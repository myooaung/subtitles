1
00:00:01,040 --> 00:00:04,010
[Autogenerated] Let's see how we can use a wiretap and a message

2
00:00:04,010 --> 00:00:07,520
store in practice to store messages that we receive on the

3
00:00:07,520 --> 00:00:11,140
registration Request channel in the database.

4
00:00:11,140 --> 00:00:16,080
In this demo will first at a wiretap to the Registration Request channel,

5
00:00:16,080 --> 00:00:20,640
which will send a copy off the incoming messages to with the back Channel.

6
00:00:20,640 --> 00:00:24,660
Then we'll configure a message store on the debug channel that will store the

7
00:00:24,660 --> 00:00:29,040
messages in a Mongo DB database where we can inspect them.

8
00:00:29,040 --> 00:00:30,150
Open example.

9
00:00:30,150 --> 00:00:33,240
Project number seven in your IDE.

10
00:00:33,240 --> 00:00:35,940
Let's first at the wiretap.

11
00:00:35,940 --> 00:00:39,170
Look up the definition off the registration request General in

12
00:00:39,170 --> 00:00:42,840
the Spring Integration XML configuration file.

13
00:00:42,840 --> 00:00:47,210
A wiretap in spring integration is the type off channel interceptor,

14
00:00:47,210 --> 00:00:51,640
so we can add it to the Registration Request channel by adding an in

15
00:00:51,640 --> 00:00:57,040
interceptors element in which we put in wiretap element.

16
00:00:57,040 --> 00:00:58,970
We have to add one attribute,

17
00:00:58,970 --> 00:01:04,330
which tells the wiretap where to send a copy off the messages to Let's

18
00:01:04,330 --> 00:01:08,340
send the messages to a channel named D Back Channel.

19
00:01:08,340 --> 00:01:11,440
We'll have to define that channel as well.

20
00:01:11,440 --> 00:01:15,430
So now we have a wiretap on the Registration Request Channel,

21
00:01:15,430 --> 00:01:18,770
which sends a copy off all incoming registration

22
00:01:18,770 --> 00:01:21,940
request messages to the D Back channel.

23
00:01:21,940 --> 00:01:26,370
The next step is to configure a message store on this channel so that

24
00:01:26,370 --> 00:01:30,340
the messages are stored in a Mongo DB database.

25
00:01:30,340 --> 00:01:34,140
To do that, we first have to set up Mongo DB.

26
00:01:34,140 --> 00:01:37,740
Let's first get Mongol to be running in Docker.

27
00:01:37,740 --> 00:01:40,610
This is just a ZZ is running other software in

28
00:01:40,610 --> 00:01:43,150
Docker with the following command.

29
00:01:43,150 --> 00:01:47,440
We can create and started Docker Container with Mongo DB.

30
00:01:47,440 --> 00:01:53,310
Now let's go back to the application to use the Mongo DB Message store will

31
00:01:53,310 --> 00:01:56,590
first have to add the dependency on spring integration.

32
00:01:56,590 --> 00:02:01,830
Mongo db This spring integration module contains the Mongo DB message

33
00:02:01,830 --> 00:02:05,950
store implementation and will automatically pull in other dependencies

34
00:02:05,950 --> 00:02:09,240
that are necessary for accessing mongo DB.

35
00:02:09,240 --> 00:02:11,620
Since this is a spring boot application,

36
00:02:11,620 --> 00:02:14,400
we don't have to do a lot of configuration for Mongo

37
00:02:14,400 --> 00:02:17,820
to be in the Application properties file.

38
00:02:17,820 --> 00:02:20,800
We have to add just one line to tell it where to find

39
00:02:20,800 --> 00:02:24,240
Mongol to be and what database name to use.

40
00:02:24,240 --> 00:02:27,140
We'll have it used a database named Globomantics,

41
00:02:27,140 --> 00:02:31,140
which will be created automatically if it doesn't yet exist.

42
00:02:31,140 --> 00:02:35,960
Now we're ready to set up the Mongo DB message store we'll have to

43
00:02:35,960 --> 00:02:39,160
define a message Group store Spring Bean for It,

44
00:02:39,160 --> 00:02:44,740
which will do in the main application class Globomantics service application.

45
00:02:44,740 --> 00:02:48,230
The message store implementation class that will want to use here

46
00:02:48,230 --> 00:02:51,330
is glass of Mongo DB Channel Message store,

47
00:02:51,330 --> 00:02:53,300
so we'll create a new instance of it.

48
00:02:53,300 --> 00:02:55,040
In the being method,

49
00:02:55,040 --> 00:03:00,130
we have to pass three arguments to the constructor first are among

50
00:03:00,130 --> 00:03:04,040
Go DB factory and a mapping mongo converter.

51
00:03:04,040 --> 00:03:07,940
Now we need to get these objects from somewhere, of course.

52
00:03:07,940 --> 00:03:08,820
Fortunately,

53
00:03:08,820 --> 00:03:12,210
this is not complicated because these objects are created

54
00:03:12,210 --> 00:03:15,320
automatically by spring boot auto configuration,

55
00:03:15,320 --> 00:03:19,740
so we can just inject them in the bean method and use them.

56
00:03:19,740 --> 00:03:23,350
The third argument will pass to the constructor off Mongo DB

57
00:03:23,350 --> 00:03:26,610
Channel Message store is the name off the collection in Mongo

58
00:03:26,610 --> 00:03:29,740
db Why we wanted to store messages.

59
00:03:29,740 --> 00:03:32,740
Let's call it registrations.

60
00:03:32,740 --> 00:03:35,540
We're not completely done here yet.

61
00:03:35,540 --> 00:03:37,980
Remember that at the end of the last clip,

62
00:03:37,980 --> 00:03:41,520
I explained that there are some limitations that you have to take into

63
00:03:41,520 --> 00:03:46,140
account when storing messages into a persistent message store.

64
00:03:46,140 --> 00:03:49,640
You have to make sure that any objects that may appear in the

65
00:03:49,640 --> 00:03:53,000
headers or payload off messages can be stored and retrieved

66
00:03:53,000 --> 00:03:55,540
from the message store correctly.

67
00:03:55,540 --> 00:04:00,440
In this case, there are two types of objects that may cause problems.

68
00:04:00,440 --> 00:04:05,660
Message headers in registration messages will contain or cough spring framework.

69
00:04:05,660 --> 00:04:10,710
HTTP dot media type objects that cannot be stored directly

70
00:04:10,710 --> 00:04:14,650
on our own class at any registration that's used as the

71
00:04:14,650 --> 00:04:16,980
payload of registration messages.

72
00:04:16,980 --> 00:04:23,040
Contains an offset daytime field that mongo DB gone Tantalus Well,

73
00:04:23,040 --> 00:04:28,540
To handle this, we need to add and register some custom converters.

74
00:04:28,540 --> 00:04:32,460
We can do this by providing a mongo custom conversions.

75
00:04:32,460 --> 00:04:33,740
Bean.

76
00:04:33,740 --> 00:04:39,140
The converters I've used here are included with the example project as well.

77
00:04:39,140 --> 00:04:42,260
I won't show them in detail, but they're just very simple.

78
00:04:42,260 --> 00:04:45,860
Converters that convert media type and offset daytime

79
00:04:45,860 --> 00:04:49,140
objects into strings and vice versa.

80
00:04:49,140 --> 00:04:50,360
Side note.

81
00:04:50,360 --> 00:04:54,030
Spring integration actually has another mongo DB message store

82
00:04:54,030 --> 00:04:59,840
implementation in class Mongo DB Message store instead of the class

83
00:04:59,840 --> 00:05:04,340
Mongo DB Channel message store that refused here.

84
00:05:04,340 --> 00:05:07,580
That seems to be an older implementation that works in a

85
00:05:07,580 --> 00:05:10,690
slightly different way and also the way you have to

86
00:05:10,690 --> 00:05:13,840
configure custom converters is different.

87
00:05:13,840 --> 00:05:19,540
It won't recognize the converters defined in our mongo custom conversions bean.

88
00:05:19,540 --> 00:05:23,220
I recommend that you use mongo db General Message store

89
00:05:23,220 --> 00:05:25,810
unless you have a special reason to use Mongo.

90
00:05:25,810 --> 00:05:27,840
DB Message store.

91
00:05:27,840 --> 00:05:29,640
End of shy note.

92
00:05:29,640 --> 00:05:31,520
Now we have our message store,

93
00:05:31,520 --> 00:05:36,040
and the last thing to do is to use it for the debug channel.

94
00:05:36,040 --> 00:05:40,140
Let's go back to the XML configuration file again.

95
00:05:40,140 --> 00:05:43,990
We'll make the debug channel acute channel by adding an inter

96
00:05:43,990 --> 00:05:47,520
que element to it to make its store messages.

97
00:05:47,520 --> 00:05:48,760
In mongo db,

98
00:05:48,760 --> 00:05:51,890
we pointed to the message store we've defined by

99
00:05:51,890 --> 00:05:54,540
setting the message store attribute.

100
00:05:54,540 --> 00:05:57,340
Now we're ready to run the demo.

101
00:05:57,340 --> 00:06:02,240
We have mongo DB running and also make sure that greenmail is running.

102
00:06:02,240 --> 00:06:06,140
Then start up the services off the demo application.

103
00:06:06,140 --> 00:06:09,110
Before we shoot in some registration messages,

104
00:06:09,110 --> 00:06:12,750
it's worth mentioning that the wiretap can also be controlled.

105
00:06:12,750 --> 00:06:14,640
Fire J M X.

106
00:06:14,640 --> 00:06:19,470
By default, the wiretap is running, which we can see via JPA console.

107
00:06:19,470 --> 00:06:23,500
But it's also possible to stop it so via J.

108
00:06:23,500 --> 00:06:23,630
M.

109
00:06:23,630 --> 00:06:25,760
X or via the control bus.

110
00:06:25,760 --> 00:06:29,640
We can switch the wiretap on and off as needed.

111
00:06:29,640 --> 00:06:34,740
Note that it's always started automatically when the application is started.

112
00:06:34,740 --> 00:06:35,900
Unfortunately,

113
00:06:35,900 --> 00:06:39,110
the wiretap does not have an auto started property

114
00:06:39,110 --> 00:06:41,090
like we saw in an earlier demo,

115
00:06:41,090 --> 00:06:44,510
where we add that the email retry components so that we can have

116
00:06:44,510 --> 00:06:47,940
it turned off after starting the application.

117
00:06:47,940 --> 00:06:53,040
Let's now start the low generator test to get some messages into this system.

118
00:06:53,040 --> 00:06:57,640
We can now take a look at the messages in mongo db to do this,

119
00:06:57,640 --> 00:06:58,850
run the following command,

120
00:06:58,850 --> 00:07:02,190
which will start the Mongo shell in the Docker container by Mongo.

121
00:07:02,190 --> 00:07:05,320
DB, is running in the Mongo Shell.

122
00:07:05,320 --> 00:07:10,340
The command show DVS shows us what database is exist.

123
00:07:10,340 --> 00:07:13,280
We want to take a look at the Globomantics database,

124
00:07:13,280 --> 00:07:18,640
so let's center use Globomantics to make it the current database.

125
00:07:18,640 --> 00:07:22,850
The command show collections tells us that there's one collection

126
00:07:22,850 --> 00:07:28,210
named Registrations with D B that registrations count.

127
00:07:28,210 --> 00:07:31,610
We can see how many documents there are in the collection,

128
00:07:31,610 --> 00:07:35,740
and now we can, of course, to queries to see the contents.

129
00:07:35,740 --> 00:07:39,240
For example, let's try DevOps load registrations,

130
00:07:39,240 --> 00:07:43,440
not find, which will show us the first few documents.

131
00:07:43,440 --> 00:07:44,360
As you can see,

132
00:07:44,360 --> 00:07:47,530
the documents correspond to the messages that the wiretaps

133
00:07:47,530 --> 00:07:49,940
saw on the Registration Request channel,

134
00:07:49,940 --> 00:07:58,000
including the headers, that payload and some other fields. You can get out of the Mongol shell by typing exit

