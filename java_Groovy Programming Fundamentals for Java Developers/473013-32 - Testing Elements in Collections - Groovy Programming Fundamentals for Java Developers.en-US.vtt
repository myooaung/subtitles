WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.025
We also have two other methods which we can look up,

00:00:02.025 --> 00:00:03.360
which are every in any.

00:00:03.360 --> 00:00:05.520
So whereas we had before find all,

00:00:05.520 --> 00:00:06.990
gets all of the matching elements,

00:00:06.990 --> 00:00:08.820
find just gets the first one.

00:00:08.820 --> 00:00:12.765
And these methods as return back the elements themselves or the element itself,

00:00:12.765 --> 00:00:15.360
every and any work to return a boolean.

00:00:15.360 --> 00:00:17.175
So we'll see this in action now.

00:00:17.175 --> 00:00:19.780
We convert this to every.

00:00:20.150 --> 00:00:24.285
What this is gonna do is it's going to go through this map.

00:00:24.285 --> 00:00:27.180
And for each of these person objects is going to run

00:00:27.180 --> 00:00:31.095
this test to see if the age is greater than or equal to 40.

00:00:31.095 --> 00:00:34.560
And if and only if all the elements are greater than or

00:00:34.560 --> 00:00:38.320
equal to 40 of the Age of all elements rather is bigger than or equal to 40,

00:00:38.320 --> 00:00:43.115
then this will return true because that means that every element has the truth about it.

00:00:43.115 --> 00:00:45.575
So if we run this now, we will see that it is false.

00:00:45.575 --> 00:00:48.995
And that's because Susie's 32, she's not over 40.

00:00:48.995 --> 00:00:50.990
So therefore, that's why it's false.

00:00:50.990 --> 00:00:55.220
If we change this to make a 65 for example, and then run it.

00:00:55.220 --> 00:00:56.660
Now we see that it's true.

00:00:56.660 --> 00:00:59.450
So whereas every tests, every element,

00:00:59.450 --> 00:01:07.385
any, just hopes to find at least one element, whether it's true.

00:01:07.385 --> 00:01:11.645
So here names and ages do any do any of these have an age bigger than or equal to 40?

00:01:11.645 --> 00:01:13.565
Well, yes, they all do.

00:01:13.565 --> 00:01:15.050
That's what we get true here.

00:01:15.050 --> 00:01:18.575
If we put Susie back to 32 and rerun.

00:01:18.575 --> 00:01:23.225
But still true because we've got Simon and Robert, would you both over 40?

00:01:23.225 --> 00:01:26.255
And if we change these two, thirty, nine,

00:01:26.255 --> 00:01:31.040
and thirty, now we don't have any element here now who was ages over 40.

00:01:31.040 --> 00:01:33.380
And so therefore, this will be turned false.

00:01:33.380 --> 00:01:34.700
So if we run this now,

00:01:34.700 --> 00:01:36.470
we can see in this returns false.

00:01:36.470 --> 00:01:39.230
So whereas find all and find work to

00:01:39.230 --> 00:01:42.110
return matching elements or a single matching elements,

00:01:42.110 --> 00:01:44.840
every and any work to determine if a condition is

00:01:44.840 --> 00:01:48.170
true across all elements are cross a single element.

00:01:48.170 --> 00:01:50.285
So as you can see, filtering and analyzing

00:01:50.285 --> 00:01:52.745
collections in Groovy is pretty straightforward and simple to do.

00:01:52.745 --> 00:01:56.000
So I'd encourage you to have a go making your own expressions using find all,

00:01:56.000 --> 00:01:57.335
find every and any,

00:01:57.335 --> 00:02:00.210
and get a feel for how they work firsthand.
