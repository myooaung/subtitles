WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.440
Now at this point you're probably thinking,

00:00:01.440 --> 00:00:02.955
well, what's the point in just having a matcher?

00:00:02.955 --> 00:00:04.140
We're just gonna call matches.

00:00:04.140 --> 00:00:07.170
It seems a bit weird that we used in this kind of groovy like syntax here,

00:00:07.170 --> 00:00:08.625
which looks like idiomatic Groovy.

00:00:08.625 --> 00:00:11.955
But then here we're using a Java type syntax where we're calling natural method.

00:00:11.955 --> 00:00:15.045
And that's true. So if you just want to find if something matches something,

00:00:15.045 --> 00:00:18.615
we can use another operator and the other operator is called the match operator.

00:00:18.615 --> 00:00:29.255
So we can take this and use a double equals tilda.

00:00:29.255 --> 00:00:31.580
This is the match operator.

00:00:31.580 --> 00:00:33.980
And what this does is it creates

00:00:33.980 --> 00:00:36.980
a matcher and then calls the matches are immediately afterwards,

00:00:36.980 --> 00:00:38.855
and then you get back a Boolean.

00:00:38.855 --> 00:00:42.710
So here we'll see true because this does match them.

00:00:42.710 --> 00:00:45.470
So if we clear again and then rerun,

00:00:45.470 --> 00:00:47.105
we can see we have true.

00:00:47.105 --> 00:00:50.270
If we put another string and here instead,

00:00:50.270 --> 00:00:56.285
Wednesday, then we see we get false. Go back.

00:00:56.285 --> 00:00:58.190
And we get true again.

00:00:58.190 --> 00:01:00.155
So this is the match operator now.

00:01:00.155 --> 00:01:03.320
So a three operators day the pattern operator to construct

00:01:03.320 --> 00:01:07.475
the actual pattern objects which holds the regular expression find operator,

00:01:07.475 --> 00:01:11.450
which lets you create a matcher object to then perform nature-based operations

00:01:11.450 --> 00:01:13.130
on to check the actual matching of

00:01:13.130 --> 00:01:15.890
the input string with a regular expression that you've passed.

00:01:15.890 --> 00:01:17.360
And then the match operator,

00:01:17.360 --> 00:01:20.210
which is basically just an exact match of the input string

00:01:20.210 --> 00:01:23.585
against a regular expression and returns a boolean if there is an exact match.

00:01:23.585 --> 00:01:27.230
And you could also, by the way, just make this a literal as well.

00:01:27.230 --> 00:01:28.895
So that's also possible.

00:01:28.895 --> 00:01:30.320
But usually you have some kind of

00:01:30.320 --> 00:01:33.410
wildcard characters in there as well, like this, for example,

00:01:33.410 --> 00:01:36.110
we won't go into the extended syntax of how you can

00:01:36.110 --> 00:01:39.620
actually write regular expressions that's beyond the scope of this video.

00:01:39.620 --> 00:01:42.905
And if you refer to the Java doc for the Java util re-expressing class,

00:01:42.905 --> 00:01:45.560
you'll see all of the syntax that's used there.

00:01:45.560 --> 00:01:49.940
So for example, if I jump into Chrome over util,

00:01:49.940 --> 00:01:55.430
regex atom, then here you can see I get the Java doc.

00:01:55.430 --> 00:01:57.140
And as part of this Java doc,

00:01:57.140 --> 00:01:59.990
you can see the actual syntax that it accepts.

00:01:59.990 --> 00:02:02.930
So you can see this is the backslash d we referred to before.

00:02:02.930 --> 00:02:04.535
We were very much a digit.

00:02:04.535 --> 00:02:07.490
Backslash w for, actually for word characters,

00:02:07.490 --> 00:02:10.115
it's not whitespace, whitespaces, backslash s.

00:02:10.115 --> 00:02:12.080
So you can have a look at this to be able to

00:02:12.080 --> 00:02:14.315
construct the regular expressions you want to use.

00:02:14.315 --> 00:02:18.150
So have a read of that at your leisure and that should help you out.
