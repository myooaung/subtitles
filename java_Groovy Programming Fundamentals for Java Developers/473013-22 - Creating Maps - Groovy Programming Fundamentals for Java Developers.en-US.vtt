WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.850
The next collection class we'd probably think about what would be a map.

00:00:02.850 --> 00:00:06.300
So we can create a map like this.

00:00:06.300 --> 00:00:08.085
Whereas with the list,

00:00:08.085 --> 00:00:12.150
we enclose individual elements in square brackets with a map.

00:00:12.150 --> 00:00:15.525
We enclose individual entries in the map in square brackets.

00:00:15.525 --> 00:00:25.209
So for example, a1, B5, F, 17.

00:00:25.880 --> 00:00:30.360
If I run this now, again,

00:00:30.360 --> 00:00:32.505
we get this linked data structure back,

00:00:32.505 --> 00:00:34.165
and this time is a link to HashMap.

00:00:34.165 --> 00:00:36.650
Which means again that the map, when we iterate over it,

00:00:36.650 --> 00:00:39.815
we're gonna get back the values in the same order that we inserted them in.

00:00:39.815 --> 00:00:42.395
So we'll get a, then b, then f.

00:00:42.395 --> 00:00:45.050
So you can see this has a nice concise syntax.

00:00:45.050 --> 00:00:48.350
In fact, grieving gives you very nice concise syntax by effectively

00:00:48.350 --> 00:00:52.580
making these kind of collection types or the syntax for creating these collection types,

00:00:52.580 --> 00:00:54.425
first-class citizens in the language.

00:00:54.425 --> 00:00:57.830
In other words, we don't have to do deaf m equals new HashMap.

00:00:57.830 --> 00:01:01.550
And then a sequence of m dot protocols to put each individual entry in the map,

00:01:01.550 --> 00:01:04.595
we can just construct a effectively like a map literal.

00:01:04.595 --> 00:01:08.160
So it's very nice that Ruby gives us this facility to do that.
