WEBVTT
1
00:00:01.040 --> 00:00:02.740
[Autogenerated] Let's now get back to the three

2
00:00:02.740 --> 00:00:05.440
possible channel implementations.

3
00:00:05.440 --> 00:00:09.440
Possible channels implemented pulling consumer pattern.

4
00:00:09.440 --> 00:00:13.770
They work by receivers pulling messages from the channel and may buffer

5
00:00:13.770 --> 00:00:18.640
messages full of all channels are all going to point channels.

6
00:00:18.640 --> 00:00:22.560
Multiple receivers can call the receive method off a possible channel,

7
00:00:22.560 --> 00:00:27.040
but each message will be delivered to only one of the receivers.

8
00:00:27.040 --> 00:00:31.240
Let's briefly discuss the three possible channel implementations.

9
00:00:31.240 --> 00:00:33.940
First, there's Cute Channel.

10
00:00:33.940 --> 00:00:39.140
This is a simple message channel that stores messages in a queue by default.

11
00:00:39.140 --> 00:00:43.740
It uses a linked blocking queue with an unbounded capacity.

12
00:00:43.740 --> 00:00:47.160
It's possible to configure the capacity or even to replace the

13
00:00:47.160 --> 00:00:50.540
Q implementation by some other type of Q.

14
00:00:50.540 --> 00:00:52.840
When receive is called on acute channel,

15
00:00:52.840 --> 00:00:55.580
it gets the next message that's waiting in the queue,

16
00:00:55.580 --> 00:01:01.640
or it blocks until a center puts a message in the queue or a time out occurs.

17
00:01:01.640 --> 00:01:04.280
Run The Food channel is similar to Cute Channel,

18
00:01:04.280 --> 00:01:07.280
but it behaves as if it has a queue with capacity.

19
00:01:07.280 --> 00:01:08.640
Zero.

20
00:01:08.640 --> 00:01:12.760
This means that when a sender sends a message to this type of channel,

21
00:01:12.760 --> 00:01:16.640
it will block until it receiver receives the message

22
00:01:16.640 --> 00:01:18.210
and also the other way around.

23
00:01:18.210 --> 00:01:20.520
When I receiver calls to receive on the channel,

24
00:01:20.520 --> 00:01:24.140
it will block until a center sends a message.

25
00:01:24.140 --> 00:01:26.910
It's like the center and receiver agreed to meet on the

26
00:01:26.910 --> 00:01:29.940
street corner to hand over a package.

27
00:01:29.940 --> 00:01:33.010
Whoever arrives first at the street corner has to wait

28
00:01:33.010 --> 00:01:35.740
until the other one arrives there, too.

29
00:01:35.740 --> 00:01:39.840
Priority Channel is also very similar to Cute channel.

30
00:01:39.840 --> 00:01:44.490
The difference is that cute channel uses a regular first in first out queue,

31
00:01:44.490 --> 00:01:49.750
and that priority channel uses a priority queue instead by default,

32
00:01:49.750 --> 00:01:53.040
messages are ordered by looking at a special message Hatter,

33
00:01:53.040 --> 00:01:55.540
unsurprisingly named priority.

34
00:01:55.540 --> 00:01:58.620
But it's also possible to configure custom logic to order

35
00:01:58.620 --> 00:02:02.770
messages que channel and priority channel by default

36
00:02:02.770 --> 00:02:05.440
store messages only in memory.

37
00:02:05.440 --> 00:02:08.440
It's also possible to make the cubes persistent,

38
00:02:08.440 --> 00:02:12.140
for example, by storing messages in the database.

39
00:02:12.140 --> 00:02:14.500
But if you need messages to be persisted,

40
00:02:14.500 --> 00:02:18.140
it's often better to use a message broker instead.

41
00:02:18.140 --> 00:02:20.880
That's what we're going to do in the next model of this course.

42
00:02:20.880 --> 00:02:23.240
So stay tuned for that.

43
00:02:23.240 --> 00:02:26.770
Now you have a clear overview off the different types of message

44
00:02:26.770 --> 00:02:30.440
colonel implementations that spring integration provides.

45
00:02:30.440 --> 00:02:31.290
As I mentioned,

46
00:02:31.290 --> 00:02:39.000
it's really important that you understand message channels so that you can make the right decision for which message colonel to use when

