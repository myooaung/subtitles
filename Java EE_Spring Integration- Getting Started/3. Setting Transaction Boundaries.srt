1
00:00:01,040 --> 00:00:03,400
[Autogenerated] in the error scenarios where the email

2
00:00:03,400 --> 00:00:05,670
server or the building services down,

3
00:00:05,670 --> 00:00:10,030
you might have noticed that the registration is still saved in the database,

4
00:00:10,030 --> 00:00:13,740
even though the message is given back to rabid MQ.

5
00:00:13,740 --> 00:00:15,610
This happens because currently,

6
00:00:15,610 --> 00:00:19,140
the transaction boundary for the database transaction is

7
00:00:19,140 --> 00:00:22,340
only around the registration service.

8
00:00:22,340 --> 00:00:26,740
Remember that we had a transactional annotation on the service.

9
00:00:26,740 --> 00:00:30,070
The transaction starts when the register method is called and

10
00:00:30,070 --> 00:00:33,140
commits when the register method returns.

11
00:00:33,140 --> 00:00:36,690
So when an error occurs while sending email or calling the

12
00:00:36,690 --> 00:00:39,700
building service after the registration service,

13
00:00:39,700 --> 00:00:42,940
the database transaction has already committed.

14
00:00:42,940 --> 00:00:46,320
What if we want the database transaction to be committed only

15
00:00:46,320 --> 00:00:48,780
whenever a message has been handled completely,

16
00:00:48,780 --> 00:00:51,980
without errors through the whole flow and rolled back?

17
00:00:51,980 --> 00:00:55,240
Whenever an error occurs anywhere in the flow,

18
00:00:55,240 --> 00:00:58,460
it's possible to make the API inbound channel of

19
00:00:58,460 --> 00:01:00,660
after participate in the transaction,

20
00:01:00,660 --> 00:01:03,810
and since this is the entry point off the flow,

21
00:01:03,810 --> 00:01:07,940
it puts the transaction boundaries around the whole flow.

22
00:01:07,940 --> 00:01:08,890
To make this work,

23
00:01:08,890 --> 00:01:13,740
we have to set two attributes on the AM Cube and Bound channel adapter.

24
00:01:13,740 --> 00:01:18,410
We have to add channel transacted is true and transaction manager

25
00:01:18,410 --> 00:01:23,040
is transaction manager note that the name transaction manager

26
00:01:23,040 --> 00:01:26,920
refers to the default platform transaction manager Bean that

27
00:01:26,920 --> 00:01:30,800
spring Boot has initialized, and that's also used by spring data J P.

28
00:01:30,800 --> 00:01:34,240
A, which he used to access to database.

29
00:01:34,240 --> 00:01:37,580
What happens now when we run this is that these am kubectl

30
00:01:37,580 --> 00:01:39,620
analyze app to will start a transaction,

31
00:01:39,620 --> 00:01:42,340
and when the registration services called it will

32
00:01:42,340 --> 00:01:45,590
participate in the existing transaction,

33
00:01:45,590 --> 00:01:51,040
the transaction now finishes with the commit or roll back after the whole flow.

34
00:01:51,040 --> 00:01:55,800
This means that when the male outbound channel adapter or the HTTP outbound

35
00:01:55,800 --> 00:01:59,250
channel adapter for the building services throws an exception,

36
00:01:59,250 --> 00:02:02,820
the database transaction will be rolled back so that we don't

37
00:02:02,820 --> 00:02:05,700
get records in the database for messages that have not been

38
00:02:05,700 --> 00:02:08,240
completely handled successfully.

39
00:02:08,240 --> 00:02:09,320
A side note.

40
00:02:09,320 --> 00:02:12,700
Transactions in spring are normally threat local.

41
00:02:12,700 --> 00:02:15,170
So this all works because in the whole flow,

42
00:02:15,170 --> 00:02:19,010
we are only using channels that execute and receivers

43
00:02:19,010 --> 00:02:21,340
in the same threat as the center.

44
00:02:21,340 --> 00:02:23,450
As I mentioned in the previous clip,

45
00:02:23,450 --> 00:02:28,040
when I explained where exceptions go that are thrown by a receiver

46
00:02:28,040 --> 00:02:31,930
making the API channel adaptor started transaction was,

47
00:02:31,930 --> 00:02:34,640
however, just the first step.

48
00:02:34,640 --> 00:02:38,080
There are still some problems we have to solve when

49
00:02:38,080 --> 00:02:39,880
an exception occurs in the flow.

50
00:02:39,880 --> 00:02:43,480
The message is still being negatively acknowledged to rabbit MQ

51
00:02:43,480 --> 00:02:47,170
and put back on the queue so that the back and starts trying to

52
00:02:47,170 --> 00:02:50,200
process the message again continually.

53
00:02:50,200 --> 00:02:54,240
In the next clip, we'll see how we can deal with that problem.

54
00:02:54,240 --> 00:02:57,240
Another problem is that not all of the components in the

55
00:02:57,240 --> 00:03:00,840
integration flow participate in the transaction.

56
00:03:00,840 --> 00:03:03,500
The mail server and the building services are not

57
00:03:03,500 --> 00:03:07,020
transactional systems when an error occurs.

58
00:03:07,020 --> 00:03:10,860
While calling the billing system, the email has already been sent,

59
00:03:10,860 --> 00:03:13,740
and that can't easily be undone.

60
00:03:13,740 --> 00:03:18,140
We now have a particularly undesirable situation.

61
00:03:18,140 --> 00:03:20,630
When I run the demo application without the billing

62
00:03:20,630 --> 00:03:25,820
service and enter registration, then the message will continually be retried,

63
00:03:25,820 --> 00:03:29,140
but that each try and email is being sent.

64
00:03:29,140 --> 00:03:30,830
After just a few seconds.

65
00:03:30,830 --> 00:03:39,000
It will have spent these at and with hundreds of confirmation emails. We'll definitely have to do something about that

