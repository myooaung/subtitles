1
00:00:01,040 --> 00:00:04,230
[Autogenerated] in the examples you've seen until now in this module,

2
00:00:04,230 --> 00:00:09,340
we've used channels that called our receivers on the same threat as the center.

3
00:00:09,340 --> 00:00:14,440
That might not always be how you want to do things in your integration flow.

4
00:00:14,440 --> 00:00:18,240
Sometimes you will want to use an executed channel to make listeners

5
00:00:18,240 --> 00:00:21,760
error a known threats from a threat pool or acute channel to be

6
00:00:21,760 --> 00:00:25,340
able to buffer messages before processing them.

7
00:00:25,340 --> 00:00:28,100
When you use these types off message generals and the

8
00:00:28,100 --> 00:00:32,140
message Chandler throws an exception, then where does it go?

9
00:00:32,140 --> 00:00:35,180
It can't be thrown back to the center directly because the

10
00:00:35,180 --> 00:00:38,240
message Chandler is running in a different threat.

11
00:00:38,240 --> 00:00:41,540
Spring integration as a mechanism for this,

12
00:00:41,540 --> 00:00:45,850
what happens is that the original message that the handler was processing is

13
00:00:45,850 --> 00:00:49,820
package together with the exception in an error message object,

14
00:00:49,820 --> 00:00:53,140
which is sent to a special error channel,

15
00:00:53,140 --> 00:00:56,710
spring integration automatically creates a published subscribed

16
00:00:56,710 --> 00:01:00,440
channel with the name Error channel for this purpose.

17
00:01:00,440 --> 00:01:04,800
By default, spring integration subscribes a logging handler to this channel,

18
00:01:04,800 --> 00:01:08,240
which just locks the exception that occurred.

19
00:01:08,240 --> 00:01:10,650
You can, of course, subscribe your own handler,

20
00:01:10,650 --> 00:01:14,260
Students channel to handle errors if necessary.

21
00:01:14,260 --> 00:01:17,740
You can also define a channel named Error Channel Yourself,

22
00:01:17,740 --> 00:01:22,540
which will override the default error channel that spring integration provides.

23
00:01:22,540 --> 00:01:26,240
Let's see how we can use this in the demo application.

24
00:01:26,240 --> 00:01:30,940
The From Rabbit Channel that we have now is a simple direct colonel.

25
00:01:30,940 --> 00:01:35,950
Whenever the A M Q B inbound channel adaptor sends a message to this channel,

26
00:01:35,950 --> 00:01:37,440
it runs its receiver,

27
00:01:37,440 --> 00:01:42,030
which is the JSON to object transformer and the rest of the integration flow.

28
00:01:42,030 --> 00:01:43,940
On the same threat,

29
00:01:43,940 --> 00:01:46,530
suppose that we would want to run the integration

30
00:01:46,530 --> 00:01:49,540
flow on a threat from a threat pool.

31
00:01:49,540 --> 00:01:54,440
Let's add a task executable ping that manages a number of threats.

32
00:01:54,440 --> 00:01:58,150
Then let's at an inn dispatcher element to the From Rabbit

33
00:01:58,150 --> 00:02:01,640
Channel that refers to this task executable.

34
00:02:01,640 --> 00:02:04,910
Doing this makes the from Rabbit Channel and executed

35
00:02:04,910 --> 00:02:07,640
channel instead of a direct channel.

36
00:02:07,640 --> 00:02:11,610
Now the handlers in the flow, starting from the From Rabbit Channel,

37
00:02:11,610 --> 00:02:15,690
will run on one off the threats off the threat pool instead of on the rabbit.

38
00:02:15,690 --> 00:02:18,440
MQ message listeners threat.

39
00:02:18,440 --> 00:02:23,000
I can now remove the error and the attributes on the AM Coop inbound

40
00:02:23,000 --> 00:02:26,840
general adapter because it's not useful anymore.

41
00:02:26,840 --> 00:02:29,360
Exceptions will not cross their boundaries,

42
00:02:29,360 --> 00:02:32,690
so the error handler that you said he will not be called anymore to

43
00:02:32,690 --> 00:02:36,140
handle exceptions that occur in the message handlers.

44
00:02:36,140 --> 00:02:38,990
Changing the threading model also has consequences

45
00:02:38,990 --> 00:02:41,440
for the transaction boundaries.

46
00:02:41,440 --> 00:02:45,490
Since transactions are threat local and the Rabbit Am Coalition ER and

47
00:02:45,490 --> 00:02:49,140
the registration service now run in different threats.

48
00:02:49,140 --> 00:02:53,240
They will not be participating in the same transaction anymore.

49
00:02:53,240 --> 00:02:57,090
The Rabbit DOM Coalition ER and the registration service will each have

50
00:02:57,090 --> 00:03:01,240
their own independent transactions in their own threats.

51
00:03:01,240 --> 00:03:05,940
Since the transaction for the Rabbit and Coalition ER is now not useful anymore.

52
00:03:05,940 --> 00:03:07,560
I can just as well removed,

53
00:03:07,560 --> 00:03:11,510
the channel transacted and transaction manager attributes from the

54
00:03:11,510 --> 00:03:15,820
inbound channel adapter whenever an exception occurs in one of the

55
00:03:15,820 --> 00:03:17,870
handlers off the integration flow.

56
00:03:17,870 --> 00:03:23,240
What happens now is that an error message will be sent to the Error Channel.

57
00:03:23,240 --> 00:03:27,740
Let's run the application, cause an error and look at the logging.

58
00:03:27,740 --> 00:03:32,140
Let's stop the building service and then enter registration.

59
00:03:32,140 --> 00:03:34,760
If you look at the logging off the service application,

60
00:03:34,760 --> 00:03:36,740
you'll see the following.

61
00:03:36,740 --> 00:03:39,610
You will see a D buck message that shows that the message

62
00:03:39,610 --> 00:03:43,640
is being sent to the Error Channel, then the logging handler.

63
00:03:43,640 --> 00:03:48,240
That's bring integration by default subscribes to the error channel is executed,

64
00:03:48,240 --> 00:03:49,960
which locks the error,

65
00:03:49,960 --> 00:03:53,640
including the stack Trace off the exception that occurred

66
00:03:53,640 --> 00:03:55,790
to handle errors in an appropriate way.

67
00:03:55,790 --> 00:03:57,230
For your application,

68
00:03:57,230 --> 00:04:00,130
you can subscribe your own handlers to the error

69
00:04:00,130 --> 00:04:02,840
channel that do whatever is needed.

70
00:04:02,840 --> 00:04:04,140
For this example.

71
00:04:04,140 --> 00:04:07,240
Let's add an exception type router.

72
00:04:07,240 --> 00:04:09,840
This is a router that listens on the channel,

73
00:04:09,840 --> 00:04:11,150
looks at the exception,

74
00:04:11,150 --> 00:04:14,740
type in error messages on the channel and then decides what

75
00:04:14,740 --> 00:04:17,640
other channel to pass the message on to.

76
00:04:17,640 --> 00:04:22,920
We'll add an exception type router that recognizes data excess exceptions email,

77
00:04:22,920 --> 00:04:27,120
send exceptions and resource excess exceptions and passes

78
00:04:27,120 --> 00:04:29,840
them on to three separate channels.

79
00:04:29,840 --> 00:04:34,570
These three exception types correspond to the exceptions of the car when

80
00:04:34,570 --> 00:04:39,070
a database error occurs and when an error happens when sending email or

81
00:04:39,070 --> 00:04:41,840
sending a request to the building services.

82
00:04:41,840 --> 00:04:44,140
Let's stop at this point.

83
00:04:44,140 --> 00:04:45,120
I could, of course,

84
00:04:45,120 --> 00:04:54,000
now at more components that listen to the three different error channels, but I think you now understand enough about how the error channel works

