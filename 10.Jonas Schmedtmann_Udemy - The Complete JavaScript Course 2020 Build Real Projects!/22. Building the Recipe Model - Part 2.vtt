WEBVTT
1
1

00:00:01.408  -->  00:00:02.570
<v Jonas>Okay, let's keep working on our</v>
2

2

00:00:02.570  -->  00:00:03.820
recipe model now,
3

3

00:00:03.820  -->  00:00:05.930
this time writing a complex function,
4

4

00:00:05.930  -->  00:00:08.320
to process the ingredients list.
5

5

00:00:08.320  -->  00:00:10.650
And so we will use a lot of stuff here,
6

6

00:00:10.650  -->  00:00:14.720
like using array methods like map, slice, find index,
7

7

00:00:14.720  -->  00:00:17.780
and includes, and you will also learn how and why
8

8

00:00:17.780  -->  00:00:20.963
to use the eval function in JavaScript.
9

9

00:00:22.010  -->  00:00:23.700
So in this lecture, what we're trying to do,
10

10

00:00:23.700  -->  00:00:26.650
is to basically read through a list of ingredients,
11

11

00:00:26.650  -->  00:00:29.880
and in each ingredient, separate the quantity,
12

12

00:00:29.880  -->  00:00:33.030
the unit, and the description of each ingredient.
13

13

00:00:33.030  -->  00:00:36.720
So for example here, we have four ounces of cream cheese.
14

14

00:00:36.720  -->  00:00:40.770
And here we have have 1/4 of a cup of sour cream,
15

15

00:00:40.770  -->  00:00:43.120
and we need to have add them separately for two reasons,
16

16

00:00:43.120  -->  00:00:45.660
first because we later want to implement this function,
17

17

00:00:45.660  -->  00:00:49.850
where we can decrease and increase the number here,
18

18

00:00:49.850  -->  00:00:52.680
so of course, we need to have them in separate variable.
19

19

00:00:52.680  -->  00:00:54.100
And the same thing happens,
20

20

00:00:54.100  -->  00:00:56.300
when we add this to the shopping list,
21

21

00:00:56.300  -->  00:00:58.537
we also have them separated here in the number,
22

22

00:00:58.537  -->  00:01:02.210
and the unit, and then the ingredient itself.
23

23

00:01:02.210  -->  00:01:05.250
So we can for example, update this number here,
24

24

00:01:05.250  -->  00:01:07.930
and everything of course, stays the same.
25

25

00:01:07.930  -->  00:01:10.110
Okay, so we need a way to read through
26

26

00:01:10.110  -->  00:01:12.140
a list of ingredients and then parse
27

27

00:01:12.140  -->  00:01:14.500
each ingredient into the count,
28

28

00:01:14.500  -->  00:01:18.300
the unit, and the description of the ingredient.
29

29

00:01:18.300  -->  00:01:21.283
So let's take a look at a couple of our results here.
30

30

00:01:23.490  -->  00:01:25.413
So let's say pizza again.
31

31

00:01:29.380  -->  00:01:30.850
So let's what for a data hit to come back
32

32

00:01:30.850  -->  00:01:32.073
for this first recipe.
33

33

00:01:33.230  -->  00:01:35.190
And here we go,
34

34

00:01:35.190  -->  00:01:36.820
and we have our ingredients here,
35

35

00:01:36.820  -->  00:01:38.730
and you see that we have these number here,
36

36

00:01:38.730  -->  00:01:40.513
like, 4 1/2 cups,
37

37

00:01:40.513  -->  00:01:42.713
then we have some stuff here in parentheses,
38

38

00:01:43.668  -->  00:01:45.660
then we have teaspoon, we have cup,
39

39

00:01:45.660  -->  00:01:47.560
now we have cups, okay.
40

40

00:01:47.560  -->  00:01:50.740
And so all of these units, they are all different,
41

41

00:01:50.740  -->  00:01:52.130
in each of the recipes.
42

42

00:01:52.130  -->  00:01:53.770
So here we have like teaspoon,
43

43

00:01:53.770  -->  00:01:56.713
but if we go, into this last one here,
44

44

00:01:57.880  -->  00:01:58.923
let's wait for it,
45

45

00:02:02.520  -->  00:02:03.720
if we take a look here now,
46

46

00:02:03.720  -->  00:02:06.820
for example here we have tbsp, which stands for tablespoons,
47

47

00:02:06.820  -->  00:02:10.020
but then we have teaspoons again, spelled out like this.
48

48

00:02:10.020  -->  00:02:11.840
And so here we have cups,
49

49

00:02:11.840  -->  00:02:13.960
and probably somewhere else we have cup.
50

50

00:02:13.960  -->  00:02:16.240
And so we to first, before we actually start,
51

51

00:02:16.240  -->  00:02:17.580
parsing the ingredients,
52

52

00:02:17.580  -->  00:02:20.130
we first need these units to be all the same
53

53

00:02:20.130  -->  00:02:21.560
across all of the recipes.
54

54

00:02:21.560  -->  00:02:23.810
So that we don't have sometimes, teaspoon,
55

55

00:02:23.810  -->  00:02:26.350
and at other times, teaspoons,
56

56

00:02:26.350  -->  00:02:28.250
and then tbsp, and so on and so forth.
57

57

00:02:28.250  -->  00:02:31.011
So when we have cup, or teaspoon, or ounce,
58

58

00:02:31.011  -->  00:02:33.550
we always want it to be the same, okay.
59

59

00:02:33.550  -->  00:02:35.070
And we also want to get rid here,
60

60

00:02:35.070  -->  00:02:36.834
of these parentheses okay, because,
61

61

00:02:36.834  -->  00:02:39.560
they don't really add anything here,
62

62

00:02:39.560  -->  00:02:41.010
in most of the cases, okay.
63

63

00:02:41.010  -->  00:02:42.370
So we're getting rid of the parentheses,
64

64

00:02:42.370  -->  00:02:46.110
and then we need to kind of standardize the units.
65

65

00:02:46.110  -->  00:02:48.800
So let's start by doing that.
66

66

00:02:48.800  -->  00:02:51.263
So the recipe, and we add a new method,
67

67

00:02:53.020  -->  00:02:54.143
parse ingredient,
68

68

00:02:57.410  -->  00:03:00.260
and so what we're going to do is, to create a new array,
69

69

00:03:00.260  -->  00:03:02.963
with some new ingredients based on the old ones.
70

70

00:03:03.940  -->  00:03:05.263
Okay, so const,
71

71

00:03:08.200  -->  00:03:09.363
the new ingredient,
72

72

00:03:11.590  -->  00:03:15.630
is this dot ingredient, and now we will use the map method.
73

73

00:03:15.630  -->  00:03:17.990
So basically a loop of ingredient,
74

74

00:03:17.990  -->  00:03:21.330
where in each iteration, we can save new item,
75

75

00:03:21.330  -->  00:03:23.140
to this new array here.
76

76

00:03:23.140  -->  00:03:24.050
So in each of the iterations,
77

77

00:03:24.050  -->  00:03:26.300
we have to simply return a value,
78

78

00:03:26.300  -->  00:03:29.580
which will then be stored into the new ingredients array.
79

79

00:03:29.580  -->  00:03:32.280
Okay, remember that from one of the previous projects?
80

80

00:03:33.850  -->  00:03:35.470
So we pass in the element,
81

81

00:03:35.470  -->  00:03:38.060
and then we have our callback function in here, basically.
82

82

00:03:38.060  -->  00:03:40.870
And then finally we will then say that,
83

83

00:03:40.870  -->  00:03:45.483
this dot ingredient, will be the new, ingredient.
84

84

00:03:46.380  -->  00:03:49.530
Okay, so that's basically how this is going to work.
85

85

00:03:49.530  -->  00:03:53.180
And so let's define what we are going to do.
86

86

00:03:53.180  -->  00:03:57.130
So first we want uniform units,
87

87

00:03:57.130  -->  00:03:59.630
so all the units should be all the same,
88

88

00:03:59.630  -->  00:04:01.133
then we move parentheses,
89

89

00:04:04.550  -->  00:04:05.563
and finally,
90

90

00:04:10.980  -->  00:04:15.980
into count unit, and the ingredient itself.
91

91

00:04:17.800  -->  00:04:22.110
Okay, so how are we going to do this first task?
92

92

00:04:22.110  -->  00:04:25.230
Well, what I'm going to do is to create two arrays,
93

93

00:04:25.230  -->  00:04:27.120
in one array we will have the units
94

94

00:04:27.120  -->  00:04:29.610
as they appear in our ingredients,
95

95

00:04:29.610  -->  00:04:32.070
and in the second array, we will have them written,
96

96

00:04:32.070  -->  00:04:35.030
exactly like we want them to be, okay.
97

97

00:04:35.030  -->  00:04:37.203
So let's do that out here,
98

98

00:04:42.060  -->  00:04:43.293
so units long,
99

99

00:04:45.420  -->  00:04:47.543
and so let's say that we have tablespoons.
100

100

00:04:52.040  -->  00:04:54.120
But we want it to be,
101

101

00:04:54.120  -->  00:04:55.193
tbsp.
102

102

00:04:59.480  -->  00:05:02.080
And what we're going to do here, is then to loop,
103

103

00:05:02.080  -->  00:05:03.600
through this array here,
104

104

00:05:03.600  -->  00:05:06.230
and see if one of these long units is there,
105

105

00:05:06.230  -->  00:05:09.373
and if it is, then replace it by the short version.
106

106

00:05:11.480  -->  00:05:15.403
Okay, now sometimes we saw, that we also have tablespoon.
107

107

00:05:17.160  -->  00:05:19.360
Like this, okay, and that is, of course,
108

108

00:05:19.360  -->  00:05:23.080
still tbsp, and so that's one of these cases,
109

109

00:05:23.080  -->  00:05:26.040
where tablespoons or tablespoon can appear,
110

110

00:05:26.040  -->  00:05:28.420
but we still want it always to be the same.
111

111

00:05:28.420  -->  00:05:30.430
Okay, and so that's a great use case,
112

112

00:05:30.430  -->  00:05:33.860
for why we have to uniform these units like this.
113

113

00:05:33.860  -->  00:05:36.203
And the same happens with ounce.
114

114

00:05:38.700  -->  00:05:42.383
So it may appear ounce, or it may appear ounces.
115

115

00:05:46.078  -->  00:05:49.210
And of course, they should both be oz, okay.
116

116

00:05:49.210  -->  00:05:51.480
And so we have these data structures here,
117

117

00:05:51.480  -->  00:05:54.900
which store the way that it may appear in the recipe,
118

118

00:05:54.900  -->  00:05:57.660
and then the way that we actually want it to look.
119

119

00:05:57.660  -->  00:05:59.573
Now another example is teaspoon,
120

120

00:06:03.810  -->  00:06:06.683
and teaspoons, so again, a plural,
121

121

00:06:07.830  -->  00:06:11.713
but we really want the abbreviation of tsp like this.
122

122

00:06:14.830  -->  00:06:19.083
And then finally, we may also encounter cups, or pounds.
123

123

00:06:23.670  -->  00:06:25.590
And cups, we want it to cup,
124

124

00:06:25.590  -->  00:06:29.003
and pounds, we want it to be, just pounds.
125

125

00:06:30.410  -->  00:06:31.760
Alright.
126

126

00:06:31.760  -->  00:06:35.230
Now let's create a variable here called ingredient,
127

127

00:06:35.230  -->  00:06:37.963
which will be based on the current element,
128

128

00:06:39.330  -->  00:06:41.540
right, so right now this element here is
129

129

00:06:41.540  -->  00:06:43.670
each of the elements of the array.
130

130

00:06:43.670  -->  00:06:45.700
And so we said ingredient to that l,
131

131

00:06:45.700  -->  00:06:48.040
but to lower strength.
132

132

00:06:48.040  -->  00:06:49.193
Or to lowercase.
133

133

00:06:52.300  -->  00:06:54.134
Okay, and that's because,
134

134

00:06:54.134  -->  00:06:57.010
it may even sometimes appear like, with a capital T,
135

135

00:06:57.010  -->  00:06:58.340
something like this for example.
136

136

00:06:58.340  -->  00:07:00.970
But we don't want to include all of these cases here
137

137

00:07:01.834  -->  00:07:02.667
in our long units, instead,
138

138

00:07:02.667  -->  00:07:04.890
we can simply convert everything to a lowercase,
139

139

00:07:04.890  -->  00:07:06.740
and then can start from there.
140

140

00:07:06.740  -->  00:07:08.860
Okay, and I'm using a let here,
141

141

00:07:08.860  -->  00:07:12.076
because we are going to mutate this variable
142

142

00:07:12.076  -->  00:07:13.350
here in a second, and so therefore,
143

143

00:07:13.350  -->  00:07:16.970
we cannot use const, because then we could not change it.
144

144

00:07:16.970  -->  00:07:19.650
So, as I was saying we are now going to loop
145

145

00:07:19.650  -->  00:07:22.660
over the long unit, so that ones that are appearing
146

146

00:07:22.660  -->  00:07:23.713
in the ingredient.
147

147

00:07:25.610  -->  00:07:28.550
So we use for each, and this is how it's going to work.
148

148

00:07:28.550  -->  00:07:30.340
So let me first write it out,
149

149

00:07:30.340  -->  00:07:32.273
and then I'm going to explain it to you.
150

150

00:07:33.940  -->  00:07:35.680
So in our callback function,
151

151

00:07:35.680  -->  00:07:37.720
we need both the current element,
152

152

00:07:37.720  -->  00:07:41.570
which I call unit here, and then also the current index.
153

153

00:07:41.570  -->  00:07:44.280
Okay, and what we're then going to do is,
154

154

00:07:44.280  -->  00:07:46.520
to manipulate the ingredient variable,
155

155

00:07:46.520  -->  00:07:47.810
as I mentioned before,
156

156

00:07:47.810  -->  00:07:49.920
so the one that we created up here.
157

157

00:07:49.920  -->  00:07:51.033
And we will,
158

158

00:07:54.120  -->  00:07:54.953
replace.
159

159

00:07:55.870  -->  00:07:57.845
And what we're going to replace,
160

160

00:07:57.845  -->  00:07:59.630
is the current unit, so that's the unit here,
161

161

00:07:59.630  -->  00:08:01.160
in this callback function,
162

162

00:08:01.160  -->  00:08:03.533
with the unit short that we want.
163

163

00:08:05.900  -->  00:08:08.193
So unit short, at position i.
164

164

00:08:10.120  -->  00:08:12.320
Okay, does that make sense?
165

165

00:08:12.320  -->  00:08:14.110
So the tablespoons here, for example,
166

166

00:08:14.110  -->  00:08:17.900
is at position zero, and this tbsp here, is also at zero.
167

167

00:08:17.900  -->  00:08:21.390
And so if we find this tablespoons in the ingredient,
168

168

00:08:21.390  -->  00:08:23.330
then it will be replaced with the unit
169

169

00:08:23.330  -->  00:08:25.870
at the same position, but in this other array.
170

170

00:08:25.870  -->  00:08:28.350
So unit short, as we have here, okay.
171

171

00:08:28.350  -->  00:08:29.183
So again,
172

172

00:08:29.183  -->  00:08:32.820
we loop over each of these long unit possibilities,
173

173

00:08:32.820  -->  00:08:35.150
and replace that text with the shorter version,
174

174

00:08:35.150  -->  00:08:36.850
which appears in the same position.
175

175

00:08:36.850  -->  00:08:39.570
That's why we have to repeat these here, for example,
176

176

00:08:39.570  -->  00:08:40.820
tablespoons, tablespoons,
177

177

00:08:40.820  -->  00:08:42.000
they're both the same here,
178

178

00:08:42.000  -->  00:08:43.793
but we have to repeat them,
179

179

00:08:43.793  -->  00:08:45.500
so that they are still on the same position.
180

180

00:08:45.500  -->  00:08:47.160
Right, so for example, this one here,
181

181

00:08:47.160  -->  00:08:49.800
is at position number five, six, seven,
182

182

00:08:49.800  -->  00:08:52.000
so cup is at position seven in here,
183

183

00:08:52.000  -->  00:08:53.250
and in here as well.
184

184

00:08:53.250  -->  00:08:54.520
So that they can still match
185

185

00:08:54.520  -->  00:08:56.900
when we do this replacement here.
186

186

00:08:56.900  -->  00:08:59.500
Okay, and so right now, the current ingredient,
187

187

00:08:59.500  -->  00:09:02.060
no longer has the long unit, but the short unit,
188

188

00:09:02.060  -->  00:09:03.970
and so we can now move on to the second step,
189

189

00:09:03.970  -->  00:09:07.970
with our ingredient already with the short unit in there.
190

190

00:09:07.970  -->  00:09:11.361
Okay, so next up, let's remove the parentheses,
191

191

00:09:11.361  -->  00:09:12.760
and that should be a bit easier.
192

192

00:09:12.760  -->  00:09:14.230
And now sometimes when you're developing,
193

193

00:09:14.230  -->  00:09:17.230
you might now know how to accomplish a certain task,
194

194

00:09:17.230  -->  00:09:19.600
and so what you do is, to basically Google it.
195

195

00:09:19.600  -->  00:09:21.000
So let's do that together now,
196

196

00:09:21.000  -->  00:09:24.120
just so I can show you how I usually do it.
197

197

00:09:24.120  -->  00:09:24.953
Okay.
198

198

00:09:25.917  -->  00:09:28.259
So, what I would do in this case is just simply write,
199

199

00:09:28.259  -->  00:09:29.220
JavaScript,
200

200

00:09:29.220  -->  00:09:30.253
remove parentheses.
201

201

00:09:33.890  -->  00:09:36.470
Okay, so let's take a look at the results here,
202

202

00:09:36.470  -->  00:09:38.460
remove parentheses from string,
203

203

00:09:38.460  -->  00:09:40.370
remove text between parentheses.
204

204

00:09:40.370  -->  00:09:41.790
So this is here actually what,
205

205

00:09:41.790  -->  00:09:43.720
we're trying to accomplish.
206

206

00:09:43.720  -->  00:09:45.020
Then we can take a look at the example,
207

207

00:09:45.020  -->  00:09:47.260
and see if it applies to our case,
208

208

00:09:47.260  -->  00:09:48.860
and so yeah, so imagine we have this,
209

209

00:09:48.860  -->  00:09:50.320
and we want this, so,
210

210

00:09:50.320  -->  00:09:53.090
the parentheses including the text, should be gone.
211

211

00:09:53.090  -->  00:09:56.080
And so the solution is to use something like this.
212

212

00:09:56.080  -->  00:09:57.770
So we can just go ahead and copy it,
213

213

00:09:57.770  -->  00:09:59.297
and I'll will explain it to you in a second,
214

214

00:09:59.297  -->  00:10:00.856
how this works.
215

215

00:10:00.856  -->  00:10:04.063
But for now, let's simply grab it, and use it here.
216

216

00:10:05.680  -->  00:10:10.640
Okay, so we want ingredient to be ingredient,
217

217

00:10:10.640  -->  00:10:12.440
and then replace.
218

218

00:10:12.440  -->  00:10:14.480
I've yet to store it here in the new variable,
219

219

00:10:14.480  -->  00:10:17.243
because this doesn't change the underlying variable,
220

220

00:10:18.224  -->  00:10:19.460
but instead, it returns a new one.
221

221

00:10:19.460  -->  00:10:21.870
And so we have to change that result somewhere, okay.
222

222

00:10:21.870  -->  00:10:24.830
Now what is this weird replace here?
223

223

00:10:24.830  -->  00:10:27.200
That's what it is called a regular expression,
224

224

00:10:27.200  -->  00:10:29.200
and let me show that to you also here,
225

225

00:10:29.200  -->  00:10:30.427
so let's write mdn,
226

226

00:10:32.320  -->  00:10:33.573
regular expression.
227

227

00:10:36.750  -->  00:10:39.580
And regular expressions are kind of complex topic,
228

228

00:10:39.580  -->  00:10:42.640
in programming, because they're really quite confusing.
229

229

00:10:42.640  -->  00:10:44.520
But in essence, regular expressions are like
230

230

00:10:44.520  -->  00:10:47.710
patterns used to match character combinations in strings.
231

231

00:10:47.710  -->  00:10:50.150
Okay, so that's exactly what we're trying to do
232

232

00:10:50.150  -->  00:10:51.040
in our example,
233

233

00:10:51.040  -->  00:10:53.410
we're trying to match a character combination,
234

234

00:10:53.410  -->  00:10:55.180
which starts with the opening parentheses,
235

235

00:10:55.180  -->  00:10:56.490
then has some text in it,
236

236

00:10:56.490  -->  00:10:59.970
and then closes the parentheses at the end.
237

237

00:10:59.970  -->  00:11:03.980
So not going to teach you all about regular expressions,
238

238

00:11:03.980  -->  00:11:05.570
but as the basics, what you need to know,
239

239

00:11:05.570  -->  00:11:08.020
is they always start with the slashes,
240

240

00:11:08.020  -->  00:11:10.950
so they start and end, and so that's what we have here.
241

241

00:11:10.950  -->  00:11:14.287
So we start and we end here with the slash,
242

242

00:11:14.287  -->  00:11:17.460
and so we already know that this is a regular expression.
243

243

00:11:17.460  -->  00:11:18.293
Okay.
244

244

00:11:19.481  -->  00:11:21.560
So let's replace this here by, for normal quotes,
245

245

00:11:21.560  -->  00:11:23.730
which are the ones that we've been using all time.
246

246

00:11:23.730  -->  00:11:26.150
And so we want to replace everything that is
247

247

00:11:26.150  -->  00:11:28.660
inside the parentheses and the parentheses themselves,
248

248

00:11:28.660  -->  00:11:30.040
with nothing.
249

249

00:11:30.040  -->  00:11:32.740
So let's take a look again at the regular expressions,
250

250

00:11:33.850  -->  00:11:36.580
and all the symbols that are in the regular expressions,
251

251

00:11:36.580  -->  00:11:38.400
they have different meanings.
252

252

00:11:38.400  -->  00:11:40.940
So for example, if you write this hat here,
253

253

00:11:40.940  -->  00:11:43.430
then it matches the beginning of an input.
254

254

00:11:43.430  -->  00:11:46.798
Or this dollar sign here matches the end of an input,
255

255

00:11:46.798  -->  00:11:49.120
this symbol here means that the proceeding expression
256

256

00:11:49.120  -->  00:11:51.680
can happen zero or more times.
257

257

00:11:51.680  -->  00:11:53.240
And, so on and so forth.
258

258

00:11:53.240  -->  00:11:56.120
So this is really a lot of stuff that you can do here
259

259

00:11:56.120  -->  00:11:57.530
with regular expressions.
260

260

00:11:57.530  -->  00:12:01.540
Again, in order to match different situations, in a string.
261

261

00:12:01.540  -->  00:12:02.373
Okay.
262

262

00:12:02.373  -->  00:12:04.640
So let's take a look again at ours,
263

263

00:12:04.640  -->  00:12:06.960
so an arbitrary amount of spaces,
264

264

00:12:06.960  -->  00:12:09.660
after that parentheses symbol, after that,
265

265

00:12:09.660  -->  00:12:12.220
an arbitrary number of other characters,
266

266

00:12:12.220  -->  00:12:14.410
then the closing parentheses,
267

267

00:12:14.410  -->  00:12:17.150
and then again, and arbitrary number of spaces.
268

268

00:12:17.150  -->  00:12:20.303
So whenever we match that, we are going to replace it
269

269

00:12:20.303  -->  00:12:22.450
with a space, okay.
270

270

00:12:22.450  -->  00:12:24.190
And whenever you need something like this,
271

271

00:12:24.190  -->  00:12:26.850
you can usually just Google for regular expressions,
272

272

00:12:26.850  -->  00:12:28.930
for achieving something like this.
273

273

00:12:28.930  -->  00:12:30.590
So you can find regular expressions
274

274

00:12:30.590  -->  00:12:33.480
for matching certain types of phone numbers,
275

275

00:12:33.480  -->  00:12:34.960
or of an email address,
276

276

00:12:34.960  -->  00:12:37.810
or of a zip code, or whatever you need really,
277

277

00:12:37.810  -->  00:12:39.647
to match in a string,
278

278

00:12:39.647  -->  00:12:41.650
there's always a regular expression for that.
279

279

00:12:41.650  -->  00:12:43.680
And if you want to try to come up with your own,
280

280

00:12:43.680  -->  00:12:47.713
well then, you can just try to read this tutorial,
281

281

00:12:49.470  -->  00:12:50.390
or read some other tutorial online,
282

282

00:12:50.390  -->  00:12:52.530
and there are tons of them.
283

283

00:12:52.530  -->  00:12:55.890
So this one here removes for parentheses, okay,
284

284

00:12:55.890  -->  00:12:58.820
and so let's now actually try to test it out,
285

285

00:12:58.820  -->  00:13:01.110
to see how it works, at this moment.
286

286

00:13:01.110  -->  00:13:01.950
Now before we can do that,
287

287

00:13:01.950  -->  00:13:04.543
we actually have to return something from here.
288

288

00:13:05.440  -->  00:13:08.140
So return the ingredient.
289

289

00:13:08.140  -->  00:13:10.100
Okay, so as I explained at the beginning,
290

290

00:13:10.100  -->  00:13:12.270
that's how the map method here works.
291

291

00:13:12.270  -->  00:13:14.350
So in each iteration, we have to return something,
292

292

00:13:14.350  -->  00:13:17.140
which will then be saved into the current position,
293

293

00:13:17.140  -->  00:13:18.343
of the new array.
294

294

00:13:19.440  -->  00:13:22.180
Okay, now in order to not always have to,
295

295

00:13:22.180  -->  00:13:26.310
write in pizza, or whatever else you might be searching for,
296

296

00:13:26.310  -->  00:13:29.000
when we're testing, let's actually,
297

297

00:13:29.000  -->  00:13:33.483
do the same here for the load, event.
298

298

00:13:37.280  -->  00:13:39.190
Okay so basically this is just for testing,
299

299

00:13:39.190  -->  00:13:40.293
that's right at here,
300

300

00:13:42.830  -->  00:13:46.310
so whenever we test, we will start the control search,
301

301

00:13:46.310  -->  00:13:48.503
and we will, instead of getting from input,
302

302

00:13:49.870  -->  00:13:52.463
we will simply write pizza.
303

303

00:13:56.840  -->  00:13:58.483
So let's check that out.
304

304

00:14:02.960  -->  00:14:05.010
And it doesn't work,
305

305

00:14:05.010  -->  00:14:05.843
and,
306

306

00:14:06.760  -->  00:14:07.670
yeah, of course.
307

307

00:14:07.670  -->  00:14:10.003
I need to add this one here to the window.
308

308

00:14:11.900  -->  00:14:13.800
Alright, so let's wait for it.
309

309

00:14:13.800  -->  00:14:16.280
And yeah, so automatically pizza returns,
310

310

00:14:16.280  -->  00:14:18.580
instead of us having to write it here, out,
311

311

00:14:18.580  -->  00:14:19.800
all the time.
312

312

00:14:19.800  -->  00:14:21.450
Now something else that we can do here,
313

313

00:14:21.450  -->  00:14:23.580
for testing purposes again,
314

314

00:14:23.580  -->  00:14:27.450
is to, let's take a look at it,
315

315

00:14:27.450  -->  00:14:31.210
is to expose this recipe here, to our global window.
316

316

00:14:31.210  -->  00:14:32.960
Because right now, in the console,
317

317

00:14:32.960  -->  00:14:35.170
we don't have access, neither to the state,
318

318

00:14:35.170  -->  00:14:38.200
nor the recipe or the search, or any of that really,
319

319

00:14:38.200  -->  00:14:40.900
because it's not exposed to the global object.
320

320

00:14:40.900  -->  00:14:44.080
Okay, but we can't do that, so we can do,
321

321

00:14:44.080  -->  00:14:47.790
let's say, window dot r, which is going to stand for recipe,
322

322

00:14:47.790  -->  00:14:51.223
equals state, dot recipe.
323

323

00:14:55.290  -->  00:14:57.210
So testing again, and so right now,
324

324

00:14:57.210  -->  00:14:59.514
we will have access to the recipe object,
325

325

00:14:59.514  -->  00:15:00.930
right in the console,
326

326

00:15:00.930  -->  00:15:04.340
because it's on our global window object.
327

327

00:15:04.340  -->  00:15:06.513
Okay, so let's test it out again.
328

328

00:15:08.250  -->  00:15:11.460
And as soon as I select something, when it comes back,
329

329

00:15:11.460  -->  00:15:12.713
now it's type r,
330

330

00:15:14.210  -->  00:15:18.610
and indeed here it is, so here's our recipe, okay.
331

331

00:15:18.610  -->  00:15:21.940
And so now we can then go ahead and call,
332

332

00:15:21.940  -->  00:15:24.500
that parse ingredients method on it.
333

333

00:15:24.500  -->  00:15:26.960
So for example, this one here, we have,
334

334

00:15:26.960  -->  00:15:30.590
ounces, cup, cup, and ounces and tablespoons,
335

335

00:15:30.590  -->  00:15:33.050
all written out as a long form.
336

336

00:15:33.050  -->  00:15:36.713
So let's now say r dot parse ingredient,
337

337

00:15:38.620  -->  00:15:40.183
let's take a look at r again,
338

338

00:15:41.980  -->  00:15:44.780
so it should by now have changed our ingredients, right.
339

339

00:15:45.960  -->  00:15:48.300
And so it did actually replace,
340

340

00:15:48.300  -->  00:15:51.000
so now it says, ozs, to ounces,
341

341

00:15:51.000  -->  00:15:53.384
well something is not right here,
342

342

00:15:53.384  -->  00:15:56.010
but it's probably just an s that I put too much.
343

343

00:15:56.010  -->  00:15:59.350
But here it converted the tablespoon as long unit,
344

344

00:15:59.350  -->  00:16:02.980
as it was here, to tbsp, right.
345

345

00:16:02.980  -->  00:16:04.403
So that's perfect.
346

346

00:16:05.440  -->  00:16:08.770
And I see why it did that ozs thing,
347

347

00:16:08.770  -->  00:16:11.050
even if it's not written out here like this,
348

348

00:16:11.050  -->  00:16:13.320
it's because it found ounces probably,
349

349

00:16:13.320  -->  00:16:16.600
but then only replaced ounce, and so the s stayed there,
350

350

00:16:16.600  -->  00:16:18.043
and it was then ozs.
351

351

00:16:18.879  -->  00:16:20.370
And so we have turn it the other way around.
352

352

00:16:20.370  -->  00:16:21.903
So the s first,
353

353

00:16:23.120  -->  00:16:24.850
and then the singular.
354

354

00:16:24.850  -->  00:16:26.830
And the same here for teaspoons,
355

355

00:16:26.830  -->  00:16:29.040
and then only teaspoon.
356

356

00:16:29.040  -->  00:16:32.760
Okay, so that's a small detail, it's not a big deal,
357

357

00:16:32.760  -->  00:16:36.030
but I just wanted to show it to you, okay.
358

358

00:16:36.030  -->  00:16:37.763
So this is the first one here,
359

359

00:16:39.590  -->  00:16:41.003
let's say r,
360

360

00:16:42.710  -->  00:16:44.630
parse ingredients.
361

361

00:16:44.630  -->  00:16:45.853
Take a look at r,
362

362

00:16:47.730  -->  00:16:50.060
and, here we go.
363

363

00:16:50.060  -->  00:16:53.830
So we have cup, we have tsp, and we have tsp here,
364

364

00:16:53.830  -->  00:16:55.750
but we're missing the space now,
365

365

00:16:55.750  -->  00:16:58.360
okay, and that's because of the parentheses.
366

366

00:16:58.360  -->  00:17:01.055
Okay, so we remove the parentheses,
367

367

00:17:01.055  -->  00:17:02.860
and then didn't insert a new space,
368

368

00:17:02.860  -->  00:17:04.620
but instead, we removed it completely,
369

369

00:17:04.620  -->  00:17:06.720
and so the spaces are gone as well.
370

370

00:17:06.720  -->  00:17:09.210
Because remember, here we also selected the space
371

371

00:17:09.210  -->  00:17:11.437
in front and after parentheses.
372

372

00:17:11.437  -->  00:17:13.387
And so we have to add a new space here.
373

373

00:17:15.270  -->  00:17:17.943
Okay, so let's wait for it.
374

374

00:17:19.484  -->  00:17:21.000
Choose this one.
375

375

00:17:21.000  -->  00:17:22.250
Or actually, another one.
376

376

00:17:22.250  -->  00:17:23.990
Remember it can't be the same thing,
377

377

00:17:23.990  -->  00:17:25.990
because then it doesn't change the hash,
378

378

00:17:27.480  -->  00:17:28.983
oh, we have an error here.
379

379

00:17:30.260  -->  00:17:31.250
I'm not sure why.
380

380

00:17:31.250  -->  00:17:34.090
So let's try another again, so this one.
381

381

00:17:34.090  -->  00:17:35.410
And again, we get an error here,
382

382

00:17:35.410  -->  00:17:37.670
that's very weird, but it still works here.
383

383

00:17:37.670  -->  00:17:41.273
So, and so now, parsed ingredients,
384

384

00:17:42.529  -->  00:17:45.770
and let's take a look at r, and now it should be gone.
385

385

00:17:45.770  -->  00:17:50.270
So, yeah, so we have cup, and tsp, and cup,
386

386

00:17:50.270  -->  00:17:53.840
and so, yeah, so the first two steps,
387

387

00:17:53.840  -->  00:17:56.470
well for processing, are already working at this point.
388

388

00:17:56.470  -->  00:17:58.810
And so now, really comes the hardest part,
389

389

00:17:58.810  -->  00:18:01.890
which is to separate the numbers from the units,
390

390

00:18:01.890  -->  00:18:03.610
from the rest of the text.
391

391

00:18:03.610  -->  00:18:05.790
And as you can see, probably this is going to be
392

392

00:18:05.790  -->  00:18:08.190
quite difficult, because for example, in here,
393

393

00:18:08.190  -->  00:18:11.750
we have all of this, all of this should be the number,
394

394

00:18:11.750  -->  00:18:13.920
then we have the unit, then we have the text.
395

395

00:18:13.920  -->  00:18:16.470
But here, we only have this normal number,
396

396

00:18:16.470  -->  00:18:19.130
here we don't have any number at all,
397

397

00:18:19.130  -->  00:18:22.313
and let's take a look for example, at this example.
398

398

00:18:23.830  -->  00:18:25.530
So let's wait for it to come back,
399

399

00:18:27.240  -->  00:18:29.440
then we need to parse ingredients, actually,
400

400

00:18:34.100  -->  00:18:37.870
and so here you the example where we have a number,
401

401

00:18:37.870  -->  00:18:41.080
but no unit, but then again, some text.
402

402

00:18:41.080  -->  00:18:43.300
And so each situation is really different,
403

403

00:18:43.300  -->  00:18:46.390
and so we have to be prepared for all of these cases.
404

404

00:18:46.390  -->  00:18:48.450
So basically, we have the case where we have the number,
405

405

00:18:48.450  -->  00:18:50.330
the unit and the text,
406

406

00:18:50.330  -->  00:18:52.860
then we have the case where we have only the number,
407

407

00:18:52.860  -->  00:18:55.450
and just the ingredient text and no unit,
408

408

00:18:55.450  -->  00:18:59.630
and sometimes we don't have any units and any number.
409

409

00:18:59.630  -->  00:19:02.070
So just like in this example of,
410

410

00:19:02.070  -->  00:19:04.230
most of these ingredients down here.
411

411

00:19:04.230  -->  00:19:05.380
Okay,
412

412

00:19:05.380  -->  00:19:08.840
so how are we going to do this part,
413

413

00:19:08.840  -->  00:19:11.500
which is the most complex by far?
414

414

00:19:11.500  -->  00:19:13.940
Well first of all, we are going to test if there is
415

415

00:19:13.940  -->  00:19:15.980
actually a unit in the string,
416

416

00:19:15.980  -->  00:19:18.143
and if so, where it is located.
417

417

00:19:19.850  -->  00:19:21.400
Okay, so the first thing,
418

418

00:19:21.400  -->  00:19:25.143
is to convert the ingredient into an array.
419

419

00:19:29.220  -->  00:19:31.830
And I'm going to do that by splitting it,
420

420

00:19:31.830  -->  00:19:33.740
through an empty space.
421

421

00:19:33.740  -->  00:19:35.470
Okay, so whenever there is space,
422

422

00:19:35.470  -->  00:19:37.330
it will now be split, and each word,
423

423

00:19:37.330  -->  00:19:39.530
will become a new element in the array.
424

424

00:19:39.530  -->  00:19:41.420
So we've used that here before,
425

425

00:19:41.420  -->  00:19:44.140
and so I'm sure you're familiar with it already.
426

426

00:19:44.140  -->  00:19:45.850
Okay, now comes the trickier part,
427

427

00:19:45.850  -->  00:19:47.910
where we have to find the index
428

428

00:19:47.910  -->  00:19:49.973
at which the unit is located.
429

429

00:19:52.020  -->  00:19:54.253
Okay, so unit index,
430

430

00:19:58.090  -->  00:20:00.040
and so how are we going to do that?
431

431

00:20:00.040  -->  00:20:01.500
Well the first thing that comes to mind
432

432

00:20:01.500  -->  00:20:03.333
would be to use index of,
433

433

00:20:04.260  -->  00:20:06.240
like this, right.
434

434

00:20:06.240  -->  00:20:08.630
But this one is not going to work,
435

435

00:20:08.630  -->  00:20:10.130
because what we want to do is,
436

436

00:20:10.130  -->  00:20:11.940
to find the position of the unit,
437

437

00:20:11.940  -->  00:20:14.390
but we don't know what the unit is.
438

438

00:20:14.390  -->  00:20:16.780
If we knew which unit we were looking for,
439

439

00:20:16.780  -->  00:20:18.493
well then we could use index of.
440

440

00:20:19.330  -->  00:20:22.340
So for example, if we were looking for tbsp,
441

441

00:20:22.340  -->  00:20:24.560
if we already knew that, then we could simply ask,
442

442

00:20:24.560  -->  00:20:28.610
which element of the array is equal to tbsp?
443

443

00:20:28.610  -->  00:20:30.260
But it doesn't work like this in this case,
444

444

00:20:30.260  -->  00:20:32.720
because we don't know what unit we're looking for.
445

445

00:20:32.720  -->  00:20:34.790
Each ingredient has its own unit,
446

446

00:20:34.790  -->  00:20:36.960
or maybe not even a unit at all.
447

447

00:20:36.960  -->  00:20:40.520
And so what we're going to use instead, is find index.
448

448

00:20:40.520  -->  00:20:42.770
And once more, this is an ES6 method,
449

449

00:20:42.770  -->  00:20:45.700
that I actually already showed you in ES6 section,
450

450

00:20:45.700  -->  00:20:48.853
but right now, we have a more real world use case for it.
451

451

00:20:50.470  -->  00:20:53.670
Okay, so remember, into the find index function,
452

452

00:20:53.670  -->  00:20:56.140
we actually pass in a callback function.
453

453

00:20:56.140  -->  00:20:58.460
So for each element, which we're going to call,
454

454

00:20:58.460  -->  00:20:59.760
element two here in this case,
455

455

00:20:59.760  -->  00:21:02.490
because element is already taken up here.
456

456

00:21:02.490  -->  00:21:04.490
Well basically, for each of these elements,
457

457

00:21:04.490  -->  00:21:08.400
it will make a test, and what we want to test here,
458

458

00:21:08.400  -->  00:21:10.683
is units dot includes,
459

459

00:21:13.010  -->  00:21:14.160
element two.
460

460

00:21:14.160  -->  00:21:15.600
So how does this work?
461

461

00:21:15.600  -->  00:21:19.210
Well, includes is a brand new array method,
462

462

00:21:19.210  -->  00:21:21.627
I think it's like an ES7 or even an ES8,
463

463

00:21:21.627  -->  00:21:23.920
and it returns true if the element
464

464

00:21:23.920  -->  00:21:25.487
we're passing in is in the array,
465

465

00:21:25.487  -->  00:21:27.220
and it returns false, of course,
466

466

00:21:27.220  -->  00:21:29.750
if the element is not in there, okay.
467

467

00:21:29.750  -->  00:21:31.220
So what we're going to do is,
468

468

00:21:31.220  -->  00:21:34.128
for each current element, it will test,
469

469

00:21:34.128  -->  00:21:36.670
if that element is inside of the units array.
470

470

00:21:36.670  -->  00:21:38.923
And what I mean here is, unit short,
471

471

00:21:40.500  -->  00:21:44.050
so this array, with our final short unit,
472

472

00:21:44.050  -->  00:21:46.860
and so for each of the elements in the array,
473

473

00:21:46.860  -->  00:21:49.740
it will basically perform this test, okay.
474

474

00:21:49.740  -->  00:21:51.320
So again, this is like a loop,
475

475

00:21:51.320  -->  00:21:53.210
but in the case of find index,
476

476

00:21:53.210  -->  00:21:55.570
it will return the index of the position,
477

477

00:21:55.570  -->  00:21:58.820
where this test here turns out to be true, okay.
478

478

00:21:58.820  -->  00:22:02.190
So let's again use the example of ounces, for example,
479

479

00:22:02.190  -->  00:22:03.827
so it will loop over the array,
480

480

00:22:03.827  -->  00:22:05.840
and it will only return true,
481

481

00:22:05.840  -->  00:22:08.700
when there's an element in the array, that is ounces,
482

482

00:22:08.700  -->  00:22:11.200
and it will then return the index in which,
483

483

00:22:11.200  -->  00:22:13.437
this here turns out to be true, okay.
484

484

00:22:13.437  -->  00:22:16.080
And so that's the only way to find the position
485

485

00:22:16.080  -->  00:22:17.740
of the unit, when we don't really know,
486

486

00:22:17.740  -->  00:22:19.892
which unit we are looking for, okay.
487

487

00:22:19.892  -->  00:22:21.810
So this is a great trick,
488

488

00:22:21.810  -->  00:22:24.370
and a really great use case of find index,
489

489

00:22:24.370  -->  00:22:27.240
which is a great addition to the JavaScript language,
490

490

00:22:27.240  -->  00:22:30.970
so it's really a cool new method on arrays.
491

491

00:22:30.970  -->  00:22:32.373
Now as we mentioned before,
492

492

00:22:33.779  -->  00:22:35.909
there are now several different possibilities here,
493

493

00:22:35.909  -->  00:22:37.200
for the find index.
494

494

00:22:37.200  -->  00:22:39.083
So let's use an if else statement,
495

495

00:22:40.290  -->  00:22:44.173
so if unit index is greater than minus one,
496

496

00:22:46.400  -->  00:22:48.113
this means that there is a unit.
497

497

00:22:49.840  -->  00:22:51.480
Okay, so it if is minus one,
498

498

00:22:51.480  -->  00:22:53.730
then it means that it couldn't find the element,
499

499

00:22:53.730  -->  00:22:55.740
so in this case, it means that,
500

500

00:22:55.740  -->  00:22:58.080
all of this here turned to be false.
501

501

00:22:58.080  -->  00:23:00.060
So basically, if none of these words here,
502

502

00:23:00.060  -->  00:23:04.080
appear in the array, so in our original string here,
503

503

00:23:04.080  -->  00:23:06.400
then that means that this unit index,
504

504

00:23:06.400  -->  00:23:08.187
will turn out to be minus one.
505

505

00:23:09.800  -->  00:23:12.773
Okay, so we can actually already add that one here,
506

506

00:23:13.710  -->  00:23:14.963
unit index,
507

507

00:23:17.640  -->  00:23:20.963
is minus one, then that means,
508

508

00:23:22.640  -->  00:23:24.393
there is no unit.
509

509

00:23:25.520  -->  00:23:29.163
Okay, but actually there is another case.
510

510

00:23:33.250  -->  00:23:36.270
Okay, so that's the case where there is no unit,
511

511

00:23:36.270  -->  00:23:37.860
but still there is a number.
512

512

00:23:37.860  -->  00:23:40.470
Remember, so for example, one bread,
513

513

00:23:40.470  -->  00:23:41.820
that doesn't really need a unit,
514

514

00:23:41.820  -->  00:23:45.550
but there is a number, and there is text, okay.
515

515

00:23:45.550  -->  00:23:47.840
And so we assume that the number always
516

516

00:23:47.840  -->  00:23:49.910
appears in the same position.
517

517

00:23:49.910  -->  00:23:52.563
And so what we're going to do is to,
518

518

00:23:53.440  -->  00:23:57.050
say array, ingredient zero, which is the first position,
519

519

00:23:57.050  -->  00:23:59.853
then we're going to parse it to a number, an integer,
520

520

00:24:03.660  -->  00:24:05.400
with the base of 10, remember.
521

521

00:24:05.400  -->  00:24:07.580
And so if this is successful here,
522

522

00:24:07.580  -->  00:24:09.480
so if it can be converted to a number,
523

523

00:24:09.480  -->  00:24:12.010
well then this here will return the number itself,
524

524

00:24:12.010  -->  00:24:15.040
and will therefore coerce into true here.
525

525

00:24:15.040  -->  00:24:16.430
Okay.
526

526

00:24:16.430  -->  00:24:19.173
There is, no unit,
527

527

00:24:24.290  -->  00:24:26.850
but the first element is a number, okay.
528

528

00:24:26.850  -->  00:24:30.210
So again, we're taking the first element of the array,
529

529

00:24:30.210  -->  00:24:31.970
and we convert it to a number.
530

530

00:24:31.970  -->  00:24:33.820
And if the conversion is successful,
531

531

00:24:33.820  -->  00:24:35.540
well then it will return that number,
532

532

00:24:35.540  -->  00:24:37.350
which will then coerce to true.
533

533

00:24:37.350  -->  00:24:38.915
And if it's not a number,
534

534

00:24:38.915  -->  00:24:39.970
then it will return not a number,
535

535

00:24:39.970  -->  00:24:41.420
which will coerce to false.
536

536

00:24:41.420  -->  00:24:43.420
Let me actually try to show that to you,
537

537

00:24:44.470  -->  00:24:46.203
so let's use parse int,
538

538

00:24:47.110  -->  00:24:50.003
with this string here.
539

539

00:24:51.240  -->  00:24:52.690
And so it returns 234,
540

540

00:24:52.690  -->  00:24:53.830
which is a number,
541

541

00:24:53.830  -->  00:24:55.770
but if we had something else,
542

542

00:24:55.770  -->  00:24:59.410
so text, well then it returns not a number,
543

543

00:24:59.410  -->  00:25:01.748
and that will then, in turn, coerce to false,
544

544

00:25:01.748  -->  00:25:04.250
leaving us with the third option,
545

545

00:25:04.250  -->  00:25:05.290
which is this here.
546

546

00:25:05.290  -->  00:25:06.283
There's no unit,
547

547

00:25:07.410  -->  00:25:10.563
and no number, in first position.
548

548

00:25:12.650  -->  00:25:14.710
So this one is the most straightforward case,
549

549

00:25:14.710  -->  00:25:17.710
and so let's go ahead and start with this one.
550

550

00:25:17.710  -->  00:25:20.440
Okay, so the first thing we're going to do,
551

551

00:25:20.440  -->  00:25:22.370
is to create a new variable here,
552

552

00:25:22.370  -->  00:25:24.810
and will have to be let, and not a const,
553

553

00:25:24.810  -->  00:25:28.300
and also it has to be outside of each of these blocks here,
554

554

00:25:28.300  -->  00:25:31.060
because again, let and const, are block scoped,
555

555

00:25:31.060  -->  00:25:32.920
okay, and so we need to define them outside of the blocks,
556

556

00:25:32.920  -->  00:25:36.330
and then mutate them inside of one of these blocks.
557

557

00:25:36.330  -->  00:25:38.580
So, this is the final object that
558

558

00:25:38.580  -->  00:25:40.100
we're actually going to return,
559

559

00:25:40.100  -->  00:25:42.623
which is the object ingredient.
560

560

00:25:43.590  -->  00:25:45.870
Okay, and for now, it's empty in here,
561

561

00:25:45.870  -->  00:25:47.743
we're just like, initializing it.
562

562

00:25:51.490  -->  00:25:55.703
So our ingredient object will always have the count,
563

563

00:25:57.960  -->  00:25:59.593
it will have the unit,
564

564

00:26:02.710  -->  00:26:04.983
and it will have the ingredient itself.
565

565

00:26:06.520  -->  00:26:08.320
Now in the case that we have no unit,
566

566

00:26:08.320  -->  00:26:10.760
while the unit is empty, I will simply say,
567

567

00:26:10.760  -->  00:26:13.590
that it is one, because he have to put something here,
568

568

00:26:13.590  -->  00:26:16.230
and so rather than putting, like, zero, or something,
569

569

00:26:16.230  -->  00:26:17.680
we simply put one.
570

570

00:26:17.680  -->  00:26:19.460
So for example, if it says tomato sauce,
571

571

00:26:19.460  -->  00:26:20.450
without an ingredient,
572

572

00:26:20.450  -->  00:26:23.670
well, we just say that we need one tomato sauce, okay.
573

573

00:26:23.670  -->  00:26:26.680
And now as for the ingredient itself,
574

574

00:26:26.680  -->  00:26:28.730
well, if there's no number, no unit,
575

575

00:26:28.730  -->  00:26:32.930
all we really want is the entire ingredient, okay.
576

576

00:26:32.930  -->  00:26:35.860
So that variable here, that we split it up,
577

577

00:26:35.860  -->  00:26:36.960
right in the beginning.
578

578

00:26:36.960  -->  00:26:40.190
So we can say ingredient, or even better,
579

579

00:26:40.190  -->  00:26:43.826
in ES6, when we have an object that is like this,
580

580

00:26:43.826  -->  00:26:45.580
when we say ingredient, is ingredient,
581

581

00:26:45.580  -->  00:26:47.100
we don't need any of this,
582

582

00:26:47.100  -->  00:26:48.880
we can simply do it like this.
583

583

00:26:48.880  -->  00:26:51.570
So instead of having to repeat it, we just put ingredient,
584

584

00:26:51.570  -->  00:26:53.010
and well, it will automatically then
585

585

00:26:53.010  -->  00:26:55.261
create this property ingredient,
586

586

00:26:55.261  -->  00:26:57.010
and assign the value to it.
587

587

00:26:57.010  -->  00:27:00.980
In this case, this one, okay.
588

588

00:27:00.980  -->  00:27:05.480
So, next up, we do the one where there's no unit,
589

589

00:27:05.480  -->  00:27:06.960
but the first element is a number.
590

590

00:27:06.960  -->  00:27:09.073
So this one is also not really hard.
591

591

00:27:12.150  -->  00:27:14.773
So the number, we already know, is this one here,
592

592

00:27:15.640  -->  00:27:16.943
so let's just copy it,
593

593

00:27:20.520  -->  00:27:24.573
so count, the unit, where you don't have, again,
594

594

00:27:27.130  -->  00:27:28.700
and then the ingredient,
595

595

00:27:28.700  -->  00:27:32.310
well, it just the entire array, except the first element.
596

596

00:27:32.310  -->  00:27:34.720
So the first element here is for the number,
597

597

00:27:34.720  -->  00:27:37.463
and the rest of the array is the ingredient.
598

598

00:27:38.890  -->  00:27:42.760
So array ingredient, then we sliced it,
599

599

00:27:42.760  -->  00:27:45.460
and said that we only want to start at position number one,
600

600

00:27:45.460  -->  00:27:47.360
and if we don't specify the second argument,
601

601

00:27:47.360  -->  00:27:50.200
it goes all the way to the end, which is what we want.
602

602

00:27:50.200  -->  00:27:51.970
And so we have now, the entire array,
603

603

00:27:51.970  -->  00:27:53.650
except the first element.
604

604

00:27:53.650  -->  00:27:55.630
And now we have to put all these array elements
605

605

00:27:55.630  -->  00:28:00.460
back into a string, using of course, the join method.
606

606

00:28:00.460  -->  00:28:03.320
Okay, so we had all of these array elements, like,
607

607

00:28:03.320  -->  00:28:05.600
Italian, tomato and sauce,
608

608

00:28:05.600  -->  00:28:08.230
and now we just put them back together into a string here,
609

609

00:28:08.230  -->  00:28:09.540
with this join.
610

610

00:28:09.540  -->  00:28:11.884
Okay, so these are the two easier cases.
611

611

00:28:11.884  -->  00:28:14.067
Let's now test it out before we start
612

612

00:28:14.067  -->  00:28:16.423
with the more difficult one, which is this one.
613

613

00:28:18.980  -->  00:28:21.770
Alright, let's wait for it.
614

614

00:28:21.770  -->  00:28:22.950
I guess it's getting,
615

615

00:28:22.950  -->  00:28:23.870
yeah.
616

616

00:28:23.870  -->  00:28:25.090
So,
617

617

00:28:25.090  -->  00:28:26.710
let's take a look.
618

618

00:28:26.710  -->  00:28:28.943
Let's r parse ingredients,
619

619

00:28:33.600  -->  00:28:37.297
and let's take a look, and nothing really happened here,
620

620

00:28:37.297  -->  00:28:39.370
and I know why this is happening.
621

621

00:28:39.370  -->  00:28:42.600
It's because we didn't return the object,
622

622

00:28:42.600  -->  00:28:45.280
but instead, we just returned the ingredient string,
623

623

00:28:45.280  -->  00:28:47.030
so the one that we were working with,
624

624

00:28:47.030  -->  00:28:49.560
up until point number three.
625

625

00:28:49.560  -->  00:28:51.713
Okay, so let's do all of this again.
626

626

00:28:54.010  -->  00:28:56.260
And you see that it already got back here,
627

627

00:28:56.260  -->  00:28:59.603
with the recipe, so that's parsed ingredients.
628

628

00:29:03.560  -->  00:29:06.070
And so here you see, some of these say undefined,
629

629

00:29:06.070  -->  00:29:08.176
and that's fine, because we didn't yet
630

630

00:29:08.176  -->  00:29:09.009
take care of the first case.
631

631

00:29:09.009  -->  00:29:10.902
But the other ones, they now say one,
632

632

00:29:10.902  -->  00:29:14.160
when the unit is empty, and then we have the ingredient.
633

633

00:29:14.160  -->  00:29:16.903
And so if you compare that with the initial state,
634

634

00:29:17.970  -->  00:29:20.310
well we see that it's exactly correct.
635

635

00:29:20.310  -->  00:29:23.180
Right, so here we had just these strings,
636

636

00:29:23.180  -->  00:29:26.430
and then now we have all of these objects.
637

637

00:29:26.430  -->  00:29:28.760
Where it says always one, then unit,
638

638

00:29:28.760  -->  00:29:29.870
and then the ingredient.
639

639

00:29:29.870  -->  00:29:32.853
Let's see if we can do the same with another one.
640

640

00:29:35.480  -->  00:29:39.233
So let's say, parse ingredients,
641

641

00:29:44.390  -->  00:29:46.590
and now we actually have all of them undefined,
642

642

00:29:46.590  -->  00:29:48.290
except the last one, okay.
643

643

00:29:48.290  -->  00:29:50.180
So let's take this one here as an example to see
644

644

00:29:50.180  -->  00:29:53.100
what we have to, to do next.
645

645

00:29:53.100  -->  00:29:54.680
So you see that for example here,
646

646

00:29:54.680  -->  00:29:57.970
the unit is the third element of the array, right.
647

647

00:29:57.970  -->  00:30:00.071
So the first element will be 1/4,
648

648

00:30:00.071  -->  00:30:01.837
and then the second element will be just 1/2,
649

649

00:30:01.837  -->  00:30:04.070
and then the third element will be the cups.
650

650

00:30:04.070  -->  00:30:06.570
But then in this case, in number two,
651

651

00:30:06.570  -->  00:30:08.458
well the first one is the number,
652

652

00:30:08.458  -->  00:30:10.830
and then already the second one is the unit, okay.
653

653

00:30:10.830  -->  00:30:13.090
And so what we will do is assume that everything
654

654

00:30:13.090  -->  00:30:15.940
that comes for a unit will always be the number.
655

655

00:30:15.940  -->  00:30:18.740
Okay, so in this case, we will say that 4 1/2,
656

656

00:30:18.740  -->  00:30:22.040
will be the number, and then after that comes the unit.
657

657

00:30:22.040  -->  00:30:25.213
Okay, so let's implement what I just said.
658

658

00:30:27.450  -->  00:30:28.283
So const,
659

659

00:30:29.860  -->  00:30:32.053
I'm going to call this one here array count,
660

660

00:30:34.960  -->  00:30:37.713
is in array ingredients slice,
661

661

00:30:38.840  -->  00:30:42.483
from the beginning until the unit index, excluding.
662

662

00:30:43.870  -->  00:30:46.660
Okay, so if the index is number two,
663

663

00:30:46.660  -->  00:30:49.080
well that means that position zero and one,
664

664

00:30:49.080  -->  00:30:51.320
will be for the count, okay.
665

665

00:30:51.320  -->  00:30:52.960
So just like in the last example,
666

666

00:30:52.960  -->  00:30:55.840
where 1 1/2 were the first two positions,
667

667

00:30:55.840  -->  00:30:58.720
so these two are the part of the count.
668

668

00:30:58.720  -->  00:31:00.890
Let me write that down here actually.
669

669

00:31:00.890  -->  00:31:05.283
Example 4 1/2 cups,
670

670

00:31:08.190  -->  00:31:11.363
our count will be 4 1/2.
671

671

00:31:13.380  -->  00:31:15.450
Okay, and now we need to figure out,
672

672

00:31:15.450  -->  00:31:18.513
a number out of these values here, okay.
673

673

00:31:18.513  -->  00:31:20.693
Now let's actually get this here,
674

674

00:31:21.640  -->  00:31:23.020
and I will put another example,
675

675

00:31:23.020  -->  00:31:26.220
because there can be, of course different example,
676

676

00:31:26.220  -->  00:31:29.793
so if it was four cups, well then our count,
677

677

00:31:32.583  -->  00:31:34.400
is just four, right.
678

678

00:31:34.400  -->  00:31:36.450
And so we have different situations here.
679

679

00:31:39.120  -->  00:31:42.610
So you see that this is getting quite complex,
680

680

00:31:42.610  -->  00:31:46.870
and of course, this is just a great exercise to think,
681

681

00:31:46.870  -->  00:31:49.230
so it's not really important that you memorize
682

682

00:31:49.230  -->  00:31:51.510
how you can parse recipe ingredients.
683

683

00:31:51.510  -->  00:31:53.900
But it's important that you understand
684

684

00:31:53.900  -->  00:31:55.610
the thought process that you go through,
685

685

00:31:55.610  -->  00:31:57.050
in order to figure out how to
686

686

00:31:57.050  -->  00:31:58.450
accomplish the goal that you have.
687

687

00:31:58.450  -->  00:32:01.300
In this case, well it's parsing our ingredients
688

688

00:32:01.300  -->  00:32:04.270
into a, that we defined initially, okay.
689

689

00:32:04.270  -->  00:32:06.310
And so we use the tools that we have,
690

690

00:32:06.310  -->  00:32:08.870
in order achieve a goal that we established.
691

691

00:32:08.870  -->  00:32:10.600
And that's what coding is all about,
692

692

00:32:10.600  -->  00:32:12.220
okay, so that's what I want you to understand.
693

693

00:32:12.220  -->  00:32:14.300
It's not really memorizing that it want you to do,
694

694

00:32:14.300  -->  00:32:16.280
it's just understanding how we can use
695

695

00:32:16.280  -->  00:32:19.000
these different tools to achieve exactly what we need.
696

696

00:32:19.000  -->  00:32:21.090
So again, we have these two cases here,
697

697

00:32:21.090  -->  00:32:23.519
where there's more than two elements before the unit,
698

698

00:32:23.519  -->  00:32:26.160
and also the case where we have just one number.
699

699

00:32:26.160  -->  00:32:28.410
And in this case, it's really simple.
700

700

00:32:28.410  -->  00:32:29.853
So let's say, if,
701

701

00:32:31.280  -->  00:32:33.400
our count dot length,
702

702

00:32:33.400  -->  00:32:35.360
which is what defines how many elements
703

703

00:32:35.360  -->  00:32:36.983
there are before the unit.
704

704

00:32:38.150  -->  00:32:39.333
So if it's just one,
705

705

00:32:41.045  -->  00:32:44.947
then the count is array inc, zero.
706

706

00:32:47.418  -->  00:32:50.780
And actually I have to define the count before,
707

707

00:32:50.780  -->  00:32:53.290
so just the situation that we had before,
708

708

00:32:53.290  -->  00:32:55.233
so defining it outside of the block.
709

709

00:32:56.260  -->  00:33:00.180
Okay, so if there's only one element before the unit,
710

710

00:33:00.180  -->  00:33:02.940
well then that element is of course the number itself.
711

711

00:33:02.940  -->  00:33:05.660
So the count is then array inc zero.
712

712

00:33:05.660  -->  00:33:07.270
And that's not yet the final story,
713

713

00:33:07.270  -->  00:33:10.350
but for now, let's assume that this is how it works.
714

714

00:33:10.350  -->  00:33:11.650
Now if we have more than one number,
715

715

00:33:11.650  -->  00:33:13.940
which is usually like, something like this,
716

716

00:33:13.940  -->  00:33:18.250
so 4 1/2, or 1 2/3, something like this,
717

717

00:33:18.250  -->  00:33:21.100
well then we have to do it differently.
718

718

00:33:21.100  -->  00:33:23.400
And so now I'm going to show you the eval function,
719

719

00:33:23.400  -->  00:33:24.600
that I mentioned before.
720

720

00:33:25.830  -->  00:33:27.820
So what we're going to do is to basically join
721

721

00:33:27.820  -->  00:33:29.120
these two strings,
722

722

00:33:29.120  -->  00:33:31.300
because they are strings in this array here, okay.
723

723

00:33:31.300  -->  00:33:32.590
We're never talking about numbers,
724

724

00:33:32.590  -->  00:33:34.410
it's really just strings.
725

725

00:33:34.410  -->  00:33:37.560
So we're going to join these two strings using a plus sign,
726

726

00:33:37.560  -->  00:33:40.120
and then do something called evaluate the string.
727

727

00:33:40.120  -->  00:33:41.990
Okay, so I'm going to explain to you,
728

728

00:33:41.990  -->  00:33:42.963
how and why,
729

729

00:33:44.530  -->  00:33:46.423
so the array of ingredient,
730

730

00:33:47.617  -->  00:33:49.970
dot slice, from the beginning,
731

731

00:33:49.970  -->  00:33:51.603
until the unit index.
732

732

00:33:53.510  -->  00:33:56.170
Right, so on these first elements,
733

733

00:33:56.170  -->  00:33:57.633
we are going to join them,
734

734

00:33:58.480  -->  00:34:00.520
using the plus sign,
735

735

00:34:00.520  -->  00:34:02.313
and we will then evaluate,
736

736

00:34:04.550  -->  00:34:06.650
whatever is the result of that.
737

737

00:34:06.650  -->  00:34:08.280
Okay, and we wouldn't have to do it like this,
738

738

00:34:08.280  -->  00:34:10.180
but this is just a great opportunity to,
739

739

00:34:10.180  -->  00:34:11.440
to show you this function here,
740

740

00:34:11.440  -->  00:34:12.950
that you might encounter someday
741

741

00:34:12.950  -->  00:34:15.330
when you're looking at some JavaScript code, okay.
742

742

00:34:15.330  -->  00:34:16.750
So this one here, for example,
743

743

00:34:16.750  -->  00:34:18.900
well, turns out to be string,
744

744

00:34:18.900  -->  00:34:20.343
four plus, 1 1/2.
745

745

00:34:22.080  -->  00:34:24.931
Okay, and eval will then do is it will evaluate
746

746

00:34:24.931  -->  00:34:28.630
this string here as being a JavaScript code.
747

747

00:34:28.630  -->  00:34:30.170
And so it will do the math here,
748

748

00:34:30.170  -->  00:34:31.663
and calculate 4.5.
749

749

00:34:33.320  -->  00:34:35.113
Okay, so if we do eval of this,
750

750

00:34:37.890  -->  00:34:41.190
well this will then turn out the be 4.5, okay.
751

751

00:34:41.190  -->  00:34:44.670
So does this way of calculating here makes sense to you?
752

752

00:34:44.670  -->  00:34:46.831
Now this is almost done now,
753

753

00:34:46.831  -->  00:34:50.010
there's just one edge case that we also need to talk about.
754

754

00:34:50.010  -->  00:34:53.430
Which is what happens in this recipe here.
755

755

00:34:53.430  -->  00:34:54.933
So, let's wait for it.
756

756

00:34:58.450  -->  00:35:00.530
So you see here in ingredients,
757

757

00:35:00.530  -->  00:35:03.050
that some of them, they have this dash,
758

758

00:35:03.050  -->  00:35:05.380
so instead of being 1 1/3,
759

759

00:35:05.380  -->  00:35:06.940
it's one minus 1/3,
760

760

00:35:06.940  -->  00:35:09.530
but it really mean one plus 1/3.
761

761

00:35:09.530  -->  00:35:11.110
So it's 1 1/2 here, for example,
762

762

00:35:11.110  -->  00:35:13.590
not one minus 1/2, okay,
763

763

00:35:13.590  -->  00:35:15.680
and so that is actually not good.
764

764

00:35:15.680  -->  00:35:18.360
Because none of cases currently covers this.
765

765

00:35:18.360  -->  00:35:19.800
But what we could do here is,
766

766

00:35:19.800  -->  00:35:22.089
to simply replace this minus with this plus,
767

767

00:35:22.089  -->  00:35:24.370
and then evaluate that string as well,
768

768

00:35:24.370  -->  00:35:25.603
just like we did before.
769

769

00:35:26.990  -->  00:35:29.150
Okay, and so that's actually pretty easy,
770

770

00:35:29.150  -->  00:35:31.423
all we have to do here is to replace,
771

771

00:35:35.660  -->  00:35:36.963
the minus with a plus.
772

772

00:35:39.200  -->  00:35:41.340
And then finally, of course,
773

773

00:35:41.340  -->  00:35:44.170
say eval like this.
774

774

00:35:44.170  -->  00:35:45.930
Okay, so if there is a minus,
775

775

00:35:45.930  -->  00:35:47.850
then it will simply be replaced with a plus,
776

776

00:35:47.850  -->  00:35:49.960
and then the string will be evaluated,
777

777

00:35:49.960  -->  00:35:52.730
in order to return the correct number.
778

778

00:35:52.730  -->  00:35:57.730
Okay, so all we have to do is to recreate this object here,
779

779

00:35:57.890  -->  00:35:59.903
so our final ingredient object.
780

780

00:36:02.823  -->  00:36:05.086
Ooh, so this is really a long lecture here,
781

781

00:36:05.086  -->  00:36:05.919
and there's a lot to do,
782

782

00:36:05.919  -->  00:36:07.380
and it could be even more complete,
783

783

00:36:07.380  -->  00:36:09.170
so there are still some edge cases,
784

784

00:36:09.170  -->  00:36:11.520
which are not going to really work.
785

785

00:36:11.520  -->  00:36:13.040
But I think this is more than enough,
786

786

00:36:13.040  -->  00:36:15.480
for what we're trying to do here, okay.
787

787

00:36:15.480  -->  00:36:17.844
So our count will be our count,
788

788

00:36:17.844  -->  00:36:19.190
so this is the same case as before here,
789

789

00:36:19.190  -->  00:36:20.781
with the ingredient.
790

790

00:36:20.781  -->  00:36:22.510
We don't need to specify count, equal to count,
791

791

00:36:22.510  -->  00:36:25.120
because, yeah, we already have this variable here,
792

792

00:36:25.120  -->  00:36:25.953
with that name.
793

793

00:36:27.360  -->  00:36:29.053
So next up, we have the unit.
794

794

00:36:31.280  -->  00:36:36.280
Which is located at array of ingredient, at unit index.
795

795

00:36:39.790  -->  00:36:40.623
Okay.
796

796

00:36:40.623  -->  00:36:42.580
And then finally, we have the ingredient,
797

797

00:36:46.450  -->  00:36:50.370
which is also in array ingredient dot slice,
798

798

00:36:50.370  -->  00:36:53.190
and so we want to select the part of the array,
799

799

00:36:53.190  -->  00:36:56.550
and it starts right after the unit.
800

800

00:36:56.550  -->  00:37:00.400
So at unit index, plus one,
801

801

00:37:00.400  -->  00:37:02.570
all the way until the end, okay.
802

802

00:37:02.570  -->  00:37:04.350
And we then want to join this of course,
803

803

00:37:04.350  -->  00:37:05.933
back into a string.
804

804

00:37:07.710  -->  00:37:10.663
And alright, that should actually be it.
805

805

00:37:13.030  -->  00:37:14.800
So that was a lot of work,
806

806

00:37:14.800  -->  00:37:17.790
let's test if it, if it's going to work.
807

807

00:37:17.790  -->  00:37:20.850
So let's get rid of this here,
808

808

00:37:20.850  -->  00:37:22.940
we don't need this testing.
809

809

00:37:22.940  -->  00:37:25.573
And also, where's the other one?
810

810

00:37:28.830  -->  00:37:31.003
And of course also, this pizza here.
811

811

00:37:32.060  -->  00:37:34.030
So let's get rid of all of this,
812

812

00:37:34.030  -->  00:37:36.160
and then what we want to do here,
813

813

00:37:36.160  -->  00:37:37.731
before display the recipe,
814

814

00:37:37.731  -->  00:37:40.503
we also want to parse the ingredients.
815

815

00:37:41.560  -->  00:37:44.043
So let's say n parse ingredient,
816

816

00:37:46.330  -->  00:37:50.293
and so we want state, dot recipe, dot parse,
817

817

00:37:53.210  -->  00:37:54.990
ingredients.
818

818

00:37:54.990  -->  00:37:57.160
So, let's take a look now,
819

819

00:37:57.160  -->  00:37:59.743
and it should be fetching our recipe here now.
820

820

00:38:01.490  -->  00:38:02.720
And indeed.
821

821

00:38:02.720  -->  00:38:04.360
And so now we have all of our units here,
822

822

00:38:04.360  -->  00:38:06.400
and it's actually working you see.
823

823

00:38:06.400  -->  00:38:09.070
So we had 1 1/3, I remember here,
824

824

00:38:09.070  -->  00:38:10.900
and now it's just a number, 1.333,
825

825

00:38:10.900  -->  00:38:13.960
which is the exact result of that.
826

826

00:38:13.960  -->  00:38:16.480
Now this part here doesn't really look right,
827

827

00:38:16.480  -->  00:38:17.900
so shortening,
828

828

00:38:17.900  -->  00:38:21.600
and then the rest seems kind of cut off,
829

829

00:38:21.600  -->  00:38:22.433
so,
830

830

00:38:23.700  -->  00:38:26.423
let's actually try to log to the console here,
831

831

00:38:27.680  -->  00:38:29.980
the ingredients without being processed.
832

832

00:38:29.980  -->  00:38:31.123
So console,
833

833

00:38:33.000  -->  00:38:34.350
dot log,
834

834

00:38:34.350  -->  00:38:36.740
state dot recipe,
835

835

00:38:36.740  -->  00:38:38.593
dot ingredient.
836

836

00:38:46.050  -->  00:38:48.280
And so, here are the results,
837

837

00:38:48.280  -->  00:38:50.060
and actually it's, it's correct,
838

838

00:38:50.060  -->  00:38:51.649
so it's shortening it,
839

839

00:38:51.649  -->  00:38:52.680
and then may substitute butter.
840

840

00:38:52.680  -->  00:38:55.090
Okay, so I'm not really sure what this is here,
841

841

00:38:55.090  -->  00:38:59.620
maybe some of your will know what that actually means, okay.
842

842

00:38:59.620  -->  00:39:03.200
But anyway, it looks like this is kind of correct.
843

843

00:39:03.200  -->  00:39:05.683
So let's test it on a couple more results here.
844

844

00:39:06.830  -->  00:39:08.493
So let's take a look at this one.
845

845

00:39:09.750  -->  00:39:12.410
And I'm not sure if it did come back,
846

846

00:39:12.410  -->  00:39:13.913
oh yeah.
847

847

00:39:13.913  -->  00:39:15.060
I guess I just clicked on the same one
848

848

00:39:15.060  -->  00:39:16.073
that was already active.
849

849

00:39:19.160  -->  00:39:20.960
And so take a look,
850

850

00:39:20.960  -->  00:39:22.700
and yeah, great.
851

851

00:39:22.700  -->  00:39:26.603
So we had 4 1/2 cups, and it was converted to 4 1/2,
852

852

00:39:27.500  -->  00:39:30.390
so perfect, this is perfect, it really works.
853

853

00:39:30.390  -->  00:39:31.830
So that's just amazing.
854

854

00:39:31.830  -->  00:39:32.870
Let's take a look at this one,
855

855

00:39:32.870  -->  00:39:34.550
I remember that this one here,
856

856

00:39:34.550  -->  00:39:36.623
was a bit different from the other ones,
857

857

00:39:37.550  -->  00:39:40.123
but it should still be working.
858

858

00:39:41.960  -->  00:39:42.793
And,
859

859

00:39:43.745  -->  00:39:45.490
indeed.
860

860

00:39:45.490  -->  00:39:47.874
Yeah, it looks fantastic, so,
861

861

00:39:47.874  -->  00:39:49.900
I think we're really done here now,
862

862

00:39:49.900  -->  00:39:53.900
after a long lecture of writing all this code.
863

863

00:39:53.900  -->  00:39:56.190
And maybe this was not even the perfect code,
864

864

00:39:56.190  -->  00:39:58.660
so everyone will have different ways
865

865

00:39:58.660  -->  00:40:00.060
of achieving the same result.
866

866

00:40:00.060  -->  00:40:02.790
But I hope that this kind of made sense to you,
867

867

00:40:02.790  -->  00:40:05.560
and if not, then just go a bit through the code,
868

868

00:40:05.560  -->  00:40:08.420
by yourself, and try to really understand what happens here.
869

869

00:40:08.420  -->  00:40:09.830
For example, this part here,
870

870

00:40:09.830  -->  00:40:12.270
I find it a bit tricky here maybe to understand,
871

871

00:40:12.270  -->  00:40:16.528
and so try to go ahead and figure everything out,
872

872

00:40:16.528  -->  00:40:19.390
on your own, that doesn't really make sense.
873

873

00:40:19.390  -->  00:40:21.730
Okay, anyway, take a break now,
874

874

00:40:21.730  -->  00:40:24.530
and see you in the next video, when you're ready for it.
