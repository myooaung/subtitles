WEBVTT
1

00:00:00.570  -->  00:00:06.560
Hello everyone and welcome to the lecture on vector indexing and slicing and this lecture on learn how

2

00:00:06.550  -->  00:00:11.960
to use bracket notation to index and access individual elements from a vector.

3

00:00:11.970  -->  00:00:14.520
Let's go ahead and jump to our studio.

4

00:00:14.520  -->  00:00:14.840
All right.

5

00:00:14.850  -->  00:00:17.660
So here we are our studio and to start things off.

6

00:00:17.700  -->  00:00:24.090
I'm just going to go ahead and make vectors the one and the two will say V-1.

7

00:00:24.120  -->  00:00:34.080
It's just a numeric vector consisting of 100 200 and 300 and we'll say vector V-2 is a vector with a

8

00:00:34.080  -->  00:00:36.600
b and c is a character vector.

9

00:00:37.440  -->  00:00:40.590
So A B C.

10

00:00:40.700  -->  00:00:41.360
All right.

11

00:00:41.550  -->  00:00:48.240
So we have the one we have the to know what we're going to do is learn how to use bracket notation to

12

00:00:48.300  -->  00:00:48.930
index.

13

00:00:48.930  -->  00:00:55.330
So indexing works by using brackets and then passing the index position of the element as a number.

14

00:00:55.480  -->  00:01:01.430
And keep in mind that indexing and are starts at 1 and some other programming languages such as Python

15

00:01:01.440  -->  00:01:03.170
indexing starts at zero.

16

00:01:03.270  -->  00:01:05.070
That in our IT STARTS AT 1.

17

00:01:05.070  -->  00:01:08.760
So let me go ahead and show you an example of how to grab elements from a vector.

18

00:01:09.090  -->  00:01:14.640
You'll put in the vector and then you'll use square brackets and then you'll pass in the index of the

19

00:01:14.640  -->  00:01:15.810
element you want.

20

00:01:16.020  -->  00:01:21.280
So for example let's say you want the elements 200 in the vector of the one.

21

00:01:21.480  -->  00:01:24.770
So it's at position to this in the second position.

22

00:01:24.840  -->  00:01:31.020
So I input the index two inside of my square brackets and it returns to me the elements at that index

23

00:01:31.020  -->  00:01:31.710
.

24

00:01:31.710  -->  00:01:35.140
So let's do another example let's say I wanted the letter C.

25

00:01:35.340  -->  00:01:41.640
So that's an vector v 2 and in square brackets I'm going to input 3 because it's at the third position

26

00:01:41.650  -->  00:01:42.250
.

27

00:01:42.950  -->  00:01:43.420
OK.

28

00:01:43.500  -->  00:01:49.070
And then it returns that particular elements as far as slicing.

29

00:01:49.080  -->  00:01:53.940
That means we're going to do basically multiple indexing so we can grab multiple items from a vector

30

00:01:54.240  -->  00:01:58.500
by actually passing a vector of index positions inside the square brackets.

31

00:01:58.500  -->  00:02:04.380
Let's go ahead and show an example of that first thing to do is just clear the consul showed the one

32

00:02:05.460  -->  00:02:07.130
and showed it to.

33

00:02:07.350  -->  00:02:07.870
All right.

34

00:02:08.010  -->  00:02:12.350
So let's go ahead and grab the numbers 100 and 200.

35

00:02:12.420  -->  00:02:14.430
So those are from Vector 1.

36

00:02:14.720  -->  00:02:19.860
And if I just put in a single number I'll return a single element but to grab an actual slice of that

37

00:02:19.860  -->  00:02:26.490
vector I can pass in a vector inside of the square brackets and this vector will just be a vector of

38

00:02:27.150  -->  00:02:28.140
index positions.

39

00:02:28.140  -->  00:02:33.030
So I want to grab the first element and the second element and that's what occurs.

40

00:02:33.030  -->  00:02:36.750
So let's say I wanted to grab the letters A and see.

41

00:02:37.050  -->  00:02:39.040
So that's in Dr. V-2.

42

00:02:39.270  -->  00:02:45.010
I put in my square brackets to notate that I'm using indexing and then I want to grab and see.

43

00:02:45.020  -->  00:02:48.080
So that's the first element and the third elements.

44

00:02:48.270  -->  00:02:50.010
So I'm going to go ahead and put in a vector.

45

00:02:50.010  -->  00:02:56.100
Notice I'm using the combined function to specify that it's a vector and I'm going to go ahead and grab

46

00:02:56.670  -->  00:02:58.360
a and c in that manner.

47

00:02:58.590  -->  00:03:02.770
So that's how you can grab multiple items from a vector.

48

00:03:03.120  -->  00:03:09.690
So you heard me use the term slicing earlier and what I mean by slicing is not just any multiple indexing

49

00:03:09.720  -->  00:03:13.860
It's when you can actually grab a continuous slice of vector.

50

00:03:13.860  -->  00:03:16.850
So let's go ahead and show you how you can do that in order to do that.

51

00:03:16.860  -->  00:03:19.480
I'm going to go ahead and create a longer vector.

52

00:03:19.680  -->  00:03:21.960
We'll call this just the.

53

00:03:22.650  -->  00:03:25.830
And we'll do it on the numbers one through ten.

54

00:03:25.830  -->  00:03:28.640
One two three four five six seven eight nine.

55

00:03:28.750  -->  00:03:33.600
And then finally 10 there are actually easier easier and better ways to create such a vector which will

56

00:03:33.600  -->  00:03:35.140
show you later on in the course.

57

00:03:35.160  -->  00:03:38.420
But for now we'll just use than normal combine function.

58

00:03:38.460  -->  00:03:41.280
So my vector which is the numbers 1 through 10.

59

00:03:41.430  -->  00:03:46.980
And let's actually want to grab a slice so that continuous slice of elements I can use that using a

60

00:03:46.980  -->  00:03:48.170
colon notation.

61

00:03:48.180  -->  00:03:54.600
So I'm going to use square brackets again and then the weight of notation or syntax works as you put

62

00:03:54.600  -->  00:03:55.830
your starting index.

63

00:03:55.830  -->  00:03:58.830
So let's say I want to grab the numbers 2 3 and 4.

64

00:03:58.890  -->  00:04:04.380
So I want to start a position to then I'm going to put in the colon and then put my stopping index.

65

00:04:04.380  -->  00:04:06.100
So I want to stop at four.

66

00:04:06.600  -->  00:04:09.640
So this will return the numbers 2 3 and 4.

67

00:04:10.170  -->  00:04:11.990
So that's going to grab that slice.

68

00:04:12.000  -->  00:04:13.590
Let's go ahead and show another example.

69

00:04:13.620  -->  00:04:17.810
Let's say I wanted to grab the elements 7 8 9 and 10.

70

00:04:17.880  -->  00:04:25.710
So output outputted my vector put in square brackets and I want to start at index position 7 and ends

71

00:04:26.040  -->  00:04:28.240
or stop in the x position 10.

72

00:04:28.470  -->  00:04:34.090
So that's going to be my slice and I get in return 7 8 9 and 10.

73

00:04:34.260  -->  00:04:41.340
Now previously in the course we discussed using names to name the elements in our vector such as that

74

00:04:41.340  -->  00:04:43.340
temperature vector we saw earlier.

75

00:04:43.500  -->  00:04:46.980
We can actually use those names as index marks.

76

00:04:46.980  -->  00:04:52.180
So let's go ahead and show how you can index elements using names in order to do this.

77

00:04:52.230  -->  00:04:58.880
I'm going to go ahead and reassign V as just a simple vector of numerics we'll call it one two three

78

00:04:58.910  -->  00:05:05.240
four and then I'm going to use the names function on the.

79

00:05:05.670  -->  00:05:09.380
And I'm going to go ahead and pass on a vector of just names.

80

00:05:09.380  -->  00:05:13.690
In this case it'll just be simple letters to designate the names for each of those elements.

81

00:05:13.920  -->  00:05:20.070
So say B C D and make sure to put some quotes around that.

82

00:05:20.160  -->  00:05:20.700
And there we go.

83

00:05:20.700  -->  00:05:25.800
So now if I look at V it has those named elements 1 2 3 4.

84

00:05:25.830  -->  00:05:35.520
So instead of having to do something like the two which will return that names element B to what I can

85

00:05:35.520  -->  00:05:44.030
do is actually pass in the name of the elements I want so element 2 is going to be named B.

86

00:05:44.040  -->  00:05:50.310
So instead of passing in an index it can actually pass in the name B and I'll get that also back in

87

00:05:50.310  -->  00:05:52.120
return the same way.

88

00:05:52.290  -->  00:05:55.860
And if you want to do multiple indexing you can actually pass in a vector.

89

00:05:56.100  -->  00:06:01.990
So I can do something like this I can save the square brackets combine function and then pass in of

90

00:06:02.010  -->  00:06:03.790
vectors of names.

91

00:06:04.020  -->  00:06:05.930
So I can do this actually out of order.

92

00:06:05.940  -->  00:06:15.480
Let's go ahead and say I want names see the element name Z and the element names a and r is going to

93

00:06:15.480  -->  00:06:21.090
return those named elements in the same order as I requested them in that vector.

94

00:06:21.100  -->  00:06:26.320
OK so now let's do a brief discussion on comparison operators and selection.

95

00:06:26.610  -->  00:06:32.100
So as we discussed in the comparison operator lecture we can use comparison operators to filter out

96

00:06:32.160  -->  00:06:33.930
elements from a vector.

97

00:06:33.930  -->  00:06:38.910
Sometimes this is also referred to as boolean or logical masking because you're essentially creating

98

00:06:38.910  -->  00:06:42.130
a vector of logicals to filter out results you want.

99

00:06:42.330  -->  00:06:44.320
Let's go ahead and see an example.

100

00:06:44.560  -->  00:06:50.520
We'll use the same vector we've been working with the ABC 1 2 3 4.

101

00:06:50.580  -->  00:06:56.540
So let's say I wanted to filter out any values that were less than 2.

102

00:06:56.670  -->  00:07:01.460
So I wanted to only grab values that were greater than two in this case going to be three and four.

103

00:07:01.650  -->  00:07:04.580
I can do that same bracket notation.

104

00:07:04.620  -->  00:07:09.990
In this case I just do a comparison operator inside of that bracket notation.

105

00:07:09.990  -->  00:07:12.380
So it kind of looks like this.

106

00:07:12.450  -->  00:07:17.730
Now I have the square brackets and then a comparison condition here.

107

00:07:17.790  -->  00:07:21.660
So basically says Return V were V is greater than 2.

108

00:07:22.020  -->  00:07:28.490
So if I click enter I see that C and D name which are both greater than two three and four then returns

109

00:07:28.550  -->  00:07:29.190
.

110

00:07:29.220  -->  00:07:34.290
So to break down and see how this actually works let's first show what is returned if we just say V

111

00:07:34.290  -->  00:07:36.730
is greater than 2.

112

00:07:36.780  -->  00:07:38.730
So if I say V is greater than 2.

113

00:07:38.760  -->  00:07:42.980
Notice I get a logical vector out I get false false.

114

00:07:42.990  -->  00:07:45.100
True true.

115

00:07:45.190  -->  00:07:49.680
And so what this means is that we're basically passing this vector of logicals through the brackets

116

00:07:49.680  -->  00:07:54.630
of the vector and only return TRUE values at the matching index positions.

117

00:07:54.630  -->  00:08:00.750
What's also nice about this is we can assign that condition that logical comparison to a variable name

118

00:08:01.050  -->  00:08:03.750
and then just pass in that variable name and the brackets.

119

00:08:03.750  -->  00:08:07.080
So for example I could say something like this.

120

00:08:07.320  -->  00:08:16.580
I could say filter Let's actually call this something assholes call it my filter.

121

00:08:16.880  -->  00:08:24.420
So you don't overwrite any builtin functionality will say my filter will go ahead and put in the logical

122

00:08:24.420  -->  00:08:28.440
comparison I will say the is greater than 2.

123

00:08:29.490  -->  00:08:30.860
So now it's my filter.

124

00:08:30.870  -->  00:08:34.650
And if you notice then my filter is just this vector.

125

00:08:34.650  -->  00:08:46.020
So I can then say when it clear that the pass in my filter and it'll return where those explanations

126

00:08:46.140  -->  00:08:46.920
are true.

127

00:08:46.920  -->  00:08:48.890
So in this case it's C and D.

128

00:08:49.170  -->  00:08:53.970
So this is really nice because you can start to name your comparison operators are these logical conditioned

129

00:08:53.970  -->  00:08:56.880
statements pass them into vectors that have names.

130

00:08:56.910  -->  00:09:00.530
So everything becomes a lot more readable later on in your code.

131

00:09:00.540  -->  00:09:01.160
All right.

132

00:09:01.380  -->  00:09:03.360
So that's it for this lecture.

133

00:09:03.360  -->  00:09:05.620
Just a brief overview of what we've covered.

134

00:09:05.790  -->  00:09:10.870
We learned how we can use bracket notation to index and access individual elements from a vector.

135

00:09:10.960  -->  00:09:15.810
We learned how we can use that same notation for multiple indexing by passing a vector inside of those

136

00:09:15.810  -->  00:09:16.860
brackets.

137

00:09:16.860  -->  00:09:22.620
And we also learn how to use slicing with that colon in order to grab a continuous slice of the vector

138

00:09:23.100  -->  00:09:28.890
and then finally we learn how we can index of names and also use comparison operators in logical conditions

139

00:09:28.890  -->  00:09:32.850
statements to filter out results from a vector.

140

00:09:32.850  -->  00:09:35.760
All right thanks everyone and I'll see you at the next lecture
