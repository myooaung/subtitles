1
00:00:00,630 --> 00:00:02,600
[Autogenerated] not that we have the thrilling place.

2
00:00:02,600 --> 00:00:07,140
We are ready to create mongo integration tests in a spring application.

3
00:00:07,140 --> 00:00:09,440
The first trees that you're going to have to make is whether

4
00:00:09,440 --> 00:00:12,810
you're going to use and in embedded among without a base or a

5
00:00:12,810 --> 00:00:14,840
stand along with other bees.

6
00:00:14,840 --> 00:00:16,650
They both have pros and cons.

7
00:00:16,650 --> 00:00:17,350
However,

8
00:00:17,350 --> 00:00:22,900
if you opt for the embedded approach will have no dependencies whatsoever.

9
00:00:22,900 --> 00:00:26,330
This means that you can set up your local environment easily,

10
00:00:26,330 --> 00:00:30,010
and it can also meet a great with CSC pipelines very,

11
00:00:30,010 --> 00:00:31,640
very fast.

12
00:00:31,640 --> 00:00:34,240
You also get faster tests.

13
00:00:34,240 --> 00:00:37,070
However, this is not an official Mongol product,

14
00:00:37,070 --> 00:00:40,800
and therefore it's not quite integration testing because

15
00:00:40,800 --> 00:00:43,650
you're not targeting a natural Mongol database,

16
00:00:43,650 --> 00:00:48,390
but rather a custom implementation off it that runs in memory.

17
00:00:48,390 --> 00:00:50,840
If you opt for a standard on approach,

18
00:00:50,840 --> 00:00:55,240
you need a dedicated mongo database for testing purposes.

19
00:00:55,240 --> 00:00:58,480
You increase the complexity of the receipt's in the environment.

20
00:00:58,480 --> 00:01:00,890
In your local environment.

21
00:01:00,890 --> 00:01:03,940
This was meant to run a little bit slower,

22
00:01:03,940 --> 00:01:07,130
but we will discover how your application behaves

23
00:01:07,130 --> 00:01:11,630
in production like environments, and this is pretty pretty important,

24
00:01:11,630 --> 00:01:11,960
all right.

25
00:01:11,960 --> 00:01:14,090
And if both have pros and cons,

26
00:01:14,090 --> 00:01:17,990
what should you choose running tests with an embedded

27
00:01:17,990 --> 00:01:21,440
database or with the standard on one, and that's a good question.

28
00:01:21,440 --> 00:01:23,000
Based on my experience.

29
00:01:23,000 --> 00:01:26,570
Alger Command that you start with an embedded database first

30
00:01:26,570 --> 00:01:30,830
and gradually progress to a standard on database before

31
00:01:30,830 --> 00:01:33,900
shipping your application to production.

32
00:01:33,900 --> 00:01:36,760
I recommend this approach because it worked pretty well

33
00:01:36,760 --> 00:01:39,240
in the projects where I was involved.

34
00:01:39,240 --> 00:01:41,350
Before we look at an actual test,

35
00:01:41,350 --> 00:01:46,270
I want to talk about the AT data mongo test annotation.

36
00:01:46,270 --> 00:01:49,700
The sanitation can be used on classes that will contain

37
00:01:49,700 --> 00:01:53,940
your manga TB integration tests using the sanitation will

38
00:01:53,940 --> 00:01:56,620
disable full auto configuration,

39
00:01:56,620 --> 00:02:00,600
but apply partial auto configuration for the Mongol

40
00:02:00,600 --> 00:02:02,460
related components like suppositories,

41
00:02:02,460 --> 00:02:08,440
the Mongol template and standing off classes annotated with at document.

42
00:02:08,440 --> 00:02:12,140
And I think we're ready to look at some actual examples.

43
00:02:12,140 --> 00:02:15,710
We'll start which running tests using an embedded database.

44
00:02:15,710 --> 00:02:18,240
The first thing that into set up is to get a

45
00:02:18,240 --> 00:02:22,400
dependency on the embedded mongo server.

46
00:02:22,400 --> 00:02:23,910
We can achieve that pretty city,

47
00:02:23,910 --> 00:02:29,110
but adding this dependency to a poem that XML file you want

48
00:02:29,110 --> 00:02:33,010
the d e flapdoodle in bed mongo artifact.

49
00:02:33,010 --> 00:02:35,720
Do note that a sculptor dependency is test,

50
00:02:35,720 --> 00:02:38,370
which means that the embedded database will be

51
00:02:38,370 --> 00:02:41,050
available when you're running tests,

52
00:02:41,050 --> 00:02:44,310
but it won't be available at runtime at front time.

53
00:02:44,310 --> 00:02:47,420
Your application will connect toe on actual mongo database,

54
00:02:47,420 --> 00:02:49,680
Go one specified in the Application Properties file,

55
00:02:49,680 --> 00:02:50,640
for example.

56
00:02:50,640 --> 00:02:53,000
We cannot create our first this class.

57
00:02:53,000 --> 00:02:56,530
We're going to call it database integration tests.

58
00:02:56,530 --> 00:02:59,430
Not is the special annotations that you used.

59
00:02:59,430 --> 00:03:01,740
We have at data mongo test.

60
00:03:01,740 --> 00:03:05,280
We also have at extend with spring extension.

61
00:03:05,280 --> 00:03:06,520
That's class.

62
00:03:06,520 --> 00:03:12,220
This instructs the Janet five runner to use the spring test context and

63
00:03:12,220 --> 00:03:16,040
optionally we can add on at category in rotation.

64
00:03:16,040 --> 00:03:18,930
Now we can other wire the Mongo template.

65
00:03:18,930 --> 00:03:23,520
And remember, we can do that because we have the at Data Mongo test annotation,

66
00:03:23,520 --> 00:03:27,390
which gives us some auto writing capabilities.

67
00:03:27,390 --> 00:03:32,240
We can inject mongo related components, and my uncle template is one of them.

68
00:03:32,240 --> 00:03:33,580
Before we run a test,

69
00:03:33,580 --> 00:03:37,300
we need to set up some test data in clear eat afterwards so

70
00:03:37,300 --> 00:03:39,910
that each test can start from a clean slate.

71
00:03:39,910 --> 00:03:42,200
That's why we have the before each and after.

72
00:03:42,200 --> 00:03:45,190
Each methods the 1st 1 he asserts.

73
00:03:45,190 --> 00:03:48,680
Some aircraft authority embedded mongo database.

74
00:03:48,680 --> 00:03:52,040
Notice that gene it at before each annotation.

75
00:03:52,040 --> 00:03:55,620
The 2nd 1 just drops the aircraft collection

76
00:03:55,620 --> 00:03:58,920
entirely of us clearing the database.

77
00:03:58,920 --> 00:04:02,490
These methods are going to be executed before and after

78
00:04:02,490 --> 00:04:05,590
each test that we define in art a street.

79
00:04:05,590 --> 00:04:07,060
The test itself is pretty.

80
00:04:07,060 --> 00:04:10,650
Is it right to create a new method we annotated with math

81
00:04:10,650 --> 00:04:14,290
test and then we're using the mongo template to find all

82
00:04:14,290 --> 00:04:16,840
the aircraft in our database.

83
00:04:16,840 --> 00:04:20,580
Assuming that we care free, we can then use a certain equals free.

84
00:04:20,580 --> 00:04:22,170
And our result.

85
00:04:22,170 --> 00:04:27,540
That's how easy it is to create a Mongol to be integration test in spring.

86
00:04:27,540 --> 00:04:32,640
So why'd you seven The process is the following You fire up the test.

87
00:04:32,640 --> 00:04:36,530
This in turn starts the embedded Mongol database in memory.

88
00:04:36,530 --> 00:04:39,530
You populate collections with something's data in Archies

89
00:04:39,530 --> 00:04:42,610
aircraft you execute and a service.

90
00:04:42,610 --> 00:04:46,540
And finally you clear the embedded among without a base.

91
00:04:46,540 --> 00:04:49,780
It's worth mentioning that the embedded Mongol Debbie server he

92
00:04:49,780 --> 00:04:53,590
started only once when the first test is executed.

93
00:04:53,590 --> 00:04:57,640
Now let's see how we can run tests using a standard on batteries.

94
00:04:57,640 --> 00:05:01,580
Well, first of all, we have no dependency on the embedded.

95
00:05:01,580 --> 00:05:04,950
That's a base model, so we can just go ahead and write their test.

96
00:05:04,950 --> 00:05:06,100
But before we do that,

97
00:05:06,100 --> 00:05:11,810
we still lead the way to specify what database we're going to use for our tests.

98
00:05:11,810 --> 00:05:14,340
And that's why we have this test configuration.

99
00:05:14,340 --> 00:05:19,360
Not is the at test configuration annotation here we can declare beings that

100
00:05:19,360 --> 00:05:25,430
are going to be available for auto wiring in artists only equate among otb

101
00:05:25,430 --> 00:05:29,380
factory being where we specify the test database.

102
00:05:29,380 --> 00:05:31,020
Mongo your eye.

103
00:05:31,020 --> 00:05:37,140
Then we quit a mongo temperate being and passing the factory declared above.

104
00:05:37,140 --> 00:05:40,690
So what we get is when we got a wire the Mongol template.

105
00:05:40,690 --> 00:05:43,980
It will point to our test database.

106
00:05:43,980 --> 00:05:47,960
The database integration tests class is almost identical.

107
00:05:47,960 --> 00:05:53,190
The only difference is the at import annotation where we are importing

108
00:05:53,190 --> 00:05:56,630
the beans defined in our test configuration class.

109
00:05:56,630 --> 00:05:59,930
And we need to do that because when we oughta wear the Mongol template,

110
00:05:59,930 --> 00:06:04,470
we want to point to the database as specified in there.

111
00:06:04,470 --> 00:06:05,480
I hope you noticed.

112
00:06:05,480 --> 00:06:09,940
How is it is to switch from one embedded at the base toe stand?

113
00:06:09,940 --> 00:06:11,040
A long one?

114
00:06:11,040 --> 00:06:13,790
This are being executed in a similar fashion.

115
00:06:13,790 --> 00:06:18,940
You find out the street which in turn is going to connect your actual database.

116
00:06:18,940 --> 00:06:19,900
We're goingto cooperate.

117
00:06:19,900 --> 00:06:30,000
Sometimes data executor test and clear the database pretty much the same flow. Except we're not starting an embedded database in memory.

