1
00:00:01,240 --> 00:00:03,440
[Autogenerated] in this module will take a look at how to

2
00:00:03,440 --> 00:00:06,840
implement queries in spring among ______ B.

3
00:00:06,840 --> 00:00:10,710
More precisely, we look and understand the _______ object,

4
00:00:10,710 --> 00:00:12,890
the star off today's module.

5
00:00:12,890 --> 00:00:14,900
Then we learn how to create an execute.

6
00:00:14,900 --> 00:00:18,530
Queries will see how to implement full text search.

7
00:00:18,530 --> 00:00:19,200
And finally,

8
00:00:19,200 --> 00:00:21,820
we'll wrap it up with the demo in which will implement

9
00:00:21,820 --> 00:00:25,840
bongo queries in spring applications.

10
00:00:25,840 --> 00:00:27,090
Before we get started.

11
00:00:27,090 --> 00:00:31,210
I like to take a note and talk a little bit about Cory execution.

12
00:00:31,210 --> 00:00:37,160
You can execute queries or fetch data in toys with indexes and without indexes.

13
00:00:37,160 --> 00:00:40,960
Both have pros and cons, but when you're not using indexes,

14
00:00:40,960 --> 00:00:44,770
you're basically forcing Mongo to perform a collection scan.

15
00:00:44,770 --> 00:00:50,240
It's a document is evaluated, and if it passes your criteria, it is returned.

16
00:00:50,240 --> 00:00:55,290
This results in slow searches, however, you get fast inserts and on Bates.

17
00:00:55,290 --> 00:00:57,680
On the other hand, when used index is,

18
00:00:57,680 --> 00:01:00,680
mongo is not forced to scan every document in collecting.

19
00:01:00,680 --> 00:01:03,840
So a collection scan is not performed,

20
00:01:03,840 --> 00:01:07,180
was results in fast searches but decreases your

21
00:01:07,180 --> 00:01:10,790
performance for inserts and updates.

22
00:01:10,790 --> 00:01:16,460
There is no magic bullet or magic recipe on how we should prepare your queries

23
00:01:16,460 --> 00:01:21,750
for execution My advice is to try out various combination of indexes and see

24
00:01:21,750 --> 00:01:25,160
which one works best for your particular application.

25
00:01:25,160 --> 00:01:27,400
Now let's go back to the star of this module.

26
00:01:27,400 --> 00:01:29,540
The Mongo create object.

27
00:01:29,540 --> 00:01:32,610
The query object is the most powerful and flexible

28
00:01:32,610 --> 00:01:35,670
component for Mongo crab operation.

29
00:01:35,670 --> 00:01:39,280
To understand it better, let's take a look at the quarry components,

30
00:01:39,280 --> 00:01:41,830
and they're free components that make up a query.

31
00:01:41,830 --> 00:01:45,390
First of all, you have the criteria for filtering daytime.

32
00:01:45,390 --> 00:01:48,540
Then you have the sorting definition for ordering the time,

33
00:01:48,540 --> 00:01:51,440
and they have paging definition for splitting data.

34
00:01:51,440 --> 00:01:53,970
Obviously, the last two are optional.

35
00:01:53,970 --> 00:01:57,600
The 1st 1 is kind of mandatory, but enough talking.

36
00:01:57,600 --> 00:01:59,900
Let's see a natural example.

37
00:01:59,900 --> 00:02:03,740
This is how among go quickly looks like in a spring application.

38
00:02:03,740 --> 00:02:06,810
We define the query using the query class.

39
00:02:06,810 --> 00:02:09,390
Give it a meaningful name, Mrs by age.

40
00:02:09,390 --> 00:02:12,130
Then we defined the three components that we discussed

41
00:02:12,130 --> 00:02:15,410
about earlier have the criteria over here,

42
00:02:15,410 --> 00:02:20,350
which dictates that you want to filter other persons whose age is greater than

43
00:02:20,350 --> 00:02:26,000
18 and then we have the sorting direction in the row below.

44
00:02:26,000 --> 00:02:31,320
You want to sort them descending Lee by age and last but

45
00:02:31,320 --> 00:02:34,950
not least we have the page request, which were instructing,

46
00:02:34,950 --> 00:02:39,290
you know, spring to give us the first page and on Lee 10 documents.

47
00:02:39,290 --> 00:02:44,600
As a result, As you can see, we can define queries using this fluent interface,

48
00:02:44,600 --> 00:02:49,980
and this makes reading them and constructing them pretty easy.

49
00:02:49,980 --> 00:02:53,630
Let's take a closer look at the criteria definition again.

50
00:02:53,630 --> 00:02:58,190
We can define criteria in a flood banner, and we have free components.

51
00:02:58,190 --> 00:02:59,990
As we're here, we have the left operas,

52
00:02:59,990 --> 00:03:03,780
which is the data field on which you want to perform the filtering.

53
00:03:03,780 --> 00:03:05,820
We have the operator in our case.

54
00:03:05,820 --> 00:03:08,570
Is this one greater than GT?

55
00:03:08,570 --> 00:03:11,200
And then we have the right operator, which is the filter value,

56
00:03:11,200 --> 00:03:13,340
the value by which you want to perform the filter.

57
00:03:13,340 --> 00:03:15,740
In this case, it is 18.

58
00:03:15,740 --> 00:03:19,310
That's a typical criteria definition looks like.

59
00:03:19,310 --> 00:03:22,040
And of course, we have multiple operators.

60
00:03:22,040 --> 00:03:25,360
We have a fitness for equality, is or not.

61
00:03:25,360 --> 00:03:26,330
Tickles,

62
00:03:26,330 --> 00:03:31,000
have filters for less than or less than and equals for

63
00:03:31,000 --> 00:03:34,340
greater than or greater than equals.

64
00:03:34,340 --> 00:03:38,770
We also have a filter for determining if our value is present business list,

65
00:03:38,770 --> 00:03:40,740
and that's the infielder,

66
00:03:40,740 --> 00:03:44,420
which have a filter that it terms if a field has

67
00:03:44,420 --> 00:03:46,990
any value and this one is exists,

68
00:03:46,990 --> 00:03:51,280
and we can also apply Rex patterns in our criteria,

69
00:03:51,280 --> 00:03:55,790
the query object is pretty useful for defining the query.

70
00:03:55,790 --> 00:03:59,240
You can look at it as the meta data off the quake,

71
00:03:59,240 --> 00:04:04,570
But how do we execute this query against a Mongol database in Sprink?

72
00:04:04,570 --> 00:04:06,770
That's where the Mongol tempered comes in.

73
00:04:06,770 --> 00:04:09,450
Manga template is the class or component that

74
00:04:09,450 --> 00:04:12,440
executes requests to among go database.

75
00:04:12,440 --> 00:04:15,600
Mongo Template is a simple injectable class,

76
00:04:15,600 --> 00:04:18,630
following the standard template pattern in spring.

77
00:04:18,630 --> 00:04:22,880
It allows us to perform crowd operations on data it allows us to

78
00:04:22,880 --> 00:04:26,540
execute commands against among go database.

79
00:04:26,540 --> 00:04:31,980
And last but not least, it's very, very powerful but also a little bit low level.

80
00:04:31,980 --> 00:04:35,920
So even though it might take you a while to get used to it,

81
00:04:35,920 --> 00:04:37,800
it is extremely powerful,

82
00:04:37,800 --> 00:04:43,430
and it allows you to perform almost anything on any mongo database.

83
00:04:43,430 --> 00:04:51,000
Not that they have this 10,000 feet overview. Let's learn howto actually implement queries using some examples

