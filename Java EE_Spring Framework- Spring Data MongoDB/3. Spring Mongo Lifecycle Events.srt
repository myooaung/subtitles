1
00:00:01,010 --> 00:00:03,800
[Autogenerated] it's time to look at one of the most exciting features.

2
00:00:03,800 --> 00:00:04,970
His spring data.

3
00:00:04,970 --> 00:00:08,960
Mongo, Debbie Life Second events are a bit underrated,

4
00:00:08,960 --> 00:00:15,610
but they are extremely powerful ways to implement custom logic in key moments.

5
00:00:15,610 --> 00:00:19,980
Left tackle events are hooks that your application can respond to by

6
00:00:19,980 --> 00:00:25,400
registering special beings in the spring application context,

7
00:00:25,400 --> 00:00:29,510
we have many life cycle events to which you can respond to.

8
00:00:29,510 --> 00:00:30,090
First of all,

9
00:00:30,090 --> 00:00:35,550
we have the before events as I call them on before convert

10
00:00:35,550 --> 00:00:39,740
on before save and on before delete.

11
00:00:39,740 --> 00:00:46,950
Then you also have the after events on after convert on after save on after

12
00:00:46,950 --> 00:00:52,340
load and on after delete so plenty of options available.

13
00:00:52,340 --> 00:00:56,520
Let's look at the process at how these events get cold,

14
00:00:56,520 --> 00:00:59,950
where you want to save or update a document.

15
00:00:59,950 --> 00:01:04,440
Usually call center safe in a model template or among the depository.

16
00:01:04,440 --> 00:01:08,560
In this case, the first event that gets cold is on before convert,

17
00:01:08,560 --> 00:01:12,500
and it is called before your Java object is converted to

18
00:01:12,500 --> 00:01:15,020
a document by the Mongo converter,

19
00:01:15,020 --> 00:01:18,400
then on before Safe is called before inserting,

20
00:01:18,400 --> 00:01:21,220
receiving the document in the Devil Rays.

21
00:01:21,220 --> 00:01:23,690
Lastly, we have on after safe,

22
00:01:23,690 --> 00:01:28,650
which is called after the document was inserted or saved in the database.

23
00:01:28,650 --> 00:01:31,020
If you want to load a document,

24
00:01:31,020 --> 00:01:36,280
then usually you call a fine method on a Mongol template or among report story,

25
00:01:36,280 --> 00:01:39,370
the first event that gets triggered his own after load,

26
00:01:39,370 --> 00:01:44,940
which is called after the document, has been retrieved from the database.

27
00:01:44,940 --> 00:01:47,060
Then we have on after Convert,

28
00:01:47,060 --> 00:01:52,540
which is called after the document has been converted into a job object.

29
00:01:52,540 --> 00:01:56,460
There are also events when you're deleting documents each time you call,

30
00:01:56,460 --> 00:02:01,190
you move on among go template on before the fleet is called just before

31
00:02:01,190 --> 00:02:06,970
the document gets needed and on after delete is called just after the

32
00:02:06,970 --> 00:02:09,900
document has been deleted from the database.

33
00:02:09,900 --> 00:02:13,650
I think it's also worth mentioning that life cycle events

34
00:02:13,650 --> 00:02:17,030
are emitted only for root level types.

35
00:02:17,030 --> 00:02:20,960
Sub documents are not subject Steven publication unless

36
00:02:20,960 --> 00:02:24,540
they're annotated with at the B ref.

37
00:02:24,540 --> 00:02:29,010
Also, it is all happening in an a synchronous fashion.

38
00:02:29,010 --> 00:02:32,990
You have no guarantee toe when an event is processed,

39
00:02:32,990 --> 00:02:34,770
it's surely going to get processed,

40
00:02:34,770 --> 00:02:38,040
but we don't know exactly when that's going to happen.

41
00:02:38,040 --> 00:02:40,510
All right, at this point, you might be wondering,

42
00:02:40,510 --> 00:02:43,200
Why would I ever want to hook into these events.

43
00:02:43,200 --> 00:02:45,260
They seem so low level.

44
00:02:45,260 --> 00:02:48,320
Well, let me give you some really use cases.

45
00:02:48,320 --> 00:02:50,850
First of all, if you're trying to implement cascading,

46
00:02:50,850 --> 00:02:54,330
go save a life cycle, events are the way to go.

47
00:02:54,330 --> 00:02:57,100
If you want to trigger some job or action in different systems,

48
00:02:57,100 --> 00:03:00,210
when some persistence is happening in your system like you're

49
00:03:00,210 --> 00:03:02,680
saving a document or he have removal document.

50
00:03:02,680 --> 00:03:07,230
Then again, let's cycle events are great and has been a list.

51
00:03:07,230 --> 00:03:09,440
If you want to implement security auditing,

52
00:03:09,440 --> 00:03:15,110
then there's no better way than implementing its using lifecycle events.

53
00:03:15,110 --> 00:03:19,940
These are real use cases that you will come across in applications.

54
00:03:19,940 --> 00:03:23,870
All right, how can I hook it to these events and execute to my own custom logic?

55
00:03:23,870 --> 00:03:25,680
Well, I'm glad you asked.

56
00:03:25,680 --> 00:03:30,690
It all starts from the abstract mongo event Listener class.

57
00:03:30,690 --> 00:03:35,620
This class exposes methods which we can override to implement our cast.

58
00:03:35,620 --> 00:03:36,110
AJ,

59
00:03:36,110 --> 00:03:38,390
you can see what you have on after convert on after

60
00:03:38,390 --> 00:03:40,650
delete on after load and the list goes on,

61
00:03:40,650 --> 00:03:43,600
have a method for each lifecycle event.

62
00:03:43,600 --> 00:03:46,500
In order to implement our own custom logic,

63
00:03:46,500 --> 00:03:50,170
we need to extend the abstract Munguia event,

64
00:03:50,170 --> 00:03:51,680
listener class.

65
00:03:51,680 --> 00:03:52,760
That's what we're doing here.

66
00:03:52,760 --> 00:03:55,910
We're trying to create Ah, before converts non event.

67
00:03:55,910 --> 00:03:58,550
We're extending this class and then we wantto

68
00:03:58,550 --> 00:04:00,830
override the own before convert method.

69
00:04:00,830 --> 00:04:06,340
We have the at overhead imitation, and then we get other cast a magic over here.

70
00:04:06,340 --> 00:04:09,400
Last but not least, we also need to register this bean.

71
00:04:09,400 --> 00:04:10,100
You can do that.

72
00:04:10,100 --> 00:04:13,610
Using annotations is ending right here with that component.

73
00:04:13,610 --> 00:04:16,500
Or you can just quit being in a configuration class.

74
00:04:16,500 --> 00:04:19,040
Either way, it's going to work just fine.

75
00:04:19,040 --> 00:04:23,340
Before we conclude this part, I would like to give you one last piece of advice.

76
00:04:23,340 --> 00:04:25,910
Try to create an event listener.

77
00:04:25,910 --> 00:04:26,850
Poor feature.

78
00:04:26,850 --> 00:04:32,000
Don't create this generic or global mongo lifecycle listeners where

79
00:04:32,000 --> 00:04:35,370
you override all the methods and at cast a magic in there because

80
00:04:35,370 --> 00:04:37,610
they become a maintenance nightmare.

81
00:04:37,610 --> 00:04:38,260
Instead.

82
00:04:38,260 --> 00:04:40,720
Think about the future or trying to implement aren't

83
00:04:40,720 --> 00:04:44,240
trying to implement cascading, then create a cascade of a listener.

84
00:04:44,240 --> 00:04:46,330
I'm tryingto also add auditing,

85
00:04:46,330 --> 00:04:56,000
then create another auditing event listener and register it don't put order things in a global listener because that is not maintainable

