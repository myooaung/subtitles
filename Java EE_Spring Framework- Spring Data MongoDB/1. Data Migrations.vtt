WEBVTT
1
00:00:00.640 --> 00:00:03.540
[Autogenerated] I believe that that immigration's are pretty interesting

2
00:00:03.540 --> 00:00:06.750
and important topic when we're building with persistence.

3
00:00:06.750 --> 00:00:07.540
So it is.

4
00:00:07.540 --> 00:00:11.420
Module will start to understand what that immigration is our.

5
00:00:11.420 --> 00:00:12.980
Then we'll create monk.

6
00:00:12.980 --> 00:00:16.130
Oh, that immigration is in spring applications.

7
00:00:16.130 --> 00:00:19.480
I will finish the demo on which would implement migrations.

8
00:00:19.480 --> 00:00:23.640
Spring up using a library cold mongo Be.

9
00:00:23.640 --> 00:00:25.310
But let's start at the beginning.

10
00:00:25.310 --> 00:00:31.410
Let's look at the universal truth data changes over time, period.

11
00:00:31.410 --> 00:00:34.060
No matter on what project you're working on,

12
00:00:34.060 --> 00:00:37.710
no matter what technology use, the data is going to change.

13
00:00:37.710 --> 00:00:41.290
If you're planning to host an application in production for a

14
00:00:41.290 --> 00:00:44.170
given amount of time and the changes are gradual,

15
00:00:44.170 --> 00:00:46.410
we'll start with an initial other structure.

16
00:00:46.410 --> 00:00:47.410
At some point in time,

17
00:00:47.410 --> 00:00:49.400
you're going to create a relationship between some

18
00:00:49.400 --> 00:00:51.540
documents because it makes more sense.

19
00:00:51.540 --> 00:00:55.550
Or maybe we have to add new feels your documents to

20
00:00:55.550 --> 00:00:58.840
accommodate new business requirements.

21
00:00:58.840 --> 00:01:05.040
Literal one you might rename some feels to make them match the business domain.

22
00:01:05.040 --> 00:01:07.520
Or you might change collections altogether.

23
00:01:07.520 --> 00:01:12.840
You might add a new collection, sitting with old ones or rename existing ones.

24
00:01:12.840 --> 00:01:15.810
The point is that data will always change,

25
00:01:15.810 --> 00:01:19.300
and in a production application would have multiple changes.

26
00:01:19.300 --> 00:01:19.980
But wait a minute.

27
00:01:19.980 --> 00:01:22.920
Why are we discussing about data migrations?

28
00:01:22.920 --> 00:01:25.930
Italy pick Mongo Deby because it has no skin.

29
00:01:25.930 --> 00:01:27.240
My enforcements.

30
00:01:27.240 --> 00:01:28.750
Well, that's right.

31
00:01:28.750 --> 00:01:31.480
A nautical leather bass has most Emma so that our

32
00:01:31.480 --> 00:01:34.040
migrations are easier to apply.

33
00:01:34.040 --> 00:01:38.700
However, you're also working on a spring application on a job application,

34
00:01:38.700 --> 00:01:42.750
so you always have to take into account that you need to reconsider.

35
00:01:42.750 --> 00:01:46.190
Eat, making your mongo documents and your job objects.

36
00:01:46.190 --> 00:01:48.950
The structure of the Mongol documents needs to be

37
00:01:48.950 --> 00:01:52.790
reflected in your Java objects, and when you migrate data,

38
00:01:52.790 --> 00:01:55.930
these things don't to be out of think.

39
00:01:55.930 --> 00:01:58.400
A change in a manga document will impact the

40
00:01:58.400 --> 00:02:01.340
civilization and this realization process.

41
00:02:01.340 --> 00:02:04.760
A change in a Mongol document will also impact some quests.

42
00:02:04.760 --> 00:02:07.010
You saw that when you're working with Manco templates,

43
00:02:07.010 --> 00:02:10.800
you're basically using strings to define property names.

44
00:02:10.800 --> 00:02:16.780
Well, if you're documenting Manco changes, then those queries will be affected.

45
00:02:16.780 --> 00:02:19.140
Last finalist will change collections.

46
00:02:19.140 --> 00:02:20.780
This also impact queries,

47
00:02:20.780 --> 00:02:24.790
so you feel you need to keep the Mongol structure and your Java structure.

48
00:02:24.790 --> 00:02:28.850
You think that's why we're talking about Mongo migrations?

49
00:02:28.850 --> 00:02:32.740
Not because my body be can handle them because he can.

50
00:02:32.740 --> 00:02:37.040
But because your application is toe, handle them gracefully.

51
00:02:37.040 --> 00:02:40.480
There are a couple of triggers that will signal when you need to implement

52
00:02:40.480 --> 00:02:44.490
that immigration document changes are the most frequent.

53
00:02:44.490 --> 00:02:47.360
Collection changes come second,

54
00:02:47.360 --> 00:02:51.930
and sometimes you might have to do a complete that are based migration.

55
00:02:51.930 --> 00:02:54.300
But that's not happening very often.

56
00:02:54.300 --> 00:02:58.700
Most of time documents change.

57
00:02:58.700 --> 00:03:02.200
So if that's the case, how do you implement this migration?

58
00:03:02.200 --> 00:03:03.940
While we have a couple of options,

59
00:03:03.940 --> 00:03:09.040
you can use manual migrations in scripts and modify the database directly.

60
00:03:09.040 --> 00:03:12.190
Or you might create a migration comparing yourself using Java,

61
00:03:12.190 --> 00:03:14.840
our any other technology.

62
00:03:14.840 --> 00:03:17.780
Or we can use an existing framework.

63
00:03:17.780 --> 00:03:23.280
I highly discouraged to your script as a way to implement migrations.

64
00:03:23.280 --> 00:03:25.200
I've been there, I've done that.

65
00:03:25.200 --> 00:03:28.840
And trust me, it's not a road that you want to walk upon.

66
00:03:28.840 --> 00:03:31.120
We'll end up having multiple versions of the

67
00:03:31.120 --> 00:03:33.810
application deployed at various customers,

68
00:03:33.810 --> 00:03:35.800
and then you have to figure out how to migrate.

69
00:03:35.800 --> 00:03:39.680
Data from version eight version be from version Beta Version D,

70
00:03:39.680 --> 00:03:40.850
and the list can go on.

71
00:03:40.850 --> 00:03:41.650
It's a nightmare.

72
00:03:41.650 --> 00:03:43.240
You don't want to do it.

73
00:03:43.240 --> 00:03:45.330
What you want to do is you want tohave?

74
00:03:45.330 --> 00:03:48.480
A component that does this for you automatically doesn't matter,

75
00:03:48.480 --> 00:03:52.340
refusing a framework or if you're creating it yourself.

76
00:03:52.340 --> 00:03:54.210
And if you're using a component,

77
00:03:54.210 --> 00:03:57.500
there are a couple of characteristics that you need to look at.

78
00:03:57.500 --> 00:04:01.670
First of all, that component should have version detection.

79
00:04:01.670 --> 00:04:04.790
It should detect an existing database version and a

80
00:04:04.790 --> 00:04:07.840
great the newest version automatically.

81
00:04:07.840 --> 00:04:10.670
He should also be easy to configure and to set up

82
00:04:10.670 --> 00:04:13.710
ordered data changes and has been a list.

83
00:04:13.710 --> 00:04:17.870
You should have extensive logging because you want to audit

84
00:04:17.870 --> 00:04:21.620
all the migration that have been applied.

85
00:04:21.620 --> 00:04:23.950
Now the most important feature, I think,

86
00:04:23.950 --> 00:04:26.240
is automatic version detection,

87
00:04:26.240 --> 00:04:29.280
and it's kind of the most important one toe have

88
00:04:29.280 --> 00:04:31.250
because you have your application,

89
00:04:31.250 --> 00:04:35.840
which is as Version one database isn't seeing with your application.

90
00:04:35.840 --> 00:04:39.020
But then we're upgrading the application to Version two,

91
00:04:39.020 --> 00:04:42.170
and you want to deploy it to the particular customer.

92
00:04:42.170 --> 00:04:45.680
The application will try to connect to the existing database,

93
00:04:45.680 --> 00:04:47.990
which is now at version one.

94
00:04:47.990 --> 00:04:50.910
However, this is not going to be possible.

95
00:04:50.910 --> 00:04:53.540
So that component, Mr Trigger,

96
00:04:53.540 --> 00:04:58.520
a data migration on the database after the migration complete,

97
00:04:58.520 --> 00:05:03.590
will have a new database upgraded to match with your application version.

98
00:05:03.590 --> 00:05:06.290
So then your application can save to communicate

99
00:05:06.290 --> 00:05:08.610
with the updated data structures.

100
00:05:08.610 --> 00:05:18.000
That's how automatic database version mechanisms work, and your component should definitely have this feature.

