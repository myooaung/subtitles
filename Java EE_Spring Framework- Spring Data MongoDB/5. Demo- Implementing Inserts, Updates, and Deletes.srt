1
00:00:00,950 --> 00:00:04,350
[Autogenerated] it's time to get our hands dirty and write some coat.

2
00:00:04,350 --> 00:00:06,790
In his demo, we're going to implement, assert,

3
00:00:06,790 --> 00:00:11,430
update and greet operations in a spring application that targets Mongo TV.

4
00:00:11,430 --> 00:00:14,410
We're going to look at single operations they

5
00:00:14,410 --> 00:00:16,430
regard to tackle better operations,

6
00:00:16,430 --> 00:00:20,370
and we'll wrap it up by implementing some custom converters.

7
00:00:20,370 --> 00:00:22,780
Let's get to work before we get started.

8
00:00:22,780 --> 00:00:26,610
I'd like you to know that I have removed all the flights from our collection.

9
00:00:26,610 --> 00:00:29,170
We're going to start with an empty collection.

10
00:00:29,170 --> 00:00:32,590
I also made another change in the Application properties file.

11
00:00:32,590 --> 00:00:36,570
I've have added the park looking for a monk, Oh, temperate component.

12
00:00:36,570 --> 00:00:39,920
This will allow us to see how method calls among go template get

13
00:00:39,920 --> 00:00:43,930
translated into mongo to be queries very useful for trying to

14
00:00:43,930 --> 00:00:46,220
understand what's happening under the hood.

15
00:00:46,220 --> 00:00:49,640
The first thing that won't implement is a database cedar who want

16
00:00:49,640 --> 00:00:51,990
to make sure that when the application fires up,

17
00:00:51,990 --> 00:00:55,500
it pre populates some items into the database.

18
00:00:55,500 --> 00:00:57,090
In our case, a couple of flights,

19
00:00:57,090 --> 00:00:59,420
the databases that implements command and runner,

20
00:00:59,420 --> 00:01:03,440
which means that spring is going to execute it after your bootstraps.

21
00:01:03,440 --> 00:01:06,940
We also have an allocation here at order with the Valley one.

22
00:01:06,940 --> 00:01:09,850
We're using it because you want to make sure that this is the first

23
00:01:09,850 --> 00:01:12,250
commander runner that spring is going to execute.

24
00:01:12,250 --> 00:01:15,970
This would ensure us that we have data in our collection when

25
00:01:15,970 --> 00:01:18,780
we run other features of the application.

26
00:01:18,780 --> 00:01:19,270
And, of course,

27
00:01:19,270 --> 00:01:24,150
we have the wrong method in which we're calling empty and seed empty to

28
00:01:24,150 --> 00:01:28,890
remove all the priests in documents and seat toe Adan Nuance.

29
00:01:28,890 --> 00:01:30,060
Let's start with seed.

30
00:01:30,060 --> 00:01:33,960
We are defining a couple of flight information objects over here using centers.

31
00:01:33,960 --> 00:01:35,240
So nothing fancy.

32
00:01:35,240 --> 00:01:39,690
And now we want to insert all of these documents in mongo.

33
00:01:39,690 --> 00:01:41,510
Maybe wanted to do it is like this.

34
00:01:41,510 --> 00:01:44,340
We can insert them one by one.

35
00:01:44,340 --> 00:01:46,270
As you know, it's not very efficient,

36
00:01:46,270 --> 00:01:49,310
but I want to show you how that Logar works.

37
00:01:49,310 --> 00:01:52,500
So let's go ahead and fire up The application of the application

38
00:01:52,500 --> 00:01:55,940
started and we can see we have six entries from that log.

39
00:01:55,940 --> 00:01:59,670
Each one telling goes that a new document has been inserted,

40
00:01:59,670 --> 00:02:02,390
which you have six round trips to the database.

41
00:02:02,390 --> 00:02:03,870
So not very efficient.

42
00:02:03,870 --> 00:02:04,250
Of course,

43
00:02:04,250 --> 00:02:07,940
you can replace this with any sort All co we're

44
00:02:07,940 --> 00:02:09,950
grouping all the flights in a collection,

45
00:02:09,950 --> 00:02:12,810
and then we're calling Insert all on mongo template.

46
00:02:12,810 --> 00:02:14,640
If you run the application again,

47
00:02:14,640 --> 00:02:18,730
we'll see an improvement in how queries are being executed.

48
00:02:18,730 --> 00:02:19,460
And here it is.

49
00:02:19,460 --> 00:02:22,700
We now have a single round trip to the database,

50
00:02:22,700 --> 00:02:25,630
and it is illustrated by this log over here asserting

51
00:02:25,630 --> 00:02:28,320
Mr Documents containing six items.

52
00:02:28,320 --> 00:02:30,230
Brilliant, but we're not done yet.

53
00:02:30,230 --> 00:02:32,740
We have not implemented this empty method.

54
00:02:32,740 --> 00:02:34,930
We need to delete every document when the application

55
00:02:34,930 --> 00:02:37,610
starts so that we always start fresh.

56
00:02:37,610 --> 00:02:40,640
We can delete them on by one, but as he so it's not efficient.

57
00:02:40,640 --> 00:02:44,460
So we're just going to perform a more efficient removal.

58
00:02:44,460 --> 00:02:47,490
We're going to call daily movement on the mobile template,

59
00:02:47,490 --> 00:02:49,530
and we're going to pass in on empty quality,

60
00:02:49,530 --> 00:02:50,900
acquitted without criteria.

61
00:02:50,900 --> 00:02:55,810
This would effectively match all the documents that we have in our collection,

62
00:02:55,810 --> 00:02:57,550
not as we have the sedan in place.

63
00:02:57,550 --> 00:03:00,280
Let's go to the application runner again.

64
00:03:00,280 --> 00:03:04,000
This implements commander runner, and it has at order with the value of two,

65
00:03:04,000 --> 00:03:08,170
because you want executed after we have items in our collection.

66
00:03:08,170 --> 00:03:10,180
There are two requests that we have to implement.

67
00:03:10,180 --> 00:03:13,940
The 1st 1 is we need to mark all the flights to Rome as delayed.

68
00:03:13,940 --> 00:03:16,130
So this probably looks like a group update.

69
00:03:16,130 --> 00:03:19,260
And then we have to remove flights with the duration less than two hours.

70
00:03:19,260 --> 00:03:21,530
Again, this kind of looks like a batch, you know,

71
00:03:21,530 --> 00:03:25,720
did it the best in temperament batch of it is to call the update Muti

72
00:03:25,720 --> 00:03:29,070
methods are monk a template for that in Italy Final query.

73
00:03:29,070 --> 00:03:32,010
And in this case, the criteria is the destination city,

74
00:03:32,010 --> 00:03:33,580
which must be a courtroom.

75
00:03:33,580 --> 00:03:36,320
Then we create another object,

76
00:03:36,320 --> 00:03:40,180
and we said that is the late field to be updated to the

77
00:03:40,180 --> 00:03:42,900
value of truth they were calling the update.

78
00:03:42,900 --> 00:03:43,680
Muti mattered,

79
00:03:43,680 --> 00:03:48,040
passing in the query update object and the Fight information class,

80
00:03:48,040 --> 00:03:51,530
we are doing something similar with the removal of flights

81
00:03:51,530 --> 00:03:53,560
that have a duration off less than two hours.

82
00:03:53,560 --> 00:03:58,610
We're building a query, and the criteria is duration less then 120 minutes,

83
00:03:58,610 --> 00:04:02,310
and then we're losing the final remove method to remove

84
00:04:02,310 --> 00:04:05,320
the flights that matched that quick.

85
00:04:05,320 --> 00:04:09,220
After running the application, we can see that everything worked as expected.

86
00:04:09,220 --> 00:04:11,160
The database is they're taking first,

87
00:04:11,160 --> 00:04:14,060
so we're removing all the distant documents in the collection,

88
00:04:14,060 --> 00:04:16,800
then we're asserting six documents.

89
00:04:16,800 --> 00:04:19,060
After that, we have a batch of it.

90
00:04:19,060 --> 00:04:22,400
We're calling update using the Querida two discussed earlier,

91
00:04:22,400 --> 00:04:25,320
and the update object we're setting is delayed.

92
00:04:25,320 --> 00:04:26,980
Too true.

93
00:04:26,980 --> 00:04:28,580
Then we're performing a batch.

94
00:04:28,580 --> 00:04:29,120
Deal it.

95
00:04:29,120 --> 00:04:33,390
So we're finding documents using the duration less than 130 minutes.

96
00:04:33,390 --> 00:04:36,930
And then we're deleting those documents from the collection.

97
00:04:36,930 --> 00:04:38,390
Awesome.

98
00:04:38,390 --> 00:04:39,540
In the first collection,

99
00:04:39,540 --> 00:04:45,310
aircraft are stored as embedded objects in the flight information document.

100
00:04:45,310 --> 00:04:48,010
They have a model, and they have a number of seats.

101
00:04:48,010 --> 00:04:51,100
We have requests that aircraft should really be stored

102
00:04:51,100 --> 00:04:53,150
as a string HQ concocting a ting.

103
00:04:53,150 --> 00:04:55,640
Both the model and the number of seats.

104
00:04:55,640 --> 00:04:59,500
How the implement is well, of course, using custom converters,

105
00:04:59,500 --> 00:05:02,620
I created a new package Parasite Airport Management,

106
00:05:02,620 --> 00:05:05,580
that Debbie and I have added two new classes.

107
00:05:05,580 --> 00:05:09,570
Aircraft Gibby Read converter and aircraft BB right convert.

108
00:05:09,570 --> 00:05:10,540
Let's start with the right.

109
00:05:10,540 --> 00:05:11,310
Converted.

110
00:05:11,310 --> 00:05:14,020
It's a simple class that implements converter.

111
00:05:14,020 --> 00:05:15,320
The sources aircraft.

112
00:05:15,320 --> 00:05:18,370
The destination is drink, and the convert minted.

113
00:05:18,370 --> 00:05:21,840
Just concocting is get model and get number of seats.

114
00:05:21,840 --> 00:05:24,770
The databases are converter is also pretty simple.

115
00:05:24,770 --> 00:05:26,050
It's implements converter,

116
00:05:26,050 --> 00:05:29,500
but it's time the source is string and the destination is aircraft.

117
00:05:29,500 --> 00:05:31,100
You have a convert method,

118
00:05:31,100 --> 00:05:35,070
and here we're splitting that string by that special character.

119
00:05:35,070 --> 00:05:37,540
And then we're building a new aircraft object,

120
00:05:37,540 --> 00:05:40,310
and we are turning it pretty, pretty simple.

121
00:05:40,310 --> 00:05:43,240
The last step is to actually register our converter.

122
00:05:43,240 --> 00:05:46,410
We can register converters in any class annotated with that

123
00:05:46,410 --> 00:05:49,430
configuration because you are in a spring with application.

124
00:05:49,430 --> 00:05:52,020
We can also register them here.

125
00:05:52,020 --> 00:05:53,270
We define the new being.

126
00:05:53,270 --> 00:05:55,620
We're creating an empty list off converters.

127
00:05:55,620 --> 00:05:59,900
Then we're adding the aircraft reader and the aircraft writer converter on.

128
00:05:59,900 --> 00:06:01,810
We're turning and ministers off Monk,

129
00:06:01,810 --> 00:06:06,500
a custom conversions passing in the converters that we have just created.

130
00:06:06,500 --> 00:06:09,740
Let's honor it up and see if this made any difference.

131
00:06:09,740 --> 00:06:11,710
If you go back to Mongo Compass,

132
00:06:11,710 --> 00:06:15,630
we can see that the aircraft field isn't are serialized as a strength,

133
00:06:15,630 --> 00:06:19,440
and this means that our converters were successfully registered.

134
00:06:19,440 --> 00:06:23,480
Before we conclude this devil, I want to make an important remark.

135
00:06:23,480 --> 00:06:28,180
That database, either that we implement it is by no means production ready.

136
00:06:28,180 --> 00:06:32,300
Sure, it was great for demos, and he does his job,

137
00:06:32,300 --> 00:06:34,590
but it's not suitable for production.

138
00:06:34,590 --> 00:06:37,220
We'll see a better alternative once we explore that.

139
00:06:37,220 --> 00:06:40,000
Ah, migration's later on. In his course,

