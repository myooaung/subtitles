1
00:00:00,380 --> 00:00:03,850
[Autogenerated] I bet you're pretty eager to write a first test in

2
00:00:03,850 --> 00:00:08,140
this demo are going to implement mongo integration tests in spring

3
00:00:08,140 --> 00:00:13,330
applications so far up your ID's and less recent cult before right

4
00:00:13,330 --> 00:00:14,830
in the line of code Rito,

5
00:00:14,830 --> 00:00:19,350
figure out what parts of our data access layer I was trying to test.

6
00:00:19,350 --> 00:00:24,110
The obvious candidates are the repositories and the generic Caskey listener.

7
00:00:24,110 --> 00:00:27,200
The airport depository extends Munk reports story,

8
00:00:27,200 --> 00:00:29,840
but adds no additional methods.

9
00:00:29,840 --> 00:00:32,990
Therefore, we don't have to test it flight information.

10
00:00:32,990 --> 00:00:37,220
Boy's story, on the other hand, adds free additional methods.

11
00:00:37,220 --> 00:00:40,770
They are all good candidates for writing integration tests.

12
00:00:40,770 --> 00:00:41,420
However,

13
00:00:41,420 --> 00:00:44,770
I think the most fragile method is the last one because it

14
00:00:44,770 --> 00:00:48,330
needs a quarry defined as a string toe work.

15
00:00:48,330 --> 00:00:50,320
And this can be very era prom,

16
00:00:50,320 --> 00:00:54,230
So we're going to write on integration test for it.

17
00:00:54,230 --> 00:00:56,740
We can also test ordinary Caskey listener.

18
00:00:56,740 --> 00:01:00,070
We want to make sure that when you save a parent document,

19
00:01:00,070 --> 00:01:03,680
the channel documents are saved if they do not exist.

20
00:01:03,680 --> 00:01:07,590
So we're going to add a second test for dysfunctionality.

21
00:01:07,590 --> 00:01:10,650
Now we have to decide if you want to use on embedded at

22
00:01:10,650 --> 00:01:13,640
the base or a standard on database.

23
00:01:13,640 --> 00:01:17,760
We'll start with the first approach to use an embedded database.

24
00:01:17,760 --> 00:01:21,530
We first need to define the dependency in the bomb dot xml file

25
00:01:21,530 --> 00:01:24,680
notice the scope of the dependency is test.

26
00:01:24,680 --> 00:01:30,200
This means that when we execute tests, the embedded database is going to be used.

27
00:01:30,200 --> 00:01:35,340
But when our application rising production a really database is going to abused,

28
00:01:35,340 --> 00:01:39,250
which is exactly the kind of behavior that you want we can all right,

29
00:01:39,250 --> 00:01:42,640
our first this class, we'll call it not our base integration.

30
00:01:42,640 --> 00:01:46,010
This not these the annotations present above.

31
00:01:46,010 --> 00:01:48,310
We have at data mongo test.

32
00:01:48,310 --> 00:01:53,340
This enables us to use mongo related beans and oughta wear them.

33
00:01:53,340 --> 00:01:56,320
Mogul template, airport depository and flight information.

34
00:01:56,320 --> 00:01:57,920
Post story are good examples.

35
00:01:57,920 --> 00:02:01,060
We don't have the at extended sanitation.

36
00:02:01,060 --> 00:02:02,950
We're also importing the data base.

37
00:02:02,950 --> 00:02:07,540
This configuration class, let's take a look at it.

38
00:02:07,540 --> 00:02:12,310
A database this configuration is annotated with at test configuration and it

39
00:02:12,310 --> 00:02:17,130
defines one additional being the generic cascade listener because legendary

40
00:02:17,130 --> 00:02:22,410
Caskey listener is not among component the spring test context cannot use it

41
00:02:22,410 --> 00:02:25,340
by using solely the at data mongo test.

42
00:02:25,340 --> 00:02:28,700
So we need to define it here and use this configuration.

43
00:02:28,700 --> 00:02:29,470
Remember,

44
00:02:29,470 --> 00:02:34,010
at data Mongo test makes Mongo related beings available

45
00:02:34,010 --> 00:02:37,500
for other wearing not other components.

46
00:02:37,500 --> 00:02:38,950
Before we write our first test,

47
00:02:38,950 --> 00:02:45,520
we also need to make sure that our databases properly clean and initialized.

48
00:02:45,520 --> 00:02:48,760
So we need a before each and then after reach method.

49
00:02:48,760 --> 00:02:53,750
Let's start by implementing the before each.

50
00:02:53,750 --> 00:02:59,030
This method is an idiot with at before each, we define free airports.

51
00:02:59,030 --> 00:03:02,700
We save them tow are embedded database using the airport poised,

52
00:03:02,700 --> 00:03:04,700
very civil method.

53
00:03:04,700 --> 00:03:05,230
And then Rick,

54
00:03:05,230 --> 00:03:09,060
wait some flights which we again save using the flight

55
00:03:09,060 --> 00:03:13,720
information report story When our tests are executed,

56
00:03:13,720 --> 00:03:16,970
this data should be available for them, but we're not finished.

57
00:03:16,970 --> 00:03:21,080
Also need to clear all the other base after each test is executed.

58
00:03:21,080 --> 00:03:21,780
For that,

59
00:03:21,780 --> 00:03:26,130
we can use the after each method is method is annotated with the gene it at

60
00:03:26,130 --> 00:03:29,870
after each and the method implementation is participle.

61
00:03:29,870 --> 00:03:32,550
We're using the model template to drop the airport

62
00:03:32,550 --> 00:03:37,880
and flight information collections, thus emptying our database.

63
00:03:37,880 --> 00:03:40,830
Let's create a test for our fight information report story.

64
00:03:40,830 --> 00:03:44,860
You want to test that defined by mean l Kraft number

65
00:03:44,860 --> 00:03:47,380
of seats method works as expected.

66
00:03:47,380 --> 00:03:51,110
We're going to use 200 as the minimal number of seats.

67
00:03:51,110 --> 00:03:55,300
Then we're going to call the method on the flight information post story,

68
00:03:55,300 --> 00:04:00,230
and we're going to serve that a single flight matches the criteria.

69
00:04:00,230 --> 00:04:01,970
If we look at our visitor,

70
00:04:01,970 --> 00:04:07,750
we can see that we have one flight which has an aircraft that has 280 seats.

71
00:04:07,750 --> 00:04:12,650
So this flight should match our criteria, lets out a test for a generic.

72
00:04:12,650 --> 00:04:14,940
Ask a listener.

73
00:04:14,940 --> 00:04:19,720
Mister, we're defining two new airports Bucharest in London.

74
00:04:19,720 --> 00:04:23,360
Then we're creating the new flight information and we're using Big

75
00:04:23,360 --> 00:04:26,240
Krista's departure in London as this nation.

76
00:04:26,240 --> 00:04:29,590
We are then saving this light using the insert method on

77
00:04:29,590 --> 00:04:32,220
the fight information repositories.

78
00:04:32,220 --> 00:04:36,590
We want to test that our flight or saved in the other base,

79
00:04:36,590 --> 00:04:42,610
but also that the two airports were saved in the airport collection were already

80
00:04:42,610 --> 00:04:47,440
to run our tests and we can see that both tests succeeded.

81
00:04:47,440 --> 00:04:48,280
Looking at the logs,

82
00:04:48,280 --> 00:04:51,000
we can also see that these deaths were executed

83
00:04:51,000 --> 00:04:54,080
against an embedded mom without a base.

84
00:04:54,080 --> 00:04:58,840
Let's go ahead and try to run the same tests on a standard on database.

85
00:04:58,840 --> 00:04:59,640
To achieve this,

86
00:04:59,640 --> 00:05:02,020
me to delete the embedded among without a base

87
00:05:02,020 --> 00:05:03,850
dependency because you won't need it anymore.

88
00:05:03,850 --> 00:05:05,760
We'll connect to an actual Mongol.

89
00:05:05,760 --> 00:05:11,030
Armies also need to update our that our base days configuration going to define

90
00:05:11,030 --> 00:05:17,400
a mongo temporal bean that is going to connect to our test that always and we

91
00:05:17,400 --> 00:05:20,160
add in this two B's one for Mongo to be factory,

92
00:05:20,160 --> 00:05:23,300
which contains the connection to our __ tests.

93
00:05:23,300 --> 00:05:27,290
That always and the 2nd 1 for the Mongol template,

94
00:05:27,290 --> 00:05:33,010
which uses the factory find above hard disk less remains the same.

95
00:05:33,010 --> 00:05:34,920
There is no modification that needs to be done.

96
00:05:34,920 --> 00:05:36,540
We're here.

97
00:05:36,540 --> 00:05:40,220
We can now execute artists again and see the outcome,

98
00:05:40,220 --> 00:05:45,540
and that this best I wanted to use these two approaches because

99
00:05:45,540 --> 00:05:48,040
I wanted to highlight unimportant aspect.

100
00:05:48,040 --> 00:05:51,120
It's extremely easy to switch from one in bed,

101
00:05:51,120 --> 00:05:54,270
among without a base to an actual moon without a base.

102
00:05:54,270 --> 00:05:57,340
He took us like 30 seconds.

103
00:05:57,340 --> 00:06:00,620
That's why I'm recommending that you start with the embedded approach

104
00:06:00,620 --> 00:06:04,280
first because it would speed up your development and then before we

105
00:06:04,280 --> 00:06:07,980
ship the production switch to an actual man without a ways in order

106
00:06:07,980 --> 00:06:13,000
to test for that oxes layer. In a more realistic scenario,

