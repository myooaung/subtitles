WEBVTT
1
00:00:01.140 --> 00:00:04.940
[Autogenerated] congratulations for reaching the final module off discourse.

2
00:00:04.940 --> 00:00:07.870
And what better way to end it On a discussion about

3
00:00:07.870 --> 00:00:10.540
testing the data access layer?

4
00:00:10.540 --> 00:00:13.110
We're going to start by looking at integration

5
00:00:13.110 --> 00:00:15.080
testing from a general perspective.

6
00:00:15.080 --> 00:00:17.450
Then we're going to learn how to create mongo

7
00:00:17.450 --> 00:00:20.020
integration tests in spring applications,

8
00:00:20.020 --> 00:00:23.780
and we'll wrap it up the demo, which would implement what you have learned.

9
00:00:23.780 --> 00:00:25.640
Let's start with the beginning.

10
00:00:25.640 --> 00:00:29.930
I think you're all familiar with the testing pyramid at the base.

11
00:00:29.930 --> 00:00:31.250
We have unit tests.

12
00:00:31.250 --> 00:00:36.560
We should write as many units as possible because they're fast, Is it right?

13
00:00:36.560 --> 00:00:37.660
And cheap?

14
00:00:37.660 --> 00:00:40.660
Integration tests are more complicated to set up,

15
00:00:40.660 --> 00:00:43.230
but they provide a lot of value off course.

16
00:00:43.230 --> 00:00:44.800
We'll have less integration tests.

17
00:00:44.800 --> 00:00:49.500
The uterus last Panelist at the very top we have enter in testing,

18
00:00:49.500 --> 00:00:51.820
more distinct, the data access layer.

19
00:00:51.820 --> 00:00:56.010
In spring, applications will focus on integration tests.

20
00:00:56.010 --> 00:01:00.420
Integration Testing is the type of testing where individual pieces off softer,

21
00:01:00.420 --> 00:01:03.400
are combined and executed as a group.

22
00:01:03.400 --> 00:01:06.000
That makes sense, but you might be wondering,

23
00:01:06.000 --> 00:01:09.080
Why would I ever want to test the data axes?

24
00:01:09.080 --> 00:01:12.760
They're after all, we have marking framers for that, right?

25
00:01:12.760 --> 00:01:18.060
You can certainly use Mark's replace the component that handle data persistence.

26
00:01:18.060 --> 00:01:20.850
But I think there's a lot of value in testing the day

27
00:01:20.850 --> 00:01:24.440
taxes there in spring applications.

28
00:01:24.440 --> 00:01:30.480
First of all, data is at the core off most enterprise softer applications,

29
00:01:30.480 --> 00:01:35.540
so it pays off to test those components that are dealing with data.

30
00:01:35.540 --> 00:01:38.240
Then you might want to make sure that your application

31
00:01:38.240 --> 00:01:41.800
gracefully handles each cases or exceptions,

32
00:01:41.800 --> 00:01:42.830
and as banal ease,

33
00:01:42.830 --> 00:01:47.130
it's pretty easy to perform data access their integration testing in spring,

34
00:01:47.130 --> 00:01:50.750
so you have really no excuse for not doing it.

35
00:01:50.750 --> 00:01:55.930
Let's look at the anatomy off on integration test for the day taxes there.

36
00:01:55.930 --> 00:01:58.030
First of all, you create the test.

37
00:01:58.030 --> 00:02:01.810
Then it was set up the data in your database.

38
00:02:01.810 --> 00:02:07.700
You can then execute a test, which usually involves that of this operation us.

39
00:02:07.700 --> 00:02:12.390
So the result And last but not least, you empty the database,

40
00:02:12.390 --> 00:02:16.660
and this process goes on and on for every test.

41
00:02:16.660 --> 00:02:21.060
That right, it's very, very important to set up the data,

42
00:02:21.060 --> 00:02:25.180
basing every test and clear the database after each test

43
00:02:25.180 --> 00:02:28.900
because this should be predictable.

44
00:02:28.900 --> 00:02:33.340
If the data in your database is volatile, your tests will be Flack E.

45
00:02:33.340 --> 00:02:36.300
If you're using the same database and not resetting,

46
00:02:36.300 --> 00:02:39.740
get total initial state after each test execution so that

47
00:02:39.740 --> 00:02:43.250
operations performed in one tests are going to interfere

48
00:02:43.250 --> 00:02:45.700
with the assertions in other tests.

49
00:02:45.700 --> 00:02:48.950
This is certainly not something that you want.

50
00:02:48.950 --> 00:02:54.340
So make sure that every test starts from a Britney, well known state.

51
00:02:54.340 --> 00:02:59.430
All right, do we have to test every piece of code that caused the database?

52
00:02:59.430 --> 00:03:01.040
I'm glad you asked.

53
00:03:01.040 --> 00:03:02.470
Let's look at an example.

54
00:03:02.470 --> 00:03:05.350
We have an airport service class on the left on the

55
00:03:05.350 --> 00:03:07.700
Nerpa repository on the right.

56
00:03:07.700 --> 00:03:12.320
The airport service has this piece of code where it retrieves all the

57
00:03:12.320 --> 00:03:15.620
airports using the Mongol template vandal method.

58
00:03:15.620 --> 00:03:18.760
Now it would make no sense to create a dedicated

59
00:03:18.760 --> 00:03:21.240
integration test for airport service.

60
00:03:21.240 --> 00:03:24.760
After all, you're just calling the final method on the Mongo template.

61
00:03:24.760 --> 00:03:27.640
And I'm pretty sure the guy's creating the spring

62
00:03:27.640 --> 00:03:32.360
framework have tested that method intensively.

63
00:03:32.360 --> 00:03:34.840
If you look at the airport depository,

64
00:03:34.840 --> 00:03:37.940
you see that we have this method called by country,

65
00:03:37.940 --> 00:03:42.190
and we have the operation defined using at quarry annotation.

66
00:03:42.190 --> 00:03:48.280
The earthquake annotation receives the actual Mongo query as a non argument.

67
00:03:48.280 --> 00:03:50.490
The situation is quite different.

68
00:03:50.490 --> 00:03:54.020
Country, for example, is a property off the airport document.

69
00:03:54.020 --> 00:03:56.350
But if you misspell it or if he changes,

70
00:03:56.350 --> 00:03:59.700
then these method will not work as expected.

71
00:03:59.700 --> 00:04:05.610
So you should definitely test methods like this because they're prone to errors.

72
00:04:05.610 --> 00:04:11.850
Now let's generalize what you should test should always test complex queries.

73
00:04:11.850 --> 00:04:13.560
Watch out for strings,

74
00:04:13.560 --> 00:04:20.370
complex criteria and projections will also test object to document map ings,

75
00:04:20.370 --> 00:04:24.190
especially if you create custom monger map pigs in your application.

76
00:04:24.190 --> 00:04:27.430
And last journalist should also test lifecycle events.

77
00:04:27.430 --> 00:04:28.210
If he employment.

78
00:04:28.210 --> 00:04:29.520
That's getting, for example,

79
00:04:29.520 --> 00:04:38.000
it's a good practice to test that when you save the parent document, the chair documents also get saved.

