WEBVTT
1
00:00:01.240 --> 00:00:04.500
[Autogenerated] I think the best way for you to learn how to create an

2
00:00:04.500 --> 00:00:08.750
execute Cory's in Spring Among Go is to look at a real example.

3
00:00:08.750 --> 00:00:09.920
Remember this query?

4
00:00:09.920 --> 00:00:13.140
It's what he used earlier on in the course.

5
00:00:13.140 --> 00:00:18.060
We're basically fetching all the people that have the age greater than

6
00:00:18.060 --> 00:00:22.100
18 and then we apply some sorting and imagination.

7
00:00:22.100 --> 00:00:26.450
In order to execute this query, we need to use the Mongol template class.

8
00:00:26.450 --> 00:00:29.640
More specifically, we need to use the find method.

9
00:00:29.640 --> 00:00:32.040
The fine method has two parameters.

10
00:00:32.040 --> 00:00:34.340
The 1st 1 is the query by age,

11
00:00:34.340 --> 00:00:37.960
and the 2nd 1 is the person class is the type off

12
00:00:37.960 --> 00:00:41.940
document that we want to query against,

13
00:00:41.940 --> 00:00:44.460
and the outcome of this method is the list off

14
00:00:44.460 --> 00:00:47.390
persons that matches the given query.

15
00:00:47.390 --> 00:00:53.440
This is the recipe that you use in orderto executor queries in spring and mongo.

16
00:00:53.440 --> 00:00:58.860
But now let's take a look at things in more detail.

17
00:00:58.860 --> 00:01:02.610
Fetching data with mongo template usually involves three steps.

18
00:01:02.610 --> 00:01:05.920
You definitely need the query definition that contains the

19
00:01:05.920 --> 00:01:10.440
criteria and optionally sorting and imagination.

20
00:01:10.440 --> 00:01:13.670
Then you need to decide the outcome off the query.

21
00:01:13.670 --> 00:01:15.850
They want to retrieve a single document.

22
00:01:15.850 --> 00:01:18.270
Do you want to fetch many documents that much?

23
00:01:18.270 --> 00:01:19.120
A query.

24
00:01:19.120 --> 00:01:21.930
Do you want to count the documents that match the given?

25
00:01:21.930 --> 00:01:22.630
Pretty.

26
00:01:22.630 --> 00:01:26.630
These are questions that you should ask yourself and last but not least,

27
00:01:26.630 --> 00:01:30.340
neither class type that contains the mongo imitations.

28
00:01:30.340 --> 00:01:32.540
Those annotations are pretty important because they

29
00:01:32.540 --> 00:01:34.080
give you the collection name.

30
00:01:34.080 --> 00:01:37.060
So spring knows in which collection tok'ra data.

31
00:01:37.060 --> 00:01:40.870
And they also give you information about fields which impact

32
00:01:40.870 --> 00:01:44.350
serialization and this realization There are many methods that

33
00:01:44.350 --> 00:01:47.420
continues to retrieve information.

34
00:01:47.420 --> 00:01:50.810
There is final to retrieve all the documents in a

35
00:01:50.810 --> 00:01:54.780
particular collection we cannot find that is used to

36
00:01:54.780 --> 00:01:57.100
return documents that match even query.

37
00:01:57.100 --> 00:02:00.760
We have find one if you're interested to retrieve just a

38
00:02:00.760 --> 00:02:02.970
single document that matches a given query,

39
00:02:02.970 --> 00:02:04.560
and we also have count,

40
00:02:04.560 --> 00:02:09.380
which it turns the number of documents that match a particular quick

41
00:02:09.380 --> 00:02:12.840
Let's complicate things a little bit and look at more detailed

42
00:02:12.840 --> 00:02:17.810
examples I'll be using The aircraft Document aircraft is a simple

43
00:02:17.810 --> 00:02:20.080
class identity with a document.

44
00:02:20.080 --> 00:02:23.790
It has a couple of fields i D or internal code,

45
00:02:23.790 --> 00:02:26.520
the aircraft family, the number of seats and the engine,

46
00:02:26.520 --> 00:02:31.040
which is a sub document containing the needs maintenance bullion field.

47
00:02:31.040 --> 00:02:33.980
If we want to retrieve all the aircraft in the collection,

48
00:02:33.980 --> 00:02:35.830
we have two ways to Childress.

49
00:02:35.830 --> 00:02:36.640
First,

50
00:02:36.640 --> 00:02:39.570
we can call the final method on the Mongol tempera

51
00:02:39.570 --> 00:02:42.440
class at passing the document type.

52
00:02:42.440 --> 00:02:46.550
Another alternative would be to create a query without criteria.

53
00:02:46.550 --> 00:02:48.740
In our case, this created empty query,

54
00:02:48.740 --> 00:02:53.140
and then we can pass it to the fine method off the Mongol temperate class.

55
00:02:53.140 --> 00:02:57.580
Both methods produce the same result all the aircraft in the collection.

56
00:02:57.580 --> 00:02:58.190
However,

57
00:02:58.190 --> 00:03:01.150
the second approach is a little bit more flexible because you

58
00:03:01.150 --> 00:03:04.510
can introduce paging and sorting into the mix.

59
00:03:04.510 --> 00:03:07.800
We have dedicated methods for retrieving single documents.

60
00:03:07.800 --> 00:03:10.290
If you want to filter by i d.

61
00:03:10.290 --> 00:03:14.030
Then we have this method find by a D available on the market.

62
00:03:14.030 --> 00:03:17.960
The class we're passing the idea and the document type,

63
00:03:17.960 --> 00:03:19.840
and we're pretty much done.

64
00:03:19.840 --> 00:03:25.280
We can also great a query that returns a single result.

65
00:03:25.280 --> 00:03:28.720
We need to define the criteria and then we can use the find

66
00:03:28.720 --> 00:03:33.190
one method on the Morgan temperate class.

67
00:03:33.190 --> 00:03:36.650
We can apply multiple filters to a single field by chaining

68
00:03:36.650 --> 00:03:40.470
operators if you want to filter all the aircraft that have the

69
00:03:40.470 --> 00:03:43.490
number of seats between a minimum max value.

70
00:03:43.490 --> 00:03:46.240
We defined criteria on the number of seats field,

71
00:03:46.240 --> 00:03:51.040
and then we change the greater than and less than operators.

72
00:03:51.040 --> 00:03:55.600
We can complicate things even further and make a composite

73
00:03:55.600 --> 00:04:00.280
criteria using logical operators here if you're using the or

74
00:04:00.280 --> 00:04:04.420
operator and we pass in a list off criteria.

75
00:04:04.420 --> 00:04:09.090
One criteria filters aircraft whose families 77 the second

76
00:04:09.090 --> 00:04:11.900
criteria filters aircraft by the number of seats.

77
00:04:11.900 --> 00:04:17.810
If any of these criteria is evaluated to true, then the document is returned.

78
00:04:17.810 --> 00:04:20.740
That's what the operator does.

79
00:04:20.740 --> 00:04:23.490
We also have the operator here.

80
00:04:23.490 --> 00:04:28.680
If all criteria, it's very true, then the document is returned.

81
00:04:28.680 --> 00:04:30.650
Else it is not.

82
00:04:30.650 --> 00:04:36.180
You can see how easy it is to create complex queries by nesting

83
00:04:36.180 --> 00:04:40.640
criteria together and by using is logical operators.

84
00:04:40.640 --> 00:04:44.930
But what if you want to filter by a field in a sub document?

85
00:04:44.930 --> 00:04:45.510
Well,

86
00:04:45.510 --> 00:04:51.830
we get also this using criteria we can use dot to traverse the object graph.

87
00:04:51.830 --> 00:04:52.840
In this example,

88
00:04:52.840 --> 00:04:55.480
we're querying all the aircraft whose engine needs

89
00:04:55.480 --> 00:04:57.700
maintenance in the quite your definition.

90
00:04:57.700 --> 00:05:02.420
Engine is a property of aircraft and its maintenance is a property off engine.

91
00:05:02.420 --> 00:05:08.640
Using that, we can navigate the object graph and find the fields that we need.

92
00:05:08.640 --> 00:05:10.080
The rest is pretty simple.

93
00:05:10.080 --> 00:05:11.880
It past the equator to the fine method.

94
00:05:11.880 --> 00:05:17.760
And then you provide a document type two so results we can use the with method.

95
00:05:17.760 --> 00:05:20.390
In the with method, we can provide a sorting definition.

96
00:05:20.390 --> 00:05:22.380
Here, the direction is ascending,

97
00:05:22.380 --> 00:05:25.110
and then we have the field on which you want to sort.

98
00:05:25.110 --> 00:05:29.030
In our case, number of seats, we can complicate a query even more.

99
00:05:29.030 --> 00:05:30.920
And at Beijing again,

100
00:05:30.920 --> 00:05:34.100
we're using the wit knitted and then recreate a page definition.

101
00:05:34.100 --> 00:05:37.930
We use the pager kissed object record off method,

102
00:05:37.930 --> 00:05:40.720
and then you passing the page number and base eyes will

103
00:05:40.720 --> 00:05:42.560
be low query capacity in tomorrow.

104
00:05:42.560 --> 00:05:45.440
Template on, we're done.

105
00:05:45.440 --> 00:05:49.180
We've looked at a couple of queries ranging from simple to complex,

106
00:05:49.180 --> 00:05:52.050
but they all respect the same recipe.

107
00:05:52.050 --> 00:05:54.030
You need the query definition.

108
00:05:54.030 --> 00:05:57.690
You need to decide what they want to return one document

109
00:05:57.690 --> 00:06:00.510
multiple documents or all the documents,

110
00:06:00.510 --> 00:06:05.830
and then you need to provide the class type that contains the mongo annotations.

111
00:06:05.830 --> 00:06:11.000
Think about this when you're building queries and everything is going to be a breeze

