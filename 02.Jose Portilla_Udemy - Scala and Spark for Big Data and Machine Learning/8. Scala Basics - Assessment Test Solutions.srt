1
00:00:05,450 --> 00:00:10,870
Hello everyone and welcome to the solutions lecture for the skull a basic assessment test questions.

2
00:00:10,880 --> 00:00:12,200
Now there were just a few questions.

3
00:00:12,200 --> 00:00:13,650
They were all pretty straightforward.

4
00:00:13,760 --> 00:00:18,420
Well let's go ahead and jump to the spark shell actually answer those questions.

5
00:00:18,440 --> 00:00:18,670
All right.

6
00:00:18,680 --> 00:00:22,750
Here I am I've already started a spark shell and I'm at the scal interpreter.

7
00:00:22,970 --> 00:00:26,510
Our first question is what is to to the power of five.

8
00:00:26,780 --> 00:00:34,840
So hopefully you remember from the arithmetic and numbers lecture that you can just use math that p

9
00:00:35,110 --> 00:00:45,970
o w for power and then just type in 2 and 5 in the return back 32 which is to the power of 5 OK the

10
00:00:45,970 --> 00:00:48,630
next question was What does the remainder of 180.

11
00:00:48,670 --> 00:00:54,880
Divided by 7 Pothier remember that when we were covering booleans in comparison operators I mentioned

12
00:00:55,000 --> 00:00:58,350
the Maatta operator which is that percent sign operation.

13
00:00:58,510 --> 00:01:05,100
In that case you can just say 180 Mada 7 and you get that the remainder is 5.

14
00:01:05,410 --> 00:01:06,340
OK let's go ahead.

15
00:01:06,340 --> 00:01:08,130
Move onto the next question.

16
00:01:08,140 --> 00:01:08,530
All right.

17
00:01:08,530 --> 00:01:13,150
That next question was given the variable underscore name is equal to Samie.

18
00:01:13,230 --> 00:01:17,210
You string interpellation to print out my dog's name is Samie.

19
00:01:17,230 --> 00:01:24,920
So let's go ahead and create that variable Larpent underscore name is equal to Sammy.

20
00:01:24,980 --> 00:01:30,380
So we get that string variable and then we can just use that notation quo.

21
00:01:30,380 --> 00:01:34,270
And then we can type in my dog's name is and then a dollar sign.

22
00:01:34,550 --> 00:01:39,430
And then our variable name in this case it's pet name OK.

23
00:01:39,480 --> 00:01:43,310
And you could have also used value there or Val if you wanted to.

24
00:01:43,320 --> 00:01:46,170
Let's go ahead and move onto the next question.

25
00:01:46,170 --> 00:01:52,170
All right that next question was to use golf to find out if the letter sequence x y z is contained in

26
00:01:52,170 --> 00:01:53,490
this long string.

27
00:01:53,490 --> 00:01:54,820
So sad.

28
00:01:54,980 --> 00:01:55,850
Whatever.

29
00:01:55,890 --> 00:01:58,830
And you'll notice that X Y Z is actually there.

30
00:01:58,840 --> 00:02:00,880
Now let me go ahead and show you how we can do that.

31
00:02:00,960 --> 00:02:11,690
And then to create a value called us and said equal to that long string just go ahead and copy and paste

32
00:02:11,690 --> 00:02:22,310
it in there enter and then we'll go ahead and say S contains X Y Z and check if it's true or not.

33
00:02:22,370 --> 00:02:24,110
And in this case it is true.

34
00:02:24,110 --> 00:02:25,270
So it wanted you to figure out.

35
00:02:25,270 --> 00:02:31,140
Here is to remember that contains keyword from the strings and regular expressions lecture.

36
00:02:31,160 --> 00:02:33,440
Let's go ahead and move on to the next question.

37
00:02:33,440 --> 00:02:33,970
All right.

38
00:02:33,980 --> 00:02:39,160
Next question was What is the difference between a value and a variable.

39
00:02:39,390 --> 00:02:44,240
So remember that a value is an immutable storage unit meaning you can assign it data when you're defining

40
00:02:44,240 --> 00:02:50,030
it but you can't reassign that data to it and a variable is a mutable storage unit meaning data can

41
00:02:50,030 --> 00:02:53,850
be assigned not only at definition but it can be reassigned later on.

42
00:02:53,870 --> 00:02:59,320
Let me go on to show you a quick example or say Valot A is equal to two.

43
00:02:59,560 --> 00:03:01,040
Ill make a variable.

44
00:03:01,040 --> 00:03:03,320
Be equal to three.

45
00:03:03,320 --> 00:03:10,260
So if I go ahead and take my value and try to reassign it so we'll say actually a let's going to try

46
00:03:10,260 --> 00:03:12,590
to reassign it to a string.

47
00:03:12,590 --> 00:03:13,270
Hello.

48
00:03:13,400 --> 00:03:16,920
Well we know that's not going to work because we can't reassign it to different data type.

49
00:03:17,090 --> 00:03:21,980
But we also can't reassign it to even the same data type in integer because it'll always report back

50
00:03:22,010 --> 00:03:25,220
that you're trying to reassign a value which is not possible.

51
00:03:25,220 --> 00:03:28,060
However for the variable in this case it was B.

52
00:03:28,160 --> 00:03:30,610
We try to reassign it to a string.

53
00:03:31,640 --> 00:03:37,250
We'll go ahead and receive an error type mismatch but we can reassign it to the same data type.

54
00:03:37,250 --> 00:03:38,720
In this case it was an integer.

55
00:03:38,750 --> 00:03:43,850
So if we say physical 1 to 3 now B has been reassigned since it's a variable.

56
00:03:43,910 --> 00:03:45,020
And that's really the main difference.

57
00:03:45,020 --> 00:03:47,290
Remember a value can't be reassigned.

58
00:03:47,300 --> 00:03:48,960
A variable can be.

59
00:03:49,160 --> 00:03:51,980
All right let's go ahead and move on to the last question.

60
00:03:51,980 --> 00:03:56,690
That last question was a little tricky because I didn't exactly show you how to do something as far

61
00:03:56,690 --> 00:03:58,850
as indexing from a nested tuple.

62
00:03:58,850 --> 00:04:04,700
And it was given the tuple one two three and a nested tuple inside of four five six retrieved the number

63
00:04:04,730 --> 00:04:05,740
six.

64
00:04:05,750 --> 00:04:11,810
So hopefully you remembered that you can use the dot underscore notation to actually retrieve numbers

65
00:04:11,840 --> 00:04:13,580
or objects from a tuple.

66
00:04:13,580 --> 00:04:15,150
Let me go in and show you what I mean by that.

67
00:04:15,200 --> 00:04:18,050
I'll say a vowel of T is equal to this tuple.

68
00:04:18,050 --> 00:04:25,280
So you want to come up three and then we'll have that nested tuple inside of four five six.

69
00:04:25,340 --> 00:04:26,940
And here we have the integers.

70
00:04:26,940 --> 00:04:33,280
Now remember we want to grab 6 but it's actually nested inside another tuple in that tuple is that element

71
00:04:33,350 --> 00:04:36,440
for cause tuples indexing starts at 1.

72
00:04:36,470 --> 00:04:38,380
So say t underscore.

73
00:04:38,420 --> 00:04:42,300
For now we can see there that we actually have that tuple.

74
00:04:42,320 --> 00:04:44,080
So there's various ways you can do this.

75
00:04:44,090 --> 00:04:49,990
You can actually re-assign see the underscore for to another value and do the indexing again.

76
00:04:50,120 --> 00:04:58,040
Or you can actually just stack the index so you can say t underscore for the underscore three since

77
00:04:58,030 --> 00:05:01,910
it's at the third position there and then you get the integer 6.

78
00:05:01,940 --> 00:05:06,800
The other way you could have done this is just split this up into two steps by re-assigning Teeka underscore

79
00:05:06,830 --> 00:05:11,000
four to another value such as it's going savey.

80
00:05:11,260 --> 00:05:16,070
Well go ahead and say nest is equal to t the underscore four.

81
00:05:16,130 --> 00:05:20,950
And now if I call nest I have that so I can say nest underscore three.

82
00:05:21,230 --> 00:05:22,070
And that's the same thing.

83
00:05:22,070 --> 00:05:24,210
So it's up to you how you want to do it.

84
00:05:24,230 --> 00:05:28,550
I didn't specifically say that you can stack those index operations on top of each other.

85
00:05:28,550 --> 00:05:31,310
So kudos to you if you're able to figure that out on your own.

86
00:05:31,310 --> 00:05:32,060
All right.

87
00:05:32,060 --> 00:05:35,250
Hopefully those six questions weren't very hard.

88
00:05:35,400 --> 00:05:39,280
Should have been pretty straightforward given what we've covered is just the basics for now.

89
00:05:39,530 --> 00:05:40,000
OK.

90
00:05:40,160 --> 00:05:46,160
Coming up next in the next section we're going to discuss collections such as arrays and maps and sets

91
00:05:46,340 --> 00:05:48,560
to see how we can work with data.

92
00:05:48,560 --> 00:05:50,830
We want to store in some sort of sequence.

93
00:05:50,840 --> 00:05:53,540
Thanks everyone and I'll see you at the next section of the course.
