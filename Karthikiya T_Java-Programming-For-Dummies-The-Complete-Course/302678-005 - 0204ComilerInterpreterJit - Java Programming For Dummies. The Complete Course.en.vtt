WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:08.300
let us take a look at one knee question and Matt equals 10 because 20 c equals a plus B.

00:00:08.300 --> 00:00:09.560
What's the value off?

00:00:09.560 --> 00:00:09.950
See,

00:00:09.950 --> 00:00:12.100
they've just had 30.

00:00:12.100 --> 00:00:13.120
Okay,

00:00:13.120 --> 00:00:13.590
well done.

00:00:13.590 --> 00:00:15.360
You really deserve a standing ovation.

00:00:15.360 --> 00:00:16.240
No.

00:00:16.240 --> 00:00:19.450
One more question for you in computer language.

00:00:19.450 --> 00:00:23.350
Did you get anything you probably wouldn't.

00:00:23.350 --> 00:00:30.490
I just asked you if a equals five and B equals five and C equals a plus B,

00:00:30.490 --> 00:00:31.660
what is the value off?

00:00:31.660 --> 00:00:37.620
See the understand you may find it impossible to read and understand,

00:00:37.620 --> 00:00:43.870
but it's very easy for a computer to understand and its mere impossible for a human to

00:00:43.870 --> 00:00:48.510
remember and court hundreds of combinations of zeros and ones just to write it small tiny

00:00:48.510 --> 00:00:49.350
pizza program.

00:00:49.350 --> 00:00:54.990
So we need to solve this problem and eliminate the trouble to write a program in pure

00:00:54.990 --> 00:00:56.150
computer language.

00:00:56.150 --> 00:00:57.100
Now,

00:00:57.100 --> 00:01:01.530
how about introducing a translator between you and the computer so that you write your

00:01:01.530 --> 00:01:06.960
court like this and the translator will translate it for computer toe this and the

00:01:06.960 --> 00:01:09.080
translator In programming world,

00:01:09.080 --> 00:01:10.550
we call it Compiler.

00:01:10.550 --> 00:01:16.740
So the compiler takes the input off a source while which has your source code in high level

00:01:16.740 --> 00:01:19.620
language and it will gender it an object Fine,

00:01:19.620 --> 00:01:23.370
which has new miracles and characters in special.

00:01:23.370 --> 00:01:26.360
In some weird sequence for us,

00:01:26.360 --> 00:01:28.150
Object file may look weird,

00:01:28.150 --> 00:01:30.550
but it makes perfect sense for a computer.

00:01:30.550 --> 00:01:32.520
And as we know,

00:01:32.520 --> 00:01:39.190
computer processors understand only zeros and ones you need to have a C compiler.

00:01:39.190 --> 00:01:40.550
To compile a C program,

00:01:40.550 --> 00:01:45.150
you need to have a C plus plus compiler to come by the C++ program.

00:01:45.150 --> 00:01:46.430
Similarly,

00:01:46.430 --> 00:01:50.450
we need Java compiler to compile a Java program.

00:01:50.450 --> 00:01:51.650
Are Java source sweat?

00:01:51.650 --> 00:01:54.950
Let's take an example.

00:01:54.950 --> 00:01:59.250
Let's say you wrote the following program in the file and you saved it.

00:01:59.250 --> 00:02:04.100
Let's call it a source file as it has the source coordinate.

00:02:04.100 --> 00:02:05.810
In this programme,

00:02:05.810 --> 00:02:09.560
we will display the result off expressway on your computer screen.

00:02:09.560 --> 00:02:12.270
Now this court has few bugs in it.

00:02:12.270 --> 00:02:16.910
The compiler will start the scanning and translate the source code to mention cord from

00:02:16.910 --> 00:02:17.760
first instruction,

00:02:17.760 --> 00:02:18.900
which is X equals stent.

00:02:18.900 --> 00:02:21.510
And then it goes to line number two,

00:02:21.510 --> 00:02:25.490
which is why I call study and then it treat on display Z.

00:02:25.490 --> 00:02:31.450
The letter Z comes as a surprise for the compiler because until this point,

00:02:31.450 --> 00:02:38.260
it tried very blacks and variable y and know nothing about Z as the compiler did not read

00:02:38.260 --> 00:02:42.410
the line number four yet we're value of these calculator.

00:02:42.410 --> 00:02:48.750
So compiler takes a note off this land number three and then it continues from land number

00:02:48.750 --> 00:02:49.250
four.

00:02:49.250 --> 00:02:51.040
At land number five,

00:02:51.040 --> 00:02:52.350
we have another buck.

00:02:52.350 --> 00:02:56.150
We're trying to displace something that is not previously defined.

00:02:56.150 --> 00:03:03.660
Compiler takes in order off this bug Azra and moves on and continues with line number six.

00:03:03.660 --> 00:03:04.940
No,

00:03:04.940 --> 00:03:06.570
if you compile this program,

00:03:06.570 --> 00:03:08.760
you don't get the output you're expecting.

00:03:08.760 --> 00:03:09.950
Instant.

00:03:09.950 --> 00:03:13.550
You will see a message saying there are two bucks in your court.

00:03:13.550 --> 00:03:16.890
Please fix them before you before you compile once again.

00:03:16.890 --> 00:03:23.580
So the programmer will fix the bug by removing line number three and five has there not off

00:03:23.580 --> 00:03:24.660
any use anyways.

00:03:24.660 --> 00:03:32.120
And he compares the program once again now of your computer Milan it and showed output.

00:03:32.120 --> 00:03:35.970
You're expecting it will be 30 and will be displayed on your screen.

00:03:35.970 --> 00:03:41.270
So the compiler translates your source code in one go and notify us all.

00:03:41.270 --> 00:03:43.250
There's it finds in the end.

00:03:43.250 --> 00:03:50.390
Once the compiler certifies your court that it does not have any bugs in it your computer

00:03:50.390 --> 00:03:54.250
will go ahead and run the program and display the output as 30.

00:03:54.250 --> 00:03:55.610
Okay,

00:03:55.610 --> 00:03:55.890
good.

00:03:55.890 --> 00:04:01.270
Now let's see how the same thing is done in Gets off.

00:04:01.270 --> 00:04:03.640
Interpreter that a steak?

00:04:03.640 --> 00:04:03.990
The same.

00:04:03.990 --> 00:04:04.520
Good.

00:04:04.520 --> 00:04:07.180
Unlike compiler,

00:04:07.180 --> 00:04:08.980
where the program is compiled in one.

00:04:08.980 --> 00:04:14.070
Go and run in one go Interpreter translators Accord line by line.

00:04:14.070 --> 00:04:16.660
Let me explain you what I mean.

00:04:16.660 --> 00:04:21.150
The first Land says the value of X equals 10.

00:04:21.150 --> 00:04:24.280
Now the interpreter translates it to mission language,

00:04:24.280 --> 00:04:29.360
and then mission will run it the very moment the interpreter translates it.

00:04:29.360 --> 00:04:33.850
The mission will not wait for the entire program to be translated.

00:04:33.850 --> 00:04:39.160
Each land will be run by mission the moment it is translator.

00:04:39.160 --> 00:04:43.850
So now Line one is translated and is run by machine.

00:04:43.850 --> 00:04:47.440
Lying to is translated and is run by machine.

00:04:47.440 --> 00:04:48.950
When comes to lie.

00:04:48.950 --> 00:04:49.800
Number three,

00:04:49.800 --> 00:04:51.140
just as combined,

00:04:51.140 --> 00:04:58.080
got surprise off letters E interpreter to get surprised and deport center immediately,

00:04:58.080 --> 00:05:00.600
and it won't for the process.

00:05:00.600 --> 00:05:01.250
The lanes.

00:05:01.250 --> 00:05:06.040
So this time it asked the programmer to fix the bug.

00:05:06.040 --> 00:05:08.950
Only then will it ever go to line them before.

00:05:08.950 --> 00:05:12.530
Since this course is aboard job,

00:05:12.530 --> 00:05:18.070
let's talk a little bit about Java compiler in case off C language or any platform

00:05:18.070 --> 00:05:19.270
dependent language.

00:05:19.270 --> 00:05:24.750
The compiler would come with the source code directly to mention court that the computer

00:05:24.750 --> 00:05:26.050
process can understand.

00:05:26.050 --> 00:05:28.300
But in case off Java,

00:05:28.300 --> 00:05:33.710
the compiler will convert the source good toe on intermediate court that the job watch your

00:05:33.710 --> 00:05:40.130
mission can understand and jbm for the uses some tools and utilities to come with the

00:05:40.130 --> 00:05:47.640
Intermediate Court Toe Mission Court that the NATO computer prosecute understand run so you

00:05:47.640 --> 00:05:48.960
write your source code.

00:05:48.960 --> 00:05:52.090
It will then be compiled using Java compiler.

00:05:52.090 --> 00:05:57.250
This will generate an intermediate court that neither computer nor you can understand,

00:05:57.250 --> 00:05:58.980
but only a job.

00:05:58.980 --> 00:06:00.450
What your mission can understand.

00:06:00.450 --> 00:06:05.460
You may wonder why we need tohave intermediate court.

00:06:05.460 --> 00:06:06.950
I will answer it later.

00:06:06.950 --> 00:06:09.030
So until now,

00:06:09.030 --> 00:06:11.660
interpreter did not come to picture.

00:06:11.660 --> 00:06:16.230
Now let's a compiler did not find any bugs in your court.

00:06:16.230 --> 00:06:18.670
A utility called Lord Er,

00:06:18.670 --> 00:06:20.790
below the Intermediate court,

00:06:20.790 --> 00:06:21.950
which is compiled.

00:06:21.950 --> 00:06:24.060
So the job watching machine.

00:06:24.060 --> 00:06:28.650
Now the file is ready for interpreter to take.

00:06:28.650 --> 00:06:34.190
The interpreter will then read the first line translated to mission code,

00:06:34.190 --> 00:06:36.050
and the new computer will run it.

00:06:36.050 --> 00:06:42.210
No treats the second line translated to mission code and the new computer well done it it

00:06:42.210 --> 00:06:42.990
keeps on running.

00:06:42.990 --> 00:06:43.430
Till then,

00:06:43.430 --> 00:06:45.400
off the file or full stack.

00:06:45.400 --> 00:06:46.280
Rinse off error.

00:06:46.280 --> 00:06:49.140
We'll understand more about interpreter.

00:06:49.140 --> 00:06:57.370
When we called the concepts off runtime errors or exceptions in some languages,

00:06:57.370 --> 00:07:00.800
the source code in high level language will be interpreted,

00:07:00.800 --> 00:07:03.930
not compiled in case off.

00:07:03.930 --> 00:07:07.040
Java Interpreter will not handle the source file,

00:07:07.040 --> 00:07:13.790
but it will handle the compile cord or intermediate court just in time compiler.

00:07:13.790 --> 00:07:14.600
Now,

00:07:14.600 --> 00:07:18.250
you will better understand what just in time come batteries.

00:07:18.250 --> 00:07:27.880
Let's have a small program here as you can see that we're having fire statements or fire

00:07:27.880 --> 00:07:28.720
lines off court,

00:07:28.720 --> 00:07:31.550
out of which three of them are redundant,

00:07:31.550 --> 00:07:35.120
the statement displays E has written three times.

00:07:35.120 --> 00:07:41.420
The compiler will compile the court and generate intermediate code that says,

00:07:41.420 --> 00:07:41.620
um,

00:07:41.620 --> 00:07:43.450
this is the intermediate good.

00:07:43.450 --> 00:07:44.750
Now,

00:07:44.750 --> 00:07:46.300
when we run the program,

00:07:46.300 --> 00:07:48.560
the interpreter translates line by a lane,

00:07:48.560 --> 00:07:51.980
and do computer runs them as and when it gets translator.

00:07:51.980 --> 00:07:58.520
But one interesting thing about this is that the computer will have to wait every time the

00:07:58.520 --> 00:08:00.680
interpreter translates each lane,

00:08:00.680 --> 00:08:03.240
whereas in case off compiler,

00:08:03.240 --> 00:08:04.090
there is no way.

00:08:04.090 --> 00:08:08.650
Time as a computer will get the fully translator file in one go.

00:08:08.650 --> 00:08:11.160
In this scenario,

00:08:11.160 --> 00:08:13.390
although we cannot nullify the wait time,

00:08:13.390 --> 00:08:15.850
at least we can read you some impact.

00:08:15.850 --> 00:08:18.870
Using a technique called just in time compilation,

00:08:18.870 --> 00:08:26.370
the Compile court or Intermediate Court will go to the Justin time compiler so that it will

00:08:26.370 --> 00:08:29.390
for their optimize it in this case,

00:08:29.390 --> 00:08:36.070
lying 456 or redundant and just in time compiler will mark this court as redolent.

00:08:36.070 --> 00:08:38.590
So when the file gets into better,

00:08:38.590 --> 00:08:43.830
the interpreter will now know that the court in London before is going to come again.

00:08:43.830 --> 00:08:49.410
So it stores the Mission court off landing before somebody in the computer memory and Ben

00:08:49.410 --> 00:08:49.550
Oh,

00:08:49.550 --> 00:08:52.160
it comes across with the same piece off court again.

00:08:52.160 --> 00:08:56.920
It will simply tell the computer to run mission code directly without translating,

00:08:56.920 --> 00:09:01.100
so there is no re translation off same court again.

00:09:01.100 --> 00:09:05.650
This phenomenon is called just in time compilation,

00:09:05.650 --> 00:09:12.830
and this will significantly improve the performance in reality.

00:09:12.830 --> 00:09:13.820
Just in time,

00:09:13.820 --> 00:09:19.880
compiler and interpreter will go hand in hand in Java and use even more optimizing

00:09:19.880 --> 00:09:21.950
techniques to increase the performance.

00:09:21.950 --> 00:09:28.980
So just remember both Justin them compiler and interpreter will come into picture only when

00:09:28.980 --> 00:09:29.990
you run the program.

00:09:29.990 --> 00:09:31.340
No,

00:09:31.340 --> 00:09:34.470
I hope I made myself clear And explaining what?

00:09:34.470 --> 00:09:35.430
Compile Aries.

00:09:35.430 --> 00:09:37.030
What interpret Tory's what,

00:09:37.030 --> 00:09:38.750
Just in time compile Aries.

00:09:38.750 --> 00:09:42.290
If you're still unclear about any off this,

00:09:42.290 --> 00:09:43.520
don't panic.

00:09:43.520 --> 00:09:45.350
It's very normal for beginners.

00:09:45.350 --> 00:09:48.150
Just try to view the video once again.

00:09:48.150 --> 00:09:51.020
If you still don't get it in second time,

00:09:51.020 --> 00:09:52.470
we need to worry again.

00:09:52.470 --> 00:09:56.700
Just move on to our next videos and rivers of this video letter.

