WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.070
Let's talk about type inference,

00:00:02.070 --> 00:00:05.880
which is a feature introduced in Java Washington.

00:00:05.880 --> 00:00:08.580
This feature is actually inspired from some of

00:00:08.580 --> 00:00:11.685
the other popular languages like for instance, JavaScript.

00:00:11.685 --> 00:00:13.320
If you're used to JavaScript,

00:00:13.320 --> 00:00:18.105
then you probably know that while declaring and initializing a variable,

00:00:18.105 --> 00:00:21.270
we don't have to explicitly mention the type of that variable.

00:00:21.270 --> 00:00:27.855
That however, doesn't hold true in case of Java, only until washington.

00:00:27.855 --> 00:00:32.670
With type inference, we don't have to explicitly mention the type of the variable.

00:00:32.670 --> 00:00:34.155
We can just say var.

00:00:34.155 --> 00:00:37.080
And no matter what value that you assign,

00:00:37.080 --> 00:00:39.285
you don't get any compiled a matters.

00:00:39.285 --> 00:00:44.795
For example, I can change this to ten No.1, no errors.

00:00:44.795 --> 00:00:47.494
I can make this a string.

00:00:47.494 --> 00:00:49.145
Still no errors.

00:00:49.145 --> 00:00:54.680
We can even assign our own types or collections like list ten, set.

00:00:54.680 --> 00:00:57.649
And you still don't get any errors.

00:00:57.649 --> 00:01:02.615
Basically, although we're not explicitly mentioning the type of the variable,

00:01:02.615 --> 00:01:05.720
compiler is actually doing that job by looking

00:01:05.720 --> 00:01:09.080
at the type of the value that we're assigning.

00:01:09.080 --> 00:01:11.390
It looks at the value and based on that,

00:01:11.390 --> 00:01:17.240
it can figure out the type and same would be assigned as the type.

00:01:17.240 --> 00:01:19.160
However, in case of Java,

00:01:19.160 --> 00:01:21.305
we have certain restrictions.

00:01:21.305 --> 00:01:25.490
For example, you can have this as part of the class member variable

00:01:25.490 --> 00:01:30.260
are as matter augment or even as a method written type,

00:01:30.260 --> 00:01:35.165
you can't have water as written type that's not allowed.

00:01:35.165 --> 00:01:43.145
And similarly can't have var x or something of that sort that's not allowed.

00:01:43.145 --> 00:01:48.350
The obvious reason is the user of this method does

00:01:48.350 --> 00:01:54.290
not know what type of value that he needs to send to this method.

00:01:54.290 --> 00:01:57.395
This is accepted, for instance,

00:01:57.395 --> 00:02:01.655
then the user of this method can actually send something

00:02:01.655 --> 00:02:06.245
whose type is not supported by the internal logic of this method.

00:02:06.245 --> 00:02:09.960
And so we're going to see an error.

00:02:11.230 --> 00:02:15.440
So you're only limited to use type inference as

00:02:15.440 --> 00:02:21.545
a local variable of a method or as part of index variable in a for loop.

00:02:21.545 --> 00:02:26.345
Or you can also use it as part of try-with-resources.

00:02:26.345 --> 00:02:29.430
It shouldn't have any problems there.
