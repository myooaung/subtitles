WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:04.020
in this video,

00:00:04.020 --> 00:00:09.550
we're going to talk about bit wise operators personally.

00:00:09.550 --> 00:00:10.890
Throughout my carrier,

00:00:10.890 --> 00:00:13.850
I have never used it was operators.

00:00:13.850 --> 00:00:20.890
And I would also recommend you not to give full focus on this topic has its not what?

00:00:20.890 --> 00:00:21.080
That.

00:00:21.080 --> 00:00:23.010
But if you're a student,

00:00:23.010 --> 00:00:26.850
maybe this will be helpful for your academics or for cracking interviews.

00:00:26.850 --> 00:00:33.480
So basically all the other operators we have seen so far deal with variable.

00:00:33.480 --> 00:00:39.100
But in here we deal with the binary representation off numerical,

00:00:39.100 --> 00:00:39.920
for example.

00:00:39.920 --> 00:00:48.770
Bit was operators does not perform operation on 65 but rather it performs operations on its

00:00:48.770 --> 00:00:50.250
venerated presentation.

00:00:50.250 --> 00:00:54.410
The bandit of the presentation off value 65 in 32 bit form.

00:00:54.410 --> 00:01:02.840
It is this and for minus 30 it's this the better explain each and every bit was operator.

00:01:02.840 --> 00:01:05.980
I might need to use annotations.

00:01:05.980 --> 00:01:07.350
Let's go there.

00:01:07.350 --> 00:01:09.560
All right.

00:01:09.560 --> 00:01:12.740
We have,

00:01:12.740 --> 00:01:13.180
you know,

00:01:13.180 --> 00:01:13.810
Ryba twice.

00:01:13.810 --> 00:01:14.670
Compliment.

00:01:14.670 --> 00:01:18.440
And the operator looks something like this.

00:01:18.440 --> 00:01:22.400
All this does is it will in ward the bit,

00:01:22.400 --> 00:01:23.330
for example,

00:01:23.330 --> 00:01:28.660
zero will become one and once will become zero when we're trying to find,

00:01:28.660 --> 00:01:28.910
you know,

00:01:28.910 --> 00:01:31.450
re it was complement off a.

00:01:31.450 --> 00:01:34.040
This is what the result would be.

00:01:34.040 --> 00:01:39.110
And when we convert this to a decimal value would get minus 66.

00:01:39.110 --> 00:01:49.610
Zeros have become one and once have become zeros that that simple as that we have been

00:01:49.610 --> 00:01:54.980
twice and operator for this we need to follow a table.

00:01:54.980 --> 00:01:56.680
Here it is.

00:01:56.680 --> 00:02:02.660
We have only four possible combination off zero in one,

00:02:02.660 --> 00:02:04.890
when it comes to BET was end,

00:02:04.890 --> 00:02:14.570
00 will become 001 will become 010 will become zero and 11 will become one.

00:02:14.570 --> 00:02:17.640
So the only case would see the result,

00:02:17.640 --> 00:02:20.060
as one is when both or one.

00:02:20.060 --> 00:02:30.020
So what we're trying to do here is we're trying to find between us and off A and B So one

00:02:30.020 --> 00:02:37.640
Joe will become 001 will become zero 00 will become zero again.

00:02:37.640 --> 00:02:40.350
00 zero.

00:02:40.350 --> 00:02:43.950
And we have one and one here,

00:02:43.950 --> 00:02:46.270
and that will make one.

00:02:46.270 --> 00:02:48.220
Similarly,

00:02:48.220 --> 00:02:50.780
if you fill out all the bits in here,

00:02:50.780 --> 00:02:53.250
this is the output that we get.

00:02:53.250 --> 00:02:58.580
And when we convert that to a decimal value would get 64.

00:02:58.580 --> 00:03:03.150
We have It was our operator,

00:03:03.150 --> 00:03:06.650
and the operator looks something like this.

00:03:06.650 --> 00:03:13.170
We're trying to find the bit wise are off A and B when it comes to bit.

00:03:13.170 --> 00:03:18.150
Was are there are three cases where we would get the value one,

00:03:18.150 --> 00:03:23.610
if at least one off this to his one Then the result will be one.

00:03:23.610 --> 00:03:35.680
So 00 will become 001110 would become one 11 will become one And if you calculate the bit

00:03:35.680 --> 00:03:39.740
was are off these two Byner reader presentations.

00:03:39.740 --> 00:03:47.030
This is what we get and then we couldn't work that to a dismal value would get minus 20

00:03:47.030 --> 00:03:59.160
night Cool and then we have bit wise Exclusive are in here There are only two cases Where

00:03:59.160 --> 00:04:09.270
would get the value one 00 ever become 001 will become 110 will become one and 11 will

00:04:09.270 --> 00:04:22.070
become zero And if you perform exclusive are on this too He would get this result and that

00:04:22.070 --> 00:04:29.750
one converted to decimal would get minus 93 and we have signed the left shift operator.

00:04:29.750 --> 00:04:34.390
So what this essentially does is it's going to push.

00:04:34.390 --> 00:04:37.770
Since we're doing a left shift by four,

00:04:37.770 --> 00:04:44.350
it's going to push these digits towards left side four times.

00:04:44.350 --> 00:04:45.510
So what?

00:04:45.510 --> 00:04:47.160
That would result in years.

00:04:47.160 --> 00:04:50.760
All these four bits will fall,

00:04:50.760 --> 00:04:53.180
and we get four empty places here,

00:04:53.180 --> 00:04:57.110
and those will be filled with zeros.

00:04:57.110 --> 00:04:59.800
That's exactly what we have here.

00:04:59.800 --> 00:05:07.790
And when you convert that to dismal would get minus 4 80 We have signed right shift

00:05:07.790 --> 00:05:08.570
operator.

00:05:08.570 --> 00:05:12.200
There's a similar to sign left shift operator,

00:05:12.200 --> 00:05:17.350
except it's going to push the digits towards right in here.

00:05:17.350 --> 00:05:21.360
We're trying to push two places on the variable B.

00:05:21.360 --> 00:05:25.740
So what this is doing is it's going to push.

00:05:25.740 --> 00:05:29.070
There's bits towards right a couple of times,

00:05:29.070 --> 00:05:35.650
so these two would spill over and will disappear,

00:05:35.650 --> 00:05:38.650
and we get to empty locations here,

00:05:38.650 --> 00:05:46.870
and those empty locations will be filled with whatever is there in the most significant bit

00:05:46.870 --> 00:05:46.870
.

00:05:46.870 --> 00:05:49.470
So in this gas,

00:05:49.470 --> 00:05:50.070
it's one,

00:05:50.070 --> 00:05:54.900
and that's exactly what we have here.

00:05:54.900 --> 00:05:58.250
And we have unsigned right shift.

00:05:58.250 --> 00:06:03.310
This will do exactly what signed right shift would do.

00:06:03.310 --> 00:06:08.800
Except instead of filling the empty bits with the most significant bit,

00:06:08.800 --> 00:06:11.610
it will simply filled with zeros,

00:06:11.610 --> 00:06:15.100
so that would result in this man.

00:06:15.100 --> 00:06:17.620
If you run this program,

00:06:17.620 --> 00:06:23.470
these are about percent you're going to see go ahead and run it

