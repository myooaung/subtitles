WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:03.150
in this lesson will talk about casting in Java.

00:00:03.150 --> 00:00:08.950
Typecasting is nothing but converting a value of one day type to another date of time.

00:00:08.950 --> 00:00:10.890
Now take a look at this table.

00:00:10.890 --> 00:00:17.480
It's easier for us to convert a value off bite to a value of short,

00:00:17.480 --> 00:00:24.810
because the range off bite is lesser than toe that off the range off short and the similar

00:00:24.810 --> 00:00:31.480
fashion we can convert and too long we can also convert care to in.

00:00:31.480 --> 00:00:32.790
Remember,

00:00:32.790 --> 00:00:33.550
I said,

00:00:33.550 --> 00:00:36.200
character can also be presented in new miracles,

00:00:36.200 --> 00:00:42.970
and the range off care showed Lee is lesser than to that of the range off Enter when it

00:00:42.970 --> 00:00:48.950
comes to converting a value off lower range genotype to a higher rank data type job.

00:00:48.950 --> 00:00:50.400
What does that automatically?

00:00:50.400 --> 00:00:52.940
Because there is no loss off information.

00:00:52.940 --> 00:00:54.330
For example,

00:00:54.330 --> 00:00:58.950
it's easier to put a one liter container in a 10 litre container,

00:00:58.950 --> 00:01:00.480
but not the other way.

00:01:00.480 --> 00:01:04.310
If you try to put a 10 litre container in Munley to container,

00:01:04.310 --> 00:01:06.540
there may be loss off something.

00:01:06.540 --> 00:01:09.630
Same is the case with Java.

00:01:09.630 --> 00:01:14.200
If you're trying to put end value and let's say bite,

00:01:14.200 --> 00:01:21.660
Java won't do it right because there is a risk off losing data there can be lost off

00:01:21.660 --> 00:01:23.800
magnitude in the resulting value,

00:01:23.800 --> 00:01:26.220
so Java won't do it by itself.

00:01:26.220 --> 00:01:29.750
But we'll ask the programmer to do so at his own risk.

00:01:29.750 --> 00:01:37.000
Let's go toe a white board and take a look at some teary behind so Java does automatically

00:01:37.000 --> 00:01:40.090
convert bite to a shark,

00:01:40.090 --> 00:01:44.760
shocked to end in so long,

00:01:44.760 --> 00:01:51.550
long to float and float to double.

00:01:51.550 --> 00:01:52.310
Here,

00:01:52.310 --> 00:01:56.300
you need to note that long takes eight bites off memory.

00:01:56.300 --> 00:01:57.220
There has flow,

00:01:57.220 --> 00:01:58.950
takes only four bites off memory.

00:01:58.950 --> 00:02:03.500
All the float values can be represented in exponential notation.

00:02:03.500 --> 00:02:07.750
It can easily accommodate the maximum value that long supports.

00:02:07.750 --> 00:02:13.950
We also have care which can be converted or type casted to end.

00:02:13.950 --> 00:02:16.950
So if you go from left to right,

00:02:16.950 --> 00:02:23.550
we're converting the value off lower range data type touadera type of higher range.

00:02:23.550 --> 00:02:26.150
This is called widening.

00:02:26.150 --> 00:02:28.380
For example,

00:02:28.380 --> 00:02:30.150
you could convert by two shot.

00:02:30.150 --> 00:02:32.410
It could convert by too long.

00:02:32.410 --> 00:02:34.650
It can convert cat to float,

00:02:34.650 --> 00:02:42.490
and the name widening makes sense because what it takes eight bits off memory with us in

00:02:42.490 --> 00:02:44.190
text editor bits off memory.

00:02:44.190 --> 00:02:45.970
And like I've already mentioned,

00:02:45.970 --> 00:02:50.070
you can easily insert I one liter container in a 10 litre container,

00:02:50.070 --> 00:02:52.240
and in the similar fashion,

00:02:52.240 --> 00:02:57.230
the eight bit memory is actually widened toe a little bit memory.

00:02:57.230 --> 00:03:00.500
So essentially we have widened the space.

00:03:00.500 --> 00:03:05.450
But whereas when you try to convert and tow bite,

00:03:05.450 --> 00:03:08.550
you're trying to convert a value,

00:03:08.550 --> 00:03:13.250
which is an intelligible container to a bit.

00:03:13.250 --> 00:03:20.350
This mechanism is called narrowing and the arrow goes from right to left.

00:03:20.350 --> 00:03:23.270
So if you try to convert double toe end,

00:03:23.270 --> 00:03:25.200
it's narrowing long.

00:03:25.200 --> 00:03:25.780
Two short.

00:03:25.780 --> 00:03:26.630
It's narrowing.

00:03:26.630 --> 00:03:32.080
Accetta in case off narrowing Tower does not do it on its own.

00:03:32.080 --> 00:03:39.750
It's up to the Ripper because there can be lost off data when Java Christ to convert a 32

00:03:39.750 --> 00:03:42.130
bit while you toe a bit.

00:03:42.130 --> 00:03:42.410
Well,

00:03:42.410 --> 00:03:46.670
you obviously cannot accommodate the entire new America.

00:03:46.670 --> 00:03:51.540
Now let's take a look at this index off typecasting.

00:03:51.540 --> 00:03:55.550
A quick cushion.

00:03:55.550 --> 00:03:57.400
What are we doing here?

00:03:57.400 --> 00:04:01.210
Are we doing whitening are having what doing widening.

00:04:01.210 --> 00:04:05.560
We're trying to convert the value off type bite to indigent.

00:04:05.560 --> 00:04:08.370
This is called widening,

00:04:08.370 --> 00:04:12.950
and doing so does not yield any loss off information.

00:04:12.950 --> 00:04:15.230
Hence Java does it on its own,

00:04:15.230 --> 00:04:21.050
so it does implicit casting it will convert despite two data type int,

00:04:21.050 --> 00:04:24.860
as there is no loss off magnitude or there is no loss of data.

00:04:24.860 --> 00:04:27.640
But when we try to do the other way,

00:04:27.640 --> 00:04:28.480
for example,

00:04:28.480 --> 00:04:36.110
and I equals 1000 by B.

00:04:36.110 --> 00:04:36.860
Quartz,

00:04:36.860 --> 00:04:47.590
High compiler will complete the program because John cannot convert and into value to bite

00:04:47.590 --> 00:04:50.090
without the loss off data.

00:04:50.090 --> 00:04:53.080
So there are very wittle compiler there.

00:04:53.080 --> 00:04:54.650
It's at my own risk.

00:04:54.650 --> 00:04:57.750
I don't care if there is loss off dead,

00:04:57.750 --> 00:04:59.390
our loss off information.

00:04:59.390 --> 00:05:02.270
I still want this to be done.

00:05:02.270 --> 00:05:04.600
I still want this to be a while,

00:05:04.600 --> 00:05:05.450
it statement.

00:05:05.450 --> 00:05:07.570
So tell compiler,

00:05:07.570 --> 00:05:11.700
you just have to se bite here.

00:05:11.700 --> 00:05:21.430
Your destination data type within the brackets now compatible successfully compiled this

00:05:21.430 --> 00:05:24.080
program and even run this program.

00:05:24.080 --> 00:05:28.550
But the result would be something unexpected.

00:05:28.550 --> 00:05:32.890
Let's go door workbench and take a look at a quick example.

00:05:32.890 --> 00:05:44.790
So here we have value as 2000 which is oft I paint and we're trying to convert into by,

00:05:44.790 --> 00:05:48.140
and we explicitly typecast it to bite.

00:05:48.140 --> 00:05:51.080
Now let's try to run the program,

00:05:51.080 --> 00:06:15.150
and then let's run it so the value is pretty unexpected and is completely useless.

00:06:15.150 --> 00:06:18.150
So let's see what has happened behind the scenes,

00:06:18.150 --> 00:06:22.900
The binary presentation off the numerical 2000.

00:06:22.900 --> 00:06:30.550
These this and tens way said into equals 2000.

00:06:30.550 --> 00:06:35.180
The center thing is told in 32 bits off memory,

00:06:35.180 --> 00:06:37.650
and then we say,

00:06:37.650 --> 00:06:40.260
bite B equals eight.

00:06:40.260 --> 00:06:48.020
It's gonna create eight bits off memory and some hold Javanese to manage.

00:06:48.020 --> 00:06:51.180
To put this number 2000 neighbor.

00:06:51.180 --> 00:06:54.360
It's it will try its best.

00:06:54.360 --> 00:06:57.250
So Shower does some sort off calculation.

00:06:57.250 --> 00:06:58.690
It was tried,

00:06:58.690 --> 00:07:04.090
have ignore all the 24 bits and would consider only eight bits,

00:07:04.090 --> 00:07:14.160
which is and then a checks of the more significant bit is one or zero.

00:07:14.160 --> 00:07:15.250
If it is zero,

00:07:15.250 --> 00:07:20.950
it will start of a print the decimal number off this finally the presentation.

00:07:20.950 --> 00:07:23.550
And since it is one,

00:07:23.550 --> 00:07:31.750
it will go ahead and try to do and try to do the ones compliment off this binary number.

00:07:31.750 --> 00:07:33.560
So once complimented,

00:07:33.560 --> 00:07:35.650
is nothing but the negation off this number.

00:07:35.650 --> 00:07:42.380
So it's just replacing one with zeros and zeros with once and now,

00:07:42.380 --> 00:07:49.050
the decimal value that you get is 47.

00:07:49.050 --> 00:07:52.180
It will add,

00:07:52.180 --> 00:07:53.390
plus one to it,

00:07:53.390 --> 00:08:01.250
and we get the value 48 in Java all the integer types are signed.

00:08:01.250 --> 00:08:04.670
So since we have one here,

00:08:04.670 --> 00:08:07.450
which means Negative Sign minus,

00:08:07.450 --> 00:08:11.430
it will trade this number as a negative number.

00:08:11.430 --> 00:08:20.610
And hence we got about put us 48 Drop my career off decayed and 1/2 years off experience in

00:08:20.610 --> 00:08:23.100
using java I have never,

00:08:23.100 --> 00:08:26.110
ever used narrowing for primitive types.

00:08:26.110 --> 00:08:31.960
I don't even think off a scenario where you would need a narrowing for primitive there

00:08:31.960 --> 00:08:34.350
types you'll have to check.

00:08:34.350 --> 00:08:39.800
But the designers of the Java But I did use widening a lot off types.

00:08:39.800 --> 00:08:40.870
Well,

00:08:40.870 --> 00:08:41.250
now,

00:08:41.250 --> 00:08:42.670
going back a little bit,

00:08:42.670 --> 00:08:49.220
you might be wondering why car cannot become motor into short even though they take same

00:08:49.220 --> 00:08:50.490
bites off memory.

00:08:50.490 --> 00:08:55.970
That's because Care is unsigned but where a shot is signed.

00:08:55.970 --> 00:09:02.060
So out of two bites one bit will be allocated to decide the sign here,

00:09:02.060 --> 00:09:05.300
whether it's minus or plus.

00:09:05.300 --> 00:09:08.320
But whereas for care it starts with zero,

00:09:08.320 --> 00:09:11.990
you know to 65,005 or six,

00:09:11.990 --> 00:09:13.620
all of positive integers.

00:09:13.620 --> 00:09:14.170
Okay,

00:09:14.170 --> 00:09:17.590
now let's take a look at widening and narrowing examples.

00:09:17.590 --> 00:09:26.500
We have a pretty simple program here,

00:09:26.500 --> 00:09:28.950
converting bite to end.

00:09:28.950 --> 00:09:31.190
So by be equal,

00:09:31.190 --> 00:09:37.050
Stan and I equals B Java implicitly convert this be toe type off.

00:09:37.050 --> 00:09:43.640
And because we're doing whitening here and there is no loss off information and Java gladly

00:09:43.640 --> 00:09:45.350
does the conversion by itself.

00:09:45.350 --> 00:09:51.170
Same is the case with long to float have a long value here.

00:09:51.170 --> 00:09:53.550
We're trying to convert into float,

00:09:53.550 --> 00:09:56.700
and this is the maximum long value that long can hold.

00:09:56.700 --> 00:10:01.650
We're also converting care to double.

00:10:01.650 --> 00:10:06.450
So the unicord number off letter kept away 60 fire.

00:10:06.450 --> 00:10:15.060
So what we're going to store in Double D is $65 0 let's try to run this program.

00:10:15.060 --> 00:10:30.380
Who?

00:10:30.380 --> 00:10:32.060
We got the expected output.

00:10:32.060 --> 00:10:35.820
Now let's take a look at example,

00:10:35.820 --> 00:10:36.570
off narrowing.

00:10:36.570 --> 00:10:50.040
So we're trying to convert integer type rounded to bite anti equals 2000 B equals I,

00:10:50.040 --> 00:10:52.350
and we're printing the value off B.

00:10:52.350 --> 00:10:56.730
So would this yield accomplish in error or not?

00:10:56.730 --> 00:11:02.080
It does because there is loss off information.

00:11:02.080 --> 00:11:06.240
We need to explicitly say that I want to convert this to buy.

00:11:06.240 --> 00:11:09.770
Now this will.

00:11:09.770 --> 00:11:15.050
We've actually already taken a look at this example.

00:11:15.050 --> 00:11:18.700
So I'm not going to rest your time running it again,

00:11:18.700 --> 00:11:21.620
not to confuse you,

00:11:21.620 --> 00:11:27.650
But Java does do narrowing implicitly in kiss.

00:11:27.650 --> 00:11:29.820
There is no loss of data.

00:11:29.820 --> 00:11:30.950
For example,

00:11:30.950 --> 00:11:32.750
take a look at the statements,

00:11:32.750 --> 00:11:38.960
so bite B one equals 10 by default.

00:11:38.960 --> 00:11:42.270
Job treats and into the value as type has off type.

00:11:42.270 --> 00:11:45.260
And so John converted.

00:11:45.260 --> 00:11:49.010
This ain't data type to bite people gladly,

00:11:49.010 --> 00:11:52.310
because the value 10 comes in the range off bite,

00:11:52.310 --> 00:11:55.650
and it's not resulting in any loss off information.

00:11:55.650 --> 00:11:58.310
Let's save the program.

00:11:58.310 --> 00:12:14.400
Let's get rid off this court in here that said the program and try to run it not to confuse

00:12:14.400 --> 00:12:15.260
you for there.

00:12:15.260 --> 00:12:20.560
But let's take a look at a few more statements now.

00:12:20.560 --> 00:12:23.660
What we're doing here is essentially the same thing.

00:12:23.660 --> 00:12:30.520
The only difference is we have explicitly initialized the very belay with value.

00:12:30.520 --> 00:12:30.860
10.

00:12:30.860 --> 00:12:33.030
Now,

00:12:33.030 --> 00:12:34.600
if you run this program,

00:12:34.600 --> 00:12:36.290
do you see errors?

00:12:36.290 --> 00:12:38.690
Yes or no?

00:12:38.690 --> 00:12:41.960
The Ansari's yes,

00:12:41.960 --> 00:12:42.450
we do,

00:12:42.450 --> 00:12:47.220
because we explicitly stated that the value is end.

00:12:47.220 --> 00:12:57.810
So it's our responsibility as a programmer to explicitly cast this A to type right First,

00:12:57.810 --> 00:13:08.980
let's trade run without typecasting it and see what happens combined the program.

00:13:08.980 --> 00:13:11.410
Oops,

00:13:11.410 --> 00:13:16.770
we have already seen theater so incompatible ties,

00:13:16.770 --> 00:13:18.550
possible lossy conversation.

00:13:18.550 --> 00:13:22.290
If you cannot end to bite there can be lost off data.

00:13:22.290 --> 00:13:23.460
That's what it's complaining.

00:13:23.460 --> 00:13:28.110
So I would say that my one gresko wanna take care of this.

00:13:28.110 --> 00:13:28.600
I'd say,

00:13:28.600 --> 00:13:31.450
despite save the fine,

00:13:31.450 --> 00:13:44.870
compile the program on the program.

00:13:44.870 --> 00:13:46.580
Good.

00:13:46.580 --> 00:13:48.450
The result is expected.

