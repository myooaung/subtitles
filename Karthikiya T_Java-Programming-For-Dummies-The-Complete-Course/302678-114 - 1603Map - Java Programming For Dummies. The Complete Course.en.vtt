WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.020
in this video,

00:00:01.020 --> 00:00:02.950
we're gonna talk about map.

00:00:02.950 --> 00:00:07.720
You can think off map as a list which will have elements.

00:00:07.720 --> 00:00:12.980
Except each one of those elements would be identified with a unique key.

00:00:12.980 --> 00:00:14.550
Let me the monster.

00:00:14.550 --> 00:00:15.300
Do what I mean.

00:00:15.300 --> 00:00:23.800
So first of all we need to create the map and the map class will allow us to send a couple

00:00:23.800 --> 00:00:29.250
off type perimeters out a string and in teacher,

00:00:29.250 --> 00:00:30.920
basically,

00:00:30.920 --> 00:00:32.500
the string would be our key.

00:00:32.500 --> 00:00:38.400
An indigent would be the type of the element that we're going to insert into this map map

00:00:38.400 --> 00:00:39.030
close,

00:00:39.030 --> 00:00:39.650
new.

00:00:39.650 --> 00:00:44.140
And we're going to use the implementation off the map interface,

00:00:44.140 --> 00:00:45.850
which is hash map.

00:00:45.850 --> 00:00:49.180
That's it.

00:00:49.180 --> 00:00:50.350
Let's do control shift.

00:00:50.350 --> 00:00:50.760
Oh,

00:00:50.760 --> 00:00:53.550
to import required files.

00:00:53.550 --> 00:00:58.750
Now we're good to go ahead to add elements along with their associated keys.

00:00:58.750 --> 00:01:05.750
So the way we do it is we do map dot Put who use the matter put to put the key.

00:01:05.750 --> 00:01:06.850
In this case,

00:01:06.850 --> 00:01:12.970
it's It has to be a string sells 800 the value is going to be off type,

00:01:12.970 --> 00:01:13.970
Integer said.

00:01:13.970 --> 00:01:14.340
10.

00:01:14.340 --> 00:01:15.710
Likewise,

00:01:15.710 --> 00:01:18.960
you can keep inserting as many elements as you want,

00:01:18.960 --> 00:01:23.750
but make sure that the key is unique in each and every entry.

00:01:23.750 --> 00:01:24.660
By the way,

00:01:24.660 --> 00:01:27.450
together these two are called an entry.

00:01:27.450 --> 00:01:34.150
So let's make this 101 102 etcetera.

00:01:34.150 --> 00:01:39.950
Let's say this is 11 and this is 16 or whatever,

00:01:39.950 --> 00:01:45.870
so let's just simply try toe print this map says out map.

00:01:45.870 --> 00:01:51.750
So this statement will actually call the to string method off the hash map.

00:01:51.750 --> 00:01:57.940
Let's run the program so key value,

00:01:57.940 --> 00:01:59.600
key value and key value.

00:01:59.600 --> 00:02:06.610
Let's see what will happen if we have the same key for a couple of entries in this case.

00:02:06.610 --> 00:02:11.850
This statement will remove this element from the map,

00:02:11.850 --> 00:02:14.150
and it took place itself.

00:02:14.150 --> 00:02:15.650
That's on the program,

00:02:15.650 --> 00:02:19.350
and we should see only two entries in the map.

00:02:19.350 --> 00:02:21.020
There it is,

00:02:21.020 --> 00:02:32.460
and this is the latest one and obviously can always have the same while you that shouldn't

00:02:32.460 --> 00:02:35.390
be a problem on the key supposed to be unique.

00:02:35.390 --> 00:02:38.650
So basically,

00:02:38.650 --> 00:02:46.650
you can think off these keys as an identify where for the values you either abate dill it

00:02:46.650 --> 00:02:50.240
these values based on its corresponding key.

00:02:50.240 --> 00:02:53.760
Now let's see how we can retrieve unspecific lament from this map,

00:02:53.760 --> 00:03:01.350
but that we're just going to make use off a method called map dart get and we're gonna pass

00:03:01.350 --> 00:03:02.450
him the key.

00:03:02.450 --> 00:03:04.020
In this case,

00:03:04.020 --> 00:03:05.080
it has to be a string.

00:03:05.080 --> 00:03:11.790
If I said 101 it's going to show me the result off 11 because that's what its corresponding

00:03:11.790 --> 00:03:12.580
value is.

00:03:12.580 --> 00:03:13.670
In fact,

00:03:13.670 --> 00:03:20.680
it makes sense to call this a map because it is kind off mapping both keys and values.

00:03:20.680 --> 00:03:22.760
Hope that makes sense now.

00:03:22.760 --> 00:03:23.290
Obviously,

00:03:23.290 --> 00:03:25.270
we don't want to just print the map.

00:03:25.270 --> 00:03:26.770
We want to do something meaningful.

00:03:26.770 --> 00:03:28.870
We're gonna use the looping constructs.

00:03:28.870 --> 00:03:30.750
And just as I had explained,

00:03:30.750 --> 00:03:33.550
we're gonna make yourself for each loop.

00:03:33.550 --> 00:03:37.350
They're a couple of ways you can make use off the forage loop.

00:03:37.350 --> 00:03:44.890
One is you're gonna loop through all the keys and in order to get all the list off keys

00:03:44.890 --> 00:03:45.910
available in the map,

00:03:45.910 --> 00:03:49.690
you just have to say mab dark key set.

00:03:49.690 --> 00:03:52.270
This will bring us set off kiss.

00:03:52.270 --> 00:03:56.500
Now what we want to do is for each never individual key.

00:03:56.500 --> 00:04:03.550
We want to do something and we know that each one off this keys are off type string and

00:04:03.550 --> 00:04:05.300
using the colon,

00:04:05.300 --> 00:04:10.520
we can get each one of the keys from this case,

00:04:10.520 --> 00:04:12.150
That one at a time,

00:04:12.150 --> 00:04:13.790
and do something with it.

00:04:13.790 --> 00:04:15.550
So in here,

00:04:15.550 --> 00:04:25.700
all I'm going to do is six out and then map dot Get hope s not.

00:04:25.700 --> 00:04:27.250
This s can be anything.

00:04:27.250 --> 00:04:31.350
You can call it key or something.

00:04:31.350 --> 00:04:41.640
Let's let's on the program And you would see all the values pretty well in Good.

00:04:41.640 --> 00:04:42.380
Now,

00:04:42.380 --> 00:04:43.010
I said,

00:04:43.010 --> 00:04:49.140
both can value pair together called an entry we can look through All these entries is in

00:04:49.140 --> 00:04:49.850
the for each loop.

00:04:49.850 --> 00:04:57.650
Let me demonstrate to you what I mean So far we had to get the entry set.

00:04:57.650 --> 00:05:02.890
And what is the type off each and every entry in the sentry set?

00:05:02.890 --> 00:05:13.150
It's going to be map dart entry can get to adopt this type variables and let's call it

00:05:13.150 --> 00:05:14.580
entry.

00:05:14.580 --> 00:05:18.780
So basically,

00:05:18.780 --> 00:05:19.820
what did we just do?

00:05:19.820 --> 00:05:23.200
If you take a look at the methods defined inside the map,

00:05:23.200 --> 00:05:25.350
you would see a sub into office.

00:05:25.350 --> 00:05:26.910
So what that means is,

00:05:26.910 --> 00:05:29.710
whichever class implements that interface,

00:05:29.710 --> 00:05:33.280
it has to provide a subclass as well.

00:05:33.280 --> 00:05:35.300
If you're interested,

00:05:35.300 --> 00:05:40.680
you can go to grab code dot com and explore the source code off map and hash map and you

00:05:40.680 --> 00:05:43.650
would see us up class in the hash map as something professing the map.

00:05:43.650 --> 00:05:51.100
So what is that subclass or sub interface meant for it is for this type entry.

00:05:51.100 --> 00:05:58.560
An entry will have matters like get key and get value basically and that Will you be able

00:05:58.560 --> 00:05:58.990
to,

00:05:58.990 --> 00:05:59.710
you know,

00:05:59.710 --> 00:06:01.390
look through all these entries,

00:06:01.390 --> 00:06:03.300
get the key,

00:06:03.300 --> 00:06:04.830
and it's corresponding value.

00:06:04.830 --> 00:06:11.050
So the type of which entry is this a place type of the map?

00:06:11.050 --> 00:06:24.400
Let's do sis out now you can say key plus and you don't get key.

00:06:24.400 --> 00:06:28.840
So these are the matters that are reciting inside that subclass.

00:06:28.840 --> 00:06:30.200
We got the key.

00:06:30.200 --> 00:06:43.020
Now let's try to print the value associated with it while you hes entered out.

00:06:43.020 --> 00:06:44.190
Get value.

00:06:44.190 --> 00:06:45.900
That's on the program.

00:06:45.900 --> 00:06:52.220
That's commend this code out key value,

00:06:52.220 --> 00:06:54.850
key value and care about pretty well and good.

00:06:54.850 --> 00:06:55.810
Also,

00:06:55.810 --> 00:06:58.560
you can have no as a key,

00:06:58.560 --> 00:07:00.120
but just as any other key,

00:07:00.120 --> 00:07:01.910
you can't have a duplicate off it,

00:07:01.910 --> 00:07:04.850
so you can add one null key.

00:07:04.850 --> 00:07:09.850
Have some value.

00:07:09.850 --> 00:07:15.440
Let's run the program key now,

00:07:15.440 --> 00:07:16.980
but do take a note.

00:07:16.980 --> 00:07:22.110
Nelly is inserted at the top off rich and every element anyway.

00:07:22.110 --> 00:07:27.870
It's never a good idea to have no as a key unless there is a good business reason.

00:07:27.870 --> 00:07:32.940
But I don't know any off such reason why you should use now as a key.

00:07:32.940 --> 00:07:40.850
No one last thing which I wanted to point out here is all this tryto have string as a key

00:07:40.850 --> 00:07:44.540
because off one good reason string is immutable.

00:07:44.540 --> 00:07:48.370
Once you define 100 as a key in here,

00:07:48.370 --> 00:07:53.080
nobody can ever change this value because string is immutable.

00:07:53.080 --> 00:07:54.530
For example,

00:07:54.530 --> 00:07:57.730
if you're trying to use your own class as key Ah,

00:07:57.730 --> 00:07:59.750
let me just demonstrate that.

00:07:59.750 --> 00:08:03.090
So I'm going to make use off the class.

00:08:03.090 --> 00:08:06.400
But you had already created my own.

00:08:06.400 --> 00:08:10.450
I'm going to say the key type to be off my own.

00:08:10.450 --> 00:08:22.850
And now we can no longer have string as a key my own off 10 whatever and then my own 20

00:08:22.850 --> 00:08:28.550
again my own off 10 my own often?

00:08:28.550 --> 00:08:29.480
No.

00:08:29.480 --> 00:08:30.650
If you take a note,

00:08:30.650 --> 00:08:38.270
the keys for all these three entries in here are saying essentially we should have only two

00:08:38.270 --> 00:08:38.810
entries.

00:08:38.810 --> 00:08:40.350
But let's see what's going to happen.

00:08:40.350 --> 00:08:43.300
Even though the keys are same,

00:08:43.300 --> 00:08:45.950
job assumed to be off different.

00:08:45.950 --> 00:08:54.000
The reason is the logic behind the put method is going to assume that there is.

00:08:54.000 --> 00:08:55.830
Do people get key bears down?

00:08:55.830 --> 00:08:58.570
Couple of criterias number one.

00:08:58.570 --> 00:09:05.180
It's going to check to see if object one equals object to,

00:09:05.180 --> 00:09:08.530
and it's going to check to see if object one,

00:09:08.530 --> 00:09:12.750
not hash code equals.

00:09:12.750 --> 00:09:16.370
I object to dot hash code.

00:09:16.370 --> 00:09:18.830
Only these two conditions are met.

00:09:18.830 --> 00:09:23.110
Will the map assume that it is dealing with duplicate keys?

00:09:23.110 --> 00:09:23.990
For example?

00:09:23.990 --> 00:09:29.090
Let me just quickly move these into individual variables.

00:09:29.090 --> 00:09:35.240
My own 01 equals me off.

00:09:35.240 --> 00:09:35.750
10.

00:09:35.750 --> 00:09:47.450
Let's copy this or two or three Endo four.

00:09:47.450 --> 00:09:52.270
Made this 20 30 40.

00:09:52.270 --> 00:09:54.300
I'm going to pass in here.

00:09:54.300 --> 00:09:54.920
All one.

00:09:54.920 --> 00:09:59.040
Oh,

00:09:59.040 --> 00:10:10.460
too Hold three and old Poor Now the hash cut off which one of these objects are not

00:10:10.460 --> 00:10:11.330
identical.

00:10:11.330 --> 00:10:12.340
Also,

00:10:12.340 --> 00:10:15.250
the equals method doesn't return true.

00:10:15.250 --> 00:10:21.560
Let me just prove that since out and I'm going to say for simplicity's sake,

00:10:21.560 --> 00:10:23.370
let's get rid of this.

00:10:23.370 --> 00:10:27.670
I'm going to say no one,

00:10:27.670 --> 00:10:35.350
and to similarly in here we're going to have a six out statement.

00:10:35.350 --> 00:10:43.450
I'm going to say her hash code equals ho to dot hash court.

00:10:43.450 --> 00:10:47.040
Let's come in this out for the time being,

00:10:47.040 --> 00:10:51.770
we're on the program both our faults.

00:10:51.770 --> 00:10:57.650
So somehow we need to tell on what basis are my own objects similar?

00:10:57.650 --> 00:10:59.120
And for that,

00:10:59.120 --> 00:11:01.590
I'm going to All right,

00:11:01.590 --> 00:11:02.660
couple of methods.

00:11:02.660 --> 00:11:08.050
When is equals method together is the hash court,

00:11:08.050 --> 00:11:13.540
and I can certainly make yourself the idea functionality.

00:11:13.540 --> 00:11:15.600
Click on override imploring methods,

00:11:15.600 --> 00:11:19.270
and you can simply choose the matters that you want to.

00:11:19.270 --> 00:11:20.010
All right,

00:11:20.010 --> 00:11:23.100
So in this case equals and hash coat,

00:11:23.100 --> 00:11:34.160
I'm going to say I'm going to set the hash court to be same as the value so that they're

00:11:34.160 --> 00:11:35.960
gonna have two objects.

00:11:35.960 --> 00:11:37.360
Creator with the same value.

00:11:37.360 --> 00:11:41.570
They both would have the same hash code and similarly for equals.

00:11:41.570 --> 00:11:44.130
I'll get it off the deport logic.

00:11:44.130 --> 00:11:44.720
Rather,

00:11:44.720 --> 00:11:54.440
what I would do is I'll make sure this dot exe equals object.

00:11:54.440 --> 00:12:03.150
I'm going to type Castor to my Hoen class Dark X.

00:12:03.150 --> 00:12:07.450
If this to are similar,

00:12:07.450 --> 00:12:13.610
this has to be this argument a quick fix there.

00:12:13.610 --> 00:12:16.950
So this to are similar than we would say.

00:12:16.950 --> 00:12:19.710
The cause method is true.

00:12:19.710 --> 00:12:20.200
No,

00:12:20.200 --> 00:12:22.450
let's try to run the program.

00:12:22.450 --> 00:12:24.220
Of course,

00:12:24.220 --> 00:12:27.080
we need to have same values.

00:12:27.080 --> 00:12:30.960
Let's run the program true and true,

00:12:30.960 --> 00:12:31.980
credible and good.

00:12:31.980 --> 00:12:35.520
And we thought,

00:12:35.520 --> 00:12:36.450
These methods,

00:12:36.450 --> 00:12:41.450
this will be false and Paul's Let's undo.

00:12:41.450 --> 00:12:51.170
Now we can run the program and it would run smoothly and you would see only two entries

00:12:51.170 --> 00:12:53.980
pretty well and good.

00:12:53.980 --> 00:12:54.980
Now,

00:12:54.980 --> 00:12:56.610
if this sounds confusing,

00:12:56.610 --> 00:12:58.850
then you don't have to worry much.

00:12:58.850 --> 00:13:02.450
Just make sure you always use string as a key.

00:13:02.450 --> 00:13:07.920
But if you're using your own object than make sure that you all right,

00:13:07.920 --> 00:13:13.750
both these methods equals and hash court and you cannot have just equals alone.

00:13:13.750 --> 00:13:15.830
You cannot get rid off hash code,

00:13:15.830 --> 00:13:16.750
for example.

00:13:16.750 --> 00:13:18.750
So that way,

00:13:18.750 --> 00:13:22.680
one of these conditions is not going to met.

00:13:22.680 --> 00:13:24.230
So again,

00:13:24.230 --> 00:13:25.280
we'll see the issue.

00:13:25.280 --> 00:13:27.960
We're seeing three entries.

00:13:27.960 --> 00:13:29.270
Likewise,

00:13:29.270 --> 00:13:31.950
you cannot get rid off the equals method hater.

00:13:31.950 --> 00:13:37.260
Inappropriate results.

00:13:37.260 --> 00:13:40.970
It's always make sure whenever you all right,

00:13:40.970 --> 00:13:41.430
either off,

00:13:41.430 --> 00:13:44.050
these methods always override boat.

00:13:44.050 --> 00:13:46.590
It's a very good descent practice.

00:13:46.590 --> 00:13:49.180
Let's undo all these changes.

00:13:49.180 --> 00:13:57.800
You can also explore other implementations,

00:13:57.800 --> 00:14:01.360
like three map linked hash map etcetera.

00:14:01.360 --> 00:14:10.230
But hash map is very popular one and is extensively used in the jiao world for one good

00:14:10.230 --> 00:14:12.100
reason performance.

00:14:12.100 --> 00:14:19.620
But no matter what implementation you use it has to provide functionality for put get and a

00:14:19.620 --> 00:14:21.360
lot of other methods.

00:14:21.360 --> 00:14:27.660
You can always explore the methods defined inside this interface or the implemented class.

00:14:27.660 --> 00:14:28.770
And your clips.

00:14:28.770 --> 00:14:35.550
I d read the description and play around with it all adopted on map.

00:14:35.550 --> 00:14:37.170
See you in my next video.

