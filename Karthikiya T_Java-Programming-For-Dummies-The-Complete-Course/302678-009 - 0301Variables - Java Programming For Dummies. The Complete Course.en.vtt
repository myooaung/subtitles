WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:04.450
in this chapter will talk about variables and data types.

00:00:04.450 --> 00:00:07.640
Take a look at these equations and math.

00:00:07.640 --> 00:00:09.860
Now I question for you.

00:00:09.860 --> 00:00:16.890
What can I do to these equations so that I can improve the readability and decrease the

00:00:16.890 --> 00:00:18.610
amount of physical effort required?

00:00:18.610 --> 00:00:20.660
It's simple.

00:00:20.660 --> 00:00:24.810
Our just represent these new miracles with letters.

00:00:24.810 --> 00:00:34.390
So maybe are just call this numerical as a and I would call this numerical has be and this

00:00:34.390 --> 00:00:35.250
as C.

00:00:35.250 --> 00:00:41.450
Now let's see how the equations look after replacing new miracles with letters.

00:00:41.450 --> 00:00:43.810
So this is how the look.

00:00:43.810 --> 00:00:46.870
Now the questions look a lot cleaner,

00:00:46.870 --> 00:00:48.950
more readable old,

00:00:48.950 --> 00:00:50.050
so down the line.

00:00:50.050 --> 00:00:52.960
If you want to write hundreds off other equations,

00:00:52.960 --> 00:00:55.220
you don't have to remember the new miracles.

00:00:55.220 --> 00:00:57.210
You can just use the letters instead,

00:00:57.210 --> 00:00:59.450
so that will save a lot of physical a forest.

00:00:59.450 --> 00:01:03.410
So what's a variable here is available here.

00:01:03.410 --> 00:01:04.670
Be is available here.

00:01:04.670 --> 00:01:05.950
See is available here.

00:01:05.950 --> 00:01:08.190
So from this,

00:01:08.190 --> 00:01:09.820
let's try to form a definition off.

00:01:09.820 --> 00:01:16.200
A variable variable is something that holds a certain data in this case,

00:01:16.200 --> 00:01:19.900
the variable A and B or holding new miracles.

00:01:19.900 --> 00:01:22.810
The dismal numbers don't let understand.

00:01:22.810 --> 00:01:24.050
Very built in Java.

00:01:24.050 --> 00:01:26.750
We have our first step program.

00:01:26.750 --> 00:01:31.520
Let's use the same program and make some amendments to it.

00:01:31.520 --> 00:01:40.900
So now what I'm going to do here is I'm going to find there's some off to new miracles.

00:01:40.900 --> 00:01:50.280
So let's say we have a words then and be works 4.3 to do the some off.

00:01:50.280 --> 00:01:51.750
These two new miracles,

00:01:51.750 --> 00:01:54.070
instead of displaying this message,

00:01:54.070 --> 00:01:56.650
would just say a Les B.

00:01:56.650 --> 00:01:56.970
Now,

00:01:56.970 --> 00:01:58.940
if I try to compel this program,

00:01:58.940 --> 00:02:01.320
the compiler will throw some errors.

00:02:01.320 --> 00:02:02.750
Let's see what those are.

00:02:02.750 --> 00:02:14.500
That's open the command processor and go to the directory where your program is reciting it

00:02:14.500 --> 00:02:15.190
in desktop.

00:02:15.190 --> 00:02:18.010
Let's do CLS to clear the screen.

00:02:18.010 --> 00:02:22.750
Now let's try to compile the program Java Sea,

00:02:22.750 --> 00:02:24.750
which is a Java compiler.

00:02:24.750 --> 00:02:27.140
Full stop.

00:02:27.140 --> 00:02:27.840
Don't job.

00:02:27.840 --> 00:02:33.550
So the compiler has thrown some errors.

00:02:33.550 --> 00:02:39.110
What says it cannot find symbol and it is pointing to letter.

00:02:39.110 --> 00:02:39.670
A.

00:02:39.670 --> 00:02:41.950
Same is the case with Letter B.

00:02:41.950 --> 00:02:42.900
All right,

00:02:42.900 --> 00:02:43.720
what's going on?

00:02:43.720 --> 00:02:46.940
Java is not a human being,

00:02:46.940 --> 00:02:48.850
it's a computer.

00:02:48.850 --> 00:02:52.830
It it's artificial intelligence and we humans.

00:02:52.830 --> 00:02:57.390
We programmers need to be more specific about the information that we're providing to a

00:02:57.390 --> 00:02:58.060
machine.

00:02:58.060 --> 00:02:59.570
By that I mean,

00:02:59.570 --> 00:03:01.040
it's just not enough.

00:03:01.040 --> 00:03:05.190
If you say equal Stan or B equals 4.3.

00:03:05.190 --> 00:03:12.540
We also need to tell Java what type of data at this age holding in this case it's indigent

00:03:12.540 --> 00:03:14.950
and gives off a and guess I'll be too dismal.

00:03:14.950 --> 00:03:17.050
Dismal point in America.

00:03:17.050 --> 00:03:26.810
So the key word that went to use for integer in Java is this tells Java that the variable A

00:03:26.810 --> 00:03:35.260
is holding a debt off type integer now for decimal point number.

00:03:35.260 --> 00:03:38.750
The key would not going to use is double.

00:03:38.750 --> 00:03:42.700
One thing to note is like a like I've already mentioned.

00:03:42.700 --> 00:03:45.180
Java is a case since two language,

00:03:45.180 --> 00:03:46.230
so instruct double.

00:03:46.230 --> 00:03:48.550
If you say capital d double,

00:03:48.550 --> 00:03:51.190
then this would yield a different result.

00:03:51.190 --> 00:03:56.530
Or if you say the or if you make always capital and this would yield,

00:03:56.530 --> 00:03:57.750
compile isn errors.

00:03:57.750 --> 00:03:59.490
So let's start do that.

00:03:59.490 --> 00:04:01.450
Um,

00:04:01.450 --> 00:04:05.300
let's give it as double and let's save the file.

00:04:05.300 --> 00:04:06.850
I just hit under less.

00:04:06.850 --> 00:04:10.780
Let's go to command Prasit again and try to compile the program.

00:04:10.780 --> 00:04:14.600
The program got compiled.

00:04:14.600 --> 00:04:15.470
Successful T.

00:04:15.470 --> 00:04:18.430
Now we also have it last file here to run the program.

00:04:18.430 --> 00:04:25.150
Let's do CLS to clear the screen and then Now let's just try to run the program.

00:04:25.150 --> 00:04:28.350
So Jama Space Fuster.

00:04:28.350 --> 00:04:30.740
That's it,

00:04:30.740 --> 00:04:31.210
ender.

00:04:31.210 --> 00:04:32.850
Great.

00:04:32.850 --> 00:04:35.950
It has shown the out book Foreign Born three,

00:04:35.950 --> 00:04:40.990
which is expected now to make this output looked a little bit more meaningful.

00:04:40.990 --> 00:04:45.570
Let's try to prevent a string before before the result,

00:04:45.570 --> 00:04:48.580
So instead of just saying a plus B,

00:04:48.580 --> 00:04:51.550
what we do is all right.

00:04:51.550 --> 00:04:54.690
A string Wood says.

00:04:54.690 --> 00:05:00.730
There's some off a A and B is the result.

00:05:00.730 --> 00:05:05.850
Now there's one more thing to note here.

00:05:05.850 --> 00:05:09.970
The character place in case off a plus B.

00:05:09.970 --> 00:05:14.800
It is used to find the some off these two new miracles.

00:05:14.800 --> 00:05:20.360
But the place in here is acting as a concatenation operator,

00:05:20.360 --> 00:05:22.520
which means it is concatenation,

00:05:22.520 --> 00:05:25.670
worst there in the left and what that comes in the right.

00:05:25.670 --> 00:05:27.290
Now,

00:05:27.290 --> 00:05:28.890
if you try to run this program,

00:05:28.890 --> 00:05:31.250
you'll see a strange output.

00:05:31.250 --> 00:05:33.710
But to what it is,

00:05:33.710 --> 00:05:39.650
it's compile the program and run it.

00:05:39.650 --> 00:05:42.890
There's some more.

00:05:42.890 --> 00:05:46.070
Fenby is wonder of 4.3.

00:05:46.070 --> 00:05:47.080
What has happened?

00:05:47.080 --> 00:05:49.160
It's supposed to be 14 door three,

00:05:49.160 --> 00:05:52.340
as I said,

00:05:52.340 --> 00:05:56.770
the plus character Selves to purposes one.

00:05:56.770 --> 00:05:59.550
It actors a concatenation operator.

00:05:59.550 --> 00:06:00.700
Also,

00:06:00.700 --> 00:06:03.650
it can be used to find the some off to new miracles.

00:06:03.650 --> 00:06:04.760
In this case,

00:06:04.760 --> 00:06:12.470
Java got confused to determine whether this is a concatenation operator or are to find the

00:06:12.470 --> 00:06:15.010
some off two new miracles.

00:06:15.010 --> 00:06:21.170
So what we want is we want this place operator Toby Akane gettin eating or greater and this

00:06:21.170 --> 00:06:24.050
place as as a press operator in Matt.

00:06:24.050 --> 00:06:29.320
So when you do put them in parentis is now.

00:06:29.320 --> 00:06:30.950
Let's just try to run the program,

00:06:30.950 --> 00:06:36.880
compile the program and then run it cool.

00:06:36.880 --> 00:06:39.100
It's displaying the correct result.

00:06:39.100 --> 00:06:43.960
There's some off NBC's $14.3 which makes sense.

00:06:43.960 --> 00:06:48.970
So a variable has the fallings in tax,

00:06:48.970 --> 00:06:50.800
the data type,

00:06:50.800 --> 00:06:56.660
which defines the type of data like indigenous and the name that you want to give to the

00:06:56.660 --> 00:06:57.250
variable.

00:06:57.250 --> 00:07:03.250
Something like this and the value actual value that this variable hordes.

00:07:03.250 --> 00:07:08.420
Now let's try to understand what happens behind the scenes when we say intake will stand.

00:07:08.420 --> 00:07:10.700
So when we run the program,

00:07:10.700 --> 00:07:14.150
and when the interpreter comes across with this instruction,

00:07:14.150 --> 00:07:18.700
it will create a memory location to store the value 10.

00:07:18.700 --> 00:07:24.940
And how would this family location be identified with an identifier,

00:07:24.940 --> 00:07:27.450
which is a in this case,

00:07:27.450 --> 00:07:29.190
so variable,

00:07:29.190 --> 00:07:29.850
in a sense,

00:07:29.850 --> 00:07:32.350
is nothing but this memory location.

00:07:32.350 --> 00:07:34.250
So down the lane,

00:07:34.250 --> 00:07:36.630
if you do a place,

00:07:36.630 --> 00:07:44.850
be the interpreter tries to look at the memory location with an identified A and get the

00:07:44.850 --> 00:07:49.260
value inside it and replace this letter A with 10.

00:07:49.260 --> 00:07:51.820
So behind the scenes,

00:07:51.820 --> 00:07:54.550
it does tend Bless 20.

00:07:54.550 --> 00:08:00.220
Now we have different types off variables in Java,

00:08:00.220 --> 00:08:01.780
but at this point of time,

00:08:01.780 --> 00:08:08.380
it is way too advanced after we cover the concepts off classes and methods.

00:08:08.380 --> 00:08:14.820
And a few other topics will definitely be getting back on this ray bolts and will explore

00:08:14.820 --> 00:08:16.280
even more concepts.

00:08:16.280 --> 00:08:17.840
No,

00:08:17.840 --> 00:08:18.670
I said,

00:08:18.670 --> 00:08:21.570
a certain memory is located.

00:08:21.570 --> 00:08:27.690
But how much is dependent on the type of data In case off integer,

00:08:27.690 --> 00:08:31.740
it's going to locate four bites off memory in case off double.

00:08:31.740 --> 00:08:34.380
It's going to take eight bites off memory.

00:08:34.380 --> 00:08:41.800
Our next lesson is dedicated to understand how much memory does each data type take and

00:08:41.800 --> 00:08:42.850
their ranges.

00:08:42.850 --> 00:08:43.920
For example,

00:08:43.920 --> 00:08:47.050
you can you can just you 10 zillion number here.

00:08:47.050 --> 00:08:51.050
There's a certain range within which the number has to be

