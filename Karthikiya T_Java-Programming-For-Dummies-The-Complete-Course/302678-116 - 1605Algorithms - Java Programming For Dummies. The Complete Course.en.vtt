WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.290
in this video,

00:00:02.290 --> 00:00:07.590
we're gonna talk about some of the pre existing algorithms that we can make use off to

00:00:07.590 --> 00:00:10.950
perform a variety off operations on collections.

00:00:10.950 --> 00:00:12.500
In this case,

00:00:12.500 --> 00:00:18.720
we're going to consider other list for demonstration purpose and all the algorithms that

00:00:18.720 --> 00:00:19.870
I'm talking about,

00:00:19.870 --> 00:00:22.950
or part off a class called Collections.

00:00:22.950 --> 00:00:26.760
And we're going to perform operations like sorting,

00:00:26.760 --> 00:00:32.380
which will sort elements often aerialist in a particular order searching,

00:00:32.380 --> 00:00:36.530
which will enable us to search an element in the list and shuffle,

00:00:36.530 --> 00:00:38.950
which will shuffle all the elements in the list.

00:00:38.950 --> 00:00:39.960
Likewise,

00:00:39.960 --> 00:00:45.990
we have few other algorithms that you can make use off to do a variety of things.

00:00:45.990 --> 00:00:47.220
In this example,

00:00:47.220 --> 00:00:50.850
I just have one method which will just return another list.

00:00:50.850 --> 00:00:54.480
And every time I make use off one off those algorithms,

00:00:54.480 --> 00:00:57.330
I'm getting a fresh list by calling this method.

00:00:57.330 --> 00:00:58.570
So in this section,

00:00:58.570 --> 00:01:02.150
what I'm doing here is I got better list,

00:01:02.150 --> 00:01:10.220
and I'm passing that argument to a method called sort of collections by default.

00:01:10.220 --> 00:01:16.950
It's going to sort all the elements in ascending order if the list constitute integers or

00:01:16.950 --> 00:01:19.100
double any numeric value.

00:01:19.100 --> 00:01:25.750
If it is a string than it's going to sort all the elements in alphabetical order.

00:01:25.750 --> 00:01:27.760
Since we're sending a string,

00:01:27.760 --> 00:01:31.200
this is going to sort all the element in alphabetical order,

00:01:31.200 --> 00:01:33.650
and that's what we're doing here.

00:01:33.650 --> 00:01:36.700
If you wanted to do it the other way,

00:01:36.700 --> 00:01:41.130
if you wanted to sort the elements in divers are for indigents,

00:01:41.130 --> 00:01:42.850
it's going to be in descending order.

00:01:42.850 --> 00:01:46.050
Then you're gonna pass another argument,

00:01:46.050 --> 00:01:50.520
which is this Collections dot reverse order.

00:01:50.520 --> 00:01:51.470
So basically,

00:01:51.470 --> 00:01:57.950
the sort method is going to accept severity off arguments when a single argument,

00:01:57.950 --> 00:02:03.150
which is simply a list the other one is along with the Comparator,

00:02:03.150 --> 00:02:05.850
which will talk about in a minute.

00:02:05.850 --> 00:02:10.300
But basically this instruction will actually sort in ascending order,

00:02:10.300 --> 00:02:14.560
and it would reverse it out so that we get the reverse order.

00:02:14.560 --> 00:02:16.350
Let's try to run the program.

00:02:16.350 --> 00:02:26.070
Let me just come in doubt the section off good so list before starting.

00:02:26.070 --> 00:02:28.250
This is how it looked,

00:02:28.250 --> 00:02:33.250
ascending order and the reverse off it,

00:02:33.250 --> 00:02:36.880
which would be descending order at some comment.

00:02:36.880 --> 00:02:39.000
Let's come in this section,

00:02:39.000 --> 00:02:45.250
and I got a fresh list off strings again in here,

00:02:45.250 --> 00:02:49.090
and this time I'm trying to search an element,

00:02:49.090 --> 00:02:53.040
and for that I'm going to call this method by any research,

00:02:53.040 --> 00:02:55.710
which is a static method off the collections class.

00:02:55.710 --> 00:02:59.750
It's going to accept a couple off para meters number one,

00:02:59.750 --> 00:03:04.640
the list in which you wanted to perform the search operation and the element that you want

00:03:04.640 --> 00:03:05.310
to search.

00:03:05.310 --> 00:03:07.500
This will returners the index.

00:03:07.500 --> 00:03:12.690
Let's run the program and see the result.

00:03:12.690 --> 00:03:16.800
So it's that Index one and exito in next one.

00:03:16.800 --> 00:03:19.240
Similarly,

00:03:19.240 --> 00:03:23.410
you can shuffle all the elements in the list.

00:03:23.410 --> 00:03:26.050
So let's from this program.

00:03:26.050 --> 00:03:32.750
We were just calling the shuffle method and you're passing the list there it iss.

00:03:32.750 --> 00:03:35.550
The list is shuffled,

00:03:35.550 --> 00:03:37.960
and every time you run,

00:03:37.960 --> 00:03:39.390
the results will be different.

00:03:39.390 --> 00:03:43.210
Obviously that statement off shuffling element.

00:03:43.210 --> 00:03:47.110
So these are some of the pre defined algorithms.

00:03:47.110 --> 00:03:47.820
Likewise,

00:03:47.820 --> 00:03:48.820
there are a few more,

00:03:48.820 --> 00:03:50.050
if you want to explore,

00:03:50.050 --> 00:03:55.710
can just go to the documentation of the collections class and experiment with them.

00:03:55.710 --> 00:03:57.390
Let me and commit everything.

00:03:57.390 --> 00:04:00.900
Now you may have a question arising in your mind.

00:04:00.900 --> 00:04:05.970
How do we deal with list that has our own custom objects?

00:04:05.970 --> 00:04:10.900
How does these algorithms know how to sort are objects,

00:04:10.900 --> 00:04:12.450
or how to search an element,

00:04:12.450 --> 00:04:13.230
etcetera,

00:04:13.230 --> 00:04:18.630
The answer is it doesn't know we need to tell how to deal with our own objects.

00:04:18.630 --> 00:04:22.330
We'll see an example off it in our next video.

00:04:22.330 --> 00:04:23.950
See you in my next video.

