WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.220
in this video,

00:00:01.220 --> 00:00:05.020
we're gonna talk about Set and for this example,

00:00:05.020 --> 00:00:09.420
I'm going to make use off the exact same called what we have in our list.

00:00:09.420 --> 00:00:10.150
Example.

00:00:10.150 --> 00:00:13.640
Let's get it off this for the time being.

00:00:13.640 --> 00:00:15.440
Instead,

00:00:15.440 --> 00:00:16.020
off list,

00:00:16.020 --> 00:00:19.910
I'm going to call it a set and insulin off Federalist.

00:00:19.910 --> 00:00:22.800
I'm going to say half set,

00:00:22.800 --> 00:00:24.690
basically hash.

00:00:24.690 --> 00:00:30.660
That is a class that pro its implementation for this hadn't if s,

00:00:30.660 --> 00:00:32.030
of course,

00:00:32.030 --> 00:00:34.550
money to import both off these.

00:00:34.550 --> 00:00:38.490
So what is a set?

00:00:38.490 --> 00:00:41.010
Has said it is similar to a list,

00:00:41.010 --> 00:00:45.510
except it differs in terms off to aspirants number one.

00:00:45.510 --> 00:00:47.490
It cannot have double get elements.

00:00:47.490 --> 00:00:48.600
And number two,

00:00:48.600 --> 00:00:53.460
the order in which the elements are inserted may not be the same order.

00:00:53.460 --> 00:00:55.650
When we read elements from the set,

00:00:55.650 --> 00:00:57.680
let me show you what I mean.

00:00:57.680 --> 00:01:03.360
I'm going to make use off a simple says out statement to print the set,

00:01:03.360 --> 00:01:07.160
but let's call this set in straw awful list.

00:01:07.160 --> 00:01:08.880
That would make more sense.

00:01:08.880 --> 00:01:12.250
Let's have the file.

00:01:12.250 --> 00:01:15.070
Let's run the program.

00:01:15.070 --> 00:01:23.770
My first element is 10 but what we have here is 20 so the order is not guaranteed.

00:01:23.770 --> 00:01:25.240
Also,

00:01:25.240 --> 00:01:31.640
this set off elements does not have any duplicate values and the people get objects.

00:01:31.640 --> 00:01:32.050
Rather,

00:01:32.050 --> 00:01:35.300
we have added 20 twice.

00:01:35.300 --> 00:01:37.470
We've also added 40 twice,

00:01:37.470 --> 00:01:44.100
but they're being displayed only once and with that said cannot work on in dices,

00:01:44.100 --> 00:01:44.950
for example,

00:01:44.950 --> 00:01:48.880
like we have here for a list.

00:01:48.880 --> 00:01:52.750
Let let's start get cannot have such method in here.

00:01:52.750 --> 00:01:58.070
That method is not supported because that's I make the six.

00:01:58.070 --> 00:02:04.110
What I would expect from this instruction is it would get me the Element 40 which is that

00:02:04.110 --> 00:02:05.120
index six,

00:02:05.120 --> 00:02:06.100
if you look at it.

00:02:06.100 --> 00:02:10.030
But when the program is run,

00:02:10.030 --> 00:02:13.650
all the double get element in the set are eliminated.

00:02:13.650 --> 00:02:14.350
Also,

00:02:14.350 --> 00:02:19.420
the order in which elements are stored in the set is not the same order.

00:02:19.420 --> 00:02:27.190
We add them so it doesn't make sense to have this method toe get an element at a particular

00:02:27.190 --> 00:02:27.850
index.

00:02:27.850 --> 00:02:29.930
And with that being said,

00:02:29.930 --> 00:02:32.970
we cannot use something like the full open here.

00:02:32.970 --> 00:02:36.750
It's to control sea and control V.

00:02:36.750 --> 00:02:44.580
We can't work with full appear because we cannot get the element at a particle index.

00:02:44.580 --> 00:02:47.010
But we have an alternate.

00:02:47.010 --> 00:02:50.920
We're going to make use off something called an eye traitor.

00:02:50.920 --> 00:02:54.320
So we're gonna say I traitor.

00:02:54.320 --> 00:02:55.340
It's a class.

00:02:55.340 --> 00:02:59.650
Let's call it I tr It's not interest rates at aerator.

00:02:59.650 --> 00:03:04.320
That's to conduct your toe two.

00:03:04.320 --> 00:03:13.760
Important this class from the util package it quotes and I'm going to do said dot Traitor

00:03:13.760 --> 00:03:15.750
will understand what is a night traitor.

00:03:15.750 --> 00:03:24.450
Now this method I trader off the Hachette is going to return an object off.

00:03:24.450 --> 00:03:30.330
I trade her what it's going to offer as an alternative solution for the folder.

00:03:30.330 --> 00:03:32.650
Let me demonstrate what I mean.

00:03:32.650 --> 00:03:35.780
They're a couple of metal that we're gonna make use off.

00:03:35.780 --> 00:03:38.090
I traded out next.

00:03:38.090 --> 00:03:43.100
What this is going to do returns the next element in the iteration.

00:03:43.100 --> 00:03:55.420
Let's try to retrieve the element Let's do sis out and that spend what it is returning So

00:03:55.420 --> 00:04:01.690
know what this is going to do is it's going to return the first element in the set.

00:04:01.690 --> 00:04:06.510
And when I called the same method next on the same object,

00:04:06.510 --> 00:04:07.400
I'd er,

00:04:07.400 --> 00:04:11.250
then this is going to return the next element.

00:04:11.250 --> 00:04:14.390
So let me just demonstrated what I mean.

00:04:14.390 --> 00:04:16.150
If we run this program,

00:04:16.150 --> 00:04:21.510
this instruction returned 20 the next time I called this method next,

00:04:21.510 --> 00:04:26.000
it's going to return the next element in the set.

00:04:26.000 --> 00:04:27.310
Similarly,

00:04:27.310 --> 00:04:35.230
we can called all the elements and forget all the four elements that are reciting the set

00:04:35.230 --> 00:04:39.090
if you try to call any additional element,

00:04:39.090 --> 00:04:45.220
which is not present in the set because as we know that some of these elements are deleted

00:04:45.220 --> 00:04:47.250
due to duplication.

00:04:47.250 --> 00:04:49.250
So let's run the program.

00:04:49.250 --> 00:04:51.050
We're going to get an exception,

00:04:51.050 --> 00:04:53.840
but there's no such element exception.

00:04:53.840 --> 00:05:00.040
So to get it off this kind of exceptions in our program there's another method which we can

00:05:00.040 --> 00:05:04.760
check to see if there is next element available.

00:05:04.760 --> 00:05:15.380
So if I tr DOT has next is going to return a Boolean value and it would tell if we can,

00:05:15.380 --> 00:05:17.250
here's them at the next,

00:05:17.250 --> 00:05:20.230
so only if this is too.

00:05:20.230 --> 00:05:23.950
But we want to get the next element.

00:05:23.950 --> 00:05:27.950
So this is going to solve our problem.

00:05:27.950 --> 00:05:34.170
Let's run the program this time.

00:05:34.170 --> 00:05:41.690
We shouldn't be having an exception because in here this is pose condition didn't met and

00:05:41.690 --> 00:05:43.140
this chairman didn't get executed.

00:05:43.140 --> 00:05:44.390
However,

00:05:44.390 --> 00:05:46.060
we don't want to do it this way.

00:05:46.060 --> 00:05:49.750
We want to make use off some kind off a looping construct.

00:05:49.750 --> 00:05:57.760
I want to look to each and every element in here and kind off perform some operations.

00:05:57.760 --> 00:05:58.880
The concert,

00:05:58.880 --> 00:06:01.350
make use off while loop or even for a loop.

00:06:01.350 --> 00:06:02.880
I'm going to make yourself.

00:06:02.880 --> 00:06:12.400
I loop someone to say I tear dot has next and I'm going to say sis out.

00:06:12.400 --> 00:06:15.540
I tr thought,

00:06:15.540 --> 00:06:26.480
Next's now this is going to return the next element in the operation Place 10 or whatever

00:06:26.480 --> 00:06:31.330
you want to do now this is going to be an object.

00:06:31.330 --> 00:06:43.820
Hands went to perform typecasting integer That's get it off this chord in here now from the

00:06:43.820 --> 00:06:46.470
program terrorists.

00:06:46.470 --> 00:06:49.310
The result is as expected,

00:06:49.310 --> 00:06:54.220
so this house next is going to return.

00:06:54.220 --> 00:06:54.890
True,

00:06:54.890 --> 00:06:55.260
it die.

00:06:55.260 --> 00:06:57.370
Attrition has more elements,

00:06:57.370 --> 00:06:58.450
in other words,

00:06:58.450 --> 00:07:03.150
returns to if next would return if the matter next,

00:07:03.150 --> 00:07:08.810
which were used inside the by loop but return an element rather than throwing an exception

00:07:08.810 --> 00:07:08.810
.

00:07:08.810 --> 00:07:16.240
But let's see what will happen if it don't make use off this next element that's scattered

00:07:16.240 --> 00:07:21.530
off this Now this is going to be an infinite loop.

00:07:21.530 --> 00:07:26.900
That's because since we haven't read than elements using the next,

00:07:26.900 --> 00:07:30.260
the has next always return true.

00:07:30.260 --> 00:07:31.300
Let's run the program.

00:07:31.300 --> 00:07:38.750
Obviously this goes forever that we need to explicitly stop the program.

00:07:38.750 --> 00:07:41.170
Hold it now.

00:07:41.170 --> 00:07:45.110
This explains the difference between set and the list.

00:07:45.110 --> 00:07:46.890
Also,

00:07:46.890 --> 00:07:48.690
there is a shorthand way off.

00:07:48.690 --> 00:07:54.470
Dealing with Iitrader is by using something called forage loop.

00:07:54.470 --> 00:08:02.850
Let me show you what I mean when I say for and we're gonna say the type of data,

00:08:02.850 --> 00:08:09.140
the type of elements present in the set and let's I or whatever you want to give,

00:08:09.140 --> 00:08:19.170
we're gonna use Colon and then which is going to pass in the set object and that's all

00:08:19.170 --> 00:08:19.980
there is to it.

00:08:19.980 --> 00:08:22.860
And you can do exact same thing,

00:08:22.860 --> 00:08:27.200
what you're doing here and instead,

00:08:27.200 --> 00:08:28.720
off I chilled out.

00:08:28.720 --> 00:08:29.350
Next,

00:08:29.350 --> 00:08:33.370
you can say simply high variable.

00:08:33.370 --> 00:08:41.720
So you can think off the statement as a shorthand for writing all this so internally this

00:08:41.720 --> 00:08:43.770
is going to use I traitor.

00:08:43.770 --> 00:08:44.590
Also,

00:08:44.590 --> 00:08:48.750
this is visually more readable and maintainable.

00:08:48.750 --> 00:08:57.250
So what this means is for each element I off type integer in the set.

00:08:57.250 --> 00:08:59.360
We're gonna do this.

00:08:59.360 --> 00:09:03.200
Let's run the program there.

00:09:03.200 --> 00:09:05.280
It is in fact,

00:09:05.280 --> 00:09:07.170
all the canoes poor loop.

00:09:07.170 --> 00:09:08.240
For a realist,

00:09:08.240 --> 00:09:14.550
it's always advisable to use a dry traitor or the forage loop.

00:09:14.550 --> 00:09:20.170
We'll see why at later point of time once we caressed off the topics.

00:09:20.170 --> 00:09:20.840
OK,

00:09:20.840 --> 00:09:21.430
lastly,

00:09:21.430 --> 00:09:32.700
there's one downside with using for loop over the traitor in I traitor can actually make

00:09:32.700 --> 00:09:37.650
use off the remove minted to remove an element.

00:09:37.650 --> 00:09:42.860
But whereas in here we cannot accomplish the same.

00:09:42.860 --> 00:09:43.390
For example,

00:09:43.390 --> 00:09:51.490
I cannot say I don't remove or whatever because the eyes off type integer but anyways,

00:09:51.490 --> 00:09:52.860
you always have working on.

00:09:52.860 --> 00:09:53.720
For example,

00:09:53.720 --> 00:09:56.150
you can use the remove matter in the set.

00:09:56.150 --> 00:10:00.950
Remove and then you can tell the object to be removed.

00:10:00.950 --> 00:10:05.960
But it's a bad practice to use and guess if you're dealing with removing elements,

00:10:05.960 --> 00:10:11.450
then you're better off used the trader than the forage loop.

00:10:11.450 --> 00:10:13.400
Hope that makes sense.

00:10:13.400 --> 00:10:20.150
Put up more on I treasure at later point off Time se you in my next video.

