WEBVTT
1
00:00:01.840 --> 00:00:06.930
Halo semuanya dan selamat datang di ceramah tentang pohon-pohon warga dan kekuatan acak.

2
00:00:06.930 --> 00:00:13.480
Jadi seperti biasa ada iPod iPhone atau kadang-kadang disebut notebook Jupiter tersedia untuk Anda yang sejalan dengan

3
00:00:13.480 --> 00:00:14.560
kuliah ini.

4
00:00:14.560 --> 00:00:21.520
Anda dapat menemukan bahwa Anda memenuhi repo pembelajaran mesin kas simpanan di bawah pohon keputusan secara acak.

5
00:00:21.520 --> 00:00:25.160
Jadi kuliah ini akan membahas ini di pohon dan merangkak acak.

6
00:00:25.160 --> 00:00:29.870
Tetapi agar Anda benar-benar memahami ceramah ini ada beberapa bacaan wajib.

7
00:00:30.120 --> 00:00:34.820
Jadi Anda akan pergi ke depan dan pergi ke notebook ini dan membaca posting blog saya

8
00:00:34.820 --> 00:00:41.030
sehingga Anda dapat mengklik tautan itu di sini dan saya akan membawa Anda ke halaman ini yang disebut Enchanted random force dan

9
00:00:41.030 --> 00:00:44.130
itu hanya panduan cepat untuk ini bukan pengkhianatan menjalankan kekuatan.

10
00:00:44.130 --> 00:00:45.500
Jadi, silakan baca.

11
00:00:45.500 --> 00:00:47.450
Pastikan Anda mengerti apa yang sedang terjadi.

12
00:00:47.450 --> 00:00:52.910
Seharusnya penjelasan yang cukup mudah dan sederhana tentang apa ini bukan Trias bagaimana cara

13
00:00:52.910 --> 00:00:59.560
kerjanya, apa keuntungannya dan bagaimana itu bekerja dan juga apa yang membuat hutan acak bekerja sebagai metode ansambel.

14
00:00:59.560 --> 00:01:07.500
Jadi banyak teori aktual penjelasan tentang apa yang sebenarnya terjadi akan terjadi di posting blog ini.

15
00:01:07.500 --> 00:01:13.670
Jadi, teruskan dan pastikan Anda membacanya sebelum melanjutkan untuk tinggal coding melalui sisa

16
00:01:13.670 --> 00:01:14.900
notebook ini.

17
00:01:14.900 --> 00:01:15.470
Baiklah.

18
00:01:15.910 --> 00:01:18.570
Selain itu, mari kita mulai dan memulai.

19
00:01:18.570 --> 00:01:20.370
Jadi saya punya beberapa impor di sini.

20
00:01:20.370 --> 00:01:22.050
Saya akan pergi dan menyalin dan menempelkannya.

21
00:01:24.010 --> 00:01:25.400
Dari buku catatan.

22
00:01:25.740 --> 00:01:32.590
Jadi kami mengimpor mati rasa PI menggeser peta langsung dan seaborne serta mengatakan bagian itu

23
00:01:32.820 --> 00:01:38.580
hidup dalam garis sehingga kita dapat melihat plot kami di notebook.

24
00:01:38.580 --> 00:01:41.630
Baiklah jadi mari kita mulai dan memulai.

25
00:01:41.630 --> 00:01:45.280
Hal pertama yang akan kita lakukan adalah memikirkan klasifikasi.

26
00:01:45.280 --> 00:01:50.890
Jadi gaya acak adalah contoh klasik pembelajar ensemble.

27
00:01:50.890 --> 00:01:57.550
Dan seperti yang dijelaskan dalam posting blog Hutan adalah pembelajar ensemble karena mereka adalah ensemble dari banyak

28
00:01:57.550 --> 00:02:00.570
pelajar yang lemah yang merupakan pohon sistem.

29
00:02:00.570 --> 00:02:07.280
Jadi yang akan kita lakukan adalah mulai dengan pohon keputusan sehingga kita tahu bahwa ini bukan pohon dari posting blog itu.

30
00:02:07.280 --> 00:02:12.900
Memanfaatkan pemisahan biner untuk membuat keputusan berdasarkan fitur yang merupakan pertanyaan yang kami tanyakan.

31
00:02:13.350 --> 00:02:18.520
Jadi mari kita keluar dan membuat beberapa data menggunakan beberapa fungsi bawaan dan Psik yang dipelajari.

32
00:02:18.520 --> 00:02:24.300
Jadi hal pertama yang akan saya lakukan adalah mengatakan dari S K untuk belajar.

33
00:02:26.710 --> 00:02:35.720
Mereka akan menilai impor membuat Blob's begitu sikat belajar berasal dari banyak alat yang menarik dan berguna untuk membuat set data palsu

34
00:02:35.720 --> 00:02:40.980
sehingga Anda dapat menguji algoritma Anda hanya untuk memastikan Anda mendapatkan hasil

35
00:02:40.980 --> 00:02:42.480
yang masuk akal.

36
00:02:42.480 --> 00:02:50.520
Jadi kita akan menggunakan fungsi fitur gumpalan dari skalar dan kumpulan data dan

37
00:02:50.520 --> 00:03:00.420
kemudian apa yang akan saya lakukan adalah mengatakan xy sama dengan membuat gumpalan juga jumlah sampel adalah

38
00:03:00.420 --> 00:03:06.610
jumlah total sampel sama dengan 500 semua memiliki empat pusat.

39
00:03:06.610 --> 00:03:11.100
Karena saya membuat gumpalan dan saya akan merencanakan ini jadi harus cukup jelas.

40
00:03:11.100 --> 00:03:15.170
Jadi pada dasarnya saat ini kami memiliki seratus dua puluh lima sampel per pusat.

41
00:03:15.170 --> 00:03:19.430
Saya akan menempatkan Negara acak sama dengan delapan.

42
00:03:19.430 --> 00:03:22.810
Jadi jika saya tidak menempatkan dalam keadaan acak mereka akan sepenuhnya acak.

43
00:03:22.810 --> 00:03:25.670
Tetapi jika Anda memasukkan garis bawah acak tetap sama dengan 8.

44
00:03:25.670 --> 00:03:28.170
Anda harus bisa mengikuti apa yang saya lakukan di sini.

45
00:03:29.450 --> 00:03:34.170
Dan kemudian sejauh cluster mereka juga dapat memiliki standar deviasi.

46
00:03:34.170 --> 00:03:39.320
Saya hanya main-main dan memutuskan 2. 4 adalah standar deviasi OK.

47
00:03:39.420 --> 00:03:44.810
Jika Anda melakukan standar deviasi yang terlalu rendah, cluster Anda akan sepenuhnya terpisah dan Anda

48
00:03:44.810 --> 00:03:46.520
tidak akan merasakan algoritme.

49
00:03:46.520 --> 00:03:51.570
Jika terlalu tinggi penyimpangan stand Anda tidak akan benar-benar memiliki cluster akan di semua tempat

50
00:03:51.570 --> 00:03:55.280
akan sulit untuk mengatakan dengan hasil yang sebenarnya terlihat seperti.

51
00:03:55.280 --> 00:04:03.460
Jadi sekarang mari kita membuat plot sebaran ini semua mengatakan figur kulit.

52
00:04:04.960 --> 00:04:08.770
Saya akan mengatur ukuran tetap saya sama dengan.

53
00:04:08.770 --> 00:04:11.750
Anggap saja sekarang enam dengan enam.

54
00:04:11.750 --> 00:04:13.200
Kita bisa menyesuaikannya nanti.

55
00:04:14.280 --> 00:04:26.010
Dan saya akan membuat plot pencar semua titik di sepanjang X untuk semua titik di sepanjang.

56
00:04:28.070 --> 00:04:39.950
Sumbu 0 dan 1 C sama dengan Y yang merupakan label saya yaitu label warna saya sehingga ukurannya sama dengan 50 dan juga peta

57
00:04:39.950 --> 00:04:42.430
warna sama dengan jet.

58
00:04:43.170 --> 00:04:45.710
Jadi maju dan lari ke sana.

59
00:04:45.710 --> 00:04:46.490
Dan kita mulai.

60
00:04:46.490 --> 00:04:50.360
Jadi apa yang saya miliki di sini saya memiliki gumpalan yang saya buat.

61
00:04:50.360 --> 00:04:55.500
Jadi ini membuat gumpalan pada dasarnya hanya cara membuat kelompok atau gumpalan.

62
00:04:55.500 --> 00:05:01.050
Anda dapat memilih jumlah sampel berapa banyak pusat yang Anda inginkan keadaan acak jika Anda ingin membagikan hasil.

63
00:05:01.050 --> 00:05:08.190
Jadi, jika Anda menempatkan dalam keadaan acak sama dengan delapan, Anda akan melihat formasi gumpalan yang sama selama Anda juga

64
00:05:08.190 --> 00:05:10.110
menempatkan standar deviasi yang sama.

65
00:05:10.570 --> 00:05:17.780
Dan kemudian kami pergi ke depan dan mengambil dari informasi X nol pada satu akses dan kemudian melihat di mana

66
00:05:17.780 --> 00:05:21.650
warna sama dengan y karena y adalah label di sini.

67
00:05:21.650 --> 00:05:22.750
Kanan.

68
00:05:22.750 --> 00:05:24.920
OK jadi mari kita masuk dan melanjutkan.

69
00:05:28.380 --> 00:05:34.160
Jadi yang akan kita lakukan sekarang adalah mengimpor classifier pohon keputusan.

70
00:05:34.160 --> 00:05:43.760
Jadi saya akan mengatakan dari melarikan diri untuk belajar impor pohon ini dalam api kelas pohon dan melihat ada

71
00:05:43.760 --> 00:05:45.840
opsi penekan di sana.

72
00:05:45.840 --> 00:05:51.260
Kami akan membahas regresi setelah klasifikasi dalam kuliah ini.

73
00:05:51.260 --> 00:05:52.780
Jadi saya sudah mengimpornya.

74
00:05:52.780 --> 00:05:57.800
Dan sebelum kita mulai menerapkan pada pohon warga yang akan kita lakukan adalah membuat fungsi

75
00:05:57.800 --> 00:06:00.900
yang bagus untuk memplot batas Sishen menggunakan grid mesh.

76
00:06:01.180 --> 00:06:06.700
Jadi ini semacam grid grid merencanakan dengan batas-batas keputusan benar-benar teknik yang umum digunakan banyak

77
00:06:06.730 --> 00:06:08.930
dalam dokumentasi psikis yang dipelajari.

78
00:06:08.930 --> 00:06:11.210
Jadi saya membuat fungsi di sini.

79
00:06:12.760 --> 00:06:15.190
Jadi saya punya fungsi besar di sini.

80
00:06:15.190 --> 00:06:17.040
Saya akan gulir ke bawah sehingga Anda bisa melihatnya.

81
00:06:17.040 --> 00:06:18.950
Dan ini adalah fungsi visualisasi.

82
00:06:18.950 --> 00:06:24.320
Jadi pada dasarnya apa yang dilakukan atau dimasukkan sebagai input model itu sendiri.

83
00:06:24.320 --> 00:06:30.560
Jadi model apa pun yang kita letakkan informasi X dan Y sehingga fitur dan

84
00:06:30.560 --> 00:06:37.910
labelnya jadi apa warnanya pada dasarnya Dan kemudian kita juga memiliki beberapa batas xy opsional dan kemudian menampilkan

85
00:06:37.940 --> 00:06:40.220
visualisasi untuk batas pohon keputusan.

86
00:06:40.220 --> 00:06:43.720
Jadi seperti yang Anda lihat sebenarnya cukup panjang.

87
00:06:43.720 --> 00:06:51.170
Jadi saya akan mengatakan itu hanya untuk tujuan visualisasi Anda berlindung hanya menyalin dan menempel ini

88
00:06:51.170 --> 00:06:55.010
sehingga Anda tidak perlu mengetik semuanya sendiri.

89
00:06:55.010 --> 00:07:01.790
Tapi apa yang akan saya lakukan adalah saya akan menyalin dan menempelkannya sekarang ke sesi kode langsung kami dan kemudian

90
00:07:01.790 --> 00:07:06.660
saya akan dengan cepat memecah apa yang dilakukan setiap bagian dari kode ini.

91
00:07:06.660 --> 00:07:13.830
Jadi saya memiliki fungsi yang disebut memvisualisasikan pohon mengambil dalam model kelas api mengambil dalam fitur X label Y

92
00:07:13.830 --> 00:07:21.270
target dan kemudian juga mengambil dalam batas boolean disebut yang akan membahas nanti ketika kita pindah ke kekuatan acak

93
00:07:21.270 --> 00:07:26.780
pada dasarnya hanya mengatakan apakah bukannya kita ingin benar-benar menggambar batas-batas yang sebenarnya.

94
00:07:26.780 --> 00:07:29.710
Dan kemudian dibutuhkan batas X dalam beberapa saat M begitu.

95
00:07:31.020 --> 00:07:36.130
Hal pertama yang kita lakukan adalah data x dan y ke pohon.

96
00:07:36.130 --> 00:07:44.190
Jadi kita mengambil classifier dan menyesuaikannya dengan X dan Y dan kemudian apa yang saya miliki di sini secara otomatis

97
00:07:44.190 --> 00:07:53.170
menetapkan batas x dan y untuk data sehingga mengambil minimum kata minus point 1 meraih max pada kolom itu dan kemudian mengatakan plus

98
00:07:53.170 --> 00:07:56.740
point 1 lalu mengapa membatasi hal yang sama.

99
00:07:56.740 --> 00:07:58.360
Min maks.

100
00:07:58.360 --> 00:08:00.440
Jadi hanya sebuah catatan di sini.

101
00:08:00.440 --> 00:08:06.360
Batas Y Anda masih ditentukan oleh kolom fitur kedua.

102
00:08:06.360 --> 00:08:11.990
OK, mari kita atur x min Max berikutnya.

103
00:08:11.990 --> 00:08:13.230
Karena ini adalah tuple.

104
00:08:13.230 --> 00:08:15.040
Perhatikan di sini kita memiliki sebuah tuple.

105
00:08:15.040 --> 00:08:16.760
Kami menugaskannya dengan beberapa tuple membongkar.

106
00:08:16.760 --> 00:08:20.980
Jadi kita punya x pria yang memukul y m. WiMAX.

107
00:08:20.980 --> 00:08:22.510
Lalu kami mengatur jaringan mesh kami.

108
00:08:22.510 --> 00:08:24.290
Kami pernah melihatnya sekali sebelumnya.

109
00:08:24.290 --> 00:08:31.090
Jadi numpad memiliki grid mesh dan itu berbaris ruang linear sehingga 100 poin ruang linear dari X

110
00:08:31.090 --> 00:08:38.040
berarti Xmax dan kemudian sama dari y berarti YMX menggunakan tuple membongkar untuk membuat ini x x yy

111
00:08:38.040 --> 00:08:45.260
Jadi Anda memiliki grid mesh Anda di sana dan kemudian apa yang kami lakukan adalah kami mendefinisikan Z berdasarkan prediksi.

112
00:08:45.260 --> 00:08:48.440
Jadi ini akan memberi warna pada kotak mesh itu sendiri.

113
00:08:48.440 --> 00:08:52.470
Dan ketika saya menjalankan ini mungkin akan lebih jelas dan apa yang sebenarnya kita maksud dengan mewarnai.

114
00:08:53.410 --> 00:08:59.850
Dan kita memiliki fungsi pi mati ini yang memungkinkan kita untuk pada dasarnya menempatkan di grid

115
00:08:59.890 --> 00:09:04.180
mesh dan bentuk array yang benar untuk classifier prediksi

116
00:09:04.180 --> 00:09:10.530
Sekarang biasanya Anda pasti tidak perlu melakukan notasi Pyar semacam ini tapi ini hanya untuk

117
00:09:10.530 --> 00:09:16.830
grid mesh mengisi warna bahkan atau kami tidak benar-benar memprediksi label yang sebenarnya.

118
00:09:17.110 --> 00:09:19.410
Jadi saya akan menunjukkan kepada Anda apa yang saya maksud.

119
00:09:19.410 --> 00:09:21.360
Setelah kita menjalankan fungsinya.

120
00:09:21.750 --> 00:09:25.280
Kemudian kami hanya membentuk kembali berdasarkan grid mesh.

121
00:09:25.280 --> 00:09:32.290
Dan di sini hanya memplot jadi saya plot gambar saya plot mesh warna x x yy z sendiri sama dengan titik

122
00:09:32.290 --> 00:09:37.270
2 sehingga tidak sepenuhnya tertutup itu akan melihat melalui pengaturan peta warna ke jet.

123
00:09:37.270 --> 00:09:43.090
Kemudian saya juga memplot poin pelatihan jadi perhatikan di sini jala warna

124
00:09:43.090 --> 00:09:46.580
berbeda dari plot pelatihan titik itu sendiri.

125
00:09:46.580 --> 00:09:49.730
Tetapkan batas dan kemudian Anda plot batas.

126
00:09:49.730 --> 00:09:53.530
Jadi kita akan melakukan ini untuk pohon sistem dan pada dasarnya apa yang dilakukannya.

127
00:09:53.530 --> 00:09:59.270
Karena ini adalah pohon dosa jika Anda terbiasa melewati pohon sama sekali dari latar belakang ilmu komputer

128
00:09:59.270 --> 00:10:01.830
yang mungkin atau mungkin tidak Anda miliki.

129
00:10:01.830 --> 00:10:04.710
Anda harus melalui pohon biasanya secara rekursif.

130
00:10:04.710 --> 00:10:09.790
Jadi pada dasarnya di sini hanya secara rekursif melewati simpul pohon untuk memplot

131
00:10:09.790 --> 00:10:13.420
batas sehingga Anda dapat melihatnya memanggil fungsi itu sendiri.

132
00:10:13.420 --> 00:10:17.650
Jadi batas plot ada di sini, tetapi fungsi whoops yang sama muncul.

133
00:10:20.170 --> 00:10:24.950
Dan pernyataan kecil tentang intimidasi ini adalah untuk berjaga-jaga jika saya ingin merencanakan kekuatan yang

134
00:10:24.950 --> 00:10:27.070
akan kita bahas nanti di kuliah.

135
00:10:27.070 --> 00:10:32.040
OK jadi silakan luangkan waktu Anda jika Anda tertarik pada bagaimana plot sebenarnya bekerja.

136
00:10:32.040 --> 00:10:37.960
Alasan saya menggunakannya di sini adalah karena itu benar-benar umum untuk melihat dalam dokumentasi psikis yang dipelajari jala

137
00:10:37.960 --> 00:10:38.990
ini hebat.

138
00:10:39.260 --> 00:10:40.660
Jadi apa yang akan saya lakukan sekarang.

139
00:10:40.660 --> 00:10:45.170
Pertama saya akan memperkecil sedikit.

140
00:10:45.170 --> 00:10:46.260
Baiklah.

141
00:10:46.260 --> 00:10:56.200
Dan kemudian saya akan mengatakan classifier saya c lf sama dengan classifier pohon duduk

142
00:10:56.200 --> 00:11:08.750
saya hanya menekan tab sepenuhnya mereka akan memiliki kedalaman maksimal dua dan kemudian mengatakan Amerika acak sama dengan 0.

143
00:11:11.650 --> 00:11:14.920
Dan kemudian saya ingin memvisualisasikan pohon itu lagi.

144
00:11:14.920 --> 00:11:22.040
Saya hanya tab autocomplete di sini melewati classifier saya fitur dan label saya.

145
00:11:25.880 --> 00:11:33.660
OK jadi perhatikan fungsi dasarnya hanya memvisualisasikan segalanya.

146
00:11:33.660 --> 00:11:39.000
Dan alasan kami menggunakan grid mesh sekarang adalah agar kami dapat melihat pohon keputusan benar dan salah.

147
00:11:39.000 --> 00:11:48.920
Jadi dengan kedalaman dua di pohon keputusan Anda terlalu dalam sehingga Anda dapat melihat grid mesh dapat mengisi zona apa

148
00:11:48.920 --> 00:11:51.730
yang pada dasarnya akan dipikirkan.

149
00:11:51.730 --> 00:11:57.250
Sejauh area khusus ini dan grid jala bagaimana itu akan label hal.

150
00:11:57.250 --> 00:12:05.330
Jadi misalnya titik merah ini di sini akan salah diklasifikasikan dan sama dengan titik di sini.

151
00:12:05.330 --> 00:12:10.130
Jadi Anda dapat melihat berdasarkan warna latar belakang apakah Anda akan memiliki klasifikasi yang benar

152
00:12:10.130 --> 00:12:11.420
atau klasifikasi yang salah.

153
00:12:11.420 --> 00:12:17.310
Dan kemudian garis hitam ini hanya mewakili kurang lebih garis perbatasan antara masing-masing zona

154
00:12:17.310 --> 00:12:18.920
atau prediksi ini.

155
00:12:18.920 --> 00:12:28.360
OK jadi sekarang yang akan kita lakukan adalah bertanya siapa yang mengatur langkah maksimal ke 4.

156
00:12:32.180 --> 00:12:34.700
Baiklah apa yang kita dapatkan di sini.

157
00:12:34.700 --> 00:12:40.810
Jadi Anda melihat perubahan kedalaman keputusan menyebabkan batas berubah secara substansial.

158
00:12:40.810 --> 00:12:46.870
Dan jika Anda memperhatikan model kedua Anda bisa melihat bukti overfitting.

159
00:12:46.870 --> 00:12:51.240
Jadi ini pada dasarnya berarti bahwa jika kita mencoba memprediksi titik-titik baru, hasilnya akan

160
00:12:51.240 --> 00:12:53.480
lebih dipengaruhi oleh noise daripada sinyal.

161
00:12:53.480 --> 00:12:59.140
Jadi baterai ini akan semakin kecil dan semakin kecil dan pada akhirnya Anda akan sangat cocok untuk masing-masing

162
00:12:59.840 --> 00:13:00.520
poin ini.

163
00:13:00.520 --> 00:13:07.150
Dengan risiko ketika Anda memiliki titik baru itu akan diambil lebih banyak atau akan lebih dipengaruhi oleh

164
00:13:07.150 --> 00:13:08.420
suara dalam sinyal.

165
00:13:08.420 --> 00:13:17.600
Jadi saya memiliki tautan ke jika kita kembali ke sini ke notebook Jupiter notebook Python Saya memiliki tautan untuk overfitting Anda dapat melanjutkan

166
00:13:17.600 --> 00:13:18.850
dan memeriksanya.

167
00:13:18.850 --> 00:13:24.410
Ini adalah topik yang sangat penting yang dipelajari mesin, jadi saya mendorong Anda untuk memeriksa tautan penjelasan

168
00:13:24.830 --> 00:13:30.540
ini dan yang khusus ini menjelaskan pengambilan keputusan pohon berlebihan yang merupakan masalah umum jika ini bukan pohon.

169
00:13:30.540 --> 00:13:33.380
Jadi, penting untuk mengetahui hal itu dengan benar.

170
00:13:33.380 --> 00:13:37.710
Jadi bagaimana kita mengatasi masalah overfitting dari pohon keputusan tunggal ini.

171
00:13:37.710 --> 00:13:42.630
Jadi jawabannya adalah dengan menciptakan ansambel pohon keputusan yang disebut hutan acak.

172
00:13:42.930 --> 00:13:48.970
Dan itu adalah metode solid yang pada dasarnya rata-rata hasil dari banyak penaksir individu yang

173
00:13:48.970 --> 00:13:55.070
sesuai dengan data dan perkiraan yang dihasilkan terkadang secara mengejutkan jauh lebih kuat dan akurat daripada

174
00:13:55.070 --> 00:13:57.100
perkiraan individu yang membuatnya.

175
00:13:59.130 --> 00:14:05.240
Anda dapat berpikir bahwa ini adalah analogi dengan kebijaksanaan orang banyak yang menebak berapa

176
00:14:05.240 --> 00:14:09.410
kelereng yang ada dalam toples atau berat seseorang.

177
00:14:09.410 --> 00:14:12.810
Jadi mungkin Anda pernah mendengar tentang itu sebelum hikmat istilah orang banyak.

178
00:14:12.810 --> 00:14:16.390
Jika tidak kita sudah membahas ini di posting blog.

179
00:14:16.390 --> 00:14:22.570
Sejauh metode ansambel jadi salah satu metode ansambel yang paling umum dan saya yakin Anda mungkin sudah pernah

180
00:14:22.570 --> 00:14:24.770
mendengar tentang itu di sekitar hutan.

181
00:14:24.770 --> 00:14:31.540
Jadi itu ansambel yang terdiri dari banyak ini ada di pohon-pohon yang dalam beberapa cara berubah.

182
00:14:31.540 --> 00:14:37.430
Jadi yang akan kita lakukan adalah melihat bagaimana kita dapat menggunakannya belajar untuk menciptakan kekuatan acak dan itu sebenarnya

183
00:14:37.430 --> 00:14:38.280
cukup sederhana.

184
00:14:38.620 --> 00:14:48.110
Jadi apa yang akan Anda lakukan adalah membuat kekuatan acak dan Psik itu belajar mengatakan itu dari Eskay

185
00:14:48.960 --> 00:14:51.190
belajar impor sambal.

186
00:14:51.190 --> 00:14:54.280
Dan di sini saya akan mengklik tab untuk melengkapi otomatis.

187
00:14:54.280 --> 00:15:03.010
Pertama kita akan mulai untuk classifier acak keempat semua set classifier saya sama atau di classifier

188
00:15:03.010 --> 00:15:05.340
hutan lagi tab autocomplete.

189
00:15:07.810 --> 00:15:13.380
Dan kemudian saya memiliki parameter ini bukan penaksir garis bawah Jadi itu jumlah penaksir dan bahwa

190
00:15:13.380 --> 00:15:14.120
denda.

191
00:15:14.120 --> 00:15:15.460
Berapa banyak ini di pohon.

192
00:15:15.460 --> 00:15:18.020
Apakah saya ingin dimasukkan ke dalam hutan acak ini.

193
00:15:18.460 --> 00:15:20.510
Dalam hal ini saya akan memasukkan seratus.

194
00:15:20.510 --> 00:15:23.010
Saya akan membicarakan hal ini nanti.

195
00:15:23.010 --> 00:15:30.220
Dan kemudian saya akan menempatkan status acak nol sehingga Anda dapat melanjutkan dan mengikuti saya dengan memasukkan kondisi

196
00:15:30.220 --> 00:15:31.910
acak yang sama.

197
00:15:31.910 --> 00:15:39.040
Dan kemudian apa yang akan saya lakukan adalah memanggil fungsi visualisasi lagi yang memvisualisasikan

198
00:15:39.070 --> 00:15:50.150
menggarisbawahi pohon melihat pass tertawa di fitur saya label saya dan dalam hal ini saya akan melewati batas boolean menjadi palsu kalau tidak

199
00:15:50.150 --> 00:15:56.760
Anda akan dapatkan kesalahan jika mencoba menggambar masing-masing dari garis batas ini dan

200
00:15:56.760 --> 00:15:59.930
Anda akan melihat mengapa dalam sedetik.

201
00:15:59.930 --> 00:16:01.550
Jadi jika saya langsung saja menjalankan ini.

202
00:16:05.180 --> 00:16:10.100
Anda akan melihat bahwa Anda melihat kekuatan acak dapat mengambil fitur yang tidak bisa dilakukan

203
00:16:10.100 --> 00:16:10.790
oleh penjaga.

204
00:16:10.980 --> 00:16:16.390
Tapi sekali lagi Anda harus berhati-hati dengan kekuatan acak juga meskipun tidak sebanyak

205
00:16:16.390 --> 00:16:17.290
pohon keputusan.

206
00:16:17.290 --> 00:16:23.000
Jadi meskipun visualnya bagus, mungkin cara yang lebih baik untuk menilai model Anda tentu saja dengan melakukan tes

207
00:16:23.000 --> 00:16:23.650
split kereta.

208
00:16:23.650 --> 00:16:25.150
Jika Anda memiliki data nyata.

209
00:16:25.150 --> 00:16:30.940
Karena pada dasarnya saya sudah membuat gumpalan ini, Anda bisa pergi dan mencoba melatih test split dan membandingkan pohon

210
00:16:30.940 --> 00:16:36.710
sistem dengan sekitar hutan yang sebenarnya menjadi latihan yang baik untuk Anda lalui sebagai tugas pekerjaan rumah.

211
00:16:36.710 --> 00:16:46.890
Jadi gunakan split tes kereta pada data gumpalan dan lihat perbedaannya.

212
00:16:46.890 --> 00:16:50.690
Ini bukan pohon versus seluruh CROSSFIRE hutan acak.

213
00:16:50.690 --> 00:16:55.010
Dan sesuatu yang ingin saya sebutkan di sini adalah jumlah penaksir ini.

214
00:16:55.010 --> 00:17:02.290
Jadi tergantung pada data Anda, tipe data yang ada di berbagai fitur Anda dan seberapa besar

215
00:17:02.290 --> 00:17:07.030
kumpulan data Anda biasanya berkisar antara 100 hingga 400.

216
00:17:07.880 --> 00:17:13.310
Pohon keputusan individual biasanya cukup untuk penduga pada sampel urin.

217
00:17:13.310 --> 00:17:18.210
Apa pun lebih dari itu dan Anda benar-benar tidak mendapatkan akurasi lebih dan Anda

218
00:17:18.210 --> 00:17:20.490
hanya berusaha Sepi Anda Anda lagi.

219
00:17:20.490 --> 00:17:26.440
Fitur lain dari ensemble hutan acak adalah bahwa seperti yang kita bahas dalam posting blog

220
00:17:26.440 --> 00:17:34.250
masing-masing pohon keputusan ini tidak bergantung pada yang lain sehingga sebenarnya merupakan teknik model yang bagus untuk mengetahui apakah Anda

221
00:17:34.250 --> 00:17:40.350
memiliki akses ke komputasi terdistribusi karena Anda dapat meletakkan beberapa penduga pada satu komputer dan

222
00:17:40.350 --> 00:17:47.070
mendistribusikan beberapa lainnya ini di pohon di lain dan kemudian mengambil ansambel setelah mereka semua selesai memproses

223
00:17:47.070 --> 00:17:49.040
setiap pohon keputusan individu.

224
00:17:49.040 --> 00:17:49.810
Baiklah.

225
00:17:50.060 --> 00:17:56.890
Jadi yang terakhir yang ingin saya bicarakan adalah agresi kehutanan acak sehingga kita dapat menggunakan kekuatan acak untuk

226
00:17:57.260 --> 00:17:59.560
regresi sebagaimana kita bisa untuk klasifikasi.

227
00:17:59.560 --> 00:18:05.380
Jadi ini adalah contoh yang sangat menarik dan yang akan kita lakukan adalah membayangkan kita memiliki semacam data cuaca

228
00:18:05.420 --> 00:18:11.160
yang menandakan Anda tanah di alam dan memiliki beberapa kebisingan untuk itu dan memiliki komponen osilasi lambat.

229
00:18:11.160 --> 00:18:15.580
Komponen osilasi cepat dan kemudian komponen derau acak.

230
00:18:15.580 --> 00:18:19.770
Jadi hal pertama yang harus dilakukan adalah membuat data palsu ini.

231
00:18:19.770 --> 00:18:30.260
Saya akan mengatakan X sama dengan 10 dikalikan dengan katakanlah AP yang menjalankan Rams.

232
00:18:30.260 --> 00:18:34.990
Jadi di sini saya punya X saya yang hanya sekelompok angka acak itu 100 angka acak.

233
00:18:39.610 --> 00:18:47.820
Jadi yang bisa saya lakukan sekarang adalah membuat fungsi yang pada dasarnya akan membuat kesalahan ini, saya tahu sangat sedikit data

234
00:18:47.820 --> 00:18:49.040
untuk saya.

235
00:18:49.040 --> 00:18:58.100
Jadi saya membuat fungsi yang disebut model tanda dan biarkan saya memperbesar fungsi yang Anda bisa melihatnya dengan baik.

236
00:18:58.100 --> 00:19:06.250
Saya akan mengatakan def dari model yang ditandatangani dan saya akan mengambil dua parameter x dan beberapa parameter Sigma yang akan menjadi

237
00:19:06.250 --> 00:19:11.490
noise dalam hal ini saya hanya akan menetapkan standar sama dengan titik 2.

238
00:19:11.490 --> 00:19:14.620
Benar-benar terserah Anda karena ini hanya akan menjadi suara acak.

239
00:19:14.620 --> 00:19:16.110
Saya akan membuat istilah kebisingan.

240
00:19:17.800 --> 00:19:27.570
Saya akan mengambil komponen Sigma dan mengalikannya dengan beberapa angka acak.

241
00:19:27.570 --> 00:19:29.540
Panjang x.

242
00:19:29.540 --> 00:19:32.790
Buat sedikit fleksibel jika kita memutuskan untuk mengganti x.

243
00:19:32.790 --> 00:19:35.510
Saya hanya bisa memasukkan 100 di sana juga.

244
00:19:35.600 --> 00:19:42.520
Dan kemudian akan mengembalikan beberapa komponen sinus jadi saya akan membuat komponen

245
00:19:42.520 --> 00:19:47.890
yang pertama ini lebih lambat seperti 5 kali x.

246
00:19:47.890 --> 00:19:50.410
Saya akan membuat tanda lain menggunakan komponen oli.

247
00:19:50.410 --> 00:19:54.250
Itu sedikit lebih cepat dalam pergumulan Jadi nol koma lima kali X

248
00:19:57.050 --> 00:19:59.560
dan kemudian saya akan menambahkan komponen kebisingan.

249
00:20:01.230 --> 00:20:02.690
Baiklah.

250
00:20:02.690 --> 00:20:05.290
Jadi itulah fungsi model tanda kecil.

251
00:20:05.290 --> 00:20:10.030
Yah pada dasarnya membuat atau memalsukan data untuk kita jadi mari kita lanjutkan dan panggil dan

252
00:20:10.030 --> 00:20:18.010
lihat seperti apa itu semua diatur sama dengan menandatangani model dan meneruskan X. Kami berhasil dan kemudian saya akan merencanakan

253
00:20:18.010 --> 00:20:21.680
bahwa saya akan mengatakan mengupas angka.

254
00:20:21.680 --> 00:20:24.890
Mari kita pada ukuran ara sebenarnya sebelum kita mengatur ukuran gambar.

255
00:20:24.890 --> 00:20:30.150
Mari kita lanjutkan dan plot keluar dan kemudian kita akan melihat apakah ukuran gambarnya OK.

256
00:20:30.150 --> 00:20:32.030
Saya akan menggunakan figur bar udara.

257
00:20:32.490 --> 00:20:39.500
Hanya untuk menunjukkan tren yang sedikit lebih baik ini tidak perlu istilah ini di sini adalah nol koma satu

258
00:20:39.500 --> 00:20:43.220
hanya akan menentukan seberapa besar kesalahan bar akan menjadi.

259
00:20:43.220 --> 00:20:46.150
Jadi kami tidak benar-benar memiliki kesalahan dalam kumpulan data kami.

260
00:20:46.150 --> 00:20:47.400
Agak dibuat-buat.

261
00:20:49.730 --> 00:20:52.570
OK jadi begitulah.

262
00:20:52.570 --> 00:21:01.530
Mari kita pergi ke depan dan sekarang mengatur ukuran tetap menjadi sedikit lebih lama melihat katakanlah teh kulit yang mencari

263
00:21:02.590 --> 00:21:06.000
ukuran ara dan mari kita mungkin saja.

264
00:21:06.000 --> 00:21:08.390
Mari kita lihat seperti apa 10 dengan delapan.

265
00:21:08.390 --> 00:21:12.400
Jika terlihat sedikit lebih baik, itu sedikit lebih memanjang.

266
00:21:12.400 --> 00:21:20.100
Jadi Anda dapat melihat di sini dan jika saya mengubah bilah kesalahan ini saya akan membuat bilah galat sedikit lebih menonjol.

267
00:21:20.100 --> 00:21:24.860
Tetapi Anda dapat melihat bahwa ada tanda pola tanah Anda, Anda dapat melihat bahwa ada osilasi yang

268
00:21:24.860 --> 00:21:27.730
lebih cepat dari yang saya ikuti di sepanjang mouse saya.

269
00:21:27.730 --> 00:21:32.830
Dan Anda akan melihat bahwa tren umum kurva ini lebih besar jika kita menggambar semacam di

270
00:21:32.830 --> 00:21:37.390
tengah semua ini adalah osilasi yang jauh lebih lambat dari lima kali tanda itu.

271
00:21:37.390 --> 00:21:44.730
Jadi sebagai bagian dari situs yang jauh lebih besar Anda melihatnya akan berosilasi OK.

272
00:21:45.670 --> 00:21:50.260
Jadi sekarang kita akan menggunakan regresi kekuatan acak atau untuk membuat regresi pas.

273
00:21:51.640 --> 00:21:55.820
Anda dapat memikirkan hal ini dengan semacam data cuaca, pola cuaca kita mungkin seperti tingkat karbon

274
00:21:55.820 --> 00:21:57.950
dioksida di atmosfer atau sesuatu seperti itu.

275
00:21:57.950 --> 00:22:02.860
Anda tidak akan dapat menggunakan ini seperti pendekatan regresi linier standar dan

276
00:22:02.860 --> 00:22:08.850
jika Anda tidak benar-benar tahu apa-apa tentang sifat sebenarnya dari model itu akan sulit untuk cocok

277
00:22:08.850 --> 00:22:14.140
dengan polinomial atau sinus Anda regresi tanah sehingga cukup membosankan untuk coba pas di sini.

278
00:22:14.140 --> 00:22:18.350
Tetapi yang menyenangkan tentang represor gaya acak adalah Anda benar-benar dapat mengetahui sedikit

279
00:22:18.350 --> 00:22:22.780
tentang sifat sebenarnya dari data Anda dan masih dapat menyesuaikan model Rusia kami dengannya.

280
00:22:22.780 --> 00:22:28.690
Jadi itulah yang benar-benar keren tentang regresi hutan.

281
00:22:28.690 --> 00:22:33.070
Jadi ketika orang berpikir tentang hutan acak digunakan untuk menganggapnya sebagai teknik

282
00:22:33.380 --> 00:22:38.210
klasifikasi dan itu mungkin lebih umum digunakan sebagai teknik klasifikasi dalam praktik ilmu data standar.

283
00:22:38.210 --> 00:22:40.530
Tapi itu juga teknik regresi yang sangat kuat.

284
00:22:44.290 --> 00:22:51.480
Jadi apa yang akan saya lakukan di sini adalah membuat beberapa x poin x pas.

285
00:22:51.480 --> 00:22:53.920
Silakan aku seribu dari mereka.

286
00:22:53.920 --> 00:22:57.620
Mari kita sebut model regresi hutan acak kami jauh dan saya

287
00:23:00.250 --> 00:23:03.730
harus mengimpornya jadi mari kita lanjutkan dan lakukan itu.

288
00:23:03.730 --> 00:23:18.850
Katakanlah dari skala belajar bahwa impor sambal berada di agresor kehutanan OK dan sekarang jauh sama dengan kita di tab penyulingan hutan di

289
00:23:18.850 --> 00:23:26.190
luar jangkauan lengkap tentu saja penahan. Argumen pertama adalah jumlah penduga

290
00:23:26.190 --> 00:23:30.950
saya hanya akan melewati dalam 100.

291
00:23:31.600 --> 00:23:33.590
Dan kemudian saya

292
00:23:36.720 --> 00:23:41.920
akan menyesuaikan model dengan data x asli yang ada di sini.

293
00:23:41.920 --> 00:23:42.550
Data

294
00:23:46.900 --> 00:23:50.320
ini diformat dalam format yang benar.

295
00:23:50.320 --> 00:23:53.320
Saya akan menyampaikannya seperti ini.

296
00:23:53.320 --> 00:24:02.810
Bersamaan dengan istilah y dan kemudian saya akan mengatakan istri saya cocok dengan persyaratan.

297
00:24:05.130 --> 00:24:10.720
Sama dengan prediksi yang didasarkan pada syarat keluar.

298
00:24:18.250 --> 00:24:18.600
Baiklah.

299
00:24:18.600 --> 00:24:23.620
Jadi kami menjalankan model regresi kami dan kami memasangnya kemudian menetapkan beberapa istilah prediksi.

300
00:24:23.620 --> 00:24:31.760
Jadi saat ini kami memiliki istilah x di sini, apa pun 0 hingga 10 adalah ketentuan kami yang sesuai, persyaratan Truax dan kemudian

301
00:24:32.400 --> 00:24:38.630
apa yang kami lakukan juga karena perlu diingat bahwa kami sedang melakukan regresi di sini, benar.

302
00:24:38.630 --> 00:24:41.280
Itu sebabnya saya bisa mengatakan 1000 poin di sini.

303
00:24:41.280 --> 00:24:47.110
Jadi kita akan mundur sepanjang seribu poin dengan ini adalah penampung dari data aktual.

304
00:24:47.430 --> 00:24:54.590
Jadi saya bisa mengambil istri saya yang cocok dengan data yang saya tidak tahu dan kemudian memprediksi data yang saya tidak tahu

305
00:24:54.590 --> 00:24:56.600
yang mana data yang cocok X.

306
00:24:56.600 --> 00:25:01.040
Sehingga 1000 poin versus pas pada 100 poin.

307
00:25:01.040 --> 00:25:02.980
Semoga itu masuk akal.

308
00:25:02.980 --> 00:25:03.400
Baiklah.

309
00:25:03.400 --> 00:25:06.930
Jadi mari kita lanjutkan dan merencanakan ini dan melihat seperti apa bentuknya.

310
00:25:06.930 --> 00:25:10.810
Jadi sesuatu yang sangat menarik adalah untuk

311
00:25:10.810 --> 00:25:26.000
merencanakannya melawan model yang sebenarnya karena kita benar-benar mengetahui model yang sebenarnya sehingga saya dapat melihat mengapa true sama dengan Model X cocok sepanjang nol karena ingat permisi.

312
00:25:26.000 --> 00:25:27.530
Jadi daftarkan saya.

313
00:25:31.070 --> 00:25:34.140
Jadi kami memiliki model yang sama di sini.

314
00:25:34.140 --> 00:25:38.860
Itulah nilai-nilai kebenaran putih.

315
00:25:38.860 --> 00:25:48.730
Jadi jika kita gulir kembali ke atas, kita dapat melihat bahwa model tanda saya hanya menyampaikan sigma nol di sini.

316
00:25:48.730 --> 00:25:50.040
BAIK.

317
00:25:50.040 --> 00:25:55.420
Jadi, Anda memiliki benar putih dan kemudian apa yang akan saya lakukan adalah pergi dan merencanakan angka.

318
00:25:55.420 --> 00:26:04.060
Jadi saya hanya akan membuat plot error bar dengan xy.

319
00:26:04.060 --> 00:26:08.590
Mari kita letakkan Point 1 untuk bilah kesalahan itu.

320
00:26:08.590 --> 00:26:17.740
Dan 0 0 0 kecil ini hanya singkatan dari apa yang tampak seperti pusat kesalahan.

321
00:26:17.740 --> 00:26:22.120
Dan kemudian yang akan kita lakukan adalah memasukkan data yang sudah terpasang.

322
00:26:22.120 --> 00:26:30.510
Saya akan menempatkan yang pertama ini sebagai garis merah sebenarnya hanya akan dibaca garis padat. Saya hanya meletakkannya di

323
00:26:30.510 --> 00:26:33.210
sana dan kemudian mengisi t plot.

324
00:26:33.210 --> 00:26:37.600
Mari kita merencanakan X fit vs. yang benar.

325
00:26:43.660 --> 00:26:48.430
Jadi perlu diingat ini adalah regresi.

326
00:26:48.430 --> 00:26:50.750
Mari kita pergi ke depan dan menjalankan setelan itu seperti apa.

327
00:26:50.750 --> 00:26:51.930
BAIK.

328
00:26:51.930 --> 00:26:52.820
Luar biasa.

329
00:26:52.820 --> 00:26:56.250
Mari kita keluar dan mengubah ukuran gambar sehingga kita bisa menganalisanya sedikit lagi.

330
00:26:56.840 --> 00:26:59.180
Dan saya katakan mohon pada sosok itu.

331
00:27:00.800 --> 00:27:02.560
Mari kita lihat apakah saya bisa.

332
00:27:02.560 --> 00:27:05.390
Apa yang terjadi jika saya membuatnya cukup besar jika kita dapat memperbesar.

333
00:27:09.810 --> 00:27:14.220
Tapi dengan enam mata melihatku.

334
00:27:14.220 --> 00:27:15.940
OK keren.

335
00:27:15.940 --> 00:27:17.540
Jadi apa yang kita miliki di sini.

336
00:27:17.540 --> 00:27:19.680
Kami memiliki poin data asli kami.

337
00:27:19.680 --> 00:27:21.510
Anda bisa melihatnya di sini.

338
00:27:21.510 --> 00:27:24.650
Garis yang bagus ini agak sulit dilihat.

339
00:27:24.650 --> 00:27:25.410
Biarkan saya memperbesar.

340
00:27:27.420 --> 00:27:35.170
Oh well, itu mengubah ukuran ketakutan karena itu notebook pintar, jadi kami memperbesar di sini dan kami melihat titik data dari

341
00:27:35.440 --> 00:27:41.820
data apa pun yang kami coba cocokkan dengan garis abu-abu ini yang merupakan data yang benar.

342
00:27:41.820 --> 00:27:49.560
Kami melewati kemudian untuk garis abu-abu putih benar yang merupakan data X dipasang ke model tanpa Sigma tidak

343
00:27:49.560 --> 00:27:50.540
ada suara.

344
00:27:50.540 --> 00:27:54.850
Jadi sepatu putih ini pada dasarnya hanyalah dua istilah ini.

345
00:27:54.850 --> 00:28:01.240
Jika kita naik ke sini, ini hanya angka yang tepat. Saya menandatangani Sloss lation, menolak lemak dan

346
00:28:01.270 --> 00:28:02.760
ditambah osilasi cepat.

347
00:28:02.760 --> 00:28:06.580
Jadi itu hanya tambahan dari kedua istilah sinus itu.

348
00:28:06.830 --> 00:28:09.120
Jadi Poin Biru memiliki sedikit kebisingan pada mereka.

349
00:28:09.120 --> 00:28:13.460
Dan kemudian apa yang gila super menarik adalah garis regresi merah ini.

350
00:28:13.460 --> 00:28:21.010
Lihat seberapa baik kecocokan. Ini mempertimbangkan bahwa kita tidak benar-benar tahu atau mengatakan apa pun tentang data kita sehingga

351
00:28:21.010 --> 00:28:26.830
penyerang kehutanan acak tidak tahu apakah ada tanda yang Anda lihat. Semua akan tahu.

352
00:28:26.830 --> 00:28:33.710
Sedangkan poin yang kami berikan dan masih bisa muncul dengan pola yang sangat mirip dengan data

353
00:28:33.710 --> 00:28:35.010
nyata dan benar.

354
00:28:35.010 --> 00:28:39.850
Jadi jika Anda perhatikan di sini gagal, kami hanya memiliki dua titik data di sini.

355
00:28:39.850 --> 00:28:41.580
Jadi itu sudah cukup bagus.

356
00:28:43.840 --> 00:28:49.810
Jadi Anda dapat melihat bahwa model gaya ram non-parametrik ini cukup fleksibel untuk disesuaikan dengan data

357
00:28:49.940 --> 00:28:56.290
multi periode tanpa kami bahkan menentukan bahwa itu adalah model multi periode yang memiliki komponen osilasi Cepat

358
00:28:56.290 --> 00:28:57.560
dan Lambat untuknya.

359
00:28:57.890 --> 00:29:04.040
Jadi ini jelas merupakan pertukaran antara kesederhanaan model ini dan berpikir tentang

360
00:29:04.040 --> 00:29:06.640
seperti apa data Anda sebenarnya.

361
00:29:06.640 --> 00:29:13.890
Jika kita kembali ke buku catatan Jupiter. Ini sebenarnya adalah akhir dari kuliah ini, jadi saya ingin menunjukkan beberapa sumber

362
00:29:13.890 --> 00:29:17.250
hebat lainnya untuk belajar lebih banyak tentang kekuatan acak.

363
00:29:17.250 --> 00:29:23.100
Dan kuliah ini kita agak baru saja membahas mekanisme penerapannya dalam mempelajari Python

364
00:29:23.100 --> 00:29:25.330
yang sebenarnya relatif sederhana.

365
00:29:25.330 --> 00:29:28.150
Seperti yang Anda lihat ini bukan pengkhianatan di sekitar pasukan.

366
00:29:28.150 --> 00:29:31.280
Mungkin akan ada terlalu banyak waktu ketika Anda akan mengimplementasikan sesuatu dari pohon

367
00:29:31.280 --> 00:29:34.170
sistem dengan sendirinya alih-alih di sekitar hutan tetapi Anda tidak pernah tahu.

368
00:29:34.520 --> 00:29:37.510
Jadi ada artikel luas di Wikipedia.

369
00:29:37.510 --> 00:29:43.370
Sebenarnya ada lebih banyak untuk dibaca tentu saja sejauh perkembangan berlanjut dari ide gaya

370
00:29:43.370 --> 00:29:45.620
acak seperti Ada boost.

371
00:29:46.700 --> 00:29:48.560
Siapa yang mendukungnya.

372
00:29:48.560 --> 00:29:51.560
Kami membahasnya sedikit di posting blog.

373
00:29:51.560 --> 00:29:56.170
Jadi silakan dan lihat kekuatan acak halaman wiki pedia halaman ton informasi

374
00:29:56.170 --> 00:30:01.530
di sini dan ada baiknya untuk memahami ide-ide dasar di balik matematika dari sekitar model hutan.

375
00:30:01.530 --> 00:30:03.410
Ada juga gambaran bagus di sini.

376
00:30:03.410 --> 00:30:09.670
Jika Anda mengeklik tautan ini ke tinjauan umum kasual di sekitar hutan dan jika Anda mengetahui pahlawan, sebutkan itu

377
00:30:09.670 --> 00:30:12.330
adalah terminal merek dagang yang membicarakannya dalam sedetik.

378
00:30:12.330 --> 00:30:17.320
Tapi itu bagus karena itu juga berbicara tentang perbedaan antara pohon keputusan tunggal dan

379
00:30:17.320 --> 00:30:20.450
di sekitar hutan dan bagaimana itu menghindari overfitting.

380
00:30:20.450 --> 00:30:24.710
Dan apa yang benar-benar keren adalah itu menghubungkan Anda ke beberapa kompetisi

381
00:30:25.030 --> 00:30:30.350
yang menggunakan kekuatan sehingga Anda dapat memeriksa sendiri dan melihat apakah Anda dapat mereplikasi hasil.

382
00:30:30.350 --> 00:30:37.230
Dan akhirnya ini mungkin tautan yang paling penting adalah di sini ada seluruh halaman web oleh Leo

383
00:30:37.230 --> 00:30:43.650
dan Adele atau Adele dan saya tidak tahu bagaimana Anda mengatakan nama penemu kekuatan acak.

384
00:30:43.650 --> 00:30:50.720
Jadi itu sebenarnya adalah merek dagang oleh mereka dan mereka adalah penemu dan mereka memiliki seluruh halaman web yang sangat menyeluruh ini untuk

385
00:30:51.130 --> 00:30:56.020
menjalankannya, jadi saya mendorong Anda jika Anda tertarik pada segala sesuatu yang perlu diketahui tentang

386
00:30:56.020 --> 00:30:57.150
dia di kepolisian.

387
00:30:57.150 --> 00:31:04.270
Anda cukup memeriksanya dari pencipta sendiri di halaman web ini di stat dot Berkeley dot edu.

388
00:31:04.270 --> 00:31:05.360
BAIK.

389
00:31:05.360 --> 00:31:10.240
Jadi terima kasih banyak untuk melihat kuliah tentang pengkhianatan sistem di sekitar kepolisian.

390
00:31:10.240 --> 00:31:15.380
Sekali lagi sebagian besar struktur kami hanya membahas mekanisme bagaimana menerapkan dan menerapkannya

391
00:31:15.410 --> 00:31:17.990
dalam Python sikat yang cukup mudah.

392
00:31:18.160 --> 00:31:23.010
Jika Anda hanya ingin ikhtisar yang sangat mendasar tentang kepolisian, pastikan dia membaca posting blog yang

393
00:31:23.010 --> 00:31:25.780
saya buat sebelum Anda datang ke kuliah ini.

394
00:31:25.780 --> 00:31:28.880
Jadi, Anda memiliki beberapa tingkat pemahaman tentang apa yang kami lakukan di sini.

395
00:31:29.130 --> 00:31:31.190
Dan kemudian jika Anda ingin menyelam.

396
00:31:31.190 --> 00:31:34.470
Saya tidak bisa merekomendasikan itu lagi.

397
00:31:34.470 --> 00:31:40.040
Ambil sendiri dari penciptanya di bagian pendahuluan, ikhtisar dan cara kerjanya serta

398
00:31:40.040 --> 00:31:42.210
semua fitur kekuatan acak.

399
00:31:42.210 --> 00:31:44.320
OK terima kasih banyak.
