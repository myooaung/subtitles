WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:06.260
in this little driver house on quick understanding on how we go about designing a database

00:00:06.260 --> 00:00:06.260
.

00:00:06.260 --> 00:00:11.220
We're also going to go through some of the good practices we can follow to make sure that

00:00:11.220 --> 00:00:16.610
the data in the data base is maintained inconsistent manner and that there no do will get

00:00:16.610 --> 00:00:19.770
interest scattered across multiple tables in the database.

00:00:19.770 --> 00:00:25.110
So the first thing that into consider while designing a database is to have a thorough

00:00:25.110 --> 00:00:30.520
understanding on all the requirements for your application and then try to visualize all

00:00:30.520 --> 00:00:34.770
the real time transactions that are going to take place in your application.

00:00:34.770 --> 00:00:36.950
The role of the database in it,

00:00:36.950 --> 00:00:37.850
etcetera.

00:00:37.850 --> 00:00:42.740
You would basically try to understand where those kinds off crowd operations you would

00:00:42.740 --> 00:00:46.030
perform on your database for your application needs.

00:00:46.030 --> 00:00:49.150
And this is a phase where you could make or break things.

00:00:49.150 --> 00:00:53.750
Because if you're not careful enough in understanding their comments thoroughly,

00:00:53.750 --> 00:00:59.880
then that's going to cost you a lot at later point off time in your project,

00:00:59.880 --> 00:01:05.770
in terms off time spent as well as a number off resources required to fix day shows.

00:01:05.770 --> 00:01:11.020
So you need to be very careful in understanding the requirements and then you'll try to

00:01:11.020 --> 00:01:15.820
visualize the database fiscal in your brain.

00:01:15.820 --> 00:01:18.270
So once you're done with that,

00:01:18.270 --> 00:01:21.550
once you have a clear picture on how the application works,

00:01:21.550 --> 00:01:24.850
you would come up with a list off tables for your application.

00:01:24.850 --> 00:01:28.090
As an example for a school management application,

00:01:28.090 --> 00:01:31.260
you may be having all these list off tables.

00:01:31.260 --> 00:01:32.400
We have students,

00:01:32.400 --> 00:01:33.120
table teachers,

00:01:33.120 --> 00:01:34.200
stable courses,

00:01:34.200 --> 00:01:35.000
etcetera,

00:01:35.000 --> 00:01:37.470
and once you're satisfied with that,

00:01:37.470 --> 00:01:41.100
you can move on with the next phase where you would try toe,

00:01:41.100 --> 00:01:43.220
create a relation scheme off a region,

00:01:43.220 --> 00:01:46.840
every individual relation or tables in your database.

00:01:46.840 --> 00:01:48.090
For example,

00:01:48.090 --> 00:01:53.950
we have this picture here which have picked from one awful previous documents.

00:01:53.950 --> 00:01:56.470
We've already talked about this diagram,

00:01:56.470 --> 00:02:00.850
So each and every individual block you're seeing here is the relation schema.

00:02:00.850 --> 00:02:02.230
So you were thought off.

00:02:02.230 --> 00:02:03.840
Create all these relations,

00:02:03.840 --> 00:02:05.800
scheme us along with their constraints,

00:02:05.800 --> 00:02:06.460
for example,

00:02:06.460 --> 00:02:08.500
to take a look at this relations.

00:02:08.500 --> 00:02:09.500
Chema marks.

00:02:09.500 --> 00:02:14.240
We see that the mark Heidi is marked as the primary key,

00:02:14.240 --> 00:02:16.900
and then we got a couple off foreign keys as well.

00:02:16.900 --> 00:02:22.680
Similarly would try to figure out a list of constraints that can be part off each and every

00:02:22.680 --> 00:02:23.950
individual table,

00:02:23.950 --> 00:02:24.980
for example,

00:02:24.980 --> 00:02:26.290
for students table,

00:02:26.290 --> 00:02:32.250
the student idea is going to be the primary key email and phone number has to have a unique

00:02:32.250 --> 00:02:35.000
constraint like wells for quarters stable,

00:02:35.000 --> 00:02:37.210
you would have course ideas the primary key,

00:02:37.210 --> 00:02:41.150
and you may have student ideas form key etcetera.

00:02:41.150 --> 00:02:43.570
And once you're done with that face,

00:02:43.570 --> 00:02:46.940
then you would ultimately create the big picture,

00:02:46.940 --> 00:02:48.210
the entire database.

00:02:48.210 --> 00:02:55.470
But connecting all these relations key mass with these connectors and that the relations

00:02:55.470 --> 00:03:02.420
between them could be anyone off these oneto one relations one too many relation or many to

00:03:02.420 --> 00:03:03.430
many relation.

00:03:03.430 --> 00:03:06.080
We've talked about all this street we've actually taken.

00:03:06.080 --> 00:03:12.570
Look at some of the examples for all these three nor previous videos and bears down that

00:03:12.570 --> 00:03:19.800
you would design a database schema that looks something like this and notice that one too

00:03:19.800 --> 00:03:20.620
many has,

00:03:20.620 --> 00:03:21.030
Ah,

00:03:21.030 --> 00:03:23.350
the symbol that looks like three spikes.

00:03:23.350 --> 00:03:25.950
We talked about it as well,

00:03:25.950 --> 00:03:31.450
and then once you have this entire database schema,

00:03:31.450 --> 00:03:36.880
you would then conduct a meeting with your customers are with the developers,

00:03:36.880 --> 00:03:37.670
etcetera,

00:03:37.670 --> 00:03:40.900
and then you would discuss out what's happening in here,

00:03:40.900 --> 00:03:43.950
take their input and possibly make some changes in here,

00:03:43.950 --> 00:03:44.650
etcetera.

00:03:44.650 --> 00:03:50.870
So you would basically go through all this for a second and again until we have a very

00:03:50.870 --> 00:03:58.150
mature database schema that we can finally finalize to bring it to implementation.

00:03:58.150 --> 00:04:02.600
So that's about designing the database.

00:04:02.600 --> 00:04:06.780
And then we have some of the good practices,

00:04:06.780 --> 00:04:12.550
which are sometimes termed as normalization is a set off techniques that you can follow.

00:04:12.550 --> 00:04:17.380
These are actually the techniques that are tried and experimented on the relation database

00:04:17.380 --> 00:04:23.620
by many people to make sure that the data has maintained in a consistent manner across the

00:04:23.620 --> 00:04:24.410
database.

00:04:24.410 --> 00:04:26.890
So the principal off first normal farm,

00:04:26.890 --> 00:04:29.920
or sometimes referred as one enough say,

00:04:29.920 --> 00:04:33.360
is that a relation must have a primary key,

00:04:33.360 --> 00:04:35.890
which uniquely identifies each row.

00:04:35.890 --> 00:04:37.800
And as a good convention,

00:04:37.800 --> 00:04:42.780
we always choose the i D field as the primary key.

00:04:42.780 --> 00:04:49.320
And the reason by winter do society is for the very reason to make it a primary key for

00:04:49.320 --> 00:04:51.650
each and every individual table are.

00:04:51.650 --> 00:04:52.400
Alternatively,

00:04:52.400 --> 00:04:53.100
as we discussed,

00:04:53.100 --> 00:04:57.840
we can also have multiple attributes are multiple columns together,

00:04:57.840 --> 00:05:01.400
be a primary key as well as you wish,

00:05:01.400 --> 00:05:07.770
and the rule of first normal form states that every collonville store atomic value,

00:05:07.770 --> 00:05:09.800
and there are no repeated groups.

00:05:09.800 --> 00:05:10.630
For example,

00:05:10.630 --> 00:05:14.270
if you take a look at the stable in here in the column,

00:05:14.270 --> 00:05:18.730
courses were trying to store multiple values like,

00:05:18.730 --> 00:05:19.660
for example,

00:05:19.660 --> 00:05:26.010
the students under has registered for Java and ESPN were separating those two courses with

00:05:26.010 --> 00:05:27.900
this coma character.

00:05:27.900 --> 00:05:29.490
This is not,

00:05:29.490 --> 00:05:30.720
I mean,

00:05:30.720 --> 00:05:37.020
this table is not following the first normal form in the scales because it says a column

00:05:37.020 --> 00:05:38.630
bill store atomic value,

00:05:38.630 --> 00:05:41.150
which means we should have only one value,

00:05:41.150 --> 00:05:43.230
not the way you're seeing here.

00:05:43.230 --> 00:05:48.280
This is going to cause some problems because at later point of time,

00:05:48.280 --> 00:05:52.060
if Sunder decides to choose another course,

00:05:52.060 --> 00:05:54.250
or if he was done with one off the course,

00:05:54.250 --> 00:05:58.060
then we need to make updates to the sentry in the stable,

00:05:58.060 --> 00:05:59.450
which is quite tedious.

00:05:59.450 --> 00:06:02.720
You would get to know it once you start using the database.

00:06:02.720 --> 00:06:05.170
If you use database before then,

00:06:05.170 --> 00:06:09.240
you would certainly know the importance off maintaining atomic values and columns.

00:06:09.240 --> 00:06:12.060
If you didn't use the database before then,

00:06:12.060 --> 00:06:14.780
just believe in what others have tried and experimented.

00:06:14.780 --> 00:06:19.760
He never supposed to have values like this is supposed to have only one atomic value,

00:06:19.760 --> 00:06:21.540
but If there is a case,

00:06:21.540 --> 00:06:23.380
how are we going to represent that?

00:06:23.380 --> 00:06:27.240
Sunder is actually registered with multiple courses.

00:06:27.240 --> 00:06:29.750
I'm going to talk about the solution in a second,

00:06:29.750 --> 00:06:35.520
but here is another example off a table that is not following the first normal form.

00:06:35.520 --> 00:06:40.080
You're not supposed to have repeated groups like this,

00:06:40.080 --> 00:06:40.860
for example,

00:06:40.860 --> 00:06:44.380
for each and every individual course have introduced a new column,

00:06:44.380 --> 00:06:46.930
and I'm setting the flag in the scare.

00:06:46.930 --> 00:06:49.470
Soon there has registered for Java and GSB,

00:06:49.470 --> 00:06:51.960
and he didn't register for SQL and DB.

00:06:51.960 --> 00:06:55.850
Emma's John has registered for DBM misson sq,

00:06:55.850 --> 00:06:58.220
but not for Java and GSP.

00:06:58.220 --> 00:07:02.370
Now this is definitely bad practice because at little one of time,

00:07:02.370 --> 00:07:04.350
if you wanted to introduce another course,

00:07:04.350 --> 00:07:07.090
then you would end up adding a new column in here.

00:07:07.090 --> 00:07:10.030
And that's going to bring a lot of complexity.

00:07:10.030 --> 00:07:10.840
And in fact,

00:07:10.840 --> 00:07:16.640
it may result in actually changing the logic Gassville the application logic to make it

00:07:16.640 --> 00:07:17.950
work with new changes.

00:07:17.950 --> 00:07:18.970
Basically,

00:07:18.970 --> 00:07:20.180
as a rule of thumb,

00:07:20.180 --> 00:07:25.920
it should always minimize the need to change this actual structure of the database.

00:07:25.920 --> 00:07:31.340
You don't want to change the definition off the database are the tables,

00:07:31.340 --> 00:07:33.580
so to solve these two problems.

00:07:33.580 --> 00:07:38.070
We have a solution which is basically what we have used so far.

00:07:38.070 --> 00:07:39.250
In our examples.

00:07:39.250 --> 00:07:47.050
You introduce another table that looks like this and you try to map the tables.

00:07:47.050 --> 00:07:52.540
And here we can say that Student one has a district for courses one and two,

00:07:52.540 --> 00:07:53.890
and similarly,

00:07:53.890 --> 00:07:58.750
a single course one has been registered by these two students one and two.

00:07:58.750 --> 00:08:01.350
This is many to many relationship.

00:08:01.350 --> 00:08:04.080
Similarly,

00:08:04.080 --> 00:08:05.770
we have second normal form as well,

00:08:05.770 --> 00:08:12.200
and it stays that all the non key columns should be fully dependent on the primary key.

00:08:12.200 --> 00:08:17.160
Even if the primary key is made up off several columns or,

00:08:17.160 --> 00:08:18.190
in other words,

00:08:18.190 --> 00:08:23.900
every non key Colin shall depend entirely on the primary keys and not part off it.

00:08:23.900 --> 00:08:28.480
I'll try to give an example from this from the stables itself.

00:08:28.480 --> 00:08:30.750
If you take a look at the stable,

00:08:30.750 --> 00:08:33.650
we're trying to associate the fee with a student,

00:08:33.650 --> 00:08:35.520
while should we really do that?

00:08:35.520 --> 00:08:38.010
It actually depends on your application needs,

00:08:38.010 --> 00:08:45.160
but we can actually move this fee column from here to this table student course stable,

00:08:45.160 --> 00:08:48.450
and then we can say student one register for,

00:08:48.450 --> 00:08:49.230
Of course,

00:08:49.230 --> 00:08:52.650
one and then he paid a certainty again,

00:08:52.650 --> 00:08:54.520
stood in to register for course one,

00:08:54.520 --> 00:08:55.980
and he paid a certainty.

00:08:55.980 --> 00:08:59.860
And if we choose these two columns as the primary key,

00:08:59.860 --> 00:09:07.400
then we can say that the fee column is actually dependent on this too student as well as

00:09:07.400 --> 00:09:08.660
the course I D.

00:09:08.660 --> 00:09:10.550
But not part off it.

00:09:10.550 --> 00:09:15.330
That means the fee column is actually fully dependent on the primary key.

00:09:15.330 --> 00:09:19.840
It's not dependent solely on the student I D or the core society,

00:09:19.840 --> 00:09:25.500
but it is dependent on combination off this to the full primary key,

00:09:25.500 --> 00:09:29.040
provided we choose these two columns as the primary key.

00:09:29.040 --> 00:09:35.040
And it actually makes sense because we have to have somebody who pays the fee to endure for

00:09:35.040 --> 00:09:35.760
a course.

00:09:35.760 --> 00:09:39.490
Only then will be able to have some fee.

00:09:39.490 --> 00:09:41.480
Well,

00:09:41.480 --> 00:09:43.130
I'm just trying to give an example,

00:09:43.130 --> 00:09:44.850
but I think you got the idea.

00:09:44.850 --> 00:09:46.670
Similarly,

00:09:46.670 --> 00:09:53.840
we got your normal form would just simply means that all the non key columns are dependent

00:09:53.840 --> 00:09:57.650
only on the primary key and not anything else.

00:09:57.650 --> 00:10:01.460
Imagine that just for the sake off this example.

00:10:01.460 --> 00:10:05.870
We're trying to introduce another column that say's eligibility.

00:10:05.870 --> 00:10:08.800
If the students ages girdle and 35.

00:10:08.800 --> 00:10:12.360
Then we're going to set the eligible to stables with the flag,

00:10:12.360 --> 00:10:13.050
basically,

00:10:13.050 --> 00:10:14.150
yes or no,

00:10:14.150 --> 00:10:15.120
in our case,

00:10:15.120 --> 00:10:17.250
although students are eligible.

00:10:17.250 --> 00:10:20.300
But just imagine that we have another column here,

00:10:20.300 --> 00:10:24.550
and we're trying to set this eligibility status.

00:10:24.550 --> 00:10:25.910
In that case,

00:10:25.910 --> 00:10:33.320
our table is not following the tor normal form because our eligibility column is dependent

00:10:33.320 --> 00:10:34.460
on the age column,

00:10:34.460 --> 00:10:39.290
which is not a primary key and asked for a definition off third normal form.

00:10:39.290 --> 00:10:44.650
It says non key columns are dependent only on the Primerica and not anything else.

00:10:44.650 --> 00:10:50.550
So that would be a bad practice if you introduce such column,

00:10:50.550 --> 00:10:58.600
and I believe this is sufficient.

00:10:58.600 --> 00:11:05.110
And definitely I think this video is definitely going to help you at later point of time in

00:11:05.110 --> 00:11:05.850
your carrier.

00:11:05.850 --> 00:11:08.700
So I think that's it.

00:11:08.700 --> 00:11:11.590
I think we've talked about pretty much everything.

00:11:11.590 --> 00:11:13.090
See you soon

