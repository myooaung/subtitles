WEBVTT

00:00:01.310 --> 00:00:05.370
Have the last topic I want to touch and this Marchal is destructuring.

00:00:05.370 --> 00:00:12.000
Destructuring allows you to do what The same applies to structure a complex object like an object or

00:00:12.000 --> 00:00:16.780
an array into simpler ones and I'll show you how this works.

00:00:16.800 --> 00:00:21.920
I'll start with an array numbers and those should be one to free let's say.

00:00:22.560 --> 00:00:25.080
And then the structuring works like this.

00:00:25.200 --> 00:00:27.630
Let's say I want to have one and 2.

00:00:27.630 --> 00:00:29.150
Now of course I quit.

00:00:29.280 --> 00:00:34.280
Set a equal to number or is index 0.

00:00:34.590 --> 00:00:42.510
And then I could do the same for B and the axis the item and the index one and the next would breed

00:00:42.540 --> 00:00:44.350
at AP that would work.

00:00:44.400 --> 00:00:46.770
Destructuring gives you a shorter syntax.

00:00:47.040 --> 00:00:54.750
Use square brackets to structure an array for objects as you will see later you use curly braces then

00:00:54.750 --> 00:00:57.610
the values you want to.

00:00:57.720 --> 00:01:04.380
Well are you variable names you want to fill with values and then well the Optik you want to do is structure

00:01:04.770 --> 00:01:08.900
numbers so that of course is syntax.

00:01:08.910 --> 00:01:16.620
You probably haven't seen before because it's new and prior to E6 you didn't use square brackets on

00:01:16.620 --> 00:01:18.470
this side of the equal sign right.

00:01:18.480 --> 00:01:20.690
You would use that on the right side to create an array.

00:01:20.700 --> 00:01:23.730
But on the left that certainly is new.

00:01:23.730 --> 00:01:27.350
Now let me show you what this actually does for printing a.

00:01:27.360 --> 00:01:30.470
And then also printing B.

00:01:30.970 --> 00:01:34.060
And we have the idea you already can guess what we'll have.

00:01:34.090 --> 00:01:35.220
But what do you think will happen.

00:01:35.220 --> 00:01:38.620
I had run you'll see one and two.

00:01:38.760 --> 00:01:42.060
So this is a quick way to extract values from an array.

00:01:42.120 --> 00:01:46.580
Now of course all the could add c to get the word value as well.

00:01:46.650 --> 00:01:49.740
The question is what happens with the original array.

00:01:49.770 --> 00:01:57.120
Is it destroyed or is it changed by this restructuring or are we just retrieving copies of those values

00:01:57.120 --> 00:01:59.390
instead of actually pulling them out.

00:01:59.580 --> 00:02:02.400
So what do you think we'll see if I now had run.

00:02:03.230 --> 00:02:06.340
I'll ask and see the original aere still persists.

00:02:06.360 --> 00:02:07.710
It's not changed.

00:02:07.710 --> 00:02:12.690
We're just getting copies of the values we're pulling out with destructuring.

00:02:12.700 --> 00:02:19.610
Another interesting question of course it is what if I actually pull out more values then this every

00:02:19.620 --> 00:02:22.810
has and now I want to print d here.

00:02:22.980 --> 00:02:26.770
What do you think I'll get if I now hit run.

00:02:27.900 --> 00:02:35.370
Well I got undefined because remember I can think of a Chavez group arrayed as kind of an infinite array

00:02:35.430 --> 00:02:39.480
where all the values you didn't set are just undefined values.

00:02:39.480 --> 00:02:42.460
So you can pull out as many values as you want.

00:02:42.480 --> 00:02:50.630
You will get them they are just fine at different ways is also the wrote the rest parameter here.

00:02:50.700 --> 00:02:55.300
You may use it like this B.

00:02:55.790 --> 00:03:02.470
And if it now print b what you think I'll get if I had run I get a new array.

00:03:02.640 --> 00:03:09.940
So with the rest parameter I'm basically pulling out all the remaining values which I didn't restructure

00:03:09.990 --> 00:03:15.820
before like a and put them into a new array which of course also is possible.

00:03:15.870 --> 00:03:21.510
This is a quick way to Reto to retrieve a part often array of course you would also have splice and

00:03:21.510 --> 00:03:23.360
slice for such operations.

00:03:23.550 --> 00:03:30.850
But as you can see it is a really quick way to get certain values if you will need to get them.

00:03:30.870 --> 00:03:35.010
Needless to say destructuring of course also works with an array that has strings or something like

00:03:35.010 --> 00:03:35.350
this.

00:03:35.350 --> 00:03:38.250
So if and now it run this still works to say.

00:03:38.760 --> 00:03:41.860
Now back to the A B example.

00:03:42.000 --> 00:03:46.030
And I also retrieve C and D like before.

00:03:46.050 --> 00:03:52.680
No you already saw that if I run this D will be undefined Of course with destructuring You can also

00:03:52.680 --> 00:03:56.020
assign default values like this before.

00:03:56.340 --> 00:04:04.770
If I now had run you see default if i also assigned 4 to 8 here and then I had to run.

00:04:04.770 --> 00:04:07.950
What do you think will happen.

00:04:07.950 --> 00:04:08.960
We see one.

00:04:08.970 --> 00:04:15.090
So let's kind of a mixture of functions with default values and golf destructuring here.

00:04:15.240 --> 00:04:21.720
So basically you are able to prepare for the case that value you want to pull out.

00:04:21.720 --> 00:04:26.250
It's actually undefined in this case he would get whatever default value you set up here.

00:04:26.250 --> 00:04:30.930
And again this could also be a number or any type.

00:04:30.930 --> 00:04:37.380
But if the value is available like here with a where we actually can pull out one then that the fold

00:04:37.380 --> 00:04:38.340
will not be used.

00:04:38.340 --> 00:04:42.620
Instead we get the actual value we pull out with destructuring.

00:04:43.030 --> 00:04:48.600
Destructuring can also be used for something else you can use it to quickly swap variables.

00:04:48.840 --> 00:04:55.370
So let's say we have eight which is five and we have B which is 10 and we just want to swap that 7 and

00:04:55.400 --> 00:04:57.450
8 10 and B is 5.

00:04:57.900 --> 00:05:03.840
Well before you would need a helper variable seat you would temporarily store one value then set one

00:05:03.840 --> 00:05:08.160
variable to the other and then set T A C to the other one and so on.

00:05:08.160 --> 00:05:11.420
So it was possible but it had some extra steps.

00:05:11.430 --> 00:05:13.780
Now it's as simple as this.

00:05:13.890 --> 00:05:24.930
Destructuring with the variable names you already defined so a and you assign it like this A and B.

00:05:24.990 --> 00:05:27.030
So what kind of destructuring on both side.

00:05:27.040 --> 00:05:32.640
So we're here we're creating an array to be precise for constructing an array and then we're instantly

00:05:32.650 --> 00:05:34.020
destructuring it.

00:05:34.260 --> 00:05:39.330
So here we're really creating an array where A is the first element that beats the second and then we're

00:05:39.330 --> 00:05:43.590
deconstructing it to well basically swap the values.

00:05:43.590 --> 00:05:45.020
So therefore if y.

00:05:45.270 --> 00:05:50.160
Now log B of course also log a

00:05:53.190 --> 00:05:54.520
run.

00:05:54.800 --> 00:05:58.230
I get an error or because I shouldn't use LET here think humor.

00:05:58.280 --> 00:06:05.360
So now if I had run you'll see B which is the first one we print is now actually 5 even though we said

00:06:05.360 --> 00:06:10.150
it to 10 before and is 10 so you values actually worse whopped.

00:06:10.260 --> 00:06:12.030
And this is a really quick way to do this.

00:06:12.030 --> 00:06:18.810
In case you have some coal where you need to swap certain values destructuring really makes this easy

00:06:18.820 --> 00:06:19.260
.

00:06:19.260 --> 00:06:25.450
Another thing you can do with destructuring to go back to the array of numbers here.

00:06:26.070 --> 00:06:29.040
You can also ignore certain values.

00:06:29.040 --> 00:06:36.690
So let's say I want you blow out some values but not all of them.

00:06:36.930 --> 00:06:39.790
I want to put the first one and the first one.

00:06:39.950 --> 00:06:43.470
Well then I just leave an empty space like that.

00:06:43.470 --> 00:06:49.920
And so that equal two numbers and then I log a and see I can also use the lock function like this.

00:06:50.040 --> 00:06:50.680
If I know I'd run.

00:06:50.730 --> 00:06:52.380
What do you think we'll get.

00:06:53.220 --> 00:06:54.600
I get one in free.

00:06:54.750 --> 00:07:00.720
So two were simply left out as I reserved an empty space here in the rest.

00:07:00.750 --> 00:07:03.020
Operator are in structuring.

00:07:03.030 --> 00:07:04.050
Operator here.

00:07:04.230 --> 00:07:09.870
So I simply left out this space where I could assign B but I don't have to and therefore I'm able to

00:07:09.870 --> 00:07:12.910
just pull out specific places in the array.

00:07:12.930 --> 00:07:14.860
I want to destructor.

00:07:14.910 --> 00:07:17.380
You can also do something like this.

00:07:17.490 --> 00:07:21.280
You don't even need to declare your array.

00:07:21.300 --> 00:07:28.470
You can immediately for example you structure it like this a and b and now had run with it you think

00:07:28.470 --> 00:07:31.400
we'll get one in two.

00:07:31.410 --> 00:07:38.070
So now I'm not even creating this array I'm not declaring it and not sending it to it's own variable

00:07:38.190 --> 00:07:42.890
instead of immediately destructuring it to just get a B out of it.

00:07:42.900 --> 00:07:48.720
Now this is kind of a way to to quickly create a and b variables initialized with one and 2 where if

00:07:48.720 --> 00:07:51.390
you think of this if you think of it like this.

00:07:51.900 --> 00:07:55.110
So that is a number of ways you used the structuring