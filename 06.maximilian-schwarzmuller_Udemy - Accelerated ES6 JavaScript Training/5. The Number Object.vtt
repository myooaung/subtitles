WEBVTT

00:00:01.320 --> 00:00:09.240
There have also been some additions to the number object and those additions also are available with

00:00:09.240 --> 00:00:10.190
iOS 5.

00:00:10.380 --> 00:00:18.240
But now they are registered on the global number object all show which new methods I mean or which new

00:00:18.240 --> 00:00:21.210
methods were added to the number object.

00:00:21.290 --> 00:00:26.930
I'll start with a variable number and I'll actually set it to NOT A NUMBER.

00:00:27.330 --> 00:00:33.930
Now we already have d is an A and method which you can use on this.

00:00:33.930 --> 00:00:37.440
And if I now had run I get true.

00:00:37.710 --> 00:00:43.720
So this is an existing method a global function which I can use to check if a number is.

00:00:43.740 --> 00:00:45.700
Well not a number.

00:00:45.780 --> 00:00:53.360
Now it was also added to the number object so I can now use it on the number object like this.

00:00:53.370 --> 00:00:56.980
So why was it added there if you already had it in a shorter way.

00:00:57.210 --> 00:00:59.550
What you just read to group it all together.

00:00:59.680 --> 00:01:05.670
Also depending on your ID you would get auto completion of course if you type number Daut some thing

00:01:05.790 --> 00:01:09.720
and this might help you finding the right method you're looking for.

00:01:09.720 --> 00:01:15.540
So it's really more of a trooping thing or improvement than an actual new feature of course.

00:01:15.540 --> 00:01:19.960
Interesting question if I make this a string What do you think we'll now get.

00:01:20.610 --> 00:01:27.840
We get false because while now it's a string which technically isn't a number but it's not there's not

00:01:27.840 --> 00:01:29.730
a number type we got here.

00:01:30.030 --> 00:01:36.560
Now as now the number we all got new is Finot.

00:01:36.610 --> 00:01:42.330
And we already had this before too without the number at the beginning so as a global function.

00:01:42.330 --> 00:01:45.690
Now if we're dead all trades are really big number here.

00:01:46.080 --> 00:01:50.280
So what do you think I'll get if I had run of course I.

00:01:50.280 --> 00:01:53.600
True it might be a big number but it's definitely finished.

00:01:53.610 --> 00:01:56.910
It's not infinity that of course changes.

00:01:56.910 --> 00:02:05.060
If I actually make this infinity so infinity like this if an hour had run I got four.

00:02:05.070 --> 00:02:07.430
Because infinity is infinite.

00:02:07.650 --> 00:02:10.000
So that certainly won't work.

00:02:10.210 --> 00:02:12.380
And as a side note the only half is finished.

00:02:12.380 --> 00:02:15.410
So if you want to check if it's actually infinite.

00:02:15.540 --> 00:02:23.470
Well then you would have to add an exclamation mark to Gruber's that liked it.

00:02:23.490 --> 00:02:28.980
If I remove does it through a Shoemark we also get the new is into Tahrir mfat.

00:02:29.100 --> 00:02:32.700
What do you think and how I get if I had run I get four.

00:02:32.700 --> 00:02:37.380
So infinity is not an integer but change just 10.

00:02:37.380 --> 00:02:40.130
What do you not get think Alegate.

00:02:40.270 --> 00:02:40.860
Now I get.

00:02:40.860 --> 00:02:46.690
True it was called because of course 10 isn't any truer and if I make this ten point one.

00:02:46.920 --> 00:02:49.500
What do you think we're now seeing the console.

00:02:50.640 --> 00:02:54.240
Well we see faults because that of course is a float and no end to truth.

00:02:54.420 --> 00:03:03.340
And since we don't have types in shambles script and floats and interests like just 10 before our end

00:03:03.350 --> 00:03:10.800
really differentiated into shorter is a good way to conveniently find out if a bad actually is afloat

00:03:11.190 --> 00:03:12.690
or is an integer.

00:03:12.870 --> 00:03:18.750
So we can also count that a bit in the direction of metaprogramming since it allows you to evaluate

00:03:18.780 --> 00:03:25.040
what your code is like at certain ball States during your program execution.

00:03:25.200 --> 00:03:31.020
So is it true is certainly an interesting addition to is shallow strip specification as it gives us

00:03:31.020 --> 00:03:32.460
just a convenient way.

00:03:32.580 --> 00:03:40.320
And prior to this situation you have to use upper loops or other functions self-build functions to find

00:03:40.320 --> 00:03:43.400
out if the number actually is an integer or float.

00:03:43.400 --> 00:03:46.090
So that definitely is a good at this.