WEBVTT

00:00:00.990 --> 00:00:09.360
I get rid of the clearance here again and sometimes it would be nice to kind of see the keys you have

00:00:09.360 --> 00:00:16.160
inside your set can use keys method but what do you think we'll see page run.

00:00:18.150 --> 00:00:23.290
Or actually we see it kind of seems to be an iterator.

00:00:23.340 --> 00:00:29.550
So since this is the case what we can of course stick with we can simply create a for loop and simply

00:00:29.550 --> 00:00:37.700
loop through all our keys and that and print a key to the console.

00:00:37.710 --> 00:00:41.800
And with for of Lupi or where I used just keys method to through it.

00:00:41.970 --> 00:00:49.240
Now if had run we see the chokey is stored in the stack or in this map here.

00:00:49.380 --> 00:00:55.740
So if you are not sure you have kind of a function where you dynamically need to get the values or the

00:00:55.740 --> 00:01:03.180
keys inside of your map Well Steve the method you want to use Tiki's method well unsurprisingly if you

00:01:03.180 --> 00:01:10.290
get a Kismat thought we all got a values method cell with the value of Smarr third I think you know

00:01:10.290 --> 00:01:16.880
what it might use so see it action while we retrieve the values.

00:01:17.160 --> 00:01:23.010
So we have methods to retrieve the keys and we got them methods to retrieve the values.

00:01:23.220 --> 00:01:29.600
Well of course the question that we also have a wage you well get both the key value pairs.

00:01:29.970 --> 00:01:31.620
Yes we got that.

00:01:31.620 --> 00:01:38.390
For one we can use the entries method here which and each entry is a key value pair.

00:01:38.400 --> 00:01:43.380
So here we would get the individual key value Paris as it can see if Now run.

00:01:43.440 --> 00:01:44.640
Now how do you think.

00:01:44.640 --> 00:01:48.060
Will this be printed to the console or how is it stored internally

00:01:51.420 --> 00:01:52.610
as an array.

00:01:52.620 --> 00:01:59.940
Remember that when creating this map I said you could also pass an array with arrays inside of it to

00:01:59.940 --> 00:02:01.330
the constructor here.

00:02:01.620 --> 00:02:03.420
Well that's just what you were getting back here.

00:02:03.480 --> 00:02:09.930
You get back the arrays which would be inside of the outer aere when creating a map where the first

00:02:09.930 --> 00:02:14.140
element is always to keep and the second element is always the value.

00:02:14.520 --> 00:02:16.500
So that is why we get this.

00:02:16.500 --> 00:02:22.490
There was a raised bag with key value in Paris mapped into elements in this array.

00:02:22.500 --> 00:02:25.070
Now we don't have to use the entry Smurfette.

00:02:25.260 --> 00:02:30.560
If I just loop through the map like so it works exactly the same way.

00:02:30.560 --> 00:02:33.920
So the entry method is kind of well obsolete here.

00:02:33.930 --> 00:02:36.820
So we don't really need to add it in order.

00:02:36.870 --> 00:02:40.070
You will loop through all the entries in our map.

00:02:40.140 --> 00:02:47.580
Now of course as with the default array for example you may also override the way you iterate through

00:02:47.580 --> 00:02:51.810
your map by simply overwriting the iterator as symbol.

00:02:51.840 --> 00:02:58.950
So the field stored with the iterator a symbol like it saw it in the section where we used symbols to

00:02:59.280 --> 00:03:03.500
actually do just that were ID iterating logic of Diebold in array.

00:03:03.630 --> 00:03:05.430
And you might do the very same for a map.

00:03:05.460 --> 00:03:09.030
And as you later also learned for the set to