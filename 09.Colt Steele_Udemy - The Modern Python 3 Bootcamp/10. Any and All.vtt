WEBVTT
1
00:00:00.240 --> 00:00:01.320
Hey welcome back.

2
00:00:01.320 --> 00:00:05.990
So from here on out in this section we're going to take a look at a bunch of built in functions.

3
00:00:06.090 --> 00:00:10.080
Spend maybe a minute on each but there's quite a few of them to take a look at.

4
00:00:10.110 --> 00:00:12.040
And in this video we're going to learn too.

5
00:00:12.090 --> 00:00:14.670
They're called any and all.

6
00:00:14.670 --> 00:00:15.660
So let me just show you.

7
00:00:15.750 --> 00:00:16.870
This is all.

8
00:00:17.160 --> 00:00:25.980
And what it does is it takes an interval as an argument and it returns true if all arguments or elements

9
00:00:26.120 --> 00:00:30.390
in the iterable are truthy or if it's empty it also returns true.

10
00:00:30.390 --> 00:00:33.250
So we'll see a special case there.

11
00:00:33.270 --> 00:00:36.230
So for example if we pass in all.

12
00:00:36.270 --> 00:00:44.370
And then a list containing 0 1 2 3 Remember that 3 2 and 1 are all Sruthi but zero is falsie.

13
00:00:44.400 --> 00:00:46.490
So all is going to return false.

14
00:00:46.500 --> 00:00:52.750
So this first example we have a list comprehension and it's going to take each character and he I go

15
00:00:53.730 --> 00:01:01.880
if so it's actually just it would be easier if I just go to my terminal if I run this I get this list

16
00:01:02.000 --> 00:01:02.330
right.

17
00:01:02.330 --> 00:01:06.110
So if I run all on that what do we expect to get.

18
00:01:06.230 --> 00:01:06.900
True.

19
00:01:07.070 --> 00:01:09.430
All elements are truthy.

20
00:01:09.440 --> 00:01:10.120
How about this.

21
00:01:10.130 --> 00:01:18.010
This is another list comprehension numb for numb in four to ten six eight if numb mode to is zero.

22
00:01:18.230 --> 00:01:21.400
So that gives us four to ten six and eight.

23
00:01:21.500 --> 00:01:24.670
And if I run all pace then it's still true.

24
00:01:24.890 --> 00:01:29.330
So these are all geared uses honestly you wouldn't really do this very often.

25
00:01:29.330 --> 00:01:32.100
Let me now show you an example that you might do.

26
00:01:32.120 --> 00:01:36.730
So here I have a list of defined called people and it has a bunch of names.

27
00:01:37.040 --> 00:01:44.990
So if I wanted to know if all items in this list started with the letter c I could do this all and then

28
00:01:45.380 --> 00:01:54.170
I can do a list comprehension and produce something like name zero equals equals uppercase C for name

29
00:01:54.290 --> 00:01:58.100
and people me at a space here.

30
00:01:58.100 --> 00:01:59.290
So hopefully this makes sense.

31
00:01:59.360 --> 00:02:01.500
But this list comprehension is going to do.

32
00:02:01.880 --> 00:02:06.200
And before I hit enter I want to think to yourself what is this going to look like.

33
00:02:06.200 --> 00:02:08.950
This exact list comprehension not the all.

34
00:02:09.080 --> 00:02:10.550
If I just pasted this right now.

35
00:02:10.550 --> 00:02:14.950
Copy and pasted it this returns true or false.

36
00:02:15.000 --> 00:02:17.700
So we're going to have a list of true or false values.

37
00:02:17.710 --> 00:02:23.790
So let me just show you if I hit Enter we get true because all people start with the letter C in this

38
00:02:24.240 --> 00:02:24.980
list.

39
00:02:25.290 --> 00:02:30.810
But if I actually just ran this right now it gives me as true true true true true.

40
00:02:31.050 --> 00:02:35.440
And of course I could do people that append and let's add in someone.

41
00:02:35.440 --> 00:02:37.140
How about Hey Kristie.

42
00:02:37.230 --> 00:02:39.120
OK.

43
00:02:39.550 --> 00:02:47.760
Now if I rerun this I get church your true true false and if I rerun the all it now returns false because

44
00:02:48.180 --> 00:02:51.110
not everything passed in was true.

45
00:02:51.420 --> 00:02:52.710
Here's another example.

46
00:02:52.830 --> 00:02:56.330
I have a list called numbers and I could do something like.

47
00:02:56.370 --> 00:02:58.500
All numbers even.

48
00:02:58.500 --> 00:03:00.590
And to do that I would check all.

49
00:03:00.690 --> 00:03:01.950
And then a list comprehension.

50
00:03:01.970 --> 00:03:07.820
Which actually in a moment I'll show you why these are optional and we would do something like numb

51
00:03:08.560 --> 00:03:12.190
mod 2 equals equals zero.

52
00:03:12.400 --> 00:03:16.470
For now Nahm in numbers and that's true.

53
00:03:17.280 --> 00:03:25.420
And if I changed names and I added in 2001 the end now it's false.

54
00:03:25.420 --> 00:03:29.420
Before I talk about why we actually don't have to do this list comprehension.

55
00:03:29.620 --> 00:03:35.300
Let me introduce any which is very similar except it's the opposite.

56
00:03:35.410 --> 00:03:40.540
Well it's not quite the opposite but the way it works takes an admirable and it will return true if

57
00:03:40.660 --> 00:03:42.560
any element of iterable is truthy.

58
00:03:42.580 --> 00:03:45.620
Instead of all of them being true the.

59
00:03:45.780 --> 00:03:51.860
So in this case if we run any on the same value here we have 0 1 2 three.

60
00:03:52.260 --> 00:03:57.180
Well zero is falsie but one is truthy so any returns true.

61
00:03:57.270 --> 00:04:03.810
So I could do any numbers and see if any number is odd and that should be true.

62
00:04:03.810 --> 00:04:05.110
There is one odd number.

63
00:04:05.220 --> 00:04:11.550
So I just write no mad to equals equals 1 for numb numbs.

64
00:04:12.300 --> 00:04:13.510
And that's true.

65
00:04:13.770 --> 00:04:18.490
And I could also do the same thing as is any number even that should be true as well.

66
00:04:19.170 --> 00:04:25.080
But if I tried to do something if not mad 2 is equal to 2 that's not going to be the case for any of

67
00:04:25.080 --> 00:04:26.610
them so that's false.

68
00:04:26.640 --> 00:04:31.590
That would be false for any number because what number could be divisible by 2 and have a remainder

69
00:04:31.590 --> 00:04:31.980
of two.

70
00:04:31.980 --> 00:04:33.460
It's not possible.

71
00:04:33.600 --> 00:04:37.010
OK so any and all the most basic level.

72
00:04:37.070 --> 00:04:40.990
They're nice for testing things that you don't have to use them.

73
00:04:41.010 --> 00:04:46.760
You could just iterate over this yourself and check if it's true for each one right.

74
00:04:46.770 --> 00:04:49.650
So I could do loop over people.

75
00:04:49.650 --> 00:04:54.990
It would look like this for person and people right.

76
00:04:55.080 --> 00:04:57.800
And then I'd write a conditional statement.

77
00:04:58.020 --> 00:05:06.190
If would I say person 0 equals equals c..

78
00:05:06.870 --> 00:05:13.130
Or we could actually do if it's not equal to c then we could break or return false.

79
00:05:13.170 --> 00:05:17.880
Anyway I won't do the whole thing but the point is we could do this without all this is just a nice

80
00:05:17.880 --> 00:05:18.660
built in helper.
