WEBVTT
1
00:00:00.270 --> 00:00:01.010
Welcome back.

2
00:00:01.110 --> 00:00:05.210
So there is a bit more syntax to try and accept that I just wanted to highlight.

3
00:00:05.280 --> 00:00:08.340
We've seen the top two but we can also add in else.

4
00:00:08.340 --> 00:00:13.210
And finally and neither of these have to be there but let me just show you how it works.

5
00:00:13.290 --> 00:00:18.680
If you can remember way back when when we were doing the guessing game we were asking the user for input

6
00:00:19.110 --> 00:00:24.200
and then we tried to convert that number or whatever they typed in to an int.

7
00:00:24.390 --> 00:00:29.400
But if the user didn't type in an int for example if they just typed nothing and we tried to turn that

8
00:00:29.400 --> 00:00:32.090
into an ant that causes an error.

9
00:00:32.370 --> 00:00:38.050
So what we could do is use a try except to prevent that so we could do something like try.

10
00:00:38.280 --> 00:00:41.960
And then we'll just do inputs.

11
00:00:42.360 --> 00:00:48.120
Please enter a number and then save that to a variable.

12
00:00:48.210 --> 00:00:53.420
Let's call it numb equals and then let's turn it into an end like this.

13
00:00:53.430 --> 00:00:57.540
So we'll try to ask them for an input and then turn it into an end.

14
00:00:57.600 --> 00:01:02.070
So this shouldn't cause any problems but the conversion to an ENT might.

15
00:01:02.100 --> 00:01:04.050
So if we encounter a problem.

16
00:01:04.050 --> 00:01:08.600
For now we'll just leave it as Except let's just start by printing.

17
00:01:09.240 --> 00:01:11.110
That's not a number.

18
00:01:11.120 --> 00:01:12.530
Something like that.

19
00:01:13.170 --> 00:01:13.600
OK.

20
00:01:13.890 --> 00:01:24.330
So on its own if we run this right now on three please enter number for I type 10 were all good but

21
00:01:24.330 --> 00:01:27.820
if I type A It tells me that not a number.

22
00:01:27.840 --> 00:01:30.420
So already this could help us with that guessing game.

23
00:01:30.420 --> 00:01:33.560
Just adding and try and Except instead of our code breaking.

24
00:01:33.570 --> 00:01:39.270
When you try and convert input or whatever the user types to an end we now could handle it what would

25
00:01:39.270 --> 00:01:40.560
we actually want to do.

26
00:01:40.710 --> 00:01:43.930
Well we would probably have this in a loop and then repeat the loop.

27
00:01:44.010 --> 00:01:45.780
But for now I'll come back to that.

28
00:01:45.930 --> 00:01:47.130
I just want to show else.

29
00:01:47.130 --> 00:01:58.090
And finally so if we put Elsin here we put some code I'm in the else and I run this again and we clear

30
00:01:58.090 --> 00:02:00.510
my terminal X in my room.

31
00:02:00.610 --> 00:02:09.560
So if I type nine I get I'm an else if I type a SD I don't.

32
00:02:09.560 --> 00:02:14.480
So this shows us that else we'll run when Except it does not.

33
00:02:14.900 --> 00:02:20.990
So try will run and it's good to see if it works or if there's a problem if there's a problem except

34
00:02:21.140 --> 00:02:23.710
we'll run if there's not a problem.

35
00:02:23.810 --> 00:02:24.870
Else we'll run.

36
00:02:25.210 --> 00:02:28.820
And that brings us to finally and finally we'll run.

37
00:02:28.840 --> 00:02:31.000
No matter what after this.

38
00:02:31.030 --> 00:02:35.550
So in here I'll do a print and we'll just write.

39
00:02:35.560 --> 00:02:35.950
I don't know.

40
00:02:35.950 --> 00:02:38.080
Runs no matter what.

41
00:02:38.800 --> 00:02:39.640
OK.

42
00:02:39.940 --> 00:02:46.740
So now if we try one more time if I enter a valid number like 12 we get the else and we get.

43
00:02:46.750 --> 00:02:53.090
Finally if I enter an invalid number just by hitting enter too soon we get that's not a number.

44
00:02:53.110 --> 00:02:57.540
So that's from the accept and then runs no matter what from the finally.

45
00:02:57.550 --> 00:02:57.840
OK.

46
00:02:57.850 --> 00:02:59.750
So hopefully that's clear try.

47
00:02:59.800 --> 00:03:05.140
We'll attempt to do something if there's a problem except runs if there's not a problem else runs and

48
00:03:05.140 --> 00:03:07.360
no matter what finally runs.

49
00:03:07.690 --> 00:03:10.880
So most commonly used I try and accept.

50
00:03:10.940 --> 00:03:13.900
Definitely but you should know these exist.

51
00:03:13.900 --> 00:03:19.120
And if I did want to make this right now this runs one time but for a guessing game example we don't

52
00:03:19.120 --> 00:03:24.310
just want to give up on the user if they enter something like S and that's not a number we should ask

53
00:03:24.310 --> 00:03:25.240
them again.

54
00:03:25.450 --> 00:03:26.570
So what we could do.

55
00:03:26.620 --> 00:03:36.540
Copy this comment that part out is something like this while true repeat this entire thing.

56
00:03:37.150 --> 00:03:38.770
But we don't want to just repeat it forever.

57
00:03:38.780 --> 00:03:39.820
It's an infinite loop.

58
00:03:39.830 --> 00:03:41.600
So when do we want to break out.

59
00:03:41.840 --> 00:03:44.520
Well when this part runs.

60
00:03:44.660 --> 00:03:48.920
So instead of Aiman else let's say good job.

61
00:03:48.920 --> 00:03:52.900
You entered a number and then break.

62
00:03:53.450 --> 00:03:57.860
And that should stop the loop and let's see what happens right now.

63
00:03:57.890 --> 00:03:59.010
So I'm going to run it again.

64
00:04:02.150 --> 00:04:12.030
Please enter a number if I enter a number please enter a number again if I enter something like that.

65
00:04:12.140 --> 00:04:16.960
But as soon as I enter a number good job you entered a number that's the else.

66
00:04:16.970 --> 00:04:22.640
So we break out but it's important to know the FINALLY still runs runs no matter what.

67
00:04:23.060 --> 00:04:24.580
But we're now out of the loop.

68
00:04:24.590 --> 00:04:32.420
So then down here if we printed something like rest of game logic try it again.

69
00:04:34.690 --> 00:04:37.370
This time I don't know f OK.

70
00:04:37.380 --> 00:04:38.300
And then I enter eight.

71
00:04:38.340 --> 00:04:40.040
That's my actual guess.

72
00:04:40.050 --> 00:04:45.250
Good job you entered a number from the ELSE ARE FINALLY around and then the code after the blue runs.

73
00:04:45.570 --> 00:04:45.900
OK.

74
00:04:45.930 --> 00:04:47.820
So you can see how this is useful.

75
00:04:47.820 --> 00:04:54.030
Like I said finally it's not as commonly used in my experience but this whole pattern especially when

76
00:04:54.030 --> 00:04:58.660
you're dealing with user input and the tendency for users to get things wrong more than once.

77
00:04:58.710 --> 00:05:04.020
This is a common structure to have a loop like this while true and then you break out if nothing went

78
00:05:04.020 --> 00:05:04.630
wrong.

79
00:05:04.860 --> 00:05:10.170
But if there's a problem then the loop just runs again and you give the user feedback to explain that's

80
00:05:10.170 --> 00:05:12.460
not a number or whatever the problem is.

81
00:05:12.690 --> 00:05:14.340
And a small improvement we can make.

82
00:05:14.460 --> 00:05:17.170
Rather than accepting all errors here.

83
00:05:17.760 --> 00:05:19.730
What kind of error would cause what's the error.

84
00:05:19.730 --> 00:05:23.980
We're really concerned about it's a value error.

85
00:05:24.240 --> 00:05:29.400
So that would be when you know a user enters a string which is the right type so it's not a type error

86
00:05:29.760 --> 00:05:34.800
but it's the it needs to be a number string that makes sense needs to be a numeric string rather than

87
00:05:34.920 --> 00:05:35.790
a letter.

88
00:05:35.790 --> 00:05:36.820
So that's a value.

89
00:05:37.050 --> 00:05:38.910
And just double check it still works.

90
00:05:38.910 --> 00:05:44.460
So if I cause a problem we get that's not a number and that's coming because we are accepting value

91
00:05:44.460 --> 00:05:45.450
errors.

92
00:05:46.850 --> 00:05:55.460
OK so one more example I have for you I'm going to make a new file called divide Y and we're going to

93
00:05:55.460 --> 00:06:01.760
define a really simple function called divide and this is still a silly example but it's a little more

94
00:06:01.760 --> 00:06:05.310
involved this more than one type of error that we're going to accept.

95
00:06:05.660 --> 00:06:12.350
And let's say it takes two numbers like a and b and the whole idea is that we would call it something

96
00:06:12.350 --> 00:06:15.450
like this one comma too.

97
00:06:15.710 --> 00:06:18.280
All right and that should return to us point five.

98
00:06:18.290 --> 00:06:19.490
Very simple.

99
00:06:19.490 --> 00:06:23.850
But if I pass in something like one to about about S.R.O that causes an error.

100
00:06:24.080 --> 00:06:26.730
What about a divided by two.

101
00:06:27.020 --> 00:06:30.610
So we're going to write some logic to check for those problems.

102
00:06:30.620 --> 00:06:31.250
OK.

103
00:06:31.640 --> 00:06:34.000
So first up all that we're going to do is right.

104
00:06:34.040 --> 00:06:35.890
Try a.

105
00:06:35.900 --> 00:06:43.570
Divide by B and we'll return that and we can just put them 1 except in here which is not a good idea

106
00:06:43.580 --> 00:06:44.330
for the most part.

107
00:06:44.340 --> 00:06:45.620
There's more than one error.

108
00:06:45.620 --> 00:06:48.890
Well let's just print something went wrong.

109
00:06:50.330 --> 00:07:00.150
OK so let's try running print of divide one comma two and then the same thing with one comma zero.

110
00:07:00.270 --> 00:07:03.570
So we get 0.5 and then we get something went wrong.

111
00:07:03.780 --> 00:07:07.330
And we also get that none because we tried to print something and nothing came back.

112
00:07:07.440 --> 00:07:08.650
Don't worry about that.

113
00:07:08.670 --> 00:07:11.810
So it's working here but all we're doing is saying something went wrong.

114
00:07:12.120 --> 00:07:14.640
And instead of doing that we want to be very explicit.

115
00:07:15.150 --> 00:07:19.250
And I believe it's called Zero division error.

116
00:07:19.260 --> 00:07:29.240
So instead accept only that error and we'll print for now don't divide by zero please.

117
00:07:29.310 --> 00:07:35.220
And now if we run this Roggio does we get don't divide by zero please.

118
00:07:35.510 --> 00:07:35.900
OK.

119
00:07:36.020 --> 00:07:43.670
That still doesn't handle everything because if I tried to do print 1 divided by a and I run it now

120
00:07:44.390 --> 00:07:47.070
we get type error on operand types.

121
00:07:47.210 --> 00:07:50.260
So let's just add another except for a type error.

122
00:07:50.510 --> 00:07:54.780
Just do it after the line except type error.

123
00:07:57.350 --> 00:08:05.120
And then this time let's print a and b must be ints or floats something like that.

124
00:08:05.120 --> 00:08:09.160
Now if we run it we get and B must be int or folks.

125
00:08:09.170 --> 00:08:15.440
So now we are accepting two different errors and once one change we could make not to make this a better

126
00:08:15.860 --> 00:08:19.030
function really but just to use an else.

127
00:08:19.070 --> 00:08:26.820
I'll save this to a variable called result and then in the else I will print a little f string that

128
00:08:26.930 --> 00:08:36.260
says something like a divided by B is result just so that we're doing something a bit different than

129
00:08:36.260 --> 00:08:39.860
just the traditional division that we wouldn't even need this for.

130
00:08:39.920 --> 00:08:43.780
Now if we test it out we get one divided by two is 0.5.

131
00:08:44.000 --> 00:08:46.130
And the second one is causing this error.

132
00:08:46.130 --> 00:08:52.550
One last thing to show you if we actually want the error itself that is triggering this we can add an

133
00:08:52.580 --> 00:08:53.220
as.

134
00:08:53.270 --> 00:08:55.350
So except the type error as.

135
00:08:55.370 --> 00:09:04.330
And I think most of the time I C E R R and we can print e r r or do something with it like this.

136
00:09:04.370 --> 00:09:09.500
And so now if I caused a type error like I am here I would just comment that when out we get and B must

137
00:09:09.500 --> 00:09:15.050
be folks we wrote that and then we printed the error which is unsupported operand types for division

138
00:09:15.290 --> 00:09:16.540
and string.

139
00:09:16.550 --> 00:09:21.010
So inside the official division function the operator.

140
00:09:21.090 --> 00:09:24.020
There's a line that is raising a type error.

141
00:09:24.440 --> 00:09:30.110
And basically this is what's being passed into that race and we can do the same thing for zero division

142
00:09:30.110 --> 00:09:31.380
error if we want it to.

143
00:09:31.760 --> 00:09:38.180
And the other thing that we could do was show you a second example is combine the errors into a single

144
00:09:38.180 --> 00:09:39.410
line with a tuple.

145
00:09:39.890 --> 00:09:44.350
So do type error like that and then I could get rid of this.

146
00:09:44.660 --> 00:09:51.950
But the thing is then we kind of have to be more general about the problem just say something went wrong

147
00:09:53.180 --> 00:09:58.370
and we can do it as error and then print error afterwards.

148
00:09:58.550 --> 00:10:04.250
But we can't specifically write a message appear that says he divided by zero or that was a type error

149
00:10:04.560 --> 00:10:10.750
and thus we could have an if statement and check is error type error where he's in his error.

150
00:10:10.760 --> 00:10:16.250
A zero division error but I prefer just to catch individual errors separately.

151
00:10:16.260 --> 00:10:22.700
Now if we run it we get something went wrong on supporting the operand types and if we also divide by

152
00:10:22.700 --> 00:10:31.010
zero run the same code we get the first little error and then the second time something went wrong.

153
00:10:31.010 --> 00:10:32.310
Division by zero.

154
00:10:32.390 --> 00:10:32.680
OK.

155
00:10:32.690 --> 00:10:38.030
So the point of that was to show you that you can accept more than one error you need a tuple using

156
00:10:38.030 --> 00:10:43.850
a single except But you could also just chain together multiple excepts if you are actually doing different

157
00:10:43.850 --> 00:10:44.630
things.

158
00:10:44.630 --> 00:10:49.730
So in this case we're just printing but we might want to call some other code only if we get a type

159
00:10:49.730 --> 00:10:51.950
error versus if we get a zero division error.

160
00:10:51.980 --> 00:10:53.330
We want to print something.

161
00:10:53.330 --> 00:10:59.310
So you can use more than one except you can use a single one and just use that tuple also.

162
00:10:59.360 --> 00:11:05.500
You can name the area give it a name with as and then refer to it inside of that except.

163
00:11:05.500 --> 00:11:05.980
All right.

164
00:11:06.020 --> 00:11:08.810
So that's pretty much it for try and except blocks.

165
00:11:08.810 --> 00:11:14.390
Next I'm going to show you something called PDB Python debugger debugger and you'll be able to step

166
00:11:14.390 --> 00:11:18.150
through your code one line at a time using PDB.

167
00:11:18.310 --> 00:11:18.680
So you then.
