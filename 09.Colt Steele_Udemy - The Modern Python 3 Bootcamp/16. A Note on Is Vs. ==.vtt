WEBVTT
1
00:00:00.240 --> 00:00:01.790
A song back for another video.

2
00:00:01.800 --> 00:00:07.770
Surprise surprise this one I'm going to mark is optional because this is going to go into something

3
00:00:07.770 --> 00:00:12.100
we haven't talked about which is how things are stored in memory in Python.

4
00:00:12.270 --> 00:00:17.730
So if you're intimidated already by this section I don't want to lose you here so come back to this

5
00:00:17.730 --> 00:00:18.390
later.

6
00:00:18.450 --> 00:00:20.410
It's kind of skipping ahead a little bit.

7
00:00:20.490 --> 00:00:24.000
So we talked about equals we're ready to test for equality.

8
00:00:24.000 --> 00:00:30.060
But there's another way to test for equality that you'll see which is it is I guess.

9
00:00:30.330 --> 00:00:32.040
And so it's I know it's kind of confusing.

10
00:00:32.070 --> 00:00:35.140
What's the difference between is and equals.

11
00:00:35.310 --> 00:00:41.610
If they both are testing for equality and I have a really dumb quote about depends on what the meaning

12
00:00:41.610 --> 00:00:43.630
of the word is is I don't know.

13
00:00:43.660 --> 00:00:45.020
I think you know I put that there.

14
00:00:45.360 --> 00:00:50.280
But essentially I mean it does depend on the meaning of is in this case and there is a different meaning

15
00:00:50.580 --> 00:00:52.140
than double equals.

16
00:00:52.230 --> 00:00:55.100
But first but see how they're similar.

17
00:00:55.230 --> 00:01:00.020
So we do something like this in python A equals one.

18
00:01:00.250 --> 00:01:06.420
Then we say OK that variable is one there's a equal one and that's true.

19
00:01:06.490 --> 00:01:08.180
Double equals equality is true.

20
00:01:08.320 --> 00:01:14.200
Same thing for a is one that also returns true.

21
00:01:14.590 --> 00:01:16.970
So OK how are they different.

22
00:01:17.230 --> 00:01:22.870
Well here's an example here's something we again we haven't really talked about but you've seen lists

23
00:01:22.900 --> 00:01:27.280
very very briefly at least you've seen them if you've been watching on the videos that have been skipping

24
00:01:27.280 --> 00:01:32.730
around which is totally fine if you do that but this is a list and they look the same to us as humans.

25
00:01:32.730 --> 00:01:35.380
Right that data inside is the same.

26
00:01:35.380 --> 00:01:37.290
We'll get to them in just a couple of sections.

27
00:01:37.300 --> 00:01:44.530
So when we used double equals it returns true because the value of the lists are the same.

28
00:01:44.860 --> 00:01:48.680
But when we do a is b it returns false.

29
00:01:48.970 --> 00:01:54.240
And the difference is that double equals is checking the values to see if they're the same.

30
00:01:54.280 --> 00:02:00.010
A is B is checking to see if they're stored in the same place in memory.

31
00:02:00.310 --> 00:02:05.920
So with lists they could look the same but they're different instances are different objects and we

32
00:02:05.920 --> 00:02:07.630
haven't really talked about objects.

33
00:02:07.630 --> 00:02:12.760
So this is sort of an awkward video for me to place in the course but I want to put it here just because

34
00:02:12.760 --> 00:02:14.790
we're already talking about double equals.

35
00:02:14.950 --> 00:02:18.670
But I also will reference it once we talk more about lists and objects.

36
00:02:18.790 --> 00:02:25.480
But the key thing is comparing the values which is a lot of the time what you actually want to do for

37
00:02:25.480 --> 00:02:26.400
lists and things.

38
00:02:26.450 --> 00:02:29.830
So if they look the same held the same data we used double equals.

39
00:02:29.950 --> 00:02:34.960
But if you want to see if it's exactly the same place and memory you use is.

40
00:02:35.010 --> 00:02:36.400
So here's another example.

41
00:02:36.580 --> 00:02:44.480
If we then take this list B and I make a new variable called C and I say C is equal to B.

42
00:02:44.520 --> 00:02:47.370
There are now pointing to the same list in memory.

43
00:02:47.650 --> 00:02:50.530
So B is c it's true.

44
00:02:50.910 --> 00:02:53.080
It sounds like kind of like a tongue twister.

45
00:02:53.080 --> 00:02:56.340
I guess I'd be too easy for a tongue twister but it sounds like jibberish.

46
00:02:56.500 --> 00:03:00.540
But the key thing again double equals checks values.

47
00:03:00.550 --> 00:03:03.970
This is Czech's memory.

48
00:03:04.750 --> 00:03:10.470
So here's you know is is only true if the if the variables reference the same item in memory.

49
00:03:10.480 --> 00:03:12.790
So if you care I will quickly demonstrate that.

50
00:03:12.790 --> 00:03:20.440
So I'll make a variable called X and I will set that to 13 and then I'll make another variable called

51
00:03:20.440 --> 00:03:23.550
Y set that 2:13.

52
00:03:24.100 --> 00:03:30.760
So if we do X equals equals Y returns true because they're pointing to the same place in memory and

53
00:03:30.810 --> 00:03:32.520
if they do X is Y.

54
00:03:32.720 --> 00:03:38.520
And that also returns true because every time he referenced the number 13 it's not a new object that

55
00:03:38.540 --> 00:03:40.270
is created in memory.

56
00:03:40.270 --> 00:03:43.590
And again we haven't talked about object so bear with me here.

57
00:03:43.870 --> 00:03:48.860
But what I really want to talk about is if we do something like this let's sort of x and y.

58
00:03:48.880 --> 00:03:58.000
Let's do a and b so a is a list just containing the numbers 1 and 2 and B is another list containing

59
00:03:58.030 --> 00:04:01.110
1 and 2 which we also haven't talked about list.

60
00:04:01.150 --> 00:04:02.900
So bear with me again.

61
00:04:03.490 --> 00:04:10.290
If we do a equals equals B that's true it contains the same values.

62
00:04:10.350 --> 00:04:11.820
They look the same.

63
00:04:11.820 --> 00:04:13.160
Now the order does matter.

64
00:04:13.170 --> 00:04:16.760
We haven't talked about that but really let's just say they look the same.

65
00:04:16.890 --> 00:04:18.820
So they are the same value.

66
00:04:19.050 --> 00:04:27.110
But if I do a is b it's not true because this is a separate object in memory.

67
00:04:27.300 --> 00:04:33.140
Every time these brackets are here a new list is created in memory and they're pointing to the error

68
00:04:33.140 --> 00:04:34.180
is pointing to this one.

69
00:04:34.290 --> 00:04:35.520
B is pointing to this one.

70
00:04:35.520 --> 00:04:36.830
They look the same.

71
00:04:36.900 --> 00:04:40.970
They're kind of they're holding the same data but they're unique in our computers memory.

72
00:04:41.220 --> 00:04:49.120
So a is not the same as B but if I make a variable called clone and I set that equal to a clone.

73
00:04:49.160 --> 00:04:53.180
Now holds it's pointing to the same part and memory as a.

74
00:04:53.180 --> 00:04:58.480
So there's kind of two arrows pointing to this you've got a pointing to that and clone.

75
00:04:58.670 --> 00:05:02.250
So if I do a is clone we get true.

76
00:05:02.420 --> 00:05:07.820
So most of the time we'll be using double equals to check for equal values but it will come up later

77
00:05:07.880 --> 00:05:13.400
where we care that we're checking for equality of objects like the exact same object in memory rather

78
00:05:13.400 --> 00:05:14.720
than just the values.

79
00:05:14.960 --> 00:05:17.780
OK so that's the difference between is and equals.
