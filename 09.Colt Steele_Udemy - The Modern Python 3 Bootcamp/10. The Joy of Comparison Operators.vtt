WEBVTT
1
00:00:00.260 --> 00:00:05.370
A welcome back and this video in the next couple we're going to take a look at what we can put here

2
00:00:05.940 --> 00:00:10.940
in the some condition is true portion of the if for elf statement.

3
00:00:11.040 --> 00:00:13.210
So what are the things that we can test for.

4
00:00:13.230 --> 00:00:14.970
So they have to return true or false.

5
00:00:15.090 --> 00:00:22.770
But so far we've only seen testing for direct equality is name equal exactly to Arya Stark but we'll

6
00:00:22.770 --> 00:00:28.470
see a couple other options in this video called comparison operators so comparison operators allow us

7
00:00:28.470 --> 00:00:31.060
to compare two pieces of data.

8
00:00:31.320 --> 00:00:37.950
And we've already seen one example the equality operator which is two equal signs remember one equal

9
00:00:37.950 --> 00:00:40.110
sign will actually assign a variable.

10
00:00:40.170 --> 00:00:42.560
So we don't want to be doing that inside an if.

11
00:00:42.660 --> 00:00:49.440
So we want to equal signs and that will be truthy it will return true if A is equal to be if they have

12
00:00:49.440 --> 00:00:50.600
the same value.

13
00:00:50.790 --> 00:00:55.900
And this little table I made you can put one in for a and one for B.

14
00:00:55.950 --> 00:00:57.750
So one equals one.

15
00:00:57.810 --> 00:00:58.830
That's true.

16
00:00:58.920 --> 00:01:05.400
So over here in my terminal I could do something like inside a price on three I could do you know one

17
00:01:05.400 --> 00:01:07.140
equals equals one.

18
00:01:07.350 --> 00:01:10.060
And we get true I could do one equals equals two.

19
00:01:10.110 --> 00:01:11.170
And that's false.

20
00:01:11.310 --> 00:01:15.480
And you know same thing for strings is a equal to capital A.

21
00:01:15.600 --> 00:01:16.600
That's false.

22
00:01:16.590 --> 00:01:17.130
They're different.

23
00:01:17.130 --> 00:01:19.000
Remember capitalization matters.

24
00:01:19.020 --> 00:01:20.830
Typically we would use variables.

25
00:01:20.850 --> 00:01:23.780
We're not going to just have an if statement if one is equal to one.

26
00:01:23.780 --> 00:01:24.900
Do this.

27
00:01:24.900 --> 00:01:28.060
You might as well just say if true or always do this.

28
00:01:28.220 --> 00:01:28.460
OK.

29
00:01:28.470 --> 00:01:30.370
So back to our comparison operators.

30
00:01:30.420 --> 00:01:34.290
The next one that goes along with equality is not equals.

31
00:01:34.410 --> 00:01:37.210
So it's an exclamation point and a single equal sign.

32
00:01:37.230 --> 00:01:46.070
So this returns true if A is not equal to be so in this case one is not equal to one is false.

33
00:01:46.170 --> 00:01:48.370
So it returns false.

34
00:01:48.480 --> 00:01:52.620
So we can test that out just do you know one not equals one.

35
00:01:52.710 --> 00:02:00.930
We get false or let's make variable as time called color set it equal to Teale and then we can test

36
00:02:01.140 --> 00:02:03.920
if color is not equal to purple.

37
00:02:04.060 --> 00:02:05.800
But will this return true.

38
00:02:05.880 --> 00:02:08.750
Because Teale is not equal to purple.

39
00:02:08.850 --> 00:02:13.360
So everything I'm showing you right now you could easily put into an IF or ever.

40
00:02:13.440 --> 00:02:18.440
But just for the sake of keeping this brief I'm just typing them immediately and getting true or false.

41
00:02:18.600 --> 00:02:20.840
Next are greater than and less than.

42
00:02:21.090 --> 00:02:25.930
So you've probably seen these before but the idea is that one value is greater than the other.

43
00:02:26.010 --> 00:02:32.190
If a is greater than be greater then returns true if it's not returns false and the opposite is true

44
00:02:32.190 --> 00:02:33.250
for less than.

45
00:02:33.270 --> 00:02:39.840
So in this case both examples are actually false because if we put one for a and one for B one is not

46
00:02:39.840 --> 00:02:42.100
greater than 1 1 it's not less than 1.

47
00:02:42.210 --> 00:02:45.280
It's exactly equal to 1.

48
00:02:45.510 --> 00:02:46.700
So we could try this.

49
00:02:46.710 --> 00:02:51.780
We'll start with numbers so we can do things like you know it's one less than three that should return

50
00:02:51.960 --> 00:02:54.210
TRUE is negative 100.

51
00:02:54.230 --> 00:02:57.410
Greater than negative 200.

52
00:02:57.600 --> 00:02:58.610
That's true.

53
00:02:58.920 --> 00:03:01.020
This is more negative it's smaller.

54
00:03:01.020 --> 00:03:08.520
The other thing that we could do is work with strings and I advise you not to do this comparing strings

55
00:03:08.640 --> 00:03:11.210
with greater than the most and it does work.

56
00:03:11.430 --> 00:03:11.790
Right.

57
00:03:11.790 --> 00:03:15.950
So we could say is lower case a less than upper case a.

58
00:03:16.260 --> 00:03:22.420
And that's false or we could do is lower case upper case a less than lower case AA.

59
00:03:22.770 --> 00:03:23.960
And that's true.

60
00:03:24.240 --> 00:03:33.820
And what about a B is a B less than if they are greater than let's do greater than it's true.

61
00:03:34.100 --> 00:03:38.180
The reason they advise you not to do this is just that it can get confusing when you have to worry about

62
00:03:38.180 --> 00:03:38.870
case.

63
00:03:38.930 --> 00:03:43.370
And honestly there's not many times when you're trying to figure out if a letter comes before another

64
00:03:43.370 --> 00:03:47.380
letter or an entire string comes before another string.

65
00:03:47.450 --> 00:03:51.500
It is possible the way Python orders them is called lexicographical ordering.

66
00:03:51.590 --> 00:03:54.740
It's essentially alphabetical ordering.

67
00:03:54.740 --> 00:03:59.070
Sort of like what the dictionary would use but we don't need to go into it that much.

68
00:03:59.090 --> 00:04:05.040
Just be aware that you can test for greater than and less than with strings but almost ninety nine percent

69
00:04:05.040 --> 00:04:10.040
of the time you're only going to care about direct equality or we'll find ways to figure out is the

70
00:04:10.040 --> 00:04:12.740
first letter of a string equal to something.

71
00:04:12.920 --> 00:04:18.020
But we'll leave that for now and move on to the last two which are greater than or equal to and less

72
00:04:18.020 --> 00:04:19.390
than or equal to.

73
00:04:19.400 --> 00:04:25.340
So in this case start with greater than or equal to the whole thing returns true if A is greater than

74
00:04:25.490 --> 00:04:26.870
or equal to be.

75
00:04:26.900 --> 00:04:31.570
So the whole thing for us returns true if one is greater than or equal to 1.

76
00:04:31.790 --> 00:04:36.760
And that's true because one is equal to one and the opposite applies for less than or equal to.

77
00:04:36.980 --> 00:04:38.300
So we could do a simple example.

78
00:04:38.330 --> 00:04:45.730
Age equals 18 and then age is greater than or equal to 18.

79
00:04:45.800 --> 00:04:49.090
We'll say that you're an adult and that's true.

80
00:04:49.350 --> 00:05:00.330
And we could use this in an IF just doing if age is greater than or equal to 18 then we'll do a print.

81
00:05:00.620 --> 00:05:03.400
You are an adult at least in the US.

82
00:05:03.590 --> 00:05:10.760
I don't know about other countries hit enter again and we get you are an adult because age is equal

83
00:05:10.760 --> 00:05:11.360
to 18.

84
00:05:11.360 --> 00:05:20.630
So if we left off an equal sign just add greater than you don't get anything because age is not greater

85
00:05:20.630 --> 00:05:22.610
than 18 equal to 18.

86
00:05:22.610 --> 00:05:22.880
All right.

87
00:05:22.880 --> 00:05:24.750
So those are comparison operators.

88
00:05:24.920 --> 00:05:28.060
There's a couple of them as we've seen most of the time.

89
00:05:28.070 --> 00:05:34.190
Well a lot of the time you're working with equals and not equals greater than less then greater than

90
00:05:34.190 --> 00:05:37.030
equal to less than or equal to are also common.

91
00:05:37.040 --> 00:05:40.980
But at the end of the day all of them return either true or false.

92
00:05:41.060 --> 00:05:46.040
Every time they run and we can plug them directly in like a little Lego block we put them in the if

93
00:05:46.040 --> 00:05:49.750
statement or in the Elif and they return true or false.

94
00:05:49.780 --> 00:05:53.000
And the gatekeepers for which branch of the code runs.
