WEBVTT
1
1

00:00:04.680  -->  00:00:07.020
In this video I'm going to cover the
2

2

00:00:07.020  -->  00:00:09.330
lightning quick differences, differences
3

3

00:00:09.330  -->  00:00:11.850
that are just informational or they
4

4

00:00:11.850  -->  00:00:14.309
don't require a lot of explanation.
5

5

00:00:14.309  -->  00:00:15.629
So, the first one I'm going to start with,
6

6

00:00:15.629  -->  00:00:17.490
which I'm sure you've already gathered
7

7

00:00:17.490  -->  00:00:20.280
is that you don't have to put semicolons
8

8

00:00:20.280  -->  00:00:24.060
at the end of a statement. Now, it's okay
9

9

00:00:24.060  -->  00:00:26.730
if you do it, let's put a semicolon here
10

10

00:00:26.730  -->  00:00:29.640
at the end of this line and we'll see
11

11

00:00:29.640  -->  00:00:31.980
that you don't get an error, but IntelliJ
12

12

00:00:31.980  -->  00:00:34.140
grays it out and it says redundant
13

13

00:00:34.140  -->  00:00:36.420
semicolon, whenever you see something
14

14

00:00:36.420  -->  00:00:38.580
great out in IntelliJ it usually means
15

15

00:00:38.580  -->  00:00:40.080
that you're not using it, like for
16

16

00:00:40.080  -->  00:00:42.090
example, employees is grayed out here
17

17

00:00:42.090  -->  00:00:44.190
because we're not using it or you don't
18

18

00:00:44.190  -->  00:00:45.810
need it, which is the case for the
19

19

00:00:45.810  -->  00:00:49.350
semicolon. Now this might be a hard habit
20

20

00:00:49.350  -->  00:00:51.030
for you to break, I didn't find it that
21

21

00:00:51.030  -->  00:00:52.860
hard to break actually. Now when I go
22

22

00:00:52.860  -->  00:00:54.540
back to Java though, I have to remember
23

23

00:00:54.540  -->  00:00:56.820
to put the semicolon, so there is that.
24

24

00:00:56.820  -->  00:00:59.100
But if you're finding it a hard habit to
25

25

00:00:59.100  -->  00:01:01.170
break, at least it's not an error but
26

26

00:01:01.170  -->  00:01:03.150
obviously the more you work with Kotlin,
27

27

00:01:03.150  -->  00:01:04.890
you don't want to be putting semicolons
28

28

00:01:04.890  -->  00:01:07.080
there because with Kotlin the more
29

29

00:01:07.080  -->  00:01:09.630
concise the code, the better. So that's
30

30

00:01:09.630  -->  00:01:12.480
difference number one. So the next thing I
31

31

00:01:12.480  -->  00:01:13.980
want to bring to your attention isn't
32

32

00:01:13.980  -->  00:01:16.410
really a difference, but they're used a
33

33

00:01:16.410  -->  00:01:17.910
lot in Kotlin so I want you to know
34

34

00:01:17.910  -->  00:01:19.350
about them and that's the use of
35

35

00:01:19.350  -->  00:01:22.230
wrappers. We saw one already in the hello
36

36

00:01:22.230  -->  00:01:24.390
world application when we use print line
37

37

00:01:24.390  -->  00:01:26.800
rather than system.out.println,
38

38

00:01:26.800  -->  00:01:28.650
now under the covers we were still
39

39

00:01:28.650  -->  00:01:30.690
using system.out.println, but
40

40

00:01:30.690  -->  00:01:32.850
the Kotlin standard library has wrappers
41

41

00:01:32.850  -->  00:01:34.680
for some of the more commonly used Java
42

42

00:01:34.680  -->  00:01:37.380
methods, so I just wanted you to be aware
43

43

00:01:37.380  -->  00:01:39.210
of them because you'll often see the
44

44

00:01:39.210  -->  00:01:41.790
term wrapper when people are talking or
45

45

00:01:41.790  -->  00:01:43.920
writing about Kotlin. Okay next is the
46

46

00:01:43.920  -->  00:01:47.790
concept of soft keywords, now in Java you
47

47

00:01:47.790  -->  00:01:50.070
can't use a keyword for anything other
48

48

00:01:50.070  -->  00:01:53.670
than its intended purpose. So if a word
49

49

00:01:53.670  -->  00:01:57.240
is reserved in Java, it's a keyword you
50

50

00:01:57.240  -->  00:01:58.890
can only use it for what it's intended
51

51

00:01:58.890  -->  00:02:01.470
to be used for. You can't use it anywhere else.
52

52

00:02:01.470  -->  00:02:04.110
Kotlin has the notion of hard keywords
53

53

00:02:04.110  -->  00:02:06.600
and soft keywords. Now hard keywords are
54

54

00:02:06.600  -->  00:02:09.810
just like Java, you can only use them for
55

55

00:02:09.810  -->  00:02:12.209
their intended purpose, but soft keywords
56

56

00:02:12.209  -->  00:02:14.430
are a little bit more relaxed. You can
57

57

00:02:14.430  -->  00:02:17.430
actually use them in other places as
58

58

00:02:17.430  -->  00:02:18.800
long as you're not using
59

59

00:02:18.800  -->  00:02:21.030
them where they have a special
60

60

00:02:21.030  -->  00:02:23.129
meaning. So for example you could use a
61

61

00:02:23.129  -->  00:02:25.799
soft key word as a variable name. If you
62

62

00:02:25.799  -->  00:02:28.349
want it to, as long as you know you're
63

63

00:02:28.349  -->  00:02:30.360
not using that variable right where you
64

64

00:02:30.360  -->  00:02:32.159
would normally use a soft key word as
65

65

00:02:32.159  -->  00:02:35.190
its intended to be used. Now personally,
66

66

00:02:35.190  -->  00:02:37.470
I wouldn't do this, I think that it could
67

67

00:02:37.470  -->  00:02:39.750
lead to some pretty confusing code and
68

68

00:02:39.750  -->  00:02:42.180
it might run you into trouble at some
69

69

00:02:42.180  -->  00:02:44.519
point, but you can do it the language
70

70

00:02:44.519  -->  00:02:47.099
won't stop you from doing it and once
71

71

00:02:47.099  -->  00:02:49.079
again just like wrappers, I want it to
72

72

00:02:49.079  -->  00:02:50.700
bring them to your attention, because you
73

73

00:02:50.700  -->  00:02:52.410
might see the term soft key word and
74

74

00:02:52.410  -->  00:02:55.260
wonder what people are talking about.
75

75

00:02:55.260  -->  00:02:57.329
Alright, another difference between Kotlin and
76

76

00:02:57.329  -->  00:02:59.069
Java and this once again is in the
77

77

00:02:59.069  -->  00:03:01.650
pursuit of more concise code, is that you
78

78

00:03:01.650  -->  00:03:03.780
can use square brackets to access
79

79

00:03:03.780  -->  00:03:06.359
elements in collections. Now, we'll cover
80

80

00:03:06.359  -->  00:03:08.250
collections later in the course, but I'll
81

81

00:03:08.250  -->  00:03:11.269
create one now just to illustrate this.
82

82

00:03:11.269  -->  00:03:13.890
So let me make a few blank lines here and
83

83

00:03:13.890  -->  00:03:17.730
I'll say val names and I'll make this an
84

84

00:03:17.730  -->  00:03:21.000
array list, we don't need the angle
85

85

00:03:21.000  -->  00:03:22.260
brackets because the compiler will
86

86

00:03:22.260  -->  00:03:27.660
figure it out and we'll say John, Jane
87

87

00:03:27.660  -->  00:03:32.250
and Mary. Now if we want it to print out
88

88

00:03:32.250  -->  00:03:34.919
Jane or the second element, we can just
89

89

00:03:34.919  -->  00:03:39.630
go print line names one and that will
90

90

00:03:39.630  -->  00:03:45.900
work. So if we run this, we'll see that
91

91

00:03:45.900  -->  00:03:48.060
Jane is printed out so this is a way
92

92

00:03:48.060  -->  00:03:49.829
that Kotlin lets us write more concise
93

93

00:03:49.829  -->  00:03:53.669
code, instead of using names.get, we can
94

94

00:03:53.669  -->  00:03:57.030
just use the square brackets as if the
95

95

00:03:57.030  -->  00:03:59.459
collection is an array and note that
96

96

00:03:59.459  -->  00:04:01.019
when you're working with a map, you can
97

97

00:04:01.019  -->  00:04:03.090
also use the key as an index and we'll
98

98

00:04:03.090  -->  00:04:05.150
see that later when we cover collections.
99

99

00:04:05.150  -->  00:04:08.489
Okay, another informational sort of
100

100

00:04:08.489  -->  00:04:10.800
called out and that's the string class.
101

101

00:04:10.800  -->  00:04:13.349
Now, we use strings a lot in our java
102

102

00:04:13.349  -->  00:04:16.560
applications, Kotlin has its own string
103

103

00:04:16.560  -->  00:04:17.789
class and I wanted to draw your
104

104

00:04:17.789  -->  00:04:20.900
attention to that, because its class
105

105

00:04:20.900  -->  00:04:24.570
hides some methods that exist in the
106

106

00:04:24.570  -->  00:04:26.280
Java string class, so when you're using
107

107

00:04:26.280  -->  00:04:28.620
string in a Kotlin application you're
108

108

00:04:28.620  -->  00:04:31.710
using Kotlin string class and so if
109

109

00:04:31.710  -->  00:04:35.669
you're trying to call a method that you would normally
110

110

00:04:35.669  -->  00:04:37.290
call in the string class and it's not
111

111

00:04:37.290  -->  00:04:40.320
compiling or it doesn't exist, this will
112

112

00:04:40.320  -->  00:04:42.540
be why. Let's pop over to the
113

113

00:04:42.540  -->  00:04:44.460
documentation for the Kotlin string
114

114

00:04:44.460  -->  00:04:47.430
class, so here we are at the
115

115

00:04:47.430  -->  00:04:50.040
documentation and you can see that it's
116

116

00:04:50.040  -->  00:04:53.160
in the Kotlin package, where a lot of the
117

117

00:04:53.160  -->  00:04:54.780
data type classes live, in fact I think
118

118

00:04:54.780  -->  00:04:57.540
all of them do. And as we can see, it's a
119

119

00:04:57.540  -->  00:05:01.650
pretty big class, so I suggest that you
120

120

00:05:01.650  -->  00:05:03.570
come over and take a look at this class.
121

121

00:05:03.570  -->  00:05:06.510
One thing I will point out is the length
122

122

00:05:06.510  -->  00:05:09.150
property in Java of course length is a
123

123

00:05:09.150  -->  00:05:12.270
method but in Kotlin length is a
124

124

00:05:12.270  -->  00:05:13.889
property, so if you want to get the
125

125

00:05:13.889  -->  00:05:15.750
length of a string there's no reason to
126

126

00:05:15.750  -->  00:05:18.570
call a function, you'll just access the
127

127

00:05:18.570  -->  00:05:21.690
property. So as I said, take a look at the
128

128

00:05:21.690  -->  00:05:24.030
string class, because when you're writing
129

129

00:05:24.030  -->  00:05:26.490
a Kotlin application and you're using
130

130

00:05:26.490  -->  00:05:28.320
string, you're actually using this class
131

131

00:05:28.320  -->  00:05:30.500
you're not using java.line.string.
132

132

00:05:30.500  -->  00:05:32.250
Oo it's possible that something
133

133

00:05:32.250  -->  00:05:34.320
might have changed about a method that
134

134

00:05:34.320  -->  00:05:37.020
you use a lot. So I suggest that you pop
135

135

00:05:37.020  -->  00:05:39.030
over and take some time to look at the
136

136

00:05:39.030  -->  00:05:40.800
string documentation because of course
137

137

00:05:40.800  -->  00:05:43.050
string is the very popular class, we use it
138

138

00:05:43.050  -->  00:05:45.270
all the time. Let's go back to
139

139

00:05:45.270  -->  00:05:49.169
IntelliJ now. Okay so another important
140

140

00:05:49.169  -->  00:05:51.080
difference between Kotlin and Java is
141

141

00:05:51.080  -->  00:05:54.060
exceptions, in Java you have to declare
142

142

00:05:54.060  -->  00:05:55.770
when a method can throw a checked
143

143

00:05:55.770  -->  00:05:57.990
exception, for example if a method can
144

144

00:05:57.990  -->  00:05:59.880
throw an io exception and it doesn't
145

145

00:05:59.880  -->  00:06:01.860
catch it in its code then it has to
146

146

00:06:01.860  -->  00:06:04.300
declare that it throws io exception.
147

147

00:06:04.300  -->  00:06:07.410
Well, not so in Kotlin because Kotlin doesn't
148

148

00:06:07.410  -->  00:06:09.090
distinguish between checked and
149

149

00:06:09.090  -->  00:06:11.880
unchecked exceptions, so you no longer
150

150

00:06:11.880  -->  00:06:13.710
have to declare that a function can
151

151

00:06:13.710  -->  00:06:16.410
throw an exception, in fact the throws
152

152

00:06:16.410  -->  00:06:18.780
keyword doesn't exist in Kotlin so if
153

153

00:06:18.780  -->  00:06:21.389
you try to declare which exceptions the
154

154

00:06:21.389  -->  00:06:22.950
function throws, it's not going to
155

155

00:06:22.950  -->  00:06:24.900
compile. So if you're wondering why you
156

156

00:06:24.900  -->  00:06:26.940
never see functions throwing any
157

157

00:06:26.940  -->  00:06:29.400
exceptions, that's why. It's not that they
158

158

00:06:29.400  -->  00:06:31.470
can't raise exceptions, it's just that
159

159

00:06:31.470  -->  00:06:34.050
all exceptions are unchecked and so you
160

160

00:06:34.050  -->  00:06:37.440
don't have to declare them. Okay next the
161

161

00:06:37.440  -->  00:06:40.110
ternary operator and if you forgotten
162

162

00:06:40.110  -->  00:06:42.060
what ternary operator is,
163

163

00:06:42.060  -->  00:06:46.990
it's when you do something like X,Y,Z,
164

164

00:06:46.990  -->  00:06:49.020
so you know this is, X is the
165

165

00:06:49.020  -->  00:06:51.690
condition and then if it's true, normally
166

166

00:06:51.690  -->  00:06:53.880
there's a variable here you know what
167

167

00:06:53.880  -->  00:06:59.160
my q equals X, Y, Z. So, if X is true Y gets
168

168

00:06:59.160  -->  00:07:01.350
assigned to Q and if it's false that
169

169

00:07:01.350  -->  00:07:03.660
gets assigned to Q well this doesn't
170

170

00:07:03.660  -->  00:07:06.660
exist in Kotlin, it's been replaced by
171

171

00:07:06.660  -->  00:07:10.320
the if statement, in fact in Kotlin if is
172

172

00:07:10.320  -->  00:07:12.720
an expression. So we will be covering
173

173

00:07:12.720  -->  00:07:14.520
this in more detail later, but for now
174

174

00:07:14.520  -->  00:07:17.450
just know that the ternary operator
175

175

00:07:17.450  -->  00:07:23.100
is gone. No longer there in Kotlin. Okay,
176

176

00:07:23.100  -->  00:07:24.960
the next difference involves the for loop.
177

177

00:07:24.960  -->  00:07:26.910
Now we're going to cover loops in more
178

178

00:07:26.910  -->  00:07:29.640
detail later on, for now you just have to
179

179

00:07:29.640  -->  00:07:32.310
know that the original for loop that we
180

180

00:07:32.310  -->  00:07:34.200
all know and love doesn't exist in
181

181

00:07:34.200  -->  00:07:36.870
Kotlin. So in Kotlin you cannot do this,
182

182

00:07:36.870  -->  00:07:40.830
for i, well let's go into well that
183

183

00:07:40.830  -->  00:07:42.330
wouldn't even work in Kotlin, but
184

184

00:07:42.330  -->  00:07:47.300
i equals 0, i less than you know 20.
185

185

00:07:47.670  -->  00:07:51.810
i++ and then you do something. This form
186

186

00:07:51.810  -->  00:07:54.210
of the for loop doesn't exist in Kotlin.
187

187

00:07:54.210  -->  00:07:56.460
Of course in Java, you probably have this.
188

188

00:07:56.460  -->  00:07:59.190
But this doesn't exist, Kotlin doesn't
189

189

00:07:59.190  -->  00:08:01.830
understand this and as I said, we'll go
190

190

00:08:01.830  -->  00:08:04.170
over for loops in much more detail,
191

191

00:08:04.170  -->  00:08:08.970
later in the course. So another difference
192

192

00:08:08.970  -->  00:08:11.700
between Kotlin and Java is that Kotlin
193

193

00:08:11.700  -->  00:08:14.220
doesn't have a static keyword and we'll
194

194

00:08:14.220  -->  00:08:16.470
see as we progress through the course,
195

195

00:08:16.470  -->  00:08:20.070
how Kotlin has replaced this keyword
196

196

00:08:20.070  -->  00:08:21.360
because it depends on whether you're
197

197

00:08:21.360  -->  00:08:22.620
dealing with a function or whether
198

198

00:08:22.620  -->  00:08:24.240
you're dealing with a variable. Now one
199

199

00:08:24.240  -->  00:08:25.890
way that it has done it of course is
200

200

00:08:25.890  -->  00:08:27.900
with top-level functions and we've
201

201

00:08:27.900  -->  00:08:30.390
already seen that. Here, we have the main
202

202

00:08:30.390  -->  00:08:32.430
function outside of a class and under
203

203

00:08:32.430  -->  00:08:34.080
the covers, this is actually a static
204

204

00:08:34.080  -->  00:08:36.330
function. Now when I say that the static
205

205

00:08:36.330  -->  00:08:38.700
keyword is gone, the concept of static is
206

206

00:08:38.700  -->  00:08:40.469
still there, because don't forget Kotlin
207

207

00:08:40.469  -->  00:08:42.690
when you're targeting the jvm is being
208

208

00:08:42.690  -->  00:08:46.100
compiled down to java bytecode which
209

209

00:08:46.100  -->  00:08:49.350
understands static and what static.
210

210

00:08:49.350  -->  00:08:51.450
So, when we say it's not there we mean
211

211

00:08:51.450  -->  00:08:54.390
syntactically, the concept is still there
212

212

00:08:54.390  -->  00:08:59.100
it's just that the way that you deal with static
213

213

00:08:59.100  -->  00:09:00.990
functions and static variables is
214

214

00:09:00.990  -->  00:09:03.300
different and we'll see the different
215

215

00:09:03.300  -->  00:09:05.430
ways as we progress through the course.
216

216

00:09:05.430  -->  00:09:07.260
Okay, the next difference which I'm sure
217

217

00:09:07.260  -->  00:09:09.330
you've also already gathered is that
218

218

00:09:09.330  -->  00:09:12.270
there is no new keyword, so we never have
219

219

00:09:12.270  -->  00:09:14.460
to use new and this is just another way
220

220

00:09:14.460  -->  00:09:17.700
of Kotlin making it more concise, I mean
221

221

00:09:17.700  -->  00:09:19.680
if the common pattern when you're
222

222

00:09:19.680  -->  00:09:22.050
creating an instance is to always go new
223

223

00:09:22.050  -->  00:09:24.750
and then you know the class name with an
224

224

00:09:24.750  -->  00:09:27.000
uppercase letter and then the
225

225

00:09:27.000  -->  00:09:30.900
constructor parameters. Why do we need new?
226

226

00:09:30.900  -->  00:09:32.670
The compiler can figure out
227

227

00:09:32.670  -->  00:09:34.350
what you're trying to do just with this
228

228

00:09:34.350  -->  00:09:36.420
part of the statement here, so Kotlin has
229

229

00:09:36.420  -->  00:09:39.900
dropped new and you don't use it in Kotlin.
230

230

00:09:39.900  -->  00:09:41.610
Okay, so that's it for the
231

231

00:09:41.610  -->  00:09:43.560
lightning quick differences.
232

232

00:09:43.560  -->  00:09:44.910
Now, obviously there are a lot more
233

233

00:09:44.910  -->  00:09:47.190
differences between Kotlin and Java.
234

234

00:09:47.190  -->  00:09:49.530
I mean, you know in in some sense that's
235

235

00:09:49.530  -->  00:09:51.300
what the rest of this course is about,
236

236

00:09:51.300  -->  00:09:54.120
but if you're trying to get your feet
237

237

00:09:54.120  -->  00:09:55.920
wet by writing some Kotlin code, now you
238

238

00:09:55.920  -->  00:09:58.700
already know a few things that you can't do.
239

239

00:09:58.700  -->  00:10:02.240
And that's it for this video.
