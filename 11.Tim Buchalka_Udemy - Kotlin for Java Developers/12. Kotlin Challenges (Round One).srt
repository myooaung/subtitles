1
1

00:00:04,650  -->  00:00:07,080
Alright, so now it's time to practice
2

2

00:00:07,080  -->  00:00:09,389
what you've learned and so we're going
3

3

00:00:09,389  -->  00:00:12,780
to go through a series of small steps in
4

4

00:00:12,780  -->  00:00:16,349
the form of challenges and step one is
5

5

00:00:16,349  -->  00:00:18,900
up on the screen here, this is the only
6

6

00:00:18,900  -->  00:00:20,520
challenge that will have a slide, because
7

7

00:00:20,520  -->  00:00:23,610
after this, we'll be in IntelliJ. So this
8

8

00:00:23,610  -->  00:00:25,259
will be a breeze for those of you who
9

9

00:00:25,259  -->  00:00:27,540
are familiar with IntelliJ, but for those
10

10

00:00:27,540  -->  00:00:30,059
of you who aren't, this will be for you.
11

11

00:00:30,059  -->  00:00:32,880
However, everybody should do this, create
12

12

00:00:32,880  -->  00:00:35,309
a new Kotlin project called challenge
13

13

00:00:35,309  -->  00:00:37,679
one and then add a package called
14

14

00:00:37,679  -->  00:00:41,250
academy learn programming challenge one
15

15

00:00:41,250  -->  00:00:44,550
to the project, after that add a file to
16

16

00:00:44,550  -->  00:00:46,859
the package called challenge one and
17

17

00:00:46,859  -->  00:00:49,519
then add the main function to the file.
18

18

00:00:49,519  -->  00:00:52,589
So pause the video now and go ahead and
19

19

00:00:52,589  -->  00:00:55,230
do that and when you have your project
20

20

00:00:55,230  -->  00:00:58,589
and package and file and main function
21

21

00:00:58,589  -->  00:01:02,719
created come back to see the solution.
22

22

00:01:02,719  -->  00:01:05,790
Alright, welcome back so this is just a
23

23

00:01:05,790  -->  00:01:07,650
matter of creating a project, so we'll go
24

24

00:01:07,650  -->  00:01:11,820
to file, new, project you want to make
25

25

00:01:11,820  -->  00:01:13,410
sure that Kotlin is selected on the left
26

26

00:01:13,410  -->  00:01:15,900
hand side and Kotlin jvm on the right
27

27

00:01:15,900  -->  00:01:18,360
hand side, we'll click Next and we're
28

28

00:01:18,360  -->  00:01:20,280
going to call this one challenge1
29

29

00:01:20,280  -->  00:01:21,720
and click finish.
30

30

00:01:21,720  -->  00:01:26,420
And I'm going to open it in this window.
31

31

00:01:26,420  -->  00:01:29,790
So, we have our new project here so I'm
32

32

00:01:29,790  -->  00:01:32,550
going to expand the project node right
33

33

00:01:32,550  -->  00:01:34,790
click on the source folder go to new,
34

34

00:01:34,790  -->  00:01:36,810
package and we're going to call this
35

35

00:01:36,810  -->  00:01:42,900
package academy.learnprogramming.challenge1
36

36

00:01:42,900  -->  00:01:45,840
and click ok and then
37

37

00:01:45,840  -->  00:01:47,670
we'll right-click on the package and go
38

38

00:01:47,670  -->  00:01:50,460
new, Kotlin class or file and we'll call
39

39

00:01:50,460  -->  00:01:54,390
this challenge1 and click ok and at
40

40

00:01:54,390  -->  00:01:56,130
this point, all we have to do is add the
41

41

00:01:56,130  -->  00:01:58,410
main method, so I'll just type in main
42

42

00:01:58,410  -->  00:02:01,680
and hit enter and that's it. That's the
43

43

00:02:01,680  -->  00:02:03,360
first part of the challenge completed,
44

44

00:02:03,360  -->  00:02:05,280
I hope you did well and you managed to
45

45

00:02:05,280  -->  00:02:07,710
create an IntelliJ project and file
46

46

00:02:07,710  -->  00:02:11,790
and package and main function. Alright so
47

47

00:02:11,790  -->  00:02:13,319
the next thing I'd like you to do and
48

48

00:02:13,319  -->  00:02:15,209
I'll type this into IntelliJ now is
49

49

00:02:15,209  -->  00:02:18,510
declare two immutable
50

50

00:02:18,510  -->  00:02:22,909
strings or rather string variables
51

51

00:02:22,909  -->  00:02:28,680
called hello one and hello two. Assign
52

52

00:02:28,680  -->  00:02:35,459
hello to both variables and that's it,
53

53

00:02:35,459  -->  00:02:39,810
pretty easy. So pause the video and give
54

54

00:02:39,810  -->  00:02:44,519
it a shot. Okay welcome back! I hope you
55

55

00:02:44,519  -->  00:02:48,359
completed that challenge okay so let's do it!
56

56

00:02:48,359  -->  00:02:50,489
We're going to start with val because
57

57

00:02:50,489  -->  00:02:53,849
we want immutable string variables which
58

58

00:02:53,849  -->  00:02:55,319
means they can't be changed and those
59

59

00:02:55,319  -->  00:02:57,870
are val variables we'll call the first
60

60

00:02:57,870  -->  00:02:59,940
one hello and we'll assign it the string
61

61

00:02:59,940  -->  00:03:03,299
hello and then do the same thing for the
62

62

00:03:03,299  -->  00:03:05,639
second one, hello two equals hello
63

63

00:03:05,639  -->  00:03:10,440
perhaps you did this and that's okay,
64

64

00:03:10,440  -->  00:03:11,940
that's not the end of the world.
65

65

00:03:11,940  -->  00:03:13,709
You don't really need to do that but it's
66

66

00:03:13,709  -->  00:03:16,680
fine if you do it. As I said, when you're
67

67

00:03:16,680  -->  00:03:18,389
first learning Kotlin your first crack
68

68

00:03:18,389  -->  00:03:20,280
at something will often be more verbose
69

69

00:03:20,280  -->  00:03:21,750
than it has to be and then you can
70

70

00:03:21,750  -->  00:03:23,760
experiment and take certain parts of the
71

71

00:03:23,760  -->  00:03:25,739
statement away and see if you get any
72

72

00:03:25,739  -->  00:03:29,069
errors. Okay so the next thing I want you
73

73

00:03:29,069  -->  00:03:33,780
to do is using one line of code and I do
74

74

00:03:33,780  -->  00:03:39,810
mean one line of code, test whether hello
75

75

00:03:39,810  -->  00:03:47,069
one and hello two our referentially
76

76

00:03:47,069  -->  00:03:51,410
equal. That's the hard one to spell and
77

77

00:03:51,410  -->  00:03:55,739
print the result. So using one line of
78

78

00:03:55,739  -->  00:03:58,230
code, test whether hello one and hello two
79

79

00:03:58,230  -->  00:04:01,019
are referentially equal and print the
80

80

00:04:01,019  -->  00:04:04,500
result. Pause the video now and give it a try.
81

81

00:04:04,990  -->  00:04:09,419
Okay, welcome back I'm going to
82

82

00:04:09,419  -->  00:04:11,519
include some descriptive text in my
83

83

00:04:11,519  -->  00:04:14,190
solution, but it's okay if you
84

84

00:04:14,190  -->  00:04:17,190
include any. So here's what I did print
85

85

00:04:17,190  -->  00:04:25,800
line, hello one is referentially equal to
86

86

00:04:25,800  -->  00:04:31,280
hello two and then I'm using an expression
87

87

00:04:31,280  -->  00:04:35,600
as a substitution value and hello one,
88

88

00:04:35,600  -->  00:04:37,490
and of course we want to use the triple
89

89

00:04:37,490  -->  00:04:42,250
equals to test for referential equality.
90

90

00:04:42,250  -->  00:04:45,200
So, we're using triple equals and we're
91

91

00:04:45,200  -->  00:04:48,620
comparing hello one to hello two. So let's
92

92

00:04:48,620  -->  00:04:55,610
run and see what we get. And we get hello
93

93

00:04:55,610  -->  00:04:58,520
one is referentially equal to hello two
94

94

00:04:58,520  -->  00:05:01,820
and it says that that's true. You might be
95

95

00:05:01,820  -->  00:05:04,310
surprised at the result. I hope you
96

96

00:05:04,310  -->  00:05:05,900
didn't pull your hair out thinking you
97

97

00:05:05,900  -->  00:05:08,840
did something wrong. Now remember that in
98

98

00:05:08,840  -->  00:05:11,780
Java, there's only ever one instance of a
99

99

00:05:11,780  -->  00:05:15,230
specific string literal. So here we've
100

100

00:05:15,230  -->  00:05:17,690
assigned the same string literal to hello
101

101

00:05:17,690  -->  00:05:21,169
one and hello two. If you use the string
102

102

00:05:21,169  -->  00:05:23,840
more than once in your code, you're
103

103

00:05:23,840  -->  00:05:26,330
actually using the same string instance
104

104

00:05:26,330  -->  00:05:28,460
every time you refer to the string
105

105

00:05:28,460  -->  00:05:31,550
literal. Now the jvm optimizes strings in
106

106

00:05:31,550  -->  00:05:33,229
this way and of course we're running on
107

107

00:05:33,229  -->  00:05:35,840
a jvm, so we get the same optimization
108

108

00:05:35,840  -->  00:05:38,390
when we run our Kotlin application.
109

109

00:05:38,390  -->  00:05:40,940
So these two string literals are actually
110

110

00:05:40,940  -->  00:05:43,790
the exact same instance because when the
111

111

00:05:43,790  -->  00:05:47,360
jvm comes to execute this line of code,
112

112

00:05:47,360  -->  00:05:50,780
it looks in what's called a string pool
113

113

00:05:50,780  -->  00:05:53,300
and it sees that it already has an
114

114

00:05:53,300  -->  00:05:56,479
instance of a string literal hello and
115

115

00:05:56,479  -->  00:05:59,210
so it just reuses it, because strings are
116

116

00:05:59,210  -->  00:06:01,640
immutable and so it's safe for the jvm
117

117

00:06:01,640  -->  00:06:04,190
to do that. So, you're actually assigning
118

118

00:06:04,190  -->  00:06:06,890
this the same string instance here,
119

119

00:06:06,890  -->  00:06:10,789
helloe one and hello two contain the exact same
120

120

00:06:10,789  -->  00:06:12,530
instance and therefore, they are
121

121

00:06:12,530  -->  00:06:16,039
referentially equal. So as I said, I hope
122

122

00:06:16,039  -->  00:06:17,539
you didn't tear your hair out over this,
123

123

00:06:17,539  -->  00:06:19,580
I wouldn't call it a trick question
124

124

00:06:19,580  -->  00:06:21,979
because the important thing from this
125

125

00:06:21,979  -->  00:06:24,110
part of the challenge is that you use
126

126

00:06:24,110  -->  00:06:26,479
the triple equals, that you know that
127

127

00:06:26,479  -->  00:06:28,669
when you want to test for referential
128

128

00:06:28,669  -->  00:06:30,979
equality in Kotlin, you use the triple
129

129

00:06:30,979  -->  00:06:33,350
equal, so if you did that you did great!
130

130

00:06:33,350  -->  00:06:35,990
Alright so now I want you to do the
131

131

00:06:35,990  -->  00:06:38,349
same thing, but I want you to determine
132

132

00:06:38,349  -->  00:06:41,599
whether they're structurally equal, so do
133

133

00:06:41,599  -->  00:06:44,080
the same thing as above,
134

134

00:06:44,080  -->  00:06:48,310
test for structural equality, so pause
135

135

00:06:48,310  -->  00:06:53,379
the video and give it a shot. Okay well
136

136

00:06:53,379  -->  00:06:55,270
this one should be easy now in fact you
137

137

00:06:55,270  -->  00:07:00,009
know you can just copy this line, bring
138

138

00:07:00,009  -->  00:07:01,780
it down here and then you know we'll
139

139

00:07:01,780  -->  00:07:06,629
want to change this to structurally
140

140

00:07:06,629  -->  00:07:09,699
structurally and knock off one of the
141

141

00:07:09,699  -->  00:07:12,370
equals here, because this is how Kotlin
142

142

00:07:12,370  -->  00:07:16,030
tests for structure equality and if we run,
143

143

00:07:16,030  -->  00:07:20,349
we should also see true and we do,
144

144

00:07:20,349  -->  00:07:22,750
because if two variables are
145

145

00:07:22,750  -->  00:07:24,219
referentially equal, then obviously
146

146

00:07:24,219  -->  00:07:26,139
they're also going to be structurally
147

147

00:07:26,139  -->  00:07:28,240
equal. Okay so let's move on to the next
148

148

00:07:28,240  -->  00:07:31,289
challenge, the next one is- this time
149

149

00:07:31,289  -->  00:07:37,259
declare a mutable variable of
150

150

00:07:37,259  -->  00:07:48,039
type int and assign it the value of 2988,
151

151

00:07:48,039  -->  00:07:50,919
So this should be a fairly easy one,
152

152

00:07:50,919  -->  00:07:55,569
go ahead and try it. Okay, so for this one,
153

153

00:07:55,569  -->  00:07:57,490
we're going to start with var because we
154

154

00:07:57,490  -->  00:08:01,210
want a mutable variable and then you can
155

155

00:08:01,210  -->  00:08:02,800
call it whatever you want, I didn't
156

156

00:08:02,800  -->  00:08:04,870
specify the name, so we'll just call it
157

157

00:08:04,870  -->  00:08:09,800
num and we can just assign it the value 2988.
158

158

00:08:09,800  -->  00:08:11,770
Now in this case, we don't have to
159

159

00:08:11,770  -->  00:08:13,509
specify the type because for whole
160

160

00:08:13,509  -->  00:08:16,419
numbers the default data type is int, but
161

161

00:08:16,419  -->  00:08:19,599
if we wanted a byte or a short or a long,
162

162

00:08:19,599  -->  00:08:21,900
we would have had to have specify the type.
163

163

00:08:21,900  -->  00:08:24,789
Okay for the next one, I want you to
164

164

00:08:24,789  -->  00:08:31,599
declare an immutable variable of type
165

165

00:08:31,599  -->  00:08:34,779
any. Now we're going to talk about this
166

166

00:08:34,779  -->  00:08:38,349
data type later, for now just know that
167

167

00:08:38,349  -->  00:08:42,339
the any variable of type any can contain in
168

168

00:08:42,339  -->  00:08:46,600
any Kotlin type, hence the name any.
169

169

00:08:46,600  -->  00:08:49,449
So, you can assign data of any type to a
170

170

00:08:49,449  -->  00:08:52,420
variable of type any, in this case we're
171

171

00:08:52,420  -->  00:08:55,220
going to assign-
172

172

00:08:55,220  -->  00:09:04,370
assign it the string the any type is the
173

173

00:09:04,370  -->  00:09:09,080
root of the Kotlin class hierarchy,
174

174

00:09:09,080  -->  00:09:11,600
perhaps you already guessed that based
175

175

00:09:11,600  -->  00:09:15,620
on what I said and then using a smart
176

176

00:09:15,620  -->  00:09:22,990
cast, print out the upper cased string.
177

177

00:09:22,990  -->  00:09:25,310
So this is going to be more than one
178

178

00:09:25,310  -->  00:09:27,850
line of code, so declare an immutable
179

179

00:09:27,850  -->  00:09:31,220
variable type, sorry an immutable
180

180

00:09:31,220  -->  00:09:33,710
variable of type any and assign it the
181

181

00:09:33,710  -->  00:09:35,810
string, the any type is the root of the
182

182

00:09:35,810  -->  00:09:38,780
Kotlin class hierarchy and then, using a
183

183

00:09:38,780  -->  00:09:41,300
smart cast, print out the uppercase
184

184

00:09:41,300  -->  00:09:43,880
string. So good luck with this one
185

185

00:09:43,880  -->  00:09:48,680
and I'll see you in a bit. Okay, so we'll
186

186

00:09:48,680  -->  00:09:50,900
start out by declaring our variable and
187

187

00:09:50,900  -->  00:09:54,440
we'll say val and we'll call it text and
188

188

00:09:54,440  -->  00:09:56,570
we'll assign it oh and you have to
189

189

00:09:56,570  -->  00:09:58,730
declare the data type in this case, which
190

190

00:09:58,730  -->  00:10:01,550
will be a type any and we'll assign it
191

191

00:10:01,550  -->  00:10:06,680
the string the any type is the root of
192

192

00:10:06,680  -->  00:10:12,500
the Kotlin class hierarchy. Okay, so now
193

193

00:10:12,500  -->  00:10:15,320
we want to use a smart cast to uppercase
194

194

00:10:15,320  -->  00:10:17,750
this, we can't just call to uppercase on
195

195

00:10:17,750  -->  00:10:20,270
it, because it's of type any not of type
196

196

00:10:20,270  -->  00:10:22,910
string, so to do a smart cast we'll use
197

197

00:10:22,910  -->  00:10:27,070
the is operator so we'll say if text is
198

198

00:10:27,070  -->  00:10:31,910
string and then in Kotlin because it has
199

199

00:10:31,910  -->  00:10:34,790
smart casting, if this test is true then
200

200

00:10:34,790  -->  00:10:36,560
in the following block of code, we can
201

201

00:10:36,560  -->  00:10:38,780
just go ahead and use text as if it's a
202

202

00:10:38,780  -->  00:10:42,050
string, we no longer have to cast it.
203

203

00:10:42,050  -->  00:10:45,400
So we'll just print line text dot to
204

204

00:10:45,400  -->  00:10:49,220
uppercase and we're done. Let's run to
205

205

00:10:49,220  -->  00:10:55,520
make sure of that. And here's our result,
206

206

00:10:55,520  -->  00:10:57,620
the any type is the root of the Kotlin
207

207

00:10:57,620  -->  00:11:00,680
class hierarchy. So this is what smart
208

208

00:11:00,680  -->  00:11:02,600
casting get to you we didn't have to use-
209

209

00:11:02,600  -->  00:11:05,300
we didn't have to explicitly cast text
210

210

00:11:05,300  -->  00:11:08,960
to a string here. Once the test has passed,
211

211

00:11:08,960  -->  00:11:10,730
the is test, we can then go ahead and use
212

212

00:11:10,730  -->  00:11:13,310
text as if it had already been cast.
213

213

00:11:13,310  -->  00:11:15,590
Alright so our final challenge is going to
214

214

00:11:15,590  -->  00:11:19,540
be the following, using one line of code,
215

215

00:11:19,540  -->  00:11:23,840
okay just one line of code, print out the
216

216

00:11:23,840  -->  00:11:28,820
following and make sure your code is
217

217

00:11:28,820  -->  00:11:33,710
nicely indented- nicely indented so what
218

218

00:11:33,710  -->  00:11:36,500
I want you to print out is let's see-
219

219

00:11:36,500  -->  00:11:48,740
and then on the
220

220

00:11:48,740  -->  00:11:52,250
final line- thar should actually
221

221

00:11:52,250  -->  00:11:57,200
pull this in. So this is what I want to see
222

222

00:11:57,200  -->  00:12:00,230
printed in the console and I want you to
223

223

00:12:00,230  -->  00:12:03,380
do this using just one line of code.
224

224

00:12:03,380  -->  00:12:04,820
So pause the video and I'll see you in a
225

225

00:12:04,820  -->  00:12:10,820
bit. Okay now, the verbose way and I
226

226

00:12:10,820  -->  00:12:12,860
suppose you could do it this way is to
227

227

00:12:12,860  -->  00:12:16,190
print a string that uses new lines and
228

228

00:12:16,190  -->  00:12:18,620
blanks, but we're going to do it the
229

229

00:12:18,620  -->  00:12:21,230
Kotlin way and the Kotlin way is to use
230

230

00:12:21,230  -->  00:12:25,100
a triple quoted string, so let's start
231

231

00:12:25,100  -->  00:12:29,000
we'll say val let's call it ones equals
232

232

00:12:29,000  -->  00:12:31,130
and we'll have our triple quoting and
233

233

00:12:31,130  -->  00:12:34,580
the first line is going to be 1 2 3
234

234

00:12:34,580  -->  00:12:38,480
blanks in a 1, our next line and I'm
235

235

00:12:38,480  -->  00:12:41,750
going to use the default trim character
236

236

00:12:41,750  -->  00:12:46,490
here, so the pipe will be 2 blanks and 2
237

237

00:12:46,490  -->  00:12:52,040
ones the third line will be a blank and
238

238

00:12:52,040  -->  00:12:57,290
3 ones and the fourth line will be 1 2 3
239

239

00:12:57,290  -->  00:13:00,950
4 ones and then we can close our triple
240

240

00:13:00,950  -->  00:13:02,990
quoted string and then of course we want
241

241

00:13:02,990  -->  00:13:08,510
to call the trim margin. So that all of
242

242

00:13:08,510  -->  00:13:10,430
this white space here is going to be
243

243

00:13:10,430  -->  00:13:12,650
trimmed off and I've just realized I
244

244

00:13:12,650  -->  00:13:15,110
said in one line of code, so we're going
245

245

00:13:15,110  -->  00:13:16,880
to actually delete this and just put
246

246

00:13:16,880  -->  00:13:20,790
print line here.
247

247

00:13:20,790  -->  00:13:22,980
And that's it. That's our one line of
248

248

00:13:22,980  -->  00:13:25,170
code, so let's run and see if we get what
249

249

00:13:25,170  -->  00:13:31,290
we expect and sure enough we do, in one
250

250

00:13:31,290  -->  00:13:33,510
line of code we've printed this out and
251

251

00:13:33,510  -->  00:13:35,940
our code is nicely indented we don't
252

252

00:13:35,940  -->  00:13:38,520
have one sitting out here. If you're in
253

253

00:13:38,520  -->  00:13:41,040
the mood for one more challenge, I'm not
254

254

00:13:41,040  -->  00:13:43,710
going to answer this for you. Hopefully,
255

255

00:13:43,710  -->  00:13:45,150
you'll figure it out and if you don't,
256

256

00:13:45,150  -->  00:13:46,800
you can always just ask in the
257

257

00:13:46,800  -->  00:13:49,350
discussion area. I'd like you to do the
258

258

00:13:49,350  -->  00:13:52,790
same thing, but use one as the trim
259

259

00:13:52,790  -->  00:13:56,670
character, so in other words put one here
260

260

00:13:56,670  -->  00:14:01,050
and print out this, the exact same thing.
261

261

00:14:01,050  -->  00:14:06,570
Now, if we run this we'll see now that
262

262

00:14:06,570  -->  00:14:08,960
we're not getting what we want, because
263

263

00:14:08,960  -->  00:14:11,370
we've got extra characters in here,
264

264

00:14:11,370  -->  00:14:12,930
because the pipe is no longer the
265

265

00:14:12,930  -->  00:14:14,910
character and what happened to our first
266

266

00:14:14,910  -->  00:14:17,550
line? So as an exercise for you,
267

267

00:14:17,550  -->  00:14:19,830
I'll change this statement here so that you
268

268

00:14:19,830  -->  00:14:22,920
get what we had before. Okay, that's it
269

269

00:14:22,920  -->  00:14:24,690
for the challenges and how did you do?
270

270

00:14:24,690  -->  00:14:27,600
Now, if you missed any don't worry you're
271

271

00:14:27,600  -->  00:14:29,910
learning a new language and when you do
272

272

00:14:29,910  -->  00:14:32,640
that, it takes practice and there's a lot
273

273

00:14:32,640  -->  00:14:34,470
more course to come, so you're going to
274

274

00:14:34,470  -->  00:14:36,030
be seeing a lot more Kotlin and it's
275

275

00:14:36,030  -->  00:14:37,770
going to start to feel a lot more
276

276

00:14:37,770  -->  00:14:38,800
natural to you.
277

277

00:14:38,800  -->  00:14:42,590
So I'll see you in the next section.
