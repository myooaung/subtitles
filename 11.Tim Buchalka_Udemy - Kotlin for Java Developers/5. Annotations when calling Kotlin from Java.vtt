WEBVTT
1
00:00:05.510 --> 00:00:09.990
Let's continue looking at how to call call in from Java I fixed their Java code here.

2
00:00:10.000 --> 00:00:17.740
Now that we're using the JVM field annotation I fix this to access the model property directly rather

3
00:00:17.740 --> 00:00:19.530
than calling get monel.

4
00:00:19.900 --> 00:00:23.290
OK so we've seen how we can access top level functions.

5
00:00:23.290 --> 00:00:28.110
They essentially become static methods within a class the compiler generates under the covers.

6
00:00:28.120 --> 00:00:30.780
Well what about companion objects.

7
00:00:30.880 --> 00:00:34.820
How do we access functions within companion objects.

8
00:00:35.050 --> 00:00:39.610
And the same goes for non anonymous object instances.

9
00:00:39.640 --> 00:00:42.760
Instances that we create using the object keyword.

10
00:00:43.120 --> 00:00:52.120
Well if you want Javid to be able to access them you have to use the at JVM static annotation the JVM

11
00:00:52.120 --> 00:00:58.480
static annotation tells the compiler to generate two versions of the function one within the instance

12
00:00:58.480 --> 00:00:59.840
as it normally would.

13
00:01:00.010 --> 00:01:04.720
And also a static version of the function that can be called from Java.

14
00:01:04.720 --> 00:01:05.950
So let's try this out.

15
00:01:05.950 --> 00:01:11.920
Let's go back to our Cartland code and we're going to add a companion object to our car class.

16
00:01:15.220 --> 00:01:24.760
So we'll say companion object and we'll give it a function called Car comp and all that will do is print

17
00:01:24.760 --> 00:01:30.240
a message and it'll say time in the car's companion object.

18
00:01:31.240 --> 00:01:34.070
So now let's access this from Java.

19
00:01:34.300 --> 00:01:40.640
So we'll say okay car and let's say companion because it suggesting it to us and we're like OK yeah

20
00:01:40.750 --> 00:01:43.620
we'll take that dot car cop.

21
00:01:44.080 --> 00:01:45.870
Wow that looks good.

22
00:01:45.880 --> 00:01:48.060
Everything got suggested to us.

23
00:01:48.280 --> 00:01:51.590
So that works or does it work.

24
00:01:51.610 --> 00:01:57.690
What we're actually doing right now is we're accessing the instance method generated by the compiler.

25
00:01:57.690 --> 00:02:00.810
And if that's OK with you you're done.

26
00:02:00.970 --> 00:02:06.930
But remember in cotland we don't need the companioned key word in CANTLIN we can do the following.

27
00:02:06.970 --> 00:02:15.760
We can just go ahead and say car Daut car comp we don't need to put the companioned key word in here.

28
00:02:15.760 --> 00:02:22.360
So if you want to be able to do the same thing in Java then you need to add the JVM static annotation

29
00:02:22.630 --> 00:02:27.200
so that you're calling it statically rather than calling an instance method.

30
00:02:27.220 --> 00:02:32.060
So to do that you just add JVM static in front of the function name.

31
00:02:32.200 --> 00:02:43.200
And now if we go back to Java we can remove the companion and it works if we didn't have the JVM static

32
00:02:43.200 --> 00:02:47.680
in front this doesn't work.

33
00:02:47.690 --> 00:02:54.260
So by putting JVM static here you're saying that you want Java to be able to call this using the static

34
00:02:54.260 --> 00:02:58.940
version of the method because remember I said that the compiler will generate two versions.

35
00:02:58.970 --> 00:03:03.800
So if you want to be able to use a statically you have to use a JVM static keyword.

36
00:03:03.800 --> 00:03:09.440
Otherwise the compiler will just generate the one version of the function and that'll be an instance

37
00:03:09.710 --> 00:03:10.640
method.

38
00:03:10.640 --> 00:03:16.370
So if you want it to be a static Massad you want the compiler to generate both versions.

39
00:03:16.370 --> 00:03:18.960
You have to add JVM static.

40
00:03:19.700 --> 00:03:24.290
And now you can go ahead and call it just like you would a static java method.

41
00:03:24.500 --> 00:03:28.790
So this could be important to know depending on what the car comp function does.

42
00:03:28.790 --> 00:03:36.680
I mean if the car function is accessing static properties for example and let's say you're accumulating

43
00:03:36.680 --> 00:03:40.870
something in a property and you need to you need it to be static then this is important to know.

44
00:03:40.970 --> 00:03:42.900
You don't want to call the instance method.

45
00:03:43.100 --> 00:03:46.040
Now the same applies to a named object instances.

46
00:03:46.040 --> 00:03:58.950
Let's create one in our Cartland file so will say object Singleton logs and we'll have a fun do something.

47
00:04:00.770 --> 00:04:03.730
And you know just print line.

48
00:04:05.180 --> 00:04:07.570
I'm doing something.

49
00:04:07.730 --> 00:04:10.980
The singleton object.

50
00:04:11.480 --> 00:04:17.730
All right so now let's try accessing this from our Java code so I'll pop back over here now.

51
00:04:17.750 --> 00:04:19.190
So let's type.

52
00:04:19.190 --> 00:04:29.120
Singleton Aag dot and right away intelligence suggests instance in all caps we can't see the do something

53
00:04:29.120 --> 00:04:31.100
function directly.

54
00:04:31.100 --> 00:04:36.890
So what is instance well instance is the single instance of the object class.

55
00:04:36.890 --> 00:04:45.110
Remember that when we declare an object like this there will only ever be one instance of this object

56
00:04:45.110 --> 00:04:46.200
created.

57
00:04:46.550 --> 00:04:52.360
So back in in Java that's what this instance is referring to.

58
00:04:52.370 --> 00:04:59.090
So when compiling an object class Scottland compiler generates a static class and adds a field called

59
00:04:59.180 --> 00:05:00.520
instance to it.

60
00:05:00.620 --> 00:05:05.000
And this field is assigned the single instance of the class.

61
00:05:05.000 --> 00:05:11.150
Now you never need to access this field when using an object class from CANTLIN but you can access it

62
00:05:11.180 --> 00:05:13.340
when calling call in from Java.

63
00:05:13.640 --> 00:05:15.500
So we'll say instance Daut.

64
00:05:15.530 --> 00:05:18.440
And now we can get to our do something function.

65
00:05:18.440 --> 00:05:19.430
So let's run

66
00:05:23.080 --> 00:05:29.470
and we'll see that it works and we're also getting our print line now from our car comp function but

67
00:05:29.470 --> 00:05:32.100
it doesn't look Javal like really.

68
00:05:32.110 --> 00:05:35.990
I mean normally in Java you'd probably call a get instance method here.

69
00:05:36.010 --> 00:05:41.080
So once again we can annotate the method with JVM static.

70
00:05:41.080 --> 00:05:46.580
So if we come back here we can say at JVM static.

71
00:05:46.960 --> 00:05:56.500
And now we head back to our Java class we can drop the instance and just call do something and if we

72
00:05:56.500 --> 00:05:57.280
run again

73
00:06:00.680 --> 00:06:01.970
we'll see that it's still work.

74
00:06:01.970 --> 00:06:04.370
So this looks a little more Java like.

75
00:06:04.400 --> 00:06:10.230
You don't have to do it but if you want to you can easily annotate the method here.

76
00:06:10.550 --> 00:06:13.010
So what about fields within an object class.

77
00:06:13.010 --> 00:06:14.740
Well often they're private.

78
00:06:14.780 --> 00:06:20.150
Especially when the object is a singleton but they don't have to be private so let's add one to our

79
00:06:20.150 --> 00:06:23.320
cars companion object.

80
00:06:24.090 --> 00:06:28.580
So we'll say Val is auto equals false.

81
00:06:28.850 --> 00:06:31.490
And now let's print this value from Java.

82
00:06:31.670 --> 00:06:32.770
So we'll come back here.

83
00:06:32.830 --> 00:06:47.810
Most say System outtalk print line is auto equals and will append because we don't have the nice string

84
00:06:47.810 --> 00:06:50.830
templates in Java cardiod is.

85
00:06:50.960 --> 00:06:59.060
Oh we don't get is auto suggested we have to go through companioned again and then we can see the is

86
00:06:59.060 --> 00:06:59.860
Ahto.

87
00:07:00.170 --> 00:07:06.470
So when we were accessing functions we could get rid of this by annotating with at JVM static.

88
00:07:06.470 --> 00:07:15.650
So is there any way we can get rid of this here because now we have to go through the Geter as you can

89
00:07:15.650 --> 00:07:20.650
see while we can come up to our property.

90
00:07:20.670 --> 00:07:24.950
This time we can annotate it with at JVM field.

91
00:07:25.140 --> 00:07:30.150
And now if we come back here they'll say Oh you're not using this anymore because now we can just go

92
00:07:31.350 --> 00:07:40.350
card Daut is auto Now if you have a Konst field you don't have to annotate it it will automatically

93
00:07:40.350 --> 00:07:42.940
be turned into a static field.

94
00:07:43.050 --> 00:07:50.980
So let's add a contest to our Singleton here or rather our car companion object and we'll say constant

95
00:07:51.010 --> 00:07:56.120
Vau constant constant equals 25.

96
00:07:56.340 --> 00:08:00.740
And now let's go back and use this from Jav and you'll notice it's not annotated with anything.

97
00:08:00.750 --> 00:08:10.710
And we can say car dot and we see our constant field on a property right away even though it's not annotated.

98
00:08:11.070 --> 00:08:13.190
So this is an exception to the rule.

99
00:08:13.200 --> 00:08:17.280
Now the same applies to what's called late initialize properties.

100
00:08:17.270 --> 00:08:22.350
We didn't cover those in the course but if you come across them you don't need to annotate them to access

101
00:08:22.350 --> 00:08:24.360
them as static fields from Java.

102
00:08:24.720 --> 00:08:27.990
OK so now let's talk about null safety.

103
00:08:28.050 --> 00:08:34.710
There's nothing to stop Java code from passing a novel to a function parameter that's expecting a non-null

104
00:08:34.710 --> 00:08:38.690
type so called will generate an exception when this happens.

105
00:08:38.700 --> 00:08:41.750
So let's add a function to our car class.

106
00:08:41.970 --> 00:08:50.340
So we'll do this underneath the companion object and we'll say fine print me and we want to take text

107
00:08:50.490 --> 00:08:56.220
that will be a string and we'll just say print line.

108
00:08:56.310 --> 00:09:00.530
Don't expect a null value.

109
00:09:00.630 --> 00:09:09.270
So we're not actually using the parameter here but we could just say text just so we're using it.

110
00:09:09.360 --> 00:09:11.330
Now let's pass and no.

111
00:09:11.510 --> 00:09:13.210
2 This function from Java.

112
00:09:13.210 --> 00:09:17.740
So we'll come back here and we'll say Kardon print to me.

113
00:09:17.940 --> 00:09:19.240
No.

114
00:09:20.130 --> 00:09:23.500
So absolutely nothing is going to stop us from doing that.

115
00:09:23.520 --> 00:09:25.980
We don't get any compile errors but if we run

116
00:09:29.600 --> 00:09:32.790
we'll see that we get an illegal argument exception.

117
00:09:32.900 --> 00:09:40.670
And so this is what happens if you have a function in courtliness expecting a non nullable type and

118
00:09:40.730 --> 00:09:43.090
it receives a null value.

119
00:09:43.160 --> 00:09:49.070
You'll get an illegal argument exception and what's happening is the compiler the calling compiler is

120
00:09:49.070 --> 00:09:55.430
generating a check under the cover so it's actually generating a check for knowl and the moment it sees

121
00:09:55.430 --> 00:10:00.110
knowl you get that and you don't even have to use the parameter.

122
00:10:00.110 --> 00:10:06.770
Let me let me knock this off for a minute and you'll see that even though we don't use it we never reference

123
00:10:06.770 --> 00:10:06.890
it.

124
00:10:06.890 --> 00:10:09.650
We're going to get the same illegal argument exception

125
00:10:13.070 --> 00:10:13.520
.

126
00:10:13.580 --> 00:10:19.100
So the compiler is generating the check as soon as this function is entered.

127
00:10:19.100 --> 00:10:19.860
It checks.

128
00:10:19.920 --> 00:10:23.570
OK I want to non-call is it actually not all.

129
00:10:23.890 --> 00:10:27.480
And if it is all you get the illegal argument exception.

130
00:10:27.800 --> 00:10:33.940
So talking about exceptions cotland doesn't need functions to declare what exceptions they can throw.

131
00:10:33.950 --> 00:10:35.710
But Java does.

132
00:10:35.720 --> 00:10:41.440
So what happens when we have a function in cotland that can throw an exception and we call it from Java.

133
00:10:41.450 --> 00:10:42.850
Well let's try this out.

134
00:10:42.860 --> 00:10:46.570
We'll add another function to our Cottman file here.

135
00:10:46.730 --> 00:10:50.740
We'll say fun and we'll pretend we're doing some IO here.

136
00:10:51.950 --> 00:10:57.620
And inside we're going to throw an exception.

137
00:10:57.710 --> 00:11:04.250
So this is obviously a really dumb function but this function throws an exception.

138
00:11:04.250 --> 00:11:10.190
And of course we're in cotland so we don't have to declare that but we're throwing a checked exception.

139
00:11:10.190 --> 00:11:14.230
So in Java we do have to declare when we throw an exception.

140
00:11:14.240 --> 00:11:20.420
So let's go back to Java now and see what happens if we call this function as a top level function so

141
00:11:20.420 --> 00:11:23.860
we'll say static Karakas back here.

142
00:11:23.900 --> 00:11:30.890
We said that we want the name of the static class generated for all our top level items to be static

143
00:11:30.890 --> 00:11:31.880
car.

144
00:11:32.250 --> 00:11:37.580
I will say Daut and it's not saying it because I put it in the wrong place.

145
00:11:37.580 --> 00:11:46.160
I actually put it in our car class so let me remove that and paste it up here and now are our Java code

146
00:11:46.160 --> 00:11:47.570
will see it.

147
00:11:47.690 --> 00:11:54.080
So we're not getting any errors even though we know that this function throws IO exception and if we

148
00:11:54.080 --> 00:11:58.210
run you can probably guess what we're what's going to happen.

149
00:11:58.220 --> 00:12:03.870
Actually let me first comment out the knol so we can get past that.

150
00:12:03.920 --> 00:12:06.460
We're doing a lot of bad stuff now in here.

151
00:12:08.170 --> 00:12:13.060
And of course we get the exception that we throw.

152
00:12:13.060 --> 00:12:16.920
So let's say we want to catch this exception can we catch it.

153
00:12:17.010 --> 00:12:19.220
Well let's give that a shot.

154
00:12:19.240 --> 00:12:20.740
So I will say try

155
00:12:24.880 --> 00:12:28.990
and we'll catch no exception.

156
00:12:30.880 --> 00:12:38.050
And we get an error because we get the error that says that exception is never thrown from the try block

157
00:12:38.050 --> 00:12:42.450
while we know it is because we're throwing it 100 percent of the time.

158
00:12:42.490 --> 00:12:48.460
But as far as Jack knows the function doesn't throw anything because there's nothing in the compiled

159
00:12:48.460 --> 00:12:56.650
Katlin class that says this function throws an Iowa exception to make the Katlin compiler generate something

160
00:12:56.650 --> 00:12:58.210
that tells Java that.

161
00:12:58.270 --> 00:13:04.570
Guess what the static Harakat do I O function can throw an exception and IO exception in this case we

162
00:13:04.570 --> 00:13:11.410
have to annotate this function and we're going to annotate it with the at throws annotation and we're

163
00:13:11.410 --> 00:13:13.030
going to say at throws.

164
00:13:13.030 --> 00:13:18.040
And then within parentheses we're going to say what class this can throw.

165
00:13:18.100 --> 00:13:20.500
And we have to use the.

166
00:13:20.710 --> 00:13:23.830
Actually we don't need to double quotes.

167
00:13:23.830 --> 00:13:26.690
We say no exception and then class.

168
00:13:26.770 --> 00:13:34.940
So this now tells the compiler to generate code that will inform anything that's using this function

169
00:13:34.950 --> 00:13:39.970
that this function throws an IO exception if we go about to Jaba now the error has gone away because

170
00:13:39.970 --> 00:13:41.650
now Java can see that.

171
00:13:41.710 --> 00:13:48.480
OK yeah do IO can throw in IO exception so you may have an exception to catch here.

172
00:13:48.850 --> 00:13:51.730
So let's add a print line to our catch system.

173
00:13:51.820 --> 00:13:55.180
Outdrawn front line IO exception

174
00:13:57.620 --> 00:13:59.880
and when we run we should see this caught.

175
00:13:59.890 --> 00:14:04.440
Now let's go ahead and run.

176
00:14:04.730 --> 00:14:08.150
And we do we see our IO exception message.

177
00:14:08.240 --> 00:14:14.290
So the last thing we're going to touch on as far as calling Cartland from Javid goes is a default parameters.

178
00:14:14.300 --> 00:14:18.560
We've seen that you can specify a default parameter values in Katlin.

179
00:14:18.560 --> 00:14:23.090
So when we do that what happens when we call the function from Java.

180
00:14:23.090 --> 00:14:24.170
So let's try this out.

181
00:14:24.170 --> 00:14:31.040
We'll go back to our crowded Cartland file now and we'll add a function that accepts default values

182
00:14:32.070 --> 00:14:41.330
so we'll a fun default parks and will take a string just so that the default just so the parameter that

183
00:14:41.330 --> 00:14:47.660
takes the default value isn't first or the only one in there must say none int and this grandmother

184
00:14:47.660 --> 00:14:50.190
has a default value of 25.

185
00:14:50.240 --> 00:14:55.940
So let's try to call this function now from Java so we can go back to Java

186
00:14:59.220 --> 00:15:02.800
and say static car Daut default args.

187
00:15:02.800 --> 00:15:08.830
Now you'll notice that what's being suggested to us has both parameters in it.

188
00:15:09.130 --> 00:15:17.360
So we'll say OK the number is and will pass the value of 40.

189
00:15:17.770 --> 00:15:24.460
And that works but this is supposed to be an optional parameter now because if we don't pass a value

190
00:15:24.460 --> 00:15:26.130
it will just take the value of 25.

191
00:15:26.130 --> 00:15:30.110
So let's knock off the 40 and we get an error.

192
00:15:30.130 --> 00:15:37.610
The only function signature is that Chavez sees is the full function signature where everything is required.

193
00:15:37.720 --> 00:15:43.540
And that's because when you have a Cottman function with default parameter values only one version of

194
00:15:43.540 --> 00:15:45.970
the function is generated for Java.

195
00:15:45.970 --> 00:15:51.040
So when the Cartland compiler comes along and compiles this it just generates one version of the function

196
00:15:51.070 --> 00:15:55.010
and the version it generates requires both parameters.

197
00:15:55.030 --> 00:16:00.180
There is no version of the function generated that will just take the string parameter.

198
00:16:00.190 --> 00:16:02.030
So what do you do in this situation.

199
00:16:02.050 --> 00:16:08.830
Well you probably guessed by now that you can use an annotation to get past this and in this case we

200
00:16:08.830 --> 00:16:17.260
want to use the at JVM overloads annotation and this tells the compiler to generate every possible version

201
00:16:17.260 --> 00:16:18.340
of this function.

202
00:16:18.730 --> 00:16:22.700
So we'll say at JVM overloads.

203
00:16:23.080 --> 00:16:30.220
And now this tells the compiler generate a default args function that takes only the string and then

204
00:16:30.250 --> 00:16:38.470
under the covers of course that function will assign 25 to Nam or and rather generate the default args

205
00:16:38.470 --> 00:16:41.230
function that takes both the string and the number.

206
00:16:41.590 --> 00:16:45.750
So instead of only getting the full function version you'll get Boakes.

207
00:16:45.820 --> 00:16:52.200
You'll get one version that doesn't require the name and one version that does so.

208
00:16:52.210 --> 00:16:55.840
Now if we go back to I will see that this works.

209
00:16:56.080 --> 00:17:01.600
So that's how to deal with default parameter arguments you can imagine if you had a bunch of parameters

210
00:17:01.600 --> 00:17:05.530
that take defaults are going to get a lot of functions generated but that's OK.

211
00:17:06.070 --> 00:17:12.180
Now you might decide that when you call this function from Java you want all the arguments to be specified.

212
00:17:12.190 --> 00:17:15.490
So in that case you wouldn't need this annotation.

213
00:17:15.490 --> 00:17:17.410
Now there are a few more situations.

214
00:17:17.440 --> 00:17:20.820
You have to do something special when you're calling call in from Java.

215
00:17:20.810 --> 00:17:25.050
But we've covered the most common situations so we're going to leave it here.

216
00:17:25.210 --> 00:17:28.210
And so that's it for Java interoperability.

217
00:17:28.210 --> 00:17:29.710
I'll see you in the next video.
