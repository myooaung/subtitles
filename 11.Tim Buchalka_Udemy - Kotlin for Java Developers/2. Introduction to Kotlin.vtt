WEBVTT
1
1

00:00:04.710  -->  00:00:08.879
So what is Kotlin? Well you probably know
2

2

00:00:08.879  -->  00:00:10.680
that it's a programming language and
3

3

00:00:10.680  -->  00:00:13.500
Google announced support for Android but
4

4

00:00:13.500  -->  00:00:15.480
let's talk a bit more about why it
5

5

00:00:15.480  -->  00:00:17.400
exists, because after all there are
6

6

00:00:17.400  -->  00:00:19.560
plenty of programming languages so why
7

7

00:00:19.560  -->  00:00:20.850
do we need another one?
8

8

00:00:20.850  -->  00:00:24.000
Well Kotlin belongs to JetBrains
9

9

00:00:24.000  -->  00:00:26.610
and JetBrains as a company behind the
10

10

00:00:26.610  -->  00:00:31.230
popular IntelliJ IDEA IDE in popular
11

11

00:00:31.230  -->  00:00:33.539
Java IDE. Now if you haven't used
12

12

00:00:33.539  -->  00:00:35.460
IntelliJ, we'll be using it in this
13

13

00:00:35.460  -->  00:00:37.710
course, so you'll get a chance to work
14

14

00:00:37.710  -->  00:00:40.079
with it. Now because of what JetBrains
15

15

00:00:40.079  -->  00:00:42.600
does, it not only sees a lot of Java code
16

16

00:00:42.600  -->  00:00:45.329
but it has a huge Java code base of its
17

17

00:00:45.329  -->  00:00:47.700
own and so it was familiar with some of
18

18

00:00:47.700  -->  00:00:49.230
the challenges of writing and
19

19

00:00:49.230  -->  00:00:52.620
maintaining a large Java code base. So at
20

20

00:00:52.620  -->  00:00:54.630
some point it decided to create its own
21

21

00:00:54.630  -->  00:00:56.370
language that would be completely
22

22

00:00:56.370  -->  00:00:59.129
interoperable with Java and that would
23

23

00:00:59.129  -->  00:01:01.739
perhaps get around or overcome some of
24

24

00:01:01.739  -->  00:01:04.439
the challenges of working with a large
25

25

00:01:04.439  -->  00:01:07.020
code base written in Java and the
26

26

00:01:07.020  -->  00:01:08.790
language that it designed and
27

27

00:01:08.790  -->  00:01:11.310
implemented is Kotlin. Now since then
28

28

00:01:11.310  -->  00:01:14.820
Kotlin has moved beyond the original
29

29

00:01:14.820  -->  00:01:17.460
vision, you can compile Kotlin code to
30

30

00:01:17.460  -->  00:01:19.979
run on the JVM but you can also compile
31

31

00:01:19.979  -->  00:01:22.860
it to run on JavaScript VMs and on top
32

32

00:01:22.860  -->  00:01:24.960
of that, at the time that I'm writing and
33

33

00:01:24.960  -->  00:01:27.119
recording this course, there's a native
34

34

00:01:27.119  -->  00:01:29.729
preview available, so that means that in
35

35

00:01:29.729  -->  00:01:31.979
the future it might be possible for you
36

36

00:01:31.979  -->  00:01:34.380
to compile Kotlin code to machine code
37

37

00:01:34.380  -->  00:01:36.420
and then of course, you won't need the
38

38

00:01:36.420  -->  00:01:39.030
JVM at all, but what's great about Kotlin
39

39

00:01:39.030  -->  00:01:41.580
is that if you are a Java developer,
40

40

00:01:41.580  -->  00:01:44.310
you can still use Java from Kotlin, so you
41

41

00:01:44.310  -->  00:01:46.530
can ease yourself into the Kotlin world,
42

42

00:01:46.530  -->  00:01:48.720
you don't have to make a radical switch
43

43

00:01:48.720  -->  00:01:51.210
from Java to Kotlin, you can start out by
44

44

00:01:51.210  -->  00:01:53.790
writing a single Kotlin class and adding
45

45

00:01:53.790  -->  00:01:56.460
that to an existing Java application.
46

46

00:01:56.460  -->  00:01:58.470
So in this course, we're going to focus on
47

47

00:01:58.470  -->  00:02:00.420
writing Kotlin applications that will
48

48

00:02:00.420  -->  00:02:03.030
run on the JVM and we're also going to
49

49

00:02:03.030  -->  00:02:05.820
use your existing Java knowledge to
50

50

00:02:05.820  -->  00:02:08.670
introduce you to Kotlin and what you can
51

51

00:02:08.670  -->  00:02:10.769
do with it. Now Kotlin is pronounced the
52

52

00:02:10.769  -->  00:02:13.379
way I've been pronouncing it Kotlin,
53

53

00:02:13.379  -->  00:02:15.749
it's named after an island in Russia because
54

54

00:02:15.749  -->  00:02:18.599
the Kotlin team is located in Russia.
55

55

00:02:18.599  -->  00:02:21.269
So let's talk a little more about Kotlin,
56

56

00:02:21.269  -->  00:02:23.639
as I mentioned it can run anywhere Java
57

57

00:02:23.639  -->  00:02:26.219
can run, because it runs on the JVM,
58

58

00:02:26.219  -->  00:02:27.749
so therefore it can run anywhere that the
59

59

00:02:27.749  -->  00:02:30.900
JVM can run, it's statically typed,
60

60

00:02:30.900  -->  00:02:33.299
so what I mean by this is that the type of
61

61

00:02:33.299  -->  00:02:35.340
every expression is determined at
62

62

00:02:35.340  -->  00:02:37.709
compile time, so the compiler will know
63

63

00:02:37.709  -->  00:02:40.439
the type of every expression, it will
64

64

00:02:40.439  -->  00:02:42.299
know the type of every variable,
65

65

00:02:42.299  -->  00:02:44.010
it doesn't figure out the types at runtime,
66

66

00:02:44.010  -->  00:02:45.840
they're all figured out at compile time
67

67

00:02:45.840  -->  00:02:50.310
it's object oriented, but Kotlin also
68

68

00:02:50.310  -->  00:02:53.489
uses functional programming. Now if
69

69

00:02:53.489  -->  00:02:54.930
you're not familiar with functional
70

70

00:02:54.930  -->  00:02:57.120
programming, this means that you can use
71

71

00:02:57.120  -->  00:02:59.250
functions as values, meaning you can
72

72

00:02:59.250  -->  00:03:01.739
store them in variables, you can return
73

73

00:03:01.739  -->  00:03:03.810
them from functions and pass them as
74

74

00:03:03.810  -->  00:03:06.269
arguments to functions. Also you can
75

75

00:03:06.269  -->  00:03:08.010
declare immutable objects, meaning
76

76

00:03:08.010  -->  00:03:10.469
instances that you can't change.
77

77

00:03:10.469  -->  00:03:12.599
Now functional programming allows Kotlin to
78

78

00:03:12.599  -->  00:03:14.370
be concise and you're going to see this
79

79

00:03:14.370  -->  00:03:16.439
over and over again as you go through
80

80

00:03:16.439  -->  00:03:18.389
the course, most of the time you'll have
81

81

00:03:18.389  -->  00:03:20.400
to write less Kotlin code to accomplish
82

82

00:03:20.400  -->  00:03:22.799
something then you'd have to write in Java.
83

83

00:03:22.799  -->  00:03:25.560
Okay so Kotlin has four guiding
84

84

00:03:25.560  -->  00:03:29.280
principles. The first guiding principle
85

85

00:03:29.280  -->  00:03:31.889
is conciseness, I just mentioned that and
86

86

00:03:31.889  -->  00:03:34.349
you're going to see that as we go
87

87

00:03:34.349  -->  00:03:36.030
through the course and you're going to
88

88

00:03:36.030  -->  00:03:38.579
be amazed sometimes at how little code
89

89

00:03:38.579  -->  00:03:40.199
you have to write compared to what you
90

90

00:03:40.199  -->  00:03:42.419
have to write in Java. Kotlin is also
91

91

00:03:42.419  -->  00:03:44.759
focused on safety, you'll you'll see that
92

92

00:03:44.759  -->  00:03:47.189
Kotlin goes to great lengths to protect
93

93

00:03:47.189  -->  00:03:49.379
against null pointer exceptions. Now you
94

94

00:03:49.379  -->  00:03:50.819
might have heard that you can't get a
95

95

00:03:50.819  -->  00:03:52.650
null pointer exception in Kotlin that's
96

96

00:03:52.650  -->  00:03:55.169
not true, but it's pretty hard to get one.
97

97

00:03:55.169  -->  00:03:57.569
You practically have to beg for one,
98

98

00:03:57.569  -->  00:03:59.459
it's pragmatics now what do I mean by that?
99

99

00:03:59.459  -->  00:04:02.609
It's not a research language, Kotlin is
100

100

00:04:02.609  -->  00:04:05.340
designed to solve actual problems in the
101

101

00:04:05.340  -->  00:04:08.159
real world. And also as you're going to
102

102

00:04:08.159  -->  00:04:09.959
see there's often more than one way to
103

103

00:04:09.959  -->  00:04:12.659
do something in Kotlin, all as we go
104

104

00:04:12.659  -->  00:04:13.889
through the course you'll see me
105

105

00:04:13.889  -->  00:04:15.900
sometimes saying you can write it like
106

106

00:04:15.900  -->  00:04:18.030
this, so you can write it like that and
107

107

00:04:18.030  -->  00:04:22.019
in the Kotlin world, no way is considered
108

108

00:04:22.019  -->  00:04:24.180
better than the other, so you don't have
109

109

00:04:24.180  -->  00:04:27.510
any arguments along the lines of should
110

110

00:04:27.510  -->  00:04:29.400
you have a curly brace on the same line
111

111

00:04:29.400  -->  00:04:32.759
or on a different line as we know
112

112

00:04:32.759  -->  00:04:34.770
you know among some circles those types
113

113

00:04:34.770  -->  00:04:36.779
of arguments are practically religious
114

114

00:04:36.779  -->  00:04:38.819
arguments, there's none of that in Kotlin.
115

115

00:04:38.819  -->  00:04:40.979
If you want to be verbose with your code,
116

116

00:04:40.979  -->  00:04:42.960
so it's more like Java, you can do that.
117

117

00:04:42.960  -->  00:04:44.729
If you want to be really concise, you can
118

118

00:04:44.729  -->  00:04:46.589
do that. If there are three ways to write
119

119

00:04:46.589  -->  00:04:48.330
the same thing, it doesn't matter which
120

120

00:04:48.330  -->  00:04:49.800
way you write it most of the time
121

121

00:04:49.800  -->  00:04:52.770
depending on the situation one might be
122

122

00:04:52.770  -->  00:04:54.089
a little more efficient than the other,
123

123

00:04:54.089  -->  00:04:55.800
but most of the time it doesn't matter.
124

124

00:04:55.800  -->  00:04:58.229
Now there are of course some best and
125

125

00:04:58.229  -->  00:05:00.419
recommended practices, but when there's
126

126

00:05:00.419  -->  00:05:01.559
more than one way to accomplish
127

127

00:05:01.559  -->  00:05:03.839
something, usually you can do it in the
128

128

00:05:03.839  -->  00:05:05.879
manner you prefer. Now you'll see that
129

129

00:05:05.879  -->  00:05:07.800
when you first start working with Kotlin,
130

130

00:05:07.800  -->  00:05:09.990
You'll write more verbose Java like code,
131

131

00:05:09.990  -->  00:05:13.620
you might keep doing that or as you get
132

132

00:05:13.620  -->  00:05:16.020
more familiar with Kotlin, you might
133

133

00:05:16.020  -->  00:05:19.199
write more idiomatic Kotlin code,
134

134

00:05:19.199  -->  00:05:20.870
the fourth guiding principle is
135

135

00:05:20.870  -->  00:05:22.770
interoperability, I've already mentioned
136

136

00:05:22.770  -->  00:05:25.409
this, Kotlin was designed from the ground
137

137

00:05:25.409  -->  00:05:28.620
up to be interoperable with Java, so it's
138

138

00:05:28.620  -->  00:05:30.990
really the best of both worlds for Java
139

139

00:05:30.990  -->  00:05:33.330
developers like us, it's a great language
140

140

00:05:33.330  -->  00:05:37.649
to learn because we still have the full
141

141

00:05:37.649  -->  00:05:40.080
power of the JDK at our disposal, we can
142

142

00:05:40.080  -->  00:05:42.100
use all of our existing knowledge.
143

143

00:05:42.100  -->  00:05:44.430
Okay, so I've talked enough about the language,
144

144

00:05:44.430  -->  00:05:47.159
it's time to see it in action, so we're
145

145

00:05:47.159  -->  00:05:50.129
going to start by you watching me
146

146

00:05:50.129  -->  00:05:53.399
convert a java application to Kotlin,
147

147

00:05:53.399  -->  00:05:56.039
to give you a taste of the language and to
148

148

00:05:56.039  -->  00:05:58.889
see a couple of the guiding principles
149

149

00:05:58.889  -->  00:06:02.870
in action. I'll see you in the next video.
