WEBVTT
1
1

00:00:04.680  -->  00:00:07.140
Alright now that you've watched me
2

2

00:00:07.140  -->  00:00:09.480
convert the text adventure application
3

3

00:00:09.480  -->  00:00:11.730
from Java to Kotlin, I guess I should let
4

4

00:00:11.730  -->  00:00:13.559
you in on a little secret here and tell
5

5

00:00:13.559  -->  00:00:16.350
you that IntelliJ will convert Java to
6

6

00:00:16.350  -->  00:00:19.710
Kotlin for you, all you have to do is
7

7

00:00:19.710  -->  00:00:21.840
drop a snippet of Java code into a
8

8

00:00:21.840  -->  00:00:24.450
Kotlin file. So let's see how this works,
9

9

00:00:24.450  -->  00:00:27.900
I'm back in the Java version of the text
10

10

00:00:27.900  -->  00:00:29.789
adventure and now I'm going to add a
11

11

00:00:29.789  -->  00:00:32.879
Kotlin file to the project, you can mix
12

12

00:00:32.879  -->  00:00:35.940
Kotlin and Java like this because as I
13

13

00:00:35.940  -->  00:00:38.640
said, at the top of the course Kotlin is
14

14

00:00:38.640  -->  00:00:42.649
interoperable with Java, so I'm going to
15

15

00:00:42.649  -->  00:00:46.739
spend our source here and I'll add a new
16

16

00:00:46.739  -->  00:00:50.250
Kotlin file and I'll call that Kotlin
17

17

00:00:50.250  -->  00:00:54.210
file Kotlin location because I'm going
18

18

00:00:54.210  -->  00:00:57.210
to convert the location Java class to
19

19

00:00:57.210  -->  00:01:02.160
Kotlin using the automated conversion,
20

20

00:01:02.160  -->  00:01:04.019
so now all I have to do is copy the
21

21

00:01:04.019  -->  00:01:06.780
location code into the file, so I'm going
22

22

00:01:06.780  -->  00:01:12.800
to go to our location I'm going to ctrl c
23

23

00:01:12.800  -->  00:01:15.479
all of that, come to the Kotlin
24

24

00:01:15.479  -->  00:01:19.799
location file and ctrl v and we're going
25

25

00:01:19.799  -->  00:01:21.270
to get this little pop-up that says
26

26

00:01:21.270  -->  00:01:24.260
clipboard content copied from Java file,
27

27

00:01:24.260  -->  00:01:27.180
do you want to convert it to Kotlin code?
28

28

00:01:27.180  -->  00:01:29.700
Sow you can say not to show the dialog,
29

29

00:01:29.700  -->  00:01:31.710
I wouldn't check that because there are
30

30

00:01:31.710  -->  00:01:33.299
going to be times where you definitely
31

31

00:01:33.299  -->  00:01:35.250
don't want to convert it to Kotlin code,
32

32

00:01:35.250  -->  00:01:37.680
you just want to put the Java code in as
33

33

00:01:37.680  -->  00:01:40.080
a starting point and then convert it by
34

34

00:01:40.080  -->  00:01:43.020
hand, but I do want the code converted
35

35

00:01:43.020  -->  00:01:45.090
to Kotlin, so I'll say yeah sure
36

36

00:01:45.090  -->  00:01:46.979
do it and then it's going to tell me
37

37

00:01:46.979  -->  00:01:49.619
that we're using Java util dot hashmap
38

38

00:01:49.619  -->  00:01:54.509
and so essentially select the class if I
39

39

00:01:54.509  -->  00:01:57.119
want an import statement added for it
40

40

00:01:57.119  -->  00:02:00.390
and I do, so let's go and here we are,
41

41

00:02:00.390  -->  00:02:04.740
we have our converted application. Now it's
42

42

00:02:04.740  -->  00:02:07.619
slightly different to the code that I
43

43

00:02:07.619  -->  00:02:10.500
wrote, but not by much for this class and
44

44

00:02:10.500  -->  00:02:12.719
once again, you'll understand this code
45

45

00:02:12.719  -->  00:02:14.549
by the end of the course but you'll
46

46

00:02:14.549  -->  00:02:17.549
notice that it's using hash map my
47

47

00:02:17.549  -->  00:02:18.540
version of the code
48

48

00:02:18.540  -->  00:02:21.239
didn't hear it's explicitly wanting a
49

49

00:02:21.239  -->  00:02:23.489
hashmap or to return a hashmap and
50

50

00:02:23.489  -->  00:02:26.010
that's because we're using we're doing
51

51

00:02:26.010  -->  00:02:29.459
that here in this code and the converter
52

52

00:02:29.459  -->  00:02:32.670
is designed to generate more verbose
53

53

00:02:32.670  -->  00:02:34.799
Kotlin code because it's there to help
54

54

00:02:34.799  -->  00:02:37.620
you learn Kotlin and so it stays really
55

55

00:02:37.620  -->  00:02:40.530
true to whatever your Java code was
56

56

00:02:40.530  -->  00:02:42.659
and that's why it's returning a hash map
57

57

00:02:42.659  -->  00:02:45.060
here even though it could just go ahead
58

58

00:02:45.060  -->  00:02:49.500
and return exits, the original location
59

59

00:02:49.500  -->  00:02:53.069
code is returning a new hash map I'm not
60

60

00:02:53.069  -->  00:02:57.750
sure why and so it's going to do the
61

61

00:02:57.750  -->  00:03:00.720
same thing, I didn't do that because you
62

62

00:03:00.720  -->  00:03:02.430
know we have a map property so I just
63

63

00:03:02.430  -->  00:03:04.739
returned them out. So for the conversion
64

64

00:03:04.739  -->  00:03:07.349
consider it a starting point or a way to
65

65

00:03:07.349  -->  00:03:09.269
get a hint if you're trying to convert
66

66

00:03:09.269  -->  00:03:11.099
some Java code and you're not sure what
67

67

00:03:11.099  -->  00:03:14.280
to do you could try dropping the java
68

68

00:03:14.280  -->  00:03:17.010
code into a Kotlin file and see if that
69

69

00:03:17.010  -->  00:03:20.819
helps you or you know and see if it does
70

70

00:03:20.819  -->  00:03:22.979
what you want or at least it'll be a
71

71

00:03:22.979  -->  00:03:25.290
starting point because often, as I said
72

72

00:03:25.290  -->  00:03:27.120
what you get from the converter will be
73

73

00:03:27.120  -->  00:03:30.510
more verbose than what Kotlin normally
74

74

00:03:30.510  -->  00:03:33.090
looks like. Now the converter isn't
75

75

00:03:33.090  -->  00:03:35.310
infallible, sometimes you'll end up with
76

76

00:03:35.310  -->  00:03:38.430
code that doesn't compile because the
77

77

00:03:38.430  -->  00:03:40.560
converter is only looking at the one
78

78

00:03:40.560  -->  00:03:43.919
file that you or the one snippet that
79

79

00:03:43.919  -->  00:03:46.019
you wanted to convert, so it's kind of
80

80

00:03:46.019  -->  00:03:47.970
taking code out of context and so
81

81

00:03:47.970  -->  00:03:49.889
sometimes the way it chooses to convert
82

82

00:03:49.889  -->  00:03:52.739
things won't mesh well with existing
83

83

00:03:52.739  -->  00:03:55.889
code but that's okay, because again it
84

84

00:03:55.889  -->  00:03:58.019
will give you a starting point,
85

85

00:03:58.019  -->  00:04:00.389
so wanted to show you the converter now,
86

86

00:04:00.389  -->  00:04:01.799
so you can start playing with it if you
87

87

00:04:01.799  -->  00:04:04.229
want to try converting some Java code.
88

88

00:04:04.229  -->  00:04:06.150
So if you're curious about how some Java
89

89

00:04:06.150  -->  00:04:08.639
code that you have would look in Kotlin,
90

90

00:04:08.639  -->  00:04:11.879
you can just open up the java and copy
91

91

00:04:11.879  -->  00:04:14.000
and paste it into a Kotlin file and
92

92

00:04:14.000  -->  00:04:16.500
tell the IDE that you want to convert it
93

93

00:04:16.500  -->  00:04:18.630
to Kotlin, but ideally you're going to be
94

94

00:04:18.630  -->  00:04:20.820
able to convert Kotlin code by hand to
95

95

00:04:20.820  -->  00:04:23.820
get the most idiomatic code that you can
96

96

00:04:23.820  -->  00:04:26.370
so it's time to start learning Kotlin.
97

97

00:04:26.370  -->  00:04:29.659
I'll see you in the next video.
