WEBVTT
1
1

00:00:00.000  -->  00:00:02.500
(Intro music)
2

2

00:00:05.640  -->  00:00:07.880
<v Narrator>Alright, once again it's time to</v>
3

3

00:00:07.880  -->  00:00:09.270
practise what you have learned.
4

4

00:00:09.270  -->  00:00:11.863
And this time I've typed everything in advance,
5

5

00:00:11.863  -->  00:00:14.542
so you can jump ahead if you want, but I suggest you
6

6

00:00:14.542  -->  00:00:17.850
just follow along, item by item.
7

7

00:00:17.850  -->  00:00:20.770
Now I've already gone ahead and created a Kotlin project
8

8

00:00:20.770  -->  00:00:22.850
called Challenge Two and I've put it into
9

9

00:00:22.850  -->  00:00:27.610
the usual package, and created a file called
10

10

00:00:27.610  -->  00:00:29.990
Challenge Two and then created a main function.
11

11

00:00:29.990  -->  00:00:33.150
You can do this however you want but, obviously
12

12

00:00:33.150  -->  00:00:35.350
you're going to need a file with a main function
13

13

00:00:35.350  -->  00:00:38.890
if you're going to run your answers.
14

14

00:00:38.890  -->  00:00:41.290
So, let's move on to the first challenge.
15

15

00:00:41.290  -->  00:00:46.290
Declare a non-nullable float variable, two ways
16

16

00:00:46.790  -->  00:00:49.167
and assign it the value -3847.384.
17

17

00:00:52.490  -->  00:00:55.963
So basically you're going to declare two float variables
18

18

00:00:55.963  -->  00:00:58.270
and assign them this value,
19

19

00:00:58.270  -->  00:01:01.360
and I want you to do it in two ways,
20

20

00:01:01.360  -->  00:01:03.250
hence two float variables.
21

21

00:01:03.250  -->  00:01:05.453
So pause the video and give it a try.
22

22

00:01:08.010  -->  00:01:10.970
Okay, so here are the two ways I came up with,
23

23

00:01:10.970  -->  00:01:12.540
and you might have done it another way
24

24

00:01:12.540  -->  00:01:15.410
and that's fine as long as it does
25

25

00:01:15.410  -->  00:01:19.320
what the challenge asked you to do and the code compiles.
26

26

00:01:19.320  -->  00:01:22.210
So we'll say val float one equals
27

27

00:01:22.210  -->  00:01:25.970
and we'll just assign it this float, minus 3847.384
28

28

00:01:30.160  -->  00:01:34.163
and of course we have to add the F suffix at the end of it,
29

29

00:01:34.163  -->  00:01:39.050
otherwise the compiler would interpret this as a double.
30

30

00:01:39.050  -->  00:01:41.642
So that's the first way you can do it.
31

31

00:01:41.642  -->  00:01:43.950
Now, the second way you could do it, of course,
32

32

00:01:43.950  -->  00:01:47.173
is to say float one or float two,
33

33

00:01:48.220  -->  00:01:53.220
float equals -3847.384
34

34

00:01:57.350  -->  00:02:00.880
and you still have to specify the F here, otherwise
35

35

00:02:00.880  -->  00:02:03.150
the compiler's going to read this as a double,
36

36

00:02:03.150  -->  00:02:04.868
and as we said, Kotlin doesn't
37

37

00:02:04.868  -->  00:02:08.200
automatically widen the numeric values
38

38

00:02:08.200  -->  00:02:11.170
when you're going to assign them like this.
39

39

00:02:11.170  -->  00:02:14.180
So you could do that but that's more verbose
40

40

00:02:14.180  -->  00:02:15.500
than you need to be, you'd want to
41

41

00:02:15.500  -->  00:02:18.746
stick to this version up here because the compiler,
42

42

00:02:18.746  -->  00:02:20.370
once you add the F suffix,
43

43

00:02:20.370  -->  00:02:23.200
the compiler can infer what the type is.
44

44

00:02:23.200  -->  00:02:25.570
Now, there is another way you could accomplish the same
45

45

00:02:25.570  -->  00:02:29.877
thing, you could never do this but float three and,
46

46

00:02:32.470  -->  00:02:33.950
well actually we don't need that,
47

47

00:02:33.950  -->  00:02:35.981
the compiler will be able to confer this.
48

48

00:02:35.981  -->  00:02:38.337
So we'll say, -3847.384
49

49

00:02:45.040  -->  00:02:47.303
and then we'll convert it to a float.
50

50

00:02:48.550  -->  00:02:50.680
Now again, you'd never want to do this,
51

51

00:02:50.680  -->  00:02:52.180
this is way too verbose.
52

52

00:02:52.180  -->  00:02:55.358
So, this is the one you really want, but if you came
53

53

00:02:55.358  -->  00:02:58.100
up with these two that's fine as I said,
54

54

00:02:58.100  -->  00:02:59.470
often when you start with Kotlin,
55

55

00:02:59.470  -->  00:03:01.080
you'll start off more verbose and then
56

56

00:03:01.080  -->  00:03:04.970
eventually you'll learn to be more concise.
57

57

00:03:04.970  -->  00:03:06.410
So, that's actually three different
58

58

00:03:06.410  -->  00:03:08.083
ways you can do this one.
59

59

00:03:08.083  -->  00:03:11.202
Okay, so now what I want you to do, is I want you to change.
60

60

00:03:11.202  -->  00:03:14.840
I said both of these variable declarations, because I wasn't
61

61

00:03:14.840  -->  00:03:17.650
going to show you this one but then I thought, why not?
62

62

00:03:17.650  -->  00:03:22.650
So, let's just stick with, let's do these two.
63

63

00:03:22.930  -->  00:03:27.270
Let's take this one away and stick with these two.
64

64

00:03:27.270  -->  00:03:29.450
So, I want you to change both of these
65

65

00:03:29.450  -->  00:03:32.594
variable declarations into nullable variables.
66

66

00:03:32.594  -->  00:03:35.880
So, pause the video and go ahead and do that.
67

67

00:03:38.250  -->  00:03:40.920
Okay, so of course all you have to do,
68

68

00:03:40.920  -->  00:03:44.520
is say float question mark
69

69

00:03:44.520  -->  00:03:46.670
and you'd have to do this for both of them.
70

70

00:03:49.890  -->  00:03:54.890
Because in Kotlin, variables are non-nullable by default,
71

71

00:03:54.930  -->  00:03:58.930
because Kotlin is trying to encourage not allowing
72

72

00:03:58.930  -->  00:04:03.020
null pointer exceptions, so it's just like Val versus Var.
73

73

00:04:03.020  -->  00:04:07.240
Unless you have a really good reason to declare as nullable,
74

74

00:04:07.240  -->  00:04:08.760
it should be non-nullable and so that's
75

75

00:04:08.760  -->  00:04:11.070
the default in Kotlin.
76

76

00:04:11.070  -->  00:04:12.500
Okay, so that was the answer to
77

77

00:04:12.500  -->  00:04:15.400
the second question, which is above now.
78

78

00:04:15.400  -->  00:04:19.420
So, your third challenge is to declare and array
79

79

00:04:19.420  -->  00:04:24.420
of type non-nullable short, make it size five
80

80

00:04:24.420  -->  00:04:26.810
and assign it the values one, two,
81

81

00:04:26.810  -->  00:04:28.780
three, four and five.
82

82

00:04:28.780  -->  00:04:31.453
So pause the video and go ahead and do that.
83

83

00:04:33.620  -->  00:04:35.388
Okay, there are a few ways you can do this.
84

84

00:04:35.388  -->  00:04:37.570
The most concise way to do it,
85

85

00:04:37.570  -->  00:04:42.570
would be to say val short array equals short array of,
86

86

00:04:43.390  -->  00:04:46.423
and then, the initial values.
87

87

00:04:48.550  -->  00:04:49.830
And that's it, that will give you
88

88

00:04:49.830  -->  00:04:52.100
a shorter array of size five,
89

89

00:04:52.100  -->  00:04:53.972
I kind of threw the size five in there,
90

90

00:04:53.972  -->  00:04:56.720
it's a little bit of a trick because,
91

91

00:04:56.720  -->  00:04:58.960
if you're providing the initial values,
92

92

00:04:58.960  -->  00:05:00.990
you don't actually have to specify the size.
93

93

00:05:00.990  -->  00:05:05.990
Now, a longer way to do, if you wanted an array of short
94

94

00:05:07.290  -->  00:05:11.950
rather than the sort of special short array,
95

95

00:05:11.950  -->  00:05:16.950
is to go Val short array two, and this time we'll
96

96

00:05:18.060  -->  00:05:20.453
have to explicitly declare the type.
97

97

00:05:24.090  -->  00:05:28.470
And then you can just say array of one two three
98

98

00:05:28.470  -->  00:05:30.620
four five, you'd have to do it this way
99

99

00:05:30.620  -->  00:05:32.810
if you didn't want to use the special shorter array.
100

100

00:05:32.810  -->  00:05:34.730
And both of these are actually right because
101

101

00:05:34.730  -->  00:05:36.627
I didn't specify in the challenge which one I wanted,
102

102

00:05:36.627  -->  00:05:38.740
so both of these would be right.
103

103

00:05:38.740  -->  00:05:41.810
If you wanted the special short array that you could
104

104

00:05:41.810  -->  00:05:43.769
pass to a Java method, that wanted a short,
105

105

00:05:43.769  -->  00:05:46.359
a primitive sort array, you can do it this way.
106

106

00:05:46.359  -->  00:05:50.410
If you wanted to use Kotlin's array class,
107

107

00:05:50.410  -->  00:05:54.213
it's generic array class, and have a short array,
108

108

00:05:54.213  -->  00:05:55.990
you could do it that way.
109

109

00:05:55.990  -->  00:05:58.189
So, both of these are acceptable, in fact,
110

110

00:05:58.189  -->  00:06:01.038
I wouldn't say this is more verbose because if you want
111

111

00:06:01.038  -->  00:06:04.978
an array of short using Kotlin's generic array,
112

112

00:06:04.978  -->  00:06:07.960
then you've pretty much got to declare it this way.
113

113

00:06:07.960  -->  00:06:11.044
Okay, so now declare an array of nullable,
114

114

00:06:11.044  -->  00:06:12.850
there's an extra L in there,
115

115

00:06:12.850  -->  00:06:17.133
ins and initialise it with the values five, 10, 15, 20,
116

116

00:06:17.133  -->  00:06:20.850
25, 30 et cetera, all the way up to 200.
117

117

00:06:20.850  -->  00:06:23.060
So declare an array of nullable ins
118

118

00:06:23.060  -->  00:06:26.500
and initialise it with this sequence of values
119

119

00:06:26.500  -->  00:06:28.698
starting at five all the way up to 200.
120

120

00:06:28.698  -->  00:06:30.793
Pause the video and try it now.
121

121

00:06:32.760  -->  00:06:36.830
Okay, while using Lambda expression to initialise the array,
122

122

00:06:36.830  -->  00:06:38.438
makes sense for this one, otherwise
123

123

00:06:38.438  -->  00:06:42.540
you're going to have to type out quite a number of values.
124

124

00:06:42.540  -->  00:06:47.540
So, we'll say Val int array equals
125

125

00:06:48.200  -->  00:06:50.683
an array and we want a nullable int.
126

126

00:06:53.470  -->  00:06:57.210
And, you can figure out that there are 40 values that
127

127

00:06:57.210  -->  00:06:59.520
are going to go into the array.
128

128

00:06:59.520  -->  00:07:02.430
Because we start at five, we want to go up to 200,
129

129

00:07:02.430  -->  00:07:04.590
we're going in steps of five and 200
130

130

00:07:04.590  -->  00:07:09.503
divided by five is 40, so we want an array of size 40.
131

131

00:07:10.680  -->  00:07:12.420
And then we're going to use a
132

132

00:07:12.420  -->  00:07:14.260
Lambda expression to initialise it.
133

133

00:07:14.260  -->  00:07:19.260
So, I'll say I, basically for each index we're going to add
134

134

00:07:19.330  -->  00:07:24.040
one to the index, because we don't want to start out with
135

135

00:07:24.040  -->  00:07:28.710
a index of zero and multiply that by five.
136

136

00:07:28.710  -->  00:07:31.467
Okay, so the way this would work of course, is I represents
137

137

00:07:31.467  -->  00:07:35.263
the index and the indices are going to go from zero to 39,
138

138

00:07:35.263  -->  00:07:37.100
because we have 40 elements.
139

139

00:07:37.100  -->  00:07:40.351
So, the first index will be zero, we'll have zero plus one
140

140

00:07:40.351  -->  00:07:44.244
is one, times five is five, next will be one.
141

141

00:07:44.244  -->  00:07:46.913
One plus one is two, times five is 10
142

142

00:07:46.913  -->  00:07:51.333
and then we'll have two plus one is three, times five is 15
143

143

00:07:51.333  -->  00:07:54.950
et cetera, all the way up to index 39.
144

144

00:07:54.950  -->  00:07:57.060
At which case we'll have 39 plus one
145

145

00:07:57.060  -->  00:08:00.390
is 40, times five is 200.
146

146

00:08:00.390  -->  00:08:03.160
So , this is a really convenient way, and as you can see.
147

147

00:08:03.160  -->  00:08:06.448
If we wanted to change the last value and say,
148

148

00:08:06.448  -->  00:08:10.469
well instead of going up to 200 we want you to go up to 1000
149

149

00:08:10.469  -->  00:08:14.818
or 5000, all you'd have to do it change the size here.
150

150

00:08:14.818  -->  00:08:19.288
So, this is a really convenient way to initialise arrays
151

151

00:08:19.288  -->  00:08:22.560
when you have a logical sequence of numbers.
152

152

00:08:22.560  -->  00:08:26.150
Okay, so the next challenge, you have to call a Java method
153

153

00:08:26.150  -->  00:08:28.770
with the following signature from Kotlin.
154

154

00:08:28.770  -->  00:08:30.573
So the Java method has the signature
155

155

00:08:30.573  -->  00:08:35.573
Public Void Method One, and it wants a Char Array.
156

156

00:08:35.730  -->  00:08:39.820
So, for this challenge I want you to declare an array
157

157

00:08:39.820  -->  00:08:42.597
that you could pass to the method and initialise
158

158

00:08:42.597  -->  00:08:45.610
the array with the values A B and C.
159

159

00:08:45.610  -->  00:08:47.970
So, you don't actually have to call the method because,
160

160

00:08:47.970  -->  00:08:49.540
I haven't written that method,
161

161

00:08:49.540  -->  00:08:53.310
but all I want you to do, is declare an array
162

162

00:08:53.310  -->  00:08:57.210
that has the values A B and C, that you could pass to
163

163

00:08:57.210  -->  00:08:59.282
this Java method that's expecting
164

164

00:08:59.282  -->  00:09:02.490
a primitive Char Array as a parameter.
165

165

00:09:02.490  -->  00:09:04.853
So, pause the video and give that a try now.
166

166

00:09:06.910  -->  00:09:11.050
Okay, well because you want to pass the array to
167

167

00:09:11.050  -->  00:09:12.870
a Java method that accepts one of the
168

168

00:09:12.870  -->  00:09:14.860
primitive array types, you'll have to use one
169

169

00:09:14.860  -->  00:09:17.170
of the special primitive arrays in Kotlin.
170

170

00:09:17.170  -->  00:09:21.593
So the way that you'd have to do this is Val Char Array
171

171

00:09:21.593  -->  00:09:26.593
equals Char Array of, and then we have A B and C.
172

172

00:09:31.980  -->  00:09:34.690
So, in this case that's the way you'd have to do it,
173

173

00:09:34.690  -->  00:09:37.280
in the second challenge or the third challenge,
174

174

00:09:37.280  -->  00:09:39.829
rather, when I said non-nullable shorts.
175

175

00:09:39.829  -->  00:09:41.940
There are really two ways you could do that,
176

176

00:09:41.940  -->  00:09:44.025
depending on how you took that question.
177

177

00:09:44.025  -->  00:09:48.660
You could declare the special type short array or you could
178

178

00:09:48.660  -->  00:09:51.080
just use the generic array and declare a short.
179

179

00:09:51.080  -->  00:09:52.962
But for this one, you absolutely must use
180

180

00:09:52.962  -->  00:09:56.576
the special Char Array because, you want to pass it
181

181

00:09:56.576  -->  00:09:59.930
to a method that wants a primitive Char Array.
182

182

00:09:59.930  -->  00:10:03.030
If you were to do an array of Char,
183

183

00:10:03.030  -->  00:10:05.500
like the following, you would not be able
184

184

00:10:05.500  -->  00:10:09.090
to pass that to this Java method.
185

185

00:10:09.090  -->  00:10:11.670
So for this one, you only have one choice
186

186

00:10:11.670  -->  00:10:13.210
and it's got to be the special
187

187

00:10:13.210  -->  00:10:15.266
Char Array that Kotlin provides.
188

188

00:10:15.266  -->  00:10:17.109
Okay, so for the next challenge,
189

189

00:10:17.109  -->  00:10:20.626
given the following line of code, ValEx is a string.
190

190

00:10:20.626  -->  00:10:24.030
It's a nullable string in uppercase, what I want you to do
191

191

00:10:24.030  -->  00:10:27.173
using one line of code, only one line of code.
192

192

00:10:27.173  -->  00:10:31.300
I want you to declare another string variable
193

193

00:10:31.300  -->  00:10:36.300
and I want you to assign X dot lowercase when X isn't null
194

194

00:10:37.530  -->  00:10:41.550
and a string I give up, when X is null.
195

195

00:10:41.550  -->  00:10:45.717
So, using one line of code only, assign X dot to lowercase,
196

196

00:10:45.717  -->  00:10:50.717
when X isn't null and a string I give up when X is null.
197

197

00:10:51.230  -->  00:10:53.393
Pause the video and give it a try.
198

198

00:10:56.070  -->  00:11:00.405
Okay, now while the video is paused I realised that
199

199

00:11:00.405  -->  00:11:03.218
I had missed out a challenge, so I just typed that in,
200

200

00:11:03.218  -->  00:11:06.274
I missed it out when I was typing in the challenges,
201

201

00:11:06.274  -->  00:11:09.117
so that's why this lower part has an extra challenge here.
202

202

00:11:09.117  -->  00:11:11.380
Getting back to challenge number six.
203

203

00:11:11.380  -->  00:11:14.610
The solution is, so we'll go Val Z
204

204

00:11:15.840  -->  00:11:19.650
and we'll say equals, so we're going to say X,
205

205

00:11:19.650  -->  00:11:22.060
use the safety operator, and we're going to convert
206

206

00:11:22.060  -->  00:11:24.891
it to lowercase, but then we're going to use
207

207

00:11:24.891  -->  00:11:28.192
the Elvis operator here, to assign it
208

208

00:11:28.192  -->  00:11:32.410
the I give up string, when X is null.
209

209

00:11:32.410  -->  00:11:33.735
So, what we're saying here is,
210

210

00:11:33.735  -->  00:11:38.735
when X isn't null go ahead and call to lowercase
211

211

00:11:39.170  -->  00:11:41.230
and assign the result to Z.
212

212

00:11:41.230  -->  00:11:45.300
But if X is null, then instead assign
213

213

00:11:45.300  -->  00:11:47.160
the string I give up to Z and we're
214

214

00:11:47.160  -->  00:11:49.740
using the Elvis operator to do that.
215

215

00:11:49.740  -->  00:11:51.400
So, let's print the result just to
216

216

00:11:51.400  -->  00:11:53.480
make sure it's working the way we expect it to.
217

217

00:11:53.480  -->  00:11:55.413
So, we'll say print line and Z,
218

218

00:11:57.770  -->  00:11:59.713
I'll come back up here so I can run,
219

219

00:12:03.120  -->  00:12:05.270
and we'll see that we get the string,
220

220

00:12:05.270  -->  00:12:07.897
I am in uppercase, even though it isn't,
221

221

00:12:07.897  -->  00:12:12.670
because we have converted it now to lowercase.
222

222

00:12:12.670  -->  00:12:15.540
So, because it wasn't null the
223

223

00:12:15.540  -->  00:12:18.750
result to lowercase was assigned to Z.
224

224

00:12:18.750  -->  00:12:22.023
Let's change the value null and try running again.
225

225

00:12:29.010  -->  00:12:31.604
And this time we will see I give up, because it was null so
226

226

00:12:31.604  -->  00:12:35.520
the default sting that we provided has been assigned to Z.
227

227

00:12:35.520  -->  00:12:36.978
Alright, so for your next challenge.
228

228

00:12:36.978  -->  00:12:41.170
Now I want you to use the left function to do two things.
229

229

00:12:41.170  -->  00:12:44.435
First of all lowercase the string and then to
230

230

00:12:44.435  -->  00:12:47.930
replace am with am not, in the results.
231

231

00:12:47.930  -->  00:12:52.617 line:15% 
So, we need to change this back to I am in uppercase.
232

232

00:12:56.580  -->  00:12:59.823 line:15% 
So, we'll go back to that and we now want to use
233

233

00:12:59.823  -->  00:13:01.910 line:15% 
that function to lowercase the string,
234

234

00:13:01.910  -->  00:13:04.880 line:15% 
and then to replace am with am not.
235

235

00:13:04.880  -->  00:13:07.383
So, pause the video and go ahead and do that now.
236

236

00:13:09.230  -->  00:13:12.210
Okay, so for this one we're going to start out by using
237

237

00:13:12.210  -->  00:13:14.476
the safety operator and then call the left function.
238

238

00:13:14.476  -->  00:13:17.310
And as we can see IntelliJ saying that
239

239

00:13:17.310  -->  00:13:19.593
we want to block here, so I'm going to put a block.
240

240

00:13:19.593  -->  00:13:24.470
And we'll say It, that's how we refer to X
241

241

00:13:24.470  -->  00:13:26.993
inside the Lambda expression dot to lowercase,
242

242

00:13:26.993  -->  00:13:29.288
that was the first step that we wanted to do.
243

243

00:13:29.288  -->  00:13:32.453
And then once everything is lowercase, we want to replace
244

244

00:13:32.453  -->  00:13:36.640
am with am not, so we'll use the replace function
245

245

00:13:36.640  -->  00:13:41.280
and we'll replace am with am not.
246

246

00:13:41.280  -->  00:13:43.170
And that will work, now if we want
247

247

00:13:43.170  -->  00:13:45.090
to check that, we can print it,
248

248

00:13:45.090  -->  00:13:49.053
so let's put this into print line, and we'll run.
249

249

00:13:53.140  -->  00:13:57.545
And we can see that the string X was
250

250

00:13:57.545  -->  00:14:01.120
lowercase and am was replaced with am not.
251

251

00:14:01.120  -->  00:14:03.310
Okay, so our final challenge is.
252

252

00:14:03.310  -->  00:14:05.624
You're really, really confident that the variable
253

253

00:14:05.624  -->  00:14:10.120
my non-null variable can't contain no.
254

254

00:14:10.120  -->  00:14:12.661
So, change the following code to assert
255

255

00:14:12.661  -->  00:14:15.800
that my non-null variable isn't no,
256

256

00:14:15.800  -->  00:14:18.968
and shoot yourself in the foot, because of course it is.
257

257

00:14:18.968  -->  00:14:22.230
So, essentially I want you to do something to
258

258

00:14:22.230  -->  00:14:25.650
this code here that asserts, that tells the compiler
259

259

00:14:25.650  -->  00:14:28.510
that you're absolutely sure, that my non-null
260

260

00:14:28.510  -->  00:14:30.220
variable is not null.
261

261

00:14:30.220  -->  00:14:32.483
So, pause the video and go ahead and do that.
262

262

00:14:34.810  -->  00:14:36.836
Okay, so you might have thought of doing
263

263

00:14:36.836  -->  00:14:39.430
something like that but, of course that won't work
264

264

00:14:39.430  -->  00:14:41.440
because then you can't assign no.
265

265

00:14:41.440  -->  00:14:44.953
So, you've got to keep the variable as a nullable variable,
266

266

00:14:44.953  -->  00:14:47.893
but what you would do is, instead of using
267

267

00:14:47.893  -->  00:14:51.244
a safety operator, you'd use two exclamation marks
268

268

00:14:51.244  -->  00:14:54.920
which is the not null assertion and say no, no
269

269

00:14:54.920  -->  00:14:58.950
I am absolutely sure that my non-null variable is not null.
270

270

00:14:58.950  -->  00:15:01.350
Now obviously in this case you would be lying,
271

271

00:15:01.350  -->  00:15:03.630
and you would get a null pointer exception,
272

272

00:15:03.630  -->  00:15:05.590
but this is how you would do it.
273

273

00:15:05.590  -->  00:15:08.494
So, instead of using the question mark, the safety operator,
274

274

00:15:08.494  -->  00:15:11.564
you would use the not null assertion.
275

275

00:15:11.564  -->  00:15:14.440
Okay, that's enough practise.
276

276

00:15:14.440  -->  00:15:17.680
And once again if you struggled writing the more concise way
277

277

00:15:17.680  -->  00:15:20.000
don't worry you'll get better with practise
278

278

00:15:20.000  -->  00:15:24.083
and also as I said in the last video, keep in mind
279

279

00:15:24.083  -->  00:15:27.007
that the less concise ways are perfectly valid,
280

280

00:15:27.007  -->  00:15:28.930
they're perfectly valid code,
281

281

00:15:28.930  -->  00:15:30.301
but they're not the Kotlin way.
282

282

00:15:30.301  -->  00:15:32.546
And also, as I said in a previous video,
283

283

00:15:32.546  -->  00:15:36.304
depending on the situation, writing the code in a verbose
284

284

00:15:36.304  -->  00:15:40.413
way isn't invalid, I mean your Kotlin code will still run.
285

285

00:15:40.413  -->  00:15:42.680
It's just not the Kotlin way.
286

286

00:15:42.680  -->  00:15:44.790
So as you become a more adept Kotlin developer,
287

287

00:15:44.790  -->  00:15:47.794
you'll want to abandon the more verbose way
288

288

00:15:47.794  -->  00:15:51.340
and use the short hand way of doing things.
289

289

00:15:51.340  -->  00:15:53.320
And that will become more natural to you,
290

290

00:15:53.320  -->  00:15:55.120
the more you work with that language.
291

291

00:15:55.120  -->  00:15:56.770
I'll see you in the next section.
