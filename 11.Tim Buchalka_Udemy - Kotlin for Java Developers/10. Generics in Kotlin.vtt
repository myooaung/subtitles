WEBVTT
1
00:00:05.360 --> 00:00:09.950
There isn't much difference between Cartland and Jabo when it comes to generics and how to use them.

2
00:00:09.960 --> 00:00:13.930
But you can do a few more things in cotland.

3
00:00:13.970 --> 00:00:19.970
But before we get to that let's do a whirlwind review of generics to make sure we're all on the same

4
00:00:19.970 --> 00:00:21.240
page.

5
00:00:21.260 --> 00:00:27.320
Now you used generics to give the compiler a hint about what types of objects you're dealing with often

6
00:00:27.320 --> 00:00:28.900
when related to collections.

7
00:00:28.910 --> 00:00:35.570
And this also allows the compiler to do some error checking at compile time.

8
00:00:35.570 --> 00:00:38.180
For example let's declare a list in Java.

9
00:00:38.180 --> 00:00:49.920
I've already created a java file with a main method so will say list list equals new array list.

10
00:00:49.970 --> 00:00:55.940
Now we've created a list but there's no indication of what type of object we want to store in the list.

11
00:00:56.150 --> 00:01:02.420
Maybe we'll store some mixed type objects but more likely we'll want to store strings or employees or

12
00:01:02.420 --> 00:01:03.450
cars.

13
00:01:03.650 --> 00:01:10.160
It's better for us to specify what will store because the compiler can then catch errors at compile

14
00:01:10.160 --> 00:01:11.120
time.

15
00:01:11.240 --> 00:01:14.920
The code is clearer and we won't have to cast so often.

16
00:01:15.080 --> 00:01:18.060
We use generics to specify the type.

17
00:01:18.170 --> 00:01:20.930
In this case we'll create an array list of string.

18
00:01:21.110 --> 00:01:30.230
So all we have to do is add string here so we add string between angle brackets after the collection

19
00:01:30.230 --> 00:01:30.710
type.

20
00:01:30.710 --> 00:01:34.250
So let's now go ahead and add a string to the list so will say list.

21
00:01:34.260 --> 00:01:40.430
Add And let's add hello and I need the pesky semi-colons now because we're in Java.

22
00:01:40.520 --> 00:01:45.680
And now let's try adding something that isn't a string so we'll say list start at and now let's add

23
00:01:45.680 --> 00:01:51.110
a decimal ten point five.

24
00:01:51.680 --> 00:01:52.940
And of course we can do it.

25
00:01:52.940 --> 00:01:59.420
We get a compile time error so because we provided the type the compiler can now do type checking at

26
00:01:59.420 --> 00:02:00.490
compile time.

27
00:02:00.500 --> 00:02:08.340
So now let's call uppercase on the string that we added so will say list get zero Daut.

28
00:02:08.600 --> 00:02:12.890
And you'll notice that we're getting suggestions for the string class.

29
00:02:12.890 --> 00:02:19.340
So at this point the compiler will know that the element that we're going to get is a string.

30
00:02:19.340 --> 00:02:26.260
Because this is a list of string and we'll just select to uppercase and we can now call to uppercase

31
00:02:26.270 --> 00:02:27.790
without having to cast.

32
00:02:27.860 --> 00:02:33.920
Because as I said the compiler knows that the item that we're going to get is a string so we can use

33
00:02:33.920 --> 00:02:39.680
generics whenever we want to be more specific about a type we can use them with parameters as return

34
00:02:39.680 --> 00:02:43.330
values from functions and in declarations.

35
00:02:43.460 --> 00:02:45.870
We can also do the following in Java.

36
00:02:45.890 --> 00:02:56.270
We can say list to list one equals a new array list and then we can say lists start add and let's add.

37
00:02:56.300 --> 00:02:58.460
Good by this time.

38
00:02:58.520 --> 00:03:04.920
Now here we haven't provided the type and there's no compile error so we don't have to provide the type.

39
00:03:05.180 --> 00:03:07.550
But it's good practice to do so.

40
00:03:07.580 --> 00:03:10.890
All right so now let's go over to Kallen.

41
00:03:11.060 --> 00:03:16.670
So we're going to declare a mutable list because we're going to want to add elements to it after we've

42
00:03:16.670 --> 00:03:17.640
created it.

43
00:03:17.870 --> 00:03:25.020
So I'll say Vau list and we're going to make an immutable list.

44
00:03:25.040 --> 00:03:33.620
Now you'll notice we're going to get an error here because we haven't specified a type for the list.

45
00:03:33.740 --> 00:03:38.800
So back here in Java we were able to declare a list and not say anything about the type.

46
00:03:38.810 --> 00:03:42.250
But here in CANTLIN the compiler is complaining.

47
00:03:42.590 --> 00:03:48.790
And that's because in cotland you have to use a generic type when with collections.

48
00:03:48.980 --> 00:03:53.210
So unlike Java the best practice of doing that is enforced.

49
00:03:53.210 --> 00:04:02.930
So we're going to use strings as we didn't Javaris all say string string and then we'll say mutable

50
00:04:03.590 --> 00:04:09.560
list of an all give it hello like we had in Java.

51
00:04:09.560 --> 00:04:13.430
Now of course now that I'm using this we can remove that.

52
00:04:13.460 --> 00:04:20.210
I deliberately put the typed in on the variable because I wanted to show you that the compiler would

53
00:04:20.210 --> 00:04:24.370
complain if we didn't use provide the type in the list.

54
00:04:24.380 --> 00:04:27.520
OK so now we'll continue to do what we did in Java.

55
00:04:27.530 --> 00:04:38.760
So we want to uppercase the first element so will say list 0 dot to uppercase and that works.

56
00:04:38.780 --> 00:04:42.400
So this is the equivalent now of what we had in Java.

57
00:04:42.410 --> 00:04:46.020
So now let's take a look at how to use generics with functions.

58
00:04:46.250 --> 00:04:49.740
So let's say we have the following function fun.

59
00:04:50.030 --> 00:04:58.690
Print collection and we'll say it accepts a collection and we have a collection of strings so we want

60
00:04:58.690 --> 00:04:59.620
a collection of string.

61
00:04:59.620 --> 00:05:07.040
Remember you have to provide a generic type so I'll say for item in collection.

62
00:05:07.190 --> 00:05:08.860
Print line the item.

63
00:05:08.930 --> 00:05:15.430
So let's add another string to our list so that we have a more interesting list here so will say Alliston

64
00:05:15.470 --> 00:05:20.390
add another string and then we'll print the collection

65
00:05:24.860 --> 00:05:26.620
and mail run now

66
00:05:31.040 --> 00:05:34.410
and we'll see that we get our strings in our collection.

67
00:05:34.500 --> 00:05:35.910
So that's great.

68
00:05:35.910 --> 00:05:39.610
All right now let's create a list of big decimal numbers.

69
00:05:39.840 --> 00:05:44.250
I'm going to comment or actually I'll just remove this because it's kind of hanging there and we're

70
00:05:44.250 --> 00:05:45.700
not doing anything with it.

71
00:05:45.870 --> 00:05:51.590
So we'll say Val B list equals mutable list of.

72
00:05:51.630 --> 00:06:01.800
And in this case I want to tell it the type here by providing the initial value civil same minus thirty

73
00:06:01.800 --> 00:06:05.260
three point forty five.

74
00:06:06.210 --> 00:06:09.960
And we'll say the decimal 3 5 0.

75
00:06:09.960 --> 00:06:19.010
Three point ninety nine and let's see that one more decimal zero point three to nine.

76
00:06:19.380 --> 00:06:25.220
OK so now we're going to call our print collection function to print this list here.

77
00:06:25.500 --> 00:06:28.230
So all saying you can probably guess it's going to happen.

78
00:06:28.230 --> 00:06:32.520
Print collection and we'll say B-D list.

79
00:06:32.880 --> 00:06:38.700
And we're going to get an error here because it's going to say well you want a list of string for this

80
00:06:38.700 --> 00:06:44.440
function and you are providing me with a list of big decimals so sorry but that doesn't work.

81
00:06:44.460 --> 00:06:51.060
Now obviously we don't want to have to create a print collection function for every possible type of

82
00:06:51.060 --> 00:06:52.630
lists that we might want to deal with.

83
00:06:52.740 --> 00:06:54.590
Unfortunately we don't have to.

84
00:06:54.630 --> 00:06:59.860
Just like in Java we'll use t as the generic type which means any type.

85
00:06:59.970 --> 00:07:05.440
So we'll change our declaration here will say Chih.

86
00:07:06.630 --> 00:07:10.440
And then over here we'll say to you as well.

87
00:07:10.440 --> 00:07:14.840
So here we're saying that this function will accept any type of list.

88
00:07:14.850 --> 00:07:24.240
Now once we use t here we have to put this t here as well to indicate that the function is using generics

89
00:07:24.570 --> 00:07:31.440
and this T and angle brackets after the find key word is called the type parameter declaration.

90
00:07:31.440 --> 00:07:33.920
Now there's really nothing new here compared to Java.

91
00:07:33.930 --> 00:07:38.220
But I want to make sure we're all on the same page before we start looking at some of the more serious

92
00:07:38.220 --> 00:07:44.700
stuff like covariance and contravariant is also the Cartland standard library is filled with functions

93
00:07:44.700 --> 00:07:50.250
that use generics so if you don't understand how to read function signatures you'll have a difficult

94
00:07:50.250 --> 00:07:54.060
time understanding what the function expects and what it returns.

95
00:07:54.420 --> 00:07:57.970
So now it's called a print collection function with the big decimal list.

96
00:07:57.990 --> 00:08:01.480
Well actually we're already doing that and will see that the error has gone away.

97
00:08:01.620 --> 00:08:03.900
So we can actually run this now.

98
00:08:06.650 --> 00:08:11.460
And we'll see our strings list printed and then our big decimals.

99
00:08:11.870 --> 00:08:15.790
So what we're saying here is will now accept a list of any type.

100
00:08:15.800 --> 00:08:21.440
Now we could have written this function differently we could have instead of making it a top level function

101
00:08:21.440 --> 00:08:25.430
we could have made it an extension function for a list of T.

102
00:08:25.460 --> 00:08:31.400
So let's do it that way now so instead of passing the list as a parameter we'll call the function on

103
00:08:31.400 --> 00:08:32.000
the list.

104
00:08:32.000 --> 00:08:36.750
And we really just have to put a list t here.

105
00:08:37.140 --> 00:08:47.150
Daut and then remove that parameter and then of course insight instead of collection we'll just say

106
00:08:47.180 --> 00:08:54.590
this because remember when your using a in defining an extension function you use this to refer to the

107
00:08:54.590 --> 00:08:58.140
instance that you're going to use to invoke the function.

108
00:08:58.160 --> 00:09:03.070
So now that print collection is it is an extension function on list.

109
00:09:03.080 --> 00:09:10.880
It will be invoked using an instance of list and we refer to that instance as this inside the extension

110
00:09:10.880 --> 00:09:11.780
function.

111
00:09:11.780 --> 00:09:18.110
So we'll have to update our two calls because the print collection that takes a list doesn't exist anymore

112
00:09:18.110 --> 00:09:24.230
so one will want to say list dot print collection and we don't need the parameter anymore.

113
00:09:24.230 --> 00:09:25.600
And the same thing here.

114
00:09:25.610 --> 00:09:30.950
B the list Daut and we don't need the parameter anymore and if we run

115
00:09:33.820 --> 00:09:36.120
we'll see that we get the same thing.

116
00:09:36.670 --> 00:09:45.850
So if you want to define a an extension function that can be invoked which is a collection of type T

117
00:09:46.090 --> 00:09:51.400
then this is the way that you would do it or anytime that you want to define an extension function on

118
00:09:51.400 --> 00:09:55.230
a class that takes a type T.

119
00:09:55.240 --> 00:09:57.050
This is the way that you would do it.

120
00:09:57.050 --> 00:10:04.060
Now print collections was doing something that wasn't silly and that your application would do a lot.

121
00:10:04.060 --> 00:10:07.090
It might make sense to write it as an extension function.

122
00:10:07.090 --> 00:10:12.100
You might also want to do it as an extension function if you want it to make the function available

123
00:10:12.100 --> 00:10:14.890
to everyone on your development team.

124
00:10:14.980 --> 00:10:20.100
And if you want it the idea to include it in its suggestions as we've said before.

125
00:10:20.200 --> 00:10:27.610
Now in addition to having a generic type as the function parameter of course you can always use generics

126
00:10:27.610 --> 00:10:34.210
in the function's return type specific type that will be returned can be inferred by the compiler and

127
00:10:34.210 --> 00:10:39.750
you can also as in Java declare generic classes and interfaces.

128
00:10:39.850 --> 00:10:46.810
OK so now that we've had that whirlwind tour of generics will move into some of them more Katlin specific

129
00:10:46.810 --> 00:10:49.150
stuff and we'll do that in the next video.
