WEBVTT
1

00:00:01.350  -->  00:00:07.650
Hello everyone and welcome to the phone screen solution for the search engine company mock interview

2

00:00:07.650  -->  00:00:08.640
.

3

00:00:08.640  -->  00:00:12.880
So just to remind you they should be practicing your non-technical question answers.

4

00:00:13.020  -->  00:00:15.120
I gave you some non-technical questions here.

5

00:00:15.130  -->  00:00:16.840
These should be able to answer.

6

00:00:16.920  -->  00:00:22.320
Go ahead and review the list of non-technical questions earlier in the course to really get good practice

7

00:00:22.320  -->  00:00:24.980
on that as far as the solution for those.

8

00:00:24.990  -->  00:00:26.710
There aren't really any correct answers here.

9

00:00:26.730  -->  00:00:30.750
Just make sure you're prepared to answer the following questions about the company interviewing with

10

00:00:30.780  -->  00:00:35.910
be honest friendly and ready to defend any statements you make of logical arguments to back them up

11

00:00:35.910  -->  00:00:36.500
.

12

00:00:36.510  -->  00:00:39.820
So if you say like Python is my favorite programming language.

13

00:00:39.900  -->  00:00:42.740
Make sure you have logical arguments to back that up.

14

00:00:42.750  -->  00:00:45.700
No you should always have follow up questions.

15

00:00:45.780  -->  00:00:49.680
Go ahead and review the follow up questions list we have earlier in the course.

16

00:00:49.740  -->  00:00:54.610
Now with that being said let's go ahead and move on to that technical question.

17

00:00:54.630  -->  00:01:00.360
So here is the question right a function that computes the nth Fibonacci number.

18

00:01:00.480  -->  00:01:02.670
So there's lots of ways to answer this question.

19

00:01:02.790  -->  00:01:07.650
And in an interview setting you might be able you might be required to solve multiple ways and discuss

20

00:01:07.650  -->  00:01:09.430
some pros and cons of each way.

21

00:01:09.540  -->  00:01:12.580
So we're going to walk through the various ways of doing it.

22

00:01:12.660  -->  00:01:15.070
Going to zoom in here so you can really see it.

23

00:01:15.880  -->  00:01:16.680
OK.

24

00:01:16.710  -->  00:01:22.740
So we're going to go through about five examples here using a looping technique using recursion using

25

00:01:22.740  -->  00:01:25.750
generators using minimization.

26

00:01:26.160  -->  00:01:29.940
And then also using the Moyes ation as a decorator.

27

00:01:29.940  -->  00:01:30.630
All right.

28

00:01:30.630  -->  00:01:34.220
So let's go ahead and discuss each of these solutions.

29

00:01:34.320  -->  00:01:36.980
So we're actually going to code anything out we're just going to talk about this.

30

00:01:36.980  -->  00:01:42.360
So using a looping technique what are we doing here in this particular function we're taking advantage

31

00:01:42.990  -->  00:01:46.230
of Python's tuple unpacking packing here.

32

00:01:46.230  -->  00:01:51.240
So we say A and B are both equal to one and then we say for Iron Range and minus one.

33

00:01:51.270  -->  00:01:58.320
We're just looping through that range and resetting a equal to B and B equal to A plus B that previous

34

00:01:58.320  -->  00:01:58.900
say.

35

00:01:59.070  -->  00:02:01.080
Then at the end we just return a.

36

00:02:01.080  -->  00:02:03.450
So pretty simple pretty straightforward.

37

00:02:03.690  -->  00:02:06.990
Using recursion you may be in a situation where an entire resetting.

38

00:02:07.020  -->  00:02:11.280
They specifically ask you to do this using recursion to test if you know recursion or not.

39

00:02:11.310  -->  00:02:18.350
So let's go over the solution here we have our recursion sequence and then we have a base case member

40

00:02:18.420  -->  00:02:24.660
recursions always have base cases so we say if and is equal to 1 or 2 in this case we're starting at

41

00:02:24.660  -->  00:02:25.350
1 and 2.

42

00:02:25.380  -->  00:02:30.690
You may have Zura on one depending where you start your Fibonacci sequence here or just returning one

43

00:02:30.690  -->  00:02:31.000
.

44

00:02:31.170  -->  00:02:37.200
Otherwise we do a recursive call the function of and minus one and and minus two.

45

00:02:37.530  -->  00:02:43.770
And here we're calling on seven if we have another example using generators here again we're taking

46

00:02:43.770  -->  00:02:49.840
advantage of tuple packing starting at 0 and 1 for this Fibonacci Sequence say global A B.

47

00:02:50.040  -->  00:02:51.910
Because we're doing a generator we are ahead of the final.

48

00:02:51.930  -->  00:02:59.220
Outside of that function and then say while true we're yielding It really really similar to that looping

49

00:02:59.220  -->  00:02:59.700
statement.

50

00:02:59.700  -->  00:03:01.870
But in this case we're doing a generator.

51

00:03:02.100  -->  00:03:06.120
So you'd have to keep calling next in order to see all the results.

52

00:03:06.510  -->  00:03:11.800
Ok then finally using memoization in this case without a decorator.

53

00:03:12.150  -->  00:03:20.670
So we have memo here and we're going to take an F N and are now we're saying if Argives not already

54

00:03:20.670  -->  00:03:28.560
and memo memo at that argument is equal to argument into that function and then we'll return memo at

55

00:03:28.620  -->  00:03:29.010
ARG.

56

00:03:29.040  -->  00:03:31.030
So those who are using keys here.

57

00:03:31.320  -->  00:03:36.070
So using memoization we're going to pass in that function.

58

00:03:36.420  -->  00:03:43.800
And the end number we want and set it equal to an object we put in memorize and then if we want to use

59

00:03:43.800  -->  00:03:51.480
minimization as a decorator we can actually make a class really similar in function scope we say def

60

00:03:51.510  -->  00:03:59.640
in it we initialize with some function set memo equal to empty here and then we say again if arge not

61

00:03:59.640  -->  00:04:07.350
already in that memoization tracker that dictionary we set that argument's equal to the argument passed

62

00:04:07.350  -->  00:04:08.100
into the function.

63

00:04:08.100  -->  00:04:09.680
So we're keeping track of things.

64

00:04:10.050  -->  00:04:17.750
And then you can use a decorator to pass it into or over that regular Fibonacci looping function.

65

00:04:18.100  -->  00:04:24.570
Ok as far as depicted average relative performance went ahead and ran this on a computer so you can

66

00:04:24.570  -->  00:04:26.070
get an idea here.

67

00:04:26.070  -->  00:04:29.000
So redo doing unequals 15000.

68

00:04:29.130  -->  00:04:30.030
And what are the results.

69

00:04:30.030  -->  00:04:35.740
Let's zoom out so we can see a little more here if you're using loops recursion generators.

70

00:04:35.750  -->  00:04:39.090
Memorization and memorization as a decorator.

71

00:04:39.090  -->  00:04:41.930
Clearly recursion probably the worst way to go.

72

00:04:42.030  -->  00:04:46.920
You should know that in your interview and that makes sense because you're having to recalculate things

73

00:04:47.100  -->  00:04:48.640
over and over again.

74

00:04:48.660  -->  00:04:55.140
Remember we discussed in the recursions section how you can use memoization to improve on just general

75

00:04:55.140  -->  00:04:56.880
recursion.

76

00:04:56.880  -->  00:05:03.510
Also loops pretty straightforward but probably the better ways to go are taking advantage of recursion

77

00:05:03.570  -->  00:05:05.670
through memo ization.

78

00:05:05.690  -->  00:05:06.450
All right.

79

00:05:06.810  -->  00:05:12.810
Again hopefully you are able to answer at least one of these methods and the question is to get a good

80

00:05:12.810  -->  00:05:14.360
idea of how to approach it.

81

00:05:14.400  -->  00:05:19.740
One simple problem through multiple different methods and understand the pros and cons of each of those

82

00:05:19.760  -->  00:05:20.060
.

83

00:05:20.340  -->  00:05:23.290
All right thanks everyone and I'll see you at the next lecture
