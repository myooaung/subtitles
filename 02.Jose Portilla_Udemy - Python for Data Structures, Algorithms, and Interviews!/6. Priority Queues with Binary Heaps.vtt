WEBVTT
1

00:00:01.590  -->  00:00:06.870
Hello everyone and welcome to priority queues with binary heaps lecture.

2

00:00:06.900  -->  00:00:12.420
So we're going to switch gears a bit and talk about priority queues with binary heaps and later on we'll

3

00:00:12.420  -->  00:00:14.660
see how that relates to trees.

4

00:00:14.820  -->  00:00:22.790
So we discuss stacks queues and decks and now we're going to talk about an important variation of a

5

00:00:22.790  -->  00:00:24.060
cube called a priority.

6

00:00:24.060  -->  00:00:26.640
Q So a priority queue X..

7

00:00:26.660  -->  00:00:32.900
Q In that you can dequeue or remove an item by removing it from the front.

8

00:00:33.030  -->  00:00:38.400
However in a priority queue the logical order of the items inside the queue are determined by their

9

00:00:38.400  -->  00:00:39.470
priority.

10

00:00:39.860  -->  00:00:45.450
So the highest priority items are at the front of the queue and the lowest priority items are actually

11

00:00:45.450  -->  00:00:46.390
at the back.

12

00:00:46.560  -->  00:00:53.640
And then when you and Q are in queue basically meaning adding an item to your queue into that priority

13

00:00:53.640  -->  00:00:58.200
queue the new item may actually move all the way to the front depending on its priority.

14

00:00:58.830  -->  00:01:03.990
So the classic way to implement implement a priority queue is using a data structure called a binary

15

00:01:03.990  -->  00:01:11.340
heap and the binary heap is going to allow us to both on queue and the queue and remove items from this

16

00:01:11.340  -->  00:01:12.310
priority queue.

17

00:01:12.690  -->  00:01:17.730
On order of log n so the binary heap has two common variations.

18

00:01:17.730  -->  00:01:22.800
The min heap in which the smallest key is always at the front and the max heap in which the largest

19

00:01:22.800  -->  00:01:24.640
key value is always at the front.

20

00:01:25.050  -->  00:01:28.610
In this section in the next lecture we're going to implement the min heat.

21

00:01:29.220  -->  00:01:34.800
OK so let's go ahead and get ready for the next lecture where we're going to discuss the implementation

22

00:01:34.800  -->  00:01:35.160
.

23

00:01:35.160  -->  00:01:40.290
Show some code throughout a presentation and then you'll have a Jupiter note book as a resource.

24

00:01:40.440  -->  00:01:45.430
So the next Look she likes to see a presentation and you'll be able to refer to the code Notebook.

25

00:01:45.570  -->  00:01:50.340
We're not actually going to live code it because there's a bit of an explanation to go through as far

26

00:01:50.340  -->  00:01:52.810
as what the binary heap is actually doing.

27

00:01:53.100  -->  00:01:53.790
All right.

28

00:01:53.850  -->  00:01:55.880
Thanks and I'll see at the next lecture.
