WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.230
in this video,

00:00:01.230 --> 00:00:01.890
Let's go.

00:00:01.890 --> 00:00:05.070
I have an understanding off Do pull collection,

00:00:05.070 --> 00:00:06.940
which is a read only collection.

00:00:06.940 --> 00:00:14.630
And you can create a pupil by typing something like names equals toe in around bracket.

00:00:14.630 --> 00:00:18.180
You can get some values that'll give you the note on,

00:00:18.180 --> 00:00:21.630
say no and then at a press enter now,

00:00:21.630 --> 00:00:29.920
type off names is tube so you can access the values back by typing names off zero on names

00:00:29.920 --> 00:00:30.280
off.

00:00:30.280 --> 00:00:32.410
One notice that even though,

00:00:32.410 --> 00:00:32.680
well,

00:00:32.680 --> 00:00:34.530
we create the dupe,

00:00:34.530 --> 00:00:35.860
abused their own bracket,

00:00:35.860 --> 00:00:39.850
we're gonna use the script record for accessing the values at a given index.

00:00:39.850 --> 00:00:42.400
And like in case off list,

00:00:42.400 --> 00:00:44.070
If I take your names off two,

00:00:44.070 --> 00:00:45.630
which is an invalid index,

00:00:45.630 --> 00:00:48.050
we're gonna get an index better.

00:00:48.050 --> 00:00:50.230
And it was their names off miners.

00:00:50.230 --> 00:00:50.550
One.

00:00:50.550 --> 00:00:52.880
I'm gonna get the last name there,

00:00:52.880 --> 00:00:54.820
which is a no same thing.

00:00:54.820 --> 00:00:55.420
My bad.

00:00:55.420 --> 00:00:57.590
I should have said here names off,

00:00:57.590 --> 00:01:00.370
minus one to get the last element.

00:01:00.370 --> 00:01:01.300
So we got it.

00:01:01.300 --> 00:01:02.340
Names off.

00:01:02.340 --> 00:01:03.250
Minus two.

00:01:03.250 --> 00:01:07.150
We get the first element off the last but one element.

00:01:07.150 --> 00:01:08.010
But again,

00:01:08.010 --> 00:01:11.230
if I say names off minus three because at this time,

00:01:11.230 --> 00:01:13.280
minus three is an invalid Index.

00:01:13.280 --> 00:01:16.300
You're going to get an index better anyways,

00:01:16.300 --> 00:01:17.510
but I like the list.

00:01:17.510 --> 00:01:22.190
If you try to say names off zero equals toe something tell,

00:01:22.190 --> 00:01:22.480
say,

00:01:22.480 --> 00:01:23.310
for example,

00:01:23.310 --> 00:01:24.000
Robert.

00:01:24.000 --> 00:01:26.070
And then I press enter in.

00:01:26.070 --> 00:01:26.310
C.

00:01:26.310 --> 00:01:27.920
Get an error type.

00:01:27.920 --> 00:01:31.490
A doable object does not support item assignment,

00:01:31.490 --> 00:01:33.950
so my name's are intact.

00:01:33.950 --> 00:01:34.850
However,

00:01:34.850 --> 00:01:38.290
if you want to use the plus equals two operator,

00:01:38.290 --> 00:01:39.440
that is a load,

00:01:39.440 --> 00:01:42.710
mainly because it's going to be a new object.

00:01:42.710 --> 00:01:43.620
Let me show you.

00:01:43.620 --> 00:01:45.720
10 examples are tape your names.

00:01:45.720 --> 00:01:48.650
It contains a pupil off two names.

00:01:48.650 --> 00:01:52.780
If I say their names plus equals two and then use another,

00:01:52.780 --> 00:01:57.950
do you put it like this on one more name like this?

00:01:57.950 --> 00:02:00.810
This is going toe.

00:02:00.810 --> 00:02:05.880
Create a new pupil consisting off the original two names,

00:02:05.880 --> 00:02:07.170
plus these two names,

00:02:07.170 --> 00:02:10.330
and that new name will be assigned toe names.

00:02:10.330 --> 00:02:10.990
So,

00:02:10.990 --> 00:02:11.490
for example,

00:02:11.490 --> 00:02:12.880
if a press enter now,

00:02:12.880 --> 00:02:15.700
you'll see that names consist of four names,

00:02:15.700 --> 00:02:19.060
but it doesn't mean that it follows us to write.

00:02:19.060 --> 00:02:19.750
For example,

00:02:19.750 --> 00:02:21.890
if I take your idea off names,

00:02:21.890 --> 00:02:23.740
you'll see that there is a number.

00:02:23.740 --> 00:02:26.850
If I think you're names plus equals two,

00:02:26.850 --> 00:02:28.930
and then let's say I want toe are,

00:02:28.930 --> 00:02:29.420
say,

00:02:29.420 --> 00:02:33.350
Rahul and broke it as two more names.

00:02:33.350 --> 00:02:34.490
I press ender.

00:02:34.490 --> 00:02:36.720
Never say I d off names.

00:02:36.720 --> 00:02:44.540
It's going to be a different object because people doesn't follow a mutation or changing of

00:02:44.540 --> 00:02:45.010
the value.

00:02:45.010 --> 00:02:48.850
So it has constructed a new to pull all together.

00:02:48.850 --> 00:02:53.340
So unlike the list of people doesn't have much functions.

00:02:53.340 --> 00:02:54.150
If I take care,

00:02:54.150 --> 00:02:57.170
dear names now are the air people.

00:02:57.170 --> 00:03:00.620
You'll see that there are only two functions.

00:03:00.620 --> 00:03:00.830
One,

00:03:00.830 --> 00:03:07.040
it's called Count on when it's called Index Count gives the number of elements are number

00:03:07.040 --> 00:03:10.020
off occurrences given next exists.

00:03:10.020 --> 00:03:10.820
In our case,

00:03:10.820 --> 00:03:12.940
we have a collection off unique names.

00:03:12.940 --> 00:03:15.280
Here s so if a type your names,

00:03:15.280 --> 00:03:18.440
you can see that there is no duplication so engaged.

00:03:18.440 --> 00:03:19.900
If I add one more time,

00:03:19.900 --> 00:03:20.170
say,

00:03:20.170 --> 00:03:20.870
for example,

00:03:20.870 --> 00:03:22.550
these two values prove it.

00:03:22.550 --> 00:03:23.450
And Rahul,

00:03:23.450 --> 00:03:27.490
no names rode with on ground exist twice.

00:03:27.490 --> 00:03:32.600
But as the rest of them exist only once they type your name start conked off.

00:03:32.600 --> 00:03:33.050
Say,

00:03:33.050 --> 00:03:33.780
for example,

00:03:33.780 --> 00:03:34.420
Rodel,

00:03:34.420 --> 00:03:37.050
which is that the count of Robin is too.

00:03:37.050 --> 00:03:39.140
Whereas if I try pure safety,

00:03:39.140 --> 00:03:40.970
not it's only one time.

00:03:40.970 --> 00:03:43.490
So called is not the number of elements.

00:03:43.490 --> 00:03:49.480
But count is the number of times an element occurs within a list or irritable,

00:03:49.480 --> 00:03:53.200
so Index will give the index often element if it exists.

00:03:53.200 --> 00:03:54.080
For example,

00:03:54.080 --> 00:03:56.840
before type your what is the index off Karishma?

00:03:56.840 --> 00:04:02.800
So I can see your name Start index and then type the world Karishma or whatever that you're

00:04:02.800 --> 00:04:03.550
looking for.

00:04:03.550 --> 00:04:05.170
And if that exists,

00:04:05.170 --> 00:04:07.640
it's gonna give you if it doesn't exist,

00:04:07.640 --> 00:04:08.830
like in the previous case,

00:04:08.830 --> 00:04:12.870
it's gonna given value better to pull that index off.

00:04:12.870 --> 00:04:15.260
X X is not in trouble,

00:04:15.260 --> 00:04:19.350
so you can always check whether an element exists in the pupil.

00:04:19.350 --> 00:04:20.510
Our list.

00:04:20.510 --> 00:04:22.450
By using the in operator,

00:04:22.450 --> 00:04:22.990
for example,

00:04:22.990 --> 00:04:25.030
I can always check your to be nine,

00:04:25.030 --> 00:04:28.130
which is a text in the names,

00:04:28.130 --> 00:04:30.250
and this is going to give me true or false.

00:04:30.250 --> 00:04:32.180
Since names doesn't contain the night,

00:04:32.180 --> 00:04:33.850
you will see that it's this once,

00:04:33.850 --> 00:04:39.040
however you can say here we note in names it says to,

00:04:39.040 --> 00:04:40.870
and it is case sensitive.

00:04:40.870 --> 00:04:43.470
So if you try here with a Capital B,

00:04:43.470 --> 00:04:45.540
you'll see that it is falls again.

00:04:45.540 --> 00:04:45.960
Now,

00:04:45.960 --> 00:04:49.550
this is also true in case off list as well.

00:04:49.550 --> 00:04:53.050
So do people is used to when you want toe.

00:04:53.050 --> 00:04:58.350
Have a read only collection off loose where you don't want toe manipulate the values.

00:04:58.350 --> 00:05:00.450
Now these are immutable.

00:05:00.450 --> 00:05:03.390
Whereas list is a mutable collection,

00:05:03.390 --> 00:05:07.680
people also can be constructed by using the pupil constructor.

00:05:07.680 --> 00:05:07.980
So,

00:05:07.980 --> 00:05:08.560
for example,

00:05:08.560 --> 00:05:12.610
I can say your names equals toe to pull like this.

00:05:12.610 --> 00:05:14.670
So this is an empty doable.

00:05:14.670 --> 00:05:17.470
So now I'll have toe our values,

00:05:17.470 --> 00:05:18.190
which I cannot,

00:05:18.190 --> 00:05:20.290
because two bullets they read only collection.

00:05:20.290 --> 00:05:25.680
So the way you might probably want to use to pull constructor is bypassing as something

00:05:25.680 --> 00:05:27.850
like a list or other kind of collections.

00:05:27.850 --> 00:05:28.580
For example,

00:05:28.580 --> 00:05:35.930
I continue your names equals two to put off a square package for list or even around record

00:05:35.930 --> 00:05:36.780
for a collection.

00:05:36.780 --> 00:05:39.660
So if I already have a collection like this,

00:05:39.660 --> 00:05:40.330
for example,

00:05:40.330 --> 00:05:40.790
it saved,

00:05:40.790 --> 00:05:46.510
you know on and say I know that this is a pupil made out off a list here.

00:05:46.510 --> 00:05:48.970
So now I can see here like names.

00:05:48.970 --> 00:05:49.940
This is stupid.

00:05:49.940 --> 00:05:53.420
Most of the times if you have a list variable like,

00:05:53.420 --> 00:05:53.720
let's say,

00:05:53.720 --> 00:05:54.350
for example,

00:05:54.350 --> 00:06:03.150
I have your names equals to say we know or say I know I have here list type of name stays a

00:06:03.150 --> 00:06:03.660
list.

00:06:03.660 --> 00:06:08.230
I can say you're t names equals toe to pull off names.

00:06:08.230 --> 00:06:12.400
So now we're constructing a pupil using a list here.

00:06:12.400 --> 00:06:15.240
This is one of the practical uses of the constructor.

00:06:15.240 --> 00:06:19.280
If you want to create a pupil with a single value,

00:06:19.280 --> 00:06:19.980
for example,

00:06:19.980 --> 00:06:21.270
let me clear the screen here.

00:06:21.270 --> 00:06:22.120
Onda.

00:06:22.120 --> 00:06:27.940
Let's I wanted to have cities equals toe a bracket around record and if a tape your bangle

00:06:27.940 --> 00:06:28.240
Oh,

00:06:28.240 --> 00:06:30.130
which is a city.

00:06:30.130 --> 00:06:38.480
So if I press enter notice that the data type you're off cities is not a to pull it says

00:06:38.480 --> 00:06:39.220
ESTA,

00:06:39.220 --> 00:06:42.260
because you have a single value.

00:06:42.260 --> 00:06:45.970
The bracket was just assumed as it's a grouping operator,

00:06:45.970 --> 00:06:47.660
not as a pupil operator.

00:06:47.660 --> 00:06:51.130
If you want to create a pupil in this fashion,

00:06:51.130 --> 00:06:56.990
you just have to add a comma here so that it is now assumed to be a collection off values

00:06:56.990 --> 00:06:58.210
inside their own bracket,

00:06:58.210 --> 00:06:59.620
not just one value.

00:06:59.620 --> 00:07:00.250
And now,

00:07:00.250 --> 00:07:00.570
of course,

00:07:00.570 --> 00:07:02.310
if you think type off cities,

00:07:02.310 --> 00:07:05.190
you'll see that it is it a terrible Of course,

00:07:05.190 --> 00:07:10.430
if you want to create a to pull with no elements at all using their own racket,

00:07:10.430 --> 00:07:13.800
you can always say cities equals toe like this.

00:07:13.800 --> 00:07:16.250
And then if you see type off cities,

00:07:16.250 --> 00:07:21.260
it is a terrible you don't have to give a comma in this particular case.

