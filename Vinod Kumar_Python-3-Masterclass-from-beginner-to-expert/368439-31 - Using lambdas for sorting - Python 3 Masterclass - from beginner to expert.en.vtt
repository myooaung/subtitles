WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.550
in this video.

00:00:01.550 --> 00:00:07.750
Let's understand Lambda expressions with the help off sorted and listed outside functions.

00:00:07.750 --> 00:00:08.550
For that,

00:00:08.550 --> 00:00:11.410
let's would create a list off a few names.

00:00:11.410 --> 00:00:15.970
I'm going to say your names equals toe in courts.

00:00:15.970 --> 00:00:18.370
A string values I give a bunch of them.

00:00:18.370 --> 00:00:19.420
That's a you know,

00:00:19.420 --> 00:00:23.350
a new cushy Karishma John.

00:00:23.350 --> 00:00:24.150
Let's say,

00:00:24.150 --> 00:00:24.900
for example,

00:00:24.900 --> 00:00:25.720
Jacob,

00:00:25.720 --> 00:00:26.890
give one more.

00:00:26.890 --> 00:00:32.000
Let's give a bigger name this time say sh close the bracket.

00:00:32.000 --> 00:00:34.440
If I use names dot start on,

00:00:34.440 --> 00:00:35.620
then press enter.

00:00:35.620 --> 00:00:41.850
You'll see that the needs themselves got rearranged and I lost the original values,

00:00:41.850 --> 00:00:44.490
so I don't want to use it this way.

00:00:44.490 --> 00:00:46.260
So I'm gonna reassign the names.

00:00:46.260 --> 00:00:48.230
So it is in random order.

00:00:48.230 --> 00:00:55.140
Now I can use a salted function on then saying names on it is going to return a new list

00:00:55.140 --> 00:01:01.230
consisting of the salted names so you can see that alphabetically it is ordered.

00:01:01.230 --> 00:01:02.720
So a hedge,

00:01:02.720 --> 00:01:04.520
J and G.

00:01:04.520 --> 00:01:07.870
But J A comes before g or here.

00:01:07.870 --> 00:01:10.540
And then you have a key and caves Okay,

00:01:10.540 --> 00:01:12.180
a comes before K hedge.

00:01:12.180 --> 00:01:12.520
And then,

00:01:12.520 --> 00:01:12.960
of course,

00:01:12.960 --> 00:01:15.350
we is the last one in this case.

00:01:15.350 --> 00:01:16.390
So by default,

00:01:16.390 --> 00:01:22.160
the started function is taking each of the strings and then comparing one string with

00:01:22.160 --> 00:01:25.460
another string based on the asking values off the letters,

00:01:25.460 --> 00:01:27.910
it is actually starting each one of them.

00:01:27.910 --> 00:01:33.350
What if I wanted to start the data based on the length of each of the text?

00:01:33.350 --> 00:01:34.890
So in which case,

00:01:34.890 --> 00:01:41.650
the sorted function takes a second argument so you can see your help on started to see more

00:01:41.650 --> 00:01:41.650
.

00:01:41.650 --> 00:01:46.970
You see that there is a name the perimeter called as a key here the terrible is your

00:01:46.970 --> 00:01:52.580
collection key happens to be a custom function that can be supplied toe customize the sort

00:01:52.580 --> 00:01:53.130
order.

00:01:53.130 --> 00:01:54.340
So by default,

00:01:54.340 --> 00:01:58.280
it is actually taking the what we call as lexical a graphical order.

00:01:58.280 --> 00:01:58.530
Now,

00:01:58.530 --> 00:01:58.970
instead,

00:01:58.970 --> 00:02:00.050
I can supply function.

00:02:00.050 --> 00:02:02.570
Now we know that there is a function called Len,

00:02:02.570 --> 00:02:03.430
for example,

00:02:03.430 --> 00:02:08.580
I can say then off a new and it's gonna give me three Len off.

00:02:08.580 --> 00:02:09.470
Harish Kumar,

00:02:09.470 --> 00:02:10.850
for example,

00:02:10.850 --> 00:02:13.870
will give you 11 so I can ask,

00:02:13.870 --> 00:02:15.290
started toe,

00:02:15.290 --> 00:02:20.710
take the result off this land and then compare and then find out which one happens to be a

00:02:20.710 --> 00:02:22.620
smaller name between these two,

00:02:22.620 --> 00:02:27.950
instead of arranging them based on the alphabetical order so to do this,

00:02:27.950 --> 00:02:29.330
I can say socket,

00:02:29.330 --> 00:02:34.400
and then I can say it terrible equals Two names are simply give names because they deliver

00:02:34.400 --> 00:02:39.350
the first argument than to say that the key is our land function.

00:02:39.350 --> 00:02:41.000
I have to say key codes to land.

00:02:41.000 --> 00:02:42.190
And what is that?

00:02:42.190 --> 00:02:43.690
I'm not calling the land function.

00:02:43.690 --> 00:02:45.090
I'm just supplying the name.

00:02:45.090 --> 00:02:50.480
Now this is where Lenny is considered as just another object like names is an object off

00:02:50.480 --> 00:02:51.680
list lended,

00:02:51.680 --> 00:02:56.700
an object of function picks I'm supplying two objects over here to this function now

00:02:56.700 --> 00:03:00.070
started will ignore the lexical graphical order.

00:03:00.070 --> 00:03:02.950
But instead it will order them based on the length.

00:03:02.950 --> 00:03:06.000
And I will see that I got three letters,

00:03:06.000 --> 00:03:06.720
four letters,

00:03:06.720 --> 00:03:11.940
violators again five and then cushy and Karishma on Karishma.

00:03:11.940 --> 00:03:14.140
So if you wanted in the reverse order,

00:03:14.140 --> 00:03:17.860
you can also one more perimeter reversed equals two.

00:03:17.860 --> 00:03:18.410
True,

00:03:18.410 --> 00:03:22.440
you can see that the same list is started in the reverse order.

00:03:22.440 --> 00:03:24.770
While Len is a building function,

00:03:24.770 --> 00:03:28.130
we can also supply our own functions here,

00:03:28.130 --> 00:03:29.280
For example,

00:03:29.280 --> 00:03:35.630
imagine I want to start the names based on the second character onwards,

00:03:35.630 --> 00:03:42.300
like i n or D e and new hit you ethic I and so on and so forth.

00:03:42.300 --> 00:03:43.790
How can I do that?

00:03:43.790 --> 00:03:47.160
So what I can do that can create a function,

00:03:47.160 --> 00:03:48.260
a custom function.

00:03:48.260 --> 00:03:54.810
Richard returns the second character onwards off this particular string so that I can pass

00:03:54.810 --> 00:03:55.580
that function,

00:03:55.580 --> 00:03:58.180
and then the started can do its job.

00:03:58.180 --> 00:03:58.840
For that,

00:03:58.840 --> 00:04:02.250
I'm gonna write a function called said Partial text.

00:04:02.250 --> 00:04:10.010
I can supply a name here and from this particular name I'm supposed to return the second

00:04:10.010 --> 00:04:11.180
character onwards.

00:04:11.180 --> 00:04:13.940
Now the slice operator comes very handy here.

00:04:13.940 --> 00:04:18.800
So I could simply say beam and then say index one onwards,

00:04:18.800 --> 00:04:20.340
everything else I want to supply.

00:04:20.340 --> 00:04:22.090
So for example,

00:04:22.090 --> 00:04:24.660
now it's a partial takes off.

00:04:24.660 --> 00:04:29.550
We know on it should simply say I am Audie.

00:04:29.550 --> 00:04:30.210
Similarly,

00:04:30.210 --> 00:04:31.960
I supply any other names,

00:04:31.960 --> 00:04:32.550
John.

00:04:32.550 --> 00:04:35.000
So it's gonna dio or hedged.

00:04:35.000 --> 00:04:38.850
And so now I can use this function called partial X,

00:04:38.850 --> 00:04:42.340
which is a totally use a different function to the senator function.

00:04:42.340 --> 00:04:49.010
I can say you started off names and then I can say key codes toe plus you.

00:04:49.010 --> 00:04:52.750
So this if I pressed enter No,

00:04:52.750 --> 00:04:55.170
you can see that it sorts at first.

00:04:55.170 --> 00:04:57.040
It might be confusing as what is the order.

00:04:57.040 --> 00:04:59.620
But if you carefully observed a c o.

00:04:59.620 --> 00:05:03.250
B is compared with a r,

00:05:03.250 --> 00:05:04.220
it's etcetera.

00:05:04.220 --> 00:05:08.030
So the a C comes before a are on.

00:05:08.030 --> 00:05:13.700
You can see that between this a r I s we have exact same match A right.

00:05:13.700 --> 00:05:17.510
But you can see that a r i n such em.

00:05:17.510 --> 00:05:20.400
So the M is the differential factor between this and this.

00:05:20.400 --> 00:05:21.610
And here is the K.

00:05:21.610 --> 00:05:24.620
So K comes before m so that it started out.

00:05:24.620 --> 00:05:31.340
Obviously it comes before hatch Hedge comes before I I comes before end on incomes before

00:05:31.340 --> 00:05:36.460
oh so everything is started Based on the second character onwards Now the whole purpose off

00:05:36.460 --> 00:05:39.280
dysfunction is only for the started.

00:05:39.280 --> 00:05:45.430
So I don't need this to be created like a global function anymore because I can supply a

00:05:45.430 --> 00:05:48.560
lander expressions instead of the actual function.

00:05:48.560 --> 00:05:50.950
Because for Lambda expressions,

00:05:50.950 --> 00:05:57.430
what we require here is a name of the function and argument of the function on a single a

00:05:57.430 --> 00:06:02.280
written statement in the function so which is a perfect qualifier for a land expression.

00:06:02.280 --> 00:06:08.100
So what I can do that can simply use your salted names and then key called story.

00:06:08.100 --> 00:06:09.550
Instead of partial text,

00:06:09.550 --> 00:06:16.300
I can simply type your lambda aan den the argument which is any valuable here I can say end

00:06:16.300 --> 00:06:21.640
and it's written Value is nothing but in off one colon just like this one.

00:06:21.640 --> 00:06:26.500
So we had here Name is a perimeter here and is a perimeter name off.

00:06:26.500 --> 00:06:33.810
One colon is the return value and we have year end off one colon as the return really of

00:06:33.810 --> 00:06:38.200
the lander on I should see exactly same result as the previous one.

00:06:38.200 --> 00:06:40.150
Let's take another example.

00:06:40.150 --> 00:06:42.440
So here is our names.

00:06:42.440 --> 00:06:43.120
Andi,

00:06:43.120 --> 00:06:48.770
if I want to start the names based on the last letters like D u I A.

00:06:48.770 --> 00:06:51.940
And B and on all of them are different.

00:06:51.940 --> 00:07:03.220
So I can see your started off names and then he equals toe Landau off name with the return

00:07:03.220 --> 00:07:04.800
value from this land Expressionist.

00:07:04.800 --> 00:07:06.500
Name off minus one.

00:07:06.500 --> 00:07:07.470
If you remember,

00:07:07.470 --> 00:07:10.490
name off zero would have given the first letter name off.

00:07:10.490 --> 00:07:15.040
One etcetera Similarly name off minus one will get the last letter that were actually

00:07:15.040 --> 00:07:15.860
amusing here.

00:07:15.860 --> 00:07:21.820
A press enter and you can see this time it is started based on the last later So it comes

00:07:21.820 --> 00:07:27.750
before B de comes before I end comes before our Arkan's before you here.

00:07:27.750 --> 00:07:33.570
So that's how Lambda expressions can be passed whenever you're calling a function so

00:07:33.570 --> 00:07:38.730
literally I'm creating a function on the fly here and then passing it as an argument.

00:07:38.730 --> 00:07:41.270
The same thing can also be used on the sort.

00:07:41.270 --> 00:07:42.890
So if I say here names,

00:07:42.890 --> 00:07:44.910
this is the names and I can say names,

00:07:44.910 --> 00:07:45.790
darts start.

00:07:45.790 --> 00:07:47.010
He equals toe.

00:07:47.010 --> 00:07:48.110
What are the key want?

00:07:48.110 --> 00:07:55.870
Let's say the previous when I gave land off again with n second letter onwards,

00:07:55.870 --> 00:08:00.060
I can supply like this and then I see that there is no result.

00:08:00.060 --> 00:08:03.550
What names themselves have been modified in this case.

