WEBVTT
1
00:00:02.290 --> 00:00:05.720
Ora che abbiamo scritto il nostro primo test, in realtà ha senso.

2
00:00:06.040 --> 00:00:10.690
Continuiamo e scriviamo il numero uno il nostro codice qui funziona solo correttamente.

3
00:00:10.690 --> 00:00:16.930
Abbiamo l'header di intestazione e autorizzazione che può essere diviso in due parti perché è quello che stiamo

4
00:00:16.930 --> 00:00:17.830
facendo qui.

5
00:00:17.830 --> 00:00:22.240
La ragione di ciò ovviamente è che ci aspettiamo qualcosa di simile al portatore e quindi il nostro token giusto.

6
00:00:22.240 --> 00:00:24.220
È così che inviamo i nostri token.

7
00:00:24.220 --> 00:00:27.750
È così che inviamo l'intestazione di autorizzazione e quindi facciamo qualcosa.

8
00:00:27.820 --> 00:00:40.320
Potremmo testarlo perché dovrebbe generare un errore se l'intestazione di autorizzazione è solo una stringa.

9
00:00:40.330 --> 00:00:48.100
Ora passiamo nuovamente una funzione dove definiamo il nostro codice di test effettivo e lì.

10
00:00:48.110 --> 00:00:53.090
Ora creerò di nuovo il mio oggetto fittizio Richiesta dove ottengo il mio header di autorizzazione.

11
00:00:53.090 --> 00:01:01.850
Ora non è più nulla, ma è solo una stringa, quindi diciamo xy set come valore di un token e questo significa che

12
00:01:01.860 --> 00:01:08.070
ora possiamo ancora trovare un'aspettativa in cui diciamo quando il middleware off diventa freddo e proprio

13
00:01:08.070 --> 00:01:14.280
come prima non chiamiamo noi stessi stiamo preparando per essere chiamato usando i bui qui.

14
00:01:14.310 --> 00:01:21.910
Questo dice a questa parola chiave quindi il nostro oggetto Richiesta fittizio, quindi un oggetto vuoto per la risposta e quindi

15
00:01:22.070 --> 00:01:24.790
una funzione vuota per la funzione successiva.

16
00:01:24.900 --> 00:01:32.070
E mi aspetto che per lanciarti ora potresti controllare un messaggio di errore esatto, ma se non sei sicuro o se

17
00:01:32.070 --> 00:01:37.920
ti interessa solo se un errore è congelato, puoi anche solo controllare per fro come questo senza

18
00:01:38.070 --> 00:01:39.840
passare alcun argomento a esso.

19
00:01:40.830 --> 00:01:45.370
Quindi ora questo dovrebbe davvero fallire se ora eseguo di nuovo il test NPM qui.

20
00:01:45.630 --> 00:01:51.900
Voglio dire che dovrebbe avere successo perché invece è perché in effetti otteniamo un errore se passiamo

21
00:01:51.900 --> 00:01:59.850
è perché se lo controllo non è solo per dimostrare questo ora sarà in realtà come un errore qui perché si

22
00:02:00.000 --> 00:02:05.490
aspettava che non lanciare un errore ma in realtà abbiamo ricevuto un errore qui.

23
00:02:05.490 --> 00:02:09.320
Come puoi vedere perché la suddivisione del nostro codice è sostanzialmente fallita.

24
00:02:09.390 --> 00:02:16.090
Quindi vogliamo essere sicuri che un errore entri in gioco qui e che non sia mai un test.

25
00:02:16.110 --> 00:02:22.310
Ora, più test aggiungiamo, più difficile questo output diventa leggere.

26
00:02:22.330 --> 00:02:23.330
In questo momento è ancora facile.

27
00:02:23.340 --> 00:02:27.340
Sappiamo che stiamo testando solo il middleware off e abbiamo ottenuto due test.

28
00:02:27.570 --> 00:02:30.320
Ma cosa succede se stiamo testando Maud e il middleware.

29
00:02:30.390 --> 00:02:34.410
Cosa succederebbe se in seguito tutti iniziassimo a testare i nostri controller che faremo.

30
00:02:34.410 --> 00:02:40.020
Bene, allora potremmo voler scoprire quali di queste affermazioni si riferiscono al middleware

31
00:02:40.020 --> 00:02:47.910
off e quali affermazioni si riferiscono ai nostri controllori oa quale controller e al MOCA ci danno effettivamente più della

32
00:02:47.910 --> 00:02:57.630
semplice funzione IT per definire e organizzare i nostri test oltre a ciò è una funzione descrittiva e descrive le funzioni lì per raggruppare

33
00:02:57.630 --> 00:03:03.610
i test ed è possibile nidificare tutte le chiamate di funzioni descritte che si desidera.

34
00:03:03.660 --> 00:03:07.380
In questo modo è possibile avere più chiamate di funzioni descrittive l'una dentro l'altra.

35
00:03:07.590 --> 00:03:13.590
Descrivi tutto per prendere un titolo e che ora non è una frase che si legge

36
00:03:13.590 --> 00:03:20.480
come una frase inglese, ma invece come un'intestazione per il gruppo che stai descrivendo come per esempio di middleware.

37
00:03:20.700 --> 00:03:29.280
Ora questa lamentela prende anche una funzione come seconda argomentazione e in disfunzione si passano tutti i casi di test in

38
00:03:29.280 --> 00:03:32.530
cui vengono chiamate chiamate di funzione TS.

39
00:03:32.580 --> 00:03:37.500
Così ora sono dentro la disfunzione della descrizione e, come ho detto, se ne hai bisogno, puoi anche avere

40
00:03:37.500 --> 00:03:40.220
una descrizione in una descrizione e poi in una funzionale.

41
00:03:40.260 --> 00:03:41.460
Questo è descrivere.

42
00:03:41.460 --> 00:03:43.820
Potresti avere i tuoi casi di test.

43
00:03:43.860 --> 00:03:46.990
Quindi ora abbiamo quell'organizzazione.

44
00:03:47.270 --> 00:03:53.430
E se ora eseguo di nuovo il test NPM, vedi che ora hai questa intestazione che rende

45
00:03:53.430 --> 00:03:59.090
più facile scoprire quale file o quale area del tuo codice della tua app.

46
00:03:59.190 --> 00:04:04.950
Questi test appartengono e, naturalmente, possono essere molto utili e, d'ora in poi, useremo questo raggruppamento

47
00:04:04.950 --> 00:04:09.780
descritto per rendere il nostro codice più leggibile e più facile da capire.
