WEBVTT

00:03.020 --> 00:07.360
So we had a look at downscaling and multi-page applications.

00:07.370 --> 00:14.990
How well does a framework fit into that purpose of having smaller apps or controlling pieces of pages

00:14.990 --> 00:17.000
of multi-page applications.

00:17.270 --> 00:22.400
Now we want to control everything with javascript our whole front and we want to build a single page

00:22.400 --> 00:23.510
application.

00:23.540 --> 00:27.230
How well do these frameworks perform in this use case.

00:27.230 --> 00:31.760
In this case in this scenario I again got a couple of questions we could answer.

00:31.760 --> 00:40.310
To narrow this question down and find out if the framework fits our purpose can you write and maintain

00:40.310 --> 00:46.880
complex or a lot of code and with that I mean if you have a big application you're going to have a lot

00:46.880 --> 00:53.300
of code probably a lot of files holding this code which a means you need a workflow which bundles everything

00:53.300 --> 01:02.180
together correctly but B It also means is there a best practice regarding the naming of files and folders

01:02.180 --> 01:08.330
structures so that the large amount of files you might have is still manageable because that is super

01:08.330 --> 01:11.990
important during development and reporting questions.

01:12.020 --> 01:18.140
Do we have to rely on a lot of third party packages to add certain functionalities with which we might

01:18.140 --> 01:20.130
need for example for validation.

01:20.150 --> 01:26.000
Is that built into the framework or is there an official package of the framework or do we need to use

01:26.000 --> 01:32.450
the community to get a fitting package which might have some disadvantages like for example that we

01:32.450 --> 01:35.430
can't be sure if the package stays updated.

01:35.480 --> 01:40.620
And things like that and how easy is it to optimize.

01:41.060 --> 01:46.940
Are there sufficient optimization capabilities so that we can really squeeze out that last piece of

01:46.940 --> 01:49.690
performance we need for our big gap.

01:49.750 --> 01:55.900
Finally how easy is it to manage the application state because that is a common pain point.

01:55.910 --> 02:02.360
It can be really difficult and tough to manage the state in bigger single page applications.

02:02.360 --> 02:03.700
So how easy is that.

02:03.710 --> 02:09.680
Is there a clear pattern maybe an official package or way of doing that or is it up to you.

02:09.680 --> 02:11.090
Is it community support.

02:11.240 --> 02:13.470
How does that work out.

02:13.490 --> 02:20.750
Let's answer these questions for the free frameworks for Wrangler can we right to maintain complex or

02:20.750 --> 02:21.560
a lot of code.

02:21.560 --> 02:22.940
Definitely yes.

02:22.940 --> 02:28.260
There are a lot of best practices for how we should name our files how we should structure them.

02:28.400 --> 02:31.070
And I can tell you that works really well.

02:31.070 --> 02:32.610
So definitely doable.

02:32.690 --> 02:38.090
And since we need a complex workflow anyways and we get the Selye which sets up a great workflow and

02:38.090 --> 02:44.080
build process for us bundling everything and this stuff also works great for a view.

02:44.090 --> 02:47.260
CHACE Yeah that is really tough.

02:47.270 --> 02:54.290
I gave it a plus with less screen you could put a equal sign or maybe even a minus here because there

02:54.380 --> 03:01.370
is no clear best practice and if you follow the approach shown for example in the official documentation

03:01.370 --> 03:07.540
for storing your components that might get difficult to maintain in bigger apps.

03:07.670 --> 03:11.950
So youll have to come up with a different way of naming things and storing things.

03:12.140 --> 03:16.650
And that is something which can be complicated because there is no clear best practice here.

03:16.790 --> 03:22.200
So doable but its solved in a better way an angler.

03:22.310 --> 03:30.830
Again you might put a minus stare if you feel like it but I feel overall de-code of course is bundled

03:30.830 --> 03:33.630
nicely by the workflows created by the UCL.

03:33.770 --> 03:40.340
And overall the app will work nicely it's just an extra piece of thing you have to do that structuring

03:40.340 --> 03:47.060
and naming of the files which isn't given to you and for re-act it's kind of the same there we have

03:47.060 --> 03:52.400
some best practices which you want in the community but it's up to you to learn about these and to find

03:52.400 --> 03:54.100
the one which fits your needs.

03:54.230 --> 04:00.370
It's not given to us as it is in the Angler or case in the Anglo world and that might be difficult.

04:00.440 --> 04:07.790
The same for creating a workflow there thankfully now is an official package which creates a workflow.

04:07.790 --> 04:10.880
The one we used in the introduction monohull by the way.

04:11.030 --> 04:15.840
And with that we got a great workflow which really optimized everything works out great.

04:15.980 --> 04:22.010
But again regarding the structure and naming of files you might need to reach out to the community and

04:22.010 --> 04:27.180
there for all is just a well lightly Drene plus here.

04:27.500 --> 04:29.630
How about for party packages.

04:29.630 --> 04:34.130
Do we need a lot or Desta Fromberg offer all the functionality we need for Wrangler.

04:34.130 --> 04:37.670
I can tell you no we don't need to reach out to the community a lot.

04:37.670 --> 04:38.660
Of course there are.

04:38.670 --> 04:40.380
They're useful for party packages.

04:40.400 --> 04:48.080
Don't get me wrong but the Engler team itself has created a lot of packages which cover a lot of common

04:48.080 --> 04:48.960
use cases.

04:49.010 --> 04:52.550
We have the forums package which handles form validation.

04:52.550 --> 04:55.650
We got the official router package which handles routing.

04:55.790 --> 05:03.410
We got the official Anglo material package which gives us material styling and awls is pre-built components

05:03.410 --> 05:09.620
you can use a lot of things you can use which all come from the official angle or team or closely connected

05:09.620 --> 05:10.340
teams.

05:10.460 --> 05:12.450
For example just Seelye too.

05:12.680 --> 05:18.230
And that gives us the advantage to the can't rely on these packages getting updated and getting updates

05:18.290 --> 05:21.880
in time and not one year after a new version came out.

05:22.100 --> 05:24.380
So that's great for you.

05:24.650 --> 05:26.270
Yeah a bit.

05:26.360 --> 05:27.620
It's an equal sign here.

05:27.770 --> 05:32.740
We have the official router package we've got the official view X state management package.

05:32.780 --> 05:33.520
That's great.

05:33.560 --> 05:36.940
And the Spectre's obviously are maintained and updated in time.

05:36.960 --> 05:38.270
That is super.

05:38.270 --> 05:45.380
However if we talk about form validation for example that is something which is not baked into the chest.

05:45.410 --> 05:50.240
So we have to use forward party packages which might not be finished which are only developed by one

05:50.240 --> 05:53.650
guy who just doesn't have enough time to keep them up to date.

05:54.050 --> 05:58.650
And that might be an issue for you depending on what your app needs to do.

05:58.820 --> 06:01.700
So that's why we have an equal sign here.

06:01.730 --> 06:03.810
How about react here.

06:03.890 --> 06:10.640
I'll even give you a minus because re-act itself is a very clean package and a lot of our things for

06:10.640 --> 06:14.960
state management redux for example or for routing you react router.

06:14.960 --> 06:17.510
These things are not official packages.

06:17.540 --> 06:22.290
We have community packages here and sometimes we even have multiple alternatives.

06:22.430 --> 06:25.550
And that makes it hard to pick the right one for newcomers.

06:25.550 --> 06:31.100
And even if you're not a newcomer you have to rely on these packages being updated which might not be

06:31.100 --> 06:31.940
the case.

06:31.940 --> 06:36.070
So data is where I'd definitely like Engler more.

06:36.080 --> 06:38.310
Now how about optimizing apps.

06:38.330 --> 06:40.550
Do we have tools to optimize the apps.

06:40.550 --> 06:43.220
Is it easy to optimize them for regular.

06:43.370 --> 06:48.160
Here I'll give a plus though I will say it's not super easy and will come back to this later in the

06:48.170 --> 06:51.940
def to production step but there are a lot of things we can do.

06:51.950 --> 06:55.980
We really can squeeze out the last piece of performance for our viewers.

06:55.980 --> 07:02.700
Yes it's a plus but a little bit less screen because we have decent optimization capabilities.

07:02.750 --> 07:08.390
I have to say out of the box view Che's optimized some things for you so that is not necessarily a bad

07:08.390 --> 07:08.950
thing.

07:09.170 --> 07:14.740
But if you're one of the people who really liked dig into it and optimize everything manually.

07:14.930 --> 07:20.030
Well you certainly got more possibilities of doing so in an OR app.

07:20.090 --> 07:22.010
How about react here.

07:22.070 --> 07:24.490
I'll give the same rating as for view chairs.

07:24.530 --> 07:26.930
We get decent optimization possibilities.

07:27.080 --> 07:28.610
We don't need to optimize some things.

07:28.610 --> 07:30.330
We do have to optimize and angular.

07:30.380 --> 07:32.570
So that is why we have less possibilities.

07:32.570 --> 07:35.230
But on the other hand while we don't have to optimize it in the first place.

07:35.360 --> 07:39.170
But again if you're one of the guys who really like to do everything on their own you might have less

07:39.170 --> 07:40.760
possibilities here.

07:41.240 --> 07:45.680
Now how easy is it to manage the application state in bigger apps.

07:45.680 --> 07:47.090
That's a huge problem.

07:47.120 --> 07:49.400
So how easy is it for wrangler.

07:49.460 --> 07:56.570
I'll give that an equal sign in Engler core or in the NG or framework and all the packages provided

07:56.570 --> 08:02.720
by the official team we get services for managing the state and that might work out well for your app

08:03.050 --> 08:06.050
in very very big applications.

08:06.050 --> 08:08.610
The capabilities to get there might be limited though.

08:08.840 --> 08:15.080
And then you might need a package like N G R X which is kind of code developed by an official English

08:15.080 --> 08:16.520
developer but mostly not.

08:16.520 --> 08:22.220
Mostly it's a community project and there we again have the issue of does it get updated in time.

08:22.220 --> 08:26.540
I can tell you the documentation isn't that great because it hasn't been updated for a longer period

08:26.540 --> 08:29.960
of time and that is why it's not perfect.

08:29.960 --> 08:34.300
We do have packages and G X which give us that feature.

08:34.430 --> 08:37.340
But these packages do have disadvantages.

08:37.640 --> 08:40.000
For a view that's better.

08:40.040 --> 08:47.090
Here we have view X and official package which integrates nicely into view chairs and which makes managing

08:47.090 --> 08:48.640
the state easier.

08:48.710 --> 08:54.300
So that is really great and that is something we can use and which really allows us to manage the state

08:54.320 --> 08:56.470
and bigger applications too.

08:56.510 --> 09:02.520
We will have to figure out how to do it correctly how to follow some best practices but again we have

09:02.600 --> 09:06.140
kind of baked into view or baked into that official package.

09:07.100 --> 09:11.270
For re-act also give this a plus but it's a little bit worse.

09:11.280 --> 09:14.880
And in the view world because there we don't have an official package.

09:14.950 --> 09:20.440
We have read X which is pretty common to use and we also have flux and that's the first thing you have

09:20.440 --> 09:22.520
to decide which approach should I use.

09:22.600 --> 09:28.600
And you'll find tons of opinions on both approaches that can be hard to choose the right one and setting

09:28.600 --> 09:31.100
it up and integrating it all as hard.

09:31.120 --> 09:37.540
The first time once you did get a run though it works awesome and it really is a great advantage then

09:37.780 --> 09:44.970
and really is something which allows you to manage the state with ease in big and very big applications.

09:44.980 --> 09:50.680
So back in our overview sheet how could we rate the frameworks now that we answered all these questions

09:51.310 --> 09:52.060
for Bangalore.

09:52.090 --> 09:53.640
It has to be a plus.

09:53.650 --> 10:00.550
Engler is built to create big and very big single page applications and it clearly is a great choice

10:00.550 --> 10:08.520
for it is viewed as it's also plus not as awesome as angular potentially but still a great framework

10:08.530 --> 10:11.910
and you definitely can build very big applications with it.

10:11.920 --> 10:13.260
So don't get this wrong.

10:13.300 --> 10:19.040
It's just an angler is even more aimed at this goal and for reaction say the same.

10:19.240 --> 10:23.890
It's a great framework for that and you definitely can build big applications with it.

10:23.890 --> 10:26.060
It just doesn't have the same focus.

10:26.140 --> 10:31.450
Angler has but still with some things you have to do like picking the right state management framework

10:31.450 --> 10:32.220
and so on.

10:32.260 --> 10:35.400
You can build really big applications with it.

10:35.530 --> 10:38.620
Now with that let's move on to the next point performance.
