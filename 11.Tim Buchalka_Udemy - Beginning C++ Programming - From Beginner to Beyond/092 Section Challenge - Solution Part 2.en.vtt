WEBVTT
1
00:00:05.590 --> 00:00:08.530
Welcome back to the continuation of the solution.

2
00:00:08.860 --> 00:00:14.860
We stopped it mean right here in the last two parts that we've got to do our display the smallest number

3
00:00:14.950 --> 00:00:16.680
and display the largest number.

4
00:00:16.870 --> 00:00:19.850
And then of course we have to handle quick which is really easy to do.

5
00:00:19.870 --> 00:00:24.740
All right so let me scroll back down here and clean up a little bit of this white space.

6
00:00:26.750 --> 00:00:27.160
All right.

7
00:00:27.160 --> 00:00:28.950
So this is where we're at right here.

8
00:00:29.080 --> 00:00:32.460
So now the user hasn't typed in appear and they are in em.

9
00:00:32.560 --> 00:00:38.200
Maybe they've typed in an S which is the smallest So we'll do another ill's else if ladder here we'll

10
00:00:38.220 --> 00:00:38.470
see.

11
00:00:38.470 --> 00:00:49.390
Else if the selection is equal to a capital S or selection is a lowercase s.

12
00:00:49.930 --> 00:00:54.090
In this case we need to calculate the smallest number in the list.

13
00:00:54.100 --> 00:00:55.630
There's a lot of ways to do this.

14
00:00:55.660 --> 00:00:59.720
But again let's deal with the case where the list is empty right.

15
00:00:59.740 --> 00:01:05.580
So we'll say if numbers just like we have before if numbers that size

16
00:01:09.090 --> 00:01:13.150
is 0 then we've got an empty list.

17
00:01:13.170 --> 00:01:21.570
We could just say C out and we could say unable to determine the smallest.

18
00:01:21.570 --> 00:01:23.200
This is empty.

19
00:01:23.610 --> 00:01:25.470
Or something like that.

20
00:01:25.770 --> 00:01:30.330
Any kind of message that makes sense and will put an end line here.

21
00:01:31.200 --> 00:01:34.010
Now we're in the L section at this point.

22
00:01:34.020 --> 00:01:41.070
Obviously there is some data in that vector so what we can do is we can again iterate through the entire

23
00:01:41.070 --> 00:01:43.090
vector and look for the smallest number.

24
00:01:43.200 --> 00:01:44.130
Well how do we do that.

25
00:01:44.250 --> 00:01:45.030
It's pretty simple.

26
00:01:45.030 --> 00:01:49.790
Just pick the first number and assume it's the smallest and then iterate through the vector.

27
00:01:49.830 --> 00:01:53.790
And if you see anything smaller just replace that one with the smallest one.

28
00:01:53.880 --> 00:01:56.250
So again it's pretty straightforward so let's do that.

29
00:01:56.250 --> 00:02:02.710
Let's say we've got a smallest we'll call it smallest and what we'll do is we'll initialize that guy

30
00:02:02.730 --> 00:02:06.650
to numbers at zero.

31
00:02:06.660 --> 00:02:09.120
All right so let's think about what's going on here.

32
00:02:09.180 --> 00:02:14.550
What we're doing here is we're saying that the smallest integer is the first integer in the vector right

33
00:02:14.550 --> 00:02:16.460
now reasonable assumption.

34
00:02:16.530 --> 00:02:19.100
We know that there is at least one integer in there.

35
00:02:19.350 --> 00:02:26.800
So we'll do that then what we'll say is we'll do again arr. base for loop will say auto We call it numb

36
00:02:27.270 --> 00:02:30.060
and the collection is numbers.

37
00:02:30.060 --> 00:02:38.040
So we'll loop through there and what we'll say is if the number we just read is less than the smallest

38
00:02:38.670 --> 00:02:44.650
that we've already seen then what do we do then we make the smallest the number we just read.

39
00:02:45.450 --> 00:02:47.220
That's it really straightforward.

40
00:02:47.220 --> 00:02:49.980
Now we do need do an output statement but look where we're going to do it.

41
00:02:49.980 --> 00:02:51.230
We're not going to do it here.

42
00:02:51.270 --> 00:02:55.380
We're going to do it here because the part this point we're out of that for loop.

43
00:02:55.440 --> 00:03:08.610
So we're going to say seek out the smallest number is a colon and it's smallest and will provide an

44
00:03:08.610 --> 00:03:10.060
end line.

45
00:03:10.950 --> 00:03:11.640
That's it.

46
00:03:11.640 --> 00:03:17.240
Let's test this out and we could put data in here top.

47
00:03:17.330 --> 00:03:18.220
It's right up here.

48
00:03:18.220 --> 00:03:20.590
Just put a bunch of data on the we know what the smallest is.

49
00:03:20.730 --> 00:03:31.170
But I really want to test it all as we go so I would have run it now and let's add 10 and let's add

50
00:03:31.260 --> 00:03:35.530
20 ambil so like us we expect 10.

51
00:03:35.730 --> 00:03:37.860
That's exactly what we got back.

52
00:03:37.860 --> 00:03:46.630
Let's add another number let's add negative 20 that's print the numbers we've got 10 20 negative 20.

53
00:03:46.920 --> 00:03:49.780
If we want the smallest at this point I'll press again.

54
00:03:50.010 --> 00:03:51.480
We should get negative 20.

55
00:03:52.020 --> 00:03:53.730
And there it is negative 20.

56
00:03:53.740 --> 00:03:57.710
It's a whole bunch of other test cases you could do but this works just fine.

57
00:03:57.780 --> 00:04:02.520
Press Q to quit and next is the largest.

58
00:04:02.520 --> 00:04:03.180
Right.

59
00:04:03.240 --> 00:04:06.990
The logic is exactly the same as this except it's going the other way.

60
00:04:06.990 --> 00:04:10.860
So in this case me clean up that whitespace space right here.

61
00:04:10.860 --> 00:04:22.170
We're going to say else if the selection is equal to a capital L or the selection is equal to a lower

62
00:04:22.170 --> 00:04:29.250
case L now the user wants to find the largest number in there and he is a mother block statement and

63
00:04:29.250 --> 00:04:36.870
the same logic I'm going to say and largest and I'm going to assume that largest is the number at the

64
00:04:36.870 --> 00:04:38.130
zero if location rate.

65
00:04:38.130 --> 00:04:42.840
The first number in the vector hopes they'll me back up here.

66
00:04:42.840 --> 00:04:46.380
Forgot to check to make sure that there's numbers in there right.

67
00:04:46.380 --> 00:04:47.850
So if numbers that size.

68
00:04:47.850 --> 00:04:52.220
I've got a little bit ahead of myself there if numbers that size is equal to zero.

69
00:04:52.440 --> 00:04:55.530
That in this case there is nothing to check right.

70
00:04:55.560 --> 00:05:04.640
So we'll just do the same thing we did here we'll say see out unable to determine largest.

71
00:05:05.140 --> 00:05:06.730
This is empty.

72
00:05:09.840 --> 00:05:14.810
Here's the else part that's the part I got ahead of myself.

73
00:05:15.150 --> 00:05:19.700
Let's assume that the largest is that first number I know there is a first number right.

74
00:05:19.710 --> 00:05:22.170
Because the size was not zero.

75
00:05:22.170 --> 00:05:25.850
So at this point were we to loop through the collection again.

76
00:05:26.010 --> 00:05:34.110
So when I say auto numb numbers just like we did before and we're going to check if the number we just

77
00:05:34.110 --> 00:05:41.010
read is greater than the largest number we've seen then what we're going to do is we're going to say

78
00:05:41.010 --> 00:05:42.830
that the largest number is now no

79
00:05:46.370 --> 00:06:01.080
zipless in our output statement now says the largest number is and we'll say largest.

80
00:06:01.360 --> 00:06:04.430
So that should take care of the largest case so let's test this out.

81
00:06:06.490 --> 00:06:10.240
So let's add some numbers will add negative 10.

82
00:06:10.330 --> 00:06:13.630
We'll add a thousand.

83
00:06:13.930 --> 00:06:18.700
We'll add 200 and will add 300.

84
00:06:19.750 --> 00:06:21.350
So that's displayer list.

85
00:06:21.610 --> 00:06:24.410
So you got negative ten thousand two hundred three hundred.

86
00:06:24.610 --> 00:06:29.830
We expect the largest to be a thousand saw press l and the largest number is a thousand.

87
00:06:29.830 --> 00:06:34.350
Let's check the smallest again as the smallest is negative 10.

88
00:06:34.470 --> 00:06:35.090
Cool.

89
00:06:35.110 --> 00:06:36.140
So we're almost done right.

90
00:06:36.160 --> 00:06:42.820
Oh we need to handle is the cue case quit here and the case is real simple because all we want to do

91
00:06:42.820 --> 00:06:44.160
is just say goodbye.

92
00:06:44.320 --> 00:06:45.370
So let's do that here.

93
00:06:45.400 --> 00:06:51.490
We'll say else if the selection in this case.

94
00:06:51.490 --> 00:06:52.350
Right.

95
00:06:52.480 --> 00:07:03.790
Just like before is an uppercase Q Or if the selection is equal to a lowercase Q In this case what we

96
00:07:03.790 --> 00:07:09.580
want is to simply say C out and let's do that in a block as well.

97
00:07:09.610 --> 00:07:13.210
You really want to do these in blocks because you never know when you're going to come back to add code

98
00:07:13.300 --> 00:07:15.790
and it's already set up to add code this way.

99
00:07:15.820 --> 00:07:17.350
So say goodbye

100
00:07:20.860 --> 00:07:21.490
and line

101
00:07:24.760 --> 00:07:25.430
perfect.

102
00:07:25.450 --> 00:07:28.540
And while we're here we may as well handle that other case right.

103
00:07:28.570 --> 00:07:31.190
That's the catch all else right here.

104
00:07:31.570 --> 00:07:34.090
That's going to be the end of the LCF else later.

105
00:07:34.240 --> 00:07:35.350
What happens here.

106
00:07:35.350 --> 00:07:38.730
Well they tried something in that I have no idea what to do with.

107
00:07:38.730 --> 00:07:40.380
So at this point what do we say.

108
00:07:40.480 --> 00:07:45.430
C out unknown selection.

109
00:07:45.430 --> 00:07:47.440
Please try again.

110
00:07:49.540 --> 00:07:51.440
That's as simple as that.

111
00:07:52.120 --> 00:07:54.000
OK.

112
00:07:54.120 --> 00:08:00.900
Seems like a lot of code and it sort of is when we talk about functions very soon we're going to make

113
00:08:00.900 --> 00:08:05.790
this so much easier because instead of all of this code and here we're just going to have one line that

114
00:08:05.790 --> 00:08:09.930
calls a function and one line that calls a function here and so forth.

115
00:08:09.930 --> 00:08:11.640
So we'll get to there soon.

116
00:08:11.640 --> 00:08:13.190
But let's finish this up now.

117
00:08:14.820 --> 00:08:16.070
Building and running.

118
00:08:16.270 --> 00:08:17.290
That's Press queue.

119
00:08:17.340 --> 00:08:19.290
We expect the goodbye message now.

120
00:08:19.350 --> 00:08:25.680
There it is goodbye and we quit and let's type in something that we don't know what to do with an.

121
00:08:26.370 --> 00:08:27.260
Unknown selection.

122
00:08:27.270 --> 00:08:31.720
Please try again one unknown selection Please try again.

123
00:08:31.950 --> 00:08:34.020
And that's it.

124
00:08:34.020 --> 00:08:35.340
That's the solution.

125
00:08:35.690 --> 00:08:42.120
Of course you could have done this with a switch statement here in which case it might have looked something

126
00:08:42.120 --> 00:08:46.610
like switch off of selection.

127
00:08:48.360 --> 00:08:49.920
And then here you would have case

128
00:08:52.540 --> 00:09:04.660
Q case lowercase Q You know C out the by and then break here and then you'd have all your other cases

129
00:09:04.800 --> 00:09:06.330
just like you saw in the videos.

130
00:09:06.510 --> 00:09:11.880
But in this case I think the switch statement is OK if we're using functions we could just call functions

131
00:09:11.880 --> 00:09:15.230
here but otherwise the switch statement Tesa get even longer.

132
00:09:15.230 --> 00:09:18.940
And I don't know how many lines of code we wrote for this example let's see.

133
00:09:19.140 --> 00:09:24.040
We started on about line 65 because the rest was just you know the stuff at the top.

134
00:09:24.090 --> 00:09:28.480
So we went from about 65 down to about 140.

135
00:09:28.500 --> 00:09:34.760
So I don't know about 70 lines of code or so it would be obviously much less when we do functions with

136
00:09:34.770 --> 00:09:38.520
the switch statement I think it would be even longer the amount of code we'd written just because of

137
00:09:38.520 --> 00:09:39.800
the syntax of the switch.

138
00:09:39.810 --> 00:09:42.840
But the if else if latter works great here.

139
00:09:42.990 --> 00:09:50.750
Obviously if I decide to add another option here it's just a matter of coming in here and you could

140
00:09:50.750 --> 00:09:55.080
do it anywhere really because it's all sort of mutually exclusive right and you could just do it right

141
00:09:55.080 --> 00:10:00.720
here else if at it between this one and this one in there you've got your other option just as easy

142
00:10:00.720 --> 00:10:01.410
as that.

143
00:10:01.740 --> 00:10:04.530
OK so I hope you enjoyed this challenge.

144
00:10:04.530 --> 00:10:09.720
This was a challenging challenge because it's using everything that we've learned so far.

145
00:10:09.720 --> 00:10:11.700
But there's a lot of logic going on here.

146
00:10:11.710 --> 00:10:14.490
It's a simple program but there's a lot of logic going on here.

147
00:10:14.490 --> 00:10:20.550
You've got you know a do while loop you've got four loops looping through the iteration and thank goodness

148
00:10:20.550 --> 00:10:27.000
that C post posts 11 gave us this range based for loop because that makes it so simple we don't have

149
00:10:27.000 --> 00:10:29.360
to do things like and I equals zero.

150
00:10:29.360 --> 00:10:34.590
I less than you know the size of the vector and then increment i along the way we'll have to deal with

151
00:10:34.590 --> 00:10:35.290
any of that.

152
00:10:35.310 --> 00:10:37.240
So that makes it really really straightforward.

153
00:10:37.590 --> 00:10:37.980
OK.

154
00:10:37.980 --> 00:10:39.570
So I hope you enjoyed this section.
