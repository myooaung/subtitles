WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:00.800
okay,

00:00:00.800 --> 00:00:06.550
The opposite off single don't sculpt being his prototype scope being that means every time

00:00:06.550 --> 00:00:10.180
workers for a B in we're going to get a brand new instance off it,

00:00:10.180 --> 00:00:12.970
which is quite opposite to Singleton beings.

00:00:12.970 --> 00:00:14.040
In this week,

00:00:14.040 --> 00:00:15.920
we're going to take an example of the same.

00:00:15.920 --> 00:00:17.180
But before that,

00:00:17.180 --> 00:00:22.550
let me quickly demonstrate the problem with the singleton scope beans in spring.

00:00:22.550 --> 00:00:27.270
And the example that I'm about to show is the same problem that we had taken.

00:00:27.270 --> 00:00:30.040
Look at when we talked about the Singleton descent.

00:00:30.040 --> 00:00:30.610
Patton.

00:00:30.610 --> 00:00:35.710
I'm in this time our sample Bean is holding a property.

00:00:35.710 --> 00:00:41.600
That means all the instances that we're going to create from the sample being would now

00:00:41.600 --> 00:00:42.750
have a state.

00:00:42.750 --> 00:00:45.420
And as of Alder demonstrated,

00:00:45.420 --> 00:00:50.550
we don't want to set the scope off a bean to Singleton when it has a state.

00:00:50.550 --> 00:00:52.930
That's a simple rule off stump,

00:00:52.930 --> 00:00:55.650
and we've already seen the negative implications off it.

00:00:55.650 --> 00:00:59.710
I'm a quickly demonstrate the same.

00:00:59.710 --> 00:01:03.800
So for this purpose I have created multiple treads,

00:01:03.800 --> 00:01:05.350
and in each spread,

00:01:05.350 --> 00:01:08.330
I'm setting a threat specific value,

00:01:08.330 --> 00:01:09.850
just as you see in here,

00:01:09.850 --> 00:01:14.660
and in order to make sure that the output is inconsistent.

00:01:14.660 --> 00:01:19.850
I've also included the following statement in the sample method,

00:01:19.850 --> 00:01:23.280
which we're calling from each and every thread.

00:01:23.280 --> 00:01:30.600
So the last thread that will set the value or the message is the message that will get

00:01:30.600 --> 00:01:32.270
displayed in all the threads.

00:01:32.270 --> 00:01:34.750
It's on the program and see the result.

00:01:34.750 --> 00:01:39.250
So this is what I'm talking about.

00:01:39.250 --> 00:01:41.650
This is very inconsistent.

00:01:41.650 --> 00:01:46.850
And also note the hash court is same as before.

00:01:46.850 --> 00:01:53.150
Now let us change the scope of the bean two so called a prototype.

00:01:53.150 --> 00:01:54.590
Not this time.

00:01:54.590 --> 00:01:56.450
If you run the program,

00:01:56.450 --> 00:02:01.960
I'm expecting the hash code Toby unique every time.

00:02:01.960 --> 00:02:03.150
Workers for the being.

00:02:03.150 --> 00:02:10.910
And it should also solve the problem we had with multi threading.

00:02:10.910 --> 00:02:16.650
And sure enough,

00:02:16.650 --> 00:02:18.780
things are sorted.

00:02:18.780 --> 00:02:22.850
And if you'd like to do the same from Java con flick,

00:02:22.850 --> 00:02:24.850
it's quite easy.

00:02:24.850 --> 00:02:34.170
All you have to do Hiss tinkler the scope annotation by setting the value to prototype just

00:02:34.170 --> 00:02:35.250
as you see in here.

00:02:35.250 --> 00:02:37.650
And that's all.

00:02:37.650 --> 00:02:51.650
Let's switch to the Java conflict and on the program and the result is pretty good.

00:02:51.650 --> 00:02:54.010
All right,

00:02:54.010 --> 00:02:55.900
we'll talk more on the same lines.

00:02:55.900 --> 00:02:57.050
Incoming videos.

00:02:57.050 --> 00:02:58.380
I will see you soon

