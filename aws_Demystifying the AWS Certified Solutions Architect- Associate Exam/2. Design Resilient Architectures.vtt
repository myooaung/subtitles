WEBVTT
1
00:00:00.440 --> 00:00:02.520
[Autogenerated] We will start off with our first

2
00:00:02.520 --> 00:00:05.040
objective from the exam blueprint.

3
00:00:05.040 --> 00:00:07.810
Design resilient architectures,

4
00:00:07.810 --> 00:00:12.620
and we're going to go through several facets of this objective and look at

5
00:00:12.620 --> 00:00:16.540
key services and key concepts that you need to understand.

6
00:00:16.540 --> 00:00:19.440
To pass the exam.

7
00:00:19.440 --> 00:00:21.520
To design a multi tier architecture,

8
00:00:21.520 --> 00:00:25.050
you need to have a clear understanding of the five

9
00:00:25.050 --> 00:00:28.040
components of a multi tier architecture.

10
00:00:28.040 --> 00:00:32.140
The first of these is the VPC.

11
00:00:32.140 --> 00:00:34.730
The VPC, or the virtual Private cloud,

12
00:00:34.730 --> 00:00:38.340
is a fundamental aspect of building service solutions in the cloud.

13
00:00:38.340 --> 00:00:41.550
The VPC is designed to mimic private networking

14
00:00:41.550 --> 00:00:44.440
aspect of an on premise data center.

15
00:00:44.440 --> 00:00:48.100
We'll discuss this in more detail in a later exam object

16
00:00:48.100 --> 00:00:51.040
when we specifically focus on networking.

17
00:00:51.040 --> 00:00:54.710
The next component is the use of availability zones

18
00:00:54.710 --> 00:00:56.930
and sub nets to build resilient,

19
00:00:56.930 --> 00:01:01.800
highly available solutions to help us eliminate single points of failure.

20
00:01:01.800 --> 00:01:05.840
This will be covered in more detail in later exam objective as well.

21
00:01:05.840 --> 00:01:10.840
Next, we have security groups and network access control list,

22
00:01:10.840 --> 00:01:12.600
also known as knack ALS.

23
00:01:12.600 --> 00:01:15.740
These act like firewalls for your infrastructure and they

24
00:01:15.740 --> 00:01:19.200
will be covered in our networking module.

25
00:01:19.200 --> 00:01:24.030
The next aspect of a multi tier solution is the use

26
00:01:24.030 --> 00:01:27.130
of load balancers within AWS.

27
00:01:27.130 --> 00:01:29.560
There are three types of load balancers.

28
00:01:29.560 --> 00:01:32.240
We have the classic load balancer,

29
00:01:32.240 --> 00:01:37.140
these application load balancer and the network load balancer.

30
00:01:37.140 --> 00:01:41.430
And each of these load balancers has specific use cases for when

31
00:01:41.430 --> 00:01:44.950
their best fits is well is best practices,

32
00:01:44.950 --> 00:01:51.060
which will briefly mention later the final aspect of a well designed,

33
00:01:51.060 --> 00:01:55.140
multi tier architecture er, is using cloudfront.

34
00:01:55.140 --> 00:01:59.390
We might not always use cloudfront, but when we have caching needs,

35
00:01:59.390 --> 00:02:01.530
cloudfront can be very useful.

36
00:02:01.530 --> 00:02:05.550
Cloudfront can help us cache both static content as well as

37
00:02:05.550 --> 00:02:09.340
dynamic content for our modern web applications.

38
00:02:09.340 --> 00:02:13.060
This service will also be covered in more detail in a later exam.

39
00:02:13.060 --> 00:02:14.140
Objective-C.

40
00:02:14.140 --> 00:02:19.580
The purpose off this aspect of the exam is understanding how these

41
00:02:19.580 --> 00:02:24.700
solutions fit together to build a multi tier solution.

42
00:02:24.700 --> 00:02:29.060
This diagram is intended to provide an example of a multi

43
00:02:29.060 --> 00:02:33.850
tier solution before sitting for the exam.

44
00:02:33.850 --> 00:02:38.310
Make sure you are comfortable with this diagram and why different

45
00:02:38.310 --> 00:02:43.010
types of sub nets are used depending on the types of services and

46
00:02:43.010 --> 00:02:45.300
servers that are being deployed.

47
00:02:45.300 --> 00:02:46.790
For example,

48
00:02:46.790 --> 00:02:54.060
this data layer of our model is in a private sub net our databases should

49
00:02:54.060 --> 00:02:58.440
always be protected and not be exposed to the public internet.

50
00:02:58.440 --> 00:03:03.540
We'll talk more about database is in a later module as well.

51
00:03:03.540 --> 00:03:08.470
So applying the concepts we've just discussed to create highly available,

52
00:03:08.470 --> 00:03:10.500
fault tolerant solutions,

53
00:03:10.500 --> 00:03:15.170
it's important to loosely couple our systems to

54
00:03:15.170 --> 00:03:18.340
prevent single points of failure.

55
00:03:18.340 --> 00:03:20.200
When taking the exam,

56
00:03:20.200 --> 00:03:25.040
look carefully at the scenarios presented and the questions related to highly

57
00:03:25.040 --> 00:03:30.710
available fault tolerant systems and choose theon option that does not create a

58
00:03:30.710 --> 00:03:34.540
tightly coupled system or a single point of failure.

59
00:03:34.540 --> 00:03:41.710
Avoid tight coupling because it leads to single points of failure in our design.

60
00:03:41.710 --> 00:03:46.220
If you go back and read the well architected framework White paper,

61
00:03:46.220 --> 00:03:50.110
it will help clear up any areas of confusion you may have around

62
00:03:50.110 --> 00:03:54.440
loosely coupled versus tight coupled systems.

63
00:03:54.440 --> 00:03:59.460
Decoupled architectures is another important area to understand.

64
00:03:59.460 --> 00:04:05.010
For the exam, there are reasons for us to use decoupling in our architectures.

65
00:04:05.010 --> 00:04:10.840
We're gonna look at three of these that you need to understand to pass the exam.

66
00:04:10.840 --> 00:04:15.240
The first of these is to decouple our architecture for health reasons.

67
00:04:15.240 --> 00:04:20.140
This is done to prevent one system from breaking the entire process.

68
00:04:20.140 --> 00:04:23.440
Oven apps stream system fails.

69
00:04:23.440 --> 00:04:27.440
Think of any commerce platform a customer places in order.

70
00:04:27.440 --> 00:04:30.740
That order goes into a queue and the order processing

71
00:04:30.740 --> 00:04:33.840
system pulls the order from the queue.

72
00:04:33.840 --> 00:04:35.840
After it processes the order,

73
00:04:35.840 --> 00:04:43.340
it sends it to another downstream que is for order fulfillment at a warehouse.

74
00:04:43.340 --> 00:04:48.240
If one of these two down street systems breaks the customer's orders,

75
00:04:48.240 --> 00:04:52.020
can see to be taken because of the decoupled architectures,

76
00:04:52.020 --> 00:04:54.000
they can be stored in queues.

77
00:04:54.000 --> 00:04:56.430
When the system comes back online,

78
00:04:56.430 --> 00:05:00.560
the order can be processed and fulfilled without having cues.

79
00:05:00.560 --> 00:05:05.140
The entire process breaks because the system breaks.

80
00:05:05.140 --> 00:05:09.240
Using cues helps ensure that orders are not lost.

81
00:05:09.240 --> 00:05:15.640
The next reason to use cues is to decouple for scalability.

82
00:05:15.640 --> 00:05:17.120
For this use case,

83
00:05:17.120 --> 00:05:21.580
take a system that trans code customer videos When

84
00:05:21.580 --> 00:05:23.770
the customer's videos are received,

85
00:05:23.770 --> 00:05:27.130
their place into queues for downstream systems to the code.

86
00:05:27.130 --> 00:05:28.540
The videos.

87
00:05:28.540 --> 00:05:31.520
Because video trans coating can see are e processor,

88
00:05:31.520 --> 00:05:37.340
intensive jobs in the queue can start to get large,

89
00:05:37.340 --> 00:05:39.040
and if you remember,

90
00:05:39.040 --> 00:05:46.830
you can use CloudWatch combined with sqs to monitor the queue and make auto

91
00:05:46.830 --> 00:05:52.340
scaling changes to the worker processes As the queue grows.

92
00:05:52.340 --> 00:05:56.140
This is one way scalability convey used with queues.

93
00:05:56.140 --> 00:06:01.540
The final aspect for decoupling for scalability involves elastic load balancers.

94
00:06:01.540 --> 00:06:05.590
Load balancers can be placed both on the edge and at

95
00:06:05.590 --> 00:06:08.240
the apple are of our architecture,

96
00:06:08.240 --> 00:06:13.310
then the elastic load balancer and auto scaling can be used together to

97
00:06:13.310 --> 00:06:16.840
scale and manage various layers of our architecture.

98
00:06:16.840 --> 00:06:22.290
So when designing architecture, it is important to separate services for example,

99
00:06:22.290 --> 00:06:27.790
having dedicated web servers at one layer and having dedicated application

100
00:06:27.790 --> 00:06:32.440
servers at another layer that can scale independently.

101
00:06:32.440 --> 00:06:36.770
The last take load balancer gives us the ability to do this and

102
00:06:36.770 --> 00:06:41.640
decouple our architecture for scalability,

103
00:06:41.640 --> 00:06:48.140
one of the storage types that is often for gotten his instant store.

104
00:06:48.140 --> 00:06:52.100
And what you need to remember for this exam objective is that it is only

105
00:06:52.100 --> 00:06:56.810
supported with a limited number of are two instantiate types.

106
00:06:56.810 --> 00:07:00.240
It also has limited capacity for storage,

107
00:07:00.240 --> 00:07:07.020
but it's extremely fast because it resides on the actual physical host.

108
00:07:07.020 --> 00:07:09.290
It is not network attached storage.

109
00:07:09.290 --> 00:07:10.120
However.

110
00:07:10.120 --> 00:07:14.210
The problem with this type of storage is that it is temporary or

111
00:07:14.210 --> 00:07:17.830
what we call ephemeral because it is ephemeral.

112
00:07:17.830 --> 00:07:20.910
It only exists for the life of the instance,

113
00:07:20.910 --> 00:07:24.150
and then it's gone because of this,

114
00:07:24.150 --> 00:07:28.740
it is neither reliable nor resilient as a storage option.

115
00:07:28.740 --> 00:07:32.490
There are use cases for this type of storage,

116
00:07:32.490 --> 00:07:36.740
but not for a resilient and reliable architectures.

117
00:07:36.740 --> 00:07:43.240
And the next storage type is elastic block store.

118
00:07:43.240 --> 00:07:46.430
This storage is network attached storage,

119
00:07:46.430 --> 00:07:49.440
and it has a lifecycle that is independent of the instance

120
00:07:49.440 --> 00:07:54.290
detached to There are four types of EBS volumes.

121
00:07:54.290 --> 00:07:57.640
There are two types based on traditional hard drugs,

122
00:07:57.640 --> 00:08:01.240
and there are two types based on solid state drives.

123
00:08:01.240 --> 00:08:05.440
The two solid state Docker types should be familiar.

124
00:08:05.440 --> 00:08:11.840
There is general Purpose SSD, also known as GP two,

125
00:08:11.840 --> 00:08:15.730
and there's also provisioned IOPS SSD,

126
00:08:15.730 --> 00:08:21.640
known as I 01 We won't discuss the characteristics of these drives

127
00:08:21.640 --> 00:08:25.050
because this is not a deep dive into storage types,

128
00:08:25.050 --> 00:08:30.200
but you should be familiar with the characteristics for the exam.

129
00:08:30.200 --> 00:08:33.270
You need to understand when you should use something like GP

130
00:08:33.270 --> 00:08:39.040
two versus I owe one for a given situation.

131
00:08:39.040 --> 00:08:44.940
The two types of hard drives based on storage traditional Docker types,

132
00:08:44.940 --> 00:08:52.020
our throughput optimized HDD, also known as S T one,

133
00:08:52.020 --> 00:08:56.190
and cold HDD known as S C.

134
00:08:56.190 --> 00:08:57.440
One.

135
00:08:57.440 --> 00:09:04.640
Again, Please make sure you review the characteristics of these Docker types.

136
00:09:04.640 --> 00:09:09.720
The key got to to pay attention to on the exam is that neither

137
00:09:09.720 --> 00:09:15.450
s t one nor SC one can be used as a boot.

138
00:09:15.450 --> 00:09:29.340
Um, for any instance, all four of these Docker types are reliable and resilient.

139
00:09:29.340 --> 00:09:34.130
The next storage type we wanna look at is a newer storage type

140
00:09:34.130 --> 00:09:40.640
known as elastic file store or Amazon Efs.

141
00:09:40.640 --> 00:09:41.890
Think of S E.

142
00:09:41.890 --> 00:09:42.160
F.

143
00:09:42.160 --> 00:09:45.440
S is a petabytes scale file storage.

144
00:09:45.440 --> 00:09:47.220
It is an elastic storage,

145
00:09:47.220 --> 00:09:51.840
so you don't have to define storage allocation at creation.

146
00:09:51.840 --> 00:09:56.890
And unlike and bs volume, it can be attached to multiple E C.

147
00:09:56.890 --> 00:09:59.440
Two instances.

148
00:09:59.440 --> 00:10:10.230
EFS supports both NFS 40 and the 41 protocols, and it's compatible with Linux.

149
00:10:10.230 --> 00:10:15.140
There will be support for Windows in the future, but currently it's Linux only.

150
00:10:15.140 --> 00:10:17.640
Before you take the exam,

151
00:10:17.640 --> 00:10:24.640
you should probably check the fake for EFS to make sure that has not changed.

152
00:10:24.640 --> 00:10:31.340
Because EFS is a managed service, it is designed to be reliable and resilience.

153
00:10:31.340 --> 00:10:35.440
The next storage type we wanna look at is Amazon S3.

154
00:10:35.440 --> 00:10:40.240
It is probably the most well known storage type within AWS,

155
00:10:40.240 --> 00:10:44.840
and it's also one of the oldest services that AWS developed.

156
00:10:44.840 --> 00:10:47.640
It's been around since 2006.

157
00:10:47.640 --> 00:10:51.140
It also supports what's known as encryption at rest.

158
00:10:51.140 --> 00:10:55.540
Amazon S3 is available in several storage classes,

159
00:10:55.540 --> 00:11:01.340
but S3 standard support what's called 11 nines durability,

160
00:11:01.340 --> 00:11:05.740
which makes Amazon S3 a reliable and resilient storage option.

161
00:11:05.740 --> 00:11:07.040
For your data.

162
00:11:07.040 --> 00:11:08.480
For the exam,

163
00:11:08.480 --> 00:11:13.020
you need to be familiar with the characteristics of Amazon S3 storage.

164
00:11:13.020 --> 00:11:16.270
The final service we wanna look at is Amazon.

165
00:11:16.270 --> 00:11:21.340
Glacier Glacier is designed for long term data storage.

166
00:11:21.340 --> 00:11:24.840
Think of Glacier as a replacement for tape drops.

167
00:11:24.840 --> 00:11:28.860
Glacier can be used in conjunction with Amazon S3 for

168
00:11:28.860 --> 00:11:32.080
lifecycle policies to archive data.

169
00:11:32.080 --> 00:11:34.530
The key thing you wanna remember about Glacier it is

170
00:11:34.530 --> 00:11:37.330
not designed to be a backup solution.

171
00:11:37.330 --> 00:11:41.240
It is designed to be an archival solution.

172
00:11:41.240 --> 00:11:46.850
Please refer to the links included with the course to help you dive deeper

173
00:11:46.850 --> 00:11:51.490
into any of these topics before we move on to the next exam.

174
00:11:51.490 --> 00:11:52.440
Objective-C.

175
00:11:52.440 --> 00:11:55.420
Let's take a few minutes to review a couple of sample

176
00:11:55.420 --> 00:11:59.250
exam questions and discuss how to tackle these types of

177
00:11:59.250 --> 00:12:01.840
questions when taking the exam.

178
00:12:01.840 --> 00:12:04.750
So this first example question is from our design

179
00:12:04.750 --> 00:12:11.250
Brazilian architectures Objective-C, and the question is as follows.

180
00:12:11.250 --> 00:12:16.310
A solution architect is designing a highly scalable system to track

181
00:12:16.310 --> 00:12:20.940
patient records due to compliance requirements.

182
00:12:20.940 --> 00:12:26.740
These records must remain available for immediate download for up to six months,

183
00:12:26.740 --> 00:12:29.140
and then they can be archived.

184
00:12:29.140 --> 00:12:34.090
What is the best approach to address this issue?

185
00:12:34.090 --> 00:12:38.120
Store the files in Amazon EBS and create lifecycle policy to

186
00:12:38.120 --> 00:12:42.840
move the files to Glacier after six months,

187
00:12:42.840 --> 00:12:45.480
store the fouls in Amazon Glacier and create

188
00:12:45.480 --> 00:12:48.840
lifecycle policies to archives to S3.

189
00:12:48.840 --> 00:12:51.980
After six months,

190
00:12:51.980 --> 00:12:55.040
store the files in Amazon S3 and create lifecycle

191
00:12:55.040 --> 00:12:56.870
policies to archive to glacier.

192
00:12:56.870 --> 00:13:00.020
After six months or option d,

193
00:13:00.020 --> 00:13:03.000
store the files in Amazon EFS and create a

194
00:13:03.000 --> 00:13:05.270
lifecycle policy to archive the files.

195
00:13:05.270 --> 00:13:07.140
After six months,

196
00:13:07.140 --> 00:13:11.630
pause the video for a moment and think about how you would answer this

197
00:13:11.630 --> 00:13:15.740
question and then we'll come back and discuss it.

198
00:13:15.740 --> 00:13:19.640
So, first of all, what is the question really asking us?

199
00:13:19.640 --> 00:13:19.840
Well,

200
00:13:19.840 --> 00:13:23.370
there most of the information and the question is really not

201
00:13:23.370 --> 00:13:26.780
relevant talking about compliance requirements other than the fact

202
00:13:26.780 --> 00:13:28.650
that you need the information to be around,

203
00:13:28.650 --> 00:13:30.250
that could be eliminated from the question,

204
00:13:30.250 --> 00:13:34.160
though the key is that it must be available for

205
00:13:34.160 --> 00:13:38.680
immediate download for six months, then it can be archived.

206
00:13:38.680 --> 00:13:42.790
What we talked about archiving and that glacier is

207
00:13:42.790 --> 00:13:47.140
what we use to archive our data.

208
00:13:47.140 --> 00:13:48.350
So that's part of it.

209
00:13:48.350 --> 00:13:52.480
So answer A says, use EBS and create lifecycle policies.

210
00:13:52.480 --> 00:13:54.420
We know that's not correct.

211
00:13:54.420 --> 00:13:58.130
If you've been studying a to be s and building your mental model,

212
00:13:58.130 --> 00:14:00.960
you know, EBS does not work with lifecycle policies,

213
00:14:00.960 --> 00:14:02.400
so that is not an option.

214
00:14:02.400 --> 00:14:06.440
And you can't use EBS to put anything in Glacier.

215
00:14:06.440 --> 00:14:12.140
The second option store files in Glacier and create a policy to archive to S3.

216
00:14:12.140 --> 00:14:18.840
That's not really gonna work either, because that's the backwards way.

217
00:14:18.840 --> 00:14:21.630
You don't start with Glacier and then go to S3.

218
00:14:21.630 --> 00:14:22.280
So again,

219
00:14:22.280 --> 00:14:26.940
you could eliminate this one pretty easily if you understood the material.

220
00:14:26.940 --> 00:14:30.530
The third option is store the files in Amazon S3 and create a

221
00:14:30.530 --> 00:14:32.480
lifecycle policy to archive dict Glacier.

222
00:14:32.480 --> 00:14:36.980
After six months, that sounds like a pretty good answer.

223
00:14:36.980 --> 00:14:42.740
Let's just look at the last one just to be safe before we make our final choice,

224
00:14:42.740 --> 00:14:43.620
De says,

225
00:14:43.620 --> 00:14:46.870
store the files in Amazon EFS and create a lifecycle

226
00:14:46.870 --> 00:14:49.840
policy to archive files after six months.

227
00:14:49.840 --> 00:14:52.990
Okay, we know we can't use the f s with lifecycle policies,

228
00:14:52.990 --> 00:14:56.340
lifecycle policies or for S3.

229
00:14:56.340 --> 00:15:02.040
So that leaves us with one answer choice.

230
00:15:02.040 --> 00:15:04.760
Answer C is the correct answer.

231
00:15:04.760 --> 00:15:08.750
Store the fouls and Amazon S3 and create a lifecycle policy

232
00:15:08.750 --> 00:15:14.630
to archive to glacier After six months, how did you do?

233
00:15:14.630 --> 00:15:22.840
Let's look at one more.

234
00:15:22.840 --> 00:15:27.340
There's a requirement to host database only to instance,

235
00:15:27.340 --> 00:15:34.180
the storage option chosen must support at least 28,000 IOPS If you don't

236
00:15:34.180 --> 00:15:39.440
remember IOPS our input output operations per second.

237
00:15:39.440 --> 00:15:43.890
Which Amazon download volume type meets this performance

238
00:15:43.890 --> 00:15:51.380
requirement for our database A e b s provisioned IOPS also known

239
00:15:51.380 --> 00:15:58.240
as I 01 B e B s throughput optimize HDD,

240
00:15:58.240 --> 00:16:09.840
c E B s general purpose SSD or D E B s cold HDD.

241
00:16:09.840 --> 00:16:11.260
Well, think about it for a second.

242
00:16:11.260 --> 00:16:19.720
Pause the video and again, think about how you would answer this question.

243
00:16:19.720 --> 00:16:22.640
This type of question on the exam will require you to

244
00:16:22.640 --> 00:16:28.840
remember key characteristics about volumes.

245
00:16:28.840 --> 00:16:32.510
And what you have to understand is that you're not gonna

246
00:16:32.510 --> 00:16:35.780
be able to get this kind of throughput from anything

247
00:16:35.780 --> 00:16:39.640
except a provisioned IOPS Docker.

248
00:16:39.640 --> 00:16:39.910
Thea.

249
00:16:39.910 --> 00:16:44.470
Other types can't do it again.

250
00:16:44.470 --> 00:16:45.930
How did you do?

251
00:16:45.930 --> 00:16:50.680
Did you get them both right, Well, let's move on to the next exam.

252
00:16:50.680 --> 00:16:52.040
Objective-C.

253
00:16:52.040 --> 00:16:54.690
If you still are unclear or any of any of this,

254
00:16:54.690 --> 00:16:57.840
there's ways you can go back and study some more.

255
00:16:57.840 --> 00:16:58.490
Go back.

256
00:16:58.490 --> 00:17:02.270
Review what we talked about in in the first module when we

257
00:17:02.270 --> 00:17:05.640
laid out and built our middle model.

258
00:17:05.640 --> 00:17:11.440
But let's keep going before we move to the next objective of the exam.

259
00:17:11.440 --> 00:17:13.750
Let's take some exam takeaways that you really need

260
00:17:13.750 --> 00:17:16.740
to focus on for this objective.

261
00:17:16.740 --> 00:17:21.240
First of all, you want to design your infrastructures to fail.

262
00:17:21.240 --> 00:17:26.410
Make sure when you design things, they're resilient and they don't just fail.

263
00:17:26.410 --> 00:17:29.340
No single points of failure.

264
00:17:29.340 --> 00:17:30.430
Secondly,

265
00:17:30.430 --> 00:17:35.040
understand the difference between fault tolerance and high availability.

266
00:17:35.040 --> 00:17:36.140
Go back,

267
00:17:36.140 --> 00:17:39.790
look at the white papers and make sure you understand the difference

268
00:17:39.790 --> 00:17:43.440
because they will try to trick you on the exam.

269
00:17:43.440 --> 00:17:44.390
Third,

270
00:17:44.390 --> 00:17:49.390
assume that an answer that is a single availability zone will never

271
00:17:49.390 --> 00:17:53.040
be the correct answer to any question on the exam.

272
00:17:53.040 --> 00:17:55.040
Finally,

273
00:17:55.040 --> 00:17:59.570
manage services are always pervert because a manage

274
00:17:59.570 --> 00:18:02.740
service is going to be managed by AD DS,

275
00:18:02.740 --> 00:18:04.540
and you're not gonna have to worry about.

276
00:18:04.540 --> 00:18:12.000
All the inner workings of it is if you then if you deploy it yourself, so keep that in mind for the exam.

