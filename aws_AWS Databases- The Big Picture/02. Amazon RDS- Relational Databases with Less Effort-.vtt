WEBVTT
1
00:00:01.000 --> 00:00:03.920
Let's start out with relational databases.

2
00:00:03.920 --> 00:00:08.160
Relational databases are still a great fit for applications that

3
00:00:08.160 --> 00:00:11.780
know the structure of the data being stored, and that structure

4
00:00:11.780 --> 00:00:14.710
isn't expected to change very often.

5
00:00:14.710 --> 00:00:19.180
Relational databases best support tabular data that needs

6
00:00:19.180 --> 00:00:22.130
to be recorded in rows, then aggregated,

7
00:00:22.130 --> 00:00:26.530
sorted, and reported. As you start trying to store nontabular data, like

8
00:00:26.530 --> 00:00:30.790
JSON or XML documents, and binary data, like images,

9
00:00:30.790 --> 00:00:35.540
audio, and video files, you can do that with a relational database,

10
00:00:35.540 --> 00:00:37.730
but it's not always the best fit.

11
00:00:37.730 --> 00:00:41.020
Some strengths of relational databases include the fact

12
00:00:41.020 --> 00:00:42.860
that they've been around for a while.

13
00:00:42.860 --> 00:00:47.380
It's a mature technology that is familiar to a large number of people

14
00:00:47.380 --> 00:00:51.240
and is relatively easy to learn and understand.

15
00:00:51.240 --> 00:00:55.760
Amazon RDS is a managed relational database service.

16
00:00:55.760 --> 00:00:57.440
So, what does that mean?

17
00:00:57.440 --> 00:01:00.450
Amazon manages the database by taking care of

18
00:01:00.450 --> 00:01:03.980
administrative tasks like provisioning hardware,

19
00:01:03.980 --> 00:01:07.720
maintaining database images for your database instances,

20
00:01:07.720 --> 00:01:10.240
and performing updates and patches.

21
00:01:10.240 --> 00:01:13.790
This allows you to focus on developing your application

22
00:01:13.790 --> 00:01:16.640
instead of administering the database.

23
00:01:16.640 --> 00:01:18.250
When you launch a database,

24
00:01:18.250 --> 00:01:23.680
you'll select an instance size based on your anticipated compute, memory,

25
00:01:23.680 --> 00:01:25.540
and I/O needs.

26
00:01:25.540 --> 00:01:29.280
You can choose a small instance and enjoy cost savings for

27
00:01:29.280 --> 00:01:33.450
applications that have a light database load or choose a large

28
00:01:33.450 --> 00:01:37.140
instance for applications that need higher performance.

29
00:01:37.140 --> 00:01:41.000
As your application changes, you can easily upgrade your database to

30
00:01:41.000 --> 00:01:45.880
run on a larger instance size with more resources. RDS has several

31
00:01:45.880 --> 00:01:48.740
helpful features for storage management.

32
00:01:48.740 --> 00:01:52.600
You can use storage autoscaling to automatically increase your available

33
00:01:52.600 --> 00:01:56.320
storage space as you fill it up so you don't have to worry about running

34
00:01:56.320 --> 00:02:01.150
out of disk space, and you can also schedule backups and restore backups

35
00:02:01.150 --> 00:02:04.770
to new instances in just a few steps.

36
00:02:04.770 --> 00:02:09.490
RDS supports running instances in multiple availability zones,

37
00:02:09.490 --> 00:02:13.290
allowing you to create highâ€‘availability database clusters.

38
00:02:13.290 --> 00:02:16.970
Enabling these clusters is a simple configuration so you don't

39
00:02:16.970 --> 00:02:20.350
have to spend hours setting up and testing replication between

40
00:02:20.350 --> 00:02:24.930
your instances. You can create an RDS instance using several

41
00:02:24.930 --> 00:02:28.930
different database engines, including Amazon Aurora,

42
00:02:28.930 --> 00:02:37.040
PostgreSQL, MySQL, MariaDB, Oracle Database, and Microsoft SQL Server.

43
00:02:37.040 --> 00:02:40.380
This makes it easy to move your existing relational databases to the

44
00:02:40.380 --> 00:02:43.880
cloud without having to change your database engine.

45
00:02:43.880 --> 00:02:51.000
We'll talk more about costs in another module, but be aware that each database engine has its own pricing model.

