WEBVTT
1

00:00:01.320  -->  00:00:07.200
You've learned a lot about the different types variables, how to use them, how to use arrays and how the

2

00:00:07.200  -->  00:00:11.370
basics of the Javascript language work.

3

00:00:11.370  -->  00:00:19.090
You also had a look at objects and these reference types which object seem to be.

4

00:00:19.200  -->  00:00:26.760
Now in this module, I'll focus on objects, which means I'll explain what objects actually are, how you create

5

00:00:26.760  -->  00:00:27.360
them

6

00:00:27.480  -->  00:00:35.960
and some characteristics objects in Javascript have. Let's dive into this.

7

00:00:36.090  -->  00:00:38.310
Let's start with the creation of objects,

8

00:00:38.340  -->  00:00:46.620
I already showed one way; I can create an object by simply creating a variable and the value which I

9

00:00:46.620  -->  00:00:55.180
create is an object with opening and closing curly braces and then between those curly braces, I

10

00:00:55.220  -->  00:00:57.140
define the object.

11

00:00:57.210  -->  00:01:04.350
Now I was already talking about fields and methods or functions inside this object

12

00:01:04.350  -->  00:01:07.920
and I want to show this in more detail here.

13

00:01:08.340  -->  00:01:14.880
So I'll not name this object, I'll name this person to make this a bit more realistic and let's say this person

14

00:01:14.880  -->  00:01:22.020
has a name and now I'm just picking my name here but you may enter your name of course. Important, when creating

15

00:01:22.020  -->  00:01:23.900
an object,

16

00:01:24.250  -->  00:01:29.030
you're not writing name equals but instead name colon,

17

00:01:29.040  -->  00:01:32.780
at least when using this notation and I'll show other notations

18

00:01:32.790  -->  00:01:39.630
soon, this is the Javascript object notation, a literal notation where you have this very convenient

19

00:01:39.630  -->  00:01:43.800
way of creating object, just like this in code with curly braces.

20

00:01:43.830  -->  00:01:49.660
So then you have your variable here or your field name, colon and then the value

21

00:01:49.770  -->  00:01:55.410
and of course you might have multiples like age too, which in this case will be a number.

22

00:01:55.500  -->  00:02:03.060
You can then of course log the complete object like this and you will see it here

23

00:02:03.480  -->  00:02:12.650
or you can just access certain variables or properties of this object by writing person.name

24

00:02:12.660  -->  00:02:20.400
for example. If I run this, I just see Max because I'm now only accessing this property here.

25

00:02:20.630  -->  00:02:30.360
Another way to access this property is to use this array-like notation with square brackets and then

26

00:02:30.360  -->  00:02:33.690
here, you pass the field you want to access,

27

00:02:33.690  -->  00:02:40.740
for example name again as a string, so name.

28

00:02:41.610  -->  00:02:47.160
Now if I run this, I still get Max,

29

00:02:47.160  -->  00:02:52.980
however accessing properties like this is not how you should do this by default.

30

00:02:53.250  -->  00:03:00.900
This is more useful if you will have say another variable which I name field and this would be a string

31

00:03:00.900  -->  00:03:07.140
of name and let's say this variable would be dynamically derived from within your code,

32

00:03:07.140  -->  00:03:15.390
then you could pass this variable here, like we were passing the index i in a for loop when accessing

33

00:03:15.390  -->  00:03:18.750
the different fields or elements in an array for example,

34

00:03:18.750  -->  00:03:22.070
so here I'm passing this variable which of course is a string

35

00:03:22.440  -->  00:03:26.930
and now I'm outputting name too. Now why is this better?

36

00:03:27.030  -->  00:03:31.470
Well it's better because this might be the only way you get this field name in your code

37

00:03:31.470  -->  00:03:34.920
when again this is dynamically created.

38

00:03:35.340  -->  00:03:43.230
If you know which field you want access when writing the code, always use the dot notation here to access

39

00:03:43.230  -->  00:03:45.770
this property, like so.

40

00:03:46.350  -->  00:03:48.960
So this is how you can access properties,

41

00:03:48.960  -->  00:03:52.150
now what kind of properties can you have?

42

00:03:52.350  -->  00:03:54.740
You see we got name and age here,

43

00:03:55.170  -->  00:03:58.990
you also can have objects as properties,

44

00:03:59.070  -->  00:04:03.010
so I can create another object within this object.

45

00:04:03.060  -->  00:04:16.640
So details might be hobbies which then might be an array, sports, cooking, whatever and let's say another

46

00:04:16.650  -->  00:04:21.650
property of this nested object with my location, Germany.

47

00:04:21.690  -->  00:04:30.780
Now I could print out details.hobbies and let's see what shows up if I hit run, I see sports and cooking

48

00:04:30.780  -->  00:04:31.030
.

49

00:04:31.050  -->  00:04:38.040
So now I can access this nested object just by chaining the properties here with dot notation

50

00:04:38.490  -->  00:04:44.150
and this is very important to understand, your object can hold all the types

51

00:04:44.160  -->  00:04:46.270
you could also assign to variables.

52

00:04:46.350  -->  00:04:50.820
You can think of these properties as variables, just inside an object,

53

00:04:50.820  -->  00:04:55.890
this is why we have this colon here and no equal sign because we're inside an object but

54

00:04:55.940  -->  00:05:03.810
besides that, you can have the same things. You can of course also have a function in here, though you

55

00:05:03.810  -->  00:05:12.210
wouldn't write it like this but you would write greet for example if this should be the greet function,

56

00:05:12.390  -->  00:05:20.100
still a colon and then function console log

57

00:05:20.490  -->  00:05:21.730
Hello

58

00:05:22.460  -->  00:05:31.310
and I could call this function like so, person.greet, don't forget the parentheses here.

59

00:05:31.380  -->  00:05:35.520
If I execute this code, you'll see Hello of course.

60

00:05:35.520  -->  00:05:44.150
Now using this notation looks like this notation when creating function outside of objects and

61

00:05:44.150  -->  00:05:48.440
it's very comparable, only the equal sign got replaced.

62

00:05:49.410  -->  00:05:54.690
So that's the general idea you should follow when creating objects or you may think of objects. You have

63

00:05:54.700  -->  00:05:59.010
key-value pairs for everything, including functions,

64

00:05:59.070  -->  00:06:05.640
you always have that key and then the value may be whichever value you could also assign to variables

65

00:06:05.640  -->  00:06:06.050
.

66

00:06:06.060  -->  00:06:11.470
This is how you can think and should think of objects and what is the advantage of such an object?

67

00:06:11.700  -->  00:06:15.100
Well you can depict many things much better with an object.

68

00:06:15.120  -->  00:06:18.410
Let's say your application indeed works with persons,

69

00:06:18.510  -->  00:06:24.840
it allows a user to enter some data about himself and then you want to use that in your Javascript 

70

00:06:24.840  -->  00:06:25.170
application.

71

00:06:25.170  -->  00:06:29.740
Now you could create a variable for that name, for the last name and so on

72

00:06:29.910  -->  00:06:35.550
or you group it all together in one object which makes much more sense since you're probably going to

73

00:06:35.550  -->  00:06:38.170
use that object throughout your code anyways,

74

00:06:38.370  -->  00:06:41.260
so this is where objects really shine.

75

00:06:41.370  -->  00:06:49.320
And of course they are reference types as explained earlier, which means you can use one object in multiple

76

00:06:49.320  -->  00:06:53.800
variables and if you change it in one place, the rest will be updated too

77

00:06:53.820  -->  00:06:56.100
and that's not necessarily a bad behavior,

78

00:06:56.100  -->  00:07:01.030
this would allow you to make sure you keep a certain object in sync,

79

00:07:01.080  -->  00:07:05.290
so you make sure you always have the same state throughout your application.

80

00:07:05.610  -->  00:07:13.210
So if I now try something else and I log the typeof person,

81

00:07:13.230  -->  00:07:18.360
this of course should be straightforward and should give us an object.

82

00:07:18.360  -->  00:07:23.680
What if I log the typeof person.name, what do you think will show up now?

83

00:07:24.450  -->  00:07:25.520
Well we get a string.

84

00:07:25.530  -->  00:07:31.740
So this is a normal string value, has nothing to do with an object, it's just a property inside an object

85

00:07:31.950  -->  00:07:35.640
but the value is string or number or object

86

00:07:35.640  -->  00:07:42.500
in this case or function in this case, like it would be the case outside of an object.

87

00:07:42.510  -->  00:07:47.470
There's also one addition I want to make sure or one important thing to understand

88

00:07:47.490  -->  00:07:48.370
and know;

89

00:07:48.450  -->  00:07:51.080
until now we always use property names like this

90

00:07:51.120  -->  00:07:52.980
and this is perfectly fine,

91

00:07:52.980  -->  00:08:00.750
however there's also one other way, you may use strings as your property names, like this, age, name

92

00:08:00.840  -->  00:08:01.940
and so on

93

00:08:02.250  -->  00:08:04.330
and one advantage this yields is that

94

00:08:04.350  -->  00:08:12.990
now you're also able to use for example a dash in the name, like let's say first-name which otherwise

95

00:08:12.990  -->  00:08:18.620
would give you an error, you're not allowed to have like let's say the first details with a dash.

96

00:08:18.780  -->  00:08:24.330
If you run this, you'll get an error but if I run it without the first details, you'll see it'll work

97

00:08:24.360  -->  00:08:25.430
fine because

98

00:08:25.440  -->  00:08:30.170
I won't have a name here but this is a string.

99

00:08:30.210  -->  00:08:36.870
So this has one advantage you may use and names, property names which you would not be able to use otherwise

100

00:08:36.880  -->  00:08:37.030
and

101

00:08:37.290  -->  00:08:42.460
you might also need this if you're dynamically creating your property names for example

102

00:08:42.500  -->  00:08:49.480
then this might be another use case. So that's important to know, that property names can be both, like variables

103

00:08:49.480  -->  00:08:49.880
here,

104

00:08:49.890  -->  00:08:53.460
so just plain text or a string.

105

00:08:53.610  -->  00:09:01.800
Now if you want to print such a string property name, of course you can't use this because if I hit

106

00:09:01.800  -->  00:09:05.070
run now, it gives me an error

107

00:09:05.100  -->  00:09:10.480
because first it's now trying to do a subtraction here,

108

00:09:10.500  -->  00:09:11.890
so that's not working.

109

00:09:12.060  -->  00:09:18.320
So here you need to use square brackets syntax and then access it as a string,

110

00:09:18.330  -->  00:09:23.340
so first name, if I now hit run, you see Max.

111

00:09:23.340  -->  00:09:30.150
So this is how you access your string property names and how you set them and that's just an important

112

00:09:30.150  -->  00:09:34.200
addition to have at this point to understand how you can set up your objects.
