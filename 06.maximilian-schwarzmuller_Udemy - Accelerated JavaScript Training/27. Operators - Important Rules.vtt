WEBVTT
1

00:00:01.530  -->  00:00:03.160
Now here's an interesting check,

2

00:00:03.540  -->  00:00:12.510
if I check if not number equals not number, what do you think we'll get?

3

00:00:12.510  -->  00:00:14.640
We actually get false,

4

00:00:14.640  -->  00:00:16.050
now why is this the case,

5

00:00:16.050  -->  00:00:18.240
it clearly is the same, right?

6

00:00:18.330  -->  00:00:25.320
You would think like this but actually, there is a rule in Javascript and that rule simply says not

7

00:00:25.320  -->  00:00:25.990
a number

8

00:00:26.010  -->  00:00:27.680
is not like not a number.

9

00:00:27.930  -->  00:00:30.060
It's like that, it's a built-in rule,

10

00:00:30.060  -->  00:00:35.140
therefore if you check if both are not equal, you get true.

11

00:00:35.490  -->  00:00:39.930
As I said, a built-in Javascript rule specifying this.

12

00:00:39.930  -->  00:00:45.810
Now what do you think we'll get if I check if zero equals null?

13

00:00:46.410  -->  00:00:51.780
Because remember when we were doing calculations with null, it was treated like a zero.

14

00:00:51.780  -->  00:00:57.990
So since I'm not checking types but only if the value is the same, we would expect to get true here, right?

15

00:00:58.000  -->  00:00:58.470
Well

16

00:00:58.920  -->  00:01:02.470
let's see it, I get false

17

00:01:02.700  -->  00:01:09.590
and the reason for this is another rule in Javascript, null can't be compared is the rule,

18

00:01:09.930  -->  00:01:11.110
you can't compare

19

00:01:11.140  -->  00:01:18.450
null. You can check if a variable is null in an if condition, as I said, null is treated like false then

20

00:01:18.810  -->  00:01:24.040
but you can't compare anything to null and that's just another built-in rule.

21

00:01:24.180  -->  00:01:31.290
Now to make this even more confusing, what happens if I compare null to undefined and I did this before,

22

00:01:31.300  -->  00:01:31.330
so

23

00:01:31.350  -->  00:01:38.010
maybe you were scratching your head already because here, I get true and then right after, I said that

24

00:01:38.010  -->  00:01:40.190
null can't be compared.

25

00:01:40.430  -->  00:01:45.790
Well that's an exception from the rule, null can be compared to undefined,

26

00:01:45.960  -->  00:01:46.880
that's possible,

27

00:01:46.890  -->  00:01:48.900
that's the one exception.

28

00:01:49.050  -->  00:01:56.130
On the other hand, if I want to check if 0 is the same as undefined, what do you think I'll get here? I'll

29

00:01:56.130  -->  00:01:58.910
get false.

30

00:01:58.920  -->  00:02:04.450
The reason for this is that generally and this is the last Javascript rule

31

00:02:04.470  -->  00:02:07.330
I want to mention here, undefined

32

00:02:07.380  -->  00:02:16.370
compared to anything is always false except when comparing it to null.

33

00:02:16.500  -->  00:02:18.960
That is something you just have to keep in mind,

34

00:02:19.200  -->  00:02:28.410
null can't be compared, except with undefined and undefined will always return false except for when

35

00:02:28.410  -->  00:02:29.640
comparing it with

36

00:02:29.640  -->  00:02:38.250
null. That are simply the exceptions here but that are the general rules in Javascript and it's just

37

00:02:38.250  -->  00:02:40.090
important to keep this in mind,

38

00:02:40.110  -->  00:02:47.070
you probably won't compare any numbers with null that often but it's important to know how all of that

39

00:02:47.070  -->  00:02:48.510
works behind the scenes

40

00:02:48.660  -->  00:02:55.890
and that you got there was hardcoded rules which probably won't affect your day-to-day programming life

41

00:02:55.920  -->  00:02:58.720
that often but as I said, it's important to know.
