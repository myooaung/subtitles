WEBVTT
1
00:00:05.310 --> 00:00:07.060
Muy bien, entonces escribamos algunas funciones más.

2
00:00:07.690 --> 00:00:10.240
También quiero hablar un poco más sobre la declaración de devolución.

3
00:00:10.480 --> 00:00:13.210
Entonces nuestra próxima función será una que devuelva valor.

4
00:00:13.880 --> 00:00:18.700
Voy a usar el programa de juego de adivinanzas dot pi de la Sección cuatro de este video.

5
00:00:19.540 --> 00:00:24.220
Para hacer eso, lo que debemos hacer es abrir el Proyecto inteligente, Sección cuatro.

6
00:00:24.940 --> 00:00:26.650
Y puedes venir aquí para presentar.

7
00:00:28.270 --> 00:00:28.990
Recientemente abierto.

8
00:00:29.280 --> 00:00:31.180
Se llamaba flujo de programa, si recuerdas.

9
00:00:31.570 --> 00:00:32.260
Entonces lo abrí.

10
00:00:32.620 --> 00:00:35.620
Obtiene esta opción y hace clic en esta ventana o en una nueva ventana.

11
00:00:35.980 --> 00:00:40.930
Voy a hacer clic en tu ventana, lo que dejará el otro proyecto abierto también y bajaré aquí para

12
00:00:40.930 --> 00:00:41.950
adivinar el juego.

13
00:00:42.400 --> 00:00:42.990
Ven derecho.

14
00:00:43.390 --> 00:00:43.630
Correcto.

15
00:00:43.630 --> 00:00:44.020
Hacer clic.

16
00:00:44.830 --> 00:00:45.610
Haga clic en copiar.

17
00:00:46.140 --> 00:00:46.360
Peter

18
00:00:47.800 --> 00:00:48.220
Copiar.

19
00:00:49.300 --> 00:00:51.760
Puedo volver al otro proyecto haciendo clic en una ventana aquí arriba.

20
00:00:52.160 --> 00:00:53.550
Regrese a la introducción de funciones.

21
00:00:54.120 --> 00:00:59.620
Tengo que proyectar el dolor, asegurándome de que los proyectos seleccionados en la parte superior allí puedan pegar.

22
00:01:00.650 --> 00:01:05.270
Que tomaré una copia del juego de adivinanzas, obtuve un pastel del otro proyecto y lo pondré aquí.

23
00:01:06.480 --> 00:01:07.290
Haz clic en Refactor.

24
00:01:07.650 --> 00:01:08.980
Ahora tenemos una copia de besos.

25
00:01:09.390 --> 00:01:15.590
Voy a volver al otro proyecto ahora en el otro Proyecto Inteligente, Proyecto de Ropa Elegante.

26
00:01:16.950 --> 00:01:18.270
Y ahora volvemos a nuestras funciones.

27
00:01:18.930 --> 00:01:20.950
Así que abramos el juego de besos.

28
00:01:22.320 --> 00:01:27.970
Muy bien, entonces una pregunta que los estudiantes suelen hacer después de este ejemplo es cómo asegurarse de que

29
00:01:27.970 --> 00:01:32.800
la entrada del usuario sea numérica o los ejemplos anteriores se basan en una entrada válida.

30
00:01:33.010 --> 00:01:35.710
Si te gusta algo que no es un número, el programa se bloqueará.

31
00:01:36.190 --> 00:01:40.950
Lo ejecutaré para confirmar esto y enfatizaremos que esto no es numérico en mi nombre.

32
00:01:41.080 --> 00:01:41.470
Tim

33
00:01:43.060 --> 00:01:43.500
Bingo.

34
00:01:43.920 --> 00:01:44.520
Tenemos un accidente

35
00:01:44.580 --> 00:01:45.890
Tenemos una era en la línea 10.

36
00:01:45.960 --> 00:01:49.520
Como puede ver, no son válidos para int con base 10.

37
00:01:49.680 --> 00:01:54.780
Tim esencialmente ayata la cadena Tim, como viste en eso, no se puede convertir a un número.

38
00:01:55.270 --> 00:01:58.260
Lo que debo hacer con eso es manejar la excepción de error de valor.

39
00:01:58.830 --> 00:02:00.810
Veremos cómo hacerlo más adelante en el curso.

40
00:02:01.110 --> 00:02:02.940
En este momento estamos practicando funciones.

41
00:02:03.480 --> 00:02:05.490
Entonces, escriba una función para tratar este problema.

42
00:02:06.180 --> 00:02:09.000
Entonces, lo que voy a hacer es ponerlo al comienzo de la tarjeta después de la importación.

43
00:02:12.380 --> 00:02:16.440
Comencé en línea por dejar dos dos líneas en blanco entre la línea uno.

44
00:02:17.220 --> 00:02:21.340
Y en lo que estamos estamos donde estamos escribiendo la definición solo fuerza,

45
00:02:21.360 --> 00:02:26.550
pero la cena, la cena, la superación de la especia consiguen a Alesco entero y entre paréntesis, rápido.

46
00:02:28.230 --> 00:02:28.950
Y luego una columna.

47
00:02:30.690 --> 00:02:36.690
Antes de comenzar a escribir cualquier función, asegúrese de tener una idea clara de lo que va a hacer,

48
00:02:36.690 --> 00:02:40.350
nuestra función obtendrá información del usuario y devolverá un valor entero.

49
00:02:40.920 --> 00:02:46.530
Pero antes de que podamos escribir cualquier código, debemos decidir qué sucederá si el usuario no ingresa un número entero

50
00:02:46.530 --> 00:02:46.920
válido.

51
00:02:48.820 --> 00:02:50.110
Entonces, ¿qué opciones tenemos aquí?

52
00:02:50.980 --> 00:02:54.010
Bueno, para esta aplicación en particular, podríamos devolver cero.

53
00:02:54.690 --> 00:03:00.190
La tarjeta principal usa cero para terminar el programa si el usuario detiene la basura en lugar de un número.

54
00:03:00.700 --> 00:03:01.720
El programa terminaría.

55
00:03:02.170 --> 00:03:03.400
Entonces esa es una opción aquí.

56
00:03:03.880 --> 00:03:06.220
Probablemente no sea adecuado para todas las aplicaciones.

57
00:03:06.490 --> 00:03:08.020
Cero es un número válido después de todo.

58
00:03:08.770 --> 00:03:12.130
Otra opción es seguir pidiéndole al usuario que haga algo válido.

59
00:03:12.610 --> 00:03:14.290
Si ingresan algo que no es un número.

60
00:03:14.620 --> 00:03:16.900
La función puede aumentar y dejar que proporcionen datos nuevamente.

61
00:03:17.350 --> 00:03:18.760
Ese es el enfoque que voy a tomar aquí.

62
00:03:19.770 --> 00:03:21.410
Justo en la línea cinco van a la cima.

63
00:03:21.480 --> 00:03:22.290
Si bien es cierto.

64
00:03:24.980 --> 00:03:25.680
Capital T allí.

65
00:03:26.190 --> 00:03:26.580
Dentro.

66
00:03:27.350 --> 00:03:29.900
Así que seguiré en bucle y su entrada es válida.

67
00:03:30.680 --> 00:03:31.740
Todavía no tenemos ninguna entrada.

68
00:03:31.790 --> 00:03:34.970
Es por eso que he usado, si bien es cierto, saldrá del ciclo.

69
00:03:35.210 --> 00:03:36.470
Cuando lo hacen en algo válido.

70
00:03:37.070 --> 00:03:40.790
Entonces, a continuación, necesitamos obtener su entrada y verificar que se pueda convertir a un número.

71
00:03:41.300 --> 00:03:44.540
Así que voy a escribir temp es igual a input.

72
00:03:45.860 --> 00:03:47.120
Mensaje entre paréntesis.

73
00:03:48.750 --> 00:03:56.180
Y la siguiente parte superior del lamaísmo, si la parte superior de la punta es paréntesis numérico izquierdo o derecho en una columna.

74
00:03:57.120 --> 00:04:01.740
Luego devuelve la siguiente línea int paréntesis temp.

75
00:04:04.090 --> 00:04:09.840
Y tenemos dos leones negros, por lo que la cadena es un método numérico para asegurarse de que la cadena

76
00:04:09.840 --> 00:04:10.710
representa un número.

77
00:04:11.070 --> 00:04:14.010
Si lo hace, podemos convertirlo y devolverlo.

78
00:04:14.310 --> 00:04:15.390
Y lo estamos haciendo en la línea ocho.

79
00:04:15.670 --> 00:04:20.610
El retorno pisó la ejecución del curso de la línea ocho para abandonar la función y regresar a la siguiente instrucción en

80
00:04:20.610 --> 00:04:21.540
el código de llamada.

81
00:04:21.990 --> 00:04:24.700
Puede que no sea obvio, pero no hay necesidad de usar break aquí.

82
00:04:25.260 --> 00:04:27.510
El regreso hará que la billetera se detenga.

83
00:04:27.990 --> 00:04:29.340
Será cada código de disfunciones.

84
00:04:29.610 --> 00:04:35.730
Entonces, mientras el trabajo gira nuevamente, si no está seguro de eso, establezca un punto de interrupción en la línea ocho y ejecute el

85
00:04:35.730 --> 00:04:36.840
código en el depurador.

86
00:04:37.580 --> 00:04:40.240
Oh, esa es la primera vez que necesitamos llamar a esta función en nuestro código principal.

87
00:04:41.100 --> 00:04:43.510
Y mirando el coraje que puedes ver allí en la línea 18.

88
00:04:45.430 --> 00:04:49.640
Estamos recibiendo la entrada del usuario en este momento, estamos utilizando la función de entrada integrada.

89
00:04:50.180 --> 00:04:52.760
Podemos cambiar eso para llamar a nuestro nuevo kit a una función en su lugar.

90
00:04:53.600 --> 00:04:56.480
Así que vamos a hacer es cambiar la entrada int.

91
00:04:59.020 --> 00:05:00.040
Resulta para llegar.

92
00:05:01.250 --> 00:05:07.930
Alesco entero entre paréntesis, va a poner comillas dobles, dos puntos y un espacio en esas comillas dobles.

93
00:05:08.680 --> 00:05:13.990
Y ese es nuestro argumento inmediato de por qué el usuario verá que algo sucede cuando ingresa una entrada no

94
00:05:13.990 --> 00:05:14.290
válida.

95
00:05:14.880 --> 00:05:16.510
Eso será mucho más claro cuando ejecutemos el programa.

96
00:05:17.580 --> 00:05:18.360
Así que vamos a ejecutarlo.

97
00:05:21.030 --> 00:05:25.560
Entonces, recibimos el mensaje, adivine un número entre uno y 1000 y aparecerá un mensaje en la línea debajo

98
00:05:25.560 --> 00:05:26.500
de esa columna.

99
00:05:27.230 --> 00:05:28.770
Una conjetura 500 para empezar.

100
00:05:30.430 --> 00:05:36.280
Parece que funcionó y el programa me está pidiendo que aumente en función de los 500, por lo que en lugar de adivinar un

101
00:05:36.280 --> 00:05:38.290
número válido, voy a ingresar un texto.

102
00:05:38.350 --> 00:05:40.240
Este no es un número.

103
00:05:43.360 --> 00:05:45.330
Observe aquí que el programa no se bloquea, Neal.

104
00:05:45.730 --> 00:05:49.540
Obtenemos nuestro colon bombeado de nuevo y entran en una función, está esperando más información.

105
00:05:50.380 --> 00:05:51.010
Lo intentaré de nuevo.

106
00:05:51.070 --> 00:05:53.410
Tampoco es esto más texto.

107
00:05:54.490 --> 00:05:58.300
Y puede decir que recibimos nuestro mensaje presionando enter sin superar ninguna importación.

108
00:05:58.840 --> 00:05:59.930
También se comporta igual.

109
00:06:00.740 --> 00:06:04.670
Entonces es por eso que pasé a Cole en Spice como un indicador de la función.

110
00:06:04.790 --> 00:06:06.170
Puedes decir eso en la línea 18 allí.

111
00:06:06.710 --> 00:06:11.300
Sin eso, el usuario no obtiene ninguna indicación de lo que está sucediendo, lo que probablemente los confunda.

112
00:06:12.080 --> 00:06:15.890
Si lo desea, puede tener un mensaje dentro de la función diciéndoles que el valor que ingresaron no es

113
00:06:15.920 --> 00:06:16.760
un número válido.

114
00:06:17.120 --> 00:06:19.190
Eso suena como un buen desafío antes del próximo video.

115
00:06:19.780 --> 00:06:24.290
Entonces continuará haciendo eso hasta que ingrese un número que obtenga el valor correcto ahora porque podemos decir eso

116
00:06:24.290 --> 00:06:26.000
en la primera línea de la salida.

117
00:06:28.170 --> 00:06:28.810
Y eso se ve bien.

118
00:06:29.060 --> 00:06:33.870
Entrar en una función, parece estar funcionando y solo termina cuando ingresamos algo que se puede convertir en una

119
00:06:33.890 --> 00:06:34.410
TI.

120
00:06:34.740 --> 00:06:35.460
Eso es muy bonito.

121
00:06:36.150 --> 00:06:41.850
Siempre que nuestros programas necesiten que el usuario ingrese valores enteros, podemos usar nuestra función get integer en lugar de

122
00:06:41.850 --> 00:06:42.300
input.

123
00:06:43.230 --> 00:06:45.510
Bajar el curso verá otra forma de manejar esto.

124
00:06:46.020 --> 00:06:48.920
Lo necesitaremos antes de poder escribir una función para obtener un valor de coma flotante.

125
00:06:49.500 --> 00:06:52.290
Es numérico fallará si hay un punto decimal en la cadena.

126
00:06:52.620 --> 00:06:54.780
Por lo tanto, no es adecuado para valores de coma flotante.

127
00:06:55.650 --> 00:07:00.360
No hemos resuelto por completo el problema de obtener información numérica del usuario, pero ahora estamos a medio

128
00:07:00.360 --> 00:07:00.660
camino.

129
00:07:01.350 --> 00:07:04.230
Es posible que desee practicar el uso de esta función en los ejemplos anteriores.

130
00:07:04.860 --> 00:07:07.590
Observe cómo definimos al niño en la silla y se cierra.

131
00:07:10.100 --> 00:07:16.940
De vuelta aquí en la línea cuatro, especificamos un parámetro de solicitud que nos permite proporcionar una solicitud, al igual que podemos

132
00:07:16.940 --> 00:07:23.320
con una función de entrada incorporada, obtener Alesco Integer es casi un reemplazo directo ahora para la importación int entre

133
00:07:23.360 --> 00:07:27.230
paréntesis no es lo mismo porque debe especificar una cadena de solicitud.

134
00:07:27.620 --> 00:07:30.410
La función de entrada incorporada permite que la solicitud sea opcional.

135
00:07:30.900 --> 00:07:32.540
Eso es algo más que aprenderemos más adelante.

136
00:07:33.470 --> 00:07:39.140
Idealmente, pondríamos la función en su propio módulo para que pueda importarla a cualquier Pergament que lo necesite.

137
00:07:39.590 --> 00:07:40.610
Lo cubriremos más tarde.

138
00:07:41.060 --> 00:07:46.760
Hasta entonces, sin embargo, es necesario copiar y pegar la función en cualquier programa que la use para

139
00:07:46.760 --> 00:07:48.440
intentar modificar los programas anteriores.

140
00:07:48.890 --> 00:07:49.970
Entonces prueba este desafío.

141
00:07:51.990 --> 00:07:56.220
Entonces, el desafío es modificar la función entera del kit para que imprima un mensaje.

142
00:07:56.490 --> 00:07:57.910
Si el usuario lo ingresa no es válido.

143
00:07:58.060 --> 00:08:01.390
No, repasaré mi solución para esto en el próximo video.
