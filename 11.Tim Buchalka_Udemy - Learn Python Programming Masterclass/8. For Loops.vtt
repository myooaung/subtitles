WEBVTT
1
1

00:00:05.300  -->  00:00:08.470
So, it's now time to talk about for loops.
2

2

00:00:08.470  -->  00:00:10.720
So, one of the reasons that
computers are so useful,
3

3

00:00:10.720  -->  00:00:15.100
is that they can actually repeat an
operations multiple times, very quickly.
4

4

00:00:15.100  -->  00:00:19.510
And this of course, removes the need for
a human to perform a repetitive task.
5

5

00:00:19.510  -->  00:00:23.260
Now we've seen the For loop in earlier
examples, but now it's time to look at
6

6

00:00:23.260  -->  00:00:25.820
them in more detail and
actually explain what was happening.
7

7

00:00:25.820  -->  00:00:29.000
So, what a For loop does it actually
takes a range of values and
8

8

00:00:29.000  -->  00:00:31.670
assigns them one by one to a variable.
9

9

00:00:31.670  -->  00:00:34.510
It then executes a block of code once for
each value.
10

10

00:00:34.510  -->  00:00:38.190
For a simple example, we're gonna have
a go printing at the values from 1 to 20.
11

11

00:00:38.190  -->  00:00:42.950
So the format is type in the for,
12

12

00:00:42.950  -->  00:00:45.900
keyword for, i in range.
13

13

00:00:45.900  -->  00:00:48.750
1 comma 20 in brackets,
then we indent the code.
14

14

00:00:48.750  -->  00:00:52.490
This is the block that we want to
have executed once for each value.
15

15

00:00:52.490  -->  00:00:57.570
So print i is now, replacement field,
16

16

00:00:57.570  -->  00:01:05.760
this should be double quotes at the start. dot
format i, that's the simplest example.
17

17

00:01:05.760  -->  00:01:09.510
Again, what we're trying to do is go
to get the values from 1 to 20.
18

18

00:01:09.510  -->  00:01:11.990
And then when we run that,
you can see what happens is for
19

19

00:01:11.990  -->  00:01:16.520
each value of i, we've actually got the
value i is now one, two, three, four five,
20

20

00:01:16.520  -->  00:01:19.740
right through to 19, so
it didn't go through the 20.
21

21

00:01:19.740  -->  00:01:23.600
If you think back to this, remember
how our string slices that we used
22

22

00:01:23.600  -->  00:01:26.580
return the characters up to, but
not including, the N number?
23

23

00:01:26.580  -->  00:01:27.920
Well, ranges work in the same way.
24

24

00:01:27.920  -->  00:01:30.410
The last value specified is not included.
25

25

00:01:30.410  -->  00:01:34.670
So effectively, the way to rate is for
i in range (1-20).
26

26

00:01:34.670  -->  00:01:36.720
Would be to actually say to yourself,
27

27

00:01:36.720  -->  00:01:39.590
I'm going to actually loop
through the values 1 to 19.
28

28

00:01:39.590  -->  00:01:44.150
So the computer will actually repeat
this code in here in the block,
29

29

00:01:44.150  -->  00:01:48.260
in this case 19 times, and
incrementing the value of i each time.
30

30

00:01:48.260  -->  00:01:51.170
So the first time it runs,
you can see i was set to 1,
31

31

00:01:51.170  -->  00:01:55.570
i is set to 2, i is set to 3, and so
on and so forth, right through into 19.
32

32

00:01:55.570  -->  00:01:58.700
Now we're gonna talk more about
naming variables in a later video.
33

33

00:01:58.700  -->  00:02:01.580
Up until now we've just used simple
words that describe the value
34

34

00:02:01.580  -->  00:02:02.660
that we've been dealing with.
35

35

00:02:02.660  -->  00:02:05.110
And normally, you should avoid
using single character names for
36

36

00:02:05.110  -->  00:02:06.450
variables like we've got here, like I.
37

37

00:02:06.450  -->  00:02:10.760
Because I don't really give any
indication of what the variable is for,
38

38

00:02:10.760  -->  00:02:12.140
but there is an exception to that and
39

39

00:02:12.140  -->  00:02:16.780
loop control variables are one of those
few places where I and J are acceptable.
40

40

00:02:16.780  -->  00:02:18.690
I is taken to be short for index and
41

41

00:02:18.690  -->  00:02:22.160
the convention is that it's
acceptable name in a For loop.
42

42

00:02:22.160  -->  00:02:26.620
So when you are creating a For loop
like this, using I is quite okay and
43

43

00:02:26.620  -->  00:02:29.180
you find that there is a lot of code
out there that actually does that.
44

44

00:02:29.180  -->  00:02:30.160
So another example of this.
45

45

00:02:30.160  -->  00:02:34.320
We can actually see the variable uses an
index in the next example which I'm about
46

46

00:02:34.320  -->  00:02:38.190
to type out, where we print each
character in a string once at a time.
47

47

00:02:38.190  -->  00:02:40.470
So I'm going to actually just
put that on the next line.
48

48

00:02:40.470  -->  00:02:43.240
Being sure to go to the start of
the block and not to indent it.
49

49

00:02:43.240  -->  00:02:45.300
So we're gonna type in number.
50

50

00:02:45.300  -->  00:02:46.470
number= 9,223,372,036,854,775,807
51

51

00:02:46.470  -->  00:02:52.860
And what we're gonna do is gonna put for
52

52

00:02:52.860  -->  00:03:00.420
I in range 0 len, which stands for
length, number.
53

53

00:03:01.900  -->  00:03:05.900
Colon again, and
54

54

00:03:05.900  -->  00:03:11.330
print number, i in square brackets.
55

55

00:03:11.330  -->  00:03:14.220
There's a couple of things here,
we've introduced a new function.
56

56

00:03:14.220  -->  00:03:17.580
This function here is called len which
is an abbreviation for length and
57

57

00:03:17.580  -->  00:03:20.270
it actually returns
the length of a string.
58

58

00:03:20.270  -->  00:03:23.090
So, how many characters
actually exist in that string.
59

59

00:03:23.090  -->  00:03:26.430
So, in this case it should actually
return 25 if I'm counting correctly.
60

60

00:03:26.430  -->  00:03:30.980
But with that said, the way that we
actually access individual characters
61

61

00:03:30.980  -->  00:03:33.990
in a string,
they actually start from zero in
62

62

00:03:33.990  -->  00:03:38.420
this case to whatever the length
is minus one, so 24 in this case.
63

63

00:03:38.420  -->  00:03:41.330
And because we established earlier
that when we put a range in,
64

64

00:03:41.330  -->  00:03:44.390
we only go up into one less
than the final number,
65

65

00:03:44.390  -->  00:03:47.140
we know that in the case
the len(number) is gonna be correct.
66

66

00:03:47.140  -->  00:03:48.130
Cuz it's only gonna go through and
67

67

00:03:48.130  -->  00:03:51.640
process up to one less than that
final number in the For loop.
68

68

00:03:51.640  -->  00:03:54.320
So that's actually one of the reasons
why the range runs up to but
69

69

00:03:54.320  -->  00:03:56.200
not including the final value.
70

70

00:03:56.200  -->  00:03:59.150
So in many other programming languages,
the loop would have to be specified
71

71

00:03:59.150  -->  00:04:01.970
as from zero to, and
you might have to do something like this.
72

72

00:04:01.970  -->  00:04:04.910
Length, number, take one,
because you'd have to code it for
73

73

00:04:04.910  -->  00:04:08.010
the fact you're starting from zero,
and not starting from one,
74

74

00:04:08.010  -->  00:04:09.270
as you can see in the example up here.
75

75

00:04:09.270  -->  00:04:13.130
But in this case, with Python,
you don't actually have to do that,
76

76

00:04:13.130  -->  00:04:16.360
because of course we established
that when you use a range,
77

77

00:04:16.360  -->  00:04:19.440
it actually finishes at one less
than the number you specify anyway.
78

78

00:04:19.440  -->  00:04:22.770
Basically, it works more how you'd expect
and your free from having to consider
79

79

00:04:22.770  -->  00:04:25.960
whether you need to put this minus one and
other such trivia which is really cool.
80

80

00:04:25.960  -->  00:04:29.490
So if we actually run this now,
you can see what's happened here.
81

81

00:04:29.490  -->  00:04:30.960
Each time we've gone through the loop.
82

82

00:04:30.960  -->  00:04:34.890
It's actually printed out
one element of that string.
83

83

00:04:34.890  -->  00:04:36.530
And by using the square bracket,
84

84

00:04:36.530  -->  00:04:40.570
what that is saying is print
the character at position i.
85

85

00:04:40.570  -->  00:04:45.370
So we started on the first time position
i, i had the value of of zero, so
86

86

00:04:45.370  -->  00:04:47.730
position zero is nine.
87

87

00:04:47.730  -->  00:04:50.900
Next time I'm gonna go through and
position one is the comma, and so
88

88

00:04:50.900  -->  00:04:53.470
right through to the end and
we should have an 807 on the end there.
89

89

00:04:53.470  -->  00:04:56.650
The last three digits there, so,
you can see this is working quite nicely.
90

90

00:04:56.650  -->  00:04:58.170
And it didn't crash or
anything like that and
91

91

00:04:58.170  -->  00:04:59.650
actually come up with the right number.
92

92

00:04:59.650  -->  00:05:02.310
That's one example but
let's take this all to the next level.
93

93

00:05:02.310  -->  00:05:06.300
And let's just imagine that your
processing data at someone elses exported
94

94

00:05:06.300  -->  00:05:07.210
from a spread sheet program.
95

95

00:05:07.210  -->  00:05:11.310
And let's just say that the spreadsheet
was set to display numbers with commas or
96

96

00:05:11.310  -->  00:05:14.130
some other separators like in Europe for
example it could be a full stop or
97

97

00:05:14.130  -->  00:05:15.020
a space.
98

98

00:05:15.020  -->  00:05:16.690
Normally, before we could
process these numbers we
99

99

00:05:16.690  -->  00:05:19.620
would have to strip out the separators,
but there's other ways to do this.
100

100

00:05:19.620  -->  00:05:21.970
And one way could be to
check each character and
101

101

00:05:21.970  -->  00:05:24.440
only print it out if it's one
of the digits from zero to nine.
102

102

00:05:24.440  -->  00:05:26.790
So what we could do is
actually take this code again.
103

103

00:05:26.790  -->  00:05:27.710
I'm just gonna copy that.
104

104

00:05:27.710  -->  00:05:30.420
And paste it down here.
105

105

00:05:30.420  -->  00:05:33.900
We leave the same for range in here,
but we add another test here.
106

106

00:05:33.900  -->  00:05:41.050
And the test we're gonna add is
if number i, in square brackets,
107

107

00:05:41.050  -->  00:05:46.260
in a string, one, two, three,
four, five, six, seven, eight, nine.
108

108

00:05:46.260  -->  00:05:48.980
That's the case, and then we come back
onto the print line, and then we actually
109

109

00:05:48.980  -->  00:05:53.260
indent that because we only want that
executed, if this actually returns true.
110

110

00:05:53.260  -->  00:05:57.350
So, if you remember the in function, it
returns true if whatever we're testing on
111

111

00:05:57.350  -->  00:06:00.570
the left hand side is actually in
whatever is in the right hand side.
112

112

00:06:00.570  -->  00:06:03.880
So, in this case we're looking for
the element in this case nine.
113

113

00:06:03.880  -->  00:06:07.150
And as you get that nine, yes,
it's going to actually print that out.
114

114

00:06:07.150  -->  00:06:09.900
So, what this should do is actually go
through and print all the numbers and
115

115

00:06:09.900  -->  00:06:11.660
it should actually skip the commas.
116

116

00:06:11.660  -->  00:06:13.730
Cuz of course,
a comma is not actually in this string.
117

117

00:06:13.730  -->  00:06:15.250
So, let's just run that and
see if it works.
118

118

00:06:17.170  -->  00:06:22.810
And what we should probably
do is just to make sure,
119

119

00:06:22.810  -->  00:06:26.070
we'll just comment that out for
now, and run that again.
120

120

00:06:26.070  -->  00:06:29.220
And you can see that it's now
successfully 9223372036854775807.
121

121

00:06:29.220  -->  00:06:34.290
So it successfully skipped anything
that wasn't a digit from 0 to 9.
122

122

00:06:34.290  -->  00:06:37.760
Now one of the disadvantages with that
is you notice that when using the print,
123

123

00:06:37.760  -->  00:06:41.000
automatically Python's actually
adding the end of line character.
124

124

00:06:41.000  -->  00:06:43.060
So it's actually starting on a new line.
125

125

00:06:43.060  -->  00:06:46.090
So we can actually stop that if we want
though, because it actually syntax.
126

126

00:06:46.090  -->  00:06:48.510
So you may actually seen
this when you actually
127

127

00:06:48.510  -->  00:06:50.950
typing a comma after number, so I'll go back
and enter a comma there.
128

128

00:06:52.050  -->  00:06:53.500
And notice how this comes
up automatically and
129

129

00:06:53.500  -->  00:06:55.740
IntelliJ is saying there's
some other options here.
130

130

00:06:55.740  -->  00:07:00.160
And by default,
end=\n which is a new line character.
131

131

00:07:00.160  -->  00:07:03.320
So that's what happens automatically and
that consequently each number,
132

132

00:07:03.320  -->  00:07:05.190
each time it's hitting
a number in the loop.
133

133

00:07:05.190  -->  00:07:07.910
When we're doing the print,
it's actually skipping to the next line.
134

134

00:07:07.910  -->  00:07:10.280
So we'll be providing
of course to first parameter,
135

135

00:07:10.280  -->  00:07:13.240
which is obviously the object
that we want printed.
136

136

00:07:13.240  -->  00:07:17.380
But as you can see in the screen, we can
also specify separator and a value for end.
137

137

00:07:17.380  -->  00:07:20.180
So we're gonna come back to separators, and
the last two options file and
138

138

00:07:20.180  -->  00:07:23.900
flush will be covered when we talk
about file IO in a later video.
139

139

00:07:23.900  -->  00:07:25.900
But the end parameter is the one
that's interesting here.
140

140

00:07:25.900  -->  00:07:29.660
Cuz at the moment you can see that it
defaults again, to \n, which is new line.
141

141

00:07:29.660  -->  00:07:32.620
But we can actually override that,
so for example, if we set that
142

142

00:07:32.620  -->  00:07:36.870
to an empty string, then a new line's not
gonna be started after each character.
143

143

00:07:36.870  -->  00:07:41.590
So what we could do is we could
type something like end = '',
144

144

00:07:41.590  -->  00:07:44.480
and that's overwriting
the standard n = '\n'.
145

145

00:07:44.480  -->  00:07:48.150
And what we should see when
we run it is the numbers
146

146

00:07:48.150  -->  00:07:49.240
now appearing from left to right.
147

147

00:07:49.240  -->  00:07:51.870
Because there's not a new line being
automatically added each time
148

148

00:07:51.870  -->  00:07:52.590
the printout's made.
149

149

00:07:52.590  -->  00:07:57.100
Now if we wanted to use a number that
we come up for performing calculations.
150

150

00:07:57.100  -->  00:08:00.610
What we could do is we can concatenate
each character onto the new string and
151

151

00:08:00.610  -->  00:08:03.100
then convert the final
string to an integer.
152

152

00:08:03.100  -->  00:08:06.020
So, we have to initialize a string
variable to hold the digits first or
153

153

00:08:06.020  -->  00:08:07.130
Python will give an error.
154

154

00:08:07.130  -->  00:08:10.910
Because it obviously won't know if a plus
should attempt to perform an addition or
155

155

00:08:10.910  -->  00:08:11.750
concatenation.
156

156

00:08:11.750  -->  00:08:16.390
So the way we do that is we come back
up here and we'll type something like
157

157

00:08:16.390  -->  00:08:21.580
cleanedNumber = '', so
that's what we're gonna start with.
158

158

00:08:21.580  -->  00:08:23.220
We're gonna leave the loop
as it was before.
159

159

00:08:23.220  -->  00:08:25.300
We're gonna leave the if there as well.
160

160

00:08:25.300  -->  00:08:27.570
But instead of printing out at this point,
161

161

00:08:27.570  -->  00:08:32.750
what we're in fact going to do is we're
gonna type cleanedNumber = cleanedNumber
162

162

00:08:32.750  -->  00:08:38.370
+ number[i], I'm gonna rid of that print.
163

163

00:08:38.370  -->  00:08:40.970
Now back to the left, so it's gonna go
through and each time it finds a number.
164

164

00:08:40.970  -->  00:08:44.860
It's gonna add only that digit to the
cleaned number string that we've actually
165

165

00:08:44.860  -->  00:08:45.610
defined on line nine.
166

166

00:08:45.610  -->  00:08:49.110
So now what we want to do is
convert that to an integer.
167

167

00:08:49.110  -->  00:08:54.030
So we type newNumber = int(cleanedNumber)
168

168

00:08:55.540  -->  00:08:56.700
And I could type something like print,
169

169

00:08:56.700  -->  00:09:00.330
because as far as Python's
concerned this is now a number. print(
170

170

00:09:00.330  -->  00:09:06.320
"The number is".format(newNumber))
171

171

00:09:06.320  -->  00:09:07.190
So if we run this.
172

172

00:09:08.280  -->  00:09:11.300
We get the number is 92 blah,
blah, blah, blah, blah 807.
173

173

00:09:11.300  -->  00:09:14.110
So as far as Python'ss concerned
that is now a proper number.
174

174

00:09:14.110  -->  00:09:17.120
So that's how you'd actually go
about converting from a string and
175

175

00:09:17.120  -->  00:09:20.110
then actually building up a number
that's actually in a string.
176

176

00:09:20.110  -->  00:09:22.460
And then converting that
string back to an integer.
177

177

00:09:22.460  -->  00:09:26.100
Thing here is that, you need to actually
be very careful with your indentation,
178

178

00:09:26.100  -->  00:09:29.000
because we're nesting blocks within
blocks and the For loop contains an
179

179

00:09:29.000  -->  00:09:32.460
if block, which contains the block
that performs the concatenation.
180

180

00:09:32.460  -->  00:09:37.620
So, if line 15 is actually indented by 4 or 8
spaces, then the code's still gonna work,
181

181

00:09:37.620  -->  00:09:39.950
but newNumber's gonna be assigned
a value each time through the loop.
182

182

00:09:39.950  -->  00:09:43.690
So, in other words if I actually tab that,
like so,
183

183

00:09:44.970  -->  00:09:47.960
actually run this and
we still go the same result.
184

184

00:09:47.960  -->  00:09:51.830
But what's actually happened here
is each time in this loop new
185

185

00:09:51.830  -->  00:09:54.020
Number's been assigned that value.
186

186

00:09:54.020  -->  00:09:55.020
And it doesn't make, it's not
187

187

00:09:55.020  -->  00:09:57.660
really, it's not a really problem here when
you've only got a few numbers to deal with.
188

188

00:09:57.660  -->  00:10:01.620
If you can imagine that if we had
10,000 numbers to actually deal with.
189

189

00:10:01.620  -->  00:10:04.470
You're actually repeating this assignment,
of
190

190

00:10:04.470  -->  00:10:09.000
the value int(cleanedNumber) each time we
actually run, so it's a lot processing.
191

191

00:10:09.000  -->  00:10:11.690
So, the end result could be
significant delays you're introducing,
192

192

00:10:11.690  -->  00:10:13.840
even if the final answer,
as you saw, was still correct.
193

193

00:10:13.840  -->  00:10:17.660
So, in this case, it's far better
to actually have that calculation
194

194

00:10:17.660  -->  00:10:21.550
do occur only once, and that's after
you've been through the entire for loop.
195

195

00:10:21.550  -->  00:10:25.570
and we built up the entire cleanedNumber string
performed only once
196

196

00:10:25.570  -->  00:10:28.160
as opposed to actually performing
it each time through the loop.
197

197

00:10:28.160  -->  00:10:31.110
Now, note this is a specific example.
198

198

00:10:31.110  -->  00:10:33.250
Where our orignal number came
from a spreadsheet program.
199

199

00:10:33.250  -->  00:10:35.400
We knew that it was a valid number.
200

200

00:10:35.400  -->  00:10:38.700
Just, you know they happen to
contain some extraneous formatting.
201

201

00:10:38.700  -->  00:10:41.200
So this code that we've actually written,
wouldn't be suitable for
202

202

00:10:41.200  -->  00:10:44.440
validating numbers that had been
typed on the keyboard, for example.
203

203

00:10:44.440  -->  00:10:47.710
And also it wouldn't be suitable if
the spreadsheet contains scientific data,
204

204

00:10:47.710  -->  00:10:51.040
where the numbers could be in
an exponential or scientific format,
205

205

00:10:51.040  -->  00:10:53.110
such as 1.353e+18.
206

206

00:10:53.110  -->  00:10:58.200
So we're gonna be looking at catering
both of those or catering for
207

207

00:10:58.200  -->  00:11:00.420
both those situations in future videos.
208

208

00:11:00.420  -->  00:11:01.520
So I'm gonna end this video here.
209

209

00:11:01.520  -->  00:11:04.530
In the next video, we're gonna continue
with our discussion on four loops.
210

210

00:11:04.530  -->  00:11:05.870
So I'll see you in that next video.
