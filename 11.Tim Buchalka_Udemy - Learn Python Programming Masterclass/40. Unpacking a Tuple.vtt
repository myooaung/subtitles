WEBVTT
1

00:00:04.670  -->  00:00:10.070
So let's talk about unpacking tuples.
Earlier in this section, when we were

2

00:00:10.070  -->  00:00:14.629
looking at lists, I bound several
variables to the same value, using a

3

00:00:14.629  -->  00:00:18.800
single assignment. So let's have a go at
doing something similar. So we're going

4

00:00:18.800  -->  00:00:27.380
to create a new Python file - I'm going
to call it unpacking.

5

00:00:27.380  -->  00:00:38.340
The code was something like this in that previous
section: a = b = c = d = e = f = 12.

6

00:00:38.340  -->  00:00:42.880
Then we'll print the value of c.

7

00:00:42.880  -->  00:00:48.260
All six variables are now
bound to the same value - 12 in this case.

8

00:00:48.260  -->  00:00:52.550
If we run the program now, we just want to
confirm that c has the value 12, and we

9

00:00:52.550  -->  00:00:57.350
can see that is the case on screen. So
that's a useful shortcut, or shorthand,

10

00:00:57.350  -->  00:01:01.460
for typing in the full amount of
code. It also makes it easier to make

11

00:01:01.460  -->  00:01:05.320
changes, without the risk that you'd
forget to change one of the variables.

12

00:01:05.320  -->  00:01:09.320
Let's say that the value of 12 needs to
be changed, for whatever reason. With the

13

00:01:09.320  -->  00:01:12.770
assignment all in one line, as we've got on
line one, we only need to make the change

14

00:01:12.770  -->  00:01:18.680
in one place, so we change the value of
12 to 42. If we'd used six separate

15

00:01:18.680  -->  00:01:23.860
assignments, I'd have to make the change
in six places. Python also lets us bind

16

00:01:23.860  -->  00:01:28.280
several variables to different values. In
fact, we've already done that, when we

17

00:01:28.280  -->  00:01:32.520
looked at the enumerate function, earlier.
So let's start, now, with a simple example,

18

00:01:32.520  -->  00:01:36.600
before we go back and look at
that enumerate code. So down on line 4,

19

00:01:36.600  -->  00:01:44.180
I'm going to type x comma y equals 1
comma 2. Let's print out the value of x,

20

00:01:44.180  -->  00:01:52.369
and also the value of y. So run the
program, and we can see there, that x is bound

21

00:01:52.369  -->  00:01:58.160
to the value 1 and y is bound to the
value 2. And you're not restricted to just two values.

22

00:01:58.160  -->  00:02:03.860
We could add z if we wanted to,
there, as well. So put a comma z there,

23

00:02:03.860  -->  00:02:10.860
and also add the value 76.
Let's do that and print out z.

24

00:02:11.800  -->  00:02:20.330
Run - we also get 76 printed out. So this
is called unpacking a tuple and is very

25

00:02:20.330  -->  00:02:25.220
useful in all sorts of situations.
Looking at that code on line four,

26

00:02:25.220  -->  00:02:29.520
those three values on the right hand side,
look suspiciously like a tuple.

27

00:02:29.520  -->  00:02:37.600
That's because they are a tuple. Let's write
that code differently. So I'm going to

28

00:02:37.610  -->  00:02:45.680
type on line 9, print parentheses double
quotes, unpacking a tuple. Line 11, I'm

29

00:02:45.680  -->  00:02:52.580
going to type data equals 1 comma 2
comma 76 - just a comment here, that

30

00:02:52.580  -->  00:03:02.120
data represents a tuple. Then on
the next time we're gonna type x, y, z

31

00:03:02.120  -->  00:03:06.140
is equal to data. Then we can print
out the values of x, y and z and I'll

32

00:03:06.140  -->  00:03:10.130
just take a copy of those three lines,
that we used previously, and paste them

33

00:03:10.130  -->  00:03:16.310
down here. Run the program, and we should
see we get the same output. And you can

34

00:03:16.310  -->  00:03:21.740
see that is the case. On line 12, the
three variables, x y and z, get each of the

35

00:03:21.740  -->  00:03:26.700
values from the data tuple. Data on the
right hand side, is bound to a tuple.

36

00:03:26.700  -->  00:03:32.520
We did that on line 11. The three variables
on the left hand side also look like a tuple,

37

00:03:32.520  -->  00:03:36.920
but they're not. They're three
separate variables, that each get a value

38

00:03:36.920  -->  00:03:41.460
from the data tuple. You can't have a
tuple on the left of an assignment,

39

00:03:41.460  -->  00:03:45.460
because tuples, if you recall, are
immutable. Alright, so we'll finish this

40

00:03:45.470  -->  00:03:49.370
lecture with the second advantage of
using a tuple. When I used the phrase,

41

00:03:49.370  -->  00:03:53.630
unpacking a tuple, a few moments ago, I
didn't mention that you can unpack any

42

00:03:53.630  -->  00:04:02.000
sequence type. Let's see an example of
that. On line 17, I'm going to type print

43

00:04:02.000  -->  00:04:11.540
parentheses double quotes, Unpacking a
list. And the code itself, we're going to type

44

00:04:11.540  -->  00:04:18.600
data_list is equal to, in
square brackets, it's going to be 12, 13,  14

45

00:04:18.600  -->  00:04:24.220
in the square brackets, and
on the next line, I'm going to type p, q, r

46

00:04:24.220  -->  00:04:32.420
equals data_ list. Let's print put the values of p, q and r.

47

00:04:32.420  -->  00:04:37.680
on lines 21 to 23. So data_list, on line 19,

48

00:04:37.680  -->  00:04:42.020
is a list. It contains three items and
we can unpack them into three variables,

49

00:04:42.020  -->  00:04:46.820
as we're doing here; p, q and r. That's on
line 20. Run the program and let's

50

00:04:46.820  -->  00:04:51.580
confirm that that works. You can see
that's working fine, so we can unpack

51

00:04:51.580  -->  00:04:56.600
the values from any sequence type. But
lists are mutable, so if something

52

00:04:56.600  -->  00:05:01.250
changes the list, our code will break. You
might create a list in one part of your

53

00:05:01.250  -->  00:05:05.690
code, then attempt to unpack it in
another part. If you append another item

54

00:05:05.690  -->  00:05:10.010
to the list before then, the code will
crash. We can demonstrate that quite

55

00:05:10.010  -->  00:05:18.710
easily. Let's add some code. We'll add it
down here, on line 20. So I'm gonna type

56

00:05:18.710  -->  00:05:25.380
data_list.append, and in parentheses, 15,

57

00:05:25.380  -->  00:05:31.600
and put a space there for readability purposes. Now if we run this,

58

00:05:31.600  -->  00:05:36.139
it's crashed, as you can see. So the error
happened on line 22, and it actually says,

59

00:05:36.139  -->  00:05:41.330
too many values to unpack, expected
3. Line 22 is where we tried to

60

00:05:41.330  -->  00:05:46.550
unpack the list into three variables, but
the list now contains four items and our

61

00:05:46.550  -->  00:05:51.840
code crashed, as a result. If we'd used a
tuple instead of a list, that couldn't happen,

62

00:05:51.840  -->  00:05:57.000
and the reason for that is tuples
are immutable and you can't append items to a tuple.

63

00:06:15.440  -->  00:06:19.080
These examples have been very simple,
and don't really show just how useful

64

00:06:19.080  -->  00:06:23.200
unpacking a tuple might be. I'll stop
the video here and in the next video,

65

00:06:23.200  -->  00:06:27.380
we'll see some more practical
applications for unpacking tuples.

66

00:06:27.380  -->  00:06:30.400
See you in the next video.
