WEBVTT
1
1

00:00:05.420  -->  00:00:09.130
So in this video we're going to
do some writing to text files.
2

2

00:00:09.130  -->  00:00:12.260
So obviously in the previous video
we covered reading from them.
3

3

00:00:12.260  -->  00:00:15.380
So I'm still in the same project
that I used for the last video and
4

4

00:00:15.380  -->  00:00:18.090
we are going to create a new path file.
5

5

00:00:21.630  -->  00:00:26.320
I'm just going to call this "writing." So
the process of
6

6

00:00:26.320  -->  00:00:30.470
writing data to a text file is
very similar to reading from it.
7

7

00:00:30.470  -->  00:00:34.820
The files opened but this time the mode
is w from write instead of r for
8

8

00:00:34.820  -->  00:00:38.870
read which we saw previously Now
the actual data is written using the print
9

9

00:00:38.870  -->  00:00:42.910
function exactly as you want to
display it on the screen but
10

10

00:00:42.910  -->  00:00:47.040
only this time we specify a file object
to send it to and it goes to the file.
11

11

00:00:47.040  -->  00:00:50.570
And finally it's very important to
close the file when you're finished and
12

12

00:00:50.570  -->  00:00:54.050
once again we can use which we
looked at in the previous video so
13

13

00:00:54.050  -->  00:00:55.470
we don't have to remember
to do that ourselves.
14

14

00:00:55.470  -->  00:00:57.570
So, let's start talking some code.
15

15

00:00:57.570  -->  00:01:00.010
We're going to start with cities.
16

16

00:01:00.010  -->  00:01:02.150
So, cities equals LA.
17

17

00:01:04.620  -->  00:01:06.470
Alice Springs.
18

18

00:01:08.940  -->  00:01:09.860
Darwin.
19

19

00:01:12.330  -->  00:01:13.710
Melbourne.
20

20

00:01:16.180  -->  00:01:17.560
And Sydney.
21

21

00:01:18.780  -->  00:01:22.190
And we're going to type with open
22

22

00:01:22.190  -->  00:01:28.810
cities.txt for write,
so using a W this time.
23

23

00:01:29.910  -->  00:01:36.140
S City and
then we can type four city in cities,
24

24

00:01:36.140  -->  00:01:41.810
print city, and
here's a different bit now.
25

25

00:01:41.810  -->  00:01:44.900
File equals City underscore file so
26

26

00:01:44.900  -->  00:01:49.960
instead of just having it print by itself
we're adding the file part of the line
27

27

00:01:49.960  -->  00:01:53.520
which indicates that we want
to write this to a text file.
28

28

00:01:53.520  -->  00:01:56.400
And again because we're using
with here on line three
29

29

00:01:56.400  -->  00:01:58.710
we don't have to close the file ourself.
30

30

00:01:58.710  -->  00:02:01.110
So if we go to our folder and
we just open that up.
31

31

00:02:02.870  -->  00:02:06.260
So we're going to go to our
folder that contains the code.
32

32

00:02:06.260  -->  00:02:15.010
It's it's this one here you can see the
sample dot txt from the previous video.
33

33

00:02:15.010  -->  00:02:20.870
So if I did run this and
whoops, I run this by default,
34

34

00:02:20.870  -->  00:02:25.620
which choose the file I I need to actually
right-click it and run it the first time.
35

35

00:02:25.620  -->  00:02:30.680
So nothing appeared in the console output
but if we go back to our folder We can see
36

36

00:02:30.680  -->  00:02:34.550
this now, cities.text has been created and
we'll have a look at that, double click.
37

37

00:02:34.550  -->  00:02:38.710
You see you've got the five
cities that I typed originally in
38

38

00:02:38.710  -->  00:02:41.960
the source code on line one.
39

39

00:02:41.960  -->  00:02:43.260
So you now know what this parameter was.
40

40

00:02:43.260  -->  00:02:46.400
I know we talked about that very
briefly once in the course.
41

41

00:02:46.400  -->  00:02:48.110
You can now see how that's used.
42

42

00:02:48.110  -->  00:02:49.350
Now another thing you
might have noticed here,
43

43

00:02:49.350  -->  00:02:53.570
because we're using the default folder,
cities.txt appeared here as well, so
44

44

00:02:53.570  -->  00:02:56.840
intellijack picked up the fact that
there was a file in its folder, and
45

45

00:02:56.840  -->  00:03:00.020
it enables you to actually view in
that as well, which is pretty handy.
46

46

00:03:00.020  -->  00:03:03.810
And when you specify right mode the file
will be, will be created as be solvent
47

47

00:03:03.810  -->  00:03:07.880
doesn't everything exist, but important
if it does exist it will be overwritten.
48

48

00:03:07.880  -->  00:03:11.310
Now incidentally there's a slight auditiy
about the path and convention for
49

49

00:03:11.310  -->  00:03:13.910
the spaces around operators here.
50

50

00:03:13.910  -->  00:03:16.560
Now normally you'd put a space
either side of the equals symbol and
51

51

00:03:16.560  -->  00:03:21.080
in a silent operation And it tells you
correctly warns you if you forget, but
52

52

00:03:21.080  -->  00:03:24.540
when using named parameters and function
calls, the spaces are frowned upon,
53

53

00:03:24.540  -->  00:03:27.590
and you get a warning if you put
them around the equals here.
54

54

00:03:27.590  -->  00:03:30.230
In fact, equals here is not
actually the assignment operation.
55

55

00:03:30.230  -->  00:03:34.270
But it's used to provide a named
argument in place of the file parameter.
56

56

00:03:34.270  -->  00:03:36.220
So in other words if I do something here.
57

57

00:03:36.220  -->  00:03:37.760
We got a warning here.
58

58

00:03:37.760  -->  00:03:38.390
Now in line.
59

59

00:03:38.390  -->  00:03:39.290
That's fine.
60

60

00:03:39.290  -->  00:03:42.610
Put that there to get rid of that.
61

61

00:03:42.610  -->  00:03:46.970
But if we put a space here and
here we'll actually get
62

62

00:03:46.970  -->  00:03:51.780
a realwaring unexpected spaces around
key word slash parameters values.
63

63

00:03:51.780  -->  00:03:56.140
So On the we need to not
have spaces to avoid that
64

64

00:03:56.140  -->  00:03:58.240
error which I know is a little bit weird.
65

65

00:03:58.240  -->  00:04:02.490
So just to confirm the equals here in
this particular case is normally used for
66

66

00:04:02.490  -->  00:04:05.590
the and we put eye equals five but there.
67

67

00:04:05.590  -->  00:04:09.620
But here its not actually
in the operation but
68

68

00:04:09.620  -->  00:04:13.190
it's used to provide a name document
In place of the file parameter.
69

69

00:04:13.190  -->  00:04:17.530
So in other words, city_file is
the parameter, it's a named argument.
70

70

00:04:17.530  -->  00:04:20.610
Now we saw another named argument earlier
in the print statement when we passed and
71

71

00:04:20.610  -->  00:04:23.450
equals in two single quotes, and
we'll be looking at functions and
72

72

00:04:23.450  -->  00:04:25.520
parameters in more detail
later in the course.
73

73

00:04:25.520  -->  00:04:29.830
So just for now, humor IntelliJ,
remove the spaces around the equal
74

74

00:04:29.830  -->  00:04:33.580
When specifying named arguments
like we've done in line five.
75

75

00:04:33.580  -->  00:04:39.140
Now before we leave named arguments print
argument that can be set to true or false.
76

76

00:04:39.140  -->  00:04:42.100
And the false is false so
data isn't flushed.
77

77

00:04:42.100  -->  00:04:43.360
Now to understand what this is for
78

78

00:04:43.360  -->  00:04:46.630
we have to look a little bit in more
detail about what is happening.
79

79

00:04:46.630  -->  00:04:48.990
When Python writes data to a file.
80

80

00:04:48.990  -->  00:04:52.810
Now, external devices on your
computer including the screen
81

81

00:04:52.810  -->  00:04:55.130
are much slower than computer memory.
82

82

00:04:55.130  -->  00:04:58.770
So, running with things like disc
drives in the screen is buffered.
83

83

00:04:58.770  -->  00:05:02.510
So what that means is that the data
is actually written to a buffer, and
84

84

00:05:02.510  -->  00:05:06.270
the contents of that buffer is transferred
to the external device in the background.
85

85

00:05:06.270  -->  00:05:10.640
So it's something that happens,
While you're sort of doing something else.
86

86

00:05:10.640  -->  00:05:14.600
This allows the program to continue
processing without waiting for
87

87

00:05:14.600  -->  00:05:15.940
the write to complete.
88

88

00:05:15.940  -->  00:05:17.400
And so, everything seems much faster.
89

89

00:05:17.400  -->  00:05:22.340
So in other words, as soon as we run
this program, Once the process finished,
90

90

00:05:22.340  -->  00:05:25.730
at that point it may still be writing
something in the background to that file.
91

91

00:05:25.730  -->  00:05:27.230
Now this, obviously an example,
92

92

00:05:27.230  -->  00:05:30.210
you have five words that
would have been pretty quick.
93

93

00:05:30.210  -->  00:05:33.000
But you can imagine like a huge
file writing that was perhaps many
94

94

00:05:33.000  -->  00:05:34.130
megabytes long.
95

95

00:05:34.130  -->  00:05:36.440
It does take the computer
some time to process.
96

96

00:05:36.440  -->  00:05:40.630
And that's because it is putting
in that buffer It all then
97

97

00:05:40.630  -->  00:05:44.410
comes down to the speed of the device
that you're writing the information to.So
98

98

00:05:44.410  -->  00:05:47.840
essentially it means that the data is
actually written to the buffer and then
99

99

00:05:47.840  -->  00:05:51.280
the contents of the buffer is transferred
to the external device in the background.
100

100

00:05:51.280  -->  00:05:52.360
And again, we're doing that or
101

101

00:05:52.360  -->  00:05:54.950
it happens automatically to
allow the program to continue.
102

102

00:05:54.950  -->  00:05:58.170
Without waiting for
that write process to complete.
103

103

00:05:58.170  -->  00:06:01.620
Sometimes though with that said, you want
the data to be written out immediately.
104

104

00:06:01.620  -->  00:06:03.960
So especially if the external
device is a screen, and
105

105

00:06:03.960  -->  00:06:06.400
you want the user to be able to
see the output straight away.
106

106

00:06:06.400  -->  00:06:09.480
So with buffering, data could be sent
to the screen from the buffer for
107

107

00:06:09.480  -->  00:06:13.790
example, and then immediately overwritten
by subsequent data from the buffer.
108

108

00:06:13.790  -->  00:06:16.470
So this wouldn't be apparent
in our example so far.
109

109

00:06:16.470  -->  00:06:19.650
Because it already using relatively
small amounts of data but
110

110

00:06:19.650  -->  00:06:22.490
displaying the last on the screen
could suffer from that effect.
111

111

00:06:22.490  -->  00:06:26.410
As the scrolls up the screen
lines of text appear to flicker.
112

112

00:06:26.410  -->  00:06:30.650
Now, closing a file causes the buffer
to be flushed automatically.
113

113

00:06:30.650  -->  00:06:32.620
But if you wanna ensure
your data's written sooner,
114

114

00:06:32.620  -->  00:06:37.480
you can pass flush equals true to cause
the data to be written immediately.
115

115

00:06:37.480  -->  00:06:40.410
Generally though with that said, it's not
something you'd, you really should worry
116

116

00:06:40.410  -->  00:06:44.110
about, but the ability to control
it through a window is important
117

117

00:06:44.110  -->  00:06:49.470
enough that the benefits Python introduced
the flash parameter in Python three.
118

118

00:06:49.470  -->  00:06:53.370
Remembering that with that said that
Python was but Python three was released
119

119

00:06:53.370  -->  00:06:58.020
in 2008, and although they may not seem
very a longer time ago A modern computer
120

120

00:06:58.020  -->  00:07:02.860
is three times as fast as they were
then and interestingly enough a modern
121

121

00:07:02.860  -->  00:07:07.380
mobile phone more than likely has a faster
processor than a 2008 desktop computer.
122

122

00:07:07.380  -->  00:07:11.650
So things have come a long way and
the point we're making here is
123

123

00:07:11.650  -->  00:07:14.650
you probably generally speaking don't
need to use the first parameter.
124

124

00:07:14.650  -->  00:07:16.870
But it's there if you decide to use it.
125

125

00:07:16.870  -->  00:07:24.340
So you go about doing something
like flash equals true.
126

126

00:07:24.340  -->  00:07:26.960
That's actually how you do it if you
wanted to actually use that flush command.
127

127

00:07:26.960  -->  00:07:31.510
And generally we don't recommend
that you need to do that for
128

128

00:07:31.510  -->  00:07:33.760
most of the situations.
129

129

00:07:33.760  -->  00:07:36.880
So okay data from the last video.
130

130

00:07:36.880  -->  00:07:40.350
And we've now seen how to write our
little file worked earlier in this video.
131

131

00:07:40.350  -->  00:07:43.560
But before we move on it's probably
useful to see if we can read back
132

132

00:07:43.560  -->  00:07:44.760
the data we've just written.
133

133

00:07:44.760  -->  00:07:48.580
So let's that bit out, because
we've already now written the data.
134

134

00:07:50.690  -->  00:07:52.920
We don't need to call them again
because the file already exists so
135

135

00:07:52.920  -->  00:07:55.590
we're going to start with an empty list.
136

136

00:07:58.070  -->  00:08:05.780
And with open, with open cities.txt for
137

137

00:08:05.780  -->  00:08:10.700
read as city_file.
138

138

00:08:10.700  -->  00:08:13.890
This is our first study,
for city in city_file.
139

139

00:08:16.140  -->  00:08:19.530
You can try something
like cities.append(city).
140

140

00:08:19.530  -->  00:08:26.450
Then we can do a print(cities).
141

141

00:08:26.450  -->  00:08:32.770
Then maybe, for
city in cities and print(city).
142

142

00:08:32.770  -->  00:08:35.920
So now we're going through
opening the file using with.
143

143

00:08:35.920  -->  00:08:38.620
We're going through each city,
we're appending it to our list.
144

144

00:08:38.620  -->  00:08:42.360
Then we're printing up the list and you're
just going through each entry in the list
145

145

00:08:42.360  -->  00:08:45.590
and printing it again just to confirm
that we can save the individual cities.
146

146

00:08:45.590  -->  00:08:46.470
So if we run this
147

147

00:08:48.300  -->  00:08:51.660
you can see we've got notice that slash
n exists on all of those as well.
148

148

00:08:51.660  -->  00:08:54.780
And then we can see
that the five examples.
149

149

00:08:54.780  -->  00:08:57.420
So in other words this
works after a fashion.
150

150

00:08:57.420  -->  00:08:58.320
But we have those,
151

151

00:08:58.320  -->  00:09:03.080
these additional new line characters up
here in the list but also after each line.
152

152

00:09:03.080  -->  00:09:06.910
And one good way that we can remove
that is we can use the strip function,
153

153

00:09:06.910  -->  00:09:08.800
from a string to remove those
characters from a string.
154

154

00:09:08.800  -->  00:09:12.330
Instead of waiting until you print it out,
I'm doing something in the print here,
155

155

00:09:12.330  -->  00:09:16.590
like putting end equals single quote
single quote there to remove it.
156

156

00:09:16.590  -->  00:09:20.170
It can be a good idea to remove it
at the time we're importing it.
157

157

00:09:21.660  -->  00:09:25.770
So we can do something like,
append, and we can put .strip
158

158

00:09:29.550  -->  00:09:31.890
.strip/n.
159

159

00:09:31.890  -->  00:09:36.750
So if you then run that We see
we get a much better result.
160

160

00:09:36.750  -->  00:09:38.900
You notice the /n doesn't
appear in our list anymore.
161

161

00:09:38.900  -->  00:09:39.720
And obviously,
162

162

00:09:39.720  -->  00:09:44.390
each entry is outputted without the any
line character which is pretty cool.
163

163

00:09:45.420  -->  00:09:49.230
So, to see how strip's used let's
temporarily create a new file.
164

164

00:09:49.230  -->  00:09:54.130
We're just going to call it scratch pad.
165

165

00:09:57.910  -->  00:10:00.020
So, if you happen to be using
idol you can just type these
166

166

00:10:00.020  -->  00:10:01.230
commands directly into idol.
167

167

00:10:01.230  -->  00:10:02.050
Assuming you.
168

168

00:10:02.050  -->  00:10:06.310
You need to do just what I have done and
create a new file.
169

169

00:10:06.310  -->  00:10:13.380
We do something like
print Adelaide.strip A.
170

170

00:10:13.380  -->  00:10:17.380
Then we run that and
171

171

00:10:17.380  -->  00:10:20.260
it will say problem with running it again
so I'm going to just right click that.
172

172

00:10:20.260  -->  00:10:21.950
And run scratchpad.
173

173

00:10:21.950  -->  00:10:25.430
And notice how it's taking the a off,
so it's stripped off the a.
174

174

00:10:25.430  -->  00:10:30.240
So what strip does, it removes characters
from the beginning or end of a string and
175

175

00:10:30.240  -->  00:10:31.750
only from the beginning or end.
176

176

00:10:31.750  -->  00:10:32.530
That's an important thing.
177

177

00:10:32.530  -->  00:10:38.350
So for example, if I went back now and
changed this To del,
178

178

00:10:38.350  -->  00:10:40.770
which you can see.
179

179

00:10:40.770  -->  00:10:41.710
I ran that.
180

180

00:10:41.710  -->  00:10:44.070
So you can see what's happened there.
181

181

00:10:44.070  -->  00:10:48.240
The intention here when we ran it was to
remove the del, the second, third, and
182

182

00:10:48.240  -->  00:10:49.760
fourth characters from.
183

183

00:10:49.760  -->  00:10:52.550
But what actually happened
was it ignored those.
184

184

00:10:52.550  -->  00:10:56.730
But, it did remove the DE on the end,
and it ignored the L.
185

185

00:10:56.730  -->  00:11:00.740
So, very important that's a partial
match and its only returning, stripping
186

186

00:11:00.740  -->  00:11:04.690
anything that's in there even its only
a partial match as you can see there.
187

187

00:11:04.690  -->  00:11:05.990
So, back to our program again.
188

188

00:11:05.990  -->  00:11:09.860
Back to writing, and I'll just
select that before I forget again.
189

189

00:11:09.860  -->  00:11:13.810
So on line 11,
our program now strips slash n,
190

190

00:11:13.810  -->  00:11:17.410
which is the new line character,
before they're appended to the list.
191

191

00:11:17.410  -->  00:11:21.710
So one thing to note is that Python
is aware of which operating system
192

192

00:11:21.710  -->  00:11:25.410
it's running on, and it handles what
is referred to as universal newlines.
193

193

00:11:25.410  -->  00:11:30.410
Now on UNIX systems, such as Linux and a
Mac, New lines are written using a single
194

194

00:11:30.410  -->  00:11:35.300
character, where as Windows uses two
characters which is a /r or a /m.
195

195

00:11:35.300  -->  00:11:39.460
Sometimes now it's written as CR-LF for
carriage return and line feed, back
196

196

00:11:39.460  -->  00:11:43.030
from the the days when printers needed
codes to correctly position the paper.
197

197

00:11:43.030  -->  00:11:44.720
For the next line of text.
198

198

00:11:44.720  -->  00:11:48.030
But the good thing is the point we're
making here is that Python's aware of this
199

199

00:11:48.030  -->  00:11:50.670
and automatically takes care of
the different conventions for
200

200

00:11:50.670  -->  00:11:54.180
handling line breaks for you for
different operating systems.
201

201

00:11:54.180  -->  00:11:57.870
But, this is the important thing,
as long as the files open in text mode.
202

202

00:11:57.870  -->  00:11:59.590
Does need to be opened in text mode for
that to happen.
203

203

00:11:59.590  -->  00:12:02.620
So we're going to finish the discussion
on text files by observing that
204

204

00:12:02.620  -->  00:12:06.190
anything that you can print out on
screen can be written to a text file.
205

205

00:12:06.190  -->  00:12:10.420
However, it's not always possible to
read it back in the original form.
206

206

00:12:10.420  -->  00:12:13.540
And to show you that,
you're going to run the following program.
207

207

00:12:13.540  -->  00:12:16.370
And we'll see exactly what we mean.
208

208

00:12:19.320  -->  00:12:27.150
So down here,
I'm gonna type Imelda equals Mayhem.
209

209

00:12:27.150  -->  00:12:31.900
[NOISE]
My 2011.
210

210

00:12:31.900  -->  00:12:39.300
And it's one, you saw this
obviously in the earlier lectures.
211

211

00:12:39.300  -->  00:12:48.580
[NOISE]
212

212

00:12:48.580  -->  00:12:49.330
Do a couple more.
213

213

00:13:00.010  -->  00:13:02.000
Okay so
there's the data we want to [INAUDIBLE] so
214

214

00:13:02.000  -->  00:13:04.380
if we do something like with open.
215

215

00:13:06.320  -->  00:13:14.160
Three, double and the order as before.
216

216

00:13:14.160  -->  00:13:18.410
And we do something like print,
217

217

00:13:19.430  -->  00:13:22.750
file equals file.
218

218

00:13:24.050  -->  00:13:27.840
So that's obviously gonna run and
print out our top.
219

219

00:13:27.840  -->  00:13:32.170
So if we run that, just for simplicity
I'll change that to a text file, .txt.
220

220

00:13:32.170  -->  00:13:37.170
And if we run that, and there's our .txt.
221

221

00:13:37.170  -->  00:13:37.880
We'll have a look at that.
222

222

00:13:37.880  -->  00:13:40.760
And you can see that,
just make a bit space here.
223

223

00:13:42.870  -->  00:13:47.320
So the contents of the file probably look
like a good representation of our tuple,
224

224

00:13:47.320  -->  00:13:51.550
but there's no easy way to read
it back into a tuple variable,
225

225

00:13:51.550  -->  00:13:53.900
because it's now stored as a string.
226

226

00:13:53.900  -->  00:13:58.330
So Python does have an eval function
that will evaluate any expression
227

227

00:13:58.330  -->  00:13:59.300
to a string passed to it, so
228

228

00:13:59.300  -->  00:14:02.940
we could get the contents back from the
file into a tuple variable by using eval.
229

229

00:14:02.940  -->  00:14:04.790
So we'll just close it down.
230

230

00:14:06.230  -->  00:14:08.750
And we'll just comment this
out now because we know what
231

231

00:14:09.870  -->  00:14:11.160
file we're going to read the file again.
232

232

00:14:11.160  -->  00:14:19.180
So I'm going to put with open, and in
order three dot TXT, we'll read this time.
233

233

00:14:19.180  -->  00:14:23.400
As imelda_file contents
234

234

00:14:23.400  -->  00:14:28.770
equals imelda_file.readline.
235

235

00:14:28.770  -->  00:14:36.980
And we can do something like
imelda equals eval contents.
236

236

00:14:41.040  -->  00:14:45.520
We can do print imelda Title,
237

237

00:14:45.520  -->  00:14:50.630
artist, year, tracks equals imelda.
238

238

00:14:50.630  -->  00:14:55.500
print title, print artist, print year.
239

239

00:14:55.500  -->  00:15:00.880
Okay so if you run
240

240

00:15:00.880  -->  00:15:06.540
that So it does allow us,
241

241

00:15:06.540  -->  00:15:09.900
in this case, to retrieve
the contents of the type of the file.
242

242

00:15:09.900  -->  00:15:12.750
But there are much better
ways to do it as we'll see.
243

243

00:15:12.750  -->  00:15:15.830
So the use of evals is not a good idea
when dealing with data external to your
244

244

00:15:15.830  -->  00:15:21.320
program, and that's because the contents
of the file could be changed, and frankly
245

245

00:15:21.320  -->  00:15:24.640
could contain damaging instructions and
your program would happily execute them.
246

246

00:15:24.640  -->  00:15:27.240
It's really important to design
programs with security in mind and
247

247

00:15:27.240  -->  00:15:29.970
not to leave vulnerabilities in your code.
248

248

00:15:29.970  -->  00:15:31.960
So I'm gonna finish the video here, now.
249

249

00:15:31.960  -->  00:15:34.190
In the next video we're gonna talk
about appending to a text file.
250

250

00:15:34.190  -->  00:15:36.700
And then we're going to come
up with a challenge, for
251

251

00:15:36.700  -->  00:15:40.510
what we've learned to do with reading,
writing, and appending text files.
252

252

00:15:40.510  -->  00:15:41.690
So we'll do that in the next video
