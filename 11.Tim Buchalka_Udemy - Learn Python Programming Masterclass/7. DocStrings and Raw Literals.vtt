WEBVTT
1
1

00:00:05.000  -->  00:00:09.950
so continuing on with classes so what we are going to do is use an example to work with a record
2

2

00:00:09.950  -->  00:00:15.170
collection to show how classes can be
used together and I'm also gonna take this
3

3

00:00:15.170  -->  00:00:19.310
opportunity to talk about doc strings
what they are and what information
4

4

00:00:19.310  -->  00:00:23.620
should be included in them so lets go
ahead and create a new class for this
5

5

00:00:23.620  -->  00:00:29.080
so I'm gonna come over as I always done new
Python file and will
6

6

00:00:29.080  -->  00:00:38.840
call this one song and we'll start by
writing the class so....
7

7

00:00:38.840  -->  00:00:40.560
...
8

8

00:00:40.560  -->  00:00:44.660
....
9

9

00:00:46.700  -->  00:00:52.820
....
10

10

00:00:57.580  -->  00:01:01.000
....
11

11

00:01:03.960  -->  00:01:23.280
....
12

12

00:01:23.280  -->  00:01:38.900
...so that is our doc string
13

13

00:01:38.900  -->  00:01:44.300
...so lets create our __init__  which I said wasn't going to
14

14

00:01:44.300  -->  00:01:52.070
say the underscore underscore again so....
15

15

00:01:52.070  -->  00:01:56.480
....
16

16

00:01:56.480  -->  00:02:03.650
...and lets write the doc string for the init method....
17

17

00:02:06.510  -->  00:03:02.600
....
18

18

00:03:02.600  -->  00:03:11.900
....then we need to initialise
our data attributes so...
19

19

00:03:11.900  -->  00:03:22.700
....
20

20

00:03:22.700  -->  00:03:29.350
...so their really shouldn't be much to say at this point about this class and that's
21

21

00:03:29.350  -->  00:03:33.790
because the doc string should say it all
and in fact the doc strings in this class are
22

22

00:03:33.790  -->  00:03:37.010
probably a little bit to verbose but I
just wanted to show you that anyway
23

23

00:03:37.850  -->  00:03:50.430
....so their really
24

24

00:03:50.430  -->  00:03:54.010
shouldn't be too much to say about this
class and that's because the doc string
25

25

00:03:54.010  -->  00:03:57.440
should really say it at all and in fact what I've done I probably have gone overboard
26

26

00:03:57.440  -->  00:04:02.240
here and made the doc strings a little
bit too verbose here so doc strings
27

27

00:04:02.240  -->  00:04:05.850
themselves can be used to document
modules functions classes and methods
28

28

00:04:05.850  -->  00:04:09.600
and really should provide information
that is useful to understanding what the
29

29

00:04:09.600  -->  00:04:15.340
object does and also how to use it now you
should also include other details that
30

30

00:04:15.340  -->  00:04:20.190
aren't obvious such as what will happen
if a value wasn't specified now writing good
31

31

00:04:20.190  -->  00:04:24.650
documentation is a skill in itself and it can be
very difficult  to document your own code
32

32

00:04:24.650  -->  00:04:28.930
and because you know how it works and
fits together well you did create it after
33

33

00:04:28.930  -->  00:04:33.360
all so large companies just out of interest will often
employ technical writers to produce
34

34

00:04:33.360  -->  00:04:38.210
the documentation so someone else who creates a
documentation who didn't create the
35

35

00:04:38.210  -->  00:04:42.140
original program so a description of
doc stings and guidelines for writing them
36

36

00:04:42.140  -->  00:04:45.140
is in pep 257 so if we look at that
37

37

00:04:46.160  -->  00:04:54.400
paste it on the screen the links are in the Resources section
so the pep documents and semantics and
38

38

00:04:54.400  -->  00:04:58.730
conventions associated with python doc
strings well thats actually fairly short
39

39

00:04:58.730  -->  00:05:02.050
documents as you can see it doesn't really go into a lot of details certainly compared to some
40

40

00:05:02.050  -->  00:05:06.220
other peps there but I definitely
recommend that you read it to specially
41

41

00:05:06.220  -->  00:05:09.090
as you can skip the final section on handling
42

42

00:05:09.090  -->  00:05:15.750
doc string indentation that's this bit here so you don't need to worry about that too much getting
43

43

00:05:15.750  -->  00:05:20.600
back to our code so a doc string should
always use triple quotes and that keeps
44

44

00:05:20.600  -->  00:05:25.060
your doc strings consistent with everyone
else's and also means you can include quotes in the
45

45

00:05:25.060  -->  00:05:27.830
documentation as well now if
46

46

00:05:27.830  -->  00:05:33.000
you intend to use escape characters you
know such as /t or /n in your doc
47

47

00:05:33.000  -->  00:05:39.230
string then use r with 3 quotes to make it a raw
string and lets just see what I mean so I'm going to create a new
48

48

00:05:39.230  -->  00:05:53.140
class new file and call this one demo I just wanna show you how this works so....
49

49

00:05:53.140  -->  00:06:11.060
....
50

50

00:06:11.060  -->  00:06:16.910
...and will print that out to see if that it's working so if we run that and run demo
51

51

00:06:16.910  -->  00:06:22.710
string split and tab you can see its gone to the next line as well but I just want to show you how to create this raw string
52

52

00:06:22.710  -->  00:06:31.990
that I just talk about so...
53

53

00:06:31.990  -->  00:06:36.540
you notice how IntelliJ automatically added the second
one and if I take the contents down
54

54

00:06:36.540  -->  00:06:41.280
here in the first string so I'm actually
copying and pasting that I'm gonna paste that
55

55

00:06:41.280  -->  00:06:54.090
into their and if we print the raw string and run this is just to see the difference so as
56

56

00:06:54.090  -->  00:06:57.510
you can see by pasting that in there
like that what I've done is we've got
57

57

00:06:57.510  -->  00:07:06.140
Python to not treat it with those
escape characters so the /n on line 1and the /t's we're
58

58

00:07:06.140  -->  00:07:10.340
treated correctly by Python and
treated as the carriage return and also
59

59

00:07:10.340  -->  00:07:14.230
the tab characters but when we put this
in this raw string the /n was
60

60

00:07:14.230  -->  00:07:19.720
ignored and just was treated as a regular character so raw string saw are useful when you don't want Python to treat
61

61

00:07:19.720  -->  00:07:24.620
the backslash escaped character in a
special way so when the string literal
62

62

00:07:24.620  -->  00:07:29.100
is defined without the r prefix as you
saw these /n causes a
63

63

00:07:29.100  -->  00:07:34.030
line break and /t causes tabs to be included in
the string and that's the output at the bottom left of
64

64

00:07:34.030  -->  00:07:37.880
the screen so I really just provided this as a
convenience other ways you have to enter
65

65

00:07:37.880  -->  00:07:41.820
the ASCII codes for those characters
which not only make the code messy but
66

66

00:07:41.820  -->  00:07:45.320
they cause problems on different
operating systems so if Python didn't
67

67

00:07:45.320  -->  00:07:49.030
provide a mechanism for escaping certain
characters we have to probably create
68

68

00:07:49.030  -->  00:07:53.820
strings like this is so lets just write some more code so...
69

69

00:07:54.380  -->  00:08:04.690
....
70

70

00:08:05.210  -->  00:08:18.050
....
71

71

00:08:18.050  -->  00:08:27.780
..and we got the same response same output as
72

72

00:08:27.780  -->  00:08:34.240
we got for a sting when we printed that out and of course that's sort of shows you that by
73

73

00:08:34.240  -->  00:08:39.000
Python letting us put a /n and a /t in that format it saves us from
74

74

00:08:39.000  -->  00:08:42.960
having to write a string in this format having to add this characters
75

75

00:08:42.960  -->  00:08:47.520
via ASCII codes to create a string that
way so in other words it's really adding
76

76

00:08:47.520  -->  00:08:51.030
that as a inconvenience for us a shortcut to
put those escape characters and if you
77

77

00:08:51.030  -->  00:08:54.830
wanted to and again using a raw string with
the r in front of it enables us to
78

78

00:08:54.830  -->  00:08:59.580
effectively ignore those escape
characters but it gets worse with
79

79

00:08:59.580  -->  00:09:03.640
these characters because not only was
it annoying to type because obviously a lot
80

80

00:09:03.640  -->  00:09:07.850
more code than in the first example
on line 1 but it's also wrong on
81

81

00:09:07.850  -->  00:09:12.720
windows and that is because Linux and Mac use a line feed character which is the ASCII
82

82

00:09:12.720  -->  00:09:17.870
code for ten as you can see on line 7 character 10 to start a new line but
83

83

00:09:17.870  -->  00:09:22.420
Windows users uses 2 characters a carriage
return followed by line feed so
84

84

00:09:22.420  -->  00:09:26.750
to do the equivalent in Windows its
character 13 + character 10 or ASCII
85

85

00:09:26.750  -->  00:09:32.300
symbol 13 and ASCII 10 now reasons why
Windows does this are historical and really
86

86

00:09:32.300  -->  00:09:35.680
dates back to the time before screens
when computers were program using
87

87

00:09:35.680  -->  00:09:40.540
teletype terminals so it was
necessary to return the carriage to the
88

88

00:09:40.540  -->  00:09:45.200
left hand side and in feed down one line and that explains
89

89

00:09:45.200  -->  00:09:50.240
Windows Control carriage return line
feed combination that's the
90

90

00:09:50.240  -->  00:09:55.950
character 13 and character 10 now UNIX drivers started automatically using the carriage
91

91

00:09:55.950  -->  00:09:59.790
returns so it wasn't necessary to have it in
the file now when you use a backslash
92

92

00:09:59.790  -->  00:10:04.300
n Pyton takes care of this for you
and the same code will work on all three
93

93

00:10:04.300  -->  00:10:07.820
operating systems in other words it
knows by you just putting a /n
94

94

00:10:07.820  -->  00:10:14.240
then it needs to essentially put a character 13 and a character 10 and therefore on
95

95

00:10:14.240  -->  00:10:15.110
Windows
96

96

00:10:15.110  -->  00:10:21.130
and to leave it just a character 10 for Mac
and Linux enough of the history well
97

97

00:10:21.130  -->  00:10:25.870
almost that last bit of history may
be an interesting but probably of very
98

98

00:10:25.870  -->  00:10:29.300
little use but there's a bit more
history that is important I'm getting to
99

99

00:10:29.300  -->  00:10:34.920
that now these raw strings literals that we've used on line 4 their introduced
100

100

00:10:34.920  -->  00:10:39.500
in Python 2 mainly for using regular
expressions now we will be covering regular
101

101

00:10:39.500  -->  00:10:43.670
expressions later in the course for now
all we really need to know about regular
102

102

00:10:43.670  -->  00:10:48.020
expressions is that the strings that
contain a lot of back / characters now
103

103

00:10:48.020  -->  00:10:52.530
because the backslashes used to escape
the next character in a string if you
104

104

00:10:52.530  -->  00:10:56.210
actually want a backslash then you have to
double it up and I'll show you what I mean so
105

105

00:10:56.780  -->  00:11:04.900
lets continue on here so we're going to type....
106

106

00:11:04.900  -->  00:11:18.800
....and see what happens
107

107

00:11:20.710  -->  00:11:24.300
notice as what happened their so this is a
backslash followed by some texts that's
108

108

00:11:24.300  -->  00:11:29.580
because the way that we've type that in the
/ f has been treaded or the f that is after
109

109

00:11:29.580  -->  00:11:34.250
the / has been treated as a
control character and we can't see that on
110

110

00:11:34.250  -->  00:11:37.200
the screen but the bottom line is the
f hasn't been treated as a regular f
111

111

00:11:37.200  -->  00:11:40.720
in that case so if we want to use a
backslash character would have to do
112

112

00:11:40.720  -->  00:11:43.290
something like this so....
113

113

00:11:43.290  -->  00:11:47.260
....
114

114

00:11:49.570  -->  00:12:00.090
....and if we run that
115

115

00:12:00.090  -->  00:12:03.940
you could see we got it now appearing so / is
now being shown because we've
116

116

00:12:03.940  -->  00:12:07.910
used to backslashes and the f is now
showing and incidentally in the previous
117

117

00:12:07.910  -->  00:12:12.960
example a strange character
may appear on Linux and Windows it
118

118

00:12:12.960  -->  00:12:17.560
doesn't appear as you can see under Mac
right here theirs probably a strange
119

119

00:12:17.560  -->  00:12:21.040
characters so if your seeing that
looks a little bit like a or just a
120

120

00:12:21.040  -->  00:12:26.690
strange character the reason for that is Python interpreting /f as an ASCII 6
121

121

00:12:26.690  -->  00:12:31.400
which is an echo used by device to
acknowledge receiving of a transmission in
122

122

00:12:31.400  -->  00:12:35.090
the early days so you may or may not see
that but the point was that it was
123

123

00:12:35.090  -->  00:12:38.620
basically not showing a regular f but
by putting two backslashes we can see
124

124

00:12:38.620  -->  00:12:43.490
that its working correctly so again
the point of this raw string literals
125

125

00:12:43.490  -->  00:12:47.070
are introduced to remove the need to
double up backslashes in a string like
126

126

00:12:47.070  -->  00:12:52.780
we've had to do their on line 13 so
why now you probably asking why is the
127

127

00:12:52.780  -->  00:12:55.560
fact that raw stings that were introduced
to deal with regular expressions
128

128

00:12:55.560  -->  00:12:59.600
important well although regular
expressions used a lot of backslashes
129

129

00:12:59.600  -->  00:13:04.500
you can't have one at the end of a regular
expressions string now as a result the
130

130

00:13:04.500  -->  00:13:09.030
Python raw string process it but doesn't suppress escaping if the backslashes the
131

131

00:13:09.030  -->  00:13:14.320
last character in the string and to show you what I mean I'm going to show by just type in a bit of code we can get it
132

132

00:13:14.320  -->  00:13:20.520
to show an error that you may not
think should be an error so....
133

133

00:13:22.130  -->  00:13:32.370
....so Python treats the final backslashes as escape character
134

134

00:13:32.370  -->  00:13:36.920
and its escaping the final close quote
so consequently the string isn't
135

135

00:13:36.920  -->  00:13:37.960
terminated
136

136

00:13:37.960  -->  00:13:43.200
so hence we are getting an error if that makes sense so if you want to end a string with a backslash you have to
137

137

00:13:43.200  -->  00:13:47.210
escape it even when using raw string
literal in other words we have to put a
138

138

00:13:47.210  -->  00:13:51.390
double backslash in there and that
fixes the problem now raw string
139

139

00:13:51.390  -->  00:13:55.690
literals are sometimes used to specify
file paths in Windows which used the
140

140

00:13:55.690  -->  00:13:58.860
backslash character rather than a
forward slash two separate the directory
141

141

00:13:58.860  -->  00:14:03.120
names but it's not actually necessary to
do this because once again Python takes
142

142

00:14:03.120  -->  00:14:07.560
care of it for us but if you do and your
Python ends up with a backslash such a
143

143

00:14:07.560  -->  00:14:11.840
a c:/ for example then you need
to double up that final backslash
144

144

00:14:11.840  -->  00:14:16.260
so I'll be referring to these raw type literals because there's really no such
145

145

00:14:16.260  -->  00:14:20.610
thing as a raw string type in Python their all just string which is really
146

146

00:14:20.610  -->  00:14:24.760
telling Python to alter how it
interprets them and that's why I had to
147

147

00:14:24.760  -->  00:14:28.890
copy and paste the strings rather than
somehow convert them into a raw string when
148

148

00:14:28.890  -->  00:14:32.430
initializing the raw variables there's
no such conversion because there's no
149

149

00:14:32.430  -->  00:14:34.550
raw type to convert to
150

150

00:14:34.550  -->  00:14:39.660
their are prefix that we're putting you can see on
line 16 really only applies to string
151

151

00:14:39.660  -->  00:14:44.780
literals to tell Python on how to interpret
so pep 257 that we saw earlier in
152

152

00:14:44.780  -->  00:14:49.190
this video was written along time ago
and the comment about using a u prefix
153

153

00:14:49.190  -->  00:14:55.260
doesn't apply to Python 3 if you go back you can read up on prefix all strings in Python
154

154

00:14:55.260  -->  00:14:59.790
3 are already Unicode that's what I
was referring to so I'm going to end the video
155

155

00:14:59.790  -->  00:15:05.320
here now in the next video we are going to switch back to
the doc string and talk more about a how you
156

156

00:15:05.320  -->  00:15:09.830
got about documenting your classes and methods
and functions etc see you in the next
157

157

00:15:09.830  -->  00:15:10.060
video
