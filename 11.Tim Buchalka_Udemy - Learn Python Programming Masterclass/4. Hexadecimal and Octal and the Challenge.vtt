WEBVTT
1
1

00:00:04.670  -->  00:00:07.590
So if you've been following
through the previous video,
2

2

00:00:07.590  -->  00:00:09.750
we talked about the binary number system.
3

3

00:00:09.750  -->  00:00:12.640
You may actually have made
the following two observations.
4

4

00:00:12.640  -->  00:00:18.140
Firstly, converting from decimal To binary
tedious once you get up above four bits or
5

5

00:00:18.140  -->  00:00:19.470
eight numbers in the range 0 through 15.
6

6

00:00:19.470  -->  00:00:22.890
And binary numbers have a lot of numbers
have a lot of digits and writing and
7

7

00:00:22.890  -->  00:00:27.250
speaking them is both boring and,
more importantly, error prone.
8

8

00:00:27.250  -->  00:00:30.660
So as a result, programmers very
often use hexadecimal instead.
9

9

00:00:30.660  -->  00:00:36.070
Hexidecimal, or as it's usually called
X is basic 16 and because 16 is
10

10

00:00:36.070  -->  00:00:41.510
an exact power of two, converting between
binary and hex is actually quick and easy.
11

11

00:00:41.510  -->  00:00:45.580
Now once again, I'm gonna point out you
don't need to understand this section
12

12

00:00:45.580  -->  00:00:47.800
in order to complete
the rest of the course.
13

13

00:00:47.800  -->  00:00:51.790
So don't feel that if you haven't got
a good understanding of this section that
14

14

00:00:51.790  -->  00:00:54.900
The next sections are going to get
worse because that's not the case, but
15

15

00:00:54.900  -->  00:00:58.390
the thing here is that our discussion
of binary wouldn't be complete
16

16

00:00:58.390  -->  00:01:00.310
without covering hexadecimal.
17

17

00:01:00.310  -->  00:01:01.850
So if you want to skip
the rest of this video,
18

18

00:01:01.850  -->  00:01:03.600
and move on to the next
section then please do.
19

19

00:01:03.600  -->  00:01:06.790
And we'll get back to
regular Python programming.
20

20

00:01:06.790  -->  00:01:07.330
Look.
You can
21

21

00:01:07.330  -->  00:01:10.170
also come back to this section
once you've mastered Python, and
22

22

00:01:10.170  -->  00:01:12.380
you no longer having to
remember loads of new things.
23

23

00:01:12.380  -->  00:01:13.330
So continuing on.
24

24

00:01:13.330  -->  00:01:16.750
Hex has got a number of
advantages over binary.
25

25

00:01:16.750  -->  00:01:22.210
Firstly hex numbers are much shorter and
that makes writing them a lot easier.
26

26

00:01:22.210  -->  00:01:26.530
For the number 0 through 255 can be
written in just two hex digits and
27

27

00:01:26.530  -->  00:01:30.940
the number 0 to 65,535
With just four hex digits.
28

28

00:01:30.940  -->  00:01:34.970
The other thing is that working in hex
provides a convenient way to remain close
29

29

00:01:34.970  -->  00:01:36.210
to the underlying binary.
30

30

00:01:36.210  -->  00:01:39.550
And this can be very useful when you're
actually dealing with memory addresses, or
31

31

00:01:39.550  -->  00:01:41.970
operations that work on individual bits.
32

32

00:01:41.970  -->  00:01:45.730
And that's like using and or an xor,
which we saw in the previous video.
33

33

00:01:47.210  -->  00:01:48.260
So moving on to the next slide.
34

34

00:01:48.260  -->  00:01:53.550
Working in base 16 means that we actually
need a way to represent the 16 digits
35

35

00:01:53.550  -->  00:01:58.500
from 0 to 15 in the same way that,
in base 10, we had the digits from 0 to 9.
36

36

00:01:58.500  -->  00:02:02.230
So rather than create 6 more digits to
represent 10, 11, 12, 13, 14, and 15,
37

37

00:02:02.230  -->  00:02:06.820
th symbols A to F
are actually used instead.
38

38

00:02:06.820  -->  00:02:11.000
Now each hex digit represents four
binary digits called a nibble.
39

39

00:02:11.000  -->  00:02:13.790
And seriously, I know it's a weird
name but that's what they're called.
40

40

00:02:13.790  -->  00:02:18.780
So to represent an 8 bit-byte,
we actually use two hex digits.
41

41

00:02:18.780  -->  00:02:21.840
So let's go back now and
change the program that we wrote
42

42

00:02:21.840  -->  00:02:24.690
in the previous video to
print out the numbers in hex.
43

43

00:02:24.690  -->  00:02:27.260
So I'm gonna shoot back
over to the Intelligo, so
44

44

00:02:27.260  -->  00:02:29.180
a simple change of we'll just
briefly type it in again.
45

45

00:02:29.180  -->  00:02:34.720
I've got a new for, so for
i in range 17, and we'll
46

46

00:02:34.720  -->  00:02:41.830
do our print("
47

47

00:02:41.830  -->  00:02:51.130
in hex is ".format)
48

48

00:02:52.730  -->  00:02:55.990
Note that I use x here to
represent hex and hot h.
49

49

00:02:55.990  -->  00:02:57.070
So, I've actually run this.
50

50

00:02:58.950  -->  00:03:02.220
You can see the numbers and
the cross pointing value in hex.
51

51

00:03:02.220  -->  00:03:04.510
So, 0 through nine is
equivalent to decimal.
52

52

00:03:04.510  -->  00:03:09.200
But once we get to 10, notice how
instead of 10 we went to oi, 11 is ob.
53

53

00:03:09.200  -->  00:03:12.160
12 is [INAUDIBLE] and so on,
right through to 16, and
54

54

00:03:12.160  -->  00:03:14.660
16 effectively becomes 10, 1, and 0.
55

55

00:03:14.660  -->  00:03:19.480
So [INAUDIBLE] partially uses the letter B
in the format stream to represent binary.
56

56

00:03:19.480  -->  00:03:23.370
We saw that in the previous video when I
used X as I pointed out on the screen,
57

57

00:03:23.370  -->  00:03:26.730
not H to represent X If you want
to extend the range to 256,
58

58

00:03:26.730  -->  00:03:30.440
you can actually see how
counting in hex works.
59

59

00:03:30.440  -->  00:03:33.470
So adding one then carries over
to the next column as a source.
60

60

00:03:33.470  -->  00:03:38.260
So for example,
1F is 116 plus 15 units, which is 31.
61

61

00:03:38.260  -->  00:03:42.670
20 and hex is two 16s,
and no units, which is 32.
62

62

00:03:42.670  -->  00:03:46.200
Now, if a hexadecimal number
contains one of the letters a to f,
63

63

00:03:46.200  -->  00:03:49.130
it's actually obviously easy
to see that it's a hex number.
64

64

00:03:49.130  -->  00:03:52.180
But however, the number 20 is
not obviously hexadecimal.
65

65

00:03:52.180  -->  00:03:56.630
So if we're dealing with hex numbers,
we need some way to identify them as such.
66

66

00:03:56.630  -->  00:04:01.520
Python along with many other languages
allows or uses the prefix 0x to actually
67

67

00:04:01.520  -->  00:04:05.930
identify a hex number as the following
simple program we're about to demonstrate.
68

68

00:04:05.930  -->  00:04:10.630
So I'm gonna type in that so
obviously we can type x=20.
69

69

00:04:10.630  -->  00:04:12.860
Exit 20, but based on that,
70

70

00:04:12.860  -->  00:04:17.630
you wouldn't know whether you
meant 20 decimal or 20 hex.
71

71

00:04:17.630  -->  00:04:20.390
But if I type in 0X 20, that actually
72

72

00:04:20.390  -->  00:04:24.700
tells Python that we want to actually
type in the hex number for 20.
73

73

00:04:24.700  -->  00:04:32.210
So y equals 0X0A, and
then we could do a print X, print Y.
74

74

00:04:32.210  -->  00:04:33.230
Let's do a modification.
75

75

00:04:33.230  -->  00:04:36.790
Print X times Y So let's run that.
76

76

00:04:36.790  -->  00:04:39.540
And you can see the results there.
77

77

00:04:39.540  -->  00:04:41.920
First one, 20, which is actually 32.
78

78

00:04:41.920  -->  00:04:44.900
So we're asking it to print
out the decimal equivalent.
79

79

00:04:44.900  -->  00:04:47.800
And y, which was 0x0a,
the equivalent is 10.
80

80

00:04:47.800  -->  00:04:52.330
And the last one, multiplying them
together So it's basically 32 by 10
81

81

00:04:52.330  -->  00:04:57.010
effectively, or
20x multiplied by [INAUDIBLE] X, and
82

82

00:04:57.010  -->  00:05:01.180
that's 320 as a decimal number,
is the actual total in decimals.
83

83

00:05:01.180  -->  00:05:02.980
And I didn't point it out
in the previous video, but
84

84

00:05:02.980  -->  00:05:07.830
you can actually specify binary
literals using the prefix ob.
85

85

00:05:08.980  -->  00:05:14.580
So we could do something like 0b00101010
To actually print out a value in binary.
86

86

00:05:14.580  -->  00:05:18.260
So if we run that, that would be
the binary equivalent, and or in decimal,
87

87

00:05:18.260  -->  00:05:21.310
42 is equivalent of that
binary number there.
88

88

00:05:21.310  -->  00:05:22.360
Now the other thing to point out,
89

89

00:05:22.360  -->  00:05:24.750
is that leading zeros are not
actually necessary either.
90

90

00:05:24.750  -->  00:05:26.810
So in other words,
we could have done the same thing here,
91

91

00:05:26.810  -->  00:05:28.070
we could have just removed those two.
92

92

00:05:29.570  -->  00:05:30.900
Run it.
93

93

00:05:30.900  -->  00:05:32.480
We've got exactly the same value.
94

94

00:05:32.480  -->  00:05:33.740
Hexadecimal addition and
95

95

00:05:33.740  -->  00:05:38.010
subtraction can actually be performed just
like decimal addition and subtraction.
96

96

00:05:38.010  -->  00:05:42.040
But with that said there's very few people
these days who actually think in hex.
97

97

00:05:42.040  -->  00:05:45.720
Now it use when we didn't have modern
programming languages and compilers
98

98

00:05:45.720  -->  00:05:49.570
that we have these days programmers often
work with machine code or assembler And
99

99

00:05:49.570  -->  00:05:53.270
you can actually find programs he thought
encountered effectively in hex, but
100

100

00:05:53.270  -->  00:05:54.690
this is becoming rarer.
101

101

00:05:54.690  -->  00:05:58.170
I actually, myself,
developed games back in the day and
102

102

00:05:58.170  -->  00:06:03.540
I didn't actually have an [INAUDIBLE] so
I actually had to deal with hex and
103

103

00:06:03.540  -->  00:06:08.070
I had to understand how to actually
calculate numbers in hex but
104

104

00:06:08.070  -->  00:06:09.880
also [INAUDIBLE] what they
actually meant in their values.
105

105

00:06:09.880  -->  00:06:11.810
So, It's something that you
can certainly learn, but
106

106

00:06:11.810  -->  00:06:13.900
these days it's not something
you really need to.
107

107

00:06:13.900  -->  00:06:15.680
So let's swing back now
on to the next slide.
108

108

00:06:17.650  -->  00:06:21.720
So in this calculation I'm
gonna show you 8A take 4E.
109

109

00:06:21.720  -->  00:06:23.650
So 8E requires us borrowing
from the next column.
110

110

00:06:23.650  -->  00:06:24.890
So we actually borrow 16.
111

111

00:06:24.890  -->  00:06:28.840
Now, at this point,
most people would probably add 16 to 10.
112

112

00:06:28.840  -->  00:06:30.740
Or A and Hex to give 26.
113

113

00:06:30.740  -->  00:06:36.400
So, taking away E which is 14 leaves 12
and so we have c in the first column.
114

114

00:06:36.400  -->  00:06:38.920
Seven take four leaves
three in the second column.
115

115

00:06:38.920  -->  00:06:42.290
So, the answer is three c in hex or
60 in decimal.
116

116

00:06:42.290  -->  00:06:45.110
So if you had to perform addition and
subtraction in Hex
117

117

00:06:45.110  -->  00:06:48.750
without using a calculator, it's natural
to convert the digits to decimal.
118

118

00:06:48.750  -->  00:06:51.850
Now the standard calculators that
come with Windows, Linux and
119

119

00:06:51.850  -->  00:06:56.070
the Mac all have an advanced mode
that can perform Hex arithmetic, and
120

120

00:06:56.070  -->  00:07:00.370
you see how easy it is to do it in Python,
so Now frankly there's no real reason for
121

121

00:07:00.370  -->  00:07:03.480
risking errors by performing
these calculations yourself.
122

122

00:07:03.480  -->  00:07:05.040
So in Windows there's a couple of options.
123

123

00:07:05.040  -->  00:07:07.580
There's either a scientific
option under the view menu or
124

124

00:07:07.580  -->  00:07:10.640
in Windows 10 it's got a programmer
mode in the settings menu.
125

125

00:07:10.640  -->  00:07:13.790
On the Mac, there's a programmer
mode under the view menu.
126

126

00:07:13.790  -->  00:07:18.180
And under Ubuntu Linux, there's also
a programmer mode under the mode menu.
127

127

00:07:18.180  -->  00:07:20.910
So there's a few options if you
do actually wanna go in and
128

128

00:07:20.910  -->  00:07:22.370
check out the calculator and try it out.
129

129

00:07:22.370  -->  00:07:26.460
It's actually quite useful to do that
just to sort of see how it all works,
130

130

00:07:26.460  -->  00:07:29.810
but again it's not something you
need to understand fully yourself.
131

131

00:07:29.810  -->  00:07:31.420
Okay, so moving onto the next slide.
132

132

00:07:33.180  -->  00:07:35.120
Gonna talk now about Octal.
133

133

00:07:35.120  -->  00:07:41.350
So Octal have like hexadecimal,
Octal is base 8 and uses the digits 037.
134

134

00:07:41.350  -->  00:07:45.570
As you've probably expected I'd soon
assume you now understand binary decimal.
135

135

00:07:45.570  -->  00:07:50.160
And so representing 255 an octal,
we've got three times 64 which is 192,
136

136

00:07:50.160  -->  00:07:55.570
plus seven times eight which is 56 and
that gives us 248.
137

137

00:07:55.570  -->  00:07:57.910
Then adding seven to give 255.
138

138

00:07:57.910  -->  00:08:01.500
So adding one to that we carry one
from the first to second column
139

139

00:08:01.500  -->  00:08:04.990
Then carry one again from the second
to third column, giving you 400 octal,
140

140

00:08:04.990  -->  00:08:11.680
which is written as 0 in the lower case
o 400, the little o in other words.
141

141

00:08:11.680  -->  00:08:15.620
So it's usual to use lower case so
it's not confused with the digit 0.
142

142

00:08:15.620  -->  00:08:19.340
So Python will allow an upper
case letter O, though But
143

143

00:08:19.340  -->  00:08:21.140
it's not advisable to actually do that.
144

144

00:08:21.140  -->  00:08:23.910
so octal is really rarely used these days.
145

145

00:08:23.910  -->  00:08:28.220
One of the few instances that JP could
come up with was Linux file permissions,
146

146

00:08:28.220  -->  00:08:30.120
which are three groups of three bits each.
147

147

00:08:30.120  -->  00:08:34.560
So it's represents the read,
write, and execute permission.
148

148

00:08:34.560  -->  00:08:37.830
And the first group being the owner's
permission, the next group of three bits,
149

149

00:08:37.830  -->  00:08:39.270
the group's permission, and
150

150

00:08:39.270  -->  00:08:42.700
finally The last three bits was
the permission for all users.
151

151

00:08:42.700  -->  00:08:48.020
I'm just showing you this on a slide.
152

152

00:08:48.020  -->  00:08:53.410
So each octal digit corresponds to a three
bit binary number, as shown there.
153

153

00:08:53.410  -->  00:08:55.410
So all seven combinations have been shown,
154

154

00:08:55.410  -->  00:08:59.780
although not all of them would be used in
practice when specifying file permissions.
155

155

00:08:59.780  -->  00:09:02.730
So the most common permission is to
allow read and write access to the owner
156

156

00:09:02.730  -->  00:09:07.260
of the file And read only to everyone
else this will be written as
157

157

00:09:07.260  -->  00:09:12.110
what's octal number 644 and
that will be written as rw-r--r--.
158

158

00:09:12.110  -->  00:09:15.000
Again, if that didn't make a lot
of sense to you, that's okay.
159

159

00:09:15.000  -->  00:09:18.180
You don't really need to know this, it's
more something you can come back to later.
160

160

00:09:18.180  -->  00:09:20.640
If you're feeling this is a bit
overwhelming, don't give up,
161

161

00:09:20.640  -->  00:09:23.420
move on to the next section if you're
finding this a little bit difficult.
162

162

00:09:23.420  -->  00:09:26.720
Okay, so let's go back to IntelliJ So
it's actually time for a challenge.
163

163

00:09:26.720  -->  00:09:31.660
So we're gonna come up with a challenge to
help you understand binary hex and octals.
164

164

00:09:31.660  -->  00:09:35.280
I'm gonna close down the run window and
I'm gonna
165

165

00:09:35.280  -->  00:09:38.710
comment out this code to to say you've
got it there later if you wanna use it.
166

166

00:09:38.710  -->  00:09:40.910
And I'm gonna paste in
what the challenge is.
167

167

00:09:40.910  -->  00:09:42.290
Gonna paste in there now.
168

168

00:09:42.290  -->  00:09:43.410
So here is the challenge.
169

169

00:09:43.410  -->  00:09:47.160
So when converting a decimal
number to binary, you look for
170

170

00:09:47.160  -->  00:09:51.680
the highest power of two, smaller than the
number, and you put a one in that column.
171

171

00:09:51.680  -->  00:09:56.220
You then take the remainder and you repeat
the process with the highest power.
172

172

00:09:56.220  -->  00:09:57.360
Putting a one in it.
173

173

00:09:57.360  -->  00:09:58.700
Into the remainder.
174

174

00:09:58.700  -->  00:10:00.110
And is zero otherwise.
175

175

00:10:00.110  -->  00:10:03.370
And you keep repeating until you've
dealt with all the powers down to two.
176

176

00:10:03.370  -->  00:10:04.810
That is one in other words.
177

177

00:10:04.810  -->  00:10:07.690
So, what we're going to be wanting to
do is writing a program that requests
178

178

00:10:07.690  -->  00:10:11.430
a number from the keyboard and
then prints out its binary representation.
179

179

00:10:11.430  -->  00:10:13.330
Now, obviously you could
use a format string.
180

180

00:10:13.330  -->  00:10:17.570
But, that's not actually allowed for
this challenge because it's too easy.
181

181

00:10:17.570  -->  00:10:21.240
So, the program should actually cater for
numbers up to 65,535.
182

182

00:10:21.240  -->  00:10:22.740
Other words 2 to the power of 16 take 1.
183

183

00:10:22.740  -->  00:10:26.170
And that's a hint here,
you need integer division.
184

184

00:10:26.170  -->  00:10:30.590
That's the two slashes for integer
division as we've talked about previously
185

185

00:10:30.590  -->  00:10:33.140
and the modular the percent
to get the remainder.
186

186

00:10:33.140  -->  00:10:38.580
You also need to use the two stars to
raise one number to the power of another.
187

187

00:10:38.580  -->  00:10:41.260
For example 2 * * 8 raises
2 to the power of 8.
188

188

00:10:41.260  -->  00:10:46.180
And that's an optional extra try
avoiding printing leading zeros.
189

189

00:10:46.180  -->  00:10:51.080
Then once the program is working, modify
it to print Octal rather than binary.
190

190

00:10:51.080  -->  00:10:53.310
So that's is the challenge,
see how well you go with it.
191

191

00:10:53.310  -->  00:10:56.300
Go away and try your best with it and
when you're ready to come back and
192

192

00:10:56.300  -->  00:10:59.640
see what we've come up with, come back and
we'll get started on the code.
193

193

00:10:59.640  -->  00:11:01.230
Pause the video now and
I'll see you when you get back.
194

194

00:11:07.240  -->  00:11:08.230
Okay, so how did you get on?
195

195

00:11:08.230  -->  00:11:11.650
Hopefully you figured it out, or
you managed to get it working, and
196

196

00:11:11.650  -->  00:11:12.950
let's talk about the solution.
197

197

00:11:12.950  -->  00:11:16.450
So the way we come up with it was
because the highest number we've got to
198

198

00:11:16.450  -->  00:11:19.100
deal with is one less than
two to the power of sixteen,
199

199

00:11:19.100  -->  00:11:22.620
The first number we need to divide
by is 2 to the power of 15.
200

200

00:11:22.620  -->  00:11:24.140
That is, 32,768.
201

201

00:11:24.140  -->  00:11:30.770
So we then just keep dividing and
printing a zero or a one as appropriate
202

202

00:11:30.770  -->  00:11:34.650
before repeating with a remainder and
the next lowest powers of two.
203

203

00:11:34.650  -->  00:11:38.290
So we therefore need to loop from 15
down to zero to get the powers of two.
204

204

00:11:38.290  -->  00:11:42.720
So for our solution, what we're about to
do is boot up a list of the powers And
205

205

00:11:42.720  -->  00:11:45.110
we iterate through the list
to print the digits.
206

206

00:11:45.110  -->  00:11:48.170
So this could all be done in a single
loop if you wanted to, then.
207

207

00:11:48.170  -->  00:11:49.830
So let's actually make a start.
208

208

00:11:49.830  -->  00:11:50.790
We'll make a bit of space here.
209

209

00:11:52.930  -->  00:11:57.640
Okay, so we're gonna start by
typing powers, create a list.
210

210

00:11:57.640  -->  00:11:58.480
Powers in empty.
211

211

00:11:59.890  -->  00:12:03.190
And put for power in range.
212

212

00:12:06.600  -->  00:12:12.060
15, which is saying this is using the for
213

213

00:12:12.060  -->  00:12:14.270
loops and stepping and so
forth in previous videos.
214

214

00:12:14.270  -->  00:12:17.380
I'm gonna do powers.append.
215

215

00:12:17.380  -->  00:12:20.140
[SOUND] To, power.
216

216

00:12:20.140  -->  00:12:25.430
[INAUDIBLE]
So that's actually gonna build our lists.
217

217

00:12:25.430  -->  00:12:28.720
So in other words, what it should be
doing is actually giving us 32,768,
218

218

00:12:28.720  -->  00:12:31.000
16,384 and right on down to three to one.
219

219

00:12:31.000  -->  00:12:35.120
I'm gonna actually try that
to see that it's working,
220

220

00:12:35.120  -->  00:12:36.390
by doing a print [INAUDIBLE].
221

221

00:12:36.390  -->  00:12:38.530
So let's do that first to
make sure it's working.
222

222

00:12:38.530  -->  00:12:43.890
And you can see that's working so
223

223

00:12:43.890  -->  00:12:46.740
that's our list which is
working containing our powers.
224

224

00:12:46.740  -->  00:12:47.690
So that's good so far.
225

225

00:12:48.900  -->  00:12:50.100
So let's continue on.
226

226

00:12:50.100  -->  00:12:52.730
Now what we want to do is allow
the user to talk a number.
227

227

00:12:52.730  -->  00:12:58.500
So X equal int(input)
Please enter a number.
228

228

00:12:58.500  -->  00:13:04.090
[SOUND]
And
229

229

00:13:04.090  -->  00:13:07.080
what we need to do is actually
circle through each of our powers.
230

230

00:13:07.080  -->  00:13:09.300
So basically eat right through
the list now to print the digits.
231

231

00:13:09.300  -->  00:13:14.800
To do that you can type for
power in powers.
232

232

00:13:14.800  -->  00:13:15.710
We're going through the list.
233

233

00:13:18.130  -->  00:13:23.390
Print x, x being the number that has been
entered by the user, integer division for
234

234

00:13:23.390  -->  00:13:30.470
power and end equals like so
cuz you want it all on the one
235

235

00:13:30.470  -->  00:13:34.520
line we don't wanna move to the next
line and we put x to find the remainder.
236

236

00:13:36.440  -->  00:13:36.940
Power.
237

237

00:13:38.300  -->  00:13:41.940
So if we actually run this now, and
let's just try to the value ten.
238

238

00:13:43.230  -->  00:13:47.180
We can see we've got the binary equivalent
of one, zero, one, zero binary.
239

239

00:13:47.180  -->  00:13:52.320
And of course, working that out,
we've got a zero in the first digit
240

240

00:13:52.320  -->  00:13:55.260
The right most bit if you
will of the binary number.
241

241

00:13:55.260  -->  00:13:57.760
We've got a one and
that's the value of two there.
242

242

00:13:57.760  -->  00:14:02.690
Then moving over we've got over here
the other one and that's two times two,
243

243

00:14:02.690  -->  00:14:04.410
which is four times two is eight.
244

244

00:14:04.410  -->  00:14:06.210
So eight plus two is ten.
245

245

00:14:06.210  -->  00:14:09.940
So you can see our binary converters
actually working just fine.
246

246

00:14:09.940  -->  00:14:11.710
We mentioned an optional challenge.
247

247

00:14:11.710  -->  00:14:16.310
So we consider flag once when we
hit a non zero value to print.
248

248

00:14:16.310  -->  00:14:19.320
And we don't actually want to print
anything until that flag is set.
249

249

00:14:19.320  -->  00:14:22.690
The way we can do that is we can modify
that here, so power in powers, and
250

250

00:14:22.690  -->  00:14:28.290
up here we're going to put bit equals x,
integer division divided by power.
251

251

00:14:28.290  -->  00:14:33.450
And then we'll put if
bit is not equal to zero
252

252

00:14:35.380  -->  00:14:38.800
printing is equal to true.
253

253

00:14:40.580  -->  00:14:44.690
Then here, what we'll do is we'll
put if printing [INAUDIBLE]
254

254

00:14:44.690  -->  00:14:45.250
print, but
255

255

00:14:45.250  -->  00:14:48.350
instead of doing the division again
we'll just use bit at this point
256

256

00:14:48.350  -->  00:14:51.940
because we've already done
the integer division on line 43.
257

257

00:14:52.960  -->  00:14:57.320
Like so and that should now remove
the leading zeros because we're actually
258

258

00:14:57.320  -->  00:15:00.980
not printing anything until we get
a non zero value the first time.
259

259

00:15:00.980  -->  00:15:02.740
We're setting printing to true.
260

260

00:15:02.740  -->  00:15:04.820
Of course it can be good practice printing
261

261

00:15:06.700  -->  00:15:09.430
equals false before we
start the loop as well.
262

262

00:15:09.430  -->  00:15:12.370
We run that and
we get to the number ten again.
263

263

00:15:14.330  -->  00:15:17.760
We're now left with one zero one
zero which is again is the bond
264

264

00:15:17.760  -->  00:15:21.450
unit of decimal ten minus the zeros,
the leading zeros.
265

265

00:15:21.450  -->  00:15:25.790
And you look at that and you think that
works, and it mostly does the example I
266

266

00:15:26.900  -->  00:15:31.170
typed in it does but you should always
test what are called boundary conditions.
267

267

00:15:31.170  -->  00:15:34.480
Now, these are boundaries that are at
the extreme of allowing importance.
268

268

00:15:34.480  -->  00:15:36.360
So testing with the highest
number allowed.
269

269

00:15:36.360  -->  00:15:38.740
65535, so we run it.
270

270

00:15:38.740  -->  00:15:39.340
65535.
271

271

00:15:39.340  -->  00:15:46.900
That works fine with all 1's remembering
that that's the maximum number There.
272

272

00:15:46.900  -->  00:15:49.150
That we're allowed in this conversion.
273

273

00:15:49.150  -->  00:15:53.590
But, if we run it again and
it's a zero, we get nothing.
274

274

00:15:53.590  -->  00:15:56.110
And of course zero is
a valid binary number.
275

275

00:15:56.110  -->  00:15:57.080
So, how do we fix that?
276

276

00:15:57.080  -->  00:15:59.220
Well, the cure is to alter our tests so
277

277

00:15:59.220  -->  00:16:02.330
that we're actually setting printing
to true as we can see on line 47.
278

278

00:16:02.330  -->  00:16:05.520
But we want to actually test that.
279

279

00:16:05.520  -->  00:16:07.070
Bit is not equal to zero.
280

280

00:16:07.070  -->  00:16:09.560
Or that we're processing the last power.
281

281

00:16:09.560  -->  00:16:13.880
In other words, processing the very
last digit if you will on r in binary.
282

282

00:16:13.880  -->  00:16:17.960
So you can put all power is equal to 1.
283

283

00:16:17.960  -->  00:16:19.680
First you run that.
284

284

00:16:19.680  -->  00:16:24.690
Then we type 0, which you get a 0 chart
which is correct cause the last power.
285

285

00:16:24.690  -->  00:16:29.210
Was calculated correctly and
our condition was actually
286

286

00:16:29.210  -->  00:16:32.990
executed because the power was one and
we hadn't had a zero up until then.
287

287

00:16:32.990  -->  00:16:36.120
The 65535 should still work as
you can see on the screen there.
288

288

00:16:36.120  -->  00:16:39.810
The other you can do if you wanted
to is you can play around with this
289

289

00:16:39.810  -->  00:16:43.740
looking at line The line where we use 15.
290

290

00:16:43.740  -->  00:16:47.370
So what we could do here is we could
actually convert this to octal,
291

291

00:16:47.370  -->  00:16:47.870
our result.
292

292

00:16:47.870  -->  00:16:52.080
We could change the two here to
an eight because two was for binary.
293

293

00:16:52.080  -->  00:16:55.980
We could actually change that to an eight
to work in octal if we wanted to.
294

294

00:16:55.980  -->  00:16:57.820
And for efficiency,
you should also reduce the range.
295

295

00:16:57.820  -->  00:17:01.790
Because the highest power of 8 we're
now interested in is basically 262,144,
296

296

00:17:01.790  -->  00:17:04.560
which is greater than the highest
number we're allowing for binary.
297

297

00:17:04.560  -->  00:17:07.810
So play around with that, as well.
298

298

00:17:07.810  -->  00:17:08.390
And you can do.
299

299

00:17:08.390  -->  00:17:10.890
Do something similar by
converting it to octal.
300

300

00:17:10.890  -->  00:17:14.410
I'm gonna finish this video now but
leave you with something to think about.
301

301

00:17:14.410  -->  00:17:16.510
So we shouldn't have actually
written any code for this challenge.
302

302

00:17:16.510  -->  00:17:21.710
The specifications stated that the program
should be coded for numbers up to 65,5-
303

303

00:17:21.710  -->  00:17:26.170
35, but with that said [INAUDIBLE] which
would happen if a larger number is entered
304

304

00:17:26.170  -->  00:17:29.110
and there's also an assumption that
the numbers would be positive.
305

305

00:17:29.110  -->  00:17:31.900
The problem here was
the specification was inadequate.
306

306

00:17:31.900  -->  00:17:34.860
So, as programmers, we've got a duty of
care to the people we're programming for
307

307

00:17:34.860  -->  00:17:38.530
and if we give it a specification
that leaves such questions unanswered
308

308

00:17:38.530  -->  00:17:41.170
then we really need to go back
to whoever produced the spec and
309

309

00:17:41.170  -->  00:17:44.350
seek clarification before
producing any code.
310

310

00:17:44.350  -->  00:17:45.890
So that's it I am going
to end the video there.
311

311

00:17:45.890  -->  00:17:47.210
I hope that's been helpful to you.
312

312

00:17:47.210  -->  00:17:49.250
We will see you now in the next section.
