WEBVTT
1
00:00:00.210 --> 00:00:04.160
Next up we have three more operators that are extremely useful.

2
00:00:04.170 --> 00:00:05.750
You'll see them all the time.

3
00:00:05.790 --> 00:00:10.090
They're called logical operators and they're a bit different than what we've seen so far.

4
00:00:10.110 --> 00:00:13.530
They kind of modify other boolean expressions.

5
00:00:13.530 --> 00:00:20.220
So we've been writing conditionals that have a single expression inside of them like if x is less than

6
00:00:20.220 --> 00:00:27.940
10 that's it or if password dot length is greater than or equal to six.

7
00:00:28.230 --> 00:00:30.030
And we can get by doing that.

8
00:00:30.030 --> 00:00:34.710
But sometimes we want to write more complex expressions instead of these parents.

9
00:00:34.860 --> 00:00:37.530
And that's where these three operators come in.

10
00:00:37.530 --> 00:00:40.700
They might look a little funky if you're new to programming entirely.

11
00:00:40.800 --> 00:00:47.740
The three operators are called and or and not in the first one we'll take a look at who's called End

12
00:00:48.310 --> 00:00:52.800
and is created or written using two ampersand in a row.

13
00:00:52.800 --> 00:00:54.580
One ampersand is not going to cut it.

14
00:00:54.630 --> 00:00:56.250
We need two of them.

15
00:00:56.250 --> 00:01:02.760
And what it does is it takes two separate boolean expressions a left side and a right side they both

16
00:01:02.760 --> 00:01:10.530
evaluate to either true or false and the entire thing this entire line will only be true if both sides

17
00:01:10.680 --> 00:01:12.560
came out to be true.

18
00:01:12.600 --> 00:01:13.930
So there's a left and a right.

19
00:01:14.010 --> 00:01:21.180
And when you use and the whole expression is true only if both sides are true if one of them is false

20
00:01:21.420 --> 00:01:23.340
the entire thing is false.

21
00:01:23.370 --> 00:01:25.380
So here's a simple example.

22
00:01:25.380 --> 00:01:26.420
These are hardcoded.

23
00:01:26.490 --> 00:01:29.870
We know what the answers are is one less than or equal to four.

24
00:01:29.940 --> 00:01:31.160
Yes that's true.

25
00:01:31.170 --> 00:01:34.880
So we have true and and then is a equal to A.

26
00:01:34.890 --> 00:01:35.850
That's true.

27
00:01:35.850 --> 00:01:37.520
So we have true and true.

28
00:01:37.800 --> 00:01:39.450
And that gives us true.

29
00:01:39.510 --> 00:01:47.790
So in my console if I tried something like something really simple true and true gives me True true

30
00:01:47.790 --> 00:01:55.000
and false gives me false because one side is false it doesn't matter if it's a left or the right.

31
00:01:55.290 --> 00:01:58.610
If either is false the whole thing is considered false.

32
00:01:58.800 --> 00:02:06.060
So false and false is going to be false just like false and true is also false.

33
00:02:06.090 --> 00:02:10.200
So this is kind of useless other than just teaching how it works.

34
00:02:10.260 --> 00:02:18.870
Usually we have expressions like well this is still very silly but is one lesson or equal to two and

35
00:02:18.930 --> 00:02:20.490
five equals five.

36
00:02:21.060 --> 00:02:23.180
Well this part's true.

37
00:02:23.340 --> 00:02:24.340
This part is true.

38
00:02:24.390 --> 00:02:26.390
The whole thing is true.

39
00:02:26.490 --> 00:02:27.870
So that's the basics of.

40
00:02:27.870 --> 00:02:34.170
And in a vacuum without a conditional without realistic conditions you have two sides.

41
00:02:34.200 --> 00:02:37.390
Both sides have to be true for the whole thing to be true.

42
00:02:37.410 --> 00:02:43.440
So something like this is false because ABC dot link is three but one plus one is not equal to four

43
00:02:44.160 --> 00:02:45.380
one plus one is two.

44
00:02:45.720 --> 00:02:46.560
That is not four.

45
00:02:46.770 --> 00:02:48.660
So the whole thing is false.

46
00:02:48.690 --> 00:02:52.780
So here is a better example of when you would use something like this.

47
00:02:53.010 --> 00:02:57.960
Back when we were writing our first password checking example a couple sections or a couple of videos

48
00:02:57.960 --> 00:03:00.650
ago we had this right here.

49
00:03:01.080 --> 00:03:04.820
We were checking if password length is greater than or equal to six.

50
00:03:05.280 --> 00:03:10.350
And if it was we were checking if it contained a spacer if it did not contain a space.

51
00:03:10.380 --> 00:03:15.970
So in order to get a valid password we had two things that needed to happen.

52
00:03:16.110 --> 00:03:20.570
It had to be six characters or more and it could not include space.

53
00:03:20.580 --> 00:03:27.810
So we can achieve that logic by nesting two Fs or we can combine them into one statement like I have

54
00:03:27.810 --> 00:03:29.160
right here.

55
00:03:29.250 --> 00:03:30.560
This is only true.

56
00:03:30.570 --> 00:03:37.930
This entire line right here is only true if password length is greater than or equal to six and password

57
00:03:37.930 --> 00:03:42.040
but index of space is equal to negative 1.

58
00:03:42.240 --> 00:03:43.260
So we could try that out.

59
00:03:43.560 --> 00:03:44.730
We'll do something similar.

60
00:03:44.730 --> 00:03:45.980
We might tweak it just a bit.

61
00:03:46.290 --> 00:03:47.570
So we'll have password.

62
00:03:47.670 --> 00:03:49.260
We'll set it equal to chicken.

63
00:03:49.260 --> 00:03:53.190
Gal and then we'll write our conditional.

64
00:03:53.190 --> 00:04:03.120
So if password dot length is greater than or equal to let's go with eight this time and password dot

65
00:04:03.150 --> 00:04:04.140
index of

66
00:04:07.050 --> 00:04:08.880
I'll zoom out a bit.

67
00:04:09.030 --> 00:04:09.510
Password.

68
00:04:09.510 --> 00:04:16.690
Index of space is equal to negative one which means it does not exist in that password string.

69
00:04:16.800 --> 00:04:18.730
Then we'll counsel that log.

70
00:04:18.840 --> 00:04:20.880
Valid password.

71
00:04:20.880 --> 00:04:24.510
Otherwise we'll console that log invalid password

72
00:04:27.300 --> 00:04:28.220
cool.

73
00:04:28.670 --> 00:04:33.530
So we now have two pieces of logic combined into one statement.

74
00:04:33.530 --> 00:04:37.020
This entire thing has to be true in order to get a valid password.

75
00:04:37.310 --> 00:04:45.230
And I think our example we have does give us a valid password if we added a space and now we get invalid

76
00:04:45.440 --> 00:04:48.500
because this portion is false.

77
00:04:48.500 --> 00:04:53.070
So if all we need is a simple yes it's valid or no it's invalid.

78
00:04:53.330 --> 00:04:59.390
And this works great but if we compare that to what we had earlier we actually had specific feedback

79
00:04:59.450 --> 00:05:04.440
that said password cannot include spaces vs. password is too short.

80
00:05:04.490 --> 00:05:09.320
Right now we just have yes or no valid or invalid and that's shorter.

81
00:05:09.320 --> 00:05:15.020
It's easier to look at but if you need specific specific breakdown you need to differentiate between

82
00:05:15.080 --> 00:05:16.130
each piece.

83
00:05:16.130 --> 00:05:17.660
Then you probably want to nest.

84
00:05:17.660 --> 00:05:23.360
You don't want to have a boolean and but if you just need two things to be true or you can even do more

85
00:05:23.360 --> 00:05:27.140
than two you can combine multiple ends together and chain them.

86
00:05:27.140 --> 00:05:29.150
It just gets quite long for a single line.

87
00:05:29.240 --> 00:05:32.090
Anyway let's take a look at one more example.

88
00:05:32.090 --> 00:05:37.550
Another common use case for end is to check if a number is within a specified range.

89
00:05:37.760 --> 00:05:43.040
So let's say we're asking a user to guess or to pick a number from 1 to 10 and we want to make sure

90
00:05:43.040 --> 00:05:45.120
it's between 1 and 10.

91
00:05:45.380 --> 00:05:47.620
So we'll define that num.

92
00:05:47.630 --> 00:05:56.870
Let's set it to 3 to start and we'll check if num is greater than or equal to 1 at eleven.

93
00:05:56.870 --> 00:05:59.450
That's one part but that's not it.

94
00:05:59.450 --> 00:06:03.400
Because we could have ninety nine that's greater than or equal to 1.

95
00:06:03.470 --> 00:06:10.500
So we also add in our and num is less than or equal to 10.

96
00:06:10.520 --> 00:06:18.320
We could also rewrite this as less than 11 although that would allow somebody to have ten point three.

97
00:06:18.440 --> 00:06:22.670
So we can't assume that it's going to be a whole number.

98
00:06:22.670 --> 00:06:24.850
So I'm going to go back to less than or equal to 10.

99
00:06:25.100 --> 00:06:30.970
So this is now saying if a number is greater than or equal to 1 and less than or equal to 10.

100
00:06:31.130 --> 00:06:35.580
Essentially if it's between 1 and 10 then that's a valid guess.

101
00:06:35.630 --> 00:06:39.640
Consider log number is between 1 and 10.

102
00:06:39.650 --> 00:06:40.370
So here we go.

103
00:06:40.400 --> 00:06:43.630
I've just flushed it out with our else and a console log.

104
00:06:43.640 --> 00:06:50.410
If we tested out or commented out the original code and refresh we get number is between 1 and 10.

105
00:06:50.600 --> 00:06:52.650
We change it to 30.

106
00:06:52.850 --> 00:06:57.070
It doesn't work if we change it to 1.

107
00:06:57.260 --> 00:06:58.490
Does it work.

108
00:06:58.490 --> 00:06:58.810
Yes.

109
00:06:58.820 --> 00:06:59.990
Number is between 1 and 10.

110
00:06:59.990 --> 00:07:01.250
And so on.

111
00:07:01.250 --> 00:07:05.420
So that's another situation where you can use and it comes up all the time.

112
00:07:05.420 --> 00:07:11.000
Often you have multiple conditions you need to check for in order to run code you can nest things but

113
00:07:11.000 --> 00:07:15.890
sometimes it makes sense to put them together using boolean and or logical and.
