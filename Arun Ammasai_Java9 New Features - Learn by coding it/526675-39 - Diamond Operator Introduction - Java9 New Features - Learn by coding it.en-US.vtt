WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.550
Hello everyone, Welcome back.

00:00:02.550 --> 00:00:04.365
As a part of Java 9,

00:00:04.365 --> 00:00:09.435
there is another important announcement which is in diamond operator.

00:00:09.435 --> 00:00:11.670
So before we are jumping in a diamond operator,

00:00:11.670 --> 00:00:17.025
we should know what is diamond operator and a weight is came into the picture.

00:00:17.025 --> 00:00:19.365
And where do we need them?

00:00:19.365 --> 00:00:23.085
So you feel familiar with arrays and collection on genetics.

00:00:23.085 --> 00:00:25.800
You can skip this particular session.

00:00:25.800 --> 00:00:27.790
Let's move on.

00:00:29.410 --> 00:00:32.405
So when you're talking about collection or genetics,

00:00:32.405 --> 00:00:35.570
the first thing which we need to know way they came,

00:00:35.570 --> 00:00:37.190
okay, so the first thing is arrays,

00:00:37.190 --> 00:00:39.800
you need to know what is our race and what is collection.

00:00:39.800 --> 00:00:43.850
Let's check out some theoretical ways are a and Y is

00:00:43.850 --> 00:00:46.190
collection and what is generics and

00:00:46.190 --> 00:00:48.980
what did happen in Java 7 on what happened in challenge.

00:00:48.980 --> 00:00:51.680
The first thing we need to know what is

00:00:51.680 --> 00:00:54.740
arrays and what is collection, and why do we need array?

00:00:54.740 --> 00:00:56.000
I know where you need a collection.

00:00:56.000 --> 00:00:59.180
The first thing when you're using type, right?

00:00:59.180 --> 00:01:01.385
So in arrays it's constant.

00:01:01.385 --> 00:01:04.115
When you're defining an array, array of string,

00:01:04.115 --> 00:01:07.070
it always accepts string alone.

00:01:07.070 --> 00:01:08.660
If you're trying to add something else,

00:01:08.660 --> 00:01:12.110
we will end up with an issue we will talk about in our simple example.

00:01:12.110 --> 00:01:13.550
But in the similar scenario,

00:01:13.550 --> 00:01:14.855
in case of collection,

00:01:14.855 --> 00:01:16.070
it is not type safety.

00:01:16.070 --> 00:01:18.185
If you're creating a collection,

00:01:18.185 --> 00:01:21.290
a list, it can accept any kind of data.

00:01:21.290 --> 00:01:22.700
It may accept integer,

00:01:22.700 --> 00:01:26.075
string or double or any user defended tools.

00:01:26.075 --> 00:01:29.525
So the type safety is available in arrays,

00:01:29.525 --> 00:01:33.215
the types it is not available in collection till on buying fine.

00:01:33.215 --> 00:01:36.020
And RAs is reliable.

00:01:36.020 --> 00:01:38.780
Because if you add some wrong data,

00:01:38.780 --> 00:01:42.710
the compile time itself, it will throw an error.

00:01:42.710 --> 00:01:45.785
But in a collection it acts or any kind of data.

00:01:45.785 --> 00:01:47.690
So there is no relay level 2 there.

00:01:47.690 --> 00:01:51.005
So when you're running the code, you might end up with an issue.

00:01:51.005 --> 00:01:54.155
And that is tightly coupled, dissimilar.

00:01:54.155 --> 00:01:56.930
The collection is not tightly coupled

00:01:56.930 --> 00:01:59.660
because that can cause anything or any kind of data, right?

00:01:59.660 --> 00:02:01.565
So that's the loosely-coupled.

00:02:01.565 --> 00:02:05.795
And if anything wrong, rays will do compelled dimmer.

00:02:05.795 --> 00:02:07.880
So you cannot compel the code itself.

00:02:07.880 --> 00:02:11.000
But in collection, it won't

00:02:11.000 --> 00:02:15.410
show any error to say because it is accelerated any kind of data,

00:02:15.410 --> 00:02:17.735
we will not get any issues.

00:02:17.735 --> 00:02:19.460
We will take a look at a simple example,

00:02:19.460 --> 00:02:21.830
how our days and our collection is going to 0.

00:02:21.830 --> 00:02:26.030
And another important thing so I had is I have a collection,

00:02:26.030 --> 00:02:28.099
why I need to go for generics.

00:02:28.099 --> 00:02:29.015
Okay.

00:02:29.015 --> 00:02:30.770
Subdue on pine for in collection.

00:02:30.770 --> 00:02:32.345
We don't have the type safety right?

00:02:32.345 --> 00:02:34.625
To enables type safety.

00:02:34.625 --> 00:02:37.039
We are regard generics.

00:02:37.039 --> 00:02:38.660
So when you use generics,

00:02:38.660 --> 00:02:41.690
we should be able to maintain the type safety.

00:02:41.690 --> 00:02:46.265
Ren, and that's another thing resolving typecasting.

00:02:46.265 --> 00:02:48.140
So what is reserved and typecasting?

00:02:48.140 --> 00:02:50.165
Because we know that the collection,

00:02:50.165 --> 00:02:52.025
it will accept any kind of data.

00:02:52.025 --> 00:02:55.444
So whenever you're trying to read some data from a collection,

00:02:55.444 --> 00:02:57.500
we don't know what kind of data is going to come.

00:02:57.500 --> 00:03:03.770
So we have two typecasting always whatever the type is required.

00:03:03.770 --> 00:03:06.590
Right? So what is the diamond operator?

00:03:06.590 --> 00:03:10.920
So diamond operator is nothing but just a greater than n,

00:03:11.020 --> 00:03:15.620
greater than or less than simple reset diamond operator,

00:03:15.620 --> 00:03:17.090
it looks like a diamond, right?

00:03:17.090 --> 00:03:18.830
So basically what it is happening,

00:03:18.830 --> 00:03:22.295
you just basically just allowing compiler to infer the type of generic class.

00:03:22.295 --> 00:03:23.570
Just take a look at the first example.

00:03:23.570 --> 00:03:28.445
A list of string L1 is equal to new ArrayList String I had to provide.

00:03:28.445 --> 00:03:31.715
It is going to be a list of string and the new URL is going to be a string.

00:03:31.715 --> 00:03:37.550
So I need to specify the type again in the initialization, right?

00:03:37.550 --> 00:03:41.090
But take a second example is stuff string L di dt equals new ArrayList.

00:03:41.090 --> 00:03:42.665
That diamond operator.

00:03:42.665 --> 00:03:43.685
That's all.

00:03:43.685 --> 00:03:45.050
I don't have to defend.

00:03:45.050 --> 00:03:48.080
So it is going to be a string because I defined in list of strings.

00:03:48.080 --> 00:03:52.685
So that will indirectly infer the type to an ArrayList.

00:03:52.685 --> 00:03:57.030
So that is why the diamond operator comes into place in Java 7.

00:03:58.690 --> 00:04:05.550
So what does announcement AND operator diamond diamond operators in Java nine?

00:04:05.590 --> 00:04:08.405
Basically before Java nine,

00:04:08.405 --> 00:04:11.345
we can use diamond operator,

00:04:11.345 --> 00:04:16.235
but it cannot be used in anonymous classes by Java en

00:04:16.235 --> 00:04:19.100
enhance the capability to using

00:04:19.100 --> 00:04:22.415
the anonymous class is we will create a simple example for that.

00:04:22.415 --> 00:04:24.770
And then you announce it.

00:04:24.770 --> 00:04:27.125
When you're using the anonymous class,

00:04:27.125 --> 00:04:30.185
it'll be simplified and more readability.

00:04:30.185 --> 00:04:35.390
So the code looks simple and whoever is reading the code,

00:04:35.390 --> 00:04:37.145
it should be understandable.

00:04:37.145 --> 00:04:39.260
Right? So in the next video,

00:04:39.260 --> 00:04:40.850
I'm gonna show you a simple example of

00:04:40.850 --> 00:04:43.640
arrays collection and why we need to go from arrays to

00:04:43.640 --> 00:04:48.245
collection and collection to generics and generics enhancement for the Java Man.

00:04:48.245 --> 00:04:49.920
Thank you.
