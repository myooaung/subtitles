WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.140 --> 00:00:03.375
Hello everyone, So welcome back.

00:00:03.375 --> 00:00:04.335
So on.

00:00:04.335 --> 00:00:06.630
Another important thing in Java nine,

00:00:06.630 --> 00:00:08.955
the stream API and enhancement.

00:00:08.955 --> 00:00:13.380
So the stream has been introduced in Java version 8.

00:00:13.380 --> 00:00:15.750
And it is a very big breakthrough how we are going to

00:00:15.750 --> 00:00:18.690
handle that data as a form of a collection.

00:00:18.690 --> 00:00:19.605
Okay?

00:00:19.605 --> 00:00:23.085
So and then a new method has been introduced.

00:00:23.085 --> 00:00:25.710
No nine motion so far.

00:00:25.710 --> 00:00:29.715
Now, if people are not aware of what is streaming and how it is working,

00:00:29.715 --> 00:00:34.215
Let's go to small example and how the stream is going to work.

00:00:34.215 --> 00:00:36.630
And was given a simple introduction about strings.

00:00:36.630 --> 00:00:40.155
And then we'll move on to do Java nine, APN, and spines.

00:00:40.155 --> 00:00:43.540
So let's talk about stream introduction and what are

00:00:43.540 --> 00:00:47.200
the extreme methods and some simple examples.

00:00:47.200 --> 00:00:49.525
And then we'll move on to the Java nine announcements.

00:00:49.525 --> 00:00:51.535
And as a part of the oven and announcements,

00:00:51.535 --> 00:00:54.100
what are the defaults matters and what are the static methods?

00:00:54.100 --> 00:00:55.855
We're going to talk about them.

00:00:55.855 --> 00:00:57.370
Right?

00:00:57.370 --> 00:01:02.080
So not only that, when we talk about a stream,

00:01:02.080 --> 00:01:04.135
so what is a string basically?

00:01:04.135 --> 00:01:05.650
So we thought a collection,

00:01:05.650 --> 00:01:07.300
we don't need a stream.

00:01:07.300 --> 00:01:09.055
So basically the code is conduction.

00:01:09.055 --> 00:01:11.260
So conduction is nothing but it is a group of objects.

00:01:11.260 --> 00:01:13.180
If you take a look at the first image,

00:01:13.180 --> 00:01:15.685
it contains a list of objects,

00:01:15.685 --> 00:01:19.630
are a group of objects which contains some number random numbers.

00:01:19.630 --> 00:01:22.105
We have a number 12, eight, right?

00:01:22.105 --> 00:01:24.840
So the collection which will contain the data.

00:01:24.840 --> 00:01:26.810
But what do you mean a DStream.

00:01:26.810 --> 00:01:31.010
So the same is basically work against to the collection.

00:01:31.010 --> 00:01:31.400
Okay.

00:01:31.400 --> 00:01:33.875
I mean, woke with the data,

00:01:33.875 --> 00:01:35.165
like processing the data.

00:01:35.165 --> 00:01:37.145
So what is the data contains and the collection?

00:01:37.145 --> 00:01:38.810
The stream will work with that.

00:01:38.810 --> 00:01:43.370
Okay, for example, I have a colloquium which has some random numbers and I want to

00:01:43.370 --> 00:01:47.720
filter the numbers are odd numbers are even numbers,

00:01:47.720 --> 00:01:50.000
so we can go further streams.

00:01:50.000 --> 00:01:52.235
But on another thing, when you're using streams,

00:01:52.235 --> 00:01:54.755
the original collection, it will not be impacted.

00:01:54.755 --> 00:01:57.695
So the data will not be changed.

00:01:57.695 --> 00:01:59.420
So the data remains the same.

00:01:59.420 --> 00:02:00.980
The stream, what will happen?

00:02:00.980 --> 00:02:02.090
It will take the collection,

00:02:02.090 --> 00:02:04.385
it'll open the stream out of the collection,

00:02:04.385 --> 00:02:07.350
and it will work with the stream data.

00:02:07.510 --> 00:02:12.740
Let's create a simple example and I'll tell you how the streams is looks

00:02:12.740 --> 00:02:17.570
like and what does some simple methods which are going to talk about, right?

00:02:17.570 --> 00:02:19.565
It's open Eclipse.

00:02:19.565 --> 00:02:21.995
So before we are jumping into that,

00:02:21.995 --> 00:02:23.750
so there are three important methods.

00:02:23.750 --> 00:02:25.400
The one is mapped metadata,

00:02:25.400 --> 00:02:33.905
or the first thing is filter and map and flatMap.

00:02:33.905 --> 00:02:36.680
These are the three major methods which we

00:02:36.680 --> 00:02:40.925
are looking into in Java it so what is the purpose of filter?

00:02:40.925 --> 00:02:43.655
Filter is nothing but, as I said,

00:02:43.655 --> 00:02:45.710
I have a random numbers and I'm filtering

00:02:45.710 --> 00:02:48.140
some data from the collection with the help of streams.

00:02:48.140 --> 00:02:49.985
So we can go for a filter.

00:02:49.985 --> 00:02:55.250
Filter which use up pretty good as a functional interface.

00:02:55.250 --> 00:02:56.540
And map.

00:02:56.540 --> 00:03:00.019
Map is not like it is HashMap.

00:03:00.019 --> 00:03:05.690
It will be converting data or transforming one kind of data to another kind of data.

00:03:05.690 --> 00:03:07.115
If you're getting a string value,

00:03:07.115 --> 00:03:09.170
it will convert the data into uppercase,

00:03:09.170 --> 00:03:11.360
R. Lowercase are based on user conditions,

00:03:11.360 --> 00:03:12.890
are based on our functions.

00:03:12.890 --> 00:03:19.240
So it will take function interface and the similar,

00:03:19.240 --> 00:03:21.670
the flatMap also search take the function interface,

00:03:21.670 --> 00:03:23.935
but where do we need to use a flat map?

00:03:23.935 --> 00:03:28.885
For example, when you have two list of integers and you want to combine them into one.

00:03:28.885 --> 00:03:30.655
So you can go for the flatMap.

00:03:30.655 --> 00:03:35.330
So flattening the objects that you can go for flatMap.

00:03:35.640 --> 00:03:38.050
So let me do one thing.

00:03:38.050 --> 00:03:41.515
Let me create a simple stream matter here.

00:03:41.515 --> 00:03:45.370
And then we'll move on from this place.

00:03:45.370 --> 00:03:48.730
Okay, So I'm going to have a list of names here.

00:03:48.730 --> 00:03:52.645
So let's draw string which contains names.

00:03:52.645 --> 00:03:56.410
So let me create a main method first.

00:03:56.410 --> 00:04:02.170
So here I have a list of names and contains few names in it.

00:04:02.170 --> 00:04:08.080
So I'm going to use a less chart of put some names here.

00:04:08.080 --> 00:04:18.055
Sam and say, okay,

00:04:18.055 --> 00:04:21.610
so I have a list of names.

00:04:21.610 --> 00:04:24.115
So I want to print the names.

00:04:24.115 --> 00:04:27.235
Linked contains greater than or equal to three.

00:04:27.235 --> 00:04:30.790
So if you are providing greater than or equal to three decimals, 0,

00:04:30.790 --> 00:04:34.390
1, 2, so the length is two, right?

00:04:34.390 --> 00:04:35.650
So let us start from 1, 2,

00:04:35.650 --> 00:04:37.255
3, right? So here 123.

00:04:37.255 --> 00:04:41.360
So Sam will not printer right?

00:04:42.640 --> 00:04:46.440
Open the stream against the collection.

00:04:46.930 --> 00:04:50.615
I'm going to use a normal stream, stream dot.

00:04:50.615 --> 00:04:52.610
And we're going to use a filter condition.

00:04:52.610 --> 00:04:56.435
So the filter is the one which will accept predicted as an input predicate is,

00:04:56.435 --> 00:04:57.845
it's not a complicated thing.

00:04:57.845 --> 00:05:01.415
Predicate is a condition which will return a true or false.

00:05:01.415 --> 00:05:05.570
So for now I'm going to use S and conditioning.

00:05:05.570 --> 00:05:10.430
I'm going to use S dot length greater than or equal to three.

00:05:10.430 --> 00:05:12.395
And then once the data received,

00:05:12.395 --> 00:05:18.275
I'm going to collect them as a list of collectors dot t2 list.

00:05:18.275 --> 00:05:22.580
So either you can collect the entire data into a list

00:05:22.580 --> 00:05:24.350
and you can print them or else you can directly

00:05:24.350 --> 00:05:27.335
open the loop and you can print the data here.

00:05:27.335 --> 00:05:29.330
I can number the next one here,

00:05:29.330 --> 00:05:31.115
so it'll be easy to read.

00:05:31.115 --> 00:05:32.840
So let's print the data here.

00:05:32.840 --> 00:05:36.035
System dot, I'm using them as a reference here.

00:05:36.035 --> 00:05:37.835
Print LN.

00:05:37.835 --> 00:05:41.720
So now let's run the code.

00:05:41.720 --> 00:05:44.090
So we've got Sam, Paul,

00:05:44.090 --> 00:05:45.725
and Nancy. So what happened?

00:05:45.725 --> 00:05:49.250
Okay, So the 123, so Sam is also contains the length of

00:05:49.250 --> 00:05:52.595
3 because I used greater than or equal to,

00:05:52.595 --> 00:05:54.980
okay, if I use greater than 30, the sample on calm.

00:05:54.980 --> 00:05:57.095
Okay, let's run it again.

00:05:57.095 --> 00:05:58.970
See now the sun has gone.

00:05:58.970 --> 00:06:04.085
So this filter is basically ignoring or skipping,

00:06:04.085 --> 00:06:08.290
or you can eliminating some data with the help of a predicate.

00:06:08.290 --> 00:06:15.170
Right? So let's finish here and we'll create another example.

00:06:15.170 --> 00:06:18.290
And we'll show you some random examples of streams,

00:06:18.290 --> 00:06:20.630
how to use streams with the integers,

00:06:20.630 --> 00:06:22.640
how to work with the stream and the strings,

00:06:22.640 --> 00:06:27.390
and we'll talk about it and then we'll move on to the enhancements.
