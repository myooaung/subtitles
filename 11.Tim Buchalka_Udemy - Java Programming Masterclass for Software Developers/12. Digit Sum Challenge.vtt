WEBVTT
1
1

00:00:04.410  -->  00:00:06.450
Alrighty, it's time for another
2

2

00:00:06.450  -->  00:00:08.940
challenge, so this is the digit sum
3

3

00:00:08.940  -->  00:00:12.059
challenge. So the challenge is to write a
4

4

00:00:12.059  -->  00:00:14.309
method with the name some digits the
5

5

00:00:14.309  -->  00:00:16.259
method name that's got one inter
6

6

00:00:16.259  -->  00:00:19.169
parameter with the name number. Now in
7

7

00:00:19.169  -->  00:00:21.269
terms of validation, if the parameter
8

8

00:00:21.269  -->  00:00:23.369
value is greater than or equal to ten
9

9

00:00:23.369  -->  00:00:25.619
then the method should process the
10

10

00:00:25.619  -->  00:00:27.689
number and processing here is done by
11

11

00:00:27.689  -->  00:00:30.330
returning the sum of all digits in that
12

12

00:00:30.330  -->  00:00:32.189
number if that's not the case if
13

13

00:00:32.189  -->  00:00:34.890
parameter is less than ten, we want to
14

14

00:00:34.890  -->  00:00:36.480
return negative one to indicate an
15

15

00:00:36.480  -->  00:00:38.790
invalid value. Now the numbers from zero
16

16

00:00:38.790  -->  00:00:41.370
through nine have one digit and that's
17

17

00:00:41.370  -->  00:00:42.570
the reason why we're not going to
18

18

00:00:42.570  -->  00:00:44.340
process them because we don't want to
19

19

00:00:44.340  -->  00:00:47.100
sum a single digit so that's real reason
20

20

00:00:47.100  -->  00:00:48.360
why we're returning negative one there
21

21

00:00:48.360  -->  00:00:51.390
but also if the number is negative, we
22

22

00:00:51.390  -->  00:00:53.010
also want to return negative one for
23

23

00:00:53.010  -->  00:00:55.230
negative numbers and it's an example
24

24

00:00:55.230  -->  00:00:56.910
there calling the method some digits
25

25

00:00:56.910  -->  00:00:59.969
with a value of 125 passed should return
26

26

00:00:59.969  -->  00:01:02.070
eight and that's because the three
27

27

00:01:02.070  -->  00:01:04.559
digits that make up the value 125 can be
28

28

00:01:04.559  -->  00:01:06.750
summed with one plus two plus five and
29

29

00:01:06.750  -->  00:01:09.300
that's value of eight and calling the
30

30

00:01:09.300  -->  00:01:11.580
method some digits one should return
31

31

00:01:11.580  -->  00:01:13.649
negative one as per the requirements
32

32

00:01:13.649  -->  00:01:15.509
listed above. So you want to add some
33

33

00:01:15.509  -->  00:01:17.190
code to the main method to test out the
34

34

00:01:17.190  -->  00:01:19.110
some digits method to determine that
35

35

00:01:19.110  -->  00:01:20.640
it's working correctly for both valid
36

36

00:01:20.640  -->  00:01:23.429
and invalid values passed as arguments.
37

37

00:01:23.429  -->  00:01:26.910
And as a hint here use n remainder ten
38

38

00:01:26.910  -->  00:01:29.399
to extract the least significant digit
39

39

00:01:29.399  -->  00:01:32.369
and use N equals n divided by ten to
40

40

00:01:32.369  -->  00:01:35.700
discard the least significant digit, so
41

41

00:01:35.700  -->  00:01:36.720
hopefully that will help you in
42

42

00:01:36.720  -->  00:01:38.429
determining how to go through and
43

43

00:01:38.429  -->  00:01:40.920
extract out individual digits and the
44

44

00:01:40.920  -->  00:01:42.899
method needs to be static like we've
45

45

00:01:42.899  -->  00:01:44.399
used for other methods so far in this
46

46

00:01:44.399  -->  00:01:47.340
course and I'm going to create the
47

47

00:01:47.340  -->  00:01:49.229
project in IntelliJ called digit sum
48

48

00:01:49.229  -->  00:01:51.479
challenge, you can download the challenge
49

49

00:01:51.479  -->  00:01:53.970
text for this challenge in the resources
50

50

00:01:53.970  -->  00:01:55.200
section on this video if you want to
51

51

00:01:55.200  -->  00:01:57.660
have that available to you to read.
52

52

00:01:57.660  -->  00:01:59.970
At this point in time now go ahead and try
53

53

00:01:59.970  -->  00:02:01.920
this out, pause the video and once you're
54

54

00:02:01.920  -->  00:02:03.360
finished come back and you can check out
55

55

00:02:03.360  -->  00:02:06.229
my solution, so pause the video now.
56

56

00:02:06.229  -->  00:02:08.069
Alright so how did you get on? Hopefully
57

57

00:02:08.069  -->  00:02:09.509
you managed to figure it out
58

58

00:02:09.509  -->  00:02:12.060
let's hop back into IntelliJ and go
59

59

00:02:12.060  -->  00:02:14.220
through this step by step, you can see
60

60

00:02:14.220  -->  00:02:16.020
here that I've already got my project
61

61

00:02:16.020  -->  00:02:18.330
created and I've got the main method
62

62

00:02:18.330  -->  00:02:22.230
also added to this class main as well.
63

63

00:02:22.230  -->  00:02:23.310
Alright so the first thing we need to do
64

64

00:02:23.310  -->  00:02:25.650
is to clear the method, so I'm going to
65

65

00:02:25.650  -->  00:02:27.090
this is the method we need to create
66

66

00:02:27.090  -->  00:02:28.980
these some digits method I'll put that
67

67

00:02:28.980  -->  00:02:31.470
below the main method I'm gonna type in
68

68

00:02:31.470  -->  00:02:34.140
private and once again private public or
69

69

00:02:34.140  -->  00:02:36.780
not typing either is acceptable for this
70

70

00:02:36.780  -->  00:02:38.850
solution and in time we'll go through
71

71

00:02:38.850  -->  00:02:40.920
that private and public and will mean I
72

72

00:02:40.920  -->  00:02:44.550
only use private static int because we
73

73

00:02:44.550  -->  00:02:46.740
want to return a sum then we need to
74

74

00:02:46.740  -->  00:02:48.930
return ability so method name is in some
75

75

00:02:48.930  -->  00:02:51.960
digits in parentheses int being the type
76

76

00:02:51.960  -->  00:02:54.090
of the parameter and the name being
77

77

00:02:54.090  -->  00:02:56.850
number, so that's the definition for our
78

78

00:02:56.850  -->  00:02:58.860
method then we're getting an error at the
79

79

00:02:58.860  -->  00:02:59.880
moment because we haven't returned
80

80

00:02:59.880  -->  00:03:00.900
anything and it's telling you some of
81

81

00:03:00.900  -->  00:03:02.850
got a missing return statement but we'll
82

82

00:03:02.850  -->  00:03:04.800
get to that but obviously the methods
83

83

00:03:04.800  -->  00:03:06.300
returning type int because we have to
84

84

00:03:06.300  -->  00:03:07.680
return the sum of all digits in the
85

85

00:03:07.680  -->  00:03:09.540
number, so this probably would have
86

86

00:03:09.540  -->  00:03:11.610
validate our parameter to make sure the
87

87

00:03:11.610  -->  00:03:13.440
numbers within array in the correct range
88

88

00:03:13.440  -->  00:03:16.110
and the simplest way to test this is to
89

89

00:03:16.110  -->  00:03:22.800
put if number is less than 10, I put a
90

90

00:03:22.800  -->  00:03:25.890
code block and return negative 1 there
91

91

00:03:25.890  -->  00:03:27.209
the good thing about that solution is it
92

92

00:03:27.209  -->  00:03:30.000
handles and make sure that the digits
93

93

00:03:30.000  -->  00:03:33.030
I've got that the number is going to be
94

94

00:03:33.030  -->  00:03:35.010
10 or higher but it also caters for
95

95

00:03:35.010  -->  00:03:36.209
negative numbers because obviously a
96

96

00:03:36.209  -->  00:03:37.830
negative number is going to be any
97

97

00:03:37.830  -->  00:03:39.239
number less than 10 anyway so that
98

98

00:03:39.239  -->  00:03:42.900
solves both our scenarios there.
99

99

00:03:42.900  -->  00:03:44.340
Alright so what we're going to do now is
100

100

00:03:44.340  -->  00:03:46.470
come up with a while loop but before we
101

101

00:03:46.470  -->  00:03:48.870
do that we need to define a variable
102

102

00:03:48.870  -->  00:03:50.580
that's kind of hold to some of the
103

103

00:03:50.580  -->  00:03:52.560
digits I'm going to call that sum and
104

104

00:03:52.560  -->  00:03:56.930
we'll define it with int sum equals 0.
105

105

00:03:56.930  -->  00:03:59.370
Alright now before we start with the
106

106

00:03:59.370  -->  00:04:01.500
while loop I just want to explain how
107

107

00:04:01.500  -->  00:04:03.540
we're going to extract the least
108

108

00:04:03.540  -->  00:04:05.820
significant digit, so let's say we've got
109

109

00:04:05.820  -->  00:04:08.340
the number 125 that number as we've
110

110

00:04:08.340  -->  00:04:10.260
established has got three digits one two
111

111

00:04:10.260  -->  00:04:13.170
and five so the first step is to extract
112

112

00:04:13.170  -->  00:04:15.299
the least significant digit in the
113

113

00:04:15.299  -->  00:04:18.209
number 125 and that in this case is the
114

114

00:04:18.209  -->  00:04:20.970
number five so to extract that digit we
115

115

00:04:20.970  -->  00:04:23.130
have to use the remainder operator, what
116

116

00:04:23.130  -->  00:04:24.360
I'm going to do is write a small comment
117

117

00:04:24.360  -->  00:04:28.289
here on screen to help visualize
118

118

00:04:28.289  -->  00:04:30.939
this sort of 125
119

119

00:04:30.939  -->  00:04:33.610
it's basically going to be 125 divided
120

120

00:04:33.610  -->  00:04:37.110
by 10 equals 12
121

121

00:04:37.110  -->  00:04:43.959
12 times 10 equals 120 so therefore 125
122

122

00:04:43.959  -->  00:04:47.589
take from 20 equals 5 so hopefully that
123

123

00:04:47.589  -->  00:04:48.639
should help you visualize what we're
124

124

00:04:48.639  -->  00:04:50.229
going to do so first we've got the
125

125

00:04:50.229  -->  00:04:52.419
number 125 using the remainder with 10
126

126

00:04:52.419  -->  00:04:55.179
we will get the number 5 and the reason
127

127

00:04:55.179  -->  00:04:58.059
for that is that 125 divided by 10 is 12
128

128

00:04:58.059  -->  00:05:01.569
this first part in here and then we know
129

129

00:05:01.569  -->  00:05:04.300
that 12 times 10 is 120
130

130

00:05:04.300  -->  00:05:07.209
so therefore 125 which we started with
131

131

00:05:07.209  -->  00:05:11.229
more as 120 equals 5 so that's the way
132

132

00:05:11.229  -->  00:05:13.629
to get the least significant digit but
133

133

00:05:13.629  -->  00:05:15.459
it also knows when we divide the number
134

134

00:05:15.459  -->  00:05:18.879
by 10 we would usually get 12.5 but
135

135

00:05:18.879  -->  00:05:20.949
since this is an int number the decimal
136

136

00:05:20.949  -->  00:05:22.869
place is discarded so we're actually
137

137

00:05:22.869  -->  00:05:25.589
dropping the least significant digit.
138

138

00:05:25.589  -->  00:05:27.939
So let's write our while loop so it's
139

139

00:05:27.939  -->  00:05:32.110
going to be while and the while condition
140

140

00:05:32.110  -->  00:05:34.539
is going to be number is greater than
141

141

00:05:34.539  -->  00:05:37.269
zero, so you might be wondering at this
142

142

00:05:37.269  -->  00:05:39.249
point why number greater than zero is
143

143

00:05:39.249  -->  00:05:41.079
the condition well this is because we
144

144

00:05:41.079  -->  00:05:43.539
have to divide the number by 10 to drop
145

145

00:05:43.539  -->  00:05:45.309
the digit and once we've dropped all
146

146

00:05:45.309  -->  00:05:47.800
digits the number will become zero, so in
147

147

00:05:47.800  -->  00:05:48.839
other words we want to keep looping
148

148

00:05:48.839  -->  00:05:51.180
while the number is greater than zero
149

149

00:05:51.180  -->  00:05:53.769
for example we've got the number 125
150

150

00:05:53.769  -->  00:05:55.959
like in the comment when we first
151

151

00:05:55.959  -->  00:05:58.059
divided by 10 we get the number 12 then
152

152

00:05:58.059  -->  00:05:59.619
again the next iteration of the loop we
153

153

00:05:59.619  -->  00:06:01.779
divided by 10 we'll get the number 1 and
154

154

00:06:01.779  -->  00:06:04.449
once more dividing by 10 so the last one
155

155

00:06:04.449  -->  00:06:06.490
is going to be 1 divided by 10 we'll get
156

156

00:06:06.490  -->  00:06:09.069
0 so when we get to 0 the loop will exit
157

157

00:06:09.069  -->  00:06:10.929
since the condition is no longer true at
158

158

00:06:10.929  -->  00:06:12.279
that point so that's why we're testing
159

159

00:06:12.279  -->  00:06:14.409
and continuing the loop while the number
160

160

00:06:14.409  -->  00:06:16.749
is greater than 0. So the first step in
161

161

00:06:16.749  -->  00:06:17.949
the loop is to extract the least
162

162

00:06:17.949  -->  00:06:20.139
significant digit as I mentioned let's
163

163

00:06:20.139  -->  00:06:21.849
make a point about that first I'll make
164

164

00:06:21.849  -->  00:06:24.300
a note about that so we want to extract
165

165

00:06:24.300  -->  00:06:30.009
the least significant digit that's going
166

166

00:06:30.009  -->  00:06:34.389
to be int digit equals number using the
167

167

00:06:34.389  -->  00:06:38.169
remainder operator 10, right so the next
168

168

00:06:38.169  -->  00:06:40.029
step in is to add the digit to the sum,
169

169

00:06:40.029  -->  00:06:42.810
to do that we can put sum
170

170

00:06:42.810  -->  00:06:47.409
plus equals digit this sums our variable
171

171

00:06:47.409  -->  00:06:49.569
that we've defined on 115 outside of the while
172

172

00:06:49.569  -->  00:06:51.969
loop. Now the last step in the
173

173

00:06:51.969  -->  00:06:54.009
while loop is to increment so in other
174

174

00:06:54.009  -->  00:06:56.379
words to do an iteration step, so the
175

175

00:06:56.379  -->  00:06:58.599
goal is to drop the least significant
176

176

00:06:58.599  -->  00:07:00.699
digit and to drop it as described
177

177

00:07:00.699  -->  00:07:02.500
previously and in the hint we just
178

178

00:07:02.500  -->  00:07:04.750
needed to divide the number by 10, so in
179

179

00:07:04.750  -->  00:07:07.750
case in the case of the number 125 when
180

180

00:07:07.750  -->  00:07:10.719
we divide it with 10, we get 12 since
181

181

00:07:10.719  -->  00:07:12.159
we're using an int the decimal places
182

182

00:07:12.159  -->  00:07:13.599
are dropped, so in other words we can say
183

183

00:07:13.599  -->  00:07:15.400
the least significant digit at this
184

184

00:07:15.400  -->  00:07:17.319
point is dropped so I'm going to add a
185

185

00:07:17.319  -->  00:07:19.530
comment to that effect
186

186

00:07:19.530  -->  00:07:28.150
drop the least significant digit and the
187

187

00:07:28.150  -->  00:07:31.449
way we do that we put a number divided
188

188

00:07:31.449  -->  00:07:34.120
by equals 10 in case you're wondering
189

189

00:07:34.120  -->  00:07:36.069
that's an equivalent line to topping
190

190

00:07:36.069  -->  00:07:38.620
number equals number divided by 10
191

191

00:07:38.620  -->  00:07:40.240
you may not have seen that very often
192

192

00:07:40.240  -->  00:07:42.819
that's the shortcut for that it was
193

193

00:07:42.819  -->  00:07:46.569
quite a bit of text is a mess. Alright
194

194

00:07:46.569  -->  00:07:48.610
so that's literally it for our while loop.
195

195

00:07:48.610  -->  00:07:50.409
So the last step we want to do which is
196

196

00:07:50.409  -->  00:07:52.539
outside of the while loop is to return
197

197

00:07:52.539  -->  00:07:56.009
the sum so outside of the while loop,
198

198

00:07:56.009  -->  00:08:03.370
we're going to type a return sum so
199

199

00:08:03.370  -->  00:08:05.199
that's all there is for this method so
200

200

00:08:05.199  -->  00:08:07.029
now we have to test it out so in other
201

201

00:08:07.029  -->  00:08:08.440
words we've got to write some code in
202

202

00:08:08.440  -->  00:08:10.870
the main method that will call the
203

203

00:08:10.870  -->  00:08:12.729
method some digits to test out of our
204

204

00:08:12.729  -->  00:08:15.430
logic in the method is working as per
205

205

00:08:15.430  -->  00:08:17.949
the challenge text so in mine coming up
206

206

00:08:17.949  -->  00:08:21.669
to here what I'm going to do is put this
207

207

00:08:21.669  -->  00:08:23.650
out there we've got n double quotes sum
208

208

00:08:23.650  -->  00:08:30.639
of digits number 125 is a little bit
209

209

00:08:30.639  -->  00:08:34.329
make a little bit more readable the sum
210

210

00:08:34.329  -->  00:08:42.490
of the digits and then 125 is plus some
211

211

00:08:42.490  -->  00:08:48.149
digits and past 125 so if you run that
212

212

00:08:48.149  -->  00:08:50.260
you should hopefully get the answer 8
213

213

00:08:50.260  -->  00:08:54.520
here you can see we've got four there I
214

214

00:08:54.520  -->  00:08:56.399
put that down to the bottom
215

215

00:08:56.399  -->  00:08:59.379
sum of the digits in number 125 is 8, so
216

216

00:08:59.379  -->  00:09:01.300
that's working correctly so let's copy
217

217

00:09:01.300  -->  00:09:02.829
and paste that line a few times we'll
218

218

00:09:02.829  -->  00:09:04.389
try a few different values still another
219

219

00:09:04.389  -->  00:09:07.509
three we're just going to change the
220

220

00:09:07.509  -->  00:09:08.769
numbers here firstly the second I'm
221

221

00:09:08.769  -->  00:09:11.470
going to make that negative 125 the
222

222

00:09:11.470  -->  00:09:14.259
third one we're going to make five and
223

223

00:09:14.259  -->  00:09:15.519
the fourth one that's using the larger
224

224

00:09:15.519  -->  00:09:18.389
number three two one two three
225

225

00:09:18.389  -->  00:09:23.829
let's run all those. Okay as you can see
226

226

00:09:23.829  -->  00:09:25.870
for number 125 we've got the value of 8
227

227

00:09:25.870  -->  00:09:28.149
which is correct for the number 125
228

228

00:09:28.149  -->  00:09:29.949
will be negative 1 which is correct
229

229

00:09:29.949  -->  00:09:31.930
because it's an valid number we've
230

230

00:09:31.930  -->  00:09:33.730
determined we're not going to deal with
231

231

00:09:33.730  -->  00:09:35.410
negative numbers if you want to show it
232

232

00:09:35.410  -->  00:09:36.850
down here is change these values as well
233

233

00:09:36.850  -->  00:09:38.290
let's go ahead and do that it should
234

234

00:09:38.290  -->  00:09:40.569
really be there to make it more readable
235

235

00:09:40.569  -->  00:09:45.759
negative 125, make that 4 and for the
236

236

00:09:45.759  -->  00:09:49.829
last one we're gonna go with 32,000 123,
237

237

00:09:49.829  -->  00:09:51.899
just run that against how that the
238

238

00:09:51.899  -->  00:09:54.730
labels match up with the text that was passed on.
239

239

00:09:54.730  -->  00:09:57.550
Alright so negative 125 is negative 1
240

240

00:09:57.550  -->  00:09:59.740
which is correct because we determined
241

241

00:09:59.740  -->  00:10:01.389
here that any number less than 10 should
242

242

00:10:01.389  -->  00:10:02.290
return negative 1
243

243

00:10:02.290  -->  00:10:04.480
likewise for number 4 that should also
244

244

00:10:04.480  -->  00:10:07.089
return negative 1, sum of the digits 4 3
245

245

00:10:07.089  -->  00:10:10.389
2 1 2 3 is 11 we can calculate that by 3
246

246

00:10:10.389  -->  00:10:14.889
plus 2 is 5 1 is 6 2 is 8 3 is 11, so it
247

247

00:10:14.889  -->  00:10:17.019
seems that our solution is working
248

248

00:10:17.019  -->  00:10:19.509
correctly. So as you can see the tricky
249

249

00:10:19.509  -->  00:10:21.579
part here was to extract and drop the
250

250

00:10:21.579  -->  00:10:23.500
least significant digit I hope you've
251

251

00:10:23.500  -->  00:10:24.939
got a lot out of this challenge
252

252

00:10:24.939  -->  00:10:27.279
and that you managed to complete it and
253

253

00:10:27.279  -->  00:10:30.959
I'll see you now in the next video.
