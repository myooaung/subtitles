WEBVTT
1
1

00:00:05.170  -->  00:00:10.940
so in this video we are going to continue our
discussion on sets and what I've done is I've opened up
2

2

00:00:10.940  -->  00:00:15.320
the previous project that we've been
working on because ultimately in the
3

3

00:00:15.320  -->  00:00:18.670
challenge which will come in the next
video we are going to be using the heavenly
4

4

00:00:18.670  -->  00:00:21.990
bodies for that reason I'm creating
these files in this particular project
5

5

00:00:21.990  -->  00:00:27.280
I'm gonna create a new file to work on a
new main so we don't affect any other
6

6

00:00:27.280  -->  00:00:36.280
previous code so just normal create
a new class will call this one SetMain
7

7

00:00:36.280  -->  00:00:43.230
and I'm going to do a psvm and press tab to create our own main method like so
8

8

00:00:43.230  -->  00:00:48.010
we're going to do is finish of our
discussion on sets and we are gonna start by looking at
9

9

00:00:48.010  -->  00:00:51.350
the remaining mathematical operations
that are usually performed on them
10

10

00:00:51.350  -->  00:00:55.790
now we already seen in the previous video
how to create the union of two sets using
11

11

00:00:55.790  -->  00:00:59.540
the ad OR method now this is one of
what the oracle documentation
12

12

00:00:59.540  -->  00:01:03.800
called bulk operations that can be
performed on sets and what I'm going to do is
13

13

00:01:03.800  -->  00:01:09.090
just open that link up so you can have a
look paste this link which you can see on the screen
14

14

00:01:09.090  -->  00:01:15.540
and this is the documentation and looking
down the bottom of the page you can see
15

15

00:01:15.540  -->  00:01:19.570
that the bulk operations are described
here in detail in particular in
16

16

00:01:19.570  -->  00:01:23.650
sets when applied they perform
standard set algebraic operations
17

17

00:01:23.650  -->  00:01:28.430
I won't go into details on that now but you
can read up on that we're going
18

18

00:01:28.430  -->  00:01:32.960
to use some examples to look at how to
perform set intersection indifference as
19

19

00:01:32.960  -->  00:01:36.570
well as checking if one set is a super set
of another or whether the
20

20

00:01:36.570  -->  00:01:40.210
second set is a subset of the first
which effectively amounts to the same thing
21

21

00:01:40.210  -->  00:01:44.780
so what we going to do is start typing
some code and do check out that link
22

22

00:01:44.780  -->  00:01:48.680
it's got some interesting information in
there about bulk operations that are
23

23

00:01:48.680  -->  00:01:53.950
available for set so going back to the code
we are gonna start by creating 2 sets one is the
24

24

00:01:53.950  -->  00:01:58.150
set of all squares and the other is gonna be
set of all cubes of the numbers from 1 to
25

25

00:01:58.150  -->  00:02:06.420
100 what we're going to do is type....
26

26

00:02:06.420  -->  00:02:20.790
.....
27

27

00:02:20.790  -->  00:02:30.700
....and we're going to now
create the various values for both
28

28

00:02:30.700  -->  00:02:36.590
the first one to do is create first a for loop to loop through and process the
29

29

00:02:36.590  -->  00:02:45.760
numbers 1 to 100 so...
30

30

00:02:45.760  -->  00:02:51.980
.....to get the square
31

31

00:02:51.980  -->  00:02:58.060
of each element effectively or each preference of
i so the first time will be 1 x 1
32

32

00:02:58.060  -->  00:03:03.630
2 X 2, 3 X 3 etc then we are going to do cubes as well.....
33

33

00:03:03.630  -->  00:03:10.600
...so that's added those as you can see into
34

34

00:03:10.600  -->  00:03:13.640
our set so we now got a hundred
elements in each set and just to
35

35

00:03:13.640  -->  00:03:17.220
confirm that we can actually use the.size check if we have got we think we
36

36

00:03:17.220  -->  00:03:26.470
got in theri and we can come down here and put....
37

37

00:03:26.470  -->  00:03:31.980
.....
38

38

00:03:31.980  -->  00:03:48.230
...so run this program to
confirm that it does work
39

39

00:03:48.230  -->  00:03:52.950
100 squares and 100 cubes as we would expect now we already seen how to get the Union when we created the
40

40

00:03:52.950  -->  00:03:57.040
set of all moons in the solar system or at
least the ones that we typed in not
41

41

00:03:57.040  -->  00:04:01.110
everyone in the solar
system itself now because checking nearly
42

42

00:04:01.110  -->  00:04:05.180
200 numbers that will be printed in a
chaotic order is too much like hard work
43

43

00:04:05.180  -->  00:04:11.420
we are just gonna print the size of the resulting set
to confirm things are working so to do that so after
44

44

00:04:11.420  -->  00:04:24.410
the printout I'm gonna do... and what we are gonna be doing here
45

45

00:04:24.410  -->  00:04:30.940
is we are putting a parameter in their called squares which is going to add the first 100 or the elements from the
46

46

00:04:30.940  -->  00:04:35.300
square set into this one we are using that in the constructor so it initializes it
47

47

00:04:35.300  -->  00:04:43.340
with those values we are also going to use the add all....
48

48

00:04:43.340  -->  00:04:44.410
.....
49

49

00:04:44.410  -->  00:05:00.510
...and run that and the result is we get union
50

50

00:05:00.510  -->  00:05:06.000
contains a 196 elements now because this bulk operations are destructive what that
51

51

00:05:06.000  -->  00:05:09.780
means is that they modify the set that
called upon the program that we
52

52

00:05:09.780  -->  00:05:14.590
typed in created a new set containing
the members of squares on line 20 and
53

53

00:05:14.590  -->  00:05:18.440
then of course on line 21 we did the add all to add the cubes entries as well
54

54

00:05:18.440  -->  00:05:22.830
so just to confirm that nearly all the
collection classes have constructors that
55

55

00:05:22.830  -->  00:05:26.490
take another collection and use the
items in that to populate the new
56

56

00:05:26.490  -->  00:05:32.800
collection and that's why we did on line
20 and also created a new variable on line 20
57

57

00:05:32.800  -->  00:05:37.360
because bulk operations are destructive
which means they modify the set they are called upon
58

58

00:05:37.360  -->  00:05:39.460
so by creating a new hash set
59

59

00:05:39.460  -->  00:05:43.160
we are able to make sure that we are not affecting any
existing set that we've previously
60

60

00:05:43.160  -->  00:05:45.380
created so we use it initially too
61

61

00:05:45.380  -->  00:05:51.030
create passing squares to constructor for
hash set which added those entries and then
62

62

00:05:51.030  -->  00:05:56.490
using the .addall to add in the
entries from cubes as well and you've
63

63

00:05:56.490  -->  00:05:59.720
noticed when I run that we didn't get two
hundred elements we got a
64

64

00:05:59.720  -->  00:06:02.000
196 elements
65

65

00:06:02.000  -->  00:06:06.240
Unio contains 196 elements and we know that
the intersection must contain four
66

66

00:06:06.240  -->  00:06:09.960
elements as a result so let's create the
intersection to check that and then
67

67

00:06:09.960  -->  00:06:16.400
ultimately see the sum value in terms of
size for both should equal the total number of  elements we defined
68

68

00:06:16.400  -->  00:06:29.000
on line 11 and 12 or actually processed on line 14 and 16
so what we do we can type....
69

69

00:06:29.000  -->  00:06:51.410
.....
70

70

00:06:51.410  -->  00:06:59.050
...and lets go through and calculate this we are going to print the four
71

71

00:06:59.050  -->  00:07:04.270
values which themselves which will be very informative so we are gonna use a square root and CBRT methods
72

72

00:07:04.270  -->  00:07:10.300
of the math classes to show the square root and cube root of each elements to confirm that we are on track put....
73

73

00:07:10.300  -->  00:07:14.050
.....so lets go
74

74

00:07:14.050  -->  00:07:20.500
ahead and do that so put...for each to go through each
75

75

00:07:20.500  -->  00:07:33.090
element in the hash set...
76

76

00:07:33.090  -->  00:07:47.590
.....
77

77

00:07:47.590  -->  00:07:53.370
....and both of these methods returned
doubles which you would expect so if run
78

78

00:07:53.370  -->  00:08:04.880
that now and we need a space their so close that down and add a space run it again
79

79

00:08:04.880  -->  00:08:10.130
196 is a square of 64 on the cube of 16
1 is a of 1 and the cube of 1
80

80

00:08:10.130  -->  00:08:16.000
64 is a square of 8 and the cube of 4.0 729 is the square of 27 and the cube of 9 and that is the 4
81

81

00:08:16.000  -->  00:08:21.500
entries that are intersection so in set theory 2
differences are defined symmetric
82

82

00:08:21.500  -->  00:08:25.940
difference and asymmetric difference the
Java set interface defines a way to
83

83

00:08:25.940  -->  00:08:30.940
obtain the asymmetric difference of two
sets using the remove all bulk operation and
84

84

00:08:30.940  -->  00:08:35.570
that remove all elements in one set
from another now our current example has
85

85

00:08:35.570  -->  00:08:40.360
an intersection of four elements and a set size of 100 so
actually checking the results set will be
86

86

00:08:40.360  -->  00:08:44.560
extremely tedious so will switch to
smaller sets just to see removal in
87

87

00:08:44.560  -->  00:08:48.680
action and this is actually good time to look at
the interaction between the collections
88

88

00:08:48.680  -->  00:08:53.670
framework in Java arrays so that we can
use that to create our sets now the
89

89

00:08:53.670  -->  00:08:58.350
collections interface suggests that all
classes that implement collection should
90

90

00:08:58.350  -->  00:09:03.040
provide two stand constructors the first one
should take no arguments to create an
91

91

00:09:03.040  -->  00:09:06.560
empty collection and we've used that quite extensively
92

92

00:09:06.560  -->  00:09:10.610
but the other one takes a collection argument to
initialize new collection with all the
93

93

00:09:10.610  -->  00:09:13.910
items in the collection that is passed
to the constructor and of course we've
94

94

00:09:13.910  -->  00:09:18.150
used that in this code and talked about that
and seen it in previous lectures as well but
95

95

00:09:18.150  -->  00:09:22.130
this is only a suggestion because
interfaces do not have constructors so
96

96

00:09:22.130  -->  00:09:26.320
this behavior can't be enforced
for that reason but all the current
97

97

00:09:26.320  -->  00:09:30.400
collection implementations do this
currently and we've used it on early examples
98

98

00:09:30.400  -->  00:09:33.190
to initialize a set
before creating the union and
99

99

00:09:33.190  -->  00:09:38.330
intersection so the arrays class also
provides an (Arrays.)asList method that used to
100

100

00:09:38.330  -->  00:09:40.730
return a list view of the elements in
the array
101

101

00:09:40.730  -->  00:09:44.350
in fact it actually uses an ArrayList so
gonna type on some code that we can
102

102

00:09:44.350  -->  00:09:47.920
quickly get to the declaration of the
(Arrays.)asList method and then have a look at
103

103

00:09:47.920  -->  00:09:53.240
the comments for it so what I'm going to do
is below here start typing...and start
104

104

00:09:53.240  -->  00:10:01.940
with....
105

105

00:10:01.940  -->  00:10:12.540
....
106

106

00:10:12.540  -->  00:10:19.070
.....
107

107

00:10:19.070  -->  00:10:24.730
...using that as delimiter so we
108

108

00:10:24.730  -->  00:10:29.350
can get each word that's in a string and
as a separate entry in our string array then we are
109

109

00:10:29.350  -->  00:10:30.040
going to do
110

110

00:10:30.040  -->  00:10:38.910
......
111

111

00:10:38.910  -->  00:10:44.980
...which is our string array created on
112

112

00:10:44.980  -->  00:10:52.630
line 34 once we've done that we can do
something like this....
113

113

00:10:52.630  -->  00:11:03.560
.....going through each item
in the set and print it out
114

114

00:11:03.560  -->  00:11:08.620
...and run that to make sure it does work and of
115

115

00:11:08.620  -->  00:11:11.660
course we are not guaranteed for them to be in any
particular sorted order but you can see
116

116

00:11:11.660  -->  00:11:15.850
all the words are actually appearing on
the screen so it is working if you
117

117

00:11:15.850  -->  00:11:20.550
have a look at the (Arrays.)asList method go their and
click on it click
118

118

00:11:20.550  -->  00:11:24.290
on that we'll have a look
119

119

00:11:24.290  -->  00:11:27.960
first you can see this method and the
related to array
120

120

00:11:27.960  -->  00:11:33.450
method of collections are attended as a
bridge between the two API's so the (Arrays.)asList
121

121

00:11:33.450  -->  00:11:36.870
methods on the screen provides a
convenient way to initialize a
122

122

00:11:36.870  -->  00:11:41.660
collection with a list of values as there is still not set of literals in Java
123

123

00:11:41.660  -->  00:11:45.580
so that's what we're using it for in this
particular case now to see what remove
124

124

00:11:45.580  -->  00:11:50.020
old does and why it's called the
asymmetric difference this example
125

125

00:11:50.020  -->  00:11:55.520
creates two sets going back to the code
when it does it's going to create the
126

126

00:11:55.520  -->  00:12:01.500
asymmetric difference between those
two so the example creates 2 sets and calculates the asymmetry
127

127

00:12:01.500  -->  00:12:05.500
difference both ways around so it's
called a symmetric difference because
128

128

00:12:05.500  -->  00:12:11.110
set one takes set 2 is not the same as set
2 takes set 1 now a diagram is always useful
129

129

00:12:11.110  -->  00:12:15.980
for when dealing with sets so what I'm going
to do is bring up on the screen and the
130

130

00:12:15.980  -->  00:12:20.050
circle to the left in green represents
the set nature and the one the one on
131

131

00:12:20.050  -->  00:12:24.270
the right is divine so when they overlap it's
the intersection of the two sets and the
132

132

00:12:24.270  -->  00:12:29.320
set of everything in both is the Union
now the asymmetric difference nature take
133

133

00:12:29.320  -->  00:12:33.450
divine will contain all the green words
and divine take nature will contain the
134

134

00:12:33.450  -->  00:12:37.040
blue ones which is what the following
code we are about type in actually works
135

135

00:12:37.040  -->  00:12:45.630
out so bring the graphic back on the screen once we typed in the code so lets type...
136

136

00:12:45.630  -->  00:13:02.560
.....
137

137

00:13:02.560  -->  00:13:29.420
......
138

138

00:13:29.420  -->  00:14:08.640
.....
139

139

00:14:08.640  -->  00:14:20.470
...so we created those but lets add these as well so will do.....
140

140

00:14:20.470  -->  00:14:47.200
.....
141

141

00:14:47.200  -->  00:14:52.780
ok so lets add them both again using the same method and
again as list provides a convenient way
142

142

00:14:52.780  -->  00:14:56.460
to initialize a collection with a list
of values because of course there is still no
143

143

00:14:56.460  -->  00:15:02.220
set or map literals in Java so we sort
of simulated that by having array here you
144

144

00:15:02.220  -->  00:15:06.280
can see on the screen and we are using the add all and then .asList
145

145

00:15:06.280  -->  00:15:10.890
to convert ultimately we can get
those into the set in a convenient way
146

146

00:15:10.890  -->  00:15:14.760
so what I'm gonna do I'm
to stop this video here in the next video
147

147

00:15:14.760  -->  00:15:19.180
we're going to continue work on
this particular piece of code we want to go
148

148

00:15:19.180  -->  00:15:24.540
through and start looking at this set
asymmetric differences and talk more
149

149

00:15:24.540  -->  00:15:28.640
about that and ultimately explain this a bit more as well so
I'll see you in the next video
