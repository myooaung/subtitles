WEBVTT
1
1

00:00:04.890  -->  00:00:06.540
<v Tim>In the previous videos,</v>
2

2

00:00:06.540  -->  00:00:08.580
we've dealt with whole numbers
3

3

00:00:08.580  -->  00:00:11.120
and also with single and double-precision numbers.
4

4

00:00:11.120  -->  00:00:12.660
So, most recently, of course, we were dealing
5

5

00:00:12.660  -->  00:00:14.290
with the floating point numbers.
6

6

00:00:14.290  -->  00:00:15.990
In this video, we're going to talk about
7

7

00:00:15.990  -->  00:00:18.560
two additional primitive types in Java,
8

8

00:00:18.560  -->  00:00:22.330
the char, but also the Boolean primitive types.
9

9

00:00:22.330  -->  00:00:23.730
Now, as you can see, I've already created
10

10

00:00:23.730  -->  00:00:27.240
a new project on screen, and I've called it CharAndBoolean.
11

11

00:00:27.240  -->  00:00:29.690
And I also used the create template option
12

12

00:00:30.533  -->  00:00:32.730
so that we've got a class and a main method to use.
13

13

00:00:32.730  -->  00:00:35.640
So, go ahead and do that now if you're following along.
14

14

00:00:35.640  -->  00:00:38.760
So, I'm gonna start by deleting this comment.
15

15

00:00:38.760  -->  00:00:40.360
And I'm gonna tab over and press enter there,
16

16

00:00:40.360  -->  00:00:42.620
and you can see we've been indented by IntelliJ.
17

17

00:00:42.620  -->  00:00:45.700
And let's define our first char variable.
18

18

00:00:45.700  -->  00:00:47.940
So, I'm gonna type char, C-H-A-R,
19

19

00:00:47.940  -->  00:00:50.880
space, my_char is equal to,
20

20

00:00:50.880  -->  00:00:53.540
and then single quotes, and then the letter.
21

21

00:00:53.540  -->  00:00:54.680
I'm gonna put the letter D there.
22

22

00:00:54.680  -->  00:00:58.080
That could be any character, letter or number,
23

23

00:00:58.080  -->  00:01:00.320
and other characters, like an exclamation mark,
24

24

00:01:00.320  -->  00:01:03.350
a hash, an at sign, and so on.
25

25

00:01:03.350  -->  00:01:05.203
And a semicolon to complete the line.
26

26

00:01:06.120  -->  00:01:08.453
Now, the char is different to a string.
27

27

00:01:09.400  -->  00:01:12.160
Now, if you recall in the previous videos you've seen,
28

28

00:01:12.160  -->  00:01:14.290
we've used literal strings, and that's where
29

29

00:01:14.290  -->  00:01:16.770
we've typed some text in double quotes.
30

30

00:01:16.770  -->  00:01:18.870
We haven't really used a string variable yet,
31

31

00:01:18.870  -->  00:01:20.880
but we'll be doing that in upcoming videos.
32

32

00:01:20.880  -->  00:01:23.200
So, char is similar to the string in one sense
33

33

00:01:23.200  -->  00:01:25.750
in that you can store characters.
34

34

00:01:25.750  -->  00:01:29.090
But in this case, you can only store a single character.
35

35

00:01:29.090  -->  00:01:31.120
So, if we go back and try and add a second character here,
36

36

00:01:31.120  -->  00:01:34.740
like another D, you may not get an immediate error
37

37

00:01:34.740  -->  00:01:36.690
until you press enter, but you can see there are now
38

38

00:01:36.690  -->  00:01:39.490
too many characters in a character literal.
39

39

00:01:39.490  -->  00:01:41.710
So, it is literally only allowing us
40

40

00:01:41.710  -->  00:01:44.680
to actually save one character.
41

41

00:01:44.680  -->  00:01:46.783
So, I'll just delete that to make it valid.
42

42

00:01:47.920  -->  00:01:50.520
So, you might be wondering now, just how useful is it?
43

43

00:01:50.520  -->  00:01:53.190
Why would you want to use a variable
44

44

00:01:53.190  -->  00:01:55.700
that only allows you to store one character?
45

45

00:01:55.700  -->  00:01:58.080
Well, one example might be to store
46

46

00:01:58.080  -->  00:02:01.470
the last key pressed by a user in a game.
47

47

00:02:01.470  -->  00:02:02.680
And it could be other scenarios where
48

48

00:02:02.680  -->  00:02:04.830
you're just wanting to keep the last key pressed,
49

49

00:02:04.830  -->  00:02:07.720
or just the last single digit that's been used
50

50

00:02:07.720  -->  00:02:10.370
in a menu option, or something along those lines.
51

51

00:02:10.370  -->  00:02:11.860
Now, chars were much more relevant
52

52

00:02:11.860  -->  00:02:14.170
when Java was released in the late 1990s
53

53

00:02:14.170  -->  00:02:16.850
compared to today, with much faster computers
54

54

00:02:16.850  -->  00:02:17.920
that have got lots more memory.
55

55

00:02:17.920  -->  00:02:19.350
So, in these days, you don't need
56

56

00:02:19.350  -->  00:02:21.650
to focus so much on saving memory.
57

57

00:02:21.650  -->  00:02:22.980
'Cause another good use for chars
58

58

00:02:22.980  -->  00:02:25.920
would be to store data in arrays.
59

59

00:02:25.920  -->  00:02:28.110
But again, we haven't talked about arrays yet in the course,
60

60

00:02:28.110  -->  00:02:29.960
so we'll talk more about that a bit later.
61

61

00:02:29.960  -->  00:02:31.490
For now, though, keep in mind that if you're going
62

62

00:02:31.490  -->  00:02:34.370
to be using a char, you can literally only store
63

63

00:02:34.370  -->  00:02:38.320
a single character in a single char variable.
64

64

00:02:38.320  -->  00:02:40.740
Now, you might be looking at that thinking that,
65

65

00:02:40.740  -->  00:02:42.290
okay, I can only save one character,
66

66

00:02:42.290  -->  00:02:44.090
so therefore it must only occupy
67

67

00:02:44.090  -->  00:02:46.470
a single byte in memory because it's, again,
68

68

00:02:46.470  -->  00:02:48.310
one letter or digit, one character,
69

69

00:02:48.310  -->  00:02:50.000
if you will, that can be stored in it.
70

70

00:02:50.000  -->  00:02:53.000
Well, it turns out in terms of storage, that's not the case.
71

71

00:02:54.880  -->  00:02:58.230
So, a char primitive type in Java occupies two bytes
72

72

00:02:58.230  -->  00:03:02.300
of memory, or 16 bits, and thus has a width of 16.
73

73

00:03:02.300  -->  00:03:05.710
And I know I've been talking about width in other videos.
74

74

00:03:05.710  -->  00:03:08.320
The reason that it's not just a single byte
75

75

00:03:08.320  -->  00:03:11.283
is that it allows you to store Unicode characters.
76

76

00:03:12.680  -->  00:03:16.080
So, Unicode is an international encoding standard
77

77

00:03:16.080  -->  00:03:18.630
for use with different languages and scripts
78

78

00:03:18.630  -->  00:03:20.920
by which each letter, digit, or symbol
79

79

00:03:20.920  -->  00:03:23.690
is assigned a unique numeric value
80

80

00:03:23.690  -->  00:03:27.030
that applies across different platforms and programmes.
81

81

00:03:27.030  -->  00:03:29.170
Now, in the English alphabet, we've got the letters
82

82

00:03:29.170  -->  00:03:33.180
A through Z, meaning only 26 characters are needed in total
83

83

00:03:33.180  -->  00:03:35.410
to represent the entire English alphabet.
84

84

00:03:35.410  -->  00:03:37.610
But other languages need more characters,
85

85

00:03:37.610  -->  00:03:39.150
and often a lot more.
86

86

00:03:39.150  -->  00:03:41.230
Now, Unicode was developed to allow us
87

87

00:03:41.230  -->  00:03:45.110
to represent these languages in a common way on computers.
88

88

00:03:45.110  -->  00:03:46.810
So, the way that this work and equates back
89

89

00:03:46.810  -->  00:03:49.990
to the char character in Java is that it uses
90

90

00:03:49.990  -->  00:03:51.550
a combination of the two bytes
91

91

00:03:51.550  -->  00:03:53.270
that it's taking up in memory,
92

92

00:03:53.270  -->  00:03:54.780
and as a result, it can represent
93

93

00:03:54.780  -->  00:03:58.840
any one of 65,535 different types of characters.
94

94

00:03:58.840  -->  00:04:01.240
So, it's quite flexible with those two bytes.
95

95

00:04:01.240  -->  00:04:02.620
So, to see that in operation,
96

96

00:04:02.620  -->  00:04:04.313
let's swing back to our browser.
97

97

00:04:05.460  -->  00:04:06.950
All right, so I'm gonna go to a website called
98

98

00:04:06.950  -->  00:04:11.113
unicode-table.com.
99

99

00:04:13.378  -->  00:04:14.289
All right, and you can see there
100

100

00:04:14.289  -->  00:04:15.770
that we've got a lotta symbols on the screen.
101

101

00:04:15.770  -->  00:04:19.690
And if I scroll down, I got some ads there as well,
102

102

00:04:19.690  -->  00:04:21.480
unfortunately, but you can scroll down
103

103

00:04:21.480  -->  00:04:23.960
and you can see there's lots of different symbols.
104

104

00:04:23.960  -->  00:04:26.270
And these are all Unicode characters.
105

105

00:04:26.270  -->  00:04:27.983
And you can see there's a staggering amount of them.
106

106

00:04:27.983  -->  00:04:29.683
I would just give it time to load.
107

107

00:04:30.660  -->  00:04:31.827
Pages and pages, and as I'm scrolling down,
108

108

00:04:31.827  -->  00:04:33.720
that's actually generating more.
109

109

00:04:33.720  -->  00:04:35.570
So, I'll go back up to the top again,
110

110

00:04:37.300  -->  00:04:39.347
just to the first letters there
111

111

00:04:39.347  -->  00:04:42.500
You'll notice that the letter D's on the screen there.
112

112

00:04:42.500  -->  00:04:44.540
And notice that that's on the fourth row,
113

113

00:04:44.540  -->  00:04:46.790
and it's actually starting on the fourth column.
114

114

00:04:46.790  -->  00:04:50.530
So, to the left of that row containing the at sign
115

115

00:04:50.530  -->  00:04:55.530
and A, B, C, D, notice that it's got 0040, and in the column
116

116

00:04:55.620  -->  00:04:59.090
above the letter D, it's got the number four.
117

117

00:04:59.090  -->  00:05:01.630
So, a Unicode character is comprised
118

118

00:05:01.630  -->  00:05:04.920
of a code that we key into IntelliJ.
119

119

00:05:04.920  -->  00:05:06.180
So, to do that now in this case,
120

120

00:05:06.180  -->  00:05:08.640
we're going to type in 004.
121

121

00:05:08.640  -->  00:05:10.320
And if we were using the at character,
122

122

00:05:10.320  -->  00:05:13.110
we would leave it at zero, 'cause that would be 0040.
123

123

00:05:13.110  -->  00:05:16.230
But because it's the D, we replace the zero,
124

124

00:05:16.230  -->  00:05:18.970
this is the ending zero after 0040,
125

125

00:05:18.970  -->  00:05:20.183
with the letter in the column for D.
126

126

00:05:20.183  -->  00:05:22.190
So, you can see this at the top of the screen.
127

127

00:05:22.190  -->  00:05:23.320
It's four.
128

128

00:05:23.320  -->  00:05:26.780
So therefore the code we need is 0044.
129

129

00:05:26.780  -->  00:05:28.773
So, if we go back into IntelliJ,
130

130

00:05:30.330  -->  00:05:33.190
and we can actually type that Unicode character in.
131

131

00:05:33.190  -->  00:05:38.190
So, we can type char myUnicode is equal to.
132

132

00:05:39.140  -->  00:05:40.910
Now put the single quotes as we did before,
133

133

00:05:40.910  -->  00:05:43.650
but this time, because we're putting in a Unicode character,
134

134

00:05:43.650  -->  00:05:47.020
we need to put a \u and those four digits.
135

135

00:05:47.020  -->  00:05:50.010
In this case, it was 0044.
136

136

00:05:50.010  -->  00:05:50.843
All right, so then go to the end
137

137

00:05:50.843  -->  00:05:52.620
of the line and press enter there.
138

138

00:05:52.620  -->  00:05:53.840
Now we're going to print out the values.
139

139

00:05:53.840  -->  00:05:54.703
So, let's do that.
140

140

00:05:54.703  -->  00:05:57.353
We're doing a sout for myChar.
141

141

00:05:59.930  -->  00:06:02.657
Then we're doing a sout again for myUnicode.
142

142

00:06:04.390  -->  00:06:06.010
And let's actually run this programme
143

143

00:06:06.010  -->  00:06:09.150
just to make sure that it's actually working okay.
144

144

00:06:09.150  -->  00:06:10.960
Now, you can see there we've got D
145

145

00:06:10.960  -->  00:06:13.770
printing out twice in our output window.
146

146

00:06:13.770  -->  00:06:16.240
So clearly, the first representation on line seven
147

147

00:06:16.240  -->  00:06:18.530
is for a letter D, and we typed that in,
148

148

00:06:18.530  -->  00:06:20.530
but the Unicode character, if we were using
149

149

00:06:20.530  -->  00:06:23.890
a Unicode convention to assign to our character,
150

150

00:06:23.890  -->  00:06:27.070
is \u, which tells the Java compiler that it's
151

151

00:06:27.070  -->  00:06:28.960
a Unicode character, and then the code
152

152

00:06:28.960  -->  00:06:30.980
that you assume we come up with.
153

153

00:06:30.980  -->  00:06:32.670
So, we've got the same result by doing that.
154

154

00:06:32.670  -->  00:06:34.090
So, let's just find one other character
155

155

00:06:34.090  -->  00:06:35.130
to make sure that it's working.
156

156

00:06:35.130  -->  00:06:37.800
And we'll go back to our Unicode table.
157

157

00:06:37.800  -->  00:06:39.260
And we'll come down here to this one here,
158

158

00:06:39.260  -->  00:06:42.400
and you can see the row there with the copyright symbol.
159

159

00:06:42.400  -->  00:06:43.700
So, let's grab the code for that one.
160

160

00:06:43.700  -->  00:06:45.900
So, that's gonna be 00A.
161

161

00:06:45.900  -->  00:06:48.900
And there's the nine, which is above the copyright.
162

162

00:06:48.900  -->  00:06:50.000
So it's gonna be 00A9.
163

163

00:06:51.640  -->  00:06:54.270
So, let's go back to our code again.
164

164

00:06:54.270  -->  00:06:56.120
We'll define another one.
165

165

00:06:56.120  -->  00:06:58.363
We'll do a char myCopyrightChar
166

166

00:07:00.670  -->  00:07:03.280
is equal to, and we now single quotes,
167

167

00:07:03.280  -->  00:07:04.320
semicolon to end the line.
168

168

00:07:04.320  -->  00:07:06.170
And I'm going to do a \u00A9
169

169

00:07:09.160  -->  00:07:10.160
at the end of the line.
170

170

00:07:10.160  -->  00:07:13.040
And then we'll do an sout again, myCopyrightChar.
171

171

00:07:16.740  -->  00:07:18.390
And let's see whether that works.
172

172

00:07:20.850  -->  00:07:21.840
And there you can see on the screen
173

173

00:07:21.840  -->  00:07:23.330
there the copyright character.
174

174

00:07:23.330  -->  00:07:25.670
So, that's how to use Unicode if you're
175

175

00:07:25.670  -->  00:07:29.200
wanting to put that into a char, like as we've done here.
176

176

00:07:29.200  -->  00:07:30.550
And that's truly it for the char.
177

177

00:07:30.550  -->  00:07:31.620
We'll talk more about this later
178

178

00:07:31.620  -->  00:07:33.640
when we get to arrays, but for now,
179

179

00:07:33.640  -->  00:07:36.830
if you're needing to use a char, that's how you use one.
180

180

00:07:36.830  -->  00:07:40.473
And you now know also how to use Unicode.
181

181

00:07:41.630  -->  00:07:43.380
All right, now the second variable
182

182

00:07:43.380  -->  00:07:45.313
we wanna talk about is the Boolean.
183

183

00:07:47.100  -->  00:07:49.990
So, a Boolean value allows for two choices,
184

184

00:07:49.990  -->  00:07:52.440
true or false, yes or no, one or zero.
185

185

00:07:52.440  -->  00:07:55.750
In Java terms, we've got a Boolean primitive type,
186

186

00:07:55.750  -->  00:07:59.830
and it can be set to two values only, either true or false.
187

187

00:07:59.830  -->  00:08:01.820
Now, Booleans are pretty useful in Java
188

188

00:08:01.820  -->  00:08:03.210
and most programming languages,
189

189

00:08:03.210  -->  00:08:05.720
and you will use them a lot when you're programming.
190

190

00:08:05.720  -->  00:08:07.750
Now let's go back to the code.
191

191

00:08:07.750  -->  00:08:09.350
So, what I'm gonna do now is create
192

192

00:08:09.350  -->  00:08:10.610
a couple of Boolean variables.
193

193

00:08:10.610  -->  00:08:11.880
Let's go ahead and do that.
194

194

00:08:11.880  -->  00:08:13.230
So, I'm gonna type Boolean.
195

195

00:08:14.170  -->  00:08:16.830
I'll call our first one myTrueBooleanValue.
196

196

00:08:18.800  -->  00:08:19.910
And we'll assign that to be true.
197

197

00:08:19.910  -->  00:08:23.650
And we just type true in lowercase with a lowercase T,
198

198

00:08:23.650  -->  00:08:26.021
and into there, and we'll do the same on the next line,
199

199

00:08:26.021  -->  00:08:30.943
myFalseBooleanValue is equal to false.
200

200

00:08:31.840  -->  00:08:33.210
So, that can have one or two values,
201

201

00:08:33.210  -->  00:08:36.120
either be true or either be false.
202

202

00:08:36.120  -->  00:08:38.380
So, what would be a practical example
203

203

00:08:38.380  -->  00:08:40.500
of using a Boolean in a programme?
204

204

00:08:40.500  -->  00:08:42.690
Well, let's just say you wanted to know whether a particular
205

205

00:08:42.690  -->  00:08:46.450
customer was either the age of 21 or not.
206

206

00:08:46.450  -->  00:08:48.040
So, you might create a Boolean like this.
207

207

00:08:48.040  -->  00:08:50.410
You type Boolean, and you'll type
208

208

00:08:50.410  -->  00:08:52.490
the variable name to be a question.
209

209

00:08:52.490  -->  00:08:57.127
So, you'd type Boolean_isCustomerOverEighteen.
210

210

00:08:57.127  -->  00:08:59.580
Actually, I said 21, so let's go back and do that.
211

211

00:08:59.580  -->  00:09:00.413
21.
212

212

00:09:01.267  -->  00:09:03.040
So, isCustomerOverTwentyOne.
213

213

00:09:03.040  -->  00:09:05.290
We're gonna assign that equal to true.
214

214

00:09:05.290  -->  00:09:06.680
So, you can see there what we've done is,
215

215

00:09:06.680  -->  00:09:08.390
the variable name is a question,
216

216

00:09:08.390  -->  00:09:10.850
is the customer over 21, and we've assigned
217

217

00:09:10.850  -->  00:09:12.480
the value of true to that, meaning that, of course,
218

218

00:09:12.480  -->  00:09:16.063
in this particular case, the customer is over 21.
219

219

00:09:17.223  -->  00:09:19.100
And again, you'll see that fairly often with Booleans.
220

220

00:09:19.100  -->  00:09:21.780
They will use the word is and then a question
221

221

00:09:21.780  -->  00:09:23.560
to make it very intuitive as to what
222

222

00:09:23.560  -->  00:09:25.510
that variable is actually tracking.
223

223

00:09:25.510  -->  00:09:26.990
And just a reminder that in general
224

224

00:09:26.990  -->  00:09:29.070
with variable names, we'll be talking about those
225

225

00:09:29.070  -->  00:09:31.160
and the right and best practises
226

226

00:09:31.160  -->  00:09:34.330
for naming variables, classes, and methods as well.
227

227

00:09:34.330  -->  00:09:37.560
But more on that when we get to that stage in the course.
228

228

00:09:37.560  -->  00:09:40.170
And in terms of the Boolean, you'll see practical
229

229

00:09:40.170  -->  00:09:42.600
applications for that primitive type
230

230

00:09:42.600  -->  00:09:44.650
once we start tackling conditional logic.
231

231

00:09:45.610  -->  00:09:47.220
All right, so that's the eight
232

232

00:09:47.220  -->  00:09:49.090
primitive types we've now covered.
233

233

00:09:49.090  -->  00:09:50.260
And in the next video, we're going to have
234

234

00:09:50.260  -->  00:09:52.990
a bit of a recap of those eight data types.
235

235

00:09:52.990  -->  00:09:53.970
So, you know already now that
236

236

00:09:53.970  -->  00:09:55.480
they're called primitive types.
237

237

00:09:55.480  -->  00:09:56.997
So, we're gonna go over them again in the next video
238

238

00:09:56.997  -->  00:09:58.700
and then start discussing after that
239

239

00:09:58.700  -->  00:10:01.313
a special data type in Java that's called a string.
240

240

00:10:02.210  -->  00:10:04.020
Now, you've seen a literal value of a string,
241

241

00:10:04.020  -->  00:10:06.530
and that's shown up whenever you've typed something
242

242

00:10:06.530  -->  00:10:08.320
or seen me type something in double quotes.
243

243

00:10:08.320  -->  00:10:09.730
That's a literal string.
244

244

00:10:09.730  -->  00:10:11.030
But we're gonna start also working
245

245

00:10:11.030  -->  00:10:13.190
with this data type string in more detail as well,
246

246

00:10:13.190  -->  00:10:16.330
so actually creating variables of type string.
247

247

00:10:16.330  -->  00:10:18.563
So, let's move on now to the next video.
