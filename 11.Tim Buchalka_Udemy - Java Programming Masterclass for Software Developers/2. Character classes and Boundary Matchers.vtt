WEBVTT
1
1

00:00:05.010  -->  00:00:07.710
so I ended the previous video by saying
2

2

00:00:07.710  -->  00:00:09.630
that except for the most trivial cases
so I ended the previous video by saying
3

3

00:00:09.630  -->  00:00:12.090
most regular expressions will consist of
that except for the most trivial cases
4

4

00:00:12.090  -->  00:00:14.400
the literals boundary matches and
most regular expressions will consist of
5

5

00:00:14.400  -->  00:00:16.860
character classes strung together and
the literals boundary matches and
6

6

00:00:16.860  -->  00:00:19.010
they're usually be quantifies as
character classes strung together and
7

7

00:00:19.010  -->  00:00:20.360
well and we'll be covering those in a
they're usually be quantifies as
8

8

00:00:20.360  -->  00:00:21.110
minute
well and we'll be covering those in a
9

9

00:00:21.110  -->  00:00:23.070
so one example of using the square
minute
10

10

00:00:23.070  -->  00:00:25.020
brackets in a regular expression would
so one example of using the square
11

11

00:00:25.020  -->  00:00:27.390
be to find a word in a string that maybe
brackets in a regular expression would
12

12

00:00:27.390  -->  00:00:30.440
in upper or lowercase now we could
be to find a word in a string that maybe
13

13

00:00:30.440  -->  00:00:32.220
actually upper or lowercase the
in upper or lowercase now we could
14

14

00:00:32.220  -->  00:00:33.960
string first then you use something like
actually upper or lowercase the
15

15

00:00:33.960  -->  00:00:36.780
string . index of let's just say we
string first then you use something like
16

16

00:00:36.780  -->  00:00:38.510
wanted to find the name Harry with the
string . index of let's just say we
17

17

00:00:38.510  -->  00:00:41.060
capital H or Harry with a lowercase h
wanted to find the name Harry with the
18

18

00:00:41.060  -->  00:00:43.370
without upper or lower casing the string
capital H or Harry with a lowercase h
19

19

00:00:43.370  -->  00:00:45.650
so we could do something like this to
without upper or lower casing the string
20

20

00:00:45.650  -->  00:00:46.920
solve that
so we could do something like this to
21

21

00:00:46.920  -->  00:00:49.460
so we're looking for Harry in uppercase
solve that
22

22

00:00:49.460  -->  00:00:55.100
......
so we're looking for Harry in uppercase
23

23

00:00:55.100  -->  00:00:57.230
.....
......
24

24

00:00:57.230  -->  00:01:00.030
....
.....
25

25

00:01:00.030  -->  00:01:06.690
....
....
26

26

00:01:06.690  -->  00:01:09.390
so in the case of the string that was
....
27

27

00:01:09.390  -->  00:01:10.860
searching for being harry with a
so in the case of the string that was
28

28

00:01:10.860  -->  00:01:15.450
uppercase h if we run that no surprises
searching for being harry with a
29

29

00:01:15.450  -->  00:01:18.870
there we get the upper case H but if we
uppercase h if we run that no surprises
30

30

00:01:18.870  -->  00:01:21.870
change that so its a lowercase H and run
there we get the upper case H but if we
31

31

00:01:21.870  -->  00:01:25.980
that you can see the name is converted
change that so its a lowercase H and run
32

32

00:01:25.980  -->  00:01:27.510
to uppercase so whether it's uppercase
that you can see the name is converted
33

33

00:01:27.510  -->  00:01:30.330
or lowercase it gets converted to
to uppercase so whether it's uppercase
34

34

00:01:30.330  -->  00:01:32.070
uppercase because of what we put in
or lowercase it gets converted to
35

35

00:01:32.070  -->  00:01:34.380
the replacement string so it's obviously
uppercase because of what we put in
36

36

00:01:34.380  -->  00:01:36.360
saving us from actually having to
the replacement string so it's obviously
37

37

00:01:36.360  -->  00:01:38.310
upper or lowercase the action string
saving us from actually having to
38

38

00:01:38.310  -->  00:01:39.180
first
upper or lowercase the action string
39

39

00:01:39.180  -->  00:01:42.090
alright so next what if we wanted to
first
40

40

00:01:42.090  -->  00:01:44.040
replace every letter in the alphanumeric
alright so next what if we wanted to
41

41

00:01:44.040  -->  00:01:48.150
string except for an e or j because the
replace every letter in the alphanumeric
42

42

00:01:48.150  -->  00:01:49.740
alphanumeric strings off-screen what
string except for an e or j because the
43

43

00:01:49.740  -->  00:01:51.090
I'm going to do is to take a copy of
alphanumeric strings off-screen what
44

44

00:01:51.090  -->  00:01:57.000
that paste it down here so we can still see it i
I'm going to do is to take a copy of
45

45

00:01:57.000  -->  00:01:58.650
will call this one the new alphanumeric
that paste it down here so we can still see it i
46

46

00:01:58.650  -->  00:02:03.030
string from this point forward
will call this one the new alphanumeric
47

47

00:02:03.030  -->  00:02:05.580
so what we want to replace every
string from this point forward
48

48

00:02:05.580  -->  00:02:07.740
letter in that string except the E and
so what we want to replace every
49

49

00:02:07.740  -->  00:02:10.080
the J so would we have to write a long
letter in that string except the E and
50

50

00:02:10.080  -->  00:02:12.450
regular expression that contains every
the J so would we have to write a long
51

51

00:02:12.450  -->  00:02:14.450
letter but those two
regular expression that contains every
52

52

00:02:14.450  -->  00:02:15.930
fortunately not we don't need to do
letter but those two
53

53

00:02:15.930  -->  00:02:17.990
that we can actually simplify that by
fortunately not we don't need to do
54

54

00:02:17.990  -->  00:02:18.600
the following
that we can actually simplify that by
55

55

00:02:18.600  -->  00:02:20.190
regular expression so we can do....
the following
56

56

00:02:20.190  -->  00:02:23.100
.....
regular expression so we can do....
57

57

00:02:23.100  -->  00:02:26.040
....
.....
58

58

00:02:26.040  -->  00:02:38.670
....
....
59

59

00:02:38.670  -->  00:02:42.000
.....so if we run that
....
60

60

00:02:42.000  -->  00:02:48.660
you can see that the new alphanumeric
.....so if we run that
61

61

00:02:48.660  -->  00:02:50.520
string has been replaced with X's other
you can see that the new alphanumeric
62

62

00:02:50.520  -->  00:02:52.590
than that the occurrence of the E or
string has been replaced with X's other
63

63

00:02:52.590  -->  00:02:56.070
the J now when we use the carrot
than that the occurrence of the E or
64

64

00:02:56.070  -->  00:02:57.630
as the first character inside square
the J now when we use the carrot
65

65

00:02:57.630  -->  00:03:00.240
brackets it's actually a character class
as the first character inside square
66

66

00:03:00.240  -->  00:03:02.430
not a boundary matcher so that might have
brackets it's actually a character class
67

67

00:03:02.430  -->  00:03:04.590
been causing a bit of confusion given
not a boundary matcher so that might have
68

68

00:03:04.590  -->  00:03:06.060
that we've use the carrot as a boundary
been causing a bit of confusion given
69

69

00:03:06.060  -->  00:03:08.250
matcher in the previous video so in this
that we've use the carrot as a boundary
70

70

00:03:08.250  -->  00:03:09.960
particular case because we're using it
matcher in the previous video so in this
71

71

00:03:09.960  -->  00:03:12.630
inside square brackets it negates the
particular case because we're using it
72

72

00:03:12.630  -->  00:03:14.970
pattern that follows it so instead of
inside square brackets it negates the
73

73

00:03:14.970  -->  00:03:17.340
matching all occurrences of E&J the
pattern that follows it so instead of
74

74

00:03:17.340  -->  00:03:18.630
regular expression left square
matching all occurrences of E&J the
75

75

00:03:18.630  -->  00:03:21.600
carrot ej right square bracket
regular expression left square
76

76

00:03:21.600  -->  00:03:23.820
will match all occurrences that are not
carrot ej right square bracket
77

77

00:03:23.820  -->  00:03:26.610
e and j and of course when we ran it you
will match all occurrences that are not
78

78

00:03:26.610  -->  00:03:28.350
saw that does that actually work quite
e and j and of course when we ran it you
79

79

00:03:28.350  -->  00:03:31.080
nicely every character except e and j were
saw that does that actually work quite
80

80

00:03:31.080  -->  00:03:33.690
replaced with the X in this case so to
nicely every character except e and j were
81

81

00:03:33.690  -->  00:03:35.640
reiterate here to get this behavior the
replaced with the X in this case so to
82

82

00:03:35.640  -->  00:03:37.740
carrot has to be inside square brackets
reiterate here to get this behavior the
83

83

00:03:37.740  -->  00:03:40.680
when it's not inside square brackets the
carrot has to be inside square brackets
84

84

00:03:40.680  -->  00:03:42.450
carrot is used to denote the beginning
when it's not inside square brackets the
85

85

00:03:42.450  -->  00:03:44.160
of a string or line
carrot is used to denote the beginning
86

86

00:03:44.160  -->  00:03:47.130
alright so let's so let's say we wanted
of a string or line
87

87

00:03:47.130  -->  00:03:50.340
to replace all occurrences of a through
alright so let's so let's say we wanted
88

88

00:03:50.340  -->  00:03:53.970
f & 3 through 8 inclusive so here's one
to replace all occurrences of a through
89

89

00:03:53.970  -->  00:04:00.030
way to do it so....
f & 3 through 8 inclusive so here's one
90

90

00:04:00.030  -->  00:04:05.160
.....
way to do it so....
91

91

00:04:05.160  -->  00:04:10.410
...
.....
92

92

00:04:10.410  -->  00:04:16.260
.....
...
93

93

00:04:16.260  -->  00:04:23.480
....so if we run that you see that works
.....
94

94

00:04:23.480  -->  00:04:25.500
and we've got well at least it seems
....so if we run that you see that works
95

95

00:04:25.500  -->  00:04:27.930
to partially work but notice the d
and we've got well at least it seems
96

96

00:04:27.930  -->  00:04:30.900
and f weren't replaced and just this is
to partially work but notice the d
97

97

00:04:30.900  -->  00:04:32.130
just really to confirm the fact
and f weren't replaced and just this is
98

98

00:04:32.130  -->  00:04:33.180
that if you haven't gathered this
just really to confirm the fact
99

99

00:04:33.180  -->  00:04:35.700
already the regular expressions are case
that if you haven't gathered this
100

100

00:04:35.700  -->  00:04:39.480
sensitive so in this case the D and the
already the regular expressions are case
101

101

00:04:39.480  -->  00:04:41.220
f weren't replace because they're uppercase
sensitive so in this case the D and the
102

102

00:04:41.220  -->  00:04:43.800
letters but here is a actually shorter way to
f weren't replace because they're uppercase
103

103

00:04:43.800  -->  00:04:45.000
solve what we're trying to achieve this
letters but here is a actually shorter way to
104

104

00:04:45.000  -->  00:04:47.070
we can do....
solve what we're trying to achieve this
105

105

00:04:47.070  -->  00:04:53.610
....
we can do....
106

106

00:04:53.610  -->  00:05:04.830
....
....
107

107

00:05:04.830  -->  00:05:06.750
.....
....
108

108

00:05:06.750  -->  00:05:10.380
....you
.....
109

109

00:05:10.380  -->  00:05:11.730
can see we've got exactly the same
....you
110

110

00:05:11.730  -->  00:05:14.310
result on the screen and the
can see we've got exactly the same
111

111

00:05:14.310  -->  00:05:16.140
dash character in this case that we used
result on the screen and the
112

112

00:05:16.140  -->  00:05:19.710
is specifying range now when we have
dash character in this case that we used
113

113

00:05:19.710  -->  00:05:21.540
multiple ranges as we do here there's no
is specifying range now when we have
114

114

00:05:21.540  -->  00:05:23.160
need to separate them with a comma
multiple ranges as we do here there's no
115

115

00:05:23.160  -->  00:05:24.810
we just actually go on to the next range
need to separate them with a comma
116

116

00:05:24.810  -->  00:05:26.280
as you saw there without adding a space
we just actually go on to the next range
117

117

00:05:26.280  -->  00:05:29.130
between the Ranges now since regular
as you saw there without adding a space
118

118

00:05:29.130  -->  00:05:30.990
expressions are case sensitive if we
between the Ranges now since regular
119

119

00:05:30.990  -->  00:05:32.610
wanted to actually match the capital a
expressions are case sensitive if we
120

120

00:05:32.610  -->  00:05:34.830
through f as well we could write or
wanted to actually match the capital a
121

121

00:05:34.830  -->  00:05:37.860
revise the expression slightly we
through f as well we could write or
122

122

00:05:37.860  -->  00:05:40.230
come in here we can put.....
revise the expression slightly we
123

123

00:05:40.230  -->  00:05:43.350
...and when we ran that
come in here we can put.....
124

124

00:05:43.350  -->  00:05:47.790
you can see this time we've actually got
...and when we ran that
125

125

00:05:47.790  -->  00:05:50.490
those letters replaced the d and the
you can see this time we've actually got
126

126

00:05:50.490  -->  00:05:53.130
f are now replaced because we specified the
those letters replaced the d and the
127

127

00:05:53.130  -->  00:05:54.450
uppercase versions as well as the
f are now replaced because we specified the
128

128

00:05:54.450  -->  00:05:57.390
lowercase versions with that said there's
uppercase versions as well as the
129

129

00:05:57.390  -->  00:05:58.950
still another way we can do this as well
lowercase versions with that said there's
130

130

00:05:58.950  -->  00:06:00.840
it is actually possible to turn off the
still another way we can do this as well
131

131

00:06:00.840  -->  00:06:02.340
case sensitivity using the following
it is actually possible to turn off the
132

132

00:06:02.340  -->  00:06:04.050
special construct so let's actually have
case sensitivity using the following
133

133

00:06:04.050  -->  00:06:07.920
a look at that....
special construct so let's actually have
134

134

00:06:07.920  -->  00:06:12.780
....
a look at that....
135

135

00:06:12.780  -->  00:06:20.580
....
....
136

136

00:06:20.580  -->  00:06:21.990
.....
....
137

137

00:06:21.990  -->  00:06:28.140
.....
.....
138

138

00:06:28.140  -->  00:06:32.730
.....if we do that we're ignoring case
.....
139

139

00:06:32.730  -->  00:06:34.590
now case sensitivity their is no case
.....if we do that we're ignoring case
140

140

00:06:34.590  -->  00:06:36.240
sensitivity and you can see without
now case sensitivity their is no case
141

141

00:06:36.240  -->  00:06:38.850
actually specify the uppercase a-f as we
sensitivity and you can see without
142

142

00:06:38.850  -->  00:06:41.250
did on line 33 we've now got it to actually
actually specify the uppercase a-f as we
143

143

00:06:41.250  -->  00:06:44.590
replace those letters as well
did on line 33 we've now got it to actually
144

144

00:06:44.590  -->  00:06:46.780
and that's because we're using the
replace those letters as well
145

145

00:06:46.780  -->  00:06:50.560
special construct the left parenthesis ?
and that's because we're using the
146

146

00:06:50.560  -->  00:06:53.770
I the cases sensitivity now in our regular
special construct the left parenthesis ?
147

147

00:06:53.770  -->  00:06:56.220
expressions and this works with ascii strings
I the cases sensitivity now in our regular
148

148

00:06:56.220  -->  00:06:58.470
now if the string is unicode
expressions and this works with ascii strings
149

149

00:06:58.470  -->  00:07:00.250
then we actually want to use something
now if the string is unicode
150

150

00:07:00.250  -->  00:07:04.030
like the ? I u would put u on the
then we actually want to use something
151

151

00:07:04.030  -->  00:07:05.680
end if it's actually unicode
like the ? I u would put u on the
152

152

00:07:05.680  -->  00:07:10.120
string like so an interesting bit of
end if it's actually unicode
153

153

00:07:10.120  -->  00:07:11.620
trivia here this actually didn't work
string like so an interesting bit of
154

154

00:07:11.620  -->  00:07:13.720
properly in java 6 and earlier versions
trivia here this actually didn't work
155

155

00:07:13.720  -->  00:07:16.270
the java is actually finally fixed in jdk
properly in java 6 and earlier versions
156

156

00:07:16.270  -->  00:07:19.600
six u2 alright so let's move on
the java is actually finally fixed in jdk
157

157

00:07:19.600  -->  00:07:21.940
let's say we wanted to replace all the
six u2 alright so let's move on
158

158

00:07:21.940  -->  00:07:24.220
numbers in the string now one way of
let's say we wanted to replace all the
159

159

00:07:24.220  -->  00:07:28.030
doing that you do something....
numbers in the string now one way of
160

160

00:07:28.030  -->  00:07:32.590
....
doing that you do something....
161

161

00:07:32.590  -->  00:07:36.580
.....
....
162

162

00:07:36.580  -->  00:07:41.280
....
.....
163

163

00:07:41.280  -->  00:07:43.270
.....
....
164

164

00:07:43.270  -->  00:07:47.280
run that you can see all the digits have
.....
165

165

00:07:47.280  -->  00:07:49.630
been replaced with an x but there's
run that you can see all the digits have
166

166

00:07:49.630  -->  00:07:51.280
actually a shorthand way to do the same
been replaced with an x but there's
167

167

00:07:51.280  -->  00:07:53.710
thing when we want to match any digit we
actually a shorthand way to do the same
168

168

00:07:53.710  -->  00:07:55.570
can actually use the backslash d
thing when we want to match any digit we
169

169

00:07:55.570  -->  00:07:58.030
character class i'm going to copy that
can actually use the backslash d
170

170

00:07:58.030  -->  00:08:04.060
so we can simply make that two
character class i'm going to copy that
171

171

00:08:04.060  -->  00:08:10.030
backslashes and a d and run that and you
so we can simply make that two
172

172

00:08:10.030  -->  00:08:11.280
can see that we've got the same result
backslashes and a d and run that and you
173

173

00:08:11.280  -->  00:08:15.250
and note that i had to escape the / so
can see that we've got the same result
174

174

00:08:15.250  -->  00:08:16.470
in other words had to put a slash a
and note that i had to escape the / so
175

175

00:08:16.470  -->  00:08:18.550
backslash and then put the /d in the
in other words had to put a slash a
176

176

00:08:18.550  -->  00:08:20.020
the actual string to make it a
backslash and then put the /d in the
177

177

00:08:20.020  -->  00:08:22.060
valid string if I don't put the second
the actual string to make it a
178

178

00:08:22.060  -->  00:08:24.430
/ in there we get an error
valid string if I don't put the second
179

179

00:08:24.430  -->  00:08:26.110
illegally escape character string literal
/ in there we get an error
180

180

00:08:26.110  -->  00:08:28.300
so I need to put this basically need to
illegally escape character string literal
181

181

00:08:28.300  -->  00:08:32.280
escape / for this to work and there's
so I need to put this basically need to
182

182

00:08:32.280  -->  00:08:35.890
also a shortcut to replace all non
escape / for this to work and there's
183

183

00:08:35.890  -->  00:08:39.270
digits so we can do.....
also a shortcut to replace all non
184

184

00:08:39.270  -->  00:08:42.130
....
digits so we can do.....
185

185

00:08:42.130  -->  00:08:46.930
.....
....
186

186

00:08:46.930  -->  00:08:51.850
....
.....
187

187

00:08:51.850  -->  00:08:53.170
so you can see there that we replace
....
188

188

00:08:53.170  -->  00:08:57.100
all non digits as well with X now string
so you can see there that we replace
189

189

00:08:57.100  -->  00:08:59.050
has a trim method that removes white
all non digits as well with X now string
190

190

00:08:59.050  -->  00:09:00.630
spaces from the beginning and end of a
has a trim method that removes white
191

191

00:09:00.630  -->  00:09:02.560
string but let's say that we want all
spaces from the beginning and end of a
192

192

00:09:02.560  -->  00:09:04.480
whitespace removed no matter where it
string but let's say that we want all
193

193

00:09:04.480  -->  00:09:06.510
occurs in the strings so lets actually
whitespace removed no matter where it
194

194

00:09:06.510  -->  00:09:09.370
just declare a new string....
occurs in the strings so lets actually
195

195

00:09:09.370  -->  00:09:15.910
....
just declare a new string....
196

196

00:09:15.910  -->  00:09:31.480
....
....
197

197

00:09:31.480  -->  00:09:35.940
so if you run that you can see how it prints
....
198

198

00:09:35.940  -->  00:09:38.250
out there the tab and also a new line
so if you run that you can see how it prints
199

199

00:09:38.250  -->  00:09:41.170
and the spaces as well let's now use a
out there the tab and also a new line
200

200

00:09:41.170  -->  00:09:42.730
regular expression to remove all
and the spaces as well let's now use a
201

201

00:09:42.730  -->  00:09:45.190
whitespace from the string and
regular expression to remove all
202

202

00:09:45.190  -->  00:09:46.720
fortunately there's actually character
whitespace from the string and
203

203

00:09:46.720  -->  00:09:48.510
class to do that so I can do
fortunately there's actually character
204

204

00:09:48.510  -->  00:09:52.950
....
class to do that so I can do
205

205

00:09:52.950  -->  00:09:57.220
.....
....
206

206

00:09:57.220  -->  00:10:01.020
....
.....
207

207

00:10:01.020  -->  00:10:02.580
....
....
208

208

00:10:02.580  -->  00:10:04.600
....so if we
....
209

209

00:10:04.600  -->  00:10:09.750
actually run that you can see what's
....so if we
210

210

00:10:09.750  -->  00:10:11.310
happening it's completely removed or
actually run that you can see what's
211

211

00:10:11.310  -->  00:10:13.300
removed all spaces the tab and also the
happening it's completely removed or
212

212

00:10:13.300  -->  00:10:15.630
new line that was added in the first
removed all spaces the tab and also the
213

213

00:10:15.630  -->  00:10:18.330
version of the string of course if you
new line that was added in the first
214

214

00:10:18.330  -->  00:10:19.630
really wanted to remove specific
version of the string of course if you
215

215

00:10:19.630  -->  00:10:21.930
whitespace characters we could specify
really wanted to remove specific
216

216

00:10:21.930  -->  00:10:24.450
those in a regular expression just as
whitespace characters we could specify
217

217

00:10:24.450  -->  00:10:26.010
you would for any other strings so using
those in a regular expression just as
218

218

00:10:26.010  -->  00:10:29.170
backslash t backslash n etc for
you would for any other strings so using
219

219

00:10:29.170  -->  00:10:30.330
example I could do something like
backslash t backslash n etc for
220

220

00:10:30.330  -->  00:10:38.980
....
example I could do something like
221

221

00:10:38.980  -->  00:10:44.170
....
....
222

222

00:10:44.170  -->  00:10:49.020
...you
....
223

223

00:10:49.020  -->  00:10:50.130
can see the tab character that was
...you
224

224

00:10:50.130  -->  00:10:51.160
originally shown there has been
can see the tab character that was
225

225

00:10:51.160  -->  00:10:54.570
replaced with an x now if we wanted to
originally shown there has been
226

226

00:10:54.570  -->  00:10:56.800
replace all non-white space characters
replaced with an x now if we wanted to
227

227

00:10:56.800  -->  00:10:59.350
instead we can actually use backslash s
replace all non-white space characters
228

228

00:10:59.350  -->  00:11:02.310
the capital S this time so we can put
instead we can actually use backslash s
229

229

00:11:02.310  -->  00:11:05.260
....
the capital S this time so we can put
230

230

00:11:05.260  -->  00:11:15.220
....
....
231

231

00:11:15.220  -->  00:11:20.200
.....and it's pretty hard to see but
....
232

232

00:11:20.200  -->  00:11:21.910
that's actually replaced all the non
.....and it's pretty hard to see but
233

233

00:11:21.910  -->  00:11:24.310
whitespace characters instead so all we can
that's actually replaced all the non
234

234

00:11:24.310  -->  00:11:25.810
see on the screen or we can't see it on the
whitespace characters instead so all we can
235

235

00:11:25.810  -->  00:11:27.880
screen is the tab character and the newline
see on the screen or we can't see it on the
236

236

00:11:27.880  -->  00:11:29.410
character but that has actually removed all
screen is the tab character and the newline
237

237

00:11:29.410  -->  00:11:32.440
the non-white space characters instead
character but that has actually removed all
238

238

00:11:32.440  -->  00:11:38.770
another character class is back slash
the non-white space characters instead
239

239

00:11:38.770  -->  00:11:41.680
lowercase w that matches a to z in
another character class is back slash
240

240

00:11:41.680  -->  00:11:45.250
lowercase a to z in uppercase 0 to 9 and
lowercase w that matches a to z in
241

241

00:11:45.250  -->  00:11:47.290
also the underscore so lets actually
lowercase a to z in uppercase 0 to 9 and
242

242

00:11:47.290  -->  00:11:48.880
use that in our new alphanumeric
also the underscore so lets actually
243

243

00:11:48.880  -->  00:11:54.370
string so we can go....
use that in our new alphanumeric
244

244

00:11:54.370  -->  00:11:55.210
....
string so we can go....
245

245

00:11:55.210  -->  00:12:06.460
....
....
246

246

00:12:06.460  -->  00:12:10.510
....you can see that we've got now a string of
....
247

247

00:12:10.510  -->  00:12:13.420
x's again we can run that on our white
....you can see that we've got now a string of
248

248

00:12:13.420  -->  00:12:16.450
space has.....
x's again we can run that on our white
249

249

00:12:16.450  -->  00:12:22.450
....
space has.....
250

250

00:12:22.450  -->  00:12:28.600
.....you can see here that the
....
251

251

00:12:28.600  -->  00:12:30.610
whitespace characters are not replaced
.....you can see here that the
252

252

00:12:30.610  -->  00:12:33.430
but everything else was now just like
whitespace characters are not replaced
253

253

00:12:33.430  -->  00:12:35.590
with the backslash s and backslash d
but everything else was now just like
254

254

00:12:35.590  -->  00:12:38.980
using back /w capital W will have the
with the backslash s and backslash d
255

255

00:12:38.980  -->  00:12:41.080
opposite effect so that regular
using back /w capital W will have the
256

256

00:12:41.080  -->  00:12:42.970
this regular expression will match anything but
opposite effect so that regular
257

257

00:12:42.970  -->  00:12:46.540
a to z 0 9 and the underscore so
this regular expression will match anything but
258

258

00:12:46.540  -->  00:12:50.620
that's the / capital W now the
a to z 0 9 and the underscore so
259

259

00:12:50.620  -->  00:12:52.630
backslash b lowercase b boundary
that's the / capital W now the
260

260

00:12:52.630  -->  00:12:54.430
matcher is actually an interesting one
backslash b lowercase b boundary
261

261

00:12:54.430  -->  00:12:56.800
so we actually matches word boundaries
matcher is actually an interesting one
262

262

00:12:56.800  -->  00:12:58.840
so it assumes that words are separated by
so we actually matches word boundaries
263

263

00:12:58.840  -->  00:13:01.420
white space so let's uses that with our
so it assumes that words are separated by
264

264

00:13:01.420  -->  00:13:03.130
has white space string and see what
white space so let's uses that with our
265

265

00:13:03.130  -->  00:13:03.640
we get
has white space string and see what
266

266

00:13:03.640  -->  00:13:07.690
so I'm going to do.....
we get
267

267

00:13:07.690  -->  00:13:11.020
....
so I'm going to do.....
268

268

00:13:11.020  -->  00:13:14.170
.....
....
269

269

00:13:14.170  -->  00:13:17.820
.....
.....
270

270

00:13:17.820  -->  00:13:21.390
you can see that each word has been
.....
271

271

00:13:21.390  -->  00:13:24.060
surrounded by the replacement string so
you can see that each word has been
272

272

00:13:24.060  -->  00:13:25.740
we got an x at the start and it
surrounded by the replacement string so
273

273

00:13:25.740  -->  00:13:29.790
also an x at the end of each word so
we got an x at the start and it
274

274

00:13:29.790  -->  00:13:31.260
there are situations in which this would
also an x at the end of each word so
275

275

00:13:31.260  -->  00:13:33.060
be very useful for example we could use
there are situations in which this would
276

276

00:13:33.060  -->  00:13:34.530
it we want to surround each word with
be very useful for example we could use
277

277

00:13:34.530  -->  00:13:36.000
tags of some kind of you know perhaps
it we want to surround each word with
278

278

00:13:36.000  -->  00:13:39.030
your creating some HTML code or needing
tags of some kind of you know perhaps
279

279

00:13:39.030  -->  00:13:41.250
some sort of other tags very quick way to
your creating some HTML code or needing
280

280

00:13:41.250  -->  00:13:44.130
actually replace that put a tag at the
some sort of other tags very quick way to
281

281

00:13:44.130  -->  00:13:45.990
start and the end of every word
actually replace that put a tag at the
282

282

00:13:45.990  -->  00:13:47.400
alright I'm going to finish the video
start and the end of every word
283

283

00:13:47.400  -->  00:13:49.530
here now in the next video we didn't
alright I'm going to finish the video
284

284

00:13:49.530  -->  00:13:51.600
quite get to quantifiers but we'll start
here now in the next video we didn't
285

285

00:13:51.600  -->  00:13:58.400
looking at quantifiers in the next video
quite get to quantifiers but we'll start
