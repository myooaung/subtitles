WEBVTT
1
00:00:00.770 --> 00:00:02.610
[Autogenerated] All right, let's continue now.

2
00:00:02.610 --> 00:00:06.560
We just got done over viewing state ful versus stateless

3
00:00:06.560 --> 00:00:10.140
architectures and some of the key differences.

4
00:00:10.140 --> 00:00:12.940
Now let's talk about a W s Lambda.

5
00:00:12.940 --> 00:00:16.380
Now Lambda is a compute service that runs code

6
00:00:16.380 --> 00:00:19.170
without us having to manage servers.

7
00:00:19.170 --> 00:00:23.670
It allows us to focus strictly on the code execution

8
00:00:23.670 --> 00:00:27.010
itself and only have to worry about a few different

9
00:00:27.010 --> 00:00:30.130
configuration items in the background.

10
00:00:30.130 --> 00:00:32.820
Now what happens is is it's on demand.

11
00:00:32.820 --> 00:00:38.950
So as invocations come in, they're handled on demand by Lambda itself.

12
00:00:38.950 --> 00:00:41.380
And the scaling is automatic as well.

13
00:00:41.380 --> 00:00:45.720
The beauty of this is that you only pay for what you actually

14
00:00:45.720 --> 00:00:50.110
use and what's awesome here is you get one million free

15
00:00:50.110 --> 00:00:53.490
invocations per month for Lambda.

16
00:00:53.490 --> 00:00:58.360
So this can be an extremely cheap option for compute if you can isolate

17
00:00:58.360 --> 00:01:03.220
and separate your workloads into individual functions.

18
00:01:03.220 --> 00:01:04.990
And that's not always possible,

19
00:01:04.990 --> 00:01:10.240
because the complexity involved can be a bit much for what's actually needed.

20
00:01:10.240 --> 00:01:14.730
Now the code that we implement is actually ran on highly available

21
00:01:14.730 --> 00:01:19.440
infrastructure handled by a W S in the background.

22
00:01:19.440 --> 00:01:22.580
So we don't have to worry about spinning this up in

23
00:01:22.580 --> 00:01:25.500
two different availability zones.

24
00:01:25.500 --> 00:01:28.940
A W S is handling all of that for us,

25
00:01:28.940 --> 00:01:31.880
and that includes both the functioning of the code.

26
00:01:31.880 --> 00:01:33.470
So the computer itself,

27
00:01:33.470 --> 00:01:37.970
as well as the code storage and the last tidbit here is that

28
00:01:37.970 --> 00:01:41.890
we execute code based on incoming events.

29
00:01:41.890 --> 00:01:48.140
So those on demand events that we can schedule or set up a trigger for

30
00:01:48.140 --> 00:01:51.840
so that our code can execute and perform an action.

31
00:01:51.840 --> 00:01:57.140
So now that we have an overview of Lambda or maybe a review for some of you,

32
00:01:57.140 --> 00:02:00.840
let's look at the demos that we're going to take part in.

33
00:02:00.840 --> 00:02:04.540
We're going to create in trigger a Lambda function,

34
00:02:04.540 --> 00:02:08.990
and we'll do that via Consul just so you can get a visual ization.

35
00:02:08.990 --> 00:02:14.280
And then we're going to look at manipulating data in a stateless architecture.

36
00:02:14.280 --> 00:02:16.990
So we'll use these Lambda functions,

37
00:02:16.990 --> 00:02:22.030
which are inherently stateless and will manipulate some data

38
00:02:22.030 --> 00:02:26.960
in dynamodb so we can show how we can track state in the

39
00:02:26.960 --> 00:02:29.910
back end within our databases.

40
00:02:29.910 --> 00:02:39.000
So let's go ahead and break here and in the next clip will go ahead and dive into using Lambda for our stateless architectures.

