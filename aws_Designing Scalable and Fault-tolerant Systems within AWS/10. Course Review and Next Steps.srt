1
00:00:00,640 --> 00:00:02,930
[Autogenerated] Okay, so last video in this course.

2
00:00:02,930 --> 00:00:08,170
And this is just a simple review on what we learned early on in the course,

3
00:00:08,170 --> 00:00:11,950
we discuss the different use cases for the different E.

4
00:00:11,950 --> 00:00:15,240
C to life cycle types that are offered to us.

5
00:00:15,240 --> 00:00:18,050
So we looked at spot instances and how those could be

6
00:00:18,050 --> 00:00:20,540
interrupted at any point in time.

7
00:00:20,540 --> 00:00:24,810
We looked at reserved instances for long running instances in place,

8
00:00:24,810 --> 00:00:29,850
such as domain controllers or even data bases on Easy to.

9
00:00:29,850 --> 00:00:32,880
And then we talked about on demand, which is the normal,

10
00:00:32,880 --> 00:00:36,910
easy to instance type that gets spun up in the console.

11
00:00:36,910 --> 00:00:41,830
We then looked at designing resilient, stateless architectures within a W.

12
00:00:41,830 --> 00:00:42,880
S.

13
00:00:42,880 --> 00:00:47,200
And to demo this we used a W s Lambda with an a p I

14
00:00:47,200 --> 00:00:50,940
gateway front end in a dynamodb back end.

15
00:00:50,940 --> 00:00:54,630
So we looked at how a p a gateway in Lambda were stateless.

16
00:00:54,630 --> 00:00:58,240
They simply passed the workloads through and performed actions.

17
00:00:58,240 --> 00:01:02,510
And then any state full data was stored on dynamodb building.

18
00:01:02,510 --> 00:01:03,180
Off of that,

19
00:01:03,180 --> 00:01:06,790
we looked at implementing resilient auto scaling groups

20
00:01:06,790 --> 00:01:09,850
for our workloads and to do this,

21
00:01:09,850 --> 00:01:13,860
we used multi availabilities own load balancers secured

22
00:01:13,860 --> 00:01:17,540
with T L s certificates provided by a CM.

23
00:01:17,540 --> 00:01:22,940
So we were able to spin up an auto scaling group across multiple A Z's.

24
00:01:22,940 --> 00:01:26,180
So if a particular ese failed,

25
00:01:26,180 --> 00:01:30,680
we would still be able to pick up the load in the other ese.

26
00:01:30,680 --> 00:01:36,320
Now, we also looked at using cloudfront for cashing and security purposes,

27
00:01:36,320 --> 00:01:38,940
and we discuss the different use cases and

28
00:01:38,940 --> 00:01:41,500
configuration options that were available.

29
00:01:41,500 --> 00:01:43,060
And then we just finished up,

30
00:01:43,060 --> 00:01:49,140
creating Route 53 routing policies and health checks with fail overs.

31
00:01:49,140 --> 00:01:51,690
So we looked at how weaken set up global D.

32
00:01:51,690 --> 00:01:56,570
N s resolution with advanced health checking and fail overs

33
00:01:56,570 --> 00:02:01,010
as well as advance policies based upon Leighton see and even

34
00:02:01,010 --> 00:02:03,640
geographically based request.

35
00:02:03,640 --> 00:02:04,560
Now, with that,

36
00:02:04,560 --> 00:02:08,750
I'd like to thank you once again for taking the time to watch this portal

37
00:02:08,750 --> 00:02:13,680
site course on designing scalable systems within AWS.

38
00:02:13,680 --> 00:02:13,860
Now,

39
00:02:13,860 --> 00:02:17,070
some suggested next steps would be to continue on the

40
00:02:17,070 --> 00:02:19,850
solutions architect professional Learning path.

41
00:02:19,850 --> 00:02:24,140
There are several courses in there, and then once you're done with that,

42
00:02:24,140 --> 00:02:29,740
look for some deep dives into different topics like cloudfront and Route 53.

43
00:02:29,740 --> 00:02:34,160
So you can get a better understanding those architecture considerations

44
00:02:34,160 --> 00:02:43,000
based around those technologies are heavily tested on. So with that, we'll go ahead and wrap up, and once again, thank you.

