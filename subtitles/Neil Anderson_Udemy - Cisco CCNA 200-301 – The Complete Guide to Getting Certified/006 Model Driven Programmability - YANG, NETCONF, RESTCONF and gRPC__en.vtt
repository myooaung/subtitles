WEBVTT
1
00:00:07.410 --> 00:00:16.490
In this lecture, you'll learn about model driven programmability with young Netco restaurant on Gypsy

2
00:00:17.040 --> 00:00:23.700
to day, a model is well understood and agreed upon method to describe something.

3
00:00:23.880 --> 00:00:27.420
You can also see this being described as a schema as well.

4
00:00:27.540 --> 00:00:31.710
So it's a way that the is laid out and organized.

5
00:00:31.890 --> 00:00:42.000
In the example here, you can see how a car dealership would maybe have their database laid out so that

6
00:00:42.000 --> 00:00:44.430
they are a model for what you can see here.

7
00:00:44.730 --> 00:00:51.930
The top level, we've got the mic, which includes the idea for the mique, which is an integer, meaning

8
00:00:51.930 --> 00:00:57.630
it's a number and the name, which is variable and characters up to 45 cottagers.

9
00:00:57.810 --> 00:01:07.020
We've also got the model of car with the model ID, which is an integer again, then the idea and also

10
00:01:07.020 --> 00:01:08.460
the name for the model.

11
00:01:08.610 --> 00:01:15.690
And we've got the trem or specifications of the car which has got the trim ID, the model, ID the name.

12
00:01:15.700 --> 00:01:23.310
And the year to date model is just the recognized and agreed upon way that your data is going to be

13
00:01:23.310 --> 00:01:25.380
laid out and organized.

14
00:01:26.800 --> 00:01:30.740
Young stands for yet another next generation.

15
00:01:31.030 --> 00:01:39.310
It was standardized by the IETF in 2010, and so they are modeling language, which provides a standardized

16
00:01:39.310 --> 00:01:45.420
way to represent the operational and configuration of a network device.

17
00:01:45.760 --> 00:01:54.020
So for using remote devices to interact with our network devices, to be able to pull information from

18
00:01:54.020 --> 00:01:56.130
them and push information from them.

19
00:01:56.320 --> 00:02:01.930
The client, which is the API, which is working with the network debate on the server, which is the

20
00:02:01.930 --> 00:02:08.889
network device itself, they need to have a standardized format for data to be laid out in.

21
00:02:09.100 --> 00:02:16.720
And Yang is commonly used for what is an open standard used by different network device vendors.

22
00:02:16.970 --> 00:02:26.050
It can be used both internally on the device as a way of describing all its components on features and

23
00:02:26.050 --> 00:02:32.080
also when packaged for transmission, for example, when interacting with an API.

24
00:02:33.370 --> 00:02:41.650
So looking at the young format at the top, we've got the module name and you can see here, this is

25
00:02:41.920 --> 00:02:47.560
standard IETF module, which describes the networked devices interfaces.

26
00:02:47.740 --> 00:02:50.500
Then we've got a couple of containers under there.

27
00:02:50.690 --> 00:02:54.280
The first container describing the interfaces.

28
00:02:54.370 --> 00:02:59.630
It includes information like the name, the description type, wherever it's enabled or not.

29
00:02:59.890 --> 00:03:05.110
And then we've got another container for the interface, which includes information like the name,

30
00:03:05.110 --> 00:03:08.980
again, the type, the admin and operational status, et cetera.

31
00:03:09.160 --> 00:03:13.500
So that is how the young format is laid out.

32
00:03:15.090 --> 00:03:22.530
The configuration and operational status of a network device is components and services can be remotely

33
00:03:22.530 --> 00:03:30.540
read or written to Netco Restaurant Conference RPG, our APIs, which describe the protocols and methods

34
00:03:30.540 --> 00:03:34.200
for transport of network management data.

35
00:03:34.530 --> 00:03:41.550
So looking at the model driven programmability stock on our network device, we've got things like interfaces,

36
00:03:41.550 --> 00:03:46.190
also its features like BGP, KUOW, et cetera.

37
00:03:46.410 --> 00:03:53.190
And then we've got the modules there which are which can be standard, such as the IETF interfaces that

38
00:03:53.190 --> 00:03:58.890
you just saw, but can also be vendor specific modules as well, because maybe you've got a particular

39
00:03:58.890 --> 00:04:04.230
network device which has got features on there are specific to that device.

40
00:04:04.380 --> 00:04:10.590
When not case with vendor would have a vendor specific module and they are going to be laid out into

41
00:04:10.590 --> 00:04:16.230
modules which describe the configuration and also the operational status as well.

42
00:04:16.260 --> 00:04:20.130
So we've got our young data models that resides on the device.

43
00:04:20.279 --> 00:04:25.970
And if we want to interact with our informations, if we're using an API to pool the information to

44
00:04:25.980 --> 00:04:31.670
read it, or maybe we want to push information to that particular device, then we can use Netcom,

45
00:04:31.950 --> 00:04:34.980
Rascon or Gypsie to do that.

46
00:04:35.160 --> 00:04:42.330
So in that contrast, going on RPG, those are our transports that we can use to interact with the young

47
00:04:42.330 --> 00:04:42.870
data.

48
00:04:43.980 --> 00:04:53.220
So looking at our current communications, we've got the young Yandina that is encapsulated in XML and

49
00:04:53.220 --> 00:05:00.540
then we've got the net current information, which is further encapsulating that, and we can send and

50
00:05:00.540 --> 00:05:06.210
request information to the server, which is going to be our network device.

51
00:05:07.970 --> 00:05:16.370
So our net count was designed as a replacement for S&P, the issues with S&P is various security concerns

52
00:05:16.370 --> 00:05:24.260
there, particularly if it's before S&P version three and S&P is good for reading information.

53
00:05:24.380 --> 00:05:28.370
It's not so good for pushing information to the devices.

54
00:05:28.550 --> 00:05:34.280
So Network was designed as a replacement, really an upgrade for S&P Netcom.

55
00:05:34.280 --> 00:05:41.180
Fignon provide a standardized way to programmatically inspect and modify the configuration of a network

56
00:05:41.180 --> 00:05:44.510
device so young, which standardized in 2010.

57
00:05:44.660 --> 00:05:50.210
It's a data modeling language which provides a standardized way to represent operational and configuration

58
00:05:50.420 --> 00:05:51.530
of a network device.

59
00:05:51.530 --> 00:05:56.600
As you learned earlier, Netcom, which standardized with IETF in 2006.

60
00:05:56.720 --> 00:06:03.530
And it's a protocol that remotely reads or applies changes to the data on the device to that might seem

61
00:06:03.530 --> 00:06:07.830
like it's the wrong way around where Yang actually came after it.

62
00:06:07.970 --> 00:06:13.430
But what happened to the way to work with the data was actually designed first.

63
00:06:13.430 --> 00:06:17.200
So Netcom wasn't really used back in 2006.

64
00:06:17.210 --> 00:06:21.020
It wasn't really usable until Yang came out in 2010.

65
00:06:21.110 --> 00:06:25.550
And Yang was actually originally designed to work with Netcom.

66
00:06:25.970 --> 00:06:34.400
With Netcom, it's mandated the XML coding has to be used and transport is usually over.

67
00:06:34.400 --> 00:06:37.670
S.H. It can also run over time as well.

68
00:06:38.640 --> 00:06:45.170
Looking at the net current political stock, we've got the content, which is the day to be inspected

69
00:06:45.170 --> 00:06:50.450
or changed operations, for example, getting the config or editing the config.

70
00:06:50.660 --> 00:06:56.580
This is initiated by RPG message using XML encoding messages.

71
00:06:56.670 --> 00:07:03.770
You use RPG that stands for remote procedure call RPG simply means Ellery's one system to request another

72
00:07:03.770 --> 00:07:05.330
system to execute code.

73
00:07:05.600 --> 00:07:08.750
And we've got the transport between the client and server.

74
00:07:08.960 --> 00:07:12.350
As I said earlier, supports S.H. or else.

75
00:07:12.650 --> 00:07:17.030
So looking at the protocol stack with Netco we've got to transport.

76
00:07:17.040 --> 00:07:19.820
SSA is also supported.

77
00:07:20.000 --> 00:07:23.360
The messages are using RPG.

78
00:07:23.570 --> 00:07:26.580
We've got the operations, which is the option to perform.

79
00:07:26.600 --> 00:07:29.420
This is the production that we're going to be performing.

80
00:07:29.600 --> 00:07:31.190
And then we've got the actual content.

81
00:07:31.190 --> 00:07:33.410
We've got the body there as well.

82
00:07:34.350 --> 00:07:35.240
OK, moving on.

83
00:07:35.250 --> 00:07:44.540
We've also got restaraunt restaurant kumite later in 2017 and it builds on Netco and it's also an IETF

84
00:07:44.540 --> 00:07:44.960
draft.

85
00:07:44.960 --> 00:07:49.760
It describes how amap a young specification here to a restful interface.

86
00:07:50.030 --> 00:07:58.220
It uses http verbs over a rest API and restaurant is not intended to replace Netcom.

87
00:07:58.340 --> 00:08:05.390
It doesn't have quite as much functionality as Netco, but it is simpler to use and everything Rasht

88
00:08:05.410 --> 00:08:10.220
based nowadays is very popular with our Netco.

89
00:08:10.520 --> 00:08:16.710
It was mandated that it always uses XML, including Rescoring can use XML or Jason.

90
00:08:16.880 --> 00:08:25.220
Jason is seen as easier to read and simpler to work with and to transport is http or https.

91
00:08:26.180 --> 00:08:34.130
So looking at the restaurant protocol stock we've got transport is HTP or yes, we've got our options

92
00:08:34.130 --> 00:08:42.169
to perform our CRUD operations and it's based suich, get pushed, put potch on, don't eat and the

93
00:08:42.169 --> 00:08:45.350
content is going to be X-Mailer or on.

94
00:08:45.530 --> 00:08:50.810
And looking back at that slide I showed you for Netco earlier.

95
00:08:50.930 --> 00:08:58.340
So if this was restaurant that we were using now, it would be Yandina encapsulated in XML or JSON and

96
00:08:58.340 --> 00:09:00.240
then the rest Cohon.

97
00:09:01.080 --> 00:09:08.230
Okay, so moving on from there, we've also got Gypsie.

98
00:09:09.110 --> 00:09:10.880
This is Google RPG.

99
00:09:11.090 --> 00:09:18.200
That's an open source remote procedure code system initially developed by Google in 2015 as well.

100
00:09:18.410 --> 00:09:20.810
It's collecting telemetry statistics.

101
00:09:21.080 --> 00:09:27.260
So if you're in an Internet of Things environment, you've got a lot of devices and you want to collect

102
00:09:27.260 --> 00:09:32.120
a lot of telemetry information from them, then RPG can be a good choice.

103
00:09:32.480 --> 00:09:35.600
GPP, Google Buffer, Google Protocol.

104
00:09:35.600 --> 00:09:38.300
Buffer's encoding is used Roggeveen X-Mailer.

105
00:09:38.300 --> 00:09:44.420
Jason Endre Transport is htp to show for interacting with network devices.

106
00:09:44.420 --> 00:09:50.450
If you're going to use the these, it's going to be most likely Netco, Orascom.

107
00:09:50.540 --> 00:09:53.230
But RPG is also available.

108
00:09:53.630 --> 00:10:00.950
OK, one thing to talk about here is Postman Postman is a super popular tool to test the operation of

109
00:10:01.430 --> 00:10:02.240
APIs.

110
00:10:02.450 --> 00:10:10.220
So Test APIs restaraunt is also testable with Posman because it's based on the same protocols.

111
00:10:10.610 --> 00:10:18.690
Posman can be downloaded as a standalone application or it can be run as a plug in with Postman.

112
00:10:18.690 --> 00:10:24.830
There's a lot of features and functionality in here in post in your collections and environment variables

113
00:10:24.830 --> 00:10:27.440
allow you to easily reuse requests.

114
00:10:27.440 --> 00:10:33.380
So it makes it very convenient to work with requests can be exported as code and multiple programming

115
00:10:33.380 --> 00:10:33.890
languages.

116
00:10:34.070 --> 00:10:38.840
So you can send your requests with porchlight a test of or working.

117
00:10:39.080 --> 00:10:42.710
You check that they are working as you desired directly from Posman.

118
00:10:42.710 --> 00:10:46.250
You can export the code, which you can use in your script.

119
00:10:46.280 --> 00:10:47.540
Again, very convenient.

120
00:10:47.870 --> 00:10:54.770
As well as Posman, you could alternatively use Kerl and Lennix orbit a quest module in Python to test

121
00:10:54.770 --> 00:10:55.490
APIs.

122
00:10:55.700 --> 00:11:01.280
But Posman, because it uses a guey and it's got a lot of added functionality, is the most popular

123
00:11:01.280 --> 00:11:01.730
choice.

124
00:11:01.910 --> 00:11:04.550
And I'll show you how to use it in the next lecture.

