WEBVTT
1
00:00:07.400 --> 00:00:16.400
In this lecture, you'll learn about the data serialization format, XML, Jeshurun and Yamal to give

2
00:00:16.400 --> 00:00:17.960
you the definition.

3
00:00:18.200 --> 00:00:26.390
The utilization is the process of converting your data to a standardized format that allows shading

4
00:00:26.390 --> 00:00:32.270
or storage of data and a form that allows recovery of its original structure.

5
00:00:32.479 --> 00:00:41.090
So basically what that means is allows transfer the data between different systems applications on programming

6
00:00:41.090 --> 00:00:49.820
languages because storing the data in a standardized format and free of the available format types are

7
00:00:49.820 --> 00:00:52.830
XML, JSON and YAML.

8
00:00:53.600 --> 00:00:59.270
Obviously they have to be machine readable for the data to be shared between machines.

9
00:00:59.430 --> 00:01:02.280
They're also designed to be human readable as well.

10
00:01:02.280 --> 00:01:06.520
Thoo to make it easier for us to work with them and their plaintext.

11
00:01:06.530 --> 00:01:08.380
The encoding format.

12
00:01:09.370 --> 00:01:16.920
The data formats are mostly interchangeable, meaning normally you can use any of them, it just depends

13
00:01:16.930 --> 00:01:21.110
what is supported on the particular system you're working on at the time.

14
00:01:21.340 --> 00:01:25.440
Often you'll be able to choose between multiple different formats.

15
00:01:25.730 --> 00:01:34.180
For example, if you're working with Python programming, it's capable of reading and writing with all

16
00:01:34.180 --> 00:01:35.650
three of those formats.

17
00:01:35.920 --> 00:01:39.640
So the one to use depends on support and the system is being used with.

18
00:01:39.790 --> 00:01:42.880
And which one is easiest for you?

19
00:01:43.030 --> 00:01:47.570
I'll talk about which ones are easier than the others as we go through this venture.

20
00:01:48.470 --> 00:01:56.620
So starting off with Jay, Sean will start here because this is the one that you're most likely to be

21
00:01:56.620 --> 00:01:59.580
tested on in the Shishani exam.

22
00:01:59.590 --> 00:02:06.550
One of the requirements is that you're able to read Jeshurun formatting, so join it stands for JavaScript

23
00:02:06.550 --> 00:02:07.650
object notation.

24
00:02:07.870 --> 00:02:16.570
This was first standardized in 2013 and it's easier for humans to read and work with than XML.

25
00:02:16.780 --> 00:02:20.560
XML has been around for a longer time and so on.

26
00:02:20.810 --> 00:02:27.690
And one of the reasons for on being developed was to have an easier format to read.

27
00:02:28.270 --> 00:02:35.140
Jason can be imported directly into JavaScript, which is commonly used on the Internet and with on

28
00:02:35.140 --> 00:02:39.010
white space in the text has got no special meaning.

29
00:02:39.250 --> 00:02:42.600
RESTful APIs often use Jason.

30
00:02:42.790 --> 00:02:46.570
We'll be talking about Restoril APIs in this section.

31
00:02:46.900 --> 00:02:49.840
So the different data types in Jason.

32
00:02:49.840 --> 00:02:55.360
So I'm going to break down the syntax in the format of how Jason works now.

33
00:02:55.540 --> 00:02:58.720
And first off, I need to tell you what the different data types are.

34
00:02:58.810 --> 00:03:03.040
I'll be explaining each of these as we go through the following slides.

35
00:03:03.190 --> 00:03:09.980
So the different types are object, array, string, no boolean and null.

36
00:03:10.000 --> 00:03:19.990
So let's start off with object, an object as an unordered collection of key value pairs which describe

37
00:03:19.990 --> 00:03:29.200
the thing, whatever the object is, when the object is written in Jason format is surrounded by curly

38
00:03:29.200 --> 00:03:29.970
braces.

39
00:03:30.430 --> 00:03:34.180
So we've got the key value pairs which describe the object.

40
00:03:34.360 --> 00:03:44.490
The keys must be strings, meaning a set of characters and the values must be evaluated based on data

41
00:03:44.500 --> 00:03:44.860
type.

42
00:03:44.910 --> 00:03:54.760
So those earlier six types of string, no object array, boolean or no, the keys and values are separated

43
00:03:54.760 --> 00:04:02.950
by a cool on when written and each key value pair is separated by a comma until we get to the last one

44
00:04:02.980 --> 00:04:03.250
there.

45
00:04:03.520 --> 00:04:08.470
So having a look at an example here, you can see we've got an object.

46
00:04:08.710 --> 00:04:13.540
We can tell that because it opens and closes with curly brackets.

47
00:04:13.720 --> 00:04:19.660
And then in here we've got the unordered collection of key value pairs which describe it.

48
00:04:19.970 --> 00:04:22.960
So we're looking at the description for an interface here.

49
00:04:23.110 --> 00:04:31.480
You can see here is the key is the name and then the value is gigabit Ethernet one.

50
00:04:31.810 --> 00:04:36.670
And then we've got the next key, which is description and value Internet link.

51
00:04:36.790 --> 00:04:39.970
And then we've got the key enabled and the value of two.

52
00:04:39.970 --> 00:04:43.210
So you can see there and we've got three key value pairs.

53
00:04:43.330 --> 00:04:48.780
We've got the key first, then the value, and they're separated by a cool one.

54
00:04:49.060 --> 00:04:51.310
OK, moving on.

55
00:04:51.340 --> 00:05:01.150
The next one is array and where an object is an unordered list and array as an ordered list of values

56
00:05:01.510 --> 00:05:09.500
and where an object is surrounded by curly brackets, the array is surrounded by square brackets.

57
00:05:09.500 --> 00:05:11.080
So that's how you can tell them apart.

58
00:05:11.830 --> 00:05:15.370
With our arrays, values must be average.

59
00:05:15.400 --> 00:05:16.750
So they attack again.

60
00:05:16.770 --> 00:05:20.410
String no object array boolean or no.

61
00:05:20.640 --> 00:05:26.590
You can see here the value for an array could be another array or it could be an object.

62
00:05:26.590 --> 00:05:33.010
And going back a right, it's the same for our object, but can include an object ordinary as well.

63
00:05:33.220 --> 00:05:40.900
So we can nashed our values, we can have objects within objects, we can have arrays within arrays

64
00:05:40.900 --> 00:05:42.870
and we can have them within each other as well.

65
00:05:42.880 --> 00:05:47.200
You'll see some examples of the next thing as I go through this lecture.

66
00:05:47.560 --> 00:05:49.300
So an example of an array.

67
00:05:49.300 --> 00:05:55.480
In fact, you can see here that we are nesting and are rare inside an object with the object here.

68
00:05:55.480 --> 00:05:59.440
We can see that from the curly bracket on the object.

69
00:05:59.440 --> 00:06:05.680
We've got the key values there of the name is John and his age is 25.

70
00:06:06.040 --> 00:06:07.980
And then we've got the.

71
00:06:08.280 --> 00:06:15.270
Value where the key is girlfriends and value is an array, and we've conceived of the array there,

72
00:06:15.270 --> 00:06:20.530
which is open and closed with the square brackets, and we've got the list there of John's girlfriends,

73
00:06:20.730 --> 00:06:22.920
our Steve and Amy.

74
00:06:23.230 --> 00:06:29.550
And you can see here on our object that each of the key value pairs there, we've got a comma after

75
00:06:29.550 --> 00:06:32.040
each one, apart from the last one.

76
00:06:32.160 --> 00:06:37.340
And it's the same in the array as well, where the are separated by commas.

77
00:06:37.350 --> 00:06:40.530
But we don't have a comma after the last one there.

78
00:06:41.760 --> 00:06:49.080
OK, and more example of Nashton here, you can see here that we've got an object, so we're opening

79
00:06:49.080 --> 00:06:56.250
and then closing the object and then in there we have got an array.

80
00:06:56.340 --> 00:07:00.010
And in the array, we've got two objects nested in the array.

81
00:07:00.300 --> 00:07:07.620
We've got our first IP address and subnet mask and then our second IP address on subnet mask.

82
00:07:08.550 --> 00:07:16.710
OK, moving on to the other, Jason, the types apart from object and array are a string, so a string

83
00:07:16.710 --> 00:07:25.740
is an alphanumeric string of characters and with our strings they are always showing in enclosed in

84
00:07:25.740 --> 00:07:26.320
quotes.

85
00:07:26.520 --> 00:07:28.510
So the key is always a string.

86
00:07:28.510 --> 00:07:31.040
So that's where the key is always within quotes.

87
00:07:31.230 --> 00:07:34.110
And then we've got the Coolen to separate from the value.

88
00:07:34.260 --> 00:07:36.000
And then you can see this is a string.

89
00:07:36.000 --> 00:07:39.320
We can tell it's a string because that is in quotes as well.

90
00:07:39.810 --> 00:07:42.330
The next day a type is a number.

91
00:07:42.480 --> 00:07:48.030
So here the example here, the key is input ETAs and then the value there is three.

92
00:07:48.210 --> 00:07:53.160
When we're specifying a type, which is not a string, we don't put it in quotes.

93
00:07:53.280 --> 00:07:59.430
So you can see here, it's not in quotes and it's a no videotape is no boolean is either going to be

94
00:07:59.430 --> 00:08:00.400
true or false.

95
00:08:00.440 --> 00:08:06.690
So here we are describing the interface in this example is enabled or not, that's a boolean value.

96
00:08:06.690 --> 00:08:10.140
Either it's true or false on whatever the interface is enabled.

97
00:08:10.380 --> 00:08:13.740
And finally, we can have another value as well.

98
00:08:13.890 --> 00:08:16.830
No can be written explicitly as no.

99
00:08:16.980 --> 00:08:19.380
Or you could just have a blank value there.

100
00:08:19.530 --> 00:08:24.090
It depends on the particular application you're working with at the time.

101
00:08:24.090 --> 00:08:27.570
If the null value you should see null are only the blank.

102
00:08:28.620 --> 00:08:32.850
OK, so that is the format of Jason.

103
00:08:33.070 --> 00:08:33.370
Let's go.

104
00:08:33.400 --> 00:08:35.780
Another final example here as well.

105
00:08:36.000 --> 00:08:42.630
And this gives you an example of where it would be used for network programmability, where we have

106
00:08:42.630 --> 00:08:46.890
got the object opened at the top and includes down at the bottom here.

107
00:08:47.200 --> 00:08:53.890
And then we've got multiple objects and arrays inside there describing our interfaces.

108
00:08:53.910 --> 00:08:55.970
So we've got two different interfaces.

109
00:08:56.100 --> 00:09:03.920
So that's why we've got an array opened here and then closed down here for our different interfaces.

110
00:09:04.170 --> 00:09:06.860
We've got an object inside the array.

111
00:09:06.880 --> 00:09:13.380
The first object is interface gigabit Ethernet one, and we've also got interface gigabit Ethernet as

112
00:09:13.380 --> 00:09:13.700
well.

113
00:09:13.920 --> 00:09:17.460
We've also got nested arrays for the IP addresses in there.

114
00:09:17.610 --> 00:09:22.500
So you can see here we've got nested arrays because you can have multiple interfaces on the device.

115
00:09:22.690 --> 00:09:27.260
You can also have multiple IP addresses on the interfaces as well.

116
00:09:27.570 --> 00:09:34.290
And this is how it would be written in Jessalyn format if you wanted to have a description of your two

117
00:09:34.770 --> 00:09:38.460
interfaces on your device and the IP addresses on there.

118
00:09:38.620 --> 00:09:44.600
OK, so that was the syntax of the John Deere format.

119
00:09:45.060 --> 00:09:51.900
Moving on, the next one is XML XML with Standardised in 1998.

120
00:09:52.050 --> 00:09:55.620
It's been around a lot longer than John.

121
00:09:55.710 --> 00:10:01.140
It's widely used across the Internet and similar with each HTML.

122
00:10:01.290 --> 00:10:05.350
XML was designed to describe and transfer the bowl.

123
00:10:05.590 --> 00:10:11.520
Well, each e-mail is focused on how to display the data with your webpages on the Internet.

124
00:10:11.940 --> 00:10:17.550
White space has no special meaning in XML, the same as it is in Jeshurun.

125
00:10:17.820 --> 00:10:26.110
And again, we've got our list here of our key value pairs and that they are contained within objects.

126
00:10:26.130 --> 00:10:35.250
So you can see an example of a here and we open it with the words inside our is here and in the closet

127
00:10:35.250 --> 00:10:38.670
we repeat the word again, but we put a slash in front of it.

128
00:10:38.820 --> 00:10:44.280
So let's have a look at an example of XML, same kind of information that we were looking at earlier

129
00:10:44.280 --> 00:10:47.820
about our interfaces to earlier on.

130
00:10:47.820 --> 00:10:55.230
You saw how similar information here would be in general, and this is how we would write in XML.

131
00:10:55.440 --> 00:11:02.340
So you can see here we've got our gigabit Ethernet one interface and to open that tag, we've got name

132
00:11:02.340 --> 00:11:04.590
inside our Ottos and close it.

133
00:11:04.590 --> 00:11:10.110
We say name again as well again inside our Ottos and we put a slash there in front of the name.

134
00:11:10.350 --> 00:11:12.360
We do the same thing for Internet link.

135
00:11:12.360 --> 00:11:18.300
We're opening and closing the description, opening and closing, that is true, etc..

136
00:11:18.480 --> 00:11:23.790
So that is the XML format that's been around for a long time.

137
00:11:23.790 --> 00:11:30.360
There's very wide support for it, but it's not quite as easy to work with and read as JSON is.

138
00:11:30.540 --> 00:11:37.290
So developers will typically prefer to use JSON over XML if it is available.

139
00:11:37.380 --> 00:11:39.240
Use that with whatever they are working on.

140
00:11:40.290 --> 00:11:50.310
Give the last one is YAML, and this stands for Yamal in markup language, a bit of humor for you there.

141
00:11:50.520 --> 00:11:55.590
Yamal is often used in Python, Perl and Ansible.

142
00:11:55.860 --> 00:12:02.160
Again, like Jeshurun, designed to be easily read by humans with Yamal.

143
00:12:02.160 --> 00:12:05.260
The white space or the indentation is important.

144
00:12:05.370 --> 00:12:13.650
The big difference between Yamal and XML aren't on anything at a comment indentation level in Yamal

145
00:12:13.770 --> 00:12:19.480
is considered to be related at that same level with our Yamal files.

146
00:12:19.500 --> 00:12:21.750
They always start with three dashes.

147
00:12:22.000 --> 00:12:25.350
That is how indicates is a Yamal file.

148
00:12:25.560 --> 00:12:33.690
Again, it uses key value representation, the same as V of our format and inside our YAML file, Adarsh

149
00:12:33.690 --> 00:12:39.150
indicates on W I mentioned it's often used with Ansible, your ansible playbook's use.

150
00:12:39.150 --> 00:12:46.230
Yamal will be having a look at how Ansible works and I want more detail later on and you'll see Yamal

151
00:12:46.230 --> 00:12:47.250
being used then.

152
00:12:48.120 --> 00:12:53.340
Ferdo here is an example of the Yamal syntax and format.

153
00:12:53.540 --> 00:13:00.060
You can see it starts with the three dashes and then we've got again, similar information.

154
00:13:00.060 --> 00:13:06.540
We're looking here, ISEF interfaces interface and we've got our key value pairs, which, again, are

155
00:13:06.990 --> 00:13:09.330
are separated by a cool on.

156
00:13:09.630 --> 00:13:16.380
And you can see here, but the name description enabled and IETF IAFF are all at the same level.

157
00:13:16.390 --> 00:13:19.860
So normally you use two spaces for each indentation.

158
00:13:19.990 --> 00:13:25.920
So I've got two spaces in front of each of these to indicate that a lower level than the top level.

159
00:13:26.220 --> 00:13:31.470
And then we get down to some information, which is via Drash or not interface.

160
00:13:31.710 --> 00:13:38.370
We've got that indented another two spaces as well, because we can have multiple addresses on our interfaces.

161
00:13:38.370 --> 00:13:40.500
We've got a list below that.

162
00:13:40.650 --> 00:13:42.600
And again, we've got that and then it's.

163
00:13:43.230 --> 00:13:54.300
OK, so that was what our DC utilization is, the common format of XML, Alg�n and Yamal and how they

164
00:13:54.300 --> 00:13:56.640
are written to you in the next lecture.

