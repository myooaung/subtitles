WEBVTT
1
00:00:07.470 --> 00:00:15.030
Cisco, don't expect you to be a developer, you can write your own code for the Shishani exam, but

2
00:00:15.030 --> 00:00:22.740
they do expect you to know some of the basic terminology around development and the way that developers

3
00:00:22.740 --> 00:00:23.210
work.

4
00:00:23.220 --> 00:00:26.970
So I'm going to cover those in the short lecture here.

5
00:00:27.450 --> 00:00:30.030
First up is about Python.

6
00:00:30.240 --> 00:00:37.890
And Python is typically the language of choice for network programmability for several reasons.

7
00:00:38.070 --> 00:00:43.450
It's relatively easy to learn and many different training resources available.

8
00:00:43.800 --> 00:00:50.280
The python scripting language is human readable, and it's easy by reading through it to see what's

9
00:00:50.280 --> 00:00:51.000
going on.

10
00:00:51.210 --> 00:00:53.100
It's free, open source.

11
00:00:53.250 --> 00:00:56.460
It can be installed on all popular operating systems.

12
00:00:56.570 --> 00:01:00.900
It's actually built into Linux and mark by default.

13
00:01:01.230 --> 00:01:04.769
And it's easy to find network automation code samples.

14
00:01:04.920 --> 00:01:10.360
So you don't have to start from a blank page all the time for anything that you want to do.

15
00:01:10.500 --> 00:01:16.080
You can typically find a code sample where somebody is already done not and then you maybe just need

16
00:01:16.080 --> 00:01:19.450
to modify it slightly for your particular environment.

17
00:01:20.570 --> 00:01:29.960
Next thing is get get is version control system, which tracks changes in source code and fails, it's

18
00:01:29.960 --> 00:01:36.650
typically used for software development, but it can also provide version control for any type of files

19
00:01:37.130 --> 00:01:40.120
with most client server version control systems.

20
00:01:40.120 --> 00:01:47.150
So over her version, control systems do exist, but get as by far the most popular one these days with

21
00:01:47.150 --> 00:01:49.340
a client server version control system.

22
00:01:49.580 --> 00:01:55.280
The code has to be checked out and can only be worked on by one developer at a time.

23
00:01:55.920 --> 00:01:57.800
So get the benefits that you get.

24
00:01:57.800 --> 00:02:03.020
You get the version control there to it keeps track of the changes that have been made.

25
00:02:03.230 --> 00:02:07.150
And it's very easy to roll back to the previous version.

26
00:02:07.280 --> 00:02:15.170
It's also very useful when you're working as part of a team where multiple people can work on the code.

27
00:02:15.170 --> 00:02:21.800
At the same time, if you've got a client server version of that servers, one master copy of it and

28
00:02:21.800 --> 00:02:26.020
only one person can work on the code at a time, get is different.

29
00:02:26.030 --> 00:02:28.600
It's a distributed version control system.

30
00:02:29.180 --> 00:02:35.750
So with it being a distributed version control system, every directory on every computer is a fully

31
00:02:35.750 --> 00:02:40.600
fledged repository with complete history and full version tracking abilities.

32
00:02:40.730 --> 00:02:47.600
So when you've got multiple developers working on the same project, they can all have their own separate

33
00:02:47.600 --> 00:02:51.620
copy of the project and they can start their own branches from there.

34
00:02:51.620 --> 00:02:54.950
And it's very easy to merge everything into the same code.

35
00:02:55.760 --> 00:03:02.330
Organizations do typically designate one repository as the master copy just for ease of management,

36
00:03:02.540 --> 00:03:05.330
but the architecture of it is it's distributed.

37
00:03:05.450 --> 00:03:10.010
Every separate repository is a complete, separate copy of the repository.

38
00:03:10.490 --> 00:03:12.770
OK, so that gives you your version.

39
00:03:12.770 --> 00:03:17.030
Control makes it easy to work on code when you're working as part of a team.

40
00:03:17.250 --> 00:03:18.880
There's also get help now.

41
00:03:18.920 --> 00:03:22.070
Get and get Halbe are two different things.

42
00:03:22.250 --> 00:03:23.960
So get is the version.

43
00:03:23.960 --> 00:03:31.610
Control software Git Hub is a repository hosting service which adds many of its own features.

44
00:03:31.670 --> 00:03:35.390
A repository, by the way, is just a place that you can keep things.

45
00:03:35.540 --> 00:03:41.150
So if you've got a source code repository, it's where you're keeping all files that are making up the

46
00:03:41.180 --> 00:03:41.930
source code.

47
00:03:42.230 --> 00:03:47.450
Repositories in GitHub can be private or they can be publicly shared.

48
00:03:47.660 --> 00:03:52.190
They can be easily copied between users on task management.

49
00:03:52.190 --> 00:03:57.800
Tools are available which make it easier when you're working as part of a team and control mechanisms

50
00:03:57.830 --> 00:04:04.160
provides you to resolve conflicts, as I mentioned earlier, with get as distributed and you can have

51
00:04:04.160 --> 00:04:10.610
multiple people working on it sometime soon over when you've only got one single master copy which one

52
00:04:10.610 --> 00:04:13.430
person can work on at a time because it's distributed.

53
00:04:13.610 --> 00:04:19.070
It is possible that conflicts where can arise where you've got people that have made changes to the

54
00:04:19.070 --> 00:04:25.350
same part of the code and it's different changes for our tools within Git on GitHub to help you resolve.

55
00:04:26.860 --> 00:04:37.120
OK, the last thing to talk about here is she said she stands for continuous integration on CD is continuous

56
00:04:37.120 --> 00:04:39.490
delivery or continuous deployment.

57
00:04:39.500 --> 00:04:41.310
You can use either one of those terms.

58
00:04:41.320 --> 00:04:42.310
They're both CD.

59
00:04:42.690 --> 00:04:50.350
Shiki is a set of operating principles and practices that enable application development teams to deliver

60
00:04:50.350 --> 00:04:53.530
chord changes more frequently and reliable.

61
00:04:53.680 --> 00:04:56.180
So she said it's not a thing that you can touch.

62
00:04:56.200 --> 00:04:57.610
It's not like a piece of software.

63
00:04:57.790 --> 00:05:03.020
It is really best practices for how software development teams work.

64
00:05:03.020 --> 00:05:10.390
That with software development teams producing CWD, frequent changes are more efficient than rolling

65
00:05:10.390 --> 00:05:12.340
them up into large change windows.

66
00:05:12.370 --> 00:05:17.800
So when record is written and it's ready to be put into production, it's seen as a best practice.

67
00:05:17.800 --> 00:05:23.500
Now that you do that frequently, it's better to have frequent changes than rolling up all your changes

68
00:05:23.620 --> 00:05:26.790
into a huge bundle and then doing that.

69
00:05:26.800 --> 00:05:29.500
And frequently, I mean putting it into production.

70
00:05:30.160 --> 00:05:37.270
Automation of building, testing and deployment allows you to make those frequent changes and still

71
00:05:37.270 --> 00:05:40.960
having them being quality changes without causing problems.

72
00:05:41.140 --> 00:05:48.130
And the implementation when you're doing this is new as your QEI CD pipeline software tools such as

73
00:05:48.130 --> 00:05:49.660
Jenkins and Travis.

74
00:05:49.810 --> 00:05:53.710
I can age management of the pipeline in your environment.

75
00:05:53.950 --> 00:06:00.790
OK, so that was all the basic information around development required for decision that I needed to

76
00:06:00.790 --> 00:06:01.780
talk about here.

77
00:06:01.990 --> 00:06:03.640
I'll see you in the next lecture.

