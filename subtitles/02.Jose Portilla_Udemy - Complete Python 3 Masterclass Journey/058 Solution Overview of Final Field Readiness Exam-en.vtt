WEBVTT
1

00:00:00.210 --> 00:00:01.210

We'll come back.



2

00:00:01.350 --> 00:00:05.130

Let's now go over your solutions for the final field readiness exam.



3

00:00:05.130 --> 00:00:12.120

Let's begin by running the Celt import string in random and then we will start off with our method in



4

00:00:12.120 --> 00:00:14.360

our encryption class.



5

00:00:14.400 --> 00:00:21.910

So the first thing I wanted to do was a random seed and you can do that by saying random seed.



6

00:00:22.260 --> 00:00:24.510

And then we're passing in a seed parameter.



7

00:00:24.540 --> 00:00:34.080

So we will go ahead and have that be user defined then we will say self dot seed is equal to the seed



8

00:00:34.080 --> 00:00:35.490

premire the find.



9

00:00:35.580 --> 00:00:42.090

So upon initial initialization or an instantiation of an instance of this encryption class we've gone



10

00:00:42.090 --> 00:00:48.420

ahead and set the seed for a random library and then we also mark it down as our seed then we're going



11

00:00:48.420 --> 00:00:51.900

to create an empty string attribute to hold the encrypted phrase.



12

00:00:52.080 --> 00:01:00.960

So we will say self-taught encrypted phrase and have that be an empty string.



13

00:01:00.960 --> 00:01:07.350

And then the next thing we're going to do is use the string and random libraries to create two attributes



14

00:01:07.440 --> 00:01:10.980

one of them will be called the true alphabet.



15

00:01:13.400 --> 00:01:20.330

Now we're just going to have that string dot s.c.i lowercase and we're actually going to have this be



16

00:01:20.390 --> 00:01:28.440

a list that way we can play around with its indexing later on and we will say sulf thoughts ran the



17

00:01:28.500 --> 00:01:29.720

alphabet.



18

00:01:30.420 --> 00:01:35.560

And that's going to be equal to as the hints supplied a random sample.



19

00:01:35.880 --> 00:01:40.970

And we're going to Passons self-taught true alphabet.



20

00:01:42.940 --> 00:01:49.420

By length of self-taught true alphabet.



21

00:01:49.750 --> 00:01:53.700

So let me zoom out here just a little bit so we can see the whole thing.



22

00:01:53.770 --> 00:01:59.830

And those are our attributes so we have our seat attribute and MT-NW crypt that phrase or will fill



23

00:01:59.830 --> 00:02:00.480

out later.



24

00:02:00.520 --> 00:02:07.890

And then the true alphabet and the random alphabet the next thing to do is begin our encryption method.



25

00:02:08.230 --> 00:02:14.010

So we'll start by having an output string that we intend to fill out later.



26

00:02:14.410 --> 00:02:18.160

And step one is to replace every other letter with a random letter.



27

00:02:18.160 --> 00:02:19.210

So we'll do the following.



28

00:02:19.210 --> 00:02:29.260

We'll say four and we can zoom back in here for I in range the length of the message.



29

00:02:29.290 --> 00:02:31.790

I remember the message is what's being supplied here.



30

00:02:31.960 --> 00:02:35.050

Trying to pass your message through the encryption method.



31

00:02:35.670 --> 00:02:43.650

So for i in range of length the message will say the output and will add in message.



32

00:02:44.560 --> 00:02:52.140

And then we'll also say grab that same output and then concatenate ran them and we'll take in a random



33

00:02:52.140 --> 00:02:59.660

sample from self true alphabet comma 1 0.



34

00:02:59.880 --> 00:03:02.490

So let's see what's actually happening here.



35

00:03:02.570 --> 00:03:10.100

We've define an empty string called output then for I in range length of the message.



36

00:03:10.430 --> 00:03:19.010

Go ahead and grab the empty string output and then concatenate message at index I which is essentially



37

00:03:19.070 --> 00:03:25.160

just going to be the letter at that message and then right after you put in the letter of the message



38

00:03:25.460 --> 00:03:30.110

you're going to take a random sample from your true alphabet.



39

00:03:30.110 --> 00:03:37.550

So you're going to grab one random letter and because this is a list that is returned you can go ahead



40

00:03:37.640 --> 00:03:41.780

and grab the first item in that list of 1.



41

00:03:41.810 --> 00:03:47.270

So that's where we have this indexing here because basically a random sample just to kind of show you



42

00:03:47.270 --> 00:03:50.510

here or return something like this.



43

00:03:50.510 --> 00:03:53.050

So a list of just one random letter.



44

00:03:53.240 --> 00:03:59.390

So in order to sample off of this we use that indexing of zero to just grab that string so we can concatenate



45

00:03:59.390 --> 00:04:00.190

it on.



46

00:04:00.200 --> 00:04:05.930

Now there's different ways of doing this but this is the one that is essentially showing the logic more



47

00:04:05.930 --> 00:04:07.940

precisely than some other methods.



48

00:04:07.940 --> 00:04:12.220

Again there's many many ways to do this to reverse the string.



49

00:04:12.220 --> 00:04:19.330

What we can do is start defining or encrypt that phrase so will say self encrypt that phrase is equal



50

00:04:19.330 --> 00:04:21.230

to the output.



51

00:04:21.340 --> 00:04:26.610

And then we can easily reverse it with indexing using this method.



52

00:04:27.100 --> 00:04:31.570

The final step is to use the random shuffle alphabet for a Caesar cipher.



53

00:04:31.600 --> 00:04:36.310

Let's go ahead and delete the past statement and begin to write that out.



54

00:04:36.310 --> 00:04:45.360

I'm going to create a variable called encrypted Phase 2 and it's basically going to be a bit of a placeholder



55

00:04:45.660 --> 00:04:47.460

that we can add on to.



56

00:04:47.460 --> 00:04:57.390

So it's going to be a list and it's going to go range length of self-taught encrypted phrase.



57

00:04:57.520 --> 00:05:04.570

So right now self-tanning encrypt that phrase is our current message where we added in random letters



58

00:05:04.570 --> 00:05:07.520

for every other letter and then we reverse it.



59

00:05:07.780 --> 00:05:10.840

And then what we have here is a list encrypted.



60

00:05:10.840 --> 00:05:18.670

Phase two that is essentially just all the numbers of how long from zero all the way to the length of



61

00:05:18.670 --> 00:05:19.790

the encrypted phrase.



62

00:05:19.810 --> 00:05:25.570

So its range here and we created the list out of it range going from zero all the way to the length



63

00:05:25.660 --> 00:05:28.110

of the self-signed Krup that phrase.



64

00:05:28.110 --> 00:05:31.520

So now that I have this encrypted phase to list I can play around with it.



65

00:05:32.400 --> 00:05:42.880

So we will say four letter tuple and packing here and enumerates self dots and we're going to grab our



66

00:05:42.880 --> 00:05:52.530

encrypted phrase and we're going to make it all lowercase so he can do the following we'll say if the



67

00:05:52.530 --> 00:05:59.190

letter is in self true alphabet.



68

00:05:59.760 --> 00:06:05.070

And the reason I check if letter in self-taught true alphabet is that way in case I have punctuation



69

00:06:05.490 --> 00:06:17.830

I can say something like Else encrypted face to at that point and I it's just equal to the letter.



70

00:06:17.850 --> 00:06:26.360

So this is essentially only going to happen for punctuation punctuation and spaces.



71

00:06:26.500 --> 00:06:33.010

So that's why I have this if statement so I'm going for every letter an index position in my encrypted



72

00:06:33.010 --> 00:06:35.330

phrase lowercase.



73

00:06:35.350 --> 00:06:38.480

And I'm going to check if that letter is actually in the alphabet.



74

00:06:38.590 --> 00:06:40.620

Meaning I'm dealing with an alphabet letter.



75

00:06:40.660 --> 00:06:46.090

I actually want to swap it for Caesar cypher which means we'll do the following.



76

00:06:46.330 --> 00:06:52.280

We'll say index is equal to self-taught.



77

00:06:52.870 --> 00:06:54.010

True alphabet.



78

00:06:54.100 --> 00:07:06.790

And I'm going to find the index location of the letter and then we will say encrypted phrase to an exposition



79

00:07:06.860 --> 00:07:13.900

I is now equal to self-taught and my randomized alphabet at that next position.



80

00:07:13.900 --> 00:07:16.440

So this is the Caesar cipher in operation.



81

00:07:16.720 --> 00:07:22.750

What we're doing again here is if we actually have an alphabetic letter find that index location in



82

00:07:22.750 --> 00:07:29.380

the alphabet and then find the matching in the location in our shuffled alphabet and do the re-assignment



83

00:07:29.380 --> 00:07:34.870

there then what we're going to do is after this entire for loop is done running.



84

00:07:34.870 --> 00:07:44.210

I'm going to set self-taught encrypt that phrase equal to and I'm going to join the Phase 2 of it.



85

00:07:44.260 --> 00:07:53.840

I will say join encrypted phase to remember.



86

00:07:53.950 --> 00:07:57.260

This basically takes this list and joins it as a string.



87

00:07:57.460 --> 00:08:05.140

And then when I can do after this is it's all done so I can return self-taught encrypted phrase.



88

00:08:05.140 --> 00:08:09.370

So let's run this and see if our encryption looks like it's working it's going to be hard to tell at



89

00:08:09.370 --> 00:08:13.060

first whether it's working or not because we would need to decrypt it to confirm that.



90

00:08:13.330 --> 00:08:15.670

But let's run this and see what we have.



91

00:08:15.670 --> 00:08:20.920

So I'm going to encrypt that with 20 and then we'll do the encryption of hello world.



92

00:08:21.070 --> 00:08:24.700

And if I run that I get back the exact same result as expected.



93

00:08:24.700 --> 00:08:26.060

And let's kind of edit this a bit.



94

00:08:26.080 --> 00:08:27.950

So add in some random letters here.



95

00:08:28.130 --> 00:08:31.750

Now we can see it's still working and it looks like a completely different result.



96

00:08:31.750 --> 00:08:35.870

So it looks like a pretty good encryption method at least for the very basics.



97

00:08:36.280 --> 00:08:39.690

And if we do hello world again we can see if we get this result.



98

00:08:39.690 --> 00:08:40.080

All right.



99

00:08:40.090 --> 00:08:44.970

Now it's time for the decryption and decryption is essentially the exact same thing.



100

00:08:44.980 --> 00:08:46.450

It just reverses everything.



101

00:08:46.450 --> 00:08:47.370

So let's do that.



102

00:08:49.100 --> 00:08:51.250

We need a seed in order to set random.



103

00:08:51.260 --> 00:08:58.420

So we're going to say random seed seed and then for this particular decryption session we're going to



104

00:08:58.420 --> 00:09:00.080

have our randomized alphabet.



105

00:09:00.370 --> 00:09:11.640

So we will say session Rande alphabets is equal to and say a random sample will grab from the true alphabet



106

00:09:13.210 --> 00:09:19.560

and then say do this for the length of true alphabet.



107

00:09:21.580 --> 00:09:25.330

We can zoom out here in case you want to see the whole line.



108

00:09:25.390 --> 00:09:33.140

Then after this we are going to say that the decrypted message is equal to.



109

00:09:33.200 --> 00:09:41.810

And we're going to do a list just like we did before list of length message and that's the message I'm



110

00:09:41.810 --> 00:09:42.890

trying to decrypt.



111

00:09:42.890 --> 00:09:45.620

So this is an encrypted messages coming in.



112

00:09:45.710 --> 00:09:47.390

So keep that in mind.



113

00:09:47.690 --> 00:09:53.210

And then what we're going to do here is once we have that encrypted message list we're going to undo



114

00:09:53.210 --> 00:09:55.180

the randomized Caesar cipher.



115

00:09:55.270 --> 00:10:04.780

So I will say for I letter in enumerates and this is essentially the same thing we did before lowercase



116

00:10:04.780 --> 00:10:06.220

that message.



117

00:10:06.470 --> 00:10:14.300

If the letter is in the actual alphabet then we'll do the exact opposite or say that the position is



118

00:10:14.300 --> 00:10:17.270

equal to my session Rande alphabet



119

00:10:19.920 --> 00:10:22.790

index that that letter.



120

00:10:22.930 --> 00:10:33.910

And then I will say my decrypted a message that location I is equal to self-taught true alphabet at



121

00:10:33.940 --> 00:10:40.360

that location and then if I'm dealing with punctuation or something else I'm going to say that my decrypted



122

00:10:40.360 --> 00:10:45.940

a message of-I is just equal to the actual letter.



123

00:10:49.630 --> 00:10:57.910

And then I'm just going to join this to bring it back into a string so I'll say decrypted message is



124

00:10:57.910 --> 00:10:58.600

equal to



125

00:11:01.380 --> 00:11:06.280

let's zoom in here so we can see a little better Zirkle to join of that list.



126

00:11:06.280 --> 00:11:13.040

So we'll join our decrypted a message and now if I have my decrypted message I still need to do two



127

00:11:13.040 --> 00:11:13.550

things.



128

00:11:13.550 --> 00:11:16.440

So let's run this and see the two things I need to do.



129

00:11:16.670 --> 00:11:18.240

So my encryption of hello world.



130

00:11:18.260 --> 00:11:24.650

And if I pass in this code here with the seed 20 will return or decrypted a message just so we can actually



131

00:11:24.650 --> 00:11:26.460

see what the result is.



132

00:11:26.480 --> 00:11:29.120

Return the cryptic message.



133

00:11:29.120 --> 00:11:32.780

Run this and I get back something that looks like this.



134

00:11:32.780 --> 00:11:36.400

So right now I still need to reverse this string.



135

00:11:36.410 --> 00:11:39.530

I can see here I have h e l l o.



136

00:11:39.740 --> 00:11:43.940

So let's reverse that and I can simply reverse by using slicing.



137

00:11:43.940 --> 00:11:49.840

So let's just do a call uncle a negative one off of this decrypted message and then run these again.



138

00:11:49.910 --> 00:11:52.020

And I can see I've successfully reversed that.



139

00:11:52.190 --> 00:11:55.090

And now what I want to do is grab every other letter.



140

00:11:55.130 --> 00:12:00.950

So to do that I can simply just say starting from the beginning all the way into the end and step sizes



141

00:12:00.950 --> 00:12:06.530

of two and I will grab every other letter and you can use a for loop to do a re-assignment as well but



142

00:12:06.620 --> 00:12:08.690

slicing is a nice little trick to use here.



143

00:12:08.870 --> 00:12:10.590

And then if we run that we get back.



144

00:12:10.610 --> 00:12:11.950

Hello world.



145

00:12:12.080 --> 00:12:20.580

So let's do a quick rundown of everything we just did because there is a lot going on here.



146

00:12:20.590 --> 00:12:27.610

We started off by creating our attributes where we assigned a seed that way we can shuffle the same



147

00:12:27.610 --> 00:12:29.760

way the shuffled alphabet.



148

00:12:29.770 --> 00:12:35.980

We created an empty encrypted phrase string to hold and then we set a true alphabet which is just the



149

00:12:35.980 --> 00:12:38.190

list version of the lower case letters.



150

00:12:38.380 --> 00:12:45.090

And then we created a random alphabet using random sample as hinted right here in this comment.



151

00:12:45.310 --> 00:12:49.140

And then what we wanted to do was our encryption method.



152

00:12:49.210 --> 00:12:52.640

So we set up an output string that was empty.



153

00:12:52.850 --> 00:12:58.220

Then the next thing we did was for I in interchange length of message.



154

00:12:58.250 --> 00:13:04.970

So essentially for every letter or index position in the message we concatenated to that string that



155

00:13:04.970 --> 00:13:07.630

actual letter at that point in the list.



156

00:13:07.880 --> 00:13:13.980

And then we added in some random sample of the alphabet and since random sample returns back a list



157

00:13:14.060 --> 00:13:17.420

we need it's index that letter out using zero here.



158

00:13:17.420 --> 00:13:19.120

So we got something like this back.



159

00:13:19.160 --> 00:13:22.890

So we wanted to use this indexing to actually grab the output.



160

00:13:22.960 --> 00:13:28.100

Now remember if you're having trouble keeping track you can always do a python debugger set trace anywhere



161

00:13:28.100 --> 00:13:32.240

in this code so you can play around the variables or you can just use print's that is.



162

00:13:32.430 --> 00:13:36.730

And we have step two which was reverse a string that was pretty straightforward just to use slice notation



163

00:13:36.730 --> 00:13:37.690

for that.



164

00:13:38.050 --> 00:13:42.430

And then finally I wanted to use the random shuffled alphabet to create a Caesar cipher.



165

00:13:42.430 --> 00:13:47.880

So we created this little holding variable called encrypted phase to where we could add a list range



166

00:13:47.890 --> 00:13:49.910

length of the encrypted phrase.



167

00:13:49.960 --> 00:13:56.140

So essentially just a list of a bunch of numbers from 0 up to the index position of the that phrase



168

00:13:56.140 --> 00:13:57.200

at the very end.



169

00:13:57.340 --> 00:14:01.050

And then we iterated through this list using enumerate.



170

00:14:01.090 --> 00:14:07.920

So for every index and letter in the encrypted phrase that lowercase if we actually had an alphabetic



171

00:14:07.930 --> 00:14:13.360

letter we did the switch here using the index position of the true alphabet and finding it in its random



172

00:14:13.360 --> 00:14:13.990

alphabet.



173

00:14:13.990 --> 00:14:20.530

The Caesar cipher and then Otherwise we had punctuation or other spaces and we just kept that the same



174

00:14:20.530 --> 00:14:21.320

thing.



175

00:14:21.370 --> 00:14:26.060

Then we joined it all back together so we could return back the encrypted phrase.



176

00:14:26.320 --> 00:14:30.850

Then we have the decryption and it works the same way except everything's in reverse order.



177

00:14:30.880 --> 00:14:32.170

We set our seed.



178

00:14:32.170 --> 00:14:37.170

We make sure we have the same random alphabet that was used during the encryption process.



179

00:14:37.240 --> 00:14:42.580

We created the cryptic message we reverse the Caesar cypher by grabbing the next addition of the random



180

00:14:42.580 --> 00:14:48.490

alphabet then replacing it with the true alphabet again checking for punctuation or spaces and then



181

00:14:48.490 --> 00:14:50.840

we join this up by reversing it.



182

00:14:51.010 --> 00:14:56.500

And we also grab every other letter and that's it for the encryption and decryption.



183

00:14:56.500 --> 00:14:59.500

That was definitely the toughest assignment you've had so far.



184

00:14:59.620 --> 00:15:03.880

But if you were able to successfully accomplish this you're definitely ready for the field.



185

00:15:03.910 --> 00:15:04.580

We'll see you soon.



