WEBVTT
1

00:00:00.510 --> 00:00:01.290

Welcome back.



2

00:00:01.350 --> 00:00:05.940

It's time to now check your performance on the function tasks by going over the solution.



3

00:00:05.940 --> 00:00:08.470

Let's go to the Jupiter notebook and see how you did.



4

00:00:12.460 --> 00:00:12.750

All right.



5

00:00:12.760 --> 00:00:15.330

Let's begin by taking a look at the first task.



6

00:00:15.330 --> 00:00:19.660

It was creative function takes in two integers and returns a boolean if there is some is 10.



7

00:00:19.840 --> 00:00:23.900

So true if there's some 10 and faucets or some or something else.



8

00:00:23.960 --> 00:00:26.770

Now as you're beginning to code you may have to do this.



9

00:00:26.850 --> 00:00:41.410

Could have said if and one plus and two is equal to 10 return TRUE else return false.



10

00:00:41.480 --> 00:00:43.480

That's a perfectly ok way to do this.



11

00:00:43.490 --> 00:00:45.950

You notice you get the same results if you run the code.



12

00:00:45.950 --> 00:00:51.620

However remember that if you're just checking an if statement and you're only going to return the same



13

00:00:51.620 --> 00:00:52.790

boolean value.



14

00:00:52.790 --> 00:00:56.310

All you really need to do is just return this boolean value itself.



15

00:00:56.480 --> 00:01:02.930

So you could just write return the results of this comparison operation.



16

00:01:03.150 --> 00:01:07.580

And that's the exact same thing to notice you get the same result there.



17

00:01:07.590 --> 00:01:12.950

So all we're doing here is checking into some is equal to 10 task number two was create a function that



18

00:01:12.950 --> 00:01:16.180

takes in 200 integers returns true to some extent.



19

00:01:16.220 --> 00:01:18.950

Otherwise returns the actual some value.



20

00:01:18.950 --> 00:01:21.220

Let's go ahead and see how we could do this now.



21

00:01:21.380 --> 00:01:35.420

In this case we will need the if statement will say if and 1 plus and 2 is equal to 10 return TRUE else



22

00:01:35.510 --> 00:01:39.440

we're going to return the actual sum and one plus and two.



23

00:01:39.710 --> 00:01:42.790

And then when we run this we'll get back the same results.



24

00:01:44.080 --> 00:01:48.520

Task 3 was create a function it takes in a string and returns back the first character of that string



25

00:01:48.850 --> 00:01:50.110

in uppercase.



26

00:01:50.170 --> 00:01:52.190

You can actually do this off one line.



27

00:01:52.190 --> 00:01:58.900

We're going to do is index the first character off that string with brackets and 0 and then we're just



28

00:01:58.900 --> 00:02:02.830

going to say upper to get it in upper case.



29

00:02:02.890 --> 00:02:06.330

And then we will just return this result and that's all you had to do.



30

00:02:06.370 --> 00:02:13.010

You could add multiple lines as well but it's actually quite simple if one line task for was to create



31

00:02:13.010 --> 00:02:15.890

a function that takes in a string returns the last two characters.



32

00:02:15.890 --> 00:02:19.290

If there are less than two characters return the string error.



33

00:02:19.310 --> 00:02:21.790

So let's see how we would do this.



34

00:02:21.890 --> 00:02:33.170

We'll use control flow to say if the length of my string is less than 2 that I will return the error



35

00:02:33.200 --> 00:02:34.560

code.



36

00:02:34.750 --> 00:02:43.670

Otherwise I'm going to return my string and there was a link here for hinting.



37

00:02:43.690 --> 00:02:46.600

But we're going to use negative indexing for a slice.



38

00:02:46.600 --> 00:02:51.610

So we will go back to space's from the end and then go all the way to the end.



39

00:02:51.670 --> 00:02:55.270

And if you want more explanation about this you can click on the link for the hints.



40

00:02:55.510 --> 00:03:01.090

But essentially all we're doing here is we're going from the very end of the string back to spaces and



41

00:03:01.090 --> 00:03:03.520

then going all the way back to the end again.



42

00:03:03.550 --> 00:03:04.930

So it's a little confusing at first.



43

00:03:04.930 --> 00:03:09.970

On how to use slicing with negative indices as your starting point you can just think of it as negative



44

00:03:09.970 --> 00:03:15.550

2 from the very end then go all the way to the end and we need a check to see if our length of my string



45

00:03:15.550 --> 00:03:16.520

is less than 2.



46

00:03:16.690 --> 00:03:23.900

Otherwise you'll get some weird results trying to get this one to run first task 5 was given a list



47

00:03:23.900 --> 00:03:27.560

of integers return true of the sequence 1 2 3 is somewhere in the list.



48

00:03:27.590 --> 00:03:28.860

So this one's a little trickier.



49

00:03:28.880 --> 00:03:31.490

So let's go ahead and check out how we can do this.



50

00:03:31.640 --> 00:03:32.390

We'll do the following.



51

00:03:32.390 --> 00:03:41.400

We'll say for I in range and the range we're going to do is the length of the list of numbers.



52

00:03:43.020 --> 00:03:44.420

Minus 2.



53

00:03:44.490 --> 00:03:49.890

And the reason we're going to iterate with length minus two is so that we can use I plus 1 in I plus



54

00:03:49.890 --> 00:03:50.250

2.



55

00:03:50.280 --> 00:03:51.290

Later in the loop.



56

00:03:51.540 --> 00:03:53.290

So we'll see what we mean by that.



57

00:03:53.340 --> 00:04:00.130

We're going to say if Number of is equal to 1.



58

00:04:00.380 --> 00:04:03.340

And so we're using logical operators here.



59

00:04:03.510 --> 00:04:09.370

Numbers of I plus 1 is equal to two hands.



60

00:04:10.380 --> 00:04:15.390

Numbs of I plus two is equal to three.



61

00:04:15.520 --> 00:04:22.000

Then we're going to return TRUE else if we've gone through that entire four loop and we haven't returned



62

00:04:22.000 --> 00:04:22.570

anything.



63

00:04:22.570 --> 00:04:28.910

We'll just return false so let's go over the logic here because it's a little bit tricky at first.



64

00:04:29.080 --> 00:04:33.880

So we will say for I in range length of thumbs minus 2.



65

00:04:33.880 --> 00:04:36.810

So this is a way to iterate through the length of the list.



66

00:04:36.850 --> 00:04:43.510

However if we did just the length of the list without this minus two we would end up getting errors



67

00:04:43.510 --> 00:04:50.370

here and I plus 1 and I plus 2 because we would get to the end of the list and keep asking for more.



68

00:04:50.500 --> 00:04:55.440

I would eventually be the end of the list and you would say plus 1 or plus 2 to avoid any errors.



69

00:04:55.450 --> 00:04:58.130

We will say length of Nom's minus 2.



70

00:04:58.150 --> 00:05:05.440

So that way when we do the very last check this I plus 2 and I plus 1 aren't outside of the list and



71

00:05:05.440 --> 00:05:12.000

the notice here how I'm saying for this range check if the sequence happens to be true somewhere.



72

00:05:12.100 --> 00:05:17.620

If it is return true if I've done this entire for a loop and it hasn't returned true then a line is



73

00:05:17.620 --> 00:05:18.270

this for a loop.



74

00:05:18.310 --> 00:05:20.160

I'll just return false.



75

00:05:20.560 --> 00:05:24.190

Really Make sure you check your indentation here.



76

00:05:24.190 --> 00:05:24.850

All right so we get.



77

00:05:24.850 --> 00:05:27.250

True true and false there.



78

00:05:27.290 --> 00:05:29.070

So we get the right results.



79

00:05:29.110 --> 00:05:33.940

Task number six is given two streets create a function that returns a difference in length between them



80

00:05:34.450 --> 00:05:40.180

and hence was absolute value which means hopefully you're able to google how to get an absolute value



81

00:05:40.180 --> 00:05:45.550

with Python and you're able to figure out that it was abs for absolute value.



82

00:05:45.550 --> 00:05:49.740

So all we're doing is we're taking the length of string one.



83

00:05:50.050 --> 00:05:51.360

Make sure you spell that right.



84

00:05:51.490 --> 00:05:55.630

The length of string 1 minus the length of string to



85

00:05:58.510 --> 00:06:00.200

and we're returning this.



86

00:06:00.850 --> 00:06:06.040

But if we were only to do this then we would get some wrong results so we would get negative 1 here



87

00:06:06.250 --> 00:06:09.170

in order to get just the absolute difference.



88

00:06:09.190 --> 00:06:13.110

We passed this result into abs for absolute value.



89

00:06:14.210 --> 00:06:18.050

Run that and then you'll end up getting the correct results.



90

00:06:18.050 --> 00:06:23.970

Now on to task 7 for this next task we were given a list of integers and if the length of the list is



91

00:06:23.970 --> 00:06:29.540

an even number return the sum of the list is the length of the list is odd returned the max value in



92

00:06:29.540 --> 00:06:30.200

that list.



93

00:06:30.200 --> 00:06:36.050

So first off let's create a little quick variable here called length and we'll just set that to the



94

00:06:36.050 --> 00:06:39.740

length of my list and then we'll do the following.



95

00:06:39.770 --> 00:06:49.640

We'll say if the length mod to is equal to zero then we have an even value and rule will turn the sum



96

00:06:50.270 --> 00:06:53.450

of my list else.



97

00:06:53.500 --> 00:07:00.850

We will go ahead and return the max value of my list so we can run that and then we'll see the results



98

00:07:00.850 --> 00:07:03.680

here 3 and 6.



99

00:07:03.720 --> 00:07:07.890

Your final task was to perform this replace and switch function.



100

00:07:07.890 --> 00:07:09.900

Now there's lots of different ways you could have done this.



101

00:07:09.900 --> 00:07:16.260

Let's go over one example solution to start off our example solution we're going to do the same thing



102

00:07:16.260 --> 00:07:16.950

we did last time.



103

00:07:16.950 --> 00:07:20.260

We'll start off with output being some sort of a list here.



104

00:07:20.400 --> 00:07:24.800

And then at the very end we were going to return that output.



105

00:07:24.870 --> 00:07:31.590

And likely since it's going to be a list and we want to return a string we're going to say join the



106

00:07:31.590 --> 00:07:32.160

output.



107

00:07:32.160 --> 00:07:37.980

So this follows along with the logic from some of the previous lessons where we did a very similar example.



108

00:07:38.040 --> 00:07:42.360

However in this case we don't know how long the name is going to be.



109

00:07:42.390 --> 00:07:49.380

So what we will do here is say List Range length of name.



110

00:07:49.450 --> 00:07:50.890

So what does it actually do.



111

00:07:51.160 --> 00:07:57.130

Well since we don't know how long the name may be as far as how many characters it has if we say length



112

00:07:57.220 --> 00:08:04.480

of something like John will return three if we say something of length sandy will return five.



113

00:08:04.570 --> 00:08:12.580

If we pass this into range then we get back and a range operator which defaults to 0 and then goes up



114

00:08:12.580 --> 00:08:14.440

to the length.



115

00:08:14.560 --> 00:08:21.310

And if we pass that into list now I have a list that has as many indexed positions as there are letters



116

00:08:21.490 --> 00:08:22.270

in this name.



117

00:08:22.270 --> 00:08:27.400

So that's why we're doing this list range length of the name in order to get a list that has as many



118

00:08:27.400 --> 00:08:30.930

inputs as the actual name itself.



119

00:08:30.940 --> 00:08:39.030

The other way you could have done this is to just say list of Sandy and then you would have had the



120

00:08:39.030 --> 00:08:39.720

same result.



121

00:08:39.720 --> 00:08:44.970

So either way is totally fine if it makes more sense to use it numerical so you can kind of go along



122

00:08:45.290 --> 00:08:46.770

that this was the way to do it.



123

00:08:46.800 --> 00:08:52.590

If it makes more sense just to cast or transform the string into a list using just a simple list call



124

00:08:52.650 --> 00:08:54.000

you could do it that way as well.



125

00:08:54.090 --> 00:08:56.920

As I mentioned there's going to be multiple ways to do this problem.



126

00:08:57.060 --> 00:09:03.300

So let's go ahead and just say output is list name and then we will say for I letter a little bit of



127

00:09:03.300 --> 00:09:14.100

tuple and packing here in enumerates our name will say if the lower case version of the letter is in



128

00:09:14.100 --> 00:09:15.460

a list the vowels recreate.



129

00:09:15.470 --> 00:09:24.880

So I'll say a e i o u and we'll go ahead and ignore sometimes people consider Y a vowel and some cases.



130

00:09:24.930 --> 00:09:38.510

Just stick with these five we'll say output of I and we'll reassign it to be X Bell's output of I isn't



131

00:09:38.510 --> 00:09:39.560

going to change.



132

00:09:39.830 --> 00:09:45.690

So we'll just have it be the letter in the name.



133

00:09:45.980 --> 00:09:48.250

And now we need to switch the first and last letter.



134

00:09:48.260 --> 00:09:55.160

So we'll take a variable called last and set that to be the very last item in the output.



135

00:09:55.160 --> 00:09:58.910

So another variable called first and that will be the very first item.



136

00:09:59.920 --> 00:10:00.800

In the output.



137

00:10:00.900 --> 00:10:08.610

And then finally we'll do the re-assignment will see output of 0 as equal to last an output of negative



138

00:10:08.610 --> 00:10:11.330

1 is equal to first.



139

00:10:11.370 --> 00:10:13.860

And then finally we'll join together the output.



140

00:10:13.860 --> 00:10:17.820

So let's say you could solve this problem you create a list iterate through the name.



141

00:10:17.880 --> 00:10:20.200

Do your reassignments concerning the vowels.



142

00:10:20.220 --> 00:10:21.980

If not it stays the same.



143

00:10:22.170 --> 00:10:25.320

And if you do it this way you don't need to actually do this sort of re-assignment.



144

00:10:25.320 --> 00:10:27.070

However she did it this way you do.



145

00:10:27.180 --> 00:10:32.040

You do need to do that re-assignment if you only have numbers there if you have the actual letters from



146

00:10:32.040 --> 00:10:35.050

the beginning you don't technically need to do anything there.



147

00:10:35.100 --> 00:10:37.510

So let's run this cell and see your results.



148

00:10:37.530 --> 00:10:44.010

So we'll say replace switch which James we get the same results Sindhi same result Alford same results.



149

00:10:44.280 --> 00:10:44.790

OK.



150

00:10:44.940 --> 00:10:49.650

So hopefully now you've learned how you can combine functions with other topics such as for loops while



151

00:10:49.650 --> 00:10:55.300

loops and control flow in order to get functions that have the capability to solve what seems to be



152

00:10:55.300 --> 00:10:57.460

a real generalized problems.



153

00:10:57.480 --> 00:10:58.770

Great work so far.



154

00:10:58.770 --> 00:11:03.930

Keep in mind this is a big jump in difficulty and it's just the nature of learning something as powerful



155

00:11:03.930 --> 00:11:05.010

as functions.



156

00:11:05.010 --> 00:11:10.680

So if you are still having trouble with this you can check out some of the resources for extra help.



157

00:11:10.710 --> 00:11:11.740

We'll see you at the next lesson.



