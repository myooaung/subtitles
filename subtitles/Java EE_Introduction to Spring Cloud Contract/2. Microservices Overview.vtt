WEBVTT
1
00:00:02.100 --> 00:00:05.140
[Autogenerated] So what is a micro services architecture?

2
00:00:05.140 --> 00:00:07.920
To answer that question, let's take an example.

3
00:00:07.920 --> 00:00:12.740
Application on Architect is such first of all will say

4
00:00:12.740 --> 00:00:16.210
we're dealing with a digital retail bank so we can use a

5
00:00:16.210 --> 00:00:18.890
real life scenario in our example.

6
00:00:18.890 --> 00:00:19.750
In fact,

7
00:00:19.750 --> 00:00:24.190
this is the example will be working with throughout the rest of the course.

8
00:00:24.190 --> 00:00:26.960
Now, in order to build micro services,

9
00:00:26.960 --> 00:00:29.720
we would first like a different business functionalities.

10
00:00:29.720 --> 00:00:33.630
That our banks get half in this case is quite a lot of them,

11
00:00:33.630 --> 00:00:35.830
meaning that our application is going to be quite

12
00:00:35.830 --> 00:00:39.040
complex having to do many things.

13
00:00:39.040 --> 00:00:42.000
It's these business functionalities that can then be

14
00:00:42.000 --> 00:00:44.590
used to define our micro services.

15
00:00:44.590 --> 00:00:48.470
Each business functionality maps to a single micro service,

16
00:00:48.470 --> 00:00:52.840
which is an autonomous application with that single responsibility.

17
00:00:52.840 --> 00:00:57.250
On top of this, each micro service will have its own database.

18
00:00:57.250 --> 00:00:59.060
This housekeeping de couples,

19
00:00:59.060 --> 00:01:02.240
as a micro service only ever owns its own data and

20
00:01:02.240 --> 00:01:05.280
no other the spiders decoupling.

21
00:01:05.280 --> 00:01:08.390
The reality is that they're typically needs to be some sort of

22
00:01:08.390 --> 00:01:11.960
inter service communication between micro services.

23
00:01:11.960 --> 00:01:13.160
For example, Ah,

24
00:01:13.160 --> 00:01:16.380
payment service might need to call the account service to check

25
00:01:16.380 --> 00:01:19.640
whether a person has enough money to make a payment.

26
00:01:19.640 --> 00:01:24.200
Ah, lot of the time this communication tends to be done synchronously via,

27
00:01:24.200 --> 00:01:30.220
say, a hate T T p a p i or a synchronously fire a message broker.

28
00:01:30.220 --> 00:01:34.560
It's this message passing between micro services that's a main driver for

29
00:01:34.560 --> 00:01:38.040
spring cloud contract or consumer driven contract testing,

30
00:01:38.040 --> 00:01:41.040
which will discover later on in this module.

31
00:01:41.040 --> 00:01:44.720
ASUs module mainly focuses on the challenges of Marcus Services.

32
00:01:44.720 --> 00:01:48.940
Testing will first mentions of micro service benefits.

33
00:01:48.940 --> 00:01:51.630
This is so we get a more balanced view of the trade offs

34
00:01:51.630 --> 00:01:54.380
between micro services on more traditional,

35
00:01:54.380 --> 00:01:57.140
monolithic applications.

36
00:01:57.140 --> 00:01:59.910
So the first benefit of micro services is high.

37
00:01:59.910 --> 00:02:01.550
Maintain ability.

38
00:02:01.550 --> 00:02:02.120
Imagine if,

39
00:02:02.120 --> 00:02:06.640
for the functionality of our application lived together in a single code base,

40
00:02:06.640 --> 00:02:08.390
this would have bean maintain ability.

41
00:02:08.390 --> 00:02:11.650
____, with lots of teams working on the same field at once,

42
00:02:11.650 --> 00:02:14.700
often producing code conflicts are modeling things to

43
00:02:14.700 --> 00:02:17.440
gather that should be completely decoupled.

44
00:02:17.440 --> 00:02:19.450
Micro services, on the other hand,

45
00:02:19.450 --> 00:02:23.020
are separate projects with fully independent co bases,

46
00:02:23.020 --> 00:02:24.370
which tend to be smaller,

47
00:02:24.370 --> 00:02:28.490
easier to reason about on the fully independent of each other.

48
00:02:28.490 --> 00:02:34.140
They also promote agility with a monolithic approach every time it changes made,

49
00:02:34.140 --> 00:02:36.800
the whole application must be tested on the whole

50
00:02:36.800 --> 00:02:39.640
application must be released at once.

51
00:02:39.640 --> 00:02:42.380
This all or nothing approach doesn't exist of micro

52
00:02:42.380 --> 00:02:44.660
services because of micro service.

53
00:02:44.660 --> 00:02:49.840
Can be independently testable in releasable in isolation of its counterparts.

54
00:02:49.840 --> 00:02:53.250
Releases can become more frequent and also less risky as

55
00:02:53.250 --> 00:02:56.140
they don't affect the system as a whole.

56
00:02:56.140 --> 00:02:59.240
Micro services can also be polyglot.

57
00:02:59.240 --> 00:03:00.310
For example,

58
00:03:00.310 --> 00:03:04.790
whilst a model if will only use one language and one database technology,

59
00:03:04.790 --> 00:03:08.940
each micro service can choose whatever is best for its requirements.

60
00:03:08.940 --> 00:03:11.620
Maybe some will be backed by a graph database.

61
00:03:11.620 --> 00:03:15.780
Last overs by Relational on Maybe some will be implemented and go

62
00:03:15.780 --> 00:03:19.710
whilst of is in Java the reality years that having this kind of

63
00:03:19.710 --> 00:03:23.960
flexibility is beneficial and gives far more freedom for developers

64
00:03:23.960 --> 00:03:28.090
to choose different technologies whilst keeping his choices isolated

65
00:03:28.090 --> 00:03:30.440
and easy to change.

66
00:03:30.440 --> 00:03:34.340
Failure Isolation is also major benefit with a model

67
00:03:34.340 --> 00:03:36.740
if the system will fail as a whole.

68
00:03:36.740 --> 00:03:39.560
If it crashes, everything crashes on.

69
00:03:39.560 --> 00:03:42.790
Rolling back or hot fix in a book means the deployment of

70
00:03:42.790 --> 00:03:46.130
the whole system with micro services.

71
00:03:46.130 --> 00:03:50.810
This risk is lowered as books are isolated to individual micro services

72
00:03:50.810 --> 00:03:54.340
that can be deployed independently of everything else.

73
00:03:54.340 --> 00:03:59.330
Also, if something critical happens, like a micro service or database _____,

74
00:03:59.330 --> 00:04:03.040
that much of the remaining system can continue to function.

75
00:04:03.040 --> 00:04:06.710
It can also be designed to do this in a fault tolerant way.

76
00:04:06.710 --> 00:04:11.650
That means a user experience is not negatively impacted on.

77
00:04:11.650 --> 00:04:16.040
Finally, micro services are also independently scalable.

78
00:04:16.040 --> 00:04:19.150
This means if a feature has a high resource requirement,

79
00:04:19.150 --> 00:04:22.940
only means scaling the mobile service that owns that feature.

80
00:04:22.940 --> 00:04:31.000
Everything else can remain untouched, as opposed to a model if which isn't all or nothing type of scale.

