WEBVTT
1
00:00:02.040 --> 00:00:04.300
[Autogenerated] in the final demo for this module.

2
00:00:04.300 --> 00:00:08.410
We're going to implement the provider side of our contract.

3
00:00:08.410 --> 00:00:12.230
First, we're going to switch back to to provide a project.

4
00:00:12.230 --> 00:00:14.820
Then we're going to generate our contract verification

5
00:00:14.820 --> 00:00:17.210
tests using the spring cloud contract.

6
00:00:17.210 --> 00:00:19.360
Verify a plug him.

7
00:00:19.360 --> 00:00:21.210
We're then going to create a base class,

8
00:00:21.210 --> 00:00:25.410
which is test will depend on in order to be able to execute.

9
00:00:25.410 --> 00:00:29.640
And we'll fix a fading tests by creating a spring controller.

10
00:00:29.640 --> 00:00:34.020
This will finish to consumer driven contract testing technique using spring

11
00:00:34.020 --> 00:00:40.240
cloud contracts in both the consumer and the provider.

12
00:00:40.240 --> 00:00:42.280
Back in our provider project,

13
00:00:42.280 --> 00:00:46.380
we can carry on where we left off running a May been install.

14
00:00:46.380 --> 00:00:50.440
But this time, without skipping the tests,

15
00:00:50.440 --> 00:00:54.650
we can see that we have a failure this time with a test called

16
00:00:54.650 --> 00:00:59.170
Validate Should Run a credit score of heights or citizen.

17
00:00:59.170 --> 00:01:03.740
This is the name of our contract prefixed with the word Falla date.

18
00:01:03.740 --> 00:01:05.480
As the name implies,

19
00:01:05.480 --> 00:01:08.650
this is a test that has been generated by spring cloud

20
00:01:08.650 --> 00:01:13.000
contract verifier in order to make sure our provider meets

21
00:01:13.000 --> 00:01:16.640
expectations off the contract.

22
00:01:16.640 --> 00:01:22.430
What we need to do now is make that test pass First of all,

23
00:01:22.430 --> 00:01:28.640
let's navigates a target directory who find a source code for our failing test

24
00:01:28.640 --> 00:01:33.940
sprinklered contracts puts all these generated tests in the contracts directory

25
00:01:33.940 --> 00:01:38.960
on the generated test sources from opening it up.

26
00:01:38.960 --> 00:01:44.240
We can immediately see day more or less mirrors our contracts.

27
00:01:44.240 --> 00:01:47.160
We have a request to the credit scores M point,

28
00:01:47.160 --> 00:01:50.690
as we have to clad on a response assertion,

29
00:01:50.690 --> 00:01:54.920
asserting the response that we declared the test is

30
00:01:54.920 --> 00:01:59.440
a rest assured Mark NBC test, which is the default.

31
00:01:59.440 --> 00:02:00.300
Rest assured,

32
00:02:00.300 --> 00:02:05.340
Mark NBC runs against the mock Web environment and provides an expressive

33
00:02:05.340 --> 00:02:10.140
DSL for building requests and asserting our responses.

34
00:02:10.140 --> 00:02:14.500
Here we can see how simple and fluent is to build a request.

35
00:02:14.500 --> 00:02:18.690
Chaining together had embody calls.

36
00:02:18.690 --> 00:02:23.040
The test generation coz also does some more heavy list thing.

37
00:02:23.040 --> 00:02:27.490
For example, it's figured out that because we're returning Jason,

38
00:02:27.490 --> 00:02:30.120
that it should assert the value of a Jason Field

39
00:02:30.120 --> 00:02:31.760
instead of performing of planes.

40
00:02:31.760 --> 00:02:34.540
Hats comparison.

41
00:02:34.540 --> 00:02:38.710
Okay, so the test is pretty much room for us Shorter.

42
00:02:38.710 --> 00:02:42.580
Some scaffolding code to set up mark every C.

43
00:02:42.580 --> 00:02:43.650
The question is,

44
00:02:43.650 --> 00:02:47.990
why do we put this scaffolding coz we can't write it directly

45
00:02:47.990 --> 00:02:51.530
in the test as it's generated for us and would end up being

46
00:02:51.530 --> 00:02:55.380
overridden on a subsequent build.

47
00:02:55.380 --> 00:02:58.960
The solution to this problem is to create a base class.

48
00:02:58.960 --> 00:03:00.210
So all are generated.

49
00:03:00.210 --> 00:03:05.140
Contract tests will inherit from Let's create Well,

50
00:03:05.140 --> 00:03:11.040
we'll call it based contract test on bitter alongside our test classes.

51
00:03:11.040 --> 00:03:14.680
Let's leave it empty for now on first try and make it so I

52
00:03:14.680 --> 00:03:19.440
generated contract verification tests inherit from it.

53
00:03:19.440 --> 00:03:25.640
To do this, we can switch to our maven palm and then add to configuration tyke.

54
00:03:25.640 --> 00:03:26.600
Within this,

55
00:03:26.600 --> 00:03:30.930
we need to provide a base class for test tyke and then provide it

56
00:03:30.930 --> 00:03:35.540
with the full class path to our base contract test.

57
00:03:35.540 --> 00:03:41.900
Now we can run install again and then we can take a

58
00:03:41.900 --> 00:03:46.090
look are generated test again.

59
00:03:46.090 --> 00:03:51.090
This time we can see there now inherits from our base class.

60
00:03:51.090 --> 00:03:52.690
So now this is all set up.

61
00:03:52.690 --> 00:03:55.770
We can switch back to our base class and start editing

62
00:03:55.770 --> 00:03:58.990
it in order to make our test pass.

63
00:03:58.990 --> 00:04:01.790
First of all will create a before method.

64
00:04:01.790 --> 00:04:05.040
They get run at the start of all our tests,

65
00:04:05.040 --> 00:04:08.110
Then we can call Mark M v C standalone,

66
00:04:08.110 --> 00:04:11.920
set up and this method can take a single controller,

67
00:04:11.920 --> 00:04:14.990
is an argument and then sets up a mock weapon.

68
00:04:14.990 --> 00:04:15.650
Vier Mint.

69
00:04:15.650 --> 00:04:18.020
Based on that controller,

70
00:04:18.020 --> 00:04:23.140
all the tests in our base class would then fire against that controller,

71
00:04:23.140 --> 00:04:27.850
as our comptroller does not yet exist, will call it credit check controller,

72
00:04:27.850 --> 00:04:32.120
and then we'll use alternate enter to generate it.

73
00:04:32.120 --> 00:04:36.220
We can then add the rest control annotation in order for it to

74
00:04:36.220 --> 00:04:40.640
be able to start receiving hate TTP requests.

75
00:04:40.640 --> 00:04:43.680
And then we can add a post mapping for our credit scores on

76
00:04:43.680 --> 00:04:46.140
point and give it a method to be called.

77
00:04:46.140 --> 00:04:49.540
When that request states place,

78
00:04:49.540 --> 00:04:53.240
the method will receive two classes which don't exist at,

79
00:04:53.240 --> 00:04:58.090
so we'll just write them out for now and then generate from later.

80
00:04:58.090 --> 00:05:00.840
It will also have a service field.

81
00:05:00.840 --> 00:05:03.600
The service will be what performs any logic,

82
00:05:03.600 --> 00:05:06.830
leaving the controller of Finn resource layer that

83
00:05:06.830 --> 00:05:10.640
purely responsible for Hayes TTP.

84
00:05:10.640 --> 00:05:13.590
We can now all turn enter to create our credit share

85
00:05:13.590 --> 00:05:20.070
class at a field citizen number on, then generate getters and setters,

86
00:05:20.070 --> 00:05:24.000
and then we can go back and generate our credit shirt response class,

87
00:05:24.000 --> 00:05:31.140
creating a score field on again, generating any necessary getters and setters,

88
00:05:31.140 --> 00:05:34.540
we can now implement our controller method.

89
00:05:34.540 --> 00:05:38.210
What we'll do is just allocate a logic to the service,

90
00:05:38.210 --> 00:05:43.440
making it take a citizen number and return a credit shot response.

91
00:05:43.440 --> 00:05:47.620
The implementation off it can do nothing for now on just return.

92
00:05:47.620 --> 00:05:48.070
No.

93
00:05:48.070 --> 00:05:50.940
So everything compiles.

94
00:05:50.940 --> 00:05:55.010
Now we can go back to our test and fix a compilation era with Far

95
00:05:55.010 --> 00:06:00.700
Controller by now passing in the service robin in passing in a

96
00:06:00.700 --> 00:06:03.850
real service so we can pass in a mark.

97
00:06:03.850 --> 00:06:06.680
Instance, using mosquito.

98
00:06:06.680 --> 00:06:11.680
This means we don't actually have to implement it on can focus instead on

99
00:06:11.680 --> 00:06:16.840
telling it to do specifically what we need for our test to pass.

100
00:06:16.840 --> 00:06:17.840
In this case,

101
00:06:17.840 --> 00:06:21.300
that will be getting it to return a credit score of high when a

102
00:06:21.300 --> 00:06:26.640
citizen number off 1234 is passed into it,

103
00:06:26.640 --> 00:06:28.640
and now we get to G O.

104
00:06:28.640 --> 00:06:31.840
Let's re without test and see what happens.

105
00:06:31.840 --> 00:06:35.660
Remember, even though our test is generated for us,

106
00:06:35.660 --> 00:06:38.870
there's nothing stopping us from running it directly from the I D.

107
00:06:38.870 --> 00:06:39.050
A.

108
00:06:39.050 --> 00:06:42.240
If we want to.

109
00:06:42.240 --> 00:06:43.300
Unfortunately,

110
00:06:43.300 --> 00:06:49.950
we still have a test failure last lickety output and see why it looks

111
00:06:49.950 --> 00:06:53.540
like no is somehow being returned from our controller.

112
00:06:53.540 --> 00:06:57.250
But the question is why navigating bats?

113
00:06:57.250 --> 00:06:58.640
The implementation?

114
00:06:58.640 --> 00:07:01.140
It's actually pretty Orpheus.

115
00:07:01.140 --> 00:07:05.240
Yeah, again, we forgot to add the request body annotation,

116
00:07:05.240 --> 00:07:08.030
meaning that the method argument is not created

117
00:07:08.030 --> 00:07:10.740
from the request body in our test.

118
00:07:10.740 --> 00:07:18.440
Let's at the missing annotation and then run the tests again.

119
00:07:18.440 --> 00:07:19.260
Great.

120
00:07:19.260 --> 00:07:22.820
This time it's past meaning now are provider is

121
00:07:22.820 --> 00:07:26.540
complained with the contract that we defined.

122
00:07:26.540 --> 00:07:32.900
Now we can run the full install task and see what the results of that are.

123
00:07:32.900 --> 00:07:34.920
We still have a single failure.

124
00:07:34.920 --> 00:07:38.140
Only this time it's not really an issue.

125
00:07:38.140 --> 00:07:42.370
The failing test is a default spring beauty test that was generated for

126
00:07:42.370 --> 00:07:46.910
us when we created our protests is trying to create our controller and

127
00:07:46.910 --> 00:07:50.440
con as there's no credit check service being,

128
00:07:50.440 --> 00:07:53.770
if we add at component annotation to it that it would be

129
00:07:53.770 --> 00:07:58.340
wired into the controller on that Tash, you no longer fail.

130
00:07:58.340 --> 00:08:02.580
Let's run again and say Fantastic.

131
00:08:02.580 --> 00:08:05.540
Now the whole build is passing.

132
00:08:05.540 --> 00:08:08.810
It's important to note that we've deliberately not sliced

133
00:08:08.810 --> 00:08:11.490
through the whole stack in our contract test on have

134
00:08:11.490 --> 00:08:14.090
instead Mach two service layer.

135
00:08:14.090 --> 00:08:16.820
That's because the contract test don't care about the

136
00:08:16.820 --> 00:08:19.380
internal behaviour of the provider,

137
00:08:19.380 --> 00:08:23.060
as that's what the provide is functional tested for the

138
00:08:23.060 --> 00:08:32.000
contractors only care about verifying into service communication will function as expected.

