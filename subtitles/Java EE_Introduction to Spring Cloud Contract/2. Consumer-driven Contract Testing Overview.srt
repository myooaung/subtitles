1
00:00:02,070 --> 00:00:06,240
[Autogenerated] So what is consumer driven contract testing?

2
00:00:06,240 --> 00:00:09,970
Consumer driven contract testing is a technique which fills

3
00:00:09,970 --> 00:00:13,340
the testing gap in micro services testing.

4
00:00:13,340 --> 00:00:16,980
It removes the risk of false positives caused by stops on

5
00:00:16,980 --> 00:00:22,940
provides dramatically faster feedback, then slow and brittle and two in tests.

6
00:00:22,940 --> 00:00:27,610
It's a technique where consumers under providers are continuously tested

7
00:00:27,610 --> 00:00:33,340
against contracts which are agreed interactions between them.

8
00:00:33,340 --> 00:00:37,480
It's also a test driven approach where the AP Ivor provider

9
00:00:37,480 --> 00:00:40,340
is driven by the tests of the consumer.

10
00:00:40,340 --> 00:00:44,740
Essentially, it takes T d D to the architecture level.

11
00:00:44,740 --> 00:00:50,220
It also helps make micro services independently testable on us independently,

12
00:00:50,220 --> 00:00:52,600
releasable contractors,

13
00:00:52,600 --> 00:00:57,210
ruinous part of a micro services local build and give reliable and a feed about

14
00:00:57,210 --> 00:01:01,750
to verify that they will function with their collaborators.

15
00:01:01,750 --> 00:01:06,350
And finally, it's of course, a pattern that's bring cloud contract implements,

16
00:01:06,350 --> 00:01:09,030
which is why it's important to build this understanding

17
00:01:09,030 --> 00:01:11,460
off it before moving on to a demo.

18
00:01:11,460 --> 00:01:12,450
To begin with,

19
00:01:12,450 --> 00:01:16,040
we're going to start with a higher level architecture diagram of

20
00:01:16,040 --> 00:01:19,570
how consumer driven contract testing might work.

21
00:01:19,570 --> 00:01:23,610
As we know when we work in a consumer, there's also provided it.

22
00:01:23,610 --> 00:01:27,820
It depends on we want to be able to ensure that both this consumer

23
00:01:27,820 --> 00:01:31,540
in the provider will function together correctly.

24
00:01:31,540 --> 00:01:34,540
When we implement consumer giving contract s stain,

25
00:01:34,540 --> 00:01:37,750
we can do this by introducing a contract.

26
00:01:37,750 --> 00:01:41,120
This is something which declares an agreed interaction

27
00:01:41,120 --> 00:01:44,540
between our consumer andare provider.

28
00:01:44,540 --> 00:01:48,130
Once we've created our contract, we can write automated tests,

29
00:01:48,130 --> 00:01:48,980
have verified it,

30
00:01:48,980 --> 00:01:52,740
a consumer functions with that contract and then we can

31
00:01:52,740 --> 00:01:56,080
write automated tests which also verify the provider

32
00:01:56,080 --> 00:01:58,950
functions with that contract by complain.

33
00:01:58,950 --> 00:02:00,570
With this same contract,

34
00:02:00,570 --> 00:02:05,240
it becomes implicit that the two services will be able to function together.

35
00:02:05,240 --> 00:02:08,420
This means that our local contract tests fast and

36
00:02:08,420 --> 00:02:10,540
fully isolated from each other.

37
00:02:10,540 --> 00:02:13,890
Allow us to more confidently promote our micro services

38
00:02:13,890 --> 00:02:17,010
from our local machines to an environment.

39
00:02:17,010 --> 00:02:22,080
This means we can reduce or even eliminate our alliance and end to end testing.

40
00:02:22,080 --> 00:02:31,000
And it also means that our stops are replaced if accurate contracts which represent the rial micro services

