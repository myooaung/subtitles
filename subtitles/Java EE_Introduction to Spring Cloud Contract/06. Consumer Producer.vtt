WEBVTT
1
00:00:02.140 --> 00:00:04.650
[Autogenerated] before we move on to the provider side,

2
00:00:04.650 --> 00:00:10.140
let's look at some of the challenges introduced by generating dynamic requests.

3
00:00:10.140 --> 00:00:14.820
If we start with a contract on that contract supports any time we

4
00:00:14.820 --> 00:00:17.470
would generate provider side verification tests,

5
00:00:17.470 --> 00:00:19.340
for it is normal.

6
00:00:19.340 --> 00:00:21.180
Those tests would then in turn,

7
00:00:21.180 --> 00:00:24.090
call out to an instance off the provider as normal,

8
00:00:24.090 --> 00:00:25.640
too.

9
00:00:25.640 --> 00:00:27.740
But we have a question to ask.

10
00:00:27.740 --> 00:00:30.940
What value should time be in the request?

11
00:00:30.940 --> 00:00:34.730
Because putting any time in our contract doesn't provide any

12
00:00:34.730 --> 00:00:38.240
information about what their request should bay.

13
00:00:38.240 --> 00:00:42.810
In fact, if we did need to provide a specific time for this test,

14
00:00:42.810 --> 00:00:51.710
how would we do say, without removing direct jacks on the provider side?

15
00:00:51.710 --> 00:00:56.740
We have the same problem with Red Jacks in the response part of the contract.

16
00:00:56.740 --> 00:00:58.060
For example,

17
00:00:58.060 --> 00:01:02.750
if we start with a consume aside test and then we have our contracts,

18
00:01:02.750 --> 00:01:08.640
which generates a stub, if the response body in the stop is any u i day,

19
00:01:08.640 --> 00:01:12.720
then what value should are stop return to decline again,

20
00:01:12.720 --> 00:01:14.080
just like before.

21
00:01:14.080 --> 00:01:16.330
If we needed a specific value,

22
00:01:16.330 --> 00:01:19.930
how would we set it whilst keeping the any u u I D

23
00:01:19.930 --> 00:01:25.910
assertion to get around this problem.

24
00:01:25.910 --> 00:01:29.340
Spring cloud contracts has a solution.

25
00:01:29.340 --> 00:01:31.460
Let's start with an example contract,

26
00:01:31.460 --> 00:01:34.850
which allows any alphanumeric name on any demerit

27
00:01:34.850 --> 00:01:38.450
response without having to do anything.

28
00:01:38.450 --> 00:01:40.640
Spring cloud contract is first of all,

29
00:01:40.640 --> 00:01:44.340
smart enough to generate static date of fours.

30
00:01:44.340 --> 00:01:47.090
So when generating the provider side tests,

31
00:01:47.090 --> 00:01:52.910
it will use a value which matches the rejects on when generating stop responses.

32
00:01:52.910 --> 00:01:56.840
It will also pick a value that matches the Red Jacks.

33
00:01:56.840 --> 00:01:59.770
However, as we've already determined,

34
00:01:59.770 --> 00:02:02.720
we want to be able to control these values ourselves,

35
00:02:02.720 --> 00:02:06.940
robbing them, them being selected forests.

36
00:02:06.940 --> 00:02:10.170
The way to do this is using the consumer and produce,

37
00:02:10.170 --> 00:02:14.920
um, efforts part of the contract DSL, for example.

38
00:02:14.920 --> 00:02:18.880
We can now change our contracts or allows any Alfa Unicode

39
00:02:18.880 --> 00:02:23.320
value in our consumer side stop but uses a value on drew

40
00:02:23.320 --> 00:02:26.140
in the provider side tests.

41
00:02:26.140 --> 00:02:31.260
We can also declare any number for our provider side test assertions.

42
00:02:31.260 --> 00:02:35.940
And once you free to be returned by our consumer side stop.

43
00:02:35.940 --> 00:02:46.000
This kind of flexibility allows us to have the granular control that we need over both sides of the interaction in our contract.

