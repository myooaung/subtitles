1
00:00:02,080 --> 00:00:05,170
[Autogenerated] in this demo will be implementing a feature where

2
00:00:05,170 --> 00:00:08,240
an input message triggers an output message.

3
00:00:08,240 --> 00:00:11,320
We'll start by writing a failing consumer side test,

4
00:00:11,320 --> 00:00:16,990
which sends an import message on expects an output matches to be consumed well,

5
00:00:16,990 --> 00:00:21,150
then define an input output, matches contracts and then,

6
00:00:21,150 --> 00:00:24,200
by using the stoves generated from that contract,

7
00:00:24,200 --> 00:00:27,830
will make our consumer site test pass on.

8
00:00:27,830 --> 00:00:32,460
The provider side will then generate our contract verification tests

9
00:00:32,460 --> 00:00:36,340
and finally will make our provide aside tests pass.

10
00:00:36,340 --> 00:00:40,540
Starting in our consumer, let's navigated a palm file.

11
00:00:40,540 --> 00:00:43,740
Although it hasn't affected any functionality so far,

12
00:00:43,740 --> 00:00:45,970
we should be used in the spring cloud contract.

13
00:00:45,970 --> 00:00:47,540
Stubborn a starter.

14
00:00:47,540 --> 00:00:51,370
We can update our dependency to reflect lists as now it's required in

15
00:00:51,370 --> 00:00:54,990
order to auto configure everything for the next steps.

16
00:00:54,990 --> 00:00:55,750
At this point,

17
00:00:55,750 --> 00:00:58,260
we could have also been using a bomb foul to manage all

18
00:00:58,260 --> 00:01:00,630
our various spring cloud dependencies.

19
00:01:00,630 --> 00:01:02,290
But we'll stick with what we already have.

20
00:01:02,290 --> 00:01:03,940
For now,

21
00:01:03,940 --> 00:01:08,740
let's navigate to our tests and create a new one for the Emperor output pattern.

22
00:01:08,740 --> 00:01:12,130
We'll call it should Output Credit school when requesting credit.

23
00:01:12,130 --> 00:01:17,180
Score well, then call a method requests credit score on a yet to exist.

24
00:01:17,180 --> 00:01:20,480
Credit score producer will pass in a credit check

25
00:01:20,480 --> 00:01:25,140
request with citizen number 1234 as usual.

26
00:01:25,140 --> 00:01:30,640
Okay, let's make the class of field on the news old and enter to generate it.

27
00:01:30,640 --> 00:01:30,850
Well,

28
00:01:30,850 --> 00:01:35,130
then scroll to are yet to be implemented Method unused alternate enter to

29
00:01:35,130 --> 00:01:40,140
generate that to and also make our class a spring component.

30
00:01:40,140 --> 00:01:41,070
Following this,

31
00:01:41,070 --> 00:01:45,940
we can retrieve a school from the repository will create a year I d field and

32
00:01:45,940 --> 00:01:51,790
pasa en on then asserted the score we received is high to clarify what we're

33
00:01:51,790 --> 00:01:56,590
expecting here is for is to produce a MASH is requesting a credit score on then

34
00:01:56,590 --> 00:02:00,910
for another mashes to be consumed containing that credit score which will then

35
00:02:00,910 --> 00:02:05,810
be written Czar Repository We can then assert that this happened by reading from

36
00:02:05,810 --> 00:02:12,740
the repository Okay, let's run our tests and see what happens.

37
00:02:12,740 --> 00:02:15,240
We haven't no points for exception here.

38
00:02:15,240 --> 00:02:17,180
If we navigate back to the test,

39
00:02:17,180 --> 00:02:21,030
we concede it's because the credit score producer will be No,

40
00:02:21,030 --> 00:02:24,940
This is because we forgot to add the auto wide annotation

41
00:02:24,940 --> 00:02:28,140
Let's scroll to the top and at the auto wide annotation

42
00:02:28,140 --> 00:02:31,340
and then run the test again.

43
00:02:31,340 --> 00:02:32,090
Great.

44
00:02:32,090 --> 00:02:34,410
The failure is now the one we want.

45
00:02:34,410 --> 00:02:38,380
We read from our repository and gotten all as a repositories MNT on.

46
00:02:38,380 --> 00:02:41,510
We didn't get high, which is what we actually want.

47
00:02:41,510 --> 00:02:43,210
Okay, let's navigate.

48
00:02:43,210 --> 00:02:46,890
So our producer and start to implement it will continue

49
00:02:46,890 --> 00:02:49,080
using spring cloud stream here on.

50
00:02:49,080 --> 00:02:52,400
Remember, we're not going to go into the final details off it.

51
00:02:52,400 --> 00:02:57,320
As a focus of this course is purely on spring cloud contract.

52
00:02:57,320 --> 00:03:00,990
Well, first, add a string cloud contract stream source field on auto,

53
00:03:00,990 --> 00:03:03,090
wire it via constructor,

54
00:03:03,090 --> 00:03:07,940
then in the method will use it to send our credit shot request.

55
00:03:07,940 --> 00:03:08,170
Well,

56
00:03:08,170 --> 00:03:13,420
then switch back to our application configuration on bind the source class

57
00:03:13,420 --> 00:03:17,400
and then we'll switch star application prophecies first.

58
00:03:17,400 --> 00:03:22,370
Although this may not be necessary, will add to content types are input channel.

59
00:03:22,370 --> 00:03:24,650
Then we can copy and paste everything,

60
00:03:24,650 --> 00:03:27,830
changing the word inputs output and then Rina in the

61
00:03:27,830 --> 00:03:30,700
destination to credit score requests.

62
00:03:30,700 --> 00:03:34,690
This means our producer it will send a message to this channel.

63
00:03:34,690 --> 00:03:40,240
Okay, lets one our test again and see what happens.

64
00:03:40,240 --> 00:03:44,270
We got exactly the same result is before this is because even

65
00:03:44,270 --> 00:03:46,370
though we should be produced in a message.

66
00:03:46,370 --> 00:03:51,040
We have no contract which causes and over masses to be consumed in return.

67
00:03:51,040 --> 00:03:54,390
We'll need to implement this now.

68
00:03:54,390 --> 00:03:57,290
Okay, sweet sheen back to our provider.

69
00:03:57,290 --> 00:04:01,110
Let's copy and paste our existing messaging contract well at

70
00:04:01,110 --> 00:04:03,840
an emperor output suffix to the end of it.

71
00:04:03,840 --> 00:04:04,060
Well,

72
00:04:04,060 --> 00:04:07,740
then change the label to score of High Emperor Alpert and

73
00:04:07,740 --> 00:04:10,270
then delete our existing input block.

74
00:04:10,270 --> 00:04:13,650
This is because our input will now be a message from our credit score

75
00:04:13,650 --> 00:04:16,320
Request channel as opposed to an intern or method.

76
00:04:16,320 --> 00:04:17,980
Call Well, first,

77
00:04:17,980 --> 00:04:21,410
declare a message from Block providing US Credit score Request

78
00:04:21,410 --> 00:04:25,310
Channel as an argument will then provide a body well,

79
00:04:25,310 --> 00:04:29,520
then at the citizen number that we send in our consumer side test.

80
00:04:29,520 --> 00:04:35,430
And then we'll add a U I day as the U ideas randomly generated by our consumer.

81
00:04:35,430 --> 00:04:38,670
Will you see which is short hand for consumer UN

82
00:04:38,670 --> 00:04:41,640
provider rejects of any your I D.

83
00:04:41,640 --> 00:04:44,580
On the provider side will provide the same you your i

84
00:04:44,580 --> 00:04:47,620
d as a one in our output message.

85
00:04:47,620 --> 00:04:51,240
The output Messi's block can be left as it already is.

86
00:04:51,240 --> 00:04:55,190
This is because consuming in it and storing the results in a repository

87
00:04:55,190 --> 00:04:59,440
has already been implemented in the previous demos.

88
00:04:59,440 --> 00:05:02,230
Okay, now our contract is complete.

89
00:05:02,230 --> 00:05:05,540
Will switch to the terminal on remaining clean installs.

90
00:05:05,540 --> 00:05:09,140
Get test to install it in our local repository.

91
00:05:09,140 --> 00:05:12,450
We can then switch back to our consumer on rerun are

92
00:05:12,450 --> 00:05:15,000
failing test behind the scenes,

93
00:05:15,000 --> 00:05:18,460
we expect spring cloud contract to receive the input message

94
00:05:18,460 --> 00:05:21,540
on in Fired a corresponding output message.

95
00:05:21,540 --> 00:05:25,270
We've already implemented decode for receiving the output message.

96
00:05:25,270 --> 00:05:29,120
So we expect everything to function right away also,

97
00:05:29,120 --> 00:05:32,600
what's nice here is that everything will happen in the same frat,

98
00:05:32,600 --> 00:05:35,510
meaning we don't have to implement any concurrent kowtow.

99
00:05:35,510 --> 00:05:38,450
Wait for our output message to be returns.

100
00:05:38,450 --> 00:05:41,200
Okay, lets from the tests.

101
00:05:41,200 --> 00:05:47,240
Great artists pass, meaning we fully implemented everything in our consumer side.

102
00:05:47,240 --> 00:05:49,140
Switching Baxter are provider.

103
00:05:49,140 --> 00:05:53,430
We now need to implement its side of the interaction to First,

104
00:05:53,430 --> 00:05:55,840
let's run and install to generate our contract

105
00:05:55,840 --> 00:05:59,440
verification tests and see what happens.

106
00:05:59,440 --> 00:06:02,780
Our newly generated test fells is expected,

107
00:06:02,780 --> 00:06:06,340
so lets navigate to it and do some analysis.

108
00:06:06,340 --> 00:06:11,640
First we concede a contract verifier creating import message in our contract.

109
00:06:11,640 --> 00:06:15,580
We can then see it sending that message down the channel in our contract.

110
00:06:15,580 --> 00:06:18,470
And finally we can see it receiving the message from

111
00:06:18,470 --> 00:06:20,490
the Output Channel of our contract,

112
00:06:20,490 --> 00:06:24,240
asserting that it matches the output message in our contract.

113
00:06:24,240 --> 00:06:29,040
Okay, lets from the test directly and see why it fails.

114
00:06:29,040 --> 00:06:32,310
We can see the problem is that there's no credit score requests.

115
00:06:32,310 --> 00:06:33,090
Bean.

116
00:06:33,090 --> 00:06:36,610
What this error actually means is that we haven't declared anything which

117
00:06:36,610 --> 00:06:40,010
sends messages down the credit score Request Channel.

118
00:06:40,010 --> 00:06:43,470
Let's fix this will start by switching to our application

119
00:06:43,470 --> 00:06:47,790
class on binding the sink to this allows our provider to

120
00:06:47,790 --> 00:06:50,660
consume is while his produce messages.

121
00:06:50,660 --> 00:06:54,490
Then we can create a consumer class will call it credit school.

122
00:06:54,490 --> 00:06:59,500
Consumer lets them make a spring component a nan crea Can she?

123
00:06:59,500 --> 00:07:02,940
Mefford, which takes a credit shot request parameter,

124
00:07:02,940 --> 00:07:04,750
we condemn Bind it to are saying,

125
00:07:04,750 --> 00:07:09,120
using the extreme listener annotation on after days will wiring in

126
00:07:09,120 --> 00:07:13,090
our credit check service and then use it to calculate a credit score

127
00:07:13,090 --> 00:07:15,580
based on the input from our message?

128
00:07:15,580 --> 00:07:16,330
Finally,

129
00:07:16,330 --> 00:07:19,270
were wiring our producer sending the results of our

130
00:07:19,270 --> 00:07:21,840
credit check fruit afterwards.

131
00:07:21,840 --> 00:07:24,920
Now we have a simple method which receives a message.

132
00:07:24,920 --> 00:07:28,060
Does some logic and then outputs and over message.

133
00:07:28,060 --> 00:07:31,690
Just like our contract verification test needs.

134
00:07:31,690 --> 00:07:34,320
The final step is to modify our application.

135
00:07:34,320 --> 00:07:36,610
Properties will copy and paste.

136
00:07:36,610 --> 00:07:38,310
What's our already change?

137
00:07:38,310 --> 00:07:43,540
Inputs output on, then chains, destination to credit score requests.

138
00:07:43,540 --> 00:07:48,940
Okay, let's navigate back to our test run it and see what happens.

139
00:07:48,940 --> 00:07:53,380
We're still getting a failure this time because our matches payload is no.

140
00:07:53,380 --> 00:07:59,750
But why is this while if we remember, we never actually implemented our service.

141
00:07:59,750 --> 00:08:02,980
If we navigate to it, we can see that it always returns.

142
00:08:02,980 --> 00:08:07,280
No, the reason our offer tests paths is because they use a mark.

143
00:08:07,280 --> 00:08:10,110
So we should be using the mark here as well.

144
00:08:10,110 --> 00:08:12,990
We can set this up in the base contract test class,

145
00:08:12,990 --> 00:08:17,220
so lets navigate to it, will create a test configuration on,

146
00:08:17,220 --> 00:08:17,680
innit?

147
00:08:17,680 --> 00:08:20,840
Declare our credit, Jack services a Mark bean.

148
00:08:20,840 --> 00:08:23,180
This means a mosquito mark will be in Stan.

149
00:08:23,180 --> 00:08:26,880
She hated instead of the rial instance off the being well,

150
00:08:26,880 --> 00:08:29,740
then point are Tacitus configuration,

151
00:08:29,740 --> 00:08:32,940
then will create a post constructs annotated method.

152
00:08:32,940 --> 00:08:36,190
This will be called after our spring context is initialized.

153
00:08:36,190 --> 00:08:38,420
But before our test rooms, Well,

154
00:08:38,420 --> 00:08:42,790
then wire in our mock service and then using mosquito.

155
00:08:42,790 --> 00:08:45,810
We will configure it so it returns to score in the U I.

156
00:08:45,810 --> 00:08:46,070
D.

157
00:08:46,070 --> 00:08:50,940
In our contracts when it receives a citizen number in our contract.

158
00:08:50,940 --> 00:08:53,550
Okay, lets one our test again.

159
00:08:53,550 --> 00:08:58,190
Fix this minor compilation our and then try running it again.

160
00:08:58,190 --> 00:09:00,280
Great artists passes,

161
00:09:00,280 --> 00:09:09,000
meaning we fully implemented our last messaging scenario wherein input message triggers an outfit message.

