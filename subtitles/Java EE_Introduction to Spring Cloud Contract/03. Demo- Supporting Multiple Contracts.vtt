WEBVTT
1
00:00:01.940 --> 00:00:04.150
[Autogenerated] in this demo will be following through the

2
00:00:04.150 --> 00:00:06.980
same workflow as in the previous module,

3
00:00:06.980 --> 00:00:10.100
this time building on what we've already done by adding a

4
00:00:10.100 --> 00:00:13.640
second contract for a new scenario.

5
00:00:13.640 --> 00:00:18.070
We'll start by writing a failing test this time for credit card application,

6
00:00:18.070 --> 00:00:20.940
denial, Robin and Grant.

7
00:00:20.940 --> 00:00:23.500
Then a new contract will be created.

8
00:00:23.500 --> 00:00:27.040
In order for us to make our failing tests pass,

9
00:00:27.040 --> 00:00:31.420
we'll make our failing consume aside test pass provide a side.

10
00:00:31.420 --> 00:00:35.730
Tests will then be all to generate it and then finally will make

11
00:00:35.730 --> 00:00:42.820
our provide aside test pass Also so again,

12
00:00:42.820 --> 00:00:46.000
we'll start with far Can Shima project and go through the

13
00:00:46.000 --> 00:00:49.140
same workflow as in the previous module.

14
00:00:49.140 --> 00:00:53.030
But this time the scenario will bay for a credit card application.

15
00:00:53.030 --> 00:00:56.040
Denial Robin and Grand.

16
00:00:56.040 --> 00:00:59.210
We'll start with feigning test copying and pasting

17
00:00:59.210 --> 00:01:01.840
the existing one and modifying it.

18
00:01:01.840 --> 00:01:05.230
Remember, this should usually be the starting point.

19
00:01:05.230 --> 00:01:10.440
Is consumer giving contract testing is still a TDD workflow?

20
00:01:10.440 --> 00:01:15.370
We can end rename our copy test to should deny application when credit

21
00:01:15.370 --> 00:01:21.380
score is low and then changed a citizen number to a new one as the existing

22
00:01:21.380 --> 00:01:25.560
one already has a contract associated with it.

23
00:01:25.560 --> 00:01:31.340
And finally, our assertion should change to verify the night instead of grunted.

24
00:01:31.340 --> 00:01:36.540
Let's run a test and see what happens.

25
00:01:36.540 --> 00:01:39.640
It looks like we're getting the failures we expected.

26
00:01:39.640 --> 00:01:44.800
But let's take a closer look to see what that failure is scrolling up.

27
00:01:44.800 --> 00:01:45.670
We can see a why.

28
00:01:45.670 --> 00:01:47.280
Ma Kara.

29
00:01:47.280 --> 00:01:51.640
This is because our existing contract is loaded by the stop runner,

30
00:01:51.640 --> 00:01:56.440
but not matched by the downstream request created by running our test.

31
00:01:56.440 --> 00:01:57.640
Taking a look.

32
00:01:57.640 --> 00:02:00.910
We concede that this is because he expected citizen number

33
00:02:00.910 --> 00:02:06.100
off 1234 does not match the citizen number in the request

34
00:02:06.100 --> 00:02:14.740
for 444 In order to fix this, we now need to create an additional contract.

35
00:02:14.740 --> 00:02:17.520
This one will expect a citizen number off.

36
00:02:17.520 --> 00:02:21.330
4444 I'm return a low credit score.

37
00:02:21.330 --> 00:02:24.140
Robert Down high one.

38
00:02:24.140 --> 00:02:28.380
First of all, let's switch back to our provided project.

39
00:02:28.380 --> 00:02:32.140
Then let's copy and paste the existing contract.

40
00:02:32.140 --> 00:02:38.800
But this time, rename it too, should grant a credit score of Lot's or Citizen.

41
00:02:38.800 --> 00:02:41.940
We cannot make some simple modifications to our

42
00:02:41.940 --> 00:02:45.240
copied and pasted specifications.

43
00:02:45.240 --> 00:02:52.440
First, we can change the citizen number 24444 as This is what our test uses.

44
00:02:52.440 --> 00:02:56.700
Then we can change score that is returned to low as we

45
00:02:56.700 --> 00:03:00.740
need a low score again for our test.

46
00:03:00.740 --> 00:03:04.850
That's all we need to do, so we can switch back to our terminal on run.

47
00:03:04.850 --> 00:03:08.030
The build of our provider skipping tests in order

48
00:03:08.030 --> 00:03:09.670
to generate our stops were foul.

49
00:03:09.670 --> 00:03:11.240
Any failures?

50
00:03:11.240 --> 00:03:19.240
Let's run maven clean, install skip tests.

51
00:03:19.240 --> 00:03:21.400
Great are built past.

52
00:03:21.400 --> 00:03:25.740
Let's scroll up and take a look at the locks to see what's happened.

53
00:03:25.740 --> 00:03:32.540
This time, we can see two contracts copied over before high under low scenarios,

54
00:03:32.540 --> 00:03:34.930
and we can also see two sets of stuff.

55
00:03:34.930 --> 00:03:38.220
Mapping is being generated again for both far

56
00:03:38.220 --> 00:03:42.240
corresponding high and low contract scenarios.

57
00:03:42.240 --> 00:03:45.040
We won't bother analyzing a stub jar again,

58
00:03:45.040 --> 00:03:48.470
as it should be self explanatory that both contracts and the

59
00:03:48.470 --> 00:03:52.330
corresponding stop map ings will be inside it and executed.

60
00:03:52.330 --> 00:03:53.290
When we run the store.

61
00:03:53.290 --> 00:03:59.970
Brunner switching back to our consumer, we can run our failing test again on DSI.

62
00:03:59.970 --> 00:04:05.330
If it now passes as a stop will now contain a new contract.

63
00:04:05.330 --> 00:04:07.860
Mm, let's like we still have a failure.

64
00:04:07.860 --> 00:04:11.140
So let's scroll up and see what's wrong.

65
00:04:11.140 --> 00:04:14.580
While this time Wire Mark Muchtar request.

66
00:04:14.580 --> 00:04:21.140
We can see our citizen number off 4444 when 10 on We got response of Low.

67
00:04:21.140 --> 00:04:25.140
This means our contract on the corresponding stop are working.

68
00:04:25.140 --> 00:04:27.360
So something else must be broken,

69
00:04:27.360 --> 00:04:29.980
probably because we haven't actually implemented the

70
00:04:29.980 --> 00:04:33.940
functionality in Alkhan Xinye.

71
00:04:33.940 --> 00:04:38.540
Scrolling along, we concede it's adjacent de serialization era.

72
00:04:38.540 --> 00:04:41.550
It's trying to convert a string low into our scoring,

73
00:04:41.550 --> 00:04:44.540
Um, but it's not possible value.

74
00:04:44.540 --> 00:04:49.340
So lets navigate to it and add low as a second possible value.

75
00:04:49.340 --> 00:04:50.280
Now that's done.

76
00:04:50.280 --> 00:04:55.610
We can rerun our tests and see if they can now pass well.

77
00:04:55.610 --> 00:05:01.040
It looks like we got fervor but unfortunately still have a test value.

78
00:05:01.040 --> 00:05:05.640
This time, it's because the score of Low is not yet supported.

79
00:05:05.640 --> 00:05:06.690
Let's navigate.

80
00:05:06.690 --> 00:05:10.690
So where we hold the logic for granting applications on modify it.

81
00:05:10.690 --> 00:05:14.040
So this is no longer the case.

82
00:05:14.040 --> 00:05:17.530
We can see that we currently only chat for a score of high,

83
00:05:17.530 --> 00:05:20.340
otherwise referring exception,

84
00:05:20.340 --> 00:05:23.990
let's start a new condition that chaps for a score of low on,

85
00:05:23.990 --> 00:05:25.280
then returns tonight.

86
00:05:25.280 --> 00:05:26.940
When that's the case,

87
00:05:26.940 --> 00:05:33.640
then let's do a bit of cleanup by adding some static imports using alternate er.

88
00:05:33.640 --> 00:05:34.890
Now we've done this.

89
00:05:34.890 --> 00:05:43.230
We can yet again run our test and see if it passes great this time it does.

90
00:05:43.230 --> 00:05:47.330
So we can be confident that the consumer side of our credit application to

91
00:05:47.330 --> 00:05:52.270
nail dysfunctional now we need to implement to provide aside in order to

92
00:05:52.270 --> 00:05:57.880
implement everything and to end switching back to our provide a project we can

93
00:05:57.880 --> 00:06:01.440
run maven install without skipping the tests.

94
00:06:01.440 --> 00:06:04.780
This means that the contract verification tests for our low

95
00:06:04.780 --> 00:06:09.220
credit score will be generated and executes it.

96
00:06:09.220 --> 00:06:10.880
We can see that because of this,

97
00:06:10.880 --> 00:06:15.090
we now have a failure with a generated test called Validate Should

98
00:06:15.090 --> 00:06:18.410
grunt Credit Score of low to a citizen Failing.

99
00:06:18.410 --> 00:06:23.660
Let's navigate to it and do some analysis we can see to.

100
00:06:23.660 --> 00:06:27.020
This altar generated test is very similar to the one

101
00:06:27.020 --> 00:06:29.620
we created in the last module.

102
00:06:29.620 --> 00:06:32.300
It makes a request in the new contract with the

103
00:06:32.300 --> 00:06:38.940
value of 444 as a citizen number on, it asserts that a response given is low.

104
00:06:38.940 --> 00:06:44.340
Let's run the test directly on do some analysis of why it fails.

105
00:06:44.340 --> 00:06:48.240
It looks like we're somehow returning know from our controller.

106
00:06:48.240 --> 00:06:53.940
Let's navigate to our base contract test class and see if anything looks wrong,

107
00:06:53.940 --> 00:06:54.640
right?

108
00:06:54.640 --> 00:06:57.960
We only have a mock interaction set up for the citizen.

109
00:06:57.960 --> 00:07:00.540
Number off Won t free four.

110
00:07:00.540 --> 00:07:01.950
Let's add another line,

111
00:07:01.950 --> 00:07:08.140
which supports a citizen number off 4444 on returns to score of Low,

112
00:07:08.140 --> 00:07:12.440
will create a low Inam value as it has yet to exist.

113
00:07:12.440 --> 00:07:19.540
Now we can run, maybe install again, this time seeing if our tests pass.

114
00:07:19.540 --> 00:07:25.140
Great, they dio, meaning we have implemented both sides of the interaction,

115
00:07:25.140 --> 00:07:26.410
as you can see,

116
00:07:26.410 --> 00:07:35.000
once you've already self skeleton than adding additional contracts or features becomes a lot faster than before.

