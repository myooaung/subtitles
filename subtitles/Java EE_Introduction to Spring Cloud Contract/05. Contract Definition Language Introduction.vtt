WEBVTT
1
00:00:02.140 --> 00:00:05.520
[Autogenerated] before we begin declaring our contracts will first

2
00:00:05.520 --> 00:00:08.300
take a high level look at spring cloud contracts.

3
00:00:08.300 --> 00:00:10.990
Contract definition language.

4
00:00:10.990 --> 00:00:16.810
As the name implies, the contract definition language is used to build contracts.

5
00:00:16.810 --> 00:00:20.520
It's designed to be a straightforward way to declare interactions

6
00:00:20.520 --> 00:00:24.840
between consumers and providers on integrate seamlessly into the

7
00:00:24.840 --> 00:00:28.340
spring cloud contract ecosystem.

8
00:00:28.340 --> 00:00:31.640
It's also written in Groovy, But don't let that scare you.

9
00:00:31.640 --> 00:00:32.340
If you don't know.

10
00:00:32.340 --> 00:00:36.550
It only uses a small subset off the language and is designed

11
00:00:36.550 --> 00:00:40.440
to be easy for any developer to understand.

12
00:00:40.440 --> 00:00:42.340
It's also statically typed,

13
00:00:42.340 --> 00:00:44.880
which is important to point out to those familiar

14
00:00:44.880 --> 00:00:47.440
with groovy as a dynamic language.

15
00:00:47.440 --> 00:00:48.500
Because of this,

16
00:00:48.500 --> 00:00:52.730
programmers will be able to figure out all the fields and methods available

17
00:00:52.730 --> 00:00:58.510
in a DSL easily and in terms of supported interactions.

18
00:00:58.510 --> 00:01:01.980
It comes with first class support for both hate TTP,

19
00:01:01.980 --> 00:01:04.640
our messaging out of the box.

20
00:01:04.640 --> 00:01:09.530
We'll be focusing on hate TTP and Ness module, a messaging based interactions.

21
00:01:09.530 --> 00:01:17.880
Later, If we were to declare a hate TTP contract,

22
00:01:17.880 --> 00:01:20.970
the first thing we do is called a make method,

23
00:01:20.970 --> 00:01:24.000
which creates a contract object within.

24
00:01:24.000 --> 00:01:28.380
Now we can and declare our top level request closure on within.

25
00:01:28.380 --> 00:01:30.260
Now we can declare to request,

26
00:01:30.260 --> 00:01:35.110
feels a expects here we're declaring a hate TTP method of

27
00:01:35.110 --> 00:01:38.790
get on a u r L path of Hello world.

28
00:01:38.790 --> 00:01:44.390
This means any get request a hollow world will comply with the contract.

29
00:01:44.390 --> 00:01:46.580
If you're wondering about the required value of

30
00:01:46.580 --> 00:01:51.960
over fields like body or headers, the answer is that they can be any value.

31
00:01:51.960 --> 00:01:56.440
The contracts only cares about the fields declared within it.

32
00:01:56.440 --> 00:01:59.000
Next weaken declared a top level response.

33
00:01:59.000 --> 00:02:00.230
Closure.

34
00:02:00.230 --> 00:02:04.120
This is where we put a response that we want our contract to give.

35
00:02:04.120 --> 00:02:06.440
When the request is made,

36
00:02:06.440 --> 00:02:10.520
we can declare a status of two hundreds a body of hollow to

37
00:02:10.520 --> 00:02:13.500
you on a content type head of application.

38
00:02:13.500 --> 00:02:14.740
Jason,

39
00:02:14.740 --> 00:02:19.060
on here we have our agreed interaction Our requests to be made by a

40
00:02:19.060 --> 00:02:27.940
consumer under response to be given by our provider changing our

41
00:02:27.940 --> 00:02:31.110
contract creation together into a workflow.

42
00:02:31.110 --> 00:02:34.340
We would first switch to our provider project.

43
00:02:34.340 --> 00:02:38.380
This is because the contracts typically live even here within

44
00:02:38.380 --> 00:02:42.720
another intermediary repository in this module will stick with

45
00:02:42.720 --> 00:02:48.440
keeping them in the provider within our provider we done at the

46
00:02:48.440 --> 00:02:52.990
spring cloud contract verifier dependency This is what gives us a

47
00:02:52.990 --> 00:02:55.070
contract definition language.

48
00:02:55.070 --> 00:02:58.410
The ability to build contract stops on the ability to

49
00:02:58.410 --> 00:03:02.440
build contract verification tests.

50
00:03:02.440 --> 00:03:05.940
We don't create our contract dot grieve e file.

51
00:03:05.940 --> 00:03:10.940
This would normally live in a directory with the same name is Arkin Shima.

52
00:03:10.940 --> 00:03:16.940
So it's easy to know what consumer has what interaction with our provider.

53
00:03:16.940 --> 00:03:20.270
We then declared he expected request in the contract.

54
00:03:20.270 --> 00:03:25.190
Normally the request we're trying to make in our failing test and

55
00:03:25.190 --> 00:03:28.790
then declared he expected response in the contract the response

56
00:03:28.790 --> 00:03:32.270
needed to make our failing Tass pass.

57
00:03:32.270 --> 00:03:37.140
I'm finally we Benin Stoltzfus skipping tests in the process.

58
00:03:37.140 --> 00:03:39.000
We skipped the test because for now,

59
00:03:39.000 --> 00:03:48.000
all we're doing is generating our contract stops. We don't care about the functionality on the provider side yet.

