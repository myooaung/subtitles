1
00:00:00,940 --> 00:00:06,310
In JUnit, we use the Test annotation to mark methods as tests.

2
00:00:06,310 --> 00:00:11,350
The behavior of these tests has to be specified at compile time.

3
00:00:11,350 --> 00:00:14,140
It cannot be changed at runtime.

4
00:00:14,140 --> 00:00:19,650
For example, if we want to execute this method on multiple sets of data,

5
00:00:19,650 --> 00:00:23,820
one way to do it would be to create a list and iterate it to

6
00:00:23,820 --> 00:00:27,640
act and assert on different data each time.

7
00:00:27,640 --> 00:00:30,980
We can also use the RepeatedTest annotation and the

8
00:00:30,980 --> 00:00:34,950
RepititionInfo interface and remove the for loop,

9
00:00:34,950 --> 00:00:39,370
but still act and assert on different data each time.

10
00:00:39,370 --> 00:00:41,640
However, there's a better way.

11
00:00:41,640 --> 00:00:44,520
JUnit 5 introduced dynamic tests,

12
00:00:44,520 --> 00:00:49,300
which are generated by a method annotated with TestFactory,

13
00:00:49,300 --> 00:00:55,940
which is not a test method by itself, but rather a factory of tests.

14
00:00:55,940 --> 00:01:02,040
The restriction is that this TestFactory method must not be private or static.

15
00:01:02,040 --> 00:01:05,510
Otherwise, they won't be executed by JUnit.

16
00:01:05,510 --> 00:01:11,530
To create a test, the TestFactory uses as data source Collections,

17
00:01:11,530 --> 00:01:16,130
objects that implement the Iterable or the Iterator interfaces,

18
00:01:16,130 --> 00:01:17,780
Streams, or Arrays.

19
00:01:17,780 --> 00:01:22,940
All these sources must contain elements of type DynamicNode,

20
00:01:22,940 --> 00:01:29,040
an abstract class that is the parent of DynamicContainer and DynamicTest.

21
00:01:29,040 --> 00:01:35,750
DynamicContainer is a container of DynamicTest that has its own display name

22
00:01:35,750 --> 00:01:40,550
and contains either an iterable or a stream of dynamic nodes.

23
00:01:40,550 --> 00:01:46,940
In other words, it can contain other DynamicContainers or DynamicTests.

24
00:01:46,940 --> 00:01:52,540
The class DynamicTest represents the tests generated at runtime.

25
00:01:52,540 --> 00:01:56,670
It is composed of a display name and an executable,

26
00:01:56,670 --> 00:02:01,440
a functional interface that wraps the code of the test so it can be

27
00:02:01,440 --> 00:02:05,640
provided as a lambda expression or method reference.

28
00:02:05,640 --> 00:02:12,030
However, BeforeEach and AfterEach methods are not executed for each dynamic test.

29
00:02:12,030 --> 00:02:16,940
Dynamic tests have no notion of the test lifecycle.

30
00:02:16,940 --> 00:02:17,660
All right,

31
00:02:17,660 --> 00:02:22,530
it's time to see how the lifecycle is handled and how to work with

32
00:02:22,530 --> 00:02:27,340
the classes DynamicTest and DynamicContainer.

33
00:02:27,340 --> 00:02:32,640
I have already created a class to test the RewardByGiftService with

34
00:02:32,640 --> 00:02:38,530
dynamic tests with methods to get a stream of random numbers and a

35
00:02:38,530 --> 00:02:41,940
sample order that we'll use later.

36
00:02:41,940 --> 00:02:46,540
Let's start by creating dynamic tests from the collection.

37
00:02:46,540 --> 00:02:53,840
The first thing I have to do is annotate this method as a TestFactory, not Test.

38
00:02:53,840 --> 00:02:57,140
Remember, this is a TestFactory.

39
00:02:57,140 --> 00:03:02,830
Then, I'm going to return at list of DynamicTest instances.

40
00:03:02,830 --> 00:03:04,310
For this,

41
00:03:04,310 --> 00:03:09,780
the DynamicTest class has a static method with the same name to create

42
00:03:09,780 --> 00:03:14,950
DynamicTest with the supplied display name and lambda expression,

43
00:03:14,950 --> 00:03:19,740
which represents the functional interface executable.

44
00:03:19,740 --> 00:03:23,560
In this case, I just have an assertEquals method,

45
00:03:23,560 --> 00:03:32,570
but I'm going to paste another dynamicTest and run the class.

46
00:03:32,570 --> 00:03:39,140
Here on the left side, you can see the two dynamic tests.

47
00:03:39,140 --> 00:03:46,140
Now let's modify the assertion of the first test to make it fail.

48
00:03:46,140 --> 00:03:50,640
The first test failed, but the second test was executed.

49
00:03:50,640 --> 00:03:56,940
These tell us that dynamic tests are executed independently from each other.

50
00:03:56,940 --> 00:04:01,760
I'm going to fix the assert method and add a setUp method

51
00:04:01,760 --> 00:04:04,840
that right now just prints a message.

52
00:04:04,840 --> 00:04:11,440
If I run the test, you can see that only one message is printed.

53
00:04:11,440 --> 00:04:15,940
The setUp method was executed once for the whole factory,

54
00:04:15,940 --> 00:04:21,000
not for each dynamic test. BeforeEach and AfterEach methods

55
00:04:21,000 --> 00:04:25,940
are not executed for each dynamic test.

56
00:04:25,940 --> 00:04:27,890
Okay, instead of a collection,

57
00:04:27,890 --> 00:04:31,490
you can use an iterable. List implements this

58
00:04:31,490 --> 00:04:34,940
interface, so there are no problems here.

59
00:04:34,940 --> 00:04:38,040
Or you can use an iterator.

60
00:04:38,040 --> 00:04:40,840
Just let me add it here.

61
00:04:40,840 --> 00:04:41,840
Great.

62
00:04:41,840 --> 00:04:43,850
We can also use streams.

63
00:04:43,850 --> 00:04:49,080
So let me add a RewardGiftService variable to initialize it in the setUp

64
00:04:49,080 --> 00:04:54,850
method and change the method to test. If the gift product is not in an

65
00:04:54,850 --> 00:04:58,640
order, the reward should not be applied.

66
00:04:58,640 --> 00:05:05,040
So I'm going to get a stream of random numbers. Limit them to 5.

67
00:05:05,040 --> 00:05:08,690
And using a map method in a lambda expression,

68
00:05:08,690 --> 00:05:15,240
I'm going to take that random number and call the dynamicTest static method

69
00:05:15,240 --> 00:05:22,340
with the display name Testing product ID and a lambda expression to set the

70
00:05:22,340 --> 00:05:29,330
random number as the GiftProductId. Apply the reward and assert that the

71
00:05:29,330 --> 00:05:33,440
discount and the redeemed points are 0.

72
00:05:33,440 --> 00:05:35,840
If I run the class,

73
00:05:35,840 --> 00:05:39,860
you can see that the test was executed five times with

74
00:05:39,860 --> 00:05:43,140
a different product ID each time.

75
00:05:43,140 --> 00:05:47,460
Now let me show you another way to implement this test with

76
00:05:47,460 --> 00:05:52,240
another method from the DynamicTest class, stream.

77
00:05:52,240 --> 00:05:55,640
This method takes three parameters.

78
00:05:55,640 --> 00:05:56,440
First,

79
00:05:56,440 --> 00:06:01,830
an iterator that serves as a dynamic input generator. Then a

80
00:06:01,830 --> 00:06:06,390
function, the functional interface function, generates a display

81
00:06:06,390 --> 00:06:13,040
name based on an input value. And a consumer that executes a test

82
00:06:13,040 --> 00:06:15,740
based on the input value.

83
00:06:15,740 --> 00:06:20,840
The last two parameters take the same type as the iterator.

84
00:06:20,840 --> 00:06:25,440
So we need an iterator that generates random numbers.

85
00:06:25,440 --> 00:06:26,220
Luckily,

86
00:06:26,220 --> 00:06:31,900
streams have a method to convert the stream to an iterator. So we only

87
00:06:31,900 --> 00:06:36,740
need to call this method on the stream of random numbers.

88
00:06:36,740 --> 00:06:42,390
Now as we are using an iterator of type long for the display name generator,

89
00:06:42,390 --> 00:06:48,300
we need to have a function that takes a long and returns a stream, in

90
00:06:48,300 --> 00:06:53,640
this case Testing product ID plus a random number.

91
00:06:53,640 --> 00:06:54,410
Finally,

92
00:06:54,410 --> 00:06:57,750
we just need to wrap the code of the test in a lambda

93
00:06:57,750 --> 00:07:00,840
expression of type ThrowingConsumer,

94
00:07:00,840 --> 00:07:06,640
which is a regular consumer that throws exceptions of type throwable.

95
00:07:06,640 --> 00:07:09,640
Let's run the test.

96
00:07:09,640 --> 00:07:10,210
Great.

97
00:07:10,210 --> 00:07:17,130
Once again, five dynamic tests with random IDs. Finally,

98
00:07:17,130 --> 00:07:21,440
let's create a dynamic test with containers.

99
00:07:21,440 --> 00:07:24,740
Let's add another factory test method.

100
00:07:24,740 --> 00:07:30,040
This one will return a stream of DynamicContainers.

101
00:07:30,040 --> 00:07:35,540
I'm going to start with a stream of numbers from 1 to 6,

102
00:07:35,540 --> 00:07:41,540
which are actually 5 because the upper bound of this method is exclusive.

103
00:07:41,540 --> 00:07:48,140
Then, I'm going to convert these numbers to dynamicContainer objects.

104
00:07:48,140 --> 00:07:53,380
Their display name is going to be a Container for ID plus the

105
00:07:53,380 --> 00:07:58,760
given productId. As a second parameter, the method

106
00:07:58,760 --> 00:08:03,840
dynamicContainer can take a stream of DynamicNodes.

107
00:08:03,840 --> 00:08:09,140
The first element is going to be a dynamicTest to test if the given

108
00:08:09,140 --> 00:08:16,470
productId is valid, in other words if it's greater than 0. And the second

109
00:08:16,470 --> 00:08:21,040
element of the stream is going to be a DynamicContainer.

110
00:08:21,040 --> 00:08:27,190
Remember that both DynamicTest and DynamicContainer extend from DynamicNode.

111
00:08:27,190 --> 00:08:33,900
For this container, we are going to have a dynamic test, this time, to test

112
00:08:33,900 --> 00:08:39,350
that a discount has been applied because the numbers generated are the ones

113
00:08:39,350 --> 00:08:43,340
that happen to be in our sample order.

114
00:08:43,340 --> 00:08:52,730
All right, let's run the class. DynamicTestsWithContainers, 5 containers,

115
00:08:52,730 --> 00:08:57,540
1 for each productId from 1 to 5.

116
00:08:57,540 --> 00:09:07,000
And then we have the test to validate the ID and the nested container with the Discount applied test.

