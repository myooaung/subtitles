WEBVTT
1

00:00:00.610 --> 00:00:06.860

Hi, guys, in this lesson, we will talk about Sprint and Sprint, basic components.



2

00:00:07.600 --> 00:00:15.850

Supreme Court is a framework for dependency injection, which is a pattern that allows us to build very



3

00:00:15.850 --> 00:00:17.500

decoupled systems.



4

00:00:18.460 --> 00:00:27.940

OK, we got it, but what is dependency injection dependency injection is a design that removes the



5

00:00:27.940 --> 00:00:36.220

dependency from the program in court so it can be easy to manage and test the application.



6

00:00:36.910 --> 00:00:43.900

Dependency injections makes our program called loosely coupled to understand it.



7

00:00:44.110 --> 00:00:45.910

Let's see it on an example.



8

00:00:46.630 --> 00:00:55.000

First of all, we will see the example for without using dependency injection it, we will set the example



9

00:00:55.000 --> 00:00:58.180

for Veith using dependency injection.



10

00:00:58.900 --> 00:01:04.510

For example, we have a class like user service in user service.



11

00:01:04.750 --> 00:01:11.230

We want to call user repository and we want to store users to a database.



12

00:01:11.260 --> 00:01:13.570

We have users methods.



13

00:01:14.650 --> 00:01:23.080

To do it, we can easily create user posts, for instance, and we can directly call it from Sabeh User



14

00:01:23.080 --> 00:01:23.470

Methods.



15

00:01:24.580 --> 00:01:34.960

OK, this solves our problem for now, but later, due to the reason we need to change use repository



16

00:01:34.960 --> 00:01:42.510

with different repository, for example, we should change it with a repository to do it.



17

00:01:42.670 --> 00:01:45.010

We should change user service.



18

00:01:45.010 --> 00:01:47.680

Closs for every change request.



19

00:01:48.870 --> 00:01:56.900

So the problem is user service is closely coupled with user repository or admin repository.



20

00:01:57.570 --> 00:01:59.860

So how can we avoid it?



21

00:02:00.690 --> 00:02:05.700

Of course we can avoid from it with using dependency injection.



22

00:02:06.880 --> 00:02:13.150

And we can say that with using dependancy, emerging principle.



23

00:02:14.080 --> 00:02:22.060

Dependency, emotion principle is a solid principle, the Penman's emotion principle states that high



24

00:02:22.060 --> 00:02:30.160

level modules should not depend on low level modules, but should depend on obstructions.



25

00:02:30.940 --> 00:02:35.440

Also, obstructions should not depend on details.



26

00:02:36.010 --> 00:02:39.520

Details should depend on obstructions.



27

00:02:40.720 --> 00:02:49.540

OK, let's see them on our example, first of all, user repository clause should depend on abstractness.



28

00:02:49.960 --> 00:02:58.270

To do it, we can create interface for user repository, then user repository can be implemented with



29

00:02:58.420 --> 00:03:04.030

user repository implementation plus then use the repository implementation.



30

00:03:04.030 --> 00:03:07.260

Plus can depend on user repository.



31

00:03:08.200 --> 00:03:10.180

So we do it like this.



32

00:03:10.450 --> 00:03:13.930

We can maintain dependency inmotion principle.



33

00:03:14.990 --> 00:03:19.590

To dependency injection, we can inject it with two ways.



34

00:03:20.060 --> 00:03:23.660

First one is we can inject it with constructive.



35

00:03:24.470 --> 00:03:35.000

Second one is we can inject it with using sensation after all, we can call it anywhere with injections.



36

00:03:35.750 --> 00:03:40.600

And every posture is changed without modification.



37

00:03:40.790 --> 00:03:44.180

We can call user service methods easily.



38

00:03:45.130 --> 00:03:51.010

What constructed and sensor dependency injection reduced coupling?



39

00:03:52.080 --> 00:03:57.840

OK, now we will talk about how superintended dependency injection.



40

00:03:59.280 --> 00:04:08.090

In spring, dependency, injection can be handled with three ways dependency injection in spring can



41

00:04:08.090 --> 00:04:12.860

be done through constructor's Setas or Fields'.



42

00:04:13.730 --> 00:04:15.800

Let's see them for our example.



43

00:04:16.610 --> 00:04:25.670

For constructive example, we can create beans for user service and use a repository, and later we



44

00:04:25.670 --> 00:04:28.700

can directly call from user service contracts.



45

00:04:30.220 --> 00:04:34.630

Now, we so others think about what is being.



46

00:04:35.540 --> 00:04:41.000

Just think simple, these are objects or instances of.



47

00:04:42.350 --> 00:04:52.460

So we have just created Usery Pusser object here with using B later we can call these objects from Ciprian



48

00:04:52.460 --> 00:04:55.850

components throughout applications skop.



49

00:04:57.030 --> 00:05:05.190

We should also notice something here, what is configuration, the configuration annotation indicates



50

00:05:05.490 --> 00:05:09.270

that the glass is a source of being definition's.



51

00:05:10.110 --> 00:05:15.400

So this glass is a sprink configured glass to describe it.



52

00:05:15.900 --> 00:05:19.830

We have just marked with configuration annotation.



53

00:05:21.190 --> 00:05:26.900

Second, dependency injection method in Ciprian is setar based injection.



54

00:05:27.430 --> 00:05:32.860

So, for our example, we can send a tweet using setar methods.



55

00:05:34.100 --> 00:05:42.440

The last dependency injection method is fields' based dependency injection to handle it, otherwise



56

00:05:42.440 --> 00:05:44.200

annotation will be used.



57

00:05:44.900 --> 00:05:53.810

Actually, we will generally use this annotation in our project, but we should not forget something



58

00:05:53.810 --> 00:05:56.710

for these dependency injection methods.



59

00:05:57.260 --> 00:06:03.230

These methods can be only used among Ciprian components.



60

00:06:04.130 --> 00:06:08.020

OK, now we will talk about Ciprian components.



61

00:06:08.810 --> 00:06:11.590

First one is component annotation.



62

00:06:12.350 --> 00:06:18.500

This is general purpose annotation, indicating that the class is a separate component.



63

00:06:20.280 --> 00:06:28.230

Second man is the poster annotation, this is to indicate that the class defines a data repository.



64

00:06:29.260 --> 00:06:39.130

Third one is service sanitation service Beans Holt, the business logic and Koula methods in the repository.



65

00:06:40.550 --> 00:06:50.570

The last one is comptrollers or wrest control rotation, these indicate that a particular cluster serves



66

00:06:50.570 --> 00:06:59.710

the role of a controller so you can call service methods here and you can serve it to relief.



67

00:07:00.890 --> 00:07:08.900

Now we will talk about the other baozi connotations first one is Ciprian good application annotation.



68

00:07:10.150 --> 00:07:21.250

This means to Marc Klaas s main class, so this class will be initializes class for separate, but second



69

00:07:21.250 --> 00:07:23.430

one is transactional notation.



70

00:07:23.890 --> 00:07:28.540

So this provides transactional, consistent methods.



71

00:07:29.140 --> 00:07:37.340

If you get any exception in a method, all the chains will be rolled back.



72

00:07:38.500 --> 00:07:40.210

OK, that's all.



73

00:07:40.490 --> 00:07:41.130

Thank you.

