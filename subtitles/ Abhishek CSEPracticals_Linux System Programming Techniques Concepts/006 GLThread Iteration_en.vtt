WEBVTT
1
00:00:05.570 --> 00:00:12.920
Now, next, let us discuss how will you trade or deal trade and print all the objects that is held

2
00:00:12.920 --> 00:00:18.290
by dual thread, so continuing with our same employee structure.

3
00:00:18.680 --> 00:00:26.570
Suppose we have a dual thread in which currently three employee type objects are held together by this

4
00:00:26.570 --> 00:00:27.440
giant threat.

5
00:00:29.200 --> 00:00:37.180
So our objective is to iterate over this giant thread and print each of these objects that is held by

6
00:00:37.180 --> 00:00:43.150
this giant thread, so simply we need to write a function print employee database.

7
00:00:43.360 --> 00:00:49.320
And argument to this function is actually a pointer to the first node of this real thread.

8
00:00:49.780 --> 00:00:56.500
So the argument to this function is a pointer to the first G.A., which is present in this thread.

9
00:00:58.200 --> 00:01:05.970
Now, simply, this court is pretty much obvious and it resembles exactly similar to that of the linked

10
00:01:05.970 --> 00:01:08.100
list, which you have already learned.

11
00:01:09.090 --> 00:01:16.620
The only line that makes a difference is this following line, so you can see that in this line hat

12
00:01:16.620 --> 00:01:24.510
is a pointer which points to the G.A. and in order to get a pointer to the start of the object, you

13
00:01:24.510 --> 00:01:31.100
need to subtract the offset of the G.A. from the address of the Lord.

14
00:01:31.620 --> 00:01:34.150
And this is what I am doing here.

15
00:01:35.190 --> 00:01:44.160
I have an address to the G.A. and I'm subtracting the offset of this not present in the structure so

16
00:01:44.160 --> 00:01:49.910
that I will get an address which points to the start of the object of type in play.

17
00:01:50.700 --> 00:01:58.170
So I will get the starting address and once I get a starting address, I can simply print the implied

18
00:01:58.170 --> 00:01:58.920
details.

19
00:02:00.670 --> 00:02:07.570
Right, and the rest of the implementation of this function is very much similar to that of a traditional,

20
00:02:07.570 --> 00:02:08.539
doubly linked list.

21
00:02:09.400 --> 00:02:15.060
So now you must be able to grasp the main difference between traditional, doubly linked list and Gyul

22
00:02:15.070 --> 00:02:15.580
threads.

23
00:02:16.450 --> 00:02:23.860
All the difference lies in how you obtain a pointer to the object from that list node.

24
00:02:24.490 --> 00:02:32.890
In case of traditional relentless node, you have already started a member and you simply write not

25
00:02:32.890 --> 00:02:38.320
arrow data in order to get a pointer to the object which is held by this node.

26
00:02:39.010 --> 00:02:45.460
Whereas in case of G.L. threads, you need to subtract the offset to the address of this node in order

27
00:02:45.460 --> 00:02:49.450
to get the pointer to the object that is held by the A.

28
00:02:50.620 --> 00:02:55.420
So that's the only difference between traditional, doubly linked list and real threats.

29
00:02:56.680 --> 00:03:03.340
Soon we will realize that what other benefits we will get by playing this little trick and you will

30
00:03:03.340 --> 00:03:10.090
understand that best libraries actually solves the problem with traditional libraries cannot.

