WEBVTT
1
00:00:05.260 --> 00:00:12.610
So, guys, now we are in a position that we can discuss the implementation of iterative macro to iterate

2
00:00:12.610 --> 00:00:17.080
over all the nodes of a binary tree in in order sequence.

3
00:00:17.740 --> 00:00:21.640
So you can see that following is the implementation of such a macro.

4
00:00:22.270 --> 00:00:29.110
And you can see that the approach of writing and iterative macro for binary substrate is not very different

5
00:00:29.110 --> 00:00:32.180
from the approach that we used for legalist.

6
00:00:32.820 --> 00:00:40.090
The only difference is that that in order to begin our iteration from the first node, the pointer to

7
00:00:40.090 --> 00:00:44.110
the first node is obtained using a function get left most.

8
00:00:44.770 --> 00:00:49.380
This function will return a pointer to the node number one of the binary.

9
00:00:49.390 --> 00:00:54.400
So three, right, because we need to begin our iteration from this node.

10
00:00:55.120 --> 00:01:02.260
And in order to get the pointer to the next mode of this binary tree, we have used a function get next

11
00:01:02.260 --> 00:01:03.470
in order successor.

12
00:01:04.060 --> 00:01:04.450
Right.

13
00:01:04.750 --> 00:01:09.980
So this function will return a pointer to the node number five of this binary so street.

14
00:01:10.690 --> 00:01:15.900
So in the next iteration, the node that we're going to be processed will be the node five.

15
00:01:16.900 --> 00:01:23.950
And in subsequent iteration, the nodes of this binary such tree will be processed in in the sequence.

16
00:01:24.970 --> 00:01:31.150
And of course, you need to write a complementary part of this macro which will take care to balance

17
00:01:31.150 --> 00:01:32.460
out the parentheses.

18
00:01:32.740 --> 00:01:40.600
So simply in order to make use of this macro in your application, you simply have to initialize a pointer

19
00:01:40.600 --> 00:01:48.010
which points to the node of a binary sastry and initialize this pointer to null and then make use of

20
00:01:48.010 --> 00:01:54.070
this macro as follows in order to iterate over all the nodes of a binary search tree.

21
00:01:54.790 --> 00:02:01.930
And in the body of this macro, you can do whatever processing you want to perform on a load of a binary

22
00:02:02.110 --> 00:02:02.610
stream.

23
00:02:03.070 --> 00:02:08.919
So you can see that implementation of iterative macros is nothing, but it is just a wrapper over for

24
00:02:08.919 --> 00:02:09.490
loops.

25
00:02:10.060 --> 00:02:15.790
We have learned in this section how to write iterative macros to iterate over standard data structures,

26
00:02:16.210 --> 00:02:22.000
the standard data structures that we have covered, our linked list and trees, which are the two most

27
00:02:22.000 --> 00:02:23.860
widely used data structures.

28
00:02:25.420 --> 00:02:32.750
Now let us see our macro in action so you can see that I am Entwisle to attach.

29
00:02:33.280 --> 00:02:33.750
Right?

30
00:02:34.180 --> 00:02:42.010
And in this header file I have declared the function that leftmost as well as the function get next

31
00:02:42.010 --> 00:02:43.110
in order successor.

32
00:02:43.600 --> 00:02:44.050
Right.

33
00:02:45.430 --> 00:02:52.030
And then in line number 32, I have to find the macro to iterate over a binary stream, right.

34
00:02:52.300 --> 00:02:55.360
And we have already discussed the implementation of this macro.

35
00:02:56.140 --> 00:02:59.760
Now, let me share the implementation of these two functions as well.

36
00:03:00.700 --> 00:03:06.670
If for some reason you are not able to implement the logic of these two functions, then here is the

37
00:03:06.670 --> 00:03:07.870
logic of this function.

38
00:03:08.230 --> 00:03:12.000
So the implementation of the function get left most is fairly easy.

39
00:03:12.520 --> 00:03:17.770
It should be done the first node which will encounter in the in order traversal of the binary south

40
00:03:17.770 --> 00:03:25.780
stream and the next is the implementation of a function which will return the next node in the in order

41
00:03:25.780 --> 00:03:27.470
to set up a binary sastry.

42
00:03:28.600 --> 00:03:35.200
So again, I will not discuss the implementation or the logic behind this function, but this function

43
00:03:35.200 --> 00:03:36.310
just works fine.

44
00:03:37.390 --> 00:03:42.760
And using these two functions, you can implement an iterative macro over a binary such street.

45
00:03:43.720 --> 00:03:51.580
So you can see that in the main function I am creating a binary substrate and then I'm adding values

46
00:03:51.580 --> 00:03:52.990
in this binary sastry.

47
00:03:53.380 --> 00:03:53.830
Right.

48
00:03:54.280 --> 00:04:00.850
And then I'm using our iterative macro in order to iterate over all the nodes of a binary tree.

49
00:04:01.720 --> 00:04:08.920
And simply within the body of this macro, I am simply printing the data that is carried by a load of

50
00:04:08.920 --> 00:04:10.000
a binary sastry.

51
00:04:10.390 --> 00:04:12.490
So simply I am printing the values.

52
00:04:13.060 --> 00:04:19.839
So now let us see by running this code whether we print the in order traversal of this binary Sastry

53
00:04:19.839 --> 00:04:21.010
correctly or not.

54
00:04:28.920 --> 00:04:35.150
So you can see that we are printing all the notes of a binary tree in the street, increasing order,

55
00:04:35.580 --> 00:04:41.170
we already know that in order to all of the binary Sastry, Broun's the node and the increasing order.

56
00:04:41.700 --> 00:04:44.320
So it means our macro just works fine.

57
00:04:45.210 --> 00:04:51.600
So, guys, in future, make a part of your life that you will iterate over a standard Aerostructures

58
00:04:51.870 --> 00:04:53.900
using iterative macros.

59
00:04:54.120 --> 00:05:01.500
So from now on, develop a habit of writing iterative macros in order to iterate over a standard aerostructures.

