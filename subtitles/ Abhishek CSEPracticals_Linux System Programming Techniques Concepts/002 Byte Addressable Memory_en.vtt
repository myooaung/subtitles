WEBVTT
1
00:00:05.390 --> 00:00:13.280
So, guys, going forward now, let us first understand that what our addressable memory about addressable

2
00:00:13.280 --> 00:00:18.580
memory is a memory in which every byte has an address, right.

3
00:00:18.950 --> 00:00:22.030
Such a memory is called byte addressable memory.

4
00:00:22.550 --> 00:00:24.050
So let us take an example.

5
00:00:24.800 --> 00:00:29.270
Suppose this diagram represents your physical memory, right?

6
00:00:30.540 --> 00:00:38.310
So you can see that each of this physical memory comprises of four bytes that despite zero by one,

7
00:00:38.310 --> 00:00:40.830
by two and by three, right.

8
00:00:42.180 --> 00:00:48.640
Now, you've got physical memory is about addressable memory, that is every byte has an address.

9
00:00:49.290 --> 00:00:56.460
So if the starting address of the byte zero of the physical memory is zero, then the address of the

10
00:00:56.460 --> 00:01:02.030
next byte will be one address of the next byte will be two and so on.

11
00:01:02.670 --> 00:01:03.090
Right.

12
00:01:04.019 --> 00:01:11.400
So every byte of the physical memory is has an address and therefore physical memory is called byte

13
00:01:11.400 --> 00:01:12.490
addressable memory.

14
00:01:12.930 --> 00:01:17.240
In fact, we are virtual memory is also quite addressable memory.

15
00:01:17.820 --> 00:01:25.180
So every byte has an address and you can see that the addresses are actually in continuous order.

16
00:01:25.890 --> 00:01:26.360
Right.

17
00:01:26.370 --> 00:01:31.720
That is, every consecutive bytes will have consecutive addresses and so on.

18
00:01:33.900 --> 00:01:40.080
So suppose if you have a point at which point to some memory location, let's say that pizza ad is a

19
00:01:40.080 --> 00:01:43.140
pointer and this pointer points to this address.

20
00:01:44.070 --> 00:01:44.480
Right.

21
00:01:45.720 --> 00:01:48.700
Let's say that this address represents sixty five.

22
00:01:49.500 --> 00:01:55.350
Now, if you increment this pointer value, it means that this pointer will now start pointing to the

23
00:01:55.350 --> 00:01:57.690
next byte in the physical memory.

24
00:01:59.190 --> 00:02:04.730
So this pointer will start point to the byte number six to six in the physical memory.

25
00:02:05.700 --> 00:02:10.110
So byte is the lowest unit of memory that can be accessed.

26
00:02:10.440 --> 00:02:10.800
Right.

27
00:02:11.250 --> 00:02:18.300
So that is why we need to perform boolean operations in order to manipulate memory at a better level.

28
00:02:19.170 --> 00:02:26.530
So note that in your C program or in any programming language, you do not have a data type which represents

29
00:02:26.530 --> 00:02:26.940
a bit.

30
00:02:27.420 --> 00:02:27.870
Right.

31
00:02:29.120 --> 00:02:36.290
There is no data type Colbert in any programming language, so the shortest data type that is available

32
00:02:36.290 --> 00:02:40.430
is byte in C or any other programming language, right.

33
00:02:40.790 --> 00:02:43.890
In fact, in C, we have a shortened data type called car.

34
00:02:45.020 --> 00:02:51.440
So it means that using primitive data types of a programming language, the smallest unit of memory

35
00:02:51.440 --> 00:02:53.710
that you can access is a bite.

36
00:02:54.620 --> 00:03:01.910
And whenever there is a scenario that you need to access or manipulate a particular bit present somewhere

37
00:03:01.910 --> 00:03:08.990
in your physical or virtual memory, then you need to apply boolean operations such as and or not,

38
00:03:09.440 --> 00:03:09.860
right.

39
00:03:11.310 --> 00:03:18.150
So it is for this reason, because your memory is Pythagoras's memory, there are no data types Colbert

40
00:03:18.150 --> 00:03:23.370
in the programming language and hence you cannot access memory at that level.

41
00:03:24.540 --> 00:03:31.230
So the conclusion is that our physical and virtual memory are by traversable memory and every byte has

42
00:03:31.230 --> 00:03:32.010
an address.

43
00:03:33.190 --> 00:03:40.360
So when we say that suppose this physical memory is for Jimmy Incise, let's say your computer has a

44
00:03:40.360 --> 00:03:46.840
physical memory ram which has a size of four GUI now convert this four GB into bytes.

45
00:03:46.840 --> 00:03:50.320
You will get to restore the power to 32 bytes.

46
00:03:50.830 --> 00:03:52.900
Now, every byte has an address.

47
00:03:53.200 --> 00:04:01.810
It means that your chip has to raise to the power 32 memory locations or memory addresses.

48
00:04:02.980 --> 00:04:08.230
Now the question is that what will be the address of the last bite of your physical memory?

49
00:04:08.800 --> 00:04:14.220
The address of the last bite of the physical memory will be to restore the power 30 to minus one.

50
00:04:15.250 --> 00:04:15.650
Right.

51
00:04:16.720 --> 00:04:22.930
So if you have a fauji behram that the address of the last bite of this 40 Behram will be to restore

52
00:04:22.930 --> 00:04:24.550
the power it to minus one.

53
00:04:25.680 --> 00:04:31.950
And remember, addresses are nothing, but these are just numerical indexes, which represents a particular

54
00:04:31.950 --> 00:04:33.870
location of a bite.

55
00:04:34.960 --> 00:04:35.800
In a memory.

