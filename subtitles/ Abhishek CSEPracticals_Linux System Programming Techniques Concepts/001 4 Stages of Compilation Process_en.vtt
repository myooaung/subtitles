WEBVTT
1
00:00:06.680 --> 00:00:08.270
So, guys, welcome back.

2
00:00:08.510 --> 00:00:14.210
This section of the course is dedicated to learning for stages of the compilation of a program.

3
00:00:14.660 --> 00:00:19.330
This is a very bad interview question and one of the most commonly asked questions.

4
00:00:20.180 --> 00:00:25.880
So let us see in detail that what are the four stages that are involved in the compilation process of

5
00:00:25.880 --> 00:00:26.540
a program?

6
00:00:27.290 --> 00:00:33.980
So you can see on the screen the four stages which are involved in the complete completion of a process

7
00:00:33.980 --> 00:00:41.400
from beginning to end is the pre processing stage, then completion stage, followed by the assembler

8
00:00:41.420 --> 00:00:42.050
stage.

9
00:00:42.290 --> 00:00:46.580
And then last stage of the completion process is the linking stage.

10
00:00:47.510 --> 00:00:54.290
So let us first discuss each of these stages briefly, then I will show you the demonstration, how

11
00:00:54.290 --> 00:00:59.270
a given program can be compiled stage by stage and we will see that.

12
00:00:59.270 --> 00:01:05.260
What are the changes in the program takes place as the program compiles to these stages.

13
00:01:05.930 --> 00:01:10.690
So the very first stage of the compilation process is the pre processing stage.

14
00:01:11.420 --> 00:01:18.020
The program that you write by your own hand and Ed is an input to the pre processing stage.

15
00:01:20.180 --> 00:01:27.380
So in preprocessing stage, mainly, the tax substitution is done and the preprocessing directives are

16
00:01:27.380 --> 00:01:28.240
executed.

17
00:01:29.380 --> 00:01:34.960
Now, what are preprocessing directives, all the statements in your program, which starts with the

18
00:01:34.960 --> 00:01:42.880
hash, are called preprocessing directives, for example, hash include has defined hash if defined,

19
00:01:42.880 --> 00:01:43.720
etc..

20
00:01:45.290 --> 00:01:50.240
We have already discussed the tech substitution in pretty much detail in the beginning section of the

21
00:01:50.240 --> 00:01:50.840
scores.

22
00:01:53.250 --> 00:01:59.760
That once the preprocessing of the program is done, the resultant program is actually fitted to another

23
00:01:59.760 --> 00:02:04.170
component of the compiler, which is actually called COMPILER.

24
00:02:06.680 --> 00:02:13.400
So not that technically speaking, the completion process is the second stage of a competition process

25
00:02:13.790 --> 00:02:20.170
in our day to day life, we usually call all these four stages collectively as a compilation.

26
00:02:20.540 --> 00:02:26.180
But technically speaking, the compilation is actually the second stage of completion process.

27
00:02:28.960 --> 00:02:36.700
So you can see that to the completion process, the input is the tax substituted C-code and the compiler

28
00:02:36.700 --> 00:02:39.640
generates an assembly code as an output.

29
00:02:40.730 --> 00:02:46.970
So assembly is a programming language, and it is the compiler which takes an input that substituted,

30
00:02:46.970 --> 00:02:52.130
scored, and in turn it generates an assembly code, right?

31
00:02:53.780 --> 00:02:59.810
This assembly code is equivalent in functionality to the tax substituted C code, which was fitted to

32
00:02:59.810 --> 00:03:06.980
this compiler, then this assembly code, which is generated by the compiler, is Lanfredi to the third

33
00:03:06.980 --> 00:03:09.650
component of the compiler called Assembler.

34
00:03:10.700 --> 00:03:17.330
So assembler is that component of the compiler, which takes an input to the assembly code and produces

35
00:03:17.330 --> 00:03:19.490
the machine code or binary code.

36
00:03:20.540 --> 00:03:27.200
Now once you have a compile code, compile calls me your dot, all files, that is object files.

37
00:03:27.620 --> 00:03:32.570
If there are more than one object files, then all of these object files can be.

38
00:03:34.680 --> 00:03:38.330
Grouped together in order to form a library, right?

39
00:03:38.700 --> 00:03:44.160
We have already learned that library is nothing, but it is a collection of object files and other object

40
00:03:44.160 --> 00:03:44.580
files.

41
00:03:44.580 --> 00:03:49.860
Object files are nothing, but they are compiled machine code or binary code, which is produced by

42
00:03:49.860 --> 00:03:50.600
the assembler.

43
00:03:51.240 --> 00:03:58.530
And the second option is that that if you do not want to reduce your program into a library, then you

44
00:03:58.530 --> 00:04:05.270
must object to your program, to the linking process and finally produce an executable.

45
00:04:06.060 --> 00:04:12.360
But your program can be subjected to the linking process only under one condition that your program

46
00:04:12.360 --> 00:04:14.220
must have a main function.

47
00:04:15.510 --> 00:04:20.880
Unless you are programmed to not have a main function, it cannot be subjected to linking.

48
00:04:21.910 --> 00:04:28.930
So linking is a process of creating an executable from the compiled machine called our Object Files.

49
00:04:30.780 --> 00:04:37.050
Now, you must have understood why I am calling executable executable is a program which is compiled

50
00:04:37.050 --> 00:04:44.340
already and can execute on a processor, and we know that for a program to execute on a processor,

51
00:04:44.610 --> 00:04:46.890
the program should have a main function.

52
00:04:48.180 --> 00:04:48.620
Right.

53
00:04:50.880 --> 00:04:57.990
So linking is a process of translating the object files of the group of object files together to form

54
00:04:57.990 --> 00:05:02.190
a final executable which can execute on the processing.

55
00:05:04.190 --> 00:05:11.030
So not that the preprocessor the compiler, assembler and Linko are generally together tromped as compiler

56
00:05:11.030 --> 00:05:12.170
only, right?

57
00:05:13.060 --> 00:05:19.360
So these are the four stages of the compilation process beginning from the preprocessing stage up to

58
00:05:19.360 --> 00:05:24.760
the linking stage, and you should remember the sequence of these stages, not only that, for each

59
00:05:24.760 --> 00:05:30.850
stage, you should remember that what is the input to that stage and what that particular stage produces?

60
00:05:30.850 --> 00:05:31.720
An output.

61
00:05:32.320 --> 00:05:39.490
So remember these kind of a flow chart and remember that if you want to create a library, a library

62
00:05:39.490 --> 00:05:40.000
is nothing.

63
00:05:40.000 --> 00:05:43.690
But it is a bunch of object files put together.

64
00:05:43.870 --> 00:05:44.300
Right.

65
00:05:44.500 --> 00:05:50.260
And in order to create a library, you are programmed to not have to go through the lengthy process.

66
00:05:50.530 --> 00:05:56.630
But in order to create a final executable, your program has to go through the linking process.

67
00:05:57.670 --> 00:06:03.460
Now, next, we will take a sample program and we will subject that program step by step to each of

68
00:06:03.460 --> 00:06:08.620
these four stages of the completion process and actually see the things in action.

69
00:06:14.250 --> 00:06:14.480
And.

