WEBVTT
1
00:00:07.160 --> 00:00:08.660
So welcome back, guys.

2
00:00:08.870 --> 00:00:14.270
Now, in this lecture, we will be going to discuss the concept of shared physical pages.

3
00:00:15.900 --> 00:00:23.460
A shared physical page is a physical page, which is shared by two or more running processes on the

4
00:00:23.460 --> 00:00:31.860
system, a physical page is set to be shared if it is present in page tables of two or more than two

5
00:00:31.860 --> 00:00:32.659
processes.

6
00:00:33.750 --> 00:00:40.770
So concept of shared physical page actually allows multiple processes running on the system to read

7
00:00:40.770 --> 00:00:44.410
and write into the same physical memory portion.

8
00:00:45.570 --> 00:00:50.310
We will see how concept of shared physical pages makes this possible.

9
00:00:51.510 --> 00:00:56.080
So let us start to understand the concept of shared physical pages with the help of an example.

10
00:00:56.700 --> 00:01:02.910
So, for example, we will continue with the same configuration of the system which we discussed while

11
00:01:03.060 --> 00:01:04.950
discussing the concept of paging.

12
00:01:05.640 --> 00:01:07.910
So following is the configuration of the system.

13
00:01:08.160 --> 00:01:10.880
It is the same configuration which were discussed before.

14
00:01:11.940 --> 00:01:19.530
So you can see that the virtual address comprises all four bits and it is decomposed into two parts

15
00:01:19.530 --> 00:01:20.850
of two bits each.

16
00:01:22.720 --> 00:01:25.540
So please go through this configuration once again.

17
00:01:25.570 --> 00:01:32.230
Now, you must be familiar what exactly this configuration means and what is the information you can

18
00:01:32.230 --> 00:01:34.450
infer from this configuration?

19
00:01:36.040 --> 00:01:43.930
So going forward, so in our example, we have two processes that is process P1 and P2 running simultaneously

20
00:01:43.930 --> 00:01:44.590
on the system.

21
00:01:45.400 --> 00:01:52.180
On the right hand side is the snapshot of the physical memory and as part the configuration.

22
00:01:52.180 --> 00:01:55.090
Physical memory is fragmented into eight frames.

23
00:01:56.130 --> 00:01:59.520
And of course, the size of each frame is four bytes.

24
00:02:00.650 --> 00:02:07.670
Now, consider following is the snapshot of the peace tables of the two processes, you can see that

25
00:02:07.670 --> 00:02:11.560
there is a slight modification in the page tables of the two process.

26
00:02:12.110 --> 00:02:17.990
You can see that there is a physical page, right, corresponding to the virtual page two in the page

27
00:02:17.990 --> 00:02:19.340
stable of process one.

28
00:02:20.390 --> 00:02:26.000
Similarly, there is the same physical page write corresponding to the virtual page number three in

29
00:02:26.000 --> 00:02:27.770
the table of process two.

30
00:02:28.790 --> 00:02:35.080
So it means that there is same physical page entry in the table of the two processes.

31
00:02:35.900 --> 00:02:44.180
And of course, this physical page why is loaded in frame number one, that as you can see that in this

32
00:02:44.180 --> 00:02:48.710
frame, number one of physical memory, the physical page Y is loaded.

33
00:02:50.070 --> 00:02:56.940
So now the question is that how can you insert the same physical page into the page tables of multiple

34
00:02:56.940 --> 00:03:05.170
process now put Linux or Unix operating system allows that using a special system called called a map,

35
00:03:05.880 --> 00:03:09.740
we will discuss the design and concept behind this system call.

36
00:03:10.470 --> 00:03:17.670
But for now, just understand that we have a physical page entry present in the table of the process.

37
00:03:18.690 --> 00:03:25.740
Now suppose the process P1 during the course of its execution generates a virtual address one zero zero

38
00:03:25.740 --> 00:03:28.830
one, which is actually nine.

39
00:03:29.430 --> 00:03:29.850
Right.

40
00:03:30.450 --> 00:03:37.890
And process P2 during the course of its execution generates a virtual address 13 whose binary equivalent

41
00:03:37.890 --> 00:03:39.150
is one one zero one.

42
00:03:41.160 --> 00:03:45.730
Now, we know that the composition of this virtual address is to buy two seats.

43
00:03:46.350 --> 00:03:51.120
So first of bytes are used to locate the virtual page, no underpaid, stable.

44
00:03:52.490 --> 00:04:00.980
So you can see that all that was generated by the process BE1 maps to the virtual page number two and

45
00:04:00.980 --> 00:04:06.050
this virtual page number two, maps to the physical space number Y, which is loaded in frame one and

46
00:04:06.050 --> 00:04:06.980
physical memory.

47
00:04:07.970 --> 00:04:14.810
Similarly, in case of process, prior to the first two bits of virtual address maps to the virtual

48
00:04:14.810 --> 00:04:21.410
page number three in the peace table, which maps to the physical space number y loaded and frame one

49
00:04:21.410 --> 00:04:22.490
in physical memory.

50
00:04:24.370 --> 00:04:31.240
So the output of look up into the page tables of the true process using the first two bits of virtual

51
00:04:31.240 --> 00:04:33.230
address is frame one.

52
00:04:34.390 --> 00:04:40.270
Now, the second part of the virtual address is zero one in case of process B one.

53
00:04:40.930 --> 00:04:45.940
And the second part of what that does is, again, zero one in case of process P2.

54
00:04:47.290 --> 00:04:52.530
Now we know that the second part of the virtual address represents an offset, right?

55
00:04:53.110 --> 00:04:54.640
So the offset is one.

56
00:04:55.810 --> 00:05:03.760
So you can see that the virtual address nine and what that 13 generated by the process be one and people

57
00:05:04.060 --> 00:05:07.540
maps to the physical address, five in the main memory.

58
00:05:08.640 --> 00:05:15.120
Now, you already know how Beijing works, so you know the science behind how we reach to the physical

59
00:05:15.120 --> 00:05:23.400
address five of main memory so you can see that process be won by generating a virtual does nine maps

60
00:05:23.400 --> 00:05:30.900
to the physical Atlas five and process petabytes and rating of plus 13 again, maps to the same physical

61
00:05:30.900 --> 00:05:32.760
Atlas five in the main memory.

62
00:05:33.480 --> 00:05:34.920
So what does that mean?

63
00:05:35.790 --> 00:05:42.420
It simply means that process P1 and P2 are accessing the same physical memory location whose address

64
00:05:42.420 --> 00:05:43.230
is five.

65
00:05:45.860 --> 00:05:53.150
It simply means that whatever be won right at physical, at those five modification will be available

66
00:05:53.150 --> 00:06:00.350
to process, but also it simply means that process be won and people are sharing the same physical memory

67
00:06:00.350 --> 00:06:08.510
page in frame F1, subframe F1 is that portion of that physical memory which the process we want and

68
00:06:08.510 --> 00:06:11.270
people can read and write simultaneously.

69
00:06:12.640 --> 00:06:20.650
So if Process B one executes the following statement, right, so at that does nine, process B, one

70
00:06:20.650 --> 00:06:23.050
is writing a string of land for.

71
00:06:25.190 --> 00:06:33.260
Now, after the execution of this statement, if process be to execute the following statement in which

72
00:06:33.260 --> 00:06:41.000
the SDR is a pointer which points to the that address 13 of process, Pitou, then the output of this

73
00:06:41.000 --> 00:06:43.430
print statement will be held.

74
00:06:43.580 --> 00:06:47.420
That is the same string which was written by the process P1.

75
00:06:49.090 --> 00:06:56.200
So it simply means that whatever modification the process B one does in physical pays, no Y which is

76
00:06:56.200 --> 00:07:01.390
loaded in frame F one, those modifications will be available to the process.

77
00:07:01.390 --> 00:07:05.380
But also so in a way, you can see that process.

78
00:07:05.380 --> 00:07:13.000
P1 and P2 are actually exchanging data with each other using the concept of shared physical memory.

79
00:07:13.930 --> 00:07:22.360
So now let us try to look at the broader perspective that what we have actually achieved by inserting

80
00:07:22.360 --> 00:07:28.420
the same physical page, which is based numberi in the past table of multiple processes.

81
00:07:29.290 --> 00:07:35.320
So going forward in this diagram you can see that we have three processes running simultaneously on

82
00:07:35.320 --> 00:07:42.070
the system and we have some physical page RHI, which is loaded in the best table of all these three

83
00:07:42.070 --> 00:07:42.830
processes.

84
00:07:43.630 --> 00:07:45.880
So if processed P1 right.

85
00:07:45.880 --> 00:07:53.410
And the content or data in this physical memory, the modification that is done by the process, P1

86
00:07:53.740 --> 00:07:58.570
will be available or visible to both the processes, P2 and P3.

87
00:07:59.750 --> 00:08:08.540
So it means that BE1 is able to communicate its data to process people and process Putri using shared

88
00:08:08.540 --> 00:08:09.410
memory region.

89
00:08:10.870 --> 00:08:17.980
Similarly, a process to write anything in this region than those modifications will be available to

90
00:08:17.980 --> 00:08:20.620
the process P1 and process Putri also.

91
00:08:21.640 --> 00:08:29.520
So this is the shared memory and goal by loading a same physical page into page tables of multiple processes,

92
00:08:30.040 --> 00:08:36.850
we have actually achieved a mechanism to facilitate data exchange between the processes running on the

93
00:08:36.850 --> 00:08:37.630
same system.

94
00:08:38.799 --> 00:08:47.170
This mechanism of data exchange between processors running on the same machine is formally called as

95
00:08:47.350 --> 00:08:51.040
the entire process communication through shared memory.

96
00:08:52.450 --> 00:08:55.340
So now let us have a summary on shared pages.

97
00:08:56.080 --> 00:09:02.980
So if virtual page of multiple process maps to the same physical page, that particular physical page

98
00:09:02.980 --> 00:09:09.970
is shared by multiple processors, Linux or Unix operating system officially calls this concept as shared

99
00:09:09.970 --> 00:09:10.450
memory.

100
00:09:11.470 --> 00:09:18.760
Social memory is one of the enterprises communication technique that is supported by Linux or Unix like

101
00:09:18.760 --> 00:09:19.630
operating system.

102
00:09:20.920 --> 00:09:27.160
Linux or Unix like operating system provides a system called and I have already told you that that system

103
00:09:27.160 --> 00:09:30.050
call is AMAP, right?

104
00:09:30.730 --> 00:09:34.360
We will discuss the science behind the system called later in discourse.

105
00:09:35.170 --> 00:09:42.280
So Linux operating system provide a system called which allow multiple process to create shared memory

106
00:09:42.280 --> 00:09:44.960
region and exchange data through it.

107
00:09:46.090 --> 00:09:48.700
So we have learned the concept behind shared memory.

108
00:09:48.940 --> 00:09:56.590
We shall learned later how to write programs which would support data exchange with multiple processors

109
00:09:56.590 --> 00:09:59.500
running on the same machine using shared memory.

