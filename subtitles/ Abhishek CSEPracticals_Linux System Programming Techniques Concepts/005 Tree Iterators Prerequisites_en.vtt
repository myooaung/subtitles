WEBVTT
1
00:00:05.450 --> 00:00:06.980
So, guys, going forward.

2
00:00:07.400 --> 00:00:14.060
So now let's discuss the approach to implement an iterative macro to iterate over binary Sastry.

3
00:00:14.720 --> 00:00:19.820
So in order to implement a macro first, we need to write to prerequisite functions.

4
00:00:20.660 --> 00:00:23.360
The first function is get leftmost.

5
00:00:23.900 --> 00:00:29.210
The input to this function is a pointer to the root of the tree and this function returns.

6
00:00:30.950 --> 00:00:38.300
A pointer to the node of a tree and the second function that you need to write is get next in order

7
00:00:38.300 --> 00:00:38.960
successor.

8
00:00:39.770 --> 00:00:46.360
So this function will take an input, a pointer to some node in a binary search tree.

9
00:00:46.670 --> 00:00:49.730
And this node could be any node in the binary substrate.

10
00:00:50.150 --> 00:00:56.780
And the return value of dysfunction is appointed to the node, which is an end or the successor of the

11
00:00:56.780 --> 00:00:59.480
node that you passed as an argument to this function.

12
00:01:00.230 --> 00:01:06.020
So basically this function returns the next in order successor of our node, which you parsed as an

13
00:01:06.020 --> 00:01:07.390
argument to dysfunction.

14
00:01:07.850 --> 00:01:12.030
So you can see in the example on the right hand side, we have a simple binary such tree.

15
00:01:12.350 --> 00:01:19.760
So if you walk over this binary tree in an in order sequence, what will be the order of traversal of

16
00:01:19.760 --> 00:01:21.460
nodes of this binary Sastry?

17
00:01:22.160 --> 00:01:28.340
Of course, the first node that you will visit is the number one cellular function that is get left.

18
00:01:28.340 --> 00:01:34.610
Maust is a function which will return the first node and in order traversal of a binary sastry.

19
00:01:35.390 --> 00:01:41.120
So this function should actually return a pointer to the node number one of this binary such tree.

20
00:01:41.900 --> 00:01:46.910
Right, because this node is the first node in in order of a binary such tree.

21
00:01:47.630 --> 00:01:52.790
Now if you invoke the second function, that is cat next in order successor.

22
00:01:53.240 --> 00:02:00.510
And if you pass a pointer to the node number one of this binary tree, then this function that is get

23
00:02:00.530 --> 00:02:06.860
next in the successor should return a pointer to the node number five of this binary says Tree.

24
00:02:07.550 --> 00:02:07.930
Right.

25
00:02:08.570 --> 00:02:15.680
Similarly, again, if you invoke this function on a node five, then this function should return node

26
00:02:15.680 --> 00:02:19.370
number seven of this binary search street and so on.

27
00:02:19.790 --> 00:02:20.150
Right.

28
00:02:21.020 --> 00:02:24.210
So this is the in order traversal of the binary s stream.

29
00:02:25.430 --> 00:02:30.080
So again, it is my expectation that you know how to implement above two functions.

30
00:02:30.590 --> 00:02:32.780
This is not a data structure course.

31
00:02:32.780 --> 00:02:33.680
I'm sorry.

32
00:02:33.950 --> 00:02:38.240
Henceforth, I assume that you have correctly implemented the above two functions.

33
00:02:38.870 --> 00:02:45.050
So in order to write a macro that will iterate over this binary size three, you need to implement these

34
00:02:45.050 --> 00:02:46.370
two functions first.

35
00:02:47.060 --> 00:02:47.470
Right?

36
00:02:48.540 --> 00:02:53.970
So, of course, I will going to share the implementation of these two functions, but I will not discuss

37
00:02:54.150 --> 00:03:00.000
the logic behind implementation of these two functions because its discussion will be out of the scope

38
00:03:00.000 --> 00:03:00.910
of discourse.

39
00:03:01.740 --> 00:03:03.470
So navigate to this directly.

40
00:03:03.480 --> 00:03:10.860
That is library designing iterative macros and see the solution and treat Ã–tzi and treat attach.

41
00:03:11.370 --> 00:03:12.410
In these files.

42
00:03:12.420 --> 00:03:20.670
I have implemented a sample code to create a binary sastry and an iterative macro to walk over this

43
00:03:20.670 --> 00:03:23.580
binary sastry using these two functions.

44
00:03:24.720 --> 00:03:31.170
So now let us discuss in the next slide that how you will going to write an iterative macro provided

45
00:03:31.170 --> 00:03:34.590
that you already have the implementation of these two functions.

