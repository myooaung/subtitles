WEBVTT
1
00:00:05.530 --> 00:00:13.030
So, guys, now let us try to understand that CPU generates only virtual addresses while executing your

2
00:00:13.030 --> 00:00:13.690
program.

3
00:00:14.830 --> 00:00:19.090
So variables in the programs are just symbolic names of addresses.

4
00:00:19.390 --> 00:00:19.810
Right.

5
00:00:20.170 --> 00:00:25.570
So you must have written a program and that particular program, you must have defined certain variables

6
00:00:26.050 --> 00:00:30.220
like variable and A and B and C are in many others.

7
00:00:31.390 --> 00:00:36.490
So those variables and the programs are just symbolic names of addresses.

8
00:00:37.150 --> 00:00:45.070
Variables are there for our convenience so that we can read and write computer instructions and human

9
00:00:45.070 --> 00:00:46.080
readable format.

10
00:00:46.450 --> 00:00:46.870
Right.

11
00:00:48.200 --> 00:00:56.270
Can you imagine the situation that instead of using variable names, we had to use Darroch memory locations

12
00:00:56.270 --> 00:01:03.230
or addresses in order to save our value, how horrible our program would have been look like, in fact,

13
00:01:03.230 --> 00:01:08.400
we would not be able to recognize already short program only after a few minutes.

14
00:01:08.420 --> 00:01:09.940
You have written right.

15
00:01:10.400 --> 00:01:13.130
So variables are there for our convenience.

16
00:01:14.210 --> 00:01:22.100
At the lowest level, programs are translated into machine code, which only deals with virtual addresses.

17
00:01:23.210 --> 00:01:26.720
The machine code do not deal with variable names.

18
00:01:26.870 --> 00:01:34.220
Write machine code is not aware of variable name like in A, B or C or any other variable name.

19
00:01:34.760 --> 00:01:40.640
Variable names are replaced by their actual virtual address locations in the machine code.

20
00:01:41.540 --> 00:01:48.800
So your program translates into machine code after compilation in machine code, vegetables are replaced

21
00:01:48.800 --> 00:01:56.240
by their actual virtual addresses machine code then execute and perform, read and write operations

22
00:01:56.240 --> 00:02:00.530
using addresses of variables instead of variable names.

23
00:02:01.040 --> 00:02:01.380
Right.

24
00:02:01.820 --> 00:02:08.810
So just to take an example, suppose in your program you have a variable E and inside that variable

25
00:02:08.810 --> 00:02:10.389
you are storing value 10.

26
00:02:11.030 --> 00:02:11.380
Right?

27
00:02:11.870 --> 00:02:16.470
So this instruction after compilation would look something like this.

28
00:02:17.090 --> 00:02:22.370
Now, this piece of instruction is actually a code of assembly language.

29
00:02:23.150 --> 00:02:27.910
I cannot write machine code directly because machine code is all binary.

30
00:02:28.490 --> 00:02:33.680
So assembly code is actually that piece of code which is closest to the machine code.

31
00:02:35.390 --> 00:02:40.820
And therefore, I have written here the assembly code, which is equivalent to this line of instruction

32
00:02:40.820 --> 00:02:48.470
of your high level program, so you can see that this piece of code actually talks about only in terms

33
00:02:48.470 --> 00:02:49.580
of addresses.

34
00:02:50.150 --> 00:02:53.550
That is no variable name is used in this instruction.

35
00:02:54.740 --> 00:03:01.850
Now, SBP is a base pointer register and you will understand this instruction only if you had gone through

36
00:03:01.850 --> 00:03:05.630
the stack memory section of the schools thoroughly.

37
00:03:07.250 --> 00:03:10.420
We were going to do a little recap in the next slide.

38
00:03:11.180 --> 00:03:18.380
So Machine Code is not aware of any variable name like in A and to be exact, Robert, you have used

39
00:03:18.380 --> 00:03:20.570
everywhere in your high level program.

40
00:03:21.620 --> 00:03:28.300
We have already learned that all local variables, an argument of a function are accessed by C.P.U,

41
00:03:28.340 --> 00:03:33.200
by adding or subtracting to this point a register of the current stack frame.

42
00:03:33.770 --> 00:03:34.240
Right.

43
00:03:35.320 --> 00:03:41.920
Now, I want you to recall the usage of bears point to register when we were discussing the stark memory

44
00:03:41.920 --> 00:03:44.620
management in the previous section of this course.

45
00:03:45.160 --> 00:03:52.480
So let us do a little recap in the next slide and try to understand that when you execute your program,

46
00:03:52.750 --> 00:03:59.950
it references every variable of your program using virtual addresses instead of using symbolic names.

47
00:04:11.550 --> 00:04:14.380
So, guys, now let us do a little recap.

48
00:04:14.820 --> 00:04:17.140
This is like must be familiar to you.

49
00:04:17.670 --> 00:04:21.740
We discussed this last night when we were discussing Stack Memory Management.

50
00:04:22.260 --> 00:04:22.620
Right.

51
00:04:23.100 --> 00:04:30.730
So in this slide, you have a program on the left hand side and this program is actually executing in

52
00:04:30.770 --> 00:04:33.050
its function a right.

53
00:04:33.450 --> 00:04:41.160
So because the function is currently in execution, therefore static memory contains that static frame

54
00:04:41.490 --> 00:04:44.880
corresponding to the function on the top of stack.

55
00:04:46.420 --> 00:04:49.750
So you can see that this is a stark frame of the function.

56
00:04:50.920 --> 00:04:56.090
Now I expect you that you already know that how this stack frame was built.

57
00:04:57.130 --> 00:05:04.060
So the point that I'm trying to emphasize and this is light, is this point that is best point.

58
00:05:04.060 --> 00:05:11.530
The registered value is used by the processor to reference arguments and local variables of the current

59
00:05:11.530 --> 00:05:13.200
stack in execution.

60
00:05:13.690 --> 00:05:13.990
Right.

61
00:05:14.620 --> 00:05:21.340
So you can see that as part of this diagram, the value of base pointer register is the following address.

62
00:05:22.510 --> 00:05:27.410
Now for simplicity, let us assume that this represents hundred, right?

63
00:05:28.000 --> 00:05:34.450
So if the processor wants to access the variable D now, B is a local variable of the function.

64
00:05:34.450 --> 00:05:36.090
E, right.

65
00:05:36.730 --> 00:05:42.940
So if the processor wants to access and perform, read or write operation on the variable D, the processor

66
00:05:42.940 --> 00:05:45.110
will generate an address 96.

67
00:05:45.610 --> 00:05:45.980
Right.

68
00:05:46.630 --> 00:05:51.140
The addresses are generated in related to the base point, the registered value.

69
00:05:51.580 --> 00:05:58.350
Now the best pointers to value, for example, contains 100 or so hundred minus four means 96.

70
00:05:58.780 --> 00:06:03.040
So 96 in this example will be the virtual address of the variable.

71
00:06:05.040 --> 00:06:11.880
Similarly, if the processor wants to access variable C, it will generate an address ninety-two right,

72
00:06:12.420 --> 00:06:16.990
similarly to access the variable, A, the processor will generate a virtual address.

73
00:06:17.010 --> 00:06:17.940
Hundred and eight.

74
00:06:18.180 --> 00:06:22.540
And to access the variable B, the processor will generate a virtual address.

75
00:06:22.580 --> 00:06:22.980
Hundred and.

76
00:06:24.210 --> 00:06:31.200
So the point I'm trying to make here is that that whenever a processor executes our program and during

77
00:06:31.200 --> 00:06:37.740
the course of execution of the program, if the CPU or processor wants to perform, read or write operation

78
00:06:37.740 --> 00:06:45.450
on your Redoubles processor issues or generates virtual address of those wearables, processor is not

79
00:06:45.450 --> 00:06:47.090
aware of the symbolic names.

80
00:06:47.100 --> 00:06:50.360
That is DC or B, right.

81
00:06:51.480 --> 00:06:58.110
So going forward, seepages millions of virtual addresses during the course of execution of a process

82
00:06:58.740 --> 00:06:59.700
that is generated.

83
00:06:59.700 --> 00:07:07.590
Virtual addresses are then mapped to corresponding physical address by AMMU using a concept called Paging

84
00:07:07.950 --> 00:07:08.300
Right.

85
00:07:08.700 --> 00:07:12.150
So we are about to dive deep into the concept of paging.

86
00:07:12.390 --> 00:07:15.600
We are in the process of building basics.

87
00:07:16.380 --> 00:07:22.770
C.P.U then issued the instruction to either read or write the data on the mapped physical addresses.

88
00:07:23.400 --> 00:07:28.230
Now let us understand the entire picture in totality on the next slide.

