WEBVTT
1
00:00:05.220 --> 00:00:11.970
So, guys, you can download all the codes which are related to G.L. threads from this, you are all

2
00:00:12.540 --> 00:00:13.570
in this directory.

3
00:00:13.570 --> 00:00:21.460
You will find four files that will try to attach jail to see which implements the functionality of jail.

4
00:00:21.480 --> 00:00:29.190
Threads that may not see is a file would simulate as application which demonstrate how to make use of

5
00:00:29.190 --> 00:00:30.030
the entrance.

6
00:00:30.450 --> 00:00:36.420
And then you have a make file which is used to compile your application as well as trial threads.

7
00:00:37.020 --> 00:00:42.300
So now let us have a quick look and discuss the implementation of G.L. threads.

8
00:00:44.570 --> 00:00:51.530
So, guys, you can see that I have opened the file will to attach, right, so it is a header file

9
00:00:51.530 --> 00:00:54.590
which contains the definition related to GM threats.

10
00:00:55.250 --> 00:01:00.710
So you can see that have different the structure Gyul thread load, which contains only left and right

11
00:01:00.710 --> 00:01:01.320
pointer.

12
00:01:01.850 --> 00:01:03.470
There is no way to start date.

13
00:01:03.470 --> 00:01:05.239
Remember, industrial not.

14
00:01:06.110 --> 00:01:12.160
And then I defined the structure which actually represent the dual threat itself that does list.

15
00:01:12.770 --> 00:01:19.760
So list have a head which points to the first node present in a dual thread and the second member in

16
00:01:19.760 --> 00:01:21.270
the list is the offset.

17
00:01:21.860 --> 00:01:23.360
Now we already know that.

18
00:01:23.360 --> 00:01:25.440
What is the use of this offset?

19
00:01:26.150 --> 00:01:29.660
Then I have declared two basic functions over dual threats.

20
00:01:30.230 --> 00:01:38.090
The dual threat and NGL threat remove the threat and is used to insert a new node which is parsed as

21
00:01:38.090 --> 00:01:42.920
a second argument to a joint thread which is parsed as a first argument.

22
00:01:43.850 --> 00:01:50.750
Similarly, the remove is used to remove the GM node, which is parsed as a second argument to dysfunction

23
00:01:51.050 --> 00:01:55.130
from the GM threat list, which is passed as a first argument to this function.

24
00:01:56.090 --> 00:01:58.430
Now you already know how to write it.

25
00:01:58.690 --> 00:02:07.160
Macros, GM threads are no exception and you must know how to write iterative macros for dual threads.

26
00:02:08.120 --> 00:02:13.990
Now, since we have already discussed how to write iterative macros in sufficient detail, I expect

27
00:02:14.000 --> 00:02:18.380
you that you understand how this iterative macro rug's.

28
00:02:19.960 --> 00:02:27.460
And we also have another macro called offset, of which we have already disclosed it is used to find

29
00:02:27.460 --> 00:02:33.850
the offset of a field present in the structure, which is passed as a first time to this macro.

30
00:02:35.010 --> 00:02:40.830
Now, on the right hand side, I have the implementation of functions which are declared in the header

31
00:02:40.830 --> 00:02:48.570
file for trial threads, so the file on my right hand side is actually thread Nazi source file.

32
00:02:49.210 --> 00:02:56.160
And you can see that here is the implementation of geostrategy function and the implementation of G.L.

33
00:02:56.160 --> 00:02:57.450
tried to move function.

34
00:02:58.110 --> 00:02:58.520
Right.

35
00:02:59.280 --> 00:03:06.750
So I leave it to you, to your analysis that you must go through this implementation of red dot seesaws

36
00:03:06.750 --> 00:03:13.620
file, or in fact, it will be better that you implement your own dual track libretti and implement

37
00:03:13.620 --> 00:03:16.090
basic functions for Gyul threads.

38
00:03:17.430 --> 00:03:23.730
So take the source code as a reference to help you out to write your own jail library.

39
00:03:24.420 --> 00:03:30.210
Now let us discuss Main Doxies source file, which illustrate the use of Gyul threats.

40
00:03:32.710 --> 00:03:40.470
So many is a source while would simulate an application, and you can see that in the source file,

41
00:03:40.480 --> 00:03:42.520
we have defined the structure implied.

42
00:03:43.330 --> 00:03:48.430
Right, and this implies structure has Gyul Node called G.A..

43
00:03:49.270 --> 00:03:54.550
And then we have a function which actually prints all the details of the implied object.

44
00:03:55.570 --> 00:04:02.440
Now you can see that in the main function we have declared the implied object and we have finished the

45
00:04:02.440 --> 00:04:04.690
fields of this object.

46
00:04:05.530 --> 00:04:13.930
Similarly, we have another object and we have another implied object that we have created to imply

47
00:04:13.930 --> 00:04:18.279
objects and populated the respective fields with some data.

48
00:04:20.160 --> 00:04:26.760
Now, once you have three objects ready in line number fifty one, we have created a new giant threat

49
00:04:26.760 --> 00:04:28.470
list, right.

50
00:04:29.160 --> 00:04:37.950
And we have initialized this list in the next line after initialization of G.L. threat list, we now

51
00:04:37.950 --> 00:04:42.420
insert the three objects that we have created using giant threat.

52
00:04:42.420 --> 00:04:43.470
Add Ippei.

53
00:04:45.130 --> 00:04:53.980
Then after that, I demonstrate the use of I to my crew, and using this I treated my crew, I traverse

54
00:04:53.980 --> 00:05:01.300
over this employee list and the details of all the employee objects present in this jail threat list

55
00:05:01.750 --> 00:05:03.160
that does imply list.

56
00:05:05.480 --> 00:05:12.710
Then I demonstrate the use of GM to remove API and I remove the second employee from this dual threat

57
00:05:13.760 --> 00:05:19.090
and to confirm that the object is actually removed from the GM threat.

58
00:05:19.610 --> 00:05:25.610
Again, I tripped over this trial thread and print and implied details which are present industrial

59
00:05:25.610 --> 00:05:26.120
threat.

60
00:05:27.530 --> 00:05:35.270
So when you compile and execute your program, you will see that the second employee will not be printed.

61
00:05:36.170 --> 00:05:43.580
And then finally, I took over the drill thread one final time and remove all the G alerts, which is

62
00:05:43.580 --> 00:05:48.980
present in this GM thread one by one, and free the application data.

63
00:05:50.080 --> 00:05:57.250
And finally, you should free the gold thread, which is nothing but a playlist, so this is the simple

64
00:05:57.250 --> 00:06:02.200
program which demonstrate the use of liberty that we have just written.

65
00:06:03.460 --> 00:06:10.120
So take the source code as a reference and you should try writing your own jail tree library, G.L.

66
00:06:10.180 --> 00:06:17.230
CU Library, G.L. Stack Library or or any other good version of that, a structure that you could think

67
00:06:17.230 --> 00:06:17.710
of.

