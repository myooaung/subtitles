WEBVTT
1
00:00:05.330 --> 00:00:06.780
So welcome back, guys.

2
00:00:07.040 --> 00:00:13.610
So let us continue our discussion with Jill Thread's, so now the question arises that why do we have

3
00:00:13.610 --> 00:00:20.950
to stir things up a little if we are accomplishing the same goal before by traditional link list?

4
00:00:21.260 --> 00:00:21.600
Right.

5
00:00:22.130 --> 00:00:25.040
This is the obvious question that must be crossing your mind.

6
00:00:25.850 --> 00:00:30.860
So let us discuss the benefit of Jill Tred linked list or what traditional list?

7
00:00:31.790 --> 00:00:34.670
Let us see the problem with traditional link list.

8
00:00:34.940 --> 00:00:41.960
This problem applies to traditional trees, traditional cues or any other data structure that you could

9
00:00:41.960 --> 00:00:42.620
think of.

10
00:00:44.060 --> 00:00:52.010
So let us continue with our favorite structure called employee, so let us say that we have a pointer

11
00:00:52.010 --> 00:00:53.870
to this employee object.

12
00:00:54.620 --> 00:01:01.640
Now, you need to insert this employee object into three doubly linked list with your application is

13
00:01:01.640 --> 00:01:02.240
maintaining.

14
00:01:02.900 --> 00:01:06.470
So let us assume that your application maintains three doubly linked list.

15
00:01:07.040 --> 00:01:12.050
The first unrelentless is to maintain the records of employees of an organization.

16
00:01:13.160 --> 00:01:20.210
The second linked list that your application maintains is a link list of all the employees who are above

17
00:01:20.210 --> 00:01:21.110
manager level.

18
00:01:22.130 --> 00:01:28.340
And the third link lists that your application maintains is the linked list, which stores the record

19
00:01:28.340 --> 00:01:31.550
of all employees whose promotions are due.

20
00:01:33.090 --> 00:01:41.160
Now, let us say that our favorite object that we have in our application qualifiers, all the three

21
00:01:41.160 --> 00:01:48.690
criteria, therefore we need to insert our employee object into all these three doubly linked list,

22
00:01:48.960 --> 00:01:51.650
which is being maintained by our application.

23
00:01:52.350 --> 00:01:57.210
So let us try to visualize the situation with the help of a diagram on the next slide.

24
00:01:58.290 --> 00:02:04.650
So suppose your application is using traditional, doubly linked list, so let us see that how the situation

25
00:02:04.650 --> 00:02:05.520
would look like.

26
00:02:06.330 --> 00:02:11.550
So we have our favorite employee object who satisfies all the three criteria.

27
00:02:11.790 --> 00:02:18.000
And and this employee object needs to be present in all the three doubly linked list, which is being

28
00:02:18.000 --> 00:02:19.450
maintained by our application.

29
00:02:20.250 --> 00:02:27.390
So suppose you have a list L1 and there is some node in the list L1 which distorts the pointer to this

30
00:02:27.390 --> 00:02:28.040
object.

31
00:02:28.680 --> 00:02:28.980
Right.

32
00:02:29.790 --> 00:02:35.700
So remember, we are discussing the case when an application is making use of traditional link list.

33
00:02:36.300 --> 00:02:39.640
We are not discussing Gyul threats in this case.

34
00:02:40.290 --> 00:02:47.280
Similarly, the secondary link is that your application maintains also have a inkless node, which is

35
00:02:47.280 --> 00:02:50.730
of course a reference to the object impacts.

36
00:02:51.270 --> 00:02:51.780
Right.

37
00:02:52.710 --> 00:02:57.000
And the same goes with the third link list, which is being maintained by the application.

38
00:02:58.050 --> 00:03:05.880
So you can see that because this object satisfies all the three criteria, as all the three linked list

39
00:03:05.880 --> 00:03:09.510
has to have a reference to point to this object.

40
00:03:10.690 --> 00:03:18.520
Now, obviously, in order to insert the same object into three different linked list, you need to

41
00:03:18.670 --> 00:03:21.800
allocate node for each linked list.

42
00:03:22.360 --> 00:03:30.170
It means that you need to invoke three Matlock's in order to insert this object into three list.

43
00:03:30.580 --> 00:03:30.970
Right.

44
00:03:32.810 --> 00:03:39.890
So this is first thing that you need to insert as many blogs as there are a number of linked list which

45
00:03:39.890 --> 00:03:42.380
needs to reference to the object.

46
00:03:43.750 --> 00:03:52.690
Now, consider the situation, suppose the employee alone leaves the company and therefore your application

47
00:03:52.690 --> 00:03:56.500
need to remove his records from all the linked lists.

48
00:03:58.320 --> 00:04:05.070
Now, in this situation, you have three DoubleLine list, right, so your application needs to iterate

49
00:04:05.070 --> 00:04:12.180
over all the three doubly linked list, find the node which points to the object, Aroon, and delete

50
00:04:12.180 --> 00:04:14.580
that particular node from the list.

51
00:04:14.940 --> 00:04:15.360
Right.

52
00:04:15.870 --> 00:04:23.100
And you have to do this exercise for all the list which registers the reference to the object.

53
00:04:23.730 --> 00:04:33.240
Once you unreferenced the object from all the list, then only you can actually free the object, right?

54
00:04:34.530 --> 00:04:42.360
So now I ask you the question, what is the time complexity to delete this object from your application

55
00:04:42.360 --> 00:04:43.060
database?

56
00:04:44.010 --> 00:04:52.800
The time complexity is out of and into three times because you have to e-trade or all the doubly linked

57
00:04:52.800 --> 00:04:55.320
list to unreferenced the object.

58
00:04:55.620 --> 00:05:02.670
And once you unreferenced the object from all the URLs, then only you destroy the object permanently

59
00:05:02.670 --> 00:05:03.850
from your application.

60
00:05:04.590 --> 00:05:10.050
So you have to iterate over all the link list in order to unreferenced this object.

61
00:05:10.620 --> 00:05:14.850
And therefore the time complexity is ottenhoff and into three times.

62
00:05:15.570 --> 00:05:18.990
It means the deletion of the object is an expensive operation.

63
00:05:20.430 --> 00:05:27.720
Now, let us try to visualize the same scenario using gel threads and let us see that how we are benefited

64
00:05:27.720 --> 00:05:32.160
if we had used gel threads instead of traditional booklist.

