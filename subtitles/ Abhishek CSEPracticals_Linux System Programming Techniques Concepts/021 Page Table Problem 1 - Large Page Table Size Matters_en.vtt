WEBVTT
1
00:00:05.390 --> 00:00:13.340
So guys, going forward to discuss the problem, number one, the size of the table matters, it means

2
00:00:13.340 --> 00:00:17.330
that there will be problem if you tend to increase the size of page table.

3
00:00:18.020 --> 00:00:21.780
So let us try to understand this problem with the help of numerical example.

4
00:00:22.940 --> 00:00:24.370
So let us discuss the scenario.

5
00:00:24.380 --> 00:00:32.960
Number one, suppose you have a 32 bit system and when memory size is four, GBE size of the page is

6
00:00:32.960 --> 00:00:34.340
four kilobyte as usual.

7
00:00:34.820 --> 00:00:41.840
And let us suppose that the size of one entry in a peace table is four bytes now that you have already

8
00:00:41.840 --> 00:00:45.260
practiced similar numerical assignments.

9
00:00:45.710 --> 00:00:52.640
Now you should be able to compute that given this data the size of the peace table, the process would

10
00:00:52.640 --> 00:00:58.440
going to be four megabytes and this size of this table is absolutely OK.

11
00:00:59.210 --> 00:01:06.590
So suppose if you are machine on an average is running hundred processors, then the main memory consumption's

12
00:01:06.590 --> 00:01:10.040
because of only peace tables will be fought in two hundred.

13
00:01:10.370 --> 00:01:18.040
That is, 400 megabytes of your main memory will be used only to store pays tables of hundred processors.

14
00:01:19.130 --> 00:01:27.290
So given the configuration of the machine, 400 megabytes out of this four GB is a very reasonable size

15
00:01:27.290 --> 00:01:31.610
of main memory, which is dedicated to peace tables only.

16
00:01:33.820 --> 00:01:36.040
So it doesn't look like a problem here.

17
00:01:37.000 --> 00:01:41.680
Now let us change the scenario and change the configuration of the system.

18
00:01:42.730 --> 00:01:48.550
Now, suppose you have a 64 bit system size of the main memory is FGB.

19
00:01:49.570 --> 00:01:52.020
This size is four kilobits, as usual.

20
00:01:52.360 --> 00:01:56.620
And let us suppose that the size of the table entry is four bytes.

21
00:01:57.520 --> 00:02:05.110
Now, again, calculate the size of the table purposes with this data and you will find that the size

22
00:02:05.110 --> 00:02:07.230
of the table is humongous.

23
00:02:08.199 --> 00:02:15.450
You will need to rest with about 34 megabytes off this table and this is for each process.

24
00:02:16.360 --> 00:02:20.710
It is absolutely not feasible to have tables of this size.

25
00:02:21.340 --> 00:02:23.980
I don't even know how much memory this is.

26
00:02:23.980 --> 00:02:26.170
Is it in terabytes or petabytes?

27
00:02:28.150 --> 00:02:34.420
Now, most likely, if you have putting your machine or laptop in a year or two, most probably your

28
00:02:34.420 --> 00:02:36.390
machine is a 64 bit system.

29
00:02:37.330 --> 00:02:43.960
You can go to my computer and click on properties and check whether your system is a 32 bit system or

30
00:02:43.960 --> 00:02:45.230
64 bit system.

31
00:02:45.850 --> 00:02:50.710
Now, a 64 bit systems are more common than 32 big systems.

32
00:02:51.310 --> 00:02:52.480
So what do you think?

33
00:02:52.660 --> 00:02:58.050
Does each process running on your 64 bit system has been staples of this size?

34
00:02:58.480 --> 00:02:59.740
The answer is no.

35
00:03:00.400 --> 00:03:01.780
It is not possible.

36
00:03:02.410 --> 00:03:09.430
So you can see that the problem of a stable size grows more aggrieved as much electricity is supported

37
00:03:09.430 --> 00:03:10.840
by the system increases.

38
00:03:11.470 --> 00:03:11.860
Right.

39
00:03:12.160 --> 00:03:19.030
And I have already explained that while there is a need to migrate from 32 bit system to 64 bit system,

40
00:03:19.690 --> 00:03:20.110
right.

41
00:03:20.500 --> 00:03:26.120
Remember, 32 bit system cannot access your physical memory beyond 4G now.

42
00:03:26.260 --> 00:03:28.890
We already discussed the reasons behind it.

43
00:03:29.500 --> 00:03:37.330
Therefore today we have sixty four bit system so that we can have access to more ram and hence enhances

44
00:03:37.330 --> 00:03:40.770
the speed and multitasking ability of the system.

45
00:03:41.350 --> 00:03:41.720
Right.

46
00:03:42.310 --> 00:03:50.140
But as you migrate from 32 bit system to 64 bit systems, the stable size would tend to increase.

47
00:03:50.530 --> 00:03:57.460
Having a stable of this giant size, what does this giant size to restore the power to the four megabytes

48
00:03:57.460 --> 00:04:00.000
is also not feasible, right?

49
00:04:00.370 --> 00:04:05.200
So on one hand, you want to migrate from 32 bit system to 64 bit system.

50
00:04:05.590 --> 00:04:12.720
And on the other hand, there is a problem that if you try to migrate your size of the stable glass

51
00:04:12.730 --> 00:04:18.260
to the extent that you cannot even think, would that be stable in your main memory?

52
00:04:18.760 --> 00:04:20.660
So what is the solution to this problem?

53
00:04:21.220 --> 00:04:26.800
So the solution to this problem was multilabel paging, which we were going to discuss in a separate

54
00:04:26.800 --> 00:04:27.900
section altogether.

