WEBVTT
1
00:00:05.240 --> 00:00:11.480
So, guys, now let us discuss the second problem with its troubles, the second problem is the need

2
00:00:12.320 --> 00:00:16.070
to provide contiguous main memory to page tables.

3
00:00:16.700 --> 00:00:24.790
Submersibles like physical pagers of a process are not fragmented and need a contiguous region in main

4
00:00:24.800 --> 00:00:25.330
memory.

5
00:00:25.880 --> 00:00:32.689
So, for example, four megabytes of base table would need four megabytes of contiguous region in the

6
00:00:32.689 --> 00:00:33.550
main memory.

7
00:00:34.670 --> 00:00:40.370
So the increase in the size of a lateral support base, table sizes tend to increase drastically.

8
00:00:40.820 --> 00:00:42.620
And this is what we had discussed.

9
00:00:42.620 --> 00:00:44.350
And the problem, number one.

10
00:00:45.200 --> 00:00:50.800
So finding the contiguous region in main memory becomes more and more challenging to load the piece

11
00:00:50.810 --> 00:00:52.470
tables of increased size.

12
00:00:52.910 --> 00:00:56.950
So let us try to understand and visualize this problem pictorially.

13
00:00:57.950 --> 00:01:04.280
So let us suppose that there are three processors running the system whose peace table needs three frames

14
00:01:04.280 --> 00:01:06.230
is to be stored in the main memory.

15
00:01:06.800 --> 00:01:13.760
So suppose we have a process B won't be 23 and three and the stable of these processes are represented

16
00:01:13.760 --> 00:01:15.530
with the following two different colors.

17
00:01:16.670 --> 00:01:23.270
Spaced tables of processors could be loaded in any three consecutive frames of memory.

18
00:01:23.750 --> 00:01:26.160
Not the word you need consecutive frames.

19
00:01:26.960 --> 00:01:33.950
So the snapshot of the main memory loading the tables of the process P1 P2P three would look something

20
00:01:33.950 --> 00:01:36.080
like this, right?

21
00:01:36.710 --> 00:01:42.680
So you can see that the table of the process P1 is loaded from frame number three to frame number five.

22
00:01:43.130 --> 00:01:48.530
And the best table of the process, P2, is loaded from frame number eight to frame number 10.

23
00:01:49.190 --> 00:01:54.800
And similarly, the best table of the process, P three is loaded from frame number 13 to frame number

24
00:01:54.800 --> 00:01:57.110
15 in main memory.

25
00:01:58.370 --> 00:02:05.030
So the increase in the size of the piece tables chances to find more available consecutive frames grew

26
00:02:05.030 --> 00:02:05.790
more rare.

27
00:02:06.590 --> 00:02:06.990
Right.

28
00:02:07.160 --> 00:02:09.830
So this is one of the problems with the peace table.

29
00:02:11.210 --> 00:02:17.330
Not only the increased size of the table is a problem, but with the increase in the size of the table,

30
00:02:17.510 --> 00:02:23.630
the probability of finding consecutive frames of the main memory so that it can accommodate the entire

31
00:02:23.630 --> 00:02:25.360
peace table is also rare.

32
00:02:26.930 --> 00:02:31.400
So the solution to the problem, number one, and the problem number two is multilabel.

33
00:02:32.600 --> 00:02:40.070
So the essence of multilabel paging scheme is that that break the large piece tables into smaller sizes

34
00:02:40.370 --> 00:02:43.940
loaded in noncontiguous frames in main memory.

35
00:02:44.900 --> 00:02:49.730
In fact, multilevel paging is nothing, but it is pagination of page table.

36
00:02:50.390 --> 00:02:53.540
That is, we will be purging of beds, tables.

37
00:02:54.110 --> 00:02:59.720
So we were going to discuss the concept of multilevel paging and a separate section of the scores all

38
00:02:59.720 --> 00:03:00.310
together.

