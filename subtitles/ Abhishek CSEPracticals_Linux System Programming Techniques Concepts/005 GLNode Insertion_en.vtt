WEBVTT
1
00:00:05.790 --> 00:00:13.980
So, guys, now let us discuss how we will going to do not in session in jail threats, so that is discussed

2
00:00:13.980 --> 00:00:15.660
this with the help of an example.

3
00:00:16.940 --> 00:00:20.430
So let us continue with our same structure of employer.

4
00:00:21.620 --> 00:00:29.250
Now we need to create objects out of this structure and we need to insert those objects into a general

5
00:00:29.300 --> 00:00:29.840
thread.

6
00:00:30.890 --> 00:00:40.070
Now, notice that to add an object to G.L. thread link list deltron node itself has to be a member of

7
00:00:40.070 --> 00:00:40.790
the structure.

8
00:00:41.720 --> 00:00:47.420
So you can see that this Emploi structure has a member called Zaltrap Node.

9
00:00:48.290 --> 00:00:51.320
Now, this deal node actually acts as a glue.

10
00:00:52.030 --> 00:00:59.690
Glue means that using this delord, the employee object will going to stick itself, or in other words,

11
00:00:59.690 --> 00:01:03.020
we're going to insert itself in a giant thread.

12
00:01:03.740 --> 00:01:11.300
So one thing you can analyze here is that that programmer, while at the time of writing a code, the

13
00:01:11.300 --> 00:01:16.970
programmer declared G.L. tried Node T as a member of this structure and apply.

14
00:01:18.200 --> 00:01:25.610
It simply means that while designing the application, the developer or programmer knew beforehand that

15
00:01:25.610 --> 00:01:31.610
he would going to add the object of type employee into agile thread.

16
00:01:32.300 --> 00:01:32.770
Right.

17
00:01:33.800 --> 00:01:41.570
That is why at the time of writing a code itself, the developer mentioned one of the members of this

18
00:01:41.570 --> 00:01:51.380
structure as Geelhoed, which will act as a glue to hook up the object of type emploi in deal threads.

19
00:01:52.310 --> 00:02:00.120
Now, let us discuss in the next slide that how we can insert the object of type emploi in deal threads.

20
00:02:01.340 --> 00:02:09.380
So going forward, you can see this diagram shows G.L. thread containing or consisting of three objects

21
00:02:09.380 --> 00:02:10.639
of type implying.

22
00:02:11.240 --> 00:02:15.530
So this is object one, this is object to and this is object three.

23
00:02:15.740 --> 00:02:21.830
All of the objects of type imply now using their last member, that is Geelhoed.

24
00:02:22.010 --> 00:02:27.130
Each of these objects have actually picked themselves to a thread.

25
00:02:28.010 --> 00:02:28.450
Right.

26
00:02:30.630 --> 00:02:39.120
Now, if you have the address to this G.A., you simply subtract the offset of this G.A. to get the

27
00:02:39.120 --> 00:02:45.480
starting address of the object, and once you get the starting address of the object, you can access

28
00:02:45.480 --> 00:02:47.130
all the fields of this object.

29
00:02:47.610 --> 00:02:47.980
Right.

30
00:02:48.450 --> 00:02:54.900
So given a pointer to a G.A., how to get a pointer to the start of the object.

31
00:02:55.940 --> 00:03:00.290
We have already discussed when we discussed the concept of offset.

32
00:03:02.240 --> 00:03:08.660
Now, let us write a short program in which we will write an API, which will allow us to insert an

33
00:03:08.660 --> 00:03:10.360
object into a dual threat.

34
00:03:11.270 --> 00:03:14.180
So let us say that the name of the API is G.L. Threat.

35
00:03:14.180 --> 00:03:19.370
And the first element to this API is a pointer to a dual threat list.

36
00:03:19.730 --> 00:03:25.160
And the second argument to this function is actually a pointer to a G.A..

37
00:03:27.000 --> 00:03:33.940
So let me show you the implementation of this function and this function is pretty much simple and straightforward.

38
00:03:34.200 --> 00:03:40.110
This function simply allows you to insert a new G.A. to an existing and thread.

