WEBVTT
1
00:00:05.340 --> 00:00:14.160
Now we will discuss what exactly text substitution is and how does it look so text substitution happen

2
00:00:14.160 --> 00:00:15.000
in Sourcefire?

3
00:00:15.330 --> 00:00:19.420
Want us to find the file with the extension of doxie and DOT.

4
00:00:19.440 --> 00:00:26.280
CPB are the source while so text substitution happens in source file, which is being compiled by the

5
00:00:26.280 --> 00:00:31.920
compiler compiler before it actually commence the compiling of the source file.

6
00:00:32.070 --> 00:00:34.560
It performs text substitution.

7
00:00:34.950 --> 00:00:37.260
Now, this point is actually very important.

8
00:00:38.580 --> 00:00:43.170
First of all, remember that text substitution happens in source file.

9
00:00:44.010 --> 00:00:52.800
Text substitution do not happen in the file compiler make use of the file in order to perform text substitution

10
00:00:52.800 --> 00:00:53.840
and source file.

11
00:00:54.540 --> 00:01:02.010
And second point says that before the compiler actually starts compiling the source file, compiler

12
00:01:02.010 --> 00:01:07.330
actually performs the text substitution in the source file that is being compiled.

13
00:01:07.990 --> 00:01:14.940
Now, this text substitution is actually accomplished by two pre processing directives.

14
00:01:15.450 --> 00:01:21.370
The first pre processing directive is has to include and the second preprocessing directive is has defined.

15
00:01:21.840 --> 00:01:30.360
So remember, in C or C++, any statement to start with hash is actually called preprocessing directive.

16
00:01:30.600 --> 00:01:32.190
Why it is called pre processing.

17
00:01:32.580 --> 00:01:39.090
It is called pre processing because these statements are executed before actually the compiler starts

18
00:01:39.090 --> 00:01:40.500
compiling the source file.

19
00:01:41.480 --> 00:01:47.540
Now, as we know, that has include preprocessing directive is used to include the head of PIN in the

20
00:01:47.540 --> 00:01:48.230
source file.

21
00:01:49.040 --> 00:01:55.170
So these two points actually tells that how hash include preprocessing directive rules.

22
00:01:55.940 --> 00:02:00.590
So in your source file, if you have a statement, hash include a dot.

23
00:02:00.600 --> 00:02:06.470
And then this statement is replaced by the contents of a dot.

24
00:02:06.470 --> 00:02:09.020
S had a file in that source file.

25
00:02:09.830 --> 00:02:17.930
Similarly, if contents of a DOT s had to file intown contains another hash, include statements than

26
00:02:17.930 --> 00:02:24.080
these nested hash include, the statement is again replaced by the content of that corresponding had

27
00:02:24.080 --> 00:02:26.180
the file in that particular source file.

28
00:02:28.060 --> 00:02:33.850
So don't worry, if you will, going to see how it happens with the help of an example now coming to

29
00:02:33.850 --> 00:02:40.150
the has defined preprocessing directive that has defined preprocessing directive is used to actually

30
00:02:40.150 --> 00:02:41.590
define the macro's.

31
00:02:42.130 --> 00:02:50.260
For example, here we have a very simple macro in which we define the statement Square X as the multiplication

32
00:02:50.260 --> 00:02:51.940
of two X values.

33
00:02:52.990 --> 00:03:00.490
So in your source file, whatever have you written, this square acts as a statement that square X calls

34
00:03:00.760 --> 00:03:08.440
will be texturally substituted by the definition of the macro that is X into X and all the places in

35
00:03:08.440 --> 00:03:09.220
a source file.

36
00:03:10.560 --> 00:03:16.560
So here I actually expect you that you are familiar with has to find preprocessing detective.

37
00:03:17.050 --> 00:03:24.510
Now let us see how hash include and has defined preprocessing detectives actually work in the text substitution

38
00:03:24.510 --> 00:03:26.910
phase with the help of an example.

