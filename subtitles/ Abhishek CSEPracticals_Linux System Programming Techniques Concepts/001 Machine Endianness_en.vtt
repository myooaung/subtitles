WEBVTT
1
00:00:06.900 --> 00:00:12.380
So welcome back, guys, in this section of the course, we will going to start with a new topic altogether.

2
00:00:12.660 --> 00:00:16.309
We will going to learn about big Indian and little Indian machines.

3
00:00:16.590 --> 00:00:18.660
Now, this topic is a very common topic.

4
00:00:18.660 --> 00:00:24.780
If you already have an idea about big Indian and little Indian that there is absolutely no need to invest

5
00:00:24.780 --> 00:00:29.160
time in this section of the cause and please feel free to skip.

6
00:00:30.390 --> 00:00:36.090
Those who are hearing these terms for the first time, please stay with me, this topic is again important

7
00:00:36.090 --> 00:00:42.420
from your point of view in an interview, often you are asked to explain what are big Indian and little

8
00:00:42.420 --> 00:00:47.730
Indian machines and what is the difference between them since it's a common topic.

9
00:00:47.730 --> 00:00:52.950
Therefore, those who are already aware, please feel free to skip this section of the course.

10
00:00:55.070 --> 00:00:56.180
So that's a start.

11
00:00:56.510 --> 00:01:02.540
So Indianness refers to the sequential order in which bytes of the data are stored in the computer's

12
00:01:02.540 --> 00:01:03.020
memory.

13
00:01:03.410 --> 00:01:06.180
So now let us discuss it with the help of an example.

14
00:01:06.650 --> 00:01:08.890
So let me choose some random number.

15
00:01:09.200 --> 00:01:09.620
Right.

16
00:01:10.370 --> 00:01:15.980
So if you convert this number into its equivalent binary number, it's equal in binary number.

17
00:01:15.980 --> 00:01:17.540
Would be this right?

18
00:01:17.690 --> 00:01:23.990
If you don't believe me, just pick up your calculator and try to see the binary representation of this

19
00:01:23.990 --> 00:01:24.430
number.

20
00:01:25.580 --> 00:01:33.440
Now, in your computer program, the moment you write in A is equal to, say, some number X, then

21
00:01:33.440 --> 00:01:39.540
in the computer's memory, the value of this variable eight will be stored in the binary format.

22
00:01:40.610 --> 00:01:49.970
So if this X is this number, then in the computer's memory at the address of the variable A, the value

23
00:01:49.970 --> 00:01:53.390
that is present will be the binary representation of this number.

24
00:01:55.130 --> 00:02:05.030
Now, this entire vegetable on this platform, it is of size four bites and four bite means 32 bits,

25
00:02:05.420 --> 00:02:05.840
right.

26
00:02:06.890 --> 00:02:10.910
How do you choose the data type instead of end as unsigned?

27
00:02:10.910 --> 00:02:18.020
Long than this date or time would have been of size eight bites, which is same as 64 bits.

28
00:02:18.320 --> 00:02:18.730
Right.

29
00:02:19.160 --> 00:02:26.030
So we're going to discuss the Indianness of the machine with respect to the data type int are more precisely

30
00:02:26.030 --> 00:02:27.710
saying unsigned int.

31
00:02:29.440 --> 00:02:36.460
Whatever we discuss with respect to the data type isn't exactly the same logic applies to data type

32
00:02:36.460 --> 00:02:41.870
unsigned long, which is another data type two story integers, in fact, longer integers.

33
00:02:42.760 --> 00:02:49.570
Now, by now, you must have verified that the equal representation of this number into its equivalent

34
00:02:49.570 --> 00:02:51.780
32 bit binary representation.

35
00:02:51.790 --> 00:02:53.320
Is this right?

36
00:02:54.430 --> 00:03:02.470
So you can see that these are actually 32 bits and we already know that Edwards is equal to one byte.

37
00:03:02.890 --> 00:03:09.400
So let us say that these eight, which is byte number three, these Edwards is byte number two, these

38
00:03:09.400 --> 00:03:13.870
Edwards is byte number one and is Edwards is by no P zero.

39
00:03:14.170 --> 00:03:16.600
Right in the computer's memory.

40
00:03:16.600 --> 00:03:19.060
Every byte has an address.

41
00:03:20.510 --> 00:03:26.990
Now, coming to the discussion of Indianness of the machine, the Indianness of the machine decides

42
00:03:26.990 --> 00:03:33.040
in what order these might be to be to be one and B zero will going to be stored in the computer's memory.

43
00:03:33.470 --> 00:03:38.600
So, for example, if this particular binary representation of the number is stored in the computer's

44
00:03:38.600 --> 00:03:44.150
memory in this format, then we say that your machine is a big Indian machine.

45
00:03:44.360 --> 00:03:49.070
And this particular representation of a number is called big Indian representation.

46
00:03:50.610 --> 00:03:58.200
The big Indian representation famously is also termed as network Bitauto, right, so you can see that

47
00:03:58.200 --> 00:04:04.460
this is the most significant bite of the number and this is the least significant bite of the number.

48
00:04:04.770 --> 00:04:05.190
Right.

49
00:04:05.640 --> 00:04:12.570
So in the computer's memory, even the most significant bite of the number is present at the lower address

50
00:04:12.570 --> 00:04:12.960
here.

51
00:04:13.230 --> 00:04:16.019
The lower address is two thousand, for example.

52
00:04:16.260 --> 00:04:16.680
Right.

53
00:04:17.040 --> 00:04:21.899
And as I said that every byte in the computer's memory has an address.

54
00:04:22.200 --> 00:04:30.390
It means that byte number B2 will have an address 2001 and the byte number B1 will have an address 2002

55
00:04:30.390 --> 00:04:31.150
and so on.

56
00:04:31.800 --> 00:04:38.640
So if the most significant bite of a number is saved at a lower address and the least significant bite

57
00:04:38.640 --> 00:04:45.360
of the number is saved at the higher address, then this type of storage or representation of binary

58
00:04:45.360 --> 00:04:52.440
numbers in computer's memory is called Big Indian representation or network Bitauto.

59
00:04:52.710 --> 00:04:53.230
Right.

60
00:04:55.890 --> 00:05:02.340
Now, opposed to this, if the number is stored in the computer's memory, such that least significant

61
00:05:02.340 --> 00:05:09.540
bite is the stored at the lower address and the most significant bite is stored at the higher address

62
00:05:09.960 --> 00:05:13.410
than this particular representation of binary numbers.

63
00:05:13.410 --> 00:05:19.550
And computer's memory is called little Indian representation, or Horst Bitauto.

64
00:05:20.100 --> 00:05:20.500
Right.

65
00:05:20.970 --> 00:05:25.910
So network Bitauto and host byte order are completely opposite to each other.

66
00:05:27.430 --> 00:05:33.160
So this is the difference between big Indian and little Indian machines, and it is one of the most

67
00:05:33.160 --> 00:05:35.160
part questions for interviews.

68
00:05:36.040 --> 00:05:41.680
So be prepared to explain what is big Indian and little Indian representation and what does not work

69
00:05:41.680 --> 00:05:43.450
by daughter and host Bitauto.

70
00:05:43.990 --> 00:05:51.610
And also note that the Indian as soda machine influences the order in which the bites of the number

71
00:05:51.610 --> 00:05:53.400
are stored in the computer's memory.

72
00:05:53.920 --> 00:05:59.050
It do not influences at the best level, but it influences at the bite level.

73
00:05:59.320 --> 00:05:59.630
Right.

74
00:06:00.070 --> 00:06:04.380
You can see that the order of birds is intact, right?

75
00:06:04.780 --> 00:06:10.710
It is the bitts which got rearranged in the computer's memory depending on the independence of the machine.

76
00:06:10.960 --> 00:06:11.390
Right.

77
00:06:11.710 --> 00:06:13.660
So do not get ever confused.

78
00:06:13.930 --> 00:06:18.070
The Indianness affects the byte ordering and not with ordering.

