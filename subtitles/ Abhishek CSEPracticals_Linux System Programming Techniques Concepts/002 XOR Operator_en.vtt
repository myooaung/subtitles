WEBVTT
1
00:00:06.900 --> 00:00:11.760
So, guys, in this lecture, really, we were going to cover a special property of the Czar operator,

2
00:00:12.180 --> 00:00:16.710
so czar operator has a supernatural power to segregate the mixture of two things.

3
00:00:17.340 --> 00:00:23.040
For example, separating milk from the water or separating a dissolve sugar from the water.

4
00:00:23.040 --> 00:00:29.790
So do not take these analogs very seriously, but you will realize that operate operator somewhat walks

5
00:00:29.790 --> 00:00:30.540
in this fashion.

6
00:00:31.650 --> 00:00:36.900
So, for example, let us suppose we have two variable and B and you performed the czar of these two

7
00:00:36.900 --> 00:00:40.020
variables and stored the result in the variable R.

8
00:00:40.920 --> 00:00:47.940
So in the second step, if you already know the value of E, you simply perform the czar of E with the

9
00:00:47.940 --> 00:00:50.970
result that is the mixture you will get.

10
00:00:51.270 --> 00:00:59.970
B Likewise, if you already know b just perform the czar operation with the result and you will get

11
00:00:59.970 --> 00:01:00.330
it.

12
00:01:01.020 --> 00:01:09.300
So in the step second and three, we are actually segregating the mixture represented by R and R is

13
00:01:09.300 --> 00:01:09.690
nothing.

14
00:01:09.690 --> 00:01:16.740
But you can visualize R as a mixture or a result of performing Zot on Rarible and B.

15
00:01:17.460 --> 00:01:22.800
And if you already know one of the vegetable, you simply perform the czar with the mixture to get another

16
00:01:22.800 --> 00:01:25.590
vegetable of which is always composed of.

17
00:01:26.550 --> 00:01:30.180
So we were going to exploit this property to do this exercise.

18
00:01:30.870 --> 00:01:38.280
So we already know that a singly linked list node is typically represented by the following structure.

19
00:01:39.120 --> 00:01:43.470
We have data, let's say INT, and we have a pointer to the next note.

20
00:01:44.970 --> 00:01:45.450
All right.

21
00:01:45.900 --> 00:01:52.320
So in a traditional singly linked list, the address part the stores the location of the next node.

22
00:01:53.040 --> 00:01:58.560
So let's say ABCD is the address of the node one, two, three and four.

23
00:01:59.280 --> 00:02:02.730
So the first node will going to store the address of the next node.

24
00:02:04.090 --> 00:02:04.540
All right.

25
00:02:04.900 --> 00:02:11.170
The second Nord will going to store the address of the next port and the third Nord CE would going to

26
00:02:11.170 --> 00:02:13.120
store the address of the next Nord DE.

27
00:02:13.450 --> 00:02:17.530
And the last note of the singly linked list stores the address?

28
00:02:17.530 --> 00:02:17.950
No.

29
00:02:18.790 --> 00:02:21.260
So you must be very much familiar with this concept.

30
00:02:21.280 --> 00:02:25.240
This is just a very basic concept when it comes to data structure and binders.

31
00:02:26.330 --> 00:02:35.510
My question is, can you exploit this XAA property in order to implement a double link list using the

32
00:02:35.510 --> 00:02:37.670
same strict list, nor a structure?

33
00:02:38.090 --> 00:02:42.710
You are not allowed to do any kind of modification and there's still no structure.

34
00:02:43.010 --> 00:02:47.420
And yet you should be able to implement this link list as a link list.

35
00:02:47.900 --> 00:02:52.670
When I say the link list, it means that you should be able to traverse the link list in the forward

36
00:02:52.670 --> 00:02:55.640
direction as well as in the backward direction.

37
00:02:58.550 --> 00:03:00.380
Think about it, can you do that?

38
00:03:02.470 --> 00:03:04.240
So the answer is very simple.

39
00:03:04.990 --> 00:03:13.060
In order to implement the doubling list while preserving the data structure definition of a singly linked

40
00:03:13.060 --> 00:03:19.150
list as it is, what we will going to do is that that the ad was part of each node of the linked list.

41
00:03:19.150 --> 00:03:23.890
We're going to store the czar of the previous node and the next note.

42
00:03:24.670 --> 00:03:32.440
So for example, the node ever going to store the czar of Seattle and the czar of the next node, which

43
00:03:32.440 --> 00:03:33.610
is the ADS-B.

44
00:03:34.720 --> 00:03:36.700
Similarly, the next node be.

45
00:03:38.400 --> 00:03:42.360
We're going to storm the czar of the previous mold on the next note.

46
00:03:42.780 --> 00:03:45.090
So in this case is our sea.

47
00:03:46.850 --> 00:03:47.300
All right.

48
00:03:47.630 --> 00:03:56.030
Similarly, the node number three or were going to store the czar of B and D and they were going to

49
00:03:56.030 --> 00:04:03.800
store the source of C and none because the next node with respect to the node dismal.

50
00:04:05.090 --> 00:04:09.080
So now can we trust the link list in the forward direction?

51
00:04:12.760 --> 00:04:18.790
Well, we can troubles the link list in both directions, provided that you need to catch the address

52
00:04:18.790 --> 00:04:24.610
of the previous Nord in local variable to compute the address of the next node during travel sites and

53
00:04:24.610 --> 00:04:25.630
in either direction.

54
00:04:26.680 --> 00:04:27.100
All right.

55
00:04:28.900 --> 00:04:35.020
So for example, when you start referencing this link list from the first Nord, the address part of

56
00:04:35.020 --> 00:04:37.840
the first Nord already contains the address of the next Nord.

57
00:04:38.560 --> 00:04:40.180
So you travels to the next not.

58
00:04:40.930 --> 00:04:45.850
But during the term, also gas the address of the previous Nord in the local variable.

59
00:04:46.180 --> 00:04:51.610
So let's say we have a local variable CHP and it will store the address of the previous Nord aim.

60
00:04:52.090 --> 00:04:54.400
At this point of time, we are not me.

61
00:04:55.300 --> 00:05:03.220
Now, in order to go to the Nord CE, simply perform the operation of the variable P with whatever value

62
00:05:03.220 --> 00:05:09.300
you have in the spot, so you will end up performing the czar of a czar.

63
00:05:09.340 --> 00:05:14.860
See which comes from that at the start and the czar, which comes from the previous variable.

64
00:05:15.520 --> 00:05:17.770
So you will end up getting the advocacy.

65
00:05:19.640 --> 00:05:20.110
All right.

66
00:05:20.210 --> 00:05:23.540
So when you jump to the North Sea update, the variable P..

67
00:05:25.890 --> 00:05:32.430
To point to the previous Nord, which is been and again to be the same exercise, you will perform the

68
00:05:32.760 --> 00:05:38.910
operation of whatever value you have in the Adva sparred with the previous and would be so that you

69
00:05:38.910 --> 00:05:45.690
will get the next address that is deep and update the previous variable to point to the previous Nord,

70
00:05:45.690 --> 00:05:46.470
which is see.

71
00:05:47.280 --> 00:05:52.800
And once you rise to the Nord to perform the Zahler operation of water, what do you have in the address

72
00:05:52.800 --> 00:05:54.780
bar with the previous Nord?

73
00:05:55.140 --> 00:05:57.990
So here in this case, you will end up getting No.

74
00:05:59.600 --> 00:06:05.190
So this is how travel is done in the forward direction, and exactly the same approach is done while

75
00:06:05.210 --> 00:06:07.430
doing a travel cell in the backward direction.

76
00:06:09.040 --> 00:06:16.850
However, there is one drawback of this technique, and that drawback is that that you cannot do traversal

77
00:06:16.900 --> 00:06:21.850
in either direction that is in forward direction or backward direction.

78
00:06:23.180 --> 00:06:31.340
If I simply give you an address of some mid Nord affordably linked list, so let's assume that the atlas

79
00:06:31.340 --> 00:06:37.850
part of each node of this link list contains the czar of the previous and the next node.

80
00:06:38.300 --> 00:06:45.560
If I only give you the address of some arbitrary node of this link list, you have no way to compute

81
00:06:45.560 --> 00:06:47.810
either the address or address.

82
00:06:47.840 --> 00:06:58.670
Be here in the address part of the Node three you have be Zahedi and you cannot extract out either b

83
00:06:59.660 --> 00:07:08.150
r d from this mixture of ZAR, which is b b because you don't already know the address of the Node B

84
00:07:08.150 --> 00:07:15.200
and A. Be in this case because I have given you a pointer to some made note of this link list, which

85
00:07:15.200 --> 00:07:17.300
in this case is the addressee.

86
00:07:18.170 --> 00:07:19.870
So this is the drawback of this technique.

87
00:07:19.880 --> 00:07:26.030
You can tell us the link list in the forward direction from the beginning node, and you can traverse

88
00:07:26.030 --> 00:07:32.940
the link list in the back, more direction from the and node starting from the Node D, but you cannot

89
00:07:32.940 --> 00:07:38.810
traverse the link list beginning from an ignored in the middle of the linked list.

90
00:07:39.800 --> 00:07:44.000
So this could be one of the cautions that can be put up in competitive programming.

91
00:07:44.360 --> 00:07:50.120
I haven't seen this type of link list anywhere in the production code so far, but this is one of the

92
00:07:50.120 --> 00:07:56.180
clever techniques where resort operation can be used to implement singly linked list as a link list.

