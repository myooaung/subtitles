WEBVTT
1
00:00:05.570 --> 00:00:07.010
So welcome back, guys.

2
00:00:07.430 --> 00:00:09.820
Now let us discuss Beijing in action.

3
00:00:10.310 --> 00:00:15.160
So this is the moment which we have been waiting for in this lecture video.

4
00:00:15.170 --> 00:00:20.990
We will going to discuss an end to an example which demonstrate the concept of Beijing.

5
00:00:21.890 --> 00:00:28.400
So in our example, consider the following configuration of the system, the size of the virtual space

6
00:00:28.400 --> 00:00:29.320
of the process.

7
00:00:29.330 --> 00:00:31.400
Let us suppose it the 16 bytes.

8
00:00:32.060 --> 00:00:32.560
Right.

9
00:00:33.610 --> 00:00:41.260
It means that in address and space of a process, there can be 16 Whelchel addresses and to represent

10
00:00:41.260 --> 00:00:44.490
16 virtual addresses, you need four bits.

11
00:00:45.070 --> 00:00:51.430
It means that the size of the actual address that is generated by C.P.U during the course of execution

12
00:00:51.430 --> 00:00:54.460
of a program is offered bits in size.

13
00:00:55.950 --> 00:01:00.630
Next, let us assume that the size of virtual page is four bytes.

14
00:01:02.320 --> 00:01:09.640
Now, since the size of a virtual page is four bytes, the virtual address space of a process will be

15
00:01:09.640 --> 00:01:18.730
fragmented into four virtual pages for virtual pages because 16 divided by four with 16 is the size

16
00:01:18.730 --> 00:01:24.640
of process letters of space and four is the size of a virtual page.

17
00:01:25.030 --> 00:01:32.710
It means that virtual the space of the process will be fragmented into four virtual pages.

18
00:01:33.850 --> 00:01:37.870
Now let us assume that the size of the main memory is 32 bytes.

19
00:01:38.800 --> 00:01:42.390
So diagram on the right hand side represents the main memory.

20
00:01:43.000 --> 00:01:49.660
Now, since the watch on page size is equal to frame size, therefore the main memory will be fragmented

21
00:01:49.660 --> 00:01:56.440
into it seems like it frames the size of the main memory divided by the size of the frame.

22
00:01:56.830 --> 00:01:58.120
Which is it?

23
00:01:58.450 --> 00:02:01.750
So the main memory will be fragmented into eight frames.

24
00:02:03.190 --> 00:02:10.479
Now, going forward, since the virtual space of the process is fragmented into four pages, it means

25
00:02:10.479 --> 00:02:18.160
that number of bits required to represent a virtual page uniquely is too right because to restore the

26
00:02:18.160 --> 00:02:19.760
power to will give you four.

27
00:02:20.920 --> 00:02:28.120
And finally, number of books required to represent an address within a virtual page uniquely is two

28
00:02:28.120 --> 00:02:32.780
bits like two, because the size of the virtual page is four bytes.

29
00:02:33.310 --> 00:02:39.550
It means that in one virtual page there will going to be four bytes and everybody has an address.

30
00:02:39.880 --> 00:02:46.100
Therefore, you need to buy it's two to uniquely identify a bite within a virtual page.

31
00:02:46.810 --> 00:02:51.100
So I hope you understand all these calculations and assumptions.

32
00:02:52.260 --> 00:02:58.260
Now, with this configuration of the system in place now, let us demonstrate how robust Beijing rules.

33
00:02:59.580 --> 00:03:06.300
Now, let us suppose that your program is executing now during the course of execution of a program,

34
00:03:06.510 --> 00:03:14.130
we already know that CPR generates addresses to perform, read and write operation in physical memory.

35
00:03:15.060 --> 00:03:20.340
So let us suppose that, for example, seepage and breaks the will address nine.

36
00:03:21.010 --> 00:03:21.480
Right.

37
00:03:22.510 --> 00:03:29.260
Now, the binary representation of Whelchel address nine is one zero zero one, right?

38
00:03:31.260 --> 00:03:37.260
Now you can see that the binary representation of the virtual address has been split up into two parts,

39
00:03:37.950 --> 00:03:41.360
and each part comprises of two bits, right?

40
00:03:41.670 --> 00:03:49.650
Little bits, because number of bricks required to represent a virtual page uniquely is to bits and

41
00:03:49.650 --> 00:03:53.880
number of bits required to represent an address within a virtual page.

42
00:03:53.880 --> 00:03:55.620
Uniquely is again to bits.

43
00:03:56.070 --> 00:04:03.510
Therefore, virtual address that is generated by the CPU is decomposed into two parts and each part

44
00:04:03.510 --> 00:04:04.770
is two bits long.

45
00:04:06.000 --> 00:04:12.060
Now let us suppose that for the process in execution, the following is the patient stable.

46
00:04:14.010 --> 00:04:17.910
So you can see that a process has four virtual pages is No.

47
00:04:17.910 --> 00:04:20.700
Zero base number one and two and three.

48
00:04:21.149 --> 00:04:25.740
Corresponding to this virtual page, you have a physical page, right?

49
00:04:26.070 --> 00:04:32.330
And each of these physical page is loaded into corresponding frame number in the main memory.

50
00:04:32.880 --> 00:04:38.670
So you can see, for example, that the physical page one is loaded in frame number five.

51
00:04:39.150 --> 00:04:40.650
That is in this frame.

52
00:04:41.070 --> 00:04:41.470
Right.

53
00:04:42.000 --> 00:04:46.140
Similarly, physical page number two is loaded in frame number one.

54
00:04:46.590 --> 00:04:48.180
That is in this frame.

55
00:04:48.750 --> 00:04:49.260
Right.

56
00:04:51.020 --> 00:04:58.040
Now, we already know that the virtual address has been split it up or decomposed into two parts, the

57
00:04:58.040 --> 00:05:03.860
first part is actually used to uniquely identify the virtual page number in the process, which will

58
00:05:03.860 --> 00:05:04.730
address the space.

59
00:05:05.390 --> 00:05:09.790
So the decimal equivalent of the first part is to write.

60
00:05:10.130 --> 00:05:15.380
So it maps to the second virtual page in the process, virtual table.

61
00:05:16.220 --> 00:05:22.760
Now, what should page number two has a mapping with physical page number two as per the page table.

62
00:05:23.250 --> 00:05:29.270
And we know that as part of a stable physical page, number two is loaded in frame number one.

63
00:05:30.050 --> 00:05:30.540
Right.

64
00:05:31.400 --> 00:05:39.450
So the output of looking up into this base table, using two as a key is frame number one.

65
00:05:40.040 --> 00:05:46.340
So this is the output of looking up into the peace table, using the first two bits of the virtual address

66
00:05:47.180 --> 00:05:49.050
as a key into the peace table.

67
00:05:49.850 --> 00:05:54.200
So now we have located the frame number one in the main memory.

68
00:05:55.070 --> 00:06:00.770
Now, the question is that which by number within this frame we are trying to access.

69
00:06:02.000 --> 00:06:09.440
So now here is the rule of the second decomposed part of about trilateralists now the decimal equivalent

70
00:06:09.440 --> 00:06:12.230
of the second decomposed part is wrong.

71
00:06:13.610 --> 00:06:19.360
And we know that the second part of the Wortzel address is nothing, but it is an offset within a virtual

72
00:06:19.370 --> 00:06:19.820
page.

73
00:06:21.300 --> 00:06:29.890
So it means that in a frame, everyone starting with the first bite at an offset, you will end up with

74
00:06:29.890 --> 00:06:32.760
the physical address, five of main memory.

75
00:06:33.420 --> 00:06:38.820
So please note that these numbers, which are written on the left side of the physical memory, are

76
00:06:38.850 --> 00:06:45.080
actually physical addresses which identify a location of a bite in a physical memory.

77
00:06:46.140 --> 00:06:55.110
So you can see that after adding the offset value to the starting address of frame F one, we end up

78
00:06:55.110 --> 00:06:57.150
getting the physical address five.

79
00:06:58.450 --> 00:07:07.420
So it simply means that logical address nine, that is this ad draws maps to a physical address, five

80
00:07:07.420 --> 00:07:08.490
in physical memory.

81
00:07:09.870 --> 00:07:15.780
So once the Watchem address is successfully mapped to a corresponding physical address in the main memory,

82
00:07:16.080 --> 00:07:22.710
KPL then performs the Reed all right operation as the instruction at physical address five.

83
00:07:23.550 --> 00:07:28.740
So you can see that the concept of paging is very simple and easy to understand.

84
00:07:29.490 --> 00:07:32.250
So let me summarize what we have done so far.

85
00:07:34.170 --> 00:07:35.340
In the first step.

86
00:07:35.550 --> 00:07:40.700
CPR generates the virtual address and decompose the virtual address into two parts.

87
00:07:41.640 --> 00:07:49.470
Right, using first part of the virtual address, locate the frame number of physical memory into which

88
00:07:49.470 --> 00:07:54.120
the physical page is loaded using second part of the virtual address.

89
00:07:54.450 --> 00:07:57.000
Mind the offset value, right.

90
00:07:57.810 --> 00:08:06.630
And then add this offset value to the starting address of the frame, which was TEITELMAN and step number

91
00:08:06.630 --> 00:08:06.960
two.

92
00:08:07.500 --> 00:08:11.910
So we can see that the aging process involves these folding four steps.

93
00:08:12.870 --> 00:08:19.620
And the end result of the paging is that that the virtual address that is generated by the CPU has been

94
00:08:19.980 --> 00:08:24.860
successfully mapped to some physical address of random access memory.

95
00:08:25.950 --> 00:08:31.120
And we already know that it is ramp our physical memory which actually stores the data.

96
00:08:31.590 --> 00:08:38.730
So it means that from the process perspective, the process performs return right operation on the Virtual

97
00:08:38.730 --> 00:08:49.110
Atlas nine right process always believes that it has 16 bytes of memory available to it and to be used.

98
00:08:51.500 --> 00:08:57.860
Why 16 bytes, because from a process perspective, the size of the virtual space of the process is

99
00:08:57.860 --> 00:09:04.920
16 bytes process is not even aware that there is something called physical memory and physical addresses.

100
00:09:06.110 --> 00:09:12.350
It is the packaging that is playing its role and successfully map the virtual address that is generated

101
00:09:12.350 --> 00:09:16.580
by the process to some physical address on physical memory.

102
00:09:17.330 --> 00:09:21.810
From the process perspective, process always believes that it is performing.

103
00:09:21.810 --> 00:09:29.060
Read and write operation on some address was nine, but in reality, the reason the operation is being

104
00:09:29.060 --> 00:09:32.840
performed on physical address five on physical memory.

105
00:09:33.350 --> 00:09:38.220
So you can see that paging actually creates an illusion for a process.

106
00:09:39.200 --> 00:09:49.040
So if the process, for example, involves the operation star and why past nine here and pass hell?

107
00:09:50.690 --> 00:09:57.200
Here, followed by Ford, which is the length of the string, it means that this string hell will be

108
00:09:57.200 --> 00:10:04.850
written in the physical memory in this way h e l l right.

109
00:10:05.900 --> 00:10:10.460
Because the watcher let those nine maps to the physical address, five in the main memory.

110
00:10:10.820 --> 00:10:18.280
And starting from this address, we are actually writing for byte of string, which is at Alal.

111
00:10:18.800 --> 00:10:24.160
So you can see that and the physical memory hell will be written in this manner.

112
00:10:25.610 --> 00:10:28.700
We already know that each character occupies one byte.

113
00:10:31.340 --> 00:10:38.360
So, guys, going forward, if you don't reach the logical address six, then this logical address six

114
00:10:38.360 --> 00:10:41.840
will map to the physical address, 22 in main memory.

115
00:10:42.290 --> 00:10:45.770
Similarly logical address 13 will map to the physical evidence.

116
00:10:45.770 --> 00:10:52.970
Nine logical ABDUS 15 will map to the physical abuse 11 and logical address three will map to the physical

117
00:10:52.970 --> 00:10:54.680
address 15 in memory.

118
00:10:55.280 --> 00:10:58.330
Now you already know the steps, how Beijing works.

119
00:10:58.340 --> 00:11:04.880
Therefore, I request you to actually verify whether these results are correct or not.

