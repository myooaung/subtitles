WEBVTT
1
00:00:06.120 --> 00:00:12.900
So, guys, the second stage of the completion process is actually the completion of stage this stage

2
00:00:12.900 --> 00:00:18.030
stakes and import the tax substituted source file, which is produced by the preprocessing stage of

3
00:00:18.030 --> 00:00:25.840
the completion process and the stage to the completion stage produces the assembly code as an output.

4
00:00:26.700 --> 00:00:33.000
So this assembly code is equivalent to the high level program code that you wrote, intestacy source

5
00:00:33.000 --> 00:00:39.540
file and the file, which contains the equivalent assembly code, has an extension of Dartez.

6
00:00:40.020 --> 00:00:46.590
So now let us compile our test one dot seesaws file and see how assembly code looks like.

7
00:00:48.570 --> 00:00:54.810
So you can see on the left hand side is the best one dot seesaws file, which is a tax substituted source

8
00:00:54.820 --> 00:01:01.560
file on the right hand side, I will compile the test one dot seesaws file to create an excellent assembly

9
00:01:01.560 --> 00:01:02.040
code.

10
00:01:03.960 --> 00:01:11.490
So not that you need to pass the flag hyphen capital as to your compiler in order to create the assembly

11
00:01:11.490 --> 00:01:12.800
code, right.

12
00:01:13.230 --> 00:01:16.450
So all the assembly code will go in test dot as file.

13
00:01:18.240 --> 00:01:25.800
So if I open Testament's file, you can see the same program which you ruled in a high level C language

14
00:01:25.800 --> 00:01:28.200
has been reduced to the assembly language.

15
00:01:28.950 --> 00:01:32.600
Now, this assembly language may appear as a piece of junk to you.

16
00:01:32.730 --> 00:01:39.390
Of course, you would not understand even a single line in this file if we have never does the assembly

17
00:01:39.390 --> 00:01:40.650
programming or something.

18
00:01:41.040 --> 00:01:46.110
And I'm sure that 99 percent of the student do not learn assembly language.

19
00:01:46.860 --> 00:01:52.530
And it is actually OK because until or unless you are really working at the lower level staff, you

20
00:01:52.530 --> 00:01:54.970
never need to learn assembly language.

21
00:01:56.100 --> 00:02:03.900
So in this piece of code, you can see that your main function is here and this is the equivalent implementation

22
00:02:04.470 --> 00:02:08.690
and this is the equivalent assembly implementation of the main function.

23
00:02:09.120 --> 00:02:15.900
So you can see that your three lines of code in the main function is reduced to about 20 lines in the

24
00:02:15.900 --> 00:02:17.160
assembly language program.

25
00:02:17.940 --> 00:02:23.700
Similarly, you had the function compute circle area and following is the assembly implementation of

26
00:02:23.700 --> 00:02:24.430
this function.

27
00:02:24.990 --> 00:02:31.050
So basically all you need to take away from here is that that completion stage involves the translation

28
00:02:31.050 --> 00:02:33.750
of the high level source program.

29
00:02:33.750 --> 00:02:41.250
But you roj to the equivalent assembly code and once you have generated this equivalent assembly code,

30
00:02:41.520 --> 00:02:46.950
we feed this assembly code to the third stage of the completion process, which is called assembler.

31
00:02:48.360 --> 00:02:54.870
So Assembler is a program which takes an input to the assembly code and produces the output, which

32
00:02:54.870 --> 00:02:57.570
is called machine code or object files.

33
00:02:58.620 --> 00:03:02.160
So in the next lecture video, we will catch up with the assembler.

