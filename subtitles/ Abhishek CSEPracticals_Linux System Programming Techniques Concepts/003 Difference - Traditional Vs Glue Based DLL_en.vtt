WEBVTT
1
00:00:06.000 --> 00:00:12.480
So, guys, now let us try to understand the difference between giant Trad's and Gradational link list

2
00:00:12.480 --> 00:00:13.680
with the help of a diagram.

3
00:00:14.490 --> 00:00:19.130
So you can see that the following diagram represents the traditional link list.

4
00:00:19.680 --> 00:00:27.390
And as we know that each node in the link list has a left pointer, has a right pointer, as well as

5
00:00:27.390 --> 00:00:31.760
has a data member which actually points to the application data.

6
00:00:32.280 --> 00:00:32.670
Right.

7
00:00:33.000 --> 00:00:37.020
So this is how your traditional link list looks like in the memory.

8
00:00:38.920 --> 00:00:43.010
Now, contrary to this, the jail threads look something like this.

9
00:00:43.720 --> 00:00:50.020
Now you can see that in the traditional, doubly linked list, your application data is present elsewhere

10
00:00:50.020 --> 00:00:56.530
in the memory and the load of the list actually stores the address of your application data.

11
00:00:57.220 --> 00:01:04.000
So let us suppose that for this application data that addresses a than the note of a link list, which

12
00:01:04.000 --> 00:01:11.160
actually points to this application data will hold the address in the data member of a node of a list.

13
00:01:13.090 --> 00:01:17.920
Whereas in case of Gluba is doubly linked list, there is no such thing.

14
00:01:19.300 --> 00:01:26.410
So, first of all, for the rest of the course to avoid any confusion, I will going to call group is

15
00:01:26.410 --> 00:01:28.720
doubly linked list as G.L. threads.

16
00:01:30.160 --> 00:01:30.630
Right.

17
00:01:31.270 --> 00:01:37.420
And I will going to call a node of a group is doubly linked list as Geelhoed.

18
00:01:39.220 --> 00:01:39.650
Right.

19
00:01:40.000 --> 00:01:47.560
So it will avoid any confusion, whether I am referring to a. of a traditional list or I'm referring

20
00:01:47.560 --> 00:01:49.410
to a. of a dual thread.

21
00:01:50.680 --> 00:01:56.440
Now, you can see in the second diagram, the second diagram actually represents a real threat, which

22
00:01:56.440 --> 00:01:58.150
is holding application data.

23
00:01:59.540 --> 00:02:06.140
Now, we already know that Gaylord's doesn't have already started a member too blind to the application

24
00:02:06.140 --> 00:02:06.640
data.

25
00:02:07.070 --> 00:02:15.140
So you can see that this actually represents the Geelhoed and it has only left and right Mamba, which

26
00:02:15.140 --> 00:02:18.400
points to the left and right node of a dual thread.

27
00:02:19.820 --> 00:02:26.720
So you can see that the application data is actually tightly grouped with the Geelhoed.

28
00:02:28.400 --> 00:02:37.310
So think of it like an application data has some sticky gum using which it can stick itself to any doubly

29
00:02:37.310 --> 00:02:37.970
linked list.

30
00:02:38.270 --> 00:02:47.420
No link list means G.L. threads and this sticky gum is nothing, but it is a load of a giant thread

31
00:02:47.450 --> 00:02:49.040
that is G.A..

32
00:02:49.940 --> 00:02:57.140
So you can see that this structure represents some application database your application is using and

33
00:02:57.140 --> 00:03:00.930
one of the member of this structure is actually G.P.A..

34
00:03:01.820 --> 00:03:09.650
So this member to be precisely saying that this member is nothing, but it is G.L. Thread Node and let

35
00:03:09.650 --> 00:03:19.130
us call this member as glue because using this G.L. thread node, this application data will going to

36
00:03:19.250 --> 00:03:21.920
stick itself to a thread.

37
00:03:23.090 --> 00:03:29.570
Now, we will see in the remaining portion of the that how G.L. threads work, how application data

38
00:03:29.570 --> 00:03:38.720
is glued to a thread and how do I to what a giant thread and how to access the application data while

39
00:03:38.720 --> 00:03:40.660
iterating over a dual thread.

40
00:03:41.630 --> 00:03:48.470
Now at least you must be getting some high level idea that what is the significance of the word glue

41
00:03:48.680 --> 00:03:51.160
in glue based list.

42
00:03:51.860 --> 00:03:59.510
So here glue means that something using which you can stick an object onto other object here.

43
00:03:59.510 --> 00:04:07.130
One object is an application data and this application data has G.A. as one of its member.

44
00:04:07.820 --> 00:04:10.730
This Geelhoed is nothing, but it is a glue.

45
00:04:10.970 --> 00:04:18.350
And using this glue, this application data can actually stitch itself to a real thread.

46
00:04:19.370 --> 00:04:26.180
So you can see that this application data, this is a member of application data, which is nothing

47
00:04:26.180 --> 00:04:27.110
but a glue.

48
00:04:27.770 --> 00:04:34.130
And using this glue, this application data has its itself to AdÃ©le thread.

49
00:04:35.280 --> 00:04:41.940
Now, as we proceed into this course, I will show you how to implement real threats and how to perform

50
00:04:41.940 --> 00:04:48.420
various operations which you typically perform on a linked list on real threats.

