WEBVTT
1
00:00:05.080 --> 00:00:10.690
So, guys, now let us start with the concept of jail threats, so jail terms are nothing, but they

2
00:00:10.690 --> 00:00:12.970
are glued version of the list.

3
00:00:13.330 --> 00:00:19.750
So like traditional, doubly linked list, the end goal of jail threads are the end objective of jail.

4
00:00:19.750 --> 00:00:24.460
Trad's is no different from the end goal of traditional, doubly linked list.

5
00:00:26.160 --> 00:00:32.880
As I stated earlier, we are just learning, redesigning or reorganizing our data structures in a better

6
00:00:32.880 --> 00:00:36.140
or efficient way as compared to traditional methods.

7
00:00:37.140 --> 00:00:40.010
So let us do a little recap now.

8
00:00:40.020 --> 00:00:44.220
You know how to define data structures, which represents a list.

9
00:00:44.940 --> 00:00:53.370
So now you are familiar how to define structures which represent traditional link list so you can see

10
00:00:53.370 --> 00:00:58.020
that the structure represents the node of a traditional linked list.

11
00:00:59.090 --> 00:01:05.640
I know you already know that a typical node of a traditional linked list has three members that is left

12
00:01:05.640 --> 00:01:11.720
right as well as the data, which actually a pointer which points to the application data.

13
00:01:12.240 --> 00:01:12.630
Right.

14
00:01:12.870 --> 00:01:20.370
And the second the structure is the representation of a list itself now that you have already implemented

15
00:01:20.370 --> 00:01:22.040
a traditional link list.

16
00:01:22.380 --> 00:01:29.250
So now I expect you that you know how to define and design the structures which represents traditional

17
00:01:29.730 --> 00:01:30.050
list.

18
00:01:32.680 --> 00:01:39.400
Now, against this traditional, doubly linked list, on the right hand side is actually the definition

19
00:01:39.580 --> 00:01:42.100
of group is the list.

20
00:01:42.790 --> 00:01:46.570
Now, as I said, Gluba is doubly linked list are called real threats.

21
00:01:47.410 --> 00:01:51.780
So the first structure is actually the definition of a node of a dual threat.

22
00:01:52.660 --> 00:01:58.510
So you can see that in the structure, which represents a node of a giant threat, there are only two

23
00:01:58.510 --> 00:01:59.170
members.

24
00:01:59.860 --> 00:02:03.140
The first member is the left and the second member is the right.

25
00:02:03.820 --> 00:02:10.060
Now, you already know that left and right members of a node linked list are actually the members,

26
00:02:10.060 --> 00:02:14.700
which points to the left node as well as right node in a list.

27
00:02:15.670 --> 00:02:20.500
So can you spot the difference between the definition of these two nodes?

28
00:02:20.980 --> 00:02:22.750
That is on the right hand side?

29
00:02:22.750 --> 00:02:28.420
We have a definition of a load of a giant thread, whereas on the left hand side we have a definition

30
00:02:28.420 --> 00:02:31.350
of a. of a traditional linked list.

31
00:02:32.050 --> 00:02:39.070
So as you can see that the clear difference between the two definitions is actually the absence of this

32
00:02:39.070 --> 00:02:43.990
member in threat NGL thread node definition.

33
00:02:44.350 --> 00:02:50.350
There is no member called data, which actually points to the application data.

34
00:02:51.620 --> 00:03:00.680
So we will shortly discuss that, why we do not have worldstar data as a member of the alternative structure

35
00:03:01.640 --> 00:03:07.610
and the second structure is, again, the representation of group is doubly linked list.

36
00:03:08.600 --> 00:03:14.520
So, again, like traditional double-dealing list, it has a pointer which points to the head of a giant

37
00:03:14.540 --> 00:03:19.100
thread that is a pointer to the first node of group is doubly linked list.

38
00:03:19.610 --> 00:03:25.160
And like traditional, doubly linked list, G.L. threads can also has function pointers.

39
00:03:26.120 --> 00:03:32.330
And you can see that the additional thing G.L. Threads has is a member called Offset.

40
00:03:33.200 --> 00:03:34.340
Now we will see that.

41
00:03:34.340 --> 00:03:40.630
What is the purpose of this offset, why it is there and what is the use of this offset number?

42
00:03:41.090 --> 00:03:46.190
So you can see that G.L. thread nodes do not have Whydah started a member, right?

43
00:03:46.560 --> 00:03:52.260
So you can see that we do not have Whydah started a structure in giant thread nor data structure.

44
00:03:52.760 --> 00:04:00.780
So you must be wondering that if I do not have Wildstar data data structure, then how Boudjellal thread

45
00:04:00.800 --> 00:04:03.390
nodes holds the application data.

46
00:04:04.490 --> 00:04:07.730
So before jumping into this point, let us learn some more.

47
00:04:07.730 --> 00:04:13.760
S. So looks like you are very curious to know now that how does Gyul threats walk?

