WEBVTT
1
00:00:05.540 --> 00:00:11.600
So, guys, now we will see what does the Days three does, it takes an input the assembly code and

2
00:00:11.600 --> 00:00:15.310
produces the machine code, which is an object code or object file.

3
00:00:16.580 --> 00:00:21.310
So you can see on the screen, on the left hand side is the output of the state's two of the compilation

4
00:00:21.320 --> 00:00:21.980
process.

5
00:00:21.980 --> 00:00:23.990
And it is a pure assembly code.

6
00:00:24.470 --> 00:00:30.600
On the right hand side, we can convert this assembly code into the object code using minus C flag.

7
00:00:31.310 --> 00:00:31.760
Right.

8
00:00:32.960 --> 00:00:41.090
So you can see I have created a test object file, but object files are not human readable files.

9
00:00:41.630 --> 00:00:46.710
If you tried to open this file in an editor, you will only end up with seeing a junk.

10
00:00:47.660 --> 00:00:55.340
So thankfully, there are tools or widget dump kind of tools which are used to decode the object files

11
00:00:55.340 --> 00:00:56.540
on the Linux platform.

12
00:00:57.350 --> 00:00:57.610
Right.

13
00:00:58.160 --> 00:01:07.610
So let me redirect the output to the temporary file and then we can see what is there in the temporary

14
00:01:07.610 --> 00:01:08.060
file.

15
00:01:09.220 --> 00:01:16.900
So you can see on the right hand side, it's the content of the object file has got all you can see

16
00:01:16.900 --> 00:01:23.890
on the left hand side there is a machine cord and on the right hand side is an equivalent assembly code.

17
00:01:24.250 --> 00:01:24.670
Right.

18
00:01:25.360 --> 00:01:28.510
So what is feed it to the processor for execution?

19
00:01:28.510 --> 00:01:31.990
Is actually this binary code or machine code, right.

20
00:01:32.350 --> 00:01:38.440
So you can see that this binary code or machine code is the hexadecimal representation of your program.

21
00:01:39.130 --> 00:01:45.190
And the values on the most left hand side is actually the actual addresses present in the virtual address,

22
00:01:45.190 --> 00:01:46.420
the space of your program.

23
00:01:47.600 --> 00:01:54.530
So you can see, for example, this construction is located at the virtual address number four of the

24
00:01:54.530 --> 00:01:56.420
virtual address space of this program.

25
00:01:57.730 --> 00:02:04.290
And this instruction is nothing, but it is moving some value from the Udai register to the base point

26
00:02:04.310 --> 00:02:06.050
to register, right.

27
00:02:06.730 --> 00:02:13.030
So, of course, this assembly code itself was kind of a black box to us.

28
00:02:13.270 --> 00:02:17.620
And there is no question that people are going to understand what this binary code is.

29
00:02:18.340 --> 00:02:23.470
The bottom line is that you understand the pipeline of the completion process of a C program.

30
00:02:24.310 --> 00:02:26.350
And it is a great interview question.

31
00:02:27.870 --> 00:02:34.160
Though you are not expected to decode this assembly code or machine code and tell what actually this

32
00:02:34.170 --> 00:02:40.680
code is, but you are expected to know the various stages of the compilation process that the typical

33
00:02:40.680 --> 00:02:45.230
C program goes to every time you compile a program and run it.

34
00:02:46.050 --> 00:02:50.590
So you can see that for the function, compute the square and compute circle area.

35
00:02:50.850 --> 00:02:54.070
The following is the machine code underneath each of them.

36
00:02:55.020 --> 00:03:01.200
And finally, we have the main function, which is also translated into its equivalent machine called.

37
00:03:02.330 --> 00:03:08.540
Also, one more thing you can notice is that that the information in this object file is properly organized,

38
00:03:08.990 --> 00:03:09.430
right?

39
00:03:09.770 --> 00:03:14.560
You can see that the information is properly maintained and very much organized.

40
00:03:15.200 --> 00:03:19.690
If you notice that information is divided into sections.

41
00:03:20.120 --> 00:03:23.450
For example, this is the text section of the program.

42
00:03:23.870 --> 00:03:30.260
And if you go down, you can see that this is the section which is called Read Only Data Section, then

43
00:03:30.260 --> 00:03:31.430
comment section.

44
00:03:31.820 --> 00:03:36.360
And then there's the section called Each Underscore Frame and so on.

45
00:03:37.400 --> 00:03:44.030
So this format of the object file on the Linux platform is especially damed as YALLAH format.

46
00:03:46.070 --> 00:03:54.860
The full form of Elaph is executable and linkable format, so on Linux platform, all the object files

47
00:03:54.860 --> 00:04:02.570
and executables are finally converted into an organized piece of information and the format is called

48
00:04:02.570 --> 00:04:06.100
ILF Executable and link format.

49
00:04:07.790 --> 00:04:11.600
So it's just that you should not be alien to the storm itself.

50
00:04:12.080 --> 00:04:18.260
And after stories three, once we have created all the object files corresponding to all of our source

51
00:04:18.260 --> 00:04:24.890
file, then the final stage of the compilation process is the Linko stage, which we will going to discuss

52
00:04:24.890 --> 00:04:26.120
in the next lecture video.

