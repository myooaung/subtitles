WEBVTT
1
00:00:05.670 --> 00:00:12.000
So welcome back, guys, in this section of the course, we will going to focus especially on multithreaded

2
00:00:12.000 --> 00:00:12.790
processes.

3
00:00:13.360 --> 00:00:20.670
We will learn that whole stack or heap memory management is done in case if our process is a multithreaded

4
00:00:20.670 --> 00:00:21.330
process.

5
00:00:22.420 --> 00:00:29.650
So far, we have considered only single threaded process for all the discussions we have so far regarding

6
00:00:29.650 --> 00:00:37.930
memory management, so a process can give birth to multiple threads, threads in can generate more threads.

7
00:00:38.920 --> 00:00:45.410
So thread share almost everything amongst each other as well as with the patent process.

8
00:00:45.880 --> 00:00:51.040
So these are the things with the thread share with each other as well as with the parent process.

9
00:00:52.000 --> 00:00:57.820
That is the court segment in a process which will address the space is shared among all the threads

10
00:00:57.820 --> 00:01:00.210
which has been created by the process.

11
00:01:00.970 --> 00:01:06.760
When I say share, it means that physical pages into which this court segment is.

12
00:01:07.940 --> 00:01:16.040
Included are actually shared among all the threads which are generated by the process here, sharing

13
00:01:16.040 --> 00:01:22.280
means that there will be exactly one copy of physical pages, which belongs to the code segment of a

14
00:01:22.280 --> 00:01:22.940
process.

15
00:01:24.290 --> 00:01:31.220
Similarly, the data segment, which is both initialised and initialised portion of data segment in

16
00:01:31.220 --> 00:01:37.240
virtually the space of a process, is also shared by all the threats that is generated by the process.

17
00:01:37.970 --> 00:01:44.270
If the process has certain final descriptors, such as the process has opened certain sockets or message

18
00:01:44.270 --> 00:01:46.640
cues or various other resources.

19
00:01:48.170 --> 00:01:54.560
Then as soon as the process creates threads, threads will have an access to all these file descriptors.

20
00:01:55.180 --> 00:02:01.810
It means that these open file descriptors are also shared by all the threads that is created by a process.

21
00:02:02.840 --> 00:02:06.590
And most important among all of these is the memory.

22
00:02:07.040 --> 00:02:13.370
We already know that if a process generate a thread, a thread can access all the data structures which

23
00:02:13.370 --> 00:02:15.690
is residing in the memory of the process.

24
00:02:16.250 --> 00:02:23.180
In fact, if a thread modify any data structure which is present in the heap memory, that modification

25
00:02:23.180 --> 00:02:27.950
is visible to the process also as well as other threads of a process.

26
00:02:28.950 --> 00:02:34.590
So it means that the physical pages corresponding to the heap memory is also shared by all the threads

27
00:02:34.590 --> 00:02:42.030
of a process, but there is one thing that is not shared between threads of a process, and that is

28
00:02:42.030 --> 00:02:43.170
the stack memory.

29
00:02:44.190 --> 00:02:49.170
Every thread on a process has its own private STAC memory.

30
00:02:49.770 --> 00:02:54.180
Every thread has its own exclusive private STAC memory.

31
00:02:55.140 --> 00:03:01.520
We will see how stacked memory is managed by the operating system in multithreaded environment.

32
00:03:02.520 --> 00:03:08.730
So each thread has its own execution flow, which is independent of other threats.

33
00:03:09.390 --> 00:03:13.020
Hence it is required that they have a separate stack memory.

34
00:03:13.320 --> 00:03:20.370
Right, because we know that it is the stack memory which is responsible for program execution.

35
00:03:20.790 --> 00:03:24.800
That is just the stack mumbly with supports procedure call it returns.

36
00:03:25.470 --> 00:03:32.700
So because every thread has its own execution flow, it means that every trat needs its own private

37
00:03:32.700 --> 00:03:37.920
stack memory because Ted shares many things among themselves.

38
00:03:37.950 --> 00:03:43.920
And we have already listed that these are the things which are shared by all the threads of a process.

39
00:03:44.490 --> 00:03:50.730
So common operating system not have to work too hard in order to create or destroy threads.

40
00:03:51.030 --> 00:03:58.020
Right, because most of the kernel resources, which the new thread requires, has already been created

41
00:03:58.020 --> 00:03:59.340
by the parent process.

42
00:04:00.180 --> 00:04:07.110
So that is why, because the creation and destruction of the thread is a lightweight operation.

43
00:04:07.320 --> 00:04:11.280
Therefore, tribes are also called as lightwater process.

44
00:04:13.430 --> 00:04:19.640
So let us see what changes happen to the process which will address the space and how its tables of

45
00:04:19.640 --> 00:04:25.860
a process are set up or modified when it creates or destroy new threats.

46
00:04:26.420 --> 00:04:31.130
And this is a goal or objective of the section of the course.

