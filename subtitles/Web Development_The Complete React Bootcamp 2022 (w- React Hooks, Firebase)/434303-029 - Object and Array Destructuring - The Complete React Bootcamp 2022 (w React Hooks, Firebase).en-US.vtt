WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.265
Hey, in this video we're going to talk

00:00:02.265 --> 00:00:04.844
about object and array does structuring.

00:00:04.844 --> 00:00:07.005
These two features are used a lot.

00:00:07.005 --> 00:00:09.315
Let's check them out in file.js.

00:00:09.315 --> 00:00:13.169
Let's say I wanted to create an object, let it be car.

00:00:13.169 --> 00:00:16.830
And it will have the following keys.

00:00:16.830 --> 00:00:20.280
Color, which is going to be red,

00:00:20.280 --> 00:00:25.740
Let's say Gears 5 and maybe engine type.

00:00:25.740 --> 00:00:27.495
Let's put diesel.

00:00:27.495 --> 00:00:31.365
Now let's say I want to access keys of that object.

00:00:31.365 --> 00:00:34.530
So usually I would do it like car,

00:00:34.530 --> 00:00:38.624
then putting DOD and then key name that I want to access.

00:00:38.624 --> 00:00:41.065
And if I wanted to put it in a variable,

00:00:41.065 --> 00:00:42.890
I would usually do it like that.

00:00:42.890 --> 00:00:47.150
So I'm going to declare a new variable called engine.

00:00:47.150 --> 00:00:50.855
And then I would put car and attention.

00:00:50.855 --> 00:00:54.200
And if I wanted to pull all of these objects,

00:00:54.200 --> 00:00:57.455
I would create a separate variable for each.

00:00:57.455 --> 00:01:00.440
For example, const gears is going to be

00:01:00.440 --> 00:01:06.350
car gears and the same we will do for color, right?

00:01:06.350 --> 00:01:09.650
We can see this as three separate lines of code.

00:01:09.650 --> 00:01:13.145
Well, this is not very convenient in modern GPS,

00:01:13.145 --> 00:01:17.000
we can do something more simpler, object destruction.

00:01:17.000 --> 00:01:19.130
So instead of doing that,

00:01:19.130 --> 00:01:20.735
let me comment it out.

00:01:20.735 --> 00:01:23.060
We can replace it with one line.

00:01:23.060 --> 00:01:25.340
So we're gonna put const,

00:01:25.340 --> 00:01:28.040
then we're going to put curly brackets to

00:01:28.040 --> 00:01:31.895
specify that this is going to be object does structuring.

00:01:31.895 --> 00:01:34.130
Then we're going to put equals and

00:01:34.130 --> 00:01:36.395
the object that we would like to destructure,

00:01:36.395 --> 00:01:39.575
which is going to be car from that car object,

00:01:39.575 --> 00:01:42.620
we wanted to pull engine and gears.

00:01:42.620 --> 00:01:44.510
Let's say we don't need color.

00:01:44.510 --> 00:01:46.235
So in curly brackets,

00:01:46.235 --> 00:01:51.065
I specify what keys I want to pull from that object.

00:01:51.065 --> 00:01:53.255
So it's going to be color.

00:01:53.255 --> 00:01:55.820
And then I'm going to pull gears.

00:01:55.820 --> 00:01:58.280
Will that single line of code just

00:01:58.280 --> 00:02:02.300
replaced These two for color and gears?

00:02:02.300 --> 00:02:05.360
If we wanted to pull engine as well,

00:02:05.360 --> 00:02:07.880
we would just type engine here.

00:02:07.880 --> 00:02:09.950
And of course, it is very important to

00:02:09.950 --> 00:02:13.115
specify key name very strictly.

00:02:13.115 --> 00:02:15.215
Let's say if we have gears

00:02:15.215 --> 00:02:17.870
over here for some reason and they're capitalized,

00:02:17.870 --> 00:02:19.235
we don't know about that, right?

00:02:19.235 --> 00:02:21.485
And we destructure gears,

00:02:21.485 --> 00:02:23.660
it is going to be undefined because well,

00:02:23.660 --> 00:02:26.165
it does not exist on that object.

00:02:26.165 --> 00:02:30.785
Let's maybe try and console log, color.

00:02:30.785 --> 00:02:37.070
Like that. Let me quickly do it gears and also ancient.

00:02:37.070 --> 00:02:38.015
Okay.

00:02:38.015 --> 00:02:41.750
Let me poor Node file GS

00:02:41.750 --> 00:02:46.505
and you see Colorado and gears undefined engine diesel,

00:02:46.505 --> 00:02:48.080
since we have gears,

00:02:48.080 --> 00:02:51.050
objects starting from a capital letter,

00:02:51.050 --> 00:02:52.880
and we destructure gears which

00:02:52.880 --> 00:02:54.890
does not exist on that object.

00:02:54.890 --> 00:02:58.520
We have undefined, but other values are. All right.

00:02:58.520 --> 00:03:02.240
So let's put it back and let's verify that it works.

00:03:02.240 --> 00:03:02.855
Awesome.

00:03:02.855 --> 00:03:04.850
Now we have Gears 5,

00:03:04.850 --> 00:03:06.560
that object is structuring,

00:03:06.560 --> 00:03:09.170
think, is a really powerful tool.

00:03:09.170 --> 00:03:11.600
This is basically all it does.

00:03:11.600 --> 00:03:15.020
It just pulls keys from an object.

00:03:15.020 --> 00:03:15.785
That's it.

00:03:15.785 --> 00:03:18.170
This is basically the same as

00:03:18.170 --> 00:03:21.575
doing this with those three separate lines.

00:03:21.575 --> 00:03:23.675
I would say this is just a shorthand.

00:03:23.675 --> 00:03:25.700
It does not bring something new.

00:03:25.700 --> 00:03:27.095
It is just a shorthand.

00:03:27.095 --> 00:03:28.820
There is one more thing to

00:03:28.820 --> 00:03:30.680
that object just structuring is that,

00:03:30.680 --> 00:03:33.650
let's say with the first approach with those three lines,

00:03:33.650 --> 00:03:36.034
we can easily rename variables.

00:03:36.034 --> 00:03:39.620
If I wanted to specify car engine,

00:03:39.620 --> 00:03:41.945
I would just rename the variable from

00:03:41.945 --> 00:03:44.420
engine to car engine, just like that.

00:03:44.420 --> 00:03:45.425
Pretty easy, right?

00:03:45.425 --> 00:03:46.880
But when the object is structuring,

00:03:46.880 --> 00:03:48.410
remember that we have to always

00:03:48.410 --> 00:03:50.930
specify strict key that we would

00:03:50.930 --> 00:03:52.190
like to destructure as

00:03:52.190 --> 00:03:55.280
otherwise debatable will not exist.

00:03:55.280 --> 00:03:57.305
The key will not exist on that object.

00:03:57.305 --> 00:03:58.970
So how can we renamed them?

00:03:58.970 --> 00:04:00.380
Well, in order to do that,

00:04:00.380 --> 00:04:01.820
Let's say instead of engine,

00:04:01.820 --> 00:04:04.325
we want to use car engine.

00:04:04.325 --> 00:04:06.710
I have to put colon and

00:04:06.710 --> 00:04:09.440
then the new name for that variable.

00:04:09.440 --> 00:04:12.034
So now from the car object,

00:04:12.034 --> 00:04:17.180
I pull engine and I renamed engine to car engine.

00:04:17.180 --> 00:04:19.445
Engine will not exist as a variable.

00:04:19.445 --> 00:04:21.500
It will appear as car engine.

00:04:21.500 --> 00:04:24.515
If I'm going to console log only engine,

00:04:24.515 --> 00:04:26.210
let's see what we will have.

00:04:26.210 --> 00:04:27.920
We will have reference error.

00:04:27.920 --> 00:04:29.375
Engine is not defined

00:04:29.375 --> 00:04:31.385
because this variable does not exist.

00:04:31.385 --> 00:04:33.800
We pulled the engine key,

00:04:33.800 --> 00:04:37.160
but the variable name is now car engine.

00:04:37.160 --> 00:04:40.235
So if we're going to reference car engine,

00:04:40.235 --> 00:04:42.605
it will not give us any error.

00:04:42.605 --> 00:04:43.745
I think it's clear.

00:04:43.745 --> 00:04:46.100
So the same with other keys,

00:04:46.100 --> 00:04:47.750
if you would like to rename color,

00:04:47.750 --> 00:04:50.915
we will put column and then car color.

00:04:50.915 --> 00:04:51.935
And that's it.

00:04:51.935 --> 00:04:53.000
Pretty easy, right?

00:04:53.000 --> 00:04:55.130
As a sad object destruction

00:04:55.130 --> 00:04:56.735
because it really powerful tool.

00:04:56.735 --> 00:04:59.600
We're going to use it a lot, especially in React.

00:04:59.600 --> 00:05:00.980
Let's take a look on

00:05:00.980 --> 00:05:03.740
a real example that we're going to use in React actually.

00:05:03.740 --> 00:05:05.525
So I'm going to create a function,

00:05:05.525 --> 00:05:08.180
let's say some function.

00:05:08.180 --> 00:05:12.275
And this sum function will receive an argument,

00:05:12.275 --> 00:05:15.035
let's call it arc car.

00:05:15.035 --> 00:05:16.775
We're going to expect that

00:05:16.775 --> 00:05:19.715
our car is going to be an object.

00:05:19.715 --> 00:05:22.295
And we can call some function.

00:05:22.295 --> 00:05:28.550
And we will supply our car object for our car, right?

00:05:28.550 --> 00:05:31.625
Let's quickly comment it out and

00:05:31.625 --> 00:05:35.045
let's try and console.log,

00:05:35.045 --> 00:05:38.285
arg, car like that.

00:05:38.285 --> 00:05:41.195
And we will see our object pretty simple.

00:05:41.195 --> 00:05:43.715
Now, let's say we wanted to actually

00:05:43.715 --> 00:05:46.520
cancel log separate keys from that object.

00:05:46.520 --> 00:05:49.835
So again, the same picture as we just did.

00:05:49.835 --> 00:05:53.750
So we either reference those keys by

00:05:53.750 --> 00:05:58.040
using arc car door key name syntax.

00:05:58.040 --> 00:06:01.820
For example, arc car dot color. Right?

00:06:01.820 --> 00:06:05.150
We have read, if I'm going to use engine,

00:06:05.150 --> 00:06:07.430
it is going to be disloyal if I

00:06:07.430 --> 00:06:09.770
supply a non-existing key,

00:06:09.770 --> 00:06:13.130
for example, square wheels, right?

00:06:13.130 --> 00:06:15.035
I'm going to get undefined because well,

00:06:15.035 --> 00:06:17.420
this key does not exist on that object.

00:06:17.420 --> 00:06:18.785
Instead of doing that,

00:06:18.785 --> 00:06:21.650
I can use objects restructuring and I can use

00:06:21.650 --> 00:06:25.025
it actually directly inside parenthesis.

00:06:25.025 --> 00:06:27.290
So the first way we can use actually

00:06:27.290 --> 00:06:30.380
this line of code, just like that.

00:06:30.380 --> 00:06:34.025
And it is going to work, right?

00:06:34.025 --> 00:06:36.125
Just like we discussed earlier.

00:06:36.125 --> 00:06:38.720
But instead, I can actually move

00:06:38.720 --> 00:06:42.635
that object is structuring directly inside parenthesis.

00:06:42.635 --> 00:06:47.000
So I'm just going to copy that and put it over here.

00:06:47.000 --> 00:06:50.255
And now we just removed even more line of code.

00:06:50.255 --> 00:06:58.384
Now I can directly access color and gears critical.

00:06:58.384 --> 00:07:00.020
Let's verify that we have

00:07:00.020 --> 00:07:02.300
read and five, which is correct.

00:07:02.300 --> 00:07:05.945
Nice. Let's extend this example a little bit more.

00:07:05.945 --> 00:07:10.145
What if I supply a second object to some function?

00:07:10.145 --> 00:07:14.000
So here, suppose that I supply a second object.

00:07:14.000 --> 00:07:15.485
Maybe it won't be car,

00:07:15.485 --> 00:07:17.915
but I'm just going to put it as a car. All right?

00:07:17.915 --> 00:07:23.375
And here I expect some object to,

00:07:23.375 --> 00:07:26.630
and I expect that this sum object two will

00:07:26.630 --> 00:07:30.065
have two keys, name and age.

00:07:30.065 --> 00:07:32.240
So I can reference them by doing

00:07:32.240 --> 00:07:35.915
some objects to dot name or age.

00:07:35.915 --> 00:07:38.390
But instead, I can again

00:07:38.390 --> 00:07:42.020
use object destruction directly over here.

00:07:42.020 --> 00:07:44.975
So I would put name and age.

00:07:44.975 --> 00:07:49.385
We use object destruction for both of our arguments.

00:07:49.385 --> 00:07:54.920
So arguments are separated with the comma, right?

00:07:54.920 --> 00:07:57.950
And the keys that we destructure is

00:07:57.950 --> 00:08:00.980
specified in curly brackets pretty

00:08:00.980 --> 00:08:04.235
easily that some function is a really good example

00:08:04.235 --> 00:08:06.650
because we will have a very similar piece

00:08:06.650 --> 00:08:08.135
of code in React.

00:08:08.135 --> 00:08:10.340
Let's combine object does

00:08:10.340 --> 00:08:12.964
structuring with default arguments.

00:08:12.964 --> 00:08:14.420
So what if I do not

00:08:14.420 --> 00:08:17.675
supply any arguments to some function?

00:08:17.675 --> 00:08:20.240
Let me remove second object from here.

00:08:20.240 --> 00:08:24.065
And let's say I destructure color and gears.

00:08:24.065 --> 00:08:26.900
Let's try it out. What will I get?

00:08:26.900 --> 00:08:28.910
I will get cannot

00:08:28.910 --> 00:08:31.685
destructure property color of undefined.

00:08:31.685 --> 00:08:32.600
What happened?

00:08:32.600 --> 00:08:34.340
Well, the thing is, as you remember,

00:08:34.340 --> 00:08:38.359
when we do not supply any arguments for some functions,

00:08:38.359 --> 00:08:41.135
that argument that we expect to a peer

00:08:41.135 --> 00:08:43.880
in that function is going to be undefined.

00:08:43.880 --> 00:08:45.995
So what we're basically doing here,

00:08:45.995 --> 00:08:51.125
we are trying to pull those keys from an empty value,

00:08:51.125 --> 00:08:53.750
which basically does not exist under the hood,

00:08:53.750 --> 00:08:54.995
it looks like that.

00:08:54.995 --> 00:09:00.140
So we pull color and gears from undefined.

00:09:00.140 --> 00:09:02.075
But as you can see,

00:09:02.075 --> 00:09:05.285
this syntax leads to type error.

00:09:05.285 --> 00:09:06.574
This is incorrect.

00:09:06.574 --> 00:09:07.835
So in this case,

00:09:07.835 --> 00:09:09.650
to actually fix that error,

00:09:09.650 --> 00:09:12.140
we can supply it a fallback value.

00:09:12.140 --> 00:09:14.825
So I'm going to put an empty object,

00:09:14.825 --> 00:09:17.510
and now let's see what we're going to have.

00:09:17.510 --> 00:09:19.715
We're going to have undefined, undefined.

00:09:19.715 --> 00:09:22.190
Well, this is expected because we did not

00:09:22.190 --> 00:09:25.130
supply any value for that object.

00:09:25.130 --> 00:09:29.240
Undefined value fall backs to an empty object.

00:09:29.240 --> 00:09:31.595
And from that empty object,

00:09:31.595 --> 00:09:35.675
disruptor non-existing keys, color and gears.

00:09:35.675 --> 00:09:39.800
Well, because they are not defined on an empty object.

00:09:39.800 --> 00:09:42.410
If I'm going to put color

00:09:42.410 --> 00:09:45.560
green and tried to console log it,

00:09:45.560 --> 00:09:47.690
you will see that the value will be green

00:09:47.690 --> 00:09:51.140
and gears is going to be undefined, right?

00:09:51.140 --> 00:09:52.310
Because again,

00:09:52.310 --> 00:09:57.020
our undefined value fall backs to that object.

00:09:57.020 --> 00:09:58.414
And from that object,

00:09:58.414 --> 00:10:01.445
we destructure color in gears.

00:10:01.445 --> 00:10:05.435
There is one more drawback actually with this approach.

00:10:05.435 --> 00:10:08.360
What if I supply an empty object here?

00:10:08.360 --> 00:10:09.620
As we might know,

00:10:09.620 --> 00:10:13.775
an empty object is already a defined value, right?

00:10:13.775 --> 00:10:15.350
I'm going to put an empty object.

00:10:15.350 --> 00:10:18.410
Can you guess what is going to be color and gears?

00:10:18.410 --> 00:10:19.505
Correct?

00:10:19.505 --> 00:10:21.155
It is going to be undefined.

00:10:21.155 --> 00:10:25.010
Undefined because now color and gears,

00:10:25.010 --> 00:10:27.020
they do not exist on that object.

00:10:27.020 --> 00:10:28.820
That's why we have undefined.

00:10:28.820 --> 00:10:29.465
Undefined.

00:10:29.465 --> 00:10:31.550
What if we want to somehow specify

00:10:31.550 --> 00:10:35.225
default values for separate object keys?

00:10:35.225 --> 00:10:39.260
The approach is the same by using the equal sign.

00:10:39.260 --> 00:10:43.445
So we can put color by default will be green.

00:10:43.445 --> 00:10:47.075
Let's put an empty object to verify that in a second.

00:10:47.075 --> 00:10:51.275
And gears by default will be six, right?

00:10:51.275 --> 00:10:53.435
Now if I'm going to run it,

00:10:53.435 --> 00:10:56.165
you will see green and six.

00:10:56.165 --> 00:10:57.215
Pretty awesome.

00:10:57.215 --> 00:11:00.290
So again, to extend that example,

00:11:00.290 --> 00:11:04.745
what if I remove the default value for the object itself,

00:11:04.745 --> 00:11:07.265
but I keep default values for

00:11:07.265 --> 00:11:09.410
separate keys and I'm going to

00:11:09.410 --> 00:11:12.305
remove an empty object here.

00:11:12.305 --> 00:11:14.300
Let's try and execute it. Again.

00:11:14.300 --> 00:11:15.440
We have cannot read

00:11:15.440 --> 00:11:18.020
property color of undefined because again,

00:11:18.020 --> 00:11:19.415
we have the same situation.

00:11:19.415 --> 00:11:21.860
These two keys are tried

00:11:21.860 --> 00:11:24.815
to be destructured from undefined,

00:11:24.815 --> 00:11:26.645
which leads to type error.

00:11:26.645 --> 00:11:28.190
So to fix that,

00:11:28.190 --> 00:11:31.925
we have to provide the fallback. This is important.

00:11:31.925 --> 00:11:35.345
We provide the fallback for the object itself,

00:11:35.345 --> 00:11:36.935
and here we provide

00:11:36.935 --> 00:11:40.910
default values for separate destructured keys.

00:11:40.910 --> 00:11:42.170
But I can agree that

00:11:42.170 --> 00:11:44.810
this syntax is a little bit of confusing.

00:11:44.810 --> 00:11:48.515
We can actually refactor it to make it look more nicer.

00:11:48.515 --> 00:11:50.090
Eventually we will end up with

00:11:50.090 --> 00:11:52.130
a more line of code, but it's fine.

00:11:52.130 --> 00:11:54.815
In parentheses, I'm going to keep

00:11:54.815 --> 00:11:58.235
only the default value for the object itself.

00:11:58.235 --> 00:12:00.170
And instead of using the structuring,

00:12:00.170 --> 00:12:03.395
I'm going to put the name for the argument.

00:12:03.395 --> 00:12:06.559
So let it be car object.

00:12:06.559 --> 00:12:08.390
And on a new line,

00:12:08.390 --> 00:12:11.840
I will actually put the restructuring for the object,

00:12:11.840 --> 00:12:16.490
const color gears equals Car object.

00:12:16.490 --> 00:12:18.980
Now you can see we actually separated

00:12:18.980 --> 00:12:21.380
the concerns in the parenthesis.

00:12:21.380 --> 00:12:24.530
We only specified default value

00:12:24.530 --> 00:12:27.530
for the object itself and on a new line,

00:12:27.530 --> 00:12:29.389
when we use this structuring,

00:12:29.389 --> 00:12:33.260
we specify default values for separate keys,

00:12:33.260 --> 00:12:34.445
as simple as that,

00:12:34.445 --> 00:12:36.110
I personally think this is one of

00:12:36.110 --> 00:12:38.705
the coolest features available in modern GIS.

00:12:38.705 --> 00:12:41.195
I really like it, but we also have

00:12:41.195 --> 00:12:44.090
a radius structuring next to object.

00:12:44.090 --> 00:12:46.984
The structuring, it is actually very, very similar.

00:12:46.984 --> 00:12:49.700
So let's say I have an array or

00:12:49.700 --> 00:12:53.165
maybe let me actually remove all of that.

00:12:53.165 --> 00:12:55.040
I'm going to keep some function,

00:12:55.040 --> 00:12:57.020
but I'm going to comment it out.

00:12:57.020 --> 00:13:00.320
And below, I'm going to create some array.

00:13:00.320 --> 00:13:02.870
And I'm going to put some values like 5,

00:13:02.870 --> 00:13:06.185
4, 3, 2, and 8.

00:13:06.185 --> 00:13:08.794
And the same manner as I apply

00:13:08.794 --> 00:13:11.510
objects restructuring to an object,

00:13:11.510 --> 00:13:14.105
I can use a radius structuring to

00:13:14.105 --> 00:13:16.895
signify that we use object destruction.

00:13:16.895 --> 00:13:18.604
We use curly brackets,

00:13:18.604 --> 00:13:22.055
but for arrays, we're going to use box brackets.

00:13:22.055 --> 00:13:23.495
So in the same manner,

00:13:23.495 --> 00:13:30.275
we're going to specify box brackets equal sum array.

00:13:30.275 --> 00:13:33.380
But this time we do not need to

00:13:33.380 --> 00:13:36.275
strictly follow the name of the keys.

00:13:36.275 --> 00:13:37.370
Will it object?

00:13:37.370 --> 00:13:38.630
We have key names,

00:13:38.630 --> 00:13:40.475
but in array we don't have it.

00:13:40.475 --> 00:13:42.185
In array, we have ordering.

00:13:42.185 --> 00:13:44.900
So when we apply object destruction,

00:13:44.900 --> 00:13:46.130
it does not matter in

00:13:46.130 --> 00:13:49.400
which order you destructure the keys.

00:13:49.400 --> 00:13:52.340
But in a rage is structuring. It is important.

00:13:52.340 --> 00:13:53.465
But you can give

00:13:53.465 --> 00:13:56.795
whatever names that you want for your future variables.

00:13:56.795 --> 00:13:59.390
For example, I'd like to disrupt your,

00:13:59.390 --> 00:14:02.210
the second element of that array.

00:14:02.210 --> 00:14:03.710
So in order to do that,

00:14:03.710 --> 00:14:08.135
I am required to first destructured the first element,

00:14:08.135 --> 00:14:10.295
the order that you specify in

00:14:10.295 --> 00:14:12.410
a radius structuring will be the same as

00:14:12.410 --> 00:14:14.360
the elements go in

00:14:14.360 --> 00:14:17.225
the original array to destructor the first element,

00:14:17.225 --> 00:14:20.705
I supply first element.

00:14:20.705 --> 00:14:23.915
And now I destructured The second element,

00:14:23.915 --> 00:14:26.885
second element, which is going to be 4.

00:14:26.885 --> 00:14:29.255
So first element will be 5,

00:14:29.255 --> 00:14:31.295
second element is going to be four.

00:14:31.295 --> 00:14:34.625
As you can see, the order is retained.

00:14:34.625 --> 00:14:37.100
First element five seconds 4.

00:14:37.100 --> 00:14:39.830
If I'm going to put third element here,

00:14:39.830 --> 00:14:41.390
can you guess the value?

00:14:41.390 --> 00:14:44.135
Well, yeah, it is going to be three.

00:14:44.135 --> 00:14:45.830
Let's check it out.

00:14:45.830 --> 00:14:48.859
Console log, first element,

00:14:48.859 --> 00:14:51.725
second element, and third element.

00:14:51.725 --> 00:14:55.310
Note file GS, what we see 5,

00:14:55.310 --> 00:14:58.445
4, 3, exactly the same values.

00:14:58.445 --> 00:15:03.680
If I, for some reason wanted to emit this element,

00:15:03.680 --> 00:15:06.605
Let's say I use it like that, right?

00:15:06.605 --> 00:15:08.570
Const, second element.

00:15:08.570 --> 00:15:10.385
Well, this is not going to work.

00:15:10.385 --> 00:15:12.740
Second element now is

00:15:12.740 --> 00:15:15.735
going to be the first element, which is five.

00:15:15.735 --> 00:15:18.415
If I console log it,

00:15:18.415 --> 00:15:20.380
you will see it, it'll be five.

00:15:20.380 --> 00:15:23.965
Because again, the order is important when you

00:15:23.965 --> 00:15:27.520
apply a restructuring because elements,

00:15:27.520 --> 00:15:31.090
they are ordered, they do not have key names.

00:15:31.090 --> 00:15:33.760
You can give any name to that variable,

00:15:33.760 --> 00:15:37.015
but you have to retain the order.

00:15:37.015 --> 00:15:39.340
I think it's pretty clear at last,

00:15:39.340 --> 00:15:41.590
I would say that a radius structuring is

00:15:41.590 --> 00:15:44.260
used in the same manner as object restructuring.

00:15:44.260 --> 00:15:45.400
If you want to do something

00:15:45.400 --> 00:15:47.649
similar with a radius structuring

00:15:47.649 --> 00:15:51.250
in parenthesis when are using function, it will work.

00:15:51.250 --> 00:15:55.180
The difference is only that with object destruction,

00:15:55.180 --> 00:15:56.230
q are required to use

00:15:56.230 --> 00:15:58.440
curly brackets with the radius structuring,

00:15:58.440 --> 00:16:01.820
you're going to use box brackets and also the ordering.

00:16:01.820 --> 00:16:03.545
Remember that in an array,

00:16:03.545 --> 00:16:06.590
elements are ordered and that's why you are

00:16:06.590 --> 00:16:10.235
required to destructure all previous elements.

00:16:10.235 --> 00:16:12.755
If you wanted to destructor the element number.

00:16:12.755 --> 00:16:15.905
And if I want to destructure fourth element,

00:16:15.905 --> 00:16:18.815
I am required to disrupt your first three.

00:16:18.815 --> 00:16:22.295
This is inevitable while in objects keys,

00:16:22.295 --> 00:16:23.915
they are not ordered.

00:16:23.915 --> 00:16:27.005
That's why you can use any ordering.

00:16:27.005 --> 00:16:29.000
When destruction the keys,

00:16:29.000 --> 00:16:32.210
That's it about object and a radius structuring.

00:16:32.210 --> 00:16:33.650
We're going to use it a lot

00:16:33.650 --> 00:16:35.495
and I hope it was clear for you.

00:16:35.495 --> 00:16:37.860
See you in the next one.
