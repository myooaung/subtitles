WEBVTT
1
00:00:01.520 --> 00:00:06.200
Now, before we move on, let's just discuss Java vs JavaScript.

2
00:00:07.620 --> 00:00:15.180
So right off the bat, just bear in mind, JavaScript and Java are two separate languages. Java is to

3
00:00:15.180 --> 00:00:17.190
JavaScript as ham is to a hamster.

4
00:00:19.010 --> 00:00:24.320
People often confuse Java and JavaScript, and maybe the reason is that JavaScript has actually borrowed

5
00:00:24.320 --> 00:00:25.580
a lot of ideas from Java.

6
00:00:26.610 --> 00:00:27.920
It's actually named after Java.

7
00:00:28.790 --> 00:00:32.880
And if we travel back in time about five years or so, this would be a simple comparison.

8
00:00:32.900 --> 00:00:37.820
It would have just been Java is a general purpose programming language and JavaScript is used to make

9
00:00:37.820 --> 00:00:39.500
websites animated and fun.

10
00:00:40.340 --> 00:00:42.200
But now JavaScript's grown up.

11
00:00:42.200 --> 00:00:45.110
We know that it's exploded, it's gone crazy.

12
00:00:45.350 --> 00:00:48.230
And the comparison between Java and JavaScript is more complicated.

13
00:00:49.130 --> 00:00:54.830
Perhaps the most fundamental difference between Java and JavaScript is that Java is considered a compiled

14
00:00:54.830 --> 00:00:55.850
programming language.

15
00:00:56.180 --> 00:01:01.230
JavaScript and other hand, is considered an interpreted scripting language. And this means that there are differences in

16
00:01:01.250 --> 00:01:02.120
their implementation.

17
00:01:02.840 --> 00:01:03.590
We've been through this.

18
00:01:03.590 --> 00:01:09.650
Remember, Java's compiled into bytecode and it runs on a virtual machine, whereas JavaScript can be

19
00:01:09.650 --> 00:01:13.640
interpreted directly by a browser in the syntax it is written in.

20
00:01:14.360 --> 00:01:19.460
Although, if you look at any JavaScript file sent over the web, you'll see that it's minified, it's condensed

21
00:01:19.610 --> 00:01:20.570
so you can barely read it.

22
00:01:21.050 --> 00:01:22.250
But this is the main difference.

23
00:01:23.360 --> 00:01:27.050
Now, just before we end, let's just state a few more points between JavaScript and Java.

24
00:01:27.710 --> 00:01:28.120
#1 One.

25
00:01:28.130 --> 00:01:30.120
They both run on the browser. JavaScript

26
00:01:30.140 --> 00:01:35.630
we know this already, runs on every single browser out there, and Java applets can also be run on a

27
00:01:35.630 --> 00:01:38.940
browser but they've been declining in popularity for various reasons

28
00:01:38.960 --> 00:01:41.210
some including compatibility and security.

29
00:01:42.370 --> 00:01:48.580
#2 Two. Both can run on a server. Java has long been a major workhorse of the web, with application servers like

30
00:01:48.580 --> 00:01:55.270
WebSphere, JBoss, Apache Tomcat running on a large portion of the web application seen by users today.

31
00:01:56.140 --> 00:02:01.870
And although a while ago, JavaScript wasn't that big in the server side of things, Node has come out

32
00:02:02.020 --> 00:02:06.670
and this has enabled JavaScript powered application servers to pop up all over the place.

33
00:02:08.310 --> 00:02:13.290
#3 Three. Both have libraries and frameworks. Libraries and frameworks help programmers by providing access

34
00:02:13.290 --> 00:02:17.250
to general and purpose specific code that can be reused over and over again.

35
00:02:17.760 --> 00:02:22.350
And both Java and JavaScript are mature enough to have a wide range of libraries and framework options

36
00:02:22.350 --> 00:02:22.860
available.

37
00:02:24.230 --> 00:02:29.510
#4 Four. The next thing worth mentioning is Two-Stage vs Runtime only debugging.  Java is compiled before it can

38
00:02:29.510 --> 00:02:29.990
be run,

39
00:02:30.020 --> 00:02:35.360
so if there are any structural problems with the code, they become apparent very quickly. And once it's running,

40
00:02:35.360 --> 00:02:40.880
IDE's often enable the developer to attach to the JVM to debug in real time.

41
00:02:41.920 --> 00:02:48.370
And remember, JavaScript is not compiled in the same way, so all bugs are found only at runtime. The debugging

42
00:02:48.370 --> 00:02:53.350
capabilities of JavaScript a highly dependent on the execution environment, and this can vary quite a

43
00:02:53.350 --> 00:02:53.590
bit.

44
00:02:55.340 --> 00:02:58.520
#5 Five. Write once, run everywhere vs Branching madness.

45
00:02:59.720 --> 00:03:04.400
What do I mean by this? Well, Java is specifically designed to enable developers to write code once and

46
00:03:04.400 --> 00:03:07.580
deploy it in the operating system without making changes.

47
00:03:07.850 --> 00:03:09.710
And in general, this does work as designed

48
00:03:10.130 --> 00:03:13.190
although sometimes there are hiccups depending on the JVM and the code used.

49
00:03:13.880 --> 00:03:15.230
And let's turn to JavaScript.

50
00:03:15.230 --> 00:03:20.450
Although JavaScript has a standard through ECMAScript, it is much more susceptible to the differences

51
00:03:20.450 --> 00:03:21.890
in execution environments

52
00:03:22.430 --> 00:03:24.100
normally in the form of different browsers.

53
00:03:24.500 --> 00:03:28.400
And while it's frustrating for developers to write JavaScript code for different environments,

54
00:03:28.730 --> 00:03:33.830
one silver lining is that the program itself can query the environment to decide what branch of code

55
00:03:33.830 --> 00:03:35.690
to run for that specific environment.

56
00:03:37.440 --> 00:03:42.960
#6 Six. Static vs Dynamic Type checking. Java uses static type checking, where the type of a variable

57
00:03:42.960 --> 00:03:50.130
is checked at compile time. So you as a programmer must specify the type, integer, double string,

58
00:03:50.130 --> 00:03:51.480
etc. of any variable

59
00:03:51.480 --> 00:03:55.800
you create. JavaScript though, uses dynamic typing.

60
00:03:56.070 --> 00:04:01.050
So what this means is that it's not required for you and I to specify the type of variable we're creating.

61
00:04:01.740 --> 00:04:06.690
There are many pros and cons for the two differences between how Java does it and how JavaScript does it.

62
00:04:07.230 --> 00:04:12.970
But the primary advantage of static type checking right, this is Java, is that type errors are caught

63
00:04:12.990 --> 00:04:17.519
early in the development. And because the compiler knows exactly what data types are being used,

64
00:04:17.970 --> 00:04:22.320
code typically executes faster or/and uses less memory.

65
00:04:22.980 --> 00:04:30.630
But the quid pro quo is that the primary advantage of JavaScript, of dynamic type checking, is programmer

66
00:04:31.050 --> 00:04:31.920
productivity.

67
00:04:32.400 --> 00:04:35.090
You and I are free to design types at our leisure.

68
00:04:35.160 --> 00:04:37.560
We can work quickly and get the code out there.

