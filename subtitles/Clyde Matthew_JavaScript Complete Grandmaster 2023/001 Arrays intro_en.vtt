WEBVTT
1
00:00:00.570 --> 00:00:01.530
We've come a long way.

2
00:00:01.740 --> 00:00:06.570
We've learned about objects and always starting to get more and more advanced, and you're going to

3
00:00:06.570 --> 00:00:09.990
have to understand arrays when you come to programming.

4
00:00:10.680 --> 00:00:16.170
And I like to think of an array as a variable that stores multiple values, and I want to stress the

5
00:00:16.170 --> 00:00:18.510
word multiple values.

6
00:00:19.290 --> 00:00:22.110
We're going to see shortly what I mean by multiple values.

7
00:00:22.110 --> 00:00:24.720
But before we do, how do we identify an array?

8
00:00:25.260 --> 00:00:31.440
An object can always be identified by the curly brackets arrays of closely related to it.

9
00:00:31.680 --> 00:00:34.710
And you can identify an array with square brackets.

10
00:00:36.100 --> 00:00:42.310
And taking a step back, remember when we were discussing dot attacks in JavaScript, the 2.2 times

11
00:00:42.790 --> 00:00:48.520
these perimeters, which is just a fancy word for simple things like strings, numbers, balloons,

12
00:00:48.520 --> 00:00:51.670
no undefined and even the symbol.

13
00:00:52.090 --> 00:00:53.950
Those are all simple data types.

14
00:00:53.950 --> 00:00:57.790
But then we've also got the object, which is complex data types.

15
00:00:58.420 --> 00:01:03.310
Although everything in JavaScript is pretty much an object, for our sakes, it's always nice to break

16
00:01:03.310 --> 00:01:07.900
it down and go, Okay, cool, we've got objects that we know we've also got to raise, and we've also

17
00:01:07.900 --> 00:01:09.070
got another one functions.

18
00:01:10.420 --> 00:01:13.180
And those are the second type of data types in JavaScript.

19
00:01:13.780 --> 00:01:18.760
OK, so putting that aside, you kind of we arrays that in it's a dot, a type of JavaScript.

20
00:01:19.450 --> 00:01:21.730
But they are just a special kind of object.

21
00:01:22.150 --> 00:01:23.050
And I'll prove this to you.

22
00:01:23.380 --> 00:01:24.010
Let's have a look.

23
00:01:24.790 --> 00:01:26.200
An array is just an object.

24
00:01:26.410 --> 00:01:32.410
And remember how, he said, to identify Mario or to create an array, you have to have square brackets,

25
00:01:32.800 --> 00:01:34.660
objects or curly brackets.

26
00:01:35.710 --> 00:01:38.410
So list find an array lit a equal.

27
00:01:39.670 --> 00:01:42.040
Opening kilo square brackets that's set with grated.

28
00:01:42.820 --> 00:01:47.770
And to show you that this array is actually an object, we can just go type of a.

29
00:01:49.180 --> 00:01:49.640
There he got.

30
00:01:49.940 --> 00:01:50.480
It's an object.

31
00:01:51.890 --> 00:01:56.300
And remember, I said an array is like a variable that can store multiple values.

32
00:01:57.110 --> 00:01:59.030
Well, how do we work with chunks of data?

33
00:01:59.720 --> 00:02:01.570
For example, let's take a very easy scenario.

34
00:02:01.580 --> 00:02:04.620
Let's say we've got the numbers one, three, five and seven.

35
00:02:04.640 --> 00:02:05.510
How do we store that?

36
00:02:06.580 --> 00:02:07.960
Can we just thought as a string?

37
00:02:09.500 --> 00:02:12.890
Well, I guess we can we can just write it at one two, five seven.

38
00:02:13.490 --> 00:02:14.480
That's just awkward.

39
00:02:15.230 --> 00:02:17.510
What about if we wanted to add the numbers together?

40
00:02:17.570 --> 00:02:21.100
What about if we wanted to extract just the five and leave the one, three and seven?

41
00:02:21.110 --> 00:02:22.970
We can't really do that with strings, can we?

42
00:02:23.090 --> 00:02:23.950
It's awkward back.

43
00:02:23.960 --> 00:02:24.740
It's very difficult.

44
00:02:25.490 --> 00:02:29.300
Let me just show you now a quick example of working with numbers in an array.

45
00:02:29.720 --> 00:02:31.880
So how do we store numbers and what's the best way?

46
00:02:32.300 --> 00:02:34.370
Because strings are awkward.

47
00:02:35.480 --> 00:02:39.320
So let's define an array, and let's call it numbers for lack of a better word.

48
00:02:40.310 --> 00:02:43.640
And our numbers are one, three, five and seven.

49
00:02:45.600 --> 00:02:47.670
Now we've created an array called numbers.

50
00:02:48.150 --> 00:02:48.630
That's it.

51
00:02:48.810 --> 00:02:49.990
That's how easy it is.

52
00:02:50.010 --> 00:02:51.810
And if we console.log up numbers.

53
00:02:53.560 --> 00:02:58.120
And we open it up, you can really see the consoles telling us that the four elements in this array,

54
00:02:58.150 --> 00:02:59.080
we can open it up.

55
00:03:00.260 --> 00:03:02.810
And look at that is a few things worth noting here.

56
00:03:03.470 --> 00:03:06.760
One is this array has a magical linked property.

57
00:03:06.770 --> 00:03:07.610
Where do they come from?

58
00:03:08.090 --> 00:03:09.000
We're going to see shortly.

59
00:03:09.020 --> 00:03:09.470
Don't worry.

60
00:03:10.540 --> 00:03:15.160
Second thing worth noting is that the key value pairs those keys.

61
00:03:16.250 --> 00:03:17.920
Starts at the numbers zero.

62
00:03:18.340 --> 00:03:19.090
Why is that?

63
00:03:19.240 --> 00:03:25.420
Well, you got to think about the word numbers that we've created as a reference to memory location.

64
00:03:25.930 --> 00:03:29.560
And if we type number numbers.

65
00:03:31.200 --> 00:03:31.820
Zero.

66
00:03:33.890 --> 00:03:40.640
All that they're trying to do is it's referencing a location in memory that has its elements away from

67
00:03:40.640 --> 00:03:41.390
the reference point.

68
00:03:41.660 --> 00:03:43.340
Yeah, we see the reference point to zero.

69
00:03:43.880 --> 00:03:47.720
So it's taking the very first element finds in memory.

70
00:03:47.840 --> 00:03:53.840
So in this way, that index those numbers zero, one, two and three, those are used as an offset.

71
00:03:54.140 --> 00:04:00.620
And in our example, the very first element in the array, the number one or the key of zero.

72
00:04:01.340 --> 00:04:08.240
It's elements away from its reference point, which is why when we talk numbers zero, it should give

73
00:04:08.240 --> 00:04:14.600
us one because we are literally pointing to the same memory location that that is stored in hope.

74
00:04:14.600 --> 00:04:17.329
It's making sense, but we're going to see a lot more examples of this later.

75
00:04:18.079 --> 00:04:18.769
Let's move on.

76
00:04:20.649 --> 00:04:26.320
So we've just seen a raise or daughter structures that take in multiple values, arrays don't have key

77
00:04:26.320 --> 00:04:27.160
value pays.

78
00:04:27.730 --> 00:04:29.590
They have singular pieces of data.

79
00:04:30.710 --> 00:04:35.810
But what's cool is that arrays are objects so they can contain objects as well.

80
00:04:36.940 --> 00:04:39.490
And we've seen a raise or a special kind of object.

81
00:04:39.940 --> 00:04:45.760
But one difference is that a raise of a magical lynx property, the first venue in the ray is stored

82
00:04:45.760 --> 00:04:47.440
under the key zero.

83
00:04:47.920 --> 00:04:55.030
And remember when we looked at the JavaScript object model where the mascot spec defines an object,

84
00:04:55.030 --> 00:05:00.910
it's just a reference, just a dictionary where you've got the keys and those keys point to a property

85
00:05:00.910 --> 00:05:01.390
attribute.

86
00:05:02.080 --> 00:05:04.090
Well, it's the same with arrays.

87
00:05:05.020 --> 00:05:07.780
Let me show you an example, so let's look at the right model.

88
00:05:08.500 --> 00:05:10.610
How does the engine treat an array?

89
00:05:10.630 --> 00:05:12.370
We does this lynx property come from?

90
00:05:13.000 --> 00:05:17.620
Well, let's define an array that just holds one value and that values the later eight.

91
00:05:18.280 --> 00:05:24.910
So we're going to array the race called litters score two properties a length, and it's got a key and

92
00:05:24.910 --> 00:05:29.020
the key starts at zero and they point to property attributes.

93
00:05:29.440 --> 00:05:31.960
The length property has a value of one.

94
00:05:32.500 --> 00:05:35.980
But it's innumerable and configurable properties or seek defaults.

95
00:05:36.250 --> 00:05:40.810
Because this is in built in JavaScript, we don't want to be missing this around and reconfiguring it.

96
00:05:41.200 --> 00:05:46.450
The key of zero points to the value A and that always the default two values.

97
00:05:46.780 --> 00:05:50.740
Let's take our array and let's push be into it.

98
00:05:51.490 --> 00:05:52.270
What happens then?

99
00:05:53.170 --> 00:05:55.560
Well, now you're going to have an extra key.

100
00:05:55.570 --> 00:05:56.770
You're going to have a one.

101
00:05:57.550 --> 00:06:03.340
That one will point to the value B and the length and the key of zero point exactly the same things

102
00:06:03.340 --> 00:06:03.910
as before.

103
00:06:04.300 --> 00:06:07.080
I hope this is starting to become more intuitive to you.

104
00:06:07.390 --> 00:06:08.290
Don't worry too much.

105
00:06:08.290 --> 00:06:13.420
I know this is a bit theoretical because this is what the engine and this is what the arrays and objects

106
00:06:13.420 --> 00:06:14.500
are doing in the background.

107
00:06:14.650 --> 00:06:17.440
A lot of people don't understand this, but it is going to help you.

108
00:06:17.650 --> 00:06:18.310
So let's move on.

109
00:06:18.310 --> 00:06:19.540
Let me show you some more examples.

