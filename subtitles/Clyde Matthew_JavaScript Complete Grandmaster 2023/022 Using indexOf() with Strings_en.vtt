WEBVTT
1
00:00:01.210 --> 00:00:02.280
Hmm, hmm.

2
00:00:02.380 --> 00:00:03.740
I'm having tons of fun.

3
00:00:03.760 --> 00:00:04.630
Hope you learned a lot.

4
00:00:04.990 --> 00:00:06.700
Let's just go back to where we started.

5
00:00:06.730 --> 00:00:12.370
Remember, we said it only exists on 2.2 times this index of method, the first on type we've looked

6
00:00:12.370 --> 00:00:13.180
at as a race.

7
00:00:13.750 --> 00:00:15.310
What do you think the second type is?

8
00:00:15.760 --> 00:00:16.920
Well, it is.

9
00:00:16.930 --> 00:00:18.240
Drumroll, please.

10
00:00:21.210 --> 00:00:24.360
So this one slide you're looking at here is a very important one.

11
00:00:24.530 --> 00:00:27.360
Gives you a very high level overview of this index of method.

12
00:00:27.960 --> 00:00:30.180
We've looked at a ton of examples with arrays.

13
00:00:30.720 --> 00:00:36.060
I want to finish off this lecture now by looking at examples with us working with strings.

14
00:00:36.510 --> 00:00:38.130
It starts seeing how that works.

15
00:00:38.340 --> 00:00:39.420
It's going to be a lot of fun.

16
00:00:39.630 --> 00:00:40.170
Trust me.

17
00:00:40.710 --> 00:00:43.110
Hey, wow, OK.

18
00:00:43.200 --> 00:00:44.160
This is really cool.

19
00:00:44.430 --> 00:00:45.770
We've just done arrays.

20
00:00:45.780 --> 00:00:49.440
But now I want us to get on to strings.

21
00:00:49.860 --> 00:00:50.610
How does that work?

22
00:00:50.820 --> 00:00:51.870
And it's really exciting.

23
00:00:51.870 --> 00:00:52.510
You'll see none.

24
00:00:52.530 --> 00:00:53.640
So let's jump into it.

25
00:00:54.600 --> 00:00:54.950
Cool.

26
00:00:55.050 --> 00:00:55.350
OK.

27
00:00:55.380 --> 00:00:56.070
Where do we start?

28
00:00:56.360 --> 00:01:00.980
Oh, the first thing I want to show you here is if we go to our console, we console third.

29
00:01:00.990 --> 00:01:05.910
The array is just actually clear console and let's do the same with the string.

30
00:01:09.260 --> 00:01:14.660
Pretty straightforward, we open the string, we look at a prototype, we scroll down, and there,

31
00:01:14.720 --> 00:01:21.470
my dear students, is index of this is the second daughter type in JavaScript that gives us access to

32
00:01:21.470 --> 00:01:23.510
this awesome, useful method.

33
00:01:24.560 --> 00:01:28.490
So you go, I just wanted to prove to you that it is found on this data type as well.

34
00:01:28.850 --> 00:01:32.840
If we go back to our coding it, it's a late start looking at this in action.

35
00:01:33.560 --> 00:01:35.710
So let's delete our erasure.

36
00:01:35.750 --> 00:01:40.700
We've looked at arrays it now creates, I don't know, a sentence.

37
00:01:42.310 --> 00:01:43.540
And it's just a.

38
00:01:45.160 --> 00:01:46.690
Hello, world.

39
00:01:48.080 --> 00:01:49.490
The universe.

40
00:01:51.310 --> 00:01:54.190
Often what's wrong with my typing today welcomes you?

41
00:01:55.440 --> 00:01:58.650
So these are so intense, we know this is of Typekit strength.

42
00:01:58.680 --> 00:02:03.630
How do we know that all of its console console.log type of sentence?

43
00:02:03.780 --> 00:02:08.520
And it's pretty obvious that we know it's a string and because we know it's a string, we know we have

44
00:02:08.520 --> 00:02:10.320
access to this index of method.

45
00:02:11.070 --> 00:02:14.700
So let's define a variable called in its axis, our sentence.

46
00:02:16.680 --> 00:02:18.510
And let's search for something.

47
00:02:18.610 --> 00:02:22.080
Let's search for the word welcomes.

48
00:02:22.920 --> 00:02:24.090
Let's see if that's in here.

49
00:02:24.780 --> 00:02:25.980
Where do you think that would be?

50
00:02:26.310 --> 00:02:27.240
It's console.log.

51
00:02:27.270 --> 00:02:31.350
Email to the screen and we get a number 26 six.

52
00:02:32.220 --> 00:02:32.510
Why?

53
00:02:32.530 --> 00:02:33.150
Twenty six?

54
00:02:33.840 --> 00:02:35.190
Well, let's start counting together.

55
00:02:35.460 --> 00:02:44.010
We know this is index zero one two three four five six seven eight nine 10, 11, 12, 13, 14, 15,

56
00:02:44.010 --> 00:02:54.060
16, 17, 18, 19, 20, 21, 22, 23, 24, 25 and of course, 26 is we welcome.

57
00:02:54.060 --> 00:02:58.230
This begins a very useful method.

58
00:03:00.040 --> 00:03:07.510
This define a constant call, I don't know, sentence again, and let's just say here, are you learning

59
00:03:08.710 --> 00:03:10.450
a lot in this course?

60
00:03:10.480 --> 00:03:11.110
I hope so.

61
00:03:12.420 --> 00:03:13.110
Keep learning.

62
00:03:14.620 --> 00:03:18.130
And so let's start using this index of let's start getting a more intuitive feel.

63
00:03:18.400 --> 00:03:21.610
Let's define a new JavaScript variable called search word.

64
00:03:22.120 --> 00:03:26.740
This is what we want to search for, and let's say we want to search for the new word learning.

65
00:03:27.520 --> 00:03:31.030
You can see, firstly, straight off the bat, we have two words don't we?

66
00:03:31.420 --> 00:03:32.290
Learning and learning?

67
00:03:33.770 --> 00:03:34.700
So just bear that in mind.

68
00:03:35.020 --> 00:03:37.910
So this define a new variable called first time.

69
00:03:38.900 --> 00:03:47.410
And let's access our sentence constant, that's access this index of method, and let's search usage

70
00:03:47.420 --> 00:03:47.630
would.

71
00:03:49.590 --> 00:03:51.180
It's console.log this first time out.

72
00:03:52.270 --> 00:03:57.490
It's ait's and we know it's AIDS because it's the eighth character from the very beginning.

73
00:03:57.730 --> 00:04:00.010
Is this the first learning word?

74
00:04:01.030 --> 00:04:05.020
But now how do we access the second learning word?

75
00:04:05.560 --> 00:04:06.400
How we do that?

76
00:04:07.410 --> 00:04:11.730
Well, let me give you a clue, let's utilize the second argument in the index of method.

77
00:04:12.510 --> 00:04:18.240
It's all we have to do is is to find a new variable called second time.

78
00:04:19.339 --> 00:04:23.450
This next sentence just realized the spotless and gritty.

79
00:04:24.700 --> 00:04:25.660
Sentence.

80
00:04:27.600 --> 00:04:28.320
So they we go.

81
00:04:28.920 --> 00:04:32.210
Let's access index of what we want to do now.

82
00:04:32.280 --> 00:04:34.170
We want to search for our search word, don't we?

83
00:04:35.520 --> 00:04:43.240
This time, we want to utilize the starting point, and where do we want to start, what is sought after?

84
00:04:43.290 --> 00:04:46.890
It's founded first item, which is the first time plus one.

85
00:04:47.770 --> 00:04:53.940
So now we know it's going to search through our array, but only starting after we've passed the first

86
00:04:53.940 --> 00:04:54.600
learning word.

87
00:04:56.270 --> 00:04:57.670
I hope it's making sense.

88
00:04:58.120 --> 00:05:03.010
If we console.log this out, we get to 44, which is exactly what we'd expect.

89
00:05:03.430 --> 00:05:08.110
Using index of this way can be very useful in your code and you can do a lot of things with it.

90
00:05:08.140 --> 00:05:08.580
I don't know.

91
00:05:08.590 --> 00:05:10.300
Let's give you an example.

92
00:05:10.300 --> 00:05:12.250
Let's define a variable called solution one.

93
00:05:12.550 --> 00:05:18.130
Let's use template literals and let's say the index of the first, OK?

94
00:05:19.210 --> 00:05:22.120
And we use here the variable search word.

95
00:05:25.900 --> 00:05:28.390
Word from the beginning.

96
00:05:29.980 --> 00:05:30.400
Is.

97
00:05:31.790 --> 00:05:33.650
And he will go first time.

98
00:05:36.680 --> 00:05:38.630
And if we return this to the screen.

99
00:05:40.040 --> 00:05:44.780
We literally get console.log to us, the index on the first learning word from the beginning is eight.

100
00:05:45.590 --> 00:05:47.360
How awesome is this?

101
00:05:47.900 --> 00:05:53.000
We combining a lot of things that we combining temperate literals with combining the dollar sign curly

102
00:05:53.000 --> 00:06:00.110
braces to incorporate expressions and variables within our team, the drum steamy, cool and it's going

103
00:06:00.110 --> 00:06:01.290
to help you a lot along the way.

104
00:06:01.310 --> 00:06:03.290
Of course, we can do the same full solution to.

105
00:06:04.320 --> 00:06:09.900
Solution to why don't we just copy this instead of doing it all again?

106
00:06:11.930 --> 00:06:13.640
And we know this is the second.

107
00:06:15.290 --> 00:06:18.260
Surgery from the beginning is not first time, but it's.

108
00:06:19.290 --> 00:06:20.130
Second time.

109
00:06:23.230 --> 00:06:25.300
And if we return that.

110
00:06:27.090 --> 00:06:31.920
We get exactly the same thing, but now we are referencing the second learning word coup.

111
00:06:32.270 --> 00:06:32.860
Okay.

112
00:06:33.200 --> 00:06:33.700
Sorry.

113
00:06:33.710 --> 00:06:38.210
And sometimes they get carried away and I'm maybe going a bit more advanced than you need to know right

114
00:06:38.210 --> 00:06:38.480
now.

115
00:06:38.480 --> 00:06:40.700
But trust me, this will help you in your coding career.

116
00:06:40.970 --> 00:06:42.950
And I want you to become a master at all this stuff.

117
00:06:43.740 --> 00:06:45.260
Hope is starting to make sense.

118
00:06:45.800 --> 00:06:48.710
The other thing I want to show you is let's delete everything.

119
00:06:49.100 --> 00:06:51.620
I want to show you that index of is case sensitive.

120
00:06:51.800 --> 00:06:59.840
So what I mean will, if we have a word and let's say the word is red dog, if we now console.log and

121
00:06:59.840 --> 00:07:06.140
we exist our word string, we accessed the index of method and we search for dog.

122
00:07:08.020 --> 00:07:09.340
We know that it exists.

123
00:07:09.570 --> 00:07:12.730
Again, this would make sense, but what about if we did the same?

124
00:07:12.940 --> 00:07:15.430
But yeah, we want to look for the word red.

125
00:07:16.240 --> 00:07:17.890
As you can see, it's case sensitive.

126
00:07:17.890 --> 00:07:21.460
We returned negative one A. A. It does not exist.

127
00:07:21.820 --> 00:07:25.090
If we change the small R to Big R, it does exist.

128
00:07:25.090 --> 00:07:28.480
It's in fact the very first item in our era.

129
00:07:28.990 --> 00:07:29.510
Cool.

130
00:07:29.740 --> 00:07:31.720
I hope you're learning a ton.

131
00:07:31.810 --> 00:07:39.070
The last thing I want to get across is that zero does not evaluate the true and negative one doesn't

132
00:07:39.070 --> 00:07:40.300
evaluate to false.

133
00:07:40.870 --> 00:07:44.880
Remember, if we've got a small R, it's a negative one doesn't coerce to false.

134
00:07:44.890 --> 00:07:47.680
It's kind of a weird nuance when it comes to this method.

135
00:07:48.130 --> 00:07:50.050
So how do I prove this to you?

136
00:07:50.410 --> 00:07:53.470
Well, let me prove it to you by using JavaScript.

137
00:07:53.740 --> 00:08:03.490
If statement and what I want to compete here, I want to say if the word riot contains, say, red.

138
00:08:05.880 --> 00:08:12.690
It's dense evaluates to false, then let's execute this kind of, let's say, console log.

139
00:08:14.250 --> 00:08:17.160
This is the correct answer.

140
00:08:19.260 --> 00:08:19.760
Answer.

141
00:08:21.080 --> 00:08:21.270
I'll.

142
00:08:23.070 --> 00:08:27.960
Console log, this is the wrong answer.

143
00:08:29.200 --> 00:08:35.169
And now you'll see a problem, you'll see that because of what is returned to us is the wrong answer.

144
00:08:35.770 --> 00:08:44.260
We know that the small are should not exist in our street because it only has the Capital R rate.

145
00:08:45.160 --> 00:08:48.910
So why are we hitting the second console log in our statement?

146
00:08:50.540 --> 00:08:55.460
The reason is is that the negative one does not evaluates to false.

147
00:08:56.210 --> 00:09:00.470
So therefore, we are hitting this answer and it's the wrong answer.

148
00:09:00.860 --> 00:09:08.000
Therefore, the point I'm trying to make is that we in checking if a specific string exists within another

149
00:09:08.000 --> 00:09:11.420
string, the correct way is to use negative one.

150
00:09:11.870 --> 00:09:15.500
For example, if we replaced false with negative one.

151
00:09:16.990 --> 00:09:17.890
Why is this not working?

152
00:09:18.460 --> 00:09:19.300
Negative one?

153
00:09:20.250 --> 00:09:23.140
The we got to we get the correct answer this time.

154
00:09:23.970 --> 00:09:25.460
Very, very important point.

155
00:09:25.480 --> 00:09:27.130
I've just shared with you.

156
00:09:27.250 --> 00:09:28.270
Please keep that in mind.

157
00:09:28.990 --> 00:09:30.160
So there you have it.

158
00:09:30.220 --> 00:09:32.280
We've just use index of the race.

159
00:09:32.440 --> 00:09:33.940
We've just used it with strings.

160
00:09:34.450 --> 00:09:35.680
We've discussed various ways.

161
00:09:35.680 --> 00:09:36.460
You can use it.

162
00:09:36.550 --> 00:09:37.930
We know that it's case sensitive.

163
00:09:37.930 --> 00:09:41.470
We know that you can't kind of coerce Sidney into one to false.

164
00:09:42.160 --> 00:09:43.900
And these are pretty advanced topics.

165
00:09:44.260 --> 00:09:45.610
So don't take it for granted.

166
00:09:45.640 --> 00:09:47.920
Celebrate these small wins.

167
00:09:48.590 --> 00:09:51.340
But anyway, let's move on and I'll see you in the next picture.

