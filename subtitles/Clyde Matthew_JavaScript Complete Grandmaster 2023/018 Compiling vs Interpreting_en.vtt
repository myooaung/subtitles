WEBVTT
1
00:00:00.150 --> 00:00:02.670
We've looked at interpreted code, we've looked at compiled code.

2
00:00:03.090 --> 00:00:05.490
The question is now, um, what's better?

3
00:00:06.060 --> 00:00:09.000
And with most things in life, there's not one clear answer.

4
00:00:09.630 --> 00:00:12.750
Which ones best? Well, they both have their "goods" and they both have their "bads".

5
00:00:13.080 --> 00:00:18.030
Um, so compiled code, as you can imagine, is optimized for the CPU.

6
00:00:18.750 --> 00:00:24.300
And as such, it's quicker generally, and you don't have to send your source code to other people so

7
00:00:24.300 --> 00:00:27.450
you can keep it very tight and secretive. You've

8
00:00:27.450 --> 00:00:29.790
got disadvantages with compilers as well, though.

9
00:00:30.450 --> 00:00:37.410
And the biggest disadvantage is that if you compile on a PC, that executable file that's generated

10
00:00:37.410 --> 00:00:38.940
won't typically work on a Mac.

11
00:00:39.750 --> 00:00:44.520
So in fact, it often needs to be compiled separately for different kinds of CPU, even on the same platform.

12
00:00:44.670 --> 00:00:49.200
And when you're having to write code and compile for different CPUs, that's an extra step.

13
00:00:49.650 --> 00:00:51.840
So it takes you more time, and time is money.

14
00:00:52.590 --> 00:00:54.330
So then, lets look at interpret code. Interpreted code

15
00:00:54.450 --> 00:01:00.180
on the other hand, the biggest benefit by far, is that you don't really care what kind of machine is

16
00:01:00.180 --> 00:01:06.150
on the other end, because you are not providing the machine could with an interpreted language, you

17
00:01:06.150 --> 00:01:11.400
are just sending the source code and you let the other side take care of it so it can be more portable

18
00:01:11.400 --> 00:01:13.240
and more flexible across platforms.

19
00:01:13.260 --> 00:01:15.120
This is what makes it so dynamic and awesome.

20
00:01:16.240 --> 00:01:17.650
But it also has its downsides.

21
00:01:17.980 --> 00:01:23.260
The quid pro quo is that everyone has to have an interpreter installed on their machine that can actually

22
00:01:23.260 --> 00:01:25.300
convert that source code into machine code.

23
00:01:26.620 --> 00:01:30.440
It can also be a bit slower because you have to interpret every time the program is run.

24
00:01:31.510 --> 00:01:36.790
And yes, the source code is public because you're sending it to everyone who needs to run the program.

25
00:01:37.330 --> 00:01:41.680
And as you guessed it, JavaScript is an interpreted language machine code.

26
00:01:43.000 --> 00:01:46.840
It can also be a bit slower because you have to interpret every time the program is run.

27
00:01:47.890 --> 00:01:53.170
(sorry, repetition error here) And yes, the source code is public because you're sending it to everyone who needs to run the program.

28
00:01:53.710 --> 00:01:57.650
And as you guessed us, JavaScript is an interpreted language machine.

