WEBVTT
1

00:00:00.110  -->  00:00:06.430
Hi with the Mac in this video we're looking at implementing the second assignment which is the cue.

2

00:00:06.600  -->  00:00:08.520
These assignments have multiple parts.

3

00:00:08.550  -->  00:00:13.610
The first one to re-implement some methods in the linked list and to implement a couple of new ones

4

00:00:14.340  -->  00:00:21.860
and then to create the linked queue methods as well which were just a wrapper to the linked list.

5

00:00:22.020  -->  00:00:27.270
In this video we're going to be explaining all of that how it works together and implementing the methods

6

00:00:27.270  -->  00:00:28.580
.

7

00:00:28.830  -->  00:00:36.120
The ads start to list although renamed does the same thing as the ad solist method from the last assignment

8

00:00:36.120  -->  00:00:36.360
.

9

00:00:36.360  -->  00:00:42.720
It just adds a note at the beginning of the list what we have to do here is just as we did in the last

10

00:00:42.840  -->  00:00:52.960
assignment if the route is defined then say that the nodes next node the new node next node is the root

11

00:00:53.340  -->  00:00:58.180
and finally assign the root to be equal to the next node to the new unit.

12

00:00:58.230  -->  00:01:00.810
Sorry.

13

00:01:00.810  -->  00:01:06.270
So what we're doing here is very fine that the root has a value and if it does then make sure the new

14

00:01:06.270  -->  00:01:14.160
node is appended at the start of the list by setting its next node to be the route that is currently

15

00:01:14.160  -->  00:01:15.960
there.

16

00:01:15.960  -->  00:01:21.910
Finally we make the root this variable appear to be equal to the node we're adding.

17

00:01:22.200  -->  00:01:28.200
And that plunks it in the beginning and puts it back another that here.

18

00:01:28.200  -->  00:01:35.280
I'm also going to implement the find method which we also did in the last assignment and all this has

19

00:01:35.280  -->  00:01:41.640
to do is create a marker which is going to be equal to the root while the marker has a value check if

20

00:01:41.640  -->  00:01:46.740
the marked her name is equal to the name we're looking for which is the parameter to the method and

21

00:01:46.760  -->  00:01:54.240
if it is returned the marker and if not say marker equals marker don't get next.

22

00:01:54.240  -->  00:02:01.170
And finally if we didn't find anything throughout that loop we're going to raise a lookup error which

23

00:02:01.170  -->  00:02:06.380
says that the name was not found in the linked list.

24

00:02:07.810  -->  00:02:08.390
OK.

25

00:02:08.700  -->  00:02:12.010
That's the find method which we implemented in the last video.

26

00:02:12.310  -->  00:02:14.080
So in the last assignment.

27

00:02:14.230  -->  00:02:20.460
Now let's go over to the size method which is just going to keep track of how many nodes are in the

28

00:02:20.460  -->  00:02:22.830
list.

29

00:02:22.830  -->  00:02:27.930
Once again I'm going to create a marker node which is going to be initialized at the root while the

30

00:02:27.930  -->  00:02:29.540
marker has a value.

31

00:02:29.580  -->  00:02:36.450
I'm going to be keeping track of how many markers there are how many nodes the if a marker does not

32

00:02:36.450  -->  00:02:39.050
have a value that means it is none.

33

00:02:39.240  -->  00:02:42.580
And that means we've reached the end of the list.

34

00:02:42.990  -->  00:02:43.970
When that is the case.

35

00:02:44.010  -->  00:02:48.930
I no longer want to keep track of any loops or no one of the keep going through the loop and that is

36

00:02:48.930  -->  00:02:52.760
why we are testing for marker to not be known.

37

00:02:52.790  -->  00:02:59.060
Remember while marker means exactly the same as while marker is not None.

38

00:02:59.190  -->  00:03:03.780
These two this and this has the same meaning.

39

00:03:04.950  -->  00:03:10.650
So while marker then I'm going to keep track of the notes and how we're going to do that with a variable

40

00:03:10.650  -->  00:03:18.720
which I'm going to call count if the marker has a value count plus 1 and then marker is a marker.

41

00:03:18.720  -->  00:03:20.750
Don't get mixed.

42

00:03:20.790  -->  00:03:27.130
Finally at the very end we return count as that is how many Noach were visited with this loop.

43

00:03:28.080  -->  00:03:29.770
Hopefully this makes sense.

44

00:03:29.790  -->  00:03:32.370
All we're doing is creating an initial marter variable.

45

00:03:32.370  -->  00:03:36.730
Setting it up with a root which is a starting node setting the count to be zero.

46

00:03:36.810  -->  00:03:40.710
And while the marker has a value we're going to start counting.

47

00:03:40.830  -->  00:03:44.580
If the route is none the marker is going to be none.

48

00:03:44.820  -->  00:03:46.610
And this loop is not going to run.

49

00:03:46.800  -->  00:03:54.780
So we're going to return 0 because that's where the counties if the route has a value on a node then

50

00:03:54.870  -->  00:03:59.650
this loop is going to run at least once the count is going to increase by 1.

51

00:04:00.030  -->  00:04:04.370
And the market is going to become the markers next if that is none.

52

00:04:04.530  -->  00:04:07.120
We're going to return count which is going to be one.

53

00:04:07.200  -->  00:04:16.260
And so finally the more complex method is the remove and from least we're going to remove at the end

54

00:04:16.260  -->  00:04:16.980
.

55

00:04:16.980  -->  00:04:24.870
So what this has to do once again is iterate over each node and through that iteration find both the

56

00:04:24.870  -->  00:04:32.520
second to last node and the last note and sent the second to last nodes next node to be numb as opposed

57

00:04:32.520  -->  00:04:39.050
to the last node and finally returned the last note.

58

00:04:39.180  -->  00:04:40.860
Once again we have to iterate.

59

00:04:40.890  -->  00:04:43.760
So marker is self-taught root.

60

00:04:44.280  -->  00:04:54.380
And while marker we're going to do stuff we're going to do is say we have three nodes in our list.

61

00:04:54.660  -->  00:05:02.940
The marker is initially going to be the root which is the first note we need to find the last note but

62

00:05:02.940  -->  00:05:09.360
we also need to find the node before the last node so what would are going to be doing just keeping

63

00:05:09.360  -->  00:05:14.690
track of the marker and of the next node.

64

00:05:14.730  -->  00:05:16.840
So we're always going to be keeping track of two notes.

65

00:05:16.860  -->  00:05:25.620
The current node and the next node eventually when the next nodes next node is none.

66

00:05:25.620  -->  00:05:33.780
That means the next node is the last node which means the marker is the second to last node let's look

67

00:05:33.780  -->  00:05:35.750
at some code as well as the Mocca.

68

00:05:35.820  -->  00:05:41.470
We're going to be looking at the following node which is a marker getting next.

69

00:05:41.490  -->  00:05:49.830
This is just a variable which contains the node that the marker is pointing to in case of us having

70

00:05:50.130  -->  00:05:57.360
three nodes which I'm calling and depicting as x's here the marker would be the first X and the following

71

00:05:57.360  -->  00:05:59.110
noon would be the second x.

72

00:05:59.120  -->  00:06:01.290
Notice there is another node there as well.

73

00:06:01.290  -->  00:06:02.540
And finally there is none.

74

00:06:02.540  -->  00:06:03.600
At the end.

75

00:06:04.100  -->  00:06:04.530
OK.

76

00:06:04.630  -->  00:06:09.410
And this is just a depiction for you to look at.

77

00:06:09.460  -->  00:06:16.320
Now the marker is this one I'm following notice not one which means the following node is not the last

78

00:06:16.320  -->  00:06:16.920
node.

79

00:06:17.190  -->  00:06:19.040
There is one more.

80

00:06:20.310  -->  00:06:33.030
So what we'll do is if the following node has a value we'll say if not following no don't get next

81

00:06:36.320  -->  00:06:41.520
what this is doing is saying OK we've got the marker and we've got the following node.

82

00:06:42.270  -->  00:06:44.100
And then comes this line.

83

00:06:44.220  -->  00:06:49.140
If the where this line if the following note has a value which it does then we'll check for this one

84

00:06:49.140  -->  00:06:49.550
.

85

00:06:49.920  -->  00:06:57.840
If the following nodes next node does not have a value which in this case it does we're going to do

86

00:06:57.840  -->  00:06:58.580
something.

87

00:06:59.010  -->  00:07:02.280
So at first the mater is going to be this one.

88

00:07:02.370  -->  00:07:06.720
The following note is going to be this one and this statement is going to be false and it's not going

89

00:07:06.720  -->  00:07:11.770
to execute because this node is then and it has a value.

90

00:07:11.790  -->  00:07:19.800
However once we reach this to be the marker and this to be the following node this if statement is going

91

00:07:19.800  -->  00:07:26.080
to run and what is going to tell me is that because the following nodes next node is none.

92

00:07:26.100  -->  00:07:30.020
That means this node must be the last node.

93

00:07:30.030  -->  00:07:34.290
So what do I want to do when I've reached the last node.

94

00:07:34.350  -->  00:07:37.180
That's what should go inside this if statement here.

95

00:07:37.720  -->  00:07:46.410
And what I want to do is make sure that the last node is removed by making the marker point to none

96

00:07:46.410  -->  00:07:46.500
.

97

00:07:46.530  -->  00:07:52.720
And skipping this middle node there when that happens the marker will point to none.

98

00:07:52.890  -->  00:07:57.960
Nothing will point to this node and therefore it will just be erased from memory by Python.

99

00:07:58.270  -->  00:08:06.390
So what to do is a marker set next to be none and return the following node which is the note that we've

100

00:08:06.390  -->  00:08:09.870
deleted.

101

00:08:09.870  -->  00:08:16.260
Finally at the end of the while loop make sure to move your marker over to the next slot by doing marker

102

00:08:16.260  -->  00:08:19.240
equal Markert get next.

103

00:08:19.380  -->  00:08:24.990
Naturally if we return something this is not going to execute because we're going to be exiting the

104

00:08:25.200  -->  00:08:27.880
method in there.

105

00:08:29.460  -->  00:08:32.970
So there is one last thing that we have to take care of.

106

00:08:33.420  -->  00:08:37.800
Which is what happens if there is only one node in the list.

107

00:08:37.830  -->  00:08:41.330
If the route is by itself what happens then.

108

00:08:41.700  -->  00:08:45.060
Well here's what will happen with the current code.

109

00:08:45.060  -->  00:08:52.320
We would set the marker to be the route while the marker has a value which it does then we would get

110

00:08:52.350  -->  00:08:56.300
the following node which is the markers next node which is none.

111

00:08:56.310  -->  00:09:02.540
In this case is the following no one has a value which it doesn't we would run this but it doesn't.

112

00:09:02.640  -->  00:09:04.450
So we wouldn't run any of it.

113

00:09:05.220  -->  00:09:07.620
And then we would say a marker equals marker to get next.

114

00:09:07.650  -->  00:09:08.990
That would be none.

115

00:09:09.090  -->  00:09:15.330
This would fail and then we would return none which is the default for any Python method.

116

00:09:15.540  -->  00:09:22.600
So if the route is by itself currently our code does not delete it it just returns None.

117

00:09:23.400  -->  00:09:29.310
So what we have to do is make sure that we have a scenario here or some code to deal with that scenario

118

00:09:29.670  -->  00:09:33.330
where the route is by itself and there's only one node.

119

00:09:34.590  -->  00:09:35.440
Let's do that.

120

00:09:35.440  -->  00:09:38.540
Here we have the marker which is the root.

121

00:09:38.850  -->  00:09:45.290
And then what we're going to do is say if the markers next node is none.

122

00:09:45.570  -->  00:09:49.140
If not Markert get next.

123

00:09:49.380  -->  00:09:51.180
That means the market is by itself.

124

00:09:51.180  -->  00:09:55.400
The route is by itself and therefore we have to delete it.

125

00:09:55.430  -->  00:10:03.620
Especially remember this is before the loop so the marker here is only ever going to be the route.

126

00:10:03.840  -->  00:10:11.010
What we'll do is we'll say self-taught root equals none return marker.

127

00:10:11.160  -->  00:10:17.670
So if the markers next node which is the root if the roots next node is none it means the root is by

128

00:10:17.670  -->  00:10:18.170
itself.

129

00:10:18.170  -->  00:10:19.670
So in this scenario there.

130

00:10:20.340  -->  00:10:23.240
And then what we do is we set the root to be none.

131

00:10:23.250  -->  00:10:29.450
Remember this is just the variable up there the property and then we'll return the marker which is that

132

00:10:29.450  -->  00:10:34.230
variable there which contains the root.

133

00:10:34.320  -->  00:10:36.740
That way we can deal with both the root.

134

00:10:36.750  -->  00:10:41.890
Begin by itself and also all other scenarios in your head.

135

00:10:41.970  -->  00:10:44.400
Think about a couple of scenarios.

136

00:10:44.430  -->  00:10:46.330
Does it work when the route is by itself.

137

00:10:46.380  -->  00:10:48.180
Does it work with tunnels.

138

00:10:48.180  -->  00:10:49.600
Does it work with 10 nodes.

139

00:10:49.800  -->  00:10:51.220
And that's probably fine.

140

00:10:51.330  -->  00:10:55.470
I don't think you have to think about three note for note five not six or seven nodes etc..

141

00:10:55.800  -->  00:11:01.110
I think they're all in the same sort of Plass group.

142

00:11:01.110  -->  00:11:04.920
So think about a couple of scenarios to make sure that your code works.

143

00:11:04.920  -->  00:11:09.450
Go through it line by line in your head and see what the computer would do.

144

00:11:09.450  -->  00:11:14.210
And that is a good way of verifying that your code is working.

145

00:11:14.250  -->  00:11:17.880
Once this is done we are ready to move over to the queue.

146

00:11:17.970  -->  00:11:23.250
But before that just for your convenience I'm going to add a couple of comments here so that when I

147

00:11:23.250  -->  00:11:29.160
give you the code which is by the way available in this section you can understand it better.

148

00:11:29.430  -->  00:11:29.700
So

149

00:11:33.330  -->  00:11:39.720
the first thing we're doing is we're iterating over each node in the list using this one loop.

150

00:11:40.200  -->  00:11:44.940
Then we get the following node or the next node.

151

00:11:47.070  -->  00:11:53.910
And what that gives us is the next available node of the list or after the marker.

152

00:11:54.010  -->  00:11:59.070
Finally if the following note has a value we're going to check if the following nodes next node has

153

00:11:59.070  -->  00:11:59.490
a value

154

00:12:02.480  -->  00:12:06.630
and if the next nodes next node is none.

155

00:12:06.630  -->  00:12:18.030
That means the next node is the last note which means that the current marker is the second to last

156

00:12:18.030  -->  00:12:26.190
node because there's only one more after that.

157

00:12:26.370  -->  00:12:31.950
Finally if that is the case we're going to make the marketers next note equal to none.

158

00:12:31.950  -->  00:12:35.790
So the very last node is removed.

159

00:12:37.530  -->  00:12:45.180
And I just wanted to do that for you so that you can have a bit more info when you read that code and

160

00:12:45.220  -->  00:12:49.930
especially delete the root if it is by itself.

161

00:12:50.880  -->  00:12:51.730
OK.

162

00:12:52.170  -->  00:12:56.940
Now let's go over to the queue which is in the linked queue class here.

163

00:12:57.000  -->  00:13:02.880
The linked class remember this class is only meant to be a wrapper around the linked list.

164

00:13:02.880  -->  00:13:05.380
So the methods don't really have to do anything new.

165

00:13:05.400  -->  00:13:12.540
They were just initially renaming them and giving them a standardized name to just push and pop.

166

00:13:12.760  -->  00:13:19.470
Thus the push method only has to do is as we saw earlier is get the linked list and add to start the

167

00:13:19.470  -->  00:13:21.810
node we're passing in as a parameter.

168

00:13:21.990  -->  00:13:28.150
The pop method all it has to do is return the linked lists remove and from list.

169

00:13:28.260  -->  00:13:32.550
And that is going to remove a. node and return it and then this pop method is going to get that returned

170

00:13:32.550  -->  00:13:34.750
node and return needs.

171

00:13:35.070  -->  00:13:40.800
Finally the Lenda method is just going to return the size of the list and return shelved or linked list

172

00:13:41.390  -->  00:13:42.540
size.

173

00:13:42.720  -->  00:13:50.250
And as you remember this allows us to call the lane builtin method on an object which is like so line

174

00:13:50.670  -->  00:13:54.840
my variable.

175

00:13:54.840  -->  00:13:56.330
That's what this lende method is.

176

00:13:56.430  -->  00:13:57.960
If not we would have to do something like.

177

00:13:57.960  -->  00:14:02.160
My variable Dotts size which is also fine.

178

00:14:02.160  -->  00:14:07.490
Once we've done this we are ready to run the tests and see if they work.

179

00:14:07.500  -->  00:14:13.820
So let's do that let's right click the test file and run the unit tests and tests.

180

00:14:13.830  -->  00:14:20.150
Hopefully you'll see all 10 tests passed and the green bar which means that you did the right thing

181

00:14:20.490  -->  00:14:25.280
and you were able to implement the code suggested.

182

00:14:25.620  -->  00:14:30.280
Now I do hope that you did that before looking at this video as that would be a bit more of a challenge

183

00:14:30.510  -->  00:14:34.920
but if you weren't able and you wanted to look at this video first that's totally fine.

184

00:14:34.920  -->  00:14:40.680
I do recommend that now that you've seen this video if you weren't able to implement this before you

185

00:14:40.680  -->  00:14:45.370
go back to the assignment download it again and give it another go.

186

00:14:45.750  -->  00:14:51.840
That sort of repetition and making sure that details are stuck in your brain is one of the best ways

187

00:14:51.840  -->  00:14:54.890
to learn without further ado.

188

00:14:54.960  -->  00:14:59.040
I'll be seeing you in the next video where we're going to be looking at stacks.

189

00:14:59.040  -->  00:15:00.980
I'll see you there.
