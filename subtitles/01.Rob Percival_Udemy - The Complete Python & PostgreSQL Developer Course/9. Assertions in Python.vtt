WEBVTT
1

00:00:00.150  -->  00:00:05.130
Find will come back in this way you were talking about assertions and assertions or something especially

2

00:00:05.130  -->  00:00:09.990
useful when you're creating your program and they're used to check essentially whether something is

3

00:00:09.990  -->  00:00:11.480
true or not.

4

00:00:11.670  -->  00:00:20.250
But if the thing we're checking is false then we raise an error we say hey you made a mistake here there's

5

00:00:20.250  -->  00:00:24.390
something that should be true but isn't That's what an assertion is.

6

00:00:24.390  -->  00:00:31.200
For example let's create here a new file which I'm going to call assertions just to show you what I

7

00:00:31.200  -->  00:00:32.140
mean.

8

00:00:32.550  -->  00:00:36.680
So we're have a number answer just 10 and we divide it by another number.

9

00:00:36.690  -->  00:00:38.130
So just two.

10

00:00:38.190  -->  00:00:41.330
And when we run this file we get the number five.

11

00:00:41.430  -->  00:00:43.430
You know which is what we would expect.

12

00:00:43.830  -->  00:00:50.720
As you can see increase the size of this fund down here for your convenience which is great.

13

00:00:50.730  -->  00:00:52.040
We've got 10 of it over to.

14

00:00:52.170  -->  00:00:53.080
And that's fantastic.

15

00:00:53.280  -->  00:00:59.750
But if we divide 10 by zero Do you know what happens.

16

00:01:01.680  -->  00:01:07.140
Well it's a mathematical error and Python Fortunately realizes that this is not allowed.

17

00:01:07.380  -->  00:01:12.240
And it gives zero division a division by zero is not allowed in mathematics.

18

00:01:12.480  -->  00:01:16.680
So it can do it and which it won't give us isn't there.

19

00:01:17.340  -->  00:01:27.330
However if at any point in our program we do encounter a zero division a program is going to crash and

20

00:01:27.330  -->  00:01:35.510
it must stop unless we want to be checking for a zero and number at every step in our programs.

21

00:01:35.760  -->  00:01:41.700
So what we can do in specific points in our program what it is especially important or where the program

22

00:01:43.710  -->  00:01:48.960
flows into some sort of thin focus point if you wish.

23

00:01:49.200  -->  00:01:56.920
In important places in our program we can check and the way we can check is to say for example.

24

00:01:57.080  -->  00:02:00.760
And number 10 divisor equals 2.

25

00:02:01.290  -->  00:02:05.000
We can check if divisor is not zero.

26

00:02:05.040  -->  00:02:13.780
Or rather is zero raise value era Divisoria zero.

27

00:02:14.430  -->  00:02:18.350
We could do something like this at some point in our program.

28

00:02:18.420  -->  00:02:24.750
For example we have a divide secure method

29

00:02:27.970  -->  00:02:28.660
like so.

30

00:02:28.770  -->  00:02:35.820
I say we have this method and this method then we'll divide these two numbers.

31

00:02:35.940  -->  00:02:39.210
And when we call the method if we check with the divisor is zero.

32

00:02:39.210  -->  00:02:46.050
So this is just a basic method to show you how the checking for 0 could be done.

33

00:02:46.200  -->  00:02:49.680
Naturally this method could also have a number divisor.

34

00:02:49.680  -->  00:02:52.250
There we could not have that.

35

00:02:52.610  -->  00:02:55.570
And at the end we could return number by divisor.

36

00:02:55.790  -->  00:02:56.420
So.

37

00:02:56.640  -->  00:02:59.860
OK let's let's leave it as that just a bit simple.

38

00:02:59.910  -->  00:03:05.190
So we've got to divide SECU method with checks where the divisor is equal to zero and if it does it

39

00:03:05.190  -->  00:03:08.190
raises a value error which I think is a reasonable error.

40

00:03:08.520  -->  00:03:17.940
Another could be that 0 division error or it could just do something like return minus 1 or you know

41

00:03:18.090  -->  00:03:22.950
something it could do something to tell our program that it went wrong there.

42

00:03:23.200  -->  00:03:28.550
And let's leave the value area there.

43

00:03:29.080  -->  00:03:37.200
And what that means is that when someone is using this method such as yourself you are going to know

44

00:03:38.160  -->  00:03:44.340
via the exception that you have made a mistake or somewhere that your program went wrong and you ended

45

00:03:44.340  -->  00:03:49.010
up with a zero in your division which is not a correct thing to end up with.

46

00:03:49.520  -->  00:03:56.620
So when you are using this method then you're going to know that something went wrong there.

47

00:03:56.700  -->  00:04:05.390
However if you create your program such that the number 0 will never be there.

48

00:04:05.880  -->  00:04:09.400
Then this check loses a bit of value.

49

00:04:09.420  -->  00:04:13.080
I'm sure you agree with me if the divisor is never going to be zero.

50

00:04:13.500  -->  00:04:19.410
Then checking for it to be zero loses value because it is not a scenario that is ever going to happen

51

00:04:19.420  -->  00:04:20.680
.

52

00:04:20.690  -->  00:04:29.730
Now while you develop your program you may not be 100 percent confident that the device is never going

53

00:04:29.730  -->  00:04:31.020
to be zero.

54

00:04:31.530  -->  00:04:36.870
For example a way that you could make sure your divide is never zero is by checking early around.

55

00:04:37.170  -->  00:04:41.050
You can ask the user to enter a number input and or a number.

56

00:04:41.430  -->  00:04:42.210
And if

57

00:04:46.260  -->  00:04:54.780
if user input equals zero then you can ask again and so on.

58

00:04:55.980  -->  00:05:01.600
If you do something like this for example this divisor would never be equal to zero.

59

00:05:01.680  -->  00:05:02.340
Right.

60

00:05:02.820  -->  00:05:10.050
But while you were developing your program you may want to see what happens.

61

00:05:10.050  -->  00:05:14.050
Or maybe you won't have this check in place at the time.

62

00:05:14.130  -->  00:05:20.610
So there is a better way of doing things rather than checking if the divisor to zero and then raising

63

00:05:20.610  -->  00:05:29.710
the value are the better way is to do an assertion assert divisor is not equal to zero.

64

00:05:30.510  -->  00:05:33.110
And what this does is exactly the same thing.

65

00:05:33.600  -->  00:05:40.690
It will check whether divisor is 0 and if it is zero then it will raise an assertion error.

66

00:05:41.730  -->  00:05:45.560
Now you're probably wondering well why is that better.

67

00:05:46.110  -->  00:05:53.730
And the answer to that is because the assertions once you verified that your program will not allow

68

00:05:53.790  -->  00:06:00.000
zero to get to this point the assertion turns itself off when your program is running in high performance

69

00:06:00.000  -->  00:06:00.910
mode.

70

00:06:01.530  -->  00:06:06.760
So this is not useful if your programs are always running in normal mode which is the normal thing.

71

00:06:06.930  -->  00:06:11.520
But sometimes if your program requires high performance you can do compile it and remove the assertions

72

00:06:11.910  -->  00:06:19.730
and by having assertions instead of just normal checks you can allow your program to do that.

73

00:06:19.770  -->  00:06:28.470
So use assertions when values are going to be incorrect and you're gonna be checking whether the value

74

00:06:28.470  -->  00:06:29.360
is correct or not.

75

00:06:29.390  -->  00:06:33.710
Or Yaaron to charge when the user is inputting values.

76

00:06:33.930  -->  00:06:41.430
Use exceptions to control the flow of the program when incorrect values appear and you cannot check

77

00:06:41.430  -->  00:06:47.790
for them earlier or you cannot filter them earlier than use exceptions but use assertions if you may

78

00:06:47.790  -->  00:06:50.380
want to turn them off later wrong.

79

00:06:51.330  -->  00:06:56.170
So just to improve performance of your program you can also have a message

80

00:07:00.030  -->  00:07:02.430
which is after the comma and that's it.

81

00:07:02.430  -->  00:07:03.870
So divisor is not equal to zero.

82

00:07:03.870  -->  00:07:09.290
And if it is it will raise an assertion error assertion error with that message.

83

00:07:09.330  -->  00:07:09.700
OK.

84

00:07:09.870  -->  00:07:18.520
So if we print divide secure 10 by zero we get an assertion error with that message.

85

00:07:19.200  -->  00:07:25.770
So let's say for this video I just want to tell you that assertions exist and to use them as Chink's

86

00:07:26.340  -->  00:07:31.230
when you may want to turn them off later on if you're never going to want to turn them off you're always

87

00:07:31.230  -->  00:07:32.540
going to want to have them there.

88

00:07:32.670  -->  00:07:38.170
Use exceptions instead and just because there is no possibility of turning them off.

89

00:07:38.500  -->  00:07:39.930
OK that's everything for this video.

90

00:07:39.930  -->  00:07:41.270
Hope you learn something.

91

00:07:41.280  -->  00:07:43.570
And I see you in the very next one.
