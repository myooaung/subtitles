WEBVTT
1
00:00:05.380 --> 00:00:10.620
Hello everyone and welcome to the solutions lecture for this Scala collections assessment test.

2
00:00:10.630 --> 00:00:14.050
Let's go ahead and jump to this school interpreter to get started.

3
00:00:14.050 --> 00:00:14.370
All right.

4
00:00:14.380 --> 00:00:20.710
So for this test you had five basic questions and there is some multiple parts that last question but

5
00:00:20.710 --> 00:00:26.020
the first question was Can you figure out what method you can use to find out if the list in the list

6
00:00:26.020 --> 00:00:29.470
being 1 2 3 4 5 contains the number theory.

7
00:00:29.590 --> 00:00:34.650
There's actually two ways you could have done this as far as he's in that kind of contains key word.

8
00:00:34.660 --> 00:00:45.720
You could have said Create a list vowel my list say list one two three four five and then my list contains

9
00:00:46.440 --> 00:00:47.500
the number three.

10
00:00:47.710 --> 00:00:49.700
And this would return the boolean true.

11
00:00:49.830 --> 00:00:56.580
Or you could have said my list dots and then you can say tab to get a list of all the operations.

12
00:00:56.580 --> 00:01:00.100
But in this case we actually were looking for that contains operation.

13
00:01:00.120 --> 00:01:04.110
So you can just passen three there and this will also return true.

14
00:01:04.320 --> 00:01:06.870
So the methods were just to use that key word contains.

15
00:01:06.890 --> 00:01:09.660
Or it's actually called the operation that contains.

16
00:01:09.690 --> 00:01:12.260
Let's go ahead and move on to the next question.

17
00:01:14.220 --> 00:01:20.070
OK so the next question was How can you add all the elements of that previous list and hopefully remember

18
00:01:20.070 --> 00:01:26.610
they can just call the operation some operational lists actually sum all the integers or double elements

19
00:01:26.700 --> 00:01:27.960
in a list.

20
00:01:27.960 --> 00:01:30.680
Let's go ahead and move on to the next question.

21
00:01:30.690 --> 00:01:38.780
When you go unclear that the next question was to create an array of all the odd numbers from 0 to 15.

22
00:01:38.790 --> 00:01:41.770
Now there is a little bit of a trick to this question.

23
00:01:41.810 --> 00:01:46.710
For one thing zero is not really an odd number or even really an even number.

24
00:01:46.880 --> 00:01:53.090
So this is really asking just for the odd numbers from 1 to 15 in another question that may have arisen

25
00:01:53.090 --> 00:01:56.600
is whether or not 15 is inclusive or exclusive.

26
00:01:56.600 --> 00:02:01.100
It doesn't really matter because if you can answer either question then you probably understand the

27
00:02:01.100 --> 00:02:03.420
task enough to do either or.

28
00:02:03.500 --> 00:02:06.410
Well let me go ahead and show you how you could have done that.

29
00:02:06.420 --> 00:02:08.070
You can use the Range method.

30
00:02:08.070 --> 00:02:17.130
Note that this is a capital R and we can go from 1 to 15 step size by 2 and that's going to go ahead

31
00:02:17.130 --> 00:02:21.790
and return range from 1 3 5 7 9 11 13.

32
00:02:21.930 --> 00:02:31.160
So we want that actual array instead of that range object we can say array that range 115 to now returns

33
00:02:31.160 --> 00:02:33.030
that actual array.

34
00:02:33.030 --> 00:02:33.530
OK.

35
00:02:33.720 --> 00:02:41.190
Now something to note here is if you want it to include 15 you would have to change this to 16.

36
00:02:41.940 --> 00:02:45.450
And here you have 1 3 5 7 9 11 13 15.

37
00:02:45.630 --> 00:02:51.240
So depending on how you interpreted this question whether you wanted a strict array object back or this

38
00:02:51.240 --> 00:02:58.320
range object back and if you wanted to include 15 or just go to 13 non-inclusive really depends but

39
00:02:58.560 --> 00:03:02.670
if you're able to answer one of these hopefully you're already knowledgeable enough that you could have

40
00:03:02.670 --> 00:03:05.500
answered any interpretation to that question.

41
00:03:05.570 --> 00:03:08.660
OK let's go ahead to move on to question number four.

42
00:03:08.660 --> 00:03:16.340
We're going to go at in clear that OK so this question was What are the unique elements in the list

43
00:03:16.510 --> 00:03:18.390
2 3 1 et cetera.

44
00:03:18.470 --> 00:03:25.300
So let's go out and create that list quickly so say that my list is equal to list and we'll say 2 3

45
00:03:25.300 --> 00:03:29.020
1 and we don't have to actually get exactly right.

46
00:03:29.840 --> 00:03:36.920
6 6 and then we want to so I have this list if I want to get just the unique elements in this list.

47
00:03:36.950 --> 00:03:40.330
I can remember back to that sets collection object.

48
00:03:40.340 --> 00:03:43.550
So I remember a set contains no duplicate elements.

49
00:03:43.610 --> 00:03:51.770
So they're all unique which means I can say my list and call two sets and here I have an immutable set

50
00:03:51.830 --> 00:03:58.070
of all the unique elements so I can answer the questions by saying it's 5 1 6 2 3 and then 4.

51
00:03:58.160 --> 00:04:04.110
So hopefully you're able to kind of make the connection between unique elements as a keyword to set.

52
00:04:04.130 --> 00:04:06.700
Let's go ahead and move on to the last question.

53
00:04:07.670 --> 00:04:14.310
And that was to create a mutable map with these Samie three Franke's seven Gianforte five key value

54
00:04:14.310 --> 00:04:15.410
pairs.

55
00:04:15.630 --> 00:04:18.430
And this was written now in that text article.

56
00:04:18.480 --> 00:04:25.440
Well let's go ahead and try it out I'm going to say vowel names is equal to and since I want this map

57
00:04:25.440 --> 00:04:34.480
to be immutable I have to say collection the mutable dot map and then passen these key value pairs that's

58
00:04:34.490 --> 00:04:46.690
going to be Samie comma theory and then we'll say Franki comma 7 and then finally we'll say it's a string.

59
00:04:46.690 --> 00:04:54.390
John is going to capitalize that comma 45 close parentheses in a one more close parentheses close off

60
00:04:54.390 --> 00:04:55.640
that map.

61
00:04:55.740 --> 00:05:01.370
And here if we just call names we'll see if we have that collection that mutable map where is 3 brachy

62
00:05:01.380 --> 00:05:03.220
is 7 and John is 45.

63
00:05:03.510 --> 00:05:10.560
The next task was to print out all the keys and hopefully remember they can just say names like keys

64
00:05:10.890 --> 00:05:11.810
in order to do that.

65
00:05:11.820 --> 00:05:17.130
And if you wanted the values themselves we could have also done names values.

66
00:05:17.190 --> 00:05:17.790
All right.

67
00:05:18.070 --> 00:05:22.110
And then finally the last question was to add the key value pair.

68
00:05:22.140 --> 00:05:23.860
Mike 27.

69
00:05:23.920 --> 00:05:33.040
So this is a mutable map we can just say names plus equals and then go ahead and say Mike let's go to

70
00:05:33.040 --> 00:05:43.090
capitalize that loops and then we use this arrow notation 27 enough I call names.

71
00:05:43.100 --> 00:05:44.210
Note that I get back.

72
00:05:44.240 --> 00:05:47.150
Mike 27 as a key value pair.

73
00:05:47.180 --> 00:05:47.900
All right.

74
00:05:47.900 --> 00:05:50.620
Hopefully those are pretty straightforward.

75
00:05:50.630 --> 00:05:54.100
The only trouble you may have had is and how to actually interpret the question.

76
00:05:54.200 --> 00:05:59.270
But if you're able to figure out at least one solution to your interpretation that's totally fine because

77
00:05:59.360 --> 00:06:03.550
you can basically answer all the interpretations of any of those questions.

78
00:06:03.560 --> 00:06:04.030
All right.

79
00:06:04.190 --> 00:06:05.570
That's it for the collections.

80
00:06:05.630 --> 00:06:09.360
Hopefully you can find some use cases for lists sets and maps.

81
00:06:09.410 --> 00:06:13.670
As we continue forth throughout the course Thanks everyone and I'll see at the next lecture.
