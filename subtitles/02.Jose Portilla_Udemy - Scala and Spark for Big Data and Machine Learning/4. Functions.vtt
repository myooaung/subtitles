WEBVTT
1
00:00:05.140 --> 00:00:09.290
Hello everyone and welcome to the lecture on functions.

2
00:00:09.510 --> 00:00:14.400
Now before it gets started actually programming out functions I want to make a quick note as far as

3
00:00:14.400 --> 00:00:16.950
the semantics we're gonna be using for this lecture.

4
00:00:16.950 --> 00:00:20.310
There is a technical difference between methods and functions.

5
00:00:20.310 --> 00:00:22.930
And there's another term also known as procedures.

6
00:00:22.950 --> 00:00:28.260
We're going to be using the term function for is to describe the idea of having a piece of code that

7
00:00:28.260 --> 00:00:34.380
can take an input or parameters perform an operation and then produce some sort of an output.

8
00:00:34.380 --> 00:00:40.290
Now there may be some confusion of these terms of method versus function versus procedure depending

9
00:00:40.290 --> 00:00:41.350
on what your background is.

10
00:00:41.370 --> 00:00:45.690
If you're a heavy Java user or if you're a heavy Python user you're going to have in the back of your

11
00:00:45.690 --> 00:00:48.980
mind different ideas of what those terms actually mean.

12
00:00:48.990 --> 00:00:55.260
So in order to clear any confusion up there are links as a resource in this lecture that show you how

13
00:00:55.260 --> 00:00:59.940
to actually describe the more technical differences between the term method versus the term function

14
00:01:00.210 --> 00:01:02.930
in Java and the Scala programming languages.

15
00:01:02.940 --> 00:01:06.290
So I just wanted to make that quick note before we get started.

16
00:01:06.390 --> 00:01:11.220
But from now on we're going to go ahead and refer to these things as functions even though maybe here

17
00:01:11.220 --> 00:01:15.460
a Java user in the back of your mind you may refer them more as methods.

18
00:01:15.510 --> 00:01:22.580
So let's go ahead and get started by jumping to the Adam text editor right here and at the text editor.

19
00:01:22.710 --> 00:01:28.040
Now functions are going to allow us to do is to easily reuse and call code segments.

20
00:01:28.080 --> 00:01:33.330
So let's go ahead and show you a simple example of this method or function pending on how you want to

21
00:01:33.330 --> 00:01:34.390
think about this.

22
00:01:34.530 --> 00:01:39.630
What we can use the DFA keyword and then we're going to go ahead and put in the name of what we want

23
00:01:39.690 --> 00:01:40.820
our function to be.

24
00:01:40.890 --> 00:01:43.650
In this case we're going to start a very simple function.

25
00:01:43.650 --> 00:01:46.520
So we'll say simple close parentheses.

26
00:01:46.620 --> 00:01:48.350
Then you have a colon.

27
00:01:48.630 --> 00:01:53.490
And in this case you're going to put in the data type you expect the output to be as a general data

28
00:01:53.490 --> 00:01:57.750
type and just say units is equal to curly brackets.

29
00:01:57.750 --> 00:02:00.570
And then we'll go ahead and execute some blocks of code.

30
00:02:00.750 --> 00:02:05.790
In this case we'll say prints line and we'll say simple prints.

31
00:02:05.970 --> 00:02:08.830
And then to actually call that function.

32
00:02:09.030 --> 00:02:11.460
We say simple close parentheses.

33
00:02:11.490 --> 00:02:14.850
So we go ahead and just run this and then break down all we have here.

34
00:02:15.550 --> 00:02:21.600
So notice we get simple it's just this unit and we say simple prints which is the output here.

35
00:02:21.610 --> 00:02:26.680
So basically we have is this the keyword the name of this function or method depending on how you want

36
00:02:26.680 --> 00:02:28.920
to think about this close parentheses.

37
00:02:28.960 --> 00:02:34.740
And later on we're actually going to put inputs into those parentheses a colon and then here per unit.

38
00:02:34.770 --> 00:02:40.510
We're going to eventually do is replace that with the type of output the data type output that we expect

39
00:02:41.020 --> 00:02:41.810
equals to.

40
00:02:41.860 --> 00:02:45.970
And then inside these curly brackets whatever lines of code you want to execute.

41
00:02:46.030 --> 00:02:50.950
So let's go ahead and expand this topic by creating a very simple addition function.

42
00:02:50.950 --> 00:02:57.520
So I'm going to clear this up will say D F and say atter.

43
00:02:57.820 --> 00:03:04.060
And this is going to take in two arguments number one and number two and I can go ahead and specify

44
00:03:04.450 --> 00:03:05.710
using a colon here.

45
00:03:05.720 --> 00:03:07.770
What I expect each data type to be.

46
00:03:07.930 --> 00:03:11.630
So I expect this to be an integer when I receive it for number one.

47
00:03:11.680 --> 00:03:13.550
So I have a colon and then the data type.

48
00:03:13.760 --> 00:03:18.560
And then for number 2 colon I expect this to be an integer as well.

49
00:03:18.850 --> 00:03:27.360
And then I'm going to go ahead and have a colon here and then I'm going to say ints equals curly brackets.

50
00:03:27.430 --> 00:03:32.290
And then I have the return keyword and I can go ahead and return the result.

51
00:03:32.290 --> 00:03:35.480
In this case I'm just going to add one plus two.

52
00:03:35.710 --> 00:03:39.610
Let's go ahead and call this run and then break down what's happening here.

53
00:03:39.610 --> 00:03:46.300
So go ahead and say four and five and we'll save that clue this console and run it.

54
00:03:47.210 --> 00:03:47.530
OK.

55
00:03:47.570 --> 00:03:49.300
So what we get we get at her.

56
00:03:49.430 --> 00:03:51.830
It says it expects no one as an integer.

57
00:03:51.830 --> 00:03:53.160
Number two is an integer.

58
00:03:53.240 --> 00:03:55.600
And then the output should also be an integer.

59
00:03:55.610 --> 00:03:59.290
So we get as a result four plus five is nine.

60
00:03:59.300 --> 00:04:04.910
So if you're coming in from a language as Python you may find this idea strange that you're specifying

61
00:04:04.910 --> 00:04:07.860
the data types of the inputs and outputs.

62
00:04:07.970 --> 00:04:13.370
But this is actually pretty nice when you're doing large blocks of code and you're going to have to

63
00:04:13.370 --> 00:04:14.700
do some debugging.

64
00:04:14.750 --> 00:04:19.190
It's going to become really obvious what the errors are because you specified just the beginning what

65
00:04:19.190 --> 00:04:23.150
data types are expected to be the input versus the output.

66
00:04:23.150 --> 00:04:33.120
So for instance if I pass in a string here such as four and 5 Let's go ahead and save that and run it.

67
00:04:33.160 --> 00:04:36.160
Note that we get an error so I'll say type mismatch.

68
00:04:36.220 --> 00:04:40.090
And Ill say it required an integer but it found a string.

69
00:04:40.090 --> 00:04:45.640
Now that's not to say we can actually perform this operation of four plus five strings if I come down

70
00:04:45.640 --> 00:04:46.700
here to Skala.

71
00:04:46.810 --> 00:04:54.280
If I were to just literally type four plus five here it would concatenate those strings together into

72
00:04:54.280 --> 00:04:55.140
45.

73
00:04:55.240 --> 00:04:58.290
So technically this line of code still works.

74
00:04:58.330 --> 00:05:04.210
What saved us as far as tracking this sort of error is the fact that we define what we wanted the input

75
00:05:04.210 --> 00:05:05.560
data types to be.

76
00:05:05.560 --> 00:05:10.480
So hopefully you can change your mindset if you haven't seen this sort of thing before you actually

77
00:05:10.540 --> 00:05:15.370
realize this is pretty beneficial if you're going to be dealing with large code blocks and you're going

78
00:05:15.370 --> 00:05:17.290
to be doing some debugging later on.

79
00:05:17.290 --> 00:05:21.110
So this is actually a positive not a negative.

80
00:05:21.170 --> 00:05:25.990
Now it may take a little more time to develop your code since you're declaring data types but hopefully

81
00:05:25.990 --> 00:05:26.740
you see the benefit.

82
00:05:26.750 --> 00:05:30.600
Now let's go ahead and perform another function here.

83
00:05:30.840 --> 00:05:32.770
Going to go in and clear this.

84
00:05:32.980 --> 00:05:42.840
Let's set up this method or function will say if I'm going to say great name and by convention we usually

85
00:05:42.840 --> 00:05:45.110
have these function names to be lowercase.

86
00:05:45.270 --> 00:05:49.620
And if you want another word in there either you use an underscore or you just go ahead and type the

87
00:05:49.620 --> 00:05:51.570
next word of a capital letter.

88
00:05:51.630 --> 00:05:55.290
So you say great name and I expect an input.

89
00:05:55.290 --> 00:05:59.710
We'll go ahead and call the variable name and it should be a string.

90
00:05:59.760 --> 00:06:02.930
We'll have a call in here and expect the output to be a string.

91
00:06:02.940 --> 00:06:04.970
Since all I want to return is just hello.

92
00:06:04.980 --> 00:06:09.180
And then this person's name I will say equal sign curly brackets.

93
00:06:09.210 --> 00:06:15.120
And then I'm going to execute some code in this case I'm going to go ahead and return and I will say

94
00:06:15.920 --> 00:06:20.650
hello dollar sign name and I should print out basically Hello.

95
00:06:20.700 --> 00:06:22.360
The whatever name I put in.

96
00:06:22.380 --> 00:06:27.800
So let's go ahead and say thou is equal to.

97
00:06:28.490 --> 00:06:30.920
We'll go ahead and say fool.

98
00:06:30.920 --> 00:06:31.880
Great.

99
00:06:32.240 --> 00:06:37.750
And then I'm going to say greets name Jose.

100
00:06:37.970 --> 00:06:43.070
And then I can actually create line for Greeks.

101
00:06:43.130 --> 00:06:47.500
So let's go ahead and run this and see what happens and it clears council again.

102
00:06:48.960 --> 00:06:53.270
So I get full greets and then Hello Jose.

103
00:06:53.290 --> 00:06:59.440
So what I'm actually doing here is using this return to value and saving it as a value full greets and

104
00:06:59.440 --> 00:07:01.230
then seeing that result.

105
00:07:01.390 --> 00:07:07.400
So I'm saving the result of this function with this input to this value for greets and then imprinting

106
00:07:07.450 --> 00:07:08.700
that value out.

107
00:07:08.740 --> 00:07:14.290
Let me go ahead and work on a more complicated function that will check if a number is prime.

108
00:07:14.440 --> 00:07:23.280
So this will be our final example we'll go in and say D E F and I will say is prime.

109
00:07:23.510 --> 00:07:30.410
And let's go ahead and put in a number we want to check Sol say numb check and I expect this to be an

110
00:07:30.470 --> 00:07:36.760
integer because it doesn't make sense to test floating point or double numbers for being prime or not.

111
00:07:37.040 --> 00:07:39.560
And then we're going to go ahead and say we want a boolean.

112
00:07:39.590 --> 00:07:42.250
So I want true or false is this number prime.

113
00:07:42.290 --> 00:07:50.180
So say boolean equal to and then let's go ahead and do some very simple logic for checking if there

114
00:07:50.180 --> 00:07:51.350
is a prime number.

115
00:07:51.350 --> 00:07:52.910
This is not the best way to do this.

116
00:07:52.900 --> 00:07:56.200
This is known as the naive solution or checking for numbers prime.

117
00:07:56.240 --> 00:08:06.320
Scientists say for n Remember we have this sort of error notation and I will say range from two to the

118
00:08:06.320 --> 00:08:07.240
name check.

119
00:08:08.140 --> 00:08:17.980
I will go ahead and say if numb check maade N is equal to zero.

120
00:08:18.170 --> 00:08:27.400
Then I know the number will go ahead and put a boolean here.

121
00:08:27.500 --> 00:08:30.360
So we'll go ahead and write false here.

122
00:08:30.740 --> 00:08:38.620
And then finally outside of this if that return never occurs then I'm going to go ahead and say return.

123
00:08:38.730 --> 00:08:39.260
True.

124
00:08:39.420 --> 00:08:43.420
So let's clarify that this actually worked and test it out.

125
00:08:43.620 --> 00:08:46.020
Well Saint print line is prime.

126
00:08:46.050 --> 00:08:48.980
It's going it took a number that we know is not prime.

127
00:08:48.990 --> 00:08:53.900
So I'll say this should be false not prime.

128
00:08:54.050 --> 00:09:00.050
And then we'll say prints line is prime for number that we do know as prime such as 23.

129
00:09:00.110 --> 00:09:04.470
So this should return TRUE looks.

130
00:09:04.600 --> 00:09:05.770
So let's go in and save this.

131
00:09:05.770 --> 00:09:09.010
Run it and then we'll break it down to you run it.

132
00:09:09.010 --> 00:09:11.680
So looks like we get false and true as we expected.

133
00:09:11.680 --> 00:09:12.560
Great.

134
00:09:12.580 --> 00:09:14.810
So let's go ahead and say what's going on here.

135
00:09:14.830 --> 00:09:21.510
We find the if is prime we expect number check to be an integer and we want the output to be a boolean.

136
00:09:21.730 --> 00:09:27.610
Then for every number from range to up to the integer the number we're actually checking and we're going

137
00:09:27.610 --> 00:09:31.660
to check if that number is divisible by one of these values.

138
00:09:31.810 --> 00:09:38.560
And if it has a remainder of 0 then we know that it is not prime because the definition of a prime number

139
00:09:38.860 --> 00:09:42.430
is that it can only be evenly divided by 1 or itself.

140
00:09:42.430 --> 00:09:48.290
So if this return never occurs then we go all the way out here to outside of this for loop and they'll

141
00:09:48.340 --> 00:09:49.560
return true.

142
00:09:49.570 --> 00:09:55.360
So basically once this returns everything else will be essentially jumped out over that line the for

143
00:09:55.360 --> 00:09:57.350
loop will break and we're good here.

144
00:09:57.580 --> 00:09:58.050
OK.

145
00:09:58.300 --> 00:10:03.950
So let's go ahead and show you how you can use some collections for functions.

146
00:10:04.300 --> 00:10:10.380
So let's go out and clear this and show you just two more simple examples.

147
00:10:10.380 --> 00:10:20.980
As far as using collections or functions sung in the same vowel numbers is equal to list 1 2 3 7.

148
00:10:21.180 --> 00:10:26.370
And I'm going to go ahead and just show you how you can run through a list like this.

149
00:10:26.570 --> 00:10:35.370
So if you say some sort of check and say numbs and you're expecting a collection such as a list well

150
00:10:35.400 --> 00:10:41.880
you'll have to do is actually passing a code that looks like this so you'll say list and then in square

151
00:10:41.880 --> 00:10:44.350
brackets what you expect to be in that list.

152
00:10:44.370 --> 00:10:48.640
Let me show you what I mean by that by running this scul interpreter code.

153
00:10:48.660 --> 00:10:54.260
So if I say valid numbers is equal to list 1 to 3.

154
00:10:54.300 --> 00:10:58.820
Notice what scholar will put out here it says it's a list that contains integers.

155
00:10:58.950 --> 00:11:03.810
Meaning when you're specifying the data type here inside of this method or function you're going to

156
00:11:03.810 --> 00:11:08.680
have to say list and what kind of data you expect to find inside of that list.

157
00:11:09.510 --> 00:11:18.990
Meaning I can then also return a list of integers and say equals to close brackets.

158
00:11:19.010 --> 00:11:22.980
Let's just go ahead and return that same list so say return numbers.

159
00:11:23.170 --> 00:11:31.330
We'll go ahead and print line of check numbers AUPs save this and run it.

160
00:11:33.680 --> 00:11:35.180
Let's go and run load.

161
00:11:35.180 --> 00:11:35.930
There you go.

162
00:11:36.290 --> 00:11:36.610
OK.

163
00:11:36.650 --> 00:11:42.740
So this went ahead and created that function ran that function and it returned a list and because the

164
00:11:42.740 --> 00:11:49.390
point of this is just to show you that you can't just say something like it's here.

165
00:11:49.390 --> 00:11:50.470
Otherwise you'll get an error.

166
00:11:50.470 --> 00:11:53.380
So I save this and run it again.

167
00:11:53.890 --> 00:11:59.890
Note here that I get an error because it says Type Mismatch found integer but expect that a list of

168
00:11:59.980 --> 00:12:03.770
integers so this sort of bracket notation is what you need to use.

169
00:12:03.820 --> 00:12:08.820
And if you ever get confused on how to actually write this out as far as what term should be inside

170
00:12:08.830 --> 00:12:09.610
of this list.

171
00:12:09.730 --> 00:12:15.130
A nice way of checking that is to go straight to your Skoll interpreter and let's say you wanted a list

172
00:12:15.160 --> 00:12:18.850
of boolean values so something like.

173
00:12:18.850 --> 00:12:20.440
True false.

174
00:12:20.500 --> 00:12:23.920
You can run that in and then Skala will tell you what the data type is.

175
00:12:23.980 --> 00:12:27.850
So then you could just copy and paste that into your function or method of code.

176
00:12:27.850 --> 00:12:28.220
All right.

177
00:12:28.240 --> 00:12:30.280
That is it for functions.

178
00:12:30.370 --> 00:12:36.730
Coming up next is going to be your final programming task for this Scala programming basics section.

179
00:12:36.780 --> 00:12:40.870
We're going to actually ask you just a few questions and test your skills.

180
00:12:40.870 --> 00:12:43.420
Coming up next an overview of those questions.

181
00:12:43.420 --> 00:12:45.310
Thanks everyone and I'll see you at the next lecture.
