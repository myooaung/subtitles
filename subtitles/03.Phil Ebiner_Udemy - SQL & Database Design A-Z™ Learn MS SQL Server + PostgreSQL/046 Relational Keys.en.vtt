WEBVTT
1
00:00:00.240 --> 00:00:01.670
Hello and welcome back.

2
00:00:01.710 --> 00:00:06.740
And today we're going to be talking about relational keys relational keys are divided into four types.

3
00:00:06.730 --> 00:00:13.200
In as well primary keys foreign keys super keys and candidate keys super keys being the most fundamental

4
00:00:13.290 --> 00:00:13.960
ones.

5
00:00:14.280 --> 00:00:19.850
So as soubriquet is any combination of columns that uniquely identify a row in the table.

6
00:00:19.860 --> 00:00:24.570
If you think about this table that consists of three attributes employ the first name last name the

7
00:00:24.600 --> 00:00:30.090
super key the biggest one is use all three columns in your search engine.

8
00:00:30.150 --> 00:00:36.070
So you say where employee equals one first name equals brand and last name equal to.

9
00:00:36.480 --> 00:00:42.060
Now candidate keys are basically super keys that cannot be reduced to more Superguy.

10
00:00:42.240 --> 00:00:44.070
And it also has two unique properties.

11
00:00:44.070 --> 00:00:47.710
It has to be unique and it can be reduced anymore.

12
00:00:47.730 --> 00:00:53.680
So in our case again if you think about super keys the first one that comes to mind is to use all precautions.

13
00:00:53.700 --> 00:00:57.010
Now can we divide this one into two more so brickies.

14
00:00:57.060 --> 00:01:02.220
Yes we get the first one will be employ 80 and first name used at the same time.

15
00:01:02.220 --> 00:01:04.980
And the second one being first name and last name.

16
00:01:05.010 --> 00:01:08.380
Now can we divide this two super keys into more subroutines.

17
00:01:08.520 --> 00:01:09.380
And yes we can.

18
00:01:09.450 --> 00:01:15.020
Because even if we just search for employee ID we will get Brando back.

19
00:01:15.020 --> 00:01:20.790
So if we say one employee equals one we'll get rhabdo if we say we're employed equals free we'll get

20
00:01:20.790 --> 00:01:21.580
Brad Pitt.

21
00:01:21.930 --> 00:01:24.100
Can we use last name as our Superguy.

22
00:01:24.120 --> 00:01:30.150
Yes we can because if we stay that we need to find results where last name equals though we'll only

23
00:01:30.150 --> 00:01:33.040
get one unique role data Bradd don't.

24
00:01:33.210 --> 00:01:36.450
Can these super keys be reduced to more super keys.

25
00:01:36.450 --> 00:01:37.380
The answer is No.

26
00:01:37.470 --> 00:01:41.650
And this is why both of these super keys are now candidate keys.

27
00:01:41.700 --> 00:01:42.960
They both have unique data.

28
00:01:42.960 --> 00:01:45.400
They both cannot be reduced to more super keys.

29
00:01:45.630 --> 00:01:47.880
So what can we do with this candidate keys now.

30
00:01:47.970 --> 00:01:54.060
Well we can make one of them a primary key and a primary key is the candidate key that is selected to

31
00:01:54.060 --> 00:02:00.370
identify tuples uniquely with vendor relation and relation has several candidate keys like we do.

32
00:02:00.450 --> 00:02:03.030
Only one is chosen to be primary key.

33
00:02:03.180 --> 00:02:09.330
So let's go ahead take a look at our table again and here our candidate keys employee and last name

34
00:02:09.600 --> 00:02:12.020
either one of them can be a primary key.

35
00:02:12.150 --> 00:02:17.400
But if you select your last name as primary key and your table keeps growing and growing and you get

36
00:02:17.400 --> 00:02:24.600
falls and all of employees the chances are you will have more people sharing last name.

37
00:02:24.600 --> 00:02:31.620
So then last name will not be unique and it cannot qualify to be a candidate key and therefore a primary

38
00:02:31.620 --> 00:02:32.360
key anymore.

39
00:02:32.550 --> 00:02:40.830
This is why in a lot of tables you will see an ID column basically id attribute is added to almost every

40
00:02:40.830 --> 00:02:46.830
table when it comes to ask you all because it allows you to put a unique constraint on it and make it

41
00:02:46.830 --> 00:02:47.570
a primary key.

42
00:02:47.610 --> 00:02:54.350
And all you have to specify is that any time you add a new row data the ID value goes up by one.

43
00:02:54.360 --> 00:03:00.510
And this way you will never run out of space to store new data and you will always be able to identify

44
00:03:00.510 --> 00:03:01.140
your data.

45
00:03:01.140 --> 00:03:06.560
This is why we have student IDs consumer Adie's customer IDs order IDs.

46
00:03:06.690 --> 00:03:10.140
Again almost every table has this attribute now.

47
00:03:10.350 --> 00:03:16.440
So I would suggest you pick employee as your primary key because it will never stop being unique and

48
00:03:16.650 --> 00:03:18.750
it's the best primary key there is.

49
00:03:18.750 --> 00:03:26.040
Now another thing we can do of candidate keys is tie them up to four inches so foreign key is an attribute

50
00:03:26.070 --> 00:03:31.200
or set of attributes and one relation that matches the candidate key of some other relations.

51
00:03:31.200 --> 00:03:37.530
So if we go ahead take a look and these two tables and pay attention to the left one for a second we

52
00:03:37.530 --> 00:03:40.670
can immediately identify the primary key for this table.

53
00:03:40.680 --> 00:03:44.560
The best one will be game rank because it's basically game id.

54
00:03:44.700 --> 00:03:47.020
Two games can shared the same game rank.

55
00:03:47.130 --> 00:03:50.190
And it's an integer value that's always increased by 1.

56
00:03:50.190 --> 00:03:51.570
It's very easy to search for.

57
00:03:51.570 --> 00:03:53.570
It's very easy to work with.

58
00:03:53.650 --> 00:03:59.160
If we take a look at the right table for NL we can identify three candidate keys.

59
00:03:59.330 --> 00:04:03.160
Platform name first retail availability and units sold.

60
00:04:03.210 --> 00:04:09.330
This continued on platform comment cannot be candidate keys because they have no values and therefore

61
00:04:09.360 --> 00:04:10.890
they're not unique.

62
00:04:10.920 --> 00:04:13.920
So we have three different candidate keys here.

63
00:04:13.950 --> 00:04:20.750
Now if we take a look at both tables we can see that they share one column and that column is platform.

64
00:04:21.180 --> 00:04:24.930
So what can we do right now what we can do and what we should do.

65
00:04:24.930 --> 00:04:32.400
We should specify that the platform call them in the left table has to be our foreign key that references

66
00:04:32.400 --> 00:04:35.280
the console dates table on the right.

67
00:04:35.310 --> 00:04:37.540
This way we can join them together.

68
00:04:37.620 --> 00:04:42.900
We can select data from both of them and they just makes our life much much easier.

69
00:04:42.990 --> 00:04:49.170
Relational keys are used when you have a lot of different tables in the same database and a lot of your

70
00:04:49.170 --> 00:04:51.110
data is connected to each other.

71
00:04:51.150 --> 00:04:56.780
So it's very useful to know them and to be able to implement them in your database design.

72
00:04:57.000 --> 00:04:59.830
I hope you enjoy this lecture and I'll see you in LA.
