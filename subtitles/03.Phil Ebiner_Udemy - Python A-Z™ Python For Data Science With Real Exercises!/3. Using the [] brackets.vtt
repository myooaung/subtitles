WEBVTT
1

00:00:05.150  -->  00:00:05.520
Alone.

2

00:00:05.580  -->  00:00:06.140
Welcome back.

3

00:00:06.140  -->  00:00:08.640
Of course it might improve in the tutorial.

4

00:00:08.640  -->  00:00:14.130
We learned how to create lists but now how do we read information from lists.

5

00:00:14.130  -->  00:00:17.610
Because what's the point of storing data if you cannot access it right.

6

00:00:17.850  -->  00:00:23.700
So in today's Tauriel we'll have a look at the square brackets operator so that we will know how to

7

00:00:23.790  -->  00:00:24.770
access our lists.

8

00:00:24.930  -->  00:00:26.530
Let's go ahead and get started.

9

00:00:26.580  -->  00:00:27.710
So let's create a list.

10

00:00:27.810  -->  00:00:37.080
We'll call it this list w and this list will store the family values a lowercase the lowercase c d and

11

00:00:37.200  -->  00:00:37.750
e.

12

00:00:38.040  -->  00:00:40.740
All right so like a mini start of the alphabet.

13

00:00:40.740  -->  00:00:42.320
Run that's a key.

14

00:00:42.340  -->  00:00:43.570
There it is our list.

15

00:00:43.590  -->  00:00:47.210
Now how do we access elements that say I want to get letter A out of this list.

16

00:00:47.220  -->  00:00:48.610
How do I get there.

17

00:00:48.780  -->  00:00:54.420
Well as we spoke previously lists have indexation So we know that this is a sequence of elements that

18

00:00:54.420  -->  00:00:55.770
are ordered that are numbered.

19

00:00:55.770  -->  00:00:57.260
This one is always 0.

20

00:00:57.270  -->  00:00:59.440
This is 1 2 3 and 4.

21

00:00:59.610  -->  00:01:05.700
So let's go ahead and type in and double you and in square brackets 0 as simple as that.

22

00:01:05.700  -->  00:01:09.010
That gives us element with the starting element.

23

00:01:09.030  -->  00:01:11.480
It's always number 0 and it's values.

24

00:01:11.520  -->  00:01:19.710
A cell is the current w one that gives us element B W to C and so on.

25

00:01:19.710  -->  00:01:24.750
So another thing we want to explore here is how do we find out how many elements are in the list and

26

00:01:24.750  -->  00:01:25.170
Towler.

27

00:01:25.170  -->  00:01:26.540
So here we can see that there is five.

28

00:01:26.550  -->  00:01:31.680
But what if it's a very big list and we want to get an element at the very end how do we know how many

29

00:01:31.680  -->  00:01:32.150
they are.

30

00:01:32.250  -->  00:01:33.740
There's a couple of ways to do that.

31

00:01:33.750  -->  00:01:35.910
One way is to use the land operator.

32

00:01:35.910  -->  00:01:40.950
So if you or the line function if you use the line function on your list it will return the number of

33

00:01:40.950  -->  00:01:42.680
elements the total number of elements.

34

00:01:42.930  -->  00:01:48.210
So basically you want to access the last one you would say double you you wouldn't say five because

35

00:01:48.300  -->  00:01:49.550
then you get an error.

36

00:01:49.560  -->  00:01:51.330
You don't have five elements.

37

00:01:51.330  -->  00:01:57.300
You have five elements but there are exceptions Circes 0 0 0 1 2 3 4 5 is the total number of elements

38

00:01:57.300  -->  00:01:57.520
.

39

00:01:57.660  -->  00:02:00.890
But the last one will always have lenth minus one.

40

00:02:00.900  -->  00:02:02.150
That's what its index will be.

41

00:02:02.150  -->  00:02:05.020
So you would say W4 to get the last one.

42

00:02:05.070  -->  00:02:05.360
All right.

43

00:02:05.370  -->  00:02:07.490
And there's another way to do this.

44

00:02:07.500  -->  00:02:08.100
What's the other way.

45

00:02:08.100  -->  00:02:12.600
Well we can use negative indexation So let's say let's print out a list there is.

46

00:02:12.930  -->  00:02:16.950
And the way this list is indexed right now is zero here.

47

00:02:16.950  -->  00:02:17.980
Then this is one.

48

00:02:18.030  -->  00:02:20.010
This is two to three.

49

00:02:20.040  -->  00:02:20.770
This is for.

50

00:02:21.000  -->  00:02:26.420
Well the other way these lists are also indexed is through negative indexation and how does that book

51

00:02:26.430  -->  00:02:26.580
.

52

00:02:26.730  -->  00:02:30.080
Well the very last element is minus one.

53

00:02:30.270  -->  00:02:33.000
So not minus zero because there's no such thing as mine is zero.

54

00:02:33.000  -->  00:02:38.470
So a bit different to the normal indexation you can't it actually start at minus 1 at the very end.

55

00:02:38.670  -->  00:02:39.810
Here's minus two.

56

00:02:39.890  -->  00:02:46.800
Here it is minus three minus four here and minus five at the start.

57

00:02:46.980  -->  00:02:53.380
So we can use this indexation as well so if we say double you minus one we will get the element E.

58

00:02:53.400  -->  00:03:03.210
So that's the last one and we say w minus X W minus 3 we'll get and see this one so w minus 3 is exactly

59

00:03:03.210  -->  00:03:05.300
identical to W2.

60

00:03:05.430  -->  00:03:10.740
And notice here that for instance w minus 1 this is different behavior to see if you're coming from

61

00:03:10.740  -->  00:03:11.620
our.

62

00:03:11.700  -->  00:03:18.360
I'd hope to keep bringing up are a lot so if you haven't studied our it might sound a bit strange but

63

00:03:18.660  -->  00:03:24.240
nevertheless the reason is because the data science is right now centered on a lot of the work and our

64

00:03:24.240  -->  00:03:26.510
science is happening in our and python.

65

00:03:26.520  -->  00:03:28.840
A lot of people aim to learn both languages.

66

00:03:29.010  -->  00:03:32.970
If you ever do learn art you can always come back to this course and look at these comments later on

67

00:03:32.970  -->  00:03:33.960
as well.

68

00:03:33.960  -->  00:03:39.150
So in our what this would do is it would exclude the first element to it would say.

69

00:03:39.150  -->  00:03:40.660
All right so you want the whole.

70

00:03:40.710  -->  00:03:46.470
In that case vector except for this first element because in are they do get indexed at once so it basically

71

00:03:46.470  -->  00:03:50.450
would look for the index and exclude that index and return the rest of the vector.

72

00:03:50.460  -->  00:03:55.140
So just bear in mind that the behavior is different in Python when you specify a negative index.

73

00:03:55.170  -->  00:04:01.800
It just uses this negative annexation that exists in your list and it then picks up the elements based

74

00:04:01.800  -->  00:04:02.480
on that.

75

00:04:02.790  -->  00:04:05.860
So there we go that's how negative indexation works in Python.

76

00:04:06.120  -->  00:04:10.500
And one more thing I wanted to show you is how you can over right values.

77

00:04:10.500  -->  00:04:14.790
So you can actually specify elements of illis to have different values.

78

00:04:14.790  -->  00:04:21.780
Let's look at W there is a b c d or you can say w element number two and you get a value of for example

79

00:04:21.780  -->  00:04:22.530
63.

80

00:04:22.530  -->  00:04:27.660
Now if you look at W. you'll see that we replaced the value we actually overwrote the value of that

81

00:04:27.660  -->  00:04:28.720
element.

82

00:04:28.740  -->  00:04:34.230
So there we go that's how we work with lists and pi then we can we now know how to create them how to

83

00:04:34.230  -->  00:04:38.130
change their values and how to read values out of lists.

84

00:04:38.130  -->  00:04:45.810
And from here I encourage you to explore explore the programming language and try to see what happens

85

00:04:45.810  -->  00:04:48.060
if you specify different values so what happens.

86

00:04:48.060  -->  00:04:52.980
For instance if you specify a value here that is greater than the number of elements in a list or if

87

00:04:52.980  -->  00:04:56.070
you specify a very large negative value here.

88

00:04:56.190  -->  00:05:00.720
See what happens if you try to create two lists and then the right values from one end to another and

89

00:05:00.720  -->  00:05:01.950
just play around.

90

00:05:01.950  -->  00:05:08.040
Ask yourself different questions ask questions inside the course if you need to and explore because

91

00:05:08.430  -->  00:05:13.130
ultimately programming is not just about learning a theory and doing some defined practical exercises

92

00:05:13.140  -->  00:05:16.660
it's also about exploring making mistakes learning from those mistakes.

93

00:05:16.680  -->  00:05:21.810
Understanding how the programming language works and then exploring further and further and actually

94

00:05:21.810  -->  00:05:24.300
there's a great talk on Ted.

95

00:05:24.330  -->  00:05:31.020
So Ted Talks I kind of like Ted talks and one of them was very inspiring a lot of them are very inspiring

96

00:05:31.020  -->  00:05:38.040
actually but one that relates to this topic of exploring is called Lee cometary So it's spelt I g l

97

00:05:38.040  -->  00:05:44.010
y g o m e t r y and I actually brought this up in our programming course and a student later message

98

00:05:44.010  -->  00:05:50.190
me that this talk really influenced his life and after washing it he has a different perception of learning

99

00:05:50.190  -->  00:05:50.800
things.

100

00:05:50.820  -->  00:05:53.160
So if you have some time definitely check it out.

101

00:05:53.160  -->  00:05:54.830
It's by I mean too funny.

102

00:05:54.870  -->  00:06:01.620
He works at Singularity University and some other places as well in the U.S. and it's very interesting

103

00:06:01.620  -->  00:06:05.640
talks about measuring so Lego is darkness.

104

00:06:05.640  -->  00:06:08.400
So what we don't know a metric is measuring.

105

00:06:08.400  -->  00:06:11.590
So it's about measuring what we don't know.

106

00:06:11.610  -->  00:06:17.010
So learning through understanding what we don't know and trying to learn that's very inspiring talk

107

00:06:17.010  -->  00:06:17.360
.

108

00:06:17.430  -->  00:06:18.900
Check it out if you have some time.

109

00:06:19.060  -->  00:06:22.480
And otherwise I encourage you to experiment with bison and I'll see you next time.

110

00:06:22.500  -->  00:06:23.900
Until then happy coding

111

00:06:25.970  -->  00:06:28.130
.
