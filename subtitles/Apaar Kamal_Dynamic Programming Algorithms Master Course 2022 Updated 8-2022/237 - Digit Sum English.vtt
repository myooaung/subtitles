WEBVTT

00:00.810 --> 00:01.560
Welcome back.

00:02.490 --> 00:03.960
Next problem was digit some.

00:04.560 --> 00:05.370
It did some.

00:05.910 --> 00:10.830
So the problem statement is that finding number of individuals between one and third is fine.

00:10.830 --> 00:11.940
The following conditions.

00:13.300 --> 00:19.210
The falling condition, which is the sum of digits in basten is a multiple of d so we have been given.

00:20.270 --> 00:25.490
E and B it is only half full, but gay is very big.

00:25.970 --> 00:27.200
So we cannot gay.

00:27.740 --> 00:29.870
We have to input as it is.

00:29.870 --> 00:30.140
But.

00:31.060 --> 00:38.080
If we cannot put it as an integer because in Indonesia we have only ten deliberating rate, so it's

00:38.080 --> 00:41.320
not eight in addition to the four, which is huge.

00:41.330 --> 00:43.880
So we have to take it as a thing, right?

00:44.380 --> 00:46.930
So let's not worry about how to take the input or something.

00:47.320 --> 00:53.490
But the problem the problem is some of the digits in based on is a multiple of.

00:54.800 --> 01:01.040
It means from when to tell me all those numbers whose some of digits and based in.

01:02.590 --> 01:03.920
They stand as nothing more decimal.

01:03.920 --> 01:04.180
Right.

01:04.940 --> 01:05.290
So.

01:06.080 --> 01:14.300
For example, Ford has a similar prediction based inequality for 822, has a similar digit as in based

01:14.300 --> 01:15.950
in cluster 22.

01:16.220 --> 01:21.350
And I want that to be a multiple of D, which we are still only eight here.

01:21.680 --> 01:27.320
So this problem will introduce you to the GDP if you're not had not heard about it, don't worry.

01:27.710 --> 01:31.010
Been solid and it's not not a big topic.

01:31.010 --> 01:32.870
It's a very nice, interesting problem.

01:32.870 --> 01:38.690
It's a nice very, very nice interesting topic and very easy just they just a small catch that you need

01:38.690 --> 01:40.250
to understand and.

01:42.110 --> 01:49.010
So before moving on to this problem, I want you to understand that catch for us, because if you understand

01:49.010 --> 01:51.470
it, then you will be able to solve this problem yourself.

01:52.230 --> 01:53.390
Hey, what, what?

01:53.540 --> 01:54.620
What I want to do is.

01:54.620 --> 01:55.370
I just.

01:56.370 --> 02:00.390
Let's say I have an integer 40 and I want to put into all the numbers.

02:02.590 --> 02:02.940
Okay.

02:02.950 --> 02:05.980
So let's say I want to print all the two digit numbers using recursion.

02:06.580 --> 02:07.510
How do I do that?

02:08.000 --> 02:11.080
So slightly I'm slightly diverging from the problem.

02:11.080 --> 02:12.580
But I want you to understand this.

02:12.610 --> 02:12.910
Right.

02:13.000 --> 02:13.750
It's very important.

02:14.230 --> 02:16.270
I just want to print only two digit numbers.

02:16.860 --> 02:17.980
So how do I do that?

02:19.320 --> 02:22.850
Using records in a normal rate, it means a.

02:24.070 --> 02:31.390
What I can do is I can simply call, let's say the function go right, and it will be a void function

02:31.570 --> 02:33.970
in which what I do is at first place.

02:33.970 --> 02:40.450
That is, I want to print all the numbers of two digits, eight, place one and I will be.

02:42.150 --> 02:44.910
Fixing numbers from 1 to 9 and on.

02:44.910 --> 02:45.450
Please do.

02:45.450 --> 02:46.860
I'll be fixing numbers from.

02:48.650 --> 02:50.690
0298987.

02:50.690 --> 02:52.700
Duped into holding all the digits from.

02:54.540 --> 02:58.080
All the digits of one digit as well as to the date.

02:58.110 --> 03:04.770
So instead of 1 to 9, I can fix zero also with eight and so I can fix 0 to 9.

03:04.770 --> 03:06.630
And here what will have it be like 029.

03:06.630 --> 03:07.620
So what's happening?

03:07.770 --> 03:08.520
I'm starting.

03:09.000 --> 03:15.150
So in the first location I am either filling with 0123456789 and then again.

03:15.420 --> 03:21.120
But all these values again I'm filling 012 and so on the line for all these values.

03:21.630 --> 03:23.910
This is giving me all possible combinations.

03:24.790 --> 03:26.240
So let me is slightly coded.

03:26.730 --> 03:28.350
Oh, let's start from index.

03:29.160 --> 03:32.520
Let's start from index zero that we start from the zeroth position.

03:32.940 --> 03:39.510
And reading a function here which is, let's say on which index had one and let's call.

03:40.690 --> 03:40.990
Okay.

03:40.990 --> 03:42.480
So I should do the work here.

03:42.970 --> 03:43.260
Eight.

03:44.480 --> 03:50.420
So because you don't know what happens in this go I, I go for all the digits let's call them digits.

03:51.080 --> 03:52.250
It's right there.

03:52.250 --> 03:56.870
Digit will start from zero to N and digit plus plus and so on.

03:57.740 --> 03:59.750
And I want to print all the numbers.

03:59.750 --> 04:02.900
So basically it's positive, but initially, let's call it zero.

04:04.930 --> 04:08.320
Number two, initially it is zero or.

04:11.210 --> 04:11.510
All.

04:13.770 --> 04:14.140
Right.

04:14.150 --> 04:15.410
So no problem with that.

04:15.780 --> 04:22.340
And what I'll do is I'll simply say, go just using normal recursion here, go I plus one.

04:22.340 --> 04:24.320
That means an index eight plus one.

04:24.620 --> 04:27.710
Fix the digit, which I'm going to give you eight.

04:28.160 --> 04:29.870
So what I'll have is.

04:31.540 --> 04:31.810
Yeah.

04:32.110 --> 04:37.140
And finally, what I have is if I look ahead, it will be numb in 210.

04:37.150 --> 04:39.160
So let's see if it was equal to one.

04:39.160 --> 04:40.960
I just multiplied by nine zero.

04:40.960 --> 04:43.290
Do it and added it'd be happier.

04:44.110 --> 04:44.380
Well.

04:45.260 --> 04:49.760
And if I is equals, true to what I do is I simply CO2 numb.

04:50.790 --> 04:51.310
Anderton.

04:54.630 --> 04:56.220
Okay, Nadine, it will go down.

04:57.380 --> 04:58.190
Equal to name.

05:00.910 --> 05:04.390
What I have is zero one and so on nine and then ten and the 99.

05:04.390 --> 05:07.630
So you can see I am bringing all the hundred digits on the right hand side.

05:08.050 --> 05:14.650
If I want to bring the three digit numbers in, I can do the same thing in depth of three, right?

05:15.310 --> 05:18.130
Now you can see that I have these three digit numbers.

05:18.130 --> 05:19.540
I'm bringing all the three digit numbers.

05:19.540 --> 05:22.450
So here we have a thousand numbers from zero to 999.

05:23.050 --> 05:26.800
And what if I just wanted to print only three digit numbers?

05:27.770 --> 05:29.980
That's very it's also very easy.

05:30.160 --> 05:32.440
I can simply take the number of digits in them.

05:33.370 --> 05:34.260
If you're not really sure.

05:34.270 --> 05:37.900
Eight I what I can do is I can force one upside in depth.

05:38.980 --> 05:39.280
Eight.

05:40.290 --> 05:41.340
Which can also do the work.

05:41.340 --> 05:43.770
So this is normal recording and nothing else.

05:44.310 --> 05:47.730
I'm iterating over all the numbers from zero to.

05:50.610 --> 05:51.960
Some to the right.

05:52.140 --> 05:53.790
Now, let's say I want to print.

05:54.120 --> 05:56.760
This is the important part that I want to print.

05:56.760 --> 05:57.960
Only number still.

05:58.860 --> 05:59.400
75.

06:00.510 --> 06:02.130
So let's have Ivan in Brazil.

06:02.790 --> 06:04.260
And I just want to.

06:05.280 --> 06:07.200
Find out the number still 75.

06:07.230 --> 06:12.270
If I go greater than 75, then I simply return back.

06:12.270 --> 06:14.160
I don't want to go.

06:14.670 --> 06:15.910
It's not about printing.

06:15.930 --> 06:20.700
It's about not even going for getting almost greater than 75 eight.

06:20.880 --> 06:24.700
So in that case, how should be my recursive approach, guys?

06:24.780 --> 06:26.100
What should I follow here?

06:27.220 --> 06:29.170
Just think about this if I want to.

06:30.560 --> 06:32.600
Print the numbers only did 75.

06:33.650 --> 06:35.870
Then what should be my recursive approach?

06:37.980 --> 06:39.570
So let me explain you this.

06:40.410 --> 06:42.340
This is the main catch of the day.

06:42.360 --> 06:43.770
People get mask after this.

06:44.250 --> 06:49.650
Most other things will become clear to you and you will be able to see all many of the people with a

06:50.010 --> 06:53.820
sort of digital dippy statement management do.

06:53.850 --> 06:55.200
I'm starting from zero initially.

06:55.470 --> 06:57.180
Initially, my numbers started from zero.

06:57.780 --> 07:00.990
I want to bring the number still 75 eight.

07:01.380 --> 07:01.980
So let's see.

07:05.390 --> 07:05.660
Yeah.

07:05.990 --> 07:06.470
Let's see.

07:06.890 --> 07:07.350
Italy.

07:07.370 --> 07:08.510
I'm just opining.

07:09.590 --> 07:11.210
Okay, so here we have 75.

07:12.630 --> 07:16.500
So based on the first digit here on the first is your day.

07:16.620 --> 07:20.700
What all numbers can I place on the first digit here?

07:21.030 --> 07:27.900
I can place the numbers from 0 to 7 and I can not exceed that rate on the first location.

07:27.900 --> 07:28.680
I can only.

07:28.920 --> 07:30.080
So here we have a consent.

07:30.090 --> 07:32.340
Instead of placing all the innermost from 0 to 9.

07:33.330 --> 07:36.460
I can only place in the Muslims 0278.

07:36.600 --> 07:37.230
So let's see.

07:39.230 --> 07:41.750
I'm just mocking it because of debate over there.

07:42.140 --> 07:46.220
For the first location, I have zero, which can be on the first location one.

07:47.350 --> 07:47.600
Two.

07:48.280 --> 07:49.570
I'm talking about the first place.

07:49.570 --> 07:51.670
Here are the 10th place in this case.

07:52.510 --> 07:52.810
Three.

07:53.470 --> 07:56.530
Then we will have four, five, six and seven.

07:57.030 --> 07:58.360
Now, this is an important part.

07:58.480 --> 07:58.690
Eight.

07:59.350 --> 08:01.330
We have numbers in seven.

08:01.870 --> 08:06.730
Now, guys, if I have zero on the first place, so let's have field first place with zero.

08:07.180 --> 08:12.400
Then the second place can be filled from any number from 0 to 9 eight, because that will be less than

08:12.400 --> 08:12.970
70 divided.

08:13.970 --> 08:14.240
Okay.

08:14.630 --> 08:20.090
So if I place any number from 0 to 9 on the second, please, that means I'm making all the single digit

08:20.090 --> 08:21.800
numbers if I'm placing.

08:22.940 --> 08:25.070
So now you some of you might be wondering that.

08:25.070 --> 08:30.500
Okay here I have five Vinod Ltd Bill five only via and we're printing it.

08:30.650 --> 08:34.150
Why am I adding the numbers from 0 to 9 on the second place?

08:34.160 --> 08:35.930
Why not just go down five?

08:35.930 --> 08:37.550
Because on the first place I have zero.

08:37.550 --> 08:37.880
Right?

08:38.190 --> 08:42.350
But if I have something which is less than seven, then it is zero.

08:42.350 --> 08:45.020
Or one or two of three or four or five or six.

08:45.290 --> 08:49.100
Even if it is six, then also I can base all the numbers from 0 to 9.

08:49.880 --> 08:50.660
What does this mean?

08:50.660 --> 08:53.390
That I am not on the right the most?

08:54.810 --> 08:56.130
Part of the story.

08:57.070 --> 09:00.370
If I'm the rightmost part of this tree, then it would be limited.

09:00.370 --> 09:07.060
That means if I have fixed seven on the first place here that I cannot fix.

09:08.530 --> 09:11.350
Anything which is greater than five on the second place now.

09:11.550 --> 09:17.230
Now I have a constraint that is only fill it with 0 to 5.

09:17.920 --> 09:19.720
I cannot fill it with zero.

09:19.870 --> 09:21.490
I cannot fill the second with with six.

09:21.490 --> 09:23.650
Not only 0 to 5 going to this particular.

09:24.610 --> 09:25.900
Location that means.

09:27.090 --> 09:31.380
This tree will have all ten branches again.

09:31.380 --> 09:33.060
This will have all ten branches.

09:33.480 --> 09:35.100
Similarly for this, all ten branches.

09:35.100 --> 09:39.450
But for seven it will have only zero, one, two, three, four and five.

09:39.480 --> 09:43.170
Only six branches coming out of it for the second location.

09:43.200 --> 09:43.410
Eight.

09:43.620 --> 09:47.940
Let's see, let's see that this was not just seven.

09:47.940 --> 09:51.390
Five, let's say this was 752.

09:51.840 --> 09:53.940
Well, let's say this was 752.

09:53.940 --> 09:55.980
The number was big and it is 752.

09:56.340 --> 10:02.790
I want to bring down number still 752 So if I had the first location, I am printing 0 to 6 any numbers

10:03.090 --> 10:05.970
that means now I don't have any constraints on.

10:07.290 --> 10:08.100
The branches.

10:08.400 --> 10:09.540
We have nine branches here.

10:09.720 --> 10:12.690
No matter what, I please either be zero one, two, three, four, five, six.

10:12.690 --> 10:14.820
Anything is right in the first place.

10:14.820 --> 10:15.120
Zero.

10:15.120 --> 10:17.820
I can base anything over here and I can base anything away.

10:18.450 --> 10:19.160
Similarly for this.

10:19.170 --> 10:19.890
Similarly for this.

10:20.190 --> 10:23.180
But now let's talk about seven eight.

10:23.190 --> 10:27.240
So if on the if on the first place, I placed seven, let's say here I have seven.

10:27.750 --> 10:30.780
Now on the second location, I can only place 0 to 5.

10:30.780 --> 10:31.470
We all know that.

10:31.470 --> 10:31.880
So let's see.

10:31.890 --> 10:34.560
This is zero one, two, three, four, five.

10:36.000 --> 10:40.470
So this is zero one, two, three, four, five.

10:40.800 --> 10:43.290
These are these second locations right now.

10:43.290 --> 10:45.780
This for this particular zero.

10:46.750 --> 10:48.010
Let's talk about this zero.

10:49.360 --> 10:49.720
Again.

10:49.720 --> 10:56.410
I can't place any of the Nine Values VI because I'm not on the rightmost part of the tree that I must

10:56.410 --> 11:02.590
pass, but that I most part is seven, then five, then it will be too letters, right?

11:02.830 --> 11:06.790
But right now, if I want the zero, that means I play seven and I play zero.

11:07.150 --> 11:09.970
I haven't placed anything, ladies.

11:09.970 --> 11:15.070
That means I can just anything over there because I know I'm on not on the rightmost, but similarly,

11:15.070 --> 11:20.230
guys, all nine will lose or ten they lose can come in, all the envelopes can come here, all ten values

11:20.230 --> 11:20.800
can come here.

11:21.220 --> 11:26.110
But for five, this five can only have three values after this, which is zero one and two.

11:26.440 --> 11:31.840
If I am placing five in the second location, then I can only play zero one or two on the third base.

11:32.350 --> 11:33.640
But this five was the.

11:34.630 --> 11:36.120
Rightmost part of the tree.

11:36.130 --> 11:36.390
Right?

11:36.400 --> 11:37.420
This was the end.

11:37.750 --> 11:40.540
This was the last basically last four.

11:40.690 --> 11:42.910
So this seven was the last for the first edit.

11:43.630 --> 11:45.610
This five was the last for the second digit.

11:45.610 --> 11:47.620
And now this tool will be last for the third digit.

11:47.620 --> 11:55.840
So if I make another if I try to go deeper into it, then this to this particular two will be will have

11:55.840 --> 12:01.780
a limited value of subseries so that all of them are not so that we don't exceed this two.

12:01.780 --> 12:02.110
Right.

12:02.890 --> 12:04.120
I hope do go at this point.

12:04.120 --> 12:07.210
So let's print the values till seven divided by eight.

12:07.630 --> 12:07.960
So.

12:08.870 --> 12:13.220
But I know I'm taking a swing because we have to do the voting thing.

12:13.790 --> 12:15.690
Now I say go eight.

12:16.250 --> 12:16.550
Go.

12:17.570 --> 12:18.950
Greenville started a near zero.

12:19.940 --> 12:22.130
Well, let me try the function called Google.

12:22.370 --> 12:24.140
It will started in next.

12:27.320 --> 12:28.640
I and.

12:29.980 --> 12:37.210
Let's have a boolean value which will tell me whether is it the right most modern metric or not.

12:37.210 --> 12:39.130
So let's call it last eight.

12:39.310 --> 12:43.180
So what happens is initially we are on the last.

12:43.180 --> 12:46.150
That means and the first place we will place only seven.

12:46.600 --> 12:50.710
But if we have placed anything which is less than seven, then last is false.

12:51.850 --> 12:53.740
Because now we can place all nines.

12:54.250 --> 12:59.770
And if seven is placed on the on the first place, then we can have any rule.

13:00.160 --> 13:01.300
So what I do here is.

13:03.870 --> 13:04.140
Yeah.

13:04.170 --> 13:08.850
So what I do here is go and usually I'll pass one as it goes on the zero the next.

13:08.850 --> 13:11.760
I want to place it in seven only, not in nine eight.

13:12.090 --> 13:14.610
So let's iterate over all the digits.

13:18.210 --> 13:21.150
Digits and digits will go till nine.

13:21.840 --> 13:23.820
Now, what I'll do is symbol.

13:24.360 --> 13:24.720
So.

13:26.350 --> 13:26.680
Let's.

13:28.890 --> 13:30.020
Another variable called kill.

13:30.030 --> 13:32.580
That means, Bill, where do we want to print it?

13:33.610 --> 13:37.380
But instead of making all digits, go to ten.

13:37.380 --> 13:38.820
Let's make it.

13:38.820 --> 13:38.970
Go.

13:38.970 --> 13:40.270
Tell it like.

13:42.550 --> 13:43.630
What will we tell you?

13:43.690 --> 13:44.260
It will be.

13:45.650 --> 13:52.700
If last is true, that means if I'm on the last one on the rightmost part of the tree on it, then I

13:52.700 --> 13:58.960
will only move until I say -0 because it's an integer.

13:58.970 --> 14:00.880
So I'm just converting it eight.

14:01.130 --> 14:03.140
So I'll say -0.

14:03.470 --> 14:05.060
Only if last is true.

14:05.060 --> 14:05.300
Right.

14:05.300 --> 14:07.760
So how do we rated using the new operators?

14:08.270 --> 14:12.080
If last is true, then it will be equal to say -0.

14:12.110 --> 14:13.190
The last value.

14:13.430 --> 14:15.470
Otherwise it will be equal tonight.

14:17.020 --> 14:18.370
So let's make your destiny.

14:18.700 --> 14:20.050
I hope this part is very clear.

14:20.800 --> 14:25.570
If I'm the last mouse right, then only girdle this location only put these many digits.

14:25.780 --> 14:26.680
Otherwise golden.

14:26.950 --> 14:28.210
All the digits.

14:28.630 --> 14:29.680
Eight and.

14:31.170 --> 14:34.470
Let's make this number eight that we want to print.

14:35.120 --> 14:35.730
So what will.

14:36.000 --> 14:37.590
Okay, so initially, I'm starting with zero.

14:38.970 --> 14:42.750
So what I'll do is I simply say go and I bless when of course.

14:43.530 --> 14:47.040
And yeah, so how do I form the lost value?

14:47.310 --> 14:51.000
But the lost value is only true if the previous last was true.

14:51.000 --> 14:54.630
That means if I'm on the last value and.

14:55.910 --> 14:57.950
This digits is equal to tell.

14:59.020 --> 14:59.470
Hey, guys.

14:59.470 --> 15:01.240
This is an important part of it.

15:01.510 --> 15:01.930
Okay.

15:02.380 --> 15:08.050
Earlier I was on last because guys, if last is false, even once, that means let's say I came here

15:08.050 --> 15:09.100
and lost is false here.

15:09.670 --> 15:11.980
If it is false, then it can never be true in its subtree.

15:12.400 --> 15:15.550
Last is only true on the rightmost part of the.

15:16.800 --> 15:18.180
Think on the right mouse pad.

15:18.810 --> 15:21.510
Hey, because from here I get lost or withdrew.

15:21.510 --> 15:22.700
Then I get lost to be true.

15:22.710 --> 15:24.700
Then I get lost for me to pull.

15:25.290 --> 15:29.280
If last is true and the digit is equal to the last, which is still.

15:29.610 --> 15:34.350
Both of these conditions have to be true to make the last would be true for the next particular.

15:35.500 --> 15:35.980
Index.

15:36.550 --> 15:41.110
And finally, what will within a McAllen, I mean, do ten plus digit.

15:43.010 --> 15:44.480
Hey, let's build this one's.

15:46.640 --> 15:47.190
Okay.

15:47.530 --> 15:48.470
No bias case here.

15:48.490 --> 15:49.900
So if I is equals to.

15:51.890 --> 15:53.450
As George says, let's say this.

15:55.210 --> 16:00.550
So if I go straight as outside, that means I have to dig -- to it and then put my word.

16:03.910 --> 16:05.020
We're really close to two.

16:05.020 --> 16:06.960
That means I've reached the end.

16:06.970 --> 16:07.900
I simply say out.

16:07.930 --> 16:08.320
No.

16:09.960 --> 16:10.580
And I let him.

16:13.140 --> 16:16.250
Actually, you can see I have all the numbers, but just in 75.

16:17.150 --> 16:19.130
I'm not excluding 75.

16:19.130 --> 16:21.950
I started from zero going below 75 and nothing.

16:21.950 --> 16:22.250
It's.

16:24.460 --> 16:27.430
I hope this is being very clear to you.

16:27.940 --> 16:29.860
How am I bringing numbers to 75?

16:29.860 --> 16:31.710
By using Dell and lost.

16:32.470 --> 16:33.060
This is normal.

16:33.070 --> 16:33.520
It goes on.

16:33.520 --> 16:34.390
Nothing else, right?

16:35.480 --> 16:36.040
Well, let's see.

16:36.050 --> 16:39.110
I want to find out that how many numbers are there in 75.

16:39.740 --> 16:43.760
So we all know that there are 76 numbers and it's a good integer type.

16:45.020 --> 16:45.350
Okay.

16:46.960 --> 16:48.540
We'll do that later on.

16:50.260 --> 16:51.070
Well, no problem.

16:51.640 --> 16:51.850
It.

16:56.200 --> 16:59.140
So this was a very basic example of.

17:00.960 --> 17:03.180
Going over those numbers, which are.

17:07.030 --> 17:13.160
We just a specific right now here what we have is we have num we have a and we have lost.

17:13.180 --> 17:15.840
So we have we have only three things, guys, right?

17:16.060 --> 17:17.830
And of course, we also don't need this number.

17:18.660 --> 17:21.090
It just using it for printing stuff, nothing else.

17:22.360 --> 17:26.050
So this is normal to go in in the next tutorial.

17:26.050 --> 17:28.270
Explain you how this fits into the problem.

17:28.900 --> 17:32.220
Wait, how how is this actually digital?

17:32.380 --> 17:33.370
This is the GDP.

17:33.670 --> 17:40.120
We we haven't optimized it, but yeah, so this is the base of digital TV and you guys see in the next

17:40.120 --> 17:40.390
part.
