WEBVTT

00:00.440 --> 00:00.660
Yeah.

00:00.740 --> 00:01.490
So let's call it.

00:01.820 --> 00:07.340
And in the previous example, I took example of a segment, but in this case we can take an example

00:07.340 --> 00:08.030
of one victory.

00:08.300 --> 00:15.290
And maybe I'll also do one more problem in which I can fix possible eight cosmetic as possible.

00:15.350 --> 00:21.560
Although we have already seen in LCA like you want to calculate LCA, we can use table eight, but let's

00:21.560 --> 00:21.860
just.

00:24.440 --> 00:26.680
All this using French victory rate.

00:26.690 --> 00:31.010
So some of you might be wondering, because of here, we have to take maximum rate.

00:31.370 --> 00:36.380
We have reading maximum of a particular range and then at plus one do it so.

00:37.670 --> 00:45.230
What we can do here is that, as you know, for any element, I want the maximum of the prefix that

00:45.230 --> 00:48.600
means on the whatever is on the left of the prefix to complete.

00:48.890 --> 00:54.160
And we cannot, you know, we cannot use Fenwick trees, we cannot use fen victory, which is to get

00:54.470 --> 00:55.670
all binding text for you.

00:56.930 --> 01:00.410
We cannot use them for maximum and minimum queries.

01:01.280 --> 01:02.600
We should not use them generally.

01:03.200 --> 01:07.670
Maximum minimum wages for a range because it does not support it.

01:07.850 --> 01:12.110
But we can use defend victory for some prefix of things, right?

01:12.380 --> 01:15.650
I mean, we cannot do it for a range, but we can do it for the prefix of things.

01:16.060 --> 01:22.760
So some of you already might know this because you have seen the structure of enmity or if not just.

01:23.760 --> 01:28.350
Because it's in your mind that you can always find victory for the minimum and maximum.

01:28.440 --> 01:29.870
Always using military aid.

01:30.810 --> 01:35.370
But what if the if the queries for prefixes, then you can always use it.

01:36.010 --> 01:38.560
Well, so let's move to the code.

01:39.040 --> 01:44.040
So this is my normal phone victory and I landslide it by end in itself.

01:44.070 --> 01:47.460
Initially, I'll fill it with zero because now we have to find a maximum rate.

01:47.930 --> 01:49.860
Let me updated with maximum.

01:51.210 --> 01:57.810
Maximum to whatever is the maximum, it will just give you the maximum and return back full.

01:58.170 --> 01:59.910
So initially I'll fill it with zero.

02:00.090 --> 02:03.870
And on the update, also what I can say is, yeah, this will work.

02:04.590 --> 02:08.340
So this is a normal fan retrieve which will work for the prefixes, minimum and maximums.

02:09.000 --> 02:14.910
So let me initialize it and let's call it etch its bus and do it and before.

02:14.910 --> 02:16.140
And let's take and.

02:18.320 --> 02:18.620
And.

02:18.790 --> 02:21.470
And it's the big daddy that we have.

02:21.860 --> 02:22.220
Who?

02:24.570 --> 02:26.730
I'm tired of digging in input again and again.

02:28.650 --> 02:28.880
Well.

02:29.220 --> 02:32.100
And finally, we just initialize this family.

02:32.110 --> 02:37.380
What it will do is it will go to in return and it will just initialize things for us.

02:37.890 --> 02:38.050
Good.

02:38.340 --> 02:39.810
And after this, let's move ahead.

02:40.650 --> 02:40.920
Yeah.

02:41.250 --> 02:43.650
But before moving ahead, what we need to do is we need to go in.

02:43.650 --> 02:44.100
In order.

02:44.700 --> 02:46.590
We need to go to the smallest.

02:48.260 --> 02:50.450
The index, which has the smallest element first.

02:50.930 --> 02:53.540
So to make that, let's take some beers.

02:54.720 --> 02:55.510
Let's stick up here.

02:55.510 --> 02:55.820
Ready?

02:55.860 --> 02:57.060
And it's got to be in.

02:57.810 --> 03:01.330
And as part of the period we will be completed.

03:01.350 --> 03:02.190
A period, nothing more.

03:02.190 --> 03:04.380
Diego, I hope this works.

03:05.070 --> 03:07.670
If not, yeah, it looks cool.

03:07.830 --> 03:11.520
And after this, I would simply say sort become a blessing.

03:13.090 --> 03:19.690
I just started how it been started with firstly start on the basis of the values and we are also keeping

03:19.690 --> 03:20.350
the indexes.

03:20.410 --> 03:25.000
So we will get all the indexes lined up according to the values, correct.

03:25.270 --> 03:28.060
Now what we can do is we can simply iterate over this very.

03:29.710 --> 03:36.880
So let's let's call the bell value and that will be nothing would be taught first rule and what will

03:36.880 --> 03:40.120
be the index on which this value skipped.

03:40.120 --> 03:44.650
It is nothing but b I wrote back in full and I'm going from 0 to 1.

03:44.650 --> 03:52.180
That means I'm going in an increasing order rate and we need to calculate some DB area value within

03:52.210 --> 03:52.450
three.

03:52.690 --> 04:00.040
So let's calculate some epi and or we can also use lesson eight.

04:00.220 --> 04:06.130
Initially a layer should be filled with zeros, but never mind, we don't want it to be filled with

04:06.130 --> 04:12.000
zeros initially because we know our Fenwick tree is initially filled with zeros on.

04:13.380 --> 04:18.750
What we can do here is we can simply say that I like this index because we are updating the index.

04:18.750 --> 04:20.370
Not I remember this.

04:20.370 --> 04:22.650
It's important in updating those indexes only.

04:22.650 --> 04:22.950
Right.

04:23.500 --> 04:30.390
So I simply say layers of indexes, nothing but whatever this friend victory has to give me is the query

04:30.390 --> 04:30.780
function.

04:30.790 --> 04:31.590
Yes, these are very.

04:32.980 --> 04:36.760
It just equity still index minus one.

04:38.170 --> 04:38.560
Correct.

04:39.520 --> 04:39.790
So.

04:41.370 --> 04:43.260
It will just go to retail index minus one.

04:43.410 --> 04:47.910
That means from prefix that is starting from index zero to index minus one.

04:47.910 --> 04:51.660
It will just tell me whatever is the minimum value that is there plus one.

04:52.380 --> 04:53.550
That's what I actually wanted.

04:53.560 --> 04:55.860
And finally, what I'll do is I'll simply update.

04:57.050 --> 05:04.790
Update that in nixing the family now now let's see how to update X and the value actually just pass

05:04.790 --> 05:08.270
the index it on this index just updated with the.

05:10.500 --> 05:10.920
Well, you.

05:12.200 --> 05:12.890
Oh, okay.

05:12.920 --> 05:13.800
Not this value.

05:13.820 --> 05:19.070
Actually, the value is this the value that we have calculated.

05:20.180 --> 05:22.400
So actually, we don't want these values.

05:22.550 --> 05:24.380
We just want the sorted index orders.

05:24.830 --> 05:25.230
But it's fine.

05:26.030 --> 05:27.890
So it's just similar to the biggest problem.

05:27.890 --> 05:30.160
Query, object, query, object, query, update.

05:30.410 --> 05:35.450
And in this vein, by going in and order, we can maintain the dacorum basically.

05:35.960 --> 05:36.230
Eight.

05:37.100 --> 05:39.650
The decorum that we need to finally.

05:40.100 --> 05:41.630
What is the place?

05:42.580 --> 05:42.790
So.

05:42.820 --> 05:42.910
So.

05:44.020 --> 05:44.290
Okay.

05:44.290 --> 05:46.090
Not the minority actually taking the maximum.

05:46.090 --> 05:47.970
So what if I have said minimum in middle?

05:48.460 --> 05:50.150
But finally, why did we lose?

05:50.170 --> 05:57.190
I just want whatever is the maximum value in the whole R3, starting from n, minus one and minus until

05:57.220 --> 05:57.550
zero.

05:57.910 --> 06:00.650
Tell me, what is the equity?

06:00.740 --> 06:02.470
What is the maximum value of the place?

06:03.130 --> 06:06.350
So in this case, I can see the maximum value of the places, right?

06:06.700 --> 06:10.510
So we can see it over here that it is five and returns on 40.

06:11.650 --> 06:17.470
Also what you can do is you can print this whole laser printed laser.

06:19.090 --> 06:19.330
But it.

06:21.050 --> 06:21.360
Also.

06:21.390 --> 06:28.070
So this is I think this is the value that we need to do two, three or four, four, three, five,

06:28.070 --> 06:30.770
four, five the last five years over here.

06:32.800 --> 06:38.620
I hope the advance Judas exiting is making sense because now you can see what is in and complexity of

06:38.620 --> 06:40.340
this update operation.

06:40.360 --> 06:42.310
It is log and.

06:43.110 --> 06:45.060
And this query operation is also.

06:46.690 --> 06:52.270
Lock and rate and in initiative and victory, which is nothing but an operation.

06:52.270 --> 06:53.740
I'm just resizing a vector here.

06:54.130 --> 06:57.730
After that, I thought, this very much is up here.

06:57.970 --> 06:59.350
So it is again and again.

07:00.670 --> 07:06.280
Any luck and testing is taking place over here after they're industry trading.

07:06.280 --> 07:10.810
And in each of these and iterations, what I'm doing is I'm grading, which is log and operation and

07:10.810 --> 07:12.610
updating, which is again a log in operation.

07:13.150 --> 07:21.310
But overall the complexity of the very becomes, the code becomes and log and just like the previous

07:21.310 --> 07:27.730
examples, um, so I hope this is very clear, this is just a short way of calculating.

07:30.970 --> 07:33.300
Alice in and Logan.

07:33.640 --> 07:35.650
So I have a follow up problem for you.

07:35.680 --> 07:42.460
Why don't you try and find out the inversion ground in an altitude using the same approach?

07:43.260 --> 07:45.600
You got it in verging on what we wanted to be one perennial.

07:45.870 --> 07:50.310
I want to find out how many elements are there which are on the left of it and which are greater than

07:50.310 --> 07:50.410
it.

07:50.910 --> 07:55.230
So in the two finding merging on properly, you can sort it.

07:56.400 --> 07:58.320
Emails or diaries, but nobody wanted.

07:58.360 --> 08:05.170
You want the more of elements a greater penetrate for that what you have to do is you just have to sergeant

08:05.170 --> 08:09.310
in the reverse order, in the decreasing order and then keep on updating and then keep on taking some

08:09.310 --> 08:11.140
from the left just giving you a hint.

08:11.140 --> 08:13.240
But please try the.

08:14.600 --> 08:15.920
Inversion count problem.

08:15.920 --> 08:20.510
If you haven't inversion count, it's not deep, but it is very handy.

08:21.800 --> 08:22.550
Thank you, everyone.

08:23.180 --> 08:23.840
In the next.
