WEBVTT

00:00.630 --> 00:00.800
Yeah.

00:00.930 --> 00:01.920
So let's go do this.

00:02.190 --> 00:08.760
And we already know the evolution and be delayed is something where the API goes deep.

00:08.760 --> 00:12.420
Let's run this deep list and we'll have the cases for them.

00:13.370 --> 00:14.600
We have some checks for them.

00:15.270 --> 00:17.150
So, yeah, let's stick to input.

00:20.700 --> 00:21.060
Okay.

00:21.060 --> 00:28.260
So let me take the input in assisting because here you can see this can be a 5000 digit oh Italian digits

00:28.260 --> 00:29.580
cannot be stored in an integer.

00:29.580 --> 00:29.850
Right.

00:30.270 --> 00:31.560
Let me take them as a string.

00:32.740 --> 00:33.220
And.

00:38.480 --> 00:43.400
Let's make it global because, you know, we will be writing some function if be function in that we'll

00:43.400 --> 00:46.250
have to use it and.

00:47.560 --> 00:52.140
It's included in the file because we don't have a break in conditions.

00:52.150 --> 00:55.150
I'm doing a file, one which will go on forever.

00:55.180 --> 01:01.390
The only breaking condition is that if I receive a zero, that means if s of zero is equal to zero,

01:01.960 --> 01:03.190
then simply break the loop.

01:04.120 --> 01:04.850
Otherwise word.

01:04.870 --> 01:10.900
What we'll do is we'll simply say C, ODP, and we'll start from the zeroth index as we did here.

01:10.900 --> 01:13.870
Right here, as we did here.

01:14.180 --> 01:16.150
We start from the zero, which is two.

01:16.420 --> 01:17.420
Now we have options.

01:17.440 --> 01:18.640
We'll break it and.

01:19.660 --> 01:20.590
Formulated the cause of.

01:21.550 --> 01:22.930
Well, so.

01:24.630 --> 01:28.700
Let's write a function called DP in which I will be passing in index.

01:29.190 --> 01:34.980
You guys remember I'm not passing string as I've taken it globally because if I want to pass it again

01:34.980 --> 01:40.800
and again, then you know it will vibrate again and again and give me a huge complexity.

01:41.310 --> 01:42.150
So I don't want that.

01:43.050 --> 01:44.640
Are there ways I can possibly reference?

01:45.180 --> 01:51.000
There are multiple ways to go, but I prefer this misleading thing globally for admin providing dynamic

01:51.000 --> 01:51.870
programming solution.

01:53.260 --> 01:53.760
And.

01:54.480 --> 01:54.720
Yeah.

01:55.850 --> 01:56.390
Let me.

01:57.410 --> 01:57.800
Put this.

01:58.690 --> 01:59.000
Yes.

01:59.090 --> 02:00.440
Right now I'm going to current index.

02:00.710 --> 02:02.270
What all options do I have added?

02:02.270 --> 02:07.580
I'll take single digit element, so I will take that single digit element.

02:08.000 --> 02:09.140
So if as index.

02:10.320 --> 02:14.550
Is greater than equal to zero, but greater than equal to one.

02:15.030 --> 02:18.330
And as index is less than equal to.

02:19.230 --> 02:19.590
Nine.

02:20.230 --> 02:22.570
That means I can take that as a single digit eight.

02:22.590 --> 02:24.660
So let me quickly rate answer zero.

02:25.680 --> 02:30.600
In this case, what will happen on the bill as it goes to be replaced by one?

02:31.020 --> 02:34.800
Because I've taken the current victor not tell me how many different possibilities are there from the

02:35.190 --> 02:36.480
next index.

02:36.810 --> 02:38.520
And I simply added to it.

02:38.730 --> 02:39.840
And what is the second case?

02:41.810 --> 02:43.070
What is the second case then?

02:43.330 --> 02:45.230
The next numbers should be between.

02:47.480 --> 02:47.830
Yeah.

02:47.840 --> 02:52.520
The next numbers are 1026 eight.

02:52.910 --> 02:54.500
So how do I figure this out?

02:54.530 --> 02:58.290
That the numbers should be between ten and 26?

02:59.540 --> 03:00.530
This is a tricky case.

03:01.660 --> 03:10.720
I mean, it's not that you can always write that if the next is one and then the second one can be between

03:10.720 --> 03:11.050
zero.

03:11.230 --> 03:18.280
In other words, if the next is two, then it can be between the other one can be between one zero and

03:18.280 --> 03:19.170
six eight.

03:19.180 --> 03:20.680
So that's what I'll be doing ahead.

03:20.690 --> 03:22.810
AS But if as overindex.

03:23.950 --> 03:26.410
Is equal to one.

03:27.700 --> 03:29.020
It then.

03:30.980 --> 03:33.140
The S index plus one.

03:33.990 --> 03:36.410
So in this case, just one more check that I need to have.

03:36.920 --> 03:37.670
What is that check?

03:38.030 --> 03:39.770
That index could be.

03:42.090 --> 03:47.270
Index should be greater index plus one should willesden hazard place.

03:47.820 --> 03:50.940
I am saying this because I'm checking index plus one or two.

03:51.000 --> 03:58.260
So this is the fun of using the top down approach rate because we never know when we go out of index

03:58.260 --> 04:00.120
and we need to have some special checks.

04:01.350 --> 04:04.800
But some of you might be wondering, why isn't a check over here for this index?

04:04.840 --> 04:08.090
So for this, what I simply do is I have a B, I have a base case rate.

04:08.430 --> 04:12.240
The index reaches the end of this thing that is as tight as amplitude.

04:12.240 --> 04:17.900
And one of the ways index will remain between zero and has got size minus one eight.

04:18.150 --> 04:20.370
And you don't need to have a special check for this.

04:20.700 --> 04:22.740
But for this, I can always have a special check.

04:23.740 --> 04:26.320
Heat index, plus one should be designated as dirty.

04:26.320 --> 04:28.420
Then I will be able to, you know, handle this.

04:30.170 --> 04:30.800
This is true.

04:31.840 --> 04:33.340
And this is true.

04:34.920 --> 04:35.210
Okay.

04:35.300 --> 04:38.160
So in this case, let me fulfill the total.

04:38.550 --> 04:38.850
Yeah.

04:38.910 --> 04:42.590
So it is that index is one an x index plus one.

04:42.600 --> 04:44.040
It can be between zero and nine.

04:45.070 --> 04:47.250
So how can I write it?

04:49.510 --> 04:50.890
It is between zero and nine.

04:51.220 --> 04:57.340
I don't think I should write it because it's obvious rate because all the digits are between zero and

04:57.340 --> 04:57.580
nine.

04:58.300 --> 04:58.590
Cool.

04:59.080 --> 05:03.790
If as index is equal to one, then what I can do is I can sound so classical should be I.

05:03.790 --> 05:10.100
Plus because I am taking one and any of the next digit and we between zero ending in but.

05:10.600 --> 05:14.950
And what's the hardest that now it is between 20 and 26.

05:15.760 --> 05:17.650
So if s index is equal to two.

05:18.860 --> 05:22.190
That means s index less.

05:22.190 --> 05:26.330
One could be less than equal to fix.

05:27.230 --> 05:31.600
It can be between 026, 2021, 2024, 27, 26.

05:32.070 --> 05:35.510
It's as index flows, one should be less than equal to x.

05:36.110 --> 05:38.150
I hope this is also very clear.

05:39.200 --> 05:40.980
And there were there are other ways also.

05:41.000 --> 05:41.650
What are you going to do?

05:42.710 --> 05:45.290
Let's say you have this sting.

05:45.650 --> 05:52.310
Let's say you take a big those pairs index and index, plus one function in which you pass those bars,

05:53.060 --> 05:56.870
those two characters, which will then you and indeed you enter them.

05:56.870 --> 05:57.130
Right.

05:57.290 --> 05:58.680
And then directly right.

05:58.920 --> 06:04.250
It is greater than equal to ten and less than equal to 36 one over 11.

06:04.250 --> 06:05.900
Surprising Mr. De Pierre plus two again.

06:06.170 --> 06:07.280
So this is the second case.

06:08.390 --> 06:13.290
And finally, what I'll do is I let Andy answer a.

06:16.690 --> 06:17.560
And what?

06:19.100 --> 06:20.600
It'd be a plus one.

06:20.630 --> 06:20.960
Okay.

06:21.450 --> 06:21.950
My word.

06:22.610 --> 06:23.880
Why am I okay?

06:23.900 --> 06:25.010
Look, let me.

06:26.470 --> 06:28.030
Make this index equal to.

06:28.540 --> 06:29.800
I hate.

06:31.010 --> 06:32.170
We make a record way only.

06:33.740 --> 06:33.880
Well.

06:34.010 --> 06:37.220
So whatever you're doing, we are getting 639 and one.

06:37.870 --> 06:39.200
Oh, is that what we want?

06:40.670 --> 06:46.010
But I know you can see the complexity of this solution is huge because sometimes it will be a linear

06:46.010 --> 06:46.730
tree someday.

06:46.910 --> 06:51.980
Sometimes it will be a binary to deliver it into two parts, as we can see in this example that.

06:53.710 --> 06:55.480
Here it is a linear tree, but here it is.

06:56.170 --> 07:00.040
Finality to the complexity can be huge.

07:00.520 --> 07:07.870
And yeah, so if the complexity can be very huge, what we'll do is we'll simply memorize it how we

07:07.870 --> 07:08.440
remember it.

07:08.650 --> 07:11.580
We only one state right before and DBA.

07:11.580 --> 07:13.720
Either way, the answer will remain constant.

07:14.320 --> 07:19.120
No matter from where I'm coming from behind EP, I will always be equal to.

07:20.460 --> 07:20.940
This.

07:21.740 --> 07:23.330
This and this.

07:23.810 --> 07:25.550
I will be the sum of all this.

07:26.300 --> 07:28.470
It will always be the sum of all these three.

07:28.490 --> 07:29.980
It will be a constant value.

07:29.990 --> 07:31.310
I mean, it won't change.

07:31.370 --> 07:35.210
Rate of DP is constrained for any move it is concerned.

07:35.210 --> 07:36.800
What I'll do is simply memorize it.

07:37.200 --> 07:37.490
Right.

07:37.790 --> 07:38.870
So how will my music.

07:38.900 --> 07:42.100
Let's just be okay.

07:43.050 --> 07:45.150
Let's take a vector because.

07:46.290 --> 07:46.530
Here.

07:46.530 --> 07:54.510
We know that things are variable and if the strings are of variable length, then I just take a vector.

07:55.450 --> 07:56.000
And.

07:57.580 --> 07:58.900
This is it again and again.

07:59.740 --> 08:01.320
Let me say it again and again.

08:01.330 --> 08:02.800
So Mahmoud Daughtry sees.

08:05.540 --> 08:05.810
Yeah.

08:05.870 --> 08:07.220
Firstly, let me clear it.

08:07.550 --> 08:10.760
I'm just telling you a different way of memorizing.

08:10.880 --> 08:14.450
Of course, you can take in memo 5000 and put that thing.

08:14.780 --> 08:15.920
But in that case.

08:16.850 --> 08:20.400
If this thing is small, then you don't have to.

08:20.400 --> 08:24.830
You know that memo, the whole integer at A to B minus one?

08:25.190 --> 08:25.940
What, all five?

08:27.800 --> 08:29.150
So that's why I'm doing this.

08:29.210 --> 08:34.640
So I just resize it by editor size plus one and I'll mark minus one over here.

08:35.780 --> 08:38.090
So this plus one is not needed.

08:38.180 --> 08:39.460
And both sides will also do.

08:39.470 --> 08:41.630
And I just fill it with minus one.

08:42.770 --> 08:43.880
And here what I do.

08:45.120 --> 08:45.540
Impulse.

08:46.140 --> 08:47.100
Memories are normal.

08:48.070 --> 08:49.760
We already know how to memorize it.

08:49.780 --> 08:52.000
If it is an article two minus one written memo.

08:52.890 --> 08:53.910
We're discussing, right?

08:54.930 --> 08:59.820
Now at the rate what I lose, I'll just simply stored it in my answer.

09:02.460 --> 09:03.450
And Maude.

09:04.850 --> 09:07.730
Now, guys, tell me what will be the complexity of this solution?

09:08.000 --> 09:15.110
After minimizing the complexity, the solution becomes often only because I have only answered what

09:15.110 --> 09:17.150
is then and is, let's say, the size of the string.

09:17.750 --> 09:23.990
I only an end state, and no state would be calculated twice because it is calculated once it will be

09:24.530 --> 09:26.960
stored in the memo vector.

09:27.410 --> 09:32.120
If it is stored in the memo vector, I will simply return the answer whenever I'm coming onto the state

09:32.120 --> 09:32.600
next time.

09:34.080 --> 09:34.710
What example?

09:38.000 --> 09:41.630
This be 1148025114.

09:42.050 --> 09:47.960
If I go gluten then there are three one, two and three possibilities of 114.

09:48.350 --> 09:55.430
That means the next time I reach this VI and I have to again calculate it 41149 simply written back

09:55.790 --> 09:58.850
because 114 it starts from the second index, right.

09:59.480 --> 10:01.430
And I'm reaching the second index again.

10:02.420 --> 10:06.680
Buy stays at the Big VI Take beer, he ain't.

10:06.770 --> 10:10.640
So if I'm reading it again the next time I'll simply return back the answering.

10:12.500 --> 10:16.760
I've written back to you directly here instead of, you know, moving down the hall.

10:16.790 --> 10:17.030
Three.

10:18.290 --> 10:19.490
I hope this is clear.

10:19.580 --> 10:21.170
We all know how a musician works.

10:21.710 --> 10:25.220
And yeah, this is a good working solution of the above.

10:26.000 --> 10:26.480
Problem.

10:28.110 --> 10:29.220
So thank you all.

10:29.520 --> 10:30.690
In the next part.
