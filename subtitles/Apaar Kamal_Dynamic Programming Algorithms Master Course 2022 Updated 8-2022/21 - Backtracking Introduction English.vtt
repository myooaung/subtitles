WEBVTT

00:01.390 --> 00:06.760
Hii, Everyone in this section, we are going to learn about backtracking, which is a very powerful concept

00:06.760 --> 00:08.620
in algorithmic problem solving.

00:09.160 --> 00:14.500
So it's an algorithmic technique in which we recursively try to build solutions.

00:14.530 --> 00:20.140
We try to search through the entire search space to solve a computation problem.

00:20.500 --> 00:21.280
So you might ask.

00:21.280 --> 00:23.290
Okay, give me one example.

00:23.680 --> 00:29.890
So basically we would be discussing various problems, such as popular problems are N queen problem finding

00:29.890 --> 00:31.540
permutations, finding subsets.

00:32.080 --> 00:36.110
So each of these problems can be divided into one of these categories.

00:36.130 --> 00:37.450
One is the decision problem.

00:38.020 --> 00:42.470
One is a optimization problem, and one is a enumeration problem.

00:42.490 --> 00:43.780
So what is a decision problem

00:44.200 --> 00:46.750
In a decision problem, we check for a feasible solution.

00:46.750 --> 00:50.110
For example, let's say you are given a grid.

00:51.110 --> 00:57.130
And in that particular grid, let's say there are certain cells that are blocked.

00:57.140 --> 00:58.910
Maybe the cell is blocked.

00:58.910 --> 00:59.630
This is blocked.

00:59.630 --> 01:00.980
This is blocked and this is blocked.

01:01.340 --> 01:09.320
And you're standing here and you want to tell me whether it is feasible to start from this cell and reach

01:09.530 --> 01:10.610
this particular cell.

01:10.610 --> 01:10.850
Okay.

01:10.850 --> 01:13.070
So this is like checking for a feasible solution.

01:13.070 --> 01:16.730
So you have to tell yes or no whether a solution is possible or not.

01:17.390 --> 01:21.470
Now, the solution will depend upon certain constraints that are given in the problem.

01:21.560 --> 01:21.860
Okay?

01:22.340 --> 01:28.430
So the constraints can be on the movement, how the person can move, whether he can move left or down,

01:28.670 --> 01:30.650
if it can move only left and down.

01:30.680 --> 01:31.430
right and down

01:32.030 --> 01:35.240
Then there is no way we can reach this particular cell.

01:35.330 --> 01:38.120
But if the diagonal movement is also allowed, yes.

01:38.120 --> 01:40.670
In that way we can reach this particular cell.

01:41.060 --> 01:42.380
This is a decision problem.

01:42.380 --> 01:42.640
Okay.

01:43.460 --> 01:49.760
another could be an optimization problem maybe where we want to find out the best solution.

01:49.850 --> 01:54.470
Okay, so maybe we are given maybe a set of nodes.

01:55.680 --> 02:04.500
And let's say, we have something, let's say from every node we can go to every other node.

02:04.500 --> 02:04.740
Okay.

02:06.580 --> 02:10.150
Maybe we want to find out the path which covers.

02:11.300 --> 02:12.350
All the nodes.

02:12.530 --> 02:12.890
Okay.

02:12.920 --> 02:16.550
Maybe find the path which covers all the nodes, but.

02:18.210 --> 02:19.560
in a minimum cost.

02:20.340 --> 02:21.390
okay, in a minimum cost.

02:21.700 --> 02:24.360
It's this is like an optimization problem.

02:24.360 --> 02:34.020
So maybe a path which covers all the nodes but in a minimum cost, let's say A, B, C, D, E and

02:34.030 --> 02:38.820
F from every node to every other node, there is some cost associated.

02:39.330 --> 02:43.680
So this is like finding out the best solution out of multiple solutions that we can do.

02:44.250 --> 02:50.190
This is, again, kind of a backtracking problem and example could be something similar to traveling

02:50.190 --> 02:51.090
salesman problem.

02:51.090 --> 02:58.320
If you if you have heard okay?, another is an enumeration problem where we need to find out all the possible

02:58.320 --> 02:58.890
solutions.

02:59.430 --> 03:01.650
So basically, let's say we are given.

03:05.680 --> 03:12.640
Given let's say a string ABC and we want to find out all the subsets of this particular string or maybe

03:12.640 --> 03:15.910
we want to find out all the permutations of this particular string.

03:15.910 --> 03:16.210
Okay.

03:16.570 --> 03:23.710
So if we talk about permutations, it would be ABC, CBA, BAC, BCA and so on.

03:24.300 --> 03:26.860
We will have ]3! i.e six permutations.

03:26.860 --> 03:32.590
So this is about finding all the permutations because we will discuss these type of problems in this

03:32.590 --> 03:39.430
particular section and we will also discuss some popular classical problems which are again which fall

03:39.430 --> 03:40.750
into one of these categories.

03:41.020 --> 03:48.310
So classical problems like a rat in a maze problem, where a rat is stuck in a maze and there is a problem

03:48.310 --> 03:50.410
which is known as N Queen problem.

03:50.410 --> 03:53.560
We will discuss that and discuss phone keyboard problem.

03:53.560 --> 03:55.600
We will discuss the sudoku solver.

03:55.690 --> 03:56.020
Okay.

03:56.530 --> 04:01.870
So these are some common problems that you will find there is knights toms problem.

04:03.030 --> 04:03.330
Okay.

04:04.290 --> 04:08.190
So these are some common problems that you will often see in backtracking.

04:08.220 --> 04:13.950
There is not a lot of variety if you understand and learn how to solve these basic problems.

04:14.490 --> 04:20.010
You can easily apply those concepts to newer unseen problems in backtracking if you encounter.

04:20.010 --> 04:20.250
Okay.

04:20.610 --> 04:25.860
So that's the end goal of this particular section and I hope you would really learn a lot.