WEBVTT

00:00.630 --> 00:01.590
Welcome everyone.

00:02.160 --> 00:07.410
In this tutorial we will see when to use tabulation and how to use memorization.

00:07.410 --> 00:09.360
And how does all of this work?

00:09.780 --> 00:18.180
By calling it a little bit on the let me quickly board this Fibonacci numbers part using memorization

00:18.180 --> 00:18.410
first.

00:18.420 --> 00:18.660
Right.

00:18.660 --> 00:23.820
So let's write a normal recursive relation that we have defined in the second part over here, which

00:23.820 --> 00:27.480
is f often is inclusive of N minus one plus F over and minus two.

00:27.540 --> 00:27.840
Right?

00:28.290 --> 00:33.420
So here what I'll do is simply say see out its right, a function which will give me Fibonacci numbers

00:33.780 --> 00:35.620
and the spastic st.

00:35.790 --> 00:38.400
That means it will give me the sixth Fibonacci number.

00:39.450 --> 00:43.770
Well, the void, I hope the jaundice.

00:44.190 --> 00:48.000
But it is bib not white.

00:48.000 --> 00:48.960
It will be in digital.

00:48.980 --> 00:49.620
It will me.

00:49.640 --> 00:54.500
And so yeah I figured isn't in the end for when I can.

00:54.510 --> 00:57.660
And so what if an is less than equal to do didn't.

00:58.660 --> 01:03.490
But these are the best cases, if any one or two admitted in one.

01:04.740 --> 01:07.860
And the call for when I give zero will never be called.

01:07.890 --> 01:08.190
Why?

01:08.760 --> 01:09.870
Because if I can.

01:09.870 --> 01:10.590
What if I.

01:10.590 --> 01:15.400
Come on, we're going to give 3 billion equal one into and one in two will never call what's behind

01:15.400 --> 01:18.060
them because they will come into basis.

01:18.750 --> 01:19.650
Otherwise what I'll do is.

01:19.650 --> 01:21.360
And simply return for when I kill off.

01:22.990 --> 01:26.990
And minus one plus one and Q and minus two.

01:27.460 --> 01:27.940
Always.

01:28.000 --> 01:28.690
Let's bring this.

01:29.790 --> 01:34.480
What does the fix for an acronym but it is it in this case so it is one one.

01:34.500 --> 01:35.670
The number one is two.

01:35.790 --> 01:36.850
One, two, three.

01:37.380 --> 01:39.300
It is five and five, five plus three.

01:39.300 --> 01:42.090
That is the six four when I give number eight.

01:42.360 --> 01:44.530
Now I just want to count that.

01:44.640 --> 01:47.100
How many times as this of.

01:49.370 --> 01:52.280
Being called this function called fib has been called.

01:52.280 --> 01:56.870
So I've just added a counter and I just want to count how many times.

01:58.090 --> 01:58.780
Is this being?

02:04.070 --> 02:04.260
Right.

02:04.340 --> 02:07.190
So as we can see, to just find 60 when taking numbers.

02:08.420 --> 02:11.750
The recursion is being called 15 times.

02:11.750 --> 02:13.760
This function is being formed 15 times.

02:13.790 --> 02:14.120
Right.

02:14.480 --> 02:15.770
Because let's come back here.

02:16.550 --> 02:21.680
When I five above six, it's called five and four and five again, calls for entry in four.

02:21.680 --> 02:23.750
Again cost 3 to 8.

02:24.470 --> 02:28.220
One, two, three, four, five, six, seven, eight, nine, ten, 11, 12, 13, 14, 15.

02:28.250 --> 02:32.590
We can see we are 15 states over here in this because of relation eight.

02:33.170 --> 02:36.100
That's a that's what we want to optimize.

02:36.110 --> 02:40.880
We want to optimize this because of relation by applying memorization in this case.

02:41.060 --> 02:45.620
Eight Why does memorization then if a fourth end is being.

02:46.810 --> 02:50.980
Like if it is calculated once, then please don't calculate it again.

02:51.490 --> 02:52.240
How do we do that?

02:52.960 --> 02:55.900
So firstly, what we simply say is, let's take.

02:59.680 --> 02:59.980
And.

03:00.250 --> 03:01.770
Yeah, let me take it up again.

03:01.780 --> 03:02.290
It doesn't.

03:05.760 --> 03:08.430
We can also go back to the because that will be dynamic.

03:08.430 --> 03:09.630
So let's pick a victor.

03:13.180 --> 03:14.200
And let's call it memo.

03:15.050 --> 03:17.350
Well, initially what I'll do is I'll take it in.

03:17.740 --> 03:25.180
And let's say any six, if any six, what I do is I'll simply the memo Dorothy says and I'll say, and

03:25.180 --> 03:34.750
+15 plus one, because I want the numbers from 1 to 6 and I say the vector F and plus one, say the

03:34.750 --> 03:40.870
infinite written minus one initially and simply pass and to the Fibonacci number they were ever defined

03:40.870 --> 03:41.290
globally.

03:41.290 --> 03:41.570
Yes.

03:42.070 --> 03:42.550
Because.

03:44.770 --> 03:48.190
I want to use this memo in this function eight.

03:49.600 --> 03:50.140
So here you are.

03:50.230 --> 03:54.250
You don't understand how to use my music, and I'll give you some different ways of using it.

03:54.490 --> 03:55.870
And those are really cool ways.

03:57.150 --> 03:57.690
So here it is.

03:57.690 --> 04:04.770
Memo during season plus one and minus one and I have this the old Fibonacci often will this be when

04:04.770 --> 04:11.010
I given is being called before that I filled the memo pad the memo vector with minus and later it's

04:11.010 --> 04:14.960
an error basically of land and plus one filled with minus one, initially eight.

04:15.210 --> 04:17.280
So what I do is guys, I simply say.

04:19.430 --> 04:22.280
Memo of end is not equal to minus one.

04:23.780 --> 04:26.000
What does this mean if it is not equal to minus one?

04:26.000 --> 04:26.770
I simply written.

04:27.290 --> 04:28.940
And more often that means.

04:30.440 --> 04:32.270
This is the memorization.

04:34.620 --> 04:35.160
But, guys.

04:36.400 --> 04:36.780
Yeah.

04:36.790 --> 04:40.630
So before this, let me have the bass case with the count eight.

04:41.050 --> 04:48.500
Here is the memorization part and here is the because if relation, this is what it is overlapping.

04:48.500 --> 04:50.830
So problems and this is what it means.

04:51.190 --> 04:56.680
Optimal substructure right now is a mammoth and will always be equal to minus one because we are never

04:56.680 --> 04:57.760
filling them often.

04:58.200 --> 04:58.450
Okay.

04:58.570 --> 05:00.970
So what we'll do here is whenever we are returning.

05:01.960 --> 05:03.790
These two towns will never be returning.

05:03.790 --> 05:05.500
The fee would take off.

05:05.500 --> 05:07.690
And so here we will simply save it.

05:08.850 --> 05:09.940
What we'll do is we'll see.

05:09.950 --> 05:13.510
A memo often is equal to three when your friend minus one, percent minus.

05:14.170 --> 05:16.030
Now it's become so easy, right?

05:16.510 --> 05:19.840
If mammoth and isn't, it's not called.

05:20.650 --> 05:24.510
That means if it is not filled, then it will simply call this because of relation.

05:24.520 --> 05:28.660
It will fill that mammal bird or that and part the end time of be.

05:29.440 --> 05:38.030
And it will tell you after saving it when the next day I come to the same and it will not call the of

05:38.260 --> 05:40.600
the nation, it will never reach the line number 19.

05:40.720 --> 05:46.180
It will simply return back from line number 17 by because now the memo and is already will do minus

05:46.180 --> 05:51.850
one because the previous call to the same and I fill it while returning it.

05:52.390 --> 05:52.620
Eight.

05:52.630 --> 05:53.500
So let me bring this.

05:57.510 --> 06:00.260
The goals have been reduced to nine eight.

06:01.120 --> 06:03.060
So here we can see there's a lot of.

06:04.680 --> 06:06.180
Optimization happening, right?

06:06.490 --> 06:07.020
Well, let's see.

06:07.410 --> 06:11.820
Let me simply ignore the memorization part and let me be for any good student.

06:12.730 --> 06:14.080
It didn't feel like a number.

06:14.560 --> 06:18.900
But here we can see we have this 59 and.

06:20.300 --> 06:26.480
The calls being made of 100 names when a Plymouth musician enlisted will be calculated twice.

06:26.900 --> 06:27.530
How many?

06:29.150 --> 06:31.570
Yeah, so far, ten how many times.

06:31.580 --> 06:36.590
Now it has been called 17 names on the Adelaide, what's been called 108.

06:36.590 --> 06:37.190
So whenever.

06:37.780 --> 06:43.130
So this count is actually for a state when it whenever it is being called always good.

06:45.200 --> 06:45.400
Here.

06:45.400 --> 06:46.550
You can see the difference, guys.

06:46.570 --> 06:48.550
So let's talk about NGOs for 20.

06:49.520 --> 06:55.610
If we can have we can see that this is a value of any ghostwritten B and only 37 times.

06:56.150 --> 06:57.790
It's always pleasant to win.

06:58.760 --> 07:00.950
Only 37 times this function has been called.

07:01.130 --> 07:03.350
But if I remove the memorization part.

07:04.580 --> 07:06.860
We can see that how many times it is being called?

07:07.280 --> 07:09.550
13,529.

07:10.660 --> 07:16.870
Either difference it 13,529 and 37 just 37 calls.

07:16.870 --> 07:18.490
We are giving the same answer.

07:18.490 --> 07:18.880
Where?

07:19.760 --> 07:21.650
Earlier without permission.

07:21.650 --> 07:25.760
The same answer was being formed in one on 13,539 calls.

07:27.800 --> 07:29.740
Oh, isn't that great, guys?

07:30.260 --> 07:32.540
We have optimized the Fibonacci number by trade.

07:33.140 --> 07:38.570
This really was only for the beginners who do not understand what is tabulation and memorization.

07:38.990 --> 07:42.710
For them, this is a very basic example and community.

07:44.220 --> 07:44.520
Read.

07:45.410 --> 07:49.280
Now coming on to the next part, which is.

07:52.160 --> 07:52.670
It is.

07:56.280 --> 07:59.280
Tabulation late so the memorization is done alleged.

07:59.280 --> 08:01.890
Let's do tabulation in tabulation.

08:01.890 --> 08:06.180
As I said, it will already have a picture and will be using file loops instead of recursive deletions.

08:06.630 --> 08:08.250
Utility anecdotes for 20.

08:08.550 --> 08:10.500
And I want to find out this.

08:11.100 --> 08:12.880
What is it going to give you?

08:12.900 --> 08:18.480
So what I'll do is I'll simply say and plus one, I simply fill it in the tabulation form.

08:18.480 --> 08:20.430
I believe in the best guesses first.

08:20.850 --> 08:24.270
So Fibonacci of uneasy close to Fibonacci of two is equal to one.

08:25.200 --> 08:29.130
Well, the base cases are done now one into his food now and start from three.

08:30.290 --> 08:32.450
I start from three, I go, Dylan.

08:32.600 --> 08:36.410
And what I do is I simply say, if we're going to cure physical stuff, we're going to cure five minus

08:36.410 --> 08:36.650
one.

08:36.650 --> 08:38.720
Plus we're going to give a minus to.

08:40.380 --> 08:41.750
Always so.

08:42.950 --> 08:44.120
Why will this work?

08:44.840 --> 08:46.220
It will work because.

08:47.360 --> 08:52.330
I started from like two, three in the first iteration when I got really claustrophobic.

08:52.340 --> 08:54.830
You have two plus one and two plus one has already been filled.

08:55.280 --> 08:57.800
Now when I guess when I give three is being four.

08:57.810 --> 08:59.480
Right now you're doing eight plus plus.

09:00.510 --> 09:01.830
The eye is on four.

09:01.920 --> 09:06.780
So when it is four, when you go for it is equal to Fibonacci of three plus we are going to give two

09:07.200 --> 09:13.950
which are already being filled because when I came before, when I was equal to four, then it is already

09:13.950 --> 09:14.490
calculated.

09:14.490 --> 09:16.860
I go to three and I go through two and I go to one.

09:16.860 --> 09:21.960
So if I am on I was ten, that means from 1 to 9 from when I came has already been filled.

09:22.710 --> 09:23.670
Eight ahead.

09:23.680 --> 09:29.370
We will only here will exactly take an iterations, eight two iterations over here and then minus two

09:29.370 --> 09:31.350
iterations over here, eight here.

09:31.350 --> 09:32.970
We won't have to in complexity.

09:33.180 --> 09:39.750
But yes, the tabulation approach is a little trickier to go trade because here we use only for loops.

09:40.440 --> 09:41.790
Here we have to like.

09:42.920 --> 09:45.450
Use these four loops in a specific manner.

09:45.530 --> 09:47.480
Sometimes we have to use Blizzard for loop.

09:47.490 --> 09:56.120
Sometimes we have to use forward for loops and here we have to worry about out of index thing things

09:56.450 --> 09:58.310
we have to like apply some.

10:00.450 --> 10:02.160
Conditions in Kabul.

10:02.700 --> 10:04.190
So it's kind of a little trickier.

10:04.210 --> 10:07.140
But yeah, this is like.

10:08.290 --> 10:11.440
It's secure, but it's not effective.

10:11.740 --> 10:17.320
If you solve all those 26 problems and will use both top down in bottom up approaches, then it will

10:17.320 --> 10:17.900
become easier.

10:17.920 --> 10:23.020
But if you are a big net or even an intermediate, I would suggest you to use the top down approach

10:23.020 --> 10:28.080
first, because top down approach will give you the logic building part.

10:28.090 --> 10:33.880
It will like make you understand how to write recursive relations, how to write dynamic programming,

10:33.880 --> 10:34.810
recursive relations.

10:35.050 --> 10:36.580
And then we don't have to do anything.

10:36.580 --> 10:39.340
Just write a normal recorded relation and apply memorization.

10:40.220 --> 10:46.210
Okay, so let's say if it was in an m, let's say this was a 2D deep part.

10:46.210 --> 10:51.580
So here I would have taken a memo and then made memo and and so on.

10:52.570 --> 10:52.760
Okay.

10:52.870 --> 10:55.750
So if I have to states, then I have to take.

10:56.820 --> 10:58.180
Now do like memories it.

10:59.060 --> 10:59.840
In Italy.

11:00.260 --> 11:02.460
People in Italy remember it.

11:03.440 --> 11:04.190
So we'll see.

11:04.940 --> 11:08.510
We'll keep on doing good when it comes to us in those trying to fix problems.

11:09.430 --> 11:15.080
But I hope you understood how to do the tabulation part and how to do the memorization part.

11:16.840 --> 11:17.200
So.

11:17.500 --> 11:18.220
Thank you, everyone.

11:18.250 --> 11:19.240
See you in the next part.
