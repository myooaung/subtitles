WEBVTT

00:00.820 --> 00:01.510
Hello, everyone.

00:01.690 --> 00:02.500
Welcome back.

00:02.710 --> 00:09.580
And in this lecture will understand how is recursion the most important?

00:09.820 --> 00:12.610
It plays a very vital role in dynamic programming.

00:13.120 --> 00:17.590
So basically, dynamic programming is equal to.

00:18.500 --> 00:19.130
Because in.

00:21.010 --> 00:22.410
Less optimisation.

00:23.060 --> 00:29.590
Okay, look, if we have a good recursive approach for any problem, then we can easily convert into

00:29.590 --> 00:31.630
a solution into a dining program solution.

00:31.900 --> 00:38.650
Because every then rebranding solution just I'm just mark my words, every dynamic programming solution

00:38.650 --> 00:40.660
has a recursive approach.

00:41.110 --> 00:45.880
So everything but programming solution will have a recursive solution inside it, which will be further

00:45.880 --> 00:46.540
optimized.

00:47.140 --> 00:49.360
Nothing better goes in place optimization.

00:50.110 --> 00:55.210
If you face any other type of programming problems, of course the course is going to be and you will

00:55.210 --> 00:57.490
face a lot of programming problems.

00:57.490 --> 00:57.710
Right.

00:58.000 --> 01:03.640
What I suggest is in the for the beginners, but any of the writing programming problem just write a

01:03.640 --> 01:08.530
simple recursion, whatever recursion you can write a very easy, simple equation about it.

01:08.920 --> 01:12.490
And then after writing a good recursive solution.

01:13.550 --> 01:18.320
Because we know, because the solutions, the excitement, because the solutions are very exponential.

01:18.360 --> 01:22.520
They take a lot of time, as we have seen in the human activities and other as well.

01:22.730 --> 01:28.370
And also I have a good question for you, audio, which I'll be calling integration and then we'll see

01:28.370 --> 01:29.420
how it can be optimized.

01:30.470 --> 01:33.890
Everyday presentation is nothing but a gathering place optimization.

01:34.210 --> 01:38.030
So what any of the problem you face in dynamic programming?

01:38.240 --> 01:40.070
They try to create integrated solution.

01:40.610 --> 01:44.270
The more stronger you are integration, the more strongly you'll get in dynamic programming.

01:44.600 --> 01:47.590
They look ready to go this solution.

01:47.600 --> 01:53.000
If you're able to find out the correct answer of it by using integration, then nothing but just optimize

01:53.000 --> 01:54.260
it and how to optimize it.

01:54.260 --> 01:55.280
I already shared it.

01:55.280 --> 01:56.750
Is memorization place.

01:57.590 --> 01:58.700
You can use memorization.

01:58.700 --> 02:00.190
You can use tabulation whatever you want.

02:00.380 --> 02:03.830
But right now, let's focus on the recursive part and not the optimal.

02:04.950 --> 02:08.900
Well, I have a problem with you that I want to share it.

02:08.900 --> 02:10.850
Is this the number of vs?

02:11.240 --> 02:17.420
It's a very standard problem and there's a special thing you realize in this and you'll understand why

02:17.420 --> 02:20.360
do we why do we need about some sequences?

02:21.320 --> 02:25.860
Why are some sequences very famous like curly numbers, those unique numbers.

02:26.780 --> 02:31.760
So firstly, number of ways to fill in every with zeros and ones.

02:32.390 --> 02:34.940
That's that there are no consecutive ones.

02:36.200 --> 02:36.410
Yep.

02:36.840 --> 02:37.100
So.

02:39.030 --> 02:44.610
So as I said, if you are struggling with any other TV problems, if you're a beginner, a very.

02:45.770 --> 02:46.010
Yeah.

02:46.160 --> 02:48.800
So I do begin with this problem.

02:48.800 --> 02:49.820
How to solve this problem.

02:50.180 --> 02:50.690
This idea.

02:50.690 --> 02:51.530
Recursive solution.

02:51.560 --> 02:52.400
Don't think of anything.

02:52.520 --> 02:54.110
Just like the recursive solution.

02:54.500 --> 02:55.100
Think about.

02:56.610 --> 02:58.680
As only I wanted to explain this right.

02:58.710 --> 03:03.510
We need to firstly think of a state and what is a state that I want to take?

03:03.510 --> 03:10.450
Like what is a state history to present it to you write some function call in into fun and funny XCOM

03:10.450 --> 03:11.970
of icon my versatility.

03:12.100 --> 03:14.650
It's this fun.

03:15.330 --> 03:18.400
Exclaim of I There is a state aid.

03:18.670 --> 03:21.090
It will depend on other states which is XCOM.

03:23.980 --> 03:25.690
Which is nothing but fun.

03:26.050 --> 03:28.390
XCOM x minus one y commander.

03:28.390 --> 03:31.030
And to do something like this it will depend on other states.

03:31.440 --> 03:33.650
But in Italy we need to decide a state.

03:33.670 --> 03:35.680
Like what state can I use?

03:35.980 --> 03:36.550
Can I take?

03:36.550 --> 03:39.160
And after deciding that state, we have to.

03:40.290 --> 03:41.670
Code that stated recursively.

03:41.940 --> 03:42.450
Nothing it.

03:42.840 --> 03:47.340
And of course, we'll have a base case which will then be the answer to let's find a state.

03:47.340 --> 03:48.660
Let's find a state for this answer.

03:50.080 --> 03:50.680
Before that.

03:50.680 --> 03:52.810
Let's understand, this is an example.

03:53.800 --> 03:56.690
So let's say I have an area of land three full.

03:59.940 --> 04:03.640
And I have to fill it with zeros and ones because then there are no category ones.

04:03.660 --> 04:04.770
So how many of these are there?

04:05.190 --> 04:09.950
So let's see if I can win the first place in the first location.

04:09.960 --> 04:10.830
What can I fill?

04:11.280 --> 04:13.290
This will be more or less like a tree.

04:13.500 --> 04:14.880
So let me make a tree instant.

04:15.660 --> 04:17.340
So that in the first index.

04:18.450 --> 04:23.250
What I have is that I can play zero, but I can this one eight.

04:23.850 --> 04:25.560
If I place zero in the first index.

04:25.980 --> 04:27.000
In this second index.

04:27.010 --> 04:32.280
So this is first to every depth of this tree is a index.

04:34.240 --> 04:39.220
So in this second index, so this is the first index rate and my arrows lenses right now.

04:39.220 --> 04:41.710
So let's say end is equal to the length of the area.

04:42.590 --> 04:44.920
If in the first place I have kept zero.

04:44.920 --> 04:47.020
So we'll figure out about one later.

04:47.290 --> 04:48.760
Let's talk about 0/1.

04:49.090 --> 04:50.620
So what numbers can I please?

04:50.620 --> 04:53.260
In the second place I can place zero as well.

04:53.260 --> 04:55.570
Is one correct?

04:55.690 --> 04:59.500
Because the only condition is that there are no consecutive ones.

05:01.720 --> 05:06.460
But if I played zero in the second place, in the third place, I can be zero as well is one.

05:06.670 --> 05:10.750
But if I placed one in the second place, I can only play zero in the.

05:11.700 --> 05:12.210
Third base.

05:13.350 --> 05:16.110
So what does this particular.

05:17.210 --> 05:17.840
The question.

05:18.780 --> 05:20.130
This is the going this is a.

05:21.060 --> 05:22.080
What does this represent?

05:22.110 --> 05:25.920
This represents 000 is a valid way because there are no consecutive ones.

05:26.610 --> 05:28.470
This represents the second one, which is.

05:29.850 --> 05:33.280
The spots it represents 001 cool.

05:33.280 --> 05:37.870
Again, 100% 0108.

05:38.500 --> 05:39.940
Now let's talk about if.

05:41.040 --> 05:43.900
I'm busy even placing one on the index.

05:43.910 --> 05:44.180
Zero.

05:44.850 --> 05:49.080
If I place one on the index zero, I can only place zero on index two.

05:49.710 --> 05:50.940
So this is an index fund.

05:51.000 --> 05:52.020
This is only index two.

05:52.320 --> 05:53.970
And what can I place an index three?

05:54.630 --> 05:56.520
I can place both zeros and ones.

05:58.310 --> 05:58.590
Eight.

05:59.360 --> 06:00.500
So yeah.

06:00.530 --> 06:01.490
Again, let's.

06:02.610 --> 06:04.200
The debt is 100.

06:05.420 --> 06:08.660
And this is 10.3.

06:08.840 --> 06:10.370
So how many number of these are there?

06:12.300 --> 06:12.870
Place.

06:14.940 --> 06:19.300
To fill in at every DeRozan so they're not going to go grievance nothing but five number.

06:19.920 --> 06:21.300
I hope you understood this part.

06:21.360 --> 06:23.790
LAKE How is the discussion being formed?

06:23.790 --> 06:29.130
Right, that if okay, well, basically let's try to let it go to the function.

06:29.670 --> 06:32.190
I'm going slow here because I want you to understand this part.

06:32.640 --> 06:38.730
This is the most important part of forming a state because of state which will depend on the state.

06:38.790 --> 06:41.070
There is a different thing that is called optimal substructure.

06:41.070 --> 06:42.360
We already heard about it.

06:42.840 --> 06:46.590
Right now we will just see what state can emulate.

06:47.020 --> 06:47.640
So let's see.

06:48.590 --> 06:48.800
Little.

06:48.830 --> 06:49.850
I'm starting from day zero.

06:49.850 --> 06:53.300
I'm trying to place zeros and ones and zeros in once again and again.

06:53.630 --> 06:58.610
But I will say, let's say F off, let's index.

06:59.680 --> 07:01.090
Will evolve.

07:01.090 --> 07:04.270
Index will represent number of ways.

07:10.050 --> 07:13.830
Number of ways of forming answered.

07:14.630 --> 07:14.900
Eight.

07:20.050 --> 07:20.380
Okay.

07:20.440 --> 07:22.840
Let's say number of ways of filling the.

07:24.780 --> 07:29.130
Filling the area with the 001 says there there are no consecutive ones.

07:29.460 --> 07:29.940
If.

07:32.010 --> 07:32.580
If I.

07:36.210 --> 07:36.660
Zero.

07:37.820 --> 07:38.090
Great.

07:38.180 --> 07:39.860
And once I didn't say.

07:42.670 --> 07:42.820
Well.

07:43.060 --> 07:45.550
So, look, let me go again over this.

07:45.560 --> 07:47.200
So this is a footprint.

07:47.200 --> 07:54.220
This means I'm actually taking every index equal to whether I place zero of one on this index and tell

07:54.220 --> 07:58.840
me the number of days from here till the end of the 88, basically.

07:59.980 --> 08:00.250
Okay.

08:00.310 --> 08:02.950
So initially, what is the final answer?

08:02.960 --> 08:04.720
The final answer is nothing really for zero.

08:05.600 --> 08:07.210
Or instead let's to everyone.

08:08.330 --> 08:10.220
We are considering one base indexing over here.

08:10.550 --> 08:17.150
So if I if I have an edit listed starting from one I for one is equals to the complete answer because

08:17.150 --> 08:19.490
everyone will tell me what is the answer.

08:19.640 --> 08:20.600
If I place.

08:21.650 --> 08:24.770
At zero of one from 1 to 28.

08:24.770 --> 08:30.080
Similarly, if obvi means the answer, you feel they are in the province to fill the area.

08:30.140 --> 08:35.810
If I place zero one on index I and the answer from I do index and.

08:36.720 --> 08:36.990
Well.

08:38.330 --> 08:43.460
Okay, so let's try to write it because solution and then I think it will be more clear.

08:43.860 --> 08:45.320
Okay, so let's go.

08:45.350 --> 08:45.700
Okay.

08:45.710 --> 08:47.240
So this is not simple.

08:49.800 --> 08:50.250
Let's.

08:52.120 --> 08:57.550
And now what we'll do is we'll simply write a function, let's call it fun, and I'll just see how this

08:57.550 --> 09:05.290
fun and this fun will be our function, which will give us the number of ways to fill this particular

09:05.440 --> 09:06.380
edit rate.

09:06.820 --> 09:08.860
Let me just remove this and.

09:11.410 --> 09:14.080
So as I said, I'll be taking index initially.

09:14.080 --> 09:16.990
So let's pass index as one initially.

09:16.990 --> 09:17.260
Right.

09:17.260 --> 09:24.400
And also that sparse end so that the function knows where to stop, let's say, and is equals to five.

09:24.400 --> 09:27.820
Right now we we have an area of land value and we want to find out.

09:29.910 --> 09:31.140
The number of ways of doing so.

09:31.380 --> 09:32.760
Eight And finally.

09:34.310 --> 09:34.550
Okay.

09:34.610 --> 09:35.600
We will see that later.

09:35.720 --> 09:38.510
There are other things that will come in to this function, but we'll see that later.

09:39.170 --> 09:45.160
I have an index and I have an is it and is the lentil which I have to go.

09:45.170 --> 09:47.690
So I'm starting from index equals to what?

09:48.150 --> 09:52.910
Well, so at a particular index, what I can do is I can either place.

09:54.760 --> 09:57.370
At a particular Nicaraguan to his mother, I can be zero.

09:58.560 --> 09:59.910
At their place.

09:59.940 --> 10:00.600
Zero here.

10:01.790 --> 10:03.830
And the second is our place.

10:04.720 --> 10:04.990
One.

10:05.360 --> 10:05.560
Yeah.

10:06.130 --> 10:10.020
This is what I what I can do at a particular rate.

10:10.510 --> 10:13.930
As you can see, guys, I'm not taking it in that I'm not actually formulating in at it.

10:14.170 --> 10:18.280
I'm just visualizing it that if I place one over there, how?

10:18.280 --> 10:20.200
My answer depends on the further index.

10:20.320 --> 10:27.130
If I play zero here, our minds are different on the other index, but well, let's dig on it.

10:27.880 --> 10:29.620
And it it sounds anything goes to zero.

10:29.620 --> 10:30.770
So what is this one?

10:31.050 --> 10:32.380
Dallas understands me.

10:32.380 --> 10:33.790
This answer value, which is.

10:36.910 --> 10:37.540
Answer.

10:40.050 --> 10:41.640
For Eddie.

10:42.770 --> 10:47.510
Index two and number of ways of making this from index to.

10:47.750 --> 10:49.600
And that we get it well.

10:51.460 --> 10:59.080
As a place zero here if I will please zero 28 then I can easily say that answer is goes to place whatever

10:59.080 --> 11:00.640
you want to place on the index or index.

11:01.390 --> 11:01.590
Eight.

11:02.120 --> 11:07.740
Let's say it is equals two, index plus one and will be as it is one.

11:08.020 --> 11:12.240
But I cannot place one here without knowing what is placed on the previous index.

11:12.250 --> 11:16.060
I want to know where it is based on the previous and then only I will be able to place one.

11:16.060 --> 11:16.330
Right.

11:16.570 --> 11:21.340
Because the problem is that you can't place two consecutive ones.

11:21.790 --> 11:26.680
If I if I can't place two consecutive ones and I need to know what is kept on the previous location

11:27.100 --> 11:30.550
for that, what I'll do is I'll just take a boolean with me.

11:30.950 --> 11:35.080
So I'm just writing a normal legacy solution, which is let's think of Boolean, which is called one.

11:35.800 --> 11:39.100
This will tell me whether one is placed on the previous index or not.

11:39.280 --> 11:42.250
Indeed, negative eight, because as you can see.

11:43.680 --> 11:47.340
If one is placed on the previous recursive call, then I can only place zero with it.

11:47.340 --> 11:52.560
I cannot respond again, but if zero 300 goes to God I can be zero as well is one.

11:53.430 --> 11:53.690
So.

11:54.700 --> 11:57.460
Let's come back over here and I have a relevant.

11:57.490 --> 11:57.820
Okay.

11:57.850 --> 11:58.660
So tell me.

11:58.720 --> 11:59.530
Just think about it.

11:59.540 --> 12:00.910
What will be the value?

12:02.220 --> 12:06.300
The idea that I should pass in this function when I when I'm placing zero.

12:07.550 --> 12:16.100
It should be what's right for us, because this one boolean represents whether liquidated, one represents.

12:17.460 --> 12:18.020
Whether.

12:20.010 --> 12:21.510
Divis index.

12:29.150 --> 12:34.130
IZRAEL Well, if I'm if I'm placing zero added this is my case for zero eight.

12:34.430 --> 12:37.430
That means I despise false to it that I placed zero.

12:37.460 --> 12:38.420
But it's not one.

12:38.960 --> 12:39.810
One will be false.

12:40.490 --> 12:43.090
And when when I when can I place one over there?

12:43.100 --> 12:46.070
I can only place one over here when one is equal to false.

12:46.610 --> 12:46.930
Two.

12:48.020 --> 12:49.220
Okay, let me do nim this.

12:51.160 --> 12:52.160
PBS.

12:52.720 --> 12:54.510
It's called previous Red Bull.

12:55.120 --> 12:58.750
If previous one is false, that means if I'm not pleased when?

12:58.750 --> 13:00.070
Before then I can press one here.

13:00.550 --> 13:01.840
To answer will be equal to.

13:04.600 --> 13:08.290
And this is index plus one comma and comma.

13:08.470 --> 13:08.750
True.

13:09.070 --> 13:09.820
Let's call it true.

13:09.820 --> 13:10.930
Why am I calling it true?

13:11.560 --> 13:13.420
Because now I'm placing one over here.

13:13.450 --> 13:18.760
This is a case where I placed one and went to a place when there's only one condition and there should

13:18.760 --> 13:20.920
not be a previous one in the previous record.

13:20.960 --> 13:21.910
A condition.

13:23.050 --> 13:24.340
So this is simple.

13:25.590 --> 13:26.370
Simple aggression.

13:26.580 --> 13:27.590
It's just violence.

13:27.600 --> 13:29.070
If I remove comments and spaces.

13:29.610 --> 13:31.020
Well, this is for zero.

13:31.020 --> 13:33.810
I'm blessing zero because zero can be replace without any restrictions.

13:33.810 --> 13:38.370
But one will be placed with the restriction, which is there should be no previous ones.

13:38.610 --> 13:42.090
And initially what I'll do is I'll pass files over there, which is.

13:43.310 --> 13:47.900
You can give any other zero or one on the first index because starting in the first ten days, we are

13:47.900 --> 13:52.970
just passing all the initial pool and yeah, let's build this.

13:53.810 --> 13:54.140
Okay.

13:54.710 --> 13:56.180
So why won't this work by?

13:56.180 --> 13:57.260
Am I getting some errors?

13:57.290 --> 13:58.180
Because we are.

13:58.550 --> 13:58.750
Yeah.

13:58.790 --> 13:59.720
Segmentation for it.

14:00.020 --> 14:02.150
So when do we get segmentation for it?

14:02.480 --> 14:08.630
When there's a stack overflow or does a stack overflow when we go over the recursion and build separate?

14:09.170 --> 14:12.380
If there is no base case, then it will keep on going forever.

14:12.380 --> 14:14.450
The index will keep on increasing by one.

14:15.150 --> 14:16.610
It will never know when to stop.

14:16.620 --> 14:18.230
And they look.

14:19.210 --> 14:23.230
Let's say the biscuit index is equal to N plus one because.

14:24.250 --> 14:31.300
Bill and I are pleased right now that 0.1.07 when when the index starts from one goes through to three

14:31.310 --> 14:32.800
four and then it goes to five.

14:33.280 --> 14:35.800
Again, it tries to play zeros and ones and five is.

14:35.800 --> 14:39.780
But when it reaches end plus one, five plus one, which just six rate.

14:39.790 --> 14:43.510
So in this case and it will reach six, then I wanted to return.

14:44.350 --> 14:47.260
Back pain and maturity didn't elaborate on this point.

14:47.920 --> 14:49.870
I really didn't return this one because.

14:51.100 --> 14:54.440
I'm keeping zeros and ones from the first index rate.

14:54.460 --> 14:56.290
All those index have zeros and ones.

14:56.410 --> 15:01.480
If all those index of zeros and ones date, this is a proper value arrangement that I want.

15:01.990 --> 15:03.850
If it is a valid arrangement, then.

15:05.110 --> 15:08.350
It really find out that that means it is a valid arrangement.

15:08.440 --> 15:09.790
For example, it's come back here.

15:10.600 --> 15:15.910
In this case, what happens is I play zero and again, I play zero and then I play zero.

15:16.120 --> 15:18.700
Afterwards, what happens is this called the next index.

15:18.700 --> 15:20.800
And of course, we can't go above it.

15:20.980 --> 15:22.990
So what I see right now, I'm one and plus one.

15:22.990 --> 15:24.010
That means this is a.

15:25.170 --> 15:26.700
Valid arrangement.

15:26.760 --> 15:30.990
So if that is a valid arrangement, just return me one then I've got one valid arrangement from it.

15:31.590 --> 15:31.850
Eight.

15:32.640 --> 15:36.840
So I just simply don't run with this example because I'm going slow.

15:36.840 --> 15:39.360
I'm repeating a lot of things here because I want you to.

15:40.950 --> 15:42.330
Focus on direction back.

15:44.440 --> 15:47.590
So let me read it again and let's see if it feels so.

15:47.740 --> 15:49.840
As we can see, it did not finish reading.

15:50.140 --> 15:51.900
It gave me 38.

15:52.030 --> 15:54.700
So this is four for as I said, let's try it for three.

15:56.380 --> 15:56.580
Cool.

15:56.650 --> 15:59.740
So four three than it is right now.

16:00.220 --> 16:01.240
I just want you to.

16:02.410 --> 16:06.070
Be a burden over you, and then you will easily understand it yourself.

16:06.460 --> 16:07.780
The pattern you can easily see.

16:11.840 --> 16:11.990
But.

16:12.860 --> 16:22.490
What I'll do is I'll run it from net seven and let's say it goes till ten late and I just pass I guess

16:22.490 --> 16:26.210
develop and over there what is in and is the length of the edited.

16:26.210 --> 16:28.900
Right now I'm thinking about one.

16:30.280 --> 16:32.950
Life and is the land of the area that I'm thinking about.

16:33.460 --> 16:34.740
So I'm just passing it as I.

16:34.750 --> 16:39.880
So it will tell the answer for one reason, then it will tell the answer for to Ryland and so on.

16:40.120 --> 16:45.490
And so I'm basing this and it's I, which is a variable let's build this.

16:46.990 --> 16:48.820
But so is.

16:49.060 --> 16:55.030
And you hear see that there is a pattern involved in this situation.

16:55.930 --> 17:02.950
Two, three, five, eight, 1320 134 Do you remember this to be any of the series that you have heard

17:02.950 --> 17:03.310
about?

17:04.640 --> 17:04.930
Right.

17:05.260 --> 17:06.110
But this is a.

17:07.390 --> 17:08.050
Through an exquisite.

17:11.310 --> 17:11.550
Okay.

17:12.120 --> 17:15.630
So as we know from when equity starts from one, then one.

17:16.580 --> 17:21.150
Then one plus one is two and two is three and so on, right?

17:21.500 --> 17:23.600
Five and eight and so on.

17:24.830 --> 17:30.710
So again, here we are getting answers is fibonacci's series for particular i.e. let's see if I is equal

17:30.720 --> 17:31.070
to one.

17:31.070 --> 17:31.990
Answer equals two.

17:33.170 --> 17:39.350
Here we can see that the answer for this series equals to Fibonacci of ten plus eight.

17:41.150 --> 17:45.410
But if it goes to one answer, it goes straight to if I go through to answer, he goes to three.

17:45.890 --> 17:48.380
If I go to three answers, it goes to five.

17:49.070 --> 17:50.630
Well, you can easily see.

17:51.900 --> 17:56.850
To ensure dance music goes to nothing but forbidden to give endless to a low ebb.

17:58.030 --> 18:00.290
This is a very standard type of caution.

18:00.290 --> 18:07.250
And by this we realize by this problem, we realize that all those CDs are kind of related to.

18:08.060 --> 18:14.900
We would have never thought that the cities with this particular arrangement would give us unique numbers

18:14.900 --> 18:15.590
as the answers.

18:16.010 --> 18:17.020
They don't.

18:18.210 --> 18:18.470
Yeah.

18:18.480 --> 18:24.240
So here, I leave you with a problem, which is if the answer to it goes to Fibonacci numbers, then

18:24.540 --> 18:25.020
why?

18:25.230 --> 18:28.800
Why, why evolve the recursive relation, the reform rate?

18:28.800 --> 18:32.820
To hear that goes in relation to that form, let me write it also loop.

18:34.080 --> 18:39.710
Releasing the deformities index bomber boolean value which is previous one and.

18:39.970 --> 18:41.280
And the length of the area.

18:43.570 --> 18:43.900
Right.

18:44.380 --> 18:51.340
And what I'll do is in the next part, I want you to understand why is the recording solution not equal

18:51.340 --> 18:55.270
to something like this Fibonacci of index?

18:56.550 --> 18:59.010
Is it goes through the panic of index plus.

19:00.770 --> 19:02.330
We're going to give you an X minus one.

19:02.690 --> 19:07.190
Let's see when I go for Knicks minus, I mean, different ethnicities.

19:07.700 --> 19:13.970
I just think about it and then we will come back to it in the later section of the course.

19:14.180 --> 19:15.560
Later in the evening, the debut section.

19:16.220 --> 19:21.320
This was just about an introduction video that every new programming solution will have a recursive

19:21.320 --> 19:22.160
solution added.

19:23.300 --> 19:25.280
At its heart aid and.

19:27.350 --> 19:30.620
So we can also discuss about the complexity of this function.

19:30.620 --> 19:32.380
And this is normal recursion.

19:32.720 --> 19:37.670
So what will the complexity of this the complexity of this request to the Fibonacci numbers?

19:38.180 --> 19:39.060
It is 144.

19:39.080 --> 19:40.550
How are we getting 144?

19:40.610 --> 19:42.890
Because we are summing up those many ones.

19:43.740 --> 19:49.730
Two, we are going to do the end of the tree coming back, going and coming back and moving up and down

19:49.730 --> 19:51.920
recursively and adding all these ones.

19:52.850 --> 19:53.080
Well.

19:53.790 --> 19:55.130
So, yeah.

19:55.160 --> 19:56.090
So the.

19:57.580 --> 20:02.170
Dan, complexity of this is off, Fibonacci, off and blistering.

20:02.350 --> 20:05.560
It's all fancy because this is a recursive solution.

20:05.980 --> 20:07.480
Now, just think about it.

20:08.320 --> 20:11.050
How many parameters in this function are variables?

20:12.650 --> 20:13.700
Index is a variable.

20:13.700 --> 20:16.340
We can see that index is continuously bending.

20:17.030 --> 20:25.220
Aid is end changing days and is not changing rate in all the recursive calls and is constant rate and

20:25.850 --> 20:29.000
our variable is previous one, whether it is false or true.

20:29.000 --> 20:30.320
So there are only two values of it.

20:30.920 --> 20:38.030
If I want to memorize it, if I want to save the answer and you know, not call the recursion again,

20:38.030 --> 20:41.210
if it is already been calculated, then how many states can I have here?

20:41.780 --> 20:48.260
I can have index because index is changing from 1.8 indexing to previous ones of states.

20:48.590 --> 20:49.190
That means.

20:56.020 --> 21:00.010
Index in two previous ones and where this province went, how many previous ones are there?

21:00.760 --> 21:06.610
Because only these two are the these two are varying rate, these many combinations I can have eight.

21:06.820 --> 21:10.240
So how many indexes are there and indexes and how many previous ones are there.

21:10.240 --> 21:10.990
And into two.

21:11.050 --> 21:18.850
I just need an area of and cross to do memorize this recursive solution and to bring its complexity

21:19.210 --> 21:22.900
from all Fibonacci numbers back to.

21:24.400 --> 21:30.070
Linear rate because this is a linear series begins here and into the easy goes to linear rate window

21:30.070 --> 21:30.280
in.

21:31.690 --> 21:36.820
If I want to memorize it, I can also memorize it and then it becomes a dynamic programming solution.
