WEBVTT

00:00.960 --> 00:01.410
I own.

00:01.740 --> 00:05.340
I have a very, very interesting problem here, which is regarding the.

00:06.390 --> 00:08.400
And let's see how to solve this.

00:09.150 --> 00:13.410
And it will be very easy for you now to call this out, right?

00:15.030 --> 00:16.680
And indeed there is diesel battery.

00:16.830 --> 00:26.010
If the sum of its digit is also divisible by three, for example, 702 is divisible by B and will.

00:27.270 --> 00:28.650
Is altered is al-Badri.

00:29.070 --> 00:29.600
Okay.

00:29.610 --> 00:31.590
So this property holds for nine.

00:31.590 --> 00:33.470
Also root eight.

00:34.050 --> 00:37.130
In this problem we will investigate this property for other entities.

00:37.600 --> 00:41.280
Great input starts with an intermediate less than 200.

00:41.610 --> 00:41.820
Okay.

00:41.820 --> 00:43.410
So there are some test cases.

00:44.670 --> 00:48.000
Each case contains three positive indicators avian care.

00:48.510 --> 00:51.300
Okay, so we have the ranges so we can see the range is high.

00:51.600 --> 00:55.020
It is ten days to the power nine kind of range.

00:55.390 --> 00:56.910
It will 15 in and.

00:58.420 --> 00:59.410
Just to avoid overflow.

00:59.410 --> 01:00.330
I'll take long longing.

01:00.910 --> 01:02.590
And what is this?

01:02.620 --> 01:04.270
This is a sacred number, which is key.

01:04.690 --> 01:08.870
And gays on little 1000 10,008.

01:09.310 --> 01:15.280
So for each case output, the case number, and the number of integers in the range e, comma b, which

01:15.280 --> 01:19.400
are divisible by K and the sum of its digit is all to resolve by key.

01:20.320 --> 01:21.190
Interesting point.

01:22.050 --> 01:24.790
The number should really make it so we already know.

01:24.790 --> 01:25.120
Right?

01:25.510 --> 01:26.580
But we have to find it in.

01:26.650 --> 01:27.850
In the range of it to be.

01:28.790 --> 01:35.090
So if if the problem did not contain this part, which is and this amount is the same, then it would

01:35.180 --> 01:35.990
have been very easy.

01:36.240 --> 01:37.520
It is symbolic.

01:37.890 --> 01:40.130
Yubikey minus Iraqi symbol.

01:40.130 --> 01:40.400
Right.

01:41.270 --> 01:47.090
But now what we have to do is we have to also check for the sum of its digit, whether it is divisible

01:47.090 --> 01:47.750
by Q or not.

01:48.530 --> 01:49.460
This is interesting.

01:50.120 --> 01:50.390
They.

01:51.620 --> 01:53.360
How can we solve this?

01:53.390 --> 01:54.380
How can we do this?

01:54.620 --> 01:56.120
Is that easy?

01:56.450 --> 02:03.480
Now, just think about placing deserts at each index if you're placing some digits at a particular location.

02:03.500 --> 02:09.050
Of course, these are records of solution and we have already coded a particular equation out of it.

02:09.500 --> 02:15.500
Will I'll be continuing from that record because it plays only from where I left from there, because,

02:15.500 --> 02:16.790
of course, that we've already done.

02:17.090 --> 02:19.940
I'll continue from there only and we will see how to solve this problem.

02:19.970 --> 02:23.410
It's very easy if you have understood that particular equation.

02:24.290 --> 02:30.460
It means we are placing some digit and will keep on placing digits in which location will hit rate.

02:30.600 --> 02:31.730
Still, it'll be.

02:33.110 --> 02:37.190
What we'll do is we'll find out how many such numbers are there for a particular range.

02:37.220 --> 02:38.450
Let me quickly write it.

02:38.900 --> 02:39.150
Yeah.

02:39.960 --> 02:47.790
Let's say F of x is the function which gives me the numbers which satisfies the property.

02:52.760 --> 02:55.330
02x82.

02:55.340 --> 02:56.540
How many such numbers are there?

02:56.930 --> 02:59.240
So if I want to find out the answer for you to be.

03:00.480 --> 03:01.590
Then what it will be?

03:01.590 --> 03:05.160
It will be F of B minus F of minus one eight.

03:05.520 --> 03:08.790
The total number of such numbers which are between zero.

03:08.790 --> 03:09.210
Do we?

03:10.060 --> 03:14.230
And I subtract how many of them are between 0 to -1?

03:15.510 --> 03:16.590
This will give me deliberate.

03:16.620 --> 03:18.690
How many of them are satisfying the property?

03:18.690 --> 03:18.930
Come.

03:20.350 --> 03:20.890
It'll be.

03:21.250 --> 03:22.450
I hope this is very clear.

03:23.260 --> 03:25.240
This is nothing but like prefix sums.

03:25.240 --> 03:25.540
Right.

03:26.170 --> 03:27.660
But how do you calculate this?

03:27.910 --> 03:31.690
How will you figure out what is this f how will you call this out?

03:32.890 --> 03:33.910
So this thing.

03:34.180 --> 03:36.190
Okay, daunting right now.

03:36.190 --> 03:37.170
Just look at me.

03:37.180 --> 03:38.740
How am I trying to do it?

03:39.310 --> 03:43.960
What I'll do is I'll write a recursive solution which will go over all the digits in the sum of all

03:43.960 --> 03:44.830
the digits.

03:44.830 --> 03:51.400
And I just write a base case and then I'll make you realize the properties of recursion.

03:52.450 --> 03:55.000
So let me quickly write recursion off it.

03:56.040 --> 03:57.450
But this was the last one that we did.

03:58.000 --> 03:58.680
And.

03:59.920 --> 04:00.160
Yeah.

04:00.220 --> 04:01.510
Let me see it.

04:01.510 --> 04:01.870
Maybe.

04:02.260 --> 04:02.920
Let me see it.

04:04.340 --> 04:05.090
It's called.

04:08.570 --> 04:09.410
Because.

04:09.420 --> 04:11.150
And simple.

04:12.100 --> 04:14.140
And it should be.

04:14.800 --> 04:15.030
Well.

04:16.220 --> 04:18.320
And let me open a new for you.

04:20.210 --> 04:24.050
So, first of all, let me take this input, which is nothing but three.

04:24.900 --> 04:25.940
Three is a test case.

04:28.430 --> 04:28.760
I.

04:29.150 --> 04:29.570
Okay.

04:29.630 --> 04:30.470
Do you want me to.

04:31.740 --> 04:33.960
Let me start from the beginning.

04:35.620 --> 04:39.310
Let's call it super simple or maybe simple can also do.

04:39.710 --> 04:43.000
But what I need is I want it to be.

04:44.200 --> 04:44.890
Long, long.

04:47.070 --> 04:52.170
Define and as long and just factor.

04:54.390 --> 04:55.920
Well, now we are ready.

04:56.360 --> 04:56.560
Okay.

04:56.580 --> 05:02.320
So first of all, what we're trying to do is I'm not trying to apply a tiny programming solution here.

05:02.340 --> 05:04.830
I just try and writer recursion for this.

05:05.220 --> 05:07.230
I just look to see.

05:08.270 --> 05:13.940
I just apply a normal equation and then I'll make you realize one thing, and then it would be very

05:13.940 --> 05:14.840
clear to all of us.

05:16.130 --> 05:19.990
Let's let me just quickly code the normal recursion for.

05:25.450 --> 05:25.620
Eight.

05:25.750 --> 05:27.790
So we have a comma.

05:27.820 --> 05:28.120
B.

05:29.190 --> 05:30.480
It's Stick, Abby.

05:30.510 --> 05:33.570
Okay, so I have the third integer digit escape.

05:35.440 --> 05:36.170
Three integers.

05:37.070 --> 05:39.530
And of course, all of them are integers.

05:40.500 --> 05:44.720
So what I would suggest is on let me check what are the ranges?

05:45.350 --> 05:45.670
Okay.

05:45.680 --> 05:51.200
So this goes from finder to register about 31 and K goes from till 10,000 on the right.

05:51.770 --> 05:53.120
So those are okay.

05:54.310 --> 06:03.100
I'm taking in as strings and I'm taking kids and teacher elderly away or you yourself realize why am

06:03.100 --> 06:03.580
I doing it?

06:03.870 --> 06:05.560
So you know why I'm digging every string?

06:05.560 --> 06:08.020
Because I have to compare those digits rate.

06:08.410 --> 06:09.160
That would be the.

06:09.160 --> 06:14.860
And then why I'm digging kids and because I take models from key to check whether the number is divisible

06:14.860 --> 06:15.610
by Q or not.

06:16.210 --> 06:16.420
Eight.

06:16.990 --> 06:17.410
So.

06:18.900 --> 06:24.750
And to check with the NumbersUSA wiki and also whether it's some is doable by Kerner.

06:26.070 --> 06:27.390
So yeah, let's go back.

06:28.820 --> 06:29.990
It's going back to the problem.

06:29.990 --> 06:34.820
It simply sees for each case output the case number and number of 20 designated, which are resolved

06:34.820 --> 06:39.130
by key and some of its digit is altered user by key eight.

06:39.680 --> 06:39.970
So.

06:42.770 --> 06:48.670
But let me write a function called Soil Aid and in which I will pass.

06:48.670 --> 06:51.040
And or do you want me to call it F?

06:52.080 --> 06:54.810
This is a function which I've defined here.

06:55.640 --> 07:01.640
It will tell me how many such numbers I did which certified this property from 0 to 8.

07:02.100 --> 07:04.370
So I just pass a number there.

07:04.380 --> 07:05.150
Let's call it ten.

07:05.640 --> 07:05.820
Right.

07:05.880 --> 07:10.140
It will just tell me how many numbers are there from zero to end which satisfies the current property

07:10.740 --> 07:12.090
and what will I find it on?

07:12.090 --> 07:18.720
So it will be nothing but F of B minus F off e minus one.

07:19.410 --> 07:23.310
I hope this is very clear in this fight is this part should be very clear.

07:23.910 --> 07:25.980
Now we are just very taught how to write this function.

07:26.490 --> 07:26.700
It.

07:28.100 --> 07:34.010
What I'll do is I'll just quickly start coding the digital divide here now, which is nothing.

07:34.010 --> 07:35.410
We're just writing a normal equation.

07:35.420 --> 07:36.290
I'm not doing anything.

07:36.290 --> 07:40.730
We're just writing a normal equation that the one that I've already explained.

07:41.750 --> 07:43.160
I'll just see.

07:44.740 --> 07:45.420
Um.

07:45.820 --> 07:46.630
Let's see.

07:46.660 --> 07:48.790
I return and I'll call in the function.

07:48.790 --> 07:51.090
Call all eight.

07:51.370 --> 07:52.810
And in this solver, I'll pass.

07:52.810 --> 07:54.370
I need to pass the index.

07:54.370 --> 07:59.710
We all know we need to pass the index because we have to find we have to make this hold.

08:01.150 --> 08:05.080
And we we need to alter passing value, which is called true.

08:06.390 --> 08:07.860
Let me quickly related.

08:09.020 --> 08:10.340
This is index.

08:10.610 --> 08:12.770
This is this can be a boolean.

08:13.160 --> 08:14.330
And let's call it last.

08:14.960 --> 08:15.920
And what's the third?

08:16.880 --> 08:21.320
What are the properties that I need to find that the number should be resolved by key and the sum of

08:21.320 --> 08:23.450
its digits should also be resolved by key.

08:23.960 --> 08:24.230
Right.

08:24.770 --> 08:25.020
Okay.

08:25.820 --> 08:29.300
What's the best way to figure out whether a number is used by key or not?

08:29.540 --> 08:32.420
And what is the best way to figure it out?

08:32.420 --> 08:35.060
Whether it's some of the duties or not?

08:35.450 --> 08:37.070
Because we are moving digit where digit.

08:37.280 --> 08:39.770
So what I will do is I keep a variable called sum.

08:40.560 --> 08:41.610
And I.

08:42.670 --> 08:44.950
Updated by calling somewhat late.

08:45.250 --> 08:45.850
So if.

08:47.470 --> 08:48.110
Let's see.

08:48.880 --> 08:50.350
Let's take any number later.

08:50.350 --> 08:53.560
Three, four, two, one, eight and two.

08:54.450 --> 09:00.750
If I want to find out whether this number is diesel by three or not, what I what I can do is right

09:00.750 --> 09:03.900
now I'm talking about the number itself and not its digit eight.

09:04.680 --> 09:04.980
So.

09:06.340 --> 09:07.080
It's very simple.

09:07.660 --> 09:08.590
If I have this tree.

09:08.590 --> 09:17.830
So what I can say is I can simply say if three into ten is if three or ten, whatever it makes, plus

09:17.980 --> 09:21.460
for eight into ten.

09:24.980 --> 09:27.200
Plus two into ten.

09:29.870 --> 09:32.480
Plus one.

09:33.370 --> 09:33.850
In Jordan.

09:33.910 --> 09:35.500
I'm just trying to break things for you.

09:35.500 --> 09:39.700
Right, so that you can understand it on the granular level.

09:40.420 --> 09:40.690
Yeah.

09:41.140 --> 09:41.430
Okay.

09:41.470 --> 09:42.310
What is this number?

09:42.540 --> 09:49.990
This number is 330 plus four is 34 in the ten plus two is before two in to ten plus one is this in Jordan

09:49.990 --> 09:51.880
was two is eight.

09:52.060 --> 09:55.300
So indirectly it is this number only, which I'm worried about.

09:55.630 --> 09:57.130
And I if I want to find out.

09:58.220 --> 10:05.540
Whether this particular number is divisible by three or not goes up boundary at every moment.

10:05.540 --> 10:10.490
Whenever I'm multiplying or adding something, let's am placing three, eight and the looping button

10:10.490 --> 10:11.240
and adding four.

10:11.630 --> 10:16.850
Why can't I just always take more it it's always take more than will multiply by ten.

10:17.120 --> 10:17.810
Add two.

10:17.840 --> 10:19.010
Then again we'll take more.

10:19.920 --> 10:20.910
Eight more by three.

10:20.910 --> 10:21.540
More by three.

10:21.540 --> 10:22.860
Because Vino right there.

10:22.870 --> 10:24.030
Mahrez is too beautiful.

10:24.030 --> 10:25.620
What addition and multiplication.

10:26.370 --> 10:29.580
That means if a plus being to see all mauled.

10:31.160 --> 10:35.390
Is equal to a mortem plus B into C mortem.

10:36.360 --> 10:36.620
Right.

10:36.870 --> 10:38.160
It means what I've done.

10:38.160 --> 10:38.400
I've.

10:38.700 --> 10:39.510
I've done nothing.

10:39.510 --> 10:40.800
I'm just walking over.

10:40.800 --> 10:41.370
It's desert.

10:41.370 --> 10:47.550
And I want to know whether the number of diesel by some particular day or not in this case.

10:48.870 --> 10:50.610
So let me quickly like this.

10:52.060 --> 10:52.300
Yeah.

10:52.330 --> 10:52.620
Let's.

10:52.660 --> 10:53.530
Let's call it.

10:54.450 --> 10:56.670
Thumb Mart say.

10:56.790 --> 10:58.170
So this is one part of it.

10:58.500 --> 11:04.140
And this will just tell me whether a number is whether it's some is divisible by three or not.

11:04.140 --> 11:04.360
Right.

11:05.250 --> 11:12.200
I will write this all function completely, but just let's patiently wait and initially I will pause

11:12.210 --> 11:14.270
zero because the number has not been formed.

11:14.280 --> 11:18.390
I'll place digits and keep on adding the digits multiplied by ten and more.

11:19.200 --> 11:21.570
And what is one more thing that we need to worry about?

11:22.170 --> 11:22.440
So.

11:23.510 --> 11:29.810
This some some of Marvel will tell me, but they don't know what it is like or not because I'm multiplying,

11:29.810 --> 11:32.780
adding and form indirectly informing that whole number.

11:33.170 --> 11:35.120
It will tell me within a mystery, make Rebecca or not.

11:35.570 --> 11:42.200
But will it tell me whether it's some of the digital duties like, you know, right before some of digital?

11:42.200 --> 11:48.770
What I can do is I can have another variable, let's call it some of digits might.

11:49.870 --> 11:50.060
Eight.

11:50.650 --> 11:56.860
So in this case, what I'll do is when I place three or four or two or one or two when I'll place this,

11:56.860 --> 12:03.610
that means whenever I'm iterating over all these numbers and trying to place them in this three.

12:03.790 --> 12:04.110
Right.

12:04.120 --> 12:11.440
Exactly what I will do is I'll simply say some digit MAAD is equal to whatever some digit mod was there.

12:13.550 --> 12:18.500
Plus the digit that I place here is that I place here, mart.

12:20.340 --> 12:22.440
Eight more back in place.

12:23.160 --> 12:26.700
And what was it about the previous variable?

12:27.060 --> 12:38.580
Let me quickly rated the previous variable we had a mod is equal to some mod in 210 because now we are

12:38.580 --> 12:41.580
worried about whether the whole number is resolved by key or not.

12:41.580 --> 12:42.990
Rate plus digit.

12:44.020 --> 12:46.520
And when I do this, I just take my bike.

12:46.520 --> 12:46.660
You.

12:47.720 --> 12:47.960
I.

12:47.960 --> 12:48.980
We are getting bored.

12:48.980 --> 12:50.960
These variables, these are very important.

12:51.680 --> 12:53.660
This is what is explained.

12:53.660 --> 12:55.540
a.B, I have to write the equation.

12:55.540 --> 12:55.700
Right?

12:55.730 --> 12:57.800
I have to take this index variable.

12:57.800 --> 13:01.250
I have to take this last variable index and last.

13:01.260 --> 13:01.600
Right.

13:02.120 --> 13:03.740
But I have to take some extra.

13:04.960 --> 13:06.070
A variable as well.

13:06.180 --> 13:13.800
Just to figure out whatever is the property according to the property, that problem is asking me to

13:13.810 --> 13:19.330
I just need to keep count of those edibles also so that when I reach the base case, I can simply check

13:19.600 --> 13:19.800
it.

13:20.270 --> 13:21.550
Let me quickly rate it first.

13:23.790 --> 13:26.520
It's a this is some legitimate, I hope.

13:27.200 --> 13:29.730
Right now, everything is very clear in Italy.

13:29.730 --> 13:31.200
Some legitimate will also be zero.

13:33.930 --> 13:35.190
We have to be.

13:35.190 --> 13:35.970
We have care.

13:36.120 --> 13:39.330
And yeah, I think to know that things are going fine.

13:40.110 --> 13:41.640
So what was that variable?

13:41.850 --> 13:45.450
It is ill and we already know how to formulate this.

13:46.020 --> 13:49.350
So if last is true, then it is equal to.

13:50.800 --> 13:51.430
Thank you.

13:51.610 --> 13:54.670
Now we're going to talk.

13:56.180 --> 13:57.470
Now, here's this one more thing.

13:57.470 --> 13:57.710
These.

13:58.990 --> 14:00.640
The other thing is that.

14:02.120 --> 14:07.910
Whenever I am formulating that equation, it is being called by this function and and I will not be

14:07.910 --> 14:08.960
able to find out.

14:09.680 --> 14:17.030
That means I will not be able to find out that currently I have to figure out the middle earth to be

14:17.030 --> 14:18.860
right in for that case.

14:18.890 --> 14:26.480
What I can do is I can maybe you're going to this thing or let's let's do one thing.

14:28.030 --> 14:30.210
Let's make a.

14:32.220 --> 14:33.420
As an integer only.

14:33.780 --> 14:35.100
And let's right.

14:35.280 --> 14:36.300
Let's call listing.

14:36.300 --> 14:40.800
And and what will this end be equal to and will be equal to?

14:41.070 --> 14:41.370
Okay.

14:41.400 --> 14:44.730
Let's call it underscore in which which I am being parsing here.

14:45.030 --> 14:47.490
And it's a B bars to me was positive integer.

14:47.820 --> 14:51.630
I want to convert it to a string eight and.

14:52.960 --> 14:54.490
Let me convert this to a.

14:57.420 --> 14:58.290
I hope this is clear.

14:59.970 --> 15:02.070
Team in the previous order.

15:02.070 --> 15:03.520
Also, it could have a rate.

15:03.660 --> 15:05.460
I mean, it can go back.

15:06.300 --> 15:08.490
It just about, you know, some convergence to a string.

15:08.500 --> 15:15.730
And in my I mean, this is not the main problem of this situation, but let's call it a bienen.

15:15.930 --> 15:20.910
I'm digging at third string Colin and here and instead of it, let me make it string.

15:22.060 --> 15:26.210
Being underscored, underscoring because we know bees a string is a string, right?

15:26.210 --> 15:27.350
We took them as strings.

15:27.770 --> 15:29.150
Generally we take them as strings.

15:29.570 --> 15:32.630
And what I can simply say, I can simply make this an equals to.

15:33.710 --> 15:34.400
Underscoring.

15:35.570 --> 15:39.290
But in this way, what will happen whenever a F of B is called?

15:39.880 --> 15:47.230
So we will see this listing and will be stored as B and then I'll use the recursion is B, right?

15:47.240 --> 15:49.930
And afterwards when F of A minus one will be called.

15:50.330 --> 15:54.740
Okay, so I can also not do a minus one in this V because is a string.

15:55.790 --> 16:00.920
So yes, I need to change something in this.

16:00.930 --> 16:02.240
Let's let's send it back.

16:02.900 --> 16:07.970
If we change it back to string n and into a coma, become a key.

16:09.650 --> 16:13.670
Eight again, let's get it back to underscoring what I hope you understood.

16:14.120 --> 16:17.630
Eight Whatever the problem suggest you just.

16:18.650 --> 16:19.400
Work accordingly.

16:20.180 --> 16:25.130
I've just converted this underscore ten, which is an integer to a string n, which is global so that

16:25.130 --> 16:26.150
I can use it over here.

16:27.380 --> 16:27.590
Here.

16:27.590 --> 16:28.250
What will happen?

16:28.610 --> 16:34.190
It will be an off index -0 and a zero.

16:34.520 --> 16:38.060
And secondly, will have the other number.

16:38.090 --> 16:39.050
What is the other number?

16:39.050 --> 16:39.350
Nine.

16:40.110 --> 16:40.270
Eight.

16:41.060 --> 16:42.680
These were the two things you are worried about.

16:43.250 --> 16:49.280
Well, I hope you don't confuse here in this thing to end an interesting conversation, because this

16:49.280 --> 16:50.000
is necessary.

16:50.000 --> 16:53.090
This is I mean, look, this is important to convert.

16:53.810 --> 16:56.770
You can't actually figure out the indexes of these numbers.

16:58.310 --> 16:58.500
It.

16:59.970 --> 17:00.450
Okay.

17:02.760 --> 17:07.320
Now let's go over the digits.

17:08.940 --> 17:16.980
The Church will start from 0 to 4 as an equal to all eight.

17:17.610 --> 17:22.020
And what it will do is it will just call on the next functions.

17:22.440 --> 17:28.890
So let me just keep going to the variable answer and we have to return the answer because this time

17:28.890 --> 17:35.880
it is the number of counts where I simply say answer plus equals two just solved for the next index.

17:36.480 --> 17:40.950
That means that I am trying to place this digit on this particular location.

17:42.150 --> 17:43.440
So next index.

17:44.580 --> 17:49.410
And we know the variables we use for last before, last, for use last.

17:49.680 --> 17:55.680
And if this digits is equal to ten, I hope this is clear because.

17:56.690 --> 18:00.500
This will tell me whether it is the last branch of the tree or not.

18:01.760 --> 18:03.290
And this is lost.

18:03.530 --> 18:04.800
It goes to reality.

18:05.270 --> 18:09.650
You know, we are kind of in the place of the previous problem.

18:10.550 --> 18:14.330
In the previous legacy of symbol problem, index placement and lost weight.

18:14.600 --> 18:17.510
No, these are things we just come in with just somewhat.

18:17.960 --> 18:19.730
So this is normal somewhat.

18:20.000 --> 18:28.190
And some more is equal to somewhat less, but some more into N plus the digit rate.

18:28.220 --> 18:30.800
So let me add the digit over here.

18:31.970 --> 18:32.780
I hope this is clear.

18:33.230 --> 18:40.460
They'd do some more plus Dan plus digit and I have to take the more by key also because the numbers

18:40.460 --> 18:41.060
will be large.

18:41.660 --> 18:43.700
And finally, what is the last variable?

18:43.940 --> 18:46.490
The last variable is this some of digit mark.

18:46.490 --> 18:47.930
I need to pass this all to rate.

18:48.570 --> 18:52.400
So some of digit more will be nothing but just added to it.

18:52.580 --> 18:56.510
And it may take a more by key and just regular.

18:57.720 --> 18:59.940
Well, I hope this is clear.

19:00.330 --> 19:03.600
So this the first confusion is you being too strong.

19:03.600 --> 19:09.930
And when you take them, when you will be recording it, you will automatically realize that this this

19:09.930 --> 19:14.910
is the best code that you will see because you have to access the index of a number.

19:15.360 --> 19:21.600
And people do what they do is they take it and they take things that are integers and then they break

19:21.600 --> 19:23.520
down that integer into.

19:27.280 --> 19:29.500
Victim eight so that they can access the index.

19:29.500 --> 19:33.880
But I generally takes things because it's very easy to just do a minor zero.

19:34.850 --> 19:37.160
And you'll simply get the number eight.

19:38.360 --> 19:39.440
Well, so.

19:41.010 --> 19:42.270
Now let's read the base case.

19:42.510 --> 19:43.770
So there has to be a base case.

19:44.370 --> 19:45.650
What will be the base case?

19:45.780 --> 19:47.370
So if index is equal to.

19:48.680 --> 19:49.390
Edwards's.

19:51.240 --> 19:52.110
So this is important.

19:52.170 --> 19:54.240
If indexes he goes to endorse his buy.

19:54.620 --> 20:00.090
Well, I'm not taking A.B. here because I've already converted that he ought to be doing what I was

20:00.090 --> 20:04.530
calling this particular allocation that mirrored generic for both in.

20:05.720 --> 20:10.670
Now, if your next request to NASA is what what are the conditions that needs to be satisfied?

20:11.060 --> 20:13.040
The conditions there needs to be satisfied.

20:13.180 --> 20:16.310
Odd number should really make you wonder.

20:16.310 --> 20:22.180
What I can do is I can simply say if some of my fault is equal to zero because I'm already taking more

20:22.180 --> 20:24.650
moderate evidence will lose all my key.

20:25.070 --> 20:26.300
It's more or less will be zero.

20:26.840 --> 20:28.460
And what is the second thing?

20:29.210 --> 20:32.630
I'm of desert of more is should also be equal to the.

20:34.280 --> 20:41.330
So if both of them is zero, I'll return one by my returning one here because I formulated a number.

20:41.330 --> 20:49.970
I have moved down this recursive ring and in this we I have also kept some more somewhat if some digit

20:49.970 --> 20:55.430
mark and I move to the down of the leave level note where I formulated that particular number.

20:55.850 --> 20:57.680
I have this on more I have this on my Dave.

20:57.680 --> 21:00.080
I just checking now whether there is a key or not.

21:00.880 --> 21:01.300
And.

21:03.180 --> 21:09.090
If it is true, I lived in one because I formulated one particular number and just this number is giving

21:09.090 --> 21:09.780
me true rate.

21:10.050 --> 21:14.130
But till now, all of this is because it's not dynamic programming.

21:14.130 --> 21:16.890
But in just 1/2 it will convert to dynamic programming.

21:17.160 --> 21:17.910
We'll discuss that.

21:18.660 --> 21:20.040
I just written one over here.

21:20.640 --> 21:23.400
Otherwise, if this doesn't hold true, I'll return zero.

21:24.060 --> 21:25.770
I hope this is very fine.

21:26.400 --> 21:28.950
Simply, all of this will be added to the answer.

21:29.250 --> 21:31.860
I would simply written back the answer and let's build it.

21:34.280 --> 21:34.790
Okay.

21:35.240 --> 21:36.890
So what's the problem?

21:42.390 --> 21:42.750
Okay.

21:42.750 --> 21:45.900
Some more into ten plus digits.

21:47.090 --> 21:47.570
What?

21:48.870 --> 21:49.140
Yes.

21:49.800 --> 21:50.070
Yes.

21:50.070 --> 21:51.090
Scale the number, right.

21:51.600 --> 21:52.410
The call object.

21:52.410 --> 21:55.170
A bool is not a function or a function point.

21:55.410 --> 21:58.250
But they're doing something wrong.

21:58.260 --> 22:00.360
Yes, I forgot the call.

22:00.360 --> 22:00.810
My head.

22:03.170 --> 22:05.990
It's very tricky to code while teaching.

22:07.390 --> 22:10.690
A better solution is to, you know, find the code and explain the code.

22:11.860 --> 22:12.150
Okay.

22:12.160 --> 22:13.900
No magic we're going to solve.

22:16.770 --> 22:18.420
Okay by visiting.

22:18.420 --> 22:21.510
So because I have installed over here.

22:23.090 --> 22:23.660
Index.

22:24.230 --> 22:24.740
Correct.

22:25.430 --> 22:27.580
And last is a boolean, which is true.

22:27.590 --> 22:28.100
Correct.

22:28.100 --> 22:29.720
And then I'm putting two zeros.

22:31.000 --> 22:33.370
And it really doesn't meet his answer.

22:37.690 --> 22:39.670
Check by visiting.

22:40.710 --> 22:42.150
There will be miners everywhere.

22:42.150 --> 22:42.810
Minus four.

22:45.080 --> 22:45.440
Okay.

22:46.040 --> 22:49.220
Normally when you'd call for some or of.

22:51.690 --> 22:53.580
It quickly changed its name.

22:54.710 --> 22:55.130
Hollywood.

22:56.060 --> 22:57.100
But it's all right.

22:57.110 --> 22:57.470
Maybe.

22:58.810 --> 22:59.140
Okay.

23:00.370 --> 23:01.770
And so practical to solve.

23:03.280 --> 23:03.640
Okay.

23:04.090 --> 23:05.950
Let me quickly get back.

23:06.940 --> 23:07.900
Silly mistake, guys.

23:09.280 --> 23:11.030
So this index is not defined any.

23:12.110 --> 23:17.450
Their trade is not able to find the index and instead it is seeing me that is not able to find this

23:17.450 --> 23:18.470
function called solver.

23:19.120 --> 23:21.420
But initially I have to pass the value of index rate.

23:21.440 --> 23:23.450
The first thing you should value of index.

23:23.480 --> 23:26.030
Initially, the index is zero eight.

23:26.840 --> 23:29.060
The last is true and would be sometimes zero.

23:29.600 --> 23:30.800
So now let me build it.

23:32.970 --> 23:33.930
Oh, well.

23:34.740 --> 23:39.000
So what I got, I got 25 or 64 and.

23:40.460 --> 23:40.760
Yeah.

23:41.480 --> 23:41.840
Okay.

23:43.010 --> 23:44.360
Let me be very clear here.

23:44.420 --> 23:49.970
Some of you might be thinking that, yes, there were lots of problems in the code that we faced, but

23:49.970 --> 23:51.440
those problems were necessary.

23:51.440 --> 23:51.770
Right.

23:52.160 --> 23:58.940
Because whenever you at the GDP problem, you have to differentiate between things and because they're

23:58.940 --> 23:59.530
digital.

23:59.540 --> 24:03.470
And the problem is the problem will be given some good big numbers.

24:03.740 --> 24:05.960
That's why we're using digit be in there.

24:05.960 --> 24:10.130
If there are some very small numbers, you can simply trade over them and include the answers.

24:10.580 --> 24:12.380
But we we want some very big numbers.

24:12.770 --> 24:17.960
It's best to take those numbers, strings and formulate your code accordingly.

24:19.160 --> 24:24.740
This thing, because this is one of the easiest problem and just a little tricky to code.

24:25.430 --> 24:30.620
Now, what we can see, we can simply say 25 and 64 eight.

24:31.280 --> 24:32.330
Is this what we're getting?

24:32.720 --> 24:33.110
Yes.

24:33.440 --> 24:35.880
So you can also print print case according to you.

24:35.900 --> 24:37.550
So we have 25 and 64.

24:37.590 --> 24:38.930
Yeah, the answer is correct.

24:39.320 --> 24:41.890
I hope you understand why the answer is correct.

24:42.380 --> 24:44.150
Because this is normal recursion.

24:44.380 --> 24:45.460
Normal occasionally.

24:45.710 --> 24:54.110
I just wrote a recursion book, some mod and some more digits mod in me and finally made the base case.

24:54.530 --> 25:00.050
If both of if the number is the result by zero or three of the numbers, it is a key and it's is.

25:00.110 --> 25:01.460
Your time is already all by key.

25:01.790 --> 25:02.720
Then simply return one.

25:03.920 --> 25:04.250
Great.

25:05.220 --> 25:07.380
Now, let's see.

25:09.060 --> 25:14.760
In the starting of the course, I told you one thing, right, that the dynamic programming is the recursion

25:14.760 --> 25:17.300
plus memorization, right?

25:17.750 --> 25:19.080
Right now, what's happening?

25:20.130 --> 25:25.150
This particular code is going for all the numbers.

25:25.170 --> 25:30.750
It's trying to formulate all the numbers and for all the numbers it is trying to place all the digits.

25:31.050 --> 25:34.260
And then they tell this value tile here.

25:34.830 --> 25:36.930
And the code of this.

25:38.220 --> 25:40.890
So the complexity of this code is huge.

25:41.280 --> 25:43.380
What is the complexity of this recursive code?

25:43.860 --> 25:50.850
It is making all possible numbers write all possible numbers from zero to B or whatever it is.

25:51.110 --> 25:57.450
So let's take B and let's call the complexity of code S of B, because it is going for all the.

25:59.660 --> 26:01.490
It is a win for all of us to leave.

26:01.490 --> 26:06.360
No, they will be all be numbers, but it will return one or zero and then it will sum up.

26:06.380 --> 26:07.850
Then I must return it back to me.

26:08.290 --> 26:10.850
It's a let's call it or B right now.

26:11.300 --> 26:11.660
Just.

26:12.880 --> 26:15.330
Pause the video here and think about that.

26:15.880 --> 26:17.440
How many indexes were there?

26:18.100 --> 26:20.680
Like how many different values of indexes are there?

26:21.370 --> 26:23.920
The different values of indexes are mirrored.

26:26.200 --> 26:26.450
Pace.

26:27.010 --> 26:27.190
Right.

26:27.520 --> 26:31.150
Which in that case, if I talk about this, it is.

26:32.260 --> 26:32.890
Good is doable.

26:32.890 --> 26:35.140
31 is around ten days to the power nine.

26:35.290 --> 26:35.620
Right.

26:35.860 --> 26:42.520
So I'm just taking nine at max budget sizes because tonight that means the length of the number is nine

26:42.730 --> 26:43.060
eight.

26:43.480 --> 26:47.830
Now, tell me, what how many values are lost out there?

26:47.860 --> 26:49.420
There are only two values of last eight.

26:49.870 --> 26:50.680
The last is.

26:51.790 --> 26:54.400
Either true or false.

26:55.300 --> 26:56.340
This was index.

26:56.800 --> 26:57.820
This is last.

26:58.850 --> 27:03.810
They do not tell me how many some more values can be there.

27:03.950 --> 27:06.470
So we know that we are always taking more back.

27:06.650 --> 27:07.010
Right.

27:07.370 --> 27:13.700
So if I take my back of any number, then we can always say that the number is between zero and Q minus

27:14.030 --> 27:14.330
one.

27:15.350 --> 27:16.640
Fate was determined.

27:16.850 --> 27:20.930
If I did the remainder of England were any of the number eight will be between zero and minus eight.

27:21.290 --> 27:23.000
Basically some mould.

27:23.910 --> 27:29.520
Rely between 0 to -1 to how many different values of smart can be there?

27:30.120 --> 27:32.670
EE eight And now tell me.

27:34.220 --> 27:35.330
Some digit.

27:38.200 --> 27:45.190
So similarly there's some legitimate is also being a bitcoin marred by rate but at most it can go to

27:45.190 --> 27:46.840
K minus one eight.

27:47.110 --> 27:49.060
So it is also from zero to K minus one.

27:49.410 --> 27:53.350
So how many different values of some digital model did it look?

27:53.530 --> 27:56.200
How many total different values?

27:56.200 --> 28:01.870
I mean, how many total different deep states are possible of this recursive solution?

28:02.500 --> 28:03.550
I know that.

28:04.730 --> 28:10.970
This tree will go on these trees moving downwards and it is, you know, spreading and it is going for

28:10.970 --> 28:12.140
all possible numbers.

28:12.800 --> 28:16.430
But just think about it in this way.

28:16.730 --> 28:23.240
At how many different speeds are possible is nine into two into Kentucky?

28:24.660 --> 28:24.990
Right.

28:25.500 --> 28:28.020
Which is nothing but Gay Squire didn't do it in.

28:29.310 --> 28:36.000
These many deep states will be there even if I go for any number which is less than two days to Dubai

28:36.000 --> 28:36.660
with 31.

28:37.290 --> 28:41.700
But any number and let it be the question to raise to about 31 minus when.

28:42.720 --> 28:48.720
But this also for this also there will be gays quite into it being stewards on the right because we

28:48.720 --> 28:50.760
saw that these are very different.

28:51.090 --> 28:56.940
These are the maximum different values index last somewhat and some digit margin.

28:58.010 --> 28:58.310
Right.

28:58.810 --> 29:02.930
So what can I realize here that I can have at most?

29:04.010 --> 29:08.330
He liquidated the large size, which is nine.

29:09.340 --> 29:09.640
Eight.

29:09.880 --> 29:11.590
Nine on lipstick.

29:11.590 --> 29:14.320
Ten a but human look.

29:14.530 --> 29:17.590
Ten into the last two is only true or false.

29:17.590 --> 29:19.000
Someone goes to key.

29:19.000 --> 29:24.550
And this also goes to we have these many different dates of this discussion.

29:25.480 --> 29:29.890
If you have only these many different styles of recording, how much is Keith quite entertaining.

29:30.370 --> 29:37.380
Let's check the damage to the barber for Esquire in ten will witness to Barber 98.

29:37.810 --> 29:39.490
So I hope you're getting the point here.

29:40.780 --> 29:41.030
So.

29:42.900 --> 29:43.200
Yeah.

29:43.290 --> 29:44.100
So it's very easy.

29:44.100 --> 29:50.340
You know, what you can simply do is you can simply try to memorize this particular recursive problem

29:51.360 --> 29:53.940
and we can simply place memorization over here.

29:56.950 --> 30:02.020
Like the memo and let's call it 1042.

30:02.020 --> 30:03.390
Let's call it okay.

30:03.400 --> 30:04.150
And let's call it.

30:05.110 --> 30:08.380
Yeah, but we have taken a memo bed.

30:08.380 --> 30:14.350
What we will simply do will simply memo said memo minus one side of memo.

30:15.280 --> 30:19.210
Whenever we are calling anything, we are calling any recursive.

30:20.700 --> 30:21.030
Good.

30:21.420 --> 30:23.400
We'll just marmoset it.

30:23.670 --> 30:25.170
And we all know how to.

30:26.240 --> 30:28.400
Work with mammal bird flu.

30:28.400 --> 30:30.500
Mammal Index.

30:32.100 --> 30:36.900
Last will just simply memorize it and will take some old.

30:38.400 --> 30:42.600
And then we will simply see some injured.

30:43.360 --> 30:43.840
Mort.

30:45.510 --> 30:45.770
Eight.

30:46.470 --> 30:53.310
And this will be the member for us and before this before adopted the base case.

30:53.310 --> 30:58.590
What I ultimately do ultimately say if I, I already have this answer, it means if this.

31:00.090 --> 31:02.730
Is not equal to minus one.

31:03.820 --> 31:04.690
I looked at this.

31:06.330 --> 31:07.410
I hope this is very clear.

31:07.410 --> 31:08.700
This is nothing memorization.

31:08.700 --> 31:10.560
We are all we have already been doing this.

31:10.890 --> 31:14.600
But this is important to realize it will have very listed.

31:14.620 --> 31:16.470
So in this case we can see that there are.

31:17.850 --> 31:22.080
There are too many stories of at least our nine eight.

31:22.290 --> 31:26.100
And we'll also discuss some follow up optimizations of this problem.

31:26.470 --> 31:28.230
But I hope you have understood this part.

31:28.620 --> 31:30.780
How is a recursion being converted to a dynamic?

31:31.680 --> 31:36.900
In the case of digit GP, this is the most important part index in last, which you have already understood.

31:37.170 --> 31:39.690
And these two values are based on a particular problem.

31:41.160 --> 31:41.520
So.

31:44.180 --> 31:45.910
But these are based on a particular problem rate.

31:45.950 --> 31:50.630
And of course, there will be some other properties also by which we can further reduce the number of

31:51.050 --> 31:51.860
seats here.

31:52.310 --> 31:56.570
If we can reduce the number of states further, then the problem will be optimised more.

31:57.380 --> 32:01.820
So we can see it is a multi-dimensional deep aid because we have four dimension.

32:03.610 --> 32:03.830
Well.

32:04.420 --> 32:07.420
So thank you, everyone, for watching this.

32:07.420 --> 32:08.290
And I hope you.

32:09.440 --> 32:11.900
Understand what's going on in the.

32:12.960 --> 32:16.710
These are deep and will be solving like many problems after this.

32:16.860 --> 32:19.930
And we'll see how all those problems are solved using legitimate.

32:20.900 --> 32:21.350
Thank you all.
