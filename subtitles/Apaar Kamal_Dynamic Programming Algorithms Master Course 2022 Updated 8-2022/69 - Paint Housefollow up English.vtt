WEBVTT

00:00.390 --> 00:07.080
I also I have a very interesting follow up problem offering greenhouse, which is nothing but when colours

00:07.080 --> 00:08.920
are not three but right.

00:09.060 --> 00:15.990
Let's say we I have gigolos but if I apply the same logic that I have done in the previous approach,

00:15.990 --> 00:18.960
which is this depends, nothing but many more department is one.

00:18.960 --> 00:20.160
Judith it is.

00:20.180 --> 00:22.020
The dress is not equality.

00:23.040 --> 00:27.150
So right now cake illustrates what the time complexity of my code.

00:27.150 --> 00:35.400
It will be an roski roski grade because for all these kids I will be going on the previous kids and

00:35.400 --> 00:36.630
checking their minimums.

00:37.140 --> 00:37.500
Correct?

00:39.110 --> 00:41.120
Basically let me open the code.

00:43.190 --> 00:47.840
So if I apply this, that means it will be a key growth loop.

00:47.840 --> 00:49.120
Instead of three, I'll have key.

00:50.350 --> 00:50.650
Right.

00:50.980 --> 00:52.770
And other ways I can write this.

00:52.810 --> 00:58.690
But this will also be a give complexity and maybe more because we'll be doing so many minimums.

00:59.590 --> 01:06.100
But can you optimize it in some way so that the complexity is not growth rate because.

01:07.240 --> 01:08.340
For any column.

01:08.350 --> 01:14.830
What I want is I want to find out the minimum of the previous column except for the current rule.

01:15.550 --> 01:17.830
So instead of this, tell me what is the minimum?

01:18.670 --> 01:20.680
If I want to find out the value for this.

01:21.580 --> 01:22.450
That's what we are doing.

01:22.480 --> 01:25.270
We want to find out the minimum of the previous column.

01:25.840 --> 01:27.840
How can you solve this?

01:27.850 --> 01:31.960
How can you find out the minimum of the previous column except for this minimum?

01:34.610 --> 01:41.480
So it's actually very easy if you can think about it because to how can you do this?

01:41.480 --> 01:44.270
We can easily solve this by.

01:45.210 --> 01:45.720
Kicking.

01:46.770 --> 01:47.430
Minimum.

01:48.850 --> 01:50.760
Minimum to lose weight.

01:51.620 --> 01:56.890
So what I can do is I can take just two values, which are actually the minimum one and minimum two

01:56.890 --> 01:58.930
in the previous column eight.

01:59.080 --> 02:06.190
So for any current cell in the current column, what we what can we do is we can simply say, was this

02:06.190 --> 02:09.010
value equal to the previous value, which is the minimum one?

02:09.040 --> 02:09.520
Basically.

02:09.520 --> 02:10.480
Okay, let me write it.

02:12.490 --> 02:20.590
Let's have minimum one and minimum two towards minimum when it is the bottom value in the previous.

02:22.620 --> 02:27.770
Previous column eight and minimum two is the second lowest value in the previous column.

02:28.410 --> 02:38.040
If I'm feeling some deep I comma d, that means I can simply see DP Isaac and B at their minimum one.

02:38.070 --> 02:42.120
It can be at their minimum one plus cost.

02:43.160 --> 02:46.280
Or does this cost 88?

02:46.520 --> 02:51.080
Or it can be minimum less cost 88.

02:51.860 --> 02:57.140
If is it can be either one of these two values, then I can simply take it by using by seeing if an

02:57.140 --> 02:58.310
is rate that means.

02:59.480 --> 03:07.400
If the previous value which is let me write b i.e..

03:08.530 --> 03:10.630
From day minus eight.

03:12.110 --> 03:14.150
If the previous from the same.

03:15.430 --> 03:19.150
Rule is equal to minimum one.

03:20.150 --> 03:22.880
They then take minimum to.

03:23.910 --> 03:29.040
Because that was the minimum age to take the second minimum, because that would be the minimum value

03:29.040 --> 03:30.120
of others.

03:30.120 --> 03:30.440
Right?

03:30.630 --> 03:32.930
Except the ethical rate.

03:33.120 --> 03:39.180
Otherwise, if it is not the case, then what I can do is I can take the minimum one common cause,

03:39.180 --> 03:46.160
because if the corresponding values are not the minimum, that means that minimum one is somewhere else,

03:46.170 --> 03:46.490
right?

03:46.530 --> 03:51.300
And if I take the minimum for all the other values, that minimum one will come as the minimum, but

03:51.300 --> 03:52.380
it's a minimum for all.

03:54.480 --> 04:00.120
So in India, what I can do is I can take this case and in this, if I can take this and I just have

04:00.120 --> 04:05.430
to take two minimum values rate for a particular and also you can solve.

04:06.660 --> 04:08.960
So what would be the ten complexity here now?

04:10.470 --> 04:14.520
So basically what I'm doing is for all the I was saying, for all the so and in the case, it ain't

04:14.520 --> 04:21.000
complexity because now I can just use this if is second question can be what is a memory complexity

04:21.000 --> 04:21.720
that you will use?

04:22.200 --> 04:26.880
The memory complexity will will have to make the table right the table.

04:27.090 --> 04:28.170
That will be an indicator.

04:28.470 --> 04:31.230
But I can also optimize the memory complexity.

04:31.560 --> 04:32.610
You all know how read.

04:33.000 --> 04:40.050
So for any column, I just want its previous column or insert in that.

04:40.080 --> 04:44.190
In this case, if I just keep two columns with me, then the memory complexity will be.

04:45.930 --> 04:48.040
NW And is this right?

04:48.040 --> 04:50.880
So it will be key in order to correct.

04:51.240 --> 04:52.740
But I can further optimize.

04:52.740 --> 04:59.220
I can instead of thinking to do, I can just stick it out, just fill the column.

04:59.220 --> 05:00.480
Then again iterate over it.

05:00.750 --> 05:07.110
I in the minimum one and minimum two value, then again fill it using the new values so we can just

05:07.110 --> 05:10.260
fill one column again and again and do the job.

05:12.000 --> 05:14.010
So that's it, everyone.

05:14.520 --> 05:15.390
See you in the next part.

05:15.870 --> 05:19.800
And you can further, you know, reduce the memory complexity.

05:19.840 --> 05:25.590
Ah, I'm sorry if I'm confusing you or something, but you can further reduce the memory complexity

05:25.590 --> 05:26.280
from came to do.

05:26.280 --> 05:32.490
We can make it to keep but you know ultimately what we can do is we can further reduce it to just four

05:32.490 --> 05:33.150
variables.

05:33.540 --> 05:34.470
Just for variables.

05:35.250 --> 05:41.040
We just need to keep some for variables the current minimum of the current column and let's say the

05:41.040 --> 05:47.490
current minimums of the current column rate and the current minimum of the previous column.

05:48.500 --> 05:51.050
Only those two will be needed to.

05:52.040 --> 05:53.740
Family man to hate.

05:53.780 --> 05:57.200
And if you want to trade, you can trade yourself.

05:57.230 --> 06:03.230
I'm not coding this for a variable value solution, but I would strongly suggest you to do it because

06:03.230 --> 06:03.680
it's good.

06:04.970 --> 06:06.170
We'll see in the next part.

06:06.170 --> 06:07.200
And this was nothing.

06:07.200 --> 06:10.130
We're just a follow up problem of the outside of a problem.

06:10.820 --> 06:14.220
So next we will see a very interesting problem from cold faucet.

06:15.050 --> 06:15.380
Thanks.
