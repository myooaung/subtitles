WEBVTT

00:00.870 --> 00:02.560
Okay, buddy?

00:03.420 --> 00:03.730
Yes.

00:03.750 --> 00:08.340
So let's go to this part, which is flowers, the part that we've discussed.

00:08.340 --> 00:10.220
And it's very easy.

00:10.360 --> 00:11.910
It's not that tough because.

00:12.980 --> 00:18.500
We have to apply a normal recursive relation in this case, which is nothing, just like problem in

00:18.710 --> 00:19.980
scoring the brute force part.

00:19.980 --> 00:20.220
Right?

00:20.240 --> 00:28.490
So let's stick and as an input then we have an eddy of heights and we have an array of beauties and

00:28.490 --> 00:30.510
it's utterly record beating.

00:33.670 --> 00:33.890
Okay.

00:34.450 --> 00:36.280
Let's stick and see.

00:37.220 --> 00:39.500
Similarly, let's take AA as an input.

00:40.420 --> 00:40.690
Well.

00:42.510 --> 00:43.710
Not extremely deep values.

00:43.710 --> 00:45.510
So here, what we can do is it's.

00:46.950 --> 00:48.270
Have a double for loop.

00:49.900 --> 00:50.320
Great.

00:51.460 --> 00:54.160
So, David, start from zero and give it a good lesson.

00:54.310 --> 00:54.520
Right.

00:54.820 --> 01:02.190
That's what this say, is it Jesus and I edges less than AJ and be raised max of the produced +88.

01:02.700 --> 01:10.030
So yeah so what we have is we have each of these less than edge of i.e. that means if the beauty value

01:10.030 --> 01:16.990
of AJ the other index is less than the current index, then that can be a valid extender, right?

01:17.050 --> 01:19.360
That can be a valid index that I'm looking for.

01:19.750 --> 01:20.040
Eight.

01:20.500 --> 01:21.130
So what.

01:21.130 --> 01:21.760
I'll have you.

01:22.030 --> 01:24.790
I'll have if I use max of.

01:25.860 --> 01:27.990
BP, i.e. whatever the value was failing.

01:28.080 --> 01:28.260
Okay.

01:28.320 --> 01:31.680
So we will look at that later.

01:32.270 --> 01:34.040
The deep if I.

01:35.290 --> 01:39.580
Well, this is the normal recursive relation that we define and we are trying to figure it out.

01:40.000 --> 01:40.210
Okay.

01:40.540 --> 01:42.130
What should be the DPA value here?

01:42.640 --> 01:43.450
Fill it with zero.

01:44.260 --> 01:48.640
If I fill it with zero and let's say there were no elements which were smaller, it means there was

01:48.640 --> 01:52.010
no such d which was smaller than AGI.

01:52.030 --> 01:53.320
That means there was no ending.

01:53.320 --> 01:56.140
The answer would be zero, but it should not be delayed.

01:56.500 --> 01:59.860
If there is no ending that it's getting, it can start its own meaning.

02:00.480 --> 02:05.230
If it not if it's not getting any ending, it has to start with its own beauty, right?

02:05.230 --> 02:10.210
It can of like the maximum ending that can provide it for itself.

02:10.900 --> 02:12.220
So it should be instead of zero.

02:12.220 --> 02:12.820
It should be.

02:14.420 --> 02:14.690
Cool.

02:15.170 --> 02:16.490
And finally, what's the answer?

02:17.330 --> 02:19.460
It is the maximum element.

02:22.340 --> 02:23.130
Of GDP.

02:23.660 --> 02:25.250
If sick what we are getting.

02:26.840 --> 02:27.170
Okay.

02:27.170 --> 02:29.510
So it's correct in this case, let's say, for this case.

02:30.600 --> 02:30.830
Well.

02:30.870 --> 02:31.610
31 again.

02:32.040 --> 02:32.300
Eight.

02:32.310 --> 02:34.350
So, shall we submit the solution?

02:35.100 --> 02:36.950
If someone disillusioned, this should not work.

02:36.960 --> 02:37.260
Why?

02:37.290 --> 02:37.770
Because.

02:39.040 --> 02:40.680
Of the constraints of an eight.

02:40.930 --> 02:43.690
All the major edge are distinguished.

02:44.820 --> 02:47.270
You can see that and it's quite big.

02:47.540 --> 02:49.310
And what's the complexity of this solution?

02:49.310 --> 02:53.420
This coalition has in woven square complexity, because this starts from zero.

02:53.420 --> 02:57.920
This goes to like when is equal to one day has one iteration.

02:58.190 --> 03:02.570
If I is equal to two just to iteration, if I go through three days, three duration and so on.

03:03.110 --> 03:09.380
So when Daisy goes to in I so the idea was to end or end minus one day will have an minus one iteration.

03:09.380 --> 03:11.270
So what is the total number of operations for?

03:11.270 --> 03:17.870
Jay It is one to represent 1 billion minus one, which is kind of N squared complexity theta.

03:19.220 --> 03:21.170
So this work.

03:21.200 --> 03:22.070
Now what to do?

03:22.190 --> 03:23.540
This is a brute force solution.

03:23.840 --> 03:26.600
And of course, we can not even optimize it for the like.

03:26.630 --> 03:27.770
Memories of something to it.

03:28.130 --> 03:29.030
Nothing like that, right?

03:29.360 --> 03:33.290
Because of the inside loop, I have to optimize the inside loop.

03:34.160 --> 03:36.890
What am I doing is I am trying to find maximum.

03:37.810 --> 03:41.500
You know, certain range which is from zero to I that is left off.

03:41.500 --> 03:50.290
I am trying to find maximum of deep values which are field eight and I want to find the maximum in less

03:50.290 --> 03:50.560
time.

03:50.560 --> 03:54.580
Not of nodding off in time, but I want to find it maximum in less time.

03:54.580 --> 03:55.420
It can be all one.

03:55.420 --> 03:56.050
It can be.

03:57.440 --> 04:00.530
Log in can be any day to some of you.

04:00.530 --> 04:04.220
My writing and thinking about advances that I structure that we can use here.

04:05.420 --> 04:07.910
But again, we have another problem.

04:07.910 --> 04:09.270
That is the second problem here.

04:09.470 --> 04:11.600
What is the second problem that I want to find?

04:11.600 --> 04:13.760
Maximum of somebody bit on the left of it.

04:14.240 --> 04:16.580
But I have another condition that.

04:16.580 --> 04:18.800
Okay, give me maximum of only those.

04:20.340 --> 04:26.430
Index is such that this lesson which is on the left of I and edge of this lesson.

04:26.430 --> 04:26.790
It's a.

04:27.700 --> 04:27.980
Right.

04:28.010 --> 04:34.010
So if I want to find Maxim of a particular range and obtain the value also, then how will I get it?

04:34.330 --> 04:40.300
By using segment rate, I can easily use segment segments here to in the mix, but the second problem

04:40.300 --> 04:41.740
cannot be solved using segment.

04:42.280 --> 04:48.610
Second problem is that find a maximum of only those whose active users is going to take.

04:49.570 --> 04:50.770
Hey, so think about this.

04:50.770 --> 04:52.660
How will you be able to solve this problem?

04:52.660 --> 04:57.430
The second one, and then we'll discuss this in the next video tutorial.

04:59.350 --> 05:03.190
That particular approach, which I'll be explaining to you in the next part.

05:04.200 --> 05:09.930
That will help you in many places like it will help you solve many problems in a very easy way.

05:12.520 --> 05:17.890
So think about this for a time and like, how will you solve this second condition?

05:19.060 --> 05:22.470
You can find some axiom that's not an issue using segment.

05:22.480 --> 05:23.500
You can just one query.

05:23.620 --> 05:26.950
You can also update the DPA values every time you leave.

05:26.950 --> 05:32.560
And I just update the DPA values so that from 0 to -1, we have already been 58.

05:33.040 --> 05:38.590
But how do you find the maximum of only those indexes, whether this resonating?

05:39.220 --> 05:40.750
Let's discuss it in the next part.

05:41.050 --> 05:41.380
Thank you.

05:41.380 --> 05:41.590
Is.
