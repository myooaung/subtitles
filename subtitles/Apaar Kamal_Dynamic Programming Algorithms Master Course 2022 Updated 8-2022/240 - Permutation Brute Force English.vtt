WEBVTT

00:00.550 --> 00:01.490
Welcome back, guys.

00:01.520 --> 00:06.000
And let's try and code this part out, a smaller and greater element.

00:06.020 --> 00:08.090
So before that, let's write it over here.

00:08.690 --> 00:08.930
So.

00:11.960 --> 00:12.290
Let's see.

00:12.290 --> 00:13.190
These are the three.

00:14.360 --> 00:17.990
Characters, and this is the three characters and I have to place four numbers.

00:17.990 --> 00:18.940
Now, let's see.

00:18.950 --> 00:23.510
On the first place, I'm placing all the numbers one by one, I completing the first number, the second

00:23.510 --> 00:24.560
number or these are number.

00:25.010 --> 00:29.030
And then from the next part, what happens if I'm placing the first number?

00:29.030 --> 00:30.500
Then I'm going in with a smaller than one.

00:30.620 --> 00:31.580
It is zero.

00:32.390 --> 00:33.800
And how many numbers are greater than one?

00:33.800 --> 00:34.100
Two.

00:34.670 --> 00:38.390
If I'm placing this number, then one one at the waist, two zero.

00:38.540 --> 00:41.060
Well, if I'm placing three on the first location.

00:41.720 --> 00:47.900
Now, when I'm at this particular location, I have to check if it is a lesser number then.

00:49.650 --> 00:53.340
If it if the next number has to be greater than four.

00:53.460 --> 00:58.740
This said for indicate of the greater numbers LP please all these numbers one by one and manipulate

00:58.740 --> 01:03.690
that these numbers are smaller than the current number and these numbers are greater than the current

01:03.690 --> 01:04.530
number that I'm placing.

01:05.190 --> 01:07.110
You'll let me quickly.

01:08.460 --> 01:10.740
For that part, but before that.

01:10.890 --> 01:11.220
Yes.

01:14.700 --> 01:15.000
Well.

01:18.280 --> 01:19.180
At stake this.

01:21.570 --> 01:22.020
And.

01:24.900 --> 01:26.130
Well before moving.

01:26.130 --> 01:27.150
Then let's take the.

01:28.920 --> 01:29.520
Inputs.

01:30.180 --> 01:32.610
RN And its goal is to bring SDR.

01:35.910 --> 01:38.100
Well, I've taken both of them as input.

01:38.370 --> 01:40.100
Now what I'll do is I'll say, okay.

01:41.400 --> 01:47.080
The final answer will be equal to if I'm placing I'm placing all animals from one twin eight.

01:47.910 --> 01:51.120
So if I'm placing all the animals from one to end, then it will tell me that.

01:52.330 --> 01:54.130
The answer will be equal to.

01:55.800 --> 02:03.930
BP if I'm placing so from index one because I have indexed these locations, these particular locations

02:03.930 --> 02:04.650
from index zero.

02:04.650 --> 02:07.410
Right to donate and use these added index zero.

02:08.220 --> 02:12.660
What I, what I do is I'm seeing I'm placing one at the index zero.

02:12.670 --> 02:19.800
Then tell me how many bits are there to fill these many locations with these values right out of the

02:19.800 --> 02:20.580
remaining elements.

02:21.150 --> 02:22.620
If, if I'm placing.

02:24.160 --> 02:25.030
From Index one.

02:25.060 --> 02:27.340
Tell me, how many ways are there?

02:27.820 --> 02:29.990
If I have how many small elements nowadays?

02:30.040 --> 02:32.230
How many small elements are there than the current element?

02:32.260 --> 02:37.110
Right now we have a minus one, smaller elements.

02:37.690 --> 02:42.880
Okay, so if I is equals to one, that means if I'm placing one of the zeroth position, that means

02:42.880 --> 02:45.160
now I have a minus one, which is zero.

02:45.160 --> 02:46.000
Small elements eight.

02:46.020 --> 02:52.270
So if I'm placing eight, eliminate any at the first location at any point of time, that means I have

02:52.540 --> 02:55.180
eight minus one elements which are smaller than the current element.

02:55.900 --> 02:58.680
Well, and how many elements are greater than the current element?

02:58.690 --> 02:59.170
It is.

02:59.170 --> 02:59.890
And minus.

03:02.590 --> 03:02.830
Well.

03:03.010 --> 03:03.340
So what?

03:03.490 --> 03:07.870
So if I'm placing I good strategy in the first position, that means two minus one.

03:07.870 --> 03:12.780
That means one element is smaller, then two and and minus eight, which is four minus two.

03:12.790 --> 03:18.580
Two elements are greater than two, which have to be because I didn't expedition well, but I'm starting.

03:19.330 --> 03:23.350
I'm placing all the elements one by one over here because guys, now we have to handle this case also,

03:23.380 --> 03:23.710
right?

03:24.220 --> 03:27.220
We have a character and character by character.

03:27.220 --> 03:31.030
We have to handle that what we have to place at the next location.

03:31.840 --> 03:34.450
So let's see which is the index.

03:35.360 --> 03:38.750
And let's call this s and let's call this G.

03:39.390 --> 03:41.690
And these are the most elementary, the smaller.

03:41.690 --> 03:47.540
These are the number of elements which are greater than the previous element that I felt full finality

03:47.540 --> 03:47.810
out.

03:49.050 --> 03:49.530
Answer.

03:49.770 --> 03:50.880
Well, it's really this deep.

03:51.210 --> 03:52.610
It's good this part.

03:52.620 --> 03:54.510
It's like more or less like backtracking.

03:54.510 --> 03:57.660
But instead of having a state, we are having elements smaller or greater.

03:57.990 --> 03:59.400
They do not know.

03:59.400 --> 04:01.470
Everything depends on the previous value.

04:02.550 --> 04:05.490
So if string and we know the string is zero based index.

04:05.850 --> 04:09.180
So I have to use I minus one you need.

04:11.940 --> 04:16.620
So if I have less, then count if I'm filling the first location.

04:16.950 --> 04:17.520
Okay, let me.

04:18.440 --> 04:19.130
Do this again.

04:20.150 --> 04:21.770
If I'm feeling the first index.

04:22.340 --> 04:23.540
This is the one in first index.

04:23.690 --> 04:24.820
This is what the zero index.

04:25.220 --> 04:26.330
They've been putting the first index.

04:26.330 --> 04:27.920
I have to check what is as of zero.

04:28.910 --> 04:29.210
Eight.

04:30.110 --> 04:32.750
If it is this sign, that means a lesbian sign.

04:32.750 --> 04:37.900
That means I can only feel the elements which are greater than the elements which are in this set.

04:39.200 --> 04:43.920
Let's iterate over all the elements which I didn't say, but I will iterate from.

04:45.920 --> 04:46.250
But he.

04:47.720 --> 04:48.430
G Right.

04:48.950 --> 04:51.140
So I will trade from one to G.

04:51.500 --> 04:53.360
That means I'm filling all the elements.

04:55.420 --> 04:56.050
In this age.

04:56.710 --> 05:00.760
So I'm actually said you will contain the elements.

05:01.030 --> 05:04.120
So these are actually the count of elements which are greater than the previous element.

05:04.630 --> 05:09.670
But I know what I'm doing is I'm filling those elements one by one, no matter what was that element.

05:10.030 --> 05:14.830
What I know is that they are greater than the previous element that is what matters and that they are

05:14.830 --> 05:17.650
greater than the previous element or they're less than the previous element.

05:18.100 --> 05:22.060
We don't care about what exactly is that element, because I've already shown you that example.

05:23.620 --> 05:26.710
Well, now, what do we have here?

05:26.740 --> 05:27.850
We have answered the question.

05:27.850 --> 05:28.270
Zero.

05:28.570 --> 05:30.760
And modalities on surplus equals to DP.

05:31.330 --> 05:36.220
Now, if I'm placing the first greatest element later, I'm not placing all the elements in said by

05:36.220 --> 05:37.210
one eight.

05:37.690 --> 05:40.720
So the return of the elements from placing all the elements one by one.

05:41.290 --> 05:47.770
So from a plus one, he plays on the plus one to how many elements are smaller than D?

05:48.310 --> 05:49.600
If I'm placing the element.

05:50.570 --> 05:53.270
The first element of G that means the first greater element.

05:53.570 --> 05:59.120
It means, as were already smaller, less dim, minus one elements are smaller.

05:59.600 --> 06:03.520
If I'm placing this second element of the that means Jake was two two.

06:03.950 --> 06:05.120
What does it mean that.

06:08.350 --> 06:14.110
Then the previous element was this there was already a set of smaller elements that they were going

06:14.140 --> 06:14.650
to release.

06:14.800 --> 06:17.820
So this was a by s there's a set of greater element.

06:17.830 --> 06:20.550
This is represented by D eight.

06:20.550 --> 06:27.160
So if I'm placing this second element of G at the current position, so for the next position, the

06:27.490 --> 06:29.260
previous guy is actually this G2.

06:30.390 --> 06:30.640
Eight.

06:30.990 --> 06:35.040
If previous guys do you do, then how many elements are smaller than D2?

06:35.760 --> 06:38.280
We have s so these these will already be smaller.

06:38.610 --> 06:46.500
S Plus two minus one because this element that is a D first place in G first largest element from B

06:46.860 --> 06:47.770
will also be smaller.

06:47.790 --> 06:50.940
Eight Where do they split two and split two minus one?

06:50.940 --> 06:52.420
And how many elements will be greater than G?

06:52.420 --> 06:54.450
It will be D minus two.

06:55.110 --> 06:58.710
The elements which are on the right side of the due to element.

06:59.220 --> 07:03.720
So if I'm placing the element, then what I can say is that BS equals two G.

07:05.080 --> 07:12.400
If music was tragedy, then ESP plus minus one elements are smaller than d d and how many elements are

07:12.400 --> 07:13.450
greater than it is?

07:13.780 --> 07:14.410
Do you mind this?

07:16.140 --> 07:17.760
The remaining elements will.

07:19.170 --> 07:19.500
So.

07:20.910 --> 07:22.270
Nominal limits are greater than it.

07:22.310 --> 07:23.750
It is equal to g minus.

07:25.230 --> 07:28.920
I hope this is making sense to everyone.

07:29.550 --> 07:30.570
Now what is the next part?

07:32.920 --> 07:34.480
That means if it is not.

07:35.490 --> 07:39.660
Less than saying that means it has to be the greater than saying if it is a greater than saying, then

07:39.660 --> 07:40.320
what does it mean?

07:41.160 --> 07:45.660
I have to place all the elements which are smaller than the previous element now because I know we have

07:45.660 --> 07:52.140
this st whatever is placed in, I have to place the elements which are in the set as they the its place.

07:52.140 --> 07:53.790
All the elements of S1 by one.

07:55.950 --> 07:57.000
They will start from one.

07:57.000 --> 08:00.900
They will go to less and the other plastic.

08:00.940 --> 08:01.290
Okay.

08:01.650 --> 08:02.280
So this is going.

08:02.700 --> 08:03.570
It is this part.

08:04.080 --> 08:08.430
Now, guys, how many elements this smaller than this element in this smaller set?

08:08.460 --> 08:08.790
No, no.

08:08.790 --> 08:10.260
We are worried about this smaller lizard.

08:10.260 --> 08:13.850
We are placing elements in this seven by one eight.

08:14.010 --> 08:15.330
So how many elements is smaller?

08:15.930 --> 08:17.310
It is equal to j minus one.

08:18.120 --> 08:21.390
Could not be confused in this that j minus one elements are smaller.

08:22.290 --> 08:25.110
If I am placing the jet element in this one, it.

08:26.080 --> 08:27.160
Full moon policing.

08:27.160 --> 08:31.090
The second element one element is smaller than the right and how many elements are great as a G are

08:31.090 --> 08:33.070
already greater, he said.

08:33.100 --> 08:34.210
These are already greater.

08:35.380 --> 08:35.650
Harm.

08:35.980 --> 08:40.630
The remaining elements in such as will also be greater, which is equal to minus.

08:45.070 --> 08:46.210
I hope this is correct.

08:46.420 --> 08:48.520
If Jay-Z goes to London, what does.

08:50.640 --> 08:55.410
It means that how many elements are greater than the current element do you will already be greater

08:55.410 --> 08:59.010
end s minus D elements will also be at its correct.

08:59.760 --> 09:00.910
I hope you're getting this case.

09:01.290 --> 09:03.180
It shouldn't be that tough to understand.

09:04.290 --> 09:04.520
Well.

09:04.920 --> 09:07.980
And finally it and the answer and what is the basis?

09:08.010 --> 09:11.880
The risk is well, it would be very simple if I if I placed all the elements.

09:13.030 --> 09:13.360
Right.

09:13.780 --> 09:15.040
It's a moment of time.

09:15.100 --> 09:15.910
You can be zero.

09:15.910 --> 09:17.530
Some movement of them as can be zero.

09:17.560 --> 09:19.630
Then of course, this equation won't move forward.

09:20.380 --> 09:21.610
So we're ending a loop from one.

09:22.000 --> 09:26.290
If they are equal to zero, that means there are no elements that can be placed at the particular location.

09:26.590 --> 09:27.460
It will just go back.

09:28.780 --> 09:32.950
If I placed all the elements, that means I have these the last location.

09:32.950 --> 09:34.240
That means ice equals to it.

09:34.510 --> 09:38.200
That means I need all the elements from I goes to zero.

09:38.200 --> 09:43.720
Do I go through and minus one if I is equals to an item bladed on one that yes, I found to be this.

09:43.720 --> 09:44.200
Will this.

09:46.000 --> 09:46.480
Okay.

09:50.960 --> 09:51.690
There is a problem.

09:51.750 --> 09:53.490
Okay, so it is a string.

09:55.870 --> 09:56.350
I read.

09:57.940 --> 09:58.100
Well.

09:58.190 --> 10:00.400
So here you can see we've got five, eight.

10:00.400 --> 10:01.750
So how are we getting five?

10:01.990 --> 10:05.380
Because we are trying to place all the elements one by one, not all the elements.

10:05.740 --> 10:11.860
The elements add that insert this audience there because we don't want actually that we don't we don't

10:11.860 --> 10:13.840
care about what actually those elements are.

10:13.840 --> 10:14.590
We just want that.

10:14.590 --> 10:16.780
Okay, these are the elements smaller than the current element.

10:16.780 --> 10:21.520
These are the elements that greater than the previous element and place them one by one according to

10:21.520 --> 10:22.000
the things.

10:23.390 --> 10:25.550
Well and we are passing this and so on.

10:26.090 --> 10:26.540
Here goes.

10:26.540 --> 10:27.170
You can't.

10:27.260 --> 10:30.890
You have to understand this important concept of independent variables.

10:30.890 --> 10:34.550
Independent, independent variables which we might have already seen.

10:35.060 --> 10:35.310
Right.

10:35.660 --> 10:40.490
So before moving on to the complexity of this solution, I want to discuss that.

10:41.470 --> 10:41.760
Okay.

10:41.790 --> 10:42.090
Okay.

10:42.100 --> 10:46.390
Let's move on to the complexity of this that I know we can begin to see that we have just written a

10:46.390 --> 10:47.590
recursive approach here.

10:47.590 --> 10:54.040
We have how many states I cross as cross g i is mn s can also be in and you can also be in.

10:54.040 --> 10:57.370
So this is an new type of solution if I memorized.

10:59.410 --> 10:59.590
Eight.

10:59.930 --> 11:00.670
The memo is it.

11:00.670 --> 11:02.760
What I need is I need a Ncube type of thing.

11:02.770 --> 11:06.850
So let's let's build this solution for a bigger desk.

11:06.850 --> 11:07.510
Is this one?

11:08.620 --> 11:08.980
Bobby.

11:11.550 --> 11:13.440
Well, and let's.

11:15.500 --> 11:15.740
Okay.

11:16.120 --> 11:17.450
Let's try to memorize this.

11:17.450 --> 11:20.720
Let's call it 25, 25, 25 and.

11:22.260 --> 11:25.200
I'm just doing a normal memorization, not a heavy stuff.

11:26.640 --> 11:29.430
Memo minus one size of memo.

11:30.000 --> 11:33.690
Just I just want to find out whether I'm getting a correct answer or not.

11:34.100 --> 11:41.470
Well, it's make changes that we use through a memo, i.e., s e.

11:43.100 --> 11:45.710
If answer is not your luminous wonder, don't answer.

11:48.930 --> 11:56.940
Megan's request was zero and the calculation and we it this so that the number of ways in which I can

11:56.940 --> 11:58.080
satisfy this condition.

11:59.450 --> 12:02.100
Isn't it amazing that there are so many number of ways possible?

12:02.120 --> 12:04.460
These are actually huge number of ways possible.

12:04.730 --> 12:07.460
Well, I just wondered, it's 1 to 28.

12:07.970 --> 12:12.080
So of course, some of you might be wondering that I'm not getting the correct answer, but it's correct

12:12.620 --> 12:13.130
answer answers.

12:13.580 --> 12:14.870
I've just not taken model.

12:15.130 --> 12:23.780
So let's be considering digit called modulo which is one in nine plus seven and it's print answer modulo.

12:26.440 --> 12:29.980
So what I have is 217136217136290.

12:29.980 --> 12:30.370
Correct.

12:31.600 --> 12:35.410
So this is a brute force audition and I'm amazed at what is a complexity and cue.

12:37.030 --> 12:37.250
Eight.

12:39.690 --> 12:41.090
Go and cover this state.

12:41.800 --> 12:44.880
It goes and cover the states, but not the complexity.

12:45.870 --> 12:47.960
And Cuba, this statement incited this.

12:47.970 --> 12:53.160
I'm actually using a far loop of land and in the worst case you can be in as can be.

12:53.160 --> 12:58.170
And in the worst case, that means what is the total complexity of this solution including the loops

12:58.170 --> 13:01.470
inside the new were the total number of.

13:02.770 --> 13:06.430
States in the end, because we are doing a calculation of.

13:08.060 --> 13:08.630
Enzymes.

13:09.230 --> 13:11.420
So let me erase this page because it's.

13:12.400 --> 13:15.280
It has become a huge village and it's taking a lot of.

13:16.550 --> 13:17.360
Memory and time.

13:19.030 --> 13:19.840
Just give me a second.

13:20.820 --> 13:23.820
Well, so the page has been erased and now it won't hang.

13:25.930 --> 13:26.240
Yep.

13:26.410 --> 13:27.340
So where were we?

13:27.520 --> 13:28.240
We were here.

13:28.270 --> 13:28.930
Yeah, that.

13:30.440 --> 13:35.360
The tourist states that NQ which is a cross-currency rate because they are indigenous.

13:36.080 --> 13:43.300
But though we were having one more often for loop incited hate which is which really gave me and or

13:43.310 --> 13:46.210
the complexity of ending the power for hate.

13:46.750 --> 13:47.860
Here's a concept that I want to.

13:50.220 --> 13:53.790
Tell you that again in this ISG, we know that.

13:55.370 --> 14:02.910
Sandy are kind of dependent variables on I think if I see their GS equals two so I already explained

14:03.030 --> 14:05.750
it as produce equals to n minus I.

14:06.720 --> 14:15.180
That means instead of passing G, I can easily derived you by using n minus i.e. minus s.

14:18.810 --> 14:19.120
Eight.

14:19.890 --> 14:22.030
That means I don't need to Pazzi.

14:22.500 --> 14:24.000
That means I can erase you here.

14:24.660 --> 14:25.680
And I can simply.

14:26.010 --> 14:26.340
Let's.

14:26.340 --> 14:26.880
Let's erase.

14:27.630 --> 14:28.980
Because we don't have to pass this.

14:28.980 --> 14:32.130
We don't need this variable because this is easily derivable from.

14:33.800 --> 14:38.810
S And I hate and let's let me also remove this from this location.

14:38.960 --> 14:42.010
And what I do is I simply say because I am using the audio.

14:42.020 --> 14:43.670
So what else is that?

14:43.670 --> 14:49.820
INT is equal to and minus A minus s because we know what it is.

14:50.180 --> 14:54.050
So here at the pass s or pass E, we don't have to parse both the variables.

14:55.080 --> 14:55.370
Cool.

14:55.550 --> 14:56.000
So let's.

14:57.580 --> 14:59.200
It will be destroyed during its period.

15:00.120 --> 15:00.280
Well.

15:00.390 --> 15:02.310
So again, they really get the same answer.

15:02.310 --> 15:03.600
Why am I getting the same answer?

15:03.600 --> 15:06.180
Because I don't have to.

15:06.600 --> 15:07.560
Kind of memories.

15:07.560 --> 15:16.320
Gee, because since you are in dependent variable rate and and then I can pass is Oregon buzzy because

15:16.320 --> 15:20.780
the second variable can be derived from the other variable which is reimbursement.

15:20.850 --> 15:22.950
These two are the independent variables.

15:23.250 --> 15:27.030
So if I only know, I define only know as then I cannot derive it.

15:27.810 --> 15:28.070
Right.

15:28.290 --> 15:29.640
So these are the independent variables.

15:29.640 --> 15:33.090
I need to parse them all, but this can be derived.

15:34.290 --> 15:35.760
Also, I'm getting the same answer nowadays.

15:35.760 --> 15:37.290
What is the complexity of the solution?

15:37.980 --> 15:40.080
As again we have and squared states.

15:41.080 --> 15:42.340
Esquire are these states.

15:42.340 --> 15:42.940
But we have.

15:44.110 --> 15:47.080
Often calculation inside that is these loops.

15:48.210 --> 15:52.170
So if you have a calculation inside, that means what is the total complexity of and.

15:52.170 --> 15:54.180
Q So let's see the constraints.

15:55.610 --> 15:56.900
The constraint is 3000.

15:57.500 --> 16:01.070
But will this approach work and Q approach?

16:01.610 --> 16:01.940
No.

16:01.940 --> 16:02.840
Still still.

16:02.840 --> 16:05.620
We need to optimize this for the rate.

16:06.020 --> 16:07.100
But often you will not.

16:07.100 --> 16:07.870
Google will give me that.

16:07.880 --> 16:08.260
Really.

16:08.300 --> 16:11.690
You can look and see if the code and you can try it yourself.

16:12.940 --> 16:13.210
Well.

16:14.060 --> 16:17.060
And save the gold later and then you can try the school yourself.

16:19.610 --> 16:21.860
Did you get this going in the description session?

16:23.100 --> 16:25.350
There's an end queue approach and this will not work.

16:25.710 --> 16:28.980
What we what we need to do is we need to further optimise it.

16:28.980 --> 16:34.100
So let me hear you let me give you a hint, because in the next video, I will be using their talent

16:34.110 --> 16:35.490
and solving the problem.

16:36.030 --> 16:42.430
So you know that we used this we did this problem candies in which what we did was we saw that the recording

16:42.450 --> 16:48.090
solution that we did, I was actually depending on how we fix some of the previous row of the DPD.

16:49.070 --> 16:50.700
But what we did was instead of.

16:51.760 --> 16:57.610
Going over these cells one by one, we took the prefix some of the above group, and by using the prefix

16:57.610 --> 17:00.010
then we were easily able to calculate the look.

17:00.010 --> 17:02.550
In this much part, we need eight here.

17:02.660 --> 17:06.880
And so what you will notice is that we're okay here.

17:07.950 --> 17:13.350
You know, you'll notice if you write this out and if your takes on values, you'll notice that this

17:13.350 --> 17:14.460
is kind of a prefix.

17:14.460 --> 17:14.990
Someone like.

17:16.400 --> 17:16.600
Hey.

17:16.730 --> 17:17.570
Because let's see.

17:18.050 --> 17:18.410
Okay.

17:18.680 --> 17:19.970
Let's do it in the next recording.
