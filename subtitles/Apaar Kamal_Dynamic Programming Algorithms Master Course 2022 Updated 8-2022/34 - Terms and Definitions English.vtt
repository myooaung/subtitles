WEBVTT

00:00.700 --> 00:01.390
Everyone.

00:01.450 --> 00:03.400
Welcome to the dining programming section.

00:04.000 --> 00:08.830
In this section, we'll understand how to solve our dynamic programming problem.

00:08.830 --> 00:09.090
Right?

00:09.100 --> 00:12.520
So before that, we'll see what are the new programming problems.

00:13.120 --> 00:19.960
And of course, we'll start from the basics because we have all types of students here and start from

00:19.960 --> 00:22.170
very basic and we'll go till very advance.

00:22.240 --> 00:22.530
Okay.

00:22.750 --> 00:28.630
And what I believe is that in dynamic programming, you do not need much to iterate.

00:28.630 --> 00:31.900
Of course to it is important, but only to one do the part.

00:32.380 --> 00:40.510
So I have decided to call these 26 problems from at Coder Education and Dynamic Programming Contest

00:41.020 --> 00:43.210
to resolve all these problems one by one.

00:43.480 --> 00:47.890
And these problems like contains different types of dynamic programming.

00:49.110 --> 00:50.190
Tony's dead at eight.

00:50.580 --> 00:53.030
So they will be accommodating in all these problems.

00:53.040 --> 00:59.490
That would be a regressive relation and will solve this problem when it has all types of difficulty

00:59.490 --> 01:01.410
levels and different types of solutions.

01:02.310 --> 01:10.620
And also, I tried to go all these problems in both the ways I will solve the problems, in both the

01:10.620 --> 01:13.650
tabulation form and the memorization form.

01:13.780 --> 01:16.950
They will try to bottom up and top down approach, basically.

01:17.430 --> 01:19.110
First of all, let us understand these terms.

01:19.110 --> 01:26.250
Bottom up, top down tabulation, memorization and optimal substructure and other state.

01:27.270 --> 01:32.430
So let's come back and let's start with the basic introduction to dynamic programming.

01:33.660 --> 01:39.270
In dynamic programming, what happens if these types of problems are those problems which involve maximizing

01:39.270 --> 01:42.660
or minimizing some particular subsets?

01:42.660 --> 01:42.960
Right.

01:43.350 --> 01:45.480
It's like you have all these options.

01:45.870 --> 01:47.490
Which option is the best one?

01:47.700 --> 01:48.990
Tell me which is the best option?

01:48.990 --> 01:53.050
Basically, out of all the options, we have to choose the best option and redundancy.

01:54.240 --> 02:00.780
And also, yeah, so there will be steps when we solve all these dynamic programming problems.

02:01.020 --> 02:04.020
So I think 26 really good problems are more than enough.

02:04.260 --> 02:09.000
If you want to understand what is any programming and how does it work.

02:09.240 --> 02:13.890
So the term taking all these problems and moment the first step is what we'll do is will form.

02:15.920 --> 02:16.700
Former state.

02:18.810 --> 02:22.950
Forming a state is the most important part in any dynamic programming problem.

02:23.430 --> 02:24.690
You should have a state aid.

02:25.290 --> 02:32.970
What's a state will generally define it as F of some variables a x, y, commas and and so on.

02:33.390 --> 02:34.670
It can be many, right?

02:34.680 --> 02:39.630
If it is F of x only that means it's a one dimensional d b because only one variable is there.

02:40.110 --> 02:46.530
If it is f of x comma y, then it's actually d b because there are two variable states for each F of

02:46.530 --> 02:48.960
x, comma, y, common z and all x.

02:49.110 --> 02:51.030
X, y and z are independent variables.

02:51.030 --> 02:54.660
They do not depend on each other and it's a 3D, DP and so on.

02:54.990 --> 02:57.760
So we can have multi dimensional APIs engaged.

02:57.840 --> 02:58.200
Yes.

02:58.200 --> 03:06.000
In this dynamic programming playlist we can see, I firstly will understand what is AP will understand

03:06.000 --> 03:11.160
some basic terms of DP, then we'll simply move on to solve all the solving all those 26 problems.

03:11.540 --> 03:16.350
After solving those problems, you'll get a good idea of what is done with programming and where it

03:16.350 --> 03:18.090
can be used after the.

03:19.080 --> 03:22.740
Will like solve some classical problems.

03:23.040 --> 03:25.500
Are there ways you can solve the classical problems yourself?

03:25.500 --> 03:27.480
Because those really six problems are really good.

03:28.950 --> 03:29.880
And yeah.

03:30.150 --> 03:35.380
So after that we'll move on to some starting topics are dynamically rhyming like if you will musk eight

03:35.400 --> 03:40.170
and as always dip into the stocks which are a little advanced part.

03:40.170 --> 03:43.950
But yes we'll start with the basic introduction really be and some easy problems.

03:44.570 --> 03:49.130
So the first step to solving our dynamic programming problem is to form a state, right?

03:49.140 --> 03:53.310
So here we are forming a state which is F of X, comma, right, comma, something.

03:53.940 --> 03:54.190
Right.

03:54.660 --> 03:56.340
And the second step will be.

03:57.670 --> 04:06.130
It's like finding the recursive relation that if I were state of F of something and that state is dependent

04:06.130 --> 04:12.280
on how many state or if it is dependent on some limited number of states, then how is a dependent?

04:12.760 --> 04:17.530
Is it a summation of all the state or a multiplication of all the state or minimum of all the states?

04:18.370 --> 04:19.060
The second is.

04:20.830 --> 04:22.720
Forming a recursive relation.

04:23.690 --> 04:29.180
By recursive because f of something we call f of something on the rate only the variables will change.

04:29.210 --> 04:30.050
I'll give you an example.

04:30.050 --> 04:30.650
Do not worry.

04:31.190 --> 04:32.480
Forming a recursive relation.

04:32.480 --> 04:32.960
So these.

04:34.190 --> 04:37.880
These three pots will be common in all the dining room programming problems.

04:38.390 --> 04:44.390
Generally, dynamic programming is actually optimizing a recursive relation, basically, so we have

04:44.390 --> 04:45.080
to optimize it.

04:45.080 --> 04:47.810
It goes evolution by using some different tips and tricks.

04:48.730 --> 04:49.000
Well.

04:50.000 --> 04:51.780
The green is forming a recursive relation.

04:51.790 --> 04:56.490
For example, the basic example that we always take is the Fibonacci numbers example.

04:57.400 --> 05:01.420
Even a number eight, which is how we love it.

05:01.420 --> 05:03.610
When I see this define it, it often is.

05:03.610 --> 05:05.800
It goes to F and minus one.

05:05.860 --> 05:08.170
Plus and minus two.

05:09.340 --> 05:09.640
Eight.

05:09.940 --> 05:12.700
As you can see, this is a state, but it is a state event.

05:12.730 --> 05:14.140
So how will it define this state?

05:14.560 --> 05:19.270
It f often is equal to f of represents the end event number.

05:20.700 --> 05:23.070
So this is that normal definition of a state.

05:23.430 --> 05:25.260
Sometimes it can be F of IED.

05:25.260 --> 05:30.270
Rated F of IED represents something in terms of eye injury.

05:32.890 --> 05:37.270
The second step was forming a regressive religion that often is equals to a friend minus one.

05:37.270 --> 05:39.850
Plus if a friend minus two normal people taking the right.

05:41.190 --> 05:44.750
So this part, guys, this part is called the second part.

05:44.760 --> 05:45.870
It is also called.

05:50.460 --> 05:51.150
Optimal.

05:52.400 --> 05:53.150
Substructure.

05:57.050 --> 05:57.380
Right.

05:57.490 --> 05:59.220
So what does obtuse obstructive mean for this?

05:59.240 --> 06:00.080
Optimal means.

06:00.320 --> 06:02.270
Optimal means not less.

06:02.270 --> 06:04.870
Not more like optimum rate.

06:05.510 --> 06:11.110
So here you can easily see that if I were to find a reconciliation which is f often is equal to F off

06:11.120 --> 06:15.920
and minus one plus and minus two, then only these two terms are needed.

06:15.920 --> 06:16.220
Right?

06:16.490 --> 06:20.410
I'm not finding any third dummy here and not doing anything with it.

06:20.420 --> 06:26.100
So I'm not taking some extra items and I'm not taking and I'm also including the terms that I need.

06:26.120 --> 06:28.310
So it's not minimum and it's not maximum.

06:28.310 --> 06:31.490
It's optimal only the things that we need.

06:31.490 --> 06:33.650
We are not performing any extra work here.

06:33.680 --> 06:38.600
We are only going over two back notes, not three back notes or four back notes.

06:38.600 --> 06:43.310
So that's my optimal where reduce do we should have an optimal recursive relation and.

06:44.940 --> 06:48.450
Substructure or it's also called sub problem optimizer problems.

06:48.660 --> 06:53.430
So that's not tough to understand because f of endurance over and minus when and if or when.

06:53.430 --> 07:02.110
Minus two similarly goes above and minus will be dependent on F4 and minus two and f7 minus three eight.

07:02.490 --> 07:06.240
That's what substructure or sub problem means that I have a problem.

07:06.240 --> 07:07.560
It's divided into sub problem.

07:07.770 --> 07:12.540
Then that's a problem is itself a problem and it is further divided into a problems.

07:12.920 --> 07:17.100
I'm just giving you a basic example of even taking a let's say I want to find out Fibonacci number of

07:17.100 --> 07:17.520
six.

07:18.360 --> 07:22.590
This is dependent of a four, five and also four four.

07:23.250 --> 07:27.960
Now if a five is dependent on F of four because 945 is again itself a problem.

07:28.930 --> 07:31.870
Right now after four days of three and F of two.

07:33.220 --> 07:35.620
Now if a food is dependent over an F of three.

07:37.020 --> 07:37.880
And if do.

07:38.590 --> 07:44.700
Right now I just want you to understand these optimum substructure and because I overlapping some problems

07:44.850 --> 07:49.140
two days that are overlapping the problems I explained you do not worry.

07:49.970 --> 07:51.280
And yeah.

07:51.290 --> 07:52.730
F of doing it for fun.

07:54.020 --> 07:55.790
Because I'll be using those terms again and again.

07:55.790 --> 07:57.050
So I want you to understand them.

07:57.650 --> 07:59.000
So we don't know.

07:59.270 --> 08:01.370
So we know what is F of one and F of the.

08:02.180 --> 08:04.400
So what are F1 and F2?

08:04.730 --> 08:06.230
These will be called base cases.

08:07.070 --> 08:09.500
Base cases that means these are not a problem.

08:09.740 --> 08:10.940
I know are solutions.

08:11.180 --> 08:17.930
So if I know what F1 an EV of two represents, I do not have to divide it into further recursive relations

08:17.990 --> 08:19.970
because I simply have those answers.

08:20.330 --> 08:23.720
It's f of three is F of two and f of.

08:24.480 --> 08:25.590
But I.

08:26.680 --> 08:32.380
But you can easily see that all the lymph nodes in this tree f2, f1, F2, two, two, one, two,

08:32.380 --> 08:33.610
one and two, eight.

08:33.670 --> 08:39.190
All these are the best cases because they cannot be further divided on, as I know did, values.

08:39.550 --> 08:42.190
So for F1 number four, students are one and one.

08:43.030 --> 08:43.660
What happens?

08:44.510 --> 08:44.810
It.

08:46.810 --> 08:47.040
Great.

08:47.830 --> 08:53.410
Everyone is one and f off who is also one for you guys.

08:53.440 --> 08:56.560
So I hope you understood what is optimal substructure.

08:57.220 --> 09:01.720
I'm not making a third call here to f off one here and not using it.

09:02.380 --> 09:03.430
So it should be optimal.

09:03.430 --> 09:04.270
It should not be more.

09:04.270 --> 09:05.140
It should not be less.

09:05.980 --> 09:07.660
It should contain all the things that I need.

09:08.830 --> 09:10.300
Great going on.

09:10.360 --> 09:11.680
Let's move on to the third point.

09:11.870 --> 09:17.950
So always remember, I will only be performing these three steps again and again in all the 26 problems.

09:18.580 --> 09:18.850
Eight.

09:20.000 --> 09:23.570
This is kind of a definition video basically for dynamic programming.

09:24.170 --> 09:24.410
Yeah.

09:24.920 --> 09:25.850
What's the third part?

09:26.980 --> 09:28.180
Third party is called.

09:29.430 --> 09:32.880
Memorisation or tabulation or overlapping set problems.

09:33.330 --> 09:35.370
It's a little overlapping of problems.

09:41.630 --> 09:43.280
I'll just put something out.

09:43.280 --> 09:44.280
And you understand this?

09:44.300 --> 09:44.900
No, not very.

09:45.530 --> 09:45.800
Yeah.

09:45.950 --> 09:50.180
So we have overlapping some problems and programming mean what is overlapping is a problem.

09:50.180 --> 09:53.720
I mean, if I want to calculate F for for.

09:57.150 --> 10:02.550
Eight in f6fa Ford has been calling it an F for food is also being called L.

10:04.100 --> 10:07.400
So it means that if you're going to look for.

10:08.930 --> 10:09.560
Is being.

10:11.220 --> 10:16.160
Is being like found once it is being found once.

10:16.170 --> 10:21.750
If it is, I am going in the subtree of apple foothill then I do not need to go in the subtree over

10:21.750 --> 10:26.010
for Foothill Fire because I have already found out what is there for food which is forbidden.

10:26.010 --> 10:28.470
Like you would have already found it out.

10:28.770 --> 10:33.540
And why should I calculated again by showing that I was in all this subtree and go to the base cases

10:33.540 --> 10:35.460
and then add them and come back.

10:36.330 --> 10:36.990
I can't do that.

10:36.990 --> 10:37.260
Right.

10:37.890 --> 10:42.150
But that's what overlapping problems mean, that these two problems are overlapping.

10:42.180 --> 10:43.440
They are the same problems.

10:44.190 --> 10:44.490
Eight.

10:45.470 --> 10:49.220
You don't understand more about this when we will be solving knapsack problem.

10:50.140 --> 10:50.680
Also.

10:50.890 --> 10:54.520
Yeah, I called it out a little bit and then you'll understand this in more detail.

10:55.600 --> 10:56.380
What is overlapping?

10:56.380 --> 10:57.300
Some problems, guys.

10:58.180 --> 11:02.500
Overlapping some problems mean that there are some problems which are repeating.

11:02.770 --> 11:04.840
If they're repeating, don't calculate them again.

11:06.190 --> 11:07.060
Find them once.

11:07.180 --> 11:07.930
Store them.

11:08.750 --> 11:12.880
And when the next call is being done on them, the same plate, then the venue.

11:13.460 --> 11:13.680
Right.

11:14.150 --> 11:18.020
So in the third party, we have overlapping some problems, repeating the problem.

11:18.410 --> 11:20.490
So how to solve these regarding the problems?

11:20.510 --> 11:21.500
There are two approaches.

11:21.920 --> 11:23.630
The first is called tabulation.

11:25.300 --> 11:26.560
And the second is called.

11:27.590 --> 11:28.340
Memorization.

11:32.590 --> 11:32.860
Eight.

11:33.520 --> 11:36.350
What are the differences between tabulation and memorization?

11:38.610 --> 11:40.700
Tabulation is a stable format.

11:40.890 --> 11:42.060
So we have a table.

11:42.060 --> 11:47.190
We have already have a static table, fig side, fixed base table fixes.

11:48.660 --> 11:49.090
30.

11:51.850 --> 11:52.930
And we are filling it.

11:53.320 --> 11:57.660
We are filling the rows and columns offered by using the rows and columns which are already being filled.

11:58.690 --> 12:00.010
And what is memorization based?

12:00.370 --> 12:05.230
Memorization is that if you have calculated it once and if I'm going on it again.

12:05.260 --> 12:10.930
So in tabulation, we cannot go to any state again because it's like a table in a table.

12:10.930 --> 12:16.960
All the cells that you need grade, I imagine are unique in a table eight because we will be moving

12:16.960 --> 12:21.300
like for new ways provides again and will move to all the columns one by one.

12:21.310 --> 12:21.640
So.

12:22.790 --> 12:26.650
We will not go to any state twice in abolition.

12:28.090 --> 12:30.460
Not go to any state.

12:34.260 --> 12:34.530
Eight.

12:35.500 --> 12:42.100
But in memorisation we know because we are forming a recursive relation we will write adequacy function

12:42.100 --> 12:43.280
that goes in function.

12:43.810 --> 12:44.980
Let's talk about this.

12:45.250 --> 12:50.680
We'll call F of six, F of six will call for five, then a four for F, I will then again call for four

12:50.680 --> 12:51.400
and F of three.

12:51.880 --> 12:54.610
So here we can see f what is being what do I use?

12:55.030 --> 12:55.360
Right.

12:55.960 --> 13:01.960
So to avoid calculation twice, to avoid all these recursive functions.

13:02.470 --> 13:02.860
Right.

13:02.920 --> 13:04.360
And what we'll do is we'll simply.

13:05.970 --> 13:06.930
Use memorization.

13:07.200 --> 13:12.030
That means it's kind of like visit your dad if you've already visited it and don't visit it again.

13:13.320 --> 13:14.070
So it is.

13:15.790 --> 13:17.130
Saving and.

13:18.030 --> 13:18.630
Be using.

13:22.650 --> 13:28.140
So here we have a memo pegged to what's a memo, but it's a you can dig a map.

13:28.140 --> 13:30.210
You can dig up any whatever you want.

13:30.810 --> 13:35.070
So we'll fill that area or that map with something, which is.

13:36.080 --> 13:36.650
I know.

13:37.700 --> 13:39.000
Not in the answer, right?

13:39.260 --> 13:43.880
If I want to find out when I economist, I'll fill it with minus them and completely fill the whole

13:43.880 --> 13:48.260
area with minus one initially because a minus one will means it's not visited.

13:48.260 --> 13:52.550
I've never been to the state, but once that seed has been calculated, I simply.

13:53.620 --> 13:54.730
Apply memorization.

13:56.060 --> 13:58.170
That means I simply store their doubts in the memo.

13:58.640 --> 14:03.050
So when the next time I come to the Articles of Reconciliation, I simply check that if the answer has

14:03.050 --> 14:07.820
been regularly in the memo where that means if the memo of that particular end is article two minus

14:07.820 --> 14:12.800
one completed because I've already calculated it and saved it would.

14:13.740 --> 14:15.750
That's about my musician in the next.

14:17.200 --> 14:17.830
Very well.

14:18.790 --> 14:21.020
Like Ford boat the best ever.

14:21.040 --> 14:21.360
Yeah.

14:21.400 --> 14:23.860
So I have those 26 eight quarter problems.

14:24.250 --> 14:28.510
I got all these problems both ways by using tabulation and memorization, but.

14:29.440 --> 14:29.910
Always.

14:31.040 --> 14:31.400
And.

14:32.630 --> 14:32.960
Great.

14:33.290 --> 14:36.950
Then the next part will understand what is how to.

14:38.560 --> 14:42.070
Differentiate between tabulation and memorization in detail.

14:42.520 --> 14:45.600
It will and grace in the next five.
