WEBVTT

00:00.830 --> 00:01.390
Well, guys.

00:01.400 --> 00:04.520
So this was in the previous video we discussed about.

00:05.470 --> 00:06.970
Finally Exponentials normal.

00:07.090 --> 00:10.450
Now let's discuss about modular exponential.

00:10.450 --> 00:13.990
So again, it's a binary exponential only, but under what conditions?

00:14.500 --> 00:15.520
What is a mod, guys?

00:15.820 --> 00:17.200
What does mod means?

00:17.710 --> 00:18.880
It's a reminder, right?

00:18.880 --> 00:22.600
So if I say ten more seven, is it.

00:22.960 --> 00:23.230
Okay.

00:23.230 --> 00:25.090
Generally what happens is that.

00:29.510 --> 00:33.560
The answers for some certain and for some certain problems are huge.

00:34.550 --> 00:37.460
If those answers are very huge, then what does compiler do that?

00:37.670 --> 00:44.180
Of course, those answers cannot be calculated very easily because that will of course require a lot

00:44.180 --> 00:48.290
of space and lot of time to be calculated, not lots of fast operations.

00:49.640 --> 00:52.880
So what is the problem center do?

00:53.000 --> 00:53.810
What does they do?

00:53.810 --> 01:00.470
They say, okay, give me the answer by taking modulo with some prime number by marloes with prime numbers

01:00.470 --> 01:06.410
because I leave it to you only find it out why we use multiple prime numbers.

01:06.440 --> 01:10.540
I go over to the cryptography section over the internet.

01:10.550 --> 01:13.020
Just search forwarding tick that.

01:13.040 --> 01:14.810
Why do we always consider prime numbers?

01:14.810 --> 01:19.250
Because there are lots of two items which are only applicable to prime numbers eight.

01:19.670 --> 01:19.970
So.

01:21.170 --> 01:23.390
Like 4 minutes later, the two of them and others do.

01:24.290 --> 01:24.510
Well.

01:24.560 --> 01:29.990
So what does he do is he says, okay, give me Ritalin mode, Rite Aid by taking a break.

01:30.290 --> 01:33.260
Generally, guys, this frame is going to devour 9 to 7.

01:33.260 --> 01:34.820
You might have seen it somewhere.

01:35.240 --> 01:36.280
Eight other.

01:36.290 --> 01:37.510
Okay, he says Give me more.

01:38.180 --> 01:41.600
Because we all know about modular arithmetic operations.

01:41.930 --> 01:45.440
They have to perform addition subtraction, multiplication and division using.

01:46.610 --> 01:49.820
So that is already being discussed in the mathematics section.

01:51.110 --> 01:51.350
So.

01:52.310 --> 02:00.230
Here we will understand how to find out binary how to do this by the exponent intuition and the modulus

02:00.230 --> 02:00.490
rate.

02:00.500 --> 02:02.990
So let's see if I want to find out the power.

02:04.580 --> 02:07.730
This is a pretty huge so little to devour.

02:08.900 --> 02:11.850
So, again, guys, this this value is still huge, right?

02:11.880 --> 02:13.040
Because due to the power.

02:15.030 --> 02:20.500
Export is like around ten to about 18, which can be stored in C++, a long, long eight.

02:20.880 --> 02:24.390
But so this is around ten to the power 98.

02:24.690 --> 02:24.990
So.

02:25.920 --> 02:28.440
But to do about 100 will be a huge value, right?

02:29.160 --> 02:30.300
We won't be able to distort it.

02:30.660 --> 02:35.730
But still, if I want to calculate, if I want to find out how it is, what is true to the power 100

02:35.730 --> 02:42.960
and under some models statements eight you give me two to the power hundred with some models.

02:43.590 --> 02:44.760
Let's dig more with some.

02:45.510 --> 02:46.710
Let's call it integer mode.

02:47.310 --> 02:50.250
So how will I do it using binary x1 intuition?

02:50.850 --> 02:51.370
Very easy.

02:51.390 --> 02:52.080
Is it?

02:53.160 --> 02:57.260
So we all know that if I'm multiplying sum into V and I want to perform.

02:57.270 --> 02:57.540
What?

02:58.750 --> 03:03.580
There is less in models and we use less than models.

03:03.880 --> 03:06.220
Then this becomes a mode.

03:07.580 --> 03:09.440
So this becomes a.

03:11.380 --> 03:13.750
And to be smart.

03:14.890 --> 03:23.450
If I want to calculate this particular part, then it becomes like a mod mod into the mod mod, right?

03:23.560 --> 03:24.550
And whole smart.

03:25.700 --> 03:29.840
It's been multiplied to integers which are less demand and multiplying.

03:29.840 --> 03:31.960
Take more, so I just multiply them and dig them out.

03:31.960 --> 03:32.240
Right.

03:32.810 --> 03:34.880
So similarly goes for additional.

03:34.880 --> 03:36.770
So we do the same same stuff.

03:38.330 --> 03:39.560
But that's not my point.

03:40.130 --> 03:44.030
What I want to explain to you is that how is binary x1 intuition being done?

03:44.750 --> 03:48.570
If I write it, let's say I'm finding in the in the way.

03:51.180 --> 03:55.450
One, two, three, four, five, six, seven, eight, nine, ten, 11, 11 times.

03:55.850 --> 03:57.540
The heart is by an excellent intuition work.

03:57.930 --> 04:04.290
It will take this money late, then it will take this to is to get there.

04:04.290 --> 04:05.460
And then it will take this.

04:07.130 --> 04:07.680
It is true.

04:07.680 --> 04:12.900
Whether that is true to the power to the power to interpret the power, one will be able to read the

04:12.950 --> 04:14.270
power level.

04:15.110 --> 04:15.650
Hey, guys.

04:16.460 --> 04:16.760
So.

04:17.790 --> 04:19.020
Let's get back to the code.

04:19.510 --> 04:24.840
What happens here is I always multiply in the resultant and then I see is it goes to a square.

04:25.410 --> 04:31.020
What I want is I want all these values to be less than ten to the power, nine plus seven.

04:31.230 --> 04:34.080
And I always want to keep them less than ten to the one number seven.

04:34.080 --> 04:35.070
So how will I do that?

04:35.700 --> 04:40.230
Very simple case, because as you can see, there's only one multiplication operation happening here.

04:40.590 --> 04:45.660
That means if let's say they're doing this around ten to the overnight rate and is also going to the

04:45.660 --> 04:47.340
power and I would have nine lines.

04:47.340 --> 04:49.830
And if I multiply them, both of them will have 18 length.

04:50.610 --> 04:54.870
That particular length over time can be stored in long, long integer eight.

04:54.990 --> 04:59.120
Similarly, guys, this can also be stored in long long integer eight.

04:59.490 --> 05:04.710
But after calculating both these values, what I'll do is I simply take what I just reduce the values

05:05.040 --> 05:06.210
less than ten to the power.

05:06.210 --> 05:07.440
Nine plus seven.

05:07.440 --> 05:08.880
I just take a mode.

05:09.740 --> 05:12.230
To facilitate me, see if this could.

05:13.520 --> 05:14.150
Finally.

05:19.290 --> 05:22.680
And now it's the new cold.

05:23.220 --> 05:23.460
Yeah.

05:23.920 --> 05:30.660
So here, what we'll do is we'll simply do a modular exponential rate so far that let's take on standard

05:30.660 --> 05:30.960
mode.

05:30.960 --> 05:31.400
So I'm.

05:31.560 --> 05:37.440
I am digging a go on standard mode, guys, because generally constraint is not necessary.

05:37.590 --> 05:40.560
Yeah, this is not necessarily we can dig into mode.

05:42.070 --> 05:43.360
Oh, yeah.

05:43.720 --> 05:43.950
Oh.

05:44.470 --> 05:49.900
I'm just taking it as a global variable because in power function it will be used by calculating factorial.

05:49.900 --> 05:54.130
Might be it will be used right instead of passing it over here.

05:54.430 --> 05:56.110
Just triggered as a global variable.

05:56.110 --> 05:59.380
Because what happens is if in a particular cold.

06:00.360 --> 06:01.470
In a particular problem.

06:01.470 --> 06:07.740
If you want the result mod from prime number, the prime number will not only be used in this power

06:07.740 --> 06:12.540
function but everywhere in the code, wherever you are doing it in addition or subtraction or multiplication

06:12.540 --> 06:13.170
or division.

06:13.670 --> 06:17.670
It's better to take more rather than to pass it individually to all the methods.

06:18.520 --> 06:21.960
Well, so I reckon these are going to be equal to one.

06:21.960 --> 06:25.680
I don't have to take more because it is already less than name of the seven.

06:26.100 --> 06:26.850
So these are.

06:26.880 --> 06:33.360
The problem here is that if I multiply resulting in two in both of them all of the intended to be over

06:33.360 --> 06:33.750
nine.

06:34.800 --> 06:37.990
So this will go in the into the re indefinitely populated into.

06:38.010 --> 06:40.950
Indeed won't be able to store that eight for that.

06:40.950 --> 06:46.350
I have already told you a workaround that is let's define.

06:47.650 --> 06:54.310
In this long long will always we have long, long integers, days or what, and we don't have to worry

06:54.310 --> 06:55.630
about the other stuff.

06:56.390 --> 07:01.250
So after multiplying both of these values, what we'll do is we'll simply take more data.

07:01.260 --> 07:03.640
So let's dig more side by side resulting.

07:05.470 --> 07:08.860
Ahmad and again for AOL to pledge to the same.

07:11.210 --> 07:12.920
So why am I doing this?

07:12.920 --> 07:19.580
Because this ensures that aid immensely isn't going to devour nameless women and is also remains less

07:19.580 --> 07:20.650
than tainted by nameless.

07:21.350 --> 07:25.080
So that whenever I do this magical multiplication and I take this squared off.

07:25.700 --> 07:28.190
Both of them go at max and do the voting.

07:28.610 --> 07:31.910
Because this is designed as intended by winning.

07:32.150 --> 07:37.840
In the end, they tend to devour it in number and be stored in a long, long and tedious nature.

07:38.180 --> 07:40.590
That's why they take them to the tip of an impossible.

07:42.010 --> 07:49.750
They do, because if I multiply them, they'd multiply two numbers of this particular value.

07:49.990 --> 07:51.400
Then they are, they are.

07:51.550 --> 07:53.470
They get stored in a long, long integer.

07:53.620 --> 07:54.490
That's what we want.

07:55.420 --> 07:58.180
And whenever I'm multiplying them and again, like.

07:58.980 --> 07:59.520
On this one.

07:59.530 --> 08:04.290
I'm taking what I don't want the value to exceed this particular value.

08:04.290 --> 08:04.440
Right.

08:04.470 --> 08:07.020
Because they're used in calculations again.

08:07.260 --> 08:13.800
So A to deliver 20 will be very easy, the same value, but let's say to do about 200.

08:15.230 --> 08:19.430
This will give me more with this particular value.

08:20.360 --> 08:22.080
So this is not to talk about.

08:22.220 --> 08:25.850
It is to keep our 200 moored going to Dubai when an implicit.

08:25.850 --> 08:34.070
And if I take remainders and my right agreement is to make our values in the limit that our language,

08:34.070 --> 08:36.170
our compiler can hold will.

08:37.670 --> 08:44.210
So this was about more direction, intuition, not much changes only we just took more side by side.

08:44.930 --> 08:45.320
We don't.

08:45.320 --> 08:47.770
We don't ever take more by berate in the way.

08:49.020 --> 08:50.820
Because we are dividing it, multiplying.

08:50.820 --> 08:52.320
We're adding it by something.

08:52.800 --> 08:54.170
It has to be in binary.

08:54.180 --> 08:55.620
Don't ever take more than two days.

08:55.650 --> 08:57.060
Otherwise, the value of B will change.

08:57.060 --> 08:59.630
And then there will be some of the binary rate.

08:59.970 --> 09:01.020
So thank you, guys.

09:01.050 --> 09:01.830
See you in the next part.
