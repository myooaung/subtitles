WEBVTT

0
00:00.660 --> 00:02.220
Let's code it and 

1
00:03.520 --> 00:04.220
If we take.

2
00:06.580 --> 00:06.780
Cool

3
00:08.180 --> 00:09.230
Let's take n.

4
00:11.810 --> 00:13.040
Let's take the array as well.

5
00:18.690 --> 00:19.200
And.

6
00:22.590 --> 00:24.030
Let's take the map, so in map.

7
00:24.180 --> 00:28.350
What I can say is I can give this key as a big value, which is 10 to the power 9

8
00:29.220 --> 00:31.980
And let's move forward in the array.

9
00:34.150 --> 00:35.260
I'm going from zero to N.

10
00:35.260 --> 00:41.950
What I’ll say is that I simply say that mp[a[i]], whatever the values there, I just say it is.

11
00:43.950 --> 00:44.280
Okay.

12
00:44.370 --> 00:44.820
So.

13
00:46.220 --> 00:48.290
It can be equal to mp[a[i]-1].

14
00:48.740 --> 00:55.850
It basically I there was a[i] in my case, the i took in this recursive function what this simply says is

15
00:56.420 --> 00:57.740
that what three.

16
01:00.290 --> 01:01.580
Instead of MP lets call it as DP

17
01:03.820 --> 01:07.930
Then it will be more clear rip dp[a[i]] = dp[a[i]-1] + 1

18
01:08.270 --> 01:11.830
Whatever the best ending its previous member can give till now.

19
01:12.160 --> 01:13.570
Plus, add this after that

20
01:14.620 --> 01:20.530
And similarly, when this whole off it finishes, then you can find out what's the best answer.

21
01:21.370 --> 01:25.030
And when we find out, what's the best answer the trick lies here, right.

22
01:25.330 --> 01:26.350
So I have to print K.

23
01:26.530 --> 01:28.420
Which is the l i s okay

24
01:28.480 --> 01:28.900
Let me.

25
01:29.860 --> 01:30.090
Right.

26
01:31.600 --> 01:34.180
Did we find the l i s, let me completely code it.

27
01:34.180 --> 01:37.420
Because in this the BP part is very small.

28
01:37.690 --> 01:42.040
The second part is that you have to actually print the indices of those elements which are needed.

29
01:42.530 --> 01:47.410
And I think that is also very easy, because right now what happens is we know what is the value of k

30
01:47.650 --> 01:50.650
the length of the longest increasing sequence, and we know where it will end.

31
01:51.790 --> 01:55.480
That will give me this whole range, which is x to something.

32
01:55.810 --> 02:02.710
What I just need to do is I need to find out the first index of X then the first index of X plus one after

33
02:02.710 --> 02:07.060
that, after the first index of x + 2 to then X plus three and so on.

34
02:07.360 --> 02:11.740
And I just print it till the last value, the last index.

35
02:12.820 --> 02:13.090
Right.

36
02:14.700 --> 02:16.410
Oh, so you can try.

37
02:16.410 --> 02:18.330
to solve it yourself.

38
02:19.430 --> 02:19.940
Hmm.

39
02:20.840 --> 02:22.150
Of the printing thing, right?

40
02:22.190 --> 02:23.300
I hope you can do it yourself.

41
02:23.510 --> 02:25.460
I'm just finding the value of K here.

42
02:26.330 --> 02:29.540
Let’s say k is 0, k is max of k,

43
02:30.900 --> 02:31.530
x.

44
02:32.810 --> 02:33.180
second.

45
02:33.400 --> 02:35.510
The second value in this map.

46
02:36.590 --> 02:39.860
And let’s say cout k

47
02:44.540 --> 02:44.770
Hmm.

48
02:44.980 --> 02:46.870
It will take some time because.

49
02:48.280 --> 02:49.090
We copy this.

50
02:52.230 --> 02:53.450
So the value here is 4.

51
02:53.460 --> 02:54.060
Is it 4?

52
02:54.510 --> 02:55.200
Yeah, it's 4.

53
02:55.770 --> 02:56.070
Let's.

54
02:56.070 --> 02:57.420
Let's talk about this six.

55
03:00.870 --> 03:03.120
It's a very easy, simple recursivation.

56
03:03.530 --> 03:06.450
Look, can easily see that the problem is very high.

57
03:06.450 --> 03:14.120
And the main idea of this problem is not that the DP is very simple, just that you have to print.

58
03:15.500 --> 03:19.730
The indices of the sequence as well, which is also very easy, it is just implementation problem.

59
03:19.730 --> 03:25.940
Right the DP is not tough and you just have to use a map because the numbers are huge for this.

60
03:25.940 --> 03:33.560
For the second case, we have 2 we have 2 I'm just leaving this to you on what is the best order in

61
03:33.560 --> 03:36.470
which you can print this the sequences.

62
03:36.950 --> 03:43.400
But I would always suggest you to take the hint from here that when you know the ending, you know the

63
03:43.400 --> 03:44.480
ending right here.

64
03:45.930 --> 03:51.000
Start first is the number on which you dent the maximum value.

65
03:51.840 --> 03:53.010
You can find out where it ends.

66
03:53.910 --> 03:59.200
With the help of that, you can find out x the starting of the sequence and from x what you can do it

67
03:59.200 --> 04:00.630
you can start traversing the array.

68
04:00.870 --> 04:07.870
Wherever you find x print that index, then travel further wherever you find x plus one now printed that index and 

69
04:07.890 --> 04:08.220
so on.

70
04:09.240 --> 04:11.920
Till you find this x + k - 1

71
04:14.430 --> 04:15.990
I hope it makes sense.

72
04:16.110 --> 04:18.180
And yeah, see you in the next part.

73
04:18.240 --> 04:18.570
Thanks.