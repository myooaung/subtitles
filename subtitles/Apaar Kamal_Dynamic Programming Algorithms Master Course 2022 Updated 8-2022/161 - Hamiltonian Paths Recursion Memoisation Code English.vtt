WEBVTT

00:00.810 --> 00:07.410
So now what we'll do is we'll simply not called the factorial solution because it's very easy to go

00:07.410 --> 00:09.120
back to making it also very easy to code.

00:09.420 --> 00:17.970
But we will go a recursive plus backed recursive plus memorization solution rate, which is a little.

00:19.130 --> 00:22.870
Digi and important recursive hour plus memorization.

00:22.880 --> 00:25.970
And then we will see what else can be optimized in this code.

00:26.960 --> 00:31.210
From that optimization, we realize that vibrant mask is necessary, right?

00:31.430 --> 00:35.750
So how we like to record this origin for this, it's a very simple solution.

00:35.750 --> 00:40.160
What I'll do is I'll start with let's go to DB, let's say.

00:40.160 --> 00:45.710
Okay, initially what I would say, let's say I'm on one or I just called DB initially, right?

00:45.710 --> 00:50.270
And I'll say that again, this is a set so I'll pass a set to it.

00:50.570 --> 00:51.350
Okay, let me.

00:53.390 --> 00:58.940
What is my current index or the current note or the current vertex on which I am?

00:59.150 --> 01:02.000
And secondly, El Paso said, write said.

01:02.420 --> 01:03.650
What will this ad contain?

01:03.680 --> 01:08.240
It will contain all the words which I visited below so that I don't visit them again.

01:08.650 --> 01:08.780
Right.

01:08.840 --> 01:13.160
And then simply I'll iterate over all the other notes which are in the since you of this vertex.

01:13.430 --> 01:20.930
And then I will simply jump onto those note and finally figure out whether in the end, what will be

01:20.930 --> 01:21.470
the base case.

01:21.470 --> 01:27.260
The base case will be very simple, that whether this set contains all the notes or not, that needs

01:27.260 --> 01:27.920
to be visited.

01:28.820 --> 01:37.820
So basically it's nothing, but it's more of a DFS with a set which tells me whether I have visited

01:37.820 --> 01:39.320
a node or not, whether or not.

01:39.530 --> 01:44.520
And then we will simply memorize it because we can memory the vertex in a second rate.

01:44.900 --> 01:52.370
So let me quickly move on to this solution so far as we can see that.

01:52.370 --> 01:59.990
A Yeah, I just took an I just in the list, I'm just taken to degrade because I want I want to not,

01:59.990 --> 02:06.890
you know, improvise this solution basically to not improve the complexity of it, but to make you understand

02:06.890 --> 02:08.160
what is masking, right.

02:08.180 --> 02:13.970
So I'm just going to and crossing adjacency list and it's about it's actually great.

02:13.970 --> 02:20.330
So I've just taken an attempt and finally one else's I will see out whether the solution exists or not.

02:20.900 --> 02:21.120
Right.

02:21.650 --> 02:29.180
Initially let me pass an MP vertex or what I can do is I can see the answer is false.

02:29.320 --> 02:30.260
It sounds it is false.

02:30.680 --> 02:30.980
Right.

02:31.250 --> 02:35.510
And instead of that, let's take a boolean value itself.

02:35.540 --> 02:39.770
Let's say initially that Hamiltonian path does not exist in Hamiltonian.

02:41.980 --> 02:43.160
But cool.

02:43.420 --> 02:49.660
And finally, let's start from zero because we have to start from zero because of zero base indexing.

02:50.410 --> 02:52.750
So you'll understand why have I taken this?

02:53.320 --> 03:01.720
Now what I can say is the answer or equals to D B start from A and what will be the values in my set.

03:02.170 --> 03:03.230
The values in my.

03:03.250 --> 03:03.550
Okay.

03:03.550 --> 03:04.570
I have to pass, etc..

03:04.670 --> 03:05.860
It's a little positive.

03:06.700 --> 03:12.970
We can also pass a vector that just gives a track of all the elements, but I'm just passing a set of

03:13.660 --> 03:14.680
both of them can do.

03:15.340 --> 03:15.670
Right.

03:16.770 --> 03:22.540
I'm taking a side because it's a very simple thing because of and I'll be writing this because it's

03:22.560 --> 03:22.900
solution.

03:22.920 --> 03:29.070
I have to check whether which note is already in the set and which is not in the set.

03:29.100 --> 03:29.460
Right.

03:29.610 --> 03:31.440
Because that's when I got in letter.

03:31.440 --> 03:32.550
I started from zero.

03:32.820 --> 03:34.410
Then I have to check that.

03:35.960 --> 03:37.860
Is one in this set or not, right?

03:37.880 --> 03:39.500
So that can be very easy.

03:39.500 --> 03:44.240
I can easily find it in this end because I can directly go straight out fine.

03:44.360 --> 03:44.620
Right.

03:44.630 --> 03:45.530
Which is fine.

03:45.770 --> 03:48.380
But in fact, what I have to do is I have to iterate again and again.

03:48.590 --> 03:50.540
So that's why I'm digging said goal.

03:50.870 --> 03:51.950
So it's not a big deal.

03:52.990 --> 03:56.710
And yeah, so let me keep a set here.

03:56.860 --> 04:01.990
And in this set, what I'll do is I'll just insert I.

04:02.410 --> 04:08.560
And also there's one more thing where I'm taking a side over here because of when I'll memorize the

04:08.570 --> 04:13.540
set so you can see that asset is in order data structure, right?

04:13.570 --> 04:20.530
That means if I push 2 to 3, four and one inside it, then it will be ordered as one, two, three,

04:20.530 --> 04:20.800
four.

04:21.810 --> 04:22.200
Correct.

04:22.500 --> 04:28.970
So it's in order to create a structure that means it doesn't matter which vertices I'm visiting or in

04:29.430 --> 04:31.620
or in which order I am visiting those vertices.

04:31.860 --> 04:34.920
It will just tell me that, yes, I have visited these vertices.

04:35.550 --> 04:35.880
Correct.

04:36.060 --> 04:38.040
So I want to try for one.

04:39.200 --> 04:43.310
To be same as one, two, three, four, because I'm just keeping a set of vertices.

04:43.310 --> 04:45.890
I'm just keeping track of those vertices which I visited.

04:46.550 --> 04:46.760
Right.

04:47.330 --> 04:53.720
So I just insert I and I start from, I say answers articles to DB, I must say.

04:53.990 --> 04:55.130
Okay, so let's start.

04:55.280 --> 05:02.530
So here I'm just taking a map of intensity and for every word, I just push the set that okay, they

05:02.540 --> 05:07.820
are this vertex and this that have been registered and I load and back that will be just used for memorization.

05:07.820 --> 05:10.040
This map will be just used for memorization.

05:10.550 --> 05:10.880
Cool.

05:11.210 --> 05:16.940
And yeah, so this will be boolean function and this will be the current node, which I'm on.

05:17.300 --> 05:20.840
And what we'll have will have a set.

05:22.500 --> 05:22.800
Good.

05:23.160 --> 05:24.390
And finally.

05:24.960 --> 05:25.680
Why do we lose?

05:25.710 --> 05:27.300
Let's go into a decent list.

05:27.750 --> 05:29.220
I just sense a list of current.

05:29.880 --> 05:36.900
So what I can do is, instead of taking a dozen Z and grossing, let's take the vector only.

05:36.910 --> 05:37.090
Right.

05:37.110 --> 05:38.220
Because now it doesn't matter.

05:38.220 --> 05:41.070
Because I am already taking search to find out things.

05:41.640 --> 05:41.910
Right.

05:42.180 --> 05:45.840
So, yeah, let me just take a vector only because.

05:46.020 --> 05:47.930
See, guys, both of them can work, right?

05:47.940 --> 05:49.800
I'm just taking things.

05:52.010 --> 05:54.050
Just to explain it more easily.

05:54.750 --> 05:55.880
So I just performed it.

05:55.880 --> 06:00.610
We are going the extensive list of effects and which is nothing but drop current.

06:00.620 --> 06:02.450
And what else is that?

06:03.050 --> 06:05.660
Tell me whether X is visited or not.

06:05.930 --> 06:10.880
Because what will tell me whether it is visiting this set and if it is not visited, I'll ask it to

06:10.880 --> 06:11.780
visit to that site.

06:12.690 --> 06:13.110
Correct.

06:14.850 --> 06:16.230
So yeah.

06:17.430 --> 06:22.980
So there's one thing that I want you to realize that this solution is very different from backtracking

06:22.980 --> 06:23.520
solution.

06:23.520 --> 06:26.250
In this solution, I'm not going to backtrack anything.

06:26.820 --> 06:30.560
So a backtracking solution would not require a said rate.

06:31.170 --> 06:36.780
A backtracking solution can only can also work with a visitor that can just keep a visitor that day

06:36.780 --> 06:38.730
and find out whether it is visited or not.

06:39.060 --> 06:42.520
But we cannot memorize the backtracking solution.

06:42.860 --> 06:43.190
Why?

06:43.290 --> 06:45.210
Because, let's say if two was visited.

06:45.330 --> 06:45.690
Right.

06:46.050 --> 06:46.890
But what?

06:47.280 --> 06:52.590
But you know, which bot did I take when I came to do that matters.

06:52.860 --> 06:53.970
That's why I'm keeping a sec.

06:53.970 --> 06:59.430
Because this said will maintain they look at these were the vertices that were visited when I came to

06:59.430 --> 07:01.110
this particular node which is current.

07:02.070 --> 07:02.430
Cool.

07:02.460 --> 07:03.450
This is important, guys.

07:03.450 --> 07:07.500
The difference between a backtracking and indicative solution in this case is very different.

07:08.630 --> 07:08.960
Eight.

07:09.920 --> 07:11.030
So yeah.

07:11.120 --> 07:15.410
Let's move forward and let's see if still don't find.

07:17.840 --> 07:20.480
X is not equal to SD dot.

07:22.000 --> 07:23.080
And that means I have.

07:23.380 --> 07:24.700
That means it is.

07:25.330 --> 07:26.490
It means X is in this.

07:26.510 --> 07:27.850
Or that means X is visited.

07:27.880 --> 07:29.380
So let me make it equal to.

07:29.800 --> 07:30.790
What will this mean?

07:30.790 --> 07:31.660
If this is true?

07:31.660 --> 07:35.920
That means I was going to find I was going to find this X in the set.

07:35.920 --> 07:37.180
And it is not in the set.

07:37.270 --> 07:37.560
Right.

07:38.050 --> 07:40.600
So if it is not in the set, what what will I do?

07:40.610 --> 07:41.140
I just.

07:41.350 --> 07:42.580
Let's stay on this set.

07:43.030 --> 07:45.820
Let's call it temp and let's make really close to SD.

07:46.360 --> 07:54.850
And finally, let me insert SD dot insert 30 -- dot insert x because I have to maintain this.

07:54.850 --> 07:55.150
Right.

07:55.420 --> 08:00.530
Which, which elements are there in the set and which are not h I've inserted X into the set.

08:00.790 --> 08:03.220
And finally, what I'll do is I simply.

08:03.220 --> 08:07.870
C Let's make answer on Sir William.

08:09.910 --> 08:10.240
Yeah.

08:10.540 --> 08:12.940
Boolean answer is false.

08:12.940 --> 08:14.440
And what I'd say there.

08:14.440 --> 08:21.700
Tell me whether a bot exist from the next nodes if these were the nodes which are already visited.

08:22.210 --> 08:22.450
Right.

08:22.990 --> 08:25.930
So I just say D be x comma.

08:26.290 --> 08:26.570
Yeah.

08:26.920 --> 08:27.700
And just passed them.

08:28.450 --> 08:29.470
I hope you're getting the point.

08:29.470 --> 08:34.960
I'm just copying this set into a temporary set, which I have to parse because I have to insert x also

08:34.960 --> 08:37.480
that x is now the node that is also visited.

08:37.990 --> 08:38.290
Right?

08:38.400 --> 08:40.330
Then again, I go in that sends a list of it.

08:40.330 --> 08:42.610
And so what will be the base case?

08:43.240 --> 08:52.390
The base case will be if as the dot size is equal to N, that means if all the nodes in my state is

08:52.390 --> 08:59.470
visited, that means I have found a particular Hamiltonian, but because I'm not visiting any node twice.

08:59.980 --> 09:04.690
Also let me take anywhere here and maybe let's take em on.

09:04.690 --> 09:10.720
So on the top because we have to use and then in the base case you have to use and in the base case,

09:10.720 --> 09:10.990
right.

09:11.470 --> 09:17.860
So if set size is equal to and I simply return to that, yes, the answer was possible.

09:18.190 --> 09:18.490
Right.

09:18.640 --> 09:26.000
And you and if any one of those parts were possible that then what I can simply do, I can simply say,

09:26.320 --> 09:27.490
let's return the answer.

09:28.150 --> 09:29.460
I hope this is clear now.

09:29.470 --> 09:30.430
Let's memorize it now.

09:30.430 --> 09:32.380
We have to memorize it on the basis of current.

09:32.380 --> 09:35.170
And this said that these are the nodes which are already visited.

09:35.170 --> 09:35.480
Right?

09:35.510 --> 09:36.550
I've already got a map.

09:36.820 --> 09:39.730
And what I'll do is I'll simply say and B.

09:42.120 --> 09:42.380
Yeah.

09:42.570 --> 09:45.030
MP Don't count it.

09:45.180 --> 09:48.600
That means if this was set, then simply.

09:50.220 --> 09:53.130
Return MP Dore Gold.

09:53.160 --> 09:53.520
Okay.

09:53.520 --> 09:54.450
So it is.

09:55.700 --> 09:56.060
Hmm.

09:56.270 --> 09:57.380
So this is interesting.

09:58.100 --> 10:04.400
So what I what I want to keep is I want to keep that for this current law and for this said, for all

10:04.400 --> 10:12.230
the law that I visited, I'm writing right now on the current known whether, oh, I have came to this

10:12.230 --> 10:13.490
place earlier or not.

10:13.490 --> 10:13.850
Right.

10:14.060 --> 10:16.820
So for this, I don't have to keep in conversating.

10:16.850 --> 10:17.870
Let's keep here.

10:19.190 --> 10:19.520
Right.

10:20.240 --> 10:24.140
So the first key will be a pair of indented, right?

10:24.350 --> 10:27.310
And the second key can be an IT or a boolean.

10:29.070 --> 10:29.400
Cool.

10:29.670 --> 10:32.850
So I simplisafe and pilot count current command.

10:32.850 --> 10:35.310
This set that I have already have.

10:35.610 --> 10:36.690
I'll simply return.

10:39.440 --> 10:41.140
MP current comment said.

10:42.110 --> 10:44.990
And if this was not said, then finally we consented.

10:45.680 --> 10:47.210
Let me pick this.

10:48.350 --> 10:50.050
Let me be this great.

10:51.310 --> 10:51.880
Okay.

10:51.910 --> 10:52.690
Some errors.

10:53.510 --> 10:54.490
Hmm.

10:55.300 --> 10:55.630
Okay.

10:55.860 --> 10:57.370
Set is small.

10:59.030 --> 10:59.600
My word.

11:01.830 --> 11:02.230
Okay.

11:02.760 --> 11:04.140
So I have not declared answer.

11:04.260 --> 11:04.590
Okay.

11:04.590 --> 11:06.990
It's Hamiltonian, but my word again.

11:09.500 --> 11:09.670
Right.

11:09.870 --> 11:11.430
And finally, Alessio Dancer.

11:13.670 --> 11:14.870
I re sorry.

11:15.320 --> 11:16.520
It's in habit of digging.

11:17.420 --> 11:17.660
Yeah.

11:17.750 --> 11:18.760
So here we can see that.

11:18.770 --> 11:19.040
Yes.

11:19.040 --> 11:19.700
The part.

11:19.700 --> 11:21.320
Hamiltonian part existed.

11:21.680 --> 11:21.990
Right.

11:22.040 --> 11:23.690
So I hope you can realize it.

11:23.700 --> 11:24.980
How is this recursion?

11:25.220 --> 11:26.720
Plus, memorization is working.

11:26.990 --> 11:31.490
So this is very different from a backtracking solution laid in a backtracking solution.

11:32.270 --> 11:38.660
I can go any of the parts and I can just keep account of which node is visited and which node is not.

11:39.290 --> 11:45.470
I do not need to keep us at the rate, but here I need to keep a sec because I need to memorize it.

11:46.120 --> 11:46.320
Right.

11:46.940 --> 11:49.070
Because let me quickly explain this.

11:49.400 --> 11:54.650
Maybe it will make things more clear that when you are trying, backtracking and you're just keeping

11:55.280 --> 11:56.390
an individual not right.

11:56.630 --> 12:01.430
But it depends on which paths you took to keep that node visit, for example.

12:03.260 --> 12:03.590
Okay.

12:03.590 --> 12:06.050
Let me give you a nice example maybe.

12:07.580 --> 12:08.360
Um.

12:08.390 --> 12:08.790
Okay.

12:09.230 --> 12:20.870
So in this case, we can see that 0 to 1 three is about correct and 0 to 1 to do is another but three.

12:21.020 --> 12:24.620
So in backtracking, I just need to keep track of whether zero was wasted or not.

12:24.620 --> 12:28.160
One was wasted on art and three was wasted on not but integration.

12:28.430 --> 12:31.640
I need to keep said they look at these with an order of be done.

12:31.640 --> 12:32.690
Only I can memorize it.

12:33.590 --> 12:35.120
Right because the.

12:36.230 --> 12:40.130
Order of the bat does not matter, right?

12:40.160 --> 12:42.800
But it matters whether the new one is visited or not.

12:43.240 --> 12:47.060
And so simply so here we can see that it existed.

12:47.090 --> 12:50.330
Now, let me just remove one good note in this.

12:50.880 --> 12:52.310
Um, okay.

12:53.090 --> 12:57.890
Let's remove this 0 to 1, and then let's see whether resolution works or not.

12:59.530 --> 12:59.800
He.

13:02.520 --> 13:05.790
So you can see that that the solution doesn't exist.

13:06.540 --> 13:07.620
That there's no Hamiltonian.

13:07.620 --> 13:10.080
But I hope you got this.

13:10.080 --> 13:12.210
And in the next part, we'll discuss that.

13:12.210 --> 13:13.170
How can we?

13:13.770 --> 13:14.190
Okay.

13:14.670 --> 13:16.740
We will discuss the complexity of this solution as well.

13:16.740 --> 13:19.400
But we'll also discuss how can we optimize it pool.

13:20.400 --> 13:22.410
And then you will realize what is D B we would mask.

13:22.410 --> 13:24.270
It's a very, very simple thing like.
