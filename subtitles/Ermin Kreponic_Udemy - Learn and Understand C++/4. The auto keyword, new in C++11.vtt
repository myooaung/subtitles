WEBVTT

1
00:00:00.065 --> 00:00:00.901
Welcome back!

2
00:00:01.515 --> 00:00:05.300
So, today I'm going to go ahead
and talk about a keyword called

3
00:00:05.461 --> 00:00:06.045
auto

4
00:00:06.935 --> 00:00:07.836
like this.

5
00:00:08.361 --> 00:00:10.120
auto.

6
00:00:10.581 --> 00:00:11.720
This is something new

7
00:00:11.906 --> 00:00:13.661
in C++11

8
00:00:13.825 --> 00:00:17.800
and in C++11 it was introduced
as a new feature.

9
00:00:18.601 --> 00:00:20.976
This allows for the

10
00:00:21.141 --> 00:00:24.880
automatic detection of variable
types.

11
00:00:25.041 --> 00:00:27.040
So, you don't need to declare it as
an int

12
00:00:27.201 --> 00:00:28.890
or is a double or something like that.

13
00:00:29.311 --> 00:00:32.880
Rather instead, it can be recognized
in an automatic fashion

14
00:00:33.041 --> 00:00:34.395
what it actually is.

15
00:00:34.796 --> 00:00:37.600
This does shorten the code by
a great deal

16
00:00:37.761 --> 00:00:41.180
and it is convenient in
a good amount of situations

17
00:00:41.451 --> 00:00:44.765
but it is more difficult to read
the code and

18
00:00:44.991 --> 00:00:49.735
there is a lot of dispute whether this
should be implemented in C++

19
00:00:50.111 --> 00:00:55.080
or not. The debate is still on going
that it has been implemented.

20
00:00:56.471 --> 00:00:59.186
Anyway, you shouldn't overuse auto
keywords.

21
00:00:59.371 --> 00:01:00.618
for auto detection.

22
00:01:00.780 --> 00:01:01.961
If you have the option

23
00:01:02.121 --> 00:01:04.965
if you are able to declare
the variables straight away,

24
00:01:05.301 --> 00:01:05.991
with the type

25
00:01:06.455 --> 00:01:07.720
then do so.

26
00:01:09.186 --> 00:01:13.120
If for whatever circumstances,
it is far far more convenient,

27
00:01:13.281 --> 00:01:16.508
to use the auto keyword, and
use the auto detection,

28
00:01:16.695 --> 00:01:17.660
then feel free but,

29
00:01:18.571 --> 00:01:20.120
As I said,

30
00:01:21.366 --> 00:01:24.510
declare the types on your own
as much as you can.

31
00:01:24.671 --> 00:01:25.365
For

32
00:01:25.526 --> 00:01:27.815
a wide variety of reasons,

33
00:01:28.535 --> 00:01:29.738
so, if I type in Auto,

34
00:01:29.900 --> 00:01:31.611
x =

35
00:01:32.481 --> 00:01:34.455
10.5

36
00:01:35.401 --> 00:01:35.925
and

37
00:01:36.086 --> 00:01:37.138
line terminator,

38
00:01:39.306 --> 00:01:42.320
Ok, so 10.5 is clearly
a double.

39
00:01:42.676 --> 00:01:46.970
But if I place in auto,
x this will be recognize as a double.

40
00:01:47.391 --> 00:01:51.005
I don't need to declare it as a
double. I can also say

41
00:01:51.616 --> 00:01:52.605
auto

42
00:01:53.216 --> 00:01:54.250
y

43
00:01:54.411 --> 00:01:55.740
is equal

44
00:01:56.566 --> 00:01:57.895
to 10.

45
00:01:58.976 --> 00:02:03.880
So, this will also be recognized as
an integer without me declaring it

46
00:02:04.041 --> 00:02:04.980
as an integer.

47
00:02:05.141 --> 00:02:06.151
Keep that in mind.

48
00:02:06.870 --> 00:02:11.356
So, we can initialize this variables
in several ways.

49
00:02:12.481 --> 00:02:13.446
We can

50
00:02:13.631 --> 00:02:15.131
go down, and type in int

51
00:02:15.830 --> 00:02:17.946
var1 is equal

52
00:02:18.135 --> 00:02:20.725
10. Keep this in mind, there
are a lot of people

53
00:02:20.886 --> 00:02:23.498
who initialize variables in various ways

54
00:02:23.661 --> 00:02:24.925
in

55
00:02:25.941 --> 00:02:28.231
for different purposes and
different codes

56
00:02:28.416 --> 00:02:33.960
and you might encounter something
like this. You've seen this regular

57
00:02:34.281 --> 00:02:36.315
and standard variable initialization.

58
00:02:36.841 --> 00:02:39.536
And this initialization consists of

59
00:02:39.766 --> 00:02:43.783
appending the equals sign
followed by the value.

60
00:02:44.116 --> 00:02:47.156
Now, you have constructor
initialization which is

61
00:02:47.316 --> 00:02:48.411
which goes like this.

62
00:02:49.066 --> 00:02:50.840
int var2

63
00:02:51.670 --> 00:02:52.656
=

64
00:02:53.100 --> 00:02:54.130
20.

65
00:02:55.401 --> 00:02:56.411
Because this is also

66
00:02:56.876 --> 00:03:00.160
this is alos one way of actually doing it.

67
00:03:01.716 --> 00:03:02.470
Sorry,

68
00:03:04.126 --> 00:03:06.280
Let's just put in 10.

69
00:03:06.475 --> 00:03:08.640
This is the

70
00:03:13.131 --> 00:03:14.205
My apologies.

71
00:03:14.456 --> 00:03:18.000
We'll get to the curly brackets

72
00:03:22.646 --> 00:03:23.698
ok, there we go.

73
00:03:24.076 --> 00:03:25.600
My apologies sorry this is just

74
00:03:25.761 --> 00:03:28.626
this is just habit forming and
sometimes you make errors

75
00:03:28.831 --> 00:03:29.950
anyway, it says int

76
00:03:30.111 --> 00:03:31.165
var2

77
00:03:31.606 --> 00:03:36.285
and you have parenthesis here.
This is contstructor initialization

78
00:03:36.766 --> 00:03:38.356
and down below

79
00:03:38.516 --> 00:03:39.640
you have int,

80
00:03:40.201 --> 00:03:42.480
var3

81
00:03:42.841 --> 00:03:44.241
and then you have this curly braces

82
00:03:44.446 --> 00:03:45.205
but we don't need

83
00:03:45.366 --> 00:03:46.160
certainly not.

84
00:03:46.411 --> 00:03:47.250
another space here.

85
00:03:48.566 --> 00:03:49.640
And you type in 20.

86
00:03:50.101 --> 00:03:52.308
I don't know I just selected some random

87
00:03:52.470 --> 00:03:53.136
values.

88
00:03:53.321 --> 00:03:55.893
This is uniform initialization.

89
00:03:56.055 --> 00:03:59.325
that has been introduced in C++11

90
00:03:59.510 --> 00:04:01.460
and it is recommended for use.

91
00:04:01.621 --> 00:04:03.593
to initialize variables in which

92
00:04:03.755 --> 00:04:04.361
fashion

93
00:04:04.521 --> 00:04:05.255
in this way.

94
00:04:05.716 --> 00:04:08.411
So, is what it is recommended to do.

95
00:04:08.726 --> 00:04:10.951
And this is where the C++

96
00:04:11.266 --> 00:04:14.793
programming language is going to
C++11

97
00:04:14.956 --> 00:04:17.160
is like.

98
00:04:17.961 --> 00:04:23.920
It is pretty much the newest standard
and you should be focusing on those new

99
00:04:24.106 --> 00:04:24.776
standards.

100
00:04:24.940 --> 00:04:28.571
I wouldn't say disregarding or
throwing away everything that is old,

101
00:04:28.906 --> 00:04:30.705
but just moving in the right direction

102
00:04:30.866 --> 00:04:34.500
of the future. There is a reason why
these things are being changed.

103
00:04:35.116 --> 00:04:36.721
Now, we shouldn't overdo it

104
00:04:37.336 --> 00:04:41.521
with using auto keyword as I said when
declaring the type.

105
00:04:42.516 --> 00:04:43.850
When writing

106
00:04:44.011 --> 00:04:46.580
the type is short and it's not

107
00:04:46.741 --> 00:04:49.560
like consumed too much
of the code, or time

108
00:04:49.721 --> 00:04:50.995
or something like that,

109
00:04:51.156 --> 00:04:52.725
we should really write the type.

110
00:04:52.886 --> 00:04:57.951
And only if he writing type is really long
or inconvenient for whatever

111
00:04:58.111 --> 00:05:01.578
reasons, then you should consider
using the word auto.

112
00:05:01.740 --> 00:05:02.491
For example,

113
00:05:03.486 --> 00:05:05.140
The following line,

114
00:05:05.301 --> 00:05:06.673
where the lines above

115
00:05:07.456 --> 00:05:11.045
these two lines above, both of them
are pretty much overdoing it.

116
00:05:11.510 --> 00:05:12.986
and this line

117
00:05:14.731 --> 00:05:15.805
auto,

118
00:05:16.246 --> 00:05:17.446
var

119
00:05:18.206 --> 00:05:19.005
6

120
00:05:19.401 --> 00:05:21.500
This would also be overdoing it.

121
00:05:21.856 --> 00:05:22.503
I mean,

122
00:05:22.860 --> 00:05:26.106
why not just type in the type

123
00:05:26.571 --> 00:05:28.926
of this and say this is an int

124
00:05:29.086 --> 00:05:31.560
and no problem, solve it, but

125
00:05:31.966 --> 00:05:32.680
I mean,

126
00:05:32.886 --> 00:05:36.880
those are probably wanted a var
to be on type int.

127
00:05:37.195 --> 00:05:38.205
with I don't know,

128
00:05:38.516 --> 00:05:39.910
the initial value of 6.

129
00:05:40.821 --> 00:05:41.450
var

130
00:05:41.611 --> 00:05:42.196
6,

131
00:05:42.356 --> 00:05:43.240
integer

132
00:05:43.551 --> 00:05:45.200
whose value is var 6.

133
00:05:45.581 --> 00:05:47.165
But that is not

134
00:05:47.415 --> 00:05:47.935
int

135
00:05:48.096 --> 00:05:50.960
var here is type

136
00:05:51.191 --> 00:05:53.800
you have some sort of an initialization
list.

137
00:05:54.281 --> 00:05:56.916
That is var that is type of a list

138
00:05:57.076 --> 00:05:59.560
with one element.

139
00:06:00.831 --> 00:06:02.590
And that is the element with the value

140
00:06:02.751 --> 00:06:03.401
6.

141
00:06:03.561 --> 00:06:05.895
The list on certain context is

142
00:06:06.295 --> 00:06:07.156
context

143
00:06:07.316 --> 00:06:08.390
behaves

144
00:06:09.001 --> 00:06:10.143
as an int.

145
00:06:10.305 --> 00:06:12.101
but it is not an int,

146
00:06:12.266 --> 00:06:13.830
so you should not overdo
it with auto

147
00:06:14.296 --> 00:06:18.545
It can cause errors, problems,
etc, for your confusion.

148
00:06:18.796 --> 00:06:21.640
Not the best of ideas,
unless you absolutely need to do it,

149
00:06:21.826 --> 00:06:22.346
do not

150
00:06:22.506 --> 00:06:23.880
do it.

151
00:06:25.451 --> 00:06:31.221
I've mentioned here, lists and this would
be explained, somewhere

152
00:06:31.381 --> 00:06:34.991
along the way, there would be explained
but that is a more advanced

153
00:06:35.326 --> 00:06:36.511
subject.

154
00:06:36.671 --> 00:06:38.218
I noted this last part

155
00:06:38.380 --> 00:06:41.360
is probably a little bit confusing.

156
00:06:41.521 --> 00:06:44.530
And I can feel myself, I can here my own
speech and I feel that I haven't

157
00:06:44.736 --> 00:06:47.515
explained it to the best of my
abilities, but I have

158
00:06:48.066 --> 00:06:49.610
tried in any case

159
00:06:49.771 --> 00:06:54.066
that is why I leave the discussion
section open and

160
00:06:54.296 --> 00:06:56.600
I paid people who are there to
you answer questions

161
00:06:56.761 --> 00:06:59.680
and to help you out in any way
that they can gladly.

162
00:06:59.921 --> 00:07:02.811
So, everything that you did not understand
here, feel free

163
00:07:03.041 --> 00:07:04.600
to post it in the discussion section.

164
00:07:04.761 --> 00:07:07.310
There are people who will
help you out gladly.

165
00:07:08.651 --> 00:07:09.428
Not just

166
00:07:09.590 --> 00:07:12.640
people in community in general,
they would probably help you too but,

167
00:07:12.896 --> 00:07:14.591
there are also people who are paid

168
00:07:14.751 --> 00:07:17.160
to help you out as well.

169
00:07:18.101 --> 00:07:20.543
That is one of the benefits of

170
00:07:20.706 --> 00:07:23.240
buying this courses.

171
00:07:24.586 --> 00:07:30.290
Anyway, I bid you farewell here. And
there will be only one more section

172
00:07:30.776 --> 00:07:33.920
Well, there will be only one more tutorial
of this chapter, where

173
00:07:34.081 --> 00:07:39.250
I will talk about comments and
then we will be done with this and we will

174
00:07:39.711 --> 00:07:43.805
move on into more advanced examples
and see,

175
00:07:44.361 --> 00:07:47.720
what goes on there. probably
a little bit more interesting

176
00:07:47.881 --> 00:07:49.120
But we'll see how it goes.

