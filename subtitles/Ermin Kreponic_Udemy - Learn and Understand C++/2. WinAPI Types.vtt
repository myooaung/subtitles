WEBVTT

00:00.540 --> 00:10.230
De acuerdo, la última vez te dije que cualquier cosa que se devolviera si no era un cero de una función, indica

00:10.370 --> 00:12.030
que algo salió mal.

00:12.420 --> 00:17.450
Si el estado no es cero si es distinto de cero, entonces es un problema.

00:17.730 --> 00:23.120
Entonces son cinco aquí, ¿qué crees que eso significa?

00:23.120 --> 00:26.910
Bueno, no llamamos a una función y esto es solo una constante.

00:26.930 --> 00:30.930
Entonces, si solo estoy escribiendo esta última hora, al final será cero.

00:31.510 --> 00:32.160
Ahí tienes.

00:32.330 --> 00:34.970
Son cinco y luego es cero.

00:35.330 --> 00:42.280
Ahora, si quiere saber qué muestra S-W o qué representa realmente la variable.

00:42.320 --> 00:52.080
Te daré una pista: W significa "ventana" y S significa "show" y te aconsejo que escribas

00:52.160 --> 00:58.650
"abrir" un navegador web en MSD y escribas "S-W underline show".

00:58.700 --> 01:00.390
Esto no es porque soy flojo.

01:00.470 --> 01:06.650
De hecho, quiero que vayas a la red y revises MSDE porque les estoy enviando tráfico.

01:06.650 --> 01:07.430
Diablos no

01:07.430 --> 01:14.640
Solo quiero que sepas que tienes un repositorio de conocimiento al que puedes acceder de forma gratuita.

01:14.660 --> 01:19.330
Así que solo adelante y échale un vistazo, hay una definición muy breve para él.

01:19.420 --> 01:26.510
Lo explica bastante bien y confía en mí si vas a trabajar con la API de Windows para hacer

01:26.510 --> 01:33.740
cualquier tipo de aplicaciones de GUI o lo que sea que necesites usar misty como punto de referencia porque sería

01:33.740 --> 01:37.040
absurdo aprender todas las funciones y variables de memoria

01:37.070 --> 01:40.600
Hay miles y miles de ellos de todos modos.

01:41.030 --> 01:43.670
Vamos a seguir adelante y eliminar esto por ahora.

01:45.350 --> 01:51.600
Y vamos a seguir adelante y saltar al siguiente ejemplo que demostrará una llamada simple

01:51.620 --> 01:53.900
de la función API de Windows.

01:53.900 --> 01:58.940
El programa volverá en ese momento en milisegundos.

01:59.390 --> 02:02.290
La computadora estaba funcionando desde el último arranque.

02:02.360 --> 02:08.100
Tomaremos ese tiempo y lo convertiremos en formato de minutos y segundos.

02:08.120 --> 02:11.330
Entonces sigamos y veamos cómo se hace eso, ya que esta es una máquina virtual.

02:11.370 --> 02:15.400
De hecho, no estoy seguro de cuánto tiempo ha estado funcionando.

02:17.370 --> 02:18.060
DE ACUERDO.

02:19.000 --> 02:23.920
Y honestamente no tengo idea de qué tipo de valor obtendré.

02:23.920 --> 02:29.340
Entonces, lo primero que vamos a necesitar es la palabra algo que es muy importante.

02:29.370 --> 02:37.300
La palabra es un tipo de API de Windows por lo general está en el formato de int sin firmar, lo que significa que es

02:37.780 --> 02:39.730
un número positivo número entero positivo.

02:40.180 --> 02:46.150
Así que definitivamente les aconsejo que realicen una investigación adicional sobre la palabra porque se usa

02:46.150 --> 02:48.190
ampliamente en la API de Windows.

02:49.210 --> 02:53.500
Y seguiremos adelante y escribiremos M-S y M-S serán iguales.

02:53.500 --> 02:57.250
Así que recuerda que la palabra es un tipo M-S es una variable.

02:57.250 --> 03:00.460
Entonces M-S es una variable de tipo D word.

03:00.580 --> 03:07.960
Podría haber escrito en un lío excepto en un lío y la palabra M-S son dos cosas completamente diferentes ya

03:08.910 --> 03:11.060
que son dos tipos completamente diferentes.

03:11.230 --> 03:12.590
Y usaré una función.

03:12.640 --> 03:23.580
Así que obtenga la cuenta de garrapata obtener La función de conteo de obtener la cuenta de devolver la cantidad de milisegundos desde el inicio de

03:23.880 --> 03:24.540
las computadoras.

03:24.540 --> 03:30.920
Entonces, desde el momento en que lo he encendido, va a contar todos los milisegundos y

03:30.930 --> 03:35.130
los devolveremos y los ubicaremos en la variable del lío.

03:35.160 --> 03:40.170
Entonces SDD mira hacia fuera.

03:40.410 --> 03:44.780
Este será un segundo cercano.

03:44.790 --> 03:51.780
Esto es después de que la computadora inició M-S y

03:55.480 --> 03:59.890
C D y L deified simplemente

04:03.340 --> 04:08.080
adelante y guardar esto y ejecutarlo bien.

04:08.100 --> 04:10.420
Milisegundos pasaron después de que tu computadora comenzó.

04:10.480 --> 04:16.900
De acuerdo, esta vez no me voy a molestar en leer el número, solo sigue y eche un vistazo ahora.

04:16.920 --> 04:26.430
Tomaremos este número y lo convertiremos en el formato que es más legible por humanos,

04:26.460 --> 04:35.520
por ejemplo, un int sin firmar horas equivale a M-S dividido por tres torres.

04:35.520 --> 04:44.830
Debe ser 3000 que no es 3000 3: 6 y luego 1 2 3 4 5.

04:45.140 --> 04:47.120
Eso debería estar bien.

04:47.760 --> 04:53.810
Y luego vamos a convertir esto en milisegundos en horas, así que divida

04:53.880 --> 05:04.040
por 1000 para obtener los segundos y luego por 3600 para obtener las horas una hora tiene 3600 segundos si no lo sabía.

05:04.440 --> 05:12.860
Así que consigné solo un poco de matemáticas allí y nada especial en minutos.

05:14.380 --> 05:26.090
Debido a que M-S está dividido por 6000 y luego vamos a obtener el módulo no 6000 ¿Por qué sigo yendo

05:26.100 --> 05:30.540
6000 60000 atascado y miles hoy me temo?

05:30.600 --> 05:36.680
Dividido por 60, lo que convierte milisegundos en minutos.

05:36.680 --> 05:37.920
¿Qué tenemos que hacer aquí?

05:37.970 --> 05:45.770
Bueno, primero tenemos que dividir por 1000 para obtener segundos y luego dividir por 60 para obtener los minutos

05:45.770 --> 05:54.170
un minuto tiene 60 segundos, por lo tanto, vamos a dividir por 60 y luego tomaremos el módulo para que esté

05:54.170 --> 05:57.170
en el rango de 0 a 60.

05:57.170 --> 06:00.250
Así que divida por 60 y divida por mil.

06:00.290 --> 06:02.800
Eso sería 60000.

06:03.170 --> 06:11.360
Y luego tome el módulo 60 para que así sea que obtendríamos una tasa específica de 0 a 60 K sin

06:13.170 --> 06:17.850
signo int de cómo funciona un módulo y por qué se usa.

06:17.920 --> 06:23.190
Todo lo que se explicó hace mucho tiempo en los capítulos iniciales.

06:23.760 --> 06:26.120
Segundos iguales

06:26.430 --> 06:32.110
Y aquí tendremos M. S. dividido por 1000

06:32.260 --> 06:39.300
Y luego tomaremos módulo y Chhobi 60.

06:39.360 --> 06:41.570
Divide por 1000 para obtener los segundos.

06:42.030 --> 06:44.040
Y eso es más o menos.

06:44.040 --> 06:49.970
Después de eso, simplemente tomaremos el módulo para que esté en un rango de cero a 60.

06:50.010 --> 06:55.390
De nuevo, una vez más abajo crearemos nuestra impresión.

07:00.460 --> 07:05.710
OK, así que eso

07:10.400 --> 07:12.810
es nuestro.

07:13.610 --> 07:15.740
Vamos a hacerlo un poco más bonito.

07:20.360 --> 07:21.150
Minutos

07:28.680 --> 07:31.600
de segundos en caso de

07:37.280 --> 07:45.600
que pudiera salir dentro de una línea, pero no todos, solo hazlo así S. C D y L K así que esto es solo yo formateando la salida.

07:48.320 --> 07:54.820
Nada más realmente

07:54.850 --> 07:56.260
Sigamos adelante y construyamos y ejecutemos milisegundos después de que comenzó la computadora.

07:56.440 --> 08:03.090
Es el Spenny.

08:03.210 --> 08:04.720
Y luego, a continuación, tenemos una conversión a formato legible para las personas a las siete horas, 20 minutos y 31 segundos.

08:05.070 --> 08:12.620
Una medida bastante precisa.

08:12.750 --> 08:14.340
Si hubiera si hubiera un resto

08:14.340 --> 08:18.540
de milisegundos, creo que podríamos ubicarlo aquí también, pero ese no es el formato que estábamos buscando.

08:18.540 --> 08:22.200
Simple como eso.

08:22.200 --> 08:22.960
Vemos que podemos obtener información útil de la API de Windows.

08:23.040 --> 08:27.120
También hemos aprendido el tipo de palabra D que está aquí.

08:27.150 --> 08:31.980
Sugeriría que lo lean más sobre las EMI,

08:31.980 --> 08:41.020
y la API de Windows contiene una gran cantidad de estos tipos que son sincrónicos.

08:41.020 --> 08:43.380
Para algunos tipos de C C ++ también.

08:43.380 --> 08:45.990
La palabra está parada.

08:46.000 --> 08:47.280
Me refiero

08:47.320 --> 08:57.870
a que el atajo básicamente significa doble palabra y palabra, así que la palabra doble y la palabra es básicamente eso.

08:57.960 --> 08:58.620
La palabra es un doble extremo y eso es en realidad un int sin signo.

08:58.830 --> 09:06.880
Bastante simple como eso.

09:06.910 --> 09:10.200
Como dije, te he dado una nube de esa explicación desordenada de lo que es la palabra.

09:10.240 --> 09:17.890
Pero te recomendaría encarecidamente que salgas a la red e ingreses a la zona desmilitarizada (DMZ).

09:18.130 --> 09:24.270
Está muy bien escrito.

09:24.280 --> 09:26.540
No hay dificultades para que realmente lo atraviese.

09:26.560 --> 09:30.200
Por cierto, el registro de teclas que he escrito en el registro de

09:30.280 --> 09:34.990
teclas, por supuesto, se escribió a través del uso de las funciones de la API de Windows.

09:34.990 --> 09:40.490
Por qué.

09:40.810 --> 09:41.390
Bien,

09:41.440 --> 09:49.870
¿por qué escribirías funciones personalizadas con las bibliotecas de encabezados personalizados del registrador de teclas que crearían dependencias adicionales?

09:49.870 --> 09:51.640
Tendría que tener esas bibliotecas y eso podría ser problemático.

09:51.640 --> 09:55.290
¿Por qué no utilizar las bibliotecas existentes en

09:55.360 --> 10:02.620
Windows y hacer que funcionen para usted de la manera que usted desea que funcionen?

10:03.480 --> 10:04.590
Además de obtener un

10:04.660 --> 10:12.280
sitio de un proyecto simplificado y hacerlo mucho más fácil, también tiene un doble efecto doble, por lo que el registrador de teclas tiene un mayor

10:12.280 --> 10:18.100
nivel de sigilo, por así decirlo, porque no usa nada, no lo está haciendo. usar algo fuera de lo común

10:18.100 --> 10:23.830
es usar casi las mismas cosas que la mayoría de las otras aplicaciones en el sistema también están usando.

10:23.830 --> 10:27.930
Y más o menos de la misma manera, es por eso que es tan difícil de detectar.

10:27.940 --> 10:33.900
De todos modos, es bueno despedirse aquí y espero que nos veamos en el tutorial de seguimiento.

10:34.090 --> 10:39.200
&nbsp;
