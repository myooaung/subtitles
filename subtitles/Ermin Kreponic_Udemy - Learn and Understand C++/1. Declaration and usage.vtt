WEBVTT

1
00:00:00.021 --> 00:00:01.025
Welcome back!

2
00:00:01.511 --> 00:00:04.981
Today, we are going to go ahead and begin
a new chapter.

3
00:00:05.391 --> 00:00:09.310
In this chapter, I will envelope the
basics of arrays.

4
00:00:09.476 --> 00:00:10.480
So, that is one of the concepts,

5
00:00:10.641 --> 00:00:12.640
which I have introduced
in the previous chapter.

6
00:00:12.801 --> 00:00:14.330
Just briefly, I mentioned it.

7
00:00:14.696 --> 00:00:19.680
But let's go ahead and take a look at
what arrays really are because you will

8
00:00:19.841 --> 00:00:21.200
be dealing a lot with them

9
00:00:21.361 --> 00:00:25.440
and you will need them
for a lot of things, believe me.

10
00:00:27.840 --> 00:00:32.440
So, as we introduce arrays in C++,
let's go ahead and say what they actually

11
00:00:32.601 --> 00:00:37.340
are so arrays by definition are
basically data structures

12
00:00:37.570 --> 00:00:39.360
that contain a number

13
00:00:39.705 --> 00:00:43.005
of easily accessible elements of the same
type.

14
00:00:43.420 --> 00:00:48.206
Now, here we talk about one
dimensional arrays.

15
00:00:48.456 --> 00:00:52.476
But we will cover advanced part
in later tutorials.

16
00:00:55.376 --> 00:00:56.030
So,

17
00:00:56.540 --> 00:00:58.050
the concept is

18
00:00:58.211 --> 00:01:04.560
basically to have all these elements
stored in a sequence of some sort

19
00:01:04.721 --> 00:01:07.595
and then be able to access them
by some sort of a reference

20
00:01:07.961 --> 00:01:12.480
Though very often we are required to group
a number of variables of the same type

21
00:01:12.641 --> 00:01:15.210
into one logical unit.

22
00:01:15.811 --> 00:01:16.488
So,

23
00:01:16.971 --> 00:01:22.186
For example, a student grade
cars some numbers that represents

24
00:01:22.516 --> 00:01:23.560
some parameters

25
00:01:23.961 --> 00:01:26.040
etc so if you have certain grades

26
00:01:26.201 --> 00:01:29.115
you would need them all
to be in one logical unit,

27
00:01:29.301 --> 00:01:31.835
which an array can actually provide you
with.

28
00:01:32.436 --> 00:01:35.720
Arrays are basically homogenous data
structures

29
00:01:35.881 --> 00:01:39.265
because all elements are of the same
type.

30
00:01:41.446 --> 00:01:45.520
Let's go ahead and dive into the very
first section here.

31
00:01:45.681 --> 00:01:46.831
So, I just go ahead and

32
00:01:46.995 --> 00:01:49.360
New,

33
00:01:50.546 --> 00:01:52.040
yes a project,

34
00:01:53.006 --> 00:01:54.680
Console application go

35
00:01:55.725 --> 00:01:57.026
Really should click skip

36
00:01:59.835 --> 00:02:00.856
Arrays,

37
00:02:02.505 --> 00:02:03.181
ok next,

38
00:02:03.571 --> 00:02:05.240
finished.

39
00:02:06.660 --> 00:02:07.521
So

40
00:02:07.685 --> 00:02:08.635
let's

41
00:02:08.796 --> 00:02:09.518
have actually

42
00:02:09.680 --> 00:02:10.400
now this

43
00:02:10.561 --> 00:02:12.655
this is becoming somewhat useful.

44
00:02:13.486 --> 00:02:14.648
You're going to remove this

45
00:02:14.810 --> 00:02:15.556
and

46
00:02:16.851 --> 00:02:17.505
this.

47
00:02:20.311 --> 00:02:24.880
In declaring an array, you will require
a following syntax,

48
00:02:25.041 --> 00:02:29.995
I'm sure that it is relatively familiar
to you. You are required to define a type

49
00:02:30.276 --> 00:02:33.080
and then you need an

50
00:02:34.731 --> 00:02:39.470
Array name and then after
the array name you would need a size.

51
00:02:39.861 --> 00:02:42.490
So, size is a relative term.

52
00:02:42.671 --> 00:02:43.640
It doesn't necessarily...

53
00:02:43.801 --> 00:02:46.970
you can define here.
You can simply initialize an array to

54
00:02:47.131 --> 00:02:51.660
a certain amount of elements and that
is going to define the size as well.

55
00:02:53.146 --> 00:02:54.400
So, what we want to do is,

56
00:02:54.561 --> 00:02:57.860
this was pseudo code.
Let's just go ahead and clear an array.

57
00:02:58.251 --> 00:03:00.020
This is just a

58
00:03:00.226 --> 00:03:03.456
declaration of an array. This is without
an initialization

59
00:03:03.686 --> 00:03:05.371
arr1

60
00:03:05.661 --> 00:03:07.730
Let's call it like that.

61
00:03:08.166 --> 00:03:12.560
The size of this array will be 10.
So it has the potential to contain,

62
00:03:12.721 --> 00:03:14.110
to store

63
00:03:14.276 --> 00:03:15.960
ten elements.

64
00:03:16.246 --> 00:03:18.805
Non of these elements for the time being
are

65
00:03:19.036 --> 00:03:20.570
initialized.

66
00:03:20.731 --> 00:03:22.160
So,

67
00:03:23.281 --> 00:03:25.491
I can do this as well

68
00:03:25.696 --> 00:03:27.650
float arr2

69
00:03:28.066 --> 00:03:33.686
Let's go ahead and give this one a size
of three. This is not initialization.

70
00:03:33.896 --> 00:03:37.660
We're just defining how many
elements does array need to contain.

71
00:03:38.051 --> 00:03:39.120
and with this

72
00:03:39.281 --> 00:03:40.141
basic part,

73
00:03:40.301 --> 00:03:44.280
let's take it that an array does need
a defined size,

74
00:03:44.441 --> 00:03:46.840
prior to its usage.

75
00:03:47.001 --> 00:03:48.640
So you need to define the size
fo the array.

76
00:03:48.846 --> 00:03:50.685
There are ways of

77
00:03:51.121 --> 00:03:52.540
not defining

78
00:03:54.025 --> 00:03:55.791
There are ways of

79
00:03:56.066 --> 00:03:58.045
not putting a fix number here

80
00:03:58.576 --> 00:04:03.385
and actually have an array that
is dynamic.

81
00:04:04.336 --> 00:04:07.380
So, this will be done later on, on the
advanced course

82
00:04:07.561 --> 00:04:10.000
because we're going to need pointers
and trust me

83
00:04:10.161 --> 00:04:11.160
at a certain point of time,

84
00:04:11.321 --> 00:04:14.160
you will need arrays
that whose sizes are not fixed.

85
00:04:14.321 --> 00:04:20.360
Who's sizes can change and alter.
So you can basically store in theory

86
00:04:20.521 --> 00:04:22.280
an infinite amount of elements.

87
00:04:23.236 --> 00:04:25.480
Anyway, so something scalable.
Let's put it like that.

88
00:04:25.641 --> 00:04:26.720
But that's all for the later part,

89
00:04:26.881 --> 00:04:30.410
For the time being,
I just take it that arrays need to have

90
00:04:30.736 --> 00:04:32.520
fixed sizes.

91
00:04:32.776 --> 00:04:35.400
And that's how they're usually used
in the very beginning

92
00:04:35.561 --> 00:04:39.445
of things, and later on as well people
tend to put fixed sizes as well.

93
00:04:40.046 --> 00:04:44.735
So, each elements of an array can be
accessed by a particular index.

94
00:04:44.896 --> 00:04:48.360
But we have to be careful since
the indexing in arrays

95
00:04:48.776 --> 00:04:52.680
I remember mentioning this somewhere
along the merry way, that indexing in

96
00:04:52.841 --> 00:04:54.956
arrays starts from 0.

97
00:04:55.116 --> 00:04:56.811
So, the first element

98
00:04:56.995 --> 00:04:58.831
is not indexed with one.

99
00:04:58.991 --> 00:05:01.440
It is indexed with a 0.

100
00:05:01.986 --> 00:05:03.290
So, if you

101
00:05:04.006 --> 00:05:08.280
will go ahead and do initialization to
demonstrate this. So let's go ahead and

102
00:05:08.651 --> 00:05:11.320
do it like this. arr1

103
00:05:12.205 --> 00:05:13.321
element0

104
00:05:13.921 --> 00:05:15.840
shall be 5.

105
00:05:16.500 --> 00:05:18.451
So, this is the first element,

106
00:05:18.821 --> 00:05:19.870
of the array.

107
00:05:20.376 --> 00:05:22.440
You can also, you don't need to initialize
them

108
00:05:22.601 --> 00:05:26.065
in any particular order you can initialize
them in any order you like.

109
00:05:26.481 --> 00:05:29.830
So arr1, again

110
00:05:30.361 --> 00:05:31.015
at element

111
00:05:31.221 --> 00:05:31.805
4

112
00:05:32.196 --> 00:05:34.425
element at position, index 4.

113
00:05:34.586 --> 00:05:37.720
Sorry not element 4, element at index
4.

114
00:05:38.371 --> 00:05:40.605
shall be equal I don't know to 10
let's say.

115
00:05:41.806 --> 00:05:42.600
and

116
00:05:42.901 --> 00:05:43.945
element at

117
00:05:44.106 --> 00:05:47.600
position 9,

118
00:05:48.191 --> 00:05:49.565
Shall

119
00:05:49.726 --> 00:05:50.681
be equal to

120
00:05:51.071 --> 00:05:53.480
100, let's put it like that.

121
00:05:54.206 --> 00:05:54.815
So,

122
00:05:56.136 --> 00:05:57.971
This is basically the last element.

123
00:05:58.411 --> 00:06:01.755
Why, because indexing begins at zero.

124
00:06:01.916 --> 00:06:03.751
Let's count 0 1 2 3

125
00:06:03.911 --> 00:06:06.515
4 5 6 7 8 9

126
00:06:06.676 --> 00:06:07.721
10 numbers.

127
00:06:08.301 --> 00:06:11.800
So, the size of the array is indeed 10.

128
00:06:13.410 --> 00:06:15.221
It is also important to mention

129
00:06:15.430 --> 00:06:16.196
that

130
00:06:16.476 --> 00:06:20.355
the compiler won't warn us and nor
it can

131
00:06:20.721 --> 00:06:26.345
if we access memory locations that are
outside of the range of our array

132
00:06:26.851 --> 00:06:28.360
but this locations are

133
00:06:28.526 --> 00:06:32.405
called pits basically and they are not
easily detected.

134
00:06:32.656 --> 00:06:35.355
Because the program can run out in

135
00:06:36.025 --> 00:06:36.886
8

136
00:06:37.881 --> 00:06:39.625
out of 10 cases basically.

137
00:06:40.666 --> 00:06:43.710
And because the program can run out in
8 out of 10 cases sorry.

138
00:06:44.360 --> 00:06:46.985
and in other two it doesn't actually
run.

139
00:06:47.146 --> 00:06:48.216
What do I mean by this?

140
00:06:48.540 --> 00:06:50.538
Well, if you have an array 1,

141
00:06:50.700 --> 00:06:52.676
and it has a size of 10,

142
00:06:52.996 --> 00:06:54.996
and if you try to access like

143
00:06:55.481 --> 00:06:57.991
the 50th element of this array,

144
00:06:58.266 --> 00:06:59.036
which

145
00:06:59.616 --> 00:07:02.521
basically is outside of the bounds of
this array,

146
00:07:02.911 --> 00:07:04.425
the program

147
00:07:04.791 --> 00:07:06.350
as I said,

148
00:07:06.511 --> 00:07:09.960
it's going to run in 8 cases
out of ten.

149
00:07:10.436 --> 00:07:13.240
and it's not going to warn us. And it's
going to be a problem because

150
00:07:13.401 --> 00:07:15.060
it's going to read something from
memory

151
00:07:15.311 --> 00:07:16.846
location and

152
00:07:17.446 --> 00:07:19.166
it could read some sensitive information

153
00:07:19.326 --> 00:07:22.025
that's how the overflows occur,

154
00:07:22.346 --> 00:07:22.905
and

155
00:07:23.066 --> 00:07:26.480
it could also just read some
random junk, which could cause a lot

156
00:07:26.641 --> 00:07:28.105
of confusion in our logic.

157
00:07:28.361 --> 00:07:31.775
Because C++ in of itself does not do
boundary checking.

158
00:07:32.236 --> 00:07:38.395
So, this is a case in Java, you won't be
able to achieve this in Java but

159
00:07:40.386 --> 00:07:42.295
take everything that I say with the grain
of salt.

160
00:07:42.801 --> 00:07:45.280
But as I said this is not the case in
C++.

161
00:07:45.441 --> 00:07:48.640
That is one of the beauties
of the C++ language because

162
00:07:48.801 --> 00:07:52.320
it allows you to afford what you want to
do. There is no restrictions, restraints

163
00:07:52.485 --> 00:07:54.160
of whatsoever.

164
00:07:54.551 --> 00:07:56.295
So, let me just give you
one example

165
00:07:56.595 --> 00:07:59.846
that is out of range.

166
00:08:00.006 --> 00:08:01.890
so let's take away the float
arr2,

167
00:08:02.236 --> 00:08:03.816
whose size is 3.

168
00:08:03.976 --> 00:08:05.581
So, 0 1 2

169
00:08:06.646 --> 00:08:07.695
that's it. But if we say
that

170
00:08:07.856 --> 00:08:11.250
arr2 and we are
trying to initialize

171
00:08:11.666 --> 00:08:12.800
like

172
00:08:13.221 --> 00:08:15.040
element with index 3.

173
00:08:16.076 --> 00:08:17.261
11 so,

174
00:08:17.631 --> 00:08:21.905
arr2 has three elements and
the last one is

175
00:08:22.251 --> 00:08:24.560
this will be the last element.

176
00:08:26.406 --> 00:08:29.010
This will be the last element because
it goes like this, zero.

177
00:08:30.121 --> 00:08:30.775
1, 2

178
00:08:31.676 --> 00:08:33.305
but we are trying to initialize

179
00:08:33.466 --> 00:08:35.280
the third element to 11.

180
00:08:35.626 --> 00:08:40.760
The program can run correctly
but it is ill-formed program and

181
00:08:41.756 --> 00:08:44.440
it's bound to cause some problems.

182
00:08:44.601 --> 00:08:47.240
Because you do not know what's in that
memory location,

183
00:08:47.401 --> 00:08:49.350
you could be overwriting something

184
00:08:49.511 --> 00:08:52.950
that is imporant to the functioning of
your other programs or the system

185
00:08:53.156 --> 00:08:54.440
in general.

186
00:08:54.711 --> 00:08:56.480
So, that can be a problem because

187
00:08:57.266 --> 00:08:59.775
something could be located in that
memory location

188
00:09:00.101 --> 00:09:04.445
where you are putting this number
and that's basically

189
00:09:04.696 --> 00:09:07.560
important to the proper functioning
of your machine

190
00:09:07.721 --> 00:09:10.620
and you are basically deleting that
and putting number 11 there.

191
00:09:11.266 --> 00:09:14.516
So, when the machine needs
to access those resources. It goes there

192
00:09:14.680 --> 00:09:16.005
I have number 11 here.

193
00:09:16.166 --> 00:09:19.930
And it is supposed to be my pointer
or printer something like that.

194
00:09:21.275 --> 00:09:24.560
Just be aware of those things.

195
00:09:24.721 --> 00:09:28.170
This is like the very wrong way of
doing things and

196
00:09:28.331 --> 00:09:32.000
if you're reading from these locations
outside of the bounds of the array

197
00:09:32.161 --> 00:09:33.720
that is also a very wrong way

198
00:09:33.881 --> 00:09:35.161
of going about

199
00:09:35.416 --> 00:09:36.115
things.

200
00:09:36.366 --> 00:09:37.040
So anyway,

201
00:09:37.201 --> 00:09:40.011
we're going to cut it here and
we're going to go ahead

202
00:09:40.176 --> 00:09:44.160
and begin next tutorial where I'll
talk a bit more about the memory

203
00:09:45.446 --> 00:09:48.080
representation. It's going to be a fairly
short one.

204
00:09:48.241 --> 00:09:50.320
And just something I really need
to demonstrate

