WEBVTT

00:00:00.000 --> 00:00:03.043
Welcome back all.
Today were gonna go

00:00:03.068 --> 00:00:05.390
ahead and jump into
a chapter that we

00:00:05.490 --> 00:00:08.705
all deal with loops
in C++, now in this

00:00:08.730 --> 00:00:11.849
chapter we will learn
four different

00:00:11.849 --> 00:00:15.067
types of loops: for
while, do-while

00:00:15.092 --> 00:00:18.359
and for each. So
we will also learn

00:00:18.359 --> 00:00:24.140
another one, the so-called goto loop keep
in mind that I

00:00:24.140 --> 00:00:26.616
take this with a grain
of salt, let's put

00:00:26.641 --> 00:00:28.669
it like that's, not
exactly a loop but not

00:00:28.769 --> 00:00:33.070
exactly a not loop, however you wish to
look at it as I said we will look we

00:00:33.070 --> 00:00:36.372
will learn the so-called
goto loop which

00:00:36.397 --> 00:00:39.650
can be used for the
simulation off loops.

00:00:39.750 --> 00:00:44.719
Now, loops as a general concept is
present in pretty much all programming

00:00:44.719 --> 00:00:47.524
languages, they all
pretty much use loops in

00:00:47.549 --> 00:00:50.070
order to perform
repetitive tasks, like you

00:00:50.170 --> 00:00:52.684
have a chunk of code
which you would

00:00:52.709 --> 00:00:54.980
like to be repeated
over a set number of

00:00:54.980 --> 00:00:59.570
iterations and therefore you just go and
use a loop in order to make that

00:00:59.570 --> 00:01:02.370
possible. So that is
just a concept that

00:01:02.395 --> 00:01:05.260
is used widely across
pretty much all

00:01:05.360 --> 00:01:07.780
programming languages,
but here I'm gonna

00:01:07.805 --> 00:01:10.200
go ahead and show you
how you can use these

00:01:10.200 --> 00:01:14.828
various types of loops
in C++ the four

00:01:14.853 --> 00:01:19.809
regions also is primarily
for C++ 11 so I'm

00:01:19.909 --> 00:01:22.150
just gonna go out
and create a new

00:01:22.175 --> 00:01:24.240
project, you might
notice that my taskbar

00:01:24.340 --> 00:01:26.990
is gone down below.

00:01:26.990 --> 00:01:30.522
Well, I didn't really
need so I just hit it.

00:01:30.547 --> 00:01:33.610
Let's hit it down below
it, it should pop

00:01:33.710 --> 00:01:36.668
when I touch the bottom
with my mouse but

00:01:36.693 --> 00:01:39.470
oh well, anyway console
application this

00:01:39.570 --> 00:01:42.491
was by the way complete
irrelevant for the course,

00:01:42.516 --> 00:01:45.110
let's go ahead and
click on Next C++ sure

00:01:45.210 --> 00:01:47.880
this is going to be
chapter 4 that's how I'm

00:01:47.905 --> 00:01:50.500
naming them, you can
name them any way you

00:01:50.500 --> 00:01:53.671
like, chapter for loops,
Ok, so next finish,

00:01:53.696 --> 00:01:56.969
excellent. One of
these days I'm gonna

00:01:56.969 --> 00:01:59.610
fix this I don't think it matters that
much really.

00:01:59.610 --> 00:02:01.946
come and zoom it for
me, thank you very

00:02:01.971 --> 00:02:04.090
much! So, let's go
ahead and start, let's

00:02:04.190 --> 00:02:07.150
begin wit one example
we will write a

00:02:07.175 --> 00:02:10.110
program that prompts
the user to input a

00:02:10.110 --> 00:02:14.101
number and then asks
the user to input

00:02:14.126 --> 00:02:17.440
and numbers in the end
it basically just

00:02:17.440 --> 00:02:23.510
how puts the sum of those numbers so
might seem a little bit confusing when I

00:02:23.510 --> 00:02:26.022
put it like this, but
you will see it is

00:02:26.047 --> 00:02:28.430
extremely simple, so
just go ahead and

00:02:28.430 --> 00:02:36.270
include iostream so input output iostream the
library here, and that's it

00:02:36.870 --> 00:02:44.750
int, main and go down below int 10,
this will be our integer variable that

00:02:48.450 --> 00:02:53.921
will hold the number
that the user enters as

00:02:53.946 --> 00:02:58.550
input. Ok should use from
the std namespace, cout

00:02:58.650 --> 00:03:03.450
and enter and no need
for the next line,

00:03:03.475 --> 00:03:08.650
we wanted to all to
be in the same line

00:03:08.650 --> 00:03:11.138
see we have a semicolon
and then a space

00:03:11.163 --> 00:03:13.530
and then we'll be able
to enter a number

00:03:13.530 --> 00:03:19.059
and down below std
colon colon, cin, n,

00:03:19.084 --> 00:03:24.380
semicolon, hopefully
by now you know what

00:03:24.380 --> 00:03:28.790
these are, the operators, anyway

00:03:29.690 --> 00:03:35.019
semicolon here and in here, that's gonna we have
instructed user

00:03:36.260 --> 00:03:41.286
we've instructed the
user here, your we've

00:03:41.311 --> 00:03:46.310
told the user basically:
Hey do that. So

00:03:46.410 --> 00:03:50.659
we've told user here
to enter a number

00:03:50.684 --> 00:03:54.810
n or just enter n and down below

00:03:54.810 --> 00:03:57.761
enter, int, n, let's
put it like this, so

00:03:57.786 --> 00:04:00.590
the user knows it's an integer.
Here she

00:04:00.590 --> 00:04:06.010
needs to put, anyway and down below we
have provided a method for the user to

00:04:06.010 --> 00:04:09.010
actually be able to input

00:04:09.010 --> 00:04:14.739
whatever has been asked
to that user to basically input that

00:04:14.739 --> 00:04:20.199
integer. Anyway, we will go ahead and need
to

00:04:20.199 --> 00:04:24.012
declare a variable
called some, so 0 here

00:04:24.037 --> 00:04:27.900
and we need to initialize
it to 0, so it

00:04:27.900 --> 00:04:33.880
must and I mean it must in this case be
initialize to 0 as it can cause some

00:04:33.880 --> 00:04:38.139
serious problems if it is not
initialized, it's not the compiler is not

00:04:38.139 --> 00:04:41.104
going to report any
problems, however it will

00:04:41.129 --> 00:04:44.010
be one of those logic
errors on the users

00:04:44.010 --> 00:04:46.719
and you might not get
what you want to get

00:04:46.744 --> 00:04:49.370
I will explain why
in the moment when

00:04:49.370 --> 00:04:56.760
we actually get to that portion. I'm typing
today is amazing.

00:04:57.919 --> 00:05:04.970
Anyway, for this is going to be an
example of a for loop so int I we can

00:05:04.970 --> 00:05:09.660
declare another variable here and that
variable holds it has declared for the

00:05:09.660 --> 00:05:14.490
scope of the loop, beyond the loop it is
not, no you can literally declare and

00:05:14.490 --> 00:05:16.788
I again outside of
the loop without any

00:05:16.813 --> 00:05:19.590
problems, however
once declared outside

00:05:19.690 --> 00:05:22.333
of the loop then
it's a completely

00:05:22.358 --> 00:05:24.400
different matter. So
it's less than or

00:05:24.500 --> 00:05:32.209
equal to n an it's going
to be plus plus I. okay

00:05:32.834 --> 00:05:40.560
so, our loop it's going to
start from one I stands

00:05:41.860 --> 00:05:44.511
for index or iterator
or however you

00:05:44.536 --> 00:05:46.590
want to call it, you
don't need to use I

00:05:46.690 --> 00:05:49.252
you could have used
pretty much any name

00:05:49.277 --> 00:05:51.590
any legit variable
name here instead of

00:05:51.590 --> 00:05:54.737
I so it's not a big
deal but general

00:05:54.762 --> 00:05:57.693
standard practices to use I J K

00:05:58.389 --> 00:06:01.690
those three but you can use pretty much
whatever you want it doesn't matter

00:06:02.490 --> 00:06:05.250
suited it, you can
get your convenience

00:06:05.275 --> 00:06:07.830
let's put it like
that, anyway our for

00:06:07.830 --> 00:06:10.706
loop, it starts from
number one so I has

00:06:10.731 --> 00:06:13.520
been initialized to
one, we could have

00:06:13.520 --> 00:06:16.840
initialized that whatever we wanted to
initialize it really doesn't matter

00:06:17.650 --> 00:06:24.940
and then it goes to end I will continue
to increase here until this condition is

00:06:27.740 --> 00:06:31.529
satisfied. So for
as long as I is

00:06:31.554 --> 00:06:35.060
lesser or equal to
end, this here will

00:06:35.060 --> 00:06:39.270
evaluate to true and there for whatever
is within the body of

00:06:39.270 --> 00:06:42.135
the loop of the for
loop will execute or

00:06:42.160 --> 00:06:44.479
keep executing over
the each iteration,

00:06:44.479 --> 00:06:47.605
once this condition
here becomes false,

00:06:47.630 --> 00:06:50.669
then whatever is
within the body of the

00:06:50.669 --> 00:06:57.240
loop will cease and the loop will itself
terminate as well, of course this is if we

00:06:57.240 --> 00:07:04.690
input can put ten for
example, I is one so one is lesser or

00:07:04.690 --> 00:07:12.600
equal to ten yes ok it's rated by one
and I don't know do whatever we would

00:07:15.000 --> 00:07:17.231
do whatever else
we tell you to do

00:07:17.256 --> 00:07:19.330
basically but eventually
over the course

00:07:19.330 --> 00:07:23.208
of iterations I
will become two and

00:07:23.233 --> 00:07:26.990
that it will become
345678910 then it

00:07:26.990 --> 00:07:30.225
will become 11 and
11 will no longer be

00:07:30.250 --> 00:07:33.240
less or equal to n,
so this number is

00:07:33.240 --> 00:07:40.800
the basically the amount of repetitiveness for this loop, within the loop we shall

00:07:40.800 --> 00:07:43.800
declare int, number

00:07:46.039 --> 00:07:52.585
std, colon colon, cout,
and we should do this

00:07:52.610 --> 00:07:58.354
enter and let's put a
semicolon, why not

00:08:00.830 --> 00:08:06.700
I, dot, number

00:08:07.380 --> 00:08:11.145
semicolon and there we go,
it's closed and let's

00:08:11.170 --> 00:08:14.180
provide a way for the
user to actually input

00:08:14.180 --> 00:08:18.372
something, std, colon
colon, previously of state

00:08:18.397 --> 00:08:22.420
like let's provide a
method for user to input

00:08:22.420 --> 00:08:27.390
something I mean methods are
something completely different in C++ we

00:08:27.390 --> 00:08:32.150
will get to that, is just a way of my
expressions that give you a bit

00:08:32.150 --> 00:08:33.983
confusing but just provide a way

00:08:34.008 --> 00:08:36.040
for users to
basically just input

00:08:36.040 --> 00:08:41.880
something so get that number and what
will happen here is that the loop will

00:08:41.880 --> 00:08:48.480
repeat for as many times as we have
specified with the n here which way

00:08:48.480 --> 00:08:51.785
the user basically input
it and down the loop

00:08:51.810 --> 00:08:55.220
on every iteration of
the loop, the user

00:08:55.320 --> 00:09:03.140
will be prompted to enter oops sorry my
apologies on every iteration of the loop

00:09:07.140 --> 00:09:13.930
the user will be prompted to actually
enter a certain number and that number

00:09:13.930 --> 00:09:16.283
the way for importing
that number has

00:09:16.308 --> 00:09:18.500
been provided here,
so every time this

00:09:18.500 --> 00:09:25.160
loop repeats the user will be prompted.
Ok please enter a number and you will

00:09:25.160 --> 00:09:27.075
see it will be printed
out on the screen

00:09:27.100 --> 00:09:28.790
every time we actually
input the number

00:09:28.790 --> 00:09:30.397
depending on how
many times we have

00:09:30.422 --> 00:09:32.410
specified as we want
the loop to repeat

00:09:32.510 --> 00:09:35.510
itself and now we come to the point of sum

00:09:35.510 --> 00:09:40.690
and I will show you here and demonstrate why
actually show you why we need to

00:09:40.690 --> 00:09:44.405
initialize sum to 0, it's rather

00:09:44.430 --> 00:09:48.120
simple, so let's use
this format here

00:09:48.120 --> 00:09:50.640
let's just put it like this,

00:09:50.640 --> 00:09:57.096
I'll tell you why.
Ok so sum we have

00:09:57.121 --> 00:10:02.630
declare it here in
sum, now imagine if

00:10:02.630 --> 00:10:07.550
we didn't know imagine if we didn't
actually initialize it to anything, what

00:10:07.550 --> 00:10:10.970
does that mean? Well variable sum

00:10:10.970 --> 00:10:13.481
would have been
created and it would

00:10:13.506 --> 00:10:16.050
have occupied a certain
space in ram, so

00:10:16.050 --> 00:10:18.186
whatever was in
that space prior to

00:10:18.211 --> 00:10:20.269
the creation of this
variable, would

00:10:20.269 --> 00:10:25.790
would become the content of
this variable and then when we would get

00:10:25.790 --> 00:10:30.660
to this point here, the content of that
variable, would actually be to that

00:10:30.660 --> 00:10:33.425
content, this number
wouldn't have been

00:10:33.450 --> 00:10:35.829
add, so we would get
something completely

00:10:35.829 --> 00:10:41.160
different other than the sum of numbers
that we wanted so imagine, just

00:10:41.160 --> 00:10:48.019
imagine that you had some like an x
and some random things here and

00:10:50.819 --> 00:10:55.560
just some random random information here
that has been I don't know perhaps the

00:10:55.560 --> 00:10:59.790
variable from the previous program or
something like that etc, some

00:10:59.790 --> 00:11:04.089
random value, that would have been a
problem because then we will be

00:11:04.089 --> 00:11:09.569
calculating the sum of a certain amount
of numbers and we would have been adding

00:11:09.569 --> 00:11:16.019
that random value to that sum, therefore
that some would not be accurate

00:11:16.589 --> 00:11:21.420
therefore we have ensured that that
mistake will not happen by simply

00:11:21.420 --> 00:11:27.970
initializing the sum to 0 variable sum
to 0 and therefore everything will be just

00:11:27.970 --> 00:11:30.449
be added to 0, there
will be no third party

00:11:30.474 --> 00:11:32.539
values that will be
added into the full

00:11:32.639 --> 00:11:38.129
factory into our sum. Anyway, there's no
need to write it like this, this is the

00:11:38.129 --> 00:11:45.709
long version, you can simply do this to
this, plus and there we go,

00:11:45.709 --> 00:11:47.992
So this is basically
the same as what

00:11:48.017 --> 00:11:50.370
we have just written,
so some equal

00:11:50.370 --> 00:11:53.629
sum + number is the
same as sume + equals

00:11:53.654 --> 00:11:56.950
number. Exactly you
see things just

00:11:57.050 --> 00:12:00.990
written in a different fashion I would
always advise you to use this format as

00:12:00.990 --> 00:12:04.113
it is, I mean it's
just shorter to write

00:12:04.138 --> 00:12:07.170
and it's quite
easy to comprehend

00:12:07.170 --> 00:12:12.850
and understand for anybody who knows
what they're looking at. Ok, so let's go

00:12:12.850 --> 00:12:15.850
ahead and type in std, colon colon, cout

00:12:16.370 --> 00:12:22.946
and some of, n, I
don't know n numbers,

00:12:27.771 --> 00:12:34.610
I'm just placing n ok
entered numbers is

00:12:38.110 --> 00:12:41.110
gotta love my notes.

00:12:43.420 --> 00:12:49.835
std colon colon, endl
and semicolon, ok

00:12:49.860 --> 00:12:56.110
sum, n, entered numbers
is and then of

00:12:56.110 --> 00:12:59.952
course the sum and
we're gonna go and

00:12:59.977 --> 00:13:04.240
move on into a new
line in order to make

00:13:04.240 --> 00:13:08.509
this in order to
make this simpler so

00:13:08.534 --> 00:13:12.690
let's go ahead and
type in return 0,

00:13:12.690 --> 00:13:18.580
do I have it? No. 0 let's go ahead and see
what happens? what's gonna

00:13:18.580 --> 00:13:26.220
transpire here there's gonna be an error
that's interesting that happens I wonder

00:13:26.220 --> 00:13:34.070
what the problem is here ok there is a
semicolon my good man why are you

00:13:34.270 --> 00:13:42.010
reporting that there is expected
semicolon before string constant, let me just

00:13:45.510 --> 00:13:46.670
take a look at it.

00:13:46.670 --> 00:13:53.711
CPP line 7 is this the semicolon?
certainly

00:13:53.736 --> 00:14:00.344
looks like it. std,
cout, ok, or right,

00:14:01.610 --> 00:14:04.610
operated here

00:14:07.810 --> 00:14:12.517
So it says enter int n 10.
I don't know,

00:14:12.542 --> 00:14:17.460
let's say that it's
10, and now we have

00:14:17.460 --> 00:14:21.580
some random number that we need to
enter and this is exactly what I was

00:14:21.580 --> 00:14:29.480
talking about, it says here enter,
you see it says enter and the number

00:14:30.080 --> 00:14:33.176
have I initialized number to anything?
no I have

00:14:33.201 --> 00:14:35.900
not and yet there is
this strange value here

00:14:35.900 --> 00:14:40.089
so it's just a random thing from memory
no big deal

00:14:41.180 --> 00:14:43.948
instead we shall change
this in order to make

00:14:43.973 --> 00:14:46.540
it a little bit different,
we don't need to

00:14:46.540 --> 00:14:50.180
initialize the number here because the
number will be initialized here once the

00:14:50.180 --> 00:14:52.438
user makes an input
but we can tell the

00:14:52.463 --> 00:14:54.560
user which number
in line do we want

00:14:54.560 --> 00:15:01.824
him to enter, so enter,
I can't actually, it

00:15:03.649 --> 00:15:11.120
would vary from, I wanted
to rightly first or

00:15:11.120 --> 00:15:13.644
second, third, four,
but no, I'm gonna

00:15:13.669 --> 00:15:16.230
place a dot there and I.
And now, we're

00:15:16.230 --> 00:15:20.717
gonna have to take a
look at this so enter

00:15:20.742 --> 00:15:24.950
n and then enter first number.
Ok so

00:15:24.950 --> 00:15:32.220
that makes sense right? It says here enter
first number, let the first number be 1

00:15:32.220 --> 00:15:40.070
we can also enter interesting numbers 2145 I
don't know 10 11 12 13 I don't know

00:15:48.970 --> 00:15:53.622
let's add it. So the sum
of ten entered numbers

00:15:53.647 --> 00:15:59.050
is sixty, there you go,
the program did let's see

00:15:59.050 --> 00:16:06.459
it's indeed 60, 12459 1424 3547

00:16:14.889 --> 00:16:20.829
50, yeap, 60 up there you go, so it is indeed 60 if you don't believe me, you can just go

00:16:20.829 --> 00:16:25.499
ahead and calculate it yourself or use a
calculator or whatever in order to

00:16:25.499 --> 00:16:30.925
figure it out. So
let's go ahead and

00:16:30.950 --> 00:16:36.230
do a bit of recap,
there are some

00:16:36.230 --> 00:16:40.498
things that I do need
to explain, for example

00:16:40.523 --> 00:16:44.169
this one this part,
let's actually let's

00:16:44.169 --> 00:16:46.684
just use some sort
of code here, for I

00:16:46.709 --> 00:16:49.100
just wanna make sure
that you understand

00:16:49.100 --> 00:16:56.749
this for loops it is very important, you
have the initializer, ups, and then you

00:16:57.449 --> 00:17:05.209
have the separator here and then the
condition and then the increment, down

00:17:06.909 --> 00:17:09.651
below you of course
have the body that

00:17:09.676 --> 00:17:12.510
is the body's basically
the code that's

00:17:12.510 --> 00:17:17.409
gonna get repeated, it will get repeated
so the initializer this is our

00:17:17.409 --> 00:17:23.209
initializer here, the condition, this is the
condition here and you have the

00:17:23.209 --> 00:17:25.849
increment and our
increment is here, let me

00:17:25.874 --> 00:17:28.909
just go ahead and talk
a little bit that

00:17:28.909 --> 00:17:33.500
about the increment, I've already explained
that whether the loop will continue or

00:17:33.500 --> 00:17:37.299
not depends on the condition in the
center and that condition will

00:17:37.299 --> 00:17:42.220
eventually change for false to true
because the initializer is

00:17:42.220 --> 00:17:47.000
changing which is the integral part of
the condition, the condition is dependent

00:17:47.000 --> 00:17:52.480
on I actually being less or equal to n, in
sense that the value of I is

00:17:52.480 --> 00:17:54.877
continuously increasing
it is safe to

00:17:54.902 --> 00:17:56.980
assume that at a certain
point in time I

00:17:56.980 --> 00:18:01.399
will become greater than n and this
condition will evaluate to false

00:18:03.429 --> 00:18:07.201
increment this last
part, it controls the

00:18:07.226 --> 00:18:11.130
loop steps that is
in each iteration

00:18:11.130 --> 00:18:16.769
the variable I is incremented, now in this
particular case it is incremented by one

00:18:16.769 --> 00:18:20.460
and we could have written this in
various formats, we could have written

00:18:20.460 --> 00:18:23.848
I equals I + one,
this was also one of

00:18:23.873 --> 00:18:27.310
the possibilities,
I mean we wouldn't

00:18:27.310 --> 00:18:31.915
actually change
anything and we could

00:18:31.940 --> 00:18:36.520
have also written this,
one so you would

00:18:36.520 --> 00:18:40.310
usually use this format if you wanted to
add a number that is greater than one

00:18:40.310 --> 00:18:48.270
but if you just want to add one, you can
use I + + or ++ I they're all

00:18:48.670 --> 00:18:53.900
pretty much the same, however if the
loop variable is being incremented

00:18:53.900 --> 00:19:01.010
by one, this is a preferable

00:19:01.010 --> 00:19:02.300
thing, let's put it like that,

00:19:02.300 --> 00:19:08.220
keep in mind that I ++ and ++ I
is not the same in expression, but

00:19:08.220 --> 00:19:16.080
inside the for loop it is, so if you use this an
expression like I ++, ++ I

00:19:17.380 --> 00:19:20.237
these would be two
different things, however

00:19:20.262 --> 00:19:22.790
if you use it in a
loop in a for loop

00:19:22.790 --> 00:19:28.400
here it doesn't matter, it is pretty much the same,

00:19:28.400 --> 00:19:30.892
we can also use the
control variable

00:19:30.917 --> 00:19:33.180
I inside the loop body as I

00:19:33.280 --> 00:19:35.992
stated in the very
beginning, in our

00:19:36.017 --> 00:19:38.300
example, we ask the
user for example to

00:19:38.300 --> 00:19:40.825
enter the first and then
the second and then the

00:19:40.850 --> 00:19:43.350
third and then the four,
this is very useful

00:19:43.350 --> 00:19:49.060
because this is increment in any way
right here and we can tell the user

00:19:49.060 --> 00:19:52.435
actually which number
to enter, so I bet you

00:19:52.460 --> 00:19:55.834
all farewell. I ran out
of time and I hope to

00:19:55.900 --> 00:19:57.670
see you in the follow up tutorial.