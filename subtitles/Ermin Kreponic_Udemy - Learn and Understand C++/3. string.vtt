WEBVTT

00:00:00.000 --> 00:00:03.742
Welcome back. So,
let's go ahead and

00:00:03.767 --> 00:00:07.259
talk a little bit
about type string it

00:00:07.259 --> 00:00:10.080
represents a
flexible and dynamic

00:00:10.105 --> 00:00:12.801
expansion of c like strings so c

00:00:12.900 --> 00:00:15.634
strings that we have
learned before they

00:00:15.659 --> 00:00:18.430
you can take that as
an example, this is a

00:00:18.430 --> 00:00:21.195
very important type
since it is used in

00:00:21.220 --> 00:00:23.720
almost all the programming
languages out

00:00:23.720 --> 00:00:26.466
there so the concept
that you learn here

00:00:26.491 --> 00:00:29.280
do not necessarily
only apply to C++ but

00:00:29.380 --> 00:00:34.079
pretty much to all the programming
languages out there, anyway the first

00:00:34.079 --> 00:00:37.780
thing that we will need
to do as before with all of these

00:00:37.780 --> 00:00:45.730
just gonna type in include string and
down below

00:00:47.190 --> 00:00:49.494
gonna go ahead and
take a look at what

00:00:49.519 --> 00:00:51.940
string actually is,
so first of all we

00:00:51.940 --> 00:00:58.840
need to declare and initialize the
standard things, let's go ahead and

00:00:58.840 --> 00:01:02.491
use string s1 equals
you can see in

00:01:02.516 --> 00:01:05.909
some example strings are usually

00:01:05.909 --> 00:01:12.159
referred to variables STR STR something
like that but for the sake of this demo

00:01:12.159 --> 00:01:19.119
I'm just gonna stay type in s1 equals how
is it

00:01:19.119 --> 00:01:23.850
going? let's
keep it simple

00:01:24.380 --> 00:01:27.972
"Hey" leave it like
that and then we can

00:01:27.997 --> 00:01:31.479
of course print this
out onto the screen

00:01:31.479 --> 00:01:36.100
just type in cout
you can actually see where this is going

00:01:36.100 --> 00:01:42.930
fairly similar endl and yeah there you go

00:01:42.930 --> 00:01:45.930
so this simply be printed out onto the
screen Hey

00:01:48.580 --> 00:01:50.783
you can put some text
here and then that text

00:01:50.808 --> 00:01:52.820
can be processed as a
stream pretty much

00:01:52.920 --> 00:01:57.234
anywhere else in the
code ok so you can

00:01:57.259 --> 00:02:01.370
also declare a string
object which is

00:02:01.470 --> 00:02:09.450
basically you can have more than one
word as you saw here with this one you

00:02:11.350 --> 00:02:14.214
there you saw one
word but if we go

00:02:14.239 --> 00:02:17.380
ahead and create
a s2 for example

00:02:17.380 --> 00:02:24.060
and say hey "how is it going" you can have
an entire sentence here in fact you can

00:02:24.060 --> 00:02:28.970
have an entire like text or whatever you
want, you can write pretty much whatever

00:02:28.970 --> 00:02:36.900
you want to write and you can also
do this, this would be

00:02:38.400 --> 00:02:45.672
the constructor
initialization let's be lazy

00:02:45.697 --> 00:02:51.519
again and utilize this,
so this is going to

00:02:51.519 --> 00:02:56.207
be s2 but let's printed
out again, hey how

00:02:56.232 --> 00:03:00.690
is it going? but then
again you will achieve

00:03:00.790 --> 00:03:04.329
the same result without these you
wouldn't have any problems there

00:03:04.329 --> 00:03:09.330
either see? hey how is it going?
so no

00:03:09.355 --> 00:03:14.174
worries there. Let me
just bring these back

00:03:17.680 --> 00:03:20.852
ok you are also entitled it is

00:03:20.877 --> 00:03:23.159
completely legal in
C++ to declare an

00:03:23.159 --> 00:03:27.500
empty string so std, string

00:03:28.349 --> 00:03:36.339
s3 that's it, do nothing else, this
is the same as string s4 equals this

00:03:40.639 --> 00:03:41.680
is empty

00:03:41.680 --> 00:03:43.748
this is also an empty
string these two

00:03:43.773 --> 00:03:45.619
concepts are exactly
the same you're

00:03:45.719 --> 00:03:49.424
declaring an empty
string, nothing else.

00:03:49.449 --> 00:03:54.130
Let's go ahead and
see the length of a

00:03:54.230 --> 00:03:56.667
string you can use
the dot size that

00:03:56.692 --> 00:03:58.900
will return the length
of a string, so

00:03:58.900 --> 00:04:02.650
why are we using unsing?

00:04:03.250 --> 00:04:06.250
well let me ask you something

00:04:06.889 --> 00:04:11.480
can a size of an array or an a string be
negative?

00:04:11.480 --> 00:04:15.269
can it be negative? I mean
you can have a certain amount of

00:04:15.269 --> 00:04:17.461
elements are you can
I have no elements

00:04:17.486 --> 00:04:19.810
but there is no way
that the size can be

00:04:19.810 --> 00:04:22.729
negative so why declare int? when it

00:04:22.729 --> 00:04:25.919
cannot be negative? just use unsingned int

00:04:25.919 --> 00:04:30.085
s1 underline size,
give it some arbitrary

00:04:30.110 --> 00:04:34.150
name here and we can type it s1

00:04:34.150 --> 00:04:38.680
dot size so what
is the size of s1?

00:04:38.705 --> 00:04:41.789
think about it, just count

00:04:41.789 --> 00:04:49.769
the letters it oh ok so they've
just had they just had it I no longer

00:04:58.669 --> 00:05:02.422
wish to socialize with me.
Anyway, let's

00:05:02.447 --> 00:05:05.569
go ahead and print
out the size of s1

00:05:05.669 --> 00:05:13.559
so s1_size printed
out onto the screen its 3 so: h:1, e:2

00:05:20.259 --> 00:05:23.406
and y:3 so 123, they're
3 elements, again,

00:05:23.431 --> 00:05:26.864
the indexing was the
same as before, no

00:05:27.360 --> 00:05:30.818
nothing nothing nothing
new about that so

00:05:30.843 --> 00:05:34.199
do you have 3 elements,
just counting 123

00:05:34.199 --> 00:05:38.774
basically just count
the letters its

00:05:38.799 --> 00:05:43.360
123 etc just count
them as they are

00:05:43.460 --> 00:05:46.658
basically just counting
the letters in a

00:05:46.683 --> 00:05:49.710
word in a sentence for
any sentences but

00:05:49.710 --> 00:05:52.710
hey, how many

00:05:53.919 --> 00:05:57.465
let me just reformule
this: hey t how what

00:05:57.490 --> 00:06:01.169
is the size of the array?
what is the size

00:06:01.169 --> 00:06:03.084
of this string now?
does the space

00:06:03.109 --> 00:06:07.370
count or not? is the size 4?

00:06:07.370 --> 00:06:11.520
or is it 5? let's have
a look, it's 5, the

00:06:11.545 --> 00:06:15.760
space does count, keep
that in mind so you're

00:06:15.760 --> 00:06:18.680
not only counting letters, you're
counting pretty much everything that is

00:06:18.680 --> 00:06:26.650
in the string, empty spaces included. Ok
there is also a method . empty

00:06:28.050 --> 00:06:34.345
basically just checking
if it's empty or not

00:06:34.370 --> 00:06:41.074
you can just type in
bool emp = s1.empty

00:06:43.060 --> 00:06:46.288
you can create output
below this one and

00:06:46.313 --> 00:06:49.200
see if it's empty or
not can use an if

00:06:49.300 --> 00:06:55.287
statement like if emp if
for example true, then

00:06:55.312 --> 00:07:00.639
print true, if its false,
then print false or if

00:07:00.639 --> 00:07:03.300
yeah that's I'm not creating

00:07:03.325 --> 00:07:05.960
the print outs below it but

00:07:05.960 --> 00:07:07.933
doesn't really matter
you can create

00:07:07.958 --> 00:07:09.399
print outs on your
own I'm pretty sure

00:07:09.499 --> 00:07:11.586
you know how to do
that by now in any

00:07:11.611 --> 00:07:13.550
case this is basically
checking whether a

00:07:13.550 --> 00:07:20.150
string is empty or not. Ok to access a
certain character in a string just as

00:07:20.150 --> 00:07:27.969
before with vectors and dq and

00:07:27.969 --> 00:07:30.595
arrays it's the
same, I mean there

00:07:30.620 --> 00:07:33.580
literally is very
little difference just

00:07:33.580 --> 00:07:38.399
type in char I don't know, C1 = s1

00:07:39.460 --> 00:07:44.488
so you have this fashion
which is not the recommended

00:07:44.513 --> 00:07:48.259
one and then we can type
in 0 and down below,

00:07:48.259 --> 00:07:53.360
we can use the
recommended way of fixing things from

00:07:53.360 --> 00:08:01.330
from a string or from a vector or from
a dq so it's just char C2= 1

00:08:07.130 --> 00:08:12.923
.at let's say 0, so let's
make them completely

00:08:12.948 --> 00:08:19.770
the same, go ahead
and copy this I just

00:08:19.770 --> 00:08:25.623
go ahead and create
a print out here so

00:08:25.648 --> 00:08:31.110
going to be C1 and gonna
create space here

00:08:31.110 --> 00:08:39.100
it should be c2 h h, hey hey
what did I do?

00:08:43.800 --> 00:08:51.680
right okay do you see what I did? I
didn't do anything wrong but it says s1

00:08:51.680 --> 00:08:56.293
at0 and s1 index 0 here and s1 .
at 0 so

00:08:56.318 --> 00:09:01.220
we are accessing to
same elements it's

00:09:01.220 --> 00:09:05.554
capital h capital
h beginning the

00:09:05.579 --> 00:09:09.210
first element of the string.
Anyway

00:09:09.310 --> 00:09:11.369
we can also compare
strings, so you can

00:09:11.394 --> 00:09:13.520
check wheter the two
sentences are the

00:09:13.520 --> 00:09:15.962
same or, hey, you know
what you can do? you

00:09:15.987 --> 00:09:19.110
can load the contents
of a text file into a

00:09:19.110 --> 00:09:22.920
string and then you can load the
contents of another text file into

00:09:22.920 --> 00:09:25.102
another string and
you can compare the

00:09:25.127 --> 00:09:27.020
two strings and you
can have the program

00:09:27.120 --> 00:09:31.720
actually print out onto the screen like
hey these are the differences between

00:09:31.720 --> 00:09:34.565
the files or it can
just say the files

00:09:34.590 --> 00:09:37.410
are different order
files are just say

00:09:37.410 --> 00:09:40.425
let's go ahead and have a look

00:09:40.450 --> 00:09:43.089
at that can just do this s1==

00:09:43.089 --> 00:09:46.240
s2, so I don't know,
we're not gonna actually

00:09:46.265 --> 00:09:48.760
do anything I'm just
showing you how you

00:09:48.760 --> 00:09:52.930
can do the comparisons obviously you
could place a body

00:09:52.930 --> 00:09:56.529
here and you can pretty much do whatever
you wanted in one case and whatever you

00:09:56.529 --> 00:10:01.110
want in another but I just want to
show you that these operators do apply

00:10:01.110 --> 00:10:06.969
for strings, so you can
s2 not equal to s1,

00:10:06.994 --> 00:10:12.354
in these conditions
here can be evaluated

00:10:13.330 --> 00:10:20.459
then later on they can be utilized as I
given you one example and you can also

00:10:20.459 --> 00:10:22.744
do this s1== and you can give it

00:10:22.769 --> 00:10:25.190
a string you don't need to use a

00:10:25.290 --> 00:10:28.529
string as a variable, you can just give it a
value of

00:10:28.529 --> 00:10:33.048
a string so hello, so
if this is equal to

00:10:33.073 --> 00:10:37.279
hello, if the contents
of s1 are equal to

00:10:37.279 --> 00:10:43.730
hello, you can also ask that as well. We
can also compare them alphabetically

00:10:43.730 --> 00:10:51.680
if s1 is greater than s2, this is
comparison in an alphabetical fashion if

00:10:59.580 --> 00:11:04.155
s1 is whatever lesser
than s2, so this

00:11:04.180 --> 00:11:08.730
is just gonna do
comparisons based on the alphabetical

00:11:10.140 --> 00:11:14.560
in an alphabetical way, I don't really
know what else is there to say about that

00:11:16.459 --> 00:11:19.725
to basically add
the T at the pre

00:11:19.750 --> 00:11:23.150
string we can use
push back some of

00:11:23.150 --> 00:11:27.810
that as before so
you can do addition

00:11:27.835 --> 00:11:32.470
so s1 = + = no
that's just adding

00:11:32.470 --> 00:11:37.240
strings sorry we can just do this s3.push_back

00:11:39.200 --> 00:11:44.953
So we're adding it to
s3 ok s3 is empty and

00:11:44.978 --> 00:11:50.130
we can add E there you
go and down below you

00:11:50.130 --> 00:11:54.850
can print s3 out there
you go, E has indeed

00:11:54.875 --> 00:11:59.570
been printed out onto
the screen you see

00:11:59.570 --> 00:12:04.550
the string is to a very large extent
different from the previous two types

00:12:04.550 --> 00:12:09.142
which we have processed here
you can also add strings

00:12:09.167 --> 00:12:13.339
you can concatenate them
so you can type in s1

00:12:13.339 --> 00:12:21.260
+ = tralalala ok,f this is the same as me writing

00:12:28.760 --> 00:12:30.630
s1+ tralalala

00:12:30.630 --> 00:12:33.039
instead of that I'm
using the short

00:12:33.064 --> 00:12:35.399
version so I'm just
typing it in like

00:12:35.399 --> 00:12:43.300
this you can also do this in a more
complex passion for example

00:12:50.400 --> 00:12:51.570
you can do it like this

00:12:51.570 --> 00:12:59.487
std, colon colon,
string s4= s1 + , + S2

00:13:02.112 --> 00:13:10.070
and you see, whatever
is in s1 and we

00:13:11.870 --> 00:13:14.570
have hey which is in
s1, you will add a

00:13:14.595 --> 00:13:17.270
coma to it at the
end, so it will be

00:13:17.270 --> 00:13:23.079
hey, + s2 which is hey
how's it going?

00:13:23.079 --> 00:13:29.871
that's it, can you
print out onto the

00:13:29.896 --> 00:13:36.220
screen just run it,
here seem to have a

00:13:36.220 --> 00:13:37.880
bit of an error here

00:13:37.880 --> 00:13:44.220
what is the problem? declaration of s4
ok gimme s5

00:13:49.130 --> 00:13:57.040
why haven't you produce right right, s5. Ok

00:14:01.140 --> 00:14:05.005
Heytralalala, Hey how is it going.
We've already

00:14:05.030 --> 00:14:09.050
add a tralalala directed
the previous one, in the

00:14:09.050 --> 00:14:11.989
previous lines in a
previous line of code,

00:14:12.014 --> 00:14:14.640
so the previous one
but actually yes the

00:14:14.640 --> 00:14:19.440
previous added there, there you can see how this works, just go out and

00:14:19.440 --> 00:14:20.610
do it one more time.

00:14:20.610 --> 00:14:27.120
analyzed this and compare it to what we
have done in these three lines of code

00:14:27.120 --> 00:14:32.670
and see how that has reflected the
strength itself the string s5, how it is

00:14:32.670 --> 00:14:39.820
reflected in it. Now, there is another
concept which is very important you can

00:14:39.820 --> 00:14:43.163
I mean this is for
user input, so if

00:14:43.188 --> 00:14:46.390
you're wondering how
a user can input a

00:14:46.390 --> 00:14:47.930
whole sentence

00:14:47.930 --> 00:14:53.240
well to imput a single string
from a keyword and by

00:14:53.240 --> 00:14:58.040
this I mean only one
word without spaces

00:14:58.065 --> 00:15:02.040
you can do this:
string s6 and we

00:15:02.040 --> 00:15:05.440
will leave it uninitialized there and
then blow it will be a std, colon colon,

00:15:05.440 --> 00:15:12.320
cin and naturally you would
think that it's s5, s6 sorry

00:15:12.320 --> 00:15:16.700
well yes, it can go like this,
but can only imput one word here let me

00:15:16.700 --> 00:15:19.950
show you what I mean by it

00:15:19.950 --> 00:15:26.450
testtesttest but if I press space and
type in test again,

00:15:28.520 --> 00:15:34.400
my bad,  my bad I mean I did
everything right but I didn't create a

00:15:34.400 --> 00:15:37.507
print out, so you
can actually see

00:15:37.532 --> 00:15:40.574
what's going on s6,
run the code again

00:15:42.300 --> 00:15:47.051
so test bla tra and you
can see it has only

00:15:47.076 --> 00:15:51.700
taken test into
consideration, everything

00:15:51.700 --> 00:15:56.510
passed everything immediately as soon as
I press space, it was no longer in

00:15:56.510 --> 00:16:00.780
putting this, so it was no longer
concerned with this so to say, it didn't

00:16:00.780 --> 00:16:05.690
take that into consideration, if you want
to be able to imput an entire line, well

00:16:05.690 --> 00:16:13.670
then you would use this std, colon colon,
get line and it will be std

00:16:15.170 --> 00:16:23.040
colon colon, cin, s6 in this
fashion you could actually, you have method

00:16:25.240 --> 00:16:27.712
get line, then you
have argument that are

00:16:27.737 --> 00:16:30.130
passed to it, in this
fashion you would

00:16:30.130 --> 00:16:37.710
be able to imput an entire sentence,
pretty much, there

00:16:37.710 --> 00:16:45.670
aren't any significant limits to this, so
it's like dance

00:16:52.970 --> 00:16:58.805
run party jump hahaha and
you can see all of these

00:16:58.830 --> 00:17:03.980
words are taken into
consideration, they're

00:17:03.980 --> 00:17:06.481
placed into a string and
printed out onto the

00:17:06.506 --> 00:17:08.590
screen so before I
wrap this tutorial up,

00:17:08.590 --> 00:17:10.416
once again I repeat
that string is

00:17:10.441 --> 00:17:12.870
probably the most
important type here

00:17:12.870 --> 00:17:16.900
if not the most important type please
make sure that you understand it for

00:17:16.900 --> 00:17:21.930
the full of its extends even with other
programming languages you're still going

00:17:21.930 --> 00:17:26.390
to need it, you still going to, you know
likelihood you will use it and it is a

00:17:26.390 --> 00:17:29.292
very important concept to grasp.
Anyway

00:17:29.317 --> 00:17:31.630
bet you feel well
and hope to see you

00:17:31.730 --> 00:17:32.870
in the follow

00:17:32.870 --> 00:17:34.020
tutorial.