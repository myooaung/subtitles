WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.055
Hello everyone, Welcome back.

00:00:02.055 --> 00:00:04.935
So we discussed a lot of things have been generics, right?

00:00:04.935 --> 00:00:07.950
But before we are finishing the course,

00:00:07.950 --> 00:00:09.690
we need to know one important thing.

00:00:09.690 --> 00:00:11.670
So we know how to use generates,

00:00:11.670 --> 00:00:16.995
but we should know what are the things that are not allowed to use in genetics.

00:00:16.995 --> 00:00:19.950
The first one, there is

00:00:19.950 --> 00:00:25.830
no primitive type allowed in generics because it's always an object,

00:00:25.830 --> 00:00:29.340
or is it a forensic perimeter type will not alone because primitive type does

00:00:29.340 --> 00:00:33.090
not kinda it into an object and there is no instance allowed.

00:00:33.090 --> 00:00:36.689
You cannot create an object for a type parameter.

00:00:36.689 --> 00:00:41.585
And same time, no static field and no casting.

00:00:41.585 --> 00:00:47.435
Casting, they're not allowed to because to avoid the casting only became degenerate.

00:00:47.435 --> 00:00:49.700
So why we need to do casting again?

00:00:49.700 --> 00:00:55.040
And you cannot use the no instance soft method. That is the reason why.

00:00:55.040 --> 00:00:57.965
And it will tell you while we're going through this simple example of it.

00:00:57.965 --> 00:01:03.620
And you cannot use an array while creating a generic class.

00:01:03.620 --> 00:01:09.065
And you're gonna do is the exception are true oval. Okay, that is fine.

00:01:09.065 --> 00:01:12.350
So let's go back to our ID and I'll

00:01:12.350 --> 00:01:16.520
I'll tell you what are the things which we discussed so far.

00:01:16.520 --> 00:01:20.240
Okay, So let me create a main method.

00:01:20.240 --> 00:01:25.220
So the first thing which we don't talk about it, no primitive.

00:01:25.220 --> 00:01:29.615
Okay, so we all know how to create a list of integers, right?

00:01:29.615 --> 00:01:37.415
So list of integers,

00:01:37.415 --> 00:01:43.220
so int, list, new ArrayList.

00:01:43.220 --> 00:01:45.875
So this is straightforward, no issues.

00:01:45.875 --> 00:01:49.520
But as I mentioned earlier,

00:01:49.520 --> 00:01:50.855
primitive or not allowed,

00:01:50.855 --> 00:01:55.775
what happened if you use primitive list1 and I'm gonna burn too.

00:01:55.775 --> 00:01:58.880
So what do you provide if you instead of integer wrapper class,

00:01:58.880 --> 00:02:02.120
if you use permitted, what is the primitive type int?

00:02:02.120 --> 00:02:04.310
Which will not allowed?

00:02:04.310 --> 00:02:06.830
It will throw an error message because we are

00:02:06.830 --> 00:02:12.905
using a primitive type inside the diamond operator which is not allowed.

00:02:12.905 --> 00:02:13.835
Okay?

00:02:13.835 --> 00:02:19.290
So the next thing, so the second one is no instance.

00:02:19.870 --> 00:02:22.535
Okay, so what do you mean we know instance?

00:02:22.535 --> 00:02:25.140
For example, I have a class here.

00:02:25.480 --> 00:02:29.375
Class, okay?

00:02:29.375 --> 00:02:33.210
Anything, okay, general class.

00:02:36.040 --> 00:02:39.440
Okay, so this is going to be a generic class.

00:02:39.440 --> 00:02:41.660
So I introduced the type parameter here.

00:02:41.660 --> 00:02:43.310
I mean diamond operator.

00:02:43.310 --> 00:02:44.765
So normally how we sort of,

00:02:44.765 --> 00:02:48.275
so d is equal to t. That is how we used to do.

00:02:48.275 --> 00:02:51.170
But if you try to create an object,

00:02:51.170 --> 00:02:53.735
t is equal to D,

00:02:53.735 --> 00:02:56.600
which is not allowed.

00:02:56.600 --> 00:03:00.140
Because you cannot create objects for a type parameter.

00:03:00.140 --> 00:03:03.875
Because type parameter is nothing but it's a type of data.

00:03:03.875 --> 00:03:05.540
We don't know what is the type.

00:03:05.540 --> 00:03:07.610
Who will know that?

00:03:07.610 --> 00:03:10.430
The person who's going to call the generic class, they know the type.

00:03:10.430 --> 00:03:11.930
So once they pass the data,

00:03:11.930 --> 00:03:13.070
then you can get an object,

00:03:13.070 --> 00:03:17.495
but you cannot create an object for generic type.

00:03:17.495 --> 00:03:18.350
Okay?

00:03:18.350 --> 00:03:20.300
So we discovered NO instance.

00:03:20.300 --> 00:03:23.075
So what else? There is no static field also.

00:03:23.075 --> 00:03:26.600
So no static field.

00:03:26.600 --> 00:03:28.190
Okay, so what is that?

00:03:28.190 --> 00:03:31.520
So here, okay, So this is not allowed.

00:03:31.520 --> 00:03:35.720
So I'm going back to the previous working. Okay?

00:03:35.720 --> 00:03:40.010
So I can have private t squared,

00:03:40.010 --> 00:03:44.105
private a type parameter and the instance.

00:03:44.105 --> 00:03:49.370
But you cannot give that as a static because daddy was not allowed.

00:03:49.370 --> 00:03:54.470
I mean, static is not allowed while creating that type parameter here.

00:03:54.470 --> 00:04:01.370
Okay, So we know, Okay, the next thing.

00:04:02.100 --> 00:04:04.525
So non-static field, right?

00:04:04.525 --> 00:04:07.090
And also there is no possibility of

00:04:07.090 --> 00:04:10.390
using the casting one type of data and do another type.

00:04:10.390 --> 00:04:13.360
What I meant to say is no casting.

00:04:13.360 --> 00:04:15.550
So let me give you a simple example.

00:04:15.550 --> 00:04:19.645
Let's say I have a list of numbers,

00:04:19.645 --> 00:04:26.260
n, This is going to be num one is equal to new array list.

00:04:26.260 --> 00:04:29.870
Okay, let me copy the same thing, Control C.

00:04:30.570 --> 00:04:34.330
Okay, so this is going to be number two and this is not a number,

00:04:34.330 --> 00:04:37.105
this is going to be integer which is a subclass of number.

00:04:37.105 --> 00:04:37.975
Okay?

00:04:37.975 --> 00:04:42.500
So num one, is it called the num 2,

00:04:42.500 --> 00:04:43.610
which is not possible,

00:04:43.610 --> 00:04:44.630
you might think, okay,

00:04:44.630 --> 00:04:49.230
we can do the typecasting for the list of integer,

00:04:55.060 --> 00:04:59.000
which is not possible in generics.

00:04:59.000 --> 00:05:01.730
So because you know that we are,

00:05:01.730 --> 00:05:05.345
We came to generics to avoid the typecasting, right?

00:05:05.345 --> 00:05:07.850
So what is the next thing? So we'd have no primitive,

00:05:07.850 --> 00:05:09.650
NO instance, non-static, no casting,

00:05:09.650 --> 00:05:15.125
and then our new instance of NO instance of metadata.

00:05:15.125 --> 00:05:18.305
The reason why it's not allowed to use a no intense of method.

00:05:18.305 --> 00:05:19.910
Do you know that right out type erasure.

00:05:19.910 --> 00:05:23.210
So the runtime will not keep track of the type parameters.

00:05:23.210 --> 00:05:26.765
That is the reason it is not accepting the instance of my data.

00:05:26.765 --> 00:05:29.675
Okay, so here I have an m do rate.

00:05:29.675 --> 00:05:34.505
So for example, if I'm trying to check if num

00:05:34.505 --> 00:05:42.869
two instance of some,

00:05:44.470 --> 00:05:47.640
let's delve into here.

00:05:54.250 --> 00:05:56.270
Z, whatever.

00:05:56.270 --> 00:06:00.005
It will not allow me to draw an exception.

00:06:00.005 --> 00:06:06.120
Okay, so does this not allowed in Java?

00:06:09.600 --> 00:06:12.040
Okay, so what do the next thing?

00:06:12.040 --> 00:06:15.760
So no instance of we checked and then what else?

00:06:15.760 --> 00:06:16.675
Okay?

00:06:16.675 --> 00:06:21.680
Ra, Even when it comes to array also,

00:06:22.530 --> 00:06:27.040
because of the compiler uses the type it is a right that i parameter is replaced

00:06:27.040 --> 00:06:30.850
with an object and user can add any type of object into the array.

00:06:30.850 --> 00:06:32.575
But here, let's see.

00:06:32.575 --> 00:06:36.655
I'm going to show you an example like so here we have a num one.

00:06:36.655 --> 00:06:39.160
Okay, let me create a list

00:06:39.160 --> 00:06:47.305
of list of integer,

00:06:47.305 --> 00:06:54.680
an ArrayList new

00:07:04.530 --> 00:07:05.800
list

00:07:05.800 --> 00:07:07.460
of integer,

00:07:14.490 --> 00:07:18.520
which will not allowed.

00:07:18.520 --> 00:07:20.900
Okay?

00:07:26.220 --> 00:07:30.100
So it will immediately throw an exception saying like,

00:07:30.100 --> 00:07:31.210
why do I believe stuff indeed,

00:07:31.210 --> 00:07:34.130
but we are providing something will,

00:07:34.130 --> 00:07:38.300
because we are providing array here because R is not accepted in the generics.

00:07:38.300 --> 00:07:41.820
So let's rough integer weight is ringing.

00:07:43.870 --> 00:07:47.520
Oh, okay, I didn't probably the titrate.

00:07:50.560 --> 00:07:55.640
It will not throw an error because here I have an array,

00:07:55.640 --> 00:07:56.870
I'm trying to add something into it,

00:07:56.870 --> 00:07:59.525
but our Java will not allow it.

00:07:59.525 --> 00:08:01.010
Okay, so that was the next thing.

00:08:01.010 --> 00:08:08.585
So okay, That is pretty much and more important thing is you cannot use exception.

00:08:08.585 --> 00:08:13.470
For example, like when you are using glass.

00:08:15.790 --> 00:08:21.140
Don't try to use extends exception because that may not be

00:08:21.140 --> 00:08:26.705
a subclass of the type parameter.

00:08:26.705 --> 00:08:33.830
And not only exception or even tried to award throwable as well.

00:08:33.830 --> 00:08:36.710
So these are the risks section which we need to know before

00:08:36.710 --> 00:08:43.085
we're familiar with the generics. Right?

00:08:43.085 --> 00:08:45.440
Okay, so I didn't,

00:08:45.440 --> 00:08:47.195
this is all with a generates.

00:08:47.195 --> 00:08:50.730
So let's see each in the next video. Thank you.
