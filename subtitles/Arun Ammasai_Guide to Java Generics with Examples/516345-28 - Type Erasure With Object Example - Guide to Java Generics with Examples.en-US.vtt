WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.260
Hello everyone.

00:00:01.260 --> 00:00:01.965
Welcome back.

00:00:01.965 --> 00:00:06.495
So we just discussed about what is a type erasure.

00:00:06.495 --> 00:00:08.190
It's a compelling responsibility, right?

00:00:08.190 --> 00:00:10.080
So how it is working, Let's see, I've got that.

00:00:10.080 --> 00:00:12.900
There are two ways that type of ratio will apply.

00:00:12.900 --> 00:00:16.710
The first one is basing on object and secant

00:00:16.710 --> 00:00:21.690
are bound based on new bone to bone type, bounded type.

00:00:21.690 --> 00:00:24.120
It may be upper bound ADL wide one.

00:00:24.120 --> 00:00:29.954
It doesn't matter. Okay, first let's talk about how it will be applied using an object.

00:00:29.954 --> 00:00:33.075
Okay, so for now, to explore that,

00:00:33.075 --> 00:00:37.260
I'm going to create a generic class here, for example.

00:00:37.260 --> 00:00:39.850
What is the name we can call a candidate score?

00:00:39.850 --> 00:00:41.980
Its name it as a generic class itself.

00:00:41.980 --> 00:00:45.080
Generic class.

00:00:45.080 --> 00:00:47.870
And are you sure it's a generic class?

00:00:47.870 --> 00:00:49.475
It is not. It is just momma class.

00:00:49.475 --> 00:00:54.050
If you want to mention or if you want to tell the compiler it is a generic class.

00:00:54.050 --> 00:00:58.280
We haven't introduced the diamond operator and I'm going to provide the meaning for the

00:00:58.280 --> 00:01:04.415
t. So I need to have the constructor.

00:01:04.415 --> 00:01:08.990
So I have the constructor here and let's have the getters and setters says,

00:01:08.990 --> 00:01:12.695
well, okay, so now everything is in place.

00:01:12.695 --> 00:01:15.860
So now what I can do is let

00:01:15.860 --> 00:01:20.885
me try to create an object so we'll see what's going to happen.

00:01:20.885 --> 00:01:24.660
So generic class,

00:01:25.210 --> 00:01:31.280
end January class is equal to new genetic lists.

00:01:31.280 --> 00:01:33.980
But this is just normal object creation.

00:01:33.980 --> 00:01:36.830
But what do we need to do? It is a generic lesser type, right?

00:01:36.830 --> 00:01:38.330
So we need to provide a type here.

00:01:38.330 --> 00:01:39.890
What type you're going to pass.

00:01:39.890 --> 00:01:41.555
So I'm going to tell the compiler,

00:01:41.555 --> 00:01:44.330
Okay, for now, I'm going to pass a string.

00:01:44.330 --> 00:01:46.850
And let's say something.

00:01:46.850 --> 00:01:50.480
So I am a hello, right?

00:01:50.480 --> 00:01:54.485
And I can simply print the data as well as out.

00:01:54.485 --> 00:01:56.090
So GC.

00:01:56.090 --> 00:01:58.370
So let me run this.

00:01:58.370 --> 00:02:02.405
We haven't talked about how water into a,

00:02:02.405 --> 00:02:04.955
a tiebreaker in the bytecode level.

00:02:04.955 --> 00:02:06.860
Okay, So why it is not, okay,

00:02:06.860 --> 00:02:10.880
It's printing an object because I did not override the toString method here.

00:02:10.880 --> 00:02:12.230
So it's gonna take up too much time.

00:02:12.230 --> 00:02:15.000
So let me do that.

00:02:15.160 --> 00:02:19.730
Okay, save it under one more time so I can see that data.

00:02:19.730 --> 00:02:23.945
So it has a Information. Hello.

00:02:23.945 --> 00:02:27.575
Okay, So now let me tell you the moment I compile the class,

00:02:27.575 --> 00:02:31.460
how Java in the background it converts this particular class.

00:02:31.460 --> 00:02:34.190
There are two ways. First one is object and second and

00:02:34.190 --> 00:02:36.560
is a bounded type and this doesn't have any bone to type.

00:02:36.560 --> 00:02:37.655
It is just a direct way.

00:02:37.655 --> 00:02:40.640
So which means it will be replaced by an object.

00:02:40.640 --> 00:02:42.905
So wherever the type is passing,

00:02:42.905 --> 00:02:45.740
it will be replaced by an object.

00:02:45.740 --> 00:02:50.285
So the, how it will be looks like a after the compilation is done.

00:02:50.285 --> 00:02:59.360
So it really looks like it will be remote end and the T will be updated as

00:02:59.360 --> 00:03:01.260
the objects

00:03:02.470 --> 00:03:11.040
and see what happened.

00:03:11.470 --> 00:03:15.230
And it is an object, right?

00:03:15.230 --> 00:03:19.445
And when you're using and it has to be removed.

00:03:19.445 --> 00:03:24.665
Okay? See you now what happened is working as a normal class.

00:03:24.665 --> 00:03:26.345
That is what exactly is happening.

00:03:26.345 --> 00:03:30.200
Even though you're creating a generic class,

00:03:30.200 --> 00:03:33.950
the compiler will convert into a normal class,

00:03:33.950 --> 00:03:36.605
which means the actual class.

00:03:36.605 --> 00:03:37.790
Right?

00:03:37.790 --> 00:03:39.200
So that is how it is looks like.

00:03:39.200 --> 00:03:41.795
So after the compilation, the bytecode and B looks like this.

00:03:41.795 --> 00:03:46.800
Okay, so let me give it back to the old way,

00:03:46.800 --> 00:03:49.860
like to use it.

00:03:54.160 --> 00:04:00.410
Okay, so now we know how it will be converted into a normal class at the time

00:04:00.410 --> 00:04:05.810
of compilation using the object because it's just direct type,

00:04:05.810 --> 00:04:07.700
it does not bound.

00:04:07.700 --> 00:04:10.820
It doesn't bounded by any class is gone.

00:04:10.820 --> 00:04:13.220
It means you're using any upper bound or lower bound.

00:04:13.220 --> 00:04:17.945
So next example, I'm going to create another example which will show you

00:04:17.945 --> 00:04:22.625
how comparable convert a bounded January class into normal class.

00:04:22.625 --> 00:04:25.140
Let's talk over the next example.
