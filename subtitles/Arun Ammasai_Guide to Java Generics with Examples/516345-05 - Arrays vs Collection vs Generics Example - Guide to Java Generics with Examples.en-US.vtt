WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.235
Hey everyone, Welcome back.

00:00:02.235 --> 00:00:05.775
It's time to see the difference between arrays and collection.

00:00:05.775 --> 00:00:07.515
We have seen few points.

00:00:07.515 --> 00:00:09.765
What is the advantage array in what is a?

00:00:09.765 --> 00:00:11.715
These are energy in collection.

00:00:11.715 --> 00:00:12.960
So when it comes to array,

00:00:12.960 --> 00:00:14.685
the size is the problem.

00:00:14.685 --> 00:00:15.390
Correct?

00:00:15.390 --> 00:00:17.250
So let's see how it can be done.

00:00:17.250 --> 00:00:20.260
So first let's talk about array.

00:00:26.240 --> 00:00:28.455
Let me create a simple array.

00:00:28.455 --> 00:00:30.655
So I'm going to create a string of,

00:00:30.655 --> 00:00:40.130
hey, this is so new string.

00:00:40.130 --> 00:00:43.535
And you have to provide the size of the array.

00:00:43.535 --> 00:00:45.905
So for now I'm going to pass only 10.

00:00:45.905 --> 00:00:50.435
So which means in this particular array you can store only 10 elements.

00:00:50.435 --> 00:00:54.365
For example, S of 0th element.

00:00:54.365 --> 00:00:58.985
I'm going to provide some named John.

00:00:58.985 --> 00:01:03.395
And I'm going to grow where it is of one.

00:01:03.395 --> 00:01:07.145
And array index starts with 0, not with the one.

00:01:07.145 --> 00:01:11.700
And the second name I'm going to provide as in Nancy.

00:01:12.790 --> 00:01:16.220
Got it. Okay, So now what is the problem?

00:01:16.220 --> 00:01:22.175
Let's check. Can we add something like this?

00:01:22.175 --> 00:01:29.550
S of 11 is equal to Sam.

00:01:30.010 --> 00:01:32.180
So there is no errors.

00:01:32.180 --> 00:01:35.915
So which means we can add. Does it look like?

00:01:35.915 --> 00:01:37.520
Yes, it looks like we can add,

00:01:37.520 --> 00:01:39.815
but what will happen when you render code?

00:01:39.815 --> 00:01:42.470
It will throw an exception.

00:01:42.470 --> 00:01:45.710
Okay, so let me show you that.

00:01:45.710 --> 00:01:48.350
So let me print the data.

00:01:48.350 --> 00:01:55.250
And string array is.

00:01:55.250 --> 00:01:57.740
Let's print the array.

00:01:57.740 --> 00:02:04.430
Yes. Now I'm going to run, this is running.

00:02:04.430 --> 00:02:07.670
Eventually it's thrown ArrayIndexOutOfBounds exception,

00:02:07.670 --> 00:02:11.840
which means you're pruning a size into an array and body are giving

00:02:11.840 --> 00:02:16.625
the value out of the array,

00:02:16.625 --> 00:02:18.800
which means I can only store 10 elements,

00:02:18.800 --> 00:02:21.335
but you're trying to store dilemma and element which is not possible.

00:02:21.335 --> 00:02:25.520
That is the elements, yes, we'll index 11 out of bones photo lens chin.

00:02:25.520 --> 00:02:28.925
So that's the one thing.

00:02:28.925 --> 00:02:31.835
So we cannot that's a disadvantage.

00:02:31.835 --> 00:02:34.985
So we cannot add more sides once it is declared.

00:02:34.985 --> 00:02:37.430
That's all. Okay, so fine.

00:02:37.430 --> 00:02:38.585
So what next?

00:02:38.585 --> 00:02:41.645
Okay, so can we add some other different types of data?

00:02:41.645 --> 00:02:42.965
Let's do that.

00:02:42.965 --> 00:02:45.050
So S of 2,

00:02:45.050 --> 00:02:51.095
I'm going to provide something like a new integer.

00:02:51.095 --> 00:02:53.285
And I'm going to provide this to a 100,

00:02:53.285 --> 00:02:59.225
which is not possible at all because this particular array is dedicated for string.

00:02:59.225 --> 00:03:04.940
So which means you can only assign the string value.

00:03:04.940 --> 00:03:08.030
So you cannot ask him some different kinds of data.

00:03:08.030 --> 00:03:11.060
So which means this is not allowed.

00:03:11.060 --> 00:03:14.630
It will throw an error message in the compile-time itself.

00:03:14.630 --> 00:03:18.305
So now, when we talk about our recent collection,

00:03:18.305 --> 00:03:21.245
The one thing is I want to do antigen arrays.

00:03:21.245 --> 00:03:25.235
You don't have to typecast the data because it's a string array.

00:03:25.235 --> 00:03:26.975
It only accept the string.

00:03:26.975 --> 00:03:29.225
So you can only receive as a string.

00:03:29.225 --> 00:03:32.105
You don't have to type. Guess is what I'm trying to say is here.

00:03:32.105 --> 00:03:36.350
So string name is equal to,

00:03:36.350 --> 00:03:40.770
so let's say I want to retrieve what is the data available, S sub 0.

00:03:41.410 --> 00:03:45.020
I don't have to any typecasting.

00:03:45.020 --> 00:03:47.510
And normally like, like this,

00:03:47.510 --> 00:03:51.695
you don't have to do that because it's already a string.

00:03:51.695 --> 00:03:54.200
You don't need to typecast them again.

00:03:54.200 --> 00:03:55.370
Okay?

00:03:55.370 --> 00:04:02.170
So now we know what we can do an array so we can add

00:04:02.170 --> 00:04:05.260
the element and we have a specific limit because we assigned

00:04:05.260 --> 00:04:09.355
the string array can only hold ten elements, right?

00:04:09.355 --> 00:04:14.005
And then we know that once the array is declared as a particular type,

00:04:14.005 --> 00:04:15.715
you cannot add any other type.

00:04:15.715 --> 00:04:17.950
So I can add a string,

00:04:17.950 --> 00:04:21.805
but I cannot add some other type interior because they are raised indicated for stream.

00:04:21.805 --> 00:04:25.525
And I don't need to typecast.

00:04:25.525 --> 00:04:29.409
And most importantly, the another point, type safety,

00:04:29.409 --> 00:04:35.500
that is a major important thing in the array type safety because when I enable this line,

00:04:35.500 --> 00:04:37.765
it will throw it at a message,

00:04:37.765 --> 00:04:40.845
which means this is called asset type safety.

00:04:40.845 --> 00:04:42.590
While creating the data itself,

00:04:42.590 --> 00:04:46.130
it's throwing an error saying you cannot be adding

00:04:46.130 --> 00:04:48.500
some other type of a data here because it

00:04:48.500 --> 00:04:50.975
is belongs to a string and you're trying to add a integer.

00:04:50.975 --> 00:04:52.340
So that is a type safety.

00:04:52.340 --> 00:04:54.440
So now we know it has

00:04:54.440 --> 00:04:59.585
a typecasting type safety and also there is no need for typecasting.

00:04:59.585 --> 00:05:02.465
Okay, so now let's move to the collection.

00:05:02.465 --> 00:05:04.310
So let's go back to collection.

00:05:04.310 --> 00:05:06.260
I mean, collection now one,

00:05:06.260 --> 00:05:08.780
We'll see you what it can be done.

00:05:08.780 --> 00:05:11.930
So in array you're going to add multiple type of data,

00:05:11.930 --> 00:05:14.315
which means that type safety is there.

00:05:14.315 --> 00:05:17.225
Okay, so let's create a list here.

00:05:17.225 --> 00:05:22.500
A list I is equal to mu.

00:05:24.370 --> 00:05:29.570
Arraylist. Okay, now I'm going to add something.

00:05:29.570 --> 00:05:32.630
So it's a similar kind of a data LI dot add.

00:05:32.630 --> 00:05:36.395
And it's going to be again a John.

00:05:36.395 --> 00:05:41.270
Cool and then LA dot add.

00:05:41.270 --> 00:05:44.195
So I'm going to add Nancy here.

00:05:44.195 --> 00:05:47.195
And this is where things are getting pretty interesting.

00:05:47.195 --> 00:05:48.815
So LA dot add.

00:05:48.815 --> 00:05:53.765
And now I can add a new, Sorry,

00:05:53.765 --> 00:06:00.125
no integer of a 100 C,

00:06:00.125 --> 00:06:02.550
which is still allowed.

00:06:02.980 --> 00:06:09.140
So how come it is possible because the list can hold any kind of objects.

00:06:09.140 --> 00:06:11.030
So it adds a string,

00:06:11.030 --> 00:06:12.785
it takes Nancy, I mean,

00:06:12.785 --> 00:06:15.155
again string and takes an integer also.

00:06:15.155 --> 00:06:17.720
But what is the problem with the collection?

00:06:17.720 --> 00:06:23.525
Okay, so now I want to retrieve the data which is available from the list.

00:06:23.525 --> 00:06:26.280
For now I'm going to print the airline.

00:06:27.790 --> 00:06:38.300
Let's see what happen. It will just print John and C and the integer value.

00:06:38.300 --> 00:06:41.960
Okay, so let me try to add,

00:06:41.960 --> 00:06:44.465
I mean, trying to retrieve the data from the list.

00:06:44.465 --> 00:06:49.505
For example, I want to retrieve an LI dot get off,

00:06:49.505 --> 00:06:52.925
for example one, right?

00:06:52.925 --> 00:06:55.955
So what I need to do here,

00:06:55.955 --> 00:06:57.590
so we have an answer, right?

00:06:57.590 --> 00:07:03.590
So it's a string and string name1 is equal to C.

00:07:03.590 --> 00:07:08.300
What happened? It is an error because the 0th pushing is as John,

00:07:08.300 --> 00:07:11.270
which is a string, and the first portion as an anti,

00:07:11.270 --> 00:07:12.695
which is another string.

00:07:12.695 --> 00:07:15.140
But here I'm retrieving ss string of name,

00:07:15.140 --> 00:07:16.940
but you'd still is throwing an error.

00:07:16.940 --> 00:07:18.140
So that's the problem.

00:07:18.140 --> 00:07:20.450
So the collection has a string,

00:07:20.450 --> 00:07:24.230
but why it is still throwing an error because it's a raw list.

00:07:24.230 --> 00:07:25.640
So when you're using collection,

00:07:25.640 --> 00:07:26.855
when you'd read the data,

00:07:26.855 --> 00:07:32.045
you have to typecast the data.

00:07:32.045 --> 00:07:35.495
You don't have a choice because it has a multiple types of data.

00:07:35.495 --> 00:07:38.360
So in order to do the information you like it or not,

00:07:38.360 --> 00:07:39.575
you how to typecast it.

00:07:39.575 --> 00:07:45.500
For example, I'm trying to retrieve the value from the second position,

00:07:45.500 --> 00:07:47.960
0, 1, 2. Okay, Let me do that.

00:07:47.960 --> 00:07:53.105
So LI dot and get off too.

00:07:53.105 --> 00:07:58.280
So now it's an integer,

00:07:58.280 --> 00:08:06.095
right? Value is equal.

00:08:06.095 --> 00:08:09.545
Again, it is throwing an error because you need to typecast it,

00:08:09.545 --> 00:08:11.945
because we don't know what the type is going to come in the list.

00:08:11.945 --> 00:08:13.430
It can be string,

00:08:13.430 --> 00:08:15.230
it can be Boolean in candy character,

00:08:15.230 --> 00:08:17.375
it can be a integer or a double or whatever.

00:08:17.375 --> 00:08:18.830
So we have typecast,

00:08:18.830 --> 00:08:20.420
so we know that it is going to be integer here.

00:08:20.420 --> 00:08:24.455
So we have to typecast to int now.

00:08:24.455 --> 00:08:25.955
So now what I'm gonna do,

00:08:25.955 --> 00:08:29.760
I'm gonna print the value

00:08:32.440 --> 00:08:36.785
and n here.

00:08:36.785 --> 00:08:41.010
I'm going to print out the name one.

00:08:46.780 --> 00:08:49.950
Okay, so let me run it.

00:08:50.920 --> 00:08:52.685
Now.

00:08:52.685 --> 00:08:55.610
I got the name, I got the value is a 100.

00:08:55.610 --> 00:09:01.640
So now in front of our eyes we can see the problem with the collection.

00:09:01.640 --> 00:09:04.400
So why raise much faster?

00:09:04.400 --> 00:09:07.940
Because our aid doesn't have to typecast the data.

00:09:07.940 --> 00:09:12.185
Because it is a type safety.

00:09:12.185 --> 00:09:14.510
Because the moment I create an array,

00:09:14.510 --> 00:09:16.610
it knows that it is going to be a string.

00:09:16.610 --> 00:09:18.140
So it's dedicated for strings.

00:09:18.140 --> 00:09:22.040
So you don't have to typecast or you don't have to provide

00:09:22.040 --> 00:09:26.375
any type safety because by default it's a type safety litigated one.

00:09:26.375 --> 00:09:28.580
But when it comes to collection, it's a list.

00:09:28.580 --> 00:09:30.290
List contain any kind of data,

00:09:30.290 --> 00:09:31.865
are any kind of objects.

00:09:31.865 --> 00:09:37.639
So here we have to typecast the information.

00:09:37.639 --> 00:09:41.300
So now this is where the January comes

00:09:41.300 --> 00:09:43.280
into place because we have some issues

00:09:43.280 --> 00:09:45.515
in the array and we have some issues in the collection.

00:09:45.515 --> 00:09:52.295
Which means that type safety and typecasting both has been addressed in the general case.

00:09:52.295 --> 00:09:55.325
So I'm going to show you another simple example,

00:09:55.325 --> 00:09:57.410
how it can be done.

00:09:57.410 --> 00:09:59.750
Or maybe I can do one thing.

00:09:59.750 --> 00:10:03.095
So we have one more example I previously.

00:10:03.095 --> 00:10:04.700
So generic example.

00:10:04.700 --> 00:10:10.020
So here this is generic method which is returning the data.

00:10:10.240 --> 00:10:12.935
So I want to retrieve,

00:10:12.935 --> 00:10:14.990
for example, if we have a 0 and 1, right?

00:10:14.990 --> 00:10:19.610
So two elements, I wanted to do the first element correctly.

00:10:19.610 --> 00:10:22.925
So what I'm trying to do is, let's copy this.

00:10:22.925 --> 00:10:25.190
So when you're using generics,

00:10:25.190 --> 00:10:29.825
you don't have to type cast and it is a type safety.

00:10:29.825 --> 00:10:32.425
So let me show you.

00:10:32.425 --> 00:10:34.520
Generate another apple dot.

00:10:34.520 --> 00:10:37.205
Get off 0.

00:10:37.205 --> 00:10:40.025
And I worry about,

00:10:40.025 --> 00:10:43.625
see, do I need to create any variables here?

00:10:43.625 --> 00:10:45.935
I mean, typecasting here.

00:10:45.935 --> 00:10:49.280
I don't need to be because the IDSA generates.

00:10:49.280 --> 00:10:53.675
So January is a type safety because I don't know what the type is going to come here.

00:10:53.675 --> 00:10:55.025
It can be anything.

00:10:55.025 --> 00:10:56.690
So once it's passed into the generics,

00:10:56.690 --> 00:11:01.025
that type is dedicated for that particular entire unit that,

00:11:01.025 --> 00:11:02.690
so you don't have to do that.

00:11:02.690 --> 00:11:04.655
You might think, Oh great, it will print the data.

00:11:04.655 --> 00:11:05.930
Of course it will.

00:11:05.930 --> 00:11:08.315
So value.

00:11:08.315 --> 00:11:11.165
So I'm going to print the S here.

00:11:11.165 --> 00:11:13.680
Okay, so let's run it.

00:11:14.410 --> 00:11:16.745
See what you got to Apple,

00:11:16.745 --> 00:11:19.250
which is a good buffer 0, that is,

00:11:19.250 --> 00:11:21.980
the data is available in the method call.

00:11:21.980 --> 00:11:25.850
So when it comes to a generics, It's much better.

00:11:25.850 --> 00:11:27.320
So there are issues in arrays,

00:11:27.320 --> 00:11:28.430
there are issues in collection.

00:11:28.430 --> 00:11:31.220
Everything has been addressed in the generics.

00:11:31.220 --> 00:11:33.065
So wherever it is possible,

00:11:33.065 --> 00:11:35.285
try to use the generics.

00:11:35.285 --> 00:11:38.190
Let's move to the next topic.
