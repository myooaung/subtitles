WEBVTT
0
1
00:00:05.981 --> 00:00:10.816
<v ->In this video we are going to talk about MySQL.</v>
1

2
00:00:10.816 --> 00:00:13.223
Now, MySQL is the most popular database
2

3
00:00:13.223 --> 00:00:15.381
or probably amongst some of the best.
3

4
00:00:15.381 --> 00:00:16.974
There are a couple other ones out there
4

5
00:00:16.974 --> 00:00:18.469
that are highly popular, but they claim
5

6
00:00:18.469 --> 00:00:20.001
to be the most popular database
6

7
00:00:20.001 --> 00:00:22.319
based on their 100 million downloads.
7

8
00:00:22.319 --> 00:00:25.055
It is a Relational Database System,
8

9
00:00:25.055 --> 00:00:28.959
you often see this abbreviated as RDMS.
9

10
00:00:28.959 --> 00:00:32.277
MySQL is owned by Oracle, but it is also
10

11
00:00:32.277 --> 00:00:35.964
open source and free to use and it is
11

12
00:00:35.964 --> 00:00:38.825
officially pronounced, 'My Ess Que Ell'.
12

13
00:00:38.825 --> 00:00:40.887
You'll hear a lot of people call it, my sequel,
13

14
00:00:40.887 --> 00:00:43.122
technically incorrect, because the founders
14

15
00:00:43.122 --> 00:00:45.699
do prefer it spelled out as MySQL.
15

16
00:00:45.699 --> 00:00:47.856
But, really nothing wrong with that,
16

17
00:00:47.856 --> 00:00:51.260
just want to let you know the official way of pronouncing it.
17

18
00:00:51.260 --> 00:00:55.427
Now, MySQL was created in 1995 by a Swedish company called,
18

19
00:00:56.264 --> 00:00:59.429
MySQL AB, the original developers included:
19

20
00:00:59.429 --> 00:01:02.383
Michael Widenius, I hope I'm saying that right.
20

21
00:01:02.383 --> 00:01:04.966
David Axmark and Allan Larsson.
21

22
00:01:05.851 --> 00:01:08.521
And, interesting enough, MySQL is named
22

23
00:01:08.521 --> 00:01:10.953
after Monty's daughter, My, I didn't
23

24
00:01:10.953 --> 00:01:13.114
really know that girls were named My,
24

25
00:01:13.114 --> 00:01:16.331
but kinda cute little tidbit about MySQL.
25

26
00:01:16.331 --> 00:01:20.051
Now, it is licensed under GPL, it was open sourced
26

27
00:01:20.051 --> 00:01:23.384
in the year, 2000 and by the year, 2001,
27

28
00:01:25.152 --> 00:01:28.136
MySQL's popularity grew rapidly
28

29
00:01:28.136 --> 00:01:31.019
and had over two million active installations,
29

30
00:01:31.019 --> 00:01:34.091
and that's back in the year 2001, so quite some time ago,
30

31
00:01:34.091 --> 00:01:36.502
that was gaining popularity.
31

32
00:01:36.502 --> 00:01:40.303
Now in 2005, Oracle acquired Innobase,
32

33
00:01:40.303 --> 00:01:42.436
and this is the company that was behind
33

34
00:01:42.436 --> 00:01:44.591
the storage backend of MySQL, so that did caused
34

35
00:01:44.591 --> 00:01:47.737
some concerns, but did later sign an agreement
35

36
00:01:47.737 --> 00:01:52.382
that continued allowed the use of Innobase for MySQL.
36

37
00:01:52.382 --> 00:01:55.533
In 2006, MySQL had eight million installations
37

38
00:01:55.533 --> 00:01:58.628
and the company itself had 320 employees
38

39
00:01:58.628 --> 00:02:00.878
and they were in 25 different countries
39

40
00:02:00.878 --> 00:02:03.545
and in 2008, shortly thereafter,
40

41
00:02:05.090 --> 00:02:07.840
Sun Microsystems bought MySQL and
41

42
00:02:09.205 --> 00:02:13.742
at that time, Sun was looking and were in a competition with Oracle
42

43
00:02:13.742 --> 00:02:15.901
and they were looking for a solid database
43

44
00:02:15.901 --> 00:02:19.302
and MySQL actually became a fairly popular database
44

45
00:02:19.302 --> 00:02:21.819
with large corporations, banks and telecoms
45

46
00:02:21.819 --> 00:02:24.202
so I didn't know that, it gone that far
46

47
00:02:24.202 --> 00:02:26.080
at that point of time, but it was
47

48
00:02:26.080 --> 00:02:30.023
doing a surprisingly amount of trash in the market place.
48

49
00:02:30.023 --> 00:02:33.096
And then in 2010, after some legal complications,
49

50
00:02:33.096 --> 00:02:35.945
I think Oracle bought Sun Microsystems
50

51
00:02:35.945 --> 00:02:40.086
and if I remember right, I think it was 2009 or late 2008,
51

52
00:02:40.086 --> 00:02:42.729
that Oracle launched the bid for Sun
52

53
00:02:42.729 --> 00:02:46.896
and the EU title, Oracle for about a year or so in court,
53

54
00:02:46.896 --> 00:02:48.440
because they objected to some of the
54

55
00:02:48.440 --> 00:02:51.366
anti-corrupt trust stuff, the complication
55

56
00:02:51.366 --> 00:02:53.877
between Oracle and Sun had been fearsome,
56

57
00:02:53.877 --> 00:02:55.496
then Oracle goes to buy Sun, which
57

58
00:02:55.496 --> 00:02:57.492
was a pretty interesting move.
58

59
00:02:57.492 --> 00:03:01.199
But, at this time, Sun already owned MySQL
59

60
00:03:01.199 --> 00:03:04.207
so Oracle got that and there was a lot of concern
60

61
00:03:04.207 --> 00:03:07.841
about what Oracle was going to do with MySQL.
61

62
00:03:07.841 --> 00:03:11.317
People were worried that they would either end it
62

63
00:03:11.317 --> 00:03:12.884
or return it to being close source
63

64
00:03:12.884 --> 00:03:17.424
and that's when Monty actually left Sun Microsystems
64

65
00:03:17.424 --> 00:03:21.174
and developed a fork of MySQL called, MariaDB
65

66
00:03:22.065 --> 00:03:25.540
and that was out of the concern of the future of MySQL,
66

67
00:03:25.540 --> 00:03:27.536
there was a lot of uncertainty at that time,
67

68
00:03:27.536 --> 00:03:30.153
people didn't trust Oracle to keep it open source,
68

69
00:03:30.153 --> 00:03:34.058
but today, Oracle has and MariaDB is now,
69

70
00:03:34.058 --> 00:03:36.646
out there and it's becoming more and more popular.
70

71
00:03:36.646 --> 00:03:39.492
But at this point in time, MariaDB is
71

72
00:03:39.492 --> 00:03:43.659
completely at an API level, 100% compatible with MySQL.
72

73
00:03:46.098 --> 00:03:48.530
Now let's look at some of the features of MySQL.
73

74
00:03:48.530 --> 00:03:51.788
Like we said before, it is a relational database management.
74

75
00:03:51.788 --> 00:03:55.240
So, that's going to be tables that are related to each other,
75

76
00:03:55.240 --> 00:03:58.939
so that's a pretty common design pattern for databases
76

77
00:03:58.939 --> 00:04:01.507
and now, SQL, if you did not know,
77

78
00:04:01.507 --> 00:04:04.101
it actually stands for Structured Query Language
78

79
00:04:04.101 --> 00:04:08.268
and MySQL supports the ANSI/ISO SQL standard so,
79

80
00:04:09.203 --> 00:04:12.786
I often refer to it as ANSI SQL and the one
80

81
00:04:13.941 --> 00:04:16.317
nuance there, when you're looking at
81

82
00:04:16.317 --> 00:04:18.044
the different relational databases,
82

83
00:04:18.044 --> 00:04:20.804
they all generally will support ANSI SQL,
83

84
00:04:20.804 --> 00:04:23.260
but then they also have their own extensions
84

85
00:04:23.260 --> 00:04:26.612
of the SQL language. So, Oracle does things differently
85

86
00:04:26.612 --> 00:04:28.829
and MySQL has their own extensions,
86

87
00:04:28.829 --> 00:04:31.093
so that's where you can get in trouble
87

88
00:04:31.093 --> 00:04:33.599
and then you want to look for compatibility modes,
88

89
00:04:33.599 --> 00:04:36.492
but in theory, if you're writing pure ANSI SQL,
89

90
00:04:36.492 --> 00:04:38.528
you're going to be okay, but that is
90

91
00:04:38.528 --> 00:04:41.189
pretty easy depending on common extensions
91

92
00:04:41.189 --> 00:04:43.894
and you do have to specialize to the database.
92

93
00:04:43.894 --> 00:04:46.408
So, there is a standard but the standard
93

94
00:04:46.408 --> 00:04:48.965
is not always strictly adhered to
94

95
00:04:48.965 --> 00:04:51.650
and that's why we can have tools like, Hibernate,
95

96
00:04:51.650 --> 00:04:54.003
that are certified against different databases
96

97
00:04:54.003 --> 00:04:56.379
that makes our lives easier because
97

98
00:04:56.379 --> 00:04:58.160
we're not having to worry about the nuances
98

99
00:04:58.160 --> 00:05:00.182
of different relational databases.
99

100
00:05:00.182 --> 00:05:02.943
Now under the covers, MySQL is developed
100

101
00:05:02.943 --> 00:05:05.486
in C and C++ and this is important because
101

102
00:05:05.486 --> 00:05:08.903
it makes it very portable across different platforms.
102

103
00:05:08.903 --> 00:05:11.822
So, unlike Java that comes out down to byte code
103

104
00:05:11.822 --> 00:05:15.151
that runs inside of a JVM, MySQL is actually compiled
104

105
00:05:15.151 --> 00:05:18.636
but it's compiled to the target platform.
105

106
00:05:18.636 --> 00:05:21.575
So C and C++ will run on just about anything
106

107
00:05:21.575 --> 00:05:25.479
but, you do have to compile it to that target platform
107

108
00:05:25.479 --> 00:05:28.527
then deploy those binaries to the target platform
108

109
00:05:28.527 --> 00:05:31.515
for it to run, so a slight but important difference
109

110
00:05:31.515 --> 00:05:35.255
between Java and C and C++.
110

111
00:05:35.255 --> 00:05:38.385
Now, couple other features, MySQL is
111

112
00:05:38.385 --> 00:05:40.507
very fast, stable and scalable.
112

113
00:05:40.507 --> 00:05:42.487
They're surprisingly scalable,
113

114
00:05:42.487 --> 00:05:44.089
there's a lot of big companies doing
114

115
00:05:44.089 --> 00:05:46.678
tens of millions of rows and tables on it
115

116
00:05:46.678 --> 00:05:49.040
and what's nice about MySQL's popularity
116

117
00:05:49.040 --> 00:05:52.092
is that, for just about any language that
117

118
00:05:52.092 --> 00:05:54.833
is worthwhile learning, you're going to find a
118

119
00:05:54.833 --> 00:05:57.928
driver available for it, or a client.
119

120
00:05:57.928 --> 00:05:59.999
So you can see the list there,
120

121
00:05:59.999 --> 00:06:02.628
and just about everything that we're writing in today.
121

122
00:06:02.628 --> 00:06:04.842
You can find a MySQL driver for it.
122

123
00:06:04.842 --> 00:06:08.279
Now some other features of MySQL,
123

124
00:06:08.279 --> 00:06:10.769
you do have the option of using stored procedures
124

125
00:06:10.769 --> 00:06:12.511
and this is a procedure that
125

126
00:06:12.511 --> 00:06:15.105
will be executed on the database.
126

127
00:06:15.105 --> 00:06:16.600
Not always the best idea to do,
127

128
00:06:16.600 --> 00:06:18.852
in terms of scalability, but you can do that.
128

129
00:06:18.852 --> 00:06:21.874
Triggers, a lot of times triggers are a quick workaround.
129

130
00:06:21.874 --> 00:06:24.917
I have mixed opinions about triggers myself,
130

131
00:06:24.917 --> 00:06:27.678
because they can get you into trouble quickly,
131

132
00:06:27.678 --> 00:06:30.166
because you can get into unpredictable
132

133
00:06:30.166 --> 00:06:32.221
results with those guys. Then you also have cursors
133

134
00:06:32.221 --> 00:06:35.263
and basically, this allows you to navigate through
134

135
00:06:35.263 --> 00:06:37.822
a set of data with a pointer update of both views,
135

136
00:06:37.822 --> 00:06:40.406
that's actually an interesting technology.
136

137
00:06:40.406 --> 00:06:43.614
So you can define a query that returns back a
137

138
00:06:43.614 --> 00:06:47.000
table and you can actually update through that view
138

139
00:06:47.000 --> 00:06:49.825
or that table that's returned back the query.
139

140
00:06:49.825 --> 00:06:51.840
Query caching, that's an important feature
140

141
00:06:51.840 --> 00:06:55.243
and then, subselects is also an important feature.
141

142
00:06:55.243 --> 00:06:57.131
So you can do a lot of cool stuff
142

143
00:06:57.131 --> 00:06:59.093
when you're good in SQL subselects.
143

144
00:06:59.093 --> 00:07:02.317
Important feature is ACID compliance.
144

145
00:07:02.317 --> 00:07:05.738
So, ACID is an acronym that stands for,
145

146
00:07:05.738 --> 00:07:08.394
Atomicity, probably not saying that right,
146

147
00:07:08.394 --> 00:07:09.834
my lips aren't quite working today,
147

148
00:07:09.834 --> 00:07:12.569
which means all or nothing and this applies
148

149
00:07:12.569 --> 00:07:15.750
to transactions, so your transaction might have
149

150
00:07:15.750 --> 00:07:18.389
one SQL statement or could be several statements
150

151
00:07:18.389 --> 00:07:20.535
once in the boundaries of a transaction,
151

152
00:07:20.535 --> 00:07:21.828
so this is important.
152

153
00:07:21.828 --> 00:07:24.854
Consistency, meaning that the transactions
153

154
00:07:24.854 --> 00:07:27.049
are valid to the rules of the database,
154

155
00:07:27.049 --> 00:07:29.444
so you're not violating any constraints of the database.
155

156
00:07:29.444 --> 00:07:33.496
Isolation, this is important where the transactions
156

157
00:07:33.496 --> 00:07:36.392
runs as if it was done end to end,
157

158
00:07:36.392 --> 00:07:38.873
so if you're thinking about a system that's
158

159
00:07:38.873 --> 00:07:40.981
running with lots of updates, at the same time,
159

160
00:07:40.981 --> 00:07:43.270
you need be working in isolation,
160

161
00:07:43.270 --> 00:07:45.391
so you can issue several statements
161

162
00:07:45.391 --> 00:07:48.915
that are manipulating data, that transaction
162

163
00:07:48.915 --> 00:07:51.437
shouldn't be dirty by external transactions
163

164
00:07:51.437 --> 00:07:54.133
that are happening through other threads and other users.
164

165
00:07:54.133 --> 00:07:57.995
Durability also, applies once the transaction is committed,
165

166
00:07:57.995 --> 00:08:00.849
it remains so. So once it goes to the desk, it's there,
166

167
00:08:00.849 --> 00:08:03.357
it doesn't report back that it's there
167

168
00:08:03.357 --> 00:08:05.641
but, still on memory and has not gone to desk.
168

169
00:08:05.641 --> 00:08:09.872
So the ACID is a very, very important concept having
169

170
00:08:09.872 --> 00:08:12.073
this compliance, because it does handle
170

171
00:08:12.073 --> 00:08:15.316
a multi-user heavy transactional system.
171

172
00:08:15.316 --> 00:08:18.715
This is important for databases,
172

173
00:08:18.715 --> 00:08:20.568
it doesn't buff a lot of locks
173

174
00:08:20.568 --> 00:08:22.570
and a lot of thread contention
174

175
00:08:22.570 --> 00:08:25.449
waiting for locks and waiting for transactions to complete,
175

176
00:08:25.449 --> 00:08:27.770
can get into trouble with this, but,
176

177
00:08:27.770 --> 00:08:30.718
it's also important for protecting the integrity
177

178
00:08:30.718 --> 00:08:32.734
of your transaction, if you have logic
178

179
00:08:32.734 --> 00:08:34.681
that's running on a series of statements,
179

180
00:08:34.681 --> 00:08:38.566
you don't want external influence from another thread
180

181
00:08:38.566 --> 00:08:41.806
interfering with that, so this protects from that.
181

182
00:08:41.806 --> 00:08:45.819
Other databases like Mongo, are not ACID compliant,
182

183
00:08:45.819 --> 00:08:47.645
meaning that if you're running heavy updates,
183

184
00:08:47.645 --> 00:08:49.968
you can get some pretty weird results,
184

185
00:08:49.968 --> 00:08:52.848
because you are not protected from the actions of others.
185

186
00:08:52.848 --> 00:08:54.108
So this is an important thing,
186

187
00:08:54.108 --> 00:08:57.152
Oracle actually does a very, very good job.
187

188
00:08:57.152 --> 00:08:59.704
I'm talking about the Oracle database,
188

189
00:08:59.704 --> 00:09:02.155
so MySQL does a good job, Postgres
189

190
00:09:02.155 --> 00:09:04.071
also does an exceptional job as well.
190

191
00:09:04.071 --> 00:09:06.604
When you're running a heavy transactional system
191

192
00:09:06.604 --> 00:09:08.459
especially in like, financial services,
192

193
00:09:08.459 --> 00:09:11.842
this is really paramount to have this feature there
193

194
00:09:11.842 --> 00:09:14.918
so you can trust the data was written
194

195
00:09:14.918 --> 00:09:16.825
properly to the database and was not,
195

196
00:09:16.825 --> 00:09:20.575
manipulated by or, you didn't have unintended
196

197
00:09:21.415 --> 00:09:24.513
consequences from some type of transactional scenario
197

198
00:09:24.513 --> 00:09:26.930
and multi-threading scenario.
