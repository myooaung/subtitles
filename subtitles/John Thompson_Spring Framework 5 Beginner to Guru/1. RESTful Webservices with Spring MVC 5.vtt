WEBVTT
0
1
00:00:05.180 --> 00:00:08.800
Hey folks my name is John Thompson. I am the founder of Spring Framework Guru.
1

2
00:00:09.010 --> 00:00:14.560
So in this video we are going to take a look at creating RESTful web services using Spring Boot. So we
2

3
00:00:14.560 --> 00:00:20.760
are going to be looking at Spring Boot 2 and Spring Framework 5. Inside of that Spring Framework
3

4
00:00:20.760 --> 00:00:23.350
5 actually introduced two web frameworks.
4

5
00:00:23.380 --> 00:00:26.780
One is Spring MVC and then the other is WebFlux.
5

6
00:00:26.950 --> 00:00:33.670
In this video we're going to be looking specifically at Spring MVC and the annotation controller style
6

7
00:00:33.730 --> 00:00:38.720
based of generating web services using Spring and Spring Boot.
7

8
00:00:38.740 --> 00:00:42.570
We are going to be using Spring Boot to kind of jumpstart things a little bit for us.
8

9
00:00:42.700 --> 00:00:49.600
And I'm going to show you how we can rapidly build a web service a very basic web RESTful web service
9

10
00:00:49.900 --> 00:00:50.910
using these tools.
10

11
00:00:50.920 --> 00:00:55.330
So this web service that we're going to build is going to be backed by an H2 in-memory database which
11

12
00:00:55.330 --> 00:00:58.260
we could easily swap out for any other relational database.
12

13
00:00:58.450 --> 00:01:06.150
Between that we are going to be using Hibernate for the JPA provider, so JPA  Java Persistence API.
13

14
00:01:06.430 --> 00:01:09.750
That is the standard ORM tool for Java.
14

15
00:01:09.760 --> 00:01:12.200
So we are going to be utilizing that.
15

16
00:01:12.400 --> 00:01:19.530
And on top of that I'm going to show you how to use Spring Data JPA for that. So that provides us a wrapper
16

17
00:01:19.570 --> 00:01:20.650
a real handy wrapper.
17

18
00:01:20.650 --> 00:01:27.640
All we have to do is declare our entity and then an interface using Spring Data JPA and we have our persistent
18

19
00:01:27.640 --> 00:01:33.510
services built. So Spring Boot can take care of transactions and setting up a data source for us.
19

20
00:01:33.550 --> 00:01:40.420
Initializing, entity scan. That is all handled by this framework so there is a lot that we're not going
20

21
00:01:40.420 --> 00:01:43.960
to do but it is provided by for us through Spring Boot.
21

22
00:01:44.080 --> 00:01:49.450
And then finally we are going to set up a REST controller to show you how to set up several RESTful
22

23
00:01:49.480 --> 00:01:54.550
endpoints and we're going to use JSON as our language primarily JSON not going to be dealing with
23

24
00:01:54.620 --> 00:02:00.820
XML just JSON in this example. But I'll show you how to get a list of objects back from the database
24

25
00:02:00.820 --> 00:02:05.740
so we are going to make a full trip to get to the database and then run or back JSON to the web client
25

26
00:02:06.160 --> 00:02:09.580
both and we'll show you how to get it get it by ID.
26

27
00:02:09.760 --> 00:02:15.910
And we'll even show you how to create new objects in the database using a post, HTTP POST method.
27

28
00:02:16.150 --> 00:02:22.630
So we're going to cover a lot of ground on this so this is a very introductory type level video for
28

29
00:02:22.630 --> 00:02:26.570
creating RESTful webservices using Spring MVC.
29

30
00:02:26.740 --> 00:02:30.670
And this is all built around Spring Boot 2 and Spring 5.
30

31
00:02:30.670 --> 00:02:35.380
So a lot of really cool content if you're not familiar with the Spring Framework.
31

32
00:02:35.380 --> 00:02:41.890
This is a really good video to see how we can create or how you can create RESTful web services using
32

33
00:02:41.890 --> 00:02:43.110
Spring MVC.
33

34
00:02:43.350 --> 00:02:48.520
All right in this video we are going to take a look at creating RESTful web services using Spring Framework
34

35
00:02:48.550 --> 00:02:54.310
and specifically the Spring Framework 5 and we're going to look at using the MVC library with insight
35

36
00:02:54.340 --> 00:02:55.820
of Spring Framework 5.
36

37
00:02:56.080 --> 00:03:00.940
And this is kind of the traditional way of building web services with Spring Framework.
37

38
00:03:00.940 --> 00:03:05.740
And to do this that there's actually two different ways we're going to Spring initializer to create
38

39
00:03:05.740 --> 00:03:06.340
the project.
39

40
00:03:06.340 --> 00:03:12.750
There's two methods I'm going to show you both of them and the first method is to go over to a start
40

41
00:03:12.770 --> 00:03:20.020
.spring.io and this is a website that the Spring team has set up for us to rapidly create
41

42
00:03:20.350 --> 00:03:21.210
projects.
42

43
00:03:21.340 --> 00:03:26.290
And what's really nice about this is that it creates a set of curated dependencies using Spring Boot
43

44
00:03:26.350 --> 00:03:27.630
and a parent POM.
44

45
00:03:27.790 --> 00:03:32.800
If you go back 10 years ago before Spring Boot actually Spring Boot came a couple of years ago about 10 years
45

46
00:03:32.800 --> 00:03:35.390
ago and were doing Spring applications.
46

47
00:03:35.620 --> 00:03:41.560
The mixture of dependencies was very tricky so this is a huge step up for us as far as creating that
47

48
00:03:41.560 --> 00:03:46.900
initial project. So I'm going to go ahead and use a Maven project and obviously we are going to be using
48

49
00:03:46.900 --> 00:03:47.660
Java.
49

50
00:03:48.040 --> 00:03:54.970
And here I am going to be using the new, new Spring Spring Boot 2 and right now at the time recording
50

51
00:03:54.970 --> 00:04:01.230
we're at milestone 7 and this is supposed to be the final milestone before we go on to release candidates.
51

52
00:04:01.240 --> 00:04:06.670
So right now they're still doing some integration with the different libraries of the Spring Framework.
52

53
00:04:06.770 --> 00:04:11.100
But for what we're doing is this is going to be very stable something else like that.
53

54
00:04:11.440 --> 00:04:16.930
And I'm not going to change a group id that this but I am going to switch over to the full version
54

55
00:04:16.930 --> 00:04:22.670
right here so we can see the different options and you can see there's a lot going on here.
55

56
00:04:22.690 --> 00:04:28.080
But the first thing we want to do is grab the web and we are going to play with Project Lombok.
56

57
00:04:28.090 --> 00:04:33.790
That's a really cool project that we can utilize and don't get confused here we're not going to be setting
57

58
00:04:33.790 --> 00:04:42.250
up REST repository or web services. This option for web services here is specifically for Soap web services
58

59
00:04:42.280 --> 00:04:50.180
but we are going to be doing REST web services and scroll down here and we are going to be using JPA
59

60
00:04:50.770 --> 00:04:54.740
and this is going to bring in Spring Data JPA. So that's some really cool stuff.
60

61
00:04:55.030 --> 00:05:00.670
And for our purposes we are just going to be using the H2 database so that's going to be an in memory
61

62
00:05:00.670 --> 00:05:06.310
database that's perfectly fine for our demonstration to show you how to set things up with that being
62

63
00:05:06.310 --> 00:05:13.450
that we are doing RESTful web services we don't need a template engines and you can see there's a lot
63

64
00:05:13.450 --> 00:05:15.500
of options here especially for cloud.
64

65
00:05:15.580 --> 00:05:20.310
We're not getting into the cloud stuff right now and stuff is read out.
65

66
00:05:20.350 --> 00:05:22.330
So it's not ready for Spring Boot 2.
66

67
00:05:22.350 --> 00:05:27.680
But we do want to bring in Spring Boot Actuator We'll show you some cool stuff with that.
67

68
00:05:27.910 --> 00:05:33.520
So I'm going to go ahead and generate the project and you can see here that we downloaded the zip file
68

69
00:05:33.790 --> 00:05:38.440
and this is one way that we can generate this inside this file is going to be a completely configure
69

70
00:05:38.440 --> 00:05:40.350
project for us.
70

71
00:05:40.360 --> 00:05:45.550
It's going to have stuffs of a couple of classes and then Maven POM with all dependencies on
71

72
00:05:45.560 --> 00:05:45.900
it.
72

73
00:05:46.180 --> 00:05:50.410
But what I'm going to do is show you how to do the same thing inside of IntelliJ.
73

74
00:05:50.710 --> 00:05:52.870
So let's come back over here to IntelliJ.
74

75
00:05:53.110 --> 00:05:57.950
And what I want to do is say New Project.
75

76
00:05:58.010 --> 00:06:04.600
You can see that I have this new project dialog up and you can see it's going against URL of start
76

77
00:06:04.600 --> 00:06:05.570
.spring.io.
77

78
00:06:05.680 --> 00:06:12.100
And if you look at the Chrome it's the same URL, the start.spring.io. So IntelliJ is going over
78

79
00:06:12.100 --> 00:06:17.850
to the spring.io website and utilizing the spring initializer right under the covers.
79

80
00:06:17.860 --> 00:06:21.990
But we can do everything right from inside of our IDE.
80

81
00:06:22.060 --> 00:06:26.830
Now the first thing I want to do is come up here and select the latest Java version on my machine that's
81

82
00:06:26.830 --> 00:06:35.460
1.5.2 and I'm going to go ahead and click on next and I'm going to change the domain here.
82

83
00:06:35.590 --> 00:06:41.730
If you're new to Java development for packages and also groups you always use the reverse domain name
83

84
00:06:42.000 --> 00:06:48.780
so that prevents class conflicts so long held tradition inside the Java community.
84

85
00:06:51.630 --> 00:06:57.420
And we'll just call artifacts spring-mvc-rest. So you will be using Spring MVC and just go ahead
85

86
00:06:57.430 --> 00:06:59.550
and click on next.
86

87
00:06:59.680 --> 00:07:05.090
And now you can see these options here these options look a lot like what we saw on the web here.
87

88
00:07:05.110 --> 00:07:09.660
Notice all the same or similar options you should have everything here.
88

89
00:07:09.810 --> 00:07:13.140
You can see the major cloud discovery circuit breaker.
89

90
00:07:13.140 --> 00:07:15.670
Cloud messaging it's a circuit breaker.
90

91
00:07:15.670 --> 00:07:20.290
Cloud messaging etc. are here and these are different categories that we can select from.
91

92
00:07:20.290 --> 00:07:29.600
So here we want to grab Project Lombok, SQL, also we want JPA and H2 and then down here on Ops,
92

93
00:07:29.600 --> 00:07:35.180
we wanted to do Actuator and also you can see up here the Spring Boot version.
93

94
00:07:35.330 --> 00:07:41.300
We want to get to the M7 version so that Spring Boot 2 which includes Spring Framework 5 at the time
94

95
00:07:41.300 --> 00:07:46.410
of recording we have M7 that's Milestone 7 of Spring Boot 2.
95

96
00:07:46.520 --> 00:07:48.900
This is expected to be the final milestone.
96

97
00:07:48.920 --> 00:07:54.600
Before we go into the release candidate so at the end of January 2018 they are expected to release R
97

98
00:07:54.600 --> 00:07:57.600
C1 which would be the first release candidate for Spring Boot
98

99
00:07:57.670 --> 00:07:58.400
2.
99

100
00:07:58.730 --> 00:08:04.970
So let's go ahead and select this stuff inside of M7 is pretty stable they're just resolving a few
100

101
00:08:04.970 --> 00:08:10.940
edge cases right now as some of the smaller libraries but for our purposes the stuff that we are working
101

102
00:08:10.940 --> 00:08:13.610
out is going to be pretty stable going forward.
102

103
00:08:13.610 --> 00:08:18.620
So I'm going to go ahead say next and I'm checking.
103

104
00:08:18.620 --> 00:08:24.790
Just double checking the spring-mvc-rest and I'm happy with where it storing on my machine so I am going
104

105
00:08:24.790 --> 00:08:25.890
to click Finish.
105

106
00:08:27.000 --> 00:08:29.910
I mean right now IntelliJ is going out there.
106

107
00:08:29.990 --> 00:08:35.240
Downloaded that zip file and it's unzipping it and now it's mounting the project. You can see down to the bottom
107

108
00:08:35.240 --> 00:08:36.200
of the screen.
108

109
00:08:36.350 --> 00:08:40.470
It is going through its indexing the project downloading dependencies.
109

110
00:08:40.820 --> 00:08:47.540
And now we can see that everything has come up and can see here's a project structure that is created.
110

111
00:08:47.950 --> 00:08:55.660
And let's take a look at the Maven POM here and can see this is the data that I provided is customized
111

112
00:08:55.680 --> 00:09:01.300
that Maven POM for us based on the data we provided in the setup and what's important here.
112

113
00:09:01.590 --> 00:09:02.400
That's really nice.
113

114
00:09:02.400 --> 00:09:08.580
By using Spring initializer is that we are going against the Spring Boot Starter parent project and what
114

115
00:09:08.580 --> 00:09:15.420
this does for us is it brings down a set of curated dependencies. You notice here none of the stuff in
115

116
00:09:15.420 --> 00:09:22.710
here is specifying version information so that's all curated by pivotal in the backers a Spring Framework.
116

117
00:09:22.890 --> 00:09:27.120
And now we're getting a set of dependencies that are going to work together we're not missing anything
117

118
00:09:27.120 --> 00:09:28.980
so we're going to get everything that we need.
118

119
00:09:29.100 --> 00:09:34.090
And before Spring Boot setting all this stuff up was a huge headache.
119

120
00:09:34.110 --> 00:09:38.790
Absolute huge headache because it takes you a day or so to go through find all the dependencies and
120

121
00:09:38.790 --> 00:09:42.970
then get in there like Oh I'm missing this jar or Oh I need this version.
121

122
00:09:42.990 --> 00:09:49.440
So this really alleviates a lot of headaches from the developer because I remember starting off in the
122

123
00:09:49.500 --> 00:09:54.570
early days and it was really kind of like the Wild West trying to get the right mix know spend a half
123

124
00:09:54.570 --> 00:10:01.290
a day trying to get things set up and down here on line 63 we can see that we have repositories and
124

125
00:10:01.290 --> 00:10:06.510
this is because we are on the release candidates and milestones so we need to include these as well
125

126
00:10:06.510 --> 00:10:13.830
as snapshots for the plugins. So that those are Maven dependencies. Let's go ahead and take a look at this.
126

127
00:10:13.840 --> 00:10:18.750
You can see here's our project I might just take a look at the dependencies and show you what's happening
127

128
00:10:18.750 --> 00:10:25.880
here so we have the Spring Boot Starter JPA and it's actually bring in Spring Boot Starter AOP, JDBC, 
128

129
00:10:25.930 --> 00:10:27.890
Hibernate.
129

130
00:10:28.360 --> 00:10:35.840
There's the H2 database and what this is bringing in is a lot of different dependencies for us and
130

131
00:10:35.900 --> 00:10:41.070
also Spring Boot Starter Actuator. We can see that the various things that are bringing in.
131

132
00:10:41.210 --> 00:10:46.600
So we get a lot of dependencies right out of the box by bringing in the Spring starters and it also includes in here.
132

133
00:10:46.620 --> 00:10:50.740
And here you can see that it brought in the spring-boot-starter-test.
133

134
00:10:50.740 --> 00:10:56.010
And so right out the box we are going to get things like JUnit and Mockito and Hamcrest.
134

135
00:10:56.160 --> 00:11:01.900
These are all very common libraries that we have to include manually if we were not using Spring Boot.
135

136
00:11:01.900 --> 00:11:08.610
So this is a really handy thing to start up. We are going to collapse that panel and lets come over here
136

137
00:11:08.620 --> 00:11:09.690
and expand out the source.
137

138
00:11:09.690 --> 00:11:16.290
Let's take a look at what was created for so get the whole project structure created and we see that
138

139
00:11:16.290 --> 00:11:22.110
we have a standard SpringBootApplication and this is a special class here that this is going to be used
139

140
00:11:22.110 --> 00:11:23.170
to launch Spring Boot.
140

141
00:11:23.190 --> 00:11:29.280
So this SpringBootApplication saying, run this class this class is actually a Spring Boot configuration
141

142
00:11:29.280 --> 00:11:33.330
class. So we can add in bean, sent in here configuration options.
142

143
00:11:33.360 --> 00:11:36.070
You'll see a lot of demonstrations of that.
143

144
00:11:36.090 --> 00:11:37.070
I'm not a big fan of that.
144

145
00:11:37.070 --> 00:11:39.080
I like to keep my configuration separate.
145

146
00:11:39.240 --> 00:11:42.660
I just think that's a little more tidy to do in your organization.
146

147
00:11:42.670 --> 00:11:49.380
But one thing that does trip up new people to Spring Boot is this class is going to do a component scan
147

148
00:11:49.950 --> 00:11:51.570
in this package and down.
148

149
00:11:51.570 --> 00:11:57.120
So if I were to create something a Spring component and justguru.springframework this class would
149

150
00:11:57.120 --> 00:12:01.550
not pick it up so I'd have to tell it to specifically look there. But everything that we're going to
150

151
00:12:01.560 --> 00:12:04.630
do today is going to be working from this package.
151

152
00:12:04.800 --> 00:12:10.080
So it's automatically going to pick that up so we're going to get a lot of Spring Boot goodness and
152

153
00:12:10.200 --> 00:12:11.570
a lot of people call it magic.
153

154
00:12:11.580 --> 00:12:16.440
But once you understand the broader Spring Framework it's a lot of it's taken care of a lot of stuff's
154

155
00:12:16.890 --> 00:12:21.650
making sensible defaults and sensible choices for things that you'd normally have to do anyways.
155

156
00:12:21.660 --> 00:12:23.850
But Spring Boot is going to provide that for us.
156

157
00:12:24.060 --> 00:12:28.870
So the first thing that we want to do for a demonstration is set up a domain class or we're going to
157

158
00:12:28.870 --> 00:12:31.890
use JPA for this. So I am going to come in here.
158

159
00:12:31.890 --> 00:12:37.580
Create a new package and call that domain.
159

160
00:12:37.820 --> 00:12:43.500
And let's come in here and we'll just do a Customer object so nothing too too fancy and make great new
160

161
00:12:43.800 --> 00:12:48.080
class called Customer.
161

162
00:12:48.150 --> 00:12:58.350
Now to make this a JPA class we want to do. So we are bringing in our Java persistence.
162

163
00:13:00.700 --> 00:13:02.030
Give it an id value.
163

164
00:13:04.870 --> 00:13:09.200
firstname and ...
164

165
00:13:09.440 --> 00:13:14.750
Now what I could use IntelliJ to generate the getters and setters and whatnot but I'm going to show
165

166
00:13:14.750 --> 00:13:16.120
you a shortcut.
166

167
00:13:16.510 --> 00:13:22.640
And we are going to use Project Lombok and we are going to annotate this with the Data annotation.
167

168
00:13:22.640 --> 00:13:24.410
So it's going to happen here.
168

169
00:13:24.710 --> 00:13:26.690
Let's take a closer look at the Data.
169

170
00:13:26.690 --> 00:13:28.860
Some down command click on Data.
170

171
00:13:29.300 --> 00:13:35.510
So this is going to set up getters, setters, required args constructor, toString and equal code. So
171

172
00:13:35.930 --> 00:13:37.700
Project Lombok through.
172

173
00:13:37.970 --> 00:13:43.880
It's an annotation processor so hooks into the Java compile process is going to create these classes
173

174
00:13:43.880 --> 00:13:44.850
for us.
174

175
00:13:45.140 --> 00:13:49.930
So that's going to set everything up for us so we don't have to generate all that boilerplate code.
175

176
00:13:49.970 --> 00:13:52.730
Project Lombok can do it just by annotating that class.
176

177
00:13:52.730 --> 00:13:56.970
It's real handy tool to use if you are falling along inside of IntelliJ,
177

178
00:13:57.260 --> 00:14:08.020
you might come up here to project settings and go under build ,compiler, annotation processors and make
178

179
00:14:08.020 --> 00:14:11.880
sure that you have enable annotation processing clicked off.
179

180
00:14:12.100 --> 00:14:14.500
Because IntelliJ may not be happy.
180

181
00:14:14.500 --> 00:14:19.350
I am a non Eclipse user but believe there is something similar inside of Eclipse where you want to enable
181

182
00:14:19.360 --> 00:14:25.870
annotation processing and I'm pretty sure that there is a plugin for Project Lombok with Eclipse but
182

183
00:14:25.900 --> 00:14:30.550
I am the wrong person about to ask for tips on Eclipse because I have not used Eclipse and a number
183

184
00:14:30.550 --> 00:14:30.880
of years.
184

185
00:14:30.880 --> 00:14:34.690
I'm a big IntelliJ fan. Said audio's to eclipse a long time ago.
185

186
00:14:34.990 --> 00:14:40.460
So let's go ahead and move forward with this.
186

187
00:14:40.570 --> 00:14:47.680
And then the last thing we need to do is set up our JPA entity. So we can bring in the JavaX persistence
187

188
00:14:47.680 --> 00:14:51.690
annotation. Sets a GeneratedValue
188

189
00:14:55.360 --> 00:15:05.320
and GenerationType IDENTITY. So it's going to set up that entity for us and that is our JPA domain class.
189

190
00:15:05.320 --> 00:15:11.430
So now what we want to do is use Spring Data JPA and do that.
190

191
00:15:11.430 --> 00:15:15.180
We are going to come over here and do a new package.
191

192
00:15:18.760 --> 00:15:21.130
We're just going to call it repositories.
192

193
00:15:21.130 --> 00:15:24.410
And this follows a repository model that is how Spring Data
193

194
00:15:24.400 --> 00:15:25.560
JPA works.
194

195
00:15:25.690 --> 00:15:33.120
And what we're going to do is declare an interface this time.
195

196
00:15:33.130 --> 00:15:38.980
Now you don't have to call a CustomerRepository that is by convention you'd call it whatever you want
196

197
00:15:39.460 --> 00:15:44.050
but remember more people are going to be reading your code than writing code.
197

198
00:15:44.050 --> 00:15:49.360
So you know I'd be nice to the people behind you and follow very common conventions and one common convention
198

199
00:15:49.360 --> 00:15:52.850
is to use Entity and then repository.
199

200
00:15:52.900 --> 00:15:55.540
And in this case we are going to do an extends
200

201
00:15:58.350 --> 00:16:03.750
we are going to extend out the JpaRepository and we are going to leverage Java generics
201

202
00:16:06.450 --> 00:16:12.010
and say Customer and then the second property is going to be for the ID value.
202

203
00:16:12.010 --> 00:16:18.080
So this is the entity and then ID must take a closer look at JpaRepository.
203

204
00:16:18.280 --> 00:16:25.760
You can see here this is the Spring Data API interface and this again to give us a number of options
204

205
00:16:25.760 --> 00:16:26.720
are being utilized.
205

206
00:16:26.720 --> 00:16:32.960
So this really outboxed gives us basic functionality and what happens is Spring Data JPA is going to
206

207
00:16:32.960 --> 00:16:38.240
provide us this class at runtime. So we are declaring the interface not going to get too far down the
207

208
00:16:38.240 --> 00:16:44.210
rabbit hole on Spring Data JPA but the way it works is you declare the interface and then its going
208

209
00:16:44.210 --> 00:16:46.850
to provide the implementation and we're going to be able to utilize that.
209

210
00:16:46.850 --> 00:16:52.310
Now underneath the covers Spring Data JPA is going to take care of all that the mapping commands
210

211
00:16:52.310 --> 00:16:55.910
of working with the database through Hibernate.
211

212
00:16:55.910 --> 00:17:00.090
So that's completely abstracted through. So we are going to be able to use just the ORM.
212

213
00:17:00.230 --> 00:17:03.560
It is an absolute huge time saver for us.
213

214
00:17:03.560 --> 00:17:06.350
So let's go ahead and move on with that.
214

215
00:17:06.560 --> 00:17:09.430
And another good design pattern here.
215

216
00:17:09.560 --> 00:17:13.630
So now we have our domain and our repository.
216

217
00:17:13.850 --> 00:17:17.290
What we'd like to do here is also create up a service layer.
217

218
00:17:17.300 --> 00:17:22.730
So I'm going to create a new package called services. Lets  come in here.
218

219
00:17:22.730 --> 00:17:24.070
Create CustomerService
219

220
00:17:27.500 --> 00:17:31.100
and let's do that as a interface.
220

221
00:17:32.260 --> 00:17:34.460
Now let's go ahead and declare what we want.
221

222
00:17:34.770 --> 00:17:35.320
So we want
222

223
00:17:38.610 --> 00:17:44.230
behind the.
223

224
00:17:44.410 --> 00:17:48.370
So we want to a method in there to find the customer by ID.
224

225
00:17:48.490 --> 00:17:50.890
And let's also get a list of customers
225

226
00:17:55.570 --> 00:17:57.580
and I can pass anything on that.
226

227
00:17:57.620 --> 00:18:04.190
Now we'll have to two methods here where we can get a find a customer by an ID or find all customers
227

228
00:18:04.600 --> 00:18:06.260
now that come in here.
228

229
00:18:06.500 --> 00:18:08.200
I'm going to do a alt+enter.
229

230
00:18:08.600 --> 00:18:11.620
And IntelliJ is giving me an option to implement the interface.
230

231
00:18:11.810 --> 00:18:13.470
So I'm going to go ahead and do that.
231

232
00:18:13.760 --> 00:18:15.450
And this is a Java convention.
232

233
00:18:15.470 --> 00:18:20.750
So we've created an interface and typically you are going to do,
233

234
00:18:21.080 --> 00:18:25.220
Impl. That is a pretty common Java convention.
234

235
00:18:25.250 --> 00:18:28.060
Now some people don't like use Impl.
235

236
00:18:28.250 --> 00:18:30.900
If you only have one that's perfectly fine.
236

237
00:18:31.100 --> 00:18:37.650
But if you had others like here I might be doing JpaImpl but it could also be doing a MongoDB
237

238
00:18:37.780 --> 00:18:38.450
Impl.
238

239
00:18:38.480 --> 00:18:42.960
So I get to have different persistent stores I'm going against and abstract it from my controller layer.
239

240
00:18:43.400 --> 00:18:48.800
But in this case we are just going to be running against JPA. So I am just creating a very simple implementation
240

241
00:18:48.800 --> 00:18:51.640
of it so let's go ahead and move forward with this.
241

242
00:18:51.990 --> 00:18:54.320
IntelliJ is going to set that up.
242

243
00:18:54.340 --> 00:18:58.600
Now let's go ahead and work on the implementation of this.
243

244
00:18:58.700 --> 00:19:05.950
So first thing is we're going to want to get a handle on that repository for us so we come in here
244

245
00:19:10.350 --> 00:19:17.550
and I'm declaring a final variable and I'm going to generate a constructor for that and we are going to
245

246
00:19:17.550 --> 00:19:23.250
pass in the customer's repository so the only way that we can instantiate this class is to inject in
246

247
00:19:23.340 --> 00:19:28.410
a CustomerRepository that looks like either a typo in a repository.
247

248
00:19:28.410 --> 00:19:30.510
My mistake there.
248

249
00:19:30.560 --> 00:19:33.270
So let's go ahead and work on the implementation.
249

250
00:19:33.290 --> 00:19:35.600
So we are going to return back Customer.
250

251
00:19:38.220 --> 00:19:40.460
So pretty simple implementation here.
251

252
00:19:40.920 --> 00:19:46.850
And then also here, we're just going to return back a full list now.
252

253
00:19:47.000 --> 00:19:52.010
I'm not showing you so many options as far as like paging and sorting we're just doing two very simple
253

254
00:19:52.010 --> 00:19:56.580
implementations here and this will set up our data layer.
254

255
00:19:56.900 --> 00:19:58.640
And let's go ahead.
255

256
00:19:58.760 --> 00:20:04.280
Now we are going to be backing it with an H2 database. Our databases isn't going to have anything inside
256

257
00:20:04.280 --> 00:20:08.030
of it so let's go ahead and work on setting up that database.
257

258
00:20:08.420 --> 00:20:15.410
And a real common design pattern with Spring Framework is to use an H2 database and you want to initialize
258

259
00:20:15.410 --> 00:20:16.490
it with data.
259

260
00:20:16.790 --> 00:20:19.540
So we have a very handy way to do that.
260

261
00:20:19.640 --> 00:20:24.130
And the Grail's guys used to call it bootstrap these have a bootstrap class for this.
261

262
00:20:24.140 --> 00:20:29.240
So let's go ahead and create a new package here.
262

263
00:20:29.480 --> 00:20:38.700
And I'm just calling it bootstrap. I am going to create a Java class and we'll just call it BootstrapData.
263

264
00:20:38.930 --> 00:20:46.220
And if you're not familiar bootstrap is from similar to booting up a computer system and it's from American
264

265
00:20:46.220 --> 00:20:50.010
slang where there's a saying of pull yourself up by your bootstraps.
265

266
00:20:50.070 --> 00:20:53.490
So getting yourself up in the morning by your bootstraps.
266

267
00:20:53.840 --> 00:21:00.440
So this is a kind of initialization routine and we're going to use a Spring Boot specific class.
267

268
00:21:00.640 --> 00:21:03.480
There there's a couple of different ways to initialize data.
268

269
00:21:03.470 --> 00:21:09.920
Here we are going to do this through Spring Boot this and you can do a pure Spring way by tapping into
269

270
00:21:09.920 --> 00:21:10.900
application events.
270

271
00:21:10.910 --> 00:21:13.790
But Spring Boot does have a couple of options for us.
271

272
00:21:13.870 --> 00:21:22.390
We are going to implement a CommandLineRunner and we'll make this a Component.
272

273
00:21:22.550 --> 00:21:24.430
So the Spring context will pick it up.
273

274
00:21:25.210 --> 00:21:27.760
And see that IntelliJ saying that's a red line.
274

275
00:21:27.770 --> 00:21:30.980
Let's go ahead and implement methods.
275

276
00:21:31.130 --> 00:21:35.390
So it takes on those runs so now are class is happy but we want to initialize data.
276

277
00:21:35.390 --> 00:21:41.020
So remember in our CustomerService implementation so we brought and the CustomerRepository.
277

278
00:21:41.030 --> 00:21:43.270
So I am going to copy that over.
278

279
00:21:43.280 --> 00:21:45.580
So remember cut and paste is bad.
279

280
00:21:45.800 --> 00:21:47.120
So don't be doing cut and paste
280

281
00:21:50.180 --> 00:21:55.930
go ahead and do that control + enter for constructor and allow IntelliJ to do it.
281

282
00:21:56.160 --> 00:21:58.690
And if you're familiar with Spring.
282

283
00:21:58.860 --> 00:22:01.470
Notice I'm not doing an autowire here.
283

284
00:22:01.470 --> 00:22:10.750
So in Spring and it goes for three yes I do have required args constructor and just one constructor that
284

285
00:22:10.760 --> 00:22:14.160
Spring is going to go ahead and autowire that for us.
285

286
00:22:14.160 --> 00:22:16.750
Let's fix this CustomerRepository name here.
286

287
00:22:16.740 --> 00:22:19.620
So come in here to refactor rename
287

288
00:22:23.650 --> 00:22:30.250
you will fix that little typo of error, but you may see that IntelliJ did go in and redo that.
288

289
00:22:30.280 --> 00:22:31.050
So for this
289

290
00:22:34.020 --> 00:22:35.380
regenerate the property name.
290

291
00:22:37.130 --> 00:22:40.650
And so now what we want to do is create a Customer.
291

292
00:22:43.860 --> 00:22:45.860
I'm going to pause a video while I type this out.
292

293
00:22:45.870 --> 00:22:54.250
I think you need to watch me set up POJOs. Okay I've done it a little bit and fleshed out creating some
293

294
00:22:54.250 --> 00:22:57.340
Customer objects so you can see they're on line 25.
294

295
00:22:57.490 --> 00:23:00.180
I start creating three new Customer objects.
295

296
00:23:00.190 --> 00:23:01.740
No big mystery there.
296

297
00:23:01.840 --> 00:23:07.300
I can see Michael Weston, Sam Axe, Fiona Glenanne and I'm not sure if Glenanne is spelled correctly or not
297

298
00:23:07.750 --> 00:23:12.490
but if you watch my videos you know that I am a fan of Burn Notice. So these are the characters out of
298

299
00:23:12.490 --> 00:23:20.310
Burn Notice. So we can use them as our test customers and example but it was on line 25, 30 and 35.
299

300
00:23:20.320 --> 00:23:22.220
I'm creating new Customer objects.
300

301
00:23:22.300 --> 00:23:26.180
And then you can see on 33 and 38.
301

302
00:23:26.190 --> 00:23:30.900
I am saving those using the Spring Data repository interface.
302

303
00:23:30.910 --> 00:23:36.370
Now you can see that it's been set up there and I come into the class on line 23.
303

304
00:23:36.400 --> 00:23:43.120
I am doing some output of loading customer data and then you can see down here I'm saying that we loaded
304

305
00:23:43.630 --> 00:23:44.610
X number of customers.
305

306
00:23:44.620 --> 00:23:49.840
Let's go ahead and run this right now so I'm going to go ahead and run the Spring Boot REST application.
306

307
00:23:50.190 --> 00:23:52.140
IntelliJ brings that up by default.
307

308
00:23:52.160 --> 00:23:53.860
Let's go ahead and start that up.
308

309
00:23:54.160 --> 00:24:00.460
And I just want to make sure that we are getting that output. See Spring Boot does start up and see
309

310
00:24:00.600 --> 00:24:01.920
chatter from Hibernate.
310

311
00:24:02.190 --> 00:24:06.170
You can see I made one small mistake here so it started and stopped.
311

312
00:24:06.180 --> 00:24:10.990
So nothing's really going on here and there's a very simple explanation for that.
312

313
00:24:10.990 --> 00:24:18.910
So if we look at the Maven POM and the Actuator, JPA, H2 but I forgot to bring in the spring-boot-starter-
313

314
00:24:18.960 --> 00:24:20.170
web.
314

315
00:24:20.220 --> 00:24:21.770
Go ahead and rectify that now
315

316
00:24:27.200 --> 00:24:29.760
and you can see there several different options here.
316

317
00:24:29.780 --> 00:24:32.110
web-reactive, webflux and web.
317

318
00:24:32.120 --> 00:24:35.100
We just want the web and that brings in this traditional Spring
318

319
00:24:35.160 --> 00:24:36.720
MVC. So let's bring that in.
319

320
00:24:36.730 --> 00:24:44.540
And wait until IntelliJ imports the changes and what this is let's let's examine that a little
320

321
00:24:44.540 --> 00:24:45.650
closer.
321

322
00:24:47.500 --> 00:24:55.510
Where got nested under, there it is. That do a refresh so Spring Boot Starter Web is there and this bring
322

323
00:24:55.520 --> 00:24:58.780
in a couple of different starter so we get JSON, Tomcat.
323

324
00:24:58.790 --> 00:25:00.380
That's an important one.
324

325
00:25:00.380 --> 00:25:06.800
Also Spring MVC but the way Spring Boot is going to be working especially Spring MVC, it brings
325

326
00:25:06.800 --> 00:25:12.470
in better Tomcat Servlet container and Tomcat wasn't there on the classpath. So Spring Boot
326

327
00:25:12.470 --> 00:25:13.800
didn't configure it.
327

328
00:25:13.850 --> 00:25:19.460
So we started it up and shut down right away so let's go ahead and run this again and we'll see a much
328

329
00:25:19.460 --> 00:25:20.670
different result.
329

330
00:25:21.050 --> 00:25:30.890
So we'll see it start up and then stay running because we are running inside of Servlet container.
330

331
00:25:30.980 --> 00:25:34.240
Now we can see there's additional chatter there in the log files.
331

332
00:25:34.250 --> 00:25:40.130
We can see that it set up some endpoints for us and then we can see that it also loaded Customer data.
332

333
00:25:40.340 --> 00:25:45.670
So we did bring in Spring Boot Actuator, so we do have a web application running right now.
333

334
00:25:45.710 --> 00:25:51.590
Even though we have not defined a controller Spring Boot Actuator does give us some endpoints. We can
334

335
00:25:51.590 --> 00:25:56.900
see hear them clicking on the health and we can see them bring up an application we are seeing that
335

336
00:25:56.900 --> 00:26:02.960
the database is alive and we are good. So these are different health indicators available
336

337
00:26:02.960 --> 00:26:05.610
for us through Spring Boot Actuator.
337

338
00:26:05.630 --> 00:26:07.490
If I was writing like a RabbitMQ,
338

339
00:26:07.490 --> 00:26:10.520
we do see metrics on Rabbit.
339

340
00:26:10.530 --> 00:26:15.020
If I had other options and there there's a number of different options that we can add to the health
340

341
00:26:15.050 --> 00:26:17.780
endpoint of it is a very rudimentary application.
341

342
00:26:17.950 --> 00:26:22.580
But the real nice thing about having Spring Boot Actuator installed is it does give you a health check
342

343
00:26:22.580 --> 00:26:23.450
endpoint.
343

344
00:26:23.450 --> 00:26:28.440
So if we needed to monitor that application with some type of Enterprise tool to make sure that it's
344

345
00:26:28.430 --> 00:26:29.100
alive.
345

346
00:26:29.150 --> 00:26:31.410
This is an endpoint that we could utilize.
346

347
00:26:31.430 --> 00:26:33.620
So now we do have our application up and running.
347

348
00:26:33.620 --> 00:26:35.830
I'm going to shut it down for right now.
348

349
00:26:35.880 --> 00:26:39.270
So and let's go ahead and collapse in Maven.
349

350
00:26:39.320 --> 00:26:43.850
So basically we've set up our backend Persistent store.
350

351
00:26:43.850 --> 00:26:50.330
We have a service that will respond to it but what we have not done yet is we have not created the controllers.
351

352
00:26:50.340 --> 00:26:52.270
So let's go ahead and do that now.
352

353
00:26:53.280 --> 00:27:02.010
So I'm going to come in here and create a new package and you might  guess I might call it controllers.
353

354
00:27:02.160 --> 00:27:08.250
Now some people prefer to call as endpoints not necessarily wrong. Controller isn't a necessarily wrong.
354

355
00:27:08.250 --> 00:27:10.650
It's a personal preference.
355

356
00:27:11.530 --> 00:27:13.450
So now going to create a CustomerController.
356

357
00:27:18.580 --> 00:27:27.860
Now what we want to do here is Spring MVC has annotation called RestController and this annotation I believe
357

358
00:27:27.960 --> 00:27:34.050
is also available inside a Spring WebFlux but that is the reactive stack for web applications which
358

359
00:27:34.050 --> 00:27:35.590
we are not addressing today.
359

360
00:27:35.610 --> 00:27:39.870
So this doesn't in this class as a RestController.
360

361
00:27:39.870 --> 00:27:45.220
So now the first thing that we want to do is get a hold of our service.
361

362
00:27:45.260 --> 00:27:47.160
So now just go ahead and do
362

363
00:27:50.800 --> 00:27:51.210
so.
363

364
00:27:51.270 --> 00:27:52.900
That's our CustomerService installation.
364

365
00:27:52.900 --> 00:27:53.880
I can do Command + N
365

366
00:27:53.950 --> 00:28:01.630
for a constructor that's going to set up our class now by annotating this as a RestController and
366

367
00:28:01.660 --> 00:28:06.380
providing this constructor what this is saying is it's a Spring component.
367

368
00:28:06.400 --> 00:28:09.160
So RestController is Spring stereotype.
368

369
00:28:09.310 --> 00:28:12.600
So this is to get wired up as a Spring bean and Spring
369

370
00:28:12.620 --> 00:28:18.700
when it creates this class is automatically going to inject in an instance of our CustomerService and getting
370

371
00:28:18.710 --> 00:28:22.080
a little red squiggly there so let's double check something.
371

372
00:28:22.240 --> 00:28:24.420
And I actually did make a mistake here.
372

373
00:28:24.420 --> 00:28:31.720
So this actually needs to be annotated with Service so that is another Spring stereotype. So now Spring
373

374
00:28:31.720 --> 00:28:35.710
is going to manage this component also as a Spring bean.
374

375
00:28:35.920 --> 00:28:42.690
And let's come back, back over to our controller and now you see a little squiggly went away so now that
375

376
00:28:42.690 --> 00:28:49.710
it is available there in. So now lets go ahead and set up our first mapping.
376

377
00:28:49.740 --> 00:28:51.990
So we returned back a list of customers.
377

378
00:28:58.410 --> 00:29:02.150
So pretty simple implementation you know little red line there.
378

379
00:29:02.220 --> 00:29:03.880
I've got a return statement.
379

380
00:29:03.930 --> 00:29:09.260
So this is going to be the method that we are going to use for our customers.
380

381
00:29:09.420 --> 00:29:15.210
But we want to make this a little more interesting because there's no mapping to it so we've set up
381

382
00:29:15.210 --> 00:29:19.980
our Spring object at this point but we have not done anything to set up the URL mapping.
382

383
00:29:19.980 --> 00:29:22.170
So that's what we need to tackle right now.
383

384
00:29:26.230 --> 00:29:32.020
So there's an annotation for GetMapping. So for get requests coming to the controller we are going to
384

385
00:29:32.590 --> 00:29:35.590
invoke this method but we have not provided URL mapping.
385

386
00:29:35.590 --> 00:29:43.300
Now one thing I do like to do is come up here and do public and we'll call this String
386

387
00:29:51.180 --> 00:29:57.120
so a very good habit in development is the don't repeat yourself principle.
387

388
00:29:57.130 --> 00:30:02.100
So the base URL for this API something that's going to be utilizing a lot throughout it.
388

389
00:30:02.110 --> 00:30:07.660
Now some people like to externalize this into a properties file so they can be overwritten at runtime.
389

390
00:30:07.660 --> 00:30:13.660
I personally think declaring a static final String is ideal for this because that String isn't going to
390

391
00:30:13.660 --> 00:30:14.250
change.
391

392
00:30:14.260 --> 00:30:18.820
And chances are this URL value is probably not going to change but some something that is going to
392

393
00:30:18.820 --> 00:30:20.320
be changing in different environments.
393

394
00:30:20.320 --> 00:30:27.980
We have to externalise it but here this is perfectly fine to do. So now it sets up our String for the URL
394

395
00:30:28.000 --> 00:30:30.660
that we want be utilizing.
395

396
00:30:30.710 --> 00:30:32.990
And let's go ahead and map this.
396

397
00:30:33.110 --> 00:30:35.450
So we do that with the RequestMapping annotation
397

398
00:30:42.100 --> 00:30:49.270
and by doing this we are setting up for every method on this we are declaring that this BASE_URL
398

399
00:30:49.320 --> 00:30:54.940
is going to be utilized. So any requests coming in the BASE_URL is going to be invoked.
399

400
00:30:54.940 --> 00:31:01.300
Now I do have the option if I want to do something more complex I could do RequestMapping on the method
400

401
00:31:01.300 --> 00:31:12.280
level but here what I'm saying is when I get a GET request to api/v1/customers I going to invoke this
401

402
00:31:12.610 --> 00:31:14.100
method here.
402

403
00:31:14.290 --> 00:31:23.820
So let's go ahead and test this now we're going to go ahead and run the application.
403

404
00:31:23.950 --> 00:31:26.720
Now let's go up here and we can see
404

405
00:31:31.430 --> 00:31:32.760
can see right here.
405

406
00:31:33.980 --> 00:31:38.400
That that has been mapped so this is the debug output from Spring MVC.
406

407
00:31:38.570 --> 00:31:45.410
So we have mapped api/v1/customers to method get on that method of the controller.
407

408
00:31:45.410 --> 00:31:49.710
Now let's jump over to Postman. Its a handy tool for testing web requests.
408

409
00:31:51.350 --> 00:31:54.230
And let's go over here to api/
409

410
00:31:54.560 --> 00:32:02.460
v1 and I'm going to go ahead and say send that and now we can see that I did in fact get a
410

411
00:32:02.460 --> 00:32:06.510
list of customers. So I can see that ID value, firstname, lastname.
411

412
00:32:06.660 --> 00:32:12.270
Michael Weston, Sam Axe, Fiona Glenanne. So that is a pretty simple object model from the Customer so
412

413
00:32:12.270 --> 00:32:13.100
that is a list of that.
413

414
00:32:13.110 --> 00:32:17.430
But what if we wanted to get a customer by ID.
414

415
00:32:17.430 --> 00:32:25.020
So I'd like to be able to come in here and do. Lets get Fiona she is far cuter than Michael anyways
415

416
00:32:25.770 --> 00:32:26.690
so let's do that.
416

417
00:32:26.820 --> 00:32:30.590
And now Fiona isn't found because this has not been mapped yet.
417

418
00:32:30.720 --> 00:32:34.610
So let's come back over here to IntelliJ and implement that method.
418

419
00:32:41.950 --> 00:32:47.150
So a pretty simple method that we are implementing here so we are return back customerService findBy
419

420
00:32:47.150 --> 00:32:54.770
Id and we're going to pass in the ID value. Now its a pretty simple implementation but we need to set this
420

421
00:32:54.770 --> 00:32:55.920
up a little bit.
421

422
00:32:56.000 --> 00:33:07.100
So as far as how we want this behaves over let's do GetMapping and know what we want to do is come
422

423
00:33:07.100 --> 00:33:15.110
in here and do /{id}.
423

424
00:33:15.140 --> 00:33:19.720
So this is telling Spring to look for the ID value in the URL.
424

425
00:33:19.980 --> 00:33:26.390
So this is setting that up and GetMapping is kind of like a hybrid of annotations. It includes Request
425

426
00:33:26.390 --> 00:33:32.000
Mapping so I could have done a GetMapping and RequestMapping but it's a cleaner to do it this
426

427
00:33:32.000 --> 00:33:34.190
way just what the ID value there.
427

428
00:33:34.280 --> 00:33:40.030
You'll see you'll see examples of both where they use a RequestMapping and GetMapping or just Request
428

429
00:33:40.040 --> 00:33:45.670
Mapping and specify that as a parameter inside of the annotation for RequestMapping.
429

430
00:33:45.890 --> 00:33:50.750
So there's a couple of different methods that you can see out. GetMapping the different annotations
430

431
00:33:50.750 --> 00:33:52.020
were added to.
431

432
00:33:52.070 --> 00:33:58.470
I want to say Spring 4.2, 4.1. I could be a little bit wrong on that.
432

433
00:33:58.500 --> 00:34:07.020
Now what we need to do here is we set up this PathVariable but we have not done anything here so what
433

434
00:34:07.020 --> 00:34:16.930
we want do is come in here and say @PathVariable and now what this is doing it's telling Spring.
434

435
00:34:16.980 --> 00:34:23.850
And this is by convention because I'm using the ID value so that's the name of the method parameter
435

436
00:34:24.240 --> 00:34:26.100
and it's going to match this.
436

437
00:34:26.220 --> 00:34:27.660
So that is a convention.
437

438
00:34:27.660 --> 00:34:33.190
So as long as I do the squiggly ID and have a method property called id.
438

439
00:34:33.330 --> 00:34:38.970
Now I could have two or three of these with different names obviously as far as PathVariable see you
439

440
00:34:38.970 --> 00:34:42.640
can't get a pretty long list of PathVariable in there.
440

441
00:34:42.750 --> 00:34:46.020
So you're not limited as long as they have unique names.
441

442
00:34:46.110 --> 00:34:47.190
Spring is going to handle that.
442

443
00:34:47.190 --> 00:34:49.160
So that's always working in as far as that.
443

444
00:34:49.170 --> 00:34:57.310
So now what they're saying is when we come in here and we have a value so api/v1/customers/ and
444

445
00:34:57.600 --> 00:35:05.750
id value we are going to parse out that ID value out of URL and take it from a String to a Long and pass
445

446
00:35:05.760 --> 00:35:10.910
that into our findCustomerById and then return back that Customer object.
446

447
00:35:11.190 --> 00:35:16.560
So let's go ahead and because I'm not running a Spring Boot DevTools right now I am going to have to
447

448
00:35:16.560 --> 00:35:18.470
balance Spring Boot for that.
448

449
00:35:18.480 --> 00:35:19.940
Those changes take it back.
449

450
00:35:20.100 --> 00:35:25.380
And again while starting up we are recycling the container we are going to bring back the updates to
450

451
00:35:25.380 --> 00:35:31.080
database and we are going to insert data again from our bootstrap class. A very handy thing that we're
451

452
00:35:31.080 --> 00:35:31.890
doing here.
452

453
00:35:32.100 --> 00:35:34.830
So let's go ahead and toggle over to Postman now.
453

454
00:35:36.510 --> 00:35:41.960
And we'll do a send on that. We got an internal server error.
454

455
00:35:44.910 --> 00:35:46.070
See what happened there.
455

456
00:35:47.200 --> 00:35:51.500
So it looks like we return back null type take a quick look here.
456

457
00:35:53.630 --> 00:35:54.580
No we didn't.
457

458
00:35:55.520 --> 00:35:55.810
OK.
458

459
00:35:55.820 --> 00:35:58.850
I took a little closer look at this error and this kind of weird one.
459

460
00:35:58.850 --> 00:36:05.870
And this was my mistake and let's come back over here and take a look at the implementation.
460

461
00:36:05.870 --> 00:36:12.630
So we are getting a lazy initialization error and this is a mistake in my implementation.
461

462
00:36:12.780 --> 00:36:18.170
We're here to serve some of implementation so I did get one. So if I come in here and take a look at that
462

463
00:36:18.590 --> 00:36:25.290
this is returning back a reference and by that it's a little bit different.
463

464
00:36:25.290 --> 00:36:31.820
So this is a pretty technical difference so I am doing a get one which turns back a reference and that
464

465
00:36:31.820 --> 00:36:37.690
is not what I want because that reference needs to exist inside of the Hibernate context.
465

466
00:36:38.000 --> 00:36:41.540
So Hibernate does a lot of lazy initialization which is really cool.
466

467
00:36:41.540 --> 00:36:44.770
So things aren't pulled out of the database until they're needed.
467

468
00:36:44.780 --> 00:36:47.140
So in this case that's what's happening in this case.
468

469
00:36:47.150 --> 00:36:53.340
But I'm getting outside of the Hibernate context and that's bad because we don't want that.
469

470
00:36:53.600 --> 00:36:57.520
But I do want to get that object and the proper thing to do.
470

471
00:36:57.560 --> 00:37:06.340
And this is a mistake on my part why I wrote this rather than getOne I want to do findById
471

472
00:37:10.520 --> 00:37:16.640
and that's going to return back an Optional and just going to say get and thats
472

473
00:37:16.680 --> 00:37:19.480
my mistake there and this is a change.
473

474
00:37:19.540 --> 00:37:28.020
inside of Spring Data. So Spring Data prior to Spring 5 would return back just the object and rather than
474

475
00:37:28.020 --> 00:37:34.050
an Optional so that I'm going to do something bad here and just say get so that that is bad and IntelliJ is going
475

476
00:37:34.050 --> 00:37:36.970
to give me a warning but that's just for demonstration purposes.
476

477
00:37:37.380 --> 00:37:41.280
And the more recent versions of Spring Data they are returning back the Optional so you do have to
477

478
00:37:41.280 --> 00:37:46.590
work with the Java 8 Optional class which is a very good thing to do and I do expand upon this in my
478

479
00:37:46.590 --> 00:37:47.620
courses.
479

480
00:37:47.620 --> 00:37:50.940
But for here let's go ahead and work with that.
480

481
00:37:51.010 --> 00:37:58.560
I'm going to go ahead and reinitialize this. So restart Spring Boot and we'll come up with a fresh
481

482
00:37:58.660 --> 00:38:01.660
database and get our code change in there.
482

483
00:38:02.780 --> 00:38:07.020
You know we can see we are back up and running let's toggle back over to Postman.
483

484
00:38:07.260 --> 00:38:12.960
And now if I come in here and do this I was actually running in the debugger.
484

485
00:38:14.320 --> 00:38:19.690
Come back over here we can see that Fionna Glenanne is returned properly.
485

486
00:38:19.700 --> 00:38:25.160
Now one more thing that I want to show you is how to create, create a new object so go ahead and create
486

487
00:38:25.160 --> 00:38:25.880
a Customer.
487

488
00:38:25.880 --> 00:38:29.870
So let's jump back over to IntelliJ now and we will implement that.
488

489
00:38:29.870 --> 00:38:32.750
So first thing I'm going to work backwards this time.
489

490
00:38:32.750 --> 00:38:38.020
So let's go to the CustomerController and actually stop this.
490

491
00:38:38.020 --> 00:38:39.480
We don't need that running right now.
491

492
00:38:40.840 --> 00:38:42.240
And stop him.
492

493
00:38:42.240 --> 00:38:47.040
So I'm not the CustomerController so let's go and implement that at the controller level and I'll work
493

494
00:38:47.040 --> 00:38:53.280
backwards.
494

495
00:38:53.340 --> 00:38:56.520
So we're going to create a method that's going to take in a Customer object.
495

496
00:38:56.760 --> 00:39:09.530
We want to return back customerService.saveCustomer and that will take in the Customer object and let's go
496

497
00:39:09.530 --> 00:39:10.580
ahead and decorate this.
497

498
00:39:10.580 --> 00:39:13.700
Now before we do the implementation of that method.
498

499
00:39:13.730 --> 00:39:16.980
So what I want to do is a PostMapping.
499

500
00:39:17.060 --> 00:39:26.180
So remember in our our RESTful APIs has to create a resource that's going to be through a POST and now
500

501
00:39:26.180 --> 00:39:30.560
I'm going to show you one additional annotation here because a PostMapping.
501

502
00:39:30.560 --> 00:39:39.550
We want that to return back a HTTP created status so we are going to use the ResponseStatus annotation.
502

503
00:39:39.830 --> 00:39:40.910
There it is.
503

504
00:39:41.110 --> 00:39:44.280
So that's set up to return back.
504

505
00:39:44.360 --> 00:39:46.660
So and what this is saying.
505

506
00:39:46.660 --> 00:39:54.280
So when I do a POST against api/v1/customers of a Customer object we are going to call customerService
506

507
00:39:54.370 --> 00:40:01.000
to save customer which we have not implemented yet and we are going to return back a new Customer object
507

508
00:40:01.260 --> 00:40:02.260
persisted one.
508

509
00:40:02.270 --> 00:40:08.990
Let's go and implement that hitting option enter and I'm going to go ahead and create that method.
509

510
00:40:10.140 --> 00:40:13.110
Can you say that IntelliJ automatically added that for us
510

511
00:40:17.220 --> 00:40:22.070
let's go ahead and implement methods.
511

512
00:40:22.290 --> 00:40:30.520
And in this case what we wanted to do is customerRepository.save(customer).
512

513
00:40:30.530 --> 00:40:36.240
So I was going to say that new customer entity for us. You can see how easy it is working with Spring Data JPA
513

514
00:40:36.250 --> 00:40:38.430
to go ahead and process that.
514

515
00:40:38.450 --> 00:40:42.980
So let's go ahead and start this and we'll test that out and bring this up normally.
515

516
00:40:46.960 --> 00:40:59.580
Now we are up and running and we have three customers. Must go and copy this. And now what we want to do is POST
516

517
00:41:11.750 --> 00:41:20.520
I am going to paste in the JSON, we don't want the ID value and I can't remember Jesse lastname from Burn Notice
517

518
00:41:21.540 --> 00:41:26.140
called Jessee someone I really don't remember his name Remember Jesse but don't remember his lastname.
518

519
00:41:26.460 --> 00:41:28.370
So now we're going to post this out.
519

520
00:41:28.380 --> 00:41:33.360
So we have firstname lastname and this is the JSON object so we do a post against this endpoint.
520

521
00:41:33.360 --> 00:41:40.280
Let's go out and send that now and we see that it did not bind properly so we got firstname, lastname
521

522
00:41:40.280 --> 00:41:43.300
null.
522

523
00:41:43.360 --> 00:41:45.020
Now let's go ahead over here and do a
523

524
00:41:45.030 --> 00:41:51.740
GET on that and these null properties are here because I made a very simple mistake. Because what's happening
524

525
00:41:51.740 --> 00:41:56.110
as I did do the POST against that and it did return back Id value.
525

526
00:41:56.120 --> 00:42:02.420
But what happened here is that I come back over here to my controller take a look at this.
526

527
00:42:02.600 --> 00:42:03.960
I passed on a Customer.
527

528
00:42:04.260 --> 00:42:07.720
But what happened was I didn't tell it to bind it
528

529
00:42:07.740 --> 00:42:10.750
over the RequestBody.
529

530
00:42:10.800 --> 00:42:17.860
So now with the RequestBbody annotation that tells us Spring MVC to bind it and underneath the covers,
530

531
00:42:18.030 --> 00:42:24.410
what Spring is doing it does wire in the Jackson JSON library and it's going to do all the marshalling
531

532
00:42:24.420 --> 00:42:28.140
and unmarshalling for us kind of seamlessly through the framework.
532

533
00:42:28.350 --> 00:42:30.000
So let's go ahead and try this again.
533

534
00:42:30.000 --> 00:42:33.180
I bet is going to work a lot better this time.
534

535
00:42:33.180 --> 00:42:35.210
So I'll come back over to Postman.
535

536
00:42:35.220 --> 00:42:41.820
We'll go ahead and use Jesse again and again I'm going to do a POST against localhost 8080 api/v1/customers
536

537
00:42:41.820 --> 00:42:44.920
which is API that we've mapped and we are doing a POST.
537

538
00:42:44.940 --> 00:42:46.820
Let's go ahead and do that.
538

539
00:42:48.710 --> 00:42:59.480
And we need to set the content type.
539

540
00:42:59.630 --> 00:43:05.940
And now I forget to set this Content-Type in Postman now we can see that ID for Jessee someone was
540

541
00:43:05.940 --> 00:43:07.070
created.
541

542
00:43:07.440 --> 00:43:13.140
So now it's come back over here and you can see this is where it gets persisted from the time that I
542

543
00:43:13.140 --> 00:43:17.650
did not have that RequestBody annotation on the method.
543

544
00:43:17.700 --> 00:43:19.430
So let's go on send that again.
544

545
00:43:19.450 --> 00:43:25.160
And now we can see that is there. Come back over here
545

546
00:43:27.670 --> 00:43:36.630
somebody now if we come back or get a five we can see that that data is in fact persisting. We can jump
546

547
00:43:36.630 --> 00:43:44.600
back over to and IntelliJ right now and I'm not going to implement the remainder of the RequestMethod.
547

548
00:43:44.600 --> 00:43:47.800
But let's go ahead and recap what we did here.
548

549
00:43:47.980 --> 00:43:48.820
So let me stop.
549

550
00:43:48.880 --> 00:43:53.090
So you get the screen back shut that down.
550

551
00:43:53.240 --> 00:43:55.530
So first we went in and created the Customer entity.
551

552
00:43:55.530 --> 00:43:58.450
So this is a standard JPA entity.
552

553
00:43:58.520 --> 00:44:01.410
No big mystery here so this is using JPA.
553

554
00:44:01.430 --> 00:44:07.790
And with Spring Boot in the way we're configured we are using the Hibernate implementation of JPA underneath
554

555
00:44:07.790 --> 00:44:08.640
the covers.
555

556
00:44:08.780 --> 00:44:13.130
Spring boot does bring that in and configure it automatically for us.
556

557
00:44:13.160 --> 00:44:20.570
The next thing we went in as we went and created the JPA repository and this is the Spring Data JPA
557

558
00:44:20.620 --> 00:44:27.230
a project which gives us a very robust tool set as far as working with JPA entities.
558

559
00:44:27.230 --> 00:44:32.770
Now I only scratched around the surface of the capabilities of Spring Data JPA.
559

560
00:44:32.960 --> 00:44:39.930
It's a very robust project and here I'm just demonstrating a very very simple application.
560

561
00:44:39.950 --> 00:44:45.830
Now the next thing is we went in and created our bootstrap class and bootstrap data.
561

562
00:44:45.830 --> 00:44:52.220
This class is going to run because it implements the interface CommandLineRunner. CommandLineRunner
562

563
00:44:52.250 --> 00:44:58.350
is a Spring Boot interface that basically says run me on startup so that's what this is going to do.
563

564
00:44:58.460 --> 00:45:00.020
It is a Spring component.
564

565
00:45:00.020 --> 00:45:05.900
So what happens as the Spring context comes up, and injects in a CustomerRepository again this Spring
565

566
00:45:05.900 --> 00:45:12.260
Data JPA and Spring Data JPA is providing us the runtime of that because we only provided the interface
566

567
00:45:12.740 --> 00:45:18.230
in our configuration so Spring Data JPA is going to provide us the implementation at runtime that gets
567

568
00:45:18.230 --> 00:45:22.290
injected into this class which gives us our persistence operations.
568

569
00:45:22.580 --> 00:45:25.850
That's been getting persisted to an H2 in memory database.
569

570
00:45:25.850 --> 00:45:31.670
That's why we are configured because we brought in H2 and Spring Boot is providing us all the auto configuration
570

571
00:45:31.670 --> 00:45:34.760
for working with Spring H2 database.
571

572
00:45:34.760 --> 00:45:40.950
If you notice we did not set up a data source that is being provided by Spring Boot for H2.
572

573
00:45:40.970 --> 00:45:45.020
So this sets up and creates our initial set of data for us.
573

574
00:45:45.260 --> 00:45:52.370
And then finally we went over here and created our rest control or the RestController sets up a mapping
574

575
00:45:52.760 --> 00:45:56.770
then the RequestMapping and I did use a public static final String.
575

576
00:45:56.770 --> 00:46:00.740
So I don't repeat myself when I need to use this String value again.
576

577
00:46:00.980 --> 00:46:08.260
And here we are injecting in a CustomerService implementation and that's pretty common pattern here
577

578
00:46:08.600 --> 00:46:14.620
to create a service like a service wrapper over your Spring Data repository.
578

579
00:46:14.630 --> 00:46:21.110
Now I do have examples out there where I just work with the repository directly but here let's take
579

580
00:46:21.110 --> 00:46:23.360
a quick look at the implementation of that.
580

581
00:46:23.440 --> 00:46:30.600
The service implementations is for working with the repositories and in a real business application.
581

582
00:46:30.770 --> 00:46:36.200
Typically you are going to have your web logic in the controller and any additional business logic
582

583
00:46:36.200 --> 00:46:38.990
here inside of the service layer.
583

584
00:46:38.990 --> 00:46:44.240
So the service layer is where you want to be implementing that business logic and not inside your controllers.
584

585
00:46:44.240 --> 00:46:50.900
I've seen this principle really abused where doing crazy things inside of CustomerController like obtaining
585

586
00:46:50.900 --> 00:46:56.240
database connections and everything and so controller and talk about violating the single responsibility
586

587
00:46:56.240 --> 00:46:57.010
principle.
587

588
00:46:57.170 --> 00:46:58.780
Very very bad practices.
588

589
00:46:58.940 --> 00:47:04.550
But here we have a very simple application just trying to show you if you best best practices along
589

590
00:47:04.550 --> 00:47:11.450
the way of using the implementation of a Customer or a service layer is going
590

591
00:47:11.450 --> 00:47:17.610
to be a wrapper around our persistence layer which in this case is the Spring Data repositories.
591

592
00:47:17.700 --> 00:47:23.860
So let's come back over here to the CustomerController I have mapped out three different paths on those
592

593
00:47:23.890 --> 00:47:25.340
controller URLs.
593

594
00:47:25.550 --> 00:47:30.730
So everything is utilizing the base URL api/v1/customers.
594

595
00:47:30.800 --> 00:47:35.520
And when you're dealing with RESTful API is a lot of times you can see an api v1 and then have v2
595

596
00:47:35.560 --> 00:47:41.870
and v3 as an API evolves you'll change the version to allow clients to use the old version and
596

597
00:47:41.870 --> 00:47:45.580
switch over to the new version when they're already known here.
597

598
00:47:45.620 --> 00:47:47.660
Like I said we have three implementations.
598

599
00:47:47.750 --> 00:47:51.360
If you just do it get against that URL we are going to get a list.
599

600
00:47:51.470 --> 00:47:58.260
If you do get with an ID value we're going to return back an entity with that ID from that query.
600

601
00:47:58.280 --> 00:48:02.460
And then finally I set up a PostMapping so that we can POST JSON
601

602
00:48:02.840 --> 00:48:04.210
to that endpoint
602

603
00:48:04.340 --> 00:48:10.530
URL value. So in this case I am posting that and you say on line 37 I initially forgot to do
603

604
00:48:10.550 --> 00:48:17.090
RequestBody there but that RequestBody annotations says look at the Requests body and parse out what's
604

605
00:48:17.090 --> 00:48:18.530
there in those case.
605

606
00:48:18.610 --> 00:48:24.740
We're expecting to see a Customer object in the form of JSON posts against that endpoint and we are
606

607
00:48:24.740 --> 00:48:30.020
going to parse that into a Java object using Jackson underneath the covers and again Spring Boot is
607

608
00:48:30.080 --> 00:48:32.150
configuring everything for us.
608

609
00:48:32.300 --> 00:48:39.860
So that happens through the framework that gets parsed from JSON to POJO, to a Customer POJO and then
609

610
00:48:39.860 --> 00:48:45.600
we pass that POJO into a service layer and of course that goes to Spring Data JPA.
610

611
00:48:45.810 --> 00:48:52.140
Hibernate gets persisted to the database through JPA/Hibernate and then we return back object
611

612
00:48:52.140 --> 00:48:53.600
to our client.
612

613
00:48:53.600 --> 00:48:57.570
All right I hope you enjoyed this video we did cover quite a bit of ground and I wasn't able to go in
613

614
00:48:57.570 --> 00:48:59.900
depth as I would like to on some of these subjects.
614

615
00:49:00.210 --> 00:49:02.240
If you are interested check out my course.
615

616
00:49:02.250 --> 00:49:05.930
I do have a very large course a very popular course on Spring Framework
616

617
00:49:05.930 --> 00:49:11.250
5 on Udemy thats available where I do explore these topics and a lot more depth where I can get into
617

618
00:49:11.250 --> 00:49:12.430
this and a lot more depth.
618

619
00:49:12.570 --> 00:49:13.830
But this is a great overview.
619

620
00:49:13.830 --> 00:49:15.950
I hope you really get a lot of benefit out of this.
620

621
00:49:16.050 --> 00:49:21.870
You can see how quickly you can utilize the tooling of the Spring Framework and leverage the framework
621

622
00:49:21.870 --> 00:49:27.090
to really deliver a lot of great functionality quickly once you become comfortable with those you can
622

623
00:49:27.090 --> 00:49:30.110
really knock out a lot of business functionality.
623

624
00:49:30.210 --> 00:49:35.460
And this is why this is just an example why that the Spring Framework is so popular in the Enterprise
624

625
00:49:35.460 --> 00:49:40.920
today a lot of companies are adapting this Spring Framework because developers are have a great toolset
625

626
00:49:40.950 --> 00:49:44.290
to rapidly develop Enterprise class software.
