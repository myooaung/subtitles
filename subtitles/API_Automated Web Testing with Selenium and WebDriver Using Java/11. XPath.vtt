WEBVTT
1
00:00:00.440 --> 00:00:05.960
When I pasted in the source code in our previous demo for the HTML table,

2
00:00:05.960 --> 00:00:10.160
you may have not caught that I had a comment in there that

3
00:00:10.160 --> 00:00:12.920
actually is the XPath to get to that element.

4
00:00:12.920 --> 00:00:17.140
I want to show you how I actually got that XPath.

5
00:00:17.140 --> 00:00:21.170
So looking at our test that ran and the browser page

6
00:00:21.170 --> 00:00:24.150
that popped up for our table test, here it is on the left,

7
00:00:24.150 --> 00:00:27.060
table 1, row 1, table 2, row 1, table 2,

8
00:00:27.060 --> 00:00:28.000
row 2.

9
00:00:28.000 --> 00:00:32.410
Let's look at the XPath to grab that table 2, row 2.

10
00:00:32.410 --> 00:00:38.680
The easiest way to go about this is to use the Select an element to inspect it,

11
00:00:38.680 --> 00:00:42.800
and I can see where I'm navigating through the page.

12
00:00:42.800 --> 00:00:44.890
And when I get to table 2, row 2,

13
00:00:44.890 --> 00:00:52.590
I can rightâ€‘click on it and say Copy and Copy XPath.

14
00:00:52.590 --> 00:01:01.480
Switching over to my editor, I can go inside of my TableTest and paste that,

15
00:01:01.480 --> 00:01:07.770
and you'll see that it is that exact string for me to get to that location.

16
00:01:07.770 --> 00:01:14.750
So that's how I can go ahead and get that XPath to that element on the page.

17
00:01:14.750 --> 00:01:19.940
Now let's see how we use that inside of our test.

18
00:01:19.940 --> 00:01:22.710
I'm going to make my WebDriver tables full screen.

19
00:01:22.710 --> 00:01:28.750
I'm going to actually comment out what we have so far with that

20
00:01:28.750 --> 00:01:35.470
WebElement, and I'll leave this row.getText System.out.println at

21
00:01:35.470 --> 00:01:46.760
the bottom and say WebElement row = driver.findElement. And this

22
00:01:46.760 --> 00:01:54.330
time, we're going to say By.xpath, and I still have that XPath in

23
00:01:54.330 --> 00:01:55.790
my copy/paste buffer,

24
00:01:55.790 --> 00:02:02.560
so I'm just going to paste it in. And that's it. That's all the code for me

25
00:02:02.560 --> 00:02:07.720
to go through and navigate to that specific row. Yes,

26
00:02:07.720 --> 00:02:11.750
it is an absolute path, and that can be dangerous. It can be more brittle.

27
00:02:11.750 --> 00:02:16.680
But look at the fewer lines of code that we have to get to

28
00:02:16.680 --> 00:02:19.600
this specific element. Let's run this and see if it

29
00:02:19.600 --> 00:02:21.380
produces the output that we want.

30
00:02:21.380 --> 00:02:28.090
So I'm just going to run that test again, and it's fired up my browser

31
00:02:28.090 --> 00:02:31.940
window, and immediately it's printed out table 2, row 2.

32
00:02:31.940 --> 00:02:36.500
So I've eliminated three lines of Java code to have one

33
00:02:36.500 --> 00:02:38.480
path go through and get that out.

34
00:02:38.480 --> 00:02:42.740
And think if we had tables nested three or four deep,

35
00:02:42.740 --> 00:02:46.590
which is horrific as far as HTML is concerned, but sometimes

36
00:02:46.590 --> 00:02:48.960
a lot of tools generate stuff that way.

37
00:02:48.960 --> 00:02:52.570
If you've ever written tests against tools like Salesforce,

38
00:02:52.570 --> 00:02:56.010
this is actually a really common problem that you run into.

39
00:02:56.010 --> 00:02:59.430
A lot of autogenerated content or content management systems

40
00:02:59.430 --> 00:03:01.440
have done stuff programmatically this way,

41
00:03:01.440 --> 00:03:08.000
and this is a very good way for you to go navigate down that path and grab the element that you want.

