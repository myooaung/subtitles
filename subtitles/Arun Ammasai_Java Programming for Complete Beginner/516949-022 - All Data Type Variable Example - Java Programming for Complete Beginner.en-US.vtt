WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.790
Hello everyone, Welcome back.

00:00:02.790 --> 00:00:13.455
So we know how to create a variable to space and a variable name and the data.

00:00:13.455 --> 00:00:15.570
Okay, so insert the variable itself.

00:00:15.570 --> 00:00:18.090
There are different data.

00:00:18.090 --> 00:00:22.900
So the first one is byte

00:00:24.170 --> 00:00:34.200
and int, long, float, boolean.

00:00:34.200 --> 00:00:37.005
And also we have a double.

00:00:37.005 --> 00:00:39.240
So that a tapes 1,

00:00:39.240 --> 00:00:41.100
2, 3, 4, 5, 6, 7,

00:00:41.100 --> 00:00:44.800
one else is missing a long shot, dismissing.

00:00:44.800 --> 00:00:47.780
Okay, so altogether we need to use a shot.

00:00:48.300 --> 00:00:50.035
Right?

00:00:50.035 --> 00:01:00.520
So let's create the example for each and every type of Canada that Let's do that.

00:01:00.520 --> 00:01:02.485
Let's go to the main method.

00:01:02.485 --> 00:01:07.735
So here the first thing I'm going to create a byte.

00:01:07.735 --> 00:01:12.790
So by it will only contain minus 122, 129, right?

00:01:12.790 --> 00:01:21.895
So let me create this is the syntax datatype space.

00:01:21.895 --> 00:01:27.125
X1 is equal and it will hold, for example 10.

00:01:27.125 --> 00:01:30.720
So now i'm, I'm printing X1 here.

00:01:30.790 --> 00:01:34.775
So let's go back to the command prompt and compile them again.

00:01:34.775 --> 00:01:40.850
Sam, I see Java's face class name to run that.

00:01:40.850 --> 00:01:43.415
So now we have 10.

00:01:43.415 --> 00:01:47.780
Or else if you want to modify the data 15.

00:01:47.780 --> 00:01:49.850
So you need to recompute it again.

00:01:49.850 --> 00:01:51.950
So whenever you modify some code,

00:01:51.950 --> 00:01:54.110
you need to recompile them again.

00:01:54.110 --> 00:01:55.550
So let's run it again.

00:01:55.550 --> 00:01:57.980
Now the data is 15.

00:01:57.980 --> 00:02:00.290
So we know how to use byte.

00:02:00.290 --> 00:02:02.660
Let's try care GAR,

00:02:02.660 --> 00:02:06.800
which will hold only one character.

00:02:06.800 --> 00:02:10.280
All right, so let's do that.

00:02:10.280 --> 00:02:13.380
X2 is equal.

00:02:13.690 --> 00:02:15.860
So when you provide care,

00:02:15.860 --> 00:02:17.945
it has to be inside the single quotes.

00:02:17.945 --> 00:02:21.290
Single quotes, make sure that so a,

00:02:21.290 --> 00:02:24.530
so I'm going to refer X2 here.

00:02:24.530 --> 00:02:28.370
So let's go back to the command prompt and then it again.

00:02:28.370 --> 00:02:30.980
Compare them first and then run it again,

00:02:30.980 --> 00:02:36.500
or is it won't take the new updates.

00:02:36.500 --> 00:02:38.420
So now I can see the a.

00:02:38.420 --> 00:02:41.525
You might think what will happen if I probably a B.

00:02:41.525 --> 00:02:45.590
So which will end up with a compilation issue.

00:02:45.590 --> 00:02:49.290
It's not a proper variable.

00:02:49.800 --> 00:02:53.305
Okay, Let's try integer.

00:02:53.305 --> 00:02:58.480
Int X3 is equal into VR retried, right?

00:02:58.480 --> 00:03:08.275
So let's try long X3 is equal to 155.

00:03:08.275 --> 00:03:11.365
So then you can provide X3 here.

00:03:11.365 --> 00:03:15.895
And long both of them belong to the numeric data.

00:03:15.895 --> 00:03:18.115
But they have a different kind of a limitation.

00:03:18.115 --> 00:03:21.625
When you are going for huge numbers, you need to go for long.

00:03:21.625 --> 00:03:26.330
So let's go back to the command prompt and compel them again.

00:03:29.040 --> 00:03:31.710
Cool, we got 155.

00:03:31.710 --> 00:03:34.175
So what is we need to check it out.

00:03:34.175 --> 00:03:36.185
So we tried int byte.

00:03:36.185 --> 00:03:38.510
So can we train a shot also?

00:03:38.510 --> 00:03:43.580
You can try that, right? So I shot is 32 a sum, something like that.

00:03:43.580 --> 00:03:45.335
Okay, I'm an exact number.

00:03:45.335 --> 00:03:49.505
So datatype shot Space X4.

00:03:49.505 --> 00:03:54.350
So I'm going to provide some random data.

00:03:54.350 --> 00:04:00.935
So now I'm going to print the X4 here if we want to employ multiple SOP here.

00:04:00.935 --> 00:04:03.320
So for each and everything.

00:04:03.320 --> 00:04:10.470
So let's go back to the command prompt in compiled them and run it again.

00:04:10.480 --> 00:04:14.520
Now you see 1, 2, 3, double for Azure.

00:04:14.860 --> 00:04:17.390
So there are two more.

00:04:17.390 --> 00:04:21.635
We need to check the float and double.

00:04:21.635 --> 00:04:25.865
Both of them represents that decimal values.

00:04:25.865 --> 00:04:29.510
Okay, So let me create float.

00:04:29.510 --> 00:04:35.450
Float x five is like 20,

00:04:35.450 --> 00:04:38.225
500 by 2025 one.

00:04:38.225 --> 00:04:41.850
So let's print the X5 here.

00:04:42.580 --> 00:04:48.690
Let's go back to the command prompt and compile them on wartime.

00:04:49.090 --> 00:04:55.760
See, we've got an error. So what could be the narrator says incompatible types.

00:04:55.760 --> 00:04:58.460
So I declare a variable as a float.

00:04:58.460 --> 00:05:01.205
And I mentioned to alpine 51,

00:05:01.205 --> 00:05:06.980
The one thing to keep in mind when you're using float and double.

00:05:06.980 --> 00:05:10.250
You need to provide when you're declaring

00:05:10.250 --> 00:05:13.670
an employee the value you need to provide to specify it's

00:05:13.670 --> 00:05:20.675
a float data as it gets if you're using WVD and to provide d here,

00:05:20.675 --> 00:05:28.535
which is Delhi, the comparison it is the value belongs to a decimal, right?

00:05:28.535 --> 00:05:29.765
Let's do that.

00:05:29.765 --> 00:05:32.940
So let's, let's recompile it again.

00:05:34.030 --> 00:05:38.370
Cool numbers working there it is gone and run it again.

00:05:38.370 --> 00:05:40.240
Alpine phi 1.

00:05:40.240 --> 00:05:43.465
So let's do the same thing for w also.

00:05:43.465 --> 00:05:47.485
Double x is equaled.

00:05:47.485 --> 00:05:50.665
So 50.512.

00:05:50.665 --> 00:05:54.760
As I mentioned, you need to provide the what'll happen if you're uncovering

00:05:54.760 --> 00:06:02.575
be no issues because double is a higher priority.

00:06:02.575 --> 00:06:04.840
Float is a lesser priority.

00:06:04.840 --> 00:06:09.190
So it can take anything you need to.

00:06:09.190 --> 00:06:12.745
You don't have to specifically provide the because when you're using long, right?

00:06:12.745 --> 00:06:15.790
Because long is bigger than int character.

00:06:15.790 --> 00:06:19.015
So even if you prefer in the ear plugs up the similar way.

00:06:19.015 --> 00:06:25.250
But it is better to provide D here because it easy for people to understand,

00:06:25.250 --> 00:06:28.595
Okay, this value belongs to W. And then we can run it again.

00:06:28.595 --> 00:06:31.910
Now we got 12.5.

00:06:31.910 --> 00:06:35.600
Okay, sorry, I wanted to print X6,

00:06:35.600 --> 00:06:40.140
X6 and save it and go back and compare them again.

00:06:41.770 --> 00:06:45.965
So now we've got 50.512.

00:06:45.965 --> 00:06:53.615
Okay, So now we tried all the different types of variables, correct?

00:06:53.615 --> 00:06:57.980
So now we need to check types of variable be very different datatypes.

00:06:57.980 --> 00:07:00.890
Now, now we will try different types of video.

00:07:00.890 --> 00:07:05.310
I mean to say that global, local end, static.
