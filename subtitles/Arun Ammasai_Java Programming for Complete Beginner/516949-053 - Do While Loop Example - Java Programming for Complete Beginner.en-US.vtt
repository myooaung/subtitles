WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.530
Hi everyone. Welcome back.

00:00:01.530 --> 00:00:04.380
So before I move to while I'm in do-while loop,

00:00:04.380 --> 00:00:07.710
let me give you another example because I just showed you a very sad,

00:00:07.710 --> 00:00:08.850
very simple example, right?

00:00:08.850 --> 00:00:17.200
So we used to follow Bedouins array to print the data collected revenue we tried here.

00:00:17.600 --> 00:00:21.190
So following example. So let's try that.

00:00:21.190 --> 00:00:24.950
We can do that using while loop.

00:00:24.950 --> 00:00:26.540
I also saw how we can do that.

00:00:26.540 --> 00:00:28.130
I have a class, right?

00:00:28.130 --> 00:00:30.380
So let's write a while loop.

00:00:30.380 --> 00:00:31.670
Correct?

00:00:31.670 --> 00:00:34.680
So I looked the condition is going to be,

00:00:35.110 --> 00:00:39.270
But before that in an initializer value,

00:00:39.400 --> 00:00:46.580
int j is equal to 0. Okay?

00:00:46.580 --> 00:00:56.495
So while the condition is less than cars dot length,

00:00:56.495 --> 00:01:03.410
and then what you can do is 0.

00:01:03.410 --> 00:01:14.540
And you can print and make sure you're incrementing properly.

00:01:14.540 --> 00:01:19.490
So now what I'm gonna do is I'm just common this one to see the outcome,

00:01:19.490 --> 00:01:25.370
the cost. We're going to go.

00:01:25.370 --> 00:01:33.630
Right? So this is how we need to use that while against the array.

00:01:33.940 --> 00:01:37.685
Because our next example we're going to talk about the Do While.

00:01:37.685 --> 00:01:40.985
It is pretty much similar like other while.

00:01:40.985 --> 00:01:45.270
But when do we need to use up about that?

00:01:46.660 --> 00:01:52.205
Hello everyone. So let us see how the do-while is working.

00:01:52.205 --> 00:01:53.345
It is similar to wildlife.

00:01:53.345 --> 00:01:56.120
We all the loop is pretty much doing the same job.

00:01:56.120 --> 00:01:58.940
Okay, So even do while it is performing,

00:01:58.940 --> 00:02:01.175
reboot or learning a chord.

00:02:01.175 --> 00:02:03.575
For a certain times.

00:02:03.575 --> 00:02:08.670
Again, it doesn't know what is a fixed value for the limit.

00:02:08.830 --> 00:02:11.795
The only reason we're using do-while loop,

00:02:11.795 --> 00:02:15.335
whether the condition is true or wrong, I don't care.

00:02:15.335 --> 00:02:18.990
But at least two ones, the loop we learn.

00:02:19.120 --> 00:02:23.195
So when you're using while loop,

00:02:23.195 --> 00:02:24.455
it will check the condition,

00:02:24.455 --> 00:02:27.665
then it will go inside the loop.

00:02:27.665 --> 00:02:30.395
But when you're using do while,

00:02:30.395 --> 00:02:33.485
the first thing it will go inside the implementation logic,

00:02:33.485 --> 00:02:36.785
it will go inside the code and execute.

00:02:36.785 --> 00:02:39.260
Then it will check the condition.

00:02:39.260 --> 00:02:45.499
So that is the reason it will Unity use the do-while loop when it is necessary.

00:02:45.499 --> 00:02:47.270
So whenever you need to, at least your

00:02:47.270 --> 00:02:49.670
coordinate to be executed only once, at least once.

00:02:49.670 --> 00:02:52.955
So those kind of sentence you can go for do-while loop.

00:02:52.955 --> 00:02:54.605
Okay?

00:02:54.605 --> 00:02:57.920
So our syntax, it is steady,

00:02:57.920 --> 00:02:59.360
it is pretty much like a while,

00:02:59.360 --> 00:03:02.165
but see the difference here.

00:03:02.165 --> 00:03:03.680
So the initial value we have,

00:03:03.680 --> 00:03:06.470
we have our increment, decrement and also we have a condition.

00:03:06.470 --> 00:03:08.375
But see the core.

00:03:08.375 --> 00:03:11.780
I have something called block and awhile.

00:03:11.780 --> 00:03:17.435
So do block which contains the statements.

00:03:17.435 --> 00:03:23.900
And once that do I do part is executed Danone later go on to the wild part.

00:03:23.900 --> 00:03:27.800
So that is why the do-while always

00:03:27.800 --> 00:03:32.645
render core and then into more wander while condition to check.

00:03:32.645 --> 00:03:34.925
So next time when it comes to the dual,

00:03:34.925 --> 00:03:37.265
it will check whether the data's exist or not.

00:03:37.265 --> 00:03:38.960
So based on that,

00:03:38.960 --> 00:03:40.580
they do well, we look.

00:03:40.580 --> 00:03:42.440
So while we check the condition,

00:03:42.440 --> 00:03:45.740
then I'll go inside and do it, execute the code.

00:03:45.740 --> 00:03:47.810
Then it will check the condition.

00:03:47.810 --> 00:03:49.955
Again. It's an example here.

00:03:49.955 --> 00:03:55.090
Okay, so let's create one more example to explore.

00:03:55.090 --> 00:04:01.430
Do an example. So do-while example.

00:04:03.960 --> 00:04:07.040
Let's create a main method.

00:04:07.200 --> 00:04:10.240
So we notice index, right?

00:04:10.240 --> 00:04:19.460
Do an open sunblock and then while you can hear condition.

00:04:19.560 --> 00:04:22.255
So this is the syntax.

00:04:22.255 --> 00:04:24.685
So let's try that. So do.

00:04:24.685 --> 00:04:26.635
So what I'm going to do here,

00:04:26.635 --> 00:04:28.330
we need to have initial value.

00:04:28.330 --> 00:04:33.355
That's the first thing, int I is equal to one.

00:04:33.355 --> 00:04:36.670
So we are doing those M12 then print.

00:04:36.670 --> 00:04:41.170
So System.out.print Alan.

00:04:41.170 --> 00:04:45.655
So I'm going to print the value of I and I'm incrementing the data.

00:04:45.655 --> 00:04:48.625
See here the incremental happening and they do set.

00:04:48.625 --> 00:04:51.760
Then after that we have a while.

00:04:51.760 --> 00:04:56.000
Here we have condition I less than or equal to 10.

00:04:56.190 --> 00:04:59.950
So this is how the loop will walk into wide.

00:04:59.950 --> 00:05:01.600
So what hasn't mentioned,

00:05:01.600 --> 00:05:04.270
do it always execute at least once?

00:05:04.270 --> 00:05:07.045
So first it will come, it load the initial value,

00:05:07.045 --> 00:05:09.190
it lazy you to do.

00:05:09.190 --> 00:05:11.095
So what'll happen?

00:05:11.095 --> 00:05:14.515
One will print here and then it'll go increment. One becomes two.

00:05:14.515 --> 00:05:18.715
So two less than Isaac Newton. It's true.

00:05:18.715 --> 00:05:22.105
Then a, again it'll go and do an ETL continue up to 10.

00:05:22.105 --> 00:05:24.910
So when the time of 10 less than or equal 10.

00:05:24.910 --> 00:05:28.690
But Lappin and ligand-gated to do and here to print I plus, plus.

00:05:28.690 --> 00:05:31.420
So 10 becomes 11 and then condition is false,

00:05:31.420 --> 00:05:33.490
then it will come out of the entire loop.

00:05:33.490 --> 00:05:34.450
Okay?

00:05:34.450 --> 00:05:40.465
Can it, and this kinda that 10, 11, 12, 10.

00:05:40.465 --> 00:05:43.045
And this is how it'll work.

00:05:43.045 --> 00:05:46.180
And you can do the reverse order also in charge of bad,

00:05:46.180 --> 00:05:47.605
you can do minus minus.

00:05:47.605 --> 00:05:54.010
And here you can do greater than or equal to one.

00:05:54.010 --> 00:05:58.910
So now you can even feel the data from 109,

00:06:00.250 --> 00:06:05.015
Eight, seven up to one in a descending order.

00:06:05.015 --> 00:06:08.510
So you might ask, so we tried RFR loop

00:06:08.510 --> 00:06:11.630
and while Canada then while loop, do-while loop also.

00:06:11.630 --> 00:06:12.950
Yes, which we can do that.

00:06:12.950 --> 00:06:15.665
So we have our list of array, the array here.

00:06:15.665 --> 00:06:20.090
So let's initialize n. J is equal to 0.

00:06:20.090 --> 00:06:23.285
And then it's opened a duple.

00:06:23.285 --> 00:06:29.130
And here what I'm gonna do System.out.println and costs.

00:06:31.450 --> 00:06:41.340
And then the while I'm taking j less than cars,

00:06:44.980 --> 00:06:47.570
I, let me comment this one.

00:06:47.570 --> 00:06:56.795
See that only the Lucas doing infinite,

00:06:56.795 --> 00:06:58.700
that means something wrong in our code.

00:06:58.700 --> 00:07:00.170
Okay, let's go back.

00:07:00.170 --> 00:07:01.700
See what happened.

00:07:01.700 --> 00:07:05.930
We have the red and the increment is missing here, right?

00:07:05.930 --> 00:07:08.435
We need to provide j plus plus.

00:07:08.435 --> 00:07:13.340
So that is why I mentioned every time when you're doing the increment,

00:07:13.340 --> 00:07:16.985
make sure the looping and Gilman plays a big role.

00:07:16.985 --> 00:07:18.005
Okay?

00:07:18.005 --> 00:07:21.815
So this is going to make use of looping.

00:07:21.815 --> 00:07:27.020
So based on situations in a do decide which kind of loop you're going to use.

00:07:27.020 --> 00:07:29.720
If you know the limit, how many times my loop is going to run.

00:07:29.720 --> 00:07:35.270
You can go for normal for loop or else you

00:07:35.270 --> 00:07:41.255
can use for an antelope so that you don't need to based on travel, based on the index.

00:07:41.255 --> 00:07:43.490
You can based on the elements.

00:07:43.490 --> 00:07:46.145
Or else we can have a label for loop.

00:07:46.145 --> 00:07:49.955
And then we have a while also do while.

00:07:49.955 --> 00:07:52.260
So thank you.
