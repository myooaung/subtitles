WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.280
Hello everyone, Welcome back.

00:00:02.280 --> 00:00:05.100
So now we're going to talk about logical operator.

00:00:05.100 --> 00:00:07.050
So first of all, we need to know what is

00:00:07.050 --> 00:00:09.870
a logical operator from the name itself may have answered,

00:00:09.870 --> 00:00:15.780
okay, so the logical operators will be used to check some logic.

00:00:15.780 --> 00:00:19.155
For example, you have two numbers

00:00:19.155 --> 00:00:22.770
and you wanted to check whether the two numbers are same.

00:00:22.770 --> 00:00:23.925
Okay.

00:00:23.925 --> 00:00:25.800
And do you have another method or

00:00:25.800 --> 00:00:29.220
another variable and you want to compare both of them. Both are same.

00:00:29.220 --> 00:00:31.680
So you have one condition a greater than 10,

00:00:31.680 --> 00:00:34.020
and you have another condition,

00:00:34.020 --> 00:00:36.555
B greater than 20.

00:00:36.555 --> 00:00:43.400
And in-between, you add something called AND OR are not required.

00:00:43.400 --> 00:00:44.435
That is a possible.

00:00:44.435 --> 00:00:46.295
See even in this example,

00:00:46.295 --> 00:00:50.345
you can try x and y are same,

00:00:50.345 --> 00:00:53.195
or X, or Y,

00:00:53.195 --> 00:00:54.950
or X nought equals y,

00:00:54.950 --> 00:00:56.360
anything is possible, right?

00:00:56.360 --> 00:00:58.445
So it's a logical operator,

00:00:58.445 --> 00:01:03.350
is mainly used in conditional statements like if-else and four.

00:01:03.350 --> 00:01:08.764
All right, so let's do it in a simple example.

00:01:08.764 --> 00:01:12.065
We'll talk about how the logical operator is working.

00:01:12.065 --> 00:01:22.010
So I'm going to create a new failure which is logical operator example.

00:01:22.010 --> 00:01:25.170
So let's say the file.

00:01:30.960 --> 00:01:34.960
Okay, so now I have class ready,

00:01:34.960 --> 00:01:36.670
so I have a main method ready.

00:01:36.670 --> 00:01:38.410
So what we need to do,

00:01:38.410 --> 00:01:40.030
we need to validate, okay,

00:01:40.030 --> 00:01:42.260
let's have some example.

00:01:42.420 --> 00:01:45.879
So let's have two Booleans.

00:01:45.879 --> 00:01:51.460
Boolean V1 is equal to true.

00:01:51.460 --> 00:01:54.430
Or if you want to keep it as a better example,

00:01:54.430 --> 00:01:57.130
let's have some integer here.

00:01:57.130 --> 00:02:06.715
So int a and int b is equal to phi,

00:02:06.715 --> 00:02:10.505
and int C is equal to 20.

00:02:10.505 --> 00:02:14.795
So we're going to check and condition.

00:02:14.795 --> 00:02:19.205
So firstly, let me tell you what are the operators we have 100 talk about.

00:02:19.205 --> 00:02:23.930
This is unconditioned two and that is called as an end.

00:02:23.930 --> 00:02:29.375
And this is to pipe symbols are or condition and one naught equal to, okay?

00:02:29.375 --> 00:02:30.740
So basically as I mentioned,

00:02:30.740 --> 00:02:31.790
it is a logical operator.

00:02:31.790 --> 00:02:35.705
It will check between two logical, correct.

00:02:35.705 --> 00:02:38.735
So when you're using uncondition,

00:02:38.735 --> 00:02:41.660
so that is conditioned on the left side and the right side.

00:02:41.660 --> 00:02:43.920
If both has to be true.

00:02:44.530 --> 00:02:48.140
In case you first condition return false,

00:02:48.140 --> 00:02:51.380
it will never check the condition because and it's always

00:02:51.380 --> 00:02:55.610
expecting every condition inside that will return a true.

00:02:55.610 --> 00:02:58.790
So even if one single thing is happening, file,

00:02:58.790 --> 00:03:03.170
it will not check the other condition, or it is.

00:03:03.170 --> 00:03:07.910
It will try to look for all the condition is any one of the condition is true,

00:03:07.910 --> 00:03:10.130
then it will go for it.

00:03:10.130 --> 00:03:12.545
Let me check all of them.

00:03:12.545 --> 00:03:16.070
So what I'm gonna do is I'm going to print the data here.

00:03:16.070 --> 00:03:22.805
System dot out, dot print LN.

00:03:22.805 --> 00:03:29.550
So here I'm going to check the uncondition.

00:03:30.670 --> 00:03:33.815
So this is just a string to display.

00:03:33.815 --> 00:03:38.540
So it may create a bracket so I can see the exact condition.

00:03:38.540 --> 00:03:39.815
So what I'm trying to do,

00:03:39.815 --> 00:03:49.490
I'm taking a less than b and a less than c.

00:03:49.490 --> 00:03:51.125
So this is my condition.

00:03:51.125 --> 00:03:58.490
So this is your condition and this is another condition in between we have uncondition,

00:03:58.490 --> 00:04:01.010
correct Simon AND operator.

00:04:01.010 --> 00:04:03.395
So here is my first logic,

00:04:03.395 --> 00:04:05.015
and here is my second logic.

00:04:05.015 --> 00:04:08.540
So between logic, we'll use logical operator,

00:04:08.540 --> 00:04:10.190
that is why it is called as logical operator.

00:04:10.190 --> 00:04:15.695
I do use my logical operator between some logical, I mean some logics.

00:04:15.695 --> 00:04:18.500
So L is then based on logic and near greater than B's.

00:04:18.500 --> 00:04:21.455
Another logic I'm taking if both of them are true,

00:04:21.455 --> 00:04:25.250
if in case a less than b sweetening fall into ONE chip, the second one.

00:04:25.250 --> 00:04:27.499
Because when you're using uncondition,

00:04:27.499 --> 00:04:29.345
both hash written true.

00:04:29.345 --> 00:04:30.620
Okay, in our scenario,

00:04:30.620 --> 00:04:32.270
what l is and B,

00:04:32.270 --> 00:04:34.685
so what is 8 and b is equal to 5.

00:04:34.685 --> 00:04:38.930
So L is MB, which is true.

00:04:38.930 --> 00:04:43.760
And what is a greater L is then see a less than c,

00:04:43.760 --> 00:04:45.635
less than two, and D, which is wrong.

00:04:45.635 --> 00:04:46.955
So it is a false.

00:04:46.955 --> 00:04:53.190
So obviously it will it enough files because one is returning true, one is returning.

00:04:53.830 --> 00:04:58.865
So when you are using and I'm in and,

00:04:58.865 --> 00:05:00.680
and if any one is returning false,

00:05:00.680 --> 00:05:03.160
the entire statement is false.

00:05:03.160 --> 00:05:10.760
Can check that, okay, go back to the Java compiler and Java C.

00:05:10.760 --> 00:05:16.355
So using logical operators example.

00:05:16.355 --> 00:05:21.575
In java, logical example,

00:05:21.575 --> 00:05:29.075
see the unconditioned which is returning fault because one of them is returning false.

00:05:29.075 --> 00:05:32.135
So then I think becomes false.

00:05:32.135 --> 00:05:35.190
Okay, so let's try the same thing.

00:05:36.750 --> 00:05:41.420
This one here, I'm going to use r.

00:05:41.670 --> 00:05:42.910
Okay?

00:05:42.910 --> 00:05:46.165
So instead of and I'm going to use are.

00:05:46.165 --> 00:05:50.305
So unlike than condition or we'll check,

00:05:50.305 --> 00:05:55.060
is there any logic which will return a true?

00:05:55.060 --> 00:05:56.440
So here what happened?

00:05:56.440 --> 00:05:59.020
So a less than b, which is true.

00:05:59.020 --> 00:06:00.190
So what happened?

00:06:00.190 --> 00:06:01.675
It won't check the second condition.

00:06:01.675 --> 00:06:03.175
It will simply return a true.

00:06:03.175 --> 00:06:06.040
It is unconditionally our conditioning, which we'll check.

00:06:06.040 --> 00:06:10.945
Is there any condition returns true if any one of them returns true, it will return true.

00:06:10.945 --> 00:06:15.310
And everything has written true, then only true.

00:06:15.310 --> 00:06:19.370
So let's go back and compare them again.

00:06:20.970 --> 00:06:23.095
See the first one is,

00:06:23.095 --> 00:06:25.330
the condition is the same.

00:06:25.330 --> 00:06:31.030
I mean the logics which we checked and the border line are same,

00:06:31.030 --> 00:06:33.640
but the operator which we use this reference.

00:06:33.640 --> 00:06:36.550
So because of that outcome is entirely changed.

00:06:36.550 --> 00:06:38.125
So keep that in mind.

00:06:38.125 --> 00:06:43.630
And we'll always look for bottled 100 and true and R,

00:06:43.630 --> 00:06:45.715
which will accept any one of them.

00:06:45.715 --> 00:06:50.575
And similar way, you can do the not equal also.

00:06:50.575 --> 00:06:52.105
So what I'm gonna do,

00:06:52.105 --> 00:06:54.830
I'm going to use the same condition here.

00:06:57.510 --> 00:07:04.345
So condition or not,

00:07:04.345 --> 00:07:11.620
not means with this one which will return false, correct, amusing.

00:07:11.620 --> 00:07:15.730
And before that, I'm taking is not false.

00:07:15.730 --> 00:07:19.850
Great, Let's go back and compare them.

00:07:20.820 --> 00:07:24.684
And then it true exactly.

00:07:24.684 --> 00:07:27.970
Because it is taking either the faults,

00:07:27.970 --> 00:07:29.890
this condition returning files, right?

00:07:29.890 --> 00:07:32.035
So I'm seeking is false.

00:07:32.035 --> 00:07:36.025
So this is how we introduce AND,

00:07:36.025 --> 00:07:39.445
or, and this excellent.

00:07:39.445 --> 00:07:42.805
Okay, this will check for not false condition.

00:07:42.805 --> 00:07:47.810
Okay, so let's meet each other in the next video with another operator.
