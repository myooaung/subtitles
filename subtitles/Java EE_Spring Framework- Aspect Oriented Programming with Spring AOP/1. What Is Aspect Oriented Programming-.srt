1
00:00:01,440 --> 00:00:04,000
[Autogenerated] Hello, I am cattle into dosa.

2
00:00:04,000 --> 00:00:08,450
Welcome to this aspect oriented programming with Spring a Opie course.

3
00:00:08,450 --> 00:00:09,310
It targets Java.

4
00:00:09,310 --> 00:00:13,820
Developers who are already proficient in writing Java core code already

5
00:00:13,820 --> 00:00:18,260
know the basics of the spring framework and are interested in learning how

6
00:00:18,260 --> 00:00:23,340
to develop applications that may easily separate the rial business logic

7
00:00:23,340 --> 00:00:25,740
from the cross cutting functionality.

8
00:00:25,740 --> 00:00:30,990
So let's get started and first answer these questions.

9
00:00:30,990 --> 00:00:37,680
What this aspect oriented programming This course will show you howto

10
00:00:37,680 --> 00:00:42,330
build applications using spring aspect oriented programming and applying

11
00:00:42,330 --> 00:00:44,980
it in working with a simple job application,

12
00:00:44,980 --> 00:00:49,910
implementing the business logic for the management of flights and passengers.

13
00:00:49,910 --> 00:00:53,170
The focus will be on clearly explaining the concept of

14
00:00:53,170 --> 00:00:55,090
aspect oriented programming toe.

15
00:00:55,090 --> 00:00:57,080
Apply them In practice,

16
00:00:57,080 --> 00:01:00,670
this introductory motor will first review the key concepts of aspect

17
00:01:00,670 --> 00:01:05,640
oriented programming will discuss about common AARP use cases.

18
00:01:05,640 --> 00:01:08,730
We'll discuss the concepts of aspects during points,

19
00:01:08,730 --> 00:01:12,030
advices, point cuts, target objects,

20
00:01:12,030 --> 00:01:16,200
introductions and we'll explain how a Opie proxy and

21
00:01:16,200 --> 00:01:21,710
weaving are working will illustrate the concepts and the

22
00:01:21,710 --> 00:01:23,600
need for aspect oriented programming.

23
00:01:23,600 --> 00:01:25,740
Starting from an example,

24
00:01:25,740 --> 00:01:28,860
we create a simple matter trying to get the information

25
00:01:28,860 --> 00:01:34,700
about the passenger from a database, and the method contains one single line,

26
00:01:34,700 --> 00:01:38,940
the one retrieving the passenger by I D.

27
00:01:38,940 --> 00:01:44,080
But it is necessary that we add crosscutting functionality logging.

28
00:01:44,080 --> 00:01:48,100
So we introduced two more lines to log the bugging information

29
00:01:48,100 --> 00:01:53,540
before and after retrieving the passenger by i D.

30
00:01:53,540 --> 00:01:57,490
And it is necessary to handle the possible exception.

31
00:01:57,490 --> 00:02:00,940
If the passenger that we look for cannot be retrieved,

32
00:02:00,940 --> 00:02:04,820
then we have to catch SQL exception to wrap it within around

33
00:02:04,820 --> 00:02:08,590
time exception and to throw its further.

34
00:02:08,590 --> 00:02:13,760
And we have to check the user's rights and to throw exception if the user is

35
00:02:13,760 --> 00:02:21,770
not allowed to execute an operation and we have to add cashing so that we

36
00:02:21,770 --> 00:02:26,780
optimize the access to the database and we do not try to query again for a

37
00:02:26,780 --> 00:02:30,940
passenger that has already been retreat.

38
00:02:30,940 --> 00:02:35,940
So we may know, ask ourselves, How did we evolve?

39
00:02:35,940 --> 00:02:40,340
Where did we start from and where did you arrive?

40
00:02:40,340 --> 00:02:42,710
We started with a simple idea in mind.

41
00:02:42,710 --> 00:02:48,140
Our business logic intended to get the passenger from the database by i d.

42
00:02:48,140 --> 00:02:52,780
And we arrived to a large amount of service coat.

43
00:02:52,780 --> 00:02:56,300
Our current method arrived to 17 lines of code.

44
00:02:56,300 --> 00:02:59,530
The service code practically buried the original business logic,

45
00:02:59,530 --> 00:03:01,670
and it continues to grow.

46
00:03:01,670 --> 00:03:05,500
So this is where aspect oriented programming comes in action.

47
00:03:05,500 --> 00:03:09,820
We take the or diagonal or crosscutting functionality and move

48
00:03:09,820 --> 00:03:14,980
it to the separate classes called aspects.

49
00:03:14,980 --> 00:03:17,870
So when may use aspect oriented programming,

50
00:03:17,870 --> 00:03:23,940
which are it's common use cases, it may be used for separating logging.

51
00:03:23,940 --> 00:03:28,890
For exception, handling for user writes checks,

52
00:03:28,890 --> 00:03:34,260
for cashing for transactions or for tweaking legacy

53
00:03:34,260 --> 00:03:37,780
applications that need their code improved.

54
00:03:37,780 --> 00:03:40,970
Our starting example has already pointed out.

55
00:03:40,970 --> 00:03:46,360
A few of these situations will show how to implement them with spring GOP.

56
00:03:46,360 --> 00:03:52,040
During this course in principle, how doesn't aspect work?

57
00:03:52,040 --> 00:03:57,100
You will do something before the method, for example, to longer message.

58
00:03:57,100 --> 00:04:00,740
Then you will execute the original mattered,

59
00:04:00,740 --> 00:04:08,000
and then you will do something after the method. For example, to log another message

