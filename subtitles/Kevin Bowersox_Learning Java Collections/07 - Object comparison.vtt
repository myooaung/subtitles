WEBVTT
1
00:00:00.005 --> 00:00:01.003
- [Instructor] When working with

2
00:00:01.003 --> 00:00:04.002
the Java collections framework, several collections

3
00:00:04.002 --> 00:00:08.003
and their methods rely heavily upon comparing objects.

4
00:00:08.003 --> 00:00:10.004
Just looking at the collection interface,

5
00:00:10.004 --> 00:00:12.006
we'll find a few of these methods.

6
00:00:12.006 --> 00:00:14.009
They're pretty easy to spot because they accept

7
00:00:14.009 --> 00:00:19.005
an object or a collection of objects as their argument.

8
00:00:19.005 --> 00:00:22.004
They use this argument to perform an operation

9
00:00:22.004 --> 00:00:24.005
like removing an element or checking

10
00:00:24.005 --> 00:00:26.009
for its presence in the collection.

11
00:00:26.009 --> 00:00:29.008
To perform these operations, they must identify

12
00:00:29.008 --> 00:00:32.002
the matching object within the collection

13
00:00:32.002 --> 00:00:35.003
they're invoked upon so the method relies

14
00:00:35.003 --> 00:00:38.009
upon a test that compares the provided argument

15
00:00:38.009 --> 00:00:41.003
against the elements in the collection

16
00:00:41.003 --> 00:00:44.001
to find the matching object.

17
00:00:44.001 --> 00:00:47.008
In Java, there are two main ways to compare objects.

18
00:00:47.008 --> 00:00:51.006
One is identity-based and the other is value-based.

19
00:00:51.006 --> 00:00:54.004
When comparing objects by identity,

20
00:00:54.004 --> 00:00:57.008
we check to see if two objects have references

21
00:00:57.008 --> 00:01:00.004
to the same object in memory.

22
00:01:00.004 --> 00:01:03.000
When you use Java's equality operator,

23
00:01:03.000 --> 00:01:05.009
this is the type of check that occurs.

24
00:01:05.009 --> 00:01:08.008
Comparing objects by value is a test

25
00:01:08.008 --> 00:01:12.003
of whether two objects are logically equivalent.

26
00:01:12.003 --> 00:01:14.005
It relies upon their field values,

27
00:01:14.005 --> 00:01:16.005
instead of their memory addresses

28
00:01:16.005 --> 00:01:18.008
to perform this comparison.

29
00:01:18.008 --> 00:01:21.005
In Java, we override the equals method

30
00:01:21.005 --> 00:01:25.008
on an object to establish the logic for this comparison.

31
00:01:25.008 --> 00:01:27.009
A quick way to learn these two concepts

32
00:01:27.009 --> 00:01:31.001
is to think about two people who have the same car.

33
00:01:31.001 --> 00:01:33.003
Now, that's just how we phrase it.

34
00:01:33.003 --> 00:01:35.008
They really don't have the same car,

35
00:01:35.008 --> 00:01:40.000
but they have two cars with the same make and model.

36
00:01:40.000 --> 00:01:43.001
That is a comparison based on characteristics,

37
00:01:43.001 --> 00:01:45.009
or values of the car and it's the type

38
00:01:45.009 --> 00:01:48.003
of comparison necessary for collection methods,

39
00:01:48.003 --> 00:01:52.000
like remove, to function properly.

40
00:01:52.000 --> 00:01:55.002
On the other hand, if we referred to two people sharing

41
00:01:55.002 --> 00:01:59.004
a single car, that is an identity based comparison.

42
00:01:59.004 --> 00:02:01.002
It's normally not what we want

43
00:02:01.002 --> 00:02:03.004
when working with collections.

44
00:02:03.004 --> 00:02:06.001
These comparison concepts come into play

45
00:02:06.001 --> 00:02:08.002
when collection elements must be compared

46
00:02:08.002 --> 00:02:10.008
against each other and there's some other factors

47
00:02:10.008 --> 00:02:14.002
in Java we have to take into consideration.

48
00:02:14.002 --> 00:02:16.008
We're going to unpack those in our next lesson

49
00:02:16.008 --> 00:02:19.000
with a few code examples.

