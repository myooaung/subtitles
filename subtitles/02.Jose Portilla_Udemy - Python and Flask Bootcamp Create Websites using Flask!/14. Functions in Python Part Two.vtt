WEBVTT
1
00:00:05.280 --> 00:00:06.750
Welcome back everyone to functions.

2
00:00:06.750 --> 00:00:12.370
Part two in part two we're really going to focus on trying to solve problems with functions and also

3
00:00:12.390 --> 00:00:18.540
cover a few useful operators such as the joint method off of the string as well as things like max and

4
00:00:18.540 --> 00:00:18.980
min.

5
00:00:19.170 --> 00:00:20.370
Let's get started.

6
00:00:20.370 --> 00:00:24.120
All right let's start off by actually going through a few useful operators or functions that we haven't

7
00:00:24.120 --> 00:00:25.070
discussed before.

8
00:00:25.200 --> 00:00:31.470
Such as Max maximun enumerate and the join method off of the string We'll start off with maximun since

9
00:00:31.470 --> 00:00:32.840
they're kind of the easiest.

10
00:00:32.850 --> 00:00:36.640
These are actually just going to return the max Borman of what you passen.

11
00:00:37.010 --> 00:00:40.320
So it's only pasand to numbers into max and min.

12
00:00:40.440 --> 00:00:42.820
Such as a tour of three.

13
00:00:43.070 --> 00:00:44.060
And then I print this out.

14
00:00:44.060 --> 00:00:46.950
So what's the max between 2 and 3.

15
00:00:47.040 --> 00:00:50.930
If I save that and run this I get back 3.

16
00:00:50.930 --> 00:00:54.550
So if you just pasand two numbers like this I'll report back.

17
00:00:54.680 --> 00:00:59.120
Which is the max number where you can also do for a large amount of numbers.

18
00:00:59.240 --> 00:01:03.090
It's just passing the string of values or excuse me a list of values.

19
00:01:03.110 --> 00:01:08.320
So here I am passing in a bunch of values inside of a list and then when you pass that list instead

20
00:01:08.320 --> 00:01:11.330
of Max over turn back the largest value in that list.

21
00:01:11.330 --> 00:01:13.020
So in this case it was 100.

22
00:01:13.100 --> 00:01:18.140
And just like Max there's also a min function which as you may have guessed returns back the minimum

23
00:01:18.140 --> 00:01:21.670
value in that list for the minimum between two numbers.

24
00:01:21.680 --> 00:01:24.900
Second pasan for instance 1 in 100.

25
00:01:25.070 --> 00:01:27.660
Save that and then get back 1.

26
00:01:27.920 --> 00:01:30.580
So that's max and min.

27
00:01:30.680 --> 00:01:34.910
Up next I want to talk about the enumerate function which is actually really useful especially when

28
00:01:34.910 --> 00:01:37.290
used with for loops.

29
00:01:37.340 --> 00:01:38.020
So let's imagine.

30
00:01:38.060 --> 00:01:40.450
I want to do a for loop through a list of letters.

31
00:01:40.520 --> 00:01:52.460
So I say four letter in a b and c and then I said Prince Lutter and I'm going to delete this max and

32
00:01:52.460 --> 00:01:53.950
min appear.

33
00:01:53.950 --> 00:01:59.480
So when I run this I should see ABC as illustrate a b and c..

34
00:01:59.860 --> 00:02:07.810
So in fact we can say copy that set my list equal to that list and then just say four letter in my list

35
00:02:09.320 --> 00:02:12.050
run the second and we'll get back the same result.

36
00:02:12.050 --> 00:02:12.720
Now let's imagine.

37
00:02:12.740 --> 00:02:16.810
I also want to know the index location of each of these letters.

38
00:02:16.820 --> 00:02:21.680
Well one way I could do this is start by having an index parameter.

39
00:02:21.950 --> 00:02:24.170
So something like Index is equal to zero.

40
00:02:24.470 --> 00:02:26.390
And it's a four letter in my list.

41
00:02:26.390 --> 00:02:35.580
Print the letter and then print is at index and then maybe I can use that formatting here.

42
00:02:36.910 --> 00:02:38.660
The format index.

43
00:02:38.690 --> 00:02:44.420
And then I'll add one to the index and they'll say indexes equal to index plus 1.

44
00:02:44.420 --> 00:02:49.460
So what I'm doing here is I set this variable index to 0 and then I'm going to say OK for every letter

45
00:02:49.460 --> 00:02:54.520
in my list a b and c I'll print out the letter and then I'll say is that index.

46
00:02:54.650 --> 00:02:59.940
And then I'll print out the index there not add one to my index and then I'll just print a blank line.

47
00:03:02.370 --> 00:03:04.220
So let's say that and see what happens.

48
00:03:05.450 --> 00:03:07.560
And I going expand this so you can see.

49
00:03:07.900 --> 00:03:10.250
So it says A is an index 0.

50
00:03:10.450 --> 00:03:13.760
B is the index 1 and C is an index to.

51
00:03:13.790 --> 00:03:20.470
OK not bad but this is such a useful task or such a common task as far as keeping track of the index

52
00:03:20.530 --> 00:03:26.020
while you're iterating that Python already has a built in function to do this and it's called enumerate

53
00:03:26.080 --> 00:03:29.410
because it can enumerate this list.

54
00:03:29.410 --> 00:03:35.310
So what you do is instead of having that manually track the index as we just did you just passed in

55
00:03:36.850 --> 00:03:37.670
your iterable.

56
00:03:37.690 --> 00:03:41.620
In this case our list into this enumerate function.

57
00:03:41.620 --> 00:03:44.320
And so let's see what enumerate actually returns.

58
00:03:44.500 --> 00:03:52.730
On the say for item in the numerator my list prints out the item.

59
00:03:52.750 --> 00:03:58.600
So when I run this you'll notice that you get back these tuple pairs where you have the first item in

60
00:03:58.600 --> 00:04:04.820
the tuple be the index position and the second item be the actual element that's inside of that list.

61
00:04:04.900 --> 00:04:10.190
Essentially something we're doing really similar before except now it's automatically done for you enumerate.

62
00:04:10.270 --> 00:04:18.300
Now we can continue this by actually using tuple and packing so I can say for index Khama item and enumerate.

63
00:04:18.460 --> 00:04:23.950
And now I'm going to unpack these tuples as we discussed in the for loop lecture to actually grab their

64
00:04:23.950 --> 00:04:26.080
index positions and I can say prints.

65
00:04:26.110 --> 00:04:36.610
Item print is an index and in fact then I can use extreme formatting here since I'm on Paice on 3.6

66
00:04:38.690 --> 00:04:45.580
and let's print out them of Lynn Klein save it run this and I get back the same result as I did for

67
00:04:46.260 --> 00:04:48.230
the index 0 Baeza index 1.

68
00:04:48.240 --> 00:04:54.090
See is the index to except that takes a lot less code now because the numerate function I could automatically

69
00:04:54.090 --> 00:04:58.440
grab that index because it's numbering every item in that list.

70
00:04:58.440 --> 00:05:00.340
So that's how the enumerate function works.

71
00:05:00.360 --> 00:05:05.970
And it's super useful when you want to keep track of items or maybe switch something out at a particular

72
00:05:05.990 --> 00:05:06.990
index location.

73
00:05:06.990 --> 00:05:10.830
So if you want to switch out every even number something you could do that as well.

74
00:05:12.520 --> 00:05:19.290
OK now I'm going to cover one last useful operator which is the dot join method off a string.

75
00:05:19.360 --> 00:05:28.330
So let's imagine I have a list of letters again a B and C and I wanted to somehow join the list into

76
00:05:28.330 --> 00:05:29.210
a single string.

77
00:05:29.380 --> 00:05:33.410
I wanted my output to look something like just ABC a single string like that.

78
00:05:33.670 --> 00:05:36.580
Or if I had the end here I'd also want the D in there

79
00:05:39.490 --> 00:05:41.840
so I'd want to look something like that.

80
00:05:41.890 --> 00:05:44.340
So how can I actually do that when I have this list.

81
00:05:44.530 --> 00:05:47.990
Well luckily there's a method you can call off a string.

82
00:05:48.030 --> 00:05:49.390
So let me show you how that works.

83
00:05:50.390 --> 00:05:56.280
You call part of a string that you want to serve as a connector between each of these elements.

84
00:05:56.450 --> 00:06:00.890
Then you say join and then you just pass in the list.

85
00:06:00.890 --> 00:06:08.290
So let's print out this result so we can see what it looks like and when say print.

86
00:06:08.490 --> 00:06:13.130
And I'm going to save that lots from this and then as I get back.

87
00:06:13.200 --> 00:06:14.550
ABC.

88
00:06:14.810 --> 00:06:19.700
So what this is actually doing is you get to choose whatever stream connector you want in between these

89
00:06:19.700 --> 00:06:21.850
elements and then you join them together.

90
00:06:22.100 --> 00:06:26.080
For example I'll choose two sets of dashes as my string.

91
00:06:26.210 --> 00:06:28.980
Then I called Dot join and I pass in my list.

92
00:06:29.120 --> 00:06:30.960
I print out the result to that.

93
00:06:31.360 --> 00:06:37.890
Then I get to see every element in that list 2 dashes then the next element to ashes then the next element.

94
00:06:37.940 --> 00:06:45.450
So to make it really clear what's happening here I and to say dash X dash run this again and I can see

95
00:06:45.630 --> 00:06:50.550
every element in the list separated are joined together by Dash X dash.

96
00:06:50.580 --> 00:06:52.160
Again you choose the connector.

97
00:06:52.160 --> 00:06:54.350
They say that join and pass and the list.

98
00:06:54.620 --> 00:06:54.900
OK.

99
00:06:54.930 --> 00:06:58.480
So those are the three useful operators I wanted to discuss.

100
00:06:58.480 --> 00:07:02.430
Now let's practice two example problems of Python functions.

101
00:07:02.430 --> 00:07:06.930
All right the first problem is to write a function that returns a boolean in the of the word secret

102
00:07:07.050 --> 00:07:08.240
isn't a string.

103
00:07:08.240 --> 00:07:09.170
So let's try that.

104
00:07:10.340 --> 00:07:15.820
Well start off base in the keyword DPF and then we'll name our function we'll call it secret underscore

105
00:07:15.820 --> 00:07:19.690
check and then we need to accept the string as an argument.

106
00:07:20.670 --> 00:07:23.630
So see my string colon.

107
00:07:24.020 --> 00:07:28.170
And I want you to perform some sort of logic to check if the secret is in the string.

108
00:07:29.320 --> 00:07:31.960
So I'll say if secret.

109
00:07:32.530 --> 00:07:34.300
Let's make sure I spell this right.

110
00:07:34.300 --> 00:07:42.060
Secrets in my string return true.

111
00:07:43.780 --> 00:07:49.590
Else return false and in just a little bit I'll show you how you can improve upon this.

112
00:07:49.590 --> 00:07:51.960
But right now let's see what this logic is doing.

113
00:07:52.000 --> 00:07:57.040
We taken a string as an argument and I check is this string secret in my string.

114
00:07:57.040 --> 00:08:00.550
If so all return TRUE else return false.

115
00:08:00.860 --> 00:08:03.730
So test it out and make sure it's actually working.

116
00:08:03.730 --> 00:08:09.210
Mizu much the little bit so you can see everything and then I'm going to print the results of secret

117
00:08:09.220 --> 00:08:13.430
check and Wil's passen the string simple.

118
00:08:13.540 --> 00:08:16.120
So here I would expect it to return false.

119
00:08:16.540 --> 00:08:18.580
So I run this and I get back false.

120
00:08:18.580 --> 00:08:20.370
Now let's try something like.

121
00:08:20.470 --> 00:08:27.060
This is a secret and that when I run this I get back.

122
00:08:27.060 --> 00:08:29.880
True because secret is within that string.

123
00:08:29.920 --> 00:08:33.190
OK so something I want to point out is.

124
00:08:33.340 --> 00:08:36.120
Let's analyze what secret in my string is.

125
00:08:36.130 --> 00:08:38.050
This is already a boolean.

126
00:08:38.050 --> 00:08:39.440
So we're basically saying.

127
00:08:39.490 --> 00:08:42.630
If true return TRUE else return false.

128
00:08:42.730 --> 00:08:46.670
In that case I might as well just return the result of this comparison.

129
00:08:46.710 --> 00:08:53.450
Or this operation secret in my string so I can actually place this whole thing but just saying Return

130
00:08:54.380 --> 00:08:58.720
secret in my stream because that is what's happening here.

131
00:08:58.730 --> 00:09:00.060
This itself is the boolean.

132
00:09:00.080 --> 00:09:04.880
So there's no need for me to add more returns of booleans and said I'll just return this directly.

133
00:09:04.880 --> 00:09:06.110
True or false.

134
00:09:06.170 --> 00:09:09.020
So if I run this I'll get back the same results.

135
00:09:09.020 --> 00:09:15.930
True for this the last thing I want to know is let's imagine we have an edge case where we have an s

136
00:09:15.960 --> 00:09:16.640
capitalized.

137
00:09:16.660 --> 00:09:23.760
Here when I run this I now get back false because my check is only performing it for the lower case

138
00:09:23.820 --> 00:09:24.900
secret.

139
00:09:24.960 --> 00:09:30.670
I could add logical operators like and and or statements to check for various cases of secret.

140
00:09:30.930 --> 00:09:36.540
But instead what I could do is I could just lower case everything in the string first by calling the

141
00:09:36.780 --> 00:09:38.600
lower method off that string.

142
00:09:38.730 --> 00:09:44.750
Then I'll check if secret is in the lower case version of that string then return true or false.

143
00:09:44.760 --> 00:09:47.310
So now let's see what happens.

144
00:09:47.320 --> 00:09:48.300
Now I get back.

145
00:09:48.340 --> 00:09:53.350
True because secret when I lower case this is in that string.

146
00:09:53.370 --> 00:09:53.620
All right.

147
00:09:53.630 --> 00:09:57.200
So that's how we can work through a word problems such as this.

148
00:09:57.200 --> 00:09:57.410
Right.

149
00:09:57.410 --> 00:10:02.700
The function returns a boolean true or false indicating that word secret is in string OK.

150
00:10:02.700 --> 00:10:05.630
Problem 2 is to create a code maker function.

151
00:10:05.640 --> 00:10:10.770
This function will take in a string name and replace any vowels with the letter x.

152
00:10:10.770 --> 00:10:14.060
So let's break this down into a function that can hopefully solve this problem.

153
00:10:15.130 --> 00:10:21.150
Well call this function codebreaker and it will accept that string.

154
00:10:21.190 --> 00:10:24.120
So let's see how we can do this.

155
00:10:24.190 --> 00:10:29.710
First I'm going to want to have some sort of way to organize my output and then what I should be doing

156
00:10:29.800 --> 00:10:33.010
is iterating through every letter in the string.

157
00:10:33.310 --> 00:10:35.850
So start by iterating through every letter in the string.

158
00:10:35.860 --> 00:10:42.150
So I'll say four letter in my string.

159
00:10:42.290 --> 00:10:45.810
In this case let's just print out the letters to see if that works.

160
00:10:47.200 --> 00:10:52.900
And let's have coachmaker run on a line will say coachmaker and will say Samie

161
00:10:55.640 --> 00:10:57.660
only run this I get back.

162
00:10:57.830 --> 00:10:59.990
S a m m y.

163
00:11:00.140 --> 00:11:00.680
And that true.

164
00:11:00.680 --> 00:11:02.430
Looks like I still have this code above here.

165
00:11:02.510 --> 00:11:04.620
No comment that out.

166
00:11:04.800 --> 00:11:06.570
OK so we have this code make her function.

167
00:11:06.810 --> 00:11:10.620
We just saw how we could iterate through every letter in that string.

168
00:11:10.620 --> 00:11:14.380
Now I want to check if those letters are vowels.

169
00:11:14.520 --> 00:11:15.850
So how can I do that.

170
00:11:15.960 --> 00:11:25.060
While I can do this with another for loop I could then say for vowel N and then it could have a string

171
00:11:25.060 --> 00:11:26.690
of values here a.

172
00:11:26.820 --> 00:11:40.160
Oh you and in this case I'm gonna say Prince letter equals equals vowel and let's go ahead and print

173
00:11:40.160 --> 00:11:44.680
out the letter itself that tab out there OK.

174
00:11:44.690 --> 00:11:49.730
So my logic here right now I'm just slowly building out the capabilities I take in that string for every

175
00:11:49.730 --> 00:11:56.370
letter in that string on my check against every vowel and I owe you or a IOU and then print it out if

176
00:11:56.370 --> 00:11:57.390
there is a match.

177
00:11:57.440 --> 00:11:58.420
So let's run this again.

178
00:11:59.500 --> 00:12:04.100
So you'll notice here in our results it's going to be printing a bunch of falses because it's checking

179
00:12:04.460 --> 00:12:06.880
each letter about five times.

180
00:12:06.890 --> 00:12:11.630
So how about little change just print statements only print out if there is actually a match.

181
00:12:11.720 --> 00:12:19.810
Some of the following I'll say if the letter is equal to the vowel then print out the letter that way

182
00:12:19.880 --> 00:12:21.630
only see the vowels being printed out.

183
00:12:21.800 --> 00:12:23.350
So let's run this again.

184
00:12:23.750 --> 00:12:28.510
And now I get back the letter A perfect because I was the only vowel in Samie.

185
00:12:28.970 --> 00:12:30.420
So now we're actually getting somewhere.

186
00:12:30.440 --> 00:12:35.800
I now have the capability to go through every letter in the string check it against every possible vowel

187
00:12:36.020 --> 00:12:39.320
and if the letter is equal to that I'll do something.

188
00:12:39.320 --> 00:12:42.220
Now the idea is just the actual replacement.

189
00:12:42.470 --> 00:12:44.790
So there's various ways we could do the replacement.

190
00:12:44.900 --> 00:12:54.380
But one interesting way would be right before we do the for loop we create a list from my string and

191
00:12:54.390 --> 00:12:57.750
just want to print what that actually looks like for you.

192
00:12:57.980 --> 00:13:00.010
So I'll print out that output.

193
00:13:00.110 --> 00:13:06.290
So now I have a list out of the characters Sammy and then I'm going to say for every letter in my string

194
00:13:07.220 --> 00:13:13.490
check those letters are vowels and if the letters equal to value vowel I should replace that output

195
00:13:13.490 --> 00:13:14.320
position.

196
00:13:14.690 --> 00:13:16.640
So that's where I'm going to use enumerate.

197
00:13:17.030 --> 00:13:21.620
We'll say for index letter in enumerate my string

198
00:13:24.250 --> 00:13:30.610
check that letter or basically for every vowel then you check that the letter is equal to that vowel

199
00:13:30.700 --> 00:13:39.100
and if that happens to be the case I'm going to take the output list at that index position and set

200
00:13:39.100 --> 00:13:42.340
it equal to x as the instructions wanted me to.

201
00:13:42.340 --> 00:13:47.230
So you got to remember we want to take the string and replace any vowels with the letter x.

202
00:13:47.290 --> 00:13:53.680
So right now I have this output which is this list then I'm going to say OK for every single index and

203
00:13:53.680 --> 00:13:57.590
letter and enumerate my street check it against the vowel.

204
00:13:57.700 --> 00:14:01.720
If we have a match grab my output at that sugar index positions.

205
00:14:01.720 --> 00:14:06.790
The first is going to be on the A and replace it with an X and then at the end of all this.

206
00:14:06.910 --> 00:14:14.450
Let's see what happens when we return our output and pay very close attention to my indentation here

207
00:14:14.480 --> 00:14:16.430
and zoom out so you can see the whole picture.

208
00:14:16.430 --> 00:14:21.490
So again I'm returning output after going through these four loops.

209
00:14:21.540 --> 00:14:23.450
So again take note of that in the notation.

210
00:14:23.460 --> 00:14:26.280
You can always copy and paste from are provided notes.

211
00:14:26.310 --> 00:14:29.630
So let me say that and see what happens when I run this.

212
00:14:29.830 --> 00:14:31.870
Right now I'm still not replacing a.

213
00:14:31.900 --> 00:14:34.250
So let's try to debug.

214
00:14:34.270 --> 00:14:36.380
So what's happening here is I'm just printing the output.

215
00:14:36.400 --> 00:14:41.740
So let's delete this print function and then since I'm returning the output I'm not going to need to

216
00:14:41.770 --> 00:14:48.440
print the results of coachmaker and that should fix that issue.

217
00:14:48.480 --> 00:14:51.190
So the Samie that was coming from that print output.

218
00:14:51.240 --> 00:14:52.530
So now we're returning the output.

219
00:14:52.530 --> 00:14:56.380
After doing these changes and then printing out the result of code maker.

220
00:14:56.550 --> 00:14:57.960
So let's run this again.

221
00:14:57.960 --> 00:15:00.880
And now I see s x and y.

222
00:15:00.900 --> 00:15:01.800
Perfect.

223
00:15:01.800 --> 00:15:06.210
Now the last thing you need to do is fix the output Scotius the string and we really talked about how

224
00:15:06.210 --> 00:15:09.890
it could do that using the join method.

225
00:15:09.910 --> 00:15:19.540
So once that's done I can just say output is equal to an empty string and then join the output.

226
00:15:19.560 --> 00:15:23.820
And now when I run this I'll get back the actual string itself.

227
00:15:23.820 --> 00:15:26.950
Now keep in mind we're only checking for lowercase vowels.

228
00:15:26.970 --> 00:15:35.370
So something we do here is say If letter that lowercase is equal to these lowercase vowels then the

229
00:15:35.370 --> 00:15:36.500
replacement as well.

230
00:15:36.690 --> 00:15:42.290
So that would fix an issue something like Adam which starts of a capital A.

231
00:15:43.190 --> 00:15:43.820
So we run this.

232
00:15:43.820 --> 00:15:45.820
Now I see X the XM.

233
00:15:46.220 --> 00:15:48.690
OK so let's quickly go over this logic again.

234
00:15:48.710 --> 00:15:53.520
Because the probably the most complex example of Python code I've seen so far.

235
00:15:53.600 --> 00:15:57.960
Basically what I'm doing here is I create this output list.

236
00:15:58.260 --> 00:16:05.170
Then for every index and letter inside of my original string I check it against every possible vowel.

237
00:16:05.450 --> 00:16:10.940
And then I say hey if that letter lowercase is equal to one of those vowels go ahead and change the

238
00:16:10.940 --> 00:16:15.860
output index position at that list to the letter X. Then to get it back to a string.

239
00:16:15.860 --> 00:16:19.260
I'm simply going to join the outputs and return the output.

240
00:16:19.620 --> 00:16:20.160
OK.

241
00:16:20.300 --> 00:16:23.080
If you have any questions feel free to post the Kewney forums.

242
00:16:23.090 --> 00:16:26.960
This is definitely probably the most advanced jump we've made so far but we're going to get a lot more

243
00:16:26.960 --> 00:16:31.310
practice in the very next lecture through a bunch of function exercises.

244
00:16:31.310 --> 00:16:32.020
We'll see you there.
