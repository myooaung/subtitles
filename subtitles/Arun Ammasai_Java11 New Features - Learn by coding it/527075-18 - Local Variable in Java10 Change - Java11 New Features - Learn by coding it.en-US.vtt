WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.580
Hello everyone, Welcome back.

00:00:02.580 --> 00:00:06.870
So let's create an example to understand what we discussed for one,

00:00:06.870 --> 00:00:09.780
which means how to create a variable using that keyword.

00:00:09.780 --> 00:00:13.030
So I'm going to create a new package here.

00:00:13.730 --> 00:00:16.845
Your package under a commoner John at L1.

00:00:16.845 --> 00:00:23.410
And the package name is going to be local variable.

00:00:29.780 --> 00:00:34.335
Local variable.

00:00:34.335 --> 00:00:36.495
So under the local variable package,

00:00:36.495 --> 00:00:38.790
I'm going to create a first Java class.

00:00:38.790 --> 00:00:43.475
So here we're going to explain or explored the variable types.

00:00:43.475 --> 00:00:52.295
So local variable and lambda example.

00:00:52.295 --> 00:00:56.120
So we're going to talk about what is there in January 8 and Java 11 aswell.

00:00:56.120 --> 00:00:58.680
So let me go to the presentation mode.

00:00:59.230 --> 00:01:02.525
The first thing first, let's create a main method.

00:01:02.525 --> 00:01:04.580
So before we are moving on to Java 11,

00:01:04.580 --> 00:01:07.625
Let's try to understand how it was developed in Java 10.

00:01:07.625 --> 00:01:09.650
So how are we going to get a variable in gelatin?

00:01:09.650 --> 00:01:12.480
So I'm going to create a mock data here.

00:01:14.710 --> 00:01:20.820
Earlier version, earlier means before Java 11.

00:01:22.330 --> 00:01:27.020
Okay, So normally how we will create a simple variable.

00:01:27.020 --> 00:01:29.060
So let me create one string.

00:01:29.060 --> 00:01:31.730
S1 is equal to.

00:01:31.730 --> 00:01:36.380
This is how we know to create a variable.

00:01:36.380 --> 00:01:40.580
But from Java 11, sorry, Java,

00:01:40.580 --> 00:01:46.010
then you can create a variable using that keyword like that.

00:01:46.010 --> 00:01:53.930
X2 is equal to 10 n,

00:01:53.930 --> 00:01:56.180
which is still possible.

00:01:56.180 --> 00:01:58.025
Okay, so you might think,

00:01:58.025 --> 00:02:01.475
so Java is very familiar for type safety.

00:02:01.475 --> 00:02:04.475
So here I provider is string.

00:02:04.475 --> 00:02:06.800
I provided a variable name called S1.

00:02:06.800 --> 00:02:09.695
So eventually I had to play it only string very,

00:02:09.695 --> 00:02:10.925
I mean streaming data here.

00:02:10.925 --> 00:02:12.725
What happens if I put at some other data?

00:02:12.725 --> 00:02:15.860
For example, it become this, if I'll provide,

00:02:15.860 --> 00:02:20.045
then it is immediately throws an exception. Correct.

00:02:20.045 --> 00:02:24.020
So that is called as a type safety, strong type safety.

00:02:24.020 --> 00:02:28.130
And but when you're using that keyword,

00:02:28.130 --> 00:02:32.420
are we really think that type safety has been compromised?

00:02:32.420 --> 00:02:34.055
No, it's not.

00:02:34.055 --> 00:02:35.510
So basically what happened?

00:02:35.510 --> 00:02:39.095
So when you create a variable like where S two is equal to Java 10.

00:02:39.095 --> 00:02:40.880
So when the completion time,

00:02:40.880 --> 00:02:43.160
so the var keyword has been identified,

00:02:43.160 --> 00:02:45.440
the value belongs to a string,

00:02:45.440 --> 00:02:49.475
so bad. Replaced by string.

00:02:49.475 --> 00:02:51.770
It's not only on a string.

00:02:51.770 --> 00:03:01.295
For example, you can create where fluids S3 is equal to 25, can still do them.

00:03:01.295 --> 00:03:07.505
Or you can create int x is or S4 is equal to 50.

00:03:07.505 --> 00:03:12.050
And you can work with all the variables,

00:03:12.050 --> 00:03:14.090
like even combine all of them for example.

00:03:14.090 --> 00:03:15.710
So I want to agree.

00:03:15.710 --> 00:03:23.180
So I want to print it or calculate the S3 and S4 us some, some.

00:03:23.180 --> 00:03:28.820
So what I'm trying to do here, so S3, S4.

00:03:28.820 --> 00:03:31.100
So now what we can do again,

00:03:31.100 --> 00:03:32.750
simply all let me concatenate,

00:03:32.750 --> 00:03:34.865
as you can see here,

00:03:34.865 --> 00:03:40.940
control V. So here I have a string s1 and S2,

00:03:40.940 --> 00:03:42.200
both herbal optional string, right?

00:03:42.200 --> 00:03:44.735
So let me try S1 here.

00:03:44.735 --> 00:03:47.750
N here is two. Let's see what happened.

00:03:47.750 --> 00:03:48.965
It is pretty much work.

00:03:48.965 --> 00:03:51.600
So I'm going to call them at all right.

00:03:52.240 --> 00:03:54.290
I love versions of Java,

00:03:54.290 --> 00:03:56.610
save it and run it on.

00:03:59.590 --> 00:04:05.480
See, we've got 75 because 20 way plus 50 and Java and Java 10.

00:04:05.480 --> 00:04:08.810
So both of them can coordinator together, right?

00:04:08.810 --> 00:04:11.555
So you can create a variable like this.

00:04:11.555 --> 00:04:12.485
Okay?

00:04:12.485 --> 00:04:14.180
So is there any restriction here?

00:04:14.180 --> 00:04:16.130
So what are the variables?

00:04:16.130 --> 00:04:20.330
So variable means when you're creating an object that is also variable different, right?

00:04:20.330 --> 00:04:21.800
You are creating a list.

00:04:21.800 --> 00:04:24.035
Is it considered as a very vague keyword?

00:04:24.035 --> 00:04:25.880
Okay, normally how we will create a list,

00:04:25.880 --> 00:04:28.895
for example, let me create a US simple list here.

00:04:28.895 --> 00:04:35.670
So, so list of string.

00:04:36.940 --> 00:04:44.360
And a lie is it called S list?

00:04:44.360 --> 00:04:46.430
And I'm going to probably a few names here.

00:04:46.430 --> 00:04:54.600
Sam, Nancy, N, Sean.

00:04:55.600 --> 00:04:59.315
Okay, So this is how we normally create variable,

00:04:59.315 --> 00:05:02.375
but what is LA? It's a variable.

00:05:02.375 --> 00:05:03.155
Correct?

00:05:03.155 --> 00:05:05.375
So this is a variable data type.

00:05:05.375 --> 00:05:08.330
So you can, whenever you create a variable,

00:05:08.330 --> 00:05:12.065
you can simply replace the data type with the var keyword.

00:05:12.065 --> 00:05:13.415
For example, what I'm gonna do,

00:05:13.415 --> 00:05:16.430
I'm going to copy this entire thing and paste it here.

00:05:16.430 --> 00:05:19.430
And here I'm going to name this I1.

00:05:19.430 --> 00:05:21.815
And I'm going to replace var keyword,

00:05:21.815 --> 00:05:23.345
which will still work.

00:05:23.345 --> 00:05:26.090
You might think how it is going to work, right?

00:05:26.090 --> 00:05:27.245
So as I mentioned earlier,

00:05:27.245 --> 00:05:30.125
the string concept that SD is equal to 10.

00:05:30.125 --> 00:05:32.480
So when I provide a string here,

00:05:32.480 --> 00:05:35.435
so the competitor makes sure the value belongs to a string,

00:05:35.435 --> 00:05:37.925
at the same time, an appropriate bad keyword.

00:05:37.925 --> 00:05:40.880
And if you're brokering Java 10 as a string here,

00:05:40.880 --> 00:05:42.665
so the compilation order to identify,

00:05:42.665 --> 00:05:47.480
it'll identify the data and then replace the datatype according to that, right?

00:05:47.480 --> 00:05:49.625
The similar way, what will happen here?

00:05:49.625 --> 00:05:52.130
So when the compilation comparator identify

00:05:52.130 --> 00:05:54.860
this particular line the value belongs to eat is stuff a string,

00:05:54.860 --> 00:05:59.555
which means the var keyword will be replaced by a list of string.

00:05:59.555 --> 00:06:01.955
So you might think, will it run? Yes, it will.

00:06:01.955 --> 00:06:11.345
So LI dot, we can use forEach method, System.out, print LN.

00:06:11.345 --> 00:06:13.325
So now let me run this and I'll show you.

00:06:13.325 --> 00:06:14.660
It is pretty simple.

00:06:14.660 --> 00:06:20.885
It will run straight away. See Sam, Nancy, and John.

00:06:20.885 --> 00:06:23.420
It works pretty much properly.

00:06:23.420 --> 00:06:25.310
Okay, so what else?

00:06:25.310 --> 00:06:28.550
I can try that. So normally we will create the for loop.

00:06:28.550 --> 00:06:31.685
So in we use to create, I mean,

00:06:31.685 --> 00:06:35.090
we always create a variable while creating a for loop.

00:06:35.090 --> 00:06:37.700
For int I is equal to 0, right?

00:06:37.700 --> 00:06:41.810
So let's see whether the local variable will work within the loop.

00:06:41.810 --> 00:06:43.025
Okay, so what I'm gonna do,

00:06:43.025 --> 00:06:44.750
I'm gonna create a for loop here.

00:06:44.750 --> 00:06:49.340
So int I is equal to 0,

00:06:49.340 --> 00:06:53.720
I less than or equal to five, I plus,

00:06:53.720 --> 00:06:58.850
plus, and I'm just simply providing it's going to be high.

00:06:58.850 --> 00:07:00.755
So I'm going to simply provide,

00:07:00.755 --> 00:07:02.150
I'm just simply printing the data.

00:07:02.150 --> 00:07:03.005
That's all.

00:07:03.005 --> 00:07:06.590
So I and I'm going to save it for now.

00:07:06.590 --> 00:07:08.735
So what is this?

00:07:08.735 --> 00:07:10.895
This is a variable declaration, right?

00:07:10.895 --> 00:07:13.520
So wherever you can find that NOW going to replace it,

00:07:13.520 --> 00:07:15.470
the var keyword, deleting it.

00:07:15.470 --> 00:07:16.730
Look, yes, it will work,

00:07:16.730 --> 00:07:19.370
but because it's still lives a local, okay?

00:07:19.370 --> 00:07:23.630
The reason why we are saying is a local variable, right?

00:07:23.630 --> 00:07:28.775
So because the var keyword only works inside the local method,

00:07:28.775 --> 00:07:33.095
I'll show you why it will not walk in outside of the local method.

00:07:33.095 --> 00:07:36.410
So now what I can do, I can simply run it again to see whether we should

00:07:36.410 --> 00:07:40.100
be able to see the data which is printed in the for loop 012345,

00:07:40.100 --> 00:07:41.660
which is pretty good.

00:07:41.660 --> 00:07:43.115
Okay, so what is we can do?

00:07:43.115 --> 00:07:43.745
Okay?

00:07:43.745 --> 00:07:46.760
So this is a local variable lambda expression, right?

00:07:46.760 --> 00:07:51.650
So if you want to create the object normally how we will do so this RL do so.

00:07:51.650 --> 00:07:55.775
So OBJ is equal to new class name.

00:07:55.775 --> 00:07:57.755
So this is how I will create an object.

00:07:57.755 --> 00:07:59.090
And using that object,

00:07:59.090 --> 00:08:01.625
I will call them methods available Indy.

00:08:01.625 --> 00:08:03.770
And the same class, right?

00:08:03.770 --> 00:08:05.030
What is that?

00:08:05.030 --> 00:08:06.290
This is a variable name,

00:08:06.290 --> 00:08:08.900
so which means there is a variable type and what is the type here?

00:08:08.900 --> 00:08:10.415
It is, uh, my class time.

00:08:10.415 --> 00:08:13.100
So you can simply overwrite the variable,

00:08:13.100 --> 00:08:15.335
which will still work.

00:08:15.335 --> 00:08:17.660
Now you're going to understand why it is working.

00:08:17.660 --> 00:08:19.610
The reason, because what is the value here,

00:08:19.610 --> 00:08:22.280
local variable, the implementation part is local variable.

00:08:22.280 --> 00:08:25.175
So which means when the compiler finds this particular line,

00:08:25.175 --> 00:08:27.845
it identify what that is belongs to.

00:08:27.845 --> 00:08:29.075
Okay?

00:08:29.075 --> 00:08:31.580
Okay, So where else we can try that?

00:08:31.580 --> 00:08:33.905
So we tried to turn a single string.

00:08:33.905 --> 00:08:38.330
We try with the list and we tried with the for-loop.

00:08:38.330 --> 00:08:39.695
Let's show the different fall.

00:08:39.695 --> 00:08:41.600
And we tried with good object name also.

00:08:41.600 --> 00:08:47.810
So let's create a different kind of follow forEach method for we have a list, right?

00:08:47.810 --> 00:08:50.030
La list, right, so I'm going to extract them.

00:08:50.030 --> 00:08:53.790
So normally it's L, this reshuffling rate, it's a string.

00:08:53.950 --> 00:08:57.455
And I want to blend the data from the Align.

00:08:57.455 --> 00:09:01.470
And just I'm gonna print this out.

00:09:01.960 --> 00:09:09.230
And so now take a look at this piece of code, string allergies.

00:09:09.230 --> 00:09:10.745
I'm declaring a variable.

00:09:10.745 --> 00:09:12.890
Anyway. I'm, I'm processing element from

00:09:12.890 --> 00:09:15.485
the LAN keeping it here and iterating one by one.

00:09:15.485 --> 00:09:17.345
Anyway, it's a variable declaration, right?

00:09:17.345 --> 00:09:19.685
So we can simply modify that,

00:09:19.685 --> 00:09:21.515
which will still work.

00:09:21.515 --> 00:09:23.180
Now, run it.

00:09:23.180 --> 00:09:24.905
We should be able to see the list.

00:09:24.905 --> 00:09:30.360
Again. I see Sam, Nancy, and John.

00:09:31.690 --> 00:09:33.260
Okay?

00:09:33.260 --> 00:09:35.765
So there are lot of ways you can try.

00:09:35.765 --> 00:09:37.220
For example, can we use it in

00:09:37.220 --> 00:09:41.270
the file concept when you're creating when you're dealing with the law files, right.

00:09:41.270 --> 00:09:42.980
So it can't be used?

00:09:42.980 --> 00:09:44.810
Yes, it still can use red.

00:09:44.810 --> 00:09:46.685
Ok, and it's just a variable in the numerator.

00:09:46.685 --> 00:09:48.875
So what I'm gonna do file,

00:09:48.875 --> 00:09:51.410
this is simple filing NFA file.

00:09:51.410 --> 00:09:54.510
So I'm going to input this one.

00:09:55.840 --> 00:09:57.725
Put class.

00:09:57.725 --> 00:09:59.000
Okay, so when I resume file,

00:09:59.000 --> 00:10:00.905
make sure we have the try-catch, right?

00:10:00.905 --> 00:10:07.050
So try to have a catch.

00:10:12.370 --> 00:10:19.085
So now here what I'm gonna do is I'm not going to try anything different here.

00:10:19.085 --> 00:10:26.510
So file, I'm going to create the input stream here.

00:10:26.510 --> 00:10:30.290
So normally how we will do right?

00:10:30.290 --> 00:10:32.000
So file input stream, correct.

00:10:32.000 --> 00:10:40.880
So the way how we will do file input stream if rho is

00:10:40.880 --> 00:10:43.685
equal to and we will normally provide

00:10:43.685 --> 00:10:46.970
new file input stream and we

00:10:46.970 --> 00:10:50.705
have to provide some file path year for which file you are looking for.

00:10:50.705 --> 00:10:56.510
So in your file and provide test dot txt,

00:10:56.510 --> 00:10:59.390
this is a sample file, right?

00:10:59.390 --> 00:11:03.320
Anyway here, this is a datatype and eye movements

00:11:03.320 --> 00:11:07.070
the class and does a variable for the class reference, right?

00:11:07.070 --> 00:11:10.580
So anyway, we can still modify that asset where,

00:11:10.580 --> 00:11:16.040
but normally I'm just using the traditional way of a try.

00:11:16.040 --> 00:11:18.335
But we can file input stream,

00:11:18.335 --> 00:11:19.985
which implements auto closable,

00:11:19.985 --> 00:11:22.850
which means we can use as a trial at the resource.

00:11:22.850 --> 00:11:24.320
The way we can do that,

00:11:24.320 --> 00:11:26.555
just copy this piece of code.

00:11:26.555 --> 00:11:29.000
And here you can use them.

00:11:29.000 --> 00:11:32.075
File, input stream, FIFO, that sort.

00:11:32.075 --> 00:11:36.155
But here anyway, this is a variable name which means is a data type, right?

00:11:36.155 --> 00:11:39.140
So you can simply replace with a variable.

00:11:39.140 --> 00:11:45.350
So now we understand how we can use a var keyword to create a variable's.

00:11:45.350 --> 00:11:48.995
Got it, but how it should not be used.

00:11:48.995 --> 00:11:52.130
Let's go to that last level here.

00:11:52.130 --> 00:11:58.790
Okay, so I'm going to create in DataTable get int x is equal to 25,

00:11:58.790 --> 00:12:02.855
which is pretty much normal instance variable.

00:12:02.855 --> 00:12:08.075
Can you try the same with the vacuum or that y is equal to 75?

00:12:08.075 --> 00:12:11.075
See what happened, which will not work.

00:12:11.075 --> 00:12:12.905
There is a reason, I mean,

00:12:12.905 --> 00:12:17.015
that is a reason we are calling this entire conference or local variable.

00:12:17.015 --> 00:12:17.885
Okay?

00:12:17.885 --> 00:12:24.094
So though, you can only create variables using var keyword inside of the local methods,

00:12:24.094 --> 00:12:26.465
not outset of them, right?

00:12:26.465 --> 00:12:29.180
So, so, so far we discussed its own,

00:12:29.180 --> 00:12:32.405
it's one layer boat, how it was handled in Java 10.

00:12:32.405 --> 00:12:35.855
So it's only available for creating a variables.

00:12:35.855 --> 00:12:37.195
But in Java 11,

00:12:37.195 --> 00:12:41.495
it has been an answer to handle and D lambda expression as well.

00:12:41.495 --> 00:12:43.565
Because for lambda expression we use to pass up,

00:12:43.565 --> 00:12:45.800
I mean, we're, we're passing the inputs, right?

00:12:45.800 --> 00:12:51.320
So even there, you can follow the same pattern so that we will discuss in the next video.

00:12:51.320 --> 00:12:53.040
Thank you.
