WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.430
Hello everyone, Welcome back.

00:00:02.430 --> 00:00:04.380
In the last video we discuss about what are

00:00:04.380 --> 00:00:08.460
the new methods as been introduced as part of string API.

00:00:08.460 --> 00:00:16.605
Okay, so the next feature we're going to talk about is local variables lambda.

00:00:16.605 --> 00:00:18.930
So let's talk about what is local variable.

00:00:18.930 --> 00:00:23.295
And then we'll talk about and what is the impact with the Lambda expression.

00:00:23.295 --> 00:00:25.410
Basically, since Java 10,

00:00:25.410 --> 00:00:27.540
the way how we create a variable,

00:00:27.540 --> 00:00:28.755
it has been changed.

00:00:28.755 --> 00:00:30.810
So it's gonna talk about java tin.

00:00:30.810 --> 00:00:35.145
Because while creating the example also I'm creating an example in John 10,

00:00:35.145 --> 00:00:39.160
and then we'll move to the Java 11 example.

00:00:39.160 --> 00:00:40.655
So the first thing first,

00:00:40.655 --> 00:00:43.850
so Genova 10 local variable type inference has been introduced.

00:00:43.850 --> 00:00:46.070
So what do you mean by type inference?

00:00:46.070 --> 00:00:51.230
Okay, So that type has been declared in the left side.

00:00:51.230 --> 00:00:57.080
Okay, so we don't have to specifically mentioned what is that type in the right side,

00:00:57.080 --> 00:00:58.760
which means, for example,

00:00:58.760 --> 00:01:01.550
you are creating a list of string LI is equal to

00:01:01.550 --> 00:01:06.770
new ArrayList and within the diamond operator will provide a string, correct.

00:01:06.770 --> 00:01:10.040
And that is not mandatory after Java seven.

00:01:10.040 --> 00:01:13.610
So that is called that type inference from the left side to right side.

00:01:13.610 --> 00:01:17.030
Basically moving that era tie from one side to or

00:01:17.030 --> 00:01:21.095
referring one side to another side is called as a type inference.

00:01:21.095 --> 00:01:24.545
Let me talk about that in detail in the example.

00:01:24.545 --> 00:01:29.765
So we can infer the type of a variable from right hand side to left hand side.

00:01:29.765 --> 00:01:31.475
So take an example.

00:01:31.475 --> 00:01:36.200
Variable list is equal to ni or a list of a string and the brackets.

00:01:36.200 --> 00:01:40.550
So we never create any such variables like we did normally will create a list of string.

00:01:40.550 --> 00:01:42.785
List is equal to new ArrayList, right?

00:01:42.785 --> 00:01:50.900
And it is changed. So now

00:01:50.900 --> 00:01:54.920
we can declare arguments of the implicit type Lambda expression.

00:01:54.920 --> 00:01:57.290
For example, when you're creating a lambda expression,

00:01:57.290 --> 00:01:59.090
we can pass the inputs, right?

00:01:59.090 --> 00:02:02.660
So for example, when you're trying to implement some functional interface, for example,

00:02:02.660 --> 00:02:05.435
if you're using a predicate or consumer,

00:02:05.435 --> 00:02:07.760
you need to pass a single input, right?

00:02:07.760 --> 00:02:09.050
Or multiple input, right?

00:02:09.050 --> 00:02:11.570
So datatype, how we're going to do fine.

00:02:11.570 --> 00:02:17.120
So normally we'll provide a string a or just simply provide a.

00:02:17.120 --> 00:02:20.690
Or now we can add var keyword as well.

00:02:20.690 --> 00:02:26.570
So basically, we can create a variable using var keyword since Java team.

00:02:26.570 --> 00:02:29.795
And when it comes to lambda expression,

00:02:29.795 --> 00:02:31.820
you cannot skip the type.

00:02:31.820 --> 00:02:34.655
For example, if your lambda expression taking two inputs,

00:02:34.655 --> 00:02:36.350
Hey, there you need to follow the pattern.

00:02:36.350 --> 00:02:37.670
In both variable.

00:02:37.670 --> 00:02:40.625
It has to be used vacuum or ADLS.

00:02:40.625 --> 00:02:43.205
You how to specifically what type of data audits.

00:02:43.205 --> 00:02:44.825
You don't have to specify the type of dog,

00:02:44.825 --> 00:02:46.400
but you cannot mix them both.

00:02:46.400 --> 00:02:48.680
For example, here I have a var keyword and a,

00:02:48.680 --> 00:02:51.800
the variable m, but B doesn't nothing.

00:02:51.800 --> 00:02:54.410
So you cannot provide

00:02:54.410 --> 00:02:57.875
the lambda expression like that because there is no skipping allowed.

00:02:57.875 --> 00:03:00.785
At the same time, the mixing also not alone.

00:03:00.785 --> 00:03:02.870
Here I have two parameters.

00:03:02.870 --> 00:03:06.185
First parameter is that a nd.

00:03:06.185 --> 00:03:08.270
Second one is string B.

00:03:08.270 --> 00:03:11.360
So both are meaning the same thing,

00:03:11.360 --> 00:03:12.995
but you cannot define,

00:03:12.995 --> 00:03:14.330
declare something like that.

00:03:14.330 --> 00:03:17.585
Hey, that both has to be where are both has to be string.

00:03:17.585 --> 00:03:20.330
Okay, so just make sure on that.

00:03:20.330 --> 00:03:23.975
No skipping and no mixing allowed in lambda expressions.

00:03:23.975 --> 00:03:28.055
And when you are creating a variable or if it's a single variable.

00:03:28.055 --> 00:03:30.455
And if you're providing var keyword,

00:03:30.455 --> 00:03:34.640
make sure you are providing the brackets.

00:03:34.640 --> 00:03:36.080
Okay?

00:03:36.080 --> 00:03:39.380
So maybe it might be difficult when

00:03:39.380 --> 00:03:42.650
I'm talking about the ADH is local variable and how to create a variable.

00:03:42.650 --> 00:03:44.570
Because if you're not aware of java tin,

00:03:44.570 --> 00:03:46.610
it's the entire slide which we've gone through.

00:03:46.610 --> 00:03:48.380
You may think, I don't understand anything.

00:03:48.380 --> 00:03:48.965
Okay.

00:03:48.965 --> 00:03:50.300
If you want to understand,

00:03:50.300 --> 00:03:52.400
we need to go back to our ID and we'll

00:03:52.400 --> 00:03:54.995
create a simple example and I'll explain everything,

00:03:54.995 --> 00:03:56.525
whatever we discussed so far.

00:03:56.525 --> 00:03:58.260
Thank you.
