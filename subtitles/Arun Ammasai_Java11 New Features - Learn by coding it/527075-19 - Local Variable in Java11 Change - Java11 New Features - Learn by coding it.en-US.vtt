WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.205
Hello everyone, Welcome back.

00:00:02.205 --> 00:00:07.035
So we discuss about how we can create a variable using var keyword, right?

00:00:07.035 --> 00:00:10.170
At the same time, this val keyword has

00:00:10.170 --> 00:00:15.060
an enhanced ditto using inside the lambda expression in Java 11.

00:00:15.060 --> 00:00:17.985
So what I'm gonna do, Lindeman create a 11 mother here,

00:00:17.985 --> 00:00:21.570
which means we can explore the Java 11 changes.

00:00:21.570 --> 00:00:29.580
So Java 11 changes.

00:00:29.680 --> 00:00:33.260
Okay, so as I mentioned earlier,

00:00:33.260 --> 00:00:40.520
the lambda expression can accept d variables, right?

00:00:40.520 --> 00:00:42.215
Our arguments, our parameter.

00:00:42.215 --> 00:00:45.950
So what I'm gonna do, I'm gonna create a simple lambda expression again.

00:00:45.950 --> 00:00:48.020
So you can use any kind of a functional interface.

00:00:48.020 --> 00:00:51.230
For now, I'm going to use a consumer at the same time.

00:00:51.230 --> 00:00:53.270
I'm, I'm gonna use it by consumer elsewhere.

00:00:53.270 --> 00:00:57.080
Okay, so let's try and explore them how we can do that.

00:00:57.080 --> 00:00:59.450
So it can create a consumer here.

00:00:59.450 --> 00:01:01.100
And the consumer which I'm going to create,

00:01:01.100 --> 00:01:03.065
wish you luck surplus string as input.

00:01:03.065 --> 00:01:09.230
Okay, So it can be a string and then it is going to be my consumer 1.

00:01:09.230 --> 00:01:11.780
Consumer 1 is equal to, okay,

00:01:11.780 --> 00:01:14.420
so now we have to provide the lambda expression here.

00:01:14.420 --> 00:01:16.310
So what I'm basically trying to do

00:01:16.310 --> 00:01:20.540
is just print the data which I am passing to the consumer.

00:01:20.540 --> 00:01:23.810
So what normally what we do if it is a single input,

00:01:23.810 --> 00:01:29.990
you can simply provide AS or and lower SES out here.

00:01:29.990 --> 00:01:32.855
And you can provide the essay or print it. That's what.

00:01:32.855 --> 00:01:34.565
But what are the other ways we can do that?

00:01:34.565 --> 00:01:38.885
Still, you can provide string.

00:01:38.885 --> 00:01:43.625
Yes, but when they're providing the data type, it is optional.

00:01:43.625 --> 00:01:46.115
It's not monetary and deployed to that.

00:01:46.115 --> 00:01:51.575
The reason, even though if you are not passing the type here,

00:01:51.575 --> 00:01:54.230
it will be inferred from the consumer because that is

00:01:54.230 --> 00:01:57.635
what type inference from left side to the right side.

00:01:57.635 --> 00:02:00.815
So you can use something like that or is now,

00:02:00.815 --> 00:02:02.675
you can use the var keyword as well,

00:02:02.675 --> 00:02:04.715
which will still work.

00:02:04.715 --> 00:02:09.650
Okay, so for now I'm going to use string.

00:02:09.650 --> 00:02:14.765
I'm just trying to show you how we can create in a normal way and using the var keyword.

00:02:14.765 --> 00:02:18.800
And here gone one.

00:02:18.800 --> 00:02:20.915
And I'm going to provide some data.

00:02:20.915 --> 00:02:23.090
So Java 11.

00:02:23.090 --> 00:02:25.010
So let me run it. First of all,

00:02:25.010 --> 00:02:28.310
let me call the method on the previous one,

00:02:28.310 --> 00:02:32.520
and Java 11 changes and I'm going to rent them.

00:02:40.440 --> 00:02:44.485
What happened? So we got here,

00:02:44.485 --> 00:02:45.880
we got the outcome.

00:02:45.880 --> 00:02:49.585
Now I'm trying to do the same thing using var keyword.

00:02:49.585 --> 00:02:52.060
It's true that control V.

00:02:52.060 --> 00:02:55.420
And let me call them as a conscious consumer to,

00:02:55.420 --> 00:02:57.490
I'm not going to provide anything here.

00:02:57.490 --> 00:03:00.205
I'm just removing the string.

00:03:00.205 --> 00:03:03.325
So I'm replacing with the var keyword because var,

00:03:03.325 --> 00:03:07.575
var desk knows that what is the data type is going to be because it is coming for

00:03:07.575 --> 00:03:12.715
the type inference using the string here, right?

00:03:12.715 --> 00:03:16.500
So n1 and n2.

00:03:16.500 --> 00:03:19.550
So Java 11, common one, I mean,

00:03:19.550 --> 00:03:21.170
kind of him at one end,

00:03:21.170 --> 00:03:25.205
java 11 can zoom in to just to see the clear output.

00:03:25.205 --> 00:03:27.570
So I'm going to run them again.

00:03:27.790 --> 00:03:30.620
So now we should be able to see both of them.

00:03:30.620 --> 00:03:34.070
Java alone can't swim alone and Kundiman two as well.

00:03:34.070 --> 00:03:35.315
So one using normally,

00:03:35.315 --> 00:03:37.220
one using the var keyword.

00:03:37.220 --> 00:03:39.100
And there are the results on that.

00:03:39.100 --> 00:03:41.030
We can exploit that as well.

00:03:41.030 --> 00:03:44.540
Without bracket is a single parameter, right?

00:03:44.540 --> 00:03:46.040
So when it is a single parameter,

00:03:46.040 --> 00:03:47.675
you don't have to provide the brackets at all.

00:03:47.675 --> 00:03:50.495
If you're not proving data that we can directly provide the SCR.

00:03:50.495 --> 00:03:51.440
Got it.

00:03:51.440 --> 00:03:54.770
And here, we can simply modify it according to the 0.3.

00:03:54.770 --> 00:03:57.470
And here Java 11, 3.

00:03:57.470 --> 00:04:07.025
So there are, there are different ways to create variable.

00:04:07.025 --> 00:04:09.830
So you can use the data type in the,

00:04:09.830 --> 00:04:11.165
especially the lambda expression.

00:04:11.165 --> 00:04:12.680
So you can use the datatype,

00:04:12.680 --> 00:04:14.965
which means the primitive data type name,

00:04:14.965 --> 00:04:16.925
individual string or whatever you want.

00:04:16.925 --> 00:04:20.150
But the function interface are only working with the wrapper classes,

00:04:20.150 --> 00:04:22.010
so it has to be a wrapper classes.

00:04:22.010 --> 00:04:24.035
We shouldn't provide the primitive here.

00:04:24.035 --> 00:04:28.265
So string and wet and either you don't have to upload anything at all.

00:04:28.265 --> 00:04:29.930
Okay, So now I'm using,

00:04:29.930 --> 00:04:31.850
let me run this one more time.

00:04:31.850 --> 00:04:33.845
So now I'm using consumer.

00:04:33.845 --> 00:04:35.570
So it's actually only one input parameters.

00:04:35.570 --> 00:04:39.275
So I cannot playing with that too much, right?

00:04:39.275 --> 00:04:43.220
So now what I can do is let me create a bi consumer.

00:04:43.220 --> 00:04:49.070
You, we all know that by consumer will accept two inputs as a parameter, right?

00:04:49.070 --> 00:04:57.695
So now let's explore by Kenzie my farm variable,

00:04:57.695 --> 00:05:05.495
like consumer and string comma string.

00:05:05.495 --> 00:05:07.520
And it is going to be,

00:05:07.520 --> 00:05:14.975
it can name them as consumer number 4 or be a one.

00:05:14.975 --> 00:05:19.700
So it has to be accepted to input and because it's a bacon tumor.

00:05:19.700 --> 00:05:24.390
So I'm going to blow at a comma b mod r belongs to a string.

00:05:25.780 --> 00:05:29.630
And the Lambda x and that token.

00:05:29.630 --> 00:05:31.160
And all I need to do,

00:05:31.160 --> 00:05:33.380
I'm just going to condition a and B and printing them.

00:05:33.380 --> 00:05:34.830
That's all.

00:05:37.960 --> 00:05:41.195
So a plus b.

00:05:41.195 --> 00:05:45.230
So now we got the functional interface implementation.

00:05:45.230 --> 00:05:51.115
Let's pass the better some input data to check the outcome.

00:05:51.115 --> 00:06:01.265
So I'm going to see ALU and I'm going to throw a ball here.

00:06:01.265 --> 00:06:07.205
So when the moment IRA underscore Big O D outcome as a Hello World,

00:06:07.205 --> 00:06:08.540
which is pretty straightforward.

00:06:08.540 --> 00:06:12.215
I'm using lambda expression here and lambda variables,

00:06:12.215 --> 00:06:17.060
and I'm not providing any type here because you can do that in lambda expression.

00:06:17.060 --> 00:06:19.970
As it, as we tried three different ways,

00:06:19.970 --> 00:06:22.100
I'm going to try the same here as well.

00:06:22.100 --> 00:06:27.125
So let's copy this and paste them.

00:06:27.125 --> 00:06:31.835
And I'm going to name them be i2.

00:06:31.835 --> 00:06:35.045
And here I'm going to name the Meza.

00:06:35.045 --> 00:06:39.710
I'm going to provide that type string a,

00:06:39.710 --> 00:06:44.330
string B, and which will still work.

00:06:44.330 --> 00:06:47.840
No issues at all. So let me paste them one more time.

00:06:47.840 --> 00:06:51.740
And I'm going to call them as b i 3.

00:06:51.740 --> 00:06:57.665
So now I'm gonna do using keywords that a and B.

00:06:57.665 --> 00:06:59.240
So let me run this.

00:06:59.240 --> 00:07:01.670
And so into Bb I3.

00:07:01.670 --> 00:07:04.850
I'm just trying to show you what other things is possible.

00:07:04.850 --> 00:07:08.015
The different ways to create a Lambda variables here.

00:07:08.015 --> 00:07:11.795
So everything got printed successfully, correct.

00:07:11.795 --> 00:07:13.445
So we know what is possible,

00:07:13.445 --> 00:07:16.250
but the same time we should know what is not possible and what is

00:07:16.250 --> 00:07:19.310
the wrong way to do that, right?

00:07:19.310 --> 00:07:20.810
So now what I'm gonna do,

00:07:20.810 --> 00:07:22.130
let's copy paste it.

00:07:22.130 --> 00:07:25.205
So I'm going to call MSBA 14.

00:07:25.205 --> 00:07:28.610
So we all know that a comma b is a two string variable.

00:07:28.610 --> 00:07:32.070
So you can create string,

00:07:33.250 --> 00:07:35.675
string a and B.

00:07:35.675 --> 00:07:38.740
You should not leave something like if you want to provide at

00:07:38.740 --> 00:07:43.070
that time you had to prove it for the both the both the variables, orals.

00:07:43.070 --> 00:07:45.140
Leave both alone.

00:07:45.140 --> 00:07:46.370
Don't do anything at all.

00:07:46.370 --> 00:07:52.130
Either you have to provide that if I bought them or else just leave them,

00:07:52.130 --> 00:07:55.715
or we can mix also.

00:07:55.715 --> 00:07:57.320
So one is with the normal Erdogan,

00:07:57.320 --> 00:07:59.780
none of that on us and our var keyword,

00:07:59.780 --> 00:08:02.480
that is also not possible.

00:08:02.480 --> 00:08:08.480
Okay, so you cannot mix different way of creating Lambda variables here.

00:08:08.480 --> 00:08:09.155
Okay?

00:08:09.155 --> 00:08:12.780
So the normal way, Ada,

00:08:12.940 --> 00:08:16.970
you don't have to provide any type or provide

00:08:16.970 --> 00:08:21.335
proper narrative art is protoboard of the massive add that still works,

00:08:21.335 --> 00:08:24.965
but the mixing and skipping it won't work.

00:08:24.965 --> 00:08:27.590
So I can give you one more example,

00:08:27.590 --> 00:08:29.600
Fergus, we tried different kinds of variables.

00:08:29.600 --> 00:08:31.910
Let me create a simple array also.

00:08:31.910 --> 00:08:34.685
So normally how we will create an array variable, right?

00:08:34.685 --> 00:08:44.795
So integer array and the int is equal to.

00:08:44.795 --> 00:08:47.910
So I'm going to provide new integer.

00:08:49.300 --> 00:08:53.000
So it is going to be an array of values, right?

00:08:53.000 --> 00:08:55.700
So progress on things.

00:08:55.700 --> 00:08:57.500
So 1, 2, 3, 4,

00:08:57.500 --> 00:09:00.215
5, 6 commands seven.

00:09:00.215 --> 00:09:04.460
So there are multiple different ways to create a new integers here.

00:09:04.460 --> 00:09:06.275
Okay, so the first thing,

00:09:06.275 --> 00:09:09.350
so this is a normal way of creating a variable, right?

00:09:09.350 --> 00:09:10.955
And then what I'm gonna do,

00:09:10.955 --> 00:09:14.180
so this is where the variable key here comes into place.

00:09:14.180 --> 00:09:16.850
Here is a variable name and desert type.

00:09:16.850 --> 00:09:18.260
So what you can simply do,

00:09:18.260 --> 00:09:21.740
you can convert them into a normal variables.

00:09:21.740 --> 00:09:25.745
So how we can do that, you can simply upload that keyword, right?

00:09:25.745 --> 00:09:30.410
And then so I can create a stream out of RA rate.

00:09:30.410 --> 00:09:32.255
So how we can do that normally,

00:09:32.255 --> 00:09:40.265
stream and stream is equal.

00:09:40.265 --> 00:09:46.280
So downstream end.

00:09:46.280 --> 00:09:48.500
What is the array name here?

00:09:48.500 --> 00:09:50.075
Array.

00:09:50.075 --> 00:09:53.690
So which will return a stream, right?

00:09:53.690 --> 00:09:55.160
But again here, stream,

00:09:55.160 --> 00:09:56.345
stream, what is that?

00:09:56.345 --> 00:09:57.725
It is a variable named rate.

00:09:57.725 --> 00:10:00.680
So even here you can replace it the var keyword.

00:10:00.680 --> 00:10:02.510
And now what we can do,

00:10:02.510 --> 00:10:05.190
we can print industry minimi.

00:10:07.270 --> 00:10:12.155
So Stream dot for each matter.

00:10:12.155 --> 00:10:19.265
And you can provide system.out print LN.

00:10:19.265 --> 00:10:26.075
So now we can run the code which will give you all the data.

00:10:26.075 --> 00:10:29.705
See 1234567.

00:10:29.705 --> 00:10:33.350
So the array converted into a stream,

00:10:33.350 --> 00:10:35.315
and this stream has been printed and the concern,

00:10:35.315 --> 00:10:38.600
so I removed integer array

00:10:38.600 --> 00:10:42.005
to a variable var keyword and remove a stream class has a var keyword.

00:10:42.005 --> 00:10:45.770
So wherever you are creating your variable,

00:10:45.770 --> 00:10:47.825
you can use the var keyword,

00:10:47.825 --> 00:10:51.485
but make sure it is one layer and the local methods,

00:10:51.485 --> 00:10:54.020
it's not possible outside of the mother,

00:10:54.020 --> 00:10:56.240
which meant the instance level of static level.

00:10:56.240 --> 00:10:59.750
Okay, so let's see each other next video.

00:10:59.750 --> 00:11:01.380
Thank you.
