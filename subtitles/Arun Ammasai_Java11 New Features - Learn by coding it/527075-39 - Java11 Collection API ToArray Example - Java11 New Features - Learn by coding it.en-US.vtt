WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:03.480
Hello everyone. Welcome back.

00:00:03.480 --> 00:00:09.135
In John 11, that is some new changes in the collection EPA,

00:00:09.135 --> 00:00:13.260
so that a one new method has been added and the method is already existing.

00:00:13.260 --> 00:00:17.790
But that other one would Madrid introduced with the same name,

00:00:17.790 --> 00:00:23.535
which means into my dad lower than so down below and collection API.

00:00:23.535 --> 00:00:25.155
So as I mentioned earlier,

00:00:25.155 --> 00:00:27.570
that isn't new method has been either as part of

00:00:27.570 --> 00:00:30.795
java.util dot collection and that is an interface.

00:00:30.795 --> 00:00:32.490
Name is two-way.

00:00:32.490 --> 00:00:34.620
So this is a 2D array method which will be,

00:00:34.620 --> 00:00:37.210
well what IT, and in Java 11.

00:00:37.460 --> 00:00:40.500
Okay, So what it does, for example,

00:00:40.500 --> 00:00:45.185
you have a collection of data and you want to return back as an array.

00:00:45.185 --> 00:00:50.870
So you can use the two elementary and middle Docker would how we are

00:00:50.870 --> 00:00:53.060
implementing the functionality before

00:00:53.060 --> 00:00:56.750
Java 11 and how it can be implemented in the Java 11,

00:00:56.750 --> 00:00:59.765
we'll see what is existing and what is the new one.

00:00:59.765 --> 00:01:03.830
So the new method has been overridden.

00:01:03.830 --> 00:01:06.020
So the metonym is jewelry.

00:01:06.020 --> 00:01:07.250
So for example, the duodenum,

00:01:07.250 --> 00:01:08.509
it that is already existing.

00:01:08.509 --> 00:01:11.765
And now we have a one millimeter the same name, but different parameters.

00:01:11.765 --> 00:01:14.510
That different parameters, the main function.

00:01:14.510 --> 00:01:16.625
So the ultimate good,

00:01:16.625 --> 00:01:20.045
you have a collection and you won't do it then the dataset array.

00:01:20.045 --> 00:01:24.575
So that is where I need to array method.

00:01:24.575 --> 00:01:28.835
Okay, Let's go back to some example which will be easy for us to understand.

00:01:28.835 --> 00:01:33.110
So I'm going to go to New back edge here, back h.

00:01:33.110 --> 00:01:40.170
And this is going to be Collection, eBay collection API.

00:01:40.180 --> 00:01:47.750
So I need to create a class here, new Java class.

00:01:47.750 --> 00:01:55.920
So we can name them like collection to every example.

00:01:57.070 --> 00:02:00.660
So let me go back to the presentation mode.

00:02:02.710 --> 00:02:04.940
Okay, so first thing first,

00:02:04.940 --> 00:02:09.090
let's create a main method so we can execute the code.

00:02:09.700 --> 00:02:13.460
Okay, so the ultimate goal is I have a list of collections.

00:02:13.460 --> 00:02:18.110
So let's create a collection first list which contains some name in it.

00:02:18.110 --> 00:02:20.450
So let's talk names.

00:02:20.450 --> 00:02:26.570
And it is going to be list.rev of once again.

00:02:26.570 --> 00:02:29.300
So let's just names here.

00:02:29.300 --> 00:02:31.565
Let's create some random names here.

00:02:31.565 --> 00:02:34.920
So I'm going to create strong.

00:02:35.830 --> 00:02:42.300
And see in January.

00:02:45.220 --> 00:02:48.020
So now I have a list of string,

00:02:48.020 --> 00:02:50.000
okay, It's the collection data, right?

00:02:50.000 --> 00:02:56.300
So let's see how it can be implemented in before Java 11.

00:02:56.300 --> 00:02:57.905
So the ultimate goal is,

00:02:57.905 --> 00:03:04.640
so I have a list of names I won't do to treat them as an array of strings.

00:03:04.640 --> 00:03:09.695
So I want to cast to collection to array.

00:03:09.695 --> 00:03:10.865
So how we can do that?

00:03:10.865 --> 00:03:11.960
So it's a string, right?

00:03:11.960 --> 00:03:13.610
So it's going to be a string array.

00:03:13.610 --> 00:03:16.500
So here to name array.

00:03:18.580 --> 00:03:22.685
Okay, so how are we going to implement that?

00:03:22.685 --> 00:03:24.860
So the collection, the names, right,

00:03:24.860 --> 00:03:29.795
so names is we are able to input the list of collection, okay?

00:03:29.795 --> 00:03:31.730
And we need to use 2D array.

00:03:31.730 --> 00:03:34.190
So this is a method which is a existing before Java 11.

00:03:34.190 --> 00:03:39.530
The same method we have been well water then in Java 11,

00:03:39.530 --> 00:03:43.625
but this particular method is available in the list.

00:03:43.625 --> 00:03:45.815
But the one which we,

00:03:45.815 --> 00:03:50.135
though no one pneuma that which is added at Spotify collection. I'll show you that.

00:03:50.135 --> 00:03:53.405
So 2D array, so instead they're due at a unit to provide.

00:03:53.405 --> 00:03:57.890
So whenever you create that a unit is specified the size rate.

00:03:57.890 --> 00:04:01.745
So new string.

00:04:01.745 --> 00:04:03.920
And you're going to provide the size.

00:04:03.920 --> 00:04:06.830
So the size is going to be your collection sites.

00:04:06.830 --> 00:04:10.800
It'll say names dot size.

00:04:10.900 --> 00:04:14.810
So now I have two. So what the problem here?

00:04:14.810 --> 00:04:21.770
So new string, a new string.

00:04:21.770 --> 00:04:23.345
Okay, So what is wrong here?

00:04:23.345 --> 00:04:29.910
So at any names, string two, extra space here.

00:04:33.340 --> 00:04:35.090
Oh, okay.

00:04:35.090 --> 00:04:38.510
Does not supposed to be open,

00:04:38.510 --> 00:04:41.330
close parenthesis, I mean, the square brackets.

00:04:41.330 --> 00:04:43.340
That is how the ADA again reticular, right.

00:04:43.340 --> 00:04:47.210
So Neil string of in the square regulated to progress into what is the size.

00:04:47.210 --> 00:04:50.765
So now I can wondered my collection into an array.

00:04:50.765 --> 00:04:54.080
So let me print that out.

00:04:54.080 --> 00:05:02.780
So this is going to be, my name is string, string array.

00:05:02.780 --> 00:05:04.655
So this is going to be array.

00:05:04.655 --> 00:05:07.415
So that way I can simply print that.

00:05:07.415 --> 00:05:11.570
So this dot, you can use a toString method.

00:05:11.570 --> 00:05:15.290
And here again, pass any advice here. So name Murray.

00:05:15.290 --> 00:05:22.445
So let me run this and show you. Got it.

00:05:22.445 --> 00:05:25.355
So now we've got the array data.

00:05:25.355 --> 00:05:30.005
Red, so we can try the same in other way.

00:05:30.005 --> 00:05:31.310
So for example, I,

00:05:31.310 --> 00:05:34.625
I wanted to treat them as an object of array.

00:05:34.625 --> 00:05:38.270
So which is pretty much straight forward.

00:05:38.270 --> 00:05:41.180
Okay, So here I wonder a desert restoring area.

00:05:41.180 --> 00:05:42.725
So I had to specify new string,

00:05:42.725 --> 00:05:44.480
but if we want to object,

00:05:44.480 --> 00:05:46.565
so object of array.

00:05:46.565 --> 00:05:52.985
And so name OBJ array is equal to,

00:05:52.985 --> 00:06:01.620
so names, sorry, names dot 2 or 8 on how to specify anything else here.

00:06:01.630 --> 00:06:04.400
So because I don't need any specific type,

00:06:04.400 --> 00:06:06.260
it's an object, it can be anything.

00:06:06.260 --> 00:06:09.500
So names object.

00:06:09.500 --> 00:06:12.230
So I start to string.

00:06:12.230 --> 00:06:15.395
So names object, array.

00:06:15.395 --> 00:06:17.760
So now I can rent a code.

00:06:19.540 --> 00:06:22.160
So both are the places we got deep,

00:06:22.160 --> 00:06:24.425
pretty much the same response.

00:06:24.425 --> 00:06:29.120
Okay, so now we need to know how I can do this in Java 11.

00:06:29.120 --> 00:06:33.410
First of all, let me show you the two array to array,

00:06:33.410 --> 00:06:36.110
which is available in

00:06:36.110 --> 00:06:42.920
the list class admin go to the top and I'll show you see this list interface, correct?

00:06:42.920 --> 00:06:46.550
So the list interface contains two, I,

00:06:46.550 --> 00:06:51.305
Raymond Dart and just take a look at here,

00:06:51.305 --> 00:06:53.885
the list interface extensor collection,

00:06:53.885 --> 00:06:56.450
the new method has been added and in the collection,

00:06:56.450 --> 00:07:03.245
so which means indirectly I'm overriding the 2D array method inside the list.

00:07:03.245 --> 00:07:06.800
Ok, so now let's,

00:07:06.800 --> 00:07:10.740
let me show you how it can be done in Java.

00:07:13.780 --> 00:07:16.820
Actually, it's a pretty simple one.

00:07:16.820 --> 00:07:18.455
So simple thing.

00:07:18.455 --> 00:07:22.790
So string, I want ASA names, right?

00:07:22.790 --> 00:07:27.000
So names, name, array.

00:07:27.820 --> 00:07:31.430
So I have the same name or its old existing site,

00:07:31.430 --> 00:07:34.055
so I'm going to keep it as a name A1.

00:07:34.055 --> 00:07:42.380
Okay, so that'll names dot toCharArray matter.

00:07:42.380 --> 00:07:46.430
But here, the matter we're not going to use, the first one doesn't matter.

00:07:46.430 --> 00:07:47.840
We are going to use the second one,

00:07:47.840 --> 00:07:51.950
bad contents, accepting the int function as an input.

00:07:51.950 --> 00:07:56.240
So the remainder which will act at function as a input.

00:07:56.240 --> 00:07:57.680
That is, I want to say I'm going to use it.

00:07:57.680 --> 00:08:02.960
So what I'm going to insert the US in 32 or limited exact for a function, right?

00:08:02.960 --> 00:08:11.465
So I'm going to use string because I'm going to use a string of RA.

00:08:11.465 --> 00:08:16.370
So what will happen here is a string which will,

00:08:16.370 --> 00:08:20.300
every time we do get new instance,

00:08:20.300 --> 00:08:21.830
not instance, new data.

00:08:21.830 --> 00:08:23.030
So what basically happened,

00:08:23.030 --> 00:08:24.650
the names have become ordered a 2 or a,

00:08:24.650 --> 00:08:26.120
and it'll be good every time.

00:08:26.120 --> 00:08:29.555
And the two arrays happening that each element, so one way, one,

00:08:29.555 --> 00:08:33.425
John, Nancy Daniel, one by one is added into a string of a.

00:08:33.425 --> 00:08:36.470
So the implementation is pretty simple here.

00:08:36.470 --> 00:08:41.300
Okay, so if I go to two or a month or you can see that this particular method has

00:08:41.300 --> 00:08:46.250
been available in D global,

00:08:46.250 --> 00:08:48.185
the top seed collection.

00:08:48.185 --> 00:08:50.090
So you might think like, okay,

00:08:50.090 --> 00:08:51.980
the previous two are limited available in

00:08:51.980 --> 00:08:54.590
the list and this is available in the collection,

00:08:54.590 --> 00:08:56.195
how it can be overridden.

00:08:56.195 --> 00:08:59.330
The reason is the list interface

00:08:59.330 --> 00:09:04.610
extends the collection so all the methods are visible to each other.

00:09:04.610 --> 00:09:07.340
So now what we can do,

00:09:07.340 --> 00:09:11.220
so we can simply run the code to see what's going to happen.

00:09:13.270 --> 00:09:21.980
So it is going to be namestring array in Java 11.

00:09:21.980 --> 00:09:26.790
So I reached out to the string Eigen news name array one here.

00:09:27.160 --> 00:09:30.390
So as simple as that,

00:09:32.440 --> 00:09:35.975
see, we got the same data.

00:09:35.975 --> 00:09:38.570
So the ultimate goal of this change,

00:09:38.570 --> 00:09:42.035
So you have a collection of data you want to return back. I fell at a.

00:09:42.035 --> 00:09:46.790
So normally we use to adamant that and here again we are going to use it to adamant that.

00:09:46.790 --> 00:09:49.100
But here we can use the int function,

00:09:49.100 --> 00:09:53.240
the methanogen or water then in Java 11.

00:09:53.240 --> 00:09:54.845
Right?

00:09:54.845 --> 00:10:00.125
Okay, so in the next video we're going to talk about another important feature.

00:10:00.125 --> 00:10:02.100
Thank you.
