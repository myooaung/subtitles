WEBVTT
ï»¿1
00:00:05.490 --> 00:00:07.610
Welcome back everyone in this lecture.

2
00:00:07.620 --> 00:00:14.900
We're going to have a quick crash course in the PI library Pi is a scientific computing and mathematical

3
00:00:14.900 --> 00:00:15.680
library.

4
00:00:15.680 --> 00:00:20.740
We're going to use at times during the course to just quickly generate some morays or matrices of data.

5
00:00:20.750 --> 00:00:24.860
So our main goal for this lecture is just to understand the various functions that are used later on

6
00:00:24.860 --> 00:00:31.070
in the course that allow us to generate data to plot it out using plot Lee and dash in case you're not

7
00:00:31.070 --> 00:00:32.510
using our environment file.

8
00:00:32.540 --> 00:00:38.130
You can install non-pilot with Pipp install them pie or install them pie directly at your command line.

9
00:00:39.100 --> 00:00:43.030
For this particular lecture I'm just going to be running the commands directly into the command line

10
00:00:43.330 --> 00:00:45.110
instead of running a PI script.

11
00:00:45.130 --> 00:00:49.540
However you should know that the fulled up postscript with all the commands I show here is provided

12
00:00:49.540 --> 00:00:52.050
for you in the notes in case you want to reference it.

13
00:00:52.330 --> 00:00:55.680
So let's go to our text editor and open up our terminal there.

14
00:00:55.840 --> 00:00:58.570
Or if you want just open up your command prompt directly.

15
00:00:58.570 --> 00:00:59.490
Let's get started.

16
00:00:59.740 --> 00:01:06.370
OK so if you follow it along with our installation setup guide should now have the platform real terminal

17
00:01:06.430 --> 00:01:08.260
here and create a new terminal.

18
00:01:08.310 --> 00:01:15.100
And then what you can do is in this new terminal just call I Python enter and you should be able to

19
00:01:15.100 --> 00:01:21.370
now run Piet's on commands where it supports that nice syntax highlighting as an alternative if you

20
00:01:21.400 --> 00:01:23.920
prefer not to use the terminal inside of Adam.

21
00:01:23.980 --> 00:01:28.510
You can just open up your terminal outside of Adam or if you're on a Windows computer you can just open

22
00:01:28.510 --> 00:01:29.370
up your command line.

23
00:01:29.380 --> 00:01:33.730
So for instance here I can just click on my command prompt and now I have my command prompt open here

24
00:01:34.120 --> 00:01:38.040
and outside of them I can also call Python and I get the same thing.

25
00:01:38.350 --> 00:01:42.700
So for the purposes of just fill in this lecture I'll just be running all the commands here at the command

26
00:01:42.700 --> 00:01:43.120
prompt.

27
00:01:43.180 --> 00:01:49.450
So let's minimize this guy open a command prompt again and let's get started.

28
00:01:49.450 --> 00:01:55.990
So one of the very first things I'm going to do here is I'm going to import some PI as an P and that

29
00:01:55.990 --> 00:01:58.740
allows me now to call some.

30
00:01:58.750 --> 00:02:03.880
So our main goal here is to figure out how do we create large arrays are large matrices quickly and

31
00:02:03.880 --> 00:02:05.020
easily if not pie.

32
00:02:05.110 --> 00:02:11.170
So I can plot them out with partly in-dash as we learn how those tools work well one way is by converting

33
00:02:11.230 --> 00:02:13.700
a python list into an array.

34
00:02:13.810 --> 00:02:25.400
So I can say my list is equal to 1 2 3 4 and then convert it to an umpire Ray by saying N.P. array and

35
00:02:25.400 --> 00:02:28.200
then just passing in my list.

36
00:02:28.200 --> 00:02:31.150
And if I run that now I can see I have an array.

37
00:02:31.160 --> 00:02:34.480
Keep in mind it hasn't actually affected the normal list.

38
00:02:34.520 --> 00:02:40.540
So if I check the type of my list here it's still just a list.

39
00:02:40.540 --> 00:02:45.840
If I actually want to change that list I would have to save it over to another variable.

40
00:02:45.850 --> 00:02:54.060
So it could do something like my variable A R R is equal to and appear Re of my list.

41
00:02:54.120 --> 00:02:56.660
And then I can check the type of they are.

42
00:02:56.820 --> 00:02:57.880
And it's an umpire.

43
00:02:58.000 --> 00:03:01.040
And if I enter again I can see here I have my array.

44
00:03:01.430 --> 00:03:07.350
OK so now let's go over some built in functions in non-pilot though allows to quickly create summaries

45
00:03:07.850 --> 00:03:13.830
one of them which is most common is the arr. function and the arr. function is just like the range function

46
00:03:13.830 --> 00:03:17.890
in Python where it takes an a start a stop and an optional step size.

47
00:03:18.300 --> 00:03:23.630
So I will say a is equal to a range.

48
00:03:23.820 --> 00:03:28.500
And we're going to say from 0 up to and not including 10.

49
00:03:28.530 --> 00:03:35.070
So what this is is going to return back in array of integers and the default step size is 1 and it's

50
00:03:35.070 --> 00:03:36.480
going to go from zero.

51
00:03:36.510 --> 00:03:40.840
Step size of one all the way up to but not including 10.

52
00:03:40.860 --> 00:03:45.550
So that means when I check what is it's an array 0 1 2 3 all the way tonight.

53
00:03:45.570 --> 00:03:49.890
So it goes up to and including 10 just like Python's range function.

54
00:03:49.890 --> 00:03:57.300
Now if I want to add in an optional step size what I can do if I hit upon my arrow key I can add in

55
00:03:57.300 --> 00:03:59.120
a third argument as a step size.

56
00:03:59.130 --> 00:04:01.310
So for instance going step size of two.

57
00:04:01.530 --> 00:04:05.260
And now when I check a 0 2 4 6 8.

58
00:04:05.370 --> 00:04:06.570
So that's the range function.

59
00:04:06.570 --> 00:04:09.840
It works just like Python's builtin range function.

60
00:04:09.840 --> 00:04:17.480
Now we can also create an array of zeros by saying and the zeros and here if we want to create a two

61
00:04:17.480 --> 00:04:18.740
dimensional array.

62
00:04:18.740 --> 00:04:24.650
What I can do is just pass in the dimensions as a tuple so I can say Give me a five by five.

63
00:04:24.650 --> 00:04:30.090
So notice here how in passing the tuple That's why I have two sets of princes into zeroes.

64
00:04:30.290 --> 00:04:34.060
So I'm passing if I buy five tuple zeros and I want to enter.

65
00:04:34.100 --> 00:04:36.190
Now I get back a to them missional array.

66
00:04:36.320 --> 00:04:40.110
Often referred to as a matrix and I have five by five.

67
00:04:40.130 --> 00:04:42.130
So five rows and five columns.

68
00:04:42.210 --> 00:04:45.250
That first number of five is going to be the number of rows.

69
00:04:45.290 --> 00:04:47.520
The second number five is number of columns.

70
00:04:47.570 --> 00:04:54.480
So let's make that clear by saying zeros and then saying one by 10.

71
00:04:55.480 --> 00:05:03.820
And then when you run that you can see I have one row and 10 columns or if I do this two by 10 I now

72
00:05:03.820 --> 00:05:05.800
have two rows and 10 columns.

73
00:05:05.830 --> 00:05:07.270
So the first numbers is the rows.

74
00:05:07.360 --> 00:05:11.020
Second number is the columns just like there's a zero's function.

75
00:05:11.020 --> 00:05:19.120
There's also a one function so we can say same thing and the ones give me two by four matrix and a set

76
00:05:19.120 --> 00:05:19.810
of all zeros.

77
00:05:19.840 --> 00:05:25.800
It's all ones notice here that for both zeros and ones there's a little decimal point after that 0 and

78
00:05:25.810 --> 00:05:26.630
after that one.

79
00:05:26.860 --> 00:05:32.490
And that just indicates that 0 and 1 integers actually floating point numbers.

80
00:05:32.500 --> 00:05:38.210
So the type of one point zero is a flow.

81
00:05:38.460 --> 00:05:42.650
And that's actually the same as a type of one point.

82
00:05:42.720 --> 00:05:43.700
That's also a float.

83
00:05:43.800 --> 00:05:48.690
It's just to differentiate between type of one by itself which would then be an integer.

84
00:05:48.720 --> 00:05:51.420
So non-pilot likes to convert things to float.

85
00:05:51.420 --> 00:05:53.360
If you provide them as integers.

86
00:05:53.710 --> 00:05:54.510
OK.

87
00:05:54.780 --> 00:05:58.990
Now let's move on to actually creating random arrays of integers.

88
00:05:59.010 --> 00:06:04.770
So we want some random distribution to our numbers and instead of something like all zeros or all ones.

89
00:06:04.770 --> 00:06:10.480
Luckily none pi has its own built in random library with lots of useful functions and features for us.

90
00:06:10.650 --> 00:06:14.400
So something we may need to do is create a random array of integers.

91
00:06:14.490 --> 00:06:22.580
So the way we do that is we say N.P. that random dot and then for random integers this is a uniform

92
00:06:22.580 --> 00:06:23.540
distribution.

93
00:06:23.630 --> 00:06:30.610
We can say Ranz R and D I N T and you give delimits.

94
00:06:30.630 --> 00:06:34.820
So you get the lower limit and the upper limit.

95
00:06:35.080 --> 00:06:41.500
And what this is going to do is it's going to return a random number between 0 and 100.

96
00:06:41.500 --> 00:06:45.060
So if I were to run this again it returns back forty nine.

97
00:06:45.070 --> 00:06:49.660
If I run this again returns back 96 and if you run this on your computer you'll see different random

98
00:06:49.660 --> 00:06:52.180
numbers between zero and 100.

99
00:06:52.300 --> 00:06:58.900
If you actually want an array of these random integers as a third argument what you can do is pass in

100
00:06:58.930 --> 00:07:02.040
a desired shape of the result.

101
00:07:02.050 --> 00:07:10.960
So for example if I want a five by five matrix of random numbers uniformly distributed from 0 to 100.

102
00:07:10.960 --> 00:07:14.970
What I can then do is pass and as the third argument that 5 by 5.

103
00:07:15.070 --> 00:07:21.640
So then when I hit enter I have a 5 by 5 matrix of randomly chosen numbers from 0 to 100.

104
00:07:21.640 --> 00:07:27.340
And what uniform distribution means it's just that every number between 0 and 100 has the same likelihood

105
00:07:27.460 --> 00:07:29.430
of being picked.

106
00:07:29.450 --> 00:07:35.740
OK so that's how you can make a random array of numbers as far as integers are concerned.

107
00:07:35.800 --> 00:07:43.410
We can also create a linearly spaced array and the way we do that is by saying end p dot Lynn space

108
00:07:45.080 --> 00:07:47.860
and here we can say from 0 to 10.

109
00:07:48.110 --> 00:07:51.470
So we have a start and stop the as a third argument.

110
00:07:51.470 --> 00:07:59.250
What we do is we say how many actual numbers do we want linearly space between 0 and 10.

111
00:07:59.480 --> 00:08:05.520
So let's imagine I want six numbers from 0 to 10 that are linearly spaced that are returns back zero

112
00:08:05.520 --> 00:08:07.020
to four six eight 10.

113
00:08:07.190 --> 00:08:10.610
So those are six numbers and the space between each of those numbers is the same.

114
00:08:10.640 --> 00:08:11.670
It's two.

115
00:08:11.780 --> 00:08:21.010
Now if I were to say something like and P lens space notice how it's just like an L I N E.

116
00:08:21.270 --> 00:08:28.580
Space from 0 to 10 and I say OK now give me a hundred in one evenly spaced numbers then we get a lot

117
00:08:28.580 --> 00:08:29.040
more.

118
00:08:29.060 --> 00:08:38.070
Now the space is 0.1 and I can keep doing this for large or small numbers so I can say N.P. space 0

119
00:08:38.080 --> 00:08:38.810
to 10.

120
00:08:38.900 --> 00:08:44.210
And then however numbers how many numbers are elements you want linearly spaced from that starting point

121
00:08:44.270 --> 00:08:45.460
to that start point.

122
00:08:45.480 --> 00:08:53.050
So if I say 200 then I get back 200 numbers all evenly spaced from zero to 10.

123
00:08:53.470 --> 00:08:53.920
OK.

124
00:08:54.230 --> 00:08:57.600
So now we're finally going to discuss some PI operations.

125
00:08:57.890 --> 00:09:00.500
So we just saw how we could create random numbers.

126
00:09:00.500 --> 00:09:06.770
But often especially for testing purposes it's nice if you could generate the same random numbers over

127
00:09:06.770 --> 00:09:07.600
and over again.

128
00:09:07.850 --> 00:09:11.680
That way you could actually compare results especially if you're working along this course.

129
00:09:11.780 --> 00:09:15.140
You'll try to get the same random numbers that I do in order to do that.

130
00:09:15.170 --> 00:09:25.960
We need to set a random seed so we can say N.P. random seed and then you pass in just an arbitrary number

131
00:09:26.290 --> 00:09:28.280
the number itself isn't actually important.

132
00:09:28.300 --> 00:09:32.680
What's important is that you're passing in the same number over and over again or you're passing the

133
00:09:32.680 --> 00:09:34.840
same number that I'm using right now.

134
00:09:34.870 --> 00:09:36.770
So I like to pasan 101.

135
00:09:36.790 --> 00:09:38.690
Again it's a totally arbitrary choice.

136
00:09:38.890 --> 00:09:43.890
But what this does is it sets a seed to a random number generator and then pi.

137
00:09:44.170 --> 00:09:56.230
And that way when I ask for a random rant I see again from let's say zero to 100 and let's say I just

138
00:09:56.230 --> 00:09:59.850
want 10 random numbers from zero to 100.

139
00:10:00.130 --> 00:10:01.210
If I enter now.

140
00:10:01.240 --> 00:10:07.030
If you're following along with me you should now actually have the same ran the numbers 95 11 81 and

141
00:10:07.030 --> 00:10:08.260
so on.

142
00:10:08.260 --> 00:10:14.710
Keep in mind you have to call this seed directly before calling this random integer line because if

143
00:10:14.710 --> 00:10:21.430
you run this line again the random integer line then you're going to get another set of random numbers.

144
00:10:21.430 --> 00:10:28.120
However if you were to run it just like I did seed random integer random integer these two sets of arrays

145
00:10:28.180 --> 00:10:29.800
should be the same for you.

146
00:10:29.800 --> 00:10:35.050
So a lot of times we are going to do is in our scripts since that PI scripts are going to be run over

147
00:10:35.050 --> 00:10:38.130
and over again we can do is at the very top of our thought Paice grip.

148
00:10:38.160 --> 00:10:43.870
So a seed that way in case we ever use random numbers you can be assured that you'll also get the same

149
00:10:43.870 --> 00:10:44.610
random numbers.

150
00:10:44.650 --> 00:10:46.450
So you can fairly compare your results.

151
00:10:46.630 --> 00:10:50.480
So that's all random that seed is doing OK.

152
00:10:50.740 --> 00:10:56.200
Now a few more umpire operations that you may find useful are things like max min mean.

153
00:10:56.200 --> 00:11:02.890
So let's quickly show you those are going to create an array and we'll say an arrays and the random

154
00:11:03.520 --> 00:11:10.540
random integers from 0 to 100 and we'll say give me 10 random integers there.

155
00:11:10.810 --> 00:11:15.430
So if I take a look in my array it's those 10 random integers and it's not super important that you

156
00:11:15.430 --> 00:11:19.700
get the same random ones I do right now but we can do is off of an array.

157
00:11:19.810 --> 00:11:24.950
You can call Max and it will give you back the maximum the value in the array.

158
00:11:24.950 --> 00:11:27.130
In my case it was 83.

159
00:11:27.140 --> 00:11:32.720
You can also call men and those I have open and close parentheses and then it returns back the minimum

160
00:11:32.720 --> 00:11:34.130
value of the array.

161
00:11:34.130 --> 00:11:39.110
Keep in mind if you forget those print sees if you just say a r r or whatever the variable name of your

162
00:11:39.110 --> 00:11:44.000
array is that men and enter it's going to report back hey you have this function that you could call

163
00:11:44.360 --> 00:11:47.010
in order to actually figure out what your minimum value is.

164
00:11:47.090 --> 00:11:52.090
You need to have those open and close print seats right next to it and then return back and there's

165
00:11:52.100 --> 00:11:53.590
a bunch of other ones you can do.

166
00:11:53.720 --> 00:11:57.040
But these are mainly the ones we're going to be using in the course Max.

167
00:11:57.060 --> 00:12:01.670
Men can also get mean or turn back the mean value of all those numbers in the array.

168
00:12:01.940 --> 00:12:06.890
And if you want the location of the max value or the minimum value where you can do is instead of just

169
00:12:06.890 --> 00:12:15.010
saying max or min you can use ARG Max and those were RMX those returns back to the index location of

170
00:12:15.010 --> 00:12:16.360
that maximum value.

171
00:12:16.360 --> 00:12:20.750
So for call that in Python and in some pie indexing starts at zero.

172
00:12:20.950 --> 00:12:23.370
So zero locations have 49.

173
00:12:23.470 --> 00:12:30.090
So at one location we have 83 mean that the location of that max value is in expositional on can it

174
00:12:30.130 --> 00:12:31.340
the same thing for men.

175
00:12:31.510 --> 00:12:39.340
So notice here if we go 0 1 to the location of the minimum value of 8 it should be in this location

176
00:12:39.620 --> 00:12:49.020
to say our call argument and it returns back index location 2 which makes sense because it's seen the

177
00:12:49.130 --> 00:12:52.190
location of the minimum value of 8.

178
00:12:52.310 --> 00:12:58.100
And then finally if you ever want to reshape an array often what people do is they'll create a one dimensional

179
00:12:58.100 --> 00:13:00.270
array and then reshape it to them.

180
00:13:00.310 --> 00:13:01.160
All right.

181
00:13:01.220 --> 00:13:06.130
And you can do that quite easily using the reshape command you just off of your array.

182
00:13:06.140 --> 00:13:11.990
Call the method reshape and then passen whatever that mentions you want to reshape to for instance since

183
00:13:12.080 --> 00:13:14.060
I have a 1 by 10 array here.

184
00:13:14.300 --> 00:13:17.290
I could reshape it to be a two by five array.

185
00:13:17.720 --> 00:13:27.700
And now I have two rows by five columns Finally let's discuss indexing unmasking to show you this.

186
00:13:27.710 --> 00:13:34.670
I'm going to quickly create a new to them Minshull matrix or to them missional array will say our variable

187
00:13:34.670 --> 00:13:43.280
math is equal to p arr. and we're going to go from 0 to 100 and then I'm going to stack some methods

188
00:13:43.290 --> 00:13:44.490
here.

189
00:13:44.490 --> 00:13:49.970
So I'll say arrange range and off of that object I'm going to reshape it to be 10 by 10.

190
00:13:50.270 --> 00:13:56.070
So now if I take a look at my matrix I have zero through nine nine They're 10 rows by 10 columns.

191
00:13:56.120 --> 00:13:56.960
Perfect.

192
00:13:56.960 --> 00:14:00.590
Let's imagine that you wanted to select an individual number off of this.

193
00:14:00.680 --> 00:14:07.700
The format for that is you call your variable then use square brackets or square braces and pasand the

194
00:14:07.700 --> 00:14:10.760
row value you want and then the column value you want.

195
00:14:10.820 --> 00:14:13.620
For example let's grab 52.

196
00:14:13.730 --> 00:14:16.470
So 52 the index row in.

197
00:14:16.490 --> 00:14:19.870
If you start counting 0 1 2 3 4 5.

198
00:14:19.910 --> 00:14:27.250
It's going to be at row 5 then comma and the column it's in the index to 0 1 2.

199
00:14:27.860 --> 00:14:31.210
And then you just close off those square brackets.

200
00:14:31.310 --> 00:14:32.840
And now you get 52.

201
00:14:32.840 --> 00:14:37.780
And it's really it's easy to see in this example how that first number correlates to the row in that

202
00:14:37.790 --> 00:14:40.310
second number there actually correlates to the column.

203
00:14:40.340 --> 00:14:45.590
So that's how it works for actually just grabbing a single element of a matrix if you want to grab an

204
00:14:45.590 --> 00:14:46.760
entire column.

205
00:14:46.760 --> 00:14:53.320
All you need to do is say Matt and then use a colon instead of an actual number.

206
00:14:53.780 --> 00:14:56.090
And then just provide the column number you want.

207
00:14:56.120 --> 00:15:00.240
So for instance to and then I can get back the Saray here.

208
00:15:00.290 --> 00:15:01.730
So what is this actually saying.

209
00:15:01.910 --> 00:15:08.170
It's saying hey for column 2 the colon says Give me back every single row and column 2.

210
00:15:08.180 --> 00:15:13.950
So if we look at column two every single rows to 12 22 32 and so on.

211
00:15:14.030 --> 00:15:17.730
And likewise you can do the opposite to get back an entire row.

212
00:15:17.750 --> 00:15:22.880
So this first one right here that was showed it brings back everything in column two if we wanted everything

213
00:15:22.880 --> 00:15:25.980
in a row to what I would do just the reverse.

214
00:15:26.000 --> 00:15:31.910
I would say in row two comma give me back every single column value.

215
00:15:31.910 --> 00:15:33.890
So that's two comma colon.

216
00:15:33.930 --> 00:15:34.710
Hit enter.

217
00:15:34.760 --> 00:15:42.470
And now I have an array of that row 20 21 etc. and keep in mind it's returning the back as one dimensional

218
00:15:42.470 --> 00:15:43.060
arrays.

219
00:15:43.170 --> 00:15:48.650
But you can always use reshape in order to shape them back into whatever format you want.

220
00:15:49.850 --> 00:15:54.830
Now we're going to talk about masking and masking allows you to use conditional filters to grab elements

221
00:15:55.150 --> 00:15:57.640
and we're going to see a lot more about this in Pandas.

222
00:15:57.650 --> 00:16:00.650
So this is just a little primer of an introduction.

223
00:16:00.770 --> 00:16:03.030
Let's imagine that we have our matrix again.

224
00:16:03.410 --> 00:16:11.800
And it's all the numbers from 0 to 99 all the integers that is if I say Matt greater than 50.

225
00:16:11.960 --> 00:16:16.580
So I do some sort of boolean conditional check here or a comparison operation.

226
00:16:16.580 --> 00:16:22.310
It's going to return back a really interesting matrix and this matrix is a matrix of boolean values

227
00:16:22.640 --> 00:16:29.360
where false indicates where the matrix was not greater than 50 and true in the case where the Saray

228
00:16:29.660 --> 00:16:31.190
was greater than 50.

229
00:16:31.220 --> 00:16:39.770
So I have a matrix of boolean values here and then I can pass this in as a filter back into my matrix

230
00:16:39.920 --> 00:16:44.720
in order to only select the values or elements where this happened to be true.

231
00:16:44.750 --> 00:16:45.700
So what does that mean.

232
00:16:45.890 --> 00:16:57.680
Well I can say Matt square break braces mats greater than 50 enter and now I only have the values that

233
00:16:57.710 --> 00:16:59.220
are greater than 50.

234
00:16:59.310 --> 00:17:03.630
We're going to touch a lot more on this sort of example when we talk about Panas coming up next.

235
00:17:04.010 --> 00:17:04.700
OK.

236
00:17:04.700 --> 00:17:06.870
That's really all we need to know for pi.

237
00:17:06.890 --> 00:17:11.480
In fact a lot of this is more just the primer to get you ready for pandas which is really the workhorse

238
00:17:11.480 --> 00:17:14.670
we used during this course as far as dealing with data.

239
00:17:14.780 --> 00:17:17.540
If you have any questions feel free to post the Q&amp;A forums.

240
00:17:17.540 --> 00:17:21.380
But that's the basics of what you need to know for an umpire for this course.

241
00:17:21.380 --> 00:17:23.090
Thanks and I'll see you at the next lecture.

