WEBVTT
1
1

00:00:00.383  -->  00:00:02.800
(fun jingle)
2

2

00:00:05.470  -->  00:00:07.580
<v Sarah>Alright, so, before we wrap up the course,</v>
3

3

00:00:07.580  -->  00:00:11.560
the last thing we're gonna look at very briefly is sets.
4

4

00:00:11.560  -->  00:00:13.540
Sets are an abstract data type
5

5

00:00:13.540  -->  00:00:16.610
because they really apply to any data structure.
6

6

00:00:16.610  -->  00:00:21.380
All a set is, is a data set that doesn't contain duplicates
7

7

00:00:21.380  -->  00:00:23.040
and so, if something is a set,
8

8

00:00:23.040  -->  00:00:26.100
it cannot contain duplicate values.
9

9

00:00:26.100  -->  00:00:28.750
Now, the JDK has support for sets.
10

10

00:00:28.750  -->  00:00:32.250
I'm at the set interface here and right here, we'll see
11

11

00:00:32.250  -->  00:00:35.500
it's a collection that contains no duplicate elements
12

12

00:00:35.500  -->  00:00:37.840
and they explain what that means for Java.
13

13

00:00:37.840  -->  00:00:41.810
It means that no pair of elements can exist in the set
14

14

00:00:41.810  -->  00:00:46.280
such that e1.equals(e2) is true.
15

15

00:00:46.280  -->  00:00:49.380
And so, if the equals method is gonna return true
16

16

00:00:49.380  -->  00:00:52.130
for two instances then, those two instances
17

17

00:00:52.130  -->  00:00:53.880
cannot belong to the same set.
18

18

00:00:53.880  -->  00:00:58.710
And they say that the set can contain one null element.
19

19

00:00:58.710  -->  00:01:00.390
So, you can come in and read
20

20

00:01:00.390  -->  00:01:03.890
the rest of the documentation here if you're interested.
21

21

00:01:03.890  -->  00:01:05.760
There's a lot of support for sets.
22

22

00:01:05.760  -->  00:01:07.970
We can see here, there's an abstract set, so,
23

23

00:01:07.970  -->  00:01:09.680
just like with the other interfaces,
24

24

00:01:09.680  -->  00:01:11.990
if you wanna implement your own customised set,
25

25

00:01:11.990  -->  00:01:14.390
rather than implementing the interface,
26

26

00:01:14.390  -->  00:01:16.080
if you extend abstract set,
27

27

00:01:16.080  -->  00:01:17.960
you'll get a bit of a headstart.
28

28

00:01:17.960  -->  00:01:21.750
We can see that we have HashSet and if we come over here,
29

29

00:01:21.750  -->  00:01:23.500
this is an implementation of set
30

30

00:01:23.500  -->  00:01:27.440
that's backed by a hash table, they say actually, a HashMap
31

31

00:01:27.440  -->  00:01:30.030
and so, that's an implementation of set.
32

32

00:01:30.030  -->  00:01:33.510
We've got a linked HashSet and that's a hash table
33

33

00:01:33.510  -->  00:01:37.070
and linked list implementation of the set interface.
34

34

00:01:37.070  -->  00:01:41.260
We've got a TreeSet, I mentioned that in the tree section
35

35

00:01:41.260  -->  00:01:45.370
and so, this is a navigable set implementation
36

36

00:01:45.370  -->  00:01:49.000
based on a TreeMap and so, if you wanted to build a tree
37

37

00:01:49.000  -->  00:01:51.140
that has no duplicate elements in it,
38

38

00:01:51.140  -->  00:01:52.920
you could use this class.
39

39

00:01:52.920  -->  00:01:55.850
And so, I just, very quickly, wanted to mention sets
40

40

00:01:55.850  -->  00:01:58.040
because they are an abstract data type
41

41

00:01:58.040  -->  00:02:01.410
and there is lots of support for them in the JDK.
42

42

00:02:01.410  -->  00:02:03.880
So, if we come down here to the methods and we see,
43

43

00:02:03.880  -->  00:02:07.200
we see the add method, it says, adds the specified element
44

44

00:02:07.200  -->  00:02:09.350
if it's not already present.
45

45

00:02:09.350  -->  00:02:11.447
In here, for the documentation for add,
46

46

00:02:11.447  -->  00:02:15.470
they go into, again, details about what they consider to be
47

47

00:02:15.470  -->  00:02:17.170
a duplicate element.
48

48

00:02:17.170  -->  00:02:19.220
If we go back to the list of methods now,
49

49

00:02:19.220  -->  00:02:22.240
we can see that there's also a contains,
50

50

00:02:22.240  -->  00:02:25.360
as there usually is, there's an iterator, there's a remove
51

51

00:02:25.360  -->  00:02:29.090
and you can convert the set to an array if you like.
52

52

00:02:29.090  -->  00:02:31.460
And so, there's really nothing new here
53

53

00:02:31.460  -->  00:02:33.980
and that's why I didn't wanna spend a lot of time on it,
54

54

00:02:33.980  -->  00:02:36.990
because, if you understand the other data structures
55

55

00:02:36.990  -->  00:02:40.490
we've looked at, this is sort of an extra layer
56

56

00:02:40.490  -->  00:02:43.330
of a requirement and the requirement is just that,
57

57

00:02:43.330  -->  00:02:45.480
you can't add duplicate items.
58

58

00:02:45.480  -->  00:02:48.933
And that's it for sets, I'll see you in the next video.
