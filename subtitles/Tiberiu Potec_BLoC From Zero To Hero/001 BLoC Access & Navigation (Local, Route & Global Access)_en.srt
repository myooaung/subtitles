1
00:00:00,300 --> 00:00:01,830
What is going on, everyone?

2
00:00:01,980 --> 00:00:03,870
Welcome back to chapter number six.

3
00:00:03,870 --> 00:00:09,570
In this chapter, I'll introduce you to Block Access, more specifically, how you can access a block

4
00:00:09,570 --> 00:00:15,030
instance across various scenarios with block provider and block provider that value.

5
00:00:15,120 --> 00:00:17,970
It is going to be a long but highly important tutorial.

6
00:00:17,980 --> 00:00:20,820
So make sure you buckle up and grab some popcorn at first.

7
00:00:21,120 --> 00:00:26,700
Remember that in my third tutorial of this series regarding block concepts, I showed you how to provide

8
00:00:26,700 --> 00:00:33,980
a single block instance, the counter cubitt to the widget tree of a single page by using block provider.

9
00:00:34,020 --> 00:00:39,420
Well, in that video, we only provide it locally to a single screen.

10
00:00:39,720 --> 00:00:46,200
But what if we want to provide it to another screen, to multiple screens or even globally to all of

11
00:00:46,200 --> 00:00:48,240
our app screens in order to follow up?

12
00:00:48,270 --> 00:00:54,420
We will also need to close my repository from GitHub and open the third block concepts folder inside

13
00:00:54,420 --> 00:00:57,750
the code so that we can continue right where we previously left.

14
00:00:57,780 --> 00:01:04,260
OK, so let's dive into our first scenario, which we have actually discussed in program before locally

15
00:01:04,260 --> 00:01:08,540
providing a single instance of the counter cubitt to our default home screen.

16
00:01:08,550 --> 00:01:14,880
If you remember, if we wrap a widget with a block provider, a single instance of that specific block

17
00:01:14,880 --> 00:01:17,450
will be provided to all of its direct children.

18
00:01:17,460 --> 00:01:23,220
We can provide it this way across the widget tree, thanks to the build context, which is a way Flutter

19
00:01:23,220 --> 00:01:27,440
knows which is actually the parent and which are the children across the widget.

20
00:01:27,750 --> 00:01:33,510
Since most apps nowadays benefit from more than one screen, flutter also comes with the navigation

21
00:01:33,510 --> 00:01:37,830
stack, which organizes the routes and their specific screens inside the app.

22
00:01:37,830 --> 00:01:43,170
So every time the app displays a new screen, we should know that Flutter pushes a new route with the

23
00:01:43,170 --> 00:01:45,180
new screen inside the navigation stack.

24
00:01:45,180 --> 00:01:50,100
Every time we click the back button on our phone, we should note that Flutter pops the current screen

25
00:01:50,100 --> 00:01:50,910
out of the stack.

26
00:01:50,910 --> 00:01:56,160
There are many other actions besides pushing and popping, which can be executed on flusters navigation

27
00:01:56,160 --> 00:01:56,520
stack.

28
00:01:56,520 --> 00:01:59,040
But these are beyond the purpose of this video.

29
00:01:59,050 --> 00:02:04,410
You must know that every application must have a default home route, a route which is automatically

30
00:02:04,410 --> 00:02:07,000
pushed by default when the app is started.

31
00:02:07,020 --> 00:02:12,630
In our case, inside the navigation stack, Flutter only pushes the default home route, which is the

32
00:02:12,630 --> 00:02:14,910
home screen containing the counter feature.

33
00:02:14,910 --> 00:02:19,860
Coming back to our block access discussion, you may wonder Wicked, you showed us that you can provide

34
00:02:19,860 --> 00:02:22,650
a single instance of the counter QB to our home screen.

35
00:02:22,680 --> 00:02:24,690
Why do you call it local access?

36
00:02:24,720 --> 00:02:31,050
Well, it's called local access because as the name is implying, the cubitt will only be available

37
00:02:31,050 --> 00:02:34,100
locally inside the widgets of that screen.

38
00:02:34,290 --> 00:02:39,180
So you're saying that if we push another screen inside Fata's navigation stack, the counter Cubitt

39
00:02:39,180 --> 00:02:40,560
won't be available there, too?

40
00:02:40,920 --> 00:02:43,080
Indeed, that's absolutely correct.

41
00:02:43,320 --> 00:02:49,920
If we push a new screen into the navigation stack, Flutter will add its widgets to the already available

42
00:02:49,920 --> 00:02:50,550
widget tree.

43
00:02:50,700 --> 00:02:56,340
But since this, we just are part of a new screen from when you wrote the bill, context doesn't know

44
00:02:56,340 --> 00:03:02,250
how to indicate block provider, where to provide a single instance of the counter cubitt up next.

45
00:03:02,280 --> 00:03:05,580
So here comes the major break up with local access.

46
00:03:05,730 --> 00:03:11,910
Local access means providing a single instance of a block to only one screen, thus to the entire widget,

47
00:03:12,150 --> 00:03:13,530
which is part of that screen.

48
00:03:13,800 --> 00:03:20,100
Let's test this theory for now inside our code so we know that currently locally providing our counter

49
00:03:20,100 --> 00:03:23,030
cubitt to our default home screen works perfectly.

50
00:03:23,040 --> 00:03:28,830
Firstly, let's do some refactoring with the structure of our folders and go this way will also be testing

51
00:03:28,830 --> 00:03:30,350
the block architecture layers.

52
00:03:30,360 --> 00:03:31,700
We learned a couple of tutorials.

53
00:03:32,190 --> 00:03:37,200
So in order to stick to the architecture, we must highlight the business logic layer by creating a

54
00:03:37,200 --> 00:03:43,680
business logic folder which are simply call it logic and in which will move the cubitt folder with our

55
00:03:43,680 --> 00:03:44,570
counter cubitt.

56
00:03:44,670 --> 00:03:48,380
Then, as we know, the UI should be part of the presentation layer.

57
00:03:48,390 --> 00:03:52,380
So I'll create a presentation folder along with the screen subfolder.

58
00:03:52,380 --> 00:03:57,550
Inside this folder will place all of our different screens from inside this tutorial inside the main,

59
00:03:57,550 --> 00:03:58,320
that dirt file.

60
00:03:58,320 --> 00:04:04,830
You can notice that, as I told you previously, Flutter has a separate feel inside material which is

61
00:04:04,830 --> 00:04:10,860
named home denoting that this is the screen which is going to be pushed up first onto the navigation

62
00:04:10,860 --> 00:04:11,370
stack.

63
00:04:11,370 --> 00:04:17,820
In our case is the my home page on which will press F2 and rename it to homescreen will move the entire

64
00:04:17,820 --> 00:04:20,339
implementation inside the separate home.

65
00:04:20,339 --> 00:04:23,780
Underscore screen that dirt file inside the screen folder.

66
00:04:23,790 --> 00:04:30,060
I have also modified the homescreen class a little bit so that it will take a title and a colour as

67
00:04:30,060 --> 00:04:35,940
parameters in order to make it stand out compared to the next screen will create will also need to add

68
00:04:35,940 --> 00:04:41,520
a material button inside our home screen, which will push a new screen on the navigation stack.

69
00:04:41,520 --> 00:04:44,730
When we press, it will leave the unpressed function empty for now.

70
00:04:45,060 --> 00:04:50,640
To demonstrate that the counter block won't be accessible to a new push screen, we would obviously

71
00:04:50,640 --> 00:04:54,960
need to create a new screen called Second Underscore Screen that d'arte.

72
00:04:54,960 --> 00:04:59,880
In order to speed up the process, I'll just duplicate some of our existing home screen code.

73
00:04:59,980 --> 00:05:05,200
Inside our second screen class, this is not really recommended in programming, since we shouldn't

74
00:05:05,200 --> 00:05:08,370
have duplicate code, but for testing purposes, it's OK.

75
00:05:08,470 --> 00:05:14,230
Now we need to go back to our home screen because we need to write the code to push the second screen

76
00:05:14,230 --> 00:05:15,480
onto the navigation stack.

77
00:05:15,490 --> 00:05:22,360
We'll do this by using navigator that out of context that Bush and Material Page are out to easily differentiate

78
00:05:22,360 --> 00:05:25,410
between the home screen and the second screen for the home screen.

79
00:05:25,420 --> 00:05:30,220
I'll use a blue X and color and for the second screen a red X and one.

80
00:05:30,340 --> 00:05:34,650
Finally we can run the project and as you can see, everything is running fine.

81
00:05:34,840 --> 00:05:38,290
The counter block is provided locally inside the home screen page.

82
00:05:38,290 --> 00:05:40,840
All the functionality is working as it should.

83
00:05:40,840 --> 00:05:47,500
But if we press the go to second screen button, you'll see that the application will crash with an

84
00:05:47,500 --> 00:05:48,940
error to be expected.

85
00:05:49,120 --> 00:05:57,270
Block provider that you've called with a context that does not contain a cubit of type countercoup.

86
00:05:57,280 --> 00:06:02,410
As you can see inside the second screen, we're asking the block provider for the counter cubitt instance.

87
00:06:02,830 --> 00:06:09,220
But since the new bill context doesn't know either where the instances or how to find it, it shows

88
00:06:09,220 --> 00:06:11,670
an error making the application crash.

89
00:06:11,860 --> 00:06:17,680
You may be asking yourselves now, well, how will we provide the Cubitt instance to a new screen that

90
00:06:17,920 --> 00:06:21,400
the answer to that question will be by using Routt access?

91
00:06:21,430 --> 00:06:24,700
Until now, we only provided the QB to a single screen.

92
00:06:24,850 --> 00:06:31,360
Providing an instance of a block or cubitt to only one screen is called local access.

93
00:06:31,360 --> 00:06:37,390
Providing an instance of a block or cubitt to multiple screens is called route access.

94
00:06:37,420 --> 00:06:42,820
We're calling this route access because we need to profit of the routing navigation feature of flutter

95
00:06:42,820 --> 00:06:45,730
in order to provide the instance to the multiple screens.

96
00:06:45,730 --> 00:06:50,950
You don't need to think of local and remote access as to complete different scenarios because you will

97
00:06:50,950 --> 00:06:53,050
see that in the following part of the editorial.

98
00:06:53,290 --> 00:06:56,680
Some parts of the remote access are linked to the local access.

99
00:06:56,860 --> 00:07:03,220
OK, so as I told you a couple of moments ago, route access is related to the routing navigation feature

100
00:07:03,220 --> 00:07:06,400
of Flutter because it's so strongly related.

101
00:07:06,400 --> 00:07:10,840
I need to make a short introduction on how Flutter manages its routing feature.

102
00:07:10,930 --> 00:07:17,080
Usually in routing feature, you'll need a pair of data containing both the routing name or tag and

103
00:07:17,080 --> 00:07:21,180
the page or screen you want to be displayed when you enter that scrutiny.

104
00:07:21,190 --> 00:07:26,830
Think of this as the way Web pages work when you enter five hundred pixels dot com, which is a popular

105
00:07:26,830 --> 00:07:28,000
photography website.

106
00:07:28,000 --> 00:07:32,800
If you want to navigate to the most popular photos you can append slash popular to the website.

107
00:07:32,800 --> 00:07:38,080
The Slash Popular is the road name and the popular page is what is gets loaded up.

108
00:07:38,350 --> 00:07:44,740
After having this in mind, you need to know that in flutter there are three major routing options available.

109
00:07:44,740 --> 00:07:48,760
Anonymous routing named routing and generated routing.

110
00:07:48,760 --> 00:07:53,830
Anonymous routing is at his name is implying routing without a Rosny.

111
00:07:53,860 --> 00:07:57,730
Anonymous routing is what we've been doing so far in our counter wrap.

112
00:07:57,880 --> 00:08:05,290
So by default we provided only the name of the homescreen class to the home parameter inside the material

113
00:08:05,290 --> 00:08:05,670
app.

114
00:08:05,710 --> 00:08:11,380
Also, when we navigate it from the home screen to the second screen, we used the material page route

115
00:08:11,410 --> 00:08:13,750
without having to provide a name.

116
00:08:13,750 --> 00:08:19,900
On the other hand, name routing is routing with a provided name.

117
00:08:20,050 --> 00:08:24,910
This is the routing method I explained a couple of moments before when I mentioned the example with

118
00:08:24,910 --> 00:08:26,950
the five hand pixels that come website.

119
00:08:26,980 --> 00:08:32,020
All the routes you want to provide have to be set inside the roads parameter of the material.

120
00:08:32,020 --> 00:08:32,830
App Widget.

121
00:08:32,980 --> 00:08:38,500
Here's a quick example on how they will look like if you're building a small to medium sized application,

122
00:08:38,530 --> 00:08:44,169
this named routing is recommended as opposed to the anonymous routing which might get really cluttered

123
00:08:44,169 --> 00:08:45,220
and unorganized.

124
00:08:45,250 --> 00:08:51,100
However, when you're working on a large project is recommended to user generated routing, generated

125
00:08:51,100 --> 00:08:54,190
routing has almost the same structure as the named routing.

126
00:08:54,340 --> 00:09:00,520
The only difference being is that you need to have a separate function in which you have to set up all

127
00:09:00,520 --> 00:09:01,470
our routes.

128
00:09:01,510 --> 00:09:06,820
This is a more professional approach since it will be cluttered the material map of the parameter,

129
00:09:06,820 --> 00:09:10,600
a parameter which might get really cluttered while working on a huge application.

130
00:09:10,660 --> 00:09:15,700
You will see from the code that it's actually pretty simple and self-explanatory since there are three

131
00:09:15,700 --> 00:09:16,870
major routing options.

132
00:09:16,870 --> 00:09:22,660
We'll tackle up each one of them to see how easy it is to provide an instance of a block or cubitt across

133
00:09:22,660 --> 00:09:25,630
each page in every of the above scenarios.

134
00:09:25,660 --> 00:09:30,550
We'll start up with the anonymous routing since is the one we really close to right now.

135
00:09:30,790 --> 00:09:36,070
Providing a block or a cubitt instance across different anonymous routes is a key functionality.

136
00:09:36,070 --> 00:09:39,190
So make sure you pay a little bit more attention to this topic.

137
00:09:39,190 --> 00:09:44,950
Currently, we provided a counter to locally to our home screen, therefore to all of its children widgets.

138
00:09:44,950 --> 00:09:50,230
We know that when we press the go to second screen button, there will be a new anonymous Routt pushed

139
00:09:50,410 --> 00:09:53,710
on the navigation stack, loading up our second screen.

140
00:09:53,710 --> 00:09:58,990
Unfortunately, due to the fact that the second screen has a different built context, the block provider

141
00:09:58,990 --> 00:09:59,820
isn't able.

142
00:09:59,840 --> 00:10:04,550
To continue providing the counter cubitt instance to the second screen, thus making the application

143
00:10:04,550 --> 00:10:10,340
crash so there is a working instance of the counter cubitt available in the entire homescreen widget

144
00:10:10,340 --> 00:10:10,620
tree.

145
00:10:10,670 --> 00:10:16,310
How can we provide this working instance up next to the entire widget Tree of the Second Street?

146
00:10:16,730 --> 00:10:18,110
That's the big question.

147
00:10:18,170 --> 00:10:26,000
The answer is by using block provider, that value widget block provider, that value takes an existing

148
00:10:26,030 --> 00:10:31,500
instance of a block or cubitt and provides it further to its widget.

149
00:10:31,520 --> 00:10:36,470
In our case, the second screen, let's switch to the coding part so that you understand the concept

150
00:10:36,470 --> 00:10:36,940
better.

151
00:10:36,980 --> 00:10:42,440
So we're inside the homescreen class right where the second screen anonymous root gets pushed on the

152
00:10:42,440 --> 00:10:43,290
navigation stack.

153
00:10:43,310 --> 00:10:45,370
This is done by using material page.

154
00:10:45,710 --> 00:10:48,700
The second screen is being written by the builder function.

155
00:10:48,770 --> 00:10:54,440
So right before that we need to wrap the second screen widget with the block provider, add value widget

156
00:10:54,530 --> 00:10:57,560
so that we provide a counter block instance further.

157
00:10:57,920 --> 00:11:03,200
Now please pay the most attention you possibly can because I'll be telling you some important information

158
00:11:03,200 --> 00:11:06,550
you'll definitely forget if you are paying much attention.

159
00:11:06,560 --> 00:11:10,050
There are two important steps you really need to pay attention to.

160
00:11:10,100 --> 00:11:16,250
Remember that I told you that the block provider that value widget takes in an existing instance of

161
00:11:16,250 --> 00:11:20,360
a block or cubitt and provided farther down the next screen widget tree.

162
00:11:20,630 --> 00:11:25,970
The existing instance will be passed right inside the value parameter from the block provider, that

163
00:11:25,970 --> 00:11:26,720
value widget.

164
00:11:26,810 --> 00:11:31,330
This is where most people, including me, make a huge mistake at first.

165
00:11:31,340 --> 00:11:36,580
The right block provider that value and they provide the value of counter cubitt.

166
00:11:36,590 --> 00:11:40,450
If you save this project now and run it, you'll see that everything works fine.

167
00:11:40,730 --> 00:11:41,990
The error is gone.

168
00:11:42,230 --> 00:11:44,870
All the functionality seems to be working smoothly now.

169
00:11:44,870 --> 00:11:49,730
Well, being on the home screen, let's increment a counter to five and then go to the second screen.

170
00:11:50,360 --> 00:11:53,180
You may notice that something isn't quite right.

171
00:11:53,180 --> 00:11:57,190
The counter is zero, but if we go back, the counter is still five.

172
00:11:57,320 --> 00:11:58,530
Why is this happening?

173
00:11:58,550 --> 00:12:02,000
Take a look at what we actually provided to the value parameter.

174
00:12:02,010 --> 00:12:04,330
A new instance of counter cubitt.

175
00:12:04,490 --> 00:12:06,650
What should have we provided instead?

176
00:12:06,720 --> 00:12:09,970
An existing instance of the counter cubitt.

177
00:12:09,980 --> 00:12:15,860
So what happens is that every time we push the second screen, we wrongly provide a new counter cubitt

178
00:12:15,860 --> 00:12:16,520
instance.

179
00:12:16,640 --> 00:12:22,580
This is really bad because not only the instance won't close automatically since it was not created

180
00:12:22,580 --> 00:12:28,280
by a block provider, but it will also have a completely different state than the existing instance

181
00:12:28,280 --> 00:12:29,210
from the home screen.

182
00:12:29,210 --> 00:12:36,160
And it will defeat the purpose of having one unique instance of the counter to beat around our app.

183
00:12:36,380 --> 00:12:41,150
What we should do instead is provide the existing instance of the counter cubitt to the second screen.

184
00:12:41,240 --> 00:12:47,870
If you remember back from the blockhouses view, we can access an existing instance of a cubitt or block

185
00:12:47,990 --> 00:12:53,380
by calling either block provider of Cubitt context or context that block cubitt.

186
00:12:53,540 --> 00:12:56,030
This was one of the two problems that may encounter.

187
00:12:56,030 --> 00:13:01,130
If you're not careful when you're providing blocks or qubits to new pages, let's say that this one

188
00:13:01,130 --> 00:13:05,630
can be avoided, but the next one is simply too easy to mess up.

189
00:13:05,630 --> 00:13:09,350
You may think that if you save and run the project now, everything will work.

190
00:13:09,620 --> 00:13:11,810
That's what I also thought multiple times.

191
00:13:11,810 --> 00:13:18,530
But surprise, you'll see the previous error popping up again, this time arising from the builder function

192
00:13:18,530 --> 00:13:21,590
inside the material page instead of the second stream.

193
00:13:21,860 --> 00:13:24,740
How could and flutter find the existing instance of the country?

194
00:13:24,740 --> 00:13:29,480
Cubitt in the context, we know for sure that's available inside the context of the home screen.

195
00:13:29,480 --> 00:13:34,790
But is the context from which we're searching for the counter cubitt the appropriate context?

196
00:13:34,790 --> 00:13:36,050
No, it's not.

197
00:13:36,140 --> 00:13:42,050
If you look closer, the context in which we're searching for the counter Cubitt is the new context.

198
00:13:42,050 --> 00:13:43,850
The second screen is being created.

199
00:13:44,240 --> 00:13:49,700
So instead of searching inside the homescreen context, we are wrongly searching inside the new context

200
00:13:49,700 --> 00:13:50,570
of the second screen.

201
00:13:50,630 --> 00:13:54,470
That's because we have the same name for both context.

202
00:13:54,480 --> 00:13:56,180
Imagine having to debug this.

203
00:13:56,480 --> 00:13:57,890
It would have been a nightmare.

204
00:13:58,070 --> 00:14:02,300
That's why I told you to pay as much attention to these two major issues that may arise.

205
00:14:02,390 --> 00:14:07,610
In order to fix this, we have to rename the second screen context, the new context, or maybe replace

206
00:14:07,610 --> 00:14:13,400
it with underscore since we won't use its value now, after we save and run the application, we can

207
00:14:13,400 --> 00:14:15,500
see that everything works as it should.

208
00:14:15,500 --> 00:14:21,200
We successfully provided the only instance of Counter Cubitt to the second screen's anonymous routt.

209
00:14:21,200 --> 00:14:25,970
If we're developing a small application with a few screens, this is how you can provide an instance

210
00:14:25,970 --> 00:14:31,640
of a block or cubitt through all of your anonymous screen routes one by one on multiple screens, though

211
00:14:31,640 --> 00:14:34,910
you may need to take a look at named or generated throughout access.

212
00:14:34,910 --> 00:14:36,980
And that's what we'll tackle up next.

213
00:14:36,980 --> 00:14:39,950
But first, let's create a third screen for the next topic.

214
00:14:40,100 --> 00:14:43,610
We'll duplicate some parts of the home screen again just to save some time.

215
00:14:43,770 --> 00:14:50,330
OK, so name Drought Access is basically referring to providing an existing instance of a block or cubitt

216
00:14:50,330 --> 00:14:53,210
to the screens while navigating with Nimrods.

217
00:14:53,210 --> 00:14:58,310
Since we're currently navigating with anonymous routes, we need to completely refactor the navigation

218
00:14:58,310 --> 00:14:59,600
part of our app in a.

219
00:14:59,860 --> 00:15:06,250
Application refactoring the navigation feature may take a huge amount of time, so that's why it's important

220
00:15:06,250 --> 00:15:11,470
to stick to navigating technique from the start, depending on how big your project it is going to be.

221
00:15:11,770 --> 00:15:17,160
We will list all of our routes inside the perimeter of our material app class.

222
00:15:17,170 --> 00:15:22,660
Any application should have a default home route which will be pushed in the first place when the application

223
00:15:22,660 --> 00:15:23,210
starts.

224
00:15:23,260 --> 00:15:30,820
This route must be named inside the routes list, since Slash is the universal sign for home in programming.

225
00:15:30,880 --> 00:15:32,290
Let's get to the coding part.

226
00:15:32,290 --> 00:15:37,360
Since it would be easier to explain what's going on, let's start refactoring the entire code in order

227
00:15:37,360 --> 00:15:39,220
to integrate name droughts.

228
00:15:39,220 --> 00:15:44,410
Since we have already created the screens, we need to decide which one is going to be the home road

229
00:15:44,650 --> 00:15:47,950
and then associate the rest of them with an alternate.

230
00:15:48,040 --> 00:15:54,090
As I told you, the material app class comes with a route's parameter, which takes in a map of pairs

231
00:15:54,420 --> 00:15:59,940
pairs which contain both the root name and the screen objects we want to assign them to.

232
00:16:00,010 --> 00:16:05,860
OK, so first and foremost, we need to set up our home front by routing its route name, which is slash

233
00:16:05,860 --> 00:16:10,570
and link it to the screen we want to launch when the route is pushed down the navigation stack.

234
00:16:10,570 --> 00:16:16,360
Since the screen we want to push is the home screen will write down a function taking the context as

235
00:16:16,360 --> 00:16:19,170
a parameter and returning the home screen.

236
00:16:19,210 --> 00:16:21,820
The same procedure applies for the rest of our screens.

237
00:16:21,880 --> 00:16:27,730
Let's name slash second the wrong name, referring to the second string and slash third the route referring

238
00:16:27,730 --> 00:16:28,590
to the third screen.

239
00:16:28,660 --> 00:16:33,730
Of course, in order to easily differentiate between them, I will set them different colors and titles

240
00:16:33,730 --> 00:16:38,710
so that a second screen has red X in color and the third screen has a green accent color.

241
00:16:38,860 --> 00:16:45,430
These are all our roots and screens will use inside our app since we have our roots attribute with an

242
00:16:45,430 --> 00:16:47,020
already defined home wrote.

243
00:16:47,140 --> 00:16:50,820
We can delete the home parameter since we won't need it any longer.

244
00:16:50,830 --> 00:16:56,500
Now for this name, not access topic, we're interested in how we can navigate by using name routes,

245
00:16:56,710 --> 00:17:03,780
but most importantly, how we can provide a unique instance of a block or cubitt across all of them.

246
00:17:03,790 --> 00:17:10,050
You might notice that right now we don't have any block provider widget wrapping any of our screens.

247
00:17:10,060 --> 00:17:11,040
Can you guess why?

248
00:17:11,319 --> 00:17:16,000
Well, if we had, we would have to provide a new instance of our country.

249
00:17:16,000 --> 00:17:17,819
Cubitt for every screen.

250
00:17:17,829 --> 00:17:20,829
Again, we definitely don't want this.

251
00:17:20,920 --> 00:17:26,560
We want to provide a unique instance of our countercoup cubitt across all of our screens.

252
00:17:26,890 --> 00:17:30,280
So this time will create the instance manually.

253
00:17:30,280 --> 00:17:36,040
Here at the top, we will prepare the name of the variable with an underscore to make the field only

254
00:17:36,040 --> 00:17:37,780
available inside this class.

255
00:17:37,900 --> 00:17:40,420
Note that we have a unique instance of Kountry.

256
00:17:40,420 --> 00:17:44,140
Cubitt can be provided with block provider across every screen.

257
00:17:44,150 --> 00:17:50,230
Well, yes, you could, but it's not really worth it, since the only advantage of using block provider

258
00:17:50,440 --> 00:17:57,640
is that it automatically closes the counter cubitt, but only when the counter cubitt is created inside

259
00:17:57,640 --> 00:17:59,140
the block provider itself.

260
00:17:59,170 --> 00:18:05,350
We created it at the top of our my app class, so using block provider would be nonsense.

261
00:18:05,380 --> 00:18:10,330
Then what should you use instead of taking my what I have already told you, when we want to provide

262
00:18:10,330 --> 00:18:17,200
an existing instance of a block or Cubitt, we will use block provider that value widget when we want

263
00:18:17,200 --> 00:18:21,550
to create and provide a block or cubitt in the same place.

264
00:18:21,940 --> 00:18:25,660
We should use the standalone broke provider widget here.

265
00:18:25,810 --> 00:18:32,350
We can create and provide the counter Kebede for every screen because that would lead us to having three

266
00:18:32,360 --> 00:18:34,390
different countercoup instances.

267
00:18:34,390 --> 00:18:41,920
I have told you multiple times that inside any app we should only have one unique working instance of

268
00:18:41,920 --> 00:18:43,240
a cubitt or block.

269
00:18:43,420 --> 00:18:48,310
So that's why we created only one here at the top, and that was it.

270
00:18:48,310 --> 00:18:54,760
Hence, we need to wrap all of the screens with a block provider that value widget, and provide them

271
00:18:54,760 --> 00:18:58,280
with our existing single instance of counter cubitt.

272
00:18:58,390 --> 00:19:03,730
Remember that block provided that value won't close the PROVIDEA block automatically, we will need

273
00:19:03,730 --> 00:19:06,160
to close it manually where we created it.

274
00:19:06,250 --> 00:19:10,600
More specifically, where the my app class gets this post.

275
00:19:10,600 --> 00:19:16,540
My app is a statelets widget which doesn't have a disposal method, so we'll have to convert it to a

276
00:19:16,540 --> 00:19:17,410
stateful widget.

277
00:19:17,410 --> 00:19:22,840
And then inside of this method we will need to call the closed function on our counter.

278
00:19:22,840 --> 00:19:24,400
Cubitt, we're almost done.

279
00:19:24,640 --> 00:19:30,730
All we need to do now is to modify the buttons from where we pushed our name roads into the navigation

280
00:19:30,730 --> 00:19:31,600
stack for that.

281
00:19:31,600 --> 00:19:36,940
Firstly, we need to visit the home screen from where we'll have two buttons, one navigating to the

282
00:19:36,940 --> 00:19:42,850
second screen and the other one navigating to the third screen in order to push a name brought down

283
00:19:42,850 --> 00:19:43,900
the navigation stack.

284
00:19:43,900 --> 00:19:51,070
We need to use the navigation that of context, not push named function and write the specific name

285
00:19:51,250 --> 00:19:52,480
as an argument.

286
00:19:52,570 --> 00:19:58,750
Now, if we run and save the project, we can see that everything is working perfectly as expected.

287
00:19:58,780 --> 00:19:59,710
The navigation feature.

288
00:19:59,780 --> 00:20:05,570
It's fully functional, the counter works flawlessly, and this is how we can provide a block or Kubi

289
00:20:05,580 --> 00:20:09,020
to multiple screens of your -- by using named routing.

290
00:20:09,110 --> 00:20:15,310
Now we can finally get to my favorite way to navigate seat flutter, which is by using generated routes.

291
00:20:15,560 --> 00:20:17,270
So what is generated routing?

292
00:20:17,270 --> 00:20:20,430
My top choice when it comes to navigating in flutter you mask?

293
00:20:20,720 --> 00:20:23,060
Well, mainly for two main reasons.

294
00:20:23,480 --> 00:20:29,030
One is that it mainly looks the same as the name routing, which means it borrows its advantages, thus

295
00:20:29,030 --> 00:20:31,040
being organized and properly structured.

296
00:20:31,070 --> 00:20:36,860
The second thing is that everything relates to the navigation cannot be separated into a single file.

297
00:20:36,920 --> 00:20:42,440
OK, since we're going to change the navigation feature again inside our app, we need to refactor the

298
00:20:42,440 --> 00:20:44,090
navigation part again.

299
00:20:44,120 --> 00:20:50,510
Will begin by creating a separate router folder inside the presentation layer since overall navigation

300
00:20:50,510 --> 00:20:52,010
is related to the UI.

301
00:20:52,070 --> 00:20:58,670
Inside the folder will create a file called App Underscore a router that dart in which will set up all

302
00:20:58,670 --> 00:21:01,680
the logic for navigating to all of our screens.

303
00:21:01,820 --> 00:21:07,100
The main idea here is that we want to create a function which takes in mainly the name of the route

304
00:21:07,100 --> 00:21:11,490
we want to generate and returns the generated screen accordingly.

305
00:21:11,540 --> 00:21:17,180
So we'll create a function called own generator result, which returns the type of route and this is

306
00:21:17,180 --> 00:21:19,850
going to accept a settings parameter inside.

307
00:21:19,850 --> 00:21:24,830
This function will create a switch statement which will contain our three root names.

308
00:21:24,830 --> 00:21:30,770
The own names can be accessed from inside the root setting parameter by calling settings that name.

309
00:21:30,770 --> 00:21:37,070
So we'll have three main cases, one for the home screen, one from the second screen, and finally

310
00:21:37,070 --> 00:21:38,510
one for the third screen.

311
00:21:38,510 --> 00:21:45,020
For each case, we will return a material page result which returns our specific screen inside its builder

312
00:21:45,020 --> 00:21:45,490
function.

313
00:21:45,500 --> 00:21:51,410
Since this is a switch statement, we also need to mention a default case, which will be called whenever

314
00:21:51,410 --> 00:21:55,340
one of the real names is not equal to any of the mentioned cases.

315
00:21:55,400 --> 00:22:02,630
OK, so again, we set up the navigation feature, but what we want now is to know how we can provide

316
00:22:02,630 --> 00:22:06,890
an existing instance of a block or Kubi to each of our screens.

317
00:22:06,890 --> 00:22:11,150
Creating a new instance for each screen is again not an option.

318
00:22:11,200 --> 00:22:17,270
So instead we will create the unique tumed instance right at the top, as we did with the name routing.

319
00:22:17,270 --> 00:22:22,670
Then, since we need to provide the existing instance of Cubitt we created to all of our screens, we

320
00:22:22,670 --> 00:22:26,810
need to wrap them inside a block, provide that value widget again.

321
00:22:26,960 --> 00:22:31,430
Since we created the Cubitt manually will also need to manually close.

322
00:22:31,430 --> 00:22:36,320
It will do this by creating a display function in which will close the cubitt.

323
00:22:36,470 --> 00:22:38,360
We're close to finishing the scenario.

324
00:22:38,660 --> 00:22:43,160
Our approach to class is really to manage the navigation feature of our app.

325
00:22:43,160 --> 00:22:49,580
But now we need to go inside the main Dadda file and in the material app we can delete the parameter

326
00:22:49,580 --> 00:22:52,550
completely since we don't need it anymore.

327
00:22:52,550 --> 00:22:59,300
Instead, we'll use the own generator parameter, which takes in our own generator function from inside

328
00:22:59,300 --> 00:23:00,740
our operator class.

329
00:23:00,770 --> 00:23:06,460
So first of all, we need to create an approach, for instance, at the top and then pass the on generator

330
00:23:06,650 --> 00:23:10,130
function of it to the own generator parameter.

331
00:23:10,140 --> 00:23:16,470
Pay attention because we need to pass the function as an argument and not as a result of it.

332
00:23:16,580 --> 00:23:22,880
Finally, inside of this function will close the counter cubitt by calling app router that disposer.

333
00:23:23,000 --> 00:23:27,100
I want you now to observe how organized everything is.

334
00:23:27,110 --> 00:23:33,230
Every feature is placed in its own folder and is structured nicely and easy to read and understand.

335
00:23:33,800 --> 00:23:38,180
If you run the project now, you can see that everything is working as expected.

336
00:23:38,840 --> 00:23:41,540
Now think of this fact for a moment.

337
00:23:41,960 --> 00:23:46,130
Inside your application, you'll definitely have multiple blocks and Cubitt.

338
00:23:46,490 --> 00:23:52,400
Each one of them will have their own functionality and will work on a specific screen or part of your

339
00:23:52,400 --> 00:23:52,720
app.

340
00:23:52,730 --> 00:24:00,140
Now you know how to provide our block instances locally and specifically to each of your multiple screens.

341
00:24:00,140 --> 00:24:05,690
But what happens if you have one hundred screens and you want to provide a block to all of your screens,

342
00:24:05,720 --> 00:24:08,150
will you have to provide it one by one?

343
00:24:08,190 --> 00:24:10,760
Think a little bit about an altercation block.

344
00:24:10,970 --> 00:24:16,280
You need to know the state of it around the entire app, not only inside the login or logout page.

345
00:24:16,280 --> 00:24:16,720
Why?

346
00:24:16,880 --> 00:24:19,820
Well, what if the authentication session expires?

347
00:24:19,820 --> 00:24:23,840
You will want to keep the authenticate user out of whatever the screen he's browsing at.

348
00:24:23,840 --> 00:24:26,840
The moments right in this case will need global access.

349
00:24:27,050 --> 00:24:32,480
But how can we provide a single instance of a cubitt or block to all of our screens?

350
00:24:32,670 --> 00:24:38,300
You wouldn't believe this, but if you wrap the material app inside the block provider or even inside

351
00:24:38,300 --> 00:24:44,720
the multiple provider, every block or cubitt you provider will be globally available inside every screen

352
00:24:44,720 --> 00:24:45,420
of your app.

353
00:24:45,560 --> 00:24:51,320
What it is possible is beyond the purpose of this video, but it will be addressed in detail in future

354
00:24:51,320 --> 00:24:51,950
tutorials.

355
00:24:51,950 --> 00:24:53,680
Let's tackle up the coding part.

356
00:24:54,140 --> 00:24:59,000
So right now we're manually providing an existing counter QB to all of our screens.

357
00:24:59,000 --> 00:24:59,330
One.

358
00:24:59,400 --> 00:25:06,420
Buy one because we need it in all our streets, but what we can do instead is provided globally, as

359
00:25:06,420 --> 00:25:07,010
we discussed.

360
00:25:07,020 --> 00:25:09,920
Let's refactor the code for the last time in this tutorial.

361
00:25:09,930 --> 00:25:12,210
We don't need this instance anymore here.

362
00:25:12,210 --> 00:25:14,600
And none of the block provided that value widgets.

363
00:25:14,610 --> 00:25:19,290
We can also delete the dispose function since will create the instance of the block inside the block

364
00:25:19,290 --> 00:25:19,850
provider.

365
00:25:20,250 --> 00:25:25,950
Therefore, the block provider will automatically close it then my app class does need to be a stateful

366
00:25:25,950 --> 00:25:29,260
widget anymore, so we convert it back to a statelets widget.

367
00:25:29,340 --> 00:25:34,890
All we need to do now is to wrap the material up inside the block provider and create the only instance

368
00:25:34,890 --> 00:25:39,090
of the counter cumi to be provided globally to all of our screens.

369
00:25:39,290 --> 00:25:44,790
As you can see, if you save the project and right right now everything will work as previously, but

370
00:25:44,790 --> 00:25:50,880
this time having the counter to be provided globally accessible from every screen inside the app.

371
00:25:51,030 --> 00:25:55,680
OK, I know it's been a long tutorial for you guys and I hope I didn't lose you on the way here.

372
00:25:55,710 --> 00:26:00,300
There is some important information you need to have in your mind before you leave the tutorial.

373
00:26:00,300 --> 00:26:03,960
I recommend you to watch it multiple times and practice as much as you can.

374
00:26:03,990 --> 00:26:08,090
Here goes a list of what you need to briefly understand as you watch this tutorial.

375
00:26:08,130 --> 00:26:15,270
So by default, you can navigate in many ways inside flutter by using anonymous routing, named routing

376
00:26:15,270 --> 00:26:16,550
and generated routing.

377
00:26:16,560 --> 00:26:22,650
Remember that the key here is to provide a unique instance of a block or cubitt to one or multiple screens.

378
00:26:23,070 --> 00:26:28,400
You shouldn't create multiple instances of the same block because that might cause unexpected behavior.

379
00:26:28,500 --> 00:26:35,310
Take in mind that block provider creates and provides a new instance of a cubitt or block.

380
00:26:35,550 --> 00:26:42,900
On the other hand block provider that value takes on already created instance of a block or covid and

381
00:26:42,900 --> 00:26:44,820
then provided far more.

382
00:26:44,820 --> 00:26:46,980
Depending on the navigation where you chose.

383
00:26:46,980 --> 00:26:52,350
You can provide your block or cubitt instances the following ways locally when you want to provide the

384
00:26:52,350 --> 00:26:57,750
instance to a single screen, specifically when you want to provide the instance specifically across

385
00:26:57,750 --> 00:27:04,230
one or multiple screens and globally, when you want to provide the instance across all of your screens,

386
00:27:04,530 --> 00:27:10,260
remember to always double check in which context you're searching for an existing instance of the block

387
00:27:10,260 --> 00:27:13,590
or Cubitt, because that can also cause a lot of problems.

388
00:27:13,920 --> 00:27:14,480
Wow.

389
00:27:14,490 --> 00:27:17,490
We have finally arrived at the end of the six chapter.

390
00:27:17,490 --> 00:27:19,260
I hope I didn't lose you along the way.

391
00:27:19,290 --> 00:27:25,470
I admit it was a long and difficult one, so please feel free to watch it as many times as you want.

392
00:27:25,500 --> 00:27:31,620
However, in the next chapter will relax a little bit and talk about how two or more cubits or books

393
00:27:31,620 --> 00:27:33,850
communicate well with other ones.

394
00:27:33,870 --> 00:27:35,220
We'll definitely like this one.

395
00:27:35,220 --> 00:27:39,480
With that being said, I'm looking forward to seeing each and every one of you in the next chapter.

396
00:27:39,510 --> 00:27:41,160
Stay tuned and let's get with it.

