WEBVTT
1
00:00:00.180 --> 00:00:01.920
Hey, what is going on, everyone?

2
00:00:02.260 --> 00:00:08.140
Let me wish you a huge and warm welcome to the first chapter of this amazing flutter, of course.

3
00:00:08.400 --> 00:00:14.790
Today, I'll be guiding you throughout an introduction en bloc, explaining why I chose Bloch as my

4
00:00:14.790 --> 00:00:20.280
favorite state management library and design better going to the main aspects of it.

5
00:00:20.340 --> 00:00:27.180
And hopefully at the end of the video, you'll have yourself some good reference on why it's an amazing

6
00:00:27.180 --> 00:00:31.690
idea to start a news blog on every project from now on.

7
00:00:31.860 --> 00:00:34.660
So without further ado, let's get right into it.

8
00:00:34.680 --> 00:00:37.340
But first of all, let me ask you a question.

9
00:00:37.500 --> 00:00:43.080
Have you ever had installed an application which started to crash for no reason while using it, an

10
00:00:43.080 --> 00:00:49.230
app perhaps that after you click the button in order to load some data free for three or four seconds

11
00:00:49.230 --> 00:00:55.950
without displaying absolutely any message into the UI or maybe an app which only works with Internet

12
00:00:55.950 --> 00:01:00.030
connection but goes haywire if there is no one available.

13
00:01:00.240 --> 00:01:05.250
I'm assuming that at least for some of you, the answer will be definitely yes.

14
00:01:05.550 --> 00:01:13.560
Then you will know how frustrating it is for a user to not receive a visual representation for any interaction

15
00:01:13.560 --> 00:01:14.820
with the application.

16
00:01:15.030 --> 00:01:21.270
The main problem here is that the code is not clear, organized, maintainable nor testable.

17
00:01:21.720 --> 00:01:28.500
Developers of these apps are thinking about what works for the moment instead of reflecting what would

18
00:01:28.500 --> 00:01:31.460
work in maintaining the app in the long run.

19
00:01:31.680 --> 00:01:37.830
The main idea in programming is that you and your team need to write code using an architecture which

20
00:01:37.830 --> 00:01:44.340
feature the best architecture which can accommodate every feature and scale over time.

21
00:01:44.640 --> 00:01:46.380
Now let me give you a quick story.

22
00:01:46.560 --> 00:01:52.110
In my first weeks of learning flutter and dart from some tutorials online, I wanted to give you a try

23
00:01:52.110 --> 00:01:54.780
and build my own first app by myself.

24
00:01:55.320 --> 00:02:02.100
But eventually, after a couple of days of coding, I was struck by the feeling that I cannot maintain

25
00:02:02.100 --> 00:02:07.410
the code anymore due to the fact that all of it was spread throughout the app randomly.

26
00:02:07.710 --> 00:02:11.760
So there was the moment when I learned the most important lesson.

27
00:02:12.150 --> 00:02:18.720
I have started to look for a way to organize and structure the ideas and features in my code in order

28
00:02:18.720 --> 00:02:24.520
to build an application that will be maintainable and scalable over time in Flutter.

29
00:02:24.540 --> 00:02:31.680
The best way to keep your code organized, clean and maintainable is to have a component which can mediate

30
00:02:31.980 --> 00:02:40.180
what the user sees often referred to as UI front end or presentation and the logic behind it.

31
00:02:40.320 --> 00:02:47.250
This component I'm referring to is, as you may have already guessed, Block, which is an abbreviation

32
00:02:47.370 --> 00:02:50.700
for business logic component.

33
00:02:50.910 --> 00:02:57.060
Generally speaking, Block is a design pattern created by Google to help separate business logic from

34
00:02:57.060 --> 00:03:01.720
the presentation layer and enable developers to reuse code more easily.

35
00:03:01.980 --> 00:03:08.670
There is a state management library created and maintained by Felix Angelov called Block, which helps

36
00:03:08.670 --> 00:03:13.530
developers implement the block design pattern in their flutter applications.

37
00:03:13.590 --> 00:03:15.120
What does this mean actually?

38
00:03:15.390 --> 00:03:22.540
Well, as developers, it's really necessary to know what the state of our app is at any time.

39
00:03:22.590 --> 00:03:27.840
Remember when I said that for every interaction with the app, there should be something displayed on

40
00:03:27.840 --> 00:03:30.660
the screen to let the user know what's going on?

41
00:03:30.870 --> 00:03:37.160
Technically, for every interaction, the application should be in a different state.

42
00:03:37.350 --> 00:03:43.530
For example, when the data is fetching, the app should be in a loading stage displaying a loading

43
00:03:43.530 --> 00:03:44.870
animation on the screen.

44
00:03:44.880 --> 00:03:51.210
When the Internet is off, the application should display a pop up to let the user know that there is

45
00:03:51.210 --> 00:03:52.620
no Internet connection.

46
00:03:52.680 --> 00:03:58.820
This is good app design, thinking of every possible case and having a state emerging from it.

47
00:03:58.860 --> 00:04:04.890
So not only does the Block library separate presentation from business logic, it also simplifies the

48
00:04:04.890 --> 00:04:07.610
way we manage the state of the application.

49
00:04:07.860 --> 00:04:14.490
So after all, by learning block and using the Block library, you'll have the following huge advantages

50
00:04:14.490 --> 00:04:18.480
which will lead you and your team to be better developers.

51
00:04:18.480 --> 00:04:24.780
Block will allow you to have a better understanding of what's happening inside your own app, thus making

52
00:04:24.780 --> 00:04:28.860
it more organized, structured and easier to test and maintain.

53
00:04:28.890 --> 00:04:35.190
There won't be a moment in which you won't know what the state of your app is because of the way block

54
00:04:35.190 --> 00:04:35.670
is built.

55
00:04:35.670 --> 00:04:42.030
For every user interaction, there will be an emerging state making the whole state management issue

56
00:04:42.090 --> 00:04:47.700
simple to overcome and all within a single, stable and powerful block code base.

57
00:04:47.700 --> 00:04:53.880
In the next chapter will start taking a look at every block concepts like streams, blocks and cubits,

58
00:04:54.150 --> 00:04:59.240
while also discussing the difference between them is going to be a really, really important one.

59
00:04:59.250 --> 00:04:59.580
So maybe.

60
00:04:59.880 --> 00:05:04.830
You want to keep it with that being said, I'm looking forward to seeing each and every one of you up

61
00:05:04.830 --> 00:05:05.230
next.

62
00:05:05.490 --> 00:05:07.620
Stay tuned and let us get wicked.

