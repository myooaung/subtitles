1
00:00:02,240 --> 00:00:06,040
[Autogenerated] So now that we've seen how to build our database schemers,

2
00:00:06,040 --> 00:00:09,740
we now need to understand how to access the data in the database.

3
00:00:09,740 --> 00:00:14,550
To do this, we can use a mechanism called spring data repositories.

4
00:00:14,550 --> 00:00:16,640
So what are these things?

5
00:00:16,640 --> 00:00:17,790
As we see on the slide?

6
00:00:17,790 --> 00:00:22,040
It's an abstraction that provides access to different data stores,

7
00:00:22,040 --> 00:00:24,700
which is not just about SQL we can.

8
00:00:24,700 --> 00:00:28,840
Use this with no SQL stores, for example, it's interface based.

9
00:00:28,840 --> 00:00:31,850
So for each interface, spring generates a proxy,

10
00:00:31,850 --> 00:00:34,630
and that proxy contains functionality based on the

11
00:00:34,630 --> 00:00:37,240
names of the methods in the interface.

12
00:00:37,240 --> 00:00:41,080
So basically, it looks at the interface looks at the method names on then,

13
00:00:41,080 --> 00:00:46,340
based on those method names, generates code that will do what those methods say.

14
00:00:46,340 --> 00:00:50,340
So, for example, I've gotta find articles by title.

15
00:00:50,340 --> 00:00:52,930
It will gender the SQL that we're reaching to the articles

16
00:00:52,930 --> 00:00:56,290
table on pull out an article based on the title that I pass

17
00:00:56,290 --> 00:00:59,940
to it Repositories are extensible.

18
00:00:59,940 --> 00:01:03,080
We're going to use them in a fairly simple way here just

19
00:01:03,080 --> 00:01:05,590
to give you an idea of exactly how these things are used

20
00:01:05,590 --> 00:01:08,940
on where they should be used.

21
00:01:08,940 --> 00:01:13,740
So the way we do this is we define our interface called something repository.

22
00:01:13,740 --> 00:01:18,280
In our case, we can have an article repository and in this example,

23
00:01:18,280 --> 00:01:22,440
here we see it extending a based interface called Repository.

24
00:01:22,440 --> 00:01:25,180
We're basing this on an entity called article on.

25
00:01:25,180 --> 00:01:27,940
We'll see what essentially looks like in a moment and a long.

26
00:01:27,940 --> 00:01:30,940
This is the primary key for the table.

27
00:01:30,940 --> 00:01:35,650
We saw that when we created the article to previously we indeed set upon ID

28
00:01:35,650 --> 00:01:46,140
column on that ID column was a long value on that was set as the primary key

29
00:01:46,140 --> 00:01:49,940
well and repository code to a repository project.

30
00:01:49,940 --> 00:01:51,450
To do that inside here.

31
00:01:51,450 --> 00:01:55,540
The first thing I want to do is to create two packages.

32
00:01:55,540 --> 00:02:01,740
So a lot of package we'll have one called com Pluralsight jacket data models.

33
00:02:01,740 --> 00:02:07,140
We'll have one called com Pluralsight jacket Data repository.

34
00:02:07,140 --> 00:02:11,640
The data Models package will contain the entities for the database.

35
00:02:11,640 --> 00:02:15,540
And a repository package will obviously contain the repository code.

36
00:02:15,540 --> 00:02:17,970
So the first model we're going to have if I had a new class

37
00:02:17,970 --> 00:02:21,040
to this is going to be called article.

38
00:02:21,040 --> 00:02:24,610
This article class will contain the fields that will map

39
00:02:24,610 --> 00:02:27,440
onto the columns in the articles table.

40
00:02:27,440 --> 00:02:33,140
You've got the title field and URL field on the other fields that we need.

41
00:02:33,140 --> 00:02:35,740
We need to tell it that it's an entity.

42
00:02:35,740 --> 00:02:38,800
We used the entity annotation for this on.

43
00:02:38,800 --> 00:02:42,740
We're going to tell it also that the table name is articles.

44
00:02:42,740 --> 00:02:45,830
So I'm sort of following a similar convention again that the Ruby folks

45
00:02:45,830 --> 00:02:49,250
use whereby table names of Pluralsight and entity names.

46
00:02:49,250 --> 00:02:53,820
A singular so select article from articles seems to make sense to me.

47
00:02:53,820 --> 00:02:54,370
It's the table.

48
00:02:54,370 --> 00:02:55,410
Name is articles.

49
00:02:55,410 --> 00:02:58,540
Our entity name is article.

50
00:02:58,540 --> 00:02:59,470
Now notice in here.

51
00:02:59,470 --> 00:03:02,540
I don't have an IDE value for this class.

52
00:03:02,540 --> 00:03:07,540
Well, im going to have is all of my entities extending a class called base model.

53
00:03:07,540 --> 00:03:12,170
My base model class is the one that will contain things that all my models need,

54
00:03:12,170 --> 00:03:14,440
such as an ID.

55
00:03:14,440 --> 00:03:17,510
So if I generate, that class is going to go into my model's name.

56
00:03:17,510 --> 00:03:20,840
Space on that class is gonna look like this.

57
00:03:20,840 --> 00:03:22,240
It has an IDE.

58
00:03:22,240 --> 00:03:25,540
I'm telling you that the IDE is a generally feels that this is an

59
00:03:25,540 --> 00:03:30,340
identity field inside my SQL and it's a long value.

60
00:03:30,340 --> 00:03:34,440
Remember that the repository is going to use a long for its IDE.

61
00:03:34,440 --> 00:03:35,850
We have a get ID method.

62
00:03:35,850 --> 00:03:40,840
There's also an equals method and a hash code method as part of this class.

63
00:03:40,840 --> 00:03:44,030
If I save both of these than all this code now compiles and

64
00:03:44,030 --> 00:03:47,340
there's no errors or warnings anywhere in the code,

65
00:03:47,340 --> 00:03:49,000
So these will be our entities.

66
00:03:49,000 --> 00:03:55,240
Now that we have these we can go on and design a repository to do this,

67
00:03:55,240 --> 00:04:00,510
I'll first added interface called articles repository to repository package and

68
00:04:00,510 --> 00:04:04,740
in this interface will extend the base repository interface.

69
00:04:04,740 --> 00:04:07,440
I'm making sure I bring in the right name spaces.

70
00:04:07,440 --> 00:04:10,890
So if I look at the repository interface, I'm extending here, we'll see.

71
00:04:10,890 --> 00:04:13,840
This is an interface of tighty and ID.

72
00:04:13,840 --> 00:04:17,460
ID is gonna be something like long Orent or whatever.

73
00:04:17,460 --> 00:04:23,040
Our primary key type er's then tea is a type of the repository holes.

74
00:04:23,040 --> 00:04:25,040
So article in our case.

75
00:04:25,040 --> 00:04:27,340
So it's just a market interface.

76
00:04:27,340 --> 00:04:29,920
I noticed that are no defined methods on here,

77
00:04:29,920 --> 00:04:32,950
So any work we want to do with this repository we have to

78
00:04:32,950 --> 00:04:35,640
do by adding methods to our interface.

79
00:04:35,640 --> 00:04:39,100
If we do that, spring will generate a proxy for us.

80
00:04:39,100 --> 00:04:40,950
Based on those method names.

81
00:04:40,950 --> 00:04:41,610
However,

82
00:04:41,610 --> 00:04:44,960
we can choose other base classes that we already contain

83
00:04:44,960 --> 00:04:47,840
method names that we might want to use,

84
00:04:47,840 --> 00:04:50,240
so let's take a look at one of those first.

85
00:04:50,240 --> 00:04:53,540
So the first these repositories and a one will make use

86
00:04:53,540 --> 00:04:56,140
of here is called Cried Repository.

87
00:04:56,140 --> 00:04:58,190
You can imagine with credit repository.

88
00:04:58,190 --> 00:05:02,940
It has methods such as create, read, update and delete for us.

89
00:05:02,940 --> 00:05:06,640
So let's take a look at how we can use that in our code.

90
00:05:06,640 --> 00:05:11,340
So to use the crowd repository ID, simply say credit repository here,

91
00:05:11,340 --> 00:05:12,970
updating the packages on.

92
00:05:12,970 --> 00:05:13,150
Then,

93
00:05:13,150 --> 00:05:16,360
if I browse the crowd repository type will see the crowd

94
00:05:16,360 --> 00:05:20,240
repository as various methods already defined on it.

95
00:05:20,240 --> 00:05:23,140
There's a save method that saves a single entity.

96
00:05:23,140 --> 00:05:26,840
There's a safe method that saves a collection of entities because they find by

97
00:05:26,840 --> 00:05:31,640
IDE method on exist by IDE method of final method and so on.

98
00:05:31,640 --> 00:05:36,740
So just useful methods that we could use this part of our already valid code,

99
00:05:36,740 --> 00:05:39,840
which means that just by using crude repository on extending,

100
00:05:39,840 --> 00:05:49,000
it will get a proxy that will implement those methods for us. We could then use those within the application, so let's see how we do that now

