WEBVTT
1
00:00:00.840 --> 00:00:04.080
[Autogenerated] So for our integration testing in spring,

2
00:00:04.080 --> 00:00:06.590
there is some things we have to configure.

3
00:00:06.590 --> 00:00:09.740
There are some ways that spring is going to help us.

4
00:00:09.740 --> 00:00:12.240
So when we talk about integration testing here,

5
00:00:12.240 --> 00:00:16.520
what we mean is that when I hit my article service say that service

6
00:00:16.520 --> 00:00:21.090
uses the real repository class that real repository implementation

7
00:00:21.090 --> 00:00:23.930
hits some real database and a database.

8
00:00:23.930 --> 00:00:26.390
We're going thead probably isn't gonna be our database the

9
00:00:26.390 --> 00:00:29.400
one we use in day to day work with this application because

10
00:00:29.400 --> 00:00:31.240
that's going to be too volatile.

11
00:00:31.240 --> 00:00:33.410
It could be in memory database, for example.

12
00:00:33.410 --> 00:00:36.860
That would speed the tests up, although with in memory databases,

13
00:00:36.860 --> 00:00:39.240
you didn't think about the benefits and the tradeoffs,

14
00:00:39.240 --> 00:00:42.040
the benefits are your testing will be much quicker.

15
00:00:42.040 --> 00:00:44.850
The trade offs are you're not testing against the same

16
00:00:44.850 --> 00:00:47.640
database you'd use for production.

17
00:00:47.640 --> 00:00:49.480
However, whichever type we use,

18
00:00:49.480 --> 00:00:53.540
we still need to configure the database we're going to use.

19
00:00:53.540 --> 00:00:55.770
So in our spring configuration,

20
00:00:55.770 --> 00:00:59.840
we like a new data source we can mark this data source with a profile.

21
00:00:59.840 --> 00:01:02.650
So we're saying here that this data source should only be

22
00:01:02.650 --> 00:01:06.340
configured for testing when we see exactly what the code behind

23
00:01:06.340 --> 00:01:08.540
the data source looks like in a moment.

24
00:01:08.540 --> 00:01:12.000
The key thing here is we can use spring profiles to

25
00:01:12.000 --> 00:01:14.430
differentiate between different environments.

26
00:01:14.430 --> 00:01:16.310
Are we running in a testing environment,

27
00:01:16.310 --> 00:01:21.440
or are we running in a production environment or death environment?

28
00:01:21.440 --> 00:01:24.840
We can also configure our testing environment in other ways.

29
00:01:24.840 --> 00:01:28.940
So here we're saying that we want these tests to be transactional.

30
00:01:28.940 --> 00:01:31.640
We're going to use this spring JUnit classroom,

31
00:01:31.640 --> 00:01:34.580
and that's going to do things like setting up our dependency injection for us.

32
00:01:34.580 --> 00:01:35.940
For example,

33
00:01:35.940 --> 00:01:40.420
we're also saying again that this configuration code is for the test profile.

34
00:01:40.420 --> 00:01:45.440
So only use this when running inside tests.

35
00:01:45.440 --> 00:01:48.040
So something else that's of interest here is this.

36
00:01:48.040 --> 00:01:49.870
So when I run my integration tests,

37
00:01:49.870 --> 00:01:52.390
I want to make sure that my database is an unknown

38
00:01:52.390 --> 00:01:54.940
state at the start of the test.

39
00:01:54.940 --> 00:01:58.020
So what we can due in spring is we can Add this at SQL

40
00:01:58.020 --> 00:02:01.050
annotation we can use the sanitation to executes.

41
00:02:01.050 --> 00:02:02.540
Um, SQL.

42
00:02:02.540 --> 00:02:06.890
What we're saying here is execute this insert data dot SQL file and as you

43
00:02:06.890 --> 00:02:11.000
can guess from the name that will contain SQL statements to insert data into

44
00:02:11.000 --> 00:02:16.750
our test database that we contest against Also,

45
00:02:16.750 --> 00:02:20.440
we'd like to make sure that this database is clean after the test.

46
00:02:20.440 --> 00:02:22.350
So you have another SQL statement here.

47
00:02:22.350 --> 00:02:25.140
This one is using a script called Cleanup SQL.

48
00:02:25.140 --> 00:02:29.440
But notice the execution phase here is after test method.

49
00:02:29.440 --> 00:02:30.920
After we finish the test,

50
00:02:30.920 --> 00:02:34.590
we'd run the script and I will tear down our database again in this case,

51
00:02:34.590 --> 00:02:37.440
what it will do whatever the script is set up to do.

52
00:02:37.440 --> 00:02:38.600
As I said in our case,

53
00:02:38.600 --> 00:02:43.640
we create the database and tear it down after each test again,

54
00:02:43.640 --> 00:02:48.040
just to emphasize the profile we're running this under is the test profile.

55
00:02:48.040 --> 00:02:53.140
This configuration only executes when we're using the test profile.

56
00:02:53.140 --> 00:02:55.580
So let's bring all this together and see how we set up

57
00:02:55.580 --> 00:02:59.040
integration tests inside spring.

58
00:02:59.040 --> 00:03:04.090
So what we're going to concentrate on here is how we configure these tests.

59
00:03:04.090 --> 00:03:06.210
And then once we have the configuration in place,

60
00:03:06.210 --> 00:03:09.140
we'll see some examples of how to run them.

61
00:03:09.140 --> 00:03:12.130
So what we do is we create an abstract class that's

62
00:03:12.130 --> 00:03:14.740
got to manage most of our configuration.

63
00:03:14.740 --> 00:03:17.880
I've created this class in my jacket entities project,

64
00:03:17.880 --> 00:03:21.200
as most of the things we're going to test will involve database access,

65
00:03:21.200 --> 00:03:24.650
mostly integration tests So it seems sensible to have this

66
00:03:24.650 --> 00:03:28.320
abstraction in one place that other configuration for

67
00:03:28.320 --> 00:03:31.340
specific projects can then derive from.

68
00:03:31.340 --> 00:03:35.090
So this is my abstract test class on inside here we mark

69
00:03:35.090 --> 00:03:38.340
this with a spring JUnit class runner.

70
00:03:38.340 --> 00:03:42.060
We turned where together configuration from This is also

71
00:03:42.060 --> 00:03:44.440
the place where we are our SQL scripts.

72
00:03:44.440 --> 00:03:47.640
Also, we say this is only active during testing.

73
00:03:47.640 --> 00:03:53.640
So this is active when I run my test when the test profile is set.

74
00:03:53.640 --> 00:03:56.530
If I look at this application configuration class that's also

75
00:03:56.530 --> 00:04:00.480
mentioned here since this application configuration class is used

76
00:04:00.480 --> 00:04:05.340
to configure my application we can use, this is part of our test configuration.

77
00:04:05.340 --> 00:04:08.180
The key thing here is that I add a data source that

78
00:04:08.180 --> 00:04:10.730
used for testing on this data source.

79
00:04:10.730 --> 00:04:12.650
I'm pointing at a different database.

80
00:04:12.650 --> 00:04:15.920
I'm pointing to something like jacket D B test database.

81
00:04:15.920 --> 00:04:21.210
Not my jacket db database Still set username still set a password.

82
00:04:21.210 --> 00:04:22.170
Probably not a secret.

83
00:04:22.170 --> 00:04:25.560
In this case, which find to have these things in code again,

84
00:04:25.560 --> 00:04:28.540
notice remark this with the test profile.

85
00:04:28.540 --> 00:04:32.540
So I say I'm only going to use this during my test code.

86
00:04:32.540 --> 00:04:35.320
So this application configuration class is defined

87
00:04:35.320 --> 00:04:38.940
inside jacket tests entities as well.

88
00:04:38.940 --> 00:04:44.340
Now it's jacket articles where we're going to run the test from so I look,

89
00:04:44.340 --> 00:04:46.540
first of all in jacket articles,

90
00:04:46.540 --> 00:04:51.640
look at source integration test java In here we have a articles configuration.

91
00:04:51.640 --> 00:04:52.600
Job it on.

92
00:04:52.600 --> 00:04:55.640
That just extends application configuration.

93
00:04:55.640 --> 00:04:57.110
Don't worry about the red here.

94
00:04:57.110 --> 00:04:59.360
That's happening because idea it doesn't recognize the

95
00:04:59.360 --> 00:05:03.140
base class correctly with code compiles.

96
00:05:03.140 --> 00:05:07.260
So that means here I could add any extra configuration I needed to.

97
00:05:07.260 --> 00:05:08.620
I don't have any extra.

98
00:05:08.620 --> 00:05:11.180
I don't have any extra configuration in this case,

99
00:05:11.180 --> 00:05:15.440
but we could put that year if necessary.

100
00:05:15.440 --> 00:05:15.670
And a.

101
00:05:15.670 --> 00:05:19.040
Finally, there's the article service test class.

102
00:05:19.040 --> 00:05:23.540
This article service test class is the thing that derives from abstract test.

103
00:05:23.540 --> 00:05:26.080
So this picks up all the configuration information.

104
00:05:26.080 --> 00:05:29.870
All of the information from abstract test abstract test,

105
00:05:29.870 --> 00:05:33.790
Remember tells us that you're running with spring JUnit and also

106
00:05:33.790 --> 00:05:36.760
is the place where we set the profile on where we set the scripts

107
00:05:36.760 --> 00:05:41.830
were going to use for inserting data for cleaning up data inside

108
00:05:41.830 --> 00:05:43.200
the article test class.

109
00:05:43.200 --> 00:05:46.840
This is where we'll run the actual tests.

110
00:05:46.840 --> 00:05:48.350
Now, Before we do that,

111
00:05:48.350 --> 00:05:51.340
let's take a look at the SQL and see what's in the SQL code.

112
00:05:51.340 --> 00:05:54.220
That's going to insert SQL in the database and clean up

113
00:05:54.220 --> 00:05:56.940
the database when we finished with it.

114
00:05:56.940 --> 00:05:59.350
So if I go back to my abstract test class,

115
00:05:59.350 --> 00:06:01.810
we noticed that the at SQL statement,

116
00:06:01.810 --> 00:06:05.120
especially as a path essentially so it says slash

117
00:06:05.120 --> 00:06:07.560
insert data SQL on slash cleanup.

118
00:06:07.560 --> 00:06:11.040
SQL This is relative to my class path,

119
00:06:11.040 --> 00:06:15.040
and so he placed these secret files inside My resource is folder,

120
00:06:15.040 --> 00:06:19.370
so then included inside the jar file and then the SQL attributes can do.

121
00:06:19.370 --> 00:06:22.840
Read the data from that jar falsy.

122
00:06:22.840 --> 00:06:26.740
So this is in the jacket Entities project, and it's source integration.

123
00:06:26.740 --> 00:06:30.550
Test Resource is so down here, there's the cleanup SQL on.

124
00:06:30.550 --> 00:06:31.640
There's these insert data.

125
00:06:31.640 --> 00:06:34.540
SQL.

126
00:06:34.540 --> 00:06:36.830
If I look at the insert data, first of all,

127
00:06:36.830 --> 00:06:40.240
then not just inserts some data into my database,

128
00:06:40.240 --> 00:06:45.800
so it's inserting in the jacket db test The articles URL a title on Cem,

129
00:06:45.800 --> 00:06:48.940
finally, data that makes up the image.

130
00:06:48.940 --> 00:06:51.350
It's not a full image that would be too large to include.

131
00:06:51.350 --> 00:06:53.940
It's a small image that we can use.

132
00:06:53.940 --> 00:06:55.690
So every time you run a test,

133
00:06:55.690 --> 00:07:00.810
the script runs on inserts these rows into my test database The

134
00:07:00.810 --> 00:07:05.640
cleanup SQL just truncate the database and a reason I used truncate

135
00:07:05.640 --> 00:07:08.370
that I want to reset my keys in the database,

136
00:07:08.370 --> 00:07:10.740
reset the primary key values.

137
00:07:10.740 --> 00:07:14.040
So we're just cleaning up the database completely when the test finishes.

138
00:07:14.040 --> 00:07:18.140
We can rerun the test from a completely clean state the next time.

139
00:07:18.140 --> 00:07:22.240
So there's one last thing you have to think about before we run these tests.

140
00:07:22.240 --> 00:07:24.640
And that's what to do with the migrations.

141
00:07:24.640 --> 00:07:29.100
We've already seen that we're using migrations to migrate our main database,

142
00:07:29.100 --> 00:07:31.340
our production database if you like,

143
00:07:31.340 --> 00:07:34.730
we'd like to use the same migration system for our test database.

144
00:07:34.730 --> 00:07:39.100
But to do that, we have to run the migrations against a different database.

145
00:07:39.100 --> 00:07:41.850
We're running it against jacket db Test,

146
00:07:41.850 --> 00:07:45.710
not jacket db So to do that,

147
00:07:45.710 --> 00:07:49.720
I had another task here called Migrate Test on inside here.

148
00:07:49.720 --> 00:07:51.340
I have a do first.

149
00:07:51.340 --> 00:07:54.840
This is the code that executes when the task runs.

150
00:07:54.840 --> 00:07:57.340
This is where I now run flyway.

151
00:07:57.340 --> 00:08:01.140
So with flyway here I can figure my test database.

152
00:08:01.140 --> 00:08:04.270
So inside here, Flyway set up the URL to be jacket.

153
00:08:04.270 --> 00:08:08.990
DV test schema is Jackie D V test and it runs this standard

154
00:08:08.990 --> 00:08:13.370
migrations from the same locations as before notice.

155
00:08:13.370 --> 00:08:15.940
I also have some extra greater dependencies here.

156
00:08:15.940 --> 00:08:19.440
These are to make sure that the flyway code runs at the right time.

157
00:08:19.440 --> 00:08:24.640
So the flyway code runs while I run my integration tests.

158
00:08:24.640 --> 00:08:26.630
So now that I have all of this in place,

159
00:08:26.630 --> 00:08:31.540
let's go on right and run an integration test.

160
00:08:31.540 --> 00:08:33.220
So I want to write one single test.

161
00:08:33.220 --> 00:08:36.340
First of all, just to show you how all this works,

162
00:08:36.340 --> 00:08:40.540
I'm going to write a test called Should Fight Article by ID.

163
00:08:40.540 --> 00:08:41.900
So notice the naming convention here.

164
00:08:41.900 --> 00:08:43.220
This is a should.

165
00:08:43.220 --> 00:08:46.940
So when I run this test, this is what should happen.

166
00:08:46.940 --> 00:08:49.930
So inside here, I'm going to be using my service.

167
00:08:49.930 --> 00:08:52.740
I'm going to be using my jacket, article services.

168
00:08:52.740 --> 00:08:54.720
So I declare an instance of that.

169
00:08:54.720 --> 00:08:56.150
And then once I have that,

170
00:08:56.150 --> 00:08:59.910
I can use it in my code so I can call the get method that

171
00:08:59.910 --> 00:09:03.240
I can assert that what I get back is not null.

172
00:09:03.240 --> 00:09:06.440
So we should be getting something back from the database.

173
00:09:06.440 --> 00:09:11.440
However, notice I'm not creating an instance of jacket article services anywhere,

174
00:09:11.440 --> 00:09:14.840
so I need to make sure that spring created for me.

175
00:09:14.840 --> 00:09:18.980
So to do that within my test, I say at Auto Wyatt,

176
00:09:18.980 --> 00:09:21.840
this is where this spring JUnit runner comes in.

177
00:09:21.840 --> 00:09:25.080
So at this point, it makes sure that the container is set up,

178
00:09:25.080 --> 00:09:28.140
that everything gets injected for me.

179
00:09:28.140 --> 00:09:29.740
The test should know Run.

180
00:09:29.740 --> 00:09:33.260
So run the test from inside cradle Great will make sure that

181
00:09:33.260 --> 00:09:36.070
the migrations run when I run the test here.

182
00:09:36.070 --> 00:09:36.720
No errors.

183
00:09:36.720 --> 00:09:38.140
So the test is green.

184
00:09:38.140 --> 00:09:40.540
The test has run correctly.

185
00:09:40.540 --> 00:09:44.040
Now that we have this, we can add a couple more tests.

186
00:09:44.040 --> 00:09:47.080
We have a test to make sure that for the first article we get back,

187
00:09:47.080 --> 00:09:49.280
we get the correct URL and correct title.

188
00:09:49.280 --> 00:09:52.280
We'll also test to make sure that when I asked for all articles,

189
00:09:52.280 --> 00:09:55.330
I get back to remember from my testing code.

190
00:09:55.330 --> 00:10:01.040
If I go into the insert data SQL here we're inserting to rows into the database.

191
00:10:01.040 --> 00:10:04.340
So when I asked for everything, I should get back to Rhodes,

192
00:10:04.340 --> 00:10:06.740
I've also added a cut of other tests.

193
00:10:06.740 --> 00:10:09.560
So again, if I save the code, go back to grade URL and read one.

194
00:10:09.560 --> 00:10:12.240
The tests test to finish.

195
00:10:12.240 --> 00:10:13.510
But if you look at the results.

196
00:10:13.510 --> 00:10:14.460
We have six tests.

197
00:10:14.460 --> 00:10:15.300
Last successful.

198
00:10:15.300 --> 00:10:17.640
So what about testing the repository?

199
00:10:17.640 --> 00:10:18.550
Well, in this case,

200
00:10:18.550 --> 00:10:22.940
we probably don't need to do that as we just using generally code.

201
00:10:22.940 --> 00:10:26.840
But it might be that we are extra methods to have repository implementation.

202
00:10:26.840 --> 00:10:28.800
You might want to make sure that those methods are

203
00:10:28.800 --> 00:10:31.740
doing what they think we're doing.

204
00:10:31.740 --> 00:10:33.770
So we do that in exactly the same way.

205
00:10:33.770 --> 00:10:37.950
So here we have an article repository test that extends abstract tests.

206
00:10:37.950 --> 00:10:38.560
We auto.

207
00:10:38.560 --> 00:10:39.660
Why the repository?

208
00:10:39.660 --> 00:10:43.390
We have a test method called should find all articles.

209
00:10:43.390 --> 00:10:45.300
And in this case, we simply call the repositories,

210
00:10:45.300 --> 00:10:49.770
find all method and then count the number of articles returned again.

211
00:10:49.770 --> 00:10:52.540
We check, and we're getting back to articles.

212
00:10:52.540 --> 00:10:55.870
So again, if we go back in the cradle and run the integration tests,

213
00:10:55.870 --> 00:10:56.710
they all still work.

214
00:10:56.710 --> 00:10:59.500
So as we can see we can wire up the dependencies,

215
00:10:59.500 --> 00:11:08.000
we need using auto wire using this spring runner to allow us to build and run integration tests

