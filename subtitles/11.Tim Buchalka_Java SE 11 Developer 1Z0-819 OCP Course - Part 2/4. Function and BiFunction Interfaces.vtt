WEBVTT
1
00:00:05.280 --> 00:00:11.670
In the last two videos, I reviewed the unary operator and binary operator interfaces, as well as generic

2
00:00:11.670 --> 00:00:17.910
and non generic forms of the predicate interface, all three of these types of interfaces take at least

3
00:00:17.910 --> 00:00:24.270
one argument the return of result in the first case, a result of some operation whose type matched

4
00:00:24.270 --> 00:00:25.680
the argument type or types.

5
00:00:25.950 --> 00:00:29.310
And in the case of a predicate, the result was a and value.

6
00:00:29.850 --> 00:00:35.430
Another device that takes an argument and returns a result is function, which I've already stated is

7
00:00:35.430 --> 00:00:38.870
a super interface to unary operator interface.

8
00:00:39.390 --> 00:00:43.350
The function interface has no restrictions on its type relationships.

9
00:00:43.650 --> 00:00:47.490
You can pass a document whose top has no relationship to the return type.

10
00:00:49.680 --> 00:00:55.170
The following shows you the generic functional interface function and its abstract method, the type

11
00:00:55.170 --> 00:01:01.680
parameter T represents, the type of argument parts to the method and the type parameter R represents.

12
00:01:01.680 --> 00:01:05.850
The type are the result of the method, let's say the public interface function.

13
00:01:06.180 --> 00:01:07.950
They've got T in our Renagel brackets.

14
00:01:08.460 --> 00:01:09.800
We've got an apply method there.

15
00:01:10.260 --> 00:01:13.840
Then I have a bit of T which returns the type are.

16
00:01:14.670 --> 00:01:19.470
So let's have a look at this in code E to create a new class and a built in interfaces project.

17
00:01:19.890 --> 00:01:21.750
But I call this one function example.

18
00:01:32.360 --> 00:01:37.700
So looking at this code, we're demonstrating three different usages of a lambda expression using function

19
00:01:38.540 --> 00:01:42.410
C, the first example there, and it's the simplest example, returning it to an argument.

20
00:01:43.300 --> 00:01:48.220
The second one there puts a string on spice, the returns, the first element, and the third one is

21
00:01:48.220 --> 00:01:51.340
returning a surplus string with spaces and not commas.

22
00:01:52.300 --> 00:01:53.020
Let's run this.

23
00:01:55.730 --> 00:02:00.620
And this results at the bottom of the screen, so you can see you could do a lot with a simple generic

24
00:02:00.620 --> 00:02:07.040
interface that accepts a single argument of a specified type and returns a result of some other specified

25
00:02:07.040 --> 00:02:07.460
type.

26
00:02:09.790 --> 00:02:16.540
The function interface provides two different methods compose and the and then default method, I mentioned

27
00:02:16.570 --> 00:02:21.850
these for the unary operator to postpone expanding them until now, since they are inherited from the

28
00:02:21.850 --> 00:02:22.870
function interface.

29
00:02:23.440 --> 00:02:27.870
In the example code I just demonstrated, I had a labor expression that looked like the following.

30
00:02:28.300 --> 00:02:33.640
I'm going to use the statements statement split into three parts to demonstrate using the compose and

31
00:02:33.640 --> 00:02:35.020
using the and then methods.

32
00:02:35.680 --> 00:02:36.730
So let's go back to code.

33
00:02:37.480 --> 00:02:40.900
I'm not going to do is pasted down here the end of our main method.

34
00:02:42.070 --> 00:02:43.250
Okay, so that's the code.

35
00:02:43.570 --> 00:02:48.080
So what I've done here is I've created a function typed variable and lamp expression for H.

36
00:02:48.500 --> 00:02:52.720
The first one is sublist one come for in parentheses.

37
00:02:53.110 --> 00:02:58.720
We've got another one, therefore iStock to string parentheses and the third one is replaced right at

38
00:02:58.720 --> 00:03:00.310
the bottom of the screen line 55.

39
00:03:00.460 --> 00:03:05.610
And the arguments for replace is a comma in single quotes and a space and single quotes.

40
00:03:06.640 --> 00:03:10.210
There are obviously these methods wouldn't need to be lambda expressions at all.

41
00:03:10.490 --> 00:03:13.300
I could just use method references, but hopefully you get the idea.

42
00:03:13.980 --> 00:03:17.230
Also adding a system to that statement in each lambda expression.

43
00:03:17.590 --> 00:03:21.310
So that will be able to say the order, the expressions were executed in Iraq.

44
00:03:21.340 --> 00:03:23.770
So we now need some code to execute these functions.

45
00:03:24.140 --> 00:03:25.330
So what I'm going to do is the following.

46
00:03:25.330 --> 00:03:28.010
I'm going to post the more coded score and more here.

47
00:03:29.620 --> 00:03:35.080
So what I'm doing here is I'm changing the three function local variables created using the compose

48
00:03:35.080 --> 00:03:36.010
method on function.

49
00:03:36.430 --> 00:03:41.270
And again, if we look at the names up here, we've got ifpri f result and if post.

50
00:03:41.950 --> 00:03:44.200
So I'm using those to say online at 60.

51
00:03:44.500 --> 00:03:49.630
So what I'm doing is I'm changing the three function local variables created using the compose method

52
00:03:49.630 --> 00:03:53.530
and function, then changing the end then method to the result.

53
00:03:53.830 --> 00:03:56.190
And next I'm changing the apply method.

54
00:03:56.200 --> 00:04:03.310
After that, the composed method will execute prior to apply and the method and then we'll execute after

55
00:04:03.310 --> 00:04:04.060
the apply method.

56
00:04:04.510 --> 00:04:09.250
So not that the parameter types I'm using for each predicate we've got IFPRI, which is being used for

57
00:04:09.250 --> 00:04:09.880
Campo's.

58
00:04:10.210 --> 00:04:13.930
I'm using an argument and a return type, both using a list of type integer.

59
00:04:13.930 --> 00:04:15.520
They can say that thirty 38.

60
00:04:16.460 --> 00:04:23.610
That's again used in compose on line 60 and for the end then method call using F post they can say F

61
00:04:23.620 --> 00:04:24.220
post on line.

62
00:04:24.220 --> 00:04:28.600
Fifty two is using type string for both the argument and the return top.

63
00:04:29.330 --> 00:04:30.670
So if we execute this code.

64
00:04:33.570 --> 00:04:37.190
You can see the result and the order that each function was executed in.

65
00:04:38.070 --> 00:04:41.740
Now, it could have moved the end method somewhere else to get the same result.

66
00:04:42.270 --> 00:04:44.220
So that's how about in some code?

67
00:04:44.220 --> 00:04:45.240
So I could have done this.

68
00:04:46.340 --> 00:04:52.050
I now that we've got and then method call in the code before, compose the only requirement for using

69
00:04:52.050 --> 00:04:58.110
compose and using the then method is that the applied method must be the last link, the method in the

70
00:04:58.110 --> 00:04:59.730
chain on this card.

71
00:05:03.350 --> 00:05:08.150
Looking at the output on the screen there, you notice that we've still got the identical result to

72
00:05:08.150 --> 00:05:13.220
what occurred last time, if you're adverse to creating a bunch of local variables of type function.

73
00:05:13.660 --> 00:05:15.320
You could write the code in a different way.

74
00:05:15.740 --> 00:05:16.410
That's a pencil.

75
00:05:16.430 --> 00:05:17.450
More code to look at that.

76
00:05:24.030 --> 00:05:29.610
As you can see, the commentary on 68 executing more Chinese lambrew expressions ugly, but okay, you

77
00:05:29.610 --> 00:05:34.110
can see by the code there and actually I'll just put it down a little bit so we can see the other one.

78
00:05:34.470 --> 00:05:37.770
We're using a lot of casting a topping, but we run this now.

79
00:05:40.530 --> 00:05:46.050
The actual result is still the same as we can see the final output, they could see that declaring function

80
00:05:46.050 --> 00:05:50.880
local variables when chaining makes it a lot easier to read and understand the code.

81
00:05:51.180 --> 00:05:54.270
But I'd certainly expect to see actually code on the exam.

82
00:05:56.550 --> 00:06:02.250
But before we finish the video next, let's look at the function, which is a super type of the binary

83
00:06:02.250 --> 00:06:03.240
operator interface.

84
00:06:03.390 --> 00:06:07.920
So it should come as no surprise that it takes two arguments and returns a result and that there is

85
00:06:07.920 --> 00:06:12.870
a no type relationships between either of the arguments or between the arguments and the resulting type.

86
00:06:13.140 --> 00:06:15.270
In other words, all three can be different types.

87
00:06:15.270 --> 00:06:18.510
And like binary operator, all three tops must be the same.

88
00:06:20.770 --> 00:06:26.620
So the following shows you the generic functional interface by function and it's abstract method three

89
00:06:26.620 --> 00:06:27.730
type parameters are defined.

90
00:06:27.730 --> 00:06:31.960
Here are stands for Return Talk to you here are used for the argument types.

91
00:06:32.470 --> 00:06:34.560
So we're going to public interface by function.

92
00:06:34.570 --> 00:06:37.840
You could say the type that to you and I and the method is apply.

93
00:06:37.840 --> 00:06:42.250
Returning type is are we've got two parameter types, as I mentioned t in you.

94
00:06:43.190 --> 00:06:48.240
I'm going to demonstrate a couple of examples of the function interface in our current class function

95
00:06:48.250 --> 00:06:54.100
example, since this class is very similar to the function class except for its support of two arguments.

96
00:06:55.650 --> 00:06:57.510
We're going to spend some code down the bottom here.

97
00:06:59.460 --> 00:07:00.630
We need to accept that import.

98
00:07:04.810 --> 00:07:10.450
So this example of created a by function local variable and assigned a lambda expression to it, they

99
00:07:10.450 --> 00:07:14.230
can coordinate to string values using double quotes between them.

100
00:07:14.740 --> 00:07:15.640
So if we run this now.

101
00:07:18.280 --> 00:07:20.260
You see the result at the bottom of the screen.

102
00:07:20.890 --> 00:07:22.010
All right, so that's split up.

103
00:07:22.030 --> 00:07:25.630
Let's try one more example using the more verbose version of Lambda Expressions.

104
00:07:26.830 --> 00:07:27.700
I'm going to post that in.

105
00:07:31.200 --> 00:07:31.970
Simply import.

106
00:07:33.800 --> 00:07:40.010
So here I type both lambda expression perimeter's and use Left-to-right Kelly prices to enclose the

107
00:07:40.010 --> 00:07:43.610
statements that return a list of top string in this case and a list.

108
00:07:44.150 --> 00:07:44.930
So if you run this.

109
00:07:47.770 --> 00:07:52.810
You can see the output at the bottom of the screen, so let's see in the video here in the next one,

110
00:07:53.020 --> 00:07:56.570
we're going to look at two more interfaces, consumer and supplier.

111
00:07:56.950 --> 00:07:58.210
See you in the next video.
