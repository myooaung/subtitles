WEBVTT
1
00:00:05.340 --> 00:00:10.860
Streams were designed with the lambda expressions in mind, I'll show this table again, which describes

2
00:00:10.860 --> 00:00:16.530
the operations on stream and the functional interfaces which are parameter types of these operations.

3
00:00:16.860 --> 00:00:22.020
I've included the functional interface method signature, which is important because it describes the

4
00:00:22.020 --> 00:00:24.930
structure of the lambda expression that can be used.

5
00:00:25.450 --> 00:00:27.540
Also includes sample lambda expressions.

6
00:00:29.950 --> 00:00:35.350
So from left to right, we've got a functional interface binary operator, the street method is reduce

7
00:00:35.860 --> 00:00:37.360
the functional interface method.

8
00:00:37.660 --> 00:00:38.860
You can see it's called apply.

9
00:00:39.130 --> 00:00:45.640
It takes two parameters of type T and returns a type T and a sample and expression will be in parentheses

10
00:00:45.640 --> 00:00:49.510
error token A plus B, next comparator.

11
00:00:49.900 --> 00:00:52.630
These three methods Max Min and sorted.

12
00:00:52.930 --> 00:00:59.200
The functional interface method is compare taking two parameters t and you sample an expression and

13
00:00:59.200 --> 00:01:02.180
B in parentheses are A token, B minus.

14
00:01:03.190 --> 00:01:07.770
And again, these lambda expressions are just samples that match the interface method directly defaces

15
00:01:07.780 --> 00:01:09.190
consumer and by consumer.

16
00:01:09.460 --> 00:01:14.850
The stream method which has parameters of these types I collect for each and peak and the functional

17
00:01:14.860 --> 00:01:15.780
device method first.

18
00:01:15.790 --> 00:01:22.210
If a consumer is except it's got one parameter of type T, it doesn't return anything and by consumer,

19
00:01:22.360 --> 00:01:25.480
same method, except that takes two parameters to you.

20
00:01:25.480 --> 00:01:32.020
And again, avoid return type in a sample and expression a parentheses error token system that out colon

21
00:01:32.020 --> 00:01:32.770
colon print.

22
00:01:33.280 --> 00:01:37.330
The next functional interface is function stret methods map and map.

23
00:01:37.630 --> 00:01:43.810
The functional interface method is apply, takes a perimeter of type T and returns a type R and a sample

24
00:01:43.810 --> 00:01:51.340
lambda expression here is s in parentheses error token to replace parentheses single quotes Ikoma single

25
00:01:51.340 --> 00:01:57.730
quotes B next interfaces unary operator string method is iterate the functionality of this method as

26
00:01:57.730 --> 00:02:04.360
apply takes a perimeter of type T a return to type T and a sample lambda expression there s in parentheses

27
00:02:04.360 --> 00:02:06.160
error token is plus one.

28
00:02:07.510 --> 00:02:14.890
Next, predicate, these three methods all match any match dropped while filter, iterate, non-match

29
00:02:14.890 --> 00:02:21.270
and take while punctually interface method is called test takes one parameter of type T returns, Boolean

30
00:02:21.790 --> 00:02:26.420
said and expression t parentheses error tolkan t greater than zero.

31
00:02:26.980 --> 00:02:29.200
The last functional interface is supplier.

32
00:02:29.530 --> 00:02:31.480
The three methods collect and generate.

33
00:02:31.840 --> 00:02:38.110
The functional interface method is get with no parameters and returns type T and a sample and expression.

34
00:02:38.110 --> 00:02:41.890
Parentheses, error, token string colon colon new.

35
00:02:42.530 --> 00:02:45.760
I'll be reviewing each of these methods in detail in this section of the course.

36
00:02:47.880 --> 00:02:49.800
The objectives for this section are as follows.

37
00:02:50.390 --> 00:02:52.800
This is the LAMDA operations on stream section.

38
00:02:52.800 --> 00:02:58.110
So we're going to be covering extracting stream data, using map peak and flat map methods.

39
00:02:58.480 --> 00:03:04.290
We'll be looking at searching stream data, using search point to find any any match or match and non-match

40
00:03:04.290 --> 00:03:06.810
methods can look at the optional class.

41
00:03:07.200 --> 00:03:13.140
We're going to perform some calculations using Count Max Min average and some all of our stream operations

42
00:03:14.130 --> 00:03:15.970
sort of collection using lambda expressions.

43
00:03:16.170 --> 00:03:20.340
We're also going to look at using Collectors' with a stream, including the group by and partitioning

44
00:03:20.340 --> 00:03:21.450
by operation.

45
00:03:21.990 --> 00:03:22.310
All right.

46
00:03:22.320 --> 00:03:24.120
So let's get started in the next video.
