WEBVTT
1
00:00:05.210 --> 00:00:06.870
Continuing on from the last video.

2
00:00:07.310 --> 00:00:13.010
Now let's look at Merge lead to add another method to this segment, the same, for example, Rojava

3
00:00:13.010 --> 00:00:14.210
and the price that down the bottom.

4
00:00:21.340 --> 00:00:23.120
Can see the method, their test Bourges.

5
00:00:24.530 --> 00:00:30.260
Or so good examples of using Mirch in this method specifically is in key value if the key doesn't exist

6
00:00:30.560 --> 00:00:33.680
at the entry using key and the value path to the merge method.

7
00:00:34.570 --> 00:00:39.700
And again, you key value of the key exists and the Vellis know is a valid pass to the merge method

8
00:00:39.700 --> 00:00:40.630
to obtain the value.

9
00:00:41.110 --> 00:00:46.950
Another example, the key exists in the palace, not now to execute the function past to return.

10
00:00:46.960 --> 00:00:51.010
There is not now update the value if returned value is now removed.

11
00:00:51.010 --> 00:00:51.910
The entry from the Met.

12
00:00:52.740 --> 00:00:59.160
And towards the bottom are using replaceable to replace all values in a map and specifically what I'm

13
00:00:59.160 --> 00:01:01.560
doing there is already the number one to all the values.

14
00:01:01.800 --> 00:01:07.180
If a valley is set closer to zero, they've had not tested for Nalanda provided lambda expression and

15
00:01:07.180 --> 00:01:09.090
now pointer exception would have been thrown.

16
00:01:10.110 --> 00:01:11.830
All right, let's go back up to our main method.

17
00:01:13.000 --> 00:01:14.550
Well, let's go to test this method.

18
00:01:20.770 --> 00:01:26.860
So the output, this additional segment of code confirms that much as an entry, if it doesn't exist

19
00:01:27.370 --> 00:01:30.020
and uses the second argument as the value in that scenario.

20
00:01:30.310 --> 00:01:35.500
We also confirm that merge updates entry, if it does exist, is in the operation in the third argument

21
00:01:35.500 --> 00:01:36.240
to get the value.

22
00:01:36.970 --> 00:01:42.120
And thirdly, merge removes the entry to value from the third operation returns to now.

23
00:01:43.030 --> 00:01:43.450
All right.

24
00:01:44.230 --> 00:01:48.790
So now let's look at some of the methods on map that create sets, some of the entries, keys and values

25
00:01:49.390 --> 00:01:50.550
in a new class for this one.

26
00:01:51.070 --> 00:01:53.110
We'll call this one map set examples.

27
00:02:04.750 --> 00:02:11.660
I could see he was turning out a new tree map and our main method, and specifically we're using constructor

28
00:02:11.810 --> 00:02:12.800
that takes a map.

29
00:02:13.250 --> 00:02:18.470
The map is created from a static method unmap, mapped out of, as you can see there, being invoked

30
00:02:18.470 --> 00:02:19.370
on line 17.

31
00:02:19.670 --> 00:02:25.910
That uses a comma delimited list representing the key valley pairs to create a map for the method of

32
00:02:25.910 --> 00:02:30.710
method creates an immutable list, passing an immutable map to constructor of a map.

33
00:02:31.010 --> 00:02:34.480
It is the values of the map passed to create a new mutable map.

34
00:02:35.270 --> 00:02:36.080
But the next.

35
00:02:37.070 --> 00:02:43.100
Missing the entry set method to get a set of the key valley entries, this set is a view many changes

36
00:02:43.100 --> 00:02:47.120
to the set, actually a change to the map, although add an add on.

37
00:02:47.120 --> 00:02:49.820
I'm not supported here, so let's run this.

38
00:02:52.900 --> 00:02:55.510
And as you can see there, nothing changed.

39
00:02:55.750 --> 00:02:57.040
So why didn't it change?

40
00:02:57.980 --> 00:03:03.530
Because our collection is an entry set, we must match on the object in the set, so I need to use the

41
00:03:03.530 --> 00:03:07.790
removed method, the method entry object specifying the key and valued.

42
00:03:08.360 --> 00:03:13.550
I can get an instance of an entry using a static factory method method entry which was introduced in

43
00:03:13.550 --> 00:03:13.850
Java.

44
00:03:13.850 --> 00:03:14.580
Not so.

45
00:03:14.870 --> 00:03:15.800
Let's have a look at doing that.

46
00:03:16.570 --> 00:03:21.060
In a post in his code, the bottom of our main method, and you can see what I'm doing there.

47
00:03:22.190 --> 00:03:29.900
Meeting instances retrieved from the entry invocations to specify the entry that I want removed to remove

48
00:03:29.900 --> 00:03:31.940
my entry, the key in the valley must match.

49
00:03:32.900 --> 00:03:35.750
I can see in the first attempt there are 30.

50
00:03:36.480 --> 00:03:41.450
I'm trying to remove a key value pair of John and the number twenty five and in the second John and

51
00:03:41.450 --> 00:03:42.140
thirty five.

52
00:03:42.980 --> 00:03:47.070
Looking at our entries, we can say that the correct entry for John is 34.

53
00:03:47.780 --> 00:03:48.770
So if you run this now.

54
00:03:51.320 --> 00:03:52.910
So I can say in the first example.

55
00:03:54.310 --> 00:04:00.030
Passing the key, John and the Valley 25 had no effect, but when I used the exact match for key and

56
00:04:00.070 --> 00:04:02.920
value, the element was successfully removed from the map.

57
00:04:02.920 --> 00:04:04.630
And we say that in the last line of output.

58
00:04:05.320 --> 00:04:09.660
But Sarovar, let's play some more code in here to the main method in the bottom.

59
00:04:10.330 --> 00:04:12.370
I'll just accept as imports.

60
00:04:14.010 --> 00:04:19.140
So in this code, I now get a collection of just the Map Valley's first and then removed by a value

61
00:04:19.140 --> 00:04:20.210
matching twenty three.

62
00:04:20.220 --> 00:04:23.540
You can say that on line thirty nine, I can then get a collection of just the cable.

63
00:04:24.090 --> 00:04:27.030
And then in fact, the removed method is Mary.

64
00:04:28.700 --> 00:04:33.320
So obviously, looking at the entries up here, Rob has a value of twenty three, so if we run this

65
00:04:33.320 --> 00:04:33.650
now.

66
00:04:37.240 --> 00:04:42.370
You say that both of those removal methods have worked, so we removed an entry from the map to using

67
00:04:42.370 --> 00:04:47.020
a remove method on the Valley's collection path to get a value that was an entry in the map.

68
00:04:47.410 --> 00:04:52.420
Then I removed an entry from the map using a remote method on the case collection, passing in a key

69
00:04:52.420 --> 00:04:54.310
that was a key of an entry in the map.

70
00:04:55.260 --> 00:04:57.180
But let's add some more code to my method.

71
00:04:59.860 --> 00:05:04.720
As you can see, the segment code has three more values to the map, and yet the site's not on the map,

72
00:05:05.080 --> 00:05:06.460
but of the collection keys.

73
00:05:10.830 --> 00:05:15.180
So we can see now the map contains five elements that the size of the case, a collection, is also

74
00:05:15.180 --> 00:05:19.200
five, so that changes to the map are reflected in the collection views.

75
00:05:20.740 --> 00:05:22.370
Let's use retain all now.

76
00:05:22.630 --> 00:05:24.570
I'm going to come down here and paste in some code.

77
00:05:26.470 --> 00:05:27.060
To run this.

78
00:05:30.810 --> 00:05:32.440
And we can see they have put right to the bottom.

79
00:05:33.300 --> 00:05:39.020
So remember that retitle first identifies the intersection of elements and keeps those that intersect.

80
00:05:39.390 --> 00:05:44.550
But you'll also note that you could perform operations on the map, then continue to perform operations

81
00:05:44.550 --> 00:05:45.180
on the set.

82
00:05:45.580 --> 00:05:48.660
So the changes here are reflected in both references.

83
00:05:49.320 --> 00:05:55.830
Now, this is true as long as the collection returned from entry set Kasit and Valleys is not iterating

84
00:05:56.130 --> 00:05:57.390
from the source map is altered.

85
00:05:58.830 --> 00:06:00.540
All right, just a bit more code here.

86
00:06:02.410 --> 00:06:03.570
If you try to run this now.

87
00:06:04.920 --> 00:06:09.600
You could say we had a concurrent modification exception, and the reason for that is I'm altering the

88
00:06:09.600 --> 00:06:14.280
source about the treatment while I'm iterating through the case collection I retrieved from this source,

89
00:06:14.670 --> 00:06:15.420
hence the error.

90
00:06:16.530 --> 00:06:18.510
So I'll just remove that last for loop.

91
00:06:20.250 --> 00:06:21.540
That's again, posting some code.

92
00:06:23.540 --> 00:06:29.060
So this is demonstrating the mapped out copy of static method introduced in Java, 10 of these statements

93
00:06:29.060 --> 00:06:34.520
look very similar and you can imagine it could easily be overlooked that the first line of code is creating

94
00:06:34.520 --> 00:06:37.300
a mutable map and the put method works.

95
00:06:38.060 --> 00:06:44.240
The second attempt is not passing the mapped copy of results to a constructor, but directly assigning

96
00:06:44.240 --> 00:06:45.260
it to a variable.

97
00:06:45.610 --> 00:06:50.960
Again, I'm calling the put method, so no problems with the compilation, but when I run it.

98
00:06:55.730 --> 00:07:01.460
Begin an unsupported operation exception, confirming the first put was allowed, but the second was

99
00:07:01.460 --> 00:07:02.840
against an immovable object.

100
00:07:03.500 --> 00:07:04.550
So let's just cut it out.

101
00:07:04.960 --> 00:07:07.400
The only question on 30 that's causing the problem.

102
00:07:08.060 --> 00:07:08.710
Run it again.

103
00:07:13.100 --> 00:07:14.390
The familiarity disappears.

104
00:07:17.060 --> 00:07:18.790
Spencer Malko to my method.

105
00:07:20.530 --> 00:07:22.810
You can say we've got no errors here if we run it.

106
00:07:24.620 --> 00:07:28.760
We're looking at an unsupported operation exception crashing on line 69.

107
00:07:29.720 --> 00:07:35.330
The problem is with the method being called from the entry set method, the head method is not supported

108
00:07:35.330 --> 00:07:41.660
by any of the collections returned from entry set Kasit or the values methods even against a mutable

109
00:07:41.660 --> 00:07:42.020
map.

110
00:07:44.060 --> 00:07:45.740
Let's delete those last two lines.

111
00:07:48.340 --> 00:07:49.270
Posting some more code.

112
00:07:52.580 --> 00:07:58.100
This coach is telling them episode of Entry's Method introduced in Javani to create an immutable map.

113
00:08:03.320 --> 00:08:04.790
Well, it's posted some more Kardinia.

114
00:08:07.460 --> 00:08:14.060
And here what we're doing is we're using the method of entries method call in the put all method if

115
00:08:14.060 --> 00:08:14.600
we run this.

116
00:08:16.740 --> 00:08:20.970
We get an area which is probably not surprising because it's an immutable map, the beautiful map,

117
00:08:20.970 --> 00:08:22.350
after all, is an immutable map.

118
00:08:22.350 --> 00:08:25.380
So you can't use put all to add elements to this map.

119
00:08:26.720 --> 00:08:30.320
I'm going to make some changes here, I'm going to pay some CHOTE directly under this.

120
00:08:31.950 --> 00:08:38.310
But I'm also going to do then is make a copy of teh copy Mirabal and changing Mirabal map to t copy

121
00:08:38.310 --> 00:08:38.770
immutable.

122
00:08:39.090 --> 00:08:40.140
We need to do that twice.

123
00:08:41.550 --> 00:08:43.050
If the two changes to the code, they're.

124
00:08:44.130 --> 00:08:47.030
Never, obviously, we've got no compilation errors if we run this now.

125
00:08:50.610 --> 00:08:56.820
Back to Kyra, that's working, so although the methods map of map of entries are mapped out, entry

126
00:08:56.820 --> 00:09:02.190
return, immutable objects, these can be passed to methods that they create copies of them constructors

127
00:09:02.190 --> 00:09:04.980
and put all to help create mutable maps.

128
00:09:07.590 --> 00:09:12.540
So this video and the last one have demonstrated at the map interface and map implementations are different

129
00:09:12.840 --> 00:09:16.110
from the collection, interface and collection implementations.

130
00:09:16.650 --> 00:09:21.180
I've demonstrated many of the methods, default and static that were introduced to the map interface

131
00:09:21.180 --> 00:09:27.360
in Java eight, nine and 10, which leverage lambda expressions to do operations on entry values.

132
00:09:27.910 --> 00:09:33.240
And in addition of showing you how you can leverage the collection interface methods and map implementations

133
00:09:33.240 --> 00:09:38.820
by creating the collection views using the methods entry set key set of values.

134
00:09:41.130 --> 00:09:46.740
Just remember that Ed and Ed, all methods are not supported by the collection of views you can put

135
00:09:46.740 --> 00:09:51.600
on the original map and the viewers can still be used after that modification as long as they are not

136
00:09:51.600 --> 00:09:55.170
being used in an operation when the modifications occur.

137
00:09:55.890 --> 00:10:00.840
In the next video, I'll try to point out a few unusual constructs in the collections topic which might

138
00:10:00.840 --> 00:10:02.060
turn up on the exam.

139
00:10:02.460 --> 00:10:03.620
See you in the next video.
