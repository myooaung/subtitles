WEBVTT
1
00:00:05.270 --> 00:00:10.930
A functional interface is nothing more than an interface that defines one and only one abstract method,

2
00:00:11.450 --> 00:00:14.750
its behavior is generally knowable by its name.

3
00:00:15.290 --> 00:00:20.420
There's no required keyword or annotation, but an annotation declaring your intention is recommended.

4
00:00:21.080 --> 00:00:23.360
We'll be reviewing annotations later in this course.

5
00:00:23.900 --> 00:00:29.360
But in addition, functional interfaces are often suffixed with Abu Subminimum.

6
00:00:29.570 --> 00:00:32.750
It looks something like the following interface doable.

7
00:00:33.290 --> 00:00:37.460
And we can actually Brice's within that void do something parentheses and a semicolon.

8
00:00:39.680 --> 00:00:45.620
So a functional interface has no other requirements, it can be public, private package, private or

9
00:00:45.620 --> 00:00:48.680
protected, it can be nested in another type.

10
00:00:49.010 --> 00:00:51.680
It can contain private static and default methods.

11
00:00:52.100 --> 00:00:53.810
It can extend other interfaces.

12
00:00:54.110 --> 00:00:56.540
It can be extended by other interfaces.

13
00:00:57.730 --> 00:01:03.040
So let's sounds easy enough, but let's explore some interfaces in code and see if we can make it up

14
00:01:03.040 --> 00:01:05.400
a bit so we need to create a new project.

15
00:01:05.440 --> 00:01:06.250
He can say, I've done that.

16
00:01:06.250 --> 00:01:08.110
I've called this one Lambda Expressions.

17
00:01:08.470 --> 00:01:10.060
We need a new class in this project.

18
00:01:10.330 --> 00:01:12.220
I'm going to call this one functional interface.

19
00:01:23.440 --> 00:01:24.510
All right, so that's the code.

20
00:01:24.880 --> 00:01:29.320
So the code of pasted in consists of a package, private interface double.

21
00:01:29.320 --> 00:01:33.550
You can see there with a single abstract method, you can say that method to do it.

22
00:01:34.180 --> 00:01:36.550
This meets the criteria for a functional interface.

23
00:01:37.680 --> 00:01:44.350
Now we've got the functional interface class, which contains a private interface shippable with a single

24
00:01:44.350 --> 00:01:45.010
abstract method.

25
00:01:45.010 --> 00:01:51.640
Shapard This meets the criteria for a functional interface also moving into the main method.

26
00:01:53.720 --> 00:01:56.040
Both got two other static methods here.

27
00:01:56.570 --> 00:02:02.030
Each of these takes a parameter of one of the interface types allowing us to test passing an object,

28
00:02:02.270 --> 00:02:05.530
implementing these interfaces to methods which execute a single method.

29
00:02:06.050 --> 00:02:07.430
You go back up to our main method.

30
00:02:08.780 --> 00:02:13.610
This is creating two anonymous classes, one for each interface, they say what we're doing there,

31
00:02:13.610 --> 00:02:18.980
effectively, we're executing the DeWit method and the Shapard method directly from the instances of

32
00:02:18.980 --> 00:02:20.030
the anonymous classes.

33
00:02:20.760 --> 00:02:24.650
We're also passing a lambda expression to methods which execute the functions.

34
00:02:25.010 --> 00:02:28.910
They should already be familiar with lambda expressions, but I'll be reviewing them a lot more in the

35
00:02:28.910 --> 00:02:29.570
next video.

36
00:02:29.840 --> 00:02:32.750
But I want to use them here just to test functional interfaces.

37
00:02:33.510 --> 00:02:39.200
Also passing the instances of the anonymous classes to methods which in turn invoke the single methods.

38
00:02:40.740 --> 00:02:41.720
You can see all the code there.

39
00:02:44.070 --> 00:02:45.300
So let's stop all running this.

40
00:02:47.760 --> 00:02:51.780
And there's the airport at the bottom of the screen, this process here, right?

41
00:02:52.240 --> 00:02:52.520
All right.

42
00:02:52.590 --> 00:02:53.310
So let's move on.

43
00:02:53.920 --> 00:02:54.660
I'm going to do.

44
00:02:56.410 --> 00:02:59.010
Let's go down to the bottom of the source code and his file.

45
00:02:59.410 --> 00:03:04.960
I'm going to add an interface to the source file and obviously it's not nested that this interface doesn't

46
00:03:04.960 --> 00:03:09.400
really look like it's a functional interface because it doesn't clear any methods at all.

47
00:03:10.100 --> 00:03:12.580
So what I want to do now is go back up to our main method.

48
00:03:13.090 --> 00:03:15.250
And if at the lambda expression for doable.

49
00:03:17.050 --> 00:03:23.650
Then you could say that we set that up there alone, 30 to replace that code there, including the comment

50
00:03:23.950 --> 00:03:24.640
with his code.

51
00:03:27.040 --> 00:03:32.260
So basically, the lambrix persons assigned to an extended doable local variable, and of course, that's

52
00:03:32.260 --> 00:03:35.800
the interface we only just pasted in at the bottom of the code.

53
00:03:36.580 --> 00:03:37.600
Now, if we run this again.

54
00:03:40.530 --> 00:03:47.430
The result is the same output as before, so that confirms that the extended dubal interface is a functional

55
00:03:47.430 --> 00:03:49.020
interface that's been done here again.

56
00:03:51.360 --> 00:03:53.370
Otherwise, the Lambro expression wouldn't be valid.

57
00:03:53.760 --> 00:03:59.100
So a functional interface can have no abstract methods in its body if it extends another interface,

58
00:03:59.370 --> 00:04:00.670
which is a functional interface.

59
00:04:00.760 --> 00:04:04.260
Of course, here we are extending doable, which did have that abstract method.

60
00:04:04.620 --> 00:04:09.330
Let's go ahead here and actually add a method definition for our extended dual interface.

61
00:04:11.250 --> 00:04:13.080
Boyd, of course, when extended to it.

62
00:04:16.060 --> 00:04:17.140
And when I've done that.

63
00:04:19.500 --> 00:04:24.930
So I can see what's happened there, but may actually naming method in extendible dubal the interface

64
00:04:24.930 --> 00:04:30.210
to extend it to it, it introduced a compiler on the lambda expression declared in the main method of

65
00:04:30.210 --> 00:04:31.530
the functional interface class.

66
00:04:31.950 --> 00:04:33.660
So in this instance, we just hover over that.

67
00:04:34.520 --> 00:04:37.390
We're not overriding abstract methods found in interface extendable.

68
00:04:37.830 --> 00:04:42.150
So what's happened here is I have an interface with a single abstract method that's not considered a

69
00:04:42.150 --> 00:04:43.200
functional interface.

70
00:04:43.980 --> 00:04:45.440
The reality is we got to have a look again.

71
00:04:47.010 --> 00:04:52.920
We've got our extended double interface, which has a method void extended to it, but remembering it's

72
00:04:52.920 --> 00:04:56.070
also inheriting from doable and doable.

73
00:04:56.570 --> 00:04:58.300
It's got its own method to it as well.

74
00:04:58.320 --> 00:05:02.700
So effectively, we've got two abstract methods which doesn't fulfill the requirements for a functional

75
00:05:02.700 --> 00:05:04.140
device, hence the error.

76
00:05:05.100 --> 00:05:11.430
We go back down here, if I just change, extend it, do it to do it again so that we're effectively

77
00:05:11.430 --> 00:05:14.250
overriding that method, things work as I should.

78
00:05:14.250 --> 00:05:17.850
The compiler errors disappeared because I run the code and it works.

79
00:05:19.510 --> 00:05:20.530
Right, so that's good.

80
00:05:20.740 --> 00:05:27.340
So let's try something else, though, let's try implementing the Duart method in extended Dorval interface.

81
00:05:27.700 --> 00:05:30.760
I'm going to paste in an implementation of the method.

82
00:05:32.640 --> 00:05:37.730
You say it's the default method of defy their default, do it, and we've got a simple print out there

83
00:05:38.220 --> 00:05:40.710
so it is allowable to add a default method.

84
00:05:40.720 --> 00:05:43.950
But again, I've introduced the compiler error on the lander expression.

85
00:05:45.780 --> 00:05:47.040
Their target method failed.

86
00:05:47.730 --> 00:05:52.410
That's permissible to override an abstract method with the default method, but doing so without introducing

87
00:05:52.410 --> 00:05:58.180
another abstract method into the interface, disqualifiers this interface as a functional interface.

88
00:05:58.860 --> 00:06:06.020
So to get this working again, what we need to do is come down here and add another method to our extended

89
00:06:06.030 --> 00:06:11.180
do it again to avoid extended do it parentheses and semicolon.

90
00:06:11.190 --> 00:06:13.410
And you can see the error, the disappeared.

91
00:06:13.430 --> 00:06:16.020
There's no more compiler errors if we run it now.

92
00:06:19.950 --> 00:06:23.740
We've now got to do it with Dubow method executing do it.

93
00:06:23.760 --> 00:06:25.650
We've got the message there relighting.

94
00:06:26.630 --> 00:06:32.150
To a do it method in its territorial endophytes, Senator, although we passed an extended double lambda

95
00:06:32.150 --> 00:06:37.730
expression to the do it with doable method to do it with doable method, executed the default method,

96
00:06:37.730 --> 00:06:42.920
do it and not the code in the lambda expression, go back up to our main interface.

97
00:06:43.290 --> 00:06:44.030
My method, rather.

98
00:06:45.070 --> 00:06:49.310
You can see the output, there was Lambro expression, if I can do it, but in fact, we've got a default

99
00:06:49.360 --> 00:06:54.220
method implemented, do it, outputting the apple pie and confirming that to do it with doable method,

100
00:06:54.220 --> 00:06:55.420
executed the default method.

101
00:06:55.420 --> 00:06:56.950
Do it on our interface.

102
00:06:59.440 --> 00:07:00.360
A lot, 77.

103
00:07:01.080 --> 00:07:02.260
Let's try something else.

104
00:07:04.060 --> 00:07:09.790
What are the methods that we've gone down to replace the method up here, do it with doable a lot 60

105
00:07:09.810 --> 00:07:11.110
to just replace that.

106
00:07:13.830 --> 00:07:14.520
With this code.

107
00:07:16.290 --> 00:07:17.440
They can see what's happening there.

108
00:07:17.460 --> 00:07:23.850
It's testing the type of object path to do it with doable if it implements extended doable, it's executing

109
00:07:23.850 --> 00:07:27.270
the abstract method, using the body of the lambda expression.

110
00:07:28.550 --> 00:07:31.180
That's the code we can see what the airports come back.

111
00:07:32.570 --> 00:07:37.700
I can see that that's changed an obviously overriding and abstract method with a default method must

112
00:07:37.700 --> 00:07:41.510
be done with care or the client code will be impacted negatively.

113
00:07:43.270 --> 00:07:48.700
So we've demonstrated here so you could see its impact on a functional interface, the exam will ask

114
00:07:48.700 --> 00:07:53.590
you to recognize functional interfaces and what seems straightforward is not always that.

115
00:07:54.170 --> 00:07:56.210
Let's look at a few more examples before we end the video.

116
00:07:56.650 --> 00:08:01.150
So let's start the changes with a change to our extended doable interface.

117
00:08:01.470 --> 00:08:02.380
I'm going to change that.

118
00:08:04.050 --> 00:08:10.050
As follows, you say it now includes comparable in the extents clause and has no methods of its own.

119
00:08:11.510 --> 00:08:13.950
Introduced a compiler error, if we check it out.

120
00:08:16.510 --> 00:08:20.230
But will not overriding abstract methods found in interface extended double.

121
00:08:21.410 --> 00:08:22.170
So what's happened here?

122
00:08:22.190 --> 00:08:23.840
We'll go back and look at the interface again.

123
00:08:24.820 --> 00:08:30.010
Extended to war was no longer a functional interface because it now inherits two abstract methods.

124
00:08:30.990 --> 00:08:32.070
But and do that.

125
00:08:33.830 --> 00:08:37.130
Now back to work and code, obviously, that will work.

126
00:08:42.390 --> 00:08:48.480
So it's a recap when looking at an exam question, review the hierarchy of the interface tree, tracking

127
00:08:48.480 --> 00:08:54.570
all abstract methods, remembering the following one, it can override an abstract method on an interface

128
00:08:54.570 --> 00:08:59.610
with a default method to you cannot override an abstract method on an interface with a static method.

129
00:09:00.330 --> 00:09:05.070
And three, you cannot override an abstract method with a private method because you're assigning weaker

130
00:09:05.070 --> 00:09:05.700
privileges.

131
00:09:06.060 --> 00:09:08.150
All abstract methods are an interface, are public.

132
00:09:08.880 --> 00:09:13.770
But so moving on, now that I've reviewed how to recognize a functional interface will be focusing on

133
00:09:13.770 --> 00:09:18.150
using them in the next video to support the use of lambda expressions.

134
00:09:18.630 --> 00:09:19.680
See you in the next video.
