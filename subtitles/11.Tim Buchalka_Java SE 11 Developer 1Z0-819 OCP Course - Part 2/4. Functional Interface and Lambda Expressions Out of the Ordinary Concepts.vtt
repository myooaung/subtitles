WEBVTT
1
00:00:05.320 --> 00:00:11.020
So let's look now at another interface example that will test your recognition of functional interfaces,

2
00:00:11.170 --> 00:00:16.330
we need to create a new class in our Lab Expressions project that we call this one functional test.

3
00:00:29.580 --> 00:00:34.800
So this code consists of an interface functional that declares three abstract methods.

4
00:00:36.160 --> 00:00:42.130
The functional test class moving down with its main method that assigns that lambda expression and assigns

5
00:00:42.130 --> 00:00:47.740
it a local variable, then executes the lambda expression in a system that print statement.

6
00:00:48.910 --> 00:00:50.060
The code obviously can pass.

7
00:00:50.080 --> 00:00:50.920
If we run this now.

8
00:00:53.320 --> 00:00:55.070
You can see the airport at the bottom of the screen.

9
00:00:55.660 --> 00:00:56.690
Does this confuse you?

10
00:00:56.950 --> 00:00:59.460
How can a functional interface if we look at it again?

11
00:01:00.400 --> 00:01:06.040
With three abstract methods be a functional interface, we'll look more closely at the methods declared

12
00:01:06.040 --> 00:01:06.840
in the interface.

13
00:01:07.420 --> 00:01:08.380
What do they have in common?

14
00:01:09.040 --> 00:01:13.690
The signatures match signatures of public methods, but Javadoc Languedoc object.

15
00:01:13.930 --> 00:01:20.340
As it turns out, interfaces implicitly declare abstract methods corresponding to the public methods

16
00:01:20.350 --> 00:01:20.830
of object.

17
00:01:21.130 --> 00:01:27.340
Explicitly declaring these methods abstract, as cited in this example, has no effect, and those methods

18
00:01:27.340 --> 00:01:31.090
are not included when considering an interface functional.

19
00:01:32.140 --> 00:01:37.450
I want to review again what happens when you create a default method in an interface that inherits the

20
00:01:37.450 --> 00:01:40.800
method as an abstract method we did in your class.

21
00:01:40.840 --> 00:01:42.490
This will call this lambda extras.

22
00:01:55.710 --> 00:02:00.810
But so the first thing you'll notice is that the code doesn't compile more on that shortly, looking

23
00:02:00.810 --> 00:02:07.260
at the code starting at the top, we've got an interface named confusable using type string that extends

24
00:02:07.290 --> 00:02:09.380
a comparator using top string.

25
00:02:09.990 --> 00:02:15.270
The important method in the comprehensive interface, as you know, is COMPAR here have created a default

26
00:02:15.270 --> 00:02:15.540
method.

27
00:02:15.540 --> 00:02:21.420
Compare with the same signature, then created a crazy algorithm that ensures I never get the same result

28
00:02:21.420 --> 00:02:22.420
twice and compare.

29
00:02:22.830 --> 00:02:24.970
So I've added a system to that statement.

30
00:02:24.970 --> 00:02:31.440
This I could discover when this method is executed because we've got a class confused that implements

31
00:02:31.440 --> 00:02:32.700
the confusable interface.

32
00:02:33.000 --> 00:02:37.110
This class has got an attribute, name, name there, a constructed, a populated.

33
00:02:37.710 --> 00:02:39.050
We've got a two string method there.

34
00:02:39.510 --> 00:02:41.490
We're using that as the principal face of the object.

35
00:02:41.790 --> 00:02:45.180
We've also got a method called Duminy, which for the first test isn't used.

36
00:02:45.580 --> 00:02:47.460
Then we've got a lambda extras class.

37
00:02:48.600 --> 00:02:53.550
With its main method, which declares a local variable of type confusable, and there are signs that

38
00:02:53.550 --> 00:02:59.370
Lambrew expression to it, it creates a list of confused objects that attempts to sort the list using

39
00:02:59.370 --> 00:03:01.460
confusable in place of co-operator.

40
00:03:02.550 --> 00:03:04.710
As I mentioned, this code currently doesn't compile.

41
00:03:05.160 --> 00:03:05.940
We hover over that.

42
00:03:06.880 --> 00:03:11.020
The target method failed, they've given you a similar example in the last video.

43
00:03:11.380 --> 00:03:14.470
The reason is that the default method compare in confusable up here.

44
00:03:15.690 --> 00:03:21.510
As disqualified confusable as a functional interface, so let's add another abstract method in this

45
00:03:21.510 --> 00:03:22.560
confusable interface.

46
00:03:26.390 --> 00:03:31.370
That's fixed our compiler, Arendelle, so get into the code again, it's now valid.

47
00:03:32.470 --> 00:03:33.520
And if you run this code.

48
00:03:35.280 --> 00:03:38.850
Reached the airport, as you can see on the screen there, the method, this list can be printed in

49
00:03:38.850 --> 00:03:44.070
any order and the number of print staples will vary due to the random nature of the COMPAR method.

50
00:03:46.220 --> 00:03:47.470
They say we've got a different result there.

51
00:03:49.300 --> 00:03:53.660
So executing against him during Botterill times will get different results.

52
00:03:55.030 --> 00:04:01.390
Therefore, this airport, you say that although I passed the lambda expression in using an expression

53
00:04:01.570 --> 00:04:06.760
that would match an expression for the COMPAR method, the default method of confusable was the code

54
00:04:07.000 --> 00:04:08.320
that's actually executed.

55
00:04:09.100 --> 00:04:10.080
The let's test something here.

56
00:04:10.090 --> 00:04:13.480
Let's change confusable here to comparator.

57
00:04:22.780 --> 00:04:26.040
So this confirms the lambda expression, a a comparator is used.

58
00:04:28.660 --> 00:04:33.820
So when you look at a code segment, which is testing your knowledge of functional interfaces, be careful

59
00:04:33.820 --> 00:04:37.090
to firstly check whether the interface extends another.

60
00:04:37.630 --> 00:04:39.250
Does it extend more than one interface?

61
00:04:39.460 --> 00:04:41.680
How many abstract methods does it inherit?

62
00:04:42.280 --> 00:04:46.660
Is it a folk method in the sub interface overriding an abstract method?

63
00:04:48.640 --> 00:04:54.730
Secondly, is it explicitly defining abstract methods that match Javadoc length or object public methods?

64
00:04:55.090 --> 00:05:01.590
This can be ignored when determining if the interface as a single abstract method the third nor static

65
00:05:01.600 --> 00:05:02.440
in private methods.

66
00:05:02.450 --> 00:05:08.170
Unless the question has a compile time error responses can override an inherited abstract method with

67
00:05:08.170 --> 00:05:10.000
a static method or a private method.

68
00:05:10.840 --> 00:05:14.500
So let's say in the video here next, you'll be presented with a couple of questions that will test

69
00:05:14.500 --> 00:05:19.120
your knowledge about functional interfaces and the structure and usage of lambda expressions.

70
00:05:19.530 --> 00:05:25.060
Good luck and I'll catch up with you after that to start our review of Java's built in functional interfaces

71
00:05:25.180 --> 00:05:26.080
in the next section.
