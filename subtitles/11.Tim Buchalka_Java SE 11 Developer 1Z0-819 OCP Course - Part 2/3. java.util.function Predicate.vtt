WEBVTT
1
00:00:05.390 --> 00:00:10.340
The next builtin interface I want to discuss here is the predicate interface, the word predicate,

2
00:00:10.640 --> 00:00:15.760
when used as a verb means state affirm or assert something about the subject or an argument.

3
00:00:16.430 --> 00:00:21.440
You remember from earlier videos on assertions that we asserted something by creating an expression

4
00:00:21.440 --> 00:00:23.030
that evaluated to true.

5
00:00:23.330 --> 00:00:28.280
If our certain assumption was correct, it used to predicate interface.

6
00:00:28.520 --> 00:00:33.980
When you want to test whether something is true or false, the predicate interface method is called

7
00:00:33.980 --> 00:00:37.670
test and it takes one argument and returns a boolean value.

8
00:00:39.890 --> 00:00:44.440
The generic predicates functional interface is shown below in its public interface predicate.

9
00:00:45.020 --> 00:00:49.430
We've got to type there as well because it's a generic there's a method test which returns to Berlin

10
00:00:49.670 --> 00:00:50.870
and accepts one argument.

11
00:00:52.000 --> 00:00:57.150
But switching back to coal, let's create a new class in our built in interfaces project.

12
00:00:58.520 --> 00:01:01.040
And we'll call this one perfect example.

13
00:01:09.600 --> 00:01:15.120
To this kind, it's fairly simple, it's demonstrating for examples of using the javadoc, each function,

14
00:01:15.120 --> 00:01:16.470
the predicate function.

15
00:01:17.450 --> 00:01:22.580
Looking at the first example in our main method there, the first predicate variable is not generic,

16
00:01:22.980 --> 00:01:28.740
will accept any object to lambda expression returns true regardless of what's past a value to the test

17
00:01:28.740 --> 00:01:29.070
method.

18
00:01:30.190 --> 00:01:36.490
The second predicate variable is non generic, the lambda expression returns true if the object passed,

19
00:01:36.490 --> 00:01:38.080
as the argument is no.

20
00:01:39.700 --> 00:01:44.860
So the third predicate variable is top to a billion, and the lambda expression simply passes back the

21
00:01:44.860 --> 00:01:49.030
value of the argument, whichever box to fit the returned TOPA billion.

22
00:01:49.720 --> 00:01:55.030
And the fourth predicate variable was top to string there in this example, but demonstrate using a

23
00:01:55.030 --> 00:02:01.480
full blown lambda expression with a declared parameter type in the parameter declaration using a lambda

24
00:02:01.480 --> 00:02:06.940
expression which left the right curly braces there, but turning a boolean value if we execute this

25
00:02:06.940 --> 00:02:07.360
code.

26
00:02:10.670 --> 00:02:12.440
We could see the apple screen down the bottom.

27
00:02:14.860 --> 00:02:18.820
In addition to the test method, the predicate interface provides five other methods.

28
00:02:19.030 --> 00:02:24.260
First, one of the tougher methods to fault the method signature is predicate using generic.

29
00:02:24.370 --> 00:02:30.550
It's time to end the lower bound predicate using wildcard ECPAT other.

30
00:02:31.150 --> 00:02:36.490
This represents a composed predicate that represents a short circuiting, logical end of this predicate

31
00:02:36.490 --> 00:02:39.130
and another the next type of methods default.

32
00:02:39.310 --> 00:02:40.320
The method signature.

33
00:02:40.600 --> 00:02:46.390
It's a predicate to get on top to t negate is a method, Nimish returns, a predicate that represents

34
00:02:46.390 --> 00:02:48.910
the logical negation of this predicate.

35
00:02:49.270 --> 00:02:55.660
The next type of method is also default, the predicate tintype to t or a predicate lower than, in

36
00:02:55.660 --> 00:02:58.030
other words, to say they're using the wildcard supertight.

37
00:02:58.030 --> 00:03:04.870
Other, this represents a composed predicate that represents a short circuiting logic or of this predicate

38
00:03:04.870 --> 00:03:05.470
and another.

39
00:03:07.750 --> 00:03:12.630
The teamwork at the top of method for the next one static is either predicate to using generic, so

40
00:03:12.630 --> 00:03:13.680
it's type to t there.

41
00:03:13.860 --> 00:03:16.980
So we've got a return type of T and a parameter type to T.

42
00:03:17.160 --> 00:03:19.890
Bethesda is equal and past an object.

43
00:03:20.260 --> 00:03:23.280
This returns a predicate the test of two arguments.

44
00:03:23.680 --> 00:03:29.970
Errico according to objects dot equals and the last type of static predicate type to take in return

45
00:03:29.970 --> 00:03:33.720
type of t they're not predicate meaning no apparent again.

46
00:03:33.720 --> 00:03:36.540
S wildcard super T target.

47
00:03:36.870 --> 00:03:41.250
This returns a predicate that is the negation of the supplied predicate.

48
00:03:42.340 --> 00:03:44.920
But let's bring it back to Carol, let's look at each of these in code.

49
00:03:45.370 --> 00:03:47.440
Let's start by penning some code to the main method.

50
00:03:48.600 --> 00:03:49.470
So let's go ahead and do that.

51
00:03:52.870 --> 00:03:58.450
So here what I'm doing is creating a new predicate variable, using a default method on the previously

52
00:03:58.450 --> 00:04:03.400
created predicate before the date when we execute the negated predicate.

53
00:04:03.640 --> 00:04:07.660
This should give us the opposite result from executing before that's run this code.

54
00:04:08.380 --> 00:04:15.330
You could see the output at the bottom of the screen is a more creative approach to this code, starting

55
00:04:15.340 --> 00:04:16.120
a line forty nine.

56
00:04:16.750 --> 00:04:22.180
So here I'm creating two predicate variables, each of which test the condition for an integer past.

57
00:04:22.780 --> 00:04:25.290
I also print a statement so I know what's being executed.

58
00:04:25.720 --> 00:04:31.330
I then create a third predicate variable that uses the or default method and predicate which creates

59
00:04:31.330 --> 00:04:36.190
a predicate joined by Short-circuiting or of the first two predicates.

60
00:04:36.730 --> 00:04:38.620
So let's run this and check out the results.

61
00:04:40.330 --> 00:04:45.190
So the airport confirms that both tickets were evaluated because the ditcher passed.

62
00:04:46.360 --> 00:04:51.550
You can see down there on line 62 was minus 11, well, that evaluated to three for the first predicate.

63
00:04:52.930 --> 00:04:57.640
And therefore, the second predicate needed to be evaluated to confirm the order situation.

64
00:04:59.640 --> 00:05:05.250
Now, instead of the signing, the joint predicates, using the method, let's execute the predicates

65
00:05:05.250 --> 00:05:10.380
in a predicate chain with the alternative method and the simpler code for this.

66
00:05:11.970 --> 00:05:12.720
So that's the code.

67
00:05:13.920 --> 00:05:14.640
So if I run this.

68
00:05:16.850 --> 00:05:19.490
They say we get the same test results as last time.

69
00:05:20.620 --> 00:05:26.170
They all want to actually test the short-circuiting by changing the image of postin, let's try posting

70
00:05:26.170 --> 00:05:27.130
some more code to do that.

71
00:05:31.390 --> 00:05:33.240
See the story from line 16 on there.

72
00:05:34.290 --> 00:05:35.040
So let's run this.

73
00:05:38.760 --> 00:05:40.800
And you can see the output at the bottom of the screen there.

74
00:05:41.810 --> 00:05:47.150
So from this airport, you can see that the second predicate in the chain was never evaluated since

75
00:05:47.150 --> 00:05:53.110
the result from the test provided the final result, the first predicate is false, for the first predicate

76
00:05:53.120 --> 00:05:56.570
is false for or the first predicate is true.

77
00:05:57.290 --> 00:05:59.090
You can actually chain as much as you wish.

78
00:06:00.760 --> 00:06:06.160
And some more, Candy, this now includes an escape method added to the chain, as you can see there.

79
00:06:06.640 --> 00:06:07.330
Let's run this.

80
00:06:10.100 --> 00:06:15.050
And there's the airport at the bottom of the screen that simply negates our results from the previous

81
00:06:15.050 --> 00:06:15.620
statement.

82
00:06:16.160 --> 00:06:22.650
Next, I want to show you two quick examples of using the static methods is equal and not more code

83
00:06:22.720 --> 00:06:22.850
in.

84
00:06:26.610 --> 00:06:32.220
So the first time it declares the equality test and executes the test method immediately, the second

85
00:06:32.220 --> 00:06:36.960
statement wraps a predicate in the not method and produces the opposite result.

86
00:06:37.390 --> 00:06:39.180
That's from this to confirm that is the case.

87
00:06:41.780 --> 00:06:43.250
I can see that at the bottom of the screen.

88
00:06:43.980 --> 00:06:45.320
Right, so stop the video here.

89
00:06:45.800 --> 00:06:51.500
This video in the last one, I reviewed three of the Java supplied devices, unary operator, Pinery

90
00:06:51.500 --> 00:06:56.480
operator and the Predicate family of the devices in the next couple of videos are going to be reviewing

91
00:06:56.480 --> 00:07:00.400
the function and Sheema and supplier families of devices.

92
00:07:00.800 --> 00:07:01.910
See you in the next video.
