WEBVTT
1
00:00:05.220 --> 00:00:11.680
Well, let's start exploring belted and unbelted concepts in code, so we need another test class here.

2
00:00:12.230 --> 00:00:14.150
We'll call this one test generic bandit.

3
00:00:22.150 --> 00:00:22.720
Carolyn.

4
00:00:25.110 --> 00:00:29.840
We've got a generic class, they're not bounded, called generic, not bounded, and we can see Sparerib

5
00:00:29.850 --> 00:00:35.590
would declare a in 14, but we've got to constructor's a zero and a one argument's constructed.

6
00:00:35.590 --> 00:00:37.620
They're pretty straightforward.

7
00:00:38.670 --> 00:00:44.340
We've got another class here, generic class band that this time the class is bounded by the class number.

8
00:00:44.850 --> 00:00:47.280
You can say that via the angle brackets online 30.

9
00:00:47.280 --> 00:00:52.560
We're extending the bar that's demonstrating now that the generic class and its methods that you can

10
00:00:52.560 --> 00:00:58.320
see on screen there now make available numbers members to any code using that type T.

11
00:00:59.380 --> 00:01:03.290
If we go down, we've got another class here, generic interface bound.

12
00:01:03.640 --> 00:01:09.420
You can say that using an upper bound of the comparable interface, specifically the code in the brackets

13
00:01:09.430 --> 00:01:12.070
along 44 T extends comparable.

14
00:01:12.650 --> 00:01:14.630
And you can see that we've got to do something there.

15
00:01:14.950 --> 00:01:19.750
So that's demonstrating is that this generic class and its methods, they have the comparable methods

16
00:01:19.750 --> 00:01:22.330
available to the code using type T.

17
00:01:22.820 --> 00:01:24.910
You can see an example of that in the method.

18
00:01:25.960 --> 00:01:28.980
And then we've got our public class test, generic ballot.

19
00:01:29.770 --> 00:01:34.570
This is demonstrating, creating instances of each of the above classes and frankly, some methods in

20
00:01:34.570 --> 00:01:35.410
those instances.

21
00:01:36.890 --> 00:01:41.480
So this using the Umbanda generic class, the types can be totally disparate, so you can see their.

22
00:01:42.820 --> 00:01:48.880
Sixty six below that, we've got instances of the generic class banded by number this time, so I can

23
00:01:48.880 --> 00:01:53.650
see that we've got some instances of using the generic class bounded by a number using quite an integer.

24
00:01:53.650 --> 00:02:00.490
And those examples look at some instances of the using the generic class bounded by comparable and I

25
00:02:00.490 --> 00:02:01.540
can say with passing dates.

26
00:02:01.540 --> 00:02:07.900
There is also an example here on line eighty eight, which is an idea that you can't pass a typed generic

27
00:02:07.900 --> 00:02:10.300
class to a generic class as a type argument.

28
00:02:10.780 --> 00:02:16.570
And what we're doing on this line is we've passed a generic class bound typed with integer to the generic

29
00:02:16.570 --> 00:02:18.520
class, generic, not bounded.

30
00:02:19.490 --> 00:02:20.420
But let's run this.

31
00:02:22.820 --> 00:02:24.080
Let me say, we have the of an apple.

32
00:02:25.730 --> 00:02:29.350
But let's put in some more code here and paste it down here.

33
00:02:29.610 --> 00:02:30.320
Of the main method.

34
00:02:32.160 --> 00:02:37.170
They can say by train that both of these statements are posted in have produced compile errors, so

35
00:02:37.170 --> 00:02:43.140
firstly line 91 billion is not a number and therefore doesn't satisfy the upper bound of Teagues number

36
00:02:43.500 --> 00:02:44.760
in a generic class bound.

37
00:02:46.530 --> 00:02:47.910
You can see it no, they're.

38
00:02:51.030 --> 00:02:53.260
And it's telling us as much want to hover over a top perimeter?

39
00:02:53.280 --> 00:02:56.030
Berlin is not within its should extend javadoc.

40
00:02:56.400 --> 00:02:56.730
No.

41
00:02:57.690 --> 00:03:03.510
The second example, hover over that tight perimeter javadoc length of exception is not within its bounds.

42
00:03:03.720 --> 00:03:10.650
It should implement Javadoc lameduck comparable obviously relates to our generic interface pound class

43
00:03:10.900 --> 00:03:14.400
40 44, which he can say he was set to have an upper bound of comparable.

44
00:03:14.940 --> 00:03:17.150
So let's do those two things that I've added.

45
00:03:18.000 --> 00:03:20.820
What I'm going to do is go right down to the bottom and add this.

46
00:03:21.450 --> 00:03:24.180
At this class definition, it's an out class.

47
00:03:26.510 --> 00:03:27.950
And I'm just going to accept that import.

48
00:03:30.270 --> 00:03:37.220
And say we've got classification and ego brackets extends no aposhian, comparable ampersand serializable,

49
00:03:38.160 --> 00:03:44.520
so then obviously Kampala's but if I change this to move no to the end to the end of the list there.

50
00:03:49.100 --> 00:03:54.160
No, suddenly we've got an error here in a hover over that, you get the less than helpful compiler

51
00:03:54.160 --> 00:03:56.190
error interface expected here.

52
00:03:56.500 --> 00:04:02.140
But really, no, a class must be listed as the first type in the exchange clause, noting that there's

53
00:04:02.140 --> 00:04:06.940
an option, that intelligence giving is here to move that Java, that number to the beginning of the

54
00:04:06.940 --> 00:04:08.320
band's list of top parameters.

55
00:04:08.500 --> 00:04:10.180
So it's sort of knowing that there's a problem there.

56
00:04:10.840 --> 00:04:15.250
But the reason this is happening is explained by the Oracle Java specification.

57
00:04:17.610 --> 00:04:23.910
And I'll quote part of it, The order of types in a bound is only significant in that the erasure of

58
00:04:23.910 --> 00:04:30.300
a top variable is determined by the first top in its bound and then a class type or top variable.

59
00:04:30.570 --> 00:04:32.940
They only appear in the first position.

60
00:04:34.440 --> 00:04:38.640
So I can come up here, I can click on this, that that puts it back to how it was before.

61
00:04:40.310 --> 00:04:47.510
Let's add another classiness posted in some demonstrating with this one that the upper bound declaration

62
00:04:47.510 --> 00:04:49.760
can include a generic class or interface.

63
00:04:50.370 --> 00:04:56.430
If I revised this slightly down here on the next line, just to make it a bit easier to read for another

64
00:04:56.480 --> 00:04:58.220
ampersand comparable.

65
00:05:00.860 --> 00:05:02.340
Brackets short.

66
00:05:05.630 --> 00:05:10.670
Now, once again, I've introduced a compiler error this time if we hover over a duplicate class, as

67
00:05:10.670 --> 00:05:12.560
you can see here, Javadoc Lanctot comparable.

68
00:05:13.280 --> 00:05:16.040
This is once again explained by Oracle's Java specification.

69
00:05:18.200 --> 00:05:24.740
Are quite a tight variable, must not at the same time be a subtype of two interface types which are

70
00:05:24.740 --> 00:05:31.430
different parameterization of the same generic interface or a compile time error occurs in this case

71
00:05:31.430 --> 00:05:32.400
going back to the code.

72
00:05:32.630 --> 00:05:36.740
We've got different parameterization of the comparable interface.

73
00:05:37.380 --> 00:05:40.310
Let's change this declaration completely and go back.

74
00:05:42.400 --> 00:05:46.810
Rats are going to eat all that and just commer comparable.

75
00:05:48.160 --> 00:05:53.530
So what's this declaration specifying now and what does it compile, because obviously we haven't got

76
00:05:53.560 --> 00:05:54.220
an error here now?

77
00:05:54.550 --> 00:06:00.130
I have stated earlier that the Times declared must be separated by a single aposhian, but don't let

78
00:06:00.130 --> 00:06:01.680
this declaration for you.

79
00:06:01.990 --> 00:06:08.260
It's a valid declaration, but it doesn't mean a single top argument is limited to subclasses of no

80
00:06:08.260 --> 00:06:10.480
and must implement the compatible endophytes.

81
00:06:10.930 --> 00:06:15.220
Instead, it's declaring two top parameters for this class.

82
00:06:15.490 --> 00:06:21.700
The first team, with an upper bound of the class number and the second comparable was for go back and

83
00:06:21.700 --> 00:06:24.880
make a change to this by putting in some code for the body.

84
00:06:26.340 --> 00:06:28.800
I can say by doing that, this doesn't compile.

85
00:06:30.040 --> 00:06:36.720
And it was our method comparable used in the context of this class is a type parameter and in its current

86
00:06:36.720 --> 00:06:42.210
context has nothing to do with the comparable interface you could set comparable to any type you want,

87
00:06:42.210 --> 00:06:44.430
including types that do not implement comparable.

88
00:06:45.030 --> 00:06:46.410
It's deceptive and hard to catch.

89
00:06:46.420 --> 00:06:49.440
So you can expect something like this as an exam question.

90
00:06:50.140 --> 00:06:53.880
Let's just remove this last class from our code so that everything compiles.

91
00:06:55.970 --> 00:07:00.680
What are the above examples in the last few videos have shown examples of generic classes with one or

92
00:07:00.680 --> 00:07:06.920
many top perimeter's up, discuss the coding conventions for specifying top parameters, have also shown

93
00:07:06.920 --> 00:07:09.500
you how to declare an upper bound for your top parameter.

94
00:07:10.040 --> 00:07:15.050
In addition, we've talked about the benefits of generic classes as well as the limitations on their

95
00:07:15.050 --> 00:07:15.520
usage.

96
00:07:16.340 --> 00:07:17.900
Before we move on to generic methods.

97
00:07:18.110 --> 00:07:22.640
I want to see if I can clarify what type of Rasiah is, since I referred to it several times.

98
00:07:25.360 --> 00:07:30.520
Generics are introduced to the Jaba language to provide benefits to the programer in the form of titre

99
00:07:30.520 --> 00:07:36.310
type checks at compile time, as well as support for generic programming in the Chevy if they do not

100
00:07:36.310 --> 00:07:36.770
exist.

101
00:07:37.570 --> 00:07:43.060
The process of converting source code, which makes use of generic classes and methods to code executed

102
00:07:43.060 --> 00:07:47.500
in the same fashion as prior to the existing of generics is called type erasure.

103
00:07:48.160 --> 00:07:52.360
Developer does not have to do anything to make type erasure occur or not occur.

104
00:07:52.660 --> 00:07:56.790
It will occur, but knowledge of the limitations imposed by the process is important.

105
00:07:58.930 --> 00:08:04.690
To implement generics, the Java compiler firstly replaces all type parameters in generic classes with

106
00:08:04.690 --> 00:08:11.500
object or bound to the first object type, which would say must be a class if the class is in the list

107
00:08:11.710 --> 00:08:18.760
or could be an interface type that produced bytecode, therefore contains only ordinary classes, interfaces

108
00:08:18.760 --> 00:08:19.420
and methods.

109
00:08:20.140 --> 00:08:25.520
Secondly, the Java compiler inserts typecasts, if necessary, to preserve type safety.

110
00:08:25.900 --> 00:08:32.500
Thirdly, the Java compiler generates bridge methods to preserve polymorphism in extended generic types

111
00:08:32.740 --> 00:08:33.480
and forth.

112
00:08:33.700 --> 00:08:40.330
The Java compiler keeps generics related information as metadata in the bytecode for debugging and reflection

113
00:08:40.330 --> 00:08:40.920
purposes.

114
00:08:43.610 --> 00:08:48.870
I've discussed some of the limitations imposed on generics because of type of a generic class cannot

115
00:08:48.880 --> 00:08:55.510
extend Strobl, you cannot instantiate a parameters type directly, etc. We'll be running across a few

116
00:08:55.510 --> 00:08:56.470
more as we move forward.

117
00:08:56.950 --> 00:08:59.210
But this has been a long series of videos.

118
00:08:59.210 --> 00:09:00.430
So let's end the video here.

119
00:09:00.700 --> 00:09:03.570
And in the next one, I'm going to be explaining generic methods.

120
00:09:03.580 --> 00:09:04.360
So let's move on.
