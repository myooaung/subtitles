WEBVTT
1
00:00:05.280 --> 00:00:10.980
Robots are continuing on with our discussions about various rules, the method overriding and so forth,

2
00:00:11.380 --> 00:00:14.310
let's create a new class and call it clashing methods.

3
00:00:14.310 --> 00:00:18.060
And what we're going to do is test out some of these statements that are made in code.

4
00:00:20.860 --> 00:00:21.760
Crushing method's.

5
00:00:28.050 --> 00:00:33.150
Right, I can see here with this code for clashing methods, what I've done is started off with first

6
00:00:33.150 --> 00:00:37.250
interface, which is an interface with a private method called Bhattarai.

7
00:00:38.010 --> 00:00:43.770
You've got a second interface called Second Interface, which has a static method method I obviously

8
00:00:43.770 --> 00:00:49.920
implied to be public as well as fairly the class clashing methods simply called the static method on

9
00:00:49.920 --> 00:00:50.550
the interface.

10
00:00:51.720 --> 00:00:52.440
So let's run that.

11
00:00:56.490 --> 00:01:01.320
You can say we get the relevant output consistent with the code being executed from Laurine 18.

12
00:01:03.890 --> 00:01:08.360
So let's test some statements I made in the previous video relating to a method and an interface, whether

13
00:01:08.360 --> 00:01:15.380
it's public, which is implied on an interface and static, specifically, does the static method override

14
00:01:15.380 --> 00:01:18.740
a super interfaces default method because this is not permitted.

15
00:01:19.610 --> 00:01:23.420
So let's start by adding an extended clause to our second interface.

16
00:01:23.450 --> 00:01:25.160
So we're going to extend this interface.

17
00:01:28.670 --> 00:01:30.470
They because the method method I.

18
00:01:31.550 --> 00:01:37.490
In our first devices, private is still valid, but let's test the invalid scenario, so to do that,

19
00:01:37.790 --> 00:01:40.380
we need to change first interfaces today.

20
00:01:40.770 --> 00:01:43.130
We'll change that from private to default.

21
00:01:45.280 --> 00:01:50.680
And after that, there's a component of their static method, detonate in second interface, cannot

22
00:01:50.680 --> 00:01:54.100
override instance method method, a insert interface.

23
00:01:54.920 --> 00:01:59.610
So basically a static method cannot override a default method of a super interface.

24
00:02:00.130 --> 00:02:01.800
But let's get back up to our first interface.

25
00:02:01.810 --> 00:02:04.480
We've got to change that again to be static specifically.

26
00:02:06.780 --> 00:02:11.130
And this is fine, because the super interface is static, method is not inherited.

27
00:02:13.430 --> 00:02:19.550
All right, so moving on, let's now consider this question, is the static method being invoked outside

28
00:02:19.550 --> 00:02:22.720
of the interface type without using the interface type qualifier?

29
00:02:23.270 --> 00:02:26.450
And its so again, this is not permitted to the test this.

30
00:02:26.450 --> 00:02:32.450
We're going to start by changing the clear clashing methods class to extend the second interface in

31
00:02:32.450 --> 00:02:32.750
here.

32
00:02:34.670 --> 00:02:40.730
Sorry to implement it extends implements second interface, and they will come down at some code to

33
00:02:40.730 --> 00:02:47.450
the main method, first thought method, I you could probably say yes, I was taught me that we weren't

34
00:02:47.450 --> 00:02:48.710
getting any help for intelligence.

35
00:02:49.400 --> 00:02:52.310
This is telling us that this time it is the cause of a compiler error.

36
00:02:52.820 --> 00:02:53.570
Can't find method.

37
00:02:53.570 --> 00:02:59.840
I basically cannot call a static method on an interface through an instance of an object, including

38
00:03:00.140 --> 00:03:01.430
using the disqualifier.

39
00:03:01.730 --> 00:03:07.340
Even when the objects class implements the interface, you must always qualify the method with its interface

40
00:03:07.340 --> 00:03:11.810
type, as I've done on line twenty six and do this.

41
00:03:15.820 --> 00:03:21.730
All right, so moving on, let's test each of these statements, is the interface method a default method?

42
00:03:22.030 --> 00:03:25.120
Yes, answers to any of the following questions are compile time errors.

43
00:03:25.780 --> 00:03:30.190
Firstly, does it override any of Javadoc Langdell objects, public methods or.

44
00:03:30.190 --> 00:03:32.880
We reviewed this in the previous video right at the start.

45
00:03:32.900 --> 00:03:33.940
The first code sample.

46
00:03:34.150 --> 00:03:35.500
So I won't repeat myself here.

47
00:03:37.760 --> 00:03:43.220
But the second one is, does it clash with an unrelated interfaces default method signature in an implement

48
00:03:43.220 --> 00:03:43.760
clause?

49
00:03:44.210 --> 00:03:47.090
So let's look at this question next to the staff.

50
00:03:47.090 --> 00:03:48.650
We need to change our interfaces.

51
00:03:49.280 --> 00:03:54.290
I'm going to change the first interface, the method to become default instead of static.

52
00:03:56.510 --> 00:04:01.910
And for the second interface, I want to remove the extensive first interface now, and I want to make

53
00:04:01.910 --> 00:04:02.920
this to folks as well.

54
00:04:06.480 --> 00:04:10.890
So looking at this now, these two interfaces have no relationship, so let's keep moving on.

55
00:04:11.340 --> 00:04:17.040
So let's change the declaration of the clashing methods to implement both first and second interfaces.

56
00:04:21.360 --> 00:04:27.720
And we also need to change this law before we look at the era on 20 to no longer calling a static method,

57
00:04:28.150 --> 00:04:31.770
change it to first it was to find reform that works.

58
00:04:32.350 --> 00:04:34.710
But we have got a pilot error on the declaration of the class.

59
00:04:34.710 --> 00:04:41.490
The classic method inherits unrelated defaults for Mithril from Type's first interface and second interface.

60
00:04:42.270 --> 00:04:42.570
All right.

61
00:04:42.570 --> 00:04:45.060
So let's remove the second interface from the class implements.

62
00:04:48.920 --> 00:04:55.700
But let's now test this statement, is the default method being invoked directly in a static context?

63
00:04:57.090 --> 00:05:00.410
And we did actually see that so we could just make that method, I.

64
00:05:01.360 --> 00:05:07.150
Not static method method, I cannot be referenced from a static context, compiler error, because default

65
00:05:07.150 --> 00:05:11.610
methods are instant's methods and cannot be invoked from a static context.

66
00:05:11.620 --> 00:05:14.050
In this case, it's the static main method.

67
00:05:16.560 --> 00:05:22.590
But finally, let's test out these statements, firstly, method selection is prioritized, determine

68
00:05:22.590 --> 00:05:27.630
what classes are in the hierarchy of the class, where the method is being invoked and what interfaces

69
00:05:27.780 --> 00:05:33.360
are in the hierarchy and the implements clause remembering that a class method is selected first.

70
00:05:33.690 --> 00:05:36.660
The more specific interfaces method is selected next.

71
00:05:37.000 --> 00:05:41.690
And if there is a crash, it must provide an implementation of the method in the class.

72
00:05:42.630 --> 00:05:47.730
So I'm going to undo that last error and we're going to create a new class here called this one method

73
00:05:47.730 --> 00:05:48.360
selection.

74
00:05:55.470 --> 00:05:56.580
Code is the code.

75
00:05:58.110 --> 00:06:03.950
So this card contains, firstly, a class called super class with a single public method to something,

76
00:06:03.960 --> 00:06:04.660
as you can see there.

77
00:06:05.250 --> 00:06:09.900
We've got an interface called less specific interface with a default method.

78
00:06:09.900 --> 00:06:13.110
Do something with the same signature as the super classes.

79
00:06:13.110 --> 00:06:18.690
Do something method if you on down, we've got another interface code, more specific interface, which

80
00:06:18.690 --> 00:06:22.920
extends the less specific interface and also has a default method.

81
00:06:22.930 --> 00:06:29.070
Do something with the same signature as the superclass class and the interface code, a specific interface.

82
00:06:29.640 --> 00:06:30.880
And also we go down.

83
00:06:30.930 --> 00:06:35.940
We've got a public class here, method selection, and you can see that that extends our super class

84
00:06:35.940 --> 00:06:41.700
called super class and implements the more specific interface with an instance method which invokes

85
00:06:41.700 --> 00:06:42.660
the method to something.

86
00:06:43.410 --> 00:06:49.440
So the question at this point in the method call on line thirty four, which method is being called?

87
00:06:52.200 --> 00:06:57.900
If you recall the questions, a class method is selected first, so let's promise to confirm that is

88
00:06:57.900 --> 00:06:58.370
the case.

89
00:07:00.740 --> 00:07:06.350
And you can see that's confirmed is the code from our superclass, do something, it's being executed.

90
00:07:06.950 --> 00:07:11.150
So let's now have a go at changing the declaration of the method selection class.

91
00:07:13.300 --> 00:07:17.690
We can remove the extended clause, but leaving the implements to the more specific interface.

92
00:07:19.060 --> 00:07:22.210
So you can say now just implements the more specific interface.

93
00:07:24.910 --> 00:07:30.540
So citruses, the next point that the more specific interface method is selected next is check that

94
00:07:30.730 --> 00:07:31.660
if that's the case.

95
00:07:33.910 --> 00:07:39.550
More specific to something, Senator, more specific interfaces, interface output line twenty 22,

96
00:07:39.550 --> 00:07:42.760
showing that the do something method in that interface was invoked.

97
00:07:43.900 --> 00:07:48.210
Let's now make a change again to our method declaration on line twenty six.

98
00:07:48.460 --> 00:07:50.320
We're going to implement both interfaces.

99
00:07:50.320 --> 00:07:55.900
So I'm going to put less specific interface comma just across the two lines are more readable.

100
00:07:56.320 --> 00:07:58.090
So we're now implementing both interfaces.

101
00:07:58.690 --> 00:08:03.610
If we run this again, we're trying to confirm that the method, the more specific interface method

102
00:08:03.610 --> 00:08:04.450
should be selected.

103
00:08:04.990 --> 00:08:05.800
And if we run this.

104
00:08:09.480 --> 00:08:15.870
You see, we've still got a more specific interface do something method being invoked here, so it confirms

105
00:08:15.870 --> 00:08:19.980
that the method in that interface is still selected, even if both interfaces are implemented, which

106
00:08:19.980 --> 00:08:20.670
was the case here.

107
00:08:20.880 --> 00:08:26.220
And again, bearing in mind we have got a relationship there because the more specific interface is

108
00:08:26.220 --> 00:08:28.300
extending the less specific interface.

109
00:08:28.330 --> 00:08:29.260
So that's why we were checking.

110
00:08:29.730 --> 00:08:34.320
Now we've got to remove the relationship between more specific interface and less specific interface

111
00:08:34.770 --> 00:08:36.300
by removing this extends Claw's.

112
00:08:38.500 --> 00:08:41.590
By doing that, you probably have seen that there was an error that popped up immediately.

113
00:08:46.100 --> 00:08:50.870
And this relates to the point that if there is a clash, you must provide an implementation of the method

114
00:08:51.020 --> 00:08:57.170
in the class and the area here with a selection inherits unrelated to do something from type's less

115
00:08:57.170 --> 00:09:00.350
specific interface and more specific interface.

116
00:09:00.680 --> 00:09:05.840
So you can see now that this change introduced a compiler error on the class declaration of method selection.

117
00:09:06.380 --> 00:09:09.500
Method selection inherits the unrelated defaults to something.

118
00:09:11.040 --> 00:09:15.330
So you might think that we can change the Caldari something method to do something about this.

119
00:09:16.750 --> 00:09:18.880
Say less specific interface.

120
00:09:19.890 --> 00:09:20.470
Super.

121
00:09:22.870 --> 00:09:24.610
Dot, do something.

122
00:09:25.810 --> 00:09:27.600
But alas, it doesn't fix the error.

123
00:09:28.470 --> 00:09:34.710
So problem, in fact, what we need to do is create a method that overrides the classic method, even

124
00:09:34.710 --> 00:09:41.640
if that method does nothing to do that to a public void, do something.

125
00:09:42.960 --> 00:09:44.700
And literally it's going to be empty.

126
00:09:45.360 --> 00:09:49.560
By doing that, you can say now the compiler errors disappeared, we can run the code.

127
00:09:53.260 --> 00:09:57.880
And we could check out the less specific interfaces method was called, and that's because of what we

128
00:09:58.180 --> 00:10:02.520
were taught target specific interface, not super to do something online, 34.

129
00:10:03.040 --> 00:10:04.920
So this is the end of the video next year.

130
00:10:04.930 --> 00:10:08.770
Going to be presented with a couple of quick questions and we're going to move on to the generics and

131
00:10:08.770 --> 00:10:09.700
collections section.

132
00:10:10.390 --> 00:10:13.210
Good luck and I'll see you after the quiz in the next section.
