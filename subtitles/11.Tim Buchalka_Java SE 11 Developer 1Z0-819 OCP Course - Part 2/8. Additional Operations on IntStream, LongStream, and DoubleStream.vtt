WEBVTT
1
00:00:05.190 --> 00:00:09.480
All right, so moving on from the card we're working on at the end of the last video, can you get us

2
00:00:09.480 --> 00:00:11.340
some without using any stream?

3
00:00:11.970 --> 00:00:15.890
The answer to this is yes, using the reduced method on stream.

4
00:00:16.290 --> 00:00:16.550
So what?

5
00:00:16.560 --> 00:00:17.970
I added some code to our follow.

6
00:00:18.390 --> 00:00:20.640
This is the same code we're working on in the last video.

7
00:00:20.910 --> 00:00:26.730
We got to replace the last laptop print and here is Kasoulides 67 or 68 with this code.

8
00:00:27.180 --> 00:00:31.380
So here's what I'm doing is I'm passing the method reference into charcoal and color on some to the

9
00:00:31.380 --> 00:00:37.920
reduced method on stream, which accepts a binary operator and returns an optional if we run this code.

10
00:00:40.940 --> 00:00:45.980
We can see the airport there, the proof that something data either way produces the desired result.

11
00:00:46.790 --> 00:00:49.000
And again, we'll get randomized results each time we run it.

12
00:00:50.700 --> 00:00:56.340
The single argument produced methods that are just used as the definition performs a reduction on the

13
00:00:56.340 --> 00:01:03.120
elements of this strain using an associative accumulation function and returns an optional describing

14
00:01:03.120 --> 00:01:04.440
the reduced value, if any.

15
00:01:05.250 --> 00:01:07.980
So what is an associative accumulation function?

16
00:01:08.730 --> 00:01:13.890
Well, in this case, I know it's a binary operator, an integer column called Some fits the bill,

17
00:01:14.340 --> 00:01:15.660
but what does this really mean?

18
00:01:16.530 --> 00:01:17.700
Looking back, it occurred again.

19
00:01:18.700 --> 00:01:21.280
This replaced the last calculation method reference.

20
00:01:22.650 --> 00:01:29.190
Here on line 67, ombuds, with a lambda expression, so it might not be obvious, but what is happening

21
00:01:29.190 --> 00:01:29.430
here?

22
00:01:30.240 --> 00:01:33.820
What are they A and B parameters in the lambda expression that I've just pasted in?

23
00:01:34.500 --> 00:01:37.080
Let's run this first to confirm that it works.

24
00:01:38.880 --> 00:01:43.390
They can see that it still works to better clarify what's going on here.

25
00:01:43.900 --> 00:01:45.270
That's in another version.

26
00:01:45.870 --> 00:01:48.960
Well, overall, there was some reduced definition again.

27
00:01:50.550 --> 00:01:55.710
So here I've simply changed the names of the binary operator parameter, which lends clarity to what

28
00:01:55.710 --> 00:01:57.360
the accumulation function's doing.

29
00:01:58.020 --> 00:02:04.050
The value of the current element is being added to a running total, which is being stored in memory.

30
00:02:04.320 --> 00:02:10.950
While the pipeline is processing, the accumulator function takes two parameters, a partial result

31
00:02:10.950 --> 00:02:13.740
of the reduction and the next element of the stream.

32
00:02:14.040 --> 00:02:17.680
In this example, an integer and returns a new partial result.

33
00:02:18.090 --> 00:02:22.190
So let's run this, confirming that things are still working.

34
00:02:24.220 --> 00:02:30.370
A type of combat to put on screen lists, additional operations on the three streams in stream, long

35
00:02:30.370 --> 00:02:36.400
stream and double stream, which are not supported or have different signatures, Min and Max from the

36
00:02:36.400 --> 00:02:37.330
stream versions.

37
00:02:37.930 --> 00:02:42.640
All of these operations are terminal operations, with the exception of the static methods, range and

38
00:02:42.640 --> 00:02:43.480
range closed.

39
00:02:43.810 --> 00:02:49.720
So the first operation average return type is an option of double and it returns an optional double

40
00:02:49.720 --> 00:02:55.720
describing the arithmetic mean of elements of this stream or an empty optional if the stream is empty

41
00:02:56.020 --> 00:03:00.520
max return type optional int or an optional log or an optional double.

42
00:03:00.970 --> 00:03:04.880
The result corresponds to the top of the invoking stream in stream returns optional.

43
00:03:04.880 --> 00:03:06.370
The long stream returns optional.

44
00:03:06.370 --> 00:03:09.040
Long and double stream returns optional double.

45
00:03:10.090 --> 00:03:15.910
I mean, very similar, the same return types and the result of using mean corresponds to the same types

46
00:03:16.210 --> 00:03:22.300
or invoking streams that we talked about for Max Sum, the return to I said it along or a double, and

47
00:03:22.300 --> 00:03:24.630
the result corresponds to the top of the invoking stream.

48
00:03:25.350 --> 00:03:30.430
Its stream returns and it long stream returns, a long and double stream returns a double.

49
00:03:30.940 --> 00:03:32.800
We've got the box method return.

50
00:03:32.800 --> 00:03:39.050
Top is a stream of tea, so it returns a stream consisting of the elements of the stream each box to

51
00:03:39.070 --> 00:03:44.440
an integer along or double corresponding to the invoking stream in stream, long stream or double stream.

52
00:03:44.830 --> 00:03:49.470
Next, we have the range method for our operations, noting that there's two versions here.

53
00:03:49.840 --> 00:03:57.040
We've got one excepting two parameters starting collusive and end exclusive, and the other one has

54
00:03:57.040 --> 00:04:00.790
parameters of logs that inclusive and long and exclusive.

55
00:04:01.270 --> 00:04:07.330
The return type is either stream or long stream as appropriate, and it returns a sequential ordered

56
00:04:07.330 --> 00:04:13.750
in stream along stream from start inclusive, inclusive to end exclusive exclusive by an incremental

57
00:04:13.750 --> 00:04:14.350
step of one.

58
00:04:14.770 --> 00:04:16.930
And note there, that stream doesn't have this method.

59
00:04:17.950 --> 00:04:20.260
Next, we have arranged closed operations.

60
00:04:20.710 --> 00:04:26.440
We've got the parameters there to start inclusive and inclusive, 13, that's different to range, which

61
00:04:26.440 --> 00:04:28.120
was and exclusive.

62
00:04:28.240 --> 00:04:33.670
So we've got one thing and also an equivalent one using long the return type as an extreme or a long

63
00:04:33.670 --> 00:04:34.660
stream as appropriate.

64
00:04:34.780 --> 00:04:41.920
And it returns a sequential ordered stream along stream from start inclusive, inclusive to and inclusive

65
00:04:41.920 --> 00:04:47.770
again inclusive by an incremental step of one important distinction between that and the range method.

66
00:04:48.580 --> 00:04:50.440
The last one, the last method of operation.

67
00:04:50.440 --> 00:04:51.790
There is summary statistics.

68
00:04:52.010 --> 00:04:57.280
We've got either an end summary statistics, a long summary statistics or a double summary statistics

69
00:04:57.670 --> 00:05:02.710
sort of turns one of the three describing various summary data about the elements of the stream, depending

70
00:05:02.710 --> 00:05:03.400
on the type.

71
00:05:04.000 --> 00:05:05.920
This is a special case of a reduction.

72
00:05:06.340 --> 00:05:11.110
Let's do a quick review of these in a new class and we'll call this one primitive streams.

73
00:05:20.200 --> 00:05:26.530
So looking at this code in our main method, we're creating an extreme using extreme range and invoking

74
00:05:26.530 --> 00:05:31.930
the terminal operations summary statistics, pointing out the result, which is an end summary statistic.

75
00:05:32.350 --> 00:05:37.870
Next, we're creating a long stream using long stream range closed and we're invoking the terminal operations

76
00:05:37.870 --> 00:05:42.400
summary statistics pointing out the result in this case will be a long summary statistic.

77
00:05:43.560 --> 00:05:49.020
And the third example, creating a double stream there were using double stream iterate and invoking

78
00:05:49.020 --> 00:05:53.460
the terminal operations summary statistics, putting out the result, which in this case is a double

79
00:05:53.460 --> 00:05:53.790
summary.

80
00:05:53.790 --> 00:05:55.650
Statistics running the code.

81
00:05:57.300 --> 00:06:02.520
We can see the output at the bottom of the screen so that the calling range is exclusive of the second

82
00:06:02.520 --> 00:06:02.920
argument.

83
00:06:03.180 --> 00:06:08.880
So calling it with range one, comma ten gives us a list of integers from one through nine calling range

84
00:06:08.880 --> 00:06:12.720
to close to one come a ten gave a list of lungs from one to 10.

85
00:06:13.050 --> 00:06:17.140
Its second argument is inclusive as possible, carried in here.

86
00:06:19.800 --> 00:06:27.210
So this kind of pasted in demonstrates some of the reduction operations min max average as well as some.

87
00:06:27.840 --> 00:06:28.440
Let's run that.

88
00:06:30.870 --> 00:06:36.690
So the output here shows that depending on the type of stream and the operation used, the type of the

89
00:06:36.690 --> 00:06:37.630
result is different.

90
00:06:38.190 --> 00:06:43.350
The average method always returns an option double regardless of the type of stream.

91
00:06:43.920 --> 00:06:50.100
The same method returns a primitivist long or double that corresponds to the type of stream the min

92
00:06:50.100 --> 00:06:56.040
and max methods return an optional int optional long or optional double corresponding to the top stream

93
00:06:56.040 --> 00:06:58.560
being in its stream long stream or double stream.

94
00:06:59.730 --> 00:07:01.170
Append one last bit of code.

95
00:07:04.060 --> 00:07:05.040
Except that import.

96
00:07:07.750 --> 00:07:12.890
Now, obviously, there are parentheses and a semicolon to close that off.

97
00:07:13.850 --> 00:07:19.580
So this is showing you how to transform from a stream of type integer to an extreme using map to it.

98
00:07:20.000 --> 00:07:23.060
And how to go the other way is in the boxed operation.

99
00:07:23.570 --> 00:07:27.730
I'm transforming again using map to double, which makes a stream a double stream.

100
00:07:28.350 --> 00:07:33.690
So if you run this now, you can see the output at the bottom of the screen.

101
00:07:34.280 --> 00:07:39.380
Some of this video and the previous one, I've reviewed simple calculations that you can make which

102
00:07:39.380 --> 00:07:41.300
aggregate information on a stream.

103
00:07:41.920 --> 00:07:46.550
I'm going to be discussing more complicated reductions in more detail in the video on collectors' and

104
00:07:46.550 --> 00:07:46.960
grouping.

105
00:07:46.970 --> 00:07:50.900
But first, let's review sorting on a stream in the next video.
