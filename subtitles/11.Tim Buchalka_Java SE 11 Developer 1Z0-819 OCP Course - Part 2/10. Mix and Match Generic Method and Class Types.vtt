WEBVTT
1
00:00:05.360 --> 00:00:10.880
Or it continuing on from the last period, we're going to mix and match generic method type parameters,

2
00:00:11.030 --> 00:00:14.480
a generic class type perimeter's, we need a new class for that.

3
00:00:14.480 --> 00:00:16.790
And we're going to place that into this existing source for.

4
00:00:18.930 --> 00:00:20.580
Well, I study this class for a moment.

5
00:00:21.620 --> 00:00:27.410
So basically, it's a generic class with generic methods, the class, the class to type parameters,

6
00:00:27.950 --> 00:00:34.850
personality with an upper bound using the interface comparable meaning it can only be instantiated with

7
00:00:34.850 --> 00:00:39.230
a type that implements comparable and also you which accepts any type.

8
00:00:39.800 --> 00:00:44.660
Scotter instance variables went ahead with a parameter type you to be defined.

9
00:00:44.660 --> 00:00:47.790
When the instance is created, the one declares top no.

10
00:00:48.560 --> 00:00:49.960
So I got a constructor there.

11
00:00:50.150 --> 00:00:51.080
Line ninety six.

12
00:00:51.770 --> 00:00:57.230
Now the constructor is a generic method which declares one parameter type with an upper bound of no

13
00:00:57.500 --> 00:00:57.860
meaning.

14
00:00:57.860 --> 00:01:02.950
Only a number or a subtype of no can be used for this constructor argument.

15
00:01:03.620 --> 00:01:06.710
The first constructor argument uses one of the class type parameters.

16
00:01:06.710 --> 00:01:07.100
You.

17
00:01:08.240 --> 00:01:09.470
Scroll down a bit further.

18
00:01:10.010 --> 00:01:16.310
We've got this public generic instance method on line 111, so this method declares two parameter types.

19
00:01:16.640 --> 00:01:22.580
We've got X, which is unbounded and W that has an upper bound of list with X in angle brackets.

20
00:01:22.610 --> 00:01:23.420
So what does that mean?

21
00:01:24.390 --> 00:01:29.580
But we're declaring a relationship between our two method perimeter types, indicating that whatever

22
00:01:29.580 --> 00:01:35.160
type X is declared as the least represented by the W type must be a list of X..

23
00:01:35.790 --> 00:01:38.880
In addition, the method uses two of the class parameters, T.

24
00:01:39.360 --> 00:01:40.420
S method parameters.

25
00:01:40.650 --> 00:01:44.730
Remember that the class is declared that T must implement comparable.

26
00:01:46.510 --> 00:01:54.610
Appear online so we can use comparables, compare to method on the method arguments of Type T, then

27
00:01:54.610 --> 00:02:00.280
the method returns a value of type X type, which the list elements all are required to be well.

28
00:02:00.400 --> 00:02:04.210
So let's open some code to the main method of the generics comparison class.

29
00:02:05.680 --> 00:02:06.760
It'll come back up and do that.

30
00:02:08.590 --> 00:02:09.550
That's the kind of up here.

31
00:02:11.350 --> 00:02:16.690
President Obama, the mind method, OK, there it is, not a scroll up a bit, so I'm starting by creating

32
00:02:16.690 --> 00:02:22.690
two strings, bearing in mind that string implements comparable and then creating an instance of the

33
00:02:22.690 --> 00:02:27.090
combined class with type string for tea and byte for you.

34
00:02:27.760 --> 00:02:34.350
And then I call the constructor passing a bite for you and an integer for method type V.

35
00:02:35.170 --> 00:02:38.380
Now that we've created it, I'm invoking the generic method.

36
00:02:38.620 --> 00:02:45.100
Get comparison results online only for passing the two strings as well as a list of strings, effectively

37
00:02:45.460 --> 00:02:51.580
noting here that x the parameter type is inferred to be a string and the W parameter top is the third

38
00:02:51.580 --> 00:02:57.130
to be a list of strings effectively taken that relates back to the K that we pasted in here.

39
00:02:57.970 --> 00:03:00.610
Adlard one twenty results from that.

40
00:03:06.250 --> 00:03:08.740
And again, this was the code that was being invoked.

41
00:03:10.640 --> 00:03:13.460
Now that you've done that, let's try another set of top arguments.

42
00:03:13.900 --> 00:03:16.100
What are we going to do is a pencil code to the main method.

43
00:03:16.550 --> 00:03:18.140
It's going to sit it down here below.

44
00:03:21.600 --> 00:03:26.370
Now, what I'm doing here is I'm creating an instance of the combined class with types, integer for

45
00:03:26.370 --> 00:03:33.570
T, string for you, and I'm calling the constructor notat and passing the constructor string that represents

46
00:03:33.570 --> 00:03:35.110
you and a bite.

47
00:03:35.400 --> 00:03:37.920
This represents the constructor's type parameter V.

48
00:03:38.930 --> 00:03:45.020
I've got a couple of very local variables, the finding there and then invoking the generic method comparison

49
00:03:45.020 --> 00:03:50.630
results this time when they're comparing integers, I won and I to run this code.

50
00:03:53.680 --> 00:03:58.420
And you could see the result, so this example, I hope you've seen the generics allow you to design

51
00:03:58.420 --> 00:04:04.690
typing specifications into your class using a combination of generic class type parameters with generic

52
00:04:04.690 --> 00:04:08.680
methods, which also permit you to apply some type relationship rules.

53
00:04:08.980 --> 00:04:12.880
I think he can also say that it quickly gets confusing looking at code like this.

54
00:04:15.760 --> 00:04:18.100
Which the exam questions are certain to exploit.

55
00:04:18.490 --> 00:04:23.050
I'll be discussing additional examples in the video on out of ordinary items in this section.

56
00:04:23.440 --> 00:04:29.560
But first, though, let's ask when and why would you create just a generic method, a demonstrated

57
00:04:29.560 --> 00:04:30.340
one example?

58
00:04:30.640 --> 00:04:35.170
Well, we wanted the list past to our method to be the least of the same type as the return type of

59
00:04:35.170 --> 00:04:35.630
the method.

60
00:04:36.070 --> 00:04:37.510
Let's look at another example.

61
00:04:37.930 --> 00:04:42.700
If you're familiar with the term you are comparing apples with oranges, then you might appreciate the

62
00:04:42.730 --> 00:04:46.850
generic methods are a way of preventing the comparison of apples with oranges.

63
00:04:47.380 --> 00:04:54.310
So let's consider the calm about to adhere to a new class for this because new one generic methods.

64
00:05:07.460 --> 00:05:13.330
What I can see here, firstly, we've got a Apple class and an orange class, which both implement the

65
00:05:13.330 --> 00:05:19.970
comparable interface using using generics for the specific type apple and orange, the scrolling further.

66
00:05:19.990 --> 00:05:25.210
We've got another class here, green apple that extends Apple but doesn't directly implement the comparable

67
00:05:25.210 --> 00:05:25.810
interface.

68
00:05:27.220 --> 00:05:29.100
Also the generic methods class.

69
00:05:29.550 --> 00:05:34.480
We've got to compare object's method that accepts two parameters of any type that both objects, as

70
00:05:34.480 --> 00:05:35.070
you can see a lot.

71
00:05:35.080 --> 00:05:38.050
Forty four include some limited type checking code.

72
00:05:38.270 --> 00:05:44.140
If both objects implement comparable I pair comparables, which is the method following below.

73
00:05:44.740 --> 00:05:49.390
And I note that the comment on line forty six is not extensible or easily maintainable the way you've

74
00:05:49.390 --> 00:05:50.820
written this custom type checking.

75
00:05:51.430 --> 00:05:56.920
So our compare comparables method that I talked about, it's a method to compare any object implemented

76
00:05:56.920 --> 00:06:02.800
comparable excepting two parameters of any type that implement comparable.

77
00:06:03.340 --> 00:06:04.900
They've got some more top checking here.

78
00:06:05.150 --> 00:06:09.130
I'm assuming it's the first object is one type that the second is the same type.

79
00:06:09.390 --> 00:06:15.490
But as you can say, within returning a call to compare to for the relevant type of this other method

80
00:06:15.490 --> 00:06:17.650
here, compare matching types.

81
00:06:18.400 --> 00:06:23.950
This is a generic method that expands on the previous method, but enforces by specifying method type

82
00:06:23.950 --> 00:06:28.540
parameters that the two parameters must have a matching type within their class.

83
00:06:28.540 --> 00:06:34.000
Hierarchy is obviously the code is a lot shorter, but also forces that the two parameters must have

84
00:06:34.000 --> 00:06:39.730
the matching type within their class hierarchy by specifying the method top parameters they can see

85
00:06:39.730 --> 00:06:43.420
the method there has got various calls to those various methods.

86
00:06:43.540 --> 00:06:44.380
So let's run the code.

87
00:06:51.850 --> 00:06:55.960
All right, let's put some more code into my method so you can see we're trying to do, you know, compile

88
00:06:55.960 --> 00:06:58.600
time that you cannot compare apples and oranges, but still you try.

89
00:06:58.630 --> 00:07:01.590
So let's actually try doing that apples.

90
00:07:01.600 --> 00:07:02.080
Fine.

91
00:07:02.540 --> 00:07:03.400
If you run the code.

92
00:07:05.630 --> 00:07:07.370
The Karak runtime error.

93
00:07:10.980 --> 00:07:16.620
So we can expect to compare comparables will encounter the same exception since the exception was thrown

94
00:07:16.620 --> 00:07:20.250
after invoking this method from compare objects on their.

95
00:07:24.600 --> 00:07:26.490
As possible, cut into our mind, MyFord.

96
00:07:29.510 --> 00:07:33.260
And the bottom actually will replace that because we know that it crushes.

97
00:07:34.610 --> 00:07:37.040
And you can see they're trying to compare apples to oranges.

98
00:07:37.490 --> 00:07:41.390
We've got a compiler error, which is actually a better outcome than a runtime error.

99
00:07:41.570 --> 00:07:45.610
And that's because we don't even allow the attempt to compare two disparate types to occur.

100
00:07:46.400 --> 00:07:50.240
And you can see that specifically saying require a top apple provider with orange.

101
00:07:51.230 --> 00:07:52.610
We're back to a code we had that works.

102
00:07:55.260 --> 00:08:00.510
The best description of Fair went to use generic methods is tucked into a middle of a Java tutorial.

103
00:08:00.840 --> 00:08:06.840
There's a link on screen on generic methods if we swing over to it now to show you the page of the browser

104
00:08:06.840 --> 00:08:08.610
quickly, that's the link.

105
00:08:08.610 --> 00:08:09.720
And it's in the resources sector.

106
00:08:09.750 --> 00:08:10.890
If you want to go and have a look at that.

107
00:08:12.100 --> 00:08:18.190
Back to the slides, so basically this page talks about the fact that generic methods allow tight parameters

108
00:08:18.460 --> 00:08:24.790
to be used to express dependencies among the types of one or more arguments to a method and or its return

109
00:08:24.790 --> 00:08:25.090
type.

110
00:08:25.450 --> 00:08:30.100
If there isn't such a dependency, the generic method should not be used as a standard.

111
00:08:30.100 --> 00:08:35.260
Another way, if you want to enforce a relationship between the types of method arguments or a method

112
00:08:35.260 --> 00:08:41.260
argument to which return type is a generic method to enforce the relationship, otherwise do not use

113
00:08:41.260 --> 00:08:41.470
them.

114
00:08:41.980 --> 00:08:45.460
They introduce complexity to the code that may not be warranted otherwise.

115
00:08:47.520 --> 00:08:52.350
So the examples that we've just reviewed have demonstrated that the parameters pass to the method had

116
00:08:52.350 --> 00:08:58.230
a relationship with each other because I desired them to be the same type or subclass of the time I

117
00:08:58.230 --> 00:09:03.240
was able to allow extending the method to any comparable type, but in force a relationship between

118
00:09:03.240 --> 00:09:07.170
the parameters with no additional code and with compiler time checking.

119
00:09:07.410 --> 00:09:08.940
That's a win all the way around.

120
00:09:11.230 --> 00:09:17.260
So in review, you can create generic methods on both generic and non generic classes, a generic methods

121
00:09:17.260 --> 00:09:20.200
declared type parameters are only in scope for the method.

122
00:09:20.800 --> 00:09:26.110
Generic method can use a combination of its declared type parameters or if the class is generic.

123
00:09:26.170 --> 00:09:28.120
Also, it's classes type parameters.

124
00:09:28.720 --> 00:09:33.430
A generic method can be static or not static, and a constructor can also be a generic method.

125
00:09:34.180 --> 00:09:39.490
And you can use a generic method when you want to establish a relationship between types which the method

126
00:09:39.490 --> 00:09:43.810
uses as arguments or with the type of the returned object or what.

127
00:09:43.830 --> 00:09:48.100
So in the next video, I want to talk about generics used with wild card tarping.

128
00:09:48.250 --> 00:09:49.030
So let's move on.
