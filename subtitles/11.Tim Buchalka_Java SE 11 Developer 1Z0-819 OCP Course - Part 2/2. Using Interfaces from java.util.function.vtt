WEBVTT
1
00:00:05.370 --> 00:00:10.650
Many of the examples that I showed in the previous videos, the previous section on functional interfaces

2
00:00:10.650 --> 00:00:16.380
and lambda expressions, could have been characterized as a consumer interface with a method simply

3
00:00:16.380 --> 00:00:21.900
printed information to the console or simple function, return to primitive data type of some sort,

4
00:00:22.110 --> 00:00:24.030
not related to its arguments.

5
00:00:24.630 --> 00:00:30.210
The introduction to this section in the last video listed the five most common types of devices, namely

6
00:00:30.210 --> 00:00:34.380
operator, consumer function, predicate and supplier.

7
00:00:34.650 --> 00:00:36.990
So let's take a minute to review some info about each.

8
00:00:37.940 --> 00:00:42.930
The following table shows most of the interfaces online are all represented in the Javadoc YouTube dot

9
00:00:42.980 --> 00:00:46.790
function package, including some of the primitive data counterparts.

10
00:00:49.120 --> 00:00:54.850
The first column represents the generic interface, the second columnists, some of the primitive type

11
00:00:54.910 --> 00:01:01.450
devices that correspond to the generic interfaces, these interfaces cover a wide swath of functionality.

12
00:01:02.080 --> 00:01:06.130
So looking at the functional interface, we've got unary operator, which of course is generic.

13
00:01:06.280 --> 00:01:10.000
As you can see, you could take an angle, brackets, function, interface top.

14
00:01:10.000 --> 00:01:14.740
We've got double unary operator, intermediary operator and long unary operator.

15
00:01:15.310 --> 00:01:19.680
Generic function interface method using apply their Aletta description.

16
00:01:19.930 --> 00:01:24.940
This represents an operation on a single operation that produces a result of the same type.

17
00:01:24.940 --> 00:01:30.490
S It's operand next functional interface binary operator and we've got the same three there.

18
00:01:30.490 --> 00:01:35.500
We've got double binary operator, independent operator and Longpont operator, the functional device

19
00:01:35.500 --> 00:01:41.470
type generic functional device methods apply and this represents an operation to operate at the same

20
00:01:41.470 --> 00:01:44.680
time, producing a result of the same type as the operands.

21
00:01:44.680 --> 00:01:47.530
And you can say that in the generic function interface method.

22
00:01:49.940 --> 00:01:54.920
Next, functional generic interface, consumer functional device type player, we've got double consumer

23
00:01:54.950 --> 00:02:01.100
and consumer and consumer, the generic function interface method returns void, it's called, except

24
00:02:01.100 --> 00:02:06.260
because he's got one argument there and that represents an operation that accepts a single input argument

25
00:02:06.260 --> 00:02:07.400
and returns no result.

26
00:02:08.300 --> 00:02:13.790
The next functional interface there is the consumer, it's a generic device, you can see there two

27
00:02:13.790 --> 00:02:20.900
types, new functional device top that we've got obj double consumer obj into consumer and long kushima.

28
00:02:21.560 --> 00:02:26.830
The interface method there again returns now it's called Accept and it's got two arguments here.

29
00:02:27.530 --> 00:02:31.460
So this represents an operation that accepts to input arguments and doesn't return a result.

30
00:02:31.940 --> 00:02:35.860
Next, functional generic interface predicate function interface type player.

31
00:02:35.870 --> 00:02:38.600
We've got double predicate int predicate and long predicate.

32
00:02:39.110 --> 00:02:41.900
The method returns are booleans call test with one argument.

33
00:02:42.370 --> 00:02:45.510
This represents a predicate, a boolean value function of one argument.

34
00:02:46.130 --> 00:02:51.950
So the next functional generic interface there by predicate there is a functional interface talk there.

35
00:02:52.340 --> 00:02:55.820
The generic function interface method returns a call test reget.

36
00:02:55.820 --> 00:02:56.700
It's got two arguments.

37
00:02:56.720 --> 00:03:01.340
Say this represents a predicate, a boolean value, the function of two arguments.

38
00:03:03.650 --> 00:03:09.170
The next functional generic device supplier we've got for their building supplier, double supply,

39
00:03:09.170 --> 00:03:14.400
its supplier, long supplier, the method returns the top to find in the generic method better they'll

40
00:03:14.420 --> 00:03:14.810
get.

41
00:03:15.050 --> 00:03:17.180
It represents a supplier of results.

42
00:03:17.780 --> 00:03:23.690
The next generic function device is function and functional devices type to double function in function,

43
00:03:23.690 --> 00:03:27.140
lung function, lung to function, lung function, etc..

44
00:03:27.140 --> 00:03:29.590
It's quite a few there in terms of results.

45
00:03:29.670 --> 00:03:30.410
It's called appli.

46
00:03:30.410 --> 00:03:35.450
And you can say that it accepts what argument misrepresents the function and accepts one argument and

47
00:03:35.450 --> 00:03:36.290
produces a result.

48
00:03:38.770 --> 00:03:43.760
And the last functional, generically defined by function type to double, by function, to long by

49
00:03:43.760 --> 00:03:45.360
a function, to eat by function.

50
00:03:45.990 --> 00:03:47.010
You can see that it returns.

51
00:03:47.020 --> 00:03:50.960
A result of type are the method names are of these two arguments.

52
00:03:51.250 --> 00:03:54.940
This represents a function that accepts two arguments and produces a result.

53
00:03:57.670 --> 00:04:03.190
So moving on in this video and the next one, we're going to be specifying, exploring the operator

54
00:04:03.190 --> 00:04:06.190
interfaces unary operator and binary operator.

55
00:04:06.670 --> 00:04:12.490
So the unary operator accepts a single argument, presumably perform some sort of operation or set of

56
00:04:12.490 --> 00:04:18.090
operations on this one argument, then returns the value of the argument after the operations occur.

57
00:04:18.790 --> 00:04:24.550
They by one zero eight one on part one course, I talked about unary operations in Java, such as prefix

58
00:04:24.550 --> 00:04:26.490
and postfix decrements, et cetera.

59
00:04:26.860 --> 00:04:31.990
So you can think of this interface for such type of operations where the result is only dependent on

60
00:04:31.990 --> 00:04:32.860
the single argument.

61
00:04:35.420 --> 00:04:40.310
The unary operate a functional interface as shown below, you can see an abstract method is not declared

62
00:04:40.310 --> 00:04:40.610
here.

63
00:04:40.910 --> 00:04:47.210
That's because it's inherited from function, the binary operator except two occupants of the same type

64
00:04:47.480 --> 00:04:53.600
and presumably performs calculations or operations using both arguments, keeping a result of the same

65
00:04:53.600 --> 00:04:55.850
type in the Java language.

66
00:04:55.850 --> 00:05:00.290
Binary operators are addition, subtraction, multiplication and division operators.

67
00:05:00.320 --> 00:05:01.010
For example.

68
00:05:03.790 --> 00:05:06.310
The binary operator functionally defies the Shambhala.

69
00:05:06.340 --> 00:05:11.410
And again, you can see an abstract method is not declared since it's inherited from by function.

70
00:05:12.130 --> 00:05:13.440
But let's go back to some code.

71
00:05:14.380 --> 00:05:19.840
We need a new project in intelligence of Cormie, built in interfaces, as you can see there, this

72
00:05:19.840 --> 00:05:23.590
create a new class we're going to call a first class operator example's.

73
00:05:31.850 --> 00:05:38.060
This case consists of an interface that here, my unary operator that basically mocks the unary operator

74
00:05:38.270 --> 00:05:40.130
in the job, its function package.

75
00:05:40.370 --> 00:05:45.110
So it's got a generic type, A method called apply with parameter type T.

76
00:05:45.390 --> 00:05:47.330
The returns are result of type T.

77
00:05:47.920 --> 00:05:52.700
If you go down looking at our public operator examples class and say that we've got a main method that

78
00:05:52.760 --> 00:05:57.500
firstly creates some test data and creates a multiple lambda expressions.

79
00:05:58.130 --> 00:06:02.720
And looking at those lambda expressions, we've got add five to first, which uses chapter two that

80
00:06:02.720 --> 00:06:04.070
function, that unary operator.

81
00:06:04.890 --> 00:06:08.870
We've got add five to first again, which uses the custom interface at the top of this file.

82
00:06:09.170 --> 00:06:15.350
All things being equal, it demonstrates how to create your own unary operator average first two, which

83
00:06:15.350 --> 00:06:21.290
uses the javadoc to that function of binary operator to take two integer values to get the average.

84
00:06:23.120 --> 00:06:26.360
The binary operator interface has two static methods.

85
00:06:26.660 --> 00:06:29.390
I'm demonstrating here how to use this with known comparators.

86
00:06:29.760 --> 00:06:35.180
Firstly, the binary operator matched by returns of binary operator, which will get the max of two

87
00:06:35.180 --> 00:06:41.540
values using a comparator and binary operated by which returns a binary operator, which will get the

88
00:06:41.540 --> 00:06:45.410
middle of two values using a computer and looking out further on down.

89
00:06:45.450 --> 00:06:46.460
We've got a follow up there.

90
00:06:47.580 --> 00:06:53.610
This leads to the test data applying all the lambda expressions using the apply method in each instance.

91
00:06:54.540 --> 00:06:55.590
But since when this code.

92
00:07:03.510 --> 00:07:09.810
Now, the reason why I wanted to demonstrate the creation of my own interface, the machinery operator

93
00:07:09.810 --> 00:07:14.670
interface, is to take the mystery out of the supply functional interface if there is any mystery for

94
00:07:14.670 --> 00:07:14.850
you.

95
00:07:15.360 --> 00:07:21.150
But also imagine once setting up this interface any time you wanted to use it or to creating a library

96
00:07:21.150 --> 00:07:22.110
of such interfaces.

97
00:07:22.530 --> 00:07:23.790
Neither is necessary.

98
00:07:24.030 --> 00:07:28.800
If you familiarize yourself with the interfaces in the Java utility function package.

99
00:07:31.540 --> 00:07:37.600
The operator extends the function interface and the Badreya operator extends the function interface,

100
00:07:37.870 --> 00:07:41.260
so both have two additional methods compose.

101
00:07:41.710 --> 00:07:48.010
And then I'm going to hold on explaining these methods until I review the function and by function interfaces

102
00:07:48.010 --> 00:07:49.450
in the video following the next one.

103
00:07:50.050 --> 00:07:53.810
But coming up in the next video, let's look at the predicate interface.

104
00:07:54.400 --> 00:07:55.510
See you in the next video.
