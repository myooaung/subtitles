WEBVTT
1
00:00:05.240 --> 00:00:10.430
In the previous video, I showed some of the different forms of functional interface can take with the

2
00:00:10.430 --> 00:00:16.070
importance of a single abstract method existing on the interface exactly one either through inheritance

3
00:00:16.070 --> 00:00:17.000
or declaration.

4
00:00:17.780 --> 00:00:22.310
The functional interface is the framework on which the lambda expression is constructed.

5
00:00:23.000 --> 00:00:29.590
A lambda expression can be used in a local variable declaration or past as an argument to a method.

6
00:00:30.200 --> 00:00:34.850
The local variable and the method parameter are typed with a functional interface type.

7
00:00:35.600 --> 00:00:40.190
The abstract methods parameters represent the parameters in the lambda expression.

8
00:00:42.430 --> 00:00:47.920
The return top of the abstract method represents the value returned from the lambda expression, and

9
00:00:47.920 --> 00:00:49.060
the task must be equal.

10
00:00:49.240 --> 00:00:52.270
Polymorphic speaking lambda expressions.

11
00:00:52.270 --> 00:00:58.450
Execution is deferred until it's passed to executing a method that executes the function.

12
00:00:58.990 --> 00:01:03.490
I'm going to include a partial slide from the one zero one nine one course on Lambda Expressions.

13
00:01:03.760 --> 00:01:08.230
I would recommend you review the videos from that course on Lambda Expressions before watching this

14
00:01:08.230 --> 00:01:08.580
video.

15
00:01:10.810 --> 00:01:15.580
Lambda expression Syntex, So this information was on these two links that I've got on screen that are

16
00:01:15.580 --> 00:01:16.660
in the resources section.

17
00:01:17.200 --> 00:01:22.870
Now I like this image because it very quickly tells you what you need to know about writing a lambda

18
00:01:22.900 --> 00:01:23.530
expression.

19
00:01:25.710 --> 00:01:31.920
A lambda expression is composed of three parts parameters, the argument list a comma separated list

20
00:01:31.920 --> 00:01:34.890
of formal parameters enclosed in parentheses.

21
00:01:35.310 --> 00:01:39.450
You can admit the top declaration of the parameters in a lambda expression.

22
00:01:39.810 --> 00:01:44.010
If you include top declarations, you must declare a top for each parameter.

23
00:01:44.670 --> 00:01:51.060
In addition, you can limit the parentheses if there is only one parameter, if you have no parameters,

24
00:01:51.330 --> 00:01:55.860
you can represent this with an empty parentheses set which is required.

25
00:01:58.240 --> 00:02:04.330
Next, we have the arrow taken, the dash grid then then we've got the body, the body can consist of

26
00:02:04.330 --> 00:02:05.440
a single expression.

27
00:02:05.920 --> 00:02:08.620
The expression must evaluate to the top of the method.

28
00:02:08.950 --> 00:02:12.940
Return to the word return cannot be used in a single expression body.

29
00:02:15.130 --> 00:02:20.140
Also, the body can consist of a statement block closed, the left-to-right curly braces, the word

30
00:02:20.140 --> 00:02:21.400
return is required.

31
00:02:21.760 --> 00:02:22.930
It's a method of return type.

32
00:02:22.930 --> 00:02:25.410
It's not void in all statements in the plot.

33
00:02:25.450 --> 00:02:28.600
Even a single statement must end in a semicolon.

34
00:02:29.600 --> 00:02:35.960
Well, let's go back to the idea that we need a new class down in our Lambda Expressions project, let's

35
00:02:35.960 --> 00:02:37.610
call this one Lambda Example's.

36
00:02:47.530 --> 00:02:53.110
Right to this current crisis, first we have a simple functional interface called viable, they've got

37
00:02:53.110 --> 00:02:54.790
this Lamda Example's class.

38
00:02:55.180 --> 00:03:01.390
This is demonstrating, assigning lambda expressions to a static variable, an instance variable or

39
00:03:01.390 --> 00:03:05.270
so in the main methadone here, assigning a lambda expression to a local variable.

40
00:03:05.740 --> 00:03:08.020
Note that this expression is in the left-to-right.

41
00:03:08.020 --> 00:03:09.580
Kelly Price's enclosing the body.

42
00:03:10.680 --> 00:03:14.880
We've also got that view it method at the top of the screen that's got a viewable typed parameter.

43
00:03:16.220 --> 00:03:17.150
So if you run this code.

44
00:03:22.850 --> 00:03:28.160
Now order to create local variables, to use lambda expressions, you can pass the expression directly

45
00:03:28.160 --> 00:03:28.790
to a method.

46
00:03:29.120 --> 00:03:31.640
It's not about doing that on a pasicolan.

47
00:03:32.620 --> 00:03:38.050
We are opposed to that rather than the end of the main method in this case, the lambda expression is

48
00:03:38.050 --> 00:03:41.890
passed as part of the method invocation if you run that.

49
00:03:43.440 --> 00:03:45.260
So we get the output soaring on the screen.

50
00:03:47.210 --> 00:03:53.230
And some more cope in this instance, I'm calling the view at method with a lambda expression in a fully

51
00:03:53.650 --> 00:03:58.000
I use the iteration variable in the lambda expression itself, as you can see there.

52
00:03:58.810 --> 00:03:59.590
So I will run this.

53
00:04:04.150 --> 00:04:08.800
So the airport demonstrates that using a variable from the enclosing code is permissible under some

54
00:04:08.800 --> 00:04:11.290
conditions, they'll be discussing this more in a bit.

55
00:04:11.800 --> 00:04:16.060
But now that we need another class, let's go ahead and create another class or call this lambda example

56
00:04:16.060 --> 00:04:16.510
to.

57
00:04:27.960 --> 00:04:34.860
But this card consists of first two functional interfaces, Calculable and Schobel, they've got this

58
00:04:34.870 --> 00:04:37.760
labor example to class the same day.

59
00:04:37.770 --> 00:04:40.890
We've got a private static method using a void return top.

60
00:04:41.220 --> 00:04:43.770
We've got a private static method using an int.

61
00:04:43.800 --> 00:04:44.730
That's a return top.

62
00:04:45.030 --> 00:04:49.890
We've got our main method that shows some of the many ways to declare a valid lambda expression.

63
00:04:51.390 --> 00:04:56.820
Quite a few there, as you can see, right down to the bottom of the main mouth there, the case obviously

64
00:04:56.820 --> 00:04:58.770
compiling because we haven't got any errors.

65
00:04:59.010 --> 00:04:59.630
Let's run it.

66
00:05:03.420 --> 00:05:09.750
So the code compiled, but I never actually execute any of the labor expressions, were there any surprises

67
00:05:09.750 --> 00:05:10.250
there for you?

68
00:05:11.010 --> 00:05:15.690
And we have looked at this quite a few examples there, but no output.

69
00:05:16.260 --> 00:05:20.130
Again, the reason is I didn't actually execute any of the lab expressions.

70
00:05:20.550 --> 00:05:21.870
So, again, were there any surprises?

71
00:05:22.290 --> 00:05:27.810
Maybe the fact that you can auto lambda perimeter's or that you can execute a method with a return type

72
00:05:28.020 --> 00:05:31.770
in a lab expression or a functional interface method with a void return type?

73
00:05:32.730 --> 00:05:37.770
Now, let's look at ways that we can declare an invalid lambrew expression as patients are out here

74
00:05:37.770 --> 00:05:38.520
to the main method.

75
00:05:39.900 --> 00:05:43.400
So this card demonstrates at least 11 ways to do it wrong.

76
00:05:43.560 --> 00:05:46.680
You could probably think of many more wrong amount of parameters.

77
00:05:47.850 --> 00:05:48.840
A couple of examples of that.

78
00:05:49.380 --> 00:05:55.200
You cannot use a return statement in a single expression and not in curly brackets, can't pass constraints

79
00:05:55.200 --> 00:05:56.040
in the parameter list.

80
00:05:56.350 --> 00:05:58.410
You cannot omit the permanent section altogether.

81
00:05:58.590 --> 00:05:59.670
Parentheses is required.

82
00:05:59.670 --> 00:06:02.110
If the method has no parameters, they are the last one.

83
00:06:02.130 --> 00:06:04.230
This expression returns a string of the methods void.

84
00:06:04.500 --> 00:06:09.840
I'm sure you could probably think of a few more as well as I'm going to comment about those future reference.

85
00:06:10.780 --> 00:06:12.130
If you need to access them.

86
00:06:14.090 --> 00:06:18.310
All right, let's create a new class, we'll call this one LAMDA example three.

87
00:06:29.920 --> 00:06:31.840
Krajisnik can't comment at all the other ones.

88
00:06:33.410 --> 00:06:39.080
I'll start from there as well and just remove any errors in our LAMDA example to point this out, led

89
00:06:39.110 --> 00:06:41.090
by example three four.

90
00:06:42.030 --> 00:06:47.360
This code consists of at the top there, an interface called Runnable and is a functional interface

91
00:06:48.140 --> 00:06:54.230
and a lambda example, three class consists of C there that we've got a static field, but this is field.

92
00:06:54.740 --> 00:06:58.160
We've got to construct their parents constructor and our main method.

93
00:06:58.670 --> 00:07:04.280
And that's demonstrating lambda expressions which access variables from the enclosing code and also

94
00:07:04.280 --> 00:07:04.880
down the bottom.

95
00:07:06.270 --> 00:07:07.690
We've got a couple of methods there.

96
00:07:08.190 --> 00:07:13.560
One that executes the run method on the interface, one that creates a runnable lambda expression and

97
00:07:13.560 --> 00:07:15.030
passes it to the method above.

98
00:07:17.190 --> 00:07:17.820
Let's run this.

99
00:07:20.220 --> 00:07:21.130
There's the output.

100
00:07:22.840 --> 00:07:27.760
So the output from this code demonstrates that a lambda expression has access to static variables,

101
00:07:28.030 --> 00:07:33.850
instance, variables like all variables, etc., but this is like a bit of a modification to this code.

102
00:07:34.840 --> 00:07:39.820
And I'm going to do is a line forty six, I'm going to add a postfix increment.

103
00:07:42.020 --> 00:07:47.390
Two plus plus is, after all the nurses are doing that, I've introduced a compiler error if we hover

104
00:07:47.390 --> 00:07:47.840
over that.

105
00:07:48.890 --> 00:07:53.370
The variable used in lambda expression should be final or effectively final.

106
00:07:54.210 --> 00:07:58.970
Obviously, incrementing the local variable means that AI isn't final since it's effectively changed.

107
00:07:58.980 --> 00:07:59.820
So let's undo that.

108
00:08:01.660 --> 00:08:05.220
Well, it's more like a kite before we finish the video.

109
00:08:07.220 --> 00:08:11.660
Now, this case produced another pilot error on the declaration of the lambda expression hover over

110
00:08:11.660 --> 00:08:15.080
that verbal case already defined in the scope.

111
00:08:15.560 --> 00:08:20.990
The reason for this, you cannot use variable names in the parameter declarations of the lambda expression

112
00:08:20.990 --> 00:08:26.720
that conflict between closing codes, variables and actually a lot of said that was the last book of

113
00:08:26.720 --> 00:08:26.990
code.

114
00:08:26.990 --> 00:08:31.040
But what I would do is actually replace that card, the same card that actually works.

115
00:08:33.800 --> 00:08:39.260
And I still say the best thing of what I've done here used a perimeter name in the Lambda Declaration

116
00:08:39.260 --> 00:08:45.050
instance, which is the same as the instance variable name, but this causes no compiler error for the

117
00:08:45.050 --> 00:08:48.710
same reason that we can shadow an instance filled with a local variable.

118
00:08:51.650 --> 00:08:56.960
So in summary, in this video I've shown you, always a lambda expression can be used, I've shown you

119
00:08:57.200 --> 00:09:02.240
always a lambda expression can be written off, showing you multiple ways, a lambda expression cannot

120
00:09:02.240 --> 00:09:02.720
be written.

121
00:09:03.380 --> 00:09:08.360
And finally, I've shown you using variables from the enclosing scope in the lambda expression.

122
00:09:08.690 --> 00:09:13.520
Coming up in the next video, we'll be discussing more of the mainstream uses of the functional interface

123
00:09:13.520 --> 00:09:14.860
and the lambda expression.

124
00:09:15.260 --> 00:09:16.610
So see you in the next video.
