WEBVTT
1
00:00:05.400 --> 00:00:10.530
So let's take a look at the three set implementation classes we talked about in the last video with

2
00:00:10.530 --> 00:00:15.840
some code to create a new project, and I've called the previous project generics and collections,

3
00:00:15.840 --> 00:00:19.650
but I've created a new project just to separate the code of core collections.

4
00:00:20.010 --> 00:00:23.010
We need to create a new class here called collection tests.

5
00:00:31.160 --> 00:00:32.380
Can I it in the car?

6
00:00:34.020 --> 00:00:39.990
Well, so this class just sets up some tests using the collection interface methods, so we've got a

7
00:00:39.990 --> 00:00:45.100
number of static generic methods here allowing us to use any type of collection you can see there.

8
00:00:45.120 --> 00:00:47.010
We've got to do stuff with collection.

9
00:00:50.470 --> 00:00:55.360
We've also got perform functions as well as perform functions string.

10
00:00:56.340 --> 00:01:02.310
Now, these methods are designed to exercise the following collection methods as an element at a null

11
00:01:02.730 --> 00:01:10.230
and at a duplicate element, remove an element, remove and now perform functions for string or integer

12
00:01:10.500 --> 00:01:12.560
specifically at all contains.

13
00:01:12.560 --> 00:01:19.620
So testing success and failure, remove all and retain or so be testing these methods with different

14
00:01:19.620 --> 00:01:21.210
collections in addition to set.

15
00:01:21.510 --> 00:01:23.180
So I will leave this class for the moment.

16
00:01:23.460 --> 00:01:28.080
What we'll do is we're going to create another class in a different source for to exercise these tests

17
00:01:28.380 --> 00:01:29.930
using the different types of sets.

18
00:01:30.540 --> 00:01:33.930
So we're going to do is create this new class and call it set example.

19
00:01:41.250 --> 00:01:45.900
What I can see here, what I've done, I've actually created this main method, you see, we're creating

20
00:01:45.900 --> 00:01:52.380
an initializing hash set with a type argument of integer based on our initial data online, 16, and

21
00:01:52.380 --> 00:01:58.080
then it's invoking the static method to stuff with collection on the collections test class we created

22
00:01:58.500 --> 00:01:59.460
a minute or so ago.

23
00:02:00.120 --> 00:02:01.040
So let's run this now.

24
00:02:04.000 --> 00:02:05.140
OK, there's the output.

25
00:02:06.790 --> 00:02:09.460
All right, I'm going to leave that airport on screen while we talk about this.

26
00:02:11.500 --> 00:02:17.110
So what I can confirm from these results is that the order of elements in a hash set is unpredictable

27
00:02:17.320 --> 00:02:23.140
and not related to either the way the elements were entered or the natural order of the elements.

28
00:02:23.830 --> 00:02:27.970
Secondly, we can confirm that a single no value is permitted in a set.

29
00:02:28.330 --> 00:02:31.990
And thirdly, we can confirm that duplicate values are not permitted.

30
00:02:32.190 --> 00:02:37.750
It has set the ADD method returns false if it attempts to insert a duplicate element.

31
00:02:39.170 --> 00:02:43.530
Right, so back in the car, Dale, what we'll do is we'll run the same methods on a tray set.

32
00:02:46.210 --> 00:02:49.000
But a postal coded in the mind method at the bottom.

33
00:02:51.780 --> 00:02:52.920
I'm going to accept that import.

34
00:02:54.780 --> 00:02:59.230
So I could say that the only difference here is this time we've got a tree set recording the same do

35
00:02:59.250 --> 00:03:00.450
stuff with collection method.

36
00:03:01.390 --> 00:03:02.110
If we run this.

37
00:03:05.070 --> 00:03:10.690
You could say, well, first they had the hatch set data and now we've got to trace it so we can't leave

38
00:03:10.710 --> 00:03:11.800
this airport on screen.

39
00:03:14.300 --> 00:03:19.070
We can confirm that the tree sets elements are ordered numerically called the natural order.

40
00:03:19.700 --> 00:03:23.270
We can confirm that the tree set cannot contain any null elements.

41
00:03:23.600 --> 00:03:27.500
And our pointer exception is thrown if an attempt to adonal is made.

42
00:03:28.310 --> 00:03:34.370
Third, we can confirm that a trace it does not contain duplicate elements and a duplicate with add

43
00:03:34.520 --> 00:03:35.420
returns false.

44
00:03:35.420 --> 00:03:41.510
If the element being added is already found in the list and forth, all other methods execute similarly

45
00:03:41.660 --> 00:03:42.320
to have set.

46
00:03:43.960 --> 00:03:50.130
So back in the cold again, let's get to the third set implementation and linked have set as before,

47
00:03:50.130 --> 00:03:54.930
will pay some covid at the bottom of the class or part of the method, I should say, separate import.

48
00:03:56.990 --> 00:04:01.730
Very similar, as you could say with the previous examples, but using a linked set this time still

49
00:04:01.730 --> 00:04:03.860
called the same method, do stuff with collection.

50
00:04:04.400 --> 00:04:05.150
So let's run this.

51
00:04:08.050 --> 00:04:09.660
This, the output for linked hasit.

52
00:04:10.820 --> 00:04:13.310
So leaving that on screen, we can observe from this output.

53
00:04:15.340 --> 00:04:22.330
But firstly, Link has said has the following attributes, a link test set is ordered by the insertion

54
00:04:22.330 --> 00:04:23.570
order of the elements.

55
00:04:23.920 --> 00:04:27.970
Secondly, a single now element is allowed in a linked has set.

56
00:04:28.420 --> 00:04:32.410
And thirdly, duplicate elements are not allowed in a linked hasit.

57
00:04:34.200 --> 00:04:35.100
Swinging back to the car.

58
00:04:36.210 --> 00:04:41.310
What are we going to do now is open some code and demonstrate that sets of different implementation

59
00:04:41.310 --> 00:04:47.820
types can be considered equal using a Derechos method call if they have matching elements, Pacer's

60
00:04:47.820 --> 00:04:55.050
coded so we can say the test and verify with our equals with in parentheses looking up here just to

61
00:04:55.050 --> 00:04:55.770
follow the law on it.

62
00:04:55.980 --> 00:04:59.150
That's how set and t define our line.

63
00:04:59.160 --> 00:05:00.630
Twenty five is our it.

64
00:05:05.880 --> 00:05:10.830
You can see that the output from this segment of codas below confirms that the two sets are considered

65
00:05:10.830 --> 00:05:14.640
equal regardless of the specific implementation top of the set.

66
00:05:15.300 --> 00:05:17.790
Obviously here we're comparing hasset versus a tree set.

67
00:05:19.110 --> 00:05:24.640
Let's see in the video here, I will start the next video for looking at how those are evaluated with

68
00:05:24.690 --> 00:05:26.490
let's see you in the next video.
