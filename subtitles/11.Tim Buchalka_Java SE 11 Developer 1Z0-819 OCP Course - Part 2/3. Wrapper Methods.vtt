WEBVTT
1
00:00:05.310 --> 00:00:09.870
So the rap we started talking about in the last video have many methods that you should be familiar

2
00:00:09.870 --> 00:00:10.140
with.

3
00:00:11.050 --> 00:00:16.450
So the following diagram is a limited class diagram of the primitive data Reppas showing a subset of

4
00:00:16.450 --> 00:00:17.350
the methods available.

5
00:00:19.630 --> 00:00:24.460
So in this diagram of the eight Reppas, six in the abstract class number, we talked about that in

6
00:00:24.460 --> 00:00:28.540
the last video, but also seven of the eight Reppas has a minimum score value.

7
00:00:28.570 --> 00:00:33.850
And Max Alesco, very constant, which represents the range of valid, primitive values for the data

8
00:00:33.850 --> 00:00:36.700
type for the sake of a clean diagram.

9
00:00:37.030 --> 00:00:41.620
I'm not showing the relationship between the comparable interface and the wrappers, but all of them

10
00:00:41.620 --> 00:00:47.200
implement comparable interface and have a compare to method, which compares the current instance to

11
00:00:47.200 --> 00:00:50.410
the instance passed as an argument to the compare to method.

12
00:00:51.310 --> 00:00:57.100
In addition, all rappers also have a static compare method that accepts to primitive data type arguments

13
00:00:57.100 --> 00:00:58.550
and compares them all.

14
00:00:58.550 --> 00:01:03.650
The rappers extending no have similarly named methods to those shown on the integer wrapper.

15
00:01:03.940 --> 00:01:06.520
So I've only shown integers methods in the diagram.

16
00:01:07.090 --> 00:01:11.250
Each rapper has many static methods specific to its type not shown here.

17
00:01:11.620 --> 00:01:17.020
This diagram attempts to display in the manner the methods the rappers generally have in common.

18
00:01:19.150 --> 00:01:24.160
So the table you can see on screen methods that most of the rappers have in common with descriptions

19
00:01:24.160 --> 00:01:29.950
and examples, they've only shown integers, method names and documents representing the number subclasses,

20
00:01:30.220 --> 00:01:33.820
which have similarly named methods using its specific date to type.

21
00:01:33.820 --> 00:01:38.560
And Rappa as an example of the passing method is passed long on the long wrapper class.

22
00:01:38.890 --> 00:01:43.600
So looking at some examples, the methadone shown for three Reppas here to the left boolean character,

23
00:01:43.600 --> 00:01:51.190
an integer kupelian boolean value cha cha value and intially that return the primitive value represented

24
00:01:51.190 --> 00:01:52.660
by the appropriate upper class.

25
00:01:53.050 --> 00:01:56.140
And you can see the example there of usage on the right hand side.

26
00:01:56.590 --> 00:02:02.800
Next, we've got to compare again with passing to boolean arguments for the first one to char arguments

27
00:02:02.800 --> 00:02:04.600
for the second and to for the third.

28
00:02:05.110 --> 00:02:10.450
Well that compares to primitive values and essentially it's the same as using the value of method with

29
00:02:10.450 --> 00:02:11.310
the relevant type.

30
00:02:11.650 --> 00:02:17.110
Then don't compare to then the value of then the second value and you can see some example usages to

31
00:02:17.110 --> 00:02:17.530
the right.

32
00:02:19.940 --> 00:02:25.070
Next, we're looking at the compare for Berlin rapper, character, rapper, an entertainer, rapper,

33
00:02:25.310 --> 00:02:28.160
letting that a now parameter produces a no point exception.

34
00:02:28.400 --> 00:02:34.100
And the number of rappers, well, I compare numbers numerically zero if the two numbers are the same

35
00:02:34.370 --> 00:02:39.410
or equal, rather one if the rapper value is greater than the parameter value and minus one if the rapper

36
00:02:39.410 --> 00:02:44.600
value is greater than the primitively for a billion rapper zero if the values are equal.

37
00:02:44.870 --> 00:02:50.150
One if the rapper is true and the parameter is false, minus one if the rapper is false and the parameter

38
00:02:50.150 --> 00:02:50.630
is true.

39
00:02:50.810 --> 00:02:57.590
And for a character rapper zero if he values record the positive number n if the rapper value is greater

40
00:02:57.590 --> 00:03:03.500
than the parameter value where N represents the difference in values and similar to with negative number

41
00:03:03.500 --> 00:03:04.100
minus in.

42
00:03:04.100 --> 00:03:08.960
If the rapper value is less than the perimeter value, it represents a difference in values.

43
00:03:09.620 --> 00:03:11.660
You can say a sample usage there on the right hand side.

44
00:03:14.330 --> 00:03:19.340
But looking at it equals method here, you can see that it returns a boolean to object.

45
00:03:19.350 --> 00:03:25.040
Oh, which is passed as an argument is not always returns false if object is a wrapper, but it must

46
00:03:25.040 --> 00:03:28.400
be the same wrapper type as the wrapper used for the method invocation.

47
00:03:28.740 --> 00:03:34.700
Otherwise, the result is false and passing a corresponding primitive as a parameter works and the values

48
00:03:34.700 --> 00:03:38.690
are evaluated in a couple of examples over there on the right hand side of the usage.

49
00:03:39.750 --> 00:03:40.030
Right.

50
00:03:40.060 --> 00:03:46.320
So next one is the parse boolean and pass integer examples there with a pass the string as an argument.

51
00:03:46.760 --> 00:03:49.670
This passes the string argument into the primitive data type.

52
00:03:50.100 --> 00:03:56.120
Important to note here that the character does not actually support a parse character method and sample

53
00:03:56.120 --> 00:03:58.970
uses over there to the right hand side boolean.

54
00:03:59.240 --> 00:04:03.670
We've got some value of methods for the ability repr, the character reference, the editor wrapper

55
00:04:04.070 --> 00:04:09.890
that just returns a wrapper instance with a value represented by the primitive past to the method and

56
00:04:09.890 --> 00:04:11.600
sample usage to the right hand side.

57
00:04:12.200 --> 00:04:17.300
Lastly, the value of methods got to there demonstrating the boolean wrapper and integer wrapper value

58
00:04:17.300 --> 00:04:23.510
of methods the string as an argument that returns a rare instance with a value represented by the string

59
00:04:23.510 --> 00:04:24.620
past to the method.

60
00:04:25.160 --> 00:04:30.180
And importantly to note here that the character Rappard does not support a parameter of top string for

61
00:04:30.190 --> 00:04:33.960
a value of method and some sample usages over to the right hand side.

62
00:04:33.970 --> 00:04:34.190
The.

63
00:04:36.020 --> 00:04:36.860
I've said a lot there.

64
00:04:37.130 --> 00:04:38.870
Let's actually have a look at some of this in code.

65
00:04:39.140 --> 00:04:41.660
Let's go back to our generics and collections project.

66
00:04:41.960 --> 00:04:45.410
We need to create a new class and we'll call this one rapper Method's.

67
00:04:50.520 --> 00:04:51.330
Plus, Cody.

68
00:04:53.700 --> 00:04:59.010
But so the classes are posted in my there, and what we're doing is we're demonstrating that creating

69
00:04:59.010 --> 00:05:05.340
instances of rappers by declaration and assignment to a primitive in a single statement, we can see

70
00:05:05.340 --> 00:05:06.090
examples of that.

71
00:05:06.860 --> 00:05:11.880
Most are demonstrating, creating instances of rappers and using them as parameters using the value

72
00:05:11.880 --> 00:05:13.170
of method of various rappers.

73
00:05:14.690 --> 00:05:20.300
And you can see some examples, there is also an additional method, Reppas, which is down here.

74
00:05:21.310 --> 00:05:24.310
That accepts a list of represents an object and prints them out.

75
00:05:26.740 --> 00:05:31.270
And there's some countries you can say they were recalling Reppas with various arguments to get the

76
00:05:31.270 --> 00:05:31.960
relevant output.

77
00:05:32.590 --> 00:05:35.560
So let's have a look at the output and discuss it a bit further.

78
00:05:37.060 --> 00:05:43.390
The nightmare that, for example, the Interchurch rapper is in the value of their online 44 specifically

79
00:05:43.660 --> 00:05:47.920
is accepted a charge as a parameter looking at the floating value there.

80
00:05:48.580 --> 00:05:53.560
This is the floating wrapper value of objects, noting specifically that it's accepted string's, which,

81
00:05:53.560 --> 00:05:59.800
if used as literals, would have represented double's a hundred point zero to fifty point zero dollars.

82
00:06:00.100 --> 00:06:01.680
But in this case, it's accepted those.

83
00:06:04.640 --> 00:06:07.290
You can see the rural valleys are working nicely.

84
00:06:07.570 --> 00:06:14.500
I did, Sherry, but we can see for the output for integer, the value of passing a the HRR gave us

85
00:06:14.500 --> 00:06:16.140
the value back up 97 in the airport.

86
00:06:18.580 --> 00:06:20.800
So this seems pretty straightforward and elementary.

87
00:06:21.230 --> 00:06:25.540
Let's test some alternatives, so we're going to add another method now to our rapid methods class down

88
00:06:25.540 --> 00:06:25.750
here.

89
00:06:27.750 --> 00:06:32.820
Looking at the mythical appetitive test exceptions, you can say that I've created a legal class with

90
00:06:32.820 --> 00:06:38.700
type which is representing the represent we want to test and the value the valley passed ultimately

91
00:06:39.030 --> 00:06:40.410
to the valley of method.

92
00:06:42.000 --> 00:06:45.690
You can see here that the tests at the moment are really restricted to flights and integers only.

93
00:06:46.770 --> 00:06:51.560
Scrolling on down, you can see that I'm setting up an array of test scenarios there with a repertoire

94
00:06:51.670 --> 00:06:54.090
to test and also the valley to see what happens.

95
00:06:54.540 --> 00:06:57.960
And further on down, I'm actually executing each one.

96
00:06:58.380 --> 00:07:01.350
You can see that depending on whether it worked or not, we're getting a different message.

97
00:07:01.970 --> 00:07:02.820
So I've done that.

98
00:07:02.820 --> 00:07:04.260
Let's add some code.

99
00:07:05.190 --> 00:07:07.530
To our main method so that we can actually run this.

100
00:07:09.400 --> 00:07:12.400
So we'll just invite the test exceptions method.

101
00:07:13.370 --> 00:07:14.050
Run this now.

102
00:07:17.840 --> 00:07:21.840
OK, you can see the various exceptions showering down the bottom of the screen there.

103
00:07:22.370 --> 00:07:26.600
So for this hour, what we can learn that passing are now string to the valley of method produces that

104
00:07:26.600 --> 00:07:27.110
exception.

105
00:07:27.370 --> 00:07:28.890
It's the first exception starting there.

106
00:07:29.240 --> 00:07:33.320
Now, this is not the case, by the way, for the bullion wrapper, which is created with the value

107
00:07:33.320 --> 00:07:34.490
of false in that scenario.

108
00:07:35.090 --> 00:07:39.650
The other thing to point out here is that the integer, not value of method is more limited than when

109
00:07:39.650 --> 00:07:41.810
assigning values to an integer variable.

110
00:07:42.050 --> 00:07:44.410
It doesn't permit any non numeric characters.

111
00:07:44.420 --> 00:07:45.980
Even those were literal would be fine.

112
00:07:46.470 --> 00:07:52.160
The example specifically is 100 Alesco zero zero zero, which would be valid for an integer normally

113
00:07:52.160 --> 00:07:55.550
but doesn't work is valuable because you've got a few other tests.

114
00:07:55.550 --> 00:07:59.960
They're testing different values for the integer as well as to see what happens.

115
00:08:00.650 --> 00:08:02.180
So let's just add a few more tests here.

116
00:08:02.760 --> 00:08:06.200
We're going to add this code directly under the core to test exceptions.

117
00:08:07.600 --> 00:08:13.600
So here we try it, the just overloaded value of battery with a second parameter representing the radix,

118
00:08:14.140 --> 00:08:17.380
but also on line sixty five, there's a compiler error.

119
00:08:17.890 --> 00:08:21.970
Character does not have a value of method that supports a string as a parameter.

120
00:08:24.060 --> 00:08:29.130
This is obviously looking for a Charron been provided with a string to remove this last line and only

121
00:08:29.460 --> 00:08:30.630
then will execute a code.

122
00:08:36.620 --> 00:08:42.620
And you can see their posts on the airport, the right expellees there can for sixty four point fifty

123
00:08:42.620 --> 00:08:46.720
six, that's representing binary octal and hexadecimal numbers.

124
00:08:47.540 --> 00:08:50.000
So let's send the video here in the next one.

125
00:08:50.000 --> 00:08:53.430
I want to briefly review the other methods that the Reppas have in common.

126
00:08:53.840 --> 00:08:54.950
See you in the next video.
