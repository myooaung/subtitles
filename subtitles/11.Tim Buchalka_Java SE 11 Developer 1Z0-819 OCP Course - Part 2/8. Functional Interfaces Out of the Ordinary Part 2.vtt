WEBVTT
1
00:00:05.230 --> 00:00:11.950
Finally, I want to do another closer look at the methods and then and compose the following table shows

2
00:00:11.950 --> 00:00:14.820
you which interfaces have support for these default methods.

3
00:00:15.540 --> 00:00:21.640
So note that supply and predicate do not support either method only function and it's more specific

4
00:00:21.640 --> 00:00:24.340
type unary operator support compose.

5
00:00:24.940 --> 00:00:30.970
An only consumer uses the single abstract method in combination with these methods or other interfaces

6
00:00:30.970 --> 00:00:37.720
use apply in other words, to compose and the and then methods do not get invoked without either apply

7
00:00:37.720 --> 00:00:40.560
or accept for consumer being invoked as well.

8
00:00:41.410 --> 00:00:47.740
Looking at this table, the default method and then the interfaces both function binary operator function

9
00:00:47.740 --> 00:00:48.730
and unary operator.

10
00:00:49.030 --> 00:00:55.450
The functionality of a single abstract method is appli and for the consumer interface, the functional

11
00:00:55.450 --> 00:01:01.000
interface single abstract method is accept and with the default method, compose the interface as a

12
00:01:01.000 --> 00:01:06.670
function and unary operator and for the functional interface single abstract method it's apply.

13
00:01:08.050 --> 00:01:11.550
So let's create yet another class in a built in interfaces project.

14
00:01:11.970 --> 00:01:14.130
We'll call this one and then examples.

15
00:01:23.800 --> 00:01:27.950
To this case consists of the class and the examples of the main method, as you can see on screen,

16
00:01:28.820 --> 00:01:35.180
and the code sets up a variable of type function as some as the lambda expression to the local variable

17
00:01:35.570 --> 00:01:40.880
invokes the compose method on the variable and scrolling it down also invokes the and then method on

18
00:01:40.880 --> 00:01:45.860
the variable and then invokes the apply method on the variable that's from this.

19
00:01:47.740 --> 00:01:48.580
And there's the apple.

20
00:01:50.050 --> 00:01:55.300
I had said in a video or in this section of the court when reviewing consumer, that the and dead method

21
00:01:55.300 --> 00:01:58.180
needs to be self assigned or it won't get invoked.

22
00:01:58.690 --> 00:02:00.270
The same is true for Composers'.

23
00:02:00.280 --> 00:02:02.560
Well, these methods are lazy.

24
00:02:02.830 --> 00:02:08.600
They will not actually get invoked until the corresponding single abstract method method is invoked.

25
00:02:09.430 --> 00:02:15.580
But in addition, they could include Lezley if you do not reassign the result to an appropriate interface

26
00:02:15.580 --> 00:02:18.700
variable first, if you're not immediately changing them.

27
00:02:20.030 --> 00:02:21.020
Let's make a change here.

28
00:02:21.560 --> 00:02:28.070
They basically just cannot sign the value back to the function variable executing the code now.

29
00:02:29.630 --> 00:02:33.860
Gives us another step there, as you can see there, the same is also true for the and then MyFord.

30
00:02:34.130 --> 00:02:34.980
So let's do that.

31
00:02:35.000 --> 00:02:38.600
Basically, we just come to assign the result back to our function variable.

32
00:02:39.760 --> 00:02:47.310
From this, we have the third step showing the output confirms that all lambda expressions were executed

33
00:02:48.460 --> 00:02:51.640
and we comment that the apply method invocation on line thirty six.

34
00:02:51.640 --> 00:02:54.450
Now we're doing this again.

35
00:02:56.560 --> 00:03:01.210
You could say that by doing that, we've confirmed at the end that method and composed method do not

36
00:03:01.210 --> 00:03:02.680
get invoked independently.

37
00:03:02.980 --> 00:03:06.100
That's just undo that last change back to what we had before.

38
00:03:10.200 --> 00:03:12.090
So let's put some more code to our main MyFord.

39
00:03:16.190 --> 00:03:21.890
So here you see the current variable function returning the composed method, the and then method and

40
00:03:21.890 --> 00:03:25.940
apply method in a single statement using different lambda expressions.

41
00:03:26.740 --> 00:03:30.300
And if we run this, we should see the results and the output pane.

42
00:03:31.340 --> 00:03:32.180
And there's the result.

43
00:03:33.260 --> 00:03:39.680
So were you surprised at the lambda expressions previously passed to N10 and Kapos continue to be executed

44
00:03:39.680 --> 00:03:39.870
here?

45
00:03:40.220 --> 00:03:45.610
You could say looking at the output that you can add multiple and then and compose method expressions,

46
00:03:46.040 --> 00:03:51.710
this is a reminder that if you're using a local variable and applying the lambda expression in multiple

47
00:03:51.710 --> 00:03:57.830
instances and you don't want this behavior, you need to reinitialize the variable to its original state.

48
00:03:58.370 --> 00:04:04.010
So now let's look at another interface that has the same default values via inheritance, the unary

49
00:04:04.010 --> 00:04:06.890
operator which extends the function interface.

50
00:04:08.360 --> 00:04:11.230
More code into our main method.

51
00:04:13.540 --> 00:04:19.960
In this case, I'm using a unary operator with a compose and an invocation, chaining them to the applied

52
00:04:19.960 --> 00:04:24.120
method, running the code can see the result at the bottom.

53
00:04:26.260 --> 00:04:31.990
So as I stated, I'm was talking about this slide binary operator and boy function do not support the

54
00:04:31.990 --> 00:04:35.140
composed method, but they do support and then.

55
00:04:36.440 --> 00:04:37.260
So back to the code.

56
00:04:37.940 --> 00:04:39.920
What I'm going to do now is spend some more code.

57
00:04:42.040 --> 00:04:42.810
So that's the code.

58
00:04:43.480 --> 00:04:48.730
This is showing examples of invoking and then for both of these interface types, namely by function

59
00:04:48.730 --> 00:04:51.010
and binary operator, let's run this.

60
00:04:53.420 --> 00:04:54.770
We could see the results in the apple.

61
00:04:55.970 --> 00:05:01.400
Now let's use the method and then with the consumer interface again, remembering that the consumer's

62
00:05:01.400 --> 00:05:03.350
single abstract method is except.

63
00:05:05.750 --> 00:05:06.620
SEPTA imports.

64
00:05:11.590 --> 00:05:16.960
So not hear them instead of chaining, I'm sitting at the end, then method result back to the consumer

65
00:05:16.960 --> 00:05:19.300
local variable C from the card.

66
00:05:21.380 --> 00:05:21.980
There's put.

67
00:05:23.830 --> 00:05:30.190
So try to memorize this table, remembering which interfaces support and then and which support compose.

68
00:05:30.760 --> 00:05:36.730
So go through them again briefly to folk method and then the interface is a function, binary operator,

69
00:05:36.850 --> 00:05:42.460
function and unary operator and the functional interface signal abstract method is apply and the default

70
00:05:42.460 --> 00:05:42.730
method.

71
00:05:42.730 --> 00:05:48.730
And then for the interface consumer, the functionality of high single abstract method is except for

72
00:05:48.730 --> 00:05:52.690
the default method, compose interfaces, function and unary operator.

73
00:05:53.140 --> 00:05:56.350
The single abstract method for the functional interface is apply.

74
00:05:56.920 --> 00:06:01.460
Try and memorize this remembering which interfaces support and then in which support compose.

75
00:06:01.990 --> 00:06:06.520
Remember that neither method is invoked until the single abstract method is invoked.

76
00:06:07.000 --> 00:06:11.470
Now, if you're not changing these methods to that single abstract method invocation, then you need

77
00:06:11.470 --> 00:06:18.580
to assign the result of the lazy invocations of and then or compose to the interface variable which

78
00:06:18.580 --> 00:06:23.330
will eventually invoke the single abstract method, apply or accept for consumer.

79
00:06:23.950 --> 00:06:29.740
I've shown you that you can continue to change multiple and then and compose methods even after the

80
00:06:29.740 --> 00:06:32.620
first invocation of the apply or accept method.

81
00:06:32.830 --> 00:06:37.030
And the result is cumulative operations or irrationality in the video here.

82
00:06:37.510 --> 00:06:40.410
Next, you'll be presented with a couple of quick questions on these topics.

83
00:06:40.660 --> 00:06:43.000
So good luck and then I'll see you in the following section.

84
00:06:43.270 --> 00:06:47.080
We're going to be discussing Java Stream API, which I think is a lot of fun.

85
00:06:47.530 --> 00:06:48.250
So let's go.
