WEBVTT
1
00:00:05.410 --> 00:00:11.920
In generic code, the question mark is called the wild card, it represents an unknown type at compile

2
00:00:11.920 --> 00:00:18.790
time, the wild card can be used as a top argument, an instance filled decoration also to a local variable

3
00:00:18.790 --> 00:00:23.910
declaration, to a method parameter in a return type declaration of a method.

4
00:00:24.250 --> 00:00:28.720
But this is discouraged as a matter of habit and in a type argument itself.

5
00:00:30.970 --> 00:00:37.840
The wild card is never used in the following circumstances to invoke a generic method as a type argument

6
00:00:37.960 --> 00:00:45.700
for a generic method invocation to instantiate a generic class in a class declaration to specify a supertight

7
00:00:46.000 --> 00:00:48.250
or replace a type parameter.

8
00:00:50.370 --> 00:00:56.480
There are three types of wild cards which are described in this table, firstly, inbounded the unbounded

9
00:00:56.490 --> 00:01:03.550
wild card allows any type A parameter that is declared with the list and go bracket's questionmark Lysenko

10
00:01:03.600 --> 00:01:08.010
bracket's is not the same as list with object in Ã€NGEL brackets.

11
00:01:08.370 --> 00:01:15.270
So list questionmark in brackets would accept a list of any type, whereas list object in brackets only

12
00:01:15.270 --> 00:01:17.580
accepts a list which contains object.

13
00:01:17.880 --> 00:01:21.480
Remembering that list with interchangeable brackets does not meet.

14
00:01:21.480 --> 00:01:28.170
There is a test, a list object in brackets and would not be passed to a list object in brackets parameter

15
00:01:28.960 --> 00:01:30.570
in terms of the syntax and usage.

16
00:01:30.900 --> 00:01:31.840
Could see the example there.

17
00:01:31.860 --> 00:01:33.180
Questionmark in brackets.

18
00:01:33.510 --> 00:01:36.500
It can be interpreted as any type allowed.

19
00:01:37.230 --> 00:01:38.130
So that was about it.

20
00:01:38.160 --> 00:01:45.090
Next, we've got upper bound and upper bound wild card restricts types used to the declared class or

21
00:01:45.090 --> 00:01:46.470
one of its subclasses.

22
00:01:46.800 --> 00:01:52.830
The boundary for allowable types stops at the top of the hierarchical tree with a declared class is

23
00:01:52.830 --> 00:01:54.410
the top link below.

24
00:01:54.420 --> 00:01:56.820
It is allowable as well as the top itself.

25
00:01:57.180 --> 00:02:01.050
Using an upper bound allows the code to utilize methods on the bound types.

26
00:02:01.640 --> 00:02:04.050
In terms of syntax, you can say this example.

27
00:02:04.050 --> 00:02:06.510
We've got angle brackets with the angle brackets.

28
00:02:06.540 --> 00:02:13.680
Questionmark extends no, that can be interpreted as no is allowed as well as any type that extends

29
00:02:13.680 --> 00:02:14.070
no.

30
00:02:16.470 --> 00:02:23.160
But at the top of our car law, about a low bound wildcard district types from being more specific than

31
00:02:23.160 --> 00:02:29.370
the declared type, the battery is the child in the tree and only super classes and types are permitted.

32
00:02:30.060 --> 00:02:36.330
The example that we've got in angle brackets questionmark super exception that could be interpreted

33
00:02:36.330 --> 00:02:42.360
as exception is allowed in any talk that is a super class or super type of exception.

34
00:02:44.210 --> 00:02:48.980
All right, so let's review when you could use wild cards and when you cannot, so we need to create

35
00:02:48.980 --> 00:02:51.200
a new class in our genetics and collections project.

36
00:02:51.770 --> 00:02:53.960
We're going to call this one wild card usage.

37
00:03:00.180 --> 00:03:06.870
So this is a kind of pasted in to this code consists of, firstly a generic class named Wildcard Tests,

38
00:03:06.870 --> 00:03:09.240
which has a single attribute value.

39
00:03:09.310 --> 00:03:13.710
You can see on line eleven, you've got to know, Alex constructor, they're the smallest a single engine

40
00:03:13.770 --> 00:03:16.880
constructor, which sets the attribute for them.

41
00:03:16.930 --> 00:03:21.690
Moving on down, we've got a static generic method called Do Something that prints the method argument.

42
00:03:22.250 --> 00:03:22.380
Right.

43
00:03:22.500 --> 00:03:23.460
We've gone to the next class.

44
00:03:23.460 --> 00:03:26.100
We've got the wild card usage class, the public class.

45
00:03:26.700 --> 00:03:29.280
It could say that this class is demonstrating.

46
00:03:29.280 --> 00:03:33.660
Using wild cards is firstly a field declaration, also a static field declaration.

47
00:03:34.090 --> 00:03:38.820
Got an instance method parameter to a static method parameter and return type.

48
00:03:39.090 --> 00:03:41.070
It also a local variable.

49
00:03:42.920 --> 00:03:46.820
Declaration in the main method down here on line 55.

50
00:03:48.510 --> 00:03:49.110
Let's run this.

51
00:03:50.970 --> 00:03:55.740
So the output from this courage shown below and demonstrates that all of these wild card usages that

52
00:03:55.740 --> 00:04:01.020
I've shown you were valid, now going to talk about the implications of the wild card declarations in

53
00:04:01.020 --> 00:04:01.950
the next example.

54
00:04:02.660 --> 00:04:07.740
What are we going to do is add another class to the source code in this fall and at the bottom of the

55
00:04:07.740 --> 00:04:10.290
class there below the declaration.

56
00:04:11.940 --> 00:04:17.310
Or what I can see here, what I've done is used a wild card in the top argument of the generic class,

57
00:04:17.310 --> 00:04:20.910
in the extents clause of another class, no wild card expected.

58
00:04:21.060 --> 00:04:22.380
So this is a compiler error.

59
00:04:22.710 --> 00:04:25.840
You can't use a wild card to specify supertight.

60
00:04:26.310 --> 00:04:27.240
Let's try another example.

61
00:04:27.270 --> 00:04:29.310
I'm going to overwrite that code by the code.

62
00:04:30.290 --> 00:04:34.910
We've got the same error, the unexpected wildcard, so this is obviously a co-pilot error as well.

63
00:04:35.260 --> 00:04:38.960
You can't use a wildcard in a top argument of a generic class.

64
00:04:39.200 --> 00:04:44.100
So this is very similar to the appropriate way to use an upper bound declaration.

65
00:04:44.570 --> 00:04:45.500
The code is very similar.

66
00:04:45.500 --> 00:04:48.110
It's going to post it briefly together.

67
00:04:48.110 --> 00:04:52.010
So you could say it's very similar, but it's a delete this you can see this is now valid.

68
00:04:52.910 --> 00:04:57.770
So let's play some code into our main method down here below the last line select method.

69
00:05:00.090 --> 00:05:05.440
In this case, demonstrating, invoking a static method with no type argument specified.

70
00:05:05.980 --> 00:05:10.540
That's because the top argument is effectively employed and that is, first of all, here on line 65,

71
00:05:10.960 --> 00:05:12.700
which relates to the do something method.

72
00:05:13.730 --> 00:05:15.740
If to find the missing methanol on 21.

73
00:05:18.380 --> 00:05:23.240
The second example is demonstrating and breaking a static method with a type argument specified, and

74
00:05:23.240 --> 00:05:26.480
again, this time we can see that it's the same static method that we are invoking.

75
00:05:26.870 --> 00:05:29.490
This time we're being specific with the top argument.

76
00:05:29.870 --> 00:05:33.140
So in the third invocation of that same static method, do something.

77
00:05:33.320 --> 00:05:35.160
I'm attempting to use a wildcard.

78
00:05:35.920 --> 00:05:37.990
You can see that that statements failed to compile.

79
00:05:38.570 --> 00:05:43.400
And the reason for that is I use a wildcard in a top argument for a method invocation.

80
00:05:43.700 --> 00:05:46.400
Obviously, we're getting the unexpected wildcard error.

81
00:05:47.150 --> 00:05:48.500
So let's remove that last statement.

82
00:05:49.580 --> 00:05:52.070
I anticipated some more Capullo, this fellow Khidir.

83
00:05:54.450 --> 00:06:00.360
The kind of person that firstly demonstrates instead I take a generic class with no type argument on

84
00:06:00.360 --> 00:06:05.490
the right hand side of the assignment, the first one, the second example line demonstrates instantiating

85
00:06:05.490 --> 00:06:11.550
a generic class with a wild card declaration, but specifying the type argument on the right hand side

86
00:06:11.550 --> 00:06:12.210
of the assignment.

87
00:06:12.630 --> 00:06:18.390
As a third example, line 70 Tempesta is a wild card in the institution of a generic class and not in

88
00:06:18.390 --> 00:06:19.100
the declaration.

89
00:06:19.160 --> 00:06:20.370
You can say we've got an error there.

90
00:06:20.670 --> 00:06:26.370
That code fails to compile wild top questionmark in English because they cannot be instantiated directly.

91
00:06:26.720 --> 00:06:33.330
So basically you can't use a wildcard as a top argument when instantiating a generic class that's remove

92
00:06:33.330 --> 00:06:34.050
this last line.

93
00:06:36.400 --> 00:06:40.900
So finally, before in the video, I want to add a method to the class wildcard tests.

94
00:06:43.450 --> 00:06:45.970
To top it, what cuts were added to the bottom of the screen?

95
00:06:47.950 --> 00:06:53.950
They could say that fails to compile the expected wild card like a generic class, you cannot use a

96
00:06:53.950 --> 00:07:01.810
wild card in a type argument or a generic method to undo that change in the video here in the next one,

97
00:07:01.810 --> 00:07:05.410
I will start talking about how to use wildcard type arguments.

98
00:07:05.750 --> 00:07:06.840
See you in the next video.
