WEBVTT
1
00:00:05.670 --> 00:00:11.250
Let's review briefly the other methods the Reppas have in common, we need a new class in this project.

2
00:00:12.540 --> 00:00:14.580
We'll call this one more rapid method's.

3
00:00:21.720 --> 00:00:22.470
Plus, decoding.

4
00:00:24.880 --> 00:00:29.890
So starting off, we've got the usual main method, which simply invites the test instance methods which

5
00:00:29.890 --> 00:00:30.760
were about to talk about.

6
00:00:31.090 --> 00:00:32.080
That's the next method.

7
00:00:34.150 --> 00:00:40.000
So this method specifically, this is testing the primitive value methods with several different weapons

8
00:00:40.000 --> 00:00:46.510
or other words in value, double value, byte value, etc., it's also testing the equals method for

9
00:00:46.510 --> 00:00:47.980
different wrappers and values.

10
00:00:48.430 --> 00:00:52.240
And I didn't include the compare to method here, but I will talk about that.

11
00:00:52.240 --> 00:00:57.310
Compare to method in a video, Uncomparable and Co-operator interfaces later.

12
00:00:58.220 --> 00:01:00.830
You see the various code there, they're actually checking.

13
00:01:03.590 --> 00:01:06.170
We've also got this print wrapper object as well.

14
00:01:06.490 --> 00:01:12.650
It didn't mention much about that, but that's just basically assisting in returning a string in a format

15
00:01:12.650 --> 00:01:13.400
that we can print out.

16
00:01:13.730 --> 00:01:14.560
Actually run this now.

17
00:01:18.210 --> 00:01:19.170
So that's only I put.

18
00:01:20.490 --> 00:01:23.590
So the billion value in carbon emitters have no surprises here.

19
00:01:23.790 --> 00:01:27.850
They simply return the value of the primitive, which the rapporteur represents.

20
00:01:28.350 --> 00:01:29.950
But far the equals method.

21
00:01:30.300 --> 00:01:37.830
It's important to remember that passing a no results involves not an exception and that you cannot compare

22
00:01:37.830 --> 00:01:43.290
Reppas such as short an integer, which has the same value because the results will always be false,

23
00:01:43.290 --> 00:01:48.360
even if he cast them both to number the equals method is inherited from object.

24
00:01:50.680 --> 00:01:55.030
Next, we're going to explore the static methods with the exception of value of what you've covered

25
00:01:55.030 --> 00:01:55.690
previously.

26
00:01:56.470 --> 00:01:58.060
We're going to add a method to this class.

27
00:01:59.850 --> 00:02:01.350
I just going to post it down the bottom there.

28
00:02:05.900 --> 00:02:10.310
And you can see it using the COMPAR method there for the various upper classes.

29
00:02:11.730 --> 00:02:14.490
Let's invoke this in our main method, which is at the top of the class.

30
00:02:17.590 --> 00:02:18.100
And runit.

31
00:02:22.170 --> 00:02:23.850
All right, and there's the output on screen.

32
00:02:24.990 --> 00:02:31.740
Some things to note with its output using the compar method boolean compare and compare methods return

33
00:02:31.740 --> 00:02:34.250
Vali's zero negative one on one.

34
00:02:34.920 --> 00:02:38.130
You can say that Integer accepts many types of literals.

35
00:02:38.600 --> 00:02:41.960
See various examples of that character to compare returns.

36
00:02:41.970 --> 00:02:48.450
The lexicographical difference between the values character can accept Unicode values as MyFord arguments

37
00:02:48.450 --> 00:02:50.220
as shown or at next.

38
00:02:50.220 --> 00:02:54.850
Let's look at a couple of samples of parse and a primitive types pass, for example.

39
00:02:55.350 --> 00:03:00.690
This is very similar to the value of method which internally invokes the parse and whatever the primitive

40
00:03:00.690 --> 00:03:01.260
type is.

41
00:03:01.800 --> 00:03:08.400
So rather is pass int, parse byte, etc. So the rules that apply to value of wood apply to parse and

42
00:03:08.400 --> 00:03:09.690
whatever the primitive type is.

43
00:03:09.930 --> 00:03:13.980
And again, parse it as an example, no results in no pointer exception.

44
00:03:14.220 --> 00:03:21.210
And the string values do not necessarily correspond to literal values as demonstrated by some Cotan

45
00:03:21.210 --> 00:03:26.050
in our method that we've added the test static methods right at the bottom.

46
00:03:26.070 --> 00:03:27.000
After all the other output.

47
00:03:29.560 --> 00:03:30.510
Seropositive.

48
00:03:31.430 --> 00:03:37.250
Apart from the Energy Department and also from the Berlin to Berlin, run this.

49
00:03:41.380 --> 00:03:44.220
And we get some examples working right?

50
00:03:45.160 --> 00:03:50.530
And this is actually not a typo that should actually be DPAs billion, because obviously the actual

51
00:03:50.560 --> 00:03:53.390
method is possible in which we can see being called the red line 100.

52
00:03:54.010 --> 00:03:55.720
So now that I've done that, let's run this card.

53
00:03:59.040 --> 00:04:04.830
And we can see the output from percent for integer and pass boolean for our brilliant repr.

54
00:04:06.850 --> 00:04:12.040
But since finally have a look at the get repr method, the only Boulin and integer have this method,

55
00:04:12.610 --> 00:04:18.330
the method name to get Brillion and get integer respectively, paste just below the other code.

56
00:04:20.820 --> 00:04:25.250
We can see the examples of that insurgent rocket launcher, Sharon Berlin, Docket Berlin.

57
00:04:29.780 --> 00:04:34.610
Let we say the output at the bottom of the screen now, I'm sure you probably agree that these are rather

58
00:04:34.610 --> 00:04:40.610
unexpected results if you just assume get Berlin and get into a replacement methods for the bullion

59
00:04:40.610 --> 00:04:42.590
value and the methods.

60
00:04:43.370 --> 00:04:49.190
But in fact, these methods do not pass the values past, but instead they lock up a system, not property,

61
00:04:49.190 --> 00:04:55.430
with a name that matches the value passed and then returns the system to property as the value requested.

62
00:04:55.790 --> 00:04:57.330
So let's see how it should work.

63
00:04:57.350 --> 00:04:58.310
Some code election.

64
00:05:00.140 --> 00:05:07.530
This, again, the bottom of our test static methods here, what I'm doing is I'm actually setting some

65
00:05:07.530 --> 00:05:12.390
system properties which when passed, will be passed to an innate value or a boolean.

66
00:05:13.300 --> 00:05:17.290
So therefore, I run this bearing in mind the results we got previously, when is expected.

67
00:05:20.000 --> 00:05:26.600
We've now got valleys that are appropriate based on what the properties were set on line 110 and 111.

68
00:05:28.050 --> 00:05:33.060
So I'm sure you would agree that these two methods would look fairly innocuous in a code sample on an

69
00:05:33.060 --> 00:05:33.870
exam question.

70
00:05:35.000 --> 00:05:35.760
Watch out for that.

71
00:05:36.660 --> 00:05:39.730
So each rapper has specific methods that are relevant to his day to talk.

72
00:05:40.080 --> 00:05:43.830
So you should really familiarize yourself with as many as you can if you've not already done so.

73
00:05:44.310 --> 00:05:44.880
What's next?

74
00:05:44.910 --> 00:05:48.330
Before I finish the video, I want to talk about rappers and operators.

75
00:05:48.870 --> 00:05:50.190
And we need a new class for this.

76
00:05:50.640 --> 00:05:53.700
And I will call this new class rapper operators.

77
00:06:00.250 --> 00:06:01.060
Pasicolan.

78
00:06:03.890 --> 00:06:09.470
Now, this code that I've actually added consists of a simple addition operator on two variables, one,

79
00:06:09.470 --> 00:06:13.160
an integer wrapper, the one a short local variable.

80
00:06:14.210 --> 00:06:19.400
The result of the operation is that assigned to each of the following, firstly, a primitive local

81
00:06:19.400 --> 00:06:28.040
variable like 19, a rep, a local variable line 23 and an LPT local variable type inference variable,

82
00:06:28.550 --> 00:06:29.950
and that's on line 27.

83
00:06:30.800 --> 00:06:32.520
So note here that we've got no errors.

84
00:06:32.540 --> 00:06:34.880
The code compiles if we run it.

85
00:06:39.460 --> 00:06:42.780
We got the results there, 20 for each of the answers.

86
00:06:43.780 --> 00:06:44.930
Both are continuing on.

87
00:06:44.980 --> 00:06:47.860
Let's play some more Kaidan here in our mind, MyFord.

88
00:06:49.140 --> 00:06:54.030
And that by doing that, that three of these loans have produced compiler errors, first, a result

89
00:06:54.030 --> 00:07:00.180
that was passed to the elevated variable result is not an object, but rather it's a primitive data

90
00:07:00.180 --> 00:07:00.450
type.

91
00:07:01.160 --> 00:07:04.350
The result is based upon a line twenty seven.

92
00:07:04.570 --> 00:07:07.110
That's a little variable and not an object.

93
00:07:07.110 --> 00:07:10.890
So hence we can't call methods on it or delete that.

94
00:07:12.590 --> 00:07:13.190
Coming up.

95
00:07:15.340 --> 00:07:21.730
Next year we've got here for short is incompatible top, it's required assurance provided with an INT

96
00:07:22.090 --> 00:07:25.120
and here's looking for a short wrapper and it's found in it.

97
00:07:25.730 --> 00:07:27.190
So let's see what we can do to fix that.

98
00:07:27.190 --> 00:07:33.220
We're going to get back up here to our declaration on line 11 and change the integer to a short.

99
00:07:36.310 --> 00:07:37.780
They're short, I was 10.

100
00:07:41.250 --> 00:07:46.890
We've still got exactly the same problem see incompatible types there in my one zero eight one nine

101
00:07:46.890 --> 00:07:52.380
Part one course, Section four, using operators and decision constructs using binary operators.

102
00:07:52.620 --> 00:07:58.530
I explained that all operations are numeric primitives smaller than an int a first converted to INT

103
00:07:58.830 --> 00:08:00.210
and any result would be in it.

104
00:08:00.630 --> 00:08:05.520
So this is continuing to hold true even if we've replaced the variable with Reppas.

105
00:08:06.740 --> 00:08:12.620
So let's try something else, want to go back and change short, I was 10 to the upper class short.

106
00:08:14.130 --> 00:08:18.780
And again, still got the same problems down here on our two lines, incompatible types.

107
00:08:19.770 --> 00:08:23.190
So let's just do this a few times so we get back to the car that was working.

108
00:08:28.400 --> 00:08:30.020
All right, so back to work and again.

109
00:08:31.550 --> 00:08:34.230
So you can use Reppas interchangeably with operators.

110
00:08:34.250 --> 00:08:39.150
With one exception, and this is the instance of operator, there's some code again to main method.

111
00:08:40.220 --> 00:08:42.810
This has resulted in a compiler error on line 36.

112
00:08:43.370 --> 00:08:46.640
The instance of operator will not auto box its first operand.

113
00:08:47.090 --> 00:08:51.080
So you can see they were doing an instance of integer the wrapper on the right hand side with Embling,

114
00:08:51.320 --> 00:08:52.370
the primitive type.

115
00:08:52.580 --> 00:08:55.670
But again, instance of operator box, the first operand.

116
00:08:56.240 --> 00:09:02.180
If it chose this code, I'm just going to overwrite just the if statement and the code block.

117
00:09:02.550 --> 00:09:05.460
You can see now that the compiler error is on the nested if statements.

118
00:09:05.930 --> 00:09:12.380
So the short wrapper is not an integer and because the local variable was declared as short as in the

119
00:09:12.380 --> 00:09:15.080
short wrapper, the compiler knows that this is not a valid test.

120
00:09:15.750 --> 00:09:21.370
If we replaced thirty four, which is currently short as it was 10, replace it with this definition.

121
00:09:22.400 --> 00:09:27.560
This allows the code to compile and the output from this additional code essentially run this.

122
00:09:32.370 --> 00:09:35.310
Comes back, this is an instance of no, which is true.

123
00:09:38.460 --> 00:09:41.820
The instance of operetta is one example where auto boxing does not occur.

124
00:09:42.150 --> 00:09:45.850
I've discussed others in my one zero eight or nine Part one course on YouTube.

125
00:09:46.230 --> 00:09:50.880
You're probably getting sick of me saying that as we go through this course for JVM, when matching

126
00:09:50.880 --> 00:09:58.230
overloaded methods will not use auto boxing or on boxing until first matching on valid widened primitives.

127
00:09:58.860 --> 00:10:02.970
And again, I will say yet again, you can review this in my one zero eight one nine Part one course,

128
00:10:03.180 --> 00:10:08.330
Section seven, this time creating and using methods, the topic determining which overloaded method

129
00:10:08.340 --> 00:10:08.970
gets cold.

130
00:10:09.960 --> 00:10:12.210
Another example is arise and arrive.

131
00:10:12.210 --> 00:10:17.520
A primitive data type will not get or I boxed to an array of the corresponding rappa and again saying

132
00:10:17.520 --> 00:10:23.520
it again, you can read this in one zero eight or nine part one course this time Section nine encapsulation

133
00:10:23.910 --> 00:10:24.300
topic.

134
00:10:24.300 --> 00:10:25.410
Casting object.

135
00:10:25.420 --> 00:10:26.340
This is reference.

136
00:10:28.450 --> 00:10:33.220
All right, next, collections are used, but objects and not primitive data, they're going to be discussing

137
00:10:33.220 --> 00:10:34.620
this in a video coming up shortly.

138
00:10:35.170 --> 00:10:39.880
The next generics, generics are used with class types are not primitive data types.

139
00:10:40.120 --> 00:10:42.550
And I'll be discussing this in an upcoming video as well.

140
00:10:43.240 --> 00:10:43.430
All right.

141
00:10:43.480 --> 00:10:47.950
So the last three videos I've reviewed rappers and the methods with which most of the rappers have in

142
00:10:47.950 --> 00:10:51.640
common, six of the eight rappers extend the abstract class number.

143
00:10:52.150 --> 00:10:57.730
You've seen examples of auto boxing and and boxing and have pointed out some exceptions where auto boxing

144
00:10:57.730 --> 00:10:59.560
and on boxing will not occur.

145
00:11:00.280 --> 00:11:01.150
That's in the video here.

146
00:11:01.150 --> 00:11:05.700
And move on to generics, which support reportage but not primitive data types.

147
00:11:06.040 --> 00:11:07.180
See you in the next video.
