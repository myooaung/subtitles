WEBVTT
1
00:00:05.340 --> 00:00:12.120
In the next two videos, I discussed the map interface elements in a map implement the type Javadoc

2
00:00:12.120 --> 00:00:18.120
Utah dot map toward entry and have a key and a value is set to be mapped to a key.

3
00:00:18.900 --> 00:00:21.180
A map cannot contain duplicate keys.

4
00:00:21.630 --> 00:00:23.640
Now valid key for a hash map.

5
00:00:23.640 --> 00:00:29.060
Only each cake a map to most what value and null is a valid value.

6
00:00:29.760 --> 00:00:32.730
There's a map interface doesn't extend collection, but why not?

7
00:00:35.060 --> 00:00:39.030
All these questions answered by the following Tecmo, the links in the resources section.

8
00:00:39.530 --> 00:00:41.300
The answer is that this was by design.

9
00:00:41.690 --> 00:00:44.990
Mappings are not collections and collections are not mappings.

10
00:00:45.440 --> 00:00:49.710
Thus, it makes little sense for MAP to extend the collection interface or vice versa.

11
00:00:52.230 --> 00:00:57.720
Let's talk about data manipulation methods before travel, right, this interface was pretty basic with

12
00:00:57.720 --> 00:01:06.030
operations such as put get remove, contains key, contains value, size and empty as far as bulk operations,

13
00:01:06.030 --> 00:01:11.700
such as put all a clear and collection views such as key entry set and values.

14
00:01:13.990 --> 00:01:18.730
Default methods were added in Java right to the interface for the following data manipulation methods

15
00:01:19.330 --> 00:01:25.120
of removed return types and generic top parameters in a table on screen from the method declarations

16
00:01:25.120 --> 00:01:26.620
just to simplify readability.

17
00:01:29.040 --> 00:01:35.220
The compute merge and replace all methods can be used with lambda expressions that had all of these

18
00:01:35.220 --> 00:01:40.120
methods have a function parameter with the exception of compute if absent.

19
00:01:41.070 --> 00:01:46.020
This is important for the exam, which may test your knowledge on which functional interface is used

20
00:01:46.200 --> 00:01:47.070
by which method.

21
00:01:47.880 --> 00:01:50.970
So in all cases, but one the function is used.

22
00:01:50.970 --> 00:01:54.710
Your lambda expression would have two parameters representing key and value.

23
00:01:55.470 --> 00:02:00.300
The one exception should be easy to remember because it's the instance where the key is known not to

24
00:02:00.300 --> 00:02:00.810
exist.

25
00:02:01.230 --> 00:02:07.530
Computed absent its parameter is a function excepting one parameter representing the values to be calculated

26
00:02:07.770 --> 00:02:08.490
for the new entry.

27
00:02:10.900 --> 00:02:16.150
So look at the various methods and say we've got compute that attempts to compute a mapping for the

28
00:02:16.150 --> 00:02:19.350
specified key in its current, that value or not.

29
00:02:19.390 --> 00:02:20.350
There's no current mapping.

30
00:02:21.470 --> 00:02:26.380
They've were completely absent if the specified case not already associated with a value, what's map

31
00:02:26.390 --> 00:02:31.820
to know that attempts to keep it, especially using the given mapping function and it has it into the

32
00:02:31.820 --> 00:02:32.060
map.

33
00:02:32.410 --> 00:02:32.840
Now.

34
00:02:33.840 --> 00:02:40.390
Moving on, comparative PR. If the value for the specify case present and now it attempts to complete

35
00:02:40.390 --> 00:02:44.650
a new mapping given the key and its current mapped value, we've got Mirch.

36
00:02:45.080 --> 00:02:50.890
It's a specified case not already associated with a value or is associated with no debt associated with

37
00:02:50.890 --> 00:02:52.110
a given value.

38
00:02:54.700 --> 00:02:55.510
Put it absent.

39
00:02:55.920 --> 00:03:01.120
It's a specific case not already associated with a valley or boys map to now associate it with a given

40
00:03:01.120 --> 00:03:01.950
value and returns.

41
00:03:01.960 --> 00:03:08.020
Now those returns, the current value more here remove removes the entry for the specified key only

42
00:03:08.020 --> 00:03:10.580
if it's currently mapped to the specified value.

43
00:03:10.960 --> 00:03:16.870
Replace replace the entry for the specified key and if it's currently mapped to some value, replace

44
00:03:17.110 --> 00:03:22.060
overloaded at this time replaces the entry for the specified key and if it's currently mapped to the

45
00:03:22.060 --> 00:03:27.610
specified value and replace replaceable replaces each entries value with the result of invoking the

46
00:03:27.610 --> 00:03:32.680
given function on that entry until all entries have been processed or the function throws an exception.

47
00:03:35.300 --> 00:03:39.320
Java nine and 10 introduce static methods for this interface, which include the following.

48
00:03:39.850 --> 00:03:44.960
We've got a copy of Introduced in Java 10, which returns and modifiable map containing the entries

49
00:03:44.960 --> 00:03:51.830
of a given map, an entry method introduced in Java, nine returns and unverifiable map to an entry

50
00:03:52.100 --> 00:03:53.530
containing the given keen value.

51
00:03:54.110 --> 00:04:00.770
We've got various forms of of the of method introduced in Java nine terms that are modifiable map containing

52
00:04:00.770 --> 00:04:03.440
zero to many mappings based on the arguments of this method.

53
00:04:03.800 --> 00:04:09.410
We've got other entries also introduced in Java nine, which returns are not modifiable map botanicas

54
00:04:09.410 --> 00:04:11.750
and Veliz extracted from the given entries.

55
00:04:14.210 --> 00:04:19.550
Some implementations of map contained in the collections framework, a hash map tray map and linked

56
00:04:19.550 --> 00:04:25.370
Hashmat a quick outline of the three that you can see, the Hashmat not ordered and allows an OK and

57
00:04:25.370 --> 00:04:27.500
also allows a value tray map.

58
00:04:27.740 --> 00:04:31.810
The ordering is a natural order of chaos or by a copyright are passed to the constructor.

59
00:04:32.090 --> 00:04:37.400
It does not allow no case, but it does allow no and linked Hashmat.

60
00:04:37.700 --> 00:04:43.220
The ordering is for a predictable insertion order uses the order of insertion of case and that allows

61
00:04:43.220 --> 00:04:45.620
no key and also no values.

62
00:04:47.240 --> 00:04:53.000
All right, so time to swing back over to the idea, going to create a new project in a new class in

63
00:04:53.000 --> 00:04:56.180
our collections project called Call This One, that example.

64
00:05:06.300 --> 00:05:12.180
But so this class as a main method, you can see there, it's creating three types of maps, Hashmat,

65
00:05:12.180 --> 00:05:14.040
the TriMet and the linked Hashmat.

66
00:05:15.420 --> 00:05:20.940
It's populating them with the same key value elements is in the put method in a follow and you can see

67
00:05:20.940 --> 00:05:23.730
the follow up online that five is in.

68
00:05:23.730 --> 00:05:28.580
This is going to be further testing, adding an element with a case plus an element with a value to

69
00:05:28.590 --> 00:05:31.410
see what happens then we're actually just printing out the results.

70
00:05:31.860 --> 00:05:32.340
And here.

71
00:05:33.560 --> 00:05:38.570
Basically printing out the printing out the map and its elements around this now.

72
00:05:41.680 --> 00:05:46.730
Looking at the code there, you can see firstly that only the tree map, through an exception point

73
00:05:46.730 --> 00:05:52.850
of exception, we tried to add an entry with a NOCH or three, allowed an entry with a low value.

74
00:05:55.680 --> 00:06:01.770
Looking at the map, you can see there that it's not sorted, but looking at the tree map and the linked

75
00:06:01.770 --> 00:06:04.140
hash map to see both of those are sorted.

76
00:06:04.650 --> 00:06:09.120
And in addition to each entry is an entire class of each map type.

77
00:06:09.120 --> 00:06:13.110
You can see that in the output there, each entry type implements mapped on entry.

78
00:06:14.000 --> 00:06:15.150
We're going to add a method now.

79
00:06:17.700 --> 00:06:20.340
To this class on the bottom.

80
00:06:25.290 --> 00:06:27.540
So there's a method to simple map stuff.

81
00:06:28.690 --> 00:06:31.330
This method invokes many of the common functions of a map.

82
00:06:31.970 --> 00:06:33.730
You see we've got closer to get.

83
00:06:35.080 --> 00:06:41.800
Contains key spots, contains value, also multiple flavors of replace being used there.

84
00:06:41.810 --> 00:06:43.720
You can see we're overloading it with different values.

85
00:06:44.110 --> 00:06:46.120
So we've got to replace with two arguments.

86
00:06:46.670 --> 00:06:50.860
But the first is the key and the second is Savelli, which will be the value of the entry of the keys

87
00:06:50.860 --> 00:06:51.250
found.

88
00:06:51.610 --> 00:06:53.860
But I've also got to replace that with three arguments.

89
00:06:54.580 --> 00:06:57.370
The first is the key to match and the second is the value to be matched.

90
00:06:57.660 --> 00:07:02.710
And if the entry matches on key and value, the value will be replaced with a value in the third argument

91
00:07:03.470 --> 00:07:04.650
living on death row.

92
00:07:04.930 --> 00:07:06.910
So I also got multiple examples here.

93
00:07:07.830 --> 00:07:13.170
Of the removed method, we've got removed there with a single argument which made an entry with a matching

94
00:07:13.170 --> 00:07:18.510
key to the argument we've got to remove with two arguments, which removes an entry matching the key

95
00:07:18.510 --> 00:07:20.880
of the first argument and the value on the second argument.

96
00:07:21.420 --> 00:07:22.710
And the entry won't be removed.

97
00:07:22.740 --> 00:07:24.180
The second argument doesn't match.

98
00:07:25.460 --> 00:07:26.020
It's going down.

99
00:07:26.050 --> 00:07:31.270
We've also got a use of put it up, set and put there as he comparing the results, both return the

100
00:07:31.270 --> 00:07:32.490
current value of the entry.

101
00:07:32.770 --> 00:07:37.970
If the entries fared with a key matching the first argument of the method put always updates to match

102
00:07:38.020 --> 00:07:39.380
entries value positive.

103
00:07:39.400 --> 00:07:44.800
Abbasid will update the matched entries value if the value is no and put it upside will ensure entry

104
00:07:44.800 --> 00:07:49.480
with the first argument is key and the second argument is value with the entries not found.

105
00:07:50.510 --> 00:07:53.960
Well, it's now that we've done that, let's add some code to our made method so that we can test this

106
00:07:53.960 --> 00:07:54.500
new function.

107
00:08:03.060 --> 00:08:05.150
And we can see the output on screen there now.

108
00:08:06.740 --> 00:08:12.770
Let's close that run, Payden, and we're going to go down to the bottom of our class at another Bethania.

109
00:08:13.950 --> 00:08:14.640
There's a new method.

110
00:08:18.380 --> 00:08:23.150
I'm using lambda expressions here, which you should basically be familiar with now to refer to the

111
00:08:23.150 --> 00:08:25.760
one zero eight nine Part one, cause if you need more info.

112
00:08:26.060 --> 00:08:30.530
But when we review reviewing lambda expressions in more detail in this course as well later on.

113
00:08:31.320 --> 00:08:34.970
Now you can use a lambrix pressure to alter a value with a map using compute.

114
00:08:35.690 --> 00:08:41.770
You say we're using a computer that you can alternatively use compute if absent and computed prisoners.

115
00:08:41.970 --> 00:08:43.460
We've got examples of that in this code.

116
00:08:44.120 --> 00:08:45.710
Well, let's go back to our main method.

117
00:08:46.090 --> 00:08:49.190
Need to post them, Sicard, so that we can test this method.

118
00:08:52.860 --> 00:08:55.320
Is that his code that's now run this?

119
00:08:57.370 --> 00:08:58.530
All right, so there's the airport.

120
00:08:59.570 --> 00:09:03.920
The output confirms, firstly, that using compute and we just get back to the source code to check

121
00:09:04.100 --> 00:09:04.820
that out as well.

122
00:09:08.170 --> 00:09:15.170
You were using computer to update the value, the key of John and multiply the value by a hundred and

123
00:09:15.480 --> 00:09:17.340
thirty eight is that lambda expression?

124
00:09:17.730 --> 00:09:19.270
Because can we're getting the right result?

125
00:09:19.770 --> 00:09:22.050
You see, John, on the output page on the value of 500.

126
00:09:22.800 --> 00:09:25.890
Another example here is in compute with a new value.

127
00:09:25.890 --> 00:09:28.020
Harlene, in this case, that doesn't exist.

128
00:09:28.500 --> 00:09:30.630
We could say that's been added to the map.

129
00:09:30.900 --> 00:09:36.480
Eight equals zero and it's taken the default value because the value was no other example there of setting

130
00:09:36.480 --> 00:09:39.900
John to know value subsequently saved us.

131
00:09:39.900 --> 00:09:43.500
No, and then updated it, this expression to zero.

132
00:09:43.590 --> 00:09:49.440
Again, you can say that in the upper pane, maybe go to the compute if absent method calls and computed

133
00:09:49.440 --> 00:09:49.840
present.

134
00:09:49.860 --> 00:09:53.180
We're getting the relevant results in the output pane as well.

135
00:09:54.350 --> 00:09:59.210
Basically, competitive and competitive, absent of good alternatives to the compute method, competitive,

136
00:09:59.210 --> 00:10:00.140
absolute does nothing.

137
00:10:00.140 --> 00:10:04.760
If a key exists, the operation is not executed and repeated presence does nothing.

138
00:10:04.760 --> 00:10:09.110
If the key does not exist, the operation is not executed in that scenario.

139
00:10:09.980 --> 00:10:13.610
So let's see the video here and the next one will start looking at merge.

140
00:10:14.150 --> 00:10:15.260
See you in the next video.
