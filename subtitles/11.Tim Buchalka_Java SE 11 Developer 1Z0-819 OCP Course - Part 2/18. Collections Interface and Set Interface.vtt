WEBVTT
1
00:00:05.530 --> 00:00:11.920
The following tables list methods declared on the Javadoc Languedoc collection interface not to be confused

2
00:00:11.920 --> 00:00:16.220
with Java, Utah collections class, which are discussing the latter video.

3
00:00:16.930 --> 00:00:19.600
These methods are categorized by their purpose.

4
00:00:20.320 --> 00:00:25.540
I've examined the implementation of many of these in Section 10 of my YOU to be one zero eight one nine

5
00:00:25.540 --> 00:00:30.250
part one course, specifically the declared use list and a royalist topic.

6
00:00:31.090 --> 00:00:35.470
I will be reviewing many of these methods in my upcoming videos on the collections framework in this

7
00:00:35.470 --> 00:00:40.780
course and the interfaces that extend collection, so I could say there are search methods we've got

8
00:00:40.780 --> 00:00:43.990
to contain the terms of Berlin is passed.

9
00:00:44.020 --> 00:00:46.870
An object comparison methods equals there.

10
00:00:47.170 --> 00:00:49.300
We've got to contains all they can say.

11
00:00:49.300 --> 00:00:52.210
That's part of the collection with a type wild card.

12
00:00:52.660 --> 00:00:53.770
We also got these empty.

13
00:00:56.160 --> 00:00:59.550
They are this next table, I'm not going to read all of these hours, I don't think it'll add a lot

14
00:00:59.550 --> 00:01:00.780
of value by doing that.

15
00:01:01.110 --> 00:01:06.930
But pause the video and or take a screenshot or download the slides if you want to study this in more

16
00:01:06.930 --> 00:01:07.340
detail.

17
00:01:07.340 --> 00:01:09.300
And I suggest it's probably a good idea to do that.

18
00:01:11.900 --> 00:01:17.120
Well, let's talk about some basic functionality that's shared by all collections, so these include

19
00:01:17.120 --> 00:01:20.850
traversing a collection and bulk operations on data.

20
00:01:21.650 --> 00:01:23.570
So firstly, traversing a collection.

21
00:01:23.990 --> 00:01:28.600
No, often you want to manipulate the entire collection or some subset in some way.

22
00:01:29.210 --> 00:01:30.620
You can do this in several ways.

23
00:01:31.040 --> 00:01:35.330
You can traverse over a collection using an iterator by calling the Iterator method.

24
00:01:35.540 --> 00:01:37.910
And you can see an example on screen there shown below.

25
00:01:40.510 --> 00:01:46.300
The second way is the use of the fourth method, a default method and collection, because if you've

26
00:01:46.300 --> 00:01:47.890
got another example of that below.

27
00:01:49.090 --> 00:01:53.380
Another way is to obtain a stream and perform aggregate operations on it.

28
00:01:53.740 --> 00:02:00.100
The example below gets the objects in a set, which are the type item and prints those values, and

29
00:02:00.100 --> 00:02:01.930
we'll be going through streams in a future video.

30
00:02:04.660 --> 00:02:07.330
And fourth, using an enhanced for loop.

31
00:02:07.690 --> 00:02:13.030
And again, this example below and for more details are enhanced for loops referred to by part one one

32
00:02:13.030 --> 00:02:14.740
zero eight one nine course on YouTube.

33
00:02:17.160 --> 00:02:23.550
But so moving on now, let's talk about data manipulation in bulk, so the collection framework supports

34
00:02:23.550 --> 00:02:29.490
methods which can take a set of data as an argument and then perform some bulk manipulation with a single

35
00:02:29.490 --> 00:02:30.000
statement.

36
00:02:30.840 --> 00:02:34.140
So ADA contains all of be in parentheses returns.

37
00:02:34.140 --> 00:02:41.500
True, if the collection represented by A contains all the elements in the collection next week or later

38
00:02:41.520 --> 00:02:43.830
at all will be in parentheses.

39
00:02:44.100 --> 00:02:49.620
Well, that adds all elements to be to a but note to the individual collection tops may implement this

40
00:02:49.620 --> 00:02:51.840
differently, not duplicate.

41
00:02:51.840 --> 00:02:53.850
Collections will only add unique members.

42
00:02:53.850 --> 00:03:01.410
For example, this is equivalent to a database, a unionpay which is unique or a union Olby, which

43
00:03:01.410 --> 00:03:02.310
is all members.

44
00:03:04.820 --> 00:03:10.550
Next, we've got a top removal with B in parentheses, well, that removes elements from A where there

45
00:03:10.550 --> 00:03:16.580
is an intersection of elements between A and B, the B collection can contain elements that are not

46
00:03:16.580 --> 00:03:17.690
in the instance collection.

47
00:03:17.840 --> 00:03:22.760
So this is equivalent to a database A minus B query result next.

48
00:03:23.060 --> 00:03:29.450
I don't retain all with B in parentheses that retains elements A where there's an intersection of elements

49
00:03:29.450 --> 00:03:35.030
between A and B, the big collection can contain elements that are not in the instance collection.

50
00:03:35.390 --> 00:03:39.290
This is equivalent to a database A Intersect B query result.

51
00:03:39.950 --> 00:03:45.800
The last one is clear that removes all elements from the collection such that either is empty becomes

52
00:03:45.800 --> 00:03:46.220
true.

53
00:03:48.410 --> 00:03:54.380
But let's look at the most generic of collections, the sitt represented by the set interface, the

54
00:03:54.380 --> 00:03:58.100
set interface contains only methods inherited from collection.

55
00:03:58.340 --> 00:03:59.840
It has the following features.

56
00:04:00.680 --> 00:04:04.070
Duplicate elements are prohibited in two instances.

57
00:04:04.070 --> 00:04:09.800
Errico if they contain the same elements, the comparison allowed, even if the implementation types

58
00:04:09.800 --> 00:04:10.270
differ.

59
00:04:12.610 --> 00:04:18.700
Three classes that implement the city to face are the hash set tree set and the linked hash it listed

60
00:04:18.700 --> 00:04:20.490
in the table on screen later.

61
00:04:20.500 --> 00:04:26.230
All collection implementations are generic classes of left out the top parameters for a simpler read.

62
00:04:26.980 --> 00:04:30.040
Something from the left hash set implements set.

63
00:04:30.250 --> 00:04:35.800
The order is unpredictable iteration order and in terms of knows, a single null element is permitted

64
00:04:36.010 --> 00:04:36.790
for a set.

65
00:04:37.830 --> 00:04:43.170
Next, we've got a tree set which implements navigable, said the order is of natural order or by use

66
00:04:43.170 --> 00:04:47.940
of co-operator in the constructor, but in terms of now, no null elements are permitted.

67
00:04:48.510 --> 00:04:53.130
And third, we've got linked hasset, which extends, have set and implements set.

68
00:04:53.700 --> 00:05:00.090
The order is a predictable iteration order ordered by insertion order and a single null element is permitted.

69
00:05:02.840 --> 00:05:08.810
The hashtag is backed by a hash table that makes no guarantees as to the iteration or of the set in

70
00:05:08.810 --> 00:05:13.350
particular, does not guarantee that the order will remain constant over time.

71
00:05:13.760 --> 00:05:16.130
So this class permits the null element.

72
00:05:16.850 --> 00:05:23.150
The tree set is never set and sorted, said implementation elements are ordered using their natural

73
00:05:23.150 --> 00:05:28.850
ordering or by a Pereda provider that set creation time depending on which constructor is used.

74
00:05:29.930 --> 00:05:36.380
The linked hash set extends Hasset and maintains a doubly linked list running through all of its entries.

75
00:05:36.980 --> 00:05:42.680
This linked list defines the iteration ordering as the order in which elements were inserted into the

76
00:05:42.680 --> 00:05:44.060
set insertion order.

77
00:05:44.570 --> 00:05:49.640
Note that the insertion order is not affected if an element is reinserted into the set.

78
00:05:50.610 --> 00:05:55.620
Let's end the video here and in the next one, we'll start by looking at a set implementation classes

79
00:05:55.620 --> 00:05:56.220
in code.

80
00:05:56.460 --> 00:05:57.560
See you the next video.
