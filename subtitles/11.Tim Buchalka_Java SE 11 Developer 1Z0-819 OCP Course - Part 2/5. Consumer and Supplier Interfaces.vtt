WEBVTT
1
00:00:05.170 --> 00:00:10.540
So continuing on from the last video, let's now look at the next interfaces, consumer and supplier

2
00:00:11.200 --> 00:00:17.350
consumer is like function and by consumer like by function, except that the consumer method is named,

3
00:00:17.350 --> 00:00:21.220
except it has no return type it as shown below.

4
00:00:21.820 --> 00:00:24.820
They can see the example they for consumer type T.

5
00:00:25.000 --> 00:00:29.710
We've got an exact method that takes an argument of type T, which is marked as void.

6
00:00:31.860 --> 00:00:38.340
And then by consumers, similar by consumer, this time it takes two arguments to give you two arguments,

7
00:00:38.590 --> 00:00:44.760
you void return to go back to market character, we need to create a new class consumer example built

8
00:00:44.760 --> 00:00:45.930
in interfaces projects.

9
00:00:45.930 --> 00:00:46.560
Go ahead and do that.

10
00:00:55.710 --> 00:00:56.790
OK, so there's a code.

11
00:00:57.300 --> 00:01:03.600
So what I'm doing here is I'm creating two local variables, both consumer interfaces and then assigning

12
00:01:03.600 --> 00:01:04.920
lambda expressions to them.

13
00:01:06.440 --> 00:01:10.820
Now, the first labor expression prints the string to the console that that intelligence might give

14
00:01:10.820 --> 00:01:16.250
you warnings and you can replace system thought out to peatlands if you get that with a method refits

15
00:01:16.250 --> 00:01:18.020
system, not outcall and column precleared.

16
00:01:18.080 --> 00:01:22.010
Instead, I'll be talking about method references in a later video of this course.

17
00:01:22.430 --> 00:01:28.220
Now, the second lambda expression takes a list of string and then uses that for each method which takes

18
00:01:28.220 --> 00:01:29.780
a consumer interface type.

19
00:01:30.140 --> 00:01:31.940
So I pass the local variable reference.

20
00:01:31.940 --> 00:01:32.990
See to that.

21
00:01:33.500 --> 00:01:39.560
Remember, you can use local variables in your lambda expressions as long as they're fardell or effectively

22
00:01:39.590 --> 00:01:40.010
onal.

23
00:01:40.640 --> 00:01:41.660
So running this code now.

24
00:01:43.410 --> 00:01:47.190
All right, now, let's say I want to perform at the airport a bit more, I'm going to use the bike

25
00:01:47.190 --> 00:01:48.630
and she would be the first to do this.

26
00:01:49.200 --> 00:01:52.020
So let's get some more code in to this main method.

27
00:01:54.370 --> 00:01:55.280
Except imports.

28
00:01:56.940 --> 00:02:02.820
So this lambda expression looks a lot like the lamp expression for the consumer c.B previously created

29
00:02:03.030 --> 00:02:05.000
with a minor but important difference.

30
00:02:05.370 --> 00:02:11.130
So in this case, the consumer passed to the far reaches of perimeter of the by consumer interface and

31
00:02:11.140 --> 00:02:14.260
passing the lambda expression as an argument to the accept method.

32
00:02:14.640 --> 00:02:15.510
So really, the card.

33
00:02:18.440 --> 00:02:25.640
So both consumer and consumer heaven and then method, which is similar to the and then method on functional

34
00:02:25.640 --> 00:02:29.330
and function but not a consumer, does not have a composed method.

35
00:02:29.810 --> 00:02:33.340
So let's close down the output window there and personal it.

36
00:02:34.710 --> 00:02:41.390
So there's a code starting on 41 and you can say that we're using the added method along forty seven

37
00:02:42.080 --> 00:02:42.650
on the card.

38
00:02:46.450 --> 00:02:51.450
So we at the airport in the bottom of the screen there, the codes produced a system to that statement,

39
00:02:51.690 --> 00:02:54.320
but no output from the and then method.

40
00:02:54.600 --> 00:02:55.610
There is a reason for that.

41
00:02:55.950 --> 00:03:00.150
You cannot execute the dead method that chaining it to an exit method.

42
00:03:00.840 --> 00:03:01.890
So let's add some code.

43
00:03:03.850 --> 00:03:04.390
Run this.

44
00:03:09.020 --> 00:03:13.380
And you can see this time we've actually got the Apple one, 10, 12, three, four.

45
00:03:15.030 --> 00:03:20.310
There were done is back up here along 47, but could have topped by equals.

46
00:03:21.730 --> 00:03:23.680
They get the result of calling and then.

47
00:03:27.220 --> 00:03:32.290
So this there confirms that the lambda expressions passed to the added method were invoked after the

48
00:03:32.290 --> 00:03:38.200
accept method, if you see the use of the Antheil method invoked separately from the functional method

49
00:03:38.200 --> 00:03:43.300
of the interface, and it's not assigned to the same interface variable that will be executed, the

50
00:03:43.300 --> 00:03:46.150
expression passed to the end then method will not get invoked.

51
00:03:46.540 --> 00:03:52.360
If it is assigned, it will get invoked after the functional method in this case, except after that

52
00:03:52.360 --> 00:03:56.650
gets invoked, they can invoke the added method chained to the accept method.

53
00:03:57.480 --> 00:03:59.140
What I'll do is I'll show you another example of that.

54
00:04:00.230 --> 00:04:01.450
It's placed in some malko.

55
00:04:04.410 --> 00:04:10.350
So I can say that I'm invoking and then the Chinese accept remembering the and method on its own does

56
00:04:10.350 --> 00:04:12.960
nothing, but when you're changing it to the accepted.

57
00:04:14.010 --> 00:04:15.830
They can see the output at the bottom of the screen.

58
00:04:18.770 --> 00:04:24.860
But last but not least, let's look at the supplier interface now, the Oracle documentation states

59
00:04:24.860 --> 00:04:27.570
that this interface represents a supplier of results.

60
00:04:28.100 --> 00:04:29.960
The interface is defined as follows.

61
00:04:30.470 --> 00:04:33.900
Say they're in a public interface supplier type to T there.

62
00:04:34.220 --> 00:04:40.210
We've got to get that returns an object of type T, so we need to create a new class here.

63
00:04:40.220 --> 00:04:41.810
We're going to call one supplier example.

64
00:04:50.420 --> 00:04:51.290
Postcard in.

65
00:04:53.050 --> 00:04:59.020
But I'm looking at this code, Bursley consists of a method, you say that we're creating a local variable

66
00:04:59.020 --> 00:05:04.360
s, which is a string, either accepting a string from the command or using a default value by creating

67
00:05:04.360 --> 00:05:09.080
a supplier, local variable with a lambda expression that uses the string above and a profit method

68
00:05:09.080 --> 00:05:13.810
that splits the string into words, the value returned and the number of words is then printed.

69
00:05:14.510 --> 00:05:15.250
Let's run this.

70
00:05:17.410 --> 00:05:19.510
That's a number of words, Entry-Exit.

71
00:05:20.660 --> 00:05:25.730
We can quickly go in and edit our configuration, let's try some arguments.

72
00:05:42.900 --> 00:05:47.920
It's time we've got a number of words, Intellectual's 15, which corresponds to what I entered as program

73
00:05:47.920 --> 00:05:49.420
arguments up here.

74
00:05:52.310 --> 00:05:53.220
Fifteen, by my count.

75
00:05:53.750 --> 00:05:54.890
All right, so it is clear that.

76
00:05:59.110 --> 00:06:03.700
All right, so in the last four videos, I've covered the generic forms of the interfaces listed in

77
00:06:03.700 --> 00:06:06.310
the table below with their relevant methods.

78
00:06:06.670 --> 00:06:11.740
Now all of the interface support a one and two argument version, with the exception of supplier, which

79
00:06:11.740 --> 00:06:13.060
actually doesn't have any arguments.

80
00:06:13.360 --> 00:06:17.050
But in looking at these interfaces, we've got function and function.

81
00:06:17.320 --> 00:06:19.690
Both have a method called apply of return.

82
00:06:19.690 --> 00:06:25.060
On top of our function as a perimeter of type T function has two parameters.

83
00:06:25.360 --> 00:06:26.740
Type T and top you.

84
00:06:27.370 --> 00:06:31.420
The default methods are composed, which is a function only and the second default method.

85
00:06:31.420 --> 00:06:35.800
And then for both if go we've got unary operator and binary operator.

86
00:06:36.040 --> 00:06:43.060
The abstract method is apply for both, but type top is t one method, parameter type T or unary operator

87
00:06:43.060 --> 00:06:46.210
and two parameters of type T for binary operator.

88
00:06:46.630 --> 00:06:51.760
The default method is composed for unary operator only and the second default method is and then for

89
00:06:51.760 --> 00:06:55.870
both static methods, both for binary operator Max by and Minbar.

90
00:06:58.140 --> 00:07:03.390
Next, you've got predicate and by predicate, the abstract method is test both return type boolean

91
00:07:03.630 --> 00:07:10.650
predicate has one parameter of type T by predicate has two first ones, type T and second is Tapu.

92
00:07:10.980 --> 00:07:15.840
The default method for both R and NEGATE and all the static methods.

93
00:07:15.840 --> 00:07:18.720
We've got Newgate on Predicate and also not on Predicate.

94
00:07:19.660 --> 00:07:26.980
The consumer and the consumer interfaces, the abstract methods are both called accept, both return

95
00:07:26.980 --> 00:07:30.340
nothing to avoid and the method parameters for consumer.

96
00:07:30.790 --> 00:07:36.310
If a consumer accepts two parameters, type T and top you default methods.

97
00:07:36.490 --> 00:07:42.640
And then in the last interface supplier, the functional device abstract method is called get return

98
00:07:42.640 --> 00:07:44.560
type of T or so.

99
00:07:44.560 --> 00:07:48.490
Moving on to the next video, I'm going to be looking at the built in interfaces that are not generic,

100
00:07:48.880 --> 00:07:52.060
which support primitive data types see in the next video.
