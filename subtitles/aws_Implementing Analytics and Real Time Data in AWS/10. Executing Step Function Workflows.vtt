WEBVTT
1
00:00:00.740 --> 00:00:04.390
[Autogenerated] Okay, let's dive into a W s step functions now.

2
00:00:04.390 --> 00:00:05.490
Step functions.

3
00:00:05.490 --> 00:00:11.850
Allow us to build distributed apps and in doing it in step functions.

4
00:00:11.850 --> 00:00:16.010
The service allows us to use a visual workflow.

5
00:00:16.010 --> 00:00:21.720
Now step functions error used for executing steps in a particular order.

6
00:00:21.720 --> 00:00:25.320
So if you have a specific flow and you want to trigger

7
00:00:25.320 --> 00:00:30.640
events one after another or at the same time,

8
00:00:30.640 --> 00:00:32.840
you can use step functions.

9
00:00:32.840 --> 00:00:33.720
So let's go ahead.

10
00:00:33.720 --> 00:00:35.070
I want to get started.

11
00:00:35.070 --> 00:00:37.810
And I just want to show you this Hello world example.

12
00:00:37.810 --> 00:00:40.060
I'm not going to create anything more than this.

13
00:00:40.060 --> 00:00:42.550
I just want you to be familiar with what step

14
00:00:42.550 --> 00:00:44.580
functions are and how they're used.

15
00:00:44.580 --> 00:00:49.250
So what happens is you create a JSON formatted file and it

16
00:00:49.250 --> 00:00:52.440
uses what's called Amazon States language.

17
00:00:52.440 --> 00:00:56.660
So there's specific key value pairs you must pass in in

18
00:00:56.660 --> 00:01:00.170
order to define your step function workflow.

19
00:01:00.170 --> 00:01:02.060
And what's cool is over here on the right.

20
00:01:02.060 --> 00:01:03.710
You see this graph?

21
00:01:03.710 --> 00:01:06.810
This is the flow of all of this JSON.

22
00:01:06.810 --> 00:01:09.650
On the left, we see our hello world example.

23
00:01:09.650 --> 00:01:13.920
Step here on the right and where it matches up on the left and then

24
00:01:13.920 --> 00:01:18.740
we can see all of the other steps that proceed afterwards.

25
00:01:18.740 --> 00:01:21.970
Now it's important to know there are several different types of steps.

26
00:01:21.970 --> 00:01:23.170
So there's choices.

27
00:01:23.170 --> 00:01:28.410
There's passes, there's several, so it's important to know when to use which one.

28
00:01:28.410 --> 00:01:32.410
So an example of a choice type is right here at the

29
00:01:32.410 --> 00:01:34.820
beginning with our hello world example.

30
00:01:34.820 --> 00:01:40.440
So at this step here online 10, you can see it's a choice type,

31
00:01:40.440 --> 00:01:43.470
and we provide choices in a list format.

32
00:01:43.470 --> 00:01:46.270
So we have a bullion that we're measuring.

33
00:01:46.270 --> 00:01:51.840
And if this variable equals true, then it's gonna follow the yes step,

34
00:01:51.840 --> 00:01:53.420
which is this here on the right.

35
00:01:53.420 --> 00:01:58.940
But if it's falsy, it's gonna follow the no path and that leads to an end.

36
00:01:58.940 --> 00:02:02.090
So how it works is we pass an input and I'll show you that Here,

37
00:02:02.090 --> 00:02:05.360
coming up, we give our state machine and name so we'll do.

38
00:02:05.360 --> 00:02:05.910
Hello, world.

39
00:02:05.910 --> 00:02:06.860
Example.

40
00:02:06.860 --> 00:02:07.300
We can.

41
00:02:07.300 --> 00:02:08.480
Create a new role.

42
00:02:08.480 --> 00:02:10.280
Choose an existing or enter error.

43
00:02:10.280 --> 00:02:11.540
Olarn.

44
00:02:11.540 --> 00:02:15.910
You can set up CloudWatch log so you can log any errors

45
00:02:15.910 --> 00:02:19.620
that happen within your step functions, and then we can tag it.

46
00:02:19.620 --> 00:02:22.840
So I'm gonna go and create my state machine here,

47
00:02:22.840 --> 00:02:25.200
and then we pass in an execution.

48
00:02:25.200 --> 00:02:29.670
So what this is is we specify an execution, IDE, which is optional.

49
00:02:29.670 --> 00:02:35.140
And that's just a unique identify error to identify which step did what.

50
00:02:35.140 --> 00:02:37.260
And then, you see, we pass in some input.

51
00:02:37.260 --> 00:02:40.800
So this is our values in JSON format,

52
00:02:40.800 --> 00:02:44.920
and you can see we're setting our is hello world example key,

53
00:02:44.920 --> 00:02:47.240
which is one of the variables we measure to true.

54
00:02:47.240 --> 00:02:49.350
So it should follow the yes path.

55
00:02:49.350 --> 00:02:53.780
So if I click start execution, you can see it started.

56
00:02:53.780 --> 00:02:54.380
So it hit.

57
00:02:54.380 --> 00:02:56.190
Hello, World it past.

58
00:02:56.190 --> 00:03:00.060
Yes, you can see succeeded it hit await state.

59
00:03:00.060 --> 00:03:03.940
So this is waiting for three seconds and then it continues

60
00:03:03.940 --> 00:03:06.820
on to these parallel processing states.

61
00:03:06.820 --> 00:03:11.840
And then finally it enters our hello world final state and then it ends.

62
00:03:11.840 --> 00:03:14.890
And what happens here is you can see we just parsed and

63
00:03:14.890 --> 00:03:18.140
output that same value we passed in.

64
00:03:18.140 --> 00:03:23.460
So it duplicated the list based on these parallel steps right here.

65
00:03:23.460 --> 00:03:27.670
And you can see that there we input it one value and then we output it too.

66
00:03:27.670 --> 00:03:34.040
So we split and then output both as a combined variable in JSON format.

67
00:03:34.040 --> 00:03:38.730
So now if I go back, Let me go ahead and I want to start a new execution.

68
00:03:38.730 --> 00:03:41.230
But this time let me set this to falsy.

69
00:03:41.230 --> 00:03:44.710
I'll click on Start and then you can see.

70
00:03:44.710 --> 00:03:46.280
Now our choice has been made.

71
00:03:46.280 --> 00:03:47.830
It's not yes anymore.

72
00:03:47.830 --> 00:03:54.240
It's skipped to know and it failed because we set that variable to falsy.

73
00:03:54.240 --> 00:03:57.130
So now in the output we get nothing and we see a

74
00:03:57.130 --> 00:03:59.550
exception that's defined within the code.

75
00:03:59.550 --> 00:04:01.050
Not hello world.

76
00:04:01.050 --> 00:04:04.210
So if I look at the code here and I scrolled down to

77
00:04:04.210 --> 00:04:07.870
know right here in the middle, you can see the cause,

78
00:04:07.870 --> 00:04:09.910
which is the exception that we're printing,

79
00:04:09.910 --> 00:04:11.740
says not hello world.

80
00:04:11.740 --> 00:04:15.540
So this is how you can transition between different states using an A.

81
00:04:15.540 --> 00:04:18.340
W S hosted services.

82
00:04:18.340 --> 00:04:23.030
This is a really cool tool, and it's extremely handy if you need a guarantee,

83
00:04:23.030 --> 00:04:27.240
a certain order of processing for data in an application.

84
00:04:27.240 --> 00:04:27.620
Now.

85
00:04:27.620 --> 00:04:32.860
Another key factor with these state machines is that

86
00:04:32.860 --> 00:04:38.860
you can require manual approval so, as common scenario that can get brought up,

87
00:04:38.860 --> 00:04:44.590
is asking for guaranteeing a specific workflow order as well as

88
00:04:44.590 --> 00:04:47.170
requiring approvals and in step functions.

89
00:04:47.170 --> 00:04:50.940
You can do that so be sure to remember that and keep that in mind.

90
00:04:50.940 --> 00:04:52.220
Now, before we wrap up,

91
00:04:52.220 --> 00:04:56.400
let's just go over some common scenarios that step functions can be used.

92
00:04:56.400 --> 00:04:57.450
For now,

93
00:04:57.450 --> 00:05:02.390
the biggest thing that I've seen personally is they get used with batch jobs.

94
00:05:02.390 --> 00:05:07.740
Now, step functions can work with many different services,

95
00:05:07.740 --> 00:05:11.340
so you can see all of these tasks snippets that they provided.

96
00:05:11.340 --> 00:05:14.370
And there's a ton you can see it integrates with a lot of these

97
00:05:14.370 --> 00:05:19.550
APIs within a W s so we can invoke another workflow from our

98
00:05:19.550 --> 00:05:25.300
workflow here we can invoca function we can send a message to sqs

99
00:05:25.300 --> 00:05:32.120
and this will show you what that code should look like if it lives

100
00:05:32.120 --> 00:05:33.940
within your step function.

101
00:05:33.940 --> 00:05:37.920
So this is our state languages JSON formatted code that

102
00:05:37.920 --> 00:05:40.240
we would put in our state machine.

103
00:05:40.240 --> 00:05:41.770
So let me go and cancel this,

104
00:05:41.770 --> 00:05:44.350
and the last thing I want to talk about is event driven.

105
00:05:44.350 --> 00:05:49.920
Work flows from an express standpoint, So this is for high event workloads.

106
00:05:49.920 --> 00:05:52.280
Now, most of the time standard is fine,

107
00:05:52.280 --> 00:05:55.740
But if you have something that's streaming consistently

108
00:05:55.740 --> 00:06:01.090
or maybe pushing in data like I o t, you might wanna look into using Express now.

109
00:06:01.090 --> 00:06:04.320
You shouldn't be tested over this because it's a newer technology,

110
00:06:04.320 --> 00:06:06.270
but it's important to remember that there is a

111
00:06:06.270 --> 00:06:08.880
standard for longer duration jobs.

112
00:06:08.880 --> 00:06:12.310
And then there's express for high event workloads.

113
00:06:12.310 --> 00:06:21.000
So with that, we're gonna go ahead, will end here, and then we'll wrap up with a module review in the next clip.

