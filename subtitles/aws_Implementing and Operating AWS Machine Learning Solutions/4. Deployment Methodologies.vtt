WEBVTT
1
00:00:01.040 --> 00:00:03.630
So next, we're going to be talking about some different

2
00:00:03.630 --> 00:00:06.390
high‑level deployment methodologies,

3
00:00:06.390 --> 00:00:08.660
and these three will be important concepts that you

4
00:00:08.660 --> 00:00:11.140
need to understand for the exam.

5
00:00:11.140 --> 00:00:15.440
So first of all, we're going to be talking about continuous integration,

6
00:00:15.440 --> 00:00:18.660
followed by continuous delivery, and finally,

7
00:00:18.660 --> 00:00:20.640
continuous deployment.

8
00:00:20.640 --> 00:00:24.160
So let's look first at continuous integration. And according to

9
00:00:24.160 --> 00:00:27.880
Thoughtworks, continuous integration is a development practice

10
00:00:27.880 --> 00:00:30.600
that requires developers to integrate code into a shared

11
00:00:30.600 --> 00:00:33.140
repository several times a day.

12
00:00:33.140 --> 00:00:35.840
Each check‑in is then verified by an automated build,

13
00:00:35.840 --> 00:00:39.140
allowing teams to detect problems early.

14
00:00:39.140 --> 00:00:42.420
So if we're looking at this from more of a machine learning perspective,

15
00:00:42.420 --> 00:00:45.550
we could see situations where the code that we're leveraging to

16
00:00:45.550 --> 00:00:49.800
actually train our models is something that we're building several

17
00:00:49.800 --> 00:00:53.720
times a day, and we have some type of test that can run to verify

18
00:00:53.720 --> 00:00:55.530
that it's performing as it should.

19
00:00:55.530 --> 00:00:58.850
This is continuous integration. And so with continuous integration,

20
00:00:58.850 --> 00:01:03.070
at any point you're integrating your code back into the repository,

21
00:01:03.070 --> 00:01:07.430
you are able to verify if those problems are there. Now continuous

22
00:01:07.430 --> 00:01:12.130
delivery takes this a step further. And in this situation, the

23
00:01:12.130 --> 00:01:14.220
continuous integration happens.

24
00:01:14.220 --> 00:01:18.320
But in addition, we have automated the process of deployment.

25
00:01:18.320 --> 00:01:21.840
However, deployment does not happen automatically.

26
00:01:21.840 --> 00:01:22.640
In these cases,

27
00:01:22.640 --> 00:01:26.350
there is still a manual step required to push from a

28
00:01:26.350 --> 00:01:29.440
staging environment into production.

29
00:01:29.440 --> 00:01:33.530
But on the far end of the spectrum, we have continuous deployment. And so this

30
00:01:33.530 --> 00:01:36.370
builds on the previous two concepts that we've discussed.

31
00:01:36.370 --> 00:01:40.210
We still have continuous integration because every time we check in code,

32
00:01:40.210 --> 00:01:42.940
it does integrate with other code from our team.

33
00:01:42.940 --> 00:01:45.690
It does run a verification process by having tests

34
00:01:45.690 --> 00:01:47.260
that are run against the code.

35
00:01:47.260 --> 00:01:50.640
It also has the automated deployment process.

36
00:01:50.640 --> 00:01:53.800
But instead of waiting for that manual input, in this case,

37
00:01:53.800 --> 00:01:56.150
it is going to deploy automatically.

38
00:01:56.150 --> 00:01:59.910
So every time a developer commits, that's going to trigger this entire process,

39
00:01:59.910 --> 00:02:02.260
which will then push this into production.

40
00:02:02.260 --> 00:02:05.240
And the reason you're able to do this is because there is a

41
00:02:05.240 --> 00:02:13.000
sufficient enough test suite to verify that the code isn't going to break anything once it ends up in production.

