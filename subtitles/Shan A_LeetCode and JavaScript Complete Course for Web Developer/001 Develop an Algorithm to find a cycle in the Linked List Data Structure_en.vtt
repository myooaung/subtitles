WEBVTT
1
00:00:00.210 --> 00:00:07.200
Today's quoting interview question is asked by many companies, because it is a very popular one, so

2
00:00:07.200 --> 00:00:08.990
every developer should know this one.

3
00:00:09.510 --> 00:00:13.350
And this question is called Linked Lists Cycle.

4
00:00:14.010 --> 00:00:21.660
So in this problem, we are given the head of a linked list and we need to determine if the linked list

5
00:00:21.660 --> 00:00:23.090
has a cycle in it.

6
00:00:23.340 --> 00:00:25.840
So let's get right to it to solve this problem.

7
00:00:25.890 --> 00:00:27.870
You're given a function called HAS.

8
00:00:29.330 --> 00:00:36.380
Which takes a linked list, and we need to return a true if the link list has a cycle in it.

9
00:00:38.030 --> 00:00:43.620
So we have to design an algorithm using all of one constant memory.

10
00:00:44.480 --> 00:00:45.470
So let me explain.

11
00:00:45.650 --> 00:00:51.980
The key to solve this kind of problem is to realize that any cycle or any kind of change, if we have

12
00:00:51.980 --> 00:00:58.640
like two pointers and one pointer is twice as fast as the other pointer, that eventually those two

13
00:00:58.640 --> 00:01:00.130
pointers will end up meeting.

14
00:01:00.590 --> 00:01:05.239
And that way we can find out if this is actually a cycle or not.

15
00:01:05.810 --> 00:01:06.830
So let me show you.

16
00:01:07.340 --> 00:01:11.390
So let's say we have one pointer right here and this one's going to be a black pointer.

17
00:01:12.320 --> 00:01:19.580
And this one's going to be a blue pointer, so the black pointer will go twice as fast and the Blue

18
00:01:19.580 --> 00:01:21.920
Pointer will only go one at a time.

19
00:01:22.700 --> 00:01:23.940
So let's move this one.

20
00:01:23.960 --> 00:01:25.810
So let's move this black one twice.

21
00:01:26.150 --> 00:01:28.450
So one to go right here.

22
00:01:32.620 --> 00:01:34.840
And then the blue one would only go once.

23
00:01:36.890 --> 00:01:38.360
They'll only go for once.

24
00:01:41.060 --> 00:01:45.470
So then again, we're going to move this twice, so one to right here.

25
00:01:49.270 --> 00:01:50.620
And then we're going to move the blue.

26
00:01:51.800 --> 00:01:52.430
Just one.

27
00:01:58.930 --> 00:02:02.440
OK, and then we're going to move this twice.

28
00:02:04.620 --> 00:02:05.820
This is going to end up here.

29
00:02:08.550 --> 00:02:10.979
So going to the blue again once.

30
00:02:16.810 --> 00:02:20.590
So we're trying to go until both of those pointers are at the same.

31
00:02:24.240 --> 00:02:25.840
So, again, we're going to move.

32
00:02:26.100 --> 00:02:29.720
So now let's move the black one one, two right here.

33
00:02:33.160 --> 00:02:35.500
But we still have to move this one more time.

34
00:02:38.720 --> 00:02:40.460
So that the one who only wants.

35
00:02:43.510 --> 00:02:48.940
And then again, we're going to move the blacks two times, though, from one to right here.

36
00:02:53.140 --> 00:02:56.650
And then move the blow from here to here once.

37
00:02:57.760 --> 00:03:06.280
And see that you actually have meth, so we can tell from this that this is actually a cycle and we're

38
00:03:06.280 --> 00:03:08.160
just going to return to true Coke.

39
00:03:08.380 --> 00:03:09.270
All right, guys.

40
00:03:09.280 --> 00:03:15.370
So here we have the function called has a cycle and it takes a head.

41
00:03:16.090 --> 00:03:20.290
So the head is represents the entire list.

42
00:03:20.710 --> 00:03:23.580
So head represents the entire linked list.

43
00:03:24.490 --> 00:03:33.310
And what we want to draw is a true if the limitless has a cycle in it, otherwise, if it does not have

44
00:03:33.310 --> 00:03:40.960
a cycle, we're going to return a false and we're going to solve it using all of one constant memory.

45
00:03:42.130 --> 00:03:44.840
OK, so if you remember from the wiper.

46
00:03:46.700 --> 00:03:49.110
First, we need to create two pointers.

47
00:03:49.340 --> 00:03:55.550
The first pointer and the slow pointer both will point to the head.

48
00:03:55.580 --> 00:03:59.900
So that means they will start at the same note of the littlest.

49
00:04:01.990 --> 00:04:06.290
One will go twice as fast and one will just go one one note at a time.

50
00:04:07.270 --> 00:04:09.070
So then we're going to create a loop.

51
00:04:10.270 --> 00:04:16.040
So here are saying if fast pointer does not equal and fast forward, up next does not equal.

52
00:04:16.040 --> 00:04:16.399
No.

53
00:04:16.750 --> 00:04:18.290
Then we're going to continue looking.

54
00:04:19.180 --> 00:04:25.210
So if the fast pointer does equal or the end, the first quarter of next equals.

55
00:04:25.230 --> 00:04:27.580
No, that means it's not a cycle.

56
00:04:28.540 --> 00:04:30.820
So what that means is the latest.

57
00:04:32.130 --> 00:04:38.120
Has a note that points to no no meaning the end the end of the blacklist.

58
00:04:39.060 --> 00:04:45.840
So if there is a and if it is, the note does point to note, that means we've reached the end of the

59
00:04:45.840 --> 00:04:50.210
league list and then that means there is no cycle.

60
00:04:51.120 --> 00:04:52.830
So the list should not have.

61
00:04:52.830 --> 00:04:53.180
No.

62
00:04:53.610 --> 00:04:55.950
So that means it is a cycle.

63
00:04:57.030 --> 00:05:02.310
So what we're saying is, while Pointer does not equal and while the first quarter of next does not

64
00:05:02.310 --> 00:05:04.620
equal, that means it is a cycle.

65
00:05:05.490 --> 00:05:11.540
So what we want to do is we want to have the five pointer dot next dot next minute.

66
00:05:11.820 --> 00:05:17.360
It should go twice as fast and as slow pointer should only go once.

67
00:05:17.850 --> 00:05:19.590
One step, one note at a time.

68
00:05:19.800 --> 00:05:21.210
So slow pointer, really slow.

69
00:05:21.210 --> 00:05:22.260
Pontotoc next.

70
00:05:24.000 --> 00:05:30.150
And then we're going to check if the fast pointer equals a slow pointer, meaning that they have both

71
00:05:30.150 --> 00:05:31.580
landed on the same note.

72
00:05:32.040 --> 00:05:37.400
Then we're going to return it because eventually they're going around the circle and they both landed

73
00:05:37.410 --> 00:05:38.230
on the same note.

74
00:05:38.880 --> 00:05:41.970
So that means there is a cycle and we want to return it.

75
00:05:43.830 --> 00:05:49.920
If it's not equal, then again, we're going to go to the wall and then we're again, we're going to

76
00:05:49.920 --> 00:05:52.800
move the fast forward to two times and slow pointer once.

77
00:05:53.390 --> 00:05:56.150
Remember, as in the as I showed in the whiteboard.

78
00:05:56.580 --> 00:06:01.130
So until it reaches until both pointers reach the same note.

79
00:06:01.650 --> 00:06:02.730
So that's when we're going to return.

80
00:06:05.710 --> 00:06:12.370
And if there is a note, if the note is pointing to a note.

81
00:06:13.570 --> 00:06:15.080
That means it's not a cycle.

82
00:06:15.310 --> 00:06:18.980
So eventually the fast pointer will reach to No.

83
00:06:20.280 --> 00:06:29.250
And we're going to break out of this wide loop and return a false because the DOD is pointing to a note

84
00:06:30.180 --> 00:06:38.010
that means reached the end of the list and that means it's not going to break out of the loop and we're

85
00:06:38.010 --> 00:06:42.470
going to return a force that does not have a cycle.

86
00:06:43.770 --> 00:06:46.180
Otherwise it's going to keep looking.

87
00:06:46.950 --> 00:06:50.580
And the first quarter is going to go twice and the slope is going to go once.

88
00:06:51.150 --> 00:06:55.430
And eventually the fast pointer will land on the same note as a slow pointer.

89
00:06:55.680 --> 00:07:00.420
And we trying to true meaning that the link list has a cycle.

90
00:07:01.910 --> 00:07:09.080
So if you guys have any questions on the solution, then please leave a question in the comment and

91
00:07:09.380 --> 00:07:10.250
will get back to you.

