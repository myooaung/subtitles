WEBVTT
1
00:00:00.600 --> 00:00:02.730
Hey, what's going on, guys, today?

2
00:00:02.790 --> 00:00:07.820
I have a coding interview question, and it's a question that's asked by Amazon.

3
00:00:08.430 --> 00:00:15.580
And in this problem we're given a binary tree and we need to check whether it is a mirror of itself.

4
00:00:16.050 --> 00:00:18.350
So we're going to solve this one recursively.

5
00:00:18.540 --> 00:00:19.760
So let's get right to it.

6
00:00:20.910 --> 00:00:29.250
To solve this problem, you are given a function called symmetric and which takes a binary tree right

7
00:00:29.250 --> 00:00:31.230
here and we need to return.

8
00:00:31.230 --> 00:00:37.290
True, if the binary tree is a mirror of itself or false if it is not.

9
00:00:37.920 --> 00:00:41.770
So we have to design an algorithm where we use recursion.

10
00:00:42.450 --> 00:00:46.620
So here is a definition of recursion in computer science.

11
00:00:46.620 --> 00:00:54.900
Recursion is a method of solving a problem where the solution depends on solutions to smaller instances

12
00:00:55.260 --> 00:00:56.490
of the same problem.

13
00:00:57.030 --> 00:00:58.410
So let me explain right here.

14
00:00:59.250 --> 00:01:02.970
So basically this can be split up into two.

15
00:01:03.540 --> 00:01:07.590
So this is the left triangle and this is the right triangle.

16
00:01:08.410 --> 00:01:11.800
And what are we going to do is we're going to have a recursion.

17
00:01:11.830 --> 00:01:16.420
So first we're going to pass in the parent, which is to end this.

18
00:01:16.540 --> 00:01:19.900
And so this is the left side and that this is the right side.

19
00:01:20.290 --> 00:01:21.280
And we're going to check.

20
00:01:21.370 --> 00:01:22.240
Are these the same?

21
00:01:22.300 --> 00:01:23.480
Yes, they are all the same.

22
00:01:23.860 --> 00:01:31.900
So then we're going to pass in the child, so left and the right child and check if these are same and

23
00:01:31.900 --> 00:01:32.620
these are the same.

24
00:01:32.630 --> 00:01:35.740
So then we're going to pass this child.

25
00:01:36.640 --> 00:01:39.530
The turn and the vice chair and see D.R.C..

26
00:01:40.510 --> 00:01:45.010
So these are actually notes and this is a and this is also a note.

27
00:01:45.040 --> 00:01:45.940
So these are saying.

28
00:01:46.890 --> 00:01:51.660
So then what's going to happen because of the coercion, we're going to go back up to the parent note

29
00:01:51.660 --> 00:01:55.500
again and we're going to pass the right child first.

30
00:01:56.220 --> 00:02:01.530
And from here, we're going to pass the left child and then we're going to check again this to say,

31
00:02:02.040 --> 00:02:06.630
yes, these are saying so then we're going to go to the left child.

32
00:02:07.650 --> 00:02:09.250
And passing the right time from here.

33
00:02:09.370 --> 00:02:10.680
Check this out now.

34
00:02:10.830 --> 00:02:15.760
So these are saying the right and the left in Chapter 13.

35
00:02:16.260 --> 00:02:22.910
And so that's since all of these are the same and they are the exact mirror of each other.

36
00:02:23.280 --> 00:02:25.480
So we're going to try to be true.

37
00:02:25.980 --> 00:02:30.540
So basically in code, this is called root.

38
00:02:33.520 --> 00:02:40.930
And we're going to, first of all, check if this is, you know, and if it's enough, then we want

39
00:02:40.930 --> 00:02:47.670
to turn it true, because if there's only one note that it's a measure of itself, even though it's

40
00:02:47.680 --> 00:02:49.460
not, it's a mirror of itself.

41
00:02:49.480 --> 00:02:52.600
So we're going to try to be true because there's only one note.

42
00:02:53.730 --> 00:02:57.600
And then we're going to do is create a recursive function.

43
00:02:58.730 --> 00:03:04.450
So that you can evaluate all of these and these, would you consider its own true.

44
00:03:06.830 --> 00:03:09.110
So this would be Treehorn.

45
00:03:12.400 --> 00:03:14.470
And this would be tree to.

46
00:03:18.670 --> 00:03:27.250
OK, and then we're going to check, so if every one is equal to know or treat, two is equal to.

47
00:03:28.550 --> 00:03:36.530
Then we want to check if either this one all and also this one to so both are knowing that we can just

48
00:03:36.530 --> 00:03:36.980
return it.

49
00:03:37.000 --> 00:03:42.580
True, but if one is in all and one is likely to say no to.

50
00:03:43.130 --> 00:03:46.360
So then we have to then we have to try and false.

51
00:03:47.060 --> 00:03:52.380
OK, so now that we have done the mulcher cottage to now we know that there is a value.

52
00:03:52.820 --> 00:03:54.410
So how are we going to do that?

53
00:03:54.560 --> 00:04:01.340
We're going to try to get the value of this inventory dargavel to get the value of this.

54
00:04:01.790 --> 00:04:03.910
So this is pretty long and this is true, too.

55
00:04:04.460 --> 00:04:08.720
And then we're going to check if these these values are not equal.

56
00:04:09.110 --> 00:04:11.090
They were just going to return false.

57
00:04:11.790 --> 00:04:14.930
OK, otherwise, we have to pull over to check.

58
00:04:14.930 --> 00:04:18.920
If these are both are low then or good.

59
00:04:18.920 --> 00:04:23.530
And these both have the same value that you also get.

60
00:04:23.930 --> 00:04:27.260
So what we can do is we can check the children on these.

61
00:04:28.070 --> 00:04:30.930
So these would be like the parents and these would be like the children.

62
00:04:31.550 --> 00:04:38.060
So in this, what you can do in a recursion way, they can check if you don't let.

63
00:04:39.840 --> 00:04:43.770
The sequel to Tree to Tree to right.

64
00:04:44.670 --> 00:04:53.700
If these are people that this will go on to the next one tree dot, one tree, one left and tree to

65
00:04:54.060 --> 00:04:54.570
correct.

66
00:04:56.080 --> 00:04:59.810
And we're going to check like that, so let's check those.

67
00:04:59.830 --> 00:05:01.440
You also have another condition.

68
00:05:01.630 --> 00:05:02.680
So we're going to do and.

69
00:05:03.780 --> 00:05:08.930
Tree one, right, is equal to tree to the left.

70
00:05:10.140 --> 00:05:13.220
So that's how we're going to check them and what's happening.

71
00:05:13.270 --> 00:05:17.420
Each one is going through checking if these are there.

72
00:05:17.460 --> 00:05:17.850
No.

73
00:05:19.220 --> 00:05:24.650
For the EU to have value and they're not equal, so if they're not equal, what you want to do is return

74
00:05:24.680 --> 00:05:25.300
false and.

75
00:05:26.270 --> 00:05:27.320
These are not symmetric.

76
00:05:27.650 --> 00:05:30.940
But if these are symmetric, there is this is a no.

77
00:05:31.220 --> 00:05:31.990
This is a no.

78
00:05:32.690 --> 00:05:34.460
And so that we're going to return it.

79
00:05:34.460 --> 00:05:35.210
True for the.

80
00:05:36.140 --> 00:05:43.100
OK, and what's going to happen to recursion is going to bounce back up to the parent, right?

81
00:05:44.070 --> 00:05:51.540
And then we're going to go to the left side of this one and the right side of this one, so then we're

82
00:05:51.540 --> 00:05:59.160
going to go to the right side of tree one and left side of tree two, and we're going to check out these,

83
00:05:59.160 --> 00:06:02.110
not the hospital after these have value.

84
00:06:02.130 --> 00:06:04.370
Are these the same values as the same values?

85
00:06:04.770 --> 00:06:08.490
So we'll go on to the children, so we'll go to the right.

86
00:06:10.010 --> 00:06:15.950
This and the lack of this and we're going to check out these guys is unknown and they are saying so

87
00:06:15.950 --> 00:06:21.310
we can go to the next part, which is the left of this one in the right of this one.

88
00:06:21.320 --> 00:06:23.690
And we're going to check out these little.

89
00:06:24.050 --> 00:06:27.320
These are not these are both saying so they're symmetric.

90
00:06:27.320 --> 00:06:35.330
And that's what these both triangles are the same and we're going to return true for this.

91
00:06:35.870 --> 00:06:36.730
All right, guys.

92
00:06:36.740 --> 00:06:44.080
So here we have the function is symmetric and it takes a binary tree.

93
00:06:44.840 --> 00:06:46.280
So first we're going to check.

94
00:06:46.790 --> 00:06:53.840
So first it starts with the root to the binary tree has a root and we're going to check if it equals

95
00:06:53.840 --> 00:07:00.730
to know if it equals to know, then it's a mirror of itself and there's only one node.

96
00:07:00.740 --> 00:07:03.000
So the one node is a mirror of itself.

97
00:07:03.350 --> 00:07:05.690
So it is same.

98
00:07:05.720 --> 00:07:07.250
So we're going to return a true.

99
00:07:08.310 --> 00:07:16.830
Otherwise, we're going to go and check the children of that group, so we have a function called Ismir

100
00:07:17.640 --> 00:07:22.560
and we're taking the routes left side and roots right side.

101
00:07:23.640 --> 00:07:32.040
So what that means is the first with the left side is tree one and the right side is tree to OK, and

102
00:07:32.040 --> 00:07:39.360
then we're going to check is a tree one equal to no or there's a tree to equal to know if any of these

103
00:07:39.360 --> 00:07:40.010
are equal to don't.

104
00:07:40.050 --> 00:07:41.880
We're going to end up in this condition.

105
00:07:42.230 --> 00:07:46.250
We're going to check if tree one is equal to tree too.

106
00:07:46.860 --> 00:07:52.040
So if both are null, then of course it's going to return a true and we're done.

107
00:07:52.590 --> 00:07:58.740
But if one is a null and other one is a number, then they are not equal to each other, is going to

108
00:07:58.740 --> 00:08:00.570
return false and we're done.

109
00:08:01.620 --> 00:08:06.600
So these are not normal, then we're going to move on to this condition or we're going to check the

110
00:08:06.600 --> 00:08:11.620
value so everyone has a well, which is a value entry to has a well.

111
00:08:12.480 --> 00:08:17.030
So we're going to check if they're not equal to each other, if this isn't.

112
00:08:17.140 --> 00:08:18.870
This one is one and this one is two.

113
00:08:18.870 --> 00:08:20.340
That there's not equal to each other.

114
00:08:20.940 --> 00:08:22.760
Then we're going to return a false.

115
00:08:23.400 --> 00:08:28.770
But if they're equal to each other, this is a two and this is a two, then what we can do is we can

116
00:08:28.770 --> 00:08:34.909
move on to this this condition right here where we're going to do the whole recursion.

117
00:08:35.370 --> 00:08:41.669
So this is where we do all the recursion and we're going to check all the children of this two trees

118
00:08:42.150 --> 00:08:43.640
like I showed on the whiteboard.

119
00:08:44.039 --> 00:08:51.720
So we're going to pass in the tree ones left and the tree to his right and we're going to check all

120
00:08:51.720 --> 00:08:53.340
these conditions again.

121
00:08:54.480 --> 00:08:57.720
And then we're going to check tree ones.

122
00:08:57.720 --> 00:09:01.280
Right, and tree to his left and check all these conditions again.

123
00:09:03.220 --> 00:09:09.400
So after that, we're going to bounce back to the parent like I showed on the whiteboard, and then

124
00:09:09.400 --> 00:09:13.960
it's going to again check all of those conditions until.

125
00:09:14.960 --> 00:09:23.720
It has already checked it, both sides are a mirror image of each other, and if it's a mirror, then

126
00:09:23.720 --> 00:09:25.070
we just return to true.

127
00:09:25.430 --> 00:09:30.340
But if any of the nodes are not a there, then we're going to return a false.

128
00:09:31.010 --> 00:09:32.780
And that's that's pretty much it.

129
00:09:33.300 --> 00:09:39.350
If you have any questions, then leave your questions in the comment and I will get back to you.

