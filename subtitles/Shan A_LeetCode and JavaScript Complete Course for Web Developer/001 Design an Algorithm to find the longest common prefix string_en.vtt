WEBVTT
1
00:00:00.470 --> 00:00:02.120
Hey, guys, welcome back.

2
00:00:02.450 --> 00:00:11.750
So this is one of the questions that are commonly asked in Amazon quoting interview and I will be writing

3
00:00:11.750 --> 00:00:20.880
this code in JavaScript because I want to focus on web development of coding rooms.

4
00:00:21.800 --> 00:00:25.840
So this question is about the longest common prefix.

5
00:00:26.180 --> 00:00:33.140
And we want to write a function to find the longest common prefix string amongst an array of strings.

6
00:00:33.170 --> 00:00:42.230
So what will be given is a area of multiple strings and if there is no common prefix, so return an

7
00:00:42.230 --> 00:00:43.160
empty string.

8
00:00:44.810 --> 00:00:50.600
So let's look at this, an example, this input we're given, flower flow and flight.

9
00:00:51.640 --> 00:00:55.630
And the most common prefix is F, as you can see here.

10
00:00:56.910 --> 00:01:01.490
We want to note that all given inputs are in lowercase letters, A to Z.

11
00:01:01.560 --> 00:01:04.319
So we don't have to worry about lowercase an uppercase.

12
00:01:05.290 --> 00:01:06.940
OK, let's get on to Cody.

13
00:01:07.980 --> 00:01:14.820
OK, first, we want to have a couple of variables, so let's do this the longest.

14
00:01:18.970 --> 00:01:19.590
Prefix.

15
00:01:21.180 --> 00:01:23.100
Equal and empty strength.

16
00:01:24.330 --> 00:01:32.370
So we're going to use this to keep track of common prefixes, we will insert every common prefix we

17
00:01:32.370 --> 00:01:33.930
find into this variable.

18
00:01:35.430 --> 00:01:44.220
Second, to create that first string equal.

19
00:01:46.020 --> 00:01:49.800
Strings zero index.

20
00:01:51.370 --> 00:01:58.670
So if the purse strings characters are not in the other strings, then there's no common prefix.

21
00:01:59.590 --> 00:02:04.330
That's why we are going to compare the first string to all the other strings.

22
00:02:12.790 --> 00:02:17.400
But first string index equals zero.

23
00:02:18.360 --> 00:02:26.220
So we're going to use this to keep track of which letter we are on of the first drink while we loop

24
00:02:26.220 --> 00:02:27.690
through the rest of the drinks.

25
00:02:40.440 --> 00:02:44.100
Extreme Stotland is equal to zero.

26
00:02:44.220 --> 00:02:47.760
And we want to return the longest prefix.

27
00:02:49.280 --> 00:02:58.220
So if the value given to our function contains zero strings, we would just return zero for the longest

28
00:02:58.220 --> 00:03:01.370
prefix because there is nothing to compare.

29
00:03:07.100 --> 00:03:15.500
So now we will look to first and compare the letters of the first string, one by one with the other

30
00:03:15.500 --> 00:03:21.770
strings letters, so we do this by doing a four or let's compare.

31
00:03:23.150 --> 00:03:23.720
Letter.

32
00:03:24.840 --> 00:03:27.060
Of Bursten.

33
00:03:31.990 --> 00:03:37.150
So we're going to get the letter one by one from the first round here.

34
00:03:41.800 --> 00:03:49.780
Then we're going to create a loop which will look through all of the other strengths and we will start

35
00:03:49.900 --> 00:03:51.100
with the index of one.

36
00:03:51.130 --> 00:03:52.270
Let me show you right here.

37
00:03:53.230 --> 00:03:58.090
So for that, I equal one.

38
00:04:01.110 --> 00:04:11.820
I is less than strength's, so I'm plus plus so we can iterate through it for.

39
00:04:13.960 --> 00:04:22.270
We will start with the index one, because the first string is used for comparing with the rest of the

40
00:04:22.270 --> 00:04:24.700
street, so we will exclude the first string.

41
00:04:25.800 --> 00:04:30.720
So we are on the first train right here and we want to use it to compare with the rest of the streams

42
00:04:31.050 --> 00:04:34.990
so we will exclude the first drink and then use the second stream.

43
00:04:35.640 --> 00:04:36.510
So let's say.

44
00:04:40.150 --> 00:04:42.130
We are given this screen right here.

45
00:04:45.110 --> 00:04:47.940
Flower, slow flight, right?

46
00:04:48.590 --> 00:04:49.100
So.

47
00:04:50.060 --> 00:04:55.550
We will start the flow because flour is the comparison.

48
00:04:56.630 --> 00:04:59.390
So that's why we're starting with the index of one.

49
00:05:00.890 --> 00:05:04.310
OK, so next, we want to save the street.

50
00:05:04.460 --> 00:05:06.830
We are on in a in a variable.

51
00:05:07.940 --> 00:05:10.730
So we'll call this current work.

52
00:05:18.850 --> 00:05:24.200
So this is the current word on the next.

53
00:05:24.700 --> 00:05:31.110
So let's get the current word letter at the first string's index.

54
00:05:31.750 --> 00:05:32.710
So let me show you.

55
00:05:58.030 --> 00:06:04.300
We're going to get the current word letter at the purse strings index, so the purse strings index.

56
00:06:07.340 --> 00:06:13.970
So we can compare the first words letter with the current words that are using the static index, we

57
00:06:13.970 --> 00:06:14.210
have a.

58
00:06:15.680 --> 00:06:19.010
So both words are on and that are based on this index.

59
00:06:22.460 --> 00:06:31.250
OK, so next, we want to create a statement and compare the current letter with the first indexed letter

60
00:06:31.670 --> 00:06:37.580
and see if any of them are incorrect and just return the longest prefix.

61
00:06:38.120 --> 00:06:39.600
So let me just show you.

62
00:06:40.670 --> 00:06:41.390
So if.

63
00:06:44.500 --> 00:06:45.700
String index.

64
00:06:48.130 --> 00:06:49.720
Is greater than current.

65
00:06:52.400 --> 00:06:53.630
Current world index.

66
00:06:58.130 --> 00:06:59.210
Current, fraudulent.

67
00:07:00.520 --> 00:07:03.190
OK, then we would just return.

68
00:07:05.870 --> 00:07:07.190
The longest prefix.

69
00:07:08.800 --> 00:07:10.150
Which we have collected so far.

70
00:07:10.720 --> 00:07:19.820
So if the first string index is greater than the current words Lent, then you just want to return the

71
00:07:19.820 --> 00:07:20.720
longest prefix.

72
00:07:21.100 --> 00:07:24.020
So let's say we are comparing flower with flow.

73
00:07:24.460 --> 00:07:26.820
So I'm here for you.

74
00:07:36.690 --> 00:07:47.520
So flour was flow so low as f l o w and that would be the common prefix between these two.

75
00:07:48.650 --> 00:07:52.970
OK, but if we were on E, we're here.

76
00:07:55.670 --> 00:08:04.000
Then the index is four, but flow only contains up to the three index, so there's nothing left to compare

77
00:08:04.400 --> 00:08:07.670
and that's why we're going to return the longest prefix.

78
00:08:09.560 --> 00:08:12.080
OK, next, we'll add one more.

79
00:08:13.790 --> 00:08:16.250
So or comfier?

80
00:08:21.220 --> 00:08:25.720
Is not equal to current letter.

81
00:08:29.540 --> 00:08:30.530
Let me break this down.

82
00:08:33.760 --> 00:08:39.880
So what this is trying to say is if the company letter does not equal the current budget, then we should

83
00:08:39.880 --> 00:08:41.630
return the longest prefix.

84
00:08:41.980 --> 00:08:44.860
So if our compare with flight.

85
00:08:58.110 --> 00:08:58.500
Right.

86
00:08:58.530 --> 00:08:59.700
So flight.

87
00:09:00.630 --> 00:09:02.940
And Flower have common and.

88
00:09:06.180 --> 00:09:14.730
If they if we land on the eye of the flight, then there's then it's not common and we just want to

89
00:09:14.730 --> 00:09:17.700
return what we have so far in the longest prefix.

90
00:09:22.300 --> 00:09:31.780
OK, so if we still have a common prefix and the first word is not longer than the current word, then

91
00:09:31.780 --> 00:09:40.120
we add the compare letter to the longest prefix variable and increase the first string index so we can

92
00:09:40.120 --> 00:09:48.490
check that the next character of the first string with a with the rest of the strings, meaning we are

93
00:09:48.490 --> 00:09:55.090
on F of the first word on the first string and now we will move to El.

94
00:09:56.010 --> 00:10:02.810
Until the whole street is complete, so let's say we're comparing flour because the first.

95
00:10:03.270 --> 00:10:06.750
So we're going to do is after this.

96
00:10:07.720 --> 00:10:10.300
We're going to implement the longest.

97
00:10:11.550 --> 00:10:12.150
Prefix.

98
00:10:24.310 --> 00:10:29.530
Actually, what we're going to do is implement the first string index.

99
00:10:31.630 --> 00:10:39.010
Because we want to move to the next letter in the stream to compare with the rest of the strings, and

100
00:10:39.820 --> 00:10:47.230
if we have gone to this statement and we have not returned the longest prefix, that means that we still

101
00:10:47.230 --> 00:10:49.970
have a common prefix.

102
00:10:50.170 --> 00:10:53.080
So we're going to add it to the longest prefix.

103
00:11:01.020 --> 00:11:05.100
And we're going to add the compare later, because it's still common.

104
00:11:14.060 --> 00:11:21.350
So next, we just want to return whatever we have in the longest prefix.

105
00:11:25.710 --> 00:11:33.290
And we want to return his drink, so we'll just return the longest prefix and, you know, because we're

106
00:11:33.480 --> 00:11:38.460
returning this at the end, because it is possible that all strains or common prefix.

107
00:11:38.880 --> 00:11:43.420
So we need to return to the longest prefix in that scenario.

108
00:11:44.010 --> 00:11:52.260
So example, Apple, Apple, Apple will not be returned in the above return statement right here, because

109
00:11:53.100 --> 00:11:56.310
all the letters are a common prefix.

110
00:11:56.340 --> 00:11:59.970
So we must in the end, return the longest prefix right here.

111
00:12:01.620 --> 00:12:09.310
Also, there could be a scenario that we receive an empty string area with an empty string.

112
00:12:09.420 --> 00:12:15.630
So at that at that point, we'll also have to return the longest pieces right here.

113
00:12:20.110 --> 00:12:28.370
So there was something that was wrong with it when I ran it earlier, and it looks like Estie Press

114
00:12:28.420 --> 00:12:32.010
was written incorrectly like this, so I fixed it.

115
00:12:32.830 --> 00:12:43.750
And also this was inside the for loop, but it should be inside the second floor loop, but it should

116
00:12:43.750 --> 00:12:45.730
be inside of the first floor because.

117
00:12:46.920 --> 00:12:52.530
We will go through this loop and then what's going to happen is we're going to add the company letter

118
00:12:52.540 --> 00:12:57.720
so long as prefix and we're going to implement the first string index, so.

119
00:12:59.340 --> 00:13:01.940
It should be outside of this second.

120
00:13:04.350 --> 00:13:05.320
Let me run the code.

121
00:13:08.840 --> 00:13:13.310
And it's accepted, so the common prefix is spelled.

122
00:13:14.970 --> 00:13:19.710
And that's what's that's what's written and that's what's expected.

123
00:13:21.230 --> 00:13:26.900
This is all for now, let me know if you have any questions and join me on the next one.

124
00:13:27.050 --> 00:13:27.560
Good luck.

