WEBVTT
1
1

00:00:05.320  -->  00:00:08.010
<v Tim>So a declaration consists of the data type</v>
2

2

00:00:08.010  -->  00:00:10.160
and variable name or names.
3

3

00:00:10.160  -->  00:00:13.250
A variable name must be a valid identifier.
4

4

00:00:13.250  -->  00:00:15.310
Now you can identify multiple variables
5

5

00:00:15.310  -->  00:00:17.620
of the same type on a single line,
6

6

00:00:17.620  -->  00:00:21.070
but not multiple variables of different types.
7

7

00:00:21.070  -->  00:00:23.140
So what we're going to do is create a new foo class
8

8

00:00:23.140  -->  00:00:24.940
in a new IntelliJ project.
9

9

00:00:24.940  -->  00:00:27.010
I've called mine PrimitiveData.
10

10

00:00:27.010  -->  00:00:27.910
So let's go ahead and do that.
11

11

00:00:27.910  -->  00:00:29.310
I'm gonna paste in the code.
12

12

00:00:31.080  -->  00:00:33.420
Call this one Foo, and I promise we'll start using
13

13

00:00:33.420  -->  00:00:36.900
more meaningful names as we go through the course.
14

14

00:00:36.900  -->  00:00:39.620
So you can see we've got a basic class there
15

15

00:00:39.620  -->  00:00:41.540 line:15% 
with a main method, and you can see
16

16

00:00:41.540  -->  00:00:43.320 line:15% 
there's a variable declaration for each
17

17

00:00:43.320  -->  00:00:45.783 line:15% 
of the eight primitive data types in Java.
18

18

00:00:46.670  -->  00:00:48.780
Now this code is demonstrating that you can declare
19

19

00:00:48.780  -->  00:00:51.950
multiple variables of the same type on a single line.
20

20

00:00:51.950  -->  00:00:54.640
You can see I've done that on lines 14 and 18.
21

21

00:00:54.640  -->  00:00:57.390
What happens though if we try to add multiple variables
22

22

00:00:57.390  -->  00:01:00.000
of different types on the same line?
23

23

00:01:00.000  -->  00:01:05.000
Well, let's test that by typing int myInt comma
24

24

00:01:05.340  -->  00:01:06.173
short
25

25

00:01:07.630  -->  00:01:08.463
mySecondShort.
26

26

00:01:10.460  -->  00:01:12.930
You can see we've got a compile error there,
27

27

00:01:12.930  -->  00:01:15.810
Identifier expected, so that confirms that we can't have
28

28

00:01:15.810  -->  00:01:19.090
different types of multiple variables on the same line.
29

29

00:01:19.090  -->  00:01:21.450
Solution is to either break it into multiple lines,
30

30

00:01:21.450  -->  00:01:25.090
or we can also convert the comma to a semicolon,
31

31

00:01:25.090  -->  00:01:27.500
which, of course, is valid in Java, enabling you,
32

32

00:01:27.500  -->  00:01:30.293
you can have multiple statements on a single line.
33

33

00:01:31.360  -->  00:01:32.490
All right, so at this point we've now got
34

34

00:01:32.490  -->  00:01:34.530
data variables with no data.
35

35

00:01:34.530  -->  00:01:36.770
Data in the form of literals can be assigned
36

36

00:01:36.770  -->  00:01:38.400
to these variables.
37

37

00:01:38.400  -->  00:01:40.570
The exam explores some of the implications
38

38

00:01:40.570  -->  00:01:43.810
of setting literal data to typed variables
39

39

00:01:43.810  -->  00:01:46.110
where there is a type mismatch.
40

40

00:01:46.110  -->  00:01:49.120
Valid literals are numeric values in base 10,
41

41

00:01:49.120  -->  00:01:52.060
hexadecimal or octal forms.
42

42

00:01:52.060  -->  00:01:54.340
An unmodified integer value is assumed
43

43

00:01:54.340  -->  00:01:57.100
to be a 32 bit int primitive, and a value
44

44

00:01:57.100  -->  00:02:01.570
containing a decimal point is assumed to be a 64 bit double.
45

45

00:02:01.570  -->  00:02:04.040
Keep in mind that in Java a single character value
46

46

00:02:04.040  -->  00:02:07.580
in single quotes is considered a valid char literal,
47

47

00:02:07.580  -->  00:02:10.080
but any characters surrounded by double quotes
48

48

00:02:10.080  -->  00:02:11.820
is considered to be a string literal.
49

49

00:02:11.820  -->  00:02:14.380
So in other words, A in single quotes is not equal
50

50

00:02:14.380  -->  00:02:17.563
to A in double quotes, when it comes to literals in Java.
51

51

00:02:18.650  -->  00:02:21.200
So in this slide, you can see for the various literal types,
52

52

00:02:21.200  -->  00:02:23.660
numeric, char and Boolean, I'm showing
53

53

00:02:23.660  -->  00:02:26.210
some valid literal examples for you.
54

54

00:02:26.210  -->  00:02:28.640
Basically you should be familiar with all the ways
55

55

00:02:28.640  -->  00:02:31.830
to set a variable to a literal for the exam.
56

56

00:02:31.830  -->  00:02:33.630
Let's now create a new class Foo2
57

57

00:02:33.630  -->  00:02:35.230
in our primitive data project,
58

58

00:02:35.230  -->  00:02:37.950
which will demonstrate some of these things on the slides,
59

59

00:02:37.950  -->  00:02:41.210
basically initialising primitive data variable declarations
60

60

00:02:41.210  -->  00:02:42.423
to literal values.
61

61

00:02:43.660  -->  00:02:45.650
So we'll go back to our project, as I mentioned,
62

62

00:02:45.650  -->  00:02:47.950
in the src file to we'll create a new project,
63

63

00:02:47.950  -->  00:02:51.870
a new class rather, Foo2, and I'm going to
64

64

00:02:51.870  -->  00:02:53.723
paste in that code that I mentioned.
65

65

00:02:55.980  -->  00:02:57.160
And you can see that what I've done
66

66

00:02:57.160  -->  00:02:59.570
for the primitive data types
67

67

00:02:59.570  -->  00:03:03.140
is set the data variables to the value 127.
68

68

00:03:03.140  -->  00:03:05.620
Now this is a valid numeric value for all the data types,
69

69

00:03:05.620  -->  00:03:08.190
with the exception of a Boolean.
70

70

00:03:08.190  -->  00:03:10.280
We'll explore literals and their ranges more in depth
71

71

00:03:10.280  -->  00:03:11.930
in the next video, actually.
72

72

00:03:11.930  -->  00:03:13.500
But you can that I've got that example there,
73

73

00:03:13.500  -->  00:03:16.290
and, moving down, we've just got a simple output.
74

74

00:03:16.290  -->  00:03:18.633
So, if I run this Foo2,
75

75

00:03:20.990  -->  00:03:22.240
no real surprises there.
76

76

00:03:22.240  -->  00:03:23.900
We've got the various values
77

77

00:03:23.900  -->  00:03:27.210
associated with each of our variables.
78

78

00:03:27.210  -->  00:03:28.140
The point there was that you can see that
79

79

00:03:28.140  -->  00:03:30.050
printing the primitive data variables
80

80

00:03:30.050  -->  00:03:31.870
results in different formats in some cases.
81

81

00:03:31.870  -->  00:03:33.370
So let me just run that again.
82

82

00:03:35.200  -->  00:03:36.950
Based on the type of the data variable,
83

83

00:03:36.950  -->  00:03:39.900
you will get different formats in some cases.
84

84

00:03:39.900  -->  00:03:43.290
In some cases, numeric literals will have a suffix.
85

85

00:03:43.290  -->  00:03:47.480
Valid suffixes exist for type long, float and double,
86

86

00:03:47.480  -->  00:03:49.640
and the case of the suffix doesn't matter,
87

87

00:03:49.640  -->  00:03:52.670
which force the literal value being assigned to the variable
88

88

00:03:52.670  -->  00:03:55.860
to be the type specified by the suffix.
89

89

00:03:55.860  -->  00:03:58.560
And I'll just paste in some code to make that clearer.
90

90

00:03:58.560  -->  00:04:01.820
Again, these are things that you'll certainly want to know
91

91

00:04:01.820  -->  00:04:03.730
leading in to the exam.
92

92

00:04:03.730  -->  00:04:06.583
If I paste this code down below the other code,
93

93

00:04:08.750  -->  00:04:09.640
no real surprises there.
94

94

00:04:09.640  -->  00:04:12.210
You can see we're using the L suffix for a long,
95

95

00:04:12.210  -->  00:04:16.433
the F for our floats, and the D suffix for our doubles.
96

96

00:04:18.000  -->  00:04:18.853
Running the code.
97

97

00:04:20.463  -->  00:04:22.350
And the output is as expected.
98

98

00:04:22.350  -->  00:04:25.810
Now, you also use the exponential literal form
99

99

00:04:25.810  -->  00:04:28.760
for doubles and floats, and I'll copy some code in there
100

100

00:04:28.760  -->  00:04:30.663
to paste to show you that format.
101

101

00:04:32.220  -->  00:04:33.690
You can see we've got a different format there,
102

102

00:04:33.690  -->  00:04:36.490
and again that's using the exponential literal form.
103

103

00:04:36.490  -->  00:04:39.030
In addition, you can use binary, hexadecimal,
104

104

00:04:39.030  -->  00:04:42.760
and octal forms of literals for any of the numerics.
105

105

00:04:42.760  -->  00:04:46.453
So let's see an example of a binary, octal and hexadecimal.
106

106

00:04:49.630  -->  00:04:51.720
Typo there, which I'll fix.
107

107

00:04:51.720  -->  00:04:54.440
So you can see the first example there, binary value,
108

108

00:04:54.440  -->  00:04:57.000
zero B on line 53,
109

109

00:04:57.000  -->  00:04:59.220
zero B signifies that it's a binary number
110

110

00:04:59.220  -->  00:05:00.980
'cause the prefix is zero B.
111

111

00:05:00.980  -->  00:05:04.800
On line 56, octal, the value there is
112

112

00:05:04.800  -->  00:05:08.370 line:15% 
octal value for 127, zero one seven seven,
113

113

00:05:08.370  -->  00:05:10.930 line:15% 
with zero being the octal prefix,
114

114

00:05:10.930  -->  00:05:15.350
and hexadecimal 127, we're using that on line 159,
115

115

00:05:15.350  -->  00:05:18.500
to assign that value, and zero X is the prefix
116

116

00:05:18.500  -->  00:05:21.210
for specifying a hexadecimal number.
117

117

00:05:21.210  -->  00:05:23.810
You can also use a char literal for any of the numerics,
118

118

00:05:23.810  -->  00:05:26.800
which is something that you should know,
119

119

00:05:26.800  -->  00:05:28.783
so let's have a look at some code for that.
120

120

00:05:31.188  -->  00:05:34.610
You can see that we've defined that on line 62 through 64,
121

121

00:05:34.610  -->  00:05:35.563
and if we run that,
122

122

00:05:36.510  -->  00:05:38.393
we should also get our other outputs,
123

123

00:05:39.230  -->  00:05:42.640
your confirmation that our binary, octal,
124

124

00:05:42.640  -->  00:05:44.430
and hexadecimal values are all 127,
125

125

00:05:44.430  -->  00:05:48.540
but also the values for our byte, char and double,
126

126

00:05:48.540  -->  00:05:52.830
97, A, and 97 dot zero, respectively.
127

127

00:05:52.830  -->  00:05:55.010
In addition, you can use Unicode characters
128

128

00:05:55.010  -->  00:05:57.860
for any of the numerics, so let's see an example of that.
129

129

00:06:04.070  -->  00:06:04.903
Run that.
130

130

00:06:06.380  -->  00:06:09.180
And there's our Unicode representation values,
131

131

00:06:09.180  -->  00:06:12.670
and obviously it's the backslash U being the prefix
132

132

00:06:12.670  -->  00:06:15.890
to define a Unicode number, then a four digit number.
133

133

00:06:15.890  -->  00:06:18.380
Now, you can use the underscore for readability
134

134

00:06:18.380  -->  00:06:21.200
of any numeric value, as long as you don't
135

135

00:06:21.200  -->  00:06:24.750
butt the underscore up against the prefix or suffix,
136

136

00:06:24.750  -->  00:06:28.150
and it's not the first or last symbol in the literal.
137

137

00:06:28.150  -->  00:06:31.360
You'll note that commas are not valid in numeric literals.
138

138

00:06:31.360  -->  00:06:32.980
An example would probably help here,
139

139

00:06:32.980  -->  00:06:35.470
so let me just copy a bit of code again.
140

140

00:06:35.470  -->  00:06:36.470
We'll paste that in.
141

141

00:06:38.985  -->  00:06:40.680
And you can see our examples there.
142

142

00:06:40.680  -->  00:06:41.670
So we've got various versions
143

143

00:06:41.670  -->  00:06:44.870
which are all valid of defining values.
144

144

00:06:44.870  -->  00:06:47.020
We've got octal number there, we've got a hexadecimal number
145

145

00:06:47.020  -->  00:06:48.930
and a binary number and other numbers,
146

146

00:06:48.930  -->  00:06:50.977
all using underscores, which are completely valid.
147

147

00:06:50.977  -->  00:06:52.440
And we can run this.
148

148

00:06:55.939  -->  00:06:56.960
And you can see that's quite valid,
149

149

00:06:56.960  -->  00:06:59.000
and the code compiles and works.
150

150

00:06:59.000  -->  00:07:00.760
So I've spent a lot of time in this video
151

151

00:07:00.760  -->  00:07:03.420
showing you values that are valid.
152

152

00:07:03.420  -->  00:07:04.790
Let's finish the video by looking
153

153

00:07:04.790  -->  00:07:06.810
at some things that aren't valid.
154

154

00:07:06.810  -->  00:07:08.980
Firstly we'll start with exploring some literals
155

155

00:07:08.980  -->  00:07:11.540
with underscores that aren't valid.
156

156

00:07:11.540  -->  00:07:12.680
So I'm going to take some code,
157

157

00:07:12.680  -->  00:07:15.600
copy that, paste it in, and you can see
158

158

00:07:15.600  -->  00:07:18.210
that we've got some errors there, and I put a comment
159

159

00:07:18.210  -->  00:07:21.030
to let you know the reasons why it's not valid.
160

160

00:07:21.030  -->  00:07:22.700
Firstly, have line 92.
161

161

00:07:22.700  -->  00:07:24.370
We've got a binary number there, but we can't have
162

162

00:07:24.370  -->  00:07:28.290
an underscore directly after the prefix zero B,
163

163

00:07:28.290  -->  00:07:31.220
and the same applies for the hexadecimal number,
164

164

00:07:31.220  -->  00:07:33.147
which we've defined on line 93.
165

165

00:07:33.147  -->  00:07:34.470
Again, you can't have an underscore
166

166

00:07:34.470  -->  00:07:36.910
directly after that prefix.
167

167

00:07:36.910  -->  00:07:39.770
In the case of line 94, you can't have an underscore
168

168

00:07:39.770  -->  00:07:41.920
at the end of a literal number.
169

169

00:07:41.920  -->  00:07:45.570
Line 95, an underscore cannot be prior to a suffix,
170

170

00:07:45.570  -->  00:07:47.470
and the suffix, if you recall, was L for long,
171

171

00:07:47.470  -->  00:07:49.410
F for float and D for double.
172

172

00:07:49.410  -->  00:07:51.530
The underscore cannot be first character
173

173

00:07:51.530  -->  00:07:53.310
at the start of a literal, so you can't have
174

174

00:07:53.310  -->  00:07:56.260
an underscore 1000 there on line 96, which is invalid,
175

175

00:07:56.260  -->  00:07:58.560
and also the underscore cannot prefix
176

176

00:07:58.560  -->  00:08:00.560
an exponential in a literal as well.
177

177

00:08:00.560  -->  00:08:03.830
You can see the underscore E 10 being invalid.
178

178

00:08:03.830  -->  00:08:05.690
Now you can't set a Boolean to zero
179

179

00:08:05.690  -->  00:08:07.430
or anything but true or false.
180

180

00:08:07.430  -->  00:08:09.300
Keep that in mind, that some languages you can do that,
181

181

00:08:09.300  -->  00:08:10.610
but you can't in Java.
182

182

00:08:10.610  -->  00:08:13.553
And also you cannot set any primitive value to null.
183

183

00:08:14.420  -->  00:08:16.640
So I'm gonna finish off, and just show you that example
184

184

00:08:16.640  -->  00:08:19.030
of both the Boolean number, trying to set that
185

185

00:08:19.030  -->  00:08:21.700
to a value of zero, which is invalid,
186

186

00:08:21.700  -->  00:08:24.130
but also trying to assign some of these values
187

187

00:08:24.970  -->  00:08:27.270
to null, or assigning a value of null to them.
188

188

00:08:28.710  -->  00:08:30.380
You can see they're all invalid,
189

189

00:08:30.380  -->  00:08:33.160
looking for byte and found a null, and for Boolean,
190

190

00:08:33.160  -->  00:08:35.690
looking for Boolean and it's found an int there.
191

191

00:08:35.690  -->  00:08:36.990
Right, so let's finish the video here.
192

192

00:08:36.990  -->  00:08:39.220
What I'm gonna do before I finish is just comment this out,
193

193

00:08:39.220  -->  00:08:41.280
so that if you happen to download this file,
194

194

00:08:41.280  -->  00:08:44.190
it'll be at least valid code, and it will compile.
195

195

00:08:44.190  -->  00:08:45.690
So, see you in the next video.
