WEBVTT
1
1

00:00:05.130  -->  00:00:05.963
<v Instructor>All right, so let's start</v>
2

2

00:00:05.963  -->  00:00:08.330
this section with the question why java?
3

3

00:00:08.330  -->  00:00:10.120
Because maybe someone has asked you this question
4

4

00:00:10.120  -->  00:00:12.380
in your past and you didn't have the best response.
5

5

00:00:12.380  -->  00:00:15.160
So the responses to why java are the key features
6

6

00:00:15.160  -->  00:00:16.800
which you might be tested on.
7

7

00:00:16.800  -->  00:00:18.330
And these are, firstly,
8

8

00:00:18.330  -->  00:00:22.120
Java is derived from C and C++ but simplified,
9

9

00:00:22.120  -->  00:00:24.410
Java is architecture neutral,
10

10

00:00:24.410  -->  00:00:25.843
Java is object oriented,
11

11

00:00:25.843  -->  00:00:28.220
Java is statically typed,
12

12

00:00:28.220  -->  00:00:30.463
Java is a dynamic programming language,
13

13

00:00:31.780  -->  00:00:34.180
Java supports multi-threaded processing,
14

14

00:00:34.180  -->  00:00:37.070
distributed computing is also supported by Java,
15

15

00:00:37.070  -->  00:00:39.940
and memory management is handled by the Java environment
16

16

00:00:39.940  -->  00:00:41.040
and not the developer.
17

17

00:00:42.670  -->  00:00:44.010
So let's go through each of these terms.
18

18

00:00:44.010  -->  00:00:47.650
Firstly, Java is derived from C and C++ but simplified.
19

19

00:00:47.650  -->  00:00:48.483
So why Java?
20

20

00:00:48.483  -->  00:00:50.290
Well, we might ask the original developers.
21

21

00:00:50.290  -->  00:00:54.150
Java was initially started to enhance the C++ language,
22

22

00:00:54.150  -->  00:00:56.690
which is the object oriented extension
23

23

00:00:56.690  -->  00:00:58.230
of the C language.
24

24

00:00:58.230  -->  00:01:01.210
C and C++ languages are compiled into machine
25

25

00:01:01.210  -->  00:01:03.010
specific assembly language,
26

26

00:01:03.010  -->  00:01:05.020
but Java was designed as a write once,
27

27

00:01:05.020  -->  00:01:07.200
run anywhere language since it's initial goal
28

28

00:01:07.200  -->  00:01:11.450
was to be deployed on multiple non-pc devices.
29

29

00:01:11.450  -->  00:01:14.320
Java code is compiled into byte code,
30

30

00:01:14.320  -->  00:01:16.660
which is interpreted by the Java virtual machine
31

31

00:01:16.660  -->  00:01:19.520
and then translated to execute on the machine
32

32

00:01:19.520  -->  00:01:20.743
it's being hosted on.
33

33

00:01:22.400  -->  00:01:24.461
The architects of Java eliminated
34

34

00:01:24.461  -->  00:01:27.150
more complicated features such as pointers,
35

35

00:01:27.150  -->  00:01:30.160
operator overloading, multiple class inheritance,
36

36

00:01:30.160  -->  00:01:31.490
and destructors.
37

37

00:01:31.490  -->  00:01:33.360
They added garbage collection for automated
38

38

00:01:33.360  -->  00:01:35.540
memory management and the ability
39

39

00:01:35.540  -->  00:01:37.570
to write a multithreaded application
40

40

00:01:37.570  -->  00:01:40.203
as well as library support for network programming.
41

41

00:01:42.060  -->  00:01:44.090
Java is architecture neutral.
42

42

00:01:44.090  -->  00:01:45.650
So architecture neutral is another way
43

43

00:01:45.650  -->  00:01:47.760
of saying platform independent.
44

44

00:01:47.760  -->  00:01:50.300
An application developer can write Java code
45

45

00:01:50.300  -->  00:01:52.450
without knowing or caring what hardware
46

46

00:01:52.450  -->  00:01:54.730
platform or platforms the application
47

47

00:01:54.730  -->  00:01:56.530
will be deployed to.
48

48

00:01:56.530  -->  00:01:59.600
Java compiles source code into Java byte code,
49

49

00:01:59.600  -->  00:02:01.960
which is then interpreted by the Java virtual machine
50

50

00:02:01.960  -->  00:02:04.490
using just-in-time compilation to optimise
51

51

00:02:04.490  -->  00:02:07.283
and run the application on the target machine.
52

52

00:02:08.900  -->  00:02:10.380
Java is object oriented.
53

53

00:02:10.380  -->  00:02:13.080
So Java is a class based object oriented language.
54

54

00:02:13.080  -->  00:02:15.750
From an object oriented theorist's point of view,
55

55

00:02:15.750  -->  00:02:18.370
Java is not a pure object oriented language
56

56

00:02:18.370  -->  00:02:20.360
since it supports some primitive data types
57

57

00:02:20.360  -->  00:02:22.970
for optimization of performance.
58

58

00:02:22.970  -->  00:02:26.270
Java allows precise access control of class members
59

59

00:02:26.270  -->  00:02:28.480
supporting encapsulation of data.
60

60

00:02:28.480  -->  00:02:31.150
So you can hide both data and implementation details
61

61

00:02:31.150  -->  00:02:33.380
from other classes, which use or extend
62

62

00:02:33.380  -->  00:02:35.490
the class you create.
63

63

00:02:35.490  -->  00:02:37.440
Java supports dynamic binding
64

64

00:02:37.440  -->  00:02:39.070
which delays the determination
65

65

00:02:39.070  -->  00:02:40.830
of the code to be executed for
66

66

00:02:40.830  -->  00:02:43.120
a specific method until runtime
67

67

00:02:43.120  -->  00:02:44.703
which supports polymorphism.
68

68

00:02:46.520  -->  00:02:49.840
Java supports both overloaded and overridden methods.
69

69

00:02:49.840  -->  00:02:51.110
When you override a method,
70

70

00:02:51.110  -->  00:02:52.580
you're using polymorphism,
71

71

00:02:52.580  -->  00:02:54.670
declaring that the class has its own custom
72

72

00:02:54.670  -->  00:02:56.570
behaviour for a particular method
73

73

00:02:56.570  -->  00:02:59.290
or additional behaviour to its extended class
74

74

00:02:59.290  -->  00:03:01.570
and it is this behaviour that will execute
75

75

00:03:01.570  -->  00:03:04.200
at runtime when the object's runtime type
76

76

00:03:04.200  -->  00:03:05.660
is fully known.
77

77

00:03:05.660  -->  00:03:07.810
Dynamic binding is also known as late binding
78

78

00:03:07.810  -->  00:03:09.670
or runtime binding.
79

79

00:03:09.670  -->  00:03:12.010
Static binding is binding that can be known
80

80

00:03:12.010  -->  00:03:13.820
at compile time and is also known
81

81

00:03:13.820  -->  00:03:14.713
as early binding.
82

82

00:03:16.510  -->  00:03:19.010
So Java supports both the inheritance feature
83

83

00:03:19.010  -->  00:03:20.650
of an object oriented language,
84

84

00:03:20.650  -->  00:03:23.080
by allowing classes to extend or be subtypes
85

85

00:03:23.080  -->  00:03:24.340
of other classes.
86

86

00:03:24.340  -->  00:03:28.150
So this is the "IS A" feature of object orientation.
87

87

00:03:28.150  -->  00:03:30.360
Java also supports the composition feature
88

88

00:03:30.360  -->  00:03:32.200
of an object oriented language,
89

89

00:03:32.200  -->  00:03:35.000
the "HAS A" feature, by allowing class data
90

90

00:03:35.000  -->  00:03:38.100
to be of any other defined class type.
91

91

00:03:38.100  -->  00:03:40.550
So it is important to note that Java supports
92

92

00:03:40.550  -->  00:03:42.850
a single inheritance class structure,
93

93

00:03:42.850  -->  00:03:44.950
a class can only extend one class,
94

94

00:03:44.950  -->  00:03:47.823
or only have a single parent class in its hierarchy.
95

95

00:03:49.700  -->  00:03:51.350
So let's look at types of inheritance
96

96

00:03:51.350  -->  00:03:53.430
and how it applies to Java.
97

97

00:03:53.430  -->  00:03:55.210
Multiple inheritance of state,
98

98

00:03:55.210  -->  00:03:56.650
no, Java doesn't support that.
99

99

00:03:56.650  -->  00:03:58.950
State is inherited from a supertype
100

100

00:03:58.950  -->  00:04:01.570
and classes can only have one supertype.
101

101

00:04:01.570  -->  00:04:03.710
Multiple inheritance of implementation,
102

102

00:04:03.710  -->  00:04:05.190
no, Java doesn't support that.
103

103

00:04:05.190  -->  00:04:07.800
Here, implementation means inheriting
104

104

00:04:07.800  -->  00:04:09.830
method definitions from a supertype
105

105

00:04:09.830  -->  00:04:13.820
and classes in Java again can only have one supertype.
106

106

00:04:13.820  -->  00:04:15.640
Multiple inheritance of type,
107

107

00:04:15.640  -->  00:04:17.200
yes Java does support that.
108

108

00:04:17.200  -->  00:04:20.100
Java allows classes to extend its type
109

109

00:04:20.100  -->  00:04:22.283
as well as implement other types.
110

110

00:04:24.110  -->  00:04:26.120
Java is statically typed.
111

111

00:04:26.120  -->  00:04:28.260
Java is a statically typed language
112

112

00:04:28.260  -->  00:04:30.340
which requires you to declare the data types
113

113

00:04:30.340  -->  00:04:32.670
of your variables before you use them,
114

114

00:04:32.670  -->  00:04:35.240
while dynamically typed languages do not.
115

115

00:04:35.240  -->  00:04:36.890
Statically typed languages perform
116

116

00:04:36.890  -->  00:04:39.170
type checking at compile time.
117

117

00:04:39.170  -->  00:04:41.880
Dynamically typed languages are checked at runtime.
118

118

00:04:41.880  -->  00:04:44.970
Each variable in Java must be declared with a type.
119

119

00:04:44.970  -->  00:04:48.690
Java is considered more strongly typed than C and C++
120

120

00:04:48.690  -->  00:04:51.240
because it eliminated pointer arithmetic,
121

121

00:04:51.240  -->  00:04:53.220
but it is considered not as strongly typed
122

122

00:04:53.220  -->  00:04:54.919
as some other languages, because it will perform
123

123

00:04:54.919  -->  00:04:57.610
some implicit type conversions in order
124

124

00:04:57.610  -->  00:04:59.453
to cut down programmer effort.
125

125

00:05:01.320  -->  00:05:03.790
Java is a dynamic programming language.
126

126

00:05:03.790  -->  00:05:06.500
A dynamic programming language is an extensible language
127

127

00:05:06.500  -->  00:05:09.110
which provides the ability to add new code,
128

128

00:05:09.110  -->  00:05:11.100
extend objects and definitions,
129

129

00:05:11.100  -->  00:05:12.923
and modify the type system.
130

130

00:05:14.500  -->  00:05:17.610
So we already know that Java is a statically typed language,
131

131

00:05:17.610  -->  00:05:20.520
but it's still considered a dynamic programming language
132

132

00:05:20.520  -->  00:05:22.330
because of the following features:
133

133

00:05:22.330  -->  00:05:24.840
the environment is dynamically extensible,
134

134

00:05:24.840  -->  00:05:27.940
whereby classes are loaded on the fly as required.
135

135

00:05:27.940  -->  00:05:29.670
The language supports reflection,
136

136

00:05:29.670  -->  00:05:30.830
which allows objects to be
137

137

00:05:30.830  -->  00:05:33.380
queried at runtime and manipulated.
138

138

00:05:33.380  -->  00:05:36.150
Java supports class extension and inheritance,
139

139

00:05:36.150  -->  00:05:38.900
allowing behaviour to be altered at runtime.
140

140

00:05:38.900  -->  00:05:41.450
And low level operations are dynamically executed
141

141

00:05:41.450  -->  00:05:42.973
by the Java virtual machine.
142

142

00:05:44.730  -->  00:05:47.270
Java supports multi-threaded processing.
143

143

00:05:47.270  -->  00:05:49.490
Java does support multi threaded execution,
144

144

00:05:49.490  -->  00:05:51.610
however it is not automatic.
145

145

00:05:51.610  -->  00:05:53.890
From the application programmer's point of view,
146

146

00:05:53.890  -->  00:05:56.860
you start with just one thread, called the main thread.
147

147

00:05:56.860  -->  00:05:59.910
This thread has the ability to create additional threads
148

148

00:05:59.910  -->  00:06:01.553
through programmatic constructs.
149

149

00:06:02.940  -->  00:06:05.400
Distributed computing is supported by Java.
150

150

00:06:05.400  -->  00:06:08.030
In addition to the Java virtual machine being portable
151

151

00:06:08.030  -->  00:06:11.160
to many hardware platforms across a distributed environment,
152

152

00:06:11.160  -->  00:06:13.950
Java has many features which support communication
153

153

00:06:13.950  -->  00:06:15.890
across distributed systems.
154

154

00:06:15.890  -->  00:06:19.810
Java contains extensive TCP/IP networking facilities,
155

155

00:06:19.810  -->  00:06:21.950
library routines support protocols
156

156

00:06:21.950  -->  00:06:25.120
such as HyperText Transfer Protocol, HTTP,
157

157

00:06:25.120  -->  00:06:27.483
and File Transfer Protocol, FTP.
158

158

00:06:29.120  -->  00:06:31.480
Memory management is handled by the Java environment,
159

159

00:06:31.480  -->  00:06:32.830
and not the developer.
160

160

00:06:32.830  -->  00:06:35.110
Java was written to take the work of memory management
161

161

00:06:35.110  -->  00:06:37.610
out of the hands of the developer who no longer
162

162

00:06:37.610  -->  00:06:39.115
has to write destructors to destroy
163

163

00:06:39.115  -->  00:06:41.360
and deallocate objects.
164

164

00:06:41.360  -->  00:06:45.220
Instead, Java provides a garbage collection mechanism.
165

165

00:06:45.220  -->  00:06:47.110
The Oracle documentation describes
166

166

00:06:47.110  -->  00:06:49.610
automatic garbage collection as the process
167

167

00:06:49.610  -->  00:06:51.240
of looking at heap memory,
168

168

00:06:51.240  -->  00:06:54.290
identifying which objects are in use and which are not,
169

169

00:06:54.290  -->  00:06:56.540
and deleting the unused objects
170

170

00:06:56.540  -->  00:06:58.760
which effectively means that the underlying memory
171

171

00:06:58.760  -->  00:07:02.433
is reclaimed and reused for future object allocation.
172

172

00:07:03.960  -->  00:07:06.710
An in use object, or a referenced object,
173

173

00:07:06.710  -->  00:07:08.410
means that some part of your programme still
174

174

00:07:08.410  -->  00:07:11.560
maintains a pointer or reference to that object.
175

175

00:07:11.560  -->  00:07:13.470
You will need to know when an object is considered
176

176

00:07:13.470  -->  00:07:15.650
no longer referenced for the exam.
177

177

00:07:15.650  -->  00:07:17.070
In the Java platform,
178

178

00:07:17.070  -->  00:07:18.500
there are currently four supported
179

179

00:07:18.500  -->  00:07:20.300
garbage collection alternatives
180

180

00:07:20.300  -->  00:07:23.000
and all but one of them, the serial collector,
181

181

00:07:23.000  -->  00:07:24.410
execute the work in parallel
182

182

00:07:24.410  -->  00:07:25.570
to improve performance.
183

183

00:07:25.570  -->  00:07:27.760
And I'm going to be discussing garbage collection
184

184

00:07:27.760  -->  00:07:28.773
in a later video.
185

185

00:07:30.200  -->  00:07:33.270
For 24-7 applications, or applications which
186

186

00:07:33.270  -->  00:07:35.400
manipulate large data sets,
187

187

00:07:35.400  -->  00:07:38.180
Java's garbage collection could have a detrimental effect
188

188

00:07:38.180  -->  00:07:39.910
on an application's performance
189

189

00:07:39.910  -->  00:07:41.520
since garbage collection could tie up
190

190

00:07:41.520  -->  00:07:44.320
much needed resources while it's executing.
191

191

00:07:44.320  -->  00:07:46.820
In these environments, you may need to get more familiar
192

192

00:07:46.820  -->  00:07:49.260
with the different types of garbage collectors available
193

193

00:07:49.260  -->  00:07:51.210
in the Java virtual machine to tune
194

194

00:07:51.210  -->  00:07:52.820
the right collector for your type
195

195

00:07:52.820  -->  00:07:54.653
of application environment.
196

196

00:07:56.300  -->  00:07:57.530
Finally, I just want to discuss some
197

197

00:07:57.530  -->  00:08:00.260
brief points about the Java environment.
198

198

00:08:00.260  -->  00:08:01.940
The Java Development Kit, JDK,
199

199

00:08:01.940  -->  00:08:03.440
includes the development tools,
200

200

00:08:03.440  -->  00:08:05.350
the compiler, the debugger,
201

201

00:08:05.350  -->  00:08:08.120
class inspector, and documentation generator,
202

202

00:08:08.120  -->  00:08:10.140
as well as the Java runtime environment
203

203

00:08:10.140  -->  00:08:12.200
to run applications.
204

204

00:08:12.200  -->  00:08:14.710
The Java Runtime Environment, JRE,
205

205

00:08:14.710  -->  00:08:16.530
includes only the class libraries and executables
206

206

00:08:16.530  -->  00:08:19.780
required to run a Java programme.
207

207

00:08:19.780  -->  00:08:22.983
A Java application does not need the JDK to run.
208

208

00:08:24.700  -->  00:08:27.430
Java is write once run anywhere, that's WORA,
209

209

00:08:27.430  -->  00:08:29.320
which means it's platform independent
210

210

00:08:29.320  -->  00:08:32.040
and portable Java source code is compiled into
211

211

00:08:32.040  -->  00:08:33.940
Java bytecode class files
212

212

00:08:33.940  -->  00:08:36.860
which are then interpreted by the Java Virtual Machine,
213

213

00:08:36.860  -->  00:08:38.470
JVM, which is available for
214

214

00:08:38.470  -->  00:08:40.500
a diverse range of platforms.
215

215

00:08:40.500  -->  00:08:42.920
The JVM interacts with the operating system
216

216

00:08:42.920  -->  00:08:44.350
interpreting the class files
217

217

00:08:44.350  -->  00:08:46.840
and performing just in time compilation
218

218

00:08:46.840  -->  00:08:49.650
to specific machine code, optimising the code
219

219

00:08:49.650  -->  00:08:52.810
for the environment that the code is executing on.
220

220

00:08:52.810  -->  00:08:55.070
A Java programme never really executes natively
221

221

00:08:55.070  -->  00:08:57.490
on the host machine as such.
222

222

00:08:57.490  -->  00:08:58.620
All right, so next I'm going to present
223

223

00:08:58.620  -->  00:09:00.290
you with a couple of quiz questions
224

224

00:09:00.290  -->  00:09:01.970
that tests some of the material we've just covered
225

225

00:09:01.970  -->  00:09:03.520
in this video, and then we're going to move on
226

226

00:09:03.520  -->  00:09:05.880
to section three, working with Java primitive
227

227

00:09:05.880  -->  00:09:08.005
data types and string APIs.
228

228

00:09:08.005  -->  00:09:09.543
See you in the next video.
