WEBVTT
1
00:00:05.810 --> 00:00:12.390
So let's have a talk about packages and using them in your class files, so as per the Oracle Java documentation,

2
00:00:12.630 --> 00:00:17.820
a package is a namespace that organizes a set of related classes and interfaces.

3
00:00:18.150 --> 00:00:23.120
Conceptually, you can think of packages as being similar to different folders on your computer.

4
00:00:24.550 --> 00:00:29.340
But swinging back to intelligence, we need to create a new project they've already created.

5
00:00:29.370 --> 00:00:31.280
As you can see, the cold are getting started.

6
00:00:31.580 --> 00:00:34.040
So how do we go about creating a package in intelligence?

7
00:00:34.490 --> 00:00:36.170
Well, first, we can try going to.

8
00:00:36.170 --> 00:00:36.440
Right.

9
00:00:36.440 --> 00:00:40.720
Clicking a source for a new package that will enable us to create a package.

10
00:00:40.970 --> 00:00:45.920
Well, tentatively, what you can do is create a new class and prefix the name with a qualified package

11
00:00:45.920 --> 00:00:46.160
name.

12
00:00:46.670 --> 00:00:52.640
Let's actually do that instead of go back and do a new Java class that we'll call this one garden.

13
00:00:54.800 --> 00:00:57.650
Top vegetable, wine, vegetable.

14
00:00:59.840 --> 00:01:00.530
So what happened?

15
00:01:00.830 --> 00:01:05.630
Well, intelligence created a source file in the directory structure that matches the names past which

16
00:01:05.630 --> 00:01:07.160
were delimited, as you saw, we type them.

17
00:01:07.460 --> 00:01:12.290
So we've got a package now which you could take out Kadenbach Vegetable and the class name Vyn a vegetable.

18
00:01:12.920 --> 00:01:17.390
In addition to that, if you look at the source code, you can see that it's got an additional line

19
00:01:17.390 --> 00:01:22.550
of code, which is the package stateman source code can have zero or one package statements and the

20
00:01:22.550 --> 00:01:25.940
statement must be the first line of code in the source file, excluding comments.

21
00:01:26.300 --> 00:01:27.500
You can say that is the case here.

22
00:01:27.770 --> 00:01:33.650
The classifier can only be associated with a single package, but a package can have multiple classes

23
00:01:33.650 --> 00:01:34.490
and interfaces in it.

24
00:01:35.090 --> 00:01:36.710
Let's go ahead and change the source code.

25
00:01:36.710 --> 00:01:42.320
Now, you can follow along in this course by copying and pasting in the code snippets which are always

26
00:01:42.320 --> 00:01:44.420
available in the resources section for each video.

27
00:01:44.780 --> 00:01:49.610
So I'm going to copy and paste the first snippet posted in there and I'm just going to double click

28
00:01:49.610 --> 00:01:54.620
to get a full screen, very basic code, as you can see there, if we execute this code.

29
00:01:56.350 --> 00:01:58.560
It shouldn't really be any real surprises, they we get the airport.

30
00:01:58.570 --> 00:02:00.550
I'm a vegetable that grows on a vine.

31
00:02:01.520 --> 00:02:06.940
So let's open a terminal session at the project route and look at this from the command line open project.

32
00:02:07.620 --> 00:02:07.810
Right.

33
00:02:07.810 --> 00:02:10.080
Click on the project and select open in terminal.

34
00:02:10.690 --> 00:02:13.030
That puts us in the route to order this project.

35
00:02:13.720 --> 00:02:18.430
Diyab Because I'm on Windows and you could say that we've got it out for order, which is where the

36
00:02:18.620 --> 00:02:24.500
classifiers are created by the Fulcrum intelligence and our source fora where our Java source code resides.

37
00:02:24.880 --> 00:02:29.320
So that's from this class file manually looking at the output for there their got out.

38
00:02:29.680 --> 00:02:33.310
You can see it's follow the path there and vind vegetable class.

39
00:02:33.760 --> 00:02:36.910
So we need to do something similar from the command line to Java.

40
00:02:38.020 --> 00:02:45.100
Daschle p class path and will specify the path path I set out there, paying the outfought to slash

41
00:02:45.520 --> 00:02:51.070
forward slash work, I can wendi's production getting started.

42
00:02:53.720 --> 00:02:56.590
And you can see a mirroring the output foda directory there.

43
00:02:57.420 --> 00:03:03.210
Then we need to do a spice and then we need to specify our full Java path, which is garden, top vegetable,

44
00:03:04.680 --> 00:03:07.410
dot, vine, vegetable being the name of the class.

45
00:03:09.520 --> 00:03:14.530
OK, executing this command gave us the same results as running it through an idea, you could say that

46
00:03:14.530 --> 00:03:19.510
we specified the full name, including packages of the class we wanted to execute.

47
00:03:19.960 --> 00:03:22.420
This name, by the way, is the fully qualified class name.

48
00:03:22.780 --> 00:03:25.780
If QCA or let's try something else.

49
00:03:26.020 --> 00:03:29.920
Let's compile this class and put the class files in a different output folder.

50
00:03:30.640 --> 00:03:34.600
Obviously have got an output for what they can see in the project that intelligent uses.

51
00:03:34.960 --> 00:03:36.040
Let's create a different one.

52
00:03:36.430 --> 00:03:39.910
We're going to put out in a build folder relative to our current path.

53
00:03:40.090 --> 00:03:46.840
And to do this, we call Java Sea in Java Compiler and we pass it test day option, which specifies

54
00:03:46.840 --> 00:03:50.320
where we want the classifiers to be generated over the Java Sea.

55
00:03:50.890 --> 00:03:55.030
Dashty build being the name of the airport for a relative path.

56
00:03:55.450 --> 00:03:57.670
Then we need to specify where our source code is.

57
00:03:57.670 --> 00:04:06.400
But in source slash carbon slash vegetable slash vyn vegetable dot java.

58
00:04:08.490 --> 00:04:12.750
You see, there's a bit of a pause there for a moment now, we can't see it updated in the project,

59
00:04:12.750 --> 00:04:13.860
kind of a kick back in there.

60
00:04:16.170 --> 00:04:21.120
You can see the build directory, and if you have a look at that now, we've got Kardon, Vegetable

61
00:04:21.120 --> 00:04:23.570
and vegetable class showing in there.

62
00:04:24.180 --> 00:04:28.950
It's basically put the vegetable class fall in the correct package location.

63
00:04:32.290 --> 00:04:39.400
So what would happen if we compiled without the Dashty option, let's try doing that Java Sea space,

64
00:04:39.520 --> 00:04:41.100
can we just want to point to the source code?

65
00:04:41.310 --> 00:04:45.600
This case is SAAC slash carbon slash vegetable.

66
00:04:47.150 --> 00:04:50.600
Slash fine vegetable Chava.

67
00:04:52.860 --> 00:04:58.380
If a poor you can see that the command worked and if we can have a look in our source folder, click

68
00:04:58.490 --> 00:04:59.050
in there again.

69
00:04:59.480 --> 00:05:05.000
Notice that the volume vegetable file appeared because intelligent refresh the directory contents so

70
00:05:05.000 --> 00:05:09.830
you can see that by default, without using Dashty the point vegetable, that classifier was created

71
00:05:09.830 --> 00:05:16.280
in the same location as our own vegetable java file resided in the latest because we don't need it.

72
00:05:19.220 --> 00:05:23.690
We'll also take this opportunity to delete the build folder, which we also aren't going to be using

73
00:05:23.690 --> 00:05:24.290
moving forward.

74
00:05:28.080 --> 00:05:34.470
All right, so now we've created a class in a package we next need to learn how to use it, so st2 to

75
00:05:34.470 --> 00:05:35.940
execute it from the command line.

76
00:05:36.250 --> 00:05:41.080
We provided a fully qualified class name, which includes package and the class name.

77
00:05:41.610 --> 00:05:46.230
This is one option we can use to reference another class in another package, or we can use an import

78
00:05:46.230 --> 00:05:47.250
statement in our code.

79
00:05:49.400 --> 00:05:52.300
So here's a few of the different methods referencing a top from another package.

80
00:05:52.820 --> 00:05:59.270
So the first method is a fully qualified class, that EPCM example code for that javadoc you to list

81
00:05:59.270 --> 00:06:01.790
equals new Javadoc utility list.

82
00:06:02.250 --> 00:06:07.460
If you're only referencing a class once in source or you're referencing two classes with the same name,

83
00:06:07.460 --> 00:06:11.990
but from different packages, you will still need to use the FCC and the fully qualified class name.

84
00:06:12.410 --> 00:06:13.490
It can be very verbose.

85
00:06:13.490 --> 00:06:19.190
As you can see next, we've got an option to use a single type import declaration example or import

86
00:06:19.190 --> 00:06:24.860
javadoc you to list and then the actual card usage array list, I think with neorealist.

87
00:06:25.260 --> 00:06:29.900
So this is actually the most common way for both readability of code and information for future developers.

88
00:06:30.200 --> 00:06:31.820
And it's obviously less for verbose as well.

89
00:06:34.350 --> 00:06:40.160
The next method is a top import on demand declaration import javadoc you to not start as an example,

90
00:06:40.470 --> 00:06:44.100
then we can still reference it in the same way our A-list A-list equals neorealist.

91
00:06:44.840 --> 00:06:49.320
This is generally discouraged, but still needed to be recognized as valid for the exam.

92
00:06:49.920 --> 00:06:54.720
If you use this for all your import statements, anyone reading the card after you may not know where

93
00:06:54.720 --> 00:06:58.320
the class referenced actually resides and of course always will fix it.

94
00:06:58.320 --> 00:07:03.660
Pretty quick order code, though, written before ideas or very old versions of ideas are more likely

95
00:07:03.660 --> 00:07:05.250
to use this type of import statement.

96
00:07:07.830 --> 00:07:13.190
Next, we've got a single static import declaration, the example that import static javadoc langue

97
00:07:13.200 --> 00:07:14.000
messed up part.

98
00:07:14.640 --> 00:07:20.010
Now, this is a way to pull in a single static member of a class in and reference the member's name

99
00:07:20.010 --> 00:07:22.890
without including a reference to the declared type.

100
00:07:23.610 --> 00:07:28.250
And finally, we've got a static import on demand declaration import static javadoc.

101
00:07:28.260 --> 00:07:33.030
Languedoc Method Star is an example and that's way to pull in all static members.

102
00:07:33.030 --> 00:07:38.460
That's variables and methods of a class and reference them without referencing the declared type.

103
00:07:39.300 --> 00:07:44.550
So let's finish the video here and we'll continue on with packages and using imports in the next video.
