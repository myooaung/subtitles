WEBVTT
1
1

00:00:05.320  -->  00:00:06.230
<v Instructor>All right, so in this video we're gonna</v>
2

2

00:00:06.230  -->  00:00:09.520
review some of the unary operators in code.
3

3

00:00:09.520  -->  00:00:12.190
So firstly, we'll explore the prefix decrement,
4

4

00:00:12.190  -->  00:00:15.880
prefix increment and postfix decrement as well as
5

5

00:00:15.880  -->  00:00:19.430
the postfix increment operators.
6

6

00:00:19.430  -->  00:00:20.670
Now, it's very important to remember
7

7

00:00:20.670  -->  00:00:23.390
that the postfix decrement and postfix increment
8

8

00:00:23.390  -->  00:00:27.670
operators do not change the value of its unary operand,
9

9

00:00:27.670  -->  00:00:29.690
until the expression it is operating
10

10

00:00:29.690  -->  00:00:32.370
in is considered completed or,
11

11

00:00:32.370  -->  00:00:34.550
and this or is kind of important,
12

12

00:00:34.550  -->  00:00:37.990
or the operand is used again in the same statement.
13

13

00:00:37.990  -->  00:00:40.520
This will be tested on the Certification Exam,
14

14

00:00:40.520  -->  00:00:43.040
much likely in very complex ways.
15

15

00:00:43.040  -->  00:00:46.140
So remember that the unary variable being operated
16

16

00:00:46.140  -->  00:00:49.750
on does get operated on, the value at the end is
17

17

00:00:49.750  -->  00:00:52.540
either incremented or decremented, but any assignments,
18

18

00:00:52.540  -->  00:00:54.960
or expressions this statement is part of
19

19

00:00:54.960  -->  00:00:57.330
will be using the unchanged value
20

20

00:00:57.330  -->  00:01:01.383
until the expression statement is evaluated successfully.
21

21

00:01:02.570  -->  00:01:04.980
If the statement is interrupted somehow,
22

22

00:01:04.980  -->  00:01:07.640
then the postfix increment or decrement
23

23

00:01:07.640  -->  00:01:09.470
may not actually be applied.
24

24

00:01:09.470  -->  00:01:11.430
It needs to be noted that the increment
25

25

00:01:11.430  -->  00:01:13.920
and decrement operators are changing the value
26

26

00:01:13.920  -->  00:01:16.650
contained in the reference itself.
27

27

00:01:16.650  -->  00:01:19.430
If you make the statement a++, for example,
28

28

00:01:19.430  -->  00:01:22.350
you are incrementing the value in the variable a.
29

29

00:01:22.350  -->  00:01:25.230
These operators can be stand alone statements.
30

30

00:01:25.230  -->  00:01:28.720
This is different, for example, from the unary minus a,
31

31

00:01:28.720  -->  00:01:31.740
which has no impact on the value of the operand itself,
32

32

00:01:31.740  -->  00:01:34.070
and cannot be a statement on its own.
33

33

00:01:34.070  -->  00:01:37.193
It's output must be assigned or used in an expression.
34

34

00:01:38.320  -->  00:01:39.360
All right, so enough talk about that,
35

35

00:01:39.360  -->  00:01:40.770
let's create a new project.
36

36

00:01:40.770  -->  00:01:42.190
You can see that I've actually done that here.
37

37

00:01:42.190  -->  00:01:43.630
I've called that operators.
38

38

00:01:43.630  -->  00:01:46.290
We're going to create a new class called unary operator
39

39

00:01:46.290  -->  00:01:49.280
and explore some of this prefix and postfix increment
40

40

00:01:49.280  -->  00:01:50.930
and decrement operators.
41

41

00:01:50.930  -->  00:01:53.663
So, I'm gonna go ahead and do that and create that class.
42

42

00:02:03.310  -->  00:02:06.187
You can see some examples that I've got there.
43

43

00:02:06.187  -->  00:02:07.770
And in the comments, I've indicated
44

44

00:02:07.770  -->  00:02:09.200
what should be happening.
45

45

00:02:09.200  -->  00:02:11.710
But note the comment I want to talk about on line 12,
46

46

00:02:11.710  -->  00:02:13.890
if you do no assignment and the operator
47

47

00:02:13.890  -->  00:02:16.270
is not participating in a more complex
48

48

00:02:16.270  -->  00:02:19.210
expression the following statements are the same.
49

49

00:02:19.210  -->  00:02:21.100
The value in variable a gets incremented by one.
50

50

00:02:21.100  -->  00:02:22.700
So let's actually run this code.
51

51

00:02:27.000  -->  00:02:28.430
Right, so that's the output.
52

52

00:02:28.430  -->  00:02:30.160
So what's the difference here?
53

53

00:02:30.160  -->  00:02:32.880
Well, let's modify the code and move the increment
54

54

00:02:32.880  -->  00:02:36.190
and decrement operators into the system.out.println
55

55

00:02:36.190  -->  00:02:38.530
code itself, rather than having them separate.
56

56

00:02:38.530  -->  00:02:41.780
And I've copied some code and pasted after initial code.
57

57

00:02:41.780  -->  00:02:42.613
Let's do that.
58

58

00:02:45.167  -->  00:02:46.067
So let's run this.
59

59

00:02:50.270  -->  00:02:53.690
So the prefix increment resulted in the same behaviour,
60

60

00:02:53.690  -->  00:02:56.110
however, the postfix increment did not actually get
61

61

00:02:56.110  -->  00:02:58.320
incremented until after the statement,
62

62

00:02:58.320  -->  00:03:01.720
in this case, the system.out.println was executed,
63

63

00:03:01.720  -->  00:03:03.220
which of course is the definition
64

64

00:03:03.220  -->  00:03:05.636
of the postfix increment, all right.
65

65

00:03:05.636  -->  00:03:08.200
So let's try some less obvious examples here.
66

66

00:03:08.200  -->  00:03:11.980
Gonna paste in the following code, okay.
67

67

00:03:11.980  -->  00:03:12.893
We'll run this.
68

68

00:03:16.610  -->  00:03:20.170
So note here that a2 was assigned the value of a
69

69

00:03:20.170  -->  00:03:22.110
before it was incremented.
70

70

00:03:22.110  -->  00:03:24.090
You'll also note that the if statement block
71

71

00:03:24.090  -->  00:03:25.430
was never executed.
72

72

00:03:25.430  -->  00:03:28.840
The prefix increment operator incremented a to two
73

73

00:03:28.840  -->  00:03:32.570
prior to the expression being evaluated.
74

74

00:03:32.570  -->  00:03:34.990
All right, so finally now let's look at some loops
75

75

00:03:34.990  -->  00:03:37.010
where these operators used, quite often,
76

76

00:03:37.010  -->  00:03:39.200
and the Certification Exam will test you,
77

77

00:03:39.200  -->  00:03:41.650
more than likely, in unexpected ways.
78

78

00:03:41.650  -->  00:03:43.450
I've got some more code to paste in.
79

79

00:03:45.500  -->  00:03:47.270
All right, so we'll just have a look at the code
80

80

00:03:47.270  -->  00:03:50.223
that I've just pasted in there and begins on line 44.
81

81

00:03:51.160  -->  00:03:52.220
Not a lot to say about that,
82

82

00:03:52.220  -->  00:03:53.720
so I'll actually run the code.
83

83

00:03:56.950  -->  00:03:59.503
Here you can see that the decision of which increment
84

84

00:03:59.503  -->  00:04:01.500
and decrement operator you use can
85

85

00:04:01.500  -->  00:04:03.910
have significantly different results.
86

86

00:04:03.910  -->  00:04:06.160
And we can see that in terms of the loopiterations
87

87

00:04:06.160  -->  00:04:08.100
and the value of b.
88

88

00:04:08.100  -->  00:04:09.240
All right, before we end the video,
89

89

00:04:09.240  -->  00:04:11.643
we're gonna review some other unary operators.
90

90

00:04:12.540  -->  00:04:15.720
So the unary minus returns a negative value
91

91

00:04:15.720  -->  00:04:17.770
if the value in the operand is positive,
92

92

00:04:17.770  -->  00:04:19.720
and a positive value if the value
93

93

00:04:19.720  -->  00:04:21.400
in the operand is negative.
94

94

00:04:21.400  -->  00:04:23.860
The unary plus returns a value with the same sign
95

95

00:04:23.860  -->  00:04:26.760
as the operand, and has no effect on the value.
96

96

00:04:26.760  -->  00:04:28.280
Both operators, will however,
97

97

00:04:28.280  -->  00:04:30.857
promote the return values to an int.
98

98

00:04:31.782  -->  00:04:33.460
Right, so let's create another class here.
99

99

00:04:33.460  -->  00:04:36.033
We'll call this one unary operator more.
100

100

00:04:47.220  -->  00:04:49.130
There's the code for it, as you can see.
101

101

00:04:49.130  -->  00:04:50.707
So we're demonstrating both the unary minus
102

102

00:04:50.707  -->  00:04:53.657
and the unary plus operands, which we've just talked about.
103

103

00:04:56.080  -->  00:04:58.600
So the output's demonstrating that unlike the increment
104

104

00:04:58.600  -->  00:05:01.620
and decrement operators the value of the operand reference
105

105

00:05:01.620  -->  00:05:03.770
itself stays unchanged.
106

106

00:05:03.770  -->  00:05:06.490
The expression's value must be returned to a variable
107

107

00:05:06.490  -->  00:05:08.060
or used in an expression.
108

108

00:05:08.060  -->  00:05:10.670
These unary operators cannot be stand alone statements,
109

109

00:05:10.670  -->  00:05:12.300
for that reason.
110

110

00:05:12.300  -->  00:05:14.620
All right, so just before we finish this video,
111

111

00:05:14.620  -->  00:05:17.810
let's now look at the complement operators.
112

112

00:05:17.810  -->  00:05:21.050
So the bitwise complement operator flips the bit
113

113

00:05:21.050  -->  00:05:23.700
for the entire value of the variable.
114

114

00:05:23.700  -->  00:05:26.270
So the binary literal value of the integer zero,
115

115

00:05:26.270  -->  00:05:28.260
gets every bit flipped to one,
116

116

00:05:28.260  -->  00:05:31.020
making it's integer value minus one.
117

117

00:05:31.020  -->  00:05:34.650
The logical complement operator only works on a Boolean,
118

118

00:05:34.650  -->  00:05:38.240
and changes false to not false, true in other words.
119

119

00:05:38.240  -->  00:05:41.970
So let's add some code to this same class file.
120

120

00:05:41.970  -->  00:05:43.660
So we can take a look at an example
121

121

00:05:43.660  -->  00:05:45.123
of h complement operator.
122

122

00:05:46.740  -->  00:05:48.883
Okay, so there's the code.
123

123

00:05:49.960  -->  00:05:51.003
So if we run this,
124

124

00:05:54.500  -->  00:05:56.580
you can see we get the confirmation
125

125

00:05:56.580  -->  00:05:59.340
that it's actually working as specified.
126

126

00:05:59.340  -->  00:06:00.753
Now, it's interesting to note
127

127

00:06:00.753  -->  00:06:03.200
that the Integer.toBinaryString,
128

128

00:06:03.200  -->  00:06:06.290
which we're calling on lines 34 and lines 36,
129

129

00:06:06.290  -->  00:06:08.580
only prints out 32-bits if the value
130

130

00:06:08.580  -->  00:06:11.600
of the int variable is negative.
131

131

00:06:11.600  -->  00:06:13.230
All right, so let's end the video here.
132

132

00:06:13.230  -->  00:06:14.640
In the next video, we'll start talking
133

133

00:06:14.640  -->  00:06:17.560
about all the other operators we haven't yet discussed.
134

134

00:06:17.560  -->  00:06:18.963
See you in the next video.
