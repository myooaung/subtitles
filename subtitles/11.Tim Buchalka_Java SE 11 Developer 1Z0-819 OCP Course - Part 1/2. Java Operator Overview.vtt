WEBVTT
1
1

00:00:04.931  -->  00:00:07.720
<v ->All right, so let's talk about Java operators.</v>
2

2

00:00:07.720  -->  00:00:10.010
Java operators are symbols that are used
3

3

00:00:10.010  -->  00:00:13.070
to perform mathematical or logical manipulations
4

4

00:00:13.070  -->  00:00:15.610
and have two types of classifications.
5

5

00:00:15.610  -->  00:00:18.600
The first classification is based on the number of operands
6

6

00:00:18.600  -->  00:00:21.680
the operator has, unary, binary, ternary.
7

7

00:00:21.680  -->  00:00:24.000
And the second classification is the type
8

8

00:00:24.000  -->  00:00:25.853
of operation it performs.
9

9

00:00:27.260  -->  00:00:30.000
When talking about operators, it's important to know,
10

10

00:00:30.000  -->  00:00:32.530
firstly the precedence of an operator.
11

11

00:00:32.530  -->  00:00:35.800
Unary operators are evaluated before binary operators.
12

12

00:00:35.800  -->  00:00:38.820
Among the unary operators, the postfix increment
13

13

00:00:38.820  -->  00:00:41.880
and decrement operators have the highest precedence.
14

14

00:00:41.880  -->  00:00:43.730
Unary operators with the exception
15

15

00:00:43.730  -->  00:00:47.520
of the pre and postfix operators promote the variable
16

16

00:00:47.520  -->  00:00:50.670
to and int if it's smaller than an int.
17

17

00:00:50.670  -->  00:00:52.630
If all operators have the same precedence,
18

18

00:00:52.630  -->  00:00:56.040
the expression with be evaluated from left to right
19

19

00:00:56.040  -->  00:00:58.280
with the exception of the simple and compound
20

20

00:00:58.280  -->  00:01:01.853
assignment operators which are evaluated right to left.
21

21

00:01:02.750  -->  00:01:05.653
And finally, parentheses always take precedence.
22

22

00:01:07.310  -->  00:01:09.010
All right so, unary operators,
23

23

00:01:09.010  -->  00:01:12.440
expressions with unary operators group right to left
24

24

00:01:12.440  -->  00:01:15.630
so that minus Bitwise complement operator x
25

25

00:01:15.630  -->  00:01:17.860
means the same as minus parentheses
26

26

00:01:17.860  -->  00:01:21.370
Bitwise complement operator x.
27

27

00:01:21.370  -->  00:01:23.440
So, looking at this table we've got minus minus,
28

28

00:01:23.440  -->  00:01:26.450
which is the prefix decrement and the postfix decrement,
29

29

00:01:26.450  -->  00:01:28.020
depending on how it's used.
30

30

00:01:28.020  -->  00:01:30.427
In the example, when the prefix is --a,
31

31

00:01:30.427  -->  00:01:33.560
that decrements the value of a before the expression
32

32

00:01:33.560  -->  00:01:37.011
is evaluated and a-- decrements the value of a
33

33

00:01:37.011  -->  00:01:39.670
after the expression is evaluated.
34

34

00:01:39.670  -->  00:01:41.850
Just as a note there, it's possible that a variable
35

35

00:01:41.850  -->  00:01:45.410
will go out scope before the post decrement can occur.
36

36

00:01:45.410  -->  00:01:47.567
Moving on, we've got the plus plus increment.
37

37

00:01:47.567  -->  00:01:50.370
So, we've got a prefix and a postfix increment here.
38

38

00:01:50.370  -->  00:01:53.610
And the example is very similar to the decrement operator.
39

39

00:01:53.610  -->  00:01:55.810
++a increments the value of a
40

40

00:01:55.810  -->  00:01:57.910
before the expression is evaluated,
41

41

00:01:57.910  -->  00:02:00.200
and a++ increments the value of a
42

42

00:02:00.200  -->  00:02:02.360
after the expression is evaluated.
43

43

00:02:02.360  -->  00:02:04.320
Same deal with that in terms of scope.
44

44

00:02:04.320  -->  00:02:07.100
It's possible that a variable will go out of scope
45

45

00:02:07.100  -->  00:02:09.730
before the post decrement can occur.
46

46

00:02:09.730  -->  00:02:10.930
Moving down, we've got minus,
47

47

00:02:10.930  -->  00:02:15.120
which is the unary minus operator, -a is the example,
48

48

00:02:15.120  -->  00:02:18.350
and it returns the negated value of a without actually
49

49

00:02:18.350  -->  00:02:20.220
changing the value of a.
50

50

00:02:20.220  -->  00:02:23.350
So, if a is a data type with a size less than an int,
51

51

00:02:23.350  -->  00:02:26.630
note that a will get promoted to an int.
52

52

00:02:26.630  -->  00:02:29.260
Or in other words, what is returned will be promoted.
53

53

00:02:29.260  -->  00:02:30.623
All right, we've got the unary plus,
54

54

00:02:30.623  -->  00:02:32.420
+a is the example.
55

55

00:02:32.420  -->  00:02:35.510
It's allowable, but does nothing to the value of a.
56

56

00:02:35.510  -->  00:02:37.920
If a is a data type with a size less than an int,
57

57

00:02:37.920  -->  00:02:40.600
then note again that a will be promoted to an int.
58

58

00:02:40.600  -->  00:02:42.620
That's not something you would normally use very often.
59

59

00:02:42.620  -->  00:02:45.548
We've got the naught, the logical complement operator.
60

60

00:02:45.548  -->  00:02:49.240
!a returns the complement of a boolean value.
61

61

00:02:49.240  -->  00:02:52.210
We've got the Bitwise complement operator, the tilde sign,
62

62

00:02:52.210  -->  00:02:54.790
so that one is the Bitwise complement,
63

63

00:02:54.790  -->  00:02:57.520
turns a one to zero, or zero to one.
64

64

00:02:57.520  -->  00:03:00.470
In all cases, Bitwise complement operator x
65

65

00:03:00.470  -->  00:03:01.303
equals (-x)-1.
66

66

00:03:04.560  -->  00:03:06.210
And then we've got the cast operator,
67

67

00:03:06.210  -->  00:03:08.640
which is the type in parentheses ahead
68

68

00:03:08.640  -->  00:03:10.313
of the actual data type itself.
69

69

00:03:11.280  -->  00:03:12.660
Right, so let's finish the video here.
70

70

00:03:12.660  -->  00:03:13.610
We've done some theory.
71

71

00:03:13.610  -->  00:03:15.890
And we'll start actually doing some code
72

72

00:03:15.890  -->  00:03:17.653
relating to this in the next video.
