WEBVTT
1
1

00:00:05.112  -->  00:00:06.330
<v Narrator>All right, so let's review some</v>
2

2

00:00:06.330  -->  00:00:08.752
of the binary operators that we had a quick overview
3

3

00:00:08.752  -->  00:00:11.030
of in the last video.
4

4

00:00:11.030  -->  00:00:12.450
So I'm going to create a new class in this
5

5

00:00:12.450  -->  00:00:15.567
project -- with the operators project.
6

6

00:00:15.567  -->  00:00:18.153
"Binary Operator Examples" is what I'll call it.
7

7

00:00:22.000  -->  00:00:23.600
I'm going to paste some code in.
8

8

00:00:26.845  -->  00:00:27.680
All right, so what I've done first
9

9

00:00:27.680  -->  00:00:29.150
with this initial code is include
10

10

00:00:29.150  -->  00:00:31.100
all the multiplicative and editive
11

11

00:00:31.100  -->  00:00:33.090
operators in one statement using
12

12

00:00:33.090  -->  00:00:36.500
no parentheses, defaulting to Java's precedence.
13

13

00:00:36.500  -->  00:00:38.500
I've stated that multiplicative operators,
14

14

00:00:38.500  -->  00:00:40.280
which include multiplication,
15

15

00:00:40.280  -->  00:00:43.190
division and Modulus operators take precedence
16

16

00:00:43.190  -->  00:00:45.500
over additive operators, which are the plus and minus
17

17

00:00:45.500  -->  00:00:46.510
operators.
18

18

00:00:46.510  -->  00:00:51.510
So if we run this, we can see the result on the screen.
19

19

00:00:54.310  -->  00:00:56.710
So moving on, let's actually add some
20

20

00:00:56.710  -->  00:00:58.390
additional code for the Modulus,
21

21

00:00:58.390  -->  00:01:01.290
or remainder operator as it's also known as.
22

22

00:01:01.290  -->  00:01:03.210
Now, you've probably seen this operator
23

23

00:01:03.210  -->  00:01:05.220
used in example code that evaluates
24

24

00:01:05.220  -->  00:01:07.010
odd to even numbers -- I think I've
25

25

00:01:07.010  -->  00:01:08.440
even got an example of that in
26

26

00:01:08.440  -->  00:01:10.810
my Java masterclass on Udemy --
27

27

00:01:10.810  -->  00:01:12.720
but let's explore it a bit deeper.
28

28

00:01:12.720  -->  00:01:14.973
So, I'm going to paste some more code in here.
29

29

00:01:18.300  -->  00:01:19.650
So in this code I've pasted, I've
30

30

00:01:19.650  -->  00:01:21.890
included an example where the dividend
31

31

00:01:21.890  -->  00:01:23.660
is greater than the divisor.
32

32

00:01:23.660  -->  00:01:26.500
Remember that the divisor is on the right-hand
33

33

00:01:26.500  -->  00:01:28.390
side of the operator, so clearly the
34

34

00:01:28.390  -->  00:01:30.320
example there is on line 31.
35

35

00:01:30.320  -->  00:01:32.470
But I've also got an example there
36

36

00:01:32.470  -->  00:01:33.890
we're looping three examples
37

37

00:01:33.890  -->  00:01:36.350
where the dividend is less than the divisor.
38

38

00:01:36.350  -->  00:01:37.940
Now these always evaluate to the same
39

39

00:01:37.940  -->  00:01:40.563
value as the dividend, so let's actually run this.
40

40

00:01:43.543  -->  00:01:44.863
And you can see the output.
41

41

00:01:47.546  -->  00:01:49.070
Keep in mind, obviously -- I think
42

42

00:01:49.070  -->  00:01:50.900
I've said it a few times -- but this code,
43

43

00:01:50.900  -->  00:01:53.230
every single bit of code is available
44

44

00:01:53.230  -->  00:01:55.440
for you to download and paste into your IDE
45

45

00:01:55.440  -->  00:01:58.150
and test because you might find
46

46

00:01:58.150  -->  00:02:00.160
that in some situations you learn a lot faster
47

47

00:02:00.160  -->  00:02:02.510
by doing that, so grab the code if you need to.
48

48

00:02:04.128  -->  00:02:05.251
But getting back to Modulus, in C and C++,
49

49

00:02:05.251  -->  00:02:08.020
Modulus accepts only integral operands
50

50

00:02:08.020  -->  00:02:11.200
but Java accepts floating-point operands as well.
51

51

00:02:11.200  -->  00:02:12.433
So, I want to add a similar example to
52

52

00:02:12.433  -->  00:02:14.190
what I did with the integer test there,
53

53

00:02:14.190  -->  00:02:15.870
specifically with the full loop,
54

54

00:02:15.870  -->  00:02:17.730
but I want to do it for some double values,
55

55

00:02:17.730  -->  00:02:19.410
some floating-point values, to show you
56

56

00:02:19.410  -->  00:02:20.910
what happens in that scenario.
57

57

00:02:22.010  -->  00:02:23.710
So there's the code there, this time
58

58

00:02:23.710  -->  00:02:25.403
using doubles instead of ints.
59

59

00:02:26.477  -->  00:02:30.160
Now if we run this, you can see the output,
60

60

00:02:30.160  -->  00:02:32.080
it's all showing there on the screen.
61

61

00:02:32.080  -->  00:02:33.420
It really just proved, the code segment's
62

62

00:02:33.420  -->  00:02:35.000
really just proving the same point that
63

63

00:02:35.000  -->  00:02:36.910
even with floating-point numbers,
64

64

00:02:36.910  -->  00:02:38.610
that the result equals the dividend
65

65

00:02:38.610  -->  00:02:41.800
if the divisor is greater than the dividend.
66

66

00:02:41.800  -->  00:02:44.200
There is a difference in functionality
67

67

00:02:44.200  -->  00:02:45.790
between using integers and floating-point
68

68

00:02:45.790  -->  00:02:47.630
numbers with the Modulus operator,
69

69

00:02:47.630  -->  00:02:49.190
so I want to show you that as well
70

70

00:02:49.190  -->  00:02:50.490
with another code snippet.
71

71

00:02:52.210  -->  00:02:55.240
So on line 58 we're dividing by zero as an integer
72

72

00:02:55.240  -->  00:02:57.800
but on line 66 we're dividing by zero,
73

73

00:02:57.800  -->  00:02:59.763
this time using effectively a double.
74

74

00:03:00.837  -->  00:03:05.220
If we run this, as you can see in the case
75

75

00:03:05.220  -->  00:03:07.100
of integer operands there's a runtime
76

76

00:03:07.100  -->  00:03:09.070
where a runtime exception will occur,
77

77

00:03:09.070  -->  00:03:10.250
and you can see that we've got that there
78

78

00:03:10.250  -->  00:03:11.773
showing the errors on line 58.
79

79

00:03:12.640  -->  00:03:14.690
And obviously as a result, we can catch that
80

80

00:03:14.690  -->  00:03:17.050
and print that, which we're doing here.
81

81

00:03:17.050  -->  00:03:19.730
But for double values, note that no exception
82

82

00:03:19.730  -->  00:03:22.713
is drawn, but the result's an NaN.
83

83

00:03:22.713  -->  00:03:24.337
NaN, as you're probably aware, is a special
84

84

00:03:24.337  -->  00:03:26.770
"not a number" value, and the NaN value
85

85

00:03:26.770  -->  00:03:28.870
is used in Java to represent the result
86

86

00:03:28.870  -->  00:03:30.510
of certain invalid operations
87

87

00:03:30.510  -->  00:03:31.747
such as dividing by zero.
88

88

00:03:31.747  -->  00:03:33.560
But the bottom line is that we didn't
89

89

00:03:33.560  -->  00:03:36.823
get an exception when we're using a floating-point number.
90

90

00:03:38.652  -->  00:03:42.703
Next we want to have a quick look at the shift operators.
91

91

00:03:45.730  -->  00:03:46.720
So there's the code, and I'll
92

92

00:03:46.720  -->  00:03:48.427
just go back up to the top there,
93

93

00:03:48.427  -->  00:03:52.370
you can see the code's pasted from line 72 onwards.
94

94

00:03:52.370  -->  00:03:53.810
So I'm showing a few examples
95

95

00:03:53.810  -->  00:03:55.690
of the shift operator here.
96

96

00:03:55.690  -->  00:03:57.290
The first one I'm demonstrating is the
97

97

00:03:57.290  -->  00:04:00.020
left shift sign, which is the code
98

98

00:04:00.020  -->  00:04:02.560
snippet starting on line 72, and
99

99

00:04:02.560  -->  00:04:04.668
I'm demonstrating 8 bits of a 32 bit Int there.
100

100

00:04:04.668  -->  00:04:06.990
And moving down, we've got our right shift
101

101

00:04:06.990  -->  00:04:09.890
and that's starting on line 81, demonstrating
102

102

00:04:09.890  -->  00:04:12.150
8 bits of a 32 bit Int again.
103

103

00:04:12.150  -->  00:04:15.130
And next, a right shift unsigned,
104

104

00:04:15.130  -->  00:04:17.280
you can see here starting on line 89.
105

105

00:04:17.280  -->  00:04:20.170
I'm showing both right shifts and the different results.
106

106

00:04:20.170  -->  00:04:22.270
Note that the unsigned shift populates
107

107

00:04:22.270  -->  00:04:23.910
the leftmost bit, the signed bit,
108

108

00:04:23.910  -->  00:04:26.990
with 0 as the bits are shifted right.
109

109

00:04:26.990  -->  00:04:28.463
All right, so let's run this.
110

110

00:04:30.980  -->  00:04:34.610
And there's the result of our shift operator code.
111

111

00:04:34.610  -->  00:04:35.930
So next what I want to do is combine
112

112

00:04:35.930  -->  00:04:38.090
some examples of the relationship operators
113

113

00:04:38.090  -->  00:04:40.220
with the logical operators for (OR) and (AND),
114

114

00:04:40.220  -->  00:04:42.610
remembering that the bitwise operators
115

115

00:04:42.610  -->  00:04:44.020
aren't tested in the course, so we
116

116

00:04:44.020  -->  00:04:46.120
won't be going into any detail with those.
117

117

00:04:47.740  -->  00:04:49.590
So I'll paste that in.
118

118

00:04:49.590  -->  00:04:50.530
Okay, so there's the code.
119

119

00:04:50.530  -->  00:04:52.570
If we go back up to the top there,
120

120

00:04:52.570  -->  00:04:55.130
you can see the code starting there on line 103.
121

121

00:04:55.130  -->  00:04:57.900
So what I'm trying to do here is demonstrate
122

122

00:04:57.900  -->  00:05:00.530
less than and less than, equal in expressions
123

123

00:05:00.530  -->  00:05:03.220
using the postfix increment unity operator
124

124

00:05:03.220  -->  00:05:06.020
to confirm which expressions are evaluated.
125

125

00:05:06.020  -->  00:05:09.417
Moving on, we're demonstrating next the logical (OR),
126

126

00:05:10.790  -->  00:05:13.210
and that's again using postfix increment unity
127

127

00:05:13.210  -->  00:05:16.200
operator to confirm which expressions were evaluated.
128

128

00:05:16.200  -->  00:05:19.200
Demonstrating next the Conditional Logical (OR),
129

129

00:05:19.200  -->  00:05:21.250
using the postfix increment unity operator
130

130

00:05:21.250  -->  00:05:23.790
to confirm which expressions are evaluated.
131

131

00:05:23.790  -->  00:05:25.550
Now, the Conditional Logical (OR) operator
132

132

00:05:25.550  -->  00:05:27.770
is also known as the shirt-circuiting (OR)
133

133

00:05:27.770  -->  00:05:29.512
because it skips the right-hand expression
134

134

00:05:29.512  -->  00:05:31.883
if it can be evaluated to true without it.
135

135

00:05:33.480  -->  00:05:35.380
So I've actually run the code now, and
136

136

00:05:37.250  -->  00:05:38.940
you can see the output down at the bottom.
137

137

00:05:38.940  -->  00:05:41.423
So next we want to look at the Logical (AND),
138

138

00:05:41.423  -->  00:05:42.560
as well as the Conditional (AND),
139

139

00:05:42.560  -->  00:05:44.760
so I've got some more code to paste in here.
140

140

00:05:48.790  -->  00:05:50.970
So there's the code that I've pasted in there now.
141

141

00:05:50.970  -->  00:05:52.870
If we just go back up and have a look,
142

142

00:05:53.820  -->  00:05:55.620
there's the code starting on line 143.
143

143

00:05:55.620  -->  00:05:57.681
So we're doing both a Logical (AND)
144

144

00:05:57.681  -->  00:05:59.440
test there, and then we're moving on down,
145

145

00:05:59.440  -->  00:06:01.820
we've got Conditional (AND)s as well.
146

146

00:06:01.820  -->  00:06:03.230
And in terms of the actual tests here,
147

147

00:06:03.230  -->  00:06:04.450
I'm demonstrating greater than and
148

148

00:06:04.450  -->  00:06:06.730
greater than, equal in expressions using the
149

149

00:06:06.730  -->  00:06:08.390
prefix increment unity operator
150

150

00:06:08.390  -->  00:06:10.543
to confirm which expressions are evaluated.
151

151

00:06:11.520  -->  00:06:13.490
So initially at the top there, I'm
152

152

00:06:13.490  -->  00:06:14.930
demonstrating a Logical (AND) using
153

153

00:06:14.930  -->  00:06:16.950
the prefix increment unity operator,
154

154

00:06:16.950  -->  00:06:19.500
again to confirm which expressions are evaluated.
155

155

00:06:19.500  -->  00:06:20.986
And moving on down, we've got the Conditional
156

156

00:06:20.986  -->  00:06:23.420
(AND) operator there, two ampersands using
157

157

00:06:23.420  -->  00:06:25.460
prefix increment unity operator to confirm
158

158

00:06:25.460  -->  00:06:27.390
which expressions are evaluated.
159

159

00:06:27.390  -->  00:06:29.500
The Conditional Logical (AND) -- that's
160

160

00:06:29.500  -->  00:06:30.970
the two ampersands -- is also known as
161

161

00:06:30.970  -->  00:06:33.170
the short-circuiting "and" because it skips
162

162

00:06:33.170  -->  00:06:34.650
the right-hand expression if it can
163

163

00:06:34.650  -->  00:06:36.750
be evaluated to false without it.
164

164

00:06:36.750  -->  00:06:39.720
So, we're running this code and
165

165

00:06:39.720  -->  00:06:40.840
probably shouldn't really be any
166

166

00:06:40.840  -->  00:06:43.270
real surprises there for you either.
167

167

00:06:43.270  -->  00:06:44.660
So that's the end of the video here.
168

168

00:06:44.660  -->  00:06:46.180
In the next video, we'll look at
169

169

00:06:46.180  -->  00:06:48.570
the remainder of the binary operators.
170

170

00:06:48.570  -->  00:06:49.913
See you in the next video!
