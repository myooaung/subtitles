WEBVTT
1
1

00:00:03.954  -->  00:00:06.390
<v Tim>Of course, so let's now look at some</v>
2

2

00:00:06.390  -->  00:00:08.947
of the other methods available to array list.
3

3

00:00:08.947  -->  00:00:11.090
Now that this slide should look a little familiar,
4

4

00:00:11.090  -->  00:00:12.909
we saw a similar one in section five.
5

5

00:00:12.909  -->  00:00:15.301
In this slide, we've removed the a array column,
6

6

00:00:15.301  -->  00:00:17.340
we're just showing the array list methods,
7

7

00:00:17.340  -->  00:00:19.580
most of which are on the list interface.
8

8

00:00:19.580  -->  00:00:21.130
So for comparison purposes,
9

9

00:00:21.130  -->  00:00:24.420
we've got equals and is empty as array list methods.
10

10

00:00:24.420  -->  00:00:27.220
The searches contains, contains all, index of
11

11

00:00:27.220  -->  00:00:30.573
and last index of again, this is array list methods.
12

12

00:00:32.470  -->  00:00:36.950
Data manipulation, add, add all, clear, for each, get,
13

13

00:00:36.950  -->  00:00:40.576
hash code, remove, remove all, remove if, replace all,
14

14

00:00:40.576  -->  00:00:43.303
retain all, set, size and sort.
15

15

00:00:45.420  -->  00:00:48.982
And for data transformation, copy of from Java 10,
16

16

00:00:48.982  -->  00:00:53.170
iterator, list iterator, of from Java nine, split iterator
17

17

00:00:53.170  -->  00:00:55.893
from Java eight sub list into array.
18

18

00:00:58.480  -->  00:01:00.650
In section five I showed almost all the methods
19

19

00:01:00.650  -->  00:01:02.329
of the list interface, but let's review
20

20

00:01:02.329  -->  00:01:04.259
the data manipulation methods here.
21

21

00:01:04.259  -->  00:01:07.130
Because most of our previous review reference methods
22

22

00:01:07.130  -->  00:01:09.650
we could use, with a list backed by an array,
23

23

00:01:09.650  -->  00:01:12.006
and removing and adding data was not supported.
24

24

00:01:12.006  -->  00:01:15.123
But this time, we'll use an array list instance.
25

25

00:01:16.210  -->  00:01:18.450
So I'm gonna paste some code below
26

26

00:01:18.450  -->  00:01:20.690
the other code in the main method.
27

27

00:01:20.690  -->  00:01:22.430
Okay, so there's the code that I pasted in.
28

28

00:01:22.430  -->  00:01:23.970
If you scroll up and have a look,
29

29

00:01:23.970  -->  00:01:26.820
you see it standing alone 47 you wanna pasted in.
30

30

00:01:26.820  -->  00:01:29.610
The first loop there, it's data to an array list
31

31

00:01:29.610  -->  00:01:31.220
without specifying an index,
32

32

00:01:31.220  -->  00:01:34.368
so the data is appended to the end of the list.
33

33

00:01:34.368  -->  00:01:38.740
The second loop, that adds the elements at index one,
34

34

00:01:38.740  -->  00:01:42.072
so you see the elements moved as the new element is added.
35

35

00:01:42.072  -->  00:01:45.410
And in addition, I'm also demonstrating add all here
36

36

00:01:45.410  -->  00:01:47.120
with a collection of inter-values,
37

37

00:01:47.120  -->  00:01:48.340
appearing at the end of the list,
38

38

00:01:48.340  -->  00:01:51.322
and also inserting at a specific index position.
39

39

00:01:51.322  -->  00:01:53.660
And obviously, we've got some output there as well
40

40

00:01:53.660  -->  00:01:55.150
to output the results.
41

41

00:01:55.150  -->  00:01:56.283
So if I run this code.
42

42

00:01:59.700  -->  00:02:01.370
So you can see the code below,
43

43

00:02:01.370  -->  00:02:04.080
or the output rather from the code below.
44

44

00:02:04.080  -->  00:02:07.080
Never surprises but noting in some cases where the data
45

45

00:02:07.080  -->  00:02:10.260
has been inserted based on the index position.
46

46

00:02:10.260  -->  00:02:12.310
Right, so I'm going to paste in some more code.
47

47

00:02:12.310  -->  00:02:14.553
And let's then talk about what that's going to do.
48

48

00:02:16.760  -->  00:02:19.080
First example was using the remove method to remove
49

49

00:02:19.080  -->  00:02:20.756
a single element and only the first match
50

50

00:02:20.756  -->  00:02:22.693
using that tab remove method.
51

51

00:02:22.693  -->  00:02:27.156
Within demonstrating remove if to remove a matching element.
52

52

00:02:27.156  -->  00:02:30.270
Next replace all replacing values in the array
53

53

00:02:30.270  -->  00:02:32.080
using a lambda expression.
54

54

00:02:32.080  -->  00:02:34.930
Using replace all again to put it back the way they were.
55

55

00:02:36.370  -->  00:02:39.440
Using removal to remove a set of elements,
56

56

00:02:39.440  -->  00:02:42.380
like that the list you pass remove all may contain elements
57

57

00:02:42.380  -->  00:02:43.760
that are not in this trigger,
58

58

00:02:43.760  -->  00:02:46.340
right it will remove matched elements.
59

59

00:02:46.340  -->  00:02:48.530
And down the bottom line of 104 using
60

60

00:02:48.530  -->  00:02:50.967
retain all to keep only a defined set of elements
61

61

00:02:50.967  -->  00:02:51.800
using that method.
62

62

00:02:51.800  -->  00:02:54.550
Then once we're printing out some objects down the bottom
63

63

00:02:54.550  -->  00:02:57.340
using for each with a lambda expression.
64

64

00:02:57.340  -->  00:02:58.253
So let's run this.
65

65

00:03:00.972  -->  00:03:03.100
And you could see the appropriate output
66

66

00:03:03.100  -->  00:03:04.723
at the bottom of the screen there.
67

67

00:03:07.130  -->  00:03:09.160
Alright, so I want to review again two methods
68

68

00:03:09.160  -->  00:03:11.922
that were added to the list interface since Java nine.
69

69

00:03:11.922  -->  00:03:15.370
List dot of, which was introduced in Java nine
70

70

00:03:15.370  -->  00:03:18.610
and list dot copy of which was introduced in Java 10.
71

71

00:03:18.610  -->  00:03:21.010
So both of these are static factory methods,
72

72

00:03:21.010  -->  00:03:23.320
creating unmodifiable lists.
73

73

00:03:23.320  -->  00:03:26.240
The object return is an instantiation of a member type
74

74

00:03:26.240  -->  00:03:28.940
defined in the immutable collections class.
75

75

00:03:28.940  -->  00:03:32.235
And static final class list in a domino operator a extends
76

76

00:03:32.235  -->  00:03:34.350
abstract immutable domino
77

77

00:03:34.350  -->  00:03:36.527
operator E implements serializable.
78

78

00:03:38.080  -->  00:03:40.980
That's the definition of some features of these list objects
79

79

00:03:40.980  -->  00:03:43.000
are firstly that are not modifiable.
80

80

00:03:43.000  -->  00:03:45.789
Elements cannot be added, removed or replaced.
81

81

00:03:45.789  -->  00:03:48.290
If the elements themselves are mutable,
82

82

00:03:48.290  -->  00:03:51.620
this may cause the list's contents to appear to change.
83

83

00:03:51.620  -->  00:03:55.010
They also disallow null elements, attempts to create them
84

84

00:03:55.010  -->  00:03:57.577
with null elements result in a null pointer exception.
85

85

00:03:57.577  -->  00:04:00.570
Thirdly, the order of elements in the list is the same
86

86

00:04:00.570  -->  00:04:02.477
as the order of the provided arguments
87

87

00:04:02.477  -->  00:04:05.157
or of the elements in the provided array.
88

88

00:04:05.157  -->  00:04:07.870
So we did review code with this in section five.
89

89

00:04:07.870  -->  00:04:10.646
But let's just review it one more time.
90

90

00:04:10.646  -->  00:04:13.300
What we're going to do is create a new class
91

91

00:04:13.300  -->  00:04:14.590
and paste some code in.
92

92

00:04:14.590  -->  00:04:17.263
We're going to call this one factory examples.
93

93

00:04:24.383  -->  00:04:26.880
So you can see what I'm doing that we're creating
94

94

00:04:26.880  -->  00:04:29.510
an array list, original list.
95

95

00:04:29.510  -->  00:04:32.010
We're adding elements to that list that we're using
96

96

00:04:32.010  -->  00:04:35.340
list dot copy of, and I'm printing out the results.
97

97

00:04:35.340  -->  00:04:36.253
So let's run this.
98

98

00:04:39.388  -->  00:04:41.210
And there is the result, so the code simply created
99

99

00:04:41.210  -->  00:04:43.610
an array list, populated it with some test data,
100

100

00:04:43.610  -->  00:04:47.700
then used list dot copy of both lists were then printed out.
101

101

00:04:47.700  -->  00:04:50.300
Right, so let's now test the veracity of the statements
102

102

00:04:50.300  -->  00:04:52.160
that knows and not allowed.
103

103

00:04:52.160  -->  00:04:53.530
So let's actually get into the bottom
104

104

00:04:53.530  -->  00:04:56.473
of the main method on paste and coding.
105

105

00:04:56.473  -->  00:04:59.120
All right, so there's the code, you see what we do,
106

106

00:04:59.120  -->  00:05:02.240
once you're circling through then using set to add
107

107

00:05:02.240  -->  00:05:05.040
a value and for one element, we're trying to set the value
108

108

00:05:05.040  -->  00:05:06.620
to null then we're printing it out
109

109

00:05:06.620  -->  00:05:08.350
and we're trying to make a fresh copy.
110

110

00:05:08.350  -->  00:05:10.710
So let's run this code noting that obviously,
111

111

00:05:10.710  -->  00:05:12.931
from the capacity perspective, it's happy.
112

112

00:05:12.931  -->  00:05:16.010
But if you run it, you can see there, we've got a runtime
113

113

00:05:16.010  -->  00:05:20.245
exception, no point of exception, specifically on lines 32.
114

114

00:05:20.245  -->  00:05:23.660
That's when we try to make a copy of the list.
115

115

00:05:23.660  -->  00:05:25.190
Then what we could do there, we can change this
116

116

00:05:25.190  -->  00:05:27.507
make it list dot copy of original list,
117

117

00:05:27.507  -->  00:05:30.890
and we change that and edit that revise the code
118

118

00:05:30.890  -->  00:05:35.890
to be original list dot sub list zero comma five
119

119

00:05:38.120  -->  00:05:41.877
and then print it out, copied list
120

120

00:05:41.877  -->  00:05:45.500
if we run that we now find it works.
121

121

00:05:45.500  -->  00:05:48.710
And we find it works and the reason that works
122

122

00:05:48.710  -->  00:05:51.070
is we're creating a copy of the list up to
123

123

00:05:51.070  -->  00:05:52.970
but not including the null value.
124

124

00:05:52.970  -->  00:05:55.300
This record we had specifically had an L statement
125

125

00:05:55.300  -->  00:05:58.460
executing there in that position to set that appropriate
126

126

00:05:58.460  -->  00:06:01.520
element to know we're obviously bypassing that in our list
127

127

00:06:01.520  -->  00:06:03.873
copy using original list dot sub list.
128

128

00:06:04.770  -->  00:06:06.790
So the list dot copy of method isn't overloaded
129

129

00:06:06.790  -->  00:06:10.170
and therefore only takes a collection as a parameter.
130

130

00:06:10.170  -->  00:06:12.380
Now the list dot of method on the other hand,
131

131

00:06:12.380  -->  00:06:15.280
which returns the same top of a mutable list has 13
132

132

00:06:15.280  -->  00:06:18.030
overloaded methods, let's just look at three of them.
133

133

00:06:18.030  -->  00:06:19.533
So we're gonna paste some more coding.
134

134

00:06:20.832  -->  00:06:24.110
All right, that's the code, so you can see online 36
135

135

00:06:24.110  -->  00:06:25.900
we're creating test data.
136

136

00:06:25.900  -->  00:06:29.110
Moving on using list dot of noting that it can accept
137

137

00:06:29.110  -->  00:06:31.010
an array and printing out the results.
138

138

00:06:31.934  -->  00:06:34.080
List dot of can also accept a variable list of elements
139

139

00:06:34.080  -->  00:06:37.530
and we're doing that on line 43 and for the list dot of can
140

140

00:06:37.530  -->  00:06:39.400
be code with no parameters at all
141

141

00:06:39.400  -->  00:06:40.993
and we're doing that online 47.
142

142

00:06:42.034  -->  00:06:45.890
So if we run this and there's the results
143

143

00:06:45.890  -->  00:06:47.230
at the bottom of the screen.
144

144

00:06:47.230  -->  00:06:48.800
Now below in here if I said I knew
145

145

00:06:48.800  -->  00:06:51.550
what an empty immutable list was useful for.
146

146

00:06:51.550  -->  00:06:53.630
Let's end the video here and in the next one will start
147

147

00:06:53.630  -->  00:06:55.732
turning our attention to the two array method.
148

148

00:06:55.732  -->  00:06:57.483
See you in the next video.
