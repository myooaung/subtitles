WEBVTT
1
1

00:00:05.490  -->  00:00:06.323
<v Instructor>All right, so it's time</v>
2

2

00:00:06.323  -->  00:00:08.160
for some coding examples with methods.
3

3

00:00:08.160  -->  00:00:09.990
I've created a new project for this section
4

4

00:00:09.990  -->  00:00:11.350
of the course called Methods.
5

5

00:00:11.350  -->  00:00:14.150
So we wanna create a class here called TestPathsByValue.
6

6

00:00:22.486  -->  00:00:24.150
All right, so here's the code.
7

7

00:00:24.150  -->  00:00:26.350
So you can see first here we're setting up some primitive
8

8

00:00:26.350  -->  00:00:29.820
data variables, some strings, some string builders.
9

9

00:00:29.820  -->  00:00:32.420
And then we're getting into putting out some values
10

10

00:00:32.420  -->  00:00:34.950
and hashCodes, prior to our method call.
11

11

00:00:34.950  -->  00:00:36.850
We're actually doing some method calls
12

12

00:00:37.710  -->  00:00:41.780
and printing out the hashCode values after the method calls.
13

13

00:00:41.780  -->  00:00:43.560
So basically, we're printing out the hashCode
14

14

00:00:43.560  -->  00:00:45.640
as well the values of the string objects
15

15

00:00:45.640  -->  00:00:47.010
and the string builder objects
16

16

00:00:47.010  -->  00:00:50.280
before and after the method calls to determine equality.
17

17

00:00:50.280  -->  00:00:51.970
And that's because the hashCode,
18

18

00:00:51.970  -->  00:00:54.840
when two objects are equal as per the equals method
19

19

00:00:54.840  -->  00:00:57.833
in Java, must return the same integer result.
20

20

00:00:57.833  -->  00:00:59.240
In other words, putting in the hashCode
21

21

00:00:59.240  -->  00:01:02.010
will confirm that the reference didn't change
22

22

00:01:02.010  -->  00:01:05.160
after the method return to the calling main method.
23

23

00:01:05.160  -->  00:01:06.330
And we're also doing a test there
24

24

00:01:06.330  -->  00:01:09.110
with primitive variables as well with two n's.
25

25

00:01:09.110  -->  00:01:10.460
So let's just run the code.
26

26

00:01:12.467  -->  00:01:14.330
Now there's the output down at the bottom.
27

27

00:01:14.330  -->  00:01:16.180
You can see there, we've got before method call,
28

28

00:01:16.180  -->  00:01:18.943
abc.hashCode value which is abcdef
29

29

00:01:20.089  -->  00:01:21.170
with the various values there.
30

30

00:01:21.170  -->  00:01:23.180
I'll just make this a bit bigger so you can read it.
31

31

00:01:23.180  -->  00:01:24.670
So you can there confirming that abc
32

32

00:01:24.670  -->  00:01:28.370
had the same hashCode before and after the method call,
33

33

00:01:28.370  -->  00:01:30.200
even though the value changed.
34

34

00:01:30.200  -->  00:01:34.163
And same for def as well as aString and bString.
35

35

00:01:35.330  -->  00:01:37.660
So the point here is that the hashCodes
36

36

00:01:37.660  -->  00:01:40.460
of the string and string builder objects didn't change.
37

37

00:01:40.460  -->  00:01:44.270
However, the values of the string builder objects did,
38

38

00:01:44.270  -->  00:01:46.480
the actual values themselves.
39

39

00:01:46.480  -->  00:01:48.934
Notice I started earlier and we've verified here
40

40

00:01:48.934  -->  00:01:51.020
the primitive data-type variables
41

41

00:01:51.020  -->  00:01:53.503
and the string values didn't change.
42

42

00:01:54.390  -->  00:01:55.223
All right.
43

43

00:01:57.270  -->  00:01:58.690
The following slide is a review
44

44

00:01:58.690  -->  00:02:01.870
of some of the rules for the return type of methods.
45

45

00:02:01.870  -->  00:02:04.050
So we're looking at some valid return examples first.
46

46

00:02:04.050  -->  00:02:07.380
So, first one, Number getNumber parentheses,
47

47

00:02:07.380  -->  00:02:09.158
then the left to right curly brace is
48

48

00:02:09.158  -->  00:02:12.080
the return Integer.valueOf one in parentheses.
49

49

00:02:12.080  -->  00:02:16.360
So here you can return a subtype of a declared return type.
50

50

00:02:16.360  -->  00:02:19.443
Here an integer is a subtype of number.
51

51

00:02:19.443  -->  00:02:20.276
Next one.
52

52

00:02:20.276  -->  00:02:21.690
Number Getnumber parentheses
53

53

00:02:21.690  -->  00:02:24.010
left to right curly braces return null.
54

54

00:02:24.010  -->  00:02:27.350
You can return a null for a reference type return type,
55

55

00:02:27.350  -->  00:02:28.870
as we're doing here.
56

56

00:02:28.870  -->  00:02:30.990
Next, long getNumber parentheses
57

57

00:02:30.990  -->  00:02:32.680
left to right curly braces and then the code.
58

58

00:02:32.680  -->  00:02:35.740
In the method block is int myInt equals two
59

59

00:02:35.740  -->  00:02:37.290
then return myInt.
60

60

00:02:37.290  -->  00:02:40.220
You can return a narrower primitive data type
61

61

00:02:40.220  -->  00:02:42.233
if the return type is a primitive.
62

62

00:02:45.210  -->  00:02:46.043
Okay, moving on,
63

63

00:02:46.043  -->  00:02:48.250
the next one is long getNumber parentheses
64

64

00:02:48.250  -->  00:02:49.350
left to right curly braces
65

65

00:02:49.350  -->  00:02:51.800
then return Long with a capital L,
66

66

00:02:51.800  -->  00:02:53.734
so it's the uppercase.valueOf
67

67

00:02:53.734  -->  00:02:55.650
and then 101 in parentheses.
68

68

00:02:55.650  -->  00:02:58.000
You can return a primitive data type wrapper
69

69

00:02:58.000  -->  00:03:00.610
if the return type is a primitive.
70

70

00:03:00.610  -->  00:03:01.443
Moving on.
71

71

00:03:01.443  -->  00:03:02.900
Long getNumber parentheses
72

72

00:03:02.900  -->  00:03:05.083
and then we've got left to right curly braces
73

73

00:03:05.083  -->  00:03:07.770
and then the actual code is return Integer.valueOf
74

74

00:03:07.770  -->  00:03:09.590
and in parentheses 10.
75

75

00:03:09.590  -->  00:03:12.363
You can return a wrapper of a primitive to a primitive
76

76

00:03:12.363  -->  00:03:15.160
that is the same or wider.
77

77

00:03:15.160  -->  00:03:16.900
And the last one, the other example I've got here
78

78

00:03:16.900  -->  00:03:19.970
is public void returnNothing parentheses
79

79

00:03:19.970  -->  00:03:21.150
left to right curly braces
80

80

00:03:21.150  -->  00:03:25.020
then return by itself on the line followed by a semicolon.
81

81

00:03:25.020  -->  00:03:26.780
You can just have a return statement
82

82

00:03:26.780  -->  00:03:28.960
returning no reference or primitive
83

83

00:03:28.960  -->  00:03:31.993
when the method definition is void as it is here.
84

84

00:03:34.600  -->  00:03:36.400
Looking at some invalid return examples.
85

85

00:03:36.400  -->  00:03:38.760
We've got Integer getNumber parentheses
86

86

00:03:38.760  -->  00:03:40.900
left to right curly braces and then the actual code is
87

87

00:03:40.900  -->  00:03:44.497
Number n equals Integer.valueOf and 10 in parentheses
88

88

00:03:44.497  -->  00:03:46.380
and return n.
89

89

00:03:46.380  -->  00:03:50.490
You cannot return a supertype of the defined returned type.
90

90

00:03:50.490  -->  00:03:54.350
Moving on, public void returnNothing parentheses
91

91

00:03:54.350  -->  00:03:56.720
left to right curly braces return null.
92

92

00:03:56.720  -->  00:04:00.770
You can't return null if the return type is void.
93

93

00:04:00.770  -->  00:04:02.770
Next, long getNumber parentheses
94

94

00:04:02.770  -->  00:04:04.980
left to right curly braces and return null.
95

95

00:04:04.980  -->  00:04:08.480
You cannot return null if the return type is a primitive.
96

96

00:04:08.480  -->  00:04:10.390
And the last invalid example,
97

97

00:04:10.390  -->  00:04:11.943
int getNumber parentheses
98

98

00:04:11.943  -->  00:04:14.990
left to right curly braces return 10L.
99

99

00:04:14.990  -->  00:04:16.400
You cannot return a primitive
100

100

00:04:16.400  -->  00:04:18.200
that is larger than the return type.
101

101

00:04:20.330  -->  00:04:21.163
So finally in this video,
102

102

00:04:21.163  -->  00:04:23.850
I want to talk a bit about constructors.
103

103

00:04:23.850  -->  00:04:26.420
A constructor is a special method used in the creation
104

104

00:04:26.420  -->  00:04:28.750
of an object that's an instance of a class.
105

105

00:04:28.750  -->  00:04:31.080
The constructor method name must be the same
106

106

00:04:31.080  -->  00:04:32.520
as the class name.
107

107

00:04:32.520  -->  00:04:33.990
The constructor method does not have
108

108

00:04:33.990  -->  00:04:36.130
any return type, including void.
109

109

00:04:36.130  -->  00:04:38.943
The return statement cannot be used in a constructor.
110

110

00:04:40.692  -->  00:04:43.320
The constructor method is required,
111

111

00:04:43.320  -->  00:04:45.200
but you don't have to declare one.
112

112

00:04:45.200  -->  00:04:47.700
If you declare zero constructors in a class,
113

113

00:04:47.700  -->  00:04:50.137
Java will create an implicit noargs constructor
114

114

00:04:50.137  -->  00:04:53.430
with the same access modifier as the class
115

115

00:04:53.430  -->  00:04:55.060
and a call to super,
116

116

00:04:55.060  -->  00:04:57.600
which executes the parent's constructor.
117

117

00:04:57.600  -->  00:04:59.650
If you declare one or more constructors,
118

118

00:04:59.650  -->  00:05:01.500
Java will not create an implicit
119

119

00:05:01.500  -->  00:05:03.720
no arguments constructor for you,
120

120

00:05:03.720  -->  00:05:06.933
even if you do not self declare a noargs constructor.
121

121

00:05:08.400  -->  00:05:10.440
Let's verify this bit in code.
122

122

00:05:10.440  -->  00:05:13.667
We're gonna create a class called ConstructorExample.
123

123

00:05:22.699  -->  00:05:24.450
So there's our code.
124

124

00:05:24.450  -->  00:05:26.280
Now this code's got three classes.
125

125

00:05:26.280  -->  00:05:27.597
Firstly, we've got class Atest,
126

126

00:05:27.597  -->  00:05:30.030
and you can see defined no constructor defined,
127

127

00:05:30.030  -->  00:05:31.650
in fact no fields either.
128

128

00:05:31.650  -->  00:05:32.980
Btest.
129

129

00:05:32.980  -->  00:05:35.370
You can see that's extending Atest,
130

130

00:05:35.370  -->  00:05:38.380
and it's got one constructor that takes a name parameter
131

131

00:05:38.380  -->  00:05:40.950
and sets the name field on Btest.
132

132

00:05:40.950  -->  00:05:43.380
Nothing particularly complex about that.
133

133

00:05:43.380  -->  00:05:46.134
And then our third class, the ConstructorExample class,
134

134

00:05:46.134  -->  00:05:48.190
that instantiates it into the Btest
135

135

00:05:48.190  -->  00:05:51.230
using the Btest constructor with one parameter.
136

136

00:05:51.230  -->  00:05:52.830
What you can't see there,
137

137

00:05:52.830  -->  00:05:56.500
is that ATest has a default noargs constructor created
138

138

00:05:56.500  -->  00:05:57.930
under covers by the compiler
139

139

00:05:57.930  -->  00:05:59.050
that actually gets called
140

140

00:05:59.050  -->  00:06:02.620
when the Btest constructor starts executing.
141

141

00:06:02.620  -->  00:06:03.453
Let's run this.
142

142

00:06:06.420  -->  00:06:08.350
There's the basic output so far.
143

143

00:06:08.350  -->  00:06:10.770
Nothing really much to talk about yet.
144

144

00:06:10.770  -->  00:06:12.220
What we'll do now is I'm going to add
145

145

00:06:12.220  -->  00:06:15.320
a no arguments constructor to ATest.
146

146

00:06:15.320  -->  00:06:17.515
We're gonna demonstrate that save
147

147

00:06:17.515  -->  00:06:18.640
and then we're gonna specifically call that.
148

148

00:06:18.640  -->  00:06:19.850
It does get called.
149

149

00:06:19.850  -->  00:06:21.200
Let's go ahead and do that.
150

150

00:06:22.250  -->  00:06:24.380
Okay, so there's our no arguments constructor.
151

151

00:06:24.380  -->  00:06:25.380
If we run this code,
152

152

00:06:28.900  -->  00:06:30.940
you can see that ATest constructor is called
153

153

00:06:30.940  -->  00:06:33.830
even though there's no explicit call to it in our code.
154

154

00:06:33.830  -->  00:06:35.380
But moving on,
155

155

00:06:35.380  -->  00:06:37.603
if we go back to our Btest constructor,
156

156

00:06:37.603  -->  00:06:39.300
and edit call to super
157

157

00:06:39.300  -->  00:06:42.183
at the first line in the constructor,
158

158

00:06:47.600  -->  00:06:50.350
you can see there that there's no change to the output.
159

159

00:06:50.350  -->  00:06:52.210
In other words, the results are the same.
160

160

00:06:52.210  -->  00:06:53.110
Clearly here we can see
161

161

00:06:53.110  -->  00:06:55.620
that whether you specify it explicitly or not,
162

162

00:06:55.620  -->  00:06:58.720
a parent's default constructor is executed anyway.
163

163

00:06:58.720  -->  00:07:00.420
Let's remove the super call there.
164

164

00:07:03.950  -->  00:07:07.440
Let's change the constructor in ATest to take a parameter.
165

165

00:07:07.440  -->  00:07:09.737
Note that we're actually changing the code.
166

166

00:07:09.737  -->  00:07:11.130
I'm gonna do that.
167

167

00:07:11.130  -->  00:07:13.810
I'm just going to replace the no arguments constructor
168

168

00:07:13.810  -->  00:07:16.000
with a one argument constructor.
169

169

00:07:16.000  -->  00:07:17.740
Very simple as you can see.
170

170

00:07:17.740  -->  00:07:19.190
Now if we run the code again,
171

171

00:07:20.890  -->  00:07:22.340
this time we've got an error.
172

172

00:07:23.790  -->  00:07:27.010
There's no default constructor available in ATest.
173

173

00:07:27.010  -->  00:07:29.130
Again, the code has an implied call to super
174

174

00:07:29.130  -->  00:07:31.110
from the Btest constructor,
175

175

00:07:31.110  -->  00:07:33.140
but now we don't have a no arguments constructor
176

176

00:07:33.140  -->  00:07:36.060
because we specified a constructor in ATest
177

177

00:07:36.060  -->  00:07:37.260
that takes one argument.
178

178

00:07:38.360  -->  00:07:41.130
The compiler did not implicitly create one for us,
179

179

00:07:41.130  -->  00:07:43.590
because we created another constructor.
180

180

00:07:43.590  -->  00:07:45.200
Now we've got two options,
181

181

00:07:45.200  -->  00:07:48.380
to create a no arguments constructor for ATest ourselves,
182

182

00:07:48.380  -->  00:07:51.470
or to make a call to super passing the parameter,
183

183

00:07:51.470  -->  00:07:52.370
which I'll do now.
184

184

00:07:53.290  -->  00:07:55.420
Super name
185

185

00:07:58.890  -->  00:07:59.723
on the code.
186

186

00:08:01.430  -->  00:08:03.103
We can see that it's working again.
187

187

00:08:06.090  -->  00:08:07.450
I'll be talking more about constructors
188

188

00:08:07.450  -->  00:08:09.790
when we visit inheritance in a future video.
189

189

00:08:09.790  -->  00:08:11.420
It is important to remember two things
190

190

00:08:11.420  -->  00:08:12.770
about constructors though:
191

191

00:08:12.770  -->  00:08:14.870
If you don't define one, you'll get one anyway
192

192

00:08:14.870  -->  00:08:17.820
with no arguments and an implicit call to super.
193

193

00:08:17.820  -->  00:08:18.910
If you do declare one,
194

194

00:08:18.910  -->  00:08:21.070
and your class is a child of another class,
195

195

00:08:21.070  -->  00:08:22.940
the implicit call to super is still there
196

196

00:08:22.940  -->  00:08:26.090
even if you do not explicitly call super yourself.
197

197

00:08:26.090  -->  00:08:28.730
Now, we're gonna be examining more cases in the next video
198

198

00:08:28.730  -->  00:08:31.260
on the add of ordinary uses of methods.
199

199

00:08:31.260  -->  00:08:32.560
See you in the next video.
