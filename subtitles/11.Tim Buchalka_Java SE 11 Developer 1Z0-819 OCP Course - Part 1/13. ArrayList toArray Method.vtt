WEBVTT
1
1

00:00:04.610  -->  00:00:06.370
<v Tim Buchalka>Let's turn our attention next</v>
2

2

00:00:06.370  -->  00:00:08.900
to the array list dot to array method.
3

3

00:00:08.900  -->  00:00:10.360
It's highly likely that you'll see
4

4

00:00:10.360  -->  00:00:12.500
this method in an exam question.
5

5

00:00:12.500  -->  00:00:14.810
We've looked at it previously in the array section,
6

6

00:00:14.810  -->  00:00:16.810
but let's put it through its paces here.
7

7

00:00:18.580  -->  00:00:20.970
So this table shows the three scenarios that occur
8

8

00:00:20.970  -->  00:00:24.360
when calling the array list dot to array method.
9

9

00:00:24.360  -->  00:00:26.430
Calling the method with no parameter,
10

10

00:00:26.430  -->  00:00:28.210
calling the method with a parameter
11

11

00:00:28.210  -->  00:00:31.830
that is an array larger than or equal to the list size.
12

12

00:00:31.830  -->  00:00:34.310
And thirdly, calling the method with a parameter
13

13

00:00:34.310  -->  00:00:37.520
that is an array smaller than the list size.
14

14

00:00:37.520  -->  00:00:40.020
So the first case with no parameter, there is always
15

15

00:00:40.020  -->  00:00:42.860
gonna be an array of objects returned with elements.
16

16

00:00:42.860  -->  00:00:44.990
The results, the same for a raw array list
17

17

00:00:44.990  -->  00:00:47.330
and a generic array list and object array
18

18

00:00:47.330  -->  00:00:50.890
returned whose size is a list dot size.
19

19

00:00:50.890  -->  00:00:52.480
Next, where the parameter input has
20

20

00:00:52.480  -->  00:00:55.200
an array length greater than or equal to the element size
21

21

00:00:55.200  -->  00:00:57.880
and the past array limits are not null.
22

22

00:00:57.880  -->  00:00:59.830
Result equals the parameter array,
23

23

00:00:59.830  -->  00:01:02.210
elements at index less than list dot size
24

24

00:01:02.210  -->  00:01:04.860
get populated with the list's elements.
25

25

00:01:04.860  -->  00:01:08.430
The element at index is equal to list size is set to null.
26

26

00:01:08.430  -->  00:01:10.580
And elements at index greater than list dot size
27

27

00:01:10.580  -->  00:01:11.820
remain the same as they were when
28

28

00:01:11.820  -->  00:01:13.920
they were passed to the method.
29

29

00:01:13.920  -->  00:01:15.990
If the array list is raw, you must cast it to
30

30

00:01:15.990  -->  00:01:19.750
a typed array if assigning output to a variable.
31

31

00:01:19.750  -->  00:01:21.760
And in the third scenario where the parameter
32

32

00:01:21.760  -->  00:01:24.070
array length is less than element size,
33

33

00:01:24.070  -->  00:01:27.240
the result, array returned is the set of values in the list
34

34

00:01:27.240  -->  00:01:29.550
and the type of the parameter passed
35

35

00:01:29.550  -->  00:01:31.290
an array store exception occurs
36

36

00:01:31.290  -->  00:01:33.310
if the type of the array of the parameter
37

37

00:01:33.310  -->  00:01:35.860
isn't compatible with the element type in the list.
38

38

00:01:37.400  -->  00:01:39.730
All right, so let's explore these scenarios in some code.
39

39

00:01:39.730  -->  00:01:41.920
We need to create a new class here.
40

40

00:01:41.920  -->  00:01:44.287
We're going to call this one ToArrayExamples.
41

41

00:01:53.110  -->  00:01:55.160
Right, so there's our code.
42

42

00:01:55.160  -->  00:01:57.020
Looking at the code there, we're testing
43

43

00:01:57.020  -->  00:01:58.670
two types of array lists here.
44

44

00:01:58.670  -->  00:02:00.420
We've got a raw type array list
45

45

00:02:00.420  -->  00:02:02.770
and a generics array list type to integer.
46

46

00:02:02.770  -->  00:02:06.470
Both array lists are populated with integer elements.
47

47

00:02:06.470  -->  00:02:07.740
You can see it says setting up
48

48

00:02:07.740  -->  00:02:09.340
our integer array there as well.
49

49

00:02:10.200  -->  00:02:12.290
So we're studying the results of the toArray method
50

50

00:02:12.290  -->  00:02:14.940
to a local variable type inference, variable var.
51

51

00:02:14.940  -->  00:02:17.020
We're doing that for the generics array
52

52

00:02:17.020  -->  00:02:19.470
on line 38 and then further on down,
53

53

00:02:19.470  -->  00:02:21.853
we're doing the same thing on line 57.
54

54

00:02:22.900  -->  00:02:24.640
And what we're also doing with both arrays is,
55

55

00:02:24.640  -->  00:02:25.990
we're putting the type of object,
56

56

00:02:25.990  -->  00:02:28.020
the type of array returned from the method,
57

57

00:02:28.020  -->  00:02:29.920
as well as putting the array elements.
58

58

00:02:31.520  -->  00:02:34.350
So line 46 and line 64, the other thing
59

59

00:02:34.350  -->  00:02:35.890
we're doing is we're retrieving an element
60

60

00:02:35.890  -->  00:02:37.300
from the returned array and testing
61

61

00:02:37.300  -->  00:02:39.770
whether casting is required to do that.
62

62

00:02:39.770  -->  00:02:41.320
So let's actually run the code.
63

63

00:02:44.893  -->  00:02:46.040
All right, and there's the output.
64

64

00:02:46.040  -->  00:02:47.970
So you can see for scenario one,
65

65

00:02:47.970  -->  00:02:50.710
the parameter again, was a reference variable for an array
66

66

00:02:50.710  -->  00:02:53.360
of integer elements with the elements all being null.
67

67

00:02:56.680  -->  00:02:58.410
So what have we learned in this scenario?
68

68

00:02:58.410  -->  00:03:00.360
Well, firstly, both lists returned the array
69

69

00:03:00.360  -->  00:03:03.340
that was passed but changed its elements.
70

70

00:03:03.340  -->  00:03:05.570
Copying elements from the list to the array.
71

71

00:03:05.570  -->  00:03:07.700
Using the raw array list and assigning the result
72

72

00:03:07.700  -->  00:03:10.110
of the method to var required us to cast it.
73

73

00:03:10.110  -->  00:03:11.410
That's when retrieving a single
74

74

00:03:11.410  -->  00:03:12.640
element from the returned array.
75

75

00:03:12.640  -->  00:03:14.350
So we've got a scenario, the scenario there,
76

76

00:03:14.350  -->  00:03:16.483
recasting it to an int on line 64.
77

77

00:03:17.820  -->  00:03:19.490
And up here on line 46 with the
78

78

00:03:19.490  -->  00:03:22.090
generics array list, we didn't need to do that.
79

79

00:03:22.090  -->  00:03:23.910
Right, so that's one test, let's try another one.
80

80

00:03:23.910  -->  00:03:25.480
We're going to add some code after this.
81

81

00:03:25.480  -->  00:03:28.393
Right down here at the bottom of this first chunk of code.
82

82

00:03:29.770  -->  00:03:31.070
Okay, so there's the code.
83

83

00:03:32.060  -->  00:03:33.690
So this is scenario two now.
84

84

00:03:33.690  -->  00:03:36.700
This code that I've pasted in is very similar
85

85

00:03:36.700  -->  00:03:39.440
to the previous code segment with the following changes.
86

86

00:03:39.440  -->  00:03:41.560
Firstly, the parameter array that we're passing
87

87

00:03:41.560  -->  00:03:43.620
has values for all of its elements.
88

88

00:03:43.620  -->  00:03:46.300
And you can see that we're setting that up there.
89

89

00:03:46.300  -->  00:03:50.380
On line 76 we're not using local variable type inference.
90

90

00:03:50.380  -->  00:03:52.500
Instead, what we're using is an integer array
91

91

00:03:52.500  -->  00:03:55.693
variable references to assign the result of the best code
92

92

00:03:55.693  -->  00:03:57.480
and you can see the math code's
93

93

00:03:57.480  -->  00:04:00.883
line 77 and down here also on line 96.
94

94

00:04:02.050  -->  00:04:04.120
Now we don't need to cast to integer array
95

95

00:04:04.120  -->  00:04:06.993
for the array list of integer objects, the generics one.
96

96

00:04:07.840  -->  00:04:10.750
But we do need to do that on line 96 for the
97

97

00:04:10.750  -->  00:04:14.120
raw array lists and when we access individual elements,
98

98

00:04:14.120  -->  00:04:16.740
no casting was required in either instance.
99

99

00:04:16.740  -->  00:04:19.620
And you can see the example there on line 85
100

100

00:04:19.620  -->  00:04:21.793
and also the example on line 103.
101

101

00:04:22.820  -->  00:04:23.770
Let's run the code.
102

102

00:04:26.150  -->  00:04:28.100
So does anything look weird in that output
103

103

00:04:28.100  -->  00:04:29.960
that you can see at the bottom of the screen?
104

104

00:04:29.960  -->  00:04:32.140
What's with the null element in each array.
105

105

00:04:32.140  -->  00:04:33.110
I did allude to that when we were
106

106

00:04:33.110  -->  00:04:35.010
looking at the slides earlier in the video.
107

107

00:04:35.010  -->  00:04:37.380
This is a feature of the two array method.
108

108

00:04:37.380  -->  00:04:39.810
It sets the element that is at the index
109

109

00:04:39.810  -->  00:04:43.360
list dot size to null, to inform the consumer
110

110

00:04:43.360  -->  00:04:45.860
where the copied element's boundary is.
111

111

00:04:45.860  -->  00:04:47.250
All right, so keep that in mind.
112

112

00:04:47.250  -->  00:04:49.740
All right, let's look at another scenario now.
113

113

00:04:49.740  -->  00:04:51.373
We're going to post some more code in.
114

114

00:04:56.461  -->  00:04:59.060
All right, so there's scenario three, the method to array.
115

115

00:04:59.060  -->  00:05:01.350
This is where we're actually not passing a parameter
116

116

00:05:01.350  -->  00:05:03.870
and it populates a newly instance object array
117

117

00:05:03.870  -->  00:05:07.310
with the lists elements, which happen to be all integer.
118

118

00:05:07.310  -->  00:05:08.670
The behaviour is the same for both
119

119

00:05:08.670  -->  00:05:10.530
a raw list and a generics list.
120

120

00:05:10.530  -->  00:05:12.370
Now the thing I want you to look at
121

121

00:05:12.370  -->  00:05:14.157
firstly is the code on line 113.
122

122

00:05:15.194  -->  00:05:16.130
'Cause what I want to do initially,
123

123

00:05:16.130  -->  00:05:18.040
I want to code that out, I want
124

124

00:05:18.040  -->  00:05:19.590
to put some other code in here.
125

125

00:05:20.700  -->  00:05:22.420
And looking at the comments from the code
126

126

00:05:22.420  -->  00:05:25.250
that are posted on line 113, it appears to be wrong
127

127

00:05:25.250  -->  00:05:27.410
because you can see there that the code compiles.
128

128

00:05:27.410  -->  00:05:29.573
We've got no errors, but if I run this,
129

129

00:05:32.740  -->  00:05:36.140
in fact get a class cast exception on that line.
130

130

00:05:36.140  -->  00:05:37.690
So I've got to undo that change
131

131

00:05:39.370  -->  00:05:40.990
and go back to the original pasted code,
132

132

00:05:40.990  -->  00:05:42.750
which was an object array.
133

133

00:05:42.750  -->  00:05:47.723
If we run this, we find that it does work this time.
134

134

00:05:50.570  -->  00:05:52.420
So what did we learn with this code segment?
135

135

00:05:52.420  -->  00:05:53.460
Well, firstly, it doesn't matter
136

136

00:05:53.460  -->  00:05:54.900
what type of array list you use
137

137

00:05:54.900  -->  00:05:57.510
when executing to array with no parameter.
138

138

00:05:57.510  -->  00:05:59.980
The result will always be an object array
139

139

00:05:59.980  -->  00:06:02.240
and casting will be required when you want to access
140

140

00:06:02.240  -->  00:06:04.520
its individual elements for that reason.
141

141

00:06:04.520  -->  00:06:07.270
And the elements are the elements copied from the list.
142

142

00:06:08.510  -->  00:06:10.300
So I can see looking at the code there.
143

143

00:06:10.300  -->  00:06:13.620
Obviously we're using casting in both scenarios.
144

144

00:06:13.620  -->  00:06:15.390
I'm gonna finish the video here, hang in there,
145

145

00:06:15.390  -->  00:06:17.250
we have actually got a few more examples.
146

146

00:06:17.250  -->  00:06:19.090
We're getting close to the end of this now.
147

147

00:06:19.090  -->  00:06:20.703
I'll see you in the next video.
