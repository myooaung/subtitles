WEBVTT
1
1

00:00:05.160  -->  00:00:05.993 line:15% 
<v Instructor>All right.</v>
2

2

00:00:05.993  -->  00:00:07.150 line:15% 
Now let's quickly look at the remainder
3

3

00:00:07.150  -->  00:00:09.780 line:15% 
of the binary operator separate discussed previously
4

4

00:00:09.780  -->  00:00:12.350
in the new class in the same project.
5

5

00:00:12.350  -->  00:00:15.659
So I'm going to call this one binary operator examples two.
6

6

00:00:15.659  -->  00:00:17.826
(typing).
7

7

00:00:24.300  -->  00:00:25.740
This kind of showing examples
8

8

00:00:25.740  -->  00:00:28.500
of the equal would not equal comparison operators,
9

9

00:00:28.500  -->  00:00:31.100
are primitive data types, strings and objects
10

10

00:00:31.100  -->  00:00:32.150
as you can see there.
11

11

00:00:34.860  -->  00:00:36.110
Okay, we'll run the code.
12

12

00:00:37.430  -->  00:00:39.440
Again (murmur) process there.
13

13

00:00:39.440  -->  00:00:42.250
Now I want to quickly show some examples of the Bitwise OR
14

14

00:00:42.250  -->  00:00:43.660
and an XOR operators
15

15

00:00:47.320  -->  00:00:48.920
You can see what I'm doing here.
16

16

00:00:51.000  -->  00:00:52.230
And I feel pretty confident saying that you know
17

17

00:00:52.230  -->  00:00:53.980
that a Bitwise or bit is one if one
18

18

00:00:55.272  -->  00:00:57.110
or the other operand bit is one.
19

19

00:00:57.110  -->  00:01:00.517
And bit was and is one if both operand bit is one
20

20

00:01:00.517  -->  00:01:03.610
And bit one is XOP is zero with both operand,
21

21

00:01:03.610  -->  00:01:06.313
bits of the same value, otherwise it's one.
22

22

00:01:07.510  -->  00:01:09.710
That's what we're seeking to do here to run
23

23

00:01:11.180  -->  00:01:12.013
on the code.
24

24

00:01:14.009  -->  00:01:16.090
And get the results as follows.
25

25

00:01:16.090  -->  00:01:18.020
So the last set of binary operators,
26

26

00:01:18.020  -->  00:01:19.640
last in the precedence order,
27

27

00:01:19.640  -->  00:01:21.620
are the assignment operators.
28

28

00:01:21.620  -->  00:01:24.720
So let's look at some of those with some example code.
29

29

00:01:24.720  -->  00:01:26.170
I'll paste the code in there.
30

30

00:01:28.050  -->  00:01:30.470
Okay, so there's the code look up back up to the top it.
31

31

00:01:30.470  -->  00:01:32.320
(murmur)pasted in study.
32

32

00:01:32.320  -->  00:01:34.660
The code is starting from line 72.
33

33

00:01:34.660  -->  00:01:37.210
Now it's interesting to note that the assignment operators,
34

34

00:01:37.210  -->  00:01:39.870
are not promoting the results of the compound assignments,
35

35

00:01:39.870  -->  00:01:42.200
and that you can use these operators on smaller
36

36

00:01:42.200  -->  00:01:44.150
than int variables.
37

37

00:01:44.150  -->  00:01:45.900
So see what (murmur) various examples
38

38

00:01:45.900  -->  00:01:48.600
as we move down the code, multiplicity of assignments,
39

39

00:01:48.600  -->  00:01:50.170
noting that the variables are not promoted.
40

40

00:01:50.170  -->  00:01:52.820
So I mentioned additive assignments noted variables again,
41

41

00:01:52.820  -->  00:01:53.723
are not promoted.
42

42

00:01:54.610  -->  00:01:56.410
Assignment operators with bit shift,
43

43

00:01:57.360  -->  00:02:01.040
enterprise with bit xor or down here down the bottom.
44

44

00:02:01.040  -->  00:02:02.300
Basically the assignment operators.
45

45

00:02:02.300  -->  00:02:03.583
So lets run this now.
46

46

00:02:06.030  -->  00:02:07.063
And here is results.
47

47

00:02:09.110  -->  00:02:10.640
I just want to confirm that one statement
48

48

00:02:10.640  -->  00:02:11.473
that I made earlier
49

49

00:02:11.473  -->  00:02:14.170
that binary operators promote results at a minimum
50

50

00:02:14.170  -->  00:02:15.180
(murmur) is true.
51

51

00:02:15.180  -->  00:02:18.080
To do that, I'm going to pay some coding to show you that.
52

52

00:02:19.130  -->  00:02:22.160
I'm going to enter the bottom here paste it in.
53

53

00:02:22.160  -->  00:02:23.180
Okay, there's the code.
54

54

00:02:23.180  -->  00:02:24.230
So you can see,
55

55

00:02:24.230  -->  00:02:26.360
the code introduces a compiler error,
56

56

00:02:26.360  -->  00:02:27.397
on the second segment of code,
57

57

00:02:27.397  -->  00:02:28.880
but not on the first.
58

58

00:02:28.880  -->  00:02:31.180
You can see that compounder assignment operators
59

59

00:02:31.180  -->  00:02:33.170
are less restrictive as far as talking
60

60

00:02:33.170  -->  00:02:34.950
but that in itself can lead to problems
61

61

00:02:34.950  -->  00:02:37.004
as it did here with an overflow result.
62

62

00:02:37.004  -->  00:02:37.854
(murmur) up here.
63

63

00:02:39.690  -->  00:02:41.340
Code (murmur) found it.
64

64

00:02:41.340  -->  00:02:43.490
I'll just comment that last break code out.
65

65

00:02:46.800  -->  00:02:47.633
Alright so at this point,
66

66

00:02:47.633  -->  00:02:49.420
when I look at the ternary operator,
67

67

00:02:49.420  -->  00:02:52.550
this is the only operator in Java that's got three operands.
68

68

00:02:52.550  -->  00:02:55.450
So its format is operand one, question mark,
69

69

00:02:55.450  -->  00:02:58.170
operand two colon, operand three.
70

70

00:02:58.170  -->  00:03:00.060
The ternary operator is often compared
71

71

00:03:00.060  -->  00:03:01.420
to an if statement,
72

72

00:03:01.420  -->  00:03:03.930
but it is an operator and not a statement.
73

73

00:03:03.930  -->  00:03:06.230
And therefore it is either used in an expression
74

74

00:03:06.230  -->  00:03:08.670
or a terms of value to a variable.
75

75

00:03:08.670  -->  00:03:10.613
it cannot be a standalone statement.
76

76

00:03:11.810  -->  00:03:13.860
The first operand must be a boolean value
77

77

00:03:13.860  -->  00:03:16.880
or be an expression whose result is a boolean value.
78

78

00:03:16.880  -->  00:03:19.270
The other operands datatypes can be anything
79

79

00:03:19.270  -->  00:03:22.340
but both operands must share a common type.
80

80

00:03:22.340  -->  00:03:24.880
So if one evaluates to true,
81

81

00:03:24.880  -->  00:03:27.560
then the resulting value will be operand two.
82

82

00:03:27.560  -->  00:03:29.370
If operating one is false,
83

83

00:03:29.370  -->  00:03:31.970
then the resulting value will be operand three.
84

84

00:03:31.970  -->  00:03:35.630
If operand two and operand three are both expressions,
85

85

00:03:35.630  -->  00:03:38.200
only one of the expressions is ever evaluated,
86

86

00:03:38.200  -->  00:03:40.690
based on the value of operand one.
87

87

00:03:40.690  -->  00:03:41.720
It will never be the case
88

88

00:03:41.720  -->  00:03:44.270
that both expressions are evaluated.
89

89

00:03:44.270  -->  00:03:46.990
So, let's explore a few code examples for this.
90

90

00:03:46.990  -->  00:03:49.280
So we gonna to create a work new class in this project.
91

91

00:03:49.280  -->  00:03:51.117
Will call it Ternary operator
92

92

00:04:00.517  -->  00:04:02.690
This is a very basic ternary operation so you can see there.
93

93

00:04:02.690  -->  00:04:03.830
So if we run this
94

94

00:04:07.710  -->  00:04:10.730
see the result is the result of example one equals false.
95

95

00:04:10.730  -->  00:04:12.550
And obviously that's because we've got no arguments
96

96

00:04:12.550  -->  00:04:13.383
at the moment.
97

97

00:04:13.383  -->  00:04:14.216
So if we change this
98

98

00:04:15.590  -->  00:04:18.390
and put an argument, parsing argument to a main method,
99

99

00:04:18.390  -->  00:04:20.743
call it whatever like what is called an a-r-g one.
100

100

00:04:25.178  -->  00:04:27.530
You can say we know got the output result of example one,
101

101

00:04:27.530  -->  00:04:28.403
equals true.
102

102

00:04:30.040  -->  00:04:32.640
We can make the first operand as complex as we wish
103

103

00:04:32.640  -->  00:04:34.130
and return it in value.
104

104

00:04:34.130  -->  00:04:34.963
To show you what I mean,
105

105

00:04:34.963  -->  00:04:36.740
I'm gonna paste some more coding here.
106

106

00:04:38.820  -->  00:04:40.113
So first if I run up,
107

107

00:04:41.610  -->  00:04:43.220
keeping in mind I've got the wrong argument.
108

108

00:04:43.220  -->  00:04:45.340
Now for now, what it's looking for,
109

109

00:04:45.340  -->  00:04:47.960
we get the result of example two equals zero.
110

110

00:04:47.960  -->  00:04:49.033
But if I change this,
111

111

00:04:50.320  -->  00:04:51.700
and we'll get the argument when it's looking for
112

112

00:04:51.700  -->  00:04:52.593
which is 10.
113

113

00:04:54.240  -->  00:04:56.153
Okay, run it again.
114

114

00:04:58.470  -->  00:05:00.703
This time was out of example two equals 10.
115

115

00:05:02.640  -->  00:05:04.570
Now we can return values of different types
116

116

00:05:04.570  -->  00:05:07.220
if we return them to an object variable.
117

117

00:05:07.220  -->  00:05:09.643
So from pasting some code demonstrating that.
118

118

00:05:11.470  -->  00:05:13.310
This card is demonstrating the result
119

119

00:05:13.310  -->  00:05:17.240
of the ternary operation can be either an int or a string.
120

120

00:05:17.240  -->  00:05:20.020
This is valid because we defined the variable assigned
121

121

00:05:20.020  -->  00:05:22.660
to the expression to be of type object,
122

122

00:05:22.660  -->  00:05:25.620
and the 10 will be box to an integer (murmur) automatically.
123

123

00:05:25.620  -->  00:05:27.023
So we've actually run this.
124

124

00:05:29.560  -->  00:05:32.740
You can see the result an example three equals 10.
125

125

00:05:32.740  -->  00:05:35.473
If you run it again for different parameter.
126

126

00:05:40.970  -->  00:05:42.953
Here says the result got not 10.
127

127

00:05:43.960  -->  00:05:45.760
So that's using a top object.
128

128

00:05:45.760  -->  00:05:48.420
But if we change the data type of object result,
129

129

00:05:48.420  -->  00:05:49.720
which is currently an object,
130

130

00:05:49.720  -->  00:05:50.970
we change it to a string,
131

131

00:05:52.800  -->  00:05:54.400
we suddenly get a compile error.
132

132

00:05:56.310  -->  00:05:59.750
So the literal value integer can be autoboxed to an integer,
133

133

00:05:59.750  -->  00:06:01.010
a child of object.
134

134

00:06:01.010  -->  00:06:03.357
But an integer operand and a string operand,
135

135

00:06:03.357  -->  00:06:05.720
cannot return a result to a string.
136

136

00:06:05.720  -->  00:06:08.120
That's because integer is not a child of string.
137

137

00:06:09.213  -->  00:06:12.120
I can undo that changing I back to an object again.
138

138

00:06:12.120  -->  00:06:16.750
The code is now compatible run up in the code works.
139

139

00:06:16.750  -->  00:06:17.823
But so finally now,
140

140

00:06:19.070  -->  00:06:20.625
the thing to know about the ternary operator
141

141

00:06:20.625  -->  00:06:21.458
is that only one of the two operands,
142

142

00:06:22.452  -->  00:06:25.100
operand two or operand three will get evaluated
143

143

00:06:25.100  -->  00:06:28.030
if they are an expression or a method call,
144

144

00:06:28.030  -->  00:06:29.163
or show the code.
145

145

00:06:31.150  -->  00:06:34.843
So if we start by changing the argument to 10, again,
146

146

00:06:37.800  -->  00:06:38.633
run the code.
147

147

00:06:42.290  -->  00:06:44.060
Here it's demonstrating that the x variable
148

148

00:06:44.060  -->  00:06:46.620
was incremented in the operand two expression,
149

149

00:06:46.620  -->  00:06:49.640
but the y variable remained unchanged.
150

150

00:06:49.640  -->  00:06:51.330
It was that what you're expected?
151

151

00:06:51.330  -->  00:06:52.810
You can see that the result
152

152

00:06:52.810  -->  00:06:54.510
because we passed the main method the argument
153

153

00:06:54.510  -->  00:06:57.300
was looking for was assigned x before X was incremented,
154

154

00:06:57.300  -->  00:06:59.430
but y never got incremented at all.
155

155

00:06:59.430  -->  00:07:02.320
And this is because the ternary operator will execute,
156

156

00:07:02.320  -->  00:07:04.453
one of the other operands but not both.
157

157

00:07:05.310  -->  00:07:08.800
Another way to test this is to change the operands status.
158

158

00:07:08.800  -->  00:07:11.700
That's remove the arguments altogether, programme arguments.
159

159

00:07:13.360  -->  00:07:14.310
Run the code again,
160

160

00:07:16.720  -->  00:07:18.110
You see that x was not incremented,
161

161

00:07:18.110  -->  00:07:20.160
but y was as shown below.
162

162

00:07:20.160  -->  00:07:22.560
Alright, so we've covered all the operators here.
163

163

00:07:22.560  -->  00:07:24.140
And as we move forward in the course,
164

164

00:07:24.140  -->  00:07:25.610
you'll be continually exposed to them
165

165

00:07:25.610  -->  00:07:27.570
in our sample code as well.
166

166

00:07:27.570  -->  00:07:29.290 line:15% 
So at this stage now we're going to start looking
167

167

00:07:29.290  -->  00:07:31.410 line:15% 
at some of the more unusual constructs
168

168

00:07:31.410  -->  00:07:33.210 line:15% 
and we'll do that in the next video.
