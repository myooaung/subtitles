WEBVTT
ï»¿1
00:00:00.000 --> 00:00:00.270
Hey,

2
00:00:00.270 --> 00:00:00.600
guys,

3
00:00:00.600 --> 00:00:02.410
welcome backs in this video,

4
00:00:02.410 --> 00:00:08.570
we're going to discuss the different variable data types in xlv B A.

5
00:00:08.570 --> 00:00:14.300
So variables in XlV be a have different data types.

6
00:00:14.300 --> 00:00:23.950
And if you think of variables as containers or buckets that contain data on this data is

7
00:00:23.950 --> 00:00:25.400
stored in memory.

8
00:00:25.400 --> 00:00:34.380
These containers or buckets number one can hold different types of data so each bucket type

9
00:00:34.380 --> 00:00:38.710
or container type can hold a certain data type,

10
00:00:38.710 --> 00:00:41.960
and it cannot hold other data types.

11
00:00:41.960 --> 00:00:43.010
That's number one.

12
00:00:43.010 --> 00:00:48.350
Number two is that because they hold different data types,

13
00:00:48.350 --> 00:00:56.290
they will have different sizes because different data types can occupy different sizes.

14
00:00:56.290 --> 00:00:58.490
So they have two main aspects.

15
00:00:58.490 --> 00:01:01.610
They can hold different data types,

16
00:01:01.610 --> 00:01:05.770
and they will have different sizes.

17
00:01:05.770 --> 00:01:07.260
Now.

18
00:01:07.260 --> 00:01:15.420
The reason we're learning about the data types in XlV B A for variables is that because

19
00:01:15.420 --> 00:01:21.250
thes variables occupy a size in the memory of your computer,

20
00:01:21.250 --> 00:01:29.330
it is a better practice to select the appropriate data type for each variable.

21
00:01:29.330 --> 00:01:37.290
So that means that it is a better practice to select a data type that can just accommodate

22
00:01:37.290 --> 00:01:40.120
the data that you're gonna put in your variable,

23
00:01:40.120 --> 00:01:45.430
and you would not select a data type that is overly big.

24
00:01:45.430 --> 00:01:53.300
So it is a better practice to just select a size that just fits your data as long as it can

25
00:01:53.300 --> 00:01:57.380
accommodate its size at all the points in your procedures.

26
00:01:57.380 --> 00:01:58.190
OK,

27
00:01:58.190 --> 00:02:03.250
so as long as if the size of your data shrinks or expands,

28
00:02:03.250 --> 00:02:05.190
it can accommodate it.

29
00:02:05.190 --> 00:02:12.300
Fists makes for better efficiency when your program or where your macro is running.

30
00:02:12.300 --> 00:02:19.240
So it makes sure that it won smoother a runs in the shortest amount of time possible.

31
00:02:19.240 --> 00:02:26.350
And although these differences do not appear in small procedures in Small micro's,

32
00:02:26.350 --> 00:02:30.620
they do appear in Big Mac Rose.

33
00:02:30.620 --> 00:02:31.140
Okay,

34
00:02:31.140 --> 00:02:37.150
so it is a better practice in general to declare a variable that can just suit your data

35
00:02:37.150 --> 00:02:38.880
type that is not overly big.

36
00:02:38.880 --> 00:02:41.250
And it's also not smaller,

37
00:02:41.250 --> 00:02:45.820
then the data type that you're gonna accommodate in your variable.

38
00:02:45.820 --> 00:02:46.500
Okay,

39
00:02:46.500 --> 00:02:47.130
so let's see,

40
00:02:47.130 --> 00:02:50.680
what are the different data types that we have in XlV?

41
00:02:50.680 --> 00:02:52.260
Be a first of all.

42
00:02:52.260 --> 00:02:54.490
We've got the bite data type,

43
00:02:54.490 --> 00:02:58.690
and this bite data type has a storage size of one bite.

44
00:02:58.690 --> 00:03:05.740
And that means that it occupies only one bite in memory of your computer and it's olive oil

45
00:03:05.740 --> 00:03:08.450
ranges between zero and 255.

46
00:03:08.450 --> 00:03:16.120
So that means that you can put numbers between zero and 255 in that data type.

47
00:03:16.120 --> 00:03:20.230
So if you put 256 for example,

48
00:03:20.230 --> 00:03:22.260
then you're going to get an error.

49
00:03:22.260 --> 00:03:26.420
There is also the Boolean data type,

50
00:03:26.420 --> 00:03:33.600
and the bullion data type occupies two bites in your memory in your computer's memory.

51
00:03:33.600 --> 00:03:36.050
That's its storage size,

52
00:03:36.050 --> 00:03:41.510
and it can only hold either true or false values.

53
00:03:41.510 --> 00:03:41.890
OK,

54
00:03:41.890 --> 00:03:43.800
so it cannot think any other values.

55
00:03:43.800 --> 00:03:47.440
It cannot take five or six and two of force.

56
00:03:47.440 --> 00:03:48.110
By the way,

57
00:03:48.110 --> 00:03:50.980
they can be one and zero.

58
00:03:50.980 --> 00:03:53.680
So one is a true and zero is a false.

59
00:03:53.680 --> 00:03:57.120
It cannot take any other values it cannot take Johnny.

60
00:03:57.120 --> 00:03:59.420
You cannot take five okay,

61
00:03:59.420 --> 00:04:01.820
so can only take true or false values.

62
00:04:01.820 --> 00:04:04.830
There is also the integer data type,

63
00:04:04.830 --> 00:04:11.670
which can Onley hold integers and it occupies two bites in your computer's memory.

64
00:04:11.670 --> 00:04:14.270
So that is its storage size,

65
00:04:14.270 --> 00:04:26.430
and it can accept values between negative 32,768 to positive 32,700 67 so if you try to put

66
00:04:26.430 --> 00:04:29.240
a value days outside the range of values.

67
00:04:29.240 --> 00:04:29.380
So,

68
00:04:29.380 --> 00:04:30.230
for example,

69
00:04:30.230 --> 00:04:33.620
33,000 you will get an error,

70
00:04:33.620 --> 00:04:37.090
and if you try to put a decimal value in it,

71
00:04:37.090 --> 00:04:40.020
the value will be rounded up or down,

72
00:04:40.020 --> 00:04:41.850
depending on the value.

73
00:04:41.850 --> 00:04:48.890
So if the number on the right hand side of the decimal point is between one and five,

74
00:04:48.890 --> 00:04:50.680
it will be rounded down.

75
00:04:50.680 --> 00:04:51.670
So,

76
00:04:51.670 --> 00:04:52.680
for example,

77
00:04:52.680 --> 00:04:57.490
if you give it a value between 1.0 and 1.5,

78
00:04:57.490 --> 00:04:59.870
it will be rounded down to a one.

79
00:04:59.870 --> 00:05:00.750
However,

80
00:05:00.750 --> 00:05:04.220
if the value is greater than 1.5,

81
00:05:04.220 --> 00:05:09.990
so even 1.51 or 1.6 it will be rounded up to two.

82
00:05:09.990 --> 00:05:12.850
So that's that interject data type.

83
00:05:12.850 --> 00:05:14.890
There's also the Long Data type,

84
00:05:14.890 --> 00:05:21.010
which occupies four bytes and its range of values between negative 2,000,000,147 million,

85
00:05:21.010 --> 00:05:24.890
483,648 and positive,

86
00:05:24.890 --> 00:05:27.190
two billion and all that long number.

87
00:05:27.190 --> 00:05:29.490
There's also the single data type,

88
00:05:29.490 --> 00:05:38.990
which occupies four bytes of memory and has a range of negative 3.4 by 10 to the power 38

89
00:05:38.990 --> 00:05:45.170
to negative 1.4 by TEMPTED the poor negative 45 for negative values and 1.4 by tens of poor

90
00:05:45.170 --> 00:05:45.500
negative.

91
00:05:45.500 --> 00:05:49.550
45 23.4 by tend to the poor.

92
00:05:49.550 --> 00:05:52.640
38 for positive values has a big range.

93
00:05:52.640 --> 00:05:55.250
That double as well occupies eight bites.

94
00:05:55.250 --> 00:05:59.900
Has this range negative 1.79 by tend to the poor.

95
00:05:59.900 --> 00:06:01.840
308 to negative.

96
00:06:01.840 --> 00:06:03.450
4.94 by tens of poor.

97
00:06:03.450 --> 00:06:05.190
Three negative,

98
00:06:05.190 --> 00:06:09.090
3 to 4 for negative values and 4.9 by temper.

99
00:06:09.090 --> 00:06:09.340
Poor.

100
00:06:09.340 --> 00:06:09.640
Negative.

101
00:06:09.640 --> 00:06:13.810
3 to 4 to 1.79 by terms of the poor.

102
00:06:13.810 --> 00:06:16.070
308 for positive values.

103
00:06:16.070 --> 00:06:18.800
And there's the currency as well.

104
00:06:18.800 --> 00:06:20.450
You can see its range here,

105
00:06:20.450 --> 00:06:25.880
and there's also the date which can only hold dates.

106
00:06:25.880 --> 00:06:26.470
Okay,

107
00:06:26.470 --> 00:06:27.940
so if you give it a string,

108
00:06:27.940 --> 00:06:29.030
it will fail.

109
00:06:29.030 --> 00:06:29.730
And a string.

110
00:06:29.730 --> 00:06:31.010
It means attacks.

111
00:06:31.010 --> 00:06:31.750
Basically,

112
00:06:31.750 --> 00:06:33.290
you will get an error.

113
00:06:33.290 --> 00:06:35.760
There's also the string data type,

114
00:06:35.760 --> 00:06:39.750
and you can either declare a fixed length string.

115
00:06:39.750 --> 00:06:40.840
Okay,

116
00:06:40.840 --> 00:06:42.310
and I'll tell you how to do that.

117
00:06:42.310 --> 00:06:45.050
And there's also the variable length string,

118
00:06:45.050 --> 00:06:51.440
and most in most of the cases we just declare a variable length string because it's not

119
00:06:51.440 --> 00:06:53.700
worth it to fix the length of the string.

120
00:06:53.700 --> 00:06:56.580
We normally just declare a variable length string,

121
00:06:56.580 --> 00:06:58.890
but it might show you how to do the fixed length.

122
00:06:58.890 --> 00:07:01.270
One is very simple just for ah,

123
00:07:01.270 --> 00:07:02.780
an extra bit of information,

124
00:07:02.780 --> 00:07:05.610
and there is also the variant data type,

125
00:07:05.610 --> 00:07:13.930
and this data type is basically assumed by excel if you do not declare your variable as

126
00:07:13.930 --> 00:07:15.790
being a certain data time.

127
00:07:15.790 --> 00:07:21.060
So if you just declare a variable where if you do not declare a variable at all,

128
00:07:21.060 --> 00:07:24.600
Excel will just give it the very indeed a type which,

129
00:07:24.600 --> 00:07:25.590
as you can see her,

130
00:07:25.590 --> 00:07:30.300
occupies the biggest amount of sighs in memory.

131
00:07:30.300 --> 00:07:31.960
16 bytes.

132
00:07:31.960 --> 00:07:39.210
And it is generally not a good practice to declare variant data types.

133
00:07:39.210 --> 00:07:45.100
You might see me just not declare the variables in this course,

134
00:07:45.100 --> 00:07:50.790
sometimes just to focus on the subject of the lesson that I'll be teaching you.

135
00:07:50.790 --> 00:07:55.940
But it's generally not a good practice to leave your variables as variant.

136
00:07:55.940 --> 00:07:57.520
It is a better practice,

137
00:07:57.520 --> 00:07:57.970
too.

138
00:07:57.970 --> 00:08:01.710
Declare your variables win a data type,

139
00:08:01.710 --> 00:08:08.400
and people would sometimes not declared the type of the variable if they do not know what

140
00:08:08.400 --> 00:08:09.930
is going to be put inside it,

141
00:08:09.930 --> 00:08:11.900
and there macro would still run.

142
00:08:11.900 --> 00:08:16.950
And probably this is the only exceptional case that you should do it.

143
00:08:16.950 --> 00:08:20.110
But it's generally a better practice,

144
00:08:20.110 --> 00:08:20.610
too.

145
00:08:20.610 --> 00:08:26.650
Specify the data type for the variable that you declare.

146
00:08:26.650 --> 00:08:29.540
Declaring variables is also debated.

147
00:08:29.540 --> 00:08:35.700
You will see debated on the Internet because some people do not believe in the need for

148
00:08:35.700 --> 00:08:39.760
declaring the data types for variables or declaring the variables.

149
00:08:39.760 --> 00:08:46.200
It'll and they're actually Excel geeks who actually do not declare variables such as,

150
00:08:46.200 --> 00:08:47.010
for example,

151
00:08:47.010 --> 00:08:49.190
Mr Excel or Bill Jelen.

152
00:08:49.190 --> 00:08:51.850
He does not believe in declaring variables,

153
00:08:51.850 --> 00:08:58.940
and declaring variables will not make a big difference when you write a small micro.

154
00:08:58.940 --> 00:09:03.340
But it does make a difference when you write a big macro with lots of variables and loss of

155
00:09:03.340 --> 00:09:04.700
stuff to be done in it.

156
00:09:04.700 --> 00:09:12.640
So it is generally a better practice to declare your variables and declare their data types

157
00:09:12.640 --> 00:09:12.640
,

158
00:09:12.640 --> 00:09:16.550
and we will see in the upcoming lesson how we conduce that.

159
00:09:16.550 --> 00:09:22.330
But this is just a introduction to data types in XlV B A.

160
00:09:22.330 --> 00:09:25.620
So thank you very much guys for watching this video,

161
00:09:25.620 --> 00:09:27.490
and I'll see on the next one

