WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:03.465
Discussed or at least and collection and generics, right?

00:00:03.465 --> 00:00:06.480
So now let's talk about what a exempting diamond object.

00:00:06.480 --> 00:00:09.705
And it has been introduced in Java 7.

00:00:09.705 --> 00:00:13.390
And after that, we're gonna talk about what is the announcement done.

00:00:14.450 --> 00:00:19.980
Okay, So I'm going to create an example here, new class here,

00:00:19.980 --> 00:00:27.225
like diamond operator example.

00:00:27.225 --> 00:00:31.810
And it has some element of so I'm creating a main method here.

00:00:32.360 --> 00:00:36.780
Okay, so let's look back at the slide.

00:00:36.780 --> 00:00:39.430
What we discussed already.

00:00:39.800 --> 00:00:48.680
This is a diamond operator which infer the type of generic, right?

00:00:48.680 --> 00:00:52.085
So the first one is list of string and string,

00:00:52.085 --> 00:00:54.305
either pro and what kind of data and passing.

00:00:54.305 --> 00:00:58.895
And I never really knew at the time against this kind of it, I'm using it.

00:00:58.895 --> 00:01:02.330
So I had to tell the compiler it is going to be

00:01:02.330 --> 00:01:06.890
a list of string and it is going to create a new release and it is going to be string.

00:01:06.890 --> 00:01:09.965
But in Java Man, we don't have to.

00:01:09.965 --> 00:01:12.095
Once you initialize a list, a list of the string.

00:01:12.095 --> 00:01:14.375
So outcome it has to be in this stuff a string.

00:01:14.375 --> 00:01:19.580
So it internally dual allows the compiler to infer the type of dendritic class.

00:01:19.580 --> 00:01:22.835
It's good, a simple example and we'll just take it out.

00:01:22.835 --> 00:01:30.670
So for now what I'm gonna do list of string and i 1 is 6 o'clock.

00:01:30.670 --> 00:01:33.880
Let me import a list first.

00:01:33.880 --> 00:01:42.560
And here are a list of string.

00:01:42.690 --> 00:01:50.815
So I need to input list and as well as the ArrayList.

00:01:50.815 --> 00:01:52.660
So this cell we use flew,

00:01:52.660 --> 00:01:55.190
it is before Java 7.

00:01:57.300 --> 00:01:59.950
By the end, java 7, however,

00:01:59.950 --> 00:02:01.240
when you do this,

00:02:01.240 --> 00:02:03.010
pretty much the same thing.

00:02:03.010 --> 00:02:07.730
But this is not necessary.

00:02:08.410 --> 00:02:16.145
Because as internally infer the genotype do this type.

00:02:16.145 --> 00:02:21.290
So this is in Java 7.

00:02:21.290 --> 00:02:23.210
This is pretty simple, right?

00:02:23.210 --> 00:02:28.190
So that is the first reason the diamond operator has been introduced.

00:02:28.190 --> 00:02:32.255
But what does enhancement has been done in Germany.

00:02:32.255 --> 00:02:36.770
So I don't do anything here,

00:02:36.770 --> 00:02:38.600
but what do they exactly is

00:02:38.600 --> 00:02:44.180
an unordered nutrient is comes in because the ArrayList diamond operator,

00:02:44.180 --> 00:02:48.420
it was not supported by any narrow glasses.

00:02:48.940 --> 00:02:54.365
So you can only use Edmodo pattern classes like list, ArrayList, gender.

00:02:54.365 --> 00:02:58.490
But when you're writing your own classes, cannot create them.

00:02:58.490 --> 00:03:00.740
So that is what we discussed in the next slide.

00:03:00.740 --> 00:03:02.540
Let me take the next flight.

00:03:02.540 --> 00:03:05.870
It can be used, you're done NMS class anonymous classmates.

00:03:05.870 --> 00:03:11.645
You can write a simple list and inside the list we can create anonymous class.

00:03:11.645 --> 00:03:15.335
Let's make some little gold and inclusivity with DAG and show you the example.

00:03:15.335 --> 00:03:17.030
So which you can understand.

00:03:17.030 --> 00:03:18.770
What I'm trying to say.

00:03:18.770 --> 00:03:22.640
For example, what I'm gonna do is, let's leave this aside.

00:03:22.640 --> 00:03:25.490
I'm going to create a simple list of string.

00:03:25.490 --> 00:03:29.345
And I'll show you what exactly means.

00:03:29.345 --> 00:03:31.370
So for example, I have a list of string,

00:03:31.370 --> 00:03:33.995
okay, So here, l1, right?

00:03:33.995 --> 00:03:37.740
So let me recreate the same thing here.

00:03:38.410 --> 00:03:42.140
So as I said, we can create an anonymous inner class, right?

00:03:42.140 --> 00:03:45.270
So aligning three.

00:03:48.010 --> 00:03:56.350
So now we can create an anonymous block inside a lightly now we can make it or not,

00:03:56.350 --> 00:03:59.300
it was not possible in Java 7,

00:03:59.300 --> 00:04:00.890
8 worth individual Jeremy.

00:04:00.890 --> 00:04:02.540
So here what you can do,

00:04:02.540 --> 00:04:07.550
it can override the metals in the list. For example.

00:04:07.550 --> 00:04:10.160
Hello mainly meant that Intel illustrate for

00:04:10.160 --> 00:04:12.845
checking a size or get out something like that.

00:04:12.845 --> 00:04:14.750
So we can actually overlay them.

00:04:14.750 --> 00:04:17.030
And us, for example, I'm going to,

00:04:17.030 --> 00:04:19.535
I'm going to see what is there in the list.

00:04:19.535 --> 00:04:23.495
So I'm going to look for a method call length or size.

00:04:23.495 --> 00:04:26.465
Say I'm going to override does size matter?

00:04:26.465 --> 00:04:28.445
You can probably your own implementation.

00:04:28.445 --> 00:04:29.270
It is just a sample.

00:04:29.270 --> 00:04:32.075
But the next example we're gonna talk about a real example.

00:04:32.075 --> 00:04:37.055
So what I'm gonna do is here and where you override the method.

00:04:37.055 --> 00:04:40.820
So go to source and then you can override implement methods.

00:04:40.820 --> 00:04:42.830
So under the ArrayList,

00:04:42.830 --> 00:04:46.955
you gonna overwrite the size method.

00:04:46.955 --> 00:04:49.790
Okay, let's do that. Okay?

00:04:49.790 --> 00:04:53.015
So we all know that what size is going to do.

00:04:53.015 --> 00:04:56.885
It is when needed and the size of the array, size of the list.

00:04:56.885 --> 00:04:58.880
So I'm doing something crazy,

00:04:58.880 --> 00:05:04.190
which will always happen when you're passing. It, always it.

00:05:04.190 --> 00:05:07.460
And I'm what I'm trying to show you is that, you know,

00:05:07.460 --> 00:05:11.630
you have the option to overwrite the existing implementation. So what I wanna do this?

00:05:11.630 --> 00:05:17.240
Well, since we're going

00:05:17.240 --> 00:05:23.040
to print that size.

00:05:23.470 --> 00:05:26.075
So what will happen?

00:05:26.075 --> 00:05:29.210
Because I let it doesn't have any elements in it.

00:05:29.210 --> 00:05:30.665
We haven't added anything into it.

00:05:30.665 --> 00:05:32.165
It's supposed to return a 0,

00:05:32.165 --> 00:05:35.930
but just run it and you'll see it written.

00:05:35.930 --> 00:05:38.600
Then how come it is possible because I just read

00:05:38.600 --> 00:05:42.725
the matter is in the morphinan class. Right?

00:05:42.725 --> 00:05:49.475
So we can do the same thing with your one class and I'm going to add a new class.

00:05:49.475 --> 00:05:51.800
And I'm going to make some on my tabs.

00:05:51.800 --> 00:05:55.655
And we're going to go right down with the help of diamond operator.

00:05:55.655 --> 00:05:57.780
To that.
