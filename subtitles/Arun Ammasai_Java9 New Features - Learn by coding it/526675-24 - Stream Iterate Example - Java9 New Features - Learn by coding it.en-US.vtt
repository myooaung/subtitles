WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.670
Hello everyone. Welcome back.

00:00:02.670 --> 00:00:05.370
So we know how the takeaway is working.

00:00:05.370 --> 00:00:08.955
Now we need to talk about drop while.

00:00:08.955 --> 00:00:11.860
So what is drop while it is,

00:00:13.280 --> 00:00:17.880
it is works like TakeWhile,

00:00:17.880 --> 00:00:28.690
like TakeWhile, opposite to that.

00:00:29.540 --> 00:00:33.194
So what does it mean? So a TakeWhile,

00:00:33.194 --> 00:00:39.240
which will print the data or to process the data until the predication is true.

00:00:39.240 --> 00:00:42.110
But drop while it will check all look,

00:00:42.110 --> 00:00:43.970
it will go one by one.

00:00:43.970 --> 00:00:46.520
Once the condition is false,

00:00:46.520 --> 00:00:48.995
it will pretend the rest of the elements,

00:00:48.995 --> 00:00:51.035
not the previous element.

00:00:51.035 --> 00:00:53.870
So like in this example, 2,

00:00:53.870 --> 00:00:57.020
4, 6, 8, 9, and 10, 11, 12, right?

00:00:57.020 --> 00:00:59.780
So our condition is checking the even numbers.

00:00:59.780 --> 00:01:02.900
So 2, 4, 6, 8 up to here it is a true,

00:01:02.900 --> 00:01:06.725
but in this particular location, it is getting files.

00:01:06.725 --> 00:01:09.020
So basically drop while it will drop

00:01:09.020 --> 00:01:14.040
these elements and it will print the rest of the data.

00:01:14.380 --> 00:01:17.360
Okay, let me show you that.

00:01:17.360 --> 00:01:19.850
So what I'm gonna do is I'm going to comment this one also.

00:01:19.850 --> 00:01:23.580
Let me copy this so I can make a small change.

00:01:25.500 --> 00:01:27.550
It may come on this,

00:01:27.550 --> 00:01:32.560
so okay, let me print it now.

00:01:32.560 --> 00:01:34.675
So instead of TakeWhile,

00:01:34.675 --> 00:01:36.085
I'm going to use a drop wise.

00:01:36.085 --> 00:01:42.850
So we know that how the profile is going to drop the elements before the true condition.

00:01:42.850 --> 00:01:45.085
So it will return the rest of the elements.

00:01:45.085 --> 00:01:49.450
So let's run it. See now we have 9101112.

00:01:49.450 --> 00:01:54.010
Oh, they displace the condition getting files and so it is written rest of the data.

00:01:54.010 --> 00:01:57.070
It one process, whatever the data is becoming.

00:01:57.070 --> 00:01:59.800
The next element. Once it is false,

00:01:59.800 --> 00:02:02.890
it will return everything. Right?

00:02:02.890 --> 00:02:05.320
Okay, So this is the most important thing about that.

00:02:05.320 --> 00:02:09.175
Take while and drop while, right?

00:02:09.175 --> 00:02:11.770
So what are the things which are going to talk about?

00:02:11.770 --> 00:02:16.930
So stream dot-dot-dot E-Trade and there's something called stream dot nullable.

00:02:16.930 --> 00:02:18.625
So what is streamed at item a,

00:02:18.625 --> 00:02:26.260
it will create infinite data.

00:02:26.260 --> 00:02:29.080
So when you create a stream that I taught,

00:02:29.080 --> 00:02:33.010
basically it will do it will create a data in a infinite loop.

00:02:33.010 --> 00:02:37.105
But you can limit the data with the help of some methods.

00:02:37.105 --> 00:02:40.075
Let me tell you how the stream dot i2, i2 and walk.

00:02:40.075 --> 00:02:43.345
And then we'll move on to how

00:02:43.345 --> 00:02:48.025
we'll put a condition into a limit and how it has been unanswered into Java nine.

00:02:48.025 --> 00:02:50.775
The first thing we'll talk about how it is looking in Java 8.

00:02:50.775 --> 00:02:53.495
Okay, So let me create a new example here.

00:02:53.495 --> 00:03:00.780
New class stream, I iterate example.

00:03:00.910 --> 00:03:03.215
Let's have a main method in it.

00:03:03.215 --> 00:03:04.565
Finish.

00:03:04.565 --> 00:03:08.090
Okay, So now we have matter in place.

00:03:08.090 --> 00:03:09.995
Let's start implementing it.

00:03:09.995 --> 00:03:12.290
So how the stream a look?

00:03:12.290 --> 00:03:14.360
So let's open a creative stream.

00:03:14.360 --> 00:03:19.520
And I'm going to create a stream of integer, right?

00:03:19.520 --> 00:03:24.800
And I'm going to call the message stream S1 and import the stream.

00:03:24.800 --> 00:03:28.115
And then I'm going to use the stream dot I trade my thought.

00:03:28.115 --> 00:03:29.780
Here is a difference.

00:03:29.780 --> 00:03:32.915
The first matter which is introduced as part of Java 8,

00:03:32.915 --> 00:03:36.440
how one seed and one unary operator.

00:03:36.440 --> 00:03:41.360
But DR1 and it has seed and a predicate and the unitary operator.

00:03:41.360 --> 00:03:43.220
Okay, so basically what is the difference?

00:03:43.220 --> 00:03:44.540
So because Java 8,

00:03:44.540 --> 00:03:51.200
we don't have a condition to check if this condition is false, break it, right?

00:03:51.200 --> 00:03:53.915
But in Java 9 model,

00:03:53.915 --> 00:03:57.410
we do have a privilege to do that.

00:03:57.410 --> 00:04:00.320
Let's see, Let's talk about the Java 8 version.

00:04:00.320 --> 00:04:02.165
So I'm going to use our AT I iterate.

00:04:02.165 --> 00:04:04.160
The initial Alice is going to be 0.

00:04:04.160 --> 00:04:06.695
And I'm going to perform an add operation.

00:04:06.695 --> 00:04:07.700
Right?

00:04:07.700 --> 00:04:10.280
Like I'm getting a data here and I'm going to

00:04:10.280 --> 00:04:15.680
add x plus 1 every time I'm adding one into the data.

00:04:15.680 --> 00:04:16.835
That's all.

00:04:16.835 --> 00:04:19.415
So basically what happen if I run this code?

00:04:19.415 --> 00:04:22.200
The data will learn infinite.

00:04:23.230 --> 00:04:25.985
So it will not stop.

00:04:25.985 --> 00:04:27.890
Okay, so I'm going to print it right?

00:04:27.890 --> 00:04:33.785
So S1 chart for h,

00:04:33.785 --> 00:04:37.680
and then let's print the data System.out.

00:04:37.750 --> 00:04:41.030
And I'm going to use a print LN.

00:04:41.030 --> 00:04:44.510
So let's run it. This program will not stop,

00:04:44.510 --> 00:04:47.570
it will keep going because I don't have any condition to limit

00:04:47.570 --> 00:04:52.745
the loop because it's a infinite plus this.

00:04:52.745 --> 00:04:54.335
So how we can limit it.

00:04:54.335 --> 00:05:01.460
So we can use the dot limit, mitre dot limit.

00:05:01.460 --> 00:05:04.099
So I want to raise it only the 10 elements.

00:05:04.099 --> 00:05:05.390
Now we can run it.

00:05:05.390 --> 00:05:07.790
We should be able to see only the elements up to 10.

00:05:07.790 --> 00:05:10.985
So there are 29. Got it.

00:05:10.985 --> 00:05:15.440
So this is a simple example in stream dot-dot-dot eight.

00:05:15.440 --> 00:05:16.610
So basically what is happening,

00:05:16.610 --> 00:05:19.775
it is a seed value and this is a function, and here it is.

00:05:19.775 --> 00:05:21.140
It is not exactly a function.

00:05:21.140 --> 00:05:23.780
It is a unitary operator which will attend,

00:05:23.780 --> 00:05:28.580
takes as input it and the same type as an input, sorry, output, right?

00:05:28.580 --> 00:05:31.880
So if you want to know how it is going to work,

00:05:31.880 --> 00:05:35.790
we can, let me show you a small example in a real operator.

00:05:37.500 --> 00:05:40.375
So this is an example of a unary operator.

00:05:40.375 --> 00:05:42.550
So unity operator takes a single input

00:05:42.550 --> 00:05:47.050
as the input parameters and it returns the same type of data.

00:05:47.050 --> 00:05:48.730
It's taking string as input.

00:05:48.730 --> 00:05:53.110
It is taking the string as output.

00:05:53.110 --> 00:05:55.330
We can use the same thing in our code also,

00:05:55.330 --> 00:05:56.770
like how I did here.

00:05:56.770 --> 00:06:00.055
Okay, let me create a unitary operator here, which will then,

00:06:00.055 --> 00:06:04.435
yeah, it takes an integer and it returns an integer,

00:06:04.435 --> 00:06:06.250
I'm going to use an a plus one.

00:06:06.250 --> 00:06:08.545
So what I can do simply,

00:06:08.545 --> 00:06:12.940
instead of this, I can directly use the e.

00:06:12.940 --> 00:06:15.265
So it's pretty much the same thing.

00:06:15.265 --> 00:06:17.935
There is not much difference, okay?

00:06:17.935 --> 00:06:20.500
So, but here in Java nine,

00:06:20.500 --> 00:06:22.000
we have our eligibility.

00:06:22.000 --> 00:06:29.620
In case if you want to check some condition to break that infinite loop, we can do that.

00:06:29.620 --> 00:06:31.495
We don't have to use the limit.

00:06:31.495 --> 00:06:34.760
So under the condition is false, it'll break it.

00:06:35.340 --> 00:06:38.560
Right? Let's see how we are going to do that.

00:06:38.560 --> 00:06:40.825
I'm going to use the same thing here.

00:06:40.825 --> 00:06:46.555
So just copy paste and create a new variable.

00:06:46.555 --> 00:06:48.490
So it should be particular to see.

00:06:48.490 --> 00:06:52.600
So I'm going to call them as a stream to stream dot.

00:06:52.600 --> 00:06:54.865
I treat zeros a seed value,

00:06:54.865 --> 00:06:58.270
and this is the unity operator which will return the next value.

00:06:58.270 --> 00:07:00.885
So in-between I'm going to use the predicate.

00:07:00.885 --> 00:07:03.080
Okay, So one of the predicate here.

00:07:03.080 --> 00:07:11.165
So I will check only print the data if it is less than or equal to three, right?

00:07:11.165 --> 00:07:12.950
So I'm going to create a connection here.

00:07:12.950 --> 00:07:15.740
X is a predicate, okay?

00:07:15.740 --> 00:07:20.795
X less than 3 or less than or equal to trade surplus.

00:07:20.795 --> 00:07:23.090
So now what will happen? I don't have the,

00:07:23.090 --> 00:07:25.490
I have a limit condition up to ten.

00:07:25.490 --> 00:07:28.100
So it will check whether the data is less than or

00:07:28.100 --> 00:07:31.100
equal to three then at reprint or else it will not.

00:07:31.100 --> 00:07:33.755
So let's copy that data and paste it here.

00:07:33.755 --> 00:07:34.805
Just name the various,

00:07:34.805 --> 00:07:36.170
I mean changed every limb.

00:07:36.170 --> 00:07:38.840
For now I'm going to comment this one out to

00:07:38.840 --> 00:07:42.560
see the clear output here. Just run it again.

00:07:42.560 --> 00:07:45.785
So now we've got 0123.

00:07:45.785 --> 00:07:48.900
So what will happen if you remove the limit here?

00:07:51.550 --> 00:07:54.380
Since till we got the same output.

00:07:54.380 --> 00:07:59.450
The reason is it is a kind of a limiting your stream.

00:07:59.450 --> 00:08:00.050
Okay?

00:08:00.050 --> 00:08:03.455
So that whatever the limit is doing, it, it will,

00:08:03.455 --> 00:08:06.395
it will process the data up to this limit,

00:08:06.395 --> 00:08:08.165
but it won't check any condition.

00:08:08.165 --> 00:08:11.400
But now in Java and then we can do that.

00:08:11.470 --> 00:08:15.950
So that is an important thing about this particular method.

00:08:15.950 --> 00:08:19.565
And that is another matter which is nothing but Java dot off nullable.

00:08:19.565 --> 00:08:22.140
And we'll talk about in the next video.
