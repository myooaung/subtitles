1
00:00:01,040 --> 00:00:03,650
[Autogenerated] when you need to understand what's happening with the

2
00:00:03,650 --> 00:00:06,490
messages in your spring integration application,

3
00:00:06,490 --> 00:00:10,050
you want to be able to inspect messages that passed through the

4
00:00:10,050 --> 00:00:13,840
channels at certain points in the integration flow.

5
00:00:13,840 --> 00:00:18,520
The wiretap and message store patterns will help you do that In

6
00:00:18,520 --> 00:00:20,850
the Enterprise Integration Patterns book.

7
00:00:20,850 --> 00:00:26,440
Each pattern is introduced by stating a question that the pattern answers.

8
00:00:26,440 --> 00:00:30,540
The question for the wiretap pattern is the following.

9
00:00:30,540 --> 00:00:35,640
How do you inspect messages that travel on a point to point channel?

10
00:00:35,640 --> 00:00:39,030
Inspecting messages on the publish Subscribed channel is no

11
00:00:39,030 --> 00:00:42,340
difficult because the published subscribed channel delivers

12
00:00:42,340 --> 00:00:46,540
messages that are sent to it to multiple receivers,

13
00:00:46,540 --> 00:00:49,940
so you could just add another receiver to the channel That,

14
00:00:49,940 --> 00:00:54,740
for example, writes the content of messages to the debug blog.

15
00:00:54,740 --> 00:00:55,710
This is, however,

16
00:00:55,710 --> 00:00:58,940
not so easy for a point to point channel because they

17
00:00:58,940 --> 00:01:02,640
delivers messages only to a single receiver.

18
00:01:02,640 --> 00:01:06,660
A wiretap enables you to listen in on the messages that are passing

19
00:01:06,660 --> 00:01:10,520
through a point to point channel in spring integration.

20
00:01:10,520 --> 00:01:14,930
This is implemented as a channel interceptor on the point to

21
00:01:14,930 --> 00:01:16,640
point channel that you want to monitor.

22
00:01:16,640 --> 00:01:20,000
You can configure a wiretap that will send copies off

23
00:01:20,000 --> 00:01:22,410
the messages to Secondary Channel,

24
00:01:22,410 --> 00:01:26,090
where you can process them further in the demo that

25
00:01:26,090 --> 00:01:30,640
we're going to work within a minute, you'll see how this works in practice.

26
00:01:30,640 --> 00:01:33,820
One thing you can do and you want to inspect messages is to

27
00:01:33,820 --> 00:01:36,510
write a content of messages to the debug blog,

28
00:01:36,510 --> 00:01:38,140
as I mentioned.

29
00:01:38,140 --> 00:01:40,970
But sometimes it will be more convenient if you can

30
00:01:40,970 --> 00:01:43,020
store the messages in the database,

31
00:01:43,020 --> 00:01:47,240
especially if you're dealing with large numbers off messages.

32
00:01:47,240 --> 00:01:52,040
You can then use distort messages for analytics and reporting

33
00:01:52,040 --> 00:01:55,360
the Enterprise Integration Patterns Book describes the message

34
00:01:55,360 --> 00:01:57,080
store pennant for this purpose,

35
00:01:57,080 --> 00:02:01,640
and that's how we're going to use it in our upcoming demo as well.

36
00:02:01,640 --> 00:02:05,230
The question that the enterprise integration patterns book poses

37
00:02:05,230 --> 00:02:09,610
for the message store pattern is how do we report against message

38
00:02:09,610 --> 00:02:13,600
information without disturbing the loosely coupled and transient

39
00:02:13,600 --> 00:02:16,640
nature off a messaging system?

40
00:02:16,640 --> 00:02:20,420
But Spring Integration uses the idea off storing messages in

41
00:02:20,420 --> 00:02:26,440
a database for a more general purpose, not just for debugging or analytics.

42
00:02:26,440 --> 00:02:29,500
There are a number of spring integration components that

43
00:02:29,500 --> 00:02:32,740
have the ability to buffer messages.

44
00:02:32,740 --> 00:02:33,750
For example,

45
00:02:33,750 --> 00:02:38,270
Possible channels such as cute channel need to keep messages in a queue

46
00:02:38,270 --> 00:02:42,740
until the receiver makes a received goal by default.

47
00:02:42,740 --> 00:02:47,340
These components keep the messages in non persistent memory.

48
00:02:47,340 --> 00:02:49,140
When the application is stopped,

49
00:02:49,140 --> 00:02:53,470
the messages are lost by configuring a message store on

50
00:02:53,470 --> 00:02:55,790
a component that buffers messages.

51
00:02:55,790 --> 00:02:59,340
You can have its store messages persistently.

52
00:02:59,340 --> 00:03:02,900
Spring integration provides a number off different message story

53
00:03:02,900 --> 00:03:07,340
implementations for storing messages in a relational database using J.

54
00:03:07,340 --> 00:03:07,470
D.

55
00:03:07,470 --> 00:03:08,230
B C.

56
00:03:08,230 --> 00:03:13,640
And for storing messages in mongo DB reddish or gem fire.

57
00:03:13,640 --> 00:03:14,370
Finally,

58
00:03:14,370 --> 00:03:17,760
I have to note that there are some limitations that you have to be aware

59
00:03:17,760 --> 00:03:21,140
off when you are using a persistent message store.

60
00:03:21,140 --> 00:03:24,870
When messages are stored into a persistent message store,

61
00:03:24,870 --> 00:03:27,920
they have to be serialized into whatever form is

62
00:03:27,920 --> 00:03:30,740
necessary for the message store you're using.

63
00:03:30,740 --> 00:03:34,240
And these, she realized when they are retrieved again.

64
00:03:34,240 --> 00:03:35,450
That will only work.

65
00:03:35,450 --> 00:03:39,410
If the Henderson payload of the messages only contain objects that

66
00:03:39,410 --> 00:03:43,140
can be serialized and deserialize correctly,

67
00:03:43,140 --> 00:03:46,710
you might need to convert values before storing them,

68
00:03:46,710 --> 00:03:54,000
and after retrieving them from a message store, we will encounter audition the demo as well

