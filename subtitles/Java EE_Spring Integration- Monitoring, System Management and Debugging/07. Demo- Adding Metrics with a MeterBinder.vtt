WEBVTT
1
00:00:01.040 --> 00:00:04.760
[Autogenerated] we've added a counter and a timer by injecting the meter

2
00:00:04.760 --> 00:00:08.940
registry into the registration service and using it there.

3
00:00:08.940 --> 00:00:14.340
Another way to add meters to the application is by using a meter binder.

4
00:00:14.340 --> 00:00:16.930
Let's use a meter binder to add a gauge,

5
00:00:16.930 --> 00:00:20.270
which is, as I mentioned, the third main type of meter.

6
00:00:20.270 --> 00:00:23.040
Besides counters and timers,

7
00:00:23.040 --> 00:00:28.140
let's add a gauge that returns the current number of tickets in the database.

8
00:00:28.140 --> 00:00:30.280
We'll add another being to class.

9
00:00:30.280 --> 00:00:35.440
Globomantics serves application named Ticket Count Media Binder.

10
00:00:35.440 --> 00:00:39.350
This method will return the media binder interface.

11
00:00:39.350 --> 00:00:45.140
Meter Binder defines a single method named Bind to That we have to implement,

12
00:00:45.140 --> 00:00:48.940
just like in the previous example, with me to registry customize er,

13
00:00:48.940 --> 00:00:53.240
we can, of course, implemented using a Lambda expression.

14
00:00:53.240 --> 00:00:56.510
The Lambda expression gets past the meter registry

15
00:00:56.510 --> 00:01:00.940
and in the body of the Lambda, we can now use it to define meters.

16
00:01:00.940 --> 00:01:03.440
Let's create a gauge here.

17
00:01:03.440 --> 00:01:08.440
A gauge is a very simple meter that just holds the current value.

18
00:01:08.440 --> 00:01:11.600
A real world example of gauge would, for example,

19
00:01:11.600 --> 00:01:12.700
be a thermo meter,

20
00:01:12.700 --> 00:01:17.240
which indicates the current temperature creating a gauge is done

21
00:01:17.240 --> 00:01:19.870
in the same way as creating a counter or timer.

22
00:01:19.870 --> 00:01:24.140
By calling one off the gauge methods off the meter registry,

23
00:01:24.140 --> 00:01:27.350
we have to pass three arguments to the gauge method

24
00:01:27.350 --> 00:01:30.290
that I intend to use here first.

25
00:01:30.290 --> 00:01:32.240
The name of the gauge.

26
00:01:32.240 --> 00:01:36.840
Let's call it Globomantics start registration or tickets.

27
00:01:36.840 --> 00:01:40.680
The next arguments are state object and the function that

28
00:01:40.680 --> 00:01:44.540
calculates the current value from the state object.

29
00:01:44.540 --> 00:01:48.830
The state object can be any object you like and depends on what you need

30
00:01:48.830 --> 00:01:52.240
for the function that calculates the current value.

31
00:01:52.240 --> 00:01:55.960
In this case, we want to count the number off tickets in the database.

32
00:01:55.960 --> 00:02:01.040
So inappropriate object to use is the antennae ticket repository.

33
00:02:01.040 --> 00:02:04.780
Let's inject it into the ticket count meter by the method so that we

34
00:02:04.780 --> 00:02:08.740
can pass it to the gauge method as the state object.

35
00:02:08.740 --> 00:02:13.440
Next is the function that calculates the current value off the gauge.

36
00:02:13.440 --> 00:02:15.070
This method gets passed.

37
00:02:15.070 --> 00:02:18.990
The state object we can write it as a lambda here that

38
00:02:18.990 --> 00:02:21.330
takes the state object as an argument,

39
00:02:21.330 --> 00:02:25.540
and it has to return a number as the current value off the gauge.

40
00:02:25.540 --> 00:02:28.720
The state object is theater and ticket repository.

41
00:02:28.720 --> 00:02:32.710
So to get the number of tickets in the database we can simply call the

42
00:02:32.710 --> 00:02:37.870
count method on the repository Intelligence suggests that we can replace

43
00:02:37.870 --> 00:02:40.340
the Lambda expression by a method references.

44
00:02:40.340 --> 00:02:42.140
So let's do that.

45
00:02:42.140 --> 00:02:45.140
Let's check if it works by restarting this spring Bootstrap

46
00:02:45.140 --> 00:02:48.440
service again and running the low test again.

47
00:02:48.440 --> 00:02:50.830
If we now look at the metrics endpoint again,

48
00:02:50.830 --> 00:02:55.240
we see the Globomantics that registration or ticket symmetric,

49
00:02:55.240 --> 00:02:58.880
just like a counter, has a single count measurement.

50
00:02:58.880 --> 00:03:04.040
A gauge has a single value measurement with the current value of the gauge.

51
00:03:04.040 --> 00:03:07.740
Let's make one final change to this example.

52
00:03:07.740 --> 00:03:11.910
Stop the low generator test and let's look at the code again.

53
00:03:11.910 --> 00:03:15.860
Suppose that instead of just counting the total number off tickets,

54
00:03:15.860 --> 00:03:20.440
I would want to be able to see the number off tickets by ticket type.

55
00:03:20.440 --> 00:03:25.340
Remember that we have premium standard and community tickets.

56
00:03:25.340 --> 00:03:30.740
Let's use tax with engage so that we can select by ticket type.

57
00:03:30.740 --> 00:03:34.090
Let's first take a quick peek at theater and take a trip

58
00:03:34.090 --> 00:03:37.350
positively interface for this demo.

59
00:03:37.350 --> 00:03:41.520
I've added three custom count methods here to count the number

60
00:03:41.520 --> 00:03:45.140
of premium standard and community tickets.

61
00:03:45.140 --> 00:03:51.340
We'll use these for our gauge now back to the code for defining the cage.

62
00:03:51.340 --> 00:03:55.330
Besides the gauge method of the meter registry that we've used here,

63
00:03:55.330 --> 00:04:01.540
there are other variants off this method that also take an interim ble off tax.

64
00:04:01.540 --> 00:04:06.440
Let's change these lines of code and pass a single tech,

65
00:04:06.440 --> 00:04:08.600
since we have to pass an intra.

66
00:04:08.600 --> 00:04:12.870
BLE will use collections dot singleton here and then the

67
00:04:12.870 --> 00:04:16.240
tact OAuth method to define attack.

68
00:04:16.240 --> 00:04:20.930
This last method takes attack name and value for the name

69
00:04:20.930 --> 00:04:25.840
will use type and the value p for premium.

70
00:04:25.840 --> 00:04:28.910
Now, for the function that calculated the gauge value,

71
00:04:28.910 --> 00:04:33.530
we want to use the Count Premium tickets method that counts just a premium

72
00:04:33.530 --> 00:04:37.740
tickets instead of the count method that counts all tickets.

73
00:04:37.740 --> 00:04:42.280
The last step is to define the same gauge two more times,

74
00:04:42.280 --> 00:04:45.310
but each time with the different tack value and,

75
00:04:45.310 --> 00:04:45.890
of course,

76
00:04:45.890 --> 00:04:49.770
a different calculation function to count the number off standard

77
00:04:49.770 --> 00:04:52.840
tickets and the number of community tickets.

78
00:04:52.840 --> 00:04:55.740
We're done with the code for this demo.

79
00:04:55.740 --> 00:04:59.360
Let's see the result one more time by restarting to spring booed

80
00:04:59.360 --> 00:05:02.940
service and running the load generator test again.

81
00:05:02.940 --> 00:05:07.140
If you now look at the Globomantics start registration or tickets metric,

82
00:05:07.140 --> 00:05:12.290
you will see that it has attack named Type with three possible values.

83
00:05:12.290 --> 00:05:14.540
B, S and C.

84
00:05:14.540 --> 00:05:17.310
If you don't select on any of the tax values,

85
00:05:17.310 --> 00:05:22.220
these gauge will show the total number of tickets by adding a query

86
00:05:22.220 --> 00:05:29.000
parameter to select on one off the tack values, you can see the number off tickets by ticket type.

