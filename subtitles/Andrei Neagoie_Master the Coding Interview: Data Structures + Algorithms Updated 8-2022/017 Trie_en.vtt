WEBVTT
1
00:00:00.920 --> 00:00:01.880
Welcome back.

2
00:00:02.029 --> 00:00:07.550
We have one last tree that I want to talk about, and that is a tree or a tree.

3
00:00:07.850 --> 00:00:12.200
Pronunciation here varies on who you ask, but let's have a look at what it is.

4
00:00:13.930 --> 00:00:21.520
A try is a specialized tree used in searching, most often with text, as you can see here.

5
00:00:22.830 --> 00:00:30.210
And in most cases, it can outperform binary search trees, hash tables and most other data structures

6
00:00:30.210 --> 00:00:33.600
we've been talking about depending on the type of search you're doing.

7
00:00:34.620 --> 00:00:39.810
And just by looking at this image, you might understand what it does.

8
00:00:40.350 --> 00:00:47.340
Tries allow you to know if a word or part of a word exists in a body of text.

9
00:00:47.910 --> 00:00:52.650
You see, a tree has usually an empty root note, which is the starting point.

10
00:00:53.530 --> 00:00:55.840
And from there letters are added.

11
00:00:55.840 --> 00:00:57.490
You see that it's not a binary tree.

12
00:00:57.490 --> 00:00:59.260
It can have multiple children.

13
00:00:59.530 --> 00:01:05.800
In this case, it will most likely have 26 children because there's 26 letters in the alphabet.

14
00:01:06.340 --> 00:01:12.130
The power of the try is when we search for something such as N.

15
00:01:12.950 --> 00:01:20.240
If we had this dictionary, we know right away that there's two words associated with the word n.

16
00:01:20.750 --> 00:01:25.040
Another name for a tree is something called prefix tree.

17
00:01:25.660 --> 00:01:31.120
It's a tree like data structure which proves to be quite efficient in solving these problems specific

18
00:01:31.120 --> 00:01:31.870
to strengths.

19
00:01:31.900 --> 00:01:35.640
You can think of it as auto completion, right?

20
00:01:35.650 --> 00:01:42.340
When you search something on Google, it knows what you might be searching for or it tries and completes

21
00:01:42.340 --> 00:01:43.570
the word for you.

22
00:01:43.990 --> 00:01:50.470
And this is what it's used for, for searching words in a dictionary, providing auto suggestions on

23
00:01:50.470 --> 00:01:52.810
search engines or even IP routing.

24
00:01:53.290 --> 00:01:54.850
If I typed in a.

25
00:01:55.480 --> 00:02:03.400
I know immediately that all the children are related to a and I can print out a, r e and then as the

26
00:02:03.400 --> 00:02:09.850
benefit of this type of data structure is speed and space, what do you think the big o of finding a

27
00:02:09.850 --> 00:02:11.740
word in this data structure is?

28
00:02:12.340 --> 00:02:14.500
We're not going to go through every single node.

29
00:02:15.300 --> 00:02:19.710
Instead, all we need to do is find the length of the word.

30
00:02:19.860 --> 00:02:24.900
So the big o of a try is o of length.

31
00:02:24.900 --> 00:02:26.940
That is the length of the word.

32
00:02:27.330 --> 00:02:36.690
If I'm looking for the word, r, a, r, e, all I do is look for a, then look for R, then look for

33
00:02:36.690 --> 00:02:37.140
E.

34
00:02:38.140 --> 00:02:44.140
All I'm doing is hitting three notes which are associated with the length of the word when it comes

35
00:02:44.140 --> 00:02:44.650
to space.

36
00:02:44.650 --> 00:02:48.280
Complexity tries also have a major advantage.

37
00:02:49.520 --> 00:02:56.960
Because we use prefixes such as MN here is used in different words and same with a.

38
00:02:56.990 --> 00:02:59.540
We don't have to store it multiple times.

39
00:02:59.810 --> 00:03:04.250
It's stored in one location and you have children linking to it.

40
00:03:04.280 --> 00:03:11.210
Because of these prefixes, you save a lot of space because you don't have to store the word not in

41
00:03:11.210 --> 00:03:11.810
use.

42
00:03:12.200 --> 00:03:14.900
You get to avoid storing that extra in.

