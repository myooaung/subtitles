WEBVTT
1
00:00:01.170 --> 00:00:02.040
Welcome back.

2
00:00:02.680 --> 00:00:04.030
How is that exercise?

3
00:00:04.059 --> 00:00:08.620
Does your brain hurt from all this confusing sequence?

4
00:00:09.220 --> 00:00:17.500
Let's actually start off with the recursive function this time, because in this case the recursive

5
00:00:17.500 --> 00:00:20.860
function is actually a lot simpler to think about.

6
00:00:21.820 --> 00:00:28.900
All we would do with our recursive function is to say, Well, the base case is going to say number

7
00:00:29.260 --> 00:00:32.110
or N is going to equal.

8
00:00:34.530 --> 00:00:35.340
Two.

9
00:00:35.370 --> 00:00:38.460
If that's the case, simply return.

10
00:00:42.000 --> 00:00:47.190
Actually, if we look at the sequence, we see that if the index is zero.

11
00:00:47.950 --> 00:00:48.970
The answer is zero.

12
00:00:49.000 --> 00:00:53.680
If the index is one, the answer is one.

13
00:00:53.950 --> 00:00:58.210
And if the index is two, then the answer changes to one.

14
00:00:58.480 --> 00:01:04.090
So instead, our base case can maybe just simply be if PN is less than two.

15
00:01:04.120 --> 00:01:08.050
We're always going to just return whatever the NN is.

16
00:01:08.080 --> 00:01:10.990
So if we say zero, it's going to return zero.

17
00:01:10.990 --> 00:01:13.340
If we say one, it's going to return one.

18
00:01:13.360 --> 00:01:19.150
If we have an index higher than that, well, then we have to do some recursion.

19
00:01:20.910 --> 00:01:28.140
And all we're going to do here is have another return statement and say this function, I know that

20
00:01:28.140 --> 00:01:30.240
this function is really, really long.

21
00:01:30.240 --> 00:01:33.590
We can probably make it shorter to just say fib.

22
00:01:33.600 --> 00:01:37.230
And I notice that we don't need the iterative here.

23
00:01:38.230 --> 00:01:39.820
That will make it a little shorter.

24
00:01:39.850 --> 00:01:40.630
There you go.

25
00:01:42.870 --> 00:01:52.560
Now we're going to say is fib is going to equal N minus one plus the same thing.

26
00:01:54.720 --> 00:01:55.350
And.

27
00:01:56.510 --> 00:01:57.590
Minus two.

28
00:01:58.190 --> 00:02:06.680
Because remember, the sum is always the answer is always the numbers one and two before it.

29
00:02:07.380 --> 00:02:08.880
So we're just adding.

30
00:02:09.660 --> 00:02:15.030
The numbers one and two before our sequence.

31
00:02:16.250 --> 00:02:17.180
And that's it.

32
00:02:17.360 --> 00:02:24.200
If we run this function, let's say a Fibonacci recursive of three and I click run, I get two because

33
00:02:24.200 --> 00:02:27.710
zero one, two, three is two.

34
00:02:28.840 --> 00:02:31.330
Let's do eight, which should give us 21.

35
00:02:32.680 --> 00:02:35.200
I click run or give eight.

36
00:02:36.200 --> 00:02:37.850
I get 21.

37
00:02:39.820 --> 00:02:40.570
Nice.

38
00:02:40.960 --> 00:02:43.930
And if I do zero.

39
00:02:44.760 --> 00:02:45.780
I get zero.

40
00:02:46.140 --> 00:02:48.570
If I do one, I get one.

41
00:02:48.960 --> 00:02:52.980
If I do two, I should get one right here.

42
00:02:53.280 --> 00:02:55.230
Nice and simple.

43
00:02:55.920 --> 00:02:58.410
Well, I don't know about simple, right?

44
00:02:58.440 --> 00:03:04.110
You really have to get comfortable with this before you truly understand what's happening.

45
00:03:04.230 --> 00:03:06.420
But I have a little diagram to help you here.

46
00:03:07.460 --> 00:03:10.070
All we've done is simply this.

47
00:03:10.250 --> 00:03:18.830
If I added seven here, our recursive function is going to get one less than seven and two less than

48
00:03:18.830 --> 00:03:19.370
five.

49
00:03:19.370 --> 00:03:22.490
And then within those functions do the same thing.

50
00:03:22.820 --> 00:03:25.520
One less than six to less than six.

51
00:03:25.970 --> 00:03:27.300
One less than five.

52
00:03:27.320 --> 00:03:28.460
Two less than three.

53
00:03:28.460 --> 00:03:30.080
And it's doing all of these.

54
00:03:30.080 --> 00:03:30.650
All of these.

55
00:03:30.650 --> 00:03:34.670
All of these until we get to fib of one, two.

56
00:03:35.640 --> 00:03:39.300
Where we have our base case that returns that number.

57
00:03:39.300 --> 00:03:41.190
So this becomes one.

58
00:03:42.320 --> 00:03:43.760
This also becomes one.

59
00:03:43.760 --> 00:03:48.560
And then it keeps going, keeps going, keeps returning until we get to fib of seven.

60
00:03:48.980 --> 00:03:51.170
Now, this is a diagram that we're going to get back to.

61
00:03:51.170 --> 00:03:54.170
But you see, we're doing a lot of calculations here.

62
00:03:55.190 --> 00:03:57.710
But simply put, this is all we're doing.

63
00:03:59.690 --> 00:04:06.050
Now I said that the recursive approach is actually simple, simpler than the iterative approach.

64
00:04:06.650 --> 00:04:10.280
Let's have a look at what the iterative approach would look like.

65
00:04:11.110 --> 00:04:14.740
Create an array and there's many ways of doing this.

66
00:04:14.750 --> 00:04:23.180
This is my preferred way, and this array is going to have the initial items of the sequence zero and

67
00:04:23.180 --> 00:04:23.630
one.

68
00:04:24.430 --> 00:04:28.240
And this is going to, first of all, return the array.

69
00:04:29.910 --> 00:04:31.620
And item of MN.

70
00:04:31.650 --> 00:04:36.210
We're creating this array and then grabbing whatever index the user wants.

71
00:04:36.450 --> 00:04:43.470
In our case, if the user requests zero or one, we already have the array prefilled with zero and one

72
00:04:43.470 --> 00:04:45.210
and it's going to return the same.

73
00:04:45.630 --> 00:04:48.780
But we still need to calculate for all the other ones.

74
00:04:49.410 --> 00:04:58.890
That's where we do a for loop and say Let I equal two because we're going to start adding when the index

75
00:04:58.920 --> 00:05:03.840
is 012 to start filling this array.

76
00:05:04.290 --> 00:05:13.200
We'll say I is less than n plus one or we can do equals here if we want.

77
00:05:13.800 --> 00:05:16.740
We'll leave it at that for now and we'll increment it plus.

78
00:05:16.740 --> 00:05:17.310
Plus.

79
00:05:17.790 --> 00:05:23.280
And in this loop, we're going to keep going until we hit the number of index that we're interested

80
00:05:23.280 --> 00:05:23.610
in.

81
00:05:23.610 --> 00:05:26.550
And all we're going to say is array push.

82
00:05:28.840 --> 00:05:29.750
A ray.

83
00:05:30.520 --> 00:05:31.750
I minus two.

84
00:05:34.720 --> 00:05:35.590
A ray.

85
00:05:36.650 --> 00:05:38.600
I minus one.

86
00:05:38.900 --> 00:05:40.600
Similar to what we did before.

87
00:05:40.610 --> 00:05:45.890
We're just summing the previous two numbers and pushing it to the array.

88
00:05:46.750 --> 00:05:47.230
All right.

89
00:05:47.230 --> 00:05:49.000
Now, let's see if this works.

90
00:05:49.000 --> 00:05:53.380
I'm going to comment out this one and just do the iterative approach.

91
00:05:54.540 --> 00:05:56.730
I get two for three?

92
00:05:56.760 --> 00:05:58.900
What about index of eight?

93
00:05:58.920 --> 00:06:00.500
I get 21.

94
00:06:00.510 --> 00:06:01.320
Perfect.

95
00:06:01.620 --> 00:06:03.630
And then if I do index of zero.

96
00:06:05.030 --> 00:06:06.170
Index of one.

97
00:06:08.120 --> 00:06:10.450
And index of two should be one.

98
00:06:10.460 --> 00:06:11.120
Perfect.

99
00:06:11.450 --> 00:06:16.820
Now, I said that the recursive approach is simpler than the iterative approach.

100
00:06:16.850 --> 00:06:18.730
Now that's my personal opinion.

101
00:06:18.740 --> 00:06:19.970
You might not think that.

102
00:06:19.970 --> 00:06:22.100
You might think that this was quite easy.

103
00:06:22.460 --> 00:06:28.160
But to me, this reads a lot nicer than all this thing that we're doing.

104
00:06:28.790 --> 00:06:34.370
And this is something we're going to get into in the next video where we talk about the tradeoffs between

105
00:06:34.370 --> 00:06:41.120
the iterative and the recursive approaches to these problems and why maybe you're wondering right now,

106
00:06:41.120 --> 00:06:46.460
why would we ever write anything recursive if you find this confusing?

107
00:06:46.910 --> 00:06:47.900
We'll get to that.

108
00:06:48.640 --> 00:06:53.740
But the one thing I want to show you is something that we just learned here that is new to us.

109
00:06:54.310 --> 00:06:57.400
What do you think the big o of these two functions are?

110
00:06:58.890 --> 00:07:01.710
Well in our iterative solution.

111
00:07:02.710 --> 00:07:06.310
The big o is linear time, right?

112
00:07:06.310 --> 00:07:08.110
It's O of RN.

113
00:07:08.410 --> 00:07:16.180
Basically we're just iterating through the loop and minus two times because we're skipping the first

114
00:07:16.180 --> 00:07:17.080
two items.

115
00:07:18.570 --> 00:07:21.150
Which in turn makes it even.

116
00:07:21.980 --> 00:07:25.040
But what about the recursive approach?

117
00:07:25.920 --> 00:07:27.680
Remember the diagram I showed you?

118
00:07:28.660 --> 00:07:33.040
That's a lot more calculations than just the seven, right?

119
00:07:34.760 --> 00:07:38.270
We have a lot of function calls that happen.

120
00:07:39.160 --> 00:07:45.340
In this case, in the recursion solution, it takes what we call exponential time.

121
00:07:45.730 --> 00:07:51.550
The size of the tree exponentially grows when and increases.

122
00:07:51.550 --> 00:08:01.270
If Fibonacci number was eight, we would have this tree as well as an other tree underneath the fib

123
00:08:01.300 --> 00:08:02.200
of eight.

124
00:08:03.370 --> 00:08:06.160
So what is the big o of that?

125
00:08:07.980 --> 00:08:12.900
This is very exciting because we're learning about a new big notation.

126
00:08:13.080 --> 00:08:17.520
We're learning about this one exponential time.

127
00:08:18.460 --> 00:08:24.040
Which can be seen with recursive algorithms that solve a problem of size.

128
00:08:24.040 --> 00:08:27.040
N two to the power of n.

129
00:08:27.800 --> 00:08:32.929
If we go to our big o cheat sheet, this is o two to the power of.

130
00:08:34.429 --> 00:08:37.490
You see how much it increases.

131
00:08:37.640 --> 00:08:39.470
That's pretty bad.

132
00:08:39.500 --> 00:08:42.799
It's bigger than even o of nn square.

133
00:08:42.919 --> 00:08:45.080
The two nested for loops.

134
00:08:46.170 --> 00:08:52.710
Exponential time means every additional element in the Fibonacci sequence.

135
00:08:52.710 --> 00:08:57.090
We get an increase in function calls exponentially.

136
00:08:58.010 --> 00:08:59.810
And here's a fun little trick.

137
00:09:00.780 --> 00:09:10.530
Although this is o of nw the iterative approach this function because its o of two.

138
00:09:11.970 --> 00:09:13.350
To the power of an.

139
00:09:14.620 --> 00:09:18.880
If I run this function, let's say if we do ten.

140
00:09:20.580 --> 00:09:24.630
I get a result if I do 15.

141
00:09:25.690 --> 00:09:27.060
I still get a result.

142
00:09:27.070 --> 00:09:28.570
What if I do 20 here?

143
00:09:29.880 --> 00:09:30.300
All right.

144
00:09:30.300 --> 00:09:32.310
It's starting to get bigger and bigger.

145
00:09:33.060 --> 00:09:34.320
If I do 30.

146
00:09:36.480 --> 00:09:37.690
If I do 40.

147
00:09:40.440 --> 00:09:43.410
Do you see how much longer that took to calculate?

148
00:09:43.830 --> 00:09:47.880
Because our time complexity is increasing more and more.

149
00:09:47.910 --> 00:09:49.890
If I do 43 now.

150
00:09:51.290 --> 00:09:55.970
You'll see that we're waiting and waiting and waiting for the calculation to happen.

151
00:09:55.970 --> 00:10:00.690
And eventually the browser comes up with a calculation as a bonus question.

152
00:10:00.710 --> 00:10:05.750
Think about how many calculations Fibonacci 43 required.

153
00:10:07.000 --> 00:10:14.080
This, although might be more readable, is not an ideal solution.

154
00:10:14.440 --> 00:10:19.330
As you can see, big time complexity is pretty big and this is something that you might get asked in

155
00:10:19.330 --> 00:10:19.990
an interview.

156
00:10:21.280 --> 00:10:24.160
And I know what you're thinking, Andre.

157
00:10:24.190 --> 00:10:28.030
You just taught us about recursion, and it's not even good.

158
00:10:28.120 --> 00:10:29.350
It's slow.

159
00:10:29.350 --> 00:10:30.390
It's confusing.

160
00:10:30.400 --> 00:10:33.550
Why would I ever want to use recursion?

161
00:10:34.330 --> 00:10:38.180
In the next video, I'm going to talk about this trade off.

162
00:10:38.200 --> 00:10:42.280
Why would you ever use recursion over something that is iterative?

163
00:10:43.320 --> 00:10:46.050
Why would any sane person do that?

164
00:10:46.320 --> 00:10:53.100
And as you'll find out, there are some pros and cons and as a matter of fact, a function like this.

165
00:10:53.970 --> 00:11:02.220
Such as Fibonacci sequence and recursion can be made to over MN using something like dynamic programming

166
00:11:02.220 --> 00:11:06.450
and memorization, which we're going to talk about towards the end of this course.

167
00:11:07.170 --> 00:11:08.760
And we're going to get back to this.

168
00:11:09.560 --> 00:11:12.350
But let's finally answer the question in the next video.

169
00:11:12.830 --> 00:11:17.840
Why would you ever use recursion over something iterative?

170
00:11:18.700 --> 00:11:19.750
I'll see you in the next one.

171
00:11:20.340 --> 00:11:20.880
Bye bye.

