WEBVTT
1
00:00:01.240 --> 00:00:02.050
Welcome back.

2
00:00:02.080 --> 00:00:09.090
We've talked about these five sorting algorithms and by now you should know that merge, sort and quicksort,

3
00:00:09.100 --> 00:00:16.059
although they're harder to implement, are the most often used algorithms in real life because they

4
00:00:16.059 --> 00:00:21.700
use divide and conquer to get us this o of n log n performance boost.

5
00:00:21.700 --> 00:00:25.540
But can we beat o of n log n.

6
00:00:26.400 --> 00:00:27.630
And here's the thing.

7
00:00:27.780 --> 00:00:36.930
Mathematically, it is impossible to improve on this if anybody comes up with an algorithm that is faster

8
00:00:36.930 --> 00:00:37.560
than this.

9
00:00:37.860 --> 00:00:41.010
They're going to well, they're going to be very, very rich.

10
00:00:41.040 --> 00:00:49.650
Mathematically, it's impossible because of an log n means that we have to sort by comparison, all

11
00:00:49.650 --> 00:00:56.160
of these sorting algorithms have to compare every number to each other.

12
00:00:56.610 --> 00:00:59.940
But there is one exception to this rule.

13
00:01:00.330 --> 00:01:05.850
You can improve this if you don't make comparisons.

14
00:01:06.670 --> 00:01:07.130
Huh?

15
00:01:07.150 --> 00:01:08.170
What does that mean?

16
00:01:08.620 --> 00:01:13.600
There's a small section of inputs that we can actually beat.

17
00:01:13.750 --> 00:01:15.670
Oh, of an log n.

18
00:01:16.380 --> 00:01:20.550
And these are called non comparison sorts.

19
00:01:21.690 --> 00:01:25.790
And you'll most likely see counting sort and radical sort.

20
00:01:25.800 --> 00:01:27.240
But what does that mean?

21
00:01:27.480 --> 00:01:33.150
Counting sort and radical sort is an entire different way to think about sorting.

22
00:01:34.010 --> 00:01:40.640
With comparison short, we decided the order of the numbers based on asking the question, Hey, is

23
00:01:40.640 --> 00:01:44.090
this element bigger than the one over there?

24
00:01:44.450 --> 00:01:46.550
What about the one over there and over there?

25
00:01:46.550 --> 00:01:47.900
And we just kept doing that.

26
00:01:47.900 --> 00:01:49.940
Every number got compared to each other.

27
00:01:50.270 --> 00:01:54.200
Non comparison sorting does it a little bit differently.

28
00:01:54.320 --> 00:02:02.750
We're going to use the way that numbers and data is stored on our computers in zeros and ones and take

29
00:02:02.750 --> 00:02:05.600
advantage of that fact to sort things.

30
00:02:06.290 --> 00:02:12.260
Now this can get pretty complex and as you can see here in this paper.

31
00:02:13.410 --> 00:02:19.110
Just looking at the diagrams and for example, radical sort here in how we store numbers in zeros and

32
00:02:19.110 --> 00:02:24.780
ones, we can use this knowledge to actually sort some things.

33
00:02:25.440 --> 00:02:30.600
I'm going to leave resources for you if you want to get really technical and into this topic.

34
00:02:30.990 --> 00:02:38.100
I do warn you, you can get a little bit mathy, but the one thing to note here is that these type of

35
00:02:38.130 --> 00:02:47.130
sorting algorithm counting sort and radical sort only work with numbers, specifically integers in a

36
00:02:47.130 --> 00:02:48.720
restricted range.

37
00:02:48.810 --> 00:02:54.720
So if you have only numbers that you want to solve sort and the range of those numbers go from, let's

38
00:02:54.720 --> 00:02:58.020
say, 0 to 100, that is a small range.

39
00:02:58.140 --> 00:03:05.520
Then you would use something like this to make things really fast, but it wouldn't work on any type

40
00:03:05.520 --> 00:03:06.160
of data.

41
00:03:06.180 --> 00:03:11.220
It only really works on numbers because of the way numbers are stored in memory.

42
00:03:12.260 --> 00:03:18.710
You see, unlike something like merge sort or quicksort that are universal, that is they can sort any

43
00:03:18.710 --> 00:03:19.580
type of data.

44
00:03:20.510 --> 00:03:26.060
Things like counting sort and radical sort is only useful for fixed length integers.

45
00:03:26.950 --> 00:03:30.400
But they are able to beat the speed of Owen.

46
00:03:30.400 --> 00:03:31.150
Log in.

47
00:03:32.120 --> 00:03:40.670
And as you can see here, bucket sort radical sword counting sort in their average cases have o of n

48
00:03:40.670 --> 00:03:43.820
plus k ov and k ov and k.

49
00:03:44.030 --> 00:03:48.560
What wn and K means is beyond the scope of this course.

50
00:03:48.560 --> 00:03:54.350
And some argue that in the end, this actually still turns out to be pretty slow.

51
00:03:54.770 --> 00:03:58.310
I'll leave resources for you, like I said, so you can read up on them.

52
00:03:58.310 --> 00:04:04.040
But the only thing you need to know about these is that sometimes if you have numbers that are within

53
00:04:04.040 --> 00:04:08.530
a certain range, it could be faster than quicksort or master.

54
00:04:09.780 --> 00:04:16.620
So now that we know this, let's do some interview exercises based on sorting to solidify what we just

55
00:04:16.620 --> 00:04:17.100
learned.

