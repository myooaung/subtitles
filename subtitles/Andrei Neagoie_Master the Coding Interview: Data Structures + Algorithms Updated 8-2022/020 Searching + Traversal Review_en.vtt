WEBVTT
1
00:00:01.130 --> 00:00:02.440
Holy moly.

2
00:00:02.450 --> 00:00:04.310
Another section done.

3
00:00:04.310 --> 00:00:06.530
And we're getting so close to the end.

4
00:00:07.040 --> 00:00:14.600
In this section, we learned about searching and traversal some of the most popular and important algorithms.

5
00:00:14.750 --> 00:00:23.120
We learned about linear search and how it can be good for some cases, but not the most efficient because

6
00:00:23.120 --> 00:00:25.970
it has linear time of DN.

7
00:00:26.480 --> 00:00:32.780
We also talked about binary search where we're able to search through things at log of DN.

8
00:00:33.620 --> 00:00:40.750
Essentially skipping a lot of the nodes that we would need to search by dividing the tree in half.

9
00:00:41.050 --> 00:00:49.030
We then talked about how to traverse a tree and a graph that is to visit every single node in the most

10
00:00:49.030 --> 00:00:50.290
efficient way possible.

11
00:00:50.770 --> 00:00:57.670
We talked about depth for search that goes in as deep as possible into a tree or a graph and breadth

12
00:00:57.670 --> 00:01:05.050
for a search that goes level by level, searching or traversing a tree or a graph.

13
00:01:07.870 --> 00:01:14.980
And whether you realize it or not, we've completed a lot of this mind map that looked so intimidating

14
00:01:15.190 --> 00:01:17.350
at the beginning of this course.

15
00:01:18.370 --> 00:01:22.150
You see now when we look at a race, for example.

16
00:01:24.430 --> 00:01:25.670
We understand that.

17
00:01:25.690 --> 00:01:32.520
Well, when a ray we need to search through an array, we can ask the question, hey, is it sorted?

18
00:01:32.530 --> 00:01:35.880
Because if it is, then yes.

19
00:01:35.890 --> 00:01:43.000
In that case we should divide and conquer and arrange that array in a tree like data structure so that

20
00:01:43.000 --> 00:01:49.420
we can do binary search and get a speed boost of oh log n is the array.

21
00:01:50.120 --> 00:01:50.960
Not sorted?

22
00:01:50.990 --> 00:01:51.950
Well, no.

23
00:01:51.980 --> 00:02:00.950
Then it's actually more efficient to sort the array, even though it takes o of an log n as we know

24
00:02:00.950 --> 00:02:06.260
over here, and then do a binary search after we sorted.

25
00:02:07.320 --> 00:02:09.210
And a lot of programs do that.

26
00:02:10.050 --> 00:02:17.220
Although it may seem time consuming to do sorting and then searching, it is actually faster than perhaps

27
00:02:17.220 --> 00:02:19.890
doing a linear search over and over.

28
00:02:20.620 --> 00:02:27.060
We can also complete this part of the graph where we come to graphs and trees.

29
00:02:27.660 --> 00:02:34.500
When we do traversal, that is, try and visit a node in a tree or graph or all nodes in a tree over

30
00:02:34.500 --> 00:02:35.040
graph.

31
00:02:35.730 --> 00:02:40.640
We know that it's going to take o of and that is we have to visit every node.

32
00:02:40.650 --> 00:02:42.630
It's going to be linear time.

33
00:02:43.200 --> 00:02:51.420
But there are ways to traverse these trees using breadth for search and depth for search.

34
00:02:52.500 --> 00:03:00.060
And we learned that breadth for search is great for the shortest path algorithms, while depth for search

35
00:03:00.060 --> 00:03:06.810
is really great at maze solving problems or perhaps finding if a node even exists.

36
00:03:07.720 --> 00:03:13.120
And depth for search allow us to do in order post order and pre-order sorting.

37
00:03:15.040 --> 00:03:23.380
And we even coded this up all ourselves and we learn how the code works using recursion with depth for

38
00:03:23.380 --> 00:03:29.990
search and also with breadth for search using both iterative and recursive.

39
00:03:30.010 --> 00:03:32.260
Using a Q data structure.

40
00:03:33.610 --> 00:03:40.510
Finally, we also learned a little bit about shortest path problems, such as the one that Google Maps

41
00:03:40.510 --> 00:03:41.260
would use.

42
00:03:41.260 --> 00:03:47.650
When there's weights between nodes in a graph where we can use something like Belmont, Ford or Dijkstra's

43
00:03:47.650 --> 00:03:49.990
algorithm to solve a problem.

44
00:03:51.070 --> 00:03:52.390
Congratulations.

45
00:03:52.420 --> 00:03:53.230
This.

46
00:03:54.610 --> 00:04:02.650
Is your mind map and you've covered every single thing on this map with the exception of one.

47
00:04:02.980 --> 00:04:05.290
And that is this one right over here.

48
00:04:05.320 --> 00:04:06.940
Dynamic programming.

49
00:04:07.420 --> 00:04:13.870
It's a short section to complete our overall mind map and get you interview ready.

50
00:04:14.540 --> 00:04:16.100
So I'll see you in the next section.

51
00:04:16.370 --> 00:04:17.260
Congratulations.

52
00:04:17.269 --> 00:04:18.170
Getting this far.

53
00:04:18.200 --> 00:04:19.399
You're almost there.

