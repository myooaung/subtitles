WEBVTT
1
00:00:02.009 --> 00:00:02.940
Welcome back.

2
00:00:03.420 --> 00:00:06.570
You may have noticed something while talking about Big O.

3
00:00:07.540 --> 00:00:11.980
Scalable means we worry about large inputs.

4
00:00:12.160 --> 00:00:15.430
What does the end of the graph look like?

5
00:00:15.850 --> 00:00:24.340
So if our function is only worried about really small inputs or we know that our inputs are only going

6
00:00:24.340 --> 00:00:29.590
to be, let's say, an array of five items, big O won't matter as much, does it?

7
00:00:29.590 --> 00:00:34.510
Because over here if the elements are small, all these lines are kind of bunched up together.

8
00:00:34.510 --> 00:00:35.470
They're all the same.

9
00:00:35.800 --> 00:00:38.170
But is that real life?

10
00:00:38.230 --> 00:00:39.760
No, because.

11
00:00:40.700 --> 00:00:46.580
As humans, we tend to think in here and now we tend to think that, Oh, our website's only going to

12
00:00:46.580 --> 00:00:48.380
have 100 users.

13
00:00:48.380 --> 00:00:49.040
That's it.

14
00:00:49.670 --> 00:00:52.020
But what if that user base grows?

15
00:00:52.040 --> 00:00:53.600
What if our inputs grow?

16
00:00:53.630 --> 00:00:54.380
We never know.

17
00:00:54.380 --> 00:00:55.340
When we write code.

18
00:00:55.340 --> 00:01:01.340
We want to write code that can scale so that we don't have to constantly go back and fix things.

19
00:01:01.340 --> 00:01:04.670
Or when things get out of hand, the code breaks.

20
00:01:05.710 --> 00:01:09.040
And that's why Big O is so important to write.

21
00:01:09.040 --> 00:01:14.390
Scalable code means thinking outside of just this small little section over here.

22
00:01:14.410 --> 00:01:19.510
It means thinking long term, thinking big about your code and what could happen in the future.

23
00:01:20.020 --> 00:01:25.870
Now you're thinking to yourself right now, Hey, Andre, I feel like I just learned a whole bunch of

24
00:01:25.870 --> 00:01:28.510
theory and no practical information.

25
00:01:28.540 --> 00:01:33.400
Andre, I want to know exactly how I can use this in my day to day life as a coder.

26
00:01:33.430 --> 00:01:35.110
I'm kind of getting bored here.

27
00:01:35.500 --> 00:01:39.640
Well, with this newfound knowledge, you're going to look at code differently now.

28
00:01:39.850 --> 00:01:40.560
Right.

29
00:01:40.660 --> 00:01:41.680
Let's have a look.

30
00:01:42.640 --> 00:01:50.380
You see now when we look at methods that we get in a language such as methods in an array, when it

31
00:01:50.380 --> 00:01:56.260
comes to JavaScript, we have things like push pop shift on shift.

32
00:01:56.650 --> 00:02:04.900
You see all these methods which are functions have a cost associated with them, a big o cost.

33
00:02:06.020 --> 00:02:12.770
For example, when it comes to arrays, when we search for an item or when we access the first item

34
00:02:12.770 --> 00:02:15.950
in an array, for example, it's O of one.

35
00:02:16.760 --> 00:02:22.670
But when we use something like on shift, well, it actually turns out to be o of n.

36
00:02:23.330 --> 00:02:29.000
And why that is we're going to get into when we talk about the data structure array in the data structure

37
00:02:29.000 --> 00:02:37.430
section, but you're going to start to see for the rest of this course how we use Big O to measure why

38
00:02:37.430 --> 00:02:40.370
one data structure might be better than others.

39
00:02:40.370 --> 00:02:45.020
Why should we use an array instead of, let's say, an object?

40
00:02:45.020 --> 00:02:49.910
Maybe object has better functions that we need for our data.

41
00:02:50.930 --> 00:02:57.560
This graph that we've talked about up until now is actually part of big o chichi dot com.

42
00:02:57.560 --> 00:03:00.560
And if we scroll down here, you'll see that.

43
00:03:01.250 --> 00:03:08.180
Each data structure that is an array and in this case, objects on this table is a hash table.

44
00:03:08.180 --> 00:03:10.940
Again, something that we're going to cover in the data structure section.

45
00:03:10.940 --> 00:03:18.680
But we see that we have different big notation for different data structure.

46
00:03:18.680 --> 00:03:25.280
And some data structures have really good search bigo some have insertions, some have deletion.

47
00:03:25.280 --> 00:03:32.060
And you can see here that there's different pros and cons to each of these data structures.

48
00:03:32.840 --> 00:03:40.430
As you'll find out in this course, data structures are simply ways to store data, and algorithms are

49
00:03:40.430 --> 00:03:46.700
simply functions or ways to use data structures to write our programs.

50
00:03:46.700 --> 00:03:51.260
Remember our instructions for machines, for our computers.

51
00:03:52.040 --> 00:04:00.920
And great programmers have this knowledge where they pick the right data structure, the right algorithms

52
00:04:00.920 --> 00:04:03.260
to write good programs.

53
00:04:04.040 --> 00:04:08.780
Remember our two rules of good code readable and scalable.

54
00:04:09.440 --> 00:04:16.610
And what we've learned is the foundation for us to make a decision of which data structure is going

55
00:04:16.610 --> 00:04:17.360
to be best.

56
00:04:17.360 --> 00:04:24.110
When we get into the data structure section because we're going to know, oh, arrays allows us to access

57
00:04:24.110 --> 00:04:26.470
at oh and one constant time.

58
00:04:26.480 --> 00:04:31.970
But when it comes to searching through an array, it's going to give us linear time.

59
00:04:32.730 --> 00:04:35.280
Versus perhaps maybe an object.

60
00:04:35.760 --> 00:04:42.870
So behind the scenes, even though this section may be a little bit theoretical and boring, what we've

61
00:04:42.870 --> 00:04:49.140
just learned is going to lay the foundation for the rest of the course for us to be able to write good

62
00:04:49.140 --> 00:04:52.230
code for the rest of the sections.

63
00:04:52.230 --> 00:04:58.950
We're going to use Big O to see what is a good solution to a problem and what is a bad solution to a

64
00:04:58.950 --> 00:04:59.450
problem.

65
00:04:59.460 --> 00:05:05.730
And most interviews have this core concept what's the right data structure?

66
00:05:05.730 --> 00:05:09.270
What's the right algorithm to write good programs?

67
00:05:09.570 --> 00:05:17.310
Google hires engineers and developers that know this because they have a lot of scale that they have

68
00:05:17.310 --> 00:05:19.530
to think about a lot of inputs.

69
00:05:20.170 --> 00:05:26.890
And people that know how to handle these programs are the ones that are going to be able to build great

70
00:05:26.890 --> 00:05:27.580
programs.

71
00:05:29.270 --> 00:05:30.320
I'll see you in the next one.

72
00:05:30.870 --> 00:05:31.470
Bye bye.

