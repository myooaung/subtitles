WEBVTT
1
00:00:01.000 --> 00:00:01.870
Welcome back.

2
00:00:01.900 --> 00:00:05.080
Let's talk about the very first rule when it comes to big oil.

3
00:00:05.110 --> 00:00:09.430
That is worst case when calculating big.

4
00:00:09.430 --> 00:00:13.420
Oh, we always think about the worst case.

5
00:00:13.960 --> 00:00:15.220
What do I mean by that?

6
00:00:15.860 --> 00:00:18.290
Well, if we go back to Finding Nemo example.

7
00:00:20.900 --> 00:00:23.210
And the Find Nemo function.

8
00:00:24.060 --> 00:00:29.850
You may have been screaming at me while I was going through the function saying that, Andre, this

9
00:00:29.850 --> 00:00:31.020
is not efficient.

10
00:00:31.050 --> 00:00:31.980
What are you doing?

11
00:00:32.400 --> 00:00:40.110
Because if you look at this function, we're looping through the entire array to find Nemo.

12
00:00:41.440 --> 00:00:49.180
Remember how we had the Everyone Array with about ten different characters from Finding Nemo?

13
00:00:50.100 --> 00:00:56.580
Well, Nemo was only the 1 to 3 fourth member on this array.

14
00:00:57.180 --> 00:00:59.400
And when we run this function.

15
00:01:00.920 --> 00:01:02.450
We found Nemo.

16
00:01:02.780 --> 00:01:10.910
But the funny thing is, this function ran ten times, not four times.

17
00:01:11.240 --> 00:01:15.830
If I do a console log here and I say.

18
00:01:17.580 --> 00:01:18.270
Running.

19
00:01:19.080 --> 00:01:20.520
And let's click this.

20
00:01:21.610 --> 00:01:24.220
We see that this function ran.

21
00:01:24.220 --> 00:01:29.230
One, two, three, four, five, six, seven, eight, nine, ten.

22
00:01:29.710 --> 00:01:30.010
Hmm.

23
00:01:30.160 --> 00:01:32.100
I mean, we already found Nemo.

24
00:01:32.110 --> 00:01:35.470
All these runs are pretty wasteful.

25
00:01:36.290 --> 00:01:40.160
So we can make this function a little bit more efficient.

26
00:01:40.310 --> 00:01:46.070
In JavaScript, we can just have something called break.

27
00:01:48.090 --> 00:01:54.990
And again, different languages have different ways of exiting out of a loop if a condition is met.

28
00:01:54.990 --> 00:01:59.070
In our case, if we find Nemo, just break out of this loop.

29
00:01:59.490 --> 00:02:02.610
If I do this and click Run.

30
00:02:03.350 --> 00:02:04.070
Look at that.

31
00:02:04.160 --> 00:02:06.570
Once we found Nemo, we're done.

32
00:02:06.590 --> 00:02:08.960
We're not going to loop through the rest of the items.

33
00:02:09.229 --> 00:02:10.340
Congratulations.

34
00:02:10.340 --> 00:02:13.700
We just made our code a little bit more efficient.

35
00:02:14.270 --> 00:02:15.380
That's a good thing, right?

36
00:02:16.250 --> 00:02:23.810
Well, when it comes to Big O, although this is important and when you write good code, this is something

37
00:02:23.810 --> 00:02:27.080
that we want to do in the big scheme of things.

38
00:02:27.080 --> 00:02:30.820
Big O only cares about the worst case.

39
00:02:30.830 --> 00:02:32.450
What is the worst case here?

40
00:02:32.480 --> 00:02:40.430
Well, the worst case is that Nemo, instead of being the fourth item, is at the very end.

41
00:02:43.260 --> 00:02:50.940
So even if we have this break statement, we're still going to run this ten times because Nima, at

42
00:02:50.940 --> 00:02:56.790
the end best case is if Nemo is at the very beginning and we only have to loop through it once, but

43
00:02:56.790 --> 00:03:01.050
worst case, we're still going to have to go through ten.

44
00:03:01.830 --> 00:03:06.300
Loops still big o of n.

45
00:03:06.450 --> 00:03:09.900
So this is our very first rule.

46
00:03:10.290 --> 00:03:16.980
The very first rule is we always care about what is the worst case scenario, because when we talk about

47
00:03:16.980 --> 00:03:23.820
scalability, we can't just assume things are going well, even though the Find Nemo function might

48
00:03:24.210 --> 00:03:28.530
be of one if Nemo.

49
00:03:29.450 --> 00:03:31.580
Is the very first item in the array.

50
00:03:32.730 --> 00:03:39.120
It doesn't matter in the grand scheme of things because we can't be certain of what the input is going

51
00:03:39.120 --> 00:03:39.560
to be.

52
00:03:39.570 --> 00:03:46.110
We're going to assume that of big O is of n linear time.

53
00:03:46.840 --> 00:03:50.440
Again if we're finding a yellow box.

54
00:03:51.250 --> 00:03:54.070
And the yellow box is at the very end.

55
00:03:54.100 --> 00:03:57.220
We have to iterate through all the boxes.

56
00:03:58.200 --> 00:04:04.290
If the yellow box at the very beginning, you see that we don't have to iterate through these boxes.

57
00:04:05.060 --> 00:04:11.460
But Big O doesn't really care, even though this function yes is indeed more efficient.

58
00:04:11.480 --> 00:04:16.190
At the end of the day, when we talk about Big O, we're talking about worst case.

59
00:04:17.000 --> 00:04:17.540
All right.

60
00:04:17.540 --> 00:04:19.100
I hope you got that point through.

61
00:04:19.190 --> 00:04:24.890
I feel like I've beaten it to a pulp, so you should be comfortable with it by now.

62
00:04:24.920 --> 00:04:27.560
Let's talk about the next role on the next video.

