WEBVTT
1
00:00:01.460 --> 00:00:02.390
Welcome back.

2
00:00:02.480 --> 00:00:08.600
Before we code our own binary surgery, let's just go over the performance implications and why we might

3
00:00:08.600 --> 00:00:10.730
want to use it over other data structures.

4
00:00:11.300 --> 00:00:16.250
Its strengths are that it has really good performance across the board.

5
00:00:16.280 --> 00:00:23.180
You saw that most operations or all operations in a binary search three are better than O of n.

6
00:00:24.040 --> 00:00:29.320
Assuming that the binary search tree is balanced, it is also ordered.

7
00:00:30.220 --> 00:00:36.550
And because we can place the node anywhere in memory, we can just have flexible size.

8
00:00:36.550 --> 00:00:38.950
We can keep growing our tree.

9
00:00:39.910 --> 00:00:46.120
The downside is that, as you may have noticed, it has no one operation.

10
00:00:46.360 --> 00:00:51.940
We usually have to do some sort of traversal through the tree for any sort of operation.

11
00:00:52.910 --> 00:00:59.630
So compared to an array, a lookup, for example, will be a lot faster because we have zero log in

12
00:00:59.630 --> 00:01:04.489
for searches versus if we iterate through an entire array.

13
00:01:04.519 --> 00:01:12.020
If the array is unsorted, inserts and deletes are also faster than an array unless the array is adding

14
00:01:12.020 --> 00:01:12.800
to the end.

15
00:01:12.830 --> 00:01:20.510
Otherwise, arrays have to shift all the indexes versus a binary search tree that is just o of log in.

16
00:01:21.610 --> 00:01:23.290
What about compared to hash tables?

17
00:01:23.320 --> 00:01:32.020
Well, although hash tables allow us to insert and search at constant time with binary searches, we

18
00:01:32.020 --> 00:01:33.880
have sorted data.

19
00:01:34.480 --> 00:01:41.440
And we also have this structure of parent child relationship that you won't be able to get too much

20
00:01:41.440 --> 00:01:42.460
with hash tables.

21
00:01:43.350 --> 00:01:49.470
A good thing to keep in mind is that binary searches aren't the fastest for anything.

22
00:01:50.210 --> 00:01:54.080
Remember their operations are usually always o of log in.

23
00:01:54.560 --> 00:02:02.090
On average, an array or an object will have faster operation, but there are certain conditions where

24
00:02:02.090 --> 00:02:04.490
they do outperform objects in arrays.

25
00:02:05.160 --> 00:02:12.240
So binary searches do perform really well as long as you make sure that you stay away from the cases

26
00:02:12.240 --> 00:02:15.450
that we discussed and we balance our binary search tree.

27
00:02:16.540 --> 00:02:22.450
But enough talk, enough slides, I think, to fully grasp and understand how trees work.

28
00:02:22.450 --> 00:02:23.650
We should code our own.

29
00:02:24.100 --> 00:02:25.240
I'll see you in the next one.

30
00:02:25.690 --> 00:02:26.230
Bye bye.

