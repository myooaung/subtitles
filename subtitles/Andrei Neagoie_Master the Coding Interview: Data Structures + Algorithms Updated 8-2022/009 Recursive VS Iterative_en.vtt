WEBVTT
1
00:00:01.310 --> 00:00:02.270
Welcome back.

2
00:00:02.480 --> 00:00:12.440
There is a theorem that states anything that can be implemented recursively can be implemented iteratively.

3
00:00:13.360 --> 00:00:21.220
That is, you can go your whole life without implementing recursive functions and just use loops.

4
00:00:21.990 --> 00:00:29.620
OC So why would we ever want to confuse ourselves with a topic like recursion that can be a little confusing.

5
00:00:30.700 --> 00:00:37.150
Well, for some problems, it's actually easier to write, but it really depends on the situation.

6
00:00:37.390 --> 00:00:44.440
Keep in mind that there's always two options, and by now you know that with programming, there's always

7
00:00:44.440 --> 00:00:50.920
pros and cons, and a good engineer is somebody who can make the right decisions based on those pros

8
00:00:50.920 --> 00:00:51.610
and cons.

9
00:00:52.800 --> 00:01:00.720
But I want you to keep this in mind for interviews, because interviewers will ask you to solve a problem

10
00:01:00.720 --> 00:01:06.660
and a problem that can be solved with recursion can usually be solved iteratively as well.

11
00:01:09.770 --> 00:01:12.440
And looking at our Fibonacci the function.

12
00:01:13.180 --> 00:01:24.070
This is a simpler example of recursion, but there are times when recursion can keep your code dry.

13
00:01:24.100 --> 00:01:26.350
That is, do not repeat yourself.

14
00:01:26.380 --> 00:01:29.230
A big rule when it comes to programming.

15
00:01:29.890 --> 00:01:36.970
And there are a lot of problems when it comes to recursion as they get harder and harder when using

16
00:01:36.970 --> 00:01:42.790
recursive functions, allow your code to be more readable and also dry.

17
00:01:42.820 --> 00:01:47.860
Simpler, have less loops happening with confusing code.

18
00:01:48.310 --> 00:01:55.570
And I'm a little bit biased because although recursion is a powerful technique, in my opinion, it's

19
00:01:55.570 --> 00:01:57.430
not always the best approach.

20
00:01:57.580 --> 00:02:07.150
So you need to make sure because of or its main drawback, that is, although recursion can keep your

21
00:02:07.150 --> 00:02:14.710
code dry and make your code more readable, it also creates this extra memory footprint.

22
00:02:15.840 --> 00:02:22.890
Because every time we add a function to the call stack, it adds extra piece of memory.

23
00:02:23.220 --> 00:02:26.670
So you have cases where you can get stack overflows.

24
00:02:27.700 --> 00:02:33.790
Or if your system has expensive memory, you want to avoid making too many recursive calls.

25
00:02:34.790 --> 00:02:39.320
And for some people, recursion is also something that is hard to wrap their mind around.

26
00:02:39.320 --> 00:02:45.230
And if you have a team of young engineers of developers that aren't familiar with recursion, that may

27
00:02:45.230 --> 00:02:46.880
not be the best option.

28
00:02:47.700 --> 00:02:52.770
But the main drawback is this that iterative approaches tend to be more efficient because they don't

29
00:02:52.770 --> 00:02:57.810
make these additional function calls that take up the stack space.

30
00:02:58.290 --> 00:03:02.520
With the downside being that iterative solutions might be not as readable.

31
00:03:03.750 --> 00:03:11.580
And a rule that I like to follow is that I like to use recursion when you're working with data structures

32
00:03:11.580 --> 00:03:17.310
that you're not really sure how deep they are, where you don't know how many loops to go through.

33
00:03:17.430 --> 00:03:24.360
And as you'll see, recursion is really useful for things such as tree data structures and doing traversal

34
00:03:24.360 --> 00:03:26.640
because that is often the case.

35
00:03:27.570 --> 00:03:34.470
Now in the next video, I want to talk about this topic a little bit deeper and when to use recursion.

36
00:03:34.470 --> 00:03:37.440
But I do want to point one thing quickly.

37
00:03:38.390 --> 00:03:41.180
There's something called tail code optimization.

38
00:03:42.060 --> 00:03:43.200
In many languages.

39
00:03:43.200 --> 00:03:50.730
And for example, in JavaScript with ES6, it allows recursion to be called without increasing the call

40
00:03:50.730 --> 00:03:51.300
stack.

41
00:03:51.330 --> 00:03:55.680
You can read more about it in the resources that I'll provide to you in this video.

42
00:03:56.660 --> 00:03:58.460
But in other languages as well.

43
00:03:58.460 --> 00:04:02.660
There are certain ways to write recursion, so they're more memory efficient.

44
00:04:03.740 --> 00:04:09.680
So this large stack issue can actually be resolved during production.

45
00:04:10.820 --> 00:04:15.080
But let's talk about a definitive guide to when to use recursion in the next video.

