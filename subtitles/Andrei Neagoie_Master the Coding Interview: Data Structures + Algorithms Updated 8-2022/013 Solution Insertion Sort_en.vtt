WEBVTT
1
00:00:01.480 --> 00:00:02.469
Welcome back.

2
00:00:02.560 --> 00:00:05.170
Were you able to figure out insertion sort?

3
00:00:05.920 --> 00:00:07.780
I have the answer here for you.

4
00:00:07.810 --> 00:00:17.260
Just like it happened in the animation, we first loop over the array and if the item we're looping

5
00:00:17.260 --> 00:00:20.710
for is less than the first item in the array.

6
00:00:21.460 --> 00:00:23.530
Well, we just move.

7
00:00:24.290 --> 00:00:31.820
That item, use the on shift method in array and added to the first index in the array.

8
00:00:32.880 --> 00:00:39.960
Otherwise if the item were currently looping over is not less than the first index.

9
00:00:40.320 --> 00:00:44.060
In that case, we got to figure out where the number should go.

10
00:00:44.070 --> 00:00:50.850
So we're going to loop through things, do an if statement to see where the number should go, and then

11
00:00:50.850 --> 00:00:58.590
we move that number to the right spot using the splice method so that if we click run here we have our

12
00:00:58.590 --> 00:01:00.000
list sorted.

13
00:01:01.390 --> 00:01:06.340
I'll once again leave this function here for you to play around with.

14
00:01:06.460 --> 00:01:10.780
But I want to quickly talk about the big complexity of insertion sort.

15
00:01:11.290 --> 00:01:16.210
There are times where insertion sort can work really, really well.

16
00:01:16.390 --> 00:01:23.670
The best case scenario for insertion sort when the list is almost sorted or the data is really small,

17
00:01:23.680 --> 00:01:25.330
it can be really fast.

18
00:01:25.600 --> 00:01:29.230
If we go back to our little animations here.

19
00:01:30.080 --> 00:01:36.140
And we look at insertion sort in a nearly sorted data and I click play.

20
00:01:36.470 --> 00:01:41.120
You'll notice that it's the first one that will finish quite fast actually, compared to all the other

21
00:01:41.120 --> 00:01:41.570
ones.

22
00:01:41.780 --> 00:01:42.890
Let's see that again.

23
00:01:45.740 --> 00:01:47.510
You'll see that it's the first one done.

24
00:01:48.480 --> 00:01:49.470
Quite fast.

25
00:01:49.800 --> 00:01:57.450
And as we'll discuss in the next videos, when it comes to small data sets or data sets that are nearly

26
00:01:57.450 --> 00:02:02.160
sorted, you want to use insertion sort over most other sorting algorithms.

27
00:02:02.760 --> 00:02:03.520
Well done.

28
00:02:03.540 --> 00:02:06.030
Let's move on to the next sorting algorithm.

