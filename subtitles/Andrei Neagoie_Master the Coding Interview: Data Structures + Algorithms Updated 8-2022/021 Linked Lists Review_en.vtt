WEBVTT
1
00:00:01.420 --> 00:00:02.320
Welcome back.

2
00:00:03.020 --> 00:00:06.710
In this section, we learned all about linked lists.

3
00:00:07.320 --> 00:00:14.700
We learned how it doesn't come prebuilt in a lot of languages such as JavaScript, but it does in others.

4
00:00:14.940 --> 00:00:20.100
That is because linked lists are low level data structures.

5
00:00:20.890 --> 00:00:25.090
It's used a lot actually in other data structures like hash tables.

6
00:00:25.090 --> 00:00:31.570
And as we will see in some of the upcoming ones, such as Stacks and Qs, that we're going to talk about.

7
00:00:32.240 --> 00:00:40.070
It is a fundamental data structure that is very, very useful in computer science and also a very popular

8
00:00:40.070 --> 00:00:41.780
question when it comes to interviewing.

9
00:00:42.290 --> 00:00:45.170
We learned that when it comes to linked list.

10
00:00:45.930 --> 00:00:52.920
There's no random access in the sense that when looking for something you have to actually traverse

11
00:00:52.920 --> 00:00:54.810
the list with hash tables.

12
00:00:54.810 --> 00:01:00.090
We can find things right away with arrays, we can find things through indexes.

13
00:01:00.090 --> 00:01:01.830
We have slow lookups.

14
00:01:01.830 --> 00:01:05.160
We have to traverse through the list if we're searching for something.

15
00:01:05.980 --> 00:01:12.610
However they are ordered, unlike hash tables and link lists, allow us to have this sort of order.

16
00:01:13.330 --> 00:01:21.820
If we had a large number of items in an array and we keep adding to that array, we'd have to have excessive

17
00:01:21.820 --> 00:01:29.620
overhead cost, copying the array in memory and doubling up the space when it reaches the limit to create

18
00:01:29.620 --> 00:01:38.380
a larger array versus a link list where we can have a fast insertion and fast deletion, especially

19
00:01:38.380 --> 00:01:43.240
once we have a reference to where we want to insert or delete that node.

20
00:01:44.070 --> 00:01:51.780
This also becomes a really, really fast when it's at the beginning of a list or the end of the list.

21
00:01:52.080 --> 00:01:55.650
And we're going to see that coming up when we talk about Stacks and Qs.

22
00:01:56.070 --> 00:02:02.760
The primary reason to choose a link list over something like an array is simplicity and ability to grow

23
00:02:02.760 --> 00:02:04.010
and shrink as needed.

24
00:02:04.020 --> 00:02:10.770
Now working with them as we saw, can be a little bit weird and difficult to just manage all the pointers

25
00:02:10.770 --> 00:02:17.910
in your head, but they are pretty lightweight and self-contained in that they can be quite flexible

26
00:02:17.910 --> 00:02:18.480
as well.

27
00:02:19.770 --> 00:02:25.470
That's why you're going to see linked lists in a lot of places like implementing file systems on your

28
00:02:25.470 --> 00:02:31.830
computer or even browser history, right, when you go back and forth on a browser.

29
00:02:32.640 --> 00:02:38.190
You can think of that as a link list because you can traverse one by one from one place to another.

30
00:02:39.050 --> 00:02:44.180
And remember with our hash tables how we had this issue of collision.

31
00:02:44.180 --> 00:02:51.680
And when we had a collision, we had to do something like this where we combined John Smith and Sandra

32
00:02:51.680 --> 00:02:56.870
D into two nodes and the first node pointed to the second node.

33
00:02:59.570 --> 00:03:07.580
If we go back to our hash table data structure that we created, if we scroll down to the set method

34
00:03:07.730 --> 00:03:11.570
where we set a key and a value in the hash table.

35
00:03:12.250 --> 00:03:18.070
We did a check here to check if this address exists.

36
00:03:18.070 --> 00:03:28.750
And then afterwards we used an array to push our items in case we had multiple items when we had a collision.

37
00:03:29.050 --> 00:03:36.580
Because sometimes we can set our hash table memory size to be a lot smaller like two, and you might

38
00:03:36.580 --> 00:03:45.550
be able to see why now instead of using an array, which every time we need to insert a new item, I

39
00:03:45.550 --> 00:03:51.430
mean, it works because we're pushing to the end, but if we had to delete an item on the hash table,

40
00:03:51.430 --> 00:04:01.840
we'd have to on shift the array, which as you know, is very slow so we can modify this now to something

41
00:04:01.840 --> 00:04:09.160
like a link list so that a delete becomes a lot easier than if it was an array.

42
00:04:09.580 --> 00:04:15.760
And that's something that I'll leave up to you, but you should have a good sense of why these data

43
00:04:15.760 --> 00:04:20.860
structures exist now and why you might want to use a link list over an array.

44
00:04:21.670 --> 00:04:27.190
We also added another piece of the puzzle in our mind map.

45
00:04:27.900 --> 00:04:34.290
We've talked about arrays, about hash tables, and now we talked about if you see over here, link

46
00:04:34.290 --> 00:04:40.860
lists are singly and doubly linked lists with their big notation.

47
00:04:42.170 --> 00:04:43.420
And just a hint here.

48
00:04:43.430 --> 00:04:48.650
As you can see, link lists are related to something we're going to talk about coming up.

49
00:04:49.360 --> 00:04:51.580
That is trees and grass.

50
00:04:53.980 --> 00:04:59.770
But at the end of the day, we've just managed to add another data structure to our tool belt.

51
00:04:59.800 --> 00:05:06.130
As engineers, congratulations and let's learn about more data structures in the next video.

52
00:05:06.670 --> 00:05:07.270
Bye bye.

