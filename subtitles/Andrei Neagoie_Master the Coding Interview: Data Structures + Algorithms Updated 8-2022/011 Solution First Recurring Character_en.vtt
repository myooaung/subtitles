WEBVTT
1
00:00:00.760 --> 00:00:01.630
Welcome back.

2
00:00:02.100 --> 00:00:02.910
How was it?

3
00:00:02.940 --> 00:00:03.810
Did you get it?

4
00:00:03.840 --> 00:00:05.130
Was it a tough question?

5
00:00:06.939 --> 00:00:10.870
Don't get too disappointed if you weren't able to get the answer.

6
00:00:10.990 --> 00:00:14.110
These questions are meant to be tough to stretch your mind.

7
00:00:14.140 --> 00:00:17.410
If there were too simple, then you wouldn't be learning anything.

8
00:00:22.710 --> 00:00:25.620
Let's start off with the naive approach.

9
00:00:25.620 --> 00:00:28.590
That is the approach that first comes to mind.

10
00:00:29.600 --> 00:00:35.690
For me, the very first one is going to be a nested for loop.

11
00:00:36.320 --> 00:00:37.610
Let's have a function.

12
00:00:37.610 --> 00:00:39.170
I'm going to call it first.

13
00:00:42.510 --> 00:00:44.610
Recurring character.

14
00:00:45.890 --> 00:00:47.630
It's going to receive an input.

15
00:00:48.440 --> 00:00:53.030
And because we've already talked about it, I'm not going to do any input validation.

16
00:00:53.030 --> 00:00:57.560
We can just assume that we're always going to get some sort of a numbered array.

17
00:00:59.100 --> 00:01:02.550
In here, I'm going to loop again.

18
00:01:02.760 --> 00:01:05.610
And oh, boy, I've done this so many times by now.

19
00:01:05.610 --> 00:01:09.120
I hope you're getting sick and tired of just looping through arrays.

20
00:01:10.460 --> 00:01:14.540
But hey, now, at least we we are masters of loops.

21
00:01:18.720 --> 00:01:19.740
I plus.

22
00:01:19.740 --> 00:01:20.390
Plus.

23
00:01:21.300 --> 00:01:27.720
So in here, in the first loop, we're going to grab the first item in the array and let's just call

24
00:01:27.720 --> 00:01:31.950
this function so we have it here nice and easy.

25
00:01:33.220 --> 00:01:34.690
And gives us a nice visual.

26
00:01:35.630 --> 00:01:40.220
So I'm going to loop through the first item, then the fifth or the second.

27
00:01:40.220 --> 00:01:40.670
The third.

28
00:01:40.670 --> 00:01:41.090
The fourth.

29
00:01:41.090 --> 00:01:41.630
And keeps going.

30
00:01:41.660 --> 00:01:42.320
Keeps going.

31
00:01:42.860 --> 00:01:50.450
I want to grab this item and then do another loop and check to versus five to versus one, two versus

32
00:01:50.450 --> 00:01:53.270
two and then say, Oh, that's the one.

33
00:01:53.780 --> 00:02:01.160
If it doesn't find anything, it's going to go to the next five and then compare 5 to 1, 1 to 2, 2

34
00:02:01.160 --> 00:02:02.450
to 3 and so on.

35
00:02:03.220 --> 00:02:08.650
So once again, I'm just going to copy and paste this time because we have done a lot of four loops.

36
00:02:09.430 --> 00:02:15.010
And simply change the variable to be J.

37
00:02:15.370 --> 00:02:19.900
We're going to start at one because we don't want to compare 2 to 2.

38
00:02:19.930 --> 00:02:21.640
We want to compare 2 to 5.

39
00:02:21.670 --> 00:02:22.720
To start off.

40
00:02:23.780 --> 00:02:26.660
So we're just skipping a loop which will help us out.

41
00:02:27.860 --> 00:02:31.670
I'm going to say J here and J plus.

42
00:02:31.670 --> 00:02:32.200
Plus.

43
00:02:32.690 --> 00:02:35.510
Now, some of you may have been caught.

44
00:02:36.410 --> 00:02:43.790
Here because if we have it the way it is right now and you console.log this loop, you'll see that it

45
00:02:43.790 --> 00:02:51.770
won't work properly because every time this shifts, the outer for loop shifts from, let's say zero

46
00:02:51.770 --> 00:02:53.120
to next one.

47
00:02:53.120 --> 00:02:59.870
The one index j is going to be reset to one.

48
00:02:59.870 --> 00:03:06.920
So five is going to get compared to five and the function is going to assume five is the reoccurring

49
00:03:06.920 --> 00:03:07.610
character.

50
00:03:08.890 --> 00:03:14.410
So a little trick here is to do a plus one.

51
00:03:15.040 --> 00:03:22.090
That is, we always go one to the right of where is the first indexes.

52
00:03:22.360 --> 00:03:32.110
So if we're looping, looping and we're at here, the sub loop, the nested loop is going to look at

53
00:03:32.380 --> 00:03:34.210
a plus one.

54
00:03:34.210 --> 00:03:42.610
So it's going to compare 2 to 3, 2 to 5, two to I because well, we've already compared 2 to 2, 5

55
00:03:42.610 --> 00:03:46.120
to 1, 5 to 2, 1 to 2 in previous loops.

56
00:03:46.750 --> 00:03:49.570
All right, we've done that in here.

57
00:03:49.570 --> 00:03:53.140
We can simply do an if statement saying input.

58
00:03:53.470 --> 00:03:58.030
EI does that equal input J.

59
00:03:59.020 --> 00:04:02.280
Does two equals to five does two equal to one?

60
00:04:02.290 --> 00:04:03.760
Does two equal to two?

61
00:04:03.790 --> 00:04:04.300
Oh.

62
00:04:04.420 --> 00:04:08.290
If that equals, then just simply return input.

63
00:04:12.250 --> 00:04:17.800
Otherwise, if we do all this work and nothing happens, we can just return.

64
00:04:20.620 --> 00:04:21.339
Undefined.

65
00:04:22.920 --> 00:04:24.090
Let's see if that works.

66
00:04:24.180 --> 00:04:25.410
I'm going to run it.

67
00:04:26.270 --> 00:04:28.010
And I get two.

68
00:04:28.070 --> 00:04:28.760
Awesome.

69
00:04:29.460 --> 00:04:31.570
What if I change this to one?

70
00:04:31.590 --> 00:04:33.810
If I run this, I get one.

71
00:04:33.810 --> 00:04:34.460
Perfect.

72
00:04:34.470 --> 00:04:39.090
What if I do just a single item in an array?

73
00:04:39.270 --> 00:04:40.710
I get undefined.

74
00:04:40.740 --> 00:04:43.960
If I do an empty array, I get undefined.

75
00:04:43.980 --> 00:04:44.970
That's good.

76
00:04:45.000 --> 00:04:48.360
What if I do one, one or one one?

77
00:04:49.490 --> 00:04:52.070
I guess one that's great if I do one to.

78
00:04:53.100 --> 00:04:54.360
I get undefined.

79
00:04:54.540 --> 00:04:55.160
Awesome.

80
00:04:55.170 --> 00:04:56.610
This looks to be working.

81
00:04:56.730 --> 00:05:02.940
Nice and simple, but as you can see here, we're not being very efficient.

82
00:05:03.240 --> 00:05:06.450
We have nested loops which should trigger.

83
00:05:06.450 --> 00:05:08.820
Oh, this is O of NW squared.

84
00:05:13.270 --> 00:05:19.900
And although technically we're actually always looping a little bit more efficient because of AI plus

85
00:05:19.900 --> 00:05:24.670
AI, we're not looping twice over the entire array.

86
00:05:25.420 --> 00:05:31.810
In the end, when you remove the constants and simplify things, it's still going to be o of rn squared.

87
00:05:32.350 --> 00:05:36.070
So how can we solve this using hash tables?

88
00:05:37.290 --> 00:05:39.900
Well, let's create a new.

89
00:05:40.990 --> 00:05:41.860
Function.

90
00:05:43.060 --> 00:05:46.620
We'll call this function by the same name this time.

91
00:05:46.630 --> 00:05:48.460
Number two, version two.

92
00:05:49.260 --> 00:05:50.910
It's going to receive an input.

93
00:05:54.350 --> 00:05:59.570
And let's change our test case to have the same thing.

94
00:06:03.360 --> 00:06:04.650
Like we did previously.

95
00:06:05.390 --> 00:06:06.590
What can we do here?

96
00:06:07.480 --> 00:06:09.640
Well, let's use a.

97
00:06:10.240 --> 00:06:11.170
Hash table.

98
00:06:11.850 --> 00:06:20.700
Or an object to do something interesting that is to add these all these as we iterate one by one.

99
00:06:20.700 --> 00:06:24.600
So loop through all the items, add them to a hash table.

100
00:06:24.930 --> 00:06:32.610
And while we're doing that, we can check to see if the property already exists or the key already exists.

101
00:06:33.430 --> 00:06:38.560
We add two to the hash table, then five to the hash table, then one to the hash table.

102
00:06:38.560 --> 00:06:45.130
And when we try to add two, we can trigger a warning saying, hmm, we already have two as a key.

103
00:06:46.310 --> 00:06:49.070
So using that logic, let's see how we can implement it.

104
00:06:49.890 --> 00:06:52.760
I'm going to create a map.

105
00:06:52.770 --> 00:06:58.950
We'll just call it a hash map for now, because the keys are going to be unique.

106
00:06:58.980 --> 00:07:02.490
It's not going to let any duplicate keys.

107
00:07:04.120 --> 00:07:07.390
And we can simply do our loops.

108
00:07:13.490 --> 00:07:18.080
And in this loop, all we're going to do is say if.

109
00:07:19.570 --> 00:07:20.350
Map.

110
00:07:21.450 --> 00:07:25.500
And we can check in this map if it's empty.

111
00:07:26.730 --> 00:07:35.130
Now the first check in here, I want to say if the property or if the key already exists, I want to

112
00:07:35.130 --> 00:07:39.480
just return the item.

113
00:07:40.270 --> 00:07:49.810
Because we don't need to do any more work as soon as we find a key that already exists in our hash table.

114
00:07:49.960 --> 00:07:52.660
Stop all the looping and just return.

115
00:07:52.690 --> 00:07:55.200
In this case, we want to return to.

116
00:07:55.210 --> 00:07:59.650
So to index zero one, two, three.

117
00:08:00.250 --> 00:08:07.540
It's going to return and say two because well, this key already exists.

118
00:08:08.980 --> 00:08:14.440
So the way we do that in the if check is to simply say if input.

119
00:08:15.500 --> 00:08:15.950
I.

120
00:08:15.980 --> 00:08:21.230
Because remember, this is going to equal to two when we look through it.

121
00:08:23.250 --> 00:08:27.270
If that exists, then return.

122
00:08:28.070 --> 00:08:33.080
Otherwise we will just add it to our map.

123
00:08:33.200 --> 00:08:35.450
So input I.

124
00:08:37.500 --> 00:08:38.669
Is going to equal.

125
00:08:39.480 --> 00:08:41.370
And the value can be anything.

126
00:08:41.370 --> 00:08:44.370
We'll just leave it at AI, which is the index.

127
00:08:44.610 --> 00:08:47.280
So two is going to equal zero.

128
00:08:47.280 --> 00:08:48.810
Five is going to equal one.

129
00:08:48.810 --> 00:08:52.110
One is going to have to.

130
00:08:53.250 --> 00:08:56.610
Let's just console.log here to see what is happening.

131
00:08:56.610 --> 00:09:06.360
But I want to also return undefined at the end in case none of this happens, in case there is no match.

132
00:09:07.050 --> 00:09:12.720
So at the end of the four loop, we'll just console log nap.

133
00:09:13.990 --> 00:09:15.850
And see what we have.

134
00:09:15.880 --> 00:09:16.960
I'm going to run.

135
00:09:17.900 --> 00:09:20.270
And I get five, huh?

136
00:09:20.300 --> 00:09:22.160
And there's no log.

137
00:09:22.190 --> 00:09:23.420
What just happened here?

138
00:09:23.930 --> 00:09:32.810
Well, if we console, log up here instead and take a look at what this is giving us.

139
00:09:36.220 --> 00:09:41.770
And run, I get undefined, undefined, undefined zero undefined one.

140
00:09:43.340 --> 00:09:44.330
What does that mean?

141
00:09:44.690 --> 00:09:51.890
Well, remember, we're looping through here and we're saying, Hey, does.

142
00:09:53.010 --> 00:10:01.200
To exist does input zero, which is to exist as a key.

143
00:10:01.860 --> 00:10:05.430
So it's simply saying map dot two.

144
00:10:06.180 --> 00:10:07.740
Does it exist?

145
00:10:07.920 --> 00:10:11.670
And because that doesn't exist, we get undefined.

146
00:10:13.270 --> 00:10:14.980
And it's going to go to next.

147
00:10:14.980 --> 00:10:16.090
Hey, does five exist?

148
00:10:16.120 --> 00:10:17.030
No, it doesn't.

149
00:10:17.050 --> 00:10:19.060
Hey, does one exist?

150
00:10:19.090 --> 00:10:20.140
No, it doesn't.

151
00:10:20.170 --> 00:10:22.080
Hey, does two exist?

152
00:10:22.090 --> 00:10:25.510
And as soon as it checks to again.

153
00:10:26.460 --> 00:10:27.270
Map.

154
00:10:28.000 --> 00:10:28.810
To.

155
00:10:29.800 --> 00:10:32.590
It's going to say, Ah, I already have it.

156
00:10:32.620 --> 00:10:36.220
It's at index of zero.

157
00:10:37.500 --> 00:10:40.200
So this is working.

158
00:10:40.440 --> 00:10:42.300
However, because.

159
00:10:42.970 --> 00:10:48.610
When this gets to zero, the way JavaScript works it.

160
00:10:49.710 --> 00:10:58.110
Puts zero here, but in an if statement, zero is what we call falsely in JavaScript, and that has

161
00:10:58.110 --> 00:11:03.420
to do with type caution in JavaScript, something that a lot of people get annoyed about with the language.

162
00:11:03.750 --> 00:11:12.690
So what we would need to do is to make sure that we, we specify that we want this to not equal on define.

163
00:11:12.690 --> 00:11:17.460
So as soon as it doesn't equal undefined, I want you to return this item.

164
00:11:18.580 --> 00:11:22.810
Now, if we run this, we get to.

165
00:11:22.990 --> 00:11:24.130
Which is great.

166
00:11:25.370 --> 00:11:32.600
If we console dot log the map and run this and.

167
00:11:33.330 --> 00:11:34.860
Let's add it at the bottom here.

168
00:11:34.860 --> 00:11:37.350
So we see the actual iteration that's happening.

169
00:11:38.830 --> 00:11:46.150
We see that it adds to an index of zero, then to an index of zero and five, index of one.

170
00:11:46.480 --> 00:11:47.860
So on and so forth.

171
00:11:47.860 --> 00:11:55.960
Until it stops after the third loop because it encounters two again, it's going to check and say oh

172
00:11:55.990 --> 00:11:58.690
two already exists, just return it.

173
00:11:59.850 --> 00:12:00.960
How cool is that?

174
00:12:01.080 --> 00:12:06.360
We just made this entire thing with just one loop.

175
00:12:07.410 --> 00:12:12.630
That is way faster than our first version using hash tables.

176
00:12:12.900 --> 00:12:15.300
How cool is that for me?

177
00:12:15.300 --> 00:12:23.520
Doing things like this and seeing the power of how learning about big O and hash tables has improved.

178
00:12:23.520 --> 00:12:29.100
Our coding ability just gets me really, really excited and I hope this gets you excited as well.

179
00:12:29.130 --> 00:12:36.360
We made this function have a time complexity of oh, then we've improved it with one downside.

180
00:12:36.360 --> 00:12:46.620
We've increased the memory, the space complexity by O of n because we're creating a new object in this

181
00:12:46.620 --> 00:12:50.730
function that needs to keep track of all the items in the array.

182
00:12:50.730 --> 00:12:57.000
And in the worst case, when there is no match, it's going to go through the entire item list of the

183
00:12:57.000 --> 00:12:59.670
array and hold that information in the map.

184
00:12:59.670 --> 00:13:06.210
So we're also going to have like this version where we didn't create any space complexity.

185
00:13:06.660 --> 00:13:11.100
We just had space complexity of of one.

186
00:13:11.460 --> 00:13:16.830
We now have a little bit more, but in turn, we have a faster function.

187
00:13:18.060 --> 00:13:19.500
Very, very cool.

188
00:13:19.620 --> 00:13:24.330
Now to finish off, I want to give you one last challenge.

189
00:13:24.810 --> 00:13:32.880
You see, looking at these two implementations, what happens if we have something like.

190
00:13:33.580 --> 00:13:34.210
This.

191
00:13:35.720 --> 00:13:40.670
What do you think the first recurring character is?

192
00:13:41.090 --> 00:13:42.650
If I run this.

193
00:13:43.830 --> 00:13:45.510
I get five?

194
00:13:46.150 --> 00:13:47.140
Because.

195
00:13:47.820 --> 00:13:49.140
Well, five.

196
00:13:49.890 --> 00:13:56.580
Occurs sooner than two to because of the way we implemented the second function.

197
00:13:56.970 --> 00:14:04.530
However, if I go to the first version of our function and run this, I get to.

198
00:14:06.090 --> 00:14:06.450
Hmm.

199
00:14:06.480 --> 00:14:07.410
Why is that?

200
00:14:08.250 --> 00:14:15.090
Well, if we go to the very first part of our function, we see that the way we are doing things is

201
00:14:15.090 --> 00:14:18.420
we are going one by one in a different way.

202
00:14:18.960 --> 00:14:25.350
We're saying grap two and then compare it to with five, then five, then two, then three, then five,

203
00:14:25.380 --> 00:14:32.720
then one and two, four, and then move over to five, then five and five and two and so on and so forth.

204
00:14:32.730 --> 00:14:40.020
And because of the way we have that implemented, it's going to detect two and two because the outer

205
00:14:40.020 --> 00:14:43.500
loop has an index of zero and has.

206
00:14:44.280 --> 00:14:47.580
Two as it's going through the loop.

207
00:14:48.920 --> 00:14:59.030
Before it compares five with five versus our second version with a hash table where we had all these

208
00:14:59.030 --> 00:15:04.190
items and we were able to compare them once we grabbed all of them.

209
00:15:05.020 --> 00:15:11.590
And that's another powerful thing when you think about arrays and hash tables and how you're able to

210
00:15:11.590 --> 00:15:12.580
compare things.

211
00:15:12.580 --> 00:15:18.340
And based on what the interviewer asked, you might have a wrong answer.

212
00:15:18.340 --> 00:15:23.620
Maybe they want you to detect five and five before you detect two and two.

213
00:15:24.290 --> 00:15:32.330
So my bonus question to you, if you have time and a bit of a challenge is to convert this function

214
00:15:32.330 --> 00:15:33.260
if you want.

215
00:15:33.920 --> 00:15:39.830
Into something that matches the answer to this, that is to detect five and five.

216
00:15:41.120 --> 00:15:43.550
How would you go about doing that?

217
00:15:43.970 --> 00:15:47.540
You're most likely going to have to do something interesting here.

218
00:15:48.730 --> 00:15:50.200
So good luck with that.

219
00:15:50.860 --> 00:15:55.180
Talk to other people on discord in our community and see if you can figure it out.

220
00:15:55.180 --> 00:16:03.340
And I'll post some creative solutions to that problem as students, submit them to see how other people

221
00:16:03.340 --> 00:16:04.480
have implemented this.

222
00:16:05.220 --> 00:16:07.890
But for now, I think we deserve a break.

223
00:16:08.160 --> 00:16:09.300
I'll see you in the next one.

224
00:16:09.870 --> 00:16:10.410
Bye bye.

