WEBVTT
1
00:00:00.750 --> 00:00:03.719
What about depth for search in graphs?

2
00:00:04.740 --> 00:00:12.270
You might not know it, but you just learned how to solve a maze using programming because depth first

3
00:00:12.270 --> 00:00:16.860
search is exactly like solving a maze, right?

4
00:00:17.100 --> 00:00:23.370
If you've ever done a real life maze yourself or looked at a program that tries to solve which path

5
00:00:23.370 --> 00:00:27.750
to take, the idea was to go as deep as you can.

6
00:00:27.750 --> 00:00:33.750
And when you hit a roadblock or a place where you can't go anymore, you backtrack and find a different

7
00:00:33.750 --> 00:00:34.260
route.

8
00:00:34.860 --> 00:00:40.530
And then you keep backtracking until you find the desired node or you exit the maze.

9
00:00:41.490 --> 00:00:44.610
And that's the beauty of depth for search.

10
00:00:44.700 --> 00:00:50.160
You can now implement an algorithm that solves a maze puzzle.

11
00:00:50.220 --> 00:00:51.240
Isn't that cool?

12
00:00:51.900 --> 00:00:57.840
Just like in here, if we do a desperate search, let's say we're starting at number one.

13
00:00:58.470 --> 00:01:02.160
And ten is the exit or.

14
00:01:02.190 --> 00:01:03.600
Nine is the exit.

15
00:01:04.140 --> 00:01:11.940
And actually one won't work because this unlike our previous graph which was undirected, that is it

16
00:01:11.970 --> 00:01:12.990
had both directions.

17
00:01:12.990 --> 00:01:14.370
I can go back and forth.

18
00:01:14.370 --> 00:01:19.190
This one is a directed graph that has specific directions that it can go.

19
00:01:19.200 --> 00:01:21.150
So let's do 0 to 9.

20
00:01:21.690 --> 00:01:28.100
If I do depth for a search and do nine or we'll start at zero trying to find nine.

21
00:01:28.170 --> 00:01:29.880
Just like looking through a maze.

22
00:01:29.880 --> 00:01:32.130
I go here, I go here.

23
00:01:32.130 --> 00:01:39.450
I keep going through my children and then try and go as deep as I can and I manage to get out of the

24
00:01:39.450 --> 00:01:42.900
maze before I even search six and five over here.

25
00:01:44.280 --> 00:01:48.450
And obviously this algorithm keeps going because I didn't tell it to stop at nine.

26
00:01:48.450 --> 00:01:52.680
But you see how it was exactly like solving a maze.

27
00:01:53.550 --> 00:01:56.550
And that's why we use recursion for depth for search.

28
00:01:56.550 --> 00:01:57.030
Right.

29
00:01:58.000 --> 00:02:06.400
The idea of backtracking after a dead end and then repeating the walk down another path is just recursion.

30
00:02:07.180 --> 00:02:08.830
Each step smaller than the other.

31
00:02:08.830 --> 00:02:12.400
And then we go back and then keep doing the same thing over and over.

32
00:02:13.390 --> 00:02:19.660
The idea of death for research is that it's really good at saying, does the path exist?

33
00:02:20.320 --> 00:02:25.120
It doesn't tell us the shortest path, but whether it even exists.

34
00:02:25.270 --> 00:02:29.080
And it uses less memory than death for search.

35
00:02:29.830 --> 00:02:37.810
The one downside with it is that if you have a really, really deep graph, then it can get very slow

36
00:02:37.810 --> 00:02:45.610
because the deeper the graph, the more recursive calls, the more space complexity you add because

37
00:02:45.610 --> 00:02:49.060
we have to keep track of those function calls on a stack.

