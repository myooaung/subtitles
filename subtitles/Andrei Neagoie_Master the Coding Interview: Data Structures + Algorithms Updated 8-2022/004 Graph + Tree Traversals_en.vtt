WEBVTT
1
00:00:00.810 --> 00:00:04.530
There are times when we want to do something called traversal.

2
00:00:05.350 --> 00:00:11.980
And the name traversal and search is often used interchangeably, sometimes meaning the same thing,

3
00:00:11.980 --> 00:00:12.910
sometimes not.

4
00:00:13.980 --> 00:00:20.190
Up until now, we talked about binary search trees and we knew what we were looking for and we always

5
00:00:20.190 --> 00:00:22.380
knew where to go left or right.

6
00:00:23.850 --> 00:00:27.600
But other times we want to do some operations on the same note.

7
00:00:27.810 --> 00:00:32.340
As I mentioned before, we might want to add a color property to this note.

8
00:00:32.460 --> 00:00:41.040
Perhaps if we had a user node, we want to add an H property to all our users that are in a tree structure.

9
00:00:41.040 --> 00:00:44.400
Perhaps we want to add a shape property to these nodes.

10
00:00:45.820 --> 00:00:50.440
Or perhaps we don't have a sorted tree.

11
00:00:50.950 --> 00:00:52.810
It's not a binary search tree.

12
00:00:52.840 --> 00:00:59.230
Or we have a graph that has no order to it, in which case we have to visit every node.

13
00:00:59.770 --> 00:01:06.130
Or maybe we're working at Google and our boss asks us to, hey, can you check if our binary search

14
00:01:06.130 --> 00:01:13.210
tree we entered into our database is correct and that it's actually valid and making sure that the left

15
00:01:13.210 --> 00:01:16.390
item is always lower than the right item.

16
00:01:17.180 --> 00:01:21.680
And in order for us to check that, we have to touch every single node.

17
00:01:22.220 --> 00:01:24.710
But how will we go about doing this?

18
00:01:24.830 --> 00:01:28.760
You can think of traversal as a visiting every note.

19
00:01:29.530 --> 00:01:36.250
And as you can imagine, because we're visiting every node that's an O of an operation, linear time.

20
00:01:36.820 --> 00:01:44.770
Up until now, we did loops to visit all of our other data structures, like arrays, link lists, hash

21
00:01:44.770 --> 00:01:47.650
tables, queues, stacks.

22
00:01:48.100 --> 00:01:56.260
So how do we go about doing this in a data structure like a tree or even a graph?

23
00:01:56.930 --> 00:02:01.040
Well, luckily for us, there's two ways of doing this that we need to learn.

24
00:02:01.520 --> 00:02:02.270
One.

25
00:02:03.330 --> 00:02:04.890
It's right over here.

26
00:02:05.220 --> 00:02:11.250
Do we have to do a tree traversal or do we have to do a graph traversal?

27
00:02:12.040 --> 00:02:15.070
In that case, our two options are the exact same.

28
00:02:18.360 --> 00:02:25.710
We have breadth for search and depth for search, and sometimes this is called traversal instead of

29
00:02:25.710 --> 00:02:26.290
search.

30
00:02:26.310 --> 00:02:30.930
As you can see, both with trees and graphs, it's the same thing.

31
00:02:31.710 --> 00:02:39.180
The big o is O of NW because we have to visit every single node using these two techniques.

32
00:02:39.600 --> 00:02:46.530
But let's review why this is important and why we don't store everything in just lists which are simpler

33
00:02:46.530 --> 00:02:47.370
to understand.

34
00:02:48.090 --> 00:02:55.830
Well, the main benefit of why we don't put complex data into just lists like arrays that are sorted.

35
00:02:56.790 --> 00:03:01.080
Is that we get the o of log n searching.

36
00:03:02.420 --> 00:03:03.890
What about hash tables?

37
00:03:03.920 --> 00:03:05.060
Those are easy.

38
00:03:05.150 --> 00:03:08.240
Well, remember that hash tables aren't order.

39
00:03:08.480 --> 00:03:14.460
And at the end of the day, we represent data with different data structures based on their needs.

40
00:03:14.480 --> 00:03:20.410
And trees and grass work really well for a lot of cases, which we've already discussed.

41
00:03:20.420 --> 00:03:26.990
When we search for things, we have the benefit, but also when we insert or delete items, we have

42
00:03:26.990 --> 00:03:33.860
better performance than something like an array, but we also maintain the order that we wouldn't have

43
00:03:33.860 --> 00:03:35.300
otherwise with hash tables.

44
00:03:35.870 --> 00:03:42.590
Trees and graphs are used a lot when we want to search nodes or visit every node, and it represents

45
00:03:42.590 --> 00:03:46.310
a lot of data that models the real world.

46
00:03:46.640 --> 00:03:52.010
Now let's explore how these two traversal techniques work.

47
00:03:52.840 --> 00:03:53.860
I'll see you in the next one.

