WEBVTT
1
00:00:01.200 --> 00:00:02.070
Welcome back.

2
00:00:02.550 --> 00:00:06.370
Let's start off with the very first item on our list.

3
00:00:06.390 --> 00:00:10.230
Bubble sort sounds kind of playful and nice, right?

4
00:00:11.010 --> 00:00:18.760
Bubble sort is part of these first three sorting algorithms here that are called elementary sorts.

5
00:00:18.780 --> 00:00:25.860
They're very simple basic sorting algorithms that you would usually think of if somebody asked you to

6
00:00:25.860 --> 00:00:27.870
sort something at the top of your head.

7
00:00:28.440 --> 00:00:35.010
The second item here that we're going to get into later merge, short and quicksort are more complex

8
00:00:35.190 --> 00:00:39.270
algorithms that most of the time can be more efficient than the first ones.

9
00:00:39.810 --> 00:00:43.500
But to build that Lego block, let's start off with bubble sort.

10
00:00:43.950 --> 00:00:46.290
How does bubble sort work?

11
00:00:47.540 --> 00:00:49.820
Well, let me ask you a question.

12
00:00:49.940 --> 00:00:57.290
If I gave you a list and I asked you to sort it in your head, imagining that you had blocks of these

13
00:00:57.290 --> 00:01:00.140
letters, how would you move them around?

14
00:01:00.170 --> 00:01:04.160
Or how would you tell a computer to move them around to sort it?

15
00:01:05.290 --> 00:01:08.800
And Bubble Sword might be one of the first things that comes into mind.

16
00:01:09.220 --> 00:01:17.650
You see, Bubble Sword comes from the idea of bubbling up the largest value using multiple pass through.

17
00:01:17.950 --> 00:01:19.450
Let's see what I mean by that.

18
00:01:19.540 --> 00:01:21.580
We look at six and five.

19
00:01:22.800 --> 00:01:25.800
And then say six is larger than five.

20
00:01:26.130 --> 00:01:30.810
And then we look at six and three and say six is larger than three, let's swap them out.

21
00:01:31.200 --> 00:01:35.100
Then we look at six and one and once again six is larger than one.

22
00:01:35.100 --> 00:01:36.150
Let's swap them out.

23
00:01:36.210 --> 00:01:39.660
We look at six and eight, eight is larger than six.

24
00:01:39.660 --> 00:01:43.920
So keep it the way it is and let's move on to the next one, eight and seven.

25
00:01:43.920 --> 00:01:44.810
Let's swap them out.

26
00:01:44.820 --> 00:01:50.720
Eight is larger than seven, eight and two, swap them out, eight and four swap them out.

27
00:01:50.730 --> 00:01:55.470
We bubble up the highest number and then we go from the beginning.

28
00:01:55.900 --> 00:01:56.980
Five and three.

29
00:01:58.140 --> 00:02:01.290
Five and one, we bubble up the largest number.

30
00:02:01.290 --> 00:02:02.790
So that seven comes next.

31
00:02:04.260 --> 00:02:05.220
Then we keep going.

32
00:02:05.220 --> 00:02:07.980
Keep going until six comes next.

33
00:02:08.009 --> 00:02:11.070
Then we keep looping until we bubble up.

34
00:02:11.610 --> 00:02:19.410
The highest number one by one, one by one, until we have a sorted list that is bubble sort.

35
00:02:19.440 --> 00:02:22.740
Now, before we even code this, what do you think of bubble sort?

36
00:02:23.580 --> 00:02:27.480
As you might have guessed, it's not the most efficient, is it?

37
00:02:27.900 --> 00:02:29.700
Look at how many comparisons we did.

38
00:02:29.700 --> 00:02:31.230
And everything was one by one.

39
00:02:31.230 --> 00:02:37.920
Looping and looping and looping and bubble sort is one of the simplest sorting algorithm, but also

40
00:02:37.920 --> 00:02:39.850
one of the least efficient.

41
00:02:39.870 --> 00:02:42.860
So don't hate me for showing you how this works.

42
00:02:42.870 --> 00:02:48.270
It's usually used as a learning tool, as the first step in learning a certain algorithm.

43
00:02:48.870 --> 00:02:55.050
What do you think the time, complexity and space complexity of this algorithm is the answer.

44
00:02:55.530 --> 00:02:58.050
Well, we can just use the big cheat sheet.

45
00:02:58.590 --> 00:03:06.360
If we look at bubble sort, we see that the cases that we're most interested in is the average and worst

46
00:03:06.360 --> 00:03:06.900
case.

47
00:03:06.900 --> 00:03:09.600
We see that it's O of n squared.

48
00:03:10.370 --> 00:03:13.280
With a space complexity of of one.

49
00:03:13.280 --> 00:03:15.800
We're not really creating any new data structures.

50
00:03:16.100 --> 00:03:21.260
We're just comparing items in nested loops one by one.

51
00:03:21.910 --> 00:03:26.080
But let's see it in code to see why this is over and squared.

52
00:03:27.120 --> 00:03:28.650
And I want to challenge you here.

53
00:03:28.650 --> 00:03:33.750
And the next video we're going to coat along the bubble sort algorithm.

54
00:03:34.290 --> 00:03:41.370
But if you want, go ahead and try implementing this on your own and see how your code matches up with

55
00:03:41.370 --> 00:03:42.690
mine in the next video.

56
00:03:43.200 --> 00:03:44.160
I'll see you on that one.

