WEBVTT
1
00:00:01.140 --> 00:00:01.650
[Autogenerated] all right.

2
00:00:01.650 --> 00:00:03.270
Here we are in visual studio code,

3
00:00:03.270 --> 00:00:08.040
and for this exercise we are going into nine cf template.

4
00:00:08.040 --> 00:00:10.340
Go ahead and expand that out.

5
00:00:10.340 --> 00:00:12.320
And let's take a look at what's in commands.

6
00:00:12.320 --> 00:00:13.940
Txt.

7
00:00:13.940 --> 00:00:15.420
Well, there's not a lot to this one.

8
00:00:15.420 --> 00:00:18.700
We're going through the standard terra form workflow of Terra form in it.

9
00:00:18.700 --> 00:00:19.730
Plan and apply.

10
00:00:19.730 --> 00:00:22.100
And we're gonna be using that same state bucket that

11
00:00:22.100 --> 00:00:24.020
we used in the previous exercise.

12
00:00:24.020 --> 00:00:27.640
So we'll have to fill out that information when we get to that point.

13
00:00:27.640 --> 00:00:32.040
Let's take a look at what's going on in Maine TF.

14
00:00:32.040 --> 00:00:34.040
All right in Maine, .NET E f.

15
00:00:34.040 --> 00:00:36.340
We're setting up a few things here,

16
00:00:36.340 --> 00:00:39.980
the region and aws bucket prefix because we're going to

17
00:00:39.980 --> 00:00:42.670
create a bucket and we'll see why in a moment.

18
00:00:42.670 --> 00:00:47.400
And then we are going to be referencing the Dev VPC

19
00:00:47.400 --> 00:00:49.590
Network State to get some information.

20
00:00:49.590 --> 00:00:52.430
So we need to do the network state bucket network,

21
00:00:52.430 --> 00:00:57.840
state key and network state region, just like we did in the previous exercise,

22
00:00:57.840 --> 00:00:59.080
scrolling down a little bit more,

23
00:00:59.080 --> 00:01:03.960
we are going to generate a bucket name that will be used to store our lambda

24
00:01:03.960 --> 00:01:08.120
function so we're gonna use the bucket prefix dash lambda and then the random

25
00:01:08.120 --> 00:01:11.490
integer that we generate below under providers.

26
00:01:11.490 --> 00:01:15.190
The only notable thing here is we're using the app profile so again were

27
00:01:15.190 --> 00:01:19.280
functioning as Joshua Magee scrolling down to data sources.

28
00:01:19.280 --> 00:01:22.120
We're using the Terra form remote state data source.

29
00:01:22.120 --> 00:01:25.970
It's exactly the same as the one we just used for the previous exercise.

30
00:01:25.970 --> 00:01:30.140
We're getting that network information from the Dev VPC.

31
00:01:30.140 --> 00:01:31.260
It's going down a little bit more.

32
00:01:31.260 --> 00:01:35.450
We generate that random integer and then we deploy an S3 bucket.

33
00:01:35.450 --> 00:01:36.190
And like I said,

34
00:01:36.190 --> 00:01:41.580
this is going to hold the Lambda Function code because the CloudFormation

35
00:01:41.580 --> 00:01:45.540
template assumes that the code is sitting in an S3 bucket.

36
00:01:45.540 --> 00:01:47.490
So we have to provide that information to it.

37
00:01:47.490 --> 00:01:49.640
And this is something that the template didn't do before.

38
00:01:49.640 --> 00:01:52.340
So we're actually adding a little value through terra form.

39
00:01:52.340 --> 00:01:53.440
How about that?

40
00:01:53.440 --> 00:01:58.730
Once we deploy that S3 bucket, we are going to put an object into that S3 bucket,

41
00:01:58.730 --> 00:02:01.430
and that is the published orders dot zip file,

42
00:02:01.430 --> 00:02:04.700
which is in the same directory as this configuration.

43
00:02:04.700 --> 00:02:06.830
So we're gonna push that up to the bucket.

44
00:02:06.830 --> 00:02:10.440
So then it's accessible to our CloudFormation template,

45
00:02:10.440 --> 00:02:12.110
scrolling down a little bit more.

46
00:02:12.110 --> 00:02:14.870
The Lambda also requires a security group which is

47
00:02:14.870 --> 00:02:16.360
not created inside the template.

48
00:02:16.360 --> 00:02:18.170
So again, terra form to the rescue.

49
00:02:18.170 --> 00:02:21.280
We're creating that security group for Lambda,

50
00:02:21.280 --> 00:02:26.660
and we're using the terra form remote state data source to get the VPC

51
00:02:26.660 --> 00:02:30.540
IDE where this security group should be created.

52
00:02:30.540 --> 00:02:32.430
Now let's scroll down a little bit more and we get

53
00:02:32.430 --> 00:02:35.240
into the actual stack deployment.

54
00:02:35.240 --> 00:02:37.940
The name we're giving it is orders Dash stack,

55
00:02:37.940 --> 00:02:40.460
and then we have an argument called capabilities,

56
00:02:40.460 --> 00:02:44.040
and this enables certain capabilities on the stack.

57
00:02:44.040 --> 00:02:45.440
Within the template.

58
00:02:45.440 --> 00:02:47.760
We are going to be creating an I am role.

59
00:02:47.760 --> 00:02:52.740
So we have to give it the capability of capability underscore I am.

60
00:02:52.740 --> 00:02:57.740
Once we do that, the CloudFormation stack will be able to create that resource.

61
00:02:57.740 --> 00:03:00.000
Then we have to feed it the parameters that we're

62
00:03:00.000 --> 00:03:01.500
going to be using with the template,

63
00:03:01.500 --> 00:03:04.860
which includes the bucket where the function is located,

64
00:03:04.860 --> 00:03:08.640
the key where that function is located inside the bucket,

65
00:03:08.640 --> 00:03:11.250
the Lambda security group that we just created,

66
00:03:11.250 --> 00:03:14.730
and then a list of sub net IDs where Lambda should place

67
00:03:14.730 --> 00:03:17.100
those network interfaces and in this case,

68
00:03:17.100 --> 00:03:20.040
we wanted in the public sub nets.

69
00:03:20.040 --> 00:03:24.350
The interesting thing here is we're using the joint function because the

70
00:03:24.350 --> 00:03:30.240
template expects a comma delimited string off sub net IDs.

71
00:03:30.240 --> 00:03:35.030
The data type that's returned by public sub nets is a list, not a string.

72
00:03:35.030 --> 00:03:39.540
The join function converts a list to a string,

73
00:03:39.540 --> 00:03:42.990
and it separates the elements of the list using the delimit ER.

74
00:03:42.990 --> 00:03:44.640
That's the first argument in the joint,

75
00:03:44.640 --> 00:03:50.340
so we're basically creating that comma separated string for sub net IDs.

76
00:03:50.340 --> 00:03:52.420
Then the very last thing is submitting.

77
00:03:52.420 --> 00:03:56.370
The template body were using the file function to reference the lambda dot

78
00:03:56.370 --> 00:04:00.540
template file that's in the same directory as this configuration.

79
00:04:00.540 --> 00:04:01.050
Lastly,

80
00:04:01.050 --> 00:04:03.690
just to show that you have access to the output

81
00:04:03.690 --> 00:04:07.820
from that CloudFormation template, we're specifying a single output here.

82
00:04:07.820 --> 00:04:12.040
And it's all the outputs from this stack deployment.

83
00:04:12.040 --> 00:04:14.940
Alright, so that's everything in the main .NET e f.

84
00:04:14.940 --> 00:04:18.570
In the back end dot t f were simply defining that we're using S3,

85
00:04:18.570 --> 00:04:27.000
and the key is lambda slash terra form dot t f state. Now let's take a look at what's going on in that lambda template

