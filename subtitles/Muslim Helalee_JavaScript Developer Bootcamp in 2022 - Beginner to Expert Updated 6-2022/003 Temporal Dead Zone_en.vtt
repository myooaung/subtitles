WEBVTT
1
00:00:00.980 --> 00:00:01.950
Hi, everyone.

2
00:00:01.970 --> 00:00:06.230
In this lecture, we are going to talk about the temporal dead zone.

3
00:00:07.610 --> 00:00:14.750
All right, now, before diving into this lecture, I got to say that the temporal dead zone is not

4
00:00:14.750 --> 00:00:16.960
a walking dead reference.

5
00:00:17.210 --> 00:00:18.500
It is a programming thing.

6
00:00:18.890 --> 00:00:24.410
It doesn't relate to walking dead or right or any kind of zombie movie.

7
00:00:24.420 --> 00:00:27.160
So it is just a programming thing.

8
00:00:27.680 --> 00:00:33.680
And in this course, it is a JavaScript thing that we are going to go over right now.

9
00:00:34.430 --> 00:00:40.490
I just want to show you I just wanted to give you this specification at some point in the course and

10
00:00:40.490 --> 00:00:41.250
why not here?

11
00:00:41.570 --> 00:00:51.680
So this is a model international dot org slash dash to Sixta slash and this is ECMAScript 2020 language

12
00:00:51.680 --> 00:00:52.850
specification.

13
00:00:53.000 --> 00:00:58.520
And the most popular implementation of this specification is JavaScript.

14
00:00:59.150 --> 00:01:01.730
Now, this is ECMAScript.

15
00:01:01.970 --> 00:01:09.910
That's where the E to 2015 is 2016, all the way to 2020.

16
00:01:10.730 --> 00:01:15.550
All of these different versions of JavaScript they get their name from.

17
00:01:15.860 --> 00:01:22.280
So you can call it E, you can grab the E and then the S and then you can call it ESX.

18
00:01:22.280 --> 00:01:24.980
iOS seven is eight all the way to 11.

19
00:01:26.370 --> 00:01:28.730
Or you could go ahead and say E.

20
00:01:29.060 --> 00:01:37.010
S 2015, 2016, which is the proper way of saying, OK, we have talked about this in our I think it

21
00:01:37.010 --> 00:01:41.630
was second chapter of this course way like before.

22
00:01:42.590 --> 00:01:49.400
So what I'm going to do is I'm going to show you where we can find Letton Corsicans declaration.

23
00:01:49.790 --> 00:01:57.840
But you should go over this spec if you're really serious about learning JavaScript and mastering JavaScript.

24
00:01:59.150 --> 00:02:00.560
There is a lot of things.

25
00:02:00.560 --> 00:02:05.570
There is like literally a ton of things here and you don't need to like, go ahead, Line-by-line.

26
00:02:05.570 --> 00:02:12.500
Whenever you hit a hurdle or you hit a bump, make sure you check it in the specification, because

27
00:02:12.860 --> 00:02:16.970
according to this specification, JavaScript is created.

28
00:02:16.970 --> 00:02:19.580
So JavaScript is created, JavaScript behaves.

29
00:02:19.580 --> 00:02:22.480
According to this ECMAScript specification.

30
00:02:22.940 --> 00:02:25.010
It is a JavaScript standard.

31
00:02:25.220 --> 00:02:27.110
So you should know what the standard is.

32
00:02:27.440 --> 00:02:37.310
And everything is everything that's written here is the authentic is the most authentic like like decision

33
00:02:37.310 --> 00:02:39.500
that is built on JavaScript.

34
00:02:39.530 --> 00:02:45.510
Okay, so this is the go to resource if you want to know how things work in JavaScript.

35
00:02:46.250 --> 00:02:51.830
OK, so there is going to be a lot of like weird stuff in here, but I'm going to make sure I'm going

36
00:02:51.830 --> 00:02:59.750
to try to go ahead and like explain it in simplest terms possible.

37
00:03:00.230 --> 00:03:00.590
All right.

38
00:03:00.600 --> 00:03:07.690
So what I'm going to do is we went into Chapter 13, ECMAScript language statements and declarations.

39
00:03:07.700 --> 00:03:09.470
So we want to talk about those.

40
00:03:09.950 --> 00:03:16.140
And I'm just going to click here and we can see that we have declarations and the variable statement.

41
00:03:16.550 --> 00:03:19.170
So this is thirteen point three, right.

42
00:03:19.440 --> 00:03:22.160
So, you know what?

43
00:03:22.160 --> 00:03:26.130
What I'm going to do is I'm just going to give you the spec in here as well.

44
00:03:26.150 --> 00:03:28.850
So so this is the original link for the spec.

45
00:03:28.850 --> 00:03:34.970
You can go ahead and check it out and you will find what it what it what it has.

46
00:03:34.970 --> 00:03:36.950
All the chapters are at your disposal.

47
00:03:38.330 --> 00:03:38.720
All right.

48
00:03:38.870 --> 00:03:44.780
So in here, what we have is lead and const declarations because they're different than Vahdat and they

49
00:03:44.780 --> 00:03:50.980
are they came after the as of 2015 is 2015.

50
00:03:51.290 --> 00:03:55.660
That's why they are inside like in one section.

51
00:03:56.450 --> 00:03:59.060
So here is where I'm going to prove to you.

52
00:03:59.060 --> 00:04:07.130
Prove to you that let and can they do hoist but they hoist in a different way because we know how var

53
00:04:07.130 --> 00:04:15.290
hoists not understood way, but the original way is that we have to process even though var is one statement,

54
00:04:15.290 --> 00:04:18.100
we have two passes for that statement.

55
00:04:18.350 --> 00:04:26.000
The first pass is that we find the identifier and the scope, which is the completion pass.

56
00:04:26.240 --> 00:04:34.190
And the second pass is whenever we get to the execution, which is the second pass, we grab the value

57
00:04:34.190 --> 00:04:40.830
of that identifier if it is in the target reference and we allocate a space in memory to it.

58
00:04:41.150 --> 00:04:44.570
So this is how variable declarations are getting executed.

59
00:04:44.900 --> 00:04:51.180
A verbal declaration is an executed executable piece of a line of code or a statement in code.

60
00:04:51.770 --> 00:04:57.220
That's why we go over them very, very deeply, because this is how all everything in JavaScript works.

61
00:04:57.950 --> 00:05:01.880
But the misconception, another there are a lot of them.

62
00:05:02.030 --> 00:05:06.410
But another one says declarations using leadon const are not.

63
00:05:06.660 --> 00:05:15.000
Are also not hoisted, it means that there are not two passes to let on, cause it means that whenever

64
00:05:15.000 --> 00:05:18.360
you say that I don't know, like let

65
00:05:21.000 --> 00:05:29.610
like no equal one to three, it is like a once in it is a statement and it has only one pass.

66
00:05:30.120 --> 00:05:33.810
But that is not accurate, even though it is let or consed.

67
00:05:34.140 --> 00:05:36.930
That statement also has two passes.

68
00:05:37.510 --> 00:05:37.860
Right.

69
00:05:37.980 --> 00:05:39.020
And it says it here.

70
00:05:39.030 --> 00:05:47.340
So it says Let uncaused declarations define variables that are Scob to their running execution contexts,

71
00:05:47.580 --> 00:05:49.220
lexical environment.

72
00:05:49.710 --> 00:05:54.480
That's why we see a lot of lexical environment, because JavaScript has a lexical environment.

73
00:05:54.480 --> 00:05:57.900
JavaScript is a lexically scoped language language.

74
00:05:59.010 --> 00:06:04.240
So that part is proven as well, even though it was clear the variables are created.

75
00:06:04.260 --> 00:06:06.930
Now, this is the part that we are interested in.

76
00:06:07.260 --> 00:06:15.840
The variables are created when they're containing lexical environment is in instantiated, but may not

77
00:06:15.840 --> 00:06:22.560
be accessed in any way until the variables lexical binding is evaluated.

78
00:06:23.410 --> 00:06:25.530
OK, so this is the line No.

79
00:06:25.530 --> 00:06:25.830
One.

80
00:06:26.010 --> 00:06:31.260
This is the first line that says that they do hoist.

81
00:06:31.260 --> 00:06:38.350
I'm going to explain to you how this line says that a variable defined by lexical binding with an initialism

82
00:06:38.430 --> 00:06:46.950
is assigned the value of its initialize assignment expression when the lexical binding is evaluated,

83
00:06:47.190 --> 00:06:49.410
not when the variable is created.

84
00:06:50.450 --> 00:07:00.320
So what it means that whenever we assign a value to a declaration using let and contest, the lexical

85
00:07:00.320 --> 00:07:09.590
binding only is evaluated when the assignment of that value is given, not when the variable is created.

86
00:07:09.620 --> 00:07:11.680
So there are two purposes here.

87
00:07:12.170 --> 00:07:19.650
The first passes when the variable is created, the second pass is when the lexical binding is evaluated.

88
00:07:20.280 --> 00:07:20.630
All right.

89
00:07:20.780 --> 00:07:28.040
So what I'm going to do here, I'm going to paste in a comment here and I'm going to explain to you

90
00:07:28.040 --> 00:07:32.110
what lexical Idont binding identifier, lexical binding, what these are.

91
00:07:32.480 --> 00:07:36.970
And I'm going to expand this a bit more so to here.

92
00:07:37.430 --> 00:07:41.360
So we have our lexical declaration, which is let or the context.

93
00:07:41.690 --> 00:07:43.670
Then we have our binding identifier.

94
00:07:43.700 --> 00:07:45.470
What is the binding identifier?

95
00:07:45.500 --> 00:07:52.600
It is our lexical binding and then we have our assignment operator and then we have the assignment expression.

96
00:07:53.060 --> 00:08:00.800
So the variable, it says here a variable is defined by a lexical binding.

97
00:08:01.190 --> 00:08:08.930
OK, when an initialise is assigned to the assigned the value of its initialisms assignment expression

98
00:08:09.410 --> 00:08:16.540
when now from here it says when the lexical binding is evaluated, not when the variable is created.

99
00:08:16.820 --> 00:08:18.500
So when the what does it mean?

100
00:08:18.500 --> 00:08:22.250
It means that when the variable is created up until this.

101
00:08:23.850 --> 00:08:30.630
The lexical binding is not evaluated, so it means this is the first pass and when does the lexical

102
00:08:30.630 --> 00:08:32.010
binding evaluate it?

103
00:08:32.010 --> 00:08:37.020
Is that is the second pass, which is that to that lexical binding?

104
00:08:37.020 --> 00:08:38.840
We assign this expression.

105
00:08:39.210 --> 00:08:41.520
So there are two passes as well.

106
00:08:42.010 --> 00:08:47.490
Now, I could go ahead and explain it five more times, but that would not make a difference here,

107
00:08:47.970 --> 00:08:58.860
because this is now this is proven according to the ECMAScript specification and OK, so and it also

108
00:08:58.860 --> 00:08:59.730
says it here.

109
00:08:59.730 --> 00:09:06.030
But generally these the variables are created when they're containing lexical environment is this is

110
00:09:06.180 --> 00:09:10.800
instantiated when there are lexical, when their block is created.

111
00:09:11.070 --> 00:09:17.670
So the variables, they are created when they have a block B, that block is a set of curly braces,

112
00:09:17.670 --> 00:09:25.950
or B, that block like the global scope, but may not be accessed in any way until the variables lexical

113
00:09:25.950 --> 00:09:27.200
binding is evaluated.

114
00:09:27.510 --> 00:09:35.270
So this but this creates the second step, the second process, the first process they're created,

115
00:09:35.490 --> 00:09:42.420
the second process they are accessed, but they should have the lexical binding evaluated.

116
00:09:43.500 --> 00:09:45.780
What is the lexical bindings evaluation?

117
00:09:46.020 --> 00:09:52.800
When the lexical bindings initialize or has an assignment expression, it means that when this identifier,

118
00:09:52.800 --> 00:09:54.990
it has assigned a value.

119
00:09:55.380 --> 00:09:57.330
That's when they are evaluated.

120
00:09:57.940 --> 00:09:58.180
Right.

121
00:09:58.250 --> 00:09:59.550
So there are two passes.

122
00:09:59.550 --> 00:10:07.680
The first pass is when the variable the a statement is declared, the second pass when the statement

123
00:10:07.680 --> 00:10:09.130
is initialized.

124
00:10:09.360 --> 00:10:14.950
So there are two states as well, two passes as well, which means that the letton const they hoist.

125
00:10:15.510 --> 00:10:17.670
Now, why is this like this?

126
00:10:17.700 --> 00:10:24.690
Why should we like why is there a lot of confusion around this around this letter and consed?

127
00:10:25.200 --> 00:10:29.610
Now, the reason I'm just going to tell you there is so first off, there are two points that we should

128
00:10:29.610 --> 00:10:30.350
keep in mind.

129
00:10:30.600 --> 00:10:39.330
Point number one, let const let on const hoist to a block whereas var hoists to a function point.

130
00:10:39.330 --> 00:10:41.040
No to the difference.

131
00:10:42.320 --> 00:10:51.020
Between VA and Let Cons is that now I'm going to give you the difference during the compilation or parsing

132
00:10:51.350 --> 00:10:55.220
when VA creates its variables for the scope.

133
00:10:55.340 --> 00:11:00.940
For example, like let's say we have a book variable, it says now we are talking about the VA.

134
00:11:01.100 --> 00:11:08.050
It says when the scope starts, initialize the book variable to undefined.

135
00:11:08.060 --> 00:11:11.630
So that is the first pass for the VA variable.

136
00:11:12.650 --> 00:11:19.130
And if it has an assignment expression, give it the value of that assignment expression.

137
00:11:19.370 --> 00:11:23.690
Otherwise, keep the book variable as undefined.

138
00:11:24.200 --> 00:11:32.150
So whenever rewrite va VA is actually initially is it is in an undefined state.

139
00:11:33.560 --> 00:11:41.360
But what about letting CONSED now during the compilation or passing stage, will let hoists, let and

140
00:11:41.360 --> 00:11:49.130
concerts, both of them behave in the same way when that and concert host their variables into their

141
00:11:49.130 --> 00:11:59.240
block scope, they say create a location called, for example, sort of created an identifier called,

142
00:11:59.240 --> 00:12:00.320
for example, movie.

143
00:12:00.470 --> 00:12:00.920
All right.

144
00:12:01.190 --> 00:12:03.560
So but do not initialize it.

145
00:12:03.590 --> 00:12:04.600
This is the difference.

146
00:12:04.910 --> 00:12:06.160
Do not initialize it.

147
00:12:06.380 --> 00:12:10.340
It is an on initialize state for var.

148
00:12:10.400 --> 00:12:14.210
I'm just going to write it here because these are really, really critical.

149
00:12:14.450 --> 00:12:29.420
So for var we had and and it is you know what originally, originally it is in an undefined state.

150
00:12:29.930 --> 00:12:32.750
So originally var is in an undefined state.

151
00:12:32.750 --> 00:12:34.550
Let's slash const.

152
00:12:36.160 --> 00:12:38.860
They are originally Aruri.

153
00:12:40.410 --> 00:12:54.960
Originally in and in and on initialised state, so VA is in undefined state and originally let on CONSED,

154
00:12:55.230 --> 00:13:06.930
they are in an on initialised state right now under and being and of course and initialised is is different

155
00:13:06.930 --> 00:13:07.680
than undefined.

156
00:13:07.920 --> 00:13:15.570
Undefined is a primitive data type on initialised means that you cannot touch it, yet it does not get

157
00:13:15.570 --> 00:13:20.460
initialized until in that block you run, you run across a letter.

158
00:13:20.460 --> 00:13:22.080
Kohn's declaration.

159
00:13:22.230 --> 00:13:24.630
It means that we have our assignment expression.

160
00:13:25.440 --> 00:13:34.440
So whenever they created this let const keywords, they sort of they restricted us.

161
00:13:34.620 --> 00:13:45.720
They banned us from ever like think even thinking about this little concept as two passes because we

162
00:13:45.720 --> 00:13:46.950
are going to see an error.

163
00:13:47.010 --> 00:13:47.310
Right.

164
00:13:47.670 --> 00:13:52.890
I can show you that we are going to talk about them in code right now.

165
00:13:52.950 --> 00:13:53.250
Right.

166
00:13:53.400 --> 00:13:56.250
I don't want to be it it has been 14 minutes.

167
00:13:56.250 --> 00:14:02.160
But because this lecture is really, really, really important, I don't care if even if it is get even

168
00:14:02.160 --> 00:14:06.300
if it gets 30 minutes, if you want to know, then you have to stick around.

169
00:14:06.320 --> 00:14:06.620
Right.

170
00:14:07.020 --> 00:14:13.020
Have these were so what I'm going to do is I'm just going to write here proof of now we know theoretically

171
00:14:13.020 --> 00:14:19.830
they are they do hoist all three of them, Valette and Consed, but how can we see them in code.

172
00:14:20.010 --> 00:14:20.580
So let's go.

173
00:14:20.580 --> 00:14:27.990
That's the second part of this lecture where we get to the temporal deadzone error and how we can avoid

174
00:14:27.990 --> 00:14:28.200
it.

175
00:14:28.470 --> 00:14:34.800
This is a very like, horrible or horrifying error that you can get in JavaScript.

176
00:14:34.950 --> 00:14:36.060
How can you avoid it?

177
00:14:36.060 --> 00:14:39.150
I'm going to give you the solution for that as well.

178
00:14:39.240 --> 00:14:47.340
So we are going to say proof of Hoy's proof of hoisting are flat and const.

179
00:14:49.320 --> 00:14:51.360
Right, Konsta.

180
00:14:51.750 --> 00:14:56.110
So now we are talking about the proof of that, so how can we prove it?

181
00:14:56.430 --> 00:15:00.410
Now, this is this is actually the easier part, right?

182
00:15:00.990 --> 00:15:05.220
And I think I give you this these three websites are given.

183
00:15:05.220 --> 00:15:07.500
Now, we are going to talk about these two as well.

184
00:15:07.860 --> 00:15:13.410
But first, let's go ahead and let's prove that so we have our temporal dead zone of file open right

185
00:15:13.410 --> 00:15:15.520
here and I'm going to dive right in.

186
00:15:15.780 --> 00:15:22.440
So I'm going to create a variable called VAR with VAR and the variable identifier is book.

187
00:15:22.920 --> 00:15:23.880
And you know what?

188
00:15:23.880 --> 00:15:28.200
I'm just going to copy the value from here and I'm going to paste it here and I'm going to save it.

189
00:15:28.740 --> 00:15:31.680
100 Years of Solitude is the book's name.

190
00:15:32.040 --> 00:15:34.520
I'm going to create a block here.

191
00:15:35.340 --> 00:15:36.690
I'm going to open curly braces.

192
00:15:36.690 --> 00:15:42.180
We don't know whether it is a block or not until we run across a letter or const.

193
00:15:42.540 --> 00:15:46.440
And here I'm going to I'm going to call that book.

194
00:15:46.950 --> 00:15:49.560
I'm going to reference it right here inside the console.

195
00:15:49.980 --> 00:15:53.400
But I'm going to create another variable that is called movie.

196
00:15:53.790 --> 00:15:57.000
And let's put it to Black Panther.

197
00:15:58.270 --> 00:16:04.180
Panther, right, and I'm going to come out of here and I'm going to you know what?

198
00:16:04.180 --> 00:16:05.320
I'm not going to do anything.

199
00:16:06.740 --> 00:16:13.410
So when I save this what word, what what it is that we are going to get.

200
00:16:13.970 --> 00:16:17.540
So this is a block scope right now.

201
00:16:17.570 --> 00:16:21.680
This is not proof of hoisting of lead cause this is proof of something else.

202
00:16:21.920 --> 00:16:24.970
But we are on our way of proving that in concert.

203
00:16:24.980 --> 00:16:25.340
All right.

204
00:16:25.670 --> 00:16:26.990
That they hoist as well.

205
00:16:27.320 --> 00:16:33.520
Now, this is proof that whenever we have a scope, like in this case, we have the block scope.

206
00:16:34.010 --> 00:16:44.030
And whenever this concert, a concert console identifier, cannot find its reference inside the scope

207
00:16:44.510 --> 00:16:48.100
because JavaScript is a lexically scoped language.

208
00:16:48.110 --> 00:16:54.800
And the key to understanding lexically scoped language is that whenever we cannot find a reference to

209
00:16:54.800 --> 00:17:01.440
it to an identifier, that that whole identifier is going to go one level up.

210
00:17:01.700 --> 00:17:04.170
So this is a scope and this is another skill.

211
00:17:04.220 --> 00:17:05.510
This is the global scope.

212
00:17:05.520 --> 00:17:07.230
This is the block scope inside here.

213
00:17:07.730 --> 00:17:11.660
So if that if JavaScript is not a lexically.

214
00:17:14.230 --> 00:17:20.470
Scope language, then this console log book, it should throw an error, but it doesn't, and when we

215
00:17:20.470 --> 00:17:27.819
save it, we are going to get 100 years of solitude, even though this console log is inside this scope,

216
00:17:27.819 --> 00:17:35.050
the scope of this block, why we see 100 years of solitude is not because it's not it doesn't have anything

217
00:17:35.050 --> 00:17:36.980
to do with the hoisting of that unconscious.

218
00:17:37.000 --> 00:17:37.510
No, no, no.

219
00:17:37.840 --> 00:17:44.560
It just has something to do with the lexical nature of JavaScript that says when you cannot find the

220
00:17:44.560 --> 00:17:47.830
source, just move from one level up.

221
00:17:47.830 --> 00:17:50.550
Don't go one line up, one level up.

222
00:17:50.740 --> 00:17:55.310
So from the block scope, this council log just moved to the global scale.

223
00:17:55.330 --> 00:17:56.170
What does it mean?

224
00:17:56.200 --> 00:17:59.740
It means that this constant log is movable now.

225
00:18:00.880 --> 00:18:08.230
And when it is movable, I can check whether or not we have hoisting for Aulet and Consed.

226
00:18:08.620 --> 00:18:09.680
How can we check it?

227
00:18:09.910 --> 00:18:17.140
I'm going to create another variable and I'm going to call it name and in here I'm just going to pass.

228
00:18:17.140 --> 00:18:18.190
And Chadwick

229
00:18:21.850 --> 00:18:25.730
Chadwick Boseman and I'm going to pass in Chadwick.

230
00:18:25.730 --> 00:18:26.250
All right.

231
00:18:26.260 --> 00:18:26.750
And.

232
00:18:28.690 --> 00:18:29.130
All right.

233
00:18:29.410 --> 00:18:30.010
Moving on.

234
00:18:30.460 --> 00:18:38.440
We are going to create our scope in here and I'm going to say console, dot, lock and I'm going to

235
00:18:38.440 --> 00:18:39.520
say in here name.

236
00:18:40.630 --> 00:18:47.140
But the difference is this time that I create let I'm going to create a variable name as well and I'm

237
00:18:47.140 --> 00:18:48.340
going to set it to Rosie.

238
00:18:49.100 --> 00:18:49.540
Right.

239
00:18:50.080 --> 00:18:52.480
And I just said it to Rosie.

240
00:18:53.410 --> 00:18:53.800
All right.

241
00:18:54.130 --> 00:18:54.670
Now.

242
00:18:56.080 --> 00:19:03.430
If that doesn't hoist, if let does not hoist, what should we see in here?

243
00:19:03.760 --> 00:19:05.380
We should see in here.

244
00:19:06.010 --> 00:19:07.870
Let me come in this part out.

245
00:19:08.270 --> 00:19:11.000
I'm not going to save it because I don't want to show it to you guys.

246
00:19:11.080 --> 00:19:17.020
I want to go over the theory first, because I told you that these chapters, these three chapters,

247
00:19:17.020 --> 00:19:21.000
they dive very, very deep into the concept of how JavaScript works.

248
00:19:22.000 --> 00:19:31.990
Now, if Leron, if led, doesn't hoist the normally this concept of log, even though there is a letton

249
00:19:31.990 --> 00:19:39.850
here because this console log doesn't have any reference to this console, it should move one level

250
00:19:39.850 --> 00:19:40.090
up.

251
00:19:40.240 --> 00:19:50.290
And when it like moves one level up, like I'm doing air quotes, if it moves one level up as the misconception

252
00:19:50.300 --> 00:19:59.400
misunderstood hoisting suggests, we should see var name this Chadwick be printed inside the console.

253
00:19:59.680 --> 00:20:01.440
And if I say it oops.

254
00:20:02.020 --> 00:20:04.540
If I save it we can see the Chadwicks post.

255
00:20:04.540 --> 00:20:05.830
It is logged.

256
00:20:05.830 --> 00:20:09.790
But what if the console is down here now.

257
00:20:09.970 --> 00:20:16.660
Technically this is the behavior that we should see, like according to the misunderstood hoisting and

258
00:20:16.660 --> 00:20:24.160
according to that line that the MDN says that led and const do not hoist but.

259
00:20:25.290 --> 00:20:27.630
There is a naming collision right here.

260
00:20:27.660 --> 00:20:34.200
That's how I can prove to you that let him hoist, but they hoist in a different way and we are going

261
00:20:34.200 --> 00:20:37.140
to get a TDE error right now.

262
00:20:37.590 --> 00:20:40.740
Now, because the name is right here as well.

263
00:20:40.740 --> 00:20:47.310
And because of the compilation stage, this console log is going to try to access the value of this

264
00:20:47.310 --> 00:20:50.240
name, which is Rowsey, but it will fail.

265
00:20:50.550 --> 00:20:55.720
So let's save it and we get an error and the error is a reference error.

266
00:20:55.740 --> 00:20:57.270
It is not a typo error.

267
00:20:57.460 --> 00:21:00.150
It means that we have not mistyped anything.

268
00:21:00.420 --> 00:21:02.220
It is a reference error.

269
00:21:02.820 --> 00:21:08.100
And why the console log didn't grab the value of Chadwick.

270
00:21:08.310 --> 00:21:09.420
Why it didn't grab it.

271
00:21:09.420 --> 00:21:14.220
Because JavaScript is not an interpretive language.

272
00:21:14.220 --> 00:21:18.720
JavaScript doesn't go line by one before moving to top.

273
00:21:19.020 --> 00:21:20.730
Even though this line is right here.

274
00:21:21.170 --> 00:21:25.940
It referenced this name, but it couldn't get it.

275
00:21:26.370 --> 00:21:31.500
And the reason for that is whenever you create a let.

276
00:21:34.170 --> 00:21:41.630
Variable through let or const, there are two passes, the first pass is going to throw a TDE error

277
00:21:41.630 --> 00:21:46.770
or in this case which this reference error actually belongs to that TDE error.

278
00:21:46.910 --> 00:21:48.880
I'm going to tell you how it belongs to that.

279
00:21:49.310 --> 00:21:58.220
And until it grabs it, until you find the value for that initial for that identifier, you're going

280
00:21:58.220 --> 00:21:59.560
to get this TDE error.

281
00:21:59.960 --> 00:22:04.490
And when you find it like this, that TDE error is gone.

282
00:22:05.090 --> 00:22:09.560
When you can't find it, the TDE error is there, right?

283
00:22:09.770 --> 00:22:10.580
It is there.

284
00:22:10.820 --> 00:22:15.650
Now, this code acts in the same way as if I were to come in this one out.

285
00:22:15.890 --> 00:22:19.570
And if I say cancel that log name.

286
00:22:19.850 --> 00:22:24.380
Now, you can see that we have referenced the identifier.

287
00:22:24.650 --> 00:22:31.130
We have referenced the identifier before the execution of that identifier.

288
00:22:31.430 --> 00:22:42.140
So how VA reacts to this kind of code is it is going to throw it should have thrown an undefined because

289
00:22:42.140 --> 00:22:45.050
this is defined, it is going to grab the value of that.

290
00:22:45.320 --> 00:22:51.140
But if we were to do this, it is going to throw an undefined because this is not defined.

291
00:22:51.680 --> 00:22:52.850
So let's save it.

292
00:22:52.850 --> 00:22:53.990
We still get Chadwick.

293
00:22:54.000 --> 00:22:55.790
Where is it getting Chadwick from?

294
00:22:56.600 --> 00:22:58.930
Because there is no Chadrick in here.

295
00:22:59.960 --> 00:23:00.530
All right.

296
00:23:00.530 --> 00:23:03.050
So I'm just going to go ahead and remove this.

297
00:23:04.160 --> 00:23:06.320
And we are going to save it.

298
00:23:06.590 --> 00:23:11.390
We can see that because this is in this state of undefined, we don't get anything.

299
00:23:11.390 --> 00:23:15.810
We just get like an empty string because this is not defined, this variable.

300
00:23:15.920 --> 00:23:18.920
And when we go ahead, I'm just going to control them.

301
00:23:19.100 --> 00:23:22.490
And when we define it, we are going to get still.

302
00:23:22.490 --> 00:23:23.940
We are not going to get anything.

303
00:23:23.990 --> 00:23:24.320
All right.

304
00:23:24.500 --> 00:23:28.700
But if I bring down the console log, I don't know why it is throwing.

305
00:23:29.650 --> 00:23:32.240
We we do get it in the console log there.

306
00:23:32.270 --> 00:23:36.230
So what I'm going to do is let's go ahead and open up a life server one more time.

307
00:23:36.230 --> 00:23:40.360
It's working buggy and it is defeating my point right here.

308
00:23:41.090 --> 00:23:46.490
So let's say that we do get Chadwick here now until Chadwick is defined.

309
00:23:46.490 --> 00:23:53.900
But when Chadwick is not defined, we are getting an undefined it means it is in an undefined state.

310
00:23:54.080 --> 00:23:54.430
All right.

311
00:23:54.560 --> 00:24:04.520
I just wrote here it is in an undefined state, but when we do not and we do not give the identifier

312
00:24:04.520 --> 00:24:10.760
off, let that value it is going to be in an initialized state.

313
00:24:10.970 --> 00:24:16.640
And that reference error comes from the initialized state nature of late.

314
00:24:17.160 --> 00:24:17.550
Right.

315
00:24:18.800 --> 00:24:20.840
So I'm just going to go ahead and remove that.

316
00:24:21.020 --> 00:24:23.810
And when I say it now, this is dereference error.

317
00:24:23.960 --> 00:24:26.900
It means that this name was not referenced.

318
00:24:27.110 --> 00:24:27.710
It wasn't.

319
00:24:27.740 --> 00:24:33.740
It notes that there is a name, but it couldn't reference that name by referencing.

320
00:24:33.890 --> 00:24:37.310
I mean, it couldn't get the value from it.

321
00:24:37.850 --> 00:24:40.940
Now, this is decided by the ECMAScript.

322
00:24:41.840 --> 00:24:53.030
Whenever you call that identifier and then you like you go ahead and you declare it later, you're going

323
00:24:53.030 --> 00:24:53.880
to get this error.

324
00:24:54.320 --> 00:24:56.480
This is called a error.

325
00:24:56.690 --> 00:24:57.650
This error is.

326
00:24:59.530 --> 00:25:05.920
Associated with Lett and Consed, and you can see in here, it says, Unlike variables declared with

327
00:25:05.920 --> 00:25:13.300
Vare, which will start with disvalue undefined let variables are not initialized.

328
00:25:13.570 --> 00:25:18.640
They are in an unknown initialized state until their definition is evaluated.

329
00:25:19.000 --> 00:25:23.100
Now, even this text says that there are two passes.

330
00:25:23.410 --> 00:25:29.860
First, the the variable is created, then the their definition is evaluated.

331
00:25:30.010 --> 00:25:33.480
And this is a synonym of this that we had in here.

332
00:25:33.640 --> 00:25:40.270
Very, very simple, accessing the variables before the initial initialization results in a reference

333
00:25:40.270 --> 00:25:40.570
error.

334
00:25:40.960 --> 00:25:50.140
The variable is in a temporal dead zone from the start of that block until initialization is processed.

335
00:25:50.500 --> 00:25:53.080
So you can see that there are two states in here.

336
00:25:53.080 --> 00:26:01.150
The first state is that the variables, the latent const variables are in the TDE zone in the TDE.

337
00:26:02.030 --> 00:26:09.890
From the start of that block, the second stage says when the initialization is process, the TDE is

338
00:26:09.890 --> 00:26:10.790
going to go away.

339
00:26:11.270 --> 00:26:15.230
OK, now you can read all about TDE in here.

340
00:26:15.350 --> 00:26:15.770
All right.

341
00:26:15.990 --> 00:26:22.550
And this reference error actually says that the variable is in the TDE zone.

342
00:26:23.070 --> 00:26:24.840
OK, in the TDE.

343
00:26:25.180 --> 00:26:28.430
OK, it says zone at the end, so I don't have to say it again.

344
00:26:29.420 --> 00:26:30.830
So that's why we get it.

345
00:26:31.850 --> 00:26:40.310
If the variables were not in TDE, then this console log would have very easily traveled to top and

346
00:26:40.310 --> 00:26:41.690
grabbed the value of Chadwick.

347
00:26:41.900 --> 00:26:52.160
But it didn't because they are in TDE because letton cons do highest, but their hosting is different.

348
00:26:52.760 --> 00:26:56.120
Their hosting is not in an undefined state.

349
00:26:56.300 --> 00:26:58.340
It is in an initialized state.

350
00:26:58.550 --> 00:27:04.820
And when something is in an initialized state, this is the error that you are going to get.

351
00:27:04.820 --> 00:27:09.920
Unquit uncaught reference error cannot access named before initialization.

352
00:27:10.200 --> 00:27:13.490
It didn't say that name is not present.

353
00:27:13.940 --> 00:27:15.950
It just said we cannot access it.

354
00:27:16.100 --> 00:27:22.430
It didn't say like we cannot get it, we cannot access it before initialization.

355
00:27:22.430 --> 00:27:26.720
So let s present, but we cannot get the value of it.

356
00:27:26.900 --> 00:27:30.140
So there are two states here, two stages.

357
00:27:30.380 --> 00:27:33.020
The same thing goes for const as well.

358
00:27:34.280 --> 00:27:37.970
And if I come down here, I believe I can find it.

359
00:27:40.610 --> 00:27:41.430
OK.

360
00:27:41.600 --> 00:27:42.810
Uh hmm.

361
00:27:44.610 --> 00:27:54.810
Consed common our area, all the considerations about the TDE apply to both Lett and Consed, so this

362
00:27:54.810 --> 00:27:56.760
to act in the same way.

363
00:27:57.540 --> 00:28:00.240
And there is another thing that I want to discuss here.

364
00:28:00.240 --> 00:28:02.160
And then we are going to wrap this lecture up.

365
00:28:02.580 --> 00:28:03.930
It has been 30 minutes.

366
00:28:04.420 --> 00:28:07.620
And why do we have this, the TDE.

367
00:28:08.580 --> 00:28:14.500
You might ask, OK, you might have never heard of it before, but and these are the resources for that.

368
00:28:14.520 --> 00:28:15.720
Feel free to go over them.

369
00:28:16.080 --> 00:28:20.370
And before even explaining that, what I'm going to do is I'm going to come down here and I'm going

370
00:28:20.370 --> 00:28:26.640
to come and this one out and I'm going to say, Consed, I just want to show you that what consed you

371
00:28:26.640 --> 00:28:28.080
are going to get the same error.

372
00:28:28.590 --> 00:28:30.960
Let's save it from here.

373
00:28:31.290 --> 00:28:34.520
We can still see that from line number 34.

374
00:28:35.010 --> 00:28:36.540
We have a reference error.

375
00:28:37.360 --> 00:28:39.290
No initialization has happened.

376
00:28:39.720 --> 00:28:40.180
All right.

377
00:28:40.290 --> 00:28:40.800
So.

378
00:28:42.470 --> 00:28:43.550
Why this?

379
00:28:44.420 --> 00:28:49.520
What's up with this I'm going to give you like I'm going to explain this in a story kind of thing,

380
00:28:49.820 --> 00:28:53.560
and then we are done we are done with the all of theory and everything.

381
00:28:53.570 --> 00:29:00.080
I just want to give you a history on the TDE excuse me, a very, very short one.

382
00:29:02.840 --> 00:29:12.470
Now, TDE, surprisingly, was actually created for Consed, TDE was not created for that.

383
00:29:13.580 --> 00:29:20.350
Now the reason for that is I'm going to give you like the mental picture and I hope you are following.

384
00:29:20.450 --> 00:29:20.780
All right.

385
00:29:21.050 --> 00:29:29.150
One Consed as of year 2015 was created as a verbal declaration method when Konsta was created.

386
00:29:29.330 --> 00:29:39.740
At first, if CONSED was to behave as var that when CONSED is created, it means that Consed cannot

387
00:29:39.740 --> 00:29:40.720
be reassigned.

388
00:29:41.240 --> 00:29:45.230
The variables with consed they cannot be redeclared, they cannot be reassigned.

389
00:29:45.470 --> 00:29:45.880
Right.

390
00:29:47.090 --> 00:29:56.180
And to think like const variables, first off they have an undefined state and then they have an initialized

391
00:29:56.180 --> 00:29:56.750
state.

392
00:29:56.990 --> 00:30:03.620
It would mean that the concepts actually they beat the point of being consed.

393
00:30:04.190 --> 00:30:11.660
It means that they have two different kinds of states, but that beats the point of const const only

394
00:30:11.660 --> 00:30:16.430
has one state and you cannot change it constantly has one value.

395
00:30:16.430 --> 00:30:18.880
If you change the value you're going to get an error.

396
00:30:19.640 --> 00:30:26.210
So that was the problem with CONSED and the problem with constant var there.

397
00:30:26.630 --> 00:30:36.110
The the war between VA and these other newer methods started from there and because VA it has an undefined

398
00:30:36.110 --> 00:30:40.880
state and then when it is initialized it has a defined state.

399
00:30:41.180 --> 00:30:47.120
But const if we talk about consed in this manner consed has an undefined state.

400
00:30:47.120 --> 00:30:49.580
When it is initialized it has a defined state.

401
00:30:49.970 --> 00:30:53.600
It means that it is switching values, it is switching states.

402
00:30:54.230 --> 00:30:57.500
How can it be a constant if it is switching stuff.

403
00:30:58.100 --> 00:31:03.860
That's why they created a TDE, a temporal dead zone that you cannot do it.

404
00:31:04.100 --> 00:31:12.530
And they said OK, if you do this with const, if you initialize, if you declare a const but not initialize

405
00:31:12.530 --> 00:31:13.670
it, you're going to see an error.

406
00:31:14.840 --> 00:31:17.030
And I'm just going to in this one out.

407
00:31:17.030 --> 00:31:19.220
And if I come here it means like this.

408
00:31:19.230 --> 00:31:25.520
So we are just declaring yet we are not initializing it and we are going to say no.

409
00:31:26.000 --> 00:31:33.140
And if I say it's a syntax error, missing initialization const declaration and the reason that they

410
00:31:33.140 --> 00:31:41.060
did this happens, the syntax error happens is because const cannot have two different values.

411
00:31:41.240 --> 00:31:46.090
A constant identifier cannot have two different valid values.

412
00:31:46.400 --> 00:31:52.310
So this case proves it because number is declared and then I go ahead.

413
00:31:52.310 --> 00:31:54.260
And if I say const number.

414
00:31:55.180 --> 00:32:04.270
I always mistype mistype consed consed no, and I set it to like, let's say one and then I changed

415
00:32:04.270 --> 00:32:07.270
my mind, I said it to two and we are going to we are going to see error.

416
00:32:07.570 --> 00:32:11.170
But if I change this to let we are not going to see any error.

417
00:32:12.840 --> 00:32:21.030
OK, so like this, if I were to do let's grab this, let we are not going to see any error, we are

418
00:32:21.030 --> 00:32:21.780
going to see.

419
00:32:22.100 --> 00:32:22.580
Of course.

420
00:32:22.590 --> 00:32:23.190
Let's go ahead.

421
00:32:23.190 --> 00:32:24.140
UNcancel lock.

422
00:32:26.020 --> 00:32:33.220
So I just proved this point, we are going to see number two, but if I change this to CONSED, we are

423
00:32:33.220 --> 00:32:39.360
going to CNR because whenever you declare a variable with CONSED, you have to initialize it.

424
00:32:39.520 --> 00:32:44.510
It means that the const cannot switch, states cannot switch values.

425
00:32:44.920 --> 00:32:46.410
So how, how can we.

426
00:32:46.660 --> 00:32:50.250
They thought, OK, how can we make sure that this problem doesn't happen.

427
00:32:50.500 --> 00:32:58.750
Then they created this tde that whenever you initial you declare a variable with const originally it

428
00:32:58.750 --> 00:33:05.320
is and it is in the TDE until you initialize it and if you do not initialize it you are going to get

429
00:33:05.320 --> 00:33:05.810
an error.

430
00:33:06.490 --> 00:33:07.540
Very, very simple.

431
00:33:07.980 --> 00:33:15.610
And when they did that for CONSED, they said unfortunately or fortunately, I will let you, I will

432
00:33:15.610 --> 00:33:16.920
let you to be the judge.

433
00:33:17.260 --> 00:33:21.980
They said that we might have TDE for that as well.

434
00:33:22.600 --> 00:33:27.010
That's how they decided upon TDE for let as well.

435
00:33:27.700 --> 00:33:34.420
Now, at the end of this lecture, I just want to give you one way, one definitive way to avoid the

436
00:33:34.420 --> 00:33:36.220
TDE, OK?

437
00:33:36.370 --> 00:33:44.710
And that is put all of your left and const declarations at the top of this block and that where you

438
00:33:44.710 --> 00:33:51.350
will never encounter it easier whenever you're working in the global scope or inside a block scope or

439
00:33:51.370 --> 00:34:00.130
any in any scope where you have led and const make sure to put him at the top of your application at

440
00:34:00.130 --> 00:34:03.100
the top of your code to avoid this error.

441
00:34:04.750 --> 00:34:10.900
And you will never encounter that, you will never that's why in almost all of our applications, we

442
00:34:10.900 --> 00:34:16.510
had all of our Willetton concert concerts at the top of the application.

443
00:34:17.960 --> 00:34:27.800
All right, so with this lecture, 34 minutes and something, our entire discussion of how JavaScript

444
00:34:27.800 --> 00:34:35.900
works and there are a lot of more, there are a lot more things that I might I might add, on the future

445
00:34:35.900 --> 00:34:43.219
to this course based on how you are going to react to these three chapters of the JavaScript, advanced

446
00:34:43.219 --> 00:34:45.800
JavaScript, the inner workings part one, two, three.

447
00:34:46.489 --> 00:34:50.900
I might add more parts to this, but first, I have to know your reaction.

448
00:34:51.830 --> 00:34:56.239
And I have to know that if you want more theory, I could add more.

449
00:34:56.510 --> 00:34:58.250
But for now, we are done.

450
00:34:58.250 --> 00:35:07.130
And I congratulate you because now you understand truly what the difference is between varlet consed,

451
00:35:07.520 --> 00:35:15.410
how they are compiled, how they're executed, what what actually what actually hoisting is, where

452
00:35:15.410 --> 00:35:21.510
are the references for hoisting, how can you find it and how you can use it to your own advantage.

453
00:35:22.070 --> 00:35:25.490
So this is going to be it for this lecture and for this chapter.

454
00:35:25.500 --> 00:35:31.850
I hope you're not getting you have not gotten bored and I hope you have enjoyed this lecture.

455
00:35:31.850 --> 00:35:34.460
So see you guys in the next chapter.

