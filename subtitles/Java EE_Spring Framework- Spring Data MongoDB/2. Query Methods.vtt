WEBVTT
1
00:00:01.140 --> 00:00:03.540
[Autogenerated] we can't really discuss about manga report

2
00:00:03.540 --> 00:00:07.640
stories without first looking into query method.

3
00:00:07.640 --> 00:00:10.330
Query methods are the clarity of way toe add

4
00:00:10.330 --> 00:00:13.390
functionality toe a spring depository.

5
00:00:13.390 --> 00:00:19.070
And I think the best way to illustrate this process is by looking at an example.

6
00:00:19.070 --> 00:00:21.590
We'll start with our airport document.

7
00:00:21.590 --> 00:00:27.770
It has a couple of properties like I D flights per day name closed and location,

8
00:00:27.770 --> 00:00:29.840
which is actually a sub document.

9
00:00:29.840 --> 00:00:33.050
No, it is the correct annotations on the airport class.

10
00:00:33.050 --> 00:00:34.230
Before we move on.

11
00:00:34.230 --> 00:00:38.970
I want youto post this video and look closely at the property names.

12
00:00:38.970 --> 00:00:43.040
In fact, know them on a piece of paper.

13
00:00:43.040 --> 00:00:47.280
So in hostile report story toe, add more functionality to it.

14
00:00:47.280 --> 00:00:49.970
We can add in a new method.

15
00:00:49.970 --> 00:00:51.540
Let's take a look at this one.

16
00:00:51.540 --> 00:00:57.880
Find by flights per day greater than, and we have a value.

17
00:00:57.880 --> 00:01:01.670
Recreate his method signature, which he turns a list of airports.

18
00:01:01.670 --> 00:01:06.870
And then we can just call this method and everything will work as expected.

19
00:01:06.870 --> 00:01:11.840
At this point, you might be asking yourselves, Is this some sort of magic?

20
00:01:11.840 --> 00:01:13.640
Well, not at all.

21
00:01:13.640 --> 00:01:14.310
In fact,

22
00:01:14.310 --> 00:01:18.740
Spring knows how to create a proxy and the correct

23
00:01:18.740 --> 00:01:23.010
implementation based on the query method signatures.

24
00:01:23.010 --> 00:01:26.640
There are a lot of conventions which are being used under the hood,

25
00:01:26.640 --> 00:01:30.740
but Indian Spring manages to create our desired outcome.

26
00:01:30.740 --> 00:01:34.890
In fact, let's detail on how we can create this queen methods,

27
00:01:34.890 --> 00:01:37.790
and let's explore the conventions that govern them.

28
00:01:37.790 --> 00:01:41.740
There are four things that you need to consider when declaring query methods.

29
00:01:41.740 --> 00:01:43.950
You need to know the return type.

30
00:01:43.950 --> 00:01:47.640
Is that method going to return a list is that nothing's going to

31
00:01:47.640 --> 00:01:50.800
return a single document or maybe an optional.

32
00:01:50.800 --> 00:01:53.240
Then we have the method prefix.

33
00:01:53.240 --> 00:01:57.860
This is usually find by, but they're also other alternatives available.

34
00:01:57.860 --> 00:02:00.920
After that, you can specify a property name,

35
00:02:00.920 --> 00:02:04.020
and you can add filters on that property name.

36
00:02:04.020 --> 00:02:07.040
And that's exactly what we did in the previous example.

37
00:02:07.040 --> 00:02:10.510
If you want to build a query method to filter numeric properties,

38
00:02:10.510 --> 00:02:11.910
we can build them like this.

39
00:02:11.910 --> 00:02:16.550
We're turning a list of airports we have find by as the prefix.

40
00:02:16.550 --> 00:02:22.040
We have flights per day, which is the property on which you wantto other fitter,

41
00:02:22.040 --> 00:02:26.780
and then we have a couple of fitters between greater than greater

42
00:02:26.780 --> 00:02:30.900
than equal or less than equal and of course,

43
00:02:30.900 --> 00:02:35.440
we provide some values to customize our fitters.

44
00:02:35.440 --> 00:02:41.040
I want to highlight the convention return type prefix find by in our case,

45
00:02:41.040 --> 00:02:43.470
property name, flats per day,

46
00:02:43.470 --> 00:02:48.100
the filters and then the values for those particular filters.

47
00:02:48.100 --> 00:02:50.590
Let's move on to string properties.

48
00:02:50.590 --> 00:02:54.740
Let's assume you wantto filter airports by their name.

49
00:02:54.740 --> 00:02:57.000
We have free variants over here.

50
00:02:57.000 --> 00:03:02.210
Find by name, like find by name, not now and find my name.

51
00:03:02.210 --> 00:03:04.360
Now the first method returns.

52
00:03:04.360 --> 00:03:09.280
All the airports where the name is similar toe are provided value.

53
00:03:09.280 --> 00:03:13.820
The 2nd 1 returns all the airports where the name properties not know.

54
00:03:13.820 --> 00:03:17.200
In the last one returns, all the airports were the name properties.

55
00:03:17.200 --> 00:03:18.200
Know what?

56
00:03:18.200 --> 00:03:23.470
If you want an exact match, wantto find all the airports by an exact name.

57
00:03:23.470 --> 00:03:26.330
What, In this case, we can modify the signature.

58
00:03:26.330 --> 00:03:28.940
And instead of returning a list of airports,

59
00:03:28.940 --> 00:03:33.400
we can just return on airport or a non optional off type airport.

60
00:03:33.400 --> 00:03:36.630
We also need to modify the method names and in this case,

61
00:03:36.630 --> 00:03:41.870
we have find by name notice the absence of the feather well

62
00:03:41.870 --> 00:03:45.330
filtering on the name property with an exact value,

63
00:03:45.330 --> 00:03:49.140
and the exact value is the one that you passing into this method.

64
00:03:49.140 --> 00:03:52.770
We also have quite a method for bullion fields.

65
00:03:52.770 --> 00:03:58.130
Let's say we want to find all the airport that are closed or that are open well,

66
00:03:58.130 --> 00:04:02.460
we can use the close property and we can create methods such as find,

67
00:04:02.460 --> 00:04:06.010
buy clothes true or find my closed false.

68
00:04:06.010 --> 00:04:10.160
We looked at how we can filter airports based on a single

69
00:04:10.160 --> 00:04:12.460
property and using a single feather.

70
00:04:12.460 --> 00:04:13.210
However,

71
00:04:13.210 --> 00:04:17.310
we can complicate things we can chain together

72
00:04:17.310 --> 00:04:20.020
multiple properties and multiple filters.

73
00:04:20.020 --> 00:04:24.860
Let's see wantto filter all the airports that are closed and where the

74
00:04:24.860 --> 00:04:27.840
flights per day is greater than a particular value.

75
00:04:27.840 --> 00:04:30.230
We declare a singer you have to return type.

76
00:04:30.230 --> 00:04:30.710
In this case,

77
00:04:30.710 --> 00:04:34.420
the list of airports have the prefix find by and now we

78
00:04:34.420 --> 00:04:38.400
have all the airports that are closed, so closed,

79
00:04:38.400 --> 00:04:44.390
true and where flights per day greater than are given value.

80
00:04:44.390 --> 00:04:47.650
Using the end operator became chain up Marty profit

81
00:04:47.650 --> 00:04:54.330
Ear's on multiple properties, however, Is this approach good for all the cases?

82
00:04:54.330 --> 00:04:54.480
No.

83
00:04:54.480 --> 00:04:56.980
What about more complex queries?

84
00:04:56.980 --> 00:05:01.930
Want our methods be like 200 characters long For those cases,

85
00:05:01.930 --> 00:05:07.390
we can use the at query annotation and we can specify the exact custom

86
00:05:07.390 --> 00:05:11.530
query that Mongo should use when executing our method.

87
00:05:11.530 --> 00:05:15.120
This approach is a little bit more complex because you need to know how

88
00:05:15.120 --> 00:05:17.870
to create queries using the Mongol Cree language.

89
00:05:17.870 --> 00:05:21.420
But for complex queries, it's absolutely wonderful.

90
00:05:21.420 --> 00:05:22.730
What if you want a filter?

91
00:05:22.730 --> 00:05:28.050
All the airports by City City is a property on the location class.

92
00:05:28.050 --> 00:05:30.480
On location is a sub document off airport.

93
00:05:30.480 --> 00:05:34.040
While we can create a method and the name here is not relevant,

94
00:05:34.040 --> 00:05:37.070
I just call it a former city and not is that we use the at

95
00:05:37.070 --> 00:05:42.240
query annotation and in the at Korea notation passing among go

96
00:05:42.240 --> 00:05:46.920
quickly language construct location, city equals question mark zero,

97
00:05:46.920 --> 00:05:52.540
which matches for the first argument in our method in our case city.

98
00:05:52.540 --> 00:05:57.010
Creating a query to find all the small airports is also pretty easy.

99
00:05:57.010 --> 00:05:59.950
We use that queer irritation with their flights per days.

100
00:05:59.950 --> 00:06:03.550
Our property, we add in the filter dollar lt,

101
00:06:03.550 --> 00:06:07.120
which stands for less than or equals on the value 50.

102
00:06:07.120 --> 00:06:11.980
I want to highlight that location and fights per day are the field

103
00:06:11.980 --> 00:06:15.670
names as they are stored in the Mongol database.

104
00:06:15.670 --> 00:06:18.960
There now the property names on our airport class.

105
00:06:18.960 --> 00:06:23.240
When you're constructing queries this way, you lose type safety.

106
00:06:23.240 --> 00:06:28.040
You need to know how the underlying data is stored.

107
00:06:28.040 --> 00:06:29.490
Based on my experience,

108
00:06:29.490 --> 00:06:33.260
I would encourage you to use the at Cory annotation only

109
00:06:33.260 --> 00:06:36.600
situations where you cannot create the query methods using

110
00:06:36.600 --> 00:06:38.870
the conventions discussed earlier.

111
00:06:38.870 --> 00:06:42.670
Sure, they're great addition to the repository interface,

112
00:06:42.670 --> 00:06:48.000
but they force you to know that our base specific details, so don't overuse them.

