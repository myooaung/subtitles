WEBVTT
1
00:00:01.440 --> 00:00:05.230
[Autogenerated] full text search is probably one of the most used

2
00:00:05.230 --> 00:00:07.960
and needed features in modern applications.

3
00:00:07.960 --> 00:00:12.700
I cannot think of any Web application that does not have a giant

4
00:00:12.700 --> 00:00:15.520
input text books where you can type in something,

5
00:00:15.520 --> 00:00:19.110
and then the application tries to give you results that are useful.

6
00:00:19.110 --> 00:00:19.380
T.

7
00:00:19.380 --> 00:00:21.870
We're going to see how to implement full text search in a

8
00:00:21.870 --> 00:00:24.090
spring application that uses Mongo Debbie,

9
00:00:24.090 --> 00:00:27.740
who start our discussion around text indexes.

10
00:00:27.740 --> 00:00:32.880
Text indexes are the bits and pieces that make food tech search possible.

11
00:00:32.880 --> 00:00:36.040
A text index is similar to a normal index,

12
00:00:36.040 --> 00:00:38.660
but it works on Lee on properties of types,

13
00:00:38.660 --> 00:00:41.200
drink or on the res off strings.

14
00:00:41.200 --> 00:00:45.740
You can text index properties across the whole autograph so

15
00:00:45.740 --> 00:00:47.740
you're not limited to the root object.

16
00:00:47.740 --> 00:00:53.710
You can dig into a graph and apply text indexes on any string property,

17
00:00:53.710 --> 00:00:56.780
and last but not least, should pay attention to the text index.

18
00:00:56.780 --> 00:00:57.460
Wait,

19
00:00:57.460 --> 00:01:03.310
because it's going to be extremely important in how your results are ordered.

20
00:01:03.310 --> 00:01:04.480
But enough waffle.

21
00:01:04.480 --> 00:01:05.820
Let's look at an example.

22
00:01:05.820 --> 00:01:08.140
It all begins with annotations,

23
00:01:08.140 --> 00:01:13.550
which have this simple job profile class over here with I D name title

24
00:01:13.550 --> 00:01:19.310
and about me field title and about me are annotated with at text

25
00:01:19.310 --> 00:01:23.070
indexed notice that we do not add any weight.

26
00:01:23.070 --> 00:01:25.380
So there are both equal weighted.

27
00:01:25.380 --> 00:01:28.580
Let's assume we have these few documents in Armando Database.

28
00:01:28.580 --> 00:01:31.840
Don Java Guru and John Free profiles.

29
00:01:31.840 --> 00:01:35.260
If you perform a full text search by the Cuba Java,

30
00:01:35.260 --> 00:01:37.840
then Jaap is going to be done and John or John.

31
00:01:37.840 --> 00:01:41.940
And that, based on the order of those documents in the collection,

32
00:01:41.940 --> 00:01:46.740
then is going to be picked up because it contains Java in the title property.

33
00:01:46.740 --> 00:01:48.900
And John is going to be picked up because it

34
00:01:48.900 --> 00:01:52.140
contains Java in the about me property.

35
00:01:52.140 --> 00:01:55.040
Notice that Java guru is not selected,

36
00:01:55.040 --> 00:01:57.510
even though it contains Java in the name property.

37
00:01:57.510 --> 00:02:02.640
That's because the name property was not annotated with at text indexed.

38
00:02:02.640 --> 00:02:04.480
So how does this really work?

39
00:02:04.480 --> 00:02:07.450
Well, first of all, it's a documented scanned.

40
00:02:07.450 --> 00:02:12.780
Then a score is computed internally based on the text index waits

41
00:02:12.780 --> 00:02:15.990
so Mongol keeps track off that score internally,

42
00:02:15.990 --> 00:02:17.830
and then the outcome.

43
00:02:17.830 --> 00:02:21.770
The results are sorted by that score and presented to the user.

44
00:02:21.770 --> 00:02:26.080
That's why I said that the text index ways matter in our

45
00:02:26.080 --> 00:02:28.930
examples chattering about me had the same weight.

46
00:02:28.930 --> 00:02:32.530
We can change their body property and assign it a weight off, too.

47
00:02:32.530 --> 00:02:34.460
And we do that by adding the weight.

48
00:02:34.460 --> 00:02:37.740
A tribute to the ATS text indexed annotation.

49
00:02:37.740 --> 00:02:44.460
Now you can read this as about me is two times more important than title when

50
00:02:44.460 --> 00:02:48.850
performing a full text such That's how we should release the ways our

51
00:02:48.850 --> 00:02:52.180
relative to one another and the default way is one.

52
00:02:52.180 --> 00:02:56.650
Now if you go back, for example, and perform the exact full take such again,

53
00:02:56.650 --> 00:03:00.190
the output is always going to be John, followed by Dan.

54
00:03:00.190 --> 00:03:01.690
That's the order.

55
00:03:01.690 --> 00:03:05.900
John is the first result because it contains Java in about me.

56
00:03:05.900 --> 00:03:09.020
About me has the weight off, too.

57
00:03:09.020 --> 00:03:12.460
Then it's present because it contains Java in the title.

58
00:03:12.460 --> 00:03:14.880
However, the title has the weight of one,

59
00:03:14.880 --> 00:03:18.520
and that's why, then is always displayed after John,

60
00:03:18.520 --> 00:03:22.940
you can see why waiting matters and performing for tech searches.

61
00:03:22.940 --> 00:03:26.100
But other than that people making this feature in a speak

62
00:03:26.100 --> 00:03:29.800
application for Mogo TB is not very difficult.

63
00:03:29.800 --> 00:03:32.440
In fact, it's pretty straightforward.

64
00:03:32.440 --> 00:03:34.630
All right, we discussed about indexes,

65
00:03:34.630 --> 00:03:39.510
but how do we actually execute this free text query well again,

66
00:03:39.510 --> 00:03:43.640
we have to define the query and then pass it to the Mongol template.

67
00:03:43.640 --> 00:03:45.890
But things are a little bit different.

68
00:03:45.890 --> 00:03:50.610
First of all, we will use a particular type of criteria called Tex criteria.

69
00:03:50.610 --> 00:03:54.890
Now, when performing full text searches, the language is important.

70
00:03:54.890 --> 00:03:57.800
So we have this method over here to specify the language in our

71
00:03:57.800 --> 00:04:01.440
case will use the default machine language.

72
00:04:01.440 --> 00:04:04.330
Then we're calling this matching method and we're passing

73
00:04:04.330 --> 00:04:06.830
in the text that you want to search.

74
00:04:06.830 --> 00:04:09.850
After we have this text criteria, we can start to build a query.

75
00:04:09.850 --> 00:04:14.140
However, notice that you're using different started factory methods here.

76
00:04:14.140 --> 00:04:17.680
We're using text query that Cory text on.

77
00:04:17.680 --> 00:04:20.320
We're adding in the text criteria.

78
00:04:20.320 --> 00:04:23.450
Then we're sorting results by their score.

79
00:04:23.450 --> 00:04:27.070
And remember this thing Colonel score computed by mongo

80
00:04:27.070 --> 00:04:29.180
when performing the actual search.

81
00:04:29.180 --> 00:04:33.440
And after that we adding a page definition.

82
00:04:33.440 --> 00:04:36.410
We then passing a square ito the Mongol template the

83
00:04:36.410 --> 00:04:39.380
fine method and return the results.

84
00:04:39.380 --> 00:04:41.050
So things look a little bit different.

85
00:04:41.050 --> 00:04:43.740
But overall, the recipe is the same.

86
00:04:43.740 --> 00:04:45.280
You define the query, the quit.

87
00:04:45.280 --> 00:04:53.000
It contains criteria, imagination and sorting. And then you pass that to the Mongol template

