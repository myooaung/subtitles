WEBVTT
1
00:00:00.470 --> 00:00:01.200
[Autogenerated] in his module.

2
00:00:01.200 --> 00:00:04.650
I'll show you a new way toe handle persistence in spring

3
00:00:04.650 --> 00:00:09.940
applications that you use mobile to be, and that is with mongo repositories.

4
00:00:09.940 --> 00:00:13.480
We'll start by discovering what you pushed the resort and when she

5
00:00:13.480 --> 00:00:17.810
used them will continue to look at quarry methods and how we can use

6
00:00:17.810 --> 00:00:21.310
and extend them to meet all of our needs.

7
00:00:21.310 --> 00:00:25.040
Then we'll take a look at, inserts updates and reads,

8
00:00:25.040 --> 00:00:27.040
and we'll finish this module with the demo in,

9
00:00:27.040 --> 00:00:28.770
which would implement among operations.

10
00:00:28.770 --> 00:00:30.870
But this time using repositories.

11
00:00:30.870 --> 00:00:34.930
I mentioned the word depository a lot in these first few seconds.

12
00:00:34.930 --> 00:00:37.930
So what are Mongo report stories?

13
00:00:37.930 --> 00:00:39.400
Well, to put it simple,

14
00:00:39.400 --> 00:00:42.210
Mongol depository is just an abstraction that

15
00:00:42.210 --> 00:00:45.650
significantly reduces the amount of boilerplate code

16
00:00:45.650 --> 00:00:48.440
needed to implement the data access there.

17
00:00:48.440 --> 00:00:52.110
And when I mean obstruction, I mean another face.

18
00:00:52.110 --> 00:00:55.300
Mongrel repositories are injectable interfaces that can

19
00:00:55.300 --> 00:00:57.940
be used in our spring applications.

20
00:00:57.940 --> 00:01:02.040
They provide basic crowd operations out of the box,

21
00:01:02.040 --> 00:01:04.960
and they can be expected with these to meet all of our

22
00:01:04.960 --> 00:01:07.630
clearing needs before we move on.

23
00:01:07.630 --> 00:01:10.460
Let's take a look at how three positively interfaces

24
00:01:10.460 --> 00:01:12.890
are structured in spring framework.

25
00:01:12.890 --> 00:01:15.110
It all starts with the repositories interface.

26
00:01:15.110 --> 00:01:19.090
The repository interface has to tie parameter STI and i d.

27
00:01:19.090 --> 00:01:22.520
He is the type off the class that we're trying to persist,

28
00:01:22.520 --> 00:01:25.220
and I d is the type of the I D.

29
00:01:25.220 --> 00:01:28.740
Then we have a crowd depository, which extends report story.

30
00:01:28.740 --> 00:01:34.130
Crowd depository gives us some pretty useful capabilities to save.

31
00:01:34.130 --> 00:01:35.710
To find documents,

32
00:01:35.710 --> 00:01:39.950
toe come documents and to delete no comments on top off crowd depository,

33
00:01:39.950 --> 00:01:42.610
we have paging and sorting report story.

34
00:01:42.610 --> 00:01:43.170
The paging.

35
00:01:43.170 --> 00:01:46.510
Asserting Your boy's story expands the frontal method by

36
00:01:46.510 --> 00:01:49.660
adding a sort and a page about definition.

37
00:01:49.660 --> 00:01:55.340
This enables us to use the final method and to implement Beijing and sorting.

38
00:01:55.340 --> 00:01:56.390
And after this,

39
00:01:56.390 --> 00:02:00.570
we finally have Mongo repository Mobile put story

40
00:02:00.570 --> 00:02:05.640
just implements free from methods, mostly insert and batch insert.

41
00:02:05.640 --> 00:02:10.070
It's also worth pointing out that the base interfaces

42
00:02:10.070 --> 00:02:12.770
are all defined in spring data.

43
00:02:12.770 --> 00:02:18.280
The only manga specific interface is actually our manga reposted interface,

44
00:02:18.280 --> 00:02:22.810
and this is a pretty important statement because it means

45
00:02:22.810 --> 00:02:27.190
that regardless off our persistence, technology were mostly using.

46
00:02:27.190 --> 00:02:29.790
The interface is defined in spring data.

47
00:02:29.790 --> 00:02:32.160
We have a common set off interfaces,

48
00:02:32.160 --> 00:02:35.210
regardless of the processes technology in fact,

49
00:02:35.210 --> 00:02:38.070
if you've ever worked with GP report stories before,

50
00:02:38.070 --> 00:02:41.550
So with a relational database you'll find most of these

51
00:02:41.550 --> 00:02:44.340
interfaces and methods to be pretty familiar.

52
00:02:44.340 --> 00:02:47.440
That's because you're accusing the same abstractions,

53
00:02:47.440 --> 00:02:52.130
and it is very, very powerful because it means if you switch to Mongo,

54
00:02:52.130 --> 00:02:54.930
your application will almost look identical.

55
00:02:54.930 --> 00:02:56.860
And I think that's a pretty cool.

56
00:02:56.860 --> 00:03:00.600
Think that the people working on a spring framework have

57
00:03:00.600 --> 00:03:03.810
done to create this uniformity across, ah,

58
00:03:03.810 --> 00:03:06.640
lot off different persistence technologies.

59
00:03:06.640 --> 00:03:09.980
I think now is a perfect time to take a look at an example.

60
00:03:09.980 --> 00:03:12.910
Let's say we have this airport class and you want to persistent.

61
00:03:12.910 --> 00:03:14.540
In Mongo, you're single report story.

62
00:03:14.540 --> 00:03:19.340
We add in the correct annotations, so a document and at I d.

63
00:03:19.340 --> 00:03:21.770
And now how do we implement the report story?

64
00:03:21.770 --> 00:03:23.110
We create a new interface.

65
00:03:23.110 --> 00:03:26.000
We call it Airport Depository to Father conventions,

66
00:03:26.000 --> 00:03:28.140
but you can call it however you want,

67
00:03:28.140 --> 00:03:31.860
and we make this interface extent among repository,

68
00:03:31.860 --> 00:03:33.800
off type airport and strength.

69
00:03:33.800 --> 00:03:37.710
Airport is the top off the documents that were trying to persist and strength

70
00:03:37.710 --> 00:03:40.740
is the type of the property which contains the idea field.

71
00:03:40.740 --> 00:03:43.980
Then we had the at repositories annotation to make Spink

72
00:03:43.980 --> 00:03:46.530
aware that it can use this depository.

73
00:03:46.530 --> 00:03:50.840
In our application, we have four lines of goat,

74
00:03:50.840 --> 00:03:53.420
and now we can begin to use the reported.

75
00:03:53.420 --> 00:03:53.640
You know,

76
00:03:53.640 --> 00:03:58.040
we can inject it in a different component and we can find all the documents.

77
00:03:58.040 --> 00:04:01.080
Or we can create a new airport and called insert method

78
00:04:01.080 --> 00:04:02.870
on ______ suppository to save it.

79
00:04:02.870 --> 00:04:06.340
Or we can delete every airport in our collection by

80
00:04:06.340 --> 00:04:08.040
calling the day little method.

81
00:04:08.040 --> 00:04:12.370
I'm trying to point out how easy it is to use your poster is in our application.

82
00:04:12.370 --> 00:04:15.010
Have just written four lines of code.

83
00:04:15.010 --> 00:04:17.200
At this moment, you might be asking yourself,

84
00:04:17.200 --> 00:04:21.270
all right, but what is the actual implementation for that interface?

85
00:04:21.270 --> 00:04:25.870
We created an interface, but we implement it, and that's a very good question.

86
00:04:25.870 --> 00:04:27.820
Well, spring.

87
00:04:27.820 --> 00:04:28.180
Thus,

88
00:04:28.180 --> 00:04:31.080
all the magic behind the scene for a total post or the

89
00:04:31.080 --> 00:04:35.060
interface spring registers the appropriate technology

90
00:04:35.060 --> 00:04:40.530
specific factory being that in turn, creates the appropriate Proxim fermentation.

91
00:04:40.530 --> 00:04:42.970
So for any interface that we define,

92
00:04:42.970 --> 00:04:47.340
spring creates approximate lamentation of it with the correct behavior,

93
00:04:47.340 --> 00:04:50.360
and that's how we get capabilities out of the box without us

94
00:04:50.360 --> 00:04:53.390
having to tackle the persistence details for just writing an

95
00:04:53.390 --> 00:04:54.890
interface we're declaring.

96
00:04:54.890 --> 00:04:57.180
What do we want to do?

97
00:04:57.180 --> 00:04:58.590
What are we trying to achieve?

98
00:04:58.590 --> 00:05:05.000
And spring takes care of the ugly part. Now, if that's not awesome, then I don't know what is.

