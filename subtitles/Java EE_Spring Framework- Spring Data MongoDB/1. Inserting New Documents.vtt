WEBVTT
1
00:00:00.240 --> 00:00:01.250
[Autogenerated] up until now,

2
00:00:01.250 --> 00:00:06.580
we looked at how to retrieve inquiry data from OTB in spring applications,

3
00:00:06.580 --> 00:00:09.920
but I think it's time to look at the other side of the spectrum.

4
00:00:09.920 --> 00:00:11.350
So his module,

5
00:00:11.350 --> 00:00:14.380
you're going to learn how to insert new documents in a

6
00:00:14.380 --> 00:00:17.340
mongo database from a spring application.

7
00:00:17.340 --> 00:00:21.440
How to update a decent documents, how to remove documents.

8
00:00:21.440 --> 00:00:26.170
Then we'll take a look at converters and see how we can utilize them

9
00:00:26.170 --> 00:00:29.880
for civilization and destroy ization off fields.

10
00:00:29.880 --> 00:00:32.470
And as but not these will wrap it up to Demo in,

11
00:00:32.470 --> 00:00:35.780
which will apply everything that we have learned in this module.

12
00:00:35.780 --> 00:00:36.770
Sounds interesting.

13
00:00:36.770 --> 00:00:37.980
Let's get to it.

14
00:00:37.980 --> 00:00:41.650
Databases are not fun if they don't contain anything.

15
00:00:41.650 --> 00:00:46.400
So let's try to insert some data in a Mongol database from a spring application.

16
00:00:46.400 --> 00:00:50.760
But before we do that, let's take a look at the overall is third process.

17
00:00:50.760 --> 00:00:51.960
When it comes to Mongo D.

18
00:00:51.960 --> 00:00:52.810
B.

19
00:00:52.810 --> 00:00:58.040
Let's assume you have a document that you want to store that want to persist.

20
00:00:58.040 --> 00:01:00.220
If the collection does not exist,

21
00:01:00.220 --> 00:01:03.700
Mangal will automatically create that collection for us.

22
00:01:03.700 --> 00:01:06.900
Then, if our document doesn't have an I D.

23
00:01:06.900 --> 00:01:10.520
Mangal will also generate a random I d for us.

24
00:01:10.520 --> 00:01:12.910
If not, it could use the one that he has.

25
00:01:12.910 --> 00:01:15.170
And then it was safe.

26
00:01:15.170 --> 00:01:17.260
That single document, Atomic Lee.

27
00:01:17.260 --> 00:01:18.390
So not very difficult.

28
00:01:18.390 --> 00:01:22.990
But we already see the many things that Mongo does for us automatically,

29
00:01:22.990 --> 00:01:26.110
including creating the collection and generating the idee.

30
00:01:26.110 --> 00:01:28.640
I mentioned Atomic Lee earlier.

31
00:01:28.640 --> 00:01:29.990
What they mean by that?

32
00:01:29.990 --> 00:01:34.820
Well, mom got to be body full support single document transactions.

33
00:01:34.820 --> 00:01:39.620
So on operation of a single document is atomic either succeeds or fails.

34
00:01:39.620 --> 00:01:41.400
And because mongo is an article,

35
00:01:41.400 --> 00:01:46.140
database and relationships are embedded in that single document,

36
00:01:46.140 --> 00:01:49.640
then these mostly eliminates the need for multi document transactions.

37
00:01:49.640 --> 00:01:53.870
However, what's neat is that starting with version for Mongo, D.

38
00:01:53.870 --> 00:01:56.980
B also supports mostly document transaction.

39
00:01:56.980 --> 00:02:02.040
And this is something very rare in the no sequel world.

40
00:02:02.040 --> 00:02:05.820
But just because we have them doesn't mean we have toe overuse them.

41
00:02:05.820 --> 00:02:07.470
So this is my advice to you.

42
00:02:07.470 --> 00:02:10.880
Don't overuse mongo multi document transactions.

43
00:02:10.880 --> 00:02:12.140
You can do that.

44
00:02:12.140 --> 00:02:16.450
But no sequel was not designed with this in mind.

45
00:02:16.450 --> 00:02:21.730
So we should really try to make your documents as embedded as possible and

46
00:02:21.730 --> 00:02:25.010
try to limit the use of relationships between documents.

47
00:02:25.010 --> 00:02:26.380
But enough of the theory.

48
00:02:26.380 --> 00:02:27.900
Let's look at some coat.

49
00:02:27.900 --> 00:02:32.420
We're creating a new person called Anna, and Anna has the age of 18.

50
00:02:32.420 --> 00:02:37.730
If you want to insert a document we can use Well, you guessed it Mongo template.

51
00:02:37.730 --> 00:02:42.710
And here we have a method called Insert it passing the object,

52
00:02:42.710 --> 00:02:47.140
and that document is going to be stored in our mongo collection.

53
00:02:47.140 --> 00:02:49.320
Now, don't get fooled by the stable over here.

54
00:02:49.320 --> 00:02:52.410
I want to represent this concept using a table.

55
00:02:52.410 --> 00:02:56.960
But as you know, documents in a Mongol database are not tabular.

56
00:02:56.960 --> 00:03:00.940
What if you want to create a personality so we're creating a new person,

57
00:03:00.940 --> 00:03:04.760
but this time also giving it a ny D by default.

58
00:03:04.760 --> 00:03:10.270
Then we call Mongo template insert, and a lot make is going to be inserted.

59
00:03:10.270 --> 00:03:10.990
But this time,

60
00:03:10.990 --> 00:03:13.810
Mangal will not generate an i d for us because you have

61
00:03:13.810 --> 00:03:17.130
provided that I d when you created the object.

62
00:03:17.130 --> 00:03:21.840
So the a d dirty provide is the one that is going to be stored.

63
00:03:21.840 --> 00:03:25.670
And what if we want to create a new person in this time Stan

64
00:03:25.670 --> 00:03:30.510
with the age of 34 but accidentally assign it on existing I d

65
00:03:30.510 --> 00:03:31.830
we're going to get an error,

66
00:03:31.830 --> 00:03:35.150
A duplicate key exception and your document is not going

67
00:03:35.150 --> 00:03:37.280
to be inserted in the Mongol batteries.

68
00:03:37.280 --> 00:03:41.480
And this is happening because I d by default is an indexed

69
00:03:41.480 --> 00:03:44.720
field with the unique property said to true.

70
00:03:44.720 --> 00:03:47.430
All right, we know how to insert single documents.

71
00:03:47.430 --> 00:03:51.110
But what if you have a ton of documents that you want to be certain?

72
00:03:51.110 --> 00:03:53.830
Let's assume you want to bootstrap a system,

73
00:03:53.830 --> 00:03:55.770
and we have to insert a lot of people.

74
00:03:55.770 --> 00:03:56.550
Well,

75
00:03:56.550 --> 00:04:01.220
the naive way would be to create all of our persons and then

76
00:04:01.220 --> 00:04:04.640
Cole insert for each and every one of them,

77
00:04:04.640 --> 00:04:05.650
and this will work.

78
00:04:05.650 --> 00:04:07.170
It's a fully functional solution,

79
00:04:07.170 --> 00:04:12.350
but it is not efficient because you have a free round trips to the database.

80
00:04:12.350 --> 00:04:13.700
Is there a better solution?

81
00:04:13.700 --> 00:04:15.780
Well, yes, it is.

82
00:04:15.780 --> 00:04:20.330
We can combine all these persons into a least off persons.

83
00:04:20.330 --> 00:04:21.810
We call it people over here,

84
00:04:21.810 --> 00:04:25.500
and then we can use the insert all method on the Mongol

85
00:04:25.500 --> 00:04:28.410
template and passing that collection of people.

86
00:04:28.410 --> 00:04:34.110
This is what we call a badge insert, and we have the same result as before.

87
00:04:34.110 --> 00:04:37.290
But now we get a single round ship to the database.

88
00:04:37.290 --> 00:04:40.080
So the performance increase is really considerable,

89
00:04:40.080 --> 00:04:42.580
especially if we have a large number of documents that

90
00:04:42.580 --> 00:04:49.000
want to save in a single round trip. That's how you do batch inserts in Margo, TB and Spring.

