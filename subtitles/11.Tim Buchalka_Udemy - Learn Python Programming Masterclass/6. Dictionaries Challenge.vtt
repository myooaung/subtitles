WEBVTT
1
1

00:00:05.320  -->  00:00:07.700
Okay.
So it's time for a Python challenge.
2

2

00:00:07.700  -->  00:00:11.340
We're actually going to do
two challenges for these, for
3

3

00:00:11.340  -->  00:00:13.240
the dictionary sort of things.
4

4

00:00:13.240  -->  00:00:16.940
So the first one, let me introduce,
I'm gonna copy this code because
5

5

00:00:16.940  -->  00:00:20.620
ultimately we're going to be using
that and I'm gonna create a new file.
6

6

00:00:20.620  -->  00:00:22.430
A new Python File.
7

7

00:00:22.430  -->  00:00:23.440
And we'll call this challenge.
8

8

00:00:25.830  -->  00:00:26.910
I'm just gonna paste it in there.
9

9

00:00:26.910  -->  00:00:31.040
That's the standard code that we
worked on in the previous video.
10

10

00:00:31.040  -->  00:00:33.400
But what we're going to do,
come up to the top here.
11

11

00:00:35.810  -->  00:00:39.620
We're gonna paste in First challenge,
bearing in mind there's a couple of
12

12

00:00:39.620  -->  00:00:41.750
challenges here, and
we saw a couple of sections.
13

13

00:00:41.750  -->  00:00:46.640
So the challenge at the moment is to
modify the program that you see below, so
14

14

00:00:46.640  -->  00:00:50.290
that the exits are a dictionary
rather than a list.
15

15

00:00:50.290  -->  00:00:53.260
And the keys being the numbers of
the locations and the values being
16

16

00:00:53.260  -->  00:00:56.760
dictionaries holding the exits, and
obviously they're doing that at present.
17

17

00:00:56.760  -->  00:01:00.160
So no change should be needed
to the actual code itself,
18

18

00:01:00.160  -->  00:01:03.890
it's just basically the dictionaries and
lists that you're changing.
19

19

00:01:03.890  -->  00:01:04.900
And once that's working,
20

20

00:01:04.900  -->  00:01:09.500
we're gonna create another dictionary
that contains words That players can use.
21

21

00:01:09.500  -->  00:01:11.110
Instructions, in other words.
22

22

00:01:11.110  -->  00:01:13.210
And these words will be the keys, and
23

23

00:01:13.210  -->  00:01:17.890
the valleys will be a single letter that
the can use to determine which way to go.
24

24

00:01:17.890  -->  00:01:19.680
So that's the challenge.
25

25

00:01:19.680  -->  00:01:20.840
Two components of a challenge.
26

26

00:01:20.840  -->  00:01:24.480
And bearing in mind it's also a secondary
challenge which you will be doing later.
27

27

00:01:24.480  -->  00:01:27.160
So go away and
see if you can complete both of those and
28

28

00:01:27.160  -->  00:01:31.820
once you're ready come back and we'll work
through both parts of this challenge.
29

29

00:01:31.820  -->  00:01:32.520
Pause the video now.
30

30

00:01:35.510  -->  00:01:36.450
Okay, so how did you get on?
31

31

00:01:36.450  -->  00:01:39.800
Hopefully you managed to resolve that and
you've got it working.
32

32

00:01:39.800  -->  00:01:43.260
So the first stage is actually quite easy
so what we really want to do here is just
33

33

00:01:43.260  -->  00:01:48.920
change exits From a dictionary or sorry
from a list I should say to a dictionary.
34

34

00:01:48.920  -->  00:01:50.280
So let's go ahead now and make the change.
35

35

00:01:50.280  -->  00:01:50.820
Want to go ahead and
36

36

00:01:50.820  -->  00:01:54.570
convert the existing list which
is on line 18 into a dictionary.
37

37

00:01:54.570  -->  00:01:58.280
So to do that we're going to start by
removing the square brackets which
38

38

00:01:58.280  -->  00:01:59.380
indicate that it's a list.
39

39

00:02:02.380  -->  00:02:04.470
Like so and I'll just put a bit of
space here so it's a bit clearer.
40

40

00:02:05.560  -->  00:02:09.770
That we also need to put our keys in for
each part so zero colon,
41

41

00:02:09.770  -->  00:02:13.920
one colon,
42

42

00:02:13.920  -->  00:02:18.130
two colon.
43

43

00:02:18.130  -->  00:02:24.820
Three column, four column,
and five column.
44

44

00:02:24.820  -->  00:02:27.370
So the keys are obviously the rooms.
45

45

00:02:27.370  -->  00:02:28.790
The locations as they are before.
46

46

00:02:28.790  -->  00:02:31.920
And I'll just clear that
up a little bit like so.
47

47

00:02:31.920  -->  00:02:33.700
And that should be all we need to do.
48

48

00:02:33.700  -->  00:02:36.280
We've converted it now from
a list to a dictionary.
49

49

00:02:36.280  -->  00:02:39.170
If a key being the location 0, 1, 2, 3, 4,
50

50

00:02:39.170  -->  00:02:43.680
5 Which matches our location dictionary
above, so if we run that, and
51

51

00:02:46.540  -->  00:02:50.280
we should still be able to go
say north you're in the forest,
52

52

00:02:50.280  -->  00:02:55.780
south you're standing at the end of
a road we can quit, he's sitting
53

53

00:02:55.780  -->  00:02:58.530
in front of a computer learning Python so
that's the first part of the challenge.
54

54

00:02:59.640  -->  00:03:01.230
Converting it to a dictionary and
55

55

00:03:01.230  -->  00:03:04.600
note how we didn't have to change
any of the code that's the beauty
56

56

00:03:04.600  -->  00:03:09.060
that if we're using a numerical key for
a dictionary, the syntax for retrieving
57

57

00:03:09.060  -->  00:03:13.480
the dictionary value by key is the same
as retrieving a list item by index.
58

58

00:03:13.480  -->  00:03:16.360
That's one of the great things that
happened here, the code doesn't have to
59

59

00:03:16.360  -->  00:03:20.950
change to accommodate The change in the
data structure from list to dictionary.
60

60

00:03:20.950  -->  00:03:22.510
Okay so for the second part so
61

61

00:03:22.510  -->  00:03:26.610
we need to create a dictionary whose
keys are the words we're interested and
62

62

00:03:26.610  -->  00:03:29.760
the values of the single letter
that the program expects.
63

63

00:03:29.760  -->  00:03:33.490
So if the pro players talks
more than a single letter.
64

64

00:03:33.490  -->  00:03:35.710
Then we use the vocabulary dictionary.
65

65

00:03:35.710  -->  00:03:38.500
Because they could type
something like run less quickly,
66

66

00:03:38.500  -->  00:03:41.510
we don't use the text as the value to
look up, but we do it the other way.
67

67

00:03:41.510  -->  00:03:43.950
We iterate through the keys
to see if their text
68

68

00:03:43.950  -->  00:03:46.440
contains one of the words
that we recognize.
69

69

00:03:46.440  -->  00:03:50.620
So, what we need to do first is create our
vocabulary, we're going to put it down
70

70

00:03:50.620  -->  00:03:53.210
here and that's going to be a dictionary
with the relevant commands.
71

71

00:03:54.400  -->  00:04:01.200
So, we're going to start by
typing vocabulary equals and
72

72

00:04:01.200  -->  00:04:05.750
the first one will be quit and
the key, the value will be two.
73

73

00:04:05.750  -->  00:04:14.890
North, north, south,
74

74

00:04:19.610  -->  00:04:22.890
east, and west.
75

75

00:04:22.890  -->  00:04:27.800
[SOUND] And
we can just tidy it up a little bit so
76

76

00:04:27.800  -->  00:04:29.800
it sits there nicely, but that's optional.
77

77

00:04:29.800  -->  00:04:32.200
So we've now assigned the vocabulary.
78

78

00:04:32.200  -->  00:04:32.980
The dictionary.
79

79

00:04:32.980  -->  00:04:35.740
We've assigned and created a dictionary
and assigned it to vocabulary.
80

80

00:04:35.740  -->  00:04:36.730
The variable.
81

81

00:04:36.730  -->  00:04:38.860
So what we want to do
now is add some codes.
82

82

00:04:38.860  -->  00:04:41.830
So once we've actually got a command
that's been given to us and
83

83

00:04:41.830  -->  00:04:43.290
the users selected that and typed it in.
84

84

00:04:43.290  -->  00:04:45.610
Down here we want to
start adding some code.
85

85

00:04:45.610  -->  00:04:50.630
So we want to parse the input so
we're gonna parse user
86

86

00:04:50.630  -->  00:04:59.060
report using our vocabulary
dictionary if necessary.
87

87

00:05:00.700  -->  00:05:03.340
And we're only going to do that remember
if the length is greater than one.
88

88

00:05:03.340  -->  00:05:10.320
So I'm going to put if, len, direction,
direction, greater than one.
89

89

00:05:12.380  -->  00:05:17.450
In other words, more than one letter.
90

90

00:05:17.450  -->  00:05:19.510
Check out vocab.
91

91

00:05:19.510  -->  00:05:23.020
Then we put four word in vocabulary.
92

92

00:05:24.850  -->  00:05:29.870
So what effectively we're doing now
is does it contain a word we know?
93

93

00:05:32.500  -->  00:05:38.660
If word in direction,
if it does then direction,
94

94

00:05:38.660  -->  00:05:43.540
direction becomes equal
to vocabulary(word) and
95

95

00:05:43.540  -->  00:05:45.700
we'll just clean it up a little bit.
96

96

00:05:45.700  -->  00:05:48.360
And that's actually it
as you can see then.
97

97

00:05:48.360  -->  00:05:50.740
Remember, we're also converting
it to upper case as well.
98

98

00:05:50.740  -->  00:05:53.180
So we're really only testing
to see whatever they have
99

99

00:05:53.180  -->  00:05:55.990
typed is greater than 1, so
more than one character.
100

100

00:05:55.990  -->  00:06:00.240
If it is, we're gonna go through our
dictionary and try to find a match for
101

101

00:06:00.240  -->  00:06:01.060
whatever they have typed.
102

102

00:06:01.060  -->  00:06:03.160
And if they have typed
something like north,
103

103

00:06:03.160  -->  00:06:06.110
we're gonna match it back to
the value N as you can see there.
104

104

00:06:06.110  -->  00:06:07.830
Let's actually run this and
see if it works.
105

105

00:06:07.830  -->  00:06:10.050
So, first thing, you should just check.
106

106

00:06:10.050  -->  00:06:12.240
If you go north, you're in a forest.
107

107

00:06:12.240  -->  00:06:14.160
South, you're standing in the road.
108

108

00:06:14.160  -->  00:06:18.200
And if you type north, you're in a forest.
109

109

00:06:20.060  -->  00:06:22.420
But also you should be able to type,
go north.
110

110

00:06:24.070  -->  00:06:28.620
Your gonna first go south,
and the reason is
111

111

00:06:28.620  -->  00:06:32.600
we're actually done looking at our and
we're going through our dictionary and
112

112

00:06:32.600  -->  00:06:35.590
we're comparing each word of
the dictionary to see whether it's fine or
113

113

00:06:35.590  -->  00:06:40.580
whatevers being So, the entire string is
going south We are checking to see if
114

114

00:06:40.580  -->  00:06:43.500
the word South is actually in that string
and that's why it's working that way
115

115

00:06:43.500  -->  00:06:48.290
even though we've typed extra letters that
are not in it, exact match so to speak.
116

116

00:06:48.290  -->  00:06:50.460
So what we now got is
a fairly flexible way for
117

117

00:06:50.460  -->  00:06:53.920
players to specify which
direction they'd like to go in.
118

118

00:06:53.920  -->  00:06:57.010
And for that reason alone hopefully
that's demonstrated the power of using
119

119

00:06:57.010  -->  00:06:57.720
dictionaries.
120

120

00:06:57.720  -->  00:07:01.940
Once you are actually used to using
dictionaries Even our exits one.
121

121

00:07:01.940  -->  00:07:06.020
The exits diction where you will be
converted makes a lot more sense, but
122

122

00:07:06.020  -->  00:07:09.210
you can probably see why we chose
to use a list initially and
123

123

00:07:09.210  -->  00:07:11.720
that's because a dictionary
of dictionaries
124

124

00:07:11.720  -->  00:07:13.920
can look confusing at first until
you sort of understand the.
125

125

00:07:13.920  -->  00:07:14.550
Concepts.
126

126

00:07:14.550  -->  00:07:17.380
Now with that said, we can make
the program a bit more efficient though.
127

127

00:07:17.380  -->  00:07:21.000
So it's quite likely that our
vocabulary will grow quite large,
128

128

00:07:21.000  -->  00:07:24.090
whereas the text the players type
in will only be a few words.
129

129

00:07:24.090  -->  00:07:24.750
So as a result,
130

130

00:07:24.750  -->  00:07:28.390
it's really not efficient to perform
the word lookup the way we have.
131

131

00:07:28.390  -->  00:07:32.800
As we could literally end up iterating
through a large collection of keys before
132

132

00:07:32.800  -->  00:07:35.630
we find the one that's
in the player's input,
133

133

00:07:35.630  -->  00:07:37.220
that's contained in the player's input.
134

134

00:07:37.220  -->  00:07:41.140
A better way would be to check each
word that the player has typed to
135

135

00:07:41.140  -->  00:07:42.980
see if it's in the vocabulary.
136

136

00:07:42.980  -->  00:07:46.620
Cuz obviously, starting from that way,
rather than coming from the.
137

137

00:07:46.620  -->  00:07:48.850
Starting at the vocabulary and
going through that.
138

138

00:07:48.850  -->  00:07:49.680
Better to go the other way.
139

139

00:07:49.680  -->  00:07:52.230
And Python provides a way to do just that.
140

140

00:07:52.230  -->  00:07:55.090
So what we need to do is break up
the input that the [INAUDIBLE].
141

141

00:07:55.090  -->  00:07:59.340
Applies topped into individual words
in other words individual sequences of
142

142

00:07:59.340  -->  00:08:03.720
characters separated by spaces so really
what we want to do there is we want to do
143

143

00:08:03.720  -->  00:08:07.930
the opposite of join and in fact there is
a method to do that and its called split.
144

144

00:08:07.930  -->  00:08:09.630
And it does exactly what we want.
145

145

00:08:09.630  -->  00:08:14.370
So given a string,
the split command or the split
146

146

00:08:14.370  -->  00:08:18.960
method will split a string into a list
containing all the parts of the string
147

147

00:08:18.960  -->  00:08:23.400
that are separated by the delimiter of our
choice, which is gonna be a space here.
148

148

00:08:23.400  -->  00:08:27.090
And if we don't specify a delimiter,
it defaults to a space.
149

149

00:08:27.090  -->  00:08:28.000
But we could use commas,
150

150

00:08:28.000  -->  00:08:31.620
colons or any other type of text
that we want as a delimiter.
151

151

00:08:31.620  -->  00:08:33.640
So let's have a look at,
see that in action.
152

152

00:08:33.640  -->  00:08:36.940
What we want to do before we start,
we want to comment
153

153

00:08:36.940  -->  00:08:39.440
out the call of the [INAUDIBLE] So
I'm going to close this down.
154

154

00:08:40.580  -->  00:08:41.900
Disconnect.
155

155

00:08:41.900  -->  00:08:45.170
Let's go ahead and comment all that
code out for now, cuz we don't need it.
156

156

00:08:45.170  -->  00:08:46.640
Come back to that later.
157

157

00:08:46.640  -->  00:08:50.430
Comment all that out again with command
slash, which is control slash for
158

158

00:08:50.430  -->  00:08:56.150
Windows and Linux after selecting it, and
we'll put our code up here We're probably
159

159

00:08:56.150  -->  00:08:59.750
coming to that area as well, the lock = 1
because that's all part and parcel of it.
160

160

00:08:59.750  -->  00:09:02.650
So let's actually try the split function,
let's do a couple of examples.
161

161

00:09:02.650  -->  00:09:07.000
We can do a print locations 0.
162

162

00:09:07.000  -->  00:09:15.620
split, and also try print locations 3.
163

163

00:09:15.620  -->  00:09:16.440
split.
164

164

00:09:18.180  -->  00:09:19.460
Passing a parameter this time.
165

165

00:09:19.460  -->  00:09:20.670
I was, or, comma.
166

166

00:09:22.570  -->  00:09:23.820
And let's also try this one.
167

167

00:09:23.820  -->  00:09:25.110
Print.
Space.
168

168

00:09:25.110  -->  00:09:25.630
Dot.
169

169

00:09:25.630  -->  00:09:27.920
Join locations.
170

170

00:09:27.920  -->  00:09:28.620
Zero.
171

171

00:09:28.620  -->  00:09:29.150
Dot.
172

172

00:09:29.150  -->  00:09:30.200
Spirit.
173

173

00:09:30.200  -->  00:09:36.300
[SOUND] So, let's run this.
174

174

00:09:36.300  -->  00:09:39.050
So you can see what happened
with the first one.
175

175

00:09:39.050  -->  00:09:42.830
It splits, you are sitting in front of
a computer learning Python, into a list
176

176

00:09:42.830  -->  00:09:46.430
containing the 10 words, which is pretty
cool that it's done that automatically.
177

177

00:09:46.430  -->  00:09:51.020
The 2nd example gave a list, gives a list
containing 2 items, as you can see,
178

178

00:09:51.020  -->  00:09:55.730
because it's split based on the fact that
we passed the parameter of a comma, so
179

179

00:09:55.730  -->  00:09:59.940
it's using that a as a delimiter
instead of the default being a space.
180

180

00:09:59.940  -->  00:10:02.890
Which the split method will use
unless you give it a parameter.
181

181

00:10:02.890  -->  00:10:05.880
And incidentally if you didn't want
a leading space in the second list item,
182

182

00:10:05.880  -->  00:10:09.920
you could specify comma as a string to
split on if you wanted to do it that way.
183

183

00:10:09.920  -->  00:10:11.790
So split's the opposite of join so
184

184

00:10:11.790  -->  00:10:15.990
the final print is interesting if
as it turns out a little futile.
185

185

00:10:15.990  -->  00:10:21.340
So it uses split to split the text that
spaces, but then it also calls join
186

186

00:10:21.340  -->  00:10:24.270
on a string containing a single
space to join them back up again.
187

187

00:10:24.270  -->  00:10:27.250
So really the end result is the orignal
string that you worked with.
188

188

00:10:27.250  -->  00:10:29.320
Ok, so armed with this split method,
189

189

00:10:29.320  -->  00:10:32.720
we can rewrite the program to
work the correct way around.
190

190

00:10:32.720  -->  00:10:35.740
So I can check the players
input against the vocabulary,
191

191

00:10:35.740  -->  00:10:37.050
instead of the other way around.
192

192

00:10:37.050  -->  00:10:38.440
So let's go back and do that.
193

193

00:10:38.440  -->  00:10:43.770
And I'm going to comment these [INAUDIBLE]
out, like so, and I'm going to select
194

194

00:10:43.770  -->  00:10:48.050
the [INAUDIBLE] code that we Comment
it out, and do a command slash again.
195

195

00:10:48.050  -->  00:10:50.950
Just control slash on Windows and
Linux, and that makes it,
196

196

00:10:50.950  -->  00:10:54.410
more [INAUDIBLE] gets rid of the comments,
so that we can work on it again.
197

197

00:10:54.410  -->  00:10:56.280
So what we want to do here is see,
198

198

00:10:56.280  -->  00:10:59.840
in this method is this part here
after the [INAUDIBLE] direction.
199

199

00:10:59.840  -->  00:11:01.970
You really just want to
comment that out for now.
200

200

00:11:01.970  -->  00:11:03.880
[INAUDIBLE] I'll do is I'll delete that.
201

201

00:11:03.880  -->  00:11:07.380
So after the test to make sure that what's
been taught has more than one characters
202

202

00:11:07.380  -->  00:11:12.840
in it,
we do words equals direction of split.
203

203

00:11:12.840  -->  00:11:17.340
So we're splitting up the input using
the default delimiter of a space.
204

204

00:11:17.340  -->  00:11:20.380
Cuz we're gonna go through those words,
so for word in words.
205

205

00:11:21.480  -->  00:11:25.680
And we're going a test the other way
this time and we're putting if word In
206

206

00:11:27.040  -->  00:11:32.630
vocabulary direction
equals vocabulary word.
207

207

00:11:32.630  -->  00:11:35.160
And we can also break at that point.
208

208

00:11:36.460  -->  00:11:39.430
So you can see how we've
done it the other way now.
209

209

00:11:39.430  -->  00:11:43.740
So what we've done is we've taken doing
our searching based on what the users
210

210

00:11:43.740  -->  00:11:48.360
typed instead of going through the whole
dictionary, which Isn't a problem now, but
211

211

00:11:48.360  -->  00:11:51.460
if we started having hundreds of entries,
it could start slowing it down.
212

212

00:11:51.460  -->  00:11:55.510
So it's always something that you should
be looking at when you're developing code,
213

213

00:11:55.510  -->  00:11:58.040
to decide which angle should I start from.
214

214

00:11:58.040  -->  00:12:00.750
Is it best to start, in this case,
from the user's input,
215

215

00:12:00.750  -->  00:12:03.200
because chances are there's only
gonna be a few words there,
216

216

00:12:03.200  -->  00:12:06.960
instead of automatically processing
the entire dictionary each time,
217

217

00:12:06.960  -->  00:12:09.030
which we did in sort of
the first version of this code.
218

218

00:12:09.030  -->  00:12:10.560
Let's run this and make sure it works.
219

219

00:12:11.980  -->  00:12:15.190
So if we type east, okay, and
220

220

00:12:15.190  -->  00:12:19.700
now back to west again, and
if we type E, go back to west again.
221

221

00:12:21.880  -->  00:12:23.080
Please sir, can I go east.
222

222

00:12:25.190  -->  00:12:28.900
And it's gonna say it's found east,
so it's gonna [INAUDIBLE]
223

223

00:12:28.900  -->  00:12:32.660
each one of those words and found east
as the last word, And that works.
224

224

00:12:32.660  -->  00:12:33.570
So we go back west again.
225

225

00:12:33.570  -->  00:12:36.670
And just to make sure,
226

226

00:12:36.670  -->  00:12:42.100
how bout going east now again.
227

227

00:12:42.100  -->  00:12:43.070
And still found that as well.
228

228

00:12:44.080  -->  00:12:44.900
So that's it.
I hope
229

229

00:12:44.900  -->  00:12:46.190
you got a lot out of that challenge.
230

230

00:12:46.190  -->  00:12:48.250
So we're not done yet with dictionaries.
231

231

00:12:48.250  -->  00:12:51.610
In the next video, we're gonna go ahead
and continue our work on dictionaries.
232

232

00:12:51.610  -->  00:12:54.200
And specifically we're going to
be looking at the update method
233

233

00:12:54.200  -->  00:12:56.460
which allows you to
combine two dictionaries.
234

234

00:12:56.460  -->  00:13:00.310
And also a copy method that's used
to create a copy of a dictionary and
235

235

00:13:00.310  -->  00:13:03.010
then we'll go into another challenge for
that as well.
236

236

00:13:03.010  -->  00:13:04.160
So see you in the next video.
