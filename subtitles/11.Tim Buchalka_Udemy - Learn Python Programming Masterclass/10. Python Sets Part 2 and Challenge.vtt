WEBVTT
1
1

00:00:05.400  -->  00:00:08.630
So continuing on with our
discussion on sets (inaudible),
2

2

00:00:08.630  -->  00:00:12.090
we finish off on our last video just
talking about the different methods, and
3

3

00:00:12.090  -->  00:00:16.770
as you can see on line 61 and 62, when
you run this, you get the same results.
4

4

00:00:16.770  -->  00:00:21.530
You get the same results using dot
difference or using the minus sign.
5

5

00:00:21.530  -->  00:00:24.400
So which one you use depends, again,
on which one you find more readable.
6

6

00:00:24.400  -->  00:00:27.960
In our opinion, the difference method does
make it clear that you're working on sets,
7

7

00:00:27.960  -->  00:00:31.890
which you wouldn't necessarily see
just looking at line 62 in isolation.
8

8

00:00:31.890  -->  00:00:35.900
So again, looking at line 61,
it's pretty obvious that .difference
9

9

00:00:35.900  -->  00:00:39.930
is calling a method, so That's giving
you a that it's actually a set.
10

10

00:00:39.930  -->  00:00:43.440
Now, there's also an update
difference method and
11

11

00:00:43.440  -->  00:00:45.860
that performs the subtraction in place.
12

12

00:00:45.860  -->  00:00:47.670
In other words,
it doesn't return a new set, but
13

13

00:00:47.670  -->  00:00:52.350
what it does it modifies the set
upon which it is called on.
14

14

00:00:52.350  -->  00:00:54.050
As a result it returns none.
15

15

00:00:54.050  -->  00:00:57.080
And if you think about that,
remember the list dot sort method and
16

16

00:00:57.080  -->  00:00:59.610
the dictionary dot update methods
cause they did the similar thing.
17

17

00:00:59.610  -->  00:01:01.540
So see how that works.
18

18

00:01:01.540  -->  00:01:04.210
So lets continue our code down here,
so I'll make a bit more space,
19

19

00:01:04.210  -->  00:01:05.980
it's a little higher up on the screen.
20

20

00:01:07.000  -->  00:01:11.000
So we'll just make a bit
of space in our output.
21

21

00:01:13.480  -->  00:01:21.850
Then we're gonna
print(sorted[even]) print(squares).
22

22

00:01:21.850  -->  00:01:24.230
And we'll do even .difference.
23

23

00:01:24.230  -->  00:01:26.510
This time we're doing difference and
the score update.
24

24

00:01:26.510  -->  00:01:28.290
And we're gonna select squares.
25

25

00:01:28.290  -->  00:01:31.040
So, again we're passing squares
as a perimeter and even.
26

26

00:01:31.040  -->  00:01:34.720
So, that updates a curve
on the even variable.
27

27

00:01:34.720  -->  00:01:36.410
Now, on the even set.
28

28

00:01:36.410  -->  00:01:38.710
So, we're gonna print and sort it even and
29

29

00:01:40.090  -->  00:01:43.040
you should find that the changes have
been made to it, so let's run that.
30

30

00:01:44.620  -->  00:01:47.480
So I can say that we started
out with this long set, and
31

31

00:01:47.480  -->  00:01:50.330
then we printed out these squares.
32

32

00:01:50.330  -->  00:01:54.020
I don't know if you can see them now
being removed all the contents from
33

33

00:01:54.020  -->  00:01:57.790
these squares, cuz we've used Is
the difference update to remove them from
34

34

00:01:57.790  -->  00:02:00.710
the even set and
we printed a sort of even set.
35

35

00:02:00.710  -->  00:02:03.360
You can see those numbers
clearly aren't there anymore.
36

36

00:02:03.360  -->  00:02:06.780
So, moving on the next thing we want
to talk about is the the symmetric
37

37

00:02:06.780  -->  00:02:11.450
difference of two sets, so What that is
a symmetric difference of two sets is all
38

38

00:02:11.450  -->  00:02:15.260
the members that are in one set or
the other but not both.
39

39

00:02:15.260  -->  00:02:18.570
So being symmetric also means
that it doesn't matter which way
40

40

00:02:18.570  -->  00:02:20.500
round you calculate the difference.
41

41

00:02:20.500  -->  00:02:23.970
And once again what I'll, what we'll do is
we'll sort the result before printing it
42

42

00:02:23.970  -->  00:02:26.710
just to make it easy to
interpret The result
43

43

00:02:26.710  -->  00:02:30.640
you don't normally need to do that in
your coding for processing reasons.
44

44

00:02:30.640  -->  00:02:32.230
We're just making it easy
on the screen for you.
45

45

00:02:32.230  -->  00:02:35.350
So, let's just take this bit of code
here because we're going to use that and
46

46

00:02:35.350  -->  00:02:39.070
post that down here and
I'll just comment all that code out.
47

47

00:02:39.070  -->  00:02:43.080
Okay, so
we're gonna stand a code there for sets.
48

48

00:02:43.080  -->  00:02:47.960
So, what we're going to do now is the
symmetric difference so we're gonna Print
49

49

00:02:50.370  -->  00:02:54.430
symmetric in there.
50

50

00:02:56.850  -->  00:02:58.920
Symmetric even minus squares.
51

51

00:03:02.050  -->  00:03:04.540
And we'll do print sorter.
52

52

00:03:04.540  -->  00:03:08.380
Sorter is just for our eyes but we have to
do this to get the symmetric difference
53

53

00:03:08.380  -->  00:03:12.940
Symmetric difference squares.
54

54

00:03:12.940  -->  00:03:19.930
Thought so.
And we can also do a print symmetric
55

55

00:03:19.930  -->  00:03:25.510
squares minus even.
56

56

00:03:25.510  -->  00:03:30.560
Print squares.symmetric
57

57

00:03:30.560  -->  00:03:35.840
underscore difference even.
58

58

00:03:35.840  -->  00:03:38.500
We could do the same thing there if
we want to, we can sort that as well.
59

59

00:03:40.680  -->  00:03:43.580
Just to make sure that it's
going to come out the same way.
60

60

00:03:43.580  -->  00:03:44.450
Like I say, we run that.
61

61

00:03:44.450  -->  00:03:47.520
The output for
both is absolutely identical.
62

62

00:03:47.520  -->  00:03:51.410
So it doesn't matter which order we
run it on we get the same results.
63

63

00:03:53.220  -->  00:03:56.940
And I just remove sort of the,
if we run that again.
64

64

00:03:56.940  -->  00:03:59.680
It says symmetric difference
can be thought of
65

65

00:03:59.680  -->  00:04:02.910
as the opposite of intersection
which we covered earlier.
66

66

00:04:02.910  -->  00:04:05.590
The intersection of the two sets was 4,
6, and 16.
67

67

00:04:05.590  -->  00:04:10.980
So the symmetric difference is the set
of everything except those three values.
68

68

00:04:10.980  -->  00:04:14.120
Now symmetric difference can also
be performed using the carrot.
69

69

00:04:14.120  -->  00:04:16.260
You know, the sort of up arrow symbol,
70

70

00:04:16.260  -->  00:04:19.400
which is just really another way
of doing exactly the same thing.
71

71

00:04:19.400  -->  00:04:22.000
There's no performance advantage
with either method, so
72

72

00:04:22.000  -->  00:04:24.240
again it's really just
a matter of preference.
73

73

00:04:24.240  -->  00:04:27.070
What we'd suggest generally is using
the methods to make it clear that you're
74

74

00:04:27.070  -->  00:04:30.950
dealing with sets unless your program
was only or mainly using sets,
75

75

00:04:30.950  -->  00:04:35.290
in which case the shorter operators, again
we're talking about In a carrot the and,
76

76

00:04:35.290  -->  00:04:38.700
and the mono sign will be clearing
up because of the context.
77

77

00:04:38.700  -->  00:04:40.220
Now it may seem to be a quirky you know,
78

78

00:04:40.220  -->  00:04:45.070
so I took the sorted out and
when we ran it we got the same results.
79

79

00:04:45.070  -->  00:04:47.940
So, that's a little bit of a quirk
with a symmetric difference.
80

80

00:04:47.940  -->  00:04:51.390
When we did even Dot symmetric
dot difference squares
81

81

00:04:51.390  -->  00:04:53.710
we have to sort the result to
say the number is in order.
82

82

00:04:53.710  -->  00:04:57.070
When we did these, the symmetric
difference between squares and
83

83

00:04:57.070  -->  00:04:59.760
even result set printed out in order.
84

84

00:04:59.760  -->  00:05:02.720
So why that happens
we're not really sure so
85

85

00:05:02.720  -->  00:05:05.910
we're not sure if it happens with
all Python implementations and
86

86

00:05:05.910  -->  00:05:08.780
it's certainly not documented behavior so
if you did notice it.
87

87

00:05:08.780  -->  00:05:10.190
But don't rely on this for your program.
88

88

00:05:10.190  -->  00:05:13.130
So in other words,
if you did want that to be sorted.
89

89

00:05:13.130  -->  00:05:16.420
And for some reason it's sorting
without actual use of the sort method.
90

90

00:05:16.420  -->  00:05:19.540
You may actually want to put that in there
anyway because it might be a bug they fix
91

91

00:05:19.540  -->  00:05:25.180
in the future versions of Python So,
the last
92

92

00:05:25.180  -->  00:05:30.490
set difference method that we mentioned is
symmetric and it's called difference in
93

93

00:05:30.490  -->  00:05:34.870
It performs really just like the line 67
with a difference update, but obviously in
94

94

00:05:34.870  -->  00:05:38.750
this case it's using the symmetric
difference instead of the difference
95

95

00:05:38.750  -->  00:05:42.300
It updates the set that it's been called
upon rather than reset as you saw when we
96

96

00:05:42.300  -->  00:05:45.590
talked about the difference updates
as you saw again on line 67.
97

97

00:05:45.590  -->  00:05:48.020
Now there's two ways to
remove items from the set.
98

98

00:05:48.020  -->  00:05:50.780
We can use discard and remove.
99

99

00:05:50.780  -->  00:05:54.070
The only difference between them is
that removes would raise an error
100

100

00:05:54.070  -->  00:05:56.860
if the island to be
removed doesn't exist and
101

101

00:05:56.860  -->  00:05:59.970
whereas discard won't actually
raise an error in that scenario.
102

102

00:05:59.970  -->  00:06:02.180
So let's see some code that showing that.
103

103

00:06:02.180  -->  00:06:03.840
I'm just going to comment
this last bit of code out.
104

104

00:06:05.950  -->  00:06:10.030
And I'll just remove this sort of there.
105

105

00:06:10.030  -->  00:06:13.690
We don't really need it anymore so
I'll get rid of those.
106

106

00:06:13.690  -->  00:06:19.390
See what we're starting out with and
now we can start removing some.
107

107

00:06:19.390  -->  00:06:20.560
So I'm going to do squares.
108

108

00:06:20.560  -->  00:06:23.510
.discard 4.
109

109

00:06:23.510  -->  00:06:28.200
Squares dot remove, remove 16.
110

110

00:06:28.200  -->  00:06:30.180
And squares.discard.
111

111

00:06:31.560  -->  00:06:33.490
8, it should
112

112

00:06:39.530  -->  00:06:42.800
show no,
it should be no error does nothing.
113

113

00:06:42.800  -->  00:06:47.820
And obviously we're Because obviously
114

114

00:06:47.820  -->  00:06:50.770
eight isn't in the set as you can
see the set defined on line 73 and
115

115

00:06:50.770  -->  00:06:55.700
we can do print squares to see
that the 416 were removed but
116

116

00:06:58.760  -->  00:07:05.190
then if we do squares Dot remove
eight you should get an error.
117

117

00:07:06.790  -->  00:07:10.270
First thing I need to fix is error
up online, 75, that should fix.
118

118

00:07:10.270  -->  00:07:14.070
So if we run that now you can
see we did get the three.
119

119

00:07:14.070  -->  00:07:19.260
As you can see that we
started out we had 16,
120

120

00:07:19.260  -->  00:07:24.120
9, 4, 6 and 25 and you can see that 16 and
4 are now removed from the last attempt
121

121

00:07:24.120  -->  00:07:27.730
which was from line 86, and
then we tried to use squares remove.
122

122

00:07:27.730  -->  00:07:30.970
We actually got an error and again that's
the difference between the discard on line
123

123

00:07:30.970  -->  00:07:34.490
89 because the silent didn't return,
didn't raise an error.
124

124

00:07:34.490  -->  00:07:39.440
But the one on line 87 you can see
the remove does raise an error.
125

125

00:07:39.440  -->  00:07:41.990
That's the main difference,
remove does raise an error.
126

126

00:07:41.990  -->  00:07:43.460
whereas discard doesn't.
127

127

00:07:43.460  -->  00:07:46.540
If you want to use remove,
to safely use that,
128

128

00:07:46.540  -->  00:07:49.480
you should check the items in the set
before attempting to remove it.
129

129

00:07:49.480  -->  00:07:54.070
We would do something
like this to make sure.
130

130

00:07:54.070  -->  00:08:00.240
We put "if 8 in squares" and squares
don't remove 8, as you can see there.
131

131

00:08:00.240  -->  00:08:04.100
If you run that This time
we don't get an error and
132

132

00:08:04.100  -->  00:08:08.040
that's because we're checking first to
see where that eights in the set and
133

133

00:08:08.040  -->  00:08:12.760
it wasn't in this case so therefore
the code on line 88 didn't get executed.
134

134

00:08:12.760  -->  00:08:15.150
So probably the next
question you're asking
135

135

00:08:15.150  -->  00:08:18.620
Now it would be why do you wanna use
remove if discard seems much safer.
136

136

00:08:18.620  -->  00:08:21.780
Well the reason is,
sometimes you may want an error
137

137

00:08:21.780  -->  00:08:25.620
to be raised if an operation is
being attempted that shouldn't be.
138

138

00:08:25.620  -->  00:08:27.330
So when attempting to discard eight,
139

139

00:08:27.330  -->  00:08:29.620
there's no way indication
that anything's wrong.
140

140

00:08:29.620  -->  00:08:32.800
And it's not possible to
take any action if eight
141

141

00:08:32.800  -->  00:08:35.330
should not be deleted from the zero or
could not be deleted from the set.
142

142

00:08:35.330  -->  00:08:38.230
So we're gonna look at exceptions later
in the course so don't worry too much
143

143

00:08:38.230  -->  00:08:42.760
about this next bit of code it's really
just to show that we can trip an error and
144

144

00:08:42.760  -->  00:08:47.280
take some other action if we tip to remove
an item that doesn't exist from a set.
145

145

00:08:47.280  -->  00:08:49.710
Sometimes removing them for
that reason is more useful so
146

146

00:08:49.710  -->  00:08:53.250
to do that we can come back here And
we can put try.
147

147

00:08:53.250  -->  00:08:56.930
>> [NOISE]
>> And
148

148

00:08:56.930  -->  00:09:01.880
the codes going to be squares dot
remove eight, and put accept.
149

149

00:09:01.880  -->  00:09:07.480
Key error, print,
150

150

00:09:07.480  -->  00:09:11.890
item eight.
151

151

00:09:11.890  -->  00:09:15.130
Is not member of sets
152

152

00:09:16.790  -->  00:09:21.190
now if you fan run that to
the awesome eighties of the set.
153

153

00:09:21.190  -->  00:09:24.670
Okay so this is try try and receptors.
154

154

00:09:24.670  -->  00:09:28.790
Exceptions that are used in path in which
we won't be going through the details now,
155

155

00:09:28.790  -->  00:09:31.080
but later in the course
you'll see more about those.
156

156

00:09:31.080  -->  00:09:34.190
The point is we're able to trap
the error and do some processing,
157

157

00:09:34.190  -->  00:09:36.450
which in this case consisted
only of printing a message but
158

158

00:09:36.450  -->  00:09:40.220
it could be anything if the removal
failed for some reason.
159

159

00:09:40.220  -->  00:09:44.830
Now the same is true when attempting
to access keys in a dictionary
160

160

00:09:44.830  -->  00:09:47.610
using the square brackets
rather than using a get, so
161

161

00:09:47.610  -->  00:09:50.340
in other words using [NOISE] When we use.
162

162

00:09:50.340  -->  00:09:53.460
Trying to get access to keys in
the dictionary using the square
163

163

00:09:53.460  -->  00:09:54.930
brackets instead of using get.
164

164

00:09:56.400  -->  00:09:58.420
Or they get is very useful,
165

165

00:09:58.420  -->  00:10:00.880
because we might need to take
action if the key is not present.
166

166

00:10:00.880  -->  00:10:05.010
So that's the reason that partham also
provides a way to raise an exception
167

167

00:10:05.010  -->  00:10:07.020
in error if the key is not present so.
168

168

00:10:07.020  -->  00:10:09.690
Basically the same concept here for a set.
169

169

00:10:09.690  -->  00:10:14.390
Okay, so we've now seen how to create
a set using either a set [INAUDIBLE] and
170

170

00:10:14.390  -->  00:10:17.980
closing the members in clearly brackets or
the set constructors.
171

171

00:10:17.980  -->  00:10:20.560
You have also seen how to add and
remove members.
172

172

00:10:20.560  -->  00:10:25.230
As well as creating new sets that are the
union and intersection of two other sets.
173

173

00:10:25.230  -->  00:10:28.700
We can subtract sets from each
other as well, which you say.
174

174

00:10:28.700  -->  00:10:32.730
And in the same way that you can create
a set from a list by passing the list
175

175

00:10:32.730  -->  00:10:35.710
to the set constructor,
you can actually go the other way.
176

176

00:10:35.710  -->  00:10:40.330
So in other words you can create a list
from a set using the list constructor.
177

177

00:10:40.330  -->  00:10:43.900
In fact we did something similar
by passing the sets to the sorted
178

178

00:10:43.900  -->  00:10:46.160
function which will turn to list.
179

179

00:10:46.160  -->  00:10:49.860
So the last two operations with
sets are is subset and is superset.
180

180

00:10:49.860  -->  00:10:54.950
Now those will be used to test if one set
is a sub or super Set of the other set.
181

181

00:10:54.950  -->  00:10:58.100
Now one set is a sub set of
another if all the members
182

182

00:10:58.100  -->  00:10:59.480
are contained in the other set.
183

183

00:10:59.480  -->  00:11:01.660
Now similarly,
184

184

00:11:01.660  -->  00:11:07.200
one set is a super set of another if it
contains all the other sets and members.
185

185

00:11:07.200  -->  00:11:11.040
So if we remove the odd squares from our
project, which we're about to do now.
186

186

00:11:11.040  -->  00:11:12.730
We can see these two methods in action.
187

187

00:11:12.730  -->  00:11:18.050
So what I'm going to do is just
comment this out Encrypt this code.
188

188

00:11:18.050  -->  00:11:23.540
But we'll just code that as, well so
we can stop down at the bottom.
189

189

00:11:27.500  -->  00:11:31.120
Now what we're going to do for
these square.
190

190

00:11:31.120  -->  00:11:33.160
We'll just make that 4, 6, and 16.
191

191

00:11:33.160  -->  00:11:34.660
We'll leave the other ones out.
192

192

00:11:37.240  -->  00:11:43.470
And we can do something like
if squares dot is subset even.
193

193

00:11:43.470  -->  00:11:48.600
We're gonna
194

194

00:11:48.600  -->  00:11:53.950
do print squares is a subset Copy and we
195

195

00:11:56.130  -->  00:12:02.580
can also do even dot superset
is superset squares.
196

196

00:12:02.580  -->  00:12:09.270
Print is a super set of squares.
197

197

00:12:11.970  -->  00:12:12.530
So you can run that.
198

198

00:12:13.930  -->  00:12:15.880
Squares is a subset of even.
199

199

00:12:15.880  -->  00:12:17.890
Even is a superset of squares.
200

200

00:12:17.890  -->  00:12:19.610
So again, a subset.
201

201

00:12:19.610  -->  00:12:23.850
One set is a subset of another if all its
members are contained in the other set.
202

202

00:12:23.850  -->  00:12:28.600
And for superset, one set is a superset
of another If it contains all the other
203

203

00:12:28.600  -->  00:12:31.150
set's members then you can just
say that we've used the example
204

204

00:12:31.150  -->  00:12:35.910
of inverting the results to be able to
show that squares is a subset of even and
205

205

00:12:35.910  -->  00:12:37.760
even is a superset of squares.
206

206

00:12:39.200  -->  00:12:41.460
So sets are really not
used as often as lists.
207

207

00:12:41.460  -->  00:12:42.530
Dictionaries, but
208

208

00:12:42.530  -->  00:12:47.120
they can still be used, can be useful
as hopefully you've seen in this code.
209

209

00:12:47.120  -->  00:12:49.140
So our challenge we're about to
do is gonna show you how they
210

210

00:12:49.140  -->  00:12:50.620
can provide a quick way to modify data.
211

211

00:12:50.620  -->  00:12:52.840
Now before we start the challenge though,
212

212

00:12:52.840  -->  00:12:56.990
there's one more type of set available to
us in Python It's called a frozen set.
213

213

00:12:56.990  -->  00:13:01.300
And a frozen set is a immutable set
which of course can't be changed.
214

214

00:13:01.300  -->  00:13:06.220
So, when being unmutable at least we can
use a frozen set as a dictionary key,
215

215

00:13:06.220  -->  00:13:07.220
which is good.
216

216

00:13:07.220  -->  00:13:10.600
And we can also add a frozen
set as a member of a set.
217

217

00:13:10.600  -->  00:13:13.980
Now keep in mind there's no add methods,
there's no add, remove, or
218

218

00:13:13.980  -->  00:13:16.280
discard methods available
with a frozen set.
219

219

00:13:16.280  -->  00:13:17.800
Once created, it can't be changed.
220

220

00:13:17.800  -->  00:13:20.470
And obviously that's the reason
they haven't added those methods.
221

221

00:13:20.470  -->  00:13:28.040
So to use those, It'll
222

222

00:13:28.040  -->  00:13:34.370
give you something like even
equals frozen set range 0 100 2.
223

223

00:13:34.370  -->  00:13:38.770
And print even
224

224

00:13:40.870  -->  00:13:46.580
even dot add three notice that
the doesn't come up and if we run
225

225

00:13:46.580  -->  00:13:51.520
that we're getting an error because frozen
set object has no attribute for add.
226

226

00:13:51.520  -->  00:13:54.140
And as I mentioned, it hasn't got
those methods because it's immutable.
227

227

00:13:54.140  -->  00:13:57.170
Once we create it, we can't modify it.
228

228

00:13:57.170  -->  00:13:59.770
Now other than an inability to add or
remove members,
229

229

00:13:59.770  -->  00:14:03.930
frozen sets behave just like regular
sets and can be used to create unions,
230

230

00:14:03.930  -->  00:14:06.840
intersections, and
can be subtracted from other sets.
231

231

00:14:06.840  -->  00:14:11.580
Now you can't call difference_update or
symmetric_difference_update
232

232

00:14:11.580  -->  00:14:15.060
on a frozen set, of course,
because A frozen set isn't mutable.
233

233

00:14:15.060  -->  00:14:18.800
What you can do is you can pass a
parameter to a different underscore update
234

234

00:14:18.800  -->  00:14:20.420
core on a regular set.
235

235

00:14:20.420  -->  00:14:21.830
Now before we move onto the challenge,
236

236

00:14:21.830  -->  00:14:24.810
we looked at many operators that
do the same job as the methods.
237

237

00:14:24.810  -->  00:14:28.410
And there's a nice table in
the path documentation for
238

238

00:14:28.410  -->  00:14:31.890
2.7 showing the methods and
the equivalent operators
239

239

00:14:31.890  -->  00:14:35.800
Not only use the table that was much of
the text no longer applies to Python 3.
240

240

00:14:35.800  -->  00:14:39.980
So that's important so ignore the text and
just see the refer to the table.
241

241

00:14:39.980  -->  00:14:45.600
So I'm just gonna bring that up on
the screen so you can see There and
242

242

00:14:45.600  -->  00:14:48.610
we're gonna put this link
in the resources section.
243

243

00:14:48.610  -->  00:14:51.890
So refer to that as well, but you can see
that's giving you a good overview of what
244

244

00:14:51.890  -->  00:14:55.380
the various operations are for sense.
245

245

00:14:55.380  -->  00:14:58.270
And just out of interest, the same
information is available in the Tree
246

246

00:14:58.270  -->  00:15:01.880
documentation but it's not laid out in
a helpful table than it is there and
247

247

00:15:01.880  -->  00:15:05.040
I think it is really quite helpful being
able to see that all getting there.
248

248

00:15:05.040  -->  00:15:07.940
So probably I could link for
you to bookmark.
249

249

00:15:07.940  -->  00:15:09.300
All right, it's time for a challenge.
250

250

00:15:09.300  -->  00:15:13.800
Let's go back to our code and
we're gonna create a new file.
251

251

00:15:13.800  -->  00:15:20.510
[NOISE]
>> We're gonna copy and paste challenging.
252

252

00:15:21.950  -->  00:15:22.840
So, here's the challenge.
253

253

00:15:22.840  -->  00:15:24.910
Create a program that takes some text and
254

254

00:15:24.910  -->  00:15:29.150
returns a list of all the characters
in the text that are not vowels.
255

255

00:15:29.150  -->  00:15:30.560
Sorted in alphabetical order.
256

256

00:15:30.560  -->  00:15:33.710
And you can either answer
the text from the keyboard or
257

257

00:15:33.710  -->  00:15:36.140
initialize a string
variable with a the string.
258

258

00:15:36.140  -->  00:15:37.570
Now obviously we wanted to use sets.
259

259

00:15:37.570  -->  00:15:40.250
So this is where the whole idea
of this is we're using sets.
260

260

00:15:40.250  -->  00:15:42.880
So you should be using
a set with this challenge.
261

261

00:15:42.880  -->  00:15:45.600
Okay so, go away and
see if you can figure out that challenge.
262

262

00:15:45.600  -->  00:15:48.320
And when you're ready to see the solution,
come back and we're make a start on it.
263

263

00:15:52.270  -->  00:15:53.730
Let's have a look at that.
264

264

00:15:53.730  -->  00:15:55.920
Let's type some text in.
265

265

00:15:55.920  -->  00:16:01.310
Sampletext equals "python is
a very powerful language".
266

266

00:16:01.310  -->  00:16:05.900
So, how would we do that?
267

267

00:16:05.900  -->  00:16:13.170
We would type "vowels equals Frozenset,
aeiou.
268

268

00:16:13.170  -->  00:16:19.260
Alternatively, you could have
done something like this
269

269

00:16:19.260  -->  00:16:25.720
vowels = ("a",
270

270

00:16:25.720  -->  00:16:29.710
"e", "i", "o", "u").
271

271

00:16:31.220  -->  00:16:34.760
But thank you, that takes more topics so
the one that for
272

272

00:16:34.760  -->  00:16:36.610
instance we dont that it was way quicker.
273

273

00:16:37.740  -->  00:16:41.180
So, then we do funnel set, equals set.
274

274

00:16:41.180  -->  00:16:46.070
Sample text, dot difference
275

275

00:16:48.420  -->  00:16:51.910
Print final set [NOISE]
>> And
276

276

00:16:51.910  -->  00:16:57.870
then we can finally do something
like final lists equals sorted.
277

277

00:16:57.870  -->  00:17:02.760
FInal set and print.
278

278

00:17:02.760  -->  00:17:04.340
[NOISE] On a list.
279

279

00:17:06.140  -->  00:17:06.710
So if you run that.
280

280

00:17:08.220  -->  00:17:10.050
And I think I need to
[INAUDIBLE] some [INAUDIBLE].
281

281

00:17:10.050  -->  00:17:11.190
So I need to go back to my other file.
282

282

00:17:11.190  -->  00:17:13.190
I'm actually running
the wrong program file.
283

283

00:17:13.190  -->  00:17:15.390
Unless you just run this
one here as well first.
284

284

00:17:17.500  -->  00:17:18.920
Run challenge.
285

285

00:17:18.920  -->  00:17:20.080
Just to confirm that it works.
286

286

00:17:20.080  -->  00:17:23.640
So you can see that the first line
shows the answer to the sorted version
287

287

00:17:23.640  -->  00:17:24.670
of the sort.
288

288

00:17:24.670  -->  00:17:25.790
And the second line as you can see.
289

289

00:17:25.790  -->  00:17:27.350
That's in alphabetical order.
290

290

00:17:27.350  -->  00:17:29.260
Noting the upper case and lower case and
291

291

00:17:29.260  -->  00:17:32.490
spaces have got a different ordering
than the lower case equivalence.
292

292

00:17:32.490  -->  00:17:36.360
So because sets don't contain duplicates,
we get the list that we wanted with each
293

293

00:17:36.360  -->  00:17:38.970
character only occurring once on
the list as you can see there.
294

294

00:17:38.970  -->  00:17:40.770
And we've used a frozen set for
295

295

00:17:40.770  -->  00:17:43.430
the vals because the members
shouldn't change in English.
296

296

00:17:43.430  -->  00:17:46.880
If you wanted to test say for the worst
language and we add w and y to the set.
297

297

00:17:46.880  -->  00:17:49.440
Then the frozen wouldn't be
appropriate in this scenario.
298

298

00:17:49.440  -->  00:17:53.140
Just to go back to that other area,
that was coming up because
299

299

00:17:53.140  -->  00:17:56.000
I hadn't come into that line out which was
invalid because we're using a frozen set.
300

300

00:17:57.110  -->  00:17:58.830
So that's actually the challenge.
301

301

00:17:58.830  -->  00:18:00.660
That's any few lines of code and
302

302

00:18:00.660  -->  00:18:04.930
again I just want to reinforce how
powerful Python is to be able to do things
303

303

00:18:04.930  -->  00:18:07.510
that are relatively complex
in such a few lines of code.
304

304

00:18:07.510  -->  00:18:10.180
It's really a fantastic language for that.
305

305

00:18:10.180  -->  00:18:14.130
Ok, so that's the end of this video and
the end of this section, actually.
306

306

00:18:14.130  -->  00:18:17.400
So I've worked on quite a few
things in this section trying
307

307

00:18:17.400  -->  00:18:19.790
to get dictionaries and
sets out of the way.
308

308

00:18:19.790  -->  00:18:20.720
And we're now done with that.
309

309

00:18:20.720  -->  00:18:24.340
In the next section we're going to start
working on input and output in Python, so
310

310

00:18:24.340  -->  00:18:25.850
see you in the next section.
