WEBVTT
1
1

00:00:05.340  -->  00:00:09.120
So in the previous video we started
looking at the if statement and
2

2

00:00:09.120  -->  00:00:11.760
went through various conditional checks.
3

3

00:00:11.760  -->  00:00:16.100
So we actually looked at the if,
the else, the elif and come up with
4

4

00:00:16.100  -->  00:00:19.910
a simple scenario so you can see on
the screen a simple guess the number game.
5

5

00:00:19.910  -->  00:00:23.980
But what I want to talk about now is
the situation where you want to test more
6

6

00:00:23.980  -->  00:00:27.150
complicated conditions than
the simple ones we've used so far.
7

7

00:00:27.150  -->  00:00:30.080
And Python actually gives you
the mechanism to produce quite
8

8

00:00:30.080  -->  00:00:32.970
complex expressions when you're
actually doing some testing.
9

9

00:00:32.970  -->  00:00:36.820
So what I'm going to do is delete
this code now, and start fresh.
10

10

00:00:36.820  -->  00:00:38.180
And let's come up with a scenario.
11

11

00:00:38.180  -->  00:00:40.650
So we'll type in age equals input.
12

12

00:00:42.410  -->  00:00:43.560
Actually we'll put an int there first.
13

13

00:00:43.560  -->  00:00:46.230
So int input, so
we're converting it to a number.
14

14

00:00:46.230  -->  00:00:47.390
How old are you?
15

15

00:00:49.850  -->  00:00:53.680
So what we can do is put,
if age greater than equal to 16.
16

16

00:00:53.680  -->  00:00:56.280
You've seen something
similar to that before.
17

17

00:00:56.280  -->  00:01:00.120
We had talked about the greater than
equal operator in the previous video.
18

18

00:01:00.120  -->  00:01:05.960
But we can also expand that, we can put
int space age, less than equal to 65.
19

19

00:01:07.270  -->  00:01:11.790
So what that does, that actually checks
to see whether the age is greater than or
20

20

00:01:11.790  -->  00:01:15.730
equal to 16 and
that it's also less than and equal to 65.
21

21

00:01:15.730  -->  00:01:18.490
So if we actually do that and
then we should do a print,
22

22

00:01:18.490  -->  00:01:22.440
have a good day at work.
23

23

00:01:22.440  -->  00:01:26.060
So obviously run that.
24

24

00:01:26.060  -->  00:01:28.810
How old are you?
25

25

00:01:28.810  -->  00:01:29.920
We can actually enter our value.
26

26

00:01:29.920  -->  00:01:31.520
Add 9.
We put 15.
27

27

00:01:31.520  -->  00:01:35.540
Nothing happens, and that's because
this condition wasn't fulfilled.
28

28

00:01:35.540  -->  00:01:38.530
Because age was 15,
which failed this first part here, so
29

29

00:01:38.530  -->  00:01:40.250
consequently nothing happened.
30

30

00:01:40.250  -->  00:01:41.350
So if we run it again.
31

31

00:01:41.350  -->  00:01:42.490
This time I'll put, say 25.
32

32

00:01:42.490  -->  00:01:44.650
Have a good day at work.
33

33

00:01:44.650  -->  00:01:49.480
So, it's looking for a number that's
within the ranges of greater than or
34

34

00:01:49.480  -->  00:01:51.940
equal to 16 and less than equal to 65.
35

35

00:01:51.940  -->  00:01:56.530
Now because the and has a lower priority
than the conditional operators,
36

36

00:01:56.530  -->  00:01:58.480
this expression evaluates
as we would expect.
37

37

00:01:58.480  -->  00:02:02.060
But if you want to be really clear
you can use parentheses to make it
38

38

00:02:02.060  -->  00:02:03.150
obvious what you intended.
39

39

00:02:03.150  -->  00:02:05.230
So what we could have done
is something like this.
40

40

00:02:05.230  -->  00:02:08.590
We could have actually changed this,
used brackets.
41

41

00:02:11.980  -->  00:02:14.380
Like so, and we've made it very clear.
42

42

00:02:14.380  -->  00:02:16.090
And we'll still get the same result.
43

43

00:02:16.090  -->  00:02:18.740
But it's now a lot clearer because
I've used those brackets what we
44

44

00:02:18.740  -->  00:02:19.350
were trying to do.
45

45

00:02:19.350  -->  00:02:22.530
It still actually works as you can see.
46

46

00:02:22.530  -->  00:02:26.700
So the parentheses just to be clear
aren't necessary, but generally speaking,
47

47

00:02:26.700  -->  00:02:30.930
it's a good idea to use them, especially
in complex conditional expressions.
48

48

00:02:30.930  -->  00:02:33.670
And the reason that you want to
do that is it really makes it,
49

49

00:02:33.670  -->  00:02:39.040
not only does it make it easy to read, but
if someone has to work on your code later,
50

50

00:02:39.040  -->  00:02:42.260
the use of parentheses makes it obvious
to them what your intentions were.
51

51

00:02:42.260  -->  00:02:46.200
So for that reason, I certainly highly
recommend brackets or parentheses.
52

52

00:02:46.200  -->  00:02:48.250
Now Python also gives
you another scenario.
53

53

00:02:48.250  -->  00:02:50.400
Instead of writing it
the way we've written there.
54

54

00:02:50.400  -->  00:02:51.300
We can comment that out.
55

55

00:02:51.300  -->  00:02:53.630
And we'll comment out just that one line.
56

56

00:02:54.950  -->  00:02:56.200
And we can also do it like this.
57

57

00:02:56.200  -->  00:03:03.620
We can put if 16, less than equal to age,
less than equal to 65.
58

58

00:03:03.620  -->  00:03:05.980
Which is another way of actually
writing the thing, the same thing.
59

59

00:03:05.980  -->  00:03:11.500
So we can actually do, on that and
just confirm if it's working.
60

60

00:03:11.500  -->  00:03:15.270
We didn't get a message because
we're outside of the range, and 34,
61

61

00:03:15.270  -->  00:03:17.150
we have gotten a message.
62

62

00:03:17.150  -->  00:03:21.160
So you can see, there we're actually doing
a test to see whether the value 16 is less
63

63

00:03:21.160  -->  00:03:26.120
than equal to age, and whether the value
65 is less than equal to age as well.
64

64

00:03:26.120  -->  00:03:28.750
Making sure that it's actually within
the range that's been entered.
65

65

00:03:28.750  -->  00:03:31.290
And there's actually even an easier
way that we could write this.
66

66

00:03:31.290  -->  00:03:34.170
Instead of using less than equal,
we can actually change this and
67

67

00:03:34.170  -->  00:03:36.770
put 15 less than age and less than 66.
68

68

00:03:36.770  -->  00:03:42.600
So what we could do there is
we could actually run that.
69

69

00:03:42.600  -->  00:03:43.710
How old are you if we're 15?
70

70

00:03:43.710  -->  00:03:47.600
We don't get a message because
the range was greater than or
71

71

00:03:47.600  -->  00:03:50.060
equal to 16 originally and less than 65.
72

72

00:03:50.060  -->  00:03:51.250
Less than equal to 65.
73

73

00:03:51.250  -->  00:03:55.490
If we put the age of 16,
have a good day at work.
74

74

00:03:55.490  -->  00:04:00.470
So that's still actually working because
age is not less than 15 in this case and
75

75

00:04:00.470  -->  00:04:01.690
we can actually change it again.
76

76

00:04:02.720  -->  00:04:04.830
We can put 61 or 62,
have a good day at work, and
77

77

00:04:04.830  -->  00:04:10.110
lastly 66 actually falls
outside of the range.
78

78

00:04:10.110  -->  00:04:13.550
So that's possibly easy
to understand as well.
79

79

00:04:13.550  -->  00:04:16.410
So the other thing we can do is we can
actually turn the condition around using
80

80

00:04:16.410  -->  00:04:19.200
an or instead, so
I'm just gonna go ahead and do that.
81

81

00:04:19.200  -->  00:04:21.380
Let's actually just comment
out all this code, so
82

82

00:04:21.380  -->  00:04:24.360
I've just got the original age and
put at the top which is the same.
83

83

00:04:24.360  -->  00:04:30.540
When you put something like
if age is less than 16 or
84

84

00:04:30.540  -->  00:04:34.260
age is greater than 65,
85

85

00:04:34.260  -->  00:04:38.950
print, enjoy your free time.
86

86

00:04:41.690  -->  00:04:46.220
Else, print, have a good day at work.
87

87

00:04:46.220  -->  00:04:50.720
So you can see what we've done there,
we've actually use an or to check whether
88

88

00:04:50.720  -->  00:04:56.400
the age is less than 16 or it's greater
than 65 so if either of those expressions
89

89

00:04:56.400  -->  00:05:00.450
turns out being true, this message is
gonna be printed, enjoy your free time.
90

90

00:05:00.450  -->  00:05:03.150
Otherwise the else is gonna be invoked and
we should see the message,
91

91

00:05:03.150  -->  00:05:04.210
have a good day at work.
92

92

00:05:04.210  -->  00:05:05.450
So if you actually run that.
93

93

00:05:05.450  -->  00:05:07.780
I'll just stop this and start this again.
94

94

00:05:07.780  -->  00:05:10.950
How old are you?
So if I put 15, enjoy your free time.
95

95

00:05:10.950  -->  00:05:11.680
Run it again.
96

96

00:05:11.680  -->  00:05:14.590
And if I put 66, enjoy your free time.
97

97

00:05:14.590  -->  00:05:18.800
And if I put a value in between 45,
have a good day at work.
98

98

00:05:18.800  -->  00:05:20.740
So that's using an or.
99

99

00:05:20.740  -->  00:05:24.120
And again the difference there was
with an end, with this line up here.
100

100

00:05:24.120  -->  00:05:25.590
Both conditions have to be true,
101

101

00:05:25.590  -->  00:05:30.120
so both what was in the parentheses
had to actually equate to true, for
102

102

00:05:30.120  -->  00:05:34.070
that condition to be satisfied, but
in the case of or, it's either, has to be.
103

103

00:05:34.070  -->  00:05:37.720
So we're checking here to see
if the age is less than 16 or
104

104

00:05:37.720  -->  00:05:39.430
if it's greater than 65.
105

105

00:05:39.430  -->  00:05:42.010
If either of those expressions
turns out to be true
106

106

00:05:42.010  -->  00:05:43.890
then the message on
the next line is printed.
107

107

00:05:43.890  -->  00:05:47.340
There's one important difference
though to actually using and and or.
108

108

00:05:47.340  -->  00:05:48.660
When comparing conditions using and
109

109

00:05:48.660  -->  00:05:52.730
Python is gonna stop checking as soon
as it finds a condition that's false.
110

110

00:05:52.730  -->  00:05:54.860
Whereas comparing conditions using or,
111

111

00:05:54.860  -->  00:05:58.130
it's going to stop as soon
as it finds one that's true.
112

112

00:05:58.130  -->  00:06:02.580
So again in this case here, with the and,
if age wasn't greater than or
113

113

00:06:02.580  -->  00:06:04.050
equal to 16 it wouldn't do anything else.
114

114

00:06:04.050  -->  00:06:05.880
At that point that was
going to be a false.
115

115

00:06:05.880  -->  00:06:10.300
If i just say 15 in our test it would stop
and it wouldn't actually start doing this
116

116

00:06:10.300  -->  00:06:14.210
sort of doing this expression because the
other ones has already been proved to be
117

117

00:06:14.210  -->  00:06:17.870
false but with an or
we're looking to one of these to be true.
118

118

00:06:17.870  -->  00:06:22.330
So, if age is less than 16,
so again 15 was entered and
119

119

00:06:22.330  -->  00:06:26.080
this expression is going to be
true because 15 is less than 16.
120

120

00:06:26.080  -->  00:06:30.550
Only if that is false, so if say 25
was typed in, only then will the or
121

121

00:06:30.550  -->  00:06:34.070
be actually checked to see whether
the age was also greater than 65.
122

122

00:06:34.070  -->  00:06:36.760
So that's the important
difference between both.
123

123

00:06:36.760  -->  00:06:41.240
And just as an example, if we type if,
124

124

00:06:41.240  -->  00:06:48.800
we'll go back here actually,
start at the right indent level,
125

125

00:06:48.800  -->  00:06:54.400
if some condition, or,
some weird function,
126

126

00:06:54.400  -->  00:06:58.610
that does stuff hash do something.
127

127

00:07:00.430  -->  00:07:03.390
So this example here which obviously is
not working because we haven't set these
128

128

00:07:03.390  -->  00:07:06.170
things up,
some condition evaluates to true.
129

129

00:07:06.170  -->  00:07:07.920
If that happens there's no need for
130

130

00:07:07.920  -->  00:07:11.810
Python to execute the weird function
before deciding whether to do something.
131

131

00:07:11.810  -->  00:07:15.080
So basically this can be very important
when we come to looking at classes but for
132

132

00:07:15.080  -->  00:07:18.750
now it's just something to be aware of,
checking to see this first part,
133

133

00:07:18.750  -->  00:07:21.480
whether that's gonna be executed
based on the actual value.
134

134

00:07:21.480  -->  00:07:24.300
Now, Python, itself,
doesn't have a boolean data type.
135

135

00:07:24.300  -->  00:07:26.100
And in other languages, Java for
136

136

00:07:26.100  -->  00:07:30.340
example, there is a boolean data type
which you can set to true or false.
137

137

00:07:30.340  -->  00:07:33.550
But what it does have,
it has two constants, true and false.
138

138

00:07:33.550  -->  00:07:36.020
So as well as conditions
evaluating to true or false,
139

139

00:07:36.020  -->  00:07:39.870
just about anything in Python can
also be tested in a condition.
140

140

00:07:39.870  -->  00:07:41.860
And this can actually lead
to some strange results and
141

141

00:07:41.860  -->  00:07:42.820
I'm gonna show you what I mean here.
142

142

00:07:42.820  -->  00:07:47.540
So I'm gonna delete this code and
I'm gonna put x equals false.
143

143

00:07:47.540  -->  00:07:48.450
X being a string.
144

144

00:07:48.450  -->  00:07:53.720
If x, print.
145

145

00:07:53.720  -->  00:07:55.140
X is true.
146

146

00:07:55.140  -->  00:07:57.390
Now if we actually run that.
147

147

00:07:58.630  -->  00:07:59.740
Comes back with x is true.
148

148

00:07:59.740  -->  00:08:01.340
Now that may not have
been what you expected.
149

149

00:08:01.340  -->  00:08:02.720
Perhaps you've looked at this and
150

150

00:08:02.720  -->  00:08:06.590
you're wondering why we're showing true
when x was set to the value of false.
151

151

00:08:06.590  -->  00:08:09.680
Well, in Python true is one and
false is zero.
152

152

00:08:09.680  -->  00:08:14.940
But in a condition, any non-zero or
non-empty values will evaluate to true.
153

153

00:08:14.940  -->  00:08:19.410
So because we've actually got the x
string set to a value, which in this
154

154

00:08:19.410  -->  00:08:23.220
case is the value of false, it's going
to be evaluated as being returned true.
155

155

00:08:23.220  -->  00:08:27.560
So if x is actually going to return to and
that's why when we run it,
156

156

00:08:27.560  -->  00:08:29.030
we actually got the line of output.
157

157

00:08:29.030  -->  00:08:31.950
So, more specifically, anything except
the following is gonna be true.
158

158

00:08:31.950  -->  00:08:33.910
We're going to use the bull function, so
159

159

00:08:33.910  -->  00:08:35.830
we can print out the results
to actually confirm this.
160

160

00:08:35.830  -->  00:08:38.200
And I'm actually going to copy and
paste this code, and paste it in.
161

161

00:08:38.200  -->  00:08:41.040
And I'm going to paste this in and
we're actually going to run it.
162

162

00:08:42.760  -->  00:08:45.290
And you can see here in these scenarios,
when we're going to be finding out more
163

163

00:08:45.290  -->  00:08:48.910
about these types variables, and basically
what I've done is I've just pasted in some
164

164

00:08:48.910  -->  00:08:52.090
code, and I'll just bring it back to
the screen so we can actually read it.
165

165

00:08:52.090  -->  00:08:54.100
And figured out what the values were for
each of them.
166

166

00:08:54.100  -->  00:08:57.020
So the false, we're setting up the false,
if that's the case you can see we've
167

167

00:08:57.020  -->  00:09:00.380
used a replacement field, and
it actually does return false.
168

168

00:09:00.380  -->  00:09:05.610
Bull for none, none is another dial
type in Python that's also set to false.
169

169

00:09:05.610  -->  00:09:08.500
A zero, so we do it using the bull
function to actually check
170

170

00:09:08.500  -->  00:09:10.930
to see whether this returns a true or
false, and
171

171

00:09:10.930  -->  00:09:14.010
you can see the various things here,
whether they return true or false,
172

172

00:09:14.010  -->  00:09:17.270
in this case everything's returning
false because we're checking for empty.
173

173

00:09:17.270  -->  00:09:21.020
And you probably don't know at this
stage what a list is, what a is and
174

174

00:09:21.020  -->  00:09:22.520
we'll be talking about
that more in the future.
175

175

00:09:22.520  -->  00:09:25.900
But for now it's just something to keep
in mind that as we progress through
176

176

00:09:25.900  -->  00:09:29.290
the definitions that you
think might be the case with
177

177

00:09:29.290  -->  00:09:32.610
as in the true example I gave you
may not the case in practice.
178

178

00:09:32.610  -->  00:09:34.710
But I'll alert you to that
as we go through anyway.
179

179

00:09:34.710  -->  00:09:38.210
And there's one exception to this and it's
possible to create a class that evaluates
180

180

00:09:38.210  -->  00:09:41.570
to false, but there's probably enough
confusion without introducing anymore, so
181

181

00:09:41.570  -->  00:09:42.950
I won't go into that in detail.
182

182

00:09:42.950  -->  00:09:46.090
What this does, the reason that I brought
this up, it does allow you to create
183

183

00:09:46.090  -->  00:09:50.210
conditions, such as this, so I'm going
to actually type in some more code.
184

184

00:09:50.210  -->  00:09:55.690
So x equals input, please enter some text.
185

185

00:09:55.690  -->  00:10:02.170
If x, print you entered.
186

186

00:10:05.630  -->  00:10:10.940
.format, and it's gonna be x,
187

187

00:10:10.940  -->  00:10:17.620
else print, you did not enter anything.
188

188

00:10:17.620  -->  00:10:21.400
So if we actually run this,
please enter some text.
189

189

00:10:21.400  -->  00:10:22.250
Or I'll just press enter.
190

190

00:10:22.250  -->  00:10:24.100
You did not enter anything.
191

191

00:10:24.100  -->  00:10:29.620
But if I actually enter some text,
Tim was here, you entered Tim was here.
192

192

00:10:29.620  -->  00:10:34.120
So this can actually result in simpler
code, but probably at this stage,
193

193

00:10:34.120  -->  00:10:36.970
I'd recommend you'd avoid it until
you're more comfortable with Python.
194

194

00:10:36.970  -->  00:10:40.000
Now before we actually finish with
conditions there's two more key words
195

195

00:10:40.000  -->  00:10:40.930
that we need to look at.
196

196

00:10:40.930  -->  00:10:44.820
The first is not which just
reverses a true or false value.
197

197

00:10:44.820  -->  00:10:47.680
Not true equals false and
not false equals true.
198

198

00:10:47.680  -->  00:10:53.360
So for example, we can put print
199

199

00:10:53.360  -->  00:10:58.430
not false, print not true.
200

200

00:10:58.430  -->  00:10:59.270
So we actually run that.
201

201

00:11:00.350  -->  00:11:03.270
You get true for the first one and
false for the second one.
202

202

00:11:03.270  -->  00:11:06.060
So basically it just reverses
whatever the count scenario was.
203

203

00:11:06.060  -->  00:11:09.730
So in this case false would normally
return zero, where false is a zero,
204

204

00:11:09.730  -->  00:11:12.300
as you recall from
earlier in this lecture.
205

205

00:11:12.300  -->  00:11:14.330
Not false is gonna return true.
206

206

00:11:14.330  -->  00:11:16.920
Likewise, for true, not or
the inverse of that is going to be false.
207

207

00:11:16.920  -->  00:11:21.880
So based on that, what we could have done,
if we go back to our earlier voting check.
208

208

00:11:21.880  -->  00:11:28.100
We could do something like age
equals int input, how old are you?
209

209

00:11:30.990  -->  00:11:37.850
So you can put something like
if not age less than 18.
210

210

00:11:37.850  -->  00:11:39.100
Print.
211

211

00:11:40.470  -->  00:11:41.600
Not old enough to vote.
212

212

00:11:44.220  -->  00:11:44.720
Print.
213

213

00:11:46.350  -->  00:11:49.880
Please put an X in the box.
214

214

00:11:51.070  -->  00:11:57.830
Else, print, please come back, in
215

215

00:11:59.360  -->  00:12:05.280
years, and
of course it was .format, 18-age.
216

216

00:12:05.280  -->  00:12:08.590
So if you run that now, how old are you?
217

217

00:12:08.590  -->  00:12:11.430
If I put in 15,
please come back in three years.
218

218

00:12:11.430  -->  00:12:13.820
That's because it's
performing this check now.
219

219

00:12:13.820  -->  00:12:16.220
If not age less than 18, so
220

220

00:12:16.220  -->  00:12:21.230
age less than 18 would be true in this
case because age was less than 18.
221

221

00:12:21.230  -->  00:12:24.520
But not is the inverse of that,
so the inverse of that would be,
222

222

00:12:24.520  -->  00:12:29.170
we're looking for an age in this
case that is actually 18 or higher.
223

223

00:12:29.170  -->  00:12:32.110
If not age less than 18,
in this case being 15,
224

224

00:12:32.110  -->  00:12:35.720
and that evaluates effectively as false,
and it comes back and
225

225

00:12:35.720  -->  00:12:38.870
actually shows how old you are, and
please come back in three years.
226

226

00:12:38.870  -->  00:12:42.100
Run that again, we put 21,
you're old enough to vote,
227

227

00:12:42.100  -->  00:12:46.390
and that's because age
less than 18 is false and
228

228

00:12:46.390  -->  00:12:50.150
then not, which is the inverse of that,
converts the false to the true and that's
229

229

00:12:50.150  -->  00:12:53.590
why we can actually see that message
showing on the screen for that reason.
230

230

00:12:53.590  -->  00:12:56.830
So sometimes, and this is not one of them,
it makes sense to check for
231

231

00:12:56.830  -->  00:12:58.570
a condition not being true.
232

232

00:12:58.570  -->  00:13:00.330
And then not a keyword
allows you to do that.
233

233

00:13:00.330  -->  00:13:04.380
And you'll see more examples of not and so
forth as we go through in the actual OS.
234

234

00:13:04.380  -->  00:13:05.630
We go through the course.
235

235

00:13:05.630  -->  00:13:08.300
Now in is another keyword and
it's used in sequences,
236

236

00:13:08.300  -->  00:13:11.360
and we make more use of it when we come
back to look at lists in a later section,
237

237

00:13:11.360  -->  00:13:15.240
but one list that we have used though is a
string, which is a sequence of characters,
238

238

00:13:15.240  -->  00:13:17.540
so let's have a look at the in keyword for
that.
239

239

00:13:17.540  -->  00:13:19.350
So we're gonna start with parent, so
240

240

00:13:19.350  -->  00:13:20.800
what I'll do is I'm just
gonna paste this code in.
241

241

00:13:20.800  -->  00:13:23.340
I'm gonna do that and
I'm gonna paste it in.
242

242

00:13:23.340  -->  00:13:25.100
But, for
some reason hasn't pasted it properly.
243

243

00:13:25.100  -->  00:13:28.250
This is a good example of how
sometimes things don't get pasted
244

244

00:13:28.250  -->  00:13:29.190
in correctly to spaces.
245

245

00:13:29.190  -->  00:13:31.360
So, you've got to just
check your spaces and
246

246

00:13:31.360  -->  00:13:33.950
your tabs to make sure things
have been correctly put in.
247

247

00:13:33.950  -->  00:13:37.490
And you can see that basically intelliJ
is quite happy to tell us that things
248

248

00:13:37.490  -->  00:13:38.470
aren't correct.
249

249

00:13:38.470  -->  00:13:40.910
So, you can just go back and delete.
250

250

00:13:40.910  -->  00:13:43.820
So start like that and
then press tab which fixes it.
251

251

00:13:43.820  -->  00:13:46.330
We could just remove
the offending characters.
252

252

00:13:46.330  -->  00:13:49.390
So again, you find that it's quite
common when you're actually copying and
253

253

00:13:49.390  -->  00:13:52.740
pasting code from other place,
and I did allude to that earlier.
254

254

00:13:52.740  -->  00:13:54.390
It's how I actually go about fixing it.
255

255

00:13:54.390  -->  00:13:58.140
So in this case, we've set up a string
called parent, we're actually looking for
256

256

00:13:58.140  -->  00:14:01.080
a letter, and
if that letter is actually in parent,
257

257

00:14:01.080  -->  00:14:03.950
in other words if it's contained
within the parent stream,
258

258

00:14:03.950  -->  00:14:07.830
that's what the in keyword does,
we can actually print out that message.
259

259

00:14:07.830  -->  00:14:09.430
Otherwise, I'm gonna say
I don't need that letter.
260

260

00:14:09.430  -->  00:14:12.780
So if I actually run
this into a character.
261

261

00:14:12.780  -->  00:14:15.410
So if we put, o, for example.
262

262

00:14:15.410  -->  00:14:16.110
Give me an o, Bob.
263

263

00:14:16.110  -->  00:14:19.500
And that's because if letter,
the letter we typed in was o,
264

264

00:14:19.500  -->  00:14:22.410
if that's in the parent, which it does,
that's actually in there.
265

265

00:14:22.410  -->  00:14:23.110
So that's good.
266

266

00:14:23.110  -->  00:14:24.110
So that worked.
267

267

00:14:24.110  -->  00:14:24.890
And we'll just try another one.
268

268

00:14:24.890  -->  00:14:25.630
We'll try a b.
269

269

00:14:27.580  -->  00:14:30.430
Now you might be thinking well hang on
there's a B there, why didn't that work?
270

270

00:14:30.430  -->  00:14:32.670
Well, that's because that's a capital B.
271

271

00:14:32.670  -->  00:14:34.340
Capital B for blue there.
272

272

00:14:34.340  -->  00:14:39.010
And doing a comparison as far
as the N key word is concerned
273

273

00:14:39.010  -->  00:14:40.180
that letter is different.
274

274

00:14:40.180  -->  00:14:43.250
So an uppercase B is
different to a lowercase b.
275

275

00:14:43.250  -->  00:14:45.910
If I type the uppercase B,
give me a B Bob.
276

276

00:14:45.910  -->  00:14:47.350
It actually does work.
277

277

00:14:47.350  -->  00:14:49.390
And also if we enter a letter
that's not in there like a z,
278

278

00:14:50.540  -->  00:14:53.440
I don't need that letter, so
it actually comes up quite correctly and
279

279

00:14:53.440  -->  00:14:54.770
doesn't actually match anything.
280

280

00:14:54.770  -->  00:14:57.830
Now you can also use a not
in that example so we put,
281

281

00:14:57.830  -->  00:15:03.160
at the moment we put if letter in parent
we can actually change that to put if not
282

282

00:15:03.160  -->  00:15:06.450
in parent then we would have to
change the prints around, so go look.
283

283

00:15:06.450  -->  00:15:10.830
So ready to put the other
print here in that scenario
284

284

00:15:10.830  -->  00:15:13.700
because we're actually doing a not test so
we're going to get the reverse results.
285

285

00:15:13.700  -->  00:15:19.020
So if we actually run this again put z, I
don't need that letter, which is correct.
286

286

00:15:19.020  -->  00:15:24.080
Or if you put a B in,
we actually get a correct response.
287

287

00:15:24.080  -->  00:15:26.020
So that's it.
So I'm going to end this video here.
288

288

00:15:26.020  -->  00:15:28.930
In the next video it's time for
your first challenge.
289

289

00:15:28.930  -->  00:15:33.980
So what I'm going to do is give you a
challenge to come up with an answer to and
290

290

00:15:33.980  -->  00:15:35.740
it's gonna help you understand, or
291

291

00:15:35.740  -->  00:15:38.790
by actually completing that challenge
it's gonna help you understand
292

292

00:15:38.790  -->  00:15:41.250
what you've learned in this video and
the previous video.
293

293

00:15:41.250  -->  00:15:42.710
So I'll see you in that next video.
