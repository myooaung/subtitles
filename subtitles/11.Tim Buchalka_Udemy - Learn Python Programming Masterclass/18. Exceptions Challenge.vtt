WEBVTT
1
1

00:00:05.320  -->  00:00:08.410
ok so let's start with a challenge so
2

2

00:00:08.410  -->  00:00:10.650
the challenges is for you to create a
3

3

00:00:10.650  -->  00:00:12.690
new python file and write a short
4

4

00:00:12.690  -->  00:00:15.030
program that asks the user to type 2
5

5

00:00:15.030  -->  00:00:17.350
integer numbers then prints out the
6

6

00:00:17.350  -->  00:00:20.680
first number / the second now the
7

7

00:00:20.680  -->  00:00:23.170
program shouldn't crash no matter what
8

8

00:00:23.170  -->  00:00:25.200
the user types in although you shouldn't
9

9

00:00:25.200  -->  00:00:27.250
have to worry about control keys and
10

10

00:00:27.250  -->  00:00:29.410
just as a hint here if you have to do
11

11

00:00:29.410  -->  00:00:31.110
the same thing more than once that
12

12

00:00:31.110  -->  00:00:34.150
sounds like a good use for a function so
13

13

00:00:34.150  -->  00:00:35.650
that's you challenge see how you go
14

14

00:00:35.650  -->  00:00:37.600
pause the video and I'll see you when
15

15

00:00:37.600  -->  00:00:41.410
you get back ok so let's go through my
16

16

00:00:41.410  -->  00:00:44.020
solution to this challenge and as
17

17

00:00:44.020  -->  00:00:45.690
always yours might be different
18

18

00:00:45.690  -->  00:00:47.550
the important thing here is that you've
19

19

00:00:47.550  -->  00:00:49.140
got a solution that works
20

20

00:00:49.140  -->  00:00:51.010
not that you've got identical code to me
21

21

00:00:51.010  -->  00:00:54.010
so create a new file for this
22

22

00:00:54.010  -->  00:00:56.260
i'm going to right click over here click
23

23

00:00:56.260  -->  00:00:59.320
on new select python file will call this
24

24

00:00:59.320  -->  00:01:04.480
one...okay we're
25

25

00:01:04.480  -->  00:01:05.710
gonna be asking for a number more than
26

26

00:01:05.710  -->  00:01:08.370
once so i put the code to get the number
27

27

00:01:08.370  -->  00:01:10.930
from the user into a function so...
28

28

00:01:10.930  -->  00:01:15.520
...
29

29

00:01:15.520  -->  00:01:49.660
...
30

30

00:01:49.660  -->  00:01:54.580
so the function will keep asking for a
31

31

00:01:54.580  -->  00:01:57.060
number until something valid is entered
32

32

00:01:57.060  -->  00:01:59.470
to put everything into an infinite loop
33

33

00:01:59.470  -->  00:02:03.910
using while true on line 2 so that loop
34

34

00:02:03.910  -->  00:02:05.980
just keeps looping so we'll have to use
35

35

00:02:05.980  -->  00:02:08.290
break or return statement to get out of
36

36

00:02:08.290  -->  00:02:10.390
it obviously using the return statement
37

37

00:02:10.390  -->  00:02:13.590
on line five next comes the try except
38

38

00:02:13.590  -->  00:02:16.210
blocks so we've seen how to get numbers
39

39

00:02:16.210  -->  00:02:18.910
from the keyboard a few times we now
40

40

00:02:18.910  -->  00:02:20.950
use the input function then convert the
41

41

00:02:20.950  -->  00:02:24.130
users text into an int now that's
42

42

00:02:24.130  -->  00:02:25.900
the first place where an exception can
43

43

00:02:25.900  -->  00:02:28.150
be thrown when python attempts to
44

44

00:02:28.150  -->  00:02:30.850
convert the user's input into an int value
45

45

00:02:30.850  -->  00:02:33.100
now obviously the conversion
46

46

00:02:33.100  -->  00:02:35.650
to an int will only work if the users
47

47

00:02:35.650  -->  00:02:37.960
has actually entered numbers and
48

48

00:02:37.960  -->  00:02:38.980
nothing else
49

49

00:02:38.980  -->  00:02:41.040
so we need to wrap the conversion in a
50

50

00:02:41.040  -->  00:02:43.150
try block so we can trap that invalid
51

51

00:02:43.150  -->  00:02:45.670
input so how did I know what exception
52

52

00:02:45.670  -->  00:02:47.920
that we should be handling well one
53

53

00:02:47.920  -->  00:02:49.210
approach to this would be to read
54

54

00:02:49.210  -->  00:02:51.100
through the list of exceptions in the
55

55

00:02:51.100  -->  00:02:52.780
documentation link that i showed you in
56

56

00:02:52.780  -->  00:02:54.820
the previous video that's certainly one
57

57

00:02:54.820  -->  00:02:55.960
way to find out
58

58

00:02:55.960  -->  00:02:57.970
now I'm a great believer in using
59

59

00:02:57.970  -->  00:03:00.040
documentation and I've been providing
60

60

00:03:00.040  -->  00:03:01.930
links to the documentation throughout
61

61

00:03:01.930  -->  00:03:04.380
this course you really can't just write
62

62

00:03:04.380  -->  00:03:06.460
code without reading documentation has
63

63

00:03:06.460  -->  00:03:09.250
lots of it but with that said I'm also
64

64

00:03:09.250  -->  00:03:11.100
the first to admit that program
65

65

00:03:11.100  -->  00:03:13.270
documentation isn't the most shall we
66

66

00:03:13.270  -->  00:03:15.880
say riveting of reads so there's
67

67

00:03:15.880  -->  00:03:17.260
another way to find out what we need to
68

68

00:03:17.260  -->  00:03:20.160
know i'll jump that as well so i'm going
69

69

00:03:20.160  -->  00:03:21.730
to comment all that out for now and run
70

70

00:03:21.730  -->  00:03:23.040
this little program so let's just
71

71

00:03:23.040  -->  00:03:28.510
comment out the code the code we want to
72

72

00:03:28.510  -->  00:03:32.880
run temporarily.....
73

73

00:03:32.880  -->  00:03:36.320
....
74

74

00:03:36.320  -->  00:03:42.290
alright so let's run this and we're
75

75

00:03:42.290  -->  00:03:44.240
going to enter a number obviously with a valid
76

76

00:03:44.240  -->  00:03:46.570
number we get no problems but we try
77

77

00:03:46.570  -->  00:03:50.540
to run it with some garbage input you
78

78

00:03:50.540  -->  00:03:52.340
see that the exception that we've raised
79

79

00:03:52.340  -->  00:03:54.350
here by putting in something invalid is
80

80

00:03:54.350  -->  00:03:56.570
a value error invalid literal for int with
81

81

00:03:56.570  -->  00:03:58.760
base 10 switching back to the
82

82

00:03:58.760  -->  00:04:02.710
documentation if we look for our value
83

83

00:04:02.710  -->  00:04:05.120
exception
84

84

00:04:05.120  -->  00:04:08.780
sorry value error now obviously search for it
85

85

00:04:08.780  -->  00:04:10.460
but its a fair way down the list so
86

86

00:04:10.460  -->  00:04:12.650
chances are you might have to do a favor
87

87

00:04:12.650  -->  00:04:15.040
of reading to find it so either way you
88

88

00:04:15.040  -->  00:04:16.790
could actually read this or you could
89

89

00:04:16.790  -->  00:04:19.150
have also gone back to the code and did
90

90

00:04:19.150  -->  00:04:20.660
what I did was try and get the program
91

91

00:04:20.660  -->  00:04:23.410
to crash without using try and except to
92

92

00:04:23.410  -->  00:04:25.600
see what errors what exceptions are
93

93

00:04:25.600  -->  00:04:27.020
actually generated in this case the
94

94

00:04:27.020  -->  00:04:29.660
value error either way we'll find out
95

95

00:04:29.660  -->  00:04:31.310
what we need but when dealing with
96

96

00:04:31.310  -->  00:04:32.150
exceptions
97

97

00:04:32.150  -->  00:04:34.550
I find personally it's often easier to
98

98

00:04:34.550  -->  00:04:36.310
just cause the problem and see what
99

99

00:04:36.310  -->  00:04:38.560
exceptions raised and then to add the try
100

100

00:04:38.560  -->  00:04:40.550
except Clause after that
101

101

00:04:40.550  -->  00:04:43.000
alright let's delete that line that i
102

102

00:04:43.000  -->  00:04:45.410
added temporarily and go ahead and
103

103

00:04:45.410  -->  00:04:50.540
uncomment our function and just
104

104

00:04:50.540  -->  00:04:52.040
carry on explaining more about what it
105

105

00:04:52.040  -->  00:04:52.700
does
106

106

00:04:52.700  -->  00:04:55.120
so if a valid number is entered on line
107

107

00:04:55.120  -->  00:04:57.800
4 the code is going to continue and
108

108

00:04:57.800  -->  00:05:00.200
the number will just be returned but if
109

109

00:05:00.200  -->  00:05:02.620
invalid input has entered a value error
110

110

00:05:02.620  -->  00:05:04.280
exception will be raised as we've just
111

111

00:05:04.280  -->  00:05:07.000
seen so we handle that error in our except
112

112

00:05:07.000  -->  00:05:09.310
Clause now we don't do a great deal is
113

113

00:05:09.310  -->  00:05:10.790
not really much we can do apart from
114

114

00:05:10.790  -->  00:05:12.500
asking the user to type another number
115

115

00:05:12.500  -->  00:05:14.470
then we could perhaps make the message a
116

116

00:05:14.470  -->  00:05:16.580
bit more helpful or mention that only
117

117

00:05:16.580  -->  00:05:17.930
digits are allowed
118

118

00:05:17.930  -->  00:05:19.810
so you've got an extra point their gold
119

119

00:05:19.810  -->  00:05:21.350
star if you manage to do that in your
120

120

00:05:21.350  -->  00:05:23.720
message now once that message in the
121

121

00:05:23.720  -->  00:05:25.430
exception blocks printed the code
122

122

00:05:25.430  -->  00:05:27.430
continues so we'll go around the loop
123

123

00:05:27.430  -->  00:05:29.680
the while loop again and that will keep
124

124

00:05:29.680  -->  00:05:32.560
happening until a valid number is entered
125

125

00:05:32.560  -->  00:05:34.280
so we can be really confident this that
126

126

00:05:34.280  -->  00:05:36.970
this function will always return a valid
127

127

00:05:36.970  -->  00:05:37.930
int value
128

128

00:05:37.930  -->  00:05:39.590
alright so how do we make use of this
129

129

00:05:39.590  -->  00:05:42.860
function well let's add get the two
130

130

00:05:42.860  -->  00:05:45.200
numbers from the users i'm going to put
131

131

00:05:45.200  -->  00:05:48.800
..
132

132

00:05:48.800  -->  00:05:49.490
...
133

133

00:05:49.490  -->  00:05:51.680
...
134

134

00:05:51.680  -->  00:05:56.590
...let's finish this
135

135

00:05:56.590  -->  00:05:59.500
off by performing the division now
136

136

00:05:59.500  -->  00:06:00.950
we've seen in the previous video that
137

137

00:06:00.950  -->  00:06:03.530
division by zero can raise a 0 division
138

138

00:06:03.530  -->  00:06:05.560
error exception i'm going to put the
139

139

00:06:05.560  -->  00:06:07.520
code to perform the division in a try
140

140

00:06:07.520  -->  00:06:10.310
block and catch the exception i'm gonna
141

141

00:06:10.310  -->  00:06:13.400
come down here and then try...
142

142

00:06:13.400  -->  00:06:14.990
...
143

143

00:06:14.990  -->  00:06:49.520
...
144

144

00:06:49.520  -->  00:06:57.050
ok now using the same prompt twice isn't
145

145

00:06:57.050  -->  00:06:59.680
really very user-friendly a user might
146

146

00:06:59.680  -->  00:07:01.030
wonder what they've done wrong to get
147

147

00:07:01.030  -->  00:07:03.170
exactly the same prompt again so let's
148

148

00:07:03.170  -->  00:07:05.210
say actually easily fixed by passing the
149

149

00:07:05.210  -->  00:07:07.610
text we want to prompt the user want to
150

150

00:07:07.610  -->  00:07:09.740
prompt the user with as an argument to our
151

151

00:07:09.740  -->  00:07:12.250
get int function so let's change this a
152

152

00:07:12.250  -->  00:07:13.930
little bit i'm going to come up here and
153

153

00:07:13.930  -->  00:07:18.020
make this prompt and then what we're going to
154

154

00:07:18.020  -->  00:07:20.090
do number equals...instead of
155

155

00:07:20.090  -->  00:07:23.870
putting a hard-coded string there
156

156

00:07:23.870  -->  00:07:27.530
we're going to put prompt the prompt is
157

157

00:07:27.530  -->  00:07:28.550
going to be the message that we want
158

158

00:07:28.550  -->  00:07:30.410
displayed when we're getting a number
159

159

00:07:30.410  -->  00:07:33.410
input and in terms of using the get int
160

160

00:07:33.410  -->  00:07:35.300
method now are the function now
161

161

00:07:35.300  -->  00:07:41.680
we're going to put...
162

162

00:07:41.680  -->  00:07:46.360
...
163

163

00:07:46.360  -->  00:07:54.940
...
164

164

00:07:54.940  -->  00:07:58.390
so let's try running this so
165

165

00:07:58.390  -->  00:07:59.950
please enter the first number we put some
166

166

00:07:59.950  -->  00:08:01.530
rubbish numbers in there
167

167

00:08:01.530  -->  00:08:03.780
invalid number entered please try again
168

168

00:08:03.780  -->  00:08:06.340
and you can see I'm typing it again it's
169

169

00:08:06.340  -->  00:08:07.750
going to continue asking for that first
170

170

00:08:07.750  -->  00:08:09.850
number until we put something valid in
171

171

00:08:09.850  -->  00:08:12.670
there so let's put a valid number like 455
172

172

00:08:12.670  -->  00:08:15.400
in there now it's asking for the second
173

173

00:08:15.400  -->  00:08:17.290
number same deal there with invalid input
174

174

00:08:17.290  -->  00:08:19.120
is going to keep asking until I put
175

175

00:08:19.120  -->  00:08:20.140
something valid in there
176

176

00:08:20.140  -->  00:08:23.080
let's put 0 in as the value for the
177

177

00:08:23.080  -->  00:08:26.560
second number and we get the error can't
178

178

00:08:26.560  -->  00:08:29.110
divide by 0 so this point I think we've
179

179

00:08:29.110  -->  00:08:31.420
got a fairly robust program that the
180

180

00:08:31.420  -->  00:08:33.870
user can't crash by entering invalid
181

181

00:08:33.870  -->  00:08:36.610
input so if your program behaves in the
182

182

00:08:36.610  -->  00:08:38.430
same way congratulations
183

183

00:08:38.430  -->  00:08:39.930
now there are a number of ways that this
184

184

00:08:39.930  -->  00:08:41.980
could be written and you can even do
185

185

00:08:41.980  -->  00:08:43.740
away with the second try except block
186

186

00:08:43.740  -->  00:08:46.210
and use an if statement to check his
187

187

00:08:46.210  -->  00:08:48.540
second number 0 instead that's also
188

188

00:08:48.540  -->  00:08:50.980
fine and in this program is very little
189

189

00:08:50.980  -->  00:08:52.920
to choose between the two
190

190

00:08:52.920  -->  00:08:55.450
methods now there's still one way the
191

191

00:08:55.450  -->  00:08:57.820
user can crash the program and that's to
192

192

00:08:57.820  -->  00:09:00.160
do a control D which may be
193

193

00:09:00.160  -->  00:09:02.020
control z on earlier versions of
194

194

00:09:02.020  -->  00:09:04.840
Windows now on operating systems derived
195

195

00:09:04.840  -->  00:09:07.210
from unix that includes mac OS x and
196

196

00:09:07.210  -->  00:09:10.150
linux ctrl-d triggers an end-of-file
197

197

00:09:10.150  -->  00:09:12.850
eof and Windows 10 behave in the same
198

198

00:09:12.850  -->  00:09:15.400
way i'm going to show you what i mean by
199

199

00:09:15.400  -->  00:09:19.290
that by running it again and down here
200

200

00:09:19.290  -->  00:09:23.790
if I do control d the first number now
201

201

00:09:23.790  -->  00:09:26.470
when I press ctrl-d on a Mac actually
202

202

00:09:26.470  -->  00:09:28.840
get a different output
203

203

00:09:28.840  -->  00:09:30.580
that's because the controlled d is map
204

204

00:09:30.580  -->  00:09:32.040
to another process so what i'm going to do is
205

205

00:09:32.040  -->  00:09:36.850
cancel out of that and run this again so
206

206

00:09:36.850  -->  00:09:39.310
on a linux machine or Windows machine
207

207

00:09:39.310  -->  00:09:41.670
you can try ctrl D from a mac what I have
208

208

00:09:41.670  -->  00:09:43.900
to do a command D simulate something
209

209

00:09:43.900  -->  00:09:46.810
similar so i'm going to do that now when
210

210

00:09:46.810  -->  00:09:48.790
i do that you can see I get this EOF
211

211

00:09:48.790  -->  00:09:50.620
error the end of file when reading a
212

212

00:09:50.620  -->  00:09:52.170
line so that's another exception that's
213

213

00:09:52.170  -->  00:09:53.140
been raised
214

214

00:09:53.140  -->  00:09:55.350
however if you're doing this on a window
215

215

00:09:55.350  -->  00:09:57.480
machine or linux machine you might find
216

216

00:09:57.480  -->  00:09:58.950
that the program starts going a little
217

217

00:09:58.950  -->  00:10:02.440
bit nuts and that you have to start
218

218

00:10:02.440  -->  00:10:05.040
looking at manually stopping it
219

219

00:10:05.040  -->  00:10:07.140
because at this stage the mac has
220

220

00:10:07.140  -->  00:10:09.570
actually gracefully shut down the
221

221

00:10:09.570  -->  00:10:11.340
program but you might find that it's
222

222

00:10:11.340  -->  00:10:12.780
looping continually windows and linux
223

223

00:10:12.780  -->  00:10:14.790
that's the case come over here and click
224

224

00:10:14.790  -->  00:10:17.340
on stop process to stop it then cancel
225

225

00:10:17.340  -->  00:10:19.380
the program if you happen to be running
226

226

00:10:19.380  -->  00:10:20.670
this from the command line like a
227

227

00:10:20.670  -->  00:10:23.100
terminal session or from Windows 10 come
228

228

00:10:23.100  -->  00:10:25.020
from a windows command prompt and
229

229

00:10:25.020  -->  00:10:26.950
control C should probably stop as well
230

230

00:10:26.950  -->  00:10:29.730
the bottom line here is that control
231

231

00:10:29.730  -->  00:10:32.040
d signals to python that there's no
232

232

00:10:32.040  -->  00:10:34.650
input left so consequently pythons
233

233

00:10:34.650  -->  00:10:37.510
close the input stream so our code then
234

234

00:10:37.510  -->  00:10:40.000
catches the exception and in the case of
235

235

00:10:40.000  -->  00:10:42.960
windows at least and linux loops
236

236

00:10:42.960  -->  00:10:45.150
back around but the input streams
237

237

00:10:45.150  -->  00:10:47.610
already been closed so the input
238

238

00:10:47.610  -->  00:10:49.290
function returns immediately with
239

239

00:10:49.290  -->  00:10:51.130
another end of file error our code
240

240

00:10:51.130  -->  00:10:52.750
catches the end of file error and loops back around
241

241

00:10:52.750  -->  00:10:56.070
and so on and so forth so we definitely
catches the end of file error and loops back around
242

242

00:10:56.070  -->  00:10:57.760
don't want to do that even if the mac
243

243

00:10:57.760  -->  00:10:59.950
has only come up with one error
244

244

00:10:59.950  -->  00:11:01.260
it's still not something not a
245

245

00:11:01.260  -->  00:11:03.900
situation we want to get into so if your
246

246

00:11:03.900  -->  00:11:05.760
user terminates input in this way
247

247

00:11:05.760  -->  00:11:08.260
respect their choice and allow the
248

248

00:11:08.260  -->  00:11:10.470
program to terminate there's nothing you
249

249

00:11:10.470  -->  00:11:12.330
can really do about it anyway if you're
250

250

00:11:12.330  -->  00:11:14.100
using python input function to read
251

251

00:11:14.100  -->  00:11:17.200
from the user right so let's actually
252

252

00:11:17.200  -->  00:11:18.700
have a look at what we can do is close
253

253

00:11:18.700  -->  00:11:22.950
down and what we can do in the case of
254

254

00:11:22.950  -->  00:11:24.540
an end of file error lets actually trap
255

255

00:11:24.540  -->  00:11:27.580
that and down here what we will do is up
256

256

00:11:27.580  -->  00:11:29.850
here would be the place to do it after
257

257

00:11:29.850  -->  00:11:32.610
the accepted value error will get
258

258

00:11:32.610  -->  00:11:35.790
another one except this time must be eof
259

259

00:11:35.790  -->  00:11:41.610
error we can do assist.....
260

260

00:11:41.610  -->  00:11:45.070
we've got an error there and the error is
261

261

00:11:45.070  -->  00:11:46.530
that we need to basically it's
262

262

00:11:46.530  -->  00:11:48.270
unresolved reference so we need to
263

263

00:11:48.270  -->  00:11:51.900
import sys so lets go ahead and do that so
264

264

00:11:51.900  -->  00:11:53.500
...
265

265

00:11:53.500  -->  00:12:00.370
...and sys . exit
266

266

00:12:00.370  -->  00:12:02.530
terminates the program with the exit
267

267

00:12:02.530  -->  00:12:04.450
code that's used or past as its
268

268

00:12:04.450  -->  00:12:06.520
argument now for normal program
269

269

00:12:06.520  -->  00:12:09.490
termination is quite usual to return 0
270

270

00:12:09.490  -->  00:12:12.310
and if you decide that the user boarding
271

271

00:12:12.310  -->  00:12:13.570
the program isn't normal termination
272

272

00:12:13.570  -->  00:12:15.520
then you can return a different value
273

273

00:12:15.520  -->  00:12:18.730
i'll do that next let's just try running
274

274

00:12:18.730  -->  00:12:20.410
this first to make sure that works
275

275

00:12:20.410  -->  00:12:22.840
I've been here and going to do on
276

276

00:12:22.840  -->  00:12:25.180
a mac command d you would do a ctrl
277

277

00:12:25.180  -->  00:12:28.540
D on windows or linux and we now just
278

278

00:12:28.540  -->  00:12:30.460
got the program terminating without
279

279

00:12:30.460  -->  00:12:33.970
anything else happening now if you are
280

280

00:12:33.970  -->  00:12:36.130
writing a python script to be used
281

281

00:12:36.130  -->  00:12:38.230
from the terminal possibly called from a shell
282

282

00:12:38.230  -->  00:12:40.720
script or Windows command file that it
283

283

00:12:40.720  -->  00:12:42.790
may be really useful to use different
284

284

00:12:42.790  -->  00:12:45.160
error codes or exit codes so we can
285

285

00:12:45.160  -->  00:12:47.170
return a exit code of one if the user
286

286

00:12:47.170  -->  00:12:49.540
terminate the program and perhaps 2 if they attempt
287

287

00:12:49.540  -->  00:12:52.060
a division by 0
288

288

00:12:52.060  -->  00:12:53.470
let's go ahead and add that code so
289

289

00:12:53.470  -->  00:12:56.110
going to come up here to line 12 going
290

290

00:12:56.110  -->  00:12:57.520
to change that to assists
291

291

00:12:57.520  -->  00:13:00.730
sys.extone let's also put an
292

292

00:13:00.730  -->  00:13:02.980
error in here for the division
293

293

00:13:02.980  -->  00:13:05.680
by zero close the program now...
294

294

00:13:05.680  -->  00:13:09.820
....you can see here process finished
295

295

00:13:09.820  -->  00:13:11.200
with exit code zero so let's try
296

296

00:13:11.200  -->  00:13:15.070
running this again so now if we do my
297

297

00:13:15.070  -->  00:13:17.110
command d on a Mac or control d on windows
298

298

00:13:17.110  -->  00:13:20.410
or linux we get process finished with
299

299

00:13:20.410  -->  00:13:24.310
exit code one running it again this time
300

300

00:13:24.310  -->  00:13:26.680
we'll put some valid numbers in 10 the
301

301

00:13:26.680  -->  00:13:29.890
second number put zero to ensure the 0 division
302

302

00:13:29.890  -->  00:13:33.610
error comes up can't divide by 0 this
303

303

00:13:33.610  -->  00:13:35.380
time we got process finished with exit code 2
304

304

00:13:35.380  -->  00:13:36.340
...
305

305

00:13:36.340  -->  00:13:38.590
that's really good demonstration of
306

306

00:13:38.590  -->  00:13:40.990
reacting in a different way when
307

307

00:13:40.990  -->  00:13:43.210
handling different types of operations
308

308

00:13:43.210  -->  00:13:45.880
alright let's finish the video here and
309

309

00:13:45.880  -->  00:13:47.290
we're still got a couple more things we
310

310

00:13:47.290  -->  00:13:48.910
need to look at with exceptions
311

311

00:13:48.910  -->  00:13:55.620
let's start on that in the next video
