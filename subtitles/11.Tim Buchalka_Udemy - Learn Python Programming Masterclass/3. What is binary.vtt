WEBVTT
0
1
00:00:04.840 --> 00:00:08.340
So let's now have a bit of
a discussion about binary.
1

2
00:00:08.340 --> 00:00:10.810
What it is, and
how you can actually use it.
2

3
00:00:10.810 --> 00:00:14.380
So binary is actually a number
system just like decimal but
3

4
00:00:14.380 --> 00:00:19.560
whereas decimal is based on ten and
uses the digits zero to nine binary
4

5
00:00:19.560 --> 00:00:23.870
is actually based on two and so therefore
can only use the digits zero to one.
5

6
00:00:23.870 --> 00:00:27.580
So I'm just gonna show this
little table on the screen.
6

7
00:00:27.580 --> 00:00:30.440
And in decimal,
we're actually very familiar with
7

8
00:00:30.440 --> 00:00:34.690
the idea that the position of
a digit represents its value.
8

9
00:00:34.690 --> 00:00:36.640
So you may remember doing hundreds.
9

10
00:00:36.640 --> 00:00:40.220
Tens and
units in school to get used to that idea.
10

11
00:00:40.220 --> 00:00:43.590
So if we enter the digits into columns
as you can see on the screen we
11

12
00:00:43.590 --> 00:00:46.430
can see that the column values
are just powers of ten.
12

13
00:00:46.430 --> 00:00:49.430
So with the first column
representing 10 to the power of 0,
13

14
00:00:49.430 --> 00:00:51.140
anything to the power of 0 is 1.
14

15
00:00:51.140 --> 00:00:53.290
In the second column is
10 to the power of 1.
15

16
00:00:53.290 --> 00:00:57.060
And anything to the power
of 1 is itself and so on.
16

17
00:00:57.060 --> 00:00:59.750
So 10 squared, 10 cubed, etc.
17

18
00:00:59.750 --> 00:01:03.340
So, thus the 9 in the second column
as you can see on the screen were 90,
18

19
00:01:03.340 --> 00:01:05.650
and the 9 in the third
column is worth 900.
19

20
00:01:05.650 --> 00:01:09.960
So it's easy to see that the maximum
number we can represent with four digits
20

21
00:01:09.960 --> 00:01:13.760
then is 9999,
as you can see on the screen And
21

22
00:01:13.760 --> 00:01:17.040
if we need to store 10,000,
then we have to go into a fifth column.
22

23
00:01:17.040 --> 00:01:20.160
So binary, as it turns out,
works in exactly the same way.
23

24
00:01:20.160 --> 00:01:23.520
But because it's working in
base two rather than base ten,
24

25
00:01:23.520 --> 00:01:26.530
the column headings are powers of two,
they're not powers of ten.
25

26
00:01:29.780 --> 00:01:33.190
So as you can see in this screen,
in binary each binary digit or
26

27
00:01:33.190 --> 00:01:35.090
bit is worth the power of 2,
27

28
00:01:35.090 --> 00:01:39.540
and it's corresponding to the column that
it's in, just like in the decimal system.
28

29
00:01:39.540 --> 00:01:42.010
So 1 in the first column is still worth 1.
29

30
00:01:42.010 --> 00:01:44.700
In the next column it is worth 2,
and so on.
30

31
00:01:44.700 --> 00:01:46.270
And as you can see from the slide,
31

32
00:01:46.270 --> 00:01:49.700
a byte where all the bits
are 0 holds the value 0.
32

33
00:01:49.700 --> 00:01:53.250
If the first bit is one,
then the value is one.
33

34
00:01:53.250 --> 00:01:56.920
So, as an example to represent decimal 47,
34

35
00:01:56.920 --> 00:02:02.560
we need 32 plus 8 which gives us 40
plus 4 which gives us a total of 44, and
35

36
00:02:02.560 --> 00:02:07.090
We need two, which gives us a total of 46,
and then plus one, to give it 47.
36

37
00:02:07.090 --> 00:02:09.400
So in binary,
the decimal value of 47 is 00101111,
37

38
00:02:09.400 --> 00:02:13.770
as you can see on the screen there.
38

39
00:02:13.770 --> 00:02:16.140
If every one of the first 8 bits is one.
39

40
00:02:16.140 --> 00:02:21.370
Now what we actually have is 128
plus 64 plus so on so forth.
40

41
00:02:21.370 --> 00:02:23.840
So it's easy in this case
to look at the next column
41

42
00:02:23.840 --> 00:02:27.830
because we can actually
have one less than it.
42

43
00:02:27.830 --> 00:02:28.680
Or there is 255.
43

44
00:02:28.680 --> 00:02:32.780
Now when we actually add 1 to 255
the number in the first column becomes 2.
44

45
00:02:32.780 --> 00:02:35.420
So we enter 0 and we actually carry 1.
45

46
00:02:37.470 --> 00:02:41.820
And on the next slide you can see that the
number in the next column then becomes 2.
46

47
00:02:41.820 --> 00:02:45.930
So again we enter 0 and
carry the 1 and so on.
47

48
00:02:45.930 --> 00:02:50.030
Once we reach the eighth bit
what we do is set that to 0.
48

49
00:02:50.030 --> 00:02:52.540
And we have to move into another part.
49

50
00:02:52.540 --> 00:02:57.400
Now unlike a decimal where we don't have
the concept of restricting the number of
50

51
00:02:57.400 --> 00:03:01.070
digits because we're not really trying to
store decimal numbers in a computer or
51

52
00:03:01.070 --> 00:03:06.230
such, binary doesn't have that Or
binary has a problem or has a restriction.
52

53
00:03:06.230 --> 00:03:07.240
Because binary,
53

54
00:03:07.240 --> 00:03:12.630
we actually have the concept of eight bits
making a byte, by a eighth, hence byte.
54

55
00:03:12.630 --> 00:03:16.780
And because we're actually storing binary
numbers in physical computer hardware,
55

56
00:03:16.780 --> 00:03:21.080
a decision had to be made early on for
example As to how many transistors
56

57
00:03:21.080 --> 00:03:24.320
at the hyper level would be
used in each memory location.
57

58
00:03:24.320 --> 00:03:26.570
So the number they
eventually choose was 8.
58

59
00:03:26.570 --> 00:03:29.130
And as a result,
when dealing with binary numbers,
59

60
00:03:29.130 --> 00:03:31.560
we have to consider a digit
moving into the next byte.
60

61
00:03:31.560 --> 00:03:35.950
But it's nothing really more than starting
a new column like we did in decimal
61

62
00:03:35.950 --> 00:03:37.030
when we added 1 to 9999.
62

63
00:03:37.030 --> 00:03:41.980
It also turns out it's actually very easy
to display numbers in binary in Python.
63

64
00:03:41.980 --> 00:03:45.800
So I'm just gonna switch over
to my Intellijay, IDE, and
64

65
00:03:45.800 --> 00:03:48.080
we're just gonna type a bit of code in.
65

66
00:03:48.080 --> 00:03:51.530
As I mentioned it's very easy to
display numbers in binary in Python.
66

67
00:03:51.530 --> 00:03:54.430
Now we covered formatting strings and
using replacement fields,
67

68
00:03:54.430 --> 00:03:58.530
the one thing we haven't mentioned is that
you can add a number base to the format To
68

69
00:03:58.530 --> 00:04:02.580
display a number in binary hexadecimal or
octal which we'll look at shortly.
69

70
00:04:02.580 --> 00:04:06.510
So, the following program I'm about to type
in will display the numbers from 0
70

71
00:04:06.510 --> 00:04:07.240
to 16 in binary.
71

72
00:04:07.240 --> 00:04:12.060
So we can type for i,
in range, 17, and then
72

73
00:04:15.280 --> 00:04:20.380
print Is a replacement field zero column
73

74
00:04:20.380 --> 00:04:25.270
greater than two in
74

75
00:04:28.640 --> 00:04:33.890
is, and then we can top zero on the
replacement field greater than O eight B.
75

76
00:04:33.890 --> 00:04:36.870
In closing off the field, top format I.
76

77
00:04:36.870 --> 00:04:39.960
And, I made an arrow there
at the start of this line.
77

78
00:04:39.960 --> 00:04:42.140
However I can fix that or
close off the replacement field.
78

79
00:04:42.140 --> 00:04:46.320
So what we're doing is we're
showing the decimal equivalent
79

80
00:04:46.320 --> 00:04:50.390
of the field with the 2, and we're right
align, right aligning to the value of i,
80

81
00:04:50.390 --> 00:04:51.660
then we're specifying a of 8.
81

82
00:04:51.660 --> 00:04:57.410
Over here the, the binary right align and
adding beta with the value of i in binary.
82

83
00:04:57.410 --> 00:05:03.450
So if we actually run that You can
see we're getting the right result.
83

84
00:05:03.450 --> 00:05:08.110
Zero in binary is 0000 one in binary is
and so on and so forth, as per the slides.
84

85
00:05:08.110 --> 00:05:11.520
So looking at the pattern of the binary
numbers from 0 to 16 is a good
85

86
00:05:11.520 --> 00:05:14.650
way to understand how binary numbers work.
86

87
00:05:14.650 --> 00:05:17.950
What I'm talking about is we can
see the one moving across here.
87

88
00:05:17.950 --> 00:05:23.020
So we've got the value zero which is
gonna be all zeroes, one has got the bit
88

89
00:05:23.020 --> 00:05:26.640
right most bit set and notice when we
move to two the next bit gets set and
89

90
00:05:26.640 --> 00:05:31.980
then three the two is set, four we've got
the next bit set and so on and so forth.
90

91
00:05:31.980 --> 00:05:34.700
You can also extend the range to
print out high binary numbers so
91

92
00:05:34.700 --> 00:05:38.810
experiment with this and get a feel for
how the binary numbers increase as you add
92

93
00:05:38.810 --> 00:05:41.810
one to it and
that will really help you understand.
93

94
00:05:41.810 --> 00:05:44.360
The conversions that
are actually happening when
94

95
00:05:44.360 --> 00:05:46.660
you're converting from decimal to binary.
95

96
00:05:46.660 --> 00:05:49.160
Now subtraction actually works
the same as it does in decimal, so
96

97
00:05:49.160 --> 00:05:51.000
I'm going to move back to the next slide.
97

98
00:05:53.140 --> 00:05:56.450
So as I mentioned subtraction also works
Works the same as it does in decimal.
98

99
00:05:56.450 --> 00:05:59.960
If there's not a number big
enough in the current column
99

100
00:05:59.960 --> 00:06:01.860
then you can actually borrow
from the next column.
100

101
00:06:01.860 --> 00:06:04.430
Now you'll be glad to know that we're
not going to look at multiplication and
101

102
00:06:04.430 --> 00:06:05.540
division here.
102

103
00:06:05.540 --> 00:06:07.280
If you were to perform multiplication or
103

104
00:06:07.280 --> 00:06:12.380
division long hand the process is
identical to what you would do in decimal,
104

105
00:06:12.380 --> 00:06:15.100
although you'd actually tend to have
many more digits to deal with in
105

106
00:06:15.100 --> 00:06:19.310
binary just because we're dealing
with a base-2 number system.
106

107
00:06:22.290 --> 00:06:25.120
So this next slide shows seven,
which in binary is one,
107

108
00:06:25.120 --> 00:06:26.430
one, one as you can see
on the screen there.
108

109
00:06:26.430 --> 00:06:30.790
And it shows up being multiplied
by three or one, one in binary.
109

110
00:06:30.790 --> 00:06:33.270
And it shows you that long hand if
you want to experiment with it,
110

111
00:06:33.270 --> 00:06:37.100
but you really don't have to perform
arithmetic like this on binary numbers
111

112
00:06:37.100 --> 00:06:38.410
That's what we've got computers for.
112

113
00:06:38.410 --> 00:06:41.070
It's just good to have a sort
of basic understanding of this
113

114
00:06:41.070 --> 00:06:44.200
without necessarily needing to know or
to know it in detail.
114

115
00:06:44.200 --> 00:06:46.930
Now there's a few more operations
that can be performed on
115

116
00:06:46.930 --> 00:06:51.440
binary numbers that are beyond the basic
arithmetic that we're used to and
116

117
00:06:51.440 --> 00:06:53.080
understanding those can
actually be useful.
117

118
00:06:53.080 --> 00:06:58.590
So I'm just gonna move
to the next slide Now
118

119
00:06:58.590 --> 00:07:02.730
this slide shows what happens when
you shift a binary number left.
119

120
00:07:02.730 --> 00:07:06.000
So just like a decimal when
you want to multiply by ten,
120

121
00:07:06.000 --> 00:07:08.350
you insert a zero at the end
of the Of the number.
121

122
00:07:08.350 --> 00:07:12.090
In binary the same thing,
multiplies by two instead of ten.
122

123
00:07:12.090 --> 00:07:17.230
So shifting right divides by two just
like it divides by ten in decimal.
123

124
00:07:17.230 --> 00:07:19.860
And as it turns out, you can have
a binary point in binary as well.
124

125
00:07:19.860 --> 00:07:24.500
So 11 or 1011,
as you can see on the screen there,
125

126
00:07:24.500 --> 00:07:28.060
Shift right would become 101.1
which is 5.5 in decimal.
126

127
00:07:28.060 --> 00:07:34.200
Now the final three operations we want
to look at briefly are going to be or,
127

128
00:07:34.200 --> 00:07:36.930
and, and xall, which is short for
exclusive all.
128

129
00:07:36.930 --> 00:07:38.220
The first thing or.
129

130
00:07:38.220 --> 00:07:42.210
So the binary or operation checks
each bid and its two upper hands.
130

131
00:07:42.210 --> 00:07:45.410
And for each bid it actually sets
the bid in the result to one
131

132
00:07:45.410 --> 00:07:48.290
if either of the upper hands
had a one in that position.
132

133
00:07:48.290 --> 00:07:53.470
And probably the next lab will
help you understand that.
133

134
00:07:53.470 --> 00:08:00.090
So this slide actually shows 4 or
8 giving 12 and then 12 or 11 giving 15.
134

135
00:08:00.090 --> 00:08:02.980
So that's how OR actually works.
135

136
00:08:02.980 --> 00:08:08.290
The next one, the AND operation,
This sets each bit of the result to one,
136

137
00:08:08.290 --> 00:08:11.570
if the corresponding bit
in both upper hands is one.
137

138
00:08:11.570 --> 00:08:12.900
So let's have a look at
that in the next slide.
138

139
00:08:15.790 --> 00:08:20.720
So as you can see here, 12 and eight is
eight because there's only one position
139

140
00:08:20.720 --> 00:08:25.070
that's got both a one, or that has a one
in both 12 and eight as you can see there.
140

141
00:08:25.070 --> 00:08:29.870
So eight and seven is zero, as no
positions contain a one in both numbers.
141

142
00:08:29.870 --> 00:08:34.740
And just moving on to the final slide,
this is Exclusive OR, or XOR.
142

143
00:08:34.740 --> 00:08:35.790
And with this one,
143

144
00:08:35.790 --> 00:08:39.670
XOR sets the corresponding bit of
the result to one if either but not
144

145
00:08:39.670 --> 00:08:43.930
both of the upper ANDs has a one in that
position as you can see in this slide.
145

146
00:08:43.930 --> 00:08:46.600
Now, XOR is useful because
if you repeat the operation,
146

147
00:08:46.600 --> 00:08:47.670
you get the original number back.
147

148
00:08:47.670 --> 00:08:49.020
Now we'll move on to the next slide.
148

149
00:08:52.100 --> 00:08:56.410
So in this one you can actually see 12
XOR eight is four or equals four and
149

150
00:08:56.410 --> 00:08:58.970
four XOR eight is equal to 12.
150

151
00:08:58.970 --> 00:09:03.190
Now this has got useful applications
in cryptography, for example.
151

152
00:09:03.190 --> 00:09:07.030
And was also used to draw the cursor
on early monochrome screens.
152

153
00:09:07.030 --> 00:09:11.690
By XORing each row of a character's eight
bit representation on the screen The image
153

154
00:09:11.690 --> 00:09:14.850
would actually be inverted to represent
the cursor being on that character.
154

155
00:09:14.850 --> 00:09:17.430
So XOR again restores the character.
155

156
00:09:17.430 --> 00:09:18.760
Now moving on to the last slide.
156

157
00:09:21.390 --> 00:09:25.010
This actually shows you a much
smaller four by five character
157

158
00:09:25.010 --> 00:09:26.830
XOR in each row with one one one one.
158

159
00:09:26.830 --> 00:09:28.550
And you can sort of see
what happened there.
159

160
00:09:28.550 --> 00:09:31.060
Now that's really all you need to
know about binary at this stage,
160

161
00:09:31.060 --> 00:09:34.450
we're not really going to perform
binary arithmetic manually
161

162
00:09:34.450 --> 00:09:36.470
Because we've got computers to do that.
162

163
00:09:36.470 --> 00:09:39.610
But, that said understanding
how numbers are stored
163

164
00:09:39.610 --> 00:09:42.870
inside the computer is actually
very useful especially when we have
164

165
00:09:42.870 --> 00:09:45.970
to consider how many bytes we have
to allocate for storing our data.
165

166
00:09:45.970 --> 00:09:48.010
Now it also explains why, for
166

167
00:09:48.010 --> 00:09:52.240
example ASCII cannot be used to represent
all the characters that are used in
167

168
00:09:52.240 --> 00:09:57.330
the various languages around the world as
ASCII characters must fit into one byte.
168

169
00:09:57.330 --> 00:10:00.950
Now Unicode resolves this by using two or
four bytes per character and
169

170
00:10:00.950 --> 00:10:02.840
allowing many more characters
to be represented.
170

171
00:10:02.840 --> 00:10:06.420
Now if some of that or all of that didn't
make a great deal of sense, don't worry.
171

172
00:10:06.420 --> 00:10:09.110
It's useful to understand what's
going on inside the computer
172

173
00:10:09.110 --> 00:10:11.940
But is not actually essential and
the remainder of this course
173

174
00:10:11.940 --> 00:10:15.340
does not require you to actually
understand the binary number system.
174

175
00:10:15.340 --> 00:10:17.170
So that's it,
I'm going to finish the video here.
175

176
00:10:17.170 --> 00:10:21.100
In the next video we're going to start
looking at hexidecimal and octal.
176

177
00:10:21.100 --> 00:10:22.460
So see you in the next video.
