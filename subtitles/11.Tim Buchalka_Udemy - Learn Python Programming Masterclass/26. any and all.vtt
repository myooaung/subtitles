WEBVTT
1
1

00:00:04.430  -->  00:00:06.500
Alright, so let's talk now about
2

2

00:00:06.500  -->  00:00:09.410
Any and All. So the names of these
3

3

00:00:09.410  -->  00:00:12.260
two functions pretty much describe what they
4

4

00:00:12.260  -->  00:00:15.289
do. All, that checks to see if the items
5

5

00:00:15.289  -->  00:00:18.320
in an iterable are true and Any, by
6

6

00:00:18.320  -->  00:00:20.630
contrast, checks to see if any of them
7

7

00:00:20.630  -->  00:00:23.570
are. Both functions take an iterable
8

8

00:00:23.570  -->  00:00:26.779
and return either true or false, depending on
9

9

00:00:26.779  -->  00:00:29.599
the values in the iterable. So let's have
10

10

00:00:29.599  -->  00:00:31.730
a look at some examples, to clarify their
11

11

00:00:31.730  -->  00:00:34.100
behavior and also see a couple of things
12

12

00:00:34.100  -->  00:00:36.260
to be wary of when you're using them.
13

13

00:00:36.260  -->  00:00:37.610
Now we're going to start by using a
14

14

00:00:37.610  -->  00:00:39.680
simple list for our iterable and I'm going to
15

15

00:00:39.680  -->  00:00:41.480
create a new Python file to do that,
16

16

00:00:41.480  -->  00:00:42.980
so let's do that. I'm going to create the
17

17

00:00:42.980  -->  00:00:50.210
file and call it anyall. Alright, so
18

18

00:00:50.210  -->  00:00:52.340
let's start typing now, so on line 1,
19

19

00:00:52.340  -->  00:00:55.370
entries equals left and right square
20

20

00:00:55.370  -->  00:00:58.280
braces. It's going to be 1, 2, 3,
21

21

00:00:58.280  -->  00:01:01.790
4, 5 separated by commas. On the
22

22

00:01:01.790  -->  00:01:03.729
first, on line three, we're going to print
23

23

00:01:03.729  -->  00:01:07.460
parentheses all colon left and right
24

24

00:01:07.460  -->  00:01:10.540
curly braces ending double quote comma
25

25

00:01:10.540  -->  00:01:15.470
format and in parentheses, all parenthesis
26

26

00:01:15.470  -->  00:01:18.500
entries, and the closing parenthesis. On
27

27

00:01:18.500  -->  00:01:20.420
the next line, we're going to do the same
28

28

00:01:20.420  -->  00:01:22.760
but for Any, so in double quotes after
29

29

00:01:22.760  -->  00:01:26.090
the print, any colon then our left and
30

30

00:01:26.090  -->  00:01:28.400
right curly braces closing double quote
31

31

00:01:28.400  -->  00:01:31.730
dot format and left parenthesis,
32

32

00:01:31.730  -->  00:01:34.430
any, left parenthesis entries and the closing
33

33

00:01:34.430  -->  00:01:37.580
right parenthesis. And I'm going
34

34

00:01:37.580  -->  00:01:39.740
to actually change this. What
35

35

00:01:39.740  -->  00:01:45.340
I'm going to do is, I'm gonna run it first, so let's do that.
36

36

00:01:45.340  -->  00:01:48.620
So you can see any and all have both
37

37

00:01:48.620  -->  00:01:50.900
returned true here, so basically, both
38

38

00:01:50.900  -->  00:01:52.760
functions are taking an iterable
39

39

00:01:52.760  -->  00:01:55.370
and returning either true or false, depending
40

40

00:01:55.370  -->  00:01:58.820
on the values in the iterable. And again
41

41

00:01:58.820  -->  00:02:01.010
in this case, both functions, as you can
42

42

00:02:01.010  -->  00:02:03.020
see in the run pane, are returning true.
43

43

00:02:03.020  -->  00:02:04.850
Now the reason that all is returning
44

44

00:02:04.850  -->  00:02:07.430
true is because all the items in the
45

45

00:02:07.430  -->  00:02:09.950
list of true values, and any value
46

46

00:02:09.950  -->  00:02:12.230
returns true because at least one of
47

47

00:02:12.230  -->  00:02:14.749
them is. Now I'm going to review what we
48

48

00:02:14.749  -->  00:02:17.389
mean by a true value in a moment, but firstly
49

49

00:02:17.389  -->  00:02:18.170
though, let's just
50

50

00:02:18.170  -->  00:02:21.140
see another example. On line 6
51

51

00:02:21.140  -->  00:02:22.480
I'm going to start by typing print
52

52

00:02:22.480  -->  00:02:25.670
parenthesis, in double quotes Iterable,
53

53

00:02:25.670  -->  00:02:30.110
with a single quote False closing single
54

54

00:02:30.110  -->  00:02:32.060
quote value, so that's our heading on
55

55

00:02:32.060  -->  00:02:33.500
that line. Then we're going to do, on
56

56

00:02:33.500  -->  00:02:36.500
line 7, entries with, underscore with
57

57

00:02:36.500  -->  00:02:40.700
that is, underscore zero is equal to, then
58

58

00:02:40.700  -->  00:02:43.580
in left and right square braces 1, 2
59

59

00:02:43.580  -->  00:02:49.640
0, 4, 5 and let's just take a
60

60

00:02:49.640  -->  00:02:53.450
copy of any, all and any. Paste it in
61

61

00:02:53.450  -->  00:02:55.370
and then we'll just change, so it's
62

62

00:02:55.370  -->  00:02:57.140
actually printing out the values
63

63

00:02:57.140  -->  00:03:00.220
from our second entry there. Entries with zero,
64

64

00:03:00.220  -->  00:03:05.600
entries with zero. What I might do
65

65

00:03:05.600  -->  00:03:08.959
is, just take the opportunity here to move
66

66

00:03:08.959  -->  00:03:10.610
the run window to the right hand side, so
67

67

00:03:10.610  -->  00:03:11.600
we can see the output a little bit
68

68

00:03:11.600  -->  00:03:14.900
better and now you've seen that code,
69

69

00:03:14.900  -->  00:03:16.220
or typed that code in, rather, let's actually
70

70

00:03:16.220  -->  00:03:19.580
run it. And you can see there, Iterable
71

71

00:03:19.580  -->  00:03:22.760
with a False value, all is returning
72

72

00:03:22.760  -->  00:03:25.180
False there but any is returning True.
73

73

00:03:25.180  -->  00:03:27.470
So contrasting that to the previous
74

74

00:03:27.470  -->  00:03:30.680
example, where all returned True. So any
75

75

00:03:30.680  -->  00:03:32.540
still returning True here in this second
76

76

00:03:32.540  -->  00:03:35.239
example, and it's basically asking, does
77

77

00:03:35.239  -->  00:03:38.239
the list contain any true items?
78

78

00:03:38.239  -->  00:03:39.709
Alright, so now that we've seen that,
79

79

00:03:39.709  -->  00:03:41.780
so what do we mean when we say true items
80

80

00:03:41.780  -->  00:03:43.480
or true values? What do we mean by that?
81

81

00:03:43.480  -->  00:03:46.280
Well if you can recall, way back early on
82

82

00:03:46.280  -->  00:03:47.840
in the course, I showed you how Python
83

83

00:03:47.840  -->  00:03:50.780
interprets some values as false
84

84

00:03:50.780  -->  00:03:53.090
and everything else as true. So what I'm
85

85

00:03:53.090  -->  00:03:54.650
going to do is paste that code back in,
86

86

00:03:54.650  -->  00:03:56.870
and we'll run it again just to refresh
87

87

00:03:56.870  -->  00:04:00.380
your memory there. I'm going to do that
88

88

00:04:00.380  -->  00:04:02.650
on line 12,
89

89

00:04:02.650  -->  00:04:04.820
and I'll just close the run window for
90

90

00:04:04.820  -->  00:04:09.620
now, and there's the example. You can see
91

91

00:04:09.620  -->  00:04:11.510
the code that I've pasted in there.
92

92

00:04:11.510  -->  00:04:13.820
Now I've used the bool function to convert
93

93

00:04:13.820  -->  00:04:16.040
the value to true or false, as Python
94

94

00:04:16.040  -->  00:04:17.959
sees it. By printing the result of
95

95

00:04:17.959  -->  00:04:20.180
calling bool for each of the items, we
96

96

00:04:20.180  -->  00:04:22.460
can confirm that Python hopefully does
97

97

00:04:22.460  -->  00:04:24.530
see them as false. Everything else though,
98

98

00:04:24.530  -->  00:04:26.900
will be evaluated as true if we use
99

99

00:04:26.900  -->  00:04:28.460
it as a condition but let's just tell run
100

100

00:04:28.460  -->  00:04:31.240
this example first.
101

101

00:04:31.240  -->  00:04:33.260
You can see down here, we're getting the
102

102

00:04:33.260  -->  00:04:34.940
examples here, values interpreted as
103

103

00:04:34.940  -->  00:04:37.820
False in Python. False is false, None
104

104

00:04:37.820  -->  00:04:40.880
is false, 0 is false, 0.0 is false, an empty
105

105

00:04:40.880  -->  00:04:41.660
list is false,
106

106

00:04:41.660  -->  00:04:43.640
empty tuple false, empty string false,
107

107

00:04:43.640  -->  00:04:45.350
an empty string with double quotes is
108

108

00:04:45.350  -->  00:04:47.300
termed false and entry mapping
109

109

00:04:47.300  -->  00:04:50.210
also false. Now that's pretty clear now, but cos
110

110

00:04:50.210  -->  00:04:52.130
we've used the bool function, and by
111

111

00:04:52.130  -->  00:04:53.660
printing the result of calling bool for
112

112

00:04:53.660  -->  00:04:55.310
each of these items, as I mentioned, we're
113

113

00:04:55.310  -->  00:04:56.870
confirming that Python does in fact see
114

114

00:04:56.870  -->  00:04:58.760
them as false. Everything else however,
115

115

00:04:58.760  -->  00:05:01.760
will be evaluated as true if we use it
116

116

00:05:01.760  -->  00:05:04.160
as a condition. A quick example should
117

117

00:05:04.160  -->  00:05:06.080
help with that, so let's just type that
118

118

00:05:06.080  -->  00:05:15.440
in. Okay, okay so we're going to start on
119

119

00:05:15.440  -->  00:05:18.020
line 25, print 2 parentheses double
120

120

00:05:18.020  -->  00:05:21.830
quotes, an equal in it, times 80, so we
121

121

00:05:21.830  -->  00:05:23.840
get a nice little heading there and then
122

122

00:05:23.840  -->  00:05:28.850
we're going to do name equals double
123

123

00:05:28.850  -->  00:05:30.440
quotes, two double quotes, so we're going to
124

124

00:05:30.440  -->  00:05:33.080
start with an empty string, if name colon.
125

125

00:05:33.080  -->  00:05:35.680
On the next line, then print Hello
126

126

00:05:35.680  -->  00:05:38.930
left and right curly braces closing double
127

127

00:05:38.930  -->  00:05:43.460
quote dot format name. Then we're gonna have an
128

128

00:05:43.460  -->  00:05:45.470
else on the next line, else colon then
129

129

00:05:45.470  -->  00:05:51.380
print Welcome, person with no name, double
130

130

00:05:51.380  -->  00:05:56.270
quotes closing parenthesis. So when we're
131

131

00:05:56.270  -->  00:05:59.420
testing name on line 27, it evaluates to
132

132

00:05:59.420  -->  00:06:00.770
false and we should get the welcome
133

133

00:06:00.770  -->  00:06:02.720
message printed out. So let's actually run
134

134

00:06:02.720  -->  00:06:04.910
that and confirm that is the case.
135

135

00:06:04.910  -->  00:06:06.470
You can see down here in the output, or
136

136

00:06:06.470  -->  00:06:07.610
at the right hand side of the screen,
137

137

00:06:07.610  -->  00:06:09.680
Welcome, person with no name, and that's
138

138

00:06:09.680  -->  00:06:11.030
consistent with the fact that an empty
139

139

00:06:11.030  -->  00:06:12.590
string higher up on the run
140

140

00:06:12.590  -->  00:06:15.260
window output there, is also returning false,
141

141

00:06:15.260  -->  00:06:17.270
and if we change that to actually put a name
142

142

00:06:17.270  -->  00:06:19.280
on line 26 instead of the empty string
143

143

00:06:19.280  -->  00:06:23.060
and run it again, this time we're getting
144

144

00:06:23.060  -->  00:06:24.710
Hello Tim because it's no longer being
145

145

00:06:24.710  -->  00:06:27.350
evaluated as false. In fact name is now
146

146

00:06:27.350  -->  00:06:29.450
true because it has got some content.
147

147

00:06:29.450  -->  00:06:31.940
It's not empty, in other words. So
148

148

00:06:31.940  -->  00:06:35.450
closing now the run pane again,
149

149

00:06:35.450  -->  00:06:37.160
and going back to our code at the top there,
150

150

00:06:37.160  -->  00:06:39.410
our entries with zero list, it
151

151

00:06:39.410  -->  00:06:41.690
should now be obvious as to why all return
152

152

00:06:41.690  -->  00:06:44.120
false. Zero was interpreted as
153

153

00:06:44.120  -->  00:06:46.310
false, so all the items in the
154

154

00:06:46.310  -->  00:06:48.979
list aren't true. Alright, so that's all and any.
155

155

00:06:48.979  -->  00:06:51.800
They both take an Iterable and can be
156

156

00:06:51.800  -->  00:06:54.590
very useful to check, or for checking the
157

157

00:06:54.590  -->  00:06:57.050
items in the iterable for consistency.
158

158

00:06:57.050  -->  00:06:59.210
This becomes even more useful when we
159

159

00:06:59.210  -->  00:07:00.919
combine them with a comprehension
160

160

00:07:00.919  -->  00:07:03.680
or generate our expression, which is why
161

161

00:07:03.680  -->  00:07:05.240
we've included them in this section on
162

162

00:07:05.240  -->  00:07:07.160
comprehensions. If you recall, 
163

163

00:07:07.160  -->  00:07:08.630
I did mention
164

164

00:07:08.630  -->  00:07:10.010
that there's a couple of things to be wary of.
165

165

00:07:10.010  -->  00:07:13.580
The main one is how all behaves with an
166

166

00:07:13.580  -->  00:07:16.040
empty iterable. So I'm going to create a
167

167

00:07:16.040  -->  00:07:17.870
new file for this just to help clarify.
168

168

00:07:17.870  -->  00:07:21.199
So New, Python file, and we'll call
169

169

00:07:21.199  -->  00:07:26.539
this one allgotcha, and I'm gonna paste
170

170

00:07:26.539  -->  00:07:30.440
in these three lines from the previous
171

171

00:07:30.440  -->  00:07:31.550
example we we're working on,
172

172

00:07:31.550  -->  00:07:33.410
previous file. Alright, so let's run
173

173

00:07:33.410  -->  00:07:38.449
that, and again we can see there, on the
174

174

00:07:38.449  -->  00:07:40.400
right-hand side, both the functions are
175

175

00:07:40.400  -->  00:07:41.930
returning true as we saw earlier in the
176

176

00:07:41.930  -->  00:07:45.139
video, but what happens if the iterable
177

177

00:07:45.139  -->  00:07:48.139
is empty? Let's change that to making an
178

178

00:07:48.139  -->  00:07:51.770
empty list on line 1. Before I run the
179

179

00:07:51.770  -->  00:07:53.120
program though, have a think about what
180

180

00:07:53.120  -->  00:07:54.740
you'd expect to happen. What would you
181

181

00:07:54.740  -->  00:07:57.080
expect to happen, given that now the list
182

182

00:07:57.080  -->  00:08:01.340
is empty. So let's now run this and
183

183

00:08:01.340  -->  00:08:04.130
you can see that any behaves as expected
184

184

00:08:04.130  -->  00:08:06.320
and returns false, and that makes sense
185

185

00:08:06.320  -->  00:08:07.910
because the list doesn't contain any
186

186

00:08:07.910  -->  00:08:09.979
items that could be true. Now where you
187

187

00:08:09.979  -->  00:08:11.539
may have expected a different
188

188

00:08:11.539  -->  00:08:14.180
result though, is all. As you can see there
189

189

00:08:14.180  -->  00:08:16.910
in the output, all is returning true. Now
190

190

00:08:16.910  -->  00:08:18.740
that's the documented behavior so it's
191

191

00:08:18.740  -->  00:08:20.690
not a bug, but I wouldn't have expected
192

192

00:08:20.690  -->  00:08:22.760
that result, and that's why I've included
193

193

00:08:22.760  -->  00:08:24.289
this because it's something that can
194

194

00:08:24.289  -->  00:08:26.660
catch you out. If there's a possibility
195

195

00:08:26.660  -->  00:08:28.970
that your list, or whatever iterable
196

196

00:08:28.970  -->  00:08:31.099
you're checking can be empty, then you
197

197

00:08:31.099  -->  00:08:33.169
need to test for that as well. Now we've
198

198

00:08:33.169  -->  00:08:35.150
just seen that an empty list evaluates
199

199

00:08:35.150  -->  00:08:37.610
as false in a boolean expression, so you
200

200

00:08:37.610  -->  00:08:39.440
can generally, write something
201

201

00:08:39.440  -->  00:08:42.289
like this; so I'm going to just
202

202

00:08:42.289  -->  00:08:43.550
close down this run window so we get more
203

203

00:08:43.550  -->  00:08:46.220
output, but you can do something like, on
204

204

00:08:46.220  -->  00:08:51.410
line 3, if entries then we go print
205

205

00:08:51.410  -->  00:08:55.240
all, else
206

206

00:08:55.240  -->  00:09:00.080
print false in double quotes. Then on the
207

207

00:09:00.080  -->  00:09:01.010
next line, we're going to print
208

208

00:09:01.010  -->  00:09:04.160
the result of calling any. If you run that
209

209

00:09:04.160  -->  00:09:08.180
now, we're getting false returned in both
210

210

00:09:08.180  -->  00:09:11.420
scenarios, which is now more correct. So
211

211

00:09:11.420  -->  00:09:13.310
this would be a better way of actually
212

212

00:09:13.310  -->  00:09:14.930
writing a code there, because we're now
213

213

00:09:14.930  -->  00:09:17.600
using the fact that conditional if
214

214

00:09:17.600  -->  00:09:19.670
is evaluating the empty list as false in a
215

215

00:09:19.670  -->  00:09:22.220
boolean expression. Another thing to be aware
216

216

00:09:22.220  -->  00:09:24.380
of is combining the check for an empty
217

217

00:09:24.380  -->  00:09:27.020
list in a single boolean expression.
218

218

00:09:27.020  -->  00:09:27.980
So you might be tempted to do
219

219

00:09:27.980  -->  00:09:30.250
something along these lines;
220

220

00:09:30.250  -->  00:09:34.839
result equals entries and all
221

221

00:09:34.839  -->  00:09:41.600
parentheses entries print result. So if
222

222

00:09:41.600  -->  00:09:45.020
we run that, so as you can see, we get
223

223

00:09:45.020  -->  00:09:47.570
the result printing as an empty list, not
224

224

00:09:47.570  -->  00:09:50.660
false as we wanted. So in this case, we
225

225

00:09:50.660  -->  00:09:53.060
have to be explicit. So we would change
226

226

00:09:53.060  -->  00:09:55.760
that to result equals bool, call to bool,
227

227

00:09:55.760  -->  00:10:01.399
entries and all entries, like so. If we
228

228

00:10:01.399  -->  00:10:04.820
run that, we're now correctly getting
229

229

00:10:04.820  -->  00:10:07.430
false showing. Basically, now behaves as
230

230

00:10:07.430  -->  00:10:10.040
we want. So there you go, two gotchas for
231

231

00:10:10.040  -->  00:10:12.470
the price of one. I'll go over some more
232

232

00:10:12.470  -->  00:10:14.660
examples of any and all in a later video.
233

233

00:10:14.660  -->  00:10:17.120
We're going to need some data for the
234

234

00:10:17.120  -->  00:10:18.470
examples, and we really don't want to
235

235

00:10:18.470  -->  00:10:20.630
spend a lot of time typing it all in, so in
236

236

00:10:20.630  -->  00:10:22.339
the resources section for this video,
237

237

00:10:22.339  -->  00:10:25.490
you'll find the file data.py. Download
238

238

00:10:25.490  -->  00:10:27.290
that file and place it in your project
239

239

00:10:27.290  -->  00:10:29.180
directory, and we'll make use of that in
240

240

00:10:29.180  -->  00:10:30.950
the next video. I won't be
241

241

00:10:30.950  -->  00:10:32.930
using comprehensions in the next video.
242

242

00:10:32.930  -->  00:10:34.700
Those examples for comprehensions
243

243

00:10:34.700  -->  00:10:36.589
will be in the video after that. The next
244

244

00:10:36.589  -->  00:10:38.240
one, though, is a short one to introduce
245

245

00:10:38.240  -->  00:10:41.060
named tuples. So I'll see you in the
246

246

00:10:41.060  -->  00:10:43.480
next video.
