WEBVTT
1
1

00:00:05.280  -->  00:00:10.230
So continuing on with our discussion about
tuples in Python, so we just talked about
2

2

00:00:10.230  -->  00:00:14.210
this line here in line 15 and how that
concept is called unpacking the tuple.
3

3

00:00:14.210  -->  00:00:18.000
It actually mentioned I'm gonna
leave the list item here on line 12,
4

4

00:00:18.000  -->  00:00:21.560
just to show you how a tuple can be
much better than listing situation.
5

5

00:00:21.560  -->  00:00:24.450
So again if we run the program,
making sure we've selected tuples or
6

6

00:00:24.450  -->  00:00:27.080
whatever name you've called your path and
fall.
7

7

00:00:27.080  -->  00:00:29.600
Click on run.
You can actually see how it's unpacked
8

8

00:00:29.600  -->  00:00:33.140
the top, so in other words with that
one line of code on line 15 you've
9

9

00:00:33.140  -->  00:00:37.550
extracted the contents out of the tuple
into three individual variables, title,
10

10

00:00:37.550  -->  00:00:38.500
artist and year.
11

11

00:00:38.500  -->  00:00:41.090
So you can see that that makes it
very convenient when dealing with
12

12

00:00:41.090  -->  00:00:45.620
the individual items of tuple by signing
them to meaningful named variables.
13

13

00:00:45.620  -->  00:00:47.640
I'm just cleaning up this a little bit so
I'm going to delete that.
14

14

00:00:48.880  -->  00:00:52.540
So we can actually do something similar or
actually the same with the list.
15

15

00:00:52.540  -->  00:00:53.610
So you can change this.
16

16

00:00:53.610  -->  00:00:57.110
So we could come along here and
we could change this code on line ten and
17

17

00:00:57.110  -->  00:01:02.790
we could do something like
teleca two dot pinned rock.
18

18

00:01:03.820  -->  00:01:08.720
Like so.
I'm going to give it title, artist,
19

19

00:01:08.720  -->  00:01:11.280
year, equals Metallica 2.
20

20

00:01:11.280  -->  00:01:15.350
And if we actually run that,
we actually get an error.
21

21

00:01:15.350  -->  00:01:20.620
And this is an example of why you wouldn't
want to use a list in this situation where
22

22

00:01:20.620  -->  00:01:24.310
the code you're working on, or the data
you're working on, isn't to be changed.
23

23

00:01:24.310  -->  00:01:25.440
So it's not immutable.
24

24

00:01:25.440  -->  00:01:27.510
So a list, you can see, isn't immutable.
25

25

00:01:27.510  -->  00:01:30.140
We're able to actually
append an item to that.
26

26

00:01:30.140  -->  00:01:33.490
And, of course, when we went to run
the code on line 12, we actually failed
27

27

00:01:33.490  -->  00:01:39.060
because it was too many values to unpack,
because we didn't assign enough variables.
28

28

00:01:39.060  -->  00:01:41.160
To unpack the data out of the list.
29

29

00:01:41.160  -->  00:01:44.230
So remember that you might
be creating code modules.
30

30

00:01:44.230  -->  00:01:46.320
That will be used in
different parts of a program.
31

31

00:01:46.320  -->  00:01:49.800
And possibly and even probably if
you start working professionally.
32

32

00:01:49.800  -->  00:01:52.170
As a path-end developer
by other programmers.
33

33

00:01:52.170  -->  00:01:54.950
And if you allow such things
to be done then frankly.
34

34

00:01:54.950  -->  00:01:57.280
It's only a matter of time
before they will be done.
35

35

00:01:57.280  -->  00:01:58.980
That's just the nature of programming.
36

36

00:01:58.980  -->  00:02:02.470
Now because a tuple is immutable
in other words it can't be changed
37

37

00:02:02.470  -->  00:02:07.400
In this case line ten couldn't be executed
cuz a tuple doesn't have an append method.
38

38

00:02:07.400  -->  00:02:11.180
So, this makes your code much more robust
to make it a tuple in this scenario and
39

39

00:02:11.180  -->  00:02:14.010
prevents errors that would actually
not appear until someone else was
40

40

00:02:14.010  -->  00:02:14.990
using the program.
41

41

00:02:14.990  -->  00:02:20.150
So for example if we try and
do something like imelda.append
42

42

00:02:20.150  -->  00:02:24.060
note that there's no intelligent,
IntelliSense, nothing happened.
43

43

00:02:24.060  -->  00:02:26.520
Try and do that and run it.
44

44

00:02:26.520  -->  00:02:31.050
I think if I just comment
out that line for now.
45

45

00:02:31.050  -->  00:02:35.770
The point is if we actually run this now,
we actually get an error, tuple object has
46

46

00:02:35.770  -->  00:02:40.420
no attribute append, because of course we
can only use the .append with a list item.
47

47

00:02:40.420  -->  00:02:43.190
Now the other thing to note is that
tuple can contain elements that
48

48

00:02:43.190  -->  00:02:44.940
are themselves tuples.
49

49

00:02:44.940  -->  00:02:45.930
So let's actually go ahead and
50

50

00:02:45.930  -->  00:02:49.520
add a track list to the tuple
representing the Albert Moore Mayhem.
51

51

00:02:49.520  -->  00:02:51.920
We're just gonna use the first
four songs to save some typing.
52

52

00:02:51.920  -->  00:02:55.060
So we're gonna clear out the Metallica
code because we don't need that anymore.
53

53

00:02:55.060  -->  00:02:56.300
I'm just going to get rid
of all that right now.
54

54

00:02:56.300  -->  00:02:58.830
And let's actually change this mail order,
and
55

55

00:02:58.830  -->  00:03:01.090
I'm just going to close the running data.
56

56

00:03:01.090  -->  00:03:04.410
And after date,
the year that the album was released,
57

57

00:03:04.410  -->  00:03:06.660
then I'm going to put a comma,
then put a bracket, and
58

58

00:03:06.660  -->  00:03:10.470
I'm going to type in another bracket,
because I'm creating a tuple.
59

59

00:03:10.470  -->  00:03:12.100
And we're going to create
the individual items.
60

60

00:03:12.100  -->  00:03:17.500
So it's one, in the tracks,
61

61

00:03:17.500  -->  00:03:24.630
"Pulling the rug" 2, "Psycho".
62

62

00:03:24.630  -->  00:03:28.410
3, "Mayhem".
63

63

00:03:28.410  -->  00:03:33.410
And 4, "Kentish Town Waltz.
64

64

00:03:36.610  -->  00:03:38.500
I can just do that and
get rid of that last bracket there.
65

65

00:03:38.500  -->  00:03:43.200
So it's another line here, print(imelda).
66

66

00:03:43.200  -->  00:03:48.070
We're gonna do in this case,
we're gonna do title, artist, year, but
67

67

00:03:48.070  -->  00:03:52.420
also tracks now,
the fourth variable, equals imelda.
68

68

00:03:52.420  -->  00:03:55.730
So we're unpacking the top lagoon.
69

69

00:03:55.730  -->  00:04:00.720
And of course we're gonna print title,
print artist,
70

70

00:04:00.720  -->  00:04:05.640
print year, print tracks.
71

71

00:04:05.640  -->  00:04:06.250
So if you run that.
72

72

00:04:07.380  -->  00:04:10.130
You can see we've correctly
now got the information out.
73

73

00:04:10.130  -->  00:04:13.400
We've got the three fields as before,
title, artist and year.
74

74

00:04:13.400  -->  00:04:15.830
But notice how the fourth entry, tracks,
75

75

00:04:15.830  -->  00:04:18.600
has been returned as
a tuple in its own right.
76

76

00:04:18.600  -->  00:04:20.870
Now the important thing to
note here in this situation,
77

77

00:04:20.870  -->  00:04:22.630
when adding these extra tuples,
78

78

00:04:22.630  -->  00:04:26.500
was that it was important to actually
enclose the four individual songs.
79

79

00:04:26.500  -->  00:04:29.310
The track number and
the actual song in parentheses.
80

80

00:04:29.310  -->  00:04:32.350
Otherwise what would happen
would be the Python interpreter
81

81

00:04:32.350  -->  00:04:36.050
would actually evaluate that as
a single tuple with eight elements.
82

82

00:04:36.050  -->  00:04:38.790
In other words, track 1,
song 1, track 2, song 2.
83

83

00:04:38.790  -->  00:04:42.630
So by putting an extra set
of parentheses around each,
84

84

00:04:42.630  -->  00:04:47.160
we're actually making it clear that these
are individual tuples in their own right.
85

85

00:04:47.160  -->  00:04:49.850
So just to show you what I actually
mean there I can actually change that.
86

86

00:04:49.850  -->  00:04:54.920
So I could get rid of these extra
brackets, and close this down.
87

87

00:04:54.920  -->  00:04:56.140
So I get rid of all these brackets.
88

88

00:05:02.840  -->  00:05:04.850
Just leaving the last bracket in there.
89

89

00:05:04.850  -->  00:05:05.740
If I actually run that.
90

90

00:05:05.740  -->  00:05:09.720
You can see, now,
we've got single tuple with eight entries.
91

91

00:05:09.720  -->  00:05:12.650
The four individual track numbers,
and the four songs.
92

92

00:05:12.650  -->  00:05:15.740
And obviously, in that case, we've
actually lost a lot of the structure.
93

93

00:05:15.740  -->  00:05:18.510
Because instead of the tracks
obviously having a track number.
94

94

00:05:18.510  -->  00:05:22.150
With title we've just got eight values,
and there's no obvious relationship.
95

95

00:05:22.150  -->  00:05:24.350
At least not obvious to the computer,
anyway.
96

96

00:05:24.350  -->  00:05:28.060
So we just undo that, and do that again,
put the brackets back again.
97

97

00:05:31.360  -->  00:05:33.080
So we've got individual tuples again.
98

98

00:05:33.080  -->  00:05:36.680
And it's also possible to extract
the individual tracks as well.
99

99

00:05:36.680  -->  00:05:39.350
So at the moment we got title,
artist, year, we've got tracks.
100

100

00:05:39.350  -->  00:05:46.950
But let's change tracks to track1,
track2, track3, and track4.
101

101

00:05:46.950  -->  00:05:55.200
And now we have to print those out
individually, so track1, 2, 3, 4.
102

102

00:05:55.200  -->  00:05:56.150
So, we can actually run that.
103

103

00:05:56.150  -->  00:06:00.350
And what I was going to do then,
I'll just close that down.
104

104

00:06:00.350  -->  00:06:03.250
What I was gonna go is get rid
of this initial bracket, so
105

105

00:06:03.250  -->  00:06:06.680
I'm actually just creating four
separate tuples effectively here.
106

106

00:06:06.680  -->  00:06:12.060
If I actually run that,
that breaks down each individual track and
107

107

00:06:12.060  -->  00:06:14.380
title into it's own tuple.
108

108

00:06:14.380  -->  00:06:15.950
Now that will actually get an error, and
109

109

00:06:15.950  -->  00:06:19.010
the error that you actually saw on the
screen before I changed it, if it hadn't
110

110

00:06:19.010  -->  00:06:21.860
actually created four separate track
variables, as I've done there.
111

111

00:06:21.860  -->  00:06:26.310
But also if I hadn't actually changed and
removed the extra brackets,
112

112

00:06:26.310  -->  00:06:29.930
you sort of created a tuple
within a tuple, so to speak, or
113

113

00:06:29.930  -->  00:06:32.760
four tuples within that master tuple.
114

114

00:06:32.760  -->  00:06:35.590
So in this example, though, it's still
a good example cuz we've actually
115

115

00:06:35.590  -->  00:06:37.860
retained the relationship
between track number and title.
116

116

00:06:37.860  -->  00:06:41.460
But the downside with this method here,
with track one through four,
117

117

00:06:41.460  -->  00:06:44.620
cuz we'd actually need to know in
advance how many tracks there are.
118

118

00:06:44.620  -->  00:06:46.940
And obviously we'll need to
create a variable for each one.
119

119

00:06:46.940  -->  00:06:49.770
Cuz obviously if we forgot,
and got rid of track4 and
120

120

00:06:49.770  -->  00:06:53.460
we'll comment this line out and
we were to run it,
121

121

00:06:53.460  -->  00:06:57.440
you actually get an error because
there's too many values to unpack.
122

122

00:06:57.440  -->  00:07:00.400
So we'll need to look at
our data now ahead of time.
123

123

00:07:00.400  -->  00:07:02.750
How many variables to actually
have on the assignment line,
124

124

00:07:02.750  -->  00:07:06.290
and obviously to actually be able
to use those on the right line.
125

125

00:07:06.290  -->  00:07:09.420
Of course,
we've now lost the ability to actually
126

126

00:07:09.420  -->  00:07:11.710
process a single tuple with a for loop.
127

127

00:07:11.710  -->  00:07:14.470
And we'll do that in a minute,
just in case it's not obvious.
128

128

00:07:14.470  -->  00:07:17.850
So, let's actually look at the final
example without any parenthesis.
129

129

00:07:17.850  -->  00:07:20.230
To create a single tuple
containing 11 elements.
130

130

00:07:20.230  -->  00:07:23.450
So, I'm actually gonna copy and paste some
code here just to save a bit of time.
131

131

00:07:23.450  -->  00:07:24.140
I'm going to copy that.
132

132

00:07:24.140  -->  00:07:25.750
I'm going to close this window down.
133

133

00:07:25.750  -->  00:07:29.620
I'm just gonna paste this in to
the builder variable definition.
134

134

00:07:29.620  -->  00:07:33.140
So, you can see in this case now we've
literally got a single tuple containing
135

135

00:07:33.140  -->  00:07:34.310
eleven elements.
136

136

00:07:34.310  -->  00:07:37.360
So, we've obviously got the three that
we had initial title, artist, and year.
137

137

00:07:37.360  -->  00:07:39.620
And then we've also got each track number.
138

138

00:07:39.620  -->  00:07:42.230
And also, the actual song title for
139

139

00:07:42.230  -->  00:07:45.890
the first four songs of
the track of the album as well.
140

140

00:07:45.890  -->  00:07:48.470
I you try to print to run
this we'll get an error.
141

141

00:07:48.470  -->  00:07:51.030
And too many ellies to unpack, expected 7.
142

142

00:07:51.030  -->  00:07:55.350
And that's because we've actually put them
all individually into one master tuple.
143

143

00:07:55.350  -->  00:07:59.750
And it's now a total of 11 elements,
two each for the first four tracks, for
144

144

00:07:59.750  -->  00:08:01.210
the artist for the album.
145

145

00:08:01.210  -->  00:08:04.230
And then, of course, it was title,
artist as well, and that made up the 11.
146

146

00:08:04.230  -->  00:08:07.690
So if you're really trying to store
an album object, for instance, in Python,
147

147

00:08:07.690  -->  00:08:09.820
the first structure we
did makes more sense and
148

148

00:08:09.820  -->  00:08:12.500
more accurately reflects the real objects.
149

149

00:08:12.500  -->  00:08:14.560
Cuz albums can have
different numbers of tracks,
150

150

00:08:14.560  -->  00:08:18.610
you can just iterate over the contained
tracks tuple to print them all out.
151

151

00:08:18.610  -->  00:08:21.370
So as promised, we're going to look
at the code to print the tracks
152

152

00:08:21.370  -->  00:08:24.010
in more mayhem using
the original structure.
153

153

00:08:24.010  -->  00:08:27.610
But I didn't say I wouldn't ask
you to have a go first though.
154

154

00:08:27.610  -->  00:08:31.100
So what I've come up with is a simple
challenge and I'm gonna start that now.
155

155

00:08:31.100  -->  00:08:32.100
So let me talk about the challenge.
156

156

00:08:32.100  -->  00:08:33.540
So the challenge is going to be,
157

157

00:08:46.620  -->  00:08:47.990
Okay, so this is a challenge.
158

158

00:08:47.990  -->  00:08:50.620
So given the tuple that I've
got on line seven, below.
159

159

00:08:50.620  -->  00:08:53.950
And that actually represents the amount
Imelda May track called Mayhem.
160

160

00:08:53.950  -->  00:08:57.140
And that should actually say,
Imelda May album.
161

161

00:08:57.140  -->  00:08:58.690
So, here, I'll start it here.
162

162

00:08:58.690  -->  00:09:01.920
Given the tuple below that represents
the Imelda May album, Mayhem,
163

163

00:09:01.920  -->  00:09:03.870
or at least the first four songs.
164

164

00:09:03.870  -->  00:09:06.520
Right code to actually
print the album details.
165

165

00:09:06.520  -->  00:09:08.910
Followed by listing of all
the tracks in the album.
166

166

00:09:08.910  -->  00:09:12.130
Now, you want to indent the tracks by
a single tab stop when printing them.
167

167

00:09:12.130  -->  00:09:16.070
And remember that you can actually pass
more than one item to the print function,
168

168

00:09:16.070  -->  00:09:18.320
separating them with a comma.
169

169

00:09:18.320  -->  00:09:21.260
So go away and see if you can
come up with a solution to that,
170

170

00:09:21.260  -->  00:09:22.560
printing that out in the right format.
171

171

00:09:22.560  -->  00:09:25.660
And when you're ready to come back and
check your code, restart the video and
172

172

00:09:25.660  -->  00:09:26.730
I'll show you how to do it.
173

173

00:09:26.730  -->  00:09:28.830
So pause the video now and
see what you can come up with.
174

174

00:09:31.990  -->  00:09:34.320
Okay, so how did you figure it out?
175

175

00:09:34.320  -->  00:09:37.370
So let me go through and
show you our sample solution.
176

176

00:09:37.370  -->  00:09:40.820
First I'll start off by just
printing the current tuple just so
177

177

00:09:40.820  -->  00:09:42.330
we can sort of see what it's like.
178

178

00:09:42.330  -->  00:09:45.280
So the first thing we wanna
do is extract the fields.
179

179

00:09:45.280  -->  00:09:46.840
So we're gonna extract four.
180

180

00:09:46.840  -->  00:09:53.670
Title Artist, year, tracks = imelda.
181

181

00:09:53.670  -->  00:09:57.880
And obviously we're using this tuple
that has got four tuples within it, and
182

182

00:09:57.880  -->  00:10:02.280
by doing that, we can actually just use
that one assignment to actually get all of
183

183

00:10:02.280  -->  00:10:04.240
the tuples in that one assignment.
184

184

00:10:04.240  -->  00:10:09.590
And we can obviously print out the title,
print title.
185

185

00:10:09.590  -->  00:10:13.940
You can print the artist and
obviously the year as well but
186

186

00:10:13.940  -->  00:10:18.120
to actually go through each
song if you are using the for
187

187

00:10:18.120  -->  00:10:23.330
loop you are in the right frame of mind so
you type for song in tracks.
188

188

00:10:24.470  -->  00:10:28.060
Remembering that tracks
contains a list of tuples and
189

189

00:10:28.060  -->  00:10:32.520
the for loop is gonna go through and
allocate the individual song or
190

190

00:10:32.520  -->  00:10:36.850
the value from pulling it from
the tuple into the variable song.
191

191

00:10:36.850  -->  00:10:41.730
And from there we can literally just
192

192

00:10:41.730  -->  00:10:46.940
type print, adding the tap\t song.
193

193

00:10:46.940  -->  00:10:48.160
So, we can actually run that.
194

194

00:10:50.000  -->  00:10:52.780
And you can see that we are able
to actually print out the title,
195

195

00:10:52.780  -->  00:10:53.530
artist and year.
196

196

00:10:53.530  -->  00:10:56.370
And for each song we have actually
just printed out the tuple.
197

197

00:10:56.370  -->  00:11:00.130
Now alternatively you might have actually
further expanded the individual song
198

198

00:11:00.130  -->  00:11:02.490
tuples, and
you can do that quite easily as well.
199

199

00:11:02.490  -->  00:11:07.310
So what we could have done is under
the for loop we can type track,
200

200

00:11:07.310  -->  00:11:10.500
title = song.
201

201

00:11:10.500  -->  00:11:14.610
So I'm packing the tuple into
the variables called Track and Title.
202

202

00:11:14.610  -->  00:11:18.440
Then we can actually leave
the slash-T in there, but
203

203

00:11:18.440  -->  00:11:24.750
we wanna start using replacement fields,
and we'll put something like track number,
204

204

00:11:24.750  -->  00:11:28.600
and then title column,
another replacement field.
205

205

00:11:30.650  -->  00:11:36.500
And of course down here
we've actually put .format,
206

206

00:11:36.500  -->  00:11:39.810
which would be track, total.
207

207

00:11:39.810  -->  00:11:41.210
So we can actually run that code,
208

208

00:11:41.210  -->  00:11:46.910
and we'll individually print out the track
number and obviously the total as well.
209

209

00:11:46.910  -->  00:11:48.910
So that's my solution to the challenge.
210

210

00:11:48.910  -->  00:11:51.030
And just a couple more questions for
you to think about.
211

211

00:11:51.030  -->  00:11:54.780
So once you've actually represented
your alburn collection as tuples,
212

212

00:11:54.780  -->  00:11:58.790
we'll destroy all the tuples in the list,
or we'll just store them in another tuple.
213

213

00:11:58.790  -->  00:11:59.590
I'll just say that again.
214

214

00:11:59.590  -->  00:12:02.370
Once you've represented your
album collection as tuples,
215

215

00:12:02.370  -->  00:12:05.530
we'll destroy all the tuples in the list,
or in another tuple.
216

216

00:12:05.530  -->  00:12:09.400
But the answer to that one is that in
programming there's certainly incorrect
217

217

00:12:09.400  -->  00:12:12.630
answers because they have
solutions that don't work.
218

218

00:12:12.630  -->  00:12:14.430
But there's really one correct answer.
219

219

00:12:14.430  -->  00:12:16.830
So, with that said,
you have multiple options, but
220

220

00:12:16.830  -->  00:12:19.910
often there is one that is
better in a given situation.
221

221

00:12:19.910  -->  00:12:23.020
So unless you are positive that
you will never buy another album.
222

222

00:12:23.020  -->  00:12:26.340
You'd be better off using a list to store
the albums in, because of course, once
223

223

00:12:26.340  -->  00:12:30.500
you've actually allocated something in a
tuple, you can't actually change it again.
224

224

00:12:30.500  -->  00:12:31.290
So if you had a list,
225

225

00:12:31.290  -->  00:12:35.120
you could actually pin new items to
the list as you acquired new albums.
226

226

00:12:35.120  -->  00:12:37.280
Second question is,
although a tuple is immutable,
227

227

00:12:37.280  -->  00:12:41.170
what would be the status of a tuple that
contained a mutable object such as a list.
228

228

00:12:41.170  -->  00:12:45.000
So that question again is, although
a tuple is immutable, what would be
229

229

00:12:45.000  -->  00:12:49.990
the status of a tuple that contained
immutable objects, such as a list.
230

230

00:12:49.990  -->  00:12:52.120
So a tuple is immutable,
as we've established, so
231

231

00:12:52.120  -->  00:12:54.050
its contents cannot be changed.
232

232

00:12:54.050  -->  00:12:56.450
But, however,
if a tuple contained a list, for
233

233

00:12:56.450  -->  00:13:01.170
example, as one of its elements, then the
contents of the list itself can change.
234

234

00:13:01.170  -->  00:13:04.190
So to see this in action I'm gonna type
in a little bit of code just to show
235

235

00:13:04.190  -->  00:13:05.450
you what I mean.
236

236

00:13:05.450  -->  00:13:07.290
The best way to do that
is just to paste this in.
237

237

00:13:07.290  -->  00:13:09.470
I'm gonna paste all this code in.
238

238

00:13:09.470  -->  00:13:12.860
I'm gonna temporarily, I've shut down
the run window and I'm just going to
239

239

00:13:12.860  -->  00:13:16.180
comment out this code so you'll still
have it available for download.
240

240

00:13:16.180  -->  00:13:18.260
This is the answer to the second question,
241

241

00:13:18.260  -->  00:13:20.430
or it explains a little bit better,
anyway.
242

242

00:13:20.430  -->  00:13:24.360
Looking at this code you'll notice how
I've actually created a topple for
243

243

00:13:24.360  -->  00:13:27.570
each of the individual tracks,
but they're now in a list.
244

244

00:13:27.570  -->  00:13:30.010
With the square brackets
indicating it's in a list.
245

245

00:13:30.010  -->  00:13:33.240
So the contents of that mutable
list tracks has actually changed.
246

246

00:13:33.240  -->  00:13:36.350
So you can see now that we've
actually changed the immutable tuple
247

247

00:13:36.350  -->  00:13:38.540
to store the songs as a list of tuples,
248

248

00:13:38.540  -->  00:13:41.160
noting the square brackets I've
actually put around there now.
249

249

00:13:41.160  -->  00:13:44.990
So this is now a list that still
contains individual tuples.
250

250

00:13:44.990  -->  00:13:48.650
And what we can then do is, we can
actually apend, quite happily actually,
251

251

00:13:48.650  -->  00:13:51.950
a pint another track to the list
using the lists append method.
252

252

00:13:51.950  -->  00:13:55.500
You can see that their showing that on
line 26, and again you can see that in
253

253

00:13:55.500  -->  00:13:59.220
operation on line 29 where we're
actually appending an additional track.
254

254

00:13:59.220  -->  00:14:03.270
So the tuple still contains four elements,
title, artist, year, and tracks.
255

255

00:14:03.270  -->  00:14:04.740
And that hasn't changed.
256

256

00:14:04.740  -->  00:14:08.550
The contents of the immutable list track,
tracks I should say, has changed,
257

257

00:14:08.550  -->  00:14:10.880
just to run this just to
confirm it's working.
258

258

00:14:10.880  -->  00:14:11.410
There's no errors.
259

259

00:14:11.410  -->  00:14:13.040
You can see we're able to
actually get that to run.
260

260

00:14:13.040  -->  00:14:16.860
So that's an important clarification
there again, that a tuple is immutable.
261

261

00:14:16.860  -->  00:14:19.010
So its contents can't be changed.
262

262

00:14:19.010  -->  00:14:22.070
However, if a tuple contains a list,
as it did in this example that I've just
263

263

00:14:22.070  -->  00:14:26.150
showed you that the contents of
the list itself can actually change and
264

264

00:14:26.150  -->  00:14:28.130
you saw it actually working on the screen.
265

265

00:14:28.130  -->  00:14:31.930
This concept where you can actually
change a list that's within a tuple
266

266

00:14:31.930  -->  00:14:36.490
has implications later in the course when
we start looking at dictionaries and keys.
267

267

00:14:36.490  -->  00:14:38.760
It's also useful in many applications.
268

268

00:14:38.760  -->  00:14:41.420
For example if you ever
replace your vinyl collection
269

269

00:14:41.420  -->  00:14:45.970
records with CDs you might've noticed
that the CDs come with bonus tracks and
270

270

00:14:45.970  -->  00:14:47.850
now having tuple can cope with that.
271

271

00:14:47.850  -->  00:14:49.240
The way that we've actually developed it.
272

272

00:14:49.240  -->  00:14:51.040
So that's it.
That's the end of this video.
273

273

00:14:51.040  -->  00:14:52.030
I'll see you in the next video.
