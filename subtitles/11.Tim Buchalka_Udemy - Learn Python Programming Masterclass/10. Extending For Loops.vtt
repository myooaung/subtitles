WEBVTT
1
1

00:00:05.340  -->  00:00:08.890
So in the previous video, we started
talking about the for loop in Python.
2

2

00:00:08.890  -->  00:00:12.370
So let's actually continue on with that
now with a few more advanced examples.
3

3

00:00:12.370  -->  00:00:15.760
So I'm gonna actually delete the code
that we had from the previous video.
4

4

00:00:15.760  -->  00:00:21.020
And just a bit of a recap, that unlike
many other languages such as C and C++,
5

5

00:00:21.020  -->  00:00:26.390
for loops in Python work by having
a variable iterate over a set of values.
6

6

00:00:26.390  -->  00:00:31.590
So the difference is with C and C++ and
Java, for loops can be read as something
7

7

00:00:31.590  -->  00:00:37.750
along the lines of for i starting at 1
up to 20 in steps of 1, do something.
8

8

00:00:37.750  -->  00:00:40.350
If Python,
the follow-ups read more like, for
9

9

00:00:40.350  -->  00:00:43.680
i, taking each of the values in
the following sequence, do something.
10

10

00:00:43.680  -->  00:00:46.360
Now it doesn't sound like there's
a great difference with that.
11

11

00:00:46.360  -->  00:00:51.320
But the actual difference of the different
approach to for loops that Python uses,
12

12

00:00:51.320  -->  00:00:54.940
makes it really powerful, incredibly
powerful, but also very flexible.
13

13

00:00:54.940  -->  00:00:59.050
So in our example in previous video,
we wanted to show a follow with an index
14

14

00:00:59.050  -->  00:01:01.960
taking values from zero to
the length of the string.
15

15

00:01:01.960  -->  00:01:05.970
But because the string is a sequence, what
we can actually do is we can simplify that
16

16

00:01:05.970  -->  00:01:10.420
a great deal and set our loop variable to
each of the characters in the sequence.
17

17

00:01:10.420  -->  00:01:12.520
So it sort of cuts out a step there,
if you will.
18

18

00:01:12.520  -->  00:01:16.050
Now what we could do is we could leave the
variable name as i, but we'll change it to
19

19

00:01:16.050  -->  00:01:19.630
char because it's no longer being
used as an index in the string.
20

20

00:01:19.630  -->  00:01:21.610
And this will actually work better,
make more sense,
21

21

00:01:21.610  -->  00:01:23.320
if you see the code up there on top.
22

22

00:01:23.320  -->  00:01:27.020
So in this example it's also a string of
length one rather than integers sideways.
23

23

00:01:27.020  -->  00:01:28.680
So let's just have
a look at that code now.
24

24

00:01:28.680  -->  00:01:29.890
So I'm going to type that number again.
25

25

00:01:29.890  -->  00:01:34.940
So what I'll do is undo that and go just
to the first line, the first two lines,
26

26

00:01:34.940  -->  00:01:36.930
we'll keep those because we
need to clean one as well.
27

27

00:01:36.930  -->  00:01:40.050
I'll just delete this and redo it again so
it make sense as I'm typing it.
28

28

00:01:40.050  -->  00:01:46.110
So this time instead of using the len and
so forth, you know the len for the number.
29

29

00:01:46.110  -->  00:01:50.980
We can put for char in number.
30

30

00:01:50.980  -->  00:01:55.760
And what that's going to do is extract
a character that each position in that
31

31

00:01:55.760  -->  00:01:57.060
number string.
32

32

00:01:57.060  -->  00:02:05.660
And then we can put something
like if char in 0123456789 colon.
33

33

00:02:05.660  -->  00:02:07.790
If it is,
then we do the same as we did before.
34

34

00:02:07.790  -->  00:02:13.400
CleanedNumber, equals,
cleanedNumber plus char.
35

35

00:02:13.400  -->  00:02:17.240
So, again, we're not having to use that
number and the index position with the i
36

36

00:02:17.240  -->  00:02:20.760
anymore because we're actually
using the for char directly.
37

37

00:02:20.760  -->  00:02:24.060
And, again, getting back to the for
loop, your number.
38

38

00:02:25.690  -->  00:02:32.800
As it was before enter cleanedNumber,
print the number.
39

39

00:02:32.800  -->  00:02:36.930
Is the format number.
40

40

00:02:36.930  -->  00:02:39.940
We should find this works exactly
the same as it did before.
41

41

00:02:39.940  -->  00:02:41.510
Number is 92, blah, blah,
blah, blah, blah, 87.
42

42

00:02:41.510  -->  00:02:47.380
But, you notice how this has significantly
reduced the amount of code for and number.
43

43

00:02:47.380  -->  00:02:49.560
And it's actually a lot
more readable as well.
44

44

00:02:49.560  -->  00:02:51.650
We no have to use that i number anymore.
45

45

00:02:51.650  -->  00:02:55.050
And we no longer have to access each
of the characters by using number and
46

46

00:02:55.050  -->  00:02:57.040
i in square brackets
as we used previously.
47

47

00:02:57.040  -->  00:02:58.270
So, just to confirm that the for
48

48

00:02:58.270  -->  00:03:02.260
loop assigns each character in
the sequence number to a loop
49

49

00:03:02.260  -->  00:03:06.720
variable character as it's going through
each element in the actual string itself.
50

50

00:03:06.720  -->  00:03:10.060
So each time around the loop the variable
char has the value of the next character
51

51

00:03:10.060  -->  00:03:10.960
from our string number.
52

52

00:03:10.960  -->  00:03:13.880
Now, we're gonna be actually
looking at lists soon, but
53

53

00:03:13.880  -->  00:03:17.010
a list is just a sequence of
things that we can use a for
54

54

00:03:17.010  -->  00:03:20.750
loop for to iterate through them,
as in this examples.
55

55

00:03:20.750  -->  00:03:22.820
I'm actually talk some more
code to show you what I mean.
56

56

00:03:22.820  -->  00:03:29.760
So, I'm gonna put something like for,
57

57

00:03:29.760  -->  00:03:34.460
state in ["not pinin",
58

58

00:03:34.460  -->  00:03:41.420
"no more"] a stiff, bereft of life.
59

59

00:03:41.420  -->  00:03:44.120
We'll run this and then we will
just go through and talk about it.
60

60

00:03:45.390  -->  00:03:47.690
This parrot is plus state and
61

61

00:03:47.690  -->  00:03:51.660
that's opposed to doing
something like this, print.
62

62

00:03:51.660  -->  00:03:57.350
This parrot is, you could have done,
63

63

00:03:57.350  -->  00:04:00.040
.format state.
64

64

00:04:00.040  -->  00:04:02.650
Now not because our sequence was
a list of strings, you can see here.
65

65

00:04:02.650  -->  00:04:04.360
We've actually got a list of strings.
66

66

00:04:04.360  -->  00:04:09.270
So that's actually square bracket and
the list of strings separated with commas.
67

67

00:04:09.270  -->  00:04:11.140
Now, because of that,
because it's a sequence of strings,
68

68

00:04:11.140  -->  00:04:15.510
we can just state to the text
this parrot is plus state.
69

69

00:04:15.510  -->  00:04:18.080
And what it's gonna do each
time it goes through the loop,
70

70

00:04:18.080  -->  00:04:20.790
it's going to actually add one
of these to it automatically.
71

71

00:04:20.790  -->  00:04:22.460
And best way to see this
is actually run it.
72

72

00:04:23.570  -->  00:04:27.430
This parrot is, you see the first time
it went through, not that one there.
73

73

00:04:27.430  -->  00:04:30.790
The second time I went through the for
loop, is no more.
74

74

00:04:30.790  -->  00:04:35.260
This parrot, is a stiff, and
fourth this parrot is bereft of life,
75

75

00:04:35.260  -->  00:04:36.840
that's supposed to be, not lift.
76

76

00:04:36.840  -->  00:04:37.700
[LAUGH] Of life.
77

77

00:04:37.700  -->  00:04:41.230
So you can see how the for loop is
actually worked there, it's actually
78

78

00:04:41.230  -->  00:04:45.230
sort of went through the sequence
one element at a time, so to speak.
79

79

00:04:45.230  -->  00:04:48.450
And just as a confirmation
I've commented it out but
80

80

00:04:48.450  -->  00:04:52.780
we could equally put the parrot is and
use ".format(state).
81

81

00:04:52.780  -->  00:04:56.250
And it would be up to you to decide which
one you think would be more readable.
82

82

00:04:56.250  -->  00:04:59.520
My personal opinion is this one is
more readable and is basically less
83

83

00:04:59.520  -->  00:05:03.120
code as well, and just you to actually
look at the previous one and that is,
84

84

00:05:03.120  -->  00:05:08.130
okay the four state values set to each
time we go through the four loop.
85

85

00:05:08.130  -->  00:05:13.130
And speaking of for loops the range,
and we used the range previously for
86

86

00:05:13.130  -->  00:05:15.650
a for loop,
the range is also a sequence tie.
87

87

00:05:15.650  -->  00:05:19.540
It just specifies the start and end,
rather than listing all values.
88

88

00:05:19.540  -->  00:05:23.690
In other words it's like a sequence
of values, much like this, but
89

89

00:05:23.690  -->  00:05:25.390
instead of actually listing each and
all of them,
90

90

00:05:25.390  -->  00:05:28.610
we're actually listing just the start and
the end as I mentioned.
91

91

00:05:28.610  -->  00:05:31.240
In actual fact, the range is more
than a start and end value, but
92

92

00:05:31.240  -->  00:05:32.660
it can also include step.
93

93

00:05:32.660  -->  00:05:34.190
We haven't seen that before.
94

94

00:05:34.190  -->  00:05:36.430
So let's actually go through and
type that in.
95

95

00:05:36.430  -->  00:05:41.950
So we can do something
like 4 i in range 0, 100,
96

96

00:05:41.950  -->  00:05:46.960
but we can also introduce the third
parameter which is the step.
97

97

00:05:46.960  -->  00:05:49.770
And that's how much it's going
to jump in between each loop.
98

98

00:05:49.770  -->  00:05:51.280
So if we actually run this.
99

99

00:05:51.280  -->  00:05:53.940
Probably would be the easiest way to see
100

100

00:05:53.940  -->  00:05:58.760
remain.format i, so,
we actually run that now.
101

101

00:05:58.760  -->  00:06:02.060
So, you can see it's actually started on
102

102

00:06:02.060  -->  00:06:05.260
element zero which would expect because
we started on the value of zero.
103

103

00:06:05.260  -->  00:06:08.780
But, notice how it skipped to five,
and that's what this third thing here,
104

104

00:06:08.780  -->  00:06:09.720
this step value is.
105

105

00:06:09.720  -->  00:06:11.750
It means to step ahead.
106

106

00:06:11.750  -->  00:06:14.230
How many each time we go through
the loop should we had two Is.
107

107

00:06:14.230  -->  00:06:17.700
So, in other words, i zero,
the first time five, the second time 10,
108

108

00:06:17.700  -->  00:06:21.220
the third time 15 and so
on through until we got to 95.
109

109

00:06:21.220  -->  00:06:25.550
Bring them on then it goes one
less than the actual range,
110

110

00:06:25.550  -->  00:06:27.360
the ending range that we've added here.
111

111

00:06:27.360  -->  00:06:31.590
And because we're stepping in values of
five, I finished at 95 instead of 100.
112

112

00:06:31.590  -->  00:06:35.400
Now just as you've seen nesting in for
[INAUDIBLE] used, if statement and so
113

113

00:06:35.400  -->  00:06:36.970
forth to nest model ifs.
114

114

00:06:36.970  -->  00:06:38.770
We can actually nest loops as well.
115

115

00:06:38.770  -->  00:06:41.350
So we can actually nest a for
loop within another loop,
116

116

00:06:41.350  -->  00:06:44.110
and that's a really powerful
way to process data.
117

117

00:06:44.110  -->  00:06:47.380
So here's an example of how we can
generate the times table used to teach
118

118

00:06:47.380  -->  00:06:49.030
children multiplication.
119

119

00:06:49.030  -->  00:06:51.490
So we can put for i.
120

120

00:06:51.490  -->  00:06:53.470
Don't forget,
making sure we're starting to the left,
121

121

00:06:53.470  -->  00:06:56.360
so we're not getting caught
up in any previous code.
122

122

00:06:56.360  -->  00:06:59.180
For i in range.
123

123

00:06:59.180  -->  00:07:05.180
Should be i range 1,13, and
obviously that's gonna go and
124

124

00:07:05.180  -->  00:07:09.500
give us, go through 1 and 12, 1 to 12.
125

125

00:07:09.500  -->  00:07:16.130
And for j in range 1 to 13 as well.
126

126

00:07:17.240  -->  00:07:19.090
And then we can do print.
127

127

00:07:19.090  -->  00:07:25.640
Times zero is two .format, and
128

128

00:07:25.640  -->  00:07:31.700
it's gonna be i j, i times j.
129

129

00:07:32.720  -->  00:07:33.730
And then we can go print.
130

130

00:07:33.730  -->  00:07:36.150
We can actually put a spacer
131

131

00:07:36.150  -->  00:07:39.690
between each major number that we're
actually going through and processing.
132

132

00:07:39.690  -->  00:07:43.060
So if I actually run that,
you can see what it's actually done there.
133

133

00:07:43.060  -->  00:07:44.040
Scrolling back up to the top.
134

134

00:07:44.040  -->  00:07:46.860
We start on the one times table,
one times one is one.
135

135

00:07:46.860  -->  00:07:47.810
Two times one is two.
136

136

00:07:47.810  -->  00:07:49.280
And so on right to 12.
137

137

00:07:49.280  -->  00:07:52.450
Then we start at the two times table and
three times table, and
138

138

00:07:52.450  -->  00:07:55.290
right through until we got to the last
part which was a 12 times table.
139

139

00:07:55.290  -->  00:07:57.320
12 times 12 is 144.
140

140

00:07:57.320  -->  00:08:01.680
And you can see how that was created
with only a minimal amount of code, and
141

141

00:08:01.680  -->  00:08:06.530
that also the indent level again is really
important here because if we put print in
142

142

00:08:06.530  -->  00:08:11.210
the wrong spot, actually print it
up in there to that level instead.
143

143

00:08:11.210  -->  00:08:13.010
We get a completely different result.
144

144

00:08:13.010  -->  00:08:17.490
We actually get the equal signs with each
time we've actually done a calculation.
145

145

00:08:17.490  -->  00:08:20.770
So, again, make sure you do watch your
indent levels to make sure they're
146

146

00:08:20.770  -->  00:08:23.610
actually in the right spot when
you're actually processing your code.
147

147

00:08:23.610  -->  00:08:26.170
And just another thing we can do
here just before we end the video.
148

148

00:08:26.170  -->  00:08:29.820
We can actually change the print
function's n character for a tab.
149

149

00:08:29.820  -->  00:08:32.370
And once we do that we can actually
produce a pretty neat table.
150

150

00:08:32.370  -->  00:08:37.880
So, we can come back up here to print and
put end equals slash t and
151

151

00:08:37.880  -->  00:08:41.470
put a comma there as
well to make it valid.
152

152

00:08:41.470  -->  00:08:44.200
And now you can actually run that you
can see we have something completely
153

153

00:08:44.200  -->  00:08:46.590
different, and we're actually
going from left to right now.
154

154

00:08:46.590  -->  00:08:49.370
And we just make this a little bit
wider it will probably make more sense.
155

155

00:08:51.140  -->  00:08:53.130
And that would just be a way
to actually expand it out.
156

156

00:08:53.130  -->  00:08:55.830
And actually I've got the equals sign
probably shouldn't be there now with
157

157

00:08:55.830  -->  00:08:56.380
this example.
158

158

00:08:56.380  -->  00:08:58.190
So I'm just gonna comment those out.
159

159

00:08:58.190  -->  00:09:00.460
We run this again.
160

160

00:09:00.460  -->  00:09:01.950
And we're going from left to right now.
161

161

00:09:01.950  -->  00:09:04.970
You can see 1 times 1 is 1,
2 times 1 is 2.
162

162

00:09:04.970  -->  00:09:06.670
We're going right across from left right.
163

163

00:09:06.670  -->  00:09:08.190
And just to pretty it
up a little bit more,
164

164

00:09:08.190  -->  00:09:12.650
what we could also do then is
here on this indent level.
165

165

00:09:12.650  -->  00:09:13.400
Let's actually print.
166

166

00:09:13.400  -->  00:09:15.390
Let's go to a new line at this point,
just so
167

167

00:09:15.390  -->  00:09:19.100
it actually reads a little bit nicer for
each time we change the number.
168

168

00:09:19.100  -->  00:09:20.940
We'll just print an empty string like so.
169

169

00:09:20.940  -->  00:09:25.030
So now if we run that, you see we're
going to for each times table now, and
170

170

00:09:25.030  -->  00:09:26.130
it's looking a little bit more order.
171

171

00:09:26.130  -->  00:09:27.380
So it's just another
way to actually try and
172

172

00:09:27.380  -->  00:09:30.200
sort things from left to right,
just close it.
173

173

00:09:30.200  -->  00:09:32.910
Run down, window down, so and again,
we have to print an empty string
174

174

00:09:32.910  -->  00:09:37.900
after the inner loop terminates in order
to start each new set of on a new line.
175

175

00:09:37.900  -->  00:09:40.190
And notice we didn't have to
specify a character for end.
176

176

00:09:40.190  -->  00:09:41.380
It goes back to being a new line.
177

177

00:09:41.380  -->  00:09:44.390
The change to a tab is not remembered
from one print call to another.
178

178

00:09:44.390  -->  00:09:48.630
So, in other words, doing this here is
not remembered when we get to this stage.
179

179

00:09:48.630  -->  00:09:49.820
That doesn't override that.
180

180

00:09:49.820  -->  00:09:52.860
Sort of, each time you use your print
statement it doesn't remember anything
181

181

00:09:52.860  -->  00:09:54.180
from the previous one.
182

182

00:09:54.180  -->  00:09:55.570
Okay, so that's actually it.
183

183

00:09:55.570  -->  00:09:57.590
So we're going to end this video here now.
184

184

00:09:57.590  -->  00:09:59.970
We're not going to actually do
a challenge for the for loop.
185

185

00:09:59.970  -->  00:10:03.280
But believe me you'll get plenty of time
to actually complete some challenges.
186

186

00:10:03.280  -->  00:10:05.890
So in the next video we're going to
actually start talking about the continue
187

187

00:10:05.890  -->  00:10:08.740
and break commands which actually
work hand in hand with what
188

188

00:10:08.740  -->  00:10:11.570
you've been learning in
this section of the course.
189

189

00:10:11.570  -->  00:10:12.830
So I'll see you in the next video.
