WEBVTT
1
1

00:00:04.600  -->  00:00:07.600
So, now it's time to talk about tuples.
2

2

00:00:07.600  -->  00:00:11.640
And what tuples are is a term for
an ordered set of data.
3

3

00:00:11.640  -->  00:00:15.730
Now, in Python, tuples are similar to
lists which we've already talked about.
4

4

00:00:15.730  -->  00:00:18.690
But the difference here is
that they're immutable.
5

5

00:00:18.690  -->  00:00:21.010
And what that means is
they can't be changed.
6

6

00:00:21.010  -->  00:00:21.510
So, in other words,
7

7

00:00:21.510  -->  00:00:25.070
attempting to append an item to a tuple
will actually give you an error.
8

8

00:00:25.070  -->  00:00:28.010
Now, you might have read
that definition stated that
9

9

00:00:28.010  -->  00:00:31.860
lists are enclosed in square brackets,
and that's true, and you've seen that.
10

10

00:00:31.860  -->  00:00:35.530
And that tuples are enclosed in
parentheses, but that is not true.
11

11

00:00:35.530  -->  00:00:38.240
So, a comma is used to separate
the elements of a tuple, but
12

12

00:00:38.240  -->  00:00:43.030
the parentheses are only required when
necessary to remove syntactic ambiguity.
13

13

00:00:43.030  -->  00:00:44.670
So, I'm gonna show you
an example of what I mean.
14

14

00:00:44.670  -->  00:00:49.760
I can put my space here.
15

15

00:00:49.760  -->  00:00:55.240
So I'm gonna type t = "a", "b", "c",
16

16

00:00:55.240  -->  00:01:02.180
print(t) print("a", "b",
17

17

00:01:02.180  -->  00:01:07.710
"c") print A.
18

18

00:01:07.710  -->  00:01:08.210
B.
C.
19

19

00:01:11.800  -->  00:01:16.680
So, if we actually run that,
if you've seen the first example,
20

20

00:01:16.680  -->  00:01:21.200
the answer is returned in brackets, and
that signifies that it is a double, and
21

21

00:01:21.200  -->  00:01:24.790
also the third example Shows
that it's a tuple as well and
22

22

00:01:24.790  -->  00:01:28.660
you can see why the second
example the one on line four.
23

23

00:01:28.660  -->  00:01:33.460
That's actually just returned the letters
a, b, c and that's an example of having to
24

24

00:01:33.460  -->  00:01:38.620
use parentheses to actually
avoid syntactic ambiguity.
25

25

00:01:38.620  -->  00:01:42.140
So, in other words print will also
accept parameters followed by a comma.
26

26

00:01:42.140  -->  00:01:45.420
So, if you do want to print out a tuple
then you'd need to actually put brackets
27

27

00:01:45.420  -->  00:01:47.130
there as an example.
28

28

00:01:47.130  -->  00:01:51.100
So, this also applies when you're actually
passing a tuple tool function and
29

29

00:01:51.100  -->  00:01:54.900
as we've seen earlier enclosing an
expression in parentheses allows it to be
30

30

00:01:54.900  -->  00:01:58.840
split over several lines without
using line continuation characters.
31

31

00:01:58.840  -->  00:02:02.160
So, sometimes enclose our tuples
in them as well for that reason.
32

32

00:02:02.160  -->  00:02:04.320
Now, you might prefer to always do so,
and that's fine.
33

33

00:02:04.320  -->  00:02:08.510
Just be aware that if you come across
code that does not use parenthesis,
34

34

00:02:08.510  -->  00:02:10.140
then you'll need to
understand what that is.
35

35

00:02:10.140  -->  00:02:11.190
So, it's up to you.
36

36

00:02:11.190  -->  00:02:13.610
Probably what I would
recommend is to actually
37

37

00:02:13.610  -->  00:02:17.400
use brackets as much as possible
like this when creating a tuple.
38

38

00:02:17.400  -->  00:02:20.660
Again, we're gonna go through a bit
more about what tuples are as we go
39

39

00:02:20.660  -->  00:02:24.380
through this video but the choice is
up to you and you will see examples.
40

40

00:02:24.380  -->  00:02:28.140
Like the example I started with, like this
example here, where they're not enclosed
41

41

00:02:28.140  -->  00:02:31.520
in parentheses but they're still actually
tuples and you need to be aware of that.
42

42

00:02:31.520  -->  00:02:33.740
Before I continue And this is a digress.
43

43

00:02:33.740  -->  00:02:35.980
What I want to do, we haven't
actually mentioned this before, but
44

44

00:02:35.980  -->  00:02:40.160
you can also pass a comma separated
list of items to the print function, and
45

45

00:02:40.160  -->  00:02:41.770
it'll print them all on the same line.
46

46

00:02:41.770  -->  00:02:45.320
And what I mean by that, we're going to
actually type some code in to show you.
47

47

00:02:46.780  -->  00:02:48.030
Let me comment out this code for now.
48

48

00:02:49.260  -->  00:02:51.110
So, let's start by creating some tuples.
49

49

00:02:51.110  -->  00:02:55.090
So, first one is welcome = "Welcome to my
50

50

00:02:55.090  -->  00:03:00.070
Nightmare" Alice Cooper, 1975.
51

51

00:03:00.070  -->  00:03:02.400
This is a tuple.
52

52

00:03:02.400  -->  00:03:04.590
Now, notice how it's
a different type on the end.
53

53

00:03:06.260  -->  00:03:09.630
Oops, I've got my equals and
so forth done correctly.
54

54

00:03:09.630  -->  00:03:11.370
And notice how you can have, actually,
55

55

00:03:11.370  -->  00:03:13.710
different data types on
the one line with the tuple.
56

56

00:03:13.710  -->  00:03:18.860
And we'll do something like this,
57

57

00:03:18.860  -->  00:03:25.560
bad equals "Bad Company" "Bad Company",
58

58

00:03:25.560  -->  00:03:30.220
1974 budgie = Nightflight
59

59

00:03:34.760  -->  00:03:39.770
1981 and Imelda
60

60

00:03:39.770  -->  00:03:44.490
[SOUND] 2011 and
61

61

00:03:44.490  -->  00:03:52.470
Metallica Ride the Lightning.
62

62

00:03:57.340  -->  00:03:59.300
1984.
63

63

00:03:59.300  -->  00:04:04.500
So, we can actually
print Metallica like so.
64

64

00:04:04.500  -->  00:04:06.020
We can actually run that.
65

65

00:04:06.020  -->  00:04:11.570
And you can see when we just print it it
actually prints out the entire topple.
66

66

00:04:11.570  -->  00:04:18.880
But, we can also do print
Metallica[0] in square brackets.
67

67

00:04:18.880  -->  00:04:19.400
And we run that.
68

68

00:04:19.400  -->  00:04:22.930
And surprisingly,
we get the first element.
69

69

00:04:22.930  -->  00:04:24.380
And we can also do the same for
the other two.
70

70

00:04:24.380  -->  00:04:25.350
We can print those separately.
71

71

00:04:25.350  -->  00:04:30.110
So, we can go like so, 1, and
let's put that on a new line, 2.
72

72

00:04:30.110  -->  00:04:33.510
And we run that.
73

73

00:04:33.510  -->  00:04:35.710
We get the other elements
printing them individually.
74

74

00:04:35.710  -->  00:04:37.950
But the point I want to make,
as I mentioned at the start of the video,
75

75

00:04:37.950  -->  00:04:39.780
is that tupples are immutable.
76

76

00:04:39.780  -->  00:04:41.640
So, any attempt to change them,
77

77

00:04:41.640  -->  00:04:45.400
in this case a Metallica album to say
Master of Puppets, would give an error.
78

78

00:04:45.400  -->  00:04:48.280
So, we can actually do
something like that.
79

79

00:04:48.280  -->  00:04:53.380
We can try typing metallica[0],
element 0, = "Master of Puppets".
80

80

00:04:54.560  -->  00:04:55.740
If we actually run that,
81

81

00:04:55.740  -->  00:05:01.390
we actually get an error, tuple object
does not support item assignment.
82

82

00:05:01.390  -->  00:05:04.320
So, you can't actually
change it in that fashion.
83

83

00:05:04.320  -->  00:05:07.080
Now, the good thing now is tuples
actually support indexing and
84

84

00:05:07.080  -->  00:05:12.220
slicing, which is sort of a sneaky way
of actually correcting any problems or
85

85

00:05:12.220  -->  00:05:14.370
updating particular entries.
86

86

00:05:14.370  -->  00:05:17.030
So, for example,
I made a typo on line nine.
87

87

00:05:17.030  -->  00:05:18.390
With the actual name, Imelda Mae.
88

88

00:05:18.390  -->  00:05:21.970
So, if I've got to change that
I can actually type something
89

89

00:05:21.970  -->  00:05:24.310
like imelda equals imelda.
90

90

00:05:24.310  -->  00:05:25.760
And we can put 0.
91

91

00:05:31.470  -->  00:05:35.730
If we actually run that, unless you
print that out afterwards, print imelda,
92

92

00:05:35.730  -->  00:05:38.040
just to make sure it's actually working.
93

93

00:05:38.040  -->  00:05:38.960
So, if I actually run that,
94

94

00:05:40.140  -->  00:05:42.470
actually what we want to do is get
rid of this error line first now.
95

95

00:05:42.470  -->  00:05:43.740
So, that that code actually executes.
96

96

00:05:43.740  -->  00:05:46.400
So, I'll comment that out, run that again.
97

97

00:05:46.400  -->  00:05:48.840
We actually get more my hand,
Emilda May this time,
98

98

00:05:48.840  -->  00:05:51.680
remembering that initially I
actually put it through incorrectly.
99

99

00:05:51.680  -->  00:05:53.660
It's Emilda, with an E on the start.
100

100

00:05:53.660  -->  00:05:56.470
So, I've actually got the values
correctly added to the, or
101

101

00:05:56.470  -->  00:05:59.140
updated I should say in
the middle of the tuple.
102

102

00:05:59.140  -->  00:06:00.840
So actually there's two
important concepts here.
103

103

00:06:00.840  -->  00:06:05.240
Firstly, a type being immutable means that
you can't change the contents of an object
104

104

00:06:05.240  -->  00:06:06.930
once you've created it.
105

105

00:06:06.930  -->  00:06:10.700
But, it doesn't mean that your
variable Can't be assigned
106

106

00:06:10.700  -->  00:06:14.440
a new object of that type, so
that's an important clarification here.
107

107

00:06:14.440  -->  00:06:18.150
So, just to confirm the differences
between a immutable object,
108

108

00:06:18.150  -->  00:06:20.370
an mutable one,
an mutable one being changeable,
109

109

00:06:20.370  -->  00:06:23.840
immutable meaning you can't change
consider this current I'm going to add.
110

110

00:06:23.840  -->  00:06:29.570
So we are going to create a new
111

111

00:06:29.570  -->  00:06:34.590
one metallic2 equals,
112

112

00:06:34.590  -->  00:06:40.330
and I'm creating a list this
113

113

00:06:40.330  -->  00:06:45.350
time instead of a tuple,
114

114

00:06:45.350  -->  00:06:51.560
lightning [NOISE] Teleca two And
115

115

00:06:51.560  -->  00:06:55.880
print metallica2.
116

116

00:06:55.880  -->  00:06:59.260
So, we've created a list there,
just to show you the differences.
117

117

00:06:59.260  -->  00:07:03.540
So, course in the case of the list, that
should be metalica2 there, because I'm
118

118

00:07:03.540  -->  00:07:06.900
updating the list here, in this
particular group of code, block of code.
119

119

00:07:06.900  -->  00:07:07.650
Run that again.
120

120

00:07:07.650  -->  00:07:12.500
So, in the case of lines 21 to 24,
we're working with a list.
121

121

00:07:12.500  -->  00:07:16.860
And you can see that I was able to
directly change the element zero,
122

122

00:07:16.860  -->  00:07:20.060
the album name, and
it worked quite Quite nicely.
123

123

00:07:20.060  -->  00:07:23.610
But of course in the case above when
this error are here when I actually
124

124

00:07:23.610  -->  00:07:27.670
ran that code Which it got an error and
we couldn't actually update it that way.
125

125

00:07:27.670  -->  00:07:29.490
Because it's an immutable object.
126

126

00:07:29.490  -->  00:07:31.460
So, again tuple immutable object.
127

127

00:07:31.460  -->  00:07:32.340
A list is a.
128

128

00:07:32.340  -->  00:07:37.310
Object, but you can see also that in terms
of tuples we were able to get around it
129

129

00:07:37.310  -->  00:07:41.100
by actually assigning new
objects to that variable.
130

130

00:07:41.100  -->  00:07:45.470
So, in this case Imelda had the initial
value set here for the tuple.
131

131

00:07:45.470  -->  00:07:49.260
They were able to actually recreate it and
that works quite nicely.
132

132

00:07:49.260  -->  00:07:52.210
You'll find that the term immutable
works in a lot of languages
133

133

00:07:53.290  -->  00:07:55.960
you can't change the existing contents,
but
134

134

00:07:55.960  -->  00:07:58.640
you can actually reference it or
to a new object of that type.
135

135

00:07:58.640  -->  00:08:03.380
Now, the second thing that might be
obvious, but it is important for
136

136

00:08:03.380  -->  00:08:04.630
me to actually point out.
137

137

00:08:04.630  -->  00:08:07.900
Is that expressions on the right
hand side of an assignment
138

138

00:08:07.900  -->  00:08:10.710
are always evaluated
before the left hand side.
139

139

00:08:10.710  -->  00:08:12.710
So, in the imelda example above,
140

140

00:08:12.710  -->  00:08:15.980
we're taking the first element
of the count imelda objects.
141

141

00:08:15.980  -->  00:08:19.070
I'm talking about this line here, line 18.
142

142

00:08:19.070  -->  00:08:21.630
So, we're taking the first element
of the current IMELDA object
143

143

00:08:21.630  -->  00:08:25.460
which of course indicts 0 plus
the string IMELDA may correctly
144

144

00:08:25.460  -->  00:08:29.660
typed as I-M-E-L-D-A
instead on E-M-I-L-D-A.
145

145

00:08:29.660  -->  00:08:33.010
Followed by the third element of
the current IMELDA to produce a new tuple.
146

146

00:08:33.010  -->  00:08:35.970
So, you can see that it's
actually This would only work if
147

147

00:08:35.970  -->  00:08:40.670
the computer was actually evaluating this
right hand side of the expression first.
148

148

00:08:40.670  -->  00:08:43.130
If it started evaluating
the left hand side first,
149

149

00:08:43.130  -->  00:08:46.000
then of course this imelda object
would already have been updated.
150

150

00:08:46.000  -->  00:08:48.270
So again,
it's looking at these values first and
151

151

00:08:48.270  -->  00:08:51.450
assigning those before ultimately
looking at the left hand side.
152

152

00:08:51.450  -->  00:08:53.630
To see where these objects
are going to actually be saved.
153

153

00:08:53.630  -->  00:08:57.150
S,o in this case the new tupple was
then assigned to the value mild or
154

154

00:08:57.150  -->  00:08:59.640
after that and
it replaces the previous object.
155

155

00:08:59.640  -->  00:09:02.230
So, it's not the variable
that is immutable, but
156

156

00:09:02.230  -->  00:09:06.270
it's the object that the variable
Imelda in this case points to.
157

157

00:09:06.270  -->  00:09:09.700
So we haven't changed the contents
of the tupple object.
158

158

00:09:09.700  -->  00:09:13.450
What we actually did here on line
18 is we created a new tupple.
159

159

00:09:13.450  -->  00:09:16.240
And then pointed the variable and
the order to reference it.
160

160

00:09:16.240  -->  00:09:19.450
And again, because the right
hand side is evaluated first,
161

161

00:09:19.450  -->  00:09:23.170
the current contents of an order can
be used to create the new topple before
162

162

00:09:23.170  -->  00:09:25.320
the assignment and
that's why line 18 actually worked.
163

163

00:09:25.320  -->  00:09:27.870
And probably about now
you're starting to wonder,
164

164

00:09:27.870  -->  00:09:30.720
well Why would I actually
be using a tuple?
165

165

00:09:30.720  -->  00:09:33.040
What's the advantages of
using tuple over a list?
166

166

00:09:33.040  -->  00:09:36.830
Because at first glance, you might look at
it and think that lists seem more useful.
167

167

00:09:36.830  -->  00:09:40.830
And while it's actually true that you can
generally use a list in place of a tuple,
168

168

00:09:40.830  -->  00:09:44.650
there's some important reasons why
you'd wanna favor tuples over lists.
169

169

00:09:44.650  -->  00:09:48.580
And then we haven't actually covered
hashes or dictionaries yet in the course.
170

170

00:09:48.580  -->  00:09:51.580
But a dictionary key requires
immutable object, and
171

171

00:09:51.580  -->  00:09:54.450
that removes the choice if you wanna
use your object as a dictionary key.
172

172

00:09:54.450  -->  00:09:56.310
But, you'll be finding out
more about that later.
173

173

00:09:56.310  -->  00:10:00.490
But another key difference, is that a list
is intended, although it's not enforced,
174

174

00:10:00.490  -->  00:10:02.470
to contain items of the same type.
175

175

00:10:02.470  -->  00:10:03.900
Much like a real world list.
176

176

00:10:03.900  -->  00:10:06.660
So, you wouldn't add an activity such
as sky diving to a shopping list,
177

177

00:10:06.660  -->  00:10:07.620
for example.
178

178

00:10:07.620  -->  00:10:10.090
The computing temp of this is homogenous.
179

179

00:10:10.090  -->  00:10:13.890
So, in other words the list have
intended to hold homogenous items.
180

180

00:10:13.890  -->  00:10:16.460
In other words,
meaning items of the same type.
181

181

00:10:16.460  -->  00:10:19.900
So, tuples are actually intended
to hold heterogeneous items.
182

182

00:10:19.900  -->  00:10:23.250
So, like our albums example where we
were storing three different things in
183

183

00:10:23.250  -->  00:10:24.030
each tuple.
184

184

00:10:24.030  -->  00:10:25.580
An album title, artist name, and
185

185

00:10:25.580  -->  00:10:28.420
a year, which you can see that with
different types on lines 6 through 10.
186

186

00:10:28.420  -->  00:10:33.080
Now, the other things to keep in mind is
the protection offered by using a tuple.
187

187

00:10:33.080  -->  00:10:35.760
The things that should not
change can actually help prevent
188

188

00:10:35.760  -->  00:10:37.010
bugs in your programs.
189

189

00:10:37.010  -->  00:10:40.560
So, in other words, once an album is
released, its details do not change.
190

190

00:10:40.560  -->  00:10:43.660
Prince and the Sensational Alex
Harvey Band, notwithstanding.
191

191

00:10:43.660  -->  00:10:46.520
So, it actually makes sense to
store the details in a tuple.
192

192

00:10:46.520  -->  00:10:49.630
Because of course they're fixed items,
which should never change.
193

193

00:10:49.630  -->  00:10:52.770
So, if your code then attempts to
change one of the fields in the tuple,
194

194

00:10:52.770  -->  00:10:55.280
the attempt is gonna fail and
you saw the error earlier in the video.
195

195

00:10:55.280  -->  00:10:58.960
When I actually tried to do that,
on line 17 which is now commented out.
196

196

00:10:58.960  -->  00:10:59.810
So, that it will file, and
197

197

00:10:59.810  -->  00:11:02.960
it will actually highlight something that
your code probably shouldn't be doing.
198

198

00:11:02.960  -->  00:11:04.790
So, it's really good
from that point of view,
199

199

00:11:04.790  -->  00:11:08.750
to use a tuple in that way to avoid
getting into difficulties later.
200

200

00:11:08.750  -->  00:11:10.640
So, one example of that
might be an adventure game.
201

201

00:11:10.640  -->  00:11:14.080
So the layout of your game, the various
rooms and the links between them will be
202

202

00:11:14.080  -->  00:11:17.910
fixed throughout the game's, Even if all
exits are not immediately available to
203

203

00:11:17.910  -->  00:11:21.100
the players, so you would actually store
that or could store that in tuples.
204

204

00:11:21.100  -->  00:11:23.990
The players can change though
as they gain hit points and
205

205

00:11:23.990  -->  00:11:27.700
take damage through the game, so a tuple
wouldn't be appropriate in this case for
206

206

00:11:27.700  -->  00:11:29.730
example to storing player details.
207

207

00:11:29.730  -->  00:11:32.770
So, we're going to digress slightly now
and show another way to assign values to
208

208

00:11:32.770  -->  00:11:35.090
variables that we haven't
discussed earlier.
209

209

00:11:35.090  -->  00:11:37.180
So, what I'm gonna do is
create a new pathing file for
210

210

00:11:37.180  -->  00:11:39.710
this example because we're gonna be
coming back to this tuples.py shortly.
211

211

00:11:39.710  -->  00:11:42.950
So, I'm just gonna come up here,
as I've done throughout the course,
212

212

00:11:42.950  -->  00:11:46.100
and I'm just gonna call this one demo but
you can call it whatever you'd like.
213

213

00:11:47.410  -->  00:11:51.040
And close down the run window for now,
and I'll just delete that first line.
214

214

00:11:51.040  -->  00:11:54.090
So, in Python it's possible to assign
values to several variables at
215

215

00:11:54.090  -->  00:11:54.640
the same time.
216

216

00:11:54.640  -->  00:11:58.500
And here's an example of setting
four variables to the same value.
217

217

00:11:58.500  -->  00:12:01.100
So, we can put a = b = c = d = 12.
218

218

00:12:01.100  -->  00:12:06.770
And if we print c, for
example, and run that.
219

219

00:12:08.200  -->  00:12:09.420
And see, we got the answer, 12.
220

220

00:12:09.420  -->  00:12:13.050
So in that case, all four variables
were assigned the value of 12.
221

221

00:12:13.050  -->  00:12:16.420
But we can also assign different
values to multiple variables.
222

222

00:12:16.420  -->  00:12:21.090
So, another example might be A,
B equals 12, 13.
223

223

00:12:21.090  -->  00:12:25.220
We could print A, B.
224

224

00:12:27.340  -->  00:12:31.410
You can see, in that case, line three,
a's been assigned the value 12,
225

225

00:12:31.410  -->  00:12:32.520
b's been assigned the value 13.
226

226

00:12:32.520  -->  00:12:36.340
So, once again, remember that the right
hand side is evaluated first.
227

227

00:12:36.340  -->  00:12:38.970
So, just clarify that,
I can do something like this.
228

228

00:12:38.970  -->  00:12:44.540
I can type So we've got a and b defined as
12, 13, and we've printed the values out.
229

229

00:12:44.540  -->  00:12:47.570
We can do something like a, b = b, a.
230

230

00:12:47.570  -->  00:12:52.930
Then we could do print(a is
231

231

00:12:59.920  -->  00:13:02.970
.Formata.
232

232

00:13:02.970  -->  00:13:04.170
We're gonna do the same for b.
233

233

00:13:08.760  -->  00:13:14.660
We can run that, and we can see there
we've got the a have been assigned to 13,
234

234

00:13:14.660  -->  00:13:17.760
and b has been assigned the value of 12.
235

235

00:13:17.760  -->  00:13:21.270
And again, the value for that, the reason
that that's working is the right-hand
236

236

00:13:21.270  -->  00:13:26.140
assignment is actually calculated,
or evaluated I should say first.
237

237

00:13:26.140  -->  00:13:29.430
Now, looking at line 3,
it looks suspiciously like a tupple.
238

238

00:13:29.430  -->  00:13:31.730
Considering what we've
learned in this session.
239

239

00:13:31.730  -->  00:13:34.770
And that means that we can actually
pull out all the elements of a tuple in
240

240

00:13:34.770  -->  00:13:35.760
a single assignment.
241

241

00:13:35.760  -->  00:13:37.640
Please go back to the albums Python now.
242

242

00:13:37.640  -->  00:13:40.020
And we'll just delete a bit of this code.
243

243

00:13:40.020  -->  00:13:41.580
And we'll fix this tuple up here.
244

244

00:13:41.580  -->  00:13:44.930
And delete that.
245

245

00:13:44.930  -->  00:13:48.050
And metallica2 I'm gonna
leave as a list there.
246

246

00:13:48.050  -->  00:13:50.360
We're gonna print out
part two if it down here.
247

247

00:13:50.360  -->  00:13:52.900
This is the example, we can type title.
248

248

00:13:52.900  -->  00:13:59.170
Artist, year, equals Imelda.
249

249

00:13:59.170  -->  00:14:02.020
Print title.
250

250

00:14:02.020  -->  00:14:05.160
Print artist.
251

251

00:14:05.160  -->  00:14:07.740
Print year.
252

252

00:14:07.740  -->  00:14:09.010
We actually now run this code.
253

253

00:14:10.550  -->  00:14:11.940
Run titles.
254

254

00:14:11.940  -->  00:14:15.040
We get the actual, press the print
of the list, which we've left in.
255

255

00:14:15.040  -->  00:14:18.600
But notice how now that we've
extracted the valleys out of the total
256

256

00:14:18.600  -->  00:14:23.090
into individual variables using the common
syntax that I've just shown you.
257

257

00:14:23.090  -->  00:14:24.670
So, there is actually a term for that.
258

258

00:14:24.670  -->  00:14:27.040
It's actually called unpacking the tupple.
259

259

00:14:27.040  -->  00:14:30.550
And just incidentally in this case, where
you've got more than one file open, if you
260

260

00:14:30.550  -->  00:14:33.550
are ever in doubt as to which one is gonna
run, come up here to the top right-hand
261

261

00:14:33.550  -->  00:14:36.930
corner, and you can actually choose
which file you actually want to run.
262

262

00:14:36.930  -->  00:14:40.760
For example, I can choose demo and
it will actually run demo.
263

263

00:14:40.760  -->  00:14:41.920
And run the code for this file.
264

264

00:14:41.920  -->  00:14:46.610
But, equally I could come back here and
select topples and actually run that code.
265

265

00:14:46.610  -->  00:14:49.870
So, another alternative of course is just
to right click the relevant file and
266

266

00:14:49.870  -->  00:14:50.670
actually run it.
267

267

00:14:50.670  -->  00:14:52.590
So, we've just touched
on unpacking the topple.
268

268

00:14:52.590  -->  00:14:53.850
Gonna end the video here, and
269

269

00:14:53.850  -->  00:14:56.060
we'll actually talk more
about this in the next video.
