WEBVTT
1
1

00:00:05.300  -->  00:00:06.180
So in the previous video,
2

2

00:00:06.180  -->  00:00:10.020
we stored some strings in variables but we
didn't really explain what was going on.
3

3

00:00:10.020  -->  00:00:10.930
So we wanna go through and
4

4

00:00:10.930  -->  00:00:14.680
actually explain what is happening
a little bit more now behind the scenes.
5

5

00:00:14.680  -->  00:00:16.500
So when the Python programming is running,
6

6

00:00:16.500  -->  00:00:20.340
everything the program needs ends up being
stored somewhere in the computer's memory.
7

7

00:00:20.340  -->  00:00:23.010
You don't actually need to know
where that is because the computer
8

8

00:00:23.010  -->  00:00:23.870
actually tracks that.
9

9

00:00:23.870  -->  00:00:27.750
For the program code itself, in other
words the instructions that you type in,
10

10

00:00:27.750  -->  00:00:31.640
will be stored in one area of memory, but
also the data that it's gonna work on,
11

11

00:00:31.640  -->  00:00:36.140
the variables that you've typed in etc.,
will be stored somewhere else in memory.
12

12

00:00:36.140  -->  00:00:37.130
So the variable,
13

13

00:00:37.130  -->  00:00:40.900
the name that we assigned is just really
a way to give a meaningful name to
14

14

00:00:40.900  -->  00:00:45.410
a area of memory into which we can place
certain values like strings and so forth.
15

15

00:00:45.410  -->  00:00:50.050
So when we create a variable called
greeting like greeting = Bruce.
16

16

00:00:51.340  -->  00:00:55.220
Python's actually allocating an area
of computer memory for us, and
17

17

00:00:55.220  -->  00:00:58.900
it knows to refer to that area whenever
we talk about the variable greeting.
18

18

00:00:58.900  -->  00:01:03.230
So think of it like a box in memory that's
storing the values, Bruce in this case,
19

19

00:01:03.230  -->  00:01:06.470
and the box has got a name on,
a sticker on it that says greeting.
20

20

00:01:06.470  -->  00:01:09.440
And when we type in greeting,
the computer knows to go and
21

21

00:01:09.440  -->  00:01:11.760
find the value that's
in that particular box.
22

22

00:01:11.760  -->  00:01:14.400
So that all happens
automatically behind the scenes.
23

23

00:01:14.400  -->  00:01:17.610
Just in terms of creating
these variable names,
24

24

00:01:17.610  -->  00:01:20.750
there are a few rules to keep in
mind when you actually created them.
25

25

00:01:20.750  -->  00:01:24.880
Firstly, the actual name has to start with
either a letter, it could be upper or
26

26

00:01:24.880  -->  00:01:27.160
lower case, or an underscore.
27

27

00:01:27.160  -->  00:01:33.270
So in other words,
we can type _myName = Tim, that's valid.
28

28

00:01:33.270  -->  00:01:36.150
So a variable name can start with
either the letter or an underscore but
29

29

00:01:36.150  -->  00:01:37.430
we can't start with a number.
30

30

00:01:40.530  -->  00:01:41.700
Actually get an error.
31

31

00:01:41.700  -->  00:01:44.870
But we can actually also use letters.
32

32

00:01:44.870  -->  00:01:47.810
We can also use numbers in our variable
names, just not as the first letter.
33

33

00:01:47.810  -->  00:01:50.510
So, we can put something
like Tim45 = Good.
34

34

00:01:50.510  -->  00:01:53.650
That's quite valid and
we could put a combination.
35

35

00:01:53.650  -->  00:01:59.110
So we could put Tim_Was_57 = Hello and
36

36

00:01:59.110  -->  00:02:02.910
that's quite valid as well.
37

37

00:02:02.910  -->  00:02:05.780
Now the other important thing to
consider here is that I could also
38

38

00:02:05.780  -->  00:02:08.750
type a variable name called Greeting,
with uppercase G.
39

39

00:02:08.750  -->  00:02:13.560
And that's different and
distinct to this variable name.
40

40

00:02:13.560  -->  00:02:16.870
So that one's all in lowercase,
this one's got an uppercase first letter.
41

41

00:02:16.870  -->  00:02:18.540
Even though the actual word is the same,
42

42

00:02:18.540  -->  00:02:23.630
they are treated as different variable
names as far as Python is concerned.
43

43

00:02:23.630  -->  00:02:25.500
Now in terms of the allocation of memory,
44

44

00:02:25.500  -->  00:02:28.270
it actually happens at the point
that you've initialized it.
45

45

00:02:28.270  -->  00:02:31.850
So in other words once you've talked in
the variable name and put an equal and
46

46

00:02:31.850  -->  00:02:34.880
then the value, at that point
python will allocate the space for
47

47

00:02:34.880  -->  00:02:36.790
that in the computers memory.
48

48

00:02:36.790  -->  00:02:39.670
In terms of using variables
we saw that we could
49

49

00:02:39.670  -->  00:02:41.210
use the prints statement
to print some out.
50

50

00:02:41.210  -->  00:02:46.450
We could do something like TIm was here,
or
51

51

00:02:46.450  -->  00:02:53.040
Tim was 57 + a single-quote
space plus greeting.
52

52

00:02:53.040  -->  00:02:56.560
We could run thatm, Hello Bruce.
53

53

00:02:56.560  -->  00:02:59.870
Obviously it's taking the value
of Hello from Tim_Was_57 and
54

54

00:02:59.870  -->  00:03:01.770
Bruce from the variable greeting and
55

55

00:03:01.770  -->  00:03:06.110
actually printing that on the screen
with a space between the two there.
56

56

00:03:06.110  -->  00:03:09.720
We could do something like age equals 24,
print age.
57

57

00:03:11.620  -->  00:03:16.440
We can also do something like greeting
plus age, since we're on this program.
58

58

00:03:17.780  -->  00:03:19.640
Now this is where we
actually get an error.
59

59

00:03:19.640  -->  00:03:22.410
So you can see it should the first
Hello Bruce which we saw before,
60

60

00:03:22.410  -->  00:03:23.820
which was this first line.
61

61

00:03:23.820  -->  00:03:27.490
We then assigned a value of 24 to
the variable age, and we printed the age,
62

62

00:03:27.490  -->  00:03:27.990
which 24 worked.
63

63

00:03:27.990  -->  00:03:32.340
We're going to try to do this next line,
print greeting plus age.
64

64

00:03:32.340  -->  00:03:33.760
And we actually got an error in red.
65

65

00:03:33.760  -->  00:03:37.930
And you can see that Python's actually
trying to help you here by actually sort
66

66

00:03:37.930  -->  00:03:39.990
of saying, look I've got
a problem with what you've typed.
67

67

00:03:39.990  -->  00:03:44.340
It's actually come up and actually said,
I can't convert int object to a string.
68

68

00:03:44.340  -->  00:03:47.610
Str is the abbreviation
of string implicitly.
69

69

00:03:47.610  -->  00:03:50.730
So what we've tried to do is Get it to do
something that Python can't work with, and
70

70

00:03:50.730  -->  00:03:53.300
this is what happens
when you get an error.
71

71

00:03:53.300  -->  00:03:57.000
So Python will hopefully show you some
information which hopefully leads to you
72

72

00:03:57.000  -->  00:04:01.010
figuring out what the problem was, and
it actually shows also the actual lines.
73

73

00:04:01.010  -->  00:04:05.140
So if we move over a little bit you can
see it's saying the name of the Python
74

74

00:04:05.140  -->  00:04:09.680
file which was one that I created for
this video varibles.py py.
75

75

00:04:09.680  -->  00:04:13.260
And it says that line 12,
which equates to line 12 over here.
76

76

00:04:13.260  -->  00:04:16.350
So it's very handy to look at these when
you trying to figure out whether there's
77

77

00:04:16.350  -->  00:04:20.370
a problem, and you can go back to line 12,
and know this was where the problem was.
78

78

00:04:21.500  -->  00:04:24.450
Now the other thing is that IntelliJ
actually does a lot of this for
79

79

00:04:24.450  -->  00:04:28.090
you automatically as well, it tries
to help you out with hints as well.
80

80

00:04:28.090  -->  00:04:30.770
So, over here we can see
these little dashes.
81

81

00:04:30.770  -->  00:04:32.380
If I actually hover over
there with my mouse,
82

82

00:04:32.380  -->  00:04:34.310
we actually get a helpful error message.
83

83

00:04:34.310  -->  00:04:37.600
Expected type string str got int instead.
84

84

00:04:37.600  -->  00:04:40.430
So that's IntelliJ, trying to
give you some information to say,
85

85

00:04:40.430  -->  00:04:41.990
you've got this wrong, basically.
86

86

00:04:41.990  -->  00:04:46.250
And so it can be really useful when
you're creating Python programs to keep
87

87

00:04:46.250  -->  00:04:49.170
checking these hints out to see
whether there actually is an issue.
88

88

00:04:49.170  -->  00:04:50.860
Notice also there's a keyboard shortcut,
89

89

00:04:50.860  -->  00:04:53.160
if you want to expand this to
get some more information.
90

90

00:04:53.160  -->  00:04:58.390
So on a Mac, I can actually type Cmd + F1,
I get more information like so.
91

91

00:04:58.390  -->  00:05:01.920
And press Ctrl + F1 on Windows machine or
a Linux machine and
92

92

00:05:01.920  -->  00:05:02.950
you can get the full message.
93

93

00:05:02.950  -->  00:05:06.050
So that's very handy to refer
to that all the time, and
94

94

00:05:06.050  -->  00:05:08.940
later in the course we'll be
looking at handling these errors.
95

95

00:05:08.940  -->  00:05:11.760
In other words, if you're program
crashes or goes to crash,
96

96

00:05:11.760  -->  00:05:13.880
we can handle that more gracefully.
97

97

00:05:13.880  -->  00:05:17.360
But for now, think of those error messages
that come up as your friend because what
98

98

00:05:17.360  -->  00:05:20.460
it's really doing, it's telling you
that your code is not gonna work and
99

99

00:05:20.460  -->  00:05:23.180
providing as much information as
possible to you to help you try and
100

100

00:05:23.180  -->  00:05:24.520
figure out what the solution is.
101

101

00:05:24.520  -->  00:05:27.550
So what can be frustrating, you really
did learn a lot from errors like these,
102

102

00:05:27.550  -->  00:05:29.960
because you can figure out something
that Python doesn't like, and
103

103

00:05:29.960  -->  00:05:33.050
how to work around that to come
up with actually a solution.
104

104

00:05:33.050  -->  00:05:34.160
Okay, so moving on,
105

105

00:05:34.160  -->  00:05:37.380
and later in the course we'll be
talking about these conversions.
106

106

00:05:37.380  -->  00:05:40.630
So, in terms of this particular error
message, what's actually happening was
107

107

00:05:40.630  -->  00:05:45.950
again we determined that Python wasn't
happy because we're trying to add the age,
108

108

00:05:45.950  -->  00:05:49.820
the numeric variable age to a number,
and you can't actually do that.
109

109

00:05:49.820  -->  00:05:51.450
It doesn't actually work like that.
110

110

00:05:51.450  -->  00:05:53.420
So Python doesn't know what
to do in that scenario.
111

111

00:05:53.420  -->  00:05:56.030
It knows what to do in
the situation like this,
112

112

00:05:56.030  -->  00:05:57.400
we're actually adding strings together.
113

113

00:05:57.400  -->  00:05:59.830
Because Tim_Was_57 is a string, and
114

114

00:05:59.830  -->  00:06:03.370
greeting was a string and
it knows to concatenate those.
115

115

00:06:03.370  -->  00:06:06.240
Likewise, if we tried it to do
something with two numbers,
116

116

00:06:06.240  -->  00:06:08.460
it knows to add to some
of those two numbers.
117

117

00:06:08.460  -->  00:06:10.480
But in this scenario where
we've got a string and
118

118

00:06:10.480  -->  00:06:12.720
a number, Python doesn't
actually know how to do that.
119

119

00:06:12.720  -->  00:06:15.510
Not know how to handle that and
that's why we actually got the message.
120

120

00:06:15.510  -->  00:06:18.020
So what we dealing more with
actually how to get around that.
121

121

00:06:18.020  -->  00:06:21.450
And do note that some other programming
languages, Java being one of them,
122

122

00:06:21.450  -->  00:06:24.040
does actually allow you to
actually do something like that.
123

123

00:06:24.040  -->  00:06:27.930
And in that scenario what would happen is
it would actually automatically convert
124

124

00:06:27.930  -->  00:06:28.740
what you're trying to do.
125

125

00:06:28.740  -->  00:06:32.620
In this case, it would append
the value of 24 to the string age.
126

126

00:06:32.620  -->  00:06:35.700
But Python doesn't do that,
it makes you get it right at the start.
127

127

00:06:35.700  -->  00:06:38.390
And that's actually a good thing in
many ways because it means you're not
128

128

00:06:38.390  -->  00:06:41.100
going to be getting any weird
little bugs that crept about
129

129

00:06:41.100  -->  00:06:43.100
because of automatic type conversion.
130

130

00:06:43.100  -->  00:06:44.710
That you may get in other
programming languages.
131

131

00:06:44.710  -->  00:06:47.290
So the bottom line is,
you need to get that right first, and
132

132

00:06:47.290  -->  00:06:50.580
really it's just a matter of checking
out the error message and fixing it.
133

133

00:06:50.580  -->  00:06:53.610
And we're talking more about this type of
thing as the course progresses anyway.
134

134

00:06:53.610  -->  00:06:56.530
So moving on, let's talk now
a little bit about variable types.
135

135

00:06:56.530  -->  00:06:59.080
So Python has got several
built-in data types.
136

136

00:06:59.080  -->  00:07:01.580
We've got a heap of them and
we'll be dealing with those in detail.
137

137

00:07:01.580  -->  00:07:06.270
Data types can be classified as numerics,
sequences, mappings, files,
138

138

00:07:06.270  -->  00:07:08.590
classes, instances, and exceptions.
139

139

00:07:08.590  -->  00:07:11.810
And I [LAUGH] know that sounds
like a lot and it probably is but
140

140

00:07:11.810  -->  00:07:14.890
you'll be introduced to all of
these as the course progresses.
141

141

00:07:14.890  -->  00:07:17.650
But for now we're gonna look
at numeric data types and
142

142

00:07:17.650  -->  00:07:19.620
one of the sequence types
which you've already seen.
143

143

00:07:19.620  -->  00:07:22.450
String being a sequence type,
which we've actually looked at before.
144

144

00:07:22.450  -->  00:07:26.960
Now Python 2, the older version of
python which as I mention is no longer
145

145

00:07:26.960  -->  00:07:28.860
being used and
we're not using it in this course.
146

146

00:07:28.860  -->  00:07:33.860
That actually had various data types
such as int, long, float, and complex,
147

147

00:07:33.860  -->  00:07:37.980
but in Python 3 the change they've made
is there's no longer a long type, and
148

148

00:07:37.980  -->  00:07:40.140
the int now behaves like a long used to.
149

149

00:07:40.140  -->  00:07:43.160
So they've really consolidated
the amount of data types.
150

150

00:07:43.160  -->  00:07:45.810
Now we're not going to
discuss complex numbers
151

151

00:07:45.810  -->  00:07:47.180
without going into too much detail.
152

152

00:07:47.180  -->  00:07:49.990
A complex number contains a real and
153

153

00:07:49.990  -->  00:07:52.600
an imaginary part based on
the square root of minus one.
154

154

00:07:52.600  -->  00:07:56.170
Now, if you understand a complex number
and wanna use Pyton to manipulate them,
155

155

00:07:56.170  -->  00:08:00.000
then by the end of the course you'll
understand Python well enough to do so.
156

156

00:08:00.000  -->  00:08:04.320
But really the complex number theories
in advance branch of mathematics slash
157

157

00:08:04.320  -->  00:08:07.640
engineering, it's not really appropriate
to go into too much detail with that.
158

158

00:08:07.640  -->  00:08:10.240
But let's look at the basic data types,
and
159

159

00:08:10.240  -->  00:08:12.800
a basic data type we're going
to start with an integer.
160

160

00:08:12.800  -->  00:08:16.670
An integer being a whole number so a
number that hasn't got any decimal points.
161

161

00:08:16.670  -->  00:08:19.070
First, you can see on the screen
I have typed in an integer.
162

162

00:08:19.070  -->  00:08:20.620
So an integer is a just whole number.
163

163

00:08:20.620  -->  00:08:24.150
It's a number having no
fractional part where as a float
164

164

00:08:24.150  -->  00:08:27.330
in the other example is another name for
a real number.
165

165

00:08:27.330  -->  00:08:30.950
That is a number having a fractional
part after the decimal point.
166

166

00:08:30.950  -->  00:08:35.150
There is a very small number of computer
languages that make no distinction between
167

167

00:08:35.150  -->  00:08:36.860
real numbers and integers.
168

168

00:08:36.860  -->  00:08:39.630
I guess you could say that
integers can be considered
169

169

00:08:39.630  -->  00:08:41.350
just special cases of real numbers.
170

170

00:08:41.350  -->  00:08:44.520
But when represented in a computer,
computations using integers,
171

171

00:08:44.520  -->  00:08:48.390
these whole numbers, are significantly
faster than using floating point numbers.
172

172

00:08:48.390  -->  00:08:51.420
So that's one of the main reasons that
we actually distinguish in programming
173

173

00:08:51.420  -->  00:08:53.850
an integer as a whole number and
a real number,
174

174

00:08:53.850  -->  00:08:56.960
a floating point number and that's
because it's a lot faster to process.
175

175

00:08:56.960  -->  00:09:00.700
So anything that doesn't need, as a
general rule, a floating point number for
176

176

00:09:00.700  -->  00:09:03.390
calculation purposes,
you shouldn't actually be using it.
177

177

00:09:03.390  -->  00:09:06.770
Because you'll find that your programs
will operate a lot faster because of it.
178

178

00:09:06.770  -->  00:09:10.810
There are pros and cons, because of
the way that integers are stored in
179

179

00:09:10.810  -->  00:09:14.010
the computer's memory, there's actually
a limit to the size of an int.
180

180

00:09:14.010  -->  00:09:17.040
It's about 9 trillion in European terms.
181

181

00:09:17.040  -->  00:09:19.990
I think it's nine quintillion,
in American format.
182

182

00:09:19.990  -->  00:09:23.390
But effectively the Python 2
long data type the Python 3,
183

183

00:09:23.390  -->  00:09:26.000
effectively have no real maximum size.
184

184

00:09:26.000  -->  00:09:27.680
Now floating point numbers
on the other hand,
185

185

00:09:27.680  -->  00:09:31.280
that's floats, they're used to represent
numbers having a fractional part.
186

186

00:09:31.280  -->  00:09:35.750
So the maximum float value on a 64 bit
computer is, well that's, it's just huge,
187

187

00:09:35.750  -->  00:09:37.390
we'll go through it, but it's quite large.
188

188

00:09:37.390  -->  00:09:41.730
Basically a number that actually moves
the decimal point 308 places to the right.
189

189

00:09:41.730  -->  00:09:45.940
And the smallest float is a negative
number which has 307 zeros before
190

190

00:09:45.940  -->  00:09:47.390
the decimal float.
191

191

00:09:47.390  -->  00:09:51.120
So, it's obviously a huge variance and
192

192

00:09:51.120  -->  00:09:53.830
a huge number can be stored in
that floating point number.
193

193

00:09:53.830  -->  00:09:57.280
Floating points have 52 digits of
precision, which should be adequate for
194

194

00:09:57.280  -->  00:10:00.600
most purposes from financial calculations
where you're needing decimals.
195

195

00:10:00.600  -->  00:10:04.080
And because Python doesn't really
have variable declarations,
196

196

00:10:04.080  -->  00:10:07.950
that's where you specify the type of
a variable before you can use it, and
197

197

00:10:07.950  -->  00:10:10.170
lots of other computer languages do that.
198

198

00:10:10.170  -->  00:10:13.970
It's probably tempting to think that you
don't need to understand the difference
199

199

00:10:13.970  -->  00:10:15.010
between an int, a long,
and a float type, but
200

200

00:10:15.010  -->  00:10:18.120
really it is something you really need
to consider when writing your programs.
201

201

00:10:18.120  -->  00:10:20.380
This makes more sense when we look
at some of the operators that can be
202

202

00:10:20.380  -->  00:10:21.240
performed on numbers.
203

203

00:10:21.240  -->  00:10:23.040
So let's just go through
the first few scenarios.
204

204

00:10:23.040  -->  00:10:26.480
So I typed a variable called
a with an integer value of 12.
205

205

00:10:26.480  -->  00:10:29.450
Let's do another one, b = 3.
206

206

00:10:29.450  -->  00:10:31.670
And let's perform some calculations.
207

207

00:10:31.670  -->  00:10:39.450
We'll do print, we'll do a plus b,
we should get the value of 15,
208

208

00:10:39.450  -->  00:10:44.920
a take b, we should get the value of nine.
209

209

00:10:44.920  -->  00:10:50.390
Print, a times b, the value of 36,
we should get and we'll test this shortly.
210

210

00:10:50.390  -->  00:10:53.530
a divided by b,
we should get the answer four, but
211

211

00:10:53.530  -->  00:10:56.120
there's a special rule there about
that which I will talk about shortly.
212

212

00:10:56.120  -->  00:11:01.640
And we're going to introduce
another operator, //b and
213

213

00:11:01.640  -->  00:11:04.680
I'll explain that shortly, and last one
we're going to use is the remainder,
214

214

00:11:04.680  -->  00:11:09.330
remainder of a divided by b effectively.
215

215

00:11:09.330  -->  00:11:13.760
Otherwise dividing 12 by 3,
how much remainder is left after that.
216

216

00:11:13.760  -->  00:11:16.320
So let's just run this, and
then we'll just go through it.
217

217

00:11:16.320  -->  00:11:17.750
So the first one is 15.
218

218

00:11:17.750  -->  00:11:18.440
The second one is 9.
219

219

00:11:18.440  -->  00:11:20.080
And the third value is 36.
220

220

00:11:20.080  -->  00:11:22.610
And there's the fourth one,
a divided by b.
221

221

00:11:22.610  -->  00:11:27.360
The actual answer is returned as a float,
with a decimal point, .0.
222

222

00:11:27.360  -->  00:11:30.490
And that's the thing to keep in mind,
with a divide,
223

223

00:11:30.490  -->  00:11:35.180
a division operation, in Python,
by default it returns as a float.
224

224

00:11:35.180  -->  00:11:37.880
If you want the result
to return as an integer,
225

225

00:11:37.880  -->  00:11:40.990
a whole number, you need to use
the two slashes in this case.
226

226

00:11:40.990  -->  00:11:44.360
So a, slash slash b,
returns four as a whole number.
227

227

00:11:44.360  -->  00:11:45.120
And lastly,
228

228

00:11:45.120  -->  00:11:50.300
the remainder of a divided by b was
zero because b goes into a four times.
229

229

00:11:50.300  -->  00:11:52.200
Four times three is twelve and
there would be no remainder.
230

230

00:11:52.200  -->  00:11:55.520
So that's how you do some
basic calculations in Python.
231

231

00:11:55.520  -->  00:11:58.830
Now this slash and
slash slash can really trip you up, and
232

232

00:11:58.830  -->  00:12:00.980
we're gonna be talking about loops later.
233

233

00:12:00.980  -->  00:12:04.030
But I just want to give you an example of
typing in a loop where you could get into
234

234

00:12:04.030  -->  00:12:06.090
difficulty without using that slash or
235

235

00:12:06.090  -->  00:12:09.600
slash slash because it can be
a common source of problems.
236

236

00:12:09.600  -->  00:12:10.700
So let's look at an example here.
237

237

00:12:10.700  -->  00:12:13.770
We're gonna type in some code, and
again we'll talk more about this for, and
238

238

00:12:13.770  -->  00:12:14.900
the concept of loops later.
239

239

00:12:14.900  -->  00:12:19.930
But for now we'll just type in for
240

240

00:12:19.930  -->  00:12:24.980
i in range, 1, 4, : print i.
241

241

00:12:24.980  -->  00:12:28.390
So if we run this,
You get the values 1, 2, 3.
242

242

00:12:28.390  -->  00:12:33.950
We've actually changed this here and
put a divided by b, cuz instead
243

243

00:12:33.950  -->  00:12:37.260
of putting a constant number, a literal,
we can actually put an expression like so.
244

244

00:12:37.260  -->  00:12:40.750
If we run that, we actually get an error.
245

245

00:12:40.750  -->  00:12:43.750
And that's because float object
cannot be interpreted as an integer,
246

246

00:12:43.750  -->  00:12:45.020
and that's because the answer,
247

247

00:12:45.020  -->  00:12:47.990
if you remember, with division by
default is a floating point number.
248

248

00:12:47.990  -->  00:12:49.540
The range actually needs an integer, so
249

249

00:12:49.540  -->  00:12:51.920
we'd actually put two
slashes in that scenario.
250

250

00:12:51.920  -->  00:12:55.900
Run the code again, it actually correctly
returns the results one, two, and three.
251

251

00:12:55.900  -->  00:12:58.500
As we progress through the course, you'll
see other ways of actually handling this,
252

252

00:12:58.500  -->  00:12:59.820
but I just wanted to point that out.
253

253

00:12:59.820  -->  00:13:02.640
At this point in time, that's a common
source of problems when you're
254

254

00:13:02.640  -->  00:13:03.960
looking at Python for the first time.
255

255

00:13:03.960  -->  00:13:06.710
And again, don't be too worried about
the concepts of what this is doing,
256

256

00:13:06.710  -->  00:13:10.110
we'll be covering loops, which is what
this actually is In future videos.
257

257

00:13:10.110  -->  00:13:13.640
So the code something like a plus b,
that's actually an expression and
258

258

00:13:13.640  -->  00:13:14.840
I mentioned expressions.
259

259

00:13:14.840  -->  00:13:19.030
In Python an expression is anything that
can be calculated to return a value.
260

260

00:13:19.030  -->  00:13:22.230
So we've really only used simple
expressions to date like a plus b or
261

261

00:13:22.230  -->  00:13:24.550
a take b but
we can get a lot more complex.
262

262

00:13:24.550  -->  00:13:26.650
We could do something,
just let me clear some space here.
263

263

00:13:27.730  -->  00:13:31.290
So a lot more complex if we want to,
264

264

00:13:31.290  -->  00:13:37.320
we can do something like
print (a + b / 3- 4 * 12),
265

265

00:13:37.320  -->  00:13:41.810
and that's quite a valid expression.
266

266

00:13:41.810  -->  00:13:45.600
So if we actually run this, you might
be surprised to look at that and think,
267

267

00:13:45.600  -->  00:13:47.770
why is that come up with a value of 35?
268

268

00:13:47.770  -->  00:13:51.100
You'd expect looking at that,
that the answer should actually be 12.
269

269

00:13:51.100  -->  00:13:57.980
It should be a plus b is 15 divided by
3 is 5, take 4 is 1, times 12 is 12.
270

270

00:13:57.980  -->  00:13:59.780
So why have we actually
got 35 here instead of 12?
271

271

00:13:59.780  -->  00:14:03.170
[LAUGH] Now don't worry,
your computer's not broken.
272

272

00:14:03.170  -->  00:14:05.930
And you can reliably perform
arithmetic in Python.
273

273

00:14:05.930  -->  00:14:08.360
But, as is the case in all
programming languages,
274

274

00:14:08.360  -->  00:14:12.280
you have to understand some of the basic
rules of the arithmetic operators.
275

275

00:14:12.280  -->  00:14:14.560
Out problem here is operator precedence.
276

276

00:14:14.560  -->  00:14:17.260
Now operator precedence
is a fancy term for
277

277

00:14:17.260  -->  00:14:19.890
the relative importance given
to each of the operators.
278

278

00:14:19.890  -->  00:14:23.810
If all operators were equal, we'll get
the expression how I read it earlier.
279

279

00:14:23.810  -->  00:14:31.180
By calculating a plus b is 15 divided by
three is 5 take 4 is 1 time 12 is 12.
280

280

00:14:31.180  -->  00:14:33.570
But the thing to remember
is multiplication and
281

281

00:14:33.570  -->  00:14:37.400
division have higher operator precedence
than addition and subtraction.
282

282

00:14:37.400  -->  00:14:39.620
So those operators are performed first.
283

283

00:14:39.620  -->  00:14:41.580
And most languages you'll
find working the same way so
284

284

00:14:41.580  -->  00:14:42.970
this is not just peculiar to Python.
285

285

00:14:42.970  -->  00:14:47.440
So what's actually happening is b divided
by 3, this is actually happening first.
286

286

00:14:47.440  -->  00:14:51.790
So, b divided by 3 is happening first,
which is 1.
287

287

00:14:51.790  -->  00:14:53.720
Then 4 times 12 is added, which is 48.
288

288

00:14:53.720  -->  00:14:57.950
So the expression is actually evaluated
as 12 plus one is 13, take 48,
289

289

00:14:57.950  -->  00:14:59.260
which is negative 35.
290

290

00:14:59.260  -->  00:15:04.380
That's weird, but that's the way
it actually happens by default
291

291

00:15:04.380  -->  00:15:08.340
because multiplication and division, as I
mentioned, have got a higher precedence.
292

292

00:15:08.340  -->  00:15:11.760
So the case where you've actually got
expressions that use just those operators,
293

293

00:15:11.760  -->  00:15:13.200
they will actually work
from left to right.
294

294

00:15:13.200  -->  00:15:16.060
So we can type a divided
by two times three,
295

295

00:15:16.060  -->  00:15:19.280
and that should give us the answer
of four times three is 12.
296

296

00:15:19.280  -->  00:15:22.840
So we run that,
we actually get the answer of twelve and
297

297

00:15:22.840  -->  00:15:26.410
even something like eight
times three divided by two.
298

298

00:15:26.410  -->  00:15:30.340
24 divided by two is 12,
we get the answer correct.
299

299

00:15:30.340  -->  00:15:32.510
Then the best way to
actually overcome this,
300

300

00:15:32.510  -->  00:15:37.460
if you want your expressions to be clear
and unambiguous to use parenthesis freely,
301

301

00:15:37.460  -->  00:15:39.300
even when Python doesn't
specifically require them.
302

302

00:15:39.300  -->  00:15:42.690
So, in our earlier example, the one
that didn't work, this first line here.
303

303

00:15:42.690  -->  00:15:47.710
So we could do something like, print,
304

304

00:15:47.710  -->  00:15:54.730
a plus b, divide it by three,
take four, times 12.
305

305

00:15:54.730  -->  00:15:57.880
Now that's a lot of brackets there but
what we're doing is we're actually putting
306

306

00:15:57.880  -->  00:16:00.900
the expressions in parentheses to make
it clear what we're trying to perform.
307

307

00:16:00.900  -->  00:16:04.270
And when we actually run it we're actually
correct, you now have the answer 12.
308

308

00:16:04.270  -->  00:16:08.480
So you can see we've got a plus b in its
own set of brackets, that's gonna be 15.
309

309

00:16:08.480  -->  00:16:11.260
But then outside to that there's this
bracket here, which covers that.
310

310

00:16:11.260  -->  00:16:15.830
So therefore, that calculation is now
15 divided by three, which is five.
311

311

00:16:15.830  -->  00:16:19.070
Then take four from that is one,
then multiply by 12, is 12,
312

312

00:16:19.070  -->  00:16:20.810
and that's why we're
getting the answer of 12.
313

313

00:16:20.810  -->  00:16:22.080
Okay, so I'm gonna stop the video here.
314

314

00:16:22.080  -->  00:16:25.710
In the next video we're gonna continue
on talking about variables and
315

315

00:16:25.710  -->  00:16:26.910
operator precedence etc.
316

316

00:16:26.910  -->  00:16:28.320
So I'll see you in the next video.
