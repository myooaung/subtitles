WEBVTT
1
1

00:00:04.250  -->  00:00:05.660
alright let's move on to the next
2

2

00:00:05.660  -->  00:00:11.210
challenge challenge number 12
3

3

00:00:11.210  -->  00:00:13.370
so the challenge here is to write a regular
4

4

00:00:13.370  -->  00:00:16.040
expression that will match a five-digit
5

5

00:00:16.040  -->  00:00:17.510
us zip code
6

6

00:00:17.510  -->  00:00:20.860
so use 11111 as your test string so figure that one
7

7

00:00:20.860  -->  00:00:21.610
out
8

8

00:00:21.610  -->  00:00:23.660
pause the video and come back when
9

9

00:00:23.660  -->  00:00:25.360
you're ready to go through my solution
10

10

00:00:25.360  -->  00:00:30.500
pause the video alright challenge 12 how
11

11

00:00:30.500  -->  00:00:32.540
do we actually do this so we're going to
12

12

00:00:32.540  -->  00:00:34.250
put in our test string....
13

13

00:00:34.250  -->  00:00:41.720
....so challenge
14

14

00:00:41.720  -->  00:00:43.570
is actually quite simple it's going to
15

15

00:00:43.570  -->  00:00:46.670
be...
16

16

00:00:46.670  -->  00:00:50.420
....
17

17

00:00:50.420  -->  00:00:52.300
...
18

18

00:00:52.300  -->  00:00:56.440
....
19

19

00:00:56.440  -->  00:01:02.600
....so we wanted to use the start and
20

20

00:01:02.600  -->  00:01:04.100
end boundary matches because we want the
21

21

00:01:04.100  -->  00:01:06.190
entire string to match and we use the
22

22

00:01:06.190  -->  00:01:08.120
/d character class which will
23

23

00:01:08.120  -->  00:01:10.010
match any digit and then use a
24

24

00:01:10.010  -->  00:01:11.840
quantifier to specify that I wanted
25

25

00:01:11.840  -->  00:01:14.180
5 digits let's check that actually
26

26

00:01:14.180  -->  00:01:19.970
works and we got a true their showing
27

27

00:01:19.970  -->  00:01:22.310
that it works alright next challenge
28

28

00:01:22.310  -->  00:01:28.100
challenge number 13
29

29

00:01:28.100  -->  00:01:30.920
so us zip codes can be followed by dash
30

30

00:01:30.920  -->  00:01:33.400
and another 4 numbers so write a
31

31

00:01:33.400  -->  00:01:35.720
regular expression that will match those
32

32

00:01:35.720  -->  00:01:40.310
zip codes so use 11111-111 as your test string
33

33

00:01:40.310  -->  00:01:42.470
so see if you can figure that one out
34

34

00:01:42.470  -->  00:01:44.110
pause the video now and i'll see you
35

35

00:01:44.110  -->  00:01:50.600
when you get back ok so challenge 13 so
36

36

00:01:50.600  -->  00:01:52.430
will enter our string firstly....
37

37

00:01:52.430  -->  00:02:01.610
....
38

38

00:02:01.610  -->  00:02:19.730
...
39

39

00:02:19.730  -->  00:02:21.470
so this one is fairly straightforward we're just
40

40

00:02:21.470  -->  00:02:22.940
adding a dash after the regular
41

41

00:02:22.940  -->  00:02:25.060
expression for challenge 12 and then we
42

42

00:02:25.060  -->  00:02:27.410
expect four digits so the final palette
43

43

00:02:27.410  -->  00:02:28.700
expression is essentially the same as
44

44

00:02:28.700  -->  00:02:30.350
the beginning all we have to do is change
45

45

00:02:30.350  -->  00:02:32.950
the number in the quantifier now if we
46

46

00:02:32.950  -->  00:02:35.000
were trying to verify user input we
47

47

00:02:35.000  -->  00:02:36.980
could check the length of the input and
48

48

00:02:36.980  -->  00:02:38.200
from there decide which regular
49

49

00:02:38.200  -->  00:02:40.670
expression to use but ideally it would
50

50

00:02:40.670  -->  00:02:42.440
be nice to have one regular expression
51

51

00:02:42.440  -->  00:02:44.950
that would match both cases but lets
52

52

00:02:44.950  -->  00:02:46.220
actually just check to see whether this
53

53

00:02:46.220  -->  00:02:48.290
actually works before we move on to the
54

54

00:02:48.290  -->  00:02:50.510
last challenge we got a true there
55

55

00:02:50.510  -->  00:02:52.940
so that one works alright final
56

56

00:02:52.940  -->  00:02:58.810
challenge challenge 14
57

57

00:02:58.810  -->  00:03:01.230
so write a regular expression that will
58

58

00:03:01.230  -->  00:03:04.690
match a five-digit us zip code and zip
59

59

00:03:04.690  -->  00:03:06.400
codes that contain the optional four
60

60

00:03:06.400  -->  00:03:09.730
digits preceded by a dash in other words
61

61

00:03:09.730  -->  00:03:12.010
matching both challenge 12 and challenge
62

62

00:03:12.010  -->  00:03:14.080
13 in the one regular expression
63

63

00:03:14.080  -->  00:03:15.880
see how you go with that one
64

64

00:03:15.880  -->  00:03:17.800
pause the video now i'll see you when
65

65

00:03:17.800  -->  00:03:20.100
you get back
66

66

00:03:20.100  -->  00:03:24.690
ok challenge 14 how we go about actually
67

67

00:03:24.690  -->  00:03:28.170
solving this one what we can do is we're
68

68

00:03:28.170  -->  00:03:29.820
going to use the challenge 12 and
69

69

00:03:29.820  -->  00:03:31.680
challenge 13 strings that we defined in
70

70

00:03:31.680  -->  00:03:33.570
the previous challenges so print out
71

71

00:03:33.570  -->  00:03:38.550
firstly challenge 12....
72

72

00:03:38.550  -->  00:03:39.930
...
73

73

00:03:39.930  -->  00:03:42.900
....
74

74

00:03:42.900  -->  00:03:46.560
...
75

75

00:03:46.560  -->  00:03:48.090
....
76

76

00:03:48.090  -->  00:04:07.140
...
77

77

00:04:07.140  -->  00:04:09.030
...we're going to put the
78

78

00:04:09.030  -->  00:04:11.820
question mark...
79

79

00:04:11.820  -->  00:04:16.080
....
80

80

00:04:16.080  -->  00:04:20.190
...so basically I've actually modified
81

81

00:04:20.190  -->  00:04:21.900
the expression by enclosing the optional
82

82

00:04:21.900  -->  00:04:24.330
part the dash and four numbers within a
83

83

00:04:24.330  -->  00:04:27.180
group and following the group with the ?
84

84

00:04:27.180  -->  00:04:29.670
modifier which means that a quantifier
85

85

00:04:29.670  -->  00:04:31.320
I should say which means that they can be
86

86

00:04:31.320  -->  00:04:34.290
0 or 1 occurrences of the group and we
87

87

00:04:34.290  -->  00:04:36.120
wouldn't want to use the plus or star
88

88

00:04:36.120  -->  00:04:38.310
quantifies in this case because then we
89

89

00:04:38.310  -->  00:04:42.330
match strings like 11111-1111
90

90

00:04:42.330  -->  00:04:45.030
so we run this now we should find that
91

91

00:04:45.030  -->  00:04:50.310
both the post codes now match this you can
92

92

00:04:50.310  -->  00:04:52.800
see we've got true for both and
93

93

00:04:52.800  -->  00:04:54.360
whenever you want need to write a
94

94

00:04:54.360  -->  00:04:55.860
regular expression that matches a piece
95

95

00:04:55.860  -->  00:04:57.630
of data like a zip code
96

96

00:04:57.630  -->  00:05:00.090
telephone number email address etc we
97

97

00:05:00.090  -->  00:05:01.800
can usually find regular expressions
98

98

00:05:01.800  -->  00:05:04.380
that solve these problems on the web but
99

99

00:05:04.380  -->  00:05:06.840
my suggestion here is to be careful and
100

100

00:05:06.840  -->  00:05:07.830
that's because there's a lot of
101

101

00:05:07.830  -->  00:05:10.680
variations and in some cases much debate
102

102

00:05:10.680  -->  00:05:12.480
about which one is correct
103

103

00:05:12.480  -->  00:05:14.130
also the regular expressions can be
104

104

00:05:14.130  -->  00:05:16.800
wrong or incomplete for example if you do a
105

105

00:05:16.800  -->  00:05:18.030
search you can actually find this
106

106

00:05:18.030  -->  00:05:19.770
regular expression for a Canadian
107

107

00:05:19.770  -->  00:05:21.870
postcode i'm just going to paste it in
108

108

00:05:21.870  -->  00:05:22.830
because we're not going to produce any
109

109

00:05:22.830  -->  00:05:26.760
code so that's the example there this
110

110

00:05:26.760  -->  00:05:28.260
regular expression expects a letter
111

111

00:05:28.260  -->  00:05:30.810
followed by digit followed by letter
112

112

00:05:30.810  -->  00:05:33.030
then they will optionally be a blank or
113

113

00:05:33.030  -->  00:05:33.810
a dash
114

114

00:05:33.810  -->  00:05:35.430
and then a number followed by letter
115

115

00:05:35.430  -->  00:05:37.560
followed by a number this matches
116

116

00:05:37.560  -->  00:05:42.030
post codes like my m1a 1m1 but here
117

117

00:05:42.030  -->  00:05:43.950
the regular expression is wrong because
118

118

00:05:43.950  -->  00:05:45.810
canadian post codes can't contain
119

119

00:05:45.810  -->  00:05:47.700
certain letters and they're generally
120

120

00:05:47.700  -->  00:05:49.260
aren't written using a dash although that's
121

121

00:05:49.260  -->  00:05:52.050
not strictly wrong the point here is to
122

122

00:05:52.050  -->  00:05:53.400
remember that not everything you see on
123

123

00:05:53.400  -->  00:05:55.440
the internet is true especially with the
124

124

00:05:55.440  -->  00:05:56.700
regular expressions
125

125

00:05:56.700  -->  00:05:58.740
alright so that concludes our regular
126

126

00:05:58.740  -->  00:06:00.270
expression challenge and actually this
127

127

00:06:00.270  -->  00:06:02.190
section of the course regular
128

128

00:06:02.190  -->  00:06:04.380
expressions can be challenging and to
129

129

00:06:04.380  -->  00:06:06.470
write and decipher but you'll get the hang
130

130

00:06:06.470  -->  00:06:09.060
of it with practice practice practice so
131

131

00:06:09.060  -->  00:06:10.620
i hope you enjoyed this section time to
132

132

00:06:10.620  -->  00:06:16.700
move on to the next one now
