WEBVTT
1
1

00:00:04.670  -->  00:00:07.960
This video is about method overriding
2

2

00:00:07.960  -->  00:00:11.240
versus overloading, specifically let's
3

3

00:00:11.240  -->  00:00:12.710
talk about the main differences between
4

4

00:00:12.710  -->  00:00:16.090
method overriding and method overloading.
5

5

00:00:16.090  -->  00:00:19.040
So method overloading it means providing
6

6

00:00:19.040  -->  00:00:21.170
two or more separate methods in a class
7

7

00:00:21.170  -->  00:00:24.170
with the same name but with different
8

8

00:00:24.170  -->  00:00:26.720
parameters now the yeah method return
9

9

00:00:26.720  -->  00:00:29.210
type may or may not be different and
10

10

00:00:29.210  -->  00:00:31.369
that allows us to reuse the same method
11

11

00:00:31.369  -->  00:00:34.460
name. Overloading is very handy because
12

12

00:00:34.460  -->  00:00:37.010
it reduces duplicated code and we don't
13

13

00:00:37.010  -->  00:00:39.790
have to remember multiple method names.
14

14

00:00:39.790  -->  00:00:42.199
Now overloading doesn't have anything to
15

15

00:00:42.199  -->  00:00:44.989
do with polymorphism but Java developers
16

16

00:00:44.989  -->  00:00:46.729
often refer to overloading as
17

17

00:00:46.729  -->  00:00:49.850
compile-time polymorphism, so in other
18

18

00:00:49.850  -->  00:00:52.430
words the compiler decided which method
19

19

00:00:52.430  -->  00:00:54.409
is going to be called based on the
20

20

00:00:54.409  -->  00:00:56.960
method name return type an argument list.
21

21

00:00:56.960  -->  00:00:59.809
Now we can override static in instant
22

22

00:00:59.809  -->  00:01:02.089
methods and more about the differences
23

23

00:01:02.089  -->  00:01:03.890
between static and instant methods later
24

24

00:01:03.890  -->  00:01:04.960
in the course.
25

25

00:01:04.960  -->  00:01:07.880
Now usually overloading happens inside a
26

26

00:01:07.880  -->  00:01:10.430
single class, but a method can also be
27

27

00:01:10.430  -->  00:01:13.070
treated as overloaded in the subclass of
28

28

00:01:13.070  -->  00:01:15.770
that class and that's because a subclass
29

29

00:01:15.770  -->  00:01:18.710
inherits one version of the method from
30

30

00:01:18.710  -->  00:01:20.840
the parent class and then the subclass
31

31

00:01:20.840  -->  00:01:22.909
can have another overloaded version of
32

32

00:01:22.909  -->  00:01:25.880
that method, there's some rules about
33

33

00:01:25.880  -->  00:01:27.859
method overloading methods will be
34

34

00:01:27.859  -->  00:01:30.079
considered overloaded if both follow the
35

35

00:01:30.079  -->  00:01:32.390
following rules the methods must have
36

36

00:01:32.390  -->  00:01:34.369
the same method name and methods must
37

37

00:01:34.369  -->  00:01:35.840
have different parameters.
38

38

00:01:35.840  -->  00:01:37.999
Now if methods follow the rules above
39

39

00:01:37.999  -->  00:01:40.640
then they may or may not have different
40

40

00:01:40.640  -->  00:01:42.530
return types that may or may not have
41

41

00:01:42.530  -->  00:01:44.749
different access modifiers and then may
42

42

00:01:44.749  -->  00:01:46.369
or may not throw different checked or
43

43

00:01:46.369  -->  00:01:48.799
unchecked exceptions and more on
44

44

00:01:48.799  -->  00:01:50.179
exceptions than what they are on how to
45

45

00:01:50.179  -->  00:01:53.569
use them later in the course, so that was
46

46

00:01:53.569  -->  00:01:55.280
method overloading let's discuss a
47

47

00:01:55.280  -->  00:01:56.509
little bit more now about method
48

48

00:01:56.509  -->  00:01:59.780
overriding, so a method overriding well
49

49

00:01:59.780  -->  00:02:01.399
that means to finding a method in the
50

50

00:02:01.399  -->  00:02:03.679
child car or in a child class that
51

51

00:02:03.679  -->  00:02:06.079
already exists in the parent class with
52

52

00:02:06.079  -->  00:02:07.880
the same signature in other words the
53

53

00:02:07.880  -->  00:02:10.819
same name and same arguments, so by
54

54

00:02:10.819  -->  00:02:13.069
extending the parent class the child
55

55

00:02:13.069  -->  00:02:14.870
class gets all the methods defined in
56

56

00:02:14.870  -->  00:02:16.970
the parent class and those methods are
57

57

00:02:16.970  -->  00:02:18.930
know on has derived methods.
58

58

00:02:18.930  -->  00:02:21.159
Method overriding is also known as
59

59

00:02:21.159  -->  00:02:23.680
runtime polymorphism and dynamic method
60

60

00:02:23.680  -->  00:02:26.200
dispatch because the method that is
61

61

00:02:26.200  -->  00:02:27.940
going to be called is decided at runtime
62

62

00:02:27.940  -->  00:02:31.659
by the java virtual machine. When we
63

63

00:02:31.659  -->  00:02:33.190
override a method, it's recommended to
64

64

00:02:33.190  -->  00:02:36.129
put at override immediately above the
65

65

00:02:36.129  -->  00:02:38.799
method definition and an override is an
66

66

00:02:38.799  -->  00:02:41.170
annotation and the compiler will read
67

67

00:02:41.170  -->  00:02:43.329
and will read an annotation and in this
68

68

00:02:43.329  -->  00:02:46.599
case the at override tells the compiler
69

69

00:02:46.599  -->  00:02:48.730
to show us an error if we aren't
70

70

00:02:48.730  -->  00:02:50.620
following the overriding rules correctly
71

71

00:02:50.620  -->  00:02:53.230
for that method, then we can override
72

72

00:02:53.230  -->  00:02:55.540
static methods only instance methods can
73

73

00:02:55.540  -->  00:02:56.700
be overridden
74

74

00:02:56.700  -->  00:02:59.230
so some rules about method overriding a
75

75

00:02:59.230  -->  00:03:01.480
method will be considered overridden if
76

76

00:03:01.480  -->  00:03:03.879
we follow these rules firstly it must
77

77

00:03:03.879  -->  00:03:05.500
have the same name and same arguments
78

78

00:03:05.500  -->  00:03:08.590
the return type can be a subclass of the
79

79

00:03:08.590  -->  00:03:11.290
return type in the parent class, it can't
80

80

00:03:11.290  -->  00:03:13.540
have a lower access modifier so for
81

81

00:03:13.540  -->  00:03:15.489
example if the parent method is
82

82

00:03:15.489  -->  00:03:17.890
protected than using private in the
83

83

00:03:17.890  -->  00:03:19.209
child is not allowed,
84

84

00:03:19.209  -->  00:03:21.760
however using public in the child would
85

85

00:03:21.760  -->  00:03:25.120
be allowed in this example now there's
86

86

00:03:25.120  -->  00:03:27.010
also some important points about method
87

87

00:03:27.010  -->  00:03:29.680
overriding to keep in mind firstly only
88

88

00:03:29.680  -->  00:03:31.989
inherited methods can be overridden in
89

89

00:03:31.989  -->  00:03:33.579
other words methods cannot be overridden
90

90

00:03:33.579  -->  00:03:37.120
only in child classes constructors and
91

91

00:03:37.120  -->  00:03:38.470
other private methods cannot be
92

92

00:03:38.470  -->  00:03:40.599
overridden and methods that are final
93

93

00:03:40.599  -->  00:03:43.629
also cannot be overridden now a subclass
94

94

00:03:43.629  -->  00:03:44.889
can use super dot method name
95

95

00:03:44.889  -->  00:03:47.709
parenthesis to call the subclass version
96

96

00:03:47.709  -->  00:03:50.500
of an overridden method. So let's see an
97

97

00:03:50.500  -->  00:03:52.120
example now of method overloading and
98

98

00:03:52.120  -->  00:03:55.359
method overriding so on the Left we've
99

99

00:03:55.359  -->  00:03:58.060
got a simple overriding example, as you
100

100

00:03:58.060  -->  00:04:00.370
can see we've got two classes dog and
101

101

00:04:00.370  -->  00:04:02.919
German Shepherd, now the class German
102

102

00:04:02.919  -->  00:04:05.500
shepherd extends dog and overrides
103

103

00:04:05.500  -->  00:04:08.049
method bark, so as you can see with
104

104

00:04:08.049  -->  00:04:10.239
overriding we've got the same name and
105

105

00:04:10.239  -->  00:04:12.310
same parameters for the method in this
106

106

00:04:12.310  -->  00:04:13.900
case specifically we don't have any
107

107

00:04:13.900  -->  00:04:15.669
parameters but they would need to be the
108

108

00:04:15.669  -->  00:04:18.130
same in the case of overriding on the
109

109

00:04:18.130  -->  00:04:20.169
right-hand side you can see simple
110

110

00:04:20.169  -->  00:04:22.389
example with method overloading, so here
111

111

00:04:22.389  -->  00:04:24.490
we've got the class dog with two methods
112

112

00:04:24.490  -->  00:04:27.520
that have the nice same name bark but in
113

113

00:04:27.520  -->  00:04:28.330
this case they've got different
114

114

00:04:28.330  -->  00:04:30.969
parameters, the second method bark has an
115

115

00:04:30.969  -->  00:04:31.840
int parameter
116

116

00:04:31.840  -->  00:04:33.790
while the firsts our method for bark
117

117

00:04:33.790  -->  00:04:36.430
doesn't have any parameters, so hopefully
118

118

00:04:36.430  -->  00:04:37.570
now you can easily see the difference
119

119

00:04:37.570  -->  00:04:40.540
between overriding and overloading when
120

120

00:04:40.540  -->  00:04:42.070
comparing these two examples side by
121

121

00:04:42.070  -->  00:04:45.070
side, so let's recap now the most
122

122

00:04:45.070  -->  00:04:47.830
important rules about overloading and
123

123

00:04:47.830  -->  00:04:49.870
overriding methods, so in the following
124

124

00:04:49.870  -->  00:04:51.610
table you can see the main differences
125

125

00:04:51.610  -->  00:04:54.310
between overloading and overriding now
126

126

00:04:54.310  -->  00:04:56.889
some parts like exceptions are probably
127

127

00:04:56.889  -->  00:04:58.449
still unknown you may be wondering what
128

128

00:04:58.449  -->  00:05:00.250
exceptions are you may not know those at
129

129

00:05:00.250  -->  00:05:02.020
this point but we'll cover exceptions
130

130

00:05:02.020  -->  00:05:04.210
later in the course, but on the left hand
131

131

00:05:04.210  -->  00:05:05.950
side we've got overloading and on the
132

132

00:05:05.950  -->  00:05:07.360
right hand side we've got method
133

133

00:05:07.360  -->  00:05:09.250
overriding. Now with method overloading
134

134

00:05:09.250  -->  00:05:11.470
we've got functionality to reuse the
135

135

00:05:11.470  -->  00:05:13.979
method name with different parameters
136

136

00:05:13.979  -->  00:05:16.090
overloading usually happens in a single
137

137

00:05:16.090  -->  00:05:18.729
class however it can be used in a child
138

138

00:05:18.729  -->  00:05:21.639
class because the child class inherits
139

139

00:05:21.639  -->  00:05:24.100
methods from the parent class now with
140

140

00:05:24.100  -->  00:05:25.960
overloading methods they must have
141

141

00:05:25.960  -->  00:05:28.389
different parameters but they might have
142

142

00:05:28.389  -->  00:05:30.539
different return types access modifiers
143

143

00:05:30.539  -->  00:05:33.520
and/or different exceptions you know
144

144

00:05:33.520  -->  00:05:36.370
with overriding we're reusing behavior
145

145

00:05:36.370  -->  00:05:38.919
which the class has inherited from the
146

146

00:05:38.919  -->  00:05:41.500
parent class, so overriding can be in the
147

147

00:05:41.500  -->  00:05:44.410
child class or grandchild class it's
148

148

00:05:44.410  -->  00:05:46.840
always in two classes that have there is
149

149

00:05:46.840  -->  00:05:48.940
a relationship so methods that are
150

150

00:05:48.940  -->  00:05:51.280
overridden must have the same parameters
151

151

00:05:51.280  -->  00:05:53.080
and they must have the same return type
152

152

00:05:53.080  -->  00:05:57.370
or covariant return type now covariant
153

153

00:05:57.370  -->  00:06:00.160
return type is just a return type that
154

154

00:06:00.160  -->  00:06:02.320
is in the parent-child relationship so
155

155

00:06:02.320  -->  00:06:03.729
in other words that has a is a
156

156

00:06:03.729  -->  00:06:06.760
relationship overridden methods I can't
157

157

00:06:06.760  -->  00:06:09.039
have a lower access modifier, so in other
158

158

00:06:09.039  -->  00:06:10.690
words if the parent method is protected
159

159

00:06:10.690  -->  00:06:13.150
then the child method can't be private
160

160

00:06:13.150  -->  00:06:15.610
but it could have a higher modifier in
161

161

00:06:15.610  -->  00:06:18.280
other words in a scenario the parent
162

162

00:06:18.280  -->  00:06:20.800
method being protected the child method
163

163

00:06:20.800  -->  00:06:23.830
could be public. Now covariant type you
164

164

00:06:23.830  -->  00:06:25.900
might be a bit confused by that term so
165

165

00:06:25.900  -->  00:06:28.000
let's see a quick example of a covariant
166

166

00:06:28.000  -->  00:06:31.750
return type with method overriding so on
167

167

00:06:31.750  -->  00:06:33.270
the left hand side we've got two classes
168

168

00:06:33.270  -->  00:06:35.710
burger and healthy burger
169

169

00:06:35.710  -->  00:06:37.120
the fuels and methods have just been
170

170

00:06:37.120  -->  00:06:38.979
admitted for simplicity so that create
171

171

00:06:38.979  -->  00:06:40.960
any additional confusion and on the
172

172

00:06:40.960  -->  00:06:43.180
right hand side we can see the classes
173

173

00:06:43.180  -->  00:06:45.550
burger factory and it's got one method
174

174

00:06:45.550  -->  00:06:48.220
create burger that method just returns a
175

175

00:06:48.220  -->  00:06:50.740
new burger instance there's also a
176

176

00:06:50.740  -->  00:06:53.170
healthy burger factory class that
177

177

00:06:53.170  -->  00:06:55.150
extends the burger factory and overrides
178

178

00:06:55.150  -->  00:06:58.630
the create burger method so notice here
179

179

00:06:58.630  -->  00:07:00.550
how the return types are different and
180

180

00:07:00.550  -->  00:07:03.340
that's known as a covariant return type
181

181

00:07:03.340  -->  00:07:05.440
so in other words the burger class is
182

182

00:07:05.440  -->  00:07:08.200
the parent class and healthy burger is a
183

183

00:07:08.200  -->  00:07:11.710
child class, so the method create burger
184

184

00:07:11.710  -->  00:07:14.980
in the class healthy burger factory can
185

185

00:07:14.980  -->  00:07:17.740
return any child type of burger in this
186

186

00:07:17.740  -->  00:07:19.210
case we've just got one child class
187

187

00:07:19.210  -->  00:07:22.330
healthy burger. Alright, so hopefully we've
188

188

00:07:22.330  -->  00:07:23.800
now aware that they'll make sense about
189

189

00:07:23.800  -->  00:07:26.740
covariant return types and that's giving
190

190

00:07:26.740  -->  00:07:28.240
you a good recap of a method overloading
191

191

00:07:28.240  -->  00:07:31.330
vs. method overriding. I'll see you in
192

192

00:07:31.330  -->  00:07:33.960
the next video.
