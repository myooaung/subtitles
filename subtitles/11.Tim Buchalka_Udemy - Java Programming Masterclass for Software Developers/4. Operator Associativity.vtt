WEBVTT
1
1

00:00:05.240  -->  00:00:08.020
<v Tim>So we've previously looked at operator precedence,</v>
2

2

00:00:08.020  -->  00:00:11.050
but I want to talk now about operator associativity.
3

3

00:00:12.461  -->  00:00:14.490
So an expression is a construct
4

4

00:00:14.490  -->  00:00:16.620
that evaluates to a single value.
5

5

00:00:16.620  -->  00:00:18.350
Now, expressions are constructed,
6

6

00:00:18.350  -->  00:00:20.490
as we know, from operands and operators,
7

7

00:00:20.490  -->  00:00:22.360
and we've seen that in the last section.
8

8

00:00:22.360  -->  00:00:25.060
The operators in an expression indicate
9

9

00:00:25.060  -->  00:00:28.280
which operations to apply to the operands.
10

10

00:00:28.280  -->  00:00:30.720
And the order of evaluation of operators
11

11

00:00:30.720  -->  00:00:33.840
is an expression determined by the precedence,
12

12

00:00:33.840  -->  00:00:37.370
but also by the associativity of the operators.
13

13

00:00:37.370  -->  00:00:39.080
So we have talked about operator precedence
14

14

00:00:39.080  -->  00:00:41.750
in the last section, and as a brief recap,
15

15

00:00:41.750  -->  00:00:44.670
precedence is the priority order of an operator.
16

16

00:00:44.670  -->  00:00:45.850
In other words, what order
17

17

00:00:45.850  -->  00:00:48.383
Java processes operators in an expression.
18

18

00:00:49.750  -->  00:00:51.670
But what is associativity?
19

19

00:00:51.670  -->  00:00:54.270
Well, associativity is the direction
20

20

00:00:54.270  -->  00:00:56.640
of execution of operators and can be either
21

21

00:00:56.640  -->  00:00:59.900
left to right or right to left.
22

22

00:00:59.900  -->  00:01:02.840
If consecutive operators in an expression
23

23

00:01:02.840  -->  00:01:06.370
have the same precedence, associativity is used
24

24

00:01:06.370  -->  00:01:09.770
to decide the order in which those operators are evaluated.
25

25

00:01:09.770  -->  00:01:11.620
And as I mentioned, an operator
26

26

00:01:11.620  -->  00:01:14.960
can be left-associative or right-associative.
27

27

00:01:14.960  -->  00:01:17.670
Now technically, an operator can be non-associative,
28

28

00:01:17.670  -->  00:01:19.670
but we won't discuss that at this point.
29

29

00:01:21.100  -->  00:01:23.800
So, left-associative operators of the same precedence
30

30

00:01:23.800  -->  00:01:28.020
are evaluated in order from left to right in an expression.
31

31

00:01:28.020  -->  00:01:30.450
Now for example, addition and subtraction
32

32

00:01:30.450  -->  00:01:34.550
have the same precedence and they are left-associative.
33

33

00:01:34.550  -->  00:01:39.550
So in this example expression, 16 minus eight plus five,
34

34

00:01:39.840  -->  00:01:42.330
the subtraction is done first,
35

35

00:01:42.330  -->  00:01:43.720
and that's because it's to the left
36

36

00:01:43.720  -->  00:01:45.410
of the addition operator,
37

37

00:01:45.410  -->  00:01:48.420
and the addition operator is left-associative.
38

38

00:01:48.420  -->  00:01:51.220
So this is what left-associative effectively means here.
39

39

00:01:52.720  -->  00:01:55.480
Now, right-associative operators, on the other hand,
40

40

00:01:55.480  -->  00:01:57.270
of the same precedence are evaluated
41

41

00:01:57.270  -->  00:01:59.700
in order from right to left.
42

42

00:01:59.700  -->  00:02:03.710
For example, the assignment operator is right-associative.
43

43

00:02:03.710  -->  00:02:06.960
So consider the following code fragment.
44

44

00:02:06.960  -->  00:02:09.400
So, int numberTrucks equals five,
45

45

00:02:09.400  -->  00:02:11.280
int numberCars equals seven,
46

46

00:02:11.280  -->  00:02:15.890
int fleetCount equals numberTrucks plus numberCars.
47

47

00:02:15.890  -->  00:02:18.690
So the expression to the right of the equal sign
48

48

00:02:18.690  -->  00:02:22.980
is evaluated first in order to know what value to store
49

49

00:02:22.980  -->  00:02:26.260
in the variable on the left of the equal sign.
50

50

00:02:26.260  -->  00:02:28.650
So equals, or the assignment operator,
51

51

00:02:28.650  -->  00:02:31.460
is right-associative for that reason.
52

52

00:02:31.460  -->  00:02:33.810
So what's on the right hand side of the operator,
53

53

00:02:33.810  -->  00:02:36.620
the equals operator or the assignment operator,
54

54

00:02:36.620  -->  00:02:39.330
is right-associative.
55

55

00:02:39.330  -->  00:02:41.480
Right, so let's go back to our operator precedence page
56

56

00:02:41.480  -->  00:02:44.430
which we've seen from the last section again, in a browser.
57

57

00:02:45.540  -->  00:02:48.010
All right, so I'll just paste that link in.
58

58

00:02:48.010  -->  00:02:50.440
And again, it's always in the resources section.
59

59

00:02:50.440  -->  00:02:52.640
Now as you can see, the table here
60

60

00:02:52.640  -->  00:02:56.390
also talks about the associativity for each operator.
61

61

00:02:56.390  -->  00:03:00.030
So we can see that looking down at the assignment operator,
62

62

00:03:00.030  -->  00:03:01.550
down here, right down the bottom,
63

63

00:03:01.550  -->  00:03:03.940
you can see that it says to the right hand side,
64

64

00:03:03.940  -->  00:03:06.020
in the table, it's right to left.
65

65

00:03:06.020  -->  00:03:09.480
And that right most column is the associativity column.
66

66

00:03:09.480  -->  00:03:10.720
So it's telling us that it's basically
67

67

00:03:10.720  -->  00:03:12.710
evaluated right to left.
68

68

00:03:12.710  -->  00:03:14.490
And you can see that there's a few other ones there
69

69

00:03:14.490  -->  00:03:17.480
that are also right to left in that same category,
70

70

00:03:17.480  -->  00:03:21.080
plus equals, minus equals, multiplied equal,
71

71

00:03:21.080  -->  00:03:24.170
divided by equal, and modulus assignment,
72

72

00:03:24.170  -->  00:03:25.920
the modulus equal.
73

73

00:03:25.920  -->  00:03:28.440
Generally, with associativity,
74

74

00:03:28.440  -->  00:03:32.480
it's not something you need to really understand too deep,
75

75

00:03:32.480  -->  00:03:35.380
and most of it should be fairly intuitive.
76

76

00:03:35.380  -->  00:03:37.330
But let's swing back now quickly to IntelliJ
77

77

00:03:37.330  -->  00:03:40.230
and just type in a few examples to hopefully clarify this.
78

78

00:03:41.570  -->  00:03:45.120
Alright, so I'm in the same project as per the last video.
79

79

00:03:45.120  -->  00:03:48.070
All right, so if we wanted to create an expression
80

80

00:03:48.070  -->  00:03:50.010
to convert miles into kilometres,
81

81

00:03:50.010  -->  00:03:51.500
we'd need to know firstly that a mile
82

82

00:03:51.500  -->  00:03:55.530
was equal to 1.609344 kilometres.
83

83

00:03:55.530  -->  00:03:56.770
And if you wanted then to figure out
84

84

00:03:56.770  -->  00:03:59.630
what 100 miles were converted to kilometres,
85

85

00:03:59.630  -->  00:04:02.750
we'd type something like double kilometres
86

86

00:04:04.890  -->  00:04:07.840
is equal to parentheses 100d,
87

87

00:04:07.840  -->  00:04:09.780
being the number of miles we want to convert,
88

88

00:04:09.780  -->  00:04:13.140
multiplied by the literal value of 1.603944d,
89

89

00:04:16.630  -->  00:04:19.653
and that's the calculation to convert miles to kilometres.
90

90

00:04:21.040  -->  00:04:23.040
And just as a recap, the actual expression
91

91

00:04:23.040  -->  00:04:25.630
is the entire line minus the data type
92

92

00:04:25.630  -->  00:04:28.730
and minus the semicolon, we've talked about that previously.
93

93

00:04:28.730  -->  00:04:30.250
And yes, the expression includes
94

94

00:04:30.250  -->  00:04:32.720
the left hand side of the equal sign.
95

95

00:04:32.720  -->  00:04:34.390
Now, of course, the code in parentheses
96

96

00:04:34.390  -->  00:04:36.950
is also an expression in its own right, as well.
97

97

00:04:36.950  -->  00:04:38.470
But a quick challenge here,
98

98

00:04:38.470  -->  00:04:41.210
is the assignment operator equals here?
99

99

00:04:41.210  -->  00:04:43.210
Is it left or right associative?
100

100

00:04:43.210  -->  00:04:46.750
In other words, is it evaluated left to right by Java,
101

101

00:04:46.750  -->  00:04:48.720
or is it evaluated from the right hand side
102

102

00:04:48.720  -->  00:04:49.920
to the left hand side?
103

103

00:04:49.920  -->  00:04:51.190
So pause the video if you need to,
104

104

00:04:51.190  -->  00:04:52.790
and come back when you're ready.
105

105

00:04:54.600  -->  00:04:55.710
Welcome back, so did you say
106

106

00:04:55.710  -->  00:04:58.200
that the assignment operator is right-associative?
107

107

00:04:58.200  -->  00:05:00.900
In other words, it's evaluated right to left.
108

108

00:05:00.900  -->  00:05:02.800
If so, you'd be correct.
109

109

00:05:02.800  -->  00:05:04.800
So in order to assign a value,
110

110

00:05:04.800  -->  00:05:06.900
in this case, what's in parentheses,
111

111

00:05:06.900  -->  00:05:08.730
we need to know the value, right?
112

112

00:05:08.730  -->  00:05:10.660
So Java has to calculate
113

113

00:05:10.660  -->  00:05:13.440
what is on the right hand side of the equal sign
114

114

00:05:13.440  -->  00:05:15.880
in order to figure out the value to store
115

115

00:05:15.880  -->  00:05:19.400
into our variable, kilometres in this case.
116

116

00:05:19.400  -->  00:05:20.800
All right, so getting back to expressions,
117

117

00:05:20.800  -->  00:05:24.300
and expression comprises variables, values, and operators.
118

118

00:05:24.300  -->  00:05:26.280
And all of those are used in this case.
119

119

00:05:26.280  -->  00:05:29.140
So we've got a variable named kilometres,
120

120

00:05:29.140  -->  00:05:33.787
we've got literal double values, 100 and 1.609344.
121

121

00:05:33.787  -->  00:05:35.740
And of course, the operators, the equals
122

122

00:05:35.740  -->  00:05:38.500
or assignment operator and the multiplication operator.
123

123

00:05:38.500  -->  00:05:40.490
And as a recap, it's this component
124

124

00:05:40.490  -->  00:05:42.240
of the line which is the expression.
125

125

00:05:42.240  -->  00:05:45.360
And by adding the data type and a semi colon,
126

126

00:05:45.360  -->  00:05:47.730
we're then creating a valid Java statement.
127

127

00:05:47.730  -->  00:05:50.730
And we'll talk more about Java statements in the next video.
128

128

00:05:51.650  -->  00:05:54.790
Now, most operators in Java are left-associative,
129

129

00:05:54.790  -->  00:05:57.030
and we'll just go back to the browser again briefly,
130

130

00:05:57.030  -->  00:05:59.000
into that same page we were in before.
131

131

00:05:59.000  -->  00:06:01.790
So as you can see, most of them are left to right.
132

132

00:06:01.790  -->  00:06:03.580
So in other words, they're evaluated left to right.
133

133

00:06:03.580  -->  00:06:05.450
So we've got an example there
134

134

00:06:05.450  -->  00:06:07.160
of the addition and subtraction,
135

135

00:06:07.160  -->  00:06:09.650
which we talked about in the slides earlier in this video.
136

136

00:06:09.650  -->  00:06:11.337
They're evaluated left to right.
137

137

00:06:11.337  -->  00:06:12.640
And there's very few that are actually
138

138

00:06:12.640  -->  00:06:14.660
evaluated right to left.
139

139

00:06:14.660  -->  00:06:15.510
You can see down the bottom,
140

140

00:06:15.510  -->  00:06:17.330
which we talked about in the first column,
141

141

00:06:17.330  -->  00:06:18.810
but also in the second one,
142

142

00:06:18.810  -->  00:06:20.780
the ternary conditional operator,
143

143

00:06:20.780  -->  00:06:23.778
that's also evaluated right to left.
144

144

00:06:23.778  -->  00:06:24.640
All right, so that's about all
145

145

00:06:24.640  -->  00:06:26.700
I'm gonna talk about associativity.
146

146

00:06:26.700  -->  00:06:27.660
It's not something you really
147

147

00:06:27.660  -->  00:06:29.720
need to memorise or know a lot about.
148

148

00:06:29.720  -->  00:06:32.790
It's fairly intuitive after you've used it for a while.
149

149

00:06:32.790  -->  00:06:34.560
And you can always clarify your results
150

150

00:06:34.560  -->  00:06:36.400
by printing the output, which is a good idea
151

151

00:06:36.400  -->  00:06:38.920
any time you're testing out your logic
152

152

00:06:38.920  -->  00:06:40.330
or testing out a theory,
153

153

00:06:40.330  -->  00:06:43.050
to see what Java returns as an output,
154

154

00:06:43.050  -->  00:06:45.840
it's always a good idea to clarify and do that.
155

155

00:06:45.840  -->  00:06:48.130
The more important thing to understand is precedence,
156

156

00:06:48.130  -->  00:06:50.160
which we talked about in the previous section,
157

157

00:06:50.160  -->  00:06:52.510
specifically when you're not using parentheses.
158

158

00:06:52.510  -->  00:06:53.510
And again, we talked about that
159

159

00:06:53.510  -->  00:06:55.150
in depth in the last section.
160

160

00:06:55.150  -->  00:06:56.670
So I'll end the video here.
161

161

00:06:56.670  -->  00:06:59.150
And in the next one, we're gonna discuss statements,
162

162

00:06:59.150  -->  00:07:00.900
which we've already talked a bit about.
163

163

00:07:00.900  -->  00:07:02.930
And we'll also then get into white space
164

164

00:07:02.930  -->  00:07:04.780
indentation of code as well.
165

165

00:07:04.780  -->  00:07:06.453
So, see you in the next video.
