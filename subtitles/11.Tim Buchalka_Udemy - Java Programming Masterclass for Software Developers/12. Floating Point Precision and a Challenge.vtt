WEBVTT
1
1

00:00:05.430  -->  00:00:06.270
<v Tim>All right, so I continue</v>
2

2

00:00:06.270  -->  00:00:08.100
on with our floating point discussion
3

3

00:00:08.100  -->  00:00:10.670
of the float and double primitive types.
4

4

00:00:10.670  -->  00:00:12.090
Let's start out by deleting
5

5

00:00:13.310  -->  00:00:17.830
the .25 from both our float and our double variables.
6

6

00:00:17.830  -->  00:00:19.280
And let's actually print out these values.
7

7

00:00:19.280  -->  00:00:20.840
We'll do it to all three.
8

8

00:00:20.840  -->  00:00:22.847
So we'll print out the myIntValue
9

9

00:00:24.420  -->  00:00:28.040
is equal to, and we'll add to myIntValue.
10

10

00:00:28.040  -->  00:00:32.203
We do the same for the other two.
11

11

00:00:35.120  -->  00:00:37.840
MyFloatValue, get that equal
12

12

00:00:37.840  -->  00:00:41.670
to plus myFloatValue.
13

13

00:00:41.670  -->  00:00:43.363
And the same for the double.
14

14

00:00:45.506  -->  00:00:49.450
MyDoubleValue equals plus myDoubleValue.
15

15

00:00:50.826  -->  00:00:51.659
All right, so let's just run
16

16

00:00:51.659  -->  00:00:53.893
that to see what it looks like.
17

17

00:00:57.156  -->  00:00:58.500
All right, I can see there that myIntValue
18

18

00:00:58.500  -->  00:00:59.333
is showing five.
19

19

00:00:59.333  -->  00:01:00.460
No surprises there,
20

20

00:01:00.460  -->  00:01:02.370
but the float and the double are showing
21

21

00:01:02.370  -->  00:01:06.410
the points of 5.0 and 5.0,
22

22

00:01:06.410  -->  00:01:09.120
both for the float and for the double value.
23

23

00:01:09.120  -->  00:01:11.120
And obviously, that's because, no surprises,
24

24

00:01:11.120  -->  00:01:13.110
it's a floating point number.
25

25

00:01:13.110  -->  00:01:15.630
All right, so let's now try doing some division
26

26

00:01:15.630  -->  00:01:16.470
to see what happens.
27

27

00:01:16.470  -->  00:01:19.010
So we're going to go back,
28

28

00:01:19.010  -->  00:01:21.790
and we're going to put for the first line, line 17,
29

29

00:01:21.790  -->  00:01:24.350
we're gonna put divide it by two there.
30

30

00:01:24.350  -->  00:01:26.150
And we're gonna do the same for floats.
31

31

00:01:26.150  -->  00:01:27.750
So we're gonna put divide it by,
32

32

00:01:28.790  -->  00:01:29.720
and we're going to put 2f
33

33

00:01:29.720  -->  00:01:31.577
there because you wanna divide it by a floating point number
34

34

00:01:31.577  -->  00:01:32.772
and the same for the double.
35

35

00:01:32.772  -->  00:01:36.070
Divide it by 2d, in this case.
36

36

00:01:36.070  -->  00:01:38.560
So we're doing a simple division for all three.
37

37

00:01:38.560  -->  00:01:40.810
Let's actually run that and see what happens.
38

38

00:01:43.890  -->  00:01:45.580
So you can see what's happened there, now.
39

39

00:01:45.580  -->  00:01:48.470
The int type has got a value of two,
40

40

00:01:48.470  -->  00:01:51.613
but both float and the double have got the value of 2.5.
41

41

00:01:52.600  -->  00:01:55.020
So because the integer is a whole number,
42

42

00:01:55.020  -->  00:01:57.380
in effect, what's happened is it hasn't handled
43

43

00:01:57.380  -->  00:02:00.050
the remainder of the division five divided by two,
44

44

00:02:00.050  -->  00:02:02.460
and we're left with the number of times
45

45

00:02:02.460  -->  00:02:04.460
that two goes into five, which is two.
46

46

00:02:04.460  -->  00:02:05.840
But in the case of the float and the double,
47

47

00:02:05.840  -->  00:02:08.140
obviously, we've got a much more precise answer,
48

48

00:02:08.140  -->  00:02:10.510
because it can handle the decimal point.
49

49

00:02:10.510  -->  00:02:11.600
And, obviously, that's the reason
50

50

00:02:11.600  -->  00:02:13.210
why you'd want to use a floating point number
51

51

00:02:13.210  -->  00:02:15.460
to be more precise with things like division.
52

52

00:02:16.370  -->  00:02:17.460
All right, So moving on, let's change
53

53

00:02:17.460  -->  00:02:19.283
this instead of two to three.
54

54

00:02:21.730  -->  00:02:23.870
And dividing all three of them by three, this time,
55

55

00:02:23.870  -->  00:02:25.320
and we'll run the code again.
56

56

00:02:30.130  -->  00:02:31.520
And, as you can see, for the integer value
57

57

00:02:31.520  -->  00:02:34.100
we've now got one because three goes into five only once,
58

58

00:02:34.100  -->  00:02:36.510
and, again, there's no remainder because we're using
59

59

00:02:36.510  -->  00:02:38.610
an integer, but note, so the precision
60

60

00:02:38.610  -->  00:02:41.000
for the float and the double value there.
61

61

00:02:41.000  -->  00:02:42.520
Obviously, we haven't got an exact number
62

62

00:02:42.520  -->  00:02:43.930
because we're dividing,
63

63

00:02:43.930  -->  00:02:48.390
but the result for the float value is 1.6666666.
64

64

00:02:48.390  -->  00:02:50.460
So you can see there that the precision is seven
65

65

00:02:50.460  -->  00:02:51.940
for a float, but can get up to seven numbers
66

66

00:02:51.940  -->  00:02:52.940
after the decimal point,
67

67

00:02:52.940  -->  00:02:54.643
but the double has got up to 16,
68

68

00:02:54.643  -->  00:02:58.550
and you can see it's actually 16 digits there, 1.6666.
69

69

00:02:58.550  -->  00:03:00.640
I won't read them all but the last digit is a seven.
70

70

00:03:00.640  -->  00:03:02.510
So basically 16 digits.
71

71

00:03:02.510  -->  00:03:04.720
So you can see, hopefully that's really clear now,
72

72

00:03:04.720  -->  00:03:06.940
that the double is a lot more precise
73

73

00:03:06.940  -->  00:03:09.063
and has more precision than the float.
74

74

00:03:09.900  -->  00:03:11.310
All right, and just a reminder again,
75

75

00:03:11.310  -->  00:03:13.930
that in terms of the number that you're typing in there,
76

76

00:03:13.930  -->  00:03:17.040
if you're typing in a decimal number 5.25,
77

77

00:03:17.040  -->  00:03:18.690
for argument's sake,
78

78

00:03:18.690  -->  00:03:19.523
we can do something like this.
79

79

00:03:19.523  -->  00:03:22.900
I've got 5.00 divided by 3.00.
80

80

00:03:22.900  -->  00:03:26.050
We can remove the d, remembering that Java will
81

81

00:03:26.050  -->  00:03:28.110
automatically look at a floating point number,
82

82

00:03:28.110  -->  00:03:29.227
and assume it's a double.
83

83

00:03:29.227  -->  00:03:30.303
You can run that,
84

84

00:03:32.565  -->  00:03:34.360
and we get exactly the same output as a result.
85

85

00:03:34.360  -->  00:03:36.630
So you don't really need to specify d
86

86

00:03:36.630  -->  00:03:38.020
when you're using a literal there,
87

87

00:03:38.020  -->  00:03:39.950
but it's, again, as I mentioned in the last video,
88

88

00:03:39.950  -->  00:03:42.990
it's a good habit to get into to do just that.
89

89

00:03:42.990  -->  00:03:44.560
Now, you might be thinking that given
90

90

00:03:44.560  -->  00:03:46.100
that the fact that double takes up
91

91

00:03:46.100  -->  00:03:47.520
double the amount of space,
92

92

00:03:47.520  -->  00:03:49.560
it's a double precision number compared to the float,
93

93

00:03:49.560  -->  00:03:50.970
which is a single precision number,
94

94

00:03:50.970  -->  00:03:53.200
that, perhaps, you should be using the float.
95

95

00:03:53.200  -->  00:03:56.250
What's interesting, but most definitely, the double
96

96

00:03:56.250  -->  00:03:58.180
precision number, the double primitive type,
97

97

00:03:58.180  -->  00:03:59.860
in this case, is recommended.
98

98

00:03:59.860  -->  00:04:01.450
And there's a number of reasons for it.
99

99

00:04:01.450  -->  00:04:05.320
Firstly, believe it or not, it's actually faster to process
100

100

00:04:05.320  -->  00:04:06.850
on many modern computers.
101

101

00:04:06.850  -->  00:04:10.250
And that's because computers have at the chip level
102

102

00:04:10.250  -->  00:04:11.990
the functionality, for many computers,
103

103

00:04:11.990  -->  00:04:13.750
to actually deal with these double numbers
104

104

00:04:13.750  -->  00:04:16.060
faster than the equivalent float.
105

105

00:04:16.060  -->  00:04:18.410
Secondly, the Java libraries that we'll get into
106

106

00:04:18.410  -->  00:04:21.480
later in the course, that the particular math functions
107

107

00:04:21.480  -->  00:04:24.770
are often patternal-written to process doubles
108

108

00:04:24.770  -->  00:04:27.910
and not floats, and to return the result as a double.
109

109

00:04:27.910  -->  00:04:30.810
And you can see the reason that the makers of Java did that.
110

110

00:04:30.810  -->  00:04:33.090
Obviously, it's more precise, and it can handle
111

111

00:04:33.090  -->  00:04:34.070
a larger range of numbers.
112

112

00:04:34.070  -->  00:04:35.820
So you can see why they would have done that.
113

113

00:04:35.820  -->  00:04:37.780
So, consequently, you'll find that double
114

114

00:04:37.780  -->  00:04:40.810
was used a lot in the code that's out there, in the wild,
115

115

00:04:40.810  -->  00:04:42.150
in the various libraries.
116

116

00:04:42.150  -->  00:04:43.810
And for you to take advantage of these libraries,
117

117

00:04:43.810  -->  00:04:45.220
you should be using the double.
118

118

00:04:45.220  -->  00:04:46.303
And the other thing I mentioned, anyway,
119

119

00:04:46.303  -->  00:04:48.230
is that Java treats double
120

120

00:04:48.230  -->  00:04:50.260
as the default floating point number
121

121

00:04:50.260  -->  00:04:53.290
if you don't specify the d or the f.
122

122

00:04:53.290  -->  00:04:54.240
So for all those reasons,
123

123

00:04:54.240  -->  00:04:56.560
it's highly recommended that you use the double.
124

124

00:04:56.560  -->  00:04:58.330
And for that reason, I'm not gonna be using
125

125

00:04:58.330  -->  00:05:00.190
the float anymore in this course.
126

126

00:05:00.190  -->  00:05:02.560
Any floating point number code that we use,
127

127

00:05:02.560  -->  00:05:04.680
will be using the double, moving forward.
128

128

00:05:04.680  -->  00:05:05.523
Alright, so to end this video,
129

129

00:05:05.523  -->  00:05:07.853
it's time for a quick little challenge.
130

130

00:05:09.340  -->  00:05:11.320
So the challenge here is to convert
131

131

00:05:11.320  -->  00:05:14.310
a given number of pounds to kilogrammes.
132

132

00:05:14.310  -->  00:05:16.670
So here are the steps that you'll need to take.
133

133

00:05:16.670  -->  00:05:19.490
Firstly, you'll need to create a variable
134

134

00:05:19.490  -->  00:05:20.920
with the appropriate type to store
135

135

00:05:20.920  -->  00:05:22.920
the number of pounds that we want
136

136

00:05:22.920  -->  00:05:25.060
to convert into kilogrammes.
137

137

00:05:25.060  -->  00:05:26.880
Then you wanna calculate the result of that.
138

138

00:05:26.880  -->  00:05:28.750
So, i.e. the number of kilogrammes
139

139

00:05:28.750  -->  00:05:31.480
based on the contents of the variable above,
140

140

00:05:31.480  -->  00:05:32.670
then you wanna store that result
141

141

00:05:32.670  -->  00:05:36.450
into a second variable with the appropriate type.
142

142

00:05:36.450  -->  00:05:37.920
And third, we wanna print out the result
143

143

00:05:37.920  -->  00:05:39.490
of your calculation.
144

144

00:05:39.490  -->  00:05:41.280
And just to help you, as a hint there,
145

145

00:05:41.280  -->  00:05:45.170
one pound is equal to 0.45359237 of a kilogramme.
146

146

00:05:47.730  -->  00:05:49.370
So you should be able to take that and figure
147

147

00:05:49.370  -->  00:05:52.460
out how you would calculate and perform that operation.
148

148

00:05:52.460  -->  00:05:53.960
You can go through the three steps,
149

149

00:05:53.960  -->  00:05:55.020
and see what you can come up with.
150

150

00:05:55.020  -->  00:05:57.100
So pause the video, type your code in.
151

151

00:05:57.100  -->  00:05:59.250
Give it a test run, try and see if you can get the result.
152

152

00:05:59.250  -->  00:06:01.000
When you're done, come back and resume the video,
153

153

00:06:01.000  -->  00:06:02.470
and I'll go over my solution with you.
154

154

00:06:02.470  -->  00:06:03.733
So pause the video now.
155

155

00:06:05.516  -->  00:06:06.349
All right, so welcome back.
156

156

00:06:06.349  -->  00:06:08.390
Hopefully, you managed to solve that.
157

157

00:06:08.390  -->  00:06:11.500
So let's go through and come up with a solution.
158

158

00:06:11.500  -->  00:06:12.430
We're gonna be using a double
159

159

00:06:12.430  -->  00:06:13.870
here for floating point numbers.
160

160

00:06:13.870  -->  00:06:16.790
And, hopefully, you've taken in my reasoning
161

161

00:06:16.790  -->  00:06:17.950
for using the double.
162

162

00:06:17.950  -->  00:06:20.730
So I'm gonna start by typing double numberOfPounds
163

163

00:06:23.460  -->  00:06:25.960
equals, and I'm just gonna type 200d.
164

164

00:06:25.960  -->  00:06:27.090
That's just an arbitrary number.
165

165

00:06:27.090  -->  00:06:29.610
You could have used any number for a calculation.
166

166

00:06:29.610  -->  00:06:31.970
And next, we're gonna create another variable
167

167

00:06:31.970  -->  00:06:34.347
called double convertedKilograms.
168

168

00:06:36.810  -->  00:06:40.080
We set that equal to, the formula will be the number
169

169

00:06:40.080  -->  00:06:42.020
of pounds we want converted.
170

170

00:06:42.020  -->  00:06:44.446
All we need to do is multiply it by that number
171

171

00:06:44.446  -->  00:06:49.446
I gave you, which was 0.45359237d,
172

172

00:06:49.480  -->  00:06:50.313
and I'm putting a d there.
173

173

00:06:50.313  -->  00:06:51.700
We don't have to because we're dealing
174

174

00:06:51.700  -->  00:06:53.580
with a double data type, anyway.
175

175

00:06:53.580  -->  00:06:56.200
It would be assumed, but we'll do that for consistency.
176

176

00:06:56.200  -->  00:06:57.550
Semicolon, to end the line,
177

177

00:06:58.560  -->  00:07:00.920
and we'll print out the results.
178

178

00:07:00.920  -->  00:07:05.350
We'll put converted kilogrammes equals
179

179

00:07:06.680  -->  00:07:08.533
plus our convertedKilograms.
180

180

00:07:09.881  -->  00:07:11.080
All right, so let's actually run this,
181

181

00:07:11.080  -->  00:07:13.123
and make sure that it works.
182

182

00:07:15.830  -->  00:07:20.250
And you can see we got a result there 90.718474.
183

183

00:07:20.250  -->  00:07:22.360
Now, just to be sure that it's going to work,
184

184

00:07:22.360  -->  00:07:23.660
let's just open a browser.
185

185

00:07:24.500  -->  00:07:26.180
We're going to Google, and we'll say
186

186

00:07:26.180  -->  00:07:29.220
200 pounds to kilogrammes.
187

187

00:07:29.220  -->  00:07:31.890
You can say that's a common question.
188

188

00:07:31.890  -->  00:07:36.430
We've got the result there, 70 point, sorry, 90.7185.
189

189

00:07:36.430  -->  00:07:39.850
Looking at our code, 70.71847.
190

190

00:07:39.850  -->  00:07:41.620
So, obviously, that would be 7185.
191

191

00:07:41.620  -->  00:07:43.280
Google have just round it up.
192

192

00:07:43.280  -->  00:07:46.640
So, clearly, our calculation has worked well.
193

193

00:07:46.640  -->  00:07:48.090
Okay, that's good.
194

194

00:07:48.090  -->  00:07:50.293
So, hopefully, you managed to solve that challenge.
195

195

00:07:51.490  -->  00:07:52.900
All right, the other quick thing I wanted to show
196

196

00:07:52.900  -->  00:07:55.960
you was we're aware now that we can type in a double,
197

197

00:07:55.960  -->  00:08:00.747
for example, double pi equals 3.1415927d semicolon,
198

198

00:08:02.720  -->  00:08:03.950
but you can also express a number
199

199

00:08:03.950  -->  00:08:06.868
like this, using the underscores double
200

200

00:08:06.868  -->  00:08:11.868
anotherNumber is equal to, we could do 3 underscore 000,
201

201

00:08:11.980  -->  00:08:16.980
underscore 000 period 4 underscore 567 underscore 890d.
202

202

00:08:19.782  -->  00:08:21.430
So you can format it in that way, if you want.
203

203

00:08:21.430  -->  00:08:22.660
I personally don't like that.
204

204

00:08:22.660  -->  00:08:23.810
I don't like using underscores,
205

205

00:08:23.810  -->  00:08:25.890
but I'm just showing you that because you may see
206

206

00:08:25.890  -->  00:08:27.540
that out in the wild when you're coding,
207

207

00:08:27.540  -->  00:08:29.130
and wonder what it is.
208

208

00:08:29.130  -->  00:08:30.030
And just to confirm, though,
209

209

00:08:30.030  -->  00:08:32.690
even though we type it in that format,
210

210

00:08:32.690  -->  00:08:35.140
if we actually print both of these variables out,
211

211

00:08:38.560  -->  00:08:41.510
this is purely a thing just for us humans to read,
212

212

00:08:41.510  -->  00:08:43.860
because when we output it you can see the results
213

213

00:08:43.860  -->  00:08:46.790
are still stored exactly the same way, 3.1415927.
214

214

00:08:48.250  -->  00:08:49.240
And I printed out the wrong number.
215

215

00:08:49.240  -->  00:08:51.570
I was wondering why that number was coming up.
216

216

00:08:51.570  -->  00:08:52.403
That's the one I was trying
217

217

00:08:52.403  -->  00:08:53.500
to print out there, anotherNumber.
218

218

00:08:53.500  -->  00:08:54.450
We'll try it again.
219

219

00:08:57.202  -->  00:08:58.035
And there's the number.
220

220

00:08:58.035  -->  00:09:00.883
You can see it's still 3,000,000.456789.
221

221

00:09:02.490  -->  00:09:04.200
And the zero at the end was ignored
222

222

00:09:04.200  -->  00:09:05.833
because it's not needed.
223

223

00:09:06.830  -->  00:09:07.663
All right, so I just wanna
224

224

00:09:07.663  -->  00:09:09.990
finish off by talking about another important point
225

225

00:09:09.990  -->  00:09:11.440
about floating point numbers.
226

226

00:09:13.090  -->  00:09:14.350
So keep in mind that, in general,
227

227

00:09:14.350  -->  00:09:17.040
float and decimal are great primitive types
228

228

00:09:17.040  -->  00:09:19.230
for general floating point operations,
229

229

00:09:19.230  -->  00:09:20.790
but both are not great to use
230

230

00:09:20.790  -->  00:09:23.230
where precise calculations are required.
231

231

00:09:23.230  -->  00:09:24.660
Now, this is due to a limitation
232

232

00:09:24.660  -->  00:09:26.380
with how floating point numbers, in general,
233

233

00:09:26.380  -->  00:09:29.870
are stored and not a Java-specific problem, as such.
234

234

00:09:29.870  -->  00:09:31.960
But Java has a solution for this,
235

235

00:09:31.960  -->  00:09:34.620
the class called BigDecimal that overcomes
236

236

00:09:34.620  -->  00:09:37.480
this problem with calculation of precise numbers.
237

237

00:09:37.480  -->  00:09:40.250
Now we will talk about that more later in the course.
238

238

00:09:40.250  -->  00:09:42.070
You really need to get an understanding of classes,
239

239

00:09:42.070  -->  00:09:43.770
and so forth, before we move into that.
240

240

00:09:43.770  -->  00:09:45.450
For now, just keep in the back of your mind
241

241

00:09:45.450  -->  00:09:48.030
that when precise calculations are necessary,
242

242

00:09:48.030  -->  00:09:50.850
such as when performing say currency calculations,
243

243

00:09:50.850  -->  00:09:52.740
then floating point types, like I've used here,
244

244

00:09:52.740  -->  00:09:54.520
should generally not be used.
245

245

00:09:54.520  -->  00:09:55.900
But for general calculations,
246

246

00:09:55.900  -->  00:09:56.733
like you've seen here,
247

247

00:09:56.733  -->  00:09:58.610
converting kilogrammes and things of that nature,
248

248

00:09:58.610  -->  00:10:00.880
float and double are probably just fine.
249

249

00:10:00.880  -->  00:10:02.600
And again, double would be the recommendation.
250

250

00:10:02.600  -->  00:10:05.420
That would be the floating point type you'd generally use.
251

251

00:10:05.420  -->  00:10:08.040
We'll discuss this in a lot more detail
252

252

00:10:08.040  -->  00:10:10.400
in a future video, as we go through the course.
253

253

00:10:10.400  -->  00:10:11.960
All right, so that's it now for the floating
254

254

00:10:11.960  -->  00:10:13.520
point data types.
255

255

00:10:13.520  -->  00:10:16.060
In the next video we'll look at two more primitive types
256

256

00:10:16.060  -->  00:10:20.010
in Java, namely the char and the Boolean primitive types.
257

257

00:10:20.010  -->  00:10:21.760
So I'll see you in that next video.
