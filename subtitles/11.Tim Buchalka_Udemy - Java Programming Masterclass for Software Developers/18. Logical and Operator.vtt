WEBVTT
1
1

00:00:05.209  -->  00:00:06.180
<v Instructor>All right, so let's switch now</v>
2

2

00:00:06.180  -->  00:00:08.110
to another primitive type to continue our
3

3

00:00:08.110  -->  00:00:11.260
exploration of the if then statement.
4

4

00:00:11.260  -->  00:00:12.910
I'm going to continue on outside
5

5

00:00:12.910  -->  00:00:15.580
of the code block introduced in the last video
6

6

00:00:15.580  -->  00:00:19.750
and I'm going to type int topScore is equal to 100
7

7

00:00:20.994  -->  00:00:22.060
and on the next line I'm going to type
8

8

00:00:22.060  -->  00:00:25.967
if parentheses topScore is equal to 100
9

9

00:00:25.967  -->  00:00:27.930
and we can see we're using the two equals signs there
10

10

00:00:27.930  -->  00:00:29.370
because it's not an assignment,
11

11

00:00:29.370  -->  00:00:30.760
we're checking to see whether
12

12

00:00:30.760  -->  00:00:33.290
they are the same, they equal the same.
13

13

00:00:33.290  -->  00:00:36.056
Then we're gonna add our code block as I talked about
14

14

00:00:36.056  -->  00:00:38.806
and I'm gonna print our message you got the high score.
15

15

00:00:41.880  -->  00:00:43.820
So you can see that that equal to operator,
16

16

00:00:43.820  -->  00:00:47.490
which is the correct name for the operator on line 54,
17

17

00:00:47.490  -->  00:00:51.030
that's comparing topScore to the literal value 100.
18

18

00:00:51.030  -->  00:00:52.400
So it should show our output
19

19

00:00:52.400  -->  00:00:55.090
that we've defined in our code block on line 55
20

20

00:00:55.090  -->  00:00:57.690
because we've defined topScore as 100.
21

21

00:00:57.690  -->  00:00:59.840
So if we run this we should see the output.
22

22

00:01:01.670  -->  00:01:03.790
All right, so we can see we've got you got the high score,
23

23

00:01:03.790  -->  00:01:05.630
so that's working correctly,
24

24

00:01:05.630  -->  00:01:06.940
but we can also do something like this,
25

25

00:01:06.940  -->  00:01:09.210
we can use the not equal to operator,
26

26

00:01:09.210  -->  00:01:11.120
which is one that we haven't looked at yet,
27

27

00:01:11.120  -->  00:01:13.060
and that's the exclamation mark and the equals.
28

28

00:01:13.060  -->  00:01:15.520
So I'm gonna come back there and change that to
29

29

00:01:15.520  -->  00:01:18.220
exclamation mark, which is not, and the equals.
30

30

00:01:18.220  -->  00:01:20.660
So we're asking the question with our operator,
31

31

00:01:20.660  -->  00:01:23.940
is topScore not equal to 100?
32

32

00:01:23.940  -->  00:01:25.440
So that's the expression.
33

33

00:01:25.440  -->  00:01:27.640
So in that case clearly if we had previously had
34

34

00:01:27.640  -->  00:01:29.580
topScore equal 100 work,
35

35

00:01:29.580  -->  00:01:32.580
topScore not equal to 100 shouldn't work.
36

36

00:01:32.580  -->  00:01:34.080
So let's run that and this time
37

37

00:01:34.080  -->  00:01:36.080
we shouldn't see you got the high score,
38

38

00:01:37.500  -->  00:01:40.290
and no, that wasn't displayed, so that would be correct,
39

39

00:01:40.290  -->  00:01:42.710
and the reason is topScore does equal 100
40

40

00:01:42.710  -->  00:01:43.790
so therefore the expression
41

41

00:01:43.790  -->  00:01:46.060
topScore not equal to 100 was false,
42

42

00:01:46.060  -->  00:01:49.310
and therefore the line on 55 wasn't executed.
43

43

00:01:49.310  -->  00:01:50.790
Now we can also use another operator,
44

44

00:01:50.790  -->  00:01:52.590
the greater than operator.
45

45

00:01:52.590  -->  00:01:55.800
Let's replace that with greater than.
46

46

00:01:55.800  -->  00:01:58.390
So that's now checking to see or it's asking the question,
47

47

00:01:58.390  -->  00:02:02.527
does topScore, or is topScore greater than the value 100?
48

48

00:02:02.527  -->  00:02:03.980
And we know the answer's no to that
49

49

00:02:03.980  -->  00:02:05.730
but let's run it anyway to confirm.
50

50

00:02:06.700  -->  00:02:08.510
Then we haven't got the you got the high score message
51

51

00:02:08.510  -->  00:02:09.800
which is correct
52

52

00:02:09.800  -->  00:02:12.950
because we've used the greater than operator
53

53

00:02:12.950  -->  00:02:15.220
and obviously topScore is equal to 100,
54

54

00:02:15.220  -->  00:02:17.490
so is topScore greater than 100 is false
55

55

00:02:17.490  -->  00:02:19.700
because of course topScore is 100.
56

56

00:02:19.700  -->  00:02:21.620
But we can define that further, instead of using
57

57

00:02:21.620  -->  00:02:24.177
greater than, we can use greater than or equal to,
58

58

00:02:24.177  -->  00:02:26.090
and we can do that with the greater than
59

59

00:02:26.090  -->  00:02:27.720
and equals sign together.
60

60

00:02:27.720  -->  00:02:29.300
Now we're testing whether topScore
61

61

00:02:29.300  -->  00:02:32.330
is greater than or equal to 100.
62

62

00:02:32.330  -->  00:02:34.930
So it's one operator to cover both those scenarios,
63

63

00:02:34.930  -->  00:02:38.400
and if we run that this time we should see the output,
64

64

00:02:38.400  -->  00:02:39.790
and we're seeing the output because of course
65

65

00:02:39.790  -->  00:02:41.340
topScore is equal to 100,
66

66

00:02:41.340  -->  00:02:43.470
and the greater than equal operator checks
67

67

00:02:43.470  -->  00:02:46.690
to see whether the value is 100 or greater in this case,
68

68

00:02:46.690  -->  00:02:50.470
or whatever is on the right hand side, or the right operand.
69

69

00:02:50.470  -->  00:02:52.100
And we can contrast that and do a similar thing,
70

70

00:02:52.100  -->  00:02:54.590
we've also got a less than operator.
71

71

00:02:54.590  -->  00:02:56.663
We'll just run through these pretty quickly.
72

72

00:02:57.650  -->  00:02:59.000
Less than operator won't come out
73

73

00:02:59.000  -->  00:03:02.850
because topScore isn't less than 100, it is equal to 100,
74

74

00:03:02.850  -->  00:03:05.120
but we can use less than equal.
75

75

00:03:05.120  -->  00:03:06.860
Similar thing to greater than equal.
76

76

00:03:06.860  -->  00:03:07.980
This time we're testing to see
77

77

00:03:07.980  -->  00:03:10.340
whether topScore is 100 or less.
78

78

00:03:10.340  -->  00:03:12.510
We run that and we should see the output,
79

79

00:03:12.510  -->  00:03:13.910
and again we're seeing that because
80

80

00:03:13.910  -->  00:03:16.223
topScore is equal to 100.
81

81

00:03:17.360  -->  00:03:19.460
Now just to confirm that this is working,
82

82

00:03:19.460  -->  00:03:21.570
so if this topScore less than 100,
83

83

00:03:21.570  -->  00:03:23.860
we come back and change that again.
84

84

00:03:23.860  -->  00:03:26.610
Let's make the topScore value to be 80.
85

85

00:03:26.610  -->  00:03:28.890
Just wanted to show you that it does actually work.
86

86

00:03:28.890  -->  00:03:30.320
So now we're testing to see whether
87

87

00:03:30.320  -->  00:03:31.930
topScore's less than 100.
88

88

00:03:31.930  -->  00:03:34.570
Now that we've defined it as 80 on line 53
89

89

00:03:34.570  -->  00:03:37.680
of course that should be true, the expression on line 54,
90

90

00:03:37.680  -->  00:03:38.713
so when we run this,
91

91

00:03:41.040  -->  00:03:43.110
this time we have got the you got the high score message
92

92

00:03:43.110  -->  00:03:46.250
because topScore is less than 100,
93

93

00:03:46.250  -->  00:03:49.420
because we defined it to be 80 on line 53.
94

94

00:03:49.420  -->  00:03:51.000
All right, so let's introduce another variable.
95

95

00:03:51.000  -->  00:03:53.770
I want to show you a slightly more complex example,
96

96

00:03:53.770  -->  00:03:58.763
so I'm going to type int secondTopScore is equal to 60.
97

97

00:04:00.340  -->  00:04:01.330
Now you can get a bit more complex,
98

98

00:04:01.330  -->  00:04:03.000
we can type something like if
99

99

00:04:03.000  -->  00:04:05.650
then our parentheses and we can put topScore,
100

100

00:04:06.680  -->  00:04:09.233
if that's greater than secondTopScore,
101

101

00:04:10.950  -->  00:04:14.300
two ampersand characters which stands for and,
102

102

00:04:14.300  -->  00:04:17.540
topScore less than 100
103

103

00:04:18.791  -->  00:04:20.580
and I'm going to add a code block there
104

104

00:04:20.580  -->  00:04:22.280
and I'm gonna print out a message,
105

105

00:04:24.270  -->  00:04:26.030
greater than second top score
106

106

00:04:28.450  -->  00:04:29.443
and less than 100.
107

107

00:04:31.260  -->  00:04:32.340
So looking at this code,
108

108

00:04:32.340  -->  00:04:35.020
this is actually performing two tests now.
109

109

00:04:35.020  -->  00:04:37.320
So it's saying if the topScore
110

110

00:04:37.320  -->  00:04:39.620
is greater than the secondTopScore,
111

111

00:04:39.620  -->  00:04:41.400
and we're also saying, but,
112

112

00:04:41.400  -->  00:04:44.640
also we want to check whether the topScore is less than 100.
113

113

00:04:44.640  -->  00:04:46.560
So the two ampersands put together like that
114

114

00:04:46.560  -->  00:04:49.460
are is what's called a logical and operator.
115

115

00:04:49.460  -->  00:04:52.360
So it ensures that both operands are true,
116

116

00:04:52.360  -->  00:04:54.640
or tests to see whether both operands
117

117

00:04:54.640  -->  00:04:57.520
to the left of the double ampersand and to the right,
118

118

00:04:57.520  -->  00:05:01.329
both of those have to be set to true, have a value of true.
119

119

00:05:01.329  -->  00:05:03.070
And there's also a single ampersand you can use
120

120

00:05:03.070  -->  00:05:06.710
which is called a bitwise and, which works in a similar way
121

121

00:05:06.710  -->  00:05:08.240
but you shouldn't really use that here,
122

122

00:05:08.240  -->  00:05:10.280
you need to use the both ampersands.
123

123

00:05:10.280  -->  00:05:12.360
We'll talk about bitwise operators later
124

124

00:05:12.360  -->  00:05:15.150
which are something that you use far less regularly
125

125

00:05:15.150  -->  00:05:17.780
than you would use the logical and operator
126

126

00:05:17.780  -->  00:05:19.390
that we're using here.
127

127

00:05:19.390  -->  00:05:21.840
So in this case we should find the message will be printed
128

128

00:05:21.840  -->  00:05:23.390
and the reason is topScore firstly
129

129

00:05:23.390  -->  00:05:25.657
is greater than secondTopScore,
130

130

00:05:25.657  -->  00:05:28.419
and secondTopScore is 60,
131

131

00:05:28.419  -->  00:05:30.647
but we've assigned the test, the two ampersands,
132

132

00:05:30.647  -->  00:05:33.009
if this topScore is less than 100,
133

133

00:05:33.009  -->  00:05:35.154
and of course topScore is set to 80.
134

134

00:05:35.154  -->  00:05:36.571
So if we run that
135

135

00:05:39.374  -->  00:05:41.540
greater than second top score and less than 100
136

136

00:05:41.540  -->  00:05:43.497
is correctly output.
137

137

00:05:43.497  -->  00:05:45.030
And just to confirm that this is working let's make
138

138

00:05:45.030  -->  00:05:48.700
the secondTopScore, make that value 81
139

139

00:05:48.700  -->  00:05:50.670
which now changes the scenario
140

140

00:05:50.670  -->  00:05:52.060
because now suddenly secondTopScore
141

141

00:05:52.060  -->  00:05:53.610
is greater than topScore.
142

142

00:05:53.610  -->  00:05:54.460
So let's run that
143

143

00:05:57.035  -->  00:05:58.800
and you can see we haven't got the message
144

144

00:05:58.800  -->  00:06:00.820
showing that it only needs one side,
145

145

00:06:00.820  -->  00:06:03.800
for the left operand or right operand to be false,
146

146

00:06:03.800  -->  00:06:05.090
and then the entire condition
147

147

00:06:05.090  -->  00:06:07.440
or in this case the code in the code block
148

148

00:06:07.440  -->  00:06:08.463
won't be executed.
149

149

00:06:09.370  -->  00:06:12.790
All right, so that's a more advanced if then statement.
150

150

00:06:12.790  -->  00:06:14.800
Let's finish the video here and then in the next one
151

151

00:06:14.800  -->  00:06:17.840
we'll continue our exploration of operators still further
152

152

00:06:17.840  -->  00:06:19.110
and we'll also be looking at something
153

153

00:06:19.110  -->  00:06:21.350
called operator precedence.
154

154

00:06:21.350  -->  00:06:22.800
So see you in the next video.
