WEBVTT
1
1

00:00:05.030  -->  00:00:07.570
<v Tim>All right, so let's introduce two other data types</v>
2

2

00:00:07.570  -->  00:00:10.110
or, more correctly, primitive types in Java,
3

3

00:00:10.110  -->  00:00:11.797
the byte and the short.
4

4

00:00:11.797  -->  00:00:14.330
And we'll introduce a third one later on.
5

5

00:00:14.330  -->  00:00:16.820
So I'm gonna start by closing down the run window.
6

6

00:00:16.820  -->  00:00:19.720
You can click on this little option down there to do that.
7

7

00:00:20.585  -->  00:00:23.320
And I'm going to start typing after line 16,
8

8

00:00:23.320  -->  00:00:25.450
byte this time, B-Y-T-E,
9

9

00:00:25.450  -->  00:00:28.590
and we'll call it my min byte value.
10

10

00:00:28.590  -->  00:00:30.360
We're gonna do the same thing we've done for integer,
11

11

00:00:30.360  -->  00:00:31.193
but for byte.
12

12

00:00:31.193  -->  00:00:33.320
We're gonna make that equal to, this time
13

13

00:00:33.320  -->  00:00:35.110
instead of integer, we're going to use the word byte,
14

14

00:00:35.110  -->  00:00:37.420
with a capital b, with a period,
15

15

00:00:37.420  -->  00:00:39.930
and min underscore value, semicolon.
16

16

00:00:39.930  -->  00:00:41.900
We'll do the same for the maximum value.
17

17

00:00:41.900  -->  00:00:45.650
My max byte value is equal to byte,
18

18

00:00:45.650  -->  00:00:47.390
with a capital b, period.
19

19

00:00:47.390  -->  00:00:49.253
This time max underscore value.
20

20

00:00:50.320  -->  00:00:52.650
That's in print that matters, we've done above,
21

21

00:00:52.650  -->  00:00:54.263
and we'll put byte,
22

22

00:00:56.260  -->  00:00:59.640
minimum value is equal to closing
23

23

00:00:59.640  -->  00:01:04.640
double quote plus then our my byte min value.
24

24

00:01:05.678  -->  00:01:07.423
And we'll take a copy of that line again.
25

25

00:01:08.380  -->  00:01:11.083
Paste, and we'll just change this to maximum.
26

26

00:01:13.259  -->  00:01:15.580
Then we need to change the variable on our line 21
27

27

00:01:15.580  -->  00:01:16.743
to be max as well.
28

28

00:01:19.760  -->  00:01:20.900
All right, so let's run this,
29

29

00:01:20.900  -->  00:01:22.320
and we can see what the minimum
30

30

00:01:22.320  -->  00:01:24.193
and maximum ranges are for a byte.
31

31

00:01:26.780  -->  00:01:29.210
Now you can see that in that case for a byte,
32

32

00:01:29.210  -->  00:01:30.950
the range is quite small.
33

33

00:01:30.950  -->  00:01:33.457
The minimum value you can go down to is minus 128,
34

34

00:01:33.457  -->  00:01:36.770
and the maximum value is 127.
35

35

00:01:36.770  -->  00:01:37.880
So the range is quite small,
36

36

00:01:37.880  -->  00:01:40.300
and, frankly, you probably won't be using
37

37

00:01:40.300  -->  00:01:42.220
the byte data type a lot.
38

38

00:01:42.220  -->  00:01:43.680
Now maybe if you had a requirement to store
39

39

00:01:43.680  -->  00:01:46.010
a lot of numbers that are within that range,
40

40

00:01:46.010  -->  00:01:47.300
and you wanna save memory,
41

41

00:01:47.300  -->  00:01:49.440
but also could be a good idea if you were doing
42

42

00:01:49.440  -->  00:01:52.260
that to use the byte instead of, say, an int.
43

43

00:01:52.260  -->  00:01:53.700
If you wanted the fact that it were
44

44

00:01:53.700  -->  00:01:55.120
a small range documented.
45

45

00:01:55.120  -->  00:01:58.550
So using a small data type is actually code documentation,
46

46

00:01:58.550  -->  00:02:00.700
in the sense that someone would read the code,
47

47

00:02:00.700  -->  00:02:02.440
and then note that you're using a data type,
48

48

00:02:02.440  -->  00:02:04.890
in this case that is quite small,
49

49

00:02:04.890  -->  00:02:07.050
and that there was a specific reason for it.
50

50

00:02:07.050  -->  00:02:09.040
But with that said, today's modern computers mean
51

51

00:02:09.040  -->  00:02:11.630
that you perhaps can be a little bit lazy with memory,
52

52

00:02:11.630  -->  00:02:13.460
and not worry too much about space,
53

53

00:02:13.460  -->  00:02:15.000
and how much it's being used.
54

54

00:02:15.000  -->  00:02:16.500
But keep in mind, there can also be
55

55

00:02:16.500  -->  00:02:18.810
performance reasons that come into account.
56

56

00:02:18.810  -->  00:02:21.840
A smaller data type takes up less space,
57

57

00:02:21.840  -->  00:02:23.850
and can be quicker to access.
58

58

00:02:23.850  -->  00:02:25.820
But, in general, another thing that probably won't affect
59

59

00:02:25.820  -->  00:02:28.280
you much due to the speed of today's computers,
60

60

00:02:28.280  -->  00:02:31.600
but certainly was a factor when Java was first created.
61

61

00:02:31.600  -->  00:02:34.150
All right, so that's the byte data type.
62

62

00:02:34.150  -->  00:02:35.750
So let's create another one now.
63

63

00:02:35.750  -->  00:02:36.970
The next one we're gonna look at,
64

64

00:02:36.970  -->  00:02:40.140
the next primitive type is our short value.
65

65

00:02:40.140  -->  00:02:41.460
So let's do the same thing with that.
66

66

00:02:41.460  -->  00:02:43.090
We're gonna select that.
67

67

00:02:43.090  -->  00:02:45.440
I'm taking a copy of the full lines there,
68

68

00:02:45.440  -->  00:02:49.640
and I'm going to paste the code into there.
69

69

00:02:49.640  -->  00:02:50.537
All right, now we've got an error there,
70

70

00:02:50.537  -->  00:02:51.940
and that's because we're reusing
71

71

00:02:51.940  -->  00:02:53.660
the same variable names.
72

72

00:02:53.660  -->  00:02:56.330
So let's actually use the Search and Replace functionality
73

73

00:02:56.330  -->  00:02:59.010
built into IntelliJ to make these changes
74

74

00:02:59.010  -->  00:03:00.360
for us automatically.
75

75

00:03:00.360  -->  00:03:02.630
I'm gonna go to Find, Replace.
76

76

00:03:02.630  -->  00:03:03.900
All right, so first things first.
77

77

00:03:03.900  -->  00:03:06.253
I'm gonna change byte with a capital b.
78

78

00:03:07.370  -->  00:03:10.370
I'm gonna change that to short with a capital s.
79

79

00:03:10.370  -->  00:03:13.300
So I'm gonna make sure that to Match case is checked there,
80

80

00:03:13.300  -->  00:03:15.990
so we're only updating the ones that match
81

81

00:03:15.990  -->  00:03:18.762
precisely with the case, replace all.
82

82

00:03:18.762  -->  00:03:21.120
Then what I'm going to do is come back here,
83

83

00:03:21.120  -->  00:03:23.870
and replace byte with a lower case b,
84

84

00:03:23.870  -->  00:03:26.520
with short with a lowercase b,
85

85

00:03:26.520  -->  00:03:31.240
and do a oops, and do a replace all for that as well.
86

86

00:03:31.240  -->  00:03:32.790
And that should be our code change.
87

87

00:03:32.790  -->  00:03:35.240
So basically we've just swapped out the word byte
88

88

00:03:35.240  -->  00:03:36.820
for the word short.
89

89

00:03:36.820  -->  00:03:38.550
And we should be able to now print out those values.
90

90

00:03:38.550  -->  00:03:40.880
So let's do that and see what range
91

91

00:03:40.880  -->  00:03:42.833
a short can contain.
92

92

00:03:43.870  -->  00:03:46.753
We can see the short minimum value is minus 32768,
93

93

00:03:47.840  -->  00:03:50.277
the maximum value for a short is 32,767.
94

94

00:03:53.200  -->  00:03:55.660
So both the byte and the short
95

95

00:03:55.660  -->  00:03:58.260
have the same overflow and underflow issue.
96

96

00:03:58.260  -->  00:04:00.980
But obviously with their own range of numbers.
97

97

00:04:00.980  -->  00:04:02.660
So let's have a brief talk about how much
98

98

00:04:02.660  -->  00:04:05.770
space each of the data types we've talked to take
99

99

00:04:05.770  -->  00:04:06.603
up in memory.
100

100

00:04:08.220  -->  00:04:09.710
All right, so I wanna talk about the size
101

101

00:04:09.710  -->  00:04:12.370
of primitives types, and what width means.
102

102

00:04:12.370  -->  00:04:15.500
So a byte occupies eight bits.
103

103

00:04:15.500  -->  00:04:18.630
Now a bit is not directly represented in a primitive type.
104

104

00:04:18.630  -->  00:04:20.107
We have a Boolean, which is not really the same thing,
105

105

00:04:20.107  -->  00:04:22.490
and that we'll discuss in a future video.
106

106

00:04:22.490  -->  00:04:26.110
But we could just assume that a byte occupies eight bits.
107

107

00:04:26.110  -->  00:04:30.230
Now we can say, therefore, that a byte has a width of eight.
108

108

00:04:30.230  -->  00:04:32.040
Now a short, on the other hand, we saw that it can
109

109

00:04:32.040  -->  00:04:33.900
store a larger range of numbers,
110

110

00:04:33.900  -->  00:04:36.990
and for that reason it occupies 16 bits,
111

111

00:04:36.990  -->  00:04:39.910
and has a width of, therefore, 16.
112

112

00:04:39.910  -->  00:04:42.090
Now an integer has a much larger range,
113

113

00:04:42.090  -->  00:04:45.320
as we saw again, compared to the byte and the short.
114

114

00:04:45.320  -->  00:04:49.560
While that occupies 32 bits, it has a width of 32.
115

115

00:04:49.560  -->  00:04:51.550
So the point here is that each primitive type
116

116

00:04:51.550  -->  00:04:54.140
occupies a different amount of memory.
117

117

00:04:54.140  -->  00:04:56.110
We can see that an int now needs four times
118

118

00:04:56.110  -->  00:04:59.350
the amount of space that a byte does, as an example.
119

119

00:04:59.350  -->  00:05:01.040
Now it's not particularly relevant
120

120

00:05:01.040  -->  00:05:02.050
for you to know these numbers,
121

121

00:05:02.050  -->  00:05:03.710
but suddenly they could come up
122

122

00:05:03.710  -->  00:05:04.680
as an interview question,
123

123

00:05:04.680  -->  00:05:06.570
and it's useful to know, in general,
124

124

00:05:06.570  -->  00:05:09.563
that certain data types take up more space than others.
125

125

00:05:11.010  -->  00:05:13.150
All right, so there's one more data type,
126

126

00:05:13.150  -->  00:05:14.840
and that's of use for you where you've got a number
127

127

00:05:14.840  -->  00:05:15.680
that you wanna process
128

128

00:05:15.680  -->  00:05:18.380
that's larger than the amount for an int.
129

129

00:05:18.380  -->  00:05:20.320
So we call that one the long.
130

130

00:05:20.320  -->  00:05:23.360
So let's go ahead and add some code for that.
131

131

00:05:23.360  -->  00:05:27.823
So we just type long my long value is equal to 100.
132

132

00:05:30.090  -->  00:05:32.600
Now technically what I've done there is wrong
133

133

00:05:32.600  -->  00:05:34.700
because when you're assigning a long value,
134

134

00:05:34.700  -->  00:05:37.570
you need to put the letter l on the end of it,
135

135

00:05:37.570  -->  00:05:40.220
and that tells the computer that it's a long value.
136

136

00:05:40.220  -->  00:05:42.770
So I can go ahead and do something like this,
137

137

00:05:42.770  -->  00:05:44.180
we can put an l there,
138

138

00:05:44.180  -->  00:05:46.107
and I can see that if you hover over it,
139

139

00:05:46.107  -->  00:05:49.320
"Long literal ends with lowercase l."
140

140

00:05:49.320  -->  00:05:51.140
And that actually tells that could be confusing
141

141

00:05:51.140  -->  00:05:53.770
as lowercase l looks very similar to a one.
142

142

00:05:53.770  -->  00:05:55.890
So for that reason, when you're doing it,
143

143

00:05:55.890  -->  00:05:58.290
I suggest you always use the uppercase l
144

144

00:05:58.290  -->  00:06:01.110
to make it clearly stand out, as we've done here.
145

145

00:06:01.110  -->  00:06:03.890
So a long has got a width of 64,
146

146

00:06:03.890  -->  00:06:05.560
which is obviously double the size of an int,
147

147

00:06:05.560  -->  00:06:08.700
which we established had a width of 32.
148

148

00:06:08.700  -->  00:06:11.110
So it means it's double the width of an integer.
149

149

00:06:11.110  -->  00:06:12.300
So the actual number we can store
150

150

00:06:12.300  -->  00:06:14.960
is huge, though, in a long primitive type.
151

151

00:06:14.960  -->  00:06:17.920
It's actually two to the power of 63.
152

152

00:06:17.920  -->  00:06:20.320
So let's grab the code we've done for short,
153

153

00:06:20.320  -->  00:06:21.970
and do a similar thing that we've done previously.
154

154

00:06:21.970  -->  00:06:23.740
We're gonna copy it.
155

155

00:06:23.740  -->  00:06:26.240
I'm gonna paste it under our long definition,
156

156

00:06:26.240  -->  00:06:28.603
our declaration for my long value, on line 28.
157

157

00:06:29.830  -->  00:06:32.737
And we'll do a copy, a Search and Replace there.
158

158

00:06:32.737  -->  00:06:35.440
And it's Control + R we saw last time with the shortcut.
159

159

00:06:35.440  -->  00:06:37.340
So firstly I'm gonna do it with short,
160

160

00:06:38.920  -->  00:06:41.380
replace that with long with a capital l,
161

161

00:06:41.380  -->  00:06:44.861
making sure Match case is selected, replace all.
162

162

00:06:44.861  -->  00:06:46.640
And we're gonna do the same for short as well,
163

163

00:06:46.640  -->  00:06:51.640
so short to long, same thing there, replace all.
164

164

00:06:54.182  -->  00:06:55.460
All right, so now that've done that,
165

165

00:06:55.460  -->  00:06:58.190
let's just close down that Search and Replace,
166

166

00:06:58.190  -->  00:07:00.760
and right click and run this.
167

167

00:07:00.760  -->  00:07:04.090
And let's see how big the range of numbers can be.
168

168

00:07:04.090  -->  00:07:06.290
Now I just may need to scroll this up a little bit,
169

169

00:07:06.290  -->  00:07:08.300
contrast to the size of an integer,
170

170

00:07:08.300  -->  00:07:10.233
and it's significantly larger, as you can see.
171

171

00:07:10.233  -->  00:07:12.880
It's a pretty big range of numbers there.
172

172

00:07:12.880  -->  00:07:15.050
Now, yes, it has got the same type of overflow
173

173

00:07:15.050  -->  00:07:16.460
and underflow problem we've discussed
174

174

00:07:16.460  -->  00:07:18.560
for the other primitive types.
175

175

00:07:18.560  -->  00:07:20.060
Now just minimise this again,
176

176

00:07:20.060  -->  00:07:22.083
we're gonna go down, and we'll close it off.
177

177

00:07:23.750  -->  00:07:25.930
So, by default, Java considers a number you type
178

178

00:07:25.930  -->  00:07:28.830
as an integer, unless you add a letter on the end,
179

179

00:07:28.830  -->  00:07:30.530
as we did on line 28.
180

180

00:07:30.530  -->  00:07:33.660
This forces Java to treat that number as a long.
181

181

00:07:33.660  -->  00:07:35.030
But you might be wondering, though, why the long
182

182

00:07:35.030  -->  00:07:36.600
declaration worked without an l.
183

183

00:07:36.600  -->  00:07:40.640
After all, when we first started, we didn't put an l there.
184

184

00:07:40.640  -->  00:07:42.040
There you can see clearly we haven't got an error
185

185

00:07:42.040  -->  00:07:44.530
on line 28 by removing the l.
186

186

00:07:44.530  -->  00:07:47.800
Well the reason is that an int fits fully into a long
187

187

00:07:47.800  -->  00:07:49.950
because obviously a long is twice the width.
188

188

00:07:49.950  -->  00:07:51.317
So Java is smart enough to know that,
189

189

00:07:51.317  -->  00:07:54.170
and just converts the int to a long for us,
190

190

00:07:54.170  -->  00:07:55.890
instead of giving us an error.
191

191

00:07:55.890  -->  00:07:57.970
However, if we try and type in a literal value
192

192

00:07:57.970  -->  00:08:00.900
for a long without the l, we will get an error.
193

193

00:08:00.900  -->  00:08:02.200
So we know that previously we've used
194

194

00:08:02.200  -->  00:08:03.600
the maximum range there.
195

195

00:08:03.600  -->  00:08:06.480
So if I copy this maximum int test number there,
196

196

00:08:06.480  -->  00:08:08.330
which we know was the maximum number.
197

197

00:08:09.530  -->  00:08:12.590
So I come down here and create a new variable,
198

198

00:08:12.590  -->  00:08:16.613
we'll call it long big long literal value equals...
199

199

00:08:18.620  -->  00:08:20.397
Firstly if we do that, we put a semicolon on there,
200

200

00:08:20.397  -->  00:08:22.820
and that works, we know that that's the maximum
201

201

00:08:22.820  -->  00:08:25.030
integer number, and so IntelliJ is
202

202

00:08:25.030  -->  00:08:26.200
quite happy to accept that.
203

203

00:08:26.200  -->  00:08:29.600
But if we change that, and put in underscore 234,
204

204

00:08:29.600  -->  00:08:31.450
suddenly we've got an error there.
205

205

00:08:31.450  -->  00:08:33.097
And we can see there, that's the hint,
206

206

00:08:33.097  -->  00:08:34.950
"Integer number is too large."
207

207

00:08:34.950  -->  00:08:37.630
So clearly Java is telling us that it's still treating
208

208

00:08:37.630  -->  00:08:39.200
that number as an integer.
209

209

00:08:39.200  -->  00:08:41.740
And you can see that's why the default whole number
210

210

00:08:41.740  -->  00:08:42.840
is an integer in Java.
211

211

00:08:44.166  -->  00:08:46.980
So we've put an l on the end there to treat it as a long,
212

212

00:08:46.980  -->  00:08:49.960
and, you can see, suddenly, that number has been accepted.
213

213

00:08:49.960  -->  00:08:52.770
And just to confirm that, we can then print that out.
214

214

00:08:52.770  -->  00:08:55.130
Let's just go ahead and do that, do an s out,
215

215

00:08:55.130  -->  00:08:56.670
big long literal value.
216

216

00:08:56.670  -->  00:08:57.870
And if we run that code,
217

217

00:09:01.290  -->  00:09:02.770
see down the bottom, our largest number
218

218

00:09:02.770  -->  00:09:03.950
clearly is correct.
219

219

00:09:03.950  -->  00:09:05.940
It's got the 234 on the end,
220

220

00:09:05.940  -->  00:09:08.450
and I'm not gonna attempt to read that number out.
221

221

00:09:08.450  -->  00:09:09.680
Then just before we finish the video,
222

222

00:09:09.680  -->  00:09:11.670
Java's also smart when it comes to converting
223

223

00:09:11.670  -->  00:09:14.040
numbers from int to, say, a short.
224

224

00:09:14.040  -->  00:09:16.560
So it knows if the literal value we're going to use
225

225

00:09:16.560  -->  00:09:18.540
is not going to fit into a short.
226

226

00:09:18.540  -->  00:09:19.373
So to see what I mean there,
227

227

00:09:19.373  -->  00:09:23.703
if I add this code, if I type in short,
228

228

00:09:24.740  -->  00:09:29.740
big short literal value is equal to 32768.
229

229

00:09:30.210  -->  00:09:34.000
We established that 32767 was the maximum number,
230

230

00:09:34.000  -->  00:09:36.189
and we could have a look at our code there,
231

231

00:09:36.189  -->  00:09:38.870
short maximum value is 32767.
232

232

00:09:38.870  -->  00:09:40.520
So clearly we've got an error there,
233

233

00:09:40.520  -->  00:09:42.207
and it's saying, "Incompatible types, required
234

234

00:09:42.207  -->  00:09:44.340
"a short, found an int."
235

235

00:09:44.340  -->  00:09:46.053
But if we change that to a seven,
236

236

00:09:47.500  -->  00:09:50.110
which we know is valid, the error is just disappeared,
237

237

00:09:50.110  -->  00:09:51.850
and Java is quite happy with that
238

238

00:09:51.850  -->  00:09:53.630
because it knows even though the number is an int
239

239

00:09:53.630  -->  00:09:56.950
which potentially is larger than the maximum
240

240

00:09:56.950  -->  00:09:57.870
that can fit in a short,
241

241

00:09:57.870  -->  00:09:59.680
in this particular case, the literal number
242

242

00:09:59.680  -->  00:10:01.790
we've entered doesn't exceed that,
243

243

00:10:01.790  -->  00:10:04.623
and it can actually fit directly into a short.
244

244

00:10:05.890  -->  00:10:07.240
Right, so let's finish the video here.
245

245

00:10:07.240  -->  00:10:09.010
And in the next one, we'll start talking
246

246

00:10:09.010  -->  00:10:11.980
about a bit of arithmetic using these data types,
247

247

00:10:11.980  -->  00:10:13.220
and then we'll talk about another important
248

248

00:10:13.220  -->  00:10:15.320
concept called casting.
249

249

00:10:15.320  -->  00:10:17.020
So I'll see you in the next video.
