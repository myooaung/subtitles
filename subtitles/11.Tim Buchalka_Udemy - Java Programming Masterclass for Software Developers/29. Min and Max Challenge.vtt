WEBVTT
1
1

00:00:03.830  -->  00:00:06.899
Alright time for the next challenge this
2

2

00:00:06.899  -->  00:00:10.559
is the minimum and maximum challenge so
3

3

00:00:10.559  -->  00:00:11.940
you were to read numbers from the
4

4

00:00:11.940  -->  00:00:14.280
console entered by the user and print
5

5

00:00:14.280  -->  00:00:16.500
the minimum and maximum number the user
6

6

00:00:16.500  -->  00:00:18.720
has entered in that session so before
7

7

00:00:18.720  -->  00:00:20.340
the user enters each number print the
8

8

00:00:20.340  -->  00:00:22.199
message enter number now if the user
9

9

00:00:22.199  -->  00:00:25.109
enters an invalid number break out of the loop
10

10

00:00:25.109  -->  00:00:27.449
and print the minimum and maximum number
11

11

00:00:27.449  -->  00:00:29.429
has been entered so far in that session
12

12

00:00:29.429  -->  00:00:31.529
and you want to use an endless while
13

13

00:00:31.529  -->  00:00:33.840
loop here and Korean approach it with
14

14

00:00:33.840  -->  00:00:37.200
the name min and max input challenge so
15

15

00:00:37.200  -->  00:00:38.579
that's it see if you can figure out that
16

16

00:00:38.579  -->  00:00:40.829
to challenge pause the video now and try
17

17

00:00:40.829  -->  00:00:42.750
it out and once you're ready to see my
18

18

00:00:42.750  -->  00:00:44.489
version of the code come back and we'll
19

19

00:00:44.489  -->  00:00:47.870
go through it so pause the video now
20

20

00:00:47.870  -->  00:00:50.250
okay welcome back hopefully you managed
21

21

00:00:50.250  -->  00:00:52.199
to get it working alright so let's get
22

22

00:00:52.199  -->  00:00:54.059
started first thing we need to do is
23

23

00:00:54.059  -->  00:00:55.890
create our scanner as well as the close
24

24

00:00:55.890  -->  00:00:57.690
method call so let's do that as we've
25

25

00:00:57.690  -->  00:01:01.730
been doing in recent videos so a scanner
26

26

00:01:01.730  -->  00:01:05.689
scanner is equal to new scanner
27

27

00:01:05.689  -->  00:01:11.070
parenthesis system dot in we need to
28

28

00:01:11.070  -->  00:01:12.390
make sure here that we choose the right
29

29

00:01:12.390  -->  00:01:17.040
one scanner to us sorry scanner Java dot
30

30

00:01:17.040  -->  00:01:18.750
util and again you know you've got the
31

31

00:01:18.750  -->  00:01:20.460
right one there if you see import Java
32

32

00:01:20.460  -->  00:01:22.740
dot util dot scanner let's have the code
33

33

00:01:22.740  -->  00:01:24.810
to close the scanner it's a good habit
34

34

00:01:24.810  -->  00:01:25.409
to get into
35

35

00:01:25.409  -->  00:01:27.330
and the code we're going to be typing
36

36

00:01:27.330  -->  00:01:29.970
will be in the middle alright we no need
37

37

00:01:29.970  -->  00:01:32.100
to read the numbers and then from them
38

38

00:01:32.100  -->  00:01:34.020
figure out the minimum and maximum
39

39

00:01:34.020  -->  00:01:35.820
number we're going to start by adding
40

40

00:01:35.820  -->  00:01:38.369
two in variables to track the minimum
41

41

00:01:38.369  -->  00:01:41.579
and maximum numbers so int min equals
42

42

00:01:41.579  -->  00:01:46.740
zero it's max equals zero next we want
43

43

00:01:46.740  -->  00:01:48.540
to loop through until the user enters an
44

44

00:01:48.540  -->  00:01:50.310
invalid number so I'm going to do a
45

45

00:01:50.310  -->  00:01:53.970
while true and enter sleep again as we
46

46

00:01:53.970  -->  00:01:56.969
discussed in the previous challenge and
47

47

00:01:56.969  -->  00:01:59.280
again the while true loop which we're
48

48

00:01:59.280  -->  00:02:01.439
doing there on line 14 creates an
49

49

00:02:01.439  -->  00:02:03.899
endless loop in other words a loop that
50

50

00:02:03.899  -->  00:02:06.299
doesn't complete to stop it we can use a
51

51

00:02:06.299  -->  00:02:07.920
break statement that'll break out of the
52

52

00:02:07.920  -->  00:02:09.690
loop when the user enters an invalid
53

53

00:02:09.690  -->  00:02:11.819
value now to test whether it's a valid
54

54

00:02:11.819  -->  00:02:13.780
number will again use the has next
55

55

00:02:13.780  -->  00:02:16.390
in method and break out or break out of
56

56

00:02:16.390  -->  00:02:18.120
the loop rather when it returns false
57

57

00:02:18.120  -->  00:02:20.319
before the user starts entering numbers
58

58

00:02:20.319  -->  00:02:22.209
we need to print out that message that
59

59

00:02:22.209  -->  00:02:24.400
we had in the challenge so let's go
60

60

00:02:24.400  -->  00:02:31.600
ahead and do that first enter number all
61

61

00:02:31.600  -->  00:02:33.340
right so the next step now is to get the
62

62

00:02:33.340  -->  00:02:35.770
input from the user so let's create as
63

63

00:02:35.770  -->  00:02:38.230
we've done previously boolean variable
64

64

00:02:38.230  -->  00:02:42.480
here for boolean is an int equal scanner
65

65

00:02:42.480  -->  00:02:46.150
dot has next int no space is out so we
66

66

00:02:46.150  -->  00:02:48.640
can read it a bit better again we've got
67

67

00:02:48.640  -->  00:02:50.980
this sub warning here talking about
68

68

00:02:50.980  -->  00:02:52.690
unreachable code because we haven't yet
69

69

00:02:52.690  -->  00:02:54.910
coded a way to exit out of the while
70

70

00:02:54.910  -->  00:02:56.980
loop so what we're going to do there is
71

71

00:02:56.980  -->  00:02:59.530
put a test as we did also in the last
72

72

00:02:59.530  -->  00:03:03.430
challenge if isn't it else what we're
73

73

00:03:03.430  -->  00:03:05.290
going to do is out of the code block if
74

74

00:03:05.290  -->  00:03:07.030
it's not an int we'll add that as well
75

75

00:03:07.030  -->  00:03:10.330
we're also go down outside of that if
76

76

00:03:10.330  -->  00:03:15.900
code block and put scanner dot next line
77

77

00:03:15.900  -->  00:03:18.040
again we've talked about the reasons why
78

78

00:03:18.040  -->  00:03:22.180
we need to use that we're just will
79

79

00:03:22.180  -->  00:03:23.440
handle input because we know now what
80

80

00:03:23.440  -->  00:03:25.329
that's so all about alright so in this
81

81

00:03:25.329  -->  00:03:27.850
case the else block will execute it's a
82

82

00:03:27.850  -->  00:03:30.549
boolean variable is an int is false
83

83

00:03:30.549  -->  00:03:32.530
meaning that the user has entered an
84

84

00:03:32.530  -->  00:03:34.720
invalid number so that is the case the
85

85

00:03:34.720  -->  00:03:36.670
code will move to the or statement so
86

86

00:03:36.670  -->  00:03:38.530
therefore our break statement should be
87

87

00:03:38.530  -->  00:03:40.540
in the else component about if loop
88

88

00:03:40.540  -->  00:03:41.920
since our goal of course was to break
89

89

00:03:41.920  -->  00:03:44.019
out of the loop when invalid input was
90

90

00:03:44.019  -->  00:03:46.030
entered so we simply need to add a break
91

91

00:03:46.030  -->  00:03:48.820
in the else I think of the error
92

92

00:03:48.820  -->  00:03:50.760
disappears on line 28 now I've done that
93

93

00:03:50.760  -->  00:03:52.780
all right so let's add some more code
94

94

00:03:52.780  -->  00:03:54.970
now in the troop component of the if
95

95

00:03:54.970  -->  00:03:57.910
statement so down here we can have to
96

96

00:03:57.910  -->  00:04:03.900
type in here int number equals scanner
97

97

00:04:03.900  -->  00:04:08.799
dot next int all right now we need to do
98

98

00:04:08.799  -->  00:04:10.900
some tests here firstly we want to test
99

99

00:04:10.900  -->  00:04:12.040
if the number is greater than the
100

100

00:04:12.040  -->  00:04:14.079
current value of max then we want to
101

101

00:04:14.079  -->  00:04:16.900
sign assign that number to max since it
102

102

00:04:16.900  -->  00:04:18.340
would then presently be the largest
103

103

00:04:18.340  -->  00:04:20.799
value so to check that we can use an if
104

104

00:04:20.799  -->  00:04:22.750
statement that tests if the number is
105

105

00:04:22.750  -->  00:04:25.150
greater than max so let's do that test
106

106

00:04:25.150  -->  00:04:27.840
we'll type it in we're going to put if
107

107

00:04:27.840  -->  00:04:33.759
number is greater than max and open up a
108

108

00:04:33.759  -->  00:04:35.979
code block I'm going to type max equals
109

109

00:04:35.979  -->  00:04:42.160
number okay we'll just place this out so
110

110

00:04:42.160  -->  00:04:44.620
it's more readable so right so in
111

111

00:04:44.620  -->  00:04:46.270
summary once the users entered a valid
112

112

00:04:46.270  -->  00:04:48.669
number meaning is an INT is equal to
113

113

00:04:48.669  -->  00:04:50.800
true within testing if the number is
114

114

00:04:50.800  -->  00:04:53.139
greater than the current max we're doing
115

115

00:04:53.139  -->  00:04:56.440
that test on line 23 if it is we assign
116

116

00:04:56.440  -->  00:04:57.490
that number to max
117

117

00:04:57.490  -->  00:04:59.919
meaning that ensuring rather that max
118

118

00:04:59.919  -->  00:05:02.650
always has the maximum number assigned
119

119

00:05:02.650  -->  00:05:05.020
to it you know to get the minimum number
120

120

00:05:05.020  -->  00:05:07.660
we can do something very similar but the
121

121

00:05:07.660  -->  00:05:09.789
test will go we are doing a less than
122

122

00:05:09.789  -->  00:05:11.410
test instead of a greater than test so
123

123

00:05:11.410  -->  00:05:17.770
it'll be if number is less than min then
124

124

00:05:17.770  -->  00:05:22.599
we will put min equals number so again
125

125

00:05:22.599  -->  00:05:24.099
you saw the logic was very similar to
126

126

00:05:24.099  -->  00:05:25.870
max the difference being here that we're
127

127

00:05:25.870  -->  00:05:27.729
now looking for the minimum value from
128

128

00:05:27.729  -->  00:05:29.919
the users input so if the number entered
129

129

00:05:29.919  -->  00:05:31.419
by the user is less than the current
130

130

00:05:31.419  -->  00:05:33.639
minimum the condition we'll test is true
131

131

00:05:33.639  -->  00:05:36.310
and the newest input that has been
132

132

00:05:36.310  -->  00:05:38.800
entered will be replaced as the current
133

133

00:05:38.800  -->  00:05:41.020
valley for min all right so we've got
134

134

00:05:41.020  -->  00:05:43.030
most of the code done what we no need to
135

135

00:05:43.030  -->  00:05:44.729
do is print out the minimum and maximum
136

136

00:05:44.729  -->  00:05:47.289
valleys after the while loop so let's go
137

137

00:05:47.289  -->  00:05:48.940
ahead and do that and into the bottom of
138

138

00:05:48.940  -->  00:05:51.400
the wall loop after the loop is ended
139

139

00:05:51.400  -->  00:05:53.430
before the close these scale about close
140

140

00:05:53.430  -->  00:05:58.770
we're going to put min equals plus min
141

141

00:05:58.770  -->  00:06:07.840
plus comma max equals plus max all right
142

142

00:06:07.840  -->  00:06:09.130
now before we finish this challenge
143

143

00:06:09.130  -->  00:06:11.560
there is a small bug that we have in
144

144

00:06:11.560  -->  00:06:13.810
this code firstly I'm going to
145

145

00:06:13.810  -->  00:06:15.669
demonstrate the bug and then we can
146

146

00:06:15.669  -->  00:06:18.220
implement a solution so let's run the
147

147

00:06:18.220  -->  00:06:24.010
application first all right so I'm going
148

148

00:06:24.010  -->  00:06:25.419
to begin by entering your three numbers
149

149

00:06:25.419  -->  00:06:30.880
so I'm going to start with 1 1 2 3 we're
150

150

00:06:30.880  -->  00:06:32.830
going to break out on the loop by typing
151

151

00:06:32.830  -->  00:06:36.130
the variety you can see once I've done
152

152

00:06:36.130  -->  00:06:37.900
that for the output is now min equals 0
153

153

00:06:37.900  -->  00:06:39.919
max equals 3
154

154

00:06:39.919  -->  00:06:43.669
technically that's incorrect and the
155

155

00:06:43.669  -->  00:06:45.259
reason is we've never entered the number
156

156

00:06:45.259  -->  00:06:47.990
zero the minimum number was we entered
157

157

00:06:47.990  -->  00:06:50.360
was 1 so consequently there's a small
158

158

00:06:50.360  -->  00:06:52.400
bug that we've associated with our logic
159

159

00:06:52.400  -->  00:06:54.770
but there are multiple ways to fix it
160

160

00:06:54.770  -->  00:06:56.719
now one way would be to use a boolean
161

161

00:06:56.719  -->  00:06:59.150
flag that checks if the user is entering
162

162

00:06:59.150  -->  00:07:01.340
the first number and then sets min and
163

163

00:07:01.340  -->  00:07:03.949
max to that value another way is to set
164

164

00:07:03.949  -->  00:07:06.710
min and max to extremely high and low in
165

165

00:07:06.710  -->  00:07:09.590
finales respectively let's first see the
166

166

00:07:09.590  -->  00:07:11.419
solution with a flag with a boolean flag
167

167

00:07:11.419  -->  00:07:14.120
so right after the max or close this
168

168

00:07:14.120  -->  00:07:16.879
window down so we get more space so
169

169

00:07:16.879  -->  00:07:18.529
right after our max declarations up here
170

170

00:07:18.529  -->  00:07:22.180
at the top I'm going to type in boolean
171

171

00:07:22.180  -->  00:07:27.139
first it was true so that is the flag
172

172

00:07:27.139  -->  00:07:29.569
brilliant first it was true now you
173

173

00:07:29.569  -->  00:07:31.069
might be wondering what I mean when I
174

174

00:07:31.069  -->  00:07:33.800
say a flag well basically it's a boolean
175

175

00:07:33.800  -->  00:07:35.779
value meaning that the value can be true
176

176

00:07:35.779  -->  00:07:38.270
or false in other words on or off so
177

177

00:07:38.270  -->  00:07:39.229
that's why
178

178

00:07:39.229  -->  00:07:41.659
Boyet boolean is often referred to as a
179

179

00:07:41.659  -->  00:07:44.120
flag you can only have two states true
180

180

00:07:44.120  -->  00:07:46.339
or false so we've set this boolean to
181

181

00:07:46.339  -->  00:07:48.650
true while we wait for the user to enter
182

182

00:07:48.650  -->  00:07:50.900
an initial number when the user enters
183

183

00:07:50.900  -->  00:07:52.819
the first number what we can do is use
184

184

00:07:52.819  -->  00:07:55.550
an if statement to set the boolean the
185

185

00:07:55.550  -->  00:07:57.830
flag here to false that's worth selling
186

186

00:07:57.830  -->  00:07:59.779
both min and Max to the first numbers
187

187

00:07:59.779  -->  00:08:02.389
value by selling the flag to false after
188

188

00:08:02.389  -->  00:08:04.399
the first number the next numbers will
189

189

00:08:04.399  -->  00:08:06.199
not meet the conditions of the first and
190

190

00:08:06.199  -->  00:08:08.839
therefore will not be replaced so let's
191

191

00:08:08.839  -->  00:08:10.219
put the code in and you'll see what I
192

192

00:08:10.219  -->  00:08:11.719
mean here's I'm going to come down put
193

193

00:08:11.719  -->  00:08:16.339
the if after the scan next line so I'm
194

194

00:08:16.339  -->  00:08:21.680
going to put if parentheses first like
195

195

00:08:21.680  -->  00:08:25.069
so now as previously stated after the
196

196

00:08:25.069  -->  00:08:27.169
user enters the first number we want to
197

197

00:08:27.169  -->  00:08:29.629
set the boolean flag to false since the
198

198

00:08:29.629  -->  00:08:31.939
user can obviously only enter one first
199

199

00:08:31.939  -->  00:08:33.919
number and the next will set the min and
200

200

00:08:33.919  -->  00:08:36.529
Max to the value of the first number so
201

201

00:08:36.529  -->  00:08:37.820
for that code we're gonna start by
202

202

00:08:37.820  -->  00:08:41.089
topping first in the code block in the
203

203

00:08:41.089  -->  00:08:42.620
earth without it here we're going to
204

204

00:08:42.620  -->  00:08:47.480
type first equals false min equals
205

205

00:08:47.480  -->  00:08:52.060
number and Max equals number as well
206

206

00:08:52.060  -->  00:08:54.500
so let's review this if statement one
207

207

00:08:54.500  -->  00:08:55.250
last time
208

208

00:08:55.250  -->  00:08:57.649
first we're checking if the first number
209

209

00:08:57.649  -->  00:09:00.320
flag is set to true and attesting then
210

210

00:09:00.320  -->  00:09:03.470
on line 24 which it should be since we
211

211

00:09:03.470  -->  00:09:05.269
set it to true before the wallet you can
212

212

00:09:05.269  -->  00:09:07.190
see the code there on line 13 on screen
213

213

00:09:07.190  -->  00:09:09.560
when the user enters their first number
214

214

00:09:09.560  -->  00:09:11.810
the if statement will execute in other
215

215

00:09:11.810  -->  00:09:14.389
words the code in the code from from
216

216

00:09:14.389  -->  00:09:16.820
line 25 through 27 will execute in the
217

217

00:09:16.820  -->  00:09:19.190
first cut and that line 25 when we first
218

218

00:09:19.190  -->  00:09:22.430
set the first flag to false now when the
219

219

00:09:22.430  -->  00:09:24.320
user enters a second number the if
220

220

00:09:24.320  -->  00:09:26.240
statement won't execute and that's
221

221

00:09:26.240  -->  00:09:29.360
because first is now set to false so in
222

222

00:09:29.360  -->  00:09:30.649
other words this if statement will truly
223

223

00:09:30.649  -->  00:09:32.870
ne execute once when the user enters the
224

224

00:09:32.870  -->  00:09:35.480
first number and then never again at
225

225

00:09:35.480  -->  00:09:36.709
least that's the theory but let's
226

226

00:09:36.709  -->  00:09:38.329
actually check it out to make sure that
227

227

00:09:38.329  -->  00:09:44.149
it works all right so I'm gonna run it
228

228

00:09:44.149  -->  00:09:45.589
again as you saw I'm going to enter the
229

229

00:09:45.589  -->  00:09:49.459
same three numbers again 1 2 3 then an
230

230

00:09:49.459  -->  00:09:52.970
eight-oh exit this time we get the
231

231

00:09:52.970  -->  00:09:55.329
output the min equals 1 and Max equals 3
232

232

00:09:55.329  -->  00:09:57.260
indicating that our solution will work
233

233

00:09:57.260  -->  00:09:58.760
this time because of course previously
234

234

00:09:58.760  -->  00:10:01.790
the min value was set to zero we never
235

235

00:10:01.790  -->  00:10:04.069
saw that minimum value get set to 1 all
236

236

00:10:04.069  -->  00:10:05.380
right so let's run the application again
237

237

00:10:05.380  -->  00:10:07.639
this time we're gonna enter the values
238

238

00:10:07.639  -->  00:10:13.220
in reverse 3 2 1 and then an a again so
239

239

00:10:13.220  -->  00:10:16.370
that the parsing fails and we still got
240

240

00:10:16.370  -->  00:10:19.579
min equals 1 max equals 3 all right so
241

241

00:10:19.579  -->  00:10:21.310
that's worked so that's one solution
242

242

00:10:21.310  -->  00:10:23.600
using a simple flag here at boolean
243

243

00:10:23.600  -->  00:10:25.699
we've easily managed to overcome that
244

244

00:10:25.699  -->  00:10:27.829
bug so that's it the challenge is now
245

245

00:10:27.829  -->  00:10:29.209
complete I'm just going to close down
246

246

00:10:29.209  -->  00:10:31.370
this window but before we finish the
247

247

00:10:31.370  -->  00:10:33.079
video I'm going to show you one more
248

248

00:10:33.079  -->  00:10:35.660
solution that doesn't require a flag now
249

249

00:10:35.660  -->  00:10:37.730
the idea with this solution is to set
250

250

00:10:37.730  -->  00:10:40.490
max to the minimum value that an INT can
251

251

00:10:40.490  -->  00:10:43.069
hold now we can do this because the user
252

252

00:10:43.069  -->  00:10:45.260
will only be able to enter a number that
253

253

00:10:45.260  -->  00:10:47.870
is greater or equal to the minimum int
254

254

00:10:47.870  -->  00:10:50.480
value now the maximum in value is
255

255

00:10:50.480  -->  00:10:52.670
approximately positive 2 billion while
256

256

00:10:52.670  -->  00:10:54.769
the minimum is approximately negative 2
257

257

00:10:54.769  -->  00:10:57.110
billion so with that in mind if we set
258

258

00:10:57.110  -->  00:11:00.019
max to negative 2 billion any number
259

259

00:11:00.019  -->  00:11:01.430
what the user enters will always be
260

260

00:11:01.430  -->  00:11:03.890
greater than negative 2 billion so this
261

261

00:11:03.890  -->  00:11:05.450
means that we don't need a flare
262

262

00:11:05.450  -->  00:11:07.520
to ensure that the values of Max and min
263

263

00:11:07.520  -->  00:11:09.860
are set to numbers that the user enters
264

264

00:11:09.860  -->  00:11:12.110
as long as they enter at least one
265

265

00:11:12.110  -->  00:11:14.180
number now this might sound confusing
266

266

00:11:14.180  -->  00:11:15.770
but it should hopefully become clearer
267

267

00:11:15.770  -->  00:11:18.530
in your mind once you see the code the
268

268

00:11:18.530  -->  00:11:19.730
first things I'm going to do is comment
269

269

00:11:19.730  -->  00:11:21.950
out the code that's using the flag so I
270

270

00:11:21.950  -->  00:11:23.210
need to comment out the line here where
271

271

00:11:23.210  -->  00:11:26.780
we declared the first a flag and also
272

272

00:11:26.780  -->  00:11:29.420
the code that does did the test there
273

273

00:11:29.420  -->  00:11:31.880
when I point that out then this time
274

274

00:11:31.880  -->  00:11:33.680
instead of setting min to zero and Max
275

275

00:11:33.680  -->  00:11:35.660
to zero we're going to set min to the
276

276

00:11:35.660  -->  00:11:38.270
maximum value and it can hold I'm going
277

277

00:11:38.270  -->  00:11:41.360
to come up here to min on line 11 so I'm
278

278

00:11:41.360  -->  00:11:48.970
going to set that to 2 1 4 7 4 8 3 6 4 7
279

279

00:11:48.970  -->  00:11:51.020
so that's the minimum value and
280

280

00:11:51.020  -->  00:11:52.100
therefore the maximum I'm going to set
281

281

00:11:52.100  -->  00:11:55.970
that to minors two one four seven four
282

282

00:11:55.970  -->  00:12:02.510
eight three six four eight so in review
283

283

00:12:02.510  -->  00:12:04.190
our min value is set to the highest
284

284

00:12:04.190  -->  00:12:06.050
number and it can hold and our max
285

285

00:12:06.050  -->  00:12:08.900
variable to the lowest any number that
286

286

00:12:08.900  -->  00:12:10.880
the user enters will always be the equal
287

287

00:12:10.880  -->  00:12:12.370
or within the range of those two numbers
288

288

00:12:12.370  -->  00:12:14.600
so let's test this out to see what if it
289

289

00:12:14.600  -->  00:12:20.000
works so we're going to enter a number 1
290

290

00:12:20.000  -->  00:12:24.290
2 3 or a number range 1 2 3 and a to
291

291

00:12:24.290  -->  00:12:26.480
exit and you can see we've correctly got
292

292

00:12:26.480  -->  00:12:29.120
the output min equals 1 max equals 3 and
293

293

00:12:29.120  -->  00:12:30.710
just to be heard of a sense sure let's
294

294

00:12:30.710  -->  00:12:36.050
run it again 3 2 1 a we still got the
295

295

00:12:36.050  -->  00:12:39.350
same result min equals 1 mexic was 3 so
296

296

00:12:39.350  -->  00:12:41.060
that's another solution to solve that
297

297

00:12:41.060  -->  00:12:43.280
particular problem and again as
298

298

00:12:43.280  -->  00:12:44.750
mentioned in previous challenges it's
299

299

00:12:44.750  -->  00:12:46.610
possible to generate correct solutions
300

300

00:12:46.610  -->  00:12:48.890
with code that's different so if your
301

301

00:12:48.890  -->  00:12:50.270
code doesn't match mine that's
302

302

00:12:50.270  -->  00:12:52.640
completely okay the main goal is to get
303

303

00:12:52.640  -->  00:12:54.680
the application working while meeting
304

304

00:12:54.680  -->  00:12:56.810
the challenge requirements and you can
305

305

00:12:56.810  -->  00:12:58.190
even expand on the challenge and add
306

306

00:12:58.190  -->  00:13:00.740
more features and so forth alright so
307

307

00:13:00.740  -->  00:13:02.930
just before I end this video I want to
308

308

00:13:02.930  -->  00:13:04.700
show you the same solution but using
309

309

00:13:04.700  -->  00:13:07.460
constants so every primitive number type
310

310

00:13:07.460  -->  00:13:09.290
has constants that represent the minimum
311

311

00:13:09.290  -->  00:13:11.750
and the maximum value that primitives
312

312

00:13:11.750  -->  00:13:14.000
can hold now you may have noticed how
313

313

00:13:14.000  -->  00:13:15.770
comer said it was topping at the minimum
314

314

00:13:15.770  -->  00:13:18.200
and maximum values the topped on lines
315

315

00:13:18.200  -->  00:13:19.020
he live in a 12
316

316

00:13:19.020  -->  00:13:21.300
since we know that we need them maximum
317

317

00:13:21.300  -->  00:13:22.920
and minimum values in it can hold here
318

318

00:13:22.920  -->  00:13:24.779
what we can do is we come back up here
319

319

00:13:24.779  -->  00:13:27.089
say to minimum for example and type
320

320

00:13:27.089  -->  00:13:32.839
integer the capital y dot max value
321

321

00:13:32.839  -->  00:13:34.709
instead of actually topping up the
322

322

00:13:34.709  -->  00:13:37.470
numbers and you may recall that in a
323

323

00:13:37.470  -->  00:13:38.940
previous video we used the integer class
324

324

00:13:38.940  -->  00:13:41.279
with methods like pars int but this
325

325

00:13:41.279  -->  00:13:43.410
class also contains these two constants
326

326

00:13:43.410  -->  00:13:46.020
min value and Max value so I'm going to
327

327

00:13:46.020  -->  00:13:49.370
add Max value on the next line then
328

328

00:13:49.370  -->  00:13:52.140
integers dot min value I should say I
329

329

00:13:52.140  -->  00:13:54.120
think I said max value so we've got
330

330

00:13:54.120  -->  00:13:56.459
soaring minimum to the integer drop max
331

331

00:13:56.459  -->  00:13:58.529
value and Max to the integer dot min
332

332

00:13:58.529  -->  00:14:02.370
value and basically we've got now these
333

333

00:14:02.370  -->  00:14:04.020
two things set up and these are the
334

334

00:14:04.020  -->  00:14:06.450
constant so for example with Max value
335

335

00:14:06.450  -->  00:14:08.430
that's the maximum number and it can
336

336

00:14:08.430  -->  00:14:10.890
have and 4 min value that's the minimum
337

337

00:14:10.890  -->  00:14:13.709
value and it can have and that's exactly
338

338

00:14:13.709  -->  00:14:15.690
what we need in this case so keep in
339

339

00:14:15.690  -->  00:14:17.490
mind that every primitive numeric type
340

340

00:14:17.490  -->  00:14:19.110
has these max value and min value
341

341

00:14:19.110  -->  00:14:21.060
constants in their respective wrapper
342

342

00:14:21.060  -->  00:14:22.920
class and again we'll talk more about
343

343

00:14:22.920  -->  00:14:25.860
wrapper classes later in the course so
344

344

00:14:25.860  -->  00:14:27.390
instead of typing those large numbers we
345

345

00:14:27.390  -->  00:14:29.550
can just use these constants which were
346

346

00:14:29.550  -->  00:14:31.800
easy to type but also easy to understand
347

347

00:14:31.800  -->  00:14:35.100
what are we trying to achieve alright so
348

348

00:14:35.100  -->  00:14:36.390
the codes pretty much the same as what
349

349

00:14:36.390  -->  00:14:38.579
it was before let's test it to make sure
350

350

00:14:38.579  -->  00:14:42.420
that it still works so going into a
351

351

00:14:42.420  -->  00:14:46.290
value 1 2 3 and a to exit me at the same
352

352

00:14:46.290  -->  00:14:48.480
results all right let's do one final
353

353

00:14:48.480  -->  00:14:49.740
test now I'm going to run it one more
354

354

00:14:49.740  -->  00:14:51.570
time I'm going to enter the valley's
355

355

00:14:51.570  -->  00:14:53.370
I'll enter some really big numbers this
356

356

00:14:53.370  -->  00:14:55.430
time so I will do two one four seven
357

357

00:14:55.430  -->  00:14:59.579
four eight three six four five which is
358

358

00:14:59.579  -->  00:15:01.980
very close to the maximum number and
359

359

00:15:01.980  -->  00:15:03.660
I'll enter a number that's very close to
360

360

00:15:03.660  -->  00:15:05.190
the minimum negative of two one four
361

361

00:15:05.190  -->  00:15:09.870
seven four eight three over six three
362

362

00:15:09.870  -->  00:15:15.209
three a to exit and you can see now that
363

363

00:15:15.209  -->  00:15:16.589
we've got the minimum correctly set to
364

364

00:15:16.589  -->  00:15:18.360
the negative two one four seven four
365

365

00:15:18.360  -->  00:15:20.399
eight three six three three and the
366

366

00:15:20.399  -->  00:15:22.649
maximum now set to two one four seven
367

367

00:15:22.649  -->  00:15:25.980
four eight three six four five all right
368

368

00:15:25.980  -->  00:15:27.150
so that's it I hope you enjoyed this
369

369

00:15:27.150  -->  00:15:29.100
challenge and learnt a lot from it.
370

370

00:15:29.100  -->  00:15:32.510
I'll see you in the next video.
