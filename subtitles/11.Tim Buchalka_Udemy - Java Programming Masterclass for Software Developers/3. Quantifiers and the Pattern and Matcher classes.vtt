WEBVTT
1
1

00:00:05.010  -->  00:00:06.780
ok so let's now have a bit of a
2

2

00:00:06.780  -->  00:00:09.870
discussion about quantifies so in
3

3

00:00:09.870  -->  00:00:12.180
earlier example we used a regular
4

4

00:00:12.180  -->  00:00:13.500
expression and what I'm going to do is take
5

5

00:00:13.500  -->  00:00:16.650
a copy that and paste it down here and
6

6

00:00:16.650  -->  00:00:18.120
we'll just have work on that and see
7

7

00:00:18.120  -->  00:00:21.720
how this relates to quantifies so here's
8

8

00:00:21.720  -->  00:00:24.180
the earlier regular expression that we
9

9

00:00:24.180  -->  00:00:26.340
used and of course that was looking for
10

10

00:00:26.340  -->  00:00:28.380
a match at the start of the alphanumeric
11

11

00:00:28.380  -->  00:00:34.170
string that we just run that you see
12

12

00:00:34.170  -->  00:00:36.090
the first three letters have been
13

13

00:00:36.090  -->  00:00:38.420
replaced well in actual fact the first
14

14

00:00:38.420  -->  00:00:41.210
seven letters ABCDEE have been replaced
15

15

00:00:41.210  -->  00:00:44.370
with the letters YY and that's just
16

16

00:00:44.370  -->  00:00:45.920
make another copy of that alphanumeric
17

17

00:00:45.920  -->  00:00:57.120
string or just get up and scroll up and
18

18

00:00:57.120  -->  00:00:58.940
take a copy of that so we can sort of
19

19

00:00:58.940  -->  00:01:00.200
see it more clearly
20

20

00:01:00.200  -->  00:01:04.700
alright then i'll just change that
21

21

00:01:04.700  -->  00:01:12.150
alright so that's working now there is
22

22

00:01:12.150  -->  00:01:14.580
another way to write this expression we
23

23

00:01:14.580  -->  00:01:16.980
can actually use a quantifier now
24

24

00:01:16.980  -->  00:01:19.530
quantifiers specify how often an element in
25

25

00:01:19.530  -->  00:01:22.290
a regular expression can occur in our
26

26

00:01:22.290  -->  00:01:24.480
example there are three Es clearing in
27

27

00:01:24.480  -->  00:01:26.850
a row so instead of writing them all out
28

28

00:01:26.850  -->  00:01:28.920
we can actually use a quantifier as
29

29

00:01:28.920  -->  00:01:33.360
follows so we can leave the ABCD as well
30

30

00:01:33.360  -->  00:01:35.460
as the first letter but in here we
31

31

00:01:35.460  -->  00:01:39.660
can delete the last 2 es and put left
32

32

00:01:39.660  -->  00:01:42.960
curly bracket right curly bracket and do
33

33

00:01:42.960  -->  00:01:45.540
it that way so the three and curly
34

34

00:01:45.540  -->  00:01:48.150
braces indicates the number of the
35

35

00:01:48.150  -->  00:01:51.270
preceding character that must occur in
36

36

00:01:51.270  -->  00:01:52.710
order for there to be a match
37

37

00:01:52.710  -->  00:01:54.240
so in this case we have the way we've
38

38

00:01:54.240  -->  00:01:57.330
written it we want to see 3 e's and keep
39

39

00:01:57.330  -->  00:01:59.040
in mind the quantifier always comes
40

40

00:01:59.040  -->  00:02:01.110
after the character that it applies to
41

41

00:02:01.110  -->  00:02:04.020
so when we run we should see the same
42

42

00:02:04.020  -->  00:02:05.720
results we got without using a
43

43

00:02:05.720  -->  00:02:08.900
quantifier you can see we still got the
44

44

00:02:08.900  -->  00:02:11.450
yy being replaced so clearly
45

45

00:02:11.450  -->  00:02:14.120
that works successfully so lets
46

46

00:02:14.120  -->  00:02:15.540
actually look at doing in a different
47

47

00:02:15.540  -->  00:02:16.070
way
48

48

00:02:16.070  -->  00:02:18.090
let's suppose we don't actually care how
49

49

00:02:18.090  -->  00:02:18.870
many e's their are
50

50

00:02:18.870  -->  00:02:20.870
we want to match strings that begin with
51

51

00:02:20.870  -->  00:02:24.150
ABC and a capital D followed by one or
52

52

00:02:24.150  -->  00:02:26.840
more e's so in that case we use a
53

53

00:02:26.840  -->  00:02:28.620
different quantifier we use the +
54

54

00:02:28.620  -->  00:02:33.230
quantifier as follows so we do....
55

55

00:02:33.230  -->  00:02:39.090
...
56

56

00:02:39.090  -->  00:02:48.510
....
57

57

00:02:48.510  -->  00:02:50.190
...
58

58

00:02:50.190  -->  00:02:53.400
...so run it to confirm it
59

59

00:02:53.400  -->  00:02:56.480
works and you can see we've still got
60

60

00:02:56.480  -->  00:02:59.370
yy appearing on there so the good
61

61

00:02:59.370  -->  00:03:01.100
thing about using this quantifier is we
62

62

00:03:01.100  -->  00:03:03.260
don't need the curly braces and the
63

63

00:03:03.260  -->  00:03:04.760
reason for that is we don't we aren't
64

64

00:03:04.760  -->  00:03:06.780
providing a value so we're just
65

65

00:03:06.780  -->  00:03:09.510
basically specifying one or more e's
66

66

00:03:09.510  -->  00:03:11.570
is all we are actually looking for here not
67

67

00:03:11.570  -->  00:03:13.170
here we're not actually specifying the
68

68

00:03:13.170  -->  00:03:15.650
actual number so let's actually
69

69

00:03:15.650  -->  00:03:17.940
suppose we don't care if there are any
70

70

00:03:17.940  -->  00:03:20.730
e's so the street can begin with ABC
71

71

00:03:20.730  -->  00:03:23.430
capital D and then it's followed by any
72

72

00:03:23.430  -->  00:03:26.190
e's we want to match but we also want to
73

73

00:03:26.190  -->  00:03:28.700
match if it's not followed by any e's
74

74

00:03:28.700  -->  00:03:30.380
so in other words we want to match
75

75

00:03:30.380  -->  00:03:33.260
strings that begin with ABCD followed by
76

76

00:03:33.260  -->  00:03:36.510
zero or more e's so in this case we want
77

77

00:03:36.510  -->  00:03:39.060
to use the star or the astrix quantifier
78

78

00:03:39.060  -->  00:03:44.010
so will do...
79

79

00:03:44.010  -->  00:03:46.590
....
80

80

00:03:46.590  -->  00:03:52.370
...
81

81

00:03:52.370  -->  00:03:55.160
....
82

82

00:03:55.160  -->  00:04:01.370
...run that we're getting the same
83

83

00:04:01.370  -->  00:04:04.620
result again so just to confirm that
84

84

00:04:04.620  -->  00:04:06.150
this third one is working let's actually
85

85

00:04:06.150  -->  00:04:09.030
remove the e's from the beginning of
86

86

00:04:09.030  -->  00:04:11.660
the string will come up here remove 3
87

87

00:04:11.660  -->  00:04:19.410
e's if you run this again we can find
88

88

00:04:19.410  -->  00:04:21.510
that the first two matches have got
89

89

00:04:21.510  -->  00:04:24.120
ABCDF they basically the same as
90

90

00:04:24.120  -->  00:04:25.380
the string in other words they haven't
91

91

00:04:25.380  -->  00:04:27.630
matched anything but the third one
92

92

00:04:27.630  -->  00:04:30.990
using the star quantifier has actually
93

93

00:04:30.990  -->  00:04:32.550
replace it
94

94

00:04:32.550  -->  00:04:34.250
that's because we said the regular
95

95

00:04:34.250  -->  00:04:35.780
expression was going to be looking for
96

96

00:04:35.780  -->  00:04:39.120
ABCD and whether it's got an e after
97

97

00:04:39.120  -->  00:04:41.190
that or not still proceed with the
98

98

00:04:41.190  -->  00:04:43.680
replacement so you might be wondering
99

99

00:04:43.680  -->  00:04:45.720
what would this quantifier useful for
100

100

00:04:45.720  -->  00:04:47.690
well one use might be when you're doing
101

101

00:04:47.690  -->  00:04:50.120
something like verifying user input and
102

102

00:04:50.120  -->  00:04:52.190
part of what we've asked for is optional
103

103

00:04:52.190  -->  00:04:54.270
so in that case you want to look for
104

104

00:04:54.270  -->  00:04:55.830
that or if it's there if it's not
105

105

00:04:55.830  -->  00:04:57.870
there and you may still have
106

106

00:04:57.870  -->  00:05:01.130
some valid input so it really quite useful
107

107

00:05:01.130  -->  00:05:03.620
for that scenario you can also specify
108

108

00:05:03.620  -->  00:05:06.560
the minimum and maximum times that a
109

109

00:05:06.560  -->  00:05:09.090
character can occur here for example let's
110

110

00:05:09.090  -->  00:05:10.370
say we wanted to match strings that
111

111

00:05:10.370  -->  00:05:13.460
begin with ABCD followed by two to five
112

112

00:05:13.460  -->  00:05:16.310
e's and what I'll do there is I will
113

113

00:05:16.310  -->  00:05:19.590
just take a copy so what I'll do is I'll
114

114

00:05:19.590  -->  00:05:21.690
just undo that change and put the
115

115

00:05:21.690  -->  00:05:23.000
three e's back in again so we're back
116

116

00:05:23.000  -->  00:05:26.780
to where we were before and code on line
117

117

00:05:26.780  -->  00:05:28.340
51 was still work anyway because
118

118

00:05:28.340  -->  00:05:29.660
with all the e's
119

119

00:05:29.660  -->  00:05:32.210
so in this scenario again we want to
120

120

00:05:32.210  -->  00:05:33.620
match the strings that begin with ABC
121

121

00:05:33.620  -->  00:05:37.250
capital D followed by 2 to 5 e's so we do
122

122

00:05:37.250  -->  00:05:39.560
that with....
123

123

00:05:39.560  -->  00:05:41.190
....
124

124

00:05:41.190  -->  00:05:58.620
...
125

125

00:05:58.620  -->  00:06:04.190
....you can see we have got a
126

126

00:06:04.190  -->  00:06:06.810
match their if we go back and change our string to
127

127

00:06:06.810  -->  00:06:10.800
only have one e now like so we should
128

128

00:06:10.800  -->  00:06:12.710
find that won't succeed now because
129

129

00:06:12.710  -->  00:06:15.120
we're looking for between 2 and 5 e's
130

130

00:06:15.120  -->  00:06:17.810
you can see the string there has been
131

131

00:06:17.810  -->  00:06:19.340
left untouched because we've only got
132

132

00:06:19.340  -->  00:06:22.250
the one e in there and of course we don't
133

133

00:06:22.250  -->  00:06:23.750
have to match the beginning of a string
134

134

00:06:23.750  -->  00:06:25.680
we can match parts in the middle or the
135

135

00:06:25.680  -->  00:06:26.870
end of the string as well as the
136

136

00:06:26.870  -->  00:06:28.800
beginning so let's actually try
137

137

00:06:28.800  -->  00:06:30.870
replacing all occurrences of h
138

138

00:06:30.870  -->  00:06:33.560
followed by any number of i's followed
139

139

00:06:33.560  -->  00:06:37.520
by at least one j with a y so we
140

140

00:06:37.520  -->  00:06:41.270
can do something like...
141

141

00:06:41.270  -->  00:06:55.830
...
142

142

00:06:55.830  -->  00:06:57.000
what we're trying to do is replace all
143

143

00:06:57.000  -->  00:06:59.630
occurrences of h followed by any
144

144

00:06:59.630  -->  00:07:01.430
number of my i's followed by at least
145

145

00:07:01.430  -->  00:07:04.500
one j and we want to replace all that with
146

146

00:07:04.500  -->  00:07:06.750
a y so do that we're going....
147

147

00:07:06.750  -->  00:07:17.780
...
148

148

00:07:17.780  -->  00:07:19.970
so again we want to see one h hence we use the +
149

149

00:07:19.970  -->  00:07:22.500
followed by zero or more i's hence
150

150

00:07:22.500  -->  00:07:26.060
we're using the star followed by j and
151

151

00:07:26.060  -->  00:07:28.880
when we run this what we should see is the
152

152

00:07:28.880  -->  00:07:31.310
hhiij part of the string has been
153

153

00:07:31.310  -->  00:07:33.470
replaced with a single y you can see
154

154

00:07:33.470  -->  00:07:35.310
that being the case or that is
155

155

00:07:35.310  -->  00:07:38.060
the case there now there are other
156

156

00:07:38.060  -->  00:07:40.340
character classes boundary matches and
157

157

00:07:40.340  -->  00:07:42.020
quantifiers that we can use in regular
158

158

00:07:42.020  -->  00:07:44.520
expressions and there's actually quite a
159

159

00:07:44.520  -->  00:07:47.610
complete list at the documentation or of
160

160

00:07:47.610  -->  00:07:49.830
documentation on oracles websites so
161

161

00:07:49.830  -->  00:07:51.000
let's just go there and have a quick
162

162

00:07:51.000  -->  00:07:54.560
look
163

163

00:07:54.560  -->  00:07:58.400
so you can find quite a bit of detail
164

164

00:07:58.400  -->  00:08:00.180
there at various patterns and so forth
165

165

00:08:00.180  -->  00:08:01.860
so I do suggest you check that out and
166

166

00:08:01.860  -->  00:08:04.280
experiment you know the basics of regular
167

167

00:08:04.280  -->  00:08:06.590
expressions one thing that you'll notice
168

168

00:08:06.590  -->  00:08:08.270
with this documentation is that talking
169

169

00:08:08.270  -->  00:08:11.520
about the pattern class now we've been
170

170

00:08:11.520  -->  00:08:13.370
using the string . matches and string
171

171

00:08:13.370  -->  00:08:15.500
. replace all methods to demonstrate
172

172

00:08:15.500  -->  00:08:16.770
the basics of writing regular
173

173

00:08:16.770  -->  00:08:18.810
expressions and we haven't used
174

174

00:08:18.810  -->  00:08:21.590
the pattern class yet but we can also
175

175

00:08:21.590  -->  00:08:23.550
use this pattern class to manipulate
176

176

00:08:23.550  -->  00:08:25.940
strings using regular expressions now
177

177

00:08:25.940  -->  00:08:27.900
some java api always want to work with
178

178

00:08:27.900  -->  00:08:29.720
patterns rather than a string that
179

179

00:08:29.720  -->  00:08:31.800
represents a regular expression so we
180

180

00:08:31.800  -->  00:08:34.310
can use the pattern . compile method to
181

181

00:08:34.310  -->  00:08:36.080
compile a regular expression into a
182

182

00:08:36.080  -->  00:08:38.490
pattern now this is often done when we
183

183

00:08:38.490  -->  00:08:39.950
want to work with methods in the matcher
184

184

00:08:39.950  -->  00:08:41.390
class
185

185

00:08:41.390  -->  00:08:43.820
now matches work with classes that
186

186

00:08:43.820  -->  00:08:45.770
implement the char sequence interface
187

187

00:08:45.770  -->  00:08:47.570
and that means that we can use matches
188

188

00:08:47.570  -->  00:08:49.760
with strings stringbuffer stringbuilder
189

189

00:08:49.760  -->  00:08:51.770
and other classes that implement that
190

190

00:08:51.770  -->  00:08:55.110
interface generally we use a matcher when
191

191

00:08:55.110  -->  00:08:56.690
we want to find multiple occurrences of
192

192

00:08:56.690  -->  00:08:58.520
a pattern or when we want to use the
193

193

00:08:58.520  -->  00:08:59.390
same pattern
194

194

00:08:59.390  -->  00:09:02.450
multiple sequences now if we are only going to use
195

195

00:09:02.450  -->  00:09:04.610
a regular expression once to check one
196

196

00:09:04.610  -->  00:09:06.110
occurrence in the string then we
197

197

00:09:06.110  -->  00:09:07.490
probably don't need to use a matcher
198

198

00:09:07.490  -->  00:09:10.160
alright so let's look at example at an
199

199

00:09:10.160  -->  00:09:13.940
example we'll go back to our code let's
200

200

00:09:13.940  -->  00:09:15.470
say we want to find all the
201

201

00:09:15.470  -->  00:09:18.320
occurences of the h2 tag in a char
202

202

00:09:18.320  -->  00:09:21.320
sequence of HTML text let's start by
203

203

00:09:21.320  -->  00:09:23.660
assigning some sample text string so....
204

204

00:09:23.660  -->  00:09:28.550
....
205

205

00:09:28.550  -->  00:10:01.190
...
206

206

00:10:01.190  -->  00:10:10.280
....
207

207

00:10:10.280  -->  00:10:15.800
...
208

208

00:10:15.800  -->  00:10:22.250
....
209

209

00:10:22.250  -->  00:10:35.300
...
210

210

00:10:35.300  -->  00:10:42.500
....ok got some basic HTML there and in
211

211

00:10:42.500  -->  00:10:44.180
case you're wondering i'm using a
212

212

00:10:44.180  -->  00:10:46.430
stringbuilder because we're creating we
213

213

00:10:46.430  -->  00:10:48.440
creating a long string so assume that
214

214

00:10:48.440  -->  00:10:50.870
this HTML text is part of a large page
215

215

00:10:50.870  -->  00:10:52.640
within a HTML body that
216

216

00:10:52.640  -->  00:10:54.950
perhaps has been now extracted by some
217

217

00:10:54.950  -->  00:10:55.850
other process
218

218

00:10:55.850  -->  00:10:58.460
alright so let's start using a matcher
219

219

00:10:58.460  -->  00:11:01.070
start by using a matcher to find out if
220

220

00:11:01.070  -->  00:11:02.960
there's any h 2 tags within this
221

221

00:11:02.960  -->  00:11:05.270
text so the way we do that it would put
222

222

00:11:05.270  -->  00:11:12.490
....
223

223

00:11:12.490  -->  00:11:30.670
...
224

224

00:11:30.670  -->  00:11:36.250
....
225

225

00:11:36.250  -->  00:11:45.070
...
226

226

00:11:45.070  -->  00:11:47.350
alright so again what we're doing is
227

227

00:11:47.350  -->  00:11:49.030
we're using the regular expression h2
228

228

00:11:49.030  -->  00:11:51.490
as a tag to find occurrences of this
229

229

00:11:51.490  -->  00:11:53.740
tag which we have assigned to this string called
230

230

00:11:53.740  -->  00:11:57.040
h2 pattern next we
231

231

00:11:57.040  -->  00:11:59.200
compile the pattern so that creates a
232

232

00:11:59.200  -->  00:12:00.790
patent instance that we can use to
233

233

00:12:00.790  -->  00:12:03.070
create a matcher instance which we
234

234

00:12:03.070  -->  00:12:04.330
done on the next line
235

235

00:12:04.330  -->  00:12:06.370
so finally we call the matches method
236

236

00:12:06.370  -->  00:12:08.080
inside the matchers class to check
237

237

00:12:08.080  -->  00:12:09.730
whether the pattern matches the regular
238

238

00:12:09.730  -->  00:12:11.830
expression and once you do have a
239

239

00:12:11.830  -->  00:12:13.420
pattern you can use that to create as
240

240

00:12:13.420  -->  00:12:16.030
many matches as you want you might be
241

241

00:12:16.030  -->  00:12:17.710
thinking that is won't match tags are in
242

242

00:12:17.710  -->  00:12:20.230
uppercase and you're actually right so
243

243

00:12:20.230  -->  00:12:22.930
we have two choices to fixes we could
244

244

00:12:22.930  -->  00:12:24.760
modify the regular expression to also
245

245

00:12:24.760  -->  00:12:27.940
look for h2 with an uppercase h or when
246

246

00:12:27.940  -->  00:12:29.770
we can compile the pattern we could pass
247

247

00:12:29.770  -->  00:12:31.480
the pattern . case_
248

248

00:12:31.480  -->  00:12:33.580
insensitive constant as the second
249

249

00:12:33.580  -->  00:12:35.770
parameter so we could do something like
250

250

00:12:35.770  -->  00:12:38.350
this.....
251

251

00:12:38.350  -->  00:12:42.280
....
252

252

00:12:42.280  -->  00:12:45.430
....that's one way to do a
253

253

00:12:45.430  -->  00:12:48.760
case-insensitive pattern check or using
254

254

00:12:48.760  -->  00:12:51.400
Unicode you actually leave that in but
255

255

00:12:51.400  -->  00:12:54.070
you're actually also put that like so
256

256

00:12:54.070  -->  00:12:58.000
pattern . unicode case there's one here
257

257

00:12:58.000  -->  00:13:00.610
that's how you actually be searching
258

258

00:13:00.610  -->  00:13:03.370
unicode strings gonna leave that out
259

259

00:13:03.370  -->  00:13:04.690
now because there's another alternative
260

260

00:13:04.690  -->  00:13:07.080
but in our case just for
261

261

00:13:07.080  -->  00:13:08.170
simplicity we're going to assume that
262

262

00:13:08.170  -->  00:13:10.150
all our tags in the HTML are in lowercase
263

263

00:13:10.150  -->  00:13:13.390
alright so lets actually run this and
264

264

00:13:13.390  -->  00:13:18.140
see what happens
265

265

00:13:18.140  -->  00:13:20.270
now interestingly enough we get false
266

266

00:13:20.270  -->  00:13:22.820
and that might not be what you think
267

267

00:13:22.820  -->  00:13:24.380
should happen because after all we have
268

268

00:13:24.380  -->  00:13:27.260
clearly got a h 2 their and our text
269

269

00:13:27.260  -->  00:13:29.160
clearly has got h2 in it there's no
270

270

00:13:29.160  -->  00:13:31.310
issues with upper or lowercase
271

271

00:13:31.310  -->  00:13:32.670
so what's going on why isn't this
272

272

00:13:32.670  -->  00:13:35.100
working well it turns out that the
273

273

00:13:35.100  -->  00:13:36.360
matches method
274

274

00:13:36.360  -->  00:13:37.880
wants the match the string as a whole
275

275

00:13:37.880  -->  00:13:40.110
just like the string . matches method
276

276

00:13:40.110  -->  00:13:42.240
wants to do so what we need to do is
277

277

00:13:42.240  -->  00:13:43.980
write a regular expression is going to
278

278

00:13:43.980  -->  00:13:46.670
match the entire text so we can do this
279

279

00:13:46.670  -->  00:13:47.910
quite easy with a regular expression
280

280

00:13:47.910  -->  00:13:48.830
as follows
281

281

00:13:48.830  -->  00:13:49.980
we're going to just modify our
282

282

00:13:49.980  -->  00:13:54.200
expression to put ........
283

283

00:13:54.200  -->  00:13:56.970
....
284

284

00:13:56.970  -->  00:14:00.990
...so
285

285

00:14:00.990  -->  00:14:02.750
here we're combining the
286

286

00:14:02.750  -->  00:14:05.670
. character class with a star quantifier
287

287

00:14:05.670  -->  00:14:08.180
if you recall the . will match every
288

288

00:14:08.180  -->  00:14:11.300
character and star means zero or more so
289

289

00:14:11.300  -->  00:14:13.010
effectively what we're saying here is
290

290

00:14:13.010  -->  00:14:14.910
that can they can be anything before
291

291

00:14:14.910  -->  00:14:17.990
anything after the h2 and will actually
292

292

00:14:17.990  -->  00:14:20.910
have a match if we run this now now that
293

293

00:14:20.910  -->  00:14:22.230
we're actually testing the whole line we
294

294

00:14:22.230  -->  00:14:25.370
should find that will return true and
295

295

00:14:25.370  -->  00:14:28.230
you can see it now returning true and
296

296

00:14:28.230  -->  00:14:29.730
again that's because the entire string
297

297

00:14:29.730  -->  00:14:32.420
or character sequence now matches the pattern
298

298

00:14:32.420  -->  00:14:34.880
alright so that's all well and good but
299

299

00:14:34.880  -->  00:14:36.500
how can we find out how many occurrences
300

300

00:14:36.500  -->  00:14:38.750
there are and where they occur
301

301

00:14:38.750  -->  00:14:40.760
let's talk about doing that in the next
302

302

00:14:40.760  -->  00:14:46.160
video
