1
1

00:00:04,990  -->  00:00:07,560
alright let's discuss regular
2

2

00:00:07,560  -->  00:00:10,420
expressions so regular expressions are a
alright let's discuss regular
3

3

00:00:10,420  -->  00:00:12,630
way to describe a string or a pattern
expressions so regular expressions are a
4

4

00:00:12,630  -->  00:00:15,420
and you probably already used regular
way to describe a string or a pattern
5

5

00:00:15,420  -->  00:00:16,990
expressions without actually knowing it
and you probably already used regular
6

6

00:00:16,990  -->  00:00:19,660
some methods in the string class accept
expressions without actually knowing it
7

7

00:00:19,660  -->  00:00:21,670
a regular expression as a parameter for
some methods in the string class accept
8

8

00:00:21,670  -->  00:00:23,740
example the matches method replace all
a regular expression as a parameter for
9

9

00:00:23,740  -->  00:00:26,610
method and split methods all actually work
example the matches method replace all
10

10

00:00:26,610  -->  00:00:29,920
with regular expressions so regular
method and split methods all actually work
11

11

00:00:29,920  -->  00:00:31,990
expressions are often used to search
with regular expressions so regular
12

12

00:00:31,990  -->  00:00:34,260
strings for a specific pattern or to
expressions are often used to search
13

13

00:00:34,260  -->  00:00:36,430
validate that user input matches a
strings for a specific pattern or to
14

14

00:00:36,430  -->  00:00:39,310
specific pattern for example we may want
validate that user input matches a
15

15

00:00:39,310  -->  00:00:41,080
to verify that the users provided an
specific pattern for example we may want
16

16

00:00:41,080  -->  00:00:43,120
email address by checking the input
to verify that the users provided an
17

17

00:00:43,120  -->  00:00:45,130
against a regular expression that
email address by checking the input
18

18

00:00:45,130  -->  00:00:46,840
describes how an email address string
against a regular expression that
19

19

00:00:46,840  -->  00:00:49,570
should look the best way to learn about
describes how an email address string
20

20

00:00:49,570  -->  00:00:52,420
to regular expressions is by example
should look the best way to learn about
21

21

00:00:52,420  -->  00:00:54,490
so I've created a new project called
to regular expressions is by example
22

22

00:00:54,490  -->  00:00:55,960
regular expression so start a new
so I've created a new project called
23

23

00:00:55,960  -->  00:00:58,420
project in IntelliJ we're going to start
regular expression so start a new
24

24

00:00:58,420  -->  00:01:00,220
typing some code into the main method
project in IntelliJ we're going to start
25

25

00:01:00,220  -->  00:01:04,390
going to start by typing string....
typing some code into the main method
26

26

00:01:04,390  -->  00:01:11,320
....
going to start by typing string....
27

27

00:01:11,320  -->  00:01:16,170
....
....
28

28

00:01:16,170  -->  00:01:18,460
...no surprises as to what
....
29

29

00:01:18,460  -->  00:01:23,250
that's going to watch shows you see the
...no surprises as to what
30

30

00:01:23,250  -->  00:01:24,570
string I am a string
that's going to watch shows you see the
31

31

00:01:24,570  -->  00:01:27,180
yes I am printed to console so the
string I am a string
32

32

00:01:27,180  -->  00:01:29,250
simplest form of a regular expression is
yes I am printed to console so the
33

33

00:01:29,250  -->  00:01:32,380
a string literal so for example hello in
simplest form of a regular expression is
34

34

00:01:32,380  -->  00:01:35,560
double quotes is a regular expression so
a string literal so for example hello in
35

35

00:01:35,560  -->  00:01:37,240
lets actually use the replace all
double quotes is a regular expression so
36

36

00:01:37,240  -->  00:01:39,960
method to replace all occurrences of the
lets actually use the replace all
37

37

00:01:39,960  -->  00:01:43,170
word I with the word you so the
method to replace all occurrences of the
38

38

00:01:43,170  -->  00:01:44,890
replace all method accepts a regular
word I with the word you so the
39

39

00:01:44,890  -->  00:01:46,780
expression that describes that pattern
replace all method accepts a regular
40

40

00:01:46,780  -->  00:01:48,720
we want to replace as the first
expression that describes that pattern
41

41

00:01:48,720  -->  00:01:50,670
parameter the second parameter is the
we want to replace as the first
42

42

00:01:50,670  -->  00:01:53,310
actual replacement string so in terms
parameter the second parameter is the
43

43

00:01:53,310  -->  00:01:54,750
of how to use this will do something
actual replacement string so in terms
44

44

00:01:54,750  -->  00:02:02,850
like string....
of how to use this will do something
45

45

00:02:02,850  -->  00:02:06,540
....
like string....
46

46

00:02:06,540  -->  00:02:13,220
....
....
47

47

00:02:13,220  -->  00:02:15,240
let's actually print out the results and
....
48

48

00:02:15,240  -->  00:02:20,280
fix the typo...
let's actually print out the results and
49

49

00:02:20,280  -->  00:02:25,410
let's just confirm that works we can see
fix the typo...
50

50

00:02:25,410  -->  00:02:27,600
the text showing you am a string
let's just confirm that works we can see
51

51

00:02:27,600  -->  00:02:29,700
yes you am obviously that's bad english but
the text showing you am a string
52

52

00:02:29,700  -->  00:02:30,870
you get the point of what's happening
yes you am obviously that's bad english but
53

53

00:02:30,870  -->  00:02:34,890
here we are getting strings replaced the
you get the point of what's happening
54

54

00:02:34,890  -->  00:02:36,780
regular expression I'd match the source
here we are getting strings replaced the
55

55

00:02:36,780  -->  00:02:39,510
string in 2 places and each match or
regular expression I'd match the source
56

56

00:02:39,510  -->  00:02:41,520
occurrence was replaced with the string
string in 2 places and each match or
57

57

00:02:41,520  -->  00:02:44,430
you now all we could do was match
occurrence was replaced with the string
58

58

00:02:44,430  -->  00:02:46,050
string literals in this way regular
you now all we could do was match
59

59

00:02:46,050  -->  00:02:47,550
expressions wouldn't really be very
string literals in this way regular
60

60

00:02:47,550  -->  00:02:49,650
interesting but we can actually do much
expressions wouldn't really be very
61

61

00:02:49,650  -->  00:02:51,330
more by using what's called character
interesting but we can actually do much
62

62

00:02:51,330  -->  00:02:55,260
classes and boundary matches so a
more by using what's called character
63

63

00:02:55,260  -->  00:02:57,750
character classes like a wild card
classes and boundary matches so a
64

64

00:02:57,750  -->  00:02:59,700
it represents a set or class of
character classes like a wild card
65

65

00:02:59,700  -->  00:03:02,250
characters and a boundary matcher looks
it represents a set or class of
66

66

00:03:02,250  -->  00:03:04,620
for boundaries such as the beginning and
characters and a boundary matcher looks
67

67

00:03:04,620  -->  00:03:06,720
end of a string or a word
for boundaries such as the beginning and
68

68

00:03:06,720  -->  00:03:09,000
let's start by declaring a new string
end of a string or a word
69

69

00:03:09,000  -->  00:03:12,630
in main and we will call
let's start by declaring a new string
70

70

00:03:12,630  -->  00:03:18,360
it alphanumeric gonna set that to.....
in main and we will call
71

71

00:03:18,360  -->  00:03:20,880
....
it alphanumeric gonna set that to.....
72

72

00:03:20,880  -->  00:03:29,020
....
....
73

73

00:03:29,020  -->  00:03:33,220
....so looking at
....
74

74

00:03:33,220  -->  00:03:35,830
character class matches any character so
....so looking at
75

75

00:03:35,830  -->  00:03:37,690
let's start try it out by using replace all
character class matches any character so
76

76

00:03:37,690  -->  00:03:41,050
method so we're going to do....
let's start try it out by using replace all
77

77

00:03:41,050  -->  00:03:46,120
....
method so we're going to do....
78

78

00:03:46,120  -->  00:03:57,640
....
....
79

79

00:03:57,640  -->  00:03:59,680
...lets run that you
....
80

80

00:03:59,680  -->  00:04:01,120
can probably guess what that that will do if
...lets run that you
81

81

00:04:01,120  -->  00:04:03,580
we know that a . matches any
can probably guess what that that will do if
82

82

00:04:03,580  -->  00:04:06,190
character you can see that the entire
we know that a . matches any
83

83

00:04:06,190  -->  00:04:07,870
string which we said on line 11 is
character you can see that the entire
84

84

00:04:07,870  -->  00:04:10,780
replaced with all ys
string which we said on line 11 is
85

85

00:04:10,780  -->  00:04:12,370
so it's basically a wild card for any
replaced with all ys
86

86

00:04:12,370  -->  00:04:15,520
character now the carrot boundary
so it's basically a wild card for any
87

87

00:04:15,520  -->  00:04:17,890
matcher that's located doing a shift 6
character now the carrot boundary
88

88

00:04:17,890  -->  00:04:21,310
that is always followed by pattern which
matcher that's located doing a shift 6
89

89

00:04:21,310  -->  00:04:22,900
could be a string literal or something
that is always followed by pattern which
90

90

00:04:22,900  -->  00:04:25,270
more complex when we use this carrot
could be a string literal or something
91

91

00:04:25,270  -->  00:04:28,090
boundary matcher the regular expression
more complex when we use this carrot
92

92

00:04:28,090  -->  00:04:29,770
must match the beginning of the string
boundary matcher the regular expression
93

93

00:04:29,770  -->  00:04:32,140
so let's try it out with the replace all
must match the beginning of the string
94

94

00:04:32,140  -->  00:04:34,090
method again let's just say we want to
so let's try it out with the replace all
95

95

00:04:34,090  -->  00:04:35,620
replace that first part of the string
method again let's just say we want to
96

96

00:04:35,620  -->  00:04:39,880
that ABCdeee with something else lets have a
replace that first part of the string
97

97

00:04:39,880  -->  00:04:42,100
go at doing that so we're going to
that ABCdeee with something else lets have a
98

98

00:04:42,100  -->  00:04:45,790
print out again....
go at doing that so we're going to
99

99

00:04:45,790  -->  00:04:48,610
....
print out again....
100

100

00:04:48,610  -->  00:05:00,880
....
....
101

101

00:05:00,880  -->  00:05:02,170
note that the length of the regular
....
102

102

00:05:02,170  -->  00:05:03,940
expression doesn't have to match the
note that the length of the regular
103

103

00:05:03,940  -->  00:05:06,370
length of the replacement so we actually
expression doesn't have to match the
104

104

00:05:06,370  -->  00:05:12,190
run this you can see that we've got a
length of the replacement so we actually
105

105

00:05:12,190  -->  00:05:12,790
match
run this you can see that we've got a
106

106

00:05:12,790  -->  00:05:16,090
we got ABCDeee was found at the start of
match
107

107

00:05:16,090  -->  00:05:17,980
the string and just the first three
we got ABCDeee was found at the start of
108

108

00:05:17,980  -->  00:05:19,510
letters were replaced because we told it
the string and just the first three
109

109

00:05:19,510  -->  00:05:21,160
to replace what it found with just
letters were replaced because we told it
110

110

00:05:21,160  -->  00:05:23,980
those first three characters the three
to replace what it found with just
111

111

00:05:23,980  -->  00:05:25,060
ys that we put in the rest
those first three characters the three
112

112

00:05:25,060  -->  00:05:28,330
replacement string so basically the
ys that we put in the rest
113

113

00:05:28,330  -->  00:05:29,620
regular expression match those
replacement string so basically the
114

114

00:05:29,620  -->  00:05:31,030
characters that occurred at the
regular expression match those
115

115

00:05:31,030  -->  00:05:33,070
beginning of the string and again
characters that occurred at the
116

116

00:05:33,070  -->  00:05:34,990
because we specify the carrot
beginning of the string and again
117

117

00:05:34,990  -->  00:05:36,370
boundary matcher that's is why its only looking
because we specify the carrot
118

118

00:05:36,370  -->  00:05:38,410
for the start of the string and replaced
boundary matcher that's is why its only looking
119

119

00:05:38,410  -->  00:05:40,780
it now just to show that this is only
for the start of the string and replaced
120

120

00:05:40,780  -->  00:05:42,280
going to show it only
it now just to show that this is only
121

121

00:05:42,280  -->  00:05:43,660
replace it at the start of the string
going to show it only
122

122

00:05:43,660  -->  00:05:46,660
let's add another occurrence of ABCDeee
replace it at the start of the string
123

123

00:05:46,660  -->  00:05:48,580
later in the string now since it doesn't
let's add another occurrence of ABCDeee
124

124

00:05:48,580  -->  00:05:50,950
occur at the beginning it shouldn't match
later in the string now since it doesn't
125

125

00:05:50,950  -->  00:05:52,840
the regular expression so the second
occur at the beginning it shouldn't match
126

126

00:05:52,840  -->  00:05:55,270
occurrence shouldn't be replaced
the regular expression so the second
127

127

00:05:55,270  -->  00:05:56,470
let's just create a new string to do
occurrence shouldn't be replaced
128

128

00:05:56,470  -->  00:05:58,960
this to keep it easy to make it easy i'm
let's just create a new string to do
129

129

00:05:58,960  -->  00:05:59,890
just going to take a copy of the
this to keep it easy to make it easy i'm
130

130

00:05:59,890  -->  00:06:03,400
alphanumeric one will call this one
just going to take a copy of the
131

131

00:06:03,400  -->  00:06:10,780
second string will put it somewhere here
alphanumeric one will call this one
132

132

00:06:10,780  -->  00:06:14,740
....so we got two versions of
second string will put it somewhere here
133

133

00:06:14,740  -->  00:06:18,190
that showing now and if we just print out
....so we got two versions of
134

134

00:06:18,190  -->  00:06:22,360
....
that showing now and if we just print out
135

135

00:06:22,360  -->  00:06:27,190
....
....
136

136

00:06:27,190  -->  00:06:31,990
.....if we run the second
....
137

137

00:06:31,990  -->  00:06:36,850
occurrence you can see in this case the
.....if we run the second
138

138

00:06:36,850  -->  00:06:39,730
ABCDeee second occurrence hasn't been
occurrence you can see in this case the
139

139

00:06:39,730  -->  00:06:41,920
replaced again because we specify the
ABCDeee second occurrence hasn't been
140

140

00:06:41,920  -->  00:06:44,050
boundary matcher the carrot which
replaced again because we specify the
141

141

00:06:44,050  -->  00:06:46,270
indicates to only match at the start of
boundary matcher the carrot which
142

142

00:06:46,270  -->  00:06:49,750
the string so it's probably good time to
indicates to only match at the start of
143

143

00:06:49,750  -->  00:06:51,220
point out what I think is a really nifty
the string so it's probably good time to
144

144

00:06:51,220  -->  00:06:54,550
feature of IntelliJ so when we place the
point out what I think is a really nifty
145

145

00:06:54,550  -->  00:06:57,490
cursor inside a regular expression like
feature of IntelliJ so when we place the
146

146

00:06:57,490  -->  00:07:00,100
here notice we've got a pop up on the
cursor inside a regular expression like
147

147

00:07:00,100  -->  00:07:02,020
left-hand side there in the gutter
here notice we've got a pop up on the
148

148

00:07:02,020  -->  00:07:03,640
or near the gutter so we actually click
left-hand side there in the gutter
149

149

00:07:03,640  -->  00:07:06,520
on that we can click on check reg x
or near the gutter so we actually click
150

150

00:07:06,520  -->  00:07:07,930
which is of course abbreviation for
on that we can click on check reg x
151

151

00:07:07,930  -->  00:07:09,970
check regular expression so I click on
which is of course abbreviation for
152

152

00:07:09,970  -->  00:07:14,320
that get this little pop-up then we can
check regular expression so I click on
153

153

00:07:14,320  -->  00:07:16,000
type different strings into the field
that get this little pop-up then we can
154

154

00:07:16,000  -->  00:07:17,470
intelliJ will actually tell us
type different strings into the field
155

155

00:07:17,470  -->  00:07:19,630
whether the string matches the regular
intelliJ will actually tell us
156

156

00:07:19,630  -->  00:07:22,420
expression now the default entry would
whether the string matches the regular
157

157

00:07:22,420  -->  00:07:25,300
normally pop up to be a sample text but
expression now the default entry would
158

158

00:07:25,300  -->  00:07:26,740
because I've actually used this before i
normally pop up to be a sample text but
159

159

00:07:26,740  -->  00:07:28,660
got a different sample we can actually
because I've actually used this before i
160

160

00:07:28,660  -->  00:07:30,220
change that so we can we made that like
got a different sample we can actually
161

161

00:07:30,220  -->  00:07:31,570
sample text....
change that so we can we made that like
162

162

00:07:31,570  -->  00:07:33,940
notice how its red and it's actually
sample text....
163

163

00:07:33,940  -->  00:07:35,170
showing that there's no match is
notice how its red and it's actually
164

164

00:07:35,170  -->  00:07:37,210
basically saying the regular expression
showing that there's no match is
165

165

00:07:37,210  -->  00:07:40,180
we've typed in here and what the result
basically saying the regular expression
166

166

00:07:40,180  -->  00:07:41,590
of that is against this in this case
we've typed in here and what the result
167

167

00:07:41,590  -->  00:07:43,480
it's there's no match so it's actually
of that is against this in this case
168

168

00:07:43,480  -->  00:07:47,560
in red if i go back and type in abcdeee
it's there's no match so it's actually
169

169

00:07:47,560  -->  00:07:51,790
again we get a match as you
in red if i go back and type in abcdeee
170

170

00:07:51,790  -->  00:07:53,260
can see and it actually converted to
again we get a match as you
171

171

00:07:53,260  -->  00:07:54,130
green
can see and it actually converted to
172

172

00:07:54,130  -->  00:07:57,020
so this is a really handy way to test a
green
173

173

00:07:57,020  -->  00:07:59,180
regular expression without actually
so this is a really handy way to test a
174

174

00:07:59,180  -->  00:08:00,530
having to run your application all the
regular expression without actually
175

175

00:08:00,530  -->  00:08:03,220
time but however it requires that the
having to run your application all the
176

176

00:08:03,220  -->  00:08:05,150
string as a whole must match the
time but however it requires that the
177

177

00:08:05,150  -->  00:08:07,240
expression so it doesn't actually match
string as a whole must match the
178

178

00:08:07,240  -->  00:08:10,180
parts of a string for example if we put
expression so it doesn't actually match
179

179

00:08:10,180  -->  00:08:11,900
our second string value into the sample
parts of a string for example if we put
180

180

00:08:11,900  -->  00:08:13,930
text field will tell us that doesn't
our second string value into the sample
181

181

00:08:13,930  -->  00:08:17,710
match the carrot ABCDeeee but the replace
text field will tell us that doesn't
182

182

00:08:17,710  -->  00:08:20,620
all method actually disagrees but still
match the carrot ABCDeeee but the replace
183

183

00:08:20,620  -->  00:08:22,720
depending on the regular expression it's
all method actually disagrees but still
184

184

00:08:22,720  -->  00:08:23,990
a quick way to check whether the
depending on the regular expression it's
185

185

00:08:23,990  -->  00:08:26,240
expression will match what we expected
a quick way to check whether the
186

186

00:08:26,240  -->  00:08:29,020
to match gonna close that down by
expression will match what we expected
187

187

00:08:29,020  -->  00:08:31,810
pressing escape now before we actually
to match gonna close that down by
188

188

00:08:31,810  -->  00:08:34,250
look at other character classes and
pressing escape now before we actually
189

189

00:08:34,250  -->  00:08:35,440
boundary matches
look at other character classes and
190

190

00:08:35,440  -->  00:08:37,820
let's actually try these or try out
boundary matches
191

191

00:08:37,820  -->  00:08:40,450
the string . matches method now this
let's actually try these or try out
192

192

00:08:40,450  -->  00:08:42,520
method accepts a regular expression as a
the string . matches method now this
193

193

00:08:42,520  -->  00:08:45,460
parameter and returns true if the string
method accepts a regular expression as a
194

194

00:08:45,460  -->  00:08:48,580
matches and false otherwise so let's use
parameter and returns true if the string
195

195

00:08:48,580  -->  00:08:50,690
the example alphanumeric string and pass
matches and false otherwise so let's use
196

196

00:08:50,690  -->  00:08:52,880
the regular expression carrot hello
the example alphanumeric string and pass
197

197

00:08:52,880  -->  00:08:55,330
since the alphanumeric string
the regular expression carrot hello
198

198

00:08:55,330  -->  00:08:57,350
doesn't start with hello will expect
since the alphanumeric string
199

199

00:08:57,350  -->  00:09:00,290
this to be expected to return false so
doesn't start with hello will expect
200

200

00:09:00,290  -->  00:09:04,820
we do s out will be alpha numeric....
this to be expected to return false so
201

201

00:09:04,820  -->  00:09:07,820
.....
we do s out will be alpha numeric....
202

202

00:09:07,820  -->  00:09:13,130
....
.....
203

203

00:09:13,130  -->  00:09:14,510
clearly hello is not in there we look at
....
204

204

00:09:14,510  -->  00:09:16,730
our alphanumeric string on line 11
clearly hello is not in there we look at
205

205

00:09:16,730  -->  00:09:19,190
so that should return false for us
our alphanumeric string on line 11
206

206

00:09:19,190  -->  00:09:21,800
no surprises there it does actually
so that should return false for us
207

207

00:09:21,800  -->  00:09:24,700
return false but now let's pass the
no surprises there it does actually
208

208

00:09:24,700  -->  00:09:27,470
ABCDeee as a regular expressions so
return false but now let's pass the
209

209

00:09:27,470  -->  00:09:30,760
copy that line again this time going to
ABCDeee as a regular expressions so
210

210

00:09:30,760  -->  00:09:32,770
change it to make it the carrot
copy that line again this time going to
211

211

00:09:32,770  -->  00:09:35,600
boundary matcher.....
change it to make it the carrot
212

212

00:09:35,600  -->  00:09:39,980
so the string begins with ABCDeee and we've
boundary matcher.....
213

213

00:09:39,980  -->  00:09:41,390
already used the regular expression to
so the string begins with ABCDeee and we've
214

214

00:09:41,390  -->  00:09:43,330
successfully replace the characters with
already used the regular expression to
215

215

00:09:43,330  -->  00:09:45,680
3 y's so you would expect here the
successfully replace the characters with
216

216

00:09:45,680  -->  00:09:48,110
matches method to return true so lets
3 y's so you would expect here the
217

217

00:09:48,110  -->  00:09:53,540
actually run this but as you can see
matches method to return true so lets
218

218

00:09:53,540  -->  00:09:55,390
when i ran that we're not getting the
actually run this but as you can see
219

219

00:09:55,390  -->  00:09:58,510
results that perhaps you expect the
when i ran that we're not getting the
220

220

00:09:58,510  -->  00:10:00,800
value of false is printed here
results that perhaps you expect the
221

221

00:10:00,800  -->  00:10:03,410
the question now is what's going on well
value of false is printed here
222

222

00:10:03,410  -->  00:10:05,120
it turns out that when using the string
the question now is what's going on well
223

223

00:10:05,120  -->  00:10:07,850
matches method the string as a whole
it turns out that when using the string
224

224

00:10:07,850  -->  00:10:09,760
has to match the regular expression in
matches method the string as a whole
225

225

00:10:09,760  -->  00:10:11,540
order for true to be returned
has to match the regular expression in
226

226

00:10:11,540  -->  00:10:13,330
that's not good enough for only part of
order for true to be returned
227

227

00:10:13,330  -->  00:10:15,520
the string to match this is the same
that's not good enough for only part of
228

228

00:10:15,520  -->  00:10:16,790
behavior that i mentioned with the
the string to match this is the same
229

229

00:10:16,790  -->  00:10:18,440
IntelliJ quick check
behavior that i mentioned with the
230

230

00:10:18,440  -->  00:10:19,750
in fact I wouldn't be surprised if
IntelliJ quick check
231

231

00:10:19,750  -->  00:10:22,060
IntelliJ internally is calling this
in fact I wouldn't be surprised if
232

232

00:10:22,060  -->  00:10:24,050
matches method under the covers
IntelliJ internally is calling this
233

233

00:10:24,050  -->  00:10:26,540
so when using matches with the begins
matches method under the covers
234

234

00:10:26,540  -->  00:10:28,690
with boundary matcher the carrier in other
so when using matches with the begins
235

235

00:10:28,690  -->  00:10:30,520
words the entire string has to match the
with boundary matcher the carrier in other
236

236

00:10:30,520  -->  00:10:32,870
regular expression and to see what I mean
words the entire string has to match the
237

237

00:10:32,870  -->  00:10:35,300
the following will actually return true
regular expression and to see what I mean
238

238

00:10:35,300  -->  00:10:36,760
so if we come back here and do a print
the following will actually return true
239

239

00:10:36,760  -->  00:10:42,070
out....and we actually
so if we come back here and do a print
240

240

00:10:42,070  -->  00:10:44,060
get the contents of alphanumeric copying
out....and we actually
241

241

00:10:44,060  -->  00:10:48,010
that and pasting that we should find
get the contents of alphanumeric copying
242

242

00:10:48,010  -->  00:10:52,690
that will actually return true then we
that and pasting that we should find
243

243

00:10:52,690  -->  00:10:56,000
could put a boundary match their our
that will actually return true then we
244

244

00:10:56,000  -->  00:10:57,640
carrot match at the start of the string and
could put a boundary match their our
245

245

00:10:57,640  -->  00:11:01,610
run that we also get a true in that
carrot match at the start of the string and
246

246

00:11:01,610  -->  00:11:03,580
scenario because now the entire string
run that we also get a true in that
247

247

00:11:03,580  -->  00:11:06,350
has matched so either way that will
scenario because now the entire string
248

248

00:11:06,350  -->  00:11:10,940
return true a little bit surprising but
has matched so either way that will
249

249

00:11:10,940  -->  00:11:13,550
just something to keep in mind i just
return true a little bit surprising but
250

250

00:11:13,550  -->  00:11:15,110
wanted to show you that because the
just something to keep in mind i just
251

251

00:11:15,110  -->  00:11:16,670
documentation for the matches method
wanted to show you that because the
252

252

00:11:16,670  -->  00:11:18,760
doesn't really make it clear that the
documentation for the matches method
253

253

00:11:18,760  -->  00:11:20,870
whole string must match for true to be
doesn't really make it clear that the
254

254

00:11:20,870  -->  00:11:23,680
returned and this actually makes sense
whole string must match for true to be
255

255

00:11:23,680  -->  00:11:25,670
though needing the full string to match
returned and this actually makes sense
256

256

00:11:25,670  -->  00:11:27,820
in the context of verifying user input
though needing the full string to match
257

257

00:11:27,820  -->  00:11:30,290
when we want the entire string or input
in the context of verifying user input
258

258

00:11:30,290  -->  00:11:32,660
to match a given pattern just something
when we want the entire string or input
259

259

00:11:32,660  -->  00:11:33,940
to keep in mind anyway
to match a given pattern just something
260

260

00:11:33,940  -->  00:11:36,110
alright let's move on to more character
to keep in mind anyway
261

261

00:11:36,110  -->  00:11:39,620
classes and boundary matches so the dollar
alright let's move on to more character
262

262

00:11:39,620  -->  00:11:41,750
boundary matcher dollar sign is always
classes and boundary matches so the dollar
263

263

00:11:41,750  -->  00:11:44,500
preceded by a pattern and it will
boundary matcher dollar sign is always
264

264

00:11:44,500  -->  00:11:46,370
actually match strings that end with the
preceded by a pattern and it will
265

265

00:11:46,370  -->  00:11:48,250
pattern in other words it's the opposite of
actually match strings that end with the
266

266

00:11:48,250  -->  00:11:50,770
the carrot boundary matcher so let's see
pattern in other words it's the opposite of
267

267

00:11:50,770  -->  00:11:54,310
an example of that working....
the carrot boundary matcher so let's see
268

268

00:11:54,310  -->  00:11:59,360
....
an example of that working....
269

269

00:11:59,360  -->  00:12:01,810
....
....
270

270

00:12:01,810  -->  00:12:04,790
...
....
271

271

00:12:04,790  -->  00:12:07,610
....
...
272

272

00:12:07,610  -->  00:12:09,170
....
....
273

273

00:12:09,170  -->  00:12:12,470
...
....
274

274

00:12:12,470  -->  00:12:14,810
....
...
275

275

00:12:14,810  -->  00:12:17,600
....
....
276

276

00:12:17,600  -->  00:12:19,200
...
....
277

277

00:12:19,200  -->  00:12:21,420
....so
...
278

278

00:12:21,420  -->  00:12:24,120
basically ijkl99z in my case is
....so
279

279

00:12:24,120  -->  00:12:25,080
what I've type in there for
basically ijkl99z in my case is
280

280

00:12:25,080  -->  00:12:26,910
alphanumeric we're going to replace that
what I've type in there for
281

281

00:12:26,910  -->  00:12:29,190
because we've used the boundary matcher
alphanumeric we're going to replace that
282

282

00:12:29,190  -->  00:12:32,220
we are telling it to only replace it if
because we've used the boundary matcher
283

283

00:12:32,220  -->  00:12:35,760
that's at the end so if we run that you
we are telling it to only replace it if
284

284

00:12:35,760  -->  00:12:37,380
can see we've got the end replacing the
that's at the end so if we run that you
285

285

00:12:37,380  -->  00:12:38,820
characters and I actually put in there
can see we've got the end replacing the
286

286

00:12:38,820  -->  00:12:43,290
in our pattern in case you're wondering I
characters and I actually put in there
287

287

00:12:43,290  -->  00:12:45,060
use replace all rather than matches
in our pattern in case you're wondering I
288

288

00:12:45,060  -->  00:12:46,920
because of the matches requirement that
use replace all rather than matches
289

289

00:12:46,920  -->  00:12:48,900
the entire string matches the expression
because of the matches requirement that
290

290

00:12:48,900  -->  00:12:50,340
rather than just part of it
the entire string matches the expression
291

291

00:12:50,340  -->  00:12:52,260
now when we want to match a specific
rather than just part of it
292

292

00:12:52,260  -->  00:12:54,690
letter or set of letters we can actually
now when we want to match a specific
293

293

00:12:54,690  -->  00:12:56,640
put those letters within square brackets
letter or set of letters we can actually
294

294

00:12:56,640  -->  00:12:59,610
so lets actually find and replace all
put those letters within square brackets
295

295

00:12:59,610  -->  00:13:02,970
occurrences of a e and I with X in our
so lets actually find and replace all
296

296

00:13:02,970  -->  00:13:05,340
alphanumeric string so to do that we
occurrences of a e and I with X in our
297

297

00:13:05,340  -->  00:13:07,320
can do....
alphanumeric string so to do that we
298

298

00:13:07,320  -->  00:13:12,150
....
can do....
299

299

00:13:12,150  -->  00:13:20,970
....
....
300

300

00:13:20,970  -->  00:13:23,400
...so that should replace all
....
301

301

00:13:23,400  -->  00:13:26,220
occurrences of a e and I in our alphanumeric
...so that should replace all
302

302

00:13:26,220  -->  00:13:29,430
string with the letter X let's run that
occurrences of a e and I in our alphanumeric
303

303

00:13:29,430  -->  00:13:34,050
and you can see that a e and i have been
string with the letter X let's run that
304

304

00:13:34,050  -->  00:13:36,900
replaced entirely with X's in our string
and you can see that a e and i have been
305

305

00:13:36,900  -->  00:13:39,960
now the length of the replacement string
replaced entirely with X's in our string
306

306

00:13:39,960  -->  00:13:42,150
doesn't have to be one so let's use the
now the length of the replacement string
307

307

00:13:42,150  -->  00:13:44,940
replacement string replace the letter here
doesn't have to be one so let's use the
308

308

00:13:44,940  -->  00:13:47,190
just to see what I mean so going
replacement string replace the letter here
309

309

00:13:47,190  -->  00:13:49,380
to copy that line again instead of just
just to see what I mean so going
310

310

00:13:49,380  -->  00:13:51,930
replacing with x going to put....
to copy that line again instead of just
311

311

00:13:51,930  -->  00:13:59,340
.....
replacing with x going to put....
312

312

00:13:59,340  -->  00:14:00,810
that each letter has been replaced by
.....
313

313

00:14:00,810  -->  00:14:02,790
the actual phrase are replaced the letter
that each letter has been replaced by
314

314

00:14:02,790  -->  00:14:05,190
here instead of the replacing it
the actual phrase are replaced the letter
315

315

00:14:05,190  -->  00:14:06,570
with a single letter as we did on the
here instead of the replacing it
316

316

00:14:06,570  -->  00:14:11,460
preceding line just to be clear and you
with a single letter as we did on the
317

317

00:14:11,460  -->  00:14:12,900
can probably see that in the example
preceding line just to be clear and you
318

318

00:14:12,900  -->  00:14:15,150
this regular expression isn't looking
can probably see that in the example
319

319

00:14:15,150  -->  00:14:17,730
for the pattern a e i instead each
this regular expression isn't looking
320

320

00:14:17,730  -->  00:14:20,070
individual characters are examined and if its
for the pattern a e i instead each
321

321

00:14:20,070  -->  00:14:23,280
an a e or an I then it matches this
individual characters are examined and if its
322

322

00:14:23,280  -->  00:14:24,810
expression in the replacement actually
an a e or an I then it matches this
323

323

00:14:24,810  -->  00:14:27,390
happens let's say we want to do the same
expression in the replacement actually
324

324

00:14:27,390  -->  00:14:29,640
again but we only want to replace the
happens let's say we want to do the same
325

325

00:14:29,640  -->  00:14:32,280
letters A E and I if they followed by an
again but we only want to replace the
326

326

00:14:32,280  -->  00:14:32,730
F
letters A E and I if they followed by an
327

327

00:14:32,730  -->  00:14:35,430
or a j so we can do something that
F
328

328

00:14:35,430  -->  00:14:40,380
something like this to achieve that....
or a j so we can do something that
329

329

00:14:40,380  -->  00:14:45,480
....
something like this to achieve that....
330

330

00:14:45,480  -->  00:14:54,770
....
....
331

331

00:14:54,770  -->  00:14:59,160
...
....
332

332

00:14:59,160  -->  00:15:01,980
so what we're going to do is so we're
...
333

333

00:15:01,980  -->  00:15:04,130
going to perform a replacement if one of
so what we're going to do is so we're
334

334

00:15:04,130  -->  00:15:06,380
the three letters A E or I is actually
going to perform a replacement if one of
335

335

00:15:06,380  -->  00:15:08,820
followed by an F or a J you can see we got
the three letters A E or I is actually
336

336

00:15:08,820  -->  00:15:11,040
an e their that is followed by an f and we've
followed by an F or a J you can see we got
337

337

00:15:11,040  -->  00:15:13,190
got an I that's followed by a j so
an e their that is followed by an f and we've
338

338

00:15:13,190  -->  00:15:14,450
we should have a couple of matches there
got an I that's followed by a j so
339

339

00:15:14,450  -->  00:15:16,010
that we can run through so let's just
we should have a couple of matches there
340

340

00:15:16,010  -->  00:15:20,310
run that and you can see we've only
that we can run through so let's just
341

341

00:15:20,310  -->  00:15:23,430
had a few replacements only the X and
run that and you can see we've only
342

342

00:15:23,430  -->  00:15:25,700
the x was replaced because we've got an f
had a few replacements only the X and
343

343

00:15:25,700  -->  00:15:28,500
their following the e so the third
the x was replaced because we've got an f
344

344

00:15:28,500  -->  00:15:29,790
occurrence was actually replaced with an
their following the e so the third
345

345

00:15:29,790  -->  00:15:33,300
X so only those occurence of A E and
occurrence was actually replaced with an
346

346

00:15:33,300  -->  00:15:35,910
I that was followed by f or j were replaced
X so only those occurence of A E and
347

347

00:15:35,910  -->  00:15:38,250
and note that both will replace their so
I that was followed by f or j were replaced
348

348

00:15:38,250  -->  00:15:42,120
in the case of the the first occurrence
and note that both will replace their so
349

349

00:15:42,120  -->  00:15:45,300
looking at the f there we have ABCDeee
in the case of the the first occurrence
350

350

00:15:45,300  -->  00:15:49,260
it's ABCDeee notice that the 3rd e and the
looking at the f there we have ABCDeee
351

351

00:15:49,260  -->  00:15:50,910
f were both ultimately replace with the
it's ABCDeee notice that the 3rd e and the
352

352

00:15:50,910  -->  00:15:52,940
X so it took the basically both characters
f were both ultimately replace with the
353

353

00:15:52,940  -->  00:15:55,680
and replaced them with an x and likewise for
X so it took the basically both characters
354

354

00:15:55,680  -->  00:15:59,190
the fourth i we had an I and a J and that
and replaced them with an x and likewise for
355

355

00:15:59,190  -->  00:16:00,630
was replaced with the x as well and
the fourth i we had an I and a J and that
356

356

00:16:00,630  -->  00:16:01,980
that's because our regular expression
was replaced with the x as well and
357

357

00:16:01,980  -->  00:16:04,560
needed two characters to match then
that's because our regular expression
358

358

00:16:04,560  -->  00:16:05,850
both those characters that were
needed two characters to match then
359

359

00:16:05,850  -->  00:16:09,000
matched were replaced with the X alright so
both those characters that were
360

360

00:16:09,000  -->  00:16:10,310
I'm going to finish the video here now
matched were replaced with the X alright so
361

361

00:16:10,310  -->  00:16:12,260
in the next video we're going to move on
I'm going to finish the video here now
362

362

00:16:12,260  -->  00:16:13,820
and we'll be looking at other boundary
in the next video we're going to move on
363

363

00:16:13,820  -->  00:16:16,070
matchers and other character classes will
and we'll be looking at other boundary
364

364

00:16:16,070  -->  00:16:18,020
also be looking at quantifiers as well
matchers and other character classes will
365

365

00:16:18,020  -->  00:16:24,920
i'll see you in the next video
also be looking at quantifiers as well
