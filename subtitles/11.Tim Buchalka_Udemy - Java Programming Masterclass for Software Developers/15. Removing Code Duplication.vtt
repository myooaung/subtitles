WEBVTT
1
00:00:05.220 --> 00:00:09.620
Also gut, am Ende des letzten Videos haben wir unser Programm gelesen und gesehen, dass wir den gleichen Applaus

2
00:00:09.810 --> 00:00:11.910
bekommen haben, den wir jetzt für einige Videos hatten.

3
00:00:12.480 --> 00:00:14.240
Aber wir haben unsere Parameter definiert.

4
00:00:14.240 --> 00:00:18.570
Wir können sagen, dass diejenigen, die in Zeile 23 aufschreiben, nicht ganz sehen können, dass sie das auch ein bisschen beschreiben.

5
00:00:18.570 --> 00:00:23.040
Es gibt vier Parameter, die wir definiert haben, und Sie können die Argumente sehen, bei

6
00:00:23.070 --> 00:00:24.870
denen wir die Methode online aufrufen.

7
00:00:24.880 --> 00:00:30.560
Zweitens ist es eine Zusammenfassung dessen, was hier passiert, wenn das Spiel entweder den Punktestand erreicht

8
00:00:30.560 --> 00:00:36.980
hat oder der Bonus ist, dass Java automatisch Variablen mit diesen Typen und Namen für uns erstellt und sie zuweist,

9
00:00:36.990 --> 00:00:42.840
wann immer wir einen Wert in den Klammern übergeben haben, wenn wir den aufrufen Berechnen Sie die Punktzahlmethode.

10
00:00:42.960 --> 00:00:46.020
Also echt achthundert Level absolviert und Bonus.

11
00:00:46.200 --> 00:00:50.100
Zum anderen müssen wir sicherstellen, dass beim Aufruf dieser Methode

12
00:00:50.100 --> 00:00:51.930
derselbe Parameter verwendet wird.

13
00:00:51.940 --> 00:00:56.120
Also, wir haben, dass diese vorbeikommen, müssen wir zuerst das in eine andere Position bringen.

14
00:00:56.150 --> 00:00:57.870
Endlich bekomme ich den Fehler.

15
00:00:57.870 --> 00:00:58.140
Gut.

16
00:00:58.140 --> 00:00:58.920
So weit, ist es gut.

17
00:00:58.950 --> 00:01:00.920
Uns geht es gut.

18
00:01:01.390 --> 00:01:04.920
Mal sehen, ob wir mit diesem Code dieses zweite Codebit bereinigen können.

19
00:01:04.920 --> 00:01:08.790
Hier ist deutlich über uns und nur eine Zeile definiert.

20
00:01:08.800 --> 00:01:13.410
Wir werden diese Methode erneut mit denselben Methodennamen bezeichnen, die den Score berechnen, und in Klammern.

21
00:01:13.570 --> 00:01:16.810
Was wir dieses Mal passieren werden, ist wieder wahr.

22
00:01:17.350 --> 00:01:21.190
Ja, dieses Spiel ist vorbei und auf diese Weise erhalten wir die relevante Ausgabe,

23
00:01:21.190 --> 00:01:26.610
die zeigt, dass wir die Werte, die wir hartcodieren werden, bestehen werden, zehntausendvier Punkte aus Zeile 14, gemeinsames Level abgeschlossen.

24
00:01:26.620 --> 00:01:32.570
Ich werde das Komma in die oberste Acht setzen und dann mit einem Bonus abschließen. Dies ist die letzte

25
00:01:32.950 --> 00:01:36.570
Zeile von sechzehn zu zweihundert, und es gibt eine gültige Ecke.

26
00:01:36.580 --> 00:01:40.120
Nun, da ich getan habe, dass wir diesen Code vollständig bereinigen können

27
00:01:42.850 --> 00:01:46.450
und Sie sehen, dass unsere Methode jetzt ziemlich gut aussieht, haben wir

28
00:01:46.450 --> 00:01:47.770
eine Menge davon bereinigt.

29
00:01:47.770 --> 00:01:52.110
Beachten Sie, dass wir die Partitur, die gelöscht wird, nicht mehr sehr gut verwenden, wenn

30
00:01:52.110 --> 00:01:58.100
wir den Mauszeiger über die Partitur halten, und auch über seine Partitur, können wir sagen, dass keine dieser Variablen verwendet wird.

31
00:01:58.180 --> 00:02:03.190
Denken Sie daran, und wir werden mehr darüber sprechen, wenn wir über den Gültigkeitsbereich sprechen, aber

32
00:02:03.400 --> 00:02:08.610
diese Variablen, die wir in unserer Hauptmethode erstellt haben, sind nur für die Hauptmethode und funktionieren hier nicht.

33
00:02:08.610 --> 00:02:13.690
Mit anderen Worten, wir können sehr gerne gleichnamige Variablen außerhalb unserer Berechnungsmethode

34
00:02:13.690 --> 00:02:14.500
definieren.

35
00:02:14.500 --> 00:02:16.890
Dies bedeutet nicht, dass es in der Hauptmethode nicht mehr verwendet wird.

36
00:02:16.900 --> 00:02:23.170
Das liegt daran, dass wir diesen Code gelöscht haben, damit ich diese jetzt gerne löschen kann. Beachten Sie jedoch, dass die Stufe

37
00:02:23.170 --> 00:02:29.530
und der Bonus, die wir derzeit noch in Zeile 9 verwenden, abgeschlossen sind. Beim Löschen dieser Codes wird also tatsächlich eine Beschwerde

38
00:02:29.530 --> 00:02:34.330
von Intel angezeigt Löse das einfache Level und den Bonus, was natürlich richtig ist, weil wir

39
00:02:34.330 --> 00:02:35.740
sie gerade gelöscht haben.

40
00:02:36.700 --> 00:02:41.730
Ich möchte also die Gelegenheit nutzen, um diese Änderung kurz rückgängig zu machen, damit ich sehe, dass das

41
00:02:41.740 --> 00:02:44.280
abgeschlossene Level fünf und der Bonus einhundert war.

42
00:02:44.410 --> 00:02:50.260
Lassen Sie uns den Auszahlungsbonus auf einhundert ändern, und dann haben wir es geschafft.

43
00:02:50.350 --> 00:02:53.260
Man kann sagen, dass wir zu dieser Zeit alle die gleichen Informationen darüber hatten, dass sie nicht genutzt wurden.

44
00:02:53.600 --> 00:02:55.250
Ich räum das auch auf.

45
00:02:55.280 --> 00:03:01.000
Folglich besteht unsere gesamte Hauptmethode jetzt aus nur zwei Aufrufen zum Berechnen der Punktzahl, und Sie können sehen, dass für

46
00:03:01.000 --> 00:03:05.200
die meisten Variablen, die nicht unsere sind, andere Werte übergeben werden, die in beiden

47
00:03:05.200 --> 00:03:10.030
Fällen auf true gesetzt sind, und das ist auch so dass wir den Code tatsächlich ausgeben

48
00:03:10.030 --> 00:03:14.230
oder den Code ausführen lassen und die Zeilen 15 bis 17 setzen können.

49
00:03:14.350 --> 00:03:19.030
Jetzt, bevor ich mehr über unser Endergebnis spreche, wenn wir diesen Code ausführen, erinnere ich mich an die Pellets, die

50
00:03:19.030 --> 00:03:21.670
wir jetzt für einige Videos hatten, wenn wir ihn ausführen.

51
00:03:21.670 --> 00:03:25.010
Beachten Sie, dass jetzt verschiedene Werte auf dem Bildschirm angezeigt werden.

52
00:03:25.240 --> 00:03:29.200
Die endgültigen Ergebnisse, die Sie jetzt haben, sind zweitausenddreihundertzwölftausendsechshundert, und wenn Sie sich erinnern,

53
00:03:29.200 --> 00:03:33.970
habe ich vor ein paar Tagen darüber gesprochen, dass wir eine Änderung an einer Stelle vorgenommen haben,

54
00:03:34.000 --> 00:03:38.950
und das war der Code, der 1000 zum endgültigen Ergebnis hinzufügt, und unsere erste Ausgabe war dreiundzwanzighundert, aber

55
00:03:38.950 --> 00:03:40.250
die zweite war elftausendsechshundert.

56
00:03:40.360 --> 00:03:45.430
Aber jetzt, da wir vertauscht haben und die Punktzahl für beide Anrufe berechnet wurden, können Sie sagen, dass die

57
00:03:45.430 --> 00:03:50.380
Endpunktzahl jetzt für jeden dieser Anrufe angepasst wird, die wir an einer Stelle geändert haben, und die Ausgabe

58
00:03:50.380 --> 00:03:55.030
wird angezeigt Wir haben vorgeschlagen, dies hier zu tun: Wir haben unsere Codeduplizierung entfernt und die Bearbeitung

59
00:03:55.450 --> 00:03:58.510
vereinfacht, da wir eine Änderung an einer Stelle vornehmen können.

60
00:03:58.510 --> 00:04:04.310
Jetzt wird der Code in der Berechnungsmethode für die Punktzahl geändert, sobald wir die Berechnungsmethode für die Punktzahl aufrufen.

61
00:04:04.320 --> 00:04:06.200
Es ist viel einfacher zu warten.

62
00:04:06.340 --> 00:04:11.380
Wir müssen uns keine Sorgen machen, dass wir Änderungen verpassen, wenn wir überall Code-Duplikate haben.

63
00:04:11.560 --> 00:04:16.180
Und nur um zu demonstrieren, dass ich jetzt diese 1000 auf 2000 ändern kann.

64
00:04:16.570 --> 00:04:20.470
Wir können uns daran erinnern, dass wir mit den

65
00:04:20.470 --> 00:04:26.450
Werten, die wir zuvor auf dem Bildschirm hatten, jetzt die endgültigen Punktewerte von

66
00:04:26.450 --> 00:04:28.370
dreitausenddreihundertdreizehntausendsechshundert erreicht haben.

67
00:04:28.430 --> 00:04:32.850
Offensichtlich wurden beide um zusätzliche 1000 Punkte aktualisiert.

68
00:04:32.930 --> 00:04:33.490
Ich denke du würdest zustimmen.

69
00:04:33.490 --> 00:04:38.390
Betrachtet man den Code, den wir jetzt haben, ist es viel einfacher, ihn zu lesen. Weniger

70
00:04:38.390 --> 00:04:44.210
Code ist normalerweise ein gutes Zeichen, weil es weniger zu verstehen gibt und nicht nur weniger Code zu verstehen

71
00:04:44.210 --> 00:04:49.370
und zu warten ist, was Sie tun Als Entwickler müssen Sie sicherstellen, dass der Code aktualisiert und

72
00:04:49.370 --> 00:04:50.760
einfacher zu warten ist.

73
00:04:50.870 --> 00:04:53.180
Aber wir haben auch diese Codeduplizierung entfernt.

74
00:04:53.340 --> 00:04:54.460
Es ist im Grunde eine Win-Win-Situation.

75
00:04:55.650 --> 00:05:00.030
Im Wesentlichen ist eines der großartigen Merkmale von Methoden, dass es Ihnen das Leben erheblich erleichtert, Ihren Code zu

76
00:05:00.030 --> 00:05:03.600
pflegen, da Sie jetzt buchstäblich nur eine Stelle haben, an der der Code geändert wird.

77
00:05:03.600 --> 00:05:08.210
Diese eine Methode ist, warum es kein Problem mit der Verwendung von Variablen gab.

78
00:05:08.210 --> 00:05:11.650
Also, bevor ich diese Variablen aus der Hauptmethode gelöscht habe.

79
00:05:11.680 --> 00:05:13.500
Sie können das mit Sicherheit tun, und das ist mit Sicherheit gültig.

80
00:05:13.510 --> 00:05:17.770
Und es gab viele Szenarien, in denen es gültig war, aber es fängt gerade erst mit der Diskussion der Methode

81
00:05:17.770 --> 00:05:18.140
an.

82
00:05:18.140 --> 00:05:19.530
Also müssen wir irgendwo anfangen.

83
00:05:19.690 --> 00:05:21.520
Es ist also einfach, Ihnen zu zeigen, wie das geht.

84
00:05:21.940 --> 00:05:27.250
Und im Allgemeinen ist es eine gute Idee, die Menge an Code, die Sie eingeben, zu reduzieren,

85
00:05:27.250 --> 00:05:31.720
wenn eine Variable nur zur Übergabe an eine Methode verwendet wird und diese

86
00:05:31.720 --> 00:05:34.480
für nichts anderes verwendet wird dieser einfache Test.

87
00:05:34.480 --> 00:05:39.560
Wenn Sie jedoch Produktionscode ausführen, gibt es möglicherweise ein Argument, das die Definition eines Variablennamens vereinfacht.

88
00:05:39.610 --> 00:05:44.260
Wir werden jedoch etwas später mehr über die Art der Regeln und bewährten Methoden für

89
00:05:44.260 --> 00:05:45.100
Methoden sprechen.

90
00:05:45.100 --> 00:05:47.680
Wir fangen gerade erst damit an.

91
00:05:47.680 --> 00:05:47.950
Gut.

92
00:05:47.950 --> 00:05:52.690
Grundsätzlich können Sie immer noch fest codierte Zahlen verwenden, da wir hier in den Zeilen sieben bis acht die Literalwerte

93
00:05:53.170 --> 00:05:57.460
verwenden, mit denen wir Variablen definieren können, wenn Sie möchten, und den Variablennamen verwenden, den Sie zuvor

94
00:05:57.490 --> 00:05:58.640
im Video gesehen haben.

95
00:05:58.930 --> 00:06:03.160
Und wieder passiert es, wenn Sie Variablen verwenden und eine Methode aufrufen, deren Wert dieses Argument

96
00:06:03.160 --> 00:06:08.620
übergibt, und Java automatisch einen Variablennamen erstellt, während wir über die Variable top gesprochen haben und der Name auf dem

97
00:06:08.650 --> 00:06:10.900
basiert, was in den Parametern definiert ist.

98
00:06:10.900 --> 00:06:16.300
In diesem Fall werden in den Zeilen 11 und 12 die Werte zugewiesen und als Argumente übergeben. In

99
00:06:16.330 --> 00:06:19.160
diesen Methoden werden die Zeilen sieben bis acht aufgerufen.

100
00:06:19.180 --> 00:06:22.050
Nun, ich denke, ich stimme zu, dass die Methoden für sich genommen ziemlich cool sind.

101
00:06:22.060 --> 00:06:26.500
Die Tatsache, dass wir tatsächlich eine Methode aufrufen und sie dazu bringen können, etwas zu

102
00:06:26.500 --> 00:06:31.420
tun, damit unser Code viel sauberer aussieht, ist eine coole Sache, aber es wird sogar noch

103
00:06:31.420 --> 00:06:36.430
kälter, weil wir unsere Methode dazu bringen können, dies zu tun Einige Berechnungen ähneln denen, die derzeit

104
00:06:36.430 --> 00:06:41.860
ausgeführt werden, aber dann können wir das Ergebnis dieser Berechnung oder dieser Verarbeitung an den Code zurücksenden, der ausgeführt

105
00:06:41.860 --> 00:06:45.880
wurde, dass die Methode ursprünglich aufgerufen wurde, möglicherweise für eine spätere Verarbeitung.

106
00:06:46.000 --> 00:06:47.760
Das ist das Thema des nächsten Videos.

107
00:06:47.890 --> 00:06:49.360
Wir sehen uns im nächsten Video.
