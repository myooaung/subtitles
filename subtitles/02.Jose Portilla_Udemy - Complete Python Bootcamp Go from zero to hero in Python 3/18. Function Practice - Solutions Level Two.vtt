WEBVTT
1
00:00:05.360 --> 00:00:09.680
Selamat datang kembali di kuliah ini kita akan membahas solusi untuk masalah level dua

2
00:00:09.680 --> 00:00:11.570
dan masalah fungsi praktik notebook.

3
00:00:11.690 --> 00:00:12.700
Mari kita mulai.

4
00:00:12.980 --> 00:00:14.540
Baiklah jadi di sini ada dua masalah.

5
00:00:14.540 --> 00:00:20.990
Masalah pertama yang kami miliki adalah 5:33 yang diberi daftar integer return true jika daftar atau array ini berisi tiga

6
00:00:21.320 --> 00:00:23.690
atau dua berikutnya tiga di suatu tempat.

7
00:00:23.720 --> 00:00:26.310
Jadi di sini kita bisa melihat tiga dan tiga bersama.

8
00:00:26.420 --> 00:00:30.130
Jadi kita katakan benar di sini bertiga tidak terhubung dengan cara apa pun jadi kita katakan salah

9
00:00:30.140 --> 00:00:32.000
Dan lagi di sini bertiga tidak terhubung bersama.

10
00:00:32.010 --> 00:00:33.060
Jadi kami katakan salah.

11
00:00:33.080 --> 00:00:37.250
Jadi pada dasarnya pada dua tiga berturut-turut kita tahu untuk mengembalikan true.

12
00:00:37.250 --> 00:00:39.820
Jadi lakukan ini atau lakukan logika berikut.

13
00:00:40.280 --> 00:00:49.270
Kami akan mengatakan untuk saya dalam kisaran dari 0 dan kami sebenarnya tidak ingin pergi jauh ke akhir angka.

14
00:00:49.360 --> 00:00:55.530
Kami ingin pergi ke panjang dari yang minus karena kami ingin naik ke digit kedua ke terakhir.

15
00:00:55.550 --> 00:01:01.220
Jadi kita dapat memeriksa digit berikutnya jika kita naik ke digit terakhir

16
00:01:01.220 --> 00:01:10.860
tidak akan ada digit berikutnya untuk memeriksa itulah sebabnya kita akan mengatakan rentang besi dari 0 hingga panjang mati rasa minus 1.

17
00:01:10.870 --> 00:01:12.240
Jadi ini bagian dari triknya.

18
00:01:12.670 --> 00:01:32.490
Dan kita dapat mengatakan jika mati rasa mata sama dengan 3 dan mati rasa ditambah 1 sama dengan 3 maka kembali benar.

19
00:01:32.580 --> 00:01:36.100
Kalau tidak, yang akan kita lakukan adalah mengembalikan false.

20
00:01:36.360 --> 00:01:37.880
Jadi dan itulah yang saya lakukan di sini.

21
00:01:37.980 --> 00:01:43.920
Saya akan menjalankan for for loop yang melewati setiap posisi indeks tunggal dalam daftar ini hingga

22
00:01:44.070 --> 00:01:47.470
yang kedua hingga terakhir dan kemudian kita akan lakukan.

23
00:01:47.790 --> 00:01:51.750
Maka yang akan kita lakukan di sini adalah memeriksa nomor itu dan nomor yang ada di sebelahnya.

24
00:01:51.840 --> 00:01:53.240
Begitu banyak.

25
00:01:53.510 --> 00:01:56.190
Dan angka di sebelahnya adalah angka I ditambah 1.

26
00:01:56.190 --> 00:02:00.840
Dan jika mereka berdua bertiga maka kita akan mengembalikan true jika kita melalui seluruh empat loop ini dan

27
00:02:00.840 --> 00:02:02.650
kita tidak pernah menjalankan pernyataan pengembalian ini.

28
00:02:02.730 --> 00:02:06.070
Maka kita tahu tidak ada bertiga bersama dan akan kembali palsu.

29
00:02:06.090 --> 00:02:08.270
Jadi mari kita jalankan ini dan memeriksanya.

30
00:02:08.310 --> 00:02:11.700
Kami akan menyalin tempel ini di sini.

31
00:02:11.820 --> 00:02:12.870
Jalankan itu dan kami kembali.

32
00:02:12.870 --> 00:02:13.290
Benar.

33
00:02:13.320 --> 00:02:14.430
Asharq salah satu yang palsu.

34
00:02:14.430 --> 00:02:16.100
Lihat apakah itu juga berfungsi.

35
00:02:16.120 --> 00:02:16.920
Masukkan itu ke dalam.

36
00:02:16.980 --> 00:02:18.500
Jalankan dan kami kembali salah.

37
00:02:18.600 --> 00:02:19.520
Sempurna.

38
00:02:19.530 --> 00:02:28.650
Sekarang alternatif lain yang bisa kita lakukan yang tidak terlihat sebaik pernyataan ini adalah dengan mengatakan

39
00:02:29.390 --> 00:02:38.430
jika mati rasa saya diiris ke saya ditambah dua sama dengan daftar 3 tiga.

40
00:02:38.510 --> 00:02:40.690
Ini sebenarnya sama persis seperti sebelumnya.

41
00:02:40.700 --> 00:02:43.760
Hanya saja menurut saya sedikit kurang mudah dibaca.

42
00:02:43.810 --> 00:02:49.110
Secara teknis sedikit lebih ramping karena Anda hanya melakukan satu potong dan satu perbandingan, bukan

43
00:02:49.130 --> 00:02:50.130
dua perbandingan.

44
00:02:50.300 --> 00:02:56.190
Jadi yang dilakukan adalah mengambil irisan sekaligus dan membandingkannya dengan sublist tiga tiga ini.

45
00:02:56.210 --> 00:02:56.410
Baiklah.

46
00:02:56.420 --> 00:03:02.020
Mari kita beralih ke masalah ini yang disebut Paper Doll.

47
00:03:02.030 --> 00:03:07.760
Jadi untuk masalah boneka kertas ini kami ingin mengatakan diberikan string kembali string di mana untuk setiap karakter

48
00:03:07.760 --> 00:03:10.080
dalam aslinya Sekarang ada tiga karakter.

49
00:03:10.100 --> 00:03:15.400
Jadi intinya pergi dan buat tiga karakter ini jadi tiga H's tiga E's tiga L's.

50
00:03:15.410 --> 00:03:18.290
Satu set tiga L dan kemudian tiga pergi.

51
00:03:18.450 --> 00:03:23.410
Dan ini sebenarnya tidak terlalu buruk setelah Anda mengetahui triknya adalah dengan memulai string kosong

52
00:03:23.410 --> 00:03:25.490
dan kemudian terus menyatukan string itu.

53
00:03:25.530 --> 00:03:30.050
Jadi saya akan mengatakan hasil dimulai sebagai string kosong.

54
00:03:31.560 --> 00:03:37.650
Dan kemudian untuk setiap karakter dalam teks yang saya lewati, saya akan mengambil hasil saya saat ini

55
00:03:37.650 --> 00:03:42.600
sehingga string saat ini dan saya akan menambahkan pada karakter itu tiga kali.

56
00:03:42.600 --> 00:03:46.390
Hal lain yang bisa dilakukan adalah mengatakan karakter plus karakter plus karakter.

57
00:03:46.410 --> 00:03:50.580
Jadi, kali tiga atau tiga karakter digabungkan bersama, itu hal yang sama.

58
00:03:51.180 --> 00:03:55.780
Dan kemudian pada akhir ini untuk loop di luarnya, saya hanya akan mengatakan hasil pengembalian.

59
00:03:55.820 --> 00:03:56.980
Dan itu sebenarnya yang harus Anda lakukan.

60
00:03:57.060 --> 00:04:02.500
Jadi trik utama di sini adalah menyadari bahwa Anda dapat terus menyambung ke string.

61
00:04:02.660 --> 00:04:09.020
Pertanyaan selanjutnya disebut Black Jack yang pada dasarnya menggunakan permainan kartu blackjack sebagai dasar untuk pernyataan masalah

62
00:04:09.020 --> 00:04:13.700
yang diberikan kami diberi tiga bilangan bulat antara 1 dan 11.

63
00:04:13.730 --> 00:04:17.930
Dan jika ada beberapa kurang dari atau sama dengan 21, kami hanya mengembalikan beberapa.

64
00:04:17.930 --> 00:04:24.460
Namun, jika ada beberapa yang melebihi 21 dan ada 11, kami mendapat peluang untuk mengurangi jumlah total sebesar 10.

65
00:04:24.800 --> 00:04:30.180
Dan akhirnya jika beberapa bahkan setelah penyesuaian melebihi 21 kita kembali gagal.

66
00:04:30.260 --> 00:04:31.370
Jadi mari kita periksa ini.

67
00:04:31.430 --> 00:04:36.670
Single pertama hanya memeriksa apakah ada kurang dari atau sama dengan 21.

68
00:04:36.840 --> 00:04:41.990
Dan kita dapat melakukan ini dengan mengatakan jika

69
00:04:44.570 --> 00:04:52.180
beberapa ABC kurang dari atau sama dengan 21 kembali yang beberapa mengatakan beberapa ABC.

70
00:04:52.550 --> 00:04:55.310
Jadi beberapa fungsi bawaan yang bagus bisa Anda gunakan.

71
00:04:55.310 --> 00:04:59.640
Atau Anda bisa mengirim b vagina plus.

72
00:04:59.750 --> 00:05:06.290
Jadi itu hal yang sama dengan melewati daftar BNC di sini.

73
00:05:06.320 --> 00:05:09.500
Jadi kami akan menggunakan beberapa kata kunci karena sedikit lebih mudah dibaca.

74
00:05:10.940 --> 00:05:11.140
Baiklah.

75
00:05:11.140 --> 00:05:16.340
Hal berikutnya yang akan kita periksa adalah kasus kedua di mana kita memiliki angka 11 di sana.

76
00:05:16.460 --> 00:05:23.330
Jadi ingat ada 11 kita bisa mengurangi jumlah total sebesar 10 dan kemudian kita benar-benar memeriksa apakah itu melebihi atau

77
00:05:23.330 --> 00:05:23.910
tidak.

78
00:05:24.140 --> 00:05:30.790
Jadi yang bisa Anda lakukan adalah mengatakan elif berikut.

79
00:05:30.940 --> 00:05:37.830
Ada 11 dalam daftar A B C.

80
00:05:38.030 --> 00:05:50.510
Jadi jika ada 11 di sana dan beberapa dari ketiganya disatukan kurang atau sama dengan 31 karena ingat kita harus mengurangi jumlah total

81
00:05:50.510 --> 00:05:54.530
sebesar 10 ketika ada 11 di sana.

82
00:05:54.530 --> 00:06:00.600
Jadi pada dasarnya kita bisa mengeceknya dengan tigapuluh satu kali ini lalu kita bisa mengembalikan jumlahnya.

83
00:06:00.600 --> 00:06:08.750
Jadi kemudian kita dapat mengembalikan jumlah ABC ini kecuali kita akan mengurangi 10 dari ini.

84
00:06:08.780 --> 00:06:16.010
Jadi ini kurang dari atau sama dengan 31 pada dasarnya semua yang kita lakukan sekarang bukannya memeriksa kurang dari 21 karena

85
00:06:16.160 --> 00:06:18.910
sebelumnya kita dapat mengurangi jumlah dengan 10.

86
00:06:18.920 --> 00:06:21.600
Itu berarti kita harus memeriksa 31.

87
00:06:21.710 --> 00:06:29.520
Jadi cara lain untuk melakukan ini adalah mengatakan beberapa ABC minus 10 kurang atau sama dengan 21.

88
00:06:29.540 --> 00:06:34.250
Jadi itu adalah hal yang sama dan terserah kepada Anda logika mana yang Anda pilih

89
00:06:34.250 --> 00:06:41.000
apakah Anda lebih suka mengambil jumlah kemudian mengurangi 10 dan kemudian memeriksa apakah itu kurang di bawah 21 atau jika Anda hanya ingin

90
00:06:41.120 --> 00:06:44.690
melakukan pemeriksaan terhadap 31 sehingga secara teknis hal yang sama sana.

91
00:06:44.720 --> 00:06:47.750
Akhirnya jika itu memang terjadi maka orang ini telah rusak.

92
00:06:47.770 --> 00:06:50.240
Jadi kami kembali bangkrut.

93
00:06:50.420 --> 00:06:51.500
Sekarang kita jalankan ini.

94
00:06:51.590 --> 00:06:57.160
Kami kembali 18 bust dan kemudian kami berlari dari waktu ke waktu kami kembali 19.

95
00:06:57.630 --> 00:07:01.000
Oke mari kita pergi ke masalah berikutnya yaitu Summer of 69.

96
00:07:01.160 --> 00:07:06.750
Kami ingin Anda kembali ke beberapa angka dalam array kecuali mengabaikan bagian angka yang dimulai dengan

97
00:07:06.750 --> 00:07:09.280
6 dan meluas ke 9 berikutnya.

98
00:07:09.320 --> 00:07:14.040
Jadi setiap 6 akan diikuti oleh setidaknya 1 9 dan kami kembali ke 0 4.

99
00:07:14.060 --> 00:07:16.340
Tidak ada angka.

100
00:07:16.380 --> 00:07:17.670
Jadi apa artinya itu sebenarnya.

101
00:07:17.700 --> 00:07:19.780
Kita bisa lihat di sini tiga sampel berbeda di sini.

102
00:07:19.800 --> 00:07:22.550
Kami memiliki 1 3 5 7 6 atau 9 di sana.

103
00:07:22.590 --> 00:07:26.520
Jadi kembalilah ke beberapa dari mereka yang merupakan satu tambah tiga ditambah 5 yaitu 9.

104
00:07:26.730 --> 00:07:28.750
Di sini kita kembali 4 5.

105
00:07:28.920 --> 00:07:31.080
Dan kemudian kita memiliki 6 7 8 9.

106
00:07:31.260 --> 00:07:34.610
Jadi 6 sampai 9 di sini akan diabaikan.

107
00:07:34.680 --> 00:07:36.050
Jadi itu musim panas tahun 69.

108
00:07:36.060 --> 00:07:38.890
Kami mengabaikannya karena katakanlah tidak ada yang dilakukan di sana.

109
00:07:38.940 --> 00:07:42.080
Jadi kita tambahkan saja empat tambah lima dan kita dapatkan kembali 9.

110
00:07:42.150 --> 00:07:45.000
Di sini kita mendapatkan 1 dan kemudian kita memiliki 6 dan 9.

111
00:07:45.000 --> 00:07:51.070
Jadi dua angka ini ditambah apa saja di antara diabaikan dan kemudian kita melihat banyak di sana dan mereka pergi

112
00:07:51.100 --> 00:07:56.090
ke 14 dan kami juga mencatat bahwa setiap enam akan diikuti oleh setidaknya 1 9.

113
00:07:56.220 --> 00:08:00.180
Ketika Anda diberikan dalam daftar ini, Anda tidak perlu khawatir tentang semacam kasus tepi aneh di

114
00:08:00.180 --> 00:08:03.890
mana Anda hanya memiliki 6 dan kemudian Anda menunggu sembilan yang tidak pernah datang.

115
00:08:03.890 --> 00:08:05.470
OK jadi mari kita mulai ini.

116
00:08:05.670 --> 00:08:11.130
Cara kita akan melakukan ini adalah mulai menjalankan total kita akan mengatakan total sama dengan nol.

117
00:08:11.540 --> 00:08:17.910
Dan saya juga akan membuat nilai boolean yang disebut AD dan dan saya mengatakan bahwa

118
00:08:17.910 --> 00:08:25.320
yang benar pertama dan saya akan mengatakan mati rasa dalam array saya atau dalam daftar saya saat iklan aktif.

119
00:08:25.320 --> 00:08:26.550
Jadi, sementara saya masih menambahkan.

120
00:08:26.560 --> 00:08:33.930
Yah itu benar dan kita mulai setengah benar jika angka saat ini tidak sama dengan 6 maka saya

121
00:08:33.960 --> 00:08:37.280
akan mengambil total saya dan saya akan menambahkannya.

122
00:08:38.410 --> 00:08:40.540
Dan kemudian saya akan keluar dari sini.

123
00:08:42.770 --> 00:08:49.680
Lain yang akan saya lakukan adalah menambahkan sama dengan false dan kemudian berbaris dengan loop sementara ini.

124
00:08:49.680 --> 00:09:03.890
Apa yang akan saya lakukan adalah mengatur sementara tidak menambahkan cara lain untuk mengatakan menambahkan tidak sama dengan benar jika tidak ada sama dengan

125
00:09:03.890 --> 00:09:06.860
9 yang akan saya hancurkan.

126
00:09:08.350 --> 00:09:18.940
Kalau tidak, saya akan menambahkan itu kembali ke true dan kemudian istirahat di sini dan akhirnya setelah semua ini di luar ini untuk loop

127
00:09:18.940 --> 00:09:20.880
saya akan mengembalikan total.

128
00:09:20.890 --> 00:09:24.130
Jadi mari kita jalankan ini dan kemudian kita akan memecah penjelasannya.

129
00:09:24.130 --> 00:09:24.330
BAIK.

130
00:09:24.340 --> 00:09:26.780
Jadi sepertinya kita punya sembilan di sini yang terlihat bagus.

131
00:09:26.950 --> 00:09:28.690
Kami punya sembilan di sini.

132
00:09:28.690 --> 00:09:29.290
Itu terlihat bagus.

133
00:09:29.290 --> 00:09:30.210
Empat dan Lima bersama.

134
00:09:30.220 --> 00:09:31.150
Abaikan semua ini.

135
00:09:31.300 --> 00:09:32.210
Dan ada yang enam puluh sembilan.

136
00:09:32.210 --> 00:09:36.310
Di sini kita hanya mendapatkan dua tambah satu 11 yaitu 14.

137
00:09:36.400 --> 00:09:38.880
Jadi itu sebenarnya terjadi di sini dalam logika kita.

138
00:09:39.060 --> 00:09:40.090
Kami memiliki total yang nol.

139
00:09:40.090 --> 00:09:41.080
Itu masuk akal.

140
00:09:41.080 --> 00:09:44.440
Dan kami memiliki kondisi boolean ini yang disebut ADD yang sama dengan true.

141
00:09:44.650 --> 00:09:48.970
Dan pada dasarnya secara default saya akan menganggap bahwa saya akan terus menambahkan semua angka dalam daftar ini

142
00:09:48.970 --> 00:09:49.910
atau dalam survei.

143
00:09:50.200 --> 00:09:55.480
Jadi saya akan melalui array dan saya katakan OK untuk setiap angka dalam array jika pernyataan

144
00:09:55.480 --> 00:09:58.720
ADD saya benar maka saya akan melakukan pemeriksaan berikut.

145
00:09:58.960 --> 00:10:05.380
Jika jumlah mereka yang kebetulan 6 saya akan mengatakan Ambil total sebagai jumlah di sana dan kemudian

146
00:10:05.470 --> 00:10:08.020
saya akan keluar dari lingkaran itu.

147
00:10:08.260 --> 00:10:13.090
Jadi saya akan keluar dari loop inclosing ini yang merupakan loop sementara yang

148
00:10:13.240 --> 00:10:18.790
membawa saya kembali ke loop for dan saya melanjutkan kemudian saya suka mengatakan yang lain.

149
00:10:19.110 --> 00:10:22.180
Jadi misalkan angkanya 6 jadi ini memang benar.

150
00:10:22.350 --> 00:10:25.080
Lalu saya katakan tambahkan sama dengan salah.

151
00:10:25.080 --> 00:10:28.290
Jadi dalam hal ini sekarang saya hanya menunggu sembilan.

152
00:10:28.410 --> 00:10:30.750
Jadi saya sekarang di musim panas 69 dan saya harus terus berjalan.

153
00:10:30.750 --> 00:10:31.730
Menunggu sembilan.

154
00:10:31.980 --> 00:10:39.370
Jadi saya akan mengatakannya sementara tidak menambahkan jika mati rasa tidak sama dengan 9 maka saya akan keluar dari ini sementara tidak menambahkan

155
00:10:39.630 --> 00:10:42.320
atau saya akan mengatakan menambahkan sama dengan benar.

156
00:10:42.450 --> 00:10:44.180
Dan kemudian itu akan pecah.

157
00:10:44.270 --> 00:10:44.840
BAIK.

158
00:10:44.940 --> 00:10:49.170
Jadi yang ini sedikit rumit karena kami menggunakan istirahat di sini dan kami memiliki

159
00:10:49.170 --> 00:10:53.160
situasi loop bersarang kami memiliki loop dengan dua sementara loop bersarang di sana.

160
00:10:53.190 --> 00:10:58.470
Jadi hal utama yang perlu diperhatikan di sini adalah bahwa istirahat ini hanya terhubung ke loop Sementara itu dan istirahat

161
00:10:58.470 --> 00:11:03.090
ini hanya terhubung ke loop kawat di sana yang akan membawa Anda kembali ke sini untuk loop

162
00:11:03.090 --> 00:11:04.810
sehingga Anda dapat melanjutkan nomor.

163
00:11:04.920 --> 00:11:07.290
Saya akan mengatakan ini jelas mungkin masalah yang paling sulit.

164
00:11:07.320 --> 00:11:13.560
Saya akan mengatakan dalam seluruh tantangan ini sejauh yang tidak secara khusus menantang masalah tetapi bahkan

165
00:11:13.850 --> 00:11:19.280
saya berpikir bahwa musim panas ini mungkin lebih sulit daripada masalah menantang pertama.

166
00:11:19.280 --> 00:11:19.600
BAIK.

167
00:11:19.620 --> 00:11:23.670
Dan kuliah berikutnya akan mengakhiri diskusi kita dengan membahas masalah-masalah yang menantang ini

168
00:11:23.970 --> 00:11:24.970
dan solusinya.

169
00:11:24.990 --> 00:11:25.530
Kita akan melihat yang lain.
