WEBVTT
1
00:00:05.210 --> 00:00:10.140
Dalam kuliah ini kita akan membuat katalog melalui solusi untuk masalah praktik fungsi sebelumnya.

2
00:00:10.140 --> 00:00:11.230
Mari kita mulai.

3
00:00:11.580 --> 00:00:16.980
OK mari kita mulai dengan bagian pemanasan ini dan yang ini disebut lebih rendah dari dua kejahatan Anda ingin

4
00:00:16.980 --> 00:00:22.380
menulis fungsi yang mengembalikan lebih rendah dari dua angka yang diberikan jika kedua angka genap tetapi mengembalikan lebih besar

5
00:00:22.470 --> 00:00:24.200
jika satu atau kedua angka ganjil.

6
00:00:24.570 --> 00:00:29.510
Jadi di sini kita memiliki fungsi kita dan dibutuhkan angka dalam angka menjadi hal

7
00:00:29.520 --> 00:00:33.210
pertama yang ingin Anda lakukan mungkin diperiksa apakah jumlahnya sama.

8
00:00:33.430 --> 00:00:38.900
Dan dengan begitu kita memiliki pernyataan if jadi kita akan mengatakan jika mod 2 sama dengan nol.

9
00:00:38.920 --> 00:00:44.550
Jadi artinya ketika Anda membagi dua adalah untuk memiliki sisa 0 yang menunjukkan itu genap.

10
00:00:44.890 --> 00:00:49.850
Dan hal yang sama untuk B B MA 2 sama dengan nol.

11
00:00:50.900 --> 00:00:52.990
Jadi kalau pernyataan ini kebetulan benar.

12
00:00:53.000 --> 00:00:56.290
Jadi jika kondisi ini benar itu berarti kita memiliki keduanya angka atau genap.

13
00:00:56.510 --> 00:01:00.850
Jadi saya akan mengatakan di sini kedua angka tersebut genap.

14
00:01:00.950 --> 00:01:06.230
Dan dalam hal ini ketika kedua angka bahkan kita ingin mengembalikan yang lebih rendah dari dua angka.

15
00:01:06.230 --> 00:01:07.880
Jadi kita akan mengatakan yang berikut.

16
00:01:07.970 --> 00:01:13.010
Kita akan mengatakan jika 2 sama dengan nol dan B 2 sama dengan nol.

17
00:01:13.190 --> 00:01:14.680
Mari kita periksa angka yang lebih besar.

18
00:01:14.870 --> 00:01:28.410
Jika A kurang dari B kita akan mengatakan hasilnya sama dengan A lain.

19
00:01:28.400 --> 00:01:35.310
Hasil sama dengan dan menawarkan ini yang akan kita lakukan adalah katakan.

20
00:01:35.310 --> 00:01:36.810
Lain.

21
00:01:36.830 --> 00:01:43.110
Jadi sekarang satu atau kedua angka itu ganjil.

22
00:01:44.720 --> 00:01:46.200
Dan dalam hal ini kami ingin mengembalikan yang lebih besar.

23
00:01:46.200 --> 00:01:47.850
Jadi kami melakukan yang sebaliknya di sini.

24
00:01:47.900 --> 00:01:59.370
Jika A lebih besar dari B katakan hasilnya adalah yang lain hasilnya.

25
00:01:59.600 --> 00:02:04.600
Dan kemudian pada akhirnya di sini kita dapat mengembalikan hasilnya.

26
00:02:04.610 --> 00:02:07.080
Perhatikan lekukan di sini.

27
00:02:07.090 --> 00:02:12.670
Baiklah jadi ini adalah salah satu cara untuk menyelesaikan masalah ini hanya dengan menggunakan banyak pernyataan IF dan L jadi mari

28
00:02:12.670 --> 00:02:15.610
kita jalankan ini dan konfirmasikan bahwa itu benar-benar bekerja untuk kita.

29
00:02:15.610 --> 00:02:16.960
Jadi lebih sedikit dari dua kejahatan.

30
00:02:17.140 --> 00:02:18.600
Sepertinya itu kembali ke sini.

31
00:02:18.640 --> 00:02:21.820
Kurang dari dua kejahatan jika salah satu dari mereka memiliki angka ganjil itu mengembalikan lima.

32
00:02:21.910 --> 00:02:25.930
Mari kita buat mereka berdua hanya untuk check in pengembalian 7.

33
00:02:25.930 --> 00:02:26.510
Besar.

34
00:02:26.530 --> 00:02:29.350
Jadi ini adalah solusi yang layak untuk masalah ini.

35
00:02:29.380 --> 00:02:32.330
Namun kami sebenarnya dapat membersihkan kode ini lebih banyak.

36
00:02:32.350 --> 00:02:38.720
Sebenarnya ada cara kita dapat menjalankan potongan kode ini secara otomatis dan itu menggunakan fungsi min.

37
00:02:38.740 --> 00:02:43.840
Sebelumnya kami melihat bagaimana fungsi min sebenarnya dapat mengembalikan nilai minimum daftar.

38
00:02:44.050 --> 00:02:49.270
Tetapi jika kita melihat apa yang terjadi dengan fungsi minimum ketika kita meneruskan ke

39
00:02:49.270 --> 00:02:54.710
angka-angka seperti 10 dan 20 itu benar-benar mengembalikan kembali minimum dua angka yang Anda bandingkan.

40
00:02:55.080 --> 00:02:59.180
Dan itu berfungsi hanya dengan dua angka jika Anda menginginkan lebih dari itu, Anda harus menyampaikan daftar.

41
00:02:59.640 --> 00:03:01.850
Tetapi ini juga berfungsi sama dengan fungsi Max.

42
00:03:02.090 --> 00:03:07.830
Jadi mengembalikan max 20 di sini ketika Anda lulus dan dua angka yang harus saya lakukan

43
00:03:07.830 --> 00:03:09.000
adalah sebagai berikut.

44
00:03:09.030 --> 00:03:18.540
Saya dapat mengatakan hasil di sini sama dengan maks suatu kombi dan kemudian saya dapat mengatakan di sini

45
00:03:18.550 --> 00:03:21.490
hasilnya sama dengan min AB.

46
00:03:21.640 --> 00:03:24.160
Jadi kita bisa membersihkan ini lebih jauh.

47
00:03:24.280 --> 00:03:27.600
Dan jika saya menjalankan ini, mari kita periksa untuk memastikan kami mendapatkan hasil yang sama di sini.

48
00:03:27.850 --> 00:03:31.210
Jadi saya kembali dan mereka kembali 7 ketika saya jalankan kembali sel-sel itu.

49
00:03:31.210 --> 00:03:32.220
Sempurna.

50
00:03:32.260 --> 00:03:34.680
Dan sebenarnya kita bisa melangkah lebih jauh.

51
00:03:34.750 --> 00:03:39.910
Kami benar-benar dapat memiliki beberapa pernyataan pengembalian di dalam sini karena sekali Anda mengatakan

52
00:03:39.970 --> 00:03:42.340
kembali dan dieksekusi fungsi akan berhenti.

53
00:03:42.340 --> 00:03:47.140
Jadi alih-alih menyimpan hasil ini dan kemudian menunggu sampai akhir untuk

54
00:03:47.140 --> 00:03:57.580
mengembalikan hasil Anda yang bisa kami lakukan adalah katakan saja kembalikan pria B di sini dan kemudian katakan kembalikan Max AB di sini dan hapus yang terakhir.

55
00:03:57.940 --> 00:04:01.440
Jadi apa yang akan terjadi di sini adalah fungsi Anda akan berjalan.

56
00:04:01.570 --> 00:04:06.540
Dan dikatakan hei jika kedua angka bahkan maju dan langsung saja mengembalikan nilai

57
00:04:06.550 --> 00:04:12.180
minimum antara a dan b yang lain maka langsung mengembalikan nilai maksimum a dan b.

58
00:04:12.430 --> 00:04:15.350
Dan ini mungkin cara paling efisien untuk melakukan masalah ini.

59
00:04:15.370 --> 00:04:21.520
Kita bisa membuatnya sedikit lebih ramping mungkin mencoba untuk menempatkan semuanya dalam satu baris tetapi ini di sini adalah solusi yang lebih

60
00:04:21.520 --> 00:04:24.180
baik daripada apa yang kita lihat di jalankan pertama.

61
00:04:24.310 --> 00:04:26.460
Dan ini yang akan Anda lihat di notebook.

62
00:04:26.920 --> 00:04:30.940
Baiklah pertanyaan berikutnya di bagian pemanasan adalah pertanyaan yang disebut Animal Crackers

63
00:04:30.940 --> 00:04:37.330
di mana Anda ingin menulis fungsi yang mengambil string dua kata dan kemudian mengembalikan true jika kedua kata dimulai dengan

64
00:04:37.330 --> 00:04:38.590
huruf yang sama.

65
00:04:38.590 --> 00:04:41.450
Jadi di sini saya bisa melihat level berkepala dingin dan llama keduanya dimulai dengan L.

66
00:04:41.500 --> 00:04:46.790
Jadi kita mengembalikan TRUE kanguru gila dimulai dengan huruf yang berbeda sehingga kita mengembalikan false.

67
00:04:46.840 --> 00:04:48.390
Jadi mari kita buat ini.

68
00:04:48.800 --> 00:04:53.290
Kita akan melakukan hal yang sama seperti terakhir kali kita akan membangun semua logikanya dan kemudian

69
00:04:53.620 --> 00:04:57.300
melihat apakah kita dapat membuatnya sedikit lebih ramping dengan menggunakan beberapa kata kunci.

70
00:04:57.310 --> 00:05:04.030
Jadi, hal pertama yang ingin saya lakukan adalah benar-benar mengambil dua kata sehingga saya dapat membuat variabel bernama wordlist dan mengatur

71
00:05:05.200 --> 00:05:10.500
sama dengan string yang masuk dan untuk mengambil dua kata yang bisa saya gunakan split

72
00:05:10.510 --> 00:05:13.380
Dan sekarang saya harus memiliki daftar dua kata yang sebenarnya.

73
00:05:13.390 --> 00:05:17.280
Jadi mari kita cetak daftar kata sehingga kita dapat mengkonfirmasi ini.

74
00:05:17.290 --> 00:05:22.060
Jadi jika saya menjalankan ini sekarang saya melihat bahwa saya mendapatkan kembali daftar dua kata dan

75
00:05:22.530 --> 00:05:27.770
apa yang ingin saya lakukan adalah memeriksa karakter pertama dan kata ini cocok dengan karakter pertama dalam kata ini.

76
00:05:27.880 --> 00:05:32.540
Jadi saya bisa mengatakan bahwa kata pertama saya sama dengan daftar kata di nol.

77
00:05:33.280 --> 00:05:36.220
Dan kata kedua saya sama dengan daftar kata.

78
00:05:36.250 --> 00:05:37.680
Selanjutnya.

79
00:05:37.900 --> 00:05:42.750
Dan kemudian saya ingin kembali adalah nol pertama.

80
00:05:43.000 --> 00:05:49.420
Artinya adalah huruf pertama dari kata pertama sama dengan 0 kedua.

81
00:05:49.420 --> 00:05:53.460
Begitu juga huruf pertama ini sama dengan huruf pertama kedua.

82
00:05:53.470 --> 00:05:59.650
Jadi sekarang kita jalankan ini, saya kembali benar dan saya kembali salah di sini dan kita bisa

83
00:05:59.650 --> 00:06:03.720
mengambil pernyataan cetak ini sekarang untuk melihat hanya hasil boolean.

84
00:06:03.730 --> 00:06:06.060
Sekarang kita benar-benar dapat mengedit ini sedikit.

85
00:06:06.100 --> 00:06:13.240
Sebenarnya perhatikan di sini bagaimana saya pada dasarnya membuat dua panggilan indeks nol dan satu lagi nol di sini dan satu

86
00:06:13.240 --> 00:06:14.980
lagi nol di sini.

87
00:06:14.980 --> 00:06:20.770
Jadi apa yang bisa dilakukannya bahkan tidak repot dengan tugas ini dan hanya mengambil pesanan sendiri dan menggantinya

88
00:06:20.770 --> 00:06:22.130
terlebih dahulu di sini.

89
00:06:23.250 --> 00:06:26.940
Dan kemudian saya bisa mengambil daftar kata satu di sini dan menggantinya sebentar di sana.

90
00:06:28.760 --> 00:06:33.730
Dan sekarang ini adalah hal yang persis sama kecuali sekarang menggunakan panggilan indeks ganda.

91
00:06:33.730 --> 00:06:36.760
Jadi ketika saya menjalankan ini lagi saya mendapatkan hasil yang sama.

92
00:06:36.910 --> 00:06:42.630
Sesuatu yang perlu diperhatikan di sini yang tidak saya periksa sebenarnya adalah berjaga-jaga jika kedua surat ini.

93
00:06:42.820 --> 00:06:46.840
Saat ini keduanya dikapitalisasi dan kami menganggap keduanya dikapitalisasi tetapi mungkin salah satunya adalah huruf kecil dan saya akan

94
00:06:46.930 --> 00:06:48.980
menunjukkan kepada Anda apa yang saya maksud dengan itu.

95
00:06:49.150 --> 00:06:53.980
Mari kita bayangkan kita memiliki kucing gila dengan huruf kecil untuk melihat apakah saya menjalankan ini.

96
00:06:53.980 --> 00:06:55.370
Ini akan kembali salah.

97
00:06:55.390 --> 00:06:58.100
Meskipun kita mulai dengan huruf yang sama.

98
00:06:58.240 --> 00:07:02.720
Dalam hal itu yang bisa dilakukan adalah huruf kecil kata-kata saya membagi huruf kecil teks saya.

99
00:07:02.740 --> 00:07:11.290
Maafkan saya sebelum perpecahan sehingga saya bisa mengatakan teks yang lebih rendah dan kemudian setelah panggilan panggil kedua untuk melakukan itu

100
00:07:11.290 --> 00:07:12.610
di baris baru.

101
00:07:12.690 --> 00:07:17.150
Tapi Python sebenarnya memungkinkan Anda untuk jenis ini pada satu setelah yang lain.

102
00:07:17.190 --> 00:07:21.670
Jadi saya akan melakukan yang lebih rendah dan kemudian melakukan split pada Snell's run ini lagi.

103
00:07:22.200 --> 00:07:27.210
Dan sekarang Anda dapat melihat bahwa itu mengkonfirmasi benar karena itu membuat semuanya huruf kecil sebelum benar-benar

104
00:07:27.210 --> 00:07:31.190
melakukan pemisahan dan kita dapat melihat itu dengan mencetak daftar kata itu.

105
00:07:31.290 --> 00:07:36.750
Dan jika saya menjalankan ini lagi pada kucing gila saya perhatikan di sini gila sekarang menjadi huruf kecil

106
00:07:36.750 --> 00:07:43.450
dan semuanya akan bekerja dengan cara yang sama seperti yang kita gunakan atas karena kemudian itu hanya akan huruf besar kucing di sana.

107
00:07:43.750 --> 00:07:47.170
Jadi pasti sudah dikonfirmasi modal C modal C ..

108
00:07:47.230 --> 00:07:50.280
Baiklah jadi itulah dasar dari masalah kerupuk hewan.

109
00:07:50.320 --> 00:07:50.680
Baiklah.

110
00:07:50.710 --> 00:07:55.190
Masalah pemanasan terakhir kami sedikit lebih berbasis matematika dan itu disebut make 20.

111
00:07:55.330 --> 00:08:01.030
Dan kami ingin tahu bahwa diberikan dua bilangan bulat mengembalikan true jika jumlah bilangan bulat adalah 20

112
00:08:01.250 --> 00:08:04.260
Atau jika salah satu dari bilangan bulat itu sendiri adalah 20.

113
00:08:04.330 --> 00:08:05.320
Jika tidak ada yang benar.

114
00:08:05.320 --> 00:08:07.210
Silakan dan kembalikan salah.

115
00:08:07.240 --> 00:08:09.930
Jadi mari kita periksa tiga kasus ini.

116
00:08:10.760 --> 00:08:12.810
Pertama kita perlu memeriksa jumlah 20.

117
00:08:13.140 --> 00:08:24.640
Jadi, Anda dapat mengatakan jika dan 1 plus dan 2 sama dengan 20 return true dan kemudian kita dapat meninggikan case untuk yang lain

118
00:08:24.640 --> 00:08:31.130
kita dapat mengatakan baik jika dan satu sama dengan 20 return true.

119
00:08:32.620 --> 00:08:41.310
Elif dan 2 fisik hingga 20 mengembalikan true dan jika tidak ada yang benar maka Anda bisa

120
00:08:41.910 --> 00:08:43.000
mengembalikan false.

121
00:08:43.020 --> 00:08:46.080
Jadi ketika saya menjalankan kode ini dan saya memeriksanya sepertinya berfungsi.

122
00:08:46.080 --> 00:08:47.340
Jadi dua atau tiga itu salah.

123
00:08:47.370 --> 00:08:49.050
20 dalam 10 benar.

124
00:08:49.050 --> 00:08:53.390
Dan jika Anda melakukan satu yang berjumlah 20 10 dan 10 itu juga mengembalikan true.

125
00:08:53.630 --> 00:08:59.610
Tetapi seperti yang disebutkan sebelumnya sepanjang kursus jika Anda sudah memeriksa jika beberapa pernyataan boolean mengembalikan boolean

126
00:08:59.700 --> 00:09:05.340
yang sebenarnya maka apa yang bisa kita lakukan adalah meletakkan semua ini pada satu baris.

127
00:09:05.790 --> 00:09:07.260
Jadi bagaimana sebenarnya kita melakukannya.

128
00:09:07.260 --> 00:09:09.560
Yah tidak, ini hanya sekelompok cek boolean di sini.

129
00:09:09.750 --> 00:09:14.600
Jadi kita dapat menggunakan operator perbandingan ini bersama dengan operator logis seperti atau.

130
00:09:14.760 --> 00:09:28.610
Jadi yang sebenarnya perlu kita lakukan dalam satu baris adalah katakan return dan 1 plus dan 2 sama dengan 20 atau dan satu sama

131
00:09:28.610 --> 00:09:33.310
dengan 20 atau ke sama dengan 20.

132
00:09:33.320 --> 00:09:37.270
Jadi mari kita lihat bagaimana hal ini sama persis dengan semua kode yang baru saja kita tulis di sini.

133
00:09:37.490 --> 00:09:42.890
Kami mengatakan bahwa kondisi bullying ini benar atau yang ini benar atau yang ini

134
00:09:42.890 --> 00:09:43.710
benar.

135
00:09:43.790 --> 00:09:46.750
Jika tidak ada yang benar maka kita akan kembali salah.

136
00:09:46.760 --> 00:09:50.960
Jadi satu baris kode ini melakukan hal yang sama dengan semua ini.

137
00:09:51.200 --> 00:09:56.210
Dan kita dapat memeriksanya dengan menjalankan ini dan kita mendapatkan kembali hasil yang sama persis.

138
00:09:56.210 --> 00:09:58.400
Baiklah itu untuk masalah pemanasan.

139
00:09:58.460 --> 00:10:01.720
Selanjutnya, kita akan membahas masalah level satu.

140
00:10:01.730 --> 00:10:02.390
Kami akan melihat apakah mereka.
