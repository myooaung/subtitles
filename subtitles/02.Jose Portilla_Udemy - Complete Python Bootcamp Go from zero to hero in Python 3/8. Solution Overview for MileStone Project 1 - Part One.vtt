WEBVTT
1
00:00:05.340 --> 00:00:07.140
Selamat datang kembali semua orang di kuliah ini.

2
00:00:07.140 --> 00:00:11.550
Kita akan secara formal membahas solusi untuk Workbook untuk proyek Milestone yang merupakan game

3
00:00:11.550 --> 00:00:12.650
tic tac toe.

4
00:00:12.960 --> 00:00:15.020
Mari kita buka buku catatan dan memulai.

5
00:00:15.050 --> 00:00:15.350
Kanan.

6
00:00:15.360 --> 00:00:18.790
Di sini kita berada di proyek Milestone satu berjalan melalui langkah-langkah buku kerja.

7
00:00:18.840 --> 00:00:22.770
Mari kita mulai dengan langkah pertama yaitu membuat fungsi yang dapat mencetak papan.

8
00:00:22.770 --> 00:00:25.530
Dan ada banyak cara berbeda Anda bisa mencetak papan atau

9
00:00:25.530 --> 00:00:29.520
Anda bisa pergi jika papan benar-benar mewah atau yang benar-benar sederhana yang hanya menampilkan daftar.

10
00:00:29.520 --> 00:00:32.660
Tapi ingat kami berharap papan menjadi daftar.

11
00:00:32.670 --> 00:00:37.470
Jadi beberapa hal pertama yang akan kita butuhkan sebenarnya adalah mencetak posisi indeks dari daftar

12
00:00:37.470 --> 00:00:38.070
itu.

13
00:00:38.070 --> 00:00:46.440
Jadi akan lebih baik jika kita melakukan sesuatu seperti papan satu plus dan kemudian semacam indikator bahwa kita memiliki kolom

14
00:00:46.530 --> 00:00:55.900
baru di sana sehingga kita bisa melakukan itu dan kemudian kita akan melakukan naik itu ditambah dua dan kemudian operator pipa lain

15
00:00:57.600 --> 00:01:02.220
dan akhirnya naik tiga dan kemudian saya akan menyalin dan menempel

16
00:01:05.560 --> 00:01:08.710
ini dan pengetahuan mengubah posisi indeks.

17
00:01:08.710 --> 00:01:14.140
Jadi 7 8 dan 9 di atas dan terserah Anda jika Anda ingin membalikkan itu.

18
00:01:14.200 --> 00:01:19.860
Tapi empat lima enam akan selalu di tengah sana dan mari kita periksa dengan ini sepertinya jika kita

19
00:01:19.860 --> 00:01:20.640
menampilkan papan.

20
00:01:20.880 --> 00:01:22.690
Jadi kita jalankan ini.

21
00:01:23.100 --> 00:01:23.910
Kami menampilkan papan.

22
00:01:23.940 --> 00:01:25.740
Dan sekarang papan tes saya kosong.

23
00:01:25.740 --> 00:01:32.150
Jadi izinkan saya menyalin papan tes dari buku kerja asli dan saya ingin menjalankan ini saya mendapatkan kembali papan saya.

24
00:01:32.160 --> 00:01:35.740
Jadi ini adalah versi papan yang sangat sederhana tetapi berfungsi dengan baik.

25
00:01:35.760 --> 00:01:39.540
Sekarang sesuatu yang perlu diperhatikan di sini adalah jika saya menjalankan papan display beberapa kali.

26
00:01:39.540 --> 00:01:41.750
Jadi izinkan saya menyebutnya dua kali di sini.

27
00:01:41.850 --> 00:01:45.890
Apa yang akan terjadi sebenarnya adalah melihat sejarah semua papan di sini.

28
00:01:46.230 --> 00:01:51.180
Jadi untuk menghindari apa yang bisa kita lakukan adalah memanggil output yang jelas terlebih dahulu.

29
00:01:51.240 --> 00:01:55.590
Jadi jika saya memanggil output jelas dan sebagai alternatif jika Anda menjalankan itu adalah baris perintah Anda

30
00:01:55.590 --> 00:02:01.170
dapat menggunakan pernyataan cetak ini yang kita bicarakan jika sekarang saya memiliki output jelas apa yang akan terjadi adalah saya hanya

31
00:02:01.230 --> 00:02:02.580
melihat satu versi board.

32
00:02:02.670 --> 00:02:06.610
Jadi ini akan menampilkan papan dan waktu berikutnya papan ditampilkan.

33
00:02:06.630 --> 00:02:09.990
Jadi lain kali Anda memanggil papan permainan ini akan menghapus output untuk Anda.

34
00:02:10.350 --> 00:02:14.590
Jadi ini adalah versi yang sangat sederhana untuk mencetak papan dan kita dapat menyimpannya untuk saat ini.

35
00:02:14.940 --> 00:02:21.000
Tetapi pada salinan luka dan tempel buku kerja solusi yang pada dasarnya ide yang sama.

36
00:02:21.060 --> 00:02:24.120
Hanya memiliki sedikit format yang lebih ramping di sini.

37
00:02:24.120 --> 00:02:28.260
Jadi jika saya menjalankan ini saya mendapatkan kembali jenis papan yang lebih luas untuk dilihat.

38
00:02:28.260 --> 00:02:29.830
Terserah Anda apa yang ingin Anda lakukan di sini.

39
00:02:29.850 --> 00:02:30.930
Banyak pilihan berbeda.

40
00:02:30.930 --> 00:02:36.070
Gagasan utama adalah untuk dapat mengindeks papan dan kemudian dicetak.

41
00:02:36.190 --> 00:02:41.830
Langkah kedua adalah menulis fungsi yang dapat mengambil input pemain dan menetapkan penanda mereka sebagai X atau O.

42
00:02:42.010 --> 00:02:43.870
Lagi-lagi banyak cara berbeda yang bisa kita lakukan ini.

43
00:02:43.910 --> 00:02:48.560
Itu sesuatu yang pasti ingin kami lakukan adalah menggunakan loop sementara di mana kami dapat terus bertanya.

44
00:02:48.610 --> 00:02:50.830
Jadi, Anda mendapatkan jawaban yang benar.

45
00:02:50.830 --> 00:02:58.570
Jadi saya akan menetapkan marker sebagai string kosong pada dasarnya apapun yang bukan X atau lebih dan

46
00:02:58.660 --> 00:03:08.100
saya bisa melakukan ini dengan dua cara saya bisa melihatnya sementara marker tidak sama dengan x dan marker tidak sama dengan 0.

47
00:03:08.540 --> 00:03:21.680
Jadi saya bisa melakukannya dengan cara ini dan kemudian mengatakan marker sama dengan input player 1 pilih X atau 0.

48
00:03:23.690 --> 00:03:29.120
Dan yang bisa saya lakukan adalah huruf besar ini jika Anda tidak sengaja memasukkan huruf kecil X atau huruf kecil begitu.

49
00:03:29.210 --> 00:03:31.820
Dan akhirnya saya akan mengembalikan semacam tugas tuple.

50
00:03:32.180 --> 00:03:41.800
Jadi saya akan mengatakan jika marker sama dengan x return x koma.

51
00:03:42.210 --> 00:03:44.770
Jadi format di sini saya bisa menulis sendiri sedikit tidak.

52
00:03:44.840 --> 00:03:53.250
Sebenarnya ini akan menjadi kasus yang baik untuk docstring adalah dengan

53
00:03:53.970 --> 00:04:03.440
mengatakan bahwa output dalam bentuk tuple dengan penanda pemain koma pemain dua penanda.

54
00:04:03.460 --> 00:04:08.130
Jadi ketika pemain cek memasukkan docstring berkata Katakan padaku seperti apa output yang sebenarnya.

55
00:04:08.350 --> 00:04:12.780
Jadi, Anda dapat melihat kuliah sebelumnya untuk versi yang lebih terperinci ini.

56
00:04:12.790 --> 00:04:15.580
Ini semacam versi yang lebih bersih dan kami akan mengatakannya.

57
00:04:15.580 --> 00:04:17.130
Kembali lagi.

58
00:04:18.410 --> 00:04:22.050
Oh dan X dan ini memungkinkan kita menggunakan tuple dan packing.

59
00:04:22.050 --> 00:04:26.970
Jadi jika saya menjalankan ini maka saya dapat menggunakan tuple dalam mengemas sesuatu seperti ini untuk mendapatkan kembali

60
00:04:26.970 --> 00:04:28.350
pemain 1 dan pemain 2.

61
00:04:28.350 --> 00:04:33.750
Jadi saya menjalankan input jika saya melewati X enter dan saya mengambil pemain saya untuk menandai itu akan menjadi kebalikan dari X

62
00:04:33.750 --> 00:04:34.490
yang mana.

63
00:04:34.490 --> 00:04:38.180
Oh dan jika saya memeriksa pemain saya satu penanda itu akan menjadi X ..

64
00:04:38.190 --> 00:04:39.830
Jadi cara yang berbeda Anda bisa melakukan ini.

65
00:04:39.840 --> 00:04:44.400
Hal lain yang ingin saya sebutkan adalah alih-alih

66
00:04:44.400 --> 00:04:56.140
melakukannya dengan tidak sama dengan dan tidak sama dengan Anda bisa mengatakan sementara tidak penanda sama dengan x atau penanda sama dengan nol.

67
00:04:57.770 --> 00:05:03.340
Jadi sementara bukan kasus ini atau kasus ini ada dua cara berbeda untuk memikirkannya secara logis.

68
00:05:03.410 --> 00:05:08.320
Ini terserah Anda yang lebih suka hidup pada dua langkah tiga.

69
00:05:08.500 --> 00:05:14.830
Kami ingin menulis fungsi yang membawa objek daftar papan marker X atau 0 0 ke posisi nomor 1 hingga 9

70
00:05:14.890 --> 00:05:17.220
dan kemudian menugaskannya ke papan tulis.

71
00:05:17.440 --> 00:05:28.530
Jadi yang bisa kita lakukan di sini adalah tempat penanda posisi papan penanda dan saya akan mengatakan papan

72
00:05:28.530 --> 00:05:32.310
pada posisi itu sama dengan penanda.

73
00:05:32.350 --> 00:05:35.530
Jadi mari kita jalankan tes untuk memastikan ini benar-benar berfungsi.

74
00:05:35.660 --> 00:05:39.120
Yang akan kita lakukan adalah mengatakan penanda tempat yang saya miliki sekarang sebagai papan tes.

75
00:05:39.310 --> 00:05:44.230
Jadi jika saya melihat pada papan tes saya sepertinya itu dari atas di mana saya memiliki tag hash

76
00:05:44.380 --> 00:05:47.240
pertama untuk jenis memblokir nol dan X dan O.

77
00:05:47.380 --> 00:05:49.690
Saya akan mengatakan memasukkan sesuatu yang baru di sana.

78
00:05:49.690 --> 00:05:53.340
Jadi mari kita membuatnya menjadi tanda dolar yang sangat jelas dan kemudian menempatkannya di posisi 8.

79
00:05:53.510 --> 00:05:57.290
Maka akan menempatkan spidol dan kemudian menampilkan papan tes di sini.

80
00:05:57.310 --> 00:06:02.650
Jadi mari kita jalankan itu dan kita dapat melihat bahwa itu dicurigai berhasil memasukkan tanda dolar

81
00:06:02.650 --> 00:06:04.570
di posisi yang kita inginkan.

82
00:06:04.660 --> 00:06:05.920
Dan itu hanya sederhana.

83
00:06:05.980 --> 00:06:13.110
Pada dasarnya pada saat itu posisi papan ditempatkan penanda ada OK langkah empat adalah untuk menulis fungsi yang mengambil dan bahwa

84
00:06:13.110 --> 00:06:19.440
daftar papan dan beberapa penanda seperti X atau 0 dan memeriksa untuk melihat apakah penanda itu telah menang.

85
00:06:19.440 --> 00:06:22.540
Jadi kita harus bertanya pada diri sendiri apa artinya menang.

86
00:06:22.830 --> 00:06:30.000
Tic tac toe Yah itu berarti bahwa kita perlu memeriksa kemungkinan kombinasi sehingga kita tahu

87
00:06:30.020 --> 00:06:32.280
bahwa akan ada tiga.

88
00:06:32.480 --> 00:06:43.420
Jadi kita perlu memeriksa semua baris dan memeriksa untuk melihat apakah mereka semua berbagi penanda yang sama sehingga jika mereka semua berbagi Xs yang sama atau

89
00:06:43.420 --> 00:06:45.190
mereka semua berbagi sama.

90
00:06:45.190 --> 00:06:47.690
Keduanya perlu melakukan itu untuk semua baris.

91
00:06:47.740 --> 00:06:49.800
Kemudian ketika dibutuhkan untuk itu untuk semua kolom.

92
00:06:49.870 --> 00:06:52.870
Jadi itu akan menjadi tiga kolom di sana.

93
00:06:53.100 --> 00:06:56.790
Periksa untuk melihat apakah marker cocok.

94
00:06:56.790 --> 00:06:59.540
Dan akhirnya kami memiliki dua diagonal untuk diperiksa.

95
00:07:00.710 --> 00:07:01.550
Diagonal dan

96
00:07:04.220 --> 00:07:06.000
periksa untuk melihat apakah kita

97
00:07:09.220 --> 00:07:14.940
memiliki matrikular sekarang kita dapat menggunakan pengindeksan untuk mengambil contoh baris contoh kolom dalam contoh diagonal.

98
00:07:15.040 --> 00:07:19.270
Saya akan menunjukkan kepada Anda berbagai cara untuk melakukan ini dan kemudian kami akan menyalin dan

99
00:07:19.270 --> 00:07:21.300
menempel dari solusi karena itu banyak pemeriksaan.

100
00:07:21.340 --> 00:07:26.860
Jadi salah satu cara kami dapat memeriksa semua yang cocok pada semua baris adalah cara kami menunjukkan

101
00:07:26.860 --> 00:07:30.570
Anda di notebook solusi yang bisa dikatakan bosan dengan baris bawah.

102
00:07:30.670 --> 00:07:40.900
Jadi kita membutuhkan papan periksa yang sama dengan tanda dan papan untuk memastikan saya memeriksa papan

103
00:07:42.170 --> 00:07:50.330
yang tepat sama dengan tanda dan papan untuk tiga sama dengan tanda.

104
00:07:50.340 --> 00:07:57.740
Jadi apa yang dilakukan adalah terus maju dan memeriksa apakah posisi di papan 1 sama dengan penanda adalah posisi naik atau sama dengan penanda itu,

105
00:07:58.020 --> 00:08:01.620
di mana penanda itu mengatakan bahwa Anda melewati mereka akan menjadi X

106
00:08:01.620 --> 00:08:02.540
atau O.

107
00:08:02.670 --> 00:08:05.700
Jadi, jika dilewati maka x Jangan katakan pada posisi ini adalah X.

108
00:08:05.910 --> 00:08:07.700
Dan pada posisi ini x.

109
00:08:07.710 --> 00:08:09.150
Dan pada posisi ini x.

110
00:08:09.300 --> 00:08:12.380
Jika kasus ini benar, maka kita tahu seseorang telah menang.

111
00:08:12.390 --> 00:08:15.160
Apa pun tanda ini yang dimenangkan.

112
00:08:15.270 --> 00:08:21.480
Dan dalam hal ini kami hanya akan mengembalikan semacam bullying bahwa mereka telah memenangkan permainan

113
00:08:21.480 --> 00:08:28.770
dan kemudian yang bisa kita lakukan adalah membungkus ini di pangeran di sini dan kemudian memiliki pernyataan ATAU kemudian

114
00:08:28.770 --> 00:08:36.860
memeriksa baris berikutnya sehingga kita bisa katakanlah papan empat sama dengan Markus dan seterusnya dan seterusnya lima enam berikutnya akan menjadi

115
00:08:36.860 --> 00:08:38.160
tujuh delapan sembilan.

116
00:08:38.400 --> 00:08:45.690
Dan kemudian kita bisa melakukan hal yang sama untuk kolom dan kolom akan seperti 7 4 1 8 5 2 9 6 3.

117
00:08:45.750 --> 00:08:51.870
Dan kemudian kita memiliki dua hewan yang akan menjadi angka 7 5 3 dan 9 5 1.

118
00:08:51.900 --> 00:08:56.160
Sekarang inilah cara kami melakukannya dalam solusi notebook karena sedikit lebih jelas apa yang terjadi

119
00:08:56.160 --> 00:08:56.790
di sini.

120
00:08:56.880 --> 00:09:02.430
Tetapi sebagai alternatif daripada menggunakan ini dan operator bersama dengan tanda

121
00:09:02.430 --> 00:09:12.360
centang untuk setiap posisi indeks individu yang juga bisa Anda lakukan adalah hanya memeriksa bahwa dewan empat sama dengan empat

122
00:09:12.360 --> 00:09:16.070
hingga lima sama dengan papan di enam.

123
00:09:16.120 --> 00:09:18.990
Dan akhirnya periksa apakah ini sama dengan tanda.

124
00:09:19.000 --> 00:09:24.610
Alasan Anda tidak bisa begitu saja melakukan pengecekan terhadap tanda adalah karena jika papan mulai kosong

125
00:09:24.670 --> 00:09:26.110
maka akan dilaporkan kembali.

126
00:09:26.170 --> 00:09:29.110
Hei, tiga posisi kosong ini cocok dan seseorang sudah menang.

127
00:09:29.290 --> 00:09:32.310
Jadi, Anda harus memeriksanya dengan Tanda akhirnya.

128
00:09:32.320 --> 00:09:35.650
Jadi ini di sini adalah logika yang sama dengan apa yang kita lihat di sini.

129
00:09:35.650 --> 00:09:38.190
Hanya saja mungkin sedikit lebih ramping lebih bersih.

130
00:09:38.200 --> 00:09:38.810
Tergantung.

131
00:09:38.810 --> 00:09:40.200
Bagi Anda apa yang lebih mudah dibaca.

132
00:09:40.450 --> 00:09:45.910
Tapi saya akan menyalin dan menempel ini dari buku solusi karena ini banyak pemeriksaan dan jika Anda ingin sedikit

133
00:09:45.910 --> 00:09:50.410
pintar, Anda bisa membuat sedikit untuk loop untuk baris sedikit untuk itu untuk kolom dan

134
00:09:50.620 --> 00:09:52.580
kemudian secara manual benar di diagonal.

135
00:09:52.690 --> 00:09:55.230
Tetapi saya salin dan tempel solusinya.

136
00:09:55.240 --> 00:09:56.580
Dan secara singkat membahasnya.

137
00:09:56.590 --> 00:10:01.300
Pada dasarnya apa yang kita lakukan di sini adalah kita melakukan hal pertama yang saya

138
00:10:01.450 --> 00:10:07.090
katakan kita memeriksa di bagian atas di tengah di bagian bawah di tengah dan kemudian ke bawah kolom lain

139
00:10:07.090 --> 00:10:08.560
dan kemudian kedua diagonal.

140
00:10:08.590 --> 00:10:08.960
Baiklah.

141
00:10:08.980 --> 00:10:13.330
Dan apa yang kami lakukan di sini adalah bahwa kami memiliki pernyataan ATAU untuk masing-masing

142
00:10:13.420 --> 00:10:18.120
cek yang mungkin dan kemudian setelah semua ini kami akan mengembalikan boolean dalam kitting benar atau salah.

143
00:10:18.120 --> 00:10:20.500
Apakah seseorang menang.

144
00:10:20.630 --> 00:10:21.960
Jadi kita bisa mendapatkan win win di sini.

145
00:10:21.980 --> 00:10:28.270
Mari kita tentukan win tic tac toe ini sebagai pemeriksaan akhir dan sepertinya seseorang memang memenangkan tic tac toe.

146
00:10:28.580 --> 00:10:34.590
Jadi mari kita dapat benar-benar menampilkan papan sehingga kita dapat melihat papan tes papan display.

147
00:10:34.640 --> 00:10:39.680
Jadi jika kita melihat ini pasti X memiliki satu di kedua mode di sini dan itu mengembalikan benar bahwa orang ini

148
00:10:39.680 --> 00:10:40.290
telah menang.

149
00:10:40.430 --> 00:10:41.140
Besar.

150
00:10:41.570 --> 00:10:42.370
Jadi terserah 5.

151
00:10:42.380 --> 00:10:47.400
Kami ingin menulis fungsi yang menggunakan modul ran untuk memutuskan secara acak pemain mana yang lebih dulu.

152
00:10:47.480 --> 00:10:51.870
Dan seperti yang kami sebutkan Anda mungkin ingin mencari kata-kata kasar acak dan kami berbicara sedikit tentang hal itu.

153
00:10:51.880 --> 00:10:54.680
Operator yang berguna memberi kuliah tetapi mari kita melihat lebih dekat.

154
00:10:54.680 --> 00:11:01.880
Sekarang salah satu cara kita dapat menggunakan titik acak berlari ke adalah hanya pasand 0 dan 1 dan memperlakukannya sebagai apa yang pada dasarnya

155
00:11:01.880 --> 00:11:03.120
adalah koin flip.

156
00:11:03.320 --> 00:11:14.050
Jadi kita bisa mengatakan yang berikut ini kita akan memiliki nomor flip kita sama dengan Rand I. acak SEBUAH. nol umum 1.

157
00:11:14.060 --> 00:11:16.980
Jadi ini secara acak akan memilih 0 atau 1.

158
00:11:17.120 --> 00:11:25.440
Jadi kita bisa menganggap itu sebagai kepala atau ekor dan kemudian kita akan mengatakan jika flip sama dengan nol maka

159
00:11:25.770 --> 00:11:29.530
kita kembali katakanlah Player 1 seperti yang pertama.

160
00:11:29.530 --> 00:11:34.970
Kalau tidak, kita mengembalikan pemain string untuk pergi dulu.

161
00:11:35.020 --> 00:11:38.770
Dan ada banyak dan banyak cara berbeda yang bisa dilakukan ini tetapi ini adalah

162
00:11:38.770 --> 00:11:40.520
cara sederhana dengan kata-kata kasar acak.

163
00:11:40.570 --> 00:11:42.720
SAYA. SEBUAH. fungsi integer acak.

164
00:11:43.090 --> 00:11:44.150
Jadi mari kita jalankan itu.

165
00:11:44.530 --> 00:11:48.820
OK langkah nomor enam adalah menulis fungsi yang mengembalikan boolean yang menunjukkan di mana ada ruang

166
00:11:48.820 --> 00:11:50.370
dan papan tersedia secara bebas.

167
00:11:50.560 --> 00:11:55.180
Jadi itu akan mengambil papan yang memiliki daftar dan kemudian mengambil posisi di dalamnya ingin memeriksa apakah

168
00:11:55.270 --> 00:11:56.680
itu tersedia secara bebas.

169
00:11:56.830 --> 00:12:01.660
Dalam kasus kami tersedia secara bebas berarti bahwa posisi itu adalah string kosong.

170
00:12:01.750 --> 00:12:12.540
Jadi untuk melakukan itu apa yang akan saya katakan adalah mendapatkan papan pada posisi itu dan melihat apakah itu sama dengan string kosong dan karena

171
00:12:13.260 --> 00:12:17.830
itu sudah sendiri akan menjadi boolean kita hanya akan mengembalikannya

172
00:12:18.040 --> 00:12:22.370
Kemudian langkah tujuh adalah menulis fungsi yang memeriksa papan penuh dan mengembalikan nilai boolean.

173
00:12:22.470 --> 00:12:25.430
True Full false sebaliknya.

174
00:12:25.480 --> 00:12:34.740
Jadi untuk melakukan ini kita akan menjalankan loop for yang berlaku untuk saya di kisaran 1 hingga 10 karena ada sembilan ruang di Laborde

175
00:12:34.740 --> 00:12:38.440
mulai dari 1 dan kemudian hingga dan termasuk 10.

176
00:12:38.680 --> 00:12:44.950
Kita akan mengatakan jika dan kemudian kita dapat memanggil fungsi pemeriksaan ruang yang baru saja kita tentukan muncul.

177
00:12:45.320 --> 00:12:51.220
Jadi, jika ruang periksa menggunakan posisi papan itu.

178
00:12:51.260 --> 00:12:53.680
Jadi itu semua posisi yang memungkinkan di papan tulis.

179
00:12:53.750 --> 00:13:00.740
Jika ruang periksa kembali benar maka saya akan menjadi semacam negatif ganda di sini tapi kami akan mengembalikan

180
00:13:00.740 --> 00:13:07.210
palsu jadi apa artinya ini jika saya memiliki ruang yang berarti papan saya tidak bodoh.

181
00:13:07.250 --> 00:13:13.780
Jadi saya akan mengembalikan false jika saya melakukan seluruh empat loop ini dan saya tidak mengembalikan false maka saya

182
00:13:13.840 --> 00:13:16.630
akan mengembalikan true karena board saya penuh.

183
00:13:17.020 --> 00:13:19.310
Bosan itu bodoh.

184
00:13:19.420 --> 00:13:26.740
Jika kita mengembalikan TRUE OK jadi itulah fungsi pemeriksaan papan penuh.

185
00:13:26.740 --> 00:13:32.770
Langkahnya adalah menulis fungsi yang meminta posisi pemain berikutnya sebagai angka 1 hingga sembilan dan kemudian menggunakan fungsi

186
00:13:32.770 --> 00:13:36.170
dari Langkah 6 untuk memeriksa apakah itu dalam posisi bebas.

187
00:13:36.310 --> 00:13:40.970
Jika sudah kita kembalikan posisi untuk digunakan nanti.

188
00:13:41.080 --> 00:13:47.150
Jadi kita akan melakukan hal berikut, kita akan mengatakan posisi dan kita akan menjadikannya placeholder di nol karena

189
00:13:47.450 --> 00:13:48.860
kita tahu indeks 0.

190
00:13:48.910 --> 00:13:50.340
Tidak ada yang terjadi di sana.

191
00:13:50.580 --> 00:13:57.780
Dan kita dapat mengatakan sementara posisi tidak ada dalam daftar posisi yang memungkinkan.

192
00:13:57.780 --> 00:14:06.490
Jadi bisa jadi 1 2 3 4 5 6 7 8 9 kita bisa menggunakan rentang daftar panjang lengkap untuk mewujudkannya.

193
00:14:06.770 --> 00:14:17.300
Atau ruang itu tidak bebas sehingga kita dapat mengatakan atau tidak memeriksa ruang posisi Borda akan meminta pemain untuk posisi

194
00:14:17.300 --> 00:14:22.910
kita akan mengatakan posisi sama dengan bilangan bulat dari input.

195
00:14:23.270 --> 00:14:30.780
Pilih posisi 9.

196
00:14:30.970 --> 00:14:34.000
Dan akhirnya setelah semua ini kita akan mengembalikan posisi itu.

197
00:14:34.210 --> 00:14:39.280
Jadi yang kami lakukan di sini adalah mengikuti, kami akan mengatakan posisi dimulai dari nol dan posisi kekayaan.

198
00:14:39.350 --> 00:14:43.660
Jika pemain karena alasan tertentu memasukkan nomor yang salah di sana dengan meletakkan huruf yang

199
00:14:43.660 --> 00:14:48.620
akan menjadi cek ini untuk melihat apakah itu angka aktual yang ada di papan tulis atau itu akan memeriksa.

200
00:14:48.630 --> 00:14:50.830
Hei apakah ruang itu masih tersedia.

201
00:14:51.160 --> 00:14:55.900
Dan kemudian kita akan mengembalikan posisi setelah semua ini terpenuhi sehingga kita

202
00:14:55.900 --> 00:15:01.300
hanya akan memanggil pilihan pemain nanti setelah kita mengeceknya karena papan telah dibodohi oleh

203
00:15:01.300 --> 00:15:05.290
dewan. seri karena papannya bodoh dan belum ada yang menang.

204
00:15:05.290 --> 00:15:06.660
Lalu kita tahu ada dasi.

205
00:15:07.150 --> 00:15:12.660
OK langkah sembilan adalah menulis fungsi yang menanyakan pemain apakah mereka ingin bermain lagi dan mengembalikan boolean true.

206
00:15:12.670 --> 00:15:14.250
Jika mereka memang ingin bermain lagi.

207
00:15:14.520 --> 00:15:18.120
Begitu banyak cara berbeda yang bisa kita lakukan ini.

208
00:15:18.170 --> 00:15:22.420
Salah satu caranya adalah dengan mengatakan put play lagi.

209
00:15:23.150 --> 00:15:26.550
Tanda tanya jawab ya atau tidak.

210
00:15:27.530 --> 00:15:30.510
Dan kita akan mengatakan itu akan menjadi jawabannya.

211
00:15:30.550 --> 00:15:37.770
Anggap saja itu pilihan mereka dan kita akan mengatakan pilihan kembali sama dengan ya.

212
00:15:37.780 --> 00:15:44.200
Jadi di sini kita mengasumsikan orang tersebut benar-benar memberikan nilai yang benar jika kita mendapatkan pilihan yang tidak

213
00:15:44.200 --> 00:15:45.320
sama dengan ya.

214
00:15:45.370 --> 00:15:46.290
Pada dasarnya mereka harus benar.

215
00:15:46.300 --> 00:15:47.140
Ya sempurna.

216
00:15:47.140 --> 00:15:49.610
Kalau tidak, kami akan menganggap mereka tidak ingin bermain lagi.

217
00:15:49.630 --> 00:15:49.930
Baiklah.

218
00:15:49.950 --> 00:15:51.340
Dan itu adalah fungsi replay.

219
00:15:51.550 --> 00:15:53.110
Sekarang langkah 10 adalah bagian tersulit.

220
00:15:53.110 --> 00:15:54.980
Kami benar-benar harus kode semua logika.

221
00:15:55.090 --> 00:15:57.410
Jadi ini akan menjadi blok kode terbesar kami.

222
00:15:57.520 --> 00:15:59.640
Jadi kita akan menyelesaikan ini di kuliah berikutnya.

223
00:15:59.650 --> 00:16:00.280
Kami akan melihat apakah ada.
