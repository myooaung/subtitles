WEBVTT
1
1

00:00:01.446  -->  00:00:02.367
<v Narrator>Hello everyone,</v>
2

2

00:00:02.367  -->  00:00:04.533
and welcome to the Advanced Functions Test.
3

3

00:00:04.533  -->  00:00:07.425
So for this test, the main requirement is that
4

4

00:00:07.425  -->  00:00:10.979
all the functions you should be able to write inline.
5

5

00:00:10.979  -->  00:00:13.527
So basically what this test is gonna consist of
6

6

00:00:13.527  -->  00:00:16.778
are you filling in these problems with functions.
7

7

00:00:16.778  -->  00:00:18.671
But every single one of these functions
8

8

00:00:18.671  -->  00:00:21.222
can be done with just a single line,
9

9

00:00:21.222  -->  00:00:23.404
using the built-in functions that we learned about,
10

10

00:00:23.404  -->  00:00:26.323
such as map, reduce, filter, etc.
11

11

00:00:26.323  -->  00:00:27.156
So let's just go ahead and go
12

12

00:00:27.156  -->  00:00:29.989
through the problems real quickly.
13

13

00:00:31.087  -->  00:00:33.471
First problem is, use map to create a function
14

14

00:00:33.471  -->  00:00:36.625
which finds the length of each word in the phrase,
15

15

00:00:36.625  -->  00:00:40.312
broken by spaces, and returns the values in a list.
16

16

00:00:40.312  -->  00:00:42.452
So for instance, if you have a phrase here,
17

17

00:00:42.452  -->  00:00:44.534
how long are the words in this phrase,
18

18

00:00:44.534  -->  00:00:46.166
this function should be able to return
19

19

00:00:46.166  -->  00:00:47.729
a list that looks like this.
20

20

00:00:47.729  -->  00:00:52.052
So How has three letters in it, Long has four, etc.
21

21

00:00:52.052  -->  00:00:55.507
Now you should be able to do this all in one line here.
22

22

00:00:55.507  -->  00:00:58.305
So a return, and then one line of code,
23

23

00:00:58.305  -->  00:01:00.062
using the map function,
24

24

00:01:00.062  -->  00:01:03.259
and maybe some other stuff that you've learned about.
25

25

00:01:03.259  -->  00:01:05.920
Problem two, I want you to use reduce to take in
26

26

00:01:05.920  -->  00:01:09.278
a list of digits and return the number they correspond to.
27

27

00:01:09.278  -->  00:01:10.704
So here, I have a list of digits,
28

28

00:01:10.704  -->  00:01:13.078
three, four, three, two, one.
29

29

00:01:13.078  -->  00:01:15.828
And you reduce it to this 34,321.
30

30

00:01:17.503  -->  00:01:19.097
Now what I do not want you to do
31

31

00:01:19.097  -->  00:01:21.922
is to directly convert the integers to strings.
32

32

00:01:21.922  -->  00:01:25.010
Figure out a better way to do it than that.
33

33

00:01:25.010  -->  00:01:27.286
Okay, problem three.
34

34

00:01:27.286  -->  00:01:30.139
Here I want you to use filter to return the words
35

35

00:01:30.139  -->  00:01:33.238
from a list of words, which start with a target letter.
36

36

00:01:33.238  -->  00:01:36.240
So you'll have a list of a bunch of words,
37

37

00:01:36.240  -->  00:01:39.382
and here, the function will take in that list
38

38

00:01:39.382  -->  00:01:42.657
and a target letter, and will return a list of
39

39

00:01:42.657  -->  00:01:46.020
all the words that start with that target letter.
40

40

00:01:46.020  -->  00:01:48.845
And again, this is all done in one line.
41

41

00:01:48.845  -->  00:01:52.807
Problem four, I want you to use zip and list comprehension
42

42

00:01:52.807  -->  00:01:54.809
to return a list of the same length,
43

43

00:01:54.809  -->  00:01:58.565
where each value is the two strings from L1 and L2
44

44

00:01:58.565  -->  00:02:01.694
concatenated together with connector in between them.
45

45

00:02:01.694  -->  00:02:04.397
So what I want you to do is, for example,
46

46

00:02:04.397  -->  00:02:06.715
you take in one list, you take in another,
47

47

00:02:06.715  -->  00:02:08.718
and then you take in some sort of connector,
48

48

00:02:08.718  -->  00:02:12.228
and what you return, using zip and list comprehension,
49

49

00:02:12.228  -->  00:02:14.159
remember this is all in one line,
50

50

00:02:14.159  -->  00:02:16.272
is a list that looks like this.
51

51

00:02:16.272  -->  00:02:18.592
The item from list one, the connector,
52

52

00:02:18.592  -->  00:02:21.280
the item from list two, for that index zero.
53

53

00:02:21.280  -->  00:02:23.867
Then that index one, item from list one,
54

54

00:02:23.867  -->  00:02:26.628
the connector, item from list two.
55

55

00:02:26.628  -->  00:02:30.067
Okay, problem five, I want you to use enumerate
56

56

00:02:30.067  -->  00:02:32.635
and some other skills to return a dictionary,
57

57

00:02:32.635  -->  00:02:34.759
which has the values of the list as keys
58

58

00:02:34.759  -->  00:02:36.722
and the index as the value.
59

59

00:02:36.722  -->  00:02:39.246
And you can assume that a value will only appear once
60

60

00:02:39.246  -->  00:02:40.790
in the given list.
61

61

00:02:40.790  -->  00:02:44.046
So for example, you'll have a list that says a, b, c,
62

62

00:02:44.046  -->  00:02:48.132
and you return a dictionary a of zero, b one, c two.
63

63

00:02:48.132  -->  00:02:52.833
Okay, so the index of a was zero, that becomes its value,
64

64

00:02:52.833  -->  00:02:57.744
index of b was one, that becomes its value, as b is the key.
65

65

00:02:57.744  -->  00:02:59.554
Last problem, I want you to use enumerate
66

66

00:02:59.554  -->  00:03:02.119
and other skills from above to return the count of the
67

67

00:03:02.119  -->  00:03:05.894
number of items in the list whose value equals its index.
68

68

00:03:05.894  -->  00:03:10.240
So for example, here you're gonna take in count match index,
69

69

00:03:10.240  -->  00:03:13.328
again, this should all be able to be done on one line,
70

70

00:03:13.328  -->  00:03:16.095
you take in a list and you check of each of these numbers,
71

71

00:03:16.095  -->  00:03:19.280
so zero, the first one, does that number match the index?
72

72

00:03:19.280  -->  00:03:22.555
Yes, zero is at zero, that's a plus one.
73

73

00:03:22.555  -->  00:03:26.054
This is at index one, so two does not match.
74

74

00:03:26.054  -->  00:03:28.038
This one is, however, at index two,
75

75

00:03:28.038  -->  00:03:31.033
so two equals two, so that matches, etc.
76

76

00:03:31.033  -->  00:03:34.082
All the way down, in this case, there's four matching here.
77

77

00:03:34.082  -->  00:03:36.221
Alright, so those are the six problems.
78

78

00:03:36.221  -->  00:03:38.070
Remember they should all be done on one line,
79

79

00:03:38.070  -->  00:03:40.291
using things such as list comprehension
80

80

00:03:40.291  -->  00:03:43.572
and lambda expressions, and all the built-in
81

81

00:03:43.572  -->  00:03:45.421
functions that we learned about.
82

82

00:03:45.421  -->  00:03:49.588
Okay, best of luck and I will see you at the next lecture!
