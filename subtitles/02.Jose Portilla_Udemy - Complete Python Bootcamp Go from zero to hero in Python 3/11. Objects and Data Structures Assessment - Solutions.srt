1
1

00:00:01,121  -->  00:00:01,954
<v Instructor>Hello everyone.</v>
2

2

00:00:01,954  -->  00:00:03,082
In this video, we'll be going over
3

3

00:00:03,082  -->  00:00:07,485
the Objects and Data Structures assessment solutions.
4

4

00:00:07,485  -->  00:00:10,877
Okay, so the first question was, "write a brief description
5

5

00:00:10,877  -->  00:00:13,084
of all the following Object types and Data Structures
6

6

00:00:13,084  -->  00:00:14,519
we've learned about."
7

7

00:00:14,519  -->  00:00:16,568
So for the full answers, all you've gotta do
8

8

00:00:16,568  -->  00:00:18,405
is review the Jupyter notebook.
9

9

00:00:18,405  -->  00:00:20,205
So if you go to the solutions notebook,
10

10

00:00:20,205  -->  00:00:21,921
I've put links so you can go ahead and
11

11

00:00:21,921  -->  00:00:23,998
check out the introductions of each of
12

12

00:00:23,998  -->  00:00:27,705
those Jupyter notebooks where described in layman's terms
13

13

00:00:27,705  -->  00:00:31,460
numbers, strings, lists, tuples, and dictionaries.
14

14

00:00:31,460  -->  00:00:35,510
So let's go ahead and move on to the numbers section.
15

15

00:00:35,510  -->  00:00:36,820
First thing I wanted you to do is write
16

16

00:00:36,820  -->  00:00:39,816
an equation that uses multiplication, division,
17

17

00:00:39,816  -->  00:00:42,189
exponent, addition, and subtraction to equal
18

18

00:00:42,189  -->  00:00:44,528
this kind of arbitrary number.
19

19

00:00:44,528  -->  00:00:46,005
So your answer's probably different,
20

20

00:00:46,005  -->  00:00:47,478
all I did was work backwards.
21

21

00:00:47,478  -->  00:00:51,850
But this was just so you made sure you understood
22

22

00:00:51,850  -->  00:00:54,775
what minus, to the powers, parenthesis,
23

23

00:00:54,775  -->  00:00:59,174
division, multiplication all look like, and how they worked.
24

24

00:00:59,174  -->  00:01:03,174
So this is what I did, and that equals a 100.25.
25

25

00:01:04,699  -->  00:01:05,964
Next I wanted to explain what
26

26

00:01:05,964  -->  00:01:09,420
the cell would produce, two divided by three,
27

27

00:01:09,420  -->  00:01:13,460
and what can you do to change it so the answer's correct.
28

28

00:01:13,460  -->  00:01:16,482
So if you notice, we have two divided by three
29

29

00:01:16,482  -->  00:01:17,912
and we have a zero there.
30

30

00:01:17,912  -->  00:01:19,428
And remember that's because Python 2
31

31

00:01:19,428  -->  00:01:21,793
performs classic division for integers,
32

32

00:01:21,793  -->  00:01:24,824
and you need to use floats to perform true division,
33

33

00:01:24,824  -->  00:01:28,030
such as 2.0 divided by three.
34

34

00:01:28,030  -->  00:01:30,366
We also discussed on how to use import from the
35

35

00:01:30,366  -->  00:01:33,581
future module to also change that.
36

36

00:01:33,581  -->  00:01:35,500
Or you could just use Python 3 and you
37

37

00:01:35,500  -->  00:01:38,607
wouldn't have to worry about that.
38

38

00:01:38,607  -->  00:01:41,431
Next, answer these three questions without typing code,
39

39

00:01:41,431  -->  00:01:43,353
then type code to check your answer.
40

40

00:01:43,353  -->  00:01:45,153
So you can go ahead and check your own answers here,
41

41

00:01:45,153  -->  00:01:46,622
but this was just to make sure you understood
42

42

00:01:46,622  -->  00:01:49,730
order of operations in Python.
43

43

00:01:49,730  -->  00:01:53,037
What was the type of the result of the expression here?
44

44

00:01:53,037  -->  00:01:54,877
The answer's gonna be a floating point number,
45

45

00:01:54,877  -->  00:01:56,310
as long as there's one floating point
46

46

00:01:56,310  -->  00:01:57,698
number in the entire equation your
47

47

00:01:57,698  -->  00:02:01,637
result will be a floating point number.
48

48

00:02:01,637  -->  00:02:03,559
After that, what would you used to
49

49

00:02:03,559  -->  00:02:06,804
find a number's square root, as well as its square?
50

50

00:02:06,804  -->  00:02:10,168
You can just use two asterisks in a row
51

51

00:02:10,168  -->  00:02:14,118
to do a power, and then use a fraction to do a square root.
52

52

00:02:14,118  -->  00:02:17,558
There's also a math module in Python that will
53

53

00:02:17,558  -->  00:02:19,024
allow you to do square roots and we'll
54

54

00:02:19,024  -->  00:02:22,384
talk about that later on in the course.
55

55

00:02:22,384  -->  00:02:24,593
The string section, basically I just wanted you
56

56

00:02:24,593  -->  00:02:26,922
to play around with indexing,
57

57

00:02:26,922  -->  00:02:30,480
so writing out commands to grab letters from strings,
58

58

00:02:30,480  -->  00:02:31,463
making sure that you understand
59

59

00:02:31,463  -->  00:02:34,653
that indexing starts at zero, reversing strings,
60

60

00:02:34,653  -->  00:02:38,991
again with slicing and indexing, and then given the string,
61

61

00:02:38,991  -->  00:02:41,522
give two methods to print the letter O.
62

62

00:02:41,522  -->  00:02:44,546
First one was just going in reverse with negative one.
63

63

00:02:44,546  -->  00:02:49,205
Second one I just went straightforward with index of four.
64

64

00:02:49,205  -->  00:02:51,239
After that it was lists, and I wanted you to build
65

65

00:02:51,239  -->  00:02:53,813
the list 0,0,0 two separate ways.
66

66

00:02:53,813  -->  00:02:55,528
One way is just the standard,
67

67

00:02:55,528  -->  00:02:57,864
write out the lists in between brackets.
68

68

00:02:57,864  -->  00:02:59,830
The second way you could have done it was
69

69

00:02:59,830  -->  00:03:02,401
by doing a list of zero and multiplying
70

70

00:03:02,401  -->  00:03:05,914
it by three to get three of those.
71

71

00:03:05,914  -->  00:03:08,120
After that I wanted you to reassign "hello"
72

72

00:03:08,120  -->  00:03:11,552
in this nested list to say "goodbye."
73

73

00:03:11,552  -->  00:03:15,067
So the index to reach that item was [2][2],
74

74

00:03:15,067  -->  00:03:18,743
because it was a list nested inside of a list.
75

75

00:03:18,743  -->  00:03:20,918
After that I wanted you to sort this list,
76

76

00:03:20,918  -->  00:03:23,456
and you could've done that with a sorted function
77

77

00:03:23,456  -->  00:03:25,623
or with the method "sort."
78

78

00:03:27,828  -->  00:03:29,502
Then for dictionaries, this was basically
79

79

00:03:29,502  -->  00:03:32,831
just keys and indexing to grab "hello."
80

80

00:03:32,831  -->  00:03:34,511
First one was just pretty simple,
81

81

00:03:34,511  -->  00:03:36,349
you just had to do this simple key.
82

82

00:03:36,349  -->  00:03:38,029
The second one a little trickier,
83

83

00:03:38,029  -->  00:03:40,278
had to do two keys because there was a dictionary
84

84

00:03:40,278  -->  00:03:42,864
nested inside another dictionary.
85

85

00:03:42,864  -->  00:03:44,788
Third one, pretty tricky, this is
86

86

00:03:44,788  -->  00:03:46,628
actually harder than I expected.
87

87

00:03:46,628  -->  00:03:49,390
It was the key, an index, nest key,
88

88

00:03:49,390  -->  00:03:52,660
and then two indexes later to get "hello".
89

89

00:03:52,660  -->  00:03:54,215
This one was a little crazy.
90

90

00:03:54,215  -->  00:03:57,632
It was a key, an index, a key two, index,
91

91

00:03:58,551  -->  00:04:00,800
the key "toughie" and then two indexes
92

92

00:04:00,800  -->  00:04:02,805
to reach "hello" there.
93

93

00:04:02,805  -->  00:04:05,914
After that was "Can you sort a dictionary? Why or why not?"
94

94

00:04:05,914  -->  00:04:07,385
No you can not sort a dictionary,
95

95

00:04:07,385  -->  00:04:10,650
because normal dictionaries are mappings, not sequence.
96

96

00:04:10,650  -->  00:04:13,717
So they don't remember what order you put in items in.
97

97

00:04:13,717  -->  00:04:15,392
Now later on in the course we'll talk about
98

98

00:04:15,392  -->  00:04:18,254
something called an ordered dictionary,
99

99

00:04:18,254  -->  00:04:20,219
which is a sub-class of dictionary in Python
100

100

00:04:20,219  -->  00:04:22,715
in a specific module called collections,
101

101

00:04:22,715  -->  00:04:25,045
so you'll learn about a specific type of dictionary
102

102

00:04:25,045  -->  00:04:28,128
that you actually can remember order.
103

103

00:04:29,667  -->  00:04:32,121
Moving along with Tuples, "What's the major difference
104

104

00:04:32,121  -->  00:04:34,285
between tuples and lists?"
105

105

00:04:34,285  -->  00:04:35,863
Hopefully you were able to answer this,
106

106

00:04:35,863  -->  00:04:39,054
which is tuples are immutable, that's the big difference.
107

107

00:04:39,054  -->  00:04:40,404
"How do you create a tuple?"
108

108

00:04:40,404  -->  00:04:42,367
Remember it's just parenthesis and then commas,
109

109

00:04:42,367  -->  00:04:44,041
just like a list but instead of square brackets
110

110

00:04:44,041  -->  00:04:46,448
you're using parenthesis.
111

111

00:04:46,448  -->  00:04:48,784
For sets, "What's unique about a set?"
112

112

00:04:48,784  -->  00:04:51,562
Remember they don't allow duplicate items.
113

113

00:04:51,562  -->  00:04:53,527
So to use a set to find the unique values,
114

114

00:04:53,527  -->  00:04:57,201
you could just cast that list with the set function.
115

115

00:04:57,201  -->  00:04:59,331
For booleans, don't worry if you didn't
116

116

00:04:59,331  -->  00:05:00,972
fully understand this, there's a whole section
117

117

00:05:00,972  -->  00:05:03,668
on comparison operators coming up next.
118

118

00:05:03,668  -->  00:05:07,114
But I just wanted you to get kind of a sneak peek.
119

119

00:05:07,114  -->  00:05:11,570
You can go ahead and check out these various pieces of code.
120

120

00:05:11,570  -->  00:05:14,609
They should have been hopefully pretty straightforward
121

121

00:05:14,609  -->  00:05:16,288
if you already knew some math notations.
122

122

00:05:16,288  -->  00:05:17,517
This is two greater than three,
123

123

00:05:17,517  -->  00:05:21,324
or two less than or equal to two, et cetera.
124

124

00:05:21,324  -->  00:05:24,253
So you can run those cells and check your answers.
125

125

00:05:24,253  -->  00:05:26,173
Final question was, "What is the boolean output
126

126

00:05:26,173  -->  00:05:28,830
"of the cell block below?" Right here.
127

127

00:05:28,830  -->  00:05:31,120
So it's gonna be false, and we can check
128

128

00:05:31,120  -->  00:05:32,753
that through indexing.
129

129

00:05:32,753  -->  00:05:36,336
So l_one, index two, zero, would have been,
130

130

00:05:38,183  -->  00:05:41,331
if we look here, that would have been this list,
131

131

00:05:41,331  -->  00:05:44,361
first item, so that's three.
132

132

00:05:44,361  -->  00:05:46,610
So then you're basically asking, "Is three greater
133

133

00:05:46,610  -->  00:05:48,088
"than or equal to?"
134

134

00:05:48,088  -->  00:05:51,694
And we fill out that second list it's gonna be index two,
135

135

00:05:51,694  -->  00:05:53,572
key one, so four.
136

136

00:05:53,572  -->  00:05:55,704
So is three greater than or equal to four?
137

137

00:05:55,704  -->  00:05:57,011
That's false.
138

138

00:05:57,011  -->  00:05:59,219
Okay, great job on your first assessment,
139

139

00:05:59,219  -->  00:06:02,002
and I'm excited to continue on with the course,
140

140

00:06:02,002  -->  00:06:03,726
and I'll see you at the next lecture where
141

141

00:06:03,726  -->  00:06:06,257
we talk about Python comparison operators.
142

142

00:06:06,257  -->  00:06:07,840
Great job everyone.
