WEBVTT

00:00.810 --> 00:06.560
All right so here we're going to be finding the largest strings in an array of strings who are turning

00:06.590 --> 00:12.730
an array of those values so in our example here we have some some multilane strings.

00:13.200 --> 00:19.740
The Hoops the largest one is eighth are three digits long and thus we're going to return an array of

00:19.800 --> 00:21.570
all three digit strings.

00:21.570 --> 00:27.690
I don't really have any hints here for you for methods this is all just pure logic so let's go and dive

00:27.690 --> 00:28.980
into it.

00:28.980 --> 00:36.600
So our first objective here should be to find out what the longest length of the largest string is in

00:36.600 --> 00:38.100
our array.

00:38.160 --> 00:45.810
Let's start by creating this longest length variable and we're just equal to zero.

00:46.500 --> 00:52.260
And now we're going to also need let's just we'll do one by one.

00:52.260 --> 00:54.570
So we're going to iterate through each one.

00:54.570 --> 00:58.980
In this case we're going to use it for each use of words giving us rather descriptive and we're just

00:58.980 --> 01:02.830
going to say hey we expect each one of these words to be a string.

01:02.920 --> 01:06.120
It's cool.

01:06.610 --> 01:12.670
Now we've done that what we want to do here is we want to compare the length of the word to our longest

01:12.670 --> 01:20.060
length which we're OK initializing to zero because if there's no a if it's just an empty string.

01:20.070 --> 01:22.350
See I have length this year so that's fine.

01:22.430 --> 01:24.730
Not to worry about negatives or anything like that.

01:24.880 --> 01:31.360
So long as science is equal to long it's Lance being less than our word length.

01:31.420 --> 01:32.810
So we're doing ternary here.

01:32.950 --> 01:39.540
We're saying is that less than our word length is.

01:39.590 --> 01:43.760
Go ahead and return a word doc lamp's if it isn't.

01:43.820 --> 01:46.890
Go ahead or interring long late and set it back equal to itself.

01:47.120 --> 01:52.380
So now we have we have our longest land.

01:53.030 --> 01:58.260
And now we need a way to return the longest words.

01:58.400 --> 02:02.210
So we're going to do next three and create a counts here longest words

02:05.160 --> 02:07.780
and we're going to set that equal to an Inferi

02:10.760 --> 02:16.400
and return longest words.

02:16.650 --> 02:18.720
Excellent.

02:18.720 --> 02:25.790
Now all we have to do from here is one more time through that array.

02:28.170 --> 02:30.510
And do it again.

02:30.520 --> 02:37.350
Type of string excellent and we just have simplicity in here.

02:37.550 --> 02:46.490
This is if word length is exactly equal to the longest length meaning that it matches the length of

02:46.490 --> 02:47.800
the largest strings.

02:49.370 --> 03:00.010
All we need to do now is close them all we need to do now is push two longest words.

03:00.110 --> 03:00.740
That word

03:05.050 --> 03:06.090
and there we have it.

03:06.130 --> 03:10.110
We have our three that we're expecting.

03:10.280 --> 03:12.100
Pretty pretty straightforward.

03:12.220 --> 03:22.430
There might be a way to do this but in terms of efficiency I don't really see a shorter way.

03:22.540 --> 03:28.620
Pretty much we have to iterate through long slainte and then push those values to it after one more

03:28.620 --> 03:30.830
after issue I think it's fine for the efficiency.

03:30.850 --> 03:32.790
But if someone has a better way please share it.

03:32.800 --> 03:33.340
As always.
