WEBVTT

00:00.720 --> 00:06.090
All right so this is a challenge that is under Google on catfights.

00:06.390 --> 00:07.830
It's called First duplicate.

00:07.920 --> 00:15.780
And what it's trying to get us to do is return the first duplicate value in an array that is going to

00:16.680 --> 00:22.510
be the first to get value that will then return negative one if there isn't one.

00:22.560 --> 00:24.120
That's really our only objective.

00:24.120 --> 00:27.180
So in our first example here we have three and then three.

00:27.180 --> 00:28.780
So it's going to return three.

00:28.800 --> 00:31.590
That's the first duplicate even though 2 and 2 is in there.

00:31.590 --> 00:34.820
The first one is the first one that has the following number.

00:34.920 --> 00:35.990
The backup number right.

00:35.990 --> 00:38.190
Not necessarily the index spot.

00:38.190 --> 00:42.560
So first the first occurrence of a second number is how I would put it.

00:42.690 --> 00:45.240
And then here there are no duplicate so are turning negative one.

00:45.240 --> 00:50.150
The only hint I have for you was that I solved this using has own property.

00:50.340 --> 00:52.860
Let's go ahead and jump into it.

00:52.890 --> 00:53.250
All right.

00:53.250 --> 00:59.850
So what we're going to do here is we're going to create a object where we are storing a reference to

00:59.850 --> 01:01.100
the Keys.

01:01.260 --> 01:08.460
So what we're going to be creating Keys based off of our our values here.

01:08.550 --> 01:13.380
And when we finally hit one that already exists we're just going to return that value we found if we

01:13.380 --> 01:15.910
never hit one we're going to return negative 1.

01:15.930 --> 01:19.670
So our failure case.

01:19.710 --> 01:24.610
Meaning that nothing passes is negative one that's what we're going to return.

01:24.870 --> 01:40.340
The our object and we'll just call this first do first dupe and then it's equal to here and we're going

01:40.340 --> 01:49.250
to do is we're going to iterate through our four loops so we're just a week before of oh say let some

01:49.460 --> 02:07.730
of A and we'll do it if say if our our smallest Susie if first do dot has own property meaning it already

02:07.730 --> 02:11.930
exists for knowm.

02:11.930 --> 02:13.120
If that's true thing.

02:13.370 --> 02:14.590
We just returned no.

02:14.680 --> 02:15.910
We found it.

02:16.100 --> 02:19.440
That means it already has been added.

02:19.490 --> 02:25.910
Else we go ahead and just set first do peer

02:28.790 --> 02:32.850
of that property number just set it unknown.

02:33.230 --> 02:37.640
The setting does really matter and no I think I think we remove this Alice because our IF is going to

02:37.640 --> 02:43.100
break out if that's every true eliminate some of that code here and BAM.

02:43.110 --> 02:43.520
That's it.

02:43.520 --> 02:47.680
So the idea here is we have an object that we're mapping to.

02:48.110 --> 02:53.740
We are then going to check if a property exists on here.

02:53.840 --> 02:57.010
Meaning like we've already mapped a number to it.

02:57.410 --> 03:01.500
If we have we're just going to return that number because we found the first duplicate.

03:01.670 --> 03:04.140
If we haven't we're going to add that key to it.

03:04.240 --> 03:08.510
And if it never hits meaning it gets through this whole loop or just returning a good one that's pretty

03:08.510 --> 03:09.210
much it.
