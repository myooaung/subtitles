WEBVTT

00:00.380 --> 00:06.560
Are so Araik conversion is a really fun one I really like this one because I think it gets you know

00:06.560 --> 00:14.010
the way that I solved it as I wrote a second function that handles a lot of the logic here.

00:14.120 --> 00:23.090
But you know so here we have an array of numbers and what we want to happen is on the odd numbers we

00:23.090 --> 00:25.150
want to add there.

00:25.490 --> 00:32.270
The next index values together and on the even numbers we want to multiply those values until we get

00:32.270 --> 00:33.970
a single array value.

00:33.980 --> 00:42.170
So in our example here on the first iteration we're going to add so 1 and 2 becomes 3 3 and 4 becomes

00:42.170 --> 00:47.800
7 5 and 6 becomes 11 and 7 and 8 becomes 15.

00:48.010 --> 00:55.030
Then the next iteration we have three and seven becomes 21 11 and 15 becomes 165 and then on the next

00:55.030 --> 01:00.710
iteration they add those together to return our final answer which is 186 which is a number.

01:00.730 --> 01:07.110
So the only hint I have for you here is I use push as a method that I use.

01:07.270 --> 01:11.140
Everything else so just pure logic go in and dive right into it.

01:11.140 --> 01:11.340
All right.

01:11.350 --> 01:19.750
So the way I solve this was I created a boolean value that let us let us know if we were on a even or

01:19.750 --> 01:21.620
odd number.

01:21.640 --> 01:29.650
So because we have to either add or multiply and I use a while loop to keep track of adoration and call

01:29.650 --> 01:36.490
a separate function I called some product that took in an array of values and a sum and then with an

01:36.490 --> 01:42.400
if else there perform the the numbers and passed it back.

01:42.400 --> 01:48.910
Similar in a recursive fashion except I just use a while loop because I think it pretty much recursion

01:48.910 --> 01:51.900
exists when you don't want to use a while loop most of the time.

01:51.940 --> 01:55.350
And we can do things recursively or we can use a while loop nine times out of 10.

01:55.360 --> 01:59.640
So I think while it's a little bit easier to follow for a lot of people so here we go.

01:59.740 --> 02:08.020
So we give what I called iteration and my first time I think if we were to refactor this we could call

02:08.020 --> 02:15.220
this is odd because that's really what we're keeping track of here and we're going to set that to true.

02:15.460 --> 02:20.390
And what we want to do is we want to iterate until our input array.

02:20.920 --> 02:22.340
So length is one.

02:22.330 --> 02:30.820
Because remember we're going to keep sending back a new array after it's been multiplied or multiplied

02:30.880 --> 02:32.400
or added to.

02:32.590 --> 02:36.860
And we want to run that as long as it's not equal to 1.

02:37.150 --> 02:45.760
So what we can do here is we now know that because we want to keep track of is all we're saying is odd

02:46.060 --> 02:47.440
is equal to not is odd.

02:47.430 --> 02:51.940
So that's going to change the numbers as we go through and at the end.

02:51.940 --> 02:58.750
What we want to return here is a number which will be our input array that is zero once we only have

02:58.750 --> 03:01.030
one value like so.

03:01.180 --> 03:04.230
And for some reason my quick turned off so start that back up

03:07.750 --> 03:11.300
two broke.

03:11.650 --> 03:15.620
So it's it's actually probably running I just have an infinite loop right now.

03:15.790 --> 03:28.930
So the way we're going to solve that is we're going to hear write a function called some product in

03:28.930 --> 03:38.020
some product what we want to take in is a number array and then we're also going to take in the is odd

03:38.590 --> 03:39.840
which is going to be a boolean

03:43.070 --> 03:48.310
because that's going to tell us if we want to add or multiply.

03:48.430 --> 03:52.460
And what we're expecting back from here is an array of numbers.

03:54.080 --> 03:55.160
All right.

03:55.160 --> 04:03.320
And what we want to do is sit input array equal to some product and that's going to take in our Gnome's

04:03.680 --> 04:13.940
our number right which is our input or excuse me is also going to take in our is odd boolean value

04:16.790 --> 04:19.460
art can I read properly.

04:19.460 --> 04:21.720
Length of undefine version.

04:21.770 --> 04:23.680
Ignore all that for now.

04:29.060 --> 04:33.620
Go ahead and move this that are cool.

04:36.770 --> 04:37.250
All right.

04:37.500 --> 04:41.460
So what we're doing here now is we now have to have our logic.

04:41.610 --> 04:48.620
And what we're going to do is a simple IF ELSE check to find out if we need to multiply or divide.

04:48.720 --> 04:53.280
First when you go out and create a constant variable here called some products and this is going to

04:53.280 --> 04:57.100
be a number array we're going to go ahead and say that equal to an empty array.

04:57.450 --> 05:09.420
Now if if it is odd what we want to do is just iterate through those values and jump two at a time because

05:09.420 --> 05:10.550
remember we're doing pairs here.

05:10.550 --> 05:11.770
We're not going through each one.

05:11.970 --> 05:16.590
So we can do that with a simple for loop where he said Let i equal to zero.

05:17.730 --> 05:27.400
While I is less than when we go ahead minus 1 here so we can see the whole picture is less than the

05:28.420 --> 05:30.910
gnome's array length.

05:32.080 --> 05:36.760
But instead of iterating by one we're going to iterate by two that way we get our pairs and all we're

05:36.760 --> 05:38.960
going to do here is take some products.

05:39.420 --> 05:46.760
So this is plus equals excluding some products not push the number that we're checking.

05:46.960 --> 05:52.050
And the next number as well which is just going to be high plus one.

05:52.200 --> 05:54.800
And because we're doing that we're again jumpy too.

05:55.150 --> 06:00.540
Now what we do here just what else to handle the product aspect of it.

06:00.760 --> 06:05.540
And this is going to say for what pi equal to zero.

06:05.610 --> 06:08.230
And we can actually go ahead and just copy this over.

06:08.270 --> 06:09.640
Save yourself some time.

06:12.720 --> 06:14.200
Excellent.

06:14.310 --> 06:22.270
And then copy this over as well and instead of adding on to here just multiply.

06:22.500 --> 06:28.880
And at the end all we need to do is return some products here because again we're returning a number

06:28.950 --> 06:29.130
a

06:32.000 --> 06:35.370
and what you'll see is that we get our total 186.

06:35.400 --> 06:40.260
So we did quite a bit there but it's not really all that complicated when we start thinking about it.

06:40.290 --> 06:44.550
So we keep track of a is odd value.

06:44.550 --> 06:53.370
We then iterate through the input array decreasing its size by half until it is exactly equal to a 1.

06:53.580 --> 06:56.910
And then we're past we're switching after it runs the iteration.

06:56.930 --> 07:03.150
Updating our input array we are then we are then changing it to say oh it's not on anymore it's now

07:03.150 --> 07:05.730
even and it's going until it goes down.

07:05.820 --> 07:11.220
Here we're just running some little check that adds those values and returns the updated input array

07:11.490 --> 07:12.550
to happen again.

07:12.690 --> 07:19.440
So I found I had a lot of fun with this and I encourage you to if you want to solve it recursively but

07:19.910 --> 07:22.780
it's pretty much the same thing I did with the While loop at the end the day.
