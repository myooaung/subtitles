WEBVTT

00:00.670 --> 00:04.040
All right find close pairs.

00:04.060 --> 00:10.470
So what we're trying to do here is we're trying to find the closest pair of values that equal our soul

00:10.470 --> 00:16.300
and so we're taking an array of values and we want to find out which of them will add up to five.

00:16.330 --> 00:24.550
Not only that we want to return the one that is closest together so one in four add together for five

00:24.850 --> 00:31.450
but two and three are closer because there's only two numbers between them and that is exactly what

00:31.450 --> 00:32.310
we're looking for.

00:32.320 --> 00:41.440
Her turn is the closest pair in terms of the difference between the two indexes indices.

00:41.470 --> 00:45.120
Now if there isn't one we're just going to go ahead and return negative 1.

00:45.430 --> 00:48.380
That's our objective The only hint I have for you is I use math.

00:48.430 --> 00:49.870
Absolute or abs.

00:49.880 --> 00:52.150
This is for this iteration.

00:52.550 --> 00:58.030
All right so for this I did a brute force tactic where essentially just checked all the combinations

00:58.030 --> 01:06.040
and worked my way through which is an ode to the and to solution which is kind of slow because you're

01:06.040 --> 01:10.030
iterating through every single thing every single time each iteration.

01:10.390 --> 01:13.180
So it's it's quite slow but it does work.

01:13.180 --> 01:19.200
So the way I did it was I created a distance variable and I said it equals the negative negative one.

01:19.210 --> 01:21.270
Because this is what we're going to want to modify.

01:21.280 --> 01:23.840
So on the end here we're going to go ahead and just want to return.

01:23.830 --> 01:27.270
Distance is equal to the negative one.

01:27.640 --> 01:28.730
Awesome.

01:29.230 --> 01:38.110
Now that we've done that we want to do is we want to do a a check here that says hey let's go ahead

01:38.230 --> 01:43.650
and iterate through all our race twice or and test it right and then we're in check the value in learning

01:43.670 --> 01:51.820
at the absolute value and see if it is greater than our distance here or equal to if it's equal to our

01:51.820 --> 01:52.530
sum.

01:52.690 --> 01:56.440
And then we're OK is a distance if it is awesome.

01:56.440 --> 02:09.480
So we go through here that high equal to zero Why is less than our numbers length plus plus.

02:09.620 --> 02:13.890
Now we're going to go ahead and iterate one more time and say Let J equal to zero.

02:14.170 --> 02:22.860
When J is less then our numbers length J plus plus awesome.

02:23.000 --> 02:28.900
Now that we have that we're set up to First we have to find out what is our distance something and I

02:28.920 --> 02:30.700
mean that and create a variable for this.

02:30.830 --> 02:34.370
And this is going to be the current number.

02:34.370 --> 02:35.100
The numbers I

02:38.140 --> 02:40.930
plus the numbers J.

02:40.930 --> 02:44.020
And we actually are going to need to offset our values here.

02:44.040 --> 02:50.850
We're going to set J equal to I plus 1 because we want to have different values that we're checking

02:50.860 --> 02:55.900
so recent that we need to reiterate through every single one and we're going to just go ahead and minus

02:55.900 --> 02:59.620
one off here so I don't have any any out of bounds exceptions.

02:59.620 --> 03:08.490
So now we have that we're in what I call abs distance which is going to be the absolute value here of

03:08.490 --> 03:13.090
the two of the values minus So we're going to have I match j.

03:15.700 --> 03:18.490
Because index values are what we're comparing here.

03:18.760 --> 03:27.040
Now if it is in fact true that sum is exactly equal the distance some what we're going to want to do

03:27.040 --> 03:31.790
here is your Seven-Eleven nested if this is a distance.

03:31.790 --> 03:44.580
If abs distance is less than distance we want to go ahead and set distance equal to ABS distance

03:47.160 --> 03:53.070
and we're going to do one more thing here where we're going to set a system here where we have to check

03:53.820 --> 03:58.630
for distance being equal to negative 1 because we're never going to get a negative value here.

03:58.680 --> 04:03.090
So we're going to do is we're going to just put this little negative if we're at this point we know

04:03.090 --> 04:04.560
we have a value.

04:04.680 --> 04:12.830
If distance is equal to negative 1 or ABS abs distance is less than distance than this is accurate.

04:12.850 --> 04:16.410
But see I may have made a mistake in my code somewhere.

04:16.710 --> 04:19.970
So we are either need of one.

04:20.100 --> 04:27.810
Why is equal numbers on length and just number japes plus plus numbers plus numbers J.

04:28.140 --> 04:36.620
Then math thought absolute numbers and then we say sum is equal distance some distance will need one

04:36.650 --> 04:39.900
at distance distances equal distance.

04:40.030 --> 04:40.740
I only did it right.

04:40.750 --> 04:42.990
I don't know what I was doing here when I put distance.

04:43.000 --> 04:44.090
There we go.

04:44.140 --> 04:45.760
I was like oh what's going on here.

04:45.790 --> 04:49.510
So we're going to iterate through it the absolute value of the indexes.

04:49.510 --> 04:54.190
We have this little logic here to handle the negative one case for our we're solving it and then we're

04:54.190 --> 04:56.170
going to update the value and finally return it.
