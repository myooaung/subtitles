WEBVTT

00:00.780 --> 00:06.800
All right guys we are in square digit sequence with my guest star Tito here.

00:06.840 --> 00:09.480
He wants to hang out say hi.

00:09.690 --> 00:12.840
Well go ahead and I said Buddy you can be in a video today why not.

00:12.840 --> 00:13.200
All right.

00:13.230 --> 00:20.460
So what we're trying to do here is we have a number that's coming into our function in this case it's

00:20.460 --> 00:21.750
16 loops.

00:21.930 --> 00:25.600
And what we're trying to do is we're a split up into digits.

00:25.800 --> 00:31.440
So one in six and then we're going to square those and then we're going to get a roommate a new value

00:31.440 --> 00:38.370
37 and we want to do this until we get a value that has been duplicated and the amount of iterations

00:38.670 --> 00:41.100
that that takes is what we're going to return.

00:41.100 --> 00:47.050
So you'll see here we start iteration one 16:30 750 50 89 145 for 224.

00:47.160 --> 00:52.560
And finally we end back up with 16 that Carrick's shouldn't be there but we go for it to the second

00:53.040 --> 00:58.520
which gets us 4 squared rather gets us to 16 again.

00:58.560 --> 01:02.130
And so it takes nine times to get that so that is our objective.

01:02.130 --> 01:05.520
Let's go ahead and talk about how I solved it just a little bit.

01:05.520 --> 01:15.140
I think this might be the algorithm that I use the most method to solve this is 1 2 3 4 5 6 7 I use

01:15.180 --> 01:16.890
7 methods to solve this.

01:16.890 --> 01:18.820
Let's go ahead and get started.

01:19.320 --> 01:24.870
All right so we know that we're going to need to create a count variable here and we'll know how to

01:24.880 --> 01:29.700
initialize that to 1 for this is my logic.

01:29.700 --> 01:33.710
Normally we would initialize our counts as 0 right Lauren doing something like that.

01:33.900 --> 01:37.990
But my logic in this instance needs to be initialized to 1.

01:38.280 --> 01:45.210
And so will go ahead and return count and count will always be at least 1 even if we pass zero and because

01:45.390 --> 01:48.000
it's going to take one more one iteration to figure that out.

01:48.000 --> 01:49.830
So we're a count.

01:49.830 --> 01:52.690
Next we're going to we don't know how many times are going to iterate.

01:52.740 --> 01:58.470
And when you don't know how many times it's going to iterate usually tells you like hey we need to do

01:58.470 --> 02:01.500
this either recursively or within a while loop or something like that.

02:01.590 --> 02:03.490
And that's what we're going to do here.

02:03.510 --> 02:09.990
So for every iteration that's in there we want to go ahead and increase count by 1.

02:10.360 --> 02:13.700
We also are going to have a unique Gnome's array.

02:13.720 --> 02:20.860
So it's going to create a contes unique number and we're going to initialize it with the value that

02:20.860 --> 02:21.680
comes in.

02:23.140 --> 02:25.200
Because that's unique No by itself.

02:25.280 --> 02:27.220
We want to go ahead and add that value.

02:27.520 --> 02:36.670
Now from there what we want to do is I created a function that I call a digit digit power and we're

02:36.670 --> 02:45.640
going to define this and digit power is going to take in a number just gone home and it's going to return

02:45.640 --> 02:46.990
a number.

02:47.710 --> 02:53.980
And within here what it's going to do is it's going to split it into a it's going to convert that number

02:54.040 --> 03:00.940
into a string is then going to split on each character and then it's going to map the parsed values

03:01.300 --> 03:06.820
of the parse values that were then going to take to the second power.

03:06.940 --> 03:11.890
Then we're going to add those numbers together and then return that number once we have that number

03:11.890 --> 03:17.050
we're going to check to see if it's a unique value in our unique numbers if it is we're just going to

03:17.050 --> 03:17.860
return count.

03:18.040 --> 03:23.020
If it's not we're going to go ahead and push that new value and just keep going until we're done.

03:23.020 --> 03:24.720
So let's go ahead and start.

03:24.940 --> 03:30.490
So you see here I have digits digits will be equal to the number we're passing in but just to make it

03:30.490 --> 03:37.480
into a a character trick we first have to split it on on each character like so and then we're going

03:37.480 --> 03:39.920
to map it.

03:40.700 --> 03:46.970
Now each element and what we want to do here is parse it as an end because we can't.

03:47.230 --> 03:52.960
We need to parses it in in order to turn it into a number array which will then reduce.

03:52.960 --> 03:56.820
And while we're at it we might as well just take it to the second power here.

03:56.830 --> 04:00.010
Now once we have that we can create are some here.

04:00.280 --> 04:03.690
And you're asking me like why didn't we do this all in one sitting.

04:03.850 --> 04:08.770
We could have but it's sort we've sort of reached the point where typically this is I don't really want

04:08.770 --> 04:10.090
to go more line wise.

04:10.180 --> 04:16.200
And also it it someone delivers a point of what we're trying to do.

04:16.200 --> 04:17.880
It's not the best example of what we do.

04:18.120 --> 04:24.480
We could do better and all we're going to do here is reduce it into a single number again and just do

04:24.510 --> 04:30.300
a b and b a plus be excellent.

04:30.300 --> 04:32.750
And then we're going to return the sum.

04:32.800 --> 04:36.510
So what we found our value multiplied and done all that.

04:36.660 --> 04:42.300
What we're going to have here with an count is we're just going to reset the value of EOE to a new number

04:42.600 --> 04:46.620
which will be the digit power of the AOH current value.

04:47.040 --> 04:55.770
Now once we have that we're going to check if the unique numbers includes

04:59.790 --> 05:02.990
Eva meaning does it already have this value.

05:03.030 --> 05:06.670
If it does we just want to return count we're done at this point.

05:06.900 --> 05:14.790
If it doesn't after the fact we can go ahead and take unique numbers and push a new value onto it.

05:14.880 --> 05:17.850
And that's just going to be the age of 0 that we just returned.

05:18.480 --> 05:19.390
That's pretty much it.

05:19.400 --> 05:20.470
At the end of the day.

05:20.580 --> 05:23.230
So quite a bit going on here.

05:23.340 --> 05:29.820
And I think it is good code good sort of is much more readable when we break out this logic where we

05:29.820 --> 05:37.380
could do a better name job naming this name and this but I do this about 10 minutes so I just knocked

05:37.380 --> 05:39.250
it out.

05:39.720 --> 05:46.650
So we iterate until we find a duplicate number the number we are we are turning into a string split

05:46.650 --> 05:53.340
into a character a we then map a new array that has a the squared value that we were then parsing the

05:53.340 --> 05:53.660
end.

05:53.880 --> 05:56.000
And then we reduce it to a single number.

05:56.130 --> 05:57.540
We return it.

05:57.540 --> 06:00.070
We check if it's already in our unique number array.

06:00.180 --> 06:01.580
No need for that spacing.

06:01.650 --> 06:04.330
And then we if it is we return it we're done.

06:04.350 --> 06:09.030
If it's not we add the values we continue on and we can actually take out return count here it never

06:09.030 --> 06:09.910
gets called.

06:09.980 --> 06:13.000
So pretty cool stuff.

06:13.500 --> 06:14.140
That's it.

06:14.800 --> 06:17.850
The but you don't Subodh tootle.
