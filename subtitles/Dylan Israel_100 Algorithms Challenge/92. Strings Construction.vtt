WEBVTT

00:00.710 --> 00:01.570
All right.

00:01.580 --> 00:07.950
So strings construction this was a really fun one mainly because it was a lot more code and I had to

00:07.950 --> 00:10.370
write a second function to handle it.

00:10.740 --> 00:16.230
But anyhow so what we're going to do here is have to shrink some string and a string B and we're going

00:16.230 --> 00:23.130
to find out how many times we can build string based off the characters that are available in the string

00:23.130 --> 00:23.620
B.

00:23.760 --> 00:27.130
So in the ABC you'll see we have one a or two.

00:27.150 --> 00:32.020
So that's two then two views and to see so we can build it exactly twice.

00:32.070 --> 00:33.560
That's what we're trying to find out here.

00:33.620 --> 00:38.830
What is the amount of strings we can extract from one string compared to the other.

00:38.850 --> 00:50.100
Now in our example here we have five properties I use has one property push Matt but floor matt thought

00:50.100 --> 00:51.290
Man and split.

00:51.360 --> 00:53.140
So quite a bit going on here.

00:53.140 --> 00:55.060
I did really enjoy this though.

00:55.200 --> 00:56.910
So let's go ahead and

00:59.640 --> 01:01.560
and get started.

01:01.560 --> 01:02.240
All right.

01:02.280 --> 01:10.380
So the way that I solve this was first I went ahead and I got a total count of the values in string

01:10.380 --> 01:11.640
A and string beer.

01:11.640 --> 01:14.550
So we'll start there.

01:14.760 --> 01:17.530
We're going to create these variables.

01:17.640 --> 01:23.010
Well call this a count and then we'll create this Rail's or call those be counted and then we assign

01:23.010 --> 01:23.370
the values.

01:23.370 --> 01:29.040
Now because of the logic in here being duplicated what I'm going to do is I want to write a secondary

01:29.040 --> 01:29.810
function here.

01:30.060 --> 01:38.100
And normally in if I was doing this and in typescript like a class Id be a private access modifier not

01:38.100 --> 01:41.040
public function but just wanted to mention that.

01:41.040 --> 01:41.680
So.

01:41.760 --> 01:49.300
So this is going to be alphabet count and we're going to take in a string here like so.

01:49.350 --> 01:53.060
All right and well we're going to do is we're going to split that string first.

01:53.090 --> 02:00.220
So we're going to go and just call this close Chara's be the word refastened split.

02:00.840 --> 02:07.680
And next we're going to create a object that we are then going to map the keys as well as a count to

02:07.680 --> 02:08.400
those.

02:08.400 --> 02:17.280
So we go ahead and create our alphabet count and this will just be set to an empty object.

02:17.490 --> 02:22.410
Now that we've done that we're going to iterate through all our chars and then just use a For Each for

02:22.410 --> 02:25.690
this char.

02:25.700 --> 02:31.080
You can also of course use a form of a regular for loop and then eventually what we're going to do is

02:31.080 --> 02:36.240
run return that alphabet count which is going to be our object with all the cues and values that we

02:36.470 --> 02:37.050
try.

02:37.220 --> 02:43.470
How are we going to get the cues or values simply with them are a ternary here where we're going to

02:43.470 --> 02:49.250
say alphabet count.

02:49.550 --> 02:51.620
Actually no no journey will do.

02:51.960 --> 02:55.540
If else is a little bit too much alphabet counts kind of a long way.

02:55.700 --> 03:00.560
So we're going to say alphabet count dot hands on property.

03:01.010 --> 03:07.730
So if that is true of that char that we're checking the character where are you going to say alphabet

03:07.730 --> 03:10.510
count already exist with that value.

03:10.520 --> 03:14.390
And so we're just going to add 1 to it.

03:14.390 --> 03:22.370
Else we're going to go ahead and take alphabet count for the key that doesn't exist or that character

03:22.790 --> 03:23.640
of our count here.

03:23.660 --> 03:25.720
And we're going to set it to 1.

03:26.600 --> 03:31.510
So you'll see here if we just do this now and when we go ahead and call get Alf.

03:31.580 --> 03:32.040
Whoops.

03:32.120 --> 03:40.160
Well they're good alphabet count only pass a C will give us the value when we see it.

03:43.250 --> 03:51.200
So without long it just to get an idea she'll see we're actually getting an object with our cues which

03:51.200 --> 03:55.820
are characters and our values which are the count of those letters.

03:56.130 --> 03:58.170
And we're in the same exact thing for B count.

03:58.170 --> 04:01.990
Now we just copy this

04:06.460 --> 04:09.440
and swap an R B string.

04:09.460 --> 04:17.140
So now that we have those counts what we're going to do is we are going to in our eight count because

04:17.140 --> 04:21.730
that's what we care about we want to find out how many characters for each.

04:21.880 --> 04:26.020
How many characters in our string exists in our BE string for all the values and we're just going to

04:26.020 --> 04:27.870
push those values to an array.

04:28.180 --> 04:30.400
And then we're going to get the main value out of that.

04:30.430 --> 04:33.220
And that will be the amount that we can create.

04:33.220 --> 04:33.460
Right.

04:33.460 --> 04:37.930
So if there's two ways to be to seize it that works to return to.

04:37.930 --> 04:46.090
But if there's three C's to A's one B we're going to return 1 because in you know ABC There is only

04:46.090 --> 04:51.820
enough characters for for all three of those for the one or it's going to be the lowest of value.

04:52.360 --> 04:59.590
So now in our string's construction what we're going to do is we're in a a contest here and this is

04:59.590 --> 05:08.650
going to be called this divisors but there's a kind of a bad name we'll call this counts.

05:08.950 --> 05:10.310
What is zero.

05:10.780 --> 05:11.130
All right.

05:11.170 --> 05:12.560
And then what are you going to do.

05:12.640 --> 05:20.630
We're going to iterate through we say let char in a count because remember we have a.

05:20.800 --> 05:29.050
This is an object that we're iterating through the Keys in that object and say if B count has own property

05:29.710 --> 05:40.390
char the key or the character in our string what we want to do is we want to go ahead and say divisors

05:41.830 --> 05:47.890
or recounts dot push and we're going to take math off floor here.

05:47.890 --> 05:51.500
The reason for it is sometimes serviette uneven amount.

05:51.700 --> 05:58.860
And we're going to get that character value divided by that the count divided by the char count.

05:58.870 --> 06:13.560
So we're talking about floor say count the character that exists divided by a count that exists.

06:13.620 --> 06:20.020
Now tell us how many of those characters that we can have so like maybe there's two ways in string a

06:20.370 --> 06:21.630
where and they have four.

06:21.640 --> 06:26.290
This will give us the fact that now there is actually two complete strings we can build based off that

06:26.290 --> 06:30.830
letter now else meaning it doesn't have that character at all.

06:30.850 --> 06:35.440
We're just going to return 0 because we're done here.

06:35.440 --> 06:42.650
It's missing a character in our string B and thus we can never have any creation's based off that.

06:43.090 --> 06:50.980
And finally now that we have all of our values here in our array all we have to do is return the smallest

06:50.980 --> 06:55.570
one because that means it exists for all the characters or say math doesn't mean.

06:55.660 --> 07:02.430
And then we can just unwrap this counts and return our value and we're done.

07:02.440 --> 07:04.390
So we get are two that are there.

07:04.390 --> 07:09.250
So quite a bit going on this is not just a little bit and go over our logic.

07:09.250 --> 07:17.590
We create a function that's going to make an object of our count of characters for each string and return

07:17.590 --> 07:22.720
that and that's the first part we then have an array that we're going to store values in here we're

07:22.720 --> 07:28.150
going to iterate through the count the eight count or the string that we are going to be matching to

07:28.510 --> 07:34.890
and say look those are string that we're matching from B have that character.

07:34.930 --> 07:40.870
If it does we're going to figure out how many of those that we can create and we have to floor it because

07:40.870 --> 07:43.270
it may not be divided evenly.

07:43.270 --> 07:46.340
If it doesn't have that character at all we're going to return 0.

07:46.420 --> 07:52.030
Once we have all the character counts based off a and b we're in turn the smallest one because that

07:52.030 --> 07:54.750
will be how many we can evenly Karaite.

07:54.760 --> 07:56.380
So I like this one quite a bit.

07:56.390 --> 07:57.570
A lot of fun.

07:57.710 --> 08:07.150
On a side note I am I actually had this in a I had a I had this exact problem in a sort of like a for

08:07.360 --> 08:15.310
technical interview and I finished it because I I saw it instantly and I was going to do this and they

08:15.310 --> 08:21.640
made me an offer for sixty seven dollars an hour for a contract for all which is you know when you knock

08:21.640 --> 08:25.260
out these technical interviews they do very well.

08:25.570 --> 08:27.260
But you know that's just a side note.

08:27.260 --> 08:35.080
But also we should probably assign a type here which is just going to be an object to communicate.

08:35.080 --> 08:39.370
So it's kind of a fun one for me anyhow.
