WEBVTT

00:00.540 --> 00:06.000
All right guys check palindromes So here we're going to find out is this actually a palindrome or not

00:06.000 --> 00:11.480
a palindrome is defined as a string lays the same forward as it is backwards.

00:11.490 --> 00:17.310
Some examples here a B.A.A. would be true right because we could flip this still be the same thing A

00:17.310 --> 00:21.250
B A C would be false because if we flipped it it wouldn't be the same.

00:21.270 --> 00:25.820
And then a if we flush it would be true because a bit silly.

00:26.130 --> 00:33.930
So some hints for how I solve this I use to lower case split reverse and join although you could eliminate

00:34.440 --> 00:38.040
the three of these for the most part and just use a for loop.

00:38.170 --> 00:39.730
Couple different ways we can do this.

00:39.990 --> 00:41.990
Let's go ahead and jump into it.

00:42.000 --> 00:47.490
All right so the first thing that we're going to want to do is understand that palindromes are not case

00:47.490 --> 00:53.560
sensitive and you typically want to handle that so you can either use to lower case or to upper case

00:53.940 --> 00:56.190
on the forward and backward word.

00:56.190 --> 00:59.630
In my case I just used to lowercase.

01:00.030 --> 01:02.880
It's not case sensitive unless someone says it is.

01:03.030 --> 01:08.280
I guess but most of the time I come from is not defined as being case sensitive and take her input string

01:08.330 --> 01:12.590
oriented to lowercase it.

01:12.810 --> 01:14.820
OK so now we're going to have that.

01:15.030 --> 01:23.340
And what we're going to have is our reversed word here which for now I'm just going to return a string

01:23.640 --> 01:28.260
which is going to be the original location so that we could see as it's happening here and then say

01:28.290 --> 01:33.900
hey let's go ahead and take what actually we can eliminate lower case because we've already had that

01:34.470 --> 01:35.150
on our string.

01:35.270 --> 01:40.000
Well let's go ahead and split this into an array of values on each character.

01:40.020 --> 01:45.930
So now you see it split and then we're going to go ahead and say hey let's go in or reverse this because

01:45.930 --> 01:48.840
we want to get the reversed values.

01:48.840 --> 01:53.780
Now let's go ahead and then join it back together and each individual character gets stringing.

01:54.000 --> 01:58.180
So now we know that hey this is how we're going to reverse our word.

01:58.200 --> 02:05.080
Let's just go ahead and cut this and we'll go ahead and call this contest

02:08.060 --> 02:12.760
or word and set it equal to that.

02:13.360 --> 02:18.820
And all we have to do here is just compare the two and see hey was our original non-sexually changes

02:18.820 --> 02:19.930
to original word

02:22.700 --> 02:24.690
that makes more sense.

02:24.740 --> 02:31.520
Original Word isn't exactly equal to reversed word.

02:31.950 --> 02:35.640
And let's fix this area.

02:35.910 --> 02:41.140
And so you'll see here everything passes because we're lowercase them both in both senses.

02:41.190 --> 02:46.770
Because we're targeting this where and then we break it up into a character and reverse that array and

02:46.770 --> 02:52.680
then we join it back together and each individual character and we just make a simple comparison.

02:52.860 --> 02:59.730
You could solve this other way by having a for loop where your decorating backwards and essentially

03:00.540 --> 03:08.150
you have a two two values keeping track of the first one would be the one the incrementing the second

03:08.150 --> 03:12.220
one with one decrementing and then you just keep going and checking those same values.

03:12.230 --> 03:16.880
And if at any point there night when you hit the halfway point you break it.

03:16.920 --> 03:18.900
It's false or true and false.

03:19.260 --> 03:20.850
So that's another possible solution.
