WEBVTT

00:00.920 --> 00:07.710
Are right add two digits so they'd be active here is we're going to take in a two digit integer such

00:07.710 --> 00:09.010
as 29.

00:09.180 --> 00:14.100
And what we want is we want to return some of those digit.

00:14.100 --> 00:20.080
So 29 when we add a 2 and a 9 returns 11 if we have a 11.

00:20.130 --> 00:22.750
It's going to return a to right one plus one.

00:22.800 --> 00:23.790
That's what we want to do.

00:23.790 --> 00:25.890
Here are some ways that I solve this.

00:25.950 --> 00:29.720
I use split parts to string and reduce.

00:29.790 --> 00:35.670
But looking at this in a little bit more detail you could probably eliminate the reduce since our objective

00:35.670 --> 00:43.650
here and asked for just the two digit integer but we'll go ahead and do my solution with Reduce for

00:43.650 --> 00:45.230
the time being.

00:45.260 --> 00:45.850
All right.

00:45.860 --> 00:52.310
So we're getting a number in from here right now I'm using any because my test lane doesn't like my

00:52.310 --> 00:53.150
solution.

00:53.210 --> 00:55.520
So what.

00:56.090 --> 00:57.070
Well quite TS-Aligner.

00:57.080 --> 00:58.360
So you just put it in there.

00:58.540 --> 01:03.870
Well we are getting a number and we're expecting to return a number the way I went about this was it

01:03.950 --> 01:05.410
is variable Nomes.

01:05.410 --> 01:12.990
And what we're going to do is we're going take that number or invert it to a value of essentially of

01:13.910 --> 01:16.000
strings a string of numbers.

01:16.010 --> 01:24.740
So we're taking and we're going to go Toops two and two string and then we're going to split it on each

01:24.740 --> 01:26.760
one of those values.

01:27.020 --> 01:30.750
Now that we have that all we have to do is call reduce.

01:30.750 --> 01:40.850
So we're getting non-stock reduce and in here we're going to get a which is going to be a string or

01:41.150 --> 01:47.450
B which will be a string as well so this is going to be essentially our accumulator from over correctly.

01:47.450 --> 01:50.130
So this we keep track and this is going to be the number we're going to have.

01:50.210 --> 01:54.410
That's really at the end of the day for a reduce for how are you using anyhow.

01:54.920 --> 02:03.070
And what we're going to do here is we're right turn and go ahead and turn go on.

02:03.410 --> 02:11.090
We're going to see right now we have identified we were in turn a plus b but because there strings is

02:11.090 --> 02:14.270
just going to concatenate them back together right.

02:14.270 --> 02:14.950
We don't want that.

02:14.950 --> 02:17.680
We want them to actually treat it as numbers.

02:17.910 --> 02:24.800
And so we're going to parse it a plus parse and B.

02:24.860 --> 02:26.760
And now we get 11.

02:26.810 --> 02:27.290
So pretty.

02:27.290 --> 02:27.830
All right.

02:27.890 --> 02:29.820
So just go over the logic one more time.

02:29.840 --> 02:36.830
We're taking a number we're converting into an array of characters at the end the day after we convert

02:36.830 --> 02:37.900
it to a string.

02:38.120 --> 02:44.180
We're then iterating through that array and then parsing the integers out which they all are and then

02:44.180 --> 02:45.170
adding them together.

02:45.170 --> 02:49.540
Now we could do parsing a plus be something like this.

02:49.730 --> 02:52.250
And now after reading the questions that would be fine.

02:52.250 --> 02:54.930
So we do something like parse and a

02:58.740 --> 02:59.910
percent.

03:00.210 --> 03:05.520
Gnome's 0 rather plus S.

03:08.620 --> 03:10.210
is 1.

03:10.410 --> 03:11.930
And that works as well.

03:11.980 --> 03:18.010
So just that's honestly looking at this this is probably a cleaner solution for this product for this

03:18.010 --> 03:20.160
application for this algorithm.
