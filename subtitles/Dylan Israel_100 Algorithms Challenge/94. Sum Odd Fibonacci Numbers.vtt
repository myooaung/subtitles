WEBVTT

00:00.210 --> 00:09.360
All right some all the fibs Banaji numbers so in our example let's say we take in a single input of

00:09.360 --> 00:14.820
a number we're going to get a sum of all the Fibonacci numbers.

00:14.850 --> 00:19.770
Not Shinners are defined as essentially adding the numbers.

00:19.770 --> 00:22.900
So we go 0 and then we go 1 9 0 1 to 1 which makes two.

00:22.940 --> 00:28.290
Then we go to and one which makes 3 2 and 3 which ranks 5 and then eight and then we only want to add

00:28.290 --> 00:29.900
the odd values.

00:30.000 --> 00:36.230
So 1 1 3 and 5 to return 10 or 10 input and then we have some other examples here.

00:36.330 --> 00:37.390
As test cases.

00:37.500 --> 00:41.580
So that's our objective and all of the odd Fibonacci numbers.

00:41.640 --> 00:42.570
I don't have any answers.

00:42.610 --> 00:43.850
It is pure logic one.

00:43.920 --> 00:45.710
Let's go ahead and jump into it.

00:46.210 --> 00:51.600
All right so what we have to understand here is we sort of need three variables and this is the hardest

00:51.600 --> 00:55.010
part just understand how many variables we need to keep track of our items.

00:55.020 --> 00:56.750
We need one for our previous number.

00:56.910 --> 01:04.010
We need one for our current number and we need four and for a result to return.

01:04.020 --> 01:06.810
So let's start there with our result.

01:07.230 --> 01:13.020
So create a result initialises 0 at the end of what we really want to do is return that result we're

01:13.020 --> 01:14.320
going to modify that.

01:14.400 --> 01:16.720
We then need one for our previous number.

01:16.740 --> 01:17.100
So

01:20.310 --> 01:26.940
previous pre-WWI for use this on and we'll go ahead and say that zero.

01:27.060 --> 01:30.990
And then we'll go ahead and say let current equal to 1.

01:30.990 --> 01:32.690
So we are initialising at 1.

01:32.820 --> 01:35.970
If you're able to get this far you probably understand what to do next.

01:35.970 --> 01:43.190
So we need to iterate through our Fibonacci numbers or up to our current No.

01:43.380 --> 01:54.960
So while our current number or current is less than or equal to our income that we're passing then we

01:54.960 --> 01:57.300
need to do some stuff.

01:57.450 --> 02:02.160
The first thing that we can do is we can find out if it's evenly divisible because we don't want to

02:02.160 --> 02:08.290
return those items that are divisible by by 2 right.

02:08.430 --> 02:18.090
So we can take our current value and we can modify 2 and if it equals equals zero mean not as equals

02:18.240 --> 02:19.200
equals zero.

02:19.350 --> 02:21.000
Meaning it's odd.

02:21.270 --> 02:29.670
We in fact can just say look our result is equal to our current number.

02:29.670 --> 02:35.160
Now if it's not we're not worried about it we're just not going to add the result.

02:35.160 --> 02:42.480
So we're going to handle some cases here where we're going to say hey instead previous number previous

02:42.900 --> 02:50.270
will be equal to current number plus previous.

02:50.520 --> 02:51.690
Now that we have that

02:54.450 --> 02:57.640
excuse me I'm sorry a previous number is equal to our current number.

02:57.930 --> 03:08.340
And then our current number will be equal to our previous number plus and if I did these out of order

03:08.340 --> 03:09.090
I think.

03:09.420 --> 03:15.460
So let's see where am I going wrong here.

03:15.480 --> 03:16.470
So this

03:19.950 --> 03:22.760
oh I see what I forgot to add a variable.

03:22.900 --> 03:30.350
So this is where I got tricked up last time where I was going to just create a contest here called him.

03:31.800 --> 03:37.920
And this is going to be our new value and this is going to be equal to our current plus our previous

03:37.920 --> 03:39.950
number before we modify them.

03:40.290 --> 03:43.580
That's where I got tricked up again this twice now.

03:43.710 --> 03:44.620
Shame on me.

03:44.850 --> 03:46.790
So our added value.

03:47.350 --> 03:48.160
How like the name.

03:48.170 --> 03:51.900
I did our previous current.

03:51.990 --> 03:57.930
A very strange way of new current new current.

03:57.930 --> 04:01.430
There we go next great.

04:01.440 --> 04:03.180
How what next great next year is much better.

04:03.180 --> 04:05.000
So next our next screen value.

04:05.220 --> 04:10.370
We're going to go ahead and set previous though first or answer that equal to current.

04:10.440 --> 04:13.070
This is going to update to the latest rally now.

04:13.140 --> 04:17.940
Now we can update current to be equal to our next current.

04:18.390 --> 04:20.000
And there we go.

04:20.040 --> 04:27.530
So I've got to say moosic I was getting I have my notes so easy here.

04:27.660 --> 04:32.180
The idea is we have three variables one to two put the result in one to serve the previous value of

04:32.180 --> 04:35.370
one to store the current value run through it.

04:35.370 --> 04:43.140
Why we're doing it at only the odd numbers and then keep track of the current plus the previous and

04:43.140 --> 04:46.380
then reset those values or update those values.

04:46.380 --> 04:50.150
I should say when you break out just returning a lot of stuff going on here.

04:50.190 --> 05:00.300
But I think this is a really good sort of mid low mid-tier algorithm problem that you probably could

05:00.300 --> 05:02.870
see in an actual technical interview.
