WEBVTT

00:00.540 --> 00:07.940
Alphabetic shift is a great algorithm and just I found I had a lot of fun with this one.

00:07.950 --> 00:14.100
So what we're going to be doing here is we're going to take in a single input string such as crazy and

00:14.100 --> 00:19.170
then we are going to shift everything forward forward by one letter.

00:19.170 --> 00:21.000
Hence the name alphabetic shift.

00:21.060 --> 00:26.600
So our C is going to become a dear r is going to become a s a b easy way.

00:26.760 --> 00:29.090
And why is the how I did it.

00:29.130 --> 00:33.860
I use split index of and join in.

00:33.870 --> 00:35.580
So these are hints.

00:35.580 --> 00:38.910
I've actually already thought of a better way of doing this since I originally solved it.

00:38.910 --> 00:43.350
We'll talk a little bit about that in the solution.

00:43.350 --> 00:43.880
All right.

00:43.890 --> 00:51.640
So the way that I solve this was I created a string array in which I stored a single character from

00:51.660 --> 00:53.460
English alphabet A to Z.

00:53.630 --> 00:57.220
So I'm going to just go ahead and copy that over.

00:57.300 --> 01:03.410
So we don't have to see everything that's going on here and I'll word wrap so that you can see it here.

01:03.450 --> 01:07.330
So we're going all the way A.D.C. and comments.

01:08.130 --> 01:09.680
And we're not we're not going to modify.

01:09.720 --> 01:21.300
And what I want to do here is I'm going to create this string called Let input input shifted and this

01:21.300 --> 01:23.890
is going to be equal to my cats and jump in.

01:23.940 --> 01:28.500
So this is going to be equal to our input string

01:32.730 --> 01:36.680
and then we're going to split it on each individual character like so.

01:37.580 --> 01:40.190
And there's no reason for this line here.

01:40.330 --> 01:48.480
So we now have it split up from here the way that I did my thinking was that I'm going to check that

01:48.480 --> 01:56.640
value and if it's not equal does Z I'm going to get the index of that value and reset it plus 1 if it

01:56.730 --> 01:57.880
is equal to Z.

01:57.890 --> 02:00.410
I'm just set it to zero index to be a.

02:00.570 --> 02:05.360
Because that's the only one where loose background everything else is just going one one forward.

02:05.670 --> 02:06.610
So let's start there.

02:06.630 --> 02:07.770
So say let.

02:07.960 --> 02:09.410
Is equal to zero.

02:09.580 --> 02:18.430
I's less than R and put shifted doesn't really matter if it's input shifted or input string will say

02:18.580 --> 02:21.120
input shifted I plus plus

02:24.470 --> 02:32.370
all right now that we're there we're going to create a constant called index vowel we're on the actual

02:32.860 --> 02:38.460
reading this yeah we do index and we're this equal to zero.

02:38.460 --> 02:40.470
So by default it's going to be equal to zero.

02:40.680 --> 02:46.980
So we're here we're into is for us hey input shifted actually let's not do this out of order.

02:46.980 --> 02:48.690
What are you using.

02:48.690 --> 02:53.580
We're going to have a statement here that's going to check the character we're going to say is our input

02:54.750 --> 02:56.220
shifted.

02:56.220 --> 02:59.290
Z for instance.

03:00.970 --> 03:02.610
Excuse me.

03:02.710 --> 03:05.040
Why not equal equal to Z.

03:05.230 --> 03:13.330
If it's not what we want to do in this case all our values are are lower case on our input string and

03:13.330 --> 03:19.140
we're not worried about uppercase values but if we were we would have two to uppercase or two lowercase

03:19.170 --> 03:21.410
in effect our logic here.

03:21.970 --> 03:23.160
Now if it's not equal to Z.

03:23.200 --> 03:32.980
What we know is that index value is equal to our alphabet index of which is going to return the index

03:32.980 --> 03:37.450
value for our the value that we're checking

03:41.510 --> 03:43.290
and then we're going to add 1 to that

03:46.240 --> 03:48.960
assuming that changes index.

03:49.540 --> 03:52.040
Now that we have that for one it's not easy.

03:52.240 --> 03:57.610
And we've already initialized it to zero which would be the same value we would use for Z.

03:57.610 --> 04:08.000
All we have to do here is go and say input shifted is equal to alphabet Plus the index value which is

04:08.000 --> 04:12.570
going to be one more so you can shift it.

04:13.640 --> 04:14.540
And at the end here.

04:14.630 --> 04:20.960
Now that we've modified the array Oh do is join it back together and we're in turn our shifted array

04:23.100 --> 04:28.610
and joined them back on every character and that should worked.

04:28.770 --> 04:30.970
Where is our air in our logic here.

04:30.990 --> 04:32.550
Sort of index index of

04:35.520 --> 04:41.660
trowing which shift to it in the

04:46.320 --> 05:06.650
put 50 plus plus.

05:07.380 --> 05:10.260
Well that's fine.

05:10.270 --> 05:10.690
Interesting.

05:10.760 --> 05:12.790
So I have an error somewhere.

05:15.780 --> 05:17.800
It puts strain and put shifted

05:22.900 --> 05:26.570
for false and false and

05:32.310 --> 05:33.750
where is our air.

05:34.350 --> 05:34.860
All right.

05:34.860 --> 05:40.680
On further review I made a simple mistake here where we get the index of value over alphabet and then

05:40.680 --> 05:45.730
we just add one because we're not actually looking to get that index at character at this time.

05:45.930 --> 05:51.660
Or instead just looking to get the index of that and then we shift.

05:51.690 --> 05:57.750
And now we're good to go just a little bit of typing too fast for my own good.

05:57.810 --> 05:59.160
So we'll be like that.

05:59.160 --> 06:01.380
Let's go ahead and move on to the next one.

06:01.380 --> 06:01.740
All right.

06:01.740 --> 06:08.610
I'd mentioned that there is a way to actually make this faster depending on how we we did that and the

06:08.610 --> 06:10.380
way that we could do it just right here.

06:10.380 --> 06:16.720
We're having to look up every single element in this array with this index of We're reiterating through

06:16.720 --> 06:20.100
that now in something with 26 characters.

06:20.100 --> 06:27.480
It's not the biggest deal but it is a very easy way that we could fix this by instead of having an alphabet

06:27.480 --> 06:28.500
like this.

06:28.660 --> 06:35.790
And I haven't done this yet but so we'll type it out is we are instead going to just have an object.

06:35.790 --> 06:42.570
And the reason that this is going to be faster is that when there are property keys in our case we're

06:42.570 --> 06:51.930
going to essentially create a object that we then say is going to be equal to B B will b c Let's continue

06:51.930 --> 06:53.140
on.

06:53.160 --> 06:54.060
C is

06:57.230 --> 06:58.920
Susan D.

06:58.930 --> 07:02.240
We're going to create a dictionary essentially.

07:02.320 --> 07:02.860
And

07:05.800 --> 07:09.010
when we target this property we're going to set it to this value.

07:09.220 --> 07:14.830
And this is a much faster way of doing this because we don't have to iterate through an array.

07:14.830 --> 07:18.780
So I'm going to posit video type out a to z and the fix arko.

07:18.970 --> 07:19.320
All right.

07:19.330 --> 07:21.550
Now that we have this very long.

07:21.580 --> 07:33.250
Ada Z back to a alphabet all we're going to do here is we're going to delete what's in here.

07:35.130 --> 07:45.090
And now we're going to modify our string ever so slightly Surace input shifted on that index value is

07:45.300 --> 07:49.140
equal to our alphabet.

07:49.140 --> 07:53.010
And then we're just going to pass in the input shifted value

07:58.130 --> 08:00.040
and that's going to be the key.

08:00.050 --> 08:06.380
Now let's go ahead and just cancel the log and put shift it just so that we can see it right because

08:06.380 --> 08:10.510
we changed a lot and you can see we get the C.

08:10.520 --> 08:14.360
And so that C is going to return the value of D.

08:14.550 --> 08:16.540
The Z is going to return the value of a.

08:16.670 --> 08:20.610
Now there's a third way we can do this using ASCII.

08:20.660 --> 08:25.820
But I have several other ASCII algorithms coming up and you can do that on your own if you find that

08:25.820 --> 08:26.510
helpful.

08:26.510 --> 08:32.300
This is a faster algorithm but even they ask evaluate ask you solution would be a better solution than

08:32.300 --> 08:33.290
what we have here.
