WEBVTT

00:00.930 --> 00:05.790
All right sort by heit was a fun problem to dive into.

00:05.790 --> 00:09.740
We're going to be taking in a number array and some values.

00:09.780 --> 00:14.490
Most of those will be positive but we'll have these negative ones when we want to do is you want to

00:14.490 --> 00:19.890
sort the array numerically ignoring the negative ones we aren't the negative ones that stay in their

00:19.890 --> 00:23.440
index pots they never move but the rest of the array gets sorted.

00:23.430 --> 00:28.130
So 150 160 170 and then these were the original indexes of negative 1.

00:28.140 --> 00:32.820
So we don't touch those and then 180 190 that that's our objective here.

00:32.910 --> 00:34.560
I use filter and sort for this.

00:34.560 --> 00:36.010
That's really your only hint.

00:36.090 --> 00:42.740
But for the most part this is a pure logic logic array manipulation type algorithm.

00:42.750 --> 00:48.860
All right so the way that I did this was I created a new array based off our input.

00:48.870 --> 00:56.310
I filtered it where I ignored if there was a need of one.

00:57.260 --> 01:01.500
And if it was me it was not equal a negative one.

01:01.500 --> 01:06.720
I returned the value if it was I just left it there and I didn't filter anything.

01:06.720 --> 01:08.900
Meaning that it just stays same.

01:08.910 --> 01:12.100
Now I sorted it numerically for those values.

01:12.210 --> 01:17.280
So we were only sorting and filtering the values that exists basically So we're ignoring the negative

01:17.280 --> 01:19.080
one values in our new array.

01:19.100 --> 01:25.730
Then I keep track of an index Val where this is for the original length of the array.

01:25.770 --> 01:31.680
And here we just then if it's if our original value in that index was negative then we're going to overwrite

01:31.680 --> 01:33.160
it with our current index value.

01:33.240 --> 01:34.720
That's all that we had to do here.

01:34.770 --> 01:39.960
So let's greenery and we'll just call this I call this array to an awful name.

01:40.110 --> 01:49.490
But we're going to say our original array filter and then the the element that we're filtering on.

01:49.890 --> 01:50.160
All right.

01:50.180 --> 02:01.050
And in here what we basically want is an array that we want an array that we are not going to.

02:01.500 --> 02:04.060
That's not going to have those negative ones functions.

02:04.230 --> 02:10.410
So we're just going to check if x is not equal equal to negative one or element or rather it's just

02:10.440 --> 02:14.090
my original I call it x.

02:14.210 --> 02:21.180
If it's not equal legal name of one going to return that element.

02:21.230 --> 02:24.980
So now that we've filtered our array to ignore all the negative ones.

02:24.980 --> 02:32.000
Now what we want do is we want to go ahead and sort that array numerically and so we can just call this

02:32.220 --> 02:35.390
one too.

02:36.250 --> 02:37.900
And then here we're seeing turn.

02:37.920 --> 02:40.580
Hey might this be or.

02:40.620 --> 02:46.050
No one to try and do better with the naming as we're going on here so.

02:46.550 --> 02:50.380
So we're going to sort those numerically from least the greatest.

02:50.540 --> 02:53.180
So we filtered and sort sorted the values.

02:53.310 --> 02:58.660
Next what we're going to do is create an index Vout initialize it to zero.

02:58.670 --> 03:03.290
The reason for this is eventually all we're going to do is actually return the original array that we've

03:03.290 --> 03:08.350
modified here but it hasn't been sorted yet.

03:08.700 --> 03:13.670
And zoom out a little bit so we can see the full array the way that we're going to do that is we're

03:13.670 --> 03:20.600
going to iterate through these index values the entire railhead of our original input

03:26.520 --> 03:27.820
plus plus.

03:28.730 --> 03:35.750
And we're going to have this issue which is where if AI is not exactly equal negative 1 mean it's not

03:35.760 --> 03:40.280
one of those placeholders SWAT's what we want to do is we want to take Eva.

03:40.360 --> 03:49.730
And we want to set that value equal to our array to value our filtered sorted array and go ahead and

03:49.730 --> 03:55.580
pass in the index value because now we know which number to pass in and all we do here is just increment

03:55.640 --> 03:59.530
index fell by one every iteration.

04:00.250 --> 04:04.440
See index is not defined.

04:05.960 --> 04:10.780
This is equal equals zero.

04:10.900 --> 04:13.920
I just listen.

04:14.230 --> 04:14.760
There.

04:14.940 --> 04:15.780
And now we're done.

04:15.870 --> 04:21.810
So basically the logic was first sort and filter all the numbers that are negative one right here.

04:21.930 --> 04:30.300
After that keep track of an index value of reference to this where if the value in the original completed

04:30.300 --> 04:35.650
array which we haven't sorted or filtered is not equal to the negative one then what we wanna do is

04:35.640 --> 04:40.830
we want to overwrite that spot with the current sorted and filtered value and then increment by 1 so

04:40.830 --> 04:42.940
that we can get it in the correct order.

04:42.960 --> 04:43.840
That's pretty much it.

04:43.850 --> 04:51.780
I think I found that this was a this is a type of algorithm I like in terms of that is not overly convoluted

04:51.930 --> 04:56.850
but it does sort of you know there's multiple ways to solve it I guess is why I like about it.
