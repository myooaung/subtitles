WEBVTT

00:00.570 --> 00:03.740
All right guys we have a very special algorithm.

00:03.900 --> 00:10.160
This is you you wouldn't know this unless I told you but this is actually algorithm one hundred.

00:10.170 --> 00:16.140
So we have made it on my end to recording all of the algorithms.

00:16.140 --> 00:16.920
It took a minute.

00:16.920 --> 00:17.880
It really did.

00:18.030 --> 00:22.750
So our objective here is we want to flatten a nested array.

00:22.890 --> 00:25.010
We don't care how nested it is.

00:25.020 --> 00:25.690
So what does it mean.

00:25.710 --> 00:33.280
Well taking our steamroller right here I'm probably and change just flatten but oh we'll roasting we're

00:33.310 --> 00:34.960
all ready.

00:35.580 --> 00:37.950
But you'll see that we have all these nested arrays.

00:37.950 --> 00:45.420
All we really want are the values in them where they can be you know steam roller one raid to try and

00:45.520 --> 00:46.620
get one two three four.

00:46.650 --> 00:52.100
I will say that I believe there is a function that is sort of an alpha development called Fly and that

00:52.110 --> 00:52.840
will do this.

00:52.860 --> 00:53.970
That's not the objective here.

00:53.970 --> 00:55.490
We're not trying to you fine.

00:55.530 --> 01:03.000
So if you can figure out how to solve this without having to use that in here we have it right and pushes

01:03.000 --> 01:03.480
your hands.

01:03.480 --> 01:07.040
These are some of the methods I use to solve it.

01:07.040 --> 01:15.080
All right so the way that I saw this was I created a Conte's variable called one array or combined.

01:15.120 --> 01:22.080
I called it one right got really shit the bed on this name right here will go with one array and initialize

01:22.080 --> 01:24.710
this to an empty array.

01:24.750 --> 01:34.630
Then I defined a function within here called flatten and flatten will take in an array.

01:35.370 --> 01:39.460
So the array and any array

01:42.650 --> 01:48.730
and what we're going to do is we're going to recursively call Flaten like so.

01:48.950 --> 01:55.340
So we'll have something like Flaten and I'll take an R R and I will perform all we needed to do.

01:55.340 --> 02:00.910
Now if line fails it's no longer recursive we just go ahead and return one.

02:00.910 --> 02:01.750
Right.

02:02.330 --> 02:07.700
So what we need to do is with that flatten array we're going to pass and we're going to use what's called

02:07.700 --> 02:08.440
recursion.

02:08.660 --> 02:14.990
So a little brief background on recursion for those of you who aren't familiar recursion essentially

02:14.990 --> 02:22.850
is calling a function within itself calling calling out and we don't have to use Flaten like this week.

02:23.090 --> 02:30.440
I thought it was a little bit more clean to break it out but we're actually just calling Flanery again

02:30.440 --> 02:34.090
and again and again and again until it until we exit out of it.

02:34.100 --> 02:42.440
So recursion is the act of repeating a function within itself until you don't need it anymore.

02:42.470 --> 02:48.890
And so that's recursion a very brief run their recursion but it Zorg news with this value that we're

02:48.890 --> 02:55.040
going to pass in we're going to iterate through each of the values here.

02:56.270 --> 03:01.940
And this is how we're going to fire off or Herscher when we first launch to hit Flann and then within

03:01.940 --> 03:05.700
here we're going you're going to see a little bit better example this is in.

03:05.720 --> 03:07.610
But what's in here will be recursion.

03:07.700 --> 03:15.210
And so we're going to have an if statement says look if there's an array array that is array.

03:15.950 --> 03:20.180
This again checks to make sure that it's an array we can't check the type of it because object comes

03:20.180 --> 03:24.410
back for not a number it comes back for an object also goes back for an array.

03:24.410 --> 03:27.050
So array that is array.

03:27.200 --> 03:35.890
If that element is an array we want to go ahead and call Flaten on on the the element

03:39.820 --> 03:41.650
now if it's not

03:44.850 --> 03:48.930
we just want to go ahead and push those values.

03:48.960 --> 04:00.140
So take Flaten and we'll take one re push that element.

04:00.330 --> 04:08.710
So we're constantly modifying that element constantly modifying the one array or just continually calling

04:08.730 --> 04:14.850
flying right here or pushing to this every other way that we could have done this using enclosure we'd

04:14.850 --> 04:17.290
still be using recursion that would work.

04:17.360 --> 04:22.590
Know it's like I forget third my test case is so sloppy on number 100 but let me go ahead and throw

04:22.590 --> 04:24.140
that up real quick.

04:24.150 --> 04:26.770
All right so you see everything is working here.

04:26.810 --> 04:32.100
So SQL logic warmer tanks I don't know if I've done any recursion algorithms I tend to try and avoid

04:32.100 --> 04:35.120
it because I think most time you could solve problems without it.

04:35.130 --> 04:39.040
But so were iterating through the array.

04:39.750 --> 04:45.140
And if it is an array we want to then flatten the array.

04:45.180 --> 04:49.890
What that means is we're going to then call this function on the element we're passing and which is

04:49.890 --> 04:51.560
an array.

04:52.020 --> 04:53.120
At this point it's an array.

04:53.130 --> 04:55.100
At this point it's a value.

04:55.320 --> 05:00.450
And if that's the case we're going to go in and nice check until it finally hit somebody and not an

05:00.450 --> 05:01.080
array.

05:01.080 --> 05:03.810
And then we're going to push that value to our one array.

05:03.810 --> 05:08.340
And then when it's done entering through that I'll continue iterating through the other options.

05:08.370 --> 05:13.920
Doesn't stop it it just continues on a different path until it finally has no paths other than to return

05:13.980 --> 05:15.210
the one value.

05:15.630 --> 05:17.950
So those are our recursions solution.
