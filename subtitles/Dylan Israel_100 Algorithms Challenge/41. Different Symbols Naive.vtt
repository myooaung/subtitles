WEBVTT

00:00.560 --> 00:04.020
All right so here we are with different symbols.

00:04.190 --> 00:05.520
Nay naive native.

00:05.540 --> 00:06.810
I don't know what they're trying to say here.

00:06.830 --> 00:08.430
I naive.

00:08.720 --> 00:13.250
And what we're trying to do here is figure out how many different characters are in a string we are

00:13.250 --> 00:14.240
passing in.

00:14.300 --> 00:19.610
So in the cab here and this string that we pass in it would be three because there's a c there's an

00:19.610 --> 00:20.860
H and there's a B.

00:20.900 --> 00:27.100
So that's what we're trying to do here the way that I solve this is I use includes split and push.

00:27.480 --> 00:33.010
I think there's probably some better ways that we could have gone about this using objects.

00:33.030 --> 00:38.100
It would be faster but we'll go ahead and show this solution and maybe we'll do a second one using objects.

00:39.780 --> 00:46.780
Our is the way that I solve this was I created a a constant call letter array and then there I just

00:46.780 --> 00:48.110
push new values to it.

00:48.120 --> 00:53.380
That didn't exist it was or wasn't it and we push an age to it and when we checked against it using

00:53.380 --> 00:54.010
include.

00:54.010 --> 00:59.310
So we take our string we turn it into a character array and then we add to the letter right.

00:59.320 --> 01:02.680
And then finally we return that letter raised length at the end.

01:02.680 --> 01:06.040
So let's go ahead and create our constant letter.

01:07.080 --> 01:13.730
We should probably just call this chars but char's is going to be equal to an empty array.

01:13.780 --> 01:17.650
Now in typescript again I say I've said this several times.

01:17.830 --> 01:21.110
You can have implicit types here or explicit.

01:21.130 --> 01:26.620
When I'm dealing with a certain type of array I like to explicitly state what it is going to do.

01:26.770 --> 01:28.240
That's a personal preference.

01:28.240 --> 01:33.430
Next what we're going to do here we're going to set up our our wind condition if you will what we're

01:33.430 --> 01:37.450
expecting and our return and what we're expecting is our charge dot length.

01:37.550 --> 01:42.690
And actually this should be unique chars.

01:42.820 --> 01:44.310
That's a better name.

01:44.380 --> 01:46.410
So any unique chars.

01:46.450 --> 01:50.370
So that's what we're expecting to return by the end of this.

01:50.380 --> 01:56.850
Now what we need to do is just create a cost here and we'll just call this input chars.

01:57.190 --> 02:00.270
And this is a game going to be a string array.

02:00.530 --> 02:06.190
In this case I could probably leave the string off because we're going to split on it but kind of my

02:06.280 --> 02:08.680
own standard convention.

02:08.740 --> 02:16.470
All right so now we have that we need to iterate through our input chars and check if the element exists.

02:16.480 --> 02:21.480
If it does not we can go ahead and push it to the unique chars we can.

02:21.520 --> 02:24.580
There's no reason that we can't use a For Each loop for this.

02:24.670 --> 02:28.570
So we use a for each one we witness.

02:28.750 --> 02:31.980
And then here we'll just say char.

02:34.190 --> 02:36.180
Excellent.

02:36.270 --> 02:40.180
What is that stuff for each input chars.

02:40.220 --> 02:40.490
Susie

02:43.810 --> 02:44.330
very nice.

02:44.560 --> 02:48.180
And we're just going to if we're say look if letter re

02:51.250 --> 02:59.310
or is meaning you need char's sorry this is what happens when you rename variables mid tutorial so unique

02:59.330 --> 03:04.440
char's includes the char.

03:04.620 --> 03:09.690
If it does not write because we are bang on here or if it does if it's not included what we want to

03:09.690 --> 03:10.120
do.

03:10.260 --> 03:16.380
So don't take unique chars and we want to push that char on there and that's it.

03:16.380 --> 03:17.470
At the end of the day.

03:17.520 --> 03:22.280
So just go over the logic and we create a essentially a placeholder array to store the unique values

03:22.310 --> 03:27.030
then we then turn our string into a character or a string array.

03:27.060 --> 03:28.940
We iterate over that array.

03:29.010 --> 03:36.630
We check if it's unique chars here has that value and we push that value return the length.

03:36.660 --> 03:41.220
As I mentioned earlier this isn't really a in terms of optimization.

03:41.220 --> 03:46.650
This is a very poorly optimized one because this includes right here.

03:46.710 --> 03:51.560
So this includes is going to check every value in this unique character.

03:51.690 --> 03:54.130
Now it's something that is a simple string like this.

03:54.180 --> 04:01.440
It's not a big deal but as we would be moving forward and we want to maybe maybe that we wanted to make

04:01.440 --> 04:07.290
sure is the most efficient possible we could redo this and use the has own property and stored in an

04:07.290 --> 04:09.930
object to return the length that way.

04:10.110 --> 04:13.620
And you know what let's go ahead and do that next.

04:13.620 --> 04:15.060
All right so let's go and dive in here.

04:15.060 --> 04:17.160
I warn you that I actually haven't solved this one yet.

04:17.190 --> 04:18.830
I'm not too worried about it.

04:18.900 --> 04:20.200
We could solve it together.

04:20.250 --> 04:23.090
So we're in the second solution.

04:23.080 --> 04:30.930
Or is it concept unique char's and this is just going to be a empty object.

04:31.560 --> 04:32.160
Excellent.

04:32.340 --> 04:40.970
And at the end here we want to return object Dom keys passing the unique chars.

04:41.130 --> 04:45.600
So this is going to return the keys that are in there as an array but we don't want the array.

04:45.750 --> 04:48.420
We just want the length of it so that would be how we're going to handle this.

04:48.420 --> 04:56.230
Now all we have to do is make sure we add unique values to that array and that's pretty straightforward

04:56.250 --> 04:57.320
at the end of the day.

04:57.690 --> 05:07.840
We can do the same thing we did here earlier where we're going to create a a input array input and put

05:07.850 --> 05:10.420
chars it was a stock split

05:13.350 --> 05:14.790
excellent.

05:15.060 --> 05:17.830
And now we're going to iterate over the input jars

05:21.090 --> 05:26.080
for each and say char again.

05:27.300 --> 05:32.190
And because of the way that we're going to do this because of the way that this is going to work out

05:32.520 --> 05:36.640
is we actually don't even have to check because A is going to overwrite.

05:36.690 --> 05:43.110
And that's how we're going to set our values so it is a unique unique char's not

05:46.470 --> 05:47.690
dot.

05:48.110 --> 05:53.420
Oh you make char char and we could just go ahead and set it equal to 1 if we want.

05:53.780 --> 05:55.730
That should of set.

05:55.760 --> 05:56.380
There you go.

05:56.530 --> 05:58.980
So we just give a default value c with 3.

05:59.020 --> 06:03.950
So it just occurred to me that there is actually a third way that we can solve this.

06:04.030 --> 06:07.240
That is even simpler as we go through.

06:07.240 --> 06:10.380
And let's go ahead and do that one one more time.

06:10.390 --> 06:10.800
All right.

06:10.810 --> 06:17.530
So we're going to be using a little bit of E-6 here and what we're going to do is go ahead and clear

06:17.530 --> 06:24.160
out all of this again and we're going to create a new set so sets for those who aren't super familiar

06:24.160 --> 06:29.710
with it are essentially a unique list meaning that all the values in there have to be unique even if

06:29.710 --> 06:31.350
we added duplicate value.

06:31.360 --> 06:33.650
So what this gives us the ability to do here.

06:33.750 --> 06:37.680
So on the anvil return unique chars.

06:37.690 --> 06:39.960
And I believe sets called dot size.

06:40.000 --> 06:43.020
So instead of length we're calling size because it's a set.

06:43.420 --> 06:49.110
And what we're going to do here we're they we're just going to iterate over all the values in the string

06:49.510 --> 06:51.500
and we're going to push every single one to it.

06:51.520 --> 06:54.060
But if there is duplicates it's just going to ignore it.

06:54.190 --> 07:02.220
And so what we can do here is we'll just create a Conte's one more time and we'll call this input chars.

07:02.570 --> 07:02.980
Well good.

07:02.980 --> 07:13.300
Is this equal to a a split of brain fart there for a second sort of split that up into a character.

07:13.460 --> 07:20.710
Now we're just going to input chars and we're going to iterate over for each.

07:21.840 --> 07:22.390
So are

07:26.530 --> 07:37.920
excellent and all we're going to do is say unique char's ad which is essentially push.

07:38.290 --> 07:43.900
I'm just going to add that char you'll see here we get three back just to show you that it's doing it

07:43.900 --> 07:44.400
right.

07:44.410 --> 07:47.920
We're going to have C A and B in our set there.

07:48.070 --> 07:56.020
And so this is another way that we could of solve this algorithm and probably looking at it the simplest

07:56.020 --> 08:01.770
way as well as the set sets are designed for unique values in a list.

08:01.780 --> 08:06.250
And so we should have there should have been our first conclusion when we're like OK this is what we

08:06.250 --> 08:07.020
need to solve this.
