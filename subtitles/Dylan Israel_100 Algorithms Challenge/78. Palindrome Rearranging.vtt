WEBVTT

00:00.780 --> 00:06.750
All right so this was a fun one palindrome rearranging and what we're trying to find out is given the

00:06.750 --> 00:13.400
string that we're taking Can we in fact in fact if we rearrange the letters in a way make it a palindrome.

00:13.560 --> 00:15.940
So you'll see we have a B B.

00:16.170 --> 00:25.770
At which point we get a erks do we get a BBA or some or you know the reverse which should b b a b which

00:25.770 --> 00:34.020
would also be a palindrome palindrome just as a reminder something the same forward as it is backwards.

00:34.020 --> 00:39.420
In our case we're just try to find out if we can return a boolean if it's possible to rearrange it to

00:39.420 --> 00:46.880
be a palindrome and to say I have four of the two methods used was has own property and split.

00:46.890 --> 00:48.650
Let's jump into it.

00:48.690 --> 00:54.660
All right so the way that I tackle this problem was first I broke the input string into a character

00:54.660 --> 00:55.170
array.

00:55.380 --> 01:04.640
Then I created an object that then added a count of each individual characters and then I and then I.

01:04.680 --> 01:11.580
I Moggi I find I found out how many of those values were even if they were even great that works really

01:11.580 --> 01:15.730
good but it there's more than one odd value.

01:16.580 --> 01:21.150
Then it can't be a palindrome because espie the same on each side excluding the middle number which

01:21.150 --> 01:26.070
is why we have one odd value so that was sort of my logic when I was trying to solve this so go ahead

01:26.070 --> 01:27.290
and create a character.

01:27.990 --> 01:29.130
I just call this chart.

01:29.330 --> 01:30.540
We've just got char's.

01:30.630 --> 01:39.700
And also this equal to the input string split split on each end of each individual character next door

01:39.730 --> 01:45.550
and create a letter object or so just set it to an empty object.

01:45.810 --> 01:49.660
From here we're going to use or and iterate through art our chars.

01:49.890 --> 02:02.650
So for each character and then over say I's list and char chars the length plus plus.

02:03.660 --> 02:04.360
Excellent.

02:04.390 --> 02:10.410
Now we're going to do here is Soltanieh probably if you watched the other videos you probably have already

02:10.410 --> 02:17.040
an idea is we're going to essentially map our object at this point where we're into if letter object

02:18.200 --> 02:21.780
has a property.

02:22.330 --> 02:23.130
What are we checking.

02:23.130 --> 02:27.200
Property We're checking our char Sherzai.

02:27.480 --> 02:39.110
If that is true what we want to do is take a letter object into char Ray Charles I

02:42.060 --> 02:45.960
fat finger and it over here plus plus we just want to add 1 to it.

02:45.960 --> 02:59.640
Now if that's false and or else we're going to do is re-insert letter object plus value chars equal

02:59.640 --> 03:01.160
to 1.

03:01.620 --> 03:02.310
Excellent.

03:02.310 --> 03:08.420
So now we have our object that's been mapped over so that we can add one to it.

03:08.460 --> 03:14.730
And I think we'll probably refactor this to get rid of the for loop and make it maybe a foot for a loop

03:14.970 --> 03:18.290
just because there's no reason for us to have this index.

03:18.290 --> 03:22.620
This index value and it may make it a little bit easier to keep track of.

03:22.620 --> 03:30.090
So we're going to have here is what I call odd count count equal to zero and so odd count it's going

03:30.090 --> 03:35.550
to be the value that we should actually initialize this up top.

03:35.550 --> 03:41.340
Usually you want to initialize your variables of top odd counters the value that keeps track of how

03:41.340 --> 03:43.510
many odd items are on.

03:43.600 --> 03:50.300
And so we're going to go for in loop as it were and say a vowel in letter object.

03:51.000 --> 03:54.460
So going through with this

04:05.120 --> 04:07.140
what they want.

04:07.550 --> 04:11.200
So we're going to iterate through.

04:11.460 --> 04:23.090
I say if our letter object for the actions is key preserved word.

04:23.640 --> 04:25.440
So that's really what we're discussing here.

04:25.670 --> 04:32.950
So we're going to check that key and we say if this is modular by two is not equally equal to zero I

04:33.070 --> 04:36.250
mean it is a even excuse me an odd number.

04:36.290 --> 04:39.900
We're going to take our count and we're going to anchorman's by one.

04:40.250 --> 04:45.170
Now that we've done that we have all the info we need and we just need a simple ternary here I say odd

04:45.170 --> 04:48.140
count if I'm counting is greater than 1.

04:48.140 --> 04:52.940
We can go ahead and return false because that means we can't have a palindrome because you know we can

04:52.940 --> 05:00.020
only have the one middle odd number else and return true and we're done so.

05:00.210 --> 05:00.800
So why is that.

05:00.800 --> 05:02.560
I might clean this up.

05:02.660 --> 05:11.390
I would maybe rename letter object to something more intuitive like Char count would be a good a good

05:11.390 --> 05:12.200
name.

05:12.200 --> 05:16.650
So I do so like this.

05:16.760 --> 05:18.740
I mean you're factoring codes are important.

05:19.130 --> 05:20.980
So char count there.

05:21.300 --> 05:30.840
It might be a little bit more intuitive instead of this we do a for loop or Sulit which char of charas

05:31.570 --> 05:35.330
and then we go ahead and eliminate some of this code.

05:45.620 --> 05:47.600
Sure.

05:47.980 --> 05:56.080
So a little bit cleaner in that aspect but I think that's pretty much it for this one.
