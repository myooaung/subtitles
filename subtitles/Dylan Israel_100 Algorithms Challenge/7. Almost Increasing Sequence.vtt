WEBVTT

00:00.730 --> 00:01.370
All right.

00:01.380 --> 00:07.850
So in almost increasing sequence what we're going to have here is an array of values such as one three

00:07.860 --> 00:15.000
to one array of integers to what we're going to say is a number it's almost increasing if the array

00:15.000 --> 00:19.560
goes from left to right and is constantly increasing.

00:19.770 --> 00:22.050
Or it can have one mistake right.

00:22.050 --> 00:29.160
So in our in our example here one 3 that's our first mistake in two is the second mistake or first mistake

00:29.170 --> 00:35.820
and that's the one it's the second mistake while 1 3 2 is a true statement because it only goes in a

00:36.360 --> 00:40.200
in a incorrect sequence one single time.

00:40.590 --> 00:43.410
Hence the almost increasing sequence.

00:43.550 --> 00:48.880
I don't really have any methods for you to reference here this is pretty much pure logic.

00:48.900 --> 00:50.410
Let's get started.

00:51.080 --> 00:57.780
OK so the way that I solve this is I created a count variable that's going to store how many times numbers

00:57.930 --> 01:06.710
are out of sync really at the end of the day and we'll we'll go ahead and just initialize it we initialize

01:06.740 --> 01:14.360
it to 0 and the end here is what we're expecting is a boolean value we want to return if Count will

01:14.360 --> 01:18.920
return true if count is less than or equal to one meaning if it's 0 it passes.

01:18.920 --> 01:25.780
If it's one it's fasces if two or more items are out of sync then it is not an almost increasing sequence.

01:25.820 --> 01:27.780
So now that we know our condition.

01:27.890 --> 01:35.780
Now all we have to do is iterate through the array and understand situations where when we iterate through

01:36.260 --> 01:42.130
if we're going to have an issue with the number order so we can do this.

01:42.200 --> 01:49.820
We're going to do it at a normal for loop because the logic here it's just easier and we want to easily

01:49.820 --> 01:52.230
have access to the index value.

01:52.280 --> 01:55.120
So we're in sequence length

01:58.350 --> 02:04.150
faffing that Susan plus plus we want to go through every iteration here.

02:04.250 --> 02:08.480
Now what we're are we're in at two nested if statements.

02:08.600 --> 02:20.710
The first ones to say hey if sequence II is less than or equal to sequence I'm on this one.

02:20.750 --> 02:32.270
If that is a true statement meaning that the the value after it is the the second value is less than

02:32.270 --> 02:36.830
the first value in order we want to go ahead and add 1 Dickau.

02:36.950 --> 02:43.580
Now after this we're going to do another nested IF here because it is a almost increasing sequence so

02:43.580 --> 02:49.840
what that basically means is that we need to check if this if two values back is less than that value.

02:49.970 --> 02:58.400
And the one value ahead is less than the one value behind because if it is that's our second item there

02:58.400 --> 03:02.700
that's going to break the count because we're giving it one pass not two.

03:02.790 --> 03:08.540
And it's it's a little bit wonky when you look at it and it took me a second to figure it out on my

03:08.540 --> 03:09.940
own about the math.

03:09.950 --> 03:14.350
But we're saying hey is our current value that we're checking also also

03:17.320 --> 03:21.910
less than two values before that.

03:22.490 --> 03:29.450
You know is is are one less than 2 or excuse me these are two less than 1.

03:29.560 --> 03:30.250
In this case.

03:30.350 --> 03:31.650
Are looking at this first one.

03:33.000 --> 03:37.880
If that's a true statement and the sequence

03:40.650 --> 03:51.300
of the II plus 1 is less than or equal to the sequence of minus 1.

03:52.120 --> 03:56.320
We can just go ahead and return false because we've already hit our double count at this point.

03:56.410 --> 04:05.460
There's really no there's no reason to do another generation.

04:05.580 --> 04:08.960
And you know it's better practice not to at this point.

04:08.960 --> 04:14.390
The hardest part was probably for me at least just sort of visualizing why I would do this just because

04:15.350 --> 04:19.920
it could be in a world where let's say this is three and then this is one.

04:20.030 --> 04:21.900
This actually fails right.

04:22.090 --> 04:29.840
Because then even if this is true because this value here is equal this value here there they haven't

04:29.840 --> 04:33.480
made that correlation where we're saying it's almost increase.

04:33.490 --> 04:36.330
And that doesn't mean that it's just the next door neighbor.

04:36.380 --> 04:37.880
We can skip one time.

04:37.880 --> 04:41.850
It needs to be valid for all of them which is why we do this check here.
