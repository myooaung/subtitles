1
00:00:01,240 --> 00:00:03,120
[Autogenerated] I mentioned at the beginning of the module that

2
00:00:03,120 --> 00:00:05,570
deep learning is a subset of machine learning,

3
00:00:05,570 --> 00:00:08,000
and it underlies a lot of the AWS services and

4
00:00:08,000 --> 00:00:09,770
algorithms that you'll be working with,

5
00:00:09,770 --> 00:00:13,540
particularly when it comes to things like image recognition and speech.

6
00:00:13,540 --> 00:00:17,540
Let's do a quick lap around the important concepts you need to know

7
00:00:17,540 --> 00:00:19,770
first going back to our definition of machine learning,

8
00:00:19,770 --> 00:00:22,090
we said It starts with data when it's passed into an

9
00:00:22,090 --> 00:00:25,360
algorithm that identifies patterns, and at the end of the process,

10
00:00:25,360 --> 00:00:29,160
we have a trained model or simplifying even more.

11
00:00:29,160 --> 00:00:30,840
We have input.

12
00:00:30,840 --> 00:00:35,040
We do stuff to that input, and then we have output.

13
00:00:35,040 --> 00:00:37,890
For example, the input could be a transaction date,

14
00:00:37,890 --> 00:00:42,240
a customer name and the fact that a credit card was reported stolen.

15
00:00:42,240 --> 00:00:44,860
We pass that data in we do stuff,

16
00:00:44,860 --> 00:00:49,140
and the output is that we can predict that this is a case of fraud.

17
00:00:49,140 --> 00:00:50,160
So super easy.

18
00:00:50,160 --> 00:00:53,990
We have limited known data for input and just two options for output.

19
00:00:53,990 --> 00:00:56,440
Either fraud or not.

20
00:00:56,440 --> 00:00:58,940
But what if we have something more complex?

21
00:00:58,940 --> 00:01:01,840
Take, for instance, this hand written digit, too.

22
00:01:01,840 --> 00:01:07,140
This image is 28 pixels by 28 pixels or 784 total pixels.

23
00:01:07,140 --> 00:01:08,730
And this is just a single digit.

24
00:01:08,730 --> 00:01:11,880
You could imagine if we're dealing with images of people or the input

25
00:01:11,880 --> 00:01:14,540
is an audio stream that you want to make sense of.

26
00:01:14,540 --> 00:01:17,910
But sticking with our example of a digit to what happens here

27
00:01:17,910 --> 00:01:19,820
is we're going to take each of those pixels,

28
00:01:19,820 --> 00:01:24,440
all 784 of them and put them into this input layer.

29
00:01:24,440 --> 00:01:27,020
The next step is what we call the hidden layers,

30
00:01:27,020 --> 00:01:29,640
and we'll have one or more hidden layers.

31
00:01:29,640 --> 00:01:31,890
There's an art and science to the number of layers

32
00:01:31,890 --> 00:01:33,370
and the number of nodes in them.

33
00:01:33,370 --> 00:01:34,620
But for illustration purposes,

34
00:01:34,620 --> 00:01:38,440
I'm just going with two and some number of nodes in each.

35
00:01:38,440 --> 00:01:41,940
For now, we're just going to say that these layers do stuff.

36
00:01:41,940 --> 00:01:43,900
The nodes in the first hidden layer are connected to

37
00:01:43,900 --> 00:01:46,340
the nodes in the second layer, and so on.

38
00:01:46,340 --> 00:01:50,790
These connections are called edges, and then finally, the output layer.

39
00:01:50,790 --> 00:01:52,720
After all of the doing stuff,

40
00:01:52,720 --> 00:01:57,040
we want to get an output that identifies the hand written digit as a to,

41
00:01:57,040 --> 00:02:00,740
and this entire structure is called a neural network.

42
00:02:00,740 --> 00:02:03,570
Now going back to that in middle part of doing stuff.

43
00:02:03,570 --> 00:02:07,640
What's happening here is the neural network is identifying patterns,

44
00:02:07,640 --> 00:02:09,860
so it's these pixels in a certain pattern,

45
00:02:09,860 --> 00:02:12,770
and it can identify a line that makes up part of the digit,

46
00:02:12,770 --> 00:02:13,840
for instance,

47
00:02:13,840 --> 00:02:16,430
or it can identify loops that make up part the digit

48
00:02:16,430 --> 00:02:18,940
or looky loos and squid lease,

49
00:02:18,940 --> 00:02:23,100
and eventually it will get to the full digit of to now under the covers.

50
00:02:23,100 --> 00:02:24,480
There's a few things happening,

51
00:02:24,480 --> 00:02:28,740
and I'll take this back down to a super simple example with just a few neurons.

52
00:02:28,740 --> 00:02:31,290
So you have your input, and here are input.

53
00:02:31,290 --> 00:02:33,050
Values are for no particular reason.

54
00:02:33,050 --> 00:02:34,800
12 and three.

55
00:02:34,800 --> 00:02:37,540
Then you have your connections or edges.

56
00:02:37,540 --> 00:02:40,540
Each connection has a weight associated with it,

57
00:02:40,540 --> 00:02:42,950
and these are just numbers that I made up with the top one having a

58
00:02:42,950 --> 00:02:47,040
weight of three the middle of five in the bottom of seven.

59
00:02:47,040 --> 00:02:49,420
If you multiply those weights together with the input,

60
00:02:49,420 --> 00:02:52,160
you get the values that we pass into the next neuron.

61
00:02:52,160 --> 00:02:54,740
So one times three equals three,

62
00:02:54,740 --> 00:02:59,460
two times five equals 10 and three times seven equals 21 you,

63
00:02:59,460 --> 00:03:03,740
then some those up and you get 34 there in the middle node.

64
00:03:03,740 --> 00:03:06,120
Now, in this note, a couple of things happen first,

65
00:03:06,120 --> 00:03:08,740
to apply what's called an activation function.

66
00:03:08,740 --> 00:03:10,990
A common activation function is one that will cause your

67
00:03:10,990 --> 00:03:14,160
output to be between zero and one, or in some cases,

68
00:03:14,160 --> 00:03:16,440
between negative one and one,

69
00:03:16,440 --> 00:03:19,580
and then each node also has a bias associated with it,

70
00:03:19,580 --> 00:03:24,440
and that bias gets added in, and all of that will result in an output value.

71
00:03:24,440 --> 00:03:26,910
Now that's just for the couple of notes that we saw there,

72
00:03:26,910 --> 00:03:28,500
not the entire network.

73
00:03:28,500 --> 00:03:32,730
So rinse and repeat a lot, and when you get to the final output,

74
00:03:32,730 --> 00:03:37,240
compare the output that you got with the output that you expected.

75
00:03:37,240 --> 00:03:41,740
And that difference equals these cost or the error.

76
00:03:41,740 --> 00:03:42,270
And really,

77
00:03:42,270 --> 00:03:48,240
the goal of learning is to find which weights and biases minimize that cost.

78
00:03:48,240 --> 00:03:50,360
So Azure algorithm is making its passes,

79
00:03:50,360 --> 00:03:54,040
its tweaking those numbers to find the right combinations.

80
00:03:54,040 --> 00:03:56,150
We'll talk more about cost functions and things like

81
00:03:56,150 --> 00:03:58,190
radiant dissent in future modules,

82
00:03:58,190 --> 00:04:00,490
but hopefully that gives you the intuition for how neural

83
00:04:00,490 --> 00:04:08,000
networks behave and with the ultimate goal is now. Let's take a look at some common use cases for machine learning

