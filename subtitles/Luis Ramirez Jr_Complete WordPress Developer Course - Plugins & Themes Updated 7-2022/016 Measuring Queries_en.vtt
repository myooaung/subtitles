WEBVTT
1
00:00:00.090 --> 00:00:03.900
In this lecture, let's take a moment to talk about performance.

2
00:00:03.930 --> 00:00:06.480
Performance is crucial for any site.

3
00:00:06.480 --> 00:00:11.040
The slower a site loads, the more likely a user may leave our site.

4
00:00:11.040 --> 00:00:18.660
We never want that to happen for the daily recipe block we wrote a custom SQL query for grabbing a random

5
00:00:18.660 --> 00:00:19.410
recipe.

6
00:00:19.410 --> 00:00:21.510
I haven't been completely honest.

7
00:00:21.510 --> 00:00:25.380
WordPress has a solution for performing the same action.

8
00:00:25.530 --> 00:00:32.490
We avoided the WordPress solution for one simple reason WordPress is solution is slower than a custom

9
00:00:32.490 --> 00:00:33.180
query.

10
00:00:33.180 --> 00:00:37.110
There are different ways to measure the performance of a line of code.

11
00:00:37.400 --> 00:00:40.170
SQL has a feature called profiling.

12
00:00:40.170 --> 00:00:43.560
However, setting up profiling can take a while.

13
00:00:43.560 --> 00:00:50.640
Therefore, I'm going to show you a simple PHP solution for measuring the performance of a line of code.

14
00:00:50.670 --> 00:00:54.300
In PHP, there's a function called micro time.

15
00:00:54.300 --> 00:00:58.740
The micro time function will grab the current time in microseconds.

16
00:00:59.250 --> 00:01:01.290
PHP is a very fast language.

17
00:01:01.290 --> 00:01:05.010
Lines of code can finish running within microseconds.

18
00:01:05.010 --> 00:01:11.220
The micro time function is the best way to measure how long a line of code takes to run.

19
00:01:11.220 --> 00:01:13.190
Let me show you an example.

20
00:01:13.200 --> 00:01:17.640
For the sake of brevity, I've updated the daily recipe block.

21
00:01:17.640 --> 00:01:21.900
By measuring the SQL query, you do not need to follow along.

22
00:01:21.930 --> 00:01:26.520
Feel free to sit back and relax in the daily recipe function.

23
00:01:26.520 --> 00:01:29.760
I'm running the micro time function by defaults.

24
00:01:29.760 --> 00:01:32.880
The micro time function returns a string.

25
00:01:32.910 --> 00:01:38.370
A boolean value can be passed in to override this behavior by passing in.

26
00:01:38.370 --> 00:01:41.640
True, the returned value will be a number.

27
00:01:41.760 --> 00:01:47.190
The value returned by the micro time function is stored in a variable.

28
00:01:47.220 --> 00:01:55.950
After storing the time, I'm running the same SQL query from the generate daily recipe dot PHP file.

29
00:01:55.950 --> 00:01:58.620
This time the value is not stored.

30
00:01:58.620 --> 00:02:00.750
We're not interested in the value.

31
00:02:00.780 --> 00:02:04.620
We just want to measure the time it takes to run this query.

32
00:02:04.890 --> 00:02:08.729
After the query finishes running, we are storing the time again.

33
00:02:08.729 --> 00:02:15.180
Lastly, I'm calculating the time it took to run this line of code by subtracting the variables.

34
00:02:15.180 --> 00:02:19.950
The result is stored in a variable called SQL execution time.

35
00:02:19.950 --> 00:02:22.050
The same process is repeated.

36
00:02:22.050 --> 00:02:28.440
However, in this example, I have recreated the same query with the WP query class.

37
00:02:28.440 --> 00:02:33.360
The WP Query class will create and execute a query for you.

38
00:02:33.390 --> 00:02:37.860
This allows you to avoid writing queries to grab a random value.

39
00:02:37.860 --> 00:02:40.830
I set the order by option to random.

40
00:02:40.830 --> 00:02:42.480
That's all there is to it.

41
00:02:42.480 --> 00:02:48.060
The execution time is stored in a variable called WP execution time.

42
00:02:48.420 --> 00:02:55.020
After calculating the execution times, I've updated the template to render both times in a paragraph

43
00:02:55.020 --> 00:02:55.740
tag.

44
00:02:55.770 --> 00:03:00.390
This should give us an idea of how long a query took to execute.

45
00:03:00.390 --> 00:03:03.360
I'm going to refresh the page in the browser.

46
00:03:05.580 --> 00:03:10.730
At the bottom of the daily recipe block the execution times get displayed.

47
00:03:10.740 --> 00:03:15.540
Clearly the SQL query runs faster than the WordPress query.

48
00:03:15.570 --> 00:03:19.840
I can continuously refresh the page to get similar results.

49
00:03:19.860 --> 00:03:25.440
The SQL query will always outpace the WordPress query by a long shot.

50
00:03:25.470 --> 00:03:29.940
This is not to say that WordPress is inefficient in most scenarios.

51
00:03:29.970 --> 00:03:33.840
WordPress can perform just as fast as a raw query.

52
00:03:33.850 --> 00:03:38.880
In fact, it can be safer to use the WordPress class whenever possible.

53
00:03:38.910 --> 00:03:42.240
I prefer to use the WordPress query class.

54
00:03:42.360 --> 00:03:44.720
I have made an exception for this block.

55
00:03:44.730 --> 00:03:48.030
The query generated by WordPress is too slow.

56
00:03:48.060 --> 00:03:53.130
It can severely impact the performance of a site if a query is too slow.

57
00:03:53.160 --> 00:03:57.480
I will try writing a manual query and measure the differences.

58
00:03:57.480 --> 00:04:01.230
In my opinion, the raw query is better than WordPress.

59
00:04:01.230 --> 00:04:04.200
At the end of the day, it's completely up to you.

60
00:04:04.230 --> 00:04:08.280
Let's start moving on to other topics in the next section.

