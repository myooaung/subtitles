1
00:00:00,552 --> 00:00:03,718
Let's take a look at testing our controller by reviewing the

2
00:00:03,718 --> 00:00:07,326
source code for the ReviewControllerTest class.

3
00:00:07,326 --> 00:00:10,876
The ReviewControllerTest class should look familiar to you by now.

4
00:00:10,876 --> 00:00:15,266
It begins by including the ExtendWith SpringExtension annotation,

5
00:00:15,266 --> 00:00:19,675
which manages the application context; the SpringBootTest annotation,

6
00:00:19,675 --> 00:00:23,522
which populates our application context with all of our

7
00:00:23,522 --> 00:00:27,299
Spring-managed beans; and the AutoConfigureMockMvc annotation,

8
00:00:27,299 --> 00:00:31,148
which creates a MockMvc instance and wires it into our test class.

9
00:00:31,148 --> 00:00:35,850
We create a mock ReviewService for our test using the MockBean annotation.

10
00:00:35,850 --> 00:00:39,464
One of the new things in this test is the comparison of dates.

11
00:00:39,464 --> 00:00:42,614
Spring returns dates based on the date format you see

12
00:00:42,614 --> 00:00:45,132
here with the timezone set to GMT.

13
00:00:45,132 --> 00:00:50,133
We create a simple DateFormat to use in our data comparison and we set the

14
00:00:50,133 --> 00:00:54,077
timezone to GMT in our beforeAll JUnit set up method.

15
00:00:54,077 --> 00:00:58,712
BeforeAll is called once in this test case before all tests run.

16
00:00:58,712 --> 00:01:03,529
The testGetReviewByIdFound method executes a get request

17
00:01:03,529 --> 00:01:06,287
against /review/id to retrieve a review.

18
00:01:06,287 --> 00:01:10,677
And the mock service is configured to return a mockReview that contains a

19
00:01:10,677 --> 00:01:13,986
single review entry when its findById method is called.

20
00:01:13,986 --> 00:01:18,481
It uses the mockMvc.perform method to execute the GET request,

21
00:01:18,481 --> 00:01:23,450
specifying /review/reviewId, then it validates the response.

22
00:01:23,450 --> 00:01:27,939
It checks to make sure that we receive a 200 OK HTTP response code,

23
00:01:27,939 --> 00:01:32,472
a JSON response body, and the correct ETAG and LOCATION HttpHeaders,

24
00:01:32,472 --> 00:01:35,551
then it validates the return body.

25
00:01:35,551 --> 00:01:37,424
In the previous module, we had a simple document,

26
00:01:37,424 --> 00:01:41,599
and we were able to extract fields in the root of that document.

27
00:01:41,599 --> 00:01:45,161
In this case, the ID and productId are in the root of the response,

28
00:01:45,161 --> 00:01:48,451
but we have a list of entries that we want to validate.

29
00:01:48,451 --> 00:01:52,928
First we use the jsonPath expression $ .entries .length.

30
00:01:52,928 --> 00:01:57,309
Recall that the dollar sign represents the root of the document,

31
00:01:57,309 --> 00:02:00,803
so $ .entries references the entries element

32
00:02:00,803 --> 00:02:02,941
attached to the root of the document.

33
00:02:02,941 --> 00:02:05,533
The length method is then specified to retrieve the

34
00:02:05,533 --> 00:02:07,793
number of elements in its array.

35
00:02:07,793 --> 00:02:11,166
In this case, we have one entry, so we compare the length to 1.

36
00:02:11,166 --> 00:02:14,104
Next we want to examine the contents of the entry.

37
00:02:14,104 --> 00:02:16,023
Just like Java arrays,

38
00:02:16,023 --> 00:02:20,876
jsonPath defines its array notation using square brackets and an index,

39
00:02:20,876 --> 00:02:22,142
starting at 0.

40
00:02:22,142 --> 00:02:27,316
So $ .entries at 0.username references the username key in

41
00:02:27,316 --> 00:02:31,946
the first node of the entries array, which we compare to test-user.

42
00:02:31,946 --> 00:02:34,699
Likewise, we compare the entries review to Great product.

43
00:02:34,699 --> 00:02:37,161
Finally, in order to compare dates,

44
00:02:37,161 --> 00:02:40,489
we need to format our date using the simple dateFormat that

45
00:02:40,489 --> 00:02:43,466
we created above that was set to GMT.

46
00:02:43,466 --> 00:02:47,544
We extract the date from the JSON payload and then compare it to the date

47
00:02:47,544 --> 00:02:50,443
string generated by the dateFormat's format method.

48
00:02:50,443 --> 00:02:51,967
It's pretty simple once you know how to do it,

49
00:02:51,967 --> 00:02:54,690
but there's plenty of room for questions when facing

50
00:02:54,690 --> 00:02:56,538
testing dates for our quality.

51
00:02:56,538 --> 00:02:59,798
The remaining methods are all similar to what you've already seen.

52
00:02:59,798 --> 00:03:04,946
The testGetReviewByIdNotFound method executes the same GET request,

53
00:03:04,946 --> 00:03:07,791
but this time the mocked service is configured to return an

54
00:03:07,791 --> 00:03:11,200
Optional.empty when its findById method is called so it validates that

55
00:03:11,200 --> 00:03:14,071
the controller returns a 404 NotFound response.

56
00:03:14,071 --> 00:03:17,515
The testCreateReview method performs a POST request to /review,

57
00:03:17,515 --> 00:03:21,757
passing in a mock review that contains a single entry,

58
00:03:21,757 --> 00:03:25,841
using the same asJson object method that we saw in the last module.

59
00:03:25,841 --> 00:03:29,502
The review service is configured to return another mockReview object that

60
00:03:29,502 --> 00:03:32,617
includes an ID and version number when its save method is called,

61
00:03:32,617 --> 00:03:36,510
so we would expect that review to be presented back to us.

62
00:03:36,510 --> 00:03:41,814
The test method then verifies that it receives a 201 created HTTP response code,

63
00:03:41,814 --> 00:03:44,884
a JSON payload, the correct ETAG and LOCATION HttpHeaders,

64
00:03:44,884 --> 00:03:47,068
as well as a valid JSON document.

65
00:03:47,068 --> 00:03:51,982
The last method that I included is testAddEntryToReview.

66
00:03:51,982 --> 00:03:57,216
The purpose of this method is to test posting a new entry to an existing review.

67
00:03:57,216 --> 00:04:00,372
The controller will first execute a findByProductId call on

68
00:04:00,372 --> 00:04:02,670
its service to retrieve the exiting review,

69
00:04:02,670 --> 00:04:04,822
then it will add the entry to the review,

70
00:04:04,822 --> 00:04:06,201
save it to the Mongo database,

71
00:04:06,201 --> 00:04:09,444
and return the result in the review with the new entry.

72
00:04:09,444 --> 00:04:10,158
To facilitate this,

73
00:04:10,158 --> 00:04:14,744
we need to create a new ReviewEntry to post to the controller,

74
00:04:14,744 --> 00:04:17,322
a mockReview to return from the findByProductId method,

75
00:04:17,322 --> 00:04:21,681
and a mockReview that will be returned by the save method.

76
00:04:21,681 --> 00:04:24,797
After setting up all these mock objects and configuring the mock service,

77
00:04:24,797 --> 00:04:28,354
we invoke the controller with a POST request through mockMvc

78
00:04:28,354 --> 00:04:31,220
and validate that the response is correct.

79
00:04:31,220 --> 00:04:33,164
There's plenty of room for additional test cases,

80
00:04:33,164 --> 00:04:39,000
but between what you learned in the last module and these examples, the rest should be straightforward.

