WEBVTT

00:00.130 --> 00:05.310
Buat semua orang pola pemecahan masalah berikutnya akan berbicara tentang saya menelepon beberapa petunjuk lagi.

00:05.430 --> 00:09.750
Itu sebenarnya bukan nama resmi untuk itu, tetapi izinkan saya membaca definisi dulu.

00:09.750 --> 00:15.450
Idenya adalah bahwa kita membuat pointer atau nilai yang sesuai dengan indeks atau posisi dan kemudian bergerak menuju

00:15.600 --> 00:19.120
awal menuju akhir atau menuju satu sama lain di tengah.

00:19.170 --> 00:20.700
Berdasarkan kondisi tertentu.

00:21.030 --> 00:23.100
OK jadi apa yang sebenarnya terjadi.

00:23.250 --> 00:30.540
Kami memiliki semacam struktur struktur linear seperti array atau string atau nanti kami akan berbicara tentang hal-hal seperti daftar tertaut

00:30.540 --> 00:34.940
ganda yang mungkin tidak Anda kenal atau bahkan daftar tertaut tunggal.

00:34.980 --> 00:36.420
Jika Anda tidak tahu apa itu, jangan khawatir.

00:36.420 --> 00:42.090
Dan idenya adalah bahwa kita akan menjadi, saya tidak tahu mencari pasangan nilai atau mencari sesuatu

00:42.090 --> 00:43.540
yang memenuhi syarat.

00:43.680 --> 00:48.960
Biasanya kami sedang mencari pasangan dan saya akan menunjukkan sebuah contoh dalam sekejap dan kami menggunakan dua referensi.

00:49.020 --> 00:54.690
Jadi kita mulai satu referensi mungkin di sini dan satu lagi di sini dan kita bekerja menuju tengah ke satu

00:54.690 --> 00:55.290
sama lain

00:55.560 --> 01:01.290
Atau kita bisa memulai sesuatu di sini dan yang lain seperti ketika saya mengatakan referensi yang saya maksud adalah

01:01.290 --> 01:04.410
variabel seperti i dan j yang angka mengacu pada indeks.

01:04.440 --> 01:09.380
Jadi kita mulai di sini di J di sini dan kemudian kita bergerak maju dengan cara tertentu.

01:09.480 --> 01:12.000
Jadi tidak ada yang tahu arah yang dijamin.

01:12.070 --> 01:17.640
Ini adalah jenis yang didefinisikan secara longgar dibandingkan dengan apa yang kami lihat di video terakhir

01:17.760 --> 01:20.040
dibandingkan jenis terakhir penghitungan frekuensi pola.

01:20.040 --> 01:22.980
Tapi ini sering muncul, saya akan menunjukkan kepada Anda beberapa contoh.

01:22.980 --> 01:26.770
Jadi hanya untuk rekap kita memiliki pointer yang hanya variabel.

01:27.150 --> 01:32.340
Anda tahu kami sedang melihat lokasi tertentu dalam array atau string biasanya Dan kami memiliki yang kedua dan kami bekerja

01:32.700 --> 01:35.420
satu sama lain atau kami bekerja di arah yang sama.

01:35.420 --> 01:37.970
Kami bekerja dari awal hingga awal.

01:38.010 --> 01:40.490
Tidak masalah tapi kami menggunakan dua petunjuk.

01:40.500 --> 01:43.150
Jadi mari kita bicara tentang contoh di mana ini bisa masuk akal.

01:43.960 --> 01:44.950
Sebuah contoh.

01:45.100 --> 01:45.410
BAIK.

01:45.440 --> 01:52.160
Jadi, tulis fungsi yang disebut Sum Nol yang menerima array bilangan bulat yang disortir sehingga perlu

01:52.220 --> 01:59.360
disortir bukan yang diurutkan tetapi untuk mengurutkan dari terendah ke tertinggi, fungsi harus menemukan pasangan pertama di

01:59.360 --> 02:00.990
mana jumlahnya nol.

02:01.040 --> 02:07.270
Jadi pasangan pertama di mana Anda mengambil satu nomor dan Anda menambahkannya ke nomor lain dan sama dengan nol

02:07.280 --> 02:09.890
Jadi Anda bisa lihat di sini Anda tahu negatif tiga.

02:09.890 --> 02:11.550
Pertama-tama ini adalah array yang diurutkan.

02:11.570 --> 02:13.420
Negatif 3 hingga positif 3.

02:13.490 --> 02:17.450
Dan dalam hal ini negatif tiga tambah tiga memberi kita nol.

02:17.630 --> 02:20.810
Jadi kami mengembalikan pasangan itu dalam array.

02:20.810 --> 02:25.520
Kalau tidak seperti dalam kasus ini tidak ada pasangan yang berjumlah nol.

02:25.520 --> 02:27.000
Jadi kami kembali tidak terdefinisi.

02:27.050 --> 02:28.380
Hal yang sama di sini.

02:28.400 --> 02:30.100
Jadi bagaimana Anda akan mendekati ini.

02:30.110 --> 02:33.750
Pertama-tama, penting untuk dicatat dan ingat dia sering memukul kita, tetapi hal itu diurutkan.

02:33.770 --> 02:39.040
Jika tidak disortir maka kita agak kurang beruntung sejauh datang dengan solusi yang efisien.

02:39.050 --> 02:43.280
Tapi itu diurutkan dan kami sedang mencari sesuatu yang berjumlah nol.

02:43.550 --> 02:49.520
Jadi kita tahu bahwa kita memiliki angka kecil di sini dan angka terbesar ada di sini dan

02:49.520 --> 02:56.990
karena itu kita dapat menggunakan dua petunjuk dan menguji jenis kondisi tertentu untuk melihat apakah kita ingin bergerak ke bawah atau

02:56.990 --> 02:59.250
ingin memindahkan pointer kita ke atas.

02:59.250 --> 03:01.820
Tapi pertama-tama izinkan saya menunjukkan solusi naif.

03:01.850 --> 03:06.910
Ini adalah yang lebih sederhana yang memiliki kompleksitas waktu semua waktu kuadratik antiquark.

03:07.160 --> 03:12.620
Dan Anda dapat melihat langsung dari kelelawar kami memiliki dua loop, kami menggunakan satu untuk loop dan yang kedua untuk loop.

03:12.620 --> 03:18.320
Jadi yang dilakukan adalah mulai menunjuk ke negatif 3 dan kemudian kita memiliki loop

03:18.320 --> 03:21.160
kedua yang beralih ke seluruh array.

03:21.160 --> 03:27.780
Seluruh sisa string mencari struktur yang menambah negatif 3 dan sama dengan nol.

03:27.830 --> 03:29.610
Jadi mencari tiga.

03:29.780 --> 03:32.930
Jadi kami melewati semua dan kami kebetulan menemukan tiga.

03:32.970 --> 03:40.130
Dan itulah contoh sederhana tapi bayangkan ada tiga di sini maka kita akan beralih ke negatif 2 dan

03:40.130 --> 03:43.490
melihat seluruh array untuk menemukan negatif 2

03:43.550 --> 03:48.810
Dan jika kita berbicara tentang item array 10.000 yang banyak iterasi ketika kita memiliki loop bersarang ini.

03:48.890 --> 03:50.180
Tapi ini cara paling sederhana.

03:50.240 --> 03:54.290
Anda mulai di sini dan kemudian Anda membandingkannya dengan setiap angka lainnya dan kemudian jika tidak

03:54.290 --> 03:58.750
ada kecocokan yang sama dengan nol Anda bergerak maju dan membandingkannya dengan setiap angka lainnya dan terus berjalan.

03:58.970 --> 04:00.860
Jadi inilah contoh versi naifnya.

04:00.890 --> 04:01.570
Itu berhasil.

04:01.610 --> 04:02.690
Jika saya menjalankan ini.

04:02.750 --> 04:06.350
Jadi kita punya negatif untuk negatif 3 dan seterusnya kita akan mulai di sini.

04:06.420 --> 04:07.480
Kami mencari kecocokan.

04:07.490 --> 04:10.130
Tidak ada yang lebih dari kita harus mendapatkan tiga.

04:10.130 --> 04:11.260
Tidak ada yang cocok.

04:11.300 --> 04:13.240
Kami membandingkan semua hal yang berbeda ini.

04:13.370 --> 04:19.460
Kami mendapatkan negatif 2 dan kami membandingkannya dengan setiap item lainnya hingga kami mencapai 2 dan kami menemukan kecocokan.

04:19.460 --> 04:25.760
Jadi bahkan dalam kasus ini kami harus melakukan banyak operasi untuk mencari tahu tidak ada yang cocok untuk negatif

04:25.950 --> 04:27.260
untuk negatif 3.

04:27.290 --> 04:30.400
Kita harus melakukan banyak operasi dan ini adalah array kecil.

04:30.740 --> 04:35.750
Jadi ini bisa mendapat manfaat dari refactor menggunakan pola multiple pointer.

04:35.750 --> 04:37.000
Jadi, inilah cara kerjanya.

04:37.070 --> 04:43.310
Kami akan memulai sebuah penunjuk di sini dan memulai yang lain di sini karena kami tahu bahwa ini adalah

04:43.550 --> 04:49.030
angka kecil dan ini adalah angka terbesar dan kami mulai dengan hanya melihat jumlah yang ditambahkan.

04:49.130 --> 04:54.200
Nah negatif empat ditambah lima itu akan memberi kita angka positif yaitu 1 dan itu terlalu besar.

04:54.200 --> 04:55.460
Kami sedang mencari 0.

04:55.490 --> 04:56.970
Jadi satu lebih besar dari nol.

04:56.990 --> 04:58.110
Bukan itu yang kita inginkan.

04:58.370 --> 05:04.730
Jadi apa yang akan kita lakukan adalah memindahkan pointer ini ke 2 karena ini adalah jumlah kecil yang akan

05:04.730 --> 05:05.610
kita dapatkan.

05:05.630 --> 05:09.490
Jadi mungkin hanya ada empat di sini tapi tidak.

05:09.680 --> 05:14.360
Tetapi kode kita tidak tahu bahwa itu akan terlihat di bawah dan berharap bahwa sekarang kita akan menjumlahkan

05:14.360 --> 05:15.020
ke nol.

05:15.080 --> 05:17.550
Jadi kami menambahkan empat negatif ke dalam.

05:17.760 --> 05:22.460
Nah kali ini terlalu kecil karena itu negatif juga dan itu kurang dari nol.

05:22.700 --> 05:27.500
Jadi itu berarti kita akan menambahkan satu ke sisi kiri karena tidak ada kecocokan untuk negatif empat.

05:27.500 --> 05:29.160
Ingat itu adalah array yang diurutkan.

05:29.450 --> 05:30.320
Jadi kita naik.

05:30.320 --> 05:32.810
Sekarang kita melihat negatif tiga dalam dua.

05:33.070 --> 05:35.540
Yah kita tambahkan mereka bersama itu masih negatif 1.

05:35.660 --> 05:40.570
Janganlah masih negatif 1 itu masih negatif itu negatif 1 yang kurang dari nol.

05:40.580 --> 05:46.740
Jadi apa artinya itu adalah bahwa kita akan mencoba dan menambahkan satu ke sisi kiri yang memberi kita 2 negatif.

05:47.060 --> 05:51.310
Dan sekarang kita tambahkan negatif 2 dan 2 dan kita mendapatkan nol.

05:51.410 --> 05:52.850
Dan itu adalah pasangan pertama.

05:52.850 --> 05:55.060
Dan kami kembali negatif ke komentar 2.

05:55.370 --> 06:01.280
Jadi CARA CARA operasi yang lebih sedikit dibandingkan dengan menggunakan loop bersarang dan mulai di sini melihat setiap nomor

06:01.280 --> 06:04.410
lainnya kemudian pindah ke sini melihat setiap nomor lainnya.

06:04.490 --> 06:11.140
Dan ini adalah contoh sederhana di mana kami menemukannya relatif cepat karena hanya ada apa angka 7 ish.

06:11.150 --> 06:12.100
Saya tidak menghitungnya.

06:12.170 --> 06:12.900
Apakah ini 8?

06:12.980 --> 06:13.310
BAIK.

06:13.310 --> 06:14.180
Itu 8.

06:14.600 --> 06:19.160
Jadi sangat kecil dibandingkan dengan 10.000 item di mana itu akan menghemat banyak waktu.

06:19.160 --> 06:25.580
Jadi di sini adalah solusi refactored di mana kita memiliki dua pointer satu mulai dari indeks kiri 0 dan

06:25.580 --> 06:29.480
yang lainnya mulai dari indeks terakhir dalam panjang array minus 1.

06:30.020 --> 06:32.310
Dan saya akan membawa Anda ke kode sebentar lagi.

06:32.420 --> 06:37.890
Tetapi Anda dapat melihat kompleksitas waktu linear itu lebih baik daripada 0 kuadrat.

06:37.910 --> 06:42.470
Jadi, inilah versi refactored dan kami tinggal nol.

06:42.560 --> 06:43.070
Kanan.

06:43.080 --> 06:48.220
Setel panjang array minus satu sehingga kiri akan menjadi indeks nol ini.

06:48.400 --> 06:48.770
Kanan.

06:48.790 --> 06:50.650
Apakah indeks ini ada di sini.

06:50.920 --> 06:52.650
Ini adalah array yang sedikit berbeda.

06:52.690 --> 06:53.980
Saya menempatkan 10 di sini.

06:53.980 --> 06:58.020
Sekarang sepertinya pasangan pertama kita harus negatif 3 3.

06:58.540 --> 07:03.110
Jadi kita mulai dan kita periksa jumlah array kiri dan array kanan.

07:03.220 --> 07:08.710
Jadi negatif empat dari 10 yang akan memberi kita 6 dan kita periksa dulu apakah 0.

07:08.740 --> 07:09.810
Karena kita sudah selesai.

07:10.060 --> 07:11.050
Bukan itu.

07:11.050 --> 07:15.610
Jadi, jika beberapa lebih besar dari nol yang kita akan kurangi satu dari kanan.

07:15.640 --> 07:19.840
Jadi benar adalah indeks ini yang saya tidak akan menghitung posisi saya tetapi kita kurangi 1.

07:19.990 --> 07:25.930
Jadi sekarang kita melihat tempat ini 3 dan kita menambahkan 3 ke negatif 4 jadi kita mulai loop lagi karena

07:25.930 --> 07:27.120
tidak ada yang terjadi

07:27.150 --> 07:30.440
Anda memiliki if dan else jika di yang lain hanya satu yang akan berjalan.

07:30.490 --> 07:34.090
Jadi kami mengurangi satu dari kanan bergerak ke sini dan mulai lagi.

07:34.090 --> 07:39.530
Jadi sekarang jumlah sama dengan negatif 4 dan 3 yang negatif 1 sekarang.

07:39.790 --> 07:41.310
Jadi kali ini bukan nol.

07:41.410 --> 07:42.720
Tidak lebih besar dari nol.

07:42.940 --> 07:46.620
Jadi ini berjalan lain yang berarti kita menambahkan satu ke kiri kita.

07:46.690 --> 07:49.180
Jadi sekarang dibiarkan bergerak ke negatif 3.

07:49.210 --> 07:54.190
Lain kali melalui beberapa negatif tiga dan tiga yang memberi kita nol dan kita selesai.

07:54.280 --> 08:00.460
Jika jumlah adalah zero return array array kolom kiri kanan sebagai array array baru.

08:00.760 --> 08:02.220
Dan hanya untuk membuktikan bahwa itu berhasil.

08:02.360 --> 08:04.940
Di sana kita pergi negatif 3 koma 3.

08:05.230 --> 08:12.370
Dan jika kita memberikannya sesuatu yang tidak memiliki pasangan seperti mari kita hapus angka 3 itu dan

08:12.370 --> 08:13.850
ubah menjadi 5.

08:14.200 --> 08:15.660
Tidak ada pasangan di sini sekarang tidak.

08:15.670 --> 08:16.870
Kami punya satu yang negatif.

08:16.960 --> 08:17.820
Hapus yang itu.

08:17.980 --> 08:18.510
BAIK.

08:18.550 --> 08:22.560
Seharusnya tidak ada pasangan sekarang dan kami tidak terdefinisi sebagaimana seharusnya.

08:22.690 --> 08:27.940
Jadi kami berhenti karena loop sementara kami berjalan dengan baik ke kiri kurang dari kanan.

08:27.940 --> 08:33.940
Jadi jika mereka berpotongan pada beberapa titik, itu berarti kami telah menghabiskan semua pasangan yang mungkin. Kami sudah mencoba di sini dan di

08:33.940 --> 08:35.080
sini, itu tidak berhasil.

08:35.110 --> 08:37.360
Itu terlalu besar sehingga kami mengurangi satu dari kanan.

08:37.360 --> 08:38.960
Kami mencoba lima dan negatif empat.

08:39.010 --> 08:39.760
Masih terlalu besar.

08:39.760 --> 08:45.910
Jadi kami pergi ke nol dan negatif untuk terlalu kecil jadi pergi ke negatif 3 dan nol dua kecil menjadi negatif 2

08:45.910 --> 08:49.250
dan 0 dua kecil dan dua negatif adalah nol terlalu kecil.

08:49.330 --> 08:56.140
Jadi kita pergi 0 0 dan kita harus berhenti sebelum ada sebaliknya jika kita mencoba dan apakah Anda tahu nol minus

08:56.140 --> 08:58.210
nol Apa yang akan kita dapatkan.

08:58.420 --> 08:58.940
Nol.

08:58.960 --> 09:00.090
Itulah yang kami cari.

09:00.100 --> 09:01.780
Tapi itu positif palsu.

09:01.830 --> 09:08.050
Dan jika bukan nol, itu bisa merupakan angka lain yang kita kurangi sendiri atau kurangi sendiri.

09:08.050 --> 09:08.920
Kita akan mendapat nol.

09:08.980 --> 09:13.900
Jadi kita harus berhenti di sana dan itu sebabnya kita memiliki kiri kurang dari kanan daripada kurang

09:13.900 --> 09:15.490
dari atau sama dengan kanan.

09:15.520 --> 09:16.930
Jadi kita harus memilikinya.

09:17.050 --> 09:18.180
Itu failafe kami.

09:18.430 --> 09:22.540
Dan itu berarti bahwa kita sudah selesai dan kita bisa secara eksplisit mengembalikan yang tidak ditentukan pada akhirnya.

09:22.600 --> 09:24.080
Tapi ini juga berfungsi dengan baik.

09:24.520 --> 09:24.850
Ya.

09:24.850 --> 09:30.400
Jadi itu menggunakan dua pointer dalam hal ini bekerja dari sisi paling kiri dan sisi paling kanan

09:30.400 --> 09:31.250
menuju tengah.

09:31.300 --> 09:32.740
Itu bukan satu-satunya cara melakukannya.

09:32.740 --> 09:38.050
Selanjutnya saya akan menunjukkan masalah di mana kita benar-benar mulai dari sisi yang sama dan hanya melihat ke depan daripada pergi

09:38.050 --> 09:39.860
dari kiri dan kanan secara bersamaan.

09:39.880 --> 09:42.000
Kami hanya memiliki dua petunjuk di sisi kiri.

09:42.160 --> 09:42.760
Itu selanjutnya.
