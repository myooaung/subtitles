WEBVTT

00:00.240 --> 00:00.570
Baiklah.

00:00.570 --> 00:03.380
Jadi itu untuk isyarat sangat cepat.

00:03.420 --> 00:07.890
Notasi O Besar harus memasukkan dan menghilangkan waktu secara konstan.

00:07.950 --> 00:09.750
Hanya itu yang penting.

00:09.810 --> 00:14.990
Mencari dan mengakses sesuatu yang benar-benar Anda lakukan dengan isyarat. Jika tidak, Anda mungkin tidak ingin

00:14.990 --> 00:18.210
menggunakan struktur data Q jika Anda perlu memprioritaskan pencarian.

00:18.210 --> 00:23.640
Secara umum yang Anda pedulikan adalah menambahkan hal-hal dengan Q menghapus hal-hal dengan dequeue yang Anda

00:23.640 --> 00:24.850
inginkan super cepat.

00:24.870 --> 00:27.810
Jadi dengan implementasi kami, ini adalah waktu yang konstan.

00:27.810 --> 00:34.380
Perhatikan bahwa ketika kita menggunakan array, itu bukan waktu yang konstan karena dalam kedua iterasi keduanya merupakan solusi yang kami

00:34.380 --> 00:36.200
gunakan atau yang kami hasilkan.

00:36.270 --> 00:40.440
Menggunakan metode Array bawaan ada kaskade pengindeksan ulang.

00:40.500 --> 00:45.930
Sehingga tidak mengarah ke waktu yang konstan dan waktu yang linier bukan yang kita inginkan.

00:46.110 --> 00:52.410
Kami ingin waktu yang konstan dan ini adalah sama untuk tumpukan tumpukan dan antrian untuk struktur menambahkan hal-hal dalam

00:52.500 --> 00:55.590
menghapusnya pesanan yang berbeda dan bagaimana mereka sebenarnya bekerja.

00:55.710 --> 01:00.140
Tetapi baik menambah dan menghapus harus waktu konstan 0 dari 1.

01:00.690 --> 01:05.660
Jadi untuk rekap pada antrian, mereka masuk pertama keluar seperti di bandara.

01:05.760 --> 01:08.380
Orang pertama yang masuk adalah orang pertama yang keluar.

01:08.490 --> 01:12.020
Kecuali jika Anda dipilih untuk pemutaran tambahan dalam hal ini Anda tidak akan menjadi yang terakhir keluar.

01:12.180 --> 01:15.120
Tetapi biasanya orang pertama yang antri keluar terlebih dahulu.

01:15.120 --> 01:19.690
Kontras bahwa dengan tumpukan hal pertama adalah hal terakhir yang keluar.

01:19.710 --> 01:21.680
Jadi sering digunakan antrian.

01:21.690 --> 01:27.090
Kapan saja Anda perlu melacak pesanan dan mempertahankan pesanan itu sehingga hal pertama dalam antrian cetak

01:27.090 --> 01:28.620
itu adalah contoh klasik.

01:28.620 --> 01:33.150
Hal pertama yang seseorang coba cetak adalah hal pertama yang benar-benar dicetak dan kemudian

01:33.150 --> 01:37.670
hal lain yang menumpuk disimpan dalam urutan yang ditambahkan dan kemudian kita hapus.

01:37.830 --> 01:41.130
Kami mencetak hal-hal yang telah menunggu paling lama.

01:41.150 --> 01:47.640
OK sangat berguna untuk memproses tugas dan juga mendasar untuk algoritma dan struktur data lain yang lebih kompleks

01:47.640 --> 01:49.660
yang akan kita lihat nanti.

01:49.860 --> 01:55.440
Seperti yang saya sebutkan kami akan menggunakan tumpukan dan Qs nanti dalam kursus untuk membantu kami

01:55.650 --> 02:02.760
menerapkan struktur data yang lebih rumit dan algoritma sehingga mereka bukan hanya hal baru untuk menunjukkan kepada Anda mereka akan muncul kembali.

02:02.760 --> 02:05.750
Dan seperti saya katakan penyisipan dan penghapusan harus.

02:05.790 --> 02:09.840
Jadi saya katakan itu bisa dilakukan dalam waktu yang konstan dalam tumpukan yang baik dan antrian yang baik.

02:09.840 --> 02:12.900
Itu harus dinyatakan hanya membuang-buang.

02:12.900 --> 02:16.140
Mengapa bahkan menggunakan tumpukan atau antrian saja.

02:16.470 --> 02:18.270
Itu untuk tumpukan dan antrian.

02:18.360 --> 02:20.160
Sangat mirip dalam banyak hal.

02:20.160 --> 02:25.980
Menambahkan dan menghapus hal-hal waktu konstan sangat berbeda dalam urutan masuk dan keluar pertama untuk antrian.

02:25.980 --> 02:28.420
Last In First Out untuk tumpukan.

02:28.480 --> 02:30.540
Ok lihat di bagian selanjutnya.
