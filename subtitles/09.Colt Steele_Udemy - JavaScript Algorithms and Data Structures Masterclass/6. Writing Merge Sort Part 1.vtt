WEBVTT

00:00.090 --> 00:01.220
Hai, selamat datang kembali.

00:01.230 --> 00:04.000
Jadi sekarang kita sampai pada bagian penyortiran penggabungan.

00:04.110 --> 00:07.620
Dan ini sebenarnya kodenya sendiri cukup singkat.

00:07.620 --> 00:10.550
Hanya saja solusi saya adalah garis 5 ish.

00:10.680 --> 00:17.120
Masalahnya adalah bahwa secara konseptual agak sulit untuk dipahami dan itu karena sebagian besar menggabungkan implementasi semacam

00:17.130 --> 00:18.430
untuk menggunakan rekursi.

00:18.450 --> 00:22.740
Jadi, jika Anda melewatkan bagian rekursi, saya sangat menyarankan Anda melihat itu karena

00:22.740 --> 00:24.560
ini akan tampak sedikit gila.

00:24.570 --> 00:30.240
Jika Anda belum pernah melihat rekursi sebelumnya dan bahkan jika Anda memilikinya, tidak langsung intuitif untuk menulis

00:30.720 --> 00:31.890
kode yang rekursif.

00:32.070 --> 00:33.030
Jadi, inilah cara kerjanya.

00:33.030 --> 00:36.170
Kami memiliki fungsi gabungan yang berfungsi.

00:36.180 --> 00:37.500
Kami hanya menganggap itu berfungsi pada saat ini.

00:37.500 --> 00:42.650
Jika Anda tidak menulisnya, buka video salin kode terakhir jika Anda ingin mencoba dan menerapkannya

00:42.650 --> 00:43.040
sendiri.

00:43.050 --> 00:45.060
Tetapi sekali lagi jangan merasa buruk jika Anda tidak bisa.

00:45.060 --> 00:50.550
Ini benar-benar tentang konsep cara kerjanya bukan tentang Anda bisa menulisnya dari awal segera mendapatkan semacam

00:51.220 --> 00:54.890
penggabungan. Kami memiliki fungsi penggabungan mengambil dua array yang diurutkan.

00:54.900 --> 00:59.570
Sekarang ingat tujuannya adalah pada dasarnya terus menyapu array menjadi dua.

00:59.640 --> 01:03.420
Jadi bagaimana kita memecah array hanya satu array menjadi setengah dua bagian.

01:03.420 --> 01:04.400
Berpikir tentang itu.

01:04.410 --> 01:10.420
Rekomendasi saya adalah menggunakan slice to array slice dan Anda beralih dari nol hingga teori tengah.

01:10.650 --> 01:14.190
Dan kemudian Anda pergi dari array tengah hingga nol dan itu memberi Anda dua bagian.

01:14.190 --> 01:16.600
Lalu apa yang akan Anda lakukan dengan masing-masing bagian itu.

01:16.820 --> 01:22.290
Welp Anda akan memanggil semacam penggabungan lagi dan Anda akan memecah masing-masing bagian menjadi dua dan

01:22.290 --> 01:24.060
terus berjalan secara rekursif.

01:24.210 --> 01:30.360
Dan sekali kasus dasar kami ketika array panjangnya kurang dari atau sama dengan satu artinya 1

01:30.360 --> 01:31.200
atau 0.

01:31.550 --> 01:31.880
BAIK.

01:31.890 --> 01:38.520
Sehingga memecah mereka semua menjadi elemen-elemen kecil ini array yang lebih kecil menggunakan irisan Intel secara rekursif.

01:38.580 --> 01:43.500
Sekali lagi kasus dasar kami adalah kami menekan panjang akhir kurang dari atau sama dengan 1.

01:43.590 --> 01:50.250
Kemudian setelah kita memiliki array kecil itu, kita menggabungkan mereka kembali menggunakan fungsi gabungan kita yang sudah kita

01:50.250 --> 01:50.970
tulis.

01:51.240 --> 01:55.010
Sampai kita kembali pada panjang penuh array sekarang tampaknya sederhana.

01:55.020 --> 01:59.970
Ketika Anda menulisnya dengan cara ini tetapi kode itu menjadi membingungkan ketika Anda menulisnya secara

01:59.970 --> 02:00.520
rekursif.

02:00.750 --> 02:01.840
Tapi itu sudah cukup.

02:01.950 --> 02:06.230
Jadi begitu array telah digabungkan kembali bersama-sama, kami mengembalikan array yang digabungkan di akhir.

02:06.770 --> 02:10.350
OK jadi jika Anda ingin mengambil bacokan ini pasti melakukannya.

02:10.350 --> 02:12.670
Namun dalam video berikutnya saya akan melewatinya.

02:12.690 --> 02:15.270
Ingat rekursi itu agak gila.

02:15.360 --> 02:17.280
Ini bisa menjadi sedikit lompatan untuk sampai ke sana.

02:17.310 --> 02:19.410
Jadi, jangan merasa buruk jika Anda tidak bisa mendapatkan yang ini.

02:19.620 --> 02:20.000
BAIK.

02:20.010 --> 02:20.910
Lihat di video berikutnya.
