WEBVTT

00:00.390 --> 00:00.780
Baiklah.

00:00.780 --> 00:01.530
Selamat datang kembali.

00:01.650 --> 00:06.980
Jadi jika saya membuat cuplikan baru, jika tidak, pada dasarnya melakukan semuanya sama, saya memiliki kode yang sama.

00:07.080 --> 00:10.820
Anda dapat memperolehnya dari slide beberapa video yang lalu, kami membicarakan hal ini jika Anda ingin

00:10.850 --> 00:12.130
mengikuti dengan grafik yang sama.

00:12.270 --> 00:18.620
Jadi saya akan mulai dengan menentukan napas pertama di sini yang membutuhkan titik awal.

00:18.660 --> 00:26.700
Sebut saja mulai dan kemudian kita perlu mendefinisikan beberapa variabel sehingga kita dapat membuat Q saya sebagai array

00:26.700 --> 00:31.620
kosong dan saya hanya akan menambahkan mulai keluar langsung dari gerbang.

00:31.620 --> 00:36.910
Kita perlu membuat hasil, kita bisa menyalin ini dari atas semua ini.

00:37.170 --> 00:43.470
Jika Anda menonton video sebelumnya dan variabel saya mengunjungi untuk melacak apa yang bisa kita lakukan,

00:43.470 --> 00:51.180
maka kita akan mengulang sementara q memiliki panjang dan hal pertama yang kita lakukan adalah menghapus simpul pertama dalam antrian

00:51.180 --> 00:52.340
dari awal.

00:52.350 --> 00:55.590
Jadi alih-alih Pop kita akan melakukan shift.

00:55.650 --> 01:02.670
Jadi qued shift dan disimpan dalam sebuah variabel dan kita bisa mendefinisikan variabel di sini saya akan menyebutnya vertex saat ini seperti

01:02.670 --> 01:04.940
yang kita lakukan di video terakhir.

01:05.220 --> 01:11.700
Tapi saya sebenarnya tidak akan mendefinisikan ulang dalam satu lingkaran akan memindahkannya ke sini dan kemudian mengaturnya

01:12.030 --> 01:15.230
di sini jadi menginisialisasi sekali mengaturnya dan memperbaruinya.

01:15.400 --> 01:16.120
BAIK.

01:16.230 --> 01:23.140
Dan kemudian kita akan mengunjungi simpul yang berarti hasil mendorong titik saat ini.

01:23.190 --> 01:29.530
Jadi jika kita mengeluarkan item pertama dan kemudian kita dorong ke array kita bahwa kita kembali di akhir.

01:29.550 --> 01:33.120
Sekarang bagian yang sedikit rumit kita harus pergi ke semua tetangganya.

01:33.540 --> 01:38.000
Jadi itu daftar kedekatan Virtex saat ini.

01:38.580 --> 01:43.470
Dan kemudian untuk masing-masing untuk setiap Naver.

01:43.980 --> 01:50.550
Tetapi kita akan melakukannya dengan baik, kita akan memeriksa apakah sudah dikunjungi atau sebenarnya kita akan

01:50.550 --> 01:52.590
memeriksa apakah belum dikunjungi.

01:52.590 --> 01:53.560
Itulah yang kami pedulikan.

01:53.640 --> 01:57.420
Karena jika belum dikunjungi maka kita perlu pasar telah mengunjungi hanya

02:00.180 --> 02:03.570
setel itu menjadi kenyataan dan kita perlu mendorongnya ke antrian

02:06.420 --> 02:08.250
dan kita sudah selesai

02:08.670 --> 02:11.130
Jadi pada akhirnya kita perlu mengembalikannya. Itu semacam kebohongan.

02:11.130 --> 02:13.350
Kita belum selesai sekarang.

02:14.130 --> 02:22.140
Jadi cara yang satu ini bekerja jika kita melangkah sebelum kita bahkan menjalankannya di sini adalah semacam hasil kunjungan kita yang akan

02:22.140 --> 02:24.400
kita miliki di bagian paling akhir.

02:24.510 --> 02:27.220
Dan inilah Q kita. Mari kita lakukan seperti ini.

02:27.510 --> 02:28.310
Baik.

02:29.530 --> 02:36.190
Sempurna Kita mulai dengan menambahkan ke antrian dan kemudian kita menghapusnya hal pertama dan menambahkannya ke hasil dan

02:36.190 --> 02:38.310
kemudian kita pergi ke tetangganya.

02:38.370 --> 02:41.670
Daftar kedekatan A untuk masing-masing.

02:41.710 --> 02:48.660
Jadi ada dua hal dalam daftar itu ada B dan ada C dan kami mengambil yang pertama.

02:48.880 --> 02:53.950
Jika kita jika kita benar-benar melihat daftar B datang tetapi sebelum C karena saya menambahkan koneksi itu terlebih dahulu.

02:54.280 --> 03:02.200
Jadi kita akan menambahkan B ke Q kita dan kita juga akan menambahkan c ke dalam Q Dan kemudian loop

03:02.200 --> 03:05.440
dimulai dan kita ambil dari awal kita bergeser.

03:05.590 --> 03:08.570
Jadi kami menghapus B dan menambahkannya di sini.

03:09.130 --> 03:13.090
Jika saya bisa mengetik dan kemudian kita tambahkan tetangganya.

03:13.180 --> 03:18.490
Jadi kami memutari tetangganya atau A&amp;E akan a telah dikunjungi sehingga kami mengabaikannya.

03:18.490 --> 03:27.490
Jadi kita tambahkan d ke akhir di sini dan kemudian kita hapus dari awal yang memberi kita c jadi kita tambahkan c ke

03:27.490 --> 03:28.460
dalam hasilnya.

03:28.550 --> 03:31.570
Dan sekarang kita pergi ke tetangganya apa yang sudah pernah kita kunjungi.

03:31.660 --> 03:33.100
Jadi sekarang kita harus pergi makan.

03:33.370 --> 03:36.870
Jadi kami memiliki setelah D dalam antrian.

03:36.880 --> 03:39.470
Ingat pertama masuk pertama keluar.

03:39.940 --> 03:50.520
Jadi kami mengambil dan mengunjungi kembali D dan kami pergi ke tetangga DS kami sudah pernah jadi kami tidak menambahkan itu.

03:50.590 --> 03:51.910
Kami sudah pernah ke e.

03:51.950 --> 03:55.620
Ya setidaknya dalam antrian dan saat itulah kami memasarkan.

03:55.630 --> 03:58.680
Ingat kami menambahkan setelah pemasaran ulang dikunjungi.

03:59.040 --> 03:59.650
BAIK.

03:59.920 --> 04:01.990
Jadi yang tersisa adalah f ..

04:02.380 --> 04:10.840
Jadi kita tambahkan F dan sekarang kita ambil itu dari awal dengan shift kita taruh di sini dan kemudian kita akan

04:10.840 --> 04:12.520
pergi ke tetangganya.

04:12.550 --> 04:15.080
Kami sudah mengunjungi mereka semua sehingga kami tidak benar-benar menambahkan apa pun di.

04:15.430 --> 04:17.040
Dan kami akhirnya tersentuh.

04:17.230 --> 04:19.580
Dan itulah yang kami kehilangan.

04:19.930 --> 04:25.390
Sekarang mari kita lihat apakah saya mengada-ada semuanya atau apakah itu benar-benar

04:25.390 --> 04:32.530
berfungsi dan komentar yang menjalankan kode kita dan kita memiliki grafik titik luasnya mulai dari ABC.

04:32.650 --> 04:35.890
Oh sepertinya ada sedikit masalah di sini.

04:35.890 --> 04:37.180
Ayo lihat.

04:37.540 --> 04:39.130
Saya menemukan masalahnya.

04:39.130 --> 04:40.460
Mungkin Anda melihat pertunjukan ini.

04:40.630 --> 04:46.540
Tapi apa yang tidak kami lakukan di sini adalah menandai sebagai dikunjungi di awal yang sebenarnya ada dalam kode semu

04:46.540 --> 04:46.880
saya.

04:46.930 --> 04:47.820
Dan saya mengabaikannya.

04:47.940 --> 04:51.460
Anda dapat melihat di sini ditandai titik awal sebagai dikunjungi.

04:51.460 --> 04:52.540
Jadi apa yang terjadi di sana.

04:52.570 --> 05:01.110
Kami baru saja mencetak, mari kita lakukan di awal di sini, terus-menerus mencatat antrian dan menjalankan

05:01.130 --> 05:06.130
kode saya G dot pertama dari 0 3 berjalan.

05:06.180 --> 05:07.260
Baiklah, kita mulai.

05:07.530 --> 05:13.110
Kita mulai dengan di sana tetapi saya tidak memasarkan seperti yang dikunjungi di objek yang saya kunjungi.

05:13.140 --> 05:14.810
Jadi kita pergi mengeluarkannya.

05:14.820 --> 05:20.250
Kami menambahkan ke hasil kami memiliki anak-anak dari tetangga B dan C kemudian kami mengambil B.

05:20.540 --> 05:23.460
Tapi B sebenarnya punya dua tetangga, benar.

05:23.490 --> 05:24.250
Memang.

05:24.360 --> 05:26.740
Tetapi kami tidak menandai sebagai dikunjungi pertama kali.

05:26.880 --> 05:31.540
Jadi kita tambahkan kembali dan kemudian kita tambahkan D dan kemudian kita lanjutkan dari sana.

05:31.680 --> 05:34.040
Itu tidak benar karena kita mulai seperti itu.

05:34.380 --> 05:39.230
Jadi jika kami mengunjungi pasar Anda akan melihat pada akhirnya kami memiliki di sana dua kali.

05:39.230 --> 05:40.260
Itu tidak baik.

05:40.260 --> 05:42.300
Jadi pasar kami kunjungi di sini.

05:42.480 --> 05:48.000
Yah hanya dua yang dikunjungi dari awal sama dengan benar sempurna.

05:48.120 --> 05:57.210
Anda juga bisa mengatur bahwa di sini mengunjungi D dan sekarang jika kita menyimpan log konstan itu jalankan kembali kode kita

05:57.870 --> 06:04.840
berakhir dengan b cd f di akhir karena tidak pernah ditambahkan kembali dan semuanya bekerja.

06:05.050 --> 06:06.090
Baiklah.

06:06.090 --> 06:08.080
Jadi mari kita singkirkan log konstan itu.

06:08.330 --> 06:22.320
Jika kita pergi sekali lagi untuk membaca pencarian pertama dari a b c d e f yang berarti pergi ke b ke c d e

06:22.650 --> 06:25.040
f yang Brett pertama.

06:25.080 --> 06:27.710
OK jadi kita akan pergi dari kiri ke kanan.

06:27.780 --> 06:32.940
Anda dapat memikirkannya dengan urutan apa pun yang ada di tepinya atau di daftar adjacency yang akan kita buka dari

06:33.000 --> 06:34.350
awal daftar hingga akhir.

06:34.650 --> 06:44.040
Jadi saya menambahkan B sebelum c jadi kami mengunjungi B C dan kemudian D sebelum E dan kemudian f Anda bisa mengubahnya

06:44.040 --> 06:45.970
jika Anda benar-benar ingin.

06:46.050 --> 06:49.230
Tidak ada yang mudah sejauh yang saya tahu tidak ada jalan pintas untuk mundur.

06:49.380 --> 06:54.250
Untuk setiap beberapa bahasa Anda dapat Anda tahu cukup tentukan Saya ingin mengulang array ini ke belakang.

06:54.630 --> 06:58.950
Tetapi cara mudah semacam itu hanya untuk menunjukkan kepada Anda jika kami melakukan ini.

06:58.950 --> 07:01.290
Jadi saya mulai mundur dan saya menjalankan kode.

07:01.290 --> 07:10.050
Sekarang Anda akan melihat kita mulai dari tetapi sekarang pergi ke C dan kemudian B dan kemudian E dan kemudian D dan kemudian f.

07:10.050 --> 07:15.570
Jadi daripada b c seperti kiri ke kanan kiri atau kanan kita akan kanan ke kiri.

07:15.570 --> 07:16.530
Masih bernafas dulu.

07:16.530 --> 07:17.850
Sama seperti dengan kedalaman dulu.

07:17.880 --> 07:19.380
Kami memiliki pesanan yang berbeda.

07:19.410 --> 07:20.430
Hal yang sama di sini.

07:20.640 --> 07:25.500
Dan saya ingin menjadi jelas bahwa tidak hanya ada dua pesanan, ini bisa menjadi grafik yang jauh

07:25.560 --> 07:31.350
lebih besar dan kami dapat meminta Anda untuk mengetahui lima tetangga dalam hal ini bukan hanya b c atau C B.

07:31.350 --> 07:34.160
Akan ada lima dua atau tiga tetangga lain yang perlu dikhawatirkan.

07:34.350 --> 07:34.620
BAIK.

07:34.630 --> 07:35.620
Jadi itu luasnya dulu.

07:35.640 --> 07:41.690
Semoga Anda bisa melihatnya sangat mirip dengan yang kami lakukan dengan solusi iteratif pertama yang mendalam.

07:41.760 --> 07:46.000
Sekarang kita memiliki semua ini dari cara kita dapat mengunjungi setiap titik tunggal dalam grafik.

07:46.110 --> 07:51.080
Kita harus membahas hal-hal menyenangkan yang berhubungan dengan algoritma jalur terpendek.

07:51.120 --> 07:55.260
Ini adalah penggunaan yang sangat penting atau hal yang sangat penting untuk dapat dilakukan

07:55.260 --> 08:01.140
dengan grafik dan salah satu hal yang paling umum dilakukan dalam semua jenis aplikasi apakah kita berbicara tentang Uber, kita

08:01.140 --> 08:04.920
sedang berbicara tentang Google Maps atau sedang kita bicarakan Hasil pencarian Google.

08:04.920 --> 08:07.310
Ini bukan hanya peta barang dan GPS.

08:07.410 --> 08:08.960
Jadi kita akan membicarakannya sebentar lagi.
