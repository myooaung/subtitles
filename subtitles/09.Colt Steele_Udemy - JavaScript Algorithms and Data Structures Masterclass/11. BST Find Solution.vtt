WEBVTT

00:00.320 --> 00:04.560
Sudah mari kita implementasikan find pada kelas B S T kami.

00:04.620 --> 00:11.790
Jadi hal pertama yang akan kita lakukan adalah menambahkan metode find yang menerima nilai dan kita memiliki beberapa optimasi yang

00:12.000 --> 00:13.960
dapat kita lakukan di akhir.

00:13.950 --> 00:16.100
Tetapi saya hanya akan memulai dengan mengikuti ini.

00:16.140 --> 00:18.210
Kami akan memeriksa apakah ada rute.

00:18.330 --> 00:19.780
Jadi itu sederhana.

00:19.860 --> 00:27.780
Jika rute ini tidak ada maka kita hanya akan mengembalikan apa yang kita inginkan dengan false yang tidak terdefinisi kembali.

00:28.080 --> 00:31.390
Anggap saja kita ingin ini benar atau salah.

00:31.410 --> 00:34.370
Jadi kita akan mengatakan bahwa itu mengembalikan benar atau salah.

00:34.380 --> 00:39.690
Jadi jika tidak ada apa-apa di sana maka kita tidak dapat menemukan nilai yang dikembalikan salah.

00:39.760 --> 00:40.680
Itu bagus.

00:40.770 --> 00:42.910
Jika kita menjalankannya, kita membuat pohon baru.

00:42.930 --> 00:46.330
Sebut saja pohon pencarian biner baru.

00:46.370 --> 00:48.540
Kami tidak menemukannya.

00:48.540 --> 00:49.520
Kita harus salah.

00:49.650 --> 00:51.460
Baiklah jadi itu tidak mungkin.

00:51.480 --> 00:56.910
Sekarang yang akan saya lakukan adalah membuat variabel bernama Start dan saya akan mulai sama dengan root.

00:56.910 --> 00:58.920
Anda juga dapat menyebutnya saat ini.

00:59.060 --> 01:01.250
Saya agak suka saat ini.

01:01.410 --> 01:02.610
Jadi saya tidak akan menyebutnya mulai.

01:02.630 --> 01:09.270
OK dengan saat ini dan kemudian mari kita buat variabel lain dan yang ini akan disebut ditemukan dan itu dimulai

01:09.270 --> 01:10.280
sebagai false.

01:10.350 --> 01:11.940
Jadi ditemukan hanya melacak.

01:11.940 --> 01:13.480
Jika kami sudah menemukan barang itu.

01:13.740 --> 01:18.850
Maka kita perlu sampai ke sebagian besar logika kita yang pada dasarnya melibatkan perulangan.

01:18.900 --> 01:25.850
Jadi saya akan melakukan loop sementara dan kami ingin loop sementara tidak ditemukan jadi sementara kami belum menemukan hal itu.

01:26.280 --> 01:33.020
Tetapi juga sementara ada arus jadi saya akan menjelaskan mengapa hanya sebentar.

01:33.030 --> 01:39.120
Tetapi kami ingin terus berjalan karena jika kami katakan kami tidak pernah menemukannya dengan benar, itu tidak ada di sana.

01:39.120 --> 01:40.920
Ditemukan akan selalu salah.

01:40.950 --> 01:46.230
Jadi kita juga perlu memastikan loop ini tidak berlangsung selamanya sehingga saat ini akan menjadi nilai kami bahwa segera setelah

01:46.230 --> 01:50.970
tidak ada arus setiap kali ada Anda tahu kami telah mencapai ujung pohon kami tidak dapat memperbarui saat

01:50.970 --> 01:51.820
ini sama sekali.

01:51.860 --> 01:54.720
Tidak, maka loop kita akan berhenti.

01:54.720 --> 02:00.350
Jadi pada dasarnya ini adalah sementara ada sesuatu untuk diulang dan kami belum menemukannya apa yang kami lakukan.

02:00.420 --> 02:07.640
Mari kita mulai dengan hanya memeriksa apakah nilainya kurang dari nilai titik saat ini.

02:07.830 --> 02:14.300
Jika dibiarkan kurang dari maka kita akan mengatakan arus sekarang sama dengan kiri saat ini.

02:14.400 --> 02:16.620
Kita tahu bahwa itu harus di sebelah kiri.

02:16.620 --> 02:20.840
Jadi misalnya jika ini adalah pohon yang kita miliki dan kita cari dua.

02:21.240 --> 02:28.530
Nah jika kita melakukan tree up menemukan dua kita akan mengatur arus untuk menyamakan simpul ini dan kemudian menemukan itu

02:28.530 --> 02:29.400
akan salah.

02:29.430 --> 02:33.070
Jadi kami memeriksa 2 kurang dari nilai saat itu benar.

02:33.180 --> 02:35.360
Jadi sekarang yang sekarang adalah ini.

02:35.550 --> 02:37.110
Jadi kita mulai lagi.

02:37.140 --> 02:43.770
Jadi mari kita lakukan hal yang sama dengan nilai LCF lebih besar dari nilai saat ini.

02:43.950 --> 02:51.630
Jika itu yang terjadi saat ini sama dengan saat ini sekarang kita kehilangan bagian terpenting yang mana

02:51.630 --> 02:52.250
lagi.

02:52.380 --> 02:55.730
Jika kami menemukannya kami akan menetapkan ditemukan sama dengan benar.

02:55.740 --> 03:01.530
Jadi ini jika kurang dari ini jika lebih besar dari satu-satunya pilihan lain adalah sama.

03:01.560 --> 03:03.590
Jadi kita akan mengatur ternyata benar.

03:03.720 --> 03:07.450
Dan kemudian loop harus dilakukan karena ini sekarang salah.

03:07.500 --> 03:10.000
Tidak ditemukan tidak benar itu salah.

03:10.230 --> 03:11.090
Jadi kita sudah selesai di sini.

03:11.220 --> 03:14.450
Kemudian setelah loop sementara ini kita harus mengembalikan node.

03:14.550 --> 03:17.330
Yah itu cukup tidak jelas tentang hal ini dalam instruksi.

03:17.340 --> 03:24.470
Saya menyesal bahwa jika Anda harus mengembalikan catatan itu sendiri atau mengembalikan benar atau salah untuk melihat apakah itu berisi, mari

03:25.290 --> 03:26.510
kita mengembalikan simpul.

03:26.520 --> 03:27.990
Jadi itu akan terkini.

03:28.050 --> 03:35.280
Saya minta maaf jika Anda menerapkan satu solusi dan saya melakukan yang sebaliknya di sini, tetapi logikanya sama dengan cara

03:35.280 --> 03:40.460
kami dapat mengembalikan true di sini jika kami menemukannya kami dapat kembali saat ini.

03:40.710 --> 03:41.170
Baik.

03:41.430 --> 03:47.760
Jadi saya akan mengembalikan arus di akhir dan kemudian kami juga ingin memeriksa apakah tidak pernah

03:47.760 --> 03:52.570
menemukan kami harus mengembalikan sesuatu karena sekarang naik tidak berarti melakukan itu.

03:52.650 --> 03:58.730
Jika kami menjalankan kode ini, kami memiliki nilai hierarki yang memiliki semua ini.

03:58.740 --> 04:00.610
Jadi jika saya mencari.

04:00.990 --> 04:05.000
Anda tahu, coba temukan 5 misalnya.

04:05.250 --> 04:05.730
Baik.

04:05.850 --> 04:08.880
Itu di pohon mereka menemukan 10 yang ada di sana.

04:08.960 --> 04:12.400
It Out menemukan waktu ini juga ada di sana.

04:12.510 --> 04:13.030
BAIK.

04:13.170 --> 04:15.000
Tapi bagaimana dengan 100.

04:15.300 --> 04:16.290
Itu tidak ada di sana.

04:16.500 --> 04:20.360
Jadi kita tidak mendapatkan bukan.

04:20.940 --> 04:23.820
Saya pikir akan lebih baik untuk mengembalikan false.

04:24.090 --> 04:27.800
Jadi untuk melakukan itu kita bisa menambahkan pernyataan if di sini.

04:27.900 --> 04:36.820
Jika ternyata tidak ditemukan return false atau sebenarnya saya pikir undefined mungkin lebih baik tetapi tidak terlalu penting.

04:36.840 --> 04:39.520
Tetapi hanya beberapa nilai di sini untuk menunjukkan itu tidak ada di sana.

04:39.720 --> 04:44.010
Dan jika kita ingin jadi adil jika kita ingin melakukan itu.

04:44.160 --> 04:45.260
Versi benar atau salah.

04:45.260 --> 04:50.790
Jadi itu tidak benar-benar mengembalikan simpul itu hanya mengembalikan benar atau salah jadi mungkin saya akan

04:50.850 --> 04:52.280
menyebutnya mengandung nilai.

04:52.290 --> 04:55.970
Ini sedikit lebih sederhana karena jika kita menemukannya kita dapat mengembalikan true.

04:56.430 --> 04:58.330
Dan kita tidak membutuhkan ini di sini.

04:58.350 --> 05:00.750
Kita bisa mengembalikan false OK.

05:00.790 --> 05:03.480
Jadi jika kita menemukannya jika itu sama kita mengembalikan true.

05:03.850 --> 05:06.280
Dan satu-satunya cara kita sampai di sini adalah jika tidak ada di sana.

05:06.280 --> 05:08.000
Jadi kami mengembalikan false.

05:08.020 --> 05:17.830
Jadi jika saya menjalankan ini, Anda akan memperlakukan titik berisi satu yang salah tetapi 10 ada di sana sehingga dua dan 16

05:17.830 --> 05:19.060
saya pikir

05:19.210 --> 05:21.210
Tetapi 18 tidak ada di sana.

05:21.480 --> 05:21.820
BAIK.

05:21.850 --> 05:28.210
Jadi semacam keluar dari bidang kiri tapi saya hanya harus melakukan dua implementasi satu benar atau salah hanya

05:28.210 --> 05:34.450
mengembalikan nilai-nilai yang disebut mengandung yang lain disebut Cari dan itu benar-benar mengembalikan nilai simpul itu sendiri.

05:34.450 --> 05:35.430
Jika ada di sana.

05:35.850 --> 05:36.310
BAIK.
