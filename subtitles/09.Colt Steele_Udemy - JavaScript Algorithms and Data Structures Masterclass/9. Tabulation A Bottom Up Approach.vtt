WEBVTT

00:00.150 --> 00:00.390
Baiklah.

00:00.390 --> 00:01.260
Selamat datang kembali.

00:01.260 --> 00:05.350
Jadi kami berbicara tentang memoisasi yang merupakan salah satu rasa pemrograman dinamis.

00:05.370 --> 00:10.050
Ingatlah seluruh gagasan To name of programming artinya mengambil satu masalah dengan memecahnya menjadi

00:10.050 --> 00:16.740
subproblem yang lebih kecil dan memastikan bahwa kami menyelesaikan masing-masing paling banyak satu kali dengan menyimpan solusi mereka entah

00:16.980 --> 00:20.500
bagaimana sehingga kami tidak selalu menyelesaikan subproblem yang sama.

00:20.700 --> 00:23.370
Jadi salah satu cara untuk melakukannya adalah menggunakan menghafal.

00:23.450 --> 00:26.230
Dan dalam video ini saya akan menunjukkan kepada Anda cara kedua.

00:26.280 --> 00:29.240
Jadi pendekatan yang kami lakukan adalah semacam top down.

00:29.350 --> 00:35.220
Jika itu masuk akal di mana kita telah bekerja dari katakanlah sebuah angka 7 dan menghitung lima pertama dari enam

00:35.220 --> 00:41.040
dan lima atau lima dan kemudian lima dari lima dan empat dan terus turun sampai kita mencapai apa pun

00:41.040 --> 00:43.220
kasus dasar kita adalah dua atau satu.

00:43.260 --> 00:49.020
Dan kami telah memulai dengan apa yang kami coba temukan dan bekerja untuk mengisi kekosongan dan kemudian

00:49.080 --> 00:50.220
menambahkan semuanya bersama-sama.

00:50.490 --> 00:52.330
Jadi itu akan dari atas ke bawah.

00:52.350 --> 00:54.870
Tapi tentu saja ada cara lain untuk melakukannya.

00:54.870 --> 01:01.590
Dari bawah ke atas, maka dari bawah ke atas berarti bahwa kita akan mulai dengan fib 1 dan 2 dan menambahkannya bersama-sama lalu

01:01.590 --> 01:04.640
pergi ke tiga dan menambahkannya sampai kita membalik tujuh.

01:04.710 --> 01:06.650
Jadi kami mendapatkan hasil yang sama di akhir hari.

01:06.660 --> 01:09.450
Hanya saja kami bekerja ke arah yang berbeda.

01:09.540 --> 01:12.880
Jadi strategi yang bisa kita gunakan untuk melakukan ini disebut tabulasi.

01:12.900 --> 01:17.360
Jadi memoisasi dan tabulasi dua rasa berbeda dari pemrograman dinamis.

01:17.520 --> 01:21.510
Jadi dalam tabulasi biasanya dilakukan menggunakan iterasi menggunakan loop.

01:21.630 --> 01:26.220
Tidak harus Anda, tetapi lebih mudah untuk melakukannya dan kami mulai dari bagian bawah dari apa pun yang kami

01:26.220 --> 01:26.820
coba pecahkan.

01:26.820 --> 01:28.410
Submasalah terkecil.

01:28.590 --> 01:31.480
Dan kemudian kami menyimpan hasilnya di semacam tabel.

01:31.530 --> 01:34.610
Oleh karena itu istilah tabulasi biasanya berupa array.

01:34.650 --> 01:39.720
Jadi kami menyimpan data dalam sebuah array dan kemudian kami loop dan bergerak maju dan kami menambahkan hal-hal bersama atau kami

01:39.720 --> 01:40.970
melakukan sesuatu dengan data.

01:41.010 --> 01:44.850
Kami tidak selalu menambahkan tetapi dalam kasus Fibonacci kami akan menjadi.

01:44.850 --> 01:49.830
Dan kemudian kita bergerak maju lagi dan kita menambahkan dan kita terus bergerak maju sampai kita mencapai nomor

01:49.830 --> 01:51.570
yang kita coba untuk sampai.

01:51.580 --> 01:55.090
Itu sangat buruk sampai kita tiba pada solusi yang kita inginkan.

01:55.140 --> 01:59.730
Kami akan berbicara tentang kompleksitas waktu dan ruang tetapi karena Anda mungkin sudah tahu dari video

01:59.730 --> 02:00.600
sebelumnya tentang rekursi.

02:00.810 --> 02:07.230
Rekursi bisa jadi sulit pada kompleksitas ruang dan seringkali tabulasi kurang intensif ruang tetapi kita

02:07.230 --> 02:08.520
akan membicarakannya nanti.

02:08.520 --> 02:12.580
Jadi, inilah contoh Fibonacci menggunakan tabulasi.

02:12.600 --> 02:18.690
Jadi itu hasil yang sama persis pada akhir hari itu menghitung apa pun angka kelima atau kesepuluh

02:18.810 --> 02:20.280
dalam urutan Fibonacci.

02:20.580 --> 02:24.100
Dan apa yang kita lakukan pada dasarnya adalah memulai dari kelelawar.

02:24.120 --> 02:24.390
BAIK.

02:24.390 --> 02:28.520
Jika Anda mencari satu atau dua hanya hubungan pendek dan kembalikan satu.

02:28.890 --> 02:32.310
Kalau tidak, ini adalah array kami di mana kami akan menyimpan data kami.

02:32.310 --> 02:33.270
Ini meja kami.

02:33.630 --> 02:37.910
Dan saya menempatkan 0 di sini kita dapat menempatkan tidak terdefinisi ketika kita tidak benar-benar menyentuh ini.

02:38.010 --> 02:39.390
Kita mulai dari sini.

02:39.390 --> 02:41.150
Jadi ini adalah digit pertama Fibonacci.

02:41.190 --> 02:44.010
Indeks 1 digit kedua di indeks 2.

02:44.310 --> 02:48.810
Dan kemudian kita hanya mengulang mulai dari 3 hingga apa pun yang kita coba temukan.

02:48.810 --> 02:55.050
Jika saya mencoba menemukan angka Fibonacci kelima kita akan mengulang dari 3 menjadi 5 dan kemudian kita mulai

02:55.050 --> 03:01.920
dan mengatakan Fibonacci dengan baik dari tiga fibbed nomor tiga sama dengan dua angka sebelum ini yang satu dan yang satu

03:02.070 --> 03:02.660
ini.

03:02.970 --> 03:05.810
Dan kami menambahkannya bersama dan menyimpannya dalam array itu.

03:06.030 --> 03:10.520
Jadi kita berakhir dengan dua dan kemudian kita bergerak maju dan kita tambahkan dua sebelumnya.

03:10.740 --> 03:16.800
Jadi setiap kali kita menghitung angka baru dengan menambahkan dua yang datang sebelumnya dalam array atau mentabulasi

03:16.800 --> 03:17.670
mereka bersama-sama.

03:17.970 --> 03:19.290
Jadi inilah sedikit animasi.

03:19.470 --> 03:22.810
Ini adalah array kami untuk mencoba menghitung Fibonacci enam.

03:22.920 --> 03:26.640
Secara teknis dalam javascript itu tidak akan memiliki enam slot kosong seperti ini.

03:26.640 --> 03:31.360
Dalam bahasa pemrograman lain kita sebenarnya harus menentukan berapa lama sebuah array ketika kita membuatnya.

03:31.380 --> 03:36.410
Tapi ini agak tidak akurat karena dalam javascript ukurannya akan tetap dinamis.

03:36.630 --> 03:37.800
Jadi kita punya array ini.

03:37.800 --> 03:40.300
Saya menaruh tanda X di sini karena kami tidak menggunakan nol.

03:40.350 --> 03:41.940
Itu semacam tempat kosong.

03:42.000 --> 03:43.310
Kita bisa mengubah semuanya.

03:43.320 --> 03:44.960
Tapi saya suka menjaganya tetap sederhana.

03:45.060 --> 03:51.080
Jadi kita mulai atau kita mengisi dasar-dasar yang kita tahu dua digit pertama adalah 1 dan 1.

03:51.090 --> 03:55.100
Kita harus tahu bahwa untuk melakukan apa pun kita bekerja dari bawah ke atas.

03:55.110 --> 04:04.390
Jadi selanjutnya kita akan menghitung Fibonacci 3 dengan menambahkan Fibonacci 2 plus 1 dan mengisinya dan kita dapatkan

04:04.390 --> 04:05.120
2.

04:05.530 --> 04:07.840
Dan tentu saja kita pindah ke lot berikutnya.

04:07.840 --> 04:10.970
Angka Fibonacci keempat adalah yang ketiga ditambah yang kedua.

04:11.260 --> 04:12.980
Jadi kita tambahkan itu bersama untuk mendapatkan tiga.

04:13.240 --> 04:14.110
Dan kita terus berjalan.

04:14.110 --> 04:19.240
Yang kelima adalah yang keempat ditambah yang ketiga memberi kita 5 dan kemudian kita sampai yang keenam yang merupakan

04:19.240 --> 04:20.610
Plus kelima yang keempat.

04:20.610 --> 04:24.270
Tambahkan bersama-sama simpan itu dan kita selesai.

04:24.280 --> 04:26.500
Jadi semoga Anda bisa melihat satu cara kerjanya.

04:26.500 --> 04:29.330
Tetapi juga mengapa itu disebut pendekatan bottom up.

04:29.350 --> 04:36.260
Kita mulai dari dasar, bawah, subproblem terkecil dan menyelesaikan masalah yang paling rumit.

04:36.340 --> 04:37.310
Masalah aslinya.

04:37.390 --> 04:39.370
Jadi, saya tunjukkan dalam aksi.

04:39.370 --> 04:42.320
Inilah implementasi yang sama dan jalankan.

04:42.580 --> 04:46.690
Dan jika kita mencoba melakukan fib 5 kita mendapatkan lima.

04:46.780 --> 04:48.130
Ini bekerja sebagaimana mestinya.

04:48.250 --> 04:50.790
Tetapi juga dapat melakukan hal-hal seperti Fitbit 100.

04:50.800 --> 04:57.730
Dan sekarang ada sesuatu yang menarik jika saya pergi ke versi hafal yang bersifat rekursif dan saya jalankan yang

04:58.450 --> 05:02.000
ini biarkan saya dari atau saya ingin melakukan ini.

05:02.050 --> 05:13.420
Mereka meletakkan ini di file yang sama dan saya akan memanggil memo yang satu ini dan tabel yang satu ini dan memutarnya

05:13.420 --> 05:14.100
kembali.

05:14.200 --> 05:19.920
Jika saya mencoba dan melakukan memo memo, kami hanya memastikan memo memo fibbed ada di sini.

05:20.100 --> 05:21.040
Ini bekerja dengan baik.

05:21.040 --> 05:25.690
Sekarang jika saya menemukan 500 yang masih belum cukup besar.

05:25.690 --> 05:29.920
Bagaimana dengan 1000 itu masih menyenangkan sepuluh ribu.

05:29.920 --> 05:30.190
Baiklah.

05:30.190 --> 05:31.500
Itu dia.

05:31.540 --> 05:37.840
Ini saya sedang mencari ukuran stack panggilan maksimum terlampaui jadi karena kami menggunakan rekursi di

05:37.840 --> 05:45.160
sini dan kami memiliki semua panggilan rekursif yang tidak terselesaikan ini yang menunggu di stack ketika saya melakukan 10.000.

05:45.160 --> 05:46.090
Sebenarnya tidak berfungsi.

05:46.090 --> 05:47.970
Kami berakhir dengan kesalahan stack overflow ini.

05:48.040 --> 05:51.200
Saya berbicara tentang hal itu di bagian rekursi karena tidak terbiasa dengannya.

05:51.400 --> 05:57.100
Kami tidak akan mengalami masalah dengan versi tabulasi karena tidak memakan banyak

05:57.100 --> 05:57.810
ruang.

05:57.910 --> 05:58.590
Bikinan.

05:58.660 --> 06:02.740
Tabel 1 0 0 0 10000 adalah.

06:02.800 --> 06:08.560
Sekarang kita mendapatkan infinity karena javascript tidak cukup tepat atau tidak dapat menyimpan angka-angka besar itu setidaknya tidak

06:09.070 --> 06:10.840
seperti yang saya lakukan sekarang.

06:11.140 --> 06:12.640
Tapi itu tidak aneh.

06:12.700 --> 06:17.770
Ia berpikir bahwa ia mengerjakan matematika itu hanya cara mengumpulkan.

06:17.770 --> 06:22.440
Jadi ini adalah contoh yang salah karena tidak ada yang benar-benar memberi kita jawaban yang benar.

06:22.600 --> 06:25.530
Tetapi setidaknya Anda dapat melihat bahwa kami tidak menemukan kesalahan yang sama.

06:25.600 --> 06:30.820
Dan dalam implementasi lain atau bahasa lain ini tidak akan terjadi, kami benar-benar mendapatkan jawaban yang

06:30.850 --> 06:31.460
akurat.

06:31.720 --> 06:33.430
Dan ini masih akan meluap.

06:33.770 --> 06:34.220
BAIK.

06:34.510 --> 06:37.960
Jadi sejauh kompleksitas waktu keduanya.

06:37.990 --> 06:43.270
Dan jika kita berpikir tentang versi tabulasi kita, itu sangat mudah bahwa itu sudah

06:43.270 --> 06:50.560
berakhir dan karena kita memiliki satu loop dan itu loop dari sekitar tiga ke dan kita bisa mengatakan hingga N

06:50.680 --> 06:57.670
sehingga dan menumbuhkan jumlah loop atau iterasi tumbuh secara linear dengan dan keduanya berakhir dan kompleksitas ruang dari versi

06:57.670 --> 06:59.420
yang dihafal lebih buruk.
