WEBVTT

00:00.150 --> 00:00.510
Baiklah.

00:00.510 --> 00:01.250
Selamat datang kembali.

00:01.350 --> 00:04.080
Mari kita lakukan pencarian nafas pertama kita.

00:04.500 --> 00:10.490
Jadi saya akan membahasnya dan hal pertama adalah saya akan menemukan metode yang bisa kita sebut EF-S atau

00:10.500 --> 00:11.760
napas untuk pencarian.

00:11.760 --> 00:13.080
Itu tidak masalah.

00:13.110 --> 00:18.120
Maksud saya menjadi Fester's karena itu benar-benar menjengkelkan untuk mengetik dan tidak perlu mengambil argumen.

00:18.120 --> 00:20.310
Kami hanya mencoba mengunjungi setiap node.

00:20.770 --> 00:21.540
BAIK.

00:21.960 --> 00:24.680
Dan segera kita perlu dua hal.

00:24.870 --> 00:28.610
Pertama kita membutuhkan data kita yang akan kembali pada akhirnya.

00:28.830 --> 00:30.590
Jadi saya hanya akan membuat array kosong.

00:30.600 --> 00:34.240
Kami juga memiliki beberapa variabel lain jadi saya hanya akan mendeklarasikan semuanya.

00:34.290 --> 00:39.980
Kami memiliki Q kami yang juga akan menjadi array kosong dan kita bisa mulai dengan itu.

00:40.620 --> 00:45.160
Dan hal pertama yang akan dilakukan adalah menempatkan simpul root dalam antrian.

00:45.650 --> 00:48.080
OK jadi itu cukup mudah.

00:48.120 --> 00:52.090
Q Dot mendorong dot Rube ini.

00:52.590 --> 00:53.400
Jadi itu menempatkan.

00:53.400 --> 00:59.370
Jika ini adalah pohon yang kami kerjakan yang menempatkan 10 di sana dan kemudian kami hanya akan mengulang

00:59.370 --> 01:01.100
selama ada sesuatu dalam antrian.

01:01.380 --> 01:03.830
Kita akan mengambil dequeue dari.

01:03.860 --> 01:07.880
T Jadi mari kita mulai dengan loop itu sementara ada sesuatu dalam antrian.

01:07.950 --> 01:16.590
Jadi jika kita hanya melakukan sementara Q Dalam javascript jika kita memiliki array kosong dan kita meniadakannya ini memberitahu kita bahwa kita mendapatkan false

01:16.980 --> 01:19.920
yang berarti bahwa array kosong itu benar.

01:20.070 --> 01:21.090
Jadi bukan itu yang kita inginkan.

01:21.090 --> 01:26.550
Ini tidak seperti string kosong atau beberapa bahasa array kosong adalah falsie karena itu kosong.

01:26.550 --> 01:27.300
Bukan kasusnya.

01:27.300 --> 01:30.270
Jadi yang akan kami lakukan adalah panjang antrian liar.

01:30.340 --> 01:37.490
Jadi 0 adalah falsie seperti yang kita lihat ada kita bisa kembali ke false.

01:37.610 --> 01:39.140
Itu tidak masuk akal.

01:39.140 --> 01:40.980
Saya minta maaf jika saya melakukan pekerjaan yang buruk dengan menjelaskan hal itu.

01:41.040 --> 01:42.350
Tapi kita tidak bisa hanya mengatakan sementara.

01:42.350 --> 01:44.700
Q Saat Anda mengatakan panjang Q Dot.

01:45.270 --> 01:52.790
Jadi, sementara ada sesuatu dalam Q Kita akan menghapus sesuatu dari awal Q itu. Jadi ketika Q bergeser

01:52.800 --> 01:56.050
dan mari kita letakkan ini dalam variabel.

01:56.280 --> 02:02.370
Tetapi alih-alih di dalam lingkaran ini terus membuat variabel baru berulang-ulang dan mendeklarasikannya

02:02.370 --> 02:02.850
kembali.

02:03.270 --> 02:10.680
Mari kita benar-benar pergi ke sini dan membuat variabel lain panggil node dan mari kita mulai sebagai yang

02:10.680 --> 02:13.730
benar-benar kita lakukan rute ini seperti ini.

02:13.860 --> 02:14.570
OK saya akan.

02:14.730 --> 02:20.820
Ini hanya aku yang agak konyol tapi aku suka semua ini berbaris.

02:21.380 --> 02:23.050
OK, mari kita lakukan saja.

02:23.100 --> 02:24.200
Itu tidak masalah.

02:24.210 --> 02:26.940
Anda bisa melakukan tiga vars berbeda pula.

02:26.970 --> 02:31.190
Kami memiliki node mulai sebagai root maka kita dapat menggunakan untuk mendorong node.

02:31.200 --> 02:37.080
Itu tidak terlalu penting, tetapi sekarang saya tidak harus melakukan ini var simpul sama dengan dan hanya memiliki kata kunci var ini

02:37.080 --> 02:37.930
dalam satu lingkaran.

02:37.930 --> 02:39.050
Itu bukan ide yang bagus.

02:39.300 --> 02:43.680
Jadi saya hanya akan sekarang menetapkan node ke pergeseran bq.

02:43.680 --> 02:48.330
Sekarang tentu saja saya bisa mulai mencatat karena tidak ada yang bisa membuatnya tidak terdefinisi atau tidak.

02:48.920 --> 02:50.420
Tetapi ini bekerja dengan baik untuk saya.

02:50.430 --> 02:53.470
Jadi kita ambil dari awal antrian.

02:53.610 --> 02:58.260
Jadi jika kita mendorong pada akhirnya kita akan beralih dari awal untuk mendapatkan yang

02:58.260 --> 02:59.430
pertama masuk pertama.

02:59.670 --> 03:04.060
Maka kita perlu mengambil catatan itu dan menambahkannya ke daftar yang akan kita kembalikan.

03:04.320 --> 03:06.150
Kemudian kami memeriksa apakah ada yang tersisa.

03:06.180 --> 03:08.290
Kami menambahkan itu ke antrian kami mengakhirinya.

03:08.340 --> 03:11.410
Jika ada tulisan, kami menambahkannya ke antrian juga.

03:11.910 --> 03:13.920
Jadi kita tahu itu antri shift.

03:13.920 --> 03:21.710
Sekarang kita akan melakukan data push node sehingga menambahkan ke daftar kita bahwa kita akan kembali ke jika

03:21.720 --> 03:27.040
ini adalah antrian kami kosong dan ini adalah data kami kosong.

03:27.170 --> 03:31.250
Hal paling pertama yang terjadi adalah kami mendorong.

03:31.280 --> 03:35.470
Maaf tentang Syren itu jika Anda bisa mendengar bahwa push 10 antrian diberikan pohon ini.

03:35.690 --> 03:41.690
Kemudian sementara panjang antrian simpul sama dengan mengambil ini dan ditambahkan ke data kami.

03:41.690 --> 03:45.720
Sekarang kita akan memeriksa apakah ada kiri jika simpul tersisa.

03:45.920 --> 03:54.120
Kemudian kita akan melakukan Q push node ke kiri dan akan melakukan hal yang sama.

03:54.670 --> 03:59.140
Jika ada hak maka kami tambahkan itu ke dalamnya.

03:59.140 --> 04:03.920
T Dan itu sebenarnya untuk loop kita lalu di akhir.

04:03.930 --> 04:09.460
Kami hanya perlu mengembalikan variabel data ini tempat kami membangun semua yang kami kunjungi.

04:09.600 --> 04:16.320
Jadi hanya untuk menegaskan kembali bahwa jika kita mengambil 10 dari awal yang ada dalam antrian kita, kita menambahkan data maka kita

04:16.320 --> 04:18.210
akan memeriksa apakah masih ada 10.

04:18.270 --> 04:21.390
Dengan baik struktur kita ya itu enam.

04:21.390 --> 04:23.500
Jadi kami punya enam dalam 10.

04:23.550 --> 04:24.880
Kami tahu benar.

04:24.900 --> 04:25.860
Apakah tidak diragukan lagi benar.

04:25.860 --> 04:27.280
Ya itu 15.

04:27.300 --> 04:31.680
Jadi cued up push 15 dan kemudian loop dimulai lagi.

04:31.800 --> 04:33.320
Masih panjang antrian.

04:33.360 --> 04:40.400
Jadi sekarang simpul sama dengan 6 akan mengambil 6 dan kami mendorongnya ke data yang kami kunjungi.

04:40.650 --> 04:45.030
Dan kami kembali di akhir dan kemudian kami memeriksa apakah ada yang tersisa.

04:45.030 --> 04:46.050
Jadi kami menambahkannya.

04:46.080 --> 04:47.080
Itu tiga.

04:47.390 --> 04:49.440
Dan akan melakukan hal yang sama dengan benar.

04:49.470 --> 04:50.090
Kami menambahkannya di.

04:50.090 --> 04:50.980
Itu delapan.

04:51.120 --> 04:55.380
Dan kami terus berjalan dan saya melakukan ini di video terakhir sehingga saya tidak akan melangkah setiap saat.

04:55.620 --> 04:58.980
Tapi mari kita lihat apakah itu berfungsi jika itu berfungsi.

04:59.130 --> 05:02.030
Kami berharap mendapatkan ini.

05:02.700 --> 05:04.810
Jadi saya akan menyalin ini.

05:04.860 --> 05:06.310
Ini adalah apa yang kita inginkan.

05:07.290 --> 05:09.040
Mari kita coba jalankan.

05:09.180 --> 05:12.280
Jadi di sini saya punya kode untuk benar-benar membangun pohon.

05:12.510 --> 05:14.010
Dan sekarang saya akan melakukan pohon.

05:14.040 --> 05:16.420
B fs.

05:16.730 --> 05:18.930
Wow itu menyebalkan.

05:18.930 --> 05:22.620
Mungkin saya harus mendorong nilainya agar lebih mudah melihat apa yang terjadi.

05:22.620 --> 05:24.910
Jadi mari kita lakukan push no value diragukan.

05:24.930 --> 05:26.000
Itu tidak masalah.

05:26.010 --> 05:27.860
Tetapi hanya untuk membuat ini lebih mudah

05:31.670 --> 05:32.170
dilihat.

05:32.400 --> 05:42.240
Jadi kita punya 10 6 15 3 8 20 dan kita seharusnya mendapatkan 10 615 3:08 20 yang luas pertama sepanjang

05:42.240 --> 05:44.850
jalan melintasi semua jalan melintasi.

05:44.910 --> 05:48.980
Jadi mendatar sebelum kita melakukan napas vertikal sebelum kedalaman.

05:49.290 --> 05:55.090
Jadi itu adalah EF-S, ini relatif mudah jika Anda memanfaatkan antrian.

05:55.150 --> 05:59.140
Ingat dulu masuk pertama keluar hanya daftar hal-hal yang perlu kita kunjungi.

05:59.160 --> 06:02.420
Kami terus melacaknya dan terus tumbuh dan tidak masalah.

06:02.550 --> 06:05.330
Ya ini kode sulit untuk kiri dan kanan.

06:05.550 --> 06:09.840
Tetapi jika ini adalah pohon ternary kami dapat menambahkan Anda tahu anak kedua dan ketiga pertama.

06:09.990 --> 06:14.430
Atau kita bisa melakukannya secara dinamis dan melakukan perulangan di semua anak.

06:14.430 --> 06:16.350
Jadi tidak harus berupa pohon biner.

06:16.350 --> 06:18.000
Itu prinsip dasar yang sama.

06:18.000 --> 06:18.590
Anda menggunakan.

06:18.590 --> 06:19.580
Q Baiklah.

06:19.590 --> 06:20.520
Jadi itu EF-S.
