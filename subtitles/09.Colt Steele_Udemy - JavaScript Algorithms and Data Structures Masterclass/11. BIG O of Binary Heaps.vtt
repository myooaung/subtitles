WEBVTT

00:00.210 --> 00:00.930
Selamat datang kembali.

00:00.930 --> 00:06.630
Mari kita selesaikan oleh tumpukan Mary dengan berbicara tentang bagaimana mereka melakukan notasi Big-O mereka terutama

00:06.630 --> 00:11.480
untuk kompleksitas waktu sehingga tumpukan biner baik tumpukan min dan max besar.

00:11.520 --> 00:15.480
Ketika kita berbicara tentang penyisipan dan penghapusan, itulah yang benar-benar unggul.

00:15.480 --> 00:19.980
Log-in besar sangat cepat untuk kompleksitas waktu.

00:19.980 --> 00:25.890
Jadi ingat dari pohon pencarian biner yang sangat cepat ketika kita membandingkannya dengan semua jenis Bigos standar

00:25.890 --> 00:27.660
lainnya yang telah kita lihat.

00:27.800 --> 00:33.540
Jadi semua jalan di sini dan hijau muda semacam ini bukan hijau tua tapi hijau muda Jadi

00:33.540 --> 00:39.240
dan menumbuhkan jumlah waktu yang dibutuhkan untuk memasukkan atau menghapus sesuatu dari tumpukan biner tumbuh lebih lambat

00:39.330 --> 00:42.510
ia tumbuh tumbuh pada tingkat log dan sekitar.

00:42.510 --> 00:44.070
Jadi mari kita bicara mengapa itu terjadi.

00:44.070 --> 00:50.190
Jadi pertama-tama ingat ketika kita mengatakan vog dan sebenarnya berbasis log untuk memiliki apa yang benar-benar merujuk

00:50.190 --> 00:55.380
walaupun itu sebenarnya tidak penting karena kita hanya merujuk pada tren umum ini.

00:55.380 --> 01:00.970
Tetapi jika kita berpikir seperti itu dan kita berbicara tentang tumpukan biner kita berbicara tentang log berdasarkan peristiwa.

01:01.250 --> 01:07.680
Nah setiap kali kita turun satu langkah dalam tumpukan biner atau sembarang struktur pohon biner kita memiliki dua kali

01:07.680 --> 01:13.020
jumlah node kita memiliki satu simpul dari 2 dan 4 kemudian 16 dan seterusnya.

01:13.020 --> 01:21.150
Jadi mari kita fokus pada penyisipan jika kita ingin memasukkan angka 200 ke dalam tumpukan terburuk ini yang kita tahu benar

01:21.150 --> 01:23.620
sebenarnya karena itu adalah jumlah terbesar.

01:23.790 --> 01:31.650
Ini akan berakhir di sini tapi sepanjang jalan kita hanya perlu membandingkannya satu kali per baris tepat satu

01:31.650 --> 01:33.970
kali per tingkat tumpukan ini.

01:34.020 --> 01:38.930
Jadi kami membandingkannya dengan orang tua pertama yang sembilan karena ingat semuanya dimasukkan di sebelah kiri.

01:39.060 --> 01:43.060
Jadi 200 akan menjadi anak dari elemen 9 ini.

01:43.110 --> 01:43.690
Jadi kami membandingkannya.

01:43.700 --> 01:48.480
Itu salah satu perbandingan yang kami bandingkan dengan orangtua dengan perbandingan.

01:48.540 --> 01:50.190
Sekali lagi tiga perbandingan.

01:50.400 --> 01:56.260
Dan kemudian perbandingan keempat dan kemudian pada titik ini kita menyadari OK 200 adalah elemen terbesar.

01:56.260 --> 01:59.110
Jika ini adalah tumpukan biner maks, ia harus menjadi root.

01:59.340 --> 02:00.390
Jadi itu untuk perbandingan.

02:00.390 --> 02:03.350
Jadi untuk 16 elemen kita berbicara tentang empat perbandingan.

02:03.420 --> 02:11.310
Jadi Anda dapat menganggapnya sebagai dua kekuatan yang memberi kita 16 ke kekuatan keempat dua kali dua kali dua

02:11.310 --> 02:13.590
kali dua memberi kita 16.

02:13.890 --> 02:17.940
Atau jika kita harus melompat kesini, ini adalah nilai maksimal.

02:17.940 --> 02:21.570
Sayangnya saya sebenarnya tidak bisa memasukkan hal lain ke dalam ini.

02:21.600 --> 02:29.310
Batasnya adalah 31 node tetapi jika kita menyisipkan sesuatu di sini, ini adalah di mana ia akan pergi di sebelah 30

02:29.420 --> 02:36.000
detik kita akan jika itu katakanlah kita memasukkan 100 yang lebih besar dari root untuk menemukan jalan

02:36.000 --> 02:37.120
di sini.

02:37.140 --> 02:42.950
Ini satu perbandingan dengan perbandingan tiga empat dan kemudian lima perbandingan.

02:43.020 --> 02:47.460
Jadi untuk 32 node kita berbicara tentang lima operasi perbandingan.

02:47.460 --> 02:49.200
Jadi akhirnya tumbuh menjadi 32.

02:49.230 --> 02:54.490
Kita berpikir tentang dua kekuatan apa yang memberi kita 32-2 kekuatan kelima.

02:54.600 --> 02:58.000
Dua kali dua kali dua kali dua kali dua.

02:58.080 --> 03:03.930
Jadi cara lain untuk menempatkan itu adalah setiap kali kita menggandakan jumlah node setiap layer

03:04.340 --> 03:08.330
lengkap baru kita hanya menambah waktu yang dibutuhkan oleh satu.

03:08.340 --> 03:13.140
Jadi ketika kita mencapai 64 node kita berbicara tentang enam operasi dan mudah-mudahan Anda

03:13.140 --> 03:19.500
dapat melihat mengapa akan sama untuk dihapus karena kita memasukkan yang kita hapus dari awal kita menukar sesuatu menjadi rute

03:19.500 --> 03:25.230
baru dan kemudian kita harus membandingkan dan jika harus menyaring semua jalan kembali jumlah perbandingan maksimal akan

03:25.230 --> 03:27.680
sama seperti yang kita lihat di sini.

03:27.780 --> 03:32.040
Log dan ide yang sama antara penyisipan dan penghapusan.

03:32.040 --> 03:37.590
Sekarang Anda mungkin ingat dari ketika kita berbicara tentang pohon pencarian biner di mana mereka juga

03:37.590 --> 03:41.490
memiliki log waktu penyisipan secara umum atau kasus slash terbaik rata-rata.

03:41.490 --> 03:43.390
Ada juga skenario terburuk.

03:43.620 --> 03:49.590
Ingat ini pohon yang sangat menyedihkan yang benar-benar tidak terlihat seperti jenis pohon seperti yang

03:49.890 --> 03:50.740
lainnya.

03:50.790 --> 03:57.300
Kompleksitas waktu O besar untuk dimasukkan ke dalam pohon ini atau untuk mencari adalah dari dan karena

03:57.300 --> 04:00.830
cara itu diatur dengan benar jika itu selalu tepat.

04:00.840 --> 04:01.170
Kanan.

04:01.260 --> 04:01.670
Kanan.

04:01.710 --> 04:02.430
Kanan.

04:02.700 --> 04:05.400
Ini akan membawa Anda tahu berapa banyak node di sini.

04:05.460 --> 04:11.250
Itu berpotensi berapa lama untuk memasukkan jika Anda mencoba memasukkan 100 atau sesuatu.

04:11.250 --> 04:14.460
Ini bukan masalah ketika kita berbicara tentang tumpukan.

04:14.460 --> 04:15.350
Sekarang kenapa begitu.

04:15.510 --> 04:18.690
Yah tumpukan tidak pernah bisa terlihat seperti ini bertentangan dengan aturan tumpukan.

04:18.690 --> 04:23.570
Ingatlah bahwa ketika kita memasukkan tumpukan, kita selalu mengisi sisi kiri terlebih dahulu.

04:23.610 --> 04:28.950
Jadi tidak seperti pohon pencarian biner di mana kami mungkin telah Anda tahu baris tidak lengkap saya tidak harus

04:28.950 --> 04:30.580
menyebutnya baris tingkat tidak lengkap.

04:30.590 --> 04:34.960
Alih-alih semuanya selalu diisi sebelum kita melanjutkan ke tingkat berikutnya.

04:35.160 --> 04:41.070
Jadi seluruh baris ini, seluruh bagian ini selesai dan kemudian kita mulai menyisipkan di sini dan di sini dan kemudian

04:41.070 --> 04:42.130
kita terus melintasinya.

04:42.150 --> 04:48.540
Jadi tidak ada kemungkinan bagi kita untuk memiliki pohon tertekan yang tidak seimbang dan gila.

04:48.540 --> 04:51.130
Dan karena kasus terburuk itu masih.

04:51.310 --> 04:59.190
Oh tentu saja kembali ke sini lagi untuk penyisipan dan penghapusan sekarang tumpukan biner tidak benar-benar dibuat untuk mencari dengan baik seperti

04:59.190 --> 05:04.550
jika Anda benar-benar peduli tentang mengoptimalkan pencarian Anda maka Anda mungkin ingin menggunakan pohon pencarian

05:04.550 --> 05:06.540
biner atau sesuatu seperti itu.

05:06.560 --> 05:08.780
Jadi kompleksitas waktu untuk pencarian sudah selesai.

05:08.820 --> 05:14.750
Dan ingat bahwa ketika kita melihat tumpukan biner seperti ini, tidak ada jaminan pesanan atau bahkan pesanan

05:14.750 --> 05:16.440
tersirat antara saudara kandung.

05:16.580 --> 05:21.860
Jadi jika kita mencari simpul yang berisi nilai 1 kita mulai dengan awal.

05:22.130 --> 05:24.210
Kita tidak bisa membuat keputusan.

05:24.320 --> 05:26.740
Kita tidak bisa tahu dengan pohon pencarian biner yang bisa kita katakan baik-baik saja.

05:26.750 --> 05:29.320
Kurang dari 86 jadi di suatu tempat di sini.

05:29.360 --> 05:30.520
Bukan itu masalahnya di sini.

05:30.530 --> 05:36.710
Itu bisa di mana saja karena seseorang kurang dari 86 itu satu-satunya syarat yang kita tahu pasti benar tentang

05:36.710 --> 05:37.870
semua catatan ini.

05:37.870 --> 05:39.460
Apakah ada kurang dari 86.

05:39.620 --> 05:43.890
Jadi kita harus melihat ke sini dan sekali lagi kita tidak bisa membuat keputusan.

05:43.980 --> 05:47.590
Di suatu tempat di sini mungkin tapi masih bisa di sini.

05:47.720 --> 05:55.280
Dan jadi kami terus berjalan dan Anda tahu kami harus mencari di sini dan di sini dan di sini dan di sini dan akhirnya

05:55.280 --> 05:55.970
menemukan satu.

05:55.970 --> 05:57.710
Tapi bisa juga di sini.

05:57.710 --> 06:01.310
Tidak ada aturan bahwa itu harus ada di sini, itu hanya dalam skenario yang diberikan ini.

06:01.310 --> 06:03.740
Ini dan itu adalah sedikit kasus terburuk.

06:03.740 --> 06:08.810
Sekarang jika kita mencari sesuatu yang lebih dekat ke bagian atas tumpukan kita seperti kita

06:09.020 --> 06:16.150
sedang mencari nomor katakanlah 80 ketika kita mulai di sini dan kita tahu bahwa 80 pasti kurang dari 86 sehingga kita memiliki

06:16.150 --> 06:16.700
keduanya.

06:16.880 --> 06:20.400
Di sini kita tahu bahwa 80 kurang dari 85.

06:20.690 --> 06:22.860
Jadi akan ada di sini secara potensial.

06:22.970 --> 06:24.790
Di sini kita punya 77 sumur.

06:24.890 --> 06:29.260
Tujuh puluh tujuh tidak lebih besar dari 80 sehingga kita dapat menyeberang sisi pohon ini.

06:29.270 --> 06:32.510
Tidak ada angka yang lebih besar dari 77 di sini.

06:32.690 --> 06:37.610
Jadi, jika kita dapat membuat keputusan dan menghilangkan sebagian dari itu, tetapi tidak ada jaminan setiap

06:37.610 --> 06:38.580
langkah yang terjadi.

06:38.630 --> 06:41.240
Dan itu tergantung pada nilai yang kita cari.

06:41.240 --> 06:43.360
Jadi secara teknis jika Anda mencarinya.

06:43.460 --> 06:50.480
Saya percaya bahwa big-O untuk pencarian adalah rata-rata dan dibagi dua tetapi ingat bahwa ketika kita memiliki konstanta seperti

06:50.480 --> 06:55.830
itu dan dibagi dua dan kali dua dan kali 100 itu tidak masalah.

06:55.850 --> 06:57.280
Kami menyederhanakannya menjadi besar.

06:57.290 --> 07:03.870
Dan ketika n tumbuh secara umum, jumlah waktu yang dibutuhkan untuk mencari juga tumbuh pada tingkat yang sama.

07:03.890 --> 07:05.530
Dan itu linear.

07:05.570 --> 07:11.030
Dan ini tidak dioptimalkan untuk pencarian tetapi ketika kita berbicara tentang penyisipan dan penghapusan itu adalah

07:11.030 --> 07:12.710
nama permainan dengan tumpukan.

07:12.740 --> 07:17.390
Baiklah kita punya waktu untuk rekap cepat jadi kita telah melihat banyak waktu berbicara tentang tumpukan

07:17.390 --> 07:19.060
biner yang merupakan jenis pohon.

07:19.190 --> 07:21.740
Yah secara teknis tumpukan biner adalah jenis tumpukan.

07:21.800 --> 07:25.990
Kita bisa memiliki tipe tumpukan lainnya seperti pohon biner adalah jenis pohon.

07:26.240 --> 07:31.220
Jadi kita memiliki tumpukan biner yang merupakan jenis tumpukan yang merupakan jenis pohon.

07:31.460 --> 07:32.040
BAIK.

07:32.450 --> 07:37.240
Jadi mereka berguna sendiri tetapi juga untuk mengimplementasikan struktur data lain seperti antrian prioritas.

07:37.310 --> 07:39.150
Pikir kami baru saja melihat beberapa video yang lalu.

07:39.620 --> 07:44.770
Mereka adalah salah satu atau berbicara tentang tumpukan biner mereka baik tumpukan biner Mac atau banyak tumpukan biner.

07:45.050 --> 07:48.010
Dan cara kerjanya satu aturan yang mengaturnya.

07:48.020 --> 07:52.980
Selain dari struktur yang berarti bahwa setiap simpul dapat memiliki maksimal dua anak.

07:53.030 --> 07:59.090
Aturan lain dalam emacs heap biasa adalah bahwa setiap orang tua lebih besar dari dua anaknya dan tumpukan

07:59.090 --> 08:04.330
biner setiap orang tua lebih kecil dari dua anaknya atau berapa banyak anak yang dimilikinya.

08:04.400 --> 08:10.120
Kita mengisinya dari kiri ke kanan sehingga kita tidak berakhir dengan pohon miring satu sisi yang tidak seimbang ini.

08:10.220 --> 08:13.070
Tumpukan selalu diisi dari kiri ke kanan.

08:13.100 --> 08:14.890
Itu terlihat seperti tumpukan.

08:15.050 --> 08:17.350
Ini piramida barang.

08:17.360 --> 08:19.300
Ini tumpukan.

08:19.400 --> 08:23.710
Dan dengan ini sedikit matematika kita bisa dengan mudah mewakili tumpukan menggunakan kenaikan gaji.

08:23.810 --> 08:25.320
Jadi kita tidak harus membuat pointer.

08:25.370 --> 08:30.980
Kita tidak harus membuat simpul yang menunjuk ke titik berikutnya berikutnya atau kiri dan kanan atau anak atau

08:30.980 --> 08:36.560
apa pun kita bisa menyimpannya dalam array karena aturan yang kita ikuti membuatnya sangat mudah untuk mendatar

08:36.800 --> 08:39.020
atau mewakili hanya menggunakan indeks numerik.

08:39.020 --> 08:40.930
Dan itu cara mudah yang bagus untuk melakukannya.

08:41.060 --> 08:42.890
Anda tidak harus mewakili tumpukan seperti itu.

08:42.890 --> 08:44.020
Anda bisa melakukan banyak.

08:44.030 --> 08:49.940
Anda bisa membuat kelas sendiri dan Anda tahu membuat banyak catatan seperti yang kami lakukan untuk pohon pencarian biner.

08:49.940 --> 08:51.790
Lebih mudah melakukannya dengan cara ini.

08:52.150 --> 08:53.520
Baiklah jadi itu biner.

08:53.580 --> 08:53.900
Tumpukan.
