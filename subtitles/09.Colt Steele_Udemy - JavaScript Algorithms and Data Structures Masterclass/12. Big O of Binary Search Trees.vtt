WEBVTT

00:00.210 --> 00:00.570
Baiklah.

00:00.570 --> 00:01.330
Selamat datang kembali.

00:01.470 --> 00:05.890
Jadi kita masih berbicara tentang pohon pencarian biner tetapi kita tidak akan menerapkan metode baru.

00:05.970 --> 00:09.640
Yang akan kita lakukan sekarang adalah meninjau dua metode yang telah kita tambahkan.

00:09.650 --> 00:13.890
Dan khususnya fokus pada kinerja mereka, kompleksitas waktu mereka.

00:13.890 --> 00:20.280
Jadi ketika pohon pencarian biner tumbuh, katakanlah itu dimulai pada 10 node dan naik ke satu juta

00:20.280 --> 00:20.780
node.

00:21.000 --> 00:25.230
Berapa banyak waktu rata-rata tetapi kami juga akan membicarakan kasus terbaik dan terburuk.

00:25.290 --> 00:29.490
Berapa banyak waktu yang diperlukan untuk memasukkan nilai atau mencari.

00:29.520 --> 00:31.240
Aku sebenarnya sudah memberikannya.

00:31.290 --> 00:35.140
Ini adalah kasus log terbaik dan rata-rata.

00:35.460 --> 00:37.880
Dan saya akan menjelaskan mengapa itu hanya sebentar.

00:37.920 --> 00:41.170
Tetapi jika Anda tidak ingat apa log itu, logaritma itu apa.

00:41.280 --> 00:44.070
Jika Anda tidak menonton dengan baik jika Anda tidak ingat dari kelas matematika.

00:44.070 --> 00:45.390
Sangat bisa dimengerti.

00:45.930 --> 00:50.700
Ini tidak berguna dalam kehidupan sehari-hari tetapi jika Anda tidak menonton video di awal kursus

00:50.700 --> 00:53.710
ini di bagian O Besar Anda mungkin ingin memeriksanya.

00:53.730 --> 00:57.190
Ini menjelaskan secara lebih rinci pada dasarnya apa artinya ini.

00:57.330 --> 01:03.570
Dan sama seperti penyegaran, ini sebenarnya berarti log berdasarkan dari dan yang benar-benar sangat malas cara

01:03.570 --> 01:06.300
O-besar bekerja, kami hanya menyederhanakan penyederhanaan.

01:06.300 --> 01:08.890
Kami juga menyingkirkan basis dan Anda hanya mengatakan masuk.

01:09.030 --> 01:09.270
BAIK.

01:09.270 --> 01:11.080
Jadi mari kita bicara tentang bagaimana kita tiba di sini.

01:11.250 --> 01:13.710
Hal pertama yang harus dihindari adalah Logan baik.

01:13.710 --> 01:18.990
Itu adalah kompleksitas waktu yang solid bahwa jika kita melihat grafik yang sebentar lagi kita akan melihat

01:19.350 --> 01:21.300
bahwa grafik itu tumbuh sangat lambat.

01:21.300 --> 01:21.660
Baiklah.

01:21.720 --> 01:25.180
Jadi di sini kita memiliki dua pohon, dua pohon pencarian biner.

01:25.200 --> 01:29.760
Saya hanya ingin menegaskan kembali apa yang saya bicarakan dalam video ini hanya untuk pohon pencarian biner.

01:29.790 --> 01:34.110
Mereka harus disortir karena memberi kita jalan pintas yang bagus dan bagus ini.

01:34.110 --> 01:35.920
Jadi inilah pohon pertama ini.

01:36.000 --> 01:37.530
Itu yang tujuh node.

01:37.530 --> 01:38.520
Sesuatu seperti itu.

01:38.940 --> 01:43.830
Ketika kita mencari nilai, katakanlah kita sedang mencari atau memasukkannya tidak masalah karena pada dasarnya kita

01:43.830 --> 01:45.090
melakukan hal yang sama.

01:45.210 --> 01:47.150
Kami menemukan tempat yang tepat untuk itu.

01:47.340 --> 01:51.240
Jadi katakanlah saya mencoba memasukkan 15: 9 ke dalam pohon teratas ini.

01:51.510 --> 01:57.090
Kita harus mulai dari sini dan kita harus membuat perbandingan. Pergi di sini, perbandingan lain,

01:57.360 --> 02:00.780
pergi di sini perbandingan lain dan kemudian masukkan nilainya.

02:00.810 --> 02:03.040
Sekarang jika kita menggandakan ukuran pohon.

02:03.090 --> 02:10.980
Jadi ini memiliki dua kali lipat node sebagai yang di atasnya hanya memiliki satu tingkat lebih ke bawah satu langkah lagi.

02:11.010 --> 02:12.680
Tingginya bertambah 1.

02:12.720 --> 02:19.170
Jadi di pohon ini walaupun memiliki dua kali lipat simpul seperti yang dari atas kita hanya perlu melihat sekali lagi

02:19.170 --> 02:21.530
kita harus mengambil satu langkah lagi.

02:21.540 --> 02:29.490
Jadi jika saya mencoba memasukkan 61 kali ini saya hanya perlu melangkah satu langkah dua langkah tiga langkah empat langkah.

02:29.490 --> 02:32.600
Yang ini memiliki setengah node adalah tiga langkah.

02:32.940 --> 02:38.900
Jadi hubungan ini di sini karena cara kita menyimpannya dan sekali lagi yang hanya berfungsi di pohon

02:38.910 --> 02:43.810
pencarian pohon pencarian biner sebagai pohon berfungsi ganda sebagai jumlah node berlipat ganda.

02:44.010 --> 02:46.410
Kami hanya menambah jumlah langkah sebanyak 1.

02:46.440 --> 02:49.250
Jadi hubungan itu berbasis log 2.

02:49.620 --> 02:54.340
Jadi inilah grafik sebenarnya dari Wikipedia log 2 X ..

02:54.420 --> 03:01.140
Jika Anda melihatnya hanya sisi positif saat kami menggandakan nilai dari 1 menjadi 2, kami hanya mengambil satu langkah

03:01.740 --> 03:05.730
saat kami menggandakannya lagi menjadi 4 dua langkah ke atas.

03:05.810 --> 03:09.390
Jadi kita gandakan lagi menjadi delapan 3 langkah ke atas.

03:09.390 --> 03:14.610
Jika kita kembali ke bagan kompleksitas O yang besar ini di mana kita hanya melihat semua notasi yang

03:14.610 --> 03:18.200
berbeda yang dipetakan bersebelahan, Anda dapat melihat bahwa masuk sangat padat.

03:18.240 --> 03:24.270
Itu tumbuh sangat lambat dibandingkan dengan sesuatu seperti saya tidak tahu dan kuadrat waktu kuadrat.

03:24.270 --> 03:29.330
Maksud saya itu tidak baik atau analog dalam atau bahkan waktu linier.

03:29.340 --> 03:33.470
Satu-satunya hal yang lebih baik pada bagan ini setidaknya adalah waktu yang konstan.

03:33.540 --> 03:35.100
Jadi login itu bagus.

03:35.100 --> 03:37.970
Butuh waktu lama untuk mulai tumbuh.

03:38.250 --> 03:42.220
Dan ini sama untuk penyisipan dan untuk pencarian.

03:42.270 --> 03:47.430
Hanya untuk menegaskan kembali bahwa mereka adalah ide yang sama karena cara pohon diatur kita mengikuti langkah-langkah yang

03:47.430 --> 03:50.500
sama kita membandingkan apakah kita ke kanan atau kiri membandingkan

03:50.560 --> 03:51.730
Apakah kita ke kanan atau kiri.

03:51.960 --> 03:54.710
Dan apakah kita menemukan nilainya atau kita masukkan.

03:54.840 --> 03:57.080
Ini semacam jumlah langkah yang sama.

03:57.480 --> 04:01.250
OK jadi sekarang mari kita bicara tentang mengapa saya katakan tidak dijamin.

04:01.440 --> 04:08.080
Jadi login adalah kompleksitas waktu untuk kasus rata-rata pohon tetapi juga untuk kasus terbaik tidak ada

04:08.100 --> 04:09.870
cara yang lebih cepat.

04:10.140 --> 04:13.460
Tetapi ketika kita berbicara tentang kasus terburuk itu tidak dijamin.

04:13.590 --> 04:20.220
Dan itu karena ada beberapa konfigurasi pohon pencarian biner yang sangat lambat setidaknya dibandingkan dengan

04:20.220 --> 04:22.560
yang telah kita lihat.

04:22.650 --> 04:28.370
Sebagai contoh pohon pencarian biner floppy mopy yang sangat menyedihkan ini.

04:28.590 --> 04:35.430
Pohon ini yang benar-benar hanya terlihat seperti daftar tertaut atau sesuatu di sana sangat seluruhnya satu sisi tetapi

04:35.790 --> 04:41.580
masih pohon pencarian biner yang valid karena jika kita mengambil nilai setiap node ke kanan lebih

04:41.580 --> 04:45.810
besar dari induknya dan kita akan tetap valid sepanjang jalan.

04:46.230 --> 04:52.890
Jadi jika kita berbicara tentang memasukkan ke dalam pohon ini jika kita memiliki pohon seperti ini, katakanlah berapa banyak

04:52.890 --> 04:54.410
item ini atau apa.

04:54.570 --> 05:00.280
Jika kita memilikinya tumbuh menjadi sejuta item dan itu masih pohon satu sisi yang tidak digunakan dengan baik untuk

05:00.280 --> 05:04.960
pohon pencarian biner tetapi jika itu yang Anda miliki dan itu terus tumbuh dan tumbuh

05:04.960 --> 05:10.570
dan tumbuh maka jumlah langkah yang akan diambil untuk menyisipkan atau mencari akan tumbuh ketika jumlah node bertambah.

05:10.690 --> 05:11.570
Jadi itu akan menjadi 0.

05:11.590 --> 05:15.310
Dan jika Anda memiliki pohon yang sepenuhnya satu sisi seperti ini.

05:15.400 --> 05:20.440
Sekarang ada solusi yang sangat mudah untuk ini yaitu jangan menyimpan pohon biner atau pohon pencarian

05:20.440 --> 05:21.420
biner seperti ini.

05:21.610 --> 05:28.210
Jika Anda membutuhkan ini sebagai pohon dan Anda ingin itu dapat disortir, Anda bisa menulis ulang pohon pencarian biner ini di mana

05:28.450 --> 05:30.500
Anda memilih pilihan rute yang berbeda.

05:30.520 --> 05:36.490
Saya tidak tahu 34 adalah root dan kemudian merestrukturisasi seluruh pohon dan memiliki nilai-nilai ini untuk menulis

05:36.490 --> 05:38.230
nilai-nilai ini ke kiri.

05:38.230 --> 05:42.130
Itu akan membuat pencarian dan penyisipan Anda lebih cepat.

05:42.160 --> 05:45.110
Jadi saya hanya ingin menunjukkan meskipun ini adalah BSD yang valid.

05:45.130 --> 05:49.050
Jadi ini sebabnya saya bilang tidak dijamin akan meluap lagi.

05:49.090 --> 05:55.020
Tetapi rata-rata penyisipan dan pencarian di pohon pencarian biner adalah 0 log dan kompleksitas waktu.

05:55.060 --> 05:56.480
Dan itu cukup bagus.

05:56.690 --> 05:57.440
Cukup bagus.

05:57.610 --> 05:58.280
Baiklah.

05:58.390 --> 05:58.890
Bergerak.
