WEBVTT

00:00.350 --> 00:04.240
OK jadi di video ini aktif untuk mengimplementasikan pencarian linear dasar kami.

00:04.380 --> 00:05.850
Jadi, inilah kodesemu lagi.

00:05.850 --> 00:11.490
Anda dapat menulis fungsi atau memanggilnya, sebut saja indeks untuk pencarian linier dan itu akan menerima array

00:11.490 --> 00:12.480
dan nilai.

00:12.600 --> 00:14.580
Jadi kita bisa mulai dari sana.

00:14.610 --> 00:17.890
Jadi saya sudah membuat cuplikan yang disebut Pencarian linear. Saya memilikinya.

00:17.890 --> 00:22.050
Saya akan mulai dengan pencarian sama seperti yang saya lakukan dengan rekursi sehingga mereka hanya dikelompokkan bersama.

00:22.080 --> 00:24.980
Jadi saya membuatnya di sini potongan baru dan menutup itu sekarang.

00:25.370 --> 00:31.680
Dan mari kita definisikan fungsi kita memanggil pencarian linier dan dibutuhkan array dan nilai.

00:31.820 --> 00:33.480
Mari kita lakukan seperti itu.

00:33.510 --> 00:35.050
Baiklah jadi itu langkah pertama.

00:35.310 --> 00:38.040
Jadi saya harus bisa menyebutnya seperti ini.

00:38.050 --> 00:42.450
Maka pencarian Anda pasand array saya hanya akan melakukan angka.

00:42.470 --> 00:50.700
Tiga puluh empat lima puluh enam satu dua dan kemudian nilai yang saya cari adalah 1 dan itu harus mengembalikan indeks yang

00:50.700 --> 00:53.360
0 1 2 yang harus kembali ke.

00:53.580 --> 00:59.310
Jadi langkah selanjutnya adalah hanya loop melalui array dan periksa apakah elemen array saat ini sama

00:59.310 --> 01:00.190
dengan nilainya.

01:00.660 --> 01:03.340
Jadi mari kita mulai dengan mengulang melalui array.

01:03.660 --> 01:07.930
Itu akan menjadi for loop atau maksud saya Anda bisa melakukan loop SAAT jika Anda mau.

01:08.100 --> 01:09.620
Anda bahkan bisa melakukan foreach.

01:09.650 --> 01:12.770
Ada banyak cara yang akan dilakukan Forfar sama dengan nol.

01:12.780 --> 01:14.160
Kita akan pergi dari awal.

01:14.160 --> 01:18.360
Jadi sementara saya kurang dari panjang array.

01:19.290 --> 01:27.460
Tambahkan satu ke saya dan kemudian Anda perlu memeriksa apakah elemen array saat ini sama dengan nilainya.

01:27.770 --> 01:32.710
Jadi kita mengakses elemen array saat ini dengan RRR array.

01:32.720 --> 01:36.410
Saya akan memeriksa apakah itu sama dengan nilainya.

01:37.070 --> 01:39.150
Jadi kita perlu membuat pernyataan if.

01:40.270 --> 01:43.090
Dan jika itu masalahnya, apa yang akan kita lakukan.

01:43.220 --> 01:44.600
Kami akan kembali.

01:44.960 --> 01:49.720
Yah kami ingin kembali seperti yang Anda lihat di sini indeks di mana elemen ditemukan.

01:49.760 --> 01:55.520
Jadi itu cukup mudah karena kita sudah memiliki I itulah sebabnya saya memilih untuk tidak menggunakan for for loop atau permisi satu sama lain

01:55.520 --> 01:58.000
yang masih dapat Anda lakukan untuk masing-masing dengan indeks.

01:58.010 --> 02:01.160
Tapi kami punya saya keluar dari kotak karena untuk satu lingkaran.

02:01.160 --> 02:02.670
Jadi kita kembali saja.

02:03.140 --> 02:05.640
Jadi dalam hal ini saya akan menjadi nol.

02:05.660 --> 02:08.690
Kita mulai, kita periksa apakah array sama dengan nilainya.

02:08.780 --> 02:10.100
Tidak adalah 34 1.

02:10.160 --> 02:10.700
Tidak.

02:10.940 --> 02:13.100
Selanjutnya adalah 1 adalah 56 1.

02:13.100 --> 02:13.590
Nggak.

02:13.700 --> 02:15.260
Lain kali melalui mata 2.

02:15.440 --> 02:17.880
Jadi kita periksa array 2 yaitu 1.

02:17.900 --> 02:19.750
Apakah itu sama dengan yang kita cari.

02:19.910 --> 02:20.390
Iya nih.

02:20.390 --> 02:22.620
Jadi kami mengembalikan saya yang 2.

02:22.970 --> 02:27.650
Maka kita memiliki hasil tangkapan akhir kita semua jika nilainya tidak pernah ditemukan return negatif 1.

02:28.160 --> 02:30.620
Dan cara termudah untuk melakukannya adalah setelah loop.

02:30.710 --> 02:31.990
Itu berarti kita sudah mencapai akhir.

02:32.180 --> 02:35.490
Jadi jika kita belum kembali sekarang berarti itu tidak ada di sana.

02:35.570 --> 02:42.230
Jadi kita bisa mengembalikan yang negatif begitu saja dan penyederhanaan kecil yang bisa kita buat bisa kita

02:42.230 --> 02:43.060
singkirkan.

02:43.180 --> 02:44.360
Anda dapat melakukan ini dalam satu baris.

02:44.360 --> 02:49.940
Pernyataan if kondisi hanya memindahkan itu kembali ke sana seperti itu.

02:50.180 --> 02:52.990
Persingkat sedikit tapi itu hanya preferensi pribadi.

02:53.000 --> 02:56.170
Jadi jika Trayvon adalah triple sama dengan nilai return I.

02:56.300 --> 02:57.950
Jadi sekarang mari kita coba ini.

02:57.970 --> 03:02.460
Ini adalah pencarian linear dari ini, kita harusnya jika berhasil, dapatkan 0 1 2.

03:02.550 --> 03:05.260
Akan menggunakan perintah enter untuk menjalankannya.

03:05.510 --> 03:11.390
Dan kita mulai, mari kita coba lagi kali ini untuk menambahkan beberapa angka lainnya.

03:12.640 --> 03:16.480
Dan mari kita periksa 56 yang sebenarnya.

03:16.490 --> 03:16.950
Wow.

03:17.000 --> 03:20.450
Saya sangat buruk dalam memilih angka bulat sehingga saya memilih nomor yang sama dua kali.

03:20.450 --> 03:27.680
Mari kita ubah yang ini menjadi 51 dan jika saya menjalankannya kita mendapatkan indeks 6 0 1 2 3 4 5 6.

03:27.680 --> 03:32.270
Akhirnya mari kita mengujinya pada sesuatu yang tidak ada di sana seperti 100.

03:32.270 --> 03:33.860
Kami mendapat negatif 1.

03:33.860 --> 03:40.190
Sekarang jika saya masih memiliki array negara saya, Rigaud karena saya membuat potongan ini saya harus

03:40.190 --> 03:46.510
dapat melakukan pass pencarian linier di negara bagian dan kemudian memeriksa apa indeks Texas misalnya.

03:46.730 --> 03:51.230
Dan kami mendapat 50 dan jika saya memeriksa Anda satu lagi.

03:51.230 --> 03:54.110
Bagaimana dengan Texas dengan X-ray.

03:54.140 --> 03:55.480
Itu tidak ada di sana.

03:55.680 --> 03:56.400
Keren.

03:56.450 --> 03:57.740
Jadi ini pencarian linear.

03:57.740 --> 04:03.740
Inilah yang di balik layar indeks bawaan melakukan salah satu dari pencarian dasar ini yang sudah

04:03.740 --> 04:05.480
kita bicarakan dalam javascript.

04:05.690 --> 04:12.320
Apa lagi yang ada di sana adalah indeks pencarian 0 termasuk semua yang menggunakan pencarian linear dan hal

04:13.190 --> 04:16.570
terakhir yang harus kita bicarakan adalah O besar ini.

04:16.820 --> 04:19.700
Jadi, luangkan waktu sejenak dan coba cari tahu.

04:19.910 --> 04:26.380
Kompleksitas waktu sebagai panjang array yang tumbuh bagaimana waktu yang dibutuhkan kasus terburuk.

04:26.480 --> 04:27.910
Berapa lama waktu yang dibutuhkan.

04:28.700 --> 04:30.730
Dan jawabannya adalah semuanya sudah berakhir.

04:30.750 --> 04:36.830
Dan karena RE kami semakin lama, kami harus melakukan lebih banyak pencarian, kami harus melakukan lebih banyak operasi jika

04:36.830 --> 04:38.610
kami mencari item terakhir Wyoming.

04:38.900 --> 04:45.380
Kita mungkin harus melakukan 59 atau kita harus melakukan pencarian 15: 9 tetapi jika negara kita bukan 5000 Negara dan

04:45.800 --> 04:49.570
kita mencari yang terakhir kita harus memeriksa 5000 item yang berbeda.

04:49.580 --> 04:53.900
Jadi as dan grow adalah panjang array bertambah juga jumlah waktu.

04:53.900 --> 04:59.570
Jadi ini adalah 0 0 dan linear yang juga disebut pencarian venir memberikannya sedikit.

04:59.720 --> 05:06.500
Dan selanjutnya kita akan melihat pencarian lain yang bekerja berbeda di mana jika data diurutkan saat saya mengisyaratkan ada

05:06.500 --> 05:08.360
cara pencarian yang lebih baik.

05:08.630 --> 05:14.060
Dan ini sedikit lebih rumit tetapi ini menyenangkan semacam algoritma pertama untuk meningkatkan sedikit

05:14.270 --> 05:16.740
dari pencarian linear dan lebih cepat.

05:16.790 --> 05:18.530
Jadi kita akan melihatnya di video berikutnya.
