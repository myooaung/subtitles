WEBVTT

00:00.180 --> 00:00.440
Baiklah.

00:00.450 --> 00:01.110
Selamat datang kembali.

00:01.110 --> 00:01.910
Jadi dalam video ini.

00:01.940 --> 00:04.620
Maksudku dengan cepat menjalankan melalui kode semu untuk pengurutan cepat.

00:04.830 --> 00:07.820
Tapi ini cukup singkat jadi saya benar-benar akan mengimplementasikannya juga.

00:07.830 --> 00:12.960
Daripada melakukan video terpisah untuk menunjukkan kode pseudo dan kemudian mengimplementasikannya hanya untuk menjaga hal-hal

00:12.960 --> 00:14.010
sedikit lebih singkat.

00:14.100 --> 00:19.680
Jadi kita memiliki penolong pivot kita selesai kita lewati dalam array penuh atau array apa pun dan itu akan mengambil item pertama

00:19.680 --> 00:24.690
dan mencari tahu ke mana harus pergi dan kemudian meletakkan semua item yang lebih kecil untuk meninggalkan semua item

00:24.690 --> 00:27.150
yang lebih besar ke kanan dan kemudian kembali Indeks.

00:27.450 --> 00:31.800
Jadi itu penting bahwa ia mengembalikan indeks karena apa yang akan kita lakukan dalam

00:32.220 --> 00:37.710
fungsi quicksort kami adalah bahwa itu akan memanggil pivot helper di awal dengan array penuh dan kami akan

00:37.710 --> 00:41.270
mengetahui Anda tahu indeks empat misalnya adalah titik pivot pertama.

00:41.550 --> 00:48.000
Dan kemudian apa yang akan kita lakukan adalah secara rekursif memanggil hal yang sama dengan memanggil quicksort lagi di sisi kiri

00:48.000 --> 00:50.480
dan di sisi kanan titik pivot itu.

00:50.490 --> 00:53.150
Jadi bayangkan kita memanggil quicksort dengan array ini.

00:53.490 --> 00:59.490
Nah hal pertama yang terjadi adalah kita menemukan pivot yang 4 dan dipindahkan ke indeks

00:59.550 --> 01:00.880
ini di sini.

01:01.320 --> 01:08.310
Dan kemudian apa yang akan kita lakukan adalah kita akan memanggil quicksort di sisi ini dari 3 sampai awal tetapi tidak

01:08.580 --> 01:14.460
termasuk pivot karena kita sudah tahu ini apakah ini di tempat yang tidak ingin kita baca kami

01:14.460 --> 01:16.130
tidak ingin memindahkan ini.

01:16.320 --> 01:20.320
Jadi kita akan mengurutkan array di sini dan di sini dengan quicksort.

01:20.340 --> 01:26.550
Jadi logika kasar ketika helper mengembalikan indeks pivot yang diperbarui, kami secara rekursif memanggil pivot

01:26.820 --> 01:31.320
helper di sisi kiri dan kemudian di sisi kanan juga.

01:31.320 --> 01:34.900
Sekarang penting untuk memperhatikan atau menunjukkan bahwa kita tidak membuat array baru.

01:34.950 --> 01:36.760
Ini semua terjadi di tempat.

01:36.810 --> 01:38.490
Kami tidak membuat array baru.

01:38.550 --> 01:39.950
Itu terjadi dalam array yang sama.

01:40.080 --> 01:46.590
Jadi casing dasar kami tidak cukup hanya untuk memeriksa apakah array adalah item dengan panjang atau apakah array memiliki satu item

01:46.590 --> 01:47.330
di dalamnya.

01:47.450 --> 01:53.130
Ini untuk memeriksa apakah sub array memiliki satu item di dalamnya dan apa artinya kita akan

01:53.130 --> 01:55.470
selalu bekerja dengan array ini misalnya.

01:55.470 --> 02:02.150
Tetapi kita hanya akan melihat bagian ini atau bagian ini di mana akhirnya bagian ini.

02:02.430 --> 02:08.820
Jadi apa yang akan kita periksa adalah tidak melihat apakah panjang array adalah 0 atau 1 karena panjangnya akan

02:08.820 --> 02:09.720
selalu sama.

02:09.720 --> 02:11.460
Kami tidak menambahkan dan menghapus elemen.

02:11.580 --> 02:16.530
Kita akan memeriksa apakah titik awal yang kita lihat dan sebut saja kiri

02:16.530 --> 02:22.050
dan kanan jika kiri dan kanan sama satu sama lain atau jika kanan kurang dari kiri

02:22.050 --> 02:26.480
Jadi itu terjadi ketika pinggiran kota memiliki kurang dari dua elemen.

02:26.850 --> 02:28.130
Jadi saya hanya akan mengimplementasikannya.

02:28.120 --> 02:28.940
Ini yang sulit.

02:28.950 --> 02:32.060
Jujur saja ambil kode semu itu dan coba tulis sendiri.

02:32.100 --> 02:35.500
Saya memuji siapa pun yang ingin melakukannya dan yang mencobanya.

02:35.520 --> 02:41.280
Tetapi sekali lagi tidak ada harapan di pihak saya bahwa ketika saya mengajarkan ini secara pribadi, sangat jarang ada

02:41.280 --> 02:43.170
orang yang dapat menerapkannya segera.

02:43.170 --> 02:47.050
Dan bahkan sekali saya menunjukkan kode itu bisa sulit untuk datang dengan itu lagi.

02:47.130 --> 02:51.140
Dan saya sudah menyebutkan perjuangan saya dengan itu dan bagaimana itu hanya tidak intuitif untuk saya.

02:51.330 --> 02:56.370
Jadi saya akan mendefinisikan fungsi quicksort saya dan saya sudah melakukan itu sebenarnya dan itu

02:57.060 --> 02:58.100
akan mengambil array.

02:58.920 --> 03:02.410
Dan hal pertama yang akan kita lakukan adalah menelepon.

03:02.420 --> 03:08.940
Jadi mari kita membuat variabel yang disebut indeks Pivot dan itu hanya akan sama dengan memanggil pivot dengan

03:09.180 --> 03:09.990
array itu.

03:10.380 --> 03:12.970
Tapi masalahnya adalah poros kita.

03:13.080 --> 03:17.510
Pertama-tama, jika kita kembali, array akan menerima awal dan akhir.

03:17.700 --> 03:20.580
Dan ini penting karena baru pertama kali lewat.

03:20.580 --> 03:25.020
Ya kita ingin menyebutnya pada seluruh array tetapi kemudian fungsi rekursif ini

03:25.020 --> 03:31.380
akhirnya akan memanggilnya lagi pada array ini atau ini di mana kita memiliki awal yang berbeda, titik akhir

03:31.710 --> 03:34.320
bukan hanya default 0 hingga akhir array.

03:34.320 --> 03:39.390
Jadi apa yang akan saya lakukan adalah di sini saya akan membuat argumen yang disebut

03:39.390 --> 03:44.510
kiri dan set sama dengan nol dan satu lagi yang disebut hak yang disusun seperti minus.

03:44.730 --> 03:49.380
Dan kemudian kita akan melewati kiri dan kanan ketika kita memanggil poros.

03:49.380 --> 03:54.240
Jadi pertama kali kita menyebut ini di sini nilai default untuk kiri adalah nol.

03:54.270 --> 03:58.010
Dan untuk kanan akan menjadi 0 1 2 3 4 5 6.

03:58.050 --> 04:03.100
Jadi kami memanggil poros pada array ini dengan 0 6 benar.

04:03.120 --> 04:04.490
Jadi begitulah.

04:04.560 --> 04:10.650
Menghapus braket mengambil item pertama di dalam fungsi pivot itu dan mengetahui bahwa ini harus

04:10.650 --> 04:13.000
benar-benar berada di indeks 3.

04:13.050 --> 04:18.010
Jadi itu mengubah array agar terlihat seperti ini dan mengembalikan indeks tiga kepada kita.

04:18.020 --> 04:21.040
Jadi pivot dan x sama dengan tiga pada saat ini.

04:21.150 --> 04:27.480
Kemudian kami ingin mengulangi hal yang sama tetapi kami ingin melakukannya di sisi kiri yang pada dasarnya

04:27.960 --> 04:31.740
berarti dari kiri titik awal yang sekarang adalah nol.

04:31.740 --> 04:35.990
Jadi dari kiri ke atas hingga indeks pivot minus 1.

04:36.510 --> 04:38.660
Jadi kita sudah memasang semen ini.

04:38.670 --> 04:41.510
Kami ingin sekarang memilah dari sini ke sini.

04:41.700 --> 04:43.190
Dan kemudian hal yang sama di sisi kanan.

04:43.380 --> 04:47.990
Tapi kami ingin beralih dari pivot dan X plus satu hingga akhir.

04:48.000 --> 04:49.050
Kanan.

04:49.050 --> 04:50.420
Jadi mari kita lakukan yang kiri dulu.

04:50.460 --> 04:55.530
Jadi sisi kiri hanyalah semacam array cepat.

04:55.620 --> 05:00.430
Kali ini kita akan melewati di kiri dan kanan di mike di sini ketika kita menyebutnya pertama

05:00.670 --> 05:03.980
kali mereka default ke nol dan kemudian sangat panjang minus satu.

05:04.150 --> 05:09.820
Kali ini kiri yang kita lihat masih akan menjadi kiri yang sama dengan yang kita lihat

05:09.900 --> 05:10.810
sebelum nol.

05:11.020 --> 05:16.930
Tapi di sebelah kanan di mana kita akan berhenti akan menjadi apa yang telah kita bahas indeks

05:18.490 --> 05:19.900
pivot minus 1.

05:20.740 --> 05:23.480
Jadi dengan begitu kita tidak memasukkan pengindeksan pivot itu.

05:23.650 --> 05:24.520
Jadi ini disemen.

05:24.520 --> 05:27.830
Kami hanya ingin melihat itu dan hal yang sama di sisi kanan.

05:28.060 --> 05:32.390
Yah tidak persis ide yang sama tapi itu akan menjadi semacam array cepat.

05:32.590 --> 05:35.970
Tapi kita akan mulai dengan pivot index plus satu.

05:36.130 --> 05:38.120
Jadi itu artinya ini adalah indeks kami.

05:38.290 --> 05:40.390
Kami ingin pergi dari sini sampai akhir.

05:40.590 --> 05:42.800
Jadi indeks pivot plus satu Intel.

05:42.880 --> 05:44.770
Kanan.

05:44.800 --> 05:47.300
Jadi itu adalah panggilan rekursif.

05:47.320 --> 05:51.190
Namun jika saya hanya menjalankan ini seperti sekarang ada masalah besar.

05:51.490 --> 05:53.080
Ini akan berjalan selamanya.

05:53.320 --> 05:59.650
Jadi sebenarnya jika saya melakukan ini kita mendapatkan stack overflow ukuran panggilan maksimum stack kita karena tidak pernah ada

05:59.650 --> 06:04.140
kasus dasar tidak pernah dikembalikan sesuatu yang pernah menghentikan panggilan rekursif ini.

06:04.210 --> 06:06.690
Itu terus berjalan dan pergi dan pergi dan pergi dan pergi dan pergi.

06:06.910 --> 06:09.220
Jadi di mana kita ingin berhenti.

06:09.460 --> 06:16.090
Kami ingin berhenti dalam situasi ini atau situasi di mana kami telah mencapai kereta bawah tanah yang panjangnya satu elemen

06:16.840 --> 06:22.090
dan bagaimana kita bagaimana kita tahu itu dan mengingatnya kapan saja jika kita melihat array.

06:22.540 --> 06:25.140
Selalu seluruh array.

06:25.330 --> 06:26.900
Kami menyortirnya di tempat.

06:26.920 --> 06:32.380
Jadi, bahkan langkah ini di sini misalnya array masih seluruh array.

06:32.680 --> 06:39.840
Tetapi apa yang telah berubah adalah kiri dan kanan karena kiri dan kanan terus berubah karena kami memanggil quicksort dan rekursif

06:39.850 --> 06:44.950
karena kiri dan kanan didasarkan dari indeks pivot dan jadi kami mendapatkan indeks pivot

06:44.950 --> 06:47.900
baru setiap kali kiri dan kanan adalah berubah.

06:47.950 --> 06:53.150
Dan saat pinggiran kota ini menjadi lebih kecil kiri dan kanan semakin berdekatan.

06:53.170 --> 07:00.250
Jadi misalnya di sini kiri dengan nol dan kanan dengan enam lalu di sini misalnya kiri ke

07:00.250 --> 07:05.410
nol dan kanan adalah mendengar kiri nol kanan seperti sekarang di sini.

07:05.560 --> 07:09.620
Kiri dan Kanan sama, begitu juga kondisional.

07:09.740 --> 07:12.060
Kami ingin terus melakukan kode ini terus berjalan.

07:12.150 --> 07:20.860
Jika kiri kurang dari kanan dan begitu begitu mereka sama segera setelah hidup sekarang sama dengan benar itu berarti

07:20.860 --> 07:25.420
bahwa kita sedang melihat satu elemen yang masuk akal.

07:25.420 --> 07:29.560
Ingatlah bahwa kiri dan kanan hanyalah pointer di dalam array lengkap ini.

07:29.740 --> 07:31.070
Jadi itu dimulai seperti ini.

07:31.390 --> 07:38.620
Dan kemudian pada salah satu dari mereka panggilan rekursif pindah ke ini dan kemudian ke ini dan kemudian menjadi hal yang

07:38.620 --> 07:39.190
sama.

07:39.340 --> 07:45.380
Dan saat itulah kami berhenti karena itu berarti kami telah mencapai ujung setidaknya dari salah satu cabang.

07:45.580 --> 07:47.460
Jadi saya perlu braket saya di sana.

07:47.490 --> 07:49.170
Itu dia.

07:49.960 --> 07:50.520
BAIK.

07:50.620 --> 07:52.090
Jadi kita masih belum selesai.

07:52.090 --> 07:55.090
Kami memiliki satu bagian yang hilang yang sangat penting.

07:55.090 --> 07:56.420
Kami tidak mengembalikan apa pun.

07:56.530 --> 08:02.710
Kita harus mengembalikan orang Irak pada akhirnya karena ingat bagaimana panggilan rekursif ini bekerja.

08:02.710 --> 08:09.940
Penyortiran cepat ini di sini menunggu hasil penyortiran cepat ini dan penyortiran cepat itu.

08:10.030 --> 08:14.100
Dan kemudian mereka yang menunggu hasil sortir cepat ini dan itu.

08:14.110 --> 08:19.090
Jadi kita harus mengembalikan array di sini sehingga kita bisa mendapatkannya kembali di sini dan terus naik dan kemudian hal

08:19.090 --> 08:20.530
yang sama di sisi kanan.

08:21.190 --> 08:26.060
Jadi mari kita simpan dan kosongkan konsol saya. Mari kita lihat apakah itu berfungsi.

08:26.070 --> 08:29.510
Tidak, tidak jelas area nol.

08:29.550 --> 08:30.850
Mari kita lihat apakah itu berfungsi sekarang.

08:31.510 --> 08:33.000
Dan itu terlihat bagus.

08:33.130 --> 08:35.570
Kami mendapat 1 2 3 4 5 6 9.

08:35.600 --> 08:41.740
Tidak yakin mengapa saya memilih itu dan mari kita verifikasi. Mari kita campur lagi sedikit, masukkan angka

08:41.740 --> 08:43.110
negatif di sini.

08:43.150 --> 08:43.670
Baiklah.

08:43.690 --> 08:45.220
Dan sepertinya itu bekerja.
