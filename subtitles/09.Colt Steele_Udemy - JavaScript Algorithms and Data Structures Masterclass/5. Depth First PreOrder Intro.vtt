WEBVTT

00:00.120 --> 00:01.230
Hai, selamat datang kembali.

00:01.230 --> 00:03.220
Kami mendorong dengan traversal pohon.

00:03.330 --> 00:05.650
Sekarang kita mulai pencarian mendalam pertama.

00:05.670 --> 00:09.420
Jadi ada tiga perintah berbeda dalam pencarian pertama yang akan kita bicarakan.

00:09.520 --> 00:16.860
Tetapi semuanya adalah algoritma DFS yang berarti bahwa mereka mengejar semua simpul yang mereka kunjungi atau melintasi simpul

00:16.860 --> 00:21.130
secara vertikal hingga ke ujung pohon sebelum mengunjungi simpul saudara.

00:21.360 --> 00:26.880
Jadi itu mungkin bukan penjelasan yang paling teknis tetapi itu berarti bahwa kita akan melintasi sampai

00:26.880 --> 00:32.640
kita mencapai ujung pohon di beberapa titik dan kemudian dari sana ada beberapa pilihan sejauh urutan yang

00:32.640 --> 00:33.540
kita lakukan.

00:33.560 --> 00:41.250
Tapi kami bekerja lebih dulu di kedalaman pertama daripada napas secara horizontal terlebih dahulu sehingga kami bisa memecah traversal

00:41.250 --> 00:43.770
pohon menjadi tiga langkah utama.

00:43.770 --> 00:50.880
Jadi untuk setiap simpul kita perlu mengunjungi suatu titik simpul itu sendiri seperti membangun daftar atau

00:50.880 --> 00:51.530
mencetaknya.

00:51.570 --> 00:55.480
Kita perlu menambahkannya ke daftar atau kita perlu mencetaknya apa pun yang kita lakukan.

00:55.500 --> 00:57.460
Jadi kita harus benar-benar melakukan kunjungan.

00:57.570 --> 01:03.240
Kemudian kita juga perlu menjelajahi seluruh sisi kiri dan seluruh sisi kanan setidaknya ketika kita berbicara

01:03.240 --> 01:04.640
tentang pohon biner.

01:04.830 --> 01:09.080
Jika kami tahu Anda berbelok setiap pohon, maka kami perlu melakukan yang pertama, anak kedua dan ketiga.

01:09.090 --> 01:11.270
Tapi mari kita tetap dengan pohon biner untuk saat ini.

01:11.430 --> 01:15.840
Jadi kita harus pada suatu titik menjelajahi node dan kemudian melintasi kiri dan melintasi kanan.

01:15.840 --> 01:21.420
Dan ketiga hal itu hanya dengan mengubah urutan yang kita lakukan dalam kode kita secara harfiah

01:21.420 --> 01:27.450
menyalin garis yang ditempelkan di atas garis menghapusnya di bawah garis lain akan mengubah output yang kita dapatkan.

01:27.450 --> 01:33.210
Jadi dengan algoritme DFS kami, tujuan akhir kami seperti halnya pencarian pertama yang luas adalah hanya membuat array

01:33.210 --> 01:36.230
atau daftar atau jika Anda lebih suka mencetaknya saja.

01:36.420 --> 01:42.180
Tetapi pada dasarnya kami ingin mengunjungi mereka dalam urutan ini di pre order yang merupakan apa yang kami mulai.

01:42.420 --> 01:47.640
Pada dasarnya berarti Anda akan mengunjungi node terlebih dahulu kemudian kita melihat seluruh sisi kiri.

01:47.640 --> 01:52.270
Kami melintasi kiri lalu melintasi kanan dan itu berlaku untuk sembarang simpul.

01:52.290 --> 01:53.770
Jadi kita mulai jam 10.

01:53.970 --> 01:54.840
Kami mengunjungi.

01:54.840 --> 01:57.770
Berarti kami menambahkan ke daftar kami atau kami mencetak.

01:57.900 --> 01:59.860
Lalu kita jelajahi sisi kiri.

02:00.060 --> 02:02.240
Jadi itu berarti mulai jam 6.

02:02.670 --> 02:07.640
Jadi kami mengunjungi enam pertemuan yang berarti kami menambahkannya ke daftar kami atau dicetak.

02:07.770 --> 02:11.470
Lalu kami melintasi seluruh sisi kiri kemudian seluruh sisi kanan.

02:11.520 --> 02:13.400
Jadi itu berarti tiga dan delapan.

02:13.440 --> 02:15.270
Tidak ada yang perlu dilalui setelah mereka.

02:15.270 --> 02:16.780
Jadi mereka dikunjungi.

02:16.980 --> 02:20.370
Sekarang kita kembali ke 10 karena ingat kita mengunjungi 10.

02:20.460 --> 02:22.040
Lalu kami melihat ke sisi kiri.

02:22.050 --> 02:27.780
Sekarang kita harus melihat sisi kanan 10 10 kita masih menunggu untuk mengunjungi sisi kanannya.

02:27.780 --> 02:30.000
Jadi kita punya 15 dan kemudian 20.

02:30.000 --> 02:31.340
Jadi kami memiliki tiga operasi.

02:31.350 --> 02:36.540
Kami mengunjungi simpul yang kami lihat di sebelah kiri dan kami melihat ke kanan hanya

02:36.540 --> 02:43.400
dengan mengubah urutan yang kami lakukan, kami akan memiliki dampak yang sangat drastis pada urutan keluaran urutan traversal yang sebenarnya.

02:43.500 --> 02:46.490
Jadi kita akan membicarakan tentang preorder di video ini.

02:46.560 --> 02:52.770
Lalu ada juga post order dan agar semuanya menjadi algoritma pencarian pertama yang mendalam tetapi ada pesanan yang berbeda dan kita

02:52.770 --> 02:55.550
hanya perlu menggeser satu atau dua baris kode.

02:55.740 --> 02:59.880
Jadi, inilah langkah-langkah dasar yang saya rekomendasikan agar Anda bisa melakukannya berulang-ulang.

02:59.940 --> 03:02.950
Jelas lebih pendek dan lebih mudah untuk melakukannya secara rekursif.

03:02.970 --> 03:08.220
Jadi sekali lagi jika Anda belum melakukan bagian rekursi Rickerson di mana Anda tidak tahu rekursi saya def. sarankan Anda meninjau

03:08.250 --> 03:10.260
bagian itu.

03:10.350 --> 03:10.660
BAIK.

03:10.770 --> 03:15.680
Jadi kita akan membuat variabel seperti yang kita lakukan sebelumnya untuk menyimpan nilai yang kita kunjungi.

03:15.780 --> 03:20.760
Jadi pada akhirnya kita hanya akan mengembalikan yang menyebutnya data atau dikunjungi atau apa pun maka kita akan

03:20.760 --> 03:24.130
membuat variabel bernama Current dan hanya menyimpan root dari pohon di sana.

03:24.490 --> 03:26.440
Jadi di situlah kita memulai.

03:26.790 --> 03:31.830
Sekarang bagian yang sedikit rumit kita akan menulis fungsi pembantu kedua sehingga kita

03:31.830 --> 03:38.370
akan memiliki fungsi preorder kita tidak mengambil argumen dalam fungsi kedua kita yang mengambil node dan menerima dan

03:38.370 --> 03:45.210
melihat argumen dan semua yang dilakukannya adalah kita dorong nilai node ke variabel yang menyimpan nilai kami yang kami

03:45.210 --> 03:50.370
kembalikan ke akhir sehingga kami mengunjungi node dengan menambahkannya ke array atau ke daftar.

03:50.370 --> 03:57.090
Kemudian kami memeriksa apakah ada yang tersisa jika tidak diragukan lagi meninggalkan properti, kami akan secara rekursif memanggil

03:57.090 --> 03:58.490
fungsi pembantu lagi.

03:59.450 --> 04:05.030
Dan kemudian lakukan hal yang sama di sebelah kanan jika memiliki properti tulis, panggil fungsi di sebelah kanan.

04:05.030 --> 04:10.390
Jadi pada dasarnya kita memiliki fungsi pembantu ini di mana untuk node yang diberikan kita mulai dengan rute.

04:10.640 --> 04:15.780
Kami mendorong simpul itu ke daftar yang kami lihat pada hasil akhir kami, data kami.

04:15.950 --> 04:21.200
Jadi kami mengunjungi ruangan dan kemudian bergerak secara rekursif ke hal yang sama untuk kiri dan hal yang

04:21.200 --> 04:22.340
sama untuk kanan.

04:22.400 --> 04:25.790
Jadi kita akan membahas bagaimana ini bekerja dalam solusi akan melihat tumpukan panggilan.

04:25.790 --> 04:31.820
Mungkin sedikit gila untuk mencoba dan memvisualisasikan tetapi jika Anda bisa menulis fungsi pembantu yang menerima sebuah simpul,

04:31.820 --> 04:37.090
dibutuhkan nilai simpul yang mendorongnya ke array kami atau kami yang kami kembalikan pada akhirnya.

04:37.250 --> 04:40.880
Kemudian kita periksa apakah ada kiri kita memanggil fungsi pembantu yang sama.

04:40.880 --> 04:47.240
Saya akan menyebutnya traverse yang kami sebut traverse di sisi kiri node dan kemudian kami juga baris berikutnya di

04:47.240 --> 04:47.990
bawah ini.

04:48.170 --> 04:54.620
Jika ada properti tulis bernama traverse di sisi kanan maka kita akan memanggil fungsi pembantu

04:54.640 --> 04:58.680
dengan variabel saat ini yang dimulai pada root.

04:58.780 --> 05:00.040
Di mana itu di sini.

05:00.340 --> 05:04.880
Dan kemudian di bagian paling belakang mengembalikan array nilai atau daftar nilai yang kami kunjungi.

05:05.200 --> 05:07.060
Jadi saya tahu itu tampak menakutkan.

05:07.180 --> 05:12.210
Jika Anda tidak nyaman dengan rekursi saya benar-benar mengerti bahwa ini relatif.

05:12.220 --> 05:13.970
Ini kata per kata yang cukup banyak.

05:13.990 --> 05:14.740
Ya bukan kata demi kata.

05:14.740 --> 05:16.290
Baris demi baris apa yang perlu Anda lakukan.

05:16.300 --> 05:22.120
Anda dapat melakukan solusi ini hanya dalam beberapa baris mungkin delapan baris tujuh baris.

05:22.570 --> 05:28.270
Dan begitu Anda mendapatkan yang satu ini, sangat mirip dengan dua yang lainnya, yaitu dua urutan pencarian pertama

05:28.330 --> 05:29.180
yang dalam.

05:29.200 --> 05:30.730
Jadi cobalah.

05:30.790 --> 05:34.330
Jangan berkecil hati jika Anda tidak bisa melakukannya karena di video berikutnya saya akan memiliki solusi

05:34.330 --> 05:37.520
yang cukup menyeluruh di mana kita benar-benar berjalan langkah demi langkah cara kerjanya.
