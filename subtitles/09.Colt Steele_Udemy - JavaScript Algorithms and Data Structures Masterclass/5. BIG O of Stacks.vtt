WEBVTT

00:00.240 --> 00:00.550
Baiklah.

00:00.570 --> 00:06.150
Jadi hal terakhir yang akan kita lakukan adalah dengan cepat berbicara tentang tumpukan O besar dan yang paling penting adalah

00:06.150 --> 00:08.100
dua penyisipan dan penghapusan pertama ini.

00:08.190 --> 00:15.000
Jadi cara kami menulis kelas staf kami adalah memastikan bahwa mendorong dan bermunculan adalah waktu yang

00:15.000 --> 00:15.540
konstan.

00:15.540 --> 00:21.750
Itu satu-satunya hal yang harus Anda perhatikan di dek ini mencari mengakses item individual

00:21.780 --> 00:26.370
menggunakan indeks atau posisi yang tidak penting sama sekali.

00:26.460 --> 00:31.380
Dan jika itu Anda mungkin ingin menggunakan array atau struktur data lain yang akan memberi

00:31.380 --> 00:32.710
Anda akses lebih cepat.

00:33.210 --> 00:39.600
Jadi tumpukan benar-benar memprioritaskan penyisipan dan penghapusan dan cara kami menerapkan milik kami jika Anda ingin

00:39.600 --> 00:44.190
mencari sesuatu yang Anda harus mulai dari awal dan hanya melintasi

00:44.400 --> 00:51.210
seluruh tumpukan berikutnya berikutnya berikutnya yang akan memberi kita penyisipan dan penghapusan meskipun karena kami menambah awal dan

00:51.660 --> 00:53.020
menghapus dari awal.

00:53.130 --> 00:55.550
Kami tidak perlu mengulangi daftar atau tumpukan.

00:55.560 --> 01:00.030
Kita tidak harus mencari apa pun yang baru saja kita lompat sejak awal.

01:00.240 --> 01:09.750
Dan itu berarti waktu yang konstan dan terakhir untuk rekap tumpukan adalah struktur data Lythgoe pertama keluar pertama di mana nilai

01:09.750 --> 01:15.930
terakhir selalu yang pertama di luar sana digunakan untuk menangani pemanggilan fungsi seperti

01:15.930 --> 01:17.060
tumpukan panggilan.

01:17.070 --> 01:20.940
Kami telah melihat bahwa mereka juga digunakan untuk operasi seperti undo dan redo.

01:20.940 --> 01:25.880
Untuk merutekan riwayat halaman tempat Anda berada di browser dan lebih banyak lagi dan

01:25.880 --> 01:29.510
itu bukan struktur data bawaan dalam Javascript dalam beberapa bahasa.

01:29.520 --> 01:33.450
Tapi javascript bukan salah satu dari mereka tetapi mereka cukup cepat atau mudah diimplementasikan.

01:33.690 --> 01:40.140
Dan seperti yang saya katakan di video ini atau di video terakhir Anda akan melihat saya menggunakan array untuk mengimplementasikan stack

01:40.170 --> 01:41.190
karena lebih pendek.

01:41.190 --> 01:43.390
Kami tidak harus menggunakan semua kode ini di sini.

01:43.440 --> 01:48.900
Tidak seburuk itu tetapi ketika kita melakukan algoritma yang lebih rumit ini nanti di

01:48.900 --> 01:55.770
mana kita perlu menggunakan stack saya mungkin sudah merekamnya jadi saya pasti akan menggunakan array tetapi ini adalah

01:55.770 --> 02:00.650
cara yang disukai untuk membuat stack jika Anda menggunakan untuk berton-ton data.

02:00.690 --> 02:06.270
Anda tahu tidak ada alasan untuk menggunakan array untuk menyimpan 10.000 item jika Anda hanya mengakses menggunakan push dan

02:06.270 --> 02:08.010
pop atau shift on shift.

02:08.010 --> 02:12.230
Tidak ada alasan untuk melakukan itu hanya dengan menggunakan kelas khusus seperti ini.

02:12.240 --> 02:13.200
Jadi selanjutnya.

02:13.200 --> 02:14.760
Selanjutnya antrian.
