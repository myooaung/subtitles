WEBVTT

00:00.180 --> 00:01.060
Selamat datang kembali.

00:01.140 --> 00:07.080
Selanjutnya saya ingin memperkenalkan pola desain yang umum digunakan dengan rekursi yang disebut rekursi metode

00:07.080 --> 00:07.780
hoper.

00:07.860 --> 00:14.390
Sejauh ini semua fungsi rekursif yang kami tulis adalah fungsi mandiri tunggal seperti faktorial.

00:14.430 --> 00:21.180
Itu rekursif itu sendiri kita sebut faktorial dari luar fungsi dan faktorial itu sendiri menyebut faktorial

00:21.540 --> 00:23.520
di dalam kode sendiri.

00:23.520 --> 00:28.890
Itulah yang terjadi dengan semua fungsi yang telah kami tulis sejauh ini dengan rekursi metode pembantu.

00:28.950 --> 00:30.010
Agak sedikit berbeda.

00:30.120 --> 00:31.800
Jadi kode ini tidak benar-benar melakukan apa pun.

00:31.800 --> 00:37.510
Ini hanya semacam pola yang saya paparkan tetapi dengan rekursi metode pembantu kami memiliki dua fungsi.

00:37.530 --> 00:43.320
Kami memiliki fungsi luar di sini dan kemudian di dalam kami memiliki fungsi rekursif kami.

00:43.320 --> 00:46.800
Jadi fungsi rekursif ini memanggil dirinya sendiri seperti yang Anda lihat di sini.

00:47.070 --> 00:50.880
Sekali lagi ini hanyalah pola yang akan saya tunjukkan pada Anda sebuah contoh nyata yang melakukan sesuatu dalam

00:50.880 --> 00:51.490
waktu singkat.

00:51.660 --> 00:54.610
Itulah yang disebut fungsi helper atau rekursi metode helper.

00:54.630 --> 01:00.480
Kami memiliki fungsi luar utama kami yang kami sebut sebagai pengembang dari luar sini kami akan memanggil luar

01:00.480 --> 01:04.410
dan melewati sesuatu di dalam dan kemudian di dalam kode luar.

01:04.500 --> 01:10.340
Ada fungsi lain yang didefinisikan dan dipanggil dan itu menyebut dirinya secara rekursif.

01:10.340 --> 01:15.960
Jadi ini biasanya dilakukan ketika kita perlu mengkompilasi sesuatu seperti array atau daftar data.

01:16.020 --> 01:21.420
Kami tidak hanya tabulasi kami tidak mengalikan satu nilai berulang-ulang seperti kami

01:21.420 --> 01:25.590
bekerja dengan berbagai faktorial atau sesuatu yang berbeda.

01:25.620 --> 01:26.970
Itu satu lagi yang kami lakukan.

01:27.120 --> 01:34.140
Jika kita melakukan sesuatu seperti ini mengumpulkan semua nilai aneh dalam array sangat mudah untuk melakukan

01:34.140 --> 01:35.540
rekursi metode helper.

01:35.640 --> 01:42.780
Kami membuat array kosong di mana kami kemudian akan menyimpan data kami dan kemudian kami memanggil fungsi pembantu kami.

01:42.780 --> 01:43.890
Jadi alasan kami melakukan ini.

01:43.890 --> 01:50.590
Jika saya mencoba mendefinisikan fungsi yang disebut kumpulkan odds yang menerima daftar nama.

01:50.760 --> 01:57.640
Jika saya mencoba membuat variabel yang disebut hasil dan saya mengaturnya menjadi array kosong.

01:57.660 --> 02:00.720
Di sinilah kita akan meletakkan angka ganjil.

02:00.720 --> 02:06.210
Nah jika kita melakukan fungsi rekursif tidak peduli apa yang saya masukkan setelah ini setiap kali itu disebut

02:06.210 --> 02:08.570
hasil akan diatur ulang menjadi array kosong.

02:08.730 --> 02:10.580
Jadi bagaimana kita akan mengumpulkan data kita.

02:10.590 --> 02:14.270
Bagaimana kita akan memiliki bagian ini yang bertahan sampai sekarang.

02:14.520 --> 02:24.900
Dan satu solusi mudah adalah mendefinisikan hasil di luar kumpulkan peluang seperti ini dan kemudian tambahkan dua hasil di

02:25.140 --> 02:30.720
sini dan bukannya hasilnya mengambang di tengah-tengah tempat seperti ini.

02:30.720 --> 02:35.870
Kami menggunakan rekursi metode helper yang sebenarnya hanya berarti mendefinisikan fungsi di sekitarnya.

02:35.880 --> 02:40.140
Jadi, inilah solusi saya untuk solusi masalah ini.

02:40.200 --> 02:48.230
Sepertinya saya kehilangan pembaruan braket yang menggesernya ok diperbesar terlalu banyak.

02:48.240 --> 02:53.780
Jadi yang kita miliki di sini adalah mengumpulkan nilai-nilai ganjil yang sebenarnya kita sebut di sini.

02:54.000 --> 02:56.350
Akan lewat seperti saya tidak tahu.

02:56.350 --> 03:03.870
Mari kita lakukan sesuatu yang sederhana seperti ini dan dibutuhkan array di dalamnya yang membuat array hasil kita

03:03.920 --> 03:04.680
kosong.

03:04.700 --> 03:11.480
Maka di sini adalah logika rekursif kami dan mengabaikannya untuk sesaat kami memanggil fungsi pembantu yang Anda

03:11.480 --> 03:15.580
tetapkan di sini dengan array dan kemudian kami mengembalikan hasilnya.

03:15.680 --> 03:16.750
Itu untuk menemukan rekan.

03:16.760 --> 03:20.800
Jadi ini akan memanipulasi hasil yang akan ditambahkan ke hasil.

03:20.840 --> 03:25.730
Dan lagi alasan kami melakukan ini adalah bahwa jika kami mencoba mendefinisikan hasil di dalam sini, maka akan

03:25.760 --> 03:27.790
disetel ulang ke array kosong setiap saat.

03:28.010 --> 03:30.590
Jadi dengan bantuan atau metode rekursi kita bisa menyiasatinya.

03:30.860 --> 03:36.500
Dan ini adalah pola umum ketika kita mencoba untuk mengkompilasi semacam hasil biasanya sebuah array atau

03:36.500 --> 03:39.350
semacam struktur data lainnya di sepanjang baris tersebut.

03:39.380 --> 03:45.320
Jadi logika sebenarnya di sini jika kita ingin berjalan melalui ini jika kita melihat helper dieksekusi di

03:45.320 --> 03:46.830
bagian bawah dengan array.

03:46.850 --> 03:48.530
Jadi ini adalah array.

03:48.530 --> 03:55.330
Ini diteruskan dan kami memiliki kasus dasar di mana jika input pembantu kosong jika panjang baris tahun

03:55.330 --> 03:56.930
ini kami hanya kembali.

03:56.930 --> 04:04.540
Kalau tidak, kita periksa apakah input pertama atau elemen pertama mod 2 tidak sama dengan nol.

04:04.540 --> 04:06.240
Itu berarti aneh.

04:06.580 --> 04:09.580
Jadi jika tidak dapat dibagi 2 dengan bersih itu aneh.

04:09.670 --> 04:12.990
Jadi kami mendorong pembantu dan memasukkan 0 ke Brasil.

04:13.390 --> 04:16.510
Maka hal berikutnya yang kita lakukan adalah memanggil pembantu.

04:16.600 --> 04:20.890
Tapi kali ini kami menyebutnya pada segala hal lain dalam array.

04:20.890 --> 04:22.620
Tidak termasuk elemen pertama itu.

04:22.960 --> 04:29.000
Jadi kami membuat kapal selam seperti ini menjadi array yang lebih kecil dan kami meneruskannya untuk membantu dan kami jalankan lagi.

04:29.320 --> 04:30.460
Dan itu tidak kosong.

04:30.460 --> 04:31.930
Jadi kami tidak kembali.

04:32.200 --> 04:36.660
Dan kemudian kita mengambil elemen pertama yang ini dan kita periksa apakah itu genap atau ganjil.

04:36.850 --> 04:37.800
Yah bahkan saat ini.

04:37.800 --> 04:39.200
Jadi ini tidak berjalan.

04:39.220 --> 04:42.720
Jadi kita memanggil pembantu lagi pembantu dan meletakkan irisan itu 1.

04:42.730 --> 04:46.180
Jadi kali ini alih-alih subarray ini kita melihat yang satu ini.

04:46.180 --> 04:50.560
Jadi kita selalu melihat elemen pertama dan kita mengecilkan susunan itu menyusut

04:50.560 --> 04:53.830
dan menyusut sampai kosong dan kita kembali OK.

04:54.130 --> 04:55.890
Jadi itulah logika di baliknya.

04:56.080 --> 04:59.730
Tetapi pola ini apakah itu nilai ganjil atau kita sedang melakukan sesuatu yang lain.

04:59.770 --> 05:02.950
Jadi nanti dalam kursus ini adalah flash ke depan.

05:03.010 --> 05:06.890
Jangan khawatir tentang memahami semua ini tetapi ini dari bagian grafik saja.

05:07.030 --> 05:11.650
Kami memang menemukan metode yang disebut kedalaman pertama rekursif yang memiliki variabel hasil.

05:11.830 --> 05:16.120
Dan ini sebenarnya adalah contoh dari metode rekursi pembantu.

05:16.120 --> 05:22.840
Berikut adalah metode pembantu yang didefinisikan di dalam fungsi kami yang lain dan kami menyebutnya di sini dan sedang

05:22.840 --> 05:24.320
memperbarui variabel hasil.

05:24.380 --> 05:25.630
Pokoknya kita akan kembali ke ini.

05:25.690 --> 05:26.470
Bukan fokus.

05:26.470 --> 05:28.510
Saya hanya ingin menunjukkan kepada Anda bahwa ini adalah hal yang nyata.

05:28.570 --> 05:31.160
Saya tidak hanya mengada-ada atau menunjukkannya kepada Anda tanpa alasan.

05:31.300 --> 05:35.750
Ini adalah traversal aktual dari struktur data grafik sesuatu yang sedikit lebih kompleks.

05:36.030 --> 05:36.550
BAIK.

05:36.730 --> 05:43.030
Jadi ini adalah salah satu cara untuk melakukan solusi ini tetapi ini bukan satu-satunya cara menulis mengumpulkan nilai-nilai ganjil

05:43.240 --> 05:44.170
secara rekursif.

05:44.170 --> 05:50.500
Anda dapat melakukannya tanpa fungsi pembantu Anda dapat melakukannya tanpa harus menentukan hasil di luar

05:50.500 --> 05:54.020
dalam cakupan yang berbeda dan kemudian memperbarui hasil.

05:54.130 --> 05:58.840
Hanya saja ini sederhana, lebih mudah dimengerti di video berikutnya.

05:58.870 --> 06:00.030
Saya akan menunjukkan kepada Anda bagaimana melakukan ini.

06:00.040 --> 06:03.710
Cara rekursi murni yang belum tentu lebih baik.

06:04.000 --> 06:08.410
Ini sedikit lebih membingungkan tetapi itu semua adalah rekursi.

06:08.410 --> 06:10.020
Tidak ada metode pembantu.

06:10.040 --> 06:13.000
Ini sedikit lebih pendek tetapi kita akan sampai di sana.

06:13.000 --> 06:14.050
Itu akan terjadi selanjutnya.

06:14.050 --> 06:19.120
Jadi metode rekursi Hulver hanyalah pola di mana kita memiliki fungsi luar yang tidak

06:19.120 --> 06:22.140
rekursif yang memanggil fungsi dalam yang rekursif.

06:22.290 --> 06:22.640
BAIK.

06:22.750 --> 06:23.260
Saya akan cukup.
