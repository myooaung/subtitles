WEBVTT

00:00.120 --> 00:03.420
Baiklah mari kita lakukan ini, mari kita implementasikan semacam gelembung.

00:03.750 --> 00:06.140
Jadi saya punya instruksi yang cukup spesifik di sini.

00:06.150 --> 00:07.370
Mulai pengulangan.

00:07.590 --> 00:11.060
Oh saya baru sadar ini sedikit salah ketik.

00:11.070 --> 00:11.810
Maaf soal itu.

00:11.880 --> 00:16.930
Mulai perulangan dari ujung array ke awal dengan variabel yang disebut I.

00:17.310 --> 00:20.260
Apa yang sebenarnya akan saya lakukan adalah menunjukkan Domer.

00:20.520 --> 00:27.180
Saya tidak boleh mengatakan bodoh versi yang kurang dioptimalkan yang tidak mengikuti petunjuk ini yang hanya menggunakan

00:27.180 --> 00:32.060
dua loop bersarang yang pergi dari awal hingga akhir array sepanjang jalan.

00:32.370 --> 00:33.600
Sehingga akan terlihat seperti ini.

00:33.600 --> 00:36.000
Saya akan mendefinisikan fungsi saya, saya akan menyebutnya bubble sort.

00:36.000 --> 00:36.780
Saya membuat cuplikan baru.

00:36.780 --> 00:42.650
Omong-omong menerima array dan kita tahu pada akhirnya itu akan mengembalikan array.

00:43.230 --> 00:51.490
Dan katakanlah saya akan menyebutnya dengan array super sederhana seperti 37 45.

00:51.750 --> 00:55.060
Saya memiliki kecenderungan untuk memilih angka ganjil seperti ini.

00:55.200 --> 00:56.310
Itu tidak sengaja.

00:56.440 --> 00:57.810
OK kita akan menempatkan delapan di sana.

00:58.120 --> 00:58.370
BAIK.

00:58.380 --> 00:59.790
Jadi ini yang kita mulai.

01:00.210 --> 01:03.170
Dan kita akan mengulang semua item dalam array.

01:03.240 --> 01:08.250
Jadi untuk kami, saya sama dengan nol dan saya akan melakukan seperti yang saya katakan baru mulai dari awal.

01:08.310 --> 01:13.320
Jadi nol sampai kurang dari plus plus besar.

01:13.380 --> 01:16.020
Jadi itu akan memberi kita izin tunggal.

01:16.120 --> 01:19.680
Jika ini hanya akan mengulang Apa itu empat kali.

01:19.920 --> 01:23.190
Jadi kita akan mulai dengan nol dan mengakhirinya pada 3.

01:23.220 --> 01:28.950
Jadi itu membuat kita cukup untuk mengurutkan satu item sehingga kita dapat membandingkan dan melakukan swap dan pada akhir

01:28.950 --> 01:35.270
dari loop ini jika kita melakukan swap hal kita akan memiliki 45 di akhir array tetapi kita sendiri untuk mengurutkan semuanya.

01:35.430 --> 01:39.130
Jadi kita perlu mengulangi proses itu untuk setiap item secara teknis.

01:39.150 --> 01:45.410
Ingat kita tidak harus melakukannya untuk setiap item setiap kali dalam array itu karena ketika kita

01:45.420 --> 01:47.110
maju akhir menjadi diurutkan.

01:47.370 --> 01:55.630
Jadi jika kita mulai dengan ini di lain waktu kita akan berakhir dengan 45 di akhir.

01:57.240 --> 02:01.320
Jadi lain kali kita hanya perlu menyortir ketiganya.

02:01.320 --> 02:09.640
Dan jika kita lakukan itu, kita akan berakhir dengan gelembung di sini dan sekarang kita hanya perlu menyortir keduanya.

02:09.810 --> 02:13.700
Tetapi untuk solusi naif kita, mari kita biarkan kodenya terus sampai akhir.

02:13.710 --> 02:15.350
Setiap saat.

02:15.360 --> 02:17.330
Jadi untuk itu kita hanya perlu satu loop lagi.

02:17.400 --> 02:29.550
Jadi untuk menyebutnya J sama dengan nol sedangkan J kurang dari panjang J plus plus.

02:29.550 --> 02:31.290
Dan sekarang kita punya J.

02:31.290 --> 02:37.470
Jadi J akan menjadi nol mulai dari awal dan kami ingin membandingkan item apa pun yang

02:37.470 --> 02:40.060
kita lihat dengan J di depan.

02:40.140 --> 02:43.610
Jadi J dan J ditambah satu yang hanya terlihat seperti array J.

02:43.650 --> 02:44.750
Array koma.

02:44.910 --> 02:45.730
Yah tidak koma.

02:45.900 --> 02:47.020
Abaikan itu.

02:47.220 --> 02:48.710
Kami ingin memeriksa apakah lebih besar.

02:48.810 --> 02:51.780
Jadi jika array J lebih besar dari yang ada di depannya.

02:51.810 --> 02:53.100
Menukar.

02:53.130 --> 02:55.590
Jadi mari kita perbaiki logika itu sekarang.

02:55.770 --> 02:59.360
Sekarang sejauh swapping saya akan mulai dengan dasar.

02:59.380 --> 03:05.150
Tukar swap yang sudah dicoba dan benar di mana kami membuat nilai.

03:05.160 --> 03:10.330
Jadi variabel saya akan menyebutnya temp dan mengaturnya ke salah satu dari mereka itu tidak masalah.

03:10.350 --> 03:11.820
Saya akan mengaturnya ke array J.

03:12.000 --> 03:17.180
Dan kemudian kita mengubah nilai array J menjadi array J ditambah 1.

03:17.650 --> 03:20.790
Untungnya kami menyimpan versi lama di variabel sementara kami.

03:20.790 --> 03:24.360
Sekarang kita mengatur array plus 1 sama dengan temp.

03:24.940 --> 03:25.720
BAIK.

03:26.220 --> 03:27.430
Dan itu sebenarnya.

03:27.450 --> 03:32.690
Ini adalah versi kerja semacam gelembung tetapi tidak dioptimalkan karena apa yang kita bicarakan terus

03:32.700 --> 03:36.020
berjalan berulang-ulang dan sebenarnya ada masalah kecil lainnya.

03:36.030 --> 03:41.660
Mari kita mulai dengan menunjukkan log konselor sebaya seperti apa array saat ini.

03:41.670 --> 03:43.870
Baiklah, mari kita lihat apakah itu berfungsi.

03:44.160 --> 03:45.570
Ini kartu masuk pertama kami.

03:45.630 --> 03:48.120
Kami punya tiga puluh tujuh empat puluh lima dua puluh sembilan dan delapan.

03:48.120 --> 03:49.130
Kami membandingkan keduanya.

03:49.330 --> 03:50.550
Tiga puluh tujuh dan empat puluh lima.

03:50.550 --> 03:51.840
Kami tidak bertukar.

03:51.930 --> 03:52.870
Sekarang kita lanjutkan.

03:52.990 --> 03:54.830
J bertambah 1.

03:54.840 --> 03:58.150
Jadi kami membandingkan 45 dan 29 dan kami melakukan swap.

03:58.260 --> 04:00.820
Dia dapat melihat bahwa perubahan tercermin pada waktu berikutnya.

04:01.110 --> 04:03.150
Kemudian kita membandingkan 45 dan 8.

04:03.150 --> 04:04.830
Dan sekali lagi kami bertukar.

04:04.830 --> 04:07.610
Dan itulah yang terjadi di sini delapan dan empat puluh lima.

04:07.740 --> 04:08.430
Itu terlihat bagus.

04:08.430 --> 04:09.680
Kami memiliki 45 di akhir.

04:09.900 --> 04:11.420
Tapi ini masalahnya.

04:11.470 --> 04:13.230
Dan sebenarnya saya sudah sedikit berubah pikiran.

04:13.230 --> 04:18.340
Saya pikir kita bahkan akan lebih jelas seolah-olah daripada hanya mencetak array konsulat log.

04:18.480 --> 04:20.090
Jika kami juga mencetak apa yang kami bandingkan.

04:20.090 --> 04:26.160
Jadi saya akan melakukan array J array J ditambah satu sehingga kita bisa melihat perbandingannya saat itu terjadi.

04:26.770 --> 04:29.070
Saya jelaskan nasihat saya di sini.

04:29.450 --> 04:30.340
Lagi.

04:30.810 --> 04:31.290
BAIK.

04:31.290 --> 04:40.250
Jadi sekarang Anda dapat melihat bahwa kami membandingkan 37 45 45 29 45 dan 8 tetapi kemudian 45 dan tidak ditentukan.

04:40.410 --> 04:42.590
Jadi yang terjadi adalah kami melangkah terlalu jauh.

04:42.660 --> 04:45.460
J mencapai akhir dari loop ini di 45.

04:45.510 --> 04:50.800
Yah J sama dengan tiga indeks tiga dan kami membandingkannya dengan indeks empat yang tidak ada.

04:50.820 --> 04:53.010
Jadi kami membandingkan 45 dan tidak terdefinisi.

04:53.010 --> 04:56.220
Sekarang jenis kami masih berfungsi tetapi kami terlalu lama.

04:56.220 --> 04:57.360
Kami tidak perlu melakukan ini.

04:57.420 --> 05:01.400
Belum lagi fakta bahwa sekarang kita tahu ini diurutkan.

05:01.470 --> 05:02.660
Jadi kita mulai dari awal.

05:02.730 --> 05:06.960
Kami membandingkan ini dengan 37 dan 29 yang ditukar dengan benar.

05:06.990 --> 05:08.140
Jadi kami menukar mereka.

05:08.250 --> 05:09.910
Lalu kita punya tiga puluh tujuh dan delapan.

05:09.930 --> 05:16.450
Kami bertukar lagi dan kami harus selesai dengan iterasi ini, kami harus mulai dari awal dan mulai menyortir ini.

05:16.500 --> 05:18.810
Tetapi sebaliknya kami membandingkan 37 dan 45.

05:18.810 --> 05:22.220
Tetapi kita tahu bahwa itu sudah diurutkan 45 tidak bergerak.

05:22.350 --> 05:26.080
Tidak ada yang lebih tinggi dari 45 karena cara kerja semacam gelembung.

05:26.100 --> 05:28.440
Ini disemen di tempat pertama kalinya.

05:28.620 --> 05:30.380
Jadi kita tidak perlu perbandingan ini.

05:30.630 --> 05:34.980
Dan sekali lagi nanti melalui Anda akan melihat kami melakukan hal yang sama.

05:35.020 --> 05:37.390
Tiga puluh tujuh dan empat puluh lima tidak ada alasan.

05:37.440 --> 05:42.630
Jadi yang ingin kita lakukan adalah pada dasarnya kita ingin membuat tiga perbandingan.

05:42.630 --> 05:44.490
Jadi ada empat item dalam array ini.

05:44.640 --> 05:46.230
Kami ingin memiliki tiga perbandingan.

05:46.260 --> 05:48.990
Satu dua satu dua tiga.

05:49.410 --> 05:53.980
Dan kemudian kita harus mulai dari awal dan lain kali hanya membuat dua perbandingan.

05:53.980 --> 05:58.270
Ini perbandingan ini di sini 37 dan 29 dan kemudian tiga puluh tujuh dan delapan.

05:58.420 --> 06:01.290
Dan kemudian lain kali kita harus membandingkannya.

06:01.290 --> 06:05.520
Apakah itu masuk akal kita ingin kita ingin mengecilkan jumlah perbandingan yang kita buat karena kita

06:05.520 --> 06:07.160
mengurutkan array saat kita pergi.

06:07.530 --> 06:11.350
Jadi solusi untuk itu jika kita datang dan melakukan beberapa pengeditan.

06:11.550 --> 06:15.060
Yang pertama adalah bahwa saya benar-benar akan mengubah cara loop ini diatur.

06:15.060 --> 06:17.380
Saya sekarang akan mengikuti kode semu yang saya atur.

06:17.490 --> 06:19.050
Kita akan mulai dengan variabel i.

06:19.100 --> 06:22.350
Mulai dari akhir array ke awal.

06:22.950 --> 06:26.400
Jadi sepertinya ini diatur menjadi panjang titik merah.

06:26.850 --> 06:33.240
Dan kita pergi wow saya lebih besar dari nol minus minus.

06:33.240 --> 06:38.520
Alasan kami melakukan ini adalah agar kami dapat menggunakan I dalam definisi loop untuk J.

06:38.520 --> 06:45.490
Jadi J sekarang berjalan liar kurang dari saya dot atau saya keberatan ini.

06:45.510 --> 06:46.470
Apa yang saya katakan Don.

06:46.670 --> 06:47.570
Saya minus satu.

06:47.790 --> 06:48.130
BAIK.

06:48.150 --> 06:51.210
Jadi pada awalnya panjang sinar kita adalah empat.

06:51.210 --> 06:52.000
Selalu empat.

06:52.010 --> 06:54.090
Tapi saya mulai jam empat.

06:54.090 --> 07:00.240
Jadi loop ini loop batin kita akan membandingkan J kurang dari empat minus satu.

07:00.270 --> 07:01.560
Jadi tiga perbandingan.

07:01.560 --> 07:06.000
Ini memberi kita tiga perbandingan pertama kali karena saya berusia empat tahun.

07:06.030 --> 07:08.580
Itu berarti J berlaku untuk minus 1 3.

07:08.580 --> 07:12.590
Lain kali saya turun saya berada di minus ini.

07:12.600 --> 07:14.770
Jadi kita berakhir dengan saya sama dengan tiga.

07:14.790 --> 07:18.050
Jadi kita punya J kurang dari tiga minus satu.

07:18.150 --> 07:22.380
Jadi itu artinya loop ini akan berjalan sementara J kurang dari 2.

07:22.530 --> 07:25.950
Jadi saat aku turun begitu pula J.

07:26.370 --> 07:29.530
Jadi kami akhirnya menjalankan loop lebih sedikit setiap kali.

07:29.700 --> 07:36.710
Jadi, jika saya menyimpan ini, singkirkan X rerun ekstra itu mungkin menghapus kontra. tidak.

07:37.390 --> 07:39.760
Sekarang mari kita lihat perbandingan yang dibuat.

07:39.760 --> 07:48.610
Jadi kita melakukan 37 dan 45 yang masuk akal kemudian 45 dan 29 dan kemudian perbandingan akhir kita pada kali pertama ini melalui empat

07:49.010 --> 07:54.810
puluh lima dan delapan dan kita berakhir dengan pertama kali melalui 45 adalah pada akhirnya.

07:54.820 --> 07:55.650
Lalu kita mulai lagi.

07:55.660 --> 08:01.240
Kami tidak lagi menyortir undefined dan 45 karena ini minus.

08:01.240 --> 08:10.660
Jadi, kali berikutnya kita melakukan dua perbandingan 37 dan 29 jadi kita bertukar dan kemudian 37 dan 8 dan kita bertukar

08:10.660 --> 08:11.330
lagi.

08:11.740 --> 08:13.660
Dan pada saat itu keduanya disemen.

08:13.930 --> 08:20.200
Jadi lain kali kita hanya perlu melakukan satu perbandingan lagi dan Anda dapat melihat bahwa delapan dua puluh sembilan

08:20.200 --> 08:21.860
kami bertukar dan kami selesai.

08:22.210 --> 08:23.250
Jadi apa yang bisa saya lakukan.

08:23.410 --> 08:27.970
Mari kita tambahkan, mari ubah ini menjadi 8 12.

08:28.270 --> 08:30.140
88 seratus.

08:30.190 --> 08:30.730
Sekarang mari kita lihat.

08:30.730 --> 08:33.340
Nilai negatif 3 area negatif.

08:33.730 --> 08:38.440
Dan jika kita jalankan sekarang, mari kita bersihkan konsol terlebih dahulu.

08:38.440 --> 08:39.620
Itu dia.

08:40.180 --> 08:41.530
Mari kita biarkan aku sebenarnya.

08:41.680 --> 08:44.330
Maaf ini menjengkelkan, tetapi izinkan saya membuatnya lebih mudah dilihat.

08:44.440 --> 08:51.940
Jadi setelah loop selesai, mari kita lakukan conses log 1 pass selesai seperti ini.

08:52.150 --> 08:54.700
OK jalankan kembali ini.

08:55.950 --> 08:56.510
BAIK.

08:56.950 --> 09:02.260
Jadi sekarang Anda dapat melihat benar-benar apa yang terjadi pertama kali melalui kami melakukan perbandingan satu dua tiga empat lima enam

09:02.830 --> 09:04.480
maka itu adalah satu lulus penuh.

09:04.540 --> 09:09.670
Lain kali melaluinya kami melakukan perbandingan satu dua tiga empat lima dan kemudian empat dan

09:09.670 --> 09:12.420
kemudian tiga kemudian dua dan kemudian satu.

09:12.430 --> 09:15.410
Jadi ini adalah salah satu versi solusinya.

09:15.490 --> 09:16.890
Singkirkan konser yang mencatat.

09:17.110 --> 09:25.990
Saya juga memiliki versi 2015 Timur di mana saya memutuskan untuk pertama kali saya menggunakan versi lama atau maaf cara baru bertukar hal

09:25.990 --> 09:28.930
dan saya memutuskan untuk membuatnya menjadi fungsi.

09:28.960 --> 09:30.480
Anda pasti tidak perlu melakukan itu.

09:30.490 --> 09:32.430
Maksud saya ini hanya tiga baris dengan jujur.

09:32.760 --> 09:37.910
Tetapi jika Anda ingin mendengar adalah semakin bagus beberapa orang menganggap solusi ini lebih bagus.

09:37.960 --> 09:41.270
Gunakan lebih sedikit juga dan sebaliknya.

09:41.320 --> 09:41.800
Apa lagi.

09:41.800 --> 09:42.640
Fungsi panah besar.

09:42.640 --> 09:45.210
Semuanya cukup mudah.

09:45.580 --> 09:48.010
Anda tinggal menjalankannya dan memastikan masih berfungsi tentu saja

09:51.580 --> 09:52.450
kita mulai.

09:52.500 --> 09:55.060
Mereka memberi tiga hingga 88.

09:55.450 --> 09:55.660
BAIK.

09:55.660 --> 09:58.030
Jadi ini adalah dua solusi yang berfungsi untuk memilah gelembung.
