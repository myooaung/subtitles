WEBVTT

00:00.210 --> 00:00.560
Baiklah.

00:00.560 --> 00:01.350
Selamat datang kembali.

00:01.350 --> 00:06.690
Kami telah mencapai langkah terakhir dari lima langkah dan ini mungkin langkah paling penting

00:06.690 --> 00:09.800
dalam hal meningkatkan menjadi pengembang yang lebih baik.

00:09.840 --> 00:14.370
Jadi kami memahami masalah yang kami bicarakan tentang contoh nyata yang dipecah menjadi beberapa langkah.

00:14.370 --> 00:17.250
Kami memecahkannya atau menyederhanakannya untuk membantu kami menyelesaikannya.

00:17.250 --> 00:22.560
Dan sekali kita memiliki sesuatu apakah itu solusi yang luar biasa atau super scrappy saatnya untuk melihat

00:22.560 --> 00:24.030
ke belakang dan refactor

00:24.030 --> 00:29.010
Saya tahu itu menggoda bahwa sekali Anda memiliki sesuatu yang bisa dilakukan cukup baik yang melakukan apa yang

00:29.010 --> 00:29.570
perlu dilakukan.

00:29.730 --> 00:33.640
Anda tergoda untuk hanya tahu menutup laptop Anda atau menutup buku dan pergi.

00:33.660 --> 00:34.040
Saya tidak tahu

00:34.050 --> 00:36.680
Mainkan permainan video atau lakukan sesuatu yang lain.

00:36.740 --> 00:42.500
Ini sangat menggoda karena sering kali Anda dapat bertahan dengan sesuatu yang hanya berfungsi.

00:42.810 --> 00:45.570
Dan dalam banyak pekerjaan dan banyak skenario.

00:45.600 --> 00:47.410
Yang penting adalah sesuatu bekerja.

00:47.430 --> 00:52.380
Tidak harus cantik, tidak harus menjadi kode yang paling efisien di Bumi tetapi sangat

00:52.380 --> 00:54.750
penting untuk berjuang untuk tujuan-tujuan tersebut.

00:54.750 --> 00:59.190
Jelas jika Anda adalah satu tim pria dan Anda adalah satu tim wanita dan

00:59.190 --> 01:04.140
Anda menciptakan perusahaan Anda sendiri dan Anda memiliki tenggat waktu besok dan Anda hanya perlu menulis kode yang

01:04.140 --> 01:08.590
berfungsi maka ya tidak apa-apa untuk dihapuskan tetapi sangat penting untuk mencoba dan meningkatkan kode Anda.

01:08.790 --> 01:15.120
Dan ini adalah peluang yang terlewatkan jika Anda tidak meluangkan waktu untuk melihat kode Anda melihat kembali dan

01:15.120 --> 01:15.690
merenungkannya.

01:15.840 --> 01:19.990
Dan saya tidak hanya bermaksud Anda tahu dengan cara yang puitis.

01:20.010 --> 01:25.110
Maksud saya, melihat setiap komponen, baris per baris, berbicara tentang bagian-bagian yang tidak Anda sukai atau apa

01:25.110 --> 01:31.200
yang tidak Anda sukai tentang bagaimana kode itu sendiri terlihat bagaimana ia membaca betapa mudahnya memahami dengan jelas apa yang

01:31.200 --> 01:34.340
kebanyakan orang pedulikan adalah efisiensi ketika mereka sedang melihat kode.

01:34.440 --> 01:40.770
Namun sering kali ada keseimbangan yang perlu dicapai antara dua pilar efisiensi dan keterbacaan dan

01:41.280 --> 01:42.800
dalam pengaturan wawancara.

01:42.930 --> 01:46.920
Sangatlah penting untuk menanyakan pertanyaan-pertanyaan ini sering dengan keras.

01:47.010 --> 01:49.070
Anda memiliki solusi yang sudah jadi.

01:49.260 --> 01:51.900
Anda bisa bangga bahwa sesuatu berhasil.

01:51.930 --> 01:58.350
Saya suka kemudian mengambil waktu sejenak dan semacam pergi baris demi baris dan berpikir oh Anda tahu ini tidak ideal Saya pikir mungkin ada cara yang lebih

01:58.500 --> 02:02.400
baik untuk melakukan ini tetapi saya tidak yakin saya akan google jika ada cara yang lebih cepat

02:02.400 --> 02:04.090
untuk melakukan ini hal semacam itu.

02:04.140 --> 02:05.340
Jadi saya akan membahasnya.

02:05.460 --> 02:08.730
Tapi ini semacam daftar pertanyaan yang bisa Anda tanyakan pada diri sendiri.

02:09.030 --> 02:13.410
Bisakah Anda memeriksa hasilnya sehingga jelas kita perlu memastikan kode kita berfungsi.

02:13.410 --> 02:15.740
Bisakah Anda menurunkan hasilnya secara berbeda.

02:15.780 --> 02:21.330
Jadi ini merujuk pada kenyataan bahwa jarang ada satu solusi dan hanya satu solusi untuk masalah.

02:21.330 --> 02:24.960
Jadi, bisakah Anda memikirkan pendekatan yang berbeda sekarang setelah Anda menyelesaikannya satu arah.

02:24.960 --> 02:29.400
Apakah ada cara lain yang tampaknya dapat dilakukan yang tidak dapat Anda pikirkan sebelumnya.

02:29.400 --> 02:32.240
Bisakah Anda melihatnya sekilas atau memahaminya sekilas.

02:32.250 --> 02:37.080
Jadi seberapa intuitif solusi Anda apakah masuk akal ketika Anda melihatnya di atas kertas di papan tulis

02:37.260 --> 02:41.600
di editor kode Anda dapat Anda gunakan hasil atau metode untuk beberapa masalah lain.

02:41.610 --> 02:47.310
Salah satu manfaat besar memecahkan masalah adalah membantu Anda mengembangkan spider sense, intuisi

02:47.310 --> 02:49.510
untuk menyelesaikan masalah lain.

02:49.530 --> 02:54.720
Jadi, setiap kali Anda menuliskan solusi, ada baiknya berhenti sejenak dan bertanya pada diri sendiri apakah ada kesamaan

02:54.720 --> 02:56.790
antara solusi ini atau masalah ini.

02:56.790 --> 02:58.570
Pada orang lain yang Anda temui di masa lalu.

02:58.740 --> 02:59.880
Jadi mungkin tidak.

02:59.880 --> 03:03.740
Dalam pengaturan wawancara tentu tetapi ini telah terjadi pada saya beberapa kali.

03:03.780 --> 03:09.000
Saya memecahkan beberapa masalah dan itu semacam membuka solusi untuk masalah lain pada proyek yang berbeda

03:09.270 --> 03:12.060
atau perusahaan yang berbeda atau sesuatu seperti itu.

03:12.390 --> 03:14.250
Jadi itu sesuatu yang perlu diingat.

03:14.490 --> 03:14.770
BAIK.

03:14.790 --> 03:18.020
Selanjutnya Anda dapat meningkatkan kinerja solusi Anda.

03:18.030 --> 03:23.140
Jadi ini adalah salah satu yang seperti saya katakan mungkin ada di puncak pikiran banyak orang ketika mereka

03:23.140 --> 03:23.840
menulis solusinya.

03:23.850 --> 03:26.700
Jadi bagaimana kita membuatnya lebih baik.

03:26.730 --> 03:29.850
Terutama Anda tahu kompleksitas waktu dan kompleksitas ruang.

03:29.850 --> 03:32.550
Dan itu adalah sesuatu yang sering kita bicarakan dalam kursus ini.

03:32.550 --> 03:36.680
Jadi, jika Anda tidak nyaman mengukurnya atau menghitungnya, itu OK.

03:36.690 --> 03:43.140
Tetapi kita masih dapat mengidentifikasi hal-hal tertentu yang mungkin berkinerja buruk atau lambat misalnya seperti sekelompok

03:43.140 --> 03:46.130
loop yang bersarang coba dan hindari itu.

03:46.200 --> 03:49.440
Dapatkah Anda memikirkan cara lain untuk bereaksi terhadap kode Anda jika Anda bekerja untuk sebuah perusahaan.

03:49.440 --> 03:52.440
Apakah kode Anda mengikuti panduan gaya pedoman perusahaan.

03:52.440 --> 03:54.630
Apakah ini mengikuti konvensi bahasa.

03:54.630 --> 03:56.410
Apakah spasi konsisten.

03:56.460 --> 04:02.970
Hanya hal-hal kecil tetapi ini penting untuk diperlihatkan bahkan dalam pengaturan wawancara setidaknya mengakui fakta bahwa kode Anda tidak rapi

04:02.970 --> 04:07.400
dan bahwa Anda lebih suka membuatnya lebih rapi jika Anda tidak punya waktu.

04:07.410 --> 04:10.530
Dan terakhir bagaimana orang lain memecahkan masalah ini.

04:10.590 --> 04:16.280
Jadi dalam pengaturan wawancara sering Anda tahu pewawancara menanyakan pertanyaan yang sama kepada banyak kandidat yang berbeda.

04:16.290 --> 04:21.730
Beberapa perusahaan saya telah melihat pertanyaan Anda yang sama selama bertahun-tahun sehingga mereka mungkin telah melihat banyak

04:21.750 --> 04:23.050
kandidat dan banyak solusi.

04:23.070 --> 04:28.050
Jadi dalam sebuah wawancara itu bisa sangat bermanfaat setelah Anda memiliki sesuatu apakah itu berfungsi

04:28.050 --> 04:28.800
atau tidak.

04:29.010 --> 04:34.140
Pada akhirnya untuk memilih otak mereka katakan Anda tahu apa pendekatan lain yang ada apa yang saya lewatkan.

04:34.140 --> 04:35.800
Bagaimana Anda melihat orang memecahkan ini?

04:35.880 --> 04:40.120
Dan kadang-kadang orang suka berbagi solusi yang paling efektif atau paling sederhana.

04:40.230 --> 04:45.360
Lain kali orang-orang suka berbicara tentang solusi paling gila dan paling eksentrik cara paling tak terduga untuk

04:45.360 --> 04:50.520
menyelesaikannya bahkan jika itu bukan yang paling efisien tetapi Anda bisa belajar banyak dari melihat bagaimana orang

04:50.520 --> 04:52.440
lain telah memecahkan masalah yang sama.

04:52.440 --> 04:58.110
Sekarang jika Anda sendirian, Anda mengerjakan proyek dan aplikasi dan Anda sedang memecahkan masalah.

04:58.310 --> 05:01.660
Seringkali Anda memecahkan sesuatu yang belum diselesaikan orang lain sebelumnya.

05:01.800 --> 05:06.240
Kalau tidak, Anda mungkin tidak memprioritaskan menyelesaikannya sendiri.

05:06.250 --> 05:09.920
Jika perlu, Anda tidak akan membangun basis data Anda sendiri dari awal.

05:09.960 --> 05:14.070
Anda dapat menggunakan database orang lain tetapi kadang-kadang ada beberapa hal yang

05:14.070 --> 05:19.050
Anda implementasikan sendiri dan ada baiknya melihat implementasi lain apakah itu dalam bahasa yang berbeda.

05:19.050 --> 05:20.760
Ini sering terjadi pada saya.

05:20.940 --> 05:24.150
Jika saya menulis sesuatu, Anda mungkin tidak menemukannya di javascript.

05:24.150 --> 05:29.730
Anda dapat mencari di sekitar dan Anda mungkin menemukan kode orang lain di Jawa atau Python dan Anda dapat

05:29.730 --> 05:34.860
mengambilnya dan membandingkannya dengan Anda tergantung pada seberapa nyaman Anda melakukan itu dan itu bisa sangat berguna

05:35.280 --> 05:38.310
dan Anda dapat menemukan ide dalam pendekatan yang berbeda pula.

05:38.370 --> 05:41.040
Jadi ini banyak pertanyaan di sini yang bisa dia tanyakan pada diri sendiri.

05:41.040 --> 05:45.390
Tetapi poin saya adalah bahwa refactoring sangat penting dan bahkan tidak harus menjadi refactoring itulah

05:45.390 --> 05:46.470
mengapa saya menyebutnya.

05:46.470 --> 05:51.360
Lihat ke belakang dan refactor karena kadang-kadang Anda bisa bahagia dengan kode Anda.

05:51.360 --> 05:54.800
Atau Anda mungkin tidak ingin melakukan perubahan tetapi ada baiknya memikirkannya.

05:54.810 --> 05:58.050
Ada baiknya menganalisis kode Anda dan merenungkannya.

05:58.050 --> 06:02.030
Melihat ke belakang daripada sekadar menulis sesuatu yang berhasil dan menyebutnya sehari.

06:02.160 --> 06:06.670
Jadi mari kita lihat versi proses yang disederhanakan dengan solusi saya di sini.

06:06.810 --> 06:08.910
Jadi saya sedikit mengubah solusi saya.

06:08.940 --> 06:09.420
Ini dia.

06:09.420 --> 06:15.030
Ngomong-ngomong semuanya sama dengan apa yang kita lihat di video terakhir saya menambahkan dalam

06:15.280 --> 06:19.080
ekspresi reguler sederhana untuk menguji apakah karakter alfanumerik.

06:19.080 --> 06:25.760
Jadi jika huruf kecil A sampai Z atau nol hingga sembilan dan ini adalah bagaimana saya menyapu

06:25.760 --> 06:31.680
semua ruang karakter non-alfanumerik menggarisbawahi tanda titik koma dan hanya melakukan huruf dan angka dan

06:31.910 --> 06:36.030
saya huruf kecil dulu dan kemudian saya menguji setiap karakter.

06:36.060 --> 06:41.070
Jadi, jika kita sampai pada titik ini karakternya bisa berupa angka atau huruf dan kemudian kita periksa seperti yang

06:41.280 --> 06:42.940
kita lakukan di video terakhir.

06:42.960 --> 06:48.750
Jika karakter sudah ada di objek yang berarti lebih besar dari nol, maka diatur ke 1 atau 2 atau 3.

06:48.750 --> 06:53.620
Misalnya, tambahkan 1 hingga 2 nilai jika tidak, inisialisasi ke 1.

06:53.670 --> 06:58.040
Saya yakin bahwa satu ekstra datang dari dan kemudian kami mengembalikan objek di akhir.

06:58.140 --> 07:03.600
Jadi ini berhasil dan jika saya menyelesaikan ini di akhir wawancara, ini adalah solusi saya.

07:03.660 --> 07:06.680
Rasa sakit utama menunjuk pada hal-hal yang akan saya tunjukkan.

07:06.740 --> 07:12.380
Ada beberapa yang mudah diperbaiki adalah saya bukan penggemar menggunakan for for.

07:13.050 --> 07:15.260
Jelas untuk loop besar dan mereka telah ada selamanya.

07:15.420 --> 07:21.090
Tetapi dalam lanskap hari ini saya mungkin akan menggunakan empat loop hanya untuk menyederhanakan ini sehingga kita tidak

07:21.090 --> 07:22.350
harus bekerja dengan saya

07:22.830 --> 07:26.580
Karena jika kita melakukan 4 pada string itu memberi kita masing-masing karakter segera.

07:26.580 --> 07:29.720
Tidak ada alasan untuk pergi, Anda tahu ini adalah langkah tambahan.

07:29.910 --> 07:33.900
Loop melalui rentang angka kemudian ambil angka itu untuk mendapatkan karakter individu.

07:34.050 --> 07:36.920
Ketika saya bisa menggantinya, saya akan memperbaiki ini.

07:37.030 --> 07:42.190
Simpan ini di sini tetapi perlahan-lahan refactor di sini dan ini bukan hal kinerja.

07:42.360 --> 07:45.480
Kurasa hanya estetika saja.

07:45.480 --> 07:49.690
Saya akan mengatakan var char dari string itu.

07:50.050 --> 07:53.070
Maka Anda tidak perlu mendefinisikan char lagi.

07:53.130 --> 07:54.140
Kita akan huruf kecil.

07:54.280 --> 07:59.250
Jadi bagan ini untuk huruf kecil sehingga kita tidak perlu lagi melakukannya.

07:59.250 --> 08:05.000
Untaian saya hanya bekerja dengan char dan ini harus tetap bekerja.

08:05.190 --> 08:07.220
Mari kita verifikasi saja.

08:07.380 --> 08:08.540
Jadi saya menempel.

08:08.760 --> 08:11.140
Mari kita lakukan halo.

08:11.550 --> 08:15.870
Hai beri tanda baca dan sepertinya itu berfungsi.

08:15.870 --> 08:18.190
Kami memiliki dua huruf H lebih rendah.

08:18.280 --> 08:19.290
OK, itu bagus.

08:19.500 --> 08:22.280
Sekarang perubahan sintaks kecil yang bisa kita buat.

08:22.290 --> 08:26.670
Ini bukan masalah besar, tetapi hal ini mengganggu saya ketika saya melihatnya membutuhkan banyak ruang

08:26.670 --> 08:32.550
untuk melakukan hal yang sangat sederhana di mana menambahkan 1 ke angka atau menetapkan angka ke 1 atau menginisialisasi nilai pada

08:32.670 --> 08:33.530
kunci .

08:33.600 --> 08:34.050
Ya ampun.

08:34.050 --> 08:36.560
Dalam suatu objek Anda menginisialisasi nilai ke nol.

08:36.570 --> 08:42.170
Jadi kita menginisialisasi ke nol atau menambahkan 1 padanya yang merupakan hal yang cukup sederhana dan sesederhana

08:42.190 --> 08:48.690
itu kalau begitu sering saya melihat untuk menggabungkan ini menjadi satu baris jika mungkin dan itu bisa sulit jika Anda

08:48.690 --> 08:51.120
berada dalam wawancara yang menegangkan situasi.

08:51.120 --> 08:56.850
Seringkali saya hanya menulis hal pertama yang muncul dalam pikiran sintaksis paling dasar yang paling sederhana dan kemudian

08:56.850 --> 09:01.290
kembali dan membersihkannya sehingga kita dapat mengganti ini di sini dengan baris ini.

09:01.350 --> 09:08.100
Jadi yang dilakukan adalah dibutuhkan karakter seperti Access, nilai yang sesuai di objek kita.

09:08.100 --> 09:12.840
Jadi jika itu benar kita akan menambahkan satu ke dalamnya.

09:12.840 --> 09:14.980
Berarti jika sudah ada nilai di sana.

09:15.300 --> 09:18.320
Jika tidak ada di sana kita akan mengaturnya menjadi 1.

09:18.480 --> 09:20.970
Jadi pada dasarnya kami memiliki dua skenario.

09:20.970 --> 09:25.350
Obyek char sama dengan char objek ini ditambah satu.

09:25.560 --> 09:29.590
Atau jika falsie set sama dengan 1.

09:30.030 --> 09:35.940
Jadi ini adalah cara yang baik untuk membersihkan kode kita dengan memperpendeknya sedikit dan hanya untuk memverifikasi bahwa kode itu masih

09:35.940 --> 09:36.480
berfungsi.

09:36.480 --> 09:38.430
Sekali lagi.

09:38.430 --> 09:43.430
Disisipkan dengan benar dan sepertinya berfungsi.

09:43.590 --> 09:48.730
Jadi hal terakhir dan ini mungkin hal terpenting yang akan saya pikirkan di sini.

09:48.960 --> 09:51.920
Kami melakukan beberapa perubahan gaya.

09:52.200 --> 09:53.850
Anda tahu kita bisa menggunakan lebih banyak lagi.

09:53.910 --> 09:58.250
Sintaks 2015 ganti var dengan lut dan konstan.

09:58.410 --> 10:00.000
Itu mungkin ide yang baik untuk dilakukan.

10:00.000 --> 10:04.830
Tetapi hal yang paling mendesak dalam pikiran saya bahwa saya tidak yakin apakah ini dalam pengaturan

10:04.830 --> 10:09.750
wawancara saya akan mengatakan OK baik saya menggunakan ekspresi reguler di sini karena saya tahu bagaimana melakukannya.

10:09.820 --> 10:15.180
Dan ini adalah cara yang relatif cepat untuk memeriksa suatu pola tertentu.

10:15.180 --> 10:21.150
Dalam kasus kami untuk melihat apakah karakter alfanumerik huruf atau angka, tetapi saya tidak yakin seberapa

10:21.150 --> 10:22.440
efisien itu sebenarnya.

10:22.620 --> 10:26.580
Dan saya akan mengatakan bahwa saya akan mengatakan Anda tahu saya pernah mendengar hal-hal tertentu dalam Javascript.

10:26.590 --> 10:29.010
Dan ini berlaku dalam ekspresi reguler javascript.

10:29.100 --> 10:33.300
Kinerja dapat bervariasi tergantung pada apa yang Anda lakukan dan tergantung pada browser tempat Anda berada.

10:33.330 --> 10:37.490
Secara khusus Chrome memiliki beberapa masalah dengan ekspresi reguler beberapa waktu lalu.

10:37.650 --> 10:43.360
Jadi saya agak berusaha menghindari mereka karena mereka bisa sangat berguna untuk hal seperti ini.

10:43.380 --> 10:46.370
Ini adalah penggunaan ekspresi reguler yang sangat sederhana.

10:46.440 --> 10:51.600
Seringkali orang akan menggunakannya untuk menemukan pola seperti pola kartu kredit atau nomor telepon atau

10:51.600 --> 10:56.740
alamat adalah hal-hal yang jauh lebih rumit seperti mencocokkan pola yang akan sangat merepotkan.

10:57.000 --> 11:02.260
Tetapi hanya memeriksa apakah ada huruf atau angka saya pikir mungkin ada cara yang lebih baik untuk melakukan ini.

11:02.310 --> 11:05.590
Jadi saya akan mengatakan itu keras-keras dan Anda mungkin tidak.

11:05.700 --> 11:07.620
Ini mungkin tidak langsung terpikirkan.

11:07.700 --> 11:09.710
Itu tidak langsung terlintas di pikiran saya juga.

11:09.870 --> 11:13.890
Tapi apa yang bisa Anda lakukan, saya baru saja melakukan riset untuk mencari tahu.

11:13.890 --> 11:17.420
Gunakan karakter char at di.

11:17.460 --> 11:25.260
Jadi jika Anda tahu Anda mengambil string seperti tinggi dan kemudian lakukan kode Chaar di daripada char itu permisi

11:25.260 --> 11:27.770
kode char di dan berikan indeks.

11:28.140 --> 11:34.460
Ini memberi kita angka 104 yang merupakan kode karakter untuk H untuk huruf kecil H.

11:34.650 --> 11:42.460
Jika kita lakukan, ayo lakukan saja, itu salah satu dari lima H I J datang berikutnya dalam alfabet.

11:42.670 --> 11:43.600
Itu salah satu dari enam.

11:43.810 --> 11:46.900
Jadi ini ada dalam kisaran angka.

11:47.020 --> 11:55.030
Jadi apa yang bisa kita lakukan adalah mengganti ekspresi reguler kita dengan menggunakan perbandingan matematis sederhana sehingga kita

11:55.030 --> 12:04.420
akan melakukan karakter pada kode char-nya dan memberi Anda tahu katakan saja selalu nol untuk sekarang dan kemudian kita akan memeriksa

12:05.090 --> 12:08.380
apakah itu kode karakter yang valid .

12:08.480 --> 12:13.330
Dan saya menemukan seseorang yang melakukan ini secara online yang merupakan jenis inspirasi saya untuk melihatnya.

12:13.400 --> 12:19.370
Orang ini menulis sedikit tes kinerja di mana mereka menguji apakah ada sesuatu yang alfanumerik

12:19.490 --> 12:21.740
di sini menggunakan ekspresi reguler.

12:21.740 --> 12:27.140
Dan di sini mereka menguji apakah sesuatu alfanumerik menggunakan kode karakter sehingga Anda

12:27.140 --> 12:35.430
dapat melihat antara empat puluh tujuh dan lima puluh delapan adalah kode karakter numerik antara 64 dan 91 adalah huruf besar.

12:35.570 --> 12:41.270
Ya alfabet dan huruf kecil adalah 96 hingga 123.

12:41.270 --> 12:47.300
Jadi kita bisa dengan cepat membandingkan beberapa boolean yang sangat mudah dan cepat dilakukan dalam bahasa

12:47.300 --> 12:48.550
pemrograman apa pun.

12:48.620 --> 12:55.220
Mereka cukup banyak salah satu operasi paling sederhana yang paling sederhana yang dapat Anda lakukan adalah perbandingan

12:55.580 --> 13:01.310
boolean sederhana dan orang ini menunjukkan sebenarnya bahwa jika Anda mengulangi ini berulang

13:01.310 --> 13:10.170
kali Anda dapat melihat bahwa versi ekspresi tidak teratur memang lebih cepat lebih cepat Lima puluh lima persen lebih lambat menggunakan ekspresi reguler.

13:10.370 --> 13:15.290
Jadi saya menunjukkan ini kepada Anda untuk tidak mengatakan Anda tahu saya akan datang dengan ini dalam sebuah

13:15.290 --> 13:20.600
wawancara karena saya mungkin tidak akan saya mungkin mempertimbangkannya tapi saya pasti tidak akan tahu kode karakter dan saya akan

13:20.600 --> 13:23.540
pergi dengan dengan apa yang saya rasa paling nyaman dilakukan.

13:23.660 --> 13:29.060
Tapi kemudian saya pada akhirnya akan menambahkan sedikit catatan ke pewawancara saya mengatakan hei mungkin ada cara yang lebih baik

13:29.060 --> 13:30.300
saya akan google itu.

13:30.320 --> 13:31.590
Saya punya perasaan.

13:31.700 --> 13:34.080
Ekspresi reguler mungkin bukan cara tercepat.

13:34.340 --> 13:39.670
Jadi yang saya lakukan sebenarnya mengubah ini menjadi fungsi yang disebut alfanumerik.

13:39.770 --> 13:41.490
Tapi itu bekerja dalam satu karakter.

13:41.720 --> 13:48.620
Jadi Anda memasukkan karakter satu per satu dan kemudian kita mendapatkan kode karakter pada indeks 0 karena hanya

13:48.620 --> 13:50.870
itu karakter string satu karakter.

13:50.870 --> 13:53.150
Secara teknis Anda benar-benar dapat membiarkan ini kosong dan masih berfungsi.

13:53.150 --> 13:56.030
Tapi saya ingin eksplisit jadi saya akan meletakkan nol di sana.

13:56.030 --> 13:58.360
Ini hanya memberikan karakter pertama yang merupakan satu-satunya karakter.

13:58.460 --> 14:07.310
Jadi jika kita melewati halo seperti ini yang saya sebut alfanumerik di H sebut di e on.

14:07.340 --> 14:09.190
Dan itu harus kembali benar setiap saat.

14:09.440 --> 14:13.150
Dan kemudian jika kita memiliki spasi atau tanda seru itu akan kembali salah.

14:13.160 --> 14:14.950
Jadi saya telah membuat fungsi ini.

14:15.050 --> 14:23.480
Sekarang yang akan saya lakukan adalah menghilangkan ekspresi reguler ini dan mengubahnya menjadi jika itu

14:23.930 --> 14:27.240
adalah alfanumerik karakter seperti itu.

14:27.260 --> 14:31.610
Hal lain yang perlu dipertimbangkan adalah penempatan saat kita melakukan casing bawah.

14:32.060 --> 14:38.240
Apakah lebih baik huruf kecil semuanya di awal seluruh string dan kemudian memeriksa setiap karakter untuk melihat

14:38.240 --> 14:39.700
apakah itu alfanumerik.

14:39.710 --> 14:46.310
Apakah lebih baik untuk terlebih dahulu memeriksa karakter alfanumerik sehingga kami membuang semua spasi tanda baca.

14:46.310 --> 14:50.090
Segala sesuatu yang tidak valid dan kemudian huruf kecil sesudahnya.

14:50.300 --> 14:53.860
Dan saya sebenarnya tidak positif tentang bagaimana perasaan saya tentang hal itu.

14:53.870 --> 14:55.080
Saya sudah bolak-balik.

14:55.100 --> 15:00.890
Tergantung pada apa string Anda terlihat seperti apa input terlihat jika mereka umumnya semua alfanumerik versus

15:01.010 --> 15:06.530
jika Anda memiliki string benar-benar aneh yang memiliki satu ton karakter acak yang bukan alfanumerik.

15:06.530 --> 15:08.810
Saya pikir jawabannya tergantung pada itu.

15:09.080 --> 15:15.590
Tapi apa yang akan saya lakukan adalah menjalankannya seperti ini jadi jika itu alfanumerik maka kita akan

15:15.590 --> 15:17.900
menurunkannya dan menambahkannya ke objek kita.

15:17.900 --> 15:20.170
Jadi saya suka solusi ini.

15:20.180 --> 15:24.310
Saya suka memiliki fungsi terpisah ini sehingga ini cukup mudah dibaca menurut pendapat saya.

15:24.440 --> 15:31.040
Untuk setiap karakter di atau dari string kami seperti itu sangat bagus dan dapat dibaca untuk karakter di dalam string.

15:31.040 --> 15:37.550
Jika karakter itu alfanumerik, kita akan huruf kecil dan kemudian ditambahkan ke objek kita atau inisialisasi ke

15:37.550 --> 15:38.270
satu.

15:38.340 --> 15:40.680
Tambahkan satu ke nilai saat ini.

15:40.700 --> 15:41.840
Jadi saya suka solusi ini.

15:41.840 --> 15:48.190
Saya pikir itu bersih dan mudah dibaca tetapi juga diduga setidaknya menurut beberapa hal kami menemukan

15:48.190 --> 15:55.210
bahwa tambang lebih efisien untuk menggunakan kode karakter dibandingkan dengan ekspresi reguler seperti yang kami miliki di sini.

15:55.220 --> 15:59.120
Jadi saya tahu ini agak lama tapi saya hanya ingin menunjukkan kepada Anda proses saya.

15:59.180 --> 16:04.820
Ini adalah solusi yang saya tulis pertama dan kemudian saya agak lebih memikirkannya dan melakukan penelitian lebih lanjut

16:05.240 --> 16:06.400
dan ini solusinya.

16:06.410 --> 16:11.540
Saya lebih suka tidak hanya secara gaya bukan hanya karena lebih pendek itu sebenarnya tidak lebih pendek karena

16:11.540 --> 16:17.930
kode ini di sini tentu saja Anda bisa meletakkan semua kode ini di sini dan tidak memiliki fungsi yang terpisah tapi saya pikir

16:17.930 --> 16:19.950
ini jauh lebih baik seperti ini.

16:19.970 --> 16:20.240
Baiklah.

16:20.270 --> 16:21.800
Jadi mari kita pastikan itu berfungsi.

16:21.980 --> 16:23.380
Akun Char.

16:23.380 --> 16:23.710
Yakin.

16:23.720 --> 16:24.910
Yang ini lagi.

16:25.460 --> 16:26.390
Halo Dunia.

16:26.450 --> 16:26.870
Hai.

16:26.870 --> 16:31.690
Jadi harus ada dua huruf H di sana ada satu.

16:31.760 --> 16:32.150
Apa lagi.

16:32.150 --> 16:37.360
Tiga L dan kami mengabaikan huruf besar dan juga kami mengabaikan karakter non-alfanumerik.

16:37.370 --> 16:37.720
Baiklah.

16:37.760 --> 16:38.930
Jadi itu banyak di sana.

16:39.140 --> 16:40.440
Semoga Anda setuju.

16:40.460 --> 16:46.640
Mungkin Anda tidak memiliki umpan balik tentang refactor saya tetapi hanya bertanya kepada diri sendiri tentang bagaimana orang lain melakukan

16:46.640 --> 16:48.890
ini bagaimana saya bisa buktikan ini.

16:48.890 --> 16:54.170
Di mana perubahan gaya saya bisa membuat atau solusi terlihat sangat berbeda dari sebelumnya.

16:54.170 --> 16:56.600
Bukannya ada yang salah dengan ini di luar kotak.

16:56.860 --> 16:57.380
BAIK.
