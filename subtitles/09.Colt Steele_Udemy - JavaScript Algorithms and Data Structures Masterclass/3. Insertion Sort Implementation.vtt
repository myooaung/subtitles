WEBVTT

00:00.240 --> 00:00.810
Baiklah.

00:00.840 --> 00:03.270
Jadi mari kita terapkan jenis penyisipan.

00:03.570 --> 00:09.720
Jadi saya sudah siapkan snippet saya dan saya akan mendefinisikan fungsi kami yang disebut insertion sort membutuhkan sebuah array.

00:09.840 --> 00:11.440
Ini harusnya cukup akrab sekarang.

00:11.460 --> 00:17.030
Kembalikan array itu dan mari kita panggil ke sini dengan apa yang harus kita sebut dengan itu.

00:17.160 --> 00:19.830
Mari kita lanjutkan dengan 2 4.

00:20.040 --> 00:20.460
Oh tunggu.

00:20.460 --> 00:21.510
Saya sedang melakukan semacam array.

00:21.540 --> 00:22.810
Itu tidak akan berhasil.

00:22.900 --> 00:30.240
Dua koma satu sembilan dan tujuh puluh enam dan empat.

00:30.410 --> 00:30.830
BAIK.

00:30.870 --> 00:34.050
Bagian tersulit dari hari saya keluar dari jalan sekarang memilih angka-angka itu.

00:34.050 --> 00:35.880
Dan sebenarnya itu tidak benar.

00:35.880 --> 00:37.740
Semua ini sulit dijelaskan.

00:38.050 --> 00:38.290
BAIK.

00:38.310 --> 00:39.400
Jadi kita punya ini di sini.

00:39.600 --> 00:44.670
Dan hal pertama yang ingin kita lakukan adalah jika kita hanya memvisualisasikan apa yang kita

00:44.940 --> 00:50.240
lakukan saat kita melewati daripada memulai dengan elemen pertama karena itu bisa menjadi semacam kasus tepi.

00:50.430 --> 00:53.970
Katakanlah kita telah melewati beberapa pass dan RE kita diurutkan.

00:53.970 --> 00:55.570
Sampai titik ini.

00:55.650 --> 00:58.880
Jadi apa yang perlu kita lakukan misalnya.

00:59.130 --> 01:03.360
Nah apa yang kita lakukan kita ambil empat dan pada dasarnya kita bekerja mundur.

01:03.360 --> 01:09.300
Kami membandingkannya dengan 76 dan kami memeriksa mana yang lebih besar jika Empat lebih besar daripada tetap di tempatnya dan

01:09.300 --> 01:10.160
kami selesai.

01:10.380 --> 01:14.150
Tetapi jika empat kurang dari 76 maka apa yang kita lakukan.

01:14.170 --> 01:22.490
Apa yang bisa kita lakukan adalah naik ke atas ke 4 dan kemudian kita melihat ke bawah ke 9 di mana tidak

01:22.500 --> 01:23.280
ada kehilangan.

01:23.400 --> 01:25.720
Nah sembilan masih lebih besar jadi kami pindah sembilan.

01:25.860 --> 01:28.030
Sampai di mana 76 dulu.

01:28.200 --> 01:30.470
Dan kemudian kami memeriksa untuk merangkak lebih besar.

01:30.480 --> 01:32.690
Jadi kami menempatkan empat di sini.

01:32.800 --> 01:35.490
Jika itu masuk akal, kita berakhir dengan ini.

01:35.790 --> 01:41.820
Jadi alasan saya saya mulai dari sini adalah karena bagian mudah pertama adalah kami ingin mengulangi setiap

01:41.820 --> 01:42.260
item.

01:42.450 --> 01:42.800
Kanan.

01:42.800 --> 01:43.650
Itu sudah jelas.

01:43.650 --> 01:46.850
Semua algoritma pengurutan sejauh ini telah melibatkan bahwa kita mulai dengan satu loop.

01:46.920 --> 01:51.450
Kita mulai kira-kira di awal meskipun dalam kasus ini kita dapat benar-benar mulai mengulang pada indeks

01:51.870 --> 01:58.040
item pertama pertama daripada nol dan kemudian kita melihat ke belakang dan kita mencari tahu di mana harus memulai atau ke mana harus

01:58.100 --> 01:58.740
melakukan apa.

01:58.740 --> 02:03.390
Jadi mari kita tulis loop kita untuk sama dengan kita daripada nol.

02:03.630 --> 02:05.090
Itu tidak masalah jika kita melakukan nol.

02:05.100 --> 02:07.910
Ini hanya iterasi tambahan dan akan berjalan dengan baik.

02:07.930 --> 02:09.540
Itu kurang dari panjangnya.

02:09.810 --> 02:14.040
Tidak saya baca panjang lebar maksud saya tambahkan 1 ke saya.

02:14.700 --> 02:20.520
Ok jadi sekarang apa yang perlu kita lakukan adalah pertama mari kita membuat variabel untuk melacak nilai yang kita lihat.

02:20.520 --> 02:22.790
Jadi katakanlah kita melihat empat.

02:22.860 --> 02:28.050
Kita akan membuat variabel bernama Saya tidak tahu apa yang akan Anda panggil, mari kita lanjutkan

02:28.170 --> 02:30.740
dengan nilai sejauh ini sama dengan array.

02:30.760 --> 02:33.930
Aku suka itu.

02:33.960 --> 02:35.570
Sekarang kami hanya ingin bekerja mundur.

02:35.760 --> 02:36.780
Jadi ini sebabnya lebih mudah.

02:36.780 --> 02:41.310
Seperti saya katakan berpikir bahwa kita sedang menuju akhir atau tengah array daripada di

02:41.310 --> 02:44.640
awal karena tidak ada mundur pasti untuk bekerja menuju

02:44.760 --> 02:47.390
Jadi mari kita buat loop lain untuk mundur.

02:47.400 --> 02:52.240
Jadi untuk var J sama dengan di mana kita mulai.

02:52.410 --> 02:58.340
Yah kita ingin memulainya dengan kurang dari apa pun Ayas Jadi jika ini jika kita kembali ke contoh ini,

02:58.620 --> 03:00.100
inilah yang kita lihat.

03:00.270 --> 03:05.880
Jika saya ada di sini jadi itu 0 1 2 3 4 jika saya meminta kami ingin mulai membandingkan.

03:05.880 --> 03:11.200
Saya atau nomor ini ke nomor ini yang akan menjadi indeks minus 1.

03:11.310 --> 03:14.640
Jadi J sama dengan saya minus 1 untuk memulai.

03:15.090 --> 03:20.790
Dan kita akan membuat perbandingan yang belum kita lakukan dan terus berjalan sampai akhirnya kita menemukan tempat

03:20.790 --> 03:21.540
yang tepat.

03:21.540 --> 03:23.490
Kasus terburuk berapa kali.

03:23.490 --> 03:25.360
Misalnya kalau ini nol.

03:25.530 --> 03:27.150
Berapa kali kita harus turun.

03:27.150 --> 03:32.890
Kita perlu j menjadi 3 0 1 2 3 dan itu harus menjadi 1 saat dibutuhkan menjadi nol.

03:33.000 --> 03:34.690
Dan di situlah kita akan menempatkan 0.

03:34.740 --> 03:35.700
Indeks nol.

03:35.970 --> 03:42.390
Jadi untuk itu untuk bekerja kita ingin terus berjalan sementara J lebih besar dari nol adalah apa yang lebih besar dari negatif 1 adalah

03:42.390 --> 03:45.410
salah satu cara melakukannya lebih besar dari atau sama dengan nol.

03:45.420 --> 03:47.370
Saya selalu akan melakukan yang saya inginkan.

03:47.400 --> 03:51.140
Saya tidak tahu saya akan mengatakan saya memiliki preferensi tetapi saya tidak benar-benar melakukan J.

03:51.150 --> 03:54.380
Lebih besar dari ya itu lebih besar dari atau sama dengan nol.

03:54.570 --> 03:57.990
Jadi tidak apa-apa jika kita memiliki nol karena indeks Indeks menjadi nol.

03:57.990 --> 04:00.780
Atau Anda bisa melakukan lebih dari yang negatif mana saja.

04:00.780 --> 04:01.770
Baiklah.

04:01.770 --> 04:04.120
Jadi kita akan mengurangi satu dari J.

04:04.140 --> 04:06.230
Setiap saat.

04:06.300 --> 04:09.740
Jadi ini hanya kerangka ruffs loop kami jika Anda mau.

04:09.750 --> 04:10.700
Jadi kami memilih.

04:10.710 --> 04:17.990
Jika saya empat maka kita memiliki loop J ini yang pergi dari 3 ke 2 ke 1 ke nol dan kemudian berhenti.

04:18.000 --> 04:19.360
Jadi itu hanya loop dasar.

04:19.440 --> 04:22.440
Tapi kami tidak benar-benar ingin itu terus berulang tanpa alasan.

04:22.500 --> 04:28.470
Kita harus mulai mencari tahu ke mana nilai ini pergi atau jika kita melihat contoh ini di mana nol

04:28.470 --> 04:29.090
cocok

04:29.280 --> 04:31.230
Jadi apa yang kita lakukan, kita sudah punya NOL.

04:31.290 --> 04:35.130
Dalam kasus kami disimpan di bawah Val variabel saat ini.

04:35.190 --> 04:39.130
Jadi apa pun itu, kami menyimpan ramify di Kernville.

04:39.270 --> 04:40.470
Jadi kami memilikinya di samping.

04:40.470 --> 04:45.270
Simpan saja di sini nilai nol dan konsol saya tidak begitu senang tentang itu.

04:45.270 --> 04:51.070
Jadi yang terjadi sekarang adalah bahwa J akan mulai pada 76 dan bergerak mundur Will J sendiri bukan

04:51.150 --> 04:53.470
J-Stars pada 3 dan bergerak ke nol.

04:53.490 --> 04:59.420
Apa yang ingin kita lakukan sekarang adalah membandingkan nilai saat ini dengan array J.

04:59.890 --> 05:04.060
Jadi kita bisa menulis itu pada dasarnya seperti ini array J.

05:04.210 --> 05:06.140
Jika saya bisa mengetikkan array J.

05:06.310 --> 05:08.770
Dan kemudian kami ingin membandingkannya dengan baris saat ini.

05:09.090 --> 05:11.730
Apa yang ingin kita periksa adalah array dari J.

05:11.770 --> 05:13.690
Lebih besar dari nilai saat ini.

05:13.930 --> 05:17.330
Jadi jika demikian halnya jika 76 lebih besar dari 0.

05:17.680 --> 05:19.890
Kami ingin memindahkan nol ke bawah.

05:19.900 --> 05:23.490
Yang artinya adalah kita akan naik 76.

05:23.500 --> 05:26.430
Jadi jika saya tunjukkan operasi mana yang sebenarnya.

05:26.470 --> 05:26.670
BAIK.

05:26.680 --> 05:33.730
Jadi pertama kali melalui nol di sini kita membandingkan nilai saat ini dengan 76 76 lebih besar.

05:33.970 --> 05:36.190
Jadi kami benar-benar bergerak 76.

05:36.190 --> 05:38.470
Kami salin ke sini.

05:38.620 --> 05:43.480
Ingat kita sudah nol yang disimpan dalam suatu variabel sehingga kita tidak perlu melakukan seperti swap dengan

05:43.480 --> 05:46.980
variabel sementara kita sudah memiliki variabel sementara yang disebut nilai saat ini.

05:47.530 --> 05:54.690
Jadi kita kembali ke malam dan kita membandingkan 9 dan 0 9 lebih besar dari nol.

05:54.700 --> 05:58.840
Jadi kita akan mengambil sembilan dan menaruhnya di sana.

05:58.870 --> 06:00.580
Sekarang kita pindah ke dua.

06:00.830 --> 06:02.530
Dua lebih besar dari nol.

06:02.680 --> 06:07.930
Jadi kita akan memindahkannya ke J plus 1 kemudian kita sampai ke 1 yang masih lebih besar dari nol.

06:08.110 --> 06:13.740
Jadi kita memindahkannya ke sini dan kemudian di akhir jika loop kita selesai kita akan

06:13.750 --> 06:17.650
mengambil apa pun nilai ini dan menempelkannya di sana.

06:18.760 --> 06:20.850
Jadi ada cara yang lebih baik untuk menulis ini.

06:20.860 --> 06:25.420
Dan saya akan menunjukkan kepada Anda seperti apa rasanya sedikit membingungkan untuk melihat for for loop seperti ini tetapi ini adalah

06:25.420 --> 06:26.730
salah satu cara untuk melakukannya.

06:26.740 --> 06:30.550
Jadi loop kita berjalan sementara J lebih besar dari atau sama dengan nol.

06:31.180 --> 06:38.770
Dan array J lebih besar dari nilai saat ini, nilai saat ini.

06:39.260 --> 06:43.130
Jadi Anda mungkin belum melihat banyak untuk perjalanan seperti ini tetapi ini adalah salah satu cara potensial untuk melakukannya daripada

06:43.130 --> 06:43.480
kita.

06:43.500 --> 06:49.240
Kedua, Anda dapat melakukan loop sementara juga atau dalam segala jenis pemeriksaan bersyarat untuk keluar dari loop.

06:49.370 --> 06:53.510
Tapi yang terbaca begini Jay dimulai adalah saya minus 1.

06:53.690 --> 06:56.740
Kita akan terus berjalan sementara J lebih besar dari atau sama dengan nol.

06:56.970 --> 07:00.120
Dan array J lebih besar dari nilai saat ini.

07:00.170 --> 07:07.120
Jadi jika dan jika pada titik mana saja misalnya jika bukan 0 item terakhir ini adalah 20.

07:07.640 --> 07:12.860
Kita akan melalui sekali array J akan memberi kita 76 yang lebih besar sehingga kita terus mengulang dan kita

07:13.400 --> 07:15.100
ingin memindahkan 76 ke sini.

07:15.170 --> 07:19.240
Tapi kemudian kita membandingkan 20 hingga sembilan dan tiba-tiba ini tidak benar lagi.

07:19.280 --> 07:20.760
Jadi kita sudah selesai mengulang.

07:20.810 --> 07:23.330
Sekarang kita hanya menempatkan 20 di sini.

07:23.330 --> 07:28.130
Jadi saya agak bingung ketika kita ketika kita menulisnya dengan cara ini, tetapi biarkan

07:28.130 --> 07:35.180
saya mengisi sisanya jadi jika setiap saat kita melalui loop ini apa yang akan kita lakukan adalah mengambil nilai seperti ini dan

07:35.240 --> 07:37.060
bergerak maju dan bergerak maju.

07:37.070 --> 07:39.270
Dan kemudian kita berhenti di beberapa titik.

07:39.560 --> 07:49.260
Jadi untuk benar-benar memindahkan nilai itu ke depan, itu hanya array J ditambah satu sama dengan array J.

07:50.450 --> 07:57.680
Jadi mengapa saya tidak melakukan log itu saja untuk menunjukkan apa yang terjadi pada array log dan sebenarnya mari kita

07:58.040 --> 07:59.420
lakukan di sini.

07:59.600 --> 08:06.430
Jadi kami belum menyortir karena kami belum benar-benar mengganti nilai yang benar.

08:06.500 --> 08:09.970
Tetapi jika saya menjalankan ini OK, Anda dapat melihat apa yang terjadi.

08:10.070 --> 08:12.240
Jadi kami mulai dengan satu dan kami melihat kembali dua.

08:12.470 --> 08:14.870
Kita harus pergi ke sini, jadi kita maju dua.

08:14.900 --> 08:20.650
Jadi kita mendapatkan dua hingga 9 7 76 karena kita tidak pernah menambahkannya dalam satu.

08:20.940 --> 08:27.720
Jadi untuk memperbaiki ini setelah loop ini selesai itu berarti bahwa kami menemukan tempat yang tepat untuk tempat kami

08:27.720 --> 08:29.550
harus memasukkan Vau saat ini.

08:29.730 --> 08:34.630
Jadi di sini semua yang kita lakukan adalah memasukkan nilai saat ini dan itu bukan array dari J.

08:34.690 --> 08:40.010
Ini adalah array dari J plus 1 karena jika kita membahas ini lagi katakanlah kita mulai dari sini.

08:40.260 --> 08:43.070
Maka J akan mulai dari sini.

08:43.500 --> 08:45.360
Jadi kami memeriksa mana yang lebih besar.

08:45.360 --> 08:46.860
OK 76 lebih besar.

08:47.040 --> 08:49.260
Jadi ingatlah bahwa kita memiliki 20 simpanan dalam suatu variabel.

08:49.320 --> 08:52.010
Kita akan mengambil 76 dan memindahkannya ke sini.

08:52.200 --> 08:53.730
Tapi J ada di sini.

08:54.030 --> 08:58.430
Jadi waktu berikutnya melalui J bergerak ke sini dan kami membandingkan 20 dan sembilan.

08:58.470 --> 09:00.780
Nah 20 lebih besar dari sembilan.

09:01.050 --> 09:06.410
Jadi kita tidak akan bergerak maju 9 tetapi kita tidak ingin menukar kita tidak ingin menempatkan 20 di sini.

09:06.420 --> 09:09.480
Kami ingin menempatkan 20 di sini di ruang ini.

09:09.480 --> 09:12.330
Jadi J apakah ini yang kita inginkan J plus 1.

09:12.480 --> 09:18.510
Jadi array J ditambah satu sama dengan apa yang kita sebut nilai saat ini.

09:19.410 --> 09:21.380
Dan sekarang sebenarnya kita sudah selesai.

09:21.840 --> 09:29.720
Jadi jika kita melangkah sekarang, apa yang terjadi, biarkan saya jelas mengeksekusi.

09:30.020 --> 09:30.570
BAIK.

09:30.630 --> 09:36.390
Saya mencetak ketika kami memindahkan item ke depan yang agak membingungkan sehingga kami bergerak terlalu maju.

09:36.630 --> 09:44.740
Tetapi kemudian pada baris ini di sini kita memasukkan satu di awal dan berkata jangan membatalkan log di sini.

09:45.790 --> 09:46.230
BAIK.

09:46.310 --> 09:47.030
Jadi, di mana awal mulanya.

09:47.040 --> 09:48.270
Kita mulai.

09:48.360 --> 09:54.990
Jadi Anda dapat melihat kita melalui yang pertama kali dan kita meletakkan satu di mana ia pergi di depan keduanya kemudian kita melihat

09:54.990 --> 09:59.770
sembilan Yah itu pergi di mana ia kemudian kita melihat 76 yang pergi di mana itu.

09:59.940 --> 10:01.820
Tapi kemudian kita sampai empat.

10:02.100 --> 10:06.470
Kita perlu pindah ke sini dan kemudian kita disortir.

10:06.900 --> 10:08.670
Jadi yang ini sedikit berbeda.

10:08.940 --> 10:13.670
Saya tahu ini mungkin sedikit lebih sulit untuk memahami kode ini tetapi melangkah melaluinya.

10:13.680 --> 10:19.380
Jika Anda jika Anda terjebak saya sangat menyarankan Anda untuk hanya menuliskan apa yang saya dan J di setiap titik.

10:19.530 --> 10:20.770
Hanya satu per satu.

10:20.820 --> 10:21.450
Berjalan melalui.

10:21.450 --> 10:22.560
Mungkin butuh sedikit.

10:22.590 --> 10:23.880
Gunakan array yang lebih pendek.

10:24.150 --> 10:29.120
Jelas ketika Anda memilih angka untuk array itu membantu untuk memilih hal-hal yang masuk akal yang suka

10:29.310 --> 10:30.740
bekerja dengan algoritma Anda.

10:30.810 --> 10:35.190
Jika Anda hanya memilih sekelompok angka seperti dua dua dan dua di mana Anda memilih sesuatu yang

10:35.650 --> 10:37.210
sudah disortir itu tidak banyak membantu.

10:37.350 --> 10:39.180
Jadi perhatikan itu.

10:39.240 --> 10:42.480
Tapi jalani saja jika Anda butuh bantuan, cobalah memahami apa yang sedang terjadi.
