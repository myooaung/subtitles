WEBVTT

00:00.210 --> 00:01.620
Baiklah, selamat datang kembali.

00:01.620 --> 00:06.510
Jadi yang ingin saya lakukan sekarang adalah sangat cepat mengambil tiga algoritma yang telah

00:06.510 --> 00:08.800
kami pelajari sejauh ini dan membandingkannya.

00:09.090 --> 00:13.780
Jadi ini akan menjadi penyelesaian cepat tetapi pada dasarnya kami telah mengerjakan masing-masing algoritma secara terpisah.

00:13.800 --> 00:18.510
Kami telah berbicara tentang pro dan kontra tetapi kami belum benar-benar melihat bagaimana mereka

00:18.510 --> 00:22.920
semua membandingkan dan Anda dapat melihat bahwa mereka dikelompokkan bersama di bagian ini.

00:22.920 --> 00:28.920
Saya menyebutnya sebagai algoritma penyortiran dasar yang sering disebut algoritma penyortiran kuadrat karena Semuanya adalah kompleksitas waktu yang besar.

00:28.950 --> 00:30.510
Oh dan kuadrat.

00:30.510 --> 00:32.530
Ingat kami peduli dengan kasus terburuk.

00:32.670 --> 00:34.870
Itulah gunanya Pay-Go.

00:35.100 --> 00:39.610
Tapi kami juga memecahnya menjadi pencarian rata-rata dan CEO dan cocok untuk mereka semua.

00:39.690 --> 00:43.260
Tetapi jika kita melihat kompleksitas waktu, ada sedikit perbedaan.

00:43.410 --> 00:47.070
Jadi, inilah bubble sort dan ini dengan data yang hampir diurutkan.

00:47.100 --> 00:48.570
Jadi itulah kasus terbaik.

00:48.570 --> 00:54.510
Jika data kami benar-benar diurutkan, pengurutan gelembung berfungsi dengan sangat baik karena telah melewati dan harus

00:54.510 --> 00:56.070
melakukan sedikit pertukaran.

00:56.070 --> 01:01.370
Kami beralih lagi dan kami melakukan satu pemeriksaan lagi dan semuanya diurutkan dan selesai.

01:02.600 --> 01:06.730
Dan hanya itu yang semacam gelembung berkinerja sangat baik dalam situasi itu.

01:06.730 --> 01:08.770
Hal yang sama dengan jenis penyisipan.

01:08.770 --> 01:13.090
Jika kita bekerja dengan data yang hampir diurutkan, kita menempatkan sesuatu di tempat yang benar.

01:13.180 --> 01:17.130
Tapi kemudian Anda melihat saat kita pergi, kita tidak benar-benar harus melakukan apa pun.

01:17.130 --> 01:22.120
Kami hanya memeriksa setiap item ke item sebelumnya dan kami tidak perlu melakukan swap.

01:22.270 --> 01:26.730
Jadi pada dasarnya kita beralih melalui loop sekali melakukan satu perbandingan untuk setiap item.

01:26.770 --> 01:31.070
Jika data benar-benar diurutkan maka dalam kasus ini hampir diurutkan.

01:31.120 --> 01:37.280
Jadi itu jenis penyisipan berfungsi dengan baik dalam jenis pemilihan situasi namun tidak berjalan dengan baik.

01:37.280 --> 01:39.780
Jika Anda melihat apa yang terjadi di sini, data hampir diurutkan.

01:39.850 --> 01:45.010
Kami masih akan melalui setiap kali untuk menemukan item terendah sehingga kami mengulangi semua jalan melalui

01:45.010 --> 01:50.080
dan itu terjadi pada set pertama dan kemudian kami melakukannya lagi dan kami mencari item

01:50.080 --> 01:50.770
minimum terkecil.

01:50.890 --> 01:54.060
Tidak masalah bahwa itu sudah hampir diurutkan.

01:54.070 --> 01:59.740
Jadi pemilihan semacam tidak berkinerja baik dalam situasi ini, tetapi pemilihan jenis sangat sederhana untuk

01:59.770 --> 02:02.940
memahami yang cukup banyak itu hanya positif.

02:03.340 --> 02:08.890
Jadi kembali ke situs web algoritma pengurutan animasi ini jika kita melihat hampir diurutkan sehingga ada banyak

02:08.890 --> 02:10.860
algoritma yang belum kita bicarakan.

02:10.990 --> 02:13.650
Tapi kita akan belajar tentang beberapa dari ini semacam penggabungan yang muncul.

02:13.810 --> 02:19.450
Tetapi jika kita klik fokus hampir diurutkan tentang bagaimana pemilihan penyisipan dan gelembung melakukan Anda akan melihat penyisipan dan

02:19.480 --> 02:21.220
gelembung selesai dengan sangat cepat.

02:21.220 --> 02:27.860
Seleksi membutuhkan selamanya tetapi tetap penyisipan dan gelembung yang umumnya lebih lambat daripada algoritma ini yang

02:27.940 --> 02:29.020
lebih maju.

02:29.200 --> 02:31.740
Mereka masih berkinerja lebih baik pada hampir semua jenis data.

02:31.910 --> 02:32.360
BAIK.

02:32.480 --> 02:34.770
Jadi itulah kompleksitas waktu.

02:34.810 --> 02:39.880
Pada dasarnya mereka semua sudah berakhir dan dikuadratkan kecuali dengan semacam gelembung data dan penyisipan dilakukan

02:39.880 --> 02:41.140
dengan baik sekarang.

02:41.140 --> 02:42.420
Kompleksitas ruang.

02:42.460 --> 02:48.370
Mereka sebenarnya semua sama juga dan itu karena kita tidak benar-benar menggunakan banyak ruang dengan algoritma

02:48.370 --> 02:49.020
ini.

02:49.100 --> 02:50.470
Semuanya terjadi di tempat.

02:50.470 --> 02:53.160
Kami sebenarnya tidak membuat array baru.

02:53.170 --> 02:55.410
Tidak peduli berapa lama arraynya.

02:55.420 --> 03:00.490
Kami tidak membuat variabel untuk setiap elemen atau dua variabel untuk setiap elemen atau sesuatu seperti itu.

03:00.730 --> 03:05.980
Tetapi apa yang akan Anda lihat nanti pada beberapa algoritma lain yang lebih cepat apa yang mereka

03:05.980 --> 03:11.320
lakukan adalah bahwa mereka benar-benar membuat sekelompok array yang lebih kecil misalnya menggabungkan semacam yang akan dipelajari

03:11.320 --> 03:17.290
selanjutnya di awal bagian berikutnya itu kompleksitas ruang bukan 0 1 itu tidak konstan tetapi untuk ini mereka semua pada

03:17.290 --> 03:18.600
dasarnya sama persis.

03:18.610 --> 03:20.880
Satu hal tentang penyisipan yang istimewa.

03:20.980 --> 03:26.670
Yang saya sebutkan adalah bahwa ia bekerja dengan sangat baik jika Anda membutuhkan data Anda untuk terus diurutkan.

03:26.670 --> 03:31.470
Jadi elemen baru sedang ditambahkan ke itu bukan hal satu kali di mana Anda memiliki semua data yang siap.

03:31.600 --> 03:36.170
Jika kita menggunakan jenis penyisipan dan saya menambahkan nomor yang saya tidak tahu.

03:36.240 --> 03:42.550
39 misalnya penyisipan hanya perlu melakukan dasarnya satu pass untuk mencari tahu di mana harus meletakkan itu

03:43.090 --> 03:47.460
versus jika kita melakukan pemilihan semacam itu akan resor seluruh hal.

03:47.590 --> 03:50.370
Itu tidak bisa mencari tahu persis di mana ia pergi segera.

03:50.500 --> 03:56.560
Jadi jenis penyisipan berfungsi dengan baik dalam situasi tersebut jika Anda memiliki data yang masuk dan Anda perlu untuk menggunakan

03:56.560 --> 04:00.690
hal-hal berulang-ulang dan mempertahankan jenis berjalan menjaga hal-hal tetap up to date.

04:00.890 --> 04:01.500
BAIK.

04:01.750 --> 04:04.540
Jadi hanya ingin rekap apa yang kita bahas.

04:04.540 --> 04:08.770
Penyortiran sangat penting itu adalah hal mendasar dalam pemrograman.

04:08.770 --> 04:10.900
Ini juga sangat umum dalam wawancara.

04:10.900 --> 04:16.240
Kami akan berbicara lebih banyak tentang apa yang sebenarnya perlu Anda ketahui jika Anda melakukan wawancara dan Anda khawatir

04:16.240 --> 04:17.100
tentang penyortiran.

04:17.140 --> 04:21.520
Anda tidak perlu hanya duduk di sini dan mengingat implementasi dari semua algoritma ini.

04:21.520 --> 04:23.340
Kami akan berbicara lebih banyak tentang apa yang perlu Anda ketahui.

04:23.440 --> 04:28.690
Jadi pemilihan jenis gelembung dan jenis penyisipan semuanya kira-kira setara dalam skema besar hal

04:29.320 --> 04:34.660
terutama ketika kita membandingkannya dengan kumpulan algoritma berikutnya yang akan kita pelajari di bagian berikutnya.

04:34.680 --> 04:38.950
Ada beberapa perbedaan kecil antara ketiganya tetapi mereka menjadi tidak signifikan ketika

04:38.950 --> 04:41.450
kita melihat seberapa cepat beberapa algoritma ini.

04:41.860 --> 04:46.310
Jadi mereka akan memiliki kompleksitas waktu rata-rata yang kuadratik yang bisa kita lakukan dengan lebih baik.

04:46.540 --> 04:47.940
Dan itulah yang akan terjadi selanjutnya.

04:47.980 --> 04:49.730
Kami membutuhkan algoritma yang lebih kompleks.

04:49.840 --> 04:51.660
Mereka agak sulit dijelaskan.

04:51.670 --> 04:53.240
Mereka kurang.

04:53.580 --> 04:54.770
Saya tidak mengatakan sedikit manusia.

04:54.820 --> 04:56.680
Mereka kurang mereka kurang intuitif.

04:56.680 --> 04:58.000
Langsung dari kelelawar.

04:58.000 --> 05:02.920
Jadi ini sedikit lebih banyak pekerjaan tetapi algoritma ini sangat layak untuk diketahui dan juga apa yang akan kita

05:02.920 --> 05:04.960
lihat di video berikutnya dan bagian selanjutnya.

05:04.990 --> 05:09.730
Algoritma ini sebenarnya dapat bekerja lebih baik pada set data yang sangat kecil.

05:09.730 --> 05:11.090
Jadi kita akan lihat mengapa begitu.

05:11.140 --> 05:13.530
Jadi ini bukan buang-buang waktu untuk belajar.

05:13.660 --> 05:18.580
Jika Anda merasa jika Anda khawatir tentang itu dan Anda berpikir oh dia hanya menunjukkan yang bodoh dulu

05:18.590 --> 05:20.590
dan kita bisa mendapatkan Hardman sesudahnya.

05:20.590 --> 05:25.000
Itu hanya sebagian benar karena ini benar-benar unggul ketika set data kecil.

05:25.000 --> 05:25.320
Baiklah.

05:25.330 --> 05:29.440
Jadi di bagian selanjutnya kita akan mulai belajar tentang beberapa algoritma yang lebih menakutkan ini.

05:29.440 --> 05:30.490
Kami akan mengambil waktu kita.

05:30.580 --> 05:33.590
Jadi mudah-mudahan itu tidak terlalu buruk dan kita akan mulai dengan semacam penggabungan.
