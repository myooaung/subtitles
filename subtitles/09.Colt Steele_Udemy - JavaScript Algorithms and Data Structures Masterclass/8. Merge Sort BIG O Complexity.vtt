WEBVTT

00:00.320 --> 00:01.550
Baiklah, selamat datang kembali.

00:01.560 --> 00:06.420
Saya hanya ingin cepat berbicara tentang Big O waktu dan kompleksitas ruang untuk semacam penggabungan.

00:06.570 --> 00:11.070
Jadi kami agak tidak menyebutkannya meskipun saya tunjukkan pada Anda di intro

00:11.070 --> 00:16.990
pertama untuk menggabungkan video sortir seberapa cepat lebih cepat setidaknya secara anekdot dibandingkan dengan sesuatu seperti bubble sort.

00:17.220 --> 00:22.530
Tapi kasus terbaik kasus rata-rata dan kasus terburuk untuk jenis gabungan semuanya sama.

00:22.620 --> 00:29.130
Oh dari dan masuk dan jadi tidak seperti sesuatu seperti semacam gelembung tidak berhasil OK itu cukup baik saya bahkan tidak akan

00:29.130 --> 00:31.170
mengatakan OK itu tidak cukup buruk.

00:31.170 --> 00:36.960
Ini kuadrat dan waktu kuadrat dalam Haruskah data dalam kasus terbaik sudah diurutkan dalam

00:36.960 --> 00:42.050
hal ini meningkatkan waktu linier dari semacam penggabungan tidak memiliki seperti itu.

00:42.570 --> 00:43.280
Saya tidak ingin mengatakan ini.

00:43.310 --> 00:45.890
Tidak ada tepi kasus seperti itu dan semacam penggabungan.

00:45.940 --> 00:47.470
Tidak peduli seperti apa data itu.

00:47.470 --> 00:51.910
Itu tidak memiliki dampak itu akan membaginya berulang-ulang dan menggabungkan hal-hal

00:51.910 --> 00:54.150
berulang-ulang tidak peduli apa inputnya.

00:54.160 --> 00:58.750
Jika sudah diurutkan atau dibalik atau benar-benar acak Tidak masalah.

00:58.750 --> 01:00.250
Jadi itulah poin pertama.

01:00.250 --> 01:05.010
Sekarang yang kedua adalah mengapa log akhir dan dari mana asalnya.

01:05.020 --> 01:10.000
Dan tentunya saya tidak akan mengharapkan Anda hanya untuk mengetahui hal itu atau bahkan harus dapat

01:10.000 --> 01:10.690
menghitungnya segera.

01:10.870 --> 01:12.920
Tapi inilah gambaran dasar.

01:13.420 --> 01:18.270
Jadi jika kita memiliki ini jika kita mulai dengan array delapan elemen.

01:18.490 --> 01:21.840
Jadi ini terlihat pada akhir proses menggabungkan mereka.

01:21.850 --> 01:25.600
Tapi kita katakan saja kita mulai di sini dan bergerak ke atas.

01:25.630 --> 01:28.650
Jadi kita harus membaginya menjadi dua bagian.

01:28.960 --> 01:30.780
Jadi itu satu dekomposisi.

01:31.000 --> 01:34.170
Lalu kami membaginya lagi dan itu adalah dekomposisi lain.

01:34.170 --> 01:38.470
Dan lagi sampai kita mendapatkan item yang panjangnya 1 atau array atau satu item.

01:38.710 --> 01:40.450
Jadi apa hubungannya di sini.

01:40.450 --> 01:43.120
Jika kita memiliki delapan item dalam array dan delapan.

01:43.240 --> 01:47.700
Berapa kali kita harus membelah untuk mendapatkan array elemen tunggal.

01:47.770 --> 01:49.420
Dalam hal ini tiga.

01:49.720 --> 01:53.600
Tetapi jika sebaliknya kami memiliki array 32 item.

01:53.840 --> 01:58.140
Saya tidak akan, saya tidak akan mengetik semuanya tetapi bayangkan bahwa saya hanya menulis panjang di sini.

01:58.150 --> 02:00.790
Jadi kami memiliki array 32 item.

02:00.790 --> 02:06.910
Kita dapat melakukan split yang hanya memberikan satu array 16 dan 16 lainnya dan kemudian kita bisa membaginya lagi yang

02:07.000 --> 02:11.500
akan terjadi kita akan mendapatkan array 8 8 8 8 jadi 4 8 item.

02:11.800 --> 02:13.340
Dan kemudian kita membaginya lagi.

02:13.540 --> 02:15.060
Dan apa yang kita dapat.

02:15.060 --> 02:20.630
Kami mendapatkan 8 4 item perlombaan dan kemudian kami terus berjalan.

02:20.770 --> 02:23.740
Dan saya tidak akan menghitung ini dengan tepat.

02:23.740 --> 02:25.030
Itu tidak masalah.

02:25.030 --> 02:27.160
Pokoknya lupakan saja angkanya ini.

02:27.160 --> 02:30.670
Intinya meskipun akhirnya kita akan berakhir dengan 32.

02:30.700 --> 02:31.810
Satu item kenaikan gaji.

02:31.810 --> 02:35.310
Sekarang berapa banyak perpecahan yang harus kita lakukan untuk sampai ke sana.

02:35.320 --> 02:35.950
Saya tidak menghitung.

02:35.950 --> 02:39.030
Tolong jangan minta saya bertanggung jawab di sini.

02:39.100 --> 02:39.930
Berapa banyak perpecahan.

02:40.000 --> 02:43.690
Nah inilah yang pertama membagi yang kedua yang ketiga keempat yang kelima.

02:43.780 --> 02:47.250
Begitu tinggi dan tumbuh hingga 32.

02:47.260 --> 02:50.230
Kami memiliki lima split ketika N berusia delapan.

02:50.320 --> 02:51.600
Kami memiliki tiga perpecahan.

02:51.700 --> 02:53.110
Hubungan apa itu.

02:53.230 --> 02:58.810
Baik kembali ke O. besar S. log itu dan sekarang ingat kita berbicara tentang basis 2.

02:58.810 --> 03:00.330
Jadi log basis 2 dari.

03:00.340 --> 03:04.770
Dan apa yang sebenarnya berarti adalah dua dari apa yang diberikan kekuasaan kepada kita.

03:05.860 --> 03:13.260
Jadi dalam kasus kami jika kami memiliki delapan elemen, kami mengambil dua dan menaikkannya tiga kali satu hingga tiga untuk mendapatkan delapan, atau

03:13.720 --> 03:20.260
jika kami memiliki 32 elemen yang berarti dua kali dua kali dua kali dua kali dua hingga dua hingga lima

03:20.500 --> 03:22.440
kekuatan akan memberi kita 32.

03:22.600 --> 03:28.570
Jadi dari sanalah log end berasal dan menumbuhkan panjang array ini berapa kali

03:28.570 --> 03:32.500
kita harus membaginya tumbuh pada kecepatan log n.

03:32.620 --> 03:35.370
Sekarang bagaimana dengan N log dan di mana itu ikut bermain?

03:35.440 --> 03:43.510
Yah setiap kali kita menguraikannya, kita memiliki dan perbandingan ketika kita melakukan penggabungan.

03:43.510 --> 03:47.260
Jadi misalnya, mari kita lihat baris ini di sini.

03:47.350 --> 03:52.660
Ini sedang dalam perjalanan kembali ke penggabungan menuju yang terakhir. Ini adalah langkah terakhir penggabungan.

03:52.660 --> 03:56.950
Selalu ada delapan item untuk membandingkannya membandingkan setiap waktu sampai benar.

03:57.040 --> 04:01.130
Kami tidak menambahkan atau menghapus item pada titik mana pun kami hanya membaginya dan memindahkannya.

04:01.180 --> 04:03.230
Tapi selalu ada delapan hal total.

04:03.250 --> 04:09.220
Jadi di sini kita akan mulai dan membandingkan satu dan tiga dengan satu perbandingan dan kemudian salah satu dari mereka dipilih

04:09.220 --> 04:09.920
yaitu 1.

04:10.060 --> 04:15.370
Jadi kita lanjutkan dan kita membandingkan dua dan tiga dan kemudian kita membandingkan tiga

04:15.370 --> 04:21.580
dan enam dan kemudian empat dan enam pada akhir hari kita memiliki 0 dan perbandingan pada masing-masing.

04:21.580 --> 04:28.150
Jadi seiring panjangnya akhir tumbuh algoritma penggabungan itu sendiri bukan jenis gabungan, hanya gabungan yang memiliki

04:28.150 --> 04:29.570
kompleksitas waktu Ovett.

04:29.710 --> 04:33.850
Jadi jika kita memiliki seribu item dalam array, ada sekitar seribu perbandingan yang perlu

04:34.150 --> 04:36.610
dibuat jika kita memiliki delapan item dalam array.

04:36.650 --> 04:39.490
Ada sekitar delapan perbandingan yang perlu dibuat untuk bergabung.

04:39.550 --> 04:42.530
Jadi total kita berakhir dengan analog lagi.

04:42.670 --> 04:47.470
Jadi o dari semua lagi adalah jumlah dekomposisi dan tumbuh.

04:47.470 --> 04:53.370
Ada beberapa kali perpecahan dan jumlah kali tetapi array tumbuh pada tingkat akhir

04:53.370 --> 04:53.940
Flugge.

04:54.040 --> 04:59.590
Tetapi kemudian setiap kali kita melakukan split setiap dekomposisi kita memiliki live dan perbandingan untuk benar-benar melakukan

04:59.590 --> 05:00.260
penggabungan.

05:00.280 --> 05:03.540
Jadi total kita berakhir dengan 0 dari akhir log.

05:03.730 --> 05:09.850
Jadi jika kita melihat grafik di sini dan masuk bisa melihat jalannya lebih baik daripada sesuatu seperti 0 waktu

05:09.850 --> 05:10.740
kuadrat kuadrat.

05:10.760 --> 05:16.750
Ini tidak sebagus pertandingan Dan tentu saja atau waktu linier dan tapi ini sebenarnya yang

05:16.750 --> 05:24.200
terbaik yang bisa kita dapatkan untuk algoritma pengurutan kecuali algoritma itu sendiri mengambil keuntungan dari beberapa kekhasan aneh dalam data.

05:24.490 --> 05:30.670
Jadi ada algoritma yang akan melihat yang disebut radix sort yang menggunakan kekhasan angka tertentu dan tidak akan

05:30.670 --> 05:32.420
berfungsi untuk mengurutkan hal lain.

05:32.620 --> 05:39.070
Tetapi jika kita menginginkan algoritma pengurutan data agnostik, yang terbaik yang bisa kita lakukan adalah 0 dan log in beberapa jenis gabungan

05:39.070 --> 05:40.160
bekerja dengan baik.

05:40.420 --> 05:44.000
Selalu berakhir dan masuk ke waktu terburuk dan rata-rata terbaik.

05:44.050 --> 05:46.200
Dan akhirnya kompleksitas ruang.

05:46.210 --> 05:51.420
Jadi ini sedikit berbeda dibandingkan dengan hal-hal seperti bubble sort yang memiliki kompleksitas ruang konstan.

05:51.520 --> 05:58.960
Ketika kita berbicara tentang menggabungkan semacam karena kita memiliki array yang lebih besar kita harus menyimpan lebih banyak balapan di memori kita dan bukan

05:58.960 --> 05:59.980
di memori kita.

06:00.080 --> 06:01.330
Kita harus menggunakan lebih banyak ruang.

06:01.420 --> 06:02.860
Jadi itu adalah tradeoff.

06:02.860 --> 06:09.940
Sekarang biasanya kita peduli tentang kompleksitas waktu tetapi jika ruang menjadi pertimbangan maka sesuatu seperti penggabungan memakan

06:09.940 --> 06:15.070
lebih banyak ruang dibandingkan dengan jenis gelembung atau jenis sebelumnya lainnya.

06:15.170 --> 06:15.550
BAIK.

06:15.580 --> 06:18.450
Jadi itu adalah O besar dari jenis gabungan.

06:18.460 --> 06:21.530
Selanjutnya kita bersenang-senang memilah-milah mereka.

06:21.580 --> 06:22.020
Sampai jumpa.
