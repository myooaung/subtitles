WEBVTT

00:00.210 --> 00:00.480
Baiklah.

00:00.480 --> 00:01.180
Selamat datang kembali.

00:01.290 --> 00:05.870
Jadi dalam video ini kita akan melanjutkan dan mengimplementasikan algoritma pencarian string naif.

00:06.120 --> 00:12.800
Jadi saya sudah membuat cuplikan yang melakukan ini di mana pun Anda lebih suka menyublimkan beberapa editor teks sendiri

00:12.810 --> 00:13.990
Itu tidak masalah.

00:14.010 --> 00:18.950
Jadi saya punya satu yang disebut Cari string naif dan saya akan menutupnya untuk saat ini.

00:18.960 --> 00:23.490
Pertama mari kita mendefinisikan fungsi sehingga perlu menerima dua string.

00:23.490 --> 00:32.550
Saya akan menyebutnya pencarian naif dan menerima string panjang dan string pendek atau pola panjang.

00:32.550 --> 00:34.950
Saya juga melihat pola seperti itu.

00:35.100 --> 00:36.390
Saya suka pendek.

00:37.050 --> 00:43.710
Dan kemudian hal pertama yang akan dilakukan adalah hanya melakukan contoh panggilan di sini pencarian

00:43.710 --> 00:49.180
begitu naif dan katakanlah misalnya bahwa kita akan menyebutnya dengan cetakan Loree

00:49.320 --> 00:50.090
Halo Elde.

00:50.130 --> 00:54.890
Sebagai kata kerja dan kami sedang mencari EHLO dengan baik di string itu.

00:55.280 --> 00:55.780
BAIK.

00:55.950 --> 01:00.360
Jadi pertama-tama kita perlu membuat beberapa loop karena kode pseudo ini menyebutkan loop di atas string yang

01:00.360 --> 01:04.190
lebih panjang dan kemudian bersarang di dalam loop di atas string yang lebih pendek.

01:04.560 --> 01:07.200
Jadi mari kita mulai dengan loop paling dasar di atas string panjang.

01:07.200 --> 01:16.780
Jadi untuk var saya sama dengan nol sementara saya kurang dari panjang saya plus plus.

01:16.890 --> 01:19.220
Jadi itu harus memberi kita setiap mata.

01:19.270 --> 01:23.720
Kami hanya melihatnya dan mengeksekusi ini membuat Konsul sedikit lebih besar.

01:23.720 --> 01:24.860
Ayo.

01:25.020 --> 01:25.270
Baiklah.

01:25.290 --> 01:29.660
Jadi kita mendapatkan nol hingga 10 ada 10 atau 11 karakter di sana.

01:29.810 --> 01:35.930
Kalau begitu mari kita lakukan hal yang sama untuk J atau surat apa pun yang Anda suka.

01:35.940 --> 01:38.470
Tapi J adalah yang standar.

01:38.490 --> 01:39.010
Iya nih.

01:39.110 --> 01:43.000
Ya ok untuk var J sama dengan nol.

01:43.140 --> 01:52.200
J Kali ini kurang dari panjang pendek J plus plus itu akan sedikit membingungkan ketika Anda mulai bekerja dengan i

01:52.200 --> 01:55.020
dan j melacak yang mana.

01:55.020 --> 01:59.400
Jadi jika kita baru saja mencetak saya koma J setiap kali lewat.

01:59.400 --> 02:00.760
Itu akan menjadi angka.

02:00.810 --> 02:07.040
Jadi kenapa tidak kita lakukan saja, mari kita lakukan lama-lama.

02:07.050 --> 02:09.990
Dan kekurangan J.

02:10.620 --> 02:12.330
Sekarang kita akan mendapatkan banyak cetakan.

02:12.360 --> 02:16.390
Ini adalah loop bersarang jadi kami mengulang 10 kali di sini.

02:16.650 --> 02:22.230
Tapi masing-masing dari 10 kali kita mengulang tiga kali untuk sumur L-A.

02:22.230 --> 02:28.970
Jadi jika saya menghapus ini saya akan membuat ini lebih besar dan coba lagi.

02:28.980 --> 02:29.340
Baiklah.

02:29.340 --> 02:36.170
Jadi Anda dapat melihat apa yang kami dapatkan di sini pada dasarnya kami mulai dengan L pada keduanya keluar dan keluar.

02:36.570 --> 02:38.110
Dan kemudian Eneloop pergi ke 0.

02:38.130 --> 02:46.440
Jadi kita memiliki L dan O dan kemudian l lagi dan kemudian kita pindah ke 0 dan kita mulai dari atas

02:46.620 --> 02:48.730
OK jadi apa yang sebenarnya ingin kita lakukan.

02:48.780 --> 02:50.640
Daripada hanya mencetaknya.

02:50.640 --> 02:52.430
Ya, hal pertama yang bisa kita lakukan.

02:52.590 --> 02:55.470
Mari kita lupakan fakta bahwa i dan j adalah angka.

02:55.470 --> 02:57.780
Dan katakan saja ada surat-suratnya persis.

02:57.780 --> 02:59.310
Agak lebih mudah untuk dibicarakan.

02:59.400 --> 03:05.330
Jadi katakanlah saya mulai L dan J juga mulai sebagai l.

03:05.820 --> 03:12.120
Jadi ingat bahwa saya adalah loop luarnya sehingga saya akan tetap L saat kita maju melalui EHLO Nah

03:12.120 --> 03:17.080
jika itu masuk akal ketika J bertambah sebanyak tiga kali lipat dan kemudian reset.

03:17.250 --> 03:22.500
Agar mata meningkat setelah kita memulai loop adalah l j adalah l.

03:22.650 --> 03:24.270
Kami membandingkan mereka terlihat bagus.

03:24.300 --> 03:30.460
Setiap kali tidak ada kecocokan, kami keluar dari lingkaran dalam ini dan kami beralih ke iterasi berikutnya.

03:30.570 --> 03:34.170
Tapi mari kita fokus saja dalam hal ini ada kecocokan.

03:34.170 --> 03:36.190
ELEANOR HALL Jadi apa yang kita lakukan selanjutnya.

03:36.360 --> 03:41.710
Yah perbandingan selanjutnya masih akan menjadi L tetapi itu akan dibandingkan dengan 0.

03:41.940 --> 03:50.660
Karena pada dasarnya kita bergerak, J bergerak dan itu menjadi O karena kita mengulanginya terlebih dahulu.

03:50.730 --> 03:51.630
Tapi itu tidak akan berhasil.

03:51.630 --> 03:54.960
Untuk secara langsung membandingkan 0 dan L karena kami tahu itu bukan kecocokan.

03:54.960 --> 03:59.080
Jadi yang ingin kita bandingkan adalah satu lebih dari satu.

03:59.220 --> 04:06.000
Jadi ketika kita bergerak melalui J Kita ingin juga melihat ke depan di I meskipun saya akan terjebak pada nol

04:06.030 --> 04:11.750
jika itu masuk akal ketika kita melihat melalui ini sebagai pola singkat kita semua terus loop.

04:11.970 --> 04:14.030
Kami masih membandingkan setiap kali keluar.

04:14.370 --> 04:18.210
Jadi alih-alih kami ingin melihat ke depan dan cara terbaik untuk melakukan itu atau setidaknya

04:18.210 --> 04:21.680
satu cara yang akan saya lakukan adalah dengan menambahkan I ke J.

04:21.690 --> 04:23.020
Agak membingungkan.

04:23.220 --> 04:26.900
Tetapi sekarang jika kita kembali ke angka dan kita katakan keduanya dimulai dari nol.

04:27.290 --> 04:27.580
BAIK.

04:27.600 --> 04:29.040
Jadi ada kecocokan.

04:29.040 --> 04:32.360
Sekarang J naik ke 1.

04:32.400 --> 04:38.490
Jadi kita akan membandingkan Elo dari yang 0 ke string ini.

04:38.690 --> 04:41.810
Emas tetapi bukannya nol kita akan menambahkannya bersama.

04:41.970 --> 04:46.100
Jadi di mana kami sebelumnya ditambah di mana kami sekarang di J.

04:46.170 --> 04:51.850
Yang berarti bahwa kita akan melihat ke depan ke 0 karena itu akan menjadi indeks 1.

04:51.970 --> 04:55.750
Jadi itu pertandingan berikutnya melalui indeks kanan string pendek kami.

04:55.950 --> 05:03.970
Jadi kita akan membandingkan L ini dan kita akan menambahkan 0 plus 2 untuk memberi kita indeks dua dari string ini.

05:03.990 --> 05:05.870
Ke depan dan itu bukan pertandingan.

05:05.910 --> 05:07.020
Jadi kita keluar.

05:07.140 --> 05:09.210
Itu artinya kita mulai lagi sama sekali.

05:09.690 --> 05:16.160
Tapi kemudian setelah kita naik ke sini yang mana adalah indeks 0 1 2 3 4 5 indeks 6.

05:16.170 --> 05:22.920
Jadi dalam skenario di mana kita di sini indeks enam di indeks string besar 0 di string

05:23.480 --> 05:24.690
pendek ada kecocokan.

05:24.690 --> 05:25.470
Kanan.

05:25.530 --> 05:26.420
Itu adalah pertandingan.

05:26.580 --> 05:27.840
Jadi kita lanjutkan.

05:27.840 --> 05:30.150
Dan string pendek J naik 1.

05:30.220 --> 05:34.980
Sekarang menjadi 1 tetapi kami tidak ingin membandingkan tingkat indeks 6 yang lebih rendah.

05:34.980 --> 05:35.800
Kami ingin.

05:35.960 --> 05:38.740
Indeks 7 lama dan kami menambahkannya bersama-sama.

05:38.820 --> 05:43.830
Jadi mudah-mudahan Anda dapat melihat pendekatan yang kami lihat ke depan dan untuk melakukannya.

05:43.850 --> 05:45.200
Itu tidak terlalu buruk.

05:45.570 --> 05:51.880
Yang kami lakukan adalah menambahkan I dan J bersama-sama dan mengakses menggunakan indeks baru itu mengakses string panjang.

05:52.200 --> 05:55.390
Jadi inilah pendekatan saya semacam penipu. tentang logging.

05:55.500 --> 06:07.310
Kami pada dasarnya hanya akan memeriksa apakah string pendek J tidak sama dengan string panjang I Plus J.

06:07.320 --> 06:09.450
Sekarang jika itu terjadi dan kami akan keluar.

06:09.450 --> 06:11.490
Jadi mari kita buat ini menjadi satu lingkaran.

06:11.700 --> 06:15.140
Maksud saya kondisional seperti ini.

06:15.140 --> 06:20.420
Ini berarti keluar dari loop pendek ini dan mulai dari J lagi nol.

06:20.850 --> 06:24.490
Jadi kapan saja tidak ada pertandingan, kita akan istirahat.

06:24.630 --> 06:30.880
Jadi jika saya menambahkan log konstan ini di sana sekarang saya mencetak J pendek dan panjang saya Plus J.

06:30.890 --> 06:35.820
Saya akan membersihkan seperti ini dan mari kita lihat apa yang kita dapatkan.

06:36.360 --> 06:37.240
BAIK.

06:37.680 --> 06:43.010
Jadi perbandingan kita mulai dengan L dan L itu masuk akal.

06:43.110 --> 06:43.920
Ada kecocokan.

06:43.920 --> 06:51.060
Jadi kami tidak keluar dan kami beralih ke 0 dan kami membandingkan 0 dengan karakter berikutnya yaitu 0 dan kemudian ada

06:51.120 --> 06:51.660
kecocokan.

06:51.660 --> 06:57.820
Jadi kami pindah lagi ke L dan membandingkannya dengan kami dalam hal tidak ada kecocokan.

06:57.840 --> 07:05.780
Jadi jika saya menambahkan di konsol yang masuk ke sini untuk mengatakan break dan jalankan kembali ini Anda bisa melihat apa yang terjadi.

07:06.420 --> 07:08.900
Jadi sepertinya ada kecocokan L dan L O N O.

07:08.910 --> 07:10.050
Dan kemudian tidak ada kecocokan.

07:10.110 --> 07:15.260
Jadi kita istirahat dan ketika kita istirahat apa yang terjadi di sana adalah bahwa J sedang diatur ulang.

07:15.270 --> 07:22.290
Lingkaran dalam ini akan kembali ke nol yang berarti kita mulai anggun tetapi lingkaran luar saya bergerak.

07:22.290 --> 07:25.050
Jadi sekarang kita mulai di sini pada 0.

07:25.110 --> 07:27.780
Jadi setelah istirahat itu kita lakukan L dan O.

07:27.780 --> 07:29.550
Dan itu bukan pertandingan yang harus dipecahkan.

07:29.550 --> 07:31.310
Jadi kita maju lagi.

07:31.470 --> 07:34.770
Kali ini kita berbicara tentang R dan L dan itu bukan kecocokan.

07:34.770 --> 07:40.620
Jadi kita istirahat kita terus berjalan sampai akhirnya kita sampai di sini dan ada kecocokan.

07:40.620 --> 07:44.040
Jadi kita beralih dan ada pertandingan lain dan pertandingan lainnya.

07:44.070 --> 07:46.220
Tapi apa yang tidak kita miliki sekarang.

07:46.470 --> 07:50.990
Kami sebenarnya tidak menambah penghitung apa pun saat kami menemukan empat kecocokan.

07:51.300 --> 07:52.890
Jadi kami menemukan kecocokan penuh di sini.

07:52.900 --> 07:57.480
Elo Yah mereka semua adalah dua pasang atau tiga pasangan yang cocok dengan benar.

07:57.480 --> 08:00.600
Jadi yang perlu kita lakukan adalah membuat variabel muncul.

08:00.900 --> 08:01.560
Sebut saja.

08:01.560 --> 08:04.450
Hitung sama dengan nol.

08:04.920 --> 08:06.840
Dan kapan kita harus menambah jumlah.

08:07.110 --> 08:12.400
Nah cara kita tahu bahwa kita telah berhasil melewati string ini.

08:12.630 --> 08:17.070
Karena jika kita sampai ke karakter terakhir dan ada kecocokan jika kita

08:17.070 --> 08:22.680
berhasil sampai ke titik itu berarti J akan menjadi apa pun karakter terakhir dalam string pendek itu.

08:22.980 --> 08:27.800
Jika itu masuk akal, maka jika kami memberi tahu ELO Ltd, kami tahu bahwa kami selesai.

08:27.960 --> 08:34.930
Jika J adalah 0 1 2 3 4 jika J adalah untuk atau dalam hal ini jika J adalah 2.

08:35.220 --> 08:36.630
Jika kita berhasil sampai ke titik itu.

08:36.960 --> 08:44.190
Jadi kita bisa menambahkan cek bersyarat hanya untuk jika dan kemudian kita hanya memeriksa apakah J sama dengan

08:44.190 --> 08:49.530
panjang string pendek tetapi minus satu karena panjangnya akan lebih besar dari indeks.

08:49.680 --> 08:55.020
Jika itu masalahnya mari kita tambahkan satu untuk dilakukan ditambah dua plus plus seperti itu.

08:55.680 --> 09:01.090
Dan kemudian pada akhirnya mari kembali menghitung mari kita lihat berapa banyak kawat gigi yang saya miliki.

09:01.190 --> 09:02.720
Jadi itulah loop loop kondisional.

09:02.770 --> 09:03.710
Baiklah, kita mulai.

09:05.850 --> 09:08.120
OK jadi mari kita lihat apa yang terjadi sekarang.

09:08.520 --> 09:12.220
Jadi mengapa saya tidak menambahkan log di sini.

09:13.380 --> 09:19.110
Menemukan satu yang jelas Konsul saya jalankan kembali semuanya dimulai lagi.

09:20.340 --> 09:20.990
BAIK.

09:21.490 --> 09:26.090
Jadi, jika Anda melihat kami memiliki hal yang persis sama hampir cocok tetapi tidak ada istirahat.

09:26.170 --> 09:27.040
Teruskan.

09:27.250 --> 09:30.150
Tapi kemudian kami menemukan kecocokan.

09:30.430 --> 09:31.790
Dan kode ini sedang dicetak.

09:32.050 --> 09:33.840
Jadi hitungannya naik 1.

09:34.030 --> 09:39.100
Jadi, jika Anda mendapatkan ini jika itu berfungsi untuk Anda atau jika ia memiliki solusi yang sedikit berbeda tetapi Anda

09:39.100 --> 09:39.790
tetap bekerja

09:40.000 --> 09:40.750
Itu yang terpenting.

09:40.750 --> 09:44.130
Jika Anda memiliki dua loop dan Anda membuatnya berfungsi, logika Anda bisa sedikit berbeda.

09:44.170 --> 09:46.250
Anda bisa bekerja dari ujung misalnya.

09:46.480 --> 09:49.050
Anda tidak harus bekerja dari awal ke depan atau Anda bisa bekerja mundur.

09:49.240 --> 09:50.740
Itu tidak masalah.

09:50.920 --> 09:52.560
Tetapi jika Anda memilikinya bekerja dengan baik.

09:52.720 --> 09:57.880
Jika mau, Anda bisa bertahan dan kami bisa berjalan sekali lagi hanya untuk melihat

09:57.880 --> 09:58.720
cara kerjanya.

09:58.750 --> 10:04.660
Saya akan mempersingkat ini karena seperti beberapa solusi lain kita dapat menempatkan ini pada

10:04.900 --> 10:08.560
satu baris membuatnya sedikit lebih bagus seperti itu.

10:08.620 --> 10:17.800
Hal yang sama dengan kedua kita jika kita mengatur di sini begitu saja dan masih berfungsi

10:17.800 --> 10:23.330
harus tetap bekerja setidaknya mendapatkan hasil cetak kembali konsul.

10:23.430 --> 10:24.930
Ya, kami mendapatkan satu.

10:24.930 --> 10:25.990
Keren.

10:26.010 --> 10:26.390
Baiklah.

10:26.400 --> 10:31.140
Jadi, jika Anda ingin bertahan untuk langkah-langkah ekstra Mari kita coba sekali lagi atau sesuatu yang berbeda.

10:31.140 --> 10:36.390
Mari kita coba dengan LO yang dalam hal ini kita harus mendapatkan dua pertandingan.

10:36.390 --> 10:37.560
Apakah itu berhasil?

10:38.070 --> 10:39.520
Ya, kami mendapat dua.

10:39.990 --> 10:40.670
Baiklah.

10:40.860 --> 10:41.880
Jadi apa yang terjadi di sini.

10:42.030 --> 10:44.950
Yah kita mengulangi setiap karakter misalnya.

10:44.970 --> 10:45.900
Jadi di situlah kita mulai.

10:46.080 --> 10:48.670
Dan pada string kedua kita melihat melalui setiap karakter.

10:48.780 --> 10:57.030
Jadi kami mulai dengan baik dan segera kami memeriksa apakah karakter ini tidak cocok dengan I Plus J dari karakter ini sehingga saya

10:57.040 --> 10:58.480
dan J keduanya nol.

10:58.710 --> 11:02.560
Jadi ini berarti untuk memeriksa karakter pertama bersama-sama 0 0 0.

11:02.880 --> 11:06.380
Jadi jika mereka tidak cocok segera pecah dan itu berarti bahwa kita pindah.

11:06.570 --> 11:08.260
Dan mata itu sekarang ada di sini.

11:09.450 --> 11:14.030
Jadi, jika mereka benar-benar cocok dengan apa yang mereka kebetulan cocok dengan apa yang kita lakukan.

11:14.250 --> 11:18.490
Yah karena kita masih dalam lingkaran ini, kita melanjutkan.

11:18.600 --> 11:22.460
Jay sekarang menunjuk ini tetapi saya masih mendengar.

11:22.680 --> 11:24.970
Jadi sekarang kita tambahkan keduanya.

11:25.050 --> 11:27.110
Jay sekarang masih nol.

11:27.120 --> 11:34.380
Jadi itu memberi kita total satu dan kita membandingkan ini dengan itu dan ada kecocokan di mana

11:34.830 --> 11:39.500
kita menambah hitungan karena J sama dengan panjang string pendek.

11:39.600 --> 11:45.020
Begitulah cara kita tahu kita berada pada iterasi J terakhir dan kasus ini akan sama dengan 1 0 1.

11:45.150 --> 11:50.090
Ketika kita sampai ke 1 dan kita belum pecah jika kita sampai pada titik ini berarti kita menemukan kecocokan.

11:50.310 --> 11:50.510
Baiklah.

11:50.520 --> 11:53.940
Jadi kemudian diulang lagi sampai menemukan kecocokan ini.

11:53.970 --> 11:55.250
Jadi semoga itu jelas.

11:55.440 --> 12:02.230
Dan jika kita mencobanya dengan sesuatu yang tidak ada di sana seperti pop kita seharusnya mendapatkan nol.

12:02.550 --> 12:03.300
Dan kami melakukannya.

12:03.630 --> 12:06.750
Jadi kami tidak perlu menghitung apa pun karena kami memiliki variabel jumlah ini.

12:06.810 --> 12:11.430
Ini tidak seperti pencarian biner misalnya di mana kami harus menangani kesalahan bukan kesalahan tetapi kami harus

12:11.430 --> 12:12.870
menangani kasus tepi tersebut.

12:12.870 --> 12:15.230
Jika kita tidak menemukan apa-apa, hitung euro.

12:15.600 --> 12:16.190
Baiklah.

12:16.320 --> 12:19.980
Jadi itu adalah implementasi pencarian string naif.

12:19.990 --> 12:25.530
Selanjutnya kita akan melihat implementasi yang lebih baik dari berbagai jenis algoritma pencarian string.

12:25.620 --> 12:29.330
Jelas sedikit lebih rumit dan lebih lama tetapi menyenangkan untuk dibicarakan.

12:29.340 --> 12:29.700
Kupikir.
