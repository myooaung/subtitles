WEBVTT

00:00.180 --> 00:00.720
Baiklah.

00:00.720 --> 00:05.740
Jadi mari kita lihat contoh yang lebih konkret mari kita bandingkan dua solusi untuk masalah yang sama.

00:06.390 --> 00:07.350
Baiklah, jadi inilah masalah kita.

00:07.350 --> 00:12.930
Misalkan Anda ingin menulis fungsi yang menghitung jumlah semua angka dari satu hingga dan termasuk

00:12.930 --> 00:21.300
beberapa angka dan jadi jika kita pasang 3 kita harus mendapatkan satu tambah dua tambah tiga yang memiliki enam yang paling umum adalah

00:21.420 --> 00:23.670
yang paling mudah dibuat larutan.

00:23.700 --> 00:30.510
Ini adalah salah satu yang pertama kali terlintas di pikiran saya adalah pada dasarnya membuat akumulator variabel total dan

00:30.540 --> 00:34.870
mengulang semua angka-angka itu dan menambahkannya satu per satu mulai dari 1.

00:34.890 --> 00:36.090
Semua jalan sampai sekarang.

00:36.300 --> 00:37.660
Jadi itulah yang saya lakukan di sini.

00:37.690 --> 00:42.620
Anda memiliki variabel for for loop dimulai dari nol dan pada akhirnya kami mengembalikan total.

00:42.750 --> 00:51.550
Kita memulai loop pada 1 kita naik sampai N setiap kali melalui total plus sama dengan yang saya miliki.

00:51.580 --> 00:52.270
Itu dia.

00:52.320 --> 00:54.100
Saya buka di sini sebagai cuplikan.

00:54.180 --> 00:59.280
Jika Anda tidak terbiasa dengan snippet pada dasarnya ini adalah cara bagi saya untuk tidak menyalin dan

00:59.280 --> 01:03.020
menempelkan kode ke konsol dan harus berurusan dengan kehilangan dan jalankan kembali.

01:03.030 --> 01:09.210
Dan rasa sakit di Chrome Anda dapat pergi ke tab sumber dan kemudian ada tab snippet Anda dapat mengklik

01:09.210 --> 01:14.160
dan memungkinkan Anda untuk membuat snippet baru dari beberapa di sini dan saya akan menggunakannya

01:14.160 --> 01:18.860
dalam kursus ini cukup sering sebagai cara mudah untuk menyimpan kode dan menjalankannya.

01:18.960 --> 01:22.590
Dan hanya untuk menunjukkan kepada Anda bagaimana cara kerjanya, inilah fungsi yang sama.

01:23.130 --> 01:27.570
Dan saya mencetaknya di bagian bawah hasil menambahkan hingga 6.

01:27.570 --> 01:32.940
Jadi itu harus enam ditambah lima ditambah empat ditambah tiga ditambah dua ditambah satu untuk melaksanakannya.

01:32.940 --> 01:38.900
Saya dapat mengklik di sini atau Anda dapat melihat pintasan yang disarankan untuk saya di Mac adalah perintah enter.

01:39.090 --> 01:41.010
Ini akan mengatakan pintasan yang benar pada PC.

01:41.010 --> 01:42.610
Saya pikir itu pusat kendali.

01:43.050 --> 01:45.940
Jadi jika saya melakukannya sekarang saya mendapatkan 21.

01:46.110 --> 01:48.250
Saya melakukannya dengan tiga jam yang lalu.

01:48.360 --> 01:49.030
Saya mendapat enam.

01:49.050 --> 01:53.040
Jika saya melakukannya dengan 100 ratus, saya mendapatkan 50 50.

01:53.220 --> 01:53.420
BAIK.

01:53.430 --> 01:55.840
Jadi itu hanya untuk menunjukkan bahwa itu berhasil.

01:55.920 --> 01:58.140
Selanjutnya ada solusi kedua.

01:58.380 --> 02:02.640
Ada lebih dari dua tetapi ini adalah dua yang akan saya gunakan karena mereka menggambarkan maksud saya.

02:02.640 --> 02:05.570
Yang ini jelas kurang intuitif.

02:05.670 --> 02:10.620
Seperti yang Anda lihat, ini jauh lebih pendek. Ini adalah satu baris yang tidak selalu membuatnya lebih baik tetapi

02:10.620 --> 02:11.250
sangat berbeda.

02:11.250 --> 02:12.490
Tidak ada loop yang terlibat.

02:12.720 --> 02:16.000
Apa yang kami lakukan adalah lebih dari rumus matematika.

02:16.320 --> 02:21.330
Kami mengambil N dan kami mengalikannya dengan n ditambah 1 dibagi 2.

02:21.600 --> 02:24.080
Dan dari mana ini berasal, saya tidak akan pergi ke.

02:24.080 --> 02:30.270
Saya punya slide di sana atau slide yang berbicara tentang bagaimana kita sampai dengan formula ini jika Anda

02:30.270 --> 02:32.480
ingin memeriksanya Anda bisa tetapi tidak.

02:32.700 --> 02:37.980
Ini bukan fokus dari video ini jadi saya tidak ingin mengalihkan perhatian dari

02:38.340 --> 02:43.690
fokus sebenarnya yang mengevaluasi dan membandingkan potongan-potongan kode ini tidak benar-benar menyelami bagaimana kita menulisnya.

02:43.710 --> 02:45.380
Jadi hanya untuk menunjukkan yang ini tidak bekerja.

02:45.480 --> 02:47.090
Saya punya cuplikan lain di sini.

02:47.310 --> 02:48.390
Saya bisa menjalankan hal yang sama.

02:48.390 --> 02:51.200
Mari kita lakukan dengan enam lagi dan saya akan melakukannya.

02:51.210 --> 02:54.230
Perintah masuk untuk mengeksekusi dan saya mendapatkan 21.

02:54.480 --> 02:56.060
Dan hanya untuk berjalan melalui apa yang terjadi di sana.

02:56.150 --> 03:01.710
Jadi sama dengan mengambil enam ditambah satu pertama yang akan memberi kita tujuh dan kemudian kita kalikan

03:01.710 --> 03:07.070
dengan enam yang memberi kita 42 dan kemudian kita bagi dengan 2 yang memberi kita 21.

03:07.140 --> 03:10.200
Jadi itu berhasil memberi kita jawaban yang sama pada akhirnya.

03:10.200 --> 03:11.690
Lagi-lagi cara kerjanya.

03:11.730 --> 03:12.970
Kami akan meninggalkan itu.

03:13.200 --> 03:13.500
Baiklah.

03:13.500 --> 03:15.620
Jadi kami menetapkan ada dua solusi yang berfungsi.

03:15.780 --> 03:17.460
Mana yang lebih baik.

03:17.460 --> 03:21.540
Dan tentu saja hal pertama yang bisa kita tanyakan adalah Apa yang sebenarnya lebih baik artinya.

03:21.540 --> 03:28.920
Apakah ini berarti kode yang lebih cepat dalam hitungan detik atau milidetik, apakah itu berarti kode yang tercepat ketika kita

03:29.010 --> 03:31.480
menambahkan angka kecil versus angka besar.

03:31.800 --> 03:36.370
Katakanlah kita ingin membandingkannya ketika kita menjumlahkan semua angka trans euro dan 1 miliar.

03:36.390 --> 03:41.100
Apakah itu tes yang bagus atau tentang berapa banyak memori yang digunakan.

03:41.100 --> 03:46.290
Apakah Anda tahu jumlah variabel yang dibuat bahwa data yang disimpan setiap

03:46.460 --> 03:48.690
kali fungsi itu disebut.

03:48.870 --> 03:51.390
Atau bagaimana dengan sesuatu seperti keterbacaan keterbacaan.

03:51.390 --> 03:52.440
Seberapa penting itu.

03:52.440 --> 03:57.670
Apakah itu lebih baik atau singkatnya yang tidak ada di sini tetapi banyak orang peduli tentang itu.

03:57.690 --> 04:02.550
Mereka suka meminimalkan panjang jumlah karakter yang digunakan dalam pemrograman mereka.

04:02.670 --> 04:05.650
Bukan gaya saya secara pribadi tetapi pasti valid.

04:05.670 --> 04:10.040
Semua ini adalah kekhawatiran yang valid dan benar-benar mengarah pada situasi.

04:10.350 --> 04:16.320
Tetapi saya pikir kebanyakan orang akan setuju bahwa dua yang pertama terutama untuk sekarang kita akan

04:16.320 --> 04:23.010
fokus pada kecepatan akan kembali ke penggunaan memori sedikit tetapi ini terlalu sering bisa lebih penting daripada sesuatu seperti keterbacaan.

04:23.400 --> 04:27.840
Dan sayangnya mereka sering datang dengan mengorbankan keterbacaan dan itu semacam tindakan menyeimbangkan

04:27.840 --> 04:33.780
penulisan kode yang baik adalah menulis kode efisien yang tidak menghabiskan Anda tahu banyak memori tetapi juga masih

04:33.780 --> 04:37.050
dapat dibaca dan tidak terlihat seperti lengkap omong kosong.

04:37.050 --> 04:41.510
Jadi kita akan berbicara tentang semua ini pada dasarnya bermain bersama sepanjang seluruh kursus.

04:41.520 --> 04:48.270
Ini akan menjadi tema yang berulang tetapi kita akan fokus pada evaluasi kecepatan berapa lama kode yang diperlukan untuk menjalankan target

04:48.690 --> 04:49.390
untuk memulai.

04:49.400 --> 04:50.410
Jadi bagaimana kita melakukannya.

04:50.640 --> 04:56.610
Yah cara paling sederhana adalah dengan menggunakan sesuatu seperti built in fungsi timing sesuatu seperti ini

04:57.420 --> 05:04.470
di mana kita menambahkan pertama kita dan kemudian saya menggunakan fungsi yang disebut metode yang disebut kinerja sekarang yang

05:04.470 --> 05:09.630
di browser hanya akan memberi tahu saya jumlah milidetik sejak dokumen itu dibuat.

05:09.630 --> 05:13.430
Pada dasarnya karena mereka membuka jendela dan kemudian saya akan menyimpannya ke variabel.

05:13.440 --> 05:18.840
Sebelum saya menelepon menambahkan hingga kemudian saya akan menelepon menambahkan dengan apa yang saya lakukan.

05:18.840 --> 05:19.980
Ini satu miliar.

05:19.980 --> 05:21.050
Saya pikir ini satu miliar.

05:21.120 --> 05:22.830
Jadi saya akan menelepon dengan jumlah besar.

05:23.130 --> 05:26.580
Dan setelah itu selesai saya akan memeriksa kinerja.

05:26.590 --> 05:31.470
Sekarang lagi yang seharusnya meningkatkan sekelompok milidetik yang paling mungkin.

05:31.500 --> 05:32.710
Jadi saya punya dua angka.

05:32.820 --> 05:39.450
Lalu saya kurangi saja dulu atau yang kedua dikurangi pertama kali dan saya bagi 1000 karena itu

05:39.480 --> 05:40.360
dalam milidetik.

05:40.380 --> 05:41.860
Dan saya ingin bekerja dalam hitungan detik.

05:42.030 --> 05:43.420
Kita tidak harus melakukan bagian terakhir itu.

05:43.530 --> 05:44.570
Dan saya mencetak.

05:44.850 --> 05:45.740
Jadi ini seharusnya berhasil.

05:45.780 --> 05:48.310
Dan saya sebenarnya punya cuplikan di sini.

05:48.420 --> 05:49.330
Hal yang sama.

05:49.470 --> 05:52.690
Jadi tambahkan ke yang sama dari sebelumnya.

05:52.920 --> 05:57.400
Dan kami menyebutnya dengan 1 miliar dan kami akan mencetak berapa lama berlalu.

05:57.400 --> 05:59.680
Biarkan saya membersihkan konsol saya terlebih dahulu dan saya akan pergi.

05:59.680 --> 06:00.780
Dieksekusi

06:01.940 --> 06:06.410
Di sana kita pergi satu titik ke 5 7 5 jadi satu detik.

06:06.600 --> 06:07.610
Biarkan saya melakukannya sekali lagi.

06:09.160 --> 06:12.120
Apa yang sebenarnya Anda lihat saya pikir dieksekusi.

06:12.120 --> 06:12.780
Itu dia.

06:12.930 --> 06:13.860
Apakah itu bervariasi.

06:13.890 --> 06:16.650
Jadi itu berubah bahkan di komputer saya sendiri.

06:16.710 --> 06:19.080
Tidak ada yang benar-benar berubah.

06:19.290 --> 06:22.850
Saya belum menambahkan kode. Saya belum mengubah angka di sini.

06:23.040 --> 06:27.030
Ini kode yang sama persis tetapi kami mendapatkan output yang berbeda.

06:27.030 --> 06:27.590
Sebelum saya lupa.

06:27.600 --> 06:30.430
Mari kita beralih ke solusi kedua.

06:30.930 --> 06:35.390
Jadi angka yang persis sama izinkan saya memastikan saya tidak meninggalkan atau menambahkan adalah nol

06:35.430 --> 06:39.200
Ya mereka sama dan saya melakukan hal yang sama mengambil kinerja.

06:39.210 --> 06:42.450
Sekarang awal dan kinerja mulai sekarang di akhir.

06:42.570 --> 06:44.710
Anda mengatakan harus menunjukkan seperti apa itu.

06:44.790 --> 06:50.880
Anda dapat melihat sejumlah besar pada saat ini karena saya sudah membuka ini selama beberapa menit

06:50.880 --> 06:54.330
jika saya me-refresh halaman meskipun saya baru saja melakukannya.

06:54.360 --> 06:58.030
Sekarang berada pada 2000 milidetik yaitu dua detik.

06:58.200 --> 07:01.680
Sekarang jika saya melakukannya lagi kita berada di enam koma enam detik.

07:01.920 --> 07:05.620
Dan jika kita kurangi keduanya, kamu tahu empat detik di antaranya.

07:05.620 --> 07:07.900
Lagi pula kami melakukan hal yang sama di sini.

07:08.220 --> 07:08.720
BAIK.

07:08.880 --> 07:16.890
Jadi sekarang jika saya menjalankan ini, Anda dapat melihat kami mendapatkan jumlah yang jauh lebih kecil tetapi masih sebenarnya saya kira itu

07:16.890 --> 07:19.160
tidak terlihat seperti berubah di sini.

07:19.370 --> 07:23.420
Kemudian pengukuran perbedaannya terlalu kecil untuk ditangkap.

07:23.490 --> 07:27.580
Tapi poin saya adalah bahwa durasinya jauh lebih pendek.

07:27.580 --> 07:30.590
Namun data yang sama dengan yang ini.

07:30.590 --> 07:36.000
Di sini kita pergi pada satu titik dua empat detik dibandingkan dengan pada dasarnya nol detik.

07:36.000 --> 07:39.260
Jadi sepertinya itu pertanda baik untuk solusi ini.

07:39.270 --> 07:42.310
Sepertinya itu jauh lebih efisien dan itu hebat.

07:42.480 --> 07:50.490
Tetapi proses ini bukan yang paling dapat diandalkan untuk menentukan waktu hal-hal seperti ini sebelum dan sesudah dan membandingkannya dengan fungsi

07:50.490 --> 07:53.990
lain dan tidak mudah bagi kita untuk membicarakannya.

07:54.000 --> 07:59.130
Bagaimana saya benar-benar menuliskan bagaimana saya akan memberikan label seberapa efisien yang satu ini dibandingkan dengan yang

07:59.130 --> 07:59.830
satu ini.

07:59.840 --> 08:03.460
Apakah ini didasarkan pada persentase kecepatan.

08:03.650 --> 08:09.210
Apakah itu saya kurangi jumlah detik atau milidetik itu menjadi sedikit buram.

08:09.210 --> 08:17.430
Ini membawa kita ke masalah dengan waktu yang saya sisakan untuk masalah judul memoar akhir hidup saya dengan

08:17.430 --> 08:18.290
waktu.

08:18.570 --> 08:21.990
Hanya saja, suara kecil yang bagus sangat dalam.

08:22.140 --> 08:24.770
Jadi yang pertama adalah bahwa mesin yang berbeda akan merekam waktu yang berbeda.

08:24.780 --> 08:30.900
Jadi itu tidak dapat diandalkan tergantung pada spesifikasi pada seberapa banyak mesin dan apa yang saat ini

08:30.900 --> 08:36.480
terjadi pada mesin itu kode apa yang berjalan saat hasil yang Anda dapatkan akan berbeda.

08:36.540 --> 08:42.090
Itu tidak benar-benar berarti bahwa kita akan mendapatkan hasil yang berlawanan di mana solusi pertama tiba-tiba lebih cepat

08:42.090 --> 08:43.090
daripada yang kedua.

08:43.170 --> 08:48.240
Tetapi itu berarti bahwa margin dapat mengubah pengukuran aktual bisa berbeda dan hampir

08:48.240 --> 08:49.820
pasti akan berbeda waktu.

08:50.370 --> 08:53.760
Dan seperti yang kita lihat mesin yang sama ini akan merekam waktu yang berbeda.

08:53.760 --> 08:56.230
Jadi di browser saya, saya hanya melakukan kode yang sama persis.

08:56.310 --> 09:02.490
Contoh pertama itu dan itu berbeda setiap kali dengan sedikit yang tidak benar-benar masalah tetapi masih menunjukkan bahwa itu

09:02.490 --> 09:05.720
tidak tepat dan bahwa kita tidak dapat mengandalkan itu.

09:05.820 --> 09:10.650
Dan yang kedua atau ketiga dari semua saya kira adalah untuk algoritma cepat

09:10.710 --> 09:15.590
hal-hal yang terjadi pada pengukuran kecepatan skala sangat sangat cepat mungkin tidak cukup tepat.

09:15.600 --> 09:18.750
Kami memiliki dua atau tiga atau empat algoritma dan semuanya sangat cepat.

09:18.790 --> 09:20.330
Mereka melakukan sesuatu dengan sangat cepat.

09:20.340 --> 09:23.220
Masih ada satu yang akan menjadi tercepat atau paling efisien.

09:23.310 --> 09:29.580
Tetapi jika fungsi waktu kita tidak dapat mengetahuinya karena mereka tahu interval waktu terkecil yang

09:29.880 --> 09:34.530
dapat diukur tidak cukup baik maka itu tidak benar-benar membantu kita.

09:34.530 --> 09:40.260
Jadi, bagaimana kita menelusuri kode kita dan benar-benar berbicara secara umum tentang kode mana yang lebih baik tanpa harus

09:40.320 --> 09:41.530
pergi dan menghitung waktu.

09:41.550 --> 09:44.840
Jadi saya ingin menjadi jelas. Saya tidak mengatakan bahwa waktu kode Anda adalah ide yang buruk.

09:44.850 --> 09:52.140
Saya melakukannya sepanjang waktu tetapi saya lebih mengatakan bahwa itu akan keren jika ada cara lain yang tidak melibatkan harus

09:52.140 --> 09:56.650
mengatur file baru dan benar-benar pergi melalui proses pengaturan waktu kode kita.

09:56.670 --> 10:02.340
Bagaimana jika kode kami memberi tahu Anda satu jam sesuatu yang besar dan saya membandingkannya dengan versi lain yang

10:02.340 --> 10:03.560
membutuhkan waktu empat jam.

10:03.600 --> 10:06.690
Saya tidak ingin harus menjalankan tes untuk mencari tahu mana yang lebih cepat.

10:06.720 --> 10:09.450
Kami ingin dapat memberikan nilai.

10:09.570 --> 10:14.710
Secara umum berbicara tentang bagaimana kode dibandingkan dengan kode lain tanpa harus melalui semua ini.

10:14.760 --> 10:18.040
Dan di situlah notasi Big-O masuk dan selanjutnya muncul.

10:18.180 --> 10:19.000
Cliffhanger, maaf.
