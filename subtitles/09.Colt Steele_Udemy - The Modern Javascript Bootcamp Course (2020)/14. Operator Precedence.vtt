WEBVTT
1
00:00:00.300 --> 00:00:02.370
All right I've got a question for you.

2
00:00:02.400 --> 00:00:10.530
I have a simple expression I'm combining or hand and equality greater than I have a variable called

3
00:00:10.560 --> 00:00:10.950
X.

4
00:00:10.950 --> 00:00:12.280
It's set to seven.

5
00:00:12.300 --> 00:00:16.360
And my question is what does this evaluate to.

6
00:00:16.420 --> 00:00:20.480
And the reason I'm asking is that it has to do with operator precedents.

7
00:00:20.560 --> 00:00:26.380
So this will be a very quick video but it's very important when we're working with all operators as

8
00:00:26.380 --> 00:00:29.840
we've already seen with addition subtraction multiplication division.

9
00:00:29.980 --> 00:00:33.430
Certain operators have precedence over others for example.

10
00:00:33.490 --> 00:00:36.220
Division happens before subtraction.

11
00:00:36.220 --> 00:00:42.190
That also applies with logical operators and it applies with operators like this one here greater than

12
00:00:42.660 --> 00:00:46.370
a logical guess would be to assume it goes from left to right.

13
00:00:46.420 --> 00:00:49.300
So we would have X equals seven.

14
00:00:49.420 --> 00:00:50.800
Well that's true.

15
00:00:50.800 --> 00:00:55.830
Then we have true or X equals three that's false.

16
00:00:55.900 --> 00:01:01.410
So this whole thing since we have the order right there this whole thing becomes true.

17
00:01:02.110 --> 00:01:07.090
And then we have true and X greater than 10.

18
00:01:07.780 --> 00:01:08.910
Well that's not the case.

19
00:01:08.920 --> 00:01:09.500
Right.

20
00:01:09.520 --> 00:01:10.450
X is seven.

21
00:01:10.450 --> 00:01:11.620
So that's false.

22
00:01:11.620 --> 00:01:14.150
So then the whole thing becomes false.

23
00:01:14.320 --> 00:01:17.020
That's what you might think the answer is.

24
00:01:17.020 --> 00:01:21.820
But if we actually look and we pasted in the answer is true.

25
00:01:22.330 --> 00:01:27.320
And the reason for this is because the and operator takes precedence over or.

26
00:01:28.060 --> 00:01:34.150
So this is going to run first and it's going to look for a left and a right and you can think of it

27
00:01:34.450 --> 00:01:36.590
as this right here.

28
00:01:36.700 --> 00:01:38.120
So is X equal to three.

29
00:01:38.440 --> 00:01:39.420
Nope.

30
00:01:39.490 --> 00:01:41.920
So that's false X greater than 10.

31
00:01:41.920 --> 00:01:42.220
Nope.

32
00:01:42.220 --> 00:01:44.050
So the whole thing is false.

33
00:01:44.050 --> 00:01:45.820
Only one part needed to be false.

34
00:01:45.910 --> 00:01:52.300
So this is false or true which is going to give us true false or true.

35
00:01:52.300 --> 00:01:54.260
We need one side to be true.

36
00:01:54.670 --> 00:02:00.340
If we wanted the logic to actually work the way that we thought it did from left to right we need to

37
00:02:00.340 --> 00:02:02.430
use parentheses to group this.

38
00:02:02.500 --> 00:02:10.990
We want this to run first and if we run that you'll see we get false because now we're checking this

39
00:02:10.990 --> 00:02:18.520
first this thing evaluates to true and then this thing evaluates to false and the whole thing becomes

40
00:02:18.520 --> 00:02:21.430
false rather than what we had here.

41
00:02:21.430 --> 00:02:26.950
So the order does matter when we're working with these operators especially at the logical ones.

42
00:02:27.370 --> 00:02:28.340
This is the rough order.

43
00:02:28.450 --> 00:02:38.080
This is the exact order logical knot is going to run first then logical and then or it can be confusing

44
00:02:38.140 --> 00:02:41.300
to remember all of this and keep track of it.

45
00:02:41.320 --> 00:02:46.700
So if you ever have any doubt put parentheses in their parentheses will trump everything.

46
00:02:46.750 --> 00:02:49.950
And it makes it clearer how things are supposed to run.

47
00:02:49.990 --> 00:02:56.440
There's no shame in adding extra parents and if you go to M.D. end it's kind of an interesting chart.

48
00:02:56.440 --> 00:03:02.440
There is a table that shows the precedence of every single operator and you can see at the very top

49
00:03:02.440 --> 00:03:06.640
the highest precedence is parentheses that always wins.

50
00:03:06.640 --> 00:03:08.620
That always runs first.

51
00:03:08.620 --> 00:03:16.820
And as we scroll down we can see we encounter logical not and that comes before logical and which is

52
00:03:16.820 --> 00:03:17.860
all the way down here.

53
00:03:17.960 --> 00:03:23.330
And the logical or so and before or and not before both of those.

54
00:03:24.110 --> 00:03:35.040
And this also explains why something like this works X less than three and X greater than one.

55
00:03:35.210 --> 00:03:37.620
This is an operator and this is an operator.

56
00:03:37.700 --> 00:03:39.750
These are going to run first.

57
00:03:39.770 --> 00:03:46.400
So this on the left runs this on the right runs and then and does its thing.

58
00:03:46.400 --> 00:03:51.130
So we know that because we've been using and for a while at this point and we've seen how it works.

59
00:03:51.230 --> 00:03:58.610
But this chart explains that as you can see if I scroll down greater than less than all those operators

60
00:03:58.670 --> 00:04:02.390
come first before and and or.

61
00:04:03.010 --> 00:04:03.220
All right.

62
00:04:03.230 --> 00:04:04.300
So that's it for this video.

63
00:04:04.310 --> 00:04:05.780
I just wanted to make that clear.

64
00:04:05.840 --> 00:04:09.340
There is an order and it can be confusing to remember.

65
00:04:09.380 --> 00:04:14.210
So if you ever have any doubts add in parentheses it also makes it clearer for anyone else who's reading

66
00:04:14.210 --> 00:04:18.440
it because not all developers happen to remember that order off the top of their head either.
