WEBVTT
1
00:00:00.210 --> 00:00:02.980
Next step I'm grouping to array methods together.

2
00:00:03.070 --> 00:00:05.440
They're called every and some.

3
00:00:05.610 --> 00:00:08.220
So both of these methods are boolean methods.

4
00:00:08.220 --> 00:00:11.630
They return true or false at the end of the day after they run.

5
00:00:11.700 --> 00:00:13.380
You get true or false.

6
00:00:13.770 --> 00:00:18.990
So every is going to accept a callback which itself needs to be a boolean callback.

7
00:00:18.990 --> 00:00:20.500
It returns true or false.

8
00:00:20.760 --> 00:00:26.380
It's a test and it runs that function on every or with every element in the array.

9
00:00:27.090 --> 00:00:33.370
And if it gets true for every element then the whole function the whole method of every return is true.

10
00:00:34.200 --> 00:00:41.010
So it's a way of verifying or checking does every element in this array have three letters or does every

11
00:00:41.010 --> 00:00:43.850
element end with a letter G.

12
00:00:44.070 --> 00:00:48.020
So as an example let's try this out we have a word's array over here.

13
00:00:48.090 --> 00:00:54.930
If I wanted to check if every word has a length of 3 I would do words dot every and then I pass in my

14
00:00:54.930 --> 00:00:56.500
boolean function.

15
00:00:56.520 --> 00:01:02.250
This function also called the test function needs to return true or false so I'll say for every word

16
00:01:03.120 --> 00:01:12.290
does that word dot length equal 3 and I'll save this to a variable called all 3 letters or something.

17
00:01:12.660 --> 00:01:14.950
Not the most graceful variable name.

18
00:01:15.180 --> 00:01:17.440
Let's run it and see what we get.

19
00:01:17.640 --> 00:01:24.030
All three Lutz is true but as soon as I change one of these to be four letters or two letters and I

20
00:01:24.030 --> 00:01:26.000
run it again it's false.

21
00:01:26.010 --> 00:01:32.120
This function has to return true for every single element in order for every to return true.

22
00:01:32.250 --> 00:01:33.530
So let's go back to what we had.

23
00:01:34.170 --> 00:01:38.180
We could do another test if they all end with the letter G.

24
00:01:38.700 --> 00:01:45.300
So that would be words dot every and I'll do this on multiple lines just so that we have some diversity

25
00:01:45.300 --> 00:01:47.290
here for every word.

26
00:01:47.370 --> 00:01:49.050
That would be our parameter.

27
00:01:49.050 --> 00:01:50.790
Let's calculate the last index.

28
00:01:50.820 --> 00:01:56.920
So we'll go with last equals and then word length minus 1.

29
00:01:56.940 --> 00:01:58.320
That gives us the last index.

30
00:01:58.320 --> 00:02:07.360
Remember length is always one more than the last index and then we'll use that to return word of last.

31
00:02:07.740 --> 00:02:10.950
Triple equals G.

32
00:02:10.950 --> 00:02:15.150
So we're getting the last index which for all of these there are only three letters.

33
00:02:15.180 --> 00:02:22.410
So the last index will be two and then we're saying is word of two equal to the letter G and save that

34
00:02:22.410 --> 00:02:23.570
to a variable.

35
00:02:23.680 --> 00:02:29.310
Let's go with concept all g all end in G.

36
00:02:29.310 --> 00:02:37.590
And if we check over here all and in G is true but of course I change one of them to be bet with a T

37
00:02:38.160 --> 00:02:40.830
it's no longer true.

38
00:02:41.010 --> 00:02:47.010
So that's every it takes a boolean function it runs it on every element in the array and if it always

39
00:02:47.010 --> 00:02:52.200
gets true for the entire array then every itself returns true.

40
00:02:52.200 --> 00:02:55.320
Next we have some some is similar.

41
00:02:55.320 --> 00:03:01.600
It does kind of the same process but it only cares if any of those elements pass the test.

42
00:03:01.620 --> 00:03:07.950
So if there's at least one element in the array that pass the test that return true then the entire

43
00:03:07.950 --> 00:03:09.930
method of some returns true.

44
00:03:09.930 --> 00:03:17.280
So with this example array of words if I wanted to check if some of the words start with D it would

45
00:03:17.280 --> 00:03:24.740
be words dot some and then word will do word of zero equals D.

46
00:03:24.750 --> 00:03:27.450
So this is a boolean function we pass in.

47
00:03:27.450 --> 00:03:33.240
It has to be a true or false returning function and some will call it once per elements.

48
00:03:33.240 --> 00:03:37.010
And as long as it gets one true that's all that matters.

49
00:03:37.050 --> 00:03:40.520
Words that some will return true or the sum method.

50
00:03:40.680 --> 00:03:43.130
So we'll go with whom.

51
00:03:43.230 --> 00:03:46.850
I don't know these variables are really hard to name const some.

52
00:03:46.980 --> 00:03:51.630
Start with D is quite the lengthy name.

53
00:03:52.530 --> 00:03:53.680
Let's check it out.

54
00:03:53.790 --> 00:03:54.890
Some start with D.

55
00:03:55.410 --> 00:03:57.040
Yes that is true.

56
00:03:57.270 --> 00:03:59.820
We have two elements that start with D.

57
00:03:59.820 --> 00:04:05.360
If I instead did words dot every word starts with D.

58
00:04:05.520 --> 00:04:17.920
We'll call this every year all start with D we get false as you can see here versus some start is true.

59
00:04:18.120 --> 00:04:24.920
So the only difference here was some in every some needs just one element to return true every needs.

60
00:04:24.960 --> 00:04:26.840
All of them to return true.

61
00:04:26.910 --> 00:04:31.260
Let's try one more every one two words dot every actually.

62
00:04:31.410 --> 00:04:35.880
Let's bring our books back and let's try a couple more examples with our good friend.

63
00:04:35.880 --> 00:04:44.460
This book array let's write some code to check if every book is at least three point five stars or three

64
00:04:44.460 --> 00:04:48.060
point five whatever rating or higher.

65
00:04:48.060 --> 00:04:57.180
So we would call books dot every for each book we want to know if book dot rating is greater than three

66
00:04:57.180 --> 00:05:01.260
point five and we'll save this to a variable.

67
00:05:01.270 --> 00:05:04.180
All good books.

68
00:05:04.270 --> 00:05:04.980
Let's take a look.

69
00:05:04.990 --> 00:05:07.000
All good books is true.

70
00:05:07.120 --> 00:05:09.250
If I instead did 4.5 and higher

71
00:05:12.520 --> 00:05:17.800
that's false because we have plenty of books that are not four point five or higher.

72
00:05:17.800 --> 00:05:18.840
So let's go back to it.

73
00:05:18.850 --> 00:05:20.690
Let's leave it up for them.

74
00:05:20.800 --> 00:05:21.420
Three point five.

75
00:05:21.460 --> 00:05:23.050
I think all of these books are good.

76
00:05:23.080 --> 00:05:26.470
I would feel bad saying that one of them is not good.

77
00:05:26.470 --> 00:05:28.570
Some of these older books Lord of the Flies.

78
00:05:28.690 --> 00:05:35.350
People always write them lower and that's right one more to see if any of these books have two authors.

79
00:05:35.350 --> 00:05:37.030
So that would be a concept.

80
00:05:37.780 --> 00:05:42.420
Let's go with any two authors equals books dad.

81
00:05:42.490 --> 00:05:51.460
Some book book that authors got length equals two.

82
00:05:51.550 --> 00:05:58.720
So we're passing in our function the test function it will return true if a given book has exactly two

83
00:05:58.720 --> 00:06:01.770
authors authors felt like this too.

84
00:06:01.960 --> 00:06:03.060
And we're using some.

85
00:06:03.090 --> 00:06:05.590
So we just need one of them to be true.

86
00:06:05.590 --> 00:06:09.580
We'll run it any two authors is true.

87
00:06:09.610 --> 00:06:09.850
Okay.

88
00:06:09.880 --> 00:06:16.660
So that is some and every day follow a similar pattern but they behave differently every needs every

89
00:06:16.660 --> 00:06:18.210
element to pass this test.

90
00:06:18.280 --> 00:06:19.900
Some just needs one to pass.
