WEBVTT
1
00:00:05.610 --> 00:00:09.240
OK so it's time to practice what you've learned in this section.

2
00:00:09.240 --> 00:00:15.600
So the first thing that I'm going to do and I've already created the usual package and class is I'm

3
00:00:15.600 --> 00:00:18.460
going to add a Person class.

4
00:00:18.900 --> 00:00:25.400
So class person and then I'll have a first name which will be a string.

5
00:00:25.670 --> 00:00:34.630
They'll have a last name also a string and they'll have an age.

6
00:00:35.280 --> 00:00:37.770
OK so now I'm going to add a main method.

7
00:00:37.890 --> 00:00:42.960
So Main and let's add the following code vowel.

8
00:00:43.050 --> 00:00:51.630
Joe equals and he's a person his first name is Joe his second name is Jones.

9
00:00:52.400 --> 00:00:58.780
And let's say he's 45 and now I want to be able to do the following vowel F..

10
00:00:58.830 --> 00:01:05.400
Name no name and age equals Joe.

11
00:01:06.390 --> 00:01:19.700
And then I want to print line f name equals F. name our name equals Al name and age equals age.

12
00:01:20.100 --> 00:01:24.140
And so your first challenge is to make this compile.

13
00:01:24.210 --> 00:01:29.890
Do what you have to do to make this code compile because right now we have a compilation error here.

14
00:01:29.940 --> 00:01:33.240
So I paused the video and give that a try now.

15
00:01:35.420 --> 00:01:35.860
OK.

16
00:01:35.870 --> 00:01:37.490
Well this one shouldn't have been too bad.

17
00:01:37.490 --> 00:01:44.150
In fact the error message tells us what we have to do essentially we need to add the component and functions

18
00:01:44.150 --> 00:01:47.270
to the Person class in order to make this work.

19
00:01:47.270 --> 00:01:50.120
Now there are two ways we could do this.

20
00:01:50.150 --> 00:01:54.170
The first way is to just make it a data class.

21
00:01:54.170 --> 00:01:55.530
Boom done.

22
00:01:55.760 --> 00:02:02.570
And the reason for that is we get the component and functions for free in data classes so that was one

23
00:02:02.570 --> 00:02:04.470
possible solution.

24
00:02:04.490 --> 00:02:09.380
The other solution lets say we didn't want this to be data class for some reason we're going to do a

25
00:02:09.380 --> 00:02:12.470
lot more in this class than just store state.

26
00:02:12.530 --> 00:02:17.960
So the other reason is to explicitly add the component and function.

27
00:02:17.960 --> 00:02:19.370
So let's go ahead and do that now.

28
00:02:19.370 --> 00:02:24.590
Now the one thing here is you always have to use the operator keyword for the component and functions

29
00:02:24.590 --> 00:02:32.810
so we'll say operator fun component 1 and we want to return the first name and then we'll say operator

30
00:02:34.030 --> 00:02:44.720
one component to and we want to return the last name and then operator fun component 3 and that will

31
00:02:44.720 --> 00:02:46.630
equal the age.

32
00:02:46.640 --> 00:02:48.860
And now we compile.

33
00:02:48.860 --> 00:02:50.070
So let's go ahead and run

34
00:02:53.750 --> 00:02:59.300
and we have F name equals Joe Al-Naimi calls Jones and age equals 45.

35
00:02:59.300 --> 00:03:00.660
So that works.

36
00:03:00.680 --> 00:03:06.680
Just remember that when youre coding the component and functions you always need the operator key word

37
00:03:06.680 --> 00:03:08.780
in front they have to be operators.

38
00:03:08.810 --> 00:03:11.970
All right so now I'm going to type in some more people.

39
00:03:12.080 --> 00:03:21.830
So we've got our our Joe person and all type in a few more people here so I'll say Val Jane equals person

40
00:03:23.300 --> 00:03:25.810
Jane snaps.

41
00:03:26.090 --> 00:03:27.250
So make her yeah.

42
00:03:27.500 --> 00:03:28.970
She can be 12.

43
00:03:28.970 --> 00:03:31.250
These aren't employees I just went in for a moment.

44
00:03:31.250 --> 00:03:31.570
Why.

45
00:03:31.570 --> 00:03:33.150
Why am I making an employee 12.

46
00:03:33.170 --> 00:03:36.370
But these are people not necessarily employees.

47
00:03:36.380 --> 00:03:44.350
So we have Mary and she's Mary Wilson and she'll be 70 years old.

48
00:03:44.450 --> 00:03:45.980
Pesky bracket there.

49
00:03:46.010 --> 00:03:50.720
And then we have now John and he's a person as well.

50
00:03:50.720 --> 00:03:53.840
His name is John Adams.

51
00:03:53.870 --> 00:03:56.370
And he'll be 32.

52
00:03:56.390 --> 00:04:00.820
And finally we have gene or you Joie.

53
00:04:00.830 --> 00:04:11.360
Perhaps if you if you live in a francophone area and we'll see Gene or John Smithson I guess if it was

54
00:04:11.360 --> 00:04:16.170
Zsa maybe there'd be a different last name here in 66.

55
00:04:16.640 --> 00:04:27.470
OK so using this data I want you to create an immutable map and the key for the map should be the last

56
00:04:27.560 --> 00:04:29.700
name of the person.

57
00:04:29.810 --> 00:04:36.910
So the key should be the last name and the value will be the person instance.

58
00:04:36.950 --> 00:04:41.120
So create an immutable map that contains all of this data.

59
00:04:41.120 --> 00:04:48.050
The key for each entry should be the last name and the value for each entry should be the person instance

60
00:04:48.050 --> 00:04:50.620
so paused the video and go ahead and do that now.

61
00:04:52.670 --> 00:05:00.800
OK welcome back so we want an immutable map so I'm going to say Val people equals map because we want

62
00:05:00.800 --> 00:05:12.290
an immutable map and then we'll say Jones to Joe because we want the key to be the last name and we

63
00:05:12.290 --> 00:05:16.700
want the value to be the person instance and then it's just going to be the same for all of them.

64
00:05:16.700 --> 00:05:20.420
So Smith to Jane

65
00:05:22.790 --> 00:05:36.890
Wilson to Mary Adams to John and Smithson to Gene.

66
00:05:36.890 --> 00:05:42.590
Now if you wanted to in a real world application we probably upper case or lower case a last name to

67
00:05:42.590 --> 00:05:46.940
make sure if we were receiving input or something that it would match in fact we probably use an ant

68
00:05:47.030 --> 00:05:50.190
but I'm not doing any of that here.

69
00:05:50.270 --> 00:05:55.140
We're just demonstrating stuff here and getting you to stretch your Cartland muscle.

70
00:05:55.160 --> 00:06:01.610
So this is how you create an immutable map for this data where we're using the last name as the key

71
00:06:01.640 --> 00:06:05.010
and the person instance is a value.

72
00:06:05.240 --> 00:06:13.040
OK so now that you have this map I want you to print out how many people have last names beginning with

73
00:06:13.130 --> 00:06:19.290
S and I want you to do that without using an explicit loop.

74
00:06:19.370 --> 00:06:23.270
So you should be able to do this in one statement.

75
00:06:23.390 --> 00:06:30.710
So print the number of people in the people map that have last names beginning with ass and do it without

76
00:06:30.710 --> 00:06:32.140
using an explicit loop.

77
00:06:32.140 --> 00:06:36.950
In other words you shouldn't be using four or 4 each or anything like that.

78
00:06:37.160 --> 00:06:41.210
You should be able to do this in just one statement.

79
00:06:41.210 --> 00:06:44.030
So give that a try and I'll see you in a bit.

80
00:06:46.100 --> 00:06:47.930
OK how did you do with that one.

81
00:06:47.930 --> 00:06:51.030
I'm going to give you my solution yours might be different.

82
00:06:51.140 --> 00:06:57.440
So print line people Daut and I'm going to use the filter here because the first thing I want to do

83
00:06:57.860 --> 00:07:02.380
is get the people who have last names that begin with s.

84
00:07:02.390 --> 00:07:13.770
So I'm going to say I dot value dot last name dot starts with and S starts with.

85
00:07:14.300 --> 00:07:21.650
So at this point I have all the people with last names that begin with s because they are the only ones

86
00:07:21.650 --> 00:07:23.020
that are going to pass the filter.

87
00:07:23.030 --> 00:07:25.990
And then all I want to do at this point is count them.

88
00:07:26.060 --> 00:07:28.070
So I'll call a count.

89
00:07:28.070 --> 00:07:33.650
Now you could also use the key here instead of going out value dot last name you could say itx key.

90
00:07:33.650 --> 00:07:38.480
I like doing it this way because it makes it obvious that we're filtering on the last name and that

91
00:07:38.480 --> 00:07:40.550
might not be obvious if we just put key.

92
00:07:40.580 --> 00:07:42.950
But if you put key here that's fine.

93
00:07:43.010 --> 00:07:46.700
You may have found a different way to do it without having to explicitly loop.

94
00:07:46.700 --> 00:07:48.010
This is my solution.

95
00:07:48.140 --> 00:07:53.040
So we call filtered to get the people with the last name of asked.

96
00:07:53.210 --> 00:07:55.890
And then we just count how many people are in the result.

97
00:07:56.120 --> 00:08:01.000
So let's run and we should get to know our answer.

98
00:08:02.590 --> 00:08:08.400
And we do there are two people in our people map that have the last name beginning with S.

99
00:08:08.560 --> 00:08:15.490
Ok so now what I want you to do with this map is I want you to create a list of pairs from this map

100
00:08:15.970 --> 00:08:21.550
and the first item in the pair should be the first name and the last item in the pair should be the

101
00:08:21.550 --> 00:08:26.240
last name and I want you to do this once again without using a loop.

102
00:08:26.380 --> 00:08:34.870
So you should end up with a list of pairs and the first pair will have Joe as its first value in Jones's

103
00:08:34.930 --> 00:08:36.100
second value.

104
00:08:36.220 --> 00:08:41.610
The second pair would have Jane is the first value in this is second value etc..

105
00:08:41.650 --> 00:08:48.580
So create a list of pairs of first names and last names without using a loop and then go ahead and print

106
00:08:48.580 --> 00:08:50.430
out the list of pairs.

107
00:08:50.440 --> 00:08:51.510
After you finish.

108
00:08:51.520 --> 00:08:56.400
So give that a try and I'll see you in a bit OK.

109
00:08:56.400 --> 00:08:57.750
How did you do with that one.

110
00:08:57.750 --> 00:09:03.740
There are a couple of ways that I thought of to do this one and once again your solution might be different.

111
00:09:03.750 --> 00:09:10.260
So the first way that I did it was to say vowel name pairs equals.

112
00:09:10.890 --> 00:09:21.840
And then I said people dot map and then for each entry I create a pair that consists of the first name

113
00:09:22.830 --> 00:09:27.350
and the last name and that's it.

114
00:09:27.360 --> 00:09:28.480
That's the solution.

115
00:09:28.560 --> 00:09:35.790
So remember that when you use map whatever is in here is executed for every entry.

116
00:09:35.820 --> 00:09:41.520
So I'm saying that for every entry in the map create a pair that consists of the first name and the

117
00:09:41.520 --> 00:09:42.340
last name.

118
00:09:42.390 --> 00:09:49.660
And then I'll go ahead and printout name pairs and we'll run.

119
00:09:49.990 --> 00:09:51.780
And I have my list of name pairs.

120
00:09:51.790 --> 00:09:57.040
Joe Jones Jane Smith Mary Wilson etc. So that's one way.

121
00:09:57.050 --> 00:10:06.350
Another more verbose way that I thought of is to say Val first name equals people dot map and I want

122
00:10:06.350 --> 00:10:10.120
to get the I-T value of first name.

123
00:10:10.840 --> 00:10:20.860
So this is actually a list of first names and then on our last name equals people dot map T-top value

124
00:10:20.860 --> 00:10:22.120
dot last name.

125
00:10:22.300 --> 00:10:24.090
So this contains last names.

126
00:10:24.100 --> 00:10:27.940
Maybe I should call these first names and last names just to make that clear.

127
00:10:28.390 --> 00:10:37.330
And then I'm going to say vowel name pairs two equals and I'm going to say first names don't zip last

128
00:10:37.330 --> 00:10:38.560
names.

129
00:10:38.560 --> 00:10:44.590
You remember we took a look at this zip function and what it does is it creates pairs so it matches

130
00:10:44.590 --> 00:10:51.040
the first bite him in the first list with the first item in the list it's called with the second item

131
00:10:51.040 --> 00:10:56.230
in the list it's invoked with the second item in the list it's called with what you know etc..

132
00:10:56.410 --> 00:10:59.840
So I'm going to say print line name pairs.

133
00:11:00.270 --> 00:11:01.820
And I should get the same result.

134
00:11:01.840 --> 00:11:02.680
So I'm going to run

135
00:11:05.530 --> 00:11:08.710
and I do so that's two potential ways of doing it.

136
00:11:08.710 --> 00:11:13.960
This one's a lot more concise but in this line we're not using a loop either so you might have come

137
00:11:13.960 --> 00:11:18.340
up with one of these two solutions or maybe you came up with another solution as long as you're not

138
00:11:18.700 --> 00:11:20.110
explicitly looping.

139
00:11:20.110 --> 00:11:24.850
Because I asked you not to do that because obviously you could do it by explicitly looping But the challenge

140
00:11:24.850 --> 00:11:27.230
was not to explicitly loop.

141
00:11:27.430 --> 00:11:32.760
So as long as you're not explicitly looping and you get this result you're good.

142
00:11:32.760 --> 00:11:33.220
All right.

143
00:11:33.220 --> 00:11:40.090
So we talked about lambdas with receivers and we looked at the Wiz and apply functions but there are

144
00:11:40.090 --> 00:11:42.670
other functions that also work with receivers.

145
00:11:42.670 --> 00:11:46.360
And one of those is the also function.

146
00:11:46.360 --> 00:11:52.520
So the also function also works with receivers.

147
00:11:52.690 --> 00:11:58.610
What I want you to do is I want you to read up on this function and then use it to print out the following.

148
00:11:58.930 --> 00:12:00.180
Using the people map.

149
00:12:00.190 --> 00:12:02.250
So I want you to out.

150
00:12:02.650 --> 00:12:12.890
Show is 45 years old Jane is 12 years old Extra.

151
00:12:12.910 --> 00:12:18.040
So for each entry in the map you should printout a line that says how old they are.

152
00:12:18.040 --> 00:12:24.070
So go ahead take a look at the also function you should be able to find documentation on ranch's using

153
00:12:24.070 --> 00:12:31.420
your favorite search engine and then use it on the people map to print out a line for each entry in

154
00:12:31.420 --> 00:12:36.680
the map that tells us how old that person is in this format.

155
00:12:36.730 --> 00:12:37.630
So I see in a bit.

156
00:12:37.630 --> 00:12:40.150
Good luck with it.

157
00:12:40.180 --> 00:12:40.840
All right.

158
00:12:40.840 --> 00:12:41.470
Welcome back.

159
00:12:41.470 --> 00:12:47.530
Well if you read about the also function and I hope you did you'll know that it works like the Apply

160
00:12:47.530 --> 00:12:53.370
function but you use it instead of this inside the lambda to refer to the receiver object.

161
00:12:53.770 --> 00:13:01.780
So let's go ahead and use it to do what the challenge asked to do so we'll save people dot also so the

162
00:13:01.780 --> 00:13:08.290
people map is the receiver object for whatever they Lamda that we're going to write in here and we'll

163
00:13:08.290 --> 00:13:09.930
say it map.

164
00:13:09.940 --> 00:13:19.360
So I-T refers to the people map and we'll say print lying and we want to print.

165
00:13:19.360 --> 00:13:23.440
I'm going to open up the expression here I've got value.

166
00:13:23.560 --> 00:13:27.590
First name suggested it to me and then took it away.

167
00:13:28.470 --> 00:13:34.600
And then we'll say is and then we want to print out I T-Dog follow you dot H.

168
00:13:35.100 --> 00:13:40.050
Years old and that's it.

169
00:13:40.050 --> 00:13:48.820
So let's go ahead and run and we get Joe is 45 years old Jane is 12 years old etc. This print line is

170
00:13:48.820 --> 00:13:51.230
coming from underneath here.

171
00:13:51.340 --> 00:13:56.640
So as I said the difference between Also and apply because otherwise they're pretty much the same as

172
00:13:56.740 --> 00:14:00.860
you use it instead of this inside the also LAMDA.

173
00:14:01.000 --> 00:14:04.440
So why would you want to use Also instead of apply.

174
00:14:04.600 --> 00:14:10.450
Well it can come in handy when for some reason you don't want to use this inside the lambda.

175
00:14:10.450 --> 00:14:17.290
Maybe the code surrounding this statement is also using this to refer to something else and so you don't

176
00:14:17.290 --> 00:14:19.710
want any confusion that could be one reason.

177
00:14:19.930 --> 00:14:23.090
But essentially it does the same thing as apply.

178
00:14:23.470 --> 00:14:29.870
Ok so now I'm going to type in two lists and I'm going to want you to do something with those lists.

179
00:14:30.040 --> 00:14:33.810
So I'll do that down here I'll say Val just one equals.

180
00:14:34.300 --> 00:14:35.870
And this is going to be a list.

181
00:14:35.920 --> 00:14:46.950
And it's just integers 1 4 9 15 and 33 and then our second list will be a list of integers as well.

182
00:14:46.990 --> 00:14:54.710
But this time we'll have 4 55 minus 83 22 and 1 0 1.

183
00:14:55.060 --> 00:15:01.780
So we have these two lists and I want you to create a third list that only contains items that are in

184
00:15:01.780 --> 00:15:03.340
both of these lists.

185
00:15:03.550 --> 00:15:10.330
And I want you to once again do that without using an explicit loop because of course with this challenge

186
00:15:10.330 --> 00:15:12.390
just like the other ones you could do in x.

187
00:15:12.460 --> 00:15:16.080
Do it using an explicit loop but I don't want you to do that.

188
00:15:16.090 --> 00:15:23.650
So what I want you to do is to create a third list and that list should contain all the matching items.

189
00:15:23.650 --> 00:15:31.870
So the resulting list should contain four because four is in both lists and it should contain 15.

190
00:15:31.870 --> 00:15:38.230
I meant to add 15 here so it should contain the resulting list should contain 4 because four is in both

191
00:15:38.230 --> 00:15:46.630
lists and should also contain 15 because 15 is in both lists and create that list without using an explicit

192
00:15:46.660 --> 00:15:47.290
loop.

193
00:15:47.290 --> 00:15:49.890
So good luck with that and I'll see you in a bit.

194
00:15:51.960 --> 00:15:52.410
All right.

195
00:15:52.410 --> 00:15:53.190
Welcome back.

196
00:15:53.190 --> 00:15:58.290
There are a number of ways you can do this so your solution might not match mine at all.

197
00:15:58.290 --> 00:16:03.060
There are verbose ways we can do it and there are concise ways we can do it.

198
00:16:03.060 --> 00:16:05.940
I'm going to show you two of the concise ways.

199
00:16:06.120 --> 00:16:13.440
So the first way is I'm going to say Vallis three equals I'm going to say list one dot filter because

200
00:16:13.440 --> 00:16:20.720
when you think about it we want to grab items in the lists that match a certain condition.

201
00:16:20.730 --> 00:16:22.370
So filter is ideal for that.

202
00:16:22.380 --> 00:16:31.500
And in this case we're going to say if the item in list 1 is also in bliss too we want we want it in

203
00:16:31.500 --> 00:16:32.630
our new list.

204
00:16:32.910 --> 00:16:35.030
And so that's the solution here.

205
00:16:35.250 --> 00:16:41.520
So what's going to happen here is each item in list one is going to be substituted for it.

206
00:16:41.550 --> 00:16:48.910
And then if that item is also in list to we want it in our list so let's print line lists three lists

207
00:16:48.930 --> 00:16:59.050
three equals list three and let's run and we have our list with four and 15.

208
00:16:59.100 --> 00:17:05.670
Now we could also do it as follows I'll comment this out so that you have both solutions and I'll say

209
00:17:05.680 --> 00:17:10.270
Vau lists three equals and once again we're going to use filters.

210
00:17:11.040 --> 00:17:18.110
But instead of using in and we could say List 2 contains I-T.

211
00:17:18.240 --> 00:17:20.310
So that's another potential solution.

212
00:17:20.310 --> 00:17:27.380
So in this case we're we're saying for each item in list one call list 2 contains with it.

213
00:17:27.390 --> 00:17:32.550
And if this returns true then of course we've got a matching item and we'll add it to our resulting

214
00:17:32.550 --> 00:17:36.540
lists so let's run.

215
00:17:36.840 --> 00:17:39.120
And again we get 4 in 15.

216
00:17:39.270 --> 00:17:42.160
Now as I said there are a number of ways you can solve this.

217
00:17:42.160 --> 00:17:47.850
There are some really verbose ways where instead of using inning contains you could explicitly write

218
00:17:47.850 --> 00:17:54.630
a longer lambda that tests whether you know list 1 or whatever it equals list 2.

219
00:17:54.650 --> 00:17:59.770
Now you can do it that way but the concise version that I've shown you are a lot easier to read.

220
00:17:59.820 --> 00:18:05.370
And they are concise so that's why I've chosen to show you these two solutions.

221
00:18:05.670 --> 00:18:11.430
OK so now let's move on and I'm going to type in a few classes here.

222
00:18:11.430 --> 00:18:12.420
I'm going to say.

223
00:18:12.420 --> 00:18:15.950
Class box t.

224
00:18:17.730 --> 00:18:23.380
And I'm going to create an E class called paper.

225
00:18:23.910 --> 00:18:29.490
And in fact not going to make this open because I'm going to create two subclasses of paper.

226
00:18:29.490 --> 00:18:37.770
Now I'm going to create a class of regular paper which extends paper and I'm going to create a class

227
00:18:37.770 --> 00:18:45.000
of premium paper which also extends paper.

228
00:18:45.510 --> 00:18:52.610
Okay that's fine and dandy so we've got a paper class it's got two subclasses called regular and premium.

229
00:18:52.620 --> 00:18:54.830
And we have this box of T.

230
00:18:55.230 --> 00:19:05.610
So let's go back up to our main function and I'm going to save Val regular paper equals the box of regular

231
00:19:05.610 --> 00:19:07.080
paper.

232
00:19:08.100 --> 00:19:08.950
So here am.

233
00:19:09.030 --> 00:19:18.480
I'm using regular for T and then I'm going to say Vau paper equals box of paper that's valid too.

234
00:19:18.510 --> 00:19:22.280
In this case I'm using paper for T.

235
00:19:22.350 --> 00:19:26.640
And now I'm going to say paper equals regular paper.

236
00:19:26.640 --> 00:19:32.810
Now this looks like it should work right because a box of paper could be a box of regular paper but

237
00:19:32.820 --> 00:19:34.240
right now it doesn't.

238
00:19:34.290 --> 00:19:36.800
It does not compile.

239
00:19:37.020 --> 00:19:43.030
So your challenge is to do whatever you need to do to make this line compile.

240
00:19:43.050 --> 00:19:45.650
So good luck with that and I'll see you in a bit.

241
00:19:47.860 --> 00:19:53.020
Okay welcome back while we have two problems here one is pretty trivial if we look at this it'll say

242
00:19:53.010 --> 00:19:57.850
Val cannot be reassigned so this is an easy fix we just make it var.

243
00:19:58.120 --> 00:20:01.200
And now that's gone away but now we're getting a type mismatch.

244
00:20:01.210 --> 00:20:07.270
A box of paper is what the compiler whines and we're giving it a box of regular.

245
00:20:07.300 --> 00:20:09.620
So what are we trying to do here.

246
00:20:09.670 --> 00:20:15.680
We're trying to assign a box of paper with a box of one of papers subclasses.

247
00:20:15.970 --> 00:20:25.860
So ideally what we want is when it comes to box of tea we want t to accept T or any of T subclasses

248
00:20:25.870 --> 00:20:33.070
because in this case we want to be able to assign a box of regular to a box of paper.

249
00:20:33.220 --> 00:20:39.610
And so we want to be a little more relaxed and say well you know what we'll accept tea or we'll accept

250
00:20:39.940 --> 00:20:46.330
a subclass of T because in this case that would mean that in this case we'll say that because paper

251
00:20:46.330 --> 00:20:52.450
is a box of paper well it will also accept a box of subclasses of paper and that's what we've got.

252
00:20:52.450 --> 00:20:54.100
We've got a box of regular.

253
00:20:54.110 --> 00:21:02.010
So what does that sound like when we want to be more relaxed so that it accepts T and any of its subclasses

254
00:21:02.020 --> 00:21:04.880
Well that sounds like covariance.

255
00:21:05.140 --> 00:21:09.950
So to get this to work we need to make the box class covariant.

256
00:21:10.330 --> 00:21:16.510
And we do that by adding the out key word and Ka-BOOM.

257
00:21:16.510 --> 00:21:17.760
Here we go.

258
00:21:17.800 --> 00:21:25.390
Our error has gone now as a reminder once we've done this once we've made baulks covariant.

259
00:21:25.390 --> 00:21:28.380
We can only take papers from the box.

260
00:21:28.510 --> 00:21:35.530
We can't add papers to the box because t now can only be in the out position and that's the return type

261
00:21:35.530 --> 00:21:38.020
of a function so we can do this.

262
00:21:38.260 --> 00:21:46.230
We could say fine take paper and that returns T and I need to give this function a body.

263
00:21:46.240 --> 00:21:49.780
Now I'm getting an error because I'm not returning anything because you know I'd have to declare a list

264
00:21:49.780 --> 00:21:50.950
and all of that and return.

265
00:21:50.950 --> 00:21:52.840
But we can do this.

266
00:21:52.840 --> 00:21:57.310
We're not getting an error on the function signature but we can't do this.

267
00:21:57.310 --> 00:22:06.190
We can't say fun add paper and we're going to add a paper of type T because we'll see here that type

268
00:22:06.190 --> 00:22:10.440
parameter T is declared as out but occurs in the in position.

269
00:22:10.450 --> 00:22:13.610
Now if we could add papers to the box.

270
00:22:13.660 --> 00:22:21.490
Let's assume this compiled we'd be able to do this we'd be able to say paper dot add paper and add premium

271
00:22:21.490 --> 00:22:21.940
paper

272
00:22:24.670 --> 00:22:32.780
because we've said that a box of paper shoot the T should be able to be the class or any of its subclasses.

273
00:22:33.010 --> 00:22:35.030
And here we're accepting T.

274
00:22:35.050 --> 00:22:41.380
So if this was to compile we're not getting compile compile error here because a compiler can see this

275
00:22:41.380 --> 00:22:44.680
function but it does function doesn't compile.

276
00:22:44.680 --> 00:22:49.620
So we can't actually do what we're doing up here and now you can understand why.

277
00:22:49.810 --> 00:22:54.250
Because at the moment we have a box of regular paper stored here.

278
00:22:54.270 --> 00:22:58.160
But here we're we're coming along and adding premium paper.

279
00:22:58.330 --> 00:23:06.640
So if this could compile we'd now have a what's supposed to be a box of type premium regular paper rather

280
00:23:06.940 --> 00:23:09.780
with a premium instance in it.

281
00:23:09.790 --> 00:23:13.720
And obviously you know that's not that's not supposed to happen.

282
00:23:13.780 --> 00:23:22.330
And so this is why once we declare boxes out we can no longer have to be in the position we can only

283
00:23:22.750 --> 00:23:30.180
read this class now instances of this class we can no longer change them we can't write them.

284
00:23:30.220 --> 00:23:31.610
And so this is a no no

285
00:23:34.740 --> 00:23:35.170
.

286
00:23:35.270 --> 00:23:40.220
I'll keep that there just and I'll put a comment saying ahead.

287
00:23:40.560 --> 00:23:48.390
Now just to remind you of the other case contravariant if we wanted t to accept T and all of its superclasses.

288
00:23:48.390 --> 00:23:55.070
In other words if we wanted to be able to do the following regular paper equals paper.

289
00:23:55.310 --> 00:23:57.720
Let me make that a VAR.

290
00:23:57.720 --> 00:24:02.880
We're able to do that now because a compiler smart enough to know that we have a box of regular paper

291
00:24:03.300 --> 00:24:04.480
inside here.

292
00:24:04.590 --> 00:24:10.290
So let me it's one of those trick things again where it's actually comparing them.

293
00:24:10.290 --> 00:24:13.160
So let me comment that out.

294
00:24:13.170 --> 00:24:20.250
And now we're going to get the problem because now it's telling us that well sorry you have a box of

295
00:24:20.250 --> 00:24:24.890
regular paper and you're trying to assign a box of paper to it and we can't do that.

296
00:24:25.170 --> 00:24:32.190
So the way around that of course what we want to be relaxed so that it accepts T and it superclasses

297
00:24:32.190 --> 00:24:39.180
is to make the class contravariant So let's just do that temporarily and we do that by changing this

298
00:24:39.180 --> 00:24:45.860
to in but now of course we can't read the instances of this class.

299
00:24:45.870 --> 00:24:46.800
We can only write them.

300
00:24:46.800 --> 00:24:48.380
So now we're getting an error here.

301
00:24:48.390 --> 00:24:56.190
But if I comment this out we're no longer getting an error on t here because this is in the in position

302
00:24:56.190 --> 00:24:57.440
so that's fine with this.

303
00:24:57.440 --> 00:24:59.130
He is in the out position.

304
00:24:59.220 --> 00:25:05.990
Now this may look funny because an instance of paper isn't necessarily an instance of regular paper

305
00:25:06.720 --> 00:25:17.580
and that's exactly why we can no longer read or take papers from a box of this contravariant type because

306
00:25:17.580 --> 00:25:23.730
right now we actually have a box of paper and regular paper and if we could do this take paper we could

307
00:25:23.730 --> 00:25:25.400
do something like this.

308
00:25:25.540 --> 00:25:34.200
Val I don't know sheet and we want that to be a regular paper and we're going to go ahead and go regular

309
00:25:34.910 --> 00:25:38.330
paper 0 let's say.

310
00:25:38.370 --> 00:25:42.900
Now none of this is compiling because I haven't actually implemented these classes.

311
00:25:42.900 --> 00:25:44.410
But let's say we could do that.

312
00:25:44.430 --> 00:25:46.990
Or actually regular paper Daut take paper.

313
00:25:47.000 --> 00:25:48.110
That's what I have.

314
00:25:48.360 --> 00:25:57.060
So if this would work then obviously we'd have a problem because at this point in time we actually have

315
00:25:57.060 --> 00:25:58.760
a box of paper.

316
00:25:58.830 --> 00:26:03.950
We don't have a box of regular paper so we're not going to get a regular paper back but we you know

317
00:26:03.990 --> 00:26:08.830
we're expecting it because we declared regular paper as a box of regular.

318
00:26:08.910 --> 00:26:16.070
And so this is why once you make a class contravariant you can no longer read instances because you

319
00:26:16.140 --> 00:26:19.240
you're you don't know really what type you're going to get back.

320
00:26:19.410 --> 00:26:21.990
And now we can really see why.

321
00:26:22.020 --> 00:26:26.910
So I'm going to say that this would be bad here

322
00:26:30.420 --> 00:26:37.190
and that's why when you make the class contravariant you can't read the instances any more.

323
00:26:37.200 --> 00:26:42.600
So we kind of look in this challenge looked at Koncz a variance in covariance a little differently in

324
00:26:42.600 --> 00:26:43.620
the way we're using them.

325
00:26:43.620 --> 00:26:50.760
So if you were still trying to get your head around the two concepts maybe looking at it this way has

326
00:26:50.880 --> 00:26:52.310
helped make things clearer.

327
00:26:52.320 --> 00:26:56.110
Hopefully it hasn't made things much easier but hopefully it's made things clearer.

328
00:26:56.370 --> 00:26:58.800
All right that's it for this set of challenges.

329
00:26:58.800 --> 00:27:00.330
I'll see you in the next section.
