WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:04.905
And obviously if we try and invoke a method on this instance, it wouldn't work.

00:00:04.905 --> 00:00:09.480
So for example, if we tried to call greet, it won't work.

00:00:09.480 --> 00:00:11.265
And we get this missing method signature,

00:00:11.265 --> 00:00:13.320
groovy dot lambda missing method signature,

00:00:13.320 --> 00:00:16.380
which is group is way of saying that it doesn't support that method.

00:00:16.380 --> 00:00:22.270
So we add a method is the same as you'd expect from what we know in Java.

00:00:23.090 --> 00:00:26.890
We can just do this kind of thing here.

00:00:28.340 --> 00:00:30.360
Hello.

00:00:30.360 --> 00:00:32.775
So now if we rerun,

00:00:32.775 --> 00:00:35.460
you can see it prints hello. Simulate.

00:00:35.460 --> 00:00:39.030
We wanna put some state onto this class.

00:00:39.030 --> 00:00:41.100
So let's say, for example,

00:00:41.100 --> 00:00:43.505
we have the name of the person,

00:00:43.505 --> 00:00:46.620
the name of the person saying the greeting, for example.

00:00:47.350 --> 00:00:51.590
Now if I run now and you can see it's, it's low, I'm no.

00:00:51.590 --> 00:00:54.395
And that's because we haven't given a value for this.

00:00:54.395 --> 00:00:57.725
So we can give it a fixed value like this.

00:00:57.725 --> 00:01:01.700
That's one way of doing it the same as we can do in Java.

00:01:01.700 --> 00:01:04.190
Or otherwise, we can create

00:01:04.190 --> 00:01:13.920
a constructor using the same kind of syntax.

00:01:14.740 --> 00:01:18.560
And notice we don't have to put semicolons here as well either.

00:01:18.560 --> 00:01:20.030
Because of Groovy, you don't have to do that.

00:01:20.030 --> 00:01:20.855
They're optional.

00:01:20.855 --> 00:01:26.045
So I'm passing in an M and I can pass in and M here.

00:01:26.045 --> 00:01:27.725
And then rerun.

00:01:27.725 --> 00:01:29.135
It says Hello, I'm Matt.

00:01:29.135 --> 00:01:33.605
You can see we can also take advantage of Groovy is weak typing.

00:01:33.605 --> 00:01:37.520
We don't have to specify that this is a string here. I mean, it is a string.

00:01:37.520 --> 00:01:39.980
And it's nice that we say it's a string because at least it means

00:01:39.980 --> 00:01:42.300
that the developer who's using this API,

00:01:42.300 --> 00:01:45.710
I will know it's a string, but we don't have to do that. We could just do this.

00:01:45.710 --> 00:01:46.895
And similarly as well.

00:01:46.895 --> 00:01:50.540
We don't have to say we're returning void almost specifically,

00:01:50.540 --> 00:01:52.895
we don't have to give what the return type is.

00:01:52.895 --> 00:01:54.875
We can just use deaf instead.

00:01:54.875 --> 00:01:58.040
So now if we rerun still works,

00:01:58.040 --> 00:01:59.825
is a perfectly valid Ruby program.

00:01:59.825 --> 00:02:03.930
But we're just taking advantage of the group is weak typing for this.
