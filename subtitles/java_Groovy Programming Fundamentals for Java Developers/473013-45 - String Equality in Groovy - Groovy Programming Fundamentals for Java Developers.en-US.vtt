WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.160
In this video, we're going to take a look at strings.

00:00:02.160 --> 00:00:05.505
And specifically we're going to look at the difference between groovy in Java,

00:00:05.505 --> 00:00:08.400
where it's really quality is handled a little bit differently.

00:00:08.400 --> 00:00:12.850
So let's take a look. So if I have a string like this,

00:00:14.090 --> 00:00:17.055
when I run this and here you can see that the string,

00:00:17.055 --> 00:00:18.525
and let's just call this s1.

00:00:18.525 --> 00:00:20.730
In fact, if I have another string,

00:00:20.730 --> 00:00:26.040
S2, and I call it high, then in Java,

00:00:26.040 --> 00:00:28.920
if you wanted to check if S1 equals S2, in other words,

00:00:28.920 --> 00:00:30.885
if the string referred to by

00:00:30.885 --> 00:00:34.800
variable s1 is equal to the string referred to by the variable S2.

00:00:34.800 --> 00:00:38.525
We do S1 dot equals stu.

00:00:38.525 --> 00:00:42.005
Or we could do S2 dot equals s1 is the same thing.

00:00:42.005 --> 00:00:43.730
And that's what we do in Java.

00:00:43.730 --> 00:00:46.265
And what this would do is this would basically compare

00:00:46.265 --> 00:00:50.240
each character in S1 with each character in S2.

00:00:50.240 --> 00:00:51.635
So you compare the hedge with the hedge,

00:00:51.635 --> 00:00:54.710
their equal, then compare e with the i naught equal.

00:00:54.710 --> 00:00:56.375
And at that point, the false,

00:00:56.375 --> 00:00:58.325
those two strings are not equal to each other,

00:00:58.325 --> 00:01:01.175
which is different than in Java.

00:01:01.175 --> 00:01:05.285
When you do this, you're asking if the two variables,

00:01:05.285 --> 00:01:06.815
which all references to those strings,

00:01:06.815 --> 00:01:09.185
actually pointed the same physical string.

00:01:09.185 --> 00:01:11.510
And it was the exact same reference in memory,

00:01:11.510 --> 00:01:14.285
which is where the string is defined on the string literal pool.

00:01:14.285 --> 00:01:16.130
You'd have to know too much about that as well in

00:01:16.130 --> 00:01:18.095
the intermediate to advanced Java type rm.

00:01:18.095 --> 00:01:19.895
And that's effectively what you're saying.

00:01:19.895 --> 00:01:21.965
Our s1 equals, equals S2,

00:01:21.965 --> 00:01:24.530
where you have to know in Groovy is the S1 equals,

00:01:24.530 --> 00:01:29.495
equals S2 is the equivalent of S1 dot equals S2.

00:01:29.495 --> 00:01:35.780
In other words, this in Groovy is how you compare strings.

00:01:35.780 --> 00:01:39.065
So if we run this now, you'll see that they're not equal to each other.

00:01:39.065 --> 00:01:40.070
So this is false.

00:01:40.070 --> 00:01:42.480
If they were equal to each other,

00:01:42.970 --> 00:01:45.440
then you'll see that this is true.

00:01:45.440 --> 00:01:47.810
So it's just something to bear in mind with Groovy

00:01:47.810 --> 00:01:50.390
didn't have to invoke the cumbersome dot equals method.

00:01:50.390 --> 00:01:52.685
Instead, you can just do equals equals instead.

00:01:52.685 --> 00:01:54.930
So just bear in mind.
