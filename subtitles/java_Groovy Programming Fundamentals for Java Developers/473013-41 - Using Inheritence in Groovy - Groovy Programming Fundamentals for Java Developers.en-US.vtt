WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.655
Now on the Soviets of inheritance, it's the same kind of thing.

00:00:02.655 --> 00:00:04.005
So if we have another class here,

00:00:04.005 --> 00:00:06.480
which is for example employee.

00:00:06.480 --> 00:00:12.630
And maybe the employee has say, a salary.

00:00:12.630 --> 00:00:18.960
We can just choose to extend person there now and give an independent method here.

00:00:18.960 --> 00:00:23.230
For example, report for work.

00:00:31.010 --> 00:00:34.275
Maybe I'm willing for the long day ahead.

00:00:34.275 --> 00:00:37.350
I'm not sure whether that's actually something you'd want to save.

00:00:37.350 --> 00:00:40.020
You are an employee, but nonetheless, it demonstrates it.

00:00:40.020 --> 00:00:42.100
And yet we're just returning a string.

00:00:42.100 --> 00:00:43.805
And we're not saying we're returning a string,

00:00:43.805 --> 00:00:45.620
that's perfectly okay, we don't have to do.

00:00:45.620 --> 00:00:48.200
And then we can just capture that value them.

00:00:48.200 --> 00:00:52.235
So if we convert this to an employee,

00:00:52.235 --> 00:00:55.550
and because we are going to get the result of a method which is defined on

00:00:55.550 --> 00:01:00.215
the subclass and need to also use a type which refers to that subclass.

00:01:00.215 --> 00:01:02.520
Let's call this E as well.

00:01:04.030 --> 00:01:11.000
Then we can do a print line of E dot report for work.

00:01:11.000 --> 00:01:15.140
And if we run this, you'd expect it to work,

00:01:15.140 --> 00:01:19.205
but it doesn't work across because we need to put in a call to the super constructor.

00:01:19.205 --> 00:01:22.880
So we still need to respect Java's rules in that respect.

00:01:22.880 --> 00:01:28.110
So here we go, employee string name.

00:01:28.780 --> 00:01:32.765
And then we can just do super name for example.

00:01:32.765 --> 00:01:34.880
Now we rerun that spine.

00:01:34.880 --> 00:01:38.285
Hello I match b as are ready and willing for a long day ahead.

00:01:38.285 --> 00:01:42.545
Now something else you'll notice is that we didn't have to put parentheses around here.

00:01:42.545 --> 00:01:46.955
So print line is a method which is given to us from the group at runtime,

00:01:46.955 --> 00:01:50.555
which accepts an argument which is the thing we want to actually print to the console.

00:01:50.555 --> 00:01:54.830
And usually we put parentheses when we're passing a parameter to a method.

00:01:54.830 --> 00:01:58.670
But in groovy, if there's only one parameter that you're passing to a method,

00:01:58.670 --> 00:02:00.170
the parentheses are optional,

00:02:00.170 --> 00:02:04.620
which means you can have some slightly more readable at this looks a little less clunky.
