WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.805
In this video, we're going to see another operator in Revie,

00:00:02.805 --> 00:00:04.830
which is called the spaceship operator,

00:00:04.830 --> 00:00:07.110
which basically helps us do comparisons.

00:00:07.110 --> 00:00:09.105
So let's start with an example.

00:00:09.105 --> 00:00:10.470
The spaceship operator.

00:00:10.470 --> 00:00:11.865
First of all, it looks like this.

00:00:11.865 --> 00:00:14.715
It's got less than an equal sign and then a greater than sign.

00:00:14.715 --> 00:00:18.210
And you can see in this kind of looks a little bit like a spaceship sets.

00:00:18.210 --> 00:00:19.995
I can remember what the symbol looks like.

00:00:19.995 --> 00:00:23.175
Now this operator takes two arguments or two operands,

00:00:23.175 --> 00:00:25.290
and basically it does a compare to between the two.

00:00:25.290 --> 00:00:29.625
So for example, if I have Agatha as a string,

00:00:29.625 --> 00:00:31.665
and I have another string,

00:00:31.665 --> 00:00:35.560
Molly, and I execute this.

00:00:35.560 --> 00:00:37.355
It's doing a kind of competitor.

00:00:37.355 --> 00:00:42.514
It's retelling minus1 here because Agatha is less than Molly, at least alphabetically.

00:00:42.514 --> 00:00:44.390
So if you're putting those analysts, for example,

00:00:44.390 --> 00:00:45.620
and they were in assorted order,

00:00:45.620 --> 00:00:47.630
Agatha would come before Molly.

00:00:47.630 --> 00:00:49.310
If you switch this round,

00:00:49.310 --> 00:00:54.380
Molly here and put here, and then replay.

00:00:54.380 --> 00:00:55.910
And you can see now we have one.

00:00:55.910 --> 00:00:58.415
And that's because Molly is greater than,

00:00:58.415 --> 00:01:00.740
is comparatively speaking Agatha.

00:01:00.740 --> 00:01:02.780
And finally, of course,

00:01:02.780 --> 00:01:07.475
if we didn't Mali in Mali around the spaceship operator,

00:01:07.475 --> 00:01:11.555
then you can see that we get a 0 because Molly is equal to Molly.

00:01:11.555 --> 00:01:14.270
So it nice and easy and intuitive to use.

00:01:14.270 --> 00:01:15.950
The next thing you probably thinking is, well,

00:01:15.950 --> 00:01:17.945
where do I use this spaceship operator them?

00:01:17.945 --> 00:01:20.990
And we had used that is typically when you're sorting lists.

00:01:20.990 --> 00:01:26.734
So for example, if I have a list here of colors, same black, white,

00:01:26.734 --> 00:01:31.220
blue, orange, for example,

00:01:31.220 --> 00:01:34.805
then I can sort these boding L dot sort.

00:01:34.805 --> 00:01:37.370
And you see they're in sorted in alphabetical order.

00:01:37.370 --> 00:01:41.750
So Blackburn's before blue because they both start with BLA,

00:01:41.750 --> 00:01:43.250
which comes before be ALU,

00:01:43.250 --> 00:01:44.630
so there is before you.

00:01:44.630 --> 00:01:46.295
So that's why they're ordered that way.

00:01:46.295 --> 00:01:49.340
And then orange comes after because orange starts with o,

00:01:49.340 --> 00:01:52.355
black and blue box, that would be o comes later in the alphabet.

00:01:52.355 --> 00:01:54.110
And white of course is at the end because that's a

00:01:54.110 --> 00:01:58.850
W. But what you can do is you can pass to the sort method, a custom comparator.

00:01:58.850 --> 00:02:01.010
So you can use the spaceship operator like this.

00:02:01.010 --> 00:02:04.895
So you could pass a closure which takes two elements.

00:02:04.895 --> 00:02:07.670
These two elements which are going to be

00:02:07.670 --> 00:02:10.430
compared with each other in order to apply the sorting.

00:02:10.430 --> 00:02:16.700
And we could do a Spaceship B and run that.

00:02:16.700 --> 00:02:18.410
And that returns a natural ordering.

00:02:18.410 --> 00:02:22.340
So they're in increasing alphabetical order as we've seen before.

00:02:22.340 --> 00:02:24.080
Because switch these as well.

00:02:24.080 --> 00:02:26.615
You can actually put B and a.

00:02:26.615 --> 00:02:28.910
And now you're effectively reversing the order.

00:02:28.910 --> 00:02:30.125
So you can see we've got white,

00:02:30.125 --> 00:02:31.430
orange, blue, and black.

00:02:31.430 --> 00:02:33.305
And that's because we're saying for two elements,

00:02:33.305 --> 00:02:36.965
we want to have the larger elements appear before the small element.

00:02:36.965 --> 00:02:39.365
And so if you apply that completely across the list,

00:02:39.365 --> 00:02:43.280
you get the large elements at the front and the smaller ones at the back.

00:02:43.280 --> 00:02:44.930
Or in this case, larger and smaller

00:02:44.930 --> 00:02:47.930
means the words which are further down in the alphabet, or the friends.

00:02:47.930 --> 00:02:49.835
And the words which earlier in the alphabet.

00:02:49.835 --> 00:02:50.915
But the back.

00:02:50.915 --> 00:02:53.120
Because at this point you're probably thinking, well, you know,

00:02:53.120 --> 00:02:57.035
I could just do elder reverse instead and get the same effect.

00:02:57.035 --> 00:02:57.665
And that's true.

00:02:57.665 --> 00:03:00.425
You could do so in general, the spaceship operator,

00:03:00.425 --> 00:03:03.110
you find used with lists to be able to provide

00:03:03.110 --> 00:03:06.785
an ordering when you use them in a closure passed to the sort method.

00:03:06.785 --> 00:03:08.375
Be normally find them working on

00:03:08.375 --> 00:03:11.810
more complex data structures than just a list of string literals.

00:03:11.810 --> 00:03:14.090
So let's get something a little bit more substantial.

00:03:14.090 --> 00:03:18.330
So we just clean up that supposing we have a food order class.

00:03:19.300 --> 00:03:24.450
And here we've got the name of the food which we are going to buy.

00:03:24.790 --> 00:03:28.910
And we've got a cost, how much it costs.

00:03:28.910 --> 00:03:31.400
And let's put a constrictor on here.

00:03:31.400 --> 00:03:33.995
Just Shall we don't have to use named constructors all the time.

00:03:33.995 --> 00:03:37.025
And that will just take two parameters, name and costs.

00:03:37.025 --> 00:03:40.025
Notice as well that we don't actually have to give the types in groovy.

00:03:40.025 --> 00:03:41.120
So I'm not giving the types,

00:03:41.120 --> 00:03:42.320
I am not saying string name and

00:03:42.320 --> 00:03:45.110
BigDecimal cost because as a developer now I don't care to do that.

00:03:45.110 --> 00:03:46.160
You should the quick class.

00:03:46.160 --> 00:03:49.490
And I love what I'm doing by no other effect that I'm gonna be passing in these types.

00:03:49.490 --> 00:03:51.545
So I don't have to explicitly name the types as well.

00:03:51.545 --> 00:03:55.490
So again, another example of Groovy taking a hands-off approach and leaving it to you,

00:03:55.490 --> 00:03:58.520
the developer, to code in the most convenient way in the moment.

00:03:58.520 --> 00:04:01.910
So now to do this.name equals name,

00:04:01.910 --> 00:04:05.180
this dot cost equals cost.

00:04:05.180 --> 00:04:08.390
And this means I can now construct these food or other objects.

00:04:08.390 --> 00:04:14.280
So let's supposing I have an order which are placed at the drive-thru.

00:04:14.890 --> 00:04:18.860
And this is going to consist of, let's say,

00:04:18.860 --> 00:04:21.425
a burger

00:04:21.425 --> 00:04:31.040
and fries.

00:04:31.040 --> 00:04:33.275
On 85.

00:04:33.275 --> 00:04:37.940
I'm gonna be a milkshake to wash it down with two 75,

00:04:37.940 --> 00:04:42.720
several and is now you can see we have a list of these food orders.

00:04:43.120 --> 00:04:46.385
Just quickly go up to here.

00:04:46.385 --> 00:04:51.875
And we'll add a transform silicon Si and have it better.

00:04:51.875 --> 00:04:53.840
Now we can see we've got a food order, burger,

00:04:53.840 --> 00:04:57.905
399 fries when 85 and a milkshake at T2 75.

00:04:57.905 --> 00:04:59.345
So now we've got that set up.

00:04:59.345 --> 00:05:00.680
We can explain where

00:05:00.680 --> 00:05:04.625
the spaceship operator really comes into its own and gives us benefit.

00:05:04.625 --> 00:05:09.455
So if I just sought this now and do sort,

00:05:09.455 --> 00:05:13.265
then what you'll find a little keep varying.

00:05:13.265 --> 00:05:15.230
It won't be consistent between runs.

00:05:15.230 --> 00:05:17.075
So you can see here if you keep looking at these,

00:05:17.075 --> 00:05:18.995
now it's fries for example.

00:05:18.995 --> 00:05:21.110
Next time it's milkshake.

00:05:21.110 --> 00:05:23.630
It was mosaic again and it went to a burger.

00:05:23.630 --> 00:05:26.000
So we don't have a consistent ordering for these.

00:05:26.000 --> 00:05:28.820
And the reason being is because we haven't made these objects comparable.

00:05:28.820 --> 00:05:31.835
So food order itself doesn't implement comparable.

00:05:31.835 --> 00:05:34.190
That's the interface which would effectively encode

00:05:34.190 --> 00:05:36.290
how different food or instances should be

00:05:36.290 --> 00:05:38.780
ordered with respect to one another in a sorted list.

00:05:38.780 --> 00:05:40.295
There's nothing Ruby specific here.

00:05:40.295 --> 00:05:41.480
I should general Java.

00:05:41.480 --> 00:05:43.430
So of course, a way around this is either to get

00:05:43.430 --> 00:05:46.250
the class food order to implement comparable to basically

00:05:46.250 --> 00:05:48.680
define how you want things ordered but are probably doesn't make

00:05:48.680 --> 00:05:51.485
sense in this case because we might want to order these differently.

00:05:51.485 --> 00:05:53.600
And also there's non-natural way of ordering them.

00:05:53.600 --> 00:05:54.950
So how would you order these, for example,

00:05:54.950 --> 00:05:56.120
would you say that when you order them

00:05:56.120 --> 00:05:57.920
alphabetically to say that you should have burgers,

00:05:57.920 --> 00:05:59.090
fries, and a milkshake.

00:05:59.090 --> 00:06:00.770
And what would you order them by price to

00:06:00.770 --> 00:06:03.800
the cheapest one burst going up to the most expensive one in the end,

00:06:03.800 --> 00:06:06.080
you know, because there's no intrinsic way of ordering,

00:06:06.080 --> 00:06:07.865
these so-called natural ordering.

00:06:07.865 --> 00:06:09.395
And that's why it's called a natural ordering.

00:06:09.395 --> 00:06:12.200
Because whenever you implement comparable at the class level,

00:06:12.200 --> 00:06:13.505
you should feel natural.

00:06:13.505 --> 00:06:16.400
We should be completely natural that things are ordered in this particular way.

00:06:16.400 --> 00:06:18.380
Like strings can be ordered alphabetically,

00:06:18.380 --> 00:06:20.360
or numbers can be ordered numerically.

00:06:20.360 --> 00:06:22.640
Dates can be ordered chronologically, that kind of thing.

00:06:22.640 --> 00:06:24.890
But here, this is just an arbitrary class.

00:06:24.890 --> 00:06:27.410
We can't make that call because we don't know how it's going to be used.

00:06:27.410 --> 00:06:30.410
So instead of basically having this class implement comparable,

00:06:30.410 --> 00:06:33.905
which would effectively hardcode the logic of an ordering into the class itself.

00:06:33.905 --> 00:06:36.530
We can take them off flexible approach and just say that wherever

00:06:36.530 --> 00:06:39.155
we're gonna call sort on a list which contains these objects,

00:06:39.155 --> 00:06:41.104
we're going to pass in a custom comparator,

00:06:41.104 --> 00:06:44.345
which will provide the ordering at the tiny ones, assault them instead.

00:06:44.345 --> 00:06:47.540
So the key part here is instead of having comparable on here,

00:06:47.540 --> 00:06:50.240
where the ordering is maintained when you're inserting into the list.

00:06:50.240 --> 00:06:52.910
What we're doing instead is we're calling salts and we're passing in

00:06:52.910 --> 00:06:56.900
a comparator instead to effectively give like an on-demand ordering at that point.

00:06:56.900 --> 00:06:59.570
And this is what the spaceship operator is perfect for.

00:06:59.570 --> 00:07:02.900
So to do this, we give a closure like we did before.

00:07:02.900 --> 00:07:04.640
So Dr. daughter dot sort.

00:07:04.640 --> 00:07:09.635
And then we have these two elements as input arguments to the closure 68 comma b,

00:07:09.635 --> 00:07:10.880
followed by the arrow operator.

00:07:10.880 --> 00:07:12.725
So these are the input arguments than that closure.

00:07:12.725 --> 00:07:15.755
And now these elements on strings like they were before,

00:07:15.755 --> 00:07:17.990
these are elements of type food order.

00:07:17.990 --> 00:07:21.365
This means that we can now use the elements within this class.

00:07:21.365 --> 00:07:24.860
So the name or the cost inside the implementation of this comparator.

00:07:24.860 --> 00:07:30.890
So for example, I could say a 0.1m b dot m. And now if I run this now,

00:07:30.890 --> 00:07:34.055
this means that the food entries will be arranged in alphabetical order.

00:07:34.055 --> 00:07:36.200
So it'll be burgers fries than milkshake,

00:07:36.200 --> 00:07:38.330
which it is burgers fries and milkshake.

00:07:38.330 --> 00:07:41.675
As you can see, if I didn't want to use Nim was the basis for the ordering.

00:07:41.675 --> 00:07:43.565
Maybe I wanted to use cost instead.

00:07:43.565 --> 00:07:44.690
I could use an indifferent.

00:07:44.690 --> 00:07:47.390
So I could do a dot cost,

00:07:47.390 --> 00:07:49.760
especially if P dot cost,

00:07:49.760 --> 00:07:55.115
which running this now guesses the food items in increasing order of cost.

00:07:55.115 --> 00:07:58.685
So wanting to five is less than 275, which is less than 399.

00:07:58.685 --> 00:08:00.260
And again, we can switch these.

00:08:00.260 --> 00:08:02.605
We could do B dot, cost it out,

00:08:02.605 --> 00:08:09.515
cost and get the most expensive items first comes between 99 before the MOOC check U235,

00:08:09.515 --> 00:08:12.455
with the fries being the cheapest, The last one 95.

00:08:12.455 --> 00:08:16.010
So that's basically the Groovy spaceship operator in a nutshell.

00:08:16.010 --> 00:08:17.930
And as you can see, it really cuts down on

00:08:17.930 --> 00:08:21.960
the boilerplate code required encoding custom comparators.
