WEBVTT
1
00:00:00.580 --> 00:00:08.710
In this section, we are discussing a question about the difference between all all settle and race

2
00:00:08.710 --> 00:00:10.180
matter of promise.

3
00:00:10.810 --> 00:00:16.420
This question is of asynchronous JavaScript section and there will be four related questions we will

4
00:00:16.420 --> 00:00:17.620
have with this topic.

5
00:00:17.860 --> 00:00:20.410
We have already seen the use of promise object.

6
00:00:21.130 --> 00:00:27.660
We also discussed the result and reject methods which are the most commonly used methods with promises.

7
00:00:27.670 --> 00:00:35.470
Though nowadays we go with async await rather than resolve and reject, which will be the next topic

8
00:00:35.470 --> 00:00:36.360
of our discussion.

9
00:00:36.370 --> 00:00:39.970
But in this section we are discussing about these three methods.

10
00:00:41.230 --> 00:00:43.870
Now let's start with Brummies not all method.

11
00:00:44.560 --> 00:00:50.800
The purpose is when you have multiple promises as input, it should return a single promise.

12
00:00:50.980 --> 00:00:53.650
After all, promises are resolved.

13
00:00:54.220 --> 00:00:56.170
Then you can use the Almighty.

14
00:00:56.620 --> 00:01:03.880
It will be something like this that you have promised one promise to maybe a few more processes, and

15
00:01:04.180 --> 00:01:11.140
each promise gets resolved and then it is passed as a parameter in the Almighty.

16
00:01:11.170 --> 00:01:17.050
So there might be multiple promises which are passed to the Iterable object in the all method.

17
00:01:17.470 --> 00:01:21.550
Now, when I say iterable, it means there can be any iterable object.

18
00:01:21.560 --> 00:01:27.940
But at the moment, or most of the time, we see that there is always an array which contains each promised

19
00:01:27.940 --> 00:01:28.540
reference.

20
00:01:28.600 --> 00:01:32.680
Mostly you see an array as an argument which has promises.

21
00:01:34.360 --> 00:01:36.640
Let's try a simple example to check this.

22
00:01:37.600 --> 00:01:39.820
I will create few promises at the moment.

23
00:01:39.820 --> 00:01:42.940
LCP one is equal to new promise.

24
00:01:44.520 --> 00:01:49.320
Which will have a callback function with two static functions.

25
00:01:50.040 --> 00:01:52.320
Static matters that is resolve and reject.

26
00:01:53.820 --> 00:01:55.710
And let's also put aside time out here.

27
00:01:58.820 --> 00:02:03.380
Which again has a callback function and that gets executed.

28
00:02:03.440 --> 00:02:04.160
Let's after.

29
00:02:05.780 --> 00:02:07.070
2000 milliseconds.

30
00:02:09.590 --> 00:02:14.890
Inside this, I'm just going to say resolved and we are going to pass a message that is promise one.

31
00:02:14.900 --> 00:02:15.410
That's it.

32
00:02:17.440 --> 00:02:19.300
This is one promise we have created.

33
00:02:20.200 --> 00:02:22.960
Now, let me also create two more promises this way.

34
00:02:24.180 --> 00:02:26.760
So there are three promises.

35
00:02:27.880 --> 00:02:31.630
I have B1, B2 and B3.

36
00:02:31.630 --> 00:02:33.370
So these are three objects we have.

37
00:02:36.870 --> 00:02:38.730
Which are handling the promise.

38
00:02:39.960 --> 00:02:40.770
Now, let's see.

39
00:02:41.280 --> 00:02:47.730
You warned that when all these three processes are done, then it should return one promise.

40
00:02:48.030 --> 00:02:50.040
That's where you are going to use the all method.

41
00:02:50.310 --> 00:02:53.760
Let me configure all the promises with the Almighty.

42
00:02:53.860 --> 00:02:55.020
So I say promise?

43
00:02:55.680 --> 00:02:56.490
Not all.

44
00:02:58.560 --> 00:03:00.630
Now here, you're going to pass the dribble.

45
00:03:01.050 --> 00:03:03.030
So right now I'm putting an edit.

46
00:03:03.780 --> 00:03:06.850
And as you see that we have B1, B2 and B3.

47
00:03:06.870 --> 00:03:08.790
These are the three promise references.

48
00:03:09.180 --> 00:03:10.680
So that's what I'm going to pass here.

49
00:03:10.680 --> 00:03:13.670
I'll say B1, B2 and B3.

50
00:03:15.920 --> 00:03:22.520
At the same time, each promise will return a different message as a promise to and promise.

51
00:03:22.520 --> 00:03:22.880
Three.

52
00:03:27.490 --> 00:03:27.820
Now.

53
00:03:27.820 --> 00:03:30.490
I'm going to use the den here.

54
00:03:33.520 --> 00:03:36.350
Which will receive a message here I am going to say.

55
00:03:36.370 --> 00:03:40.270
All the promises are sending messages here through results.

56
00:03:40.270 --> 00:03:42.520
So I'm going to see PR messages.

57
00:03:42.520 --> 00:03:44.890
That is promise messages are something.

58
00:03:44.890 --> 00:03:46.600
Any variable you take doesn't matter.

59
00:03:47.200 --> 00:03:52.180
Now I'm seeing console.log and will display the p r messages variable.

60
00:03:52.300 --> 00:03:53.590
So this is what the code is.

61
00:03:53.860 --> 00:03:57.460
We have the promise one which returns true resolved.

62
00:03:58.120 --> 00:04:00.820
Same is the case with promise two and promise three.

63
00:04:01.120 --> 00:04:03.430
Each promise is returning a different message.

64
00:04:04.520 --> 00:04:06.170
Let's run and see what happens here.

65
00:04:12.910 --> 00:04:15.030
It has waited for 2 seconds.

66
00:04:15.040 --> 00:04:18.269
Each promise anyway, takes 2 seconds only to execute.

67
00:04:18.279 --> 00:04:26.830
And you see that the PR message is now has this value collection that is added of all the values which

68
00:04:26.830 --> 00:04:28.930
was returned by the resolve method.

69
00:04:29.200 --> 00:04:36.310
So here what we have done is that we have taken promised Dart all method which has an iterable inside

70
00:04:36.310 --> 00:04:36.550
it.

71
00:04:36.910 --> 00:04:43.000
Then we are using the then method and we are proceeding with a callback function which gets all the

72
00:04:43.000 --> 00:04:45.160
messages off each promise.

73
00:04:45.190 --> 00:04:48.100
Let's try some modifications in the program.

74
00:04:49.390 --> 00:04:51.040
This B-1, which we have here.

75
00:04:52.580 --> 00:04:54.680
Let me just make this as be two.

76
00:04:56.000 --> 00:04:59.390
And instead of P3, I will say P1.

77
00:04:59.390 --> 00:05:00.980
So I'm changing the sequence.

78
00:05:01.010 --> 00:05:03.740
Now let's run the code and look at the output.

79
00:05:05.640 --> 00:05:09.210
You see that it has promised to promise three and promise one.

80
00:05:09.450 --> 00:05:10.800
This is what the output is.

81
00:05:11.040 --> 00:05:17.820
The reason is you do not have to worry about in which sequence the promise is executed.

82
00:05:17.940 --> 00:05:25.080
It might happen that all of the promises at the moment have 2000 milliseconds, but let's say one promise

83
00:05:25.080 --> 00:05:26.100
may take more time.

84
00:05:26.490 --> 00:05:33.090
But the sequence will be followed in this message variable with reference to the sequence you have mentioned

85
00:05:33.090 --> 00:05:34.110
with the iterable.

86
00:05:34.140 --> 00:05:36.990
Now let's make it B1, B2 again.

87
00:05:38.290 --> 00:05:40.020
And let me show you by changing.

88
00:05:41.080 --> 00:05:43.690
The timing, let's say this parent takes.

89
00:05:45.320 --> 00:05:46.780
4000 milliseconds.

90
00:05:46.790 --> 00:05:52.730
That is after 4 seconds this will be resolved, whereas these two promises will be resolved in just

91
00:05:53.000 --> 00:05:53.750
2 seconds.

92
00:05:53.960 --> 00:06:00.620
So ideally, you might think that this should be the last message, but that won't happen because the

93
00:06:00.650 --> 00:06:05.930
all matter will check in sequence which is mentioned here in this Adi.

94
00:06:06.890 --> 00:06:09.050
Let me save this and run the code again.

95
00:06:14.600 --> 00:06:21.590
So after 4 seconds, you see that the promise one still stays at the same that is at the first place.

96
00:06:22.040 --> 00:06:25.760
So now we know the basic syntax and behavior of all matter.

97
00:06:26.300 --> 00:06:31.820
The code we see right now is returning resolve state in all cases.

98
00:06:32.540 --> 00:06:38.060
Let's try to change one of the promise by returning a reject state and see what happens.

99
00:06:38.660 --> 00:06:42.050
Let me just change this result to reject.

100
00:06:46.470 --> 00:06:50.670
Let me also change this 4000 to 2000 so that it doesn't take more time.

101
00:06:55.140 --> 00:06:55.590
All right.

102
00:06:55.590 --> 00:06:59.810
So now what change I have made is I placed reject.

103
00:06:59.820 --> 00:07:01.680
I replaced resolve with reject.

104
00:07:01.680 --> 00:07:02.100
That is.

105
00:07:03.240 --> 00:07:05.670
Now I just want to run this call.

106
00:07:10.180 --> 00:07:17.380
So after 2 seconds, you are facing an ad, as you can see, that now it has stopped working because

107
00:07:17.380 --> 00:07:23.470
the all matter is settled with only and only result promises.

108
00:07:23.650 --> 00:07:28.810
And if any of the promise is returning error, then it won't work.

109
00:07:29.810 --> 00:07:36.080
Let me also add a catch with the all method, which is a proper way to write the code.

110
00:07:36.350 --> 00:07:39.320
So here I'm going to add a catch.

111
00:07:40.480 --> 00:07:43.210
Which will again have the added object.

112
00:07:44.780 --> 00:07:50.150
Are the measures which we are going to retrieve in this error object and I will simply say console.log.

113
00:07:50.210 --> 00:07:54.070
Let me display whatever is the value in the adder.

114
00:07:54.290 --> 00:07:59.750
Now at the moment reject will raise the error, but this promise value that is promised three will be

115
00:07:59.750 --> 00:08:01.730
passed in this era.

116
00:08:01.880 --> 00:08:02.210
Right.

117
00:08:02.210 --> 00:08:04.580
So when I clear this and run it again.

118
00:08:07.890 --> 00:08:10.980
At least this is the error section displayed for sure.

119
00:08:11.010 --> 00:08:12.300
Let me also add added here.

120
00:08:12.300 --> 00:08:14.430
So you get the right message.

121
00:08:19.940 --> 00:08:20.260
Right.

122
00:08:20.270 --> 00:08:28.400
So if anything, which displays with this ad, it means it actually went in the catch section.

123
00:08:31.250 --> 00:08:34.130
So you see that it displays error promise three.

124
00:08:34.490 --> 00:08:40.480
So in short, when all promises are expected to return success, our results state.

125
00:08:40.490 --> 00:08:42.320
You can use the all method.

126
00:08:43.130 --> 00:08:48.890
But what if you have a possibility of error or rejection, which is equally possible?

127
00:08:49.010 --> 00:08:52.460
Most of the programs will have some or the other error as well.

128
00:08:52.850 --> 00:08:54.470
Now all will stop working.

129
00:08:54.470 --> 00:08:56.830
It will not run for other promises.

130
00:08:56.840 --> 00:09:02.180
It has stopped working for other promises, even if a single promise has returned.

131
00:09:02.270 --> 00:09:07.250
And at the way is that you use the all cycle method.

132
00:09:07.910 --> 00:09:10.880
All settled matter does help in this situation.

133
00:09:10.910 --> 00:09:18.920
It will wait for all the promises, regardless of their state, and will return promise at the end no

134
00:09:18.920 --> 00:09:20.690
matter what is the state.

135
00:09:20.690 --> 00:09:24.440
That is whether it is a result state or rejected or whatever.

136
00:09:24.680 --> 00:09:28.580
It is going to wait and run all the promises one by one.

137
00:09:29.680 --> 00:09:31.450
Let me simply add.

138
00:09:32.170 --> 00:09:33.160
Settle here.

139
00:09:35.070 --> 00:09:35.610
That's it.

140
00:09:36.880 --> 00:09:39.010
Now earlier it was giving the ad it.

141
00:09:39.400 --> 00:09:40.780
Now let's see what happens.

142
00:09:45.660 --> 00:09:49.380
The outputs is that you have added return with some data.

143
00:09:49.380 --> 00:09:53.880
That is a kind of object literally we have which has titles and a value.

144
00:09:53.910 --> 00:09:58.740
So you see there are three object literature, three elements in short fulfil.

145
00:09:58.770 --> 00:10:03.150
The first promise was fulfilled, second was fulfilled with the value.

146
00:10:03.360 --> 00:10:10.650
And here the third one, the status is rejected and the reason is something which our error is displayed

147
00:10:10.650 --> 00:10:12.660
that that will be the reason.

148
00:10:12.900 --> 00:10:17.370
So in short, this is how all settle and all differ.

149
00:10:17.940 --> 00:10:24.900
So the major difference you realize here is that all matter will work when all the promises are returning,

150
00:10:24.900 --> 00:10:25.920
the results state.

151
00:10:26.100 --> 00:10:30.060
That is, rejection will be handled better with all settled.

152
00:10:30.510 --> 00:10:33.630
Now let's talk about the promise, not this method.

153
00:10:33.960 --> 00:10:41.940
This method simply returns a promise as soon as any of the promise returns the state from the iterable

154
00:10:42.030 --> 00:10:42.990
list provided.

155
00:10:43.500 --> 00:10:48.480
Let's change the method also to race and observe the output.

156
00:10:50.860 --> 00:10:51.820
Let me run the court.

157
00:10:55.330 --> 00:10:55.900
That's it.

158
00:10:56.140 --> 00:10:59.800
So it's a kind of race among promises.

159
00:11:00.040 --> 00:11:06.070
Whichever promise was executed first, that is returned with the race method.

160
00:11:06.250 --> 00:11:08.320
So what happens when you have a process?

161
00:11:08.560 --> 00:11:11.120
Let's say you have an API call, right?

162
00:11:11.230 --> 00:11:12.910
Multiple API calls, that is.

163
00:11:13.120 --> 00:11:14.020
And you want that.

164
00:11:14.230 --> 00:11:18.820
If one of the API call is done, you want to come out with a new promise return.

165
00:11:18.970 --> 00:11:23.890
Then instead of writing all or all cycle, you are going to use the restart method.

166
00:11:24.070 --> 00:11:29.410
So here, when you say race matter, it means it is going to race among each promise.

167
00:11:29.590 --> 00:11:32.650
Whichever wins that gets executed.

168
00:11:32.770 --> 00:11:35.410
It means that let's say this promise.

169
00:11:35.410 --> 00:11:35.890
Three.

170
00:11:36.400 --> 00:11:38.440
Let me reduce milliseconds here.

171
00:11:42.740 --> 00:11:48.440
So the promise tree is executed, which was actually rejecting, but then also that got executed.

172
00:11:48.620 --> 00:11:55.550
And because we have written the catch, it got caught in the catch section and it displays promise three

173
00:11:55.550 --> 00:11:55.820
here.

174
00:11:57.550 --> 00:11:59.890
Let's discuss related questions of this topic.

175
00:12:00.220 --> 00:12:07.210
The first question is what will be the output if the iterable is not a promise inside all method arguments?

176
00:12:07.420 --> 00:12:12.460
For example, as shown where B2 is not a promise.

177
00:12:14.020 --> 00:12:18.890
So the answer is that we have be2 as a normal variable.

178
00:12:18.910 --> 00:12:21.160
It's not exactly a promise.

179
00:12:21.460 --> 00:12:24.730
Now that is parsed here in the iterable.

180
00:12:25.030 --> 00:12:26.140
So what happens?

181
00:12:26.770 --> 00:12:28.300
All matter doesn't mind that.

182
00:12:28.300 --> 00:12:30.100
Not necessarily that dimension.

183
00:12:30.100 --> 00:12:32.250
Element is a promise object.

184
00:12:32.260 --> 00:12:39.430
It can be any variable or anything that will automatically be part or a kind of element of this variable

185
00:12:39.430 --> 00:12:40.720
that is PR messages.

186
00:12:41.080 --> 00:12:43.830
Let's save this and try to run and see what is the output.

187
00:12:43.840 --> 00:12:45.790
It's not going to give any added in chart.

188
00:12:47.060 --> 00:12:53.660
You see that the ADI of B of messages does have promise one which was ISR promise three which is again

189
00:12:53.660 --> 00:13:00.740
desired and the p to the value of p two is just a string, which is not a promise that is also becoming

190
00:13:00.740 --> 00:13:01.950
a part of this.

191
00:13:01.950 --> 00:13:03.830
P are messages variable?

192
00:13:04.220 --> 00:13:10.400
Second question is how will you handle rejected multiple promises in the most efficient way?

193
00:13:10.730 --> 00:13:18.200
So we have already discussed that if you are using the all method, then it will work for all the resolved

194
00:13:18.290 --> 00:13:18.920
states.

195
00:13:19.130 --> 00:13:26.150
But if that is a rejection, if there is an error, then you can handle such a situation with all settled

196
00:13:26.150 --> 00:13:26.600
matter.

197
00:13:29.020 --> 00:13:34.120
The third question is explain the purpose of promise, not race matter.

198
00:13:34.450 --> 00:13:41.920
Now we have already seen the syntax and execution, but it returns the promise as soon as any promise

199
00:13:42.130 --> 00:13:45.430
mentioned in the attribute list returns the state.

200
00:13:45.550 --> 00:13:48.730
Now that state can be resolved or reject doesn't matter.

201
00:13:48.880 --> 00:13:54.790
The purpose of race matter is sometimes you have multiple promises and you have a kind of setting where

202
00:13:54.940 --> 00:14:01.300
even if only one promise, whichever it is executed first, if that is executed, you do not want other

203
00:14:01.300 --> 00:14:02.500
promises to execute.

204
00:14:02.510 --> 00:14:06.700
And that's the exact situation where the race matter is useful.

205
00:14:08.970 --> 00:14:16.980
What will be the output of empty iterable if given as a parameter inside the race method as shown in

206
00:14:16.980 --> 00:14:17.510
the score?

207
00:14:17.760 --> 00:14:23.070
So race method is given an empty array, then the state will be pending.

208
00:14:23.070 --> 00:14:27.420
So this promise, not race, will always return a pending state.

209
00:14:27.450 --> 00:14:29.550
So this promise will never be resolved.

210
00:14:29.790 --> 00:14:30.630
Let's try that.

211
00:14:30.750 --> 00:14:32.970
I have this object that is the object.

212
00:14:33.300 --> 00:14:36.870
Now, if I display the object here, it should display the pending state.

213
00:14:37.230 --> 00:14:42.390
And even after 2 seconds, if I display the value that's going to be pending, right?

214
00:14:42.390 --> 00:14:48.750
So if that is an empty treble, then it will be pending forever in case of race method.

215
00:14:48.750 --> 00:14:52.710
So let me just run the code pending again.

216
00:14:52.710 --> 00:14:53.670
Pending, right.

217
00:14:54.000 --> 00:14:55.650
When will this situation happen?

218
00:14:56.400 --> 00:15:02.610
This is the promise which you are having that might be generated dynamically and let's say no values

219
00:15:02.610 --> 00:15:03.120
returned.

220
00:15:03.330 --> 00:15:05.130
So race will have empty array.

221
00:15:05.130 --> 00:15:08.070
Sometimes such cases will have pending state.

222
00:15:08.070 --> 00:15:10.140
But this is just a behavior which I am talking.

223
00:15:10.140 --> 00:15:11.790
That's why I have raised this question here.

224
00:15:12.030 --> 00:15:14.790
So in charge it will be pending forever.

