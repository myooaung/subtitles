WEBVTT
1
00:00:01.520 --> 00:00:07.670
In this section we are going to discuss about quantifier used with regular expressions.

2
00:00:10.070 --> 00:00:13.640
As the name speaks, it is about quantity.

3
00:00:13.670 --> 00:00:19.040
Without discussing the jargons, let's jump into the practical examples.

4
00:00:19.910 --> 00:00:23.360
The first quantifier is an asterisk.

5
00:00:24.140 --> 00:00:27.110
It means zero or more times.

6
00:00:27.110 --> 00:00:36.410
That is, if the pattern given is as star, then it returns all the characters in string with zero or

7
00:00:36.410 --> 00:00:37.680
more matches.

8
00:00:37.700 --> 00:00:41.240
Let's try it practically and then try to understand the output.

9
00:00:41.270 --> 00:00:45.920
I'm going to declare a variable and say select str is equal to.

10
00:00:46.430 --> 00:00:52.940
Now I have this and for this is I'm going to say more s characters.

11
00:00:53.580 --> 00:00:55.380
So this is a trial string.

12
00:00:55.680 --> 00:01:00.000
Now, let's create a pattern where I'll just say s and star.

13
00:01:00.810 --> 00:01:09.960
Now, if I run this, as I have mentioned, that it matches zero or more times, that means if S is

14
00:01:10.230 --> 00:01:15.630
not existing for each character in the string, then also it is return.

15
00:01:16.080 --> 00:01:20.550
And if s is existing then also it returns.

16
00:01:20.550 --> 00:01:22.680
So it is zero or more time.

17
00:01:22.680 --> 00:01:27.360
So now you see that for each character in the string that is a blank space.

18
00:01:27.360 --> 00:01:30.180
Or maybe character s is returned.

19
00:01:30.210 --> 00:01:34.650
Of course, here you see that there are three S characters returned.

20
00:01:35.530 --> 00:01:43.570
Now let's change the pattern as star and add one more character I before se and run the code.

21
00:01:49.040 --> 00:01:57.860
Now the output explains that the pattern searches for is word, but character as can be zero or more

22
00:01:57.860 --> 00:01:58.640
times.

23
00:01:59.120 --> 00:02:06.680
And that is why AI is also returned, because in the last two values there is no character as existing.

24
00:02:06.680 --> 00:02:08.330
That means it is zero times.

25
00:02:08.330 --> 00:02:17.480
So first it exists one time in the second output value it is three times, and for third and fourth

26
00:02:17.510 --> 00:02:19.460
it is zero times.

27
00:02:19.880 --> 00:02:23.390
So this is the use of the asterisk quantifier.

28
00:02:23.960 --> 00:02:27.620
The next quantifier we are going to discuss is a plus sign.

29
00:02:28.470 --> 00:02:33.900
Plus sign searches for one or more occurrences of the given criteria.

30
00:02:34.200 --> 00:02:41.160
So in the previous example, let's replace the asterisk with a plus sign and discuss the output.

31
00:02:44.290 --> 00:02:53.800
So now it searches for a string, starting with a character I and X plus means at least one or more

32
00:02:53.800 --> 00:02:55.720
occurrences of character.

33
00:02:55.720 --> 00:03:03.370
SE And that is why we get both is where there is one s and I.

34
00:03:03.380 --> 00:03:08.170
S s where it has more than one se character.

35
00:03:08.320 --> 00:03:14.810
So plus for one or more occurrence, asterisk is zero or more occurrence.

36
00:03:14.830 --> 00:03:18.490
Similarly, we have the next quantifier.

37
00:03:18.490 --> 00:03:20.260
That is the question mark.

38
00:03:20.350 --> 00:03:27.490
This sign searches for zero or one occurrences of given criteria.

39
00:03:27.820 --> 00:03:34.060
Let's change the plus sign to question mark in the same coding and see the output.

40
00:03:35.860 --> 00:03:44.710
So now it searches for a string, starting with a character I and SW means zero or one occurrences of

41
00:03:44.710 --> 00:03:45.550
character.

42
00:03:45.550 --> 00:03:52.480
SW And that is why we get is two times where there is an occurrence of character.

43
00:03:52.480 --> 00:03:58.430
SW And I also two times as there is zero occurrence of character.

44
00:03:58.450 --> 00:03:59.080
SW.

45
00:03:59.850 --> 00:04:03.090
Let's try one more example to get a better idea.

46
00:04:03.720 --> 00:04:12.930
I'm going to create a string which has hello and h l a So now the pattern searches for etch followed

47
00:04:12.930 --> 00:04:15.480
by zero or one e.

48
00:04:15.570 --> 00:04:16.800
So you get both.

49
00:04:16.800 --> 00:04:17.310
Hello.

50
00:04:17.310 --> 00:04:23.340
Where there is one E and etch A where there is zero e.

51
00:04:23.730 --> 00:04:26.910
I have used W plus here, which is a character class.

52
00:04:26.910 --> 00:04:28.410
So not to worry about it.

53
00:04:28.410 --> 00:04:30.210
We are going to see that in detail.

54
00:04:30.210 --> 00:04:35.310
But at the moment you need to focus on the concept of the question mark.

55
00:04:39.000 --> 00:04:41.340
Let's move to the next quantifier now.

56
00:04:41.370 --> 00:04:45.750
It's about giving a character with curly brackets and a number of characters.

57
00:04:46.750 --> 00:04:52.930
So this quantifier will search for character, which occurs end times in a string.

58
00:04:53.380 --> 00:04:55.510
Let's take a very simple example.

59
00:04:55.540 --> 00:04:57.310
I'll select str.

60
00:04:57.490 --> 00:04:58.300
Hello.

61
00:04:58.720 --> 00:05:02.380
And second time I give only one l.

62
00:05:02.560 --> 00:05:09.910
Now the pattern I'm going to create is that I want to search for word Hello in the string where there

63
00:05:09.910 --> 00:05:16.480
is h e l Now I want that l should be two times then only that word should be return.

64
00:05:16.600 --> 00:05:24.490
So I say curly brackets two and oh, of course the global search also given.

65
00:05:25.000 --> 00:05:31.140
Let's try to run the match matter on it and run the code when L two is mentioned.

66
00:05:31.150 --> 00:05:36.970
It means if there are two ls in the string then only it will return.

67
00:05:37.060 --> 00:05:43.540
In short, you are giving number of occurrences in curly brackets with the same curly bracket.

68
00:05:43.570 --> 00:05:48.460
You can also give a range as well, which is our next topic.

69
00:05:49.030 --> 00:05:52.500
It is also possible to use range with this quantifier.

70
00:05:52.510 --> 00:05:57.640
For example, I want to search for 2 to 4 L characters.

71
00:05:57.850 --> 00:06:02.110
In that case, you can give the range with this syntax.

72
00:06:02.110 --> 00:06:08.020
You can say curly brackets to come up for that means two, three or four.

73
00:06:08.260 --> 00:06:10.000
Let's practically try it.

74
00:06:10.510 --> 00:06:14.830
I will use the Hello world with different number of LS.

75
00:06:15.850 --> 00:06:18.220
Now what I will do is inside the pattern.

76
00:06:18.220 --> 00:06:20.050
I'm going to say h e l.

77
00:06:20.080 --> 00:06:26.560
Now what I want is that it should return all the words which have two, three or four.

78
00:06:26.590 --> 00:06:29.690
That is 2 to 4 ls is okay.

79
00:06:29.710 --> 00:06:33.520
And then, of course, we try to run the match method.

80
00:06:35.910 --> 00:06:37.410
Let's execute the code.

81
00:06:38.460 --> 00:06:47.460
So now you get all the hellos where there are two, three or four L's and words where there is one or

82
00:06:47.460 --> 00:06:51.540
five else that is less than two or more than four.

83
00:06:51.570 --> 00:06:54.780
Then those words are not in the output list.

84
00:06:55.750 --> 00:07:03.130
Now let's try to find All Hallows where there are three or more L's in the previous example we have

85
00:07:03.130 --> 00:07:06.220
given to come up for that means 2 to 4.

86
00:07:06.250 --> 00:07:08.140
That was the range which we gave.

87
00:07:08.530 --> 00:07:17.740
But in case if you want words where there are three or more L characters, then we can avoid the value

88
00:07:17.740 --> 00:07:20.850
which we mentioned after comma in previous example.

89
00:07:20.860 --> 00:07:27.520
So now let's write the string with different number of LS in the Hello world and we create the pattern

90
00:07:27.520 --> 00:07:34.400
where I'll say h e not a problem, but l I just want three that is more than three.

91
00:07:34.420 --> 00:07:37.210
The second value after comma, we keep empty.

92
00:07:37.210 --> 00:07:38.470
We don't give that value.

93
00:07:38.470 --> 00:07:43.900
So this means all the hellos with more than three words will be retrieved.

94
00:07:44.590 --> 00:07:46.150
Let's try to run the code.

95
00:07:48.160 --> 00:07:54.760
As you can see that now we have all the values where L is three or more times occurring.

