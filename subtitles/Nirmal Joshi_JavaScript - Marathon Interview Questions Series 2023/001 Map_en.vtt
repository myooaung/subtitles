WEBVTT
1
00:00:00.060 --> 00:00:03.930
So this topic is discussing about the map and related questions.

2
00:00:04.650 --> 00:00:07.380
There are six related questions to this topic.

3
00:00:08.770 --> 00:00:11.980
Any programming language has various data structures.

4
00:00:12.610 --> 00:00:18.730
In JavaScript, we have arrays and object literals, which are very powerful and commonly used data

5
00:00:18.730 --> 00:00:19.390
structures.

6
00:00:19.960 --> 00:00:25.900
But in E6 there are few more data structures introduced and they are map.

7
00:00:26.320 --> 00:00:29.020
Weak, map set and weak said.

8
00:00:29.680 --> 00:00:34.660
In this section we are discussing the map data structure in object literal.

9
00:00:34.690 --> 00:00:36.910
We have key and data values.

10
00:00:37.840 --> 00:00:46.750
MAP is also similar, but in case of map, the keys can also have types like string number, boolean,

11
00:00:46.750 --> 00:00:47.380
etc..

12
00:00:48.130 --> 00:00:53.740
In fact, this is the collection or data structure where you are mapping value to value.

13
00:00:54.520 --> 00:00:59.290
Also, values inserted in map collection are retrieved in the same order.

14
00:01:00.100 --> 00:01:06.220
There are other good features of map, but at the moment, without wasting any time in discussion,

15
00:01:06.580 --> 00:01:08.290
let's jump into an example.

16
00:01:08.800 --> 00:01:11.860
To create a map, we use the map constructor.

17
00:01:11.950 --> 00:01:16.540
So, for example, I'll say LED product is equal to new map.

18
00:01:17.410 --> 00:01:21.460
Now comes the time where you have to assign the key and value.

19
00:01:21.670 --> 00:01:27.460
And as I mentioned in the beginning, that you can have different types of key as well.

20
00:01:28.030 --> 00:01:34.330
Let me show you that there is a method called set method which allows you to assign key and value.

21
00:01:34.330 --> 00:01:36.310
So I'll say product dot set.

22
00:01:36.490 --> 00:01:40.390
Say, for example, product code, which I want to make a string key.

23
00:01:40.390 --> 00:01:44.710
So I'll put in single quotes and the value, for example, is 1001.

24
00:01:45.280 --> 00:01:48.340
Now let's try a few more data types.

25
00:01:48.430 --> 00:01:55.150
Let's say I just want to give a number one and I'll say Apple, though this value doesn't make much

26
00:01:55.150 --> 00:02:00.810
sense at the moment, but we are trying to understand how the various types of keys we can assign.

27
00:02:00.820 --> 00:02:03.100
So I'm going to add one more example.

28
00:02:03.100 --> 00:02:08.020
In that case, I'll say just true and for example, available something like this.

29
00:02:08.470 --> 00:02:12.550
So this is a map we have created which has three key value pairs.

30
00:02:13.060 --> 00:02:17.710
Now, let me just straight away display the value of the product map.

31
00:02:17.710 --> 00:02:19.900
So I'll say product, let's run the code.

32
00:02:19.960 --> 00:02:21.730
I'll say node mapped out.

33
00:02:21.730 --> 00:02:22.240
Yes.

34
00:02:22.900 --> 00:02:29.090
Now you see that the keys which are displayed, not all the keys are in code like because is in quotes.

35
00:02:29.110 --> 00:02:32.920
One is as it is and true, which is a boolean value is also as it is.

36
00:02:33.670 --> 00:02:37.360
So this in a way shows that the types are maintained.

37
00:02:38.140 --> 00:02:43.540
Now this key and value which you see this key can be value itself.

38
00:02:43.720 --> 00:02:45.310
It is in fact a value.

39
00:02:45.760 --> 00:02:48.130
It is a value to value mapping as well.

40
00:02:48.640 --> 00:02:55.360
Now, let's also try to get a specific value in case if you want to, let's say, find a key which is

41
00:02:56.110 --> 00:02:56.980
named one.

42
00:02:57.220 --> 00:03:05.830
So I can say here product dot get this get is the method which allows you to find a specific value by

43
00:03:05.830 --> 00:03:07.060
giving a key only.

44
00:03:07.390 --> 00:03:08.860
So let me run this again.

45
00:03:09.850 --> 00:03:17.050
Now you see that it displays Apple here because the key of Apple is when in fact we can try this with

46
00:03:17.200 --> 00:03:17.500
true.

47
00:03:17.500 --> 00:03:18.700
Also, I'll say true.

48
00:03:20.260 --> 00:03:21.520
Again, let's run this.

49
00:03:23.320 --> 00:03:25.390
You see this it displays available.

50
00:03:26.200 --> 00:03:31.030
There is also one more useful property with map which we don't have with object later.

51
00:03:31.030 --> 00:03:33.100
And that is the size property.

52
00:03:33.730 --> 00:03:37.510
Size property actually returns the count of key value pair.

53
00:03:37.990 --> 00:03:45.670
So let's say instead of get at the moment, I'll simply say size and you see that it displays three.

54
00:03:45.670 --> 00:03:50.210
That means there are three key value pair, so it returns account with array.

55
00:03:50.230 --> 00:03:54.070
We have length property, but with object literals we do not have anything.

56
00:03:54.070 --> 00:03:59.470
We can write the coding but we don't have any direct property to get the size which we have with the

57
00:03:59.500 --> 00:04:07.330
map collection, the way we have used the set method to assign a value because map is also a data structure.

58
00:04:07.690 --> 00:04:09.280
We also have another way.

59
00:04:09.310 --> 00:04:13.840
Let's say, for example, instead of set method, I can say product.

60
00:04:14.110 --> 00:04:18.040
Then I'll put the scribe records, which we can do with object literal.

61
00:04:18.279 --> 00:04:23.350
Here I can say price for example, and I say 300 right now.

62
00:04:23.350 --> 00:04:25.600
Let me just display the product itself.

63
00:04:28.980 --> 00:04:31.230
I'll say execute it.

64
00:04:31.830 --> 00:04:37.660
Now you see that the collection we have here, it has product called one true and price as well.

65
00:04:37.680 --> 00:04:40.970
So we have added price in the collection for short.

66
00:04:40.980 --> 00:04:44.290
But this way is not a very preferable way.

67
00:04:44.310 --> 00:04:51.870
And the reason is when you give a key like this, it actually behaves like a key of object literal.

68
00:04:52.230 --> 00:04:54.840
So here the type will not be maintained.

69
00:04:55.050 --> 00:05:00.590
So the unique way of map where Key has its own type, that will not be applied in this case.

70
00:05:00.600 --> 00:05:04.470
So ideally, when it comes to assigning value, that is key and value.

71
00:05:04.620 --> 00:05:07.370
We don't go with this way, this syntax.

72
00:05:07.380 --> 00:05:10.560
Instead, we prefer to go with the set method only.

73
00:05:11.460 --> 00:05:17.700
So coming to the set method set is one of the method which returns the map as well.

74
00:05:18.210 --> 00:05:20.880
Like when you say product dot set, it returns a map.

75
00:05:21.240 --> 00:05:23.550
Every product dot said returns a map.

76
00:05:23.850 --> 00:05:27.870
And if it returns a map, that means you can further change it.

77
00:05:27.990 --> 00:05:34.260
So instead of writing this way, let me remove all these semicolons and also I'm removing the product,

78
00:05:35.190 --> 00:05:35.520
right?

79
00:05:35.730 --> 00:05:38.190
So now this becomes a changing syntax, isn't it?

80
00:05:38.550 --> 00:05:39.120
Like this?

81
00:05:39.930 --> 00:05:42.990
This is also a valid way of creating a map.

82
00:05:43.170 --> 00:05:45.210
So you don't write the product.

83
00:05:45.210 --> 00:05:51.840
That is the map name all the times with this method, because set method returns the map itself.

84
00:05:52.110 --> 00:05:53.700
So further, you can change it.

85
00:05:54.030 --> 00:05:57.990
Let me run the code and see that it is working absolutely fine.

86
00:05:58.710 --> 00:06:03.330
Another excellent advantage of map over object or a simple object.

87
00:06:03.340 --> 00:06:04.830
But you can say object literal.

88
00:06:05.190 --> 00:06:07.260
Is that map is it rebel?

89
00:06:07.710 --> 00:06:13.440
We have already seen with it returns concept that we were not able to iterate through object literals

90
00:06:13.440 --> 00:06:15.870
right then we had to use it returns for that.

91
00:06:15.990 --> 00:06:18.750
But map is something which is already iterable.

92
00:06:19.170 --> 00:06:22.170
It means we can loop through the map collection.

93
00:06:22.650 --> 00:06:27.600
There are three methods we can use while implementing the iterations over the map.

94
00:06:28.730 --> 00:06:33.560
These three matters are values guys these and Andres.

95
00:06:34.250 --> 00:06:37.010
Let's try all the matters now here practically.

96
00:06:37.550 --> 00:06:44.210
I'm going to use the follow up where I'll say, for example, first thing we are trying is the values

97
00:06:44.420 --> 00:06:44.880
method.

98
00:06:44.910 --> 00:06:50.840
So I'll say V, for example, let V of product, not values.

99
00:06:50.840 --> 00:06:54.500
Values is the matter which is going to return all the values.

100
00:06:54.500 --> 00:07:00.290
And one by one let's try to display also which will be inside.

101
00:07:00.290 --> 00:07:04.340
V Now I'll just clear this and I done it.

102
00:07:05.000 --> 00:07:08.060
So now you see that 1001 apple and available.

103
00:07:08.060 --> 00:07:14.450
These are the three values we have here so values helps you to loop through all the values of man now

104
00:07:14.450 --> 00:07:15.470
instead of values.

105
00:07:15.980 --> 00:07:24.380
If I just see, for example, keys right now, it doesn't matter whether I give or K, but for better

106
00:07:24.380 --> 00:07:27.170
naming conventions I will use K here.

107
00:07:29.970 --> 00:07:30.990
I'm running the court.

108
00:07:31.260 --> 00:07:31.980
You see this?

109
00:07:32.100 --> 00:07:36.510
It has loop through the entire collection and displayed all the keys.

110
00:07:36.780 --> 00:07:38.790
So we have seen values and keys.

111
00:07:39.540 --> 00:07:41.880
The next matter is the entries matter.

112
00:07:41.910 --> 00:07:47.310
Now, this is one of the very useful matters because it returns both keys and values.

113
00:07:47.940 --> 00:07:55.440
Now, for example, instead of Celtic E as a variable and I'll try to display E, let's do this first.

114
00:07:56.370 --> 00:07:59.490
Now you see that we have the entire collection.

115
00:07:59.850 --> 00:08:02.950
Each value pair you see is displayed as an added.

116
00:08:02.970 --> 00:08:04.070
That is the advantage.

117
00:08:04.080 --> 00:08:07.830
The reason is you can directly d structure these values.

118
00:08:07.830 --> 00:08:15.030
Let's say for example, with LED, I can directly put and add a here where I'll see the first value

119
00:08:15.030 --> 00:08:16.770
returned in this ad.

120
00:08:16.770 --> 00:08:19.080
It is key and then we have value, right?

121
00:08:19.080 --> 00:08:23.490
So here I can see let me take key first and the value second.

122
00:08:24.180 --> 00:08:27.420
So now we have both K and V, I have removed E now.

123
00:08:27.420 --> 00:08:34.020
So here also l display key and we only key and we that's it, right?

124
00:08:34.380 --> 00:08:37.799
In fact, if I want I can put a comma also in between while displaying.

125
00:08:37.799 --> 00:08:42.570
So I'll say I'll use the template literals that is the E6 index.

126
00:08:42.840 --> 00:08:51.030
So it's a dollar I want to display key that will be, let's say, a dash and then I want the value.

127
00:08:51.030 --> 00:08:54.060
We save it and run the code.

128
00:08:55.020 --> 00:08:58.440
So now we see that we have a key value separated with a dash.

129
00:08:59.100 --> 00:09:05.190
So you get this idea that entries is the method which returns both key and value, which you can de

130
00:09:05.190 --> 00:09:07.680
structure like this within the for loop itself.

131
00:09:08.500 --> 00:09:16.090
Now as the map has entries mattered just for the information that we already have an object called capital

132
00:09:16.090 --> 00:09:19.930
or object in JavaScript, which also has entries matter.

133
00:09:19.960 --> 00:09:25.240
Now this is a matter which can be used to convert map into simple object.

134
00:09:25.630 --> 00:09:26.440
Let's try that.

135
00:09:26.590 --> 00:09:28.810
I'll just remove this code at the moment.

136
00:09:29.230 --> 00:09:30.970
Let's say I create object literal.

137
00:09:31.720 --> 00:09:35.020
Here I'll say product code 1001.

138
00:09:36.220 --> 00:09:39.640
Then product name maybe orange.

139
00:09:41.160 --> 00:09:43.950
And let's say price, I'll say 56.

140
00:09:44.880 --> 00:09:47.940
First of all, let's try the object's start entries method.

141
00:09:48.270 --> 00:09:52.410
So I'll say object date entries.

142
00:09:52.770 --> 00:09:56.970
Now what we want in the entries method is I'm going to pass this object.

143
00:09:57.000 --> 00:09:57.450
That's it.

144
00:09:57.480 --> 00:09:58.140
Nothing else.

145
00:10:00.060 --> 00:10:01.230
Now let's run the code.

146
00:10:02.520 --> 00:10:07.950
If you see the output here, the object is converted into Adi.

147
00:10:08.190 --> 00:10:08.670
Where?

148
00:10:08.670 --> 00:10:10.040
That is a sub Adi.

149
00:10:10.170 --> 00:10:10.460
Right.

150
00:10:10.530 --> 00:10:13.410
Which has both key and value mentioned here.

151
00:10:13.890 --> 00:10:18.750
So object node entries convert this object into simple ADI in a way.

152
00:10:19.320 --> 00:10:27.000
Now that Adi, if I pass in the constructor of map method, then this value collection will be converted

153
00:10:27.000 --> 00:10:28.440
into map itself.

154
00:10:28.680 --> 00:10:32.220
Let's try that instead of console.log and remove this.

155
00:10:32.430 --> 00:10:35.490
I'll say for example, let product.

156
00:10:36.670 --> 00:10:43.600
That is the map which we want to create where I'm going to use the constructor and inside the constructor

157
00:10:43.600 --> 00:10:49.810
I'm going to pass object order entries or so whatever is returned by these entries method, which is

158
00:10:49.810 --> 00:10:51.480
going to be this only right.

159
00:10:51.490 --> 00:10:54.340
This output will be part of product.

160
00:10:54.370 --> 00:10:56.800
Now let's display the product itself.

161
00:10:56.800 --> 00:10:57.490
That is the map.

162
00:10:58.000 --> 00:10:58.990
So I'll say product.

163
00:11:01.880 --> 00:11:03.320
Now let's run the court.

164
00:11:05.120 --> 00:11:12.830
So now we have this as a map that is the object literally converted into a map that is also object art

165
00:11:13.100 --> 00:11:15.920
from entities matter which can do reverse.

166
00:11:16.400 --> 00:11:19.490
A map can be converted into a simple object also.

167
00:11:20.150 --> 00:11:20.960
Let's do that.

168
00:11:21.140 --> 00:11:22.760
I'll create a map very quickly.

169
00:11:23.060 --> 00:11:27.920
I'll select product is equal to new map.

170
00:11:29.000 --> 00:11:31.880
Then I'll say product dot set.

171
00:11:32.240 --> 00:11:34.430
Product code 1001.

172
00:11:34.580 --> 00:11:40.490
Now I want to use that chaining though I can continue this way, but let me put it on a new line.

173
00:11:40.820 --> 00:11:46.220
So I'll say product name, orange and set.

174
00:11:47.360 --> 00:11:49.970
Let's say price 56.

175
00:11:51.270 --> 00:11:54.020
Now I want to convert this map into simple objects.

176
00:11:54.040 --> 00:11:55.200
I'll create the object.

177
00:11:55.410 --> 00:11:59.940
And here I'm going to use the from entries method.

178
00:12:00.990 --> 00:12:04.650
Here I'm going to pass product dot entries.

179
00:12:04.680 --> 00:12:11.280
Now we have already seen that entries will return the added values and that will be converted into the

180
00:12:11.280 --> 00:12:11.670
object.

181
00:12:11.670 --> 00:12:15.030
So now if I display the value of object.

182
00:12:20.170 --> 00:12:23.230
Then it gives you the object later, this one.

183
00:12:24.070 --> 00:12:30.820
So in short, object, not entries in object not from entries are very useful sometimes with map when

184
00:12:30.820 --> 00:12:34.960
you want to convert map to simple object or simple object to map.

185
00:12:35.880 --> 00:12:39.180
There is also one more matter called map dot has.

186
00:12:39.750 --> 00:12:46.050
Now this has method takes a key and it checks whether the given key is existing in the map or not.

187
00:12:46.560 --> 00:12:53.670
It's a very simple matter, but let's try once I'll say console.log and here I'm going to say product,

188
00:12:54.180 --> 00:12:56.460
which is a map I want to check.

189
00:12:56.460 --> 00:12:59.940
Does it have a quick or product code or not?

190
00:13:00.270 --> 00:13:03.810
Now, if there is no key, no such key, it's going to return false.

191
00:13:03.810 --> 00:13:07.290
But because we have it here, it returns true.

192
00:13:08.510 --> 00:13:16.420
As long as iteration of MAP is concerned, we can also use the for each which we have with map as well.

193
00:13:16.430 --> 00:13:22.310
We have already seen for each with Addy, but we can use for each with map as well.

194
00:13:22.790 --> 00:13:24.440
Let's quickly try that.

195
00:13:24.440 --> 00:13:30.230
Also, the syntax is very similar for for each it does take a callback function.

196
00:13:30.230 --> 00:13:35.870
So I'm going to write a callback function here and it takes the same parameters.

197
00:13:35.870 --> 00:13:43.190
It does take the value, the key and you must have observed with added that it takes add to here, but

198
00:13:43.190 --> 00:13:44.570
here it takes the maps.

199
00:13:44.570 --> 00:13:46.040
I can just write am here.

200
00:13:46.370 --> 00:13:48.920
So it is the reference of this map itself.

201
00:13:49.460 --> 00:13:52.490
Now here I'll display console.log.

202
00:13:53.060 --> 00:13:54.590
Let's display all the value.

203
00:13:54.600 --> 00:13:57.730
So I'll say V, I want to display one.

204
00:13:57.740 --> 00:14:02.540
We have a dash in between and then I'll put the key.

205
00:14:03.470 --> 00:14:08.240
So both key and value here, value and key in fact that will be displayed.

206
00:14:08.240 --> 00:14:15.260
So let's run and you see the output here so far each is one of the way to iterate through, but you

207
00:14:15.260 --> 00:14:20.390
must remember that for each is something which cannot be broken in between.

208
00:14:20.390 --> 00:14:22.820
It has to finish the entire iteration.

209
00:14:23.830 --> 00:14:26.560
There are also ways to remove items from the map.

210
00:14:26.980 --> 00:14:33.670
The delete matter removes values by key and the player method wipes out everything from the map collection.

211
00:14:34.010 --> 00:14:36.130
Let's quickly go through the example.

212
00:14:36.520 --> 00:14:42.310
Here is a code where I have speaker P name and price and I'm displaying the entire map collection.

213
00:14:42.370 --> 00:14:44.770
Now I will simply write product or delete.

214
00:14:45.310 --> 00:14:47.250
Here you have to specify the key.

215
00:14:47.260 --> 00:14:53.350
So for example, I just want to remove P name and after the deletion also I'm just trying to display

216
00:14:53.350 --> 00:14:55.630
the value of map itself.

217
00:14:56.110 --> 00:14:57.040
Let's run the code.

218
00:14:57.340 --> 00:14:58.630
I'll increase the size.

219
00:14:59.080 --> 00:15:04.870
So as you see that in the first line, the p name is existing and in this section it doesn't exist.

220
00:15:05.170 --> 00:15:08.020
So delete is something which removes a specific key.

221
00:15:08.350 --> 00:15:14.650
But now in case if you just try the clear method here instead of delete, then you do not need to give

222
00:15:14.650 --> 00:15:15.550
any key here.

223
00:15:15.730 --> 00:15:17.170
It just clears everything.

224
00:15:17.530 --> 00:15:18.460
Let's run the code.

225
00:15:20.680 --> 00:15:24.100
So now you see that the map collection earlier has values in it.

226
00:15:24.100 --> 00:15:26.620
That is the second doesn't have any value in it.

227
00:15:26.740 --> 00:15:29.320
Now let's discuss related questions of this topic.

228
00:15:29.740 --> 00:15:35.260
The first question is What are the advantages of using MAP over simple objects?

229
00:15:36.130 --> 00:15:40.840
The first thing is that maps, keys can also be values.

230
00:15:41.740 --> 00:15:46.150
They can be of any data type, which we saw in the beginning of this section.

231
00:15:48.200 --> 00:15:52.130
Whereas in case of objects we have keys as strings.

232
00:15:52.460 --> 00:15:58.220
Though in your JavaScript we also have symbols which we can use as key, but it has a limitation.

233
00:15:58.220 --> 00:16:02.000
Whereas in map you can have keys with data types.

234
00:16:02.000 --> 00:16:06.830
Ordinary value to value mapping is also possible, which doesn't happen with objects.

235
00:16:07.580 --> 00:16:10.790
Second point is that keys are ordered in map.

236
00:16:11.450 --> 00:16:18.080
The insertion and retrieval is always in the same order, whereas keys in objects are not ordered.

237
00:16:18.710 --> 00:16:25.760
Map has size property which returns number of key value pairs, whereas object doesn't have any direct

238
00:16:25.760 --> 00:16:25.990
way.

239
00:16:26.000 --> 00:16:29.570
You need to write the code to get the count of key value pairs.

240
00:16:30.230 --> 00:16:35.360
And the most important that maps are iterable and object is actually not.

241
00:16:35.960 --> 00:16:38.060
Apart from this, there is one more point.

242
00:16:38.090 --> 00:16:42.680
Map is quite optimized for data manipulation compared to objects.

243
00:16:42.680 --> 00:16:49.070
That means the insertion, the deletion, more insertion and more deletion if you have map performs

244
00:16:49.070 --> 00:16:50.570
better than the objects.

245
00:16:51.500 --> 00:16:54.530
The second question is how will you iterate through map?

246
00:16:55.040 --> 00:17:02.180
Now we have already seen that we have values, we have keys and we have entries method, right, that

247
00:17:02.180 --> 00:17:07.339
we can use and we use the for all to loop through the entire map collection.

248
00:17:07.819 --> 00:17:14.810
These methods are useful when we have the iteration over map and of course we can use the for each as

249
00:17:14.810 --> 00:17:18.589
well, which allows you to look through the map collection easily.

250
00:17:19.190 --> 00:17:23.420
The third question is can you assign key values with this index?

251
00:17:24.569 --> 00:17:26.369
Explain the reason for the answer.

252
00:17:26.790 --> 00:17:30.660
Well, writing this way is not that is going to give any added.

253
00:17:31.050 --> 00:17:37.920
But the point is it will behave like a normal or a simple object where your keys become strings only.

254
00:17:37.920 --> 00:17:43.230
So the charm of map, where you have keys with various data types, that won't happen.

255
00:17:43.230 --> 00:17:46.620
So this is a wrong way to assign a key to map.

256
00:17:47.220 --> 00:17:51.390
The first question is how can you convert simple objects to map?

257
00:17:51.960 --> 00:17:54.150
So this is the code which we have already tried.

258
00:17:54.600 --> 00:18:00.570
We are using the object or entries method along with this to convert simple objects to map.

259
00:18:01.990 --> 00:18:06.340
And the fifth question is how can you convert a map into simple objects?

260
00:18:06.850 --> 00:18:13.510
So here is the code we use the from entries method, and then we convert the added values to object.

261
00:18:13.930 --> 00:18:20.110
And the sixth question is how will you remove an item or all items from a map collection?

262
00:18:20.290 --> 00:18:27.280
So we have seen that either we use this delete method and give a key like this, or we can give the

263
00:18:27.280 --> 00:18:30.790
clear method which will remove all the items from the map.

