WEBVTT
1
00:00:00.060 --> 00:00:02.850
This question is about searching an element in an ad.

2
00:00:03.330 --> 00:00:08.070
The question is how do you perform search operation in an ad?

3
00:00:08.580 --> 00:00:14.850
The category is, of course, ads, and there will be fire related questions about searching elements

4
00:00:14.850 --> 00:00:17.640
in ad searching elements in an ad.

5
00:00:17.640 --> 00:00:19.740
It is a very common task in programming.

6
00:00:20.130 --> 00:00:23.250
JavaScript gives various methods to perform search.

7
00:00:23.580 --> 00:00:31.710
We will begin with three methods index of last index of and includes the syntax of index of is like

8
00:00:31.710 --> 00:00:32.070
this.

9
00:00:32.340 --> 00:00:36.960
That is an A name you specify and you apply the index of method.

10
00:00:36.990 --> 00:00:38.460
It takes two parameters.

11
00:00:38.610 --> 00:00:40.830
The first is search element.

12
00:00:40.830 --> 00:00:44.630
That is the element you want to search or the value you want to search.

13
00:00:44.640 --> 00:00:49.500
And the start index is optional, which denotes the beginning index.

14
00:00:49.890 --> 00:00:55.020
If it is given zero, it will search from the beginning, but default is zero.

15
00:00:55.050 --> 00:00:59.480
So you don't need to specify if you want to search in the entirety.

16
00:00:59.970 --> 00:01:03.990
This method returns index number where the item is found.

17
00:01:04.560 --> 00:01:09.450
If search element does not exist in the array, then it will return minus one.

18
00:01:09.570 --> 00:01:15.060
And if there are more than one matches found, it will return the index of the first item found.

19
00:01:16.370 --> 00:01:24.860
The last index off is similar in terms of syntax, but it returns the last index of the found element.

20
00:01:25.100 --> 00:01:32.060
Otherwise it is very similar to index of if start index is given, it will search from the index by

21
00:01:32.060 --> 00:01:32.660
default.

22
00:01:32.840 --> 00:01:35.720
START index is at a length minus one.

23
00:01:36.200 --> 00:01:39.170
The syntax of includes is something like this.

24
00:01:40.200 --> 00:01:45.660
Includes is also one similar matter like index of, but it returns boolean value.

25
00:01:46.050 --> 00:01:49.740
That is true if element is found otherwise false.

26
00:01:50.070 --> 00:01:55.230
These three are very common, very basic matters which we are going to try right now.

27
00:01:55.560 --> 00:02:00.870
Let's say we have this adding which has few elements if you are repeating like one is three times in

28
00:02:00.870 --> 00:02:01.320
the attic.

29
00:02:01.500 --> 00:02:05.790
Now the first statement I'm going to try is consolidate log.

30
00:02:06.600 --> 00:02:13.260
The added name is error and I will say index of what I want to search is I want to search for value

31
00:02:13.260 --> 00:02:14.270
one in this adding.

32
00:02:14.910 --> 00:02:17.700
Let's save this and run what it returns.

33
00:02:21.510 --> 00:02:25.470
Now you can see one is found on the zeroth index surgery done zero.

34
00:02:25.710 --> 00:02:27.870
By default, the START index is zero.

35
00:02:27.870 --> 00:02:30.060
So it has started searching from zero.

36
00:02:30.330 --> 00:02:36.360
Assume that I knew that it should start from the second index number that is zero one and two from this

37
00:02:36.360 --> 00:02:37.740
position I wanted to search.

38
00:02:37.770 --> 00:02:39.300
Oh, let's see, three.

39
00:02:39.510 --> 00:02:40.320
That will be better.

40
00:02:40.770 --> 00:02:44.970
So from this three, zero, one, two and three, it is going to start.

41
00:02:45.150 --> 00:02:47.490
I'm saving this and running it again.

42
00:02:48.880 --> 00:02:53.800
So now you see that the one is found on the fifth position.

43
00:02:53.800 --> 00:02:56.200
So it has written the index number five.

44
00:02:56.710 --> 00:03:00.340
In case if I go to, let's say small or.

45
00:03:01.830 --> 00:03:06.720
Then if we try to search it, it's not going to retain the value that is.

46
00:03:06.720 --> 00:03:10.260
It is going to return minus one because that value is not found.

47
00:03:10.500 --> 00:03:15.060
This also proves that index of searches gains sensitive value.

48
00:03:15.540 --> 00:03:17.430
Let's change it to one again.

49
00:03:17.730 --> 00:03:23.430
Now we will try the last index off in the very same case as the last two index off.

50
00:03:24.120 --> 00:03:26.460
Let's directly run this and see what happens.

51
00:03:27.660 --> 00:03:29.550
This also has returned five.

52
00:03:29.560 --> 00:03:31.500
Why last index?

53
00:03:31.620 --> 00:03:35.150
Start searching from array length minus one.

54
00:03:35.160 --> 00:03:40.680
That is if we have zero one, two, three, four, five and six, there is total seven elements.

55
00:03:41.040 --> 00:03:42.900
The last is the sixth element.

56
00:03:42.900 --> 00:03:45.540
So error length minus one will be six here.

57
00:03:45.750 --> 00:03:47.700
That will be the start of searching.

58
00:03:47.910 --> 00:03:54.660
Now, let's say you want that it should search from this place that is zero, one, two and three.

59
00:03:54.960 --> 00:03:58.050
So I can say here that start searching from three.

60
00:03:58.500 --> 00:04:06.150
Remember, that index number is calculated from the start, of course, but the search will go backward.

61
00:04:06.390 --> 00:04:12.930
So now if I search zero one, two, three, this is the place from where the search is going to be started

62
00:04:13.320 --> 00:04:15.270
and it will go to search.

63
00:04:15.270 --> 00:04:19.110
Where is one in this and are adding let's see what happens.

64
00:04:19.980 --> 00:04:21.870
It is two so 012.

65
00:04:22.050 --> 00:04:30.270
This is how the index of and last index of works the return the index number of the found element whereas

66
00:04:30.270 --> 00:04:33.750
includes is very similar in terms of parameters.

67
00:04:33.960 --> 00:04:36.780
You would see that it has the very same parameter.

68
00:04:37.230 --> 00:04:43.830
It is something like index of only, but instead of returning the element number, that is index number,

69
00:04:44.040 --> 00:04:48.390
it returns whether it is existing or not, it has found or not.

70
00:04:48.400 --> 00:04:50.280
That is true or false.

71
00:04:50.520 --> 00:04:54.480
So now if I save this, it's going to search from this place.

72
00:04:54.480 --> 00:04:57.420
That is the fourth place part index.

73
00:04:58.200 --> 00:04:59.700
Where will it find?

74
00:04:59.700 --> 00:05:03.600
It will find here, but it's not going to see the index number.

75
00:05:03.600 --> 00:05:08.400
But instead it will simply say whether is there any value found or not.

76
00:05:08.460 --> 00:05:13.920
Again, if I just change this to, let's say any or something, I don't even need this index number.

77
00:05:13.920 --> 00:05:15.900
Let's see whether it finds it or not.

78
00:05:16.200 --> 00:05:17.880
It is false.

79
00:05:17.880 --> 00:05:19.800
That means the value is not there.

80
00:05:20.220 --> 00:05:27.780
So these three methods are an easier way to search, but there can be more complex searches like conditional

81
00:05:27.780 --> 00:05:28.230
search.

82
00:05:28.590 --> 00:05:33.870
For example, you have an array of salary and you want to get all elements.

83
00:05:34.050 --> 00:05:36.720
Where salary is more than 3000.

84
00:05:36.930 --> 00:05:44.250
Then you can use find method, find index method, or sometimes even a better method called filter.

85
00:05:44.520 --> 00:05:49.950
Let's directly jump into a practical example and later we will figure out this index.

86
00:05:50.370 --> 00:05:52.710
Let's say this is the add of salary.

87
00:05:52.890 --> 00:05:55.770
Now this index of find method is something like this.

88
00:05:55.770 --> 00:05:57.900
It is going to return something that we will see.

89
00:05:57.900 --> 00:06:00.780
The return value is what I'll say added or find.

90
00:06:02.180 --> 00:06:09.230
Now this takes a callback function like we have already seen in for each that there is a callback function

91
00:06:09.230 --> 00:06:10.820
called for each element.

92
00:06:10.910 --> 00:06:12.260
Same thing is happening here.

93
00:06:12.270 --> 00:06:17.570
Now I can write function like this or I can go with the arrow function, but I prefer to go with arrow

94
00:06:17.570 --> 00:06:18.050
function.

95
00:06:19.140 --> 00:06:19.530
Here.

96
00:06:19.530 --> 00:06:22.230
It is going to pass for parameters.

97
00:06:22.590 --> 00:06:29.340
The first is the element that means each element is going to be passed in this argument.

98
00:06:29.850 --> 00:06:31.380
There can be an index number.

99
00:06:32.190 --> 00:06:33.360
There can be an ADD.

100
00:06:33.630 --> 00:06:40.150
This adds basically the add itself on which the find is applied and there can be a this argument.

101
00:06:40.170 --> 00:06:42.330
All these are similar to for each.

102
00:06:42.660 --> 00:06:45.840
First of all, let's simply start with element.

103
00:06:46.200 --> 00:06:53.010
What we want to do is we just want to return all the elements which are more than 3000.

104
00:06:53.160 --> 00:07:00.570
So if that is an element, more than 3000 that is valued, 3000 that will be returned in our will.

105
00:07:00.750 --> 00:07:07.470
So I'm going to say a return element, more than 3000, and it will stop searching and I'm adding this

106
00:07:07.470 --> 00:07:09.750
console.log out of it, which is returned here.

107
00:07:09.780 --> 00:07:11.880
Now let's run this code and see what happens.

108
00:07:13.750 --> 00:07:15.050
It says 4500.

109
00:07:15.070 --> 00:07:22.060
That means it did find this value that is something more than 3000, but it did not search further.

110
00:07:22.750 --> 00:07:29.980
In fact, this only finds one value and it stops the searching the way we have fine matter.

111
00:07:30.100 --> 00:07:32.380
We do also have find index.

112
00:07:32.560 --> 00:07:39.070
This is absolutely same as the fine matter, but instead of returning the value, it returns the index

113
00:07:39.070 --> 00:07:39.370
number.

114
00:07:39.400 --> 00:07:40.180
Let's try this.

115
00:07:40.780 --> 00:07:41.410
You see that?

116
00:07:41.770 --> 00:07:43.330
It returns the index number.

117
00:07:43.480 --> 00:07:48.610
But the problem with these two methods is it finds only one value at a time.

118
00:07:49.540 --> 00:07:54.130
Let's say you want to get all the values which are more than 3000.

119
00:07:54.550 --> 00:07:55.390
How will you do that?

120
00:07:55.930 --> 00:07:59.380
The best way is you use the filter method.

121
00:07:59.920 --> 00:08:04.150
Now, the amazing thing with filter method is it doesn't return one value.

122
00:08:04.360 --> 00:08:10.390
It returns a new add a entire new array of found elements.

123
00:08:10.630 --> 00:08:18.070
So whichever element returns true with the condition that is returned to a new add, a new array is

124
00:08:18.070 --> 00:08:19.540
filled with those values.

125
00:08:19.990 --> 00:08:22.810
Let's try this and see now what is the output?

126
00:08:23.320 --> 00:08:24.580
We are displaying the ah well.

127
00:08:24.580 --> 00:08:29.910
But now our well that is the return value is now going to be an entire add.

128
00:08:30.250 --> 00:08:30.940
You see this?

129
00:08:31.180 --> 00:08:32.260
These are the elements.

130
00:08:32.409 --> 00:08:33.950
This 1200 is not offered.

131
00:08:34.090 --> 00:08:34.409
Right.

132
00:08:34.720 --> 00:08:36.580
This 1200 is less than 3000.

133
00:08:36.789 --> 00:08:37.960
So that is not return.

134
00:08:38.140 --> 00:08:41.080
Only these three elements are part of our web.

135
00:08:41.440 --> 00:08:46.930
So a new adda is created with the filter matter as long as the syntax is concerned.

136
00:08:46.960 --> 00:08:48.820
Here is the syntax of fine matter.

137
00:08:49.830 --> 00:08:54.450
It takes a callback function and that is an element that is an optional index number.

138
00:08:54.450 --> 00:09:01.290
Also the added on which the fine motor is applied and the this argument which is a reference of the

139
00:09:01.470 --> 00:09:03.960
this object in the callback function.

140
00:09:04.080 --> 00:09:06.630
Now the same syntax is for all three methods.

141
00:09:06.630 --> 00:09:07.320
That is fine.

142
00:09:07.320 --> 00:09:08.670
Find index and filter.

143
00:09:09.000 --> 00:09:15.180
If there is no true value found in A-D in case of find it will return undefined.

144
00:09:15.360 --> 00:09:21.150
The same is the case with fine index also, but if there is no value found with filter method, it is

145
00:09:21.150 --> 00:09:22.970
going to return an empty adding.

146
00:09:23.430 --> 00:09:28.260
Let's say for example, here in this case as say 30,000, is there any value?

147
00:09:28.260 --> 00:09:29.400
More than 30,000?

148
00:09:29.880 --> 00:09:34.710
If no, then there won't be any value return in an added, but it won't be undefined.

149
00:09:34.860 --> 00:09:35.460
You see this?

150
00:09:35.640 --> 00:09:36.680
This is an empty adding.

151
00:09:36.930 --> 00:09:40.170
But instead of this, if I say find method, it will.

152
00:09:42.190 --> 00:09:43.300
Return undefined.

153
00:09:43.870 --> 00:09:51.760
So this can also be a question that what will be the output if there is no value return in filter matter?

154
00:09:52.000 --> 00:09:53.080
How do you find method?

155
00:09:54.010 --> 00:09:57.100
Now let's discuss the relative questions of this topic.

156
00:09:57.310 --> 00:10:02.110
The first question is what is the difference between find and filter method?

157
00:10:02.170 --> 00:10:07.560
So we have seen that find returns only one value that is the first match and it stops searching.

158
00:10:07.570 --> 00:10:09.820
But as filter returns a new ADI.

159
00:10:12.070 --> 00:10:18.430
The second question is if there is no value to return, what will find index return?

160
00:10:18.820 --> 00:10:25.030
So like find find index will also return undefined if there is no true value matched.

161
00:10:27.500 --> 00:10:33.020
The third question is what is the difference between index off and includes method?

162
00:10:33.320 --> 00:10:40.280
So index of returns the index whereas includes returns the true or false that is a boolean value.

163
00:10:42.680 --> 00:10:47.240
The fourth question is how will you search multiple values in an ad?

164
00:10:47.510 --> 00:10:50.030
So that's where filter matter is useful.

165
00:10:50.030 --> 00:10:52.670
So you can talk about filter matters in that case.

166
00:10:54.900 --> 00:10:57.250
And that is this piece of code.

167
00:10:57.270 --> 00:11:00.990
And the question can be, what will be the output of this code?

168
00:11:01.140 --> 00:11:06.930
Now here the last index off is applied and there is no such element ABCD in the attic.

169
00:11:07.110 --> 00:11:10.730
If the element is not found, what should be the output?

170
00:11:10.740 --> 00:11:15.520
So in case of index of our last index of minus one is the output.

171
00:11:15.570 --> 00:11:20.130
If the element is not found, if you want to try, we can do that, I will say.

172
00:11:21.080 --> 00:11:28.040
Last index of fear and trying to do something, trying to find something that is not all that in the

173
00:11:28.040 --> 00:11:28.520
attic.

174
00:11:29.030 --> 00:11:31.700
And if I understand, output is minus one.

175
00:11:32.060 --> 00:11:38.150
So apart from these matters, there are many other matters or ways which you can implement to search

176
00:11:38.150 --> 00:11:39.440
elements in an attic.

177
00:11:39.470 --> 00:11:41.360
But these are the most commonly used.

178
00:11:41.570 --> 00:11:46.750
Filter is one of those matters which is often use to find the add elements.

