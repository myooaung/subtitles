WEBVTT
1
00:00:00.150 --> 00:00:04.080
In this section of map and set, we are discussing this set.

2
00:00:04.650 --> 00:00:06.960
There are three related questions to this topic.

3
00:00:07.890 --> 00:00:12.180
The set collection or data structure does not have keys.

4
00:00:12.540 --> 00:00:15.510
It has only values and that two unique values.

5
00:00:15.930 --> 00:00:19.940
So if you add the same or duplicate value, it is ignored.

6
00:00:19.950 --> 00:00:28.020
In simple words, it means you will have unique or non-repeating values only to add values to a set.

7
00:00:28.380 --> 00:00:30.210
You can use the add method.

8
00:00:30.750 --> 00:00:34.530
It also has the size property to check the count of values.

9
00:00:35.100 --> 00:00:36.840
I will create let.

10
00:00:37.900 --> 00:00:41.140
Names is equal to a new set.

11
00:00:42.560 --> 00:00:45.380
I'm using the ad method now, so I'll say ad.

12
00:00:47.220 --> 00:00:47.850
First.

13
00:00:52.460 --> 00:00:53.050
Let's see.

14
00:00:54.460 --> 00:00:55.060
Second.

15
00:00:56.420 --> 00:00:58.280
Ter So there are four values.

16
00:00:58.520 --> 00:01:04.010
I'll add this first again as well, just to see that it maintains the unique value collection.

17
00:01:04.640 --> 00:01:06.110
Now I'm going to console.log.

18
00:01:07.630 --> 00:01:09.670
And will display names.

19
00:01:10.630 --> 00:01:11.920
Let's run this, I'll say.

20
00:01:12.710 --> 00:01:14.650
Nor suggests.

21
00:01:15.580 --> 00:01:17.740
Actually, we have added four values.

22
00:01:17.740 --> 00:01:20.960
But if you see the output, there are only three values displayed.

23
00:01:20.980 --> 00:01:23.640
Let's also try the size as well.

24
00:01:23.650 --> 00:01:28.750
So I'll say console.log based ID and name start size.

25
00:01:31.850 --> 00:01:35.450
So there are only three values added to this names set.

26
00:01:36.380 --> 00:01:41.900
So this is the unique collection of values, the way we have used the ad method.

27
00:01:42.230 --> 00:01:45.010
You can also pass and add in the constructor.

28
00:01:45.020 --> 00:01:46.850
Let me just comment this for the moment.

29
00:01:47.930 --> 00:01:52.040
Now here I am going to pass, let's say first.

30
00:01:53.760 --> 00:01:55.470
Second and third.

31
00:01:56.440 --> 00:02:00.460
So this is also the correct way to assign values to a set.

32
00:02:00.970 --> 00:02:02.410
So still it has three values.

33
00:02:02.410 --> 00:02:04.120
And of course the size is also three.

34
00:02:04.120 --> 00:02:08.410
Even if you try another value here, that will also be ignored.

35
00:02:08.410 --> 00:02:10.270
So you'll always have a unique value.

36
00:02:10.270 --> 00:02:19.420
Collection set is also a table and you can put a far off directly on set collection for each can also

37
00:02:19.420 --> 00:02:21.160
be used to look through the collection.

38
00:02:21.670 --> 00:02:23.230
Let's check both ways.

39
00:02:23.410 --> 00:02:25.330
First of all, I'll begin with far off.

40
00:02:26.280 --> 00:02:28.800
So now we are back to the original code we had earlier.

41
00:02:29.520 --> 00:02:32.370
All right, so I want to loop through this collection.

42
00:02:32.370 --> 00:02:38.280
So I'm going to put a far loop here, I'll say for let value of names.

43
00:02:39.410 --> 00:02:42.710
And we display the value we.

44
00:02:45.620 --> 00:02:49.700
So when you look through it, right, it is placed first, second and third.

45
00:02:50.430 --> 00:02:52.670
Now, let's also remove this as it is not needed.

46
00:02:52.700 --> 00:02:55.430
Now you know that it contains the unique values only.

47
00:02:56.400 --> 00:02:56.640
In?

48
00:02:56.640 --> 00:03:00.420
Mapp We have seen that we had values method.

49
00:03:00.630 --> 00:03:03.720
Let's try the same method here and see what happens.

50
00:03:05.010 --> 00:03:10.410
Anyway because we wrote names, we got the values because here we don't have key and value collection.

51
00:03:10.410 --> 00:03:10.800
Correct?

52
00:03:11.490 --> 00:03:14.600
But here, if you use values matter, then what happens?

53
00:03:14.610 --> 00:03:15.300
Let's see this.

54
00:03:16.410 --> 00:03:17.950
It still displays the values.

55
00:03:18.780 --> 00:03:21.150
Even this does not have keys.

56
00:03:21.570 --> 00:03:27.900
But if you try the keys method here, that will also give you the output and it will be values only.

57
00:03:28.680 --> 00:03:33.660
Not only this, even if you use the entries method with a set.

58
00:03:33.870 --> 00:03:34.980
It's also possible.

59
00:03:36.000 --> 00:03:40.380
If I run this, I'm going to get values in value and keep art as well.

60
00:03:40.380 --> 00:03:44.400
So key and value, if you consider both are values only.

61
00:03:44.400 --> 00:03:50.910
Now why these matters are needed anyway with said actually they are not needed, but just to make it

62
00:03:50.910 --> 00:03:52.650
compatible with map mattered.

63
00:03:53.070 --> 00:03:56.470
You see the same matters applied with asset as well.

64
00:03:56.490 --> 00:04:00.360
Otherwise values, keys or entries, they are of no use as such.

65
00:04:01.590 --> 00:04:04.410
In fact, the way we use for each year.

66
00:04:04.410 --> 00:04:05.340
Let's try that now.

67
00:04:05.370 --> 00:04:06.060
Now you know that.

68
00:04:06.060 --> 00:04:07.730
How to loop through the set.

69
00:04:08.340 --> 00:04:10.190
Let's try for each.

70
00:04:10.190 --> 00:04:11.250
So I'll say names.

71
00:04:12.680 --> 00:04:14.660
Not for each.

72
00:04:15.230 --> 00:04:16.779
And now the callback function.

73
00:04:16.790 --> 00:04:21.320
You see this parameter, the tooltip displayed here sees that value.

74
00:04:21.320 --> 00:04:23.870
Value to it doesn't display key.

75
00:04:23.870 --> 00:04:25.760
And even the last one is the set.

76
00:04:26.150 --> 00:04:31.760
So the callback function we have here, here I'm going to say value one, comma, value two and a set.

77
00:04:32.330 --> 00:04:37.220
These two values are going to be the same, only it doesn't make any difference at all.

78
00:04:37.250 --> 00:04:39.230
So let's try that.

79
00:04:40.250 --> 00:04:41.570
I'll save even calamari.

80
00:04:41.570 --> 00:04:44.960
Two They are going to be same because we don't have keys here.

81
00:04:44.960 --> 00:04:47.030
We just have values in the set collection.

82
00:04:47.660 --> 00:04:48.290
You see this?

83
00:04:48.770 --> 00:04:51.290
They both have first, first and second and third.

84
00:04:51.290 --> 00:04:51.650
Third.

85
00:04:52.610 --> 00:04:57.980
So key has no significance as such, but everywhere just to make it compatible with the regular flow

86
00:04:57.980 --> 00:05:03.650
of map or maybe other variations of data structures like you and Adam has for each right, which has

87
00:05:03.740 --> 00:05:09.320
three parameters like this where key value and the ad itself we already have with Adi.

88
00:05:09.710 --> 00:05:13.550
So just to make it compatible set does have all those things.

89
00:05:13.550 --> 00:05:20.390
But in case of KI also you are going to get the value only as long as values removal is concern.

90
00:05:21.080 --> 00:05:28.250
Set also has delete, which takes value to be removed and clear, which completely removes the values.

91
00:05:28.610 --> 00:05:30.570
So let's try here.

92
00:05:30.590 --> 00:05:32.450
Now I'm going to try console.log.

93
00:05:33.960 --> 00:05:35.820
First I'm going to display names.

94
00:05:36.600 --> 00:05:37.590
What is the value?

95
00:05:37.860 --> 00:05:40.560
You can check with size also, but that's okay.

96
00:05:41.550 --> 00:05:42.330
Names dot.

97
00:05:43.020 --> 00:05:43.920
I'll say delete.

98
00:05:44.610 --> 00:05:47.970
Why do you want to delete is let's say I want to delete first.

99
00:05:49.320 --> 00:05:52.740
Again, I'll display the set.

100
00:05:53.580 --> 00:05:54.510
Now if you run.

101
00:05:57.030 --> 00:06:02.610
You have this first set where there are three values and in the second case, we have just two lose

102
00:06:02.610 --> 00:06:04.140
here right now.

103
00:06:04.140 --> 00:06:09.150
Instead of this, if you simply say clear, there is no parameter you have to pass here in the clear.

104
00:06:09.600 --> 00:06:16.590
Let's run this so you can make out that clear will remove all the values.

105
00:06:17.460 --> 00:06:20.010
So now let's discuss related questions of this topic.

106
00:06:20.400 --> 00:06:22.830
What is the difference between map and set?

107
00:06:23.400 --> 00:06:28.020
So map has key and value and set has only values.

108
00:06:28.020 --> 00:06:30.630
And at the same time it's a unique collection.

109
00:06:30.630 --> 00:06:32.340
So the values are not repeated.

110
00:06:32.580 --> 00:06:38.850
Even if you insert a value which is duplicate, that is going to be ignored in set, which doesn't happen

111
00:06:38.850 --> 00:06:40.920
with any other collection in JavaScript.

112
00:06:41.280 --> 00:06:45.630
The second question is how will you remove a specific value from set?

113
00:06:45.990 --> 00:06:48.750
So to remove a specific value, you use the delete.

114
00:06:48.900 --> 00:06:49.890
Like this one here.

115
00:06:49.890 --> 00:06:53.560
We tried first so it removed only that value.

116
00:06:53.580 --> 00:06:58.560
Remember, in case if this value is not found, it's not going to give you any error.

117
00:06:58.950 --> 00:07:01.860
So this is how you remove a specific value from a set.

118
00:07:02.340 --> 00:07:07.470
The third question is what will entries method with set will return?

119
00:07:07.860 --> 00:07:09.330
So we have seen that here.

120
00:07:09.330 --> 00:07:16.440
When we say for loop and the entries method, both the key and value are going to be the value only

121
00:07:16.440 --> 00:07:19.110
because it doesn't have key in the set collection.

