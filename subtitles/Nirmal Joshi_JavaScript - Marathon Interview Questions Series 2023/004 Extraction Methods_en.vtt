WEBVTT
1
00:00:03.890 --> 00:00:08.090
Now in this section, I'm going to discuss various extraction methods.

2
00:00:10.050 --> 00:00:12.960
Matters which are going to extract part from a string.

3
00:00:12.960 --> 00:00:15.450
It might be a substring or a character.

4
00:00:17.010 --> 00:00:20.550
We can divide the extraction matters in two main categories.

5
00:00:21.060 --> 00:00:26.760
The first is destroying extraction methods, and the second is the character extraction methods.

6
00:00:27.240 --> 00:00:31.860
I will begin with the first category that is the string extraction methods.

7
00:00:32.369 --> 00:00:36.300
Well, there are three methods which help to extract strings.

8
00:00:36.840 --> 00:00:42.720
That is the slice, the sub star and substring itself.

9
00:00:43.200 --> 00:00:45.360
Let's begin with the slice method.

10
00:00:45.720 --> 00:00:48.780
The syntax of slice method looks like this.

11
00:00:50.050 --> 00:00:54.850
The sliced matter has two parameters in which the second parameter is optional.

12
00:00:55.300 --> 00:00:58.420
It returns the extracted part as a new string.

13
00:00:58.630 --> 00:01:00.970
That is without changing the original string.

14
00:01:01.360 --> 00:01:04.690
Let's practically try a few ways to get the clear idea.

15
00:01:04.959 --> 00:01:06.310
I'm going to define a string.

16
00:01:06.310 --> 00:01:14.560
I'll say let STR is equal to, let's say first, second, third and fourth.

17
00:01:14.590 --> 00:01:16.630
That's how I'm going to define the string.

18
00:01:17.350 --> 00:01:18.910
Now it's going to return the string.

19
00:01:18.910 --> 00:01:24.070
So instead of storing it in a variable, I'm just going to say start or slice.

20
00:01:25.100 --> 00:01:31.670
And I'll just write in here, as I mentioned in the syntax that we have the start index and optional

21
00:01:31.670 --> 00:01:35.390
end index here, I'm just defining the START index.

22
00:01:35.660 --> 00:01:37.790
Let's try to run this and see what happens.

23
00:01:38.300 --> 00:01:46.040
Now you see that it starts from the 10th position and it returns the entire string till the end because

24
00:01:46.040 --> 00:01:48.740
I haven't mentioned the end index.

25
00:01:49.940 --> 00:01:53.750
As a start index here, I can give a negative value as well.

26
00:01:54.620 --> 00:01:59.930
Now, if I run this, you will observe that because I mentioned minus ten.

27
00:02:00.260 --> 00:02:04.040
It started to cut the string from the end of it.

28
00:02:04.490 --> 00:02:11.840
Now you see that when I mentioned minus ten, it actually started from the end of the string and it

29
00:02:11.840 --> 00:02:18.710
started from this 10th position and it return the string till the last character.

30
00:02:19.640 --> 00:02:22.040
Now let me make this again positive.

31
00:02:22.430 --> 00:02:24.480
Let's try the optional syntax now.

32
00:02:24.500 --> 00:02:26.150
The syntax which you see right now.

33
00:02:27.150 --> 00:02:31.230
Now here with the ten, I'm going to define 15.

34
00:02:31.740 --> 00:02:32.940
Now, let's run this code.

35
00:02:32.940 --> 00:02:35.310
I'm just going to run this and observe what happens.

36
00:02:36.120 --> 00:02:42.180
So it started from the 10th index and it read below the 14th index.

37
00:02:43.280 --> 00:02:52.280
Now you observe that because I gave 15 as the end index it read the index minus one that it readily

38
00:02:52.460 --> 00:02:53.960
14th index only.

39
00:02:54.930 --> 00:02:58.410
If you give the negative value, let me give you minus ten here.

40
00:02:58.620 --> 00:03:06.200
And if I say minus five, then you would observe that when I ran this, it started from the minus 10th

41
00:03:06.210 --> 00:03:14.670
position and it read tilde minus five position minus five or minus ten is basically the total length,

42
00:03:14.970 --> 00:03:16.350
minus this value.

43
00:03:17.350 --> 00:03:18.910
So you get this string.

44
00:03:20.200 --> 00:03:22.360
This is how the sliced method works.

45
00:03:22.960 --> 00:03:25.720
Now let's check the sub SDR method.

46
00:03:26.140 --> 00:03:28.330
We do have a sub SDR.

47
00:03:28.360 --> 00:03:30.840
Generally we call that as substring.

48
00:03:30.850 --> 00:03:34.960
But here in JavaScript we have substring as a separate method.

49
00:03:35.230 --> 00:03:37.930
So I would call this as a sub SDR.

50
00:03:38.350 --> 00:03:41.110
So this is the syntax of a sub SDR.

51
00:03:41.140 --> 00:03:47.740
Here we have the start index and the second parameter is not the end index.

52
00:03:47.860 --> 00:03:50.200
Instead, it is the number of characters.

53
00:03:50.290 --> 00:03:52.030
Of course it is optional.

54
00:03:52.210 --> 00:03:58.420
So let me just, first of all, practically try a substitute here instead of slice, and I'm going to

55
00:03:58.420 --> 00:04:03.010
remove all these values and I'll just say ten again here, the very same thing.

56
00:04:03.610 --> 00:04:09.570
If I run is going to give you the very same output, which we got while we were using the slice method.

57
00:04:09.580 --> 00:04:15.580
Even if you say a negative value like minus ten, then also is going to give the same output.

58
00:04:15.880 --> 00:04:24.010
But the key is that when you give three here, for example, then three was actually the end index in

59
00:04:24.010 --> 00:04:25.360
case of slice.

60
00:04:25.570 --> 00:04:25.840
Right.

61
00:04:25.840 --> 00:04:28.040
But here we have the number of characters.

62
00:04:28.060 --> 00:04:34.930
It means that from the 10th position, it will read three characters and it will return it in a new

63
00:04:34.930 --> 00:04:35.730
string, of course.

64
00:04:35.800 --> 00:04:42.940
So if I run this, it'll start from the 10th position and it'll take the three characters which we have

65
00:04:42.940 --> 00:04:44.500
here, including this piece.

66
00:04:44.710 --> 00:04:46.620
Let me just correct two, four.

67
00:04:46.630 --> 00:04:50.350
So you get the idea that actually that is one more character as well.

68
00:04:51.380 --> 00:04:55.340
So if you compare, slice and subsidy are more or less.

69
00:04:55.520 --> 00:05:01.010
They both are similar, but instead of end index, it takes a number of characters.

70
00:05:02.370 --> 00:05:06.280
We do also have a provision to give negative values here as well.

71
00:05:06.300 --> 00:05:12.510
So if I can say minus ten and four characters, then certainly it'll start from the end and it will

72
00:05:12.510 --> 00:05:14.220
return four characters.

73
00:05:14.220 --> 00:05:18.030
So from 10th position, it is returning for characters.

74
00:05:18.720 --> 00:05:21.690
Let me just change -10 to -5.

75
00:05:22.140 --> 00:05:25.590
Now, if I run this, you'll observe that from minus five.

76
00:05:25.590 --> 00:05:27.950
That is one, two, three, four and five.

77
00:05:27.960 --> 00:05:31.440
So that's the opposition from all two, four characters.

78
00:05:31.440 --> 00:05:33.120
That is all you are t.

79
00:05:33.450 --> 00:05:36.390
So four characters, number of characters we get as output.

80
00:05:37.480 --> 00:05:43.030
The next string extraction matter is substring itself, so I'm going to write substring.

81
00:05:43.660 --> 00:05:50.250
Now this method has this kind of syntax where you have the start index and end index.

82
00:05:50.260 --> 00:05:55.570
So if you compare this with slice, it is very similar in terms of syntax.

83
00:05:56.170 --> 00:05:59.740
The only difference is it cannot take negative values.

84
00:05:59.980 --> 00:06:02.710
So let me just try this here as his substring.

85
00:06:03.130 --> 00:06:06.970
Otherwise, the rest of the things are very similar to slice.

86
00:06:07.030 --> 00:06:12.580
Let me just copy this line and paste it again and give me negative value just to see what happens.

87
00:06:13.090 --> 00:06:20.440
So here, if you see we have the value return from the 10th index and when I give minus ten, it doesn't

88
00:06:20.440 --> 00:06:20.750
work.

89
00:06:20.770 --> 00:06:22.840
Instead, it returns the entire stream.

90
00:06:23.500 --> 00:06:27.550
You can also give the end index, say, for example, ten, and I give 15 here.

91
00:06:27.580 --> 00:06:32.410
Now let me remove the second console, clear the console and run it.

92
00:06:32.890 --> 00:06:36.970
So this output is also similar to the slice method.

93
00:06:38.090 --> 00:06:40.430
Now let's talk about character extinction.

94
00:06:40.850 --> 00:06:44.750
Now, if we talk about character extinction, then there are two similar methods.

95
00:06:45.110 --> 00:06:47.960
Character Act and character code act.

96
00:06:49.150 --> 00:06:58.330
First is returning character and the second is returning integer unequal value between zero and 65535.

97
00:06:59.050 --> 00:07:01.300
Let's check both the methods together.

98
00:07:01.570 --> 00:07:06.300
I'm simply going to create another variable called SDR with different value.

99
00:07:06.310 --> 00:07:12.100
I mean, I'll say first, second, just a small string I'm using.

100
00:07:12.790 --> 00:07:14.350
Now I'm going to say console.log.

101
00:07:15.460 --> 00:07:15.820
Here.

102
00:07:15.820 --> 00:07:19.810
I'll see astronaut character at the next number.

103
00:07:19.810 --> 00:07:22.500
I'll say three even if I give.

104
00:07:22.540 --> 00:07:23.880
Let's say this console.log.

105
00:07:23.890 --> 00:07:24.610
I copy.

106
00:07:25.330 --> 00:07:30.790
Even if I do not give this index number here, then also it will give the output.

107
00:07:31.060 --> 00:07:36.730
When you do not give the index number, it's going to consider zero by default rates is going to return

108
00:07:36.730 --> 00:07:38.140
the value of f here.

109
00:07:39.260 --> 00:07:45.650
Similarly, let me just copy these two and I'm going to paste it again to make it fast and as a character

110
00:07:45.650 --> 00:07:46.130
called.

111
00:07:46.400 --> 00:07:48.980
Now this is going to return me Unicode value.

112
00:07:48.980 --> 00:07:50.300
That is UTF 16.

113
00:07:51.380 --> 00:07:52.660
And let's run this now.

114
00:07:52.670 --> 00:07:58.640
If I let me clear the console and run the code, now you see that when I say third position, that is

115
00:07:58.640 --> 00:07:59.840
zero one, two and three.

116
00:07:59.840 --> 00:08:01.070
So as is returned.

117
00:08:01.670 --> 00:08:06.380
And in the second case, it returns F because by default it considers zero.

118
00:08:07.100 --> 00:08:14.810
Here when I say character code and it returns the unique value of s that is 115 and for capital F,

119
00:08:15.020 --> 00:08:16.490
it returns 70.

120
00:08:17.580 --> 00:08:20.250
That is also another way to extract a character.

121
00:08:20.790 --> 00:08:22.400
Let me show you that as well.

122
00:08:22.410 --> 00:08:24.510
I just remove these methods.

123
00:08:24.510 --> 00:08:28.400
And here also I'm just using the traditional way.

124
00:08:28.410 --> 00:08:33.919
That is, I'll say, for example, SDR of two, that is zero one and two.

125
00:08:33.929 --> 00:08:38.570
Now I'm writing this like and adding Though SDR is not an edit.

126
00:08:38.909 --> 00:08:42.450
When I run, it's going to return me add here as you see.

127
00:08:43.650 --> 00:08:51.390
So here string looks like an eddy, but it actually is not this way of writing the code is not a common

128
00:08:51.390 --> 00:08:52.110
way, right?

129
00:08:52.130 --> 00:08:57.450
Generally we see that when we want to get a character, we put a loop, we loop through the string or

130
00:08:57.450 --> 00:09:01.650
we have the character at our character called depending on the requirement.

131
00:09:02.160 --> 00:09:05.720
But this is also one of the syntax existing in JavaScript.

132
00:09:05.730 --> 00:09:06.750
So I'm discussing here.

133
00:09:07.590 --> 00:09:09.150
Now let's talk about questions.

134
00:09:09.780 --> 00:09:12.560
The first question is what will be the output of below code?

135
00:09:12.570 --> 00:09:14.430
Let me just type the code here first.

136
00:09:16.560 --> 00:09:23.190
I'll say hello world and the console.log that I'm using start slice.

137
00:09:24.550 --> 00:09:26.470
So what should be the output of this?

138
00:09:27.470 --> 00:09:28.700
Now minus five.

139
00:09:28.700 --> 00:09:31.160
That is one, two, three, four and five.

140
00:09:31.640 --> 00:09:31.970
Right.

141
00:09:32.300 --> 00:09:35.300
And the second that is the end index is minus two.

142
00:09:35.300 --> 00:09:36.770
That is one and two.

143
00:09:36.780 --> 00:09:44.420
So it should consider all the characters between starting from five and ends at minus two.

144
00:09:44.480 --> 00:09:50.840
But remember, when you are using this negative index, it is going to consider characters before minus

145
00:09:50.840 --> 00:09:51.140
two.

146
00:09:51.200 --> 00:09:53.840
So you have the output W or R.

147
00:09:54.920 --> 00:09:59.900
The next question is what is the difference between Substring and Sub SDR?

148
00:10:00.830 --> 00:10:09.340
So as we have discussed sub x number of characters, whereas the substring takes start index and index

149
00:10:09.350 --> 00:10:11.540
as you see in the syntax.

150
00:10:13.570 --> 00:10:18.610
Now the third question is what will be the output of the below given called and explain with reason.

151
00:10:19.030 --> 00:10:22.480
Now, as you all know, that substring does not take negative value.

152
00:10:22.490 --> 00:10:28.930
So if I give the negative value is going to return me the entire string because negative is an invalid.

153
00:10:28.930 --> 00:10:34.240
But though you are giving an invalid value is not going to give you any added at the same time.

154
00:10:35.360 --> 00:10:35.540
Now.

155
00:10:35.540 --> 00:10:37.580
Let's talk about the next question.

156
00:10:38.810 --> 00:10:42.710
Again, you're supposed to explain the output for the given call.

157
00:10:43.640 --> 00:10:49.310
Now substring does take start and index number, but here I want to share one information.

158
00:10:49.310 --> 00:10:51.200
That's why I have raised this question.

159
00:10:51.380 --> 00:10:57.290
The reason is is going to start from the third index, but the end index is three here.

160
00:10:57.320 --> 00:11:03.230
So if I run, you would see that that is no character given because the start and end is similar.

161
00:11:04.250 --> 00:11:06.560
Now let me change this 3 to 4 and run.

162
00:11:07.640 --> 00:11:09.620
You see that it returns only one character.

163
00:11:10.310 --> 00:11:16.280
So the start index is three, but the end index is not exactly the value.

164
00:11:16.280 --> 00:11:17.150
It is returning.

165
00:11:17.330 --> 00:11:21.170
It is returning start to end index minus one.

166
00:11:21.710 --> 00:11:28.160
So always remember, if you give both start and end as similar value, whether it is slice or substring,

167
00:11:28.280 --> 00:11:30.320
it's going to give you nothing.

168
00:11:31.510 --> 00:11:36.910
Let me change this to slice as well and practically see if I run.

169
00:11:38.100 --> 00:11:42.420
You see that it does not return anything because start and end is similar.

170
00:11:42.420 --> 00:11:49.080
So always remember the end index is not the very end till the previous character of the end index is

171
00:11:49.080 --> 00:11:49.650
considered.

172
00:11:50.770 --> 00:11:52.360
Now let's discuss the last question.

173
00:11:52.630 --> 00:11:58.270
Again, you're supposed to explain what will be the output, as I mentioned, characterized if there

174
00:11:58.270 --> 00:12:02.500
is no index given inside it, it will consider the first character.

175
00:12:02.740 --> 00:12:05.130
So character it will return be here.

176
00:12:05.140 --> 00:12:07.300
Let me run and show you the output.

177
00:12:07.450 --> 00:12:08.720
You see that it returns.

178
00:12:10.150 --> 00:12:13.930
So in this section we have discussed few character extraction methods.

179
00:12:14.260 --> 00:12:18.730
There can be different programming logics which you need to apply with the extraction.

180
00:12:18.940 --> 00:12:21.130
Then the program will make sense to you.

