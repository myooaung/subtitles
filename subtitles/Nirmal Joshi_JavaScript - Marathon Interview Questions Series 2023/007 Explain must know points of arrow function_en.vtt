WEBVTT
1
00:00:00.060 --> 00:00:05.000
Now we are discussing one of the very important question, and that is about arrow function.

2
00:00:05.780 --> 00:00:12.860
The main question I'm keeping is explain must know points of arrow function, but we are going to generate

3
00:00:12.860 --> 00:00:16.100
more questions out of the entire topics discussion.

4
00:00:16.309 --> 00:00:17.540
So let's begin with this.

5
00:00:17.540 --> 00:00:24.050
The category of this topic is JavaScript language, and there will be five related questions of arrow

6
00:00:24.050 --> 00:00:24.530
function.

7
00:00:24.980 --> 00:00:28.730
In most of the interviews you will be asked about arrow function.

8
00:00:28.880 --> 00:00:35.990
That impression is created when you actually discuss functional behavior rather than just the syntax

9
00:00:36.470 --> 00:00:36.800
tree.

10
00:00:36.800 --> 00:00:41.120
Functional behavior, which you must discuss is number one.

11
00:00:41.480 --> 00:00:44.270
This object does not work with arrow function.

12
00:00:44.930 --> 00:00:49.400
Number two arguments object does not work with arrow function.

13
00:00:49.760 --> 00:00:54.500
And third is you cannot use new to call arrow function.

14
00:00:54.860 --> 00:01:01.880
Now before we move on the above three points very quickly, I will also discuss the syntax and other

15
00:01:01.880 --> 00:01:02.750
minor points.

16
00:01:03.020 --> 00:01:09.890
In short, this will be a complete arrow function related tutorial covering almost all features of arrow

17
00:01:09.890 --> 00:01:10.370
function.

18
00:01:10.640 --> 00:01:16.940
So first I will begin with this code where I'm writing the traditional way of function.

19
00:01:17.210 --> 00:01:20.930
This was the way we used to write in JavaScript, which we still write.

20
00:01:20.930 --> 00:01:22.250
It's not that it is extinct.

21
00:01:22.250 --> 00:01:25.190
So I say function for example, test.

22
00:01:26.000 --> 00:01:30.620
Now you put parenthesis for parameters and you have statements inside the function.

23
00:01:30.620 --> 00:01:35.960
This is how you write the function and as long as calling the function is concerned, you give the name

24
00:01:35.960 --> 00:01:36.710
of the function.

25
00:01:37.250 --> 00:01:43.010
Now the very same function can be converted into function expression.

26
00:01:44.480 --> 00:01:50.360
Now this is another way of writing function and this is a very common way to write function expression.

27
00:01:50.630 --> 00:01:56.180
For example, the test function we had, it was like this function test and you have statements.

28
00:01:56.360 --> 00:02:02.570
Now when you say that this needs to be converted into function expression, syntax, it means you will

29
00:02:02.570 --> 00:02:09.620
write, let's say in the older JavaScript you used to say Var, but now because we are using E6, either

30
00:02:09.620 --> 00:02:13.970
isolate our const and then I give the name of the function.

31
00:02:14.120 --> 00:02:20.480
So it's a constant test is equal to and then we do not write this function name.

32
00:02:22.130 --> 00:02:31.070
So in a way you are writing, you are assigning the function to an object called test, so you are giving

33
00:02:31.580 --> 00:02:32.540
equal to sign.

34
00:02:32.540 --> 00:02:35.360
That is, you are writing the function as an expression.

35
00:02:35.360 --> 00:02:39.050
So this is function expression and then you call the function with the name only.

36
00:02:39.050 --> 00:02:40.700
This is the only way we do it.

37
00:02:41.240 --> 00:02:48.800
Now when I say arrow function, it means arrow function is literally the replacement of this very syntax.

38
00:02:49.010 --> 00:02:55.640
Let me show you how when we write the arrow function, we say const test is equal to we do not write

39
00:02:55.640 --> 00:02:56.870
this function keyboard.

40
00:02:57.350 --> 00:03:00.710
Then we put an arrow after the list of parameters.

41
00:03:00.980 --> 00:03:01.580
That's it.

42
00:03:01.610 --> 00:03:07.940
So the function we had, which was function expression, now the very same syntax is off arrow function.

43
00:03:07.940 --> 00:03:13.280
So in other words you can see that arrow function is actually function expression.

44
00:03:13.280 --> 00:03:20.000
Only now if you want to pass parameters to the arrow function, you have these parentheses where you

45
00:03:20.000 --> 00:03:27.620
can say a comma B in case if you do not have more than one parameter, you can avoid writing these parentheses.

46
00:03:27.620 --> 00:03:30.410
Also, let me show you one practical example.

47
00:03:30.410 --> 00:03:34.910
I will create a function called some, and this is going to be an arrow function.

48
00:03:35.120 --> 00:03:42.920
At the moment I'm giving only one parameter and I will just try to display the value of E and I am calling

49
00:03:42.920 --> 00:03:43.460
the function.

50
00:03:43.460 --> 00:03:46.280
As long as calling is concerned, that is no change in it.

51
00:03:46.280 --> 00:03:49.100
So I say five here, right.

52
00:03:50.150 --> 00:03:53.300
And I'll save this and let's run this call.

53
00:03:53.300 --> 00:03:54.590
I say arrow dart.

54
00:03:54.740 --> 00:03:55.370
Yes.

55
00:03:55.610 --> 00:03:57.170
So we have the output file here.

56
00:03:57.200 --> 00:04:01.730
Now, even if I avoid these parentheses, this is also fine.

57
00:04:01.910 --> 00:04:02.300
Right?

58
00:04:02.300 --> 00:04:08.150
So arrow function gives you easier way, more clear way, as long as the syntax is concerned.

59
00:04:08.360 --> 00:04:12.230
So now if I run the code again, we see that the output is same.

60
00:04:12.230 --> 00:04:16.610
So if you have one parameter, you can avoid writing parentheses.

61
00:04:16.820 --> 00:04:21.560
Assume that you have two parameters, then you should write these parentheses.

62
00:04:21.560 --> 00:04:22.490
There is no other way.

63
00:04:22.910 --> 00:04:28.820
Now one more thing we can discuss here is let's say this function is returning A plus B.

64
00:04:29.300 --> 00:04:33.830
Now, there is only one statement in this particular call, let's say console.log.

65
00:04:33.830 --> 00:04:40.600
Here, I'll pass two parameters five, comma, six and console.log.

66
00:04:40.600 --> 00:04:41.870
Log here.

67
00:04:42.530 --> 00:04:45.560
Let's run the code once we have the output 11.

68
00:04:45.770 --> 00:04:48.710
So we have only one return statement.

69
00:04:49.010 --> 00:04:58.250
So what arrow function says that you can avoid these parentheses and you can keep this in a single line.

70
00:04:58.460 --> 00:05:03.650
If you have just a statement in that two return statement, you do not have to write a return.

71
00:05:04.160 --> 00:05:05.120
Now you see that?

72
00:05:05.190 --> 00:05:10.830
It's just a single line function that it has a written statement, but we do not write it here.

73
00:05:11.280 --> 00:05:14.610
Of course, the first way we wrote was also a correct one.

74
00:05:14.640 --> 00:05:20.670
But in case if you do not want to have a written statement, this is a provision given by arrow function.

75
00:05:20.910 --> 00:05:27.180
These are a few syntactical facilities given by arrow function, and that's why people say that arrow

76
00:05:27.180 --> 00:05:29.460
function is less verbose.

77
00:05:29.730 --> 00:05:33.840
That means you have less code to write and better way to deal with it.

78
00:05:34.380 --> 00:05:40.320
So when it comes to syntax, when it comes to new changes about syntax in arrow function, you can talk

79
00:05:40.320 --> 00:05:46.350
about parenthesis are not required for a single parameter or even the return statement, right that

80
00:05:46.350 --> 00:05:48.870
can be avoided for a single line.

81
00:05:49.080 --> 00:05:52.410
We also write if with s five syntax.

82
00:05:52.680 --> 00:05:52.970
Right.

83
00:05:53.370 --> 00:05:56.790
What isn't an if he if he's immediately invoked function expression.

84
00:05:56.970 --> 00:06:03.990
We do have the provision to write if he with arrow also like if I just write the traditional way of

85
00:06:03.990 --> 00:06:08.100
if he let's say I write code off if he here.

86
00:06:10.300 --> 00:06:12.280
Now this is just a functional expression.

87
00:06:12.280 --> 00:06:19.210
In fact, if I have to convert this into WiFi, what we do is we just do not give any name to the entire

88
00:06:19.210 --> 00:06:19.810
function.

89
00:06:20.440 --> 00:06:24.850
We cover this function into parentheses and then we need to call this.

90
00:06:25.150 --> 00:06:27.940
So this is a function which gets called automatically.

91
00:06:28.240 --> 00:06:29.020
This is iffy.

92
00:06:29.290 --> 00:06:32.830
If it is a function which calls itself let's try this.

93
00:06:32.830 --> 00:06:37.900
First of all, you see this function is called I did not give any name to the function.

94
00:06:38.170 --> 00:06:39.820
I did not even call the function.

95
00:06:40.060 --> 00:06:45.310
But the moment the control comes on this line, it starts executing this function.

96
00:06:45.430 --> 00:06:48.790
We use this if we to avoid global linkages.

97
00:06:49.150 --> 00:06:54.160
But right now my concern is to show that can we right arrow function with this?

98
00:06:54.400 --> 00:06:59.140
Yes, I can remove this function keyboard and you just have to put an arrow.

99
00:06:59.140 --> 00:06:59.650
That's it.

100
00:07:00.310 --> 00:07:05.380
So in a way, you can say that this is immediately involved arrow function, something like this.

101
00:07:06.850 --> 00:07:09.820
Let's try to run this and we get the output.

102
00:07:10.330 --> 00:07:14.830
So with arrow function, if we want to have iffy, we can do that.

103
00:07:15.010 --> 00:07:18.340
Now let's discuss about those three important points.

104
00:07:18.520 --> 00:07:22.570
That is the this object, the arguments object and the new operator.

105
00:07:22.570 --> 00:07:24.760
Assume that I have a function here.

106
00:07:25.540 --> 00:07:25.990
Test.

107
00:07:27.010 --> 00:07:33.430
This is an arrow function and I try to refer the value of this inside this function.

108
00:07:34.510 --> 00:07:37.930
If I'm running this code in browser, the output will be window.

109
00:07:38.230 --> 00:07:40.150
Here it will be the global object.

110
00:07:40.180 --> 00:07:46.120
Now, remember, in the traditional way of function, even today, when you say that I'm writing function

111
00:07:46.120 --> 00:07:49.720
with the traditional syntax, that is not the function expression.

112
00:07:50.020 --> 00:07:53.720
You write the function like this function test.

113
00:07:54.400 --> 00:08:02.290
If you write like this, it means this object can have the local reference in this type of function.

114
00:08:03.250 --> 00:08:10.510
If this function is called with the new keyword, but in arrow function you cannot have the current

115
00:08:10.780 --> 00:08:11.430
reference.

116
00:08:11.440 --> 00:08:14.890
It will always bind to the global environment.

117
00:08:15.190 --> 00:08:18.670
Let's run this call in the browser and see what is the output.

118
00:08:19.950 --> 00:08:22.200
You see that it is the window object.

119
00:08:22.710 --> 00:08:28.620
So now you see that the reference of this is not actually the function itself rather than it is window.

120
00:08:28.650 --> 00:08:30.660
Of course this code is written in the browser.

121
00:08:30.870 --> 00:08:35.880
Even if I put this code inside an object literal, then also it will point to window.

122
00:08:35.909 --> 00:08:36.690
Let's check that.

123
00:08:36.690 --> 00:08:43.110
Also, I'll create an object and I'll create a function here.

124
00:08:43.140 --> 00:08:43.929
Let's test.

125
00:08:44.940 --> 00:08:45.240
Right.

126
00:08:45.580 --> 00:08:47.880
Right now I'm using the traditional way.

127
00:08:47.880 --> 00:08:50.880
The way where object literal method is defined.

128
00:08:51.090 --> 00:08:51.720
Like this.

129
00:08:51.720 --> 00:08:56.100
Only not writing the arrow function and just trying to get the value of this here.

130
00:08:56.850 --> 00:09:01.830
Let's call this my object test and let's run this.

131
00:09:02.760 --> 00:09:03.390
You see that?

132
00:09:03.390 --> 00:09:06.030
It gives you the reference of object.

133
00:09:06.240 --> 00:09:07.410
That is the object literal.

134
00:09:07.620 --> 00:09:12.410
Now, in the same case, we do have a facility to give function expression.

135
00:09:12.420 --> 00:09:15.860
That means I can say a test is equal to that is colon right?

136
00:09:15.870 --> 00:09:17.460
Because I'm inside object literal.

137
00:09:18.030 --> 00:09:19.200
I'll put an arrow here.

138
00:09:19.230 --> 00:09:20.640
So this is an arrow function.

139
00:09:20.970 --> 00:09:23.910
Now, if I run this object, our test.

140
00:09:26.070 --> 00:09:28.740
It's going to show me again the window object.

141
00:09:29.040 --> 00:09:35.370
So in short, this object doesn't work the way it used to work with the traditional function, right?

142
00:09:35.390 --> 00:09:39.660
When it comes to add a function, this doesn't work with arrow function.

143
00:09:40.170 --> 00:09:40.650
Why?

144
00:09:41.040 --> 00:09:45.720
The reason is earlier the function also had a job of class.

145
00:09:46.290 --> 00:09:49.450
That is the function used to act as a class.

146
00:09:49.470 --> 00:09:52.050
Also, depending on the way it is called.

147
00:09:52.290 --> 00:09:56.790
Like if you call the function with the new keyword, then it will behave as a class.

148
00:09:57.030 --> 00:09:59.970
But now arrow function doesn't have that duty.

149
00:10:00.240 --> 00:10:02.190
Arrow function is just a function.

150
00:10:02.460 --> 00:10:06.150
It doesn't have to behave like a class at any point of time.

151
00:10:06.390 --> 00:10:11.010
That's why this is not needed to be referred in anyway.

152
00:10:11.010 --> 00:10:12.330
Inside arrow function.

153
00:10:12.870 --> 00:10:13.860
So this is one thing.

154
00:10:14.230 --> 00:10:14.760
Second.

155
00:10:16.580 --> 00:10:23.390
The arguments object which used to show us the parameter space to the function like this one.

156
00:10:23.900 --> 00:10:30.830
Let me show you that if I passed, let's say four or five whatsoever, and I will just run this.

157
00:10:34.180 --> 00:10:39.290
You see arguments is showing that these are the parameters passed to the function.

158
00:10:39.310 --> 00:10:41.110
But if I convert this into.

159
00:10:44.900 --> 00:10:45.830
At a function.

160
00:10:47.300 --> 00:10:50.490
And remove the function cons test is equal to.

161
00:10:52.870 --> 00:10:53.270
At all.

162
00:10:53.740 --> 00:10:54.880
And arguments.

163
00:10:55.720 --> 00:11:03.520
Now, if I ran this it shows me the add it in chart arguments object doesn't work with it.

164
00:11:03.850 --> 00:11:04.690
So now what?

165
00:11:04.690 --> 00:11:09.870
If you want to implement similar functionality, then we do have the rest parameters.

166
00:11:09.880 --> 00:11:14.800
That is those three darts we have already discussed rest and spread operator in detail.

167
00:11:14.830 --> 00:11:20.580
So you get the idea about how we can deal with similar situation in arrow function.

168
00:11:20.650 --> 00:11:22.960
I mean, you do not have arguments object.

169
00:11:22.960 --> 00:11:25.720
So how will you deal with this kind of functionality?

170
00:11:26.440 --> 00:11:28.950
So you have the rest parameters, right?

171
00:11:28.960 --> 00:11:32.760
So let's say here also one more time we can try.

172
00:11:32.800 --> 00:11:38.950
Do we have already seen in one of the previous question so you just say three dots and you have the

173
00:11:38.950 --> 00:11:39.870
entire adding.

174
00:11:39.970 --> 00:11:41.260
So now you see the output.

175
00:11:42.430 --> 00:11:43.890
That is also one more thing.

176
00:11:43.900 --> 00:11:45.520
You cannot call this function.

177
00:11:45.520 --> 00:11:48.250
That is the arrow function with a new keyword.

178
00:11:48.460 --> 00:11:52.290
Naturally you cannot because this will not act as a class.

179
00:11:52.300 --> 00:11:56.320
So let's say I have this simple function I'm just seeing high inside this.

180
00:11:56.320 --> 00:12:00.640
And what if I say const object is equal to new test?

181
00:12:01.300 --> 00:12:07.750
Now, if this was a traditional function like this function test, we could have done const object to

182
00:12:07.810 --> 00:12:08.590
new test.

183
00:12:08.590 --> 00:12:11.500
In that case this function would have been a class.

184
00:12:11.650 --> 00:12:16.540
But now we don't have that facility because we already have class in E6.

185
00:12:16.540 --> 00:12:18.010
That's why it is not needed.

186
00:12:18.010 --> 00:12:19.480
It's not that something is reduced.

187
00:12:19.690 --> 00:12:21.850
There are less functionalities in the S6.

188
00:12:22.120 --> 00:12:28.090
Actually, that is a better way to deal with a situation rather than the same function used as a class.

189
00:12:28.240 --> 00:12:29.320
Used as a function.

190
00:12:29.410 --> 00:12:30.910
We don't do that now, right?

191
00:12:30.930 --> 00:12:31.600
Not anymore.

192
00:12:32.020 --> 00:12:35.440
So we already have a class keyword to create a class.

193
00:12:35.440 --> 00:12:35.760
Right.

194
00:12:35.770 --> 00:12:38.770
So if I try this suddenly it will not work.

195
00:12:39.010 --> 00:12:40.660
It will give me the added.

196
00:12:41.140 --> 00:12:41.440
Right.

197
00:12:41.440 --> 00:12:42.760
So this is how.

198
00:12:43.750 --> 00:12:45.190
Let me go further here.

199
00:12:46.900 --> 00:12:48.730
So we have the error displayed.

200
00:12:48.730 --> 00:12:50.680
That test is not a constructor.

201
00:12:51.280 --> 00:12:53.860
Now let's discuss related questions of this topic.

202
00:12:54.250 --> 00:12:58.420
The first question is explain the syntactical features of arrow function.

203
00:12:58.930 --> 00:13:04.660
Now, when I say this question, it means if you want to explain all the syntax related changes, then

204
00:13:04.660 --> 00:13:08.290
you can discuss about those parameters that you can avoid.

205
00:13:08.290 --> 00:13:10.480
Parentheses, single line statement.

206
00:13:10.480 --> 00:13:13.090
If you have, you don't need to write the return statement.

207
00:13:13.390 --> 00:13:17.860
All those things you can talk about when this question is asked.

208
00:13:20.150 --> 00:13:24.800
Second question why this does not work in arrow function.

209
00:13:24.830 --> 00:13:30.150
Now, this question can also be asked that does this object work without or function or not?

210
00:13:30.170 --> 00:13:32.090
Then the answer is of course no.

211
00:13:32.390 --> 00:13:38.150
But the reason is that we already have a class schema to deal with the classes.

212
00:13:38.330 --> 00:13:41.600
So we do not need the function to act as a class.

213
00:13:41.810 --> 00:13:48.740
So there is no point that this which actually is used to refer the current context is needed in function.

214
00:13:48.770 --> 00:13:51.710
That's why our function is free from that job.

215
00:13:51.980 --> 00:13:54.800
And that's the reason why this object does not work.

216
00:13:57.700 --> 00:14:02.860
The third question is explain output of the following code with a reason.

217
00:14:03.610 --> 00:14:08.620
Now, I have already discussed this that I am writing the arrow function inside object.

218
00:14:08.950 --> 00:14:13.960
Normally if you write with the traditional way, then Turtle is going to refer to the current context.

219
00:14:13.960 --> 00:14:15.040
That is the object.

220
00:14:15.430 --> 00:14:20.200
But here, because I'm using the arrow function, it's going to refer the global context.

221
00:14:20.470 --> 00:14:23.350
So if you are in the browser, it will be the window.

222
00:14:23.810 --> 00:14:30.370
Fourth question is how can you handle arguments object like functionality in arrow function.

223
00:14:30.760 --> 00:14:36.760
So like because arrow function doesn't support arguments object, you have the rest parameters which

224
00:14:36.760 --> 00:14:41.950
can be used with arrow function to deal with all the parameters passed to the function.

225
00:14:44.350 --> 00:14:48.580
The fifth question is, can you write if you with arrow functions index?

226
00:14:48.790 --> 00:14:49.650
Yes, of course.

227
00:14:49.670 --> 00:14:51.190
Have you have already checked that?

228
00:14:51.640 --> 00:14:58.750
If we use arrow function and if we want to have if free that is, it calls it immediately, automatically

229
00:14:58.750 --> 00:15:00.100
and calls itself.

230
00:15:00.130 --> 00:15:01.060
You can do that.

231
00:15:01.240 --> 00:15:02.170
This is the syntax.

232
00:15:02.180 --> 00:15:04.600
This is the code which we tried a few minutes back.

