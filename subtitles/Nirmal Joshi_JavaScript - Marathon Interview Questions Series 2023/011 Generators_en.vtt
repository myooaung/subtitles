WEBVTT
1
00:00:00.090 --> 00:00:03.930
Now we are going to discuss another concept called generators.

2
00:00:04.440 --> 00:00:07.440
So this topic will have fire related questions.

3
00:00:10.120 --> 00:00:13.540
Generators can help you to pause and resume the call.

4
00:00:13.810 --> 00:00:17.050
That is the simple definition of generator functions.

5
00:00:17.410 --> 00:00:20.980
Let's get clear with the generators in the most simplified way.

6
00:00:21.310 --> 00:00:25.540
Normally when you write a function, it returns a single value.

7
00:00:25.780 --> 00:00:33.940
You can think of generators as a kind of function which can return multiple values in phases.

8
00:00:34.360 --> 00:00:35.750
Enough of definition.

9
00:00:35.770 --> 00:00:38.380
Let's try practically the function.

10
00:00:38.530 --> 00:00:43.810
Star is the keyword used to define a generator function.

11
00:00:44.230 --> 00:00:48.220
Yield is an operator which pauses the generator.

12
00:00:48.610 --> 00:00:55.300
Yield also helps to receive input and send output, but that is the next phase.

13
00:00:55.600 --> 00:01:04.390
At the moment, let's use function, asterisk, keyword and yield operator to get the idea of basic

14
00:01:04.390 --> 00:01:06.910
functionality of generator function.

15
00:01:07.210 --> 00:01:09.580
So let's define a generator function.

16
00:01:10.640 --> 00:01:16.940
I'll say concert for example, DJ and function that is generator function as a function.

17
00:01:16.970 --> 00:01:18.230
This is absolutely fine.

18
00:01:18.260 --> 00:01:21.200
Now, the difference is you put a star here.

19
00:01:23.130 --> 00:01:27.270
Sometimes we will see that people get confused with putting this star.

20
00:01:27.570 --> 00:01:30.690
Some people write like this or like this.

21
00:01:31.380 --> 00:01:33.090
All the ways are correct.

22
00:01:33.240 --> 00:01:40.030
But most of the commonly used way with generator functions is that we use the star along with the function,

23
00:01:40.050 --> 00:01:41.430
and then we put a space.

24
00:01:41.880 --> 00:01:45.780
But even if you do not have a space right, then also it's fine.

25
00:01:46.080 --> 00:01:50.220
And if you have this star with this bracket, that's also not a problem.

26
00:01:50.490 --> 00:01:53.790
I'm just writing a statement here saying console.log.

27
00:01:55.000 --> 00:01:57.280
Let's say I want to display.

28
00:01:57.280 --> 00:01:57.670
Hello.

29
00:01:58.030 --> 00:02:02.590
Then I just write yield the moment you write this yield operator.

30
00:02:02.800 --> 00:02:05.890
It means this is where the function will pause.

31
00:02:06.190 --> 00:02:09.250
I'll explain you with some illustration, but let's proceed for that.

32
00:02:09.340 --> 00:02:12.310
Another statement I want is hello.

33
00:02:12.340 --> 00:02:14.590
Then the world statement again.

34
00:02:14.590 --> 00:02:17.020
I just want to have the yield operator.

35
00:02:17.380 --> 00:02:20.380
And next, I'll put a cancel log alert.

36
00:02:20.380 --> 00:02:22.960
One more statement and let's say Galaxy.

37
00:02:23.500 --> 00:02:25.750
Now, how am I going to call the function?

38
00:02:26.020 --> 00:02:27.910
I will create an object.

39
00:02:27.910 --> 00:02:30.610
Let's a generator object is equal to.

40
00:02:30.610 --> 00:02:32.830
I'm calling the generator function.

41
00:02:33.460 --> 00:02:40.510
Now, if you see this line number eight, when a generator function is called, it does not call the

42
00:02:40.510 --> 00:02:41.170
function.

43
00:02:41.200 --> 00:02:44.770
Instead, it returns a generator object.

44
00:02:45.340 --> 00:02:49.900
So the object here you see will receive the generator object.

45
00:02:49.900 --> 00:02:51.970
Let's try to display the value of it.

46
00:02:52.360 --> 00:02:53.620
I'll say console.log.

47
00:02:53.890 --> 00:02:56.740
The generator object value I want to see.

48
00:02:57.520 --> 00:03:01.780
I run the correlation node generator dot Jess.

49
00:03:03.810 --> 00:03:06.540
So you can imagine that you are still here.

50
00:03:06.780 --> 00:03:08.160
Now, that is another matter.

51
00:03:08.340 --> 00:03:14.400
Our next method, which will start the execution and will continue till the yield.

52
00:03:14.400 --> 00:03:19.950
Operator When it reaches to the yield operator, that's where it is going to stop.

53
00:03:20.220 --> 00:03:26.370
Let's try to put a next statement now and remove this console.log as it is not needed.

54
00:03:27.300 --> 00:03:29.430
I said go bigger dart next.

55
00:03:29.910 --> 00:03:30.690
Let's run this.

56
00:03:33.120 --> 00:03:35.880
So it has executed the full statement.

57
00:03:36.000 --> 00:03:40.500
And then when it found the yield operator, it stopped the execution.

58
00:03:40.650 --> 00:03:47.910
The next method actually returns an object which has two keys which we have already seen with the iterator.

59
00:03:48.030 --> 00:03:54.360
The first is value and the other is boolean, which shows the next status.

60
00:03:54.810 --> 00:03:57.060
Let's try to print value off.

61
00:03:57.210 --> 00:03:58.080
Next method.

62
00:03:58.200 --> 00:04:00.330
Either I take the value in some variable.

63
00:04:00.360 --> 00:04:01.980
I can see some object.

64
00:04:01.980 --> 00:04:05.040
I mean const or is equal to.

65
00:04:05.070 --> 00:04:07.290
We want to check what the next returns.

66
00:04:07.590 --> 00:04:10.140
So I'll say console.log.

67
00:04:11.100 --> 00:04:12.030
The value of all.

68
00:04:12.990 --> 00:04:14.010
Let's run the code.

69
00:04:16.230 --> 00:04:17.610
So Halo is executed.

70
00:04:17.850 --> 00:04:24.000
And then when it found a yield operator, it stopped and it returned to the object.

71
00:04:24.000 --> 00:04:30.270
Like this value and the status done as you see that the value is undefined.

72
00:04:30.540 --> 00:04:37.890
The reason is, at the moment I have not returned any value with yield, which you can by giving a value

73
00:04:37.890 --> 00:04:38.910
along with the yield.

74
00:04:39.000 --> 00:04:43.710
Say, for example, I just want to try yield value.

75
00:04:43.980 --> 00:04:46.140
It might be any value which you are returning.

76
00:04:46.380 --> 00:04:49.560
So yield itself is capable of returning any value.

77
00:04:49.710 --> 00:04:50.640
Let's try this.

78
00:04:50.820 --> 00:04:51.450
I'll save.

79
00:04:53.460 --> 00:04:54.000
Run it.

80
00:04:54.420 --> 00:05:00.870
Now, as you can see here, the value says that it is yield value, which was undefined earlier and

81
00:05:00.870 --> 00:05:02.670
the status is still false.

82
00:05:03.030 --> 00:05:09.120
Now, if you want to execute this entire function because there are two yield operators return here,

83
00:05:09.330 --> 00:05:12.270
so we'll have to write multiple next methods.

84
00:05:12.570 --> 00:05:14.400
Let's do that again.

85
00:05:14.400 --> 00:05:17.090
I'll say g object dart next.

86
00:05:17.100 --> 00:05:20.350
I want to move to the next to yield even.

87
00:05:20.760 --> 00:05:24.390
What we can do here is we can directly console.log.

88
00:05:26.390 --> 00:05:29.270
And also move to the next yield.

89
00:05:29.570 --> 00:05:32.330
So we do not need to write more lines here now.

90
00:05:32.540 --> 00:05:39.920
So this will also move to the next yield and will also display the return the value of the next method.

91
00:05:39.920 --> 00:05:40.340
Call.

92
00:05:40.520 --> 00:05:41.900
Let me write three times here.

93
00:05:42.230 --> 00:05:43.340
Or even four times.

94
00:05:43.670 --> 00:05:44.810
Now let's run the call.

95
00:05:45.840 --> 00:05:48.570
The first hello is executed here.

96
00:05:48.840 --> 00:05:52.290
Then comes the return value by this next method.

97
00:05:52.620 --> 00:05:57.600
Again, we write the next, so it's going to move further when it goes on.

98
00:05:57.670 --> 00:06:01.650
Third next it is going to execute this and galaxy.

99
00:06:01.920 --> 00:06:07.710
And for the last next I've just added for the sake of adding it just to show that there is no value

100
00:06:07.830 --> 00:06:09.400
getting returned for the last.

101
00:06:09.420 --> 00:06:11.220
Next, let me remove this.

102
00:06:11.340 --> 00:06:14.430
Now, again, we tried the same code.

103
00:06:16.500 --> 00:06:17.550
So this is the output.

104
00:06:17.850 --> 00:06:23.190
Inside this generator function, we are moving step by step with the next method.

105
00:06:23.430 --> 00:06:32.970
Now this next method we have already seen in the iterator section, it means generators are iterable

106
00:06:32.970 --> 00:06:33.540
as well.

107
00:06:33.810 --> 00:06:41.550
So instead of writing this next what we can do, which is a more preferred way, we are going to put

108
00:06:41.550 --> 00:06:42.620
an iterator here.

109
00:06:42.930 --> 00:06:46.710
And I say after that I'm going to put a far off loop elsaffar.

110
00:06:47.690 --> 00:06:54.260
Let's select all of geo BDA, which is the generator object.

111
00:06:54.770 --> 00:06:58.880
Now, here, I'll simply try to display the value of all.

112
00:06:59.960 --> 00:07:00.830
Let's run the call.

113
00:07:01.970 --> 00:07:09.710
Now you see that instead of writing the next method multiple times, you put the loop that is far off

114
00:07:09.710 --> 00:07:13.910
loop and you can iterate through the entire generator function.

115
00:07:14.480 --> 00:07:15.620
Isn't it fantastic?

116
00:07:16.660 --> 00:07:21.040
And because here you see that generator functions, are it rebels?

117
00:07:21.310 --> 00:07:24.970
You can use the spread operator with it as well.

118
00:07:25.240 --> 00:07:30.730
So instead of writing like this, say, for example, when I do not want the follow up and you want

119
00:07:30.730 --> 00:07:32.620
the results inside an addy.

120
00:07:32.800 --> 00:07:39.610
What you can do is you can directly display the value of this generator object, which will not be a

121
00:07:39.610 --> 00:07:40.520
generator object.

122
00:07:40.540 --> 00:07:44.250
Later on, when I put this inside of the addy.

123
00:07:44.620 --> 00:07:48.580
So whatever the generator function is going to return because it is it rebel.

124
00:07:48.760 --> 00:07:50.910
You can use the spread operator with it.

125
00:07:50.920 --> 00:07:54.220
So this will actually create an array with return values.

126
00:07:54.220 --> 00:07:58.780
All returned values by this generator function will be assigned to this object.

127
00:07:58.790 --> 00:08:00.540
So now this is a kind of addy.

128
00:08:00.550 --> 00:08:01.690
So let's try this out.

129
00:08:01.690 --> 00:08:05.140
So I'll clear the screen first and run the code again.

130
00:08:05.350 --> 00:08:13.030
So now you see that this entire geo BGA contains the values which the generator function was returning

131
00:08:13.600 --> 00:08:15.010
in the iterator section.

132
00:08:15.190 --> 00:08:18.730
We tried a core sample to iterate through an object.

133
00:08:18.730 --> 00:08:22.330
Literal generator works best with it readers.

134
00:08:22.630 --> 00:08:31.240
This was the code we tried with iterator where we created a matter with symbol iterator key and we returned

135
00:08:31.240 --> 00:08:36.549
the iterator object to iterate through a non-trivial data structure.

136
00:08:36.909 --> 00:08:42.100
The same code we can convert with generators and that will be even easier.

137
00:08:42.250 --> 00:08:45.100
So like this object we have start and end.

138
00:08:45.550 --> 00:08:52.120
Of course this system iterator is needed, but we are going to convert this into a generator function

139
00:08:52.120 --> 00:08:52.810
and that's it.

140
00:08:53.020 --> 00:09:00.790
This actually converts this entire system iterator method as a triple because now it is a generator

141
00:09:00.790 --> 00:09:01.240
function.

142
00:09:01.780 --> 00:09:06.610
So what I can do, I do not need all these ideas and anything like this.

143
00:09:06.610 --> 00:09:10.360
You and I do not need to return this object as well.

144
00:09:10.600 --> 00:09:16.930
Instead of this, you can simply put a far loop here and let's say let counter is equal to this dot

145
00:09:17.200 --> 00:09:18.070
start number.

146
00:09:18.760 --> 00:09:25.330
The counter should go till end and the counter will be incremented by one.

147
00:09:25.810 --> 00:09:29.780
The next thing you need is that you are going to yield the counter.

148
00:09:29.830 --> 00:09:30.400
That's it.

149
00:09:32.130 --> 00:09:39.990
So now you can compare the code which we wrote like this for Iterator, and now we have this code where

150
00:09:40.110 --> 00:09:45.060
it is going to iterate through this non-trivial data structure.

151
00:09:45.300 --> 00:09:48.330
Let's try this and see what is the output.

152
00:09:48.660 --> 00:09:50.400
The loop will remain as it is.

153
00:09:52.620 --> 00:09:58.980
So now you can see that this thing is a rebel just with the help of generator functions.

154
00:09:59.250 --> 00:10:06.720
In fact, to make this syntax easier, you can certainly remove this function keyword and this star

155
00:10:06.720 --> 00:10:11.820
you can put before the symbol iterator and you can follow the E-6 syntax.

156
00:10:11.820 --> 00:10:12.780
That's also fine.

157
00:10:12.930 --> 00:10:13.890
This is even better.

158
00:10:14.100 --> 00:10:18.870
Let me say in rerun, just to check whether everything is working fine or not.

159
00:10:19.890 --> 00:10:24.390
And here also, instead of writing the follow you can use.

160
00:10:24.720 --> 00:10:26.700
Let's say you have the object.

161
00:10:26.710 --> 00:10:30.030
This is the object which we have made it terrible.

162
00:10:30.150 --> 00:10:31.920
Now see the most amazing thing here.

163
00:10:32.520 --> 00:10:34.350
I'll directly say console.log.

164
00:10:34.740 --> 00:10:35.940
Dot, dot, dot, spread.

165
00:10:35.940 --> 00:10:38.190
Operator, I'm using object.

166
00:10:39.180 --> 00:10:39.740
That's it.

167
00:10:42.400 --> 00:10:46.540
So this is an ad where you have the entire list of values.

168
00:10:47.020 --> 00:10:53.410
So now we know that generators are really working well with traders because generators are iterable

169
00:10:53.410 --> 00:10:53.920
as well.

170
00:10:54.040 --> 00:10:59.890
The yield operator, which we are using, is something we can use only in generator functions.

171
00:11:00.070 --> 00:11:05.680
When it comes to recursive function or even calling one generator function from another.

172
00:11:06.040 --> 00:11:10.840
There is a specific syntax that is by using yield and asterisk.

173
00:11:10.960 --> 00:11:11.650
Like this.

174
00:11:12.790 --> 00:11:14.260
Let's try a code sample.

175
00:11:14.470 --> 00:11:19.630
I will create a generator function as a function start generator.

176
00:11:20.080 --> 00:11:23.800
Right now I'm putting just a statement here saying that.

177
00:11:24.100 --> 00:11:24.490
Hi.

178
00:11:25.660 --> 00:11:30.460
Now I am creating another generator, let's say function star generator one.

179
00:11:31.060 --> 00:11:36.820
Ideally, when you have to call this generator, that is this one you will use gone.

180
00:11:37.120 --> 00:11:44.200
Let's say the generator object is equal to the function name is generator.

181
00:11:44.890 --> 00:11:48.090
Then you'll see g dot next.

182
00:11:48.100 --> 00:11:53.620
So you are actually calling the generator function because we know that if it is a generator function,

183
00:11:53.620 --> 00:11:58.330
we need to move the function pointer using the next method.

184
00:11:58.810 --> 00:12:06.610
Now if you call this generator, one that is also given is equal to generator one and given next.

185
00:12:07.390 --> 00:12:13.180
Now, if you look at the architecture of this code, we have two generator functions here and the generator,

186
00:12:13.180 --> 00:12:16.750
one is actually calling the generator function here.

187
00:12:17.350 --> 00:12:18.670
Let's run the code first.

188
00:12:19.000 --> 00:12:19.900
I'll send Node.

189
00:12:20.970 --> 00:12:21.950
Generator Dot.

190
00:12:22.830 --> 00:12:25.230
So here this line is executed.

191
00:12:25.530 --> 00:12:32.610
In case if you want to call this function directly, then you have another syntax as well.

192
00:12:32.970 --> 00:12:36.660
That is, you can use the yield function and you put an asterisk here.

193
00:12:36.930 --> 00:12:42.470
Then you say n this will help you to call that generator function.

194
00:12:42.480 --> 00:12:44.990
As you can see that the function is executed.

195
00:12:45.000 --> 00:12:51.930
If you had to write the yield outside any generator function, it is not allowed because yield is something

196
00:12:51.930 --> 00:12:54.270
which you have to put inside a generator function.

197
00:12:54.480 --> 00:13:01.830
But here this situation can be very well handled with yield asterisk and then you give the generator

198
00:13:01.830 --> 00:13:04.740
function in case if you have a recursive function.

199
00:13:04.770 --> 00:13:08.310
Now let me just show you one simple syntax of recursive function.

200
00:13:08.310 --> 00:13:11.310
Let's say I have a function called factorial.

201
00:13:11.820 --> 00:13:13.980
Now what is a recursive function?

202
00:13:13.980 --> 00:13:19.620
A recursive function is that you may have some if condition here and then you may want to write some

203
00:13:19.620 --> 00:13:25.230
exit statement that is to terminate the execution and here you will call the factorial function.

204
00:13:25.500 --> 00:13:31.620
So right now what we are doing is that we are referring we are calling the factorial function from the

205
00:13:31.620 --> 00:13:32.790
function itself.

206
00:13:33.030 --> 00:13:37.110
It's a kind of endless execution unless you put the if in a proper way.

207
00:13:37.620 --> 00:13:39.960
So this is a recursion now in this case.

208
00:13:39.960 --> 00:13:43.260
Also, if you want to call, let's see, this is a generator function.

209
00:13:43.260 --> 00:13:49.530
Assume that this is a generator function, then you can use the yield and star of course in that case

210
00:13:49.530 --> 00:13:54.450
also you need to have proper conditions to come out of the execution.

211
00:13:54.570 --> 00:14:00.690
So in case if you want to call the generator function from another one or you are implementing recursion

212
00:14:00.690 --> 00:14:05.880
with generator functions, then you can use the yield and asterisk syntax.

213
00:14:06.300 --> 00:14:12.420
The generator object has next matter which we have already seen, which returns object like this.

214
00:14:12.660 --> 00:14:17.370
It also has two other methods return method and true method.

215
00:14:17.820 --> 00:14:24.390
Return method is more or less similar to the next method, but it returns the object like this where

216
00:14:24.390 --> 00:14:29.490
you have the value and done will always be true and it terminates the generator.

217
00:14:30.590 --> 00:14:34.250
So return matter is used to terminate the generator.

218
00:14:34.250 --> 00:14:35.360
Here, let's try this.

219
00:14:35.360 --> 00:14:38.150
I'll create one generator function.

220
00:14:40.770 --> 00:14:43.050
Sorry I missed the generator.

221
00:14:43.140 --> 00:14:44.260
That is the asterisk.

222
00:14:44.310 --> 00:14:45.990
Now, let's say yield.

223
00:14:46.500 --> 00:14:47.970
I'll return straightaway.

224
00:14:48.000 --> 00:14:48.480
One.

225
00:14:49.830 --> 00:14:51.690
And another yield.

226
00:14:54.230 --> 00:14:54.980
And say to.

227
00:14:56.190 --> 00:14:59.010
Now I'll create the gender object.

228
00:15:03.020 --> 00:15:06.320
Let's try this console.log generator object.

229
00:15:07.720 --> 00:15:09.130
Not next at the moment.

230
00:15:09.130 --> 00:15:10.810
I'll try with next method only.

231
00:15:11.080 --> 00:15:14.110
So I'll write the next method three times.

232
00:15:14.920 --> 00:15:15.610
Let me do that.

233
00:15:17.700 --> 00:15:22.650
And we are straightaway displaying the return to value by the next method.

234
00:15:24.320 --> 00:15:25.070
Let's run this.

235
00:15:25.080 --> 00:15:30.710
Now you see that for the first two next methods, because we have already seen the execution, that

236
00:15:30.710 --> 00:15:34.700
once you start, once you write this statement, the binder is here.

237
00:15:35.480 --> 00:15:39.080
When you say the next matter, it moves to the next value.

238
00:15:39.200 --> 00:15:46.280
So this is executed because yield is something which pauses the execution, then the second next will

239
00:15:46.280 --> 00:15:47.960
move to the next line.

240
00:15:48.680 --> 00:15:55.460
The last next is going to say that now done is true and there is no value return because there is no

241
00:15:55.490 --> 00:15:56.990
yield for this.

242
00:15:56.990 --> 00:15:57.440
Next.

243
00:15:57.890 --> 00:16:03.170
Now you see that the done true is displayed at the last next method call.

244
00:16:03.470 --> 00:16:05.990
Let me just see written here.

245
00:16:06.650 --> 00:16:08.900
I'll save this and run it again.

246
00:16:11.010 --> 00:16:17.450
Now, if you compare the output here in the second call itself, it says that the value is undefined

247
00:16:17.520 --> 00:16:18.720
and that is true.

248
00:16:19.080 --> 00:16:27.270
It means that on the second call, because we have used the return method, it has terminated the generator.

249
00:16:27.570 --> 00:16:28.020
Right.

250
00:16:28.020 --> 00:16:31.010
And it has made this done is equal call to true.

251
00:16:31.030 --> 00:16:34.110
So now there is no more further execution possible.

252
00:16:34.230 --> 00:16:36.570
The same thing you find right here on the first line.

253
00:16:36.570 --> 00:16:39.750
Let's set it on here and I'll put next here.

254
00:16:39.750 --> 00:16:42.960
It doesn't matter whether I write next or not, but let's write it.

255
00:16:44.720 --> 00:16:50.660
Now, as you can see all three times, that is no value returned by yield because the generator function

256
00:16:50.660 --> 00:16:53.240
is terminated on the first call itself.

257
00:16:53.630 --> 00:16:59.150
So if you have a situation where you have a condition and then you want to come out of the generator

258
00:16:59.150 --> 00:17:01.730
function, you want to terminate the generator function.

259
00:17:01.940 --> 00:17:03.110
You can write the return.

260
00:17:03.110 --> 00:17:04.869
In fact, you can give a message also.

261
00:17:04.880 --> 00:17:07.310
Next method also takes a parameter if you want.

262
00:17:07.369 --> 00:17:09.109
Same way you can say that.

263
00:17:09.200 --> 00:17:14.000
Let's say there was a condition satisfied and you wanted to come out of the generator.

264
00:17:14.000 --> 00:17:17.000
I just say condition none or satisfied.

265
00:17:17.000 --> 00:17:17.450
Whatever.

266
00:17:17.660 --> 00:17:18.560
I'll just see if this.

267
00:17:20.619 --> 00:17:22.780
So now you see the value is conditioned.

268
00:17:22.780 --> 00:17:24.790
Done and done is true.

269
00:17:25.240 --> 00:17:31.120
So this is how they're done is useful to deal with termination of generator function.

270
00:17:31.660 --> 00:17:38.350
Now in this example, we have already seen that we can terminate the generator function using return.

271
00:17:38.590 --> 00:17:46.270
You can also suspend the termination if you are using finally and you use the yield statement in it.

272
00:17:46.540 --> 00:17:47.950
Let me show you practically.

273
00:17:47.950 --> 00:17:49.990
Then you will have a clear understanding.

274
00:17:49.990 --> 00:17:51.460
Let's say I have a try block here.

275
00:17:54.450 --> 00:18:03.630
And the yield statements are placed inside this try here I'm going to use finally now I just use yield

276
00:18:04.020 --> 00:18:10.050
and I will return finally here just to get the idea that this is actually returned by the final yield.

277
00:18:10.230 --> 00:18:12.030
Now here I have this geometry.

278
00:18:12.210 --> 00:18:14.610
I'll see g object next.

279
00:18:14.910 --> 00:18:19.830
Let me also put a console.log here so that I get the output.

280
00:18:20.890 --> 00:18:22.930
So the first is the next statement.

281
00:18:23.230 --> 00:18:27.280
The second line I'm going to write is again, the next statement.

282
00:18:27.700 --> 00:18:29.830
Let's run this and see what is the output.

283
00:18:30.220 --> 00:18:34.060
So both the cases it sees done is equal to false.

284
00:18:34.420 --> 00:18:36.550
Let me commend this deal at the moment.

285
00:18:36.970 --> 00:18:39.070
And here I am going to write right on.

286
00:18:39.100 --> 00:18:39.980
Let's try it again.

287
00:18:40.000 --> 00:18:41.110
So now what happens?

288
00:18:41.470 --> 00:18:43.600
First case that is equal to false.

289
00:18:43.600 --> 00:18:45.850
The second case it is done is true.

290
00:18:45.880 --> 00:18:50.380
The reason is we have to use the return statement which terminates the generator.

291
00:18:50.740 --> 00:18:54.970
Now, if I just uncomment this line and if I run.

292
00:18:57.850 --> 00:19:01.840
You see, the second one is not yet terminated.

293
00:19:02.050 --> 00:19:03.800
The value is finally.

294
00:19:03.820 --> 00:19:09.360
This shows that the yield statement of finally is executed and done.

295
00:19:09.640 --> 00:19:11.890
Is still not true.

296
00:19:12.070 --> 00:19:15.550
That means the suspension is executed.

297
00:19:15.670 --> 00:19:22.480
When I wrote this yield in finally the return methods termination is suspended.

298
00:19:22.870 --> 00:19:28.210
So this is another syntax which you can use sometimes when the termination is to be suspended.

299
00:19:28.840 --> 00:19:32.050
The next method we are discussing is the true method.

300
00:19:32.890 --> 00:19:40.180
That through method throws an exception at the location of yield, which made the last suspension in

301
00:19:40.180 --> 00:19:41.410
the generator function.

302
00:19:41.890 --> 00:19:48.730
It means that, for example, in this case, instead of writing, finally, I'll just put a catch here

303
00:19:48.910 --> 00:19:54.310
and let's say added header object and instead of having a yield statement.

304
00:19:54.820 --> 00:19:59.710
Now I'll say console.log and display the add on whatever the edit is.

305
00:19:59.710 --> 00:20:02.950
So I'm going to join the error era.

306
00:20:04.060 --> 00:20:04.600
That's it.

307
00:20:06.350 --> 00:20:12.470
Now, instead of this return statement, I use just a true statement through matter that is which will

308
00:20:12.470 --> 00:20:13.340
throw the at it.

309
00:20:13.670 --> 00:20:17.690
And as you see that the first next did return this object.

310
00:20:18.020 --> 00:20:25.400
But then because we have the throw right now see here return or through which I have shown this is just

311
00:20:25.400 --> 00:20:28.200
an example or a syntax or how does it work?

312
00:20:28.220 --> 00:20:29.360
That's what I'm discussing.

313
00:20:29.360 --> 00:20:29.660
Right?

314
00:20:29.690 --> 00:20:32.730
You have to go related with some practical situation.

315
00:20:32.750 --> 00:20:35.780
We are also going to see a few situations where we'll be using it.

316
00:20:35.780 --> 00:20:41.540
But at the same time, you have to understand that when I use the true statement, that means if there

317
00:20:41.540 --> 00:20:45.560
is an error condition, I'm going to write true or maybe return.

318
00:20:45.830 --> 00:20:52.250
But all these matters will be in a kind of if condition or in some situation only we are going to use

319
00:20:52.250 --> 00:20:52.530
it.

320
00:20:52.550 --> 00:20:52.820
Right?

321
00:20:52.820 --> 00:20:57.440
So there will always be an if condition, maybe switch case where you see that if certain values are

322
00:20:57.830 --> 00:21:04.730
or conditions are not satisfied or maybe satisfied, then you want to terminate or generate the error

323
00:21:05.030 --> 00:21:06.480
as long as error is concerned.

324
00:21:06.500 --> 00:21:13.040
Anyway, whenever there is an error generated by a try catch, which you generally use to handle the

325
00:21:13.040 --> 00:21:19.250
JavaScript errors, that's where you can have the generator function object, not through method.

326
00:21:19.700 --> 00:21:27.280
In this section we have just seen the syntax of generators and how generators are working with it returns

327
00:21:27.290 --> 00:21:30.510
also as long as the practical implementation is concerned.

328
00:21:30.530 --> 00:21:37.850
I would like to underline this that generator functions are rarely used in your JavaScript code, but

329
00:21:37.850 --> 00:21:44.330
yes, there are situations where you have the asynchronous processes where it returns and generators

330
00:21:44.690 --> 00:21:45.380
combined.

331
00:21:45.530 --> 00:21:51.070
They can work well and do see how generators and integrators with asynchronous processes work.

332
00:21:51.080 --> 00:21:57.890
You can check the asynchronous section that I have discussed asynchronous iterator and generators concept.

333
00:21:58.250 --> 00:22:00.530
Let's discuss the related questions of this topic.

334
00:22:00.950 --> 00:22:03.860
The first question is what are generator functions?

335
00:22:04.130 --> 00:22:05.390
Explain the syntax.

336
00:22:05.630 --> 00:22:06.950
So generator functions.

337
00:22:07.220 --> 00:22:14.090
We have seen that they give you a way where you can pause a process and then whenever you want to continue

338
00:22:14.090 --> 00:22:15.290
for that after some time.

339
00:22:15.290 --> 00:22:16.700
Even then, it's possible.

340
00:22:17.480 --> 00:22:23.540
The syntax is like this where we are using an asterisk with the function and we use the yield operator

341
00:22:23.810 --> 00:22:28.640
to pause the execution and next method to proceed further.

342
00:22:32.190 --> 00:22:34.980
The second question is which is the right syntax?

343
00:22:35.190 --> 00:22:36.420
Function asterisk.

344
00:22:36.420 --> 00:22:41.160
Then space or function, then space and asterisk.

345
00:22:41.460 --> 00:22:47.910
See, we have already seen earlier in the beginning that we whether you write space after the star,

346
00:22:47.910 --> 00:22:54.680
before the star, or even if you don't give us space in between, that is the function parentheses.

347
00:22:54.690 --> 00:22:55.680
Start in brackets.

348
00:22:55.680 --> 00:22:56.820
You do not give any space.

349
00:22:56.820 --> 00:22:57.840
Doesn't matter, right?

350
00:22:58.080 --> 00:22:59.580
All these indexes are valid.

351
00:22:59.580 --> 00:23:06.330
But at the same time, I would just like to emphasize that function star space is the commonly used

352
00:23:06.510 --> 00:23:07.200
syntax.

353
00:23:07.200 --> 00:23:10.830
So we go with this way of writing the generator function.

354
00:23:11.160 --> 00:23:15.450
The third question is explain all methods of generator object.

355
00:23:15.630 --> 00:23:20.670
So the three matters which we have discussed, the next method which actually moves the function pointer

356
00:23:20.670 --> 00:23:24.930
to the next line from the next, that is the last suspended yield.

357
00:23:25.260 --> 00:23:26.370
It proceeds further.

358
00:23:27.540 --> 00:23:30.840
Whereas the return allows you to terminate the function.

359
00:23:32.250 --> 00:23:38.280
And the mattered, which can help you to raise an error with the generator object.

360
00:23:38.280 --> 00:23:42.390
So these are the three methods related to the generator object.

361
00:23:44.770 --> 00:23:48.350
The first question is explain the use of heeled star.

362
00:23:48.370 --> 00:23:49.660
That is a yield asterisk.

363
00:23:49.990 --> 00:23:55.630
So we have seen that it's about calling a generator function from another generator function.

364
00:23:55.630 --> 00:24:02.110
Or even when you have to call a recursive generator function, then you have to use the yield star syntax.

365
00:24:04.540 --> 00:24:10.120
The fifth question is, can you prevent the return from terminating the generator?

366
00:24:10.150 --> 00:24:11.170
Yes, absolutely.

367
00:24:11.200 --> 00:24:15.670
Of course, there should also be a conditional way to deal with this situation.

368
00:24:15.670 --> 00:24:18.940
But when you see it are done, it terminates the execution.

369
00:24:18.940 --> 00:24:25.420
But let's say if you write a yield statement in finally like this, then it will certainly prevent the

370
00:24:25.420 --> 00:24:28.360
return from terminating the generator.

