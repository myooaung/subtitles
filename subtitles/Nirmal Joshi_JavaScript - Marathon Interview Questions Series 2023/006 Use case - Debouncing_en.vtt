WEBVTT
1
00:00:10.090 --> 00:00:17.410
The bouncing is good to have when you implement search like functionality or auto complete feature while

2
00:00:17.560 --> 00:00:22.210
typing, especially when the search is making API calls on the server.

3
00:00:23.140 --> 00:00:30.880
For example, you have a text box and on input, you make an API call to perform search.

4
00:00:31.270 --> 00:00:33.640
It will be numerous calls to the server.

5
00:00:34.030 --> 00:00:38.710
In such case, the bouncing is the best way to improve the performance.

6
00:00:39.100 --> 00:00:40.360
Let's see an example.

7
00:00:40.690 --> 00:00:44.170
I'm going to have an input box and on input.

8
00:00:44.710 --> 00:00:51.430
Let's say the search function is called and I'm displaying the key count every time the key is pressed.

9
00:00:52.270 --> 00:00:54.790
That's where the API call is generally made.

10
00:00:55.090 --> 00:01:02.350
But if we use if we refer the API count, then you will see how many times the API should be called.

11
00:01:03.490 --> 00:01:10.030
So this is just the very same example of the which we implemented the same code, but with a different

12
00:01:10.030 --> 00:01:10.660
scenario.

13
00:01:11.470 --> 00:01:14.590
So let me just show you the output for this as well.

14
00:01:15.070 --> 00:01:16.960
Now here is the text box.

15
00:01:17.320 --> 00:01:21.100
Let me just type test search.

16
00:01:22.830 --> 00:01:30.870
Now you observe that the actual keys we have placed is 12, whereas the count that is the API call should

17
00:01:30.870 --> 00:01:33.000
have been made only seven times.

18
00:01:33.600 --> 00:01:34.650
The more you type.

19
00:01:36.180 --> 00:01:38.010
The more call difference will get.

20
00:01:39.100 --> 00:01:43.930
So this is one of the scenario where the bounce can be very handy.

21
00:01:44.200 --> 00:01:50.560
It can really reduce the API calls or any process you attach with this kind of approach.

