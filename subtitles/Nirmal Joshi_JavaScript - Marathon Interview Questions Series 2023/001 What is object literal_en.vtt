WEBVTT
1
00:00:00.090 --> 00:00:01.440
This section of old.

2
00:00:01.440 --> 00:00:07.350
Yes, we are discussing very important related questions of object literal.

3
00:00:08.039 --> 00:00:10.500
The main question is what is an object literal?

4
00:00:10.500 --> 00:00:12.510
And there will be five related questions.

5
00:00:13.670 --> 00:00:21.560
There are many ways to create an object in JavaScript that is also a class object capital which can

6
00:00:21.560 --> 00:00:23.600
allow you to create an object.

7
00:00:24.170 --> 00:00:28.240
Here we are discussing the most essential way of object creation.

8
00:00:28.250 --> 00:00:33.710
And trust me, it's extremely important in any case of object creation.

9
00:00:33.740 --> 00:00:39.140
The basic idea is that we are creating a container to bundle data pieces.

10
00:00:39.800 --> 00:00:41.420
Let's take a simple example.

11
00:00:41.870 --> 00:00:47.780
If we have a table on which we have been pencils, sharpeners, erasers and 20 other things.

12
00:00:48.290 --> 00:00:55.520
Now, if you want to take all the things from one place to another, it's better that you have a box

13
00:00:55.760 --> 00:00:57.470
or a kind of container.

14
00:00:57.500 --> 00:01:01.610
So you put everything in it and shifted wherever you want to.

15
00:01:02.090 --> 00:01:09.160
Similarly, when you have different data pieces which you may want to pass to one function to another,

16
00:01:09.170 --> 00:01:16.100
or maybe you want to pass it to some server, then you bundle the data pieces in an object and pass

17
00:01:16.100 --> 00:01:16.310
it.

18
00:01:16.520 --> 00:01:24.500
So in a way, object actually allows you to create a container where you can put variables, even functions.

19
00:01:24.540 --> 00:01:27.290
Also, let's take an example.

20
00:01:27.620 --> 00:01:35.330
You have a product called product name, price and more fields, and you want to pass this data to a

21
00:01:35.330 --> 00:01:35.870
function.

22
00:01:36.230 --> 00:01:40.940
So the function might look like this, that you have a function product and you have various parameters

23
00:01:40.940 --> 00:01:41.690
parsed here.

24
00:01:42.300 --> 00:01:47.360
Instead of this, you can write something like this that you have the object.

25
00:01:47.660 --> 00:01:50.810
Put all the different pieces in one container.

26
00:01:50.810 --> 00:01:52.070
This becomes a container.

27
00:01:52.070 --> 00:01:54.080
We will see the syntax, how we create it.

28
00:01:54.080 --> 00:01:58.640
But this is just a kind of illustration that how do we create an object?

29
00:01:58.640 --> 00:02:01.580
And we passed the object in the function like this.

30
00:02:02.360 --> 00:02:05.300
So this is the whole idea of creating an object.

31
00:02:05.630 --> 00:02:10.120
Though there are many other advantages after creating this kind of container.

32
00:02:10.130 --> 00:02:13.010
But that discussion, we keep it for some other day.

33
00:02:13.430 --> 00:02:18.540
At the moment we are discussing all the related questions and what is object literature?

34
00:02:18.560 --> 00:02:20.270
That is our main discussion.

35
00:02:20.510 --> 00:02:26.090
Object literal is simply a key value pair data structure.

36
00:02:26.420 --> 00:02:27.800
Let's take an example.

37
00:02:27.950 --> 00:02:29.720
I want to create an object literal.

38
00:02:30.410 --> 00:02:36.560
Normally you may have different variables, for example, product code, product name and so on.

39
00:02:36.890 --> 00:02:42.900
If I want to put everything inside object literal, how can I do that to create the object literal?

40
00:02:42.920 --> 00:02:43.860
This is the syntax.

41
00:02:43.880 --> 00:02:48.190
If I say let our concept object, is it going to call in brackets?

42
00:02:48.200 --> 00:02:51.410
If I do this, this means I have created an object literal.

43
00:02:51.830 --> 00:02:55.670
For example, I want to add variables to this object.

44
00:02:55.970 --> 00:03:02.720
Now remember, if I have product code is equal to 1001, for example, and I want to add this to the

45
00:03:02.720 --> 00:03:05.900
object, you just say object or product code.

46
00:03:06.350 --> 00:03:09.260
Also, I want to add one more variable to it.

47
00:03:10.100 --> 00:03:12.680
I will say Apple, for example.

48
00:03:13.520 --> 00:03:19.190
In case if you want to add a function to the object, that is also possible, let's say I want to have

49
00:03:19.300 --> 00:03:20.150
get data.

50
00:03:21.110 --> 00:03:27.260
That is the function and this function I want that it should be part of the object, not as an independent

51
00:03:27.350 --> 00:03:27.860
function.

52
00:03:28.310 --> 00:03:34.190
So I can say object dot get data is equal to.

53
00:03:35.480 --> 00:03:36.770
You don't need to write this name.

54
00:03:36.770 --> 00:03:38.780
This is basically function expression.

55
00:03:39.170 --> 00:03:46.700
And here I can simply say console.log object or be or an object dot b name.

56
00:03:47.750 --> 00:03:48.290
That's it.

57
00:03:49.250 --> 00:03:53.630
Let's try to display the value of object itself.

58
00:03:56.610 --> 00:03:59.820
I say North Pole jazz, not jazz.

59
00:04:00.690 --> 00:04:07.620
Now, as you can see here, the object displays that it has three, two variables and one method when

60
00:04:07.620 --> 00:04:08.520
I'm seeing three.

61
00:04:08.550 --> 00:04:09.600
What does it have?

62
00:04:09.690 --> 00:04:11.430
It has three members.

63
00:04:11.700 --> 00:04:16.560
The variable you put inside object is called as a property.

64
00:04:16.709 --> 00:04:24.720
So we have two properties bigger than P name and a function added to an object is called as method.

65
00:04:25.080 --> 00:04:30.540
So here we have total three members, two properties and one matter.

66
00:04:31.140 --> 00:04:34.230
This is how an object literally is created.

67
00:04:34.260 --> 00:04:38.700
So now if you have to pass this object to some function, maybe on the server.

68
00:04:38.730 --> 00:04:43.920
The thing is, you have created this container and you have placed these members in it.

69
00:04:44.250 --> 00:04:47.200
That is the advantage of creating an object larger.

70
00:04:47.520 --> 00:04:49.590
This is not actually the right way.

71
00:04:49.740 --> 00:04:52.770
Normally we do not create object literally like this.

72
00:04:53.040 --> 00:04:59.640
What we do in JavaScript, the common practice, I mean, is that we place everything inside the object

73
00:04:59.640 --> 00:05:00.840
literally, directly.

74
00:05:00.870 --> 00:05:02.490
We don't create an empty object.

75
00:05:02.490 --> 00:05:06.030
And then we added generally a the syntax changes a bit.

76
00:05:06.240 --> 00:05:08.340
If you put everything inside the object.

77
00:05:08.340 --> 00:05:14.850
So we do not need to write object because as such you are declaring those members inside the object

78
00:05:14.850 --> 00:05:15.450
itself.

79
00:05:15.630 --> 00:05:18.990
You do not write equal to sign to assign it.

80
00:05:19.260 --> 00:05:24.560
You use the colon sign and you do not end the statement with a semicolon.

81
00:05:24.570 --> 00:05:25.770
That is, you put a comma.

82
00:05:26.730 --> 00:05:30.430
This is the most commonly used way to create an object literal.

83
00:05:30.810 --> 00:05:34.410
We declare all the members inside the object itself.

84
00:05:34.920 --> 00:05:37.810
So now if I run, that is no change at all.

85
00:05:37.830 --> 00:05:38.970
It is the same thing.

86
00:05:39.150 --> 00:05:41.760
The only difference is now the code is shifted.

87
00:05:41.880 --> 00:05:45.720
That is the declaration of properties and methods are matter.

88
00:05:45.730 --> 00:05:49.020
One matter in our case is shifted inside the object.

89
00:05:49.020 --> 00:05:50.130
That is the object.

90
00:05:50.430 --> 00:05:57.030
If you want to access individual members, as you must have observed in this code, that DOT is the

91
00:05:57.030 --> 00:05:57.630
operator.

92
00:05:57.990 --> 00:05:58.320
Right.

93
00:05:58.410 --> 00:06:03.120
Now, I also want to add one more point here, which is introduced in E6.

94
00:06:03.930 --> 00:06:07.330
The function that is the method we have written here is like this.

95
00:06:07.350 --> 00:06:10.770
That is, we have an equal to sign that is assignment in this case colon.

96
00:06:10.770 --> 00:06:12.840
But that is a kind of assignment only.

97
00:06:12.840 --> 00:06:17.210
So this exact data equals to function in E6.

98
00:06:17.220 --> 00:06:19.950
Now you can avoid this syntax.

99
00:06:20.460 --> 00:06:21.990
You can simply write like this.

100
00:06:22.530 --> 00:06:23.580
This is a valid one.

101
00:06:23.700 --> 00:06:28.350
So now instead of writing any colon are equal to outside of the object.

102
00:06:28.350 --> 00:06:30.220
You just write get data.

103
00:06:30.240 --> 00:06:30.720
That's it.

104
00:06:31.140 --> 00:06:36.960
This is how we define the matters in classes also, but that we are going to discuss in one of our forthcoming

105
00:06:36.960 --> 00:06:37.440
section.

106
00:06:38.070 --> 00:06:42.540
So let's try this code again to make sure that the output is same.

107
00:06:43.260 --> 00:06:48.780
As long as calling this matter is concerned, we can simply say object or get data.

108
00:06:48.930 --> 00:06:49.470
That's it.

109
00:06:50.280 --> 00:06:54.150
And this will display as the data that it is.

110
00:06:55.390 --> 00:07:01.270
The way we have created one object, literally, we can also have any level of objects in it.

111
00:07:01.450 --> 00:07:07.030
For example, you want one more object after peak, or let's say you want here that because it also

112
00:07:07.030 --> 00:07:14.440
has maybe some I.D. and it also has second part, for example, the second part of the product or maybe

113
00:07:14.440 --> 00:07:15.160
some character.

114
00:07:15.580 --> 00:07:17.050
So I just say A-B-C.

115
00:07:17.680 --> 00:07:24.580
So the thing is, whenever you want to create an object, literally, you just open the brackets and

116
00:07:24.580 --> 00:07:25.570
you start writing.

117
00:07:25.900 --> 00:07:31.570
Important point here is that picture is the key and the one which you are writing here is the value.

118
00:07:31.870 --> 00:07:34.590
B name is the key, the one which you are writing here.

119
00:07:34.600 --> 00:07:36.790
Like in this case Apple is the value.

120
00:07:36.790 --> 00:07:42.940
So that's why we call the object literal is key value pair data structure.

121
00:07:44.080 --> 00:07:47.800
If you know about Jason Farmer, that's also a key value pair.

122
00:07:47.980 --> 00:07:53.110
But the only difference is that the key is always inside double quotes when we talk about Jason.

123
00:07:53.110 --> 00:07:58.270
But we are not discussing Jason at the moment, but just for the reference that if you are comparing

124
00:07:58.270 --> 00:08:04.720
this object with Jason, or rather Jason is more used because of this format we have in JavaScript called

125
00:08:04.720 --> 00:08:06.150
object literal, right?

126
00:08:06.160 --> 00:08:11.020
So this is the object which helps to convert the JASON data to this format.

127
00:08:11.440 --> 00:08:16.240
So often we see that the JASON data which we receive is converted into object later.

128
00:08:16.780 --> 00:08:19.630
Now I'm changing back this product code to 1001.

129
00:08:20.500 --> 00:08:26.470
I also mentioned one thing here that F6 has this format where we directly right get data.

130
00:08:26.470 --> 00:08:29.050
We don't write any colon sign or function.

131
00:08:29.050 --> 00:08:31.270
We do not right arrow function for sure.

132
00:08:31.270 --> 00:08:32.289
Remember that.

133
00:08:32.289 --> 00:08:37.510
Also we are going to discuss in one of the question why we should not use arrow function inside object

134
00:08:37.510 --> 00:08:39.159
later to be on a safer side.

135
00:08:39.159 --> 00:08:44.770
If you are using this object then I do not recommend the arrow function in it, but that we will discuss

136
00:08:44.770 --> 00:08:48.610
in one of our next questions here in E6.

137
00:08:48.670 --> 00:08:54.370
That is also one more facility provided and that is about giving the dynamic key values.

138
00:08:54.610 --> 00:09:01.030
Imagine that this big or P named, for example, is not decided earlier.

139
00:09:01.060 --> 00:09:04.480
Maybe some data is retrieved and then that key is decided.

140
00:09:04.480 --> 00:09:11.470
So this key I want to make dynamic now let's say I create a variable here I select temporary variable.

141
00:09:11.800 --> 00:09:14.920
Is it called do I name speaker here?

142
00:09:14.950 --> 00:09:15.310
Right.

143
00:09:15.310 --> 00:09:18.850
And if I say TV here, that is temporary variable, right?

144
00:09:18.940 --> 00:09:21.580
Let's see what happens if I run this.

145
00:09:22.120 --> 00:09:23.020
It is undefined.

146
00:09:23.020 --> 00:09:24.850
So that is some problem with it, right?

147
00:09:25.000 --> 00:09:27.220
Object part B code is undefined.

148
00:09:27.310 --> 00:09:28.300
So that is some issue.

149
00:09:28.510 --> 00:09:30.790
Let me also display sort of get data.

150
00:09:30.790 --> 00:09:36.580
Let me just display the object itself so you get better idea what exactly has happened.

151
00:09:38.230 --> 00:09:42.880
You see this DV 1001, but that is DV itself.

152
00:09:42.880 --> 00:09:49.420
It is not big or and that's why because we do not have any picture like variable, it is not giving

153
00:09:49.420 --> 00:09:49.930
the data.

154
00:09:49.930 --> 00:09:51.760
Instead it returns undefined.

155
00:09:52.780 --> 00:09:58.330
How can you make sure that this value of variable TV is assigned?

156
00:09:58.960 --> 00:10:05.470
What you have to do is you just put the key inside square brackets the moment you put it in square record

157
00:10:05.620 --> 00:10:08.640
object literal understands that this is a dynamic key.

158
00:10:08.650 --> 00:10:11.740
That means you are not supposed to take DV as a key.

159
00:10:11.950 --> 00:10:16.990
Rather, the value which is residing inside TV will be the actual key name.

160
00:10:17.320 --> 00:10:18.640
Let's try this again now.

161
00:10:18.970 --> 00:10:20.200
Now you see instead of TV.

162
00:10:20.200 --> 00:10:23.740
Now we have B code and 1001 is displayed.

163
00:10:24.010 --> 00:10:26.680
So this is something which is introduced in E6.

164
00:10:26.680 --> 00:10:29.470
In fact, you may have different matter like this.

165
00:10:29.470 --> 00:10:33.700
For example, I'll say get, then I join it.

166
00:10:34.540 --> 00:10:37.750
And data, this is also valid.

167
00:10:37.750 --> 00:10:43.210
I'm just giving for the sake of showing the functionality, this can be a dynamic value, right?

168
00:10:43.330 --> 00:10:46.840
But right now assume that we have two different values and you want to join.

169
00:10:46.960 --> 00:10:52.810
You may have two different variables which you may want to join for a method name or fara property name.

170
00:10:53.080 --> 00:10:56.020
Let's try this whether it runs proper or not.

171
00:10:56.020 --> 00:10:56.590
You see this?

172
00:10:56.590 --> 00:10:58.180
It does say get data.

173
00:10:58.480 --> 00:11:04.690
So giving the dynamic key is possible because now we have this square bracket syntax to do this.

174
00:11:05.050 --> 00:11:12.490
That is also one more good facility available in E6, which is called as property value shorthand.

175
00:11:12.490 --> 00:11:14.500
But that is one of our related question.

176
00:11:14.590 --> 00:11:18.820
I'm going to discuss property shorthand feature in the related question.

177
00:11:19.420 --> 00:11:25.300
So these were a few syntax and tweaks we have seen about object literal.

178
00:11:25.480 --> 00:11:28.780
Now let's discuss related questions of this topic.

179
00:11:29.380 --> 00:11:33.280
The first question is, can you have dynamic keys with object literal?

180
00:11:33.520 --> 00:11:40.210
Yes, we can have we have already seen the last example where the key is not fixed, but it is referred

181
00:11:40.210 --> 00:11:41.260
by a variable.

182
00:11:41.260 --> 00:11:46.720
Even we saw that a matter like get data, we try to divide into two different values.

183
00:11:46.720 --> 00:11:47.950
Then also it was valid.

184
00:11:47.950 --> 00:11:52.120
So of course dynamic keys is absolutely allowed with square brackets.

185
00:11:52.630 --> 00:11:57.490
The next question is how can you add real only properties to an object?

186
00:11:58.090 --> 00:12:00.310
Now, this is a very challenging question.

187
00:12:00.310 --> 00:12:04.990
The reason is we are using object that is capital or object.

188
00:12:05.020 --> 00:12:08.560
Let's try a sample code for the same thing I am creating.

189
00:12:08.560 --> 00:12:09.940
Let's say a prototype.

190
00:12:09.940 --> 00:12:12.850
I'll say proton PR or Lexapro to itself.

191
00:12:13.960 --> 00:12:14.320
Right.

192
00:12:14.830 --> 00:12:16.540
And I'll say object dot.

193
00:12:16.810 --> 00:12:21.520
That is a matter called defined property, not properties property.

194
00:12:22.150 --> 00:12:28.090
Then I have to pass an object literally if I have any object literal defined there.

195
00:12:28.450 --> 00:12:30.750
Otherwise I can pass an empty object later.

196
00:12:30.760 --> 00:12:38.890
Let's say I want to define a property named property and then I can define the configuration that is

197
00:12:38.890 --> 00:12:41.110
you see here it says attributes.

198
00:12:42.380 --> 00:12:47.790
Attributes means properties or attributes of the property which we are defining right now.

199
00:12:47.810 --> 00:12:50.120
For example, let me drive B code itself.

200
00:12:50.720 --> 00:12:51.260
Be cool.

201
00:12:52.220 --> 00:12:56.840
Now what I want about this property is that is it writable?

202
00:12:56.960 --> 00:12:57.800
Yes, it is.

203
00:12:57.800 --> 00:12:58.190
Right there.

204
00:12:58.190 --> 00:13:00.320
Well, that means one can change the property.

205
00:13:00.650 --> 00:13:01.010
Right.

206
00:13:01.430 --> 00:13:02.690
Is it configurable?

207
00:13:02.930 --> 00:13:04.550
Yes, it is configurable.

208
00:13:05.540 --> 00:13:06.620
So I'll say true.

209
00:13:07.160 --> 00:13:09.520
What is the value of this property?

210
00:13:09.530 --> 00:13:11.120
I say 2001.

211
00:13:11.330 --> 00:13:14.210
Now I'm going to create an object.

212
00:13:15.730 --> 00:13:19.930
Seeing concert object is equal to object art.

213
00:13:20.290 --> 00:13:20.910
Create.

214
00:13:20.920 --> 00:13:24.700
I'm creating the object and I'm passing the property.

215
00:13:24.700 --> 00:13:26.680
This is one property configuration.

216
00:13:26.680 --> 00:13:29.740
Pluto contains the configuration of one key.

217
00:13:30.010 --> 00:13:31.030
That is one property.

218
00:13:31.030 --> 00:13:33.250
This is the key name and this is the value.

219
00:13:33.250 --> 00:13:37.480
But there are other settings also you can specify now object or create.

220
00:13:37.480 --> 00:13:43.990
I say Pluto that means is going to create an object with this configured property and I'll say console.log.

221
00:13:43.990 --> 00:13:53.740
And before that let me also try to assign that is to change value code to something else.

222
00:13:53.740 --> 00:13:56.470
Let's say I give t001, that's it.

223
00:13:57.640 --> 00:14:05.530
So now the P code which we initialize with 2001 after creation, we are changing it to 3001.

224
00:14:05.530 --> 00:14:08.050
And let me just refer the picture only.

225
00:14:09.670 --> 00:14:10.660
Let's see what happens.

226
00:14:11.320 --> 00:14:12.640
It is 3001.

227
00:14:12.640 --> 00:14:13.750
The value is changed.

228
00:14:14.080 --> 00:14:24.910
Now this writable if I make it false like this and then if I run, even though I assigned 3001 but it

229
00:14:24.910 --> 00:14:26.020
did not change.

230
00:14:26.020 --> 00:14:30.460
It remained 2001 because I mentioned that make it read only.

231
00:14:30.670 --> 00:14:36.610
So this is how you define the attributes of property and you can manipulate with the object literal

232
00:14:36.610 --> 00:14:37.270
properties.

233
00:14:37.420 --> 00:14:42.160
Remember, if you are running this in the browser, it will give you error provided you are running

234
00:14:42.160 --> 00:14:43.300
it in a strict mode.

235
00:14:43.570 --> 00:14:48.040
But if you are not running in a strict more, at least it will not change the value.

236
00:14:48.040 --> 00:14:48.400
Fine.

237
00:14:48.400 --> 00:14:49.510
It won't give any error.

238
00:14:49.510 --> 00:14:55.780
Like right now here it is not showing any error, but if you have strict more on then certainly it will

239
00:14:55.780 --> 00:14:57.100
give added as well.

240
00:14:57.280 --> 00:15:03.280
So in short, yes, you can define read only properties with defined property method which has several

241
00:15:03.280 --> 00:15:03.850
settings.

242
00:15:04.450 --> 00:15:09.280
Next question is what is property value shorthand with object literal?

243
00:15:09.520 --> 00:15:14.530
Now this topic I just mentioned a few minutes back that this is a new feature introduced in.

244
00:15:15.460 --> 00:15:24.160
Let me show you one example here again, I take product code 1001 and product name, which I give something

245
00:15:24.160 --> 00:15:25.120
like Apple.

246
00:15:25.150 --> 00:15:25.960
My favorite.

247
00:15:28.180 --> 00:15:31.120
I'm talking about the fruit, not the electronic item.

248
00:15:31.240 --> 00:15:36.010
Apple select object is equal to now see this?

249
00:15:36.010 --> 00:15:42.670
Imagine that this object has product code and there you want to assign this value.

250
00:15:42.670 --> 00:15:44.770
That is because there is 1001.

251
00:15:45.040 --> 00:15:49.030
The point here is you want the value to be fetched from a variable.

252
00:15:49.030 --> 00:15:51.820
So you may write like this speaker is equal to peak or so.

253
00:15:51.820 --> 00:15:57.850
The key is bigger and the value is being fetched from this speaker instead of this year.

254
00:15:57.850 --> 00:16:00.700
Six gives you property value shorthand.

255
00:16:00.700 --> 00:16:03.130
That is b code.

256
00:16:03.790 --> 00:16:04.330
That's it.

257
00:16:04.330 --> 00:16:10.300
You do not need to write this column, just speak or it means speaker equals two p code and I say p

258
00:16:10.300 --> 00:16:11.560
name is equal to premium.

259
00:16:11.560 --> 00:16:13.060
That means I don't write anything else.

260
00:16:13.060 --> 00:16:13.510
That's it.

261
00:16:13.930 --> 00:16:14.620
Let's check.

262
00:16:14.860 --> 00:16:16.600
What is the object?

263
00:16:16.600 --> 00:16:23.530
Now you see, the key is speaker value is 1001 which is being fetched from the variable.

264
00:16:23.740 --> 00:16:26.260
Similarly we have p name and apple.

265
00:16:26.530 --> 00:16:30.850
So this is called s property value shorthand where you do not need to write.

266
00:16:31.060 --> 00:16:34.480
You have both the left and right side values equal.

267
00:16:34.510 --> 00:16:37.060
Then you simply go with B code and P name.

268
00:16:37.060 --> 00:16:37.330
Here.

269
00:16:38.050 --> 00:16:41.890
The next question is what will be the output of this code?

270
00:16:44.160 --> 00:16:45.480
The output of this code.

271
00:16:45.480 --> 00:16:46.770
Let us try the code here.

272
00:16:47.070 --> 00:16:53.940
The course is that there is an object we are creating and we are assigning this object that is object

273
00:16:53.940 --> 00:16:54.840
to object one.

274
00:16:55.410 --> 00:17:01.770
So when you are assigning the object, what actually happens is that the reference of the object is

275
00:17:01.770 --> 00:17:02.250
passed.

276
00:17:02.700 --> 00:17:13.530
So if you try to change object part a Saudi object one dot A, then it does change the value of object

277
00:17:13.530 --> 00:17:15.660
one that is object itself.

278
00:17:16.630 --> 00:17:17.020
Why?

279
00:17:17.290 --> 00:17:21.349
Because here, this will not create a new copy.

280
00:17:21.369 --> 00:17:23.800
This is not going to create a clone.

281
00:17:24.250 --> 00:17:27.010
It just creates the reference.

282
00:17:27.579 --> 00:17:28.870
So let's try this code.

283
00:17:29.740 --> 00:17:30.190
You see.

284
00:17:31.060 --> 00:17:33.490
So the object was first.

285
00:17:33.760 --> 00:17:35.410
The output is second.

286
00:17:36.040 --> 00:17:38.740
Even though you change obd one dot e.

287
00:17:38.770 --> 00:17:45.910
So what actually happens in this case is that when you assign object one equals two object because the

288
00:17:45.910 --> 00:17:52.840
assignment is by reference, that is, you can imagine that it is separately located somewhere and both

289
00:17:52.870 --> 00:18:00.100
object and object one are sharing the same location because they are referring the address of a and

290
00:18:00.100 --> 00:18:00.910
not the value.

291
00:18:01.240 --> 00:18:09.040
So whenever you see object dot a R object one dot A is going to refer the very same location or variable.

292
00:18:09.320 --> 00:18:13.690
That's why because of the reference copy it is giving this output.

293
00:18:13.930 --> 00:18:20.150
In case if you want to have different objects, then this isn't the way to create a clone.

294
00:18:20.170 --> 00:18:22.150
This is not creating clone in chart.

295
00:18:22.180 --> 00:18:27.220
So if you want to create a clone, then that is our next question, which I am going to discuss right

296
00:18:27.220 --> 00:18:27.490
now.

297
00:18:28.270 --> 00:18:33.970
So the next question is how can we create a clone or a separate copy of an object literal?

298
00:18:35.200 --> 00:18:38.230
So let's take this example and I want to create a clone.

299
00:18:38.560 --> 00:18:44.140
One way is that you loop through all the properties that is all the keys of object and you assign to

300
00:18:44.140 --> 00:18:45.220
OBJ one, right?

301
00:18:45.250 --> 00:18:46.080
That is one way.

302
00:18:46.090 --> 00:18:54.220
But in E6 we do also have object assigned matter that will allow you to create the clone of one object

303
00:18:54.220 --> 00:18:54.670
literally.

304
00:18:54.940 --> 00:18:57.010
Let me change this code and we will it.

305
00:18:57.430 --> 00:19:00.370
Instead of this I will say object.

306
00:19:00.940 --> 00:19:01.360
Dot.

307
00:19:01.360 --> 00:19:01.930
Assign.

308
00:19:05.060 --> 00:19:06.410
So the target object.

309
00:19:06.410 --> 00:19:08.100
You can write the object itself.

310
00:19:08.100 --> 00:19:13.520
Here we are leaving it blank because this is also going to return the reference to not exactly the reference,

311
00:19:13.520 --> 00:19:17.210
but the new copy to object when I want the copy of object.

312
00:19:19.370 --> 00:19:19.860
All right.

313
00:19:19.880 --> 00:19:21.860
Now let's check the code.

314
00:19:22.250 --> 00:19:23.060
What happens?

315
00:19:23.780 --> 00:19:26.210
You see, now it says first.

