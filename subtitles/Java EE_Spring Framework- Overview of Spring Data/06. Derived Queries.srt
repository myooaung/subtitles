1
00:00:01,147 --> 00:00:03,493
Whilst it might not seem like it at first glance,

2
00:00:03,493 --> 00:00:07,317
traditional query creation can involve lots of boilerplate.

3
00:00:07,317 --> 00:00:09,870
Let's demonstrate this with an example.

4
00:00:09,870 --> 00:00:11,661
The method we have here is called findByName,

5
00:00:11,661 --> 00:00:16,268
and it will return our customers in the database with the given name.

6
00:00:16,268 --> 00:00:18,678
Although the signature straightforward is making it previous

7
00:00:18,678 --> 00:00:20,587
obvious to us what the method should do,

8
00:00:20,587 --> 00:00:24,059
we still have to implement the code to execute it.

9
00:00:24,059 --> 00:00:25,769
In our case, we're using JPA,

10
00:00:25,769 --> 00:00:28,931
so that means creating a native query using the EntityManager,

11
00:00:28,931 --> 00:00:33,136
setting the parameters, and then returning the result as a list.

12
00:00:33,136 --> 00:00:35,911
And this doesn't even include the code required to convert our

13
00:00:35,911 --> 00:00:38,729
results into a list of the customer type.

14
00:00:38,729 --> 00:00:41,061
Now if we take a step back and look at this code,

15
00:00:41,061 --> 00:00:44,114
it's definitely filled with boilerplate because regardless

16
00:00:44,114 --> 00:00:46,747
of whatever read query we'd be doing,

17
00:00:46,747 --> 00:00:49,920
our code here would always look more or less the same apart

18
00:00:49,920 --> 00:00:52,219
from the query string and parameters.

19
00:00:52,219 --> 00:00:54,438
And actually, although the query string is unique,

20
00:00:54,438 --> 00:00:57,719
doesn't the method name already look similar to it?

21
00:00:57,719 --> 00:01:00,541
Spring Data aims to solve these problems of query

22
00:01:00,541 --> 00:01:02,784
boilerplate for derived queries.

23
00:01:02,784 --> 00:01:03,585
In a nutshell,

24
00:01:03,585 --> 00:01:06,671
a derived query is a query generated by Spring Data for

25
00:01:06,671 --> 00:01:09,407
you based on the method signature.

26
00:01:09,407 --> 00:01:12,920
So when we declare a method like this one on a Spring Data repository,

27
00:01:12,920 --> 00:01:17,865
Spring will be smart enough to generate an implementation of the method for us.

28
00:01:17,865 --> 00:01:20,770
Let's step through to see how Spring Data might do this.

29
00:01:20,770 --> 00:01:23,684
Spring Data first looks at the method name and maps

30
00:01:23,684 --> 00:01:25,596
the word find to the word SELECT.

31
00:01:25,596 --> 00:01:30,456
It then sees the word ByName and maps it to WHERE NAME =.

32
00:01:30,456 --> 00:01:34,456
Then the value of name is pulled out of the name query parameter.

33
00:01:34,456 --> 00:01:36,594
Finally, by looking at the return type,

34
00:01:36,594 --> 00:01:39,420
Spring Data knows what to map the result set into.

35
00:01:39,420 --> 00:01:42,273
And for this example, that would be it.

36
00:01:42,273 --> 00:01:45,009
The specific details of how Spring Data does this is

37
00:01:45,009 --> 00:01:47,021
beyond the scope of this course.

38
00:01:47,021 --> 00:01:50,790
But an oversimplified explanation is that it will generate an implementation

39
00:01:50,790 --> 00:01:54,071
of the interface at runtime based on the method signature,

40
00:01:54,071 --> 00:01:57,502
and then this implementation would be what you get when you

41
00:01:57,502 --> 00:02:00,796
wire in an instance of the repository.

42
00:02:00,796 --> 00:02:04,812
Derived queries are arguably one of Spring Data's most powerful features,

43
00:02:04,812 --> 00:02:08,180
and really there's a bunch of different things that can be achieved with them.

44
00:02:08,180 --> 00:02:09,440
Let's take a look.

45
00:02:09,440 --> 00:02:11,956
We can derive queries that use logical operators,

46
00:02:11,956 --> 00:02:16,154
such as and and or, by simply putting the word into the method name.

47
00:02:16,154 --> 00:02:19,575
Our queries can also be made case-insensitive by putting

48
00:02:19,575 --> 00:02:22,654
terms like IgnoreCase into the method.

49
00:02:22,654 --> 00:02:25,498
We can order the results of the query by putting OrderBy,

50
00:02:25,498 --> 00:02:30,097
delete elements by column name, in this case the value of name,

51
00:02:30,097 --> 00:02:34,040
and even use operators like less than or greater than.

52
00:02:34,040 --> 00:02:37,226
If for some reason you think this is overkill and feel that it's

53
00:02:37,226 --> 00:02:40,450
fine to query your database with your ORM directly,

54
00:02:40,450 --> 00:02:43,658
then first try to think about some of these advantages.

55
00:02:43,658 --> 00:02:46,067
In the case of Spring Data derived queries,

56
00:02:46,067 --> 00:02:48,307
there's no boilerplate for it at all.

57
00:02:48,307 --> 00:02:50,964
All the plumbing that could be done is done for us.

58
00:02:50,964 --> 00:02:54,385
Our queries are generated for us based on the method signature,

59
00:02:54,385 --> 00:02:56,728
so we don't need to implement them.

60
00:02:56,728 --> 00:03:01,007
The queries are also executed for us within the generated code.

61
00:03:01,007 --> 00:03:02,012
And finally,

62
00:03:02,012 --> 00:03:04,872
the result set is automatically mapped for us into

63
00:03:04,872 --> 00:03:07,050
the return type of our methods.

64
00:03:07,050 --> 00:03:09,389
The removal of the boilerplate isn't the only advantage

65
00:03:09,389 --> 00:03:12,243
though because doing things this way also dramatically

66
00:03:12,243 --> 00:03:15,091
reduces the learning curve for developers.

67
00:03:15,091 --> 00:03:17,889
This is because the underlying query language is abstracted,

68
00:03:17,889 --> 00:03:21,004
letting you work with human readable method names whilst

69
00:03:21,004 --> 00:03:23,650
counting on Spring to do the rest for you.

70
00:03:23,650 --> 00:03:25,910
So if you are inexperienced with SQL,

71
00:03:25,910 --> 00:03:28,423
then derived queries would help you get a quick start.

72
00:03:28,423 --> 00:03:29,809
As well as this,

73
00:03:29,809 --> 00:03:34,673
we should consider how advantageous interoperability of derived queries are.

74
00:03:34,673 --> 00:03:37,373
This is because whilst the examples we've given were

75
00:03:37,373 --> 00:03:39,619
of SQL queries being generated,

76
00:03:39,619 --> 00:03:42,640
the exact method signatures are convertible into all

77
00:03:42,640 --> 00:03:44,858
sorts of different query languages.

78
00:03:44,858 --> 00:03:47,358
For example, if you don't know Cassandra in SQL,

79
00:03:47,358 --> 00:03:49,431
but you do know Spring Data,

80
00:03:49,431 --> 00:03:52,024
then Spring Data Cassandra would be a great way to

81
00:03:52,024 --> 00:03:53,768
generate those queries for you.

82
00:03:53,768 --> 00:03:55,862
It's only when you run into more complicated,

83
00:03:55,862 --> 00:04:03,000
advanced, and database-specific concepts that derived queries won't be enough. But in the basic use cases, they are.

