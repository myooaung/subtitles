WEBVTT

00:00:01.170 --> 00:00:07.710
So back into Isbin Let's start with the very basics let's create a symbol so I will create such a new

00:00:07.710 --> 00:00:13.590
symbol all name a variable symbol by using the symbol object like this.

00:00:13.590 --> 00:00:14.610
And this is important.

00:00:14.610 --> 00:00:17.160
You don't have a new key word here.

00:00:17.490 --> 00:00:21.510
It is kind of constructor thing without the new word.

00:00:21.750 --> 00:00:27.570
And then Tudor's will object or function you may pass one argument which is only there for debugging

00:00:27.570 --> 00:00:28.490
reason.

00:00:28.500 --> 00:00:35.180
So let's name it debug here and there is only there so that if you print the symbol you will see this

00:00:35.250 --> 00:00:38.250
debugging message but you can't really use it for your code.

00:00:38.250 --> 00:00:44.040
It's only there for you that you know which symbol it is because remember behind the scenes the symbol

00:00:44.040 --> 00:00:48.590
will represent a unique ID and not that debugfs thing.

00:00:48.990 --> 00:00:52.770
So if I now print a symbol that starts simple.

00:00:52.770 --> 00:00:56.650
So print symbol.

00:00:56.970 --> 00:01:03.480
What do you think I'll see if I hit run while I see object symbol.

00:01:03.480 --> 00:01:05.580
So exactly what am I explaining.

00:01:05.640 --> 00:01:07.230
It is the object here.

00:01:07.440 --> 00:01:09.140
But we don't see anything else.

00:01:09.150 --> 00:01:12.840
We don't see the ideal for which it stands.

00:01:12.900 --> 00:01:22.260
Now if I add the two string function here and I had run again then you see also d d black string you

00:01:22.500 --> 00:01:23.290
exit here.

00:01:23.310 --> 00:01:27.680
So this allows you to check which symbol it actually is if you want you that.

00:01:27.900 --> 00:01:29.960
So that's how we create a symbol.

00:01:29.960 --> 00:01:32.690
And now let's check the type off it.

00:01:32.700 --> 00:01:39.240
So if I have type off symbol and I run what do you think we'll see.

00:01:39.240 --> 00:01:43.600
We get symbols so as I explained this is a new primitive it's no object.

00:01:43.680 --> 00:01:45.480
It is a primitive India.

00:01:45.800 --> 00:01:52.350
Now I was explaining that symbols are unique and I'm going to prove that if I create another symbol

00:01:52.350 --> 00:01:59.640
here and I create it and exactly the same way as before a symbol D-Backs So just the variable name changed

00:01:59.640 --> 00:02:00.090
.

00:02:00.150 --> 00:02:07.470
And now if I check if symbol equals number symbol and I'm only checking with two equal sides to see

00:02:07.470 --> 00:02:14.800
if they have the same value or they think I'll get if I had run now by the way I asked.

00:02:14.820 --> 00:02:17.590
I think you assume that we got fours and that isn't true.

00:02:17.610 --> 00:02:19.680
So we get false.

00:02:19.740 --> 00:02:25.690
These symbols do not match because again behind the scenes they stand for unique IDs so for different

00:02:25.710 --> 00:02:27.360
ideas of course.

00:02:27.360 --> 00:02:31.900
Now I was already explaining that symbols are great in conjunction with objects.

00:02:32.010 --> 00:02:33.390
So let's have a look at this.

00:02:33.420 --> 00:02:44.220
Our treat such an object here and let's say I have my name property which might be max but then I also

00:02:44.220 --> 00:02:49.830
will have the symbol as a property and I can do it as with the syntax I explained or showed you in the

00:02:49.830 --> 00:02:54.120
first module where we can use a variable property name.

00:02:54.150 --> 00:03:00.180
So by using square brackets and then symbol I'm actually using symbol here as a property name.

00:03:00.180 --> 00:03:04.920
If I would not have square brackets Well then I would just create a property of name symbol and not

00:03:04.920 --> 00:03:06.150
use the symbol up here.

00:03:06.150 --> 00:03:07.200
Right.

00:03:07.200 --> 00:03:11.430
So now I can assign symbol to B-22 for example.

00:03:11.430 --> 00:03:16.330
And what do you think will now happen if I print this object here.

00:03:16.810 --> 00:03:20.280
Or do you think we'll see if he had run.

00:03:20.280 --> 00:03:21.750
We only see named Max.

00:03:21.750 --> 00:03:24.300
That's what I was talking of earlier.

00:03:24.360 --> 00:03:27.030
The symbol is actually not printed out.

00:03:27.030 --> 00:03:35.340
You also went and see if I use a for loop but it is still there as I can prove to you if I exit it explicitly

00:03:35.700 --> 00:03:38.710
with square brackets notation on the object.

00:03:39.000 --> 00:03:42.770
So if I now run we get 22.

00:03:42.840 --> 00:03:47.000
So you can see at the stair it's just a bit hidden.

00:03:47.160 --> 00:03:49.730
And that again just you met up programming part.

00:03:49.740 --> 00:03:50.920
I was talking off.

00:03:51.090 --> 00:03:55.170
You could store some meta information about this object like create it.

00:03:55.180 --> 00:03:58.840
Add to that the time stamp but that is important for your application.

00:03:58.920 --> 00:04:01.100
And then you could exit it if you needed.

00:04:01.230 --> 00:04:07.500
But if you in a natural place and your app loops through all the keys and that's created at a time stamp

00:04:07.500 --> 00:04:10.360
is not actually something you need at this point.

00:04:10.500 --> 00:04:11.430
Then this is great.

00:04:11.430 --> 00:04:17.760
It won't chew up it won't get altered or well assign sounds somewhere else where it might be wrong.

00:04:17.760 --> 00:04:26.040
So this is why symbols are really important and useful tool to add some metaprogramming power to your

00:04:26.340 --> 00:04:30.190
objects or to your app as a whole.