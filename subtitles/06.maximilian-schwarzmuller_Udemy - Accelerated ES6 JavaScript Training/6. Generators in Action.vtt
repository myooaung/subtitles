WEBVTT

00:00:01.460 --> 00:00:05.820
So now you see that conjunction or treat an object.

00:00:06.210 --> 00:00:15.530
And also this object simply has is iterator symbol to make it iterable and assign the.

00:00:15.540 --> 00:00:18.690
But first or create a function generator.

00:00:19.290 --> 00:00:25.410
This generator should yield one like this and then two.

00:00:25.440 --> 00:00:31.200
Now here I'm assigning this generator without parentheses I'm not executing it I just assigned a reference

00:00:31.200 --> 00:00:32.180
to this function.

00:00:32.190 --> 00:00:39.500
Remember this will return me an iterator is that which is exactly what I need here and then I can loop

00:00:39.550 --> 00:00:42.360
through my object.

00:00:42.720 --> 00:00:46.100
I print out the individual elements.

00:00:46.110 --> 00:00:50.070
Now what do you think we'll see if and now Heidrun.

00:00:50.230 --> 00:00:51.610
Well you see one and two.

00:00:51.630 --> 00:00:58.240
Now we're using a generator and you iterate or it will return us to loop through our object to your

00:00:58.470 --> 00:01:01.210
to kind of outsource this for one.

00:01:01.440 --> 00:01:03.850
And second with this you keyword.

00:01:03.960 --> 00:01:06.710
It's much easier for us to manage state.

00:01:06.900 --> 00:01:10.730
And also imagine the possibilities just offer us for you.

00:01:11.040 --> 00:01:18.180
Because with our generator we might also do some let's say asynchronous task and yield those results

00:01:18.220 --> 00:01:22.880
step by step like fetching something from a server or anything like that.

00:01:22.890 --> 00:01:25.640
So we watch as you get those results.

00:01:25.770 --> 00:01:33.270
And with our iterator we could then use them and take advantage of that step by step approach instead

00:01:33.270 --> 00:01:37.020
of having a son function which runs from start to finish.

00:01:37.140 --> 00:01:42.580
Right at that time of course we still have to use you for loop.

00:01:42.600 --> 00:01:50.160
We can also just extract the iterator from our optic here or since this is just our generator I can

00:01:50.370 --> 00:01:51.510
do that.

00:01:51.780 --> 00:01:59.580
And I also if I get rid of this I can also pass an argument to a generator of course.

00:01:59.790 --> 00:02:09.960
So I could pass 10 claim at end here and end here all then create the logic to loop through with a normal

00:02:10.650 --> 00:02:18.750
for loop by as long as is a smaller than and incremented each time.

00:02:18.750 --> 00:02:21.640
And that simply yield.

00:02:22.010 --> 00:02:24.240
I would.

00:02:24.660 --> 00:02:33.170
I can of course simply print out it next and I'll set this to 2 so that we get to the end faster and

00:02:33.230 --> 00:02:35.990
I'll print these for time.

00:02:36.060 --> 00:02:39.900
Now what do you think we'll see if I had run.

00:02:39.900 --> 00:02:46.410
We get our objects with 0 1 and then it's already done because we're only looping as long as I'm smaller

00:02:46.410 --> 00:02:48.180
than and so only two times.

00:02:48.270 --> 00:02:50.210
And then we get undefined twice.

00:02:50.460 --> 00:02:52.950
So this is how you pass arguments to iterators of course.

00:02:52.950 --> 00:02:59.700
Now very important aspect which allows you to write truly dynamic generators and jantan iterators with

00:02:59.700 --> 00:03:01.330
them as they retour and dad.

00:03:01.550 --> 00:03:09.390
Q We have some well dynamic data going on you're defining how long this generator should yield values

00:03:09.420 --> 00:03:12.850
or when it should use values and so on.