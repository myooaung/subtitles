WEBVTT

00:00:01.350 --> 00:00:07.470
So this has been the fat arrow function I was really stressing this because it is a key addition in

00:00:07.500 --> 00:00:09.590
E-6 now for options.

00:00:09.600 --> 00:00:12.060
Also got some additional new tricks.

00:00:12.060 --> 00:00:17.970
And what I'm showing you now applies to both the traditional functions with the function keyword as

00:00:17.970 --> 00:00:19.700
well as Fed arrow functions.

00:00:19.830 --> 00:00:25.020
But since it's a bit nicer to read I'll stick to the traditional functions with the function keyword

00:00:25.020 --> 00:00:25.790
here.

00:00:26.310 --> 00:00:34.380
If I have my function is equal to here for example and this function expects a number as a number to

00:00:34.380 --> 00:00:40.390
compare to and then let's say it returns if number is equal to compare.

00:00:40.920 --> 00:00:50.310
Then I of course can't call this function and log the result like this is equal to and then maybe 10

00:00:50.430 --> 00:00:53.910
and 10.

00:00:54.780 --> 00:00:57.910
If I now had run unsurprisingly I get true.

00:00:58.200 --> 00:01:04.210
However with iOS 6 we can assign default values to arguments.

00:01:04.260 --> 00:01:09.200
For example I could give comparer a default value of zero.

00:01:09.510 --> 00:01:15.360
So if I now call this function with only one argument 10 what do you think I'll get.

00:01:16.200 --> 00:01:22.950
Well I guess forwards because now I am now trying to compare 10 which I'm passing number to compare

00:01:22.950 --> 00:01:26.340
which I don't pass but which is set to Ciro by default.

00:01:26.520 --> 00:01:33.190
If I change default to 10 and I had run again I of course get true again.

00:01:33.270 --> 00:01:36.570
So this are default values.

00:01:36.630 --> 00:01:43.020
Now I can also assign the default value to number and no I can call this function without any arguments

00:01:43.020 --> 00:01:46.250
at all and I still get true.

00:01:46.680 --> 00:01:48.590
Now what happens if I do this.

00:01:48.600 --> 00:01:52.260
I'd set number to be a default of 10.

00:01:52.440 --> 00:01:55.160
But compare doesn't get a default value.

00:01:55.260 --> 00:01:59.130
And now I call this function with 10 what do you think will happen.

00:01:59.130 --> 00:02:09.990
I had run I get false and the reason for this is I'm still setting number to 10 because I'm only passing

00:02:09.990 --> 00:02:20.490
one argument and this will set the first argument and I can prove this pi logging number and then also

00:02:20.490 --> 00:02:30.090
logging compare and I will said is the argument here 211 to be different or to be not equal to this

00:02:30.090 --> 00:02:31.090
default value.

00:02:31.200 --> 00:02:32.130
So for now I run.

00:02:32.130 --> 00:02:36.630
What do you think we'll get when we get 11.

00:02:36.630 --> 00:02:38.590
That's what I pass for number.

00:02:38.760 --> 00:02:41.800
Then we get undefined because we're not set in compare.

00:02:41.790 --> 00:02:44.720
I'm not passing and I'm not setting a default value.

00:02:44.880 --> 00:02:49.830
And then of course I get false because 11 is not equal to compare or to undefined.

00:02:50.130 --> 00:02:57.270
So that's important to understand Chalis will not pick the values which don't have a default value or

00:02:57.270 --> 00:03:01.450
the arguments which don't have a default value to assign the values you are passing.

00:03:01.560 --> 00:03:07.070
It's still keeping the ordering and if you pass one argument to a function with two arguments while

00:03:07.110 --> 00:03:09.320
then only the first argument will get set.

00:03:09.360 --> 00:03:10.880
That doesn't change.

00:03:11.040 --> 00:03:16.560
It does allow you to skip the other arguments if you only want to set the first one that does work but

00:03:16.560 --> 00:03:17.930
not the other way around.

00:03:18.180 --> 00:03:24.850
So if I now had run we of course get 11 that's what we pass for number and then 10 which just default

00:03:24.850 --> 00:03:26.700
for Cp. either.

00:03:26.820 --> 00:03:33.390
We may not only do this we may also do some calculations here like 10 divided by 2 for example.

00:03:33.390 --> 00:03:37.710
And if you add right now we see that there's 5.

00:03:38.160 --> 00:03:40.100
How much sets that ever may make.

00:03:40.110 --> 00:03:46.950
But it's possible but an interesting thing is you can also use the other arguments like this number

00:03:46.970 --> 00:03:47.260
.

00:03:47.550 --> 00:03:50.560
So now I'm saying compare equal to number.

00:03:50.720 --> 00:03:52.400
And what do you therefore expect to have.

00:03:52.410 --> 00:03:56.970
I had run a get 11 the Lebanon of course.

00:03:56.970 --> 00:04:02.140
True because I'm always setting compare equal to number if no distinct value is provided.

00:04:02.160 --> 00:04:06.970
If I do provide a separate value for comparer and now I get run.

00:04:08.550 --> 00:04:10.860
Well we see we're still overwriting this.

00:04:10.860 --> 00:04:17.910
It's just the default value and we are able to assign a different a or another argument as our default

00:04:17.910 --> 00:04:18.990
value.

00:04:18.990 --> 00:04:23.810
We may also assign some kind of variable we have outside of this.

00:04:23.820 --> 00:04:26.150
Let's say we have a which is 100.

00:04:26.550 --> 00:04:30.390
And I do this what you think will happen if I now run.

00:04:31.440 --> 00:04:33.060
Well now compare is 100.

00:04:33.060 --> 00:04:37.920
So we may use our variables from outside of this function as well.

00:04:37.920 --> 00:04:42.050
Now with that being said what do you think will happen if I do this.

00:04:42.270 --> 00:04:50.370
I said compared to 10 and the set number to be equal to compare and then I'm calling this function without

00:04:50.400 --> 00:04:52.380
any arguments.

00:04:52.380 --> 00:04:53.540
What do you think we'll see.

00:04:53.540 --> 00:04:54.370
Will we see true.

00:04:54.390 --> 00:04:57.440
Because all is 10.

00:04:58.080 --> 00:05:01.100
We get an error that compair is not defined.

00:05:01.140 --> 00:05:07.600
And the reason for this is you can't think of this function argument list here as well.

00:05:07.950 --> 00:05:14.130
Just some lines of code only wrapped in one line of code and what we're trying to do here is we're trying

00:05:14.130 --> 00:05:18.160
to use a variable comparer before it's being set here.

00:05:18.240 --> 00:05:23.030
So this does not work we can't set something equal to something which doesn't exist yet.

00:05:23.040 --> 00:05:27.160
Ask compare will only be created in the second step and the second argument.

00:05:27.390 --> 00:05:29.270
So this does not work.

00:05:29.370 --> 00:05:31.000
But the other way around does.

00:05:31.140 --> 00:05:37.200
Because if we now said compare equal to number number has already been defined before and therefore

00:05:37.200 --> 00:05:41.810
if we run this we get true and both values are 10 of course.

00:05:41.940 --> 00:05:47.030
So there are default values at work and of course the great benefit of default values are added.

00:05:47.040 --> 00:05:54.660
You can write more dynamic functions which might work in well different circumstances which don't necessarily

00:05:54.660 --> 00:05:58.470
need for example for the parameters to be passed to them.

00:05:58.470 --> 00:06:02.580
That might work with one and the other two are set by default and so on.

00:06:02.730 --> 00:06:09.140
And you can really play around with that and try out where it works for you which you can pass and how

00:06:09.150 --> 00:06:14.640
all of that fits together Gabbert but together with aero functions the default values are really a big

00:06:14.640 --> 00:06:20.850
addition to charmless good functions and certainly helpful in your day to day coding.