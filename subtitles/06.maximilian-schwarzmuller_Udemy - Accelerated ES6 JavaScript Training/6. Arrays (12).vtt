WEBVTT

00:00:01.190 --> 00:00:09.180
I'll conclude this module with the airy object they are we also have some fun new functions to showcase

00:00:09.180 --> 00:00:14.610
this all first create a new airy and I'll start Steve ready for his new thing.

00:00:14.880 --> 00:00:18.410
I can use Tiberi object to create a new array.

00:00:18.840 --> 00:00:26.580
And this is not only new that is is five stalls so you already had this available before.

00:00:26.580 --> 00:00:37.610
Now if I add five here and then I lock my Airey to the console What do you think we'll see.

00:00:37.860 --> 00:00:43.650
We see undefined undefined undefined undefined undefined five times.

00:00:43.650 --> 00:00:52.800
So today with S-5 javascript running and all the browsers this every object if we use it like this in

00:00:52.810 --> 00:01:00.340
this kind of constructor like way it will actually give us an array of length 5 and it will of course

00:01:00.360 --> 00:01:07.820
fill it with five undefined values that might be the behavior you want but sometimes you just wanted

00:01:07.830 --> 00:01:12.820
to create a new array which actually has Well this element in it.

00:01:12.840 --> 00:01:19.800
This five with iOS 6 we therefore have the Airey off method.

00:01:20.370 --> 00:01:26.250
If I clear this and I now hit run what do you expect to happen now.

00:01:26.250 --> 00:01:31.370
Now we get an array with 5 inside of it and of course I can add more items here.

00:01:31.380 --> 00:01:34.910
And if I had run we see all those items in an array.

00:01:35.100 --> 00:01:40.350
So that's just another method to create a new array with a given list of items and notes of course and

00:01:40.350 --> 00:01:41.600
not passing an array here.

00:01:41.610 --> 00:01:43.620
I'm just passing a list of items.

00:01:43.770 --> 00:01:48.970
So that is certainly a useful nice thing.

00:01:49.660 --> 00:01:56.370
Now I'll go back to the old school tree which is a bit shorter here where I'll just add some numbers

00:01:56.370 --> 00:01:57.890
to an array.

00:01:58.740 --> 00:02:03.600
And now let's say I wanted to create an ewery based on that array here.

00:02:03.690 --> 00:02:11.020
So I want to create my new array year and I wanted to take the old array but change it in some way.

00:02:11.430 --> 00:02:14.520
We get this cool new airy from method.

00:02:14.550 --> 00:02:20.310
Now array from allows me to specify from which array I want to create in you once so array here for

00:02:20.310 --> 00:02:22.630
example this one here.

00:02:23.250 --> 00:02:32.160
And then I can add a function as a second argument to tell how we want to change each value for this

00:02:32.160 --> 00:02:33.040
new aere.

00:02:33.210 --> 00:02:36.420
So we're taking this old array as the basis.

00:02:36.510 --> 00:02:38.820
But then we want to change it in our Nury.

00:02:38.950 --> 00:02:43.220
Now here I'll use an arrow function or a federal function whatever you want to call it.

00:02:43.490 --> 00:02:48.160
I pass a value into it and then I multiplied with two.

00:02:48.360 --> 00:02:50.200
That's simply a step function.

00:02:50.230 --> 00:02:56.550
This array from function will execute on each element here and once it is done with all the elements

00:02:56.640 --> 00:03:01.430
it will give us back a new array and store it in this new Airey variable.

00:03:01.830 --> 00:03:08.550
So therefore if I now print new array here and that just sort of actually it's of course important to

00:03:08.700 --> 00:03:15.000
make this an uppercase A We need the airy object you bolt in every object here not our very well.

00:03:15.150 --> 00:03:18.810
So with that prepared What do you think you'll see if I now run

00:03:21.600 --> 00:03:28.080
while we get this new array which is the old airy but with all numbers being doubled.

00:03:28.110 --> 00:03:35.700
Of course if I still print in old Airey and run again we see that the old era here didn't get changed

00:03:35.700 --> 00:03:35.990
.

00:03:36.030 --> 00:03:39.350
We only used it as the base for this new array.

00:03:39.360 --> 00:03:46.260
And then we adjusted the values appropriately forward and you array here all get rid of this for now

00:03:46.310 --> 00:03:46.460
.

00:03:46.510 --> 00:03:49.950
And I want to show you a number of cool new method.

00:03:49.950 --> 00:03:55.780
We also have the full method and this is applied directly on an array.

00:03:55.800 --> 00:04:03.430
So I take my array which I created up here this variable and I'll use the full method on it.

00:04:03.450 --> 00:04:05.760
Now hearable pass 100.

00:04:06.010 --> 00:04:14.100
And what do you think might now happen and what will you see if I how to run while we get the array

00:04:14.510 --> 00:04:14.930
.

00:04:15.000 --> 00:04:17.430
Everything has been filled up with 100s.

00:04:17.730 --> 00:04:23.460
So thought does exactly what we could think that it does telling by the name it takes the old array

00:04:23.910 --> 00:04:30.720
and each value in this array is replaced with the value we specify here between the parentheses.

00:04:30.750 --> 00:04:33.000
So therefore we full this array with 100.

00:04:33.000 --> 00:04:40.020
In this case sometimes you don't want to fold the entire array but only well let's say we want to replace

00:04:40.020 --> 00:04:42.960
the second element with 100.

00:04:43.050 --> 00:04:47.210
Well of course there would be a quick array by simply accessing it from the index.

00:04:47.340 --> 00:04:53.610
But if we want to use the fold method we could do this by passing some optional arguments that could

00:04:53.610 --> 00:04:57.840
pass the START argument which of course is the next thing we want to start.

00:04:57.840 --> 00:05:02.280
Let's say one and the end argument here all use two.

00:05:02.490 --> 00:05:10.060
So basically telling this method here that I want to start at next one and I want to end that X too

00:05:10.080 --> 00:05:12.100
but in X two won't be included.

00:05:12.210 --> 00:05:15.500
So only this position here will be filled with 100.

00:05:15.570 --> 00:05:22.880
Therefore if I now run get 10 160 and so the second element has been replaced with 100.

00:05:23.160 --> 00:05:31.160
And of course I could have also started at the first element replaced the first two elements here.

00:05:31.470 --> 00:05:38.070
So that's a full and how we can control it to either the complete Airey or only certain parts of it

00:05:38.070 --> 00:05:39.390
.

00:05:39.420 --> 00:05:44.040
There's another method I want to share with you on my array here.

00:05:44.220 --> 00:05:51.810
So on the array created here I also have the find method of sailable and this method expect a function

00:05:51.810 --> 00:05:54.690
as an input and I'll use that arrow function here again.

00:05:54.690 --> 00:05:58.260
But of course you could still write an old for oldskool function like this.

00:05:58.260 --> 00:06:00.510
And just calling it old school.

00:06:00.540 --> 00:06:05.850
Not really because we wouldn't use it anymore just to differentiate between you arrow and the other

00:06:05.850 --> 00:06:07.890
functions.

00:06:09.060 --> 00:06:11.280
So are we using a fat function.

00:06:11.820 --> 00:06:17.910
And this gets Belizean input that you will of course be the individual elements for which is find function

00:06:17.910 --> 00:06:19.050
will appear.

00:06:19.560 --> 00:06:26.640
And then the year I specified the criterium on which I want to find something for example I could say

00:06:27.180 --> 00:06:34.120
that I want to find everything where a value is greater equal twelth.

00:06:34.710 --> 00:06:39.130
And now just to make sure what actually happens here.

00:06:39.360 --> 00:06:44.210
Remember that you can imagine are it true in Stape and in front of that.

00:06:44.550 --> 00:06:49.560
And then all I do is simply return if value is greater or equal to 12.

00:06:49.560 --> 00:06:51.750
So either true or false.

00:06:51.780 --> 00:06:57.740
And again this function here will be executed for each element in this array automatically by find.

00:06:58.080 --> 00:07:03.290
So what do you think again that would run I get 12.

00:07:03.330 --> 00:07:07.320
Now this might be surprising because 16 us also bigger than that.

00:07:07.320 --> 00:07:08.050
Right.

00:07:08.340 --> 00:07:15.730
But it actually will stop after the first match so it won't give us back the array of resources found

00:07:15.930 --> 00:07:20.880
but only the first element of that imaginary Yairi you could say.

00:07:20.880 --> 00:07:26.100
So it only will give us back the very first element we're in this condition here hits and therefore

00:07:26.100 --> 00:07:33.150
it's mostly important if you're not searching for Drage are equal then although that really is what

00:07:33.150 --> 00:07:36.070
you want you want to get the for ultimate where this is true.

00:07:36.240 --> 00:07:42.540
But imagine you have an array full of objects and you're you would have a criterion or a condition where

00:07:42.540 --> 00:07:47.870
you check for object has a certain value for a specific property.

00:07:48.060 --> 00:07:51.510
Then you could find exactly that object in your array.

00:07:51.780 --> 00:07:55.890
And that would be a use case where it absolutely makes sense to only get one.

00:07:56.160 --> 00:07:59.700
So I want to show you such an example next.

00:07:59.700 --> 00:08:04.140
Now that's actually an example from the end the end the most laudable upper network but it's really

00:08:04.140 --> 00:08:10.440
good as you can see we get our array inventory here and we got free objects which all have a name and

00:08:10.440 --> 00:08:16.290
a quantity and then we get this fine Cherrie's function Novin every function but a classic traditional

00:08:16.290 --> 00:08:17.280
function.

00:08:17.520 --> 00:08:21.060
We get fruit as an input and we check if this fruit has a name.

00:08:21.060 --> 00:08:22.320
He quoted.

00:08:22.860 --> 00:08:29.040
And then we log inventory which is our aere find and we pass a reference we find charites method here

00:08:29.050 --> 00:08:29.080
.

00:08:29.100 --> 00:08:35.310
So this will be the method executed on each item and each item will then be passed to this method as

00:08:35.310 --> 00:08:36.800
fruit here.

00:08:36.810 --> 00:08:43.590
So if I had run now what do you think I get I get these Cherie's object.

00:08:43.590 --> 00:08:49.020
And here it absolutely makes sense to be a good one because we only wanted to find one since we have

00:08:49.020 --> 00:08:50.810
unique identifiers year.

00:08:51.030 --> 00:08:58.680
So find something which can be helpful if you want to use some advanced queries like the one here where

00:08:58.680 --> 00:09:05.570
you want to look into an object instead of having a look at some generic condition.