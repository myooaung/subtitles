WEBVTT

00:00:01.490 --> 00:00:02.990
So that's symbols.

00:00:03.000 --> 00:00:07.410
And I'm not sure how to create them and why they are useful when they are useful.

00:00:07.440 --> 00:00:10.380
And now of course there is more to it.

00:00:10.430 --> 00:00:12.360
Otherwise as much will would be over right.

00:00:12.480 --> 00:00:14.330
So what do I have to add here.

00:00:14.490 --> 00:00:20.790
There are so so-called well known symbols already implemented in shovels crib towards shipping with

00:00:20.790 --> 00:00:21.990
ESX.

00:00:22.170 --> 00:00:30.960
Those well known symbols are defined are already defined and offer some core functionalities on certain

00:00:31.920 --> 00:00:35.980
objects or things in your language and to make this a bit more precise.

00:00:35.990 --> 00:00:43.530
So let me give you an example so I'll get rid of all of that and I'll create a new class person here

00:00:43.530 --> 00:00:46.730
let's say it looks like this.

00:00:46.950 --> 00:00:50.850
And it doesn't have anything in inside of it right now.

00:00:50.880 --> 00:00:52.350
That's fine.

00:00:52.470 --> 00:01:03.140
And then I log this person class and then I create a new person with the new keyboard here.

00:01:03.180 --> 00:01:05.400
Then I log breezed

00:01:08.310 --> 00:01:15.270
through I think I'll see if I now run well as the object object which is a bit sad because I could also

00:01:15.270 --> 00:01:22.300
see object person at least to show me that person is an object of type person or something like that

00:01:22.310 --> 00:01:22.430
.

00:01:22.620 --> 00:01:30.860
But that's how he bolt in to string function already built in to string tag function to be precise works

00:01:30.870 --> 00:01:31.180
.

00:01:31.500 --> 00:01:38.190
But the thing responsible for this output actually can be overwritten with a symbol and I'll show you

00:01:38.190 --> 00:01:47.670
how I may access my Berzon thought prototypes so the prototype offers purist's an object.

00:01:48.280 --> 00:01:53.470
And on this prototype I can access symbol and then with.

00:01:53.580 --> 00:01:59.100
As I said there are a couple of built in kind of static fields which you can access.

00:01:59.220 --> 00:02:01.370
For example the two string tag.

00:02:01.560 --> 00:02:05.110
No that's no function that's a symbol just a built in one.

00:02:05.250 --> 00:02:10.990
So it's kind of a unique ID or a shared ID which I can access from this field here.

00:02:11.490 --> 00:02:21.600
So by using this I could rename this to person and now watch what happens if I had run again.

00:02:21.680 --> 00:02:23.470
I to see optic person here.

00:02:23.520 --> 00:02:25.360
So we change the behavior.

00:02:25.680 --> 00:02:31.110
And here again we are in the field of metaprogramming of course that's probably not something you're

00:02:31.110 --> 00:02:37.770
going to print out to the user but it might be useful for you during programming or for sound checks

00:02:37.780 --> 00:02:38.040
.

00:02:38.220 --> 00:02:41.220
And there are other well known symbols as well.

00:02:41.220 --> 00:02:48.690
Now the best way to find out about them is to just google for E-6 well-known symbols and you should

00:02:48.690 --> 00:02:55.810
find an article on the empty empty muzzleloader Developer Network which generally is about symbols.

00:02:55.980 --> 00:03:01.320
And then also has the section on well-known symbols and you'll see there are quite a lot of them and

00:03:01.320 --> 00:03:06.690
you can go through them to learn more about there as well now and pulled in symbols if you're interested

00:03:06.690 --> 00:03:07.140
.

00:03:07.140 --> 00:03:09.800
You'll also see some of them throughout the score.

00:03:09.810 --> 00:03:15.960
All right now I want to show you one additional I want to show you the two primitive symbol for example

00:03:15.960 --> 00:03:16.810
.

00:03:16.920 --> 00:03:25.820
I'm going to get rid of this code and or create an array here instead which is simply one view.

00:03:26.040 --> 00:03:27.280
Let's say like that.

00:03:27.460 --> 00:03:28.010
Yes.

00:03:28.020 --> 00:03:30.230
So that's my array.

00:03:30.250 --> 00:03:42.220
Now if I use this array and let's say I print numbers that's one thing I think I'll see if I had run

00:03:42.280 --> 00:03:43.780
.

00:03:44.520 --> 00:03:47.060
Well I get one to free one.

00:03:47.070 --> 00:03:50.840
So it makes a string out of that and adds the one at the end.

00:03:51.090 --> 00:03:53.950
Yeah probably not what I wanted.

00:03:54.270 --> 00:04:02.970
So with the Sopel we could actually change this before printing it out or actually take my numbers and

00:04:03.450 --> 00:04:08.120
remember an array is just an object therefore I can access properties on numbers.

00:04:08.470 --> 00:04:17.100
And here again I use symbol to access such a bold in symbol such a both in property with the two primitive

00:04:18.750 --> 00:04:19.520
symbol.

00:04:19.620 --> 00:04:21.500
And again just because it's important.

00:04:21.690 --> 00:04:29.740
Remember this would just yield me a unique ID which is registered as a property in my array object.

00:04:30.210 --> 00:04:32.050
So that's what I'm accessing here.

00:04:32.310 --> 00:04:38.920
And this actually is a function which is responsible for handling this array object.

00:04:39.060 --> 00:04:45.490
If it should be transformed to a primitive and Javascript will try to transform it to a primitive.

00:04:45.660 --> 00:04:51.660
If for example I use it in a calculation with the plus operator here so that it will trigger dysfunction

00:04:51.900 --> 00:04:54.830
which is registered under this symbol.

00:04:55.290 --> 00:04:57.780
So I can override we're here of course.

00:04:57.780 --> 00:05:05.160
Now I could write that behavior to actually add all these numbers but I can also do something like return

00:05:05.610 --> 00:05:07.240
9 9.

00:05:07.360 --> 00:05:08.640
And what do you think will happen for now.

00:05:08.640 --> 00:05:12.080
Run I see 1000.

00:05:12.090 --> 00:05:17.340
And of course while this might not be the behavior you want you see the power of that to see what you

00:05:17.340 --> 00:05:19.270
actually can do with that.

00:05:19.410 --> 00:05:22.660
And of course you can also order might be a good exercise.

00:05:22.670 --> 00:05:29.100
Your time try to write some logic to actually print out the some of this era.

00:05:29.100 --> 00:05:36.460
So instead of making it a string and that is the average big part or the big advantage primitives Excuse

00:05:36.480 --> 00:05:43.380
me symbols offer they allow you to use that was well known symbols to override default behavior on built

00:05:43.440 --> 00:05:44.710
in objects.

00:05:44.760 --> 00:05:52.500
And again check out there is an article here for more information on that and to learn which are built

00:05:52.590 --> 00:05:54.090
in symbols exist