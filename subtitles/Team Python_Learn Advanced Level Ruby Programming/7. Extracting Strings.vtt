WEBVTT
1
00:00:00.450 --> 00:00:01.500
Hey, guys, what's up?

2
00:00:01.530 --> 00:00:05.300
This is American, and I welcome you to another story on this course on Ruby.

3
00:00:05.310 --> 00:00:11.480
And in this tutorial, we will see how to extract single characters from string with the bracket syntax.

4
00:00:11.820 --> 00:00:18.720
So, for example, you have, let's say, a string that is X and that is equal to, let's say my name.

5
00:00:19.410 --> 00:00:23.040
Then, for example, you just want to have a certain character.

6
00:00:23.040 --> 00:00:26.610
Let's say you want to just extract this you from here using the brackets indexed.

7
00:00:26.610 --> 00:00:28.860
And what you can do is that you can write in votes.

8
00:00:29.280 --> 00:00:35.640
You will write the name in which the that is going to be the name of the variable in which your daddy's

9
00:00:35.640 --> 00:00:42.180
story or your string in this case, to write an X, you have to specify the square brackets and then

10
00:00:42.180 --> 00:00:46.580
you have to specify the index for which you want to the value to be generated.

11
00:00:46.890 --> 00:00:50.150
So always remember that a string start with position zero.

12
00:00:50.160 --> 00:00:52.320
So this mean this you is that position zero.

13
00:00:52.320 --> 00:00:55.710
This is that position one then this is that position two.

14
00:00:55.980 --> 00:00:59.160
Is that position three and R is at position four.

15
00:00:59.370 --> 00:01:06.750
If you have let's say some space ahead in the space is also going to be treated as a location.

16
00:01:06.760 --> 00:01:10.290
So for example, I have let's say ABC Oakhill.

17
00:01:11.580 --> 00:01:15.500
So then this is going to be the fifth, this is going to be the sex, this is going to be the seventh,

18
00:01:15.510 --> 00:01:17.720
and then this is going to be the location over here.

19
00:01:18.090 --> 00:01:22.640
So let's say I just want to have the 08 character, which means that I want only this.

20
00:01:22.650 --> 00:01:24.860
You so underscored.

21
00:01:24.870 --> 00:01:27.480
And as you can see, that you is it right here?

22
00:01:27.480 --> 00:01:32.160
And as well as I was talking, this is the zero one, two, three, four.

23
00:01:32.160 --> 00:01:35.280
And if I just write in five, four, he'll run the score.

24
00:01:35.280 --> 00:01:41.650
And you can see that empty screen is generated because we have nothing on the position of this strength.

25
00:01:42.270 --> 00:01:50.160
Now, always remember that if you are using the Ruby Virgin that is below one point nine, then this

26
00:01:50.160 --> 00:01:56.010
thing is not going to work because in Ruby, one point nine strings are encoding of error sequences

27
00:01:56.010 --> 00:01:56.680
of characters.

28
00:01:56.690 --> 00:01:57.150
So.

29
00:01:58.250 --> 00:02:06.490
You can just index into it and you get a single character string out of it, as you can see on the screen.

30
00:02:06.980 --> 00:02:12.800
However, in Ruby, one point eight string are sequences of bytes, and that's completely unaware of

31
00:02:12.800 --> 00:02:13.460
the encoding.

32
00:02:13.700 --> 00:02:20.570
If you index into a string and that string uses a modified encoding, you risk indexing right into the

33
00:02:20.570 --> 00:02:22.220
middle of a multi byte character.

34
00:02:22.220 --> 00:02:28.940
In this example, the capital you, which you have printed when you indexed on the position of a zero.

35
00:02:30.560 --> 00:02:37.970
That is basically encoded, so if you are using Ruby one point eight or even below that, then this

36
00:02:37.970 --> 00:02:44.420
is going to return some kind of value that is basically going to be a multi byte encoding message.

37
00:02:44.690 --> 00:02:51.280
So you may get a, let's say, a 120, 130, 140 and any kind of message that the specific character

38
00:02:51.290 --> 00:02:53.270
you're referencing to is encoded with.

39
00:02:53.270 --> 00:02:55.700
And that is going to be a multi byte coding.

40
00:02:55.940 --> 00:03:01.370
And if you let's say you want to just see how you are with this or underscore and you can have this

41
00:03:01.370 --> 00:03:08.000
you here, but if you use the very same context in Ruby one point eight or even below that, then it

42
00:03:08.000 --> 00:03:10.670
is going to generate a garbage value.

43
00:03:10.970 --> 00:03:18.530
However, a regular expressions and some specialized string method support at least a small subset of

44
00:03:18.530 --> 00:03:19.610
popular encodings.

45
00:03:19.610 --> 00:03:27.190
Among them are some of the Japanese encoding and some that have the formation of the UTF ed.

46
00:03:27.590 --> 00:03:33.140
So if you want to have no kind of errors and you want to run this thing perfectly fine, you should

47
00:03:33.140 --> 00:03:35.390
have Ruby one point nine or about that.

48
00:03:35.660 --> 00:03:40.880
Nowadays you already have the, I guess Ruby two point seven, I guess.

49
00:03:41.100 --> 00:03:46.430
So you should not be using the old average and you should always be upgraded to the latest version to

50
00:03:46.430 --> 00:03:47.670
use the latest features.

51
00:03:48.020 --> 00:03:55.040
So that's how basically you can extract single characters from string with the bracket syntax.

52
00:03:55.250 --> 00:03:58.400
So I guess that's it with the studio.

53
00:03:58.430 --> 00:04:00.470
Thank you so much, guys, for watching.

54
00:04:00.470 --> 00:04:02.930
And I'll see you guys in the next tutorial.
