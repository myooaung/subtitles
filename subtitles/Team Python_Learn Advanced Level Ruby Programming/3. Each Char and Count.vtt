WEBVTT
1
00:00:00.330 --> 00:00:01.260
Hey, guys, what's up?

2
00:00:01.290 --> 00:00:05.870
This is American, and I welcome you to another drill, this course on Ruby and this story.

3
00:00:06.000 --> 00:00:09.610
We are again going to be covering two functions that are going to be used to its strengths.

4
00:00:10.170 --> 00:00:14.510
The first function we are going to be using is the each function.

5
00:00:15.120 --> 00:00:21.300
Now, sometimes you have been given a string and you need to go over it character by character, which

6
00:00:21.300 --> 00:00:26.110
means that you want to iterate or characters of a string in Ruby.

7
00:00:26.370 --> 00:00:32.610
Now it can easily be done after using the split function to cut up what you have already covered in

8
00:00:32.610 --> 00:00:34.130
the previous trattoria.

9
00:00:34.410 --> 00:00:37.770
But there is one more method which can be used.

10
00:00:37.920 --> 00:00:40.060
That is the each char function.

11
00:00:40.560 --> 00:00:42.420
So how it is going to be used?

12
00:00:42.420 --> 00:00:43.970
We are going to see examples for that.

13
00:00:43.980 --> 00:00:47.320
But before that you have to see the syntax of how this is going to work.

14
00:00:47.610 --> 00:00:52.440
It is a bit different from the split function you have to write in the string, not each other, and

15
00:00:52.440 --> 00:00:54.180
then you have to write in the character.

16
00:00:54.180 --> 00:00:59.490
Basically, that is the parameter from which it is going to split the string and then you can accessors

17
00:00:59.910 --> 00:01:03.540
access them within these curly brackets, which you have specified.

18
00:01:04.900 --> 00:01:11.170
The second method we are going to be using is going to be the count function and it is a string class

19
00:01:11.170 --> 00:01:12.190
method in Ruby.

20
00:01:12.400 --> 00:01:17.560
In this method, each barometer's defines a set of characteristics, which is to be counted.

21
00:01:17.800 --> 00:01:22.580
The intersection of these sets defines the characters to count in the given strength.

22
00:01:22.900 --> 00:01:29.980
Now, any character string which starts on with a carrot is basically going to get negated and how it

23
00:01:29.980 --> 00:01:30.880
is going to get negated.

24
00:01:30.920 --> 00:01:36.040
You are going to see them in the examples, but before that, you also have to see the syntax of this.

25
00:01:36.100 --> 00:01:42.850
It is going to be a string and dot count and the parameter here is going to be, again, the given string

26
00:01:43.570 --> 00:01:45.430
for which you want to condone something.

27
00:01:45.640 --> 00:01:47.740
So you will see what it is.

28
00:01:48.160 --> 00:01:54.470
So let's move on to the examples and let's color both of these functions here.

29
00:01:55.210 --> 00:01:57.870
So we will start on with the each char function.

30
00:01:57.880 --> 00:02:04.270
But before that, you have to understand the difference, how it is going to be different from the split

31
00:02:04.270 --> 00:02:04.680
function.

32
00:02:04.960 --> 00:02:07.840
So we are going to be covering three examples.

33
00:02:07.840 --> 00:02:15.250
In the first example, we will use the split function and we will split the screen using the empty string

34
00:02:15.250 --> 00:02:15.950
as operator.

35
00:02:15.970 --> 00:02:18.700
That is, we want to cut the string every place.

36
00:02:18.700 --> 00:02:22.720
We will find an empty string and we will use the each function with that.

37
00:02:23.060 --> 00:02:28.150
Then we will have another example in which we will use the very same split function.

38
00:02:28.420 --> 00:02:35.200
And this time we will call the each method right on top of the result that is received from the split

39
00:02:35.200 --> 00:02:35.530
function.

40
00:02:35.530 --> 00:02:41.350
And in the third example, we will then use that each function and you'll see that how it is basically

41
00:02:41.350 --> 00:02:45.760
easier than using the each function with the split function.

42
00:02:45.800 --> 00:02:49.030
So, for example, we have, let's say, some input.

43
00:02:51.100 --> 00:02:57.820
That is A, B, C, D, E, F, g, or you can write whatever you want, then what you are going to

44
00:02:57.820 --> 00:03:01.930
do is that you're going to write an equal to input.

45
00:03:04.690 --> 00:03:12.190
Dodd split, and you are going to just have a space over here that is going to actually convert every

46
00:03:12.190 --> 00:03:14.900
number into a single element of the array.

47
00:03:15.100 --> 00:03:21.130
So we are going to just try and puts it on land that is going to return the land for us.

48
00:03:21.490 --> 00:03:24.880
And what we are going to do is that we are going to write in votes.

49
00:03:26.680 --> 00:03:28.300
A tree, let's say.

50
00:03:28.330 --> 00:03:35.620
So that is going to return the third element for us and let's just add some lines, spaces, or just

51
00:03:35.950 --> 00:03:38.910
leave it as it is for a single line space.

52
00:03:38.920 --> 00:03:42.550
And then what we are going to write in our is that we are going to use now.

53
00:03:43.500 --> 00:03:50.930
This is using the each functions we're going to write, you know, each and we are going to use this,

54
00:03:50.940 --> 00:03:52.560
we are going to write in the character.

55
00:03:52.560 --> 00:03:54.130
We want to specify our health.

56
00:03:54.570 --> 00:03:59.760
So let's say our character is the third character, which is this deal where we are going to write and

57
00:03:59.760 --> 00:04:02.670
be included in these bardawil.

58
00:04:04.550 --> 00:04:09.650
Click, enter, and now you can use this right down here so you can try and put.

59
00:04:11.620 --> 00:04:13.870
And you can just ride in downhill.

60
00:04:17.190 --> 00:04:18.450
So run this code.

61
00:04:19.990 --> 00:04:22.970
And this is totally not what we should expect over here.

62
00:04:22.990 --> 00:04:29.480
Yes, we should not have this line space over here and the legal disappeared that debug that appeared.

63
00:04:30.430 --> 00:04:30.930
All right.

64
00:04:31.030 --> 00:04:33.070
So I guess that is going to now work.

65
00:04:33.070 --> 00:04:33.850
Perfect.

66
00:04:34.240 --> 00:04:38.650
Run the score and you can see that you have got the land, you have got the third element.

67
00:04:38.830 --> 00:04:45.410
And then you can see that you have from this you have got this Abdu right over here.

68
00:04:45.820 --> 00:04:52.000
So the resulting area, which you can see has seven elements in it, as done by the land method.

69
00:04:52.270 --> 00:04:59.860
And the fourth character that is sorry, the fourth character that is at the index three is the letter

70
00:04:59.860 --> 00:05:00.190
D.

71
00:05:00.640 --> 00:05:07.210
So I added these just so we can see the result of the split really behaves like an arrow.

72
00:05:07.420 --> 00:05:13.570
Finally, we use the each method to iterate or the elements of the area that are the characters of the

73
00:05:13.570 --> 00:05:14.590
original string.

74
00:05:15.890 --> 00:05:22.580
And that is basically going on just like for a loop, you can just call it and iterate over all the

75
00:05:22.580 --> 00:05:25.130
elements and it printed them out.

76
00:05:26.560 --> 00:05:28.660
As you can see right here, you've got this ABCDE.

77
00:05:29.890 --> 00:05:36.430
Now we are going to see how split is going to work without a temporary variable in which we will see

78
00:05:36.430 --> 00:05:39.400
an example that will use the same split method.

79
00:05:39.400 --> 00:05:44.800
But this time we call the each method right on top of the result that is going to be received from the

80
00:05:44.800 --> 00:05:45.700
split function.

81
00:05:46.060 --> 00:05:53.410
So what we are going to do is that right here we are going to write an input dot split and this is going

82
00:05:53.410 --> 00:05:54.490
to be as it is.

83
00:05:54.490 --> 00:05:57.670
But right here we are going to write in DOT each.

84
00:05:59.560 --> 00:06:04.210
And with this thought, each what we are going to do is that we are going to write in the variable over

85
00:06:04.210 --> 00:06:07.630
here, our variable was D in our case.

86
00:06:07.630 --> 00:06:12.850
And what you can do right over here is that you can just.

87
00:06:14.340 --> 00:06:23.610
Write in votes, not in caps, it should be Put's, and this deal will help, and what you can just

88
00:06:23.640 --> 00:06:26.790
do is that you can just remove this quote from hell.

89
00:06:27.390 --> 00:06:28.950
So now run this code.

90
00:06:28.950 --> 00:06:32.070
And as you can see that you have, again, got the elements.

91
00:06:32.430 --> 00:06:38.520
And the result, not surprisingly, is the very same as it was with the previous case.

92
00:06:39.080 --> 00:06:45.330
Now, in order to make it even more simple, Ruby supplies a method that is called as each hour that

93
00:06:45.330 --> 00:06:46.860
will do the same work.

94
00:06:47.870 --> 00:06:51.350
And that is what is basically going to be discovered in this story.

95
00:06:51.430 --> 00:06:55.910
So instead of using the split function and the each function, what you can do is that you can use a

96
00:06:55.910 --> 00:07:00.680
single function that is the each function and that is going to do the job of both of these.

97
00:07:01.100 --> 00:07:06.920
So what you can do is that you can just remove it from here or you can just write in each underscore

98
00:07:06.920 --> 00:07:11.150
char and the rest is going to remain the very same.

99
00:07:11.150 --> 00:07:13.650
It is going to be like this, the variable.

100
00:07:13.650 --> 00:07:15.890
Then you have to write in both to run this code.

101
00:07:16.130 --> 00:07:20.430
And as you can see, that you've got the very same output that is abcde ev.

102
00:07:20.940 --> 00:07:21.590
Go ahead.

103
00:07:21.950 --> 00:07:28.810
So basically this each hour is the third way and the most simplest way of using the split function and

104
00:07:28.820 --> 00:07:38.040
each function and to iterate over the elements of an array one by one are you say character to character.

105
00:07:38.930 --> 00:07:46.250
So basically what this each function held out was that it helped that we did not have to include both

106
00:07:46.250 --> 00:07:48.980
those functions that were the each function and the split function.

107
00:07:48.980 --> 00:07:54.510
Rather, you can just use a single function that is that each function and that simplifies the job and

108
00:07:54.510 --> 00:08:00.590
did the very same job as the combined effect of the split and the each function.

109
00:08:00.920 --> 00:08:04.410
So I hope you have understood the usefulness of this function.

110
00:08:04.550 --> 00:08:10.640
So let's move on to the second part of the Dorio that deals with the current function so far that what

111
00:08:10.640 --> 00:08:13.670
we are going to do is that we are going to have a string.

112
00:08:15.660 --> 00:08:18.330
Let's say our strength is going to be.

113
00:08:20.580 --> 00:08:21.270
Anything.

114
00:08:23.540 --> 00:08:30.260
You can just ride in anything useful over a hill and what you can do is that you can just ride in thoughts,

115
00:08:30.260 --> 00:08:32.000
you can just ride and string dot.

116
00:08:33.110 --> 00:08:39.620
Count in the brackets, you have to write in the characters, which is basically going to be a part

117
00:08:39.620 --> 00:08:40.950
of the screen you want to imagine.

118
00:08:40.970 --> 00:08:48.790
So just write in and run this code and you can see that it has generated this four for you.

119
00:08:49.520 --> 00:08:54.430
So that's how it is basically going to work.

120
00:08:56.750 --> 00:09:03.440
Now, you can just have let's say this, I repeat, repeated over here, I know this is not a word,

121
00:09:03.440 --> 00:09:04.170
but just leave it.

122
00:09:04.190 --> 00:09:04.880
Just run it.

123
00:09:05.120 --> 00:09:08.560
And you can see that it has now generated seven for you.

124
00:09:09.170 --> 00:09:11.680
So that's how this gun function basically work.

125
00:09:11.690 --> 00:09:19.130
And as I told you, that if you specify this sign over here or underscore, it is going to actually

126
00:09:19.640 --> 00:09:21.890
have any other restring.

127
00:09:21.890 --> 00:09:25.400
As I told you, it starts with a carrot is going to get negated.

128
00:09:25.430 --> 00:09:28.160
So this is going to get negated and it is going to count.

129
00:09:29.370 --> 00:09:32.130
The remaining string, which makes it five.

130
00:09:33.400 --> 00:09:38.770
And these four, so the answer is nine over here, because it is going to get this high energy and this

131
00:09:38.770 --> 00:09:41.910
high energy over here and nine is going to be your output.

132
00:09:42.130 --> 00:09:45.010
So that's how basically we can function, can be used.

133
00:09:45.020 --> 00:09:48.460
You can also use it with something like.

134
00:09:50.830 --> 00:09:55.540
This Oakhill run, this code, and it has generated some kind of errors.

135
00:09:55.580 --> 00:09:58.440
Yes, we have to specify this over here as well.

136
00:10:03.720 --> 00:10:06.780
You can just specify something like Arborio.

137
00:10:09.280 --> 00:10:14.560
And here, let's say, around this code, and yes, it is going to have some errors.

138
00:10:15.720 --> 00:10:19.770
Yes, it has to be this double bar now run this code.

139
00:10:22.490 --> 00:10:29.270
It has to be coded as well, so let's just call them now, run this and you can see that you have got

140
00:10:29.270 --> 00:10:32.170
this two over here, which means that this occurred twice.

141
00:10:32.660 --> 00:10:37.900
So that's how basically the ground function can be used in your program.

142
00:10:38.420 --> 00:10:40.180
So I guess that's it with this story.

143
00:10:40.230 --> 00:10:42.000
I hope you understood both these functions.

144
00:10:42.010 --> 00:10:43.280
So that's it with the story.

145
00:10:43.370 --> 00:10:44.870
Thank you so much, guys, for watching.

146
00:10:44.870 --> 00:10:47.000
And I'll see you guys in the next tutorial.
