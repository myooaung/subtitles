WEBVTT
1
00:00:00.440 --> 00:00:01.430
Hey, guys, what's up?

2
00:00:01.460 --> 00:00:05.550
This is a marathon, and I welcome you to another tutorial on this course on Ruby uninvested.

3
00:00:05.930 --> 00:00:09.550
We are going to be covering four functions that are related to hashes.

4
00:00:09.980 --> 00:00:11.700
Now, they are very simple function.

5
00:00:11.720 --> 00:00:14.260
That's why I have included all of these in a single tutorial.

6
00:00:14.270 --> 00:00:19.040
Not the first function we are going to go in the studio is going to be the comparable identity function.

7
00:00:19.290 --> 00:00:23.260
The second function we are going to cover in this area is going to be the values function.

8
00:00:23.270 --> 00:00:28.060
Then we are going to see the members function and then finally we are going to see the include function.

9
00:00:28.490 --> 00:00:31.620
So starting on with the compare by identity function.

10
00:00:31.820 --> 00:00:38.330
Now this is a hash class method which compares the hash with its identity and consider the exact same

11
00:00:38.330 --> 00:00:40.250
object as the same keys.

12
00:00:40.700 --> 00:00:45.310
So if you talk about the syntax of this comparable identity function, it is very simple yet.

13
00:00:45.350 --> 00:00:45.590
Right.

14
00:00:45.590 --> 00:00:47.370
And how does that compare by identity?

15
00:00:47.990 --> 00:00:53.400
No arguments are required of him and it is going to work the very in the very simple way as that.

16
00:00:53.960 --> 00:00:58.160
So the second function we are going to cover is going to be the values function.

17
00:00:58.190 --> 00:01:04.070
Now, you have already covered the keys function in the previous tutorial that basically return the

18
00:01:04.070 --> 00:01:09.080
number of keys or you can say the values, the guys that are present in a specific hash.

19
00:01:09.110 --> 00:01:10.340
Now, this values function.

20
00:01:10.340 --> 00:01:16.430
What it is going to do is that it is going to return all the values in a specified hash.

21
00:01:16.640 --> 00:01:22.190
So the syntax for that is going to be hashed out values and whatever hash you are using.

22
00:01:22.190 --> 00:01:28.760
For example, if you're using the hash it, then whatever values are stored in that hash, this function

23
00:01:28.760 --> 00:01:31.670
is going to return you all those values.

24
00:01:32.210 --> 00:01:37.550
Whereas if you just remember the keys function, it return the keys from a certified hash.

25
00:01:37.550 --> 00:01:40.520
But this is going to return the values from a certified hash.

26
00:01:41.140 --> 00:01:46.220
The third function we are going to cover in this tutorial is going to be the member function and it

27
00:01:46.220 --> 00:01:51.230
is also a hash class matter what checks, whether the given key is present in hash or not.

28
00:01:51.920 --> 00:01:55.910
It is very, very, very similar to the function we have already covered.

29
00:01:55.920 --> 00:02:00.290
That was the Haski function and this functional returns either true or false.

30
00:02:01.130 --> 00:02:05.610
If a member is found, it returns true, if a member is not found, it returns false.

31
00:02:05.960 --> 00:02:11.570
The fourth function we are going to cover in this tutorial is the include function you already have

32
00:02:11.570 --> 00:02:15.590
covered, include function in the previous sections, I guess.

33
00:02:15.710 --> 00:02:21.890
But in this tutorial, we are going to see how that include function is going to be used with hashes.

34
00:02:22.130 --> 00:02:27.010
So it is also going to work in a very similar fashion as the member function.

35
00:02:27.200 --> 00:02:29.210
It is going to be hashed out with a question mark.

36
00:02:29.210 --> 00:02:33.950
And the key you have to specify over here, if that key is present in a certain hash, it is going to

37
00:02:33.950 --> 00:02:34.310
return.

38
00:02:34.310 --> 00:02:36.390
True else it is going to return false.

39
00:02:36.710 --> 00:02:41.900
So let's just move on to the example spot and cover one examples of all of these one by one.

40
00:02:41.900 --> 00:02:46.730
So we will start on with the members by identity function.

41
00:02:47.540 --> 00:02:47.830
All right.

42
00:02:47.840 --> 00:02:50.180
So we already have three hashes over here.

43
00:02:50.180 --> 00:02:53.810
What we can do simply over here is that we can just change the format of some of them.

44
00:02:54.350 --> 00:02:57.240
You can just change this to something like this.

45
00:02:57.290 --> 00:02:59.270
We can just specify, let's say.

46
00:03:00.670 --> 00:03:04.370
Strain to this and let's say this value here is no.

47
00:03:05.080 --> 00:03:12.040
So we have actually changed some of the value, some by using its syntax, some by converting them to

48
00:03:12.040 --> 00:03:14.000
strings and some values as well.

49
00:03:14.000 --> 00:03:17.700
Let's say we have got one more Nelva here as well.

50
00:03:18.630 --> 00:03:27.780
And let's say this is also encoded, so now we have got a cluster of identities right over here.

51
00:03:27.810 --> 00:03:30.110
This is a separate Syntex.

52
00:03:30.120 --> 00:03:33.240
This has of that, you know, this has a string stored.

53
00:03:33.250 --> 00:03:34.350
This has a string start.

54
00:03:34.800 --> 00:03:38.360
This, again, has another value and this has an integer type value.

55
00:03:38.370 --> 00:03:41.100
So everything is now defined by identity.

56
00:03:41.130 --> 00:03:45.900
Now, what we are going to do is that we are going to use the comparable identity function right away.

57
00:03:46.290 --> 00:03:49.140
So what we are going to write in, we are going to write input's.

58
00:03:52.230 --> 00:04:02.490
Identity check form for a column, interpellation and interpellation, what are you going to write and

59
00:04:02.490 --> 00:04:03.750
you are going to write an OR.

60
00:04:05.210 --> 00:04:12.200
Compare, underscore to underscore identity, no parameters are required.

61
00:04:12.230 --> 00:04:13.100
Just run it.

62
00:04:14.890 --> 00:04:21.480
All right, so I guess the address is I guess the question mark will help run it now.

63
00:04:25.060 --> 00:04:30.360
All right, it has to be by identity, not to identity, so that's one error was generated.

64
00:04:30.370 --> 00:04:31.860
We don't need a question mark over here.

65
00:04:32.290 --> 00:04:34.720
Run it now and now it has performed identity check.

66
00:04:34.720 --> 00:04:41.050
And now, as you can see or hear that it is telling us everything that is a part of this.

67
00:04:41.050 --> 00:04:46.240
As you can see that it is telling us that this Syntex Ohare is used, that is the colonists index to

68
00:04:46.240 --> 00:04:47.190
identify a key.

69
00:04:47.470 --> 00:04:48.760
And this is the value for that.

70
00:04:48.880 --> 00:04:53.140
And for the second part, you have used this index that is encoded in me.

71
00:04:53.150 --> 00:04:56.140
So that's why it has done that to you will help.

72
00:04:56.410 --> 00:04:59.080
Similarly, if you just type in this for.

73
00:05:00.630 --> 00:05:09.690
Identity check form for hash, be antipollution, and you can just write and be dot.

74
00:05:11.450 --> 00:05:12.350
Compar.

75
00:05:13.490 --> 00:05:15.740
By identity.

76
00:05:19.600 --> 00:05:26.680
Run this and you can see that you've got this Syntex, then you have got this Syntex with a string value

77
00:05:26.680 --> 00:05:33.460
and then you have got a nil value with the Collinses index, then you can simply do it for the third

78
00:05:33.460 --> 00:05:34.050
one as well.

79
00:05:34.060 --> 00:05:38.720
You can just write an identity check from.

80
00:05:40.630 --> 00:05:45.610
Foresee a column interpellation and you can just write in C dot.

81
00:05:47.210 --> 00:05:47.930
Compar.

82
00:05:50.070 --> 00:05:52.470
By identity.

83
00:05:54.260 --> 00:05:54.990
Horrendous.

84
00:05:55.250 --> 00:06:00.170
And you can see that you've got this, I guess we have just misspelled one of them.

85
00:06:01.490 --> 00:06:07.910
All right, we have as we have just had an additional EOWA here and I'll run it now, it is going to

86
00:06:07.910 --> 00:06:08.740
run perfectly.

87
00:06:09.050 --> 00:06:12.080
And as you can see that you have got a comparison check.

88
00:06:12.110 --> 00:06:15.060
Whatever was Ohare is being written overhead.

89
00:06:15.230 --> 00:06:18.930
This means that everything is treated as a different object.

90
00:06:18.950 --> 00:06:24.260
For example, if this had a string, it is treating it by its identity and it is comparing it by its

91
00:06:24.260 --> 00:06:27.670
identity and it is giving us whatever is used over here.

92
00:06:27.680 --> 00:06:30.260
If you're using this index, it is giving you this index.

93
00:06:30.500 --> 00:06:33.380
If you're using this index, it is giving you this index.

94
00:06:33.380 --> 00:06:34.460
So that is what it's called.

95
00:06:34.610 --> 00:06:37.250
Compare by identity in Ruby.

96
00:06:37.970 --> 00:06:43.130
So now moving to the second to second function, we are going to cover in this tutorial that is the

97
00:06:43.130 --> 00:06:44.320
values function.

98
00:06:44.330 --> 00:06:46.490
So you can just write inputs.

99
00:06:47.840 --> 00:06:50.360
Values in our.

100
00:06:52.180 --> 00:06:58.120
Colin, interpellation and, well, you can simply ride and you can ride an arrow values racket's run

101
00:06:58.120 --> 00:07:02.140
it and you can see that it is printed out the values that are one hundred and two hundred, which are

102
00:07:02.140 --> 00:07:03.030
the values index.

103
00:07:03.310 --> 00:07:06.160
So you can just ride in your values as well.

104
00:07:06.160 --> 00:07:10.710
Ronda's and it is going to ride on Hundert a string two hundred and Unell as well.

105
00:07:10.960 --> 00:07:14.680
So that is what is basically how you can use the values function.

106
00:07:14.680 --> 00:07:18.280
It works in a very similar fashion as the Keys function which return the keys.

107
00:07:18.280 --> 00:07:22.000
But this values function is going to retain the values in a certified fashion.

108
00:07:22.000 --> 00:07:28.360
In this case that is beyond the heart function we are going to cover in this tutorial as the member

109
00:07:28.360 --> 00:07:31.520
function, which checks whether the giver is present in a hash or not.

110
00:07:31.870 --> 00:07:35.550
So what you can do is that you can just remove this from here.

111
00:07:35.560 --> 00:07:38.410
You can write in member a question mark.

112
00:07:40.250 --> 00:07:43.220
And you can just write in value.

113
00:07:47.650 --> 00:07:48.910
Exist is.

114
00:07:49.890 --> 00:07:55.200
And you can just write and be a member and for example, you want to check in for the see so you can

115
00:07:55.200 --> 00:07:59.270
just write and call and see roundish and it is returned.

116
00:07:59.300 --> 00:07:59.600
True.

117
00:07:59.610 --> 00:08:04.700
Which means that this guy is present in this harsh bio hell.

118
00:08:04.710 --> 00:08:08.790
If you just type in something that is not a part of it, you can see that it will return parts.

119
00:08:08.790 --> 00:08:13.830
Now, doesn't matter if this is has a new value in this as a string value, it doesn't matter at all.

120
00:08:14.160 --> 00:08:16.410
All that matters is that key is present or not.

121
00:08:16.710 --> 00:08:20.370
Now, if you just write in below here Ronda's, you can see that it has printed it out.

122
00:08:20.670 --> 00:08:25.470
But if you just write an idiot member and just write and call and be O'Haire, it is going to return

123
00:08:25.470 --> 00:08:25.720
false.

124
00:08:25.740 --> 00:08:28.520
And the reason behind this is that we are using this index over here.

125
00:08:28.530 --> 00:08:32.340
So what, that we are also to use this index over here.

126
00:08:32.370 --> 00:08:34.650
So if we now run it, it is going to return.

127
00:08:34.650 --> 00:08:34.930
True.

128
00:08:35.190 --> 00:08:38.200
So that was basically about the syntax.

129
00:08:38.220 --> 00:08:42.570
Now the fourth function we are going to cover in this tutorial is the include function.

130
00:08:42.570 --> 00:08:47.110
And as I told you, it works in the very, very same fashion as the member function.

131
00:08:47.130 --> 00:08:50.400
All you have to do is that you have to write and include Abargil.

132
00:08:51.910 --> 00:08:57.070
Run this and it is going to, as you can see, return true and the same goes about the syntax.

133
00:08:57.070 --> 00:09:02.410
If you just write in Colombia over here for this a run, it it is not going to it is going to run,

134
00:09:02.410 --> 00:09:06.290
but it is going to generate false because of this syntax difference.

135
00:09:06.310 --> 00:09:07.600
If you want this to return.

136
00:09:07.600 --> 00:09:07.840
True.

137
00:09:07.840 --> 00:09:14.440
Your writing in quotation marks, be here and it is going to then return to include function also does

138
00:09:14.440 --> 00:09:18.600
not see if something is nil or something like that.

139
00:09:18.610 --> 00:09:22.260
If you just write in the square, you know that this does not is a part of it.

140
00:09:22.360 --> 00:09:27.190
That's it is written because if you just write a deed or include runit, it is going to return.

141
00:09:27.190 --> 00:09:27.640
True.

142
00:09:27.850 --> 00:09:28.780
And says you can see that.

143
00:09:28.780 --> 00:09:29.640
See the part of it.

144
00:09:29.640 --> 00:09:31.290
It has the value nil.

145
00:09:31.540 --> 00:09:37.120
But since C is present because member function and include function checks, if a key is present or

146
00:09:37.120 --> 00:09:41.610
not, it doesn't matter if it has a value or if it has a nil value.

147
00:09:41.980 --> 00:09:46.300
So that's how basically all these four functions are used in Ruby.

148
00:09:46.300 --> 00:09:47.890
So I hope you have understood them.

149
00:09:48.130 --> 00:09:49.910
So I guess that's it with this tutorial as well.

150
00:09:49.920 --> 00:09:52.260
Thank you so much for watching and I'll see you guys later.
