WEBVTT
1
00:00:00.360 --> 00:00:01.350
Hey, guys, what's up?

2
00:00:01.380 --> 00:00:06.340
This is a marathon, and I welcome you to another Dorelle on this course, on Ruby and in this area

3
00:00:06.360 --> 00:00:10.880
we will see how to sort the elements that are stored in a single area.

4
00:00:11.220 --> 00:00:13.730
So sorting data is a common practice.

5
00:00:13.740 --> 00:00:19.710
You may need to advertise a list of names are sort the numbers from smallest to the largest.

6
00:00:20.070 --> 00:00:26.630
Now, Ruby arrays have a reverse method which can reverse the order of the elements in an error.

7
00:00:26.880 --> 00:00:33.000
If you have a list of data that is already organized and the reverse is going to be a quick way to flip

8
00:00:33.000 --> 00:00:33.920
the elements around.

9
00:00:33.930 --> 00:00:39.990
So if you have this very same area, then all you can do is that just initialize one more variable,

10
00:00:39.990 --> 00:00:44.610
RTV, and just write in and start reverse on this.

11
00:00:45.980 --> 00:00:51.350
And down here, just right and thoughts are around the school and you can see that the elements have

12
00:00:51.350 --> 00:00:58.460
been just river, as you can see that it starts from Eddie c.B and a which are totally in reverse order,

13
00:00:58.460 --> 00:00:59.950
as you can see right over here.

14
00:01:02.000 --> 00:01:08.300
Now, the reverse method basically returns a new era and it does not modify the original.

15
00:01:08.480 --> 00:01:15.110
Now, if you use the reverse with an exclamation mark method, then you can just have a change in the

16
00:01:15.110 --> 00:01:16.910
original area as well.

17
00:01:17.210 --> 00:01:23.490
However, reversing an error is not always the most efficient or practical way to sort the data.

18
00:01:23.960 --> 00:01:28.270
We have to use the same method to start the elements in that area.

19
00:01:28.460 --> 00:01:33.700
You would like for simple arrays of strings or in numbers.

20
00:01:33.710 --> 00:01:39.620
Let's say Assad method is efficient and it will give you the result you are looking for.

21
00:01:39.830 --> 00:01:45.560
So if you have an error in which you have goal, let's say unsorted elements, then what it is going

22
00:01:45.560 --> 00:01:47.570
to do is that it is going to start the element.

23
00:01:47.620 --> 00:01:53.150
So if you have, let's say AC and we have these, then we have got let's say Blackhill.

24
00:01:54.470 --> 00:01:58.170
And then we have got EOA here and finally we have got its EFO here.

25
00:01:58.340 --> 00:02:03.780
Let's just change this to and this to eat so you can see that they are not in order.

26
00:02:03.800 --> 00:02:08.900
All you can do is that just right in the dark matter for this right in the fall.

27
00:02:09.140 --> 00:02:13.580
This to be Asadi that look much more like what we are doing.

28
00:02:13.580 --> 00:02:15.440
So right in Ezzati Oakhill.

29
00:02:17.500 --> 00:02:21.010
Run the scoreboard and you can see that the elements have been arranged.

30
00:02:21.230 --> 00:02:28.780
You can see A, B, C, D, E, F, or here you can see that it is A, B, E, and a lot of different

31
00:02:28.780 --> 00:02:29.110
things.

32
00:02:29.440 --> 00:02:35.460
But out here, you can see that the area has been sorted out in a very beautiful and organized way.

33
00:02:36.790 --> 00:02:43.600
Now, holler if you want to start things a different way, you will want to call this, you will want

34
00:02:43.600 --> 00:02:48.510
to tell the secret method how to do that because, for example, you don't want it to get started in

35
00:02:48.520 --> 00:02:48.970
this way.

36
00:02:49.330 --> 00:02:53.770
What the solid function is going to do is that it is going to also ask you that how you want to sort

37
00:02:53.770 --> 00:02:56.140
that sort method takes are will be blocked.

38
00:02:56.150 --> 00:03:03.120
That gives you access to the elements in an array so you can compare them as well to do the comparison

39
00:03:03.130 --> 00:03:03.610
you use.

40
00:03:03.610 --> 00:03:07.900
The comparison operator often referred to as the spaceship operator.

41
00:03:08.090 --> 00:03:12.100
This operator, compare that to Ruby objects and return minus one.

42
00:03:12.100 --> 00:03:18.040
If the object on the left is smaller and it returns, a zero of the objects are the same and it returns

43
00:03:18.040 --> 00:03:22.480
one if the object on the left side is greater.

44
00:03:24.070 --> 00:03:29.780
So to give you a summary of what I'm talking, let's just write in certain comments over here.

45
00:03:30.100 --> 00:03:37.060
So if you have, let's say, a one on this side, then you have this spaceship comparison operator that

46
00:03:37.060 --> 00:03:40.330
is something like this and you've got this dual hill.

47
00:03:40.330 --> 00:03:44.110
Then you have another condition in which you have got, let's say.

48
00:03:45.860 --> 00:03:54.200
Do a hill and you have got this to over here as well, and then the final condition is that the elements

49
00:03:54.200 --> 00:03:57.370
on the left hand side is now greater.

50
00:03:57.370 --> 00:03:59.570
So let's say it is due this time.

51
00:04:03.110 --> 00:04:09.820
And this element of war here is one, so the expected output for this is going to be minus one for this,

52
00:04:09.830 --> 00:04:11.780
it is going to be zero.

53
00:04:12.110 --> 00:04:14.840
And for this O'Haire, it is going to be plus one.

54
00:04:14.850 --> 00:04:20.420
So if the value on the right hand side is greater than the left hand side, then minus one is going

55
00:04:20.420 --> 00:04:21.200
to be redone.

56
00:04:21.380 --> 00:04:26.260
If the values on the left hand side and the right hand side are equal, then it is going to return zero.

57
00:04:26.390 --> 00:04:31.640
And if the value on the left hand side is greater and the right hand side is smaller than it is going

58
00:04:31.640 --> 00:04:32.950
to return one.

59
00:04:33.140 --> 00:04:40.490
So the Ruby Sword method, except a block that must return either minus one, either a zero or it will

60
00:04:40.490 --> 00:04:42.050
return a one which it.

61
00:04:43.450 --> 00:04:46.600
Then uses to start the values in the area.

62
00:04:47.020 --> 00:04:55.000
So now let's see an example that explicitly compares the entries in the area to start them in ascending

63
00:04:55.000 --> 00:04:55.490
order.

64
00:04:55.810 --> 00:05:00.120
So what you can do here is that you can just simply compare.

65
00:05:00.280 --> 00:05:04.780
But for that, we need, let's say, some different elements so that things are much more clear.

66
00:05:06.020 --> 00:05:09.080
So let's say we have the elements as.

67
00:05:10.540 --> 00:05:16.330
Names of animals, let's say you've got Tiger, then we have got let's say.

68
00:05:20.750 --> 00:05:21.770
Great White.

69
00:05:23.440 --> 00:05:27.010
Then let's say we have got so these are basically random entries.

70
00:05:28.130 --> 00:05:31.680
And let's say finally, we have got a table over here.

71
00:05:32.090 --> 00:05:34.840
So these are basically some random entries.

72
00:05:35.130 --> 00:05:42.320
Let's just make it to tables so that it is from a different character, not from the if you do it completely

73
00:05:42.320 --> 00:05:43.630
fine, it will sort it as well.

74
00:05:43.910 --> 00:05:46.550
But we want it to be from a different character.

75
00:05:46.580 --> 00:05:53.210
So now what you can do is that you can use the comparison operator over here using the search function.

76
00:05:53.220 --> 00:05:55.970
So SRT is going to be the same exact sort.

77
00:05:56.360 --> 00:06:03.590
And what you have to do here is that you want to use to excess from this and want to compare them.

78
00:06:03.770 --> 00:06:08.930
So for that, where you have to do is that you have to write in bars and in that you're trying to use

79
00:06:08.930 --> 00:06:09.080
that.

80
00:06:09.470 --> 00:06:14.120
And B, are those values what you want to compare for the first time and what you're going to write

81
00:06:14.120 --> 00:06:17.930
and you're going to write and you're going to write in the comparison operator and you're going to write

82
00:06:17.930 --> 00:06:18.500
and be.

83
00:06:19.780 --> 00:06:25.390
That what you can simply do is that you have to write in print SRT and that is going to do your job

84
00:06:25.570 --> 00:06:32.380
or underscored and it is going to just sort your error in ascending order.

85
00:06:32.390 --> 00:06:36.880
As you can see that you've got Abel and you've got the one starting with G, then you've got the one

86
00:06:36.880 --> 00:06:41.030
sided with Edge and finally you've got the one starting with a D..

87
00:06:41.920 --> 00:06:47.650
So basically here are the eight and B variables represent the individual elements in the area that are

88
00:06:47.650 --> 00:06:49.300
compared one by one.

89
00:06:49.300 --> 00:06:53.600
And the result looks something like this, as you can see on the atom or there as well.

90
00:06:53.860 --> 00:06:58.990
Now, to sort this very same array and you want to just sort it adopted that.

91
00:06:58.990 --> 00:07:04.020
You want to reverse its order as well, then you can reverse the objects in the comparison operator.

92
00:07:04.300 --> 00:07:08.500
You can just write in Bohle and you can just write an e-mail here.

93
00:07:08.650 --> 00:07:13.090
And that is going to just sort this area in reverse order.

94
00:07:13.120 --> 00:07:13.810
Just run it.

95
00:07:13.810 --> 00:07:19.540
And you can see that now Tiger is at the top, hammer at at second, Redway the third, and Able is

96
00:07:19.540 --> 00:07:21.360
at the lowest position.

97
00:07:21.370 --> 00:07:24.790
So now they have been started and you can see a descending order.

98
00:07:26.430 --> 00:07:33.270
Now, the start method is great for areas that contain simple data like integer floats and string,

99
00:07:33.270 --> 00:07:39.200
but when errors contain more complex object, you will have to do a lot more work.

100
00:07:39.570 --> 00:07:48.540
But what you can do is that you can have an array of hashes with each hash representing element that

101
00:07:48.540 --> 00:07:49.930
is stored in this area.

102
00:07:50.460 --> 00:07:53.480
So you can have this very same area.

103
00:07:53.490 --> 00:07:59.190
What you can do is that you can convert it into a hash and what is a hash that will be covered in the

104
00:07:59.190 --> 00:07:59.700
next section.

105
00:07:59.700 --> 00:08:02.070
But for now, all you need to do is that you have to write in.

106
00:08:03.130 --> 00:08:06.280
This will then you have to ride in this whole here again.

107
00:08:10.660 --> 00:08:14.330
This here again, and just remove the last entry from here.

108
00:08:16.500 --> 00:08:22.750
So these are the three entries, we can just put an entry so that they are much more visible.

109
00:08:23.280 --> 00:08:23.840
All right.

110
00:08:24.090 --> 00:08:26.430
So there are now much more visible.

111
00:08:26.460 --> 00:08:32.160
So basically what this is, this is basically the key and this is the value that is associated with

112
00:08:32.160 --> 00:08:32.470
this key.

113
00:08:32.490 --> 00:08:33.560
This is, again, the key.

114
00:08:33.660 --> 00:08:34.590
This is, again, the key.

115
00:08:34.590 --> 00:08:37.720
And these are the values, respectively, with these keys.

116
00:08:37.950 --> 00:08:41.280
So starting this with the sword function is not going to be easy.

117
00:08:41.280 --> 00:08:44.240
Calling sort on the area is going to simplify.

118
00:08:44.340 --> 00:08:49.490
So if you just do it like this, run this code, it is going to generate an error message for you.

119
00:08:49.740 --> 00:08:56.610
And the error message is basically that it says warning name is duplicated and overwritten on line to

120
00:08:56.610 --> 00:08:59.970
name is duplicated in a an online tree again.

121
00:09:01.250 --> 00:09:05.920
So in order to do the comparison, we will have to tell us our function, what we want to compare,

122
00:09:06.110 --> 00:09:10.160
so we will compare the values of the goal here.

123
00:09:10.520 --> 00:09:17.960
So we will double the star function that basically this is a hash over here and we want to compare hashes

124
00:09:17.960 --> 00:09:18.410
over here.

125
00:09:18.830 --> 00:09:24.470
So what you are going to write in that this warrior, that is the argument that is going to be received

126
00:09:24.470 --> 00:09:28.550
in this function is going to be the very same and we are going to be the values.

127
00:09:28.910 --> 00:09:35.200
But in the comparison operator, we have to tell it that we want to compare guey of the hashes here.

128
00:09:35.210 --> 00:09:39.080
And this is basically the key of the hash we want to compare.

129
00:09:39.410 --> 00:09:45.770
So to compare, what you can do is that you can just first just change into the previous case.

130
00:09:45.770 --> 00:09:46.520
That was to.

131
00:09:48.190 --> 00:09:50.050
Just assemble it in The Ascender.

132
00:09:50.430 --> 00:09:55.690
You have to ride in it, and after that, what do you have to ride and you have to ride in this square

133
00:09:55.690 --> 00:09:58.180
brackets and in that you have to ride in Colin.

134
00:09:59.610 --> 00:10:04.080
And then you have to write in the name of the key and finally O'Haire, you have to also and call an

135
00:10:04.080 --> 00:10:06.750
Namoa here and now just run it.

136
00:10:07.110 --> 00:10:10.860
And it is again generating an error, which you should not have.

137
00:10:13.920 --> 00:10:19.560
And it says that it is, again, just deduplication error, sorry, my bad, you have to ride in these

138
00:10:20.430 --> 00:10:28.170
curly brackets around each of them because four in a single area and in not in this what it is going

139
00:10:28.170 --> 00:10:32.190
to do, it is going to treat all of these are single and that's why it is going to generate an error.

140
00:10:32.190 --> 00:10:38.820
That's his duplication of the key, because a key is always unique in the single brackets we have specified

141
00:10:38.840 --> 00:10:39.020
overhead.

142
00:10:39.060 --> 00:10:40.170
These are the brackets.

143
00:10:40.180 --> 00:10:40.650
So.

144
00:10:41.930 --> 00:10:46.900
If you want to specify two elements in a single curly bracket that has to be with a different name,

145
00:10:46.910 --> 00:10:49.430
if it is not, then it is going to generate this error.

146
00:10:49.850 --> 00:10:52.610
And I guess now it is going to run perfectly fine.

147
00:10:52.610 --> 00:10:57.980
And you can see that it has and you can see that you've got great white, then you've got Hammerhead

148
00:10:57.980 --> 00:10:59.420
and then you have got DelGrosso.

149
00:10:59.420 --> 00:11:06.350
The array has been sorted out and that was how to just organize an area or you can set up an area which

150
00:11:06.350 --> 00:11:07.780
contains hashes.

151
00:11:08.000 --> 00:11:12.700
So you did it way by using the key in the hash.

152
00:11:13.040 --> 00:11:18.320
So when you are working with more complex structure, you might want to look at the start by method

153
00:11:18.320 --> 00:11:24.790
instead, which instead of this Sard function, which uses a more efficient algorithm for sorting the

154
00:11:24.800 --> 00:11:31.010
sword by, takes a blog that only requires one argument that is the reference to the current elements

155
00:11:31.010 --> 00:11:31.650
in the area.

156
00:11:31.670 --> 00:11:37.460
So if you want to have such kind of complex structure get started and you can use the SA by function

157
00:11:37.460 --> 00:11:43.840
in place of the search function and that is a bit more easier than the SA function.

158
00:11:43.900 --> 00:11:47.840
So for that, you have to write and sort of underscore biological.

159
00:11:49.110 --> 00:11:53.370
And after that, what do you have to do is that you have only specified in one argument, so you're

160
00:11:53.370 --> 00:12:00.450
going to write and let's say Hill and then you're going to write in X since you are using hashes over

161
00:12:00.450 --> 00:12:00.650
here.

162
00:12:00.660 --> 00:12:02.970
So you're going to just write an X column Namoa.

163
00:12:02.970 --> 00:12:07.790
He'll just print it out, run this and it is going to generate the very same output.

164
00:12:08.010 --> 00:12:11.270
So the third by method implements a.

165
00:12:12.330 --> 00:12:18.420
Different algorithm that is known as the short scene transform, which is basically a sorting algorithm

166
00:12:18.420 --> 00:12:25.020
best suited for comparing objects based on the value of a specific key, therefore, you will find yourself

167
00:12:25.020 --> 00:12:30.870
using Saadeh by whenever comparing a collection of objects as it is much more efficient than the search

168
00:12:30.870 --> 00:12:31.290
function.

169
00:12:31.590 --> 00:12:37.710
Now both the sword and the sword by basically return new areas, leaving the original area intact.

170
00:12:37.890 --> 00:12:43.080
If you want to modify the original area, the very same logic, you can just go on with Sard and start

171
00:12:43.080 --> 00:12:44.530
by with an exclamation mark.

172
00:12:44.940 --> 00:12:51.090
Now addition, in addition to starting values, you might also want to do a lot of things more with

173
00:12:51.090 --> 00:12:51.540
arrows.

174
00:12:51.810 --> 00:12:56.080
And that is what we will be discussing in the next tutorial.

175
00:12:56.310 --> 00:12:58.560
So far, this tutorial, I guess that's it.

176
00:12:58.560 --> 00:13:03.120
I hope you now know how to sort the elements, how to use the sword, how to use the sword by function,

177
00:13:03.120 --> 00:13:09.810
and how to just start the element that is a bit more complex, that contains hashes and how to sort

178
00:13:09.810 --> 00:13:10.890
it with the help of keys.

179
00:13:11.130 --> 00:13:12.770
So I guess that's it with this tutorial.

180
00:13:12.780 --> 00:13:16.950
Thank you so much for watching and I'll see you guys in the next tutorial.
