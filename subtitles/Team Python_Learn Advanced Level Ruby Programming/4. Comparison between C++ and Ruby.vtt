WEBVTT
1
00:00:00.300 --> 00:00:01.440
Hey, guys, what's up?

2
00:00:01.470 --> 00:00:07.180
This is a marathon, and I welcome you to another story on this course on Ruby and I that told you in

3
00:00:07.180 --> 00:00:14.200
the previous tutorial we are going to be covering the comparison between Ruby and C++ in this tutorial.

4
00:00:14.490 --> 00:00:21.450
So we're starting off with some of the similarities between the two languages, just like in C++, in

5
00:00:21.450 --> 00:00:29.730
Ruby, the public, private and protected works in a very similar way as they work in C++.

6
00:00:29.970 --> 00:00:37.680
Now, inheritance syntax is still only one character, but the only difference is that in Ruby you have

7
00:00:37.680 --> 00:00:42.570
to use a colon instead of the less than key word that is used in C++.

8
00:00:43.750 --> 00:00:51.490
The next one is that the way namespace is used in C++, in the similar way, we may put our code into

9
00:00:51.490 --> 00:00:53.920
modules in Ruby as well.

10
00:00:54.700 --> 00:01:01.480
One more similarity here is that there are many similar operators that are found in Ruby as well as

11
00:01:01.480 --> 00:01:04.330
there are found in the C++ programming languages.

12
00:01:04.690 --> 00:01:10.750
And the last one is that tor the keyboard names have been changed to protect the innocent.

13
00:01:11.050 --> 00:01:16.480
Exceptions work in a similar manner as it work in C++.

14
00:01:16.480 --> 00:01:24.580
Only the keywords have been changed by the working criteria is the very same for the exceptions as they

15
00:01:24.580 --> 00:01:25.770
are in C++.

16
00:01:25.780 --> 00:01:29.210
You will encounter exceptions in the future tutorials.

17
00:01:30.490 --> 00:01:34.690
So now we're talking about some of the comparisons between the two languages.

18
00:01:35.110 --> 00:01:42.820
The first one is that in a ruby, every variable is just an automatically dereference name for some

19
00:01:42.820 --> 00:01:51.700
object, which means that there is no explicit reference in Ruby, whereas in C++, unlike Ruby, there

20
00:01:51.700 --> 00:01:54.690
is explicit reference in C++.

21
00:01:55.360 --> 00:02:05.950
The next one is that objects are strongly but dynamically typed in Ruby and in C++ objects are not strongly

22
00:02:05.950 --> 00:02:07.480
type as that in Ruby.

23
00:02:08.590 --> 00:02:16.030
The constructor is called Initialise instead of the class name, whereas this is not the case in C++.

24
00:02:16.840 --> 00:02:24.550
The next one is that array and hash are the only two container types in Ruby and in C++.

25
00:02:24.550 --> 00:02:26.800
There are many container types.

26
00:02:28.060 --> 00:02:36.580
The next one is that there is no need of C++ templates, no casting either required in Ruby, whereas

27
00:02:36.580 --> 00:02:43.210
in C++ templates are necessary and casting is also there in C++.

28
00:02:45.270 --> 00:02:53.550
Talking about some of the more comparisons between the two languages in Ruby itself, instead of this

29
00:02:53.550 --> 00:03:01.200
for the current object and in C++, it is this instead of self, it is actually reciprocal.

30
00:03:01.980 --> 00:03:06.120
The next one is that in Ruby iteration is done a bit differently.

31
00:03:06.390 --> 00:03:10.620
In Ruby, you don't use a separate iterator object.

32
00:03:10.620 --> 00:03:17.190
Instead, you use an iterative method of the container object that takes a block of code to which it

33
00:03:17.190 --> 00:03:26.040
passes successive elements, whereas in C++ the vectors are acquired and used, which makes the coding

34
00:03:26.040 --> 00:03:26.980
very easy.

35
00:03:27.810 --> 00:03:37.290
The next comparison is that in Ruby LRIP, a unit testing comes standard with Ruby, which is not available

36
00:03:37.320 --> 00:03:38.430
with C++.

37
00:03:39.300 --> 00:03:46.510
And there are no type convergence in Ruby where as type conversion is necessary in C++.

38
00:03:46.530 --> 00:03:55.050
There are some enforced this convergence in Ruby, whereas no such case conversions are present in C++,

39
00:03:55.320 --> 00:03:57.060
which makes it a bit easy from Ruby.

40
00:03:59.210 --> 00:04:08.420
The next comparison between the two languages is based on the class, so you can reopen a class any

41
00:04:08.420 --> 00:04:16.400
time and also you can add more methods and Ruby, whereas you cannot do this in C++, the next one is

42
00:04:16.400 --> 00:04:24.260
that some methods and and question mark or an exclamation mark in Ruby is basically actually the part

43
00:04:24.260 --> 00:04:25.280
of the method name.

44
00:04:25.470 --> 00:04:29.540
There is no such symbols are required at the end of methods in C++.

45
00:04:30.520 --> 00:04:38.610
Next one is that all methods are always virtual in Ruby, whereas in C++ methods are not virtual, multi

46
00:04:38.710 --> 00:04:43.540
threading is built in Ruby, whereas multi threading is not built in C++.

47
00:04:44.260 --> 00:04:52.960
Parenthesis used for calling of method are usually optional in Ruby, whereas parenthesis are required

48
00:04:52.960 --> 00:04:55.510
in C++ and it is necessary to put them.

49
00:04:55.510 --> 00:04:59.670
Not putting them is going to generate error messages for you.

50
00:05:00.280 --> 00:05:03.850
The next one is that you don't directly access member variables.

51
00:05:03.850 --> 00:05:13.540
All accesses to public members variables is through methods, whereas member variables in C++ can be

52
00:05:13.540 --> 00:05:15.540
accessed directly.

53
00:05:17.030 --> 00:05:25.670
So this was basically a brief comparison between C++ and Ruby, and if you have been to see or you have

54
00:05:25.670 --> 00:05:33.710
been to C++, then I guess you have got a very good idea of how Ruby is going to work on in the future

55
00:05:33.710 --> 00:05:34.420
tutorials.

56
00:05:34.760 --> 00:05:36.380
So I guess that's it with this tutorial.

57
00:05:36.410 --> 00:05:38.330
Thank you so much, guys, for watching.

58
00:05:38.340 --> 00:05:40.940
And I guess I'll see you guys in the next territorial.
