WEBVTT
1
00:00:01.320 --> 00:00:02.340
Hey, guys, what's up?

2
00:00:02.370 --> 00:00:06.360
This is American, and I welcome you to an editorial on this course on Ruby.

3
00:00:06.570 --> 00:00:11.610
And in this tutorial, we will be covering the overview of the number types in Ruby.

4
00:00:11.970 --> 00:00:19.100
So let's start by taking a look at the class hierarchy of all the number of related classes in Ruby.

5
00:00:19.500 --> 00:00:22.780
So the first one we have is the numeric number class.

6
00:00:22.800 --> 00:00:26.580
Then we have the integer, then we have the fixed number.

7
00:00:26.790 --> 00:00:28.760
Then we have the big number.

8
00:00:29.220 --> 00:00:31.070
Then we have the float numbers.

9
00:00:31.290 --> 00:00:37.890
Then we have the complex number that basically deals with the values that are related to iodized in

10
00:00:37.890 --> 00:00:38.690
mathematics.

11
00:00:39.000 --> 00:00:44.340
Then we have the original numbers that basically deals with the fractions.

12
00:00:45.440 --> 00:00:53.660
And finally, we have the big decimal that basically deals with a kind of, let's say, precision type

13
00:00:53.660 --> 00:00:56.930
of element, because float value is actually not accurate.

14
00:00:56.960 --> 00:01:03.020
That's why we come across big decimal in most cases where we need a lot of accuracy.

15
00:01:03.260 --> 00:01:06.670
So these are basically the number of classes we have in Ruby.

16
00:01:06.680 --> 00:01:12.890
And as you can see, that the numeric gloss is at the top, which is also called the parent for for

17
00:01:12.890 --> 00:01:14.230
all the number of classes.

18
00:01:14.690 --> 00:01:20.690
So you can use the ancestor method that is a building method to discover the parent class of any class.

19
00:01:21.750 --> 00:01:26.190
Well, Dad, what do you have to do is, for example, if you want to know the ancestral class of,

20
00:01:26.190 --> 00:01:31.680
let's say, this fixed number, then what you can do is that you can type in fixed number dot ancestors

21
00:01:31.680 --> 00:01:35.940
and that is going to generate the ancestral glassell fixed number for you.

22
00:01:37.550 --> 00:01:38.840
So going ahead.

23
00:01:41.730 --> 00:01:42.300
Now.

24
00:01:45.310 --> 00:01:51.940
Let's get a basic overview of all the no classes, so the first one is in teacher, which is basically

25
00:01:51.940 --> 00:01:55.800
the parent class of fixed number and big number.

26
00:01:56.500 --> 00:02:01.570
Then we have the fixed number, which basically contains the whole numbers that fit into the EU's integer

27
00:02:01.570 --> 00:02:04.480
type, whether it be 32 bits or 62 bits.

28
00:02:04.660 --> 00:02:11.560
Then we have the big number that is used for very big numbers that are integers, of course, because

29
00:02:11.560 --> 00:02:16.020
it is the it is the trial class of the integer class, as I told you.

30
00:02:16.270 --> 00:02:21.070
And as you can see at the top, that integer class is basically the parent class of this fixed number

31
00:02:21.070 --> 00:02:21.860
and big number.

32
00:02:22.150 --> 00:02:26.910
So basically, the big number consists of bigger numbers that are integers.

33
00:02:27.400 --> 00:02:33.760
Then we have the floor that consist of imprecise decimal numbers, as I told you before, then we have

34
00:02:33.760 --> 00:02:39.370
the complex number that are used for matched up with imaginary numbers in mathematics.

35
00:02:39.370 --> 00:02:40.510
We call them the aorta.

36
00:02:41.540 --> 00:02:48.980
Then we have the original, which consist of fractions and it is used to represent the fractions.

37
00:02:49.280 --> 00:02:54.560
Then we have the big decimals that is used to perfect the precision in decimal numbers.

38
00:02:55.860 --> 00:03:02.370
All right, so I guess that was a quick overview of what is going on in number of systems in Ruby,

39
00:03:02.370 --> 00:03:05.880
so let's get on with some examples to show you.

40
00:03:07.200 --> 00:03:14.610
Some of the scenarios that occur in the number of times, so let's first start with the flawed imprecision,

41
00:03:14.610 --> 00:03:19.200
as it told you, that basically flawed has imprecise values.

42
00:03:19.200 --> 00:03:25.210
And if you want values to be very, very, very precise, then you have to use the big decimal.

43
00:03:25.470 --> 00:03:27.280
So why are they imprecise?

44
00:03:27.300 --> 00:03:33.400
Let me give you a quick example for how flawed Nas in Ruby is described as imprecise.

45
00:03:33.930 --> 00:03:37.740
So, for example, you have, let's say, some number.

46
00:03:39.130 --> 00:03:46.660
That is zero point two, and you add it with zero point one, so if you see at this, you know that

47
00:03:46.660 --> 00:03:48.910
this is equal to zero point three.

48
00:03:48.920 --> 00:03:54.640
So if you want to check it, you have to write an equal equal to and you have to write in zero point

49
00:03:54.640 --> 00:03:55.480
three over here.

50
00:03:55.900 --> 00:03:59.000
Now, what you want is that you want to check if this is true or not.

51
00:03:59.010 --> 00:04:01.750
So you are going to just dive and give a space.

52
00:04:02.170 --> 00:04:06.130
But brackets around this are underscored.

53
00:04:09.020 --> 00:04:14.150
And as you can see, that the output generated is false, which means that this statement is false.

54
00:04:14.180 --> 00:04:20.180
Apparently you can see that this statement is perfectly fine, zero point zero point one is completely

55
00:04:20.180 --> 00:04:21.230
equal to zero point three.

56
00:04:21.230 --> 00:04:26.080
But the output, as you can see on the added bonuses, that this result is false.

57
00:04:26.300 --> 00:04:30.890
And as I told you before, flawed has imprecise values.

58
00:04:30.890 --> 00:04:37.190
And that's why flotilla's is described as imprecise in the official ruby documentation as well.

59
00:04:37.550 --> 00:04:44.090
So if you want very, very, very precise reserves, then what you have to do is that you have to use

60
00:04:44.330 --> 00:04:48.140
the concept of the big decimals of a hill.

61
00:04:49.190 --> 00:04:55.360
Know how that concept is going to be applied over here and how these two numbers are going to be converted

62
00:04:55.660 --> 00:05:03.160
into the big decimal, what you have to do is that you have to require the big decimal class was to

63
00:05:03.160 --> 00:05:04.380
have to write and require.

64
00:05:04.690 --> 00:05:08.590
But these single brackets and you have to write in big.

65
00:05:10.550 --> 00:05:11.280
Decimal.

66
00:05:11.660 --> 00:05:16.670
All right, so after you have acquired the glass, now what you can do is that you can simply use it,

67
00:05:16.680 --> 00:05:17.750
so you have to write in.

68
00:05:18.740 --> 00:05:19.310
Big.

69
00:05:20.320 --> 00:05:21.160
Decimal.

70
00:05:22.470 --> 00:05:24.270
Put this in brackets.

71
00:05:27.660 --> 00:05:33.450
Right, big decimal point zero point one in brackets now run this code.

72
00:05:34.760 --> 00:05:38.310
Not working, it says, did you mean by decimal?

73
00:05:38.330 --> 00:05:40.550
Yes, I meant the big decimal.

74
00:05:40.790 --> 00:05:41.300
All right.

75
00:05:41.340 --> 00:05:49.010
Yes, my bet is there has to be in capitals, as you can see or hear, big decimal deals in gaps.

76
00:05:49.520 --> 00:05:51.110
So now let's just run it.

77
00:05:51.260 --> 00:05:58.880
And you can see that it is now true because what big decimal do is that big decimal, since I told you,

78
00:05:58.880 --> 00:06:05.850
contains precise value and it is basically used for the flawed precision to make float values precise.

79
00:06:05.870 --> 00:06:11.570
So that's why, as you can see, that the flows float, values were actually made precise and that's

80
00:06:11.570 --> 00:06:16.500
why the output generated on the atom, rather says it's true.

81
00:06:16.970 --> 00:06:23.540
So that is what is the concept of big decimal and float and that what was the comparison between the

82
00:06:23.540 --> 00:06:23.870
two?

83
00:06:25.970 --> 00:06:32.510
Then we have the concept of fixed numbers and let's just remove this stuff from here first.

84
00:06:33.350 --> 00:06:37.490
All right, so what do we have the fixed number class then?

85
00:06:37.490 --> 00:06:39.740
It has some special attributes.

86
00:06:45.660 --> 00:06:51.840
Now, after that, we have the fixed numbers clause that also has some very special properties, for

87
00:06:51.840 --> 00:06:57.750
example, the object ID for a fixed number is calculated using a very special formula.

88
00:06:58.050 --> 00:06:59.250
Let me just show you that.

89
00:06:59.250 --> 00:07:00.730
So just remove this from here.

90
00:07:00.750 --> 00:07:03.050
For example, I have a fixed number.

91
00:07:03.360 --> 00:07:07.620
Let's say it is one, and I want to know the object ID for that.

92
00:07:07.770 --> 00:07:10.050
So I'm going to write in one object.

93
00:07:10.320 --> 00:07:14.520
Need to add this sports with it, run it.

94
00:07:15.060 --> 00:07:18.840
And as you can see, that three has been generated for me now.

95
00:07:19.770 --> 00:07:25.290
How this tree has been generated for this one now, the formula for that is that whatever number you

96
00:07:25.290 --> 00:07:32.370
enter here, in our case, it is one, that number is going to be multiplied by two and one is going

97
00:07:32.370 --> 00:07:33.380
to be added to it.

98
00:07:33.390 --> 00:07:37.060
And that is what is going to be the object of whatever object you enter.

99
00:07:37.080 --> 00:07:41.820
For example, if I just enter two, then you can guess automatically that this number is going to be

100
00:07:41.820 --> 00:07:42.690
multiplied by two.

101
00:07:42.690 --> 00:07:47.340
So two multiplied by two equal to four and one is going to be added to it, which means that five is

102
00:07:47.340 --> 00:07:49.370
going to be generated on the output screen.

103
00:07:49.710 --> 00:07:53.490
So I read it and as you can see, that five has been generated.

104
00:07:53.500 --> 00:07:58.800
So whatever number you enter right here, for example, the twenty twenty is multiplied by two, which

105
00:07:58.800 --> 00:08:03.620
means forty and one is going to be added to it, which makes it equal do for the one I guess.

106
00:08:03.630 --> 00:08:05.320
And that was the calculation.

107
00:08:05.320 --> 00:08:08.430
Diamond at forty one is generated right here on your screen.

108
00:08:10.340 --> 00:08:16.820
No, but there is more concept artists, this when you use a fixed number, there is no object being

109
00:08:16.820 --> 00:08:17.570
created at all.

110
00:08:17.580 --> 00:08:23.750
There is no one around the store and a fixed number because the value is derived from the object itself.

111
00:08:23.960 --> 00:08:30.050
Now, this is just an implementation detail, but I think it's interesting to want to know that's why

112
00:08:30.050 --> 00:08:34.100
I have covered it in this tutorial as well.

113
00:08:34.610 --> 00:08:38.330
Now, if you want to know the let's say.

114
00:08:39.290 --> 00:08:45.070
Glass of any kind of number, and that, I guess, is the last part of this tutorial, then what you

115
00:08:45.070 --> 00:08:48.560
can do is that you can write in votes, you can write that number.

116
00:08:48.610 --> 00:08:54.550
Let's say I want to know the class of this, so I've got to write in one dot and I'm going to write

117
00:08:54.550 --> 00:08:55.470
in class.

118
00:08:55.490 --> 00:09:00.820
Now, if I run this code, you can see that it has generated integer for me, which means that one is

119
00:09:00.820 --> 00:09:03.280
an integer, one is also a fixed number.

120
00:09:03.490 --> 00:09:10.480
But since integer is the parent class of the fixed number and big number, that's why we have this integer

121
00:09:10.480 --> 00:09:12.040
here on our output screen.

122
00:09:12.460 --> 00:09:19.150
Now, if I type in one point zero, let's say breasts or are you can see that on my Adam runner, I

123
00:09:19.150 --> 00:09:26.560
have this flaw generated right over here, which means that one point zero is a flawed number, that

124
00:09:26.560 --> 00:09:32.270
if you are a student of mathematics, then you are well aware of complex number and you know that it's

125
00:09:32.290 --> 00:09:36.670
Ayata and you know that Yoda is represented by the character.

126
00:09:36.670 --> 00:09:37.120
I see.

127
00:09:37.120 --> 00:09:42.700
If I type in one idot class over here, run the score then on the ademir and there you can see that

128
00:09:42.700 --> 00:09:48.070
it says that this is a complex number, which means that one eye is basically from the class of complex

129
00:09:48.070 --> 00:09:48.400
number.

130
00:09:48.670 --> 00:09:55.480
Now if I let's say, write in something like a fraction one divided by two or underscored, then as

131
00:09:55.480 --> 00:10:00.940
you can see that it has generated an error because it do not recognize this value over here.

132
00:10:01.270 --> 00:10:05.590
Even if I put it in the brackets, he'll now run this code.

133
00:10:05.770 --> 00:10:12.130
Then you can see that it is giving me that it is an integer, but not original.

134
00:10:12.130 --> 00:10:17.230
No original number is going to be something different, which would be covered in the future tutorials.

135
00:10:17.650 --> 00:10:24.430
Then finally, I told you about the incestuous function, how you can do it, just remove it.

136
00:10:24.670 --> 00:10:29.890
And for example, you want to know that what is the ancestral class of this big number?

137
00:10:29.890 --> 00:10:34.930
So you are going to just write ancestors, big numbers on ancestors run this code.

138
00:10:34.930 --> 00:10:40.300
And as you can see that it says integer and American variable object kernel of the basic object.

139
00:10:40.330 --> 00:10:44.320
These are all basically the ancestors of this big number class.

140
00:10:44.320 --> 00:10:50.470
And to be in general, integer is basically the ancestral class of this big number.

141
00:10:50.470 --> 00:10:56.380
And for example, if you just write in fixed number or a hill and run this code, you can again see

142
00:10:56.380 --> 00:11:00.340
that integer class is basically the parenting class of this fixed number.

143
00:11:00.340 --> 00:11:03.100
And this fixed number is basically the ancestor of this.

144
00:11:03.610 --> 00:11:10.750
For example, you dive in something like complex or undiscovered, then you can see that basically complex

145
00:11:10.750 --> 00:11:13.920
class is the ancestral class of this complex class itself.

146
00:11:13.930 --> 00:11:22.090
And in the slides, I assure you that numeric was at the top, which means that numeric gloss is basically

147
00:11:22.090 --> 00:11:28.510
what is going to be the parent class for almost all since it was at the top of the hierarchy.

148
00:11:29.920 --> 00:11:35.440
That's when American forces is basically considered as the parent for all the no classes, so whatever

149
00:11:35.440 --> 00:11:36.940
class you enter here.

150
00:11:37.810 --> 00:11:43.300
In the output, always you're going to see in America where here, since it is the complex.

151
00:11:44.400 --> 00:11:52.230
Glass Ohare We are using and do not have a specific ancestral class, as in case of integer and as in

152
00:11:52.230 --> 00:11:56.780
case of sorry big numbers and fixed number which has the parent class that is known as integer.

153
00:11:56.940 --> 00:12:01.440
So that's why I for complex you are going to see complex at the top and after that you are always going

154
00:12:01.440 --> 00:12:02.960
to see numeric.

155
00:12:03.690 --> 00:12:05.850
So I guess that's it.

156
00:12:05.880 --> 00:12:08.970
You now know about I guess number types a lot.

157
00:12:09.300 --> 00:12:16.250
So that was just a basic introduction to no system in Ruby.

158
00:12:16.560 --> 00:12:17.410
So I guess that's it.

159
00:12:17.440 --> 00:12:23.940
With this tutorial, whatever was covered in this tutorial is going to be used a lot in the future tutorial.

160
00:12:23.940 --> 00:12:25.770
So I guess you haven't tested it well.

161
00:12:26.220 --> 00:12:27.900
So thank you so much, guys, for watching.

162
00:12:27.900 --> 00:12:30.330
And I'll see you guys in the next Dorio.
