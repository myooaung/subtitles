WEBVTT
1
00:00:00.590 --> 00:00:01.590
Hey, guys, what's up?

2
00:00:01.610 --> 00:00:07.300
This is a marathon, and I welcome you to another tutorial on this course on early on in this DORELLE,

3
00:00:07.310 --> 00:00:13.220
we are going to continue on with regular expressions and move towards a bit advanced topics that are

4
00:00:13.220 --> 00:00:15.370
related to regular expressions and ruby.

5
00:00:15.920 --> 00:00:21.800
So the first thing we are going to cover is basically the expressions are you can see the different

6
00:00:21.800 --> 00:00:24.560
regular expressions you can use on with arranges.

7
00:00:24.560 --> 00:00:29.930
Now Ranges is a topic that you have covered in the previous tutorials if you haven't got a good hold

8
00:00:29.930 --> 00:00:30.380
of that.

9
00:00:30.590 --> 00:00:36.020
So I suggest you just go back and get a good hold of the Rangers topic first and then come back with

10
00:00:36.020 --> 00:00:36.550
the story.

11
00:00:36.890 --> 00:00:39.680
So if you have done good enough, you can continue on.

12
00:00:39.950 --> 00:00:46.430
So basically there are certain expressions which stands for the short form of certain ranges.

13
00:00:46.850 --> 00:00:55.550
For example, if you have a range that is 029 A to Z and capital to Capital Z, and also it includes

14
00:00:55.550 --> 00:00:57.020
this underscore of a hill.

15
00:00:57.230 --> 00:01:02.890
Then instead of writing this whole stuff over here, what you can do is that you can just write in backslash

16
00:01:02.910 --> 00:01:06.800
W and that is going to do your job for the regular expression.

17
00:01:07.080 --> 00:01:09.290
Then we have this backslash deep.

18
00:01:09.650 --> 00:01:11.000
I guess it is a backslash.

19
00:01:11.000 --> 00:01:12.330
If it is not, then it is a front line.

20
00:01:12.390 --> 00:01:14.130
So I would just call it a slash.

21
00:01:14.360 --> 00:01:17.960
So you've got this and that is the same as 029.

22
00:01:18.180 --> 00:01:23.570
Then you've got the slash as that matches the white spaces, then you have the slash capital w that

23
00:01:23.570 --> 00:01:29.600
is anything that's not in 029 A2 that that underscore that I guess includes the special characters.

24
00:01:30.080 --> 00:01:31.820
Then you have got this back Shasti.

25
00:01:31.850 --> 00:01:38.600
That is anything that's not a number, which means that it includes the uppercase lowercase and the.

26
00:01:40.030 --> 00:01:45.220
Sequences of letters that are basically the special characters, then you have got this one that is

27
00:01:45.400 --> 00:01:50.460
to s that is anything that is not a space.

28
00:01:50.620 --> 00:01:56.080
So it is going to include all the things except this wall here that matches a white space.

29
00:01:57.550 --> 00:02:05.290
So let's see some examples for how these regular expressions with ranges are going to get implemented

30
00:02:05.290 --> 00:02:06.490
in Ruby.

31
00:02:06.670 --> 00:02:09.520
So for that, we will just move on to item.

32
00:02:11.050 --> 00:02:16.060
So we are going to define to Letrozole here, the first one is going to be, let's say one kuduro oakhill

33
00:02:16.450 --> 00:02:22.160
and let's say we define the O'Haire, that is totally some kind of, let's say lateral.

34
00:02:22.360 --> 00:02:25.800
So we are going to write and let's say three point one.

35
00:02:27.250 --> 00:02:32.140
And now what we are going to do is that we are going to use the dart and the daughterly domestically

36
00:02:32.140 --> 00:02:33.820
matches for all characters.

37
00:02:33.840 --> 00:02:35.440
So if you just write in, if.

38
00:02:37.170 --> 00:02:37.890
IDOT.

39
00:02:39.470 --> 00:02:45.230
Match and in the parameters for this match where you're going to ride and you're going to ride and this,

40
00:02:45.470 --> 00:02:50.510
then you have to ride in Backslash D and you have to ride in the dot operator, then you have to ride

41
00:02:50.510 --> 00:02:51.860
in Backslash D.

42
00:02:55.210 --> 00:02:59.530
And then this, so if you just try it in a Hilbert's.

43
00:03:02.710 --> 00:03:07.330
Match found and in the EL statement, you are going to ride in boats.

44
00:03:10.390 --> 00:03:15.280
Match not found just and this.

45
00:03:16.250 --> 00:03:21.650
And I guess we have spelled this correctly, right, and this deed, then you have to write note and

46
00:03:21.810 --> 00:03:29.980
then there's the finality of in this bracket close to good enough on this and it is going to say matchpoint.

47
00:03:29.990 --> 00:03:35.330
Now, the reason behind this is since, you know, that backslash basically stands for letters from

48
00:03:35.330 --> 00:03:35.990
zero to nine.

49
00:03:36.000 --> 00:03:37.970
But here we have also got this dual here.

50
00:03:37.970 --> 00:03:40.040
So you might be thinking that why it had generated.

51
00:03:40.760 --> 00:03:43.410
Which means that it has generated match found help.

52
00:03:43.490 --> 00:03:45.440
The reason behind this is this dot.

53
00:03:45.440 --> 00:03:45.680
Right.

54
00:03:45.830 --> 00:03:51.150
Here because we are using this dot and the dot literally basically matches for all kind of characters.

55
00:03:51.170 --> 00:03:54.260
So that's why we have generated Drew for this condition.

56
00:03:54.260 --> 00:03:57.980
And we have got this match found right here on your adumbration right now.

57
00:03:57.980 --> 00:04:05.240
If you want to just skip this dot from here, then you can just specify this, a single backslash over

58
00:04:05.240 --> 00:04:06.380
here again.

59
00:04:06.380 --> 00:04:09.180
And that is basically going to escape this sequence.

60
00:04:09.200 --> 00:04:14.060
Now, you have already covered a skipping sequences and you know how to escape sequences in Ruby.

61
00:04:14.070 --> 00:04:18.650
So if you just specify a backslash over here, backslash over here and this dot in between, then that

62
00:04:18.650 --> 00:04:21.600
is going to basically escape this as a sequence.

63
00:04:21.620 --> 00:04:27.080
So now if you just run this code now, it is going to generate not found, because since it is now not

64
00:04:27.080 --> 00:04:29.990
doing it for this, it is only doing it for backslash deal here.

65
00:04:29.990 --> 00:04:33.320
And you know that backslash D if you just go back and see Cohill.

66
00:04:35.080 --> 00:04:43.050
You can see that backstage is the same as zero to nine, so in here, since we also have a camera here,

67
00:04:43.060 --> 00:04:46.510
so if you just skip this door from here, it is going to generate false.

68
00:04:46.510 --> 00:04:51.090
And that's what Majnun form is going to get printed on your screen.

69
00:04:51.460 --> 00:04:54.820
Now, if you do this very same for the B object.

70
00:04:54.830 --> 00:04:59.290
Let's say you were here just right in this or on this code.

71
00:04:59.290 --> 00:05:03.160
It is going to clearly say matchpoint because we have got this dot over here.

72
00:05:03.170 --> 00:05:08.260
But in this case, if you just escape this dot from here, run this code, it is again going to say

73
00:05:08.260 --> 00:05:11.320
matchpoint because it has escaped this sequence, no doubt.

74
00:05:11.560 --> 00:05:18.670
But since Backslash D is present over here and it only contained numbers since the backslash is for

75
00:05:18.670 --> 00:05:25.180
029 So in this case, we don't have any kind of alphabetical characters or any kind of special characters

76
00:05:25.180 --> 00:05:25.530
over here.

77
00:05:25.540 --> 00:05:31.000
So that's why a match is going to get generated just because of this backslash and it is going to generate

78
00:05:31.000 --> 00:05:33.420
match found in both the cases.

79
00:05:33.760 --> 00:05:40.240
So that's how basically you can have arranges use and you can use any of these, which we have listed

80
00:05:40.480 --> 00:05:41.770
right in our slide.

81
00:05:41.770 --> 00:05:45.670
You can use any of these in place of the range you want to use.

82
00:05:46.390 --> 00:05:53.680
So the next topic we are going to cover in this tutorial basically deals with modifiers and their purposes.

83
00:05:54.550 --> 00:06:00.070
So there are multiple modifiers you can use and be the first one is the plus operator, that is for

84
00:06:00.370 --> 00:06:05.770
one or more characters, then we have the Starick that is for a zero or more characters.

85
00:06:06.010 --> 00:06:09.460
Then we have the question mark that is for zero or one character.

86
00:06:09.640 --> 00:06:11.740
Then we have the X and Y.

87
00:06:11.770 --> 00:06:16.450
That is a number of correct if a number is between X and Y.

88
00:06:16.460 --> 00:06:22.090
So it is if for numbers of character between X and Y is true, it is going to generate results, it

89
00:06:22.090 --> 00:06:23.160
is going to generate false.

90
00:06:23.650 --> 00:06:29.290
Then we have the x m where I is for ignoring the case when matching text.

91
00:06:29.290 --> 00:06:36.250
So it is going to just ignore if a letter is in higher case or lower case, it is going to simply ignore

92
00:06:36.250 --> 00:06:43.300
all that stuff and it is going to just match text without taking into account any kind of capitaland

93
00:06:43.300 --> 00:06:43.850
small.

94
00:06:44.050 --> 00:06:50.470
Then we have got this x y head that is for ignoring wide spaces and it is going to allow comments in

95
00:06:50.470 --> 00:06:51.870
regular expressions as well.

96
00:06:52.150 --> 00:06:58.840
Then you have got this and that is for matching multiple lines, recognizing new lines as normal characters.

97
00:07:00.100 --> 00:07:07.510
And finally, we have got this USNA that our four interprets the regular expression as Unicode UTF eight,

98
00:07:07.810 --> 00:07:10.680
you see SJS are USQUE.

99
00:07:11.410 --> 00:07:12.820
Now here you need to know.

100
00:07:12.910 --> 00:07:16.930
One thing is that regular expression is assumed to use the source.

101
00:07:16.930 --> 00:07:23.110
Encoding of none of these modifiers is specified and it is going to use the source encoding.

102
00:07:23.560 --> 00:07:29.650
So I guess it's time to go back to our editor to see some of the examples that are going to be related

103
00:07:29.650 --> 00:07:30.830
to modifiers.

104
00:07:31.420 --> 00:07:33.130
So just move on to Adam Brunner.

105
00:07:33.130 --> 00:07:35.890
We will just remove the stuff from here, refresh this.

106
00:07:36.460 --> 00:07:40.870
So to give you the simplest example of all, we are going to use the AI modifier.

107
00:07:40.870 --> 00:07:45.010
And you know, that I modifier is used to ignore the case sensitivity.

108
00:07:45.970 --> 00:07:48.490
So let's say you have a text that is A, B, C.

109
00:07:50.400 --> 00:07:57.300
And you want to match, not to a check, it has a match found with a sequence.

110
00:07:58.450 --> 00:07:59.230
That is.

111
00:08:00.870 --> 00:08:07.410
From A to Z, but as you can see that I have ridden capital to Capital Z over here and in here, I have

112
00:08:07.410 --> 00:08:09.560
just written small ABCL here.

113
00:08:09.570 --> 00:08:16.500
So if I just store it in a variable X and just write and put Zuheir on this code, you can see that

114
00:08:16.500 --> 00:08:22.600
it has simply generated Faulds because now it is considering into account capital gains and lowercase.

115
00:08:22.950 --> 00:08:29.280
So in this case, since a C is in smoggiest and we are checking it with a range that is from capital

116
00:08:29.280 --> 00:08:29.950
to capital Z.

117
00:08:29.970 --> 00:08:31.610
So that's why it has generated false.

118
00:08:31.920 --> 00:08:33.890
And you can see it right on your ATM, brother.

119
00:08:33.900 --> 00:08:40.710
But if you use the I modifier or here, it is going to simply ignore the Gissing and it is going to

120
00:08:40.950 --> 00:08:44.730
perform the matching and run it and it is going to return.

121
00:08:44.730 --> 00:08:44.970
True.

122
00:08:44.970 --> 00:08:49.710
As you can see, that just by specifying this area here that this sensitivity is gone.

123
00:08:49.860 --> 00:08:51.150
It is no more a part of it.

124
00:08:51.300 --> 00:08:55.890
And you can see that Drew has been generated, which means that ABC now is a part of this strange.

125
00:08:57.400 --> 00:09:04.000
Now, we can also combine everything we have learned so far to create more complex, regular expressions.

126
00:09:04.990 --> 00:09:10.900
For example, if you want to, let's check the validity of an IP address, then what you are going to

127
00:09:10.900 --> 00:09:17.710
do is, for example, you have let's just remove this from here us and we will have a function that

128
00:09:17.710 --> 00:09:19.930
is, let's say, IP address.

129
00:09:20.900 --> 00:09:26.630
And in this IP address, what we're going to do is that we are going to receive the IP address that

130
00:09:26.630 --> 00:09:28.100
is going to be stored in a.

131
00:09:28.760 --> 00:09:32.080
So whatever is going to be done in this, that is going to be a part of later.

132
00:09:32.390 --> 00:09:35.980
For now, let's go on and let's see what is an IP address.

133
00:09:36.260 --> 00:09:39.710
So we are going to call in the function IP address.

134
00:09:42.230 --> 00:09:46.940
And inhale, what we are going to do is that we are going to call this function twice first we are going

135
00:09:46.940 --> 00:09:51.380
to call it with a valid IP address, and secondly, we are going to call it with an invalid IP address.

136
00:09:51.380 --> 00:09:58.370
You know that a valid IP address looks something like one nine two dot one six eight Dodman dot one

137
00:09:58.400 --> 00:10:01.430
are you can specify any kind of valid IP address.

138
00:10:01.700 --> 00:10:08.570
Now, this o'haire is to return to whatever we are going to do is then this O'Haire, this calling over

139
00:10:08.810 --> 00:10:09.560
is going to return.

140
00:10:09.560 --> 00:10:11.180
True, because this is a valid IP address.

141
00:10:11.510 --> 00:10:13.580
Now if we call this function.

142
00:10:15.920 --> 00:10:18.840
I guess I have spelled it very right.

143
00:10:18.860 --> 00:10:19.470
I have.

144
00:10:19.760 --> 00:10:26.180
So now if I just specify, let's say zero zero zero zero zero zero zero zero, you know, that this

145
00:10:26.180 --> 00:10:32.330
is an invalid IP address and this function is supposed to return false for this calling card.

146
00:10:32.900 --> 00:10:35.870
So now let's go on and call dysfunctional health.

147
00:10:37.290 --> 00:10:42.270
So in this one, we are going to use this, that we are going to use the exclamation mark, exclamation

148
00:10:42.270 --> 00:10:45.780
mark on set to convert the return value to a boolean fust.

149
00:10:46.200 --> 00:10:51.260
So we are going to add an exclamation exclamation and what is the purpose of exclamation exclamation?

150
00:10:51.270 --> 00:10:54.690
It is going to convert a string to a boolean value.

151
00:10:54.990 --> 00:11:02.430
So we are going to write and string and we are going to initialize a string with which this is going

152
00:11:02.430 --> 00:11:07.710
to get matched because we are going to initialize our regular expression now with which this string

153
00:11:07.710 --> 00:11:12.300
is going to get matched, because whatever is a part of this section or this tutorial in the previous

154
00:11:12.300 --> 00:11:17.610
story, we have also got word that that we are going to match a string with a regular expression.

155
00:11:17.620 --> 00:11:19.380
We have to initialize the regular expression.

156
00:11:19.380 --> 00:11:21.750
We have to pass in a string to a function.

157
00:11:21.750 --> 00:11:27.720
And that string is going to get matched with that regular expression we have initialize it and it has

158
00:11:27.720 --> 00:11:28.050
a match.

159
00:11:28.050 --> 00:11:30.360
It is going to return true as it is going to return false.

160
00:11:30.390 --> 00:11:35.520
So in this I.P. address function, what we are going to do is that we are going to initialize a string

161
00:11:35.790 --> 00:11:38.990
not sorry, not a string of regular expression.

162
00:11:39.000 --> 00:11:42.840
And if this string Ohare we are passing into this function IP address.

163
00:11:43.080 --> 00:11:47.220
If this matches the regular expression we are about to initialize, then it is going to return.

164
00:11:47.220 --> 00:11:48.800
True as it is going to return false.

165
00:11:48.810 --> 00:11:52.380
And as I said before that for this it is expected to return.

166
00:11:52.380 --> 00:11:52.680
True.

167
00:11:52.680 --> 00:11:55.560
And for this it is expected to return false.

168
00:11:56.820 --> 00:12:04.380
So we are going to just get in right in equal to negation sign, this is how you initialize things and

169
00:12:04.380 --> 00:12:06.150
just write in these two records.

170
00:12:06.150 --> 00:12:10.330
SAWHILL And now we are going to use the previous concepts as well.

171
00:12:10.350 --> 00:12:12.490
We are going to use had concepts as well.

172
00:12:12.810 --> 00:12:14.730
So just try and this will help.

173
00:12:16.760 --> 00:12:22.940
Just try and backslash D that stands for a number from zero to nine, and what we are going to do over

174
00:12:22.940 --> 00:12:27.750
here is that we are going to also specify numbers from the X Y range over here as well.

175
00:12:27.800 --> 00:12:29.420
So we are going to write in one three.

176
00:12:35.270 --> 00:12:37.790
You are going to write in DOT, that is for.

177
00:12:38.970 --> 00:12:44.250
And we are going to use it as a skipping sequence not, but we are going to use it normally, so that's

178
00:12:44.250 --> 00:12:49.470
why we are going to just write in, backslash here, backslash here, so that this door to is escape.

179
00:12:50.070 --> 00:12:53.910
And now you must be thinking that why you have to specify this door if you are to escape it.

180
00:12:53.910 --> 00:12:57.560
That is because we want to have multiple regular expressions over here.

181
00:12:57.570 --> 00:12:59.410
So that's why you have to use this door to help.

182
00:13:00.090 --> 00:13:01.230
So that's alleged.

183
00:13:01.830 --> 00:13:04.290
Again, you have to specify one commentary of a hill.

184
00:13:06.370 --> 00:13:09.190
Then you have to again drive died because you want to use one more.

185
00:13:10.760 --> 00:13:12.520
Just in one single hill.

186
00:13:15.150 --> 00:13:16.170
Again, a dot.

187
00:13:17.300 --> 00:13:18.350
Backslash de.

188
00:13:21.120 --> 00:13:22.470
One Tree Hill.

189
00:13:27.120 --> 00:13:29.160
And finally, a dollar sign.

190
00:13:31.920 --> 00:13:35.760
And now what you have to do is that you have to simply end this function.

191
00:13:37.720 --> 00:13:39.960
So I hope it works now.

192
00:13:40.030 --> 00:13:44.890
So let's just run it and then I'll explain this regular expression one more time before we quit on,

193
00:13:45.400 --> 00:13:46.210
so runit.

194
00:13:47.390 --> 00:13:51.290
All right, we have to, I guess, right in Guzzo here as well, so just try and puts.

195
00:13:54.930 --> 00:13:56.600
And also here as well.

196
00:14:00.510 --> 00:14:07.860
Run this now and you can see that the first one has generated Drew and the second function calling has

197
00:14:07.860 --> 00:14:10.620
basically generated false for us.

198
00:14:11.010 --> 00:14:18.480
Now, what is going on over here actually, is that when this IP address is forced into this function,

199
00:14:18.480 --> 00:14:23.190
it is going to get copied into the string and then the string is going to get matched with this.

200
00:14:23.200 --> 00:14:27.260
But before that, we have to convert this into a boolean value.

201
00:14:27.720 --> 00:14:30.630
So this is going to can get converted into a boolean value.

202
00:14:30.640 --> 00:14:34.260
So that's why we have got this true or false over here and in here.

203
00:14:34.260 --> 00:14:36.880
What we are going to do is that we are going to specify backslash.

204
00:14:37.320 --> 00:14:39.050
Now, this is for the first matching.

205
00:14:39.060 --> 00:14:41.280
That is one ninety-two that is postin.

206
00:14:41.280 --> 00:14:43.170
Then this is called the second matching.

207
00:14:43.170 --> 00:14:44.220
That is one sixty.

208
00:14:44.220 --> 00:14:45.390
And this is for the third match.

209
00:14:45.390 --> 00:14:46.410
Is that is one then.

210
00:14:46.410 --> 00:14:47.670
This is for the fourth matching.

211
00:14:48.000 --> 00:14:49.920
That is again one.

212
00:14:51.670 --> 00:15:00.070
So you know that an IP address is, I guess, something like as a subnet mask of two five five two five

213
00:15:00.070 --> 00:15:03.440
five five five to five, it cannot be greater than this.

214
00:15:03.670 --> 00:15:06.440
So that's why we have written one, two, three.

215
00:15:06.700 --> 00:15:13.930
So if the first letter of this starts from something else, from one to three, if it starts from zero,

216
00:15:13.930 --> 00:15:16.060
then it is going to simply generate a false.

217
00:15:16.270 --> 00:15:23.410
But if it is between one, two, three, that is in this case because the other two letters can be anything

218
00:15:23.410 --> 00:15:25.050
you can just write in, anything will help.

219
00:15:25.330 --> 00:15:27.270
But for this letter, you have to perform checks.

220
00:15:27.310 --> 00:15:31.810
Now, you must be thinking, if this is true, then this this is doable here, then this has to be five

221
00:15:31.810 --> 00:15:33.750
five over here how you can do that.

222
00:15:33.760 --> 00:15:36.100
And that is a possibility over here as well.

223
00:15:36.100 --> 00:15:42.010
And not just denying that possibility, but I guess that should be an assignment for you to do the checks

224
00:15:42.010 --> 00:15:45.070
for these two numbers as well in case this is true.

225
00:15:45.490 --> 00:15:49.510
So if this is not, you want to check if this is a number from one to three.

226
00:15:49.510 --> 00:15:52.780
So if it is, then it is going to just return.

227
00:15:52.780 --> 00:15:53.020
True.

228
00:15:53.020 --> 00:15:57.820
And it is going to just go on to the next sequence matching, then it is going to search for the first

229
00:15:57.820 --> 00:16:01.960
letter and it is going to just match it with this one over here.

230
00:16:01.960 --> 00:16:04.300
Then third and fourth, finally.

231
00:16:04.750 --> 00:16:10.060
And if everything is perfectly fine, it is going to generate a valid IP address and that's why it is

232
00:16:10.060 --> 00:16:15.310
going to generate through because we have already converted it into a billion and a here for the first

233
00:16:15.310 --> 00:16:18.100
MAGIN zero is going to get matched with this to console here.

234
00:16:18.160 --> 00:16:23.860
It is going to simply generate files for the very first match and it is going to perform and it is simply

235
00:16:23.860 --> 00:16:25.250
going to generate false over here.

236
00:16:25.270 --> 00:16:29.860
So that's why you have got to for a valid IP address and false for an invalid IP address.

237
00:16:30.910 --> 00:16:32.070
So I hope it is clear.

238
00:16:32.170 --> 00:16:35.790
The next thing we are going to cover is about the exact string matching.

239
00:16:35.800 --> 00:16:39.840
Now, if you need exact matches, you will need another type of modifier.

240
00:16:40.060 --> 00:16:44.340
So let's see an example for how you can see what I'm talking about.

241
00:16:44.350 --> 00:16:46.380
So let's just remove this stuff from here.

242
00:16:47.050 --> 00:16:53.800
And what we are going to do is that, for example, we want to find if string is exactly, let's say,

243
00:16:53.800 --> 00:16:59.220
four letters, long or not, then we are going to still match because it has more than four.

244
00:16:59.230 --> 00:17:01.490
But if it is not what we want.

245
00:17:01.510 --> 00:17:04.510
So let's just type in some.

246
00:17:05.800 --> 00:17:08.140
Thing like regs are.

247
00:17:09.330 --> 00:17:14.100
Who I know they are, so you are going to ride in the match function with this.

248
00:17:16.170 --> 00:17:16.980
And in the bedroom.

249
00:17:17.240 --> 00:17:22.050
What are you going to do over here is that you are going to specify backslash, backslash, that is

250
00:17:22.050 --> 00:17:28.230
basically the syntax and well, here you are going to specify a backslash W and with a backslash W where

251
00:17:28.230 --> 00:17:31.740
you're going to perform, you are going to write in four as a parameter.

252
00:17:31.740 --> 00:17:37.410
So you in this what we are doing, we want to find if this string along here, we have specified that

253
00:17:37.410 --> 00:17:40.200
is to school is exactly four letters long.

254
00:17:40.860 --> 00:17:45.870
This will still match because it has more than four, but it's not what we want.

255
00:17:46.380 --> 00:17:52.060
So if you just run this code, but before that we have to just store it in a variable.

256
00:17:52.200 --> 00:17:55.170
We have to write and put X on it.

257
00:17:55.680 --> 00:17:59.780
And you can see that it says RTG, which matches the four characters now.

258
00:17:59.820 --> 00:18:01.950
But this is actually not what we want.

259
00:18:02.130 --> 00:18:06.630
Instead, what we will do is that we will use the beginning of the line and end of the line.

260
00:18:06.630 --> 00:18:07.980
Modifier is Abargil.

261
00:18:08.850 --> 00:18:13.820
And what they are going to do is that they are going to tell us that the match has not been found.

262
00:18:14.070 --> 00:18:16.920
So nearly nil is going to get printed.

263
00:18:16.920 --> 00:18:17.130
Right.

264
00:18:17.130 --> 00:18:17.550
It will help.

265
00:18:17.850 --> 00:18:24.420
So to use them, what you have to do is to just write in the beginning on the line parameter over here

266
00:18:24.900 --> 00:18:28.350
and you have to write in backslash over here, then this formula here.

267
00:18:29.800 --> 00:18:34.840
And to this for what you have to write and you have to read in the dollar sign that stands for end of

268
00:18:34.840 --> 00:18:35.320
the line.

269
00:18:35.740 --> 00:18:39.610
So now if you just run this code, you can see that little has been done right now.

270
00:18:39.610 --> 00:18:40.940
This time it won't match.

271
00:18:40.960 --> 00:18:47.680
This is a rather contrived example, since we could just have used the DOT site to find the land, but

272
00:18:47.680 --> 00:18:51.580
I think it would have gone away across.

273
00:18:52.540 --> 00:18:57.670
The main idea here was that if you use it without these Abargil.

274
00:18:59.580 --> 00:19:04.680
That are the beginning of the the end of the line modifiers, respectively, and you use the W4 over

275
00:19:04.680 --> 00:19:04.970
here.

276
00:19:05.100 --> 00:19:11.100
It is going to just match the first four letters and it is going to just print those letters out for

277
00:19:11.100 --> 00:19:13.170
you by storing it in X.

278
00:19:13.170 --> 00:19:16.750
And X is going to just print those letters right on the item around there.

279
00:19:16.770 --> 00:19:18.480
But this is not what you want.

280
00:19:18.510 --> 00:19:25.920
You want that if a letter is exactly four words long, then it is going to generate true as it is going

281
00:19:25.920 --> 00:19:27.190
to simply generate false.

282
00:19:27.780 --> 00:19:35.490
So here, let's say if you have four letters over here now, we use the beginning of the line and we

283
00:19:35.490 --> 00:19:36.930
use the end of the line.

284
00:19:36.930 --> 00:19:38.830
Modifier will help run this code.

285
00:19:39.060 --> 00:19:45.300
Now it is going to generate RSG because our string here is exactly four letters long.

286
00:19:45.480 --> 00:19:47.460
You just specify one more letter.

287
00:19:47.460 --> 00:19:50.640
That is fifth letter verandahs it is going to generate.

288
00:19:51.200 --> 00:19:53.340
That is exactly what what we want.

289
00:19:53.370 --> 00:19:59.490
So if you want to match the string at the start of the string and not just on every line after a backslash,

290
00:19:59.490 --> 00:20:04.610
and you need to use the backslash and backslides that instead, instead of the beginning of the line

291
00:20:04.650 --> 00:20:10.350
and end of the line multiplier that are the this power and this a sign here.

292
00:20:11.810 --> 00:20:16.880
Then we have the concept of capture groups in regular expression as well, with capture groups, we

293
00:20:16.880 --> 00:20:20.840
can capture part of a match and reuse it later to capture a match.

294
00:20:20.840 --> 00:20:27.480
We enclose the part we want to capture in parenthesis, so we will just remove it from help.

295
00:20:27.950 --> 00:20:33.980
Now, whatever we have been covering so far, we have used this syntax for how to just initialize the

296
00:20:33.980 --> 00:20:34.570
string.

297
00:20:34.580 --> 00:20:38.830
So to initialize the regular expression with which you want to perform the match of a string.

298
00:20:39.260 --> 00:20:45.530
But in this case it is very, very positive because with the compiler is doing over here is that the

299
00:20:45.530 --> 00:20:51.470
method is going to create an object and then after that it is going to just perform the match.

300
00:20:51.980 --> 00:20:53.480
Now, what if the.

301
00:20:54.740 --> 00:21:00.740
Ruby compiler, or you can say the Ed in this case already has something that is the Maggette object

302
00:21:00.740 --> 00:21:04.520
and you don't have to create it so that the editor work is just reduced.

303
00:21:05.000 --> 00:21:09.440
So for that, what are you going to you do is that you're going to use the parsing concept now in the

304
00:21:09.440 --> 00:21:14.480
introduction of regular expressions, I told you before that regular expressions are basically used

305
00:21:14.480 --> 00:21:17.030
for two purposes that is validating and parsing.

306
00:21:17.030 --> 00:21:21.000
Now, whatever we have covered so far was basically related to validating.

307
00:21:21.020 --> 00:21:25.820
Now, in this example, what we are going to do is that we are going to use a body concept that is validating

308
00:21:25.820 --> 00:21:26.480
and parsing.

309
00:21:26.480 --> 00:21:32.240
So what we are going to do is that we are going to pass a log file that contains three things.

310
00:21:32.240 --> 00:21:36.470
Let's say that is the time for which the file was created, then contains the type of the file and then

311
00:21:36.470 --> 00:21:38.130
the message that is going to get stored.

312
00:21:38.930 --> 00:21:42.320
So what we are going to do is that we are going to create.

313
00:21:43.810 --> 00:21:51.910
A variable X that is going to create the line line for us is vital for us, that is going to be Strugnell

314
00:21:52.360 --> 00:21:59.050
and in here we are going to specify the logs for the file that has three that it's time.

315
00:22:00.840 --> 00:22:09.540
Then we have the type and then the third one is the message.

316
00:22:11.470 --> 00:22:17.410
So now what we are going to do over here is that we are going to specify the lock format with which

317
00:22:17.410 --> 00:22:19.960
it is going to distinguish here is going to get match.

318
00:22:19.970 --> 00:22:22.730
And this is basically what we are going to pass into a function.

319
00:22:23.110 --> 00:22:26.440
So we are going to specify lock format.

320
00:22:28.090 --> 00:22:36.250
That is going to equal to backslash backslash, that is the syntax for regular expression, and in this

321
00:22:36.250 --> 00:22:40.470
we are going to specify the expression we are going to use.

322
00:22:40.480 --> 00:22:42.640
And so we are going to specify.

323
00:22:44.260 --> 00:22:50.350
Multiple things that were here, the first one is, let's say Backslash D and we want to use this backslash

324
00:22:50.350 --> 00:22:51.760
the web.

325
00:22:53.210 --> 00:23:01.250
This perimetral here and we have specified do right over here and have to specify Callon, then that's

326
00:23:01.250 --> 00:23:03.290
Nesh D.

327
00:23:04.610 --> 00:23:06.680
Then do with it again.

328
00:23:08.710 --> 00:23:15.450
And after that just exploded, move out and you can use the backslash over here as well.

329
00:23:17.110 --> 00:23:22.870
Now, that is going to get used with a plus operator and then finally you are going to use it for the

330
00:23:22.870 --> 00:23:25.470
directory option, you are going to write in Dot Starick.

331
00:23:25.870 --> 00:23:29.120
So that is going to do the job for the directory.

332
00:23:29.380 --> 00:23:35.110
So what is going on over here is that you have to specify it for three things.

333
00:23:35.110 --> 00:23:41.740
The first one, that is the time, then the second one that is the type and the third one that is this

334
00:23:41.740 --> 00:23:42.780
message right here.

335
00:23:43.150 --> 00:23:47.740
So for this, it is going to perform almost everything for this.

336
00:23:47.740 --> 00:23:49.390
It is going to just match the time.

337
00:23:49.390 --> 00:23:56.920
This is going to be the format for the hours and this is going to be the format for the minutes.

338
00:23:56.950 --> 00:23:57.820
Simple enough.

339
00:23:59.510 --> 00:24:07.310
So now if you just go down and just create a function that is basically going to pass a file, so you're

340
00:24:07.310 --> 00:24:16.070
going to write and pass line and it is going to receive a variable that is that is going to be a string

341
00:24:16.070 --> 00:24:20.600
that is going to contain all these three arguments over here and in this function.

342
00:24:20.600 --> 00:24:28.130
What we are going to do is that we are going to write in line dot match and the match first argument

343
00:24:28.130 --> 00:24:30.130
is going to be the log format.

344
00:24:30.440 --> 00:24:34.700
So we are going to just write and log and a score formate.

345
00:24:35.980 --> 00:24:42.640
Just move out of it and we are going to create a block away here and what this blog is going to do is

346
00:24:42.640 --> 00:24:48.010
that it is going to capture one argument at a time and it is going to match it with the regular expression

347
00:24:48.010 --> 00:24:49.230
we have specified over here.

348
00:24:49.330 --> 00:24:51.130
If it is a match, it is going to return.

349
00:24:51.130 --> 00:24:51.370
True.

350
00:24:51.370 --> 00:24:55.560
Else, it is going to just simply go out and it is going to just print out false for us.

351
00:24:55.900 --> 00:25:00.720
So what we are going to do is that we are going to just create a bar A here and in the bars.

352
00:25:00.730 --> 00:25:03.360
We are going to write a variable in which it is going to get store.

353
00:25:03.820 --> 00:25:09.730
And now what we are going to do is that we are going to write in X dot new.

354
00:25:12.350 --> 00:25:19.730
Stereogum dogcatchers captures, and that is where the concept of captures is going to get inside now

355
00:25:19.730 --> 00:25:24.930
what it is going to capture is basically whatever we are going to pass into this function.

356
00:25:25.340 --> 00:25:27.290
So let's just.

357
00:25:29.160 --> 00:25:34.210
And this function, and I guess I just deleted the bracket from here.

358
00:25:34.770 --> 00:25:36.060
So let's just specify it.

359
00:25:36.060 --> 00:25:40.730
And I said this function, what we are going to do is that we are going to call this function simple.

360
00:25:41.160 --> 00:25:44.100
So we are going to write and pass line here and in here.

361
00:25:44.100 --> 00:25:51.180
We are going to pass in the three parameters that are expected to be received into this function.

362
00:25:51.300 --> 00:25:58.650
So what we are going to do is that we are going to specify the time, let's say the time for now is

363
00:25:58.650 --> 00:25:59.490
allowing forty one.

364
00:25:59.490 --> 00:26:03.280
So I would just use the very same time, which is now space.

365
00:26:03.300 --> 00:26:09.480
Then you have to write and the type, then a space and then you can use the type format that is let's

366
00:26:09.480 --> 00:26:10.020
say.

367
00:26:11.750 --> 00:26:12.470
Logged in.

368
00:26:14.880 --> 00:26:17.070
And if you now just run this code.

369
00:26:18.890 --> 00:26:24.650
It has generated error that says lock in PoznaÅ„, undefined variable X.

370
00:26:25.560 --> 00:26:30.690
All right, this has to be line, not X, so we're going to just ride in line over here because it is

371
00:26:30.690 --> 00:26:36.600
something that is building and we are going to also use line of a hill and now run this code.

372
00:26:37.470 --> 00:26:40.320
And you can see that it is working perfectly.

373
00:26:40.560 --> 00:26:46.410
Now, in this example, basically, we are using the dart match instead of the equal to a negation sign.

374
00:26:46.650 --> 00:26:52.050
Now, this method is going to return a Majda object if there is a match.

375
00:26:52.680 --> 00:26:58.860
Otherwise it is going to just return and nail the match that the glass has many useful methods.

376
00:26:59.130 --> 00:27:04.530
If you want just a boolean value that is that the true or false, then you can use the match method,

377
00:27:04.530 --> 00:27:06.480
which is available since Ruby two point four.

378
00:27:06.610 --> 00:27:13.980
Now this also is a faster faster than the match, since Ruby does not need to create a Majda object.

379
00:27:14.490 --> 00:27:21.360
Now you can access the captured data using the DOT capture method are treating the magida object like

380
00:27:21.360 --> 00:27:21.940
an array.

381
00:27:22.260 --> 00:27:27.470
The zero index will have the full match and consequent indexes will contain the match grub's.

382
00:27:27.690 --> 00:27:35.190
So if you want to capture the first group, what you can do is that you can just specify that and you

383
00:27:35.190 --> 00:27:37.710
can also you have the non capturing groups over here.

384
00:27:38.160 --> 00:27:39.810
So for example.

385
00:27:41.300 --> 00:27:48.650
Down here, what are you going to do is that you can just ride an equal to, let's say my name, my

386
00:27:48.680 --> 00:27:52.610
age, let's say, and then you can just use dot match.

387
00:27:54.550 --> 00:27:59.560
And in here, you can just specify the regular expression that is going to be the matching bar so you

388
00:27:59.560 --> 00:28:05.830
can just ride in the place of a hill, and then what you can do is you can use the deep glass of a hill.

389
00:28:07.780 --> 00:28:12.780
And the backslash is going to end as well, so that's for the regular expression to end.

390
00:28:12.780 --> 00:28:22.240
And if you just write in one, then if you just remove this from here, run this code.

391
00:28:23.270 --> 00:28:28.760
You can see that it is run perfectly now if you just ride in boats and one run escort, it is going

392
00:28:28.760 --> 00:28:29.990
to give you the edge.

393
00:28:30.260 --> 00:28:34.060
So that is if you want to only capture the first group.

394
00:28:34.310 --> 00:28:42.260
But if I just press controls at certain times, this is basically use if you want to capture multiple

395
00:28:42.260 --> 00:28:48.110
crops now in here, basically what's going on is that you can access the capture that are using the

396
00:28:48.350 --> 00:28:51.320
capture method or treating the Majda object like an.

397
00:28:51.890 --> 00:28:57.010
Now the zero index will have the full match and the consequent indexes will contain the matched grew

398
00:28:57.060 --> 00:28:57.200
up.

399
00:28:57.200 --> 00:28:59.240
So here are this capturers method.

400
00:28:59.240 --> 00:29:04.670
What it is doing over here is that it is capturing the data, what ever has been passed and from this

401
00:29:04.670 --> 00:29:07.120
function that is using the line functions.

402
00:29:07.130 --> 00:29:11.900
Now, since this is the format we are going to match with and this is the regular expression with which

403
00:29:11.910 --> 00:29:12.830
we want to match it.

404
00:29:13.070 --> 00:29:14.150
This is the time.

405
00:29:14.150 --> 00:29:15.530
This is the type.

406
00:29:16.100 --> 00:29:19.010
And finally, this is the message over here.

407
00:29:19.010 --> 00:29:21.340
And that is basically all done using the capture method.

408
00:29:21.350 --> 00:29:22.970
So that is how capturing work.

409
00:29:23.210 --> 00:29:27.830
Now, as I told you, you can also have non capturing groups and they will let you group expression

410
00:29:27.830 --> 00:29:30.910
together without a performance penalty.

411
00:29:30.920 --> 00:29:36.860
You may also find a named group useful for making complex expressions.

412
00:29:37.490 --> 00:29:40.020
Very, very, very easy to understand.

413
00:29:40.430 --> 00:29:45.110
So to give you an example of non capturing people just removed from here and noncapital and groups are

414
00:29:45.110 --> 00:29:49.850
basically the questionmark, then you have the Scallan and then you have the triple.

415
00:29:50.450 --> 00:29:54.530
So these are basically the non capturing groups and the non capturing.

416
00:29:54.560 --> 00:30:00.500
We also have a type that is known as the name groups and that we have got the question mark.

417
00:30:00.500 --> 00:30:05.390
Then we have got these brackets in which you can have certain data here, and then you have got this

418
00:30:05.810 --> 00:30:08.300
data known as basically the named grub's.

419
00:30:08.480 --> 00:30:13.250
So to give you a quick example for how this is going to work.

420
00:30:13.610 --> 00:30:18.140
Let me give you let's say we have this X in which we have let's say my name.

421
00:30:18.140 --> 00:30:20.420
Let's go on with the previous example.

422
00:30:20.420 --> 00:30:22.160
And I was twenty five.

423
00:30:23.550 --> 00:30:29.580
And use the DOT match and with this dot, imagine what we are going to do is that we are going to use

424
00:30:29.820 --> 00:30:32.570
the non capturing groups over here.

425
00:30:32.940 --> 00:30:36.810
So for that, you have to just write in the format for the regular expression.

426
00:30:37.020 --> 00:30:43.200
And now what you're going to do that you're going to write in the name drops and not capturing a combination

427
00:30:43.200 --> 00:30:43.560
of both.

428
00:30:43.710 --> 00:30:49.530
So I'm going to write in a question mark and then you are going to just write in this stuff over here

429
00:30:49.540 --> 00:30:55.170
that is basically namedrop and you are going to just write in whatever detail has been defined over

430
00:30:55.170 --> 00:30:55.410
here.

431
00:30:55.800 --> 00:31:01.620
So we are doing this stuff for the first argument with the strings of the first argument is my name,

432
00:31:01.630 --> 00:31:03.180
so I will just name it as name.

433
00:31:03.190 --> 00:31:07.810
So that's why it is known as name because you are giving the string certain names.

434
00:31:08.100 --> 00:31:09.920
So in this string we have got to parts.

435
00:31:09.990 --> 00:31:11.520
First is my name, second is my ID.

436
00:31:11.520 --> 00:31:14.030
So we are going to define it with some names.

437
00:31:14.040 --> 00:31:17.460
The first one is my name for we are going to define it with name.

438
00:31:19.040 --> 00:31:24.050
And right after this, what we are going to do is that we are going to use the W plus to watch him and

439
00:31:24.050 --> 00:31:29.960
after that we are going to just specify a space and we are going to do it the very same way.

440
00:31:29.960 --> 00:31:36.020
For the second thing as well, that is the X, so we will just name it as each.

441
00:31:36.050 --> 00:31:43.750
And since our image is in numbers, so we are going to use the Deloused or Helsing's deal with numbers.

442
00:31:43.970 --> 00:31:46.640
So our regular expression is already closed.

443
00:31:46.760 --> 00:31:50.120
Now what you can do is that you can just write in votes.

444
00:31:51.210 --> 00:31:56.910
And you can now use the capturing drops and you can sorry, not the capturing, but you can use the

445
00:31:56.910 --> 00:32:00.360
concept of not capturing groups and you can use the name group here as well.

446
00:32:00.390 --> 00:32:04.860
So if you want to, let's say, print out my image, which in the previous guest you would have just

447
00:32:04.860 --> 00:32:09.870
specified by writing one a hill in this case where you're going to do it, you're going to specify a

448
00:32:09.870 --> 00:32:12.180
colon that is again and on capturing group.

449
00:32:12.180 --> 00:32:16.950
And you have to write an age which is basically something you have defined to the second argument of

450
00:32:16.950 --> 00:32:17.430
this string.

451
00:32:18.120 --> 00:32:18.990
Run this code.

452
00:32:21.080 --> 00:32:30.650
All right, it is undefined local variable or method M. I guess we have to specify X here because we

453
00:32:30.650 --> 00:32:36.060
have named it as X run this now and you can see that it is printed out my age.

454
00:32:36.080 --> 00:32:41.450
Now, if you just want to print out my name, you can just write a name over here, run this and you

455
00:32:41.450 --> 00:32:44.810
can see that it is printed out my name.

456
00:32:44.990 --> 00:32:49.940
So you can do it for the previous example as well in which we were having time, we were having the

457
00:32:49.940 --> 00:32:52.040
type and we were having the message.

458
00:32:52.040 --> 00:32:54.040
So you can do it for all of these.

459
00:32:54.050 --> 00:32:55.460
So you can just specify a space.

460
00:32:55.460 --> 00:32:59.420
You can specify the third argument over here since in the previous case we had time.

461
00:32:59.420 --> 00:33:01.420
So you can just specify the time.

462
00:33:01.460 --> 00:33:02.270
Well, here, that is.

463
00:33:03.090 --> 00:33:09.180
Eleven fifty now, and you can specify the second argument as the time that was enforced, and you can

464
00:33:09.180 --> 00:33:10.230
just specify.

465
00:33:12.680 --> 00:33:19.040
Logged in a hill and in the regular expression, you have to use the very same regular expressions that

466
00:33:19.040 --> 00:33:24.350
were used before, but you have to give them certain names and you have to specify this non capturing

467
00:33:24.350 --> 00:33:25.820
group of question mark over here.

468
00:33:26.000 --> 00:33:27.680
And that is going to do your job.

469
00:33:27.680 --> 00:33:30.070
And then to print them out, you have to just write in votes.

470
00:33:30.080 --> 00:33:34.820
You have to write in the variable which has been defined over here, and you have to write in the name

471
00:33:34.820 --> 00:33:36.540
of the argument you want to bring down.

472
00:33:36.560 --> 00:33:40.460
So for the name, you have to print a name for the second time.

473
00:33:40.470 --> 00:33:41.830
You have to print on the second thing.

474
00:33:42.290 --> 00:33:45.370
And similar goes on for all that stuff.

475
00:33:46.430 --> 00:33:53.160
So unnamed group, basically, it is going to return a mascot object, which you can access to read

476
00:33:53.210 --> 00:34:01.610
the result, which is right, this name here, which we are using to just get my name and age.

477
00:34:02.790 --> 00:34:08.400
If you just ride in age here, so that are basically the namedrop that are returning a match, that

478
00:34:08.400 --> 00:34:14.070
object which you are using right here to read the result of the error you are using.

479
00:34:15.170 --> 00:34:21.260
So I hope you have now understood the concept of capturing a non capturing group as well as the namedrop.

480
00:34:22.420 --> 00:34:24.160
So I guess that's it with the storyline.

481
00:34:24.220 --> 00:34:28.750
It was an extensive tutorial, but it was a very informative tutorial.

482
00:34:28.990 --> 00:34:32.280
A lot of advanced topics were covered in this tutorial.

483
00:34:32.590 --> 00:34:38.200
So I hope you go on and remind us if you have not understood anything, and I hope if you just give

484
00:34:38.200 --> 00:34:41.440
it a look back, you will get and understand everything.

485
00:34:41.440 --> 00:34:44.140
And if you still don't get it, feel free to ask.

486
00:34:44.560 --> 00:34:46.980
So I will see you guys in the next tutorial.

487
00:34:46.990 --> 00:34:47.950
Thank you for now.
