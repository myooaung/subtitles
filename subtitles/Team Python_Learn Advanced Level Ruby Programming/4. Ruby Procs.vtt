WEBVTT
1
00:00:00.240 --> 00:00:01.170
Hey, guys, what's up?

2
00:00:01.200 --> 00:00:04.500
This is a marathon, and I welcome you to another tutorial on this course on Ruby.

3
00:00:04.500 --> 00:00:08.390
And in this studio here, we are going to be covering the last topic of this section.

4
00:00:08.400 --> 00:00:10.200
That is Ruby Barock.

5
00:00:10.210 --> 00:00:13.200
So we already have covered Ruby blocks and Ruby lambdas.

6
00:00:13.210 --> 00:00:17.910
And if you understood those topics, well, then this topic is going to be much more easy because it

7
00:00:17.910 --> 00:00:21.860
is basically related to both the previous topics we have already covered.

8
00:00:22.170 --> 00:00:29.100
So what is are will be a proc object is an encapsulation of a block of code which can be stored in a

9
00:00:29.100 --> 00:00:33.930
local variable past, do a method or another proc and can be called.

10
00:00:34.080 --> 00:00:40.980
Bronk is an essential concept in Ruby and it is a core of its functional programming features.

11
00:00:41.190 --> 00:00:47.130
If you talk about the syntax for how it is going to be used, then you can see it right on your screens.

12
00:00:47.520 --> 00:00:56.130
And the basic difference basically between Ruby lambdas and Ruby Brocks is the syntax using which they

13
00:00:56.130 --> 00:01:01.950
have to be initialized because in the lambdas you have to write in Lembo here and in here you have to

14
00:01:01.950 --> 00:01:04.260
write in proc dot new over here.

15
00:01:04.260 --> 00:01:09.300
And the remaining block over here, which is associated with this block, is basically the very same.

16
00:01:09.300 --> 00:01:10.970
You can use any kind of variable over here.

17
00:01:11.130 --> 00:01:12.870
The only difference come right over here.

18
00:01:13.020 --> 00:01:14.760
So Starboy lambdas.

19
00:01:15.620 --> 00:01:20.990
And the Bronx basically are almost the same with the difference of this index, right?

20
00:01:21.020 --> 00:01:28.340
Well, so let's see some examples and we will also cover a lot of advanced topics that are related with

21
00:01:28.350 --> 00:01:28.760
Brocks.

22
00:01:28.760 --> 00:01:31.490
So let's just move on to Adam.

23
00:01:33.840 --> 00:01:39.780
So to initialize the simplest of all Brog, all you can do is that you can just write and.

24
00:01:41.520 --> 00:01:46.500
The are all or just right BRC and we are going to make it equal to.

25
00:01:47.370 --> 00:01:55.260
Barock Dort new, and we are going to specify these brackets here and in here, you can just write in

26
00:01:55.260 --> 00:02:03.390
anything you want to and you will start to call it using the call method to underwriting PRC dot call

27
00:02:03.420 --> 00:02:06.300
around this code and you can see that my name has got printed.

28
00:02:06.330 --> 00:02:13.710
So as you can see that it has basically the very same functioning as in case of lambdas, because blogs

29
00:02:13.710 --> 00:02:18.540
are basically not objects, but they can be converted into objects of class proc.

30
00:02:18.870 --> 00:02:25.650
This can be done by calling the lamda method of the class object a blog created with Lambda acts like

31
00:02:25.650 --> 00:02:26.520
a Ruby method.

32
00:02:26.520 --> 00:02:30.780
If you don't specify the right number of arguments, you can call the block.

33
00:02:31.290 --> 00:02:37.260
Barock objects are block of code that have been found to a set of local variables.

34
00:02:38.610 --> 00:02:45.180
And basically, the only difference between these two is the syntax where it matters, so, as I told

35
00:02:45.180 --> 00:02:47.530
you, that prox is a very similar concept.

36
00:02:47.550 --> 00:02:50.370
There is no dedicated lambda clause.

37
00:02:50.370 --> 00:02:53.670
A lambda is just a special proc object.

38
00:02:53.670 --> 00:02:59.340
If you take a look at the instanced methods from Barock, you will notice that there is a LAMDA method

39
00:02:59.340 --> 00:02:59.710
as well.

40
00:02:59.730 --> 00:03:07.900
Now a broad behaves differently than a lambda, especially when it comes to arguments or how it is done.

41
00:03:08.340 --> 00:03:13.680
So for example, you have this very same barocco here that is Bercy equal to Prague new.

42
00:03:13.890 --> 00:03:17.550
And you are expecting, let's say, two arguments we are going to write in bars.

43
00:03:17.580 --> 00:03:23.160
Well, here we are going to write an ex, Carmeli, which are going to serve as the two arguments that

44
00:03:23.160 --> 00:03:25.660
are going to pass in to this function.

45
00:03:26.100 --> 00:03:32.160
So in case of Lambda, you know that if you don't pass in these two arguments to this function, it

46
00:03:32.160 --> 00:03:37.020
is going to generate the argument error and it is going to say that it is expecting two arguments and

47
00:03:37.020 --> 00:03:38.700
the arguments are zero.

48
00:03:39.210 --> 00:03:45.150
So in this case, as I told you earlier as well, when I was covering the lambda topic, that Brocks

49
00:03:45.210 --> 00:03:51.490
do not have any kind of strict implementations on the number of arguments.

50
00:03:51.510 --> 00:03:56.730
So in here, if I just write in votes or Marrawah here, you know that it is expecting two arguments.

51
00:03:56.730 --> 00:04:01.890
If I don't pass in any kind of argument over here on this score, it is going to run completely fine.

52
00:04:01.890 --> 00:04:08.120
But if I just convert it into LAMDA now, I run the score.

53
00:04:08.130 --> 00:04:12.780
You can see that it has generated an error that says wrong number of arguments given zero expected to,

54
00:04:12.960 --> 00:04:15.000
and that is known as argument error.

55
00:04:15.150 --> 00:04:19.290
So that is where basically products and lambdas are different.

56
00:04:19.890 --> 00:04:24.690
Another difference between proc and Lambda is how they react to a written statement.

57
00:04:24.900 --> 00:04:30.450
Now a lambda will return non-moral normally like a regular method, as you have seen in the previous

58
00:04:30.450 --> 00:04:31.320
tutorial as well.

59
00:04:31.590 --> 00:04:37.800
But a proc will try to return from the current context.

60
00:04:38.100 --> 00:04:44.310
So if you just have an example of this, we will just remove this from here and we will have one lambda

61
00:04:44.310 --> 00:04:49.260
and one proc and we will see how the lambda is going to work, whereas the proc is going to raise an

62
00:04:49.260 --> 00:04:49.770
exception.

63
00:04:49.800 --> 00:04:54.150
So we are going to just write in votes or I guess we don't need this.

64
00:04:54.270 --> 00:04:56.850
We are going to just write in my.

65
00:04:58.120 --> 00:05:05.440
Lebedko, and that is going to be stable and also we are going to ride in this Syntex Oakhill and in

66
00:05:05.440 --> 00:05:09.730
this braggarts we are going to simply ride in the simplest statement that is written one.

67
00:05:10.000 --> 00:05:12.190
And down here we are going to ride in boats.

68
00:05:14.230 --> 00:05:16.360
Lamda Reserved.

69
00:05:18.620 --> 00:05:25.760
Is and we are going to use interpolation and I'm going to call in the LAMDA using the call function,

70
00:05:25.770 --> 00:05:28.910
so I'm going to write in my landlord a hill.

71
00:05:30.490 --> 00:05:36.370
And that should work very perfectly fine, as you can see that the result is and it has returned the

72
00:05:36.370 --> 00:05:37.480
value that is one.

73
00:05:37.640 --> 00:05:39.790
So that's why one has been put in to try to help.

74
00:05:40.150 --> 00:05:45.760
Now, if I use the very same thing for the program, I'm going to write in my underscore rock.

75
00:05:46.810 --> 00:05:50.110
Equal to rock dot new.

76
00:05:53.910 --> 00:06:02.910
And I use the very same statement that I had used in case of LAMDA, that was right on one and down

77
00:06:02.910 --> 00:06:06.060
here I'm going to write in Votes Barock.

78
00:06:08.270 --> 00:06:15.800
Result is a colon and interpolation of a hair, and I'm going to just write in my.

79
00:06:16.880 --> 00:06:26.150
Underscore Barock dot God, so apparently you can see that they are exactly the same with the only difference

80
00:06:26.150 --> 00:06:27.000
with the syntax.

81
00:06:27.020 --> 00:06:29.320
This is baroque and this is a stab.

82
00:06:29.320 --> 00:06:35.700
Elmdale will help run the score and you can see that it has generated nothing of a hill.

83
00:06:35.990 --> 00:06:39.630
So in case of the lambda, it has generated the result.

84
00:06:39.650 --> 00:06:46.510
But in case of the proc, it has not generated any kind of result for me.

85
00:06:46.730 --> 00:06:52.950
So that is also a big difference between Brocks and lambdas.

86
00:06:53.180 --> 00:06:58.460
Now, if the Baroque was inside a method, then calling Ricciardone would be equivalent to returning

87
00:06:58.460 --> 00:06:59.470
from that method.

88
00:06:59.480 --> 00:07:06.470
For example, if I just initialize a baroque inside a method and then call that method and then inside

89
00:07:06.470 --> 00:07:11.150
that method, I call in that Krog, then it is going to behave something different.

90
00:07:11.180 --> 00:07:13.910
So we will just remove this stuff from here.

91
00:07:15.200 --> 00:07:18.320
And we will define a function that is called Barock.

92
00:07:19.600 --> 00:07:23.560
And inside that function, what I'm going to do is that I'm going to write in inputs.

93
00:07:24.900 --> 00:07:33.750
Just before calling for OK, and I'm going to initialize a brocco here, that is going to be my proc

94
00:07:33.750 --> 00:07:41.010
and it is going to equal to proc dot new and I'm going to just write and return one.

95
00:07:42.520 --> 00:07:45.490
And I'm going to call in my underscore, Brock.

96
00:07:46.600 --> 00:07:47.920
Don't call it a hill.

97
00:07:49.440 --> 00:07:51.240
And down here, I'm going to write in.

98
00:07:52.330 --> 00:07:55.420
Not down here, I'm going to ride in boats.

99
00:07:57.050 --> 00:07:59.270
After the.

100
00:08:00.230 --> 00:08:08.270
Rock God, and I'm going to just end dysfunction now, what I to do over here is that I have also to

101
00:08:08.270 --> 00:08:09.820
call and function.

102
00:08:10.340 --> 00:08:15.350
So what I'm going to do is that I'm going to just write an.

103
00:08:18.160 --> 00:08:18.760
Call.

104
00:08:19.940 --> 00:08:21.020
Underscore.

105
00:08:22.590 --> 00:08:29.920
Brock, just run this code and it says that it is some kind of undefined calling.

106
00:08:29.940 --> 00:08:32.120
Yes, we don't have to specify the here.

107
00:08:32.170 --> 00:08:33.740
I don't know why I specified this.

108
00:08:34.230 --> 00:08:35.310
Now, run this code.

109
00:08:36.430 --> 00:08:40.840
All right, so say Scott Rock, undefined method that is calling.

110
00:08:41.200 --> 00:08:41.720
All right.

111
00:08:41.950 --> 00:08:43.740
This has not to be calling.

112
00:08:43.750 --> 00:08:44.920
This has to be called now.

113
00:08:44.920 --> 00:08:45.430
Run it.

114
00:08:45.910 --> 00:08:49.990
And you can see that it has just written just before calling Brock.

115
00:08:49.990 --> 00:08:52.150
And after that, nothing has got printed.

116
00:08:52.160 --> 00:08:58.540
If I just write and feel here and now run this code, you can see that it is just before calling Brock.

117
00:08:58.540 --> 00:09:02.720
And it has also returned me one since the written statement had worked.

118
00:09:02.830 --> 00:09:06.190
That's why this statement over here does not get executed.

119
00:09:06.870 --> 00:09:13.330
Now, what is the purpose of EOWA here is basically it is going to just tell you that it is a function

120
00:09:13.330 --> 00:09:16.300
which has also got some kind of brog in it.

121
00:09:16.480 --> 00:09:20.890
So it is going to call that function and it is also going to return the statements.

122
00:09:20.890 --> 00:09:25.600
And after the written statement, since when you know that a written statement is called, any kind

123
00:09:25.600 --> 00:09:29.260
of lines up to that inside that very specific blogs are going to get ignored.

124
00:09:29.270 --> 00:09:31.990
So that's why this statement of error does not get executed.

125
00:09:32.200 --> 00:09:37.240
And if you don't specify this Beaverhead, this means that it does not know if it has a Brocklehurst

126
00:09:37.240 --> 00:09:37.690
or not.

127
00:09:37.930 --> 00:09:42.060
It is going to just exit from and it is not going to return anything.

128
00:09:42.070 --> 00:09:48.640
But if you just write and Picolo here, it is going to then return the value, which if you were outside

129
00:09:48.640 --> 00:09:53.680
the function would not have returned because as you have seen in a previous example, we have just got

130
00:09:53.680 --> 00:09:58.690
word, you know, that if you just initialize it outside the function, it does not return to anything.

131
00:09:58.840 --> 00:10:02.530
The lambda does return the one, but Brocks does not return to anything.

132
00:10:02.530 --> 00:10:07.510
But if you use it inside the function, use this be called broncho here, then it is going to, as you

133
00:10:07.510 --> 00:10:11.610
can see, return the value and any statements of that are not going to get executed.

134
00:10:11.620 --> 00:10:16.650
So to give you a summary of how barracks and lambdas are different, there are three major differences.

135
00:10:16.660 --> 00:10:17.830
The first one is.

136
00:10:18.730 --> 00:10:23.410
That lambdas are defined and established in tax and products with the product news and tax.

137
00:10:23.860 --> 00:10:29.830
The second difference is that Dr. done from the current method, Wallum does return from the lamda itself.

138
00:10:29.960 --> 00:10:34.210
And the third difference is that Brocks don't care about the correct number of arguments.

139
00:10:34.210 --> 00:10:36.040
While lambdas will raise an exception.

140
00:10:36.040 --> 00:10:42.850
If you specify the wrong number of arguments, if it is expecting to, then you have to pass to do Alamdar

141
00:10:42.850 --> 00:10:45.040
else that is going to generate the exception error.

142
00:10:45.640 --> 00:10:52.480
So taking a look at this list, we can see that lambdas are a lot closer to our regular method than

143
00:10:52.480 --> 00:10:53.200
products are.

144
00:10:53.680 --> 00:10:59.620
Then comes the concept of closure's now Ruby Brocks and lambdas also have another special attribute.

145
00:10:59.620 --> 00:11:05.620
When you create a Ruby Brocke, it captures the current execution scope that now you have the concept

146
00:11:05.620 --> 00:11:09.610
of lawyers with Lando's only and you know how that works.

147
00:11:09.820 --> 00:11:15.670
Now, this concept, which is sometimes called chloramine, that a Brockville carries with it the values

148
00:11:15.670 --> 00:11:20.430
like local variables and methods from the context where it was defined.

149
00:11:20.650 --> 00:11:24.310
They don't carry the actual values, but a reference to them.

150
00:11:24.320 --> 00:11:31.000
So if the variable change after the Brog is created, the proc will always have the latest version,

151
00:11:31.000 --> 00:11:34.200
the very same as it goes with lambdas.

152
00:11:34.450 --> 00:11:38.920
So if you have, let's say, this very same functional Wajir.

153
00:11:40.220 --> 00:11:45.980
And in that function, we have, let's say, a count variable that is, let's say two and down here,

154
00:11:45.980 --> 00:11:47.450
I just write in my.

155
00:11:50.390 --> 00:11:51.680
Brock Dargon.

156
00:11:54.130 --> 00:12:00.790
And after that function, what I'm going to write and I'm going to initialize this account to one and

157
00:12:00.790 --> 00:12:07.930
I'm going to initialize my broncho here, so I'm going to write in my proc equals to proc dot new and

158
00:12:07.930 --> 00:12:13.000
I'm going to write in votes count here and down here.

159
00:12:13.000 --> 00:12:19.300
I'm going to call this function be called Barock and I'm going to pass in the Barock as an argument

160
00:12:19.300 --> 00:12:21.370
to this function called proctological.

161
00:12:21.370 --> 00:12:23.120
And it is also going to receive that.

162
00:12:23.130 --> 00:12:26.390
So I'm going to write in my barocco here as well.

163
00:12:26.800 --> 00:12:29.980
So if I now just run the score, then you can see that you have got one.

164
00:12:29.980 --> 00:12:34.330
And also in this example, we have a local variable which is set to one.

165
00:12:34.660 --> 00:12:40.580
We also have a dog named my proc and a call proc method, which runs we are called method.

166
00:12:40.840 --> 00:12:44.330
Now, any Broch Orlando that is passed in as an argument.

167
00:12:44.560 --> 00:12:48.020
So what do you think that the output should have been generated?

168
00:12:48.040 --> 00:12:54.630
It seems it would seem like that two is the most logical conclusion, but it because of the closure

169
00:12:54.650 --> 00:12:57.550
property fact, this will print one, as you can see, on the atom.

170
00:12:57.910 --> 00:13:03.550
Now, this happens because the product is using the value of gone from the place where the proc was

171
00:13:03.550 --> 00:13:03.940
defined.

172
00:13:03.940 --> 00:13:08.680
And that is outside of the method definition, which is right here.

173
00:13:08.920 --> 00:13:13.630
If you have any kind of value over here, let's say three, run this code, then it is going to have

174
00:13:13.630 --> 00:13:14.650
that value.

175
00:13:14.650 --> 00:13:21.880
And the reason behind this is that the proc is using the value of gone from place where the proc was

176
00:13:21.880 --> 00:13:24.550
defined, which is right over here.

177
00:13:24.550 --> 00:13:29.950
And that is outside of the method definition since so that why it is going to treat this count as the

178
00:13:29.950 --> 00:13:30.330
value.

179
00:13:30.340 --> 00:13:36.070
And when you write in my product call or you just write inputs account to whatever, it is going to

180
00:13:36.070 --> 00:13:38.260
treat this as the value.

181
00:13:38.290 --> 00:13:40.870
Now, if you have this Barock, let's say.

182
00:13:42.470 --> 00:13:47.750
You just remove from here and you have this broken here, you don't have to pass and now this.

183
00:13:49.000 --> 00:13:53.890
Just remove this and we will initialize this at the top here so that.

184
00:13:57.870 --> 00:14:01.410
It knows that it has some kind of variable control here as well.

185
00:14:01.800 --> 00:14:07.080
Now, if you just run this code, you can see that it has generated error that says undefined local

186
00:14:07.080 --> 00:14:08.870
variable or method, my brog.

187
00:14:09.300 --> 00:14:09.770
All right.

188
00:14:09.780 --> 00:14:14.940
So this has to be, I guess, down here, not after this, because the definition comes first, then

189
00:14:14.940 --> 00:14:16.590
comes the calling number on this.

190
00:14:16.980 --> 00:14:21.030
And you can see that now it has printed the value that is inside because.

191
00:14:22.170 --> 00:14:25.890
That value is going to get printed where the proc is defined.

192
00:14:25.920 --> 00:14:28.710
So now the brokers sense defined inside the function.

193
00:14:28.730 --> 00:14:34.320
So that's why the count variable that is inside the function and any kind of value that is inside the

194
00:14:34.320 --> 00:14:36.390
function is going to get printed.

195
00:14:36.600 --> 00:14:40.220
And this value is now going to get ignored simply.

196
00:14:40.380 --> 00:14:47.370
But if this was outside, as in the previous case, then the value called equal Equilar three was printing

197
00:14:47.370 --> 00:14:54.150
because it is going to get the value where the proc was defined and that can be inside the function

198
00:14:54.150 --> 00:14:55.710
and that can be outside the function.

199
00:14:57.030 --> 00:14:58.530
Now comes the binding clause.

200
00:14:58.550 --> 00:15:02.580
So where do Ruby, Brocks and Lamda store this scope information?

201
00:15:02.850 --> 00:15:04.800
Now let me tell you about the binding clause.

202
00:15:04.800 --> 00:15:10.140
When you create a binding object via the binding method, you are creating an anchor to this point in

203
00:15:10.140 --> 00:15:10.570
the code.

204
00:15:10.800 --> 00:15:17.340
Now, every variable method and class defined at this point will be available literally the object,

205
00:15:17.520 --> 00:15:21.220
even if you are in a completely different school.

206
00:15:21.810 --> 00:15:27.450
So we will just remove this from here and we will define a function that is basically.

207
00:15:29.370 --> 00:15:35.730
Don, finding a way here and what this function is going to have is that we are going to initialize

208
00:15:35.730 --> 00:15:37.540
account variable over here as well.

209
00:15:37.560 --> 00:15:39.210
That is going to be Hundert.

210
00:15:39.870 --> 00:15:42.150
And then we are going to write in binding or help.

211
00:15:43.980 --> 00:15:51.160
Not written binding, we are going to have binding over here and then we are going to end this function.

212
00:15:51.400 --> 00:15:57.180
But now what we are going to do down here is that we are going to write in votes.

213
00:15:59.250 --> 00:16:03.390
Written binding dot glass.

214
00:16:04.500 --> 00:16:08.880
And what we are also going to do is that we are going to write input's.

215
00:16:11.490 --> 00:16:18.510
Return binding dot evaluate and we are going to write in the variable we want to evaluate that is count

216
00:16:18.510 --> 00:16:19.090
in our case.

217
00:16:19.380 --> 00:16:24.450
So basically the count is available thanks to the binding, even though we are outside of the method

218
00:16:24.450 --> 00:16:25.710
where it was defined.

219
00:16:26.550 --> 00:16:30.930
So if you try to print the count directly, you will get an error.

220
00:16:30.960 --> 00:16:34.940
The reason is that count was never defined outside of the method.

221
00:16:34.950 --> 00:16:38.340
So down here, if you just write inputs.

222
00:16:40.840 --> 00:16:46.880
Go ahead, and this variable over here is going to generate error because this is the variable that

223
00:16:46.880 --> 00:16:51.560
is defined inside the function, and if you try to access it outside the function, then this is totally

224
00:16:51.560 --> 00:16:52.290
not going to work.

225
00:16:52.520 --> 00:16:56.230
So to make it work, work you have to do is that you have to do something like this.

226
00:16:56.230 --> 00:17:01.820
So if you just run this code, you can see that this has generated an error that says expecting it up

227
00:17:01.820 --> 00:17:03.050
and put or something like that.

228
00:17:03.080 --> 00:17:06.710
Yes, I guess we have missed something.

229
00:17:06.850 --> 00:17:07.490
A hill.

230
00:17:10.070 --> 00:17:16.240
This has to be the end statement, not written binding, and I guess everything is perfectly in order.

231
00:17:16.250 --> 00:17:21.170
Now run this court, you can see that it has generated the error that says undefined local variable

232
00:17:21.170 --> 00:17:22.100
or method name counts.

233
00:17:22.130 --> 00:17:26.570
So for now, let's just remove it to see the output of these two lines clearly run the score and you

234
00:17:26.570 --> 00:17:28.960
can see that you're combining and you have got Hundert now.

235
00:17:29.300 --> 00:17:31.610
So here that is Ridgen binding DOT class.

236
00:17:31.880 --> 00:17:35.850
It has written that the class of this function will help.

237
00:17:36.140 --> 00:17:38.250
So the class of this function is a binding class.

238
00:17:38.250 --> 00:17:40.390
Since it is, it has got this binding overhead.

239
00:17:40.400 --> 00:17:41.900
So that's why it is a binding class.

240
00:17:42.290 --> 00:17:43.700
So it has a written binding.

241
00:17:43.700 --> 00:17:49.270
And then if you want to extend this variable, then you have to do it using this written binding here

242
00:17:49.730 --> 00:17:54.740
you have to evaluate the count variable and that is going to generate the value of the.

243
00:17:54.950 --> 00:18:00.500
So if you want to access the variable outside the scope of a function, then thanks to binding, you

244
00:18:00.500 --> 00:18:05.930
can do it outside the method as well, where it is not defined at all, because as you can see, that

245
00:18:05.930 --> 00:18:10.880
it is not defined outside the block and you are accessing it, but you can use the binding concept.

246
00:18:11.780 --> 00:18:14.030
So now let's move on to the second part.

247
00:18:14.030 --> 00:18:16.700
That was to access this run.

248
00:18:16.700 --> 00:18:19.310
This an error is going to get generated.

249
00:18:19.310 --> 00:18:24.720
So the excess is you have to use the L and you have to use the binding conceptual hell.

250
00:18:25.580 --> 00:18:31.760
So in other words, execution sometimes, sometimes under the context of a binding object is the same

251
00:18:31.760 --> 00:18:35.680
as if that court was in the same place where that binding was defined.

252
00:18:36.320 --> 00:18:37.960
Remember the anchor metaphor.

253
00:18:38.090 --> 00:18:44.210
You don't need to use the binding objects directly, but it's still good to know that this is a thing

254
00:18:44.210 --> 00:18:46.640
that you can use in Ruby.

255
00:18:47.030 --> 00:18:49.080
So I guess that's it.

256
00:18:49.100 --> 00:18:50.570
We have already covered the school.

257
00:18:50.580 --> 00:18:51.780
We have covered closure.

258
00:18:51.780 --> 00:18:56.140
We have understood the difference between the prox and lenders.

259
00:18:56.140 --> 00:18:58.810
So I guess that's it with this tutorial as well.

260
00:18:58.820 --> 00:19:03.440
I hope you have understood all the three topics we have covered in this section that will be Bloks.

261
00:19:03.440 --> 00:19:07.700
Then we have covered Ruby lambdas and finally we have covered Ruby Prox.

262
00:19:07.820 --> 00:19:13.600
All these were detailed stories in which we have start from the basics of each topic and we have covered

263
00:19:13.610 --> 00:19:16.850
a lot of advanced topics related to all these three topics.

264
00:19:17.150 --> 00:19:19.300
So I guess that's it with this story.

265
00:19:19.310 --> 00:19:20.480
Let's start with this section.

266
00:19:20.480 --> 00:19:21.830
Thank you so much, guys, for watching.

267
00:19:21.830 --> 00:19:25.670
And I'll see you guys in the next section with a very more interesting topic.

268
00:19:25.850 --> 00:19:26.990
So bye bye till then.
