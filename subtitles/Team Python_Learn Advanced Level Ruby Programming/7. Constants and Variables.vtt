WEBVTT
1
00:00:00.330 --> 00:00:01.290
Hey, guys, what's up?

2
00:00:01.320 --> 00:00:05.910
This is American, and I welcome you to another drill on this course on Aruba.

3
00:00:05.910 --> 00:00:12.900
And in this story, we are going to be discussing about variables and constant now talking about ruby

4
00:00:12.900 --> 00:00:13.590
variables.

5
00:00:13.590 --> 00:00:18.690
A variable is basically a symbol or a name that stands for a value.

6
00:00:19.050 --> 00:00:25.470
Now, variables locate in memory location and are used to store values such as numeric values, characters,

7
00:00:25.710 --> 00:00:31.890
character strings or memory addresses so that they can be used in any part of the program you want to

8
00:00:31.890 --> 00:00:32.340
use them.

9
00:00:32.670 --> 00:00:38.810
Now, there are different type of variables and constants that are supported by Ruby starting on with

10
00:00:38.820 --> 00:00:45.510
the first one that is the local variable, not a local variable name must start with a lowercase letter

11
00:00:45.510 --> 00:00:49.500
or an underscore with the eight bit set.

12
00:00:49.980 --> 00:00:55.740
Now, if you talk about the scope of the local variable, a local variable is only accessible from within

13
00:00:55.740 --> 00:00:58.650
the block of its initialization or what is a block?

14
00:00:58.890 --> 00:01:03.150
A block is basically some restriction of a code.

15
00:01:03.270 --> 00:01:07.470
For example, if you are using a loop, then for that you have to implement a block.

16
00:01:07.470 --> 00:01:13.470
And if you initialize some variable in that, then that is going to be accessible only in that specific

17
00:01:13.470 --> 00:01:14.510
block of the code.

18
00:01:14.520 --> 00:01:17.310
It is not going to be accessible outside that.

19
00:01:18.860 --> 00:01:24.200
Now, what is all that stuff you will be covering that in the future, but for now you only need to

20
00:01:24.200 --> 00:01:31.130
understand that the local variable is only accessible within the lock of its initialization now local

21
00:01:31.130 --> 00:01:32.650
variables and methods.

22
00:01:32.750 --> 00:01:39.160
We have also in Ruby, in Ruby, local variable names and method names are nearly identical.

23
00:01:39.170 --> 00:01:46.430
If you have not assigned to one of these ambiguous names, Ruby will, as you may wish to call a method.

24
00:01:46.580 --> 00:01:51.110
Now, once you have assigned to the name Ruby will assume you wish to reference to a local variable.

25
00:01:51.110 --> 00:01:57.100
So the local variable is created when the parser encounters the assignment, not when the assignment

26
00:01:57.110 --> 00:01:57.490
occur.

27
00:01:59.050 --> 00:02:06.550
The second Hruby variable we have is the instance variable, now an instance variable are shared across

28
00:02:06.550 --> 00:02:09.040
all methods for the same object.

29
00:02:09.190 --> 00:02:15.730
I repeat, instant variable are shared across all met methods for the same object, which means that

30
00:02:15.730 --> 00:02:21.460
the instance variable must follow the rules of a local variable name.

31
00:02:21.880 --> 00:02:26.740
Now, if you talk about the syntax of the local variable instance variable, it basically starts with

32
00:02:26.740 --> 00:02:28.750
the ACT character assign.

33
00:02:30.490 --> 00:02:38.740
The next one we have are the glass variables now glass variables are shared between a glass, it's subclauses

34
00:02:38.740 --> 00:02:40.120
and it's instances.

35
00:02:40.300 --> 00:02:43.780
A glass variable must start with a double add signs.

36
00:02:44.050 --> 00:02:48.300
The rest of the name follows the same rules as that of instanced variables.

37
00:02:48.730 --> 00:02:51.520
Then we have the global variables in Ruby.

38
00:02:51.520 --> 00:02:54.460
A global variable starts with a dollar sign.

39
00:02:54.850 --> 00:02:59.710
The rest of the name follows the same rules as that of instanced variables.

40
00:02:59.710 --> 00:03:05.470
And global variable is basically what is accessible everywhere and every kind of block.

41
00:03:05.470 --> 00:03:12.150
Outside the block, inside the block, throughout your code, global variable is going to be accessible.

42
00:03:12.250 --> 00:03:19.570
So Ruby has some special Globalstar that behave differently depending on the context, such as the regular

43
00:03:19.570 --> 00:03:24.820
expression match variables are that have a side effect when assigned to.

44
00:03:26.320 --> 00:03:32.140
We'll be discussing that so that we have finally the ruby Constance, now a veritable whose name begins

45
00:03:32.140 --> 00:03:38.680
with an uppercase letter, basically a constant, and that is basically the ID for a constant.

46
00:03:38.800 --> 00:03:45.640
Now, a constant can be reassigned, a value after its initialization, but doing so will generate a

47
00:03:45.640 --> 00:03:46.180
warning.

48
00:03:46.330 --> 00:03:53.800
Now, every class is a constant, trying to access an unlimited constant raise the name error exception.

49
00:03:56.680 --> 00:04:04.360
So we will be showing you all of that, these variables at the end of the tutorial, but before that,

50
00:04:04.360 --> 00:04:06.380
we have to discuss some pseudo variables.

51
00:04:06.400 --> 00:04:08.860
Now, the first one is the South.

52
00:04:09.190 --> 00:04:16.440
And if you talk about its description, it is basically the execution context of the current matter.

53
00:04:16.990 --> 00:04:20.590
The next one is an L, which expresses nothing.

54
00:04:20.590 --> 00:04:24.880
If you are familiar with C or C++, then in both we have an idea.

55
00:04:25.150 --> 00:04:27.310
But sorry, we have the end you.

56
00:04:27.880 --> 00:04:31.840
But in Ruby we have the L in place of and you.

57
00:04:32.620 --> 00:04:41.170
So it expresses nothing and also is considered to be false and every other value is considered to be

58
00:04:41.170 --> 00:04:42.880
true in a ruby.

59
00:04:42.880 --> 00:04:47.440
Then we have the true expression that expresses Strew and then we have the false which expresses the

60
00:04:47.440 --> 00:04:47.920
false.

61
00:04:48.610 --> 00:04:53.010
Then we have the dollar one dollar to uptalk dollar nine.

62
00:04:53.020 --> 00:05:00.220
And these are basically contents of capturing groups for a regular expression, matches their local

63
00:05:00.220 --> 00:05:04.060
to the current threat and the stack frame.

64
00:05:06.470 --> 00:05:13.130
Then we have some predefined variables starting on with a dollar sign exclamation mark that is basically

65
00:05:13.130 --> 00:05:17.610
the exception information message set by the last race.

66
00:05:17.690 --> 00:05:25.040
Then we have the dollar sign add sign, which basically is the array of the backtrace of the last exception

67
00:05:25.040 --> 00:05:25.310
through.

68
00:05:25.310 --> 00:05:32.330
And then we have a dollar Dorasan with an enzyme that is basically for the string matched by the last

69
00:05:32.330 --> 00:05:36.750
successful pattern that match in this scope.

70
00:05:36.840 --> 00:05:42.760
Then we have the next one that is a dollar and a dash at the top.

71
00:05:42.770 --> 00:05:45.840
That is basically the string to the left of the last successful match.

72
00:05:45.860 --> 00:05:51.770
Then we have a negation on the dollar sign that is for the strength of the right of the last successful

73
00:05:52.040 --> 00:05:52.790
match.

74
00:05:54.230 --> 00:06:00.830
Then we have the dollar plus sign that indicates the last drop of the last successful match, then from

75
00:06:00.830 --> 00:06:02.270
the dollar one to dollar nine.

76
00:06:02.300 --> 00:06:07.010
That is the end of the last successful regular expression match.

77
00:06:07.280 --> 00:06:09.740
Then we have the dollar sign with the magician Mogg.

78
00:06:09.740 --> 00:06:14.540
That is for the information about the last match in the grand scope.

79
00:06:14.540 --> 00:06:19.970
Then with the equal, do we have the flag for case insensitive and ill by default?

80
00:06:19.970 --> 00:06:24.250
If you just leave it, then we have the dollar sign with the backslash.

81
00:06:24.260 --> 00:06:26.600
That is the input record separator.

82
00:06:26.600 --> 00:06:29.270
That is new line by default.

83
00:06:31.010 --> 00:06:34.040
Some more predefined variables.

84
00:06:35.470 --> 00:06:37.570
The dollar sign was the front.

85
00:06:39.930 --> 00:06:46.190
That is for the output records operator for the print and I all right, and its default is also going

86
00:06:46.190 --> 00:06:46.760
to be no.

87
00:06:46.760 --> 00:06:51.950
Then with the comma we have the output fee separator for the print and our joint.

88
00:06:52.280 --> 00:06:59.360
Then we have with the semicolon, that is the default separator for string split than with the DOT.

89
00:06:59.360 --> 00:07:03.290
We have the current in line number of the last one that was read.

90
00:07:03.620 --> 00:07:08.480
Now of the less than sign we have then object that provide access to the concatenation of the content

91
00:07:08.480 --> 00:07:09.730
of all the files given us.

92
00:07:09.740 --> 00:07:15.950
Command line arguments are the standard in that is basically in the case where there are no arguments

93
00:07:15.950 --> 00:07:23.690
and it is only read only then we have the final name, the Grundon put filename that is basically four

94
00:07:24.470 --> 00:07:29.600
dollar less than DOT for the same as dollar, less than dot filename.

95
00:07:29.810 --> 00:07:34.490
And we have the dollars and will create a sign that is for the destination of output for the kernel

96
00:07:34.490 --> 00:07:39.830
dot print and colonel dot print f and its default is going to be send it out.

97
00:07:40.310 --> 00:07:47.090
Then with underscore we have the last input line of the string by gets our read line then with zero

98
00:07:47.090 --> 00:07:53.930
we have contains the name of the script being executed, maybe assignable and then with the Starick

99
00:07:53.930 --> 00:07:59.810
we have the command line arguments given for the script also known as the a r g.

100
00:07:59.990 --> 00:08:00.530
We.

101
00:08:02.410 --> 00:08:06.790
So let me show you some more predefined variables over here.

102
00:08:06.850 --> 00:08:08.740
We have no dollar sign.

103
00:08:08.740 --> 00:08:11.580
That is the precise number of the drug running the script.

104
00:08:12.160 --> 00:08:19.630
Then we have the dollar question mark that is for the status of the last executer trial process done

105
00:08:19.630 --> 00:08:20.170
with the call.

106
00:08:20.170 --> 00:08:24.850
And we have the last part for scripts and Bindery Module's by Lotoro require.

107
00:08:24.850 --> 00:08:30.730
Then we have the double exclamation mark that is for the array contains the module end loaded by requiring.

108
00:08:31.180 --> 00:08:38.110
Then we have the standard error with a dollar sign that is for the current standard error output and

109
00:08:38.110 --> 00:08:39.040
then for the standard.

110
00:08:39.040 --> 00:08:44.290
And we have the current standard board and with the standard out we have the current standard output.

111
00:08:44.650 --> 00:08:49.780
Then with a dash, do we have the state of the Dashty switch that is assignable and then what?

112
00:08:49.780 --> 00:08:53.400
The Dastgir we have the character encoding of the source code.

113
00:08:53.410 --> 00:09:00.190
And finally for the dash, we we have the verbals flag which is set by the dash we switch.

114
00:09:04.600 --> 00:09:10.540
So talking about some more predefined variables over here, we have with a dash that it's true if option

115
00:09:10.540 --> 00:09:17.740
dash, that is the autopilot mode is set and it is only read only variable now with a dash if and in

116
00:09:17.740 --> 00:09:18.710
place edit mode.

117
00:09:18.710 --> 00:09:21.130
Instead, this variable holds the extension.

118
00:09:21.430 --> 00:09:23.470
Otherwise it is going to be no.

119
00:09:23.740 --> 00:09:26.200
If nothing is set it then what.

120
00:09:26.200 --> 00:09:33.300
The dash one we have true app option dash one is set line ending processing is on and it is also agreed

121
00:09:33.310 --> 00:09:40.120
only variable and with a dash B it is true if option B is set that is the loop mode is on and it is

122
00:09:40.120 --> 00:09:41.380
also a read-only.

123
00:09:41.710 --> 00:09:45.370
And then finally with Dashti we have a true option.

124
00:09:45.370 --> 00:09:48.850
The dash W is set.

125
00:09:51.440 --> 00:09:59.780
Now talking about the predefined constant, so here we have the file that specifies the current file

126
00:09:59.780 --> 00:10:07.160
and for the line, it specifies the current line and what these are D.A. it shows the current directory.

127
00:10:09.160 --> 00:10:13.870
So you don't need to worry about all of these, basically, these are what we are going to be discussing

128
00:10:13.870 --> 00:10:19.810
in the future tutorials, the purpose of this tutorial was to just give you a brief description of all

129
00:10:19.810 --> 00:10:22.600
of these predefined variables and predefined constants.

130
00:10:22.600 --> 00:10:24.660
It's altered to suit the variables over here.

131
00:10:25.420 --> 00:10:29.590
So let's just talk about some examples here.

132
00:10:29.680 --> 00:10:37.110
So I will just go on to my Adam compiler here and talking about the variables.

133
00:10:37.150 --> 00:10:41.470
The first one was the local variables or local variable, as I told you, is going to be assigned in

134
00:10:41.470 --> 00:10:44.820
a very simple way, that is with a lowercase letter or an endoscope.

135
00:10:45.160 --> 00:10:51.100
So we are going to let's just sign it and let's just I want to say it equal to five and let's say I

136
00:10:51.100 --> 00:10:52.270
want to print it out.

137
00:10:52.300 --> 00:10:57.880
So we just specify puts it and it just press on plus r you can see the pipe has been printed because

138
00:10:58.180 --> 00:10:59.560
it contains this five.

139
00:11:00.950 --> 00:11:07.070
Then to specify this as an instance variable, you have to specify at the rate with it at the rate of

140
00:11:07.070 --> 00:11:07.950
a hair as well.

141
00:11:08.240 --> 00:11:12.030
And that is going to be treated as an instance variable now.

142
00:11:12.110 --> 00:11:14.440
Plus R is going to generate the output for you.

143
00:11:14.750 --> 00:11:18.890
And if you specify double at the rate, what it.

144
00:11:22.290 --> 00:11:29.280
You have to specify double here as well, all plus are, and the answer has been generated by the you

145
00:11:29.280 --> 00:11:36.720
can see that it is giving you the warning at the last variable access from top level is done because

146
00:11:36.720 --> 00:11:38.240
it is a glassy level variable.

147
00:11:38.250 --> 00:11:40.110
That's why this warning was generated.

148
00:11:40.110 --> 00:11:45.600
And now if you want to do it as a global variable, you have to specify the dollar sign.

149
00:11:46.800 --> 00:11:49.060
Dollar sign of here as well.

150
00:11:49.560 --> 00:11:53.970
All plus are and the pipe is going to be generated and now it is a global variable.

151
00:11:56.830 --> 00:12:02.470
Now he's going to make it a constant what do you have to do is that he have to specify a capital with

152
00:12:02.470 --> 00:12:02.770
it.

153
00:12:04.230 --> 00:12:06.160
Capital apprehended over here as well.

154
00:12:06.220 --> 00:12:11.580
All plus hour and five is going to be generated now if I want to reassign this, a new value, let's

155
00:12:11.580 --> 00:12:14.550
say six, and now I specify both.

156
00:12:15.910 --> 00:12:23.050
Capitally, I press all are it is giving me the output, but as I told you, that for constant value

157
00:12:23.050 --> 00:12:27.400
once assigned, if you reassigns some value to a constant value, again, it is going to give you a

158
00:12:27.400 --> 00:12:27.760
warning.

159
00:12:27.760 --> 00:12:33.520
And as you can see the warning, it says previous definition of it was already here and it says that

160
00:12:33.520 --> 00:12:36.910
already initialized constant A as a constant.

161
00:12:37.090 --> 00:12:40.750
So that's why when you reassigned it, it generated a warning message for you.

162
00:12:40.750 --> 00:12:41.110
It did.

163
00:12:41.110 --> 00:12:47.050
The output for you, for Sprenger text was printed successfully, but it generated the warning message

164
00:12:47.050 --> 00:12:47.870
for you as well.

165
00:12:48.190 --> 00:12:55.600
So that's how basically local global instance, variable and class variables and constraints are used

166
00:12:55.600 --> 00:12:56.560
in Ruby.

167
00:12:56.740 --> 00:13:03.940
Now, talking about the second part that deals with the parameters we have just discussed that were

168
00:13:03.940 --> 00:13:08.950
basically predefined, constant, the predefined variables that we will be discussing in the future

169
00:13:08.950 --> 00:13:14.770
tutorials, because for that, this tutorial as a w the purpose was just to give you a brief description

170
00:13:14.770 --> 00:13:15.520
of all of those.

171
00:13:15.730 --> 00:13:16.720
So I guess.

172
00:13:18.070 --> 00:13:19.340
That's it for this tutorial.

173
00:13:19.810 --> 00:13:24.040
Thank you so much, guys, for watching and I'll see you guys in the next oratorio.
