WEBVTT
1
00:00:00.330 --> 00:00:01.350
Hey, guys, what's up?

2
00:00:01.380 --> 00:00:04.830
This is a marathon, and I welcome you to another tutorial on this course on Dhruva.

3
00:00:04.830 --> 00:00:10.320
And in this story, we are going to be covering the Ruby file method so you can do other things with

4
00:00:10.320 --> 00:00:11.190
files as well.

5
00:00:11.190 --> 00:00:14.150
Besides reading and writing to a file.

6
00:00:14.430 --> 00:00:21.180
For example, you may want to know if a file exists or to get a list of files for the current directory.

7
00:00:21.420 --> 00:00:24.480
Now, you are going to be using multiple methods in this tutorial.

8
00:00:24.480 --> 00:00:25.960
The first your first function.

9
00:00:25.980 --> 00:00:30.960
We are going to cover in this tutorial is going to be the size function that is going to list the file

10
00:00:30.960 --> 00:00:31.980
size and bytes.

11
00:00:31.980 --> 00:00:38.070
Then we are going to cover the exact function that is going to tell you if a file exists in a current

12
00:00:38.070 --> 00:00:46.410
directory, you are looking for it or not, then you are going to have the method E X, the name and

13
00:00:46.410 --> 00:00:55.500
this E name function is also going to check if it is going to get you the file extension and this is

14
00:00:55.500 --> 00:00:57.780
going to work even if the file does not exist.

15
00:00:58.930 --> 00:01:03.760
Then you are going to go to the function based name that is going to get the file name without the directory

16
00:01:03.760 --> 00:01:11.440
part, then you are going to cover that the real name function as it is indicated by its name, it is

17
00:01:11.440 --> 00:01:14.200
going to get the part for the file without the file name.

18
00:01:14.560 --> 00:01:19.240
And we are also going to cover some a lot about the directories as well.

19
00:01:19.270 --> 00:01:25.960
So you are going to see that our method in this, we are going to instead of using the file dot, which

20
00:01:25.960 --> 00:01:31.870
we have been covering so far, we are going to use the DCI are we are going to use the directory options

21
00:01:32.470 --> 00:01:38.800
more where we are also going to have other things that includes the file as.

22
00:01:39.070 --> 00:01:42.140
So this is going to be a very informative tutorial.

23
00:01:42.160 --> 00:01:47.170
You are going to learn a lot of functions and you are going to see a lot of things which you can do

24
00:01:47.170 --> 00:01:51.700
to a file besides reading, writing, opening and closing applied.

25
00:01:53.180 --> 00:01:57.920
So to start on with, the first one we are going to cover in this tutorial is the site's function.

26
00:01:57.950 --> 00:02:06.470
So for that, what do you have to do is that you have to just go and use the file dot size and in the

27
00:02:06.470 --> 00:02:09.010
brackets you are going to specify the name of the file.

28
00:02:09.320 --> 00:02:12.440
So you know that we have already got these two files.

29
00:02:12.450 --> 00:02:17.350
The first one is rhenium and then we have the file writing a file on him.

30
00:02:17.570 --> 00:02:19.670
So we are going to see.

31
00:02:20.710 --> 00:02:27.810
The size for these fires, so we are going to write as renamed Oakhill, and we also need to specify

32
00:02:27.830 --> 00:02:31.660
door to deal with this and run this code.

33
00:02:32.200 --> 00:02:34.330
As you can see that it is brand perfectly.

34
00:02:34.330 --> 00:02:40.870
All we need to do is that we have to store it in a variable that's the land.

35
00:02:40.870 --> 00:02:45.430
Or you can just use any other name you want to and downhill.

36
00:02:45.430 --> 00:02:52.890
What you can do is that you can just print out the land on this code and it says the size of the fire

37
00:02:52.900 --> 00:02:56.700
is zero because I guess there is nothing in this file for now.

38
00:02:56.890 --> 00:03:00.900
So that's why the length of the file for now is zero.

39
00:03:01.270 --> 00:03:04.260
Then you can also see that if a file exists or not.

40
00:03:04.270 --> 00:03:11.110
So for that you can use the exist function so you can just use file dot exists.

41
00:03:11.620 --> 00:03:16.810
You're going to you have to specify a question mark because whenever you are asking the editor a question,

42
00:03:16.990 --> 00:03:18.990
you have to specify this with that function.

43
00:03:19.330 --> 00:03:24.240
So we are going to, let's say, check for renamed DOT again.

44
00:03:25.000 --> 00:03:29.530
So we will again store it in a variable, let's say X this time.

45
00:03:29.530 --> 00:03:36.430
And down here we are going to write inputs X run this code and you can see that it is true because the

46
00:03:36.430 --> 00:03:39.820
file is right in the directory you are working.

47
00:03:39.820 --> 00:03:45.010
And if you just change the name, let's say just remove this and from here, run this now and you can

48
00:03:45.010 --> 00:03:50.470
see that it is going to generate files because renamed not no file like this exist in the directory

49
00:03:50.480 --> 00:03:51.370
we are working in.

50
00:03:51.730 --> 00:03:58.000
The next function we are going to cover is the X name that is going to get the file extension and this

51
00:03:58.000 --> 00:04:00.490
function is even going to work at the file does not exist.

52
00:04:01.920 --> 00:04:03.900
So we will just remove this from here.

53
00:04:03.930 --> 00:04:13.140
We are going to write an X equal to file dot, e x name and in here we are going to write in the name

54
00:04:13.140 --> 00:04:15.840
of the file that is, let's say, renamed the city.

55
00:04:16.740 --> 00:04:24.330
And down here we are going to write in quotes X, run this code and you can see that it has generated

56
00:04:24.330 --> 00:04:26.310
the extension that is Dorthe.

57
00:04:26.670 --> 00:04:31.070
So this function basically generates the file extension for you.

58
00:04:31.530 --> 00:04:36.720
The next function is the best name function that is going to get the file name without the directory.

59
00:04:37.030 --> 00:04:41.190
But so what you are going to do is that you are going to.

60
00:04:42.390 --> 00:04:47.370
Right, and X equal to file dot based name.

61
00:04:49.140 --> 00:04:53.980
And in the perimeter, what you are going to do is that you are going to write in the name of the file,

62
00:04:53.980 --> 00:04:58.100
let's say renamed DOT the X de.

63
00:04:59.710 --> 00:05:05.680
All right, inputs X to run this code, and you can see that you have got the filename along with the

64
00:05:05.680 --> 00:05:07.900
extension as well, so it says renamed.

65
00:05:09.930 --> 00:05:15.190
The next function we are going to cover is the name that stands for Directory Name, and it is going

66
00:05:15.190 --> 00:05:19.440
to get the part for the file without the file name.

67
00:05:19.810 --> 00:05:24.520
So if you just write in X equal to.

68
00:05:25.610 --> 00:05:26.870
File dot.

69
00:05:28.090 --> 00:05:29.650
These are name.

70
00:05:31.970 --> 00:05:34.220
Rename DOT, the XDA.

71
00:05:35.460 --> 00:05:42.480
Right, inputs x this, Scott, you're going to see that you have got this dot operator and this dot

72
00:05:42.480 --> 00:05:47.130
operator basically means that it is referring to the current directory you are working at.

73
00:05:48.640 --> 00:05:54.550
So the next function is the directory function, and it is going to check if this is actually a file

74
00:05:54.550 --> 00:05:59.200
or a directory, in our case, this our file, so you don't have to run these.

75
00:05:59.620 --> 00:06:06.630
So one more function we always have to use are basically the directory options.

76
00:06:06.640 --> 00:06:12.350
Now, whatever you have been covering so far in this section was basically related with this file object

77
00:06:12.370 --> 00:06:12.880
or help.

78
00:06:13.270 --> 00:06:20.640
The next O'Haire you can use are basically correct three options and that goes on with the word D.C.I

79
00:06:21.010 --> 00:06:21.580
are.

80
00:06:22.960 --> 00:06:24.310
So when are we are going to use this?

81
00:06:24.340 --> 00:06:31.060
Now, there are specific functions that are associated with it using the DVR globe, you can get a list

82
00:06:31.060 --> 00:06:33.590
of all the files that matches a certain pattern.

83
00:06:33.610 --> 00:06:39.790
So, for example, if you just remove this from here and what are you going to do is that you are going

84
00:06:39.790 --> 00:06:42.070
to just remove this from here and you are going to write in.

85
00:06:42.070 --> 00:06:44.490
These are will the.

86
00:06:45.370 --> 00:06:49.570
And what are you going to do is that you are going to let us specify a story.

87
00:06:49.600 --> 00:06:51.730
Go ahead, run this code.

88
00:06:53.240 --> 00:06:59.960
And you can see that it has got all the names that basically exist with some extensions, so it is it

89
00:06:59.960 --> 00:07:07.600
has got every folder that is actually a part of this current working directory we are working in now.

90
00:07:07.610 --> 00:07:10.270
For now, you can see that you have got to find over here.

91
00:07:10.340 --> 00:07:15.230
This is because I have hidden the rest of the files so that you don't get confused with all that stuff

92
00:07:15.230 --> 00:07:16.270
with these files over here.

93
00:07:16.550 --> 00:07:18.830
So that's what you are seeing.

94
00:07:18.830 --> 00:07:19.720
No files over here.

95
00:07:19.730 --> 00:07:21.380
But here you are seeing a lot of files.

96
00:07:21.580 --> 00:07:25.630
That's why because I have written I have just hidden the rest of the files here.

97
00:07:25.640 --> 00:07:27.620
You can see your files that are renamed.

98
00:07:28.730 --> 00:07:30.520
And where is the second one?

99
00:07:30.530 --> 00:07:31.160
Here it is.

100
00:07:31.160 --> 00:07:32.450
It is file writing data.

101
00:07:32.690 --> 00:07:34.100
So you have got your two files.

102
00:07:34.100 --> 00:07:38.740
The rest files are basically the hidden files, which it is showing right now.

103
00:07:39.170 --> 00:07:41.420
Then you can also specify.

104
00:07:43.760 --> 00:07:49.370
SPDC over here on this code, and you can see that nothing has been generated because nothing is specified

105
00:07:49.370 --> 00:07:49.910
with this name.

106
00:07:49.940 --> 00:07:53.720
So if you're just writing, let's say, renamed the here on this code.

107
00:07:55.220 --> 00:08:03.640
And it is still generating nothing because all the files containing this are not going to get visible

108
00:08:03.890 --> 00:08:07.610
now, it should have because we have specified this.

109
00:08:07.610 --> 00:08:11.630
We have specified, not specified the star here as well.

110
00:08:11.640 --> 00:08:13.940
Run this now and now you have got this.

111
00:08:14.120 --> 00:08:23.020
If you enclose the characters and these are just again encoded between these Derickson.

112
00:08:23.150 --> 00:08:28.340
So it is going to show all the places that have these or have you just right in, let's say.

113
00:08:29.660 --> 00:08:34.970
Named O'Haire underscored it is still going to show renamed the city because it is going to show all

114
00:08:34.970 --> 00:08:42.350
the flights that have these characters in a series in its rhenium, has a named in series in it, as

115
00:08:42.350 --> 00:08:42.930
you can see.

116
00:08:42.980 --> 00:08:45.230
So that's why rename the is going to get busy.

117
00:08:45.240 --> 00:08:50.760
But then you can also show the flyers with respect to their extensions.

118
00:08:50.770 --> 00:08:59.420
So if you just remove this from here, a single starick and just write in dot the city on this and you

119
00:08:59.420 --> 00:09:02.090
are going to get all the files that have the extension.

120
00:09:02.540 --> 00:09:07.430
For now, we have got only two files while writing the DST and renamed the city that are going to get

121
00:09:07.730 --> 00:09:08.770
visible right here.

122
00:09:10.530 --> 00:09:17.700
So using the DVR at the last, it's also possible to print the current working directory for that,

123
00:09:17.700 --> 00:09:24.960
what you have to write is that you have to write in order to W.D. or underscore, and you are going

124
00:09:24.960 --> 00:09:29.190
to get the current working directory that is a C folder user as a marathon.

125
00:09:29.190 --> 00:09:32.250
And then documents, as you can see right over here as well.

126
00:09:32.280 --> 00:09:35.400
You are working in this book, then you are working in the documents folder.

127
00:09:36.320 --> 00:09:43.850
So I hope it is clear then you can also check if a directory is empty or not or if some folders are

128
00:09:43.850 --> 00:09:44.900
present in it.

129
00:09:45.380 --> 00:09:50.510
So for that, what do you have to do is that you have to check it using the empty function.

130
00:09:50.510 --> 00:09:50.750
Right.

131
00:09:50.750 --> 00:09:51.650
A question mark.

132
00:09:53.610 --> 00:10:01.560
And inside here, what you can do is that you can specify backslash DMV, run this and all right, we

133
00:10:01.560 --> 00:10:02.520
have got some error.

134
00:10:02.520 --> 00:10:04.710
It says an empty no such file or directory.

135
00:10:05.290 --> 00:10:06.210
You don't have to.

136
00:10:06.210 --> 00:10:07.640
So let's just remove this from here.

137
00:10:09.880 --> 00:10:10.630
Run this.

138
00:10:12.200 --> 00:10:15.530
All right, it says it is expecting an argument, so let's give it one.

139
00:10:17.750 --> 00:10:18.680
Run this now.

140
00:10:21.170 --> 00:10:22.440
Daughter, the missing.

141
00:10:22.610 --> 00:10:29.780
Here, I guess, around us now, and it is going to generate us because we are checking if this directory

142
00:10:29.780 --> 00:10:34.400
we are working is is empty of whatever we haven't done over here since.

143
00:10:34.400 --> 00:10:37.010
It is not because we know that such file exists.

144
00:10:37.040 --> 00:10:39.170
So that's why it has generated false hope here.

145
00:10:41.510 --> 00:10:49.190
Then you can also create a new directory using the Iowa here for that, where you have to do is that

146
00:10:49.190 --> 00:10:51.290
you can just write an.

147
00:10:53.540 --> 00:11:00.350
I'm the I r that stands for MYG Directory and in the brackets O'Haire, you can specify any directory

148
00:11:00.350 --> 00:11:05.000
you want to create so you can just write in the name of the directory and that is going to get created

149
00:11:05.000 --> 00:11:05.440
for you.

150
00:11:05.810 --> 00:11:13.850
Then you can also create a temporary directory with the M dp dmp dya that is emptied.

151
00:11:13.850 --> 00:11:20.690
Then it's it, it has this DMP that stands for a temporary and then the IRR for the directory and you

152
00:11:20.690 --> 00:11:23.390
can just create a temporary directory with that as well.

153
00:11:23.540 --> 00:11:29.660
And that directory is basically going to be enclosed in some kind of a block so that when that block

154
00:11:29.660 --> 00:11:32.000
exists the directory is going to get finished.

155
00:11:33.570 --> 00:11:40.140
Then in four hours, you can also have defiles as modules, there are some extra file handling utilities

156
00:11:40.140 --> 00:11:46.050
you can get access to within the file utils module, for example, you can compare files, you can touch

157
00:11:46.050 --> 00:11:51.930
a file that is to update the last access and modification time, or you can just copy files and directory

158
00:11:51.930 --> 00:11:53.210
with a CPR method.

159
00:11:53.670 --> 00:11:57.420
So for that, what do you have to do is that you have to just remove this from here.

160
00:11:58.350 --> 00:12:03.060
And hear what you have to write and you have to write and require you have to write and file.

161
00:12:04.140 --> 00:12:08.380
You let's run this to see if it works perfectly.

162
00:12:08.400 --> 00:12:12.020
Yes, it has now required fight while Diaz.

163
00:12:12.240 --> 00:12:13.800
Now you can use it down here.

164
00:12:13.800 --> 00:12:16.490
You can just try it and find Udai else.

165
00:12:16.620 --> 00:12:19.500
And it works the same as the directory and the file works.

166
00:12:19.770 --> 00:12:22.260
And with it you can use the functions.

167
00:12:22.260 --> 00:12:27.480
That is, let's say if you want to compare to files, you can just try and compare, underscore file

168
00:12:27.480 --> 00:12:29.340
and it accepts two parameters.

169
00:12:29.460 --> 00:12:31.080
The first one is going to be the first one.

170
00:12:31.080 --> 00:12:34.860
The second one is going to give the second five, which are going to get compared.

171
00:12:35.070 --> 00:12:38.700
So we are going to, let's say, iterate and rename the SD.

172
00:12:39.900 --> 00:12:45.420
And the second file we have right over here is the file writing, Dorte, so the second argument is

173
00:12:45.420 --> 00:12:47.190
going to be file.

174
00:12:49.410 --> 00:12:55.000
Riding around the school to see if it works, yes, it does.

175
00:12:55.020 --> 00:13:00.030
Now, what do you have to do is that you have to store it and variable, let's say X.

176
00:13:02.380 --> 00:13:06.190
And down here, we are going to ride in Boats X around this.

177
00:13:07.110 --> 00:13:13.740
And it says false, which means that these two fires were not equal to each other, they were not equal

178
00:13:13.740 --> 00:13:18.360
because you know, that one file contains the data that was HelloWallet, I guess, which we had stored

179
00:13:18.360 --> 00:13:19.320
in the previous tutorial.

180
00:13:19.320 --> 00:13:22.260
And the other file is basically empty.

181
00:13:22.260 --> 00:13:22.980
It contains nothing.

182
00:13:22.990 --> 00:13:28.230
So that's what it is going to compare the files with respect to the number of bytes, which means the

183
00:13:28.230 --> 00:13:28.890
file size.

184
00:13:28.900 --> 00:13:32.590
So they are not equal than what it is going to do is that it is going to return false.

185
00:13:32.640 --> 00:13:37.860
But if both the files are the same amount of data, it is the same in the number of bodies in this function

186
00:13:37.860 --> 00:13:40.320
over here is going to generate.

187
00:13:40.740 --> 00:13:41.150
True.

188
00:13:41.490 --> 00:13:47.100
Then you can also judge a file, which means that you can update the last access and modification time

189
00:13:47.100 --> 00:13:47.550
for that.

190
00:13:47.550 --> 00:13:49.530
But you have to do is just right.

191
00:13:49.890 --> 00:13:51.360
And Dodgeville Hill.

192
00:13:52.830 --> 00:13:58.170
And in the parameters you have to write in the name of the directory for which you want to change the

193
00:13:58.260 --> 00:14:05.100
change or update the success and modification time, and you can also use the CPR method that is basically

194
00:14:05.100 --> 00:14:08.670
used to copy files and directories.

195
00:14:09.970 --> 00:14:17.560
And that is used in a way, with this faludi's and if the right and c.B underscore are and in these

196
00:14:17.560 --> 00:14:21.460
parameters where you have to do is that you have to write in the name of the to fly, the first flight

197
00:14:21.460 --> 00:14:25.720
is going to be the file in which the data is going to get copied.

198
00:14:25.720 --> 00:14:30.490
And the second parameter is going to be the file which contains the data that is going to get copied

199
00:14:30.490 --> 00:14:31.480
into the first file.

200
00:14:31.750 --> 00:14:38.260
And here that are in the CPR basically stands for a recursive over here because it is going to be a

201
00:14:38.260 --> 00:14:39.250
recursive function.

202
00:14:39.580 --> 00:14:45.080
And at every line, one recursion is going to occur and it is going to copy the entire data.

203
00:14:45.520 --> 00:14:53.140
So so far you have learned how to manage files and folders in Ruby using building methods like reading,

204
00:14:53.140 --> 00:14:57.730
writing, and you have understood two other kind of things.

205
00:14:57.740 --> 00:14:58.840
That was the.

206
00:15:00.020 --> 00:15:04.340
Modules, which we have studies, the first module we study was the Pleyel module, then the second

207
00:15:04.340 --> 00:15:09.650
module, which was the desire that stands for the directory module, then the third module we have studied

208
00:15:09.860 --> 00:15:12.600
in this section was the Fylingdales module.

209
00:15:13.340 --> 00:15:17.390
So every module has its own use and its own importance.

210
00:15:17.780 --> 00:15:20.900
Now you can also get information about the file file.

211
00:15:20.900 --> 00:15:23.690
Handling often requires more than just opening files.

212
00:15:23.690 --> 00:15:28.400
Sometimes it is necessary to find out information about the file before it is open.

213
00:15:28.670 --> 00:15:32.720
Fortunately, the file class provides a range of methods for this very purpose.

214
00:15:32.750 --> 00:15:40.610
Now we have covered some of the methods before that are related to file module, but now we are going

215
00:15:40.610 --> 00:15:45.620
to cover more methods that are related to the file module and they are basically going to tell you more

216
00:15:45.620 --> 00:15:46.660
about the file.

217
00:15:47.030 --> 00:15:49.830
So you have already covered the exact function.

218
00:15:49.850 --> 00:15:53.200
The next function we are going to cover is the file function.

219
00:15:53.210 --> 00:15:59.060
Now to find out if the file is really a file as opposed to, for example, a directory uses the file

220
00:15:59.300 --> 00:15:59.760
method.

221
00:15:59.870 --> 00:16:05.240
So what you can do is that you can write and file, don't file a question mark.

222
00:16:05.240 --> 00:16:11.840
And in the parameters you have to write in, for example, if I just write and Rubio will.

223
00:16:13.840 --> 00:16:15.700
Store it in a variable X.

224
00:16:16.700 --> 00:16:21.890
All right, and put Sexo here on the scoreboard, you can see that it has generated for because now

225
00:16:21.890 --> 00:16:24.080
it is saying that it is basically not a file.

226
00:16:24.080 --> 00:16:32.000
If I just write and let's say rename the run this now, you can see that it has generated true because

227
00:16:32.000 --> 00:16:36.430
it is saying that whatever you are searching is basically a file.

228
00:16:36.560 --> 00:16:39.020
That's why it has generated Drew for me.

229
00:16:39.320 --> 00:16:44.930
Similarly, you can find out if it is directory with the directory method and that can also be done

230
00:16:44.930 --> 00:16:46.540
using the IRS.

231
00:16:46.540 --> 00:16:48.350
So I don't need to cover this.

232
00:16:48.800 --> 00:16:54.430
And the next is to identify whether the file is readable, writable or executable.

233
00:16:54.440 --> 00:17:01.160
You can use the readable, readable and executable methods respectively, for example, if you just

234
00:17:01.160 --> 00:17:02.510
remove this from here.

235
00:17:03.890 --> 00:17:09.170
And for example, for this file renamed, what do you want to check, if it is readable, it is writable

236
00:17:09.350 --> 00:17:13.100
or executable than what you can do is that you can use all these three methods.

237
00:17:13.340 --> 00:17:18.950
You can use the readable question mark on it, and you can see that it is generated through, which

238
00:17:18.950 --> 00:17:21.980
means that this file rename the is readable.

239
00:17:22.220 --> 00:17:25.640
Then you can also check if this file is writable or not.

240
00:17:25.640 --> 00:17:31.040
Run this and you can see that again, Drew has been generated, which means that this file is also readable.

241
00:17:31.310 --> 00:17:34.880
Then you can also see that this file is executable or not.

242
00:17:34.880 --> 00:17:36.710
For that, you have another function.

243
00:17:36.710 --> 00:17:40.420
And Ruby, that is XY Q Table.

244
00:17:40.430 --> 00:17:42.440
I hope I have spelled it correct.

245
00:17:42.450 --> 00:17:43.600
Yes, I guess I have.

246
00:17:44.090 --> 00:17:46.310
So no, no I have not.

247
00:17:46.550 --> 00:17:49.440
It is exceedingly perfect.

248
00:17:49.550 --> 00:17:54.110
Run this and it says false, which means that this file is not executable.

249
00:17:54.410 --> 00:18:00.110
Then you can also get the size of the file that you have to use the size function.

250
00:18:01.640 --> 00:18:03.660
Ron, this and zero is generated.

251
00:18:03.690 --> 00:18:06.180
Yes, I guess I covered this before as well.

252
00:18:06.540 --> 00:18:12.360
Then you have and if you want to find if a file is empty and you can do it with a zero method, for

253
00:18:12.360 --> 00:18:17.700
example, if you apply the zero method on this Oakhill renamed the Steve.

254
00:18:18.690 --> 00:18:24.000
Rhonda Scott, you know that it is going to generate true because we know that Brenham is empty, it

255
00:18:24.000 --> 00:18:25.540
contains nothing.

256
00:18:25.540 --> 00:18:27.840
So the zero method is going to return true on it.

257
00:18:28.170 --> 00:18:33.020
Then you can also find out the type of the file with the F type method.

258
00:18:33.300 --> 00:18:36.490
So what you can do is that you can just remove this from here.

259
00:18:36.510 --> 00:18:38.010
You can just write an F type.

260
00:18:38.010 --> 00:18:42.990
And if you just do it for renamed the extreme, run this code, you can see that it says that rhenium

261
00:18:43.710 --> 00:18:47.880
is basically a file and you can also do it like four directories.

262
00:18:47.910 --> 00:18:51.110
You can also do it for blocks, special and other things as well.

263
00:18:52.170 --> 00:18:59.640
Finally, you can find out the creation modification and access times of a file with the seed time and

264
00:18:59.640 --> 00:19:01.320
time and time, respectively.

265
00:19:02.540 --> 00:19:08.720
For example, if I use the time function for this renamed the exterior underscored, you can see that

266
00:19:08.720 --> 00:19:11.500
it is giving me the time when this file was created.

267
00:19:11.510 --> 00:19:16.940
So this file was created on twenty two for twenty twenty at seven forty six.

268
00:19:16.940 --> 00:19:20.540
Twenty one second plus zero five zero zero.

269
00:19:20.570 --> 00:19:26.510
So this was basically the creation time for this renamed to do, which you can get using the time function

270
00:19:26.510 --> 00:19:32.440
and by using the file module then you can also see the modification time as well.

271
00:19:32.460 --> 00:19:36.380
For that you have to just replace the C with M run this.

272
00:19:39.050 --> 00:19:46.040
All right, it has generated, I guess, defriended, that is twenty three for twenty twenty twenty

273
00:19:46.040 --> 00:19:46.280
five.

274
00:19:46.280 --> 00:19:46.790
Forty one.

275
00:19:46.790 --> 00:19:50.960
That is I guess the run time or I guess it is not.

276
00:19:51.710 --> 00:19:52.100
All right.

277
00:19:52.100 --> 00:19:54.980
It is, I guess, the time when this flight was renamed.

278
00:19:54.980 --> 00:19:55.430
I guess.

279
00:19:55.760 --> 00:20:02.750
So then you have this a function that is going to check if a file has been accessed.

280
00:20:03.200 --> 00:20:07.490
So it is going to tell you the time the file was last accessed on this.

281
00:20:09.080 --> 00:20:14.390
And it is going to, again, generate the time, that is the time for which this file was lost access.

282
00:20:14.690 --> 00:20:21.770
So these are the multiple methods that are related to the file module, which you can use to know more

283
00:20:21.770 --> 00:20:23.630
about the file you are working at.

284
00:20:23.660 --> 00:20:29.360
You can know more about the directory using the IRS module and you can have the file utils module for

285
00:20:29.360 --> 00:20:31.560
you, which is always available for you as well.

286
00:20:31.580 --> 00:20:37.550
So these are some of the functions or you can call the methods that can be used with files that are

287
00:20:37.550 --> 00:20:39.650
very, very, very useful.

288
00:20:40.070 --> 00:20:42.880
So I hope you understood all these functions.

289
00:20:42.890 --> 00:20:44.810
So I guess that's it with this tutorial as well.

290
00:20:44.840 --> 00:20:48.620
Thank you so much for watching and I'll see you guys in the next tutorial.
