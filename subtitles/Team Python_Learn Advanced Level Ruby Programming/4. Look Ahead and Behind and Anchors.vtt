WEBVTT
1
00:00:00.330 --> 00:00:01.290
Hey, guys, what's up?

2
00:00:01.320 --> 00:00:04.770
This is a marathon, and I welcome you to another tutorial on this course on Ruby.

3
00:00:04.780 --> 00:00:08.430
And in this studio, we are going to continue on with the regular expression.

4
00:00:08.430 --> 00:00:13.790
And in this story, we will cover two main topics that are related to regular expression.

5
00:00:13.800 --> 00:00:16.590
The first topic is the look ahead and look behind concept.

6
00:00:16.830 --> 00:00:23.700
And secondly, we are going to cover about anchors, which can be used with regular expressions as well.

7
00:00:24.090 --> 00:00:27.540
So starting on with the first topic, that is look ahead and look behind.

8
00:00:27.540 --> 00:00:33.450
Now, this is a more advanced technique that might not be available in all the regular expression implementations.

9
00:00:34.390 --> 00:00:39.720
Ruby, regular expression engine is able to do this, so let's see how to take advantage of that.

10
00:00:40.120 --> 00:00:47.380
So let's just move on and let us speak and see if there is a specific match before or after.

11
00:00:47.420 --> 00:00:52.030
Now, these are basically the four kind of look ahead and look behind which you can use.

12
00:00:52.490 --> 00:00:55.630
The first one is something like a question mark, then an equal design.

13
00:00:55.630 --> 00:00:56.980
Then you're right in the pattern.

14
00:00:57.340 --> 00:00:59.800
And that is known as a positive look ahead.

15
00:01:00.040 --> 00:01:02.950
Then you have a question mark with a less than sine.

16
00:01:02.950 --> 00:01:07.780
Then you have this equal design and the pattern and this is known as the positive look behind.

17
00:01:08.140 --> 00:01:14.890
Then you have this question mark, negation, mark Bacterin and inherit basically that is known as the

18
00:01:14.890 --> 00:01:15.790
negative look behind.

19
00:01:15.790 --> 00:01:20.450
And it is basically opt in by only just changing this equal do with this negation mark.

20
00:01:20.500 --> 00:01:24.940
And similarly, if you just change this equal to with a negation mark, as you can see right over here,

21
00:01:24.940 --> 00:01:27.920
that is known as a negative look behind, which was positive.

22
00:01:27.940 --> 00:01:29.730
Look behind with this equal to Mark.

23
00:01:30.070 --> 00:01:35.200
So let's see some example for how I look ahead and look behind.

24
00:01:35.200 --> 00:01:39.370
Concepts can be implemented with your.

25
00:01:40.820 --> 00:01:42.680
Ed, so let's move on to Adam.

26
00:01:44.200 --> 00:01:52.000
And we will see some examples, so let's see if there is a number that is preceded by at least one letter

27
00:01:52.000 --> 00:01:52.410
or not.

28
00:01:52.720 --> 00:01:57.100
So what we are going to do is that we are going to create a function.

29
00:01:58.530 --> 00:02:01.050
So we are going to send him the function as X.

30
00:02:07.000 --> 00:02:11.530
And we are going to just specify a question mark so that this method returns either true or false.

31
00:02:11.680 --> 00:02:19.600
And this over here is going to receive a string and whatever it is, since it is going to return a string.

32
00:02:20.050 --> 00:02:24.370
So sorry, not a string, but it is going to return a boolean value, either true or false or whatever

33
00:02:24.370 --> 00:02:25.900
is going to be received in this ring.

34
00:02:25.930 --> 00:02:28.840
We are going to convert it into a boolean value.

35
00:02:29.170 --> 00:02:31.360
And you know how this is.

36
00:02:32.160 --> 00:02:34.540
We had already covered that in the previous tutorial.

37
00:02:34.540 --> 00:02:39.460
You know, that this basically converts whatever will be written over here in a boolean value, which

38
00:02:39.460 --> 00:02:42.160
will be either true or it will be either false.

39
00:02:42.520 --> 00:02:44.730
So here we are going to initialize a string.

40
00:02:44.860 --> 00:02:48.180
So we are going to check the string with a pattern over here.

41
00:02:48.190 --> 00:02:50.500
So we are going to specify that pattern over here.

42
00:02:50.920 --> 00:02:57.760
Now, what we are going to do, use Ohare, is that we are going to use the positive look behind thing

43
00:02:57.760 --> 00:03:02.320
over here, which means that we are going to write in Questionmark Lesbian Sine and Equal to Signable

44
00:03:02.320 --> 00:03:02.650
Hill.

45
00:03:04.230 --> 00:03:09.720
So here we are going to write in this index for the regular expression and in here what we are going

46
00:03:09.720 --> 00:03:13.710
to write in, we are going to write in the questionmark, then we are going to write in the less than

47
00:03:13.710 --> 00:03:15.240
sign and then the equal to sign.

48
00:03:15.450 --> 00:03:20.490
And that is what is basically called as the positive look behind.

49
00:03:20.940 --> 00:03:25.560
And then in the Syntex, as you have seen, that we have to then write in the pattern.

50
00:03:25.570 --> 00:03:28.170
So let's say the pattern is this oakhill.

51
00:03:30.230 --> 00:03:36.200
And we can specify a more veterans of war here, so let's say we also have the de Blasio here.

52
00:03:37.780 --> 00:03:42.760
All right, so this means that we are going to pass in two string's because we have got two brackets

53
00:03:42.760 --> 00:03:50.200
in the regular expressions index, so let's just end dysfunctional here and we are going to call in

54
00:03:50.200 --> 00:03:58.070
the function X and we are going to pass in the parameters that is, let's say.

55
00:04:00.910 --> 00:04:06.280
And we are going to let slip us in 99, so what this is going to do is that it is going to check if

56
00:04:06.280 --> 00:04:10.460
there is a number that is preceded by at least one letter or not.

57
00:04:10.810 --> 00:04:14.770
So if you just run this code or edit, run perfectly.

58
00:04:14.770 --> 00:04:21.040
Now, all you need to do is just write in votes and it in brackets or help run this now.

59
00:04:21.340 --> 00:04:25.120
And you can see that it has generated the true value.

60
00:04:25.270 --> 00:04:28.690
So that is basically known as the positive look behind.

61
00:04:30.510 --> 00:04:35.940
Then comes the concept of the Ruby regular expression class, not the regular regular expressions are

62
00:04:35.940 --> 00:04:39.030
basically instances of the regular expression class.

63
00:04:39.040 --> 00:04:44.250
Most of the time you won't be using this class directly, but it is good to know that you have this

64
00:04:44.250 --> 00:04:46.340
class in Ruby.

65
00:04:46.680 --> 00:04:52.710
So if you just remove this from here and if you just want to know the class for that, so you just ride

66
00:04:52.710 --> 00:04:59.700
in this anything, go hell and you just ride in Dorte Class Wahib or underscored and you can see that

67
00:04:59.700 --> 00:05:05.280
it has generated regular expression, which means that a class that is known as regular expression basically

68
00:05:05.280 --> 00:05:05.810
exists.

69
00:05:05.970 --> 00:05:09.820
Now, one possible use is to create a regular expression from a string.

70
00:05:10.020 --> 00:05:12.480
So if you just write an.

71
00:05:14.540 --> 00:05:19.940
Regular expression equal to RTG XP now.

72
00:05:21.080 --> 00:05:27.140
We already have covered certain things, so this is basically O'Haire a module, so here we are going

73
00:05:27.140 --> 00:05:33.770
to be using a module and we and using this over here, we are going to create a regular expression.

74
00:05:33.770 --> 00:05:38.240
So you can just right now, in the previous case, you know that the syntax for regular expression is

75
00:05:38.240 --> 00:05:38.960
something like this.

76
00:05:38.960 --> 00:05:40.600
And you have to write in this area here.

77
00:05:40.970 --> 00:05:45.380
But if you are using the regular expression class, then what you can do is that you can write in regular

78
00:05:45.380 --> 00:05:51.440
expression, which is a module of the regular expression class dot new, and then you can specify whatever

79
00:05:51.440 --> 00:05:57.770
is going to be in between right over here in these quotation marks over here.

80
00:05:57.770 --> 00:06:00.260
You don't have to specify those slashes or help.

81
00:06:01.550 --> 00:06:08.600
So that is also going to do your job, so if you just ride in boats are speed dot glasspool, he'll

82
00:06:08.660 --> 00:06:09.400
run the school.

83
00:06:09.440 --> 00:06:12.350
You can see that it has also generated the very same result.

84
00:06:12.350 --> 00:06:18.750
That is a regular expression, which means that this area here is a regular expression.

85
00:06:19.160 --> 00:06:24.740
Now, another way to create a regular expression can be using the person, each module.

86
00:06:25.080 --> 00:06:27.430
So we just remove it from home.

87
00:06:30.230 --> 00:06:34.280
And we'll hear what we are going to write and we are going to write in person at.

88
00:06:37.300 --> 00:06:43.570
Ah, and then you can specify these curly brackets of a hair that basically stands for a lock, and

89
00:06:43.570 --> 00:06:48.740
in here you can specify any kind of pattern of words, let's say is the pattern.

90
00:06:49.120 --> 00:06:50.830
Now, if you just write in votes.

91
00:06:52.880 --> 00:06:59.540
E expired last will here on the score, and again, it is going to generate regular expression.

92
00:06:59.550 --> 00:07:05.390
So these are basically some of the ways in which you can initialize regular expressions and really know

93
00:07:05.390 --> 00:07:08.390
how to basically format long, regular expression.

94
00:07:08.420 --> 00:07:14.450
Now, complex ruby, regular expression can get pretty hard to read, so it will be helpful if you break

95
00:07:14.450 --> 00:07:15.630
them into multiple lines.

96
00:07:15.860 --> 00:07:21.350
Now we can do them by using the X modifier, which you have already covered in explanation.

97
00:07:21.350 --> 00:07:27.140
But now this format also allows you to use comments inside your regular expression.

98
00:07:28.450 --> 00:07:34.210
So to give you a very quick example for that, we will just remove this from here.

99
00:07:35.190 --> 00:07:40.260
And we will just create a log format of Ohio, so we are going to write in log format and we are going

100
00:07:40.260 --> 00:07:44.970
to make it equal to per cent R, which means that we are using the third Syntex.

101
00:07:45.000 --> 00:07:49.410
Well, then you have to specify these brackets to Hill.

102
00:07:51.630 --> 00:07:56.330
Now, in between, what you can do is that you can just ride in anything or help.

103
00:07:56.680 --> 00:08:01.530
Now, in the previous guests, you were not allowed to basically use commands.

104
00:08:01.530 --> 00:08:07.590
For example, if if you were using, let's say, this index over here and if you just specify a hashtag

105
00:08:07.590 --> 00:08:12.180
ÁLFHEIÐUR, so you can see that it has not been converted into the regular, which means that it is

106
00:08:12.180 --> 00:08:14.130
not being treated as a command for now.

107
00:08:14.550 --> 00:08:22.770
So you cannot basically use the regular Astarita command spot with this index, nor can you do it with

108
00:08:22.770 --> 00:08:23.880
the new one.

109
00:08:23.910 --> 00:08:29.760
So if you just ride in, let's say hashtag AOL, so you can see that it has also converted this bracket

110
00:08:29.760 --> 00:08:33.000
over here into a command, which is exactly what you don't want.

111
00:08:33.330 --> 00:08:40.370
So basically these two syntaxes are just not able to help you out with the comments.

112
00:08:40.380 --> 00:08:46.920
Moreover, they are also not helpful in creating multi-line or you can say the complex regular expression

113
00:08:46.920 --> 00:08:50.890
you can create, but that is going to be very difficult to read.

114
00:08:50.930 --> 00:08:57.360
So the best thing is to break down the complex regular expression into several lines so that it is easier

115
00:08:57.360 --> 00:08:57.810
to understand.

116
00:08:57.810 --> 00:09:04.360
And moreover, this syntax or press center is also going to allow you to add comments about him.

117
00:09:04.650 --> 00:09:10.320
So let's say if you just remember the example where we were using the time, the time and message,

118
00:09:10.530 --> 00:09:15.580
then you know that that was a very long line and it was a very complex right over there.

119
00:09:15.720 --> 00:09:19.920
So what you can do over here is that you can just simplify it as.

120
00:09:22.970 --> 00:09:29.210
Backslash deep and in the bracket, if you just remember, you had written to then that was for the

121
00:09:29.210 --> 00:09:33.280
Rs and then you have to do this very same for the minutes.

122
00:09:34.960 --> 00:09:41.320
Now, what you can do is that you can simply just come out of these brackets, Abargil.

123
00:09:42.580 --> 00:09:43.830
And what you can do.

124
00:09:44.970 --> 00:09:50.220
What you can do here is that you can just use a comment, so let's say we can just dive in the comments

125
00:09:50.220 --> 00:09:51.450
that this is basically time.

126
00:09:52.320 --> 00:09:58.920
What we have missed over here is that these should be the curly brackets, not these around brackets.

127
00:09:58.920 --> 00:10:01.200
So this should be converted into the curly brackets.

128
00:10:01.650 --> 00:10:04.530
And I guess that's good enough.

129
00:10:06.080 --> 00:10:08.330
And yes, we also have to.

130
00:10:09.940 --> 00:10:13.990
I guess there is some problem with, I guess, the condition of warheads.

131
00:10:14.020 --> 00:10:15.700
That's why it is not treating this as a command.

132
00:10:15.700 --> 00:10:17.820
So let's just create this over here again.

133
00:10:18.280 --> 00:10:21.490
So we will just copy this.

134
00:10:22.320 --> 00:10:26.880
And we will just remove this from here and we will create this stuff over here again, so we are going

135
00:10:26.880 --> 00:10:33.390
to write in percentage are these brackets click, enter and just press control.

136
00:10:33.440 --> 00:10:35.490
We and I guess that's good enough.

137
00:10:35.490 --> 00:10:37.890
And now you can just ride in hashtag.

138
00:10:38.890 --> 00:10:39.370
Dayme.

139
00:10:41.940 --> 00:10:44.690
So you can just move it to a new line as well.

140
00:10:48.740 --> 00:10:54.440
Just click, enter, and now you can just create your second one that was about the type, so you can

141
00:10:54.440 --> 00:11:00.860
just write in backslash s and then you can just write in backslash W plus over hill.

142
00:11:01.460 --> 00:11:05.060
And that is basically what is type.

143
00:11:07.680 --> 00:11:12.450
And then finally, you have the message which you had initialised using the dot starick operator, so

144
00:11:12.450 --> 00:11:13.810
you can just do it like that.

145
00:11:14.200 --> 00:11:18.960
Now, that is the very same thing we already have covered in the previous tutorial.

146
00:11:18.960 --> 00:11:21.990
But in this you can see that it is much more organized.

147
00:11:21.990 --> 00:11:23.480
You can just have comments.

148
00:11:23.910 --> 00:11:29.730
And the reason I get these comments are not just showing up is because I guess we have got some identifying

149
00:11:29.730 --> 00:11:30.090
problem.

150
00:11:30.090 --> 00:11:33.730
If you just rewrite this whole thing over here again, it is surely going to work out.

151
00:11:34.260 --> 00:11:38.610
So this is basically the useful thing about the syntax or.

152
00:11:39.720 --> 00:11:47.280
Now then comes some regular expression functions, which you can use and they are basically going to

153
00:11:47.490 --> 00:11:51.060
aid you along with regular expressions.

154
00:11:51.330 --> 00:11:54.780
So regular expressions can be used with many methods.

155
00:11:54.810 --> 00:11:56.180
The first one is a split method.

156
00:11:56.190 --> 00:11:59.720
Then we have the scan method and then we have the up and many more method.

157
00:12:00.120 --> 00:12:02.860
So let's see an example of all those.

158
00:12:03.090 --> 00:12:08.670
So just remove this from here and you can just try a rewrite it and it is surely going to work.

159
00:12:10.280 --> 00:12:15.890
So let's say you want to match all words from a string using the let's say the scan function, that

160
00:12:15.890 --> 00:12:16.940
was the first function.

161
00:12:17.420 --> 00:12:20.970
So what we are going to do is that we are going to create a string.

162
00:12:20.990 --> 00:12:23.360
Let's say we say this is a.

163
00:12:24.850 --> 00:12:28.900
String and we write in DOT scan.

164
00:12:35.830 --> 00:12:42.280
And we were just right in, let's say, W plus over here, and these are the closing ones for the regular

165
00:12:42.280 --> 00:12:42.910
expression.

166
00:12:43.630 --> 00:12:51.910
And if we just run this code and it's from perfectly, let's just store it in a variable and just.

167
00:12:51.910 --> 00:12:52.150
Right.

168
00:12:52.150 --> 00:12:54.040
And put six over here now run it.

169
00:12:54.040 --> 00:12:56.590
And you can see that it says this is our.

170
00:12:57.040 --> 00:13:03.580
So what it's going on over here is that we have matched all the words from a string using this method.

171
00:13:03.590 --> 00:13:10.720
So it is going to scan the entire string and it is going to search word by word and it is going to print

172
00:13:10.720 --> 00:13:13.890
each letter of a string in a separate line.

173
00:13:13.900 --> 00:13:18.760
So that's what this is in a single line is is in a single line, is in a single line and string is also

174
00:13:18.760 --> 00:13:19.680
in the single line.

175
00:13:19.960 --> 00:13:26.590
So that is how you can use a scan function with Ruby regular expression, then you can use the scan

176
00:13:26.590 --> 00:13:31.990
method to extract all the numbers from a string as well, so that what you can do is, for example,

177
00:13:31.990 --> 00:13:36.100
you can just write and this is number one, two, three, four, five.

178
00:13:36.100 --> 00:13:38.860
Let's say you have got this number here.

179
00:13:39.850 --> 00:13:40.280
All right.

180
00:13:40.380 --> 00:13:44.050
Does it got printed number one, two, three, four or five?

181
00:13:44.470 --> 00:13:50.700
And you can instead of this W plus what you can do is that you can just write and D plus.

182
00:13:51.250 --> 00:13:55.750
So if you just run the score, you can see that you have got one, two, three, four or five.

183
00:13:55.750 --> 00:13:59.610
So that was how to basically extract all the numbers from a string.

184
00:13:59.620 --> 00:14:03.910
So it is going to scan this entire string.

185
00:14:04.030 --> 00:14:09.160
But since we have ridi plus and you know that the plus is for the range from zero to nine, so it is

186
00:14:09.160 --> 00:14:12.910
going to search for anything that is from zero to nine in between the string.

187
00:14:12.930 --> 00:14:14.650
So it found this over here.

188
00:14:14.650 --> 00:14:15.700
That is one, two, three, four, five.

189
00:14:15.710 --> 00:14:20.860
So it is going to just bring it out, store it in this variable X, and when you try and put sex over

190
00:14:20.870 --> 00:14:22.240
here, it is going to print it out.

191
00:14:23.640 --> 00:14:28.410
Then you can use the Jesus method to capitalize all words in a string.

192
00:14:28.470 --> 00:14:33.270
So let's say you have the string that is X equal to the stuff over here.

193
00:14:33.280 --> 00:14:37.620
So you can just write in the Jesus O'Haire.

194
00:14:39.530 --> 00:14:44.480
And what you can do over here is that you have to first tell it that what you are basically referring

195
00:14:44.480 --> 00:14:51.290
to, so we will just convert it back into a strength so that we can use WOFL.

196
00:14:52.400 --> 00:14:56.990
So we are going to ride in the regular expression Centex and we are going to ride in a wild.

197
00:14:58.790 --> 00:15:04.120
Then what you are going to do is that you are going to specify the these brackets actually brackets

198
00:15:04.130 --> 00:15:09.800
over here and you are going to specify the bars over here, which means that now we want something to

199
00:15:09.800 --> 00:15:11.020
go word by word.

200
00:15:11.030 --> 00:15:17.420
So we are going to just write in a variable over here and we are going to write in w dot capitalize.

201
00:15:19.140 --> 00:15:25.080
So what this is going to do is that it is going to grab one word at a time from this stranglehold.

202
00:15:26.250 --> 00:15:33.780
And it is going to capitalize it and the loop is going to keep on trading for all the numbers or whatever

203
00:15:33.780 --> 00:15:35.390
is in between this range.

204
00:15:35.400 --> 00:15:40.860
So, you know, what is in between this range and if that is a part of this string as well, then it

205
00:15:40.860 --> 00:15:42.400
is going to capitalize that.

206
00:15:42.750 --> 00:15:45.150
So if you just run this.

207
00:15:46.440 --> 00:15:54.030
All right, it says that we have got some kind of error that says capitalized is not a method, I guess

208
00:15:54.030 --> 00:15:58.240
we have misspelled it is to see it the eyes.

209
00:15:58.470 --> 00:15:59.510
I guess that's good enough.

210
00:15:59.520 --> 00:16:00.150
Now run it.

211
00:16:00.390 --> 00:16:07.380
And you can see that it has now just printed out our string and it has printed the first letter to be

212
00:16:07.380 --> 00:16:07.780
capital.

213
00:16:07.800 --> 00:16:13.830
You can see that this is capital and its capital is capital and its capital because w for the first

214
00:16:13.830 --> 00:16:18.240
iteration is going to have this and it is going to capitalize the first letter of that, then it is

215
00:16:18.240 --> 00:16:24.080
going to have the is word, then it is going to capitalize this Iowa here then for the third address

216
00:16:24.100 --> 00:16:25.620
and it is going to store in it.

217
00:16:25.620 --> 00:16:31.080
And since it is a single character, so it is going to capitalize is simply the new in the last iteration,

218
00:16:31.080 --> 00:16:34.740
it is going to have string and it is going to capitalize this as Oakhill.

219
00:16:36.110 --> 00:16:41.070
Then you can also validate an email address using the match function.

220
00:16:41.390 --> 00:16:45.770
So how that is going to be done, what you are going to do is that you are going to write in an e-mail

221
00:16:45.770 --> 00:16:46.570
address over here.

222
00:16:46.970 --> 00:16:50.720
So let's say you just write in, let's say test.

223
00:16:51.870 --> 00:16:53.160
At the rate of.

224
00:16:54.260 --> 00:16:55.880
Let's say Yahoo!

225
00:16:55.880 --> 00:16:56.480
Dot com.

226
00:16:57.110 --> 00:17:00.030
So let's say this is some kind of e-mail address of a hill.

227
00:17:00.530 --> 00:17:05.750
Now where you're going to do is that you are going to convert whatever is going to get matched with

228
00:17:05.750 --> 00:17:06.950
this into a boolean value.

229
00:17:06.960 --> 00:17:08.630
So if it is true, it is going to return.

230
00:17:08.630 --> 00:17:08.880
True.

231
00:17:08.900 --> 00:17:10.750
And if it is not, it is going to return false.

232
00:17:10.780 --> 00:17:16.820
So we are going to write in to an addition signs over here and we are going to write an e-mail dot match.

233
00:17:18.620 --> 00:17:25.250
And in here, we are going to specify all things one by one, so what we are going to do is that we

234
00:17:25.250 --> 00:17:27.980
are going to specify this index for regular expression.

235
00:17:27.980 --> 00:17:34.670
And in between this, we are going to first specify our capital here, which means that we want to include

236
00:17:34.670 --> 00:17:43.160
almost everything that is from A to Z and also from small to small that then you can just write and

237
00:17:44.180 --> 00:17:48.200
here backslash w dot.

238
00:17:50.000 --> 00:17:58.830
Plus minus and outside this, what you can do is that you can just ride and plus at the rate of backslash

239
00:17:58.850 --> 00:17:59.720
W plus.

240
00:18:01.980 --> 00:18:04.410
Escaping the dot then plus.

241
00:18:05.920 --> 00:18:12.500
And then on this Zadow Hill and finally, just close this, so if you just store it in a variable,

242
00:18:12.500 --> 00:18:14.590
let's say X is that variable.

243
00:18:16.240 --> 00:18:21.170
And it just right and put sex over here underscore, you can see that it has generated Jewel here.

244
00:18:21.190 --> 00:18:27.330
So what's going on over here is basically this part of a hill is going to check this value over here.

245
00:18:27.860 --> 00:18:30.490
Then this part of a hill.

246
00:18:32.630 --> 00:18:39.560
Is basically going to check this value and finally, this part of a hill is going to get checked in

247
00:18:39.560 --> 00:18:40.980
by this valuable hill.

248
00:18:41.390 --> 00:18:44.920
So all the values since are perfect.

249
00:18:44.930 --> 00:18:46.250
It is a perfect e-mail address.

250
00:18:46.250 --> 00:18:48.320
So that's why it is going to simply generate.

251
00:18:49.400 --> 00:18:53.370
So let's see if you have an invalid e-mail address, you just remove the dot from here.

252
00:18:53.370 --> 00:18:58.010
You run the school, you can see that it has generated calls because you have used this Ohare, so it

253
00:18:58.010 --> 00:18:59.370
should have a daughter here.

254
00:18:59.810 --> 00:19:03.350
Similarly, if you just write and let's say nothing after this.

255
00:19:04.630 --> 00:19:08.500
Now, run the school, you can see that it has again generated false if you just write an achievement,

256
00:19:08.500 --> 00:19:10.520
O'Haire underscored, it is going to generate.

257
00:19:11.200 --> 00:19:15.090
So if you just remove this aderet from here, run this, it is again going to generate false.

258
00:19:15.090 --> 00:19:21.310
So if you just do anything that makes it an invalid email address, then it is going to generate false.

259
00:19:21.340 --> 00:19:26.480
So this example basically uses the exclamation exclamation to convert our result into a ball in value.

260
00:19:26.500 --> 00:19:27.140
True or false?

261
00:19:27.460 --> 00:19:33.010
Alternatively, you can use the match method and Ruby two point four plus, which already does this

262
00:19:33.010 --> 00:19:33.580
for you.

263
00:19:33.850 --> 00:19:36.130
And it is also very, very, very fast.

264
00:19:36.550 --> 00:19:42.100
So these are basically some of the methods that you can use on with a regular expression and they are

265
00:19:42.100 --> 00:19:45.670
going to basically aid you in using regular expression.

266
00:19:46.620 --> 00:19:50.160
Then comes the second part of this tutorial that deals with anger.

267
00:19:50.190 --> 00:19:57.260
So these are some of the anchors which you can use in really the first one is the some kind of poverty

268
00:19:57.270 --> 00:19:57.960
line, I guess.

269
00:19:57.960 --> 00:20:00.510
And you have already covered that in the previous tutorial.

270
00:20:00.510 --> 00:20:03.240
And you know that it is used for matching the beginning of a line.

271
00:20:03.260 --> 00:20:07.620
Then you have the dollar sign, which you already have covered in the previous tutorial as well, that

272
00:20:07.620 --> 00:20:10.100
is used for matching the end of the line.

273
00:20:10.110 --> 00:20:15.000
Then you have backslash here, which you just use that is used for matching beginning of a string.

274
00:20:15.490 --> 00:20:20.490
Then you have the backslash capital that that matches the end of the string, then backslash small that

275
00:20:20.490 --> 00:20:21.930
that matches the end of the string.

276
00:20:21.930 --> 00:20:27.960
And I guess you have used all of these, I guess just skipping the last three.

277
00:20:27.960 --> 00:20:34.620
You have used the top all three of all six of those then backslash gee what capital G that matches the

278
00:20:34.620 --> 00:20:40.920
first matching position then backslash B that matches the word boundaries when outside brackets and

279
00:20:40.920 --> 00:20:46.680
then finally backslash capital B that matches the non word boundaries.

280
00:20:48.880 --> 00:20:55.930
So in methods like String Gizab and String Skåne, which you already have covered, it changes on each

281
00:20:55.930 --> 00:20:56.560
iteration.

282
00:20:56.830 --> 00:21:02.950
Now it initially matches the beginning of the subject and in each iteration, it matches where the last

283
00:21:02.950 --> 00:21:04.270
match is finished.

284
00:21:04.760 --> 00:21:09.490
So you can just use all these anchors with the GST and the match functions as well.

285
00:21:09.520 --> 00:21:13.800
So let me give you, I guess, one more example of this and then we will get on with this tutorial.

286
00:21:14.200 --> 00:21:17.230
So let's say if you just remove this from here.

287
00:21:20.600 --> 00:21:24.050
And you let's just write in a B.

288
00:21:26.750 --> 00:21:30.530
And see over here and you use the Jezebel here.

289
00:21:32.990 --> 00:21:38.780
And in the brackets, you just specify regular expression and you just write and nothing over here,

290
00:21:38.780 --> 00:21:45.740
a comma, and then what you're going to write and you are going to write an underscore or help.

291
00:21:47.030 --> 00:21:49.550
So if you just store it in a variable X.

292
00:21:50.650 --> 00:21:55.870
Rhonda, as you can see that it says A, underscore B, underscore C. So what this is basically that

293
00:21:55.870 --> 00:22:01.030
the GSA is accepting a second argument that is going to get placed in all of this, which means that

294
00:22:01.030 --> 00:22:06.670
it is basically going to be a Connector's now in regular expression methods like match.

295
00:22:07.570 --> 00:22:12.680
You can also use the offset, which is going to do your jobs as well.

296
00:22:12.700 --> 00:22:16.330
So if you just remove this from here and you write and.

297
00:22:18.120 --> 00:22:22.230
Hello, world of a hill, and you use the match method now.

298
00:22:24.630 --> 00:22:32.910
And for that, let's just specify a comma here and then you specify since, let's say just three Woodhill.

299
00:22:34.430 --> 00:22:38.460
And you run this code, you can see that it says a comma here.

300
00:22:38.990 --> 00:22:48.470
So the reason behind this is that it has basically using that as an optional offset where it is going

301
00:22:48.470 --> 00:22:49.920
to match where the search begins.

302
00:22:50.300 --> 00:22:58.630
So that's how basically all of these methods can be used in Ruby over here with regular expressions.

303
00:22:58.640 --> 00:23:02.500
So I hope you have understood the usage of all these functions as well as anchors.

304
00:23:02.510 --> 00:23:04.100
So I guess that's it with this tutorial.

305
00:23:04.100 --> 00:23:05.540
Thank you so much for watching.

306
00:23:05.780 --> 00:23:07.880
And I'll see you guys in the next Attrill.
