WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.690
in this.

00:00:01.690 --> 00:00:02.150
Listen,

00:00:02.150 --> 00:00:06.760
let's see some of the very useful tricks that can be applied on list.

00:00:06.760 --> 00:00:10.300
Number one to start with is called list comprehension.

00:00:10.300 --> 00:00:15.390
Consider you have a list off numbers,

00:00:15.390 --> 00:00:18.100
which is a bunch of random on the level tape here.

00:00:18.100 --> 00:00:22.270
Support.

00:00:22.270 --> 00:00:25.280
I want to get a list off all these numbers,

00:00:25.280 --> 00:00:27.310
but in its A square format,

00:00:27.310 --> 00:00:28.340
for example,

00:00:28.340 --> 00:00:33.830
I want square off 10 square of 40 square of five and so on in another list.

00:00:33.830 --> 00:00:35.050
How would you do that?

00:00:35.050 --> 00:00:35.780
So,

00:00:35.780 --> 00:00:36.450
generally,

00:00:36.450 --> 00:00:37.970
in any other programming language,

00:00:37.970 --> 00:00:41.610
you probably use a squares equals toe a new list,

00:00:41.610 --> 00:00:44.700
and then it's therefore end in numbs.

00:00:44.700 --> 00:00:51.870
I didn't say Hear screams start upended and do that So enter.

00:00:51.870 --> 00:00:52.170
And now,

00:00:52.170 --> 00:00:52.500
of course,

00:00:52.500 --> 00:00:53.630
if I say squares,

00:00:53.630 --> 00:00:58.370
you will see that we have a square off each of the numbers presenting the lambs.

00:00:58.370 --> 00:00:58.870
But here,

00:00:58.870 --> 00:00:59.260
literally,

00:00:59.260 --> 00:01:06.080
we're using a loop that runs over each element and then doing some work.

00:01:06.080 --> 00:01:11.550
So this might be a little time consuming because Britain is an interpreted language

00:01:11.550 --> 00:01:13.120
ultimately,

00:01:13.120 --> 00:01:15.630
by done towards a very simple mechanism off,

00:01:15.630 --> 00:01:23.010
creating a new list on asking the new list operator itself to do the square and the way you

00:01:23.010 --> 00:01:25.590
can do these squibs equals toe.

00:01:25.590 --> 00:01:30.850
You create a new list by starting with the square record operator and then you say You're

00:01:30.850 --> 00:01:39.280
for in in Numbs Now this actually gets all the values as ease and then constructs a new

00:01:39.280 --> 00:01:39.770
list.

00:01:39.770 --> 00:01:46.220
But all you have to do is tow go behind this particular far and then write and star.

00:01:46.220 --> 00:01:53.310
And so you can read it like create a new list where you have the end store and for n in

00:01:53.310 --> 00:01:53.760
numbs.

00:01:53.760 --> 00:01:57.540
So we can say that for every ending NMS return.

00:01:57.540 --> 00:01:58.420
And in the end,

00:01:58.420 --> 00:02:00.350
over here you have endo.

00:02:00.350 --> 00:02:00.760
No,

00:02:00.760 --> 00:02:02.570
we have the exact same difference,

00:02:02.570 --> 00:02:03.900
like the previous one,

00:02:03.900 --> 00:02:07.530
but without using the actual foretell.

00:02:07.530 --> 00:02:10.400
So we didn't have to do an iteration here.

00:02:10.400 --> 00:02:11.820
Let's take another example.

00:02:11.820 --> 00:02:16.110
Let me clear the screen names equals toe a bunch of names,

00:02:16.110 --> 00:02:22.250
someone purely note pushing on conditional now support.

00:02:22.250 --> 00:02:25.200
If you want to convert this list in tow,

00:02:25.200 --> 00:02:29.090
list off uppercase to abortions so you can use names,

00:02:29.090 --> 00:02:31.640
equals two and then in script bracket,

00:02:31.640 --> 00:02:35.060
you can say here name are some variable,

00:02:35.060 --> 00:02:40.660
which is going to be representing one element off names at a time and then say your upper

00:02:40.660 --> 00:02:43.580
for name in names.

00:02:43.580 --> 00:02:45.620
That's ender Americans.

00:02:45.620 --> 00:02:47.680
The names contained the upper case.

00:02:47.680 --> 00:02:48.340
Washington off.

00:02:48.340 --> 00:02:53.490
The same couple of things you can observe here is that name is a new variable that you're

00:02:53.490 --> 00:02:56.510
declaring here for the for loop on,

00:02:56.510 --> 00:03:02.280
which actually picks up one element from this names and then the converted value.

00:03:02.280 --> 00:03:08.830
Here is the name that upper The ender list here is re ascent toe names.

00:03:08.830 --> 00:03:11.710
So we didn't have to create a different variable at all.

00:03:11.710 --> 00:03:13.210
Here is another example.

00:03:13.210 --> 00:03:16.030
Let's consider data reason,

00:03:16.030 --> 00:03:21.450
Ari off few numbers on a couple of non numeric funders.

00:03:21.450 --> 00:03:28.260
Let's they have your son non numeric value and some is dear,

00:03:28.260 --> 00:03:34.550
maybe I have your say 45 on and say Pick your orders.

00:03:34.550 --> 00:03:39.930
I suppose if I want this to be containing only numerical values,

00:03:39.930 --> 00:03:41.790
then how can we do that?

00:03:41.790 --> 00:03:50.270
So we can simply say here data equals two D for D in data and we can add any condition and

00:03:50.270 --> 00:03:52.400
only if that if condition is satisfied,

00:03:52.400 --> 00:04:01.850
then collected t so I can say here if type off day in probably int our float.

00:04:01.850 --> 00:04:07.170
If you carefully observed here the conditions is type off D.

00:04:07.170 --> 00:04:08.850
Where is some variable?

00:04:08.850 --> 00:04:12.670
Is it in the list off one off these two.

00:04:12.670 --> 00:04:15.010
So is it in this collection?

00:04:15.010 --> 00:04:16.710
So if the answer is yes,

00:04:16.710 --> 00:04:18.290
then D will be collected.

00:04:18.290 --> 00:04:19.350
Chief a press enter.

00:04:19.350 --> 00:04:27.530
Now you can see that ADA contains only 10 4 56 45 Omitting anything other than int and

00:04:27.530 --> 00:04:28.950
float variables.

00:04:28.950 --> 00:04:31.000
Let's extend this example.

00:04:31.000 --> 00:04:33.030
Toe are one more condition.

00:04:33.030 --> 00:04:35.650
Let's say data is equal.

00:04:35.650 --> 00:04:38.030
Stow taste with a few more values,

00:04:38.030 --> 00:04:44.650
Let's say 1234567 So there are some even values and our values.

00:04:44.650 --> 00:04:49.700
Suppose if we want toe create a new collection that contains only the even numbers in this

00:04:49.700 --> 00:04:50.740
particular collection.

00:04:50.740 --> 00:04:51.780
What I could do it.

00:04:51.780 --> 00:04:58.950
I can see here even knows a new variable equals took a new list off D.

00:04:58.950 --> 00:05:04.730
Where is a single element off this data for the in data,

00:05:04.730 --> 00:05:16.850
I can say if take off the in either in off float as the last D model is two equals toe zero

00:05:16.850 --> 00:05:19.380
so that it is an even number now,

00:05:19.380 --> 00:05:19.690
of course,

00:05:19.690 --> 00:05:21.760
if they even underscored numbs,

00:05:21.760 --> 00:05:27.130
we would get the even numbers from that excluding non numeric values.

00:05:27.130 --> 00:05:30.470
Sometimes we want to use the function some.

00:05:30.470 --> 00:05:35.450
So if I take this value and then say some off this list,

00:05:35.450 --> 00:05:39.090
you'll see that we get 82 which is the actual some off this.

00:05:39.090 --> 00:05:41.220
Let's so some in there global function,

00:05:41.220 --> 00:05:43.450
which calculates that some off element.

00:05:43.450 --> 00:05:46.370
But if I see some off data,

00:05:46.370 --> 00:05:53.360
you're gonna get an error because type at an unsupported operating for in on str somewhere

00:05:53.360 --> 00:05:53.360
.

00:05:53.360 --> 00:05:56.080
It has calculated to some off all these values.

00:05:56.080 --> 00:05:56.610
But then,

00:05:56.610 --> 00:05:59.830
when the result is being added toe,

00:05:59.830 --> 00:06:00.370
we note.

00:06:00.370 --> 00:06:06.430
So there's an int and the str and it says plus is not applicable for that combination.

00:06:06.430 --> 00:06:12.580
So this is where we may want to say that Give me only if that is an interpreter float.

00:06:12.580 --> 00:06:14.020
Then we want to calculate the sun.

00:06:14.020 --> 00:06:20.810
So what I can do that can just copied this section and then say you're some off this entire

00:06:20.810 --> 00:06:21.730
expression.

00:06:21.730 --> 00:06:25.170
Now we get the summer off numbers in that particular group,

00:06:25.170 --> 00:06:27.330
so use the list comprehension.

00:06:27.330 --> 00:06:32.810
When you want to convert a data off one type into data off another type,

00:06:32.810 --> 00:06:34.880
let's take one more example.

00:06:34.880 --> 00:06:36.510
This time I want toe,

00:06:36.510 --> 00:06:37.630
say people,

00:06:37.630 --> 00:06:40.110
is equal toe list,

00:06:40.110 --> 00:06:49.330
but a list off a few dictionaries were I have Your name on is we know City is bangle.

00:06:49.330 --> 00:06:52.780
I put a comma toe.

00:06:52.780 --> 00:06:53.850
Another dignity.

00:06:53.850 --> 00:06:55.190
That's a name.

00:06:55.190 --> 00:07:10.250
City Dallas One more big off name equals toe John Andi City equals toe newer.

00:07:10.250 --> 00:07:15.380
Now I closed the square bracket to say that this list is ended.

00:07:15.380 --> 00:07:16.750
Now you have people,

00:07:16.750 --> 00:07:19.330
which is a list off dictionaries.

00:07:19.330 --> 00:07:20.590
Let's check it out.

00:07:20.590 --> 00:07:22.170
People for center.

00:07:22.170 --> 00:07:24.780
We got a list off three dictionaries.

00:07:24.780 --> 00:07:30.270
Sometimes if I want only the names from this particular collection,

00:07:30.270 --> 00:07:33.080
I can simply say here names.

00:07:33.080 --> 00:07:39.180
It calls toe a new list and I can say p dot name for P in people.

00:07:39.180 --> 00:07:46.620
So we know that people is a list and I take one element from the list on that one element

00:07:46.620 --> 00:07:51.400
happens to be one dictionary and from the dictionary we want the name.

00:07:51.400 --> 00:07:52.010
Now,

00:07:52.010 --> 00:07:53.570
unlike other language is,

00:07:53.570 --> 00:07:57.140
the key values cannot be accessed using the thought operators.

00:07:57.140 --> 00:07:58.350
So that's my mistake.

00:07:58.350 --> 00:08:03.330
So I have to use your script record and the key indiscretion.

00:08:03.330 --> 00:08:04.920
So now off course,

00:08:04.920 --> 00:08:10.710
P off name is retired for every beat where everybody is a reduction early so from every

00:08:10.710 --> 00:08:11.300
dictionary.

00:08:11.300 --> 00:08:12.830
I'm collecting the names,

00:08:12.830 --> 00:08:14.850
and I will see I have your names,

00:08:14.850 --> 00:08:17.170
which is only the names of these people.

00:08:17.170 --> 00:08:18.590
So whenever you think off,

00:08:18.590 --> 00:08:21.560
converting a list off something in tow,

00:08:21.560 --> 00:08:25.030
a list of something else or filtering that list,

00:08:25.030 --> 00:08:27.560
I think off list comprehension.

00:08:27.560 --> 00:08:28.280
No,

00:08:28.280 --> 00:08:32.650
let's say some of the other cool stops that you can work with in a list.

00:08:32.650 --> 00:08:35.750
So whenever you have a list you want to do a reverse.

00:08:35.750 --> 00:08:38.300
Let's take this example off Mom's.

00:08:38.300 --> 00:08:40.700
I have these numbs Andi.

00:08:40.700 --> 00:08:42.440
I want toe reverse this.

00:08:42.440 --> 00:08:46.010
You can do it easily by typing RTV numbs,

00:08:46.010 --> 00:08:47.150
which is a new variable,

00:08:47.150 --> 00:08:49.230
equals two numbs,

00:08:49.230 --> 00:08:50.230
and then you say here,

00:08:50.230 --> 00:08:52.060
minus one is the step.

00:08:52.060 --> 00:08:52.830
Now,

00:08:52.830 --> 00:08:54.850
when you give the step as negative,

00:08:54.850 --> 00:09:00.310
it will automatically start from the first element from the riverside and then starts dick

00:09:00.310 --> 00:09:02.670
lamenting and then starts going to give you this.

00:09:02.670 --> 00:09:04.850
So if a shape your revenue comes,

00:09:04.850 --> 00:09:08.150
you'll see that the entire list has bean reversed.

00:09:08.150 --> 00:09:13.380
Since list and strings are more or less equivalent.

00:09:13.380 --> 00:09:16.260
You can also apply the same thing for list,

00:09:16.260 --> 00:09:17.260
for example,

00:09:17.260 --> 00:09:18.750
before type here,

00:09:18.750 --> 00:09:25.120
name equals toe say we know come on and then I can say her name off.

00:09:25.120 --> 00:09:30.500
Colon Colon minus one will give you the same name in reverse order as well.

00:09:30.500 --> 00:09:32.020
Let me clear the screen.

00:09:32.020 --> 00:09:37.180
This is what we have people which is a list off dictionaries.

00:09:37.180 --> 00:09:41.550
Let me assign the 1st 1 toe a variable called p one.

00:09:41.550 --> 00:09:45.800
So I can say people equals toe people off zero.

00:09:45.800 --> 00:09:48.510
And that's going to be be not on Bangla.

00:09:48.510 --> 00:09:52.330
If I want to bring the value off this regionally,

00:09:52.330 --> 00:10:00.820
use strange and then use a percentage s he's from percentage s and then another percentage

00:10:00.820 --> 00:10:04.930
and then we save people off Name Come up p one off,

00:10:04.930 --> 00:10:05.950
probably city.

00:10:05.950 --> 00:10:08.150
If I close the bracket center,

00:10:08.150 --> 00:10:13.360
we get you know this from Bangla now for two off these fields it is okay.

00:10:13.360 --> 00:10:18.970
So if I have said 10 keys and I have a formatted string that Prince 10 off these values

00:10:18.970 --> 00:10:23.000
then obviously brooding like this would be probably a time consuming.

00:10:23.000 --> 00:10:25.870
Tasks are sometimes complex as well.

00:10:25.870 --> 00:10:29.470
Didn't easy we have doing on what I do it.

00:10:29.470 --> 00:10:31.130
I just use the same statement,

00:10:31.130 --> 00:10:34.890
but instead off this interest off this type you're P one,

00:10:34.890 --> 00:10:36.270
of course,

00:10:36.270 --> 00:10:42.040
from the one I want name to be printed over here on the city to be printed over here.

00:10:42.040 --> 00:10:47.130
So all I have to do is tow Add a bracket in between the percentage and s,

00:10:47.130 --> 00:10:49.570
and then say What is the key on interested?

00:10:49.570 --> 00:10:53.650
So I'm interested in name here and then I'm interested in city here.

00:10:53.650 --> 00:11:00.260
So now against a percentage name s name is the attribute or property that is going to be

00:11:00.260 --> 00:11:05.780
picked up from this dictionary and city is the attribute or property taken from P one for

00:11:05.780 --> 00:11:07.240
this particular expressions.

00:11:07.240 --> 00:11:08.400
If a press enter,

00:11:08.400 --> 00:11:10.190
you'll see the exact same thing.

00:11:10.190 --> 00:11:13.880
One last example on list comprehension.

00:11:13.880 --> 00:11:18.840
Have a look at this Delia on str or any class that you view,

00:11:18.840 --> 00:11:22.440
you will see that there are a lot off dunder functions that are being displayed which

00:11:22.440 --> 00:11:27.150
practically or useless for us because they're meant for internal usage.

00:11:27.150 --> 00:11:31.250
If I have to get a list off only the non under functions,

00:11:31.250 --> 00:11:34.220
I can create a function called D d a.

00:11:34.220 --> 00:11:35.480
R or D.

00:11:35.480 --> 00:11:42.430
I double or something like that when I say str i wanted to display only the Nantes under

00:11:42.430 --> 00:11:42.860
function.

00:11:42.860 --> 00:11:44.440
So to create such a function.

00:11:44.440 --> 00:11:45.340
It's very simple.

00:11:45.340 --> 00:11:46.570
I see her death,

00:11:46.570 --> 00:11:48.050
D ira,

00:11:48.050 --> 00:11:50.140
and then it takes a pedometer.

00:11:50.140 --> 00:11:51.060
For example.

00:11:51.060 --> 00:11:52.820
The perimeter should be did it?

00:11:52.820 --> 00:11:54.140
I sell politest,

00:11:54.140 --> 00:11:57.400
DT and the like and return a new list.

00:11:57.400 --> 00:12:03.500
And I can say here 84 80 in the earlier off the DT,

00:12:03.500 --> 00:12:04.480
which the data type,

00:12:04.480 --> 00:12:10.770
but only if the first letter off the 80 80 happens to be one of the attributes at this

00:12:10.770 --> 00:12:13.470
point in time and say 80 off zero,

00:12:13.470 --> 00:12:14.560
not equal.

00:12:14.560 --> 00:12:16.120
Stow on underscore.

00:12:16.120 --> 00:12:20.930
So there are some attributes which may have a single underscore on some of them May have

00:12:20.930 --> 00:12:21.750
double into school.

00:12:21.750 --> 00:12:25.710
I'm only saying that if the first letter is not an underscore,

00:12:25.710 --> 00:12:27.490
then we want to return this.

00:12:27.490 --> 00:12:32.800
So now I have this function can be I r r I can call it as d i.

00:12:32.800 --> 00:12:34.070
R S t l.

00:12:34.070 --> 00:12:38.890
And you'll see that I get only a list of functions that are non dunder.

00:12:38.890 --> 00:12:40.280
Let's check it out again.

00:12:40.280 --> 00:12:45.960
I double park off Pete and I get only the functions which are not starting with an

00:12:45.960 --> 00:12:47.370
underscore here as well

