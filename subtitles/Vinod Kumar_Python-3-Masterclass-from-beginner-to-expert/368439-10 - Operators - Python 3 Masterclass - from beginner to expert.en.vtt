WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.530
in this lecture.

00:00:01.530 --> 00:00:03.610
Let's have a look It right on Operators,

00:00:03.610 --> 00:00:04.570
by tell Operators,

00:00:04.570 --> 00:00:07.270
can be divided broadly into arithmetic.

00:00:07.270 --> 00:00:11.950
String Relational Logical Beat Wales on assignment operators.

00:00:11.950 --> 00:00:17.350
Our medic operators perform arithmetic operations on numerical values.

00:00:17.350 --> 00:00:22.180
Most commonly used ones are plus minor star slash for addition,

00:00:22.180 --> 00:00:22.820
subtraction,

00:00:22.820 --> 00:00:24.160
multiplication and division.

00:00:24.160 --> 00:00:25.460
However,

00:00:25.460 --> 00:00:28.750
there are two types of division one that gives you a fractional values,

00:00:28.750 --> 00:00:33.750
which is like 22 by seven gives you 3.14 to 8 etcetera.

00:00:33.750 --> 00:00:37.980
There is another one where you're not interested in the fractional values.

00:00:37.980 --> 00:00:42.950
Your only to spend the integer part the division and this is a chilled by using a double

00:00:42.950 --> 00:00:43.380
slash.

00:00:43.380 --> 00:00:43.990
For example,

00:00:43.990 --> 00:00:46.750
22 double slash seven will give it three.

00:00:46.750 --> 00:00:52.560
We also have an exponents operator which is equal int off x rays to the poor off.

00:00:52.560 --> 00:00:54.480
Why in this example,

00:00:54.480 --> 00:01:00.300
Toe Start start three means to raise to the part of three which is equal int off eight.

00:01:00.300 --> 00:01:05.700
We also have a model ISS operator that gives the reminder after division,

00:01:05.700 --> 00:01:06.650
for example,

00:01:06.650 --> 00:01:13.950
25 model s seven will give you for the operator plus and star can also be used with strings

00:01:13.950 --> 00:01:13.950
,

00:01:13.950 --> 00:01:15.840
but they have a different meaning.

00:01:15.840 --> 00:01:17.270
For example,

00:01:17.270 --> 00:01:19.890
if you're using plus symbol with two strings,

00:01:19.890 --> 00:01:21.440
it's called concatenation,

00:01:21.440 --> 00:01:23.310
which results in tow,

00:01:23.310 --> 00:01:26.010
joining off two strings we know.

00:01:26.010 --> 00:01:26.320
Plus,

00:01:26.320 --> 00:01:30.580
Kumar will become we not come on as one single string start,

00:01:30.580 --> 00:01:31.380
on the other hand,

00:01:31.380 --> 00:01:33.490
is used for repeating a string.

00:01:33.490 --> 00:01:35.570
If you are using,

00:01:35.570 --> 00:01:38.300
we know times three you're gonna get.

00:01:38.300 --> 00:01:40.770
We know we don't be not as a single string.

00:01:40.770 --> 00:01:46.870
This can be used for creating a line where I can choose a character off my choice

00:01:46.870 --> 00:01:51.950
multiplied by 50 or 80 depending on hoping the line you want.

00:01:51.950 --> 00:01:53.850
For example,

00:01:53.850 --> 00:02:01.150
I can see here in single course minus times 80.

00:02:01.150 --> 00:02:04.960
We give you a line that is 80 characters.

00:02:04.960 --> 00:02:10.090
Length are I can use a different symbol like this,

00:02:10.090 --> 00:02:11.630
and then I get a different lane.

00:02:11.630 --> 00:02:20.410
I can use a combination off to off them and then reduce this by 40 and now get a line off.

00:02:20.410 --> 00:02:21.150
This time,

00:02:21.150 --> 00:02:28.010
relational operators can compare the values off to operate and and then give you true or

00:02:28.010 --> 00:02:35.650
false as the result in value less than symbol is used for comparing whether a value one is

00:02:35.650 --> 00:02:37.780
less than the value to or not,

00:02:37.780 --> 00:02:38.480
in this case,

00:02:38.480 --> 00:02:41.250
10 less than 12 which is equal in tow.

00:02:41.250 --> 00:02:41.700
True,

00:02:41.700 --> 00:02:43.990
but as less than R equals,

00:02:43.990 --> 00:02:49.560
two can be used to check whether or not the first value is less than the second value,

00:02:49.560 --> 00:02:52.250
or is it equals to the second value.

00:02:52.250 --> 00:02:53.150
In this case,

00:02:53.150 --> 00:02:58.500
12 less than Article 12 gives you true toe unless Dent well would have given force.

00:02:58.500 --> 00:02:59.890
Similarly,

00:02:59.890 --> 00:03:02.240
we have greater than great that equals two.

00:03:02.240 --> 00:03:08.830
We also have a double equals which is used for comparing two values whether they are seem

00:03:08.830 --> 00:03:09.550
or not.

00:03:09.550 --> 00:03:14.750
And also we have not equals to that checks the opposite off the table.

00:03:14.750 --> 00:03:21.940
These relational operators can also be used with strings with the unicorn values off

00:03:21.940 --> 00:03:24.680
characters off the strings will be you for comparison.

00:03:24.680 --> 00:03:25.800
If I check,

00:03:25.800 --> 00:03:27.860
we know less than we need.

00:03:27.860 --> 00:03:31.120
Do you think your false?

00:03:31.120 --> 00:03:37.370
The reason for this is this operator No checks the unicorn value off re with real since

00:03:37.370 --> 00:03:41.930
their same I with higher it is the same end with end it the same.

00:03:41.930 --> 00:03:46.750
Now it's going to check the unicorn value off all with unicorn value of E.

00:03:46.750 --> 00:03:48.770
Now go find the unicorn value.

00:03:48.770 --> 00:03:50.850
You can use the org function.

00:03:50.850 --> 00:03:51.890
Andi,

00:03:51.890 --> 00:03:56.220
that's gonna tell you what are the unique or values off pool and E,

00:03:56.220 --> 00:04:01.130
which is 111 and 101 since 111 less than under known.

00:04:01.130 --> 00:04:02.030
One is false.

00:04:02.030 --> 00:04:03.650
You get the result as false.

00:04:03.650 --> 00:04:05.090
However,

00:04:05.090 --> 00:04:05.850
if I take,

00:04:05.850 --> 00:04:09.950
we know less than you know that.

00:04:09.950 --> 00:04:13.070
Now we'll see that you're gonna get true,

00:04:13.070 --> 00:04:15.950
mainly because for the 1st 3 letters,

00:04:15.950 --> 00:04:18.220
the Unicord values are saying they're skipped.

00:04:18.220 --> 00:04:20.990
But when it comes to O on you,

00:04:20.990 --> 00:04:25.510
the unicorn value of four is less than unicord value of you.

00:04:25.510 --> 00:04:31.580
So we can check the same by taping or the off pool and wardy off you.

00:04:31.580 --> 00:04:37.330
You'll see that you're gonna get 111 on 117 since 111.

00:04:37.330 --> 00:04:39.300
Less than 117 is true.

00:04:39.300 --> 00:04:41.080
It's going to result that in tow.

00:04:41.080 --> 00:04:41.750
True here,

00:04:41.750 --> 00:04:46.910
logical operators can be used for combining more than one condition.

00:04:46.910 --> 00:04:52.810
A geological operator can be used with two conditions simultaneously.

00:04:52.810 --> 00:04:53.620
For example,

00:04:53.620 --> 00:04:56.130
10 less than 12 is one condition,

00:04:56.130 --> 00:04:58.330
10 less than 80 is another condition.

00:04:58.330 --> 00:05:00.970
10 less than 12 results in tow.

00:05:00.970 --> 00:05:01.550
True,

00:05:01.550 --> 00:05:04.500
whereas 10 less than eight results into false,

00:05:04.500 --> 00:05:06.370
true and false.

00:05:06.370 --> 00:05:07.770
He's going to be false.

00:05:07.770 --> 00:05:11.120
False and true is also false for,

00:05:11.120 --> 00:05:17.130
and Ford is obviously false with the only way a condition becomes true is when both the

00:05:17.130 --> 00:05:19.050
condition are true here.

00:05:19.050 --> 00:05:20.280
Similarly,

00:05:20.280 --> 00:05:25.060
if you're using our operator the moment the first condition is true.

00:05:25.060 --> 00:05:30.470
The second condition is that we checked at all because anyone condition must pass,

00:05:30.470 --> 00:05:32.480
and if the first condition is true,

00:05:32.480 --> 00:05:34.650
it'll ever bother to check the second condition.

00:05:34.650 --> 00:05:37.790
But as if the first condition is fade,

00:05:37.790 --> 00:05:40.050
then it's gonna check the second condition.

00:05:40.050 --> 00:05:42.200
If the second condition also fails,

00:05:42.200 --> 00:05:43.580
then the result is false.

00:05:43.580 --> 00:05:46.660
Other ways it is going to be true in this case,

00:05:46.660 --> 00:05:47.910
12 less than or equal to two.

00:05:47.910 --> 00:05:48.400
Alice.

00:05:48.400 --> 00:05:49.000
True,

00:05:49.000 --> 00:05:50.000
because of it,

00:05:50.000 --> 00:05:52.450
it doesn't even check the second condition at all.

00:05:52.450 --> 00:05:57.880
They're not operator can be used for negating the result of a condition.

00:05:57.880 --> 00:05:58.670
For example,

00:05:58.670 --> 00:05:59.430
in this case,

00:05:59.430 --> 00:06:01.760
12 greater than 12 is false,

00:06:01.760 --> 00:06:03.980
not off false becomes true.

00:06:03.980 --> 00:06:10.590
Fight announcer supports bit ways operators though the practicality off these operators are

00:06:10.590 --> 00:06:12.780
very less the operator,

00:06:12.780 --> 00:06:16.850
double less than symbol represents what's going left shift.

00:06:16.850 --> 00:06:17.890
Basically,

00:06:17.890 --> 00:06:22.130
the bigs will be shifted by the number off bits that you mentioned over here.

00:06:22.130 --> 00:06:23.440
For example,

00:06:23.440 --> 00:06:32.250
we have 12 left shift operator and then to So we want to shift the bits off this 12 by two

00:06:32.250 --> 00:06:34.550
bits and then calculate the result.

00:06:34.550 --> 00:06:36.370
Take a look at this example.

00:06:36.370 --> 00:06:38.170
12 in binary form.

00:06:38.170 --> 00:06:41.400
It is represented with these eight zeros and ones.

00:06:41.400 --> 00:06:44.800
And then when you said 12 left shift to.

00:06:44.800 --> 00:06:50.420
So we basically want to make room for two more bits on the right side because we're going

00:06:50.420 --> 00:06:52.250
to shift the bigs on the left.

00:06:52.250 --> 00:06:57.740
As you can see that the bids have been more towards the left making room for these two

00:06:57.740 --> 00:06:58.350
cells.

00:06:58.350 --> 00:07:02.150
Now these two cells will always be inserted with zeros,

00:07:02.150 --> 00:07:11.330
and hence now the overall bite consists of 00110000 bringing that result in tow 48.

00:07:11.330 --> 00:07:12.710
Similarly,

00:07:12.710 --> 00:07:15.690
if you're tryingto do a great shift operator,

00:07:15.690 --> 00:07:17.410
here is what happens.

00:07:17.410 --> 00:07:27.260
The bite consists off a debate with 00001100 representing 12 The moment you said 12 right

00:07:27.260 --> 00:07:31.180
shift operator to you want to shift all the Brits by two.

00:07:31.180 --> 00:07:34.730
So that means the leading zeros will be committed.

00:07:34.730 --> 00:07:38.860
Their pushed out of the bite making room on the left side.

00:07:38.860 --> 00:07:48.320
On these will be inserted with zeros again making the whole bite as 00000011 Now,

00:07:48.320 --> 00:07:50.630
if you can work the binary number in tow,

00:07:50.630 --> 00:07:58.900
a decimal it becomes three in person and our represents the finery on binary are,

00:07:58.900 --> 00:08:00.070
for example,

00:08:00.070 --> 00:08:03.890
12 on 13 results into 12.

00:08:03.890 --> 00:08:06.490
12 are 13 results in tow.

00:08:06.490 --> 00:08:06.960
13.

00:08:06.960 --> 00:08:08.950
To understand the same,

00:08:08.950 --> 00:08:10.390
let's have a look at this one.

00:08:10.390 --> 00:08:17.090
Consider two numbers 1 51 and 1 37 toe are between numbers and they're binary,

00:08:17.090 --> 00:08:18.250
equal and of the same.

00:08:18.250 --> 00:08:20.160
Now,

00:08:20.160 --> 00:08:23.780
if you're going to go on the operator between these,

00:08:23.780 --> 00:08:27.810
the bigs in the same index will be combined with the and operator.

00:08:27.810 --> 00:08:34.170
So one and one will become 11 and zero R zero and one.

00:08:34.170 --> 00:08:40.450
But they all become zeros so effectively you can see now that one and one is one.

00:08:40.450 --> 00:08:44.240
And then all of these are going to be converted into zeros.

00:08:44.240 --> 00:08:45.970
And here is one on one.

00:08:45.970 --> 00:08:51.870
So the total result will be one followed by 000000 and one.

00:08:51.870 --> 00:08:54.530
If you can work that binary into decimal.

00:08:54.530 --> 00:08:57.360
You're gonna get 1 29 Similarly,

00:08:57.360 --> 00:09:00.850
if you want to do and our operation between these,

00:09:00.850 --> 00:09:07.150
the big ways are Operator now takes the bits in the same index and then converts that into

00:09:07.150 --> 00:09:08.690
an R result.

00:09:08.690 --> 00:09:17.900
So one R one is 11 R zero is also one one R 00 or one they on are becoming ones.

00:09:17.900 --> 00:09:21.420
Zero R zero and zero r zero become zero.

00:09:21.420 --> 00:09:26.160
So the result will now look like this where wherever there is a one,

00:09:26.160 --> 00:09:30.070
it becomes one irrespective of the other zero.

00:09:30.070 --> 00:09:31.610
But in the zero,

00:09:31.610 --> 00:09:34.210
it's going to check the next one and then say it is one,

00:09:34.210 --> 00:09:35.860
so it's going to result in tow one.

00:09:35.860 --> 00:09:43.750
So the final dessert would be 10011111 If you can work this binary into decimal,

00:09:43.750 --> 00:09:49.600
you're gonna get 1 59 Bytom supports shorthand operators for assignment.

00:09:49.600 --> 00:09:51.350
As you can see here,

00:09:51.350 --> 00:09:56.800
each one of these operators are equal and off its lengthier former.

00:09:56.800 --> 00:09:57.710
For example,

00:09:57.710 --> 00:09:59.440
a plus equals toe.

00:09:59.440 --> 00:10:05.360
10 can be returned as equals toe a plus 10 but this is a sharp form.

00:10:05.360 --> 00:10:10.030
Notation off this lengthy er notation at this point in time.

00:10:10.030 --> 00:10:13.720
If you're coming from C C plus plus Java or C shop,

00:10:13.720 --> 00:10:19.350
it is important to know that there is no plus plus or minus minus operators.

00:10:19.350 --> 00:10:23.190
So if you want to implement a value of variable by one,

00:10:23.190 --> 00:10:28.050
we may have to say a plastic was toe one instead of a plus plus.

00:10:28.050 --> 00:10:29.080
Similarly,

00:10:29.080 --> 00:10:34.450
a minus equals to one is equal and off a minus minus in other languages.

