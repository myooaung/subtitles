WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.840
in this video.

00:00:01.840 --> 00:00:04.220
Let's have a look at three more functions.

00:00:04.220 --> 00:00:08.050
Filter map and reduce all this function.

00:00:08.050 --> 00:00:10.660
Steak original function is a perimeter,

00:00:10.660 --> 00:00:14.390
and we can supply lambda expressions instead of actual functions.

00:00:14.390 --> 00:00:16.140
And for this demonstration,

00:00:16.140 --> 00:00:18.920
let's declare a numbs as a list.

00:00:18.920 --> 00:00:19.300
Here,

00:00:19.300 --> 00:00:20.540
off some numbers,

00:00:20.540 --> 00:00:23.490
I'm gonna supply some random few numbers.

00:00:23.490 --> 00:00:33.730
1234 56 78 31 58 Terry extremely on for eight,

00:00:33.730 --> 00:00:34.780
off for 83.

00:00:34.780 --> 00:00:42.570
Now let's say I want on a list off only even numbers from this particular list or art

00:00:42.570 --> 00:00:43.150
numbers.

00:00:43.150 --> 00:00:44.380
Earlier,

00:00:44.380 --> 00:00:48.900
we learned home to do the same thing using a list comprehension.

00:00:48.900 --> 00:00:55.800
Now we will see how to use the building filter object to do the same thing so you can

00:00:55.800 --> 00:01:00.230
simply use filter and then supply a function.

00:01:00.230 --> 00:01:02.650
And then the terrible is the norms.

00:01:02.650 --> 00:01:09.720
The future function needs a logic as whether toe include this number in the result or not.

00:01:09.720 --> 00:01:12.960
On the the logic is something that we had a supply.

00:01:12.960 --> 00:01:17.900
So the filter function will call my lander expressions by supplying an element.

00:01:17.900 --> 00:01:19.200
And I just have to say,

00:01:19.200 --> 00:01:19.630
Hey,

00:01:19.630 --> 00:01:20.770
do you include this?

00:01:20.770 --> 00:01:23.590
Are don't you introduce we have to return a true or false.

00:01:23.590 --> 00:01:30.690
So let's say I give your Landau off the n where n is one of the element off this norms and

00:01:30.690 --> 00:01:33.510
then written true or false Based on some logic,

00:01:33.510 --> 00:01:35.150
if I simply say true here,

00:01:35.150 --> 00:01:37.930
then all of them will be included.

00:01:37.930 --> 00:01:38.290
Now,

00:01:38.290 --> 00:01:41.410
the return value from the filter here is a filter object.

00:01:41.410 --> 00:01:41.950
In fact,

00:01:41.950 --> 00:01:45.080
Wilder is that class and this is a constructor.

00:01:45.080 --> 00:01:46.430
So we just constructed this.

00:01:46.430 --> 00:01:49.770
But we can pass this to a list and then check it out.

00:01:49.770 --> 00:01:56.930
So I taped your list on D List constructor passing this and the expression you'll see know

00:01:56.930 --> 00:02:02.630
that all the values have been included but had a given here fonts then None of the values

00:02:02.630 --> 00:02:03.560
would be included,

00:02:03.560 --> 00:02:10.900
so we have to give a condition here that is dynamically generated based on the value n Now

00:02:10.900 --> 00:02:10.900
,

00:02:10.900 --> 00:02:13.130
since we wanted a list off even numbers,

00:02:13.130 --> 00:02:14.630
it's pretty straightforward.

00:02:14.630 --> 00:02:20.890
I don't start to say if n models to is it equals 20 That means it is an even number.

00:02:20.890 --> 00:02:23.380
Then this will be collected in the result.

00:02:23.380 --> 00:02:24.640
If it is our number,

00:02:24.640 --> 00:02:27.600
this will be committed and I will see you have a list off,

00:02:27.600 --> 00:02:28.850
only even numbers.

00:02:28.850 --> 00:02:35.080
So literally we supply the function that tells the future whether to include this inducer

00:02:35.080 --> 00:02:37.150
element in the result are not,

00:02:37.150 --> 00:02:38.050
of course,

00:02:38.050 --> 00:02:39.200
the same thing we could have done.

00:02:39.200 --> 00:02:45.860
Using a list comprehension like even numbs equals toe a square bracket to say that we need

00:02:45.860 --> 00:02:49.950
a new list at that they end for end in months,

00:02:49.950 --> 00:02:57.500
if any percentage toe equals 20 and we would have got the same result as the previous ones

00:02:57.500 --> 00:02:57.500
.

00:02:57.500 --> 00:02:58.700
Of course,

00:02:58.700 --> 00:03:00.360
the choice is up to you.

00:03:00.360 --> 00:03:02.640
Do you want to use the list comprehension,

00:03:02.640 --> 00:03:04.770
or do you want to use the filter function,

00:03:04.770 --> 00:03:06.320
which is built in class?

00:03:06.320 --> 00:03:08.860
And it's purely a question of convenience.

00:03:08.860 --> 00:03:11.500
You should decide which one is right for you.

00:03:11.500 --> 00:03:13.630
Let's take another example,

00:03:13.630 --> 00:03:15.100
which is called Map.

00:03:15.100 --> 00:03:20.740
Given a terrible like this can convert each off these elements in tow.

00:03:20.740 --> 00:03:21.660
Something else.

00:03:21.660 --> 00:03:22.990
For example,

00:03:22.990 --> 00:03:26.250
if I want the square off each of these numbers,

00:03:26.250 --> 00:03:34.650
we could have done using something like 10 into end that end straight for N in numbs.

00:03:34.650 --> 00:03:36.130
And then if I pressed enter,

00:03:36.130 --> 00:03:38.900
you can see that I got the screen off each other's numbers,

00:03:38.900 --> 00:03:41.550
and this is using a list comprehension.

00:03:41.550 --> 00:03:45.270
But there is a bill dinner class called as map.

00:03:45.270 --> 00:03:47.450
So if you say you're help Matt,

00:03:47.450 --> 00:03:49.850
you see that it's a class for map.

00:03:49.850 --> 00:03:52.640
So you are able toe call that using a constructor,

00:03:52.640 --> 00:03:54.100
it returns a map object,

00:03:54.100 --> 00:03:57.720
and then you can take that map object and positive list constructor,

00:03:57.720 --> 00:04:01.210
and you should be ableto get the list off those things.

00:04:01.210 --> 00:04:05.830
What is important here is that it takes and the terrible as a second perimeter.

00:04:05.830 --> 00:04:11.300
That's our list numbs and then in function that decides what to do with each of the

00:04:11.300 --> 00:04:12.650
elements off this terrible.

00:04:12.650 --> 00:04:14.670
So let's take an example off this.

00:04:14.670 --> 00:04:19.980
So we have numbers here and then I want the square off each one of them so I can simply are

00:04:19.980 --> 00:04:22.040
here list off.

00:04:22.040 --> 00:04:25.110
So we're creating a new list object based on a map.

00:04:25.110 --> 00:04:25.930
So return value.

00:04:25.930 --> 00:04:26.940
So it's a map,

00:04:26.940 --> 00:04:30.650
and the function here is Lambda off end.

00:04:30.650 --> 00:04:32.550
I'll say anything to end.

00:04:32.550 --> 00:04:35.640
So you give me and I will give you end square.

00:04:35.640 --> 00:04:40.080
That's what actually this land asses American supply here numbs toe.

00:04:40.080 --> 00:04:44.260
Get the square off each of these numbers again the question is,

00:04:44.260 --> 00:04:46.660
do you want to use mad function?

00:04:46.660 --> 00:04:50.630
Are Do you want to use list comprehension totally up to you?

00:04:50.630 --> 00:04:51.160
Similarly,

00:04:51.160 --> 00:04:57.250
have your names and I want the uppercase washing off each of these names I can simply use

00:04:57.250 --> 00:04:57.740
here.

00:04:57.740 --> 00:04:59.180
List off,

00:04:59.180 --> 00:05:05.270
map on and given a name here I will didn't end out a put,

00:05:05.270 --> 00:05:06.470
which is a function.

00:05:06.470 --> 00:05:11.650
And then I'll say the names is the collection that I won't supply and you can see I got the

00:05:11.650 --> 00:05:14.350
upper case washing off all the names here.

00:05:14.350 --> 00:05:14.720
Now,

00:05:14.720 --> 00:05:19.250
one more function that we want to use your is called as a read deals.

00:05:19.250 --> 00:05:22.030
But if you take your health on,

00:05:22.030 --> 00:05:23.310
reduce it,

00:05:23.310 --> 00:05:25.980
See that it says radios is not defined.

00:05:25.980 --> 00:05:30.270
This is their in fighting to directly as a global object,

00:05:30.270 --> 00:05:33.940
so invite on to you could go and straight of it used is reduced.

00:05:33.940 --> 00:05:34.740
However,

00:05:34.740 --> 00:05:41.620
here we have to import these radios from a module called Fun Tools so I can see here from

00:05:41.620 --> 00:05:45.200
fun tools import radios on.

00:05:45.200 --> 00:05:45.560
Now,

00:05:45.560 --> 00:05:48.020
if I type your help on reduced,

00:05:48.020 --> 00:05:49.480
we get the hell again.

00:05:49.480 --> 00:05:51.130
You can see that reduces their function.

00:05:51.130 --> 00:05:55.450
It's a building function more to a different model this time on.

00:05:55.450 --> 00:06:00.380
It takes another function as an argument on DNA sequence off values.

00:06:00.380 --> 00:06:03.950
And then you can supply some optional initial values.

00:06:03.950 --> 00:06:04.180
What,

00:06:04.180 --> 00:06:08.810
actually this does is it is going to take a collection off under is like a bunch of numbers

00:06:08.810 --> 00:06:09.580
on,

00:06:09.580 --> 00:06:10.500
then applies.

00:06:10.500 --> 00:06:16.520
This functions logic and then eventually gives me one single value off all of them.

00:06:16.520 --> 00:06:18.290
This can be used to,

00:06:18.290 --> 00:06:19.250
for example,

00:06:19.250 --> 00:06:23.770
find out the men value in a collection or a Maxwell be off a collection,

00:06:23.770 --> 00:06:28.480
some off the values in the collection and so on and so forth.

00:06:28.480 --> 00:06:29.300
Of course,

00:06:29.300 --> 00:06:32.810
we already have a built in function called some on the Len.

00:06:32.810 --> 00:06:35.380
We don't need to use any addiction function for this.

00:06:35.380 --> 00:06:36.650
However,

00:06:36.650 --> 00:06:39.840
if I want to find out the smallest of the largest,

00:06:39.840 --> 00:06:40.460
etcetera,

00:06:40.460 --> 00:06:43.250
so we can actually use this radius function.

00:06:43.250 --> 00:06:44.480
So how do we do this?

00:06:44.480 --> 00:06:48.770
So we say your radios on supply a logic.

00:06:48.770 --> 00:06:55.540
The logic is given in the form off Landau Landau takes your two parameters and be I'll

00:06:55.540 --> 00:06:56.560
explain that in a minute.

00:06:56.560 --> 00:06:57.400
What are these two?

00:06:57.400 --> 00:06:59.550
But we have to return.

00:06:59.550 --> 00:07:01.860
What is the summarized value in this case?

00:07:01.860 --> 00:07:02.670
Now?

00:07:02.670 --> 00:07:04.510
I want written e r B,

00:07:04.510 --> 00:07:06.020
depending on which is small,

00:07:06.020 --> 00:07:11.550
and I can simply say Everton A If is smaller than be Yes,

00:07:11.550 --> 00:07:12.990
the citizen My logic.

00:07:12.990 --> 00:07:16.130
I'm actually returning the smallest off baby.

00:07:16.130 --> 00:07:23.000
So if a smaller than beat and is the return value other ways B is smaller than r equals to

00:07:23.000 --> 00:07:23.290
eight,

00:07:23.290 --> 00:07:24.650
That will be the return value here.

00:07:24.650 --> 00:07:27.100
What actually happens is the second bottom inter is number,

00:07:27.100 --> 00:07:28.950
which is the actual collection.

00:07:28.950 --> 00:07:34.000
So the reduced function will call this lander by supplying these two numbers.

00:07:34.000 --> 00:07:34.950
At first,

00:07:34.950 --> 00:07:40.510
obviously one and two are receiving over here and then we are returning,

00:07:40.510 --> 00:07:48.460
which is small among that which is one next time one entry will be supplied as a and B and

00:07:48.460 --> 00:07:51.120
then one and 41 and 56 etcetera.

00:07:51.120 --> 00:07:51.710
As you can see,

00:07:51.710 --> 00:07:54.250
that one is the smallest in this case.

00:07:54.250 --> 00:07:57.170
So we're gonna get one as the return value.

00:07:57.170 --> 00:07:58.170
Similarly,

00:07:58.170 --> 00:08:03.950
if I go and change the condition toe a great than be basically between these two numbers

00:08:03.950 --> 00:08:08.390
were returning the largest off the to that same logic it up light.

00:08:08.390 --> 00:08:13.760
So it's gonna take your one and thought so too is the largest 2133 is the largest,

00:08:13.760 --> 00:08:14.950
three and four.

00:08:14.950 --> 00:08:17.710
So foreign 56 so on and so forth.

00:08:17.710 --> 00:08:20.270
And 483 is the largest.

00:08:20.270 --> 00:08:25.420
And we see that the 483 is the one that is returned from the reduced function.

00:08:25.420 --> 00:08:28.490
Let's take the example on names.

00:08:28.490 --> 00:08:31.400
So names is a collection off names like this.

00:08:31.400 --> 00:08:31.710
Now,

00:08:31.710 --> 00:08:32.220
obviously,

00:08:32.220 --> 00:08:36.910
here you can see the largest off their over here and the smallest Name it here.

00:08:36.910 --> 00:08:41.350
I can use the same logic toe get the smallest of the largest.

00:08:41.350 --> 00:08:42.280
So in this case,

00:08:42.280 --> 00:08:43.040
I'm gonna say,

00:08:43.040 --> 00:08:44.850
reduce off.

00:08:44.850 --> 00:08:51.550
I need to supply Atlanta and I receive N one and N two where anyone would be Jacob and

00:08:51.550 --> 00:08:53.070
Harish Kumar will be into.

00:08:53.070 --> 00:08:55.500
So does the 1st 2 parameters I always get.

00:08:55.500 --> 00:09:00.960
And then I'm gonna return Anyone our entire depending on whose length is smaller,

00:09:00.960 --> 00:09:01.690
are bigger.

00:09:01.690 --> 00:09:06.720
So let's give your yen One should be the return value if leading off.

00:09:06.720 --> 00:09:09.650
And one is less than Len off into.

00:09:09.650 --> 00:09:10.780
Yes,

00:09:10.780 --> 00:09:14.420
and to is the one that I'm gonna return same as the previous one,

00:09:14.420 --> 00:09:16.250
but this time using the land function.

00:09:16.250 --> 00:09:18.770
So I will get to names.

00:09:18.770 --> 00:09:21.500
I'm returning the first name on the second name,

00:09:21.500 --> 00:09:23.650
depending on whichever is smaller.

00:09:23.650 --> 00:09:28.200
And the names themselves is the second perimeter for the reduce.

00:09:28.200 --> 00:09:33.840
So the first bottom it is a function second parameter is the terrible.

00:09:33.840 --> 00:09:35.740
And now we have a press enter agency.

00:09:35.740 --> 00:09:39.570
You'll get it as a new If I say greater here instead,

00:09:39.570 --> 00:09:41.000
off smaller,

00:09:41.000 --> 00:09:42.840
then obviously,

00:09:42.840 --> 00:09:45.380
between the two names as an input,

00:09:45.380 --> 00:09:48.130
the lengthiest name will be written.

00:09:48.130 --> 00:09:51.020
And you can see that between Jacob and Harish Kumar.

00:09:51.020 --> 00:09:52.610
Suresh Kumar is the one that is return.

00:09:52.610 --> 00:09:53.940
We've been harassed tomorrow.

00:09:53.940 --> 00:09:57.600
Encouraged my again tomorrow between Harish Kumar and Cushy.

00:09:57.600 --> 00:09:58.150
Harassed more.

00:09:58.150 --> 00:09:58.720
We know the virus.

00:09:58.720 --> 00:09:59.020
Come on.

00:09:59.020 --> 00:10:00.470
A new Harish Kumar John.

00:10:00.470 --> 00:10:06.220
Now all of them said this will be the largest value on automatically that will be

00:10:06.220 --> 00:10:09.050
considered as the return value from their it use.

00:10:09.050 --> 00:10:14.830
So this is how we can use Lambda expressions instead off writing an actual function and

00:10:14.830 --> 00:10:16.190
keeping it in the global scope.

00:10:16.190 --> 00:10:20.510
Whatever we can supply lambda expressions to map,

00:10:20.510 --> 00:10:22.850
reduce and filter functions

