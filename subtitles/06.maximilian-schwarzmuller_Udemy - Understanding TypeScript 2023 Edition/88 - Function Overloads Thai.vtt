WEBVTT

00:02.540 --> 00:05.610
ผู้สอน: ต่อไป ฉันต้องการสำรวจฟังก์ชันโอเวอร์โหลด

00:05.610 --> 00:08.050
ซึ่งเป็นคุณลักษณะที่ช่วยให้เราสามารถกำหนดลายเซ็นของฟังก์ชันได้หลายรายการ

00:08.050 --> 00:13.840
กล่าวคือ สำหรับฟังก์ชันเดียวและฟังก์ชันเดียวกัน

00:13.840 --> 00:20.340
ซึ่งหมายความว่าเราสามารถมีหลายวิธีที่เป็นไปได้ในการเรียกใช้ฟังก์ชันด้วยพารามิเตอร์ที่แตกต่างกัน

00:20.340 --> 00:24.300
ตัวอย่างเช่น เพื่อทำบางสิ่งภายในฟังก์ชันนั้น

00:24.300 --> 00:29.060
และตัวอย่างที่ดีที่การโอเวอร์โหลดของฟังก์ชันสามารถช่วยเราได้สามารถดูเพิ่มเติมได้เล็กน้อยด้านบน

00:29.060 --> 00:32.090
ฟังก์ชันเพิ่มนี้ที่เราเขียนไว้ก่อนหน้านี้

00:32.090 --> 00:35.940
ฟังก์ชันนี้ใช้ค่าที่รวมกันได้สองค่า ซึ่งหมายถึงสตริงหรือตัวเลข

00:35.940 --> 00:39.830
จากนั้นอย่างที่คุณเห็นประเภทการส่งคืนที่ TypeScript อนุมานในที่นี้

00:39.830 --> 00:43.450
ทั้งหมดสามารถรวมกันได้

00:43.450 --> 00:45.370
นี่หมายความว่า TypeScript

00:45.370 --> 00:47.960
เข้าใจว่าสิ่งที่ส่งคืนอาจเป็นสตริงหรือตัวเลข

00:47.960 --> 00:52.880
แต่จริงๆ แล้วถ้าคุณลองคิดดู มันก็ไม่จริงเลย

00:52.880 --> 00:55.280
ฉันหมายความว่า ในทางเทคนิคแล้ว มันเป็นเรื่องจริง

00:55.280 --> 00:59.400
แต่เรารู้ว่าถ้าเราส่งเป็นตัวเลขสองตัว ประเภทผลตอบแทนจะเป็นตัวเลขเสมอ

00:59.400 --> 01:03.950
หากเราส่งอย่างน้อยหนึ่งสตริง ประเภทการส่งคืนจะเป็นสตริง

01:03.950 --> 01:05.460
ตอนนี้ทำไมเรื่องนี้ถึงเป็นเช่นนั้น?

01:05.460 --> 01:08.225
โปรดทราบว่าฟังก์ชันเพิ่มเขียนแบบนี้

01:08.225 --> 01:15.390
และที่จริงคุณสามารถแสดงความคิดเห็นทุกอย่างด้านล่างและเพิ่มรหัสใหม่บางส่วนที่ด้านล่างของฟังก์ชัน

01:15.390 --> 01:18.670
ถ้าตอนนี้ฉันได้รับผลลัพธ์ที่นี่โดยการโทรเพิ่ม

01:18.670 --> 01:23.390
ฉันผ่านในหนึ่งและห้า คุณจะเห็นว่าผลลัพธ์เป็นประเภทที่รวมกันได้

01:23.390 --> 01:30.390
ผลที่ตามมาคือ TypeScript ไม่ทราบว่าผลลัพธ์เป็นตัวเลขหรือสตริง

01:30.390 --> 01:34.510
ตอนนี้อาจเป็นเรื่องสำคัญหากเราส่งสตริง

01:34.510 --> 01:41.750
ถ้าฉันผ่าน Max Schwarz ที่นี่ มันก็ใช้ได้ แต่ฉันก็ยังกลับมารวมกันได้

01:41.750 --> 01:46.120
ผลที่ตามมาคือฉันไม่สามารถเรียกฟังก์ชันสตริงตามผลลัพธ์ได้

01:46.120 --> 01:50.600
ฉันไม่สามารถเรียกการแยกตัวอย่างเพื่อแยกบนพื้นที่สีขาวได้

01:50.600 --> 01:55.270
ฉันรู้ว่ามันใช้ได้ เพราะฉันรู้ว่าเมื่อฉันเรียกใช้ฟังก์ชันแบบนี้

01:55.270 --> 01:57.200
ฉันจะทำให้มันเป็น if branch และฉันจะได้สตริงกลับมา

01:57.200 --> 01:59.980
ดังนั้นฉันจึงรู้ว่าผลลัพธ์จะเก็บสตริงไว้

01:59.980 --> 02:05.620
แต่ TypeScript เพิ่งรู้ว่า มันเก็บสตริงหรือตัวเลข

02:05.620 --> 02:08.350
แน่นอน ตอนนี้เราสามารถใช้ typecast ที่นี่และบอก

02:08.350 --> 02:11.340
TypeScript ว่าสิ่งที่เราได้รับกลับมาคือสตริง

02:11.340 --> 02:16.040
เราสามารถทำได้ด้วยไวยากรณ์การหล่อประเภทที่คุณได้เรียนรู้ก่อนหน้านี้

02:16.040 --> 02:18.840
ถึงกระนั้นก็ไม่เหมาะสมที่เราจะต้องทำอย่างนั้น

02:18.840 --> 02:21.800
ฉันขอเถียง เพราะเราต้องเขียนโค้ดเพิ่มเติมที่นี่ แม้ว่าเราจะคาดหวังให้

02:21.800 --> 02:27.740
TypeScript เข้าใจว่าเมื่อเราเรียกฟังก์ชันนี้แบบนี้ เราจะได้สตริงกลับมาเสมอ

02:27.740 --> 02:30.890
แต่ TypeScript ยังวิเคราะห์โค้ดของเราได้ไม่ดีพอ

02:30.890 --> 02:35.000
และนั่นคือจุดที่ฟังก์ชันโอเวอร์โหลดสามารถช่วยเราได้

02:35.000 --> 02:38.730
โอเวอร์โหลดของฟังก์ชันเขียนโดยการเขียนฟังก์ชันเหนือฟังก์ชันหลักของคุณ

02:38.730 --> 02:41.880
ถ้าจะพูดด้วยชื่อเดียวกัน ดังนั้นคุณจึงพูดบรรทัดนี้ซ้ำโดยทั่วไป

02:41.880 --> 03:03.410
อย่างไรก็ตาม โดยไม่มีวงเล็บปีกกา ไม่มีวงเล็บปีกกาเปิดและปิดหลังจากนั้น และตอนนี้คุณ ต้องการใช้ตัวเลขและตัวเลขประเภทเฉพาะจากนั้นค้นหาประเภทการส่งคืนเมื่อเป็นกรณีนี้เมื่อคุณได้รับตัวเลขอย่างน้อยหนึ่งตัว

03:03.410 --> 03:06.643
และตรงนั้นเราสามารถพูดได้ว่า ประเภทการส่งคืนคือตัวเลข

03:08.840 --> 03:10.980
ตอนนี้เรากำลังพูดกับ TypeScript

03:10.980 --> 03:14.980
ถ้าเราเรียกใช้ฟังก์ชันนี้และอาร์กิวเมนต์ทั้งสองเป็นตัวเลข

03:14.980 --> 03:17.180
ฟังก์ชันนี้จะส่งคืนตัวเลข

03:17.180 --> 03:19.430
แน่นอนว่านี่ไม่ใช่ไวยากรณ์ที่จะทำงานใน

03:19.430 --> 03:24.430
JavaScript แต่จะถูกกำจัดโดย TypeScript ในกระบวนการคอมไพล์

03:24.430 --> 03:28.480
แต่ TypeScript รวมข้อมูลฟังก์ชันนี้และการประกาศฟังก์ชันนี้เข้าด้วยกัน

03:28.480 --> 03:35.550
และโดยพื้นฐานแล้วรวมความรู้ของสองบรรทัดนี้ไว้ที่นี่

03:35.550 --> 03:38.590
และตอนนี้มันก็รู้แล้ว เราสามารถเรียกใช้ฟังก์ชันนี้ที่นี่ด้วย

03:38.590 --> 03:43.790
A และ B ของประเภทที่รวมกันได้ หรือด้วย A และ B ของประเภทตัวเลข

03:43.790 --> 03:47.060
นอกจากนี้ คุณยังสามารถเพิ่มหรือลดพารามิเตอร์ที่นี่ในการโอเวอร์โหลดของคุณได้ด้วย

03:47.060 --> 03:50.100
คุณมีความยืดหยุ่นมาก

03:50.100 --> 03:53.640
คุณยังเพิ่มฟังก์ชันเพิ่มที่นี่และคาดหวังเพียงตัวเลขเดียวและส่งคืนตัวเลข

03:53.640 --> 04:03.270
และสิ่งนี้จะใช้ได้ถ้าเรากำหนดให้ B เป็นตัวเลือกในการโอเวอร์โหลดอื่นๆ ของเราด้วย

04:03.270 --> 04:05.254
เพราะท้ายที่สุดแล้ว คุณต้องแน่ใจว่าโค้ดของคุณที่นี่ใช้งานได้เสมอ

04:05.254 --> 04:10.850
และคุณจะได้รับอาร์กิวเมนต์ทั้งหมดที่คุณต้องการในตอนท้าย

04:10.850 --> 04:13.610
มันคือ B เป็นทางเลือกตรงนี้ แล้วคุณก็เห็นว่าใช้ได้

04:13.610 --> 04:15.170
ตอนนี้แน่นอนว่าเราต้องหลีกเลี่ยง

04:15.170 --> 04:19.550
B ที่อาจเป็นทางเลือกด้านล่าง

04:19.550 --> 04:21.390
อย่างไรก็ตาม ฉันไม่ต้องการสิ่งนั้น

04:21.390 --> 04:27.200
ดังนั้นฉันจะกำจัดมันและทิ้งสิ่งนี้ไว้ แต่ฉันก็ไม่ต้องการโอเวอร์โหลดเมื่อเราเรียกสิ่งนี้ด้วยสตริง

04:27.200 --> 04:30.060
ดังนั้นฉันจะเพิ่มฟังก์ชันเพิ่มโอเวอร์โหลดที่นี่โดยที่

04:30.060 --> 04:38.460
A เป็นสตริงและ B เป็นสตริง จากนั้นฉันก็ค่อนข้างชัดเจนเกี่ยวกับข้อเท็จจริงที่ว่าสิ่งที่เราส่งคืนจะเป็นสตริง

04:38.460 --> 04:43.660
ยังไงก็ตาม เป็นแนวปฏิบัติที่ดีที่จะเพิ่มเครื่องหมายอัฒภาคหลังบรรทัดโอเวอร์โหลดเหล่านี้ที่นี่

04:43.660 --> 04:46.560
ตอนนี้ผมกำลังบอกว่าถ้าเราเรียกใช้ฟังก์ชันนี้ด้วยตัวเลขสองตัว

04:46.560 --> 04:49.100
เราจะได้ตัวเลขกลับมาเสมอ

04:49.100 --> 04:52.170
หากเราเรียกมันด้วยสองสตริง เราจะได้สตริงกลับมาเสมอ

04:52.170 --> 04:54.510
ถ้าเราเรียกมันด้วยหนึ่งสตริงและหนึ่งตัวเลข

04:54.510 --> 04:59.410
ในทางเทคนิคแล้ว เราก็จะได้สตริงกลับมาเสมอ แต่ฉันไม่ต้องการเพิ่มชุดค่าผสมที่เป็นไปได้ทั้งหมดที่นี่

04:59.410 --> 05:01.240
แน่นอนว่าฉันสามารถเพิ่มได้มากกว่านั้น

05:01.240 --> 05:03.173
แล้วก็เพิ่มตัวเลขที่นี่ด้วย หรืออื่นๆ

05:04.040 --> 05:07.500
ชุดค่าผสมที่เราอาจมี ซึ่งก็คืออันนี้

05:07.500 --> 05:10.060
ฉันเดาว่าตอนนี้ฉันได้เพิ่มชุดค่าผสมทั้งหมดแล้ว

05:10.060 --> 05:12.540
และตอนนี้ฉันกำลังแสดงรายการค่าผสมที่เป็นไปได้ทั้งหมดที่นี่

05:12.540 --> 05:16.040
และสิ่งที่เราส่งคืนในแต่ละกรณี

05:16.040 --> 05:18.260
ในตอนนี้ คุณจะเห็นข้อผิดพลาดที่ด้านล่างหายไป

05:18.260 --> 05:20.520
เพราะตอนนี้ TypeScript ทราบแล้วว่าผลลัพธ์จะเป็นประเภทสตริง

05:20.520 --> 05:25.623
หากเราเรียกเพิ่มด้วยค่าสองค่านี้ซึ่งเป็นสตริงทั้งคู่

05:25.623 --> 05:31.100
และถ้าฉันวางเมาส์เหนือเพิ่ม คุณจะเห็นว่ามีโอเวอร์โหลดเพิ่มเติมอีกสามรายการ

05:31.100 --> 05:32.980
ที่นี่ฉันเรียก add ด้วยสองสตริง

05:32.980 --> 05:36.630
แต่ TypeScript รู้ว่ามีวิธีอื่นอีกสามวิธีในการเรียกสิ่งนี้

05:36.630 --> 05:39.450
ตัวอย่างเช่น ด้วยสตริงและตัวเลข ในกรณีนี้

05:39.450 --> 05:41.340
ฉันจะได้กลับเป็นสตริง

05:41.340 --> 05:46.340
ด้วยตัวเลขและสตริงบางส่วน หรือด้วยตัวเลขสองตัว

05:47.430 --> 05:48.630
สิ่งนี้ก็จะใช้งานได้เช่นกัน

05:48.630 --> 05:50.210
แน่นอนว่าฉันไม่สามารถเรียกแยกได้เนื่องจาก

05:50.210 --> 05:54.630
TypeScript ระบุอย่างถูกต้องว่าเมื่อฉันเรียกสิ่งนี้ด้วยสองหมายเลข ฉันจะได้หมายเลขกลับมา

05:54.630 --> 05:58.253
และในจำนวนนั้นคุณไม่สามารถเรียกแยกได้

05:59.260 --> 06:04.060
สิ่งเหล่านี้คือฟังก์ชันที่โอเวอร์โหลด และสามารถช่วยคุณได้ในสถานการณ์เช่นนี้

06:04.060 --> 06:08.590
โดยที่ TypeScript จะไม่สามารถอนุมานประเภทการส่งคืนได้อย่างถูกต้อง ที่นี่

06:08.590 --> 06:11.660
คุณสามารถเข้าใจได้อย่างชัดเจนเกี่ยวกับสิ่งที่ส่งคืนสำหรับชุดค่าผสมต่างๆ

06:11.660 --> 06:16.033
ที่คุณอาจสนับสนุน หน้าที่ของคุณ
