WEBVTT

00:02.220 --> 00:05.760
-次の段階として､ 割り当てられたプロジェクト､

00:05.760 --> 00:11.320
リスナー､ そしてプロジェクト状態にあるプロジェクトで使用している任意のタイプについて､

00:11.320 --> 00:14.980
作業を行いたいと思います｡

00:14.980 --> 00:25.660
もちろん､ ここで､ 私はどんな仕事もしたくないので､ 専用のプロジェクトクラスやプロジェクトタイプを用意する方が理にかなっていると思います｡

00:25.660 --> 00:34.890
そして実際に､ そのプロジェクト・タイプのためのクラスを作成します｡ クラス・プロジェクトを使用することで､

00:34.890 --> 00:41.570
常に同じ構造を持つプロジェクト・オブジェクトを構築する方法があります｡

00:41.570 --> 00:44.760
今は文字表記で下にやっています｡ 

00:44.760 --> 00:50.490
もちろん､ その弊害として､ DescribeであってDescribeでないことを忘れてはならない｡

00:50.490 --> 00:52.410
という文字列であるIDが必要であること､

00:52.410 --> 00:53.470
などなど｡

00:53.470 --> 00:56.440
そこで､ カスタムタイプが役に立つのですが､

00:56.440 --> 01:02.300
インスタンス化できるようにしたいので､ インターフェースでもカスタムタイプでもなく､

01:02.300 --> 01:05.470
クラスをtypeキーワードで作成します｡

01:05.470 --> 01:07.960
では､ そのような授業､ あるいはそのようなプロジェクトは､

01:07.960 --> 01:10.700
正確にはどのようなものであるべきなのでしょうか｡

01:10.700 --> 01:12.320
では､ コンストラクタを追加して､

01:12.320 --> 01:19.100
コンストラクタに引数やパラメータを代入し､ それが自動的にプロパティになるようにします｡

01:19.100 --> 01:22.310
この場合､ 最初にアクセッサを追加して､

01:22.310 --> 01:25.650
Public､ 次に引数とプロパティの名前､

01:25.650 --> 01:29.450
そして型を指定します｡

01:29.450 --> 01:33.100
そして､ ここではすべてのプロジェクトにIDが必要です｡ 

01:33.100 --> 01:34.990
すべてのプロジェクトにはタイトルが必要で､

01:34.990 --> 01:37.330
これもIDと同じように文字列です｡

01:37.330 --> 01:38.690
説明（文字列）､

01:38.690 --> 01:47.440
Peopleプロパティ（プロジェクトに割り当てられている人数）を持つ必要があります｡

01:47.440 --> 01:49.580
また､ これまでなかったことですが､

01:49.580 --> 01:53.580
プロジェクトのステータスも追加したいと思います｡

01:53.580 --> 01:58.680
なぜなら､ 現在､ プロジェクトをここに追加すると､ 両方のリストに表示されるからです｡

01:58.680 --> 02:01.530
ここで､ プロジェクトにステータスを追加します｡

02:01.530 --> 02:03.630
もちろん､ ステータスは変更可能なので､

02:03.630 --> 02:11.470
最初のボックスでアクティブなプロジェクト､ 2番目のボックスで終了したプロジェクトをフィルタリングすることができます｡

02:11.470 --> 02:15.000
だから､ すべてのボックスで正しいプロジェクトだけを表示するように｡ 

02:15.000 --> 02:19.890
そのために､ ここにもう一つ､ statusというパブリックプロパティを追加します｡ 

02:19.890 --> 02:21.280
そして今､ もちろん問題は､ このステータスがどのタイプであるべきか､

02:21.280 --> 02:23.985
ということです｡

02:23.985 --> 02:28.240
これで､ 2つのリテラル型ActiveとFinishを持つユニオン型が使えるようになりました｡

02:28.240 --> 02:31.170
すでに先ほど使ったものを仕上げました｡

02:31.170 --> 02:33.280
しかし､ ここではいつも､ あなたが学んだもう一つの型､

02:33.280 --> 02:38.320
Enumを紹介したり､ 再紹介したりしたいと思います｡

02:38.320 --> 02:41.890
ここでEnumが最適なのは､ 選択肢が2つしかないからです｡ 

02:41.890 --> 02:44.950
また､ このプロジェクト・オブジェクトのコンテキストでは､

02:44.950 --> 02:48.740
人間にとって意味のあるテキストは必要なく､ 値として保存されますが､

02:48.740 --> 02:52.341
実際には何らかの識別子が必要です｡

02:52.341 --> 02:56.140
そこで､ ここでは新たにEnumプロジェクトのステータスを追加することにします｡ 

02:56.140 --> 03:02.890
そして､ そこにActiveとFinishedという2つの値を持たせたいのです｡

03:02.890 --> 03:08.610
そして､ このステータスは､ このようにプロジェクト・ステータスのタイプになります｡

03:08.610 --> 03:11.003
これが今､ 私のプロジェクトクラスになっています｡ 

03:11.900 --> 03:17.820
これがあれば､ そのプロジェクトクラスを使ったプロジェクトの配列と言えるでしょう｡

03:17.820 --> 03:20.351
そしてもちろん､ ここでプロジェクトを作成するときは､

03:20.351 --> 03:26.620
project stateではなく､ new project projectを使います｡

03:26.620 --> 03:30.310
そして､ プロジェクトにIDを転送します｡

03:30.310 --> 03:38.210
前述したように､ 乱数を文字列に変換し､ タイトル､ 説明､ NUM of People､

03:38.210 --> 03:45.080
そしてもちろん､ ステータスも転送します｡

03:45.080 --> 03:54.830
そして､ このデモプロジェクトのアプリケーションで実現したいことの1つは､ デフォルトですべての新しいプロジェクトがアクティブになるようにすることです｡

03:54.830 --> 04:00.064
そこで､ ここで新しいプロジェクトを作成する際に､ プロジェクトステータスを割り当てます｡

04:00.064 --> 04:00.064
をここでアクティブにし､

04:00.064 --> 04:05.230
それをステータスの値として､ 我々は追加されたプロジェクトをする必要があります｡

04:05.230 --> 04:08.450
そして､ もうひとつ､ プロジェクトクラスが必要な場所があります｡

04:08.450 --> 04:13.474
そして､ このプロジェクト・リスト・クラスには､ アサイン・プロジェクトというプロパティがあります｡

04:13.474 --> 04:17.240
そしてもちろん､ それは常にプロジェクトの配列であるべきです｡ 

04:17.240 --> 04:19.530
これでベータタイピングを使用しています｡ 

04:19.530 --> 04:22.810
そして､ 1つの利点は､ ここレンダープロジェクトでは､

04:22.810 --> 04:26.360
例えば､ ここで自動補完もできるようになったことです｡

04:26.360 --> 04:29.020
また､ これを保存しようとすると､ コンパイルエラーが発生します｡

04:29.020 --> 04:35.360
なぜなら､ TypeScriptは､ 私たちがここでどの型を使って作業しているのかを理解しているからです｡

04:35.360 --> 04:39.040
それがプロジェクトクラスであり､ それをどう使うかということですね｡ 

04:39.040 --> 04:44.230
しかし､ ここにはListenerもあります｡

04:44.230 --> 04:48.630
そしてそのために､ 新しいカスタムタイプのListenerを追加することにします｡ 

04:48.630 --> 04:50.390
もちろん名称は自由です｡ 

04:50.390 --> 04:54.280
ここでは､ 関数の型を1つの単語で表現したいので､

04:54.280 --> 04:58.260
typeを使用しています｡

04:58.260 --> 04:59.640
ということは､ どういうことなのでしょうか？

04:59.640 --> 05:03.270
もちろん､ このアプリケーションのリスナーは､

05:03.270 --> 05:05.370
単なる関数ですよね？

05:05.370 --> 05:07.160
リスナー配列に格納したのは､

05:07.160 --> 05:08.960
単なる関数の束です Add Listener

05:08.960 --> 05:14.190
は新しい関数をプッシュし､ 何かが変わったら､ その関数を実行します｡

05:14.190 --> 05:17.610
つまり､ ここではリスナーは単なる関数に過ぎないのです｡ 

05:17.610 --> 05:22.610
しかし､ それは私たちのアイテム､ 私たちの場合は特定のアイテム､

05:22.870 --> 05:27.113
プロジェクトの配列を受け取る機能なのです｡

05:28.500 --> 05:30.410
そして､ それを使って何かをする｡ 

05:30.410 --> 05:32.480
ここで正確に言うと､

05:32.480 --> 05:35.200
もちろん､ 関数の型を定義するために､

05:35.200 --> 05:38.780
ここでは中括弧は使いません｡ 代わりに､

05:38.780 --> 05:44.090
学んだように戻り値の型を使います｡

05:44.090 --> 05:46.140
リスナーとの協働の場で

05:46.140 --> 05:47.940
戻り値の型は必要ありません｡ 

05:47.940 --> 05:49.810
このようなリスナーとして渡す人は､

05:49.810 --> 05:55.870
リスナーが起動したときにいくつかのアイテムを取得することを期待することを確認したいだけです｡

05:55.870 --> 06:02.760
これで､ Listenersは最終的にリスナーウェル関数の配列であると言える｡

06:02.760 --> 06:05.670
そしてここで､ リスナー関数を押すときに､ それがただの関数ではなく､

06:05.670 --> 06:08.480
リスナーの一種であることを明確にする必要があり､

06:08.480 --> 06:12.350
そうすればすべてがうまくいくのです｡

06:12.350 --> 06:16.180
さて､ この下にあるAdd Listenerを使う場所では､

06:16.180 --> 06:17.650
もちろんタイピングを強化し､

06:17.650 --> 06:23.440
ここで実際にプロジェクトの束を取得することを明確にすることができます｡

06:23.440 --> 06:27.220
これで､ リスナーを設定し､ プロジェクトタイプを追加しましたが､

06:27.220 --> 06:32.210
ここでは何も変わりません｡

06:32.210 --> 06:35.120
もし今､ うまくいくものを追加し､

06:35.120 --> 06:36.900
2つ目のアイテムを追加すると､

06:36.900 --> 06:40.530
最初のアイテムが再び追加される以外に､

06:40.530 --> 06:45.260
そのアイテムも追加されます｡

06:45.260 --> 06:50.570
そこで､ パーツの作業を続ける前に､

06:50.570 --> 06:53.990
1つのリストの中で重複していないこと､

06:53.990 --> 07:08.010
また､ 両方のボックスにわたって重複していないことを確認しましょう｡

07:08.010 --> 07:09.623
だから､ それを直そう｡ 
