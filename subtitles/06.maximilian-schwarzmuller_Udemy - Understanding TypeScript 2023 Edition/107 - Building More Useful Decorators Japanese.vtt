WEBVTT

00:02.480 --> 00:06.780
マン：さて､ ファクトリー関数やファクトリーデコレーターの知識があれば､

00:06.780 --> 00:10.523
かなり面白いことができるようになります｡

00:11.570 --> 00:17.693
例えば､ 新しいデコレーターファクトリーをテンプレートと交換することができます｡

00:19.400 --> 00:23.780
そして､ ここでは､ 何らかの文字列であるはずのテンプレートが得られると期待しています｡

00:23.780 --> 00:28.780
そして､ hookId｡ これも文字列である必要があります｡ 

00:28.870 --> 00:32.050
そして､ ここで無名関数を返しますが､

00:32.050 --> 00:34.800
これが実際のデコレータです｡

00:34.800 --> 00:37.440
なぜなら､ 今回もデコレーターファクトリーを持っているからです｡ 

00:37.440 --> 00:40.570
そして､ その中で､ あるテンプレートをレンダリングしたいのですが､

00:40.570 --> 00:42.530
それは､ あるHTMLコードであるべきで､

00:42.530 --> 00:46.590
domの中のある場所に､ このhookIdを見つけたいのです｡

00:46.590 --> 00:49.160
これで､ インデックスに行けるようになりましたね｡  htmlにそのような場所を追加し､

00:49.160 --> 00:51.250
これが機能することを確認できるようにします｡

00:51.250 --> 00:54.483
ここにdivを追加して､ idをappにすればいいんじゃないでしょうか｡ 

00:55.430 --> 01:01.357
そして､ アプリで｡  ts､ loggerの代わりにWithTemplateを追加しています｡

01:02.570 --> 01:06.810
とりあえず第一引数に空文字列､ 第二引数にappを渡してみましょう｡

01:06.810 --> 01:09.313
で､ このIDはここのdivに割り当てたものです｡ 

01:10.170 --> 01:13.830
そして､ この内部関数の中に､ 実際のデコレーターがあります｡

01:13.830 --> 01:19.500
このデコレータ関数の内部で､ 要素に手を差し伸べたいと思います｡

01:19.500 --> 01:24.500
document を持つ hook 要素へ｡  getElementById｡ 

01:25.662 --> 01:29.390
ここで引数として得ているhookIdについて｡ 

01:29.390 --> 01:33.480
そして､ HookElが存在するのであれば､ そのinnerHTMLにアクセスし､

01:34.330 --> 01:39.920
これを例えばtemplateと等しい値に設定したい｡

01:39.920 --> 01:41.440
もちろん､ 非常にシンプルなセットアップですが､

01:41.440 --> 01:43.640
これで十分です｡

01:43.640 --> 01:45.460
さて､ 私はコンストラクタには興味がありません｡ 

01:45.460 --> 01:48.110
そしてtypescriptに「ここは興味がない」と伝えるために､

01:48.110 --> 01:50.370
名前にアンダースコアを付けます｡ これは基本的にtypescriptに「ああ､

01:50.370 --> 01:54.580
この引数があるのは知ってるけど､ いらないよ」という合図になります｡

01:54.580 --> 01:56.170
指定しないといけないけど｡ 

01:56.170 --> 01:58.920
だから､ このアンダースコアで､ 「意識はしているけど､

01:58.920 --> 02:02.300
使わないよ」と伝えているのです｡ だって､ 今やりたいことは､ 今年中にレンダリングしたいんですもの｡

02:02.300 --> 02:04.033
ここでWithTemplateを追加すると､

02:05.580 --> 02:10.400
h1タグ､ My Person Objectをこのように追加できます｡

02:10.400 --> 02:14.570
また､ 閉じる｡ 

02:14.570 --> 02:15.653
そして､ 今､ それを保存すると､ エラーなくコンパイルされるのです｡ 

02:19.130 --> 02:22.380
そして､ 実際に､ ここに､ これが画面にレンダリングされているのがわかります｡ 

02:22.380 --> 02:29.720
そして､ これはうまくいけば､ デコレーターの持つ力を示すことができます｡

02:29.720 --> 02:31.720
このように､ 本当に高度なデコレーターを構築することができ､

02:31.720 --> 02:34.780
突然､ 舞台裏で魔法をかけることができるのです｡

02:34.780 --> 02:38.500
そして､ それがメタプログラミングの意味するところです｡ 

02:38.500 --> 02:41.260
他のユーザーと共有するサードパーティーライブラリであれば､

02:41.260 --> 02:46.190
ここでいくつかのロジックを追加し､ 公開することができます｡

02:46.190 --> 02:47.890
これをライブラリの一部として公開すれば､

02:47.890 --> 02:57.408
ライブラリを利用する誰もがこのデコレータ関数をインポートしてクラスに追加し､ あるコンテンツを突然魔法のようにレンダリングできるようになります｡

02:57.408 --> 03:00.500
もちろん､ あなたは､ そのような制限もありません｡ 

03:00.500 --> 03:02.980
もし､ インスタンス化されたときに､

03:02.980 --> 03:05.340
クラスの一部である名前を出力したいのであれば､

03:05.340 --> 03:07.850
それも可能です｡

03:07.850 --> 03:09.570
結局､ ここでコンストラクタ：Functionを手に入れることになる｡ 

03:09.570 --> 03:12.427
さて､ これで何ができるかというと､

03:14.190 --> 03:16.010
コンストラクタを呼び出して､

03:16.010 --> 03:20.380
新しい人を作ることができます｡

03:20.380 --> 03:23.820
これをanyに変換して､ typescriptがこれを許可し､

03:23.820 --> 03:26.570
通常の関数と思わないようにします｡

03:26.570 --> 03:29.240
そして､ フック要素に移動して､ h1タグを問い合わせます｡

03:29.240 --> 03:35.160
もちろん､ 実際には､ 常にh1タグがあるとは限りません｡

03:35.160 --> 03:37.330
でも､ デモ用として､ ここに必ず1台は置くことを想定しています｡

03:37.330 --> 03:42.330
おっと､ 今見ると下のh1タグは必ず閉じた方が良いですね｡

03:42.330 --> 03:43.850
そして､ ここでは感嘆符を使って､

03:43.850 --> 03:49.900
やはり常にh1要素を見つけると仮定して､ textContentをpに等しく設定することができます｡

03:49.900 --> 03:49.900
という名前を付けます｡ 

03:49.900 --> 03:53.660
そうして保存すると､

03:53.660 --> 03:59.400
テンプレート内のオブジェクトの一部である名前が出力されます｡

03:59.400 --> 04:06.010
もちろん､ 私がここでやっているよりもずっと精巧なデコレータを書くことができます｡

04:06.010 --> 04:07.840
Typescriptを使用する大人気のフレームワーク､

04:07.840 --> 04:09.550
Angularを考えてみましょう｡

04:09.550 --> 04:12.270
このコンポーネント・デコレーターのように､

04:12.270 --> 04:21.020
デコレーターを使用して､ discomponentのテンプレートなどを指定するオブジェクトを渡すことができる｡

04:21.020 --> 04:23.950
そして､ このテンプレートがレンダリングされるべきDomのセレクタ｡

04:23.950 --> 04:25.760
これは､ ここで定義したものに比較的近いと思います｡ 

04:25.760 --> 04:28.170
テンプレート､ そしてそれをレンダリングする場所です｡ 

04:28.170 --> 04:31.230
言うまでもなく､ Angularのデコレーターは､

04:31.230 --> 04:36.550
ここで紹介する基本的なデコレーターよりもずっと高度で精巧なものです｡

04:36.550 --> 04:38.740
それでも､ 核となる考え方は同じです｡ 

04:38.740 --> 04:41.660
Angularはここでデコレータを提供し､

04:41.660 --> 04:51.760
コンポーネントがレンダリングされるときにdomにレンダリングされるHTMLコードをコンポーネントクラスに接続することができます｡

04:51.760 --> 04:53.830
Angularの仕組みが分からなくても､

04:53.830 --> 04:55.850
問題ありません｡

04:55.850 --> 04:57.060
クラスとデコレーターで動作することを理解した上で､

04:57.060 --> 05:01.300
ここでやったことを基本的に実行する必要があります｡

05:01.300 --> 05:03.600
このように､ デコレーターやデコレーター・ファクトリーを使うことで､

05:03.600 --> 05:06.400
もうひとつできることがあります｡

05:06.400 --> 05:12.210
なぜなら､ そうすることで､ ここで必要な余分な葛藤を受け流すことができるからです｡

05:12.210 --> 05:13.610
メタプログラミングというのも､ そういう意味です｡ 

05:13.610 --> 05:21.130
私たちは､ エンドユーザーに対して何らかの影響を及ぼすと思われるデコレーター機能を作っています｡

05:21.130 --> 05:24.840
NPのデュアルレンダリングとかで､ ここの画面に

05:24.840 --> 05:29.090
しかし､ 私たちはそれを他の開発者に公開するツールを使って行っています｡

05:29.090 --> 05:31.370
なぜなら､ このデコレーターは､ この例のようにクラスに追加することで､

05:31.370 --> 05:36.000
他の開発者が使わなければならないようなツールだからです｡

05:36.000 --> 05:38.580
そうでなければ､ これは何もできない｡ 

05:38.580 --> 05:40.300
ですから､ 私たちは開発者に特別なユーティリティを提供し､

05:40.300 --> 05:49.050
他の開発者はそれを使って､ 例えば､ 授賞式のために何かを便利にスクリーンにレンダリングすることができるのです｡

05:49.050 --> 05:50.590
それは､ ここでもAngularがやっていることと同じで､

05:50.590 --> 05:54.220
より高度な方法で､ グラディエーターに最適なものなのです｡
