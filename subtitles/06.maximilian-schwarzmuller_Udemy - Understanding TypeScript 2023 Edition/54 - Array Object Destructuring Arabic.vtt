WEBVTT

00:02.100 --> 00:04.870
المدرب: دعنا نلتزم بالمصفوفات والأشياء.

00:04.870 --> 00:06.750
هناك بناء جملة مهم آخر ، والذي ستراه

00:06.750 --> 00:09.160
كثيرًا في مشاريع JavaScript الحديثة وأيضًا

00:09.160 --> 00:10.440
في مشاريع Typescript

00:10.440 --> 00:13.133
، وهو تدمير المصفوفات والكائنات.

00:14.180 --> 00:15.013
كيف يعمل؟

00:15.013 --> 00:17.220
حسنًا ، لنبدأ بالمصفوفة التي حصلنا عليها

00:17.220 --> 00:20.220
، مجموعة الهوايات التي تحتوي على هواياتين.

00:20.220 --> 00:22.200
لنفترض أنك تريد استخراج

00:22.200 --> 00:26.340
هاتين الهويتين وتخزينهما في متغيرات أو ثوابت.

00:26.340 --> 00:28.891
بالطبع ، يمكننا فعل ذلك باستخدام

00:28.891 --> 00:32.340
هواية واحدة متساوية في هوايات المؤشر صفر

00:32.340 --> 00:34.820
، وهو العنصر الأول.

00:34.820 --> 00:38.720
والشيء نفسه ربما مع الهواية الثانية للهوايات في الفهرس الأول.

00:38.720 --> 00:40.500
سيؤدي ذلك إلى سحب هذين

00:40.500 --> 00:43.330
العنصرين وتخزينهما في ثوابت.

00:43.330 --> 00:44.720
استغرق الأمر سطرين من التعليمات البرمجية

00:44.720 --> 00:46.710
، وكلما زاد عدد العناصر التي تريد استردادها ، زاد عدد

00:46.710 --> 00:48.493
سطور التعليمات البرمجية التي نحتاجها.

00:49.340 --> 00:51.690
يسمح لنا تدمير المصفوفة بتقصيره.

00:51.690 --> 00:53.090
باستخدام خاصية تدمير المصفوفات

00:53.090 --> 00:56.250
، والتي تعمل أيضًا مع let بالمناسبة ليس فقط مع const ، يمكنك

00:56.250 --> 00:59.760
إضافة أقواس مربعة على الجانب الأيسر من علامة التساوي ، وهو مكان

00:59.760 --> 01:01.400
غير معتاد.

01:01.400 --> 01:02.900
لم أر ذلك من قبل.

01:02.900 --> 01:04.780
وعلى الجانب الأيمن لديك المصفوفة

01:04.780 --> 01:06.480
التي تريد تدميرها.

01:06.480 --> 01:08.430
يعني التدمير الآن حقًا أنك

01:08.430 --> 01:10.470
تسحب العناصر من المصفوفة.

01:10.470 --> 01:13.570
وهنا على الجانب الأيسر بين هذه الأقواس المربعة ، يمكنك

01:13.570 --> 01:15.040
تخزينها في ثوابت ، أو إذا

01:15.040 --> 01:17.250
استخدمت let ، في المتغيرات.

01:17.250 --> 01:21.170
لذا هنا ، يمكننا بعد ذلك الحصول على هواية واحدة وهواية اثنتين.

01:21.170 --> 01:23.000
وما يفعله هذا النحو هو أنه

01:23.000 --> 01:25.640
يمر عبر مصفوفة الهوايات ، ويأخذ العنصر

01:25.640 --> 01:26.920
الأول ويخزنه بشكل

01:26.920 --> 01:29.050
ثابت بهذا الاسم ، ويأخذ العنصر

01:29.050 --> 01:30.290
الثاني ، ويخزنه بشكل

01:30.290 --> 01:32.320
ثابت بهذا الاسم.

01:32.320 --> 01:35.490
يمكنك أيضًا إضافة معلمات الراحة هنا ولديك

01:35.490 --> 01:38.720
هوايات متبقية هنا في حالة احتواء مجموعة

01:38.720 --> 01:42.130
الهوايات على عناصر أكثر من عنصرين فقط.

01:42.130 --> 01:46.260
ثم سيتم تخزين جميع العناصر المتبقية التي لم تقم بسحبها إلى

01:46.260 --> 01:48.070
هواية واحدة أو هواية اثنين

01:48.070 --> 01:51.290
في مجموعة جديدة تسمى الهوايات المتبقية.

01:51.290 --> 01:54.090
لذلك سيتم دمجهم معًا في مصفوفة جديدة.

01:54.090 --> 01:57.940
بالمناسبة التدمير لا يغير المصفوفة الأصلية.

01:57.940 --> 02:02.940
حتى لو تعزية. هوايات السجل ، والهواية الأولى ، والهواية الثانية

02:04.260 --> 02:06.840
هنا ، سترى أن الهوايات لا تزال هي المصفوفة القديمة.

02:06.840 --> 02:08.840
إنه ليس فارغًا أو أي شيء من هذا القبيل.

02:08.840 --> 02:11.780
لذا فإن القيم التي سحبناها في علامات الاقتباس

02:11.780 --> 02:14.870
يتم نسخها فقط في ثوابت أو متغيرات جديدة ، ولا

02:14.870 --> 02:17.720
تتم إزالتها حقًا من المصفوفة.

02:17.720 --> 02:18.980
الآن هذا مصفوفة تدمير.

02:18.980 --> 02:20.600
لدينا نفس الشيء بالنسبة للأشياء.

02:20.600 --> 02:21.690
لدينا شخصنا هنا.

02:21.690 --> 02:23.440
لنفترض الآن أننا نريد تخزين

02:23.440 --> 02:26.630
الاسم والعمر في ثوابت أو متغيرات قائمة بذاتها.

02:26.630 --> 02:28.480
تمامًا مثل تدمير المصفوفة

02:28.480 --> 02:31.840
، يعمل تدمير الكائن مع كل من const و let.

02:31.840 --> 02:33.010
هنا سأذهب مع const.

02:33.010 --> 02:34.930
والآن يمكننا استخدام الأقواس المتعرجة

02:34.930 --> 02:37.090
على الجانب الأيسر من علامة التساوي.

02:37.090 --> 02:38.883
على الرغم من بناء الجملة الجديد ، على ما أعتقد.

02:39.920 --> 02:43.750
ولدينا الكائن ، أو المتغير الذي يشير إلى الكائن على الجانب

02:43.750 --> 02:44.890
الأيمن.

02:44.890 --> 02:46.110
بالمناسبة ، يرجى ملاحظة

02:46.110 --> 02:48.770
أن هذا ليس نوع كائن أقوم بتعيينه هنا.

02:48.770 --> 02:51.200
ليس لدي نقطتان هنا.

02:51.200 --> 02:54.080
إنها حقًا مجرد أقواس مجعدة مثل هذه

02:54.080 --> 02:58.210
على الجانب الأيسر بدون نقطتين بعد اسم ثابت.

02:58.210 --> 03:01.000
لذا فأنا لا أحدد نوع القيمة التي يمكن

03:01.000 --> 03:02.720
تخزينها بشكل ثابت.

03:02.720 --> 03:05.470
أنا فقط أستخدم صيغة خاصة.

03:05.470 --> 03:08.450
لأنه هنا ، يمكننا الآن أيضًا الرجوع

03:08.450 --> 03:11.340
إلى أسماء الخصائص التي لدينا في

03:11.340 --> 03:13.920
كائن ، على سبيل المثال ، الاسم

03:13.920 --> 03:18.030
والعمر ، لسحب قيم هذه المفاتيح من الشخص وتخزينها

03:18.030 --> 03:21.283
في ثوابت تحمل الاسم نفسه.

03:23.290 --> 03:24.390
الآن تظهر لي أخطاء

03:24.390 --> 03:27.820
لأنني في القمة لدي بالفعل متغير عمر.

03:27.820 --> 03:30.890
وقد تبين أن الاسم متغير متاح عالميًا موجود

03:30.890 --> 03:32.173
على أي حال.

03:33.240 --> 03:34.940
لذلك ، سيكون الحل هو استخدام

03:34.940 --> 03:38.313
اسم مفتاح مختلف هنا ، الاسم الأول ، على سبيل

03:40.240 --> 03:41.920
المثال.

03:41.920 --> 03:45.020
والآن يمكننا استخلاص القيمة من هذا المفتاح هنا.

03:45.020 --> 03:46.900
إذن هذه هي الطريقة التي يعمل بها تدمير الكائن.

03:46.900 --> 03:50.110
الشيء المهم هنا هو تدمير المصفوفة ،

03:50.110 --> 03:52.260
يتم سحب العناصر بالترتيب

03:52.260 --> 03:55.110
لأن المصفوفة هي قائمة مرتبة.

03:55.110 --> 03:58.110
في الكائنات ، لا يتم ضمان الترتيب دائمًا ، وبالتالي

03:58.110 --> 04:00.720
، فإننا لا نسحب العناصر حسب الموضع ، ولكن بالاسم

04:00.720 --> 04:02.070
الرئيسي.

04:02.070 --> 04:04.790
لذا فإن القيم أو الأسماء التي تحددها هنا

04:04.790 --> 04:05.930
بين الأقواس المتعرجة

04:05.930 --> 04:07.630
ليست عشوائية.

04:07.630 --> 04:09.700
لا يمكنك الخروج بأسماء هنا.

04:09.700 --> 04:13.860
يجب أن تكون هذه أسماء الخصائص التي تجدها في الكائن

04:13.860 --> 04:16.010
، بحيث يمكن سحب قيم هذه المفاتيح

04:16.010 --> 04:18.160
من الكائن ثم تخزينها في ثوابت

04:18.160 --> 04:21.880
أو متغيرات من نفس الاسم.

04:21.880 --> 04:24.120
إذا كنت تريد تجاوز هذا الاسم ، فيمكنك

04:24.120 --> 04:25.970
فعل ذلك بنقطتين هنا.

04:25.970 --> 04:28.050
مرة أخرى ، إنها ليست مهمة نوع هنا.

04:28.050 --> 04:29.680
إنه يضع اسمًا جديدًا فقط.

04:29.680 --> 04:31.970
لذلك هذا هو كل بناء جملة JavaScript

04:31.970 --> 04:33.820
، لا علاقة له بـ Typescript.

04:33.820 --> 04:35.370
لذلك يمكننا هنا تخزين

04:35.370 --> 04:38.750
هذا في ثابت اسم المستخدم على سبيل المثال.

04:38.750 --> 04:39.840
وبالتالي ، بعد

04:39.840 --> 04:44.040
ذلك ، يمكننا أن نواسي. سجل اسم المستخدم والعمر ، ولكن ليس

04:44.040 --> 04:45.290
الاسم الأول ، لأنه تم

04:45.290 --> 04:47.870
استبدال الاسم الأول بشكل أساسي ليتم تسميته

04:47.870 --> 04:50.900
اسم المستخدم في الثابت الذي نقوم بإنشائه عندما

04:50.900 --> 04:52.790
نقوم بسحب القيم هنا.

04:52.790 --> 04:55.880
لا يتم الكتابة فوق العمر ، لذلك يمكننا استخدامه بهذه الطريقة.

04:55.880 --> 04:58.183
مرة أخرى ، هذا ليس تعيين نوع هنا.

04:58.183 --> 05:00.210
هذا هو بناء جملة JavaScript

05:00.210 --> 05:03.680
، حيث نقوم بإعادة تسمية خاصية نقوم بسحبها

05:03.680 --> 05:05.500
من الشخص.

05:05.500 --> 05:07.430
أيضًا ، تمامًا كما كان من قبل مع

05:07.430 --> 05:09.840
المصفوفة ، لم يتغير كائن الشخص نفسه.

05:09.840 --> 05:13.380
نحن في الحقيقة ننسخ هذه القيم من الكائن.

05:13.380 --> 05:15.643
وبالتالي ، نحصل على هذا الناتج هنا.
