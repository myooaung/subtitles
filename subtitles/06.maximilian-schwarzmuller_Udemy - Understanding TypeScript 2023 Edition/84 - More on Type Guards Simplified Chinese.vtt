WEBVTT

00:02.220 --> 00:04.080
- ：现在交叉点类型是一回事｡ 

00:04.080 --> 00:07.800
然而, 另一个更常用的特性是类型保护,

00:07.800 --> 00:10.590
我们实际上已经用过一点了｡

00:10.590 --> 00:12.400
让我们在这里使用“可组合”｡ 

00:12.400 --> 00:15.560
这是一个联合类型, 我们可以使用字符串或数字,

00:15.560 --> 00:18.020
类型保护可以帮助我们使用联合类型,

00:18.020 --> 00:26.200
因为尽管灵活性很好, 但通常您需要知道在运行时获得的确切类型｡

00:26.200 --> 00:28.630
比如说我们有一个add函数, 我得到一个需要是可组合类型的数字,

00:28.630 --> 00:39.520
也就是一个字符串或者一个数字, 因此, 我在这里把它命名为a, 然后我得到另一个也需要是可组合类型的参数, 也就是一个数字或者一个字符串,

00:39.520 --> 00:44.640
然后我想返回a加上b｡

00:44.640 --> 00:47.020
现在我们在过去看到, 这是行不通的｡ 

00:47.020 --> 00:51.320
相反, 我们现在需要检查typeof a是否等于string,

00:51.320 --> 00:53.740
或者typeof b是否等于string,

00:55.660 --> 01:04.681
如果是, 我们返回a｡

01:04.681 --> 01:04.681
toString加上b｡  字符串｡ 

01:04.681 --> 01:06.750
我们把这两个字符串连接起来否则,

01:06.750 --> 01:09.570
如果不把它写进if语句, 我们就返回a加b,

01:09.570 --> 01:13.270
因为现在type group知道a和b必须是数字,

01:13.270 --> 01:19.710
因为如果它们中至少有一个不是数字, 我们就在这里｡

01:19.710 --> 01:22.890
这里我们称之为类型保护,

01:22.890 --> 01:27.980
因为它允许我们利用联合类型提供的灵活性,

01:27.980 --> 01:32.550
同时还能确保代码在运行时正确运行,

01:32.550 --> 01:38.160
因为通常你的函数会处理两到三个不同的类型,

01:38.160 --> 01:40.570
因此, 联合类型是完美的,

01:40.570 --> 01:43.890
但是你对值做什么取决于类型,

01:43.890 --> 01:46.940
就像这里, 我们要么连接,

01:46.940 --> 01:51.670
要么数学相加｡

01:51.670 --> 01:55.310
现在这是一个使用typeof的类型保护｡ 

01:55.310 --> 01:58.970
您还可以编写其他类型的保护｡ 

01:58.970 --> 02:00.880
为此, 让我回到上面的管理员和雇员类型,

02:00.880 --> 02:06.943
在那里我获得了管理员的权限和雇员的startDate权限｡

02:08.590 --> 02:11.810
现在我们有了ElevatedEmployee, 它将两者结合起来｡ 

02:11.810 --> 02:14.980
现在也在这里创建另一个类型｡ 

02:14.980 --> 02:16.330
这就是未知员工｡ 

02:18.000 --> 02:21.940
这要么只是一个员工, 要么是一个管理员｡ 

02:21.940 --> 02:25.540
因此, 我们有一个使用我的两个自定义对象类型的联合类型｡ 

02:25.540 --> 02:28.173
所以无名员工是两者之一｡ 

02:29.230 --> 02:32.003
现在, 我们可能有一个函数printEmployeeInformation,

02:34.620 --> 02:36.420
我需要在其中传入一个雇员, 该雇员的类型应该是unknown

02:36.420 --> 02:39.660
employee｡

02:39.660 --> 02:44.030
现在在这里, 我要聊以自慰｡  记录有关员工的各种信息｡

02:44.030 --> 02:48.580
例如, 来自emp的名称｡  name, 因为这两种类型的员工都有name属性,

02:48.580 --> 02:52.140
所以可以正常工作｡

02:52.140 --> 03:01.520
不过后来我也想安慰安慰自己｡  通过访问emp记录权限｡

03:01.520 --> 03:01.520
特权,

03:01.520 --> 03:04.350
这里我已经在自动完成中遇到了问题,

03:04.350 --> 03:16.260
因为TypeScript不能确认它总是存在于参数上, 因为UnknownEmployee可能是没有特权属性的普通雇员｡

03:16.260 --> 03:18.330
只有管理员才有｡ 

03:18.330 --> 03:20.100
所以现在我们需要一个类型的后卫｡ 

03:20.100 --> 03:24.530
问题是, 如果是typeof, 我们什么也赢不了｡ 

03:24.530 --> 03:26.830
如果我们检查employee的类型,

03:26.830 --> 03:29.470
在运行时它将只是对象｡

03:29.470 --> 03:32.940
但这并不能告诉我们它是否有这个属性｡

03:32.940 --> 03:34.960
因此, 如果我移动if检查中的代码,

03:34.960 --> 03:37.430
TypeScript并不会比以前更好,

03:37.430 --> 03:39.750
因为对象只是一个对象｡

03:39.750 --> 03:41.920
没有任何关于属性的信息｡ 

03:41.920 --> 03:44.980
我们不能检查它是否是Employee类型,

03:44.980 --> 03:48.130
因为JavaScript不知道它是什么类型,

03:48.130 --> 03:52.560
请记住, 这个检查在运行时运行并使用JavaScript,

03:52.560 --> 03:58.010
所以我们只能将typeof得到的类型与JavaScript知道的类型进行比较,

03:58.010 --> 04:05.610
即对象､ 字符串､ 数字和布尔值, 我们的自定义类型不属于它｡

04:05.610 --> 04:07.950
它只存在于TypeScript世界,

04:07.950 --> 04:11.020
而不存在于编译的JavaScript世界｡

04:11.020 --> 04:13.990
所以, 这也是行不通的｡ 

04:13.990 --> 04:17.960
现在, 我们的解决方法是使用不同的if检查｡ 

04:17.960 --> 04:20.240
我们知道我们想要访问权限,

04:20.240 --> 04:25.240
所以我们可以检查员工权限是否存在｡

04:26.400 --> 04:30.690
问题是TypeScript根本不允许我们访问这个属性,

04:30.690 --> 04:36.200
甚至不允许像这样检查它, 但是我们有一种不同的方法来检查它｡

04:36.200 --> 04:40.000
我们可以使用JavaScript内置的in关键字｡ 

04:40.000 --> 04:46.690
我们可以检查现在写为字符串的privileges是否在emp中｡

04:46.690 --> 04:49.130
这是JavaScript代码,

04:49.130 --> 04:53.480
允许检查this是否作为employee上的属性存在,

04:53.480 --> 04:58.380
如果是这样, TypeScript会在此处检测到此检查, 因此,

04:58.380 --> 05:04.543
如果在此处进行检查, 则允许我们访问this中的此属性｡

05:05.852 --> 05:08.380
我们可以对startDate重复这个过程,

05:08.380 --> 05:12.240
检查startDate是否是这里的一个属性,

05:12.240 --> 05:18.730
我们也可以在if check中输出这个属性｡

05:18.730 --> 05:23.687
现在, 如果我们调用printEmployeeInformation,

05:24.650 --> 05:37.430
并传入我们创建的一个雇员e1, 您将看到它编译无误, 并且确实输出了权限, 当然, 这里的数据也应该显示Start

05:37.430 --> 05:42.530
Date｡

05:42.530 --> 05:45.820
但这样一来, 它就给了我们预期的输出｡ 

05:45.820 --> 05:48.590
另一方面, 如果我们传入一个没有所有这些字段的雇员,

05:48.590 --> 05:53.090
例如, 如果我们动态创建一个只有startDate但没有特权的雇员,

05:53.090 --> 06:05.723
那么所有的工作和编译都没有错误, 我们只是不打印任何关于特权的内容, 因为如果我们在那里有检查｡

06:07.650 --> 06:09.800
在使用类时, 还可以使用另一种类型的类型保护,

06:09.800 --> 06:16.520
即instanceof类型保护｡

06:16.520 --> 06:21.460
假设我们有一个类, Car, 它有一个驱动方法,

06:21.460 --> 06:26.523
叫做console.

06:26.523 --> 06:26.523
log

06:28.480 --> 06:31.750
Driving, 我们还有另一个类, Truck,

06:31.750 --> 06:34.623
它也有一个驱动方法, 或者你可以说Driving

06:35.840 --> 06:40.250
a truck, 但我们必须说方法名.

06:40.250 --> 06:43.980
我们还有一个loadCargo方法,

06:43.980 --> 06:46.570
其中有一个金额, 是一个数字,

06:46.570 --> 06:49.040
这里我有一些虚拟代码,

06:49.040 --> 06:53.570
我说, "加载货物加金额. 差不多吧, 额, 差不多吧｡ 

06:53.570 --> 06:59.320
那么现在我们有两个类, 其中当然有一些相似之处,

06:59.320 --> 07:02.090
驱动方法, 但是也有区别｡

07:02.090 --> 07:03.890
现在, 我们可以在这里创建一个并集类型,

07:03.890 --> 07:08.200
Vehicle, 它可以是Car或Truck, 现在, 假设我们创建一个新的Vehicle,

07:08.200 --> 07:18.030
v1, 它是一个新的Car, 以及另一个Vehicle, v2, 它是一个新的Truck｡

07:18.050 --> 07:21.873
现在我有了一个函数useVehicle,

07:23.890 --> 07:31.350
它只希望得到一个车辆, 应该是vehicle类型, 所以应该是这个联合类型.

07:31.350 --> 07:40.040
现在我们有了一辆车, 我们的目标是做所有我们能做的事：驾驶并装载货物｡

07:40.040 --> 07:45.420
所以, 当然, 我们可以称之为车辆｡  驾驶, 因为它一直存在, 但是对于车辆

07:45.420 --> 07:45.420
loadCargo,

07:45.420 --> 07:50.010
我们有个问题, 因为只有卡车有这个｡

07:50.010 --> 07:52.720
车里没有这个, 所以这个行不通｡ 

07:52.720 --> 07:56.440
当然, 现在我们可以再次检查loadCargo是否在车辆中,

07:56.440 --> 07:59.513
如果是, 我们就可以使用它｡

08:00.760 --> 08:05.760
至少如果我把这里的错字改好｡ 

08:06.430 --> 08:09.480
我们现在保存它, 然后调用useVehicle,

08:09.480 --> 08:13.230
传入v1, 然后用v2再次调用它, 我保存了所有的内容,

08:13.230 --> 08:17.400
它编译了, 运行了.

08:17.400 --> 08:21.680
这是一种方法｡ 

08:21.680 --> 08:23.340
另一种方法是使用instanceof,

08:23.340 --> 08:31.920
这种方法可能会更优雅一些, 因为它还消除了在此处输入该属性字符串时出错的风险｡

08:31.920 --> 08:34.080
我们可以检查车辆是否为Truck的实例｡ 

08:34.080 --> 08:39.080
如果是这种情况, 我们知道它将有一个loadCargo方法｡ 

08:39.360 --> 08:42.510
instanceof是普通JavaScript中内置的一个普通运算符,

08:42.510 --> 08:47.430
因此这不是TypeScript代码｡

08:47.430 --> 08:49.280
就像typeof一样, 这是JavaScript的一部分,

08:49.280 --> 08:52.250
它在运行时执行｡

08:52.250 --> 08:54.290
JavaScript不知道Truck类型,

08:54.290 --> 09:06.580
但它知道构造函数, 最后类只是被转换为构造函数, 然后TypeScript能够找出车辆是否基于Truck构造函数创建｡

09:06.580 --> 09:11.970
因为类被编译成JavaScript能理解的东西,

09:11.970 --> 09:15.450
构造函数, 它就能使用它.

09:15.450 --> 09:17.210
如果我们在这里使用接口,

09:17.210 --> 09:22.950
而不是类, 当然, 我们不能在这里实现, 但我们会在用对象文字符号创建对象时实现,

09:22.950 --> 09:25.130
那么我们就不能使用instanceof,

09:25.130 --> 09:34.370
因为接口, 正如你所学到的, 不会编译成任何JavaScript代码, 因此, 我们不能在运行时使用它们.

09:34.370 --> 09:37.160
对于类, 我们可以这样做, 因为JavaScript支持类和构造函数,

09:37.160 --> 09:44.500
通过instanceof, 你可以发现某个对象是否基于那个类｡

09:44.500 --> 09:47.660
如果我们知道它是否是, 那么我们将有一个loadCargo函数｡ 

09:47.660 --> 09:51.850
这些是典型的守卫｡ 

09:51.850 --> 09:53.480
最后, 类型保护只是一个术语,

09:53.480 --> 09:59.470
它描述了在尝试使用某个属性或方法之前检查它是否存在,

09:59.470 --> 10:08.470
或者在尝试使用它之前检查它是否可以对类型做一些事情的想法或方法｡

10:08.470 --> 10:10.220
对于对象, 可以使用instanceof或in来完成,

10:10.220 --> 10:19.780
对于其他类型, 可以使用typeof, 因此, 您现在可以灵活地使用联合类型提供的灵活性, 并且仍然可以编写代码,

10:19.780 --> 10:29.050
然后根据您在运行时获得的确切类型来完成一件事或另一件事｡
