WEBVTT

00:02.400 --> 00:04.390
教师：我们渲染了第一个表单,

00:04.390 --> 00:09.200
但您会注意到样式有点不对, 我的意思是表单看起来不错,

00:09.200 --> 00:13.870
但屏幕边缘和表单之间的距离会更好｡

00:13.870 --> 00:15.830
如果你进入应用程序｡  css文件中,

00:15.830 --> 00:21.050
您实际上会发现其中有一个用户输入ID选择器｡

00:21.050 --> 00:23.330
如果我们真的添加一些边距填充, 这听起来并不太糟糕,

00:23.330 --> 00:28.060
所以实际上我们可以做的是一个应用程序｡

00:28.060 --> 00:28.060
我们在这里创建元素或者访问它｡

00:31.740 --> 00:36.840
我们可以访问该元素并在此处添加一个用户输入的ID｡

00:36.840 --> 00:39.740
这将确保呈现的元素具有此ID, 因此,

00:39.740 --> 00:42.800
如果重新加载, 这看起来会更好｡

00:42.800 --> 00:45.100
如果我们在浏览器深度中对此进行检查,

00:45.100 --> 00:49.320
我们会在此处看到ID, 这就是这种更好样式的原因｡

00:49.320 --> 00:54.010
我们已经在做下一步了, 我们在和元素互动｡

00:54.010 --> 00:56.980
这不是我唯一想做的互动｡ 

00:56.980 --> 00:58.770
由于这里有一个表单,

00:58.770 --> 01:01.870
因此我想访问这里的不同表单输入,

01:01.870 --> 01:08.800
以便在提交表单时读取值, 然后在这里设置一个事件侦听器来进行提交,

01:08.800 --> 01:12.160
并验证用户输入｡

01:12.160 --> 01:15.720
因此, 我们需要访问按钮或整个表单,

01:15.720 --> 01:19.180
以监听提交, 并访问所有输入元素,

01:19.180 --> 01:21.273
以从中获取最新值｡

01:22.360 --> 01:25.440
在我们附加所有内容之前, 但在我给元素分配ID之后,

01:25.440 --> 01:28.500
我想访问表单中元素的不同输入,

01:28.500 --> 01:44.570
我想将它们存储为该类的属性, 所以我将在上面添加更多字段, 第一个字段可以是titleInputElement字段｡

01:44.570 --> 01:47.167
类型将是HTMLInputElement写入此,

01:48.060 --> 01:52.770
并且我们将不仅仅需要它, 一旦我们需要另外两个类似的字段｡

01:52.770 --> 01:55.900
我们需要一个descriptionInputElement字段,

01:55.900 --> 01:57.550
它是一个HTMLInputElement类型,

01:58.520 --> 02:02.730
我们还需要一个peopleInputElement字段｡

02:02.730 --> 02:11.510
现在我们可以在构造函数中填充这些字段, 使用设置为等于此的titleInputElement｡

02:11.510 --> 02:11.510
元素,

02:11.510 --> 02:13.120
因此对于我们的表单元素,

02:13.120 --> 02:16.390
请始终记住这里的表单元素, 查询选择器,

02:16.390 --> 02:21.350
然后查询标题元素｡

02:21.350 --> 02:25.000
而如果再看一下索引｡  我们在这里看到了这个元素的ID标题,

02:25.000 --> 02:33.323
这样我们就可以查询它, 所以在app中｡

02:33.323 --> 02:33.323
在查询选择器中,

02:33.323 --> 02:39.750
我们可以使用#title来选择标题ID元素, 并将其存储在titleInputElement中｡

02:39.750 --> 02:44.070
现在, 正如您所知, 就像document get element

02:44.070 --> 02:50.650
by ID一样, typescript没有机会理解查询选择器将在此处返回输入元素｡

02:50.650 --> 02:53.780
为了告诉typescript, 我将再次使用转换, 并将其转换为一个输入元素,

02:53.780 --> 03:03.240
然后我们可以重复这一步骤两次, 并对descriptionInputElement和peopleInputElement进行签名｡

03:03.240 --> 03:06.600
在索引中查找相应的ID｡  html文件, 我猜,

03:06.600 --> 03:12.190
这是令人惊讶的描述和人, 并将它们添加到typescript｡

03:12.190 --> 03:17.720
这里我们搜索description ID元素, 这里搜索people｡

03:17.720 --> 03:19.510
这样我们就可以访问类中的所有元素,

03:19.510 --> 03:26.593
或者访问基于类创建的每个对象中的元素.

03:27.600 --> 03:33.330
现在我们只需要在元素和表单中添加一个侦听器｡

03:33.330 --> 03:38.330
为此, 我将添加另一个私有方法configure,

03:38.440 --> 03:39.790
您不必添加它,

03:39.790 --> 03:47.900
但我希望保持这种分离, 我们基本上在构造函数中进行选择和粗略设置｡

03:47.900 --> 03:52.210
然后以单独的方法进行插入或微调｡

03:52.210 --> 03:53.900
在configure方法中,

03:53.900 --> 03:58.970
我的想法是设置一个事件侦听器, 因此在这里我们可以访问这个元素, 即表单,

03:58.970 --> 04:01.830
并添加一个事件侦听器｡

04:01.830 --> 04:04.570
现在, 由于typescript知道该元素是HTML表单元素,

04:04.570 --> 04:12.250
因此当我们希望在此处监听submit事件时, 它实际上为我们提供了自动完成功能, 这非常棒｡

04:12.250 --> 04:15.520
现在我们只需要把它绑定到一个方法上,

04:15.520 --> 04:17.840
为此我会添加另一个私有方法,

04:17.840 --> 04:20.650
因为我永远不会从类的外部访问它,

04:20.650 --> 04:23.460
只能从内部访问.

04:23.460 --> 04:26.970
我将其命名为submitHandler, 名称完全由您决定｡ 

04:26.970 --> 04:32.750
这应该是一个接收事件对象的方法, 因为我们将把它绑定到这个事件侦听器｡

04:32.750 --> 04:34.880
所以我们可以指向这个...

04:36.460 --> 04:38.713
提交处理程序｡ 

04:40.180 --> 04:42.080
现在, 我们调整它, 以确保在附加所有调用之前,

04:42.992 --> 04:46.730
配置并执行此private方法, 它也是private的,

04:46.730 --> 04:59.290
因此, 从类内部, 我们当然可以访问它, 从外部, 您将得到一个typescript错误, 因此, 无论何时提交表单, 都应触发此方法｡

04:59.290 --> 05:02.010
在提交处理程序中, 我想访问不同的输入值,

05:02.010 --> 05:10.310
并验证它们, 然后对这些输入做一些处理.

05:10.310 --> 05:12.700
现在, 我们将在以后考虑执行某项操作的部分,

05:12.700 --> 05:15.480
现在让我们来访问它们｡

05:15.480 --> 05:20.620
对于这个首先我将称之为事件｡  preventDefault用于阻止默认的表单提交,

05:20.620 --> 05:32.730
这将触发发送HTTP请求, 我不希望在这里看到这一点, 然后看看它在哪里工作, 让我们打印控制台｡

05:32.730 --> 05:32.730
记录这个title元素值,

05:32.730 --> 05:36.250
以打印title输入元素中的当前内容｡

05:36.250 --> 05:39.010
如果我们保存了它, 你会看到它编译时没有错误,

05:39.010 --> 05:40.560
所以看起来不错｡

05:40.560 --> 05:44.670
如果我们现在转到控制台并输入“Hello！ 然后单击“添加项目, "好的方面是它没有提交,

05:44.670 --> 05:51.657
坏的方面是我们得到一个错误, “无法读取未定义的属性'值'｡

05:51.657 --> 05:51.657
现在出什么问题了？

05:51.657 --> 05:56.173
这里的问题是, submitHandler中的这个关键字实际上并没有指向类.

05:57.730 --> 06:02.230
为什么？

06:02.230 --> 06:06.420
由于JavaScript和typescript的工作方式,

06:06.420 --> 06:07.760
我们将这里的方法绑定到事件侦听器,

06:07.760 --> 06:17.480
当我们将某个对象绑定到事件时, 或者在事件侦听器的帮助下, 将某个对象绑定到要执行的方法时, 该对象将绑定到其他对象,

06:17.480 --> 06:24.210
在本例中是绑定到事件的当前目标｡

06:24.210 --> 06:27.270
因此, 当使用事件侦听程式在事件上触发此方法时,

06:27.270 --> 06:35.130
此方法的这一端不会指向类别｡

06:35.130 --> 06:40.360
现在的解决方案是在submitHandler上调用bind,

06:40.360 --> 06:56.450
预先配置函数在将来执行时的执行方式, 我们传递给bind的第一个参数就是this关键字在要执行的函数中引用的参数.

06:56.450 --> 07:05.750
这里我传递this, 这意味着, submitHandler内部的this将引用与this在上下文中引用的相同的内容｡

07:05.750 --> 07:10.030
因为我们在configure的上下文中调用它, 我们用configure调用它,

07:10.030 --> 07:13.660
configure的这个端点将引用类, 由于bind,

07:13.660 --> 07:22.870
它将在那里为所有, 也引用submitHandler的类端点｡

07:22.870 --> 07:24.830
所以如果你现在把它保存在这里,

07:24.830 --> 07:30.743
我们重新加载, 然后输入“Hello！

07:30.743 --> 07:30.743
“在这里,

07:32.840 --> 07:35.600
你现在看到“Hello！ “在我们提交表单时打印在此处｡

07:35.600 --> 07:38.770
所以现在这个问题解决了, 现在我们正在正确地处理这个问题｡

07:38.770 --> 07:40.210
但也许有一个更好的方法,

07:40.210 --> 07:43.650
或者一个我们都知道的替代方法｡

07:43.650 --> 07:49.430
也许一个使用装饰器, 所以现在你有机会再次暂停,

07:49.430 --> 07:51.970
尝试用装饰器解决这个绑定问题,

07:51.970 --> 07:57.900
因为这是我们在装饰器部分学到的东西｡
