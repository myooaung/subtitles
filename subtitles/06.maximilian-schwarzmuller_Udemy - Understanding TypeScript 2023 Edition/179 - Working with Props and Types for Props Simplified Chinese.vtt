WEBVTT

00:02.170 --> 00:04.780
- ：因此, 我们的目标是构建一个to-do列表组件, 因此在源文件夹中,

00:04.780 --> 00:11.280
我将添加一个新的子文件夹､ 组件, 并在其中添加一个“to-doList”｡

00:11.280 --> 00:11.280
tsx”文件,

00:11.280 --> 00:13.690
它将保存我的to-do列表组件｡

00:13.690 --> 00:15.370
现在, 要构建react组件,

00:15.370 --> 00:17.030
我们需要从“react”导入React,

00:17.030 --> 00:20.250
否则JXS将无法在此文件中工作｡

00:20.250 --> 00:22.820
然后我创建了一个to-do列表常量,

00:22.820 --> 00:24.530
它存储了一个箭头函数, 当然这不一定是一个箭头函数,

00:24.530 --> 00:30.320
你也可以使用一个函数, 带有function关键字.

00:30.320 --> 00:33.160
现在, 我们将导出此内容｡ 

00:33.160 --> 00:39.370
现在, 让我们使用额外的typescript特性, 并设置this的类型以进行响应｡

00:39.370 --> 00:39.370
fc,

00:39.370 --> 00:43.950
以指示这不应该是常规函数, 而是功能组件｡

00:43.950 --> 00:49.790
因此, 我们会得到一个错误, 因为我们没有返回符合react元素条件的元素｡

00:49.790 --> 00:53.250
在这里, 我们应该返回, 比如一个无序列表｡ 

00:53.250 --> 00:54.850
因为我想在这里呈现一个列表,

00:54.850 --> 00:58.000
所以现在返回一个无序列表是有意义的｡

00:58.000 --> 01:02.740
现在, 在无序列表上, 我想要输出列表项｡ 

01:02.740 --> 01:07.230
在这里, 我们可以得到to-dos, 这是一个数组,

01:07.230 --> 01:09.240
在数组中我们有一个对象,

01:09.240 --> 01:11.690
每个项都有一个ID.

01:11.690 --> 01:18.100
让我们假设t1代表待办事项, 以及类似于“完成课程”的文本｡

01:18.100 --> 01:18.100
这只是一个项目,

01:18.100 --> 01:20.800
但当然您可以在此数组中拥有多个此类对象｡

01:20.800 --> 01:22.010
在我们的列表中, 我们可以动态地输出待办事项,

01:22.010 --> 01:24.620
并将它们映射到列表项列表中｡

01:24.620 --> 01:29.620
在这里, 我们检查所有的to-do, 这是一个内置的JavaScript函数,

01:30.250 --> 01:41.530
当然是map函数, 我们为数组中的每个元素返回一个列表项, 在列表项中, 我设置了“to-do”｡

01:41.530 --> 01:41.530
text”作为列表项上的内容,

01:41.530 --> 01:49.620
并添加这个特殊的关键属性, React实际上希望在彼此相邻的重复元素上使用这个属性｡

01:49.620 --> 01:51.980
在这里, 我们应该选择一些唯一的东西,

01:51.980 --> 01:54.130
ID应该符合唯一标识符的条件｡

01:54.130 --> 01:57.710
这样, 我们就呈现了一个待办事项列表｡ 

01:57.710 --> 02:00.470
现在让我们将to-do列表组件集成到应用程序组件中,

02:00.470 --> 02:02.860
为此, 我们当然可以转到应用程序组件,

02:02.860 --> 02:06.930
从““中导入“TodoList”“｡

02:06.930 --> 02:06.930
/components/TodoList”类似于下面的“｡

02:06.930 --> 02:14.350
tsx”扩展名将由我们在这里使用的构建工作流自动添加｡

02:14.350 --> 02:18.850
然后在我们的div中, 我们可以像这样呈现“TodoList”｡

02:18.850 --> 02:21.440
如果我们现在保存它并返回到运行页面,

02:21.440 --> 02:24.190
我们会在这里看到这个待办事项｡

02:24.190 --> 02:25.870
造型是可怕的, 我们可以添加更好的造型后,

02:25.870 --> 02:29.350
但目前, 这应该是好的｡

02:29.350 --> 02:31.680
然而, 这并不现实｡ 

02:31.680 --> 02:40.063
当我们构建这个待办事项列表应用程序时, 我希望以后能够用一个我们还没有的单独组件添加新的待办事项｡

02:40.063 --> 02:42.920
我们可能会在这个应用程序组件中管理待办事项,

02:42.920 --> 02:55.280
因为在这个地方, 我们将有一个添加待办事项的组件, 该组件将能够与这个应用程序组件进行对话｡

02:55.280 --> 02:56.690
在这里, 我们管理待办事项数组,

02:56.690 --> 03:01.510
并向该数组添加待办事项或从该数组中删除待办事项｡

03:01.510 --> 03:04.220
然后将该数组传递给to-do列表｡ 

03:04.220 --> 03:06.930
因此, 即使我们还没有管理它, 我们也可能不会在to-do列表中,

03:06.930 --> 03:11.660
而是在应用程序组件中拥有“todos”数组｡

03:11.660 --> 03:16.740
更实际的情况是, 该数组稍后将在此处结束, 因此我们已经可以将其移动到此处｡

03:16.740 --> 03:20.093
现在, 我们需要将它传递给“TodoList”｡  为此, 我们当然可以使用道具｡ 

03:20.930 --> 03:23.600
因此, 在待办事项列表中, 您可以有一个项目属性,

03:23.600 --> 03:25.640
名称当然由我们决定, 因为我们正在定义此组件,

03:25.640 --> 03:30.350
我们可以定义其属性的命名方式｡

03:30.350 --> 03:32.100
我们可以输入“todos”数组｡ 

03:32.100 --> 03:35.010
现在, 我们已经看到IDE不喜欢这样, 如果我尝试保存它,

03:35.010 --> 03:37.820
我们也会得到一个编译错误｡

03:37.820 --> 03:45.400
出现编译错误, 因为属性“items”在类型whatever上不存在｡

03:45.400 --> 03:52.070
所以它基本上不存在于这个交集类型上, 这个交集类型最终定义了“TodoList”接收到的props的结构｡

03:52.070 --> 03:52.070
因为在React中使用typescript时,

03:52.070 --> 03:55.300
您必须清楚所使用的类型｡

03:55.300 --> 03:59.470
这不仅仅意味着你告诉typescript这是一种特殊的函数,

03:59.470 --> 04:02.110
不, 它还意味着如果你依赖于某个组件中的道具,

04:02.110 --> 04:08.360
你告诉typescript这些道具应该是什么样子的,

04:08.360 --> 04:11.020
它们是如何构造的｡

04:11.020 --> 04:14.860
所以在to-do列表组件中, 我们在这里接收到props,

04:14.860 --> 04:17.420
对, 这是常规的React｡

04:17.420 --> 04:19.400
在道具上, 我们可能有物品的属性｡ 

04:19.400 --> 04:30.323
因此, 我们有一个名为“项目”的道具, 这确实是我在这里所说的：“我有这个道具道具｡

04:30.323 --> 04:30.323
现在的问题是,

04:31.420 --> 04:33.430
从技术上讲, 这是可行的, 但typescript还没有中止｡

04:33.430 --> 04:37.140
我们并没有告诉typescript我们的prop应该在这里有一个“items”属性｡

04:37.140 --> 04:39.503
为了说明这一点, 我们可以使用这个事实,

04:39.503 --> 04:45.063
即这里的函数组件类型实际上是一个泛型类型｡

04:45.063 --> 04:46.913
一个泛型类型, 我们可以在其中定义所有额外的属性,

04:47.840 --> 04:52.170
除了每个组件都有的默认子属性, 这是我们在这里所期望的｡

04:52.170 --> 04:54.250
所以我们可以在这里添加尖括号,

04:54.250 --> 04:58.132
并添加描述这个“props”对象的结构的对象,

04:58.132 --> 05:03.670
或者, 为了让代码更简洁, 我们在这里的一个额外的接口中完成这个操作,

05:03.670 --> 05:06.170
这是完全可选的｡

05:06.170 --> 05:09.670
这里我们可以列出待办事项列表中的道具,

05:09.670 --> 05:12.350
这描述了我们的道具的样子｡

05:12.350 --> 05:15.120
在这里, 我希望得到一个“items”键,

05:15.120 --> 05:18.260
这里有一个对象数组, 每个对象都有一个ID,

05:18.260 --> 05:20.510
也就是字符串, 还有一个文本,

05:20.510 --> 05:23.380
也就是字符串｡

05:23.380 --> 05:26.120
这就是我们在这里管理的数据｡ 

05:26.120 --> 05:32.850
我们有一个包含ID字符串和文本字符串的对象数组｡

05:32.850 --> 05:34.370
这就是我希望得到的, props,

05:34.370 --> 05:36.070
一个这样的对象数组, 如果我们在这里,

05:36.070 --> 05:38.940
我们现在可以指向这个to-do列表props接口,

05:38.940 --> 05:40.700
现在一切都好了｡ 现在typescript明白了,

05:40.700 --> 05:42.670
这里我们将得到props, 其中我们将有一个items

05:42.670 --> 05:45.040
prop, 这个items prop将是一个数组,

05:45.040 --> 05:55.000
其中我们在每个数组元素上都有一个ID键和一个文本键｡

05:55.000 --> 05:56.920
现在如果我们保存它, 它就会编译,

05:56.920 --> 05:58.870
我们又会得到工作输出｡

05:58.870 --> 05:59.850
这是React使用打字稿

05:59.850 --> 06:02.390
我们不仅仅用它来告诉React或者typescript,

06:02.390 --> 06:10.000
这是一个函数组件, 还告诉它这个组件最终会得到什么, 这对我们的类型安全有很大帮助.

06:10.000 --> 06:15.130
它避免了我在这里不小心想到它被命名为“todos”｡

06:15.130 --> 06:15.130
否, 不支持此操作, 我们会收到错误｡ 

06:15.130 --> 06:19.060
它是物品｡ 

06:19.060 --> 06:21.165
你们都将看到他们在这里自动完成｡ 

06:21.165 --> 06:23.330
因此, 在这里使用typescript时,

06:23.330 --> 06:24.910
编码变得容易得多｡ 这当然就是打字稿的全部优点：它简化了编码, 避免了不必要的错误,

06:24.910 --> 06:28.400
正如你所看到的, 它在一个react应用程序中也是如此｡

06:28.400 --> 06:30.670
当然, 我们还没说完｡ 

06:30.670 --> 06:34.420
目前, 我们这里的待办事项从未改变,

06:34.420 --> 06:36.640
我想改变这一点,

06:36.640 --> 06:44.120
我想有一个组件, 允许我们添加新的待办事项｡

06:44.120 --> 06:46.080
接下来让我们来研究这个问题｡ 
