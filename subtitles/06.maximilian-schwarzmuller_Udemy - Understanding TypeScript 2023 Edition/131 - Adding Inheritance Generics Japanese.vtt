WEBVTT

00:02.410 --> 00:06.370
講師：それでは､ 継承と基底クラスについて説明しましょう｡

00:06.370 --> 00:09.189
基本的には､ templateElement､ hostElement､

00:09.189 --> 00:12.090
その中の要素､ dom内の要素を選択するこの仕事をするもの､

00:12.090 --> 00:18.520
常に必要なattachメソッドを持つもの､ などをベースクラスとして追加したいのです｡

00:18.520 --> 00:22.540
つまり､ Domに実際に何かをレンダリングするクラスが共通に持つ､

00:22.540 --> 00:28.220
これらすべての共有機能を管理するものです｡

00:28.220 --> 00:30.880
そのために､ ProjectInputとProjectListクラスの上に､

00:30.880 --> 00:38.250
基本的にここに､ Component Base Classを追加します｡

00:38.250 --> 00:41.540
ReactやAngularを扱っている人はこの言葉を知っているかもしれませんし､

00:41.540 --> 00:53.950
そうでない人も､ これらのクラスは画面にレンダリングするUI､ ユーザーインターフェイスコンポーネントと考えることができるからです｡

00:53.950 --> 00:57.950
そして､ どのコンポーネントも最終的にはレンダリング可能なオブジェクトであり､

00:57.950 --> 01:01.370
レンダリングを可能にするいくつかの機能を備えています｡

01:01.370 --> 01:05.260
そして､ 具象インスタンス､ つまり継承されたクラスは､

01:05.260 --> 01:10.260
この特定のコンポーネントが必要とする追加機能を追加する｡

01:10.300 --> 01:14.370
では､ 一般的なコンポーネントクラスには何が入るのでしょうか？

01:14.370 --> 01:17.590
まあ､ この3つの要素は間違いなく言えるでしょう｡ 

01:17.590 --> 01:21.390
templateElement､ hostElement､ elementの4つです｡ 

01:21.390 --> 01:23.590
しかし､ ここで問題なのは､

01:23.590 --> 01:25.470
タイプに関してです｡

01:25.470 --> 01:28.320
templateElement は常に HTMLTemplateElement

01:29.160 --> 01:31.980
ですが､ hostElement は常に div である必要はありません｡

01:31.980 --> 01:37.160
例えば､ プロジェクト アイテム クラスを追加する場合､ ProjectList でレンダリングし､ 直接ルート

01:37.160 --> 01:42.360
div でもない､ つまり常に div である必要はないのです｡

01:42.360 --> 01:47.040
しかし､ ProjectInputクラスの場合のように､

01:47.040 --> 01:55.230
実際には､ どこか特定の形式のHTMLFormElementであることが分かっています｡

01:55.230 --> 01:57.540
そのため､ より具体的な情報を保存せずに､

01:57.540 --> 02:05.220
常にHTMLE要素だけを持つように制限すると､ この余分な情報が失われてしまうのです｡

02:05.220 --> 02:07.690
では､ どうすればそれを回避できるのか｡ 

02:07.690 --> 02:10.050
ただ継承するだけでなく､ ここに汎用的なクラスを作り､

02:10.050 --> 02:17.680
それを継承したときに具体的な型を設定することができるのです｡

02:17.680 --> 02:20.940
そのために､ クラス名の後に角括弧を付け､

02:20.940 --> 02:26.690
さらにTとUのように､ 一般的な選択肢である2つの識別子を付けます｡

02:26.690 --> 02:34.820
そして､ ここでいくつかの制約を加え､ Tは必ずある種のHTMLElementになると言うこともできる｡

02:34.820 --> 02:36.770
単なるHTMLElementであったり､

02:36.770 --> 02:38.970
より具体的なバージョンであったりします｡

02:38.970 --> 02:41.870
そして､ Uも同様です｡ 

02:41.870 --> 02:46.690
そして､ ここではhostElementがT型､ elementがU型であることが分かっています｡

02:46.690 --> 02:48.660
そして､ このクラスを継承するたびに具象型を指定できるようになったので､

02:48.660 --> 02:54.780
継承する場所によって異なる型を扱うことができるようになりました｡

02:56.050 --> 02:58.053
さて､ ここでコンストラクタも追加しておきましょう｡ 

02:58.910 --> 03:03.060
そのコンストラクタの中で､ ちょっとした情報が必要になります｡

03:03.060 --> 03:05.950
テンプレートを選択する方法を知るために､ テンプレートのIDを知る必要があり､

03:05.950 --> 03:09.750
それは文字列でなければなりません｡

03:09.750 --> 03:11.590
このコンポーネントをどこにレンダリングすればよいかを知るために､

03:11.590 --> 03:13.050
hostElementIdを知る必要があり､

03:13.050 --> 03:15.833
これも文字列である必要があります｡

03:17.440 --> 03:22.590
また､ newElementId を取得して､ 新しくレンダリングされた要素に割り当てるべき

03:22.590 --> 03:24.350
ID を取得したいと思います｡

03:24.350 --> 03:29.690
しかし､ これはオプションであり､ 私はパラメータの後にクエスチョンマークを追加することでそれを示しています｡

03:29.690 --> 03:31.940
ここでundefinedも型として受け入れるという方法もありますが､

03:31.940 --> 03:36.470
ここではクエスチョンマークを使うことにします｡

03:36.470 --> 03:39.793
このコードを Component

03:40.640 --> 03:42.083
クラスのコンストラクタに入れると､

03:43.810 --> 03:52.060
templateElement が保存されます｡ もちろん､ ここで取得する ID は

03:52.060 --> 03:57.450
templateId です｡

03:57.450 --> 04:00.060
そしてhostElementには､ もちろんここにあるIDがhostElementIdで､

04:00.060 --> 04:02.733
こんな感じです｡

04:04.790 --> 04:07.930
また､ もちろん､ ここでのキャストに関しても重要で､ これはT型であることが分かっています｡

04:07.930 --> 04:12.580
なぜなら､ ここでのTは､ 保存する､ あるいはhostElementに使用する､ この汎用型であり､

04:12.580 --> 04:17.163
ここではすでにキャストすることができます｡

04:18.160 --> 04:20.253
それに伴い､ エレメントを選択しているところです｡ 

04:21.130 --> 04:22.940
また､ より多くのコードをつかむことができます｡ 

04:22.940 --> 04:26.650
このコードで､ ノードなどをインポートし､ IDを設定すれば､

04:26.650 --> 04:30.130
そのすべてを取得することができます｡

04:30.130 --> 04:35.317
これをコピーして､ Componentクラスのコンストラクタに追加してみましょう｡

04:35.317 --> 04:37.640
輸入されたノード､ 次に要素を設定します｡

04:37.640 --> 04:41.080
ここの要素は一般的なタイプUを持っているので､ ここでこれをキャストすると､

04:41.080 --> 04:43.000
そのUタイプになることが分かっているので､

04:43.000 --> 04:46.870
これをUにキャストする必要があります｡

04:46.870 --> 04:51.993
これはジェネリックスの良い使い方で､ このComponentクラスは本当に再利用可能です｡

04:53.060 --> 04:55.200
さて､ IDについてですが｡ 

04:55.200 --> 04:58.200
ここで得られるのがnewElementIdです｡ 

04:58.200 --> 05:00.590
もちろん､ オプションなので､ 常にあるとは限りませんので､

05:00.590 --> 05:03.870
ある場合は確認しておきましょう｡

05:03.870 --> 05:06.070
つまり､ newElementIdがモノである場合､ そしてそれがモノである場合のみ､

05:06.070 --> 05:07.650
私はそれを割り当てようとします､ そうでなければ､

05:07.650 --> 05:13.023
我々はそれを試みません､ なぜなら､ その時､ 我々は割り当てるべきIDを持たないからです｡

05:14.420 --> 05:16.300
さて､ これでコンストラクタができました｡ 

05:16.300 --> 05:19.160
では､ ここでアタッチ機能を使ってみましょう｡ 

05:19.160 --> 05:21.970
そこで､ 他のクラスからattachメソッドをコピーして､

05:21.970 --> 05:28.473
Componentクラスのプライベートメソッドとしてここに追加してみましょう｡

05:32.690 --> 05:38.540
そして､ これを呼び出すこともできる｡  を Component クラスのコンストラクタの末尾にアタッチします｡

05:38.540 --> 05:39.960
さて､ ここでは要素を追加したいのですが､

05:39.960 --> 05:42.570
どこに追加すればいいのかわかりません｡

05:42.570 --> 05:46.450
そこで､ 実際にここで取得すべき追加情報があります｡

05:46.450 --> 05:56.680
コントラクタの4番目の引数として､ insert Atstartは名前であり､ これはブール値であるとします｡

05:56.680 --> 06:00.190
そして､ それをオプションのパラメーターの前に移動させる必要があります｡ 

06:00.190 --> 06:02.230
オプションのパラメータは､ 人が省略する可能性があるため､

06:02.230 --> 06:03.980
常に最後に置く必要があります｡

06:03.980 --> 06:09.220
したがって､ 必須パラメータは､ これらのオプションパラメータの後に来ることはできません｡

06:09.220 --> 06:12.700
insertAtStartはattachに転送され､

06:12.700 --> 06:23.470
そこでinsertAtBeginning（混乱を避けるためにここでは別の名前を使っています）がブール値として受け取られます｡

06:23.470 --> 06:28.040
そして､ ここでinsertAtBeginningがtrueかどうかをチェックします｡

06:28.040 --> 06:34.887
trueの場合は､ ここでafterbeginを､ それ以外の場合はbeforeendを指定します｡

06:36.770 --> 06:39.653
あとは､ これをどのように挿入するかは柔軟に対応します｡ 

06:42.980 --> 06:46.570
また､ このクラスを抽象クラスとしてマークしたいと思います｡ なぜなら､

06:46.570 --> 06:52.560
人々はこのクラスを直接インスタンス化してはならず､ 常に継承のために使用しなければならないからです｡

06:52.560 --> 06:56.090
そこで､ classの前に､ abstractというキーワードを追加しています｡ 

06:56.090 --> 06:58.750
これで､ 今はインスタンス化できないことを確認しました｡ 

06:58.750 --> 07:01.963
そんなことをしたら､ TypeScriptに怒鳴られますよ｡ 

07:04.070 --> 07:06.490
さらに､ configureメソッドと､

07:06.490 --> 07:10.840
renderContentメソッドを追加します｡

07:10.840 --> 07:13.430
抽象的なメソッドとして追加します｡ つまり､

07:13.430 --> 07:16.463
具体的な実装はここではありませんが､ 基本的には､

07:18.000 --> 07:21.080
componentを継承するすべてのクラスに､

07:21.080 --> 07:25.980
これら2つのメソッドを追加して利用可能にすることを強制しています｡

07:25.980 --> 07:27.220
これは､ もし他の人が私たちのコードを見たときに､

07:27.220 --> 07:34.150
Componentクラスの背後にある考え方が何であるかをよく理解できるように､ ここに書き加えているのです｡

07:34.150 --> 07:38.530
一般的なレンダリングやコンポーネントの取り付けはすべて行いますが､

07:38.530 --> 07:43.840
具体的な内容や設定は､ その後､ 継承した場所で行う必要があるということです｡

07:43.840 --> 07:47.670
余談ですが､ プライベートで抽象的なメソッドは持てません｡ 

07:47.670 --> 07:49.660
だから､ ここではprivateを省略しなければならない｡

07:49.660 --> 07:52.000
これはTypeScriptでは許されないことだ｡

07:52.000 --> 07:54.590
さて､ これでProjectListのComponentを拡張して､

07:54.590 --> 07:59.130
これら3つのプロパティを取り除くことができます｡

07:59.130 --> 08:00.640
assignedProjectsは､

08:00.640 --> 08:03.520
ProjectListに固有のものなので､ そのままにしておきます｡

08:03.520 --> 08:09.560
また､ 一般的な型に差し込むべき具体的な値を指定することもできます｡

08:09.560 --> 08:12.410
そして､ これを元に戻すと､ HTMLDivElementとHTMLElementがあることがわかるので､

08:12.410 --> 08:25.830
ここでは､ このようにHTMLDivElementとHTMLElementを渡して､ これらの3つのプロパティを取り除くことにしましょう｡

08:25.830 --> 08:29.510
コンストラクタでは､ ここでは必要ありませんが､ 代わりに､

08:29.510 --> 08:35.130
最初にsuperを呼び出して､ ベースクラスのコンストラクタを呼び出す必要があり､

08:35.130 --> 08:40.840
そのために､ superコンストラクタに､ いくつかの情報を渡す必要があります｡

08:40.840 --> 08:42.753
templateElementのID､

08:44.050 --> 08:47.870
hostElementId､ hostElementの先頭に挿入するかどうか､

08:47.870 --> 08:51.920
そして､ 新しい要素に割り当てるべきIDを指定します｡

08:51.920 --> 08:54.038
これがテンプレートIDです｡ これで､

08:54.038 --> 08:57.811
このテンプレートを取り除くことができます｡

08:57.811 --> 09:02.670
それから､ ここのhostElementですが､ そのIDはappでしたので､ これを取り除くことができます｡

09:02.670 --> 09:04.260
assignedProjectsはまだ必要なので､

09:04.260 --> 09:06.400
残しておきます｡

09:06.400 --> 09:08.193
ここでこれを取り除くのですが､

09:10.150 --> 09:16.850
新しい要素のIDについては､ 実は4番目のパラメータとして渡したいのです｡

09:16.850 --> 09:19.040
3つ目は､ これをどこに挿入するかです｡

09:19.040 --> 09:22.400
ここでは､ 終わりの前に挿入することにしているので､

09:22.400 --> 09:32.283
insertAtStartの値のパラメータとしてここに挿入したいのはfalseです｡

09:36.000 --> 09:38.940
さて､ 確かにここでリスナーを設定したい｡ 

09:38.940 --> 09:40.730
しかし､ アタッチメントを呼び出す必要はなく､

09:40.730 --> 09:44.410
それはベースクラスやベースコンポーネントで行われます｡

09:44.410 --> 09:46.253
renderContentを呼び出しますが｡ 

09:47.870 --> 09:50.010
そして､ ここではこの型は使わず､ ただの型を使うべきです｡

09:50.010 --> 09:54.410
なぜなら､ superの実行が終了する前に､ この型を使うことができないからです｡

09:54.410 --> 09:57.690
でも､ 引数として型をもらっているから問題ない｡

09:57.690 --> 09:59.680
ProjectListにアタッチメソッドがあり､

09:59.680 --> 10:07.330
それが基底クラスにあるアタッチメソッドと衝突しているためです｡

10:07.330 --> 10:10.600
そこで､ このアタッチメソッドをここで解消してしまいましょう｡ 

10:10.600 --> 10:14.024
なぜなら､ renderContentはprivateですが､

10:14.024 --> 10:16.060
ここではpublicメソッドとして指定しているので､

10:16.060 --> 10:22.860
privateにしたいところですが､ privateな抽象メソッドはサポートされていないのです｡

10:22.860 --> 10:28.170
ここでprivateキーワードを削除して､

10:28.170 --> 10:31.990
1つの問題が残りました｡

10:31.990 --> 10:33.650
では､ 追加してみましょう｡ 

10:33.650 --> 10:40.510
ここでは､ renderConfigの他に､ ここでは何もしていないが､ configureを追加することができる｡

10:40.510 --> 10:42.950
あるいは､ ここにクエスチョンマークを追加してオプションのメソッドに変換すれば､

10:42.950 --> 10:47.520
強制的に追加する必要はありません｡

10:47.520 --> 10:50.380
ここで､ ProjectListのために､

10:50.380 --> 10:56.490
リスナーを設定するコードをconfigureに入れたと主張することもできますので､

10:56.490 --> 10:58.530
追加しておきます｡

10:58.530 --> 11:05.220
そのため､ リスナーの設定を行うことができます｡

11:05.220 --> 11:06.610
そして今度は､ renderContentを呼び出すことを確認するだけでなく､

11:06.610 --> 11:10.653
このような構成にする必要があります｡

11:12.730 --> 11:16.450
なぜ､ 抽象クラスのコンストラクタでconfigureやrenderContentを呼ばないのかというと､

11:16.450 --> 11:23.720
そうすることもできるのだが､ その場合､ 問題が生じる可能性がある｡

11:23.720 --> 11:26.760
Componentクラスでこれを呼び出すと､ 継承したクラスのメソッドを呼び出すことになります｡

11:26.760 --> 11:33.240
Componentを継承したクラスで､ renderContentやconfigureが何かに依存している場合､

11:33.240 --> 11:39.410
継承したクラスのコントラクタが､ ベースクラスのコントラクタが終了した後に､ 実際に何かをセットアップし､

11:39.410 --> 11:48.100
renderContentやconfigureに依存している可能性があります｡

11:48.100 --> 11:50.690
そのため､ 基本的には､ ベースクラスがこれらのメソッドを呼び出すのではなく､

11:50.690 --> 11:56.860
継承するクラスがこれらのメソッドを呼び出さなければならないようにする方が安全なのです｡

11:57.980 --> 12:01.280
そこで､ ProjectList クラスを再構築し､

12:01.280 --> 12:05.040
継承と共有ロジックを利用するようにしました｡

12:05.040 --> 12:07.730
今度はProjectInputについて同じことをやってみましょう｡ 

12:07.730 --> 12:13.170
そこで､ Componentも拡張したい｡

12:13.170 --> 12:14.900
その汎用性を利用して､ hostElementにはHTMLDivElementを､

12:14.900 --> 12:23.980
レンダリングされる要素にはHTMLFormElementを使用します｡

12:23.980 --> 12:27.210
これで､ ここにある3つのプロパティを取り除くことができますので､

12:27.210 --> 12:28.310
そうしてみましょう｡

12:28.310 --> 12:30.090
もちろん､ これらの3つのプロパティは､ ProjectInputに特有のものなので､

12:30.090 --> 12:32.140
そのままにしておきます｡

12:33.040 --> 12:39.900
Superには､ テンプレートのID（ProjectInput）､

12:39.900 --> 12:41.970
ホストエレメントのID（app）､

12:41.970 --> 12:50.510
insertBeforeをtrueで渡します｡

12:50.510 --> 12:53.110
そして､ newElementIdですが､ これはユーザーからの入力なので､

12:53.110 --> 12:56.913
これも転送する必要があります｡

12:57.844 --> 12:59.400
これで､ このコード､ このコード､

12:59.400 --> 13:03.480
そして実際にここにあるすべてのコードを取り除くことができます｡

13:03.480 --> 13:05.240
もちろん､ このコードはここに保管しておいてください｡ 

13:05.240 --> 13:09.860
しかし､ これをconfigure maybeに入れたということもできます｡

13:09.860 --> 13:12.100
それでは､ configureメソッドに移動して､

13:12.100 --> 13:13.660
リスナーを追加するか､ プロパティ設定を追加して､

13:13.660 --> 13:17.683
configureしてみましょう｡

13:18.880 --> 13:20.780
もちろん､ attachは捨てましょう｡

13:20.780 --> 13:26.980
今はベースクラスがやってくれることですから｡ そして､ TypeScriptが何を嫌っているかを確認しましょう｡ もちろん､

13:26.980 --> 13:29.690
ここのattachは取り除くべきです｡

13:29.690 --> 13:40.380
というのも､ コンストラクタの中でconfigureが呼び出されて初期化されることを理解していないか､

13:40.380 --> 13:44.770
チェックしていないからだ｡

13:44.770 --> 13:47.500
そこで､ TypeScriptを満足させるために､

13:47.500 --> 13:52.170
これらの初期化をconfigureからコンストラクタに戻そうと思う｡

13:52.170 --> 13:55.953
技術的には全く同じ結果だが､ これでTypeScriptから文句を言われることはないだろう｡

13:56.800 --> 14:02.310
しかし､ プライベートなconfigureメソッドを持っていると文句を言われるので､

14:02.310 --> 14:08.940
前と同じようにこれを変更し､ configureをパブリックなメソッドにする必要があります｡

14:08.940 --> 14:13.000
必ずやらなければならないことではありませんが､ パブリックメソッドを最初に用意するのは慣習のようなものなので､

14:13.000 --> 14:17.240
ここでは他のプライベートメソッドよりも上に持ってきています｡

14:17.240 --> 14:19.370
そしてもちろん､ 今度は renderContent

14:19.370 --> 14:21.990
メソッドがないことにも文句を言う｡

14:21.990 --> 14:25.020
では､ 必要だからということで､ 1つ追加します｡ 

14:25.020 --> 14:26.780
ここでは何もしていないので､

14:26.780 --> 14:31.053
技術的には必要ありませんが､ これでベースクラスは完成です｡

14:32.260 --> 14:34.603
余談ですが､ ProjectListクラスのrenderContentとconfigureも､

14:35.550 --> 14:45.123
先ほど述べた規約と全く同じ理由で､ このプライベートメソッドの上に移動させることが可能です｡

14:46.440 --> 14:49.870
また､ それに伴い､ ProjectInputの構造も再構築し､

14:49.870 --> 14:55.330
継承を利用して､ 多くの仕事をベースクラスに任せるようにしました｡

14:55.330 --> 14:57.670
これですべてうまくいくかどうか､ 見てみましょう｡ 

14:57.670 --> 15:00.710
これを保存すると､ エラーもなくコンパイルされ､

15:00.710 --> 15:02.740
問題なく動作するようなので､

15:02.740 --> 15:05.870
これがうまくいくかどうかが問題です｡

15:05.870 --> 15:07.810
しかも､ これがなかなかいい感じなんですよ｡ 

15:07.810 --> 15:09.720
以前と同じように動作しますが､

15:09.720 --> 15:11.600
継承のおかげでコードの再利用が可能になり､

15:11.600 --> 15:15.850
よりクリーンなコードになりました｡

15:15.850 --> 15:18.540
さて､ 相続できるのはここだけではありません｡ 

15:18.540 --> 15:20.610
この講義の最後に､ プロジェクトの状態をリファクタリングすることで､

15:20.610 --> 15:24.230
この講義を締めくくりたいと思います｡

15:24.230 --> 15:26.240
技術的には､ このアプリケーション全体で管理する状態は1つだけなので､

15:26.240 --> 15:35.310
継承は必要ありません｡ しかし､ より大きなアプリケーションで､ 複数の異なる状態がある場合を想像してみてください｡

15:35.310 --> 15:37.240
1つはユーザーの状態､ ユーザーがログインしているかどうかなど､

15:37.240 --> 15:43.030
1つはプロジェクト､ 1つはショッピングカートのためのものです｡

15:43.030 --> 15:48.080
さて､ ステートクラスのいくつかの機能は常に同じであることにお気づきでしょう｡

15:48.080 --> 15:52.780
具体的には､ そのリスナーの配列と､ addListenerメソッドです｡

15:52.780 --> 15:54.730
ですから､ ここでベースクラスを使うこともできます｡ 

15:55.650 --> 15:58.170
ここではStateというクラスを使うことができ､

15:58.170 --> 16:09.160
そのクラスにはリスナー配列があり､ そのクラスにはaddListenersメソッドもあるので､ ProjectStateから両方を切り出してStateに追加します｡

16:09.160 --> 16:16.720
さて､ このことは､ リスナーが実際にプロジェクトの配列を返すかどうかがわからないということも意味します｡

16:16.720 --> 16:24.740
そこで､ 実はこの関数型には､ 汎用的な型も用意したいのです｡

16:24.740 --> 16:27.440
これを外から設定できるように｡ 

16:27.440 --> 16:28.483
このように､

16:29.790 --> 16:31.623
汎用的な型､ つまりカスタム型を書き､

16:32.680 --> 16:42.460
型名の後に角括弧を付け､ 任意の識別子を使用し､ その型をここで再利用することができます｡

16:42.460 --> 16:44.960
ここで､ Stateをジェネリックにすると､

16:44.960 --> 16:46.320
カスタムタイプとは異なる構造であるため､

16:46.320 --> 16:49.530
同じ識別子を使用できます｡

16:49.530 --> 16:53.520
そしてここで､ リスナーのリストを持ちたいと言ったとき､ 作成するStateオブジェクトに対して､

16:53.520 --> 17:01.510
リスナーがどの汎用タイプを使用するかをTypeScriptに伝えなければならない｡

17:01.510 --> 17:03.850
そして､ それは単純に､ 汎用タイプをここと､

17:03.850 --> 17:06.490
ここに転送すればいいということです｡

17:06.490 --> 17:12.630
つまり､ stateを拡張する際には､ このstateが扱うデータの種類を指定する必要があり､

17:12.630 --> 17:17.680
stateの代わりに､ リスナーのカスタムタイプに転送されます｡

17:17.680 --> 17:19.580
そして､ そのすべてをどう使うか？

17:19.580 --> 17:21.950
ProjectStateクラスでは､

17:21.950 --> 17:36.510
Stateクラスを単純に拡張し､ 一般的なプレースホルダーに具象的な値を与えています｡

17:36.510 --> 17:37.393
プロジェクト

17:38.970 --> 17:41.650
さて､ このプライベートコンストラクタには､

17:41.650 --> 17:45.160
お分かりのように問題があります｡

17:45.160 --> 17:48.350
そうだな､ ぜひそうしよう､ ここでスーパーを呼ぼう､

17:48.350 --> 17:49.800
そうすればいいんだ｡

17:50.640 --> 17:55.880
そして､ 下にスクロールしていくと､ リスナーがprivateであることがわかりますが､

17:55.880 --> 18:00.240
これはベースクラスでprivateになっています｡

18:00.240 --> 18:01.860
さて､ それはつまり､ ベースクラスの内部からしかアクセスできない､

18:01.860 --> 18:03.580
ということです｡

18:03.580 --> 18:06.760
しかし､ もう一つのアクセス修飾子について学びましたね｡

18:06.760 --> 18:09.380
privateと似ていますが､ 継承したクラスからのアクセスも許可するもので､

18:09.380 --> 18:14.990
それはprotectedになるでしょう｡

18:14.990 --> 18:18.930
Protectedは､ そのクラスの外からはアクセスできないが､

18:18.930 --> 18:23.030
継承するクラスからはアクセスできることを意味します｡

18:23.030 --> 18:24.740
これで､ すべて保存しましょう､

18:24.740 --> 18:26.650
うまくコンパイルできるはずです｡

18:26.650 --> 18:31.790
しかし今度は､ 状態管理にも継承とジェネリクスを使用して､

18:31.790 --> 18:38.363
もう少しすっきりしたコードになっています｡
