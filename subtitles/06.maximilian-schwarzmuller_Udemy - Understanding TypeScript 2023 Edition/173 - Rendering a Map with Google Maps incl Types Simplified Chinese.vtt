WEBVTT

00:02.120 --> 00:05.300
男：那我们现在怎么在地图上输出坐标呢？

00:05.300 --> 00:08.180
同样, 我们将使用Google API｡ 

00:08.180 --> 00:10.690
如果你搜索谷歌JavaScript地图,

00:10.690 --> 00:16.970
或者谷歌JS地图, 你会找到谷歌JavaScript谷歌地图API的官方文档｡

00:16.970 --> 00:19.660
在这里, 您将了解如何在Web应用程序中使用Google

00:19.660 --> 00:22.020
Maps来渲染地图｡

00:22.020 --> 00:24.720
而且非常直接简单｡ 

00:24.720 --> 00:27.280
首先, 我们需要在此处添加此脚本, 它将把此Google

00:27.280 --> 00:31.720
Maps SDK添加到我们的应用程序中｡

00:31.720 --> 00:34.220
因此, 只需获取该脚本, 并将其添加到您的索引html文件中,

00:34.220 --> 00:38.210
在您的脚本之上｡

00:38.210 --> 00:40.670
现在重要的是, 我们不安装这个NPM,

00:40.670 --> 00:42.920
因为它没有发布到NPM, 因此我们使用这个CDN链接,

00:42.920 --> 00:48.140
它直接从Google的服务器拉脚本｡

00:48.140 --> 00:51.560
这里我们需要设置API_KEY｡ 

00:51.560 --> 00:54.390
当然, 这就是我们在typescript文件中已经拥有的API_KEY,

00:54.390 --> 01:02.170
因此我们可以将其复制到索引html中, 并用它替换YOUR_API_KEY｡

01:02.170 --> 01:07.150
最后还要去掉这个“&amp;callback=initMap”,

01:07.150 --> 01:10.240
一旦这个映射被加载, 或者这个SDK被加载,

01:10.240 --> 01:14.843
它就会触发一个函数, 这不是我想要的｡

01:15.840 --> 01:19.760
这样, 我们就加载了这个SDK, 现在我们可以使用它了,

01:19.760 --> 01:24.250
但这里有一个问题｡

01:24.250 --> 01:28.710
我想用它来渲染一个地图, 而渲染一个地图实际上是很简单的｡

01:28.710 --> 01:33.870
在官方文档中, 我们看到最后我们必须实例化这个google｡

01:33.870 --> 01:33.870
地图｡  映射构造函数,

01:33.870 --> 01:38.960
传递一个中心给它, 它本质上是...

01:38.960 --> 01:43.250
我们从后面得到的这对坐标, 加上一个缩放级别｡

01:43.250 --> 01:45.820
所以我们可以复制这个, 然后在这里一旦我们得到了坐标,

01:45.820 --> 01:53.750
执行这个代码, 然后把地图存储在一个名为“Map”的常量中｡

01:53.750 --> 01:53.750
当然, 我们在这里得到了一个错误｡ 

01:53.750 --> 01:55.117
“找不到名称google”,

01:55.117 --> 01:57.600
这是有道理的, 这将不会在全球可用,

01:57.600 --> 02:01.320
但typescript不知道这一点｡

02:01.320 --> 02:03.380
由于我们导入了JavaScript

02:03.380 --> 02:06.300
SDK, 它将在全球范围内可用｡

02:06.300 --> 02:08.343
当然, typescript并不知道这一点｡ 

02:09.390 --> 02:14.200
你会学到你可以在那里做什么, 你当然可以使用“declare

02:14.200 --> 02:19.200
var google”, 并将其设置为any｡

02:19.990 --> 02:21.020
你告诉打字稿, “没关系,

02:21.020 --> 02:22.887
这个会存在的, 别担心｡ 我们可以做到这一点, 错误就会消失｡ 

02:22.887 --> 02:26.480
现在我们也可以在这里使用我们的坐标, 而不是硬编码的坐标,

02:26.480 --> 02:33.480
如果我们还想渲染一个标记, 这也是可能的｡

02:33.480 --> 02:37.930
在官方文档中, 只需点击“添加带标记的地图”,

02:37.930 --> 02:39.517
我们了解到, 添加标记非常简单,

02:39.517 --> 02:41.520
我们只需使用创建的地图,

02:41.520 --> 02:47.223
使用此命令创建标记, 然后指向此地图｡

02:49.040 --> 02:50.950
所以我们把这段代码复制到这里,

02:50.950 --> 02:52.980
然后回到我们的代码中, 在我们创建了地图之后,

02:52.980 --> 02:59.160
我创建了这样的标记, 这里的位置也是我的坐标｡

02:59.160 --> 03:01.160
这将渲染一个地图,

03:01.160 --> 03:04.173
并在上面放置一个标记｡

03:05.040 --> 03:10.350
唯一剩下的事情是, 我们需要确保这个地图渲染在正确的位置｡

03:10.350 --> 03:14.010
默认情况下, 它查找带有I的元素｡  D. “地图”, 这就是我们这里所拥有｡

03:14.010 --> 03:18.720
但如果你选择了不同的我｡  D. 在这里, 请确保在您打字脚本代码中对此进行调整｡

03:18.720 --> 03:20.470
如果我们保存它,

03:20.470 --> 03:26.890
它编译时不会出错, 现在如果我在这里输入一个地址,

03:26.890 --> 03:30.640
它应该会呈现这个｡

03:30.640 --> 03:33.450
这是可行的, 我们可以调整这里的缩放级别,

03:33.450 --> 03:35.320
再放大一点, 例如将其改为16,

03:35.320 --> 03:40.370
现在如果我们尝试这样做, 我们可以看得更清楚一点｡

03:40.370 --> 03:42.910
但它正在起作用, 这是我们可以告诉｡ 

03:42.910 --> 03:45.640
我们可以在地图上滚动, 然后使用它｡ 

03:45.640 --> 03:47.480
这一切都很好, 但它不是最佳的｡ 

03:47.480 --> 03:50.420
当然, 它的工作, 由于“声明var谷歌”,

03:50.420 --> 03:53.340
我们没有得到任何错误｡

03:53.340 --> 03:56.760
但我们也没有得到任何类型支持｡ 

03:56.760 --> 03:58.810
如果我引入一个错误,

03:58.810 --> 04:06.730
例如, 如果我引用“｡ 映射”而不是“｡  maps”, 它编译时没有任何问题, 只是在生产环境中崩溃｡

04:06.730 --> 04:08.860
如果我试着渲染一张地图｡ 

04:08.860 --> 04:11.280
现在我在这里得到了一个错误, 由我们的错误处理程序捕获｡ 

04:11.280 --> 04:13.150
所以这当然不是我们想要的｡ 

04:13.150 --> 04:19.770
我们需要类型支持, 我们需要在开发期间而不是在运行时处理这样的转储错误｡

04:19.770 --> 04:22.880
那么, 我们如何确保打印脚本知道谷歌地图呢？

04:22.880 --> 04:27.380
类型来救援｡ 

04:27.380 --> 04:31.080
如果你搜索“types google maps”, 你会发现各种各样的包,

04:31.080 --> 04:34.160
这些包为谷歌地图添加了类型｡

04:34.160 --> 04:41.050
现在我们没有通过NPM安装Google Maps包, 但是我们仍然可以通过NPM安装该包的类型｡

04:41.050 --> 04:46.160
在这里, 我将选择第一个包, 并将其安装到我们的项目中｡

04:46.160 --> 04:48.790
让我们回到快速开发服务器, 运行“npm install

04:48.790 --> 04:51.560
--save-dev“@types/googlemaps”,

04:51.560 --> 04:54.030
一个词｡

04:54.030 --> 04:56.400
这是这个包裹的名字｡ 

04:58.613 --> 05:01.560
现在将安装此包的全局类型｡ 

05:01.560 --> 05:03.303
现在, 如果我用NPM

05:04.200 --> 05:08.410
start重新开始, 让我们看看是否有更好的情况｡

05:08.410 --> 05:11.500
如果我在这里删除“declare

05:11.500 --> 05:15.180
var”, 或者注释掉它｡

05:15.180 --> 05:18.090
它仍然编译, 现在这个谷歌地图的东西在这里被检测到,

05:18.090 --> 05:19.940
如果我试图访问“｡ map”, 我得到一个错误, 我现在也得到自动完成,

05:19.940 --> 05:27.010
它看到, “是的, 有一个地图的东西｡

05:27.010 --> 05:27.010
它还告诉我,

05:27.010 --> 05:29.880
这个映射构造函数需要一个“Div”或“Element”, 在这里它应该将映射作为第一个参数呈现,

05:29.880 --> 05:35.100
然后是映射的一些选项｡

05:35.100 --> 05:38.660
所以这是现在工作在这里, 因为它应该｡ 

05:38.660 --> 05:40.270
这当然是向前迈出的一大步,

05:40.270 --> 05:42.850
因为现在我们有了工作应用程序,

05:42.850 --> 05:45.170
它以前也工作过｡

05:45.170 --> 05:47.600
但是现在它也可以使用类型,

05:47.600 --> 05:51.170
并且具有适当的类型支持｡

05:51.170 --> 05:58.500
这是另一个很好的练习, 可以练习如何使用类型脚本构建应用程序和使用某些类型的特性,

05:58.500 --> 06:03.700
但对于如何使用第三方库, 这尤其是一个很好的练习｡

06:03.700 --> 06:06.250
有些, 像“axios”带来了自己的类型｡ 

06:06.250 --> 06:08.470
其他的, 甚至没有与NPM一起安装,

06:08.470 --> 06:15.421
但是您可以使用适当的类型包添加类型｡

06:15.421 --> 06:18.810
我希望这个模块对理解这一点有所帮助, 并对您将来可能从事的所有项目有所帮助,

06:18.810 --> 06:27.040
在这些项目中, 您很可能也会使用某些第三方库｡
