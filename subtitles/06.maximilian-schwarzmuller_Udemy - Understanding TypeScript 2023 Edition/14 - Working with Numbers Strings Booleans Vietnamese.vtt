WEBVTT

00:01.850 --> 00:03.270
Giảng viên: Vì vậy, bây giờ chúng

00:03.270 --> 00:06.760
ta đã biết về các nguyên tắc cơ bản của TypeScript và nó khác nhau như thế

00:06.760 --> 00:09.661
nào cũng như tất cả những điều này liên quan đến JavaScript,

00:09.661 --> 00:11.410
hãy tìm hiểu sâu hơn một chút về các loại

00:11.410 --> 00:14.148
cốt lõi khác nhau mà TypeScript biết.

00:14.148 --> 00:17.490
Số là loại mà chúng ta thấy ở đây, và như tôi đã giải thích, không

00:17.490 --> 00:18.500
có sự khác biệt giữa

00:18.500 --> 00:22.050
các số nguyên như số năm ở đây và số float hoặc double, như nó được gọi

00:22.050 --> 00:24.330
trong các ngôn ngữ lập trình khác, chẳng hạn

00:24.330 --> 00:25.640
như 2. 8 ở đây.

00:25.640 --> 00:28.440
Thật vậy, trong JavaScript và điều này cũng đúng trong TypeScript,

00:28.440 --> 00:30.810
tất cả các số đều là số float theo mặc định.

00:30.810 --> 00:33.270
Vì vậy, đối với JavaScript, và do đó, cũng như đối với TypeScript,

00:33.270 --> 00:35.171
không có sự khác biệt giữa năm cái như thế này

00:35.171 --> 00:36.770
và năm cái như thế này.

00:36.770 --> 00:38.640
Đó là cùng một số, về cơ bản.

00:38.640 --> 00:42.720
Bây giờ, ngoài số, chúng tôi còn có các loại lõi khác.

00:42.720 --> 00:46.350
Và đó sẽ là các chuỗi, vì vậy văn bản và booleans.

00:46.350 --> 00:47.800
Chúng ta hãy cũng có một cái nhìn vào những.

00:47.800 --> 00:50.650
Chúng tôi thực sự đã thấy tất cả những thứ đó đang hoạt động ở đây trong

00:50.650 --> 00:53.291
câu lệnh if này, điều mà chúng tôi đã học được là hơi thừa.

00:53.291 --> 00:55.971
Tuy nhiên, đây sẽ là một chuỗi.

00:55.971 --> 00:57.720
Ngoài ra, tất nhiên, năm với dấu

00:57.720 --> 01:00.389
ngoặc kép sẽ là một chuỗi vì đó là văn bản.

01:00.389 --> 01:03.851
Và kết quả, ví dụ, của sự so sánh này ở đây, đó sẽ là một

01:03.851 --> 01:05.170
giá trị logic.

01:05.170 --> 01:08.090
Toán tử này, dấu bằng ba hoặc toán

01:08.090 --> 01:10.950
tử đẳng thức bị phủ định ở đây, tạo

01:10.950 --> 01:13.640
ra giá trị đúng hoặc sai.

01:13.640 --> 01:14.720
Và, tất nhiên, chúng

01:14.720 --> 01:17.340
ta có thể tạo một kiểm tra InternalRef động, điều

01:17.340 --> 01:18.850
mà chúng ta thường làm.

01:18.850 --> 01:22.340
Hoặc chúng ta khởi tạo một biến với giá trị true hoặc false, vì vậy hãy thực

01:22.340 --> 01:23.379
hiện cả hai ở đây.

01:23.379 --> 01:27.509
Ở đây, chúng ta có thể thêm một hằng số mới, "printResult".

01:27.509 --> 01:29.990
Và đặt điều này thành true chẳng hạn.

01:29.990 --> 01:31.320
Và để làm cho nó thực sự rõ ràng,

01:31.320 --> 01:33.130
đây cũng có thể là một biến số.

01:33.130 --> 01:34.460
Nó không phải là const.

01:34.460 --> 01:36.030
Nó có thể là một biến mà bạn sẽ tạo

01:36.030 --> 01:37.730
bằng let trong JavaScript.

01:37.730 --> 01:39.870
Nhưng vì tôi không có ý định thay đổi nó ở đây, nên tôi

01:39.870 --> 01:40.703
sẽ chọn một hằng số.

01:40.703 --> 01:43.670
Và chúng ta có thể chuyển cái này thành tham số thứ ba ở đây.

01:43.670 --> 01:46.960
Giả sử chúng ta chuyển vào "printResult", điều này đúng ở đây.

01:46.960 --> 01:49.720
Tất nhiên, bây giờ chúng tôi ngay lập tức gặp lỗi

01:49.720 --> 01:53.160
vì chức năng thêm của chúng tôi không hỗ trợ đối số thứ ba.

01:53.160 --> 01:55.560
Chúng tôi thấy, "Dự kiến hai đối số nhưng có ba đối số".

01:55.560 --> 01:57.260
Vì vậy, do đó, chúng tôi phải đảm bảo

01:57.260 --> 01:58.920
rằng chúng tôi hỗ trợ đối số thứ ba.

01:58.920 --> 02:03.920
Và ở đó, chúng ta có thể thêm tham số "showResult".

02:03.940 --> 02:05.920
Bạn cũng có thể đặt tên nó là "printResult" ở đây.

02:05.920 --> 02:07.910
Tôi sẽ sử dụng "showResult" để tránh

02:07.910 --> 02:11.340
nhầm lẫn về cách đặt tên, nhưng về mặt kỹ thuật, hai tên này

02:11.340 --> 02:12.930
sẽ không đụng độ nhau.

02:12.930 --> 02:14.320
Vì vậy, ở đây, tôi sẽ đặt tên nó là "showResult".

02:14.320 --> 02:17.580
Và tôi muốn đảm bảo rằng đây là kiểu boolean bằng cách

02:17.580 --> 02:19.500
đặt giá trị này thành boolean.

02:19.500 --> 02:22.109
Một lần nữa, bằng cách thêm dấu hai chấm

02:22.109 --> 02:25.120
sau tham số ở đây và sau đó thêm tên của loại.

02:25.120 --> 02:28.100
Bây giờ chức năng này chấp nhận điều này, và bây giờ những

02:28.100 --> 02:31.787
gì chúng ta có thể làm là chúng ta có thể thêm một kiểm tra if ở đây và kiểm

02:31.787 --> 02:35.610
tra "if showResult", nếu điều này đúng, tất nhiên, chúng ta có thể so sánh

02:35.610 --> 02:36.480
nó với true.

02:36.480 --> 02:37.628
Nhưng như bạn đã biết

02:37.628 --> 02:41.990
trong JavaScript, bạn cũng có thể chuyển giá trị true hoặc false vào đây.

02:41.990 --> 02:43.970
Và JavaScript sẽ đánh giá nó và nếu điều này

02:43.970 --> 02:47.389
mang lại giá trị đúng bằng cách nào đó hoặc giá trị trung thực nói chung, thì

02:47.389 --> 02:48.989
chúng tôi sẽ đưa nó vào khối if.

02:48.989 --> 02:50.011
Nếu không, chúng tôi sẽ không.

02:50.011 --> 02:52.900
Và giả sử chúng ta làm được ở đây, và sau đó tôi

02:52.900 --> 02:55.429
muốn "console. log n1 cộng n2".

02:55.429 --> 02:58.581
Mặt khác, trong trường hợp khác, nếu chúng tôi không vào được

02:58.581 --> 03:00.549
đó, thì tôi muốn trả lại cái này.

03:00.549 --> 03:02.300
Vì vậy, bây giờ đây là một hàm

03:02.300 --> 03:04.760
đôi khi trả về một giá trị và đôi khi không

03:04.760 --> 03:07.200
trả về một giá trị, nhưng xuất giá trị đó

03:07.200 --> 03:08.309
ngay lập tức.

03:08.309 --> 03:11.550
Bây giờ bạn có thể tranh luận, nếu bạn muốn viết một hàm

03:11.550 --> 03:14.310
như vậy, một hàm không thể đoán trước hoặc có thể

03:14.310 --> 03:16.651
hoạt động không mong muốn nếu bạn chuyển

03:16.651 --> 03:18.349
một giá trị đúng ở đây.

03:18.349 --> 03:19.990
Nhưng ở đây, chúng tôi đang làm điều đó.

03:19.990 --> 03:22.090
Vì vậy, chức năng này đôi khi chỉ trả về.

03:22.090 --> 03:24.869
Đôi khi, nó cũng không trả lại mà thay vào đó,

03:24.869 --> 03:27.830
chỉ ghi nhật ký gì đó vào bảng điều khiển.

03:27.830 --> 03:31.120
Bây giờ ở đây, chúng ta thực sự có thể gọi add như

03:31.120 --> 03:33.640
thế này và không cần lưu trữ kết quả cũng

03:33.640 --> 03:37.570
như không cần console. log bởi vì, với "printResult" được

03:37.570 --> 03:39.550
đặt thành true, hãy thêm chính nó.

03:39.550 --> 03:41.869
Vì vậy, chính chức năng sẽ in kết quả.

03:41.869 --> 03:43.640
Do đó, nếu bây giờ chúng tôi lưu nó và

03:43.640 --> 03:47.880
chúng tôi biên dịch lại ứng dụng của mình. ts tại đây bằng lệnh tsc.

03:47.880 --> 03:50.830
Khi điều này được thực hiện, trang sẽ tải lại và chúng tôi

03:50.830 --> 03:52.600
vẫn thấy đầu ra của mình ở đây.

03:52.600 --> 03:54.677
Nhưng bây giờ nó đến từ dòng sáu.

03:54.677 --> 03:57.690
Và nếu chúng ta để ý, dòng thứ sáu thực sự nằm

03:57.690 --> 03:58.980
bên trong hàm.

03:58.980 --> 03:59.891
Vì vậy, đây là một boolean.

03:59.891 --> 04:02.429
Bây giờ, giả sử chúng ta muốn tùy chỉnh đầu ra.

04:02.429 --> 04:06.190
Trong if ở đây, chúng ta có hằng số "cụm từ kết quả" ở đây chúng

04:06.190 --> 04:10.181
ta nói, "Kết quả là" dấu hai chấm và sau đó là khoảng trắng.

04:10.181 --> 04:14.205
Và chúng tôi cũng chuyển điều đó với "cụm từ kết quả" ở đây.

04:14.205 --> 04:17.410
Chà, vậy thì chúng ta cũng có thể mong đợi điều này như một cuộc tranh luận ở đây.

04:17.410 --> 04:20.750
Cụm từ, sẽ tạo ra chuỗi ống, bằng cách thêm dấu hai chấm.

04:20.750 --> 04:22.291
Và sau đó chuỗi là tên của

04:22.291 --> 04:26.469
loại, và bây giờ chúng ta có thể sử dụng cụm từ đó để xuất nó như

04:26.469 --> 04:30.360
một phần của đầu ra kết quả nếu chúng ta in kết quả ngay trong

04:30.360 --> 04:31.193
hàm.

04:31.193 --> 04:34.789
Vì vậy, ở đây, chúng ta có thể có "cụm từ cộng n1 cộng n2".

04:34.789 --> 04:37.440
Và nếu chúng ta làm điều đó và chúng ta biên dịch lại

04:37.440 --> 04:39.040
bằng cách lặp lại lệnh đó, chúng

04:39.040 --> 04:41.720
ta sẽ thấy rằng cụm từ này là một phần của kết quả.

04:41.720 --> 04:44.861
Nhưng bây giờ, chúng tôi cũng giới thiệu lại lỗi

04:44.861 --> 04:48.141
cũ vì tôi có một chuỗi mà tôi kết hợp với hai số.

04:48.141 --> 04:52.000
Mọi thứ được chuyển đổi thành một chuỗi ở đây và đó không phải

04:52.000 --> 04:53.240
là điều tôi muốn.

04:53.240 --> 04:55.930
Để tránh điều này, trong hàm này, chúng ta có thể

04:55.930 --> 04:57.708
thêm một biến kết quả vào đây.

04:57.708 --> 05:02.027
Hoặc một hằng số kết quả và lưu trữ kết quả của chúng tôi ở đây.

05:02.027 --> 05:04.530
Bây giờ điều này sẽ được xử lý theo cách toán

05:04.530 --> 05:07.990
học vì chỉ có các số liên quan, và sau đó, ở đây, chúng ta có

05:07.990 --> 05:11.430
thể kết hợp điều đó với cụm từ hoặc chỉ cần trả về nó.

05:11.430 --> 05:15.160
Và bây giờ, vì điều này không bao giờ được tính toán trực tiếp cùng với một chuỗi,

05:15.160 --> 05:17.029
nên điều này sẽ luôn là một số.

05:17.029 --> 05:19.350
Và, vâng, thì đây, con số này kết hợp với chuỗi này

05:19.350 --> 05:21.140
sẽ được chuyển đổi thành một chuỗi.

05:21.140 --> 05:24.360
Nhưng vì phép tính toán học đã hoàn thành trước đó, nên chúng

05:24.360 --> 05:25.548
ta sẽ có kết quả đúng.

05:25.548 --> 05:28.520
Vì vậy, bây giờ nếu chúng tôi lặp lại điều đó và sau đó biên dịch lại,

05:28.520 --> 05:30.181
chúng tôi sẽ nhận được đầu ra phù hợp.

05:30.181 --> 05:33.050
Vì vậy, bây giờ đây là những kiểu dữ liệu cốt lõi đang hoạt động.

05:33.050 --> 05:35.541
Bây giờ chúng ta hãy đảm bảo rằng chúng ta hiểu đầy

05:35.541 --> 05:38.061
đủ cách thức các loại được chỉ định và đồng thời,

05:38.061 --> 05:41.343
tại sao chúng ta không chỉ định rõ ràng các loại ở dưới đó.
