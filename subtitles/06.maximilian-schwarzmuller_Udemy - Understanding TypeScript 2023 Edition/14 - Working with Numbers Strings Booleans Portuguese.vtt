WEBVTT

00:01.850 --> 00:03.270
Instrutor: Então agora que

00:03.270 --> 00:06.760
sabemos sobre os fundamentos do TypeScript e como ele difere e

00:06.760 --> 00:09.661
tudo isso relacionado ao JavaScript, vamos cavar um

00:09.661 --> 00:11.410
pouco mais fundo nos diferentes

00:11.410 --> 00:14.148
tipos centrais que o TypeScript conhece.

00:14.148 --> 00:17.490
O número é o tipo que vemos aqui, e como expliquei, não há diferença entre

00:17.490 --> 00:18.500
números inteiros como

00:18.500 --> 00:22.050
os cinco aqui e flutuadores ou duplos, como seria chamado em outras linguagens

00:22.050 --> 00:25.640
de programação, como 2.

00:25.640 --> 00:25.640
8 aqui.

00:25.640 --> 00:28.440
De fato, em JavaScript, e o mesmo é verdade em TypeScript,

00:28.440 --> 00:30.810
todos os números são flutuantes por padrão.

00:30.810 --> 00:33.270
Portanto, para JavaScript, e portanto, também para

00:33.270 --> 00:35.171
TypeScript, não há diferença entre cinco

00:35.171 --> 00:36.770
como este e cinco como este.

00:36.770 --> 00:38.640
É o mesmo número, essencialmente.

00:38.640 --> 00:42.720
Agora, além dos números, temos também outros tipos de núcleo.

00:42.720 --> 00:46.350
E isso seriam cordas, portanto texto, e booleanos.

00:46.350 --> 00:47.800
Vamos também dar uma olhada neles.

00:47.800 --> 00:50.650
Na verdade, vimos todos os que já estavam em ação aqui nesta declaração,

00:50.650 --> 00:53.291
o que aprendemos que é um pouco redundante.

00:53.291 --> 00:55.971
No entanto, isto aqui seria um fio.

00:55.971 --> 00:57.720
Também, é claro, cinco com citações

00:57.720 --> 01:00.389
seriam um fio porque é um texto.

01:00.389 --> 01:03.851
E o resultado, por exemplo, desta comparação aqui, que

01:03.851 --> 01:05.170
seria um booleano.

01:05.170 --> 01:08.090
Este operador, o sinal de tripla igualdade

01:08.090 --> 01:10.950
ou o operador de igualdade negado aqui,

01:10.950 --> 01:13.640
que produz verdadeiro ou falso.

01:13.640 --> 01:14.720
E, é claro, podemos produzir

01:14.720 --> 01:17.340
uma verificação dinâmica do recife interno, o que faremos

01:17.340 --> 01:18.850
com freqüência.

01:18.850 --> 01:22.340
Ou inicializamos uma variável com um valor verdadeiro ou falso, então vamos

01:22.340 --> 01:23.379
fazer os dois aqui.

01:23.379 --> 01:27.509
Aqui, poderíamos acrescentar uma nova constante, "printResultado".

01:27.509 --> 01:29.990
E colocar isto em prática, por exemplo.

01:29.990 --> 01:31.320
E só para deixar bem claro, isto

01:31.320 --> 01:33.130
também poderia ser uma variável.

01:33.130 --> 01:34.460
Não tem que ser constante.

01:34.460 --> 01:36.030
Ela pode ser uma variável, que

01:36.030 --> 01:37.730
você criaria com o JavaScript.

01:37.730 --> 01:39.870
Mas como não pretendo mudá-lo aqui, irei com

01:39.870 --> 01:40.703
uma constante.

01:40.703 --> 01:43.670
E poderíamos passar isto como um terceiro parâmetro aqui.

01:43.670 --> 01:46.960
Digamos que passamos em "printResult", o que se aplica aqui.

01:46.960 --> 01:49.720
Agora recebemos imediatamente um erro, é claro, porque

01:49.720 --> 01:53.160
nossa função de adição não apóia um terceiro argumento.

01:53.160 --> 01:55.560
Vemos: "Esperava dois argumentos, mas conseguiu três".

01:55.560 --> 01:57.260
Portanto, temos que nos certificar

01:57.260 --> 01:58.920
de apoiar um terceiro argumento.

01:58.920 --> 02:03.920
E ali, poderíamos acrescentar um parâmetro "showResultado".

02:03.940 --> 02:05.920
Você poderia chamá-lo de "printResultado" também aqui.

02:05.920 --> 02:07.910
Vou com "showResult" para evitar confusão

02:07.910 --> 02:11.340
em relação à nomenclatura, mas, tecnicamente, estes dois nomes não

02:11.340 --> 02:12.930
entrariam em conflito.

02:12.930 --> 02:14.320
Por isso, aqui, vou chamá-lo de "showResultado".

02:14.320 --> 02:17.580
E eu quero ter certeza de que isto é do tipo booleano, definindo

02:17.580 --> 02:19.500
isto como booleano.

02:19.500 --> 02:22.109
Novamente, adicionando aqui dois pontos após

02:22.109 --> 02:25.120
o parâmetro e depois adicionando o nome do tipo.

02:25.120 --> 02:28.100
Agora esta função aceita isto, e agora o que podemos

02:28.100 --> 02:31.787
fazer é adicionar um "se" aqui e verificar "se mostrarResultado",

02:31.787 --> 02:36.480
se isto for verdade, podemos, é claro, compará-lo com verdade.

02:36.480 --> 02:37.628
Mas como você sabe em JavaScript,

02:37.628 --> 02:41.990
você também pode simplesmente passar no valor da verdade ou da falsidade aqui.

02:41.990 --> 02:43.970
E o JavaScript irá avaliá-lo, e se isto se

02:43.970 --> 02:47.389
tornar verdadeiro de alguma forma ou um valor verdadeiro em geral, então

02:47.389 --> 02:48.989
nós o faremos no se bloco.

02:48.989 --> 02:50.011
Caso contrário, não o faremos.

02:50.011 --> 02:52.900
E digamos que conseguimos entrar aqui, e depois eu

02:52.900 --> 02:55.429
quero "consolar". log n1 mais n2".

02:55.429 --> 02:58.581
Caso contrário, no outro caso, se não conseguirmos entrar

02:58.581 --> 03:00.549
ali, então quero devolver isto.

03:00.549 --> 03:02.300
Portanto, agora esta é uma função

03:02.300 --> 03:04.760
que às vezes retorna um valor e às vezes não

03:04.760 --> 03:08.309
retorna um valor, mas o produz imediatamente.

03:08.309 --> 03:11.550
Agora você pode argumentar, se quiser escrever tal função,

03:11.550 --> 03:14.310
que é meio imprevisível ou que pode se comportar

03:14.310 --> 03:16.651
de forma inesperada se você estiver passando

03:16.651 --> 03:18.349
uma verdade aqui.

03:18.349 --> 03:19.990
Mas aqui, nós estamos fazendo isso.

03:19.990 --> 03:22.090
Portanto, esta função só retorna às vezes.

03:22.090 --> 03:24.869
Às vezes também não retorna, mas, ao invés

03:24.869 --> 03:27.830
disso, apenas registra algo no console.

03:27.830 --> 03:31.120
Agora aqui, podemos realmente chamar add exatamente assim

03:31.120 --> 03:33.640
e não precisamos armazená-lo em resultado

03:33.640 --> 03:37.570
e não precisamos consolar. resultado log porque, com "printResult" definido

03:37.570 --> 03:39.550
para true, adiciona-se a si mesmo.

03:39.550 --> 03:41.869
Portanto, a própria função imprimirá o resultado.

03:41.869 --> 03:43.640
Portanto, se agora salvarmos

03:43.640 --> 03:47.880
isso e recompilarmos nossa maçã. ts arquivar aqui com o comando tsc.

03:47.880 --> 03:50.830
Uma vez feito isso, a página será recarregada, e ainda

03:50.830 --> 03:52.600
vemos nossa produção aqui.

03:52.600 --> 03:54.677
Mas agora está vindo da linha seis.

03:54.677 --> 03:57.690
E se tivermos um olhar, a linha seis está, de fato,

03:57.690 --> 03:58.980
dentro da função.

03:58.980 --> 03:59.891
Portanto, isto é um booleano.

03:59.891 --> 04:02.429
Agora vamos dizer que queremos personalizar a produção.

04:02.429 --> 04:06.190
No se aqui, temos aqui uma constante "resultPhrase" onde dizemos

04:06.190 --> 04:10.181
"resultado é" dois pontos e depois algum espaço branco.

04:10.181 --> 04:14.205
E passamos isso também com "resultPhrase" aqui.

04:14.205 --> 04:17.410
Bem, então poderíamos esperar isto também como um argumento aqui.

04:17.410 --> 04:20.750
Frase, que produziria um fio de tubo, acrescentando dois pontos.

04:20.750 --> 04:22.291
E depois a corda é o nome do tipo,

04:22.291 --> 04:26.469
e agora poderíamos usar essa frase para produzi-la como parte de nossa saída

04:26.469 --> 04:30.360
de resultados se estivéssemos imprimindo o resultado diretamente na

04:30.360 --> 04:31.193
função.

04:31.193 --> 04:34.789
Então, aqui, poderíamos ter "frase mais n1 mais n2".

04:34.789 --> 04:37.440
E se fizermos isso e recompilarmos repetindo

04:37.440 --> 04:39.040
esse comando, veremos que

04:39.040 --> 04:41.720
esta frase é parte do resultado.

04:41.720 --> 04:44.861
Mas nós também, agora, reintroduzimos o antigo bug porque

04:44.861 --> 04:48.141
eu tenho um fio, que eu combino com dois números.

04:48.141 --> 04:52.000
Tudo é convertido em um fio aqui, e não é isso

04:52.000 --> 04:53.240
que eu quero.

04:53.240 --> 04:55.930
Para evitar isto, nesta função, poderíamos acrescentar

04:55.930 --> 04:57.708
aqui uma variável de resultado.

04:57.708 --> 05:02.027
Ou um resultado constante e armazenar nosso resultado aqui.

05:02.027 --> 05:04.530
Isto agora será tratado de uma forma matemática,

05:04.530 --> 05:07.990
porque apenas números estão envolvidos, e então, aqui, poderíamos

05:07.990 --> 05:11.430
combinar isso com frase ou simplesmente devolvê-lo.

05:11.430 --> 05:15.160
E agora, como isto nunca é calculado diretamente junto com uma corda,

05:15.160 --> 05:17.029
este será sempre um número.

05:17.029 --> 05:19.350
E, sim, então aqui, este número combinado com esta

05:19.350 --> 05:21.140
corda será convertido em uma corda.

05:21.140 --> 05:24.360
Mas como o cálculo matemático terminou antes disso, teremos

05:24.360 --> 05:25.548
o resultado certo.

05:25.548 --> 05:28.520
Portanto, agora se repetirmos isso e depois recompilarmos,

05:28.520 --> 05:30.181
obtemos o resultado certo.

05:30.181 --> 05:33.050
Portanto, agora estes são os tipos de dados centrais em ação.

05:33.050 --> 05:35.541
Vamos agora nos certificar de compreender plenamente

05:35.541 --> 05:38.061
como os tipos são atribuídos e, também, por que

05:38.061 --> 05:41.343
não atribuímos tipos explicitamente lá embaixo.
