WEBVTT

00:02.130 --> 00:02.963
Người hướng dẫn: Vì vậy,

00:02.963 --> 00:05.180
chúng tôi đã đề cập đến một số loại cốt lõi mà TypeScript biết.

00:05.180 --> 00:06.590
Bây giờ chúng ta hãy tiếp tục.

00:06.590 --> 00:09.140
Vì thế, tôi sẽ đổi tên app. ts ở đây thành objs-arrays-enums

00:09.140 --> 00:11.670
hoặc bất cứ thứ gì bạn muốn đặt tên cho nó, về cơ bản

00:11.670 --> 00:12.750
là để chúng tôi vẫn có

00:12.750 --> 00:15.080
tệp đó, nhưng tôi sẽ tạo một ứng dụng hoàn toàn

00:15.080 --> 00:17.130
mới. ts để chúng tôi

00:17.130 --> 00:18.860
lại có một tệp trống để chúng

00:18.860 --> 00:20.500
tôi có thể làm việc.

00:20.500 --> 00:22.550
Bây giờ trong tệp này, tôi muốn đi sâu vào

00:22.550 --> 00:25.790
một loại thú vị khác mà bạn sẽ tìm thấy trong TypeScript.

00:25.790 --> 00:28.640
Và đó là kiểu công đoàn.

00:28.640 --> 00:30.190
Bây giờ đó là gì?

00:30.190 --> 00:33.000
Hãy quay lại chức năng thêm mà chúng ta đã viết trước đó, tôi

00:33.000 --> 00:34.490
sẽ sao chép chức năng đó và chuyển

00:34.490 --> 00:37.270
chúng sang ứng dụng. ts.

00:37.270 --> 00:39.190
Hãy loại bỏ nhận xét đó ở đây và ở đây trên

00:39.190 --> 00:42.940
phần bổ trợ, hãy kết thúc phần cơ bản. ts để chúng tôi thoát

00:42.940 --> 00:44.170
khỏi lỗi đó.

00:44.170 --> 00:47.970
Ngoài ra, bây giờ tôi muốn linh hoạt hơn về những gì

00:47.970 --> 00:49.920
chúng tôi chấp nhận ở đây.

00:49.920 --> 00:52.570
Tôi cũng sẽ loại bỏ showResult và cụm từ,

00:52.570 --> 00:54.370
tôi không cần điều đó.

00:54.370 --> 00:55.690
Và điều duy nhất tôi muốn

00:55.690 --> 00:58.590
làm là tôi muốn tính toán một kết quả và trả về nó.

00:58.590 --> 01:01.960
Nhưng tôi muốn linh hoạt hơn về các yếu tố đầu vào.

01:01.960 --> 01:06.045
Trước đây, chúng tôi đảm bảo rằng chúng tôi chỉ làm việc với các con số.

01:06.045 --> 01:09.357
Bây giờ, giả sử chúng ta thực sự đặt tên cho

01:09.357 --> 01:13.190
tổ hợp này và nó sẽ hoạt động với cả số và chuỗi.

01:13.190 --> 01:15.710
Bởi vì hóa ra chúng ta có thể kết hợp cả số và

01:15.710 --> 01:18.595
chuỗi với toán tử cộng này, điểm khác biệt duy

01:18.595 --> 01:21.650
nhất là trong một trường hợp, kết quả là chúng ta nhận

01:21.650 --> 01:24.030
được một số, trong trường hợp khác, chúng

01:24.030 --> 01:27.120
ta nhận được một chuỗi được nối, như chúng ta thực

01:27.120 --> 01:30.150
sự đã thấy trước đó trên mô-đun này.

01:30.150 --> 01:32.040
Nhưng bây giờ tôi muốn cho phép

01:32.040 --> 01:33.950
hành vi này, bởi vì bạn có thể có

01:33.950 --> 01:36.740
một ứng dụng mà bạn muốn có một hàm kết hợp linh

01:36.740 --> 01:38.963
hoạt hoạt động với các số và chuỗi.

01:39.830 --> 01:42.360
Do đó, tôi cũng sẽ đặt tên cho đầu vào này

01:42.360 --> 01:47.340
ở đây và đầu vào này và đầu vào này và kết hợp cả hai cái này ngay bây giờ.

01:47.340 --> 01:49.740
Nhưng tất nhiên chúng ta sẽ gặp một vấn

01:49.740 --> 01:53.180
đề, ngay bây giờ chúng ta đặt cả hai tham số là số.

01:53.180 --> 01:56.050
Điều này có nghĩa là chúng ta có thể gọi hàm này, miễn

01:56.050 --> 01:58.190
là chúng ta muốn làm việc với các số.

01:58.190 --> 01:59.130
Giả sử ở dưới đó, chúng

01:59.130 --> 02:01.640
ta đang tạo một hằng số mới, tổ hợpAges.

02:02.931 --> 02:04.690
Và ở đó, tôi gọi kết hợp

02:04.690 --> 02:09.602
và vượt qua 30 và 26 ở đây theo độ tuổi trong bất kỳ ứng dụng nào

02:09.602 --> 02:12.000
chúng tôi đang xây dựng.

02:12.000 --> 02:15.014
Một kết hợp khác sau nhật ký bảng điều khiểnAges,

02:15.014 --> 02:17.240
cũng không quá ngạc nhiên nếu bây giờ

02:17.240 --> 02:19.830
chúng ta biên dịch tệp này ở đây và sau đó tải

02:19.830 --> 02:22.360
lại trang này, chúng ta sẽ nhận được 56.

02:22.360 --> 02:24.690
Vì vậy, điều này hoạt động, chúng tôi nhận được con số này.

02:24.690 --> 02:26.710
Nhưng tất nhiên, chúng tôi gặp sự cố nếu

02:26.710 --> 02:28.838
chúng tôi cố gắng tạo một chuỗi ở đây.

02:28.838 --> 02:31.610
Ví dụ: Tên kết hợp.

02:31.610 --> 02:36.033
Nếu tôi cố gắng kết hợp Max và Anna ở đây, thì tốt, chúng tôi

02:37.230 --> 02:39.630
ngay lập tức gặp lỗi ở đây rằng Max

02:39.630 --> 02:42.320
không thể gán cho số loại vì đây, tất

02:42.320 --> 02:44.350
nhiên, là một chuỗi.

02:44.350 --> 02:45.790
Tất nhiên, bây giờ chúng ta có thể

02:45.790 --> 02:47.750
thay đổi điều này để chấp nhận chuỗi thay vì

02:47.750 --> 02:50.130
số, nhưng bây giờ lệnh gọi hàm đầu tiên sẽ thất bại.

02:50.130 --> 02:52.750
Và đó là nơi mà các loại công đoàn có thể giúp chúng ta.

02:52.750 --> 02:55.692
Nếu chúng ta có một vị trí nào đó trong ứng dụng

02:55.692 --> 02:58.810
của mình, đó có thể là tham số của hàm hoặc hằng số

02:58.810 --> 03:01.700
hoặc biến mà chúng ta đang sử dụng ở đâu đó, nơi

03:01.700 --> 03:05.030
chúng ta chấp nhận hai loại giá trị khác nhau.

03:05.030 --> 03:07.410
Vậy thì, một loại công đoàn có thể giúp chúng ta.

03:07.410 --> 03:09.800
Để nói với TypeScript rằng chúng

03:09.800 --> 03:12.690
tôi ổn với một số hoặc một chuỗi, chúng

03:12.690 --> 03:14.220
tôi sử dụng số và sau

03:14.220 --> 03:17.710
đó là ký hiệu ống ở đây, sau đó là loại khác mà

03:17.710 --> 03:20.660
chúng tôi cũng chấp nhận.

03:20.660 --> 03:22.340
Và bạn có thể có nhiều hơn hai loại,

03:22.340 --> 03:25.220
bạn có thể chấp nhận bao nhiêu loại ở đây nếu bạn cần.

03:25.220 --> 03:27.050
Vì vậy, ở đây, tôi chỉ cần hai mặc

03:27.050 --> 03:28.880
dù, và đó là phép gán loại đủ khả

03:28.880 --> 03:31.720
năng mà tôi sẽ thực hiện, số hoặc chuỗi.

03:31.720 --> 03:33.690
Bây giờ tôi gặp một lỗi ở đây,

03:33.690 --> 03:35.930
đó là không thể áp dụng toán tử cộng

03:35.930 --> 03:39.120
cho các loại chuỗi hoặc số và chuỗi hoặc số.

03:39.120 --> 03:41.500
Điều đó thực sự không hoàn toàn chính xác,

03:41.500 --> 03:44.350
điều này sẽ hiệu quả, bởi vì chúng ta có thể sử dụng

03:44.350 --> 03:46.670
toán tử cộng với cả số và chuỗi.

03:46.670 --> 03:49.600
Nhưng TypeScript chỉ thấy rằng chúng ta có một loại kết

03:49.600 --> 03:52.540
hợp ở đây và nó không phân tích những gì trong loại kết

03:52.540 --> 03:56.010
hợp, nó chỉ thấy, "Được rồi, bạn đang mong đợi nhiều loại.

03:56.010 --> 03:57.530
Có lẽ điều đó bao gồm các loại

03:57.530 --> 03:59.460
mà tôi không thể sử dụng toán tử cộng,

03:59.460 --> 04:01.640
do đó tôi sẽ khiếu nại ở đây. May mắn thay, bây giờ chúng ta có thể giải quyết vấn đề đó.

04:01.640 --> 04:05.410
Chúng ta có thể thêm kiểm tra kiểu thời gian chạy

04:05.410 --> 04:07.910
của mình ở đây và xem liệu typeof

04:07.910 --> 04:11.240
input1 có bằng số không và typeof input2

04:12.750 --> 04:15.170
có bằng số hay không, sau đó chuyển

04:16.530 --> 04:21.283
phép tính này vào đó, bây giờ chỉ cần một cải tiến, hãy tạo kết

04:24.100 --> 04:26.410
quả dưới dạng một biến ngay từ

04:26.410 --> 04:28.510
đầu nếu kiểm tra, vì phạm vi

04:28.510 --> 04:33.880
khóa, để đây là một biến có sẵn trong toàn bộ chức năng, sau đó chỉ cần

04:33.880 --> 04:37.873
gán một giá trị mới trong đó.

04:37.873 --> 04:40.310
Vì vậy, bây giờ ở đây chúng tôi kiểm tra xem chúng tôi có hai số không.

04:40.310 --> 04:42.818
Và do đó, TypeScript biết rằng ở

04:42.818 --> 04:45.890
đây, cả input1 và input2 sẽ là các số.

04:45.890 --> 04:49.790
Bây giờ hãy thêm một kiểm tra khác ở đây.

04:49.790 --> 04:53.900
Và ở đó chúng ta có thể đặt kết quả bằng đầu vào1. tostring, chuyển đổi rõ ràng chuỗi

04:53.900 --> 04:56.913
này thành chuỗi

04:58.550 --> 05:00.570
và input2. tostring.

05:00.570 --> 05:02.880
Và điều này sau đó cũng sẽ tốt

05:02.880 --> 05:04.160
cho TypeScript và JavaScript,

05:04.160 --> 05:05.700
bởi vì chúng ta có thể nối hai chuỗi.

05:05.700 --> 05:08.220
Vì vậy, bây giờ chúng tôi có phép tính gần như giống nhau,

05:08.220 --> 05:10.800
nhưng chúng tôi đã làm rõ rằng ở đây, chúng tôi sẽ luôn làm

05:10.800 --> 05:12.110
việc với các số, ở đây chúng

05:12.110 --> 05:13.590
tôi sẽ luôn làm việc với các chuỗi

05:13.590 --> 05:15.730
và sau đó chúng tôi trả về kết quả.

05:15.730 --> 05:17.490
Và bây giờ với điều đó, nếu chúng

05:17.490 --> 05:20.870
tôi điều khiển ghi lại các tên kết hợp ở đó và chúng tôi biên

05:20.870 --> 05:25.350
dịch tệp này, chúng tôi sẽ thấy rằng khi chúng tôi truy cập lại trang của mình,

05:25.350 --> 05:27.210
chúng tôi đã nhận được các số kết

05:27.210 --> 05:29.278
hợp ở đó, chúng được cộng lại với nhau

05:29.278 --> 05:31.460
một cách đơn giản và do đó chúng tôi nhận

05:31.460 --> 05:33.150
được một số kết quả là, và hai

05:33.150 --> 05:35.090
tên kết hợp ở đây.

05:35.090 --> 05:36.850
Vì vậy, đây là cách chúng ta có thể sử

05:36.850 --> 05:40.830
dụng các kiểu kết hợp để linh hoạt hơn đối với những gì chúng ta làm trong một hàm,

05:40.830 --> 05:43.770
chẳng hạn, hoặc bất kỳ nơi nào khác trong mã của chúng ta.

05:43.770 --> 05:45.920
Việc kiểm tra loại thời gian chạy bổ sung

05:45.920 --> 05:49.520
này không phải lúc nào cũng được yêu cầu khi bạn làm việc với các loại

05:49.520 --> 05:51.230
liên kết, nhưng thường là do với

05:51.230 --> 05:54.090
các loại liên kết, bạn có thể linh hoạt hơn, chẳng hạn như

05:54.090 --> 05:56.350
các tham số bạn chấp nhận, nhưng sau đó bạn có

05:56.350 --> 05:58.170
thể có logic khác trong chức năng dựa

05:58.170 --> 06:00.940
trên loại chính xác mà bạn đang nhận được.

06:00.940 --> 06:03.730
Vì vậy, chức năng của bạn có thể hoạt động với

06:03.730 --> 06:05.640
nhiều loại giá trị nhưng sau đó

06:05.640 --> 06:07.810
nó thực hiện những việc hơi khác nhau

06:07.810 --> 06:10.320
tùy thuộc vào loại bạn đang nhận.

06:10.320 --> 06:12.410
Thông thường, bạn có thể cần kiểm tra thời gian

06:12.410 --> 06:15.270
chạy như vậy khi làm việc với các kiểu kết hợp, nhưng không phải

06:15.270 --> 06:16.700
lúc nào bạn cũng cần nó.

06:16.700 --> 06:18.490
Bạn chắc chắn cũng sẽ gặp phải các tình huống

06:18.490 --> 06:20.900
trong các chương trình TypeScript nơi bạn có thể sử dụng

06:20.900 --> 06:24.060
một kiểu kết hợp mà không cần kiểm tra kiểu thời gian chạy.

06:24.060 --> 06:25.870
Nó thực sự phụ thuộc vào logic bạn đang viết.
