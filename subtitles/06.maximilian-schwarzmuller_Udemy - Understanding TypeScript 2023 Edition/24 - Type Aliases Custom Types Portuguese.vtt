WEBVTT

00:02.340 --> 00:05.860
-: Agora quando se trabalha com tipos de sindicatos,

00:05.860 --> 00:06.970
como este e este,

00:06.970 --> 00:11.070
pode ser incômodo repetir sempre o tipo de sindicato.

00:11.070 --> 00:13.070
Talvez você queira comercializar um novo

00:13.070 --> 00:15.330
tipo que reinstale este tipo de sindicato.

00:15.330 --> 00:18.540
E você pode fazer isso com outra característica de tipos

00:18.540 --> 00:21.410
legais, a característica de apelidos do tipo.

00:21.410 --> 00:22.723
Você cria tal pseudônimo,

00:24.280 --> 00:25.670
normalmente antes de

00:25.670 --> 00:29.240
usá-lo, então aqui no topo do arquivo neste caso, com a palavra-chave

00:29.240 --> 00:31.240
do tipo.

00:31.240 --> 00:34.040
Agora a palavra-chave do tipo não está incorporada

00:34.040 --> 00:35.880
no JavaScript, mas é suportada no

00:35.880 --> 00:40.450
TypeScript, e depois de digitar você adiciona o nome de seu tipo personalizado, ou

00:40.450 --> 00:42.860
de seu tipo pseudônimo, eu deveria dizer.

00:42.860 --> 00:44.980
Por exemplo, combinável.

00:44.980 --> 00:46.720
Mas o nome realmente depende de você.

00:46.720 --> 00:48.380
Você pode inventar aqui qualquer

00:48.380 --> 00:50.520
nome que não esteja embutido no JavaScript

00:50.520 --> 00:52.530
ou TypeScript como nome chave.

00:52.530 --> 00:54.360
Portanto, algo como data não seria permitido

00:54.360 --> 00:56.250
porque está embutido no JavaScript, mas combinável

00:56.250 --> 00:58.900
não está embutido no JavaScript, não está embutido no TypeScript

00:58.900 --> 01:01.170
para que possamos usá-lo.

01:01.170 --> 01:04.550
E agora com o sinal de igualdade você atribui o tipo que

01:04.550 --> 01:08.320
você quer codificar em seu pseudônimo, por assim dizer.

01:08.320 --> 01:10.300
Assim, poderíamos armazenar um número

01:10.300 --> 01:12.790
aqui, e agora sempre que quisermos ter certeza de

01:12.790 --> 01:14.390
que algo deveria ser um número, poderíamos

01:14.390 --> 01:16.400
usar um número combinável.

01:16.400 --> 01:18.570
Agora, isso não faz muito sentido, é discutível

01:18.570 --> 01:21.630
que até tornaria nosso código mais difícil de ser lido.

01:21.630 --> 01:25.500
Se eu usar combinável lá embaixo, por exemplo, isto funcionaria

01:25.500 --> 01:27.420
tecnicamente, mas se apenas

01:27.420 --> 01:29.550
olharmos para nosso código, não

01:29.550 --> 01:33.180
é óbvio que aqui queremos um número ou um fio.

01:33.180 --> 01:35.560
Bem, normalmente, portanto, você usa isso em

01:35.560 --> 01:37.500
conjunto com tipos de sindicatos.

01:37.500 --> 01:40.380
Assim, podemos armazenar um tipo de sindicato em nosso

01:40.380 --> 01:42.250
tipo personalizado, por assim dizer,

01:42.250 --> 01:45.240
em nosso tipo de pseudônimo, e agora só nos referimos a combinar

01:45.240 --> 01:48.170
lá embaixo em vez de nosso tipo de sindicato.

01:48.170 --> 01:51.060
Portanto, temos exatamente a mesma configuração de

01:51.060 --> 01:54.230
antes, apenas temos aqui nosso tipo reutilizável, que podemos

01:54.230 --> 01:55.580
usar em seu lugar.

01:55.580 --> 01:57.660
E isso nos permite economizar algum código

01:57.660 --> 01:59.200
extra e garantir que sempre nos

01:59.200 --> 02:04.200
referimos aos mesmos tipos ou ao mesmo tipo de configuração quando usamos combináveis.

02:04.234 --> 02:06.600
E é claro que não podemos usar isso apenas para número

02:06.600 --> 02:08.970
e string, podemos usar isso para qualquer tipo de

02:08.970 --> 02:11.140
configuração que possamos querer armazenar

02:11.140 --> 02:14.810
em um pseudônimo, incluindo estes dois tipos literais, por exemplo.

02:14.810 --> 02:18.210
Portanto, para estes dois tipos aqui, para este tipo

02:18.210 --> 02:20.660
de união, poderíamos também trocar o

02:20.660 --> 02:24.030
tipo alias, ConversionDescriptor, ou como você quiser

02:24.030 --> 02:28.920
nomeá-lo, e armazenar exatamente este tipo neste tipo alias.

02:28.920 --> 02:32.270
E agora podemos usar este tipo de pseudônimo lá embaixo.

02:32.270 --> 02:34.970
Portanto, os pseudônimos são muito, muito úteis.

02:34.970 --> 02:37.490
Você pode codificar definições de tipo mais complexas

02:37.490 --> 02:40.860
em seus próprios tipos, em seus próprios nomes de tipo, por assim dizer, e

02:40.860 --> 02:43.120
reutilizar isso em qualquer lugar em seu código onde

02:43.120 --> 02:45.920
você precise exatamente dessa configuração de tipo.

02:45.920 --> 02:48.060
Para que você evite erros de digitação lá embaixo

02:48.060 --> 02:51.000
e possa simplesmente salvar código, escrever código mais

02:51.000 --> 02:53.490
rapidamente e ser sempre mais claro sobre suas intenções,

02:53.490 --> 02:56.010
por exemplo, escolhendo nomes de tipo descritivo

02:56.010 --> 02:57.653
ali em cima.
