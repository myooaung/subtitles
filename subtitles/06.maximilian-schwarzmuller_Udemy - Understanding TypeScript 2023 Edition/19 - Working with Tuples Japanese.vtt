WEBVTT

00:02.460 --> 00:05.590
-：ですから､ 配列はサポートされていますし､ 数値､ 文字列､

00:05.590 --> 00:07.620
ブール､ オブジェクト､ 配列と｡

00:07.620 --> 00:11.400
TypeScriptでは､ オブジェクトの配列の例で学んだように､

00:11.400 --> 00:17.884
コアな値や値の型､ JavaScriptのnosがサポートされています｡

00:17.884 --> 00:30.140
TypeScriptはさらに多くの機能を提供していますが､ それは少し高度なので､ 後で見てみましょう｡

00:30.140 --> 00:33.540
TypeScriptには､ バニラJavaスクリプトでは知らない新しい概念､

00:33.540 --> 00:40.300
新しい型がいくつかあるんだ｡ 例えば､ タプル型｡

00:40.300 --> 00:46.570
他のプログラミング言語ではタプルをご存じかもしれませんが､ JavaScriptにはタプルはありません｡

00:46.570 --> 00:52.290
例えばこれはタプルで､ これは配列だと言うでしょう｡

00:52.290 --> 00:52.290
これは配列ですが､

00:52.290 --> 00:58.650
固定長の配列で､ 実は固定長だけでなく固定型もあります｡

00:58.650 --> 01:00.730
そして､ これはどこで便利に使えるのでしょうか？

01:00.730 --> 01:03.350
例えば､ personにroleというプロパティがあり､

01:03.350 --> 01:22.765
これは2つの要素からなる配列で､ 最初の要素は例えば2のような数値識別子､ 2番目は文字列識別子とauthorのような人間が読める説明です｡

01:22.765 --> 01:26.496
なぜなら､ 今書いているアプリケーションのユーザーや人は､

01:26.496 --> 01:35.185
1つのロールしか持てないからです｡ そしてロールは2つの要素で構成されています｡

01:35.185 --> 01:37.400
もちろん､ ここで光学系を使うこともできますが､

01:37.400 --> 01:43.118
何らかの理由で､ 最初の要素が常に数値の識別子で､ 2番目の要素が常に文字列の識別子または説明など､

01:43.118 --> 01:50.220
好きな呼び方をする､ ちょうど2つの要素を持つ配列にしたいのです｡

01:50.220 --> 01:52.420
さて､ この上にカーソルを置くと､

01:52.420 --> 02:06.710
TypeScriptは今まで見たこともないような奇妙な型を推論します｡

02:06.710 --> 02:06.710
重要なのは､

02:06.710 --> 02:11.668
TypeScriptが､ このようなタイプの値を持つ配列であるべきだと理解していることである｡

02:11.668 --> 02:14.580
死んでいるダウンズ このコードを実行することができましたが､

02:14.580 --> 02:18.780
人の役割､ プッシュ､ 管理者｡

02:18.780 --> 02:20.250
さて､ 今回のアプリケーションでは､

02:20.250 --> 02:21.970
2つの要素しか必要ないことが分かっているので､

02:21.970 --> 02:23.960
これは意味がないかもしれません｡

02:23.960 --> 02:28.963
しかし､ TypeScriptは､ 私たちが2つの要素しか欲していないことを知らないのです｡

02:28.963 --> 02:28.963
また､

02:28.963 --> 02:35.200
人物の役割､ インデックス1の2番目の要素を数字に切り替えることもできるようになります｡

02:35.200 --> 02:38.010
これは､ TypeScriptがroleはstringかnumber

02:38.010 --> 02:52.580
arrayの型であるべきだと知っているだけなので､ ここで2番目の要素に数値を代入し､ したがってそれを数値に置き換えることは､ 一般的にそこで使用できる型について何かを言っているだけなので許されるでしょう｡

02:52.580 --> 02:55.040
まさにそのような体制にしたいことは分かっています｡ 

02:55.040 --> 03:01.770
2つの要素､ 1つ目の要素は数字､ 2つ目の要素は文字列ですが､ TypeScriptではそのようなことはありません｡

03:01.770 --> 03:01.770
そんなときは､

03:01.770 --> 03:05.865
タプルを使えばいいんです｡ ロールの種類を明示的に設定することで､

03:05.865 --> 03:10.865
TypeScriptにロールがどうあるべきかを伝えることができる｡

03:11.010 --> 03:13.230
ここでは､ TypeScriptがフォトタイプしないが､

03:13.230 --> 03:19.927
明示的にオーバーライドしたい例もある｡

03:19.927 --> 03:19.927
そこで､

03:19.927 --> 03:23.041
personの後にコロンを付け､ 中括弧を付けて､ namesは文字列､

03:23.041 --> 03:31.180
ageは数値､ hobbiesは文字列の配列として､ 明示的にオブジェクト型を追加することができるようにした｡

03:31.180 --> 03:33.740
つまり､ すべてTypeScriptの推論通り｡ 

03:33.740 --> 03:35.401
そのため､ このような明確な課題は必要なく､

03:35.401 --> 03:38.789
あなたが学んだように､ それは悪いことだったでしょう｡

03:38.789 --> 03:40.470
しかし､ ここでは推論が思い通りにいかず､

03:40.470 --> 03:47.510
roleをタプルに設定するシナリオを考えてみます｡

03:47.510 --> 03:49.730
さて､ 2つの文字列配列や数値配列を設定したり､

03:49.730 --> 03:51.660
先ほどここで3番目ではなかった同じ型を使用する代わりに､

03:51.660 --> 03:55.180
特別な型を使用することができるようになりました｡

03:55.180 --> 03:56.810
また角括弧を使いますが､

03:56.810 --> 04:03.637
今度は角括弧の中に数字を入れ､ コンマを入れ､ さらに文字列を入れます｡

04:03.637 --> 04:07.340
ここで､ タプル型をマークしています｡ 

04:07.340 --> 04:10.729
タプルは特殊な構造で､ TypeScriptが理解する､

04:10.729 --> 04:13.310
Javaスクリプトでは通常の配列になりますが､

04:13.310 --> 04:18.190
TypeScriptでの開発中に､ ここのようなコードでエラーになります｡

04:18.190 --> 04:20.313
さて､ タプルはどうなっているのでしょうか｡ 

04:21.620 --> 04:23.564
これは､ TypeScriptで､

04:23.564 --> 04:27.195
ちょうど2つの要素を持つ特別な配列にしたいんです｡ なぜなら､

04:27.195 --> 04:32.020
そこにはちょうど2つの型があって､ 最初の要素は数字であるべきだからです｡

04:32.020 --> 04:39.033
なぜなら､ 2番目の値として文字列を指定したいのに､

04:40.663 --> 04:56.544
2番目の値として10を指定したら､ 明らかにこのルールに従わないからです｡

04:56.544 --> 05:01.544
これをコメントアウトしてコンパイルすると､ うまくいきます｡ 

05:02.240 --> 05:06.290
なぜなら､ role は正確に 2 つの要素を持つべきであり､

05:06.290 --> 05:08.610
なぜ admin を role

05:08.610 --> 05:14.980
配列にプッシュできるのかがわからないからです｡

05:14.980 --> 05:19.300
プッシュは､ 実はタプルで許される例外なのです｡ 

05:19.300 --> 05:22.410
残念ながらTypeScriptはこのエラーをキャッチすることはできないが､

05:22.410 --> 05:24.840
少なくとも間違った値を代入していないことは確認できたし､

05:24.840 --> 05:31.500
push以外では長さに関するサポートも得られた｡

05:31.500 --> 05:33.671
その役割をpersonに設定すると､ 新しい値になります｡ 

05:33.671 --> 05:36.420
例えば､ 空の配列はダメで､

05:36.420 --> 05:43.510
上で定義した通りの構造の配列はOKです｡

05:43.510 --> 05:45.880
そうすると､ またエラーが出る｡ 

05:45.880 --> 05:50.720
つまり､ このように割り当てると長さが強制されますが､ プッシングなどではそうではありません｡

05:50.720 --> 05:52.840
もし､ 配列の中に正確にX個の値が必要で､

05:52.840 --> 05:57.899
それぞれの値の型があらかじめわかっているようなシナリオがあるならば､

05:57.899 --> 06:17.543
配列の代わりにタプルを検討して､ 作業しているデータの型と期待しているデータの型をより明確にするために､ アプリにさらに厳密性を持たせることができるかもしれません｡
