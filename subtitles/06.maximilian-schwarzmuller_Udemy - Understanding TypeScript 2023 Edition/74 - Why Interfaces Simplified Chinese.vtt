WEBVTT

00:02.250 --> 00:04.870
- ：既然我们知道了这些强大的功能, 一个显而易见的问题是,

00:04.870 --> 00:07.960
我们为什么要使用它？

00:07.960 --> 00:09.610
为什么这有帮助？

00:09.610 --> 00:15.820
它在这种情况下很有用, 我们知道我们需要一组特定的功能｡

00:15.820 --> 00:21.910
比如说一个greet方法, 我们想确保一个子句有这样一个greet方法,

00:21.910 --> 00:29.570
另一个子句也有, 那么我们可以实现一个接口, 强制这个方法的存在.

00:29.570 --> 00:32.690
然后我们可以很容易地在子句之间共享功能,

00:32.690 --> 00:43.280
每个子句都必须添加自己的实现, 即在调用方法时应该执行的确切代码, 但我们在接口的帮助下强制执行特定的结构｡

00:43.280 --> 00:46.400
如果我们的代码中没有依赖于该结构的其他部分,

00:46.400 --> 00:48.550
这将非常有用｡

00:48.550 --> 00:51.680
这里, 我们把user1设为Greetable类型,

00:51.680 --> 00:55.240
这样我们就不关心user里面有什么, 但里面必须有一个greet方法,

00:55.240 --> 01:03.510
我们知道它必须在里面, 因为user1里存储的东西必须是greetable的.

01:03.510 --> 01:07.350
这使得我们可以编写真正强大而灵活的代码, 我们不需要知道关于一个对象的所有信息,

01:07.350 --> 01:16.210
或者关于一个子句的所有信息, 我们只需要知道, user1中的任何内容都必须有一个greet方法｡

01:16.210 --> 01:18.850
我们不关心Person是否还有其他内容,

01:18.850 --> 01:20.630
这里我们对greet感兴趣,

01:20.630 --> 01:22.400
因此我们将我们发送到Greetable,

01:22.400 --> 01:32.333
因此我们不能在user1中存储任何没有greet方法的内容, 因为Greetable会强制基于它的任何内容都有这样的greet方法｡
