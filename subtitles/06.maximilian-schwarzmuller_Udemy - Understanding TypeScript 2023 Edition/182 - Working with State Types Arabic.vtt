WEBVTT

00:02.260 --> 00:03.920
الشرح: حان الوقت لإدارة بعض الحالات

00:03.920 --> 00:05.340
في مكون التطبيق ، لأنه عندما

00:05.340 --> 00:07.240
نقوم بتحديث المصفوفة مثل هذا ، لن يتم

00:07.240 --> 00:08.880
إعادة تصيير المكون.

00:08.880 --> 00:10.530
هذه هي الطريقة التي يعمل بها React.

00:10.530 --> 00:12.590
في مكون وظيفتنا ، يمكننا إدارة

00:12.590 --> 00:15.000
الحالة باستخدام الخطاف useState.

00:15.000 --> 00:16.820
ومرة أخرى ، إذا كنت لا تعرف هذا

00:16.820 --> 00:18.750
أو إذا كانت مكونات الحالة أو الوظيفة

00:18.750 --> 00:21.120
أو الخطافات لا تخبرك بأي شيء ، فراجع بالتأكيد

00:21.120 --> 00:23.810
بعض موارد React المخصصة مثل React ، الدورة

00:23.810 --> 00:26.480
الإرشادية الكاملة.

00:26.480 --> 00:29.870
لذا ، أريد الآن إدارة المهام الخاصة بي هنا مع الحالة

00:29.870 --> 00:31.760
، ولهذا سأقوم بمسح تلك الأشياء

00:31.760 --> 00:33.060
الوهمية التي بدأت بها

00:33.060 --> 00:36.430
، وبدلاً من ذلك ، أهيئ الحالة عن طريق استدعاء useState

00:36.430 --> 00:39.080
، ومع ذلك ، يمكنني تمرير المصفوفة الفارغة

00:39.080 --> 00:41.210
كبداية قيمة الحالة بحيث تكون حالتي

00:41.210 --> 00:44.510
في البداية مصفوفة فارغة.

00:44.510 --> 00:47.100
الآن تُرجع useState دائمًا مصفوفة

00:47.100 --> 00:49.370
تحتوي على عنصرين بالضبط.

00:49.370 --> 00:52.070
العنصر الأول هو أحدث لقطة حالة

00:52.070 --> 00:53.630
لدورة العرض هذه.

00:53.630 --> 00:55.070
أما الوسيطة الثانية

00:55.070 --> 00:56.720
، العنصر الثاني في المصفوفة

00:56.720 --> 00:58.860
فهي دالة لتحديث تلك الحالة وإعادة

00:58.860 --> 01:01.110
تصيير المكون.

01:01.110 --> 01:02.660
يمكننا استخدام إعادة هيكلة

01:02.660 --> 01:05.060
المصفوفة التي تعلمنا عنها سابقًا في

01:05.060 --> 01:07.060
الدورة ، لسحب هذين العنصرين وتخزينهما

01:07.060 --> 01:09.230
في ثوابت منفصلة.

01:09.230 --> 01:10.900
ثم لدينا هنا todos ولنقل

01:10.900 --> 01:13.103
دالة باسم setTodos.

01:14.920 --> 01:16.820
مع ذلك ، ما زلنا نحصل على مجموعة

01:16.820 --> 01:19.530
todos الخاصة بنا والآن هنا في todoAddHandler

01:19.530 --> 01:21.480
، أريد استدعاء setTodos وتعيين

01:21.480 --> 01:24.430
مصفوفة todos الخاصة بي على مصفوفة جديدة ، والتي

01:24.430 --> 01:27.373
تمت إضافة todoText الجديد إليها.

01:28.240 --> 01:29.283
الآن لذلك ، يمكننا

01:30.400 --> 01:32.130
بالطبع تمرير مصفوفة جديدة

01:32.130 --> 01:34.100
وإضافة كائن جديد ، دعنا نقول باستخدام

01:34.100 --> 01:36.530
معرف ، حيث نقوم بإنشاء معرف عشوائي باستخدام

01:36.530 --> 01:42.530
الرياضيات.

01:42.530 --> 01:42.530
عشوائي(). إلى سلسلة.

01:42.530 --> 01:44.830
إنه ليس فريدًا حقًا ، ولكنه جيد بما فيه الكفاية

01:44.830 --> 01:46.620
هنا ، وحيث لدينا أيضًا نصنا ، وهي

01:46.620 --> 01:48.760
قيمة النص التي أحصل عليها هنا.

01:48.760 --> 01:51.910
لكن الغريب أنني أتلقى خطأ هنا.

01:51.910 --> 01:54.790
والخطأ الذي نواجهه هو أن هذه الحجة

01:54.790 --> 01:56.860
غير قابلة للتخصيص.

01:56.860 --> 01:59.630
حسنًا ، في الأساس شيء يتوقع أن يكون

01:59.630 --> 02:01.970
لديه مجموعة من لا شيء.

02:01.970 --> 02:03.590
وهذا بالطبع ليس ما تريده هنا.

02:03.590 --> 02:06.010
لا نريد أن يكون لدينا مجموعة لا شيء مثل دولتنا.

02:06.010 --> 02:07.110
لماذا يحدث هذا؟

02:07.950 --> 02:11.800
لأنه هنا عندما أقوم بتهيئة useState بمصفوفة فارغة ، يستنتج

02:11.800 --> 02:15.040
TypeScript كيف ستبدو حالتنا ، إذا كنت سأهيئ هذا

02:15.040 --> 02:17.060
إلى سلسلة ، فإن TypeScript سيستنتج

02:17.060 --> 02:20.130
أن حالتي عبارة عن سلسلة.

02:20.130 --> 02:23.010
لذلك إذا قمت بإزالة هذا مؤقتًا وقمت بتمرير بعض النص

02:23.010 --> 02:24.123
، فسيتم قبوله.

02:25.160 --> 02:26.137
إذا قمت بتمريرها

02:26.137 --> 02:28.260
في مصفوفة ، تتوقع TypeScript أنها مصفوفة

02:28.260 --> 02:30.080
ولكنها ليست مصفوفة من أي شيء ، ولكنها

02:30.080 --> 02:32.000
دائمًا مصفوفة فارغة.

02:32.000 --> 02:36.070
إذن مجموعة من لا شيء لا أريده هنا بالطبع.

02:36.070 --> 02:38.050
لإصلاح هذا علينا إخبار React

02:38.050 --> 02:40.460
، كيف ستبدو ممتلكاتنا بمرور الوقت.

02:40.460 --> 02:42.920
ومن أجل ذلك يمكننا مرة أخرى استخدام

02:42.920 --> 02:44.630
أن useState هي وظيفة عامة

02:44.630 --> 02:48.080
، لأننا نستطيع تمرير بنية ممتلكاتنا.

02:48.080 --> 02:51.240
إذن أي نوع من البيانات هي حالتنا ، وهناك

02:51.240 --> 02:54.200
يمكننا أن نمرر في أن حالتنا يجب أن تكون

02:54.200 --> 02:56.253
مصفوفة من الكائنات ، على وجه

02:57.210 --> 02:59.570
الدقة ومجموعة من الكائنات حيث

02:59.570 --> 03:02.750
لدينا خاصية ID وهي سلسلة ، وخاصية نص ، والتي

03:02.750 --> 03:04.860
عبارة عن سلسلة.

03:04.860 --> 03:08.050
والآن يُسمح بتحديث الحالة هذا.

03:08.050 --> 03:10.100
الآن كتابة هذا هنا جيد بالطبع ولكن بما أننا سنحتاجه

03:10.100 --> 03:12.410
في أماكن مختلفة في التطبيق ، سأقوم بالفعل بإنشاء ملف

03:12.410 --> 03:16.710
جديد وأسمي هذا الأمر. نموذج. ts.

03:16.710 --> 03:18.210
اسم الملف متروك لك.

03:18.210 --> 03:19.940
وهنا أرغب في التصدير بشكل

03:19.940 --> 03:21.710
أساسي ، اسم واجهة Todo حيث أريد

03:21.710 --> 03:24.080
فقط أن أصف كيف يجب أن يبدو معرف Todo الخاص

03:24.080 --> 03:25.440
بنا في تطبيقي الذي أريد

03:25.440 --> 03:27.430
الحصول على معرف من نوع سلسلة ،

03:27.430 --> 03:30.190
وخاصية نصية من نوع سلسلة.

03:30.190 --> 03:34.420
وبهذا الذي تم تصديره هنا في مكون التطبيق ، يمكننا

03:34.420 --> 03:35.900
استيراد هذا حتى

03:35.900 --> 03:38.210
يمكننا هنا استيراد Todo

03:39.080 --> 03:42.543
من. /لكى يفعل. نموذج.

03:43.900 --> 03:46.720
وهنا ببساطة لدينا مجموعة من المهام التي

03:46.720 --> 03:49.550
هي بالطبع أقصر وأسهل في القراءة.

03:49.550 --> 03:51.480
والآن لا يزال تحديث الحالة يعمل

03:51.480 --> 03:52.870
، لكن هذا أنظف قليلاً.

03:52.870 --> 03:55.100
وهذا كما ترون مهم حقًا هنا عند العمل

03:55.100 --> 03:57.210
مع شيء مثل المصفوفة حيث أنواع المحتوى

03:57.210 --> 03:59.170
الخاصة بنوع البيانات التي تريد

03:59.170 --> 04:01.860
تخزينها في النهاية ، إذا قمت بتهيئتها

04:01.860 --> 04:04.270
بمصفوفة فارغة.

04:04.270 --> 04:06.250
مع هذا كيف يعمل.

04:06.250 --> 04:07.450
الجانب السلبي بالطبع

04:07.450 --> 04:09.910
هو أن منطق تحديث حالتنا هنا غير صحيح

04:09.910 --> 04:13.670
، لأنني الآن أكتب دائمًا فوق المصفوفة الحالية من todos

04:13.670 --> 04:17.400
بمصفوفة جديدة تحتوي على عنصر واحد فقط.

04:17.400 --> 04:20.110
وبدلاً من ذلك ، أريد استبدالها بمصفوفة جديدة تحتوي

04:20.110 --> 04:23.730
على جميع العناصر القديمة بالإضافة إلى العنصر الجديد.

04:23.730 --> 04:26.583
لذلك دعونا نعدل هذا المنطق في المحاضرة القادمة.
