WEBVTT

00:02.220 --> 00:04.080
-: الآن أنواع التقاطع شيء واحد.

00:04.080 --> 00:05.470
ومع ذلك ، فإن الاستخدام في كثير

00:05.470 --> 00:07.800
من الأحيان هو ميزة أخرى ، وهي ميزة الحماية من

00:07.800 --> 00:10.590
الكتابة ، وهي ميزة استخدمناها بالفعل قليلاً.

00:10.590 --> 00:12.400
دعنا نستخدم Combinable هنا.

00:12.400 --> 00:15.560
إنه نوع اتحاد حيث يكون لدينا إما سلسلة أو رقم ، ويساعدنا

00:15.560 --> 00:18.020
حراس الكتابة في أنواع النقابات لأنه

00:18.020 --> 00:21.050
في حين أنه من الجيد أن تتمتع بالمرونة ، فغالبًا

00:21.050 --> 00:23.610
ما تحتاج إلى معرفة النوع الدقيق الذي تحصل

00:23.610 --> 00:26.200
عليه الآن في وقت التشغيل.

00:26.200 --> 00:28.630
لنفترض هنا أن لدينا دالة الجمع

00:28.630 --> 00:33.070
حيث أحصل على رقم يجب أن يكون من النوع Combinable ، أي سلسلة

00:33.070 --> 00:35.100
أو رقم ، وبالتالي ، سأسميه

00:35.100 --> 00:37.990
هنا بالفعل ، ثم حصلت على وسيطة أخرى

00:37.990 --> 00:39.520
تحتاج أيضًا لتكون

00:39.520 --> 00:42.110
قابلة للدمج ، أي رقم أو سلسلة ، ثم

00:42.110 --> 00:44.640
أريد إرجاع أ زائد ب.

00:44.640 --> 00:47.020
الآن رأينا في الماضي أن هذا لا يعمل.

00:47.020 --> 00:51.320
بدلاً من ذلك ، نحتاج الآن إلى التحقق مما إذا كان typeof

00:51.320 --> 00:53.740
a يساوي سلسلة ، على سبيل المثال

00:55.660 --> 00:59.780
، أو typeof b يساوي سلسلة ، وإذا كانت هذه هي الحالة

00:59.780 --> 01:04.681
، فإننا نعيد a.

01:04.681 --> 01:04.681
toString plus ب. إلى سلسلة.

01:04.681 --> 01:06.750
لذلك نجمع بين هاتين السلسلتين ؛

01:06.750 --> 01:09.570
خلافًا لذلك ، إذا لم يتم إدخالها في عبارة if

01:09.570 --> 01:11.510
هذه ، فسنقوم بإرجاع a زائد b مثل

01:11.510 --> 01:13.270
هذا لأن مجموعة الأنواع تعرف

01:13.270 --> 01:15.620
الآن أن a و b يجب أن يكونا أرقام هنا ، لأنه

01:15.620 --> 01:18.230
إذا لم يكن أحدهما على الأقل رقمًا ، فسنكون

01:18.230 --> 01:19.710
كذلك هنا.

01:19.710 --> 01:22.890
يُطلق على هذا هنا اسم حارس النوع لأنه

01:22.890 --> 01:25.280
يسمح لنا بالاستفادة من المرونة

01:25.280 --> 01:27.980
التي توفرها لنا أنواع الاتحاد

01:27.980 --> 01:32.550
مع ضمان تشغيل الكود الخاص بنا بشكل صحيح في وقت التشغيل

01:32.550 --> 01:34.830
، لأنه غالبًا ما يكون لديك

01:34.830 --> 01:38.160
وظائف تعمل مع نوعين أو ثلاثة أنواع مختلفة

01:38.160 --> 01:40.570
، وبالتالي ، نوع الاتحاد مثالي

01:40.570 --> 01:43.890
، لكن ما تفعله بالضبط بالقيم يعتمد على

01:43.890 --> 01:46.940
النوع ، كما هو الحال هنا ، حيث إما أن

01:46.940 --> 01:51.670
نتسلسل أو نضيف رياضيًا.

01:51.670 --> 01:55.310
الآن هذا نوع حارس باستخدام typeof.

01:55.310 --> 01:58.970
يمكنك أيضًا كتابة أنواع أخرى من حراس الكتابة.

01:58.970 --> 02:00.880
ومن أجل ذلك ، دعني أعود إلى أنواع

02:00.880 --> 02:03.050
المسؤولين والموظفين لديّ ، حيث حصلت

02:03.050 --> 02:04.950
على امتيازات في المسؤول وتاريخ

02:04.950 --> 02:06.943
البدء على الموظف.

02:08.590 --> 02:11.810
الآن لدينا الموظف المرتفع الذي يجمع بين كليهما.

02:11.810 --> 02:14.980
الآن أيضًا قم بإنشاء نوع آخر هنا.

02:14.980 --> 02:16.330
هذا هو الموظف المجهول.

02:18.000 --> 02:21.940
هذا إما مجرد موظف أو مسؤول.

02:21.940 --> 02:25.540
لذلك لدينا نوع الاتحاد باستخدام نوعي الكائنات المخصصة.

02:25.540 --> 02:28.173
الموظف المجهول هو أي من الاثنين.

02:29.230 --> 02:32.003
الآن قد يكون لدينا وظيفة ، printEmployeeInformation

02:34.620 --> 02:36.420
، حيث أحتاج إلى المرور في موظف ،

02:36.420 --> 02:39.660
ويجب أن يكون ذلك من نوع الموظف غير المعروف.

02:39.660 --> 02:41.610
الآن هنا ، أريد أن أعزّي. تسجيل أجزاء مختلفة

02:41.610 --> 02:44.030
من المعلومات حول الموظف.

02:44.030 --> 02:47.210
على سبيل المثال ، الاسم من إمبراطورية. name ، والتي ستعمل بدون

02:47.210 --> 02:48.580
مشاكل لأن كلا النوعين

02:48.580 --> 02:52.140
من الموظفين لهما خاصية الاسم.

02:52.140 --> 02:56.730
لكن بعد ذلك أريد أيضًا أن أعزّي. تسجيل الامتيازات عن طريق الوصول

02:58.160 --> 03:01.520
إلى إمبراطورية. الامتيازات ، وهنا أواجه

03:01.520 --> 03:04.350
بالفعل مشكلات في الإكمال التلقائي

03:04.350 --> 03:07.100
لأن TypeScript لا يمكنها تأكيد وجود

03:07.100 --> 03:09.890
هذا دائمًا في الوسيطة ، لأن UnknownEmployee

03:09.890 --> 03:16.260
قد يكون موظفًا عاديًا ليس لديه خاصية الامتيازات.

03:16.260 --> 03:18.330
فقط المشرف لديه ذلك.

03:18.330 --> 03:20.100
لذلك نحن الآن بحاجة إلى نوع حارس هنا.

03:20.100 --> 03:24.530
المشكلة فقط مع typeof ، لن نفوز بأي شيء.

03:24.530 --> 03:26.830
إذا تحققنا من نوع الموظف ، فسيكون

03:26.830 --> 03:29.470
ذلك مجرد كائن في وقت التشغيل.

03:29.470 --> 03:31.380
هذا لا يخبرنا ما إذا كان يحتوي

03:31.380 --> 03:32.940
على هذه الخاصية أم لا.

03:32.940 --> 03:34.960
ومن ثم ، إذا قمت بنقل الكود في هذا إذا

03:34.960 --> 03:37.430
تم التحقق ، فإن TypeScript ليس أكثر سعادة من

03:37.430 --> 03:39.750
ذي قبل لأن الكائن ، حسنًا ، مجرد كائن.

03:39.750 --> 03:41.920
لا تخبرنا بأي شيء عن الخصائص.

03:41.920 --> 03:44.980
لا يمكننا التحقق مما إذا كان من النوع الموظف

03:44.980 --> 03:48.130
لأن هذا ليس نوعًا يعرفه JavaScript ، وتذكر أن

03:48.130 --> 03:49.840
هذا الفحص يتم تشغيله في وقت

03:49.840 --> 03:52.560
التشغيل ويستخدم JavaScript ، لذلك يمكننا

03:52.560 --> 03:56.190
فقط مقارنة النوع الذي يحصلنا عليه مع الأنواع التي

03:56.190 --> 03:58.010
يعرفها JavaScript ، و سيكون

03:58.010 --> 04:01.920
هذا كائنًا ، وسلسلة ، ورقمًا ، ومنطقيًا قيد التشغيل ، والنوع

04:01.920 --> 04:05.610
المخصص لدينا ليس جزءًا منه.

04:05.610 --> 04:07.950
هذا موجود فقط في عالم TypeScript

04:07.950 --> 04:11.020
، وليس في عالم JavaScript المترجم.

04:11.020 --> 04:13.990
لذلك ، هذا أيضًا لا يعمل.

04:13.990 --> 04:17.960
الآن هنا ، الحل البديل لدينا هو استخدام شيك مختلف.

04:17.960 --> 04:20.240
نحن نعلم أننا نريد الوصول إلى الامتيازات

04:20.240 --> 04:25.240
، حتى نتمكن من التحقق مما إذا كانت امتيازات الموظف شيئًا.

04:26.400 --> 04:28.560
تكمن المشكلة فقط في أن TypeScript لا

04:28.560 --> 04:30.690
يسمح لنا بالوصول إلى هذه الخاصية على

04:30.690 --> 04:33.550
الإطلاق ، ولا حتى للتحقق منها بهذه الطريقة ، ولكن

04:33.550 --> 04:36.200
هناك طريقة مختلفة لنا للتحقق منها.

04:36.200 --> 04:40.000
يمكننا استخدام الكلمات الرئيسية المضمنة في JavaScript.

04:40.000 --> 04:43.120
يمكننا التحقق مما إذا كانت الامتيازات

04:43.120 --> 04:46.690
، المكتوبة الآن كسلسلة ، موجودة في emp.

04:46.690 --> 04:49.130
هذا هو رمز JavaScript الذي يسمح

04:49.130 --> 04:53.480
بالتحقق مما إذا كان هذا موجودًا كخاصية على الموظف ،

04:53.480 --> 04:58.380
وإذا كانت هذه هي الحالة ، يكتشف TypeScript هذا التحقق هنا

04:58.380 --> 05:01.200
، وبالتالي ، يسمح لنا بالوصول إلى

05:01.200 --> 05:04.543
هذه الخاصية داخل هذا إذا تحقق هنا.

05:05.852 --> 05:08.380
ويمكننا تكرار ذلك في startDate

05:08.380 --> 05:12.240
، وبالتالي ، التحقق مما إذا كان startDate خاصية

05:12.240 --> 05:15.710
هنا ، وبالتالي يمكننا أيضًا إخراج هذا في

05:16.970 --> 05:18.730
هذا إذا تحقق.

05:18.730 --> 05:23.687
والآن بعد ذلك ، إذا استدعينا printEmployeeInformation ، وقمنا

05:24.650 --> 05:28.363
بتمرير ذلك الموظف الذي أنشأناه ، e1 ، فسترى أن

05:31.410 --> 05:34.860
هذا تم تجميعه بدون أخطاء ، وبالفعل ، ينتج عنه

05:34.860 --> 05:37.430
الامتيازات ، حسنًا ، هنا أيضًا يجب

05:37.430 --> 05:40.730
أن تقول البيانات أيضًا تاريخ البدء هنا ،

05:40.730 --> 05:42.530
بالطبع.

05:42.530 --> 05:45.820
ولكن مع ذلك ، فإنه يعطينا الناتج الذي نتوقعه.

05:45.820 --> 05:48.590
ومن ناحية أخرى ، إذا مررنا موظفًا ليس لديه

05:48.590 --> 05:50.950
كل هذه الحقول ، على سبيل المثال ، إذا

05:50.950 --> 05:53.090
أنشأنا واحدًا سريعًا له تاريخ

05:53.090 --> 05:56.383
بداية فقط ولكن بدون امتيازات ، فهناك كل الأعمال

05:57.850 --> 06:00.370
التي تم تجميعها دون أخطاء ، و نحن ببساطة

06:00.370 --> 06:03.160
لا نطبع أي شيء عن الامتيازات بسبب هذا إذا

06:03.160 --> 06:05.723
تحقق لدينا هناك.

06:07.650 --> 06:09.800
عند العمل مع الفئات ، يمكنك

06:09.800 --> 06:13.070
أيضًا استخدام نوع آخر من نوع guard ،

06:13.070 --> 06:16.520
وسيكون هذا هو مثيل النوع guard.

06:16.520 --> 06:21.460
لنفترض أن لدينا فئة ، سيارة ، ولدينا طريقة قيادة حيث

06:21.460 --> 06:26.523
نقول فقط وحدة التحكم.

06:26.523 --> 06:26.523
سجل

06:28.480 --> 06:31.750
القيادة ، ولدينا فئة أخرى ، هي Truck ، التي

06:31.750 --> 06:34.623
لديها أيضًا طريقة قيادة ، أو ربما تقول

06:35.840 --> 06:38.280
قيادة شاحنة ، لكن يتعين علينا ذكر

06:38.280 --> 06:40.250
اسم الطريقة.

06:40.250 --> 06:43.980
وحيث لدينا أيضًا طريقة لود كارجو ، حيث لدينا

06:43.980 --> 06:46.570
مبلغ ، وهو رقم ، ثم هنا لدي فقط

06:46.570 --> 06:49.040
بعض الرموز الوهمية حيث أقول

06:49.040 --> 06:53.570
، "تحميل البضائع بالإضافة إلى المبلغ. شيء من هذا القبيل ، عفوا ، كمية ، شيء من هذا القبيل.

06:53.570 --> 06:57.323
إذن لدينا الآن صنفان ، لديهما بالطبع بعض التشابه

06:58.170 --> 06:59.320
، طريقة القيادة

06:59.320 --> 07:02.090
، ولكن هناك أيضًا اختلاف.

07:02.090 --> 07:03.890
الآن ، مرة أخرى ، يمكننا

07:03.890 --> 07:08.200
إنشاء نوع اتحاد هنا ، مركبة ، وهي إما سيارة أو شاحنة

07:08.200 --> 07:13.030
، والآن ، دعنا نقول ، قمنا بإنشاء مركبة جديدة ، v1 ، وهي سيارة

07:13.030 --> 07:18.030
جديدة ، ومركبة أخرى ، v2 ، والتي هي شاحنة جديدة.

07:18.050 --> 07:21.873
الآن لديّ وظيفة ، useVehicle ، التي تتوقع فقط الحصول

07:23.890 --> 07:26.443
على مركبة ، والتي يجب أن تكون من نوع المركبات

07:27.700 --> 07:29.780
، لذلك يجب أن تكون من هذا النوع

07:29.780 --> 07:31.350
النقابي.

07:31.350 --> 07:34.203
هنا نحصل على سيارة ، والآن ، دعنا نقول ، هدفنا هنا

07:35.420 --> 07:37.490
هو القيام بكل ما يمكننا القيام به مع

07:37.490 --> 07:40.040
المركبات: القيادة وتحميل البضائع.

07:40.040 --> 07:43.400
لذلك ، بالطبع ، يمكننا استدعاء السيارة. القيادة لأن ذلك موجود دائمًا ، ولكن

07:43.400 --> 07:45.420
للمركبة. loadCargo ، لدينا

07:45.420 --> 07:50.010
مشكلة لأن الشاحنة فقط لديها ذلك.

07:50.010 --> 07:52.720
السيارة لا تملكها ، لذا لن ينجح هذا.

07:52.720 --> 07:56.440
يمكننا الآن ، بالطبع ، مرة أخرى ، التحقق مما إذا كانت loadCargo في السيارة

07:56.440 --> 07:59.513
، وإذا كانت هذه هي الحالة ، فيمكننا استخدامها.

08:00.760 --> 08:05.760
على الأقل إذا أصلحت هذا الخطأ المطبعي هنا.

08:06.430 --> 08:09.480
لذلك نحفظها الآن ثم نسميها useVehicle

08:09.480 --> 08:13.230
ونمرر v1 ، ثم نسميها مرة أخرى بـ v2 ، وقمت

08:13.230 --> 08:17.400
بحفظ كل ذلك ، وهي تُجمِّع ، وهي تعمل.

08:17.400 --> 08:21.680
الآن هذه طريقة واحدة للقيام بذلك.

08:21.680 --> 08:23.340
الطريقة البديلة ، التي

08:23.340 --> 08:26.580
قد تكون أكثر أناقة قليلاً لأنها تقضي أيضًا على

08:26.580 --> 08:28.600
مخاطر الكتابة الخاطئة في سلسلة

08:28.600 --> 08:31.920
الخاصية هذه هنا ، هي أن تستخدم exampleof.

08:31.920 --> 08:34.080
يمكننا التحقق مما إذا كانت السيارة مثال للشاحنة.

08:34.080 --> 08:39.080
إذا كان الأمر كذلك ، فنحن نعلم أنه سيكون لها طريقة لوادكارجو.

08:39.360 --> 08:42.510
المثيل هو عامل عادي مضمن في Vanilla

08:42.510 --> 08:45.230
JavaScript ، لذلك هذا ليس رمز

08:45.230 --> 08:47.430
TypeScript.

08:47.430 --> 08:49.280
تمامًا مثل typeof ، يعد هذا جزءًا

08:49.280 --> 08:52.250
من JavaScript ويتم تنفيذه في وقت التشغيل.

08:52.250 --> 08:54.290
لا تعرف JavaScript نوع الشاحنة

08:54.290 --> 08:56.780
، لكنها تعرف وظائف المُنشئ ، ويتم ترجمة

08:56.780 --> 08:59.330
الفئات في النهاية فقط إلى وظائف المُنشئ

08:59.330 --> 09:01.490
، ويمكن لـ TypeScript بعد ذلك معرفة

09:01.490 --> 09:03.400
ما إذا تم إنشاء السيارة بناءً

09:03.400 --> 09:06.580
على وظيفة مُنشئ الشاحنة.

09:06.580 --> 09:10.290
لذلك نظرًا لأن الفئات يتم تجميعها إلى شيء تفهمه

09:10.290 --> 09:11.970
JavaScript ، ووظائف

09:11.970 --> 09:15.450
المُنشئ ، فهي قادرة على استخدام ذلك.

09:15.450 --> 09:17.210
إذا كنا سنستخدم واجهة هنا بدلاً

09:17.210 --> 09:20.390
من فصل دراسي ، وبالتالي ، بالطبع ، لا يمكننا تطبيق التنفيذ

09:20.390 --> 09:21.223
هنا ، لكننا سنفعل

09:21.223 --> 09:22.950
ذلك عندما ننشئ كائنًا باستخدام

09:22.950 --> 09:25.130
التدوين الحرفي للكائن ، عندئذٍ يمكننا

09:25.130 --> 09:27.300
لا تستخدم مثيلًا لأن الواجهات ، كما

09:27.300 --> 09:30.940
تعلمت ، لا يتم تجميعها إلى أي كود جافا سكريبت ، وبالتالي لا يمكننا

09:30.940 --> 09:34.370
استخدامها في وقت التشغيل.

09:34.370 --> 09:37.160
بالنسبة للفئات ، يمكننا القيام بذلك لأن JavaScript

09:37.160 --> 09:40.010
يدعم الفئات ووظائف المُنشئ ، وباستخدام exampleof

09:40.010 --> 09:42.290
، يمكنك بعد ذلك معرفة ما إذا كان بعض الكائنات

09:42.290 --> 09:44.500
يعتمد على تلك الفئة.

09:44.500 --> 09:47.660
إذا عرفنا ما إذا كان الأمر كذلك ، فسيكون لدينا وظيفة loadCargo.

09:47.660 --> 09:51.850
لذا فهؤلاء هم حراس النوع.

09:51.850 --> 09:53.480
في النهاية ، فإن حراس

09:53.480 --> 09:55.890
الكتابة هو مجرد مصطلح يصف فكرة

09:55.890 --> 09:59.470
أو طريقة التحقق مما إذا كانت خاصية أو طريقة

09:59.470 --> 10:02.980
معينة موجودة قبل محاولة استخدامها ، أو إذا

10:02.980 --> 10:06.310
كان بإمكانك فعل شيء بهذا النوع قبل محاولة

10:06.310 --> 10:08.470
استخدامه.

10:08.470 --> 10:10.220
بالنسبة للكائنات ، يمكن القيام

10:10.220 --> 10:15.113
بذلك باستخدام exampleof أو مع in ، بالنسبة للأنواع الأخرى ، يمكنك استخدام

10:16.140 --> 10:19.780
typeof ، وبالتالي ، لديك الآن كل المرونة لاستخدام أنواع

10:19.780 --> 10:22.280
اتحادات المرونة التي تمنحك وما زلت تكتب

10:22.280 --> 10:25.090
رمزًا يقوم بشيء واحد أو الآخر بناءً على النوع

10:25.090 --> 10:29.050
الدقيق الذي تحصل عليه في وقت التشغيل.
