WEBVTT

00:02.310 --> 00:06.000
教师：所以现在我们的目标是把项目从A带到B｡

00:06.000 --> 00:09.750
确切地说, 当用户创建一个新项目, 当他们输入所有数据时,

00:09.750 --> 00:11.850
我们希望在最后创建一个新的项目对象,

00:11.850 --> 00:21.990
然后在我们的项目列表类中输出该对象, 作为无序列表的一部分, 在那里呈现｡

00:21.990 --> 00:23.299
就是这个意思

00:23.299 --> 00:34.513
当然, 实现这一点的一个简单方法是简单地转到用户输入的地方, 然后在这里使用document｡

00:34.513 --> 00:34.513
getElementbyId,

00:36.100 --> 00:44.470
以获取我们作为项目列表类一部分呈现无序列表, 该列表在此处具有此ID, 即活动项目列表或已完成项目列表,

00:44.470 --> 00:52.760
然后只需获取该列表并向其添加新项｡

00:52.760 --> 00:57.250
但这并不是我想要构建这个应用程序的真正想法｡

00:57.250 --> 00:59.800
我想用一种面向对象的方式来构建它,

00:59.800 --> 01:02.530
我们有不同的类, 它们以一种反应的方式一起工作,

01:02.530 --> 01:10.550
我们创建一个新类, 然后在dom中发生一些事情｡

01:10.550 --> 01:14.650
我们调用一个类的一个方法然后这个类做一些事情｡

01:14.650 --> 01:16.980
我就想这样｡ 

01:16.980 --> 01:21.550
当然我们可以在项目列表类中添加一个方法,

01:21.550 --> 01:24.120
比如说添加项目方法.

01:24.120 --> 01:25.890
然后, 当需要添加和呈现项目时,

01:25.890 --> 01:32.940
应该调用该方法, 并且我们必须找到从项目输入内部调用它的某种方法｡

01:32.940 --> 01:37.940
要做到这一点, 我们可以确保我们实际上传递了对列表的引用,

01:37.940 --> 01:42.810
传递给项目输入构造函数, 这样我们就可以在项目输入类中,

01:42.810 --> 01:47.570
使用这些具体的实例, 并调用这些实例上的方法｡

01:47.570 --> 01:50.260
因为这是我们必须要做的｡ 

01:50.260 --> 01:52.050
这将是一个可行的方法,

01:52.050 --> 01:54.400
绝对是一个你可以采取的方法,

01:54.400 --> 01:58.680
但我想采取一个更抽象的方法｡

01:58.680 --> 02:01.393
在我看来更有趣的方法｡ 

02:02.330 --> 02:06.210
我将构建一个类来管理应用程序的状态,

02:06.210 --> 02:08.110
也就是说, 一个管理项目的类,

02:08.110 --> 02:21.670
或者我们可能需要在应用程序中管理的任何状态, 它还允许我们在应用程序中感兴趣的不同部分设置侦听器｡

02:21.670 --> 02:27.050
如果您使用的是Angular之类的框架或React和Redux之类的库,

02:27.050 --> 02:29.820
那么您可能对这种模式很熟悉｡

02:29.820 --> 02:35.443
你有一个全局状态管理对象, 你只是监听变化｡

02:35.443 --> 02:37.480
这就是我想要实现的｡ 

02:37.480 --> 02:41.660
当然, 这只是一种方法, 但我认为这是一种非常有趣的方法,

02:41.660 --> 02:43.680
这就是为什么我想展示它｡

02:43.680 --> 02:45.908
因此, 在appts文件的顶部,

02:45.908 --> 02:50.350
我将添加一个项目状态管理类｡

02:50.350 --> 02:57.210
而我将简单地命名为projectState;听起来是个合理的名字｡

02:57.210 --> 02:59.900
这里的想法是, 在这个类中,

02:59.900 --> 03:03.760
我们有一个属性或字段, 一个私有字段,

03:03.760 --> 03:08.800
项目, 它包含一个项目数组.

03:08.800 --> 03:13.360
现在, 我们还需要定义项目的外观, 我们将在下一步骤中进行定义｡

03:13.360 --> 03:15.830
现在, 我只说它是一个任何内容的数组,

03:15.830 --> 03:22.240
当然, 这不是完美的, 也不是最终的, 但我现在想重点介绍状态管理解决方案｡

03:22.240 --> 03:25.653
所以我们有这个项目列表｡ 

03:26.530 --> 03:30.163
现在, 我的目标是, 每当我们单击此处的“添加项目”按钮时,

03:30.163 --> 03:35.163
我都希望向该列表中添加一个项目｡

03:36.940 --> 03:39.970
为了实现这一点, 我将在项目状态类中添加一个add

03:39.970 --> 03:43.460
project方法, 一个公共方法｡

03:43.460 --> 03:47.060
我希望得到标题, 应该是一个字符串,

03:47.060 --> 03:49.390
描述, 应该是一个字符串,

03:49.390 --> 03:55.220
还有参与这个项目的人数, 应该是一个数字｡

03:55.220 --> 04:00.950
然后, 在这里, 我们可以创建一个新的项目与对象文字符号现在｡

04:00.950 --> 04:12.100
每个项目都应该有一个ID, 这样我们就可以唯一地标识它, 我在这里用数学方法生成一个ID｡

04:12.100 --> 04:12.100
随机（）｡  字符串｡ 

04:12.100 --> 04:14.960
随机数并不是唯一的ID, 你可以多次生成同一个数字,

04:14.960 --> 04:22.570
但这是不可能的, 为了我们的演示目的, 它可以做到｡

04:22.570 --> 04:25.170
除此之外, 每个项目都应该有一个标题,

04:25.170 --> 04:28.370
这里会存储我们得到的标题参数｡

04:28.370 --> 04:33.830
描述也一样, 我将在这里存储描述｡

04:33.830 --> 04:37.693
而我的人在哪里我就存放多少人｡ 

04:39.700 --> 04:43.440
现在, 这是我想要存储的项目｡ 

04:43.440 --> 04:45.000
一旦我们在这里创建了它,

04:45.000 --> 04:48.853
我们就可以在projects状态下访问projects数组,

04:48.853 --> 04:50.320
这是私有的, 但是从类内部,

04:50.320 --> 04:53.340
也就是这个方法, 我们当然可以访问它｡

04:53.340 --> 04:55.900
我想在这里添加这个新项目,

04:55.900 --> 05:00.380
为此, 我们可以简单地将新项目推送到它｡

05:00.380 --> 05:03.350
现在, 我们可以添加一个项目｡ 

05:03.350 --> 05:07.027
当然, 我们仍然有一些不清楚的问题｡ 

05:07.027 --> 05:15.990
我们如何从我们的类内部调用add project, 在那里我们从提交处理程序内部收集用户输入？

05:15.990 --> 05:17.940
我们如何调用添加项目？

05:17.940 --> 05:25.690
当项目列表类发生变化时, 我们如何传递更新后的项目列表？

05:25.690 --> 05:29.230
这当然是我们目前面临的两个问题｡ 

05:29.230 --> 05:36.499
我在这里要做的一件事就是创建一个项目状态的实例｡

05:36.499 --> 05:39.720
一个全局实例, 我们可以从整个文件中使用它,

05:39.720 --> 05:42.760
我会在创建该类后立即执行此操作.

05:42.760 --> 05:47.050
所以这里我有我的项目状态常量, 我在这里实例化项目状态,

05:47.050 --> 05:50.370
就像这样｡

05:50.370 --> 05:54.620
这是一个全局常量, 可以在文件中的任何地方使用,

05:54.620 --> 06:01.660
所以和这个类对话非常简单, 你只需要在这里使用这个全局常量.

06:01.660 --> 06:04.850
我们甚至可以使用一个我们都了解过的特性,

06:04.850 --> 06:09.170
私有构造函数, 来保证这是一个单例类｡

06:09.170 --> 06:11.950
我们可以在这里创建一个私有构造函数, 然后我们在这里有另一个私有属性,

06:11.950 --> 06:14.300
instance, 它的类型是project

06:14.300 --> 06:18.933
state, 所以这个类的类型是一样的｡

06:20.640 --> 06:24.360
然后我们在这里添加一个get实例方法, 实际上是一个静态方法,

06:24.360 --> 06:30.050
在这里我们检查这个.

06:30.050 --> 06:30.050
实例是一个东西,

06:31.020 --> 06:35.800
因此, 它也必须是一个静态实例, 一个静态属性.

06:35.800 --> 06:37.100
如果这是一件东西, 如果是,

06:37.100 --> 06:39.550
我们就把它退回去｡ 实例, 因此我们返回所获得单个实例,

06:39.550 --> 06:44.590
否则我们创建一个新实例｡

06:44.590 --> 06:45.423
所以不然的话,

06:45.423 --> 06:50.423
这个｡ 实例将等于新项目状态

06:50.450 --> 06:52.963
然后我们把这个还回去｡  实例中｡ 

06:54.740 --> 07:00.903
现在, 我们可以调用下面的实例, 就像这样, ProjectState｡

07:00.903 --> 07:00.903
getInstance,

07:04.390 --> 07:06.560
我们保证始终使用完全相同的对象,

07:06.560 --> 07:11.700
并且在整个应用程序中始终只有一个该类型的对象｡

07:11.700 --> 07:12.840
这就是这里的想法,

07:12.840 --> 07:17.503
因为我只想为我们的项目提供一个状态管理对象｡

07:17.503 --> 07:21.563
这就是这个项目现在的状态｡

07:22.730 --> 07:25.890
现在我们有了项目状态常数｡ 

07:25.890 --> 07:30.270
让我们转到收集用户输入的项目输入类｡

07:30.270 --> 07:33.950
在这里, 我们现在可以调用projectState｡  addProject并转发标题､

07:33.950 --> 07:40.960
描述和人员, 最后我们从收集用户输入中返回｡

07:40.960 --> 07:43.920
现在应该创建了这个项目｡ 

07:43.920 --> 07:51.530
现在我们只需要把我们有一个新项目的信息推送到我们的项目列表类,

07:51.530 --> 07:56.500
因为这个类负责把一些东西输出到屏幕上｡

07:56.500 --> 08:00.350
为此, 我想在最后设置一个订阅模式｡

08:00.350 --> 08:03.020
在我们的项目状态中, 我们管理一个监听器列表,

08:03.020 --> 08:05.730
也就是最后的一个函数列表,

08:05.730 --> 08:11.600
只要有什么变化, 就应该调用这些函数｡

08:11.600 --> 08:12.433
因此, 我将在这里添加另一个私有属性,

08:12.433 --> 08:15.830
侦听器｡

08:15.830 --> 08:18.810
监听器是一个空数组,

08:18.810 --> 08:22.130
现在, 也是一个任意数组,

08:22.130 --> 08:25.543
我们稍后会详细说明.

08:26.760 --> 08:31.382
现在我还需要一个方法addListener,

08:31.382 --> 08:39.150
在这里我得到一个监听器函数, 所以这应该是最后的一个函数.

08:39.150 --> 08:41.370
然后我会把这个加给我的听众｡ 

08:41.370 --> 08:46.500
我们把监听器函数推到监听器数组.

08:46.500 --> 08:49.580
现在, 让listeners数组出现的想法是什么？

08:49.580 --> 08:51.110
它是一个函数数组,

08:51.110 --> 08:53.070
函数引用数组？

08:53.070 --> 08:55.250
其思想是, 每当发生变化时,

08:55.250 --> 08:59.790
就像这里添加新项目时, 我们调用所有侦听器函数｡

08:59.790 --> 09:03.050
我们遍历所有的监听器, 这个监听器的,

09:03.050 --> 09:04.720
所有的监听器函数,

09:04.720 --> 09:11.593
由于这些都是函数引用, 我们可以把它作为函数来执行.

09:13.010 --> 09:14.630
对于这个函数, 我们传递了与之相关的东西,

09:14.630 --> 09:23.280
基于我们管理的状态, 在这个例子中, 在这个类中, 就是我们的项目列表.

09:23.280 --> 09:27.983
这是此类负责的状态｡ 

09:29.100 --> 09:29.933
在这里,

09:30.980 --> 09:33.050
我转发这个项目, 并调用slice,

09:33.050 --> 09:35.170
只返回该数组的副本,

09:35.170 --> 09:39.100
而不是原始数组.

09:39.100 --> 09:44.210
这样就不能从侦听器函数的来源位置对其进行编辑｡

09:44.210 --> 09:48.110
因为数组和对象在Javascript中是引用值,

09:48.110 --> 09:52.600
所以如果你传递原始数组, 我们可以从外部编辑它, 同样,

09:52.600 --> 09:59.830
如果我们从这个类内部向它推送一些东西, 它会在应用程序的其他地方发生变化, 但这些地方不会真正注意到它的变化,

09:59.830 --> 10:05.630
所以如果我们传递原始引用, 可能会引入奇怪的错误, 这就是为什么我传递了一个全新的副本,

10:05.630 --> 10:12.770
一个全新的数组

10:12.770 --> 10:15.390
现在, 每个监听器函数都被执行,

10:15.390 --> 10:19.400
并得到我们的副本, 我们全新的项目副本｡

10:19.400 --> 10:21.380
现在我们只需要转到我们希望得到更改通知的地方,

10:21.380 --> 10:29.030
在我们的例子中, 就是这里的项目列表类, 然后设置这样一个侦听器｡

10:29.030 --> 10:32.880
因此, 在这里, 在项目列表类的构造函数中, 在附加和呈现内容之前,

10:32.880 --> 10:43.720
我将访问projectState并在这里调用addListener, 以便在这里注册一个侦听器函数｡

10:43.720 --> 10:49.100
现在, 侦听器, 正如我所说的, 是一个函数, 所以我们必须传递一个函数给addListener｡

10:49.100 --> 10:51.210
因为我们在项目状态中管理的监听器,

10:51.210 --> 10:52.610
只是一个函数列表,

10:52.610 --> 10:57.773
当发生变化时, 我们最终会调用这些函数, 对吗？

10:58.840 --> 11:04.990
因此, 我需要在这里将一个函数传递给addListener函数｡

11:04.990 --> 11:07.520
这里我传递了一个匿名箭头函数｡ 

11:07.520 --> 11:10.770
当从projectState内部调用该函数时,

11:10.770 --> 11:14.400
它将获得一个项目列表｡

11:14.400 --> 11:17.430
我们得到了一个项目列表, 我们知道,

11:17.430 --> 11:21.560
在这个函数体中, 我们可以使用这个项目列表｡

11:21.560 --> 11:28.410
这里我将在项目列表中添加一个全新的字段, 可能是assignedProjects,

11:28.410 --> 11:30.310
它的类型是任意数组,

11:30.310 --> 11:37.630
数组中的任意内容, 以及任意值的数组, 当然我稍后还会详细说明｡

11:37.630 --> 11:41.780
那么在这里我们可以说这个分配的项目等于项目｡

11:41.780 --> 11:44.240
所以对我们的项目｡ 

11:44.240 --> 11:47.280
为了消除这个隐含的任意类型错误,

11:47.280 --> 11:51.563
我必须明确这实际上是一个任意类型的数组.

11:52.610 --> 11:55.020
所以现在我添加的项目, 我得到的,

11:55.020 --> 11:57.660
因为在我的状态发生了变化｡

11:57.660 --> 12:00.530
这里是指我未添加的已分配项目,

12:00.530 --> 12:04.170
我将使用新项目覆盖已分配项目｡

12:04.170 --> 12:08.223
然后我的想法是渲染所有这些项目｡ 

12:09.080 --> 12:15.080
为此, 我们可以添加一个新方法;例如renderPrjects｡

12:15.080 --> 12:16.920
我想在这里调用它, 这个renderProjects,

12:16.920 --> 12:20.063
就像这样｡

12:22.230 --> 12:24.120
它在renderProjects之外结束｡ 

12:24.120 --> 12:27.480
我将在这里找到这个列表, 对, 我们在呈现内容时分配ID,

12:27.480 --> 12:31.290
我们在这里就是这样做的｡

12:31.290 --> 12:34.440
看起来我们是在调用renderProjects之后执行此操作的,

12:34.440 --> 12:40.230
但请记住, 这是一个函数的结尾, 只有在添加新项目后才会最终调用该函数｡

12:40.230 --> 12:43.510
所以实际上renderContent将首先运行｡ 

12:43.510 --> 12:49.370
因此, 在renderProjects中, 我们可以依赖于将此ID分配给无序列表, 因此, 在这里,

12:49.370 --> 12:58.030
我们可以获取此ID, 并通过使用document获得我们的列表元素｡

12:58.030 --> 12:58.030
getElementbyId,

12:58.469 --> 13:03.690
然后我使用这个具体项目列表类的类型传递这个ID标识符｡

13:03.690 --> 13:08.563
然后使用我们生成的ID的其余部分｡ 

13:09.580 --> 13:14.170
我想把所有的项目都渲染到这个列表上｡

13:14.170 --> 13:21.060
因此, 我将在这里介绍此分配项目的所有项目项｡

13:21.060 --> 13:23.150
然后我想为每一个项目添加一些东西到列表中,

13:23.150 --> 13:25.380
我们将在稍后对其进行优化｡

13:25.380 --> 13:32.480
现在, 我将在list元素中调用appendChild｡

13:32.480 --> 13:34.490
顺便说一下, 这里我们应该添加一个感叹号,

13:34.490 --> 13:36.970
以明确这将不会是空的｡

13:36.970 --> 13:41.970
我们也可以将其转换为HTML UL列表元素, 因此转换为无序列表元素,

13:42.000 --> 13:45.420
因为它就是无序列表元素｡

13:45.420 --> 13:56.160
然后我们可以在这里添加子元素, 这应该是一个全新的列表项;因此我们可以在这里创建带有文档列表项｡

13:56.160 --> 13:56.160
创建LI元素

13:56.160 --> 13:58.350
在这里的列表项上, 我将把text content设置为等于project

13:58.350 --> 14:03.950
Item｡

14:03.950 --> 14:03.950
标题中的值｡ 

14:03.950 --> 14:06.240
当我们在项目状态中创建项目项时,

14:06.240 --> 14:09.940
每个项目项都将是一个项目, 因此它将是这样一个对象,

14:09.940 --> 14:13.100
因此它将有一个标题｡

14:14.210 --> 14:15.940
现在, 如果我们转到下面,

14:15.940 --> 14:18.880
我们将在此处添加列表项｡

14:18.880 --> 14:20.730
这样就差不多了, 剩下的问题还在这里,

14:20.730 --> 14:23.740
我设置了那个字段, 但是在构造函数中,

14:23.740 --> 14:27.080
我从来没有引用过它｡

14:27.080 --> 14:29.090
只在这里在我的侦听器函数中,

14:29.090 --> 14:32.640
但如前所述, 这不会立即在构造函数中运行｡

14:32.640 --> 14:37.640
我在这里要做的就是把这个赋值项目初始化为一个空数组,

14:38.970 --> 14:44.450
这样我们就可以很好的初始化了.

14:44.450 --> 14:45.510
现在如果我们保存它,

14:45.510 --> 14:47.780
编译时应该没有错误｡

14:47.780 --> 14:50.400
现在如果我们在这里加点东西,

14:50.400 --> 14:51.993
这能起作用吗？

14:53.480 --> 14:56.270
我们确实看到它出现在我们的列表中｡ 

14:56.270 --> 15:00.847
因为我们没有过滤逻辑等等｡

15:00.847 --> 15:03.210
这是我们以后可以解决的问题,

15:03.210 --> 15:04.710
但它确实起作用了,

15:04.710 --> 15:06.220
这才是重要的｡

15:06.220 --> 15:08.390
现在你看到我们这里也有一个错误｡ 

15:08.390 --> 15:12.370
如果我添加第二个元素, 我们将复制最后一个元素并添加新元素,

15:12.370 --> 15:15.490
因此这是我们必须解决的问题｡

15:15.490 --> 15:17.653
这些 都 是 我们 要 解决 的 问题

15:17.653 --> 15:21.270
, 但 现在 至少 我们 可以 用 它 输出 一些 东西 ,

15:21.270 --> 15:24.450
让 我们 深入 研究 所有 的 改进 , 比如 更 清楚

15:24.450 --> 15:27.160
地 了解 我们 正在 使用 的 类型 , 避免

15:27.160 --> 15:29.150
重复 输出 , 以及 许多 其他

15:29.150 --> 15:30.733
事情 ｡
