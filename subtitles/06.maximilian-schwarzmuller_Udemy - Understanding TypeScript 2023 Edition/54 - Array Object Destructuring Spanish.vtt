WEBVTT

00:02.100 --> 00:04.870
Instructor: Sigamos con las matrices y los objetos.

00:04.870 --> 00:06.750
Otra sintaxis importante, que verás

00:06.750 --> 00:09.160
mucho en los proyectos modernos de JavaScript

00:09.160 --> 00:10.440
y también de Typescript,

00:10.440 --> 00:13.133
es la desestructuración de arrays y objetos.

00:14.180 --> 00:15.013
¿Cómo funciona?

00:15.013 --> 00:17.220
Bien, empecemos con nuestro array que

00:17.220 --> 00:20.220
tenemos, el array hobbies que tiene dos hobbies.

00:20.220 --> 00:22.200
Digamos que quieres extraer estas

00:22.200 --> 00:26.340
dos aficiones y almacenarlas en variables o constantes.

00:26.340 --> 00:28.891
Por supuesto, podemos hacerlo con

00:28.891 --> 00:32.340
hobby uno igual a hobbies para el índice cero,

00:32.340 --> 00:33.470
que es el primer

00:33.470 --> 00:34.820
elemento.

00:34.820 --> 00:38.720
Y lo mismo quizás con el hobby dos para los hobbies en el índice uno.

00:38.720 --> 00:40.500
Esto sacará estos dos elementos

00:40.500 --> 00:43.330
y los almacenará en constantes.

00:43.330 --> 00:44.720
Nos llevó dos líneas de código,

00:44.720 --> 00:46.710
y cuantos más elementos quieras recuperar,

00:46.710 --> 00:48.493
más líneas de código nos llevará.

00:49.340 --> 00:51.690
La desestructuración de matrices nos permite acortarla.

00:51.690 --> 00:53.090
Con la desestructuración

00:53.090 --> 00:56.250
de arrays, que por cierto también funciona con let y no sólo

00:56.250 --> 00:59.760
con const, se añaden corchetes a la izquierda del signo igual, que

00:59.760 --> 01:01.400
es un lugar poco habitual.

01:01.400 --> 01:02.900
No había visto eso antes.

01:02.900 --> 01:04.780
Y en el lado derecho tienes el array,

01:04.780 --> 01:06.480
que quieres desestructurar.

01:06.480 --> 01:08.430
Ahora desestructurar significa realmente

01:08.430 --> 01:10.470
que se sacan elementos del array.

01:10.470 --> 01:13.570
Y aquí, en el lado izquierdo, entre estos corchetes,

01:13.570 --> 01:15.040
los almacenas en constantes,

01:15.040 --> 01:17.250
o si usas let, en variables.

01:17.250 --> 01:21.170
Así que aquí, podríamos tener entonces el hobby uno y el hobby dos.

01:21.170 --> 01:23.000
Y lo que hace esta sintaxis es que recorre

01:23.000 --> 01:25.640
el array de hobbies, toma el primer elemento y lo almacena

01:25.640 --> 01:26.920
en una constante con este

01:26.920 --> 01:30.290
nombre, toma el segundo elemento, lo almacena en una constante

01:30.290 --> 01:32.320
con este nombre.

01:32.320 --> 01:35.490
Incluso puede añadir parámetros de descanso aquí y

01:35.490 --> 01:38.720
tener aficiones restantes aquí en caso de que la matriz

01:38.720 --> 01:42.130
de aficiones tuviera más elementos que sólo dos.

01:42.130 --> 01:46.260
A continuación, todos los elementos restantes que no haya sacado en el hobby

01:46.260 --> 01:48.070
uno o en el hobby dos se almacenarán

01:48.070 --> 01:51.290
en un nuevo array llamado hobbies restantes.

01:51.290 --> 01:54.090
Así que se fusionarán en una nueva matriz.

01:54.090 --> 01:57.940
Por cierto, la desestructuración no cambia la matriz original.

01:57.940 --> 02:02.940
Así que si consolamos. Registra los hobbies, el hobby uno y el hobby dos aquí,

02:04.260 --> 02:06.840
verás que los hobbies siguen siendo la antigua matriz.

02:06.840 --> 02:08.840
No está vacío ni nada por el estilo.

02:08.840 --> 02:11.780
Así que los valores que sacamos entre comillas en

02:11.780 --> 02:14.870
realidad sólo se copian en nuevas constantes o variables,

02:14.870 --> 02:17.720
no se eliminan realmente de la matriz.

02:17.720 --> 02:18.980
Eso sí que es desestructuración de arrays.

02:18.980 --> 02:20.600
Tenemos lo mismo para los objetos.

02:20.600 --> 02:21.690
Tenemos a nuestra persona aquí.

02:21.690 --> 02:23.440
Ahora digamos que queremos almacenar

02:23.440 --> 02:26.630
el nombre y la edad en constantes independientes, o variables.

02:26.630 --> 02:28.480
Al igual que la desestructuración de arrays,

02:28.480 --> 02:31.840
la desestructuración de objetos funciona tanto con const como con let.

02:31.840 --> 02:33.010
Aquí voy a ir con const.

02:33.010 --> 02:34.930
Y ahora podemos usar llaves en el

02:34.930 --> 02:37.090
lado izquierdo del signo igual.

02:37.090 --> 02:38.883
Aunque una nueva sintaxis, supongo.

02:39.920 --> 02:43.750
Y tener nuestro objeto, o la variable apuntando al objeto del

02:43.750 --> 02:44.890
lado derecho.

02:44.890 --> 02:46.110
Ahora, por cierto, tenga en cuenta,

02:46.110 --> 02:48.770
esto no es un tipo de objeto que estoy asignando aquí.

02:48.770 --> 02:51.200
No tengo dos puntos aquí.

02:51.200 --> 02:54.080
En realidad se trata de llaves rizadas como esta en

02:54.080 --> 02:58.210
el lado izquierdo sin dos puntos después de algún nombre constante.

02:58.210 --> 03:01.000
Así que no estoy asignando el tipo del valor que podría

03:01.000 --> 03:02.720
ser almacenado una constante.

03:02.720 --> 03:05.470
En realidad sólo estoy usando una sintaxis especial.

03:05.470 --> 03:08.450
Porque aquí, ahora también podemos referirnos

03:08.450 --> 03:11.340
a nombres de propiedades que tenemos en un

03:11.340 --> 03:13.920
objeto, por ejemplo, nombre y edad, para

03:13.920 --> 03:18.030
sacar los valores de estas claves de persona y almacenarlos

03:18.030 --> 03:21.283
en constantes del mismo nombre.

03:23.290 --> 03:24.390
Ahora aquí me da error

03:24.390 --> 03:27.820
porque en la parte superior ya tengo una variable de edad.

03:27.820 --> 03:30.890
Y el nombre resulta ser una variable globalmente disponible que

03:30.890 --> 03:32.173
existe de todos modos.

03:33.240 --> 03:34.940
Por lo tanto, la solución

03:34.940 --> 03:38.313
sería utilizar un nombre de clave diferente, por

03:40.240 --> 03:41.920
ejemplo, firstName.

03:41.920 --> 03:45.020
Y ahora podemos sacar el valor por esa clave aquí.

03:45.020 --> 03:46.900
Así es como funciona la desestructuración de objetos.

03:46.900 --> 03:50.110
Lo importante aquí es que para la desestructuración

03:50.110 --> 03:52.260
de arrays, los elementos se sacan en

03:52.260 --> 03:55.110
orden porque un array es una lista ordenada.

03:55.110 --> 03:58.110
En los objetos, el orden no siempre está garantizado, y por

03:58.110 --> 04:00.720
lo tanto, no sacamos los elementos por posición, sino

04:00.720 --> 04:02.070
por nombre de clave.

04:02.070 --> 04:04.790
Así que los valores, o los nombres que se especifican

04:04.790 --> 04:05.930
aquí entre las llaves,

04:05.930 --> 04:07.630
no son arbitrarios.

04:07.630 --> 04:09.700
Aquí no se pueden inventar nombres.

04:09.700 --> 04:13.860
Tienen que ser nombres de propiedades que se encuentren en el objeto,

04:13.860 --> 04:16.010
para que los valores de estas claves

04:16.010 --> 04:18.160
puedan ser extraídos del objeto y luego

04:18.160 --> 04:20.600
se almacenen en constantes o variables del

04:20.600 --> 04:21.880
mismo nombre.

04:21.880 --> 04:24.120
Si quieres anular ese nombre, puedes

04:24.120 --> 04:25.970
hacerlo con dos puntos aquí.

04:25.970 --> 04:28.050
De nuevo, no es una asignación de tipo aquí.

04:28.050 --> 04:29.680
Sólo establece un nuevo nombre.

04:29.680 --> 04:31.970
Así que todo esto es sintaxis de JavaScript, no

04:31.970 --> 04:33.820
tiene nada que ver con Typescript.

04:33.820 --> 04:35.370
Así que aquí podríamos almacenar

04:35.370 --> 04:38.750
esto en una constante de userName por ejemplo.

04:38.750 --> 04:39.840
Y por lo tanto, a partir

04:39.840 --> 04:44.040
de entonces, podemos consolarnos. registra userName y age, pero no firstName,

04:44.040 --> 04:45.290
porque básicamente sobreescribió

04:45.290 --> 04:47.870
firstName para ser nombrado userName en la

04:47.870 --> 04:50.900
constante que creamos cuando sacamos los valores

04:50.900 --> 04:52.790
aquí.

04:52.790 --> 04:55.880
La edad no se sobrescribe, por lo que podemos usarla así.

04:55.880 --> 04:58.183
De nuevo, no se trata de una asignación de tipo aquí.

04:58.183 --> 05:00.210
Esta es la sintaxis de JavaScript,

05:00.210 --> 05:03.680
donde alias renombrar una propiedad que estamos sacando

05:03.680 --> 05:05.500
de persona.

05:05.500 --> 05:07.430
Además, al igual que antes con el array,

05:07.430 --> 05:09.840
el objeto persona en sí no ha cambiado.

05:09.840 --> 05:13.380
En realidad sólo copiamos estos valores del objeto.

05:13.380 --> 05:15.643
Y por lo tanto, obtenemos esta salida aquí.
