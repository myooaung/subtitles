WEBVTT

00:02.260 --> 00:03.920
教师：所以, 歧视性工会｡ 

00:03.920 --> 00:05.750
真的, 真的很有用｡ 

00:05.750 --> 00:09.060
另一个非常有用的特性是类型转换｡ 

00:09.060 --> 00:12.640
类型转换可以帮助您告诉TypeScript某个值属于特定类型,

00:12.640 --> 00:15.350
而TypeScript自己无法检测到它,

00:15.350 --> 00:22.660
但作为开发人员, 您知道这将是一种情况｡

00:22.660 --> 00:27.120
一个很好的例子是如果我们把X放到dom中的某个地方｡

00:27.120 --> 00:29.560
假设在dom中有一个段落, 只有一个段落,

00:29.560 --> 00:33.390
没有其他内容, 这是一个空的段落｡

00:33.390 --> 00:37.150
很明显, 如果我们保存它, 我们在屏幕上看不到任何东西｡

00:37.150 --> 00:40.543
现在, 我们可以从脚本中访问该段落｡

00:43.160 --> 00:48.160
例如, 使用文档查询选择器P构造段落｡ 

00:49.180 --> 00:51.890
现在, 当我们使用查询选择器并传入P作为选择器时,

00:51.890 --> 00:57.070
它将通过P标记进行选择, 然后TypeScript实际上能够发现（如果我将鼠标悬停在它上面,

00:57.070 --> 00:59.510
您可以看到）这将是paragraph

00:59.510 --> 01:07.050
element或null类型, 因为这样的元素可能在页面中不存在, 但这是另一回事｡

01:07.050 --> 01:09.920
让我们暂时忽略或null的情况｡ 

01:09.920 --> 01:14.600
重要的是TypeScript实际上发现这是一个段落元素｡

01:14.600 --> 01:16.800
现在, 如果我们按其他方式选择, 比如说ID,

01:16.800 --> 01:18.460
则情况会发生变化｡

01:18.460 --> 01:23.920
我们在这里将其命名为message-output, 因此此段落的ID为message-output｡

01:23.920 --> 01:25.890
现在, 作为开发人员, 我们当然知道我们将此ID分配给了此段落,

01:25.890 --> 01:29.780
但TypeScript并不知道这一点｡

01:29.780 --> 01:34.590
TypeScript不会深入到我们的HTML文件中并分析它们｡

01:34.590 --> 01:37.360
如果我们现在选择这个ID, 例如,

01:37.360 --> 01:45.130
使用getElementById, 那么我们会看到TypeScript推断这只是一个HTML元素或空值,

01:45.130 --> 01:49.830
它不知道具体是哪个HTML元素｡

01:49.830 --> 01:52.720
现在, 对于一个段落来说, 这可能不是很重要,

01:52.720 --> 01:57.290
也许我们只是想用它做一些我们可以用任何HTML元素做的事情,

01:57.290 --> 02:01.470
例如, 访问它的文本内容或类似的事情｡

02:01.470 --> 02:03.220
但是如果我们在这里有一个输入呢？

02:03.220 --> 02:07.750
如果我们实际上有一个输入类型文本, 并且我们希望获得用户输入的值,

02:07.750 --> 02:10.430
那么我将给它一个用户输入的ID,

02:10.430 --> 02:15.500
现在我在TypeScript代码中选择它｡

02:15.500 --> 02:17.730
所以这里我选择了by ID user-input,

02:17.730 --> 02:21.530
它不再是一个段落, 而是userInputElement｡

02:21.530 --> 02:24.023
现在, 作为开发人员, 我们知道, 在这里, 我们接触到这个输入元素,

02:24.909 --> 02:28.530
但正如我所说, TypeScript不知道这一点｡

02:28.530 --> 02:31.140
TypeScript不读取我们的HTML代码,

02:31.140 --> 02:34.435
因此TypeScript只知道它是某个HTML元素｡

02:34.435 --> 02:45.000
现在, 如果我想设置这个的value属性, 那么它会尝试执行userInputElement｡

02:45.000 --> 02:45.000
值等于hi,

02:45.000 --> 02:47.050
您可以看到我实际上得到了一个错误｡

02:47.050 --> 02:48.960
我得到一个错误, 因为对于一个,

02:48.960 --> 02:50.780
这个对象可能是空的｡

02:50.780 --> 02:54.220
我们可以通过在后面添加一个感叹号来解决这个问题,

02:54.220 --> 02:56.210
我稍后会回来讨论这个问题,

02:56.210 --> 02:58.390
但即使这样, 我仍然会收到一个错误,

02:58.390 --> 03:01.640
即value does not existing

03:01.640 --> 03:03.890
on type HTML Element,

03:03.890 --> 03:08.343
因为这个泛型类型, 基本上任何HTML元素都将其作为一个类型,

03:08.343 --> 03:14.510
不支持特定于特定HTML元素的属性｡

03:14.510 --> 03:17.540
因此, 我们需要告诉TypeScript,

03:17.540 --> 03:25.080
实际上我们在这里选择的不仅仅是null, 而且它也是HTMLInputElement类型｡

03:25.080 --> 03:28.240
这就是类型转换的作用｡ 

03:28.240 --> 03:31.153
现在, 有两种类型转换的方法, 我们可以使用两种语法,

03:31.153 --> 03:34.170
它们是等价的｡

03:34.170 --> 03:36.971
一种是在我们要转换的对象前面加一些东西,

03:36.971 --> 03:41.920
或者在我们要告诉TypeScript输入的地方加一些东西｡

03:41.920 --> 03:44.170
我们加上尖括号, 开始和结束,

03:44.170 --> 03:45.810
然后在这些括号之间,

03:45.810 --> 03:49.480
尖括号后面的东西的类型｡

03:49.480 --> 03:51.223
在本例中为HTMLInputElement｡ 

03:53.110 --> 03:54.970
这种类型是全局可用的, 因为在我的tsconfig文件中,

03:54.970 --> 03:57.963
我包含了dom lib｡

03:59.180 --> 04:06.530
这样一来, TypeScript就知道我们在尖括号后面选择的任何内容都将是HTMLInputElement类型,

04:06.530 --> 04:08.950
因此它不会再抱怨｡

04:08.950 --> 04:10.330
这是第一个版本｡ 

04:10.330 --> 04:14.750
让我复制一下, 注释掉它, 然后给你看另一种选择｡

04:14.750 --> 04:18.000
这个工作绝对好, 你可以使用这个｡ 

04:18.000 --> 04:21.210
但是, 如果您了解React, 那么您就会知道,

04:21.210 --> 04:26.970
如果您将其用于React文件（在React组件中编写JSX代码）,

04:26.970 --> 04:33.550
JavaScript或TypeScript中也会有这样的尖括号语法｡

04:33.550 --> 04:36.060
如果你不了解React, 那可能不会告诉你太多｡ 

04:36.060 --> 04:40.800
请注意, React项目中也存在类似的语法,

04:40.800 --> 04:43.320
尖括号不是用来传递有关您所使用的类型的任何信息,

04:43.320 --> 04:54.390
而是由一些构建工具和React解析, 最终了解您要在屏幕上呈现什么｡

04:54.390 --> 04:56.750
所以, 完全脱离了TypeScript｡ 

04:56.750 --> 05:04.350
为了不与JSX语法冲突, TypeScript团队提供了一种替代方括号类型转换的方法｡

05:04.350 --> 05:07.920
你也可以在你想输入的字符串后面加一些字符串,

05:07.920 --> 05:09.960
在这个例子中, 在这个选择之后,

05:09.960 --> 05:12.600
那个字符串就是as关键字.

05:12.600 --> 05:16.750
然后在这里再次添加要将其转换为的类型｡

05:16.750 --> 05:19.970
所以, 这现在告诉TypeScript它前面的表达式,

05:19.970 --> 05:27.405
在这个例子中, 这个表达式, 将产生HTMLInputElement类型的值｡

05:27.405 --> 05:30.067
因此, 同样, 我们没有得到错误｡ 

05:30.067 --> 05:31.650
这是一个替代方案,

05:31.650 --> 05:33.940
你可以使用这两种语法中的任何一种,

05:33.940 --> 05:36.350
无论你喜欢什么, 你只需要在整个项目中保持一致,

05:36.350 --> 05:42.377
这样你就不会在这两种语法之间交替使用｡

05:42.377 --> 05:47.480
这样, 您就可以将这些有价值的额外信息传递给TypeScript,

05:47.480 --> 05:56.000
并使这样的代码正常工作, 即使TypeScript自己无法发现这会生成一个HTMLInputElement｡

05:56.000 --> 05:57.940
当然, 由于您强制TypeScript使用此类型,

05:57.940 --> 06:05.620
因此作为开发人员, 您有责任确保此表达式生成的任何内容都是该类型｡

06:05.620 --> 06:09.920
否则, 如果您尝试以实际上不支援的方式与该项目互动,

06:09.920 --> 06:14.423
可能会在执行阶段发生执行阶段错误或未预期的行为｡

06:15.610 --> 06:18.060
因此, 类型转换是一个强大的功能｡ 

06:18.060 --> 06:20.490
这个感叹号也是｡ 

06:20.490 --> 06:24.820
其实我在前面的课程中已经探讨过了｡

06:24.820 --> 06:31.090
这个感叹号允许我们告诉TypeScript它前面的表达式永远不会产生null｡

06:31.090 --> 06:33.170
这对于某些表达式是必需的,

06:33.170 --> 06:38.010
就像这里, 当你从dom中选择一些可能返回null的东西时｡

06:38.010 --> 06:40.980
如果作为开发人员, 我们知道这永远不会返回null,

06:40.980 --> 06:43.690
那么我们可以使用这个感叹号｡

06:43.690 --> 06:45.470
否则, 你们已经学到了,

06:45.470 --> 06:48.248
我只想重申一下｡

06:48.248 --> 06:49.380
否则, 如果您不确定这是否会返回null,

06:49.380 --> 06:52.600
则可以使用if检查｡

06:52.600 --> 06:56.070
因此, 您可以检查userInputElement是否为true,

06:56.070 --> 06:59.440
因此它不为null, 然后在此处使用它｡

06:59.440 --> 07:02.720
现在, 我必须删除这个例子中的类型转换, 因为如果我们在这里进行类型转换,

07:02.720 --> 07:07.170
我们也会告诉TypeScript它不会是null, 因为我不确定这一点,

07:07.170 --> 07:10.470
所以我不能在这里进行类型转换｡

07:10.470 --> 07:13.120
相反, 当我使用值时, 我必须在这里这样做,

07:13.120 --> 07:14.290
因此我希望在访问value属性之前这样做,

07:14.290 --> 07:19.820
方法是像这样添加HTMLInputElement｡

07:19.820 --> 07:21.530
然而, 这当然会失败｡ 

07:21.530 --> 07:28.030
这是一个无效的语法, 您可能会尝试访问HTMLInputElement上的值属性,

07:28.030 --> 07:30.280
这甚至没有意义｡

07:30.280 --> 07:33.010
我们只需要把这个表达式用括号括起来,

07:33.010 --> 07:39.480
然后确保首先计算这个表达式, 然后我们尝试访问这个表达式结果的值｡

07:39.480 --> 07:42.893
现在我们有了一个替代感叹号的方法｡
