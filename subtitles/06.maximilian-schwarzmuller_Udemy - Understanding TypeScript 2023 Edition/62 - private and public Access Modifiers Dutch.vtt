WEBVTT

00:02.040 --> 00:04.180
Leraar: Dus dat was een heel eenvoudige les.

00:04.180 --> 00:05.930
Bij het bouwen van klassen

00:05.930 --> 00:08.400
worden ze vaak complexer dan dat.

00:08.400 --> 00:10.800
En misschien wil je er meer gegevens in opslaan.

00:10.800 --> 00:15.160
Laten we zeggen dat een afdeling allemaal werknemers moet hebben.

00:15.160 --> 00:18.160
Dat kan een array zijn, en aanvankelijk

00:18.160 --> 00:20.290
kan het een lege array zijn.

00:20.290 --> 00:23.520
En om ook wat preciezer te zijn over wat u daarin wilt

00:23.520 --> 00:24.980
opslaan, zou het een string

00:24.980 --> 00:28.800
array kunnen zijn om het relatief eenvoudig te houden.

00:28.800 --> 00:31.733
Nu zouden we hier een methode kunnen hebben addEmployee.

00:33.030 --> 00:36.880
Daar willen we een werknemer als argument, wat in ons voorbeeld

00:36.880 --> 00:39.430
gewoon een string zou moeten zijn.

00:39.430 --> 00:42.650
Dan kunnen we dit instellen. medewerkers. duw.

00:42.650 --> 00:47.320
Dus duw een nieuwe werknemer in onze werknemers array met

00:47.320 --> 00:48.373
deze code.

00:50.750 --> 00:52.683
Nu kunnen we nog een methode toevoegen,

00:53.666 --> 00:55.749
printEmployeeInformation.

01:00.508 --> 01:05.508
En daar wil ik troosten. log(this. medewerkers. lengte) en ik wil

01:07.766 --> 01:12.766
ook de console. log(this. werknemers) zelf.

01:15.510 --> 01:18.480
Als we nu naar beneden gaan, kunnen we deze code hier uitcommentariëren,

01:18.480 --> 01:20.560
wat weer zou breken omdat we weer niet

01:20.560 --> 01:25.870
passen in de beschrijving van de afdeling met ons object daar beneden.

01:25.870 --> 01:29.200
En in plaats daarvan kunnen we hier, op deze boekhoudafdeling,

01:29.200 --> 01:32.234
een werknemer toevoegen, laten we zeggen Max.

01:32.234 --> 01:35.400
En een andere werknemer, laten we zeggen Manu.

01:35.400 --> 01:37.690
En naast het beschrijven ervan, wil

01:37.690 --> 01:41.520
ik ook mijn werknemersinformatie daar neerzetten.

01:41.520 --> 01:44.600
Als we dit opslaan, krijgen we deze uitvoer,

01:44.600 --> 01:47.830
twee werknemers en hier is wat informatie.

01:47.830 --> 01:50.240
Dat is allemaal leuk en aardig.

01:50.240 --> 01:52.700
Een probleem dat we hebben met deze klasse is dat

01:52.700 --> 01:55.960
we werknemers van buitenaf zouden kunnen veranderen, niet

01:55.960 --> 01:58.160
alleen met add employee, maar door direct

01:58.160 --> 02:01.710
toegang te krijgen tot de eigenschap van de werknemer, net zoals we

02:01.710 --> 02:04.430
dat overigens ook voor de naam kunnen doen.

02:04.430 --> 02:07.630
Dus wat ik bedoel is dat we ook naar de boekhouding kunnen

02:07.630 --> 02:10.560
gaan, en dan de werknemers bereiken, en misschien

02:10.560 --> 02:13.870
nog een werknemer toevoegen bij index twee, en er een

02:13.870 --> 02:16.400
Anna doorgeven, zoals dat.

02:16.400 --> 02:18.210
Als we dat doen en we redden het, krijgen

02:18.210 --> 02:20.290
we drie werknemers en we krijgen Anna.

02:20.290 --> 02:22.710
Nu denk je misschien, geweldig, we hebben een andere manier.

02:22.710 --> 02:25.230
Als je complexere toepassingen bouwt,

02:25.230 --> 02:27.980
wil je zoiets meestal vermijden.

02:27.980 --> 02:30.930
Je wilt er zeker van zijn dat er één duidelijk pad is, één

02:30.930 --> 02:34.870
manier om je klasse te gebruiken, en dat dat soort dingen, alternatieve

02:34.870 --> 02:37.280
manieren om het te gebruiken, niet echt ondersteund

02:37.280 --> 02:38.530
worden.

02:38.530 --> 02:41.230
Want als je in een groter team werkt, dan zal de

02:41.230 --> 02:42.920
ene collega deze aanpak gebruiken

02:42.920 --> 02:45.700
om een werknemer toe te voegen en een andere collega

02:45.700 --> 02:48.050
misschien deze aanpak.

02:48.050 --> 02:49.280
En dit wil je niet.

02:49.280 --> 02:52.640
U wilt één uniforme manier om dit te doen.

02:52.640 --> 02:55.960
Ook omdat je misschien in de add employee methode meer

02:55.960 --> 02:58.420
doet dan alleen toevoegen aan de array.

02:58.420 --> 02:59.770
Misschien wil je eerst

02:59.770 --> 03:02.400
wat validatie en dergelijke hier.

03:02.400 --> 03:04.940
Er kan dus extra code in staan, die gewoon

03:04.940 --> 03:06.610
niet wordt uitgevoerd als

03:06.610 --> 03:09.470
je direct een nieuwe waarde toewijst of een nieuwe

03:09.470 --> 03:12.970
waarde toevoegt aan de array met deze regel hier.

03:12.970 --> 03:16.000
Je wilt dus niet toestaan dat medewerkers

03:16.000 --> 03:19.884
zo van buiten de klas toegankelijk zijn.

03:19.884 --> 03:22.340
En TypeScript dekt u.

03:22.340 --> 03:26.760
U kunt werknemers hier veranderen in een privé eigenschap,

03:26.760 --> 03:30.580
een privé veld door er een privé sleutelwoord voor

03:30.580 --> 03:32.220
te zetten.

03:32.220 --> 03:34.303
Wat privé betekent is dat medewerkers

03:34.303 --> 03:38.030
nu een eigenschap is, die alleen toegankelijk

03:38.030 --> 03:41.210
is vanuit de klasse, dus vanuit het creatieve

03:41.210 --> 03:43.480
object.

03:43.480 --> 03:46.700
Dus elke methode binnen de afdelingsklasse

03:46.700 --> 03:49.770
kan nog steeds werken met werknemers.

03:49.770 --> 03:52.570
Maar je kunt zo niet meer naar binnen.

03:52.570 --> 03:54.710
Hier zie je dat ik nu een foutmelding krijg.

03:54.710 --> 03:57.280
Als ik dit probeer op te slaan, krijg ik een compilatiefout

03:57.280 --> 03:59.870
dat de eigenschap 'medewerkers' privé is en alleen

03:59.870 --> 04:03.550
toegankelijk binnen de klasse 'afdeling'.

04:03.550 --> 04:07.100
Dus nu dwingen we af dat wanneer werknemers moeten worden

04:07.100 --> 04:09.370
toegevoegd aan deze afdeling, men

04:09.370 --> 04:12.690
de methode addEmployee moet gebruiken.

04:12.690 --> 04:16.760
Omdat ze een fout krijgen als ze zo'n code schrijven.

04:16.760 --> 04:20.460
Dit is een zogenaamde modifier hier, het private keyword.

04:20.460 --> 04:23.470
En naast privé hebben we ook publiek, wat

04:23.470 --> 04:25.000
de standaard is.

04:25.000 --> 04:26.590
Je hoeft geen publiek toe te voegen.

04:26.590 --> 04:29.590
Dus zo'n naam is precies hetzelfde als een

04:29.590 --> 04:31.650
naam met public ervoor.

04:31.650 --> 04:34.300
Het verschil is dat openbare eigendommen van

04:34.300 --> 04:36.350
buitenaf toegankelijk zijn.

04:36.350 --> 04:40.350
Dus bijvoorbeeld hier, zou ik ook de naam kunnen bereiken en hier een

04:40.350 --> 04:43.600
nieuwe naam kunnen toekennen als ik dat zou willen.

04:43.600 --> 04:45.260
Dat is mogelijk.

04:45.260 --> 04:49.270
Voor particuliere eigendommen is dit hier niet mogelijk.

04:49.270 --> 04:51.580
We kunnen ze alleen van binnenuit gebruiken.

04:51.580 --> 04:52.800
Technisch gezien kent

04:52.800 --> 04:55.700
JavaScript trouwens geen public en private.

04:55.700 --> 04:59.630
Alleen in zeer moderne versies die onlangs zijn toegevoegd

04:59.630 --> 05:01.320
bestaat zoiets.

05:01.320 --> 05:03.650
Vroeger kende JavaScript geen private

05:03.650 --> 05:05.690
of publieke eigenschappen.

05:05.690 --> 05:08.520
Alle eigendommen waren daar altijd openbaar.

05:08.520 --> 05:10.630
TypeScript introduceert deze functie,

05:10.630 --> 05:13.561
die natuurlijk niet werkt tijdens runtime, omdat

05:13.561 --> 05:16.620
JavaScript tot voor kort alleen publieke eigenschappen

05:16.620 --> 05:18.780
kende.

05:18.780 --> 05:21.290
Dus deze lijn hier, bevroren fout tijdens

05:21.290 --> 05:23.130
TypeScript compilatie.

05:23.130 --> 05:27.000
Als je het toch compileert naar JavaScript, zal deze code bij runtime

05:27.000 --> 05:30.140
nog steeds zonder fouten worden uitgevoerd, want

05:30.140 --> 05:32.800
nogmaals, JavaScript alleen kende dit concept

05:32.800 --> 05:34.900
tot voor kort niet.

05:34.900 --> 05:37.350
Dus afhankelijk van de versie waarvoor je compileert, zal

05:37.350 --> 05:38.720
hij het nog steeds niet weten.

05:38.720 --> 05:40.770
En daarom ondersteunt TypeScript dit alleen

05:40.770 --> 05:42.980
omdat het dit controleert tijdens het compileren,

05:42.980 --> 05:44.650
niet tijdens runtime.

05:44.650 --> 05:47.370
Daarmee kunnen we dit soort code echter vermijden en

05:47.370 --> 05:49.863
iedereen dwingen schonere code te schrijven.
