WEBVTT

00:01.850 --> 00:03.270
Instructor: Así que ahora

00:03.270 --> 00:06.760
que sabemos sobre los fundamentos de TypeScript y cómo se diferencia

00:06.760 --> 00:09.661
y todo esto relacionado con JavaScript, vamos a profundizar

00:09.661 --> 00:11.410
un poco más en los diferentes tipos

00:11.410 --> 00:14.148
de núcleo que TypeScript conoce.

00:14.148 --> 00:17.490
El número es el tipo que vemos aquí, y como expliqué, no hay diferencia

00:17.490 --> 00:18.500
entre los enteros como

00:18.500 --> 00:22.050
el cinco aquí y los flotantes o dobles, como se llamaría en otros lenguajes

00:22.050 --> 00:25.640
de programación, como el 2.

00:25.640 --> 00:25.640
8 aquí.

00:25.640 --> 00:28.440
De hecho, en JavaScript, y lo mismo ocurre en TypeScript,

00:28.440 --> 00:30.810
todos los números son flotantes por defecto.

00:30.810 --> 00:33.270
Así que, para JavaScript, y por lo tanto, también para

00:33.270 --> 00:35.171
TypeScript, no hay diferencia entre cinco

00:35.171 --> 00:36.770
como este y cinco como este.

00:36.770 --> 00:38.640
Es el mismo número, esencialmente.

00:38.640 --> 00:42.720
Ahora, además de los números, también tenemos otros tipos de núcleos.

00:42.720 --> 00:46.350
Y eso sería cadenas, así que texto, y booleanos.

00:46.350 --> 00:47.800
Echemos también un vistazo a estos.

00:47.800 --> 00:50.650
De hecho, ya hemos visto todo eso en acción en esta declaración

00:50.650 --> 00:53.291
if, que hemos aprendido que es un poco redundante.

00:53.291 --> 00:55.971
No obstante, esto sería una cadena.

00:55.971 --> 00:57.720
También, por supuesto, cinco con

00:57.720 --> 01:00.389
comillas sería una cadena porque es texto.

01:00.389 --> 01:03.851
Y el resultado, por ejemplo, de esta comparación aquí,

01:03.851 --> 01:05.170
sería un booleano.

01:05.170 --> 01:08.090
Este operador, el triple signo de igualdad

01:08.090 --> 01:10.950
o el operador de igualdad negada aquí,

01:10.950 --> 01:13.640
que produce verdadero o falso.

01:13.640 --> 01:14.720
Y, por supuesto, podemos

01:14.720 --> 01:17.340
producir una comprobación dinámica de innerRef,

01:17.340 --> 01:18.850
lo que haremos a menudo.

01:18.850 --> 01:22.340
O inicializamos una variable con un valor verdadero o falso, así que vamos a hacer

01:22.340 --> 01:23.379
ambas cosas aquí.

01:23.379 --> 01:27.509
Aquí podríamos añadir una nueva constante, "printResult".

01:27.509 --> 01:29.990
Y ponlo como verdadero, por ejemplo.

01:29.990 --> 01:31.320
Y para que quede bien claro, esto

01:31.320 --> 01:33.130
también podría ser una variable.

01:33.130 --> 01:34.460
No tiene que ser const.

01:34.460 --> 01:36.030
Puede ser una variable, que crearías

01:36.030 --> 01:37.730
con let en JavaScript.

01:37.730 --> 01:39.870
Pero como no pienso cambiarlo aquí, voy a ir con

01:39.870 --> 01:40.703
una constante.

01:40.703 --> 01:43.670
Y podríamos pasar esto como un tercer parámetro aquí.

01:43.670 --> 01:46.960
Digamos que pasamos en "printResult", que se mantiene aquí.

01:46.960 --> 01:49.720
Ahora obtenemos inmediatamente un error, por supuesto,

01:49.720 --> 01:53.160
porque nuestra función add no admite un tercer argumento.

01:53.160 --> 01:55.560
Vemos: "Esperaba dos argumentos pero obtuvo tres".

01:55.560 --> 01:57.260
Por lo tanto, tenemos que asegurarnos

01:57.260 --> 01:58.920
de apoyar un tercer argumento.

01:58.920 --> 02:03.920
Y ahí podríamos añadir un parámetro "showResult".

02:03.940 --> 02:05.920
Aquí también se podría nombrar "printResult".

02:05.920 --> 02:07.910
Voy a usar "showResult" para evitar la

02:07.910 --> 02:11.340
confusión en cuanto a la denominación, pero, técnicamente, estos

02:11.340 --> 02:12.930
dos nombres no chocan.

02:12.930 --> 02:14.320
Así que, aquí, lo llamaré "showResult".

02:14.320 --> 02:17.580
Y quiero asegurarme de que esto es de tipo booleano estableciendo

02:17.580 --> 02:19.500
esto como booleano.

02:19.500 --> 02:22.109
De nuevo, añadiendo dos puntos después del parámetro

02:22.109 --> 02:25.120
aquí y luego añadiendo el nombre del tipo.

02:25.120 --> 02:28.100
Ahora esta función acepta esto, y ahora lo que podemos

02:28.100 --> 02:31.787
hacer es añadir una comprobación if aquí y comprobar "si showResult",

02:31.787 --> 02:36.480
si esto es verdadero, podemos, por supuesto, compararlo con true.

02:36.480 --> 02:37.628
Pero como sabes en

02:37.628 --> 02:41.990
JavaScript, también puedes pasar el valor verdadero o falso aquí.

02:41.990 --> 02:43.970
Y JavaScript lo evaluará, y si esto arroja

02:43.970 --> 02:47.389
un valor verdadero de alguna manera o un valor verdadero en general, entonces

02:47.389 --> 02:48.989
lo haremos en el bloque if.

02:48.989 --> 02:50.011
Si no, no lo haremos.

02:50.011 --> 02:52.900
Y digamos que lo hacemos aquí, y luego quiero

02:52.900 --> 02:55.429
"consola". log n1 más n2".

02:55.429 --> 02:58.581
De lo contrario, en el otro caso, si no lo hacemos allí,

02:58.581 --> 03:00.549
entonces quiero devolver esto.

03:00.549 --> 03:02.300
Así que ahora se trata de una función

03:02.300 --> 03:04.760
que a veces devuelve un valor y a veces no devuelve

03:04.760 --> 03:08.309
un valor, sino que lo emite inmediatamente.

03:08.309 --> 03:11.550
Ahora se podría argumentar, si se quiere escribir una función

03:11.550 --> 03:14.310
de este tipo, que es un poco impredecible o que podría

03:14.310 --> 03:16.651
comportarse de forma inesperada si se pasa

03:16.651 --> 03:18.349
un verdadero aquí.

03:18.349 --> 03:19.990
Pero aquí, lo estamos haciendo.

03:19.990 --> 03:22.090
Por lo tanto, esta función sólo devuelve a veces.

03:22.090 --> 03:24.869
A veces tampoco regresa, sino que

03:24.869 --> 03:27.830
sólo registra algo en la consola.

03:27.830 --> 03:31.120
Ahora aquí, podemos llamar a la adición de esta manera y no

03:31.120 --> 03:33.640
es necesario para almacenar en el resultado

03:33.640 --> 03:37.570
y no es necesario a la consola. resultado del registro porque, con "printResult"

03:37.570 --> 03:39.550
establecido en true, se añade a sí mismo.

03:39.550 --> 03:41.869
Así que la propia función imprimirá el resultado.

03:41.869 --> 03:43.640
Por lo tanto, si ahora guardamos eso

03:43.640 --> 03:47.880
y recompilamos nuestra aplicación. ts con el comando tsc.

03:47.880 --> 03:50.830
Una vez hecho esto, la página se recargará, y seguiremos

03:50.830 --> 03:52.600
viendo nuestra salida aquí.

03:52.600 --> 03:54.677
Pero ahora viene de la línea seis.

03:54.677 --> 03:57.690
Y si echamos un vistazo, la línea 6 está, efectivamente,

03:57.690 --> 03:58.980
dentro de la función.

03:58.980 --> 03:59.891
Así que esto es un booleano.

03:59.891 --> 04:02.429
Ahora digamos que queremos personalizar la salida.

04:02.429 --> 04:06.190
En el if aquí, tenemos una constante "resultPhrase" aquí donde decimos,

04:06.190 --> 04:10.181
"Resultado es" dos puntos y luego algún espacio en blanco.

04:10.181 --> 04:14.205
Y lo pasamos también con "resultPhrase" aquí.

04:14.205 --> 04:17.410
Bueno, entonces podríamos esperar esto como un argumento aquí también.

04:17.410 --> 04:20.750
Frase, que daría lugar a la cadena de tuberías, añadiendo dos puntos.

04:20.750 --> 04:22.291
Y luego la cadena es el nombre

04:22.291 --> 04:26.469
del tipo, y ahora podríamos usar esa frase para imprimirla como parte de nuestra

04:26.469 --> 04:31.193
salida de resultados si estamos imprimiendo el resultado justo en la función.

04:31.193 --> 04:34.789
Entonces, aquí, podríamos tener "frase más n1 más n2".

04:34.789 --> 04:37.440
Y si hacemos eso y recompilamos repitiendo

04:37.440 --> 04:39.040
ese comando, veremos que

04:39.040 --> 04:41.720
esta frase es parte del resultado.

04:41.720 --> 04:44.861
Pero también, ahora, reintroducimos el antiguo error

04:44.861 --> 04:48.141
porque tengo una cadena, que combino con dos números.

04:48.141 --> 04:52.000
Aquí todo se convierte en una cadena, y eso no es

04:52.000 --> 04:53.240
lo que quiero.

04:53.240 --> 04:55.930
Para evitar esto, en esta función, podríamos añadir

04:55.930 --> 04:57.708
una variable de resultado aquí.

04:57.708 --> 05:02.027
O una constante de resultado y almacenar nuestro resultado aquí.

05:02.027 --> 05:04.530
Esto se tratará ahora de forma matemática

05:04.530 --> 05:07.990
porque sólo se trata de números, y entonces, aquí, podríamos

05:07.990 --> 05:11.430
combinarlo con la frase o simplemente devolverlo.

05:11.430 --> 05:15.160
Y ahora, como esto nunca se calcula directamente junto con una cadena,

05:15.160 --> 05:17.029
esto siempre será un número.

05:17.029 --> 05:19.350
Y, sí, entonces aquí, este número combinado con esta

05:19.350 --> 05:21.140
cadena se convertirá en una cadena.

05:21.140 --> 05:24.360
Pero como el cálculo matemático terminó antes, tendremos el

05:24.360 --> 05:25.548
resultado correcto.

05:25.548 --> 05:28.520
Así que ahora si repetimos eso y luego recompilamos, obtenemos

05:28.520 --> 05:30.181
la salida correcta.

05:30.181 --> 05:33.050
Así que estos son los tipos de datos básicos en acción.

05:33.050 --> 05:35.541
Ahora vamos a asegurarnos de que entendemos

05:35.541 --> 05:38.061
bien cómo se asignan los tipos y, también, por

05:38.061 --> 05:41.343
qué no asignamos explícitamente los tipos ahí abajo.
