WEBVTT

00:02.170 --> 00:05.630
講師：では､ ルートをいくつか登録したので､ そのルートに対してロジックを追加してみましょう｡

00:05.630 --> 00:07.730
そのために､ コントローラフォルダを追加しておきます｡ 

00:07.730 --> 00:08.750
これは必須ではありませんが､

00:08.750 --> 00:13.650
ここのロジックをcontrollersに､ ルートをroutesフォルダに分けたいのです｡

00:13.650 --> 00:16.740
そして､ コントローラーでは､ TODOも付けます｡  ts ファイルに､

00:16.740 --> 00:21.990
ルートから参照したいコントローラ関数が格納されます｡

00:21.990 --> 00:29.170
ここでは､ エクスポートする関数が必要です｡

00:29.170 --> 00:41.297
arrow関数として作成します（これは必須ではありませんが）｡

00:41.297 --> 00:44.550
そして､ どこから型が入手できるかを見たところです｡ 

00:44.550 --> 00:47.190
expressからrequest, response,

00:47.190 --> 00:50.460
next関数をインポートすることができる｡

00:50.460 --> 00:52.800
これは､ そういうタイプを輸入しているのです｡ 

00:52.800 --> 00:54.910
そうすれば､ ここに追加することができます｡ 

00:54.910 --> 00:57.230
さて､ エラー処理ミドルウェアで行ったように､

00:57.230 --> 01:01.300
常にこれらの型をすべてここに追加するのは面倒なことですが｡

01:01.300 --> 01:03.750
効果はありますが､ 迷惑をかけることもあります｡ 

01:03.750 --> 01:05.190
だから､ 近道があるんです｡ 

01:05.190 --> 01:11.160
これらのパラメータに型を設定する代わりに､ TypeScriptにどのような関数をこのcreateTodo定数に格納したいかを伝えれば､

01:11.160 --> 01:24.340
expressからRequestHandler型をインポートして､ このcreateTodoにRequestHandler型を設定するだけでいいのです｡

01:24.340 --> 01:30.560
そしてTypeScriptは､ リクエストとレスポンス､

01:30.560 --> 01:35.730
そして次の関数を知っていることがわかる｡

01:35.730 --> 01:38.080
これは3つのパラメータを持つ関数で､

01:38.080 --> 01:42.030
最初のパラメータはリクエスト､ 2番目のパラメータはレスポンス､

01:42.030 --> 01:44.810
3番目のパラメータは次の関数です｡

01:44.810 --> 01:47.313
そのため､ このセットアップを簡略化することができます｡ 

01:48.195 --> 01:49.380
RequestHandlerは､

01:49.380 --> 01:51.360
もちろん､ express用のタイプをインストールしたので､

01:51.360 --> 01:52.570
常に利用可能であり､ したがって､

01:52.570 --> 01:55.270
ここでこのインポートを追加することができます｡

01:55.270 --> 01:57.940
このインポートは､ JavaScriptにコンパイルされると必ず消えてしまうことに注意してください｡

01:57.940 --> 02:02.300
なぜなら､ ここでは型をインポートしているだけだからです｡

02:02.300 --> 02:05.030
これは､ 実行するようなコードをインポートしているわけではありません｡ 

02:05.030 --> 02:06.930
型を取り込むだけです｡ 

02:06.930 --> 02:08.650
したがって､ コンパイル時には､

02:08.650 --> 02:11.290
通常のJavaScriptで実行する際に必要なものは何も追加されないので､

02:11.290 --> 02:15.860
削除されます｡

02:15.860 --> 02:18.900
しかし､ これでcreateTodo関数ができたので､

02:18.900 --> 02:22.240
今度はここにTODOS配列を追加して､ いくつかのTODOSをメモリ上だけで管理してはどうでしょう､

02:22.240 --> 02:25.530
当然ですが｡

02:25.530 --> 02:28.310
これは､ JavaScriptの定数なので､

02:28.310 --> 02:31.460
サーバーが再起動するたびに消えていきます｡

02:31.460 --> 02:32.293
もちろん､ ここでデータベースと会話することも想像できますが､

02:32.293 --> 02:41.323
JavaScriptとTypeScriptの話であって､ データベース接続についてはあまり関係ないので､ シンプルにしておきたいと思います｡

02:42.390 --> 02:43.790
ここでdosを取得し､

02:43.790 --> 02:47.600
ここで新しいリクエストを受信したときに行うことを作成します｡

02:47.600 --> 02:55.420
これは新しいオブジェクトであるべきで､ このオブジェクトのブループリント､ モデルを作成しましょう｡

02:55.420 --> 02:57.640
そこで､ モデルフォルダを追加し､

02:57.640 --> 02:59.030
そのモデルフォルダの中に､

02:59.030 --> 03:08.210
Todoを追加します｡ tsファイルを作成し､ Todoと名付けたクラスをエクスポートします｡

03:08.210 --> 03:10.330
そこでコンストラクタを追加し､

03:10.330 --> 03:13.129
さらにTypeScriptのショートカットとして､

03:13.129 --> 03:24.050
publicのようなアクセス修飾子を追加し､ IDのような文字列型のプロパティ名とtextのような同じく文字列型のプロパティ名を追加すると､ TypeScriptはこのto

03:24.050 --> 03:30.130
doクラスのインスタンスを作成するたびに､ 自動的に同じ名前のフィールドやプロパティ､

03:30.130 --> 03:37.230
コンストラクタに渡した値をこれらのフィールドに追加してくれるのだ｡

03:37.230 --> 03:38.670
そこで､ ここではこの構文を使います｡

03:38.670 --> 03:41.810
この構文については､ コースの前半ですでに学びましたね｡

03:41.810 --> 03:44.660
そして今､ todosで｡  このコントローラでは､

03:44.660 --> 03:47.893
models/todoからTodoをインポートして､

03:49.020 --> 03:58.800
この型とクラスを使用することができます｡

03:58.800 --> 04:01.320
そして､ これは型であると同時にクラスでもあります｡

04:01.320 --> 04:02.800
なぜなら､ 明らかにクラスであり､

04:02.800 --> 04:05.750
すべてのクラスは自動的に型としても機能するからです｡

04:05.750 --> 04:08.550
それは､ このコースを通して見たものでもあります｡ 

04:08.550 --> 04:09.750
さて､ ここでまず言えることは､

04:09.750 --> 04:13.550
ここでのTODOSはto dosの配列になるということです｡

04:13.550 --> 04:15.480
このアノテーションを追加することで､

04:15.480 --> 04:18.590
この配列に ToDo を追加したり､ ToDo を操作したりする際に､

04:18.590 --> 04:21.410
適切なサポートが受けられるようになります｡

04:21.410 --> 04:23.610
そして､ ここでは新しいto doを作成するときに､

04:23.610 --> 04:26.220
このクラスをインスタンス化して作成します｡ そして､

04:26.220 --> 04:28.370
IDを渡さなければなりませんが､ ここではMath

04:28.370 --> 04:34.230
random toStringでランダムな疑似一意IDを作成します｡

04:34.230 --> 04:35.270
これはあまりユニークなことではありませんが､

04:35.270 --> 04:36.660
ここでは十分です｡

04:36.660 --> 04:39.170
そして､ ここでの値ですが､ もちろん､

04:39.170 --> 04:45.530
受信リクエスト・ボディで得られると思われるテキストを設定したいのです｡

04:45.530 --> 04:53.270
だから､ 基本的にはリクエストボディで､ ここにテキストが届くと予想しています｡

04:53.270 --> 04:53.270
のテキストを､

04:53.270 --> 04:56.280
ここに値として設定できるようにします｡

04:56.280 --> 04:57.113
さて､ これはうまくいったが､

04:57.113 --> 05:02.320
これはTypeScriptがany型であることを見抜いているからこそうまくいくのだということを理解しておいてほしい｡

05:02.320 --> 05:04.420
これは文字列であることを知らない｡ 

05:04.420 --> 05:11.140
なぜなら､ TypeScriptはどのデータがリクエストに含まれるかをどうやって知ることができるだろうか？

05:11.140 --> 05:12.430
それがはっきりしないのです｡ 

05:12.430 --> 05:14.260
いただいたリクエストの中身については､

05:14.260 --> 05:17.620
どこにも明記していないんです｡

05:17.620 --> 05:19.270
さて､ どうすればこれを改善できるでしょうか｡ 

05:19.270 --> 05:21.780
まあ､ 例えばタイプキャスティングを使えばいいんですけどね｡ 

05:21.780 --> 05:23.660
特定の型について知っていれば､ 型付けは常に素晴らしい解決策となるが､

05:23.660 --> 05:27.360
TypeScriptはそうではない｡

05:27.360 --> 05:30.440
そこで､ リクエストボディでテキストにアクセスする前に､ これをオブジェクトにタイプキャストして､

05:30.440 --> 05:34.900
文字列であるテキストプロパティを持たせることができる｡

05:34.900 --> 05:40.320
このアプリを作るからには､ 入ってくるリクエストに何を期待しているのかがわかるのです｡

05:40.320 --> 05:44.166
したがって､ 受信するリクエストボディにtextプロパティがあることがわかっているので､

05:44.166 --> 05:46.630
そのようなオブジェクトにキャストすることができます｡

05:46.630 --> 05:51.480
そして今､ 私たちはTypeScriptとIDEをサポートしています｡ 

05:51.480 --> 05:53.560
それで､ 新たにTo Doを追加します｡ 

05:53.560 --> 05:55.470
これで､ TODOSに手を伸ばして､ 新しいto

05:55.470 --> 05:58.280
doをこの配列にプッシュすることができます｡

05:58.280 --> 05:59.330
そしてまた､ これはもちろん､

05:59.330 --> 06:01.060
定数としてここに保存されるだけで､

06:01.060 --> 06:02.750
したがってメモリ内にのみ保存されます｡

06:02.750 --> 06:05.650
なぜなら､ データベースを扱うことは､ 実際にはnodeやTypeScriptとは直接関係なく､

06:05.650 --> 06:11.170
まあ､ データベースと関係しているからです｡

06:11.170 --> 06:14.140
これで､ Todoの作成機能を手に入れました｡ 

06:14.140 --> 06:19.070
では､ to doのルートに移動して､ このコントローラ関数をインポートしてみましょう｡

06:19.070 --> 06:22.030
そこで､ controllers フォルダにある

06:22.030 --> 06:24.000
todos ファイルから create

06:24.000 --> 06:26.660
Todo 関数をインポートし､ post ルートでこの関数を指定すると､

06:26.660 --> 06:30.100
slash todos slash nothing を対象とするリクエストが

06:30.100 --> 06:38.390
createTodo 関数に到達するようになります｡

06:38.390 --> 06:39.580
ここで実行しないでください｡ 

06:39.580 --> 06:40.650
指差すだけでいいんです｡ 

06:40.650 --> 06:45.883
後でnodeで実行され､ 実行中のWebサーバにexpressされます｡

06:46.880 --> 06:49.630
さて､ ここでこの関数を手に入れました｡ 

06:49.630 --> 06:50.900
しかし､ 私たちはまだ終わっていません｡ 

06:50.900 --> 06:54.360
コントローラでは､ 全員がレスポンスを返せばいいだけです｡

06:54.360 --> 06:56.720
例えば､ JSONメソッドでJSON形式のレスポンスを送信し､

06:56.720 --> 07:04.040
message created the todoなどのメッセージを送信します｡ また､ createdTodoキーには､

07:04.040 --> 07:14.490
サーバー側で追加された新しいto doを転送し､ クライアント側でもそれを使用できるようにすることができます｡

07:14.490 --> 07:17.750
また､ 成功し､ リソースが作成されたことを示すために､

07:17.750 --> 07:21.793
ここでステータスコード201を設定することもできます｡

07:22.680 --> 07:28.500
あとは､ ここで取り出そうとしているボディが実際に存在するかどうかを確認するだけです｡

07:28.500 --> 07:33.130
そして､ データ・アプリ用｡  tsでは､ 受信したリクエストのボディをパースする必要があります｡

07:33.130 --> 07:39.220
そのためには､ 同じくインストールしたbody-parserパッケージから､

07:39.220 --> 07:46.380
このようにJSONメソッドをインポートすればいいのです｡

07:46.410 --> 07:51.310
そして､ ここで実行したものをミドルウェアとして登録することができます｡

07:51.310 --> 07:54.480
これはサードパーティのパッケージが提供するミドルウェアで､

07:54.480 --> 08:07.970
受信するすべてのリクエストのボディを解析して､ そこで見つけたJSONデータを抽出し､ このリクエストオブジェクトのボディキーに解析されたJSONデータを入力するものです｡

08:07.970 --> 08:12.503
それが､ このbody-parserパッケージのJSONミドルウェアである｡

08:13.890 --> 08:18.230
そして､ それによって､ 新しいto dosを作ることができるサーバーができるはずです｡

08:18.230 --> 08:22.210
すべてのファイルを保存し､ エラーなしで再コンパイルされることを確認します｡ 

08:22.210 --> 08:26.150
nodemonがまだアプリを提供していることを確認します｡  jsファイルです｡ 

08:26.150 --> 08:28.560
そして､ 今度はポストリクエストを送信する必要があります｡ 

08:28.560 --> 08:34.260
そして､ ブラウザではそれができないのですが､ そのためのツールであるPostmanを使うことができるのです｡

08:34.260 --> 08:38.160
検索して､ Postmanアプリをシステムにインストールするだけでいいのです｡

08:38.160 --> 08:39.283
利用は無料です｡ 

08:40.440 --> 08:41.570
インストールが完了したら､

08:41.570 --> 08:44.440
起動するとこのような画面が表示されるはずです｡

08:44.440 --> 08:46.460
モーダルオーバーレイが表示された場合は､

08:46.460 --> 08:48.010
それを閉じるだけでよい｡

08:48.010 --> 08:51.740
そして､ ここでプラスをクリックし､ リクエストタイプ（この場合は投稿リクエスト）を選択し､

08:51.740 --> 08:53.040
URLを入力することで､

08:53.040 --> 08:56.450
新しいリクエストを作成することができます｡

08:56.450 --> 09:01.660
ここではlocalhost 3000､ 3000は私がここで選んだポートだからです｡

09:01.660 --> 09:03.100
そして､ slash todos

09:03.100 --> 09:06.320
slash nothingにリクエストを送る必要があります｡

09:06.320 --> 09:10.000
だから､ ここでトドメのスラッシュ・ナッシングに｡ 

09:10.000 --> 09:12.120
リクエストにボディを添付します｡

09:12.120 --> 09:17.010
これはJSONデータを送信するための生のボディJSONであるべきです｡

09:17.010 --> 09:19.480
さて､ ここで何を送ればいいのか？

09:19.480 --> 09:21.840
さて､ ミドルウェアの関数で抽出するものですが､

09:21.840 --> 09:27.410
この場合､ 送信するJSONデータの一部としてtextプロパティがあるはずです｡

09:27.410 --> 09:29.610
ではここで､ 名前としてテキストを追加し､

09:29.610 --> 09:33.230
さらにコースを終了するような好きなテキストを追加してみましょう｡

09:33.230 --> 09:36.960
そして､ 送信をクリックすると､ リクエストが送信され､ これが応答で､

09:36.960 --> 09:38.990
これは良い感じです｡

09:38.990 --> 09:40.670
クリエイト・ア・トゥ・ドゥを取り戻したのです｡ 

09:40.670 --> 09:43.600
生成されたIDとテキストが表示されます｡ 

09:43.600 --> 09:45.870
つまり､ 私たちのバックエンドは明らかにここで機能しているのです｡ 

09:45.870 --> 09:47.690
そして､ すべてTypeScriptで書いているのですが､

09:47.690 --> 09:49.880
普通のJavaScriptとして提供しています｡

09:49.880 --> 09:51.183
それが､ すべての仕掛けです｡ 
