WEBVTT

00:02.170 --> 00:03.860
教师：现在我们已注册了一些路由,

00:03.860 --> 00:05.630
让我们为这些路由添加一些逻辑｡

00:05.630 --> 00:07.730
为此, 我将添加一个controllers文件夹｡ 

00:07.730 --> 00:08.750
这不是必须做的,

00:08.750 --> 00:13.650
但我想在这里将逻辑拆分为控制器, 并将路由拆分为路由文件夹｡

00:13.650 --> 00:21.990
在控制器中, 我还将添加一个todos｡  ts文件, 现在它将保存我们要从路由内部指向的控制器函数｡

00:21.990 --> 00:25.120
在这里, 我需要一个函数, 我将导出它, 并将它创建为一个箭头函数,

00:25.120 --> 00:31.290
这不是必须的, 我将把它命名为createTodo, 它将接收这些典型的参数,

00:32.420 --> 00:41.297
这些参数是你在每个中间件函数中得到的, 例如, 一个请求, 一个响应, 以及下一个函数.

00:41.297 --> 00:44.550
我们刚刚看到了我们可以从哪里得到类型｡ 

00:44.550 --> 00:47.190
我们可以从express导入请求､

00:47.190 --> 00:50.460
响应和next函数｡

00:50.460 --> 00:52.800
这就为我们输入了这些类型｡ 

00:52.800 --> 00:54.910
然后, 我们可以在此处添加它们｡ 

00:54.910 --> 00:57.230
现在, 总是在这里添加所有这些类型,

00:57.230 --> 00:59.980
就像我们在错误处理中间件中所做的那样,

00:59.980 --> 01:01.300
可能会很麻烦｡

01:01.300 --> 01:03.750
它的工作, 但它可以是恼人的｡ 

01:03.750 --> 01:05.190
所以有捷径｡ 

01:05.190 --> 01:11.160
我们不需要设置所有这些参数的类型, 我们也可以告诉TypeScript我们想在createTodo常量中存储哪种类型的函数,

01:11.160 --> 01:24.340
然后我们可以简单地从express导入RequestHandler类型, 然后我们在这里设置createTodo, 将其设置为RequestHandler类型｡

01:24.340 --> 01:28.780
现在你可以看到, TypeScript知道这里有一个请求,

01:28.780 --> 01:30.560
这里有一个响应, 这里有下一个函数,

01:30.560 --> 01:35.730
因为我们的RequestHandler被定义为这样｡

01:35.730 --> 01:38.080
它是一个具有三个参数的函数,

01:38.080 --> 01:40.160
其中第一个参数是请求,

01:40.160 --> 01:44.810
第二个参数是响应, 第三个参数是下一个函数｡

01:44.810 --> 01:47.313
这样可以简化设置｡ 

01:48.195 --> 01:49.380
当然, RequestHandler始终可用,

01:49.380 --> 01:55.270
因为我们安装了express的类型, 因此可以在此处添加此导入｡

01:55.270 --> 01:57.940
请注意, 一旦编译为JavaScript,

01:57.940 --> 02:02.300
此导入将始终消失, 因为我们只是在此处导入一个类型｡

02:02.300 --> 02:05.030
这不是导入任何将执行的代码｡ 

02:05.030 --> 02:06.930
它只是导入一个类型｡ 

02:06.930 --> 02:08.650
因此, 在编译过程中,

02:08.650 --> 02:15.860
它将被删除, 因为它不会添加在常规JavaScript中运行时所需的任何内容｡

02:15.860 --> 02:16.693
然而, 这样,

02:16.693 --> 02:18.900
我得到了createTodo函数,

02:18.900 --> 02:22.240
现在我们为什么不在这里添加一个TODOS数组,

02:22.240 --> 02:25.530
当然, 只在内存中管理一些待办事项｡

02:25.530 --> 02:31.460
当我们的服务器重新启动时, 它将消失, 因为它最终只是JavaScript中的一个常量｡

02:31.460 --> 02:32.293
当然, 您也可以想象在这里与数据库对话,

02:32.293 --> 02:41.323
但我希望保持简单, 因为这是关于JavaScript和TypeScript的, 而不是关于数据库连接的｡

02:42.390 --> 02:43.790
现在我来做一个dos,

02:43.790 --> 02:47.600
当我们收到一个传入请求时, 我想在这里创建一个新的dos,

02:47.600 --> 02:55.420
这应该是一个新的对象, 为什么我们不为这个对象创建一个蓝图, 一个模型呢？

02:55.420 --> 02:57.640
因此, 我将添加一个models文件夹,

02:57.640 --> 03:04.030
并在该models文件夹中添加一个todo｡

03:04.030 --> 03:04.030
ts文件,

03:04.760 --> 03:06.250
并在这里导出一个类, 我将其命名为Todo,

03:06.250 --> 03:08.210
在其中我定义了如何做应该是什么样子｡

03:08.210 --> 03:10.330
在这里我们可以添加一个构造函数,

03:10.330 --> 03:13.129
也可以使用这个TypeScript快捷方式,

03:13.129 --> 03:16.440
我们可以添加一个访问修饰符, 比如public,

03:16.440 --> 03:27.470
然后添加一个属性名, 比如ID, 它是字符串类型, 比如text, 它也是字符串类型, 然后TypeScript会自动添加字段, 具有相同名称的属性,

03:27.470 --> 03:37.230
以及我们传递给构造函数的赋值给那些字段, 每当我们实例化它来做类的时候｡

03:37.230 --> 03:38.670
我将在这里使用这种语法,

03:38.670 --> 03:41.810
你们在前面的课程中已经学习过这种语法｡

03:41.810 --> 03:44.660
现在进入待办事项｡  在控制器中,

03:44.660 --> 03:58.800
我们当然可以从上一级的models/todo导入Todo, 并在文件中使用这个类型和类｡

03:58.800 --> 04:01.320
它既是一个类型也是一个类, 因为很明显,

04:01.320 --> 04:05.750
它是一个类, 每个类都自动地充当一个类型.

04:05.750 --> 04:08.550
这也是您在本课程中看到的内容｡ 

04:08.550 --> 04:11.910
所以在这里, 我们首先可以说TODOS是一个to

04:11.910 --> 04:13.550
dos数组｡

04:13.550 --> 04:15.480
这个额外的注释并没有什么坏处,

04:15.480 --> 04:18.590
所以一旦我们开始添加to dos或者开始使用这个数组中的to

04:18.590 --> 04:21.410
dos, 我们就可以得到适当的支持｡

04:21.410 --> 04:23.610
当我在这里创建一个新的to do时,

04:23.610 --> 04:28.370
我现在通过实例化这个类来创建它, 我们必须传入一个ID, 在这里我将用Math

04:28.370 --> 04:34.230
random toString创建一个随机的伪唯一ID｡

04:34.230 --> 04:35.270
这并不是真正独特的,

04:35.270 --> 04:36.660
但在这里已经足够好了｡

04:36.660 --> 04:39.170
现在对于这里的值, 我当然要设置一些文本,

04:39.170 --> 04:45.530
我希望在传入的请求主体中获得这些文本｡

04:45.530 --> 04:53.270
所以我希望在这里得到我的文本, 基本上是在请求正文上｡

04:53.270 --> 04:53.270
text,

04:53.270 --> 04:56.280
这样我就可以在这里将text设置为值｡

04:56.280 --> 04:57.113
现在, 这是可行的,

04:57.113 --> 05:02.320
但请注意, 这只是因为TypeScript认为这是any类型｡

05:02.320 --> 05:04.420
它不知道这是一个字符串｡ 

05:04.420 --> 05:05.510
而且它无法知道,

05:05.510 --> 05:11.140
因为TypeScript如何知道哪些数据将是传入请求的一部分？

05:11.140 --> 05:12.430
这还不清楚｡ 

05:12.430 --> 05:17.620
我们从来没有在任何地方说明我们收到的请求中会有什么内容｡

05:17.620 --> 05:19.270
现在, 我们该如何改进这一点？

05:19.270 --> 05:21.780
例如, 我们可以使用类型转换｡ 

05:21.780 --> 05:23.660
如果您知道特定类型, 类型转换总是一个很好的解决方案,

05:23.660 --> 05:27.360
但TypeScript不知道｡

05:27.360 --> 05:30.440
所以在这里, 在访问文本之前, 我们可以将其类型转换为一个对象,

05:30.440 --> 05:34.900
其中我们有一个文本属性, 即字符串｡

05:34.900 --> 05:36.920
因为我们正在构建这个应用程序,

05:36.920 --> 05:40.320
所以我们知道传入请求的预期内容｡

05:40.320 --> 05:42.750
因此, 由于我们知道传入的请求主体上会有一个text属性,

05:42.750 --> 05:46.630
所以我们可以将它转换为这样一个对象｡

05:46.630 --> 05:51.480
现在, 我们获得了正确的TypeScript和IDE支持｡ 

05:51.480 --> 05:53.560
所以有了那个, 我们就再加一个新的做｡ 

05:53.560 --> 05:58.280
现在, 我们可以访问TODOS并将新的待办事项推送到该阵列上｡

05:58.280 --> 06:01.060
同样, 这当然只会将它作为常量存储在这里,

06:01.060 --> 06:02.750
因此只存储在内存中,

06:02.750 --> 06:11.170
因为使用数据库实际上并不直接与节点或TypeScript相关, 而是与数据库相关｡

06:11.170 --> 06:14.140
这样, 我们就得到了create Todo函数｡ 

06:14.140 --> 06:19.070
现在, 让我们转到待办事项的路径并导入此控制器函数｡

06:19.070 --> 06:22.030
所以从控制器文件夹导入, 从todos文件导入,

06:22.030 --> 06:24.000
导入createTodo函数,

06:24.000 --> 06:26.660
并在post路径上指向这个函数,

06:26.660 --> 06:30.100
这样任何指向slash todos, slash

06:30.100 --> 06:38.390
nothing的请求都会到达createTodo函数.

06:38.390 --> 06:39.580
不要在这里执行｡ 

06:39.580 --> 06:40.650
只要指着它｡ 

06:40.650 --> 06:45.883
稍后将在您运行的Web服务器中按节点和表达式为您执行｡

06:46.880 --> 06:49.630
现在我们有了这个函数｡ 

06:49.630 --> 06:50.900
但我们还没说完｡ 

06:50.900 --> 06:54.360
在控制器中, 我们都只是应该返回一个响应｡

06:54.360 --> 06:56.720
这里我们可以发送一个响应,

06:56.720 --> 06:59.420
例如, 使用JSON方法的JSON格式,

06:59.420 --> 07:04.040
我们说message创建了todo或任何你想要的东西,

07:04.040 --> 07:10.520
我们可能创建了Todo键, 我们转发了服务器端添加的新的todo, 这样在客户端,

07:10.520 --> 07:14.490
我们也可以使用它｡

07:14.490 --> 07:17.750
还可以在此处设置状态代码201,

07:17.750 --> 07:21.793
以指示我们已成功创建资源｡

07:22.680 --> 07:28.500
现在我们只需要确保我们要提取的尸体确实存在｡

07:28.500 --> 07:33.130
对于数据和应用程序｡  我们需要解析传入请求的主体｡

07:33.130 --> 07:39.220
为此, 我们可以从我们安装的body-parser包中导入,

07:39.220 --> 07:41.380
然后从该包中导入JSON方法,

07:41.380 --> 07:46.380
如下所示｡

07:46.410 --> 07:51.310
在这里, 您可以将其注册为中间件｡

07:51.310 --> 07:54.480
这是一个由第三方包提供的中间件,

07:54.480 --> 08:07.970
它将解析所有传入请求的主体, 并提取其中找到的任何JSON数据, 然后用解析后的JSON数据填充此请求对象上的主体键｡

08:07.970 --> 08:12.503
这就是body解析器包中的JSON中间件的作用｡

08:13.890 --> 08:18.230
有了这些, 我们应该有一个服务器, 能够创建新的待办事项｡

08:18.230 --> 08:22.210
保存所有文件并确保重新编译时没有错误｡ 

08:22.210 --> 08:26.150
确保nodemon仍在为应用程序提供服务｡  js文件中｡ 

08:26.150 --> 08:28.560
现在我们需要发送一个发布请求｡ 

08:28.560 --> 08:31.150
而用浏览器, 我们不能做到这一点,

08:31.150 --> 08:34.260
但我们可以使用一个工具, 邮差｡

08:34.260 --> 08:35.600
您可以简单地搜索它,

08:35.600 --> 08:38.160
然后在您的系统上安装邮差应用程序｡

08:38.160 --> 08:39.283
免费使用｡ 

08:40.440 --> 08:41.570
一旦你安装了它, 你就可以启动它了,

08:41.570 --> 08:44.440
你应该会看到一个类似这样的屏幕｡

08:44.440 --> 08:46.460
如果您看到一个模式覆盖,

08:46.460 --> 08:48.010
只需关闭即可｡

08:48.010 --> 08:50.240
现在, 您可以在这里创建一个新请求,

08:50.240 --> 08:56.450
方法是单击加号, 选择请求类型（在本例中为发布请求）, 然后输入URL｡

08:56.450 --> 08:58.820
这里是localhost 3000,

08:58.820 --> 09:01.660
3000是因为我在这里选择了该端口｡

09:01.660 --> 09:03.100
然后我们需要发送一个请求,

09:03.100 --> 09:06.320
以slash todos, slash nothing.

09:06.320 --> 09:10.000
所以在这里削减所有削减什么都没有｡ 

09:10.000 --> 09:12.120
我们希望在请求中附加一个主体,

09:12.120 --> 09:17.010
这里应该是一个原始的JSON主体, 用于发送一些JSON数据｡

09:17.010 --> 09:19.480
现在我们需要把什么送到这里？

09:19.480 --> 09:21.840
我们在中间件函数中提取的内容,

09:21.840 --> 09:27.410
在本例中, 我们应该将文本属性作为发送的JSON数据的一部分｡

09:27.410 --> 09:29.610
在这里, 我们先添加文本作为名称, 然后添加您选择的任何文本,

09:29.610 --> 09:33.230
例如finish the course｡

09:33.230 --> 09:36.960
如果您现在单击“发送”, 它会发送请求, 这是响应,

09:36.960 --> 09:38.990
看起来不错｡

09:38.990 --> 09:40.670
我们得把创建一个做回来｡ 

09:40.670 --> 09:43.600
我们可以看到生成的ID和文本｡ 

09:43.600 --> 09:45.870
因此, 我们的后端显然在这里工作｡ 

09:45.870 --> 09:47.690
我们用TypeScript编写了这些代码,

09:47.690 --> 09:49.880
但我们将其作为常规JavaScript提供服务｡

09:49.880 --> 09:51.183
这就是整个把戏｡ 
