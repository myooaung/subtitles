WEBVTT

00:01.850 --> 00:03.270
講師：では､ TypeScriptの基礎とJavaScriptとの違い､

00:03.270 --> 00:14.148
そしてこれらに関することがわかったところで､ TypeScriptが知っているさまざまなコアタイプについて､ もう少し掘り下げてみましょう｡

00:14.148 --> 00:17.490
ここで見る数値は型ですが､ 説明したように､ ここにある5つのような整数と､

00:17.490 --> 00:18.500
他のプログラミング言語でいうところのフロート､

00:18.500 --> 00:25.640
あるいは2のような倍数には違いがないのです｡

00:25.640 --> 00:25.640
8はこちら

00:25.640 --> 00:28.440
実際､ JavaScriptでは､ そしてTypeScriptでも同じように､

00:28.440 --> 00:30.810
すべての数値はデフォルトでfloatである｡

00:30.810 --> 00:33.270
つまり､ JavaScriptの場合､ つまりTypeScriptの場合も､

00:33.270 --> 00:36.770
このような5つと､ このような5つの違いはないのです｡

00:36.770 --> 00:38.640
本来は同じ数字なんですけどね｡ 

00:38.640 --> 00:42.720
さて､ 数字以外にも､ コアの種類はあります｡ 

00:42.720 --> 00:46.350
そして､ それは文字列､ つまりテキストとブーリアンということになる｡ 

00:46.350 --> 00:47.800
それらも見てみましょう｡ 

00:47.800 --> 00:50.650
実は､ このif文の中で､ すでにそれらのすべてを実際に見ており､

00:50.650 --> 00:53.291
少し冗長であることを学びました｡

00:53.291 --> 00:55.971
それにもかかわらず､ ここが文字列になってしまう｡ 

00:55.971 --> 01:00.389
また､ 当然ですが､ 引用符で囲んだ5つはテキストなので文字列になります｡

01:00.389 --> 01:05.170
そして､ 例えば､ この比較の結果は､ ブール値になります｡

01:05.170 --> 01:10.950
この演算子､ 三重の等号､ あるいはここでは否定された等号演算子で､

01:10.950 --> 01:13.640
真か偽を生成するものです｡

01:13.640 --> 01:14.720
そして､ もちろん､

01:14.720 --> 01:18.850
動的にinnerRefチェックを生成することもできます｡

01:18.850 --> 01:23.379
あるいは､ 真か偽の値で変数を初期化するのですが､ ここではその両方をやってみましょう｡

01:23.379 --> 01:27.509
ここでは､ 新しい定数「printResult」を追加することができます｡ 

01:27.509 --> 01:29.990
そして､ これを例えばtrueに設定します｡ 

01:29.990 --> 01:31.320
そして､ 本当にはっきりさせておきたいのは､

01:31.320 --> 01:33.130
これも変数になり得るということです｡

01:33.130 --> 01:34.460
コンストである必要はない｡ 

01:34.460 --> 01:37.730
JavaScriptでletで作成するような変数にすることができます｡

01:37.730 --> 01:40.703
でも､ ここで変えるつもりはないので､ 定数で行くことにします｡

01:40.703 --> 01:43.670
そして､ これを第3のパラメータとしてここに渡すことができる｡ 

01:43.670 --> 01:46.960
ここでは､ "printResult "を渡すとすると､ これが真となる｡ 

01:46.960 --> 01:49.720
もちろん､ add関数が第3引数をサポートしていないため､

01:49.720 --> 01:53.160
すぐにエラーが発生します｡

01:53.160 --> 01:55.560
期待したのは2つの議論だったが､ 3つの議論になった」と見ている｡ 

01:55.560 --> 01:58.920
それゆえ､ 第三の論点をしっかりサポートしなければならないわけです｡

01:58.920 --> 02:03.920
そして､ そこに「showResult」パラメータを追加すればいいのです｡ 

02:03.940 --> 02:05.920
ここでも "printResult "と名付けることができます｡ 

02:05.920 --> 02:07.910
ネーミングの混乱を避けるために "showResult

02:07.910 --> 02:12.930
"としていますが､ 技術的にはこの2つの名前はぶつかることはありません｡

02:12.930 --> 02:14.320
そこで､ ここでは「showResult」と名付けることにします｡ 

02:14.320 --> 02:19.500
そして､ これをbooleanに設定することで､ boolean型であることを確認したい｡

02:19.500 --> 02:22.109
ここでもパラメータの後にコロンを付け､

02:22.109 --> 02:25.120
さらに型名も付けます｡

02:25.120 --> 02:28.100
この関数はこれを受け取ります｡ ここでできることは､ ここにifチェックを追加して､

02:28.100 --> 02:36.480
「if showResult」をチェックし､ これがtrueなら､ もちろんtrueと比較することができるようにします｡

02:36.480 --> 02:37.628
しかし､ JavaScriptではご存知のように､

02:37.628 --> 02:41.990
ここにtruxyまたはfalsyの値を渡すこともできます｡

02:41.990 --> 02:43.970
JavaScriptはこれを評価し､ もしこれが何らかの形でtrueを返すか､

02:43.970 --> 02:48.989
一般的にtrueの値を返すなら､ それをifブロックにするのです｡

02:48.989 --> 02:50.011
そうでなければ､ やらない｡ 

02:50.011 --> 02:55.429
そして､ 仮にここで成功したとして､ 「コンソール」をしたいと思います｡

02:55.429 --> 02:55.429
log n1 plus n2」です｡ 

02:55.429 --> 02:58.581
そうでない場合､ もしそこに入れなかった場合は､

02:58.581 --> 03:00.549
これを返したいんです｡

03:00.549 --> 03:02.300
これで､ あるときは値を返し､

03:02.300 --> 03:08.309
あるときは値を返さず､ すぐに出力する関数になったわけです｡

03:08.309 --> 03:11.550
さて､ もしあなたがそのような関数を書きたいのなら､ ある種予測不可能な､

03:11.550 --> 03:18.349
あるいはここでtrueを渡すと予期せぬ振る舞いをする可能性があると主張することができます｡

03:18.349 --> 03:19.990
でも､ ここでは､ それをやっているんです｡ 

03:19.990 --> 03:22.090
そのため､ この関数は時々しか返さない｡ 

03:22.090 --> 03:27.830
また､ 返送されず､ コンソールに何かログが残るだけの場合もあります｡

03:27.830 --> 03:31.120
ここで､ 実際にこのようにaddを呼び出すと､ resultに格納する必要がなく､

03:31.120 --> 03:37.570
コンソールに格納する必要もありません｡

03:37.570 --> 03:37.570
printResult

03:37.570 --> 03:39.550
"がtrueに設定され､ 自分自身を追加するため､ 結果をログに記録します｡

03:39.550 --> 03:41.869
ですから､ この関数自体が結果を表示することになります｡ 

03:41.869 --> 03:47.880
そこで､ これを保存して､ アプリを再コンパイルしてみます｡

03:47.880 --> 03:47.880
tscコマンドを使用して､ ここでtsファイルを作成します｡ 

03:47.880 --> 03:52.600
これが完了すると､ ページが再読み込みされ､ まだここに出力が表示されます｡

03:52.600 --> 03:54.677
しかし､ 今は6行目からです｡ 

03:54.677 --> 03:58.980
そして､ 見てみると､ 6行目は､ 確かに､ 関数の中に入っています｡

03:58.980 --> 03:59.891
つまり､ これはブール値です｡ 

03:59.891 --> 04:02.429
では､ 出力をカスタマイズすることにしましょう｡ 

04:02.429 --> 04:06.190
ここでは､ "resultPhrase "という定数で､ "Result

04:06.190 --> 04:10.181
is "というコロンと空白の部分を指定しています｡

04:10.181 --> 04:14.205
そして､ これも "resultPhrase "で渡します｡ 

04:14.205 --> 04:17.410
なるほど､ それならこちらの言い分としても期待できる｡ 

04:17.410 --> 04:20.750
フレーズ､ コロンを追加することにより､ パイプ文字列を得ることができます｡ 

04:20.750 --> 04:22.291
そして､ stringは型の名前です｡

04:22.291 --> 04:26.469
そして､ このフレーズを使って､ 関数の中で結果を正しく出力している場合､

04:26.469 --> 04:31.193
結果出力の一部としてそれを出力することができます｡

04:31.193 --> 04:34.789
そうすると､ ここでは､ 「フレーズ＋n1＋n2」とすることができますね｡ 

04:34.789 --> 04:37.440
そして､ そのコマンドを繰り返して再コンパイルすると､

04:37.440 --> 04:41.720
このフレーズが結果の一部になっていることがわかります｡

04:41.720 --> 04:44.861
しかし､ 今､ 私たちは､ 文字列を持っていて､ それを2つの数字と組み合わせるので､

04:44.861 --> 04:48.141
昔のバグを再導入してしまいました｡

04:48.141 --> 04:53.240
ここではすべてが文字列に変換され､ それは私が望むものではありません｡

04:53.240 --> 04:57.708
これを避けるために､ この関数では､ ここに結果変数を追加することができます｡

04:57.708 --> 05:02.027
または結果定数で､ ここに結果を保存します｡ 

05:02.027 --> 05:04.530
これはもう､ 数字だけが絡んでくるので､ 数学的に処理されます｡

05:04.530 --> 05:11.430
そして､ ここで､ フレーズと組み合わせたり､ そのまま返したりすることができるようになります｡

05:11.430 --> 05:15.160
そして今､ これは文字列と一緒に直接計算されることはないので､

05:15.160 --> 05:17.029
これは常に数字になります｡

05:17.029 --> 05:21.140
そして､ そうすると､ ここで､ この数字とこの文字列を組み合わせたものが文字列に変換されます｡

05:21.140 --> 05:25.548
でも､ その前に数学的な計算が終わっているから､ 正しい結果が出るんです｡

05:25.548 --> 05:28.520
そこで､ 今度はこれを繰り返して再コンパイルすると､

05:28.520 --> 05:30.181
正しい出力が得られます｡

05:30.181 --> 05:33.050
さて､ 以上がコアとなるデータ型の動作です｡ 

05:33.050 --> 05:35.541
ここで､ 型がどのように割り当てられるのか､

05:35.541 --> 05:41.343
また､ なぜ下の方で明示的に型を割り当てないのかを十分に理解しておきましょう｡
