WEBVTT

00:01.850 --> 00:03.270
Instructeur : Maintenant que

00:03.270 --> 00:06.760
nous connaissons les fondamentaux de TypeScript et comment il diffère

00:06.760 --> 00:09.661
et tout cela lié à JavaScript, nous allons creuser un peu

00:09.661 --> 00:11.410
plus profondément dans les différents

00:11.410 --> 00:14.148
types de base que TypeScript connaît.

00:14.148 --> 00:17.490
Le nombre est le type que nous voyons ici, et comme je l'ai expliqué, il n'y a

00:17.490 --> 00:18.500
pas de différence entre

00:18.500 --> 00:22.050
les entiers comme le cinq ici et les flottants ou les doubles, comme on les appellerait

00:22.050 --> 00:24.330
dans d'autres langages de programmation, comme le

00:24.330 --> 00:25.640
2. 8 ici.

00:25.640 --> 00:28.440
En effet, en JavaScript, et il en va de même en TypeScript,

00:28.440 --> 00:30.810
tous les nombres sont des flottants par défaut.

00:30.810 --> 00:33.270
Ainsi, pour JavaScript, et donc aussi pour TypeScript,

00:33.270 --> 00:35.171
il n'y a aucune différence entre cinq comme

00:35.171 --> 00:36.770
ceci et cinq comme cela.

00:36.770 --> 00:38.640
C'est le même numéro, essentiellement.

00:38.640 --> 00:42.720
Outre les chiffres, nous avons également d'autres types de noyau.

00:42.720 --> 00:46.350
Et ce serait des chaînes de caractères, donc du texte, et des booléens.

00:46.350 --> 00:47.800
Examinons-les également.

00:47.800 --> 00:50.650
En fait, nous avons déjà vu tous ces éléments en action ici, dans cette déclaration

00:50.650 --> 00:53.291
"si", dont nous avons appris qu'elle était un peu redondante.

00:53.291 --> 00:55.971
Néanmoins, ceci serait une chaîne.

00:55.971 --> 00:57.720
De plus, bien sûr, cinq entre guillemets

00:57.720 --> 01:00.389
serait une chaîne de caractères parce que c'est du texte.

01:00.389 --> 01:03.851
Et le résultat, par exemple, de cette comparaison ici,

01:03.851 --> 01:05.170
serait un booléen.

01:05.170 --> 01:08.090
Cet opérateur, le triple signe égal

01:08.090 --> 01:10.950
ou l'opérateur d'égalité niée ici,

01:10.950 --> 01:13.640
qui produit vrai ou faux.

01:13.640 --> 01:14.720
Et, bien sûr, nous pouvons

01:14.720 --> 01:17.340
soit produire un contrôle dynamique interne, ce que

01:17.340 --> 01:18.850
nous ferons souvent.

01:18.850 --> 01:22.340
Ou nous initialisons une variable avec une valeur vraie ou fausse, alors

01:22.340 --> 01:23.379
faisons les deux ici.

01:23.379 --> 01:27.509
Ici, nous pourrions ajouter une nouvelle constante, "printResult".

01:27.509 --> 01:29.990
Et mettez cette valeur à true, par exemple.

01:29.990 --> 01:31.320
Et pour que ce soit bien clair,

01:31.320 --> 01:33.130
cela peut aussi être une variable.

01:33.130 --> 01:34.460
Ça n'a pas besoin d'être une contrainte.

01:34.460 --> 01:36.030
Il peut s'agir d'une variable, que vous

01:36.030 --> 01:37.730
créeriez avec let en JavaScript.

01:37.730 --> 01:39.870
Mais comme je n'ai pas l'intention de la modifier ici, je vais m'en

01:39.870 --> 01:40.703
tenir à une constante.

01:40.703 --> 01:43.670
Et on pourrait passer ça comme troisième paramètre ici.

01:43.670 --> 01:46.960
Disons que nous passons dans "printResult", ce qui est vrai ici.

01:46.960 --> 01:49.720
Nous obtenons immédiatement une erreur, bien sûr, car notre

01:49.720 --> 01:53.160
fonction d'ajout ne prend pas en charge un troisième argument.

01:53.160 --> 01:55.560
On voit, "On attendait deux arguments mais on en a eu trois".

01:55.560 --> 01:57.260
Nous devons donc nous assurer que nous

01:57.260 --> 01:58.920
soutenons un troisième argument.

01:58.920 --> 02:03.920
Et là, nous pourrions ajouter un paramètre "showResult".

02:03.940 --> 02:05.920
Vous pourriez aussi l'appeler "printResult" ici.

02:05.920 --> 02:07.910
J'opte pour "showResult" pour éviter toute

02:07.910 --> 02:11.340
confusion concernant le nommage, mais, techniquement, ces deux noms

02:11.340 --> 02:12.930
ne seraient pas en conflit.

02:12.930 --> 02:14.320
Donc, ici, je vais l'appeler "showResult".

02:14.320 --> 02:17.580
Et je veux m'assurer que c'est de type booléen en le

02:17.580 --> 02:19.500
définissant comme booléen.

02:19.500 --> 02:22.109
Encore une fois, en ajoutant un deux-points après

02:22.109 --> 02:25.120
le paramètre ici et ensuite en ajoutant le nom du type.

02:25.120 --> 02:28.100
Maintenant, cette fonction accepte ceci, et maintenant

02:28.100 --> 02:31.787
ce que nous pouvons faire est d'ajouter une vérification if ici et de vérifier

02:31.787 --> 02:36.480
"if showResult", si c'est vrai, nous pouvons, bien sûr, le comparer à true.

02:36.480 --> 02:37.628
Mais comme vous le savez,

02:37.628 --> 02:41.990
en JavaScript, vous pouvez aussi simplement passer la valeur truthy ou falsy ici.

02:41.990 --> 02:43.970
Et JavaScript l'évaluera, et si cela donne

02:43.970 --> 02:47.389
une valeur vraie ou une valeur véridique en général, alors nous passerons

02:47.389 --> 02:48.989
dans le bloc if.

02:48.989 --> 02:50.011
Sinon, nous ne le ferons pas.

02:50.011 --> 02:52.900
Et disons que nous arrivons ici, et que je veuille faire

02:52.900 --> 02:55.429
une "console". log n1 plus n2".

02:55.429 --> 02:58.581
Sinon, dans le cas contraire, si on n'y arrive pas,

02:58.581 --> 03:00.549
alors je veux renvoyer ceci.

03:00.549 --> 03:02.300
Voici donc une fonction qui renvoie

03:02.300 --> 03:04.760
parfois une valeur et parfois ne renvoie

03:04.760 --> 03:08.309
pas de valeur, mais la produit immédiatement.

03:08.309 --> 03:11.550
Maintenant, vous pourriez argumenter, si vous voulez écrire une

03:11.550 --> 03:14.310
telle fonction, qui est en quelque sorte imprévisible

03:14.310 --> 03:16.651
ou qui pourrait se comporter de manière inattendue

03:16.651 --> 03:18.349
si vous passez un vrai ici.

03:18.349 --> 03:19.990
Mais ici, on le fait.

03:19.990 --> 03:22.090
Ainsi, cette fonction ne revient que parfois.

03:22.090 --> 03:24.869
Parfois, il ne revient pas non plus, mais affiche

03:24.869 --> 03:27.830
simplement quelque chose dans la console.

03:27.830 --> 03:31.120
Maintenant, ici, nous pouvons appeler add juste comme ça et ne

03:31.120 --> 03:33.640
pas avoir besoin de le stocker dans le résultat et

03:33.640 --> 03:37.570
ne pas avoir besoin de la console. le résultat du journal parce que, avec "printResult"

03:37.570 --> 03:39.550
réglé sur true, s'ajoute.

03:39.550 --> 03:41.869
Ainsi, la fonction elle-même imprimera le résultat.

03:41.869 --> 03:43.640
Donc, si nous sauvegardons maintenant

03:43.640 --> 03:47.880
et que nous recompilons notre application. ts ici avec la commande tsc.

03:47.880 --> 03:50.830
Une fois que c'est fait, la page se recharge, et nous voyons

03:50.830 --> 03:52.600
toujours notre résultat ici.

03:52.600 --> 03:54.677
Mais maintenant ça vient de la ligne 6.

03:54.677 --> 03:57.690
Et si nous regardons, la ligne 6 est, en effet, à l'intérieur

03:57.690 --> 03:58.980
de la fonction.

03:58.980 --> 03:59.891
C'est donc un booléen.

03:59.891 --> 04:02.429
Maintenant, disons que nous voulons personnaliser la sortie.

04:02.429 --> 04:06.190
Dans le if ici, nous avons une constante "resultPhrase" ici où

04:06.190 --> 04:10.181
nous disons, "Result is" deux points et ensuite un espace blanc.

04:10.181 --> 04:14.205
Et on passe ça aussi avec "resultPhrase" ici.

04:14.205 --> 04:17.410
Eh bien, on peut s'attendre à ce que ce soit un argument ici aussi.

04:17.410 --> 04:20.750
Phrase, qui donnerait la chaîne de caractères pipe, en ajoutant un deux-points.

04:20.750 --> 04:22.291
Et puis string est le nom du type,

04:22.291 --> 04:26.469
et maintenant nous pouvons utiliser cette phrase pour l'afficher comme une partie

04:26.469 --> 04:31.193
de notre résultat si nous imprimons le résultat directement dans la fonction.

04:31.193 --> 04:34.789
Donc, ici, on pourrait avoir "phrase plus n1 plus n2".

04:34.789 --> 04:37.440
Et si nous faisons cela et que nous recompilons en répétant

04:37.440 --> 04:39.040
cette commande, nous verrons que

04:39.040 --> 04:41.720
cette phrase fait partie du résultat.

04:41.720 --> 04:44.861
Mais nous avons aussi, maintenant, réintroduit l'ancien bug car

04:44.861 --> 04:48.141
j'ai une chaîne de caractères, que je combine avec deux chiffres.

04:48.141 --> 04:52.000
Tout est converti en chaîne ici, et ce n'est pas

04:52.000 --> 04:53.240
ce que je veux.

04:53.240 --> 04:55.930
Pour éviter cela, dans cette fonction, nous pourrions ajouter

04:55.930 --> 04:57.708
une variable de résultat ici.

04:57.708 --> 05:02.027
Ou une constante de résultat et stocker notre résultat ici.

05:02.027 --> 05:04.530
Il sera maintenant traité de manière mathématique,

05:04.530 --> 05:07.990
car seuls des chiffres sont impliqués, et nous pourrons alors le

05:07.990 --> 05:11.430
combiner avec une phrase ou simplement le renvoyer.

05:11.430 --> 05:15.160
Et maintenant, puisque ce n'est jamais calculé directement avec une chaîne de caractères,

05:15.160 --> 05:17.029
ce sera toujours un nombre.

05:17.029 --> 05:19.350
Et, oui, alors ici, ce nombre combiné avec cette

05:19.350 --> 05:21.140
chaîne sera converti en une chaîne.

05:21.140 --> 05:24.360
Mais comme le calcul mathématique s'est terminé avant cela, nous

05:24.360 --> 05:25.548
aurons le bon résultat.

05:25.548 --> 05:28.520
Donc maintenant si on répète ça et qu'on recompile,

05:28.520 --> 05:30.181
on obtient la bonne sortie.

05:30.181 --> 05:33.050
Voici donc les principaux types de données en action.

05:33.050 --> 05:35.541
Assurons-nous maintenant de bien comprendre

05:35.541 --> 05:38.061
comment les types sont affectés et pourquoi nous

05:38.061 --> 05:41.343
n'affectons pas explicitement les types à cet endroit.
