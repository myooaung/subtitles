WEBVTT

00:00.000 --> 00:02.410
(silencio) -: Así que ya vemos cómo

00:02.410 --> 00:04.190
TypeScript puede ayudarnos

00:04.190 --> 00:06.200
durante el desarrollo.

00:06.200 --> 00:10.560
Ahora, también sabemos que hay un tipo de número en JavaScript.

00:10.560 --> 00:14.010
Y podemos verlo con el tipo de operador incorporado.

00:14.010 --> 00:15.781
Esto ahora no es específico de TypeScript,

00:15.781 --> 00:17.560
es un operador incorporado y una palabra

00:17.560 --> 00:20.420
clave soportada por JavaScript.

00:20.420 --> 00:22.910
Podemos utilizarlo para obtener el tipo de un determinado valor.

00:22.910 --> 00:27.050
Así que aquí, podríamos consolar el tipo de bloqueo del número uno.

00:27.050 --> 00:27.992
Y lo que veremos si hacemos

00:27.992 --> 00:30.780
eso es que tan pronto como compilemos esto, para que corramos

00:30.780 --> 00:32.623
el código actualizado.

00:33.780 --> 00:37.040
Aquí, imprimimos el número en la consola.

00:37.040 --> 00:39.330
Ahora lo hacemos, gracias a esta salida aquí,

00:39.330 --> 00:41.180
y gracias al tipo de operador y en JavaScript

00:41.180 --> 00:43.770
de vainilla, sin TypeScript, podríamos usar eso

00:43.770 --> 00:46.710
para mejorar siempre nuestra función aquí.

00:46.710 --> 00:51.500
Podríamos comprobar si el tipo de número es igual al número.

00:51.500 --> 00:54.300
Perdón, tipo de n1 me refiero a si es

00:54.300 --> 00:56.350
igual a número, y también podríamos

00:56.350 --> 01:00.710
comprobar si el tipo de n2 es igual a número.

01:00.710 --> 01:02.349
y sólo realizar nuestra

01:02.349 --> 01:05.220
operación aquí si es un error lanzado de otra

01:05.220 --> 01:07.860
manera o hacer lo contrario y comprobar

01:07.860 --> 01:10.820
si no es igual, o si n2 no es igual.

01:10.820 --> 01:13.230
Y si alguno de los dos no es un número, entonces

01:13.230 --> 01:16.360
podríamos lanzar un nuevo error donde digamos, entrada

01:16.360 --> 01:19.690
incorrecta. Esto en realidad sería una

01:19.690 --> 01:22.300
forma no TypeScript de asegurar que no podemos

01:22.300 --> 01:25.700
llamar a esta función con una cadena aquí.

01:25.700 --> 01:26.760
Si hago esto ahora, y recompilo,

01:26.760 --> 01:29.060
obtenemos nuestro error de TypeScript, pero vamos

01:29.060 --> 01:30.830
a ignorar eso por ahora.

01:30.830 --> 01:31.730
Si volvemos a ejecutar

01:31.730 --> 01:33.100
esto, obtenemos la entrada incorrecta,

01:33.100 --> 01:34.940
que estamos lanzando nosotros mismos.

01:34.940 --> 01:38.080
Así que ahora hemos endurecido la disfunción en JavaScript,

01:38.080 --> 01:39.930
falla en tiempo de ejecución, pero

01:39.930 --> 01:41.970
fallar podría ser aquí mejor que mostrar

01:41.970 --> 01:44.950
una salida incorrecta que teníamos antes.

01:44.950 --> 01:47.640
Así que esta sería una manera de comprobar las entradas

01:47.640 --> 01:48.715
en sólo JavaScript.

01:48.715 --> 01:50.640
No necesitas TypeScript para eso.

01:50.640 --> 01:53.200
Eso es código JavaScript normal.

01:53.200 --> 01:54.033
Pero, por supuesto, este

01:54.033 --> 01:55.160
enfoque tiene inconvenientes.

01:55.160 --> 01:57.160
A veces es lo que hay que hacer.

01:57.160 --> 02:01.440
A veces sólo se pueden validar ciertas entradas en tiempo de ejecución.

02:01.440 --> 02:03.150
Pero el inconveniente es que aquí

02:03.150 --> 02:05.480
estamos comprobando algo que realmente

02:05.480 --> 02:08.950
podemos evitar durante el desarrollo con TypeScript.

02:08.950 --> 02:11.180
Así que sí, estamos lanzando un error.

02:11.180 --> 02:14.210
Y en nuestra aplicación podríamos tener medidas incorporadas

02:14.210 --> 02:16.860
que pueden retroceder a algún otro comportamiento para

02:16.860 --> 02:19.080
salvar la aplicación en ejecución.

02:19.080 --> 02:20.750
Pero aún así, estamos lanzando un

02:20.750 --> 02:24.180
error, que realmente no es necesario que ocurra en primer lugar.

02:24.180 --> 02:27.350
Podríamos haberlo evitado con TypeScript.

02:27.350 --> 02:28.830
Y aquí, realmente vemos la diferencia

02:28.830 --> 02:30.400
entre JavaScript y TypeScript, cuando

02:30.400 --> 02:31.450
se trata de tipos.

02:31.450 --> 02:33.750
JavaScript está tipado dinámicamente, lo que

02:33.750 --> 02:35.610
significa que es perfectamente posible

02:35.610 --> 02:36.880
que tengamos una variable

02:36.880 --> 02:39.100
que inicialmente podría contener un número,

02:39.100 --> 02:41.600
a la que más tarde asignamos una cadena.

02:41.600 --> 02:44.500
Y es por eso que tenemos el operador type off para

02:44.500 --> 02:48.024
poder comprobar el tipo actual de algo en tiempo de ejecución

02:48.024 --> 02:50.124
si tenemos algún código que depende

02:50.124 --> 02:52.267
de un determinado tipo.

02:52.267 --> 02:53.570
Por otro lado, TypeScript

02:53.570 --> 02:55.094
está tipado estáticamente,

02:55.094 --> 02:58.480
lo que significa que definimos los tipos de las variables

02:58.480 --> 03:01.740
y los parámetros termina durante el desarrollo, no cambian

03:01.740 --> 03:04.980
de repente durante el tiempo de ejecución.

03:04.980 --> 03:05.813
Ahora, por supuesto,

03:05.813 --> 03:09.090
ya que TypeScript se compila en JavaScript, teóricamente

03:09.090 --> 03:10.660
podrían.

03:10.660 --> 03:12.510
Pero si usamos TypeScript, y escribimos

03:12.510 --> 03:13.790
código donde de repente

03:13.790 --> 03:17.530
asignamos un nuevo tipo de datos en una variable, donde previamente

03:17.530 --> 03:18.810
dijimos que esto debería

03:18.810 --> 03:19.840
ser un número, por

03:19.840 --> 03:22.900
ejemplo, y ahora estamos asignando una cadena, entonces

03:22.900 --> 03:25.810
obtenemos un error durante el desarrollo, por lo que

03:25.810 --> 03:27.480
estamos obligados a ser claros

03:27.480 --> 03:29.670
con respecto a los tipos, algo puede o no

03:29.670 --> 03:32.120
puede sostener.

03:32.120 --> 03:33.710
Esa es la diferencia aquí.

03:33.710 --> 03:36.620
Así que realmente no queremos usar implementaciones

03:36.620 --> 03:38.330
o soluciones como esa, si podemos

03:38.330 --> 03:40.810
evitarlo con TypeScript.

03:40.810 --> 03:42.200
Aun así, es importante

03:42.200 --> 03:43.890
saber que JavaScript, por supuesto,

03:43.890 --> 03:46.400
conoce el concepto de tipos.

03:46.400 --> 03:48.740
Conoce algunos tipos como números,

03:48.740 --> 03:50.640
cadenas y booleanos.

03:50.640 --> 03:52.300
Pero usar eso siempre significa que

03:52.300 --> 03:53.540
sólo podemos fallar en tiempo

03:53.540 --> 03:56.400
de ejecución en lugar de durante el desarrollo, que es un lugar

03:56.400 --> 03:58.700
mejor para nosotros como desarrollador.

03:58.700 --> 04:01.550
Nos permite corregir los errores antes.

04:01.550 --> 04:02.840
Y además, JavaScript

04:02.840 --> 04:05.410
sólo conoce un par de tipos.

04:05.410 --> 04:07.170
Como aprenderás a lo largo de este curso.

04:07.170 --> 04:10.540
TypeScript conoce muchos más tipos que JavaScript.

04:10.540 --> 04:14.450
Así que la comprobación en tiempo de ejecución no es realmente tan flexible

04:14.450 --> 04:18.030
o no tan potente como lo que podemos hacer con TypeScript.

04:18.030 --> 04:19.490
Y por todas estas razones,

04:19.490 --> 04:20.660
este enfoque no es el

04:20.660 --> 04:22.550
que queremos utilizar aquí.

04:22.550 --> 04:26.540
A veces puede ser útil obtener el tipo en tiempo de ejecución.

04:26.540 --> 04:28.790
Pero a veces, como en este ejemplo, es mucho

04:28.790 --> 04:31.740
mejor conseguirlo durante el desarrollo.

04:31.740 --> 04:34.280
La única cosa importante a reconocer, por supuesto,

04:34.280 --> 04:36.070
sólo es que con TypeScript, sólo se llega

04:36.070 --> 04:38.670
a apoyar durante el desarrollo, no en tiempo de ejecución,

04:38.670 --> 04:39.596
debido a que estas características

04:39.596 --> 04:41.610
de TypeScript y los controles no se construyen

04:41.610 --> 04:44.650
en el motor de JavaScript para que la lógica no puede ejecutar

04:44.650 --> 04:51.223
en el navegador, sólo puede ejecutar durante el desarrollo cuando se compila el código.
