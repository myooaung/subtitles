WEBVTT

00:02.350 --> 00:03.921
教师：现在, 我们有了工会类型｡ 

00:03.921 --> 00:09.764
让我们以联合类型的概念为基础, 同时介绍Literal类型｡

00:09.764 --> 00:16.436
字面类型是这样的类型：你不只是说某个变量或参数应该保存,

00:16.436 --> 00:23.800
比如说一个数字或字符串, 而是非常清楚它应该保存的确切值｡

00:23.800 --> 00:26.064
我们在前面的基础课中已经看到了｡ 

00:26.064 --> 00:28.408
例如, 常数2｡ 

00:28.408 --> 00:32.098
如果我把鼠标悬停在上面, 你会看到, 被推断的类型不是数字,

00:32.098 --> 00:35.680
而是2｡ 8.

00:35.680 --> 00:37.290
而类型组确实推断出这个具体的数是一个类型,

00:37.290 --> 00:41.220
因为它是一个常量｡

00:41.220 --> 00:48.211
它永远不会改变, 因此类型组知道我在这里分配的值就是我拥有的确切类型｡

00:48.211 --> 00:48.211
当然这是一个数字,

00:48.211 --> 00:56.320
你可以说2｡ 8是从数字类型派生出来的, 但它是一个特定的数字｡

00:56.320 --> 00:56.320
这不仅存在于数字中,

00:56.320 --> 01:02.860
也存在于字符串中｡

01:02.860 --> 01:02.860
特别是对于字符串, 它可能非常有用｡ 

01:02.860 --> 01:07.420
比如说, 在我们的组合函数中, 我们期望得到数字或字符串,

01:07.420 --> 01:10.190
我们根据得到的结果以不同的方式组合它们,

01:10.190 --> 01:13.756
但我们也希望允许函数的调用者定义返回结果的方式,

01:13.756 --> 01:25.370
这样我们就可以强制从数字到字符串的转换, 或者相反｡

01:25.370 --> 01:25.370
我们可以用第三个参数来命名,

01:25.370 --> 01:37.240
比如说结果类型, 或者结果转换, 或者你想怎么命名我想用一个字符串来描述它.

01:37.240 --> 01:37.240
所以我将它设置为string类型｡

01:37.240 --> 01:41.122
现在我的想法是, 我可以用两个数字调用combine,

01:41.122 --> 01:55.630
例如, 传入一个字符串“as-number, ”这完全取决于你在这里使用哪个标识符｡

01:55.630 --> 01:55.630
下面我们可能有“as-text”,

01:56.260 --> 02:07.310
但我们可能有另一个组合, 这里是CombinedStringAges, 我传入了两个字符串, 但我仍然想输出这个“as-number”在这种情况下, 第三个参数可能有助于强制转换,

02:07.310 --> 02:34.030
因为如果我在这里传递两个字符串, 通常我们会将其传递到else分支并将其连接起来, 我可能会将其作为数字返回以便我还可以在此处控制台记录组合字符串代理｡

02:34.030 --> 02:34.030
因此,

02:34.030 --> 02:37.512
现在我们只需在if检查中包含resultConversion,

02:37.512 --> 02:49.930
从而在函数中考虑这些标识符｡ 现在的问题是我们到底想做什么;我们是想确保我们可以强制将这两个字符串作为数字相加,

02:49.930 --> 03:03.039
还是想强制将结果（无论它是数学计算还是字符串连接）转换为文本或数字｡

03:03.039 --> 03:03.039
如果我们想强制转换,

03:03.039 --> 03:05.960
我们可以在这里添加if检查, 检查result

03:05.960 --> 03:10.382
conversion是否等于“as-number,

03:10.382 --> 03:18.826
”如果是这样的话, 我想返回result, 在它前面加一个加号, 将它转换成一个数字, 另一种方法是parseFloat,

03:18.826 --> 03:33.593
但是这里我只选择加号, 因为它有点短, 否则我想返回result toString, 强制输出一个字符串｡

03:34.570 --> 03:38.883
现在, 我们根据得到的实数类型进行计算, 然后转换为结果,

03:38.883 --> 03:42.300
这是一种方法, 如果我们保存它, 然后编译该文件,

03:42.300 --> 03:46.360
我们会看到这是我得到的结果, 我们会得到输出,

03:47.470 --> 03:51.020
例如, 这里的字符串组合, 因为正如我所说,

03:51.020 --> 04:05.860
组合本身, 也就是说, 计算是基于我们输入的类型来执行的, 这里是string, 所以我们把它连接起来, 然后转换成result｡

04:05.860 --> 04:19.180
另一种逻辑是检查这里的类型, 并根据我们在这里指定的返回类型执行不同的操作｡

04:19.180 --> 04:19.180
所以我们可以注释掉它,

04:19.180 --> 04:22.600
在这里说, 如果输入1的类型是数字, 输入2的类型是数字,

04:22.600 --> 04:30.865
或者如果resultConversion等于“as-number”, 那么我想像这样组合值,

04:30.865 --> 04:48.490
现在为了避免这个错误, 在这里, 我通过在每个输入前面添加一个加号来强制转换为数字, 这样每个输入都转换为数字, 并且在组合之前保证是数字他们｡

04:48.490 --> 04:51.130
旁注：如果你传入的字符串不能转换成数字,

04:51.130 --> 04:54.610
比如像Max这样的字符串, 那么你会得到一个NaN,

04:54.610 --> 04:58.800
而不是一个数字｡

04:58.800 --> 05:00.280
那么在else的情况下,

05:00.280 --> 05:03.170
我们没有“as-number”, 或者我们只是没有数字输入,

05:03.170 --> 05:07.976
那么我们现在就把它放到这个块里, 如果我在这里再次返回result,

05:07.976 --> 05:20.230
然后我们保存它, 重新编译, 我们会在页面上看到一个不同的输出｡

05:20.230 --> 05:20.230
现在我们在这两行中得到56,

05:20.230 --> 05:31.970
因为现在我们没有转换结果, 所以我们没有转换这一行的连接字符串, 而是在合并两个值之前进行转换｡

05:31.970 --> 05:31.970
因此,

05:31.970 --> 05:34.760
这取决于您希望实现哪种逻辑｡ 实际上, 我想更仔细地研究一下字面类型的概念,

05:34.760 --> 05:41.180
这是我在本课开始时所描述的｡

05:41.180 --> 05:41.180
我传递了一个“as-number”和“as-text”,

05:44.157 --> 05:47.600
以及一个业务的失败, 现在我们作为一个开发人员必须记住这些价值观｡

05:47.600 --> 05:50.450
我们得确保这里不会漏字｡ 

05:50.450 --> 05:54.010
现在我们可以使用一个e-num来改进, 但是如果我们这里只有两个值,

05:54.010 --> 06:00.940
“as-text”或“as-number”, 那么也许所有的搜索文字类型都可以是一个选项｡

06:00.940 --> 06:04.173
我们可以说“这不应该是任何字符串, 它应该是“as-number”或“as-text””,

06:04.173 --> 06:15.573
所以我们使用联合类型与文本类型的组合｡

06:15.573 --> 06:15.573
文本类型是基于核心类型字符串､

06:15.573 --> 06:24.750
数字等的类型, 但随后您将拥有该类型的特定版本｡

06:24.750 --> 06:24.750
所以这里,

06:24.750 --> 06:27.960
我们特别允许这两个字符串不是任何字符串, 只是这两个字符串｡

06:27.960 --> 06:34.207
因此, 我们需要一个字符串来进行结果转换, 但它必须是这两个值之一｡

06:34.207 --> 06:34.207
任何其他字符串值都是不允许的,

06:34.207 --> 06:40.747
这就是字面类型背后的思想, 通常你会在联合类型的上下文中使用它, 因为你不想只允许一个确切的值,

06:40.747 --> 06:43.700
如果是这样的话, 你可以把它硬编码到你的代码中,

06:43.700 --> 06:49.544
但是你想有两个或更多的可能值｡

06:49.544 --> 06:52.580
在这种情况下, 我们得到两个可能的值｡ 

06:52.580 --> 06:56.240
现在我们可以保证得到的结果转换是“as-number”或“as-text”,

06:56.240 --> 07:07.256
例如这里, 如果我现在尝试将它与as-numbe进行比较, 因为我这里有一个打字错误, 类型组能够在IDE中告诉我, 当然, 我们在终端中保存并编译它,

07:07.256 --> 07:24.563
因为它知道-numbe如果末尾没有r, 将永远不会是resultConversion的有效值, 因为我用这些文字类型设置了这个联合类型｡

07:25.550 --> 07:27.593
所以现在我们再次获得了一些额外的类型安全,

07:27.593 --> 07:31.590
并确保我们不会错误地使用它｡

07:31.590 --> 07:34.720
当然, 传入一个值也是如此｡  如果我们这里有一个错别字,

07:34.720 --> 07:38.747
我们得到一个错误, 只有当我们使用“as-number”或“as-text”,

07:38.747 --> 07:41.947
我们被允许编译这个, 你看到的, 现在编译这个, 这个工作,

07:41.947 --> 07:49.562
我们得到和前面一样的输出｡

07:49.562 --> 07:49.562
因此,

07:49.562 --> 07:52.193
这些常值型别在与等位型别搭配使用时特别有用｡
