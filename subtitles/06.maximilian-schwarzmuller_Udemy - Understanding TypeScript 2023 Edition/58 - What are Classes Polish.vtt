WEBVTT

00:02.100 --> 00:04.890
Instruktor: Aby zrozumieć klasy zrozummy

00:04.890 --> 00:07.040
programowanie obiektowe.

00:07.040 --> 00:10.050
Teraz, w zależności od poziomu wiedzy i jeśli

00:10.050 --> 00:12.560
pracowałeś z nowoczesnym JavaScriptem,

00:12.560 --> 00:15.340
a może także niektórymi innymi językami programowania,

00:15.340 --> 00:18.320
możesz być świadomy, po co są klasy i o co chodzi

00:18.320 --> 00:22.270
w programowaniu obiektowym OOP.

00:22.270 --> 00:24.570
Dlatego możesz również pominąć ten wykład,

00:24.570 --> 00:27.720
aby przeskoczyć od razu do części, w których piszemy kod.

00:27.720 --> 00:29.330
W przeciwnym razie zdecydowanie

00:29.330 --> 00:32.200
trzymaj się mnie, ponieważ ważne jest, aby to zrozumieć.

00:32.200 --> 00:35.240
Ideą programowania obiektowego i klas będzie

00:35.240 --> 00:38.550
ważne dla tego, jak zobaczysz, jest to, że pracujesz

00:38.550 --> 00:41.630
z rzeczywistymi jednostkami w swoim kodzie, można

00:41.630 --> 00:43.110
powiedzieć.

00:43.110 --> 00:47.370
Tak, że pracujesz z rzeczami w swoim kodzie z obiektami, które przypominają

00:47.370 --> 00:52.110
rzeczywiste obiekty w jak największym stopniu przynajmniej po to, aby ułatwić

00:52.110 --> 00:54.410
ci jako deweloperowi rozumowanie o twoim

00:54.410 --> 00:56.250
kodzie.

00:56.250 --> 00:59.150
Przykładowo, możemy budować sklep internetowy

00:59.150 --> 01:01.270
i tam możemy mieć listę produktów.

01:01.270 --> 01:05.190
Możemy zatem chcieć pracować z obiektem listy produktów, który ma wszystko,

01:05.190 --> 01:08.140
czego potrzebujemy do zarządzania listą produktów.

01:08.140 --> 01:11.570
Metoda dodawania produktów do produktów wiodących,

01:11.570 --> 01:13.370
czyli samej listy.

01:13.370 --> 01:15.670
Tak więc na przykład może to być obiekt, który

01:15.670 --> 01:18.360
jest odpowiedzialny za renderowanie listy produktów

01:18.360 --> 01:19.540
i zarządzanie nią, które

01:19.540 --> 01:22.840
zostały pobrane z usługi lub z bazy danych.

01:22.840 --> 01:25.530
Więc ten produkt przechowuje całą logikę renderowania

01:25.530 --> 01:27.260
i pobierania oraz zarządzania.

01:27.260 --> 01:29.420
To jest dopiero lista produktów.

01:29.420 --> 01:32.510
W naszym programie do strony internetowej, którą budujemy, możemy

01:32.510 --> 01:33.870
również potrzebować pracy

01:33.870 --> 01:36.000
z poszczególnym produktem chociaż.

01:36.000 --> 01:39.540
Więc możemy również chcieć obiekt lub wiele obiektów; jeden dla każdego

01:39.540 --> 01:40.960
produktu, który jest odpowiedzialny

01:40.960 --> 01:43.930
za zarządzanie pojedynczym produktem.

01:43.930 --> 01:47.180
Może trzymać i renderować szczegóły dotyczące tego produktu,

01:47.180 --> 01:49.830
może pozwolić nam dodać go do koszyka, rzeczy

01:49.830 --> 01:51.260
tego typu.

01:51.260 --> 01:54.900
Kiedy więc chcemy narysować interfejs użytkownika na ekranie, chcemy

01:54.900 --> 01:57.010
zarządzać tym poprzez JavaScript, a więc

01:57.010 --> 01:58.740
poprzez TypeScript, to moglibyśmy

01:58.740 --> 02:00.550
zaimplementować to za pomocą listy

02:00.550 --> 02:02.970
produktów i obiektu product, który przechowuje

02:02.970 --> 02:05.370
logikę do zarządzania danymi bazowymi, ale także

02:05.370 --> 02:07.760
do renderowania treści na ekranie.

02:07.760 --> 02:10.010
I oczywiście dlatego te dwa obiekty

02:10.010 --> 02:11.940
byłyby jakby powiązane.

02:11.940 --> 02:14.790
Na naszym ekranie możemy mieć również obiekt koszyka, który

02:14.790 --> 02:16.410
jest odpowiedzialny za renderowanie

02:16.410 --> 02:18.040
i zarządzanie kartą zakupową.

02:18.040 --> 02:20.380
Jest to oczywiście związane również z produktem.

02:20.380 --> 02:22.930
I dlatego mieści całą logikę, której potrzebujemy

02:22.930 --> 02:24.880
do renderowania naszej karty zakupowej,

02:24.880 --> 02:27.240
składania zamówień, komunikacji z serwerem i

02:27.240 --> 02:28.073
tak dalej.

02:28.073 --> 02:31.190
Byłby to więc jeden ze sposobów, w jaki moglibyśmy myśleć

02:31.190 --> 02:33.010
o aplikacji, którą budujemy.

02:33.010 --> 02:35.590
Jak moglibyśmy podzielić ją na logiczne kawałki,

02:35.590 --> 02:37.670
które mają sens dla nas jako ludzi.

02:37.670 --> 02:40.320
A w kodzie w TypeScript i JavaScript, w większości

02:40.320 --> 02:42.920
nowoczesnych języków programowania, jest to aktywnie

02:42.920 --> 02:46.750
wspierane, ponieważ mamy obiekty, które są bardziej złożonymi strukturami

02:46.750 --> 02:48.900
danych, które przechowują właściwości

02:48.900 --> 02:50.640
i metody.

02:50.640 --> 02:53.340
I oczywiście mamy to również w JavaScript.

02:53.340 --> 02:57.310
Ale możemy też mieć zajęcia, które nam w tym pomogą.

02:57.310 --> 02:59.100
A teraz jaka jest idea zajęć?

02:59.100 --> 03:00.740
A czym są instancje?

03:00.740 --> 03:02.030
Kiedy otrzymujemy te

03:02.030 --> 03:04.690
obiekty i kiedy podążamy za tym podejściem obiektowym,

03:04.690 --> 03:07.500
możemy rozważyć podzielenie naszej aplikacji

03:07.500 --> 03:11.130
lub naszej logiki aplikacji na takie obiekty, które zarządzają

03:11.130 --> 03:13.750
częściami naszej logiki.

03:13.750 --> 03:17.000
Teraz związane z ideą używania tych obiektów,

03:17.000 --> 03:19.340
które oczywiście istnieją w JavaScript

03:19.340 --> 03:23.910
możemy używać obiektów tam jako idea posiadania klas.

03:23.910 --> 03:27.470
Obiekty to konkretne rzeczy, z którymi pracujemy w naszym kodzie.

03:27.470 --> 03:30.380
Struktury danych, których używamy do przechowywania

03:30.380 --> 03:33.450
danych do przechowywania metod do wykonywania metod na.

03:33.450 --> 03:36.570
Klasy są wzorami dla obiektów.

03:36.570 --> 03:40.880
Klasy pozwalają nam zdefiniować jak obiekty powinny wyglądać; jakie

03:40.880 --> 03:42.230
dane powinny trzymać,

03:42.230 --> 03:44.070
jakie metody powinny mieć, dzięki

03:44.070 --> 03:48.240
czemu możemy łatwo budować obiekty w oparciu o te klasy.

03:48.240 --> 03:51.830
A my wtedy nazywamy to instancjami klas.

03:51.830 --> 03:54.830
Więc obiekt wtedy jest instancją klasy jeśli jest oparty

03:54.830 --> 03:56.850
na takiej klasie, dzięki czemu możemy

03:56.850 --> 03:59.900
szybko replikować wiele obiektów o tej samej strukturze

03:59.900 --> 04:02.230
tych samych metodach opartych na tych samych

04:02.230 --> 04:04.090
klasach.

04:04.090 --> 04:07.280
Tak więc klasy pomagają nam określić, jak obiekty powinny wyglądać,

04:07.280 --> 04:10.170
jakie mają właściwości i metody i tak dalej.

04:10.170 --> 04:14.920
Tak więc klasy istnieją, aby przyspieszyć tworzenie obiektów.

04:14.920 --> 04:16.160
I jest to po prostu alternatywa

04:16.160 --> 04:20.070
dla używania notacji literalnej obiektu, którą już znasz.

04:20.070 --> 04:21.330
Po prostu ułatwiają to zadanie.

04:21.330 --> 04:24.620
Klasy po prostu ułatwiają tworzenie wielu obiektów, które

04:24.620 --> 04:26.900
generalnie mają tę samą strukturę i te same

04:26.900 --> 04:28.030
metody, a które mogą

04:28.030 --> 04:32.780
się różnić jedynie dokładnymi danymi, które są w nich przechowywane.

04:32.780 --> 04:34.540
Powiedzmy, że mamy wiele osób, które

04:34.540 --> 04:36.670
chcemy reprezentować za pomocą obiektów.

04:36.670 --> 04:39.330
Cóż każda osoba może mieć imię i wiek, wartości

04:39.330 --> 04:40.830
będą się różnić, ogólna

04:40.830 --> 04:43.310
struktura jest taka sama.

04:43.310 --> 04:44.500
Więc taka jest teoria.

04:44.500 --> 04:46.113
Zobaczmy to w praktyce.
