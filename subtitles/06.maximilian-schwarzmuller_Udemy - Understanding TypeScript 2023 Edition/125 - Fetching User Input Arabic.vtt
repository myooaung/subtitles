WEBVTT

00:02.150 --> 00:06.180
المدرب: لذلك نحن قادرون على جمع قيمة إدخال العنوان وطباعته

00:06.180 --> 00:07.420
على وحدة التحكم ، ولكن

00:07.420 --> 00:10.160
بالطبع ، هذه ليست الفكرة في النهاية.

00:10.160 --> 00:13.940
بدلاً من ذلك ، الفكرة هي أننا نجمع كل قيم المدخلات

00:13.940 --> 00:15.420
لدينا ، ونتحقق من صحتها

00:15.420 --> 00:17.890
بسرعة ، ثم نفعل شيئًا بها.

00:17.890 --> 00:20.598
لذلك ، سأضيف طريقة جديدة أخرى

00:20.598 --> 00:21.860
، طريقة خاصة أخرى

00:21.860 --> 00:25.700
، لأنني سأسميها فقط من داخل الفصل ، وهي طريقة

00:25.700 --> 00:28.530
collectUserInput.

00:28.530 --> 00:30.460
الاسم متروك لك تمامًا.

00:30.460 --> 00:33.240
فكرتي هي أنه يتم استدعاء هذه الطريقة هنا.

00:33.240 --> 00:35.230
بعد أن منعنا الإعداد الافتراضي

00:35.230 --> 00:38.980
، يجب أن يصل هذا بشكل أساسي إلى جميع مدخلاتنا هنا ، وجمع

00:38.980 --> 00:40.870
مدخلات المستخدم هناك ، والتحقق

00:40.870 --> 00:43.060
من صحتها ، ثم إعادتها.

00:43.060 --> 00:45.950
هنا ، حصلت على مدخلات المستخدم الخاصة

00:45.950 --> 00:50.090
بي ، والتي يمكن أن تكون مجموعة مع العنوان والوصف

00:50.090 --> 00:53.810
والأشخاص ، مثل قيم tuple المجانية.

00:53.810 --> 00:55.510
في الواقع ، أحب هذه الفكرة.

00:55.510 --> 00:57.800
لذلك ، دعونا بالفعل نحدد نوع الإرجاع هنا.

00:57.800 --> 00:59.880
نوع الإرجاع هو tuple.

00:59.880 --> 01:02.620
الآن هل تتذكر كيف يتم تعريف tuple؟

01:02.620 --> 01:05.630
كيف يتم تعريف نوع المجموعة؟

01:05.630 --> 01:08.620
إنها ليست سلسلة ، أقواس مربعة.

01:08.620 --> 01:12.260
هذا يعني أنك تعيد مجموعة من السلاسل.

01:12.260 --> 01:14.550
بدلاً من ذلك ، أريد أن أقول

01:14.550 --> 01:18.160
إنني أعيد مجموعة من عناصر X بالضبط من

01:18.160 --> 01:21.510
هذه الأنواع الثلاثة بالضبط.

01:21.510 --> 01:23.650
ولهذا ، تقوم بتعيين نوع الإرجاع

01:23.650 --> 01:27.160
هنا ، قوسين مربعين ، ثم داخل الأقواس المربعة ، يمكنك

01:27.160 --> 01:30.240
إضافة العناصر المختلفة وأنواع العناصر.

01:30.240 --> 01:32.900
على سبيل المثال ، سلسلة ، وسلسلة ، ورقم.

01:32.900 --> 01:37.130
بهذا ، أنت تقول أن هذه الطريقة تُرجع هنا بنية ، تحتوي على ثلاثة عناصر

01:37.130 --> 01:38.510
، حيث العنصر الأول عبارة

01:38.510 --> 01:40.300
عن سلسلة ، والعنصر الثاني عبارة

01:40.300 --> 01:41.820
عن سلسلة ، والعنصر الثالث

01:41.820 --> 01:44.080
هو في الواقع رقم.

01:44.080 --> 01:46.360
والآن يمكننا إضافة بعض المنطق إلى

01:46.360 --> 01:48.540
هذه الطريقة لجعل ذلك صحيحًا.

01:48.540 --> 01:52.670
لذلك ، دعنا أولاً نحصل على العنوان الذي تم إدخاله من

01:52.670 --> 01:57.210
هذا العنوانInputElement. القيمة.

01:57.210 --> 01:58.340
ويمكننا تكرار ذلك.

01:58.340 --> 02:01.920
نريد أيضًا وصف الدورة التدريبية الذي تم إدخاله من هذا

02:01.920 --> 02:05.100
الوصفInputElement. القيمة ، والمبلغ الذي

02:05.100 --> 02:09.510
تم إدخاله ، أو الأشخاص الذين تم إدخالهم للتو ، الأشخاص

02:09.510 --> 02:12.440
من هذا الأشخاص ، المدخلات.

02:12.440 --> 02:13.870
الآن قمت بتخزين هذا في

02:13.870 --> 02:15.490
ثوابت حتى لا أضطر دائمًا إلى

02:15.490 --> 02:17.640
تكرار هذه التعبيرات الأطول.

02:17.640 --> 02:19.370
الآن ، يمكننا التحقق من صحة هذا.

02:19.370 --> 02:21.500
سيكون التحقق من الصحة تافهة للتحقق

02:21.500 --> 02:24.850
مما إذا تم إدخال العنوان. تقليم ، لذلك قم بإزالة مساحة

02:24.850 --> 02:27.610
X الواسعة في البداية والنهاية.

02:27.610 --> 02:30.560
الطول يساوي الصفر ، أو إذا

02:30.560 --> 02:35.350
تم إدخال الوصف. طول القطع يساوي صفرًا

02:35.350 --> 02:41.520
، أو إذا تم إدخال الأشخاص.

02:41.520 --> 02:41.520
طول

02:41.520 --> 02:44.380
القطع يساوي الصفر.

02:44.380 --> 02:48.410
هذا من شأنه أن يتحقق من عدم وجود مدخلات فارغة.

02:48.410 --> 02:50.330
الآن ، لا يتحقق من كل شيء قد نريد التحقق

02:50.330 --> 02:51.860
منه بالرغم من ذلك.

02:51.860 --> 02:54.770
نحن لا نتحقق مما إذا كان الأشخاص الذين تم إدخالهم

02:54.770 --> 02:57.160
، دعنا نقول ، رقمًا موجبًا.

02:57.160 --> 03:00.170
لا يمكننا تحديد حد أدنى للطول.

03:00.170 --> 03:02.190
سيتعين علينا إضافة المزيد والمزيد

03:02.190 --> 03:04.050
من الشروط هنا ، وبينما يمكننا القيام

03:04.050 --> 03:06.820
بذلك ، لن يكون هذا حلاً قابلاً للتطوير حقًا.

03:06.820 --> 03:09.110
إذا كانت لدينا أجزائنا في التطبيق حيث

03:09.110 --> 03:11.550
نريد أيضًا التحقق من صحة إدخال المستخدم

03:11.550 --> 03:14.440
، فعلينا دائمًا تكرار عبارات if الطويلة.

03:14.440 --> 03:18.390
لذلك سوف أتوصل إلى حل تحقق أكثر ذكاءً أو حل

03:18.390 --> 03:21.960
تحقق أكثر قابلية للتوسع قريبًا.

03:21.960 --> 03:23.780
في الوقت الحالي ، يمكننا ترك الأمر على هذا النحو.

03:23.780 --> 03:26.190
يمكنك بالفعل التفكير في هذا الأمر

03:26.190 --> 03:28.520
، وبالطبع بعد هذه المحاضرة هنا

03:28.520 --> 03:32.220
، توقف مؤقتًا وفكر في كيفية الاستعانة بمصادر خارجية

03:32.220 --> 03:34.670
في وظيفة تحقق منفصلة قابلة للتكوين

03:34.670 --> 03:38.350
، وكيف يمكن للأنواع مساعدتك هناك.

03:38.350 --> 03:41.370
هناك بالتأكيد العديد من الأساليب الممكنة

03:41.370 --> 03:44.040
، وسوف أشارككم في المحاضرة القادمة.

03:44.040 --> 03:45.620
ولكن قبل أن نصل إلى هذا

03:45.620 --> 03:48.350
الحد ، فلنستخدم هذا النهج التافه هنا

03:48.350 --> 03:52.130
ونفعل شيئًا إذا تم استيفاء كل هذه الشروط.

03:52.130 --> 03:53.620
الآن إذا جعلناه في كتلة if

03:53.620 --> 03:56.000
، فنحن نعلم أن عملية تحقق واحدة على الأقل

03:56.000 --> 03:57.350
فشلت ، وبعد ذلك يمكننا أن

03:57.350 --> 04:01.833
ننتهي في حالة تأهب ، حيث نقول إدخال غير صالح ، يرجى المحاولة مرة أخرى.

04:03.450 --> 04:04.910
عدا ذلك ، إذا لم نتمكن

04:04.910 --> 04:06.200
من الوصول إلى هناك

04:06.200 --> 04:08.600
، فنحن نعلم أن لدينا مدخلات صالحة ،

04:08.600 --> 04:11.310
وإلا أريد إعادة المجموعة الخاصة بي.

04:11.310 --> 04:14.170
هنا ، أريد أن أعيد العنوان الذي تم إدخاله

04:14.170 --> 04:17.090
والوصف الذي تم إدخاله وأيضًا الأشخاص

04:17.090 --> 04:19.660
الذين تم إدخالهم.

04:19.660 --> 04:20.630
الآن كما يمكنك أن تقول

04:20.630 --> 04:21.850
، فإن مجموعة الأنواع ليست

04:21.850 --> 04:24.210
سعيدة ، لأن الأشخاص الذين تم إدخالهم يجب أن يكونوا

04:24.210 --> 04:25.370
رقمًا وليس نصًا.

04:25.370 --> 04:27.410
وفي الواقع ، سيكون كل شيء

04:27.410 --> 04:28.720
تستخرجه من خاصية

04:28.720 --> 04:32.350
القيمة لعنصر الإدخال نصًا افتراضيًا.

04:32.350 --> 04:34.520
لذلك لتحويل هذا إلى رقم ، يمكننا

04:34.520 --> 04:38.060
استدعاء parseFloat ، على سبيل المثال ، أو ببساطة

04:38.060 --> 04:40.610
إضافة علامة زائد أمامها ، وهذا سيحولها

04:40.610 --> 04:42.850
إلى رقم ، وما زلت مجموعة الأنواع

04:42.850 --> 04:45.430
ليست سعيدة لأننا ، حسنًا ، لا نعود

04:45.430 --> 04:48.910
دائمًا مجموعة.

04:48.910 --> 04:50.830
ماذا عن هذا الجزء هنا؟

04:50.830 --> 04:52.310
إذا وصلنا إلى كتلة if

04:52.310 --> 04:53.510
، فإننا نعرض تنبيهًا

04:53.510 --> 04:55.820
، لكننا لا نعيد tuple.

04:55.820 --> 04:59.810
حسنًا ، هناك العديد من الأشياء التي يمكننا القيام بها بدلاً من ذلك.

04:59.810 --> 05:03.460
لا يمكننا إرجاع أي شيء مثل هذا.

05:03.460 --> 05:06.320
بدلاً من ذلك ، يمكننا أن نخطئ.

05:06.320 --> 05:08.360
بعد ذلك ، لن نعيد أي شيء في الواقع

05:08.360 --> 05:11.100
، لكننا سنرتكب خطأ في هذه الحالة.

05:11.100 --> 05:12.820
الآن ، لا أريد أن أخطئ هنا لأنني

05:12.820 --> 05:15.570
لا أريد حقًا تنفيذ معالجة الأخطاء ، لذا ما سأفعله

05:15.570 --> 05:18.090
هو أنني سأضيف فقط تعليمة إرجاع ، لكن بالطبع

05:18.090 --> 05:20.100
هذه ليست مجموعة.

05:20.100 --> 05:23.110
إذن ، في الواقع ، نوع الإرجاع هنا هو

05:23.110 --> 05:25.923
tuple ، أو أنه غير محدد بالفعل.

05:27.320 --> 05:29.040
ومع ذلك ، الآن ، كما تعلمت ،

05:29.040 --> 05:30.750
لا يجب استخدام undefined

05:30.750 --> 05:32.550
هنا كنوع إرجاع للوظائف.

05:32.550 --> 05:34.040
بدلا من ذلك استخدم الفراغ.

05:34.040 --> 05:35.410
إنها متشابهة تقريبًا

05:35.410 --> 05:37.040
، ولكنها حصرية للوظائف

05:37.040 --> 05:39.350
، وهذا يخبر TypeScript

05:39.350 --> 05:46.930
أن هذه وظيفة لها على الأقل فرع لا يُرجع أي قيمة مثل هذه القيمة.

05:46.930 --> 05:49.160
نحن هنا أيضًا بالطبع نستخدم نوع الاتحاد

05:49.160 --> 05:51.240
لأن لدينا كلا الاحتمالين.

05:51.240 --> 05:53.170
قد لا نرجع شيئًا ،

05:53.170 --> 05:55.660
أو نعيد بالفعل tuple.

05:55.660 --> 05:57.510
الآن ، لدينا collectUserInput

05:57.510 --> 05:59.370
و userInput هناك للجميع

05:59.370 --> 06:01.670
إما غير محدد في النهاية أو أنها

06:01.670 --> 06:04.130
تلك tuple.

06:04.130 --> 06:07.640
لذا الآن ، قبل المضي قدمًا وتحسين عملية التحقق ، دعنا

06:07.640 --> 06:09.620
نبني على إدخال المستخدم هذا.

06:09.620 --> 06:12.480
عندما نقوم بتجميع userInput هناك ، لدينا

06:12.480 --> 06:14.820
الآن عنصر userInput هذا ، والآن يمكننا

06:14.820 --> 06:17.050
التحقق مما إذا كان tuple.

06:17.050 --> 06:19.820
المشكلة الآن في وقت التشغيل ، ليس لدينا

06:19.820 --> 06:22.620
طريقة للتحقق مما إذا كانت tuple.

06:22.620 --> 06:25.200
لا يوجد مثيل يمكننا استخدامه.

06:25.200 --> 06:28.560
لا يوجد نوع Tuple يمكننا التحقق منه.

06:28.560 --> 06:31.020
لا يمكننا أيضًا التحقق مما إذا كانت

06:33.803 --> 06:36.053
typof userInput تساوي tuple لأن

06:37.130 --> 06:40.050
ذلك غير موجود في Vanilla JavaScript.

06:40.050 --> 06:41.850
السلسلة موجودة على سبيل

06:41.850 --> 06:44.950
المثال ، لكن tuple ليس من نوع JavaScript.

06:44.950 --> 06:47.020
حتى نتحقق مما إذا كانت tuple

06:47.020 --> 06:48.900
، علينا أن نتذكر أن tuple

06:48.900 --> 06:50.990
في النهاية تم محوه للتو.

06:50.990 --> 06:52.750
إنها خاصة في TypeScript

06:52.750 --> 06:54.860
، ولكن بمجرد أن نكون في أرض JavaScript

06:54.860 --> 06:55.940
، يتم محوها فقط

06:55.940 --> 06:58.320
لأن فكرة المجموعة حيث يتم إصلاح

06:58.320 --> 06:59.950
عدد العناصر وأنواع العناصر

06:59.950 --> 07:04.470
موجودة بالفعل فقط في TypeScript.

07:04.470 --> 07:05.930
لذلك ، أثناء وقت التشغيل

07:05.930 --> 07:09.370
، كل ما نحتاج إلى التحقق منه هنا هو ما إذا كانت مصفوفة أم

07:09.370 --> 07:12.950
لا ، ومن أجل ذلك ، يمكننا استخدام كائن المصفوفة في JavaScript

07:12.950 --> 07:15.180
، وهناك طريقة isArray.

07:15.180 --> 07:17.500
هذه طريقة مضمنة في Vanilla JavaScript

07:17.500 --> 07:20.290
تتيح لنا التحقق مما إذا كانت هذه مصفوفة.

07:20.290 --> 07:23.200
نعلم أنه إما غير محدد أو مجموعة.

07:23.200 --> 07:24.630
الصفيف هو مصفوفة ، لذلك

07:24.630 --> 07:26.000
إذا عاد هذا صحيحًا ، فسنحصل

07:26.000 --> 07:27.400
على المجموعة.

07:27.400 --> 07:31.010
وبعد ذلك هنا ، يمكننا استخدام الهيكلة على سبيل المثال

07:31.010 --> 07:34.070
للحصول على العنوان والوصف والأشخاص من مدخلات

07:34.070 --> 07:35.560
المستخدم ، ثم القيام بشيء

07:35.560 --> 07:37.720
باستخدام هذه المدخلات.

07:37.720 --> 07:39.230
على سبيل المثال الآن

07:39.230 --> 07:42.623
، وحدة التحكم. عنوان السجل والوصف والأشخاص.

07:43.980 --> 07:46.060
إذا فعلنا كل ذلك وقمنا بحفظه جميعًا

07:46.060 --> 07:47.950
، فسيتم تجميعه بدون أخطاء ، وإذا

07:47.950 --> 07:49.870
عدنا إلى هنا ، وقمت بالنقر فوق

07:49.870 --> 07:51.310
مشروع مثل هذا ، أحصل على

07:51.310 --> 07:53.050
مدخلات غير صالحة.

07:53.050 --> 07:54.580
إذا أدخلت "مرحبًا" ، فما

07:54.580 --> 07:56.950
زلت أحصل عليها لأنه ليس لدينا وصف.

07:56.950 --> 07:58.890
هذا وصف.

07:58.890 --> 08:00.180
ما زلنا نحصل عليه بالطبع

08:00.180 --> 08:02.940
، ولكن إذا قمت الآن بإدخال شيء ما في الأشخاص

08:02.940 --> 08:05.220
، فهذا يعمل ونطبعه هنا.

08:05.220 --> 08:09.330
هذه بالطبع خطوة جيدة في الاتجاه الصحيح.

08:09.330 --> 08:10.990
لم نصل إلى هناك بالكامل بعد.

08:10.990 --> 08:13.330
كما قلت ، يمكننا تحسين التحقق من الصحة.

08:13.330 --> 08:16.230
شيء واحد فقط أريد القيام به على الفور قبل القيام

08:16.230 --> 08:20.070
بذلك ، أريد مسح جميع المدخلات بعد النقر فوق إضافة مشروع.

08:20.070 --> 08:22.440
لذلك أريد إفراغ جميع المدخلات مرة أخرى.

08:22.440 --> 08:25.290
الآن من أجل ذلك ، يمكننا إضافة طريقة خاصة جديدة ، clearInput

08:25.290 --> 08:27.043
أو clearInputs ، وهناك ، يمكننا

08:28.210 --> 08:32.740
تعيين هذا titleInputElement. قيمة مساوية لسلسلة فارغة

08:32.740 --> 08:34.130
وكرر ذلك للمدخلات

08:36.200 --> 08:38.980
الأخرى أيضًا.

08:38.980 --> 08:41.960
هنا ، لدينا الوصف InputElement ، وهنا ،

08:41.960 --> 08:44.250
لدينا PeopleInputElement ، والآن

08:44.250 --> 08:48.190
، إذا كنا نسمي هذا. clearInputs هنا ، يجب

08:48.190 --> 08:50.200
أن نتأكد من مسح النموذج

08:50.200 --> 08:51.730
بمجرد تقديمه.

08:51.730 --> 08:52.870
لذا إذا حاولنا ذلك

08:52.870 --> 08:54.380
مرة أخرى ، أدخل شيئًا

08:54.380 --> 08:56.230
هنا ، سترى أنه مطبوع هنا ، وتم

08:56.230 --> 08:57.740
مسح النموذج.

08:57.740 --> 09:00.720
مع ذلك ، أنا سعيد بشكل عام بالطريقة التي تعاملنا بها مع

09:00.720 --> 09:03.300
هذا ، لكنني الآن أريد تحسين التحقق من الصحة وكتابة

09:03.300 --> 09:06.970
هذا بطريقة أكثر قابلية لإعادة الاستخدام وقابلة للتطوير.

09:06.970 --> 09:07.840
كما ذكرت ، لا تتردد

09:07.840 --> 09:10.320
بالتأكيد في القيام بذلك بنفسك أولاً.

09:10.320 --> 09:11.530
في المحاضرة التالية

09:11.530 --> 09:12.580
، سنفعل ذلك معًا.
