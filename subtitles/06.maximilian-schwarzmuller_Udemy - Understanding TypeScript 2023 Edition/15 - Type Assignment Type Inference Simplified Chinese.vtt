WEBVTT

00:02.270 --> 00:03.850
教师：我们使用的核心类型是数字､

00:03.850 --> 00:07.450
布尔值和字符串｡

00:07.450 --> 00:10.840
在这个函数的参数列表中,

00:10.840 --> 00:13.970
我们总是显式地在参数名后面加上冒号,

00:13.970 --> 00:18.410
然后是类型名｡

00:18.410 --> 00:21.350
在这里, 名称是数字､ 布尔值和字符串｡ 

00:21.350 --> 00:25.420
如果你想知道, 这些现在是特殊的标识符｡

00:25.420 --> 00:30.170
这里, 这是一个由TypeScript添加的特殊语法｡

00:30.170 --> 00:32.900
它不是编译的JavaScript代码的一部分｡ 

00:32.900 --> 00:35.040
如果我们检查这里的代码, 这些类型赋值就消失了,

00:35.040 --> 00:39.530
因为JavaScript不支持它们｡

00:39.530 --> 00:43.920
变量或参数后面的冒号｡

00:43.920 --> 00:46.320
然后是数字布尔值字符串｡ 

00:46.320 --> 00:48.290
这些特殊的关键词｡ 

00:48.290 --> 00:50.840
这是由TypeScript引入的｡ 

00:50.840 --> 00:53.500
TypeScript编译器理解它｡ 

00:53.500 --> 00:55.480
此处的IDE支持TypeScript,

00:55.480 --> 00:58.580
因此不会抱怨这些特殊关键字｡

00:58.580 --> 01:01.760
JavaScript不理解此语法｡ 

01:01.760 --> 01:04.590
它不理解参数后的冒号或变量后的冒号,

01:04.590 --> 01:09.190
以及特殊的数字或字符串关键字｡

01:09.190 --> 01:13.560
JavaScript不理解这一点, 因此这不是JavaScript输出的一部分｡

01:13.560 --> 01:15.920
它实际上只由TypeScript编译器使用｡ 

01:15.920 --> 01:21.820
然后, 它是一个编译器, 因为它将这些代码转换为JavaScript代码｡

01:21.820 --> 01:24.880
边注, 你也看到它把const转换为var,

01:24.880 --> 01:27.700
但这是我稍后会讲的｡

01:27.700 --> 01:33.060
这里有显式的类型赋值, 只有TypeScript才能理解｡

01:33.060 --> 01:35.763
太好了, 我们为什么不让他们在下面呢？

01:36.880 --> 01:39.890
这里没有显式的类型赋值｡ 

01:39.890 --> 01:41.180
而且, 顺便说一句,

01:41.180 --> 01:43.450
这里也没有我们计算结果时的例子,

01:43.450 --> 01:45.530
因为TypeScript有一个内置的特性,

01:45.530 --> 01:48.400
叫做类型推断｡

01:48.400 --> 01:58.860
这意味着TypeScript在理解某个变量或常量中的类型方面做得很好｡

01:58.860 --> 02:02.300
比如这里, 它知道number1最后总是number类型,

02:02.300 --> 02:08.020
因为你用一个数字初始化它.

02:08.020 --> 02:11.740
这实际上是一个常数, 所以它比这个更具体｡

02:11.740 --> 02:15.350
它标识的类型不是任何数字,

02:15.350 --> 02:17.490
而是数字5｡

02:17.490 --> 02:23.870
因为无论如何, 你都不能给一个常量赋值｡

02:23.870 --> 02:25.840
如果你把它改成一个变量,

02:25.840 --> 02:30.180
如果你用let代替, 那么当然这不会破坏任何东西｡

02:30.180 --> 02:32.940
我们可以在这里使用一个变量, 这可能不是最佳实践,

02:32.940 --> 02:34.540
因为这个值永远不会改变,

02:34.540 --> 02:36.210
但也不是很糟糕｡

02:36.210 --> 02:38.260
但现在如果将鼠标悬停在上面, 我们会看到TypeScript不会说,

02:38.260 --> 02:41.210
好吧, 这必须是一个5｡

02:41.210 --> 02:45.510
但它仍然检测到这里的类型是一个数字｡ 

02:45.510 --> 02:49.260
现在, 我们完全可以自己在这里写这些代码｡ 

02:49.260 --> 02:53.870
我们可以在等号左边的变量名后面加一个冒号,

02:53.870 --> 02:55.590
然后是类型名｡

02:55.590 --> 02:59.470
所以, 基本上和我们在这个函数的参数中做的一样｡

02:59.470 --> 03:04.620
但是, 这是多余的, 实际上也不是一个好的做法｡

03:04.620 --> 03:09.990
因为TypeScript能够从那里完美地推断出这个类型｡

03:09.990 --> 03:13.690
所以, 分配这个不是一个好主意｡ 

03:13.690 --> 03:16.420
仅当您以未赋值方式创建此变量时,

03:16.420 --> 03:18.053
才会发生更改｡

03:19.000 --> 03:22.130
就像这样, 如果不立即初始化它｡ 

03:22.130 --> 03:29.070
然后, 告诉TypeScript哪个值最终将存储在那里是一个很好的做法｡

03:29.070 --> 03:35.320
所以当你给它赋值的时候, 当然这里把它分成两行有点多余｡

03:35.320 --> 03:37.800
我只是做个演示｡ 

03:37.800 --> 03:39.480
但是现在如果我在这里赋值,

03:39.480 --> 03:44.630
它会中断, 因为我事先告诉过TypeScript它的类型是number.

03:44.630 --> 03:45.610
你不必这样做｡ 

03:45.610 --> 03:47.420
如果你不这样做, 它也会起作用｡ 

03:47.420 --> 03:50.330
但是现在你也可以添加这五个变量, 你不会得到错误,

03:50.330 --> 03:55.350
因为你没有告诉TypeScript任何关于存储在这个变量中的类型的信息,

03:55.350 --> 03:59.630
因此TypeScript允许任何类型｡

03:59.630 --> 04:02.600
如果你在这里添加冒号数字, 你就告诉TypeScript,

04:02.600 --> 04:07.370
“嘿, 最终, “一个数字将被存储在那里｡

04:07.370 --> 04:07.370
因此,

04:07.370 --> 04:10.060
如果您稍后在其中存储了其他内容, 例如在本例中存储了一个字符串,

04:10.060 --> 04:12.470
则在IDE中会出现错误, 当然, 如果您编译了代码,

04:12.470 --> 04:15.170
也会出现错误｡

04:15.170 --> 04:17.570
我们将得到前面已经看到的错误｡ 

04:17.570 --> 04:20.253
这就是如何分配类型｡ 

04:22.300 --> 04:24.920
现在, 即使TypeScript只是推断了一个类型,

04:24.920 --> 04:29.310
让我来解决这个问题, 如果你破坏了这个推断的类型, 它也会对你大喊大叫｡

04:29.310 --> 04:32.720
事实上, 即使说它当然会这样做,

04:32.720 --> 04:35.670
它为什么不这样做呢？

04:35.670 --> 04:37.000
类型推断可用于保存代码,

04:37.000 --> 04:39.750
以避免手动分配类型｡

04:39.750 --> 04:42.730
当然, 如果您使用了一个错误的类型, 一个它没有推断的类型,

04:42.730 --> 04:46.510
TypeScript会对您大喊大叫｡

04:46.510 --> 04:48.640
例如, 这里如果resultPhrase是用let创建的,

04:48.640 --> 04:57.670
所以它是变量, 那么这里的TypeScript推断它将是字符串类型, 因为我们用字符串初始化它｡

04:57.670 --> 04:59.850
所以这基本上相当于不初始化它,

04:59.850 --> 05:04.970
自己设置类型, 然后再赋值｡

05:04.970 --> 05:07.410
现在, 如果我们把resultPhrase改成,

05:07.410 --> 05:12.310
比如说, 零, 不管出于什么原因, 我们会得到一个错误,

05:12.310 --> 05:17.330
零类型是字符串类型不可赋值的｡

05:17.330 --> 05:21.210
这就说得通了, 对吧？

05:21.210 --> 05:22.690
TypeScript推断我们想要存储一个字符串,

05:22.690 --> 05:27.290
我们现在尝试存储一个数字, 我们得到一个错误｡

05:27.290 --> 05:28.530
这就是TypeScript的核心任务｡ 

05:28.530 --> 05:35.280
检查类型, 如果我们用错了就对我们大喊大叫｡
