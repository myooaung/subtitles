WEBVTT

00:02.170 --> 00:06.250
-: الآن بجانب الكائنات ، لدينا أيضًا مصفوفات في JavaScript

00:06.250 --> 00:08.300
، نوع مهم جدًا من البيانات.

00:08.300 --> 00:10.810
يتم إنشاء المصفوفات على هذا النحو في JavaScript

00:10.810 --> 00:12.560
، كما تعلم ، ويمكنك تخزين أي بيانات

00:12.560 --> 00:15.970
هناك: أرقام ، سلاسل ، منطقية ، كائنات ، مصفوفات أخرى ، يمكن أن يكون

00:15.970 --> 00:17.970
لديك مصفوفات متداخلة ، بعد كل شيء ، ويمكنك

00:17.970 --> 00:19.380
أيضًا مزج البيانات.

00:19.380 --> 00:23.200
يمكن أن يكون لديك مصفوفة ذات سلاسل وأرقام مختلطة.

00:23.200 --> 00:25.570
ويدعم TypeScript أيضًا المصفوفات.

00:25.570 --> 00:29.260
يتم دعم أي مصفوفة JavaScript ويمكن أن تكون أنواع

00:29.260 --> 00:32.140
هذه المصفوفة مرنة أو صارمة.

00:32.140 --> 00:35.200
الآن دعونا نلقي نظرة على ذلك في TypeScript.

00:35.200 --> 00:38.760
لذلك هنا في التطبيق. ts ، دعنا نقول أن لدى شخصنا

00:38.760 --> 00:42.810
أيضًا مفتاح هوايات ، ولكن بالطبع يمكن أن يكون لدينا أيضًا

00:42.810 --> 00:45.660
هوايات متغيرة أو ثابتة خارج الكائن.

00:45.660 --> 00:49.050
لذلك ، فإن استخدام المصفوفات هو نفسه تمامًا داخل

00:49.050 --> 00:50.853
الكائنات وخارجها.

00:51.950 --> 00:54.780
لذلك لدينا هنا هوايات ، ويمكن أن

00:54.780 --> 00:58.140
تكون الهوايات رياضة ، ولنقل الطبخ.

00:58.140 --> 01:01.150
إذن لدي عنصران هناك ، وهذه العناصر ،

01:01.150 --> 01:03.620
كما يمكنك أن تقول ، هي سلاسل.

01:03.620 --> 01:07.570
الآن إذا قمنا بالتمرير فوق الهوايات ، فقد اكتشف TypeScript

01:07.570 --> 01:10.630
بشكل صحيح مسافة مصفوفة سلسلة النوع.

01:10.630 --> 01:12.500
الآن هذا هو بناء الجملة الذي لم تره من

01:12.500 --> 01:16.140
قبل ، ولكن هذه هي الطريقة التي يصف بها TypeScript مصفوفة من البيانات.

01:16.140 --> 01:18.510
لديك أقواس مربعة ، وأمام ذلك

01:18.510 --> 01:21.340
نوع البيانات المخزنة هناك.

01:21.340 --> 01:23.530
الآن هذا هو النوع ، مجموعة النوع المستنتج.

01:23.530 --> 01:25.810
لقد رأى أن لدينا هنا مصفوفة وأن لدينا

01:25.810 --> 01:29.110
خيوطًا فقط هناك ، لذلك استنتج أن الهوايات ربما

01:29.110 --> 01:31.940
يجب أن تكون مجموعة من الأوتار.

01:31.940 --> 01:34.903
وبالفعل ، بالنسبة للهوايات ، هذا منطقي للغاية.

01:36.210 --> 01:41.040
بالطبع ، يمكنك أيضًا تعيين نوع المتغير بشكل صريح.

01:41.040 --> 01:44.720
إذا أضفنا متغيرًا جديدًا وأنشطة مفضلة وكان

01:45.580 --> 01:48.670
يجب أن يكون فارغًا في البداية ، فقد نرغب

01:48.670 --> 01:51.160
في تعيين نوع البيانات المخزنة

01:51.160 --> 01:53.140
هناك بشكل صريح.

01:53.140 --> 01:55.590
لنفترض الآن أن هذا يجب أن يكون مصفوفة من السلاسل

01:55.590 --> 01:57.570
، حسنًا ، ثم يمكننا تكرار ما رأيناه

01:57.570 --> 02:00.330
للتو ؛ اكتب سلسلة ، ثم أقواس مربعة بعد ذلك ، وهذا

02:00.330 --> 02:03.330
يخبر TypeScript أن ما نخزنه هنا ليس مجرد سلسلة واحدة

02:03.330 --> 02:05.990
، إنه مجموعة من السلاسل.

02:05.990 --> 02:09.550
وبالفعل إذا حاولت تخزين الألعاب الرياضية فقط

02:09.550 --> 02:12.183
هناك ، فسأخطئ. حصلت على خطأ لأن هذا

02:12.183 --> 02:15.650
هو سلسلة واحدة ، وليس مجموعة من السلاسل.

02:15.650 --> 02:19.370
لا أحصل على خطأ ، بالطبع ، إذا قمت بلف هذا إلى أقواس مربعة

02:19.370 --> 02:22.610
وبالتالي قمت بإنشاء مصفوفة بشكل فعال.

02:22.610 --> 02:25.870
ومع ذلك ، فإنني أتلقى خطأ مرة أخرى ، إذا أضفت رقمًا ، دعنا

02:25.870 --> 02:29.220
نقول ، لأننا نعرّف هذا على أنه مجموعة من السلاسل.

02:29.220 --> 02:31.290
الآن ، لدينا مجموعة مختلطة.

02:31.290 --> 02:34.920
إنها مصفوفة من السلاسل والأرقام ، لذا لا

02:34.920 --> 02:37.180
يعمل هذا وغير مدعوم هنا.

02:37.180 --> 02:40.100
إذا أردنا دعم مثل هذه المصفوفة المختلطة

02:40.100 --> 02:43.120
، فإن أحد الحلول هو استخدام "أي" هنا.

02:43.120 --> 02:45.880
النوع "أي" هو نوع خاص في TypeScript ، والذي

02:45.880 --> 02:47.610
سنلقي نظرة فاحصة عليه لاحقًا

02:47.610 --> 02:50.530
، والذي يعني أساسًا ، افعل ما تريد.

02:50.530 --> 02:53.020
إنه بالطبع نوع لا تريد استخدامه كثيرًا لأنك

02:53.020 --> 02:55.630
ستفقد الفوائد التي يوفرها لك TypeScript ، وهو

02:55.630 --> 02:58.170
ظهرك في عالم JavaScript ، حيث يمكنك أيضًا استخدام

02:58.170 --> 03:00.140
أي قيمة في أي مكان.

03:00.140 --> 03:02.940
لذا فإن "أي" مرن حقًا ، لكن المرونة تأتي

03:02.940 --> 03:06.270
على حساب التخلي بشكل أساسي عن جميع المزايا

03:06.270 --> 03:08.710
التي يوفرها TypeScript.

03:08.710 --> 03:10.840
سأعود هنا إلى السلسلة ، لأنني حقًا لا

03:10.840 --> 03:12.530
أريد أن يكون لدي رقم هناك ، وبالتالي

03:12.530 --> 03:14.933
يمكننا حذف الرقم ونحن بخير.

03:15.900 --> 03:18.830
تعطينا المصفوفات أيضًا مثالًا رائعًا ، في

03:18.830 --> 03:21.890
الواقع تمامًا مثل الكائنات وخصائصها ، ومدى

03:21.890 --> 03:25.730
ديناميكية الاستدلال على الكتابة في TypeScript.

03:25.730 --> 03:28.750
إذا أضفنا حلقة "for" هنا في الأسفل ، وأردنا

03:28.750 --> 03:31.570
الذهاب لجميع هوايات الشخص ، يمكننا بالطبع

03:31.570 --> 03:33.220
استخدام حلقة "for" التقليدية

03:33.220 --> 03:38.220
مع هواية الشخص. الهوايات ، حتى الوصول إلى خاصية

03:38.620 --> 03:41.130
الهوايات وممارسة جميع الهوايات

03:41.130 --> 03:42.793
هناك ، وتخزين كل هواية

03:43.690 --> 03:46.780
لكل تكرار في هذا الثابت ، ومن ثم يمكننا

03:46.780 --> 03:50.090
الرجوع إلى سجل هواية هنا.

03:50.090 --> 03:52.000
الآن هذا ليس خياليًا جدًا ، هذا شيء

03:52.000 --> 03:53.710
نعرفه من JavaScript ، صحيح.

03:53.710 --> 03:58.280
إذا قمت الآن بتجميع هذا التطبيق. ts هناك ، نحصل على الاسم

03:58.280 --> 04:01.700
من هذا السطر ، وبعد ذلك تتم طباعة

04:01.700 --> 04:04.750
الهوايات.

04:04.750 --> 04:07.800
ولكن ما هو مثير للاهتمام هنا هو أنه في هواية ، يمكننا

04:07.800 --> 04:11.040
الوصول إلى أي شيء ، يمكننا الوصول إليه بأي سلسلة.

04:11.040 --> 04:14.210
على سبيل المثال ، إلى UpperCase ، أحصل على هذا الإكمال

04:14.210 --> 04:16.230
التلقائي ولا يشكو TypeScript.

04:16.230 --> 04:18.070
لماذا لا تشكو؟

04:18.070 --> 04:21.930
لأنه يعرف أن الهوايات من نوع مصفوفة سلسلة ، لذلك

04:21.930 --> 04:25.830
عندما أصل إلى الشخص. الهوايات ، يكتشف استدلال TypeScript

04:25.830 --> 04:29.700
أن الهوايات ستكون عبارة عن مجموعة من الأوتار.

04:29.700 --> 04:33.450
لذا ، فإن الهواية ، في اليد العليا ، يتم تحديدها بشكل صحيح

04:33.450 --> 04:36.000
على أنها سلسلة ، لأننا نمر عبر مجموعة

04:36.000 --> 04:38.370
من السلاسل ، حسنًا ، يجب أن تكون القيم

04:38.370 --> 04:40.510
الفردية مجرد سلاسل.

04:40.510 --> 04:43.450
وبالتالي ، فإن الأنواع تقدم لنا دعمًا كبيرًا

04:43.450 --> 04:46.490
هناك ، وتسمح لنا بفعل أي شيء بهواية يمكن القيام

04:46.490 --> 04:50.050
بها باستخدام سلسلة ، لأنها تعرف على وجه اليقين أن الهواية

04:50.050 --> 04:53.810
ستكون سلسلة بسبب الأنواع التي أنشأناها هناك.

04:53.810 --> 04:56.300
وهذه ميزة مرنة حقًا ، وبالطبع ميزة رائعة

04:56.300 --> 04:59.030
تجعل كتابة التعليمات البرمجية أسهل كثيرًا

04:59.030 --> 05:01.360
وأكثر مرونة وأمانًا.

05:01.360 --> 05:04.440
على سبيل المثال ، سنحصل على خطأ هنا إذا حاولنا

05:04.440 --> 05:08.570
الوصول إلى هواية. الخريطة ، إذا اعتقدت أن هذا سيكون مصفوفة.

05:08.570 --> 05:12.060
طريقة الخريطة متاحة في المصفوفات ، ولكن ليس على السلاسل.

05:12.060 --> 05:14.540
وهنا ، بشكل صحيح ، مرة أخرى ، خطأ أن الخريطة

05:14.540 --> 05:17.810
غير موجودة في سلسلة النوع لأنها غير موجودة.

05:17.810 --> 05:21.290
إذاً هنا حصلنا على خطأ ، وهذا أمر جيد أننا حصلنا

05:21.290 --> 05:24.510
عليه ، لأن هذا سيكون خطأ ، وهنا نرى استنتاج

05:24.510 --> 05:27.343
TypeScript متألقًا حقًا.
