WEBVTT

00:02.150 --> 00:06.180
講師：これで､ タイトルの入力値を集めてコンソールに表示することができましたが､

00:06.180 --> 00:10.160
もちろん最終的にはそれが目的ではありません｡

00:10.160 --> 00:13.940
その代わり､ 入力値をすべて集め､ 素早く検証し､

00:13.940 --> 00:17.890
その値を使って何かをするという考え方です｡

00:17.890 --> 00:20.598
そのために､ もうひとつ新しいメソッドを追加します｡

00:20.598 --> 00:21.860
クラスの内部からしか呼び出さないので､

00:21.860 --> 00:28.530
もうひとつのプライベートなメソッド､ それがgatherUserInputメソッドです｡

00:28.530 --> 00:30.460
名前は完全におまかせです｡ 

00:30.460 --> 00:33.240
私の考えでは､ このメソッドはここで呼ばれるのだと思います｡ 

00:33.240 --> 00:35.230
デフォルトを防いだ後､ これは基本的にここにあるすべての入力にアクセスし､

00:35.230 --> 00:43.060
ユーザーの入力を収集し､ それを検証して､ それを返す必要があります｡

00:43.060 --> 00:45.950
ここでは､ userInputを取得しました｡

00:45.950 --> 00:53.810
これは､ タイトル､ 説明､ および人々をタプルの値として持つタプルです｡

00:53.810 --> 00:55.510
実は､ このアイデアは気に入っているんです｡ 

00:55.510 --> 00:57.800
そこで､ もうここで戻り値の型を定義してしまいましょう｡ 

00:57.800 --> 00:59.880
戻り値の型はタプルである｡ 

00:59.880 --> 01:02.620
さて､ タプルの定義はどうなっているか覚えていますか？

01:02.620 --> 01:05.630
タプルの型はどのように定義されるのですか？

01:05.630 --> 01:08.620
文字列ではなく､ 角括弧です｡ 

01:08.620 --> 01:12.260
つまり､ 文字列の配列を返すということです｡ 

01:12.260 --> 01:21.510
その代わりに､ これら3つの型のちょうどX個の要素からなる配列を返すと言いたいのです｡

01:21.510 --> 01:23.650
そのために､ ここに2つの角括弧を付けて戻り値の型を設定し､

01:23.650 --> 01:30.240
角括弧の中にさまざまな要素や要素の型を追加します｡

01:30.240 --> 01:32.900
例えば､ 文字列､ 文字列､ 数値など｡ 

01:32.900 --> 01:37.130
つまり､ このメソッドは3つの要素を持つタプルを返すということです｡

01:37.130 --> 01:38.510
1番目の要素は文字列､

01:38.510 --> 01:44.080
2番目の要素は文字列､ 3番目の要素は実際には数値です｡

01:44.080 --> 01:46.360
そして､ このメソッドにロジックを追加して､

01:46.360 --> 01:48.540
それが真になるようにすることができます｡

01:48.540 --> 01:57.210
そのために､ まず､ このtitleInputElementから入力されたタイトルを取得しましょう｡

01:57.210 --> 01:57.210
の値を設定します｡ 

01:57.210 --> 01:58.340
そして､ それを繰り返すことができるのです｡ 

01:58.340 --> 02:05.100
また､ このdescriptionInputElementから､ 入力されたコースの説明文が欲しい｡

02:05.100 --> 02:05.100
値､

02:05.100 --> 02:09.510
および enteredPeople の量､ またはこの peopleInputElement

02:09.510 --> 02:12.440
から enteredPeople のみを取得します｡

02:12.440 --> 02:13.870
これを定数に格納することで､

02:13.870 --> 02:17.640
いつもこの長い式を繰り返す必要がないようにしたのです｡

02:17.640 --> 02:19.370
さて､ これを検証してみましょう｡ 

02:19.370 --> 02:24.850
些細な検証としては､ enteredTitle.

02:24.850 --> 02:24.850
トリム､

02:24.850 --> 02:27.610
つまり､ Xの最初と最後の広いスペースを削除することです｡

02:27.610 --> 02:35.350
Lengthが0である場合､ またはenteredDescriptionが0である場合｡

02:35.350 --> 02:35.350
トリム長が0である場合､

02:35.350 --> 02:41.520
またはenteredPeople.

02:41.520 --> 02:41.520
トリム長はゼロに等しい｡

02:44.380 --> 02:48.410
そうすると､ 入力が空でないことをチェックすることになります｡ 

02:48.410 --> 02:51.860
しかし､ このツールは､ 私たちがチェックしたいことをすべてチェックできるわけではありません｡

02:51.860 --> 02:57.160
入力された人が､ 例えば正の数であるかどうかを確認しているわけではありません｡

02:57.160 --> 03:00.170
最小の長さを設定することができないのです｡ 

03:00.170 --> 03:02.190
ここで条件をどんどん追加していくことになりますが､

03:02.190 --> 03:06.820
これはスケーラブルなソリューションとは言えません｡

03:06.820 --> 03:09.110
もし､ アプリケーションの中でユーザーの入力を検証したい部分があれば､

03:09.110 --> 03:14.440
いつも長いif文を繰り返さなければなりません｡

03:14.440 --> 03:21.960
そこで､ よりスマートな検証ソリューション､ あるいはよりスケーラブルな検証ソリューションを近いうちに考え出すつもりです｡

03:21.960 --> 03:23.780
とりあえず､ このままでいい｡ 

03:23.780 --> 03:26.190
もちろん､ このレクチャーの後､

03:26.190 --> 03:32.220
一時停止して､ これを設定可能な別の検証関数にアウトソースする方法と､

03:32.220 --> 03:38.350
そこでタイプがどのように役立つかについて考えることができます｡

03:38.350 --> 03:41.370
確かにいろいろなアプローチが考えられますが､

03:41.370 --> 03:44.040
私の場合は次回の講義で紹介します｡

03:44.040 --> 03:45.620
しかし､ その前に､ ここでは実際にこの些細なアプローチを使って､

03:45.620 --> 03:52.130
これらの条件がすべて満たされた場合に何かをすることにしましょう｡

03:52.130 --> 03:53.620
さて､ このifブロックにすると､

03:53.620 --> 03:57.350
少なくとも1つのバリデーションが失敗したことがわかります｡ そして､

03:57.350 --> 04:01.833
アラートで「無効な入力です､ もう一度試してください」と表示できます｡

04:03.450 --> 04:06.200
そうでなければ､

04:06.200 --> 04:11.310
タプルを返します｡

04:11.310 --> 04:14.170
そこで､ ここでは､ 入力されたタイトル､

04:14.170 --> 04:19.660
入力された説明､ そして入力された人を返したいと思います｡

04:19.660 --> 04:20.630
しかし､ お分かりのように､

04:20.630 --> 04:21.850
タイプグループには不満があります｡

04:21.850 --> 04:25.370
なぜなら､ 入力された人はテキストではなく数字であるべきだからです｡

04:25.370 --> 04:28.720
そして実は､ input要素のvalueプロパティから抽出したものは､

04:28.720 --> 04:32.350
デフォルトですべてテキストになります｡

04:32.350 --> 04:34.520
これを数値に変換するには､

04:34.520 --> 04:38.060
たとえばparseFloatを呼び出すか､

04:38.060 --> 04:42.850
あるいは単純に前にプラスを付ければ､ 数値に変換されます｡

04:42.850 --> 04:48.910
それでもタイプグループは満足しません｡

04:48.910 --> 04:50.830
この部分はどうでしょうか？

04:50.830 --> 04:53.510
ifブロックに入ると､ アラートが表示されますが､

04:53.510 --> 04:55.820
タプルを返すわけではありません｡

04:55.820 --> 04:59.810
まあ､ 代わりにできることはいろいろあるんですけどね｡ 

04:59.810 --> 05:03.460
このように何も返さなければいいのです｡ 

05:03.460 --> 05:06.320
あるいは､ エラーを投げることもできる｡ 

05:06.320 --> 05:08.360
そうすると､ 実際には何も返さないことになるのですが､

05:08.360 --> 05:11.100
その場合はエラーを投げることにします｡

05:11.100 --> 05:12.820
さて､ ここでエラーを出したくないのは､

05:12.820 --> 05:15.570
エラー処理を実装したくないからです｡ そこで､

05:15.570 --> 05:20.100
returnステートメントを追加します｡

05:20.100 --> 05:23.110
つまり､ ここでの戻り値の型はタプルであり､

05:23.110 --> 05:25.923
実際には未定義なのです｡

05:27.320 --> 05:32.550
しかし､ ここで学んだように､ 関数の戻り値の型としてundefinedを使うべきではありません｡

05:32.550 --> 05:34.040
代わりにvoidを使用します｡ 

05:34.040 --> 05:35.410
これはほとんど同じだが､

05:35.410 --> 05:46.930
関数専用で､ この関数のように値を返さない分岐を少なくとも持っている関数であることをTypeScriptに伝えるものだ｡

05:46.930 --> 05:51.240
ここでは､ 両方の可能性があるため､ もちろんユニオン型も使用します｡

05:51.240 --> 05:53.170
何も返さないかもしれないし､

05:53.170 --> 05:55.660
実際にタプルを返すかもしれない｡

05:55.660 --> 06:01.670
つまり､ 今､ 私たちはgatherUserInputとuserInputを持っているすべてのためにそこに最終的に未定義であるか､

06:01.670 --> 06:04.130
それはそのタプルのいずれかです｡

06:04.130 --> 06:09.620
では､ 次にバリデーションを改善する前に､ そのuserInputの上に構築してみましょう｡

06:09.620 --> 06:12.480
userInputを下に集めると､ userInputというものができ､

06:12.480 --> 06:17.050
それがタプルであるかどうかをチェックすることができます｡

06:17.050 --> 06:22.620
さて､ 問題は実行時に､ それがタプルであるかどうかを確認する方法がないことです｡

06:22.620 --> 06:25.200
使えるinstanceofがない｡ 

06:25.200 --> 06:28.560
確認できるTuple型がない｡ 

06:28.560 --> 06:31.020
また､ typof userInputがtupleに等しいかどうかも､

06:33.803 --> 06:36.053
Vanilla JavaScriptには存在しないので､

06:37.130 --> 06:40.050
確認することができない｡

06:40.050 --> 06:41.850
例えばStringは存在しますが､

06:41.850 --> 06:44.950
TupleはJavaScriptの型ではありません｡

06:44.950 --> 06:47.020
だから､ タプルかどうかをチェックするためには､

06:47.020 --> 06:50.990
最終的にタプルは消去されるだけだと覚えておく必要がある｡

06:50.990 --> 06:52.750
TypeScriptでは特別なものですが､

06:52.750 --> 07:04.470
JavaScriptの世界に入ると､ 要素の数と型が固定されたタプルという考え方はTypeScriptにしか存在しないので､ 消去されることになります｡

07:04.470 --> 07:05.930
つまり､ 実行時にここで確認する必要があるのは､

07:05.930 --> 07:09.370
配列であるかどうかということです｡ そのためには､ JavaScriptで配列オブジェクトを使用し､

07:09.370 --> 07:15.180
そこにisArrayメソッドを使用すればいいのです｡

07:15.180 --> 07:17.500
これはVanilla JavaScriptに組み込まれているメソッドで､

07:17.500 --> 07:20.290
ここが配列であるかどうかをチェックすることができます｡

07:20.290 --> 07:23.200
未定義かタプルのどちらかであることは分かっています｡ 

07:23.200 --> 07:27.400
タプルは配列なので､ これが真を返せばタプルを得たことになる｡

07:27.400 --> 07:31.010
そして､ ここでは､ 例えば､ 構造化を使って､ ユーザー入力からタイトル､

07:31.010 --> 07:37.720
説明､ 人を取り出し､ その入力に対して何かを行うことができます｡

07:37.720 --> 07:39.230
例えば......今のところ､

07:39.230 --> 07:42.623
コンソール｡ ログタイトル､ 説明､ 人々｡ 

07:43.980 --> 07:47.950
これをすべて実行して保存すると､ 何のエラーもなくコンパイルされます｡

07:47.950 --> 07:53.050
ここに戻って､ このようにプロジェクトをクリックすると､ 無効な入力が表示されます｡

07:53.050 --> 07:54.580
Helloを入力しても､

07:54.580 --> 07:56.950
説明がないので､ まだ取得できません｡

07:56.950 --> 07:58.890
これは説明文です｡ 

07:58.890 --> 08:00.180
我々はまだもちろんそれを得るが､

08:00.180 --> 08:02.940
私は今､ 人々にも何かを入力すると､ これは動作し､

08:02.940 --> 08:05.220
我々はここでこれを印刷します｡

08:05.220 --> 08:09.330
今はもちろん､ いい方向に進んでいます｡ 

08:09.330 --> 08:10.990
まだ完全にそうなっているわけではありません｡ 

08:10.990 --> 08:13.330
先ほども言いましたが､ 私たちはバリデーションを改善することができます｡ 

08:13.330 --> 08:16.230
その前に1つだけ､ ADD PROJECTをクリックした後､

08:16.230 --> 08:20.070
すべての入力をクリアする必要があります｡

08:20.070 --> 08:22.440
そこで､ もう一度､ すべての入力を空にしたいのです｡ 

08:22.440 --> 08:25.290
そのために､ 新しいプライベート・メソッド､ clearInput または clearInputs

08:25.290 --> 08:27.043
を追加して､ そこで､ この titleInputElement

08:28.210 --> 08:32.740
を設定することができます｡ の値を空文字列とし､

08:32.740 --> 08:38.980
他の入力に対しても同様に繰り返す｡

08:38.980 --> 08:41.960
ここにdescriptionInputElementがあり､

08:41.960 --> 08:48.190
ここにpeopleInputElementがあります｡

08:48.190 --> 08:48.190
clearInputs

08:48.190 --> 08:51.730
ここで､ フォームが送信されたらクリアされるようにする必要があります｡

08:51.730 --> 08:54.380
そこでもう一度､ ここに何かを入力してみると､

08:54.380 --> 08:57.740
ここに印刷され､ フォームがクリアされるのがわかります｡

08:57.740 --> 09:00.720
これで､ この処理方法には概ね満足していますが､

09:00.720 --> 09:06.970
今後は検証を改善し､ より再利用可能でスケーラブルな方法でこれを書きたいと思います｡

09:06.970 --> 09:07.840
先ほども言いましたが､

09:07.840 --> 09:10.320
まずは絶対に自分で自由にやってください｡

09:10.320 --> 09:12.580
次回の講義では､ 一緒にやってみましょう｡
