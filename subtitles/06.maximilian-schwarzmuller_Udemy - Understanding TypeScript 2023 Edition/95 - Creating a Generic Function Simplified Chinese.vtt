WEBVTT

00:02.190 --> 00:04.480
现在开始使用我们自己的泛型｡ 

00:04.480 --> 00:06.820
下面是注释掉的代码｡ 

00:06.820 --> 00:09.210
我将从一个泛型函数开始｡ 

00:09.210 --> 00:11.430
你可以构建泛型类和函数,

00:11.430 --> 00:15.350
我将展示这两种, 这里我将从函数开始｡

00:15.350 --> 00:17.490
现在让我们假设我们想要一个函数,

00:17.490 --> 00:22.490
它基本上合并两个对象, 并返回一个新对象｡

00:23.660 --> 00:25.380
所以在这里我们可以将其命名为“合并”｡ 

00:25.380 --> 00:28.803
我们想把对象A和对象B作为输入｡ 

00:30.010 --> 00:33.990
当然我们可以用某种方式来写这个函数｡ 

00:33.990 --> 00:36.660
我们可以说这是对象类型,

00:36.660 --> 00:39.033
这是对象类型.

00:39.960 --> 00:41.760
这个函数的作用是,

00:41.760 --> 00:45.200
返回对象赋值的结果.

00:45.200 --> 00:48.130
在这里我得到了对象A和对象B｡ 

00:48.130 --> 00:53.000
当然, 由于我们已经将对象赋值方法内置到了普通的javascript中｡

00:53.000 --> 00:55.820
我们可能会争论是否真的需要一个合并函数, 但当然,

00:55.820 --> 00:58.140
您可能会在这里做额外的工作｡

00:58.140 --> 01:00.480
你可以用额外的信息和额外的选项来丰富它,

01:00.480 --> 01:01.833
最后这只是一个演示,

01:01.833 --> 01:04.730
只是一个例子｡

01:04.730 --> 01:07.510
所以这是有效的, 我们可以在这里调用merge,

01:07.510 --> 01:11.830
控制台记录它的结果, 就像这样｡

01:11.830 --> 01:15.130
然后传入一个有名称键的对象和另一个有年龄的对象,

01:15.130 --> 01:20.010
如果我们运行并保存它｡

01:20.010 --> 01:22.780
在浏览器中, 我们确实得到了这个输出｡ 

01:22.780 --> 01:24.280
我们得到了这个合并对象｡ 

01:24.280 --> 01:27.050
现在这个方法可以用了,

01:27.050 --> 01:33.300
问题是如果我们尝试存储这个合并名称max和age

01:33.300 --> 01:38.097
30｡

01:39.620 --> 01:44.620
如果我们尝试将其存储在这里, 我无法访问结果中的姓名,

01:45.770 --> 01:50.020
也无法访问合并对象中结果的年龄｡

01:50.020 --> 01:52.360
即使我们知道两者都将存在｡ 

01:52.360 --> 01:54.830
因为typescript不知道这一点｡ 

01:54.830 --> 01:57.100
打字稿不能知道这一点｡ 

01:57.100 --> 01:59.310
因为我们只是告诉它, 你得到了一个对象,

01:59.310 --> 02:02.370
最后, 我们首先返回一个对象｡

02:02.370 --> 02:07.810
这是正确的, 但它并没有携带我们在这里可以使用的所有信息｡

02:07.810 --> 02:12.080
当然, 我们总是可以进行类型转换, 我们可以告诉typescript,

02:12.080 --> 02:14.220
我们得到的是一个对象, 其中有一个名称键,

02:14.220 --> 02:15.960
还有一个年龄键｡

02:15.960 --> 02:19.020
但如果我们必须这么做, 那就太麻烦了｡ 

02:19.020 --> 02:21.420
因此, 泛型可以帮助我们｡ 

02:21.420 --> 02:26.470
我们通过在函数名后面添加这些尖括号将其转换为一个泛型函数｡

02:26.470 --> 02:29.740
然后我们定义Q标识符｡ 

02:29.740 --> 02:33.190
通常以T开头, 表示类型｡ 

02:33.190 --> 02:35.600
但是你可以在这里使用任何标识符,

02:35.600 --> 02:37.730
不一定是一个字符, 但约定是使用一个字符,

02:37.730 --> 02:39.860
通常, 如果你只有一个泛型类型,

02:39.860 --> 02:43.690
你就把它命名为T.

02:43.690 --> 02:48.510
然后你说, 这里的泛型类型, 现在在这个函数里面是可用的｡

02:48.510 --> 02:51.453
所以我们可以说这里得到的是T型｡ 

02:53.090 --> 02:55.740
看起来怪怪的, 我们到那里就不用担心了｡ 

02:55.740 --> 02:57.280
现在我们得到了两个参数,

02:57.280 --> 02:59.570
我们不知道它们的确切样子｡

02:59.570 --> 03:02.450
因此, 我将在这里接受第二个泛型类型｡ 

03:02.450 --> 03:04.340
只要在尖括号里加一个逗号,

03:04.340 --> 03:07.400
然后我们继续按字母顺序排列.

03:07.400 --> 03:15.490
因此, 在函数中使用的第二个泛型参数或类型通常命名为U｡

03:15.630 --> 03:18.560
所以我们可以说这是U型｡ 

03:18.560 --> 03:22.100
好吧, 现在我们得到什么？

03:22.100 --> 03:25.450
实际上很多, 就像你看到的, 如果你把鼠标悬停在merge上,

03:25.450 --> 03:33.230
typescript会推断这个函数返回T和U的交集｡

03:33.230 --> 03:38.040
当然我们也可以这样显式地设置, 但我们甚至不需要这样做,

03:38.040 --> 03:42.010
因为对象赋值返回了一个交集, 因此, 因为我们返回了对象赋值的结果,

03:42.010 --> 03:48.390
typescript自动理解这个函数返回了交集｡

03:48.390 --> 03:50.320
那么这有什么帮助呢？

03:50.320 --> 03:52.510
如果我们现在把鼠标悬停在合并对象上,

03:52.510 --> 03:59.230
我们会看到, 现在有了这个单独的类型脚本, 它就知道我们存储在合并对象中的是这两个对象类型的交集,

03:59.230 --> 04:01.690
因为它看到我们正在传入这些对象,

04:01.690 --> 04:06.100
它们是它推断的对象类型｡

04:06.100 --> 04:08.840
姓名字符串和年龄编号｡ 

04:08.840 --> 04:11.590
我们的函数返回交集｡ 

04:11.590 --> 04:13.630
为什么它现在能够推断出这一点,

04:13.630 --> 04:16.313
而不是用我们以前拥有的对象？

04:17.220 --> 04:19.560
因为对象是高度非特定类型｡ 

04:19.560 --> 04:26.600
我们说任何对象, 是的, 因此typescript能够推断我们返回对象和对象的交集｡

04:26.600 --> 04:29.570
但是两个未知对象的交集只是一个新的未知对象,

04:29.570 --> 04:35.420
它不提供任何额外的类型信息给typescript｡

04:35.420 --> 04:38.170
对于泛型类型, 我们告诉typescript的是,

04:38.170 --> 04:55.250
这两个参数可以而且经常是不同的类型, 因此typescript能够理解我们不仅仅是在处理一些随机的对象类型, 而且我们将在这里得到不同类型的数据｡

04:55.250 --> 04:59.770
并且该函数将返回该数据的交集｡

04:59.770 --> 05:07.910
因此typescript能够理解我们在合并对象中存储的是这两个输入的数据的交集｡

05:07.910 --> 05:09.530
因为现在我们不仅仅是在处理一些未知的对象,

05:09.530 --> 05:14.423
而是处理非常特殊的类型｡

05:15.330 --> 05:20.150
因此, 现在如果我控制台日志合并对象年龄在这里, 这工作没有错误,

05:20.150 --> 05:22.980
你可以告诉｡

05:22.980 --> 05:26.770
这里我打印了30个, 因为是泛型类型｡ 

05:26.770 --> 05:29.040
我们给了typescript额外的信息,

05:29.040 --> 05:31.950
我们不知道确切的类型, 我们可以确定,

05:31.950 --> 05:34.780
这里会有对象｡

05:34.780 --> 05:36.550
但是我们不知道它是一个有名字键,

05:36.550 --> 05:38.640
年龄键, 爱好键的对象｡

05:38.640 --> 05:41.130
我们不知道也不关心, 我们不关心这里的确切对象,

05:41.130 --> 05:46.050
我们不想指定它必须是这种类型的.

05:46.050 --> 05:47.490
因为突然之间如果我在里面加上爱好,

05:47.490 --> 05:50.520
我们就有问题了｡

05:50.520 --> 05:52.540
所以我不想限制太多｡ 

05:52.540 --> 05:54.480
我只想说, 这是任何类型, 我不关心,

05:54.480 --> 05:58.590
但它最有可能是一个不同的类型, 然后在这里的一个｡

05:58.590 --> 06:00.860
如果是一样的, 那也很好｡ 

06:00.860 --> 06:06.530
但是typescript理解我们在这里确实有这两个参数的特定类型,

06:06.530 --> 06:08.800
并且我们返回它们的交集｡

06:08.800 --> 06:12.660
而不是这里只有任何不特定的对象｡ 

06:12.660 --> 06:18.410
这里的神奇之处不仅仅在于我们告诉typescript这里有两种不同的类型｡

06:18.410 --> 06:22.870
但是这些类型在我们定义这个函数时并不是一成不变的,

06:22.870 --> 06:25.810
而是在我们调用函数时动态设置的｡

06:25.810 --> 06:30.560
这里我们调用函数, typescript推断两个参数的类型｡

06:30.560 --> 06:39.600
对于T, 它基本上用一个对象填充一个对象类型, 该对象具有一个保存字符串的name属性和一个保存字符串数组的habbits属性｡

06:39.600 --> 06:43.290
对于U, 它用age属性填充type对象的类型,

06:43.290 --> 06:47.990
其中age是number类型｡

06:47.990 --> 06:51.030
当我们在另一行调用这个函数时,

06:51.030 --> 06:57.090
我们传入了不同的对象, 我用一个新的名字把它存储在一个新的常量里,

06:57.090 --> 07:03.130
当然, 在这个函数调用中, T和U的类型是不同的.

07:03.130 --> 07:05.350
您也可以在调用typescript时,

07:05.350 --> 07:11.320
通过在函数名后面添加尖括号, 明确告诉typescript它应该填充哪些类型,

07:11.320 --> 07:15.200
然后您将为T和U填充自己的类型｡

07:15.200 --> 07:18.030
我们可以告诉typescript, 对于这个函数调用,

07:18.030 --> 07:20.180
T应该是字符串类型, U应该是数字类型,

07:20.180 --> 07:25.940
但是当然typescript会抱怨我们在这里传递的具体值｡

07:25.940 --> 07:28.270
因为这显然不是一个字符串,

07:28.270 --> 07:32.280
如果我们修复它, 它显然不是数字类型｡

07:32.280 --> 07:34.650
这里我们可以非常具体地说,

07:34.650 --> 07:38.620
第一个参数, 或者说, 对于这个函数调用来说, 确切地说,

07:38.620 --> 07:41.700
类型T, 是一个对象类型, 我们有一个字符串类型的name属性,

07:41.700 --> 07:48.850
和一个字符串数组类型的habbits属性｡

07:48.850 --> 07:52.970
U的具体类型, 对于这个函数调用, 将是一个对象,

07:52.970 --> 07:57.320
其中我们有一个年龄属性, 它应该是数字类型｡

07:57.320 --> 08:00.220
现在我们会很好, 不再有错误,

08:00.220 --> 08:02.730
这会起作用｡

08:02.730 --> 08:05.060
但这是多余的, 你完全可以这么做,

08:05.060 --> 08:15.170
重要的是要明白, 这就是泛型的本质, 你可以为不同的函数调用填充不同的具体类型｡

08:15.170 --> 08:16.930
但是我们不需要在这里这样做,

08:16.930 --> 08:22.170
因为typescript只是推断我们在这里作为参数传递的值的类型｡

08:22.170 --> 08:28.240
然后将此函数调用的T和U的推断类型放入｡

08:28.240 --> 08:31.283
这就是泛型最终在幕后的工作方式｡ 
