WEBVTT

00:02.190 --> 00:04.480
そこで､ 独自のジェネリックを開始する｡ 

00:04.480 --> 00:06.820
以下は､ コメントアウトしたコードです｡ 

00:06.820 --> 00:09.210
まずは汎用的な機能からご紹介します｡ 

00:09.210 --> 00:11.430
一般的なクラスと関数を作ることができますが､

00:11.430 --> 00:15.350
ここではその両方を紹介します｡

00:15.350 --> 00:22.490
さて､ 基本的に2つのオブジェクトをマージして新しいオブジェクトを返す関数が必要だとします｡

00:23.660 --> 00:25.380
そこで､ ここでは「マージ」と名付けることができます｡ 

00:25.380 --> 00:28.803
そして､ オブジェクトAとオブジェクトBを入力として取得したい｡ 

00:30.010 --> 00:33.990
さて､ もちろんこの関数はある方法で書くことができます｡ 

00:33.990 --> 00:39.033
これはobject型で､ これはobject型と言うことができる｡

00:39.960 --> 00:41.760
そして､ この関数が行うことは､

00:41.760 --> 00:45.200
オブジェクトの割り当ての結果を返すことです｡

00:45.200 --> 00:48.130
オブジェクトAとオブジェクトBを取得するところ｡ 

00:48.130 --> 00:53.000
もちろん､ このオブジェクトの割り当て方法は､ 通常のJavaScriptにすでに組み込まれているわけですが｡

00:53.000 --> 00:55.820
マージ機能が本当に必要かどうか議論することもできますが､ もちろん､

00:55.820 --> 00:58.140
ここで追加の作業をすることもできます｡

00:58.140 --> 01:01.833
これはあくまでもデモであり､

01:01.833 --> 01:04.730
一例です｡

01:04.730 --> 01:07.510
つまり､ ここでmergeを呼び出して､

01:07.510 --> 01:11.830
その結果をコンソールログに記録することができるのです｡

01:11.830 --> 01:15.130
そして､ 名前のキーを持つオブジェクトと､

01:15.130 --> 01:20.010
年齢を持つ2番目のオブジェクトを渡します｡

01:20.010 --> 01:22.780
ここでは､ ブラウザで実際にこのような出力が得られます｡ 

01:22.780 --> 01:24.280
そこで､ このマージ・オブジェクトを取得します｡ 

01:24.280 --> 01:27.050
さて､ これでうまくいきました｡

01:27.050 --> 01:38.097
問題は､ このマージ名maxと年齢30を保存しようとした場合です｡

01:39.620 --> 01:44.620
これをここに保存しようとすると､ このマージされたオブジェクトの結果に対して､ 名前にアクセスすることができませんし､

01:45.770 --> 01:50.020
年齢にもアクセスできません｡

01:50.020 --> 01:52.360
どちらも存在することになるとわかっていても

01:52.360 --> 01:54.830
なぜなら､ typescriptはこれを知らないからです｡ 

01:54.830 --> 01:57.100
Typescriptはこれを知ることができない｡ 

01:57.100 --> 01:59.310
なぜなら､ オブジェクトを取得することを伝えているだけで､

01:59.310 --> 02:02.370
最終的にはオブジェクトを返すことを最初にタイプインしているからです｡

02:02.370 --> 02:07.810
これは正しいのですが､ ここで使えるすべての情報が載っているわけではありません｡

02:07.810 --> 02:09.970
もちろん､ typescriptに型キャストして､

02:09.970 --> 02:15.960
nameとageのキーを持つオブジェクトを返すように指示することは可能です｡

02:15.960 --> 02:19.020
でも､ そんなことをやっていたら本当に面倒です｡ 

02:19.020 --> 02:21.420
ここで､ ジェネリックが役に立つわけです｡ 

02:21.420 --> 02:23.750
関数名の後に角括弧をつけると､

02:23.750 --> 02:26.470
汎用関数になります｡

02:26.470 --> 02:29.740
そして､ Q識別子を定義します｡ 

02:29.740 --> 02:33.190
一般的には､ タイプを表すTから始めます｡ 

02:33.190 --> 02:35.600
しかし､ ここではどんな識別子でも使うことができます｡

02:35.600 --> 02:43.690
1文字である必要はありませんが､ 慣例として1文字を使うことになっています｡

02:43.690 --> 02:48.510
そして､ このジェネリックタイプは､ この関数の中で利用できるようになりましたと言うわけです｡

02:48.510 --> 02:51.453
だから､ ここで得られるものはT型と言える｡ 

02:53.090 --> 02:55.740
不思議な感じですね､ 心配なく行けます｡ 

02:55.740 --> 02:59.570
さて､ ここで､ どのように見えるか正確にはわからない2つの論点を得ました｡

02:59.570 --> 03:02.450
そこで､ ここでは2つ目のジェネリックタイプを受け入れることにします｡ 

03:02.450 --> 03:04.340
角括弧の中にカンマを入れるだけで､

03:04.340 --> 03:07.400
あとはアルファベットを続けるだけです｡

03:07.400 --> 03:10.490
そのため､ 関数内で使用する2つ目の汎用パラメータや型は､

03:10.490 --> 03:15.490
通常Uという名前になります｡

03:15.630 --> 03:18.560
だから､ これはタイプUと言える｡ 

03:18.560 --> 03:22.100
さて､ これでどうでしょう？

03:22.100 --> 03:25.450
このように､ mergeにカーソルを合わせると､

03:25.450 --> 03:33.230
typescriptはこの関数がTとUの交差点を返すと推論します｡

03:33.230 --> 03:38.040
もちろん､ このように明示的に設定することもできますが､ その必要はありません｡

03:38.040 --> 03:42.010
なぜなら､ オブジェクトの代入は交差点を返すからで､ オブジェクトの代入の結果を返したので､

03:42.010 --> 03:48.390
typescriptは自動的にこの関数が交差点を返すと理解します｡

03:48.390 --> 03:50.320
では､ どのように役立つのでしょうか？

03:50.320 --> 03:54.260
さて､ merged objectにカーソルを合わせてみると､

03:54.260 --> 03:56.450
typescriptはmerged

03:56.450 --> 04:06.100
objectに格納するものがこれら2つのオブジェクトタイプの交差点であると理解していることがわかります｡

04:06.100 --> 04:08.840
名前の文字列と年齢番号｡ 

04:08.840 --> 04:11.590
そして､ この関数が交差点を返すということです｡ 

04:11.590 --> 04:13.630
なぜ､ 今まで持っていたオブジェクトではなく､

04:13.630 --> 04:16.313
今､ それを推論することができるのでしょうか？

04:17.220 --> 04:19.560
オブジェクトは不特定多数の人が使うものだからです｡ 

04:19.560 --> 04:22.490
オブジェクトとオブジェクトの交差点を返すと､

04:22.490 --> 04:26.600
typescriptは推論することができるのです｡

04:26.600 --> 04:29.570
しかし､ 2つの未知オブジェクトの交点は､ 単なる新しい未知オブジェクトであり､

04:29.570 --> 04:35.420
typescriptに追加の型情報を提供するものではありません｡

04:35.420 --> 04:38.170
ジェネリック型を使用すると､

04:38.170 --> 04:47.100
typescriptに､ これら2つのパラメータは異なる型である可能性があり､ 多くの場合､

04:47.100 --> 04:55.250
異なる型のデータを取得することを理解させることができます｡

04:55.250 --> 04:56.940
そして､ この関数全体では､

04:56.940 --> 04:59.770
そのデータの交点を返すと｡

04:59.770 --> 05:01.773
そのため､ typescriptは､ このマージされたオブジェクトに格納されているものが､

05:01.773 --> 05:07.910
これら2つの入力のデータを交差させたものであると理解することができるのです｡

05:07.910 --> 05:09.530
なぜなら､ 今は未知の物体ではなく､

05:09.530 --> 05:14.423
非常に特殊なものを扱っているからです｡

05:15.330 --> 05:22.980
このため､ マージされたオブジェクトの年齢をコンソールログに記録すると､ このようにエラーなしで動作するようになります｡

05:22.980 --> 05:26.770
ここでは汎用タイプのため､ 30を印刷しています｡ 

05:26.770 --> 05:29.040
私たちはtypescriptに､ 型が正確にはわからないが､

05:29.040 --> 05:34.780
ここにオブジェクトがあることを伝えることができるという余分な情報を与えています｡

05:34.780 --> 05:36.550
しかし､ そのオブジェクトが名前キー､ 年齢キー､

05:36.550 --> 05:38.640
趣味キーを持つかどうかはわからない｡

05:38.640 --> 05:41.130
私たちは知らないし､ 気にしない､ ここにある正確なオブジェクトは気にしない､

05:41.130 --> 05:46.050
これはこのタイプでなければならないと指定することはない｡

05:46.050 --> 05:50.520
だって､ そこに突然趣味を入れたら大変なことになるじゃないですか｡

05:50.520 --> 05:52.540
だから､ そこまで制限をかけたくないんです｡ 

05:52.540 --> 05:54.480
私は､ これがどのようなタイプであっても気にしませんが､

05:54.480 --> 05:58.590
その最も可能性の高い､ この1つの別のタイプであると言いたいのです｡

05:58.590 --> 06:00.860
そして､ もし同じになるのであれば､ それもまた良し｡ 

06:00.860 --> 06:03.030
しかしtypescriptは､ この2つのパラメータに特定の型があること､

06:03.030 --> 06:08.800
そしてそれらの交点を返すことを理解しています｡

06:08.800 --> 06:12.660
ここに任意の不特定多数のオブジェクトを置くのではなく

06:12.660 --> 06:18.410
ここで特に重要なのは､ typescriptに2つの異なる型があることを伝えるだけではないことです｡

06:18.410 --> 06:20.740
しかし､ これらの型は､ この関数を定義したときに決まっているのではなく､

06:20.740 --> 06:25.810
関数を呼び出すときに動的に設定されるということです｡

06:25.810 --> 06:27.430
つまり､ ここでは関数を呼び出して､

06:27.430 --> 06:30.560
typescriptが2つの引数の型を推測しているのです｡

06:30.560 --> 06:33.890
Tの場合､ 基本的には､ 文字列を保持するnameプロパティと､

06:33.890 --> 06:39.600
文字列の配列を保持するhobbiesプロパティを持つオブジェクトをオブジェクトタイプに記入する｡

06:39.600 --> 06:47.990
また､ Uの場合は､ ageプロパティを持つオブジェクトの型（ageは数値型）を記入する｡

06:47.990 --> 06:51.030
さて､ この関数を別の行でもう一度呼び出して､

06:51.030 --> 06:53.890
異なるオブジェクトを渡し､ これを新しい名前の定数に格納すると､

06:53.890 --> 07:03.130
当然ながら､ この関数呼び出しに対して､ TとUに異なる型が記入されることになります｡

07:03.130 --> 07:05.350
また､ typescriptを呼び出す際に､

07:05.350 --> 07:07.780
関数名の後に角括弧を付けることで､

07:07.780 --> 07:11.320
どの型を埋めるべきかを具体的に指示することができ､

07:11.320 --> 07:15.200
TとUに独自の型を埋めることになる｡

07:15.200 --> 07:20.180
この関数呼び出しではTは文字列型であるべきで､ Uは数値型であるべきだとtypescriptに伝えることができますが､

07:20.180 --> 07:25.940
そうすると当然typescriptはここで渡している具体的な値について文句を言うでしょう｡

07:25.940 --> 07:28.270
なぜなら､ これは明らかに文字列ではなく､ もしこれを修正するならば､

07:28.270 --> 07:32.280
これは明らかに数値型ではなくなってしまうからです｡

07:32.280 --> 07:34.650
つまり､ この関数呼び出しの最初の引数､

07:34.650 --> 07:48.850
正確には型Tは､ 名前プロパティ（文字列型）と趣味プロパティ（文字列配列型）を持つオブジェクト型であると言うことができます｡

07:48.850 --> 07:52.970
そして､ Uの具体的な型は､ この関数呼び出しのためのオブジェクトになり､

07:52.970 --> 07:57.320
ageプロパティは数値型でなければなりません｡

07:57.320 --> 08:00.220
そして､ これでもうエラーもなく､

08:00.220 --> 08:02.730
うまくいくはずです｡

08:02.730 --> 08:05.060
しかし､ これは冗長で､ 絶対にそうすることができます｡

08:05.060 --> 08:15.170
そして､ これが結局､ 異なる関数呼び出しに対して異なる具象型を記入することができるというジェネリックのすべてであることを理解することが重要です｡

08:15.170 --> 08:20.110
しかし､ typescriptはここで引数として渡している値の型を単に推測するだけなので､

08:20.110 --> 08:22.170
ここでそれをする必要はない｡

08:22.170 --> 08:25.120
そして､ この関数呼び出しに対して､

08:25.120 --> 08:28.240
TとUの推論された型を配置する｡

08:28.240 --> 08:31.283
結局､ ジェネリックの裏側はそういうことなんです｡ 
