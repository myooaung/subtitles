WEBVTT

00:02.220 --> 00:04.550
- ：我说的是一个装饰器, 我们可以添加它来自动绑定“this”关键字,

00:04.550 --> 00:09.930
这样我们就不必在这里调用bind了｡

00:09.930 --> 00:14.160
很明显, 如果没有什么问题的话, 在这里调用bind并不是一件大事,

00:14.160 --> 00:16.460
但是我们还想实践我们学到的东西,

00:16.460 --> 00:24.970
如果我们必须在应用的很多地方这样做, 那么我们可以添加一个装饰器, 实际上可能会更容易｡

00:24.970 --> 00:27.100
所以, 让我们摆脱束缚｡ 

00:27.100 --> 00:30.010
相反, 在这个类的上面, 我会添加自动绑定装饰器,

00:30.010 --> 00:34.920
我只是在这里添加一些注释来保持这个文件的组织,

00:34.920 --> 00:38.750
至少是一点组织｡

00:38.750 --> 00:44.790
那么, 什么是装饰器呢？

00:44.790 --> 00:46.770
装饰师是一种功能, 对吧？

00:46.770 --> 00:51.383
你可以用这里的函数修饰或者函数表达式来找到它｡

00:52.490 --> 00:54.780
所以, 在这里我将使用一个函数装饰,

00:54.780 --> 00:57.780
并将其命名为autobind, 名称由您决定｡

00:57.780 --> 01:03.173
这个装饰器将接收目标的自由参数, 它绑定到的方法名,

01:04.430 --> 01:09.083
因为我将在这里创建一个方法装饰器｡

01:09.980 --> 01:15.720
以及该方法的描述符｡

01:15.720 --> 01:18.370
属性描述符因为方法最终只是属性,

01:18.370 --> 01:22.760
保存函数的属性.

01:22.760 --> 01:24.400
现在, 为什么这是一个方法装饰器？

01:24.400 --> 01:29.210
因为我们可以像这样把它添加到submitHandler中,

01:29.210 --> 01:32.210
然后就可以完成了.

01:32.210 --> 01:33.680
就是这个意思

01:33.680 --> 01:35.500
现在, 我们还没有完全做到这一点,

01:35.500 --> 01:38.143
但这是它最终应该如何工作｡

01:39.090 --> 01:42.950
现在, 为了使它工作, 让我们回到上面的函数,

01:42.950 --> 01:46.880
然后什么必须进入函数体？

01:46.880 --> 01:51.950
好吧, 在那里, 我首先要获得访问原始方法的权限｡

01:51.950 --> 01:59.380
带有描述符｡  值, 以便存储最初定义的方法｡

01:59.380 --> 02:04.873
然后我想在这里创建一个调整后的描述符, 它是一个对象｡

02:06.650 --> 02:11.090
实际上, 我将输入PropertyDescriptor｡ 

02:11.090 --> 02:13.880
其中configurable应该设置为true,

02:13.880 --> 02:15.910
这样我们就可以随时更改它｡

02:15.910 --> 02:17.573
我们需要吸气剂｡ 

02:18.510 --> 02:21.770
在这个getter中, 在这里, 当你试图访问这个函数时,

02:21.770 --> 02:24.270
应该执行这个getter｡

02:24.270 --> 02:31.030
我们将在这里建立边界函数, 使用我们在上面提取的原始方法｡

02:31.030 --> 02:34.063
并在上面打电话绑定这个｡ 

02:35.370 --> 02:41.603
然后, 我想返回绑定函数, 就这样了｡

02:42.510 --> 02:44.190
当然, 总的来说,

02:44.190 --> 02:48.653
我将在方法装饰器中返回调整后的描述符｡

02:49.510 --> 02:52.880
现在我们在submitHandler上得到一个错误｡ 

02:52.880 --> 02:57.960
对装饰器的实验性支持是一个基本上需要启用的特性｡

02:57.960 --> 03:00.400
所以我们应该转到tsconfig文件,

03:00.400 --> 03:02.320
在那里向下滚动｡

03:02.320 --> 03:07.450
您应该会发现“experimentalDecorators”选项只是在中注释它｡

03:07.450 --> 03:09.980
在前面加个逗号｡ 

03:09.980 --> 03:14.183
保存它, 然后重新启动类型编译过程｡ 

03:15.180 --> 03:17.700
现在, 它仍然在这里显示一些错误, 如果我展开它,

03:17.700 --> 03:18.913
methodName被声明,

03:20.212 --> 03:23.170
但它的值永远不会被读取｡

03:23.170 --> 03:25.410
在应用程序 TS四号线｡ 

03:25.410 --> 03:26.760
它指的是这里, 我得到了这个论证,

03:26.760 --> 03:30.940
我在这里得到了它, 实际上我从来没有用过｡

03:30.940 --> 03:34.370
target也是一样, 我从来没有用过那个｡ 

03:34.370 --> 03:36.343
现在, 有两种方法可以解决这个问题｡ 

03:37.200 --> 03:39.610
一种方法是转到tsconfig,

03:39.610 --> 03:42.813
在这里放松我们的严格规则｡

03:44.160 --> 03:46.740
noUnusedParameters, 如果我们将其设置为false,

03:46.740 --> 03:49.090
则实际上允许使用未使用的参数｡

03:49.090 --> 03:50.670
这是一回事,

03:50.670 --> 03:52.910
或者你用特殊的名字下划线,

03:52.910 --> 03:56.653
和下划线两个.

03:57.770 --> 04:01.860
这实际上是对typescript和javascript的一个提示,

04:01.860 --> 04:08.740
你知道你不会使用这些值, 但是你需要接受它们, 因为你需要它们后面的参数｡

04:08.740 --> 04:11.810
如果你现在保存它, 它会编译而没有错误,

04:11.810 --> 04:14.700
如果我们返回并在这里输入hello并提交它,

04:14.700 --> 04:20.060
它现在仍然工作, 这要归功于我们的自动绑定装饰器｡

04:20.060 --> 04:24.950
希望这也表明这个装饰器可以有一些真正的用途｡

04:24.950 --> 04:29.510
当然, 这比调用bind要多做一些工作.

04:29.510 --> 04:33.820
但是想象一下, 越来越多的方法都需要绑定｡

04:33.820 --> 04:36.140
不必手动调用bind this,

04:36.140 --> 04:42.343
可以节省一些时间, 还可以防止在忘记它的情况下出现一些潜在的错误｡
