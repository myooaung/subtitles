WEBVTT

00:02.300 --> 00:03.420
講師：さっそくですが､

00:03.420 --> 00:07.060
ここでnpm startを実行して､ 開発サーバーを立ち上げてみます｡

00:07.060 --> 00:09.384
HTMLファイルとメニュータブを提供するtsc-wは､

00:09.384 --> 00:13.434
ウォッチモードでコンパイルの種類を開始し､ アプリのJavaScriptファイルを継続的に再構築し､

00:13.434 --> 00:21.740
実行中のアプリケーションでそれを見ることができるようにするものです｡

00:21.740 --> 00:24.480
今､ 私たちのアプリケーションは､ もちろんあまり派手には見えません｡ 

00:24.480 --> 00:26.340
空のページです｡ 

00:26.340 --> 00:27.850
だから､ 始めるには､

00:27.850 --> 00:30.250
いろいろな方法がある｡

00:30.250 --> 00:35.040
さて､ まずはこのフォームを表示させるところから始めたいと思います｡ 

00:35.040 --> 00:36.660
そして､ 今度はいろいろな方法がありますが､

00:36.660 --> 00:40.208
実際にこのアプリケーションをオブジェクト指向のアプローチで書いてみることにします｡

00:40.208 --> 00:43.303
これは100％オプションですが､ クラスなどについて学んだので､

00:43.303 --> 00:51.140
実際にどのように動作するかを示したいので､ この方法を使用します｡

00:51.140 --> 00:51.973
アプリのキーに新しいクラスを追加して､

00:51.973 --> 00:59.120
Project Inputと名付けますが､ もちろんクラス名はあなた次第です｡

00:59.120 --> 01:00.570
このクラスでは､ このテンプレートとフォームにアクセスして､

01:00.570 --> 01:11.710
この div にアクセスし､ 最終的にこの div にテンプレートをレンダリングすることが目標です｡

01:11.710 --> 01:15.160
つまり､ テンプレートの内容､ そのdivの中にフォームがあるということです｡ 

01:15.160 --> 01:17.130
それが私たちの目標でなければなりません｡ 

01:17.130 --> 01:18.850
これを実現するために､ Project

01:18.850 --> 01:20.588
Inputにコンストラクタを追加し､

01:20.588 --> 01:27.970
最終的にテンプレートとレンダリングされる場所にアクセスできるようにします｡

01:28.830 --> 01:33.310
ここでは､ テンプレート要素のプロパティと､

01:33.310 --> 01:40.180
ホスト要素のプロパティの2つを追加します｡

01:40.180 --> 01:42.420
名前は100％おまかせします｡ 

01:42.420 --> 01:46.970
私の考えでは､ host要素は､ 最終的にテンプレートのコンテンツをレンダリングする要素への参照を保持し､

01:46.970 --> 01:54.050
template要素は､ このコンテンツを保持するテンプレートにアクセスできるようにするものです｡

01:54.050 --> 01:56.120
さて､ そのテンプレートにアクセスするために､

01:56.120 --> 02:01.870
index html を見て､ フォームを保持しているテンプレートをどのように特定するか見てみましょう｡

02:01.870 --> 02:04.050
まあ､ このプロジェクトインプットIDがあるので､

02:04.050 --> 02:06.120
いい作戦のような気もしますが｡

02:06.120 --> 02:08.510
そこで､ ここでは､ document getElementById

02:08.510 --> 02:11.022
project-inputを使用することができます｡

02:11.022 --> 02:15.410
これにより､ このテンプレート要素にアクセスすることができます｡ 

02:15.410 --> 02:17.820
さて､ 大事なことを2つほど｡ 

02:17.820 --> 02:23.900
ここでは､ template elementがproject-inputに存在しないプロパティであるというエラーが発生します｡

02:23.900 --> 02:31.610
さて､ これを取り除くには､ 実際にこのクラスの中に新しいフィールドとして直接追加する必要があります｡

02:31.610 --> 02:34.050
そうすれば､ 安心して割り当てることができます｡ 

02:34.050 --> 02:37.450
さて､ ここで､ そこに格納される型についても明確にしておきたいと思います｡

02:37.450 --> 02:41.070
そして､ それがHTMLのテンプレート要素になります｡ 

02:41.070 --> 02:43.270
tsconfigのjsファイルではDOMをlibとして追加しているので､

02:43.270 --> 02:50.360
このDOM型やHTML要素の型はすべてtypescriptの型としてプロジェクト全体に追加され､

02:50.360 --> 02:55.493
グローバルに利用可能です｡

02:57.280 --> 03:00.400
しかし､ ここで新たなエラーが発生します｡ IDで要素を取得する際に､

03:00.400 --> 03:03.110
最終的にnullになる可能性があることがわかります｡

03:03.110 --> 03:04.760
もちろん､ 失敗しないことはわかっていますが､

03:04.760 --> 03:12.757
typescriptはhtmlファイルを分析しないので､ これを知る機会がないのです｡

03:12.757 --> 03:18.210
つまり､ このIDを持つ要素は存在しないので､ nullが返されるのでしょう｡

03:18.210 --> 03:23.920
ここでは､ NULLを格納せず､ HTMLテンプレート要素だけを格納することにします｡

03:23.920 --> 03:29.470
そこで､ この危険性を排除するために､ typescriptに「これは決してNULLにはならない」と伝える必要がある｡

03:29.470 --> 03:31.290
そして､ どうすればいいかわかりますか？

03:31.290 --> 03:33.580
ここでエクスクラメーションマークをつけることができます｡ 

03:33.580 --> 03:36.170
もちろん､ 定数として保存し､

03:36.170 --> 03:37.820
テンプレート要素が真実かどうか､

03:37.820 --> 03:41.640
つまりnullでないかどうかをチェックし､

03:41.640 --> 03:51.490
このifチェックの中に保存することもできます｡

03:51.490 --> 03:52.720
さて､ まだエラーは出ていますが､

03:52.720 --> 03:54.190
これは別のエラーになるので､

03:54.190 --> 03:55.840
後でまた説明します｡

03:55.840 --> 03:59.650
とりあえず､ よくわからないときはこれで大丈夫でしょう｡

03:59.650 --> 04:01.930
しかし､ 今ここで私は確信した｡ 

04:01.930 --> 04:02.763
ちなみに､ よくわからない場合は､

04:02.763 --> 04:06.000
もちろん他のケースでのフォールバックを用意すべきです｡

04:06.000 --> 04:08.530
しかし､ ここではそのような要素が得られると確信しているので､

04:08.530 --> 04:10.544
その後に感嘆符を付けてタイプスクリプトに「All

04:10.544 --> 04:13.710
good」と伝えるだけでいいのです｡

04:13.710 --> 04:18.133
そのIDを持つ要素にアクセスできるようになる｡  さて､ 先ほども申し上げましたが､ まだ別のエラーがあります｡

04:18.133 --> 04:20.220
type HTML 要素にプロパティ内容がありません｡ 

04:20.220 --> 04:24.270
ここで問題なのは､ typescriptにhtml template

04:24.270 --> 04:29.550
elementというタイプのテンプレート要素を保存するように伝えていることです｡

04:29.550 --> 04:32.160
そして､ 実際にそうなるのです｡ 

04:32.160 --> 04:38.730
さて､ 当然ながら､ getElementByIdは最終的にどの要素を返すか分からない｡

04:38.730 --> 04:41.130
ただ､ それが何らかのhtml要素であることはわかるが､

04:41.130 --> 04:43.920
どのような特殊化されたバージョンであるかはわからない｡

04:43.920 --> 04:48.720
div､ 段落､ ボタン､ または今回のようにテンプレート要素であれば｡

04:48.720 --> 04:51.387
getElementByIdはそれを知る機会がない｡ 

04:51.387 --> 04:54.590
そこで､ 私たちが確実に知っている活字を､

04:54.590 --> 04:57.460
活字印刷に伝えるために｡

04:57.460 --> 05:00.660
タイプキャスティングを使えばいいんです｡ 

05:00.660 --> 05:02.260
このことも知りましたね｡ 

05:02.260 --> 05:03.730
使用できる構文は2つです｡ 

05:03.730 --> 05:07.690
冒頭の角括弧､ そしてこれをキャストしたい型にすることで､

05:07.690 --> 05:11.847
typeScriptに「おい！」と伝えているのです｡

05:11.847 --> 05:12.700
この後に来るもの､

05:12.700 --> 05:17.650
ここの表現､ これはそのタイプになります｡ または､ HTMLのテンプレート要素として追加する方法があります｡

05:17.650 --> 05:25.700
そして､ これによって､ ここで取得したものがnullでなく､ この型であることをtypescriptに保証しているのです｡

05:25.700 --> 05:32.016
これを選択することが多く語られていますが､ 一般的な作業であり､ これを正しく理解することが重要なのです｡

05:32.016 --> 05:33.630
続いて､ ホストエレメントについてです｡ 

05:33.630 --> 05:35.563
ここで､ host要素もフィールドとして追加して､

05:36.890 --> 05:39.360
実際にproject-inputをレンダリングするときには､

05:39.360 --> 05:45.960
host要素は最終的にここにあるdivになることが分かっています｡

05:45.960 --> 05:48.560
そこにフォームをレンダリングしたいのです｡ 

05:48.560 --> 05:51.410
つまり､ ここではHTMLのdiv要素ということになります｡ 

05:51.410 --> 05:54.000
これを追加するのは､ このタイプの要素です｡ 

05:54.000 --> 06:02.740
また､ もう少し具体的に言うと､ HTML要素ということもできます｡

06:02.740 --> 06:04.970
しかし､ 確実に分かっているのだから､

06:04.970 --> 06:08.400
なぜ追加しないのか｡

06:08.400 --> 06:11.263
さて､ もちろん､ これを追加すべきdivにアクセスしたいのですが､

06:12.110 --> 06:16.530
インデックスを見てみましょう｡ htmlファイルでは､ 再びIDでこのdivを特定できることがわかります｡

06:16.530 --> 06:18.970
この場合のアプリIDです｡ 

06:18.970 --> 06:19.945
さて､ app tsに戻って､

06:19.945 --> 06:24.640
もう一度document getElementByIdを使って､ id appの要素にアクセスすることができます｡

06:24.640 --> 06:28.780
また､ getElementById

06:28.780 --> 06:35.112
はこれが HTML の div

06:35.112 --> 06:46.030
要素であることを知らないので､ ここでも同様にキャストする必要があります｡

06:46.030 --> 06:51.210
そして､ それによって､ 私たちが必要とするすべての要素にアクセスする方法を見つけることができるようになったのです｡

06:51.210 --> 06:53.990
まあ､ それはそれでいろいろとお話があったのですが｡ 

06:53.990 --> 06:56.070
そのため､ 残念ながらあまり成果は出ていません｡ 

06:56.070 --> 07:01.970
私たちはこれらの要素にアクセスすることができますが､ そこで何かをレンダリングしているわけではありません｡

07:01.970 --> 07:03.940
では､ その続きです｡ 

07:03.940 --> 07:05.790
そのためには､ このテンプレート要素からコンテンツをインポートする必要があります｡

07:05.790 --> 07:08.020
つまり､ 基本的にはテンプレートタグの中にあるものをインポートして､

07:08.020 --> 07:11.760
これをDOMにレンダリングするのです｡

07:11.760 --> 07:15.520
もちろん､ これは私の考えであり､

07:15.520 --> 07:21.870
別の設定も可能です｡

07:21.870 --> 07:24.550
しかし､ 私の考えは､ このクラスの新しいインスタンスを作成すると､

07:24.550 --> 07:28.250
すぐにこのインスタンスに属するフォームをレンダリングすることです｡

07:28.250 --> 07:30.190
だから､ コンストラクタでちゃんとやるんだ｡ 

07:30.190 --> 07:34.420
そこで､ インポートしたノードやインポートしたHTMLコンテンツなど､

07:34.420 --> 07:49.260
どのような名前でも取得することができます｡ ドキュメントimportNodeで取得することができ､ これはグローバルドキュメントオブジェクトで提供されるメソッドで､ importNodeにテンプレート要素のポインタを渡します｡

07:49.260 --> 07:54.410
つまり､ 最終的にこのテンプレート要素､ 正確には要素ではなく､ そこにドットコンテンツがあるわけです｡

07:54.410 --> 07:57.010
Contentは､ HTMLのテンプレート要素に存在するプロパティで､

07:57.010 --> 08:05.320
単純にテンプレートの内容への参照を与えるものです｡

08:05.320 --> 08:07.480
そこで､ テンプレートテキストの間にあるHTMLコードに

08:07.480 --> 08:15.670
ImportNodeはまた､ ディープクローンでこれをインポートすべきかどうかを定義する第2引数を取る｡

08:15.670 --> 08:17.940
そのため､ テンプレートの内部ですべてのレベルのネストを行うことができますし､ ぜひそうしたいと思いますので､

08:17.940 --> 08:19.630
ここでtrueを提供します｡

08:19.630 --> 08:28.830
さて､ importedNodeですが､ 見ての通り､ これはtypescriptが自動的に仮定または推論したドキュメントフラグメントのタイプです｡

08:28.830 --> 08:34.910
そしてもちろん､ それを使ってコンテンツをレンダリングしたいと思います｡

08:34.910 --> 08:36.960
そのために､ 新しいメソッドを追加します｡

08:36.960 --> 08:40.970
プライベート・メソッドで､ 名前はattachとします｡

08:40.970 --> 08:45.150
そんなことしなくても､ 選択とレンダリングのロジックを分けたいだけなんです｡

08:45.150 --> 08:46.390
attachの内部では､ ホスト要素にアクセスして､

08:46.390 --> 09:00.770
コンテンツをレンダリングしたい場所で､ JavaScriptでブラウザが提供するデフォルトのメソッドであるinsertAdjacentElementを呼び出すことになります｡

09:00.770 --> 09:02.980
HTML要素を挿入するには､

09:02.980 --> 09:04.340
まず､ 隣接する要素を挿入する場所を記述します｡

09:04.340 --> 09:08.778
そこで､ 対象となる要素の先頭の後に挿入することができるので､

09:08.778 --> 09:20.870
ホスト要素の開始タグの直後､ 先頭または開始タグの前､ 終了タグの前､ 終了タグの後に挿入することができます｡

09:20.870 --> 09:27.020
そしてここでは､ beginの後に､ 冒頭のタグのすぐ近くに挿入するようにします｡

09:27.020 --> 09:30.580
そして､ 挿入したいのはimportedNodeですが､

09:30.580 --> 09:39.140
まず第一に､ これはコンストラクタでのみ利用可能な定数であり､

09:39.140 --> 09:42.970
第二に､ これはドキュメントの断片です｡

09:42.970 --> 09:44.630
このままでは挿入できない｡ 

09:44.630 --> 09:49.800
その代わりに､ そこにある具体的なHTML要素へのアクセスを得る必要があり､ それを別のproperty要素に格納することができるのです｡

09:49.800 --> 09:52.770
これはHTML要素のタイプにすることもできますし､

09:52.770 --> 09:58.270
私たちの場合はテンプレートの中にあるので､

09:58.270 --> 10:02.500
フォームになります｡

10:02.500 --> 10:05.790
これがテンプレートの最初の要素です｡ 

10:05.790 --> 10:07.010
そして､ この要素はimportNode

10:07.010 --> 10:10.960
firstElementChildに等しいので､

10:10.960 --> 10:20.106
typescriptにこれがHTMLフォーム要素になることを伝えればよいのです｡

10:20.106 --> 10:25.510
これで､ この要素は､ 挿入したいノードを指す具体的なプロパティになりました｡

10:25.510 --> 10:28.360
そこで､ この下にあるinsertAdjacentElementで､

10:28.360 --> 10:31.110
この要素をここに挿入しています｡

10:31.110 --> 10:36.350
あとは､ コンストラクタの最後にattachを呼び出すことで､

10:36.350 --> 10:42.260
このプライベートattachメソッドも実行されることを確認します｡

10:42.260 --> 10:44.290
そして､ すべての書式を設定すると､

10:44.290 --> 10:46.620
私のコードはこのようになります｡

10:46.620 --> 10:48.200
これで､ プロジェクトの入力クラスができあがりました｡

10:48.200 --> 10:53.950
理論的には､ このクラスをインスタンス化すると､ フォームがレンダリングされるはずです｡

10:53.950 --> 10:56.920
さあ､ 試してみましょう｡ 

10:56.920 --> 10:59.440
クラスの下に､ 単純に新しい定数､ 例えばprjInputを作りましょう､

10:59.440 --> 11:01.120
名前はあなた次第です｡

11:01.120 --> 11:05.415
そして､ 新しいプロジェクトを呼び出す こんな感じで入力します｡ 

11:05.415 --> 11:08.930
そして､ これを保存すると､ リコンパイルとリロードが行われ､ ブラウザに戻ると､

11:08.930 --> 11:16.050
確かにここにフォームが表示されるはずです｡

11:16.050 --> 11:20.660
これで､ 最初の重要な一歩を踏み出すことができたわけです｡

11:20.660 --> 11:22.450
私たちのフォームをレンダリングしてもらい､

11:22.450 --> 11:29.150
多くのものが欠けていても､ ないよりはましです｡

11:29.150 --> 11:36.430
このフォームは､ index htmlファイルから来ていて､ そこにあるオブジェクト指向のタイプスクリプトのコードを使ってレンダリングされています｡
