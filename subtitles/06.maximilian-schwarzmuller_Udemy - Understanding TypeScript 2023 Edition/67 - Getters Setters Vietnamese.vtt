WEBVTT

00:02.200 --> 00:04.920
Diễn giả: Đó là lớp, thuộc tính

00:04.920 --> 00:07.510
và kế thừa với Typescript.

00:07.510 --> 00:08.343
Và như tôi đã đề

00:08.343 --> 00:10.260
cập, mặc dù các tính năng này thường

00:10.260 --> 00:12.490
được hỗ trợ trong Javascript, nhưng

00:12.490 --> 00:14.230
trong JavaScript hiện đại,

00:14.230 --> 00:16.940
tất nhiên là ngoại trừ các phép gán loại và

00:16.940 --> 00:21.060
cũng ngoại trừ công khai riêng tư được bảo vệ.

00:21.060 --> 00:24.770
Những từ khóa này thực sự chỉ có trong Typescript.

00:24.770 --> 00:28.560
Tuy nhiên, đó không phải là tất cả những gì bạn có thể làm với các lớp học.

00:28.560 --> 00:29.940
Bất cứ khi nào cần tính

00:29.940 --> 00:32.840
năng, mà bạn cũng có trong vanilla JavaScript,

00:32.840 --> 00:35.670
trong đó cũng được hỗ trợ trong Bản mô tả,

00:35.670 --> 00:38.610
là getters và setters.

00:38.610 --> 00:42.050
Bây giờ hãy xem điều đó ở đây trên bộ phận kế

00:42.050 --> 00:43.390
toán chẳng hạn, giả

00:43.390 --> 00:47.450
sử chúng ta có một báo cáo cuối cùng, tài sản.

00:47.450 --> 00:51.630
Đó là một thuộc tính riêng tư và đó là một chuỗi loại, vì

00:51.630 --> 00:53.310
vậy chúng tôi có nó.

00:53.310 --> 00:56.480
Và sau đó ở đây chúng tôi khởi tạo cái này, để trở thành

00:56.480 --> 01:01.480
đối số đơn đặt hàng thuộc tính báo cáo của chúng tôi mà chúng tôi đang nhận được

01:02.270 --> 01:04.880
ở đây và chúng là giá trị đầu tiên.

01:04.880 --> 01:07.877
Tất nhiên, về cơ bản là không xác định nếu chúng ta chuyển

01:07.877 --> 01:09.890
vào và để trống mảng báo cáo.

01:09.890 --> 01:14.680
Bây giờ khi chúng tôi thêm một báo cáo, thì tôi muốn đặt báo cáo

01:14.680 --> 01:17.010
cuối cùng này, bằng văn bản.

01:17.010 --> 01:20.440
Đó là những gì chúng tôi thêm vào mảng báo cáo của mình.

01:20.440 --> 01:23.890
Bây giờ báo cáo cuối cùng là riêng tư, vì vậy chúng tôi có thể truy

01:23.890 --> 01:26.250
cập nó từ bên trong phương pháp này, nhưng

01:26.250 --> 01:28.590
chúng tôi sẽ không thể truy cập nó từ bên ngoài

01:28.590 --> 01:30.240
bằng ký hiệu dấu chấm.

01:30.240 --> 01:33.440
Bây giờ chúng ta có thể thêm một getter để vẫn có thể truy cập được.

01:33.440 --> 01:36.020
Getter về cơ bản là một thuộc tính, nơi bạn thực

01:36.020 --> 01:38.670
thi một hàm hoặc phương thức, khi bạn truy xuất

01:38.670 --> 01:40.910
một giá trị và điều đó cho phép bạn với

01:40.910 --> 01:42.380
tư cách là nhà phát triển

01:42.380 --> 01:44.460
thêm logic phức tạp hơn.

01:44.460 --> 01:47.560
Tại đây, bạn tạo một getter bằng cách sử dụng từ khóa get, sau

01:47.560 --> 01:49.250
đó là bất kỳ tên nào bạn chọn.

01:49.250 --> 01:51.810
Thường liên quan chặt chẽ đến thuộc tính mà bạn

01:51.810 --> 01:54.180
đang cố gắng kiểm soát quyền truy cập.

01:54.180 --> 01:58.180
Ví dụ ở đây chúng ta có thể đặt tên là báo cáo gần đây nhất.

01:58.180 --> 01:59.340
Tất cả những thứ tương tự như vậy.

01:59.340 --> 02:01.630
Điều quan trọng bây giờ là điều này được định nghĩa giống như một phương thức.

02:01.630 --> 02:04.260
Vì vậy, bạn thêm dấu ngoặc đơn và sau đó là dấu ngoặc nhọn.

02:04.260 --> 02:07.250
Và bây giờ ở đây, bạn phải trả lại một cái gì đó,

02:07.250 --> 02:11.990
đó là một phương thức getter quan trọng, phải trả lại một cái gì đó.

02:11.990 --> 02:14.610
Vì vậy, bạn có thể gửi lại báo cáo cuối cùng này,

02:14.610 --> 02:16.660
và sau đó chúng tôi tóm tắt báo cáo này,

02:16.660 --> 02:19.570
bởi vì báo cáo này hiện có thể truy cập công khai.

02:19.570 --> 02:22.720
Nhưng thường thì bạn muốn có logic phức tạp hơn ở đây.

02:22.720 --> 02:26.240
Vì vậy, ở đây chúng tôi có thể kiểm tra xem chúng tôi có giá trị ở đây không,

02:26.240 --> 02:27.600
vì vậy nếu đây là sự thật.

02:27.600 --> 02:28.960
Nếu nó không phải là không

02:28.960 --> 02:31.520
xác định, thì chúng tôi muốn trả về báo cáo

02:31.520 --> 02:34.440
cuối cùng, nếu không, chúng tôi có thể muốn trả

02:34.440 --> 02:37.850
về một số logic khác, ví dụ: giả sử nếu không, chúng tôi

02:37.850 --> 02:42.650
đưa ra một thông báo lỗi với lỗi ném mới, không tìm thấy báo cáo nào.

02:42.650 --> 02:46.650
Vì vậy, bây giờ chúng tôi đã thêm nhiều logic hơn, logic phức tạp hơn vào thuộc

02:46.650 --> 02:49.200
tính này và khi chúng tôi muốn truy xuất nó, chúng

02:49.200 --> 02:51.500
tôi không thể truy xuất trực tiếp thuộc tính

02:51.500 --> 02:55.290
này thông qua ký hiệu dấu chấm, nhưng chúng tôi có thể sử dụng thuộc tính này

02:55.290 --> 02:57.240
làm thuộc tính để chạy logic này.

02:57.240 --> 02:58.810
Vì vậy, làm thế nào điều này sẽ làm việc?

02:58.810 --> 03:02.170
Ở dưới đó, nơi tôi tạo bộ phận Kế toán của mình.

03:02.170 --> 03:07.120
Trước khi tôi thêm báo cáo của mình, nếu tôi cố gắng đăng nhập Bảng điều khiển, thì

03:07.120 --> 03:08.693
tài khoản. báo cáo gần đây nhất,

03:09.630 --> 03:11.010
và bây giờ quan trọng.

03:11.010 --> 03:13.902
Rất tiếc, kế toán. mostrecentreport.

03:13.902 --> 03:16.890
Và bây giờ điều quan trọng là bạn truy cập nó như một tài sản.

03:16.890 --> 03:18.690
Vì vậy, không có dấu ngoặc đơn ở đây.

03:18.690 --> 03:20.570
Bạn không thực hiện điều này như một phương pháp.

03:20.570 --> 03:23.030
Bạn chỉ cần truy cập nó như một tài sản

03:23.030 --> 03:24.460
bình thường và ở hậu trường,

03:24.460 --> 03:27.890
điều này sẽ thực thi phương thức này ở đó.

03:27.890 --> 03:31.670
Vì vậy, nếu tôi đã thử điều này ngay bây giờ trước khi chúng tôi thêm báo cáo của

03:31.670 --> 03:33.940
mình, Chúng tôi sẽ thấy rằng báo cáo này được xây

03:33.940 --> 03:35.440
dựng lại mà không có lỗi, được biên

03:35.440 --> 03:38.550
dịch lại mà không có lỗi, nhưng tất nhiên ở đây đã xảy ra lỗi, đó

03:38.550 --> 03:40.820
là lỗi không tìm thấy báo cáo tùy chỉnh của chúng

03:40.820 --> 03:42.820
tôi, vì chưa có báo cáo nào được thêm vào và

03:42.820 --> 03:45.370
kể từ khi sử dụng cái này làm phương thức thu thập, hãy

03:45.370 --> 03:48.310
truy cập phương thức này và thực thi nó.

03:48.310 --> 03:51.560
Nếu chúng tôi không có báo cáo, chúng tôi sẽ không thực hiện

03:51.560 --> 03:52.830
kiểm tra IF này hoặc vào

03:52.830 --> 03:55.693
câu lệnh IF này, và do đó, dòng này ở đây sẽ bắt đầu.

03:56.590 --> 04:00.250
Thay vào đó, nếu chúng tôi di chuyển báo cáo đó xuống, sau khi chúng

04:00.250 --> 04:02.210
tôi thêm báo cáo, thì tất nhiên chúng

04:02.210 --> 04:04.100
tôi có thể lưu báo cáo đó và chúng tôi

04:04.100 --> 04:05.730
không còn gặp lỗi nữa mà thay vào

04:05.730 --> 04:08.400
đó, chúng tôi xuất báo cáo cuối cùng này.

04:08.400 --> 04:09.750
Vì vậy, đó là một getter.

04:09.750 --> 04:12.190
Và bạn cũng có thể thêm một setter.

04:12.190 --> 04:14.550
Một setter được thêm gần như theo cùng một cách.

04:14.550 --> 04:16.290
Bạn sử dụng từ khóa set, sau đó

04:16.290 --> 04:18.630
sử dụng lại bất kỳ tên nào bạn chọn.

04:18.630 --> 04:21.940
thường là tên liên quan đến thuộc tính nên

04:21.940 --> 04:22.870
được đặt.

04:22.870 --> 04:25.570
Vì vậy, ở đây tôi sẽ sử dụng lại báo cáo gần đây nhất.

04:25.570 --> 04:27.840
Vì vậy, chúng ta có thể sử dụng cả giá trị này để

04:27.840 --> 04:29.150
đọc giá trị và đặt giá trị.

04:29.150 --> 04:30.090
Và một lần nữa, bạn đã định

04:30.090 --> 04:31.850
nghĩa điều này giống như một phương thức.

04:31.850 --> 04:34.850
Nhưng bây giờ, điều này cần phải có một cuộc tranh luận.

04:34.850 --> 04:38.630
Giá trị mà người dùng sẽ chuyển vào.

04:38.630 --> 04:40.940
Ở đây phải có một giá trị chuỗi, và

04:40.940 --> 04:44.110
bây giờ ở đây bạn có thể chạy bất kỳ logic nào bạn

04:44.110 --> 04:46.160
muốn lưu trữ giá trị này.

04:46.160 --> 04:48.530
Bây giờ ở đây vì đang chuyển một giá trị

04:48.530 --> 04:51.890
cho báo cáo gần đây nhất, cuối cùng tôi muốn thực hiện

04:51.890 --> 04:53.080
thêm báo cáo.

04:53.080 --> 04:55.370
Vì vậy, ở đây một setter có thể đơn giản là một giải pháp

04:55.370 --> 04:57.140
thay thế cho phương thức thêm báo cáo.

04:57.140 --> 05:01.280
Vì vậy, tại đây, chúng tôi có thể truy cập báo cáo thêm này.

05:01.280 --> 05:03.760
Điều này là bắt buộc vì chúng ta đang ở trong lớp.

05:03.760 --> 05:07.280
Chúng tôi đề cập đến lớp, và sau đó đến phương thức lớp này ở đây.

05:07.280 --> 05:10.380
Và bây giờ chúng ta chỉ có thể chuyển tiếp giá trị ở đây.

05:10.380 --> 05:12.310
Bây giờ chúng ta có thể thêm một logic

05:12.310 --> 05:16.130
phức tạp hơn, đồng thời kiểm tra xem giá trị có thể không được xác định

05:16.130 --> 05:19.810
nếu giá trị đó sai hay không, sau đó chỉ cần trả về hoặc gửi một lỗi mới

05:19.810 --> 05:24.020
cho bạn, trong đó chúng tôi nói vui lòng chuyển vào một giá trị hợp lệ.

05:24.020 --> 05:26.140
Đó là điều mà chúng ta cũng có thể làm được.

05:26.140 --> 05:29.010
Và bây giờ chúng tôi cũng đang sử dụng một setter ở đây.

05:29.010 --> 05:31.330
Với điều đó được thêm vào, chúng tôi có thể kiểm tra nó.

05:31.330 --> 05:33.193
Dưới đó, tôi có thể thêm báo cáo

05:35.400 --> 05:36.570
gần đây nhất.

05:36.570 --> 05:38.780
Tôi có thể truy cập thông tin này trong phần kế toán

05:38.780 --> 05:40.770
và giống như thông tin này, chúng tôi sẽ đọc từ

05:40.770 --> 05:42.300
đó, nhưng bây giờ bằng cách thêm dấu

05:42.300 --> 05:44.520
bằng, chúng tôi đang cố gắng đặt giá trị cho giá trị

05:44.520 --> 05:47.150
đó và điều đó sẽ kích hoạt phương thức thiết lập này.

05:47.150 --> 05:50.090
Một lần nữa ngay trước khi chúng ta không thực thi nó như một phương

05:50.090 --> 05:52.383
thức, mà chỉ cần truy cập nó như một thuộc tính.

05:53.220 --> 05:56.030
Bây giờ ở đây nếu tôi chuyển vào một chuỗi trống,

05:56.030 --> 05:58.770
thì về mặt kỹ thuật, chúng tôi thực hiện chuyển

05:58.770 --> 06:02.760
vào một chuỗi, nhưng một chuỗi trống sẽ được coi là sai, xem tại đây.

06:02.760 --> 06:04.950
Và do đó, bây giờ chúng ta sẽ nhận được một lỗi.

06:04.950 --> 06:07.450
Vì vậy, nếu tôi lưu dòng mã này, nếu tôi

06:07.450 --> 06:09.850
lưu mã có thêm dòng mã này, chúng tôi đã

06:11.120 --> 06:14.530
gặp lỗi này, vui lòng chuyển vào một giá trị hợp lệ.

06:14.530 --> 06:17.010
Tuy nhiên, nếu tôi chuyển vào một

06:17.010 --> 06:22.010
giá trị hợp lệ, nếu tôi nói báo cáo cuối năm ở đây chẳng hạn, và bây giờ

06:22.250 --> 06:23.900
tôi lưu cái này.

06:23.900 --> 06:27.210
Bây giờ bạn sẽ thấy tất cả công việc này và báo cáo cuối năm là một

06:27.210 --> 06:29.620
phần trong danh sách báo cáo của chúng tôi.

06:29.620 --> 06:31.150
Vì vậy, đây là các getters

06:31.150 --> 06:33.620
và setters, có thể tuyệt vời để đóng gói logic

06:33.620 --> 06:35.390
và để thêm logic bổ sung, sẽ chạy

06:35.390 --> 06:38.050
khi bạn cố gắng đọc một thuộc tính hoặc khi bạn

06:38.050 --> 06:40.243
cố gắng đặt một thuộc tính.
