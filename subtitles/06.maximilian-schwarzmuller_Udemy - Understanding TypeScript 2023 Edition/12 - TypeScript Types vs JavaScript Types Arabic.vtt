WEBVTT

00:00.000 --> 00:02.410
(صمت) -: لذلك نرى بالفعل كيف يمكن

00:02.410 --> 00:04.190
لـ TypeScript مساعدتنا

00:04.190 --> 00:06.200
أثناء التطوير.

00:06.200 --> 00:10.560
الآن ، نعلم أيضًا أن هناك نوع رقم في JavaScript.

00:10.560 --> 00:14.010
ويمكننا رؤيته بنوع المشغل المدمج.

00:14.010 --> 00:15.781
هذا الآن ليس خاصًا بـ TypeScript

00:15.781 --> 00:17.560
، إنه عامل تشغيل وكلمة أساسية

00:17.560 --> 00:20.420
مضمنة يدعمها JavaScript.

00:20.420 --> 00:22.910
يمكننا استخدامه للحصول على نوع قيمة معينة.

00:22.910 --> 00:27.050
لذا هنا ، يمكننا التحكم في نوع القفل رقم واحد.

00:27.050 --> 00:27.992
وما سنراه إذا فعلنا

00:27.992 --> 00:30.780
ذلك هو أنه بمجرد أن نقوم بتجميع هذا ، حتى نقوم

00:30.780 --> 00:32.623
بتشغيل الكود المحدث.

00:33.780 --> 00:37.040
هنا ، نقوم بطباعة الرقم على وحدة التحكم.

00:37.040 --> 00:39.330
الآن نقوم بذلك ، بفضل هذا الإخراج هنا

00:39.330 --> 00:41.180
، وبفضل نوع المشغل وفي Vanilla

00:41.180 --> 00:43.770
JavaScript ، بدون TypeScript ، يمكننا استخدام

00:43.770 --> 00:46.710
ذلك لتحسين وظيفتنا دائمًا هنا.

00:46.710 --> 00:51.500
يمكننا التحقق مما إذا كان نوع الرقم يساوي عددًا.

00:51.500 --> 00:54.300
عفواً ، نوع n1 أعني ، إذا كان هذا

00:54.300 --> 00:56.350
يساوي عددًا ، ويمكننا

00:56.350 --> 01:00.710
أيضًا التحقق مما إذا كان نوع n2 يساوي عددًا.

01:00.710 --> 01:02.349
ونقوم بإجراء عمليتنا

01:02.349 --> 01:05.220
هنا فقط إذا كان هناك خطأ تم طرحه بطريقة

01:05.220 --> 01:07.860
أخرى أو قم بالعكس وتحقق مما إذا كان

01:07.860 --> 01:10.820
غير متساوٍ ، أو إذا كان n2 غير متساوٍ.

01:10.820 --> 01:13.230
وإذا لم يكن أي من الاثنين رقمًا

01:13.230 --> 01:16.360
، فيمكننا طرح خطأ جديد حيث نقول ، إدخال

01:16.360 --> 01:19.690
غير صحيح. ستكون هذه في الواقع طريقة

01:19.690 --> 01:22.300
غير TypeScript للتأكد من أننا لا نستطيع

01:22.300 --> 01:25.700
استدعاء هذه الوظيفة بسلسلة هنا.

01:25.700 --> 01:26.760
إذا قمت بذلك الآن ، وقمت بإعادة

01:26.760 --> 01:29.060
التحويل البرمجي ، فسنحصل على خطأ TypeScript ، لكن دعنا

01:29.060 --> 01:30.830
نتجاهل ذلك في الوقت الحالي.

01:30.830 --> 01:31.730
إذا أعدنا تشغيل هذا

01:31.730 --> 01:33.100
، نحصل على المدخلات غير الصحيحة

01:33.100 --> 01:34.940
، والتي نرميها بأنفسنا.

01:34.940 --> 01:38.080
لذلك قمنا الآن بتقوية الخلل في JavaScript

01:38.080 --> 01:39.930
، وفشل في وقت التشغيل ، ولكن

01:39.930 --> 01:41.970
الفشل قد يكون أفضل هنا من إظهار

01:41.970 --> 01:44.950
مخرجات غير صحيحة كانت لدينا من قبل.

01:44.950 --> 01:47.640
لذلك ستكون هذه طريقة للتحقق من المدخلات في JavaScript

01:47.640 --> 01:48.715
فقط.

01:48.715 --> 01:50.640
لا تحتاج إلى TypeScript لذلك.

01:50.640 --> 01:53.200
هذا هو رمز جافا سكريبت العادي.

01:53.200 --> 01:54.033
لكن بالطبع ، لهذا

01:54.033 --> 01:55.160
النهج جوانب سلبية.

01:55.160 --> 01:57.160
في بعض الأحيان يكون هذا هو الشيء الصحيح الذي يجب القيام به.

01:57.160 --> 02:01.440
في بعض الأحيان يمكنك فقط التحقق من صحة مدخلات معينة في وقت التشغيل.

02:01.440 --> 02:03.150
لكن الجانب السلبي هنا ،

02:03.150 --> 02:05.480
فنحن نتحقق من شيء يمكننا بالفعل

02:05.480 --> 02:08.950
تجنبه أثناء التطوير باستخدام TypeScript.

02:08.950 --> 02:11.180
لذا نعم ، نحن نخطئ.

02:11.180 --> 02:14.210
وفي تطبيقنا ربما قمنا بتضمين إجراءات يمكن

02:14.210 --> 02:16.860
أن تعود بعد ذلك إلى بعض السلوكيات الأخرى

02:16.860 --> 02:19.080
لحفظ التطبيق قيد التشغيل.

02:19.080 --> 02:20.750
لكننا ما زلنا نخطئ ، وهو

02:20.750 --> 02:24.180
أمر ليس ضروريًا أن يحدث في المقام الأول.

02:24.180 --> 02:27.350
كان بإمكاننا منعه باستخدام TypeScript.

02:27.350 --> 02:28.830
وهنا ، نرى حقًا الفرق بين JavaScript

02:28.830 --> 02:30.400
و TypeScript ، عندما يتعلق الأمر

02:30.400 --> 02:31.450
بالأنواع.

02:31.450 --> 02:33.750
يتم كتابة JavaScript ديناميكيًا

02:33.750 --> 02:35.610
، مما يعني أنه من الجيد تمامًا

02:35.610 --> 02:36.880
أن يكون لدينا متغير

02:36.880 --> 02:39.100
قد يحتوي في البداية على رقم ، حيث نقوم

02:39.100 --> 02:41.600
لاحقًا بتعيين سلسلة إليه.

02:41.600 --> 02:44.500
ولهذا السبب يتعين علينا كتابة عامل التشغيل

02:44.500 --> 02:48.024
حتى نتمكن من التحقق من النوع الحالي لشيء ما في وقت التشغيل

02:48.024 --> 02:50.124
إذا كان لدينا بعض الكود الذي يعتمد

02:50.124 --> 02:52.267
على نوع معين.

02:52.267 --> 02:53.570
من ناحية أخرى ، يتم

02:53.570 --> 02:55.094
كتابة TypeScript

02:55.094 --> 02:58.480
بشكل ثابت ، مما يعني أننا نحدد أنواع المتغيرات

02:58.480 --> 03:01.740
وتنتهي المعلمات أثناء التطوير ، ولا تتغير

03:01.740 --> 03:04.980
فجأة أثناء وقت التشغيل.

03:04.980 --> 03:05.813
الآن ، بالطبع

03:05.813 --> 03:09.090
، منذ أن تم تجميع TypeScript إلى JavaScript ،

03:09.090 --> 03:10.660
يمكنهم ذلك نظريًا.

03:10.660 --> 03:12.510
ولكن إذا استخدمنا TypeScript

03:12.510 --> 03:13.790
، وكتبنا رمزًا حيث

03:13.790 --> 03:17.530
قمنا فجأة بتعيين نوع جديد من البيانات إلى متغير ، حيث

03:17.530 --> 03:18.810
قلنا سابقًا أن هذا

03:18.810 --> 03:19.840
يجب أن يكون رقمًا

03:19.840 --> 03:22.900
، على سبيل المثال ، والآن نقوم بتعيين سلسلة

03:22.900 --> 03:25.810
، ثم نحصل على خطأ أثناء التطوير ، حتى نكون

03:25.810 --> 03:27.480
مضطرين لأن نكون واضحين

03:27.480 --> 03:29.670
فيما يتعلق بالأنواع ، شيء يمكن

03:29.670 --> 03:32.120
أو لا يمكن تحمله.

03:32.120 --> 03:33.710
هذا هو الاختلاف هنا.

03:33.710 --> 03:36.620
لذلك لا نريد حقًا استخدام تطبيقات أو حلول من

03:36.620 --> 03:38.330
هذا القبيل ، إذا كان بإمكاننا

03:38.330 --> 03:40.810
تجنبها باستخدام TypeScript.

03:40.810 --> 03:42.200
ومع ذلك ، من المهم

03:42.200 --> 03:43.890
معرفة أن JavaScript

03:43.890 --> 03:46.400
بالطبع يعرف مفهوم الأنواع.

03:46.400 --> 03:48.740
إنه يعرف بعض الأنواع مثل الأرقام

03:48.740 --> 03:50.640
والسلسلة والمنطقية.

03:50.640 --> 03:52.300
لكن استخدام ذلك يعني دائمًا

03:52.300 --> 03:53.540
أنه لا يمكننا الفشل

03:53.540 --> 03:56.400
إلا في وقت التشغيل بدلاً من أثناء التطوير ، وهو

03:56.400 --> 03:58.700
مكان أفضل بالنسبة لنا كمطور.

03:58.700 --> 04:01.550
يسمح لنا بإصلاح الخلل في وقت سابق.

04:01.550 --> 04:02.840
بالإضافة إلى ذلك ،

04:02.840 --> 04:05.410
لا يعرف JavaScript سوى نوعين فقط.

04:05.410 --> 04:07.170
كما ستتعلم خلال هذه الدورة.

04:07.170 --> 04:10.540
يعرف TypeScript أنواعًا أكثر من JavaScript.

04:10.540 --> 04:14.450
كذلك ، هل فحص وقت التشغيل ليس مرنًا حقًا أو ليس قويًا

04:14.450 --> 04:18.030
مثل ما يمكننا فعله باستخدام TypeScript.

04:18.030 --> 04:19.490
ولكل هذه الأسباب ، فإن هذا

04:19.490 --> 04:20.660
النهج في الواقع ليس هو

04:20.660 --> 04:22.550
النهج الذي نريد استخدامه هنا.

04:22.550 --> 04:26.540
قد يكون من المفيد أحيانًا الحصول على النوع في وقت التشغيل.

04:26.540 --> 04:28.790
لكن في بعض الأحيان ، كما في هذا المثال

04:28.790 --> 04:31.740
، من الأفضل الحصول عليها أثناء التطوير.

04:31.740 --> 04:34.280
الشيء الوحيد المهم الذي يجب التعرف عليه بالطبع

04:34.280 --> 04:36.070
هو أنه مع TypeScript ، يمكنك فقط

04:36.070 --> 04:38.670
الدعم أثناء التطوير ، وليس في وقت التشغيل ،

04:38.670 --> 04:39.596
لأن ميزات TypeScript

04:39.596 --> 04:41.610
وعمليات التحقق هذه ليست مدمجة في

04:41.610 --> 04:44.650
محرك JavaScript بحيث لا يمكن تنفيذ المنطق في المتصفح

04:44.650 --> 04:47.590
، لا يمكن تنفيذه إلا أثناء التطوير عندما تقوم بتجميع

04:47.590 --> 04:51.223
التعليمات البرمجية الخاصة بك.
