WEBVTT

00:02.270 --> 00:03.850
講師：そこで､ 数値､ ブーリアン､

00:03.850 --> 00:07.450
文字列という核となる型を使っています｡

00:07.450 --> 00:10.840
そして､ この関数のパラメータ・リストでは､

00:10.840 --> 00:13.970
パラメータ名の後にコロン､ そして型名と､

00:13.970 --> 00:18.410
常に明示的に型を代入しているのです｡

00:18.410 --> 00:21.350
ここでは､ number, boolean, stringという名前になっていますね｡ 

00:21.350 --> 00:25.420
因みに､ これらは現在では特別な識別子となっています｡

00:25.420 --> 00:30.170
全体的に､ ここが､ TypeScriptで追加された特殊な構文です｡

00:30.170 --> 00:32.900
コンパイルされたJavaScriptのコードには含まれません｡ 

00:32.900 --> 00:37.280
ここでそのコードを確認すると､ JavaScriptがサポートしていないため､

00:37.280 --> 00:39.530
これらの型付けはなくなっている｡

00:39.530 --> 00:43.920
このコロンというのは､ 変数の後ろ､ あるいはパラメータの後ろです｡

00:43.920 --> 00:46.320
そして､ 数字とブーリアン､ 文字列｡ 

00:46.320 --> 00:48.290
この特別なキーワードを

00:48.290 --> 00:50.840
これは､ TypeScriptによって導入されたものです｡ 

00:50.840 --> 00:53.500
TypeScriptのコンパイラは､ それを理解しています｡ 

00:53.500 --> 00:55.480
このIDEはTypeScriptをサポートしているので､

00:55.480 --> 00:58.580
これらの特殊なキーワードに対して文句を言うことはない｡

00:58.580 --> 01:01.760
JavaScriptはこの構文を理解しません｡ 

01:01.760 --> 01:04.590
パラメータの後のコロンや､ 変数の後のコロン､

01:04.590 --> 01:09.190
そして特殊な数値や文字列のキーワードを理解できないのです｡

01:09.190 --> 01:13.560
JavaScriptはこれを理解できないため､ JavaScriptの出力には含まれない｡

01:13.560 --> 01:15.920
これは､ TypeScriptのコンパイラが使っているだけなのです｡ 

01:15.920 --> 01:18.130
そして､ このコードをJavaScriptのコードに変換するので､

01:18.130 --> 01:21.820
まあ､ コンパイラということになります｡

01:21.820 --> 01:24.880
余談ですが､ varのconstも切り替わっているのがわかりますが､

01:24.880 --> 01:27.700
これはまた後日｡

01:27.700 --> 01:33.060
つまり､ ここでは明示的な型付けをしているのだが､ これはTypeScriptでしか理解できない｡

01:33.060 --> 01:35.763
素晴らしい､ なぜ下にないのですか？

01:36.880 --> 01:39.890
ここでは明示的な型付けはしていません｡ 

01:39.890 --> 01:41.180
ちなみに､ 結果を計算するときも､

01:41.180 --> 01:45.530
TypeScriptには型推論と呼ばれる機能が組み込まれているので､

01:45.530 --> 01:48.400
ここではない｡

01:48.400 --> 01:53.010
つまり､ TypeScriptは､ ある変数や定数にどの型が入っているかを理解するために､

01:53.010 --> 01:58.860
最善を尽くし､ そこそこ良い仕事をするのです｡

01:58.860 --> 02:02.300
そして､ ここでは､ 例えば､ number1を数値で初期化しているので､

02:02.300 --> 02:08.020
最終的には必ず数値型になることを理解しているのです｡

02:08.020 --> 02:09.950
さて､ これは実は定数なので､

02:09.950 --> 02:11.740
さらに具体的な話です｡

02:11.740 --> 02:15.350
そして､ ここで特定されるタイプは､ ただの数字ではなく､

02:15.350 --> 02:17.490
「5」という数字です｡

02:17.490 --> 02:23.870
なぜなら､ どうせ新しい数値､ つまりconst値に新しい値を割り当てることはできないからです｡

02:23.870 --> 02:25.840
これを変数に変えて､

02:25.840 --> 02:30.180
letで代用すれば､ もちろん何も壊れません｡

02:30.180 --> 02:34.540
この値は決して変化しないので､ ベストプラクティスではないかもしれませんが､

02:34.540 --> 02:36.210
恐ろしいことでもありません｡

02:36.210 --> 02:41.210
しかし､ この上にマウスを置くと､ TypeScriptは「これは5でなければならない」とは言わないことがわかります｡

02:41.210 --> 02:45.510
しかし､ それでもここの型が数値であることは検出されます｡ 

02:45.510 --> 02:49.260
さて､ このコードは絶対に自分たちで書くことができます｡ 

02:49.260 --> 02:51.970
等号の左側の変数名の後にコロンをつけて､

02:51.970 --> 02:55.590
型名にすればいいのです｡

02:55.590 --> 02:59.470
つまり､ 基本的にはこの関数のパラメータでやったことと同じです｡

02:59.470 --> 03:04.620
しかし､ これは冗長であり､ 実はあまり良い方法とは考えられていないのも事実です｡

03:04.620 --> 03:09.990
なぜなら､ TypeScriptはそこからこの型を完璧に推論することができるからです｡

03:09.990 --> 03:13.690
だから､ これをアサインするのは良くない｡ 

03:13.690 --> 03:18.053
これは､ この変数を未割り当ての方法で作成する場合にのみ変更されます｡

03:19.000 --> 03:22.130
このように､ すぐに初期化しないと

03:22.130 --> 03:29.070
そして､ 最終的にどの値がそこに格納されるかをTypeScriptに伝えるのが良い方法です｡

03:29.070 --> 03:35.320
もちろん､ ここでこれを2行に分けるのは少し冗長です｡

03:35.320 --> 03:37.800
デモのためにやっているんです｡ 

03:37.800 --> 03:39.480
しかし､ ここでこれを代入すると､

03:39.480 --> 03:42.460
あらかじめTypeScriptに「これは数字型になります」と伝えているので､

03:42.460 --> 03:44.630
壊れてしまいます｡

03:44.630 --> 03:45.610
そんなことする必要はない｡ 

03:45.610 --> 03:47.420
また､ それをしない場合も有効です｡ 

03:47.420 --> 03:53.470
なぜなら､ この変数に格納される型についてTypeScriptに何も伝えていないため､

03:53.470 --> 03:59.630
TypeScriptはどんな型でも許容するからだ｡

03:59.630 --> 04:02.600
その代わりにここにコロンの数字を入れると､ TypeScriptに「おい､

04:02.600 --> 04:07.370
いずれここに数字が格納されるんだぞ」と教えていることになる｡

04:07.370 --> 04:07.370
そのため､

04:07.370 --> 04:10.060
この例のように文字列を格納した後に他のものを格納すると､

04:10.060 --> 04:15.170
IDEでエラーが発生します｡ もちろん､ コードをコンパイルした場合も同様です｡

04:15.170 --> 04:17.570
すでに前に見たようなエラーが出ます｡ 

04:17.570 --> 04:20.253
つまり､ このようにタイプを割り当てることができるのです｡ 

04:22.300 --> 04:24.920
さて､ TypeScriptが型を推論して､

04:24.920 --> 04:29.310
これを修正させてくれただけでも､ その推論された型を壊すと怒鳴られます｡

04:29.310 --> 04:32.720
実は､ 当然そうなっているからイーブンというのは間違いで､

04:32.720 --> 04:35.670
なぜそうならないのか？

04:35.670 --> 04:37.000
型推論は､ 手動で型を割り当てる必要がないように､

04:37.000 --> 04:39.750
コードを保存するために存在します｡

04:39.750 --> 04:42.730
もちろん､ 間違った型､ つまり推論していない型を使ったら､

04:42.730 --> 04:46.510
TypeScriptは怒りますよ｡

04:46.510 --> 04:48.640
例えば､ resultPhraseをletで作成して変数にした場合､

04:48.640 --> 04:57.670
TypeScriptでは文字列で初期化しているため､ 文字列型であると推測される｡

04:57.670 --> 04:59.850
つまり､ これは基本的に初期化せず､

04:59.850 --> 05:04.970
勝手に型を設定して､ 後から値を代入するのと同じことです｡

05:04.970 --> 05:07.410
さて､ ここでresultPhraseを例えば0に変更すると､

05:07.410 --> 05:17.330
そうしたい理由が何であれ､ ここで0型は文字列型に割り当てられないというエラーが発生します｡

05:17.330 --> 05:21.210
というのも､ 納得ですよね？

05:21.210 --> 05:22.690
TypeScriptは文字列を格納したいのだと推測し､

05:22.690 --> 05:27.290
今度は数値を格納しようとすると､ エラーが発生します｡

05:27.290 --> 05:28.530
それがTypeScriptの仕事であり､ 核となるタスクです｡ 

05:28.530 --> 05:35.280
タイプを確認し､ 間違った使い方をしていたら怒鳴る｡
