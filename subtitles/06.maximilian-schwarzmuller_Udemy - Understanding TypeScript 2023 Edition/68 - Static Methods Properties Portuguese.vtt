WEBVTT

00:02.251 --> 00:03.380
Instrutor: Outro recurso

00:03.380 --> 00:05.350
agradável relacionado a propriedades

00:05.350 --> 00:08.000
e métodos, que existe também em JavaScript quando

00:08.000 --> 00:10.010
você está usando ES6 ou posterior, mas

00:10.010 --> 00:11.180
todos os datilografados

00:11.180 --> 00:14.010
são propriedades e métodos estáticos.

00:14.010 --> 00:17.520
As propriedades estáticas e métodos permitem adicionar propriedades

00:17.520 --> 00:20.620
e métodos às classes que não são acessadas em uma instância

00:20.620 --> 00:22.530
da classe, de modo que não é necessário

00:22.530 --> 00:26.080
chamar primeiro o nome da nova classe, mas que você acessa diretamente

00:26.080 --> 00:28.950
na classe.

00:28.950 --> 00:31.350
Isto é freqüentemente usado para funções

00:31.350 --> 00:35.922
utilitárias que você quer agrupar ou mapear para uma classe logicamente,

00:35.922 --> 00:40.860
ou constantes globais que você também quer armazenar em uma classe.

00:40.860 --> 00:43.270
Um exemplo embutido no JavaScript, que

00:43.270 --> 00:46.050
não é definido por digitação e não é definido

00:46.050 --> 00:48.290
por você, mas parte do JavaScript no

00:48.290 --> 00:51.170
navegador é a função Construtor de Matemática,

00:51.170 --> 00:53.220
ou classe se você quiser chamá-la

00:53.220 --> 00:55.500
assim, que está disponível globalmente

00:55.500 --> 00:59.210
no JavaScript, onde você pode acessar pi como um valor constante

00:59.210 --> 01:01.400
para lhe dar aquele número pi, ou funções,

01:01.400 --> 01:05.050
ou métodos para ser preciso, como pow para calcular o poder

01:05.050 --> 01:08.610
de algo.

01:08.610 --> 01:10.530
Estes são métodos e propriedades aos

01:10.530 --> 01:13.370
quais você não tem acesso na instância da Matemática.

01:13.370 --> 01:16.310
Não é preciso chamar primeiro a nova matemática.

01:16.310 --> 01:19.830
De fato, isso não vai funcionar, mas você acessa essas propriedades

01:19.830 --> 01:22.360
em métodos diretamente sobre a própria classe.

01:22.360 --> 01:25.340
Portanto, a matemática age mais como um espaço de nome como

01:25.340 --> 01:27.370
um mecanismo de agrupamento aqui e isso

01:27.370 --> 01:28.640
é um caso de uso comum para

01:28.640 --> 01:30.480
métodos e propriedades estáticas e

01:30.480 --> 01:33.650
você pode adicioná-las também a suas próprias classes.

01:33.650 --> 01:36.770
Digamos que no Departamento queremos ter um método

01:36.770 --> 01:40.050
que nos ajude a criar funcionários e isso é algo que podemos

01:40.050 --> 01:43.450
querer ter acesso sem instanciar Departamento, porque

01:43.450 --> 01:45.390
normalmente instanciamos nossas

01:45.390 --> 01:46.890
versões mais especializadas,

01:46.890 --> 01:51.290
departamento de TI e departamento de contabilidade e não queremos realmente

01:51.290 --> 01:54.710
instanciar Departamento apenas para chamar um método

01:54.710 --> 01:58.490
utilitário e, portanto, podemos adicionar um método aqui,

01:58.490 --> 02:07.621
criar Funcionário, digamos, onde queremos obter o nome, que é um fio como argumento e lá queremos devolver algo.

02:07.621 --> 02:10.230
Agora, para fazer disso um método estático,

02:10.230 --> 02:12.920
ao qual podemos acessar sem instanciar esta classe,

02:12.920 --> 02:16.250
adicionamos a palavra-chave estática em frente a este método

02:16.250 --> 02:18.549
e, em seguida, aqui talvez retornemos um

02:18.549 --> 02:23.549
objeto onde temos o nome de propriedade mapeado a este valor de nome.

02:25.170 --> 02:27.010
É claro que esse é um método muito simples,

02:27.010 --> 02:28.690
mas você tem a idéia.

02:28.690 --> 02:31.960
Agora, para usar isso, poderíamos ir até lá onde executamos

02:31.960 --> 02:33.490
nosso código e agora digamos

02:33.490 --> 02:36.940
que queremos um novo funcionário, funcionário1.

02:39.300 --> 02:41.020
Bem, então podemos conseguir

02:41.020 --> 02:46.020
isto apenas com o Departamento. criarEmployee e passar em Max, por exemplo,

02:46.920 --> 02:50.680
e se eu então consolar. log(empregado1) devemos

02:50.680 --> 02:53.170
ver um objeto com o nome de Max.

02:53.170 --> 02:55.630
Portanto, se eu salvar isso, de fato aqui

02:55.630 --> 02:58.240
é o funcionário que acabamos de criar.

02:58.240 --> 03:01.200
Portanto, este seria um exemplo típico de um método estático.

03:01.200 --> 03:04.870
Chamamos isso diretamente na classe, sem a nova palavra-chave, e por isso

03:04.870 --> 03:06.360
usamos a classe como um mecanismo

03:06.360 --> 03:09.030
de agrupamento que você poderia dizer e se você quiser

03:09.030 --> 03:11.630
acrescentar uma propriedade estática, você poderia

03:11.630 --> 03:13.470
fazer isso também.

03:13.470 --> 03:17.950
Se você tivesse algo como o ano fiscal aqui que você quer usar atualmente em sua

03:19.730 --> 03:22.040
empresa, você poderia definir isto para,

03:22.040 --> 03:24.980
digamos, 2020 e depois novamente para torná-lo disponível

03:24.980 --> 03:28.560
sem instanciar isto você poderia adicionar estática em frente

03:28.560 --> 03:30.810
desta propriedade, ou em frente daquele

03:30.810 --> 03:33.950
campo e agora acessar aquilo.

03:33.950 --> 03:36.560
Portanto, agora lá embaixo, o console. log. (microempregado criado).

03:38.050 --> 03:42.420
Aqui também podemos acessar o Departamento. fiscal. Um ano assim sem instanciar

03:43.900 --> 03:47.150
e se salvarmos isso, sem surpresas, veremos

03:47.150 --> 03:51.130
2020 ser registrado aqui.

03:51.130 --> 03:53.347
Portanto, estes são métodos e propriedades estáticas.

03:53.347 --> 03:55.250
Uma palavra importante sobre eles, ou uma

03:55.250 --> 03:56.947
coisa que você deve ter em mente.

03:56.947 --> 03:59.067
Ao adicioná-las em uma classe, você

03:59.067 --> 04:03.370
não pode acessá-las de dentro de suas peças não estáticas.

04:03.370 --> 04:04.870
Portanto, se você tiver vontade de

04:04.870 --> 04:10.375
acessar o ano fiscal aqui na construtora, e quiser consolar.

04:10.375 --> 04:10.375
registre-o

04:10.375 --> 04:13.490
aqui, isto, como você pode ver, não vai funcionar.

04:13.490 --> 04:15.600
Estou recebendo aqui um erro de que

04:15.600 --> 04:18.690
a propriedade fiscalYear é um membro estático.

04:18.690 --> 04:20.976
Não podemos acessar isto aqui porque o construtor

04:20.976 --> 04:24.290
e basicamente qualquer coisa lá dentro, todos os métodos também,

04:24.290 --> 04:26.530
que não são marcados com estático, e você

04:26.530 --> 04:29.427
não pode marcar o construtor como estático, a propósito,

04:29.427 --> 04:32.430
não será capaz de acessar propriedades estáticas, porque

04:32.430 --> 04:34.770
isto se refere à instância criada com base

04:34.770 --> 04:37.660
na classe enquanto a propriedade estática não está

04:37.660 --> 04:41.450
disponível na instância, porque toda a idéia por trás das propriedades

04:41.450 --> 04:44.150
estáticas e dos métodos estáticos é que eles estão

04:44.150 --> 04:47.780
desligados das instâncias.

04:47.780 --> 04:50.930
Portanto, é claro que você não pode acessá-los com esta palavra-chave.

04:50.930 --> 04:53.940
Se você quiser usar a propriedade estática ou método

04:53.940 --> 04:56.080
de dentro da classe, você teria que

04:56.080 --> 04:59.380
usar o nome da classe aqui para acessá-la.

04:59.380 --> 05:01.337
Isto lhe dá acesso a propriedades

05:01.337 --> 05:04.290
estáticas e métodos, tudo de dentro da classe.

05:04.290 --> 05:06.593
Isso é uma coisa importante a ter em mente.
