WEBVTT

00:02.140 --> 00:03.620
- ：所以让我们继续练习这些泛型类型,

00:03.620 --> 00:09.970
因为我知道它们可能会让您感到奇怪;最后, 他们真的很简单｡

00:09.970 --> 00:12.180
让我们创建一个普通的泛型函数,

00:12.180 --> 00:14.810
进行计数和打印｡

00:14.810 --> 00:19.810
这个函数应该有一些参数.

00:20.330 --> 00:23.470
让我们将其命名为element, 但名称实际上由您决定,

00:23.470 --> 00:26.530
应该是泛型类型｡

00:26.530 --> 00:28.340
因为我真的不在乎类型,

00:28.340 --> 00:30.380
至少在某些方面｡

00:30.380 --> 00:33.400
假设我们在这个函数中有一个泛型类型,

00:33.400 --> 00:35.800
我们的参数也是这个类型｡

00:35.800 --> 00:38.350
顺便说一下, 这是泛型类型的所有典型特征.

00:38.350 --> 00:40.030
如果您有泛型函式,

00:40.030 --> 00:42.180
则参数通常会是该型别｡

00:42.180 --> 00:43.890
不一定是这样, 但通常这就是你使用泛型函数的方式,

00:43.890 --> 00:49.080
正如你将看到的, 随着你对它们的经验越来越多｡

00:49.080 --> 00:50.670
这里我们有count和print,

00:50.670 --> 00:54.430
这里有泛型类型, 元素也是这个类型.

00:54.430 --> 00:56.500
现在我想返回的是一个有两个元素的nienda元组,

00:56.500 --> 01:07.070
其中第一个元素应该是我的元素本身, 第二个元素应该是一个描述字符串｡

01:07.070 --> 01:10.160
因此, 也许我们把它命名为计数和描述｡ 

01:10.160 --> 01:15.160
这里我有描述文本, 这里我会说没有值,

01:15.410 --> 01:19.890
如果我们传入一个没有长度的元素,

01:19.890 --> 01:22.620
我想使用它｡

01:22.620 --> 01:25.570
因为我对count和describe的想法是我们可以传入一个数组或字符串,

01:25.570 --> 01:32.040
然后我们得到字符串或数组中的字符或元素的数量｡

01:32.040 --> 01:34.040
所以如果我们得到一个空字符串或者空数组,

01:34.040 --> 01:52.430
我想使用getno value, 但是这里如果我检查元素点长度大于零, 那么我想把描述文本设置为getplus元素点长度plus元素｡

01:55.850 --> 01:58.100
您可以更具体地检查此处的长度是否等于1,

01:58.100 --> 02:03.100
然后说得到了一个元素, 否则如果元素长度大于1,

02:06.590 --> 02:21.173
我们将使用描述文本等于得到了加上元素长度的元素, 这样我们就得到了正确的复数形式｡

02:22.850 --> 02:27.040
现在, 这里有第二个元素的描述文本, 并在这里返回｡

02:27.040 --> 02:27.040
现在你已经看到了关于长度的各种抱怨｡

02:29.480 --> 02:32.350
因为不清楚元素是否有长度｡ 

02:32.350 --> 02:34.770
所以也许我们应该说清楚｡ 

02:34.770 --> 02:38.430
我们可以通过创建一个新的接口或者一个自定义类型来实现,

02:38.430 --> 02:41.060
在这里, 我将创建一个接口, 我将它命名为lengage,

02:41.060 --> 02:50.820
它最终只是保证我们有一个带有length属性的对象, 它最终会产生一个数字｡

02:50.820 --> 02:52.870
这里我们可以设置一个约束条件, T,

02:52.870 --> 02:54.740
extends, long.

02:54.740 --> 02:57.710
所以我们知道无论我们得到什么, 我们都有一个长度属性,

02:57.710 --> 03:01.053
数组或字符串都有一个长度属性｡

03:02.030 --> 03:07.030
在这里, 我可以控制台日志计数和描述,

03:07.500 --> 03:11.240
并传入, 让我们说, 你好｡

03:11.240 --> 03:14.280
这是因为字符串有长度属性｡ 

03:14.280 --> 03:15.290
它不是一个物体｡ 

03:15.290 --> 03:19.980
它是一个字符串, 但在幕后, Javascript会将其转换为一个对象,

03:19.980 --> 03:23.940
并在需要时添加一个长度属性｡

03:23.940 --> 03:23.940
所以我们可以这样称呼它｡

03:23.940 --> 03:26.960
首先输入script, 这里我们返回一个数组,

03:26.960 --> 03:33.580
其中有一个字符串或T类型的元素｡

03:33.580 --> 03:33.580
现在我想要一个元组,

03:33.580 --> 03:36.060
所以我会更具体一些, 把返回类型设置成一个数组,

03:36.060 --> 03:43.850
只有两个元素, 第一个元素是T类型, 第二个元素是string类型.

03:43.850 --> 03:46.270
所以现在我只是说, 我们在这里返回一个元组,

03:46.270 --> 03:54.110
其中第一个元素是泛型类型的任何元素, 第二个元素是字符串.

03:54.110 --> 03:56.820
现在, 如果我们保存这个, 重新编译,

03:56.820 --> 04:02.330
没有错误, 打印, 有九个元素, 因为我们有九个字符｡

04:04.320 --> 04:06.890
我们也可以用一个数组来调用这个函数,

04:06.890 --> 04:12.460
这里有体育和烹饪, 现在你会看到我们得到了两个元素作为描述文本,

04:12.460 --> 04:15.990
或者用一个空数组, 当然, 在这种情况下,

04:15.990 --> 04:18.660
如果我保存我们没有得到任何值,

04:18.660 --> 04:24.103
但是我们不能用一个数字来调用这个函数, 因为数字没有长度属性,

04:24.103 --> 04:28.090
所以这个函数不起作用｡

04:28.090 --> 04:32.900
这里我们又得到了泛型函数｡ 

04:32.900 --> 04:35.043
想法和以前的功能差不多｡ 

04:35.043 --> 04:40.540
我们想对这里得到的数据类型有点不具体｡

04:40.540 --> 04:40.540
我们并不关心它是字符串,

04:40.540 --> 04:45.610
数组, 还是其他有长度属性的东西.

04:45.610 --> 04:45.610
我们只关心它是否有长度属性,

04:45.610 --> 04:49.980
然后我们想对它做些什么, 因为我们在代码中依赖长度属性, 所以我们需要保证我们得到了长度属性,

04:49.980 --> 04:59.490
但除此之外, 我们真的不关心我们得到的是哪种类型的数据｡

04:59.490 --> 04:59.490
我不想把它锁定在字符串或数组上,

05:01.820 --> 05:05.830
也不想创建一堆重载来处理所有不同的可能类型｡

05:05.830 --> 05:08.124
我也不想在这里创建一个很长的联合类型,

05:08.124 --> 05:10.970
因为我可能会忘记有length属性的类型,

05:10.970 --> 05:13.610
或者如果我创建了自己的, 有length属性的对象,

05:13.610 --> 05:21.580
我可能不允许它, 如果我把它限制为类型, 字符串和数组, 或者类似的东西｡

05:21.580 --> 05:23.500
因此, 我想更灵活一些, 对于泛型类型,

05:23.500 --> 05:27.550
我们可以这样, 我们不关心确切的类型｡

05:27.550 --> 05:33.363
在这里, 由于约束, 我只关心它具有长度属性这一事实｡
