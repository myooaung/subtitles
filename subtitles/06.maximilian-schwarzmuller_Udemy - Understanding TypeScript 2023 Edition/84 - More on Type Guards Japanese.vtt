WEBVTT

00:02.220 --> 00:04.080
-：今､ 交差点タイプは1つです｡ 

00:04.080 --> 00:05.470
しかし､ もっとよく使われるのは別の機能で､

00:05.470 --> 00:07.800
それはタイプガードです｡ 実はこの機能､

00:07.800 --> 00:10.590
すでに少し使っています｡

00:10.590 --> 00:12.400
ここではCombinableを使ってみましょう｡ 

00:12.400 --> 00:18.020
これは文字列か数値かのユニオン型です｡ タイプガードはユニオン型に役立ちます｡

00:18.020 --> 00:26.200
柔軟性があるのはいいことですが､ 実行時にどちらの型を取得するかを正確に知る必要がある場合が多いからです｡

00:26.200 --> 00:28.630
ここでadd関数があるとします｡

00:28.630 --> 00:44.640
この関数はCombinable型､ つまり文字列または数値である必要があるので､ ここでは実際にaという名前を付けます｡

00:44.640 --> 00:47.020
これがうまくいかないことは､ 過去に経験済みです｡ 

00:47.020 --> 00:51.320
代わりに､ 例えばtypeof aがstringと等しいか､ typeof

00:51.320 --> 00:53.740
bがstringと等しいかをチェックし､

00:55.660 --> 01:04.681
等しい場合はaを返すようにする必要がある｡

01:04.681 --> 01:04.681
toStringにbを加えたもの｡  を文字列に変換します｡ 

01:04.681 --> 01:06.750
そうでなければ､ このif文に入らない場合は､

01:06.750 --> 01:19.710
このようにa + bを返します｡ これは､ aおよびbが数字でなければならないことをタイプグループが知っているからです｡

01:19.710 --> 01:25.280
これはタイプガードと呼ばれ､

01:25.280 --> 01:34.830
ユニオン型の柔軟性を生かしながら､

01:34.830 --> 01:51.670
実行時にコードが正しく動作することを保証します｡

01:51.670 --> 01:55.310
今度はtypeofを使ったタイプガードです｡ 

01:55.310 --> 01:58.970
また､ 他の種類のタイプガードも書くことができます｡ 

01:58.970 --> 02:03.050
そのために､ 先ほど作成した管理者と従業員のタイプに戻り､

02:03.050 --> 02:06.943
管理者には権限を､ 従業員には開始日を設定しました｡

02:08.590 --> 02:11.810
そして､ その両方を兼ね備えたのが､ ElevatedEmployeeです｡ 

02:11.810 --> 02:14.980
ここでまた､ 別のタイプを作成します｡ 

02:14.980 --> 02:16.330
それが「UnknownEmployee」です｡ 

02:18.000 --> 02:21.940
これは､ ただの社員か管理者のどちらかです｡ 

02:21.940 --> 02:25.540
そこで､ 私の2つのカスタム・オブジェクト・タイプを使ってユニオン・タイプを作成しました｡ 

02:25.540 --> 02:28.173
つまり､ 無名の社員はこの2つのどちらかです｡ 

02:29.230 --> 02:36.420
さて､ printEmployeeInformationという関数で従業員を渡す必要があるかもしれませんが､ これはunknown

02:36.420 --> 02:39.660
employeeという型である必要があります｡

02:39.660 --> 02:44.030
さてここで､ コンソールをしたいと思います｡  従業員に関するさまざまな情報を記録します｡

02:44.030 --> 02:47.210
例えば､ empからの名前｡  という名前になります｡ どちらのタイプの社員も

02:47.210 --> 02:48.580
name プロパティを持っているので､

02:48.580 --> 02:52.140
問題なく動作します｡

02:52.140 --> 03:01.520
でも､ それならコンソールもしたい｡  empにアクセスして権限をログオンします｡

03:01.520 --> 03:01.520
というのも､

03:01.520 --> 03:07.100
TypeScriptはこの引数が常に存在することを確認できないからだ｡

03:07.100 --> 03:16.260
UnknownEmployeeは特権プロパティを持たない普通の従業員かもしれない｡

03:16.260 --> 03:18.330
それは管理者だけが持っている｡ 

03:18.330 --> 03:20.100
そこで今度は､ ここにタイプガードが必要です｡ 

03:20.100 --> 03:24.530
ただ問題は､ typeofでは何も勝てないということです｡ 

03:24.530 --> 03:29.470
従業員のタイプをチェックしても､ それは実行時にオブジェクトになるだけです｡

03:29.470 --> 03:32.940
だからといって､ この性質を持っているかどうかはわからない｡

03:32.940 --> 03:34.960
したがって､ このifチェックのコードを動かしても､

03:34.960 --> 03:39.750
オブジェクトはまあ､ ただのオブジェクトなので､ TypeScriptは前より幸せになれない｡

03:39.750 --> 03:41.920
特性について何も教えてくれない｡ 

03:41.920 --> 03:44.980
このチェックは実行時に行われ､

03:44.980 --> 03:49.840
JavaScript を使用するため､

03:49.840 --> 03:52.560
typeof が取得したものを

03:52.560 --> 04:05.610
JavaScript が知っている型と比較するだけであることに注意してください｡

04:05.610 --> 04:11.020
それはTypeScriptの世界だけで､ コンパイルされたJavaScriptの世界には存在しない｡

04:11.020 --> 04:13.990
だから､ だから､ これもダメなんです｡ 

04:13.990 --> 04:17.960
さて､ ここでの回避策は､ 別のifチェックを使うことです｡ 

04:17.960 --> 04:20.240
権限にアクセスしたいことは分かっているので､

04:20.240 --> 04:25.240
従業員権限があるかどうかを確認することができました｡

04:26.400 --> 04:30.690
ただ問題は､ TypeScriptではこのプロパティにアクセスすることができず､

04:30.690 --> 04:36.200
このようにチェックすることもできないのですが､ 別の方法でチェックすることができるのです｡

04:36.200 --> 04:40.000
JavaScriptに内蔵されているinキーワードを使えばいいんです｡ 

04:40.000 --> 04:46.690
文字列として書かれたprivilegesがempにあるかどうかを確認することができます｡

04:46.690 --> 04:49.130
これはJavaScriptのコードで､

04:49.130 --> 04:53.480
employeeのプロパティとしてこれが存在するかどうかをチェックし､

04:53.480 --> 05:04.543
存在する場合はTypeScriptがこのチェックを検出し､ したがってこのifチェックの内部でこのプロパティにアクセスできるようにするものである｡

05:05.852 --> 05:08.380
そして､ startDateについてもこれを繰り返して､

05:08.380 --> 05:12.240
startDateがここのプロパティであるかどうかをチェックし､

05:12.240 --> 05:18.730
したがって､ このifチェックでこれを出力することもできるのです｡

05:18.730 --> 05:23.687
これで､ printEmployeeInformationを呼び出して､

05:24.650 --> 05:28.363
作成した1人の社員e1を渡すと､ エラーなしでコンパイルされて､

05:31.410 --> 05:42.530
確かに特権と､ まあ､ ここにもデータはもちろん､ Start Dateと書いてあるはずです｡

05:42.530 --> 05:45.820
でも､ それを使えば､ 期待通りの出力が得られます｡ 

05:45.820 --> 05:48.590
一方､ これらのフィールドを持たない従業員を渡すと､

05:48.590 --> 05:53.090
たとえば､ startDateだけあって権限のない従業員をその場で作成した場合､

05:53.090 --> 06:05.723
すべての作業が完了し､ エラーなしでコンパイルされるのですが､ そこにあるifチェックにより､ 権限については何も表示されないだけです｡

06:07.650 --> 06:09.800
クラスを扱う場合､ もう一つのタイプガード､

06:09.800 --> 06:16.520
instanceofタイプガードを使うこともできます｡

06:16.520 --> 06:21.460
例えば､ Carというクラスがあり､ そのクラスにはdriveメソッドがあり､

06:21.460 --> 06:26.523
consoleと言うだけだとします｡

06:26.523 --> 06:26.523
Drivingというクラスがあり､

06:31.750 --> 06:40.250
Truckという別のクラスもdriveメソッドを持っています｡

06:40.250 --> 06:43.980
また､ loadCargoメソッドでは､ 金額（数値）を指定します｡

06:43.980 --> 06:46.570
ここでは､ 「Loading cargo

06:46.570 --> 06:53.570
plus amount」というダミーコードを書いています｡

06:53.570 --> 06:53.570
なんか､ おっと､ 金額､ そんな感じですね｡ 

06:53.570 --> 06:59.320
これで2つのクラスができました｡ もちろん､ 駆動方法という共通点もありますが､

06:59.320 --> 07:02.090
相違点もあります｡

07:02.090 --> 07:03.890
ここでまた､

07:03.890 --> 07:08.200
車かトラックかのユニオンタイプ､

07:08.200 --> 07:18.030
Vehicleを作成することができます｡

07:18.050 --> 07:21.873
今､ useVehicleという関数がありますが､

07:23.890 --> 07:31.350
これは単に車両を得ることを期待するものです｡

07:31.350 --> 07:34.203
ここで､ 車両を手に入れました｡ ここで言う目標は､

07:35.420 --> 07:37.490
車両でできることすべて､ つまり､

07:37.490 --> 07:40.040
運転と荷物の積載です｡

07:40.040 --> 07:45.420
だから､ もちろん､ ビークルを呼べる｡  ドライブが常に存在するため､ しかし､ 車両のために｡

07:45.420 --> 07:45.420
loadCargoは､

07:45.420 --> 07:50.010
トラックだけが持っているものなので､ 問題がありますね｡

07:50.010 --> 07:52.720
クルマにはないから､ これではダメだ｡ 

07:52.720 --> 07:56.440
これで､ もちろん､ もう一度､ loadCargoがvehicleにあるかどうかを確認し､

07:56.440 --> 07:59.513
もしそうなら､ それを使うことができるようになります｡

08:00.760 --> 08:05.760
少なくとも､ ここでその誤字を直せば｡ 

08:06.430 --> 08:09.480
これを保存して､ useVehicleを呼び出してv1を渡し､

08:09.480 --> 08:13.230
v2を指定してもう一度呼び出すと､ すべてを保存してコンパイルされ､

08:13.230 --> 08:17.400
動作します｡

08:17.400 --> 08:21.680
今のは一つの方法です｡ 

08:21.680 --> 08:23.340
もう一つの方法は､ もう少しエレガントで､

08:23.340 --> 08:31.920
このプロパティ文字列をミスタイプするリスクを排除するため､ instanceofを使用することである｡

08:31.920 --> 08:34.080
vehicleがTruckのインスタンスであるかどうかを確認することができます｡ 

08:34.080 --> 08:39.080
そうであれば､ loadCargoメソッドを持つことが分かっている｡ 

08:39.360 --> 08:42.510
instanceofはバニラJavaScriptに組み込まれている通常の演算子なので､

08:42.510 --> 08:47.430
これはTypeScriptのコードではない｡

08:47.430 --> 08:49.280
typeofと同様､ JavaScriptの一部であり､

08:49.280 --> 08:52.250
実行時に実行される｡

08:52.250 --> 08:54.290
JavaScriptはTruckの型を知らないが､

08:54.290 --> 09:01.490
コンストラクタ関数は知っている｡ 結局クラスはコンストラクタ関数に変換され､ TypeScriptはTruckのコンストラクタ関数に基づいて､

09:01.490 --> 09:06.580
vehicleが作られたかどうかを調べることができるのだ｡

09:06.580 --> 09:11.970
つまり､ クラスはJavaScriptが理解できるもの､ つまりコンストラクタ関数にコンパイルされているので､

09:11.970 --> 09:15.450
それを利用することができるのです｡

09:15.450 --> 09:17.210
もしここでクラスの代わりにインターフェイスを使うとしたら､

09:17.210 --> 09:27.300
もちろんここに実装を持つことはできませんが､ それはオブジェクト・リテラル記法でオブジェクトを作成するときに行います｡ そして､ インターフェイスは学んだように､ JavaScriptのコードにコンパイルされていないので､

09:27.300 --> 09:34.370
実行時に使うことはできません｡

09:34.370 --> 09:37.160
クラスについては､ JavaScriptがクラスとコンストラクタ関数をサポートしているので､

09:37.160 --> 09:44.500
それが可能です｡ そして､ instanceofを使えば､ あるオブジェクトがそのクラスをベースにしているかどうかを調べることができます｡

09:44.500 --> 09:47.660
もし､ それがわかれば､ loadCargoの機能ができる｡ 

09:47.660 --> 09:51.850
これがタイプガードなんですね｡ 

09:51.850 --> 09:53.480
結局､ タイプガードというのは､

09:53.480 --> 09:55.890
あるプロパティやメソッドが存在するかどうかを､

09:55.890 --> 10:08.470
それを使おうとする前にチェックする､ あるいはその型を使って何かできるかをチェックする､ という考え方やアプローチを表す言葉に過ぎないのです｡

10:08.470 --> 10:10.220
オブジェクトの場合はinstanceofやinで､

10:10.220 --> 10:29.050
その他の型の場合はtypeofで対応できます｡ したがって､ ユニオン型がもたらす柔軟性を利用しながら､ 実行時に得られる正確な型に基づいてどちらかの処理を行うコードを書くことができるようになりました｡
