WEBVTT

00:02.090 --> 00:04.730
Instrutor: Agora, antes de mergulharmos em qualquer característica, você

00:04.730 --> 00:07.002
encontrará um link para esta página em anexo a esta palestra.

00:07.002 --> 00:11.350
Esta página basicamente lista todos os recursos JavaScript mais

00:11.350 --> 00:13.610
ou menos modernos, que navegadores

00:13.610 --> 00:16.770
suportam esses recursos e também que compiladores

00:16.770 --> 00:19.700
suportam esses recursos.

00:19.700 --> 00:23.150
E lá você também encontra TypeScript, TypeScript

00:23.150 --> 00:25.310
combinado com core-js, que é um

00:25.310 --> 00:27.210
fornecedor de polifill.

00:27.210 --> 00:28.820
Mas geralmente isto descreve

00:28.820 --> 00:32.070
o que o TypeScript é capaz de compilar.

00:32.070 --> 00:34.110
Agora você pode sempre usar este recurso se estiver

00:34.110 --> 00:35.990
procurando por uma característica específica

00:35.990 --> 00:37.960
como, digamos, a palavra-chave const, Onde você

00:37.960 --> 00:40.860
quer saber se o TypeScript funciona ou não com isso.

00:40.860 --> 00:43.340
Então você pode ver como funciona com isso, e quais

00:43.340 --> 00:46.580
são as restrições, quais navegadores suportam isso.

00:46.580 --> 00:48.250
A propósito, isto também lhe dá uma

00:48.250 --> 00:51.090
dica a respeito de quais navegadores você pode querer alvejar,

00:51.090 --> 00:53.967
a respeito do alvo TypeScript, e assim por diante.

00:53.967 --> 00:55.260
Portanto, este é um grande

00:55.260 --> 00:58.600
recurso que permite alternar entre diferentes iterações do JavaScript,

00:58.600 --> 01:01.940
e as características de cada iteração introduzida, e como estas características

01:01.940 --> 01:04.220
são suportadas.

01:04.220 --> 01:06.140
Portanto, definitivamente use isto como um recurso

01:06.140 --> 01:08.800
para descobrir o que você pode usar, o que você pode compilar e quais

01:08.800 --> 01:11.060
metas você pode precisar estabelecer.

01:11.060 --> 01:14.060
E com isso, vamos começar com uma das introduções mais

01:14.060 --> 01:17.030
importantes e óbvias, e freqüentemente utilizada,

01:17.030 --> 01:19.260
acrescentou o Next-Gen JavaScript.

01:19.260 --> 01:21.780
A propósito, com o Next-Gen JavaScript,

01:21.780 --> 01:24.700
quero dizer, ES6 ou mais recente.

01:24.700 --> 01:27.860
E isso é let ou const const, do que estou falando.

01:27.860 --> 01:32.750
Ele permite definir constantes ou variáveis.

01:32.750 --> 01:35.350
A diferença é que as constantes, portanto,

01:35.350 --> 01:38.730
as variáveis definidas com a palavra-chave const não podem

01:38.730 --> 01:39.910
ser alteradas.

01:39.910 --> 01:42.410
Se você tentar atribuir um novo valor aqui

01:42.410 --> 01:44.270
mesmo que ele tenha o tipo correto,

01:44.270 --> 01:47.220
você receberá um erro porque é uma constante.

01:47.220 --> 01:48.280
A propósito, isto é um

01:48.280 --> 01:50.200
erro que é formado pelo TypeScript.

01:50.200 --> 01:53.340
No Vanilla JavaScript, você receberia um erro do navegador quando executasse

01:53.340 --> 01:55.100
seu código aqui, e essa é a idéia por trás

01:55.100 --> 01:57.280
do TypeScript, como você aprendeu, já recebemos

01:57.280 --> 02:00.410
um erro enquanto você está escrevendo o código, porque isso, é claro,

02:00.410 --> 02:02.990
é melhor para nós como desenvolvedores.

02:02.990 --> 02:04.930
Ele nos permite corrigir este código

02:04.930 --> 02:07.820
mais cedo antes de testá-lo no console.

02:07.820 --> 02:11.330
Portanto, aqui, se removermos isso ou comentarmos esta

02:11.330 --> 02:12.830
linha, agora ela se recompila

02:12.830 --> 02:14.400
e, portanto, não recebemos

02:14.400 --> 02:17.130
nenhum erro no navegador, também.

02:17.130 --> 02:20.860
Portanto, isso é constante. Vamos ser uma variável que pode ser

02:20.860 --> 02:23.620
alterada e, portanto, é claro, é semelhante a var.

02:23.620 --> 02:27.260
Var também ainda existe porque o JavaScript funciona de tal forma que as

02:27.260 --> 02:29.550
características não são subitamente tiradas,

02:29.550 --> 02:33.460
porque então os navegadores mais antigos e seus scripts podem quebrar.

02:33.460 --> 02:35.160
Mas você não deve mais usar o var.

02:35.160 --> 02:37.860
E por que você não deve mais usar o var?

02:37.860 --> 02:39.670
Quero dizer, faz sentido que tenhamos constantes,

02:39.670 --> 02:42.520
porque isso realmente acrescenta uma nova característica, as constantes.

02:42.520 --> 02:43.380
Mas por que deixar?

02:43.380 --> 02:45.380
Por que eles introduziram uma nova palavra-chave aqui?

02:45.380 --> 02:47.223
Por que eles não se limitaram a var?

02:48.280 --> 02:51.460
Deixar e constar ter uma diferença importante para var.

02:51.460 --> 02:53.300
Bem, a diferença óbvia para Const é que

02:53.300 --> 02:55.240
o valor não pode ser mudado, mas para Let,

02:55.240 --> 02:57.040
nós também obtemos uma diferença.

02:57.040 --> 03:00.930
E esse é o escopo no qual essa variável está disponível.

03:00.930 --> 03:04.363
Agora você deve conhecer este conceito de escopos em JavaScript.

03:05.609 --> 03:09.260
E com var, você tem um escopo global e um escopo funcional.

03:09.260 --> 03:10.700
Isso significa que as variáveis

03:10.700 --> 03:12.550
que você define fora das funções estão

03:12.550 --> 03:15.340
disponíveis em todos os lugares em seus scripts.

03:15.340 --> 03:17.410
As variáveis definidas dentro das funções

03:17.410 --> 03:19.370
só estão disponíveis nessa função.

03:19.370 --> 03:22.610
Por exemplo, aqui. Se eu tivesse uma função

03:22.610 --> 03:27.610
a acrescentar, e talvez houvesse dois números, a e b.

03:27.670 --> 03:29.750
Então podemos adicionar uma variável

03:29.750 --> 03:32.280
lá dentro com resultado var, digamos, e definimos

03:32.280 --> 03:34.730
resultado = a + b então, e então retornamos resultado,

03:34.730 --> 03:36.230
e claro, poderíamos ter escrito

03:36.230 --> 03:38.430
isto de uma forma mais curta, mas quero mostrar

03:38.430 --> 03:40.570
o que var faz.

03:40.570 --> 03:41.860
E isso seria bom.

03:41.860 --> 03:43.012
E o resultado só estaria disponível

03:43.012 --> 03:44.188
dentro desta função.

03:44.188 --> 03:47.723
Se eu tentar consolar aqui o resultado do log que

03:47.723 --> 03:49.470
falharia porque só está

03:49.470 --> 03:52.190
disponível no escopo desta função.

03:52.190 --> 03:53.970
Se eu o defino fora do porto var, tudo funciona

03:53.970 --> 03:56.610
porque agora está disponível globalmente, portanto aqui

03:56.610 --> 03:58.180
eu posso acessá-lo.

03:58.180 --> 04:00.220
E também, da forma como o JavaScript funciona,

04:00.220 --> 04:03.580
você pode acessar variáveis em um nível superior.

04:03.580 --> 04:05.210
Assim, dentro de uma função, você

04:05.210 --> 04:08.260
pode trabalhar com o escopo de variáveis para esta função,

04:08.260 --> 04:11.100
mas todas as variáveis têm um escopo maior, como o escopo

04:11.100 --> 04:12.563
global aqui.

04:13.580 --> 04:14.980
Então, isso é var.

04:14.980 --> 04:19.180
Agora, para o let, o comportamento é geralmente o mesmo.

04:19.180 --> 04:21.580
Isto funciona e isto funciona.

04:21.580 --> 04:23.800
Portanto, geralmente é o mesmo para o let.

04:23.800 --> 04:27.180
Mas uma diferença importante é que, para var, você

04:27.180 --> 04:30.860
realmente só tem alcance global e funcional.

04:30.860 --> 04:32.460
E se as declarações?

04:32.460 --> 04:36.720
Se verificarmos idade > 20 anos aqui, e então lá dentro criamos

04:36.720 --> 04:38.889
uma variável, isOld, e definimos

04:38.889 --> 04:41.190
isto como verdadeiro, então se

04:41.190 --> 04:44.500
um log de console forOld aqui obtemos um erro

04:44.500 --> 04:46.270
no TypeScript, mas na verdade

04:46.270 --> 04:50.090
não obteríamos um em JavaScript.

04:50.090 --> 04:53.620
Este código aqui, se você pegá-lo apenas para ver que funciona, e mover para

04:53.620 --> 04:56.280
as ferramentas de desenvolvimento JavaScript ali no

04:56.280 --> 04:57.190
console, e nós o colamos

04:57.190 --> 04:59.120
ali e batemos em enter, você vê que true está

04:59.120 --> 05:00.970
sendo impresso aqui.

05:01.830 --> 05:02.960
E de fato, se você tentar

05:02.960 --> 05:05.040
acessar isOld, você se torna verdadeiro.

05:05.040 --> 05:08.380
Portanto, esta variável isOld, é registrada globalmente,

05:08.380 --> 05:10.530
e não apenas dentro da declaração if.

05:10.530 --> 05:11.700
Porque com var, o JavaScript

05:11.700 --> 05:13.080
não conhece nenhum outro

05:13.080 --> 05:15.860
escopo além de funções e global.

05:15.860 --> 05:17.400
E isso muda com o let.

05:17.400 --> 05:19.690
Agora, como eu disse, o TypeScript reclama, no entanto,

05:19.690 --> 05:21.600
porque este não é um bom código para escrever,

05:21.600 --> 05:23.170
mas, tecnicamente, funcionaria.

05:23.170 --> 05:25.100
Com o let, isso muda.

05:25.100 --> 05:26.350
Agora, com o let, isto realmente

05:26.350 --> 05:29.880
só está disponível dentro destes suportes encaracolados.

05:29.880 --> 05:32.300
Porque Let e Const introduziu um novo conceito

05:32.300 --> 05:33.540
chamado escopo de bloco,

05:33.540 --> 05:36.550
o que significa que uma variável ou constante está sempre

05:36.550 --> 05:40.420
disponível no bloco em que você a define ou em qualquer bloco inferior.

05:40.420 --> 05:43.060
E um bloco é, basicamente, sempre um corte com um aparelho

05:43.060 --> 05:44.900
de costura, como você o tem para uma

05:44.900 --> 05:46.710
declaração de se, em loop, em função,

05:46.710 --> 05:48.760
ou até mesmo, isso é possível, se você simplesmente

05:48.760 --> 05:50.590
adicionar aparelhos de costura como

05:50.590 --> 05:52.670
este.

05:52.670 --> 05:54.230
Qualquer variável definida

05:54.230 --> 05:56.760
aqui só estaria disponível nesse bloco.

05:56.760 --> 05:57.700
E isso é bom porque

05:57.700 --> 06:00.000
o obriga a escrever um código mais limpo

06:00.000 --> 06:02.470
e evitar situações como esta.

06:02.470 --> 06:03.640
Portanto, apenas para oferecer

06:03.640 --> 06:05.530
uma prova de que existe uma diferença no navegador,

06:05.530 --> 06:09.750
se eu copiar este código usando let, e eu recarregar minha página aqui, e agora eu digito isto aqui, você vê

06:09.750 --> 06:14.706
que eu recebo um erro que isOld não está definido.

06:14.706 --> 06:14.706
Não recebemos um erro antes.

06:14.706 --> 06:19.706
De fato, se eu tentasse produzir isOld, eu teria esse erro novamente.

06:20.070 --> 06:21.060
Portanto, essa é a diferença.

06:21.060 --> 06:23.370
E portanto, let e const é melhor, não só porque

06:23.370 --> 06:25.740
obtemos esta característica constante, mas

06:25.740 --> 06:29.150
também porque somos forçados a escrever código mais limpo.

06:29.150 --> 06:30.130
Portanto, deixe-me comentar isto

06:30.130 --> 06:31.230
para que funcione novamente.
