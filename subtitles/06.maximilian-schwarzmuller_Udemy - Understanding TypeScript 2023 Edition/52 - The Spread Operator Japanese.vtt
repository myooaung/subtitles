WEBVTT

00:02.250 --> 00:04.530
講師：配列やオブジェクトに関連する便利な機能や､

00:04.530 --> 00:13.600
配列やオブジェクトに格納されたデータを取得する方法についても紹介しました｡

00:13.600 --> 00:17.180
そのために､ ここに新しい配列を追加しましょう｡ 趣味としましょう｡

00:17.180 --> 00:19.880
これは文字列の配列にすることができます｡

00:22.520 --> 00:33.030
スポーツや料理のように､ インデックスで要素を取得することができます｡

00:33.030 --> 00:36.150
しかし､ このようなJavaScriptの基本的なことは知っておく必要があります｡ 

00:36.150 --> 00:43.910
次世代JavaScriptでは､ 配列のすべての値を取り出したい場合に便利な機能が導入されています｡

00:43.910 --> 00:44.990
どんな時に必要なんだ？

00:44.990 --> 00:48.670
例えば､ アクティブな趣味があるとすると､

00:48.670 --> 00:56.510
ハイキングが趣味で､ スポーツや料理も加えたいと思っています｡

00:56.510 --> 01:01.290
ところで､ どうやって定数にプッシュするのか不思議に思うかもしれませんが､

01:01.290 --> 01:08.130
配列はオブジェクトであり､ オブジェクトは参照値であることを覚えておいてください｡

01:08.130 --> 01:11.010
プッシュすると､ メモリは変更されますが､ アドレスは変更されません｡ 

01:11.010 --> 01:20.170
もしこれで何もわからなければ､ このトピックに関してこのレクチャーに添付した追加のリソースをチェックしてください｡

01:20.170 --> 01:27.540
ではこの例に戻りますが､ ここでプッシュすることができます｡

01:27.540 --> 01:30.920
どの型が実際にそれを検出するかというと､ 文字列の配列に文字列の配列を追加したい場合､

01:30.920 --> 01:36.143
それはダメだと教えてくれるのです｡

01:37.110 --> 01:40.390
その代わり､ pushは単一の値を受け取るので､

01:40.390 --> 01:44.450
趣味をゼロで渡すことができます｡ 実はpushは無制限の引数を受け取るので､

01:44.450 --> 01:51.240
このように複数のアイテムを一度に順番にプッシュすることができます｡

01:51.240 --> 01:54.890
しかし､ それではちょっと面倒なので､ スプレッドオペレーターの出番です｡

01:54.890 --> 01:57.700
このように､ 3つの点があり､ 奇妙に見えますが､

01:57.700 --> 02:04.770
これは[Hypescript?

02:04.770 --> 02:04.770
その後に､

02:04.770 --> 02:11.700
拡散したい配列やオブジェクトを指定します｡

02:11.700 --> 02:15.160
これはJavaScriptに命令するものです｡

02:15.160 --> 02:25.500
これはモダンなJavaScriptで利用できるバニラJavaScriptオペレータで､

02:25.500 --> 02:41.740
JavaScriptに配列の後のすべての要素を引き出して､ 基本的に値のリストとして追加するように命令します｡

02:41.740 --> 02:46.220
そこでは､ 既存のアレイをそのアレイに広げることもできます｡ 

02:46.220 --> 02:48.950
つまり､ カンマ区切りのリストが必要なときはいつでも､

02:48.950 --> 02:54.360
配列と一緒にスプレッド演算子を使えば､ そのようなカンマ区切りのリストを得ることができるのです｡

02:54.360 --> 02:56.660
これがスプレッド演算子の考え方で､

02:56.660 --> 03:00.663
それゆえ配列の要素を引き出すのにとても便利なのです｡

03:01.860 --> 03:04.380
Spread Operatorは､ 配列だけでなく､

03:04.380 --> 03:07.880
オブジェクトにも存在することをすべて示しています｡

03:07.880 --> 03:10.990
例えば､ Maxという名前のキーと30というhのキーを持つ人がいて､

03:10.990 --> 03:16.640
その人をコピーして作りたいとします｡

03:16.640 --> 03:19.060
さて､ このように人を代入すると､

03:19.060 --> 03:22.680
実は､ メモリ上のこの人オブジェクトのポインタを､

03:22.680 --> 03:27.050
このコピー人定数にコピーしていることになるのです｡

03:27.050 --> 03:32.360
また､ これだけではよくわからないという方は､ 添付の私の参考値リソースをご確認ください｡

03:32.360 --> 03:36.190
つまり､ 実際にはそのオブジェクトのコピーを作っているわけではないのです｡ 

03:36.190 --> 03:40.880
さて､ 実際のコピーを作成するには､ オブジェクトに対してスプレッド演算子を使用します｡

03:40.880 --> 03:43.400
中括弧で新しいオブジェクトを作成し､

03:43.400 --> 03:46.510
コピーしたい最初のオブジェクトにスプレッド演算子を使い､

03:46.510 --> 03:49.630
3つの点を付けます｡

03:49.630 --> 03:56.310
さて､ これはすべての要素を取り出すものですが､ もちろんここでは要素は配列のような単一の値ではなく､

03:56.310 --> 03:58.630
キーと値のペアになっています｡

03:58.630 --> 04:00.550
ここでは､ キーとバリューのペアを取得しました｡ 

04:00.550 --> 04:04.110
このキー・バリュー・ペアはそこから引き出され､

04:04.110 --> 04:12.920
キー・バリュー・ペアが必要な場所､ つまり通常は決して追加されないオブジェクトで使用することができるのです｡

04:12.920 --> 04:15.447
したがって､ この何もないオブジェクトに､

04:15.447 --> 04:23.700
今度はpersonのキー・バリュー・ペアを追加し､ ここで新しいオブジェクトを作り､ キー・バリュー・ペアに追加しただけなので､

04:23.700 --> 04:30.803
メモリ内のオブジェクトを指すポインタだけでなく､ 元のオブジェクトの完全なコピーを手に入れたのです｡
