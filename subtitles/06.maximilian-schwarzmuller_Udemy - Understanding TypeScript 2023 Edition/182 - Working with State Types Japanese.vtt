WEBVTT

00:02.260 --> 00:03.920
説明：このように配列を更新しても､

00:03.920 --> 00:05.340
コンポーネントは再レンダリングされないので､

00:05.340 --> 00:08.880
Appコンポーネントの状態管理をする時が来ました｡

00:08.880 --> 00:10.530
それがReactの仕組みです｡ 

00:10.530 --> 00:15.000
関数コンポーネントでは､ useStateフックを使ってStateを管理することができます｡

00:15.000 --> 00:16.820
繰り返しになりますが､ もしあなたがこのことを知らないなら､

00:16.820 --> 00:26.480
あるいはステートや関数コンポーネントやフックでは何もわからないなら､ 私のReact完全ガイドコースのようなReact専用のリソースをぜひチェックしてみてください｡

00:26.480 --> 00:29.870
そこで､ Todoをstateで管理したいと思います｡

00:29.870 --> 00:33.060
そのために､ 最初に作ったダミーのTodoをクリアして､

00:33.060 --> 00:36.430
代わりにuseStateを呼び出してstateを初期化します｡

00:36.430 --> 00:44.510
ただし､ このときstateの開始値として空の配列を渡せば､ 最初は空の配列になります｡

00:44.510 --> 00:49.370
これで useState は常に正確に2つの要素を持つ配列を返すようになりました｡

00:49.370 --> 00:53.630
最初の要素は､ このレンダーサイクルの最新の状態スナップショットである｡

00:53.630 --> 00:55.070
そして第2引数､ 配列の2番目の要素は､

00:55.070 --> 01:01.110
その状態を更新してコンポーネントを再レンダリングする関数です｡

01:01.110 --> 01:02.660
この2つの要素を取り出し､

01:02.660 --> 01:09.230
別々の定数に格納するために､ コースの前半で学習した配列の再構築を使用することができます｡

01:09.230 --> 01:13.103
そして､ ここにTodosがあり､ setTodosという名前の関数があるとします｡

01:14.920 --> 01:16.820
todoAddHandler

01:16.820 --> 01:19.530
の中で setTodos を呼び出し､

01:19.530 --> 01:21.480
todos 配列に新しい

01:21.480 --> 01:27.373
todoText が追加された配列をセットします｡

01:28.240 --> 01:29.283
もちろん､ 新しい配列を渡して､

01:30.400 --> 01:34.100
新しいオブジェクトを追加することができます｡ たとえば､ IDを指定して､

01:34.100 --> 01:42.530
MathでランダムなIDを作成します｡

01:42.530 --> 01:42.530
random()を使用します｡  を文字列に変換します｡ 

01:42.530 --> 01:48.760
また､ テキストを入力することもできます｡

01:48.760 --> 01:51.910
しかし､ 不思議なことに､ ここでエラーが発生します｡ 

01:51.910 --> 01:56.860
そして､ この引数は割り当て可能ではないというエラーが表示されるのです｡

01:56.860 --> 02:01.970
まあ､ 基本的には何もない配列を期待するようなものです｡

02:01.970 --> 02:03.590
そして､ それはもちろん､ あなたがここで望んでいることではありません｡ 

02:03.590 --> 02:06.010
何もない配列が国家になるのは嫌だ｡ 

02:06.010 --> 02:07.110
なぜ､ このようなことが起こるのでしょうか？

02:07.950 --> 02:11.800
なぜなら､ useStateを空の配列で初期化すると､ TypeScriptは状態がどのように見えるかを推測するからだ｡

02:11.800 --> 02:20.130
もしこれを文字列で初期化すると､ TypeScriptは状態が文字列であると推測するだろう｡

02:20.130 --> 02:23.010
だから､ これを一時的に削除して､ 何かテキストを渡せば､

02:23.010 --> 02:24.123
受理される｡

02:25.160 --> 02:28.260
配列で渡すと､ TypeScriptは配列であることを期待するが､

02:28.260 --> 02:32.000
何かの配列ではなく､ 常に基本的に空の配列である｡

02:32.000 --> 02:36.070
つまり､ 何もない配列で､ もちろんここにはいらない｡ 

02:36.070 --> 02:40.460
これを解決するために､ 私たちの不動産が時間とともにどのように見えるかをReactに伝える必要があります｡

02:40.460 --> 02:44.630
そのために､ useStateは汎用的な関数であり､

02:44.630 --> 02:48.080
不動産の構造を渡すことができるからです｡

02:48.080 --> 03:04.860
正確には､ IDプロパティ（文字列）とtextプロパティ（文字列）を持つオブジェクトの配列です｡

03:04.860 --> 03:08.050
そして今､ この状態の更新が許可されています｡ 

03:08.050 --> 03:10.100
もちろんここに書いてもいいのですが､ アプリ内のさまざまな場所で必要になるので､

03:10.100 --> 03:16.710
実際に新しいファイルを作成して､ これをtodoと名付けます｡

03:16.710 --> 03:16.710
のモデルです｡  ツ｡ 

03:16.710 --> 03:18.210
ファイル名は自由です｡ 

03:18.210 --> 03:19.940
ここでは基本的に､ Todo

03:19.940 --> 03:24.080
という名前のインターフェイスをエクスポートし､

03:24.080 --> 03:25.440
アプリ内で Todo

03:25.440 --> 03:30.190
ID がどのように見えるかを記述します｡

03:30.190 --> 03:42.543
そして､ このアプリ・コンポーネントにエクスポートされたものをインポートすることで､ .NET FrameworkからTodoをインポートすることができます｡

03:42.543 --> 03:42.543
/todoです｡  のモデルです｡ 

03:43.900 --> 03:46.720
そして､ ここでは単純にTODOの配列ができ､

03:46.720 --> 03:49.550
もちろん短くて読みやすくなっています｡

03:49.550 --> 03:51.480
これで､ 状態の更新はまだ機能しますが､

03:51.480 --> 03:52.870
少しすっきりしました｡

03:52.870 --> 03:55.100
そして､ これは配列のようなものを扱うときに本当に重要なことで､

03:55.100 --> 03:59.170
どのようなタイプのデータを最終的に格納したいのか､ 空の配列で初期化すると､

03:59.170 --> 04:04.270
コンテンツのタイプが変わってしまいます｡

04:04.270 --> 04:06.250
しかし､ これならうまくいきます｡ 

04:06.250 --> 04:07.450
というのも､ 現在では､

04:07.450 --> 04:17.400
TODOの既存の配列を､ 正確に1つの要素だけを持つ新しい配列で常に上書きしているからです｡

04:17.400 --> 04:23.730
そして､ その代わりに､ 新しい要素と同様にすべての古い要素を持つ新しい配列で上書きしたいのです｡

04:23.730 --> 04:26.583
そこで､ 次回の講義でこのロジックを調整しましょう｡ 
