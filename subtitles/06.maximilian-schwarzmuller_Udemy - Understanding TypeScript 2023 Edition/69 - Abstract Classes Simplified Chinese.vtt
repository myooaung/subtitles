WEBVTT

00:02.060 --> 00:04.710
因此, 静态属性的方式,

00:04.710 --> 00:08.743
让我们回到继承和一个相关的概念｡

00:08.743 --> 00:14.280
另一种将方法加入至您计划继承自之类别的方式｡

00:14.280 --> 00:16.660
这是我们的Department类,

00:16.660 --> 00:21.360
如您所知, 我们从它继承了IT部门和会计部门｡

00:21.360 --> 00:23.470
现在, 我们的Department类中确实有describe方法,

00:23.470 --> 00:31.850
因此我们可以基于IT Department和Accounting Department在任何实例上调用它, 因为这些类基于Department,

00:31.850 --> 00:39.523
并且它们可以访问该Department基类的所有属性和方法｡

00:40.380 --> 00:43.850
现在, 正如您所了解的, 您可以重写方法｡ 

00:43.850 --> 00:46.550
例如, 在这里的会计部门,

00:46.550 --> 00:50.030
我们可以添加自己的描述方法版本,

00:50.030 --> 00:51.900
在这里我想做一些不同的事情,

00:51.900 --> 01:00.443
在这里可能当我说会计部门ID, 然后访问扭曲ID｡

01:02.040 --> 01:03.140
现在, 这在这里不起作用,

01:03.140 --> 01:06.960
因为ID是Department的私有属性,

01:06.960 --> 01:10.400
因此, 我们需要将其转换为受保护的属性,

01:10.400 --> 01:14.750
以便它在基于该类的类中也可用｡

01:14.750 --> 01:16.210
但有了这个, 应该能用｡ 

01:16.210 --> 01:19.080
如果我现在在accounting上调用describe,

01:19.080 --> 01:20.540
当然我们可以这样做, 让我们把这两行注释掉,

01:20.540 --> 01:27.460
然后调用accounting｡

01:27.460 --> 01:27.460
在下面描述,

01:27.460 --> 01:29.300
我们应该看到新输出, 实际上, 我们看到了Accounting

01:29.300 --> 01:33.340
Department ID, d2｡

01:33.340 --> 01:38.900
当然, 现在我们也可以覆盖IT部门中的describe方法｡

01:38.900 --> 01:43.240
但是有时候你不只是想提供覆盖方法的选项,

01:43.240 --> 01:46.440
因为它总是存在的｡

01:46.440 --> 01:56.840
相反, 您希望强制开发人员使用特定类或扩展特定类来实现特定方法或重写特定方法｡

01:56.840 --> 01:58.360
你什么时候会这么做？

01:58.360 --> 02:07.320
当你想确保某个方法在基于某个基类的所有类中都可用的时候在这个例子中是Department.

02:07.320 --> 02:10.550
但是当同时也知道确切的实现会依赖于具体的版本,

02:10.550 --> 02:14.220
所以当你可以提供一个通用的方法,

02:14.220 --> 02:28.520
但是你要强制这个方法存在的时候, 但是继承类就需要提供自己的实现因为你不能在基类中提供一个默认的实现｡

02:28.520 --> 02:30.150
所以在这种情况下,

02:30.150 --> 02:38.460
你可能想在基类中有一个空方法, 然后强制所有基于这个类的类添加并覆盖这个方法,

02:38.460 --> 02:44.880
你可以通过在这里添加abstract关键字来实现.

02:44.880 --> 02:46.630
如果你在这里添加abstract,

02:46.630 --> 02:51.440
你会看到一个错误, 这只在抽象类中可用｡

02:51.440 --> 02:54.220
所以如果你有一个或多个方法, 在方法前面加上abstract,

02:54.220 --> 02:57.390
你也要在类前面加上abstract, 现在,

02:57.390 --> 03:03.740
我们在这方面做得很好, 但是现在你看到我这里有一个错误.

03:03.740 --> 03:05.650
Describe不能有实作,

03:05.650 --> 03:07.850
因为它已标示为抽象｡

03:07.850 --> 03:10.340
您必须删除大括号, 添加分号,

03:10.340 --> 03:16.820
并添加它应该具有的返回类型, 在本例中为白色｡

03:16.820 --> 03:18.400
现在, 你只是定义了这个方法的结构,

03:18.400 --> 03:25.230
除此之外, 你什么都没说.

03:25.230 --> 03:27.990
但是现在, 我们在IT部门中得到了一个错误,

03:27.990 --> 03:31.120
因为它没有实现继承的抽象成员describe,

03:31.120 --> 03:36.330
这意味着, 我们在这里没有提供describe方法｡

03:36.330 --> 03:38.410
我们必须这么做因为我们是基于Department类的,

03:38.410 --> 03:42.860
它是抽象的, 它有抽象的方法.

03:42.860 --> 03:48.623
这意味着此方法必须由基于此Department类的任何类实现｡

03:49.620 --> 03:53.820
因此, 现在在IT部门, 我们必须添加一个describe方法｡

03:53.820 --> 04:01.120
在那里, 我们现在可以控制台日志IT部门, 然后做任何我们想要的｡

04:01.120 --> 04:04.900
这可以与我们在会计部门中的实现相同,

04:04.900 --> 04:07.440
但也可以不同｡

04:07.440 --> 04:10.040
现在, 我们可以保存它, 它重新编译,

04:10.040 --> 04:12.850
我们得到的输出几乎和以前一样｡

04:12.850 --> 04:20.020
但是现在我们在基于Department的不同类中有了describe方法的两种不同实现｡

04:20.020 --> 04:27.120
因此, 如果你想强制所有基于其他类的类共享一些公共的方法或属性,

04:27.120 --> 04:33.150
抽象是非常有用的, 你也可以有抽象属性｡

04:33.150 --> 04:34.260
但同时,

04:34.260 --> 04:39.170
你要确保你不必在基类中提供具体的值,

04:39.170 --> 04:43.440
具体的实现, 而是由继承类来做.

04:43.440 --> 04:45.970
同样重要的是, 抽象类｡ 

04:45.970 --> 04:51.420
所以用这个关键字标记为abstract的类可以自己实例化｡

04:51.420 --> 04:54.240
所以现在不能实例化Department｡ 

04:54.240 --> 04:57.440
它基本上只是一个类, 它开始被继承,

04:57.440 --> 05:05.230
这样继承类就可以被实例化, 继承类被强制提供具体的实现, 在这个例子中,

05:05.230 --> 05:11.770
按照你在这里布置的结构来描述方法｡

05:11.770 --> 05:15.750
因此, 使用此关键字引用Department实例或基于Department的实例,

05:15.750 --> 05:23.610
包括可能介于两者之间的继承类, 并且它不返回任何内容
