WEBVTT

00:02.270 --> 00:03.850
ผู้สอน: เรากำลังใช้ประเภทหลักของตัวเลข

00:03.850 --> 00:07.450
บูลีน และสตริง

00:07.450 --> 00:16.540
และที่นี่ในรายการพารามิเตอร์ของฟังก์ชันนี้ เราจะกำหนดประเภทอย่างชัดเจนเสมอด้วยเครื่องหมายทวิภาคตามหลังชื่อพารามิเตอร์

00:16.540 --> 00:18.410
แล้วตามด้วยชื่อประเภท

00:18.410 --> 00:21.350
ตรงนี้ ชื่อเป็นตัวเลข บูลีน สตริง

00:21.350 --> 00:25.420
และในกรณีที่คุณสงสัย สิ่งเหล่านี้เป็นตัวระบุพิเศษ

00:25.420 --> 00:28.530
นี่คือไวยากรณ์พิเศษซึ่งเพิ่มโดย

00:28.530 --> 00:30.170
TypeScript

00:30.170 --> 00:32.900
ไม่ใช่ส่วนหนึ่งของโค้ด JavaScript ที่คอมไพล์แล้ว

00:32.900 --> 00:37.280
หากเราตรวจสอบโค้ดนั้นที่นี่ การกำหนดประเภทเหล่านี้จะหายไป

00:37.280 --> 00:39.530
เนื่องจาก JavaScript ไม่รองรับ

00:39.530 --> 00:43.920
สิ่งนี้โคลอนหลังตัวแปรหรือหลังพารามิเตอร์

00:43.920 --> 00:46.320
จากนั้นตัวเลขและบูลีนและสตริง

00:46.320 --> 00:48.290
คำสำคัญพิเศษเหล่านี้

00:48.290 --> 00:50.840
สิ่งนี้ได้รับการแนะนำโดย TypeScript

00:50.840 --> 00:53.500
คอมไพเลอร์ TypeScript เข้าใจมัน

00:53.500 --> 00:58.580
IDE ที่นี่รองรับ TypeScript ดังนั้นจึงไม่บ่นเกี่ยวกับคีย์เวิร์ดพิเศษเหล่านี้

00:58.580 --> 01:01.760
JavaScript ไม่เข้าใจไวยากรณ์นี้

01:01.760 --> 01:04.590
ไม่เข้าใจโคลอนหลังพารามิเตอร์ หรือโคลอนหลังตัวแปร

01:04.590 --> 01:09.190
และคีย์เวิร์ดหมายเลขพิเศษหรือสตริง

01:09.190 --> 01:11.540
JavaScript ไม่เข้าใจสิ่งนี้ ดังนั้น นี่จึงไม่ใช่ส่วนหนึ่งของเอาต์พุต

01:11.540 --> 01:13.560
JavaScript

01:13.560 --> 01:15.920
มันถูกใช้โดยคอมไพเลอร์ TypeScript เท่านั้น

01:15.920 --> 01:21.820
แล้วมันก็เป็นคอมไพเลอร์เพราะมันแปลงโค้ดนี้เป็นโค้ดจาวาสคริปต์

01:21.820 --> 01:24.880
หมายเหตุด้านข้าง คุณยังเห็นว่ามันเปลี่ยน const เป็น

01:24.880 --> 01:27.700
var แต่นั่นคือสิ่งที่ฉันจะกลับมาใหม่ในภายหลัง

01:27.700 --> 01:30.590
ดังนั้นเราจึงมีการกำหนดประเภทที่ชัดเจนของเราที่นี่

01:30.590 --> 01:33.060
และมีเพียง TypeScript เท่านั้นที่เข้าใจ

01:33.060 --> 01:35.763
เยี่ยมมาก ทำไมเราไม่เก็บมันไว้ที่นั่นล่ะ?

01:36.880 --> 01:39.890
ฉันไม่มีการมอบหมายประเภทที่ชัดเจนที่นี่

01:39.890 --> 01:43.450
และอย่างไรก็ตาม มันไม่ได้อยู่ที่นี่เมื่อเราคำนวณผลลัพธ์

01:43.450 --> 01:48.400
ตัวอย่างเช่น เนื่องจาก TypeScript มีคุณสมบัติในตัวที่เรียกว่าการอนุมานประเภท

01:48.400 --> 01:53.010
ซึ่งหมายความว่า TypeScript ทำได้ดีที่สุดและทำงานได้ดีทีเดียว

01:53.010 --> 01:58.860
เพื่อทำความเข้าใจว่าคุณมีประเภทใดในตัวแปรหรือค่าคงที่

01:58.860 --> 02:02.300
ตัวอย่างเช่น มันเข้าใจดีว่า number1 จะเป็นประเภทตัวเลขในตอนท้ายเสมอ

02:02.300 --> 02:08.020
เพราะคุณเริ่มต้นมันด้วยตัวเลข

02:08.020 --> 02:11.740
ทีนี้, นี่เป็นค่าคงที่, มันจึงเจาะจงกว่านั้นอีก

02:11.740 --> 02:15.350
และประเภทที่ระบุในที่นี้ ไม่ใช่แค่ตัวเลขใดๆ

02:15.350 --> 02:17.490
แต่เป็นเลขห้า

02:17.490 --> 02:20.110
เนื่องจากคุณจะไม่สามารถกำหนดหมายเลขใหม่หรือค่าใหม่ให้กับค่า

02:20.110 --> 02:23.870
const ได้อยู่ดี

02:23.870 --> 02:25.840
หากคุณต้องเปลี่ยนสิ่งนี้เป็นตัวแปร

02:25.840 --> 02:30.180
ดังนั้นหากคุณใช้ let แทน แน่นอนว่าสิ่งนี้จะไม่ทำให้อะไรเสียหาย

02:30.180 --> 02:34.540
เราสามารถใช้ตัวแปรตรงนั้นได้ มันอาจจะไม่ใช่วิธีปฏิบัติที่ดีที่สุดเพราะค่านี้ไม่เคยเปลี่ยนแปลง

02:34.540 --> 02:36.210
แต่ก็ไม่น่ากลัวเช่นกัน

02:36.210 --> 02:38.260
แต่ถ้าวางเมาส์เหนือสิ่งนี้ เราจะเห็นว่า

02:38.260 --> 02:41.210
TypeScript ไม่ได้บอกว่า โอเค นี่ต้องเป็นห้า

02:41.210 --> 02:45.510
แต่ก็ยังตรวจพบว่าประเภทในที่นี้คือตัวเลข

02:45.510 --> 02:49.260
ตอนนี้ เราสามารถเขียนโค้ดนี้ที่นี่ได้ด้วยตัวของเราเอง

02:49.260 --> 02:53.870
เราสามารถเพิ่มเครื่องหมายทวิภาคหลังชื่อตัวแปรทางด้านซ้ายของเครื่องหมายเท่ากับ

02:53.870 --> 02:55.590
แล้วตามด้วยชื่อประเภท

02:55.590 --> 02:59.470
เหมือนกับที่เราทำในพารามิเตอร์ของฟังก์ชันนี้

02:59.470 --> 03:04.620
แต่สิ่งนี้ซ้ำซ้อนและไม่ถือว่าเป็นแนวปฏิบัติที่ดี

03:04.620 --> 03:09.990
เนื่องจาก TypeScript สามารถสรุปประเภทนี้ได้อย่างสมบูรณ์แบบจากที่นั่น

03:09.990 --> 03:13.690
ดังนั้น การกำหนดสิ่งนี้จึงไม่ใช่ความคิดที่ดี

03:13.690 --> 03:18.053
สิ่งนี้จะเปลี่ยนแปลงก็ต่อเมื่อคุณต้องการสร้างตัวแปรนี้ด้วยวิธีที่ไม่ได้กำหนด

03:19.000 --> 03:22.130
เช่นนี้ หากคุณไม่เริ่มต้นทันที

03:22.130 --> 03:25.700
จากนั้น เป็นแนวปฏิบัติที่ดีที่จะบอก TypeScript

03:25.700 --> 03:29.070
ว่าค่าใดจะถูกเก็บไว้ในนั้น

03:29.070 --> 03:35.320
เพื่อที่ว่าเมื่อคุณกำหนดค่าให้กับมันในภายหลัง และแน่นอนว่ามันค่อนข้างซ้ำซ้อนตรงนี้ที่จะแบ่งมันออกเป็นสองบรรทัด

03:35.320 --> 03:37.800
ฉันแค่ทำสิ่งนี้เพื่อจุดประสงค์ในการสาธิต

03:37.800 --> 03:39.480
แต่ตอนนี้ถ้าฉันกำหนดสิ่งนี้ที่นี่

03:39.480 --> 03:44.630
สิ่งนี้จะหยุดเพราะฉันบอก TypeScript ล่วงหน้าว่านี่จะเป็นหมายเลขประเภท

03:44.630 --> 03:45.610
คุณไม่จำเป็นต้องทำอย่างนั้น

03:45.610 --> 03:47.420
นอกจากนี้ยังใช้งานได้หากคุณไม่ทำอย่างนั้น

03:47.420 --> 03:51.630
แต่ตอนนี้คุณสามารถเพิ่มห้าสิ่งนี้และคุณจะไม่ได้รับข้อผิดพลาดเพราะคุณไม่ได้บอก

03:51.630 --> 03:59.630
TypeScript เกี่ยวกับประเภทที่จะเก็บไว้ในตัวแปรนี้ ดังนั้น TypeScript จึงอนุญาตประเภทใดก็ได้

03:59.630 --> 04:02.600
หากคุณเพิ่มเลขโคลอนที่นี่แทน คุณกำลังบอก

04:02.600 --> 04:07.370
TypeScript ว่า "เฮ้ ในที่สุด" ตัวเลขจะถูกเก็บไว้ในนั้น

04:07.370 --> 04:07.370
และด้วยเหตุนี้

04:07.370 --> 04:10.060
ถ้าคุณเก็บสิ่งอื่นไว้ในนั้นในภายหลัง เช่น ในกรณีนี้ ที่เราเก็บสตริงไว้

04:10.060 --> 04:15.170
คุณจะได้รับข้อผิดพลาดที่นี่ใน IDE และแน่นอนว่าถ้าคุณคอมไพล์โค้ดของคุณด้วย

04:15.170 --> 04:17.570
เราจะได้รับข้อผิดพลาดที่เราเห็นก่อนหน้านี้

04:17.570 --> 04:20.253
นี่คือวิธีกำหนดประเภท

04:22.300 --> 04:24.920
ตอนนี้ แม้ว่า TypeScript จะอนุมานประเภท และให้ฉันแก้ไขสิ่งนี้

04:24.920 --> 04:29.310
มันจะตะโกนใส่คุณหากคุณทำลายประเภทที่อนุมานนั้น

04:29.310 --> 04:32.720
ที่จริงมันผิดที่จะพูดด้วยซ้ำ เพราะแน่นอนว่ามันทำ

04:32.720 --> 04:35.670
ทำไมมันถึงไม่ทำล่ะ?

04:35.670 --> 04:37.000
การอนุมานประเภทมีไว้ให้คุณบันทึกรหัส

04:37.000 --> 04:39.750
เพื่อหลีกเลี่ยงไม่ให้คุณต้องกำหนดประเภทด้วยตนเอง

04:39.750 --> 04:42.730
แน่นอนว่า TypeScript จะตะโกนใส่คุณหากคุณใช้ผิดประเภท

04:42.730 --> 04:46.510
ซึ่งเป็นประเภทที่ไม่ได้อนุมาน

04:46.510 --> 04:48.640
ตัวอย่างเช่น ในที่นี้ หากสร้าง resultPhase

04:48.640 --> 04:54.000
ด้วยคำว่า let เพื่อให้เป็นตัวแปร ดังนั้น TypeScript ในที่นี้จะอนุมานว่าสิ่งนี้จะเป็นประเภทสตริง

04:54.000 --> 04:57.670
เนื่องจากเราเริ่มต้นมันด้วยสตริง

04:57.670 --> 04:59.850
ดังนั้น นี่จึงเทียบเท่ากับการไม่เริ่มต้น

04:59.850 --> 05:04.970
และตั้งค่าประเภทด้วยตัวเราเอง แล้วจึงกำหนดค่าในภายหลัง

05:04.970 --> 05:07.410
ตอนนี้ ถ้าเราเปลี่ยน resultPhase เป็น

05:07.410 --> 05:12.310
สมมติว่าเป็นศูนย์ ไม่ว่าด้วยเหตุผลใดก็ตาม เราอาจต้องการทำเช่นนั้น เราก็จะได้รับข้อผิดพลาดตรงนี้ว่า

05:12.310 --> 05:17.330
type zero is not assignable of type string.

05:17.330 --> 05:21.210
และนั่นสมเหตุสมผลแล้วใช่ไหม

05:21.210 --> 05:22.690
TypeScript อนุมานว่าเราต้องการจัดเก็บสตริง

05:22.690 --> 05:27.290
ขณะนี้เรากำลังพยายามจัดเก็บตัวเลข เราได้รับข้อผิดพลาด

05:27.290 --> 05:28.530
นั่นคืองาน ภารกิจหลักของ TypeScript

05:28.530 --> 05:35.280
ตรวจสอบประเภทและตะโกนใส่เราหากเราใช้ไม่ถูกต้อง
