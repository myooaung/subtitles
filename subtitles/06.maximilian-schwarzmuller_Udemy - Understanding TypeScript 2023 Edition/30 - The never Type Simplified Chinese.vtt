WEBVTT

00:02.220 --> 00:07.490
教师：在本模块中, 我想展示的最后一个有趣的类型是never类型｡

00:07.490 --> 00:10.660
现在我们看到一个返回void的函数｡ 

00:10.660 --> 00:13.058
所以它不会返回任何结果｡ 

00:13.058 --> 00:17.380
Never是另一个类型函数可以返回的｡ 

00:17.380 --> 00:19.240
这听起来可能很奇怪｡ 

00:19.240 --> 00:21.110
让我们来看看它是如何工作的｡ 

00:21.110 --> 00:24.662
假设我们有一个函数generateError｡ 

00:24.662 --> 00:28.280
在这里, 我希望得到一条消息, 它是一个字符串,

00:28.280 --> 00:31.610
可能还有一些错误代码, 它可能是一个数字｡

00:31.610 --> 00:35.130
在这个函数中, 我们抛出一个错误.

00:35.130 --> 00:41.500
所以这实际上应该是一个生成错误对象并抛出它们的实用函数｡

00:41.500 --> 00:44.380
所以这里我们可以抛出一个对象, 这可以在JavaScript中实现｡

00:44.380 --> 00:47.366
我们可以把任何对象或任何值作为错误抛出,

00:47.366 --> 00:49.930
它应该有一个message属性,

00:49.930 --> 00:53.990
我把message参数的值存储在这个属性中｡

00:53.990 --> 00:56.390
我需要一个错误代码属性, 比如说,

00:56.390 --> 00:59.417
erase这个词, 代码参数在里面.

01:00.330 --> 01:02.390
无效函数也是如此,

01:02.390 --> 01:06.600
我们可以用一个错误发生来调用它,

01:06.600 --> 01:09.640
例如, 代码为500｡

01:09.640 --> 01:12.213
如果我们这样做, 我们在这里编译这个文件,

01:14.120 --> 01:17.080
我们会看到, 一旦它重新加载, 我们就会得到我们的错误,

01:17.080 --> 01:19.150
这里也是一个错误｡

01:19.150 --> 01:21.670
这听起来可能很抽象, 但实际上,

01:21.670 --> 01:22.850
它不是｡

01:22.850 --> 01:24.640
在较大的应用程序中, 拥有这样的实用函数将是相当标准的,

01:24.640 --> 01:32.540
在这些应用程序中, 您不希望手动在应用程序的10个不同位置抛出错误, 并且您希望找到一个方便的函数,

01:32.540 --> 01:44.690
该函数为您构建错误对象, 并且可能会立即抛出它, 这样您就可以使用不同的输入调用此函数, 但总是会抛出错误｡

01:44.690 --> 01:49.048
有趣的是, 这个函数不仅仅返回void.

01:49.048 --> 01:52.385
实际上我可以指定它返回void,

01:52.385 --> 01:54.545
因为当然什么都不返回,

01:54.545 --> 01:58.030
但实际上它并不只是什么都不返回, 如果我们完全诚实的话,

01:58.030 --> 02:02.630
这个函数永远不会返回｡

02:02.630 --> 02:05.518
此函数从不生成返回值｡ 

02:05.518 --> 02:08.860
如果我尝试在控制台日志结果中恢复返回值,

02:08.860 --> 02:11.193
然后在此执行中编译代码,

02:12.040 --> 02:16.240
我们会看到此处没有记录未定义的内容,

02:16.240 --> 02:25.330
因为由于抛出了错误, 因此这实际上会导致脚本崩溃｡

02:25.330 --> 02:27.080
它取消了我们的剧本｡ 

02:27.080 --> 02:30.290
对于这个函数来说, 情况总是如此｡ 

02:30.290 --> 02:32.210
当然, 我们可以将其包装在try

02:32.210 --> 02:34.260
catch中, 这样我们仍然可以继续执行此脚本,

02:34.260 --> 02:37.620
但此函数本质上不会产生值｡

02:37.620 --> 02:44.720
如果使用try catch, 则此函数总是会使脚本或脚本的这一部分崩溃,

02:44.720 --> 02:47.910
因此不会返回任何内容｡

02:47.910 --> 02:50.400
因此这个函数的返回类型实际上不仅是void,

02:50.400 --> 02:54.483
而且是never｡

02:55.710 --> 02:59.060
有趣的是, 如果你把鼠标悬停在它上面而不赋值never,

02:59.060 --> 03:01.680
你会看到推断出的类型是void｡

03:01.680 --> 03:05.410
因为never是一个较新的类型, 它已经存在了一段时间,

03:05.410 --> 03:10.000
但是它没有内置到TypeScript的第一个版本中,

03:10.000 --> 03:15.417
因此通常假设为void, 让它保持原样并不可怕｡

03:15.417 --> 03:17.740
但是您可以非常清楚地将never显式设置为返回类型,

03:17.740 --> 03:24.490
以明确表示这不会返回任何内容｡

03:24.490 --> 03:26.770
因此, 从代码质量的角度来看,

03:26.770 --> 03:32.330
这可能会更清楚地了解您的意图, 并使我们的开发人员在阅读您的代码时真正清楚地了解到,

03:32.330 --> 03:40.954
此函数的目的是永远不返回任何内容, 并且实质上会使您的脚本或脚本的该部分崩溃或中断｡

03:40.954 --> 03:47.190
顺便说一下, 另一个永远不会返回的函数是一个无限循环的函数｡

03:47.190 --> 03:49.370
所以如果我们有while（true）在里面,

03:49.370 --> 03:51.060
这就产生了一个无限循环,

03:51.060 --> 03:54.410
因此这也是一个永远不会返回的函数.

03:54.410 --> 03:56.070
这里的错误函数,

03:56.070 --> 04:01.305
或者说生成冻结错误的函数可能是更常见的用例｡

04:01.305 --> 04:04.500
所以never, 也是一个有趣的类型,

04:04.500 --> 04:06.230
你可以在函数中使用,

04:06.230 --> 04:08.553
比如这里的例子｡
