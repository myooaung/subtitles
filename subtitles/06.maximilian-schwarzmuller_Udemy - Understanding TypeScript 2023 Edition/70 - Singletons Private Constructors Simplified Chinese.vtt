WEBVTT

00:02.260 --> 00:04.960
- ：现在还有最后一个有趣的特性,

00:04.960 --> 00:10.330
我也想介绍一下, 那就是私有构造函数｡

00:10.330 --> 00:13.823
什么是私有构造函数, 它有什么用途？

00:14.870 --> 00:20.460
在面向对象的编程中有一种模式叫做单例模式｡

00:20.460 --> 00:28.030
单例模式是为了确保您始终只有某个类的恰好一个实例｡

00:28.030 --> 00:30.558
在您无法使用静态方法或属性,

00:30.558 --> 00:33.000
或您不想使用静态方法或属性,

00:33.000 --> 00:36.440
但同时又想确定您无法建立多个以类别为基础的物件,

00:36.440 --> 00:40.730
但您永远只有一个以类别为基础的物件的情况下,

00:40.730 --> 00:44.630
这会很有用｡

00:44.630 --> 00:47.660
假设对于AccountingDepartment,

00:47.660 --> 00:57.840
我们希望确保只能基于该类创建一个对象, 因为我们在整个公司中只有一个会计部门｡

00:57.840 --> 01:00.260
我们可能有多个IT部门,

01:00.260 --> 01:03.290
但只有一个会计部门｡

01:03.290 --> 01:05.310
现在, 为了强制执行此操作并避免多次手动调用new

01:05.310 --> 01:14.320
AccountingDepartment, 我们可以通过在AccountingDepartment类的构造函数前面添加private关键字,

01:14.320 --> 01:18.860
将其转换为私有构造函数｡

01:18.860 --> 01:23.480
它的作用是, 它确保我们不能调用new｡

01:23.480 --> 01:25.160
这里你会看到我得到了一个错误,

01:25.160 --> 01:30.600
因为构造函数是私有的, 所以只能从类内部访问, 这听起来很奇怪,

01:30.600 --> 01:33.690
因为如果我们不能再基于类创建对象,

01:33.690 --> 01:37.920
我们怎么才能进入类内部呢.

01:37.920 --> 01:40.490
答案是静态方法｡ 

01:40.490 --> 01:43.610
静态方法可以在类本身上调用,

01:43.610 --> 01:46.250
因此不必为此实例化它｡

01:46.250 --> 01:51.340
在这里我们可以添加一个静态方法, 我们可以将其称为getInstance,

01:51.340 --> 01:53.260
但名称完全由您决定｡

01:53.260 --> 01:56.930
现在getInstance将检查我们是否已经有了这个类的实例,

01:56.930 --> 02:00.090
如果没有, 则返回一个新的实例｡

02:00.090 --> 02:06.350
为此, 我们可以添加一个新的静态属性实例, 一个静态私有属性, 这样你就可以把private放在静态调用实例的前面,

02:06.350 --> 02:12.040
该实例的类型将是AccountingDepartment｡

02:12.040 --> 02:16.570
因此, 我们将在其中存储一个AccountingDepartment实例｡ 

02:16.570 --> 02:17.580
这就是我要说的,

02:17.580 --> 02:19.100
我有一个静态属性, 它可以在类本身上访问,

02:19.100 --> 02:25.960
但只能从类内部访问, 我们存储在那里的值将是AccountingDepartment类型,

02:25.960 --> 02:30.140
也就是类本身的类型｡

02:30.140 --> 02:33.880
现在, 我们可以在getInstance中使用这个实例属性,

02:33.880 --> 02:38.880
并检查它是否为｡ 实例在static内部设置,

02:39.260 --> 02:47.610
如果我们使用它, 它将引用类本身, 然后我们可以访问它的所有其他静态属性｡

02:47.610 --> 02:51.963
另一种方法是使用类名｡ 

02:53.720 --> 03:01.600
现在如果这个已经设置好了, 我想把这个还回去｡  实例, 或者再次使用classname｡

03:01.600 --> 03:01.600
但在静态方法中,

03:01.600 --> 03:05.680
它可以访问类本身, 不像在非静态方法中,

03:05.680 --> 03:13.550
它可以访问我们要处理的实例, 而不是我们现在要做的.

03:13.550 --> 03:15.660
但是如果我们没有在这里,

03:15.660 --> 03:17.290
那么我们还没有实例,

03:17.290 --> 03:22.030
然后我设置这个. 实例, 所以这个静态实例属性等于new

03:22.030 --> 03:25.660
AccountingDepartment,

03:25.660 --> 03:35.250
我们可以在这里使用它, 因为现在我们在这个类方法的内部, 所以我们可以在这里访问私有构造函数, 传入我们的ID和reports数组,

03:35.250 --> 03:44.830
然后返回它｡

03:44.830 --> 03:44.830
实例｡ 

03:44.830 --> 03:48.220
因此, 现在我们要么返回可能已经拥有的一个实例,

03:48.220 --> 03:50.970
要么创建一个新实例｡

03:50.970 --> 03:53.270
但是这段代码, 这里标记的代码, 只能运行一次,

03:53.270 --> 03:57.850
因为一旦我们有了一个实例, 我们把它变成了, 我们把它变成了, if块,

03:57.850 --> 04:00.370
我们返回现有的实例｡

04:00.370 --> 04:03.700
现在如果你想使用会计部门, 而不是像这样创建它, 我们可以称之为const

04:03.700 --> 04:10.153
accounting AccountingDepartment.

04:10.153 --> 04:10.153
getInstance,

04:11.646 --> 04:14.850
这将返回AccountingDepartment的新实例｡

04:14.850 --> 04:18.190
但是, 如果我再次这样做, 我将得到相同的实例,

04:18.190 --> 04:23.570
如果我控制台日志记帐, 您将看到这里的accounting2｡

04:23.570 --> 04:26.550
你会看到这两个应该是完全相等的, 如果我们保存并重新加载,

04:26.550 --> 04:36.690
你会看到下面是我的两个AccountingDepartment对象, 它们有相同的ID, 完全相同的设置, 它们是相同的对象,

04:36.690 --> 04:47.900
相同的实例, 因为我们只有一个实例具有这种单例模式, 它是在构造函数前面的private关键字的帮助下创建的｡

04:47.900 --> 04:52.490
这是一种你不会一直使用的方法｡

04:52.490 --> 04:55.010
singleton模式有时候很有用,

04:55.010 --> 04:56.530
你并不总是需要它, 但是它绝对值得你去了解,

04:56.530 --> 05:00.360
因为它是一个有趣的东西, 你可以很容易地用TypeScript实现它,

05:00.360 --> 05:04.923
这要归功于私有构造函数｡
