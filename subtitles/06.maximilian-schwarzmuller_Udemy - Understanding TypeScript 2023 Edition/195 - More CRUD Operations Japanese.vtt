WEBVTT

00:02.150 --> 00:03.930
講師：では､ 最初のPOSTリクエストを追加して､

00:03.930 --> 00:06.120
TODOを作成できるようにしました｡

00:06.120 --> 00:07.250
これで､ ルートが増えましたね｡ 

00:07.250 --> 00:10.170
また､ 作成したTODOSをすべて出すためのルートも確保しました｡ 

00:10.170 --> 00:21.330
コードを変更して保存するたびにTODOSがリセットされることに注意してください｡

00:21.330 --> 00:23.560
これは単にダミーアプリで持っているもので､

00:23.560 --> 00:24.930
実際のアプリでは､ もちろんこれを本物のデータベースに格納し､

00:24.930 --> 00:30.280
そこから取得するなどして､ 存続させることになります｡

00:30.280 --> 00:35.060
それにもかかわらず､ ここでは新しい関数､ getTodosを作成することができ､

00:35.060 --> 00:38.030
これはRequestHandlerになるので､

00:38.030 --> 00:42.330
すべてのパラメータに個別に型を設定する必要はない｡

00:42.330 --> 00:46.120
そしてその中で､ 私は単にレスポンスを返したいのですが､

00:46.120 --> 00:56.530
そこには私のTODOsがあるJSONデータを返します｡

00:56.530 --> 00:57.810
もちろん､ これを微調整して､

00:57.810 --> 01:03.120
別のロジックにしたり､ TODOSを最初にソートしたりすることもできますが､

01:03.120 --> 01:06.690
最もシンプルな形で､ TODOSを返すだけなので､

01:06.690 --> 01:10.530
非常にシンプルな関数です｡

01:10.530 --> 01:13.240
TODOSルートでは､ あとはこれをつなげるだけです｡ 

01:13.240 --> 01:17.680
コントローラからgetTodosをインポートして､

01:17.680 --> 01:20.640
このルートに接続しましょう｡

01:20.640 --> 01:25.250
それとともに､ 今これを保存すれば､ すでにその動作を見ることができます｡

01:25.250 --> 01:29.860
http://localhost:3000/todos/

01:29.860 --> 01:44.400
に新しいリクエスト（GETリクエスト）を作成し､ これを送信すると､ 空の配列が返されます｡

01:44.400 --> 01:48.010
まあ､ コードを変更してサーバーが再起動するたびにTODOはクリアされるから､

01:48.010 --> 01:54.110
今のうちにサーバーを再起動せずに新しいTODOを作ればいいと言ったんだけどね｡

01:54.110 --> 01:57.360
そして､ そのTODOを作成し､ TODOSを取得すると､

01:57.360 --> 02:04.380
ID､ シリアル9811などの作成したTODOがここにも表示されます｡

02:04.380 --> 02:05.960
だから､ それはもううまくいっているんです｡ 

02:05.960 --> 02:08.980
それでは､ patchとdeleteもやってみましょう｡

02:08.980 --> 02:12.680
もちろん､ そこは自由にロジックを考えてください｡

02:12.680 --> 02:16.130
結局､ 今､ そのために必要な構成要素はすべて揃っているのです｡

02:16.130 --> 02:18.480
もちろん､ これから一緒にやることもありますけどね｡ 

02:19.390 --> 02:21.570
そこで､ 今ここでパッチリクエストに､

02:21.570 --> 02:24.350
新しいコントローラ機能を追加してみましょう｡

02:24.350 --> 02:29.350
export const updateTodo, これは RequestHandler 型で､

02:30.660 --> 02:34.680
我々が既に知っているこの形式の関数を保持する必要があります｡

02:34.680 --> 02:37.310
そして､ そこでは､ 受信したリクエストから新しいTODOに関するデータを抽出し､

02:37.310 --> 02:44.140
その新しいデータでTODOを更新することを目的としています｡

02:44.140 --> 02:48.900
さて､ ここでルートの一部として､ ダイナミックセグメントがあることに注意してください｡

02:48.900 --> 02:51.140
このidセグメントがあります｡ 

02:51.140 --> 02:58.750
つまり､ URLからこの動的セグメントの具体的な値を抽出することができるようになるわけです｡

02:58.750 --> 03:07.987
つまり､ この受信リクエストでは､ リクエスト・パラメータからtodoIdを取得することができます｡

03:07.987 --> 03:07.987
id､ です｡  idというのは､ 私がここで選んだ名前だからです｡ 

03:07.987 --> 03:13.060
ここで違う名前を選んだら､ そちらでも違う名前を使わなければならない｡

03:13.060 --> 03:15.810
さて､ ここではサポートの種類はありませんよね？

03:15.810 --> 03:18.410
Params は any 型である｡ 

03:18.410 --> 03:23.400
これで､ 型はこのStringを解析し､ そこに何があるのかを理解することができるようになりました｡

03:23.400 --> 03:25.460
そこで､ より良いサポートを得るために､

03:25.460 --> 03:28.920
RequestHandlerが汎用型であることを利用し､

03:28.920 --> 03:35.880
角括弧を追加して､ 基本的にどのパラメータが持つかをTypeScriptに伝えることができるのです｡

03:35.880 --> 03:37.800
これをオブジェクトに設定するだけで､

03:37.800 --> 03:42.180
URL内にあるすべての親のキー・バリュー・マップができあがります｡

03:42.180 --> 03:43.830
例えば､ IDパラメータがあり､

03:43.830 --> 03:46.730
最終的にStringを保持しているとします｡

03:46.730 --> 03:48.610
これをここに追加すると､ 自動補完され､

03:48.610 --> 03:52.560
TypeScriptはこれがStringであることを知ることができる｡

03:52.560 --> 03:55.520
だから､ この汎用型を使ったほうがいいんです｡ 

03:55.520 --> 03:58.640
今､ 私たちはIDを持っています｡ また､ リクエストボディから何かが必要です｡

03:58.640 --> 04:03.560
正確には､ リクエストボディから新しいテキストが必要です｡

04:03.560 --> 04:08.130
ここでもう一度､ 型キャストを使用して､ ボディに

04:08.130 --> 04:11.700
text プロパティがあり､ これが

04:11.700 --> 04:16.910
String 型であることを明確にしよう｡

04:16.910 --> 04:19.750
そして､ その後にテキストを取得しましょう｡ 

04:19.750 --> 04:22.373
そして､ 上のTODOS配列のTODOを更新することができます｡ 

04:23.830 --> 04:28.710
そのために､ 更新したいTODOのインデックスを探しましょう｡

04:28.710 --> 04:30.808
todoIndexで､ TODOSにリーチアウトし､

04:30.808 --> 04:36.090
findIndexで､ TODOS配列の各項目に対して､ 何らかのロジックを実行することができるのです｡

04:36.090 --> 04:38.060
そして､ すべてのTODOを見て､

04:38.060 --> 04:40.010
TODO IDがここにあるTodoIdと等しければ､

04:40.010 --> 04:44.300
それは更新したいTODOであることがわかります｡

04:44.300 --> 04:47.140
何らかの理由でマイナス1になった場合は､

04:47.140 --> 04:52.610
TODOが見つからなかったことを意味します｡ つまり､ ゼロより小さい場合は､

04:52.610 --> 04:59.630
何かが間違っていたことになります｡

04:59.630 --> 05:06.130
そして､ これがデフォルトのエラー処理ミドルウェアを起動させることになります｡

05:06.130 --> 05:08.633
もしこのチェックが通ったら､ TODOが見つかったことになります｡

05:09.870 --> 05:15.040
そして､ TODOS配列のこのインデックスのTODOを新しいTODOに更新するだけで､

05:15.040 --> 05:18.960
古いIDはそのままになります｡

05:18.960 --> 05:27.030
そこで､ TODOSにアクセスするところ､ todoIndex｡  idは､ 古いIDにアクセスして保存していますが､

05:27.030 --> 05:31.713
ここに設定したテキストは､ もちろんこのように代入しているわけではありません｡

05:32.870 --> 05:34.570
しかし､ ここで設定したテキストは､ 現在､ updatedTextになっています｡ 

05:34.570 --> 05:41.340
これで､ ここのTODOが置き換わって､ それ以降は､ 例えばUpdatedというメッセージで､

05:41.340 --> 05:45.280
レスポンスを送り返すことができるようになります｡

05:45.280 --> 05:47.053
そして､ updatedTodoを送信レスポンスに追加し､

05:47.990 --> 05:55.090
これをTODOS todoIndexに等しく設定します｡

05:55.090 --> 05:59.090
もちろん､ まだTODOS配列のメモリ上で作業しているので､

05:59.090 --> 06:09.060
ダミーコードですが､ TypeScriptをどのように使用しているかを示しています｡

06:09.060 --> 06:11.100
では､ このアップデート機能を今から試してみましょう｡ 

06:11.100 --> 06:13.620
そのために Postman

06:13.620 --> 06:16.260
に戻り､ 最後に PATCH

06:16.260 --> 06:19.960
リクエストを送ります｡

06:19.960 --> 06:26.490
そういえば､ このルートも最初にこのコントローラ関数に接続する必要があるかもしれませんね｡

06:26.490 --> 06:28.850
そこで､ ルーティング・ファイルから

06:28.850 --> 06:33.420
updateTodo をインポートし､ ここで接続を確立しましょう｡

06:33.420 --> 06:35.590
そして､ その後､ このリクエストを送信することができます｡ 

06:35.590 --> 06:38.570
さて､ Postmanに戻ると､ PATCHが送信したいもので､

06:38.570 --> 06:41.890
次にhttp://localhost:3000/todos､

06:41.890 --> 06:49.430
URLの一部として更新したいTODOのアイデアです｡

06:49.430 --> 06:50.573
さて､ 何かを保存したので､ いくつかの変更を保存したので､

06:51.500 --> 06:54.970
サーバーは再起動し､ すべてのTODOSはいずれにせよ失われます｡

06:54.970 --> 07:01.150
ではまず､ そのPOSTリクエストを再送して､ 新しいTODOを作成してみましょう｡

07:01.150 --> 07:02.450
そして､ ここでそのTODOのIDを取得しました｡ 

07:02.450 --> 07:05.170
ここで､ このidをこのURLに追加します｡ 

07:05.170 --> 07:11.780
そして､ JSONタイプのボディも追加します｡ ここには､ サーバーに送信したい新しいデータを設定します｡

07:11.780 --> 07:20.970
さて､ updateコントローラでは､ 受信したリクエストボディの中からtextというフィールドを探していることに留意してください｡

07:20.970 --> 07:24.580
そのため､ 送信するJSONデータにも､ この情報を記載する必要があります｡

07:24.580 --> 07:29.440
1ヶ月でコース終了､ これが新しいテキストになるかもしれません｡

07:29.440 --> 07:31.520
今､ これを送信すると､ 更新されたことがわかります｡ 

07:31.520 --> 07:35.210
そして､ すべてのTODOを取得すると､ TODOはまだ1つしかありませんが､

07:35.210 --> 07:39.430
テキストが単純に変更されていることがわかります｡

07:39.430 --> 07:41.623
これで､ TODOの更新もできるようになりました｡ 

07:42.950 --> 07:46.470
また､ 存在しないidを指定した場合はどうなるのか､ 例えばここで最後の一桁を削除すると､

07:46.470 --> 07:48.780
タイプ500のエラー応答にCould not

07:48.780 --> 07:53.430
find todoと表示されることを確認しましょう｡

07:53.430 --> 07:57.670
だから､ これもまたいい感じです｡ 

07:57.670 --> 07:59.660
最後のステップとして､ TODOを削除する機能を追加してみましょう｡ 

07:59.660 --> 08:07.210
そこで､ controllersフォルダに､ RequestHandler型のdeleteTodoという名前の定数をエクスポートします｡

08:07.210 --> 08:14.040
そしてまた､ リクエスト､ レスポンス､ そして次の関数がここにあります｡

08:14.040 --> 08:17.320
そして､ この中でTODOを見つけ､

08:17.320 --> 08:20.270
それを単純に削除したいのです｡

08:20.270 --> 08:25.090
そのために､ TODOのIDとインデックスを取得するこのコードを実際にコピーしてみましょう｡

08:25.090 --> 08:29.360
DELETEリクエストの場合､ リクエストボディはありませんが､

08:29.360 --> 08:32.210
URLのルートの一部であるTODOのidが必要なので､

08:32.210 --> 08:37.400
更新されたテキストを抽出するこの行は削除してください｡

08:37.400 --> 08:40.340
そしてインデックスを見つけ､ インデックスを取得したら､ TODOに移動してspliceメソッドを呼び出し､

08:40.340 --> 08:47.350
todoIndexにあるTodoを､ そのTodoだけを削除することができるのです｡

08:47.350 --> 08:54.040
そして､ それ以降は､ Todo deleted！という返事を送ればいいのです｡

08:54.040 --> 08:54.040
といった具合に｡ 

08:54.040 --> 08:58.490
これは私たちの削除ロジックかもしれません｡ 

08:58.490 --> 08:59.380
さて､ いよいよこれを接続します｡

08:59.380 --> 09:01.760
routesフォルダで､ controllers TODOsからdeleteTodoをインポートして､

09:01.760 --> 09:04.560
下に接続しましょう｡

09:04.560 --> 09:09.963
この状態で保存すると､ サーバーを再起動するたびにすべてのTODOがクリアされるため､

09:11.120 --> 09:14.370
TODOを追加する必要があります｡

09:14.370 --> 09:16.720
そのIDをコピーしてください｡ 

09:16.720 --> 09:20.550
そして､ そのDELETEリクエストを送信してみましょう｡ 

09:20.550 --> 09:22.680
そこで､ http:/localhost:3000/todos/this

09:22.680 --> 09:24.980
id への新しい DELETE リクエストを作成します｡

09:24.980 --> 09:27.160
本体を追加する必要はありません｡ 

09:27.160 --> 09:32.160
送信をクリックすると､ 動作します｡ 

09:32.800 --> 09:34.880
もう一度送ると､ 削除したばかりなので､

09:34.880 --> 09:37.180
could not findのエラーが出ます｡

09:37.180 --> 09:39.950
そして､ すべてのTODOSを取得すると､ それは空の配列となり､

09:39.950 --> 09:41.570
このようになるはずです｡

09:41.570 --> 09:42.723
これは基本的にCRUD機能であり､

09:42.723 --> 09:49.550
このシンプルなNodeとExpressのアプリにTypeScriptで追加されたものです｡

09:49.550 --> 09:50.990
もちろん､ これはかなりつまらないアプリケーションだが､

09:50.990 --> 09:52.940
すでにTypeScriptの使い方の一端を示してくれている｡

09:52.940 --> 09:56.060
このコースの残りの部分を学習すれば､ 見慣れたコードを書いていること､

09:56.060 --> 10:02.000
そしてそこで学習した機能をすべて使っていることがわかります｡

10:02.000 --> 10:04.750
そして､ Reactのセクションと同じように､ それだけが重要なのです｡ 

10:04.750 --> 10:07.610
最終的には通常のJavaScriptのコードにコンパイルされ､ それを提供することになるので､

10:07.610 --> 10:14.990
ここでもTypeScriptについて学んだことは何でも使うことができるのです｡
