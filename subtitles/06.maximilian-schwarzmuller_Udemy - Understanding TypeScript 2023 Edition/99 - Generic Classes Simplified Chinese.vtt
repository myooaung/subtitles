WEBVTT

00:02.270 --> 00:04.390
教师：好了, 关于泛型函数的讨论到此为止｡ 

00:04.390 --> 00:08.150
我们将在本课程的所有课程项目中始终使用它们｡

00:08.150 --> 00:11.890
所以我们越多地研究它, 这一点应该会越来越清楚｡

00:11.890 --> 00:14.823
大概的想法希望现在已经很清楚了｡ 

00:15.660 --> 00:18.490
泛型函数并不是我们所能使用的全部,

00:18.490 --> 00:25.170
我们还有泛型类, 因此, 让我们看看如何创建这样的泛型类, 为什么我们可以这样做,

00:25.170 --> 00:27.760
为什么这对我们有用｡

00:27.760 --> 00:31.950
我们可以在这里创建一个存储类｡ 

00:31.950 --> 00:36.060
一个类, 比如说, 它有一个私有属性数据｡ 

00:36.060 --> 00:38.850
它最终将保存一个数据数组｡ 

00:38.850 --> 00:40.940
然后它有一个addItem方法,

00:40.940 --> 00:45.763
它接受我们的项, 比如说, 它应该通过push添加到数据中｡

00:48.570 --> 00:50.830
我们有一个removeItem方法,

00:50.830 --> 00:57.740
它接受我们的项, 我们可以这样说.

00:57.740 --> 00:57.740
数据｡  然后我们只需要在这里得到indexOff（item）并拼接一个元素｡

01:02.910 --> 01:06.030
这就是我们如何从数组中移除元素｡ 

01:06.030 --> 01:07.873
当然还有getItems, where

01:09.750 --> 01:15.770
return, 比如一个副本. 数据, 就像你学过的spread运算符一样｡

01:16.610 --> 01:17.443
现在我们可以这样做了,

01:17.443 --> 01:19.450
但我们在这里得到了一堆错误｡

01:19.450 --> 01:20.500
我们遇到了一系列错误,

01:20.500 --> 01:25.230
现在举一个例子, 因为名称Storage是保留名称, 所以我们将其命名为Datastorage｡

01:25.230 --> 01:26.620
这很容易摆脱｡ 

01:26.620 --> 01:27.920
现在, 我们也会在这里得到一个错误,

01:27.920 --> 01:32.960
因为我们没有说明我们存储的数据类型, 以及item的类型｡

01:32.960 --> 01:38.860
这正是我们可以把它转换成泛型类的地方因为你可能不关心数据的类型.

01:38.860 --> 01:40.880
我们要确保它是统一的数据,

01:40.880 --> 01:42.410
所以它要么只是字符串,

01:42.410 --> 01:44.830
要么只是数字, 要么只是对象｡

01:44.830 --> 01:47.550
但除此之外, 我不在乎｡ 

01:47.550 --> 01:50.820
所以我们可以把它变成泛型类, 在类名后面加上尖括号,

01:50.820 --> 02:00.110
然后再加上T, U, 你想用的任何标识符, 然后把它作为泛型类型.

02:00.110 --> 02:01.083
现在我们可以说,

02:01.083 --> 02:07.413
这是一个T类型的数组, 所以它存储了泛型类型的数据.

02:07.413 --> 02:09.670
因此, 我们在这里添加这样的数据,

02:09.670 --> 02:12.400
我们试图在这里删除这样的数据｡

02:12.400 --> 02:18.490
因此, 我们在这里得到的项正确地被推断为返回一个泛型类型的数组｡

02:18.490 --> 02:24.690
现在, 我们可以创建不同的存储, 我们可以在这里使用sting或textStorage,

02:24.690 --> 02:31.250
方法是调用新的DataStorage, 在这里将通用类型设置为string类型｡

02:31.250 --> 02:34.340
在textStorage中, 我可以调用addItem,

02:34.340 --> 02:36.410
如果我尝试添加一个数字, 我会得到一个错误,

02:36.410 --> 02:40.800
因为我说这将是一个只存储字符串的DataStorage｡

02:40.800 --> 02:51.450
我可以在这里存储Max, 也可以存储Manu, 然后调用textStorage.

02:51.450 --> 02:51.450
removeItem（'Max

02:51.450 --> 02:55.073
'）, 然后选择控制台｡ 记录｡  text存储｡  获取项｡ 

02:56.520 --> 02:58.870
如果我们保存的话, 这应该都可以,

02:58.870 --> 03:00.300
因为它是泛型类型,

03:00.300 --> 03:03.103
实际上在最后我们只有Manu.

03:04.400 --> 03:08.240
所以这是一个我们可以创建的简单泛型类｡ 

03:08.240 --> 03:10.500
现在, 我们为什么要构建这样一个泛型类呢？

03:10.500 --> 03:11.770
正如我所说的,

03:11.770 --> 03:14.220
因为我们可能不只是想存储文本,

03:14.220 --> 03:18.950
我可能还想在不同的数据存储中存储一些数字｡

03:18.950 --> 03:21.510
因此, 我可以创建这样一个DataStorage,

03:21.510 --> 03:26.250
并将其设置为number, 以确保现在我们只能向该存储添加数字｡

03:26.250 --> 03:30.520
当然, 我们也可以通过使用联合类型来设置一个允许这两种类型的存储｡

03:30.520 --> 03:32.550
所以, 我们有了充分的灵活性,

03:32.550 --> 03:36.470
但是我们给了type一些额外的信息,

03:36.470 --> 03:41.450
这使得它既灵活又是强类型的类｡

03:41.450 --> 03:43.470
就像函数一样｡ 

03:43.470 --> 03:46.910
真正灵活和仍然完美的类型支持｡ 

03:46.910 --> 03:49.900
这就是泛型类型背后的全部思想｡ 

03:49.900 --> 03:53.750
因此, 在这里, 我们可以通过存储字符串､ 数字或任何我们想要的东西,

03:53.750 --> 03:56.513
使用DataStorage类来实现这一点｡

03:57.790 --> 04:01.300
不过, 我们的dataStorage类有一个问题｡ 

04:01.300 --> 04:07.090
假设我有了对象存储, 现在我可以创建新的DataStorage,

04:07.090 --> 04:12.270
并在其中说我想存储对象, 对, 我想存储对象, 当然,

04:12.270 --> 04:17.270
我们可以转到对象存储并添加一个项目｡

04:17.300 --> 04:20.460
假设有一个物体我把它叫做麦克斯.

04:20.460 --> 04:24.760
我们还存储另一个对象, 在那里存储Manu｡

04:24.760 --> 04:28.310
然后, 假设我们在代码中执行一些操作,

04:28.310 --> 04:29.740
稍后, 我将删除该项,

04:29.740 --> 04:34.100
我将删除name为的项：我是马努

04:34.100 --> 04:37.863
然后, 我想安慰一下｡  记录｡  对象存储｡  获取项｡ 

04:39.450 --> 04:40.550
就像这样

04:40.550 --> 04:41.883
如果我们保存它, 我们会看到里面有一个对象,

04:42.920 --> 04:45.840
那就是Max｡

04:45.840 --> 04:47.470
看起来不错吧｡ 

04:47.470 --> 04:49.140
现在, 这不是真的好｡ 

04:49.140 --> 04:55.740
假设我现在要删除Max, 那么现在应该在数据存储中保留Manu｡

04:55.740 --> 04:59.653
因此, 如果我重新加载, a, 它仍然是最大｡ 

05:00.550 --> 05:03.660
现在的问题是, 我们在这里使用的是对象, 正如你所知道的,

05:03.660 --> 05:07.350
JavaScript中的对象是引用类型｡

05:07.350 --> 05:09.440
现在, 附加以查找额外的资源,

05:09.440 --> 05:11.460
它允许您深入参考｡

05:11.460 --> 05:12.730
而原始值, 我假设你知道其中的区别,

05:12.730 --> 05:14.650
因为它是JavaScript的核心内容,

05:14.650 --> 05:19.060
与typescript完全无关｡

05:19.060 --> 05:22.300
这里的问题是, 我们的类是用这个逻辑来构建的,

05:22.300 --> 05:32.200
这个逻辑是关于如何删除和标识数据的, 当我们处理非基元值时, 我们并没有真正做好工作｡

05:32.200 --> 05:35.130
所以, 当我们处理对象或数组时, 因为indexOf,

05:35.130 --> 05:37.840
如果我们在这里传入一个对象, 它将不起作用,

05:37.840 --> 05:40.910
因为从技术上讲, 这是一个新对象｡

05:40.910 --> 05:43.800
它看起来像这样, 但它不起作用, 因为从技术上讲,

05:43.800 --> 05:48.290
这是内存中的一个全新对象, 并且有不同的地址｡

05:48.290 --> 05:52.110
实际上在这里, JavaScript会寻找地址,

05:52.110 --> 05:54.930
但基本上找不到, 所以它会删除数组中的最后一个元素,

05:54.930 --> 06:01.473
因为它最后返回-1｡

06:02.419 --> 06:06.070
IndexOf返回-1, 即使它没有找到任何内容｡ 

06:06.070 --> 06:09.770
这意味着它从数组的末尾开始, 这是正常的Javascript行为,

06:09.770 --> 06:11.921
并删除数组的最后一个元素｡

06:11.921 --> 06:14.190
这就是为什么它对Manu有效,

06:14.190 --> 06:21.760
它没有真正有效, 它偶然地有效, 但为什么它对Max不起作用, 我们现在总是删除数组的最后一个元素,

06:21.760 --> 06:23.670
因为我们不能识别它｡

06:23.670 --> 06:29.140
现在, 至少可以解决这个问题的一个方法是检查我们是否找到了我们的项目,

06:29.140 --> 06:32.260
所以我们可以检查这里的代码, 如果等于-1,

06:32.260 --> 06:36.260
这意味着我们没有找到它｡

06:36.260 --> 06:37.360
然后我们可以返回,

06:37.360 --> 06:40.780
并确保我们没有意外删除错误的项目｡

06:40.780 --> 06:42.900
当然, 现在我们刚刚修复了那个栏,

06:42.900 --> 06:44.850
但我们仍然没有这种内部状态,

06:44.850 --> 06:46.580
它将与对象一起工作｡

06:46.580 --> 06:48.890
它唯一能处理对象的方法,

06:48.890 --> 06:51.740
就是我们再次传递相同的对象.

06:51.740 --> 06:55.700
如果我把max对象存储在一个常量中, 就像这样,

06:55.700 --> 06:58.840
在这里我传递max对象.

06:58.840 --> 07:02.050
我在这里做了同样的事情, 然后我真的使用了相同的,

07:02.050 --> 07:06.540
完全相同的对象, 内存中完全相同的对象, 因此, 现在它可以工作了｡

07:06.540 --> 07:08.930
这将是唯一的办法, 使我们的工作｡ 

07:08.930 --> 07:16.150
因此, 在这里, 更好的办法可能是确保这只对原始值有效｡

07:16.150 --> 07:20.100
所以我们可以说T扩展了字符串,

07:20.100 --> 07:24.010
数字, 或者所有的布尔加法.

07:24.010 --> 07:27.920
因此, 现在我们基本上可以说, DataStorage应该只适用于这些类型｡

07:27.920 --> 07:30.470
因此, 不再允许使用对象｡ 

07:30.470 --> 07:35.220
这在这里可能更好, 因为我们需要一个更专门的DataStorage,

07:35.220 --> 07:40.080
它可能只对对象起作用, 而不对基元值起作用｡

07:40.080 --> 07:42.430
在这里微调我们的检索逻辑,

07:42.430 --> 07:45.880
以便检查应该删除的项目中的一些iD｡

07:45.880 --> 07:46.970
它在这里的工作方式,

07:46.970 --> 07:48.910
实际上只对基元类型有效,

07:48.910 --> 07:52.320
所以设置这样的约束绝对是个好主意｡

07:52.320 --> 07:57.253
如果我们保存了它, 在注释掉它之后, 它当然又可以工作了｡

07:58.810 --> 08:04.310
现在不用说了, 当然你也可以有不止一个泛型类型｡

08:04.310 --> 08:07.600
当您使用类别时, 并不局限于一种类型｡

08:07.600 --> 08:13.080
你也可以有方法, 它们有自己的泛型类型而不是类｡

08:13.080 --> 08:18.010
所以你可以在类方法中引入新的泛型类型, 如果你有一些泛型类型,

08:18.010 --> 08:19.750
它只在某个方法中需要,

08:19.750 --> 08:21.580
而不是在整个类中｡

08:21.580 --> 08:23.000
所以你在这方面很灵活｡ 

08:23.000 --> 08:25.570
您可以在任何地方使用约束,

08:25.570 --> 08:30.240
一般来说, 泛型类型可以使您的工作更轻松,

08:30.240 --> 08:36.010
并为您提供完全灵活性的完美组合｡

08:36.010 --> 08:39.310
我们可以在这里使用您想要的任何基元值和类型安全,

08:39.310 --> 08:42.820
因为我们非常清楚这个DataStorage中存储了什么,

08:42.820 --> 08:46.770
以及这个DataStorage中存储了什么｡

08:46.770 --> 08:52.283
所以这个组合就是泛型类型带给我们的最棒的东西｡
