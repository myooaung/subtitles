WEBVTT

00:02.200 --> 00:04.920
ผู้พูด: นั่นคือคลาส คุณสมบัติ และการสืบทอดด้วย

00:04.920 --> 00:07.510
Typescript

00:07.510 --> 00:08.343
และอย่างที่ฉันได้กล่าวไปแล้ว

00:08.343 --> 00:14.230
แม้ว่าโดยทั่วไปแล้วฟีเจอร์เหล่านี้จะได้รับการสนับสนุนใน Javascript ใน JavaScript สมัยใหม่

00:14.230 --> 00:21.060
แน่นอนว่ายกเว้นการกำหนดประเภท และยกเว้นสาธารณะส่วนตัวที่ได้รับการป้องกัน

00:21.060 --> 00:24.770
คำหลักเหล่านี้ใช้ได้เฉพาะใน typescript เท่านั้น

00:24.770 --> 00:28.560
ตอนนี้ยังไม่ใช่ทั้งหมดที่คุณสามารถทำได้ในชั้นเรียน

00:28.560 --> 00:32.840
เมื่อใดก็ตามที่ต้องการคุณสมบัติที่คุณมีในวานิลลา

00:32.840 --> 00:35.670
JavaScript ซึ่งรองรับใน Typescript

00:35.670 --> 00:38.610
เช่นกันคือ getters และ setters

00:38.610 --> 00:42.050
มาดูกันว่าที่นี่ในแผนกบัญชี ตัวอย่างเช่น

00:42.050 --> 00:43.390
สมมติว่าเรามีรายงานล่าสุด

00:43.390 --> 00:47.450
พร็อพเพอร์ตี้

00:47.450 --> 00:51.630
ซึ่งเป็นคุณสมบัติส่วนตัว และเป็นสตริงประเภท

00:51.630 --> 00:53.310
ดังนั้นเราจึงมี

00:53.310 --> 00:56.480
จากนั้นที่นี่ เราเริ่มต้นสิ่งนี้ เพื่อเป็นอาร์กิวเมนต์คำสั่งคุณสมบัติรายงานของเรา

00:56.480 --> 01:04.880
ที่เราได้รับที่นี่ และพวกมันคือค่าแรก

01:04.880 --> 01:09.890
ซึ่งแน่นอนว่าไม่ได้กำหนดโดยพื้นฐานหากเราผ่านเข้ามาและอาร์เรย์รายงานว่างเปล่า

01:09.890 --> 01:14.680
เมื่อเราเพิ่มรายงาน ผมต้องการตั้งค่ารายงานล่าสุดนี้

01:14.680 --> 01:17.010
เท่ากับข้อความ

01:17.010 --> 01:20.440
ซึ่งเป็นสิ่งที่เราเพิ่มในอาร์เรย์รายงานของเรา

01:20.440 --> 01:23.890
ตอนนี้รายงานล่าสุดเป็นแบบส่วนตัว ดังนั้นเราสามารถเข้าถึงได้จากภายในวิธีนี้

01:23.890 --> 01:30.240
แต่เราจะไม่สามารถเข้าถึงได้จากภายนอกด้วยเครื่องหมายจุด

01:30.240 --> 01:33.440
ตอนนี้เราสามารถเพิ่ม getter เพื่อให้สามารถเข้าถึงได้

01:33.440 --> 01:44.460
getter เป็นคุณสมบัติโดยพื้นฐานที่คุณรันฟังก์ชันหรือเมธอดเมื่อคุณเรียกค่าและนั่นช่วยให้คุณในฐานะนักพัฒนาสามารถเพิ่มตรรกะที่ซับซ้อนมากขึ้นได้

01:44.460 --> 01:49.250
ที่นี่ คุณสร้าง getter โดยใช้คำสำคัญ get แล้วตามด้วยชื่อใดก็ได้ที่คุณเลือก

01:49.250 --> 01:54.180
โดยทั่วไปจะเกี่ยวข้องอย่างใกล้ชิดกับพร็อพเพอร์ตี้ที่คุณพยายามควบคุมการเข้าถึง

01:54.180 --> 01:58.180
ตัวอย่างเช่น ที่นี่ เราสามารถตั้งชื่อเป็นรายงานล่าสุด

01:58.180 --> 01:59.340
อะไรก็ได้อย่างนั้น

01:59.340 --> 02:01.630
สิ่งสำคัญตอนนี้ถูกกำหนดเป็นวิธีการ

02:01.630 --> 02:04.260
ดังนั้นคุณจึงใส่วงเล็บแล้ววงเล็บปีกกา

02:04.260 --> 02:07.250
และตรงนี้ คุณต้องคืนบางอย่าง ซึ่งเป็นสิ่งสำคัญที่

02:07.250 --> 02:11.990
getter method ต้องส่งคืนบางอย่าง

02:11.990 --> 02:14.610
คุณจึงส่งรายงานล่าสุดนี้กลับมาได้ จากนั้นเราจะสรุปสิ่งนี้

02:14.610 --> 02:19.570
เนื่องจากขณะนี้สามารถเข้าถึงได้โดยสาธารณะแล้ว

02:19.570 --> 02:22.720
แต่บ่อยครั้งที่คุณต้องการมีตรรกะที่ซับซ้อนกว่านี้

02:22.720 --> 02:27.600
ตรงนี้เราตรวจสอบได้ว่าเรามีค่าตรงนี้ไหม ถ้านี่คือความจริง

02:27.600 --> 02:28.960
หากไม่ได้กำหนด เราต้องการส่งคืนรายงานล่าสุด

02:28.960 --> 02:37.850
มิฉะนั้น เราอาจต้องการส่งคืนตรรกะที่แตกต่างกัน ตัวอย่างเช่น สมมติว่าเราโยนข้อความแสดงข้อผิดพลาดโดยโยนข้อผิดพลาดใหม่

02:37.850 --> 02:42.650
ไม่พบรายงาน

02:42.650 --> 02:46.650
ตอนนี้เราได้เพิ่มตรรกะ ตรรกะที่ซับซ้อนมากขึ้น ให้กับคุณสมบัตินี้

02:46.650 --> 02:51.500
และเมื่อเราต้องการดึงข้อมูล เราไม่สามารถดึงคุณสมบัตินี้โดยตรงผ่านเครื่องหมายจุด

02:51.500 --> 02:57.240
แต่เราสามารถใช้คุณสมบัตินี้เพื่อสิ้นสุดการรันตรรกะนี้ได้

02:57.240 --> 02:58.810
แล้ววิธีนี้จะทำงานอย่างไร?

02:58.810 --> 03:02.170
ที่นั่นฉันสร้างแผนกบัญชีของฉัน

03:02.170 --> 03:08.693
ก่อนที่ฉันจะเพิ่มรายงานของฉัน หากฉันพยายามบันทึกคอนโซล การลงบัญชี

03:08.693 --> 03:08.693
รายงานล่าสุดและตอนนี้สำคัญ

03:11.010 --> 03:13.902
อ๊ะ การบัญชี รายงานล่าสุด

03:13.902 --> 03:16.890
และที่สำคัญตอนนี้คุณเข้าถึงสิ่งนี้ในฐานะทรัพย์สิน

03:16.890 --> 03:18.690
ดังนั้นจึงไม่มีวงเล็บที่นี่

03:18.690 --> 03:20.570
คุณไม่ได้ดำเนินการนี้เป็นวิธีการ

03:20.570 --> 03:23.030
คุณเพียงแค่เข้าถึงมันได้เหมือนทรัพย์สินทั่วไป

03:23.030 --> 03:27.890
และเบื้องหลัง มันจะดำเนินการตามวิธีนี้ที่นั่น

03:27.890 --> 03:33.940
ดังนั้น ถ้าฉันลองตอนนี้ก่อนที่เราจะเพิ่มรายงาน เราจะเห็นว่าสิ่งนี้สร้างใหม่โดยไม่มีข้อผิดพลาด

03:33.940 --> 03:35.440
คอมไพล์ใหม่โดยไม่มีข้อผิดพลาด

03:35.440 --> 03:42.820
แต่แน่นอนว่ามีข้อผิดพลาดเกิดขึ้น นี่คือข้อผิดพลาดที่เราไม่พบรายงาน เนื่องจากยังไม่มีการเพิ่มรายงาน และ เนื่องจากใช้สิ่งนี้เป็น

03:42.820 --> 03:48.310
getter เข้าถึงวิธีนี้และดำเนินการ

03:48.310 --> 03:51.560
ถ้าเราไม่มีรายงาน เราจะไม่ตรวจสอบ IF นี้หรือในคำสั่ง

03:51.560 --> 03:55.693
IF นี้ ดังนั้นบรรทัดนี้จึงเริ่มขึ้น

03:56.590 --> 04:00.250
อีกทางเลือกหนึ่งหากเราจะย้ายข้อมูลนั้นลง หลังจากที่เราเพิ่มรายงานแล้ว

04:00.250 --> 04:02.210
แน่นอนว่าเราสามารถบันทึกได้

04:02.210 --> 04:08.400
และเราจะไม่ได้รับข้อผิดพลาดอีกต่อไป แต่เราจะแสดงรายงานล่าสุดนี้แทน

04:08.400 --> 04:09.750
นั่นคือทะเยอทะยาน

04:09.750 --> 04:12.190
และคุณยังสามารถเพิ่มตัวตั้ง

04:12.190 --> 04:14.550
ตัวตั้งค่าจะถูกเพิ่มในลักษณะเดียวกัน

04:14.550 --> 04:18.630
คุณใช้คำหลักที่ตั้งไว้ จากนั้นจึงตั้งชื่อตามที่คุณเลือกอีกครั้ง

04:18.630 --> 04:22.870
โดยทั่วไปจะเป็นชื่อที่เกี่ยวข้องกับคุณสมบัติที่ควรตั้ง

04:22.870 --> 04:25.570
ดังนั้น ฉันจะใช้รายงานล่าสุดซ้ำที่นี่

04:25.570 --> 04:29.150
เพื่อให้เราสามารถใช้ทั้งการอ่านค่าและตั้งค่า

04:29.150 --> 04:31.850
แล้วคุณก็กำหนดมันเหมือนเป็นเมธอด

04:31.850 --> 04:34.850
แต่ตอนนี้สิ่งนี้จำเป็นต้องโต้แย้ง

04:34.850 --> 04:38.630
ค่าที่ผู้ใช้จะส่งเข้ามา

04:38.630 --> 04:40.940
ในที่นี่ควรมีค่าสตริง และตอนนี้คุณสามารถเรียกใช้ตรรกะใดๆ

04:40.940 --> 04:46.160
ที่คุณต้องการจัดเก็บได้

04:46.160 --> 04:48.530
ตอนนี้ที่นี่เนื่องจากมีการส่งค่าสำหรับรายงานล่าสุด

04:48.530 --> 04:53.080
ในที่สุดฉันต้องการดำเนินการเพิ่มรายงาน

04:53.080 --> 04:57.140
ดังนั้น setter อาจเป็นทางเลือกแทนวิธีการเพิ่มรายงาน

04:57.140 --> 05:01.280
ที่นี่เราสามารถเข้าถึงรายงานการเพิ่มนี้ได้

05:01.280 --> 05:03.760
สิ่งนี้จำเป็นเนื่องจากเราอยู่ในชั้นเรียน

05:03.760 --> 05:07.280
เราอ้างถึงคลาสแล้วถึงคลาสเมธอดนี้ที่นี่

05:07.280 --> 05:10.380
และตอนนี้เราสามารถส่งต่อมูลค่าตรงนี้ได้

05:10.380 --> 05:12.310
ตอนนี้เราสามารถเพิ่มตรรกะที่ซับซ้อนมากขึ้น

05:12.310 --> 05:24.020
และตรวจสอบด้วยว่าค่าอาจไม่ถูกกำหนดหากเป็นเท็จ จากนั้นเพียงแค่ส่งกลับหรือโยนข้อผิดพลาดใหม่ของคุณ โดยที่เราบอกว่าโปรดส่งค่าที่ถูกต้อง

05:24.020 --> 05:26.140
นั่นคือสิ่งที่เราสามารถทำได้เช่นกัน

05:26.140 --> 05:29.010
และตอนนี้เรากำลังใช้ตัวตั้งที่นี่เช่นกัน

05:29.010 --> 05:31.330
เมื่อเพิ่มเข้าไป เราสามารถทดสอบได้

05:31.330 --> 05:36.570
ที่นั่น ฉันสามารถเพิ่มรายงานล่าสุดได้

05:36.570 --> 05:38.780
ฉันเข้าถึงสิ่งนี้ได้ทางบัญชี และเราก็อ่านได้จากสิ่งนี้เหมือนกัน

05:38.780 --> 05:47.150
แต่ตอนนี้โดยการเพิ่มเครื่องหมายเท่ากับ เรากำลังพยายามตั้งค่าให้กับสิ่งนั้น และนั่นจะทริกเกอร์เมธอดตัวตั้งค่านี้

05:47.150 --> 05:50.090
อีกครั้งก่อนที่เราจะไม่ได้เรียกใช้งานเป็นเมธอด

05:50.090 --> 05:52.383
แต่เข้าถึงได้เหมือนพร็อพเพอร์ตี้

05:53.220 --> 05:56.030
ตรงนี้ถ้าฉันส่งผ่านสตริงว่าง

05:56.030 --> 05:58.770
ในทางเทคนิคเราจะส่งผ่านสตริง

05:58.770 --> 06:02.760
แต่สตริงว่างจะถือว่าเป็นเท็จ ดูที่นี่

06:02.760 --> 06:04.950
ดังนั้นตอนนี้เราควรได้รับข้อผิดพลาด

06:04.950 --> 06:09.850
ดังนั้น ถ้าฉันบันทึกโค้ดบรรทัดนี้ ถ้าฉันบันทึกโค้ดโดยเพิ่มโค้ดบรรทัดนี้

06:11.120 --> 06:14.530
เราได้รับข้อผิดพลาดนี้ โปรดส่งค่าที่ถูกต้อง

06:14.530 --> 06:17.010
ถ้าฉันส่งผ่านค่าที่ถูกต้อง

06:17.010 --> 06:23.900
เช่น ถ้าฉันพูดว่า year-end report ที่นี่ และตอนนี้ฉันจะบันทึกสิ่งนี้

06:23.900 --> 06:29.620
ตอนนี้คุณจะเห็นการทำงานทั้งหมดและรายงานสิ้นปีเป็นส่วนหนึ่งของรายการรายงานของเรา

06:29.620 --> 06:31.150
ดังนั้น สิ่งเหล่านี้คือตัวรับและตัวตั้ง

06:31.150 --> 06:40.243
ซึ่งเหมาะสำหรับห่อหุ้มลอจิก และสำหรับการเพิ่มลอจิกพิเศษ ซึ่งควรทำงานเมื่อคุณพยายามอ่านคุณสมบัติ หรือเมื่อคุณพยายามตั้งค่าคุณสมบัติ
