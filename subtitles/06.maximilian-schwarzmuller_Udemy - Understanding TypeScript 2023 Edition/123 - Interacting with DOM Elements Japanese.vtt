WEBVTT

00:02.400 --> 00:04.390
講師：最初のフォームをレンダリングしましたが､

00:04.390 --> 00:07.240
スタイリングが少しずれていることにお気づきでしょう｡

00:07.240 --> 00:09.200
つまり､ フォームは問題なく見えますが､

00:09.200 --> 00:13.870
画面の端とフォームの間に距離があるとよいでしょう｡

00:13.870 --> 00:15.830
アプリに飛び込めば cssファイルには､

00:15.830 --> 00:21.050
ユーザー入力IDのセレクタがあることがわかると思います｡

00:21.050 --> 00:23.330
マージンパディングを追加するとしても､ それはそれで悪くないと思うので､

00:23.330 --> 00:28.060
実はできることはアプリなんです｡

00:28.060 --> 00:28.060
tsは､

00:28.060 --> 00:31.740
ここで要素を作成するとき､ またはそれにアクセスするときです｡

00:31.740 --> 00:36.840
要素に手を伸ばして､ ここにユーザが入力するようなIDを追加することができます｡

00:36.840 --> 00:39.740
これにより､ レンダリングされた要素がこのIDを持つことを確認し､

00:39.740 --> 00:42.800
その結果､ 再読み込みの際に､ よりきれいに表示されるようになります｡

00:42.800 --> 00:45.100
ブラウザの奥行きでこれを検査すると､ ここにIDが表示され､

00:45.100 --> 00:49.320
それがこのようにスタイルを良くしている理由です｡

00:49.320 --> 00:54.010
これでもう次のステップ､ 要素とのインタラクションができるようになりました｡

00:54.010 --> 00:56.980
今､ 私がやりたいのは､ このやりとりだけではありません｡ 

00:56.980 --> 00:58.770
ここにフォームがあるので､

00:58.770 --> 01:01.870
フォームが送信されたときに値を読み取ることができるように､

01:01.870 --> 01:12.160
ここにあるさまざまなフォーム入力にアクセスできるようにしたいと思います｡

01:12.160 --> 01:15.720
そのため､ ボタンやフォーム全体へのアクセスが必要で､ 送信をリッスンし､

01:15.720 --> 01:21.273
そこから最新の値を取得するためにすべての入力要素へのアクセスが必要です｡

01:22.360 --> 01:25.440
ここでは､ すべてをアタッチする前に､

01:25.440 --> 01:28.500
しかしここで要素にIDを割り当てた後､

01:28.500 --> 01:44.570
フォームのその要素のさまざまな入力にアクセスしたいので､ それらをこのクラスのプロパティとして保存します｡

01:44.570 --> 01:47.167
型はHTMLInputElementになりますこれを書くと､

01:48.060 --> 01:52.770
我々は他の2つの同様のフィールドを必要とする一度だけそれを必要としないでしょう｡

01:52.770 --> 01:57.550
HTMLInputElement型のdescriptionInputElementフィールドと､

01:58.520 --> 02:02.730
peopleInputElementフィールドが必要です｡

02:02.730 --> 02:11.510
コンストラクタでこれらのフィールドに入力することができます｡

02:11.510 --> 02:11.510
要素に､

02:11.510 --> 02:13.120
form 要素､

02:13.120 --> 02:16.390
クエリセレクタ､ そして title

02:16.390 --> 02:21.350
要素のクエリを追加します｡

02:21.350 --> 02:25.000
そして､ もう一度インデックスを見ていただくと｡  html では､ この要素の ID

02:25.000 --> 02:33.323
title を取得し､ それをクエリで取得することができます｡

02:33.323 --> 02:33.323
ここでは､

02:33.323 --> 02:39.750
クエリセレクタで#titleを使用してタイトルID要素を選択し､ それをtitleInputElementに格納することができることを示します｡

02:39.750 --> 02:50.650
さて､ document get element by IDと同じように､ typescriptはクエリセレクタがここでinput要素を返そうとしていることを理解するチャンスがないことはご存知の通りです｡

02:50.650 --> 02:53.780
そこで､ typescriptに伝えるために､ 再びキャスティングを使用して､

02:53.780 --> 02:56.020
これをinput要素にキャストします｡ この手順を2回繰り返して､

02:56.020 --> 03:03.240
descriptionInputElementとpeopleInputElementにも署名をします｡

03:03.240 --> 03:06.600
インデックスで該当するIDを検索する｡  htmlファイル､ これは意外と説明文と人だと思うのですが､

03:06.600 --> 03:12.190
それをtypescriptに追加します｡

03:12.190 --> 03:17.720
ここでは説明のID要素を検索し､ ここでは人を検索しているわけです｡

03:17.720 --> 03:22.687
そして､ このクラスの内部､ またはクラスに基づいて作成されるすべてのオブジェクトの内部にある､

03:22.687 --> 03:26.593
これらの要素にアクセスできるようになりました｡

03:27.600 --> 03:33.330
あとは､ 要素やフォームにリスナーを追加するだけです｡

03:33.330 --> 03:38.330
そのために､ もうひとつのプライベートメソッド configure を追加します｡

03:38.440 --> 03:39.790
これは追加する必要はありませんが､

03:39.790 --> 03:47.900
基本的にコンストラクタで選択と大まかな設定を行うという分離を維持したいのです｡

03:47.900 --> 03:52.210
そして､ 別メソッドで挿入や微調整を行う｡

03:52.210 --> 03:53.900
そして､ configureメソッドでは､

03:53.900 --> 04:01.830
イベントリスナーを設定することを考えています｡

04:01.830 --> 04:04.570
typescriptはこの要素がHTMLのform要素であることを知っているので､

04:04.570 --> 04:12.250
submitイベントを聞くときに自動補完を提供してくれます｡

04:12.250 --> 04:17.840
なぜなら､ クラスの外からこのメソッドにアクセスすることはなく､

04:17.840 --> 04:23.460
内部からアクセスするだけだからです｡

04:23.460 --> 04:26.970
ここではsubmitHandlerと名付けますが､ 名前はあなた次第です｡ 

04:26.970 --> 04:32.750
これは､ イベントオブジェクトを受け取るメソッドでなければなりません｡

04:32.750 --> 04:34.880
そこで､ ここで指摘できるのは...｡ 

04:36.460 --> 04:38.713
サブミットハンドラ｡ 

04:40.180 --> 04:42.080
ここで､ すべての呼び出しをアタッチする前に､

04:42.992 --> 04:59.290
このプライベートメソッドを構成して実行するように調整します｡ ここでもプライベートなので､ クラスの内部からはもちろん到達できますが､ 外部からは typescript エラーが発生します｡

04:59.290 --> 05:02.010
サブミットハンドラでは､ さまざまな入力値にアクセスし､

05:02.010 --> 05:10.310
それらを検証し､ そしてもちろん､ 入力に対して何かを行いたいのです｡

05:10.310 --> 05:12.700
さて､ 「何かする」部分については後で考えるとして､

05:12.700 --> 05:15.480
とりあえずアクセスできるようにしましょう｡

05:15.480 --> 05:18.430
そのためにまず､ イベントを呼び出すことにします｡  preventDefault

05:18.430 --> 05:23.890
はデフォルトのフォーム送信を防ぐもので､ ここでは望まない HTTP

05:23.890 --> 05:32.730
リクエストの送信を引き起こします｡

05:32.730 --> 05:32.730
title

05:32.730 --> 05:36.250
要素の値を記録し､ 現在 title 入力要素に入力されている内容を表示する｡

05:36.250 --> 05:39.010
保存してみると､ エラーもなくコンパイルされているので､

05:39.010 --> 05:40.560
いい感じです｡

05:40.560 --> 05:51.657
そして､ ここでコンソールに「Hello！」と入力すると､ 「Hello! というエラーが発生しました｡

05:51.657 --> 05:51.657
さて､ ここで何が問題なのでしょうか？

05:51.657 --> 05:56.173
ここで問題なのは､ submitHandlerのこのキーワードが､ 実際にはクラスを指していないことです｡

05:57.730 --> 06:02.230
なぜ？

06:02.230 --> 06:06.420
JavaScriptとtypescriptの仕組みからすると､

06:06.420 --> 06:07.760
ここでメソッドをイベントリスナーにバインドしています｡

06:07.760 --> 06:14.680
イベントやイベントリスナーの助けを借りて何かをバインドすると､ 実行されるメソッドは他の何か､

06:14.680 --> 06:24.210
この場合はイベントの現在のターゲットにバインドされることになります｡

06:24.210 --> 06:27.270
そのため､ このメソッドがイベントリスナーによってトリガーされた場合､

06:27.270 --> 06:35.130
このメソッドの末尾はクラスを指すことはありません｡

06:35.130 --> 06:40.360
そして､ bindに渡す最初の引数は､

06:40.360 --> 06:56.450
thisキーワードが実行される関数の内部で参照するものです｡

06:56.450 --> 06:59.760
そして､ ここではこれを渡しています｡ つまり､ submitHandlerの中のこれは､

06:59.760 --> 07:05.750
このコンテキストでこれが参照するのと同じものを参照することになります｡

07:05.750 --> 07:10.030
そして､ このconfigureのコンテキストで呼び出しているので､

07:10.030 --> 07:13.660
configureから出たこの端はクラスを参照し､

07:13.660 --> 07:22.870
bindのおかげで､ submitHandlerから出たクラスの端も参照することになります｡

07:22.870 --> 07:24.830
ここで保存して､ リロードして､ "Hello!"と入力すると､

07:24.830 --> 07:30.743
"Hello!"が表示されます｡

07:30.743 --> 07:30.743
「と表示されるようになりました｡

07:32.840 --> 07:35.600
「は､ フォームを送信するときにここに表示されます｡

07:35.600 --> 07:38.770
これで解決して､ 今はちゃんと対応しているわけです｡

07:38.770 --> 07:43.650
でも､ もっといい方法､ あるいは私たちが知っている別の方法があるのかもしれません｡

07:43.650 --> 07:46.330
デコレーターを使ったものもあるでしょうから､ ここでもう一度､

07:46.330 --> 07:54.300
一時停止して､ デコレーターを使ってこのバインディングを解いてみてください｡

07:54.300 --> 07:57.900
デコレーターのセクションで学んだことですから｡
