WEBVTT

00:02.140 --> 00:03.620
-: Vì vậy, hãy tiếp tục thực hành

00:03.620 --> 00:06.220
với những loại chung chung này bởi vì tôi biết chúng

00:06.220 --> 00:08.305
có thể khiến bạn cảm thấy kỳ lạ; Cuối cùng,

00:08.305 --> 00:09.970
họ thực sự đơn giản mặc dù.

00:09.970 --> 00:12.180
Hãy tạo một hàm chung

00:12.180 --> 00:14.810
trung bình, đếm và in.

00:14.810 --> 00:19.810
Bây giờ chức năng này sẽ nhận một số đối số, một số tham số.

00:20.330 --> 00:23.470
Hãy đặt tên cho nó là thành phần, nhưng tên thực sự

00:23.470 --> 00:26.530
tùy thuộc vào bạn nên thuộc loại chung chung.

00:26.530 --> 00:28.340
Bởi vì tôi thực sự không quan tâm đến thể

00:28.340 --> 00:30.380
loại, ít nhất là theo một số cách nhất định.

00:30.380 --> 00:33.400
Vì vậy, giả sử chúng ta có một loại chung trong hàm này

00:33.400 --> 00:35.800
và tham số của chúng ta thuộc loại đó.

00:35.800 --> 00:38.350
Nhân tiện, đó là tất cả các loại điển hình cho các loại chung.

00:38.350 --> 00:40.030
Nếu bạn có một chức năng chung, thì

00:40.030 --> 00:42.180
thường tham số của bạn sẽ thuộc loại đó.

00:42.180 --> 00:43.890
Không nhất thiết phải như vậy, nhưng thường

00:43.890 --> 00:45.890
thì đó là cách bạn làm việc với các hàm chung, như

00:45.890 --> 00:46.920
bạn sẽ thấy, khi bạn ngày

00:46.920 --> 00:49.080
càng có nhiều kinh nghiệm hơn với chúng.

00:49.080 --> 00:50.670
Vì vậy, ở đây chúng tôi đã đếm

00:50.670 --> 00:52.350
và in với loại chung của chúng

00:52.350 --> 00:54.430
tôi ở đây và phần tử thuộc loại đó.

00:54.430 --> 00:56.500
Bây giờ cái tôi muốn trả về

00:56.500 --> 01:00.300
ở đây là bộ nienda có hai phần tử trong đó phần tử

01:00.300 --> 01:03.190
đầu tiên phải là chính phần tử của tôi

01:03.190 --> 01:07.070
và phần tử thứ hai phải là một chuỗi mô tả.

01:07.070 --> 01:10.160
Do đó, có lẽ chúng ta đặt tên cho nó là đếm và mô tả.

01:10.160 --> 01:15.160
Vì vậy, ở đây tôi có văn bản mô tả của mình và ở đây tôi sẽ nói là không

01:15.410 --> 01:19.890
có giá trị và tôi muốn sử dụng giá trị đó nếu chúng ta chuyển

01:19.890 --> 01:22.620
vào một phần tử không có độ dài.

01:22.620 --> 01:25.570
Bởi vì ý tưởng của tôi với đếm và mô tả là chúng ta có thể

01:25.570 --> 01:29.040
truyền vào một mảng hoặc một chuỗi và chúng ta lấy lại số lượng

01:29.040 --> 01:32.040
ký tự hoặc phần tử trong chuỗi hoặc mảng đó.

01:32.040 --> 01:34.040
Vì vậy, nếu chúng ta có một

01:34.040 --> 01:37.440
chuỗi rỗng hoặc một mảng trống, tôi muốn sử dụng

01:37.440 --> 01:42.440
got no value, nhưng ở đây nếu tôi kiểm tra xem độ dài chấm của phần tử

01:43.210 --> 01:46.170
lớn hơn 0, thì tôi muốn đặt văn bản mô tả

01:47.430 --> 01:52.430
thành got cộng với độ dài chấm phần tử cộng với các phần tử.

01:55.850 --> 01:58.100
Bạn thậm chí có thể cụ thể hơn

01:58.100 --> 02:03.100
và kiểm tra xem độ dài có bằng một ở đây không, sau đó nói có

02:06.590 --> 02:11.590
một phần tử, ngược lại nếu độ dài phần tử lớn hơn một, chúng

02:11.720 --> 02:13.750
ta có văn bản mô tả bằng got

02:13.750 --> 02:18.750
cộng với các phần tử có độ dài phần tử để chúng ta có dạng số

02:18.990 --> 02:21.173
nhiều bên phải.

02:22.850 --> 02:25.220
Bây giờ ở đây, văn bản mô tả đã có cho phần tử thứ hai

02:25.220 --> 02:27.040
và quay lại đây. Bây giờ bạn đã thấy

02:27.040 --> 02:29.480
các loại phàn nàn về độ dài ở đây.

02:29.480 --> 02:32.350
Bởi vì không rõ phần tử đó có độ dài.

02:32.350 --> 02:34.770
Vì vậy, có lẽ chúng ta nên làm rõ rằng nó có.

02:34.770 --> 02:38.430
Chúng tôi có thể làm như vậy bằng cách tạo một giao diện mới hoặc

02:38.430 --> 02:41.060
một loại tùy chỉnh với từ khóa loại ở đây và ở

02:41.060 --> 02:44.750
đây tôi sẽ tìm một giao diện mà tôi sẽ đặt tên dài, cuối cùng chỉ

02:44.750 --> 02:47.440
đảm bảo rằng chúng ta có một đối tượng có thuộc

02:47.440 --> 02:50.820
tính độ dài mà nên mang lại một số cuối cùng.

02:50.820 --> 02:52.870
Và sau đó ở đây chúng ta có thể thiết lập một

02:52.870 --> 02:54.740
ràng buộc và nói rằng T kéo dài dài.

02:54.740 --> 02:57.710
Vì vậy, chúng tôi biết bất cứ thứ gì chúng tôi nhận được, chúng tôi

02:57.710 --> 03:01.053
sẽ có thuộc tính độ dài và một mảng hoặc chuỗi sẽ có thuộc tính độ dài.

03:02.030 --> 03:07.030
Bây giờ ở đây, tôi có thể đếm nhật ký bảng điều khiển,

03:07.500 --> 03:11.240
mô tả và chuyển vào, giả sử, xin chào.

03:11.240 --> 03:14.280
Bây giờ điều này hoạt động vì một chuỗi có thuộc tính độ dài.

03:14.280 --> 03:15.290
Nó không phải là một đối tượng.

03:15.290 --> 03:17.310
Đó là một chuỗi, nhưng đằng sau hậu trường, loại Javascript

03:17.310 --> 03:19.980
chuyển đổi chuỗi này thành một đối tượng mà bạn có thể nói một cách

03:19.980 --> 03:21.720
nhanh chóng và thêm thuộc tính độ dài khi chúng

03:21.720 --> 03:23.940
tôi cần. Vì vậy, do đó chúng ta có thể

03:23.940 --> 03:26.960
gọi nó một cách an toàn như thế này. Trước tiên, hãy nhập

03:26.960 --> 03:31.370
tập lệnh ở đây chúng tôi trả về một mảng có phần tử chuỗi hoặc loại

03:31.370 --> 03:33.580
T trong đó. Bây giờ tôi muốn có một

03:33.580 --> 03:36.060
bộ vì vậy tôi sẽ nói cụ thể hơn ở đây và đặt kiểu

03:36.060 --> 03:39.110
trả về về cơ bản là một mảng có chính xác hai phần tử trong

03:39.110 --> 03:41.330
đó phần tử đầu tiên sẽ thuộc loại T và phần

03:41.330 --> 03:43.850
tử thứ hai sẽ thuộc loại chuỗi.

03:43.850 --> 03:46.270
Vì vậy, bây giờ tôi chỉ nói rằng chúng ta

03:46.270 --> 03:49.360
trả về một bộ ở đây trong đó phần tử đầu tiên sẽ là bất

03:49.360 --> 03:52.010
kỳ phần tử nào thuộc kiểu chung của chúng ta

03:52.010 --> 03:54.110
và phần tử thứ hai sẽ là một chuỗi.

03:54.110 --> 03:56.820
Bây giờ, với điều đó nếu chúng ta lưu cái này, nó sẽ

03:56.820 --> 04:00.330
được biên dịch lại mà không có lỗi và in ra xin chào, có chín phần tử

04:00.330 --> 04:02.330
vì chúng ta có chín ký tự trong đó.

04:04.320 --> 04:06.890
Chúng tôi cũng có thể gọi điều này với một

04:06.890 --> 04:09.530
mảng mà chúng tôi có thể thao và nấu ăn, và bây

04:09.530 --> 04:12.460
giờ bạn sẽ thấy rằng chúng tôi có hai phần tử là

04:12.460 --> 04:15.990
văn bản mô tả hoặc với một mảng trống, tất nhiên, trong trường

04:15.990 --> 04:18.660
hợp đó, nếu tôi lưu lại thì chúng tôi không

04:18.660 --> 04:22.500
có value, nhưng chúng tôi sẽ không thể gọi số này, ví dụ: với một

04:22.500 --> 04:24.103
số vì một số không có thuộc

04:24.103 --> 04:26.333
tính độ dài và do đó, điều này không hoạt

04:26.333 --> 04:28.090
động.

04:28.090 --> 04:32.900
Vì vậy, ở đây một lần nữa, chúng ta có chức năng chung.

04:32.900 --> 04:35.043
Ý tưởng tương tự như chức năng trước đây.

04:35.043 --> 04:38.680
Chúng tôi muốn không cụ thể một chút về loại dữ liệu chúng tôi nhận

04:38.680 --> 04:40.540
được ở đây. Chúng tôi không thực sự

04:40.540 --> 04:43.180
quan tâm nếu đó là một chuỗi, nếu đó là một mảng hay bất kỳ thứ gì

04:43.180 --> 04:45.610
khác có thuộc tính độ dài. Chúng tôi chỉ quan tâm đến việc

04:45.610 --> 04:47.930
nó có thuộc tính độ dài và sau đó chúng tôi muốn làm điều

04:47.930 --> 04:49.980
gì đó với nó bởi vì chúng tôi dựa vào thuộc tính độ

04:49.980 --> 04:51.970
dài trong mã của mình, vì vậy chúng tôi cần đảm

04:51.970 --> 04:53.540
bảo rằng chúng tôi có thuộc tính đó, nhưng

04:53.540 --> 04:55.370
ngoài điều đó ra, chúng tôi thực sự không có

04:55.370 --> 04:57.330
quan tâm đến loại dữ liệu chúng tôi đang nhận được

04:57.330 --> 04:59.490
ở đây. Tôi không muốn khóa cái

04:59.490 --> 05:01.820
này thành một chuỗi hoặc một mảng và tôi không muốn

05:01.820 --> 05:04.220
tạo ra một loạt các tình trạng quá tải để xử lý tất cả

05:04.220 --> 05:05.830
các loại khác nhau có thể.

05:05.830 --> 05:08.124
Tôi cũng không muốn tạo một loại kết hợp

05:08.124 --> 05:10.970
quá dài ở đây vì tôi có thể quên các loại có thuộc tính

05:10.970 --> 05:13.610
độ dài hoặc nếu tôi tạo đối tượng của riêng mình

05:13.610 --> 05:16.220
với thuộc tính độ dài, tôi có thể không cho phép

05:16.220 --> 05:18.640
nếu tôi hạn chế điều này ở đây kiểu, chuỗi

05:18.640 --> 05:21.580
và mảng hoặc bất cứ thứ gì tương tự.

05:21.580 --> 05:23.500
Vì vậy, do đó, tôi muốn trở nên linh hoạt hơn và với

05:23.500 --> 05:25.380
các loại chung chung, chúng tôi có thể làm như

05:25.380 --> 05:27.550
vậy, chúng tôi không quan tâm đến loại chính xác.

05:27.550 --> 05:30.080
Ở đây, nhờ ràng buộc, tôi chỉ quan

05:30.080 --> 05:33.363
tâm đến việc nó có thuộc tính độ dài.
