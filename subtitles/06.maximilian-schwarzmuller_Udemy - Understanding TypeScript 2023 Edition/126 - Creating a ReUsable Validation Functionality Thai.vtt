WEBVTT

00:02.160 --> 00:06.060
ผู้สอน: แล้วเราจะตรวจสอบความถูกต้องได้อย่างไร

00:06.060 --> 00:10.450
บางทีเรามาเริ่มกันที่ผลลัพธ์สุดท้ายที่ต้องการ

00:10.450 --> 00:14.850
แนวคิดของฉันคือในภายหลังเรามีฟังก์ชันตรวจสอบความถูกต้องซึ่งยังไม่มีอยู่

00:14.850 --> 00:17.950
แต่ต่อมาเรามีฟังก์ชันนั้น ซึ่งฉันส่ง

00:17.950 --> 00:21.230
enterTitle หรือวัตถุการกำหนดค่าจริง ๆ

00:21.230 --> 00:30.300
แล้วฉันจะบอกว่าค่าคือ enterTitle ดังนั้นสิ่งนี้ ที่จะได้รับการตรวจสอบ

00:30.300 --> 00:39.130
แต่ที่ฉันยังมีคุณสมบัติเพิ่มเติมที่บอกฟังก์ชันตรวจสอบวิธีการตรวจสอบความถูกต้อง

00:39.130 --> 00:43.210
ตัวอย่างเช่น เรากำหนดให้ตั้งค่าเป็น true ที่นี่

00:43.210 --> 00:47.009
กำหนด minLength เป็น 5 เพื่อบังคับใช้อักขระ

00:47.009 --> 00:48.360
5 ตัว เป็นต้น

00:48.360 --> 00:51.540
จากนั้นเราก็ทำสิ่งนี้ที่นี่สำหรับอินพุตทั้งสาม

00:51.540 --> 00:53.900
และตรวจสอบความถูกต้องเป็นฟังก์ชันที่คืนค่าจริงหากถูกต้อง

00:53.900 --> 00:59.580
และเป็นเท็จหากไม่ถูกต้อง และสุดท้าย เราอาจได้สิ่งนี้

00:59.580 --> 01:06.790
หรือป้อนคำอธิบายและป้อนผู้คน นั่นจะเป็นแนวคิดคร่าวๆ

01:06.790 --> 01:09.210
แน่นอนว่ามันเป็นเพียงวิธีหนึ่งในการนำไปใช้

01:09.210 --> 01:11.703
แต่เป็นวิธีที่ฉันชอบมากทีเดียว

01:12.600 --> 01:19.470
เพื่อที่ด้านบนของไฟล์ ฉันจะเพิ่มตรรกะการตรวจสอบบางอย่าง

01:19.470 --> 01:22.380
และอีกครั้ง มีหลายวิธีในการทำเช่นนี้

01:22.380 --> 01:27.840
ก่อนอื่นฉันจะเริ่มต้นด้วยการกำหนดโครงสร้างของวัตถุที่ตรวจสอบได้

01:27.840 --> 01:31.280
ดังนั้นวัตถุนี้เราส่งไปยังฟังก์ชันตรวจสอบความถูกต้อง

01:31.280 --> 01:33.430
เพราะแน่นอนว่าสิ่งนี้จำเป็นต้องมีโครงสร้างที่คล้ายกันเสมอ

01:33.430 --> 01:49.870
พร้อมด้วยคุณสมบัติจำนวนหนึ่งที่สามารถมีได้ และคุณสมบัติบางประเภท เพื่อให้ฟังก์ชันตรวจสอบความถูกต้องรู้ว่ามันทำงานด้วยอะไรและสามารถ แยกคุณสมบัติได้อย่างถูกต้องและอื่นๆ

01:49.870 --> 01:52.850
ดังนั้นฉันจะเริ่มต้นด้วยการกำหนดส่วนต่อประสาน

01:52.850 --> 01:55.380
เราสามารถเลือกประเภทที่กำหนดเองได้

01:55.380 --> 01:56.550
ขึ้นอยู่กับคุณ

01:56.550 --> 01:58.690
เนื่องจากฉันจะกำหนดโครงสร้างของวัตถุ

01:58.690 --> 02:02.793
ฉันจึงเป็นแฟนตัวยงของการกำหนดอินเทอร์เฟซ

02:03.810 --> 02:06.700
ฉันจะตั้งชื่อว่า Validatable

02:06.700 --> 02:09.940
ที่นี่ เพราะมันอธิบายวัตถุที่ตรวจสอบได้

02:09.940 --> 02:17.140
และจะมีค่าที่ควรเป็นสตริงหรือตัวเลขด้วย

02:17.140 --> 02:18.980
จะมีอุปกรณ์ประกอบฉากที่จำเป็น

02:18.980 --> 02:22.630
ซึ่งจะมีค่าบูลีน จริงหรือเท็จ

02:22.630 --> 02:26.470
จากนั้นสมมติว่าเราสนับสนุนการตรวจสอบ minLength

02:26.470 --> 02:28.212
ซึ่งควรเป็นตัวเลข maxLength

02:28.212 --> 02:35.240
ซึ่งควรเป็นตัวเลข และในกรณีที่เราได้รับตัวเลข ค่าต่ำสุดและค่าสูงสุด

02:35.240 --> 02:37.417
ความแตกต่างของ minLength และ maxLength

02:37.417 --> 02:46.010
คือสิ่งนี้จะตรวจสอบความยาวของสตริง ซึ่งเป็นค่าของตัวเลขหากเกินจำนวนที่กำหนดหรือต่ำกว่าค่าสูงสุดที่กำหนด

02:46.010 --> 02:48.870
นี่คือคุณสมบัติที่ฉันต้องการสนับสนุน

02:48.870 --> 02:52.140
นอกจากค่าแล้ว ทั้งหมดนี้ควรเป็นทางเลือก

02:52.140 --> 02:57.650
ซึ่งเราสามารถบังคับใช้ได้โดยเพิ่มเครื่องหมายคำถามหลังชื่อ

02:57.650 --> 03:02.720
อย่างไรก็ตาม ทางเลือกอื่นนอกจากการใช้เครื่องหมายคำถามคือการอนุญาตให้ใช้ค่าที่ไม่ได้กำหนด

03:02.720 --> 03:04.880
โดยทั่วไปแล้วเครื่องหมายคำถามจะทำเช่นเดียวกัน

03:04.880 --> 03:09.370
มันบอกว่าจำเป็นต้องใช้เป็นบูลีนหรือไม่ได้กำหนด

03:09.370 --> 03:12.610
ตอนนี้เรามีอินเทอร์เฟซที่ตรวจสอบได้

03:12.610 --> 03:13.893
เราจะทำอย่างไรกับสิ่งนั้น?

03:14.930 --> 03:17.893
ทีนี้ เมื่อสร้างอินเทอร์เฟซนั้นแล้ว เราสามารถสร้างฟังก์ชันนั้น

03:18.830 --> 03:24.220
ซึ่งเป็นฟังก์ชันตรวจสอบความถูกต้องที่ฉันกำลังมองหา

03:24.220 --> 03:27.410
ที่ควรได้รับวัตถุที่ตรวจสอบได้

03:27.410 --> 03:32.410
ValidatableInput จึงเป็นประเภท Validatable

03:32.410 --> 03:33.450
นั่นคือความคิดของฉันที่นี่

03:33.450 --> 03:36.400
มันจึงได้วัตถุที่มีโครงสร้างแบบนี้

03:36.400 --> 03:44.810
และตอนนี้เราสามารถตรวจสอบคุณสมบัติเหล่านี้ทั้งหมดที่มีอยู่แล้วทำการตรวจสอบความถูกต้องที่เหมาะสม

03:44.810 --> 03:48.200
ตอนนี้เราทำอะไรกันแน่ในฟังก์ชันตรวจสอบความถูกต้อง?

03:48.200 --> 03:49.033
ในตอนท้าย ผมต้องการสร้างตัวแปร

03:49.033 --> 03:52.330
isValid ซึ่งในตอนแรกเป็นจริง

03:52.330 --> 03:55.510
ดังนั้นสมมติฐานเริ่มต้นคือสิ่งที่เราได้เป็นจริง

03:55.510 --> 04:01.330
แต่เราจะตั้งค่าเป็นเท็จทันทีที่การตรวจสอบของเราล้มเหลวอย่างน้อยหนึ่งรายการ

04:01.330 --> 04:03.480
และตอนนี้เรามาเริ่มด้วยการตรวจสอบครั้งแรก

04:03.480 --> 04:06.410
มาดูกันว่า ValidatableInput ที่นี่

04:06.410 --> 04:08.220
อาร์กิวเมนต์ที่เราได้รับนี้

04:08.220 --> 04:11.380
มีเงื่อนไขที่จำเป็นหรือไม่

04:11.380 --> 04:13.260
หากยังไม่ได้กำหนด

04:13.260 --> 04:20.630
หากตั้งค่านี้ และถ้าเป็นจริง แสดงว่าต้องระบุค่าและต้องไม่ว่างเปล่า

04:20.630 --> 04:22.080
ดังนั้น ณ ที่นี้ เราสามารถตั้งค่า

04:22.080 --> 04:27.700
isValid เท่ากับ isValid และวิธีการทำงานของ JavaScript ทำให้มั่นใจได้ว่าค่าใหม่ของ

04:27.700 --> 04:34.330
isValid จะเป็นเท็จ หากสิ่งหลังจากนั้นและเป็นเท็จ

04:34.330 --> 04:36.870
เพราะถ้าอย่างน้อยหนึ่งในสองสิ่งเป็นเท็จ

04:36.870 --> 04:38.660
ค่าโดยรวมจะเป็นเท็จ

04:38.660 --> 04:40.500
ตอนนี้ isValid ในตอนแรกจะเป็นจริง

04:40.500 --> 04:44.070
แต่ถ้าสิ่งที่อยู่หลังตรรกะและตัวดำเนินการเป็นเท็จ

04:44.070 --> 04:46.300
isValid จะเป็นเท็จ

04:46.300 --> 04:48.700
และในที่สุด ฉันจะกลับมา isValid

04:48.700 --> 04:53.550
ทีนี้เราจะเพิ่มอะไรต่อจากเครื่องหมายแอมเพอร์แซนด์สองตัว?

04:53.550 --> 04:58.170
ฉันต้องการตรวจสอบว่า validatableInput หรือไม่ ค่า ถ้าว่างเปล่า

04:58.170 --> 05:04.210
และสำหรับสิ่งนั้น เราสามารถเล็มมันและตรวจสอบความยาวได้หรือปล่าว?

05:04.210 --> 05:07.510
ปัญหาคือเราไม่รู้ว่าค่าเป็นสตริงหรือไม่

05:07.510 --> 05:09.090
เป็นสตริงหรือตัวเลข

05:09.090 --> 05:10.910
ดังนั้นจึงไม่รับประกันว่าจะเป็นสตริง

05:10.910 --> 05:14.100
ดังนั้นวิธีการตัดแต่งจึงไม่สามารถใช้ได้เสมอไป

05:14.100 --> 05:17.570
ขณะนี้มีหลายวิธีในการแก้ไข

05:17.570 --> 05:19.600
เราสามารถเพิ่มตัวป้องกันประเภท เราสามารถตรวจสอบว่า

05:19.600 --> 05:23.390
typeof validatableInput ค่าเท่ากับสตริง

05:25.250 --> 05:30.250
และดำเนินการตรวจสอบเฉพาะกรณีนี้เท่านั้น

05:30.920 --> 05:33.040
แต่ที่จริงออกจะซ้ำซ้อนไปหน่อย

05:33.040 --> 05:36.120
สิ่งที่เราสามารถทำได้ที่นี่ง่ายมาก

05:36.120 --> 05:37.257
เราสามารถพูดว่า

05:37.257 --> 05:39.140
"เอาล่ะ แปลงเป็นสตริง ถ้ามันเป็นตัวเลข ตอนนี้มันเป็นสตริงอีกครั้ง

05:39.140 --> 05:41.370
หากเป็นสตริงก็ไม่มีอะไรเปลี่ยนแปลง

05:41.370 --> 05:44.170
และด้วยสิ่งนั้น เรากำลังทำสิ่งนี้

05:44.170 --> 05:47.950
ตอนนี้ฉันต้องเพิ่มเช็คของฉันที่นี่เพื่อตรวจสอบว่าเป็นศูนย์หรือไม่

05:47.950 --> 05:50.360
หรือพูดให้ชัดคือ ถ้าไม่ใช่ศูนย์

05:50.360 --> 05:53.463
ดังนั้นหากค่านี้ไม่เป็นศูนย์ ค่านี้จะคืนค่าจริง

05:54.680 --> 05:58.740
และค่า isValid จะเป็นค่าจริง

05:58.740 --> 06:00.500
หากเป็นศูนย์ ดังนั้นหากมีความยาวเป็นศูนย์

06:00.500 --> 06:02.760
หากว่างเปล่า ค่านี้จะคืนค่าเป็นเท็จ ดังนั้น

06:02.760 --> 06:04.940
isValid จะกลายเป็นเท็จ

06:04.940 --> 06:11.190
และเราจะตรวจสอบสิ่งนี้ก็ต่อเมื่อการตรวจสอบที่จำเป็นถูกตั้งค่าสถานะด้วยการตั้งค่าที่จำเป็นเป็นจริงเท่านั้น

06:11.190 --> 06:13.530
นั่นเป็นเช็คแรกที่ฉันอยากจะทำที่นี่

06:13.530 --> 06:15.560
ไม่ใช่คนเดียวแน่นอน

06:15.560 --> 06:17.660
เราสามารถดำเนินการต่อและตรวจสอบว่า validatableInput

06:17.660 --> 06:18.950
ได้หรือไม่ minLength ถูกตั้งค่า หาก minLength

06:18.950 --> 06:27.050
ถูกตั้งค่า ดังนั้นสตริงที่เราได้รับควรมีความยาวขั้นต่ำที่แน่นอน

06:27.050 --> 06:30.440
ข้อสำคัญ สตริงควรมีความยาวขั้นต่ำที่แน่นอน

06:30.440 --> 06:31.620
เราไม่สนใจตัวเลขที่นี่

06:31.620 --> 06:33.600
เราไม่ได้ตรวจสอบค่าขั้นต่ำของตัวเลข

06:33.600 --> 06:37.060
ที่นี่เราสามารถเพิ่มตัวป้องกันประเภท เราสามารถรวมเข้ากับการตรวจสอบนี้

06:37.060 --> 06:42.320
และตรวจสอบว่า typeof validatableInput

06:42.320 --> 06:42.320
ค่าเท่ากับสตริง

06:46.910 --> 06:48.460
ถ้าไม่ใช่ก็ไม่ต้องเข้า if

06:48.460 --> 06:50.357
check เพราะไม่มีอะไรให้ตรวจสอบ

06:50.357 --> 06:52.570
ถ้าค่าของเราเป็นตัวเลข เราก็ไม่สนใจ

06:52.570 --> 06:59.330
หากเราตั้งค่าความยาวขั้นต่ำสำหรับตัวเลข โดยทั่วไปเราจะข้ามการตรวจสอบนี้ไปเนื่องจากไม่สมเหตุสมผลมากนัก

06:59.330 --> 07:01.890
ถ้าเรามีสตริง และ minLength ถูกตั้งค่า

07:01.890 --> 07:03.420
ฉันต้องการตั้งค่า

07:03.420 --> 07:05.663
isValid เท่ากับ isValid และจากนั้นอีกครั้ง

07:06.570 --> 07:10.053
เช็คของเรา

07:11.181 --> 07:16.580
และตรวจสอบที่นี่ว่า

07:16.580 --> 07:16.580
ค่าที่เรารู้ว่าเป็นสตริง

07:16.580 --> 07:20.810
ณ จุดนี้ ความยาวมีค่ามากกว่า

07:20.810 --> 07:24.070
validatableInput นาทีความยาว

07:24.070 --> 07:28.520
มากกว่าค่าที่กำหนดไว้ที่นี่

07:28.520 --> 07:33.920
ตอนนี้เรามีปัญหาหนึ่งที่อาจเกิดขึ้นที่นี่ และคุณเห็นว่าปัญหาใดที่อาจเป็นไปได้

07:33.920 --> 07:36.163
โดยทั่วไปควรใช้งานได้ แต่จะล้มเหลวหาก minLength

07:37.030 --> 07:38.630
ถูกตั้งค่าเป็นศูนย์

07:38.630 --> 07:42.210
ความตั้งใจของนักพัฒนาซอฟต์แวร์ที่ตั้งค่าเป็นศูนย์อาจไม่ใช่เพื่อข้ามการตรวจสอบนี้

07:42.210 --> 07:50.170
แต่เพื่อตรวจสอบว่าเรามีความยาวขั้นต่ำเป็นศูนย์หรือไม่

07:50.170 --> 07:51.960
อาจเป็นไปได้ว่าเป็นการตรวจสอบซ้ำซ้อน

07:51.960 --> 07:53.800
เพราะโดยพื้นฐานแล้วเป็นการตรวจสอบว่าเรามีสิ่งใดอยู่หรือไม่

07:53.800 --> 07:57.260
ซึ่งเราทำกับการตรวจสอบที่จำเป็นแล้ว

07:57.260 --> 07:59.300
จึงไม่ใช่ปัญหาใหญ่

07:59.300 --> 08:01.330
ถึงกระนั้น ถ้าคุณต้องการความปลอดภัยสูงสุดที่นี่

08:01.330 --> 08:05.470
เราควรตรวจสอบว่า

08:05.470 --> 08:05.470
minLength ไม่เท่ากับ undefined

08:05.470 --> 08:10.470
หรือไม่เท่ากับ null โดยมีเครื่องหมายเท่ากับหนึ่งเครื่องหมาย

08:10.640 --> 08:17.130
ซึ่งรวมถึง null และ undefined นั่นคือวิธีการทำงานของ JavaScript

08:17.130 --> 08:20.470
วิธีนี้ปลอดภัยกว่าเล็กน้อย เพราะตอนนี้เราแน่ใจว่าเราเรียกใช้การตรวจสอบนี้เสมอ

08:20.470 --> 08:25.140
แม้ว่า minLength จะถูกตั้งค่าเป็นศูนย์ ซึ่งเป็นค่าเท็จ

08:25.140 --> 08:27.222
อีกครั้ง คุณสามารถโต้แย้งได้ว่ามันสมเหตุสมผลไหม

08:27.222 --> 08:29.740
เพราะโดยพื้นฐานแล้วมันเป็นการตรวจสอบแบบเดียวกับที่นั่น

08:29.740 --> 08:32.270
แต่ถึงกระนั้น ฉันต้องการแสดงที่นี่

08:32.270 --> 08:34.930
นั่นคือ minLength

08:34.930 --> 08:36.790
ตอนนี้ฉันจะคัดลอกสิ่งนี้ และทำแบบเดียวกันกับ

08:36.790 --> 08:38.130
maxLength

08:38.130 --> 08:40.720
ดังนั้น maxLength ที่นี่จะถูกตรวจสอบเช่นกัน

08:40.720 --> 08:44.350
ที่นี่ และสำหรับสตริงเท่านั้น

08:44.350 --> 08:46.870
และแน่นอนว่าเราต้องคืนค่านี้

08:46.870 --> 08:52.380
เราต้องการให้แน่ใจว่าความยาวของค่าที่ระบุนั้นต่ำกว่าความยาวสูงสุดของเรา

08:52.380 --> 08:55.173
ตอนนี้เราเหลือการตรวจสอบอีกสองรายการสำหรับค่าต่ำสุดและค่าสูงสุด

08:56.810 --> 09:00.160
ซึ่งเหมาะสมสำหรับตัวเลขเท่านั้น

09:00.160 --> 09:03.310
ดังนั้นที่นี่ฉันจะเพิ่มการตรวจสอบอีกครั้งและตรวจสอบว่า

09:03.310 --> 09:08.280
validatableInput นาทีไม่เท่ากับโมฆะ

09:09.720 --> 09:11.100
อีกครั้ง ฉันไม่ได้แค่ตรวจสอบความจริง

09:11.100 --> 09:13.820
เพราะนั่นจะมีปัญหากับค่าศูนย์

09:13.820 --> 09:21.770
จากนั้นฉันจะตรวจสอบว่าเป็นประเภทของ validatableInput หรือไม่ ค่าเท่ากับจำนวน

09:21.770 --> 09:25.640
เพราะฉันเห็นว่าไม่สมเหตุสมผลในการตรวจสอบสิ่งนี้สำหรับสตริง

09:25.640 --> 09:26.760
หากคุณต้องการตรวจสอบสตริง

09:26.760 --> 09:28.020
คุณสามารถละเว้นสิ่งนี้ได้

09:28.020 --> 09:34.380
จากนั้นคุณต้องแน่ใจว่าคุณแปลงค่าเป็นตัวเลขเมื่อคุณใช้ในเช็คที่เรากำลังจะเขียน

09:34.380 --> 09:35.970
เช็คที่เรากำลังจะเขียนอีกครั้ง

09:35.970 --> 09:37.220
ใช้ค่าเก่าของ isValid

09:37.220 --> 09:39.740
และรวมเข้ากับเช็คใหม่เพื่อจัดเก็บกลับเป็น

09:39.740 --> 09:41.500
isValid

09:41.500 --> 09:48.730
และการตรวจสอบใหม่ควรรวมหมายเลขของเราเข้าด้วยกันและตรวจสอบว่ามีค่ามากกว่าค่าขั้นต่ำหรือไม่

09:48.730 --> 09:54.650
ดังนั้นที่นี่ฉันตรวจสอบว่า validatableInput ค่ามากกว่าตรวจสอบได้อินพุท

09:54.650 --> 09:54.650
นาที

09:54.650 --> 09:58.690
และตอนนี้เราสามารถทำซ้ำสำหรับค่าสูงสุด

09:58.690 --> 10:02.010
ตรงนี้เราต้องการค่าสูงสุด และตรงนี้เราต้องการค่าสูงสุดด้วย

10:02.010 --> 10:06.190
และเราต้องเปลี่ยนนี่ตรงนี้ให้เป็นสัญลักษณ์ที่เล็กกว่า

10:06.190 --> 10:13.230
ด้วยเหตุนี้ เรากำลังตรวจสอบสถานการณ์ต่างๆ ทั้งหมดที่คุณสามารถทำได้ที่นี่

10:13.230 --> 10:16.930
และเรากำลังส่งคืน isValid

10:16.930 --> 10:23.630
ตอนนี้เราต้องสร้างวัตถุที่ยึดติดกับอินเทอร์เฟซนี้เพื่อส่งไปยังฟังก์ชันตรวจสอบความถูกต้อง

10:23.630 --> 10:26.573
สำหรับสิ่งนั้น ลงไปที่อินพุตโปรเจ็กต์

10:28.160 --> 10:34.000
และที่นั่นใน GatherUserInput ฉันต้องการสร้างวัตถุที่ตรวจสอบได้ของฉัน

10:34.000 --> 10:36.360
ข้อสังเกต นอกจากอินเทอร์เฟซแล้ว แน่นอนว่าเราสามารถสร้างคลาสที่นี่ได้ด้วย

10:36.360 --> 10:38.420
จากนั้นเราจะสร้างอินสแตนซ์ด้วยคีย์เวิร์ดใหม่

10:38.420 --> 10:46.070
แต่ทั้งหมดนี้เพื่อจุดประสงค์ในการฝึกหัดและการสาธิตที่นี่ ฉันต้องการแสดงวิธีการทำงานกับอินเทอร์เฟซ

10:46.070 --> 10:48.990
ตรงนี้เรามีชื่อเรื่อง Validatable

10:48.990 --> 10:51.900
ซึ่งควรเป็นประเภท Validatable

10:52.850 --> 10:56.830
และแน่นอนว่าเป็นวัตถุที่ต้องมีคุณสมบัติที่มีมูลค่า

10:56.830 --> 10:58.930
และนั่นคือชื่อเรื่องของเรา

10:58.930 --> 11:01.020
มันไม่ต้องการคุณสมบัติอื่นใด

11:01.020 --> 11:03.550
แต่ฉันต้องการตรวจสอบว่ามันไม่ว่างเปล่าหรือไม่

11:03.550 --> 11:06.750
ดังนั้นเราจะตั้งค่าให้เป็นจริง

11:06.750 --> 11:12.430
จากนั้นเราสามารถคัดลอกและทำซ้ำสำหรับคำอธิบายและสำหรับผู้คน

11:12.430 --> 11:19.250
และที่นี่เรามีคำอธิบาย อ๊ะ ฉันหมายถึงคำอธิบายที่ป้อน

11:19.250 --> 11:21.880
ที่นี่เรามีคนเข้ามา

11:21.880 --> 11:24.260
พูดให้ชัดคืออยากได้เลข

11:24.260 --> 11:26.230
ผมจึงแปลงเป็นตัวเลขที่มีเครื่องหมายบวก

11:26.230 --> 11:30.810
ควรต้องมีทั้งหมด แต่ในที่นี้ สมมติว่าคำอธิบายควรมีอักขระ

11:30.810 --> 11:35.420
minLength 5 ตัว และสำหรับคน ขั้นต่ำควรเป็น 1 ตัว เพื่อให้เราได้กำหนดคนอย่างน้อย

11:35.420 --> 11:38.823
2 คน

11:39.820 --> 11:42.030
ทั้งนี้ขึ้นอยู่กับคุณว่าจะนำสิ่งนี้ไปใช้อย่างไร

11:42.030 --> 11:44.020
แน่นอน ในตรรกะการตรวจสอบความถูกต้องของคุณ

11:44.020 --> 11:50.080
คุณสามารถตรวจสอบค่ามากกว่าเท่ากับค่าน้อยกว่าได้หากต้องการ

11:50.080 --> 11:52.030
เหมือนกันสำหรับความยาวของหลักสูตร

11:52.030 --> 11:54.200
มากกว่าเท่ากัน น้อยกว่าเท่ากัน

11:54.200 --> 11:56.940
ก็เป็นไปได้เช่นกัน

11:56.940 --> 11:58.660
อันที่จริง ฉันจะเก็บการเปลี่ยนแปลงเหล่านี้ไว้

11:58.660 --> 12:01.920
ตอนนี้เราได้รับมอบหมายอย่างน้อยหนึ่งคนและสูงสุดห้าคน

12:01.920 --> 12:05.253
ตอนนี้เรามีอ็อบเจกต์ที่ตรวจสอบได้สามรายการแล้ว

12:06.100 --> 12:08.500
และตอนนี้ ไปที่ฟังก์ชันตรวจสอบความถูกต้อง

12:08.500 --> 12:16.440
เราส่ง titleValidatable ของเรา ไปยังการเรียกฟังก์ชันที่สอง ฉันส่งคำอธิบายValidatable และการเรียกฟังก์ชันที่สาม

12:16.440 --> 12:21.310
ฉันส่ง peopleValidatable

12:21.310 --> 12:24.460
และตอนนี้การตรวจสอบความถูกต้องควรคืนค่าจริงหากถูกต้องทั้งหมด

12:24.460 --> 12:26.380
และมิฉะนั้นจะเป็นเท็จ

12:26.380 --> 12:29.480
ตอนนี้ฉันต้องการตรวจสอบว่ามีอย่างน้อยหนึ่งรายการที่ล้มเหลวหรือไม่

12:29.480 --> 12:32.420
โดยตรวจสอบว่าสิ่งเหล่านี้เป็นเท็จทั้งหมดหรือไม่

12:32.420 --> 12:41.560
โดยเพิ่มเครื่องหมายอัศเจรีย์ข้างหน้า เพื่อตรวจสอบว่านี่เป็นเท็จ หรือนี่เป็นเท็จ หรือนี่เป็นเท็จ

12:41.560 --> 12:42.740
และถ้าอย่างน้อยหนึ่งรายการเป็นเท็จ

12:42.740 --> 12:45.730
ดังนั้นหากการเรียกฟังก์ชันตรวจสอบความถูกต้องอย่างน้อยหนึ่งรายการส่งคืนค่าเท็จ

12:45.730 --> 12:47.760
เราจะทำให้มันอยู่ในนั้นและแสดงการแจ้งเตือน

12:47.760 --> 12:49.860
และนอกลู่นอกทาง เพื่อทดสอบสิ่งนี้ด้วย

12:51.930 --> 12:54.860
ฉันจะไปที่ดัชนี

12:54.860 --> 12:54.860
html

12:54.860 --> 12:56.270
เนื่องจากมีอินพุตสำหรับผู้คน

12:56.270 --> 13:00.410
ฉันจึงอนุญาตสูงสุด 10 และศูนย์เป็นอย่างต่ำ

13:00.410 --> 13:01.460
ดังนั้นในทางเทคนิคแล้ว เราสามารถป้อนค่าที่ไม่ถูกต้องได้

13:01.460 --> 13:06.240
แน่นอนว่ามีจุดประสงค์เพื่อให้เราสามารถทดสอบตรรกะของเราได้

13:06.240 --> 13:08.090
และตอนนี้มาบันทึกทั้งหมด

13:08.090 --> 13:10.200
คอมไพล์โดยไม่มีข้อผิดพลาด

13:10.200 --> 13:11.750
ตอนนี้เรามาลองดูกัน

13:11.750 --> 13:13.083
ถ้าฉันคลิกเพิ่มโครงการ

13:13.920 --> 13:16.000
ฉันได้รับข้อผิดพลาดซึ่งถือว่าดี

13:16.000 --> 13:17.430
ตอนนี้เรามาทดสอบกันที่นี่ แต่ก็ยังได้รับข้อผิดพลาด

13:17.430 --> 13:24.180
มาลองทดสอบที่นี่และห้าที่นี่ และฉันยังคงได้รับข้อผิดพลาด

13:24.180 --> 13:25.390
เนื่องจากคำอธิบายของฉันสั้นเกินไป

13:25.390 --> 13:26.870
ถ้าฉันป้อนอักขระอีกหนึ่งตัว ฉันจะมีความยาวขั้นต่ำ

13:26.870 --> 13:29.500
และฉันสามารถสร้างสิ่งนี้ได้

13:29.500 --> 13:31.210
ทีนี้มาป้อนกัน สมมุติว่า

13:31.210 --> 13:32.640
ลบหนึ่งคน และเอาล่ะ

13:32.640 --> 13:34.580
html ไม่สนับสนุนสิ่งนี้

13:34.580 --> 13:39.200
แต่ลองป้อนศูนย์หรือหกและเราได้รับข้อผิดพลาด

13:39.200 --> 13:43.840
และถ้าฉันป้อนบางอย่างระหว่างหนึ่งถึงห้าก็ใช้ได้

13:43.840 --> 13:46.100
ดูเหมือนว่าจะได้ผลอย่างที่ควรจะเป็น

13:46.100 --> 13:49.260
และนั่นก็ค่อนข้างดี

13:49.260 --> 13:51.850
และนั่นเป็นเพียงวิธีหนึ่งในการนำการตรวจสอบไปใช้

13:51.850 --> 13:53.570
แต่วิธีที่ตอนนี้ใช้ซ้ำได้ค่อนข้างมาก

13:53.570 --> 13:56.510
สามารถใช้แบบนี้ในส่วนต่างๆ ของแอพได้เช่นกัน และแน่นอนว่ามันใช้ประโยชน์จาก

13:56.510 --> 13:59.170
typescript และให้การสนับสนุนที่ยอดเยี่ยมแก่เรา

13:59.170 --> 14:04.480
และการตรวจสอบประเภทเพื่อหลีกเลี่ยงข้อผิดพลาดที่ไม่จำเป็น
