WEBVTT

00:02.140 --> 00:03.620
-というのも､

00:03.620 --> 00:09.970
ジェネリックタイプを理解するのは難しいからです｡

00:09.970 --> 00:14.810
平均的な汎用関数､ countとprintを作成してみましょう｡

00:14.810 --> 00:19.810
さて､ この関数は何らかの引数､ つまりパラメータを受け取る必要があります｡ 

00:20.330 --> 00:23.470
エレメントと名付けましょう｡ しかし､ その名前は本当にあなた次第で､

00:23.470 --> 00:26.530
一般的なタイプであるべきです｡

00:26.530 --> 00:30.380
少なくともある意味､ 本当に型にこだわらないからです｡

00:30.380 --> 00:35.800
そこで､ この関数の中に1つの汎用型があり､ パラメータがその型であるとします｡

00:35.800 --> 00:38.350
ちなみに､ ジェネリックタイプの典型はすべてこれだ｡ 

00:38.350 --> 00:40.030
汎用的な関数がある場合､ 多くの場合､

00:40.030 --> 00:42.180
パラメータはそのような型になります｡

00:42.180 --> 00:43.890
必ずしもそうである必要はありませんが､

00:43.890 --> 00:49.080
ジェネリック関数を使いこなすと､ しばしばそのような使い方ができるようになります｡

00:49.080 --> 00:52.350
ここで､ countとprintは一般的な型であり､

00:52.350 --> 00:54.430
elementはその型である｡

00:54.430 --> 00:56.500
ここで私が返したいのは､

00:56.500 --> 01:07.070
2つの要素を持つニエンダタプルです｡ 最初の要素は私の要素そのものであり､ 2番目の要素は説明の文字列であるべきです｡

01:07.070 --> 01:10.160
それゆえ､ 私たちはそれをカウントと名付け､ 記述するのかもしれません｡ 

01:10.160 --> 01:15.160
ここでは説明テキストを取得し､ ここでは値なしとします｡

01:15.410 --> 01:22.620
長さのない要素を渡す場合にこれを使用します｡

01:22.620 --> 01:25.570
というのも､ countやdescribeのアイデアは､

01:25.570 --> 01:32.040
配列や文字列を渡すと､ その文字列や配列の文字数や要素数が返ってくるというものだからです｡

01:32.040 --> 01:34.040
空文字列や空配列の場合は､

01:34.040 --> 01:37.440
got no valueを使いますが､

01:37.440 --> 01:42.440
ここでは､ 要素のドット長が0より大きいことを確認したら､

01:43.210 --> 01:46.170
説明テキストをgot + 要素のドット長

01:47.430 --> 01:52.430
+ 要素に設定したいと思います｡

01:55.850 --> 01:58.100
さらに具体的に言うと､

01:58.100 --> 02:13.750
ここで長さが1に等しいかどうかをチェックして､ 1つの要素を得たと言うこともできますし､ 要素の長さが1より大きい場合は､ 複数形を正しく得るために､

02:13.750 --> 02:21.173
説明文を等しく得たプラス要素の長さの要素にすることもできます｡

02:22.850 --> 02:27.040
ここで､ 2番目の要素に説明文があり､ ここに戻ります｡

02:27.040 --> 02:27.040
今､

02:27.040 --> 02:29.480
すでにここに長さに関する苦情の種類が表示されています｡

02:29.480 --> 02:32.350
なぜなら､ その要素が長さを持つことが明確でないからです｡ 

02:32.350 --> 02:34.770
だから､ そうであることをはっきりさせるべきかもしれません｡ 

02:34.770 --> 02:38.430
ここではlengthという名前のインターフェースにして､

02:38.430 --> 02:50.820
最終的に数値が得られるlengthプロパティを持つオブジェクトがあることを保証することにします｡

02:50.820 --> 02:54.740
そして､ ここで制約を設定し､ Tが長さを拡張していると言うことができます｡

02:54.740 --> 03:01.053
つまり､ 何を取得しても､ 長さのプロパティがあり､ 配列や文字列は長さのプロパティを持っていることがわかります｡

03:02.030 --> 03:07.030
ここで､ コンソールログをカウントし､ 記述して､ 例えば､

03:07.500 --> 03:11.240
こんにちはと渡すことができます｡

03:11.240 --> 03:14.280
文字列には長さのプロパティがあるので､ これはうまくいきます｡ 

03:14.280 --> 03:15.290
オブジェクトではありません｡ 

03:15.290 --> 03:17.310
これは文字列ですが､ 裏側ではJavascriptがこれをその場でオブジェクトに変換して､

03:17.310 --> 03:23.940
必要なときに長さのプロパティを追加しています｡

03:23.940 --> 03:23.940
だから､

03:23.940 --> 03:26.960
こう呼んで差し支えないだろう｡ 最初にスクリプトを入力すると､

03:26.960 --> 03:33.580
ここでは文字列かT型の要素を含む配列を返します｡

03:33.580 --> 03:33.580
さて､

03:33.580 --> 03:36.060
タプルが欲しいので､ ここではより具体的に､

03:36.060 --> 03:43.850
基本的に最初の要素がT型､ 2番目の要素が文字列型のちょうど2つの要素を持つ配列に戻り値の型を設定することにします｡

03:43.850 --> 03:46.270
つまり､ 最初の要素が汎用型の任意の要素で､

03:46.270 --> 03:54.110
2番目の要素が文字列であるタプルを返すというだけのことです｡

03:54.110 --> 03:56.820
さて､ これで保存すると､ エラーなしで再コンパイルされ､

03:56.820 --> 04:02.330
hi there, got nine elementsと表示されます｡

04:04.320 --> 04:12.460
また､ スポーツと料理がある配列でこれを呼び出すこともできます｡

04:12.460 --> 04:28.090
この場合､ 説明のテキストとして2つの要素が得られたことがわかります｡

04:28.090 --> 04:32.900
ここで再び､ 汎用的な関数を手に入れました｡ 

04:32.900 --> 04:35.043
アイデアは以前の機能に似ています｡ 

04:35.043 --> 04:40.540
ここでは､ 取得するデータの種類を少し不特定多数にしたいと思います｡

04:40.540 --> 04:40.540
文字列であろうが､

04:40.540 --> 04:45.610
配列であろうが､ lengthプロパティを持つものであれば､ 特に気にすることはありません｡

04:45.610 --> 04:45.610
私たちが気にするのは､

04:45.610 --> 04:51.970
それがlengthプロパティを持っているということだけで､ それを使って何かをしたいのは､ 私たちのコードではlengthプロパティに依存しているので､

04:51.970 --> 04:59.490
それが得られたことを保証する必要があります｡

04:59.490 --> 04:59.490
私はこれを文字列や配列に固定したくありませんし､

04:59.490 --> 05:05.830
さまざまな可能性のある型を処理するためにオーバーロードをたくさん作りたくもないのです｡

05:05.830 --> 05:08.124
また､ 長さのプロパティを持つ型を忘れてしまったり､

05:08.124 --> 05:10.970
長さのプロパティを持つ独自のオブジェクトを作成した場合､

05:10.970 --> 05:13.610
これを文字列や配列などの型に制限すると､

05:13.610 --> 05:21.580
それを許さないかもしれないので､ ここではあまり長い結合型を作らないようにします｡

05:21.580 --> 05:23.500
ですから､ より柔軟性を持たせたい｡ ジェネリック型を使えば､

05:23.500 --> 05:27.550
正確な型にこだわることなく､ そうすることができるのです｡

05:27.550 --> 05:33.363
ここでは､ 制約のおかげで､ 長さのプロパティを持つという事実だけを気にしています｡
