WEBVTT

00:02.270 --> 00:03.850
Kursleiter: Wir verwenden

00:03.850 --> 00:07.450
also die Grundtypen Zahl, Boolescher Wert und String.

00:07.450 --> 00:10.840
Und hier in der Liste der Parameter dieser Funktion

00:10.840 --> 00:13.970
weisen wir die Typen immer explizit mit einem Doppelpunkt

00:13.970 --> 00:16.540
nach dem Parameternamen zu, und dann den

00:16.540 --> 00:18.410
Namen des Typs.

00:18.410 --> 00:21.350
Hier lauten die Namen also number, boolean, string.

00:21.350 --> 00:23.100
Und für den Fall, dass Sie sich wundern: Es

00:23.100 --> 00:25.420
handelt sich jetzt um besondere Kennzeichnungen.

00:25.420 --> 00:28.530
Dieser Overall ist eine spezielle Syntax, die von TypeScript

00:28.530 --> 00:30.170
hinzugefügt wurde.

00:30.170 --> 00:32.900
Er ist nicht Teil des kompilierten JavaScript-Codes.

00:32.900 --> 00:35.040
Wenn wir den Code hier überprüfen, sind

00:35.040 --> 00:37.280
diese Typzuweisungen verschwunden, weil

00:37.280 --> 00:39.530
JavaScript sie nicht unterstützt.

00:39.530 --> 00:42.390
Dieser Doppelpunkt steht nach einer Variablen oder

00:42.390 --> 00:43.920
nach einem Parameter.

00:43.920 --> 00:46.320
Und dann Zahlen, Boolesche Werte und Zeichenketten.

00:46.320 --> 00:48.290
Diese besonderen Schlüsselwörter.

00:48.290 --> 00:50.840
Dies wird durch TypeScript eingeführt.

00:50.840 --> 00:53.500
Der TypeScript-Compiler versteht sie.

00:53.500 --> 00:55.480
Die IDE hier unterstützt TypeScript und beschwert

00:55.480 --> 00:58.580
sich daher nicht über diese speziellen Schlüsselwörter.

00:58.580 --> 01:01.760
JavaScript versteht diese Syntax nicht.

01:01.760 --> 01:04.590
Es versteht keinen Doppelpunkt nach einem Parameter oder einen

01:04.590 --> 01:06.560
Doppelpunkt nach einer Variablen und dann

01:06.560 --> 01:09.190
das spezielle Zahlen- oder String-Schlüsselwort.

01:09.190 --> 01:11.540
JavaScript versteht dies nicht und daher ist dies

01:11.540 --> 01:13.560
nicht Teil der JavaScript-Ausgabe.

01:13.560 --> 01:15.920
Es wird eigentlich nur vom TypeScript-Compiler verwendet.

01:15.920 --> 01:18.130
Und dann, nun ja, ist es ein Compiler,

01:18.130 --> 01:21.820
weil er diesen Code in JavaScript-Code umwandelt.

01:21.820 --> 01:24.880
Nebenbei bemerkt, man sieht auch, dass er für var die Konstante

01:24.880 --> 01:27.700
wechselt, aber darauf komme ich später noch zurück.

01:27.700 --> 01:30.590
Wir haben hier also unsere expliziten Typzuweisungen,

01:30.590 --> 01:33.060
und die werden nur von TypeScript verstanden.

01:33.060 --> 01:35.763
Toll, warum haben wir sie nicht da unten?

01:36.880 --> 01:39.890
Ich habe hier keine expliziten Typenzuweisungen.

01:39.890 --> 01:41.180
Und übrigens auch nicht

01:41.180 --> 01:43.450
hier, wenn wir das Ergebnis berechnen,

01:43.450 --> 01:45.530
denn TypeScript hat eine eingebaute

01:45.530 --> 01:48.400
Funktion, die Typinferenz genannt wird.

01:48.400 --> 01:51.000
Das bedeutet, dass TypeScript sein Bestes

01:51.000 --> 01:53.010
tut, um zu verstehen, welchen

01:53.010 --> 01:56.400
Typ eine bestimmte Variable oder Konstante hat, und

01:56.400 --> 01:58.860
das macht es ziemlich gut.

01:58.860 --> 02:02.300
Und hier versteht es zum Beispiel, dass number1 am

02:02.300 --> 02:05.780
Ende immer vom Typ number sein wird, weil Sie es mit

02:05.780 --> 02:08.020
einer Zahl initialisieren.

02:08.020 --> 02:09.950
Es handelt sich dabei um eine Konstante, die

02:09.950 --> 02:11.740
also noch spezifischer ist als diese.

02:11.740 --> 02:15.350
Und der Typ, den sie hier identifiziert, ist nicht irgendeine

02:15.350 --> 02:17.490
Zahl, sondern die Zahl fünf.

02:17.490 --> 02:20.110
Denn Sie können einem konstanten Wert ohnehin

02:20.110 --> 02:23.870
keine neue Zahl oder einen neuen Wert zuweisen.

02:23.870 --> 02:25.840
Wenn Sie dies in eine Variable ändern würden,

02:25.840 --> 02:28.460
also stattdessen let verwenden würden, würde das natürlich

02:28.460 --> 02:30.180
nichts ändern.

02:30.180 --> 02:32.940
Wir können dort eine Variable verwenden. Das ist vielleicht nicht die

02:32.940 --> 02:34.540
beste Methode, weil sich dieser Wert nie

02:34.540 --> 02:36.210
ändert, aber es ist auch nicht schlimm.

02:36.210 --> 02:38.260
Aber wenn wir jetzt mit dem Mauszeiger darüber fahren,

02:38.260 --> 02:41.210
sehen wir, dass TypeScript nicht sagt, okay, das muss eine Fünf sein.

02:41.210 --> 02:45.510
Dennoch wird erkannt, dass es sich bei dem Typ um eine Zahl handelt.

02:45.510 --> 02:49.260
Wir könnten diesen Code hier durchaus selbst schreiben.

02:49.260 --> 02:51.970
Wir können einen Doppelpunkt nach dem Variablennamen auf der

02:51.970 --> 02:53.870
linken Seite des Gleichheitszeichens und

02:53.870 --> 02:55.590
dann den Namen des Typs hinzufügen.

02:55.590 --> 02:56.880
Also im Grunde das Gleiche, was

02:56.880 --> 02:59.470
wir bei den Parametern dieser Funktion gemacht haben.

02:59.470 --> 03:01.860
Dies ist jedoch überflüssig und wird

03:01.860 --> 03:04.620
auch nicht als gute Praxis angesehen.

03:04.620 --> 03:06.790
Denn TypeScript ist in der Lage,

03:06.790 --> 03:09.990
diesen Typ perfekt von dort abzuleiten.

03:09.990 --> 03:13.690
Es ist also keine gute Idee, diese Aufgabe zu übernehmen.

03:13.690 --> 03:16.420
Dies ändert sich nur, wenn Sie diese Variable auf eine nicht zugewiesene

03:16.420 --> 03:18.053
Weise erstellen würden.

03:19.000 --> 03:22.130
So, wenn Sie es nicht sofort initialisieren.

03:22.130 --> 03:25.700
Dann ist es eine gute Praxis, TypeScript mitzuteilen, welcher

03:25.700 --> 03:29.070
Wert letztendlich dort gespeichert werden soll.

03:29.070 --> 03:32.590
Wenn Sie ihm später einen Wert zuweisen, ist es natürlich etwas

03:32.590 --> 03:34.080
überflüssig, dies in zwei Zeilen

03:34.080 --> 03:35.320
aufzuteilen.

03:35.320 --> 03:37.800
Ich mache das nur zu Demonstrationszwecken.

03:37.800 --> 03:39.480
Aber wenn ich das jetzt hier zuweise,

03:39.480 --> 03:42.460
bricht das, weil ich TypeScript im Voraus gesagt habe,

03:42.460 --> 03:44.630
dass das vom Typ number sein wird.

03:44.630 --> 03:45.610
Das müssen Sie nicht tun.

03:45.610 --> 03:47.420
Es funktioniert auch, wenn Sie das nicht tun.

03:47.420 --> 03:50.330
Nun könnte man aber auch diese fünf hinzufügen und bekäme

03:50.330 --> 03:51.630
keinen Fehler, weil man

03:51.630 --> 03:53.470
TypeScript nichts über den Typ mitteilt,

03:53.470 --> 03:55.350
der in dieser Variablen gespeichert

03:55.350 --> 03:56.975
werden soll, und TypeScript

03:56.975 --> 03:59.630
daher jeden Typ erlaubt.

03:59.630 --> 04:02.600
Wenn Sie stattdessen hier einen Doppelpunkt einfügen,

04:02.600 --> 04:05.417
sagen Sie TypeScript: "Hey, irgendwann wird dort eine

04:05.417 --> 04:07.370
Zahl gespeichert werden". Wenn Sie also später etwas anderes darin speichern,

04:07.370 --> 04:10.060
wie in diesem Fall, wo wir eine Zeichenkette gespeichert haben,

04:10.060 --> 04:12.470
werden Sie hier in der IDE einen Fehler erhalten, und natürlich

04:12.470 --> 04:15.170
auch, wenn Sie Ihren Code kompiliert haben.

04:15.170 --> 04:17.570
Es wird der Fehler angezeigt, den wir schon einmal gesehen haben.

04:17.570 --> 04:20.253
So können Sie also Typen zuordnen.

04:22.300 --> 04:24.920
Nun, selbst wenn TypeScript gerade einen Typ abgeleitet hat,

04:24.920 --> 04:27.830
und lassen Sie mich das korrigieren, wird es Sie anschreien, wenn Sie

04:27.830 --> 04:29.310
diesen abgeleiteten Typ brechen.

04:29.310 --> 04:32.720
Eigentlich ist es falsch, das zu sagen, denn natürlich

04:32.720 --> 04:35.670
tut sie das, warum sollte sie das nicht tun?

04:35.670 --> 04:37.000
Die Typinferenz ist dazu da, um Code

04:37.000 --> 04:39.750
zu sparen, damit Sie nicht manuell einen Typ zuweisen müssen.

04:39.750 --> 04:42.730
Natürlich schreit TypeScript Sie an, wenn Sie dann einen

04:42.730 --> 04:44.520
falschen Typ verwenden, einen Typ,

04:44.520 --> 04:46.510
den es nicht hergeleitet hat.

04:46.510 --> 04:48.640
Wenn zum Beispiel resultPhrase mit let

04:48.640 --> 04:52.460
erstellt wird, so dass es eine Variable ist, dann folgert TypeScript

04:52.460 --> 04:54.000
daraus, dass diese vom Typ string

04:54.000 --> 04:57.670
ist, weil wir sie mit einem String initialisieren.

04:57.670 --> 04:59.850
Dies ist also im Grunde das Äquivalent zur Nichtinitialisierung

04:59.850 --> 05:03.060
und zum Einstellen des Typs auf eigene Faust, um dann später einen

05:03.060 --> 05:04.970
Wert zuzuweisen.

05:04.970 --> 05:07.410
Wenn wir nun resultPhrase in, sagen

05:07.410 --> 05:12.310
wir mal, Null ändern, aus welchem Grund auch immer, erhalten wir einen

05:12.310 --> 05:15.660
Fehler, dass der Typ Null nicht dem Typ String zugewiesen

05:15.660 --> 05:17.330
werden kann.

05:17.330 --> 05:21.210
Und das macht doch Sinn, oder?

05:21.210 --> 05:22.690
TypeScript hat gefolgert, dass wir

05:22.690 --> 05:25.430
eine Zeichenkette speichern wollen, jetzt versuchen wir, eine Zahl

05:25.430 --> 05:27.290
zu speichern und bekommen einen Fehler.

05:27.290 --> 05:28.530
Das ist der Job, die Kernaufgabe von TypeScript.

05:28.530 --> 05:33.000
Sie überprüfen die Typen und schreien uns an, wenn wir

05:33.000 --> 05:35.280
sie falsch verwenden.
