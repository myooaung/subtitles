WEBVTT

00:02.400 --> 00:04.350
教师：命名空间很不错,

00:04.350 --> 00:07.240
但不一定完美｡

00:07.240 --> 00:09.680
我们在上节课中看到了一个问题,

00:09.680 --> 00:13.290
我手动将所有的待定项添加到每个文件中｡

00:13.290 --> 00:15.620
当我从项目列表中删除, 拖放,

00:15.620 --> 00:18.900
是的, 例如, 它仍然编译没有错误｡

00:18.900 --> 00:20.350
这是不理想的｡ 

00:20.350 --> 00:22.360
现在, 它可能工作, 也可能不工作,

00:22.360 --> 00:25.047
这取决于是否有其他文件导入了拖放模型,

00:25.047 --> 00:27.550
最终, 我需要在这里｡

00:27.550 --> 00:29.100
这里就是这样｡ 

00:29.100 --> 00:31.533
所以技术上讲, 即使去掉这个,

00:31.533 --> 00:33.200
它在这里也能工作｡

00:33.200 --> 00:35.580
但这并不好, 这很危险｡ 

00:35.580 --> 00:38.560
如果我们依赖于某个文件会为我们处理它的事实,

00:38.560 --> 00:41.990
那么如果我们删除或更改那个救了我们的屁股的文件,

00:41.990 --> 00:44.830
我们突然更改了一些完全无关的东西,

00:44.830 --> 00:49.240
我们的应用程序停止工作｡

00:49.240 --> 00:51.420
我们绝对不想那样｡ 

00:51.420 --> 00:53.900
因此, 如果我们有导入和导出,

00:53.900 --> 00:58.050
清楚地说明我们从哪个文件导入什么, 那就太好了｡

00:58.050 --> 00:59.660
如果我们在这里需要一些东西,

00:59.660 --> 01:01.120
例如拖动目标, 而我们没有显式导入它,

01:01.120 --> 01:04.840
我们会得到一个错误｡

01:04.840 --> 01:06.450
这基本上是我们想要的｡ 

01:06.450 --> 01:10.235
我们在ES6模块中也得到了这种行为｡ 

01:10.235 --> 01:12.930
现在, ES6模块也存在于世界的类型之外,

01:12.930 --> 01:17.340
现代浏览器本身就支持它们, 当浏览器执行时,

01:17.340 --> 01:22.960
它基本上会下载一个文件的所有未决项｡

01:22.960 --> 01:28.350
但是类型也可以导入它们, 然后在我们使用它们时获得初始类型支持｡

01:28.350 --> 01:31.007
ES6模块如何工作？

01:31.007 --> 01:33.600
让我们再次从拖放开始｡ 

01:33.600 --> 01:35.240
让我们删除名称空间,

01:35.240 --> 01:37.360
它是一个纯类型的特性｡

01:37.360 --> 01:40.030
不过, 我们还是保留export这个关键字吧｡ 

01:40.030 --> 01:42.150
export关键字不只是用于处理命名空间,

01:42.150 --> 01:49.800
它实际上是一个默认的Java脚本语法, 与typp脚本一样重要｡

01:49.800 --> 01:53.600
这意味着你可以从这个文件中导出这个界面和这里的这个界面,

01:53.600 --> 01:58.460
然后你可以将它导入到另一个文件中｡

01:58.460 --> 02:02.980
在本例中, 我们需要在项目项和项目列表文件中使用它｡

02:02.980 --> 02:05.230
现在, 让我们从项目项开始｡ 

02:05.230 --> 02:09.030
要从ES模块导入某些内容, 以便使用ES模块synthax,

02:09.030 --> 02:18.970
您可以在开始编写任何实际代码之前, 在文件顶部或文件顶部附近指定import｡

02:18.970 --> 02:23.240
Import from, 然后指向该文件,

02:23.240 --> 02:27.320
并使用相对于要导入得文件得路径.

02:27.320 --> 02:31.030
所以在这种情况下, 我们需要在I级上加上两个点和一个斜线｡

02:31.030 --> 02:32.509
这样我们就进入了源文件夹,

02:32.509 --> 02:37.450
然后我们需要转到模块文件夹并进行拖放导入｡

02:37.450 --> 02:40.480
现在, 重要的是, 在这里添加点JS,

02:40.480 --> 02:43.480
因为您需要导入, 就像它已经编译过一样,

02:43.480 --> 02:46.470
因为它将被接管到vanilla Java脚本中,

02:46.470 --> 02:50.860
然后它应该在那里查找Java脚本, 所以对于Java脚本文件,

02:50.860 --> 02:55.010
需要添加点JS｡

02:55.010 --> 02:57.560
现在, 您可以从那里导入一些内容,

02:57.560 --> 03:03.150
然后添加花括号, 在花括号之间指定要从该文件导入的内容｡

03:03.150 --> 03:08.480
我已经得到了自动完成, 我想导入可拖动｡

03:08.480 --> 03:10.910
现在这里提供了可拖动功能,

03:10.910 --> 03:14.430
类型看到它不可用, 很高兴｡

03:14.430 --> 03:17.930
现在我们需要转换所有内容, 以便在运行时显示｡

03:17.930 --> 03:20.370
因此, 我们也要去掉这里的名称空间｡ 

03:20.370 --> 03:22.340
现在还必须关闭花括号｡ 

03:22.340 --> 03:24.870
例如, 现在我们得到了我们想要的,

03:24.870 --> 03:27.540
我们得到了错误, 我们得到了组件错误,

03:27.540 --> 03:29.650
项目, 这些都不见了｡

03:29.650 --> 03:31.890
所以让我们导出和导入所有这些东西｡ 

03:31.890 --> 03:34.540
例如在基础组件中去掉名称空间,

03:34.540 --> 03:36.810
保留你学过的导出关键字｡

03:36.810 --> 03:38.270
去掉右大括号,

03:38.270 --> 03:40.810
重新格式化并导入项目｡

03:40.810 --> 03:43.380
我们总是可以摆脱名称空间｡ 

03:43.380 --> 03:48.803
这里的所有引用, 你可以删除任何地方的所有引用导入｡

03:51.300 --> 03:53.593
去掉所有名称空间的大括号｡ 

03:55.010 --> 03:58.466
项目列表, 去掉所有的名称空间和引用,

03:58.466 --> 04:00.690
去掉下面的右花括号｡

04:00.690 --> 04:03.320
还有装饰器, 去掉名字空间和右花括号,

04:03.320 --> 04:07.940
然后拖放, 我们已经去掉了｡

04:07.940 --> 04:11.920
项目, 去掉名称空间和右大括号｡

04:11.920 --> 04:16.223
项目毫无意外地摆脱了命名空间和关闭｡

04:18.390 --> 04:22.620
这里的花括号实际上是依赖于其他文件导入的项目,

04:22.620 --> 04:26.620
这里没有引用它｡

04:26.620 --> 04:29.880
这就是我所说的危险行为｡

04:29.880 --> 04:31.871
如果我们不导入或不引用其他文件的命名空间中的项目部件,

04:31.871 --> 04:36.710
则此操作可能会失败｡

04:36.710 --> 04:39.090
所以这绝对不是理想的｡ 

04:39.090 --> 04:41.560
但是, 让我们继续我们的重构｡ 

04:41.560 --> 04:47.550
在验证过程中, 去掉这里的命名空间和底部的所有右大括号｡

04:47.550 --> 04:49.150
最后但并非最不重要的一个应用TS,

04:49.150 --> 04:51.503
摆脱这些导入和名称空间｡

04:52.700 --> 04:56.988
所以现在我们到处都是错误, 但现在我们可以重新开始｡

04:56.988 --> 04:59.560
现在, 让我们从基本组件重新开始｡ 

04:59.560 --> 05:03.700
这看起来不错, 它没有抱怨似乎有它想要的一切｡

05:03.700 --> 05:06.250
项目导入, 嗯, 就是抱怨｡ 

05:06.250 --> 05:08.450
比如说我们那里需要的组件｡ 

05:08.450 --> 05:12.070
因此, 让我们在顶部添加一个导入,

05:12.070 --> 05:15.830
并让导入组件从点斜杠基本组件｡

05:15.830 --> 05:19.990
这是当某些内容在同一文件夹中时相对导入的方式｡

05:19.990 --> 05:22.370
点斜杠开头, 然后是文件名,

05:22.370 --> 05:24.490
然后都是点JS｡

05:24.490 --> 05:26.753
别忘了结尾的点JS｡ 

05:28.100 --> 05:30.250
现在我们还需要这里的可验证的中间阶段和验证方法､

05:31.170 --> 05:36.810
自动思维和项目状态｡

05:36.810 --> 05:39.140
所以我们导入所有这些东西,

05:39.140 --> 05:44.080
我们从点斜杠导入, 或者不向上一级, 然后util,

05:44.080 --> 05:46.149
然后验证点JS, 我们从那个文件导入,

05:46.149 --> 06:00.350
validatable和validate函数, 然后导入自动绑定, 从, 向上一级装饰器自动绑定JS｡

06:00.350 --> 06:02.600
最后但并非最不重要的项目状态,

06:02.600 --> 06:07.580
让我们从上一级状态导入项目状态JS｡

06:07.580 --> 06:13.250
我们可以从那里导入导出到那里的项目状态常量｡

06:13.250 --> 06:16.773
现在, 这些都是我们需要在这里使这个文件工作的所有导入｡

06:18.190 --> 06:20.480
现在让我们转到项目项｡ 

06:20.480 --> 06:23.270
在这里, 我们需要自动绑定, 我们需要组件,

06:23.270 --> 06:24.853
我们需要项目模型｡

06:24.853 --> 06:26.700
所以让我们把这些都加进去｡ 

06:26.700 --> 06:30.520
让我们举个例子, 从双点斜杠models

06:30.520 --> 06:34.523
project JS导入项目模型｡

06:35.580 --> 06:41.110
让我们添加位于同一文件夹中的组件｡

06:41.110 --> 06:45.530
因此, 导入点斜杠基本组件JS和自动绑定,

06:45.530 --> 06:55.790
让我们从点斜杠装饰器自动绑定JS导入自动绑定｡

06:56.020 --> 06:59.383
现在这个文件也有它需要的一切｡ 

07:01.260 --> 07:03.410
现在让我们转到项目列表｡ 

07:03.410 --> 07:06.610
在项目列表中, 我们还需要组件, 因此,

07:06.610 --> 07:10.250
我们实际上将从项目项复制到此处, 并将其添加到项目列表TS,

07:10.250 --> 07:16.120
但我们不需要在此处使用draggoble, 而是使用拖动目标, 因此,

07:16.120 --> 07:19.420
让我们导入该组件｡

07:19.420 --> 07:24.550
此外, 我们还需要项目状态和项目状态｡

07:24.550 --> 07:26.540
是的, 这些是我们需要的东西｡ 

07:26.540 --> 07:28.780
以及项目物料类｡ 

07:28.780 --> 07:32.720
因此, 我们还可以从项目模型文件导入项目状态｡

07:32.720 --> 07:35.340
您可以从同一个文件导入多个导出的内容,

07:35.340 --> 07:41.740
只需在这些大括号之间用逗号分隔它们, 就像您在这里看到的那样｡

07:41.740 --> 07:45.910
我们还从state文件夹中导入了项目状态常量,

07:46.790 --> 07:57.130
即项目状态JS, 并且还导入了最后一个但并非最不重要的项目项类, 在最底部我们需要它｡

07:57.130 --> 08:03.623
因此, 从点斜杠项目项点JS导入项目项｡

08:06.810 --> 08:08.280
我们继续吧｡ 

08:08.280 --> 08:13.600
自动绑定是好的, 项目状态抱怨那里我们需要的项目模型｡

08:13.600 --> 08:15.740
因此, 在顶部,

08:16.820 --> 08:22.823
让我们从上一级模型项目点JS导入项目｡

08:24.450 --> 08:29.573
我们还在这里使用了项目状态, 所以让我们从同一个文件导入它｡

08:32.320 --> 08:35.660
最后, 我们获得了应用程序TS文件,

08:35.660 --> 08:38.810
我们需要导入项目输入｡

08:38.810 --> 08:43.610
从项目输入点斜线组成部分

08:43.610 --> 08:48.030
JS和来自项目列表JS的项目列表'如果我们现在保存这个,

08:49.290 --> 09:00.823
它应该编译没有错误, 现在我们使用ES6模块来组织我们的导入和导出｡

09:02.640 --> 09:07.040
如果我们看看浏览器, 虽然我们得到了一个错误.

09:07.040 --> 09:09.390
原因是如果我们检查dist文件夹,

09:09.390 --> 09:12.013
我们就得到了正确的包JS文件｡

09:13.040 --> 09:15.900
现在, 我们需要再次切换TS配置｡ 

09:15.900 --> 09:19.070
对于这里的一个, 我们不应该使用AMD现在,

09:19.070 --> 09:22.420
而是ES 215｡

09:22.420 --> 09:29.300
Than基本上是ES6的代码, ES6是引入ES模块的agma脚本版本｡

09:29.300 --> 09:34.480
所以我们基本上是告诉类型脚本不要把我们的导入转换成任何东西,

09:34.480 --> 09:36.240
保持它们的原样｡

09:36.240 --> 09:39.250
现代浏览器会理解它｡ 

09:39.250 --> 09:43.433
所以这很重要, 还要确保这里有一个ES6或更高版本的目标,

09:44.950 --> 09:47.530
现在还应该再次注释掉out文件,

09:47.530 --> 09:50.670
因为ES模块不支持这样做｡

09:50.670 --> 09:53.590
这样, 您在dist文件夹中得到的基本上是源文件夹的复制,

09:53.590 --> 09:58.690
但带有Java脚本文件｡

09:58.690 --> 10:00.480
因此, 现在我们还需要返回到索引HDML文件并再次导入app

10:00.480 --> 10:06.350
JS, 因为我们现在在dist文件夹中得到了app JS文件｡

10:06.350 --> 10:08.910
同样, 这个应用程序JS文件将在其中包含导入语句,

10:08.910 --> 10:11.180
因为, 正如我提到的, 这是由Java脚本､

10:11.180 --> 10:15.900
现代Java脚本引擎和现代浏览器支持的｡

10:15.900 --> 10:19.440
浏览器将为您解析这些导入｡

10:19.440 --> 10:24.240
所以如果我们现在重新加载这个, 我们仍然会得到一个错误｡

10:24.240 --> 10:27.310
无法在模块外部使用import陈述式｡ 

10:27.310 --> 10:33.150
现在的浏览器支持这个sintex, 但是你必须告诉他们你想使用它｡

10:33.150 --> 10:37.470
你要告诉他们, 把这里的（mumbles）去掉, 而在script标签上,

10:37.470 --> 10:42.777
你导入一个文件, 里面有这些imports语句｡

10:42.777 --> 10:46.313
您使用类型等于module｡ 

10:47.300 --> 10:50.450
如果您现在保护它, 您会看到它工作, 现在如果我们在这里添加一些东西,

10:50.450 --> 10:56.120
我们就会再次获得工作的应用程序｡

10:56.120 --> 10:58.910
现在, 如果您检查一下“network”选项卡,

10:58.910 --> 11:01.680
您会看到, 如果重新加载, 会有一堆网络请求正在进行,

11:01.680 --> 11:07.410
如果我将其缩小一点, 我们可以更好地看到它｡

11:07.410 --> 11:10.340
我们所有的Java脚本文件都需要在这里｡ 

11:10.340 --> 11:12.810
当浏览器遇到我们的导入时,

11:12.810 --> 11:14.780
它会自动请求它们｡

11:14.780 --> 11:16.967
因此, 它从应用程序JS开始,

11:16.967 --> 11:19.410
然后看到项目输入JS的导入｡

11:19.410 --> 11:23.160
在这里, 当然下一个请求是项目输入｡

11:23.160 --> 11:25.410
它也会对项目列表执行相同的操作｡ 

11:25.410 --> 11:27.360
现在, 在项目输入中, 例如,

11:27.360 --> 11:29.422
它将看到来自基本组件JS的输入,

11:29.422 --> 11:33.400
这就是为什么它还导入prob基本组件JS的原因｡

11:33.400 --> 11:35.530
这是由浏览器完成的, 我们利用了它,

11:35.530 --> 11:38.170
现在我们有了另一种拆分文件的方法,

11:38.170 --> 11:45.850
但还有一个额外的优势, 即我们清楚地说明了我们需要从每个文件中获得什么, 如果我们省略了导入,

11:45.850 --> 11:58.870
类型脚本会对我们大喊大叫, 这在以前的方法中是没有的, 这是我实际上推荐的方法, 也是为什么它是事实上的标准导入和导出方法｡

11:58.870 --> 12:00.710
现在, 如果您以前在其他项目中使用过类型脚本,

12:00.710 --> 12:12.210
比如说在角度项目中, 您可能也习惯于不必在此处指定文件扩展名｡ 一旦添加了Web包和账单工具, 我们也可以忽略它｡

12:12.210 --> 12:14.580
只要我们没有, 我们依靠浏览器来导入我们的文件,

12:14.580 --> 12:18.833
你需要添加额外的扩展名｡
