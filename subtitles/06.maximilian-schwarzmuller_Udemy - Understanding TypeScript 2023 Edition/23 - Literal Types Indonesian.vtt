WEBVTT

00:02.350 --> 00:03.921
Instruktur: Jadi, sekarang, kita punya jenis serikat pekerja di sini.

00:03.921 --> 00:07.440
Mari kita bangun ide tentang tipe union dan juga

00:07.440 --> 00:09.764
memperkenalkan tipe Literal.

00:09.764 --> 00:14.290
Tipe literal adalah tipe di mana Anda tidak hanya mengatakan bahwa variabel

00:14.290 --> 00:16.436
tertentu atau parameter harus disimpan,

00:16.436 --> 00:19.700
katakanlah angka atau string, tetapi di mana Anda sangat

00:19.700 --> 00:21.230
jelas tentang nilai pasti

00:21.230 --> 00:23.800
yang harus disimpan.

00:23.800 --> 00:26.064
Kita sudah melihatnya sejak awal di sini, dalam hal dasar-dasarnya.

00:26.064 --> 00:28.408
Konst nomor dua, misalnya.

00:28.408 --> 00:32.098
Di sana, jika saya arahkan kursor ke sana, Anda melihat tipe yang disimpulkan

00:32.098 --> 00:35.680
bukan angka, melainkan 2. 8.

00:35.680 --> 00:37.290
Dan kelompok tipe memang menyimpulkan

00:37.290 --> 00:41.220
bilangan konkret ini sebagai tipe di sini karena ini adalah konstanta.

00:41.220 --> 00:43.810
Ini tidak akan pernah berubah dan oleh karena itu kelompok tipe tahu nilai yang

00:43.810 --> 00:48.211
saya tetapkan di sini adalah tipe yang tepat yang saya miliki. Jadi tentu saja ini adalah angka,

00:48.211 --> 00:52.796
Anda bisa mengatakan 2. 8 berasal dari jenis angka tetapi itu

00:52.796 --> 00:56.320
adalah angka tertentu. Dan ini tidak hanya ada

00:56.320 --> 00:59.160
untuk angka, tetapi juga untuk string

00:59.160 --> 01:02.860
dan sebagainya. Dan khususnya untuk string, ini bisa sangat berguna.

01:02.860 --> 01:07.420
Katakanlah di sini dalam fungsi gabungan kami, kami mengharapkan angka atau string dan

01:07.420 --> 01:10.190
kami menggabungkannya secara berbeda berdasarkan apa

01:10.190 --> 01:13.756
yang kami dapatkan, tetapi kami juga ingin mengizinkan pemanggil fungsi

01:13.756 --> 01:18.756
untuk menentukan bagaimana hasilnya harus dikembalikan sehingga pada dasarnya kami dapat memaksa

01:18.880 --> 01:25.370
konversi dari angka ke string atau sebaliknya.

01:25.370 --> 01:25.370
Kita

01:25.370 --> 01:29.740
bisa melakukan ini dengan parameter ketiga dan kita bisa menamainya katakanlah tipe hasil atau

01:29.740 --> 01:33.208
konversi hasil atau bagaimanapun Anda ingin menamainya dan saya ingin menggambarkan

01:33.208 --> 01:37.240
ini dengan string. Jadi saya akan mengatur ini

01:37.240 --> 01:41.122
untuk mengetik string. Sekarang ide saya adalah bahwa

01:41.122 --> 01:45.625
saya dapat memanggil combine di sini dengan dua angka dan misalnya memasukkan

01:45.625 --> 01:50.625
string "as-number" dan itu sepenuhnya terserah Anda pengidentifikasi mana

01:50.630 --> 01:55.630
yang Anda gunakan di sini. Di bawah sana kita mungkin memiliki "as-text"

01:56.260 --> 01:59.357
tetapi kemudian kita mungkin memiliki kombinasi lain

02:02.910 --> 02:07.310
di sini CombinedStringAges di mana saya mengoper dua string tetapi saya masih

02:07.310 --> 02:10.030
ingin mengeluarkan "as-number" ini dan ini akan

02:10.030 --> 02:13.540
menjadi kasus di mana parameter ketiga dapat membantu untuk memaksa

02:13.540 --> 02:17.050
konversi karena jika saya mengoper dua string di sini biasanya

02:17.050 --> 02:19.950
kita akan membuatnya menjadi cabang lain dan menggabungkannya

02:19.950 --> 02:24.730
dan saya mungkin ingin mengembalikan ini sebagai angka sebagai gantinya sehingga saya

02:24.730 --> 02:34.030
juga dapat konsol log agen string gabungan di sini.

02:34.030 --> 02:34.030
Jadi

02:34.030 --> 02:37.512
sekarang kita hanya perlu memperhitungkan pengidentifikasi ini dalam fungsi kita dengan menyertakan

02:37.512 --> 02:41.730
resultConversion dalam pemeriksaan if kita. Sekarang pertanyaannya adalah apa

02:41.730 --> 02:45.700
sebenarnya yang ingin kita lakukan; apakah kita ingin memastikan

02:45.700 --> 02:49.930
bahwa kita dapat memaksa kedua string ini untuk ditambahkan sebagai

02:49.930 --> 02:54.012
angka atau apakah kita ingin memaksa hasilnya tidak peduli apakah

02:54.012 --> 02:58.695
itu perhitungan matematis atau penggabungan string untuk diubah menjadi

02:58.695 --> 03:03.039
teks atau angka. Jika kita ingin memaksa konversi,

03:03.039 --> 03:05.960
kita bisa menambahkan if check di sini dan memeriksa

03:05.960 --> 03:10.382
apakah hasil konversi sama dengan "as-number" dan jika itu kasusnya,

03:10.382 --> 03:15.340
saya ingin mengembalikan hasil dengan plus di depannya yang mengubahnya

03:15.340 --> 03:18.826
menjadi angka, alternatifnya adalah parseFloat misalnya

03:18.826 --> 03:24.420
tetapi di sini saya hanya akan menggunakan plus karena ini sedikit lebih pendek dan

03:24.420 --> 03:29.420
jika tidak, saya ingin mengembalikan hasil toString untuk memaksa output

03:30.156 --> 03:33.593
sebagai string.

03:34.570 --> 03:38.883
Jadi sekarang kita melakukan kalkulasi berdasarkan tipe sebenarnya yang kita dapatkan

03:38.883 --> 03:42.300
tapi kemudian kita convert ke result itu salah satu cara untuk melakukan

03:42.300 --> 03:46.360
itu dan jika kita simpan dan kita compile file ini, kita lihat ini adalah hasil yang

03:47.470 --> 03:51.020
saya dapatkan dan kita mendapatkan output itu misalnya untuk kombinasi

03:51.020 --> 03:54.759
string kita di sini karena seperti yang saya katakan, kombinasinya sendiri

03:54.759 --> 03:58.520
kalkulasi jadi untuk mengatakan dilakukan berdasarkan tipe yang kita masukkan

03:58.520 --> 04:02.530
di mana di sini adalah string jadi kita menggabungkannya dan kemudian kita hanya

04:02.530 --> 04:05.860
mengkonversi ke result.

04:05.860 --> 04:09.593
Logika alternatifnya adalah memeriksa tipe di sini

04:09.593 --> 04:14.320
dan melakukan operasi yang berbeda berdasarkan tipe pengembalian

04:14.320 --> 04:19.180
yang kita tentukan di sini. Jadi kita bisa mengomentari ini dan sebagai

04:19.180 --> 04:22.600
gantinya di sini mengatakan jika tipe input satu adalah

04:22.600 --> 04:26.230
angka dan tipe input dua adalah angka, atau jika resultConversion

04:27.890 --> 04:30.865
sama dengan "as-number" maka saya ingin menggabungkan

04:30.865 --> 04:35.865
nilai-nilai seperti ini dan sekarang untuk menghindari kesalahan ini, di sini saya

04:35.930 --> 04:38.794
memaksa konversi ke angka dengan menambahkan

04:38.794 --> 04:42.970
plus di depan setiap input sehingga setiap input dikonversi ke angka

04:42.970 --> 04:48.490
dan dijamin menjadi angka sebelum saya menggabungkannya.

04:48.490 --> 04:51.130
Catatan tambahan: jika Anda akan mengoper string

04:51.130 --> 04:54.610
yang tidak dapat dikonversi ke angka, jadi sesuatu seperti Max

04:54.610 --> 04:58.800
misalnya, maka Anda akan mendapatkan NaN, Not a Number sebagai hasilnya.

04:58.800 --> 05:00.280
Nah kemudian dalam kasus lain,

05:00.280 --> 05:03.170
sehingga kita tidak memiliki "as-number", atau bahwa

05:03.170 --> 05:07.976
kita tidak memiliki input angka, maka kita membuatnya menjadi blok ini di sini dan sekarang

05:07.976 --> 05:12.390
dengan itu jika saya mengembalikan hasil lagi di sini, dan kemudian kita kemudian

05:12.390 --> 05:16.230
menyimpan ini dan mengkompilasi ulang, kita akan melihat output yang berbeda

05:16.230 --> 05:20.230
pada halaman kita. Sekarang kita mendapatkan 56 dalam dua baris

05:20.230 --> 05:22.945
di sini karena sekarang kita tidak mengonversi hasilnya,

05:22.945 --> 05:26.300
jadi kita tidak mengonversi string gabungan untuk baris ini tetapi

05:26.300 --> 05:29.070
sebaliknya kita melakukan konversi sebelum kita menggabungkan

05:29.070 --> 05:31.970
dua nilai. Jadi, terserah Anda logika mana

05:31.970 --> 05:34.760
yang ingin Anda terapkan. Saya sebenarnya ingin melihat

05:34.760 --> 05:37.551
lebih dekat pada konsep tipe literal yang saya jelaskan

05:37.551 --> 05:41.180
di awal kuliah ini. Saya melewati "as-number" dan

05:41.180 --> 05:44.157
"as-text" dan turunnya bisnis yang saat ini kita

05:44.157 --> 05:47.600
sebagai pengembang harus menghafal nilai-nilai ini.

05:47.600 --> 05:50.450
Kita harus memastikan bahwa kita tidak melewatkan tipe di sini.

05:50.450 --> 05:54.010
Sekarang kita bisa menggunakan e-num untuk meningkatkannya tetapi jika

05:54.010 --> 05:57.754
kita hanya memiliki dua nilai di sini, "as-text" atau "as-number", maka mungkin

05:57.754 --> 06:00.940
semua pencarian tipe literal bisa menjadi pilihan.

06:00.940 --> 06:04.173
Kita bisa mengatakan "ini tidak boleh berupa string

06:04.173 --> 06:09.173
apapun, harus "as-number" atau "as-text"" sehingga kita menggunakan tipe

06:09.870 --> 06:12.090
union yang dikombinasikan dengan

06:12.090 --> 06:15.573
tipe literal. Tipe literal adalah tipe-tipe yang

06:15.573 --> 06:17.987
didasarkan pada tipe inti Anda string, angka dan

06:17.987 --> 06:20.933
sebagainya tetapi kemudian Anda kemudian memiliki versi

06:20.933 --> 06:24.750
spesifik dari tipe tersebut. Jadi di sini, kita mengizinkan secara khusus

06:24.750 --> 06:27.960
dua string ini, bukan string apa pun, hanya dua string ini.

06:27.960 --> 06:31.460
Jadi, kita menginginkan string untuk hasil konversi, tetapi harus salah

06:31.460 --> 06:34.207
satu dari kedua nilai ini. Nilai string lainnya tidak akan

06:34.207 --> 06:37.560
diizinkan, jadi itulah ide di balik tipe literal dan sering kali Anda akan

06:37.560 --> 06:40.747
menggunakan ini dalam konteks tipe union karena Anda tidak hanya ingin

06:40.747 --> 06:43.700
mengizinkan satu nilai yang tepat, Anda dapat membuat kode keras

06:43.700 --> 06:46.500
ke dalam kode Anda jika itu yang akan terjadi tetapi Anda ingin

06:46.500 --> 06:49.544
memiliki dua atau lebih nilai yang mungkin.

06:49.544 --> 06:52.580
Dalam hal ini kita mendapatkan dua kemungkinan nilai.

06:52.580 --> 06:56.240
Jadi sekarang kita dijamin mendapatkan hasil konversi yang

06:56.240 --> 07:00.288
berupa "as-number" atau "as-text" dan misalnya di sini, Jika sekarang

07:00.288 --> 07:03.800
saya mencoba membandingkan ini dengan as-numbe karena saya

07:03.800 --> 07:07.256
memiliki kesalahan ketik di sini, grup tipe dapat memberi

07:07.256 --> 07:10.360
tahu saya di sini di IDE dan tentu saja semua yang kita

07:10.360 --> 07:15.360
simpan dan kompilasi di sini di terminal karena ia tahu bahwa as-numbe tanpa r di akhir

07:15.830 --> 07:18.940
tidak akan pernah menjadi nilai yang valid untuk resultConversion

07:18.940 --> 07:24.563
karena saya menetapkan tipe union ini dengan tipe literal ini.

07:25.550 --> 07:27.593
Jadi sekarang kita kembali mendapatkan beberapa

07:27.593 --> 07:31.590
keamanan tipe ekstra dan memastikan kita tidak dapat menggunakan ini secara salah.

07:31.590 --> 07:34.720
Hal yang sama tentu saja untuk mengoper nilai. Jika kita memiliki kesalahan ketik

07:34.720 --> 07:38.747
di sini, kita mendapatkan kesalahan hanya jika kita menggunakan "as-number" atau "as-text"

07:38.747 --> 07:41.947
kita diizinkan untuk mengkompilasi ini seperti yang Anda lihat dan sekarang

07:41.947 --> 07:45.470
mengkompilasi ini, ini berfungsi dan kita mendapatkan output yang sama seperti

07:45.470 --> 07:49.562
sebelumnya di sini. Jadi, ini adalah tipe literal yang sangat

07:49.562 --> 07:52.193
berguna ketika digunakan bersama dengan tipe union.
