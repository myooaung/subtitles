WEBVTT

00:02.540 --> 00:05.610
講師：次に､ 関数のオーバーロードについて説明します｡

00:05.610 --> 00:13.840
これは､ 1つの関数に対して複数の関数シグネチャを定義できる機能です｡

00:13.840 --> 00:17.080
これは､ 例えば､ ある関数を異なるパラメータで呼び出し､

00:17.080 --> 00:24.300
その関数の内部で何かを行う方法を複数用意することができるということです｡

00:24.300 --> 00:26.540
そして､ 関数のオーバーロードが役に立つ良い例が､

00:26.540 --> 00:29.060
もう少し上にあります｡

00:29.060 --> 00:32.090
先ほど書いたadd関数は､ 2つの組み合わせ可能な値､

00:32.090 --> 00:43.450
つまり文字列や数値を受け取り､ TypeScriptが推論する戻り値の型を見てわかるように､ すべて組み合わせ可能であることを意味する｡

00:43.450 --> 00:47.960
これは単純に､ TypeScriptが返すものも文字列か数値だと理解しているということなのだが､

00:47.960 --> 00:52.880
実はよく考えてみると､ そうでもないのだ｡

00:52.880 --> 00:55.280
つまり､ 技術的にはそうなのですが､ 2つの数値を渡すと､

00:55.280 --> 00:59.400
戻り値の型は常に数値になることが分かっています｡

00:59.400 --> 01:03.950
少なくとも1つの文字列を渡すと､ 戻り値の型は文字列になります｡

01:03.950 --> 01:05.460
さて､ なぜこのようなことが問題になるのでしょうか｡ 

01:05.460 --> 01:08.225
add関数はこのように書かれていることを頭に入れておいてください｡ 

01:08.225 --> 01:11.060
そして実際に､ 下の部分をすべてコメントアウトして､

01:11.060 --> 01:15.390
関数のすぐ下に新しいコードを追加することができます｡

01:15.390 --> 01:18.670
ここでaddを呼び出して結果を得る場合､ 1と5を渡すと､

01:18.670 --> 01:23.390
結果はcombinable型であることがわかる｡

01:23.390 --> 01:30.390
この結果､ TypeScriptはresultが数値なのか文字列なのか分からなくなる｡

01:30.390 --> 01:34.510
さて､ これは文字列で渡す場合には本当に重要なことかもしれません｡ 

01:34.510 --> 01:41.750
ここでMax Schwarzにパスすると､ これはうまくいくのですが､ やはりcombinableが返ってきてしまいます｡

01:41.750 --> 01:43.990
その結果､ 結果に対して文字列関数を呼び出すことができなくなり､

01:43.990 --> 01:50.600
例えばsplitを呼び出して空白の部分で分割することができなくなりました｡

01:50.600 --> 01:55.270
このように関数を呼び出すと､ このif分岐にして文字列が返ってくるので､

01:55.270 --> 02:05.620
resultsが文字列を保持することは分かっているのですが､ TypeScriptは文字列や数値を保持することだけを知っているのです｡

02:05.620 --> 02:11.340
もちろん､ ここで型キャストを使って､ 返ってきたものが文字列であることをTypeScriptに伝えることができる｡

02:11.340 --> 02:16.040
これは､ 先ほど学習したタイプキャスティング構文で可能です｡

02:16.040 --> 02:21.800
なぜなら､ TypeScriptが､ この関数をこのように呼び出すと必ず文字列が返ってくるということを理解してくれると思っていても､

02:21.800 --> 02:27.740
ここでさらにコードを書かなければならないからだ｡

02:27.740 --> 02:30.890
しかし､ TypeScriptはここでコードを十分に解析してくれない｡

02:30.890 --> 02:35.000
そこで､ 関数のオーバーロードが役に立つのである｡

02:35.000 --> 02:38.730
関数のオーバーロードは､

02:38.730 --> 03:03.410
メイン関数のすぐ上に同じ名前の関数を書くだけです｡ この行を基本的に繰り返しますが､ 中括弧はありません｡

03:03.410 --> 03:06.643
そして､ そこで言えることは､ そのときの戻り値の型は数字であるということです｡ 

03:08.840 --> 03:10.980
つまり､ TypeScriptに対して､

03:10.980 --> 03:17.180
「この関数を呼び出して､ 両方の引数が数字だったら､ この関数は数字を返すよ」と言っているわけです｡

03:17.180 --> 03:19.430
もちろん､ これはJavaScriptで動作する構文ではないので､

03:19.430 --> 03:24.430
TypeScriptではコンパイルの過程で排除される｡

03:24.430 --> 03:31.380
しかし､ TypeScriptはこの関数情報とこの関数宣言を一緒にして､

03:31.380 --> 03:35.550
基本的にこの2行の知識を結合しています｡

03:35.550 --> 03:38.590
そして､ この関数はcombinable型のAとB､

03:38.590 --> 03:43.790
またはnumber型のAとBで呼び出すことができることがわかりました｡

03:43.790 --> 03:47.060
ちなみに､ オーバーロードのパラメータを増やしたり減らしたりすることも可能で､

03:47.060 --> 03:50.100
実に柔軟性がある｡

03:50.100 --> 03:53.640
また､ ここに関数addを追加して､ 1つの数値を期待して数値を返すだけです｡

03:53.640 --> 04:03.270
これは､ 他のオーバーロードでも同様にBをオプションにすると動作します｡

04:03.270 --> 04:05.254
なぜなら､ 最終的にはもちろん､ ここにあるコードが常に動作し､

04:05.254 --> 04:10.850
最終的に必要なすべての引数を受け取れるようにする必要があるからです｡

04:10.850 --> 04:15.170
もちろん､ Bがオプションになる可能性があるので､

04:15.170 --> 04:19.550
それを回避する必要があります｡

04:19.550 --> 04:21.390
しかし､ それは必要ないので､ それを取り除き､

04:21.390 --> 04:24.460
これだけにします｡ また､ 文字列でこれを呼び出したときのために､

04:24.460 --> 04:27.200
オーバーロードは欲しくありませんでした｡

04:27.200 --> 04:33.450
そこで､ Aを文字列､ Bを文字列とするadd関数のオーバーロードをもう一つ追加し､

04:33.450 --> 04:38.460
返すものが文字列であるという事実を明確にします｡

04:38.460 --> 04:43.660
ちなみに､ ここではこれらのオーバーロードの行の後にセミコロンを付けるのが良い方法です｡

04:43.660 --> 04:46.560
つまり､ 2つの数字を使ってこの関数を呼び出すと､

04:46.560 --> 04:49.100
常に1つの数字が返ってくるということです｡

04:49.100 --> 04:52.170
2つの文字列で呼び出すと､ 必ず1つの文字列が返ってくる｡ 

04:52.170 --> 04:54.510
1つの文字列と1つの数字で呼び出すと､

04:54.510 --> 04:59.410
技術的には常に文字列が返ってきますが､ ここで考えられる組み合わせをすべて追加したくありません｡

04:59.410 --> 05:03.173
もちろん､ さらに追加して､ ここで数字も追加できますし､ 他の組み合わせ､

05:04.040 --> 05:07.500
つまりこの組み合わせもあります｡

05:07.500 --> 05:10.060
そうですね......今は､ すべての組み合わせを追加しました｡ 

05:10.060 --> 05:12.540
そして今､ ここにすべての可能な値の組み合わせと､

05:12.540 --> 05:16.040
それぞれのケースで返すものをリストアップしています｡

05:16.040 --> 05:18.260
これでエラーがなくなったのは､ TypeScriptが､

05:18.260 --> 05:20.520
両方とも文字列であるこれら2つの値でaddを呼び出すと､

05:20.520 --> 05:25.623
結果が文字列型になることを知っているからだ｡

05:25.623 --> 05:31.100
また､ addにカーソルを合わせると､ さらに3つのオーバーロードが利用できることがわかります｡

05:31.100 --> 05:32.980
ここでは2つの文字列でaddを呼び出しているが､

05:32.980 --> 05:36.630
TypeScriptはこの他に3つの呼び出し方があることを知っている｡

05:36.630 --> 05:39.450
例えば､ 文字列と数字の場合､ 文字列が返ってくるし､

05:39.450 --> 05:41.340
数字と何かの文字列の場合､

05:41.340 --> 05:46.340
数字が2つある場合などです｡

05:47.430 --> 05:48.630
これも有効でしょう｡ 

05:48.630 --> 05:50.210
なぜなら､ TypeScriptは､

05:50.210 --> 05:54.630
2つの数字を使ってこれを呼び出すと､ 1つの数字が返ってくることを正しく認識しており､

05:54.630 --> 05:58.253
数字に対してsplitを呼び出すことはできないからだ｡

05:59.260 --> 06:04.060
これは関数のオーバーロードであり､

06:04.060 --> 06:16.033
TypeScriptが正しく戻り値の型を推測できないような状況で役立つものである｡
