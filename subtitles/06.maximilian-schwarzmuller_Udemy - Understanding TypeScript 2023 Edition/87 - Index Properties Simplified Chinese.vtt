WEBVTT

00:02.110 --> 00:03.890
教师：现在, 在所有这些功能之后,

00:03.890 --> 00:10.340
我们处理了类型本身, 也就是说, 我们处理了检查类型, 计算类型的成本,

00:10.340 --> 00:16.110
让我们回到帮助我们驾驭灵活代码的功能｡

00:16.110 --> 00:17.930
当然, 还是写这两种类型｡ 

00:17.930 --> 00:20.150
它毕竟是打字稿, 但不是那么多的关注只是类型,

00:20.150 --> 00:23.520
现在我们可以管理他们｡

00:23.520 --> 00:25.830
为此, 我想从索引类型开始,

00:25.830 --> 00:33.010
这个特性允许我们创建对象, 这些对象在它们可能拥有的属性方面更加灵活｡

00:33.010 --> 00:34.485
我说这话是什么意思？

00:34.485 --> 00:36.813
假设您正在编写一个应用程序,

00:36.813 --> 00:39.680
其中您要验证某些用户输入｡

00:39.680 --> 00:41.810
因此, 您有多个输入字段,

00:41.810 --> 00:44.603
根据用户在其中输入的内容以及输入的字段,

00:44.603 --> 00:50.490
您可能希望存储并最终显示不同的错误消息｡

00:50.490 --> 00:52.520
例如, 如果它是一个电子邮件字段,

00:52.520 --> 00:54.360
你想检查它是谁在电子邮件中,

00:54.360 --> 00:59.830
如果它不是, 那么你想添加一个适当的错误消息到错误容器｡

00:59.830 --> 01:01.133
这就是我要开始的｡ 

01:01.133 --> 01:06.133
我将在这里放置我的接口错误容器｡ 

01:07.570 --> 01:09.530
这应该是一个对象, 因此我在这里使用了一个接口,

01:09.530 --> 01:14.090
但它应该灵活地处理它所保存的内容｡

01:14.090 --> 01:15.680
最后, 我的目标是,

01:15.680 --> 01:17.692
我们可以处理有错误标识符的对象,

01:17.692 --> 01:23.700
如果错误属于输入字段, 这可能是理想的｡

01:23.700 --> 01:26.581
例如, 电子邮件｡  然后是一些错误字符串,

01:26.581 --> 01:31.581
不是有效的电子邮件｡ 然后我们有另一个属性｡ 

01:32.130 --> 01:35.610
假设用户名, 如果输入字段不正确,

01:35.610 --> 01:41.611
则错误字符串可能会存储该输入字段｡

01:41.611 --> 01:45.770
必须以字符开头｡ 

01:45.770 --> 01:49.170
类似的内容应该存储在该对象中｡ 

01:49.170 --> 01:55.320
问题是, 我不知道我们会在那里有哪些确切的属性名称｡

01:55.320 --> 01:58.021
你可以说, 我们有电子邮件和用户名,

01:58.021 --> 02:01.650
但首先我希望它是一个灵活的容器｡

02:01.650 --> 02:05.350
我希望能够使用它的任何形式我在我的网页｡

02:05.350 --> 02:07.560
我可能会有不同的表单,

02:07.560 --> 02:10.157
输入不同, 标识符也不同｡

02:10.157 --> 02:16.150
所以我不想把自己局限在我们的电子邮件和用户名错误上｡

02:16.150 --> 02:18.461
此外, 即使我们一直只有电子邮件和用户名输入,

02:18.461 --> 02:23.291
我们只是想存储这些错误｡

02:23.291 --> 02:27.461
如果只有电子邮件无效, 而用户名无效, 我们该怎么办？

02:27.461 --> 02:30.912
当然, 在这个对象中, 我们可以存储null作为用户名的值,

02:30.912 --> 02:34.421
但我想忽略它｡

02:34.421 --> 02:37.232
那么, 我们是否有一个对象,

02:37.232 --> 02:40.419
它只保存有错误的输入的属性？

02:40.419 --> 02:42.960
所以我们也可以用一个4 in循环遍历这个对象,

02:42.960 --> 02:51.112
来读取我们得到的所有错误, 比如说, 没有任何属性在那里, 实际上没有存储错误｡

02:51.112 --> 02:53.261
长话短说, 我需要一个对象,

02:53.261 --> 02:56.861
其中我对值类型非常清楚｡

02:56.861 --> 03:02.190
它应该是一个字符串, 但我没有提前多少属性,

03:02.190 --> 03:05.320
我将有什么属性的名称｡

03:05.320 --> 03:08.171
对于这种情况, 我们可以使用索引类型｡ 

03:08.171 --> 03:10.760
您可以在此处使用方括号来定义索引类型｡ 

03:10.760 --> 03:16.280
请记住, 通常我们会在此处写入属性名称, 但现在我们使用方括号｡

03:16.280 --> 03:21.280
然后, 您可以选择任何名称, 例如key或prop｡ 

03:23.581 --> 03:28.581
然后是冒号｡  然后是属性的值类型｡ 

03:29.010 --> 03:30.010
然后是一个对象｡ 

03:30.010 --> 03:33.760
不能将字符串､ 数字或符号作为属性｡ 

03:33.760 --> 03:37.660
例如, 这里不能使用布尔值｡  这是不允许的｡ 

03:37.660 --> 03:40.504
但是你可以在这里使用字符串｡ 

03:40.504 --> 03:46.330
我只是简单地说, 无论我以后基于这个错误容器接口构造什么对象,

03:46.330 --> 03:51.083
都必须有属性, 也就是字符串｡

03:52.120 --> 03:53.928
例如, 用户名是一个有效的字符串,

03:53.928 --> 03:55.899
即使我没有用引号将它括起来｡

03:55.899 --> 04:01.629
然后, 添加冒号｡  然后是值类型, 即字符串｡

04:01.629 --> 04:01.629
所以我说我不知道确切的财产名称｡

04:04.320 --> 04:07.620
我也不知道财产算不算｡ 

04:07.620 --> 04:13.459
我只知道添加到该对象的每个属性（基于错误容器）都必须有一个可解释为字符串的属性名,

04:13.459 --> 04:23.080
并且属性的值也必须是字符串｡

04:23.080 --> 04:23.080
我就是这个意思｡ 

04:23.080 --> 04:35.339
现在, 我们仍然可以添加预定义的属性, 但是, 前提是它们的类型与这里的相同｡

04:35.339 --> 04:35.339
因此, 我们可以添加一个ID, 它是一个类型字符串｡ 

04:35.339 --> 04:39.760
然后我们构建的任何符合这个接口的对象都必须有一个ID属性,

04:39.760 --> 04:43.360
并且可以根据需要添加任意多的其他属性, 但是我们不能在这里将ID设置为一个数字,

04:43.360 --> 04:49.277
例如, 因为我们在这里有一个索引类型｡

04:49.277 --> 04:53.033
这就是我们构建这样的对象时所受到的限制｡ 

04:55.240 --> 04:56.550
那么现在的后果是什么呢？

04:56.550 --> 05:00.080
现在我们可以创建一个错误包, 例如, 它的类型是错误容器,

05:00.080 --> 05:02.390
因此它是一个对象, 它是有效的,

05:02.390 --> 05:07.440
因为我们不必添加任何属性｡

05:07.440 --> 05:10.340
这是所有有效的｡  当然, 我们现在可以添加一些｡ 

05:10.340 --> 05:13.380
例如, 电子邮件不是有效的电子邮件｡ 

05:13.380 --> 05:17.093
这是好的｡  如果我在这里赋值一个数字就不好了,

05:17.093 --> 05:23.001
因为我们说每个属性都需要一个字符串值类型｡

05:23.001 --> 05:23.001
所以我们必须在这里使用字符串｡ 

05:23.001 --> 05:25.940
如果我在这里使用数字, 就可以了,

05:25.940 --> 05:28.610
因为它也可以被解释为字符串.

05:28.610 --> 05:33.031
如果我愿意的话, 我也可以在这里使用数字作为键类型｡

05:33.031 --> 05:33.031
我在这里用什么都很自由｡

05:33.031 --> 05:35.981
如果它能把道具类型改成数字,

05:35.981 --> 05:44.810
你就可以这么做了.

05:44.810 --> 05:44.810
但这不会因为电子邮件不是一个数字｡

05:46.470 --> 05:48.170
无法转换为数字｡ 

05:48.170 --> 05:51.550
可以将其视为字符串, 但不能视为数字｡ 

05:51.550 --> 05:56.990
因此, 这就是您控制允许哪些类型的属性或哪些属性名称的方式｡

05:56.990 --> 05:59.493
这里我做了一个允许字符串属性名的操作｡ 

05:59.493 --> 06:04.740
因此, 任何可以转换为字符串的内容都是有效的属性名｡

06:04.740 --> 06:04.740
值也必须是字符串｡

06:06.413 --> 06:08.021
正如我刚才所说,

06:08.021 --> 06:10.632
我们可以在这里添加多个值,

06:10.632 --> 06:12.830
应该说是多个值｡

06:12.830 --> 06:17.263
必须以大写字符开头｡ 

06:18.170 --> 06:22.722
现在我们可以在错误容器的帮助下构建这样一个错误包,

06:22.722 --> 06:27.522
这给了我们额外的灵活性, 我们不需要提前知道我们想要使用哪些属性名,

06:27.522 --> 06:32.653
以及需要多少个属性｡
