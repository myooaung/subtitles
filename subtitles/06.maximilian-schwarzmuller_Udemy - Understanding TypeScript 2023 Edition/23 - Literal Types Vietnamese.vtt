WEBVTT

00:02.350 --> 00:03.921
Người hướng dẫn: Vì vậy, bây giờ, chúng ta có các loại công đoàn ở đây.

00:03.921 --> 00:07.440
Hãy xây dựng ý tưởng về các kiểu kết hợp và cũng

00:07.440 --> 00:09.764
giới thiệu các kiểu Literal.

00:09.764 --> 00:14.290
Các loại chữ là các loại mà bạn không chỉ nói rằng một biến hoặc

00:14.290 --> 00:16.436
một tham số nhất định sẽ giữ,

00:16.436 --> 00:19.700
chẳng hạn như một số hoặc một chuỗi, nhưng

00:19.700 --> 00:21.230
bạn rất rõ ràng về giá

00:21.230 --> 00:23.800
trị chính xác mà nó sẽ giữ.

00:23.800 --> 00:26.064
Chúng tôi đã thấy điều đó sớm ở đây trong những điều cơ bản.

00:26.064 --> 00:28.408
Const số hai chẳng hạn.

00:28.408 --> 00:32.098
Ở đó, nếu tôi di chuột qua đó, bạn sẽ thấy loại được suy ra

00:32.098 --> 00:35.680
không phải là số mà là 2. số 8.

00:35.680 --> 00:37.290
Và nhóm các loại đã suy ra

00:37.290 --> 00:41.220
con số cụ thể này dưới dạng một loại ở đây vì nó là một hằng số.

00:41.220 --> 00:43.810
Nó sẽ không bao giờ thay đổi và do đó, nhóm loại biết giá trị

00:43.810 --> 00:48.211
tôi chỉ định ở đây là loại chính xác mà tôi có. Vì vậy, tất nhiên đây là một

00:48.211 --> 00:52.796
con số, bạn có thể nói 2. 8 bắt nguồn từ kiểu số nhưng nó

00:52.796 --> 00:56.320
là một con số cụ thể. Và điều này không chỉ

00:56.320 --> 00:59.160
tồn tại đối với các số mà còn đối với

00:59.160 --> 01:02.860
các chuỗi, v.v. Và đặc biệt đối với chuỗi, nó có thể rất hữu ích.

01:02.860 --> 01:07.420
Giả sử ở đây trong hàm kết hợp của chúng tôi, chúng tôi mong đợi các số hoặc

01:07.420 --> 01:10.190
chuỗi và chúng tôi kết hợp chúng theo cách khác

01:10.190 --> 01:13.756
nhau dựa trên những gì chúng tôi nhận được nhưng chúng tôi

01:13.756 --> 01:18.756
cũng muốn cho phép người gọi hàm xác định cách kết quả sẽ được trả về để về cơ bản

01:18.880 --> 01:22.530
chúng tôi có thể buộc chuyển đổi từ số sang chuỗi hoặc ngược

01:22.530 --> 01:25.370
lại. Chúng tôi có thể làm điều

01:25.370 --> 01:29.740
này với tham số thứ ba và chúng tôi có thể đặt tên cho loại kết quả hoặc chuyển

01:29.740 --> 01:33.208
đổi kết quả hoặc bất kỳ cách nào bạn muốn đặt tên cho nó và tôi muốn

01:33.208 --> 01:37.240
mô tả điều này bằng một chuỗi. Vì vậy, tôi sẽ đặt cái này

01:37.240 --> 01:41.122
thành kiểu chuỗi. Bây giờ ý tưởng của tôi là

01:41.122 --> 01:45.625
tôi có thể gọi kết hợp ở đây với hai số và ví dụ: chuyển vào một

01:45.625 --> 01:50.625
chuỗi "dưới dạng số" và việc bạn sử dụng mã định danh nào ở đây hoàn

01:50.630 --> 01:55.630
toàn tùy thuộc vào bạn. Ở dưới đó, chúng tôi có thể có "dưới

01:56.260 --> 01:59.357
dạng văn bản" nhưng sau đó chúng tôi có thể có

02:02.910 --> 02:07.310
một kết hợp khác ở đây CombineStringAges nơi tôi chuyển vào hai

02:07.310 --> 02:10.030
chuỗi nhưng tôi vẫn muốn xuất "dưới dạng

02:10.030 --> 02:13.540
số" này và đây sẽ là trường hợp tham số thứ ba có thể

02:13.540 --> 02:17.050
hữu ích để buộc chuyển đổi bởi vì nếu tôi chuyển hai

02:17.050 --> 02:19.950
chuỗi ở đây thông thường, chúng tôi sẽ đưa

02:19.950 --> 02:24.730
nó vào nhánh khác này và nối nó và tôi có thể muốn trả lại chuỗi này dưới

02:24.730 --> 02:29.639
dạng một số để tôi cũng có thể điều khiển nhật ký các tác nhân chuỗi kết

02:29.639 --> 02:34.030
hợp tại đây. Vì vậy, bây giờ chúng ta chỉ cần tính đến các

02:34.030 --> 02:37.512
số nhận dạng này trong hàm của mình bằng cách đưa resultConversion

02:37.512 --> 02:41.730
vào các kiểm tra if của chúng ta. Bây giờ câu hỏi đặt ra là chính

02:41.730 --> 02:45.700
xác thì chúng ta muốn làm gì; chúng tôi muốn đảm bảo

02:45.700 --> 02:49.930
rằng chúng tôi có thể buộc hai chuỗi này được thêm dưới

02:49.930 --> 02:54.012
dạng số hay chúng tôi muốn buộc kết quả bất kể đó là phép

02:54.012 --> 02:58.695
tính toán học hay phép nối chuỗi phải được chuyển đổi thành

02:58.695 --> 03:03.039
văn bản hoặc số. Nếu chúng tôi muốn bắt buộc chuyển

03:03.039 --> 03:05.960
đổi, chúng tôi có thể thêm kiểm tra if tại

03:05.960 --> 03:10.382
đây và kiểm tra xem chuyển đổi kết quả có bằng "dưới dạng số" hay

03:10.382 --> 03:15.340
không và nếu đúng như vậy, tôi muốn trả về kết quả có dấu cộng phía trước

03:15.340 --> 03:18.826
chuyển đổi thành số, phương án thay thế sẽ là parseFloat

03:18.826 --> 03:21.230
chẳng hạn nhưng ở đây tôi sẽ chỉ tính

03:22.800 --> 03:24.420
điểm cộng vì cách này ngắn

03:24.420 --> 03:29.420
hơn một chút và nếu không thì tôi muốn trả về kết quả là String để buộc đầu

03:30.156 --> 03:33.593
ra dưới dạng chuỗi.

03:34.570 --> 03:38.883
Vì vậy, bây giờ chúng tôi thực hiện phép tính dựa trên loại thực mà chúng tôi nhận

03:38.883 --> 03:42.300
được nhưng sau đó chúng tôi chuyển đổi thành kết quả, đó là một

03:42.300 --> 03:46.360
cách để thực hiện điều đó và nếu chúng tôi lưu nó và sau đó chúng tôi biên dịch

03:47.470 --> 03:51.020
tệp này, chúng tôi sẽ thấy đây là kết quả tôi nhận được và chúng tôi

03:51.020 --> 03:54.759
nhận được đầu ra đó ví dụ đối với tổ hợp chuỗi của chúng tôi ở đây bởi vì

03:54.759 --> 03:58.520
như tôi đã nói, bản thân tổ hợp, phép tính có thể nói là được thực hiện

03:58.520 --> 04:02.530
dựa trên loại chúng tôi cung cấp trong đó ở đây là chuỗi nên chúng tôi nối nó

04:02.530 --> 04:05.860
và sau đó chúng tôi chỉ chuyển đổi thành kết quả.

04:05.860 --> 04:09.593
Logic thay thế sẽ là kiểm tra loại ở đây

04:09.593 --> 04:14.320
và thực hiện thao tác khác dựa trên loại trả về mà chúng

04:14.320 --> 04:19.180
tôi chỉ định ở đây. Vì vậy, chúng tôi có thể nhận xét điều

04:19.180 --> 04:22.600
này và thay vào đó, ở đây hãy nói nếu loại đầu vào

04:22.600 --> 04:26.230
một là số và loại đầu vào hai là số hoặc nếu resultConversion

04:27.890 --> 04:30.865
bằng "dưới dạng số" thì tôi muốn kết hợp các

04:30.865 --> 04:35.865
giá trị như thế này và bây giờ để tránh lỗi này, ở đây tôi buộc chuyển đổi

04:35.930 --> 04:38.794
thành số bằng cách thêm dấu cộng vào trước

04:38.794 --> 04:42.970
mỗi đầu vào để mỗi đầu vào được chuyển đổi thành một số và được

04:42.970 --> 04:45.490
đảm bảo là một số trước khi tôi kết hợp

04:45.490 --> 04:48.490
chúng.

04:48.490 --> 04:51.130
Lưu ý bên lề: nếu bạn chuyển vào các chuỗi

04:51.130 --> 04:54.610
không thể chuyển đổi thành số, do đó, chẳng hạn như Max

04:54.610 --> 04:58.800
chẳng hạn, thì kết quả là bạn sẽ nhận được NaN, Không phải là Số.

04:58.800 --> 05:00.280
Vậy thì trong trường hợp

05:00.280 --> 05:03.170
khác, để chúng ta không có "dưới dạng số" hoặc

05:03.170 --> 05:07.976
đơn giản là chúng ta không có đầu vào số, thì chúng ta sẽ đưa nó vào khối này ở đây

05:07.976 --> 05:12.390
và bây giờ với điều đó nếu tôi trả lại kết quả ở đây, và sau đó chúng tôi lưu

05:12.390 --> 05:16.230
cái này và biên dịch lại, chúng tôi sẽ thấy một đầu ra khác trên

05:16.230 --> 05:20.230
trang của chúng tôi. Bây giờ chúng tôi nhận được 56 trong hai

05:20.230 --> 05:22.945
dòng này ở đây bởi vì bây giờ chúng tôi không chuyển đổi

05:22.945 --> 05:26.300
kết quả, vì vậy chúng tôi không chuyển đổi chuỗi nối cho dòng này

05:26.300 --> 05:29.070
mà thay vào đó chúng tôi thực hiện chuyển đổi trước khi

05:29.070 --> 05:31.970
kết hợp hai giá trị. Vì vậy, bạn muốn triển khai logic

05:31.970 --> 05:34.760
nào là tùy thuộc vào bạn. Tôi thực sự muốn xem

05:34.760 --> 05:37.551
xét kỹ hơn về khái niệm loại chữ mà tôi đã

05:37.551 --> 05:41.180
mô tả ở đầu bài giảng này. Tôi đang chuyển "dưới dạng số" và "dưới

05:41.180 --> 05:44.157
dạng văn bản" và những nhược điểm của một doanh nghiệp mà ngay bây

05:44.157 --> 05:47.600
giờ chúng tôi với tư cách là nhà phát triển phải ghi nhớ những giá trị này.

05:47.600 --> 05:50.450
Chúng tôi phải đảm bảo rằng chúng tôi không bỏ lỡ loại ở đây.

05:50.450 --> 05:54.010
Bây giờ chúng tôi có thể sử dụng e-num để cải thiện điều đó nhưng nếu chúng

05:54.010 --> 05:57.754
tôi chỉ có hai giá trị ở đây, "dưới dạng văn bản" hoặc "dưới dạng số", thì

05:57.754 --> 06:00.940
có thể tất cả tìm kiếm một loại chữ có thể là một tùy chọn.

06:00.940 --> 06:04.173
Chúng tôi có thể nói "đây không phải là bất kỳ chuỗi

06:04.173 --> 06:09.173
nào, nó phải là "dưới dạng số" hoặc "dưới dạng văn bản"", vì vậy chúng

06:09.870 --> 06:12.090
tôi sử dụng loại kết hợp kết hợp

06:12.090 --> 06:15.573
với các loại chữ. Các loại chữ là các loại

06:15.573 --> 06:17.987
dựa trên chuỗi loại cốt lõi của bạn,

06:17.987 --> 06:20.933
số, v.v. nhưng sau đó bạn có một phiên bản

06:20.933 --> 06:24.750
cụ thể của loại. Vì vậy, ở đây, chúng tôi cho phép cụ thể hai

06:24.750 --> 06:27.960
chuỗi này chứ không phải bất kỳ chuỗi nào chỉ có hai chuỗi này.

06:27.960 --> 06:31.460
Vì vậy, chúng tôi muốn có một chuỗi để chuyển đổi kết quả, nhưng nó phải là

06:31.460 --> 06:34.207
một trong hai giá trị này. Bất kỳ giá trị chuỗi nào khác

06:34.207 --> 06:37.560
sẽ không được phép, vì vậy đó là ý tưởng đằng sau một loại chữ và

06:37.560 --> 06:40.747
bạn thường sẽ sử dụng giá trị này trong ngữ cảnh của loại kết

06:40.747 --> 06:43.700
hợp vì bạn không chỉ muốn cho phép một giá trị chính xác

06:43.700 --> 06:46.500
mà bạn có thể mã hóa nó vào mã của mình nếu đó là trường

06:46.500 --> 06:49.544
hợp nhưng bạn muốn có hai hoặc nhiều giá trị có thể.

06:49.544 --> 06:52.580
Trong trường hợp này, chúng tôi có hai giá trị có thể.

06:52.580 --> 06:56.240
Vì vậy, bây giờ chúng tôi được đảm bảo nhận được chuyển đổi

06:56.240 --> 07:00.288
kết quả là "dưới dạng số" hoặc "dưới dạng văn bản" và ví dụ ở đây,

07:00.288 --> 07:03.800
Nếu bây giờ tôi thử so sánh điều này với dưới dạng số vì tôi

07:03.800 --> 07:07.256
có lỗi đánh máy ở đây, nhóm loại là có thể cho tôi biết ở

07:07.256 --> 07:10.360
đây trong IDE và tất nhiên tất cả những gì chúng tôi

07:10.360 --> 07:15.360
lưu nó và biên dịch nó ở đây trong thiết bị đầu cuối vì nó biết rằng as-numbe không

07:15.830 --> 07:18.940
có r ở cuối sẽ không bao giờ là giá trị hợp lệ cho resultConversion

07:18.940 --> 07:24.563
vì tôi đã đặt loại kết hợp này với các loại chữ này.

07:25.550 --> 07:27.593
Vì vậy, bây giờ chúng tôi lại đạt được một số loại

07:27.593 --> 07:31.590
an toàn bổ sung và đảm bảo rằng chúng tôi không thể sử dụng loại này một cách sai lầm.

07:31.590 --> 07:34.720
Tất nhiên tương tự để chuyển vào một giá trị. Nếu chúng tôi có lỗi đánh máy ở

07:34.720 --> 07:38.747
đây, chúng tôi chỉ gặp lỗi nếu chúng tôi sử dụng "dưới dạng số" hoặc "dưới dạng

07:38.747 --> 07:41.947
văn bản", chúng tôi được phép biên dịch cái này như bạn thấy

07:41.947 --> 07:45.470
và bây giờ biên dịch cái này, cái này hoạt động và chúng tôi cũng nhận

07:45.470 --> 07:49.562
được đầu ra như trước ở đây. Vì vậy, đây là những loại chữ đặc biệt hữu

07:49.562 --> 07:52.193
ích khi được sử dụng cùng với các loại liên kết.
