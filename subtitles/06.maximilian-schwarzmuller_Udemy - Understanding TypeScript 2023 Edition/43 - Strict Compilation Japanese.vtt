WEBVTT

00:02.120 --> 00:04.960
講師：最初の選択肢として重要だったということですね｡

00:04.960 --> 00:07.520
さて､ これらの厳格なオプションはかなり興味深いので､

00:07.520 --> 00:09.860
掘り下げてみましょう｡

00:09.860 --> 00:12.150
strict trueというオプションがありますが､

00:12.150 --> 00:16.750
実はこのオプションは､ すべての厳密な型チェックオプションを有効にするもので､

00:16.750 --> 00:22.110
これを設定すれば､ これらのオプションを個別に設定したのと同じことになります｡

00:22.110 --> 00:24.830
そのため､ これらのオプションをひとつずつ設定するか､ このオプションだけを設定するか､

00:24.830 --> 00:27.110
どちらかになります｡

00:27.110 --> 00:29.510
もちろん､ いくつかのオプションをfalseに設定したい場合は､

00:29.510 --> 00:33.020
個々のオプションを設定する必要があります｡

00:33.020 --> 00:34.790
なぜなら､ そうでなければ､ すべてtrueに設定されているからです｡ 

00:34.790 --> 00:36.520
もし､ すべてをtrueにしたい場合は､

00:36.520 --> 00:39.290
このオプションだけを使用する方が､ もちろん短時間で済みます｡

00:39.290 --> 00:41.360
しかし､ これらのオプションは何をするものなのでしょうか？

00:41.360 --> 00:43.213
まず､ noImplicitAnyから見ていきましょう｡ 

00:44.282 --> 00:49.180
noImplicitAnyは､ より良いコードを書くために非常に興味深いオプションです｡

00:49.180 --> 00:51.370
解析ファイルに移動して､

00:51.370 --> 00:58.070
sendAnalyticsという関数を追加して､

00:58.070 --> 01:03.430
データオプションを取得します｡

01:03.430 --> 01:07.500
そして､ そのデータでsendAnalyticsを呼び出すので､

01:07.500 --> 01:08.920
文字列で｡

01:08.920 --> 01:11.080
IDEはここで文句を言うし､ コンパイラのTypeScriptも文句を言う｡

01:11.080 --> 01:17.040
この2つはもちろん､ これをコンパイルしようとすればつながっているからだ｡

01:17.040 --> 01:20.070
パラメータデータは､ 暗黙のうちに any 型を持つ｡ 

01:20.070 --> 01:23.940
ということは､ このnoImplicitAnyオプションと関係がありそうです｡

01:23.940 --> 01:29.300
確かに､ これをfalseに設定すると､ つまり､ すべてのstrictオプションをtrueに設定しても､

01:29.300 --> 01:31.521
このオプションをfalseに設定すると､

01:31.521 --> 01:33.810
このエラーは消えます｡

01:33.810 --> 01:37.140
IDEでも､ コンパイルするときでも｡ 

01:37.140 --> 01:38.730
では､ このオプションはどうなっているのでしょうか｡ 

01:38.730 --> 01:44.210
これは､ strict trueのためにもう一度コメントアウトしてオンにしますが､

01:44.210 --> 01:53.020
コードで扱うパラメータや値を明確にしなければならないことを保証します｡

01:53.020 --> 01:56.600
ここでは､ パラメータとして取得するデータの型について､

01:56.600 --> 01:59.930
TypeScriptには何も情報を与えていない｡

01:59.930 --> 02:01.320
そして､ そうすべきなのです｡ 

02:01.320 --> 02:03.800
TypeScriptがこれを推測できるのであれば､

02:03.800 --> 02:05.360
もちろん問題ないのですが､ ここでTypeScriptがこの行からどのように推測できるかというと､

02:05.360 --> 02:12.950
この関数がこのファイルが実行される前に最初に宣言されていることに留意してください｡

02:12.950 --> 02:15.080
そのため､ 関数を作成した時点では､

02:15.080 --> 02:18.380
そこに何が入っているかはわからないのです｡

02:18.380 --> 02:20.100
そこで､ ここでは単純に型を宣言し､

02:20.100 --> 02:24.253
そこでどの型を使うかを明確にすることで､ このエラーを修正することができます｡

02:25.100 --> 02:29.530
ここで､ もし変数が記録されていた場合､ ここでこれをtrueに設定すると､

02:29.530 --> 02:37.670
この宣言はデフォルトのany型を取得してもエラーにならないことに注意してください｡

02:37.670 --> 02:39.250
変数についてはこれでOKです｡ 

02:39.250 --> 02:40.910
パラメータについては､ 大丈夫ではありません｡ 

02:40.910 --> 02:42.480
なぜ変数がOKなのか？

02:42.480 --> 02:44.370
なぜなら､ TypeScriptが変数に対してできることは､

02:44.370 --> 02:48.880
ここでは関数が最初に作られるため､ できないことだからです｡

02:48.880 --> 02:52.490
ここでTypeScriptは､ 割り当てた値を追跡することができます｡ 

02:52.490 --> 02:54.650
ほら､ こうやってここにログを記録して､

02:54.650 --> 02:58.573
今度はそれをtrueに設定しました｡ だから､

02:59.430 --> 03:08.030
以後､ ここにログを記録したコンソールにすると､ それはブール型になるんです｡

03:08.030 --> 03:11.893
つまり､ TypeScriptはコードの流れを理解することができるので､

03:11.893 --> 03:15.430
ここで型について正確に説明する必要はないのです｡

03:15.430 --> 03:20.310
もちろん､ 新しい値を自由に割り当てることができることを避けたいのであれば､

03:20.310 --> 03:22.940
正確を期したいところです｡

03:22.940 --> 03:25.700
そのため､ これを避けるために型を割り当てる必要があるが､

03:25.700 --> 03:31.410
TypeScriptは少なくとも､ 呼び出したコードが現在保持している型と連動するかどうかを調べることができる｡

03:31.410 --> 03:32.410
この場合､ 関数は呼び出す前に定義されているため､

03:32.410 --> 03:41.393
TypeScriptは関数内で渡されたものが使えるかどうかを知ることができない｡

03:43.280 --> 03:46.020
strictNullChecksは決して重要なオプションではありません｡ 

03:46.020 --> 03:49.410
実は､ ここにあるボタンの選択と関係があるんです｡

03:49.410 --> 03:52.670
この感嘆符を付けないとうまくいかないのを覚えておいてください｡

03:52.670 --> 03:54.380
そうでないと､ エラーになるんです｡ 

03:54.380 --> 03:58.430
ここで､ strictNullChecksをfalseに設定することで､

03:58.430 --> 04:02.090
感嘆符を付けずにこのエラーを取り除くことも可能です｡

04:02.090 --> 04:04.200
では､ ここでそうして､ これを保存してみましょう｡ 

04:04.200 --> 04:07.860
そして､ ご覧の通り､ このエラーはここで解消されました｡ 

04:07.860 --> 04:10.120
そして､ すべてのファイルをコンパイルすることができます｡ 

04:10.120 --> 04:12.340
さて､ strictNullChecksは何をするのでしょうか？

04:12.340 --> 04:19.410
これはTypeScriptに､ NULL値を保持する可能性のある値へのアクセスや操作方法について､

04:19.410 --> 04:22.530
かなり厳密に指示するものである｡

04:22.530 --> 04:24.850
そして､ ここのボタンは無効かもしれません｡ 

04:24.850 --> 04:29.210
常にボタン要素を指しているわけではありません｡ 

04:29.210 --> 04:34.220
このようなセレクタがあっても､ このスクリプトが実行されるページにはボタンが存在しないかもしれないので､

04:34.220 --> 04:38.490
常にそのような要素を指しているわけではありません｡

04:38.490 --> 04:43.790
そのため､ TypeScriptはhtmlファイルに潜り込んでそれを見ているわけではないので､

04:43.790 --> 04:44.900
わからないのです｡

04:44.900 --> 04:48.240
これが成功するかどうかはわからない｡ 

04:48.240 --> 04:53.130
そして､ もしこれがポインタとNULLノードを返すことに失敗したら､

04:53.130 --> 04:59.090
NULL､ 正確には未定義を返しますが､ ここでは等しく扱われます｡

04:59.090 --> 05:01.610
そのため､ ボタンにNULL値が格納される可能性があり､

05:01.610 --> 05:03.530
このコードは失敗する可能性があります｡

05:03.530 --> 05:06.610
確かに､ ここのボタンをコメントアウトすると､ 今全部コンパイルすると､

05:06.610 --> 05:08.480
NULLチェックを無効にしているため､

05:08.480 --> 05:10.733
動作します｡

05:12.000 --> 05:14.100
しかし､ 私は､ したがって､ 今､ 私はnullでイベントリスナー､

05:14.100 --> 05:16.210
addEventListenerを呼び出すことができないので､

05:16.210 --> 05:18.230
ランタイムエラーが発生します｡

05:18.230 --> 05:20.970
そして､ ボタンがないからここでヌルヌルになった｡ 

05:20.970 --> 05:26.760
これはstrictNullChecksをtrueに設定することで回避できるミスです｡

05:26.760 --> 05:30.340
そして､ strictをtrueに設定すると､ 自動的に設定されます｡ 

05:30.340 --> 05:34.450
TypeScriptはこのような事態を想定しているので､

05:34.450 --> 05:38.600
その回避を余儀なくされています｡

05:38.600 --> 05:40.640
さて､ この感嘆符の演算子を使えば､

05:40.640 --> 05:42.820
簡単に回避することができます｡

05:42.820 --> 05:46.020
これは､ 開発者であるあなたがこのボタンの存在を知っていること､

05:46.020 --> 05:53.360
あるいはこの操作によって非NULL値が得られることをTypeScriptに伝えるものである｡

05:53.710 --> 05:55.830
HTMLのコードを書いていて､

05:55.830 --> 06:00.430
ここにボタンがあり､ このセレクタが動作することが分かっている場合は､

06:00.430 --> 06:03.310
確かにそうかもしれませんね｡

06:03.310 --> 06:06.623
だから､ このシナリオではエクスクラメーションマークを使っても問題ないだろう｡

06:07.600 --> 06:09.040
もし､ うまくいくかどうかわからないが､

06:09.040 --> 06:21.570
うまくいくことを祈るしかないような場合は､ 失敗するかもしれないコードを単純にifチェックで包む方がよいかもしれません（もちろん､ それは実行時にも存在します）｡

06:21.570 --> 06:27.510
ここで単純にbuttonがtrueかどうかをチェックすることもできますが､ nullやundefinedであればtrueにはなりません｡

06:27.510 --> 06:30.060
そして､ そのコードをこのifチェックの中に移動させます｡ 

06:30.060 --> 06:32.470
感嘆符がなくても､ strictNullChecksモードではエラーが発生しない｡

06:32.470 --> 06:46.310
このコードはこのif文の中にあり､ このif文はbuttonがnullでないことを確認しているので､ 失敗しないとTypeScriptは理解しているからだ｡

06:46.310 --> 06:49.310
だから､ この方が実はきれいな回避策かもしれない｡ 

06:49.310 --> 06:51.060
しかし､ もちろん､ コードを節約するために､

06:51.060 --> 06:58.320
何かが確実に存在することが分かっている場合は､ 感嘆符を使う方が短く､ 全く問題ない選択肢です｡

06:58.320 --> 07:00.450
ここでは､ 両方が見えるように両方と言いましたが､

07:00.450 --> 07:04.520
もちろん､ ifチェックか感嘆符のどちらか一方があればいいのです｡

07:04.520 --> 07:07.680
strictFunctionTypesは､

07:07.680 --> 07:12.010
多くのアプリケーションで使用されていないニッチなボックスをキャッチする､

07:12.010 --> 07:14.830
少し高度な設定です｡

07:14.830 --> 07:18.380
それは､ まあ､ 設定する可能性のあるファンクションタイプに関係するものです｡

07:18.380 --> 07:23.690
関数の中の型ではなく､ 関数のパラメータと戻り値に関してどのように見えるかを定義して､

07:23.690 --> 07:27.840
基礎モジュールで学んだそのような関数型を作成すると､

07:27.840 --> 07:32.650
クラスと継承を扱う場合にボックスを導入することができますが､

07:32.650 --> 07:39.683
まだ学んでいないし､ 使っていないので､ 今はこれを無視しましょう｡

07:40.578 --> 07:43.630
strictBindCallApplyは､ bind､

07:43.630 --> 07:46.840
call､ applyを使った作業をする場合に便利です｡

07:46.840 --> 07:49.680
そのために､ さっそく例を見てみましょう｡ 

07:49.680 --> 07:52.040
ここでは､ ボタンと関数を用意しました｡ 

07:52.040 --> 07:57.040
ここで､ 関数､ つまりfunctionキーワードで定義する関数､

07:57.780 --> 08:01.100
あるいはエラー関数を考えてみましょう｡

08:01.100 --> 08:03.650
どうでもいいことだが､ ここでは関数キーワードを使うことにする｡ 

08:04.731 --> 08:09.731
clickHandlerを作成し､ その中でコンソールしています｡  ログがクリックされました｡ 

08:11.960 --> 08:15.560
そして､ ここではclickHandlerを指しています｡

08:15.560 --> 08:17.670
何らかの理由で､ この実行時に特定の引数を渡すか､

08:17.670 --> 08:22.780
このキーワードに特定の値を設定することを確認したいのです｡

08:22.780 --> 08:28.110
ここで､ 引数として文字列であるはずのmessageを期待するとします｡

08:28.110 --> 08:32.110
そして､ これをここにも出力したい｡ 

08:32.110 --> 08:36.010
clickHandlerはaddEventListenerに渡され､

08:36.010 --> 08:41.070
ブラウザが基本的にこれを実行してくれるので､ 渡される引数を事前に設定したい場合は､

08:41.070 --> 08:43.570
bindを使用します｡

08:43.570 --> 08:49.320
そして､ bindは､ 第一引数として､ このキーワードを束ねたいものを受け取ります｡

08:49.320 --> 08:53.580
ここでは､ 関数内でこれを使用しないので関係ないと言うことができ､

08:53.580 --> 08:55.930
nullにバインドしています｡

08:55.930 --> 08:57.700
ここで､ エラーが発生することがお分かりになると思います｡ 

08:57.700 --> 09:04.613
strictBindCallApplyをfalseに設定すると回避できるエラーが発生するのですが｡

09:07.040 --> 09:08.680
これで､ エラーが消えたのがわかりますね｡ 

09:08.680 --> 09:10.501
さて､ それではこのオプションはどうなっているのでしょうか｡ 

09:10.501 --> 09:16.020
基本的には､ bind､ call､ applyのどの関数を呼び出しているかをチェックします｡

09:16.020 --> 09:20.080
そして､ ここで設定したことが意味を持つかどうかをチェックします｡ 

09:20.080 --> 09:23.440
そしてここでTypeScriptは､ 引数が欲しい､ clickHandlerにパラメータが欲しい､

09:23.440 --> 09:25.450
と判断する｡

09:25.450 --> 09:28.260
bindでは､ そのような設定はしていませんが｡ 

09:28.260 --> 09:30.600
そのため､ ここではエラーが発生します｡ 

09:30.600 --> 09:32.180
これをtrueに戻すと､ あるいはコメントアウトすると､

09:32.180 --> 09:36.230
もちろんstrictをtrueに設定することでデフォルトでtrueに設定されているので､

09:36.230 --> 09:39.790
したがって､ 再びエラーが発生するのです｡

09:39.790 --> 09:46.200
もしここで引数を期待しないのであれば､

09:46.200 --> 09:54.760
メッセージを削除するだけでエラーはなくなる｡

09:54.760 --> 09:57.420
しかし､ もちろん､ ここでは1つ欲しいので､ エラーになります｡ 

09:57.420 --> 10:04.350
解決策は､ この2番目の引数を指定することです｡

10:04.350 --> 10:06.290
ここでTypeScriptは実に賢い｡ 

10:06.290 --> 10:08.120
また､ 例えば数値を渡したとしても､ ここでは文字列が必要だと理解しているので､

10:08.120 --> 10:11.610
文句を言われることはない｡

10:12.500 --> 10:15.960
しかし､ you're welcomeのような正しい文字列を渡すと､

10:15.960 --> 10:17.350
もう文句は言われない｡

10:17.350 --> 10:19.070
なぜなら､ これは理解できないし､

10:19.070 --> 10:24.840
これが私の関数定義と一致していることがわかるからだ｡

10:24.840 --> 10:30.260
このように､ bind､ call､ applyを誤って自分のコードと相性の悪い方法で使ってしまわないようにするための､

10:30.260 --> 10:32.743
とても便利な動作です｡

10:33.930 --> 10:37.810
さて､ strictPropertyInitializationは､ クラスを扱うようになってから重要になる｡

10:37.810 --> 10:39.213
とりあえず無視すればいいんです｡ 

10:39.213 --> 10:41.890
noImplicitこれも今は関係ない｡ 

10:41.890 --> 10:43.650
これはthisキーワードと関係があり､

10:43.650 --> 10:51.020
TypeScriptは基本的にthisキーワードが何を指しているのかわからない場所で使用すると警告を出そうとします｡

10:51.020 --> 10:53.210
また､ alwaysStrict は､ 生成される

10:53.210 --> 10:55.560
JavaScript ファイルが strict モードを使用していることを制御するだけなので､

10:55.560 --> 10:58.663
これが追加されます｡

10:59.710 --> 11:02.383
それをもって､ これらの厳しい選択肢をすべて網羅したのです｡ 
