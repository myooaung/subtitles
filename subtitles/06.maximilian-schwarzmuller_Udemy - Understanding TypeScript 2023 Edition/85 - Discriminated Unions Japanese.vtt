WEBVTT

00:02.210 --> 00:05.753
ナレーター：さて､ 特殊なタイプのタイプガードとでも言いましょうか､

00:05.753 --> 00:10.000
タイプガードに役立つものに､ 差別的結合があります｡

00:10.000 --> 00:11.300
さて､ それは何でしょう｡ 

00:11.300 --> 00:15.030
これは､ ユニオン型を扱うときに使えるパターンで､

00:15.030 --> 00:18.900
タイプガードの実装を容易にするものです｡

00:18.900 --> 00:22.000
オブジェクトタイプを扱うときに利用できます｡ 

00:22.000 --> 00:24.580
その仕組みを紹介しよう｡ 

00:24.580 --> 00:26.850
いくつかのインターフェイスがあるとします｡ これはクラスでも構いませんが､

00:26.850 --> 00:32.193
ここではインターフェイスでも動作することを示すためにインターフェイスを使用します｡

00:33.170 --> 00:34.803
そして､ そこには私の鳥がいます｡

00:36.480 --> 00:40.973
鳥は飛行速度を持っていて､ それは例えば数字タイプであるべきです｡

00:42.660 --> 00:45.890
そして､ 私の馬にも地力や走力があり､

00:45.890 --> 00:51.913
これは型番のはずです｡

00:53.130 --> 00:55.430
そこで､ この2つのインターフェースを用意しました｡ 

00:55.430 --> 00:59.633
ここで､ 独自のユニオンタイプであるanimalを作成します｡

01:00.750 --> 01:03.370
これは､ 鳥か馬のどちらかです｡

01:03.370 --> 01:05.743
そして､ 先ほどと同じように､

01:06.740 --> 01:08.480
move animalという関数があり､

01:09.800 --> 01:14.800
入力として動物を受け取る｡

01:14.800 --> 01:25.180
そして､ その中で､ スピードで動くと言いたいのですが､ もちろん､ 飛ぶスピードか走るスピードのどちらかにアクセスする必要があります｡

01:25.180 --> 01:27.730
今ならもちろん､ スピードと名付けることもできたでしょう｡ 

01:27.730 --> 01:30.840
しかし､ これは実際の使用例を単純化したもので､

01:30.840 --> 01:40.500
ある種の関連性を持ちながらも異なるプロパティやメソッドを持つインターフェースやオブジェクトが一般に存在する場合です｡

01:40.500 --> 01:42.050
で､ ここでは､ スピードのプロパティですが､

01:42.050 --> 01:43.900
実はこれが違うんです｡

01:43.900 --> 01:46.780
もちろん､ すべての動物が飛行速度を持っているわけではないので､

01:46.780 --> 01:49.240
ここで飛行速度にアクセスすることはできないのです｡

01:49.240 --> 01:51.210
今､ 私たちは以前学んだことを実行することができます｡ 

01:51.210 --> 01:56.063
ここでは､ 飛行速度が動物にあるかどうかを確認することができます｡ 

01:58.240 --> 02:01.063
そして､ その場合は､ このコードを実行すればよいのです｡ 

02:01.960 --> 02:04.470
しかし､ 動物が増えれば増えるほど､

02:04.470 --> 02:09.233
確認しなければならないことが増えていきます｡

02:10.880 --> 02:14.100
また､ この文字列のここにミスタイプすることもあります｡ 

02:14.100 --> 02:18.460
例えばEを忘れて､ どうしてこれがうまくいかないんだろうと思うことがあります｡

02:18.460 --> 02:20.410
さて､ ここでinstance ofを使うわけにはいかない｡

02:20.410 --> 02:22.570
なぜなら､ 私はインターフェイスを壊しているからだ｡

02:22.570 --> 02:29.680
説明したように､ birdのanimalインスタンスは､ dataがJavaScriptにコンパイルされていないインターフェースであるため､

02:29.680 --> 02:31.840
動作しないのです｡

02:31.840 --> 02:36.210
そのため､ 実行時にはコンストラクタ関数として利用することはできません｡

02:36.210 --> 02:37.690
ですから､ したがって､ これはうまくいきません｡ 

02:37.690 --> 02:42.460
あとは､ あらゆるインターフェースを与えることで､ ここに差別的な組合を構築することができます｡

02:42.460 --> 02:45.380
だから､ ユニオンの一部であるべきすべてのオブジェクト､

02:45.380 --> 02:47.130
および余分なプロパティ｡

02:47.130 --> 02:48.640
好きな名前を使うことができます｡ 

02:48.640 --> 02:51.490
ここではkindやtypeを使うことが多いですね｡ 

02:51.490 --> 02:55.090
この鳥に名前をつけて､ タイプでいこうと思います｡ 

02:55.090 --> 02:57.480
さて､ 重要なのは､ ここでインターフェイスを取引していることです｡ 

02:57.480 --> 03:02.480
ですから､ これは実はtypeプロパティの値ではありません｡ 

03:02.650 --> 03:05.410
これは代わりに､ あなたが学んだようにリテラル型であり､ typeは文字列を保持しなければならず､

03:05.410 --> 03:09.110
それはbirdでなければならないのです｡

03:09.110 --> 03:10.880
つまり､ これは型の割り当てで､

03:10.880 --> 03:17.590
型に格納される可能性のある値を､ まさにこの文字列の値に絞り込んでいるのです｡

03:17.590 --> 03:19.810
そして､ horseについても同じように､

03:19.810 --> 03:22.283
horseをリテラル型として使用します｡

03:23.400 --> 03:27.550
ここで､ この関数の中でswitch文を使い､

03:27.550 --> 03:32.280
動物のドットタイプを切り替えることができます｡

03:32.280 --> 03:34.080
動物を構成するすべてのインターフェースにtypeプロパティを追加したため､

03:34.080 --> 03:38.350
すべての動物がtypeプロパティを持つようになりました｡

03:38.350 --> 03:40.730
TypeScriptとIDEが､

03:40.730 --> 03:44.990
typeはbirdかhorseのどちらかしかないと理解しているため､

03:44.990 --> 03:49.040
自動補完されるケースもいくつかあるのです｡

03:49.040 --> 03:51.050
また､ 鳥であれば､ 内部で何らかの可変速を設定して､

03:51.050 --> 04:02.250
たとえば動物ドットの飛行速度にして､ それ以降はブレークさせればいいわけです｡

04:02.250 --> 04:05.183
それ以外の場合は､ 馬の場合､

04:06.830 --> 04:11.753
動物のドット走行速度に等しい速度を設定する｡

04:14.150 --> 04:20.843
そして､ その後にコンソールログ､ 速度プラス速度で移動することができます｡

04:22.490 --> 04:26.540
ここで､ その場で作成した動物で動物を動かすと､

04:26.540 --> 04:30.300
タイプを鳥にして､ 鳥か馬しか使えないようにして､

04:30.300 --> 04:32.810
飛行速度を設定しなければならないのですが､

04:32.810 --> 04:34.930
ところで､ TypeScriptは､

04:36.140 --> 04:39.210
ここで走行速度という概念を認識して､

04:39.210 --> 04:48.980
これを10に設定しようとすると､ これは鳥タイプでは使えないと文句を言ってきます｡

04:48.980 --> 04:51.360
飛行速度に設定すれば､ どんなにうまくいっても､

04:51.360 --> 04:57.700
それを保存すれば､ このように正しく出力され､ また､ エラーなくコンパイルされるのです｡

04:57.700 --> 04:59.530
なぜなら､ このユニオンを構成するすべてのオブジェクトには､

04:59.530 --> 05:04.060
そのオブジェクトを説明する共通のプロパティが1つあるからです｡

05:04.060 --> 05:11.490
このオブジェクトを説明するプロパティをチェックに使用することで､ 100%の型安全性を確保し､

05:11.490 --> 05:21.930
そのオブジェクトで使用できるプロパティとできないプロパティを理解することができます｡

05:21.930 --> 05:24.500
これは､ オブジェクトやユニオン型を扱うときに使える､

05:24.500 --> 05:28.060
斬新で便利なパターンです｡

05:28.060 --> 05:30.340
さらに､ このインターフェースは､ このインターフェースに基づいて構築されたすべてのオブジェクトに､

05:30.340 --> 05:37.050
この型を強制的に与えるので､ インターフェースでも機能します｡

05:37.050 --> 05:39.400
そこで､ あるプロパティの存在を確認する代わりに､

05:39.400 --> 05:41.200
あるいはinstance ofを使う代わりに､

05:41.200 --> 05:43.660
存在することが分かっているプロパティを使って､

05:43.660 --> 05:49.020
どのタイプのオブジェクトを扱っているのかを確認します｡

05:49.020 --> 05:51.930
TypeScriptは､

05:51.930 --> 05:58.480
動物型にはbirdとhorseしかないことを理解しているので､

05:58.480 --> 06:04.690
誤入力の危険性も排除しています｡

06:04.690 --> 06:09.333
したがって､ これはオブジェクトやユニオン型を扱う際に非常に有効なパターンである｡
