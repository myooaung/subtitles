WEBVTT

00:02.350 --> 00:04.170
講師：では､ TypeScriptとは何でしょうか？

00:04.170 --> 00:06.860
どんなものなのか､ なぜ使うのか？

00:06.860 --> 00:10.820
TypeScriptは､ JavaScriptのスーパーセットです｡ 

00:10.820 --> 00:12.190
さて､ これはどういうことでしょうか｡ 

00:12.190 --> 00:14.250
つまり､ TypeScriptは結局のところ､

00:14.250 --> 00:16.370
JavaScriptの上に構築された言語､

00:16.370 --> 00:18.710
プログラミング言語なのです｡

00:18.710 --> 00:20.940
新しい言語というわけではなく､

00:20.940 --> 00:27.450
JavaScriptをベースに新しい機能や利点を追加したものです｡

00:27.450 --> 00:31.720
JavaScriptのコードをより簡単に､ より強力に書けるようになる､

00:31.720 --> 00:32.840
と言えるでしょう｡

00:32.840 --> 00:35.624
しかし､ 1つだけ大きな欠点があります｡ 

00:35.624 --> 00:41.760
TypeScriptは､ ブラウザなどのJavaScript環境では実行できない｡

00:41.760 --> 00:44.270
ブラウザはTypeScriptを実行できないし､

00:44.270 --> 00:48.486
例えばNode. jsもTypeScriptを実行できないので､

00:48.486 --> 00:54.080
JavaScriptを実行できる環境はTypeScriptに対応していません｡

00:54.080 --> 00:56.140
では､ TypeScriptはどのような考え方で作られているのでしょうか｡ 

00:56.140 --> 01:00.760
JavaScriptの改良版なのに､ 使えないの？

01:00.760 --> 01:02.130
まあ､ そうでもないんですけどね｡ 

01:02.130 --> 01:06.050
TypeScriptはプログラミング言語でありながら､ ツールでもある｡ 

01:06.050 --> 01:14.410
これは､ TypescriptのコードをJavaScriptにコンパイルするために実行される強力なコンパイラです｡

01:14.410 --> 01:16.540
つまり､ TypeScriptでコードを書いたときに結果として得られるのは､

01:16.540 --> 01:20.260
JavaScriptなのです｡

01:20.260 --> 01:22.870
しかし､ あなたはそのJavaScriptのコードを書かず､

01:22.870 --> 01:24.900
すべての新機能とすべての利点を備えたTypeScriptのコードを書き､

01:24.900 --> 01:30.670
普通のJavaScriptのコードを手に入れることができます｡

01:30.670 --> 01:33.810
最終的に得られるものが通常のJavaScriptであるなら､

01:33.810 --> 01:40.630
TypeScriptはどのようにして新しい機能を追加できるのでしょうか？

01:40.630 --> 02:02.060
その答えは､ TypeScriptコンパイラがこれらの新機能をJavaScriptの回避策にコンパイルしてくれるからです｡

02:02.060 --> 02:08.610
もちろん､ JavaScript言語でまったく不可能なことを追加することはできませんが､

02:08.610 --> 02:11.150
単純に使いやすい､ 構文がきれい､

02:11.150 --> 02:15.020
といった新しい機能を追加することはできます｡

02:15.020 --> 02:17.470
さらに､ TypeScriptは､ もちろん､

02:17.470 --> 02:20.900
その名前からすでに想像できる重要なことを一つしています｡

02:20.900 --> 02:28.750
この機能は､ スクリプトが実行されてブラウザでエラーが発生する前に､

02:28.750 --> 02:41.350
開発者としてコードのエラーを早期に発見する機会を与えてくれるものなのです｡

02:41.350 --> 02:46.690
そのため､ 新しい機能やより優れた方法を提供するだけでなく､

02:46.690 --> 02:54.153
エラーチェックを強化し､ 通常ならランタイムエラーとして発生するエラーを開発中に早期に発見し､

02:54.153 --> 02:58.370
修正することができるのです｡

02:58.370 --> 03:00.600
では､ なぜTypeScriptを使うのでしょうか｡ 

03:00.600 --> 03:06.710
この例では､ 2つの数値を足すという非常にシンプルなJavaScriptの関数を考えてみましょう｡

03:06.710 --> 03:11.810
さて､ これを呼び出すとき､ 2つの数値の代わりに2つの文字列を渡していることに注目してください｡

03:11.810 --> 03:14.810
このようなことが現実的に起こりうる実際の例を､

03:14.810 --> 03:18.090
すぐにお見せしましょう｡

03:18.090 --> 03:22.519
なぜなら､ 2つの文字列を追加すると､

03:22.519 --> 03:32.780
JavaScriptは数学的な計算を行う代わりに文字列を連結するからです｡

03:32.780 --> 03:38.980
つまり､ 結果は5ではなく､ 2つの数字を連結した文字列の23になる｡

03:38.980 --> 03:41.690
これはJavaScriptで起こりうるエラーです｡

03:41.690 --> 03:43.530
技術的なエラーではないので､

03:43.530 --> 03:49.832
おそらく実行時エラーにはなりませんが､ コードの中に論理的な間違いがあります｡

03:49.832 --> 03:55.870
そしてそれは､ もちろん､ JavaScriptで書いているWebアプリケーションに大きな問題をもたらす可能性があります｡

03:55.870 --> 03:59.360
もちろん､ JavaScriptには緩和策があります｡

03:59.360 --> 04:02.541
関数内にifチェックを追加して､

04:02.541 --> 04:15.840
実行時に入力の型をチェックしたり､ ユーザーの入力を検証してサニタイズしたりすることができます｡

04:15.840 --> 04:19.220
そしてありがたいことに､ これはTypeScriptで可能です｡ 開発者はここに無効なコードを書き､

04:19.220 --> 04:23.970
JavaScriptでこのようなボットを導入することができます｡ TypeScriptでは､

04:23.970 --> 04:30.060
より良いコードを書き､ このような問題を回避するためのツールを用意しています｡

04:30.060 --> 04:31.910
では､ もう少し詳しく見てみましょう｡ 
