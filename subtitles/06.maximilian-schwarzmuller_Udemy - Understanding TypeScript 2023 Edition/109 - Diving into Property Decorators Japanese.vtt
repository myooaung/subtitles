WEBVTT

00:02.250 --> 00:05.050
インストラクター：さて､ もっと便利な使用例やデコレーターのシナリオを探る前に､

00:05.050 --> 00:07.811
いくつかのデコレーターを紹介します｡

00:07.811 --> 00:12.550
デコレーターを追加できる他の場所を簡単に紹介したいと思います｡

00:12.550 --> 00:17.731
もちろん､ クラスにデコレータを追加することはできますが､ デコレータを追加できる場所はもっとたくさんあります｡

00:17.731 --> 00:22.460
そのために新しいクラスを作ります｡ 使いたいデコレータのためのクラスが必要ですが､

00:22.460 --> 00:26.420
すべてのデコレータを直接クラスに追加する必要はありません｡

00:26.420 --> 00:28.480
例えば､ ここに商品クラスがあり､

00:28.480 --> 00:31.523
商品クラスの中にタイトルがあるとします､

00:31.523 --> 00:34.540
これは文字列です｡

00:34.540 --> 00:37.070
そして､ ここにコンストラクタで値を代入することができます｡ 

00:37.070 --> 00:42.680
もちろん､ ショートカットを使って､ 先に学習したようにコンストラクタで一度にすべてを行うこともできます｡

00:42.680 --> 00:44.451
ここでは､ 長い道のりを歩むことにします｡ 

00:44.451 --> 00:49.451
ここで､ 税込み価格を出すという方法があります｡ 

00:50.150 --> 00:53.442
そのために､ 私は数字である税率を得ることを期待し､ それが機能するために､

00:53.442 --> 00:57.150
ここに価格も保存する必要があります｡

00:57.150 --> 01:01.200
コンストラクタの一部として取得するPriceプロパティ｡ 

01:01.200 --> 01:04.060
ここでもショートカットを使うことができますが､

01:04.060 --> 01:05.340
このようにします｡

01:05.340 --> 01:08.120
そして､ このメソッドでは､

01:08.120 --> 01:13.120
This.を返します｡ 価格×1＋税

01:13.200 --> 01:15.300
このユーティリティ・メソッドに､

01:15.300 --> 01:19.090
ゲッターとセッターを追加することもできます｡

01:19.090 --> 01:22.700
例えば､ ここに価格のセッターを追加して､ 数値であるはずの値を取得し､

01:22.700 --> 01:28.231
特定の値しか設定できないように制御することができます｡

01:28.231 --> 01:32.090
ここで､ priceの名前をアンダースコアにして､

01:32.090 --> 01:37.540
直接アクセスできないようにプライベートにします｡

01:37.540 --> 01:39.970
そしてここでは､ このアンダースコアの価格を設定し､

01:39.970 --> 01:42.580
このアンダースコアの価格を使用することにします｡

01:42.580 --> 01:48.350
そして､ このセッターの変更により､ このアンダースコアの価格と取得した値を等しく設定することができるようになりました｡

01:48.350 --> 01:51.290
しかし､ その前に値が0より大きいかどうかをチェックし､

01:51.290 --> 01:55.630
負の価格を受け入れないようにすることができます｡

01:55.630 --> 01:57.220
つまり､ 価格がゼロより大きい場合のみ設定し､

01:57.220 --> 02:00.159
そうでない場合は何もしないのです｡

02:00.159 --> 02:04.330
確かに､ 他のケースではエラーを投げることができました｡ 

02:04.330 --> 02:08.389
無効な価格を正とする｡ 

02:08.389 --> 02:11.350
これで､ 2つのプロパティとアクセサ､

02:11.350 --> 02:18.570
そしてメソッドを持つクラスができあがりました｡

02:18.570 --> 02:21.180
さて､ これらすべてにデコレーターを追加することができます｡

02:21.180 --> 02:25.910
まずは昔からの友人であるログデコレーターから始めましょう｡

02:25.910 --> 02:28.960
なぜなら､ このログ・デコレーターはクラスに追加されないので､

02:28.960 --> 02:33.770
異なる引数を取得することになるからです｡

02:33.770 --> 02:35.671
しかし､ これは引数を取得します｡

02:35.671 --> 02:40.030
どの引数を取得するかは､ デコレータを追加する場所に依存します｡

02:40.030 --> 02:41.960
というのも､ loggerはクラスでのみ動作するように微調整されているため､

02:41.960 --> 02:45.700
再利用できないのです｡

02:45.700 --> 02:48.100
ここではデコレータ・ファクトリーを使わず､

02:48.100 --> 02:49.980
このように関数をデコレートするだけですが､

02:49.980 --> 02:55.230
それでも､ このデコレータ関数がどの引数を取得するかは､ 使う場所に依存します｡

02:55.230 --> 02:58.750
例えば､ あるプロパティにデコレータを追加することができます｡ 

02:58.750 --> 03:01.120
ここでは､ このようにログを追加することができます｡

03:01.120 --> 03:05.759
プロパティにデコレータを追加すると､ デコレータは2つの引数を受け取ります｡

03:05.759 --> 03:09.830
最初の引数は､ プロパティのターゲットで､ このようなインスタンスプロパティでは､

03:09.830 --> 03:15.290
それを扱う場合はインスタンスで呼び出します｡

03:15.290 --> 03:19.490
作成されたオブジェクトのプロトタイプとなる｡ 

03:19.490 --> 03:24.850
もし､ ここに静的なプロパティがあれば､ targetはコンストラクタ関数の状態を参照することになります｡

03:24.850 --> 03:27.770
つまり､ どのような構造を持つオブジェクトなのか､ 正確には分からないので､

03:27.770 --> 03:30.140
ここでは「どれでもいい」と言うことにします｡

03:30.140 --> 03:35.140
第2引数として取得するのは､ 単純にプロパティ名です｡ 

03:35.290 --> 03:37.682
ここでは文字列の場合もあるし､

03:37.682 --> 03:40.400
もちろん記号の場合もある｡

03:40.400 --> 03:43.470
プロパティの識別子として何を使うのかがわからない｡ 

03:43.470 --> 03:55.980
そして､ ここではlogプロパティ・デコレーターを使用し､ この処理が実行されたときにコンソールを表示するようにします｡

03:55.980 --> 03:55.980
ログターゲット､ およびプロパティ名を指定します｡ 

03:55.980 --> 03:57.780
この2つの値の中身がわかるように｡ 

03:57.780 --> 04:01.280
この状態で､ エラーなしでコンパイルできるように保存し､

04:01.280 --> 04:06.871
サーバーに移動すると､ プロパティ・デコレーターが表示されていることが確認できます｡

04:06.871 --> 04:08.630
そして､ これが私たちが得た出力です｡ 

04:08.630 --> 04:15.850
ここでは､ タイトルと価格が表示されていないので､ これがオブジェクトのプロトタイプであることがわかります｡

04:15.850 --> 04:18.160
しかし､ get price with taxを見ると､

04:18.160 --> 04:21.900
確かにオブジェクトのプロトタイプにメソッドが登録されていることがわかる｡

04:21.900 --> 04:24.240
これがオブジェクトのプロトタイプで､

04:24.240 --> 04:28.943
右側にタイトルが表示されていますが､ これが現在作業中のプロパティ名です｡

04:29.800 --> 04:33.770
さて､ このロガーは一体いつ実行されるのでしょうか？

04:33.770 --> 04:37.880
まあ､ お察しの通り､ プロダクトをインスタンス化することはないので､

04:37.880 --> 04:43.980
基本的にはJavaScriptでクラス定義が登録された時点で実行されます｡

04:43.980 --> 04:52.970
つまり､ このプロパティをJavaScriptで定義したときに実行されるわけです｡

04:52.970 --> 04:54.610
それが､ 最終的にここで生み出されるのです｡ 

04:54.610 --> 04:58.053
このとき､ このプロパティ・デコレーターは実行されます｡ 
