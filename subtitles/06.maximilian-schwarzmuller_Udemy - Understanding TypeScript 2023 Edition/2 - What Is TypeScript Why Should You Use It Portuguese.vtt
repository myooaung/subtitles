WEBVTT

00:02.350 --> 00:04.170
Instrutor: Então o que é TypeScript?

00:04.170 --> 00:06.860
Do que se trata, por que o usaríamos?

00:06.860 --> 00:10.820
O TypeScript é um Superset JavaScript.

00:10.820 --> 00:12.190
Agora, o que isso significa?

00:12.190 --> 00:14.250
Isso significa que o TypeScript é, no final,

00:14.250 --> 00:16.370
uma linguagem, uma linguagem de programação,

00:16.370 --> 00:18.710
construída em JavaScript.

00:18.710 --> 00:20.940
Não é uma linguagem totalmente nova,

00:20.940 --> 00:23.980
ao invés disso, ela pega a linguagem JavaScript e

00:23.980 --> 00:27.450
acrescenta novas características e vantagens a ela.

00:27.450 --> 00:31.720
Ele torna a escrita do código JavaScript mais fácil e mais poderosa,

00:31.720 --> 00:32.840
pode-se dizer.

00:32.840 --> 00:35.624
Mas, temos uma enorme desvantagem.

00:35.624 --> 00:39.786
O TypeScript não pode ser executado por ambientes JavaScript,

00:39.786 --> 00:41.760
como o navegador.

00:41.760 --> 00:44.270
Os navegadores não podem executar TypeScript,

00:44.270 --> 00:48.486
e por exemplo, Node. js também não pode executar TypeScript,

00:48.486 --> 00:52.250
portanto, os ambientes onde podemos executar JavaScript não

00:52.250 --> 00:54.080
suportam TypeScript.

00:54.080 --> 00:56.140
Qual é então a idéia por trás do TypeScript?

00:56.140 --> 01:00.760
É uma versão melhor do JavaScript e não podemos usá-lo?

01:00.760 --> 01:02.130
Bem, não é bem assim.

01:02.130 --> 01:06.050
O TypeScript é uma linguagem de programação, mas também é uma ferramenta.

01:06.050 --> 01:10.049
É um compilador poderoso, que você corre por cima de seu

01:10.049 --> 01:14.410
código para compilar seu código digitado em JavaScript.

01:14.410 --> 01:16.540
Portanto, o que você obtém como resultado

01:16.540 --> 01:20.260
ao escrever código em TypeScript é o JavaScript.

01:20.260 --> 01:22.870
Mas você não escreveu aquele código JavaScript,

01:22.870 --> 01:24.900
você escreveu código TypeScript com

01:24.900 --> 01:27.480
todas as novas características e todas as vantagens,

01:27.480 --> 01:30.670
e você recebe o código JavaScript normal.

01:30.670 --> 01:33.810
Bem, isso naturalmente levanta uma questão importante,

01:33.810 --> 01:36.710
como o TypeScript pode adicionar novas funcionalidades

01:36.710 --> 01:40.630
se o que você obtém no final é JavaScript regular?

01:40.630 --> 01:43.460
E a resposta é que o compilador TypeScript compila

01:43.460 --> 01:47.710
essas novas funcionalidades para o JavaScript, de modo que no final ele

01:47.710 --> 01:50.670
pode lhe dar uma sintaxe mais agradável, uma maneira

01:50.670 --> 01:52.890
mais fácil de fazer algo, e então compilará

01:52.890 --> 01:56.571
essa maneira mais agradável, mais fácil para um trecho mais

01:56.571 --> 01:59.820
complexo de JavaScript, que você teria que escrever

01:59.820 --> 02:02.060
de outra forma.

02:02.060 --> 02:03.230
Portanto, não é mágico,

02:03.230 --> 02:06.790
claro que não pode adicionar o que não é possível na linguagem JavaScript,

02:06.790 --> 02:08.610
mas pode adicionar novas características

02:08.610 --> 02:11.150
que simplesmente são mais fáceis de usar, uma

02:11.150 --> 02:15.020
sintaxe mais agradável, coisas como esta.

02:15.020 --> 02:17.470
Além disso, o TypeScript, naturalmente,

02:17.470 --> 02:20.900
faz uma coisa importante, que o nome já implica.

02:20.900 --> 02:22.740
Ele adiciona tipos, acrescenta

02:22.740 --> 02:26.230
um recurso à linguagem JavaScript, no qual teremos uma

02:26.230 --> 02:28.750
visão detalhada em um segundo, o que na verdade

02:28.750 --> 02:31.541
lhe dará como desenvolvedor, uma oportunidade

02:31.541 --> 02:35.070
de identificar erros em seu código mais cedo antes que

02:35.070 --> 02:38.480
seu script seja executado e o erro ocorra em tempo de execução

02:38.480 --> 02:41.350
no navegador.

02:41.350 --> 02:44.320
Assim, ele não apenas lhe dá algumas novas características

02:44.320 --> 02:46.690
e maneiras mais agradáveis de fazer algo,

02:46.690 --> 02:50.240
mas também lhe dá uma verificação extra de erros onde erros que,

02:50.240 --> 02:54.153
de outra forma, você obteria como erros de tempo de execução podem ser

02:54.153 --> 02:58.370
pegos e corrigidos antecipadamente durante o desenvolvimento.

02:58.370 --> 03:00.600
Então, por que usaríamos o TypeScript?

03:00.600 --> 03:02.570
Considere este exemplo, uma função

03:02.570 --> 03:06.710
JavaScript bastante simples que acrescenta dois números.

03:06.710 --> 03:08.760
Agora quando eu chamo isso, por favor

03:08.760 --> 03:11.810
note que estou passando em duas cordas em vez de dois números,

03:11.810 --> 03:14.810
e vou lhe mostrar um exemplo real onde algo assim poderia

03:14.810 --> 03:18.090
acontecer realisticamente em apenas um segundo.

03:18.090 --> 03:20.270
Portanto, estamos chamando esta função

03:20.270 --> 03:22.519
com duas cordas e como resultado o que você

03:22.519 --> 03:25.260
obteria aqui é provavelmente um comportamento indesejado,

03:25.260 --> 03:27.240
porque se você adicionar duas cordas,

03:27.240 --> 03:29.596
o JavaScript irá concatenar as cordas em vez

03:29.596 --> 03:32.780
de fazer um cálculo matemático aqui.

03:32.780 --> 03:36.310
Portanto, o resultado não seria cinco, mas vinte e três, uma

03:36.310 --> 03:38.980
seqüência concatenada dos dois números.

03:38.980 --> 03:41.690
Este é um erro que você poderia ter no JavaScript,

03:41.690 --> 03:43.530
não é um erro técnico, você provavelmente

03:43.530 --> 03:46.720
não receberá um erro de tempo de execução, mas você tem

03:46.720 --> 03:49.832
um erro lógico em seu código.

03:49.832 --> 03:52.820
E isso, naturalmente, pode levar a enormes problemas nas

03:52.820 --> 03:55.870
aplicações web que você está escrevendo com JavaScript.

03:55.870 --> 03:59.360
Agora, é claro, em JavaScript temos estratégias de mitigação,

03:59.360 --> 04:02.541
poderíamos adicionar uma verificação na função para verificar

04:02.541 --> 04:05.440
os tipos de entradas em tempo de execução, poderíamos

04:05.440 --> 04:08.240
também validar e higienizar as entradas do usuário

04:08.240 --> 04:10.670
e, embora pudéssemos querer fazer tudo isso,

04:10.670 --> 04:14.040
também seria bom se pudéssemos pegar erros como esse já durante

04:14.040 --> 04:15.840
o desenvolvimento.

04:15.840 --> 04:19.220
E, felizmente, isto é possível com TypeScript, porque os desenvolvedores

04:19.220 --> 04:21.810
podem escrever código inválido aqui e introduzir

04:21.810 --> 04:23.970
bots como este em JavaScript, e com TypeScript

04:23.970 --> 04:26.160
temos uma ferramenta que nos ajuda a escrever

04:26.160 --> 04:30.060
melhor o código e evitar tais problemas.

04:30.060 --> 04:31.910
Então, vamos dar uma olhada mais de perto nisto.
