WEBVTT

00:02.040 --> 00:04.180
先生：それはとても基礎的な授業だったんですね｡ 

00:04.180 --> 00:08.400
現在､ クラスを作る際には､ それ以上に複雑になることがよくあります｡

00:08.400 --> 00:10.800
そして､ そこにさらにデータを保存したいと思うかもしれません｡ 

00:10.800 --> 00:15.160
例えば､ ある部門がすべて従業員を抱えるべきだとします｡ 

00:15.160 --> 00:20.290
それは配列かもしれませんし､ 最初は空の配列かもしれません｡

00:20.290 --> 00:23.520
また､ そこに格納したいものをもう少し正確に言うと､

00:23.520 --> 00:28.800
比較的シンプルに保つために文字列配列にすることができます｡

00:28.800 --> 00:31.733
ここで､ addEmployeeというメソッドを用意することができました｡ 

00:33.030 --> 00:39.430
ここでは､ 引数として従業員を指定しますが､ この例では単なる文字列であるべきです｡

00:39.430 --> 00:42.650
そうすれば､ これを設定することができます｡  の従業員がいます｡  を押してください｡ 

00:42.650 --> 00:48.373
そこで､ このコードで従業員配列に新しい従業員を追加します｡

00:50.750 --> 00:55.749
ここで､ もう1つのメソッド､ printEmployeeInformationも追加することができます｡

01:00.508 --> 01:12.766
そして､ そこで私はコンソールをしたいのです｡  log(this. の従業員がいます｡  length)とコンソールしたいとも思っています｡

01:12.766 --> 01:12.766
log(this. 社員）そのものです｡ 

01:15.510 --> 01:18.480
ここで､ このコードをコメントアウトすると､

01:18.480 --> 01:25.870
またもや､ このオブジェクトと部門の説明が一致しないので､ 壊れてしまいます｡

01:25.870 --> 01:32.234
そしてその代わりに､ この経理部に従業員（仮にMaxとします）を追加することができます｡

01:32.234 --> 01:35.400
そして､ もう一人の社員､ 仮にマニュとします｡ 

01:35.400 --> 01:37.690
そして､ それを記述するだけでなく､

01:37.690 --> 01:41.520
そこに従業員の情報を書き込むこともしたいのです｡

01:41.520 --> 01:44.600
これを保存すると､ このような出力が得られるはずです｡

01:44.600 --> 01:47.830
2人の従業員と､ ここにいくつかの情報があります｡

01:47.830 --> 01:50.240
今は､ それがすべてです｡ 

01:50.240 --> 01:52.700
このクラスの問題点として､ add employeeだけでなく､

01:52.700 --> 02:04.430
employeeのプロパティに直接アクセスすることで､ 外部から社員を変更できることが挙げられます（ちなみに､ nameに対しても同様に可能です）｡

02:04.430 --> 02:07.630
つまり､ 経理に行き､ 社員に声をかけ､

02:07.630 --> 02:10.560
インデックス2の社員をもう一人増やして､

02:10.560 --> 02:16.400
アンナを合格させる､ みたいなこともできます｡

02:16.400 --> 02:18.210
それをやって保存すれば､ 社員が3人になって､

02:18.210 --> 02:20.290
アナが出るんです｡

02:20.290 --> 02:22.710
さて､ あなたは､ 素晴らしい､ 別の方法がある､ と思うかもしれません｡ 

02:22.710 --> 02:25.230
しかし､ より複雑なアプリケーションを構築する場合､

02:25.230 --> 02:27.980
このようなことは避けたいものです｡

02:27.980 --> 02:30.930
クラスを使用するための明確な道筋や方法が1つだけあることを確認し､

02:30.930 --> 02:38.530
そのようなもの､ つまり別の使用方法は実際にはサポートされていないことを確認したいのです｡

02:38.530 --> 02:41.230
なぜなら､ 大きなチームで仕事をしている場合､

02:41.230 --> 02:42.920
ある同僚は従業員を追加するのにこの方法を使い､

02:42.920 --> 02:48.050
別の同僚はこの方法を使うかもしれないからです｡

02:48.050 --> 02:49.280
そして､ あなたはこれを望んでいない｡ 

02:49.280 --> 02:52.640
一つの統一された方法を持ちたいものです｡ 

02:52.640 --> 02:55.960
また､ おそらく従業員の追加メソッドでは､ 単に配列に追加するだけでなく､

02:55.960 --> 02:58.420
それ以上のことを行うからです｡

02:58.420 --> 03:02.400
まずはここで検証などをしてもらいたいのかもしれませんね｡

03:02.400 --> 03:04.940
そのため､ この行で直接新しい値を代入したり､

03:04.940 --> 03:06.610
配列に新しい値を追加したりしても､

03:06.610 --> 03:12.970
単に実行されないような余分なコードが含まれている可能性があります｡

03:12.970 --> 03:19.884
だから､ 社員がクラスの外からこのようにアクセスできることを許可したくないのです｡

03:19.884 --> 03:22.340
そして､ TypeScriptがそれをカバーします｡ 

03:22.340 --> 03:26.760
ここの従業員は､ 前にprivateキーワードをつけることで､

03:26.760 --> 03:32.220
プライベートプロパティ､ プライベートフィールドにすることができます｡

03:32.220 --> 03:38.030
privateの意味は､ employeesがクラスの内部からしかアクセスできないプロパティになったということで､

03:38.030 --> 03:43.480
つまりクリエイティブ・オブジェクトの内部からアクセスできるようになったということです｡

03:43.480 --> 03:46.700
そのため､ departmentクラスの中のどのメソッドでも､

03:46.700 --> 03:49.770
従業員を扱うことができる｡

03:49.770 --> 03:52.570
でも､ もうこのままではアクセスできない｡ 

03:52.570 --> 03:54.710
ここで､ 私は今エラーが出ていることを確認します｡ 

03:54.710 --> 03:57.280
これを保存しようとすると､ プロパティ 'employees'

03:57.280 --> 03:59.870
はプライベートであり､ クラス 'department'

03:59.870 --> 04:03.550
内でのみアクセス可能であるというコンパイルエラーが発生します｡

04:03.550 --> 04:07.100
そこで､ この部門に従業員を追加する場合は､

04:07.100 --> 04:12.690
addEmployeeメソッドを使用するように強制しています｡

04:12.690 --> 04:16.760
だって､ こんなコード書いたらエラーになるんだもん｡ 

04:16.760 --> 04:20.460
ここはいわゆるモディファイアで､ プライベートキーワードです｡ 

04:20.460 --> 04:25.000
また､ プライベート以外にパブリックもあり､ これはデフォルトですが｡

04:25.000 --> 04:26.590
パブリックを追加する必要はありません｡ 

04:26.590 --> 04:31.650
つまり､ このような名前は､ 前にpublicがついた名前と全く同じなのです｡

04:31.650 --> 04:36.350
違いは､ パブリックプロパティは外からアクセスできることです｡

04:36.350 --> 04:40.350
ですから､ 例えばここで､ 私が望めば､ 名前に連絡を取って､

04:40.350 --> 04:43.600
ここに新しい名前を割り当てることもできます｡

04:43.600 --> 04:45.260
それは可能です｡ 

04:45.260 --> 04:49.270
個人所有の物件については､ こちらはできません｡ 

04:49.270 --> 04:51.580
内側からしか使えません｡ 

04:51.580 --> 04:55.700
ところで､ 技術的には､ JavaScriptはpublicとprivateを知らない｡

04:55.700 --> 05:01.320
最近追加された非常にモダンなバージョンにのみ､ そのようなものが存在するのです｡

05:01.320 --> 05:05.690
かつてのJavaScriptは､ privateやpublicのプロパティを知りませんでした｡

05:05.690 --> 05:08.520
そこでは､ 常にすべての財産が公開されていた｡ 

05:08.520 --> 05:10.630
TypeScriptはこの機能を導入しているが､

05:10.630 --> 05:18.780
最近までJavaScriptはパブリックプロパティしか知らなかったので､ もちろん実行時には機能しない｡

05:18.780 --> 05:23.130
つまり､ この行は､ TypeScriptのコンパイル時にフリーズしたエラーです｡

05:23.130 --> 05:27.000
それでもJavaScriptにコンパイルすれば､ このコードは実行時にエラーなく実行されます｡

05:27.000 --> 05:30.140
なぜなら､ 最近まではJavaScript単体では､

05:30.140 --> 05:34.900
この概念を知らなかったからです｡

05:34.900 --> 05:38.720
そのため､ コンパイルするバージョンによっては､ まだそれがわからないこともあります｡

05:38.720 --> 05:40.770
そのため､ TypeScriptは実行時ではなく､

05:40.770 --> 05:44.650
コンパイル時にチェックするため､ これをサポートしているに過ぎない｡

05:44.650 --> 05:49.863
しかし､ これを使えば､ このようなコードを避けることができ､ 誰もがよりクリーンなコードを書かざるを得なくなるのです｡
