WEBVTT

00:00.000 --> 00:06.200
（沉默）-：因此, 我们已经看到了TypeScript在开发过程中是如何帮助我们的｡

00:06.200 --> 00:10.560
现在, 我们还知道JavaScript中有一个数字类型｡ 

00:10.560 --> 00:14.010
我们可以看到它与内置类型的运算符｡ 

00:14.010 --> 00:15.781
这现在不是TypeScript特定的,

00:15.781 --> 00:20.420
这是JavaScript支持的内置运算符和关键字｡

00:20.420 --> 00:22.910
我们可以用它来得到某个值的类型｡ 

00:22.910 --> 00:27.050
在这里, 我们可以控制台锁类型为1｡ 

00:27.050 --> 00:27.992
如果我们这样做的话,

00:27.992 --> 00:32.623
我们会看到, 一旦我们编译了它, 我们就可以运行更新的代码｡

00:33.780 --> 00:37.040
在这里, 我们将打印号码发送到控制台｡ 

00:37.040 --> 00:39.330
现在我们这样做了, 感谢这里的输出, 感谢操作符的类型,

00:39.330 --> 00:41.180
在Vanilla JavaScript中,

00:41.180 --> 00:46.710
没有TypeScript, 我们可以使用它来总是改进我们的函数｡

00:46.710 --> 00:51.500
我们可以检查数字的类型是否等于数字｡ 

00:51.500 --> 00:54.300
不好意思, n1的类型我是说,

00:54.300 --> 01:00.710
如果它等于数字, 我们也可以检查n2的类型是否等于数字｡

01:00.710 --> 01:02.349
并且只在这里执行我们的操作,

01:02.349 --> 01:05.220
如果它是一个抛出的错误, 或者执行相反的操作,

01:05.220 --> 01:10.820
检查它是否不相等, 或者n2是否不相等｡

01:10.820 --> 01:13.230
如果两者中有一个不是数字,

01:13.230 --> 01:16.360
那么我们会抛出一个新的错误, 我们说,

01:16.360 --> 01:22.300
不正确的输入｡ 这实际上是一种非TypeScript的方式,

01:22.300 --> 01:25.700
确保我们不能用字符串调用这个函数｡

01:25.700 --> 01:26.760
如果我现在这样做, 然后重新编译,

01:26.760 --> 01:30.830
我们会得到TypeScript错误, 但现在我们先忽略它｡

01:30.830 --> 01:31.730
如果我们重新运行这个程序,

01:31.730 --> 01:33.100
我们会得到不正确的输入,

01:33.100 --> 01:34.940
这是我们自己造成的｡

01:34.940 --> 01:38.080
所以现在我们加固了JavaScript中的功能障碍,

01:38.080 --> 01:44.950
它在运行时失败, 但失败可能比我们以前遇到的显示不正确的输出要好｡

01:44.950 --> 01:48.715
这是一种只在JavaScript中检查输入的方法｡

01:48.715 --> 01:50.640
您不需要TypeScript来完成此操作｡ 

01:50.640 --> 01:53.200
这是常规的JavaScript代码｡ 

01:53.200 --> 01:55.160
当然, 这种方法也有缺点｡

01:55.160 --> 01:57.160
有时候这样做是对的｡ 

01:57.160 --> 02:01.440
有时, 您只能在运行时验证某些输入｡ 

02:01.440 --> 02:08.950
但缺点是, 我们正在检查一些实际上可以在使用TypeScript开发期间避免的东西｡

02:08.950 --> 02:11.180
所以, 是的, 我们抛出了一个错误｡ 

02:11.180 --> 02:14.210
在我们的应用程序中, 我们可能已经内置了一些措施,

02:14.210 --> 02:19.080
这些措施可以回退到其他一些行为来保存正在运行的应用程序｡

02:19.080 --> 02:20.750
但是, 我们仍然抛出了一个错误,

02:20.750 --> 02:24.180
这在一开始确实没有必要发生｡

02:24.180 --> 02:27.350
我们本可以用TypeScript来阻止它｡ 

02:27.350 --> 02:31.450
在这里, 我们真正看到了JavaScript和TypeScript在类型方面的区别｡

02:31.450 --> 02:33.750
JavaScript是动态类型的,

02:33.750 --> 02:36.880
这意味着我们有一个最初可能保存一个数字的变量,

02:36.880 --> 02:41.600
然后我们给它赋值一个字符串｡

02:41.600 --> 02:44.500
这就是为什么我们必须输入off运算符,

02:44.500 --> 02:48.024
这样我们就可以在运行时检查某个东西的当前类型,

02:48.024 --> 02:52.267
如果我们有一些依赖于某个类型的代码｡

02:52.267 --> 02:55.094
另一方面, TypeScript是静态类型化的,

02:55.094 --> 03:04.980
这意味着我们在开发期间定义的变量和参数的类型结束于, 它们不会在运行时突然改变｡

03:04.980 --> 03:09.090
当然, 由于TypeScript被编译为JavaScript,

03:09.090 --> 03:10.660
理论上可以｡

03:10.660 --> 03:13.790
但是如果我们使用TypeScript,

03:13.790 --> 03:18.810
我们编写的代码中, 我们突然将一个新的数据类型赋给一个变量,

03:18.810 --> 03:19.840
例如, 我们之前说这应该是一个数字,

03:19.840 --> 03:32.120
现在我们要赋给一个字符串, 那么我们在开发过程中会得到一个错误, 所以我们不得不明确类型, 一些东西可以或不可以保存｡

03:32.120 --> 03:33.710
这就是区别所在｡ 

03:33.710 --> 03:36.620
因此, 如果我们可以通过TypeScript避免这种情况,

03:36.620 --> 03:40.810
我们并不真的希望使用这样的实现或解决方案｡

03:40.810 --> 03:46.400
当然, JavaScript知道类型的概念是很重要的.

03:46.400 --> 03:48.740
它知道一些类型, 如数字､

03:48.740 --> 03:50.640
字符串和布尔值｡

03:50.640 --> 03:53.540
但是使用它总是意味着我们只能在运行时失败,

03:53.540 --> 03:58.700
而不是在开发过程中失败, 这对我们作为开发人员来说是一个更好的地方｡

03:58.700 --> 04:01.550
它允许我们更早地修复错误｡ 

04:01.550 --> 04:05.410
此外, JavaScript只知道几种类型｡

04:05.410 --> 04:07.170
您将在本课程中学习到这一点｡ 

04:07.170 --> 04:10.540
TypeScript比JavaScript知道更多的类型｡ 

04:10.540 --> 04:18.030
所以运行时检查并不像我们用TypeScript所做的那样灵活或强大｡

04:18.030 --> 04:22.550
基于这些原因, 这种方法实际上不是我们想要在这里使用的方法｡

04:22.550 --> 04:26.540
有时候, 在执行阶段取得型别会很有用｡ 

04:26.540 --> 04:28.790
但是有时候, 就像这个例子一样,

04:28.790 --> 04:31.740
在开发过程中获得它会更好｡

04:31.740 --> 04:34.280
当然, 唯一需要注意的是, 使用TypeScript,

04:34.280 --> 04:36.070
您只能在开发期间获得支持,

04:36.070 --> 04:44.650
而不能在运行时获得支持, 因为这些TypeScript功能和检查没有内置到JavaScript引擎中, 因此逻辑无法在浏览器中执行,

04:44.650 --> 04:51.223
它只能在开发期间编译代码时执行｡
