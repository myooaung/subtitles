WEBVTT

00:02.300 --> 00:03.830
講師：そこで､ ここではかなり部署を分けて仕事をしているのですが､

00:03.830 --> 00:07.350
私は経理部を作りました｡

00:07.350 --> 00:09.610
現在構築中のアプリケーションでは､

00:09.610 --> 00:12.120
もちろん部門が必要かもしれませんが､ 特定の種類の部門については､

00:12.120 --> 00:16.660
より多くの情報が必要かもしれません｡

00:16.660 --> 00:18.830
例えば､ IT部門があり､

00:18.830 --> 00:24.900
ID､ 名前､ 従業員がいて､ さらにIT部門だけが持っている管理者がいる､

00:24.900 --> 00:28.180
というような場合です｡

00:28.180 --> 00:30.340
経理部門は､ ID､ 名前､

00:30.340 --> 00:37.470
従業員を持つかもしれませんが､ 例えば､ 報告書も持つかもしれません｡

00:37.470 --> 00:41.030
それが生成したレポートの配列､ など｡ 

00:41.030 --> 00:44.541
そのため､ すべての部門が持つべき基本的なプロパティとメソッドを用意し､

00:44.541 --> 00:54.660
さらにその部門だけが持つべき固有のプロパティとメソッドを持つ特別なバージョンを用意するかもしれません｡

00:54.660 --> 00:58.100
このようなことを実現するために役立つのが「継承」です｡ 

00:58.100 --> 01:00.010
では､ ここで継承をどのように活用すればいいのでしょうか｡ 

01:00.010 --> 01:01.670
そうですね......私たちのクラス部門がありますから｡ 

01:01.670 --> 01:05.130
では､ これらの専門部署を作ってみましょう｡ 

01:05.130 --> 01:08.483
だからここでは､ クラスのIT部門を持つことができるのです｡ 

01:09.610 --> 01:14.010
そして､ ここのクラスでは､ 名前とIDと一般部門の従業員を利用したいのですが､

01:14.010 --> 01:19.537
独自の機能を追加したいのです｡

01:19.537 --> 01:21.970
ここで extends キーワードを使い､ 継承したいクラスを指定することで､

01:21.970 --> 01:25.970
department クラスを継承することができます｡

01:25.970 --> 01:27.530
この場合､ それは部門です｡ 

01:27.530 --> 01:30.600
さて､ 重要なことは､ 1つのクラスからしか継承できないので､

01:30.600 --> 01:33.010
複数のクラスから継承することはできない､

01:33.010 --> 01:34.660
ということです｡

01:34.660 --> 01:38.070
その結果､ IT部門を作成すると､

01:38.070 --> 01:40.700
IT部門クラスが空であっても､

01:40.700 --> 01:49.400
このようなコンストラクタで呼び出すことができます｡

01:49.400 --> 01:52.830
これを保存すると､ 確かに以前と同じように動作することがわかります｡

01:52.830 --> 01:59.610
他のクラスを継承すると､ 継承したクラスは自動的にベースクラス（この場合は部門）が持っているすべてのものを取得し､

01:59.610 --> 02:06.072
そのコンストラクタも含まれます｡ したがって､ この継承したクラス専用のコンストラクタを追加しない限り､

02:06.072 --> 02:20.800
このサブクラスではベースクラスのコンストラクタが使用されるので､ このサブクラスのインスタンス化の際には､ 自動的にこのコンストラクタが使用されます｡

02:20.800 --> 02:27.562
つまり､ ここで渡している引数を使って､ 最終的に魔法のように基底クラスのコンストラクタを呼び出すのです｡

02:27.562 --> 02:30.350
ここでIT部門にコンストラクタを追加して､ 独自のコンストラクタを追加することができますが､

02:30.350 --> 02:35.800
エラーが発生しているのがわかります｡

02:35.800 --> 02:38.580
ひとつは､ もちろんここで取得するデータを受け入れるべきですが､

02:38.580 --> 02:44.120
名前はここで渡す必要のないものであるべきだと主張することができます｡

02:44.120 --> 02:46.430
そして､ それは会計でもないはずです｡ 

02:46.430 --> 02:49.110
しかし､ その代わりにここでは､ IT部門のクラスなので､

02:49.110 --> 02:52.563
部門名は常にITとすることができます｡

02:53.700 --> 02:56.910
しかし､ 私はまだ私のIDを受け入れたいのですが､

02:56.910 --> 03:06.420
今度は本質的に､ 固定名ITのように､ departmentのコンストラクタにそれを転送したいのです｡

03:06.420 --> 03:11.120
そのためには､ 特別なキーワードが必要です｡

03:11.120 --> 03:13.210
そして､ それはスーパーだ｡ 

03:13.210 --> 03:15.580
他のクラスを継承するクラスで独自のコンストラクタを追加する場合､

03:15.580 --> 03:23.790
継承元のクラスでsuperを追加し､ 関数のように実行する必要があります｡

03:23.790 --> 03:28.070
Superはここでベースクラスのコンストラクタを呼び出すので､

03:28.070 --> 03:31.300
この場合は部門コンストラクタとなります｡

03:31.300 --> 03:33.690
そして､ もう一方のsuperは親クラスのコンストラクタの引数､

03:33.690 --> 03:37.630
ID､ nameを受け取ります｡

03:37.630 --> 03:41.060
ここではIDを転送することができるので､ ここで取得したIDはそのままsuperに渡され､

03:41.060 --> 03:46.860
ITのように名前の値をハードコードすることができます｡

03:46.860 --> 03:52.500
つまり､ これでサブクラス内部からベースクラスのコンストラクタが呼び出されることになります｡

03:52.500 --> 03:55.310
さて､ 重要なことは､ 「this」キーワードで何かをする前に､

03:55.310 --> 03:59.700
コンストラクタでまずsuperを呼び出すことです｡

03:59.700 --> 04:06.670
したがって､ もしここに他の特別なプロパティを割り当てるつもりなら､ superを呼び出した後でそれを行う必要があります｡

04:06.670 --> 04:10.346
そして､ 確かに私はここに私自身の特別なプロパティを追加したいです｡ 

04:10.346 --> 04:13.528
ここで管理人を追加することもできる｡ 

04:13.528 --> 04:17.800
プライベートとして､ あるいはパブリックとして､ 実は言ってみましょう｡ 

04:17.800 --> 04:20.878
パブリックプロパティとして､ admins､

04:20.878 --> 04:25.630
そしてそれは文字列の配列であるべきです｡

04:25.630 --> 04:27.780
部門クラスは管理者データを必要としないので､

04:27.780 --> 04:34.670
私はこれをベースクラスに転送したくありません｡

04:34.670 --> 04:38.800
その代わりに､ IT部門のプロパティにこれを格納したいので､

04:38.800 --> 04:42.150
ここでadminsというフィールドを追加して､

04:42.150 --> 04:44.922
管理者をいくつか取り､ そこにadminsを格納します｡

04:44.922 --> 04:52.020
あるいは､ ここでpublicを使っているので､ 同じ名前のプロパティが作成され､ この引数に与えたデータは､

04:52.020 --> 05:00.148
自動的に作成されたプロパティに格納されるというショートカットを既に使っています｡

05:00.148 --> 05:03.710
スーパーが最初に呼ばれなければならないことを明確にするために､

05:03.710 --> 05:07.610
私は長い道のりを歩んで､ ここにアドミニストレーターを追加して､

05:07.610 --> 05:12.610
こう言う｡ admins = アドミン｡ 

05:13.260 --> 05:15.160
ここでも､ ショートカットの方が短いでしょう｡ 

05:15.160 --> 05:17.830
これは､ "this "キーワードを使用する場合は､

05:17.830 --> 05:21.020
superを呼び出した後にそれを実行しなければならないことを示し､

05:21.020 --> 05:24.480
明確にするために行っています｡

05:24.480 --> 05:27.640
そして､ それを保存すると､ アドミニストレータを渡していないので､

05:27.640 --> 05:30.920
エラーが発生します｡

05:30.920 --> 05:33.920
マックスはここでしか通らない管理者です｡ 

05:33.920 --> 05:36.950
これで保存して､ エラーもなくコンパイルできましたし､

05:36.950 --> 05:39.910
実際にここに私たちの部門が表示されています｡

05:39.910 --> 05:41.840
現在は､ ITという名称になっています｡ 

05:41.840 --> 05:44.670
そして､ 部門全体をコンソールログすると､

05:44.670 --> 05:54.250
経理からITに名前を変えて､ コンソールできるかもしれません｡

05:54.250 --> 05:54.250
ログITはこちら

05:54.250 --> 05:57.570
もちろん､ 名前の変更は任意です｡ ただ､ ここでIT部門を構築していることを考えると､

05:57.570 --> 06:00.160
より理にかなっていると思います｡

06:00.160 --> 06:02.510
部門全体をコンソールログに記録したところ､

06:02.510 --> 06:06.110
確かに管理者がいることがわかりますが､ 従業員やその他､

06:06.110 --> 06:11.110
部門クラスで設定したものもあります｡

06:12.000 --> 06:16.520
もちろん､ departmentを拡張して会計部門を作成し､

06:16.520 --> 06:27.030
そこに会計特有のものを追加することができます｡

06:27.030 --> 06:29.540
ここでコンストラクタを使うこともできますし､ ショートカットを使って､

06:29.540 --> 06:36.170
プライベートプロパティであるレポートをいくつか受け取り､ addReportでテキスト（文字列）を受け取り､ レポートにアクセスしてテキストをアイテムとしてレポートに追加し､

06:36.170 --> 06:56.990
getReportsもここでコンソールするだけかもしれません｡

06:56.990 --> 06:56.990
ログ（this. という名前にするか､

06:57.563 --> 07:00.860
printReportsという名前にするか､ その方が理にかなっています｡

07:00.860 --> 07:02.720
そして今､ 私たちは､ 基本の部門が持っていない2つのメソッドと､

07:02.720 --> 07:04.890
基本の部門が持っていない追加のプロパティを持つ､

07:04.890 --> 07:09.840
非常に特別なバージョンの部門を手に入れたことになるのです｡

07:09.840 --> 07:13.000
そして､ やはり基地局から全てを調達する｡ 

07:13.000 --> 07:20.260
名前（ここでは会計に設定）､ ID（これはベース部門のコンストラクタにも転送されます）｡

07:20.260 --> 07:27.510
そして､ その下にある新しいAccountingDepartmentで会計を作成すると､

07:27.510 --> 07:31.750
IDを入力してレポートを作成することができます｡

07:31.750 --> 07:34.340
最初は空の配列だとしよう｡ 

07:34.340 --> 07:39.340
それからaddReportを呼んで､

07:40.550 --> 07:43.446
何かがおかしくなった､

07:43.446 --> 07:58.890
もちろん会計ではそんなことはないのですが､ レポートを印刷することもできます｡

07:58.890 --> 08:01.820
経理部門は､ ある機能を継承して､ 自分たちの機能を追加していくという継承のため､

08:01.820 --> 08:05.623
そうしています｡
