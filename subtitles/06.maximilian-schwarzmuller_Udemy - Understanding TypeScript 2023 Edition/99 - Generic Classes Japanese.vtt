WEBVTT

00:02.270 --> 00:04.390
講師：さて､ ジェネリック関数については､ もう十分ですね｡ 

00:04.390 --> 00:06.490
このコース､ すべてのコースプロジェクトを通して､

00:06.490 --> 00:08.150
必ず使用します｡

00:08.150 --> 00:11.890
だから､ それは仕事をすればするほど､ だんだんはっきりしてくるはずです｡

00:11.890 --> 00:14.823
大まかな内容はもうお分かりかと思います｡ 

00:15.660 --> 00:21.560
しかし､ ジェネリックな関数がすべてではありません｡

00:21.560 --> 00:27.760
ジェネリックなクラスもあります｡

00:27.760 --> 00:31.950
ここでストレージクラスを作成することも可能です｡ 

00:31.950 --> 00:36.060
例えば､ あるクラスがプライベートプロパティであるdataを持つとします｡ 

00:36.060 --> 00:38.850
最終的にはデータの配列を保持することになります｡ 

00:38.850 --> 00:40.940
そして､ addItemメソッドを持っています｡

00:40.940 --> 00:45.763
このメソッドでは､ アイテムを受け取り､ それをプッシュでデータに追加します｡

00:48.570 --> 00:50.830
そして､ removeItemメソッドがあり､

00:50.830 --> 00:57.740
このメソッドでアイテムを受け取ります｡

00:57.740 --> 00:57.740
のデータを使用します｡  をスプライスして､

00:57.740 --> 01:02.910
ここで indexOff(item) を取得して､ 1つの要素をスプライスすればよいのです｡

01:02.910 --> 01:06.030
このようにして､ 配列から要素を削除することができます｡ 

01:06.030 --> 01:07.873
そしてもちろんgetItemsは､

01:09.750 --> 01:13.120
例えばこれのコピーを返す｡ のデータを､ 学習したスプレッド演算子を使って､

01:13.120 --> 01:15.770
そのようにします｡

01:16.610 --> 01:17.443
今､ それを実行すると､

01:17.443 --> 01:19.450
ここで大量のエラーが発生します｡

01:19.450 --> 01:20.500
Storageという名前は予約名なので､

01:20.500 --> 01:25.230
Datastorageという名前にしましょう｡

01:25.230 --> 01:26.620
それは簡単なことです｡ 

01:26.620 --> 01:27.920
ここで､ 保存しているデータの種類や､

01:27.920 --> 01:32.960
項目がどのタイプであるかについて何も言っていないため､ ここでもエラーが発生します｡

01:32.960 --> 01:35.870
そして､ それこそが､ データの種類を気にしないかもしれないので､

01:35.870 --> 01:38.860
これをジェネリッククラスにすることができるところなのです｡

01:38.860 --> 01:40.880
均一なデータにしたいので､ 文字列だけか､

01:40.880 --> 01:42.410
数字だけか､ オブジェクトだけか､

01:42.410 --> 01:44.830
どちらかです｡

01:44.830 --> 01:47.550
でも､ それ以外はどうでもいいんです｡ 

01:47.550 --> 01:50.820
そこで､ クラス名の後に角括弧を付け､

01:50.820 --> 01:53.300
さらにTやUなど､ 識別子として使用したいものを追加して､

01:53.300 --> 02:00.110
これを汎用クラスとしてここに追加します｡

02:00.110 --> 02:01.083
ここで､ これはT型の配列で､

02:01.083 --> 02:07.413
その中に汎用型のデータを格納していると言えるでしょう｡

02:07.413 --> 02:09.670
そのため､ ここではそのようなデータを追加し､

02:09.670 --> 02:12.400
ここではそのようなデータを削除するようにしています｡

02:12.400 --> 02:18.490
したがって､ ここでは､ 一般的な型の配列を返すと推論される項目を正しく得ることができます｡

02:18.490 --> 02:20.860
ここで新しいDataStorageを呼び出し､

02:20.860 --> 02:31.250
一般的なタイプをstringに設定することで､ stingやtextStorageを作成することができるようになります｡

02:31.250 --> 02:33.070
そして､ このtextStorageでaddItemを呼び出すと､

02:33.070 --> 02:40.800
数字を追加しようとするとエラーが発生します｡ これは､ これがstingsのみを格納するDataStorageになると言っているためです｡

02:40.800 --> 02:51.450
つまり､ Maxをここに格納し､ Manuも格納して､ textStorageを呼び出すことができます｡

02:51.450 --> 02:51.450
removeItem('Max')を実行し､

02:51.450 --> 02:55.073
console. ログを表示します｡  textStorageです｡  getItems

02:56.520 --> 02:58.870
そして､ これを保存すればすべてうまくいくはずです｡

02:58.870 --> 03:00.300
なぜなら､ これは一般的な型であり､

03:00.300 --> 03:03.103
実際､ 最後にはManuがそこに入っているだけだからです｡

03:04.400 --> 03:08.240
つまり､ これは私たちが作ることができる一つの簡単な汎用クラスとなるのです｡ 

03:08.240 --> 03:10.500
さて､ なぜこのような汎用的なクラスを作るのでしょうか？

03:10.500 --> 03:11.770
今言ったように､

03:11.770 --> 03:18.950
テキストだけでなく､ 数値も別のデータストレージに格納したいかもしれませんからね｡

03:18.950 --> 03:21.510
そこで､ このようなDataStorageを作成し､ これをnumberに設定することで､

03:21.510 --> 03:26.250
そのストレージに数字だけを追加することができるようになりました｡

03:26.250 --> 03:30.520
もちろん､ ユニオン型を使って両方を許可するストレージを設定することも可能だ｡

03:30.520 --> 03:32.550
つまり､ 柔軟性はそのままに､

03:32.550 --> 03:41.450
型に追加情報を与えることで､ 柔軟でありながら強く型付けされたクラスになっているのです｡

03:41.450 --> 03:43.470
関数のときと同じようにね｡ 

03:43.470 --> 03:46.910
本当に柔軟で､ なおかつ完璧なタイプのサポートです｡ 

03:46.910 --> 03:49.900
それが汎用型の考え方です｡ 

03:49.900 --> 03:52.680
そこで､ DataStorageクラスを使って､ 文字列を格納したり､

03:52.680 --> 03:56.513
数値を格納したり､ 好きなようにできるようにしました｡

03:57.790 --> 04:01.300
しかし､ dataStorageクラスについては､ 一つ問題があります｡ 

04:01.300 --> 04:07.090
例えば､ ここにオブジェクトストレージがあるとします｡

04:07.090 --> 04:17.270
新しいDataStorageを作成し､ そこにオブジェクトを格納したいとします｡

04:17.300 --> 04:20.460
そこに私がMaxと名付けたオブジェクトがあるとしよう｡ 

04:20.460 --> 04:24.760
また､ 別のオブジェクトを格納しましょう､ そこにはManuを格納します｡

04:24.760 --> 04:28.310
そして､ コードの中で何かをしていて､

04:28.310 --> 04:34.100
ある時点からその項目を削除したいとします｡

04:34.100 --> 04:37.863
そして､ コンソールにしたい｡  ログを表示します｡  objStorageです｡  getItems

04:39.450 --> 04:40.550
そんな感じ｡ 

04:40.550 --> 04:45.840
これを保存すると､ その中にMaxというオブジェクトがあることがわかります｡

04:45.840 --> 04:47.470
ということは､ 右が良さそうですね｡ 

04:47.470 --> 04:49.140
今は､ あまり良くないですね｡ 

04:49.140 --> 04:55.740
例えば､ 今Maxを削除したいので､ データストレージにはManuが残っているはずです｡

04:55.740 --> 04:59.653
それゆえ､ リロードしても､ 井の中の蛙､ マックスのままなんです｡ 

05:00.550 --> 05:07.350
さて､ 問題はここでオブジェクトを扱っていることです｡ ご存知のようにJavaScriptのオブジェクトは参照型です｡

05:07.350 --> 05:11.460
今､ あなたは参考文献に飛び込むことができ､ 追加のリソースを見つけるために添付してください｡

05:11.460 --> 05:12.730
一方､ プリミティブ値は､

05:12.730 --> 05:14.650
JavaScriptのコアなもので､

05:14.650 --> 05:16.970
typescriptとは全く関係ないので､ ここでは､

05:16.970 --> 05:19.060
その違いをご存知だと思います｡

05:19.060 --> 05:22.300
ここで問題なのは､ このようにデータを削除して識別するロジックで作られたクラスでは､

05:22.300 --> 05:32.200
非プリミティブな値を扱うときに､ 実際には良い仕事ができないということです｡

05:32.200 --> 05:35.130
つまり､ オブジェクトや配列を扱う場合､ indexOfでここにオブジェクトを渡すと､

05:35.130 --> 05:40.910
技術的にはこれは新しいオブジェクトなので､ うまくいきません｡

05:40.910 --> 05:43.800
このように見えるかもしれませんが､ これは技術的にメモリ内の真新しいオブジェクトであり､

05:43.800 --> 05:48.290
異なるアドレスを持っているので､ うまくいきません｡

05:48.290 --> 05:52.110
JavaScriptはアドレスを探しますが､

05:52.110 --> 05:54.930
基本的に見つかりません｡ そこで､

05:54.930 --> 06:01.473
配列の最後の要素を削除して､ 最終的に-1を返します｡

06:02.419 --> 06:06.070
IndexOfは何も見つからなくても-1を返します｡ 

06:06.070 --> 06:07.990
つまり､ 配列の末尾から始まり､ 配列の最後の要素を削除するという､

06:07.990 --> 06:11.921
通常のJavascriptの動作です｡

06:11.921 --> 06:14.190
Manuの場合はそれでうまくいったのですが､

06:14.190 --> 06:16.810
本当はうまくいかず､ 偶然うまくいったのですが､

06:16.810 --> 06:19.020
Maxの場合はなぜうまくいかないかというと､

06:19.020 --> 06:19.880
配列の最後の要素が特定できないので､

06:19.880 --> 06:23.670
とりあえず常に削除しているのです｡

06:23.670 --> 06:25.890
ここで､ 少なくともこの問題を解決するための一つの方法は､

06:25.890 --> 06:29.140
アイテムが見つかったかどうかをチェックすることです｡

06:29.140 --> 06:36.260
このコードで､ もしこの値が-1であれば､ それは見つからなかったということです｡

06:36.260 --> 06:37.360
そうすれば､ 間違えて削除してしまわないように､

06:37.360 --> 06:40.780
戻ってきて確認することができます｡

06:40.780 --> 06:42.900
しかし､ もちろん今はそのバーを修正しただけで､

06:42.900 --> 06:46.580
オブジェクトと一緒に動作するような内部状態はまだできていません｡

06:46.580 --> 06:51.740
オブジェクトを扱うには､ まったく同じオブジェクトをもう一度渡すしかありません｡

06:51.740 --> 06:58.840
ここで､ maxオブジェクトを定数に格納し､ ここでmaxオブジェクトを渡すとします｡

06:58.840 --> 07:02.050
そして､ ここで同じことをすると､ 本当に同じ､ まったく同じオブジェクトを､

07:02.050 --> 07:06.540
メモリ内で使っていることになりますから､ 今度はうまくいくでしょう｡

07:06.540 --> 07:08.930
これしかないでしょう｡ 

07:08.930 --> 07:16.150
したがって､ ここでは､ プリミティブな値に対してのみ動作するようにするのがよいでしょう｡

07:16.150 --> 07:24.010
つまり､ Tは文字列､ 数値､ そしてブーリアンもすべて拡張していると言える｡

07:24.010 --> 07:27.920
つまり､ DataStorageは基本的にこれらのタイプでしか動作しないはずだということです｡

07:27.920 --> 07:30.470
そのため､ オブジェクトはもう許されない｡ 

07:30.470 --> 07:32.500
なぜなら､ より特化したDataStorageが必要になり､

07:32.500 --> 07:35.220
それはおそらくオブジェクトを順番に扱うだけで､

07:35.220 --> 07:40.080
プリミティブな値を扱うことはできないからです｡

07:40.080 --> 07:45.880
ここで検索ロジックを微調整し､ 削除すべきアイテムにiDがあるかどうかをチェックします｡

07:45.880 --> 07:48.910
この方法では､ 本当にプリミティブ型にしか使えないので､

07:48.910 --> 07:52.320
このような制約を設定することは間違いなく良いアイデアです｡

07:52.320 --> 07:55.610
そして､ これで保存すれば､ これをコメントアウトした後､

07:55.610 --> 07:57.253
再びもちろん動作します｡

07:58.810 --> 08:04.310
もちろん､ ここでも複数のジェネリックタイプを持つことができることは言うまでもありません｡

08:04.310 --> 08:07.600
クラスを扱う場合､ 1つのタイプに限定されるわけではありません｡

08:07.600 --> 08:09.610
また､ クラスの代わりに独自の汎用型を持つ､

08:09.610 --> 08:13.080
メソッドを持つこともできます｡

08:13.080 --> 08:18.010
そのため､ クラス全体ではなく､ あるメソッドでのみ必要とされる汎用型があれば､

08:18.010 --> 08:21.580
クラスメソッドに新しい汎用型を導入することができます｡

08:21.580 --> 08:23.000
そこは本当に柔軟なんですね｡ 

08:23.000 --> 08:25.570
制約をどこでも使うことができ､

08:25.570 --> 08:36.010
一般的に､ ジェネリック型はあなたの生活を楽にし､ 完全な柔軟性の完璧な組み合わせを与えるために存在するのです｡

08:36.010 --> 08:40.900
このDataStorageに何が保存されているか､ 何が保存されているかは完全に分かっているので､

08:40.900 --> 08:46.770
ここではどんなプリミティブな値でも使うことができ､ 型安全性も確保されています｡

08:46.770 --> 08:52.283
この組み合わせが､ ジェネリックタイプの凄さなんですね｡
