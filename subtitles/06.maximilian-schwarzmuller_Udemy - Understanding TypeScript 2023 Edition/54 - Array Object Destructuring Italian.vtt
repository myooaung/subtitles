WEBVTT

00:02.100 --> 00:04.870
Istruttore: Rimaniamo su array e oggetti.

00:04.870 --> 00:06.750
Un'altra sintassi importante,

00:06.750 --> 00:09.160
che si vede spesso nei moderni progetti JavaScript

00:09.160 --> 00:10.440
e Typescript, è la destrutturazione

00:10.440 --> 00:13.133
di array e oggetti.

00:14.180 --> 00:15.013
Come funziona?

00:15.013 --> 00:17.220
Cominciamo con il nostro array,

00:17.220 --> 00:20.220
l'array Hobby, che ha due hobby.

00:20.220 --> 00:22.200
Supponiamo di voler estrarre

00:22.200 --> 00:26.340
questi due hobby e memorizzarli in variabili o costanti.

00:26.340 --> 00:28.891
Naturalmente, possiamo farlo

00:28.891 --> 00:32.340
con hobby uno uguale hobby per l'indice zero,

00:32.340 --> 00:34.820
che è il primo elemento.

00:34.820 --> 00:38.720
E lo stesso forse con l'hobby due per gli hobby dell'indice uno.

00:38.720 --> 00:40.500
In questo modo si estraggono questi

00:40.500 --> 00:43.330
due elementi e li si memorizza in costanti.

00:43.330 --> 00:44.720
Ci sono volute due righe di codice

00:44.720 --> 00:46.710
e più elementi si vogliono recuperare, più

00:46.710 --> 00:48.493
righe di codice ci vogliono.

00:49.340 --> 00:51.690
La destrutturazione degli array ci permette di accorciarli.

00:51.690 --> 00:53.090
Con la destrutturazione degli

00:53.090 --> 00:56.250
array, che tra l'altro funziona anche con let e non solo con const,

00:56.250 --> 00:59.760
si aggiungono le parentesi quadre a sinistra del segno di uguale, che

00:59.760 --> 01:01.400
è un posto insolito.

01:01.400 --> 01:02.900
Non l'avevo mai visto prima.

01:02.900 --> 01:04.780
E a destra c'è l'array che si

01:04.780 --> 01:06.480
vuole destrutturare.

01:06.480 --> 01:08.430
Ora, destrutturare significa proprio

01:08.430 --> 01:10.470
estrarre gli elementi dall'array.

01:10.470 --> 01:13.570
E qui a sinistra, tra queste parentesi quadre, si

01:13.570 --> 01:15.040
memorizzano in costanti

01:15.040 --> 01:17.250
o, se si usa let, in variabili.

01:17.250 --> 01:21.170
In questo caso, quindi, potremmo avere l'hobby uno e l'hobby due.

01:21.170 --> 01:23.000
Questa sintassi passa attraverso

01:23.000 --> 01:25.640
l'array degli hobby, prende il primo elemento e lo

01:25.640 --> 01:26.920
memorizza in una costante

01:26.920 --> 01:29.050
con questo nome, prende il secondo elemento

01:29.050 --> 01:30.290
e lo memorizza in una costante

01:30.290 --> 01:32.320
con questo nome.

01:32.320 --> 01:35.490
Si possono anche aggiungere qui i parametri di riposo

01:35.490 --> 01:38.720
e avere qui gli hobby rimanenti, nel caso in cui l'array

01:38.720 --> 01:42.130
degli hobby abbia più elementi di due.

01:42.130 --> 01:46.260
Quindi tutti gli elementi rimanenti che non sono stati estratti nell'hobby

01:46.260 --> 01:48.070
uno o nell'hobby due saranno memorizzati

01:48.070 --> 01:51.290
in un nuovo array chiamato hobby rimanenti.

01:51.290 --> 01:54.090
Quindi verranno uniti in un nuovo array.

01:54.090 --> 01:57.940
A proposito, la destrutturazione non modifica l'array originale.

01:57.940 --> 02:02.940
Quindi, se ci mettiamo in console. Registrate hobby, hobby uno e hobby due qui,

02:04.260 --> 02:06.840
vedrete che hobby è ancora il vecchio array.

02:06.840 --> 02:08.840
Non è vuoto o altro.

02:08.840 --> 02:11.780
Quindi i valori che abbiamo estratto tra virgolette

02:11.780 --> 02:14.870
sono in realtà solo copiati in nuove costanti o variabili,

02:14.870 --> 02:17.720
non rimossi dall'array.

02:17.720 --> 02:18.980
Questa è la destrutturazione degli array.

02:18.980 --> 02:20.600
Lo stesso vale per gli oggetti.

02:20.600 --> 02:21.690
Abbiamo qui la nostra persona.

02:21.690 --> 02:23.440
Supponiamo ora di voler memorizzare

02:23.440 --> 02:26.630
il nome e l'età in costanti indipendenti, o variabili.

02:26.630 --> 02:28.480
Proprio come la destrutturazione degli array,

02:28.480 --> 02:31.840
la destrutturazione degli oggetti funziona sia con const che con let.

02:31.840 --> 02:33.010
Qui mi affiderò a const.

02:33.010 --> 02:34.930
Ora possiamo usare le parentesi graffe

02:34.930 --> 02:37.090
sul lato sinistro del segno di uguale.

02:37.090 --> 02:38.883
Anche se una nuova sintassi, credo.

02:39.920 --> 02:43.750
E facciamo in modo che il nostro oggetto, o la variabile, punti all'oggetto

02:43.750 --> 02:44.890
sul lato destro.

02:44.890 --> 02:46.110
A proposito, si noti che non

02:46.110 --> 02:48.770
si tratta di un tipo di oggetto che sto assegnando qui.

02:48.770 --> 02:51.200
Non ho i due punti qui.

02:51.200 --> 02:54.080
In realtà si tratta solo di parentesi graffe come queste

02:54.080 --> 02:58.210
sul lato sinistro, senza i due punti dopo il nome della costante.

02:58.210 --> 03:01.000
Quindi non sto assegnando il tipo di valore che potrebbe essere

03:01.000 --> 03:02.720
memorizzato a una costante.

03:02.720 --> 03:05.470
In realtà sto solo usando una sintassi speciale.

03:05.470 --> 03:08.450
Perché ora possiamo anche fare riferimento

03:08.450 --> 03:11.340
ai nomi delle proprietà che abbiamo in un

03:11.340 --> 03:13.920
oggetto, ad esempio nome ed età, per

03:13.920 --> 03:18.030
estrarre i valori di queste chiavi da persona e memorizzarli

03:18.030 --> 03:21.283
in costanti con lo stesso nome.

03:23.290 --> 03:24.390
Ora sto ricevendo

03:24.390 --> 03:27.820
degli errori perché in cima ho già una variabile age.

03:27.820 --> 03:30.890
E name risulta essere una variabile disponibile a livello globale

03:30.890 --> 03:32.173
che esiste comunque.

03:33.240 --> 03:34.940
Quindi, la soluzione sarebbe

03:34.940 --> 03:38.313
quella di utilizzare un nome di chiave diverso, ad

03:40.240 --> 03:41.920
esempio FirstName.

03:41.920 --> 03:45.020
E ora possiamo estrarre il valore in base a quella chiave.

03:45.020 --> 03:46.900
Ecco come funziona la destrutturazione degli oggetti.

03:46.900 --> 03:50.110
La cosa importante è che per la destrutturazione degli

03:50.110 --> 03:52.260
array, gli elementi vengono estratti

03:52.260 --> 03:55.110
in ordine perché un array è un elenco ordinato.

03:55.110 --> 03:58.110
Negli oggetti, l'ordine non è sempre garantito e quindi

03:58.110 --> 04:00.720
non si estraggono gli elementi per posizione, ma

04:00.720 --> 04:02.070
per nome della chiave.

04:02.070 --> 04:04.790
Quindi i valori o i nomi specificati tra

04:04.790 --> 04:05.930
le parentesi graffe

04:05.930 --> 04:07.630
non sono arbitrari.

04:07.630 --> 04:09.700
Qui non si possono fare nomi.

04:09.700 --> 04:13.860
Devono essere nomi di proprietà che si trovano nell'oggetto, in modo

04:13.860 --> 04:16.010
che i valori di queste chiavi possano

04:16.010 --> 04:18.160
essere estratti dall'oggetto e poi

04:18.160 --> 04:20.600
memorizzati in costanti o variabili con

04:20.600 --> 04:21.880
lo stesso nome.

04:21.880 --> 04:24.120
Se si desidera sovrascrivere questo nome,

04:24.120 --> 04:25.970
lo si può fare con i due punti qui.

04:25.970 --> 04:28.050
Anche in questo caso, non si tratta di un'assegnazione di tipo.

04:28.050 --> 04:29.680
Imposta solo un nuovo nome.

04:29.680 --> 04:31.970
Quindi questa è tutta sintassi JavaScript, non

04:31.970 --> 04:33.820
ha nulla a che fare con Typescript.

04:33.820 --> 04:35.370
Quindi, ad esempio, potremmo

04:35.370 --> 04:38.750
memorizzare questo dato in una costante UserName.

04:38.750 --> 04:39.840
E quindi, in seguito,

04:39.840 --> 04:44.040
possiamo consolarci. registra il nome utente e l'età, ma non

04:44.040 --> 04:45.290
il nome di battesimo,

04:45.290 --> 04:47.870
perché in pratica sovrascrive il nome di battesimo

04:47.870 --> 04:50.900
come nome utente nella costante che creiamo quando estraiamo

04:50.900 --> 04:52.790
i valori qui.

04:52.790 --> 04:55.880
L'età non viene sovrascritta, quindi possiamo usarla così.

04:55.880 --> 04:58.183
Anche in questo caso, non si tratta di un'assegnazione di tipo.

04:58.183 --> 05:00.210
Questa è la sintassi di JavaScript,

05:00.210 --> 05:03.680
in cui rinominiamo con un alias una proprietà che stiamo

05:03.680 --> 05:05.500
estraendo da una persona.

05:05.500 --> 05:07.430
Inoltre, come per l'array, l'oggetto

05:07.430 --> 05:09.840
persona non è cambiato.

05:09.840 --> 05:13.380
In realtà, copiamo questi valori dall'oggetto.

05:13.380 --> 05:15.643
E quindi otteniamo questo risultato.
