WEBVTT

00:00.000 --> 00:02.410
(silêncio) -: Assim, já vemos como o

00:02.410 --> 00:04.190
TypeScript pode nos ajudar

00:04.190 --> 00:06.200
durante o desenvolvimento.

00:06.200 --> 00:10.560
Agora, também sabemos que existe um tipo de número em JavaScript.

00:10.560 --> 00:14.010
E nós podemos vê-lo com o tipo de operador embutido.

00:14.010 --> 00:15.781
Isto agora não é específico do TypeScript,

00:15.781 --> 00:17.560
é um operador embutido e uma palavra-chave

00:17.560 --> 00:20.420
suportada pelo JavaScript.

00:20.420 --> 00:22.910
Podemos usá-lo para obter o tipo de um determinado valor.

00:22.910 --> 00:27.050
Portanto, aqui, poderíamos consolar o tipo de trava número um.

00:27.050 --> 00:27.992
E o que veremos se fizermos

00:27.992 --> 00:30.780
isso é que, assim que compilarmos isto, executaremos

00:30.780 --> 00:32.623
o código atualizado.

00:33.780 --> 00:37.040
Aqui, nós imprimimos o número para o console.

00:37.040 --> 00:39.330
Agora nós fazemos isso, graças a esta saída

00:39.330 --> 00:41.180
aqui, e graças ao tipo de operador e

00:41.180 --> 00:43.770
em Vanilla JavaScript, sem TypeScript, poderíamos

00:43.770 --> 00:46.710
usar isso para sempre melhorar nossa função aqui.

00:46.710 --> 00:51.500
Poderíamos verificar se o tipo de número é igual ao número.

00:51.500 --> 00:54.300
Desculpe-me, tipo de n1 quero dizer, se

00:54.300 --> 00:56.350
isso for igual ao número, e também

00:56.350 --> 01:00.710
poderíamos verificar se o tipo de n2 é igual ao número.

01:00.710 --> 01:02.349
e somente realizar nossa

01:02.349 --> 01:05.220
operação aqui se for um erro de lançamento

01:05.220 --> 01:07.860
ou fazer o contrário e verificar se

01:07.860 --> 01:10.820
não é igual, ou se n2 não é igual.

01:10.820 --> 01:13.230
E se um dos dois não for um número, então

01:13.230 --> 01:16.360
poderíamos lançar um novo erro onde dizemos,

01:16.360 --> 01:19.690
entrada incorreta. Esta seria uma forma não

01:19.690 --> 01:22.300
TypeScript de garantir que não podemos

01:22.300 --> 01:25.700
chamar esta função com uma string aqui.

01:25.700 --> 01:26.760
Se eu fizer isso agora, e

01:26.760 --> 01:29.060
eu recompilar, recebemos nosso erro de TypeScript,

01:29.060 --> 01:30.830
mas vamos ignorar isso por enquanto.

01:30.830 --> 01:31.730
Se repetirmos isto,

01:31.730 --> 01:33.100
recebemos a entrada incorreta,

01:33.100 --> 01:34.940
que estamos lançando nós mesmos.

01:34.940 --> 01:38.080
Assim, agora nós endurecemos a disfunção em JavaScript,

01:38.080 --> 01:39.930
ela falha em tempo de execução, mas

01:39.930 --> 01:41.970
falhar aqui pode ser melhor do que mostrar

01:41.970 --> 01:44.950
uma saída incorreta que nós tínhamos antes.

01:44.950 --> 01:47.640
Portanto, esta seria uma forma de verificar as entradas em

01:47.640 --> 01:48.715
apenas JavaScript.

01:48.715 --> 01:50.640
Você não precisa de TypeScript para isso.

01:50.640 --> 01:53.200
Isso é código JavaScript comum.

01:53.200 --> 01:54.033
Mas, é claro, esta abordagem

01:54.033 --> 01:55.160
tem desvantagens.

01:55.160 --> 01:57.160
Às vezes é a coisa certa a fazer.

01:57.160 --> 02:01.440
Às vezes, você só pode validar certas entradas em tempo de execução.

02:01.440 --> 02:03.150
Mas o lado negativo está aqui, estamos

02:03.150 --> 02:05.480
verificando algo que podemos realmente evitar

02:05.480 --> 02:08.950
durante o desenvolvimento com o TypeScript.

02:08.950 --> 02:11.180
Portanto, sim, estamos cometendo um erro.

02:11.180 --> 02:14.210
E em nossa aplicação podemos ter incorporado medidas que

02:14.210 --> 02:16.860
podem então recair em algum outro comportamento

02:16.860 --> 02:19.080
para salvar a aplicação em execução.

02:19.080 --> 02:20.750
Mas mesmo assim, estamos cometendo

02:20.750 --> 02:24.180
um erro, que não é realmente necessário para ocorrer em primeiro lugar.

02:24.180 --> 02:27.350
Poderíamos tê-lo evitado com o TypeScript.

02:27.350 --> 02:28.830
E aqui, realmente vemos a diferença

02:28.830 --> 02:30.400
entre JavaScript e TypeScript, quando

02:30.400 --> 02:31.450
se trata de tipos.

02:31.450 --> 02:33.750
O JavaScript é datilografado dinamicamente, o

02:33.750 --> 02:35.610
que significa que é perfeitamente correto

02:35.610 --> 02:36.880
que tenhamos uma variável

02:36.880 --> 02:39.100
que inicialmente pode conter um número, onde

02:39.100 --> 02:41.600
posteriormente lhe atribuímos uma string.

02:41.600 --> 02:44.500
E é por isso que temos que digitar o operador para

02:44.500 --> 02:48.024
que possamos verificar o tipo atual de algo em tempo de execução

02:48.024 --> 02:50.124
se tivermos algum código que dependa

02:50.124 --> 02:52.267
de um determinado tipo.

02:52.267 --> 02:53.570
O TypeScript, por outro

02:53.570 --> 02:55.094
lado, é datilografado estaticamente,

02:55.094 --> 02:58.480
o que significa que definimos os tipos de variáveis e parâmetros

02:58.480 --> 03:01.740
que terminam durante o desenvolvimento, eles não mudam repentinamente

03:01.740 --> 03:04.980
durante o tempo de execução.

03:04.980 --> 03:05.813
Agora, é claro,

03:05.813 --> 03:09.090
como o TypeScript é compilado para JavaScript, teoricamente

03:09.090 --> 03:10.660
eles poderiam.

03:10.660 --> 03:12.510
Mas se usamos TypeScript, e escrevemos

03:12.510 --> 03:13.790
código onde de repente

03:13.790 --> 03:17.530
atribuímos um novo tipo de dado em uma variável, onde anteriormente

03:17.530 --> 03:19.840
dissemos que este deveria ser um número,

03:19.840 --> 03:22.900
por exemplo, e agora estamos atribuindo uma string,

03:22.900 --> 03:25.810
então recebemos um erro durante o desenvolvimento,

03:25.810 --> 03:27.480
de modo que somos forçados a ser

03:27.480 --> 03:29.670
claros quanto aos tipos, algo pode ou

03:29.670 --> 03:32.120
não segurar.

03:32.120 --> 03:33.710
Essa é a diferença aqui.

03:33.710 --> 03:36.620
Portanto, não queremos realmente usar implementações

03:36.620 --> 03:38.330
ou soluções como essa, se pudermos

03:38.330 --> 03:40.810
evitar isso com o TypeScript.

03:40.810 --> 03:42.200
Ainda assim, é importante

03:42.200 --> 03:43.890
saber que o JavaScript Naturalmente,

03:43.890 --> 03:46.400
conhece o conceito de tipos.

03:46.400 --> 03:48.740
Ele conhece alguns tipos como números,

03:48.740 --> 03:50.640
cordel e booleano.

03:50.640 --> 03:52.300
Mas usar isso sempre significa que

03:52.300 --> 03:53.540
só podemos falhar em tempo

03:53.540 --> 03:56.400
de execução ao invés de durante o desenvolvimento, que é um

03:56.400 --> 03:58.700
lugar melhor para nós como desenvolvedor.

03:58.700 --> 04:01.550
Ele nos permite corrigir bugs mais cedo.

04:01.550 --> 04:02.840
E, além disso, o JavaScript

04:02.840 --> 04:05.410
só conhece alguns tipos.

04:05.410 --> 04:07.170
Como você aprenderá ao longo deste curso.

04:07.170 --> 04:10.540
O TypeScript conhece muito mais tipos do que o JavaScript.

04:10.540 --> 04:14.450
Assim como a verificação do tempo de execução não é realmente tão flexível

04:14.450 --> 04:18.030
ou não tão potente quanto o que podemos fazer com o TypeScript.

04:18.030 --> 04:19.490
E por todas estas razões, esta abordagem

04:19.490 --> 04:20.660
não é, na verdade, a abordagem

04:20.660 --> 04:22.550
que queremos utilizar aqui.

04:22.550 --> 04:26.540
Às vezes pode ser útil obter o tipo em tempo de execução.

04:26.540 --> 04:28.790
Mas às vezes, como neste exemplo, é muito

04:28.790 --> 04:31.740
melhor obtê-lo durante o desenvolvimento.

04:31.740 --> 04:34.280
A única coisa importante a reconhecer, naturalmente,

04:34.280 --> 04:36.070
é que com o TypeScript, você só tem suporte

04:36.070 --> 04:38.670
durante o desenvolvimento, não em tempo de execução,

04:38.670 --> 04:39.596
porque estes recursos

04:39.596 --> 04:41.610
e verificações TypeScript não estão incorporados

04:41.610 --> 04:44.650
no mecanismo JavaScript para que a lógica não possa ser executada

04:44.650 --> 04:51.223
no navegador, ela só pode executar durante o desenvolvimento quando você compila seu código.
