WEBVTT

00:02.370 --> 00:05.290
解说员：现在, 我们能够获取用户输入,

00:05.290 --> 00:11.420
并借助TypeScript（此处的驱动验证逻辑）进行所有验证｡

00:11.420 --> 00:13.810
让我们继续, 确保我们对收集的用户输入做更多的事情,

00:13.810 --> 00:18.420
而不仅仅是在控制台中输出｡

00:18.420 --> 00:21.330
因为现在, 我们正在做的当然是｡

00:21.330 --> 00:26.030
最后, 我只是打印我们收集的东西契约信息来做控制台,

00:26.030 --> 00:30.300
这不是我们在这个应用程序中的最终目标｡

00:30.300 --> 00:34.290
相反, 我们的目标应该是根据此模板呈现此项目列表,

00:34.290 --> 00:41.550
其中每个项目项都基于此模板｡

00:41.550 --> 00:45.750
我们输出在这里收集的信息｡ 

00:45.750 --> 00:48.520
所以, 这将是下一件事, 我想工作｡ 

00:48.520 --> 00:55.440
除了这里有我们的项目输入子句, 它负责呈现论坛和收集用户输入,

00:55.440 --> 01:03.230
我还想有子句的数量, 它负责呈现一个项目列表｡

01:03.230 --> 01:06.100
实际上, 我们将把它分成两个子句｡ 

01:06.100 --> 01:07.650
清单的一个子句,

01:07.650 --> 01:11.000
以及清单中每个项目项目的一个类别｡

01:11.000 --> 01:14.970
然后, 我们需要找到某种方法, 将这里收集的输入传递到我们的项目列表中,

01:14.970 --> 01:20.650
并向其中添加一个新项｡

01:20.650 --> 01:23.420
因此, 让我们一步一步地解决这个问题,

01:23.420 --> 01:26.880
我会说, 让我们从添加一个项目列表类开始｡

01:26.880 --> 01:29.380
现在, 在您添加的确切位置, 由您决定｡ 

01:29.380 --> 01:36.430
顺序并不重要, 因为Java脚本最终会在执行之前完全解析整个文件｡

01:36.430 --> 01:38.860
因此, 它将意识到所有类｡ 

01:38.860 --> 01:41.990
不过, 我还是将它添加到项目输入子句的上面,

01:41.990 --> 01:50.500
因为我有点依赖项目列表子句, 我将在项目输入类中构建该子句, 但它确实很重要｡

01:50.500 --> 02:01.170
这里我有一个项目列表子句, 项目列表, 这个子句的概念和我们在项目输入中所做的有点关系｡

02:01.170 --> 02:06.930
我想在这里找到我的模板, 然后在应用程序的某个地方渲染它｡

02:06.930 --> 02:09.480
因此, 我们可以再次添加一个构造函数,

02:09.480 --> 02:15.310
我们可以添加所需的字段, 最后还需要模板元素和宿主元素,

02:15.310 --> 02:22.030
因此, 我们可以将这两个元素都添加到项目列表中｡

02:22.440 --> 02:25.190
我们还需要元素本身,

02:25.190 --> 02:29.640
我认为是具体的元素, 它被渲染了｡

02:29.640 --> 02:31.800
但类型会有所不同｡ 

02:31.800 --> 02:38.330
宿主元素仍然是一个div, 因为我也想在这个div中呈现这个列表.

02:38.330 --> 02:40.970
但是我们所呈现的具体元素｡ 

02:40.970 --> 02:43.960
当然, 它不是一个表单元素, 但是如果我们看一下这里的列表模板,

02:43.960 --> 02:48.520
我们会看到它里面有一个部分｡

02:48.520 --> 02:51.010
我们有一个section元素｡ 

02:51.010 --> 02:57.040
这里没有元素和section元素, 所以我们只有一个普通的HTML元素,

02:57.040 --> 03:00.490
因为每个元素都有这个类型的税.

03:00.490 --> 03:03.060
如果是的话, 还有更专门的类型,

03:03.060 --> 03:05.710
我们可以只使用HTML类型｡

03:05.710 --> 03:10.710
所以, 现在我们当然需要访问这些元素｡ 

03:10.970 --> 03:15.600
所以, 我们可以把这里的代码从项目的构造函数中复制出来,

03:15.600 --> 03:24.730
输入到项目的构造函数列表中, 然后调整一些东西｡

03:24.730 --> 03:29.420
例如, 我的模板元素现在当然没有项目输入的概念｡

03:29.420 --> 03:32.150
现在这是项目列表｡ 

03:32.150 --> 03:36.660
所以, 让我们复制它, 并在这里使用它来选择元素｡ 

03:36.660 --> 03:39.760
我仍然会付出代价, 我仍然确信我得到了它,

03:39.760 --> 03:42.710
所以这不会改变.

03:42.710 --> 03:45.520
主机元素仍然是死亡与ID应用程序｡ 

03:45.520 --> 03:47.820
所以这一点没有改变｡ 

03:47.820 --> 03:52.070
然后我导入我的内容, 然后我, 嗯, 商店,

03:52.070 --> 03:53.530
第一个元素｡

03:53.530 --> 03:55.380
关导入, 模板｡ 

03:55.380 --> 03:57.780
基本上, 模板中的第一个元素是section,

03:57.780 --> 04:01.590
我将其存储在这里的element属性中｡

04:01.590 --> 04:04.430
但是 ,  这 不是 HTML 表单 元素 ｡ 

04:04.430 --> 04:07.210
这里只是一个HTML元素｡ 

04:07.210 --> 04:11.710
现在我们也可以在这里分配一个ID, 实际上, 应该是动态的,

04:11.710 --> 04:16.970
而不是硬编码的, 因为我们将有多个项目列表｡

04:16.970 --> 04:21.220
我希望在最终的应用程序中有工具列表, 一个用于项目的行为,

04:21.220 --> 04:29.895
一个用于项目的执行, 它们提供了, 我希望得到一些额外的信息给构造器｡

04:29.895 --> 04:35.703
项目的类型, 我会使用stats, TypeScript快捷方式｡

04:35.703 --> 04:39.250
您将学习如何在参数（private或public）之前加入存取子,

04:39.250 --> 04:51.730
以自动建立同名的属性, 并将传递给这个参数的值储存在同名的属性中｡

04:51.730 --> 04:55.040
因此, 现在这个类也将有一个要键入的属性名｡ 

04:55.040 --> 04:58.790
现在的问题是, 这个类型参数的类型是什么？

04:58.790 --> 05:03.640
这实际上应该是一个文本类型和一个联合类型｡ 

05:03.640 --> 05:07.270
它要么处于活动状态, 要么已完成｡ 

05:07.270 --> 05:11.050
我们甚至有正在进行的项目或已完成的项目｡ 

05:11.050 --> 05:16.080
这就是我希望在实例化项目列表时得到的参数｡

05:16.080 --> 05:21.870
而与爸爸我们所要键入的属性D一样, ID应该是以此为基础的｡

05:21.870 --> 05:25.090
它应该是, 而对于爸爸, 我在这里使用了一个模板文字｡ 

05:25.090 --> 05:33.640
它应该是仪表板项目类型, 即活动仪表板项目或已完成仪表板项目

05:33.640 --> 05:35.070
这是我的主意

05:35.070 --> 05:40.380
您可以始终使用此点类型, 以便TypeScript了解我们正在使用此属性,

05:40.380 --> 05:41.890
而不是未使用｡

05:41.890 --> 05:46.200
这样, 我们就可以访问所有核心元素, 并向该部分添加一个ID,

05:46.200 --> 05:50.790
该ID来自模板｡

05:50.790 --> 05:53.650
现在, 当然, 我们要一个, 我们要渲染它对不对？

05:53.650 --> 05:58.600
这就是我们的想法, 再一次, 用私有方法.

05:58.600 --> 06:00.540
附上正义｡ 

06:00.540 --> 06:06.310
我们在项目输入中有它, 在那里它现在是目标队列｡

06:06.310 --> 06:12.750
好吧, 把这个附加到Dom, 现在把爸爸列表呈现给Dom｡

06:12.750 --> 06:16.610
因此, 我实际上将执行与项目表单附加相同的操作,

06:16.610 --> 06:19.223
而不是附加｡

06:20.070 --> 06:24.230
所以我们可以复制这条线, 然后加上态度｡ 

06:24.230 --> 06:28.420
我有我的主体元素, 我想要插入相邻元素｡

06:28.420 --> 06:30.240
始, 而此应素后｡ 

06:30.240 --> 06:33.300
我们从这里的模板中提取｡ 

06:33.300 --> 06:36.990
但是, 我并不想在开始之后, 而是在结束之前,

06:36.990 --> 06:45.870
也就是在结束之前, 把宿主元素固定下来, 然后我们可以在构造函数中调用attach,

06:45.870 --> 06:51.763
把我们创建的元素附加到Dom上.

06:53.880 --> 06:56.370
现在, 与项目输入相比,

06:56.370 --> 06:59.630
该列表有一个重要的差异｡

06:59.630 --> 07:03.220
这并不是仅仅将列表添加到Dom就完成了｡ 

07:03.220 --> 07:05.270
输入完成了吧？

07:05.270 --> 07:07.130
这里的形式已经完成了｡ 

07:07.130 --> 07:08.720
我们有所有的投入｡ 

07:08.720 --> 07:12.420
我们需要做的就是设置一个事件侦听器｡ 

07:12.420 --> 07:16.673
在这里的列表中, 我们实际上还没有空的｡

07:16.673 --> 07:21.130
例如, H到技术, 我想在那里添加一些文本｡ 

07:21.130 --> 07:22.990
所以我会加一个数字｡ 

07:22.990 --> 07:26.020
新方法添加到私有方法｡ 

07:26.020 --> 07:29.120
渲染或内容可以是配件名称｡ 

07:29.120 --> 07:36.862
我的想法是在模板中的空白处填上一个生命年｡

07:36.862 --> 07:37.780
为了那个｡ 

07:37.780 --> 07:40.040
让我们转到dead render content方法,

07:40.040 --> 07:41.580
这里有几件事我想做｡

07:41.580 --> 07:47.200
一件事是统计死亡无序列表, 这是我的项目列表的一部分在这里｡

07:47.200 --> 07:48.640
我想加个ID｡ 

07:48.640 --> 07:50.860
当然你不必这么做, 但我想这样做,

07:50.860 --> 07:54.390
如果我们以后需要选择它, 我们可以用这些来做｡

07:54.390 --> 07:58.220
我将在这里创建一个列表ID, 它存储在一个常量中,

07:58.220 --> 08:00.190
这将是一个模板文字,

08:00.190 --> 08:04.100
因此它将是一个字符串, 我们可以在其中注入动态内容,

08:04.100 --> 08:09.100
我希望基于周围项目列表的类型, 因此关闭周围部分,

08:09.370 --> 08:14.370
然后添加项目列表｡

08:15.220 --> 08:19.700
现在我们可以访问订单列表, 它在我们的元素中得到,

08:19.700 --> 08:23.820
这是统计部分年, 右边的元素是死部分｡

08:23.820 --> 08:27.360
所以要得到里面的无序列表, 我们可以, 例如,

08:27.360 --> 08:30.940
使用一个查询选择器, 搜索第一个, 在这个例子中,

08:30.940 --> 08:33.120
只搜索无序列表｡

08:33.120 --> 08:35.720
我们知道我们会得到一个, 因为我们知道会有一个, 然后我们可以在这里添加一个ID,

08:35.720 --> 08:38.280
这应该是列表ID｡

08:38.280 --> 08:40.280
这是我想做的一件事｡ 

08:40.280 --> 08:44.970
我还想在这里设置标记年龄的文本内容,

08:44.970 --> 08:50.200
为此, 我们可以访问此元素, 查询选择器｡

08:50.200 --> 08:53.020
找到第一个也是唯一的HQ标记｡ 

08:53.020 --> 08:56.340
我们知道我们会找到一个,

08:56.340 --> 09:05.610
因此感叹号排除死空的情况, 并设置文本内容等于这类型的大写｡

09:05.610 --> 09:08.130
记住类型永远是活动的｡ 

09:08.130 --> 09:10.060
我们已经完成了两个歌剧案子｡ 

09:10.060 --> 09:15.060
我们将其转换为所有大写加项目, Sten也是如此｡ 

09:16.200 --> 09:19.853
简单地说就是正科级的标题｡ 

09:21.970 --> 09:25.220
现在, 我们, 我们基本上完成了｡ 

09:25.220 --> 09:27.580
我们还没有该列表中的项目｡ 

09:27.580 --> 09:30.230
我们稍后会处理这个问题, 但我们基本上已经完成了｡ 

09:30.230 --> 09:37.210
例如, 我们可以在将其附加到Dom之后将其称为渲染内容或｡

09:37.210 --> 09:39.210
现在, 如果能看到它们在行动, 那就太好了｡ 

09:39.210 --> 09:45.523
当然, 同样, 列表项结束于将丢失, 但它会很高兴看到一些在这里的行动｡

09:46.690 --> 09:49.620
好吧, 让我们转到文件的底部, 在那里我们实例化项目输入,

09:49.620 --> 09:55.200
在那里我们不能总是实例化我们的列表｡

09:55.200 --> 10:01.230
我们有活动项目列表, 我们实例化它, 但是调用新项目列表｡

10:01.230 --> 10:06.040
我们必须传入类型参数, 它要么是active要么是finished.

10:06.040 --> 10:09.950
因为我呈现的是活动列表, 所以我当然传递了非活动列表｡

10:09.950 --> 10:13.140
这里有一个完成的项目列表,

10:13.140 --> 10:15.290
我当然通过了｡

10:15.290 --> 10:18.673
如果我们现在确定它编译时没有错误｡ 

10:19.520 --> 10:23.090
因此, 如果你返回, 你应该看到这两个空白部分,

10:23.090 --> 10:27.770
标题在这里, 空白区域将添加后面的项目,

10:27.770 --> 10:33.390
项目项目将被添加｡

10:33.390 --> 10:37.440
现在暂时, 我们还没有这样的项目物品, 斯诺｡ 

10:37.440 --> 10:43.660
因此, 下一步, 我们应该设法确保在单击“添加项目”时,

10:43.660 --> 10:49.420
在代码中创建一个新项目｡

10:49.420 --> 10:53.730
所以一个新的数据结构代表一个项目,

10:53.730 --> 10:59.870
然后我们把这个新项目的信息传递给项目的行为｡

10:59.870 --> 11:06.500
在此列出此活动项目部分, 因为默认情况下, 每个新项目都应处于活动状态｡

11:06.500 --> 11:12.080
这将是我们的下一个目标, 同样, 将有许多不同的方式来实现这一目标｡

11:12.080 --> 11:16.703
我们会用下节课我想到的一种方法来做｡
