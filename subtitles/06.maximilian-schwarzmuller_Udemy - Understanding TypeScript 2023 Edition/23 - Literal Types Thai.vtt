WEBVTT

00:02.350 --> 00:03.921
ผู้สอน: ตอนนี้เรามีประเภทสหภาพที่นี่

00:03.921 --> 00:09.764
มาสร้างแนวคิดเกี่ยวกับประเภทสหภาพและแนะนำประเภทตัวอักษร

00:09.764 --> 00:16.436
ประเภทตามตัวอักษรคือประเภทที่คุณไม่เพียงแค่บอกว่าตัวแปรหรือพารามิเตอร์บางตัวควรคงไว้

00:16.436 --> 00:23.800
สมมติว่าเป็นตัวเลขหรือสตริง แต่คุณมีความชัดเจนมากเกี่ยวกับค่าที่แน่นอนที่ควรคงไว้

00:23.800 --> 00:26.064
เราเห็นก่อนหน้านี้แล้วในพื้นฐาน

00:26.064 --> 00:28.408
ตัวอย่างเช่น Const หมายเลขสอง

00:28.408 --> 00:32.098
ตรงนั้น ถ้าฉันเลื่อนเมาส์ไปที่คุณเห็นประเภทที่สรุปออกมาไม่ใช่ตัวเลข

00:32.098 --> 00:35.680
มันคือ 2 8.

00:35.680 --> 00:37.290
และกลุ่มประเภทอนุมานจำนวนเฉพาะนี้เป็นประเภทตรงนี้

00:37.290 --> 00:41.220
เพราะมันเป็นค่าคงที่

00:41.220 --> 00:48.211
มันจะไม่เปลี่ยนแปลง ดังนั้นกลุ่มประเภทจึงรู้ว่าค่าที่ฉันกำหนดให้นี่คือประเภทที่แน่นอนที่ฉันมี

00:48.211 --> 00:48.211
แน่นอนว่านี่คือตัวเลข

00:48.211 --> 00:56.320
คุณว่า 2 ก็ได้ 8 มาจากประเภทตัวเลข แต่เป็นจำนวนเฉพาะ

00:56.320 --> 00:56.320
และสิ่งนี้ไม่ได้มีอยู่เฉพาะกับตัวเลขเท่านั้น

00:56.320 --> 01:02.860
แต่ยังรวมถึงสตริงและอื่นๆ ด้วย

01:02.860 --> 01:02.860
และโดยเฉพาะอย่างยิ่งสำหรับสตริง มันจะมีประโยชน์มาก

01:02.860 --> 01:13.756
สมมติว่าในฟังก์ชันรวมของเรา เราคาดหวังตัวเลขหรือสตริง และเรารวมมันแตกต่างกันตามสิ่งที่เราได้รับ แต่เรายังต้องการให้ผู้เรียกใช้ฟังก์ชันกำหนดว่าควรส่งคืนผลลัพธ์อย่างไร

01:13.756 --> 01:25.370
เพื่อที่เราจะสามารถบังคับการแปลงได้ จากตัวเลขเป็นสตริงหรือในทางกลับกัน

01:25.370 --> 01:25.370
เราสามารถทำเช่นนี้กับพารามิเตอร์ที่สาม

01:25.370 --> 01:37.240
และเราสามารถตั้งชื่อว่า สมมติว่าเป็นประเภทผลลัพธ์หรือการแปลงผลลัพธ์ หรืออย่างไรก็ตามคุณต้องการตั้งชื่อมัน และฉันต้องการอธิบายสิ่งนี้ด้วยสตริง

01:37.240 --> 01:37.240
ดังนั้นฉันจะตั้งค่าให้พิมพ์สตริง

01:37.240 --> 01:45.625
ตอนนี้ความคิดของฉันคือฉันสามารถเรียกรวมที่นี่ด้วยตัวเลขสองตัวและตัวอย่างเช่นส่งผ่านสตริง

01:45.625 --> 01:55.630
"as-number" และขึ้นอยู่กับคุณว่าจะใช้ตัวระบุใดที่นี่

01:55.630 --> 01:55.630
ด้านล่างเราอาจมี

01:56.260 --> 01:59.357
"as-text" แต่จากนั้นเราอาจมีชุดค่าผสมอื่นที่นี่

02:02.910 --> 02:07.310
CombinedStringAges ที่ฉันส่งผ่านเป็นสองสตริง แต่ฉันยังต้องการส่งออก "as-number"

02:07.310 --> 02:19.950
นี้และนี่จะเป็นกรณีที่พารามิเตอร์ที่สามสามารถเป็นประโยชน์ได้ เพื่อบังคับให้มีการแปลงเพราะถ้าฉันส่งสองสตริงที่นี่ โดยปกติเราจะทำให้มันเป็นสาขาอื่นและเชื่อมมันเข้าด้วยกัน และฉันอาจต้องการส่งคืนค่านี้เป็นตัวเลขแทน

02:19.950 --> 02:34.030
เพื่อที่ฉันจะได้สามารถรวมตัวแทนสตริงรวมล็อกคอนโซลได้ที่นี่

02:34.030 --> 02:34.030
ตอนนี้เราต้องคำนึงถึงตัวระบุเหล่านี้ในฟังก์ชันของเราโดยใส่

02:37.512 --> 02:41.730
resultConversion ไว้ใน if checks ตอนนี้คำถามคือเราต้องการทำอะไรกันแน่

02:41.730 --> 03:03.039
เราต้องการให้แน่ใจว่าเราสามารถบังคับให้เพิ่มสตริงทั้งสองนี้เป็นตัวเลขหรือเราต้องการบังคับผลลัพธ์ไม่ว่าจะเป็นการคำนวณทางคณิตศาสตร์หรือการต่อสตริงให้แปลงเป็นข้อความหรือตัวเลข

03:03.039 --> 03:03.039
หากเราต้องการบังคับการแปลง

03:03.039 --> 03:10.382
เราสามารถเพิ่มเครื่องหมาย if ตรงนี้และตรวจสอบว่าการแปลงผลลัพธ์เท่ากับ "as-number" หรือไม่

03:10.382 --> 03:18.826
และถ้าเป็นกรณีนี้ ฉันต้องการส่งคืนผลลัพธ์ที่มีเครื่องหมายบวกข้างหน้าซึ่งแปลงเป็นตัวเลข ทางเลือกอื่นจะเป็น

03:18.826 --> 03:33.593
parseFloat แต่ที่นี่ฉันจะไปบวกเพราะมันสั้นกว่าเล็กน้อยและอย่างอื่นฉันต้องการส่งคืนผลลัพธ์เป็นString เพื่อบังคับให้เอาต์พุตเป็นสตริง

03:34.570 --> 03:42.300
ตอนนี้เราทำการคำนวณตามประเภทจริงที่เราได้รับ แต่จากนั้นเราแปลงเป็นผลลัพธ์ซึ่งเป็นวิธีหนึ่งในการทำเช่นนั้น

03:42.300 --> 03:51.020
และถ้าเราบันทึกมันแล้วเราคอมไพล์ไฟล์นี้ เราจะเห็นว่านี่คือผลลัพธ์ที่ฉันได้รับและเราได้ผลลัพธ์นั้น ตัวอย่างเช่น

03:51.020 --> 03:54.759
สำหรับการรวมสตริงของเราที่นี่ เพราะอย่างที่ฉันพูด

03:54.759 --> 03:58.520
การรวมกันนั้นการคำนวณจะดำเนินการตามประเภทที่เราป้อนซึ่งนี่คือสตริง

03:58.520 --> 04:05.860
ดังนั้นเราจึงเชื่อมมันเข้าด้วยกัน จากนั้นเราแค่แปลงเป็นผลลัพธ์

04:05.860 --> 04:19.180
ตรรกะทางเลือกคือการตรวจสอบประเภทที่นี่ และทำการดำเนินการอื่นตามประเภทการส่งคืนที่เราระบุที่นี่

04:19.180 --> 04:19.180
ดังนั้นเราสามารถแสดงความคิดเห็นนี้และแทนที่จะพูดว่าหากประเภทของอินพุตที่หนึ่งเป็นตัวเลขและประเภทของอินพุตที่สองคือตัวเลข

04:27.890 --> 04:30.865
หรือถ้า resultConversion เท่ากับ "as-number"

04:30.865 --> 04:38.794
ฉันต้องการรวมค่าเช่นนี้และตอนนี้เพื่อหลีกเลี่ยง ข้อผิดพลาดนี้ ฉันบังคับให้แปลงเป็นตัวเลขโดยการเพิ่มเครื่องหมายบวกข้างหน้าแต่ละอินพุต

04:38.794 --> 04:48.490
เพื่อให้แต่ละอินพุตถูกแปลงเป็นตัวเลขและรับประกันว่าจะเป็นตัวเลขก่อนที่จะรวมเข้าด้วยกัน

04:48.490 --> 04:54.610
หมายเหตุด้านข้าง: หากคุณส่งผ่านสตริงที่ไม่สามารถแปลงเป็นตัวเลข

04:54.610 --> 04:58.800
เช่น Max คุณจะได้รับ NaN ไม่ใช่ตัวเลข

04:58.800 --> 05:00.280
ถ้าอย่างนั้น ในกรณีอื่น

05:00.280 --> 05:03.170
เพื่อให้เราไม่มี "as-number" หรือว่าเราไม่มีการป้อนตัวเลข

05:03.170 --> 05:07.976
เราจึงสร้างมันลงในบล็อกนี้ตรงนี้และตอนนี้ ถ้าฉันส่งคืนผลลัพธ์อีกครั้งที่นี่

05:07.976 --> 05:20.230
จากนั้นเราบันทึกและคอมไพล์ใหม่ เราจะเห็นผลลัพธ์ที่แตกต่างกันในหน้าของเรา

05:20.230 --> 05:20.230
ตอนนี้เราได้

05:20.230 --> 05:22.945
56 ในสองบรรทัดนี้เพราะตอนนี้เราไม่ได้แปลงผลลัพธ์ ดังนั้นเราจึงไม่แปลงสตริงที่ต่อกันสำหรับบรรทัดนี้

05:22.945 --> 05:31.970
แต่เราจะแปลงก่อนที่จะรวมค่าทั้งสองเข้าด้วยกัน

05:31.970 --> 05:31.970
ขึ้นอยู่กับคุณว่าคุณต้องการใช้ตรรกะใด

05:31.970 --> 05:41.180
ฉันต้องการดูแนวคิดเรื่องประเภทตามตัวอักษรซึ่งฉันได้อธิบายไว้ในตอนต้นของการบรรยายนี้อย่างละเอียดยิ่งขึ้น

05:41.180 --> 05:41.180
ฉันกำลังส่ง

05:41.180 --> 05:47.600
"เป็นตัวเลข" และ "เป็นข้อความ" และข้อเสียของธุรกิจที่ตอนนี้เราในฐานะนักพัฒนาซอฟต์แวร์ต้องจดจำค่าเหล่านี้

05:47.600 --> 05:50.450
เราต้องแน่ใจว่าเราจะพิมพ์พลาดที่นี่

05:50.450 --> 05:54.010
ตอนนี้เราสามารถใช้ e-num เพื่อปรับปรุงสิ่งนั้นได้ แต่ถ้าเรามีค่าเพียงสองค่าที่นี่

05:54.010 --> 06:00.940
"as-text" หรือ "as-number" การค้นหาทั้งหมดอาจเป็นประเภทตัวอักษรก็ได้

06:00.940 --> 06:04.173
เราสามารถพูดได้ว่า "ไม่ควรเป็นสตริงใดๆ ควรเป็น

06:04.173 --> 06:15.573
"เป็นตัวเลข" หรือ "เป็นข้อความ"" ดังนั้นเราจึงใช้ประเภทสหภาพรวมกับประเภทตัวอักษร

06:15.573 --> 06:15.573
ประเภทตามตัวอักษรคือประเภทที่ยึดตามสตริงประเภทหลักของคุณ

06:17.987 --> 06:24.750
ตัวเลข และอื่นๆ แต่จากนั้นคุณจะมีเวอร์ชันเฉพาะของประเภท

06:24.750 --> 06:24.750
ในที่นี้

06:24.750 --> 06:27.960
เราอนุญาตโดยเฉพาะสองสตริงนี้ ไม่ใช่สตริงใดๆ แค่สองสตริงนี้

06:27.960 --> 06:34.207
ดังนั้นเราต้องการสตริงสำหรับการแปลงผลลัพธ์ แต่ต้องเป็นหนึ่งในสองค่านี้

06:34.207 --> 06:34.207
ค่าสตริงอื่นๆ

06:34.207 --> 06:37.560
จะไม่ได้รับอนุญาต ดังนั้นนั่นคือแนวคิดเบื้องหลังประเภทตัวอักษร

06:37.560 --> 06:43.700
และบ่อยครั้งที่คุณจะใช้สิ่งนี้ในบริบทของประเภทสหภาพ เพราะคุณไม่ต้องการอนุญาตค่าที่แน่นอนเพียงค่าเดียว คุณสามารถฮาร์ดโค้ดลงในโค้ดของคุณได้

06:43.700 --> 06:49.544
หากเป็นเช่นนั้น แต่คุณต้องการมีค่าที่เป็นไปได้ตั้งแต่สองค่าขึ้นไป

06:49.544 --> 06:52.580
ในกรณีนี้ เราได้ค่าที่เป็นไปได้สองค่า

06:52.580 --> 06:56.240
ตอนนี้เรารับประกันได้ว่าจะได้รับการแปลงผลลัพธ์ที่เป็น

06:56.240 --> 07:00.288
"as-number" หรือ "as-text" และตัวอย่างที่นี่ ถ้าตอนนี้ฉันพยายามเปรียบเทียบสิ่งนี้กับ

07:00.288 --> 07:10.360
as-numbe เพราะฉันพิมพ์ผิด กลุ่มประเภทคือ สามารถบอกฉันได้ที่นี่ใน IDE และแน่นอนว่าเราบันทึกและคอมไพล์ที่นี่ในเทอร์มินัล เพราะมันรู้ว่า

07:10.360 --> 07:18.940
as-numbe ที่ไม่มี r ในตอนท้ายจะไม่มีทางเป็นค่าที่ถูกต้องสำหรับ resultConversion เพราะฉันตั้งค่า union type นี้ด้วย

07:18.940 --> 07:24.563
ประเภทตัวอักษรเหล่านี้

07:25.550 --> 07:31.590
ตอนนี้เราได้รับความปลอดภัยเพิ่มเติมอีกประเภทหนึ่งและมั่นใจว่าเราจะใช้สิ่งนี้ไม่ถูกต้อง

07:31.590 --> 07:34.720
หลักสูตรเดียวกันสำหรับการส่งผ่านค่า หากเราพิมพ์ผิด เราจะได้รับข้อผิดพลาดก็ต่อเมื่อเราใช้

07:34.720 --> 07:49.562
"as-number" หรือ "as-text" เราได้รับอนุญาตให้คอมไพล์สิ่งนี้ตามที่คุณเห็น และตอนนี้คอมไพล์สิ่งนี้ ใช้งานได้และเราได้เหมือนกัน ออกเหมือนเดิมที่นี่

07:49.562 --> 07:49.562
ดังนั้นสิ่งเหล่านี้จึงเป็นประเภทตัวอักษรที่มีประโยชน์อย่างยิ่งเมื่อใช้ร่วมกับประเภทสหภาพ
