WEBVTT

00:02.450 --> 00:05.030
講師：ここで関数のオーバーロードから離れ､

00:05.030 --> 00:09.010
もう一つ非常に優れた機能を紹介しましょう｡

00:09.010 --> 00:13.350
そして､ それがオプショナル・チェイニングです｡ 

00:13.350 --> 00:16.720
例えば､ データベースなどのバックエンドからデータを取得するアプリケーションがあり､

00:16.720 --> 00:29.500
あるオブジェクトで特定のプロパティが定義されているかどうかが確実に分からないとします｡

00:29.500 --> 00:36.380
fetchedUserDataがあるとします｡ fetchedUserDataは､ 取得したユーザーに関するオブジェクトである可能性があります｡

00:36.380 --> 00:39.705
そこにはIDがあり､ Maxという名前があり､

00:39.705 --> 00:53.950
さらに､ タイトルと説明文を持つオブジェクトである別のプロパティJobを期待するかもしれません｡

00:53.950 --> 00:56.900
さて､ このようなデータが得られれば､ もちろんそれを使って仕事をすることができます｡ 

00:56.900 --> 01:00.150
もっと複雑なこともできるかもしれませんが､

01:00.150 --> 01:06.871
ここではまず､ 私がやっているのは職種をアップロードすることだけだとします｡

01:06.871 --> 01:09.940
開発用サーバーを立ち上げ､ ウォッチモードでコンパイルを実行した状態でこれを保存すると､

01:09.940 --> 01:14.420
CEOがここに表示されます｡

01:14.420 --> 01:17.395
しかし､ バックエンドからデータを取得する場合､

01:17.395 --> 01:22.395
何らかの理由で必要なデータをすべて取得できなかったり､

01:23.080 --> 01:30.490
あるデータがこの時点では設定されていなかったりすることがあります｡

01:30.490 --> 01:34.730
より大規模で複雑なアプリケーションでは､ オブジェクトのプロパティが設定されているかどうか､

01:34.730 --> 01:45.340
あるいは未定義かどうかがはっきりしない､ ネストされたデータを持つ構造体を扱うことがあります｡

01:45.340 --> 01:53.180
ここでjobが存在しないとします｡ 何らかの理由でjobを取得できない場合､

01:53.180 --> 01:57.843
もちろんエラーが発生します｡

01:57.843 --> 02:01.347
問題は､ このデータがTypeScriptで制御されていないファイルから取得されたデータである場合､

02:01.347 --> 02:15.550
あるいは先ほど言ったようにバックエンドから取得されたデータである場合､ どのデータが返されるか確実に分からないということです｡

02:15.550 --> 02:18.150
さて､ 定義されているかどうかわからない場合､ 通常のJavaScriptでできることは､

02:18.150 --> 02:25.098
jobにアクセスしてみて､ それがうまくいったら続けてtitleにアクセスすることです｡

02:25.098 --> 02:33.520
これは､ 潜在的なオブジェクトに深く入り込む前に､ 何かが存在するかどうかをチェックするJavaScriptの方法です｡

02:33.520 --> 02:39.400
もし未定義であれば､ このコードは実行されず､ したがって実行時エラーが発生します｡

02:39.400 --> 02:42.410
ここでももちろんTypeScriptはジョブが存在しないことを知っていますが､

02:42.410 --> 02:48.470
もしこれがHTTPリクエストの結果のようにTypeScriptが調べることのできないソースから取得されるなら､

02:48.470 --> 02:54.920
これはJavaScriptの実行時エラーを回避する安全な方法でしょう｡

02:54.920 --> 02:58.110
もし､ これが存在するならば､ 以前と同じ出力が得られます｡ 

02:58.110 --> 03:02.233
存在しない場合は､ 少なくともランタイムエラーは発生しない｡

03:02.233 --> 03:07.020
TypeScriptを使うと､ 実はもっといい方法があるんです｡ 

03:07.020 --> 03:10.520
オプションのチェインオペレーターを手に入れたんですね｡ 

03:10.520 --> 03:16.880
定義されているかどうかわからないものの後にクエスチョンマークを付けることができます｡

03:16.880 --> 03:21.600
少なくともTypeScriptバージョン3を使っているのであれば｡  7以上であること｡ 

03:21.600 --> 03:26.300
私のIDEはこれを好まないが､ これはサポートされている構文である｡

03:26.300 --> 03:30.370
これはTypeScriptにこれが存在するかどうか､ もし存在するならばjobにアクセスするかどうかを伝えるもので､

03:30.370 --> 03:36.314
そのためここでは疑問符を追加し､ jobが定義されている場合にのみtitleにアクセスできるようにしている｡

03:36.314 --> 03:39.300
このようにしても､ コンパイルしようとするとエラーが出ます｡

03:39.300 --> 03:44.510
なぜなら､ TypeScriptはジョブが存在しないことを確実に知っているからです｡

03:44.510 --> 03:47.370
しかし､ もしそれがわからなければ､ あるいはこれをコメントアウトすれば､

03:47.370 --> 03:51.840
うまくコンパイルされ､ 以前と同じようにすべてが実行されます｡

03:51.840 --> 04:00.730
このオプションのチェイン演算子は､ オブジェクトデータ内のネストしたプロパティやネストしたオブジェクトに安全にアクセスするためのもので､

04:00.730 --> 04:03.610
クエスチョンマークの前にあるものが未定義であれば､

04:03.610 --> 04:07.061
それ以降はアクセスしないので､ ランタイムエラーは発生しませんが､

04:07.061 --> 04:12.420
その代わりに処理を続行しません｡

04:12.420 --> 04:15.210
そのため､ 裏側では基本的に､ これにアクセスしようとする前に､

04:15.210 --> 04:19.213
これが存在するかどうかをチェックするifチェックにコンパイルされています｡
