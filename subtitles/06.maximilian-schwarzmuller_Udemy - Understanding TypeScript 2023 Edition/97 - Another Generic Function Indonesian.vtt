WEBVTT

00:02.140 --> 00:03.620
-: Jadi mari kita terus berlatih dengan

00:03.620 --> 00:06.220
tipe-tipe generik ini karena saya tahu mereka bisa menjadi

00:06.220 --> 00:08.305
aneh untuk membungkus kepala Anda; Pada akhirnya

00:08.305 --> 00:09.970
mereka benar-benar mudah.

00:09.970 --> 00:12.180
Mari kita buat fungsi generik

00:12.180 --> 00:14.810
rata-rata, hitung dan cetak.

00:14.810 --> 00:19.810
Sekarang fungsi ini harus mengambil beberapa argumen, beberapa parameter.

00:20.330 --> 00:23.470
Mari kita beri nama elemen, tetapi namanya benar-benar

00:23.470 --> 00:26.530
terserah Anda yang harus dari tipe generik.

00:26.530 --> 00:28.340
Karena saya benar-benar tidak peduli tentang

00:28.340 --> 00:30.380
jenisnya, setidaknya dalam hal-hal tertentu.

00:30.380 --> 00:33.400
Jadi, katakanlah kita memiliki satu tipe generik dalam fungsi

00:33.400 --> 00:35.800
ini dan parameter kita adalah tipe tersebut.

00:35.800 --> 00:38.350
Omong-omong, itu semua tipikal untuk tipe generik.

00:38.350 --> 00:40.030
Jika Anda memiliki fungsi generik, maka seringkali

00:40.030 --> 00:42.180
parameter Anda akan bertipe seperti itu.

00:42.180 --> 00:43.890
Tidak harus demikian, tetapi sering kali itulah

00:43.890 --> 00:45.890
cara Anda bekerja dengan fungsi-fungsi generik, seperti

00:45.890 --> 00:46.920
yang akan Anda lihat, saat Anda

00:46.920 --> 00:49.080
mendapatkan lebih banyak pengalaman dengannya.

00:49.080 --> 00:50.670
Jadi di sini kita punya count dan

00:50.670 --> 00:52.350
print dengan tipe generik kita di

00:52.350 --> 00:54.430
sini, dan elemen adalah tipe itu.

00:54.430 --> 00:56.500
Sekarang apa yang ingin saya kembalikan

00:56.500 --> 01:00.300
di sini adalah tuple nienda dengan dua elemen di mana elemen

01:00.300 --> 01:03.190
pertama haruslah elemen saya sendiri dan elemen

01:03.190 --> 01:07.070
kedua haruslah string deskripsi.

01:07.070 --> 01:10.160
Mungkin kita menamainya menghitung dan menggambarkan, oleh karena itu.

01:10.160 --> 01:15.160
Jadi di sini saya mendapatkan teks deskripsi saya, dan di sini saya akan mengatakan

01:15.410 --> 01:19.890
tidak ada nilainya, dan saya ingin menggunakannya jika kita mengoper

01:19.890 --> 01:22.620
elemen yang tidak memiliki panjang.

01:22.620 --> 01:25.570
Karena ide saya dengan count dan describe adalah bahwa kita

01:25.570 --> 01:29.040
bisa memasukkan array atau string, dan kita mendapatkan kembali jumlah

01:29.040 --> 01:32.040
karakter atau elemen dalam string atau array itu.

01:32.040 --> 01:34.040
Jadi jika kita mendapatkan string

01:34.040 --> 01:37.440
kosong atau array kosong, saya ingin menggunakan

01:37.440 --> 01:42.440
got no value, tetapi di sini jika saya memeriksa bahwa panjang titik elemen

01:43.210 --> 01:46.170
lebih besar dari nol, maka saya ingin mengatur

01:47.430 --> 01:52.430
teks deskripsi menjadi got plus elemen dot length plus elemen.

01:55.850 --> 01:58.100
Anda bisa lebih spesifik dan memeriksa

01:58.100 --> 02:03.100
apakah panjangnya sama dengan satu di sini, dan kemudian mengatakan mendapat

02:06.590 --> 02:11.590
satu elemen, jika panjang elemen lebih besar dari satu, kita memiliki teks

02:11.720 --> 02:13.750
deskripsi yang sama dengan mendapat

02:13.750 --> 02:18.750
ditambah elemen panjang elemen sehingga kita mendapatkan bentuk jamak yang

02:18.990 --> 02:21.173
benar.

02:22.850 --> 02:25.220
Sekarang di sini, teks deskripsi ada di sana untuk elemen kedua

02:25.220 --> 02:27.040
dan kembali ke sini. Sekarang Anda sudah

02:27.040 --> 02:29.480
melihat jenis keluhan tentang panjangnya di sini.

02:29.480 --> 02:32.350
Karena tidak jelas bahwa elemen memiliki panjang.

02:32.350 --> 02:34.770
Jadi, mungkin kita harus memperjelas bahwa hal itu memang benar.

02:34.770 --> 02:38.430
Kita bisa melakukannya dengan membuat antarmuka baru atau tipe kustom

02:38.430 --> 02:41.060
dengan kata kunci tipe di sini dan di sini saya akan

02:41.060 --> 02:44.750
memilih antarmuka yang akan saya beri nama lengthy yang pada akhirnya

02:44.750 --> 02:47.440
hanya menjamin bahwa kita memiliki objek dengan properti

02:47.440 --> 02:50.820
panjang yang pada akhirnya akan menghasilkan angka.

02:50.820 --> 02:52.870
Dan kemudian di sini kita bisa menetapkan batasan

02:52.870 --> 02:54.740
dan mengatakan bahwa T memanjang.

02:54.740 --> 02:57.710
Jadi kita tahu apa pun yang kita dapatkan, kita akan memiliki properti

02:57.710 --> 03:01.053
panjang dan larik atau string akan memiliki properti panjang.

03:02.030 --> 03:07.030
Sekarang di sini, saya dapat menghitung dan mendeskripsikan log

03:07.500 --> 03:11.240
konsol dan meneruskan, katakanlah, hai di sana.

03:11.240 --> 03:14.280
Sekarang ini berfungsi karena string memiliki properti panjang.

03:14.280 --> 03:15.290
Ini bukan objek.

03:15.290 --> 03:17.310
Ini adalah sebuah string, tetapi di balik layar, Javascript

03:17.310 --> 03:19.980
mengubahnya menjadi objek dengan cepat dan menambahkan properti

03:19.980 --> 03:23.940
panjang ketika kita membutuhkannya.

03:23.940 --> 03:23.940
Jadi,

03:23.940 --> 03:26.960
oleh karena itu, kita bisa dengan aman menyebutnya seperti ini. Ketik skrip terlebih dahulu

03:26.960 --> 03:31.370
bahwa di sini kita mengembalikan array dengan elemen string atau tipe

03:31.370 --> 03:33.580
T di sana. Sekarang saya ingin memiliki

03:33.580 --> 03:36.060
tuple jadi saya akan lebih spesifik di sini dan mengatur

03:36.060 --> 03:39.110
tipe pengembalian menjadi pada dasarnya sebuah array dengan tepat

03:39.110 --> 03:41.330
dua elemen di mana elemen pertama akan bertipe T

03:41.330 --> 03:43.850
dan elemen kedua akan bertipe string.

03:43.850 --> 03:46.270
Jadi sekarang saya hanya mengatakan bahwa kita

03:46.270 --> 03:49.360
mengembalikan tuple di sini di mana elemen pertama akan menjadi,

03:49.360 --> 03:52.010
yah, elemen apa pun dari tipe generik kita, dan elemen

03:52.010 --> 03:54.110
kedua akan menjadi string.

03:54.110 --> 03:56.820
Sekarang, dengan itu jika kita menyimpan ini, dikompilasi

03:56.820 --> 04:00.330
ulang tanpa kesalahan dan mencetak hai di sana, mendapat sembilan elemen karena

04:00.330 --> 04:02.330
kita punya sembilan karakter di sana.

04:04.320 --> 04:06.890
Kita juga bisa memanggil ini dengan array di mana

04:06.890 --> 04:09.530
kita memiliki olahraga dan memasak, dan sekarang

04:09.530 --> 04:12.460
Anda akan melihat bahwa kita mendapat dua elemen sebagai

04:12.460 --> 04:15.990
teks deskripsi, atau dengan array kosong tentu saja, dalam hal ini,

04:15.990 --> 04:18.660
jika saya menyimpannya, kita tidak mendapat nilai,

04:18.660 --> 04:22.500
tetapi kita tidak akan dapat memanggil ini, misalnya, dengan angka karena

04:22.500 --> 04:24.103
angka tidak memiliki properti

04:24.103 --> 04:28.090
panjang dan oleh karena itu ini tidak berfungsi.

04:28.090 --> 04:32.900
Jadi, di sini lagi, kita mendapatkan fungsi generik kita.

04:32.900 --> 04:35.043
Ide ini mirip dengan fungsi sebelumnya.

04:35.043 --> 04:38.680
Kami ingin sedikit tidak spesifik tentang jenis data yang kami dapatkan

04:38.680 --> 04:40.540
di sini. Kita tidak terlalu peduli

04:40.540 --> 04:43.180
apakah itu string, apakah itu larik, atau apa pun yang memiliki

04:43.180 --> 04:45.610
properti panjang. Kita hanya peduli bahwa ia memang

04:45.610 --> 04:47.930
memiliki properti panjang dan kemudian kita ingin melakukan

04:47.930 --> 04:49.980
sesuatu dengannya karena kita mengandalkan properti

04:49.980 --> 04:51.970
panjang dalam kode kita, jadi kita perlu menjamin

04:51.970 --> 04:53.540
bahwa kita mendapatkannya, tetapi selain

04:53.540 --> 04:55.370
itu, kita benar-benar tidak tertarik pada jenis

04:55.370 --> 04:59.490
data yang kita dapatkan di sini.

04:59.490 --> 04:59.490
Saya

04:59.490 --> 05:01.820
tidak ingin mengunci ini ke string atau array, dan saya tidak

05:01.820 --> 05:04.220
ingin membuat banyak overload untuk menangani semua kemungkinan

05:04.220 --> 05:05.830
tipe yang berbeda.

05:05.830 --> 05:08.124
Saya juga tidak ingin membuat tipe union yang sangat

05:08.124 --> 05:10.970
panjang di sini karena saya mungkin lupa tipe yang memiliki

05:10.970 --> 05:13.610
properti panjang, atau jika saya membuat objek sendiri

05:13.610 --> 05:16.220
dengan properti panjang, saya mungkin tidak mengizinkannya

05:16.220 --> 05:18.640
jika saya membatasi ini di sini untuk menjadi tipe,

05:18.640 --> 05:21.580
string dan array atau semacamnya.

05:21.580 --> 05:23.500
Jadi oleh karena itu, saya ingin lebih fleksibel

05:23.500 --> 05:25.380
dan dengan tipe generik kita bisa seperti itu,

05:25.380 --> 05:27.550
kita tidak peduli dengan tipe yang tepat.

05:27.550 --> 05:30.080
Di sini, berkat batasannya, saya hanya peduli

05:30.080 --> 05:33.363
tentang fakta bahwa ia memiliki properti panjang.
