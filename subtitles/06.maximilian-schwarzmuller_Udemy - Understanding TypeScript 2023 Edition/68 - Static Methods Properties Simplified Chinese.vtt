WEBVTT

00:02.251 --> 00:05.350
教师：另一个与属性和方法相关的好特性,

00:05.350 --> 00:10.010
当你使用ES6或更高版本时, JavaScript中也存在这个特性,

00:10.010 --> 00:14.010
但是所有的类型脚本都是静态属性和方法｡

00:14.010 --> 00:17.520
静态属性和方法允许您将属性和方法添加到类中,

00:17.520 --> 00:28.950
这些属性和方法在类的实例上不能访问, 因此您不需要首先调用新类名, 而是直接在类上访问｡

00:28.950 --> 00:31.350
这通常用于你想要逻辑地分组或映射到类的实用函数,

00:31.350 --> 00:40.860
或者你也想要存储在类中的全局常量｡

00:40.860 --> 00:43.270
一个内置在JavaScript中的例子,

00:43.270 --> 00:46.050
它不是由typescript定义的,

00:46.050 --> 00:53.220
也不是由你定义的, 而是浏览器中JavaScript的一部分, 它是Math构造函数, 或者类,

00:53.220 --> 00:55.500
如果你想这样调用它, 它在JavaScript中全局可用,

00:55.500 --> 01:08.610
你可以访问pi作为一个常量值, 给你一个pi数, 或者函数, 或者更精确的方法, 比如pow来计算某个东西的幂｡

01:08.610 --> 01:13.370
这些方法和属性不能在Math实例上访问｡

01:13.370 --> 01:16.310
你不用先打电话给新数学｡ 

01:16.310 --> 01:22.360
实际上, 这是行不通的, 但您可以直接在类本身的方法中访问这些属性｡

01:22.360 --> 01:25.340
所以Math更像是一个命名空间,

01:25.340 --> 01:28.640
作为一种分组机制, 这是静态方法和属性的常见用例,

01:28.640 --> 01:33.650
你也可以将它们添加到你自己的类中｡

01:33.650 --> 01:36.770
假设在Department上, 我们希望有一个方法来帮助我们创建雇员,

01:36.770 --> 01:46.890
我们可能希望能够在不实例化Department的情况下访问该方法, 因为我们通常实例化更专业的版本, 即IT部门和会计部门,

01:46.890 --> 01:58.490
而我们并不真的希望实例化Department只是为了调用实用程序方法, 因此我们可以在此处添加一个方法, 例如创建雇员, 这里我们要得到一个字符串作为参数,

01:58.490 --> 02:07.621
然后我们要返回一个值.

02:07.621 --> 02:10.230
现在, 为了使它成为一个静态方法,

02:10.230 --> 02:12.920
我们可以在不实例化该类的情况下访问它,

02:12.920 --> 02:16.250
我们在这个方法前面添加了static关键字,

02:16.250 --> 02:18.549
然后在这里, 我们可以返回一个对象,

02:18.549 --> 02:23.549
其中我们将name属性映射到这个name值｡

02:25.170 --> 02:27.010
当然, 这是一个非常简单的方法,

02:27.010 --> 02:28.690
但你明白了｡

02:28.690 --> 02:31.960
现在, 为了使用它, 我们可以在那里执行我们的代码,

02:31.960 --> 02:33.490
现在, 假设我们需要一个新雇员,

02:33.490 --> 02:36.940
employee1｡

02:39.300 --> 02:46.020
那我们就去找部门｡

02:46.020 --> 02:46.020
createEmployee并传入Max,

02:46.920 --> 02:50.680
例如, 如果I, 则为控制台｡ log（employee1）,

02:50.680 --> 02:53.170
我们应该会看到一个名为Max的对象｡

02:53.170 --> 02:58.240
所以如果我保存它, 这里就是我们刚刚创建的雇员｡

02:58.240 --> 03:01.200
所以这是一个典型的静态方法的例子｡ 

03:01.200 --> 03:04.870
我们直接在类上调用它, 不使用new关键字,

03:04.870 --> 03:06.360
因此我们使用类作为分组机制,

03:06.360 --> 03:13.470
如果你想添加一个静态属性, 你也可以这样做.

03:13.470 --> 03:17.950
如果您有类似fiscalYear的内容, 并且当前希望在公司中使用,

03:19.730 --> 03:22.040
您可以将其设置为, 比如说, 2020,

03:22.040 --> 03:33.950
然后再次使其可用, 而无需实例化它, 您可以在此属性前面添加static, 或者在该字段前面添加static, 然后访问该字段｡

03:33.950 --> 03:36.560
下面是控制台｡  记录｡  （我创建的员工）｡ 

03:38.050 --> 03:42.420
在这里我们还可以访问部门｡  财政的 年份就像这样, 没有实例化它,

03:43.900 --> 03:51.130
如果我们保存它, 毫无疑问, 我们会看到2020年被记录在这里｡

03:51.130 --> 03:53.347
这些是静态方法和属性｡ 

03:53.347 --> 03:56.947
关于他们的一个重要的词, 或者一件你应该记住的事情｡

03:56.947 --> 03:59.067
当你把它们添加到一个类上时,

03:59.067 --> 04:03.370
你不能从你的非静态部分里面访问它们｡

04:03.370 --> 04:04.870
所以如果你想在构造函数中访问fiscalYear,

04:04.870 --> 04:10.375
并且你想控制.

04:10.375 --> 04:10.375
在此记录,

04:10.375 --> 04:13.490
如您所见, 这将不起作用｡

04:13.490 --> 04:18.690
我在这里得到一个错误, 属性fiscalYear是一个静态成员｡

04:18.690 --> 04:20.976
我们在这里不能访问它因为构造函数和里面的任何东西,

04:20.976 --> 04:37.660
还有所有的方法, 它们没有被标记为static, 你不能把构造函数标记为static, 顺便说一下, 你将不能访问static属性, 因为它引用了基于类创建的实例, 而静态属性在实例上不可用,

04:37.660 --> 04:47.780
因为静态属性和静态方法是从实例中分离出来的｡

04:47.780 --> 04:50.930
所以你当然不能用this关键字访问它们｡ 

04:50.930 --> 04:53.940
如果您想要从类别内部使用静态属性或方法,

04:53.940 --> 04:59.380
则必须使用此处的类别名称来存取它｡

04:59.380 --> 05:04.290
这使您可以从类内部访问所有静态属性和方法｡

05:04.290 --> 05:06.593
这是一个重要的事情要记住｡ 
