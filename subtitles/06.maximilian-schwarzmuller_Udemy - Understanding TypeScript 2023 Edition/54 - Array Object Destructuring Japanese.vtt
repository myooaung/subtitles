WEBVTT

00:02.100 --> 00:04.870
講師：配列とオブジェクトにこだわってみましょう｡ 

00:04.870 --> 00:06.750
もう一つの重要な構文は､ 最近の JavaScript

00:06.750 --> 00:13.133
や Typescript プロジェクトでよく目にする､ 配列やオブジェクトのデストラクチャリングです｡

00:14.180 --> 00:15.013
どのように機能するのですか？

00:15.013 --> 00:17.220
さて､ まずは2つの趣味を持つ配列､

00:17.220 --> 00:20.220
hobbiesから始めましょう｡

00:20.220 --> 00:22.200
この2つの趣味を抽出して､

00:22.200 --> 00:26.340
変数や定数に格納するとしよう｡

00:26.340 --> 00:28.891
もちろん､ 最初の要素であるインデックス・ゼロに対して､

00:28.891 --> 00:34.820
趣味1イコール趣味でやってもいい｡

00:34.820 --> 00:38.720
そして､ インデックス1での趣味のための趣味2でも同じかもしれません｡ 

00:38.720 --> 00:40.500
これは､ この2つの要素を取り出して､

00:40.500 --> 00:43.330
定数に格納します｡

00:43.330 --> 00:44.720
2行のコードで済みますが､

00:44.720 --> 00:48.493
取得したい要素が多ければ多いほど､ より多くのコード行が必要になります｡

00:49.340 --> 00:51.690
配列のデストラクチャリングで短くすることができます｡ 

00:51.690 --> 00:53.090
配列のデストラクチャリングでは､

00:53.090 --> 00:56.250
等号の左側に角括弧を付けますが､

00:56.250 --> 01:01.400
これは珍しいことです｡

01:01.400 --> 01:02.900
見たことないですね｡ 

01:02.900 --> 01:04.780
そして､ 右側には配列があり､

01:04.780 --> 01:06.480
これを再構築するのです｡

01:06.480 --> 01:10.470
さて､ デストラクチャーとは､ 本当に配列から要素を抜き出すことを意味します｡

01:10.470 --> 01:13.570
そして､ この角括弧の間の左側には､ 定数､

01:13.570 --> 01:17.250
またはletを使用する場合は変数に格納します｡

01:17.250 --> 01:21.170
ここで､ 趣味1と趣味2ができるわけです｡ 

01:21.170 --> 01:23.000
この構文では､ 趣味の配列を調べて､

01:23.000 --> 01:32.320
最初の要素を取り出し､ この名前の定数に格納し､ 2番目の要素を取り出し､ この名前の定数に格納します｡

01:32.320 --> 01:35.490
趣味の配列の要素が2つだけでない場合は､

01:35.490 --> 01:42.130
ここに残りのパラメータを追加して､ 残りの趣味を持たせることもできます｡

01:42.130 --> 01:46.260
そして､ 趣味1や趣味2に引き出されなかった残りのすべての要素が､

01:46.260 --> 01:51.290
残りの趣味という新しい配列に格納されることになります｡

01:51.290 --> 01:54.090
そのため､ それらは新しい配列にマージされることになります｡ 

01:54.090 --> 01:57.940
ちなみにデストラクチャリングでは､ 元の配列は変わりません｡ 

01:57.940 --> 02:02.940
だから､ コンソールすれば｡  ここで､ hobbies, hobby one, hobby twoをログに記録すると､

02:04.260 --> 02:06.840
hobbiesが古い配列のままであることがわかります｡

02:06.840 --> 02:08.840
空っぽというか､ そんな感じです｡ 

02:08.840 --> 02:14.870
つまり､ 引用符で囲んで取り出した値は､ 実際には新しい定数や変数にコピーされるだけで､

02:14.870 --> 02:17.720
配列から削除されるわけではありません｡

02:17.720 --> 02:18.980
これが配列の再構築です｡ 

02:18.980 --> 02:20.600
オブジェクトについても同様です｡ 

02:20.600 --> 02:21.690
私たちの担当者はここにいます｡ 

02:21.690 --> 02:23.440
ここで､ 名前と年齢を独立した定数､

02:23.440 --> 02:26.630
つまり変数に格納することにしましょう｡

02:26.630 --> 02:31.840
配列のデストラクション同様､ オブジェクトのデストラクションもconstとletの両方で動作します｡

02:31.840 --> 02:33.010
ここでは､ コンストでいきます｡ 

02:33.010 --> 02:37.090
そして､ 今度は等号の左側で中括弧を使うことができます｡

02:37.090 --> 02:38.883
新しい構文とはいえ､ ね｡ 

02:39.920 --> 02:44.890
そして､ 私たちのオブジェクト､ または変数が右側のオブジェクトを指すようにします｡

02:44.890 --> 02:48.770
ところで､ ここで割り当てているのはオブジェクト型ではないことに注意してください｡

02:48.770 --> 02:51.200
ここにコロンがないんです｡ 

02:51.200 --> 02:54.080
本当にこのように左側に中括弧があるだけで､

02:54.080 --> 02:58.210
何かの定数名の後にコロンがないのです｡

02:58.210 --> 03:02.720
だから､ 定数を格納できるような値の型は割り当てていないんだ｡

03:02.720 --> 03:05.470
本当に特殊な構文を使っているだけなんです｡ 

03:05.470 --> 03:08.450
なぜなら､ ここでは､ オブジェクトの中にあるプロパティ名､

03:08.450 --> 03:11.340
例えば､ nameやageを参照して､

03:11.340 --> 03:13.920
これらのキーの値をpersonから取り出し､

03:13.920 --> 03:21.283
同じ名前の定数に格納することもできるようになったからです｡

03:23.290 --> 03:24.390
ここで､ 一番上にすでにage変数があるため､

03:24.390 --> 03:27.820
エラーが発生しました｡

03:27.820 --> 03:32.173
そして､ nameはグローバルに利用可能な変数で､ とにかく存在することが判明しました｡

03:33.240 --> 03:41.920
そこで､ 回避策として､ 例えばfirstNameという別のキー名を使用することができます｡

03:41.920 --> 03:45.020
そして､ ここでそのキーを使って値を取り出すことができます｡ 

03:45.020 --> 03:46.900
つまり､ これがオブジェクトのデストラクチャリングの仕組みです｡ 

03:46.900 --> 03:52.260
ここで重要なのは､ 配列の再構築の場合､ 配列は順序付きリストであるため､

03:52.260 --> 03:55.110
要素は順番に引き出されることです｡

03:55.110 --> 03:58.110
オブジェクトでは､ 順番が必ずしも保証されていないため､

03:58.110 --> 04:02.070
位置で要素を引き出すのではなく､ キー名で引き出す｡

04:02.070 --> 04:04.790
ですから､ ここで中括弧の間に指定する値､

04:04.790 --> 04:07.630
つまり名前は､ 任意のものではありません｡

04:07.630 --> 04:09.700
ここで名前を出してもしょうがない｡ 

04:09.700 --> 04:13.860
これらのキーに対応する値をオブジェクトから引き出せるように､

04:13.860 --> 04:18.160
オブジェクトの中で見つけたプロパティ名でなければなりません そして､

04:18.160 --> 04:21.880
同じ名前の定数または変数に格納されます｡

04:21.880 --> 04:25.970
もし､ この名前を上書きしたい場合は､ ここにコロンをつけて上書きすることができます｡

04:25.970 --> 04:28.050
ここでも､ タイプ分けではないんです｡ 

04:28.050 --> 04:29.680
新しい名前が設定されるだけです｡ 

04:29.680 --> 04:33.820
つまり､ これはすべてJavaScriptの構文であり､ Typescriptとは何の関係もありません｡

04:33.820 --> 04:38.750
したがって､ ここでは､ 例えばuserName定数に格納することができます｡

04:38.750 --> 04:44.040
それゆえ､ 以後はコンソールにすることができるのです｡

04:44.040 --> 04:44.040
というのも､

04:44.040 --> 04:45.290
ここで値を引き出すときに作成する定数では､

04:45.290 --> 04:52.790
基本的にfirstNameはuserNameという名前に上書きされるからです｡

04:52.790 --> 04:55.880
Ageは上書きされないので､ そのように使うことができます｡ 

04:55.880 --> 04:58.183
ここでも､ 型番の割り当てではありません｡ 

04:58.183 --> 05:00.210
これはJavaScriptの構文で､

05:00.210 --> 05:05.500
人から引き出したプロパティの名前をエイリアスで変更するのです｡

05:05.500 --> 05:09.840
また､ 前回までの配列と同様､ 人物オブジェクト自体は変わっていません｡

05:09.840 --> 05:13.380
実際には､ これらの値をオブジェクトからコピーするだけです｡ 

05:13.380 --> 05:15.643
そのため､ ここにこのような出力が得られます｡ 
