WEBVTT

00:02.340 --> 00:05.860
-: ตอนนี้ เมื่อต้องทำงานกับประเภทสหภาพแรงงาน

00:05.860 --> 00:06.970
เช่น นี้และสิ่งนี้

00:06.970 --> 00:11.070
อาจเป็นเรื่องยุ่งยากที่จะทำซ้ำประเภทสหภาพเสมอ

00:11.070 --> 00:15.330
คุณอาจต้องการแลกเปลี่ยนประเภทใหม่ซึ่งติดตั้งประเภทสหภาพนี้ใหม่

00:15.330 --> 00:18.540
และคุณสามารถทำได้ด้วยฟีเจอร์ประเภทเจ๋งๆ

00:18.540 --> 00:21.410
ฟีเจอร์ของชื่อแทนประเภท

00:21.410 --> 00:22.723
คุณสร้างนามแฝงดังกล่าว

00:24.280 --> 00:25.670
โดยปกติแล้วก่อนที่คุณจะใช้

00:25.670 --> 00:31.240
ดังนั้นที่นี่ที่ด้านบนสุดของไฟล์ในกรณีนี้ ที่นี่ ด้วยคีย์เวิร์ดประเภท

00:31.240 --> 00:34.040
ตอนนี้คำหลักประเภทไม่ได้สร้างไว้ใน JavaScript

00:34.040 --> 00:40.450
แต่รองรับใน TypeScript และหลังจากพิมพ์คุณเพิ่มชื่อประเภทที่กำหนดเองหรือชื่อแทนประเภทของคุณแล้ว

00:40.450 --> 00:42.860
ฉันควรจะพูด

00:42.860 --> 00:44.980
ตัวอย่างเช่น รวมกันได้

00:44.980 --> 00:46.720
แต่ชื่อนั้นขึ้นอยู่กับคุณจริงๆ

00:46.720 --> 00:48.380
คุณสามารถสร้างชื่อใดก็ได้ที่นี่ซึ่งไม่ได้สร้างไว้ใน

00:48.380 --> 00:52.530
JavaScript หรือ TypeScript เป็นชื่อคีย์

00:52.530 --> 00:54.360
ดังนั้นบางอย่างเช่น date จะไม่ได้รับอนุญาตเพราะมันมีอยู่ใน

00:54.360 --> 00:56.250
JavaScript แต่ combinable นั้นไม่ได้สร้างไว้ใน

00:56.250 --> 01:01.170
JavaScript ไม่ได้อยู่ใน TypeScript ดังนั้นเราจึงสามารถใช้งานได้

01:01.170 --> 01:08.320
และตอนนี้ด้วยเครื่องหมายเท่ากับ คุณกำหนดประเภทที่คุณต้องการเข้ารหัสในนามแฝงของคุณ

01:08.320 --> 01:10.300
เราสามารถเก็บตัวเลขไว้ที่นี่ และตอนนี้

01:10.300 --> 01:16.400
เมื่อใดก็ตามที่เราต้องการแน่ใจว่าบางอย่างควรเป็นตัวเลข เราสามารถใช้การรวมกันแทนได้

01:16.400 --> 01:21.630
มันไม่สมเหตุสมผลเลย มันอาจทำให้โค้ดของเราอ่านยากขึ้นด้วยซ้ำ

01:21.630 --> 01:25.500
ตัวอย่างเช่น ถ้าฉันใช้ combinable ลงไป มันจะได้ผลในทางเทคนิค

01:25.500 --> 01:27.420
แต่ถ้าเราแค่ดูโค้ดของเรา

01:27.420 --> 01:33.180
มันไม่ชัดเจนว่าเราต้องการตัวเลขหรือสตริงที่นี่

01:33.180 --> 01:37.500
โดยทั่วไปแล้วคุณใช้สิ่งนั้นร่วมกับประเภทสหภาพ

01:37.500 --> 01:40.380
ดังนั้นเราจึงสามารถจัดเก็บประเภท union ในประเภทที่กำหนดเองของเรา

01:40.380 --> 01:42.250
กล่าวคือ ในชื่อแทนประเภทของเรา

01:42.250 --> 01:45.240
และตอนนี้เพียงแค่อ้างถึง combinable down ที่นั่นแทนประเภท

01:45.240 --> 01:48.170
union ของเรา

01:48.170 --> 01:51.060
ดังนั้นเราจึงมีการตั้งค่าเหมือนเดิมทุกประการ

01:51.060 --> 01:55.580
เราเพิ่งมีชื่อแทนประเภทที่ใช้ซ้ำได้ซึ่งเราสามารถใช้แทนได้

01:55.580 --> 01:59.200
และนั่นทำให้เราสามารถบันทึกรหัสพิเศษบางอย่างและตรวจสอบให้แน่ใจว่าเราอ้างอิงถึงประเภทเดียวกันหรือการตั้งค่าประเภทเดียวกันเสมอเมื่อเราใช้

01:59.200 --> 02:04.200
combinable

02:04.234 --> 02:06.600
และแน่นอนว่าเราไม่สามารถใช้สำหรับตัวเลขและสตริงได้

02:06.600 --> 02:11.140
แต่เราสามารถใช้สำหรับการตั้งค่าประเภทใดก็ได้ที่เราอาจต้องการจัดเก็บในนามแฝง

02:11.140 --> 02:14.810
รวมถึงประเภทตัวอักษรทั้งสองนี้ เป็นต้น

02:14.810 --> 02:18.210
ดังนั้นสำหรับสองประเภทนี้ที่นี่ สำหรับประเภทสหภาพนี้

02:18.210 --> 02:20.660
เรายังสามารถแลกเปลี่ยนประเภทนามแฝง,

02:20.660 --> 02:24.030
ConversionDescriptor หรืออย่างไรก็ตามคุณต้องการตั้งชื่อมัน

02:24.030 --> 02:28.920
และจัดเก็บประเภทเดียวกันนี้ในประเภทนามแฝงนี้

02:28.920 --> 02:32.270
และตอนนี้เราสามารถใช้นามแฝงประเภทนี้ได้

02:32.270 --> 02:34.970
พิมพ์นามแฝงจึงมีประโยชน์จริงๆ

02:34.970 --> 02:37.490
คุณสามารถเข้ารหัสคำจำกัดความของประเภทที่ซับซ้อนมากขึ้นเป็นประเภทของคุณเอง

02:37.490 --> 02:45.920
เป็นชื่อประเภทของคุณเอง และนำสิ่งนั้นกลับมาใช้ซ้ำได้ทุกที่ในโค้ดของคุณเมื่อคุณต้องการการตั้งค่าประเภทนี้

02:45.920 --> 02:48.060
เพื่อหลีกเลี่ยงการพิมพ์ผิด และคุณสามารถบันทึกโค้ด

02:48.060 --> 02:57.653
เขียนโค้ดได้เร็วขึ้น และชัดเจนยิ่งขึ้นเกี่ยวกับความตั้งใจของคุณ ตัวอย่างเช่น โดยการเลือกชื่อแทนประเภทที่สื่อความหมายบนนั้น
