WEBVTT

00:01.850 --> 00:03.270
教师：现在我们已经了解了TypeScript的基本原理,

00:03.270 --> 00:14.148
以及它与JavaScript的不同之处, 让我们更深入地了解一下TypeScript所知道的不同核心类型｡

00:14.148 --> 00:18.500
数字就是我们在这里看到的类型, 正如我解释的, 整数和浮点数或双精度数之间没有区别, 比如这里的5,

00:18.500 --> 00:25.640
浮点数或双精度数, 在其他编程语言中是这样称呼的, 比如2｡

00:25.640 --> 00:25.640
这里是8号

00:25.640 --> 00:28.440
实际上, 在JavaScript和TypeScript中,

00:28.440 --> 00:30.810
默认情况下所有数字都是浮点数｡

00:30.810 --> 00:33.270
对于JavaScript和TypeScript来说,

00:33.270 --> 00:36.770
五个这样的代码和五个这样的代码没有区别｡

00:36.770 --> 00:38.640
基本上是同一个数字｡ 

00:38.640 --> 00:42.720
现在, 除了数字, 我们还有其他核心类型｡ 

00:42.720 --> 00:46.350
这就是字符串, 文本和布尔值｡ 

00:46.350 --> 00:47.800
让我们也来看看那些｡ 

00:47.800 --> 00:50.650
我们实际上已经在if语句中看到了所有的动作,

00:50.650 --> 00:53.291
我们知道这有点多余｡

00:53.291 --> 00:55.971
尽管如此, 这里的这个字符串是字符串｡ 

00:55.971 --> 00:57.720
当然, 五个带引号的字符串也是一个字符串,

00:57.720 --> 01:00.389
因为它是文本｡

01:00.389 --> 01:05.170
比如说, 这个比较的结果, 就是一个布尔值｡

01:05.170 --> 01:10.950
这个运算符, 这里是三个等号或者取反的等式运算符,

01:10.950 --> 01:13.640
它产生真或假｡

01:13.640 --> 01:17.340
当然, 我们也可以动态生成innerRef检查,

01:17.340 --> 01:18.850
这是我们经常做的｡

01:18.850 --> 01:23.379
或者我们用true或false值初始化一个变量, 所以我们在这里两个都做｡

01:23.379 --> 01:27.509
在这里, 我们可以添加一个新的常量“printResult”｡ 

01:27.509 --> 01:29.990
并将此设置为true｡ 

01:29.990 --> 01:31.320
我想说的很清楚,

01:31.320 --> 01:33.130
这也可能是一个变量｡

01:33.130 --> 01:34.460
它不一定是常数｡ 

01:34.460 --> 01:37.730
它可以是一个变量, 可以在JavaScript中使用let创建｡

01:37.730 --> 01:40.703
但由于我不打算在这里改变它, 我将使用常数｡

01:40.703 --> 01:43.670
我们可以把它作为第三个参数传递到这里｡ 

01:43.670 --> 01:46.960
假设我们传入“printResult”, 这里也是如此｡ 

01:46.960 --> 01:49.720
当然, 现在我们会立即得到一个错误,

01:49.720 --> 01:53.160
因为我们的add函数不支持第三个参数｡

01:53.160 --> 01:55.560
我们看到, “期望两个参数, 但得到三个”｡ 

01:55.560 --> 01:58.920
因此, 我们必须确保我们支持第三个论点｡

01:58.920 --> 02:03.920
在那里, 我们可以添加“showResult”参数｡ 

02:03.940 --> 02:05.920
您也可以在此处将其命名为“printResult”｡ 

02:05.920 --> 02:07.910
我使用“showResult”以避免命名方面的混淆,

02:07.910 --> 02:12.930
但是, 从技术上讲, 这两个名称不会冲突｡

02:12.930 --> 02:14.320
因此, 在这里, 我将它命名为“showResult”｡ 

02:14.320 --> 02:19.500
我想通过把它设置为boolean来确保它是boolean类型的｡

02:19.500 --> 02:22.109
同样, 在此处的参数后添加冒号,

02:22.109 --> 02:25.120
然后添加类型的名称｡

02:25.120 --> 02:28.100
现在这个函数接受这个, 我们现在可以做的是在这里添加一个if检查,

02:28.100 --> 02:31.787
检查“if showResult, ”如果这个是真的,

02:31.787 --> 02:36.480
我们当然可以比较它和真的｡

02:36.480 --> 02:37.628
但是正如你在JavaScript中所知道的,

02:37.628 --> 02:41.990
你也可以在这里传入true或falsy值｡

02:41.990 --> 02:43.970
JavaScript会对它求值,

02:43.970 --> 02:48.989
如果它以某种方式产生了真值, 或者一般来说是一个真值, 那么我们就把它放到if块中｡

02:48.989 --> 02:50.011
否则, 我们不会｡ 

02:50.011 --> 02:55.429
假设我们成功了, 然后我想“安慰｡

02:55.429 --> 02:55.429
logn1加n2”｡ 

02:55.429 --> 02:58.581
否则, 在else的情况下, 如果我们没有成功,

02:58.581 --> 03:00.549
那么我想把这个退回去｡

03:00.549 --> 03:04.760
所以现在这个函数有时返回值有时不返回值,

03:04.760 --> 03:08.309
但会立即输出.

03:08.309 --> 03:11.550
你可能会说, 如果你想写这样一个函数,

03:11.550 --> 03:14.310
它是不可预测的, 或者如果你在这里传递一个真值,

03:14.310 --> 03:18.349
它可能会意外地表现出来｡

03:18.349 --> 03:19.990
但在这里, 我们做到了｡ 

03:19.990 --> 03:22.090
所以这个函数只在某些时候返回｡ 

03:22.090 --> 03:27.830
有时它也不返回, 而是将一些内容记录到控制台｡

03:27.830 --> 03:33.640
现在, 我们可以像这样调用add, 而不需要将其存储在result中,

03:33.640 --> 03:37.570
也不需要控制台｡ 日志结果, 因为“printResult”设置为true时,

03:37.570 --> 03:39.550
添加了自身｡

03:39.550 --> 03:41.869
因此函数本身将打印结果｡ 

03:41.869 --> 03:47.880
因此, 如果我们现在保存并重新编译应用程序｡

03:47.880 --> 03:47.880
ts文件｡ 

03:47.880 --> 03:52.600
完成后, 页面将重新加载, 我们仍然可以在此处看到输出｡

03:52.600 --> 03:54.677
但现在是从6号线打来的｡ 

03:54.677 --> 03:58.980
如果我们看一下, 第六行确实在函数里面｡

03:58.980 --> 03:59.891
这是一个布尔值｡ 

03:59.891 --> 04:02.429
现在假设我们要自定义输出｡ 

04:02.429 --> 04:06.190
在if中, 我们有一个“resultPhrase”常量,

04:06.190 --> 04:10.181
在这里我们说, “Result is”冒号, 然后是一些空格｡

04:10.181 --> 04:14.205
我们在这里用“resultPhrase”传递它｡ 

04:14.205 --> 04:17.410
好吧, 那么我们可以期待这也是一个论点｡ 

04:17.410 --> 04:20.750
短语, 通过添加一个冒号可以生成管道字符串｡ 

04:20.750 --> 04:22.291
字符串是类型的名称,

04:22.291 --> 04:26.469
现在我们可以用这个短语把它作为结果输出的一部分,

04:26.469 --> 04:31.193
如果我们直接在函数中输出结果的话.

04:31.193 --> 04:34.789
那么, 这里, 我们可以有"短语加n1加n2 ".

04:34.789 --> 04:37.440
如果我们这样做, 然后通过重复这个命令重新编译,

04:37.440 --> 04:41.720
我们会看到这个短语是结果的一部分｡

04:41.720 --> 04:44.861
但我们现在也重新引入了旧的bug, 因为我有一个字符串,

04:44.861 --> 04:48.141
我把它和两个数字组合在一起｡

04:48.141 --> 04:53.240
这里所有的东西都被转换成了字符串, 这不是我想要的｡

04:53.240 --> 04:57.708
为了避免这种情况, 在这个函数中, 我们可以在这里添加一个结果变量｡

04:57.708 --> 05:02.027
或者结果常量并将结果存储在这里｡ 

05:02.027 --> 05:04.530
现在我们用数学的方法来处理,

05:04.530 --> 05:07.990
因为这里只涉及数字, 然后, 我们可以把它和短语结合起来,

05:07.990 --> 05:11.430
或者直接返回.

05:11.430 --> 05:17.029
现在, 由于它永远不会和字符串一起直接计算, 所以它永远是一个数字｡

05:17.029 --> 05:19.350
是的, 这里, 这个数字和这个字符串结合起来,

05:19.350 --> 05:21.140
会被转换成一个字符串｡

05:21.140 --> 05:25.548
但由于数学计算在此之前完成, 我们会得到正确的结果｡

05:25.548 --> 05:28.520
所以现在如果我们重复这个过程, 然后重新编译,

05:28.520 --> 05:30.181
我们会得到正确的输出｡

05:30.181 --> 05:33.050
现在, 这些是正在使用的核心数据类型｡ 

05:33.050 --> 05:35.541
现在, 让我们确保完全理解类型是如何赋值的,

05:35.541 --> 05:41.343
以及为什么我们不显式地赋值类型｡
