WEBVTT

00:02.220 --> 00:05.760
- ：下一步, 我想在这里处理这些类型,

00:05.760 --> 00:14.980
我在这里为我分配的项目､ 侦听器以及项目状态中的项目使用的任何类型｡

00:14.980 --> 00:25.660
当然, 在这里, 我不想使用任何类, 如果有一个我们可以使用的专用项目类或项目类型会更有意义｡

00:25.660 --> 00:32.450
实际上, 我将为该项目类型创建一个类, 只需使用class project,

00:32.450 --> 00:34.890
这样我们就有了一种构建项目对象的方法,

00:34.890 --> 00:41.570
这些对象总是具有相同的结构｡

00:41.570 --> 00:44.760
现在我在下面用文字符号来做｡ 

00:44.760 --> 00:47.920
当然, 这样做的缺点是, 我们必须记住它是描述,

00:47.920 --> 00:50.490
而不是描述｡

00:50.490 --> 00:53.470
我们需要一个ID, 一个字符串等等

00:53.470 --> 00:56.440
这就是自定义类型可以帮助我们的地方,

00:56.440 --> 01:02.300
我将创建一个类, 而不是一个接口, 或者一个带有type关键字的自定义类型,

01:02.300 --> 01:05.470
因为我希望能够实例化它｡

01:05.470 --> 01:10.700
那么这样的一门课或者这样的一个项目应该是什么样子的呢？

01:10.700 --> 01:12.320
我将添加一个构造函数,

01:12.320 --> 01:19.100
然后使用这个快捷方式, 将实参或参数赋给构造函数, 然后这些实参或参数也会自动变为属性,

01:19.100 --> 01:25.650
方法是在开头添加访问器, 在本例中为Public, 然后是实参和属性的名称,

01:25.650 --> 01:29.450
最后是类型.

01:29.450 --> 01:33.100
在这里, 每个项目都应该有一个ID｡ 

01:33.100 --> 01:34.990
每个项目都应该有一个标题,

01:34.990 --> 01:37.330
它也是一个字符串, 就像ID一样｡

01:37.330 --> 01:38.690
它应该有一个描述,

01:38.690 --> 01:39.920
这是一个字符串,

01:39.920 --> 01:47.440
它应该有一个人员属性, 这是一个数字, 这是分配给一个项目的人数｡

01:47.440 --> 01:49.580
我还想补充一点, 这是我们目前还没有的,

01:49.580 --> 01:53.580
实际上是一个项目状态｡

01:53.580 --> 01:58.680
因为现在当我们在这里添加一个项目时, 它会出现在两个列表中｡

01:58.680 --> 02:01.530
现在, 我想为一个项目添加状态,

02:01.530 --> 02:03.630
当然状态是可以更改的,

02:03.630 --> 02:07.470
这样我们就可以在第一个框中筛选活动项目,

02:07.470 --> 02:11.470
在第二个框中筛选已完成的项目｡

02:11.470 --> 02:15.000
因此, 仅在每个框中显示正确的项目｡ 

02:15.000 --> 02:19.890
因此, 我将在这里添加另一个公共属性, 状态｡ 

02:19.890 --> 02:21.280
现在的问题当然是,

02:21.280 --> 02:23.985
这种地位应该是哪一种？

02:23.985 --> 02:28.240
现在, 我们可以使用一个联合类型, 其中包含两个文本类型Active和Finished,

02:28.240 --> 02:31.170
我们前面已经使用过了｡

02:31.170 --> 02:33.280
但在这里, 我总是想介绍或重新介绍另一种类型,

02:33.280 --> 02:38.320
你学到了, 这是枚举｡

02:38.320 --> 02:41.890
枚举在这里是完美的, 因为我们正好有两个选项｡ 

02:41.890 --> 02:44.950
在这个项目对象的上下文中, 我们也不需要一个对人类有意义的文本,

02:44.950 --> 02:52.341
我们把它存储为一个值, 我们只需要一些标识符｡

02:52.341 --> 02:56.140
因此, 在这里我将添加一个新的Enum项目状态｡ 

02:56.140 --> 03:02.890
这里有两个值, Active和Finished.

03:02.890 --> 03:05.440
在这里, 此状态将是项目状态类型,

03:05.440 --> 03:08.610
就像这样｡

03:08.610 --> 03:11.003
现在这是我的专题课｡ 

03:11.900 --> 03:17.820
在这里, 我们可以说这是一个使用该项目类的项目数组｡

03:17.820 --> 03:20.351
当然, 当我们在这里创建一个项目时,

03:20.351 --> 03:26.620
我们是通过使用新项目project而不是项目状态来完成的｡

03:26.620 --> 03:30.310
在这里, 为了投影, 我们转发了一个ID,

03:30.310 --> 03:32.200
如前所述, 一个随机数,

03:32.200 --> 03:38.210
我们将其转换为字符串, 然后是标题, 然后是描述,

03:38.210 --> 03:45.080
然后是人物的数量, 当然, 还有状态｡

03:45.080 --> 03:54.830
在这个演示项目的应用程序中, 我希望每个新项目默认都处于活动状态｡

03:54.830 --> 04:00.064
因此, 当我们在这里创建一个新项目时, 我们会分配projectstatus｡

04:00.064 --> 04:00.064
在这里作为状态的值,

04:00.064 --> 04:05.230
我们必须添加项目｡

04:05.230 --> 04:08.450
现在还有一个地方需要项目类｡

04:08.450 --> 04:11.220
在这里的项目列表类中, 我们有Assign

04:11.220 --> 04:13.474
projects属性｡

04:13.474 --> 04:17.240
当然, 这应该是一系列的项目｡ 

04:17.240 --> 04:19.530
现在我们使用Beta打字｡ 

04:19.530 --> 04:22.810
其中一个优势是, 在渲染项目中,

04:22.810 --> 04:26.360
我们现在还可以实现自动完成｡

04:26.360 --> 04:29.020
我们也会得到一个错误, 一个编译错误,

04:29.020 --> 04:35.360
如果我们试图保存它, 因为现在TypeScript知道我们在这里使用的是什么类型｡

04:35.360 --> 04:39.040
这就是项目Class以及我们如何使用它｡ 

04:39.040 --> 04:41.760
项目类不是唯一的类, 但是,

04:41.760 --> 04:44.230
我们这里还有监听器｡

04:44.230 --> 04:48.630
为此, 我将添加一个新的自定义类型Listener｡ 

04:48.630 --> 04:50.390
名字当然由你定｡ 

04:50.390 --> 04:58.260
我在这里使用类型是因为我想用一个单词来编码函数类型.

04:58.260 --> 04:59.640
那么, 这是什么意思呢？

04:59.640 --> 05:03.270
当然, 我们应用程序中的监听器只是一个函数,

05:03.270 --> 05:05.370
对吗？

05:05.370 --> 05:08.960
我们存储在listener数组中的只是一组函数｡

05:08.960 --> 05:11.060
AddListener推送一个新函数,

05:11.060 --> 05:14.190
当发生变化时, 我们执行该函数｡

05:14.190 --> 05:17.610
所以这里监听器实际上只是一个函数｡ 

05:17.610 --> 05:27.113
但它是一个接收我们的项的函数, 在我们的情况下是某些项和项目数组｡

05:28.500 --> 05:30.410
然后再做一些事情｡ 

05:30.410 --> 05:32.480
为了更精确地定义函数类型,

05:32.480 --> 05:37.440
我们这里没有花括号, 而是用了返回类型, 它是宽的,

05:37.440 --> 05:44.090
这意味着我们不关心监听器函数可能返回的任何值.

05:44.090 --> 05:46.140
在我们和听众一起工作的地方｡ 

05:46.140 --> 05:47.940
我们不需要任何返回类型｡ 

05:47.940 --> 05:51.880
我们只想确保无论谁作为这样的侦听器传递,

05:51.880 --> 05:55.870
都希望在侦听器触发时获得一些项｡

05:55.870 --> 06:02.760
在这里, 我们可以说监听器最终是一个监听器函数数组｡

06:02.760 --> 06:05.670
在这里, 当我推送监听器函数时,

06:05.670 --> 06:08.480
我需要明确它不是普通的函数, 而是一种监听器,

06:08.480 --> 06:12.350
然后一切都能正常工作｡

06:12.350 --> 06:14.530
现在, 在我们使用“添加侦听器”的地方,

06:14.530 --> 06:17.650
也就是下面的地方, 我们现在当然也可以增强我们的键入,

06:17.650 --> 06:23.440
并清楚地表明, 在这里, 我们实际上将得到一堆项目｡

06:23.440 --> 06:27.220
现在, 我们设置了监听器, 添加了项目类型,

06:27.220 --> 06:32.210
这不会改变任何内容｡

06:32.210 --> 06:35.120
如果我们现在添加了一些有用的东西,

06:35.120 --> 06:36.900
如果我添加了第二个项目,

06:36.900 --> 06:40.530
除了第一个项目之外, 第二个项目也会被添加,

06:40.530 --> 06:45.260
而且我们根本没有在任何列表中进行任何过滤｡

06:45.260 --> 06:48.600
在我们继续处理各个部分之前,

06:48.600 --> 06:50.570
请确保单个列表中没有出现重复,

06:50.570 --> 06:53.990
两个框中也没有出现重复,

06:53.990 --> 07:08.010
而是仅显示活动项目和已完成项目, 因此, 已完成项目中最初不会显示任何项目｡

07:08.010 --> 07:09.623
所以我们来解决这个问题｡ 
