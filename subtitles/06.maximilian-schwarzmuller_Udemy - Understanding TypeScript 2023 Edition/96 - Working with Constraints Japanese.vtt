WEBVTT

00:02.340 --> 00:04.100
ナレーター: ジェネリックを使い始めましたが､

00:04.100 --> 00:06.670
TypeScriptがここで何をしているのか､ わかっていただけたでしょうか｡

00:06.670 --> 00:14.370
マージ関数にいくつかの追加情報を渡し､ マージ関数の結果に対してよりよい方法で作業できるようにしているのです｡

00:14.370 --> 00:16.540
ジェネリック医薬品は､ そのためにあるのが普通です｡ 

00:16.540 --> 00:21.960
これにより､ TypeScriptに最適な方法でデータを操作し続けることができる｡

00:21.960 --> 00:23.820
しかし､ この場合､ ここで､

00:23.820 --> 00:28.570
例えば30という数字だけを渡すと問題が発生します｡

00:28.570 --> 00:30.470
もちろん､ TypeScriptは年齢にアクセスしようとしたが､

00:30.470 --> 00:32.010
名前へのアクセスはうまくいったので､

00:32.010 --> 00:33.870
今はエラーを投げている｡

00:33.870 --> 00:37.100
それでも､ これを保存すると､ エラーなしでコンパイルされ､

00:37.100 --> 00:39.710
マージされたオブジェクト全体を表示すると､

00:39.710 --> 00:43.910
オブジェクトの中に趣味と名前だけが表示されます｡ これは､ 30が数字だからで､

00:43.910 --> 00:54.590
これをオブジェクト割り当ての第2引数として渡すと､ 結局､ ここでやっているように､ これはただ黙って失敗するのです｡

00:54.590 --> 00:57.860
JavaScriptはエラーを吐かないし､ 文句も言わない｡ 

00:57.860 --> 01:00.460
しかし､ もちろん､ 新しく作成されたオブジェクトに30をマージすることもありません｡

01:00.460 --> 01:04.690
このオブジェクトには30が存在しないことがわかります｡

01:04.690 --> 01:06.540
さて､ JavaScriptはどのようにしてそうするのでしょうか｡ 

01:06.540 --> 01:08.470
30はオブジェクトではないので､

01:08.470 --> 01:14.090
オブジェクトの割り当てのみで､ 異なるオブジェクト同士を結合することが可能です｡

01:14.090 --> 01:15.410
では､ 結局のところ､ 私たちは何を救いたいのでしょうか？

01:15.410 --> 01:17.600
UとTに提供するオブジェクトの正確な型､

01:17.600 --> 01:22.980
正確な構造は気にしません｡

01:22.980 --> 01:26.600
しかし､ 我々が気にしているのは､ 両方のパラメータ､

01:26.600 --> 01:34.420
両方のタイプTとUは､ どんな種類のオブジェクトであっても､ 常にオブジェクトであるべきだということです｡

01:34.420 --> 01:36.830
そして現状では､ そのようなことは言っていません｡ 

01:36.830 --> 01:37.820
現状では､ 種類は問わない､

01:37.820 --> 01:40.110
というだけです｡

01:40.110 --> 01:41.750
今よくあるのは､ それじゃダメなんです｡ 

01:41.750 --> 01:46.683
ここでTとUの型を制限し､ 汎用型を解決したい｡

01:47.830 --> 01:51.540
型制約を使えば､ それが可能です｡ 

01:51.540 --> 02:05.150
ジェネリックタイプの場合､ ジェネリックタイプのベースとなるタイプに関する制約を設定することができます｡

02:05.150 --> 02:09.020
つまり､ T型はどんな構造を持ったオブジェクトでもいいのですが､

02:09.020 --> 02:15.340
オブジェクトでなければならないのです｡

02:15.340 --> 02:17.480
私たちはUに同じことをすることができます｡ 

02:17.480 --> 02:21.820
そうすると､ IDEですでにエラーが発生しているのがわかります｡

02:21.820 --> 02:23.980
また､ それを保存しようとすると､

02:23.980 --> 02:26.150
コンパイラでエラーが発生します｡

02:26.150 --> 02:31.133
ここのタイプ30の引数は､ タイプオブジェクトに代入できないからです｡

02:32.080 --> 02:34.480
だから､ もちろん､ ここで欲しいのはその動作なのです｡ 

02:34.480 --> 02:39.940
これでまた､ おっと､ こんな感じでオブジェクトを渡すことを余儀なくされました｡

02:39.940 --> 02:41.990
そのため､ この関数を改良して､

02:41.990 --> 02:45.290
本当に動くようにしました｡

02:45.290 --> 02:48.980
そして､ オブジェクトの割り当てでは､ 2つのオブジェクトが必要であることが分かっています｡ 

02:48.980 --> 02:52.820
つまり､ 最終的には､ 一般的な型にある種の制約を設けることで､

02:52.820 --> 02:56.370
2つのオブジェクトを得ることを保証したいのです｡

02:56.370 --> 02:58.630
そして､ ここでいう制約とは､ 何でもいいのです｡ 

02:58.630 --> 03:03.730
オブジェクトを参照したり､ 文字列を参照したり､ 独自の型を持っていればそれを使うこともできます｡

03:03.730 --> 03:06.700
必要であれば､ ここでユニオン型を使うこともできます｡

03:06.700 --> 03:10.510
ここは本当に柔軟で､ 好きな制約を設定することができます｡

03:10.510 --> 03:13.720
もちろん､ すべての汎用型を制約する必要はない｡

03:13.720 --> 03:16.560
Uを制約するだけなら､ それも可能です｡ 

03:16.560 --> 03:19.620
この例では､ オブジェクトの割り当てが2つのオブジェクトを必要とするため､

03:19.620 --> 03:24.640
両方を制約することは理にかなっていますが､ そこは本当に柔軟です｡

03:24.640 --> 03:26.620
しかし､ 制約の概念を意識することは重要です｡

03:26.620 --> 03:30.560
なぜなら､ 制約によって､ より最適な方法で汎用型を扱うことができ､

03:30.560 --> 03:37.513
以前のような不要なエラーや奇妙な動作を回避することができるからです｡
