WEBVTT

00:02.270 --> 00:05.080
教师：我们可以在方法装饰器上返回一些东西,

00:05.080 --> 00:06.820
这些东西应该是一个描述符,

00:06.820 --> 00:11.000
它允许我们改变方法或者改变方法的配置｡

00:11.000 --> 00:12.582
这是我想做的事

00:12.582 --> 00:15.985
在此之前, 我将首先转到索引HTML文件,

00:15.985 --> 00:18.540
在那里, 让我们添加一个按钮｡

00:18.540 --> 00:21.272
Click Me, 一个非常简单的按钮,

00:21.272 --> 00:26.104
在我的应用程序中｡ ts文件, 现在我想确保当我们单击此按钮时,

00:26.104 --> 00:29.800
我们会在对象上执行一个方法｡

00:29.800 --> 00:32.120
为此, 我将在这里添加一个新类,

00:32.120 --> 00:34.600
首先是printer｡

00:34.600 --> 00:38.140
在这里我需要一个属性消息, 它是这样工作的,

00:38.140 --> 00:41.690
一个简单的字符串存储在这里, 然后我需要一个显示消息的方法,

00:41.690 --> 00:49.630
在这里我只需要控制台记录这个消息｡

00:49.630 --> 00:51.770
当然, 这是一个简单的虚拟类,

00:51.770 --> 00:54.860
但这仍然允许我向你们展示我想展示的东西｡

00:54.860 --> 00:56.550
现在让我们选择按钮到门,

00:56.550 --> 01:02.970
与文档查询选择器按钮, 让我们添加一个事件侦听器｡

01:02.970 --> 01:07.800
首先, 我在这里添加感叹号, 让TypeScript清楚地知道它的存在,

01:07.800 --> 01:10.990
它不会为空, 然后我将添加一个事件侦听器, 一个单击事件侦听器,

01:10.990 --> 01:16.450
然后我想在这里触发这个show message方法.

01:16.450 --> 01:23.120
为此, 我将在这里创建一个新的打印机, 就像这样, 然后在这里指向p｡

01:23.120 --> 01:23.120
showMessage,

01:23.120 --> 01:24.323
这就是我想法

01:25.300 --> 01:27.103
现在, 如果我们保存它,

01:28.153 --> 01:33.320
然后返回到我们的页面并单击此按钮, 我们将在此处得到未定义的内容,

01:33.320 --> 01:36.050
但是, 我们不会显示消息｡

01:36.050 --> 01:38.860
原因在于, 如果我们使用事件监听器, 指向一个应该执行的函数,

01:38.860 --> 01:52.193
那么函数中的this关键字的上下文和引用就不会和我们只调用p时的上下文和引用一样了｡

01:52.193 --> 01:52.193
ShowMessage,

01:53.144 --> 01:56.450
在本例中, 这将是指打印机｡

01:56.450 --> 02:00.200
不, 在这里我们使用事件侦听器的场景中, 这将引用事件的目标,

02:00.200 --> 02:09.560
因为addEventListener最终在要执行的函数中将其绑定到事件的目标｡

02:09.560 --> 02:11.360
当然, 我也不想这样｡ 

02:11.360 --> 02:14.170
现在, 这里的一个常见解决方案是使用bind方法并将showMessage绑定到p,

02:14.170 --> 02:31.770
或者将showMessage中的this绑定到p, 以便在执行时, 它不会引用addEventListener希望它引用的内容, 而是showMessage内部的this将引用此p, 再次引用此处的此对象｡

02:31.770 --> 02:33.300
如果我们现在, 如果我们在这里重新加载,

02:33.300 --> 02:36.270
我再次清除这个, 现在我们看到这个工作！

02:36.270 --> 02:39.240
现在, 这些都是默认JavaScript｡ 

02:39.240 --> 02:40.790
现在, 我们将构建一个装饰器,

02:40.790 --> 02:42.191
我们可以将它添加到这个方法中,

02:42.191 --> 02:53.440
它会自动将它绑定到周围的类, 也就是绑定到这个方法所属的对象, 每次调用它时, 不管我们在哪里调用它.

02:53.440 --> 02:55.974
因此, 在打印机上面我将添加一个新函数, 我将它命名为autobind,

02:55.974 --> 03:01.580
因为这是我们最终要做的, 这将是我的装饰器autobind｡

03:01.580 --> 03:03.890
当然, 也可以使用大写的起始字符来与我们的其他命名保持一致,

03:03.890 --> 03:10.122
但同样, 在定义装饰器函数时, 您可以使用这两个字符中的任何一个｡

03:10.122 --> 03:15.269
现在这已经是我的室内设计师了, 在这里我们有几个参数｡

03:15.269 --> 03:17.940
你会知道, 只要我们找到目标, 那就是任何目标｡ 

03:17.940 --> 03:20.085
它要么是对象的原型,

03:20.085 --> 03:22.533
要么是构造函数, 如果我们要把它加到静态方法中,

03:22.533 --> 03:30.200
但这里它是原型, 因为我们要把它加到实例方法中.

03:30.200 --> 03:33.690
然后我们有了方法名或者属性名, 但是因为我们把它加到了一个方法上,

03:33.690 --> 03:36.330
所以我们可以调用这个方法名, 这样更有意义｡

03:36.330 --> 03:38.600
如果这是一个字符串或符号, 或者它也可以是一个数字,

03:38.600 --> 03:40.229
当然, 但我们知道我们通常会处理字符串,

03:40.229 --> 03:45.061
所以我们也可以在这里只使用字符串, 这取决于你计划在哪里添加这个装饰器,

03:45.061 --> 03:56.340
以及它应该有多通用, 最后但同样重要的是, 我们在这里得到描述符, 它将是PropertyDescriptor类型的警报｡

03:56.340 --> 03:57.650
现在我们有了这三个参数,

03:57.650 --> 03:59.655
我们都用在了Log3上,

03:59.655 --> 04:03.540
它以前是我们的方法装饰器｡

04:03.540 --> 04:11.973
在autobind中, 我现在要确保我们总是把this关键字设置为这个方法所属的对象｡

04:11.973 --> 04:14.240
我们如何才能做到这一点呢？

04:14.240 --> 04:17.880
首先, 我必须访问应该调用的方法｡

04:17.880 --> 04:20.661
在我们的描述符的帮助下, 这将成为可能,

04:20.661 --> 04:22.013
因为如果你重新加载应用程序,

04:22.013 --> 04:29.460
你会看到下面的方法描述符, 你会看到我们在描述符中获得了值属性, 它指向函数｡

04:29.460 --> 04:32.240
因为这个属性的值是一个函数, 所以在这个例子中,

04:32.240 --> 04:35.498
方法只是一个属性, 它的值是一个函数｡

04:35.498 --> 04:38.630
所以value键保存了原始函数, 所以, 在这里,

04:38.630 --> 04:47.320
我们可以提取原始方法, 如果我们想通过访问描述符来调用它｡

04:47.320 --> 04:47.320
的值｡ 

04:47.320 --> 04:50.563
这将使我们能够访问, 嗯, 原始方法｡ 

04:51.790 --> 04:55.450
接下来, 我将设置一个新的调整后的描述符,

04:55.450 --> 04:58.320
这将是我们最后返回的内容｡

04:58.320 --> 05:00.030
现在, 这将是一个对象,

05:00.030 --> 05:03.620
它的类型为属性描述符｡

05:03.620 --> 05:09.350
在这个对象中, 我们可以添加所有可以添加到属性描述符中的内容｡

05:09.350 --> 05:12.110
例如, 可以将它设置为可配置的, 真,

05:12.110 --> 05:14.962
将可枚举的设置为假, 这样它就不会出现在外部循环中,

05:14.962 --> 05:17.130
现在在这里添加一个getter,

05:17.130 --> 05:20.310
这是新的｡

05:20.310 --> 05:23.400
我在这里添加了一个getter, 它是一个方法,

05:23.400 --> 05:26.150
或者是一个保存函数的属性, 这是一样的,

05:27.020 --> 05:32.260
这样当用户试图访问这个属性时, 我们就可以执行一些额外的逻辑｡

05:32.260 --> 05:35.170
这样我们就不会直接执行这个属性的值,

05:35.170 --> 05:36.633
也就是函数, 而是可以在执行函数之前,

05:36.633 --> 05:40.850
介入并做一些额外的工作｡

05:40.850 --> 05:41.913
这就是我的想法

05:43.230 --> 05:46.290
我没有在这个描述符中添加一个value属性,

05:46.290 --> 05:51.540
我只是有一个getter, getter基本上就像是一个value属性,

05:51.540 --> 05:54.777
在返回值之前运行额外的逻辑｡

05:54.777 --> 06:03.450
在这里, 我需要一个绑定函数, 我可以使用我们在这里提取的原始方法,

06:03.450 --> 06:07.100
调用bind并绑定这个.

06:07.100 --> 06:08.590
现在的遗赠,

06:08.590 --> 06:11.730
当然, 是指什么在这里？

06:11.730 --> 06:13.720
请记住它在getter方法内部,

06:13.720 --> 06:19.510
因此它将引用负责触发此getter方法的任何内容｡

06:19.510 --> 06:23.700
这就是诀窍, getter方法将由它所属的具体对象触发,

06:23.700 --> 06:33.610
所以getter方法的内部将始终引用我们定义getter的对象.

06:33.610 --> 06:36.800
这不会被addEventListener覆盖,

06:36.800 --> 06:38.965
因为getter就像是我们正在执行的函数､

06:38.965 --> 06:44.976
它所属的对象和事件侦听器之间的一个额外的层｡

06:44.976 --> 06:51.610
因此, 这里的this将引用我们最初定义方法的对象｡

06:51.610 --> 06:54.660
所以我们可以安全地为原始方法绑定this,

06:54.660 --> 07:01.170
并确保现在原始方法内部的this也将引用完全相同的对象｡

07:01.170 --> 07:08.910
现在我将在这里返回绑定函数, 然后在这个调整后的描述符之外返回调整后的描述符｡

07:08.910 --> 07:10.560
这就是我们的装饰器函数,

07:10.560 --> 07:12.420
返回一个新的描述符对象,

07:12.420 --> 07:14.103
因此这个描述符对象将覆盖旧的描述符,

07:14.103 --> 07:18.710
这就是TypeScript将对它做的事情｡

07:18.710 --> 07:21.500
然后TypeScript将替换旧的方法描述符,

07:21.500 --> 07:28.513
因此旧的方法配置与此处的新配置（添加了额外的getter层）相同｡

07:29.460 --> 07:33.330
现在, 我对目标和方法名不感兴趣, 当然,

07:33.330 --> 07:39.083
为了避免错误, 我将这个下划线和这个下划线命名为2｡

07:40.260 --> 07:43.070
同样, 只是告诉TypeScript我对这些值不感兴趣,

07:43.070 --> 07:45.480
但我需要接受它们｡

07:45.480 --> 07:49.800
现在, 让我们在此处为showMessage添加自动绑定｡ 

07:49.800 --> 07:52.203
在这里, 我将在Autobind添加,

07:54.050 --> 07:56.490
并确保在事件侦听器中删除了bind,

07:56.490 --> 07:59.236
然后保存它｡

07:59.236 --> 08:01.450
现在让我们来看看, 让我们单击“Click

08:01.450 --> 08:04.730
Me”, 您应该会看到“This Works”！

08:04.730 --> 08:06.678
如果我重新装弹, 这个就能用了｡ 

08:06.678 --> 08:09.680
因为现在已正确绑定｡ 

08:09.680 --> 08:12.060
为了验证是我们的装饰器起了作用,

08:12.060 --> 08:15.868
如果我在getter和装饰器中删除绑定并保存它,

08:15.868 --> 08:17.850
你会看到, 如果它现在重新加载,

08:17.850 --> 08:23.626
我们单击Click me, 我们会再次看到undefined｡

08:23.626 --> 08:27.389
因此, 实际上是这个额外的getter层在这里工作,

08:27.389 --> 08:30.430
它确保无论如何调用showMessage,

08:30.430 --> 08:33.260
它总是被正确绑定｡

08:33.260 --> 08:35.380
如果我们像这样直接在对象上调用它,

08:35.380 --> 08:38.350
它将工作, 如果我们像这样用事件侦听器在这里调用它,

08:38.350 --> 08:40.760
它也将工作｡

08:40.760 --> 08:42.260
您可以看到它在这里工作,

08:42.260 --> 08:45.070
它最终来自showMessage调用,

08:45.070 --> 08:48.266
如果我单击按钮, 您也可以看到它工作｡

08:48.266 --> 08:49.918
因此, 这是一个简洁的示例,

08:49.918 --> 08:52.060
说明了如何利用装饰器构建一个相当令人惊奇的功能,

08:52.060 --> 08:58.718
并省去了在任何地方手动调用bind的麻烦｡

08:58.718 --> 09:01.883
而是像这样绑定｡ 
