WEBVTT

00:02.060 --> 00:04.880
Tipo de relação com o operador de propagação

00:04.880 --> 00:07.060
são parâmetros de repouso.

00:07.060 --> 00:10.374
E para isso, vou novamente ajustar minha função de adição.

00:10.374 --> 00:13.870
Portanto, vou comentar todo esse código aqui em cima

00:13.870 --> 00:15.780
para que nada se quebre.

00:15.780 --> 00:20.520
E readmitir minha função de adição com qualquer sintaxe que você queira com a palavra-chave

00:20.520 --> 00:22.760
da função como uma função de seta, o que você

00:22.760 --> 00:23.830
quiser.

00:23.830 --> 00:26.360
Mas agora eu quero ter uma função especial.

00:26.360 --> 00:29.100
Não quero limitá-lo a dois valores, quero

00:29.100 --> 00:31.340
poder acrescentar tantos valores

00:31.340 --> 00:33.290
quanto um usuário passar.

00:33.290 --> 00:37.700
Para que possamos basicamente chamar de adicionar assim, cinco,

00:37.700 --> 00:42.700
dez, dois, três pontos sete, e assim por diante, com tantos valores quanto

00:42.880 --> 00:44.530
você quiser.

00:44.530 --> 00:46.691
Se você quiser chamá-lo com 10 valores, isso

00:46.691 --> 00:48.090
também deve ser possível.

00:48.090 --> 00:51.160
Agora, no entanto, é claro, neste momento não é possível, como

00:51.160 --> 00:52.600
você pode ver claramente.

00:52.600 --> 00:54.290
O texto datilografado está me dando um

00:54.290 --> 00:57.760
erro, e corretamente, porque não estou aceitando nenhum argumento aqui.

00:57.760 --> 01:00.336
Agora, é claro que eu poderia aceitar os argumentos

01:00.336 --> 01:02.210
aqui e atribuir os tipos corretos, mas

01:02.210 --> 01:04.300
e se eu então chamá-lo com cinco.

01:04.300 --> 01:06.330
Como eu disse, quero ser flexível.

01:06.330 --> 01:08.850
É aí que entram os parâmetros de descanso.

01:08.850 --> 01:13.111
No lugar onde você espera uma lista de valores, então não onde você

01:13.111 --> 01:15.270
quer passá-la, mas onde você quer

01:15.270 --> 01:18.308
aceitá-la como valores recebidos, você também

01:18.308 --> 01:20.360
pode usar os três pontos e depois

01:20.360 --> 01:24.043
qualquer nome de sua escolha, como números.

01:25.630 --> 01:27.430
Agora o que isto fará é

01:27.430 --> 01:31.470
fundir todos os parâmetros de entrada, ou geralmente

01:31.470 --> 01:34.920
a lista de entrada de valores, lista de valores

01:34.920 --> 01:39.350
separados por vírgulas, em uma matriz.

01:39.350 --> 01:40.940
Portanto, os números aqui serão

01:40.940 --> 01:44.460
uma matriz, mas é claro que por padrão um tipo de qualquer valor, portanto

01:44.460 --> 01:46.920
uma matriz cheia de quaisquer valores, e não é isso

01:46.920 --> 01:48.300
que devemos fazer, devemos

01:48.300 --> 01:49.680
ser mais explícitos.

01:49.680 --> 01:53.200
E aqui poderíamos dizer: "Será um conjunto de números. Assim.

01:53.200 --> 01:54.430
Portanto, agora estamos definindo o tipo

01:54.430 --> 01:56.420
correto e agora trabalhamos com essa matriz de números.

01:56.420 --> 01:58.710
Agora podemos resumir isso de duas maneiras diferentes.

01:58.710 --> 02:01.880
Podemos trabalhar com uma variável de resultado e depois com um loop

02:01.880 --> 02:04.110
de quatro, porque os números são uma matriz.

02:04.110 --> 02:06.863
Portanto, aqui poderíamos fazer um loop através dos

02:06.863 --> 02:09.260
números e acrescentar isso ao resultado.

02:09.260 --> 02:11.519
Ou usamos o método de redução que está disponível em arrays.

02:11.519 --> 02:15.620
Reduzir trabalhos de forma a realizar uma operação em cada elemento

02:15.620 --> 02:19.030
de uma matriz, retorna um resultado e depois adiciona estes

02:19.030 --> 02:20.940
resultados em conjunto.

02:20.940 --> 02:24.310
Para isso você fornece uma função para reduzir e

02:24.310 --> 02:27.160
depois um valor inicial que aqui é zero.

02:27.160 --> 02:31.093
E então esta função que você passa para se reduzir leva

02:31.093 --> 02:33.430
dois argumentos e esse é o resultado

02:33.430 --> 02:35.920
atual que você poderia dizer.

02:35.920 --> 02:38.968
E é o valor atual que estamos analisando,

02:38.968 --> 02:42.640
que será cada valor da matriz.

02:42.640 --> 02:45.350
E então aqui você pode retornar cuResultado, que para

02:45.350 --> 02:48.290
a primeira corrida será aquele valor inicial aqui.

02:48.290 --> 02:51.497
Mais valor curValor.

02:51.497 --> 02:52.703
E se você fizer isso, a redução geral aqui retornará um número.

02:53.859 --> 02:57.920
Portanto, aqui podemos retornar o resultado geral de números

02:57.920 --> 03:01.160
reduzidos e, portanto, a variável de adição, ou constante

03:01.160 --> 03:04.790
aqui, terá no final uma função que leva um par de números,

03:04.790 --> 03:07.320
não uma matriz de números.

03:07.320 --> 03:10.650
Mas por causa dos parâmetros restantes, uma lista de

03:10.650 --> 03:13.690
números, que é então fundida em uma matriz dentro

03:13.690 --> 03:16.510
da função e que retorna o número no final.

03:16.510 --> 03:18.550
Então, por enquanto, se salvarmos tudo,

03:18.550 --> 03:20.350
tudo deve funcionar e vemos aqui

03:20.350 --> 03:23.350
o resultado, a soma de nossa pequena adição.

03:23.350 --> 03:26.250
Portanto, são parâmetros de descanso, uma característica

03:26.250 --> 03:28.430
realmente útil para aceitar uma quantidade

03:28.430 --> 03:31.400
ilimitada de argumentos.

03:31.400 --> 03:34.210
E um par de métodos embutidos como o método

03:34.210 --> 03:36.680
push funcionam exatamente assim.

03:36.680 --> 03:38.540
Veja, empurrar aqui tem esta estranha definição de parâmetros.

03:38.540 --> 03:42.560
Bem, isso é exatamente o que acabamos de aprender.

03:42.560 --> 03:44.250
Empurre aqui alguns itens

03:44.250 --> 03:48.490
para esta matriz, que é uma matriz cheia de cordas.

03:48.490 --> 03:50.400
É preciso um par de cordas.

03:50.400 --> 03:51.730
E isto não significa que é necessário

03:51.730 --> 03:54.060
um conjunto de cordas, mas sim, aqui com os parâmetros

03:54.060 --> 03:56.400
restantes, uma lista de cordas separadas por vírgula,

03:56.400 --> 03:58.580
que dentro do alpendre é então fundida em uma matriz

03:58.580 --> 04:01.260
e tratada internamente.

04:01.260 --> 04:03.100
Esta é a sintaxe dos demais parâmetros.

04:03.100 --> 04:06.276
A propósito, você pode até combinar isto com os tufos.

04:06.276 --> 04:10.370
Se você sabe que quer apoiar múltiplos argumentos

04:10.370 --> 04:15.370
mas sabe quantos serão, então se não for uma lista ilimitada,

04:16.520 --> 04:18.420
então você também pode usar

04:18.420 --> 04:20.392
um tipo de tuple lá.

04:20.392 --> 04:23.430
E, por exemplo, dizer: "Eu aceito meus números gratuitos aqui. E então eu tenho que remover o quarto

04:23.430 --> 04:28.430
argumento aqui, é claro, ao chamar a função.

04:28.460 --> 04:30.910
Porque agora estou bem claro que quero ter três argumentos,

04:30.910 --> 04:32.240
que são números cada um.

04:32.240 --> 04:33.830
Portanto, é claro que poderíamos ter adicionado

04:33.830 --> 04:36.980
apenas três parâmetros independentes aqui, mas esta sintaxe ainda pode ser um pouco

04:36.980 --> 04:39.030
mais curta ou mais fácil de ser configurada do que a adição

04:39.030 --> 04:40.720
dos parâmetros livres.

04:40.720 --> 04:43.090
Isso depende realmente de sua aplicação e de suas exigências.

04:43.090 --> 04:46.919
Aqui vou me afastar dessa configuração e ser mais genérico

04:46.919 --> 04:51.320
e aceitar todos os argumentos que conseguir, pois para esta

04:51.320 --> 04:55.210
função sou realmente capaz de lidar com uma quantidade

04:55.210 --> 04:57.864
infinita de argumentos.
