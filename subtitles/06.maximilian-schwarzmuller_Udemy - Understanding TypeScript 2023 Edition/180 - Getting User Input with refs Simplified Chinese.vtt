WEBVTT

00:02.240 --> 00:04.870
演示者：我们添加了第一个组件｡ 

00:04.870 --> 00:06.090
我们再加一个｡ 

00:06.090 --> 00:09.970
新托多｡  tsx是文件名｡ 

00:09.970 --> 00:13.060
当然, 在那里, 我们从反应中导入反应｡ 

00:13.060 --> 00:16.170
当然, 您也可以构建基于类的组件｡ 

00:16.170 --> 00:22.410
这也是完全支持的, 但我将使用这种现代的功能组件唯一的风格｡

00:22.410 --> 00:24.070
这里我们又有了一个函数,

00:24.070 --> 00:26.180
它将在后面组成我们的组件｡

00:26.180 --> 00:29.258
我将NewTodo导出为默认值,

00:29.258 --> 00:31.260
然后添加一个类型赋值,

00:31.260 --> 00:34.410
并明确这将是一个类型函数组件.

00:34.410 --> 00:38.220
当然, 这里我们缺少一些返回的jsx代码｡

00:38.220 --> 00:39.730
因此, 在这里我将返回一个表单,

00:39.730 --> 00:43.780
在其中添加允许用户添加新待办事项所需的所有控件｡

00:45.060 --> 00:48.650
现在, 让我们在app组件中添加这个新的todo组件｡ 

00:48.650 --> 00:58.095
在这里我们可以从导入NewTodo｡  /components/NewTodo并在此处添加它而不是注释｡

00:58.095 --> 01:00.520
NewTodo作为一个自结束组件,

01:00.520 --> 01:04.750
因为现在我们没有在开始和结束标记之间传递任何东西,

01:04.750 --> 01:09.263
而且这里也没有任何道具, 至少现在是这样.

01:10.140 --> 01:11.540
因此, 我们现在可以添加一个输入,

01:11.540 --> 01:16.190
然后再添加一个按钮, 而不是这个组件｡

01:16.190 --> 01:18.117
所以在这里添加一个div,

01:18.117 --> 01:20.020
我想在其中有一个标签, 上面有htmlFor属性指向,

01:20.020 --> 01:24.880
比如说, “todo-text”｡

01:24.880 --> 01:26.560
这只是一个标记,

01:26.560 --> 01:35.170
我说“todoText”, 然后输入id为“todoText”的text类型元素,

01:35.170 --> 01:39.640
这样标签和输入就可以在语义上正确连接｡

01:39.640 --> 01:41.440
在这个div下面, 我将添加一个按钮来代替表单,

01:41.440 --> 01:49.670
在这里我说, “ADD TODO, ”这个按钮应该是submit类型, 这样它就提交了表单.

01:49.670 --> 01:53.143
现在这是一个非常基本的表单, 我们可以使用它来添加一个新的待办事项｡

01:54.580 --> 01:57.060
现在, 让我们来确保这是可行的,

01:57.060 --> 02:01.820
为此, 我们实际上需要应用几个不同的步骤｡

02:01.820 --> 02:05.020
我们需要获取用户在此处输入的任何内容,

02:05.020 --> 02:09.810
然后需要将用户在此处输入的内容转发到应用程序组件,

02:09.810 --> 02:13.330
因为稍后我们将在此管理待办事项｡

02:13.330 --> 02:16.150
首先, 我们来看看表单提交｡ 

02:16.150 --> 02:18.050
我们可以添加一个新函数, 也就是函数组件中的函数,

02:18.050 --> 02:22.720
但它现在是一个常规函数, 我们将其命名为, “todoSubmitsHandler,

02:22.720 --> 02:27.720
”任何你想要的名字.

02:28.210 --> 02:31.860
这是一个在提交此表单时应触发的函数｡

02:31.860 --> 02:35.571
所以我们可以把它绑定到onSubmit属性, todoSubmitsHandler,

02:35.571 --> 02:43.810
不要执行它, 只要指向它, 这样只要提交表单, 它就会为我们执行.

02:43.810 --> 02:49.507
在这里我们得到一个事件对象, 该事件对象的类型为react｡

02:49.507 --> 02:49.507
窗体事件｡ 

02:51.290 --> 02:55.780
现在我想调用event prevent default来阻止默认设置,

02:55.780 --> 02:59.280
即向服务此应用的服务器发送一个真实的请求｡

02:59.280 --> 03:01.520
我当然不想在那个时候发生｡ 

03:01.520 --> 03:04.680
我只想在JavaScript中处理此请求,

03:04.680 --> 03:08.350
因此必须阻止此浏览器默认设置｡

03:08.350 --> 03:09.770
现在, 在防止这种情况的情况下,

03:09.770 --> 03:12.610
我们可以获得用户在输入中输入的任何内容, 为此,

03:12.610 --> 03:15.250
我们有两种不同的方法｡

03:15.250 --> 03:18.310
我们可以在这里管理输入的状态, 有点像双向绑定,

03:18.310 --> 03:20.970
或者我们使用ref, 一个引用,

03:20.970 --> 03:26.520
来提取用户在提交表单时在这里输入的内容｡

03:26.520 --> 03:28.410
我将选择后一种方法,

03:28.410 --> 03:33.470
因为我们很快就会看到应用程序组件中的状态管理｡

03:33.470 --> 03:37.340
为了建立这样一个引用, 我们从react导入useRef钩子,

03:37.340 --> 03:40.580
钩子是一些特殊的函数, 你可以执行这些函数,

03:40.580 --> 03:48.101
并调用组件来为组件添加某些功能, 当我们在这里执行useRef时, 我们得到的是一个Ref对象,

03:48.101 --> 03:57.310
我们可以将其存储在一个常量中, 我将其命名为“textInputRef”｡

03:57.310 --> 04:00.176
例如, 我们可以使用这样一个引用将其分配给一个dom元素,

04:00.176 --> 04:06.500
然后在我们的代码中与该dom元素进行交互｡

04:06.500 --> 04:08.800
例如, 当表单被提交时｡ 

04:09.680 --> 04:19.150
我们通过将特殊的Ref属性添加到您选择的任何html元素并指向我们在此处创建的对象来建立这样一个连接｡

04:19.150 --> 04:21.530
因此添加textInputRef｡ 

04:21.530 --> 04:23.540
这在这里建立了一个连接｡ 

04:23.540 --> 04:27.380
但是, 您已经再次看到TypeScript并不像这样｡ 

04:27.380 --> 04:33.250
因为useRef也是一个泛型函数｡

04:33.250 --> 04:35.270
现在, 我们可以将哪种类型传递给它｡ 

04:35.270 --> 04:37.340
这里有什么有趣的信息？

04:37.340 --> 04:39.200
知道哪种类型的数据将被存储在图中是很有趣的,

04:39.200 --> 04:47.880
因为你指向了input元素, 我们将有一个html input元素存储在那里｡

04:47.880 --> 04:51.840
现在我们只需要在设置Ref时为它提供一个默认值,

04:51.840 --> 04:53.190
我们将在那里提供null,

04:53.190 --> 04:57.380
因为当组件第一次呈现时, 当代码执行时, 当然还没有呈现,

04:57.380 --> 05:01.590
所以它不会指向任何东西｡

05:01.590 --> 05:03.350
但是, 一旦渲染了该引用,

05:03.350 --> 05:07.040
将建立连接, 然后该引用将工作｡

05:07.040 --> 05:15.342
现在在todoSubmitHandler中, 我们可以使用textInputRef获取输入的文本｡

05:15.342 --> 05:15.342
current,

05:15.500 --> 05:21.440
这是您在使用Ref时始终需要输入的内容｡

05:21.440 --> 05:21.440
值,

05:21.440 --> 05:24.530
因为我们使用html输入元素｡

05:24.530 --> 05:27.940
然而, 这里的问题是, 这可能是空的｡ 

05:27.940 --> 05:29.630
这是我们已经知道的问题, 我们在课程早期也遇到过这个问题,

05:29.630 --> 05:38.800
当我们在Dom中选择某个内容时, 我们在这里也遇到过这个问题, 因为TypeScript无法确定是否建立了这种连接｡

05:38.800 --> 05:40.580
我们知道这一点, 我们编写了代码,

05:40.580 --> 05:45.300
但不幸的是, TypeScript不理解我们在那里建立了一个连接｡

05:46.310 --> 05:48.920
为了解决这个问题, 我们可以在这里添加一个感叹号,

05:48.920 --> 05:51.350
再次告诉TypeScript, 这将是好的,

05:51.350 --> 05:54.350
这将是设置, 我们是好的｡

05:54.350 --> 05:56.130
顺便说一下, TypeScript是正确的,

05:56.130 --> 06:00.590
如果我们在这里调用todoSubmitHandler, 这将被称为转发,

06:00.590 --> 06:05.000
这是第一次呈现, 实际上还没有初始化｡

06:05.000 --> 06:10.830
我们只知道它将被确定地初始化, 因为我们知道只有在提交表单时才会调用它,

06:10.830 --> 06:13.830
并且只有在呈现表单后才会调用它｡

06:13.830 --> 06:16.120
所以我们知道代码的工作方式｡ 

06:16.120 --> 06:18.360
它永远不会为null｡ 

06:18.360 --> 06:26.030
如果存在其他可能性, 则必须在此处使用if-check来检查textInputRef.

06:26.030 --> 06:26.030
current为null,

06:26.030 --> 06:27.620
如果是, 请执行其他操作

06:27.620 --> 06:29.550
但在这里这不可能发生｡ 

06:29.550 --> 06:31.230
因此, 我们提取了一个值,

06:31.230 --> 06:34.640
我们可以安慰｡ 请在此记录, 以查看它是否有效｡ 

06:34.640 --> 06:37.040
但当然这不是最后的设置｡ 

06:37.040 --> 06:40.900
我们保存它, 在这里输入, 在一个月内完成它,

06:40.900 --> 06:47.970
然后添加todo, 我们可以在控制台日志中看到它｡

06:47.970 --> 06:50.310
这是它应该的工作方式｡ 

06:50.310 --> 06:51.910
在它正常工作的情况下,

06:51.910 --> 06:55.460
现在让我们确保应用程序组件获得了该值｡

06:55.460 --> 06:58.820
如果你知道一些反应, 一定要先自己尝试一下｡ 

06:58.820 --> 07:00.963
下节课我们会一起做｡ 
