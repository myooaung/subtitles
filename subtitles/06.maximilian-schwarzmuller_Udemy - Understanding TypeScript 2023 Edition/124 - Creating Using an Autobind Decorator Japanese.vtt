WEBVTT

00:02.220 --> 00:04.550
-: デコレーターを追加すれば､ "this"

00:04.550 --> 00:09.930
キーワードを自動的にバインドしてくれるので､ ここでバインドを呼び出さなくてもよくなりますね｡

00:09.930 --> 00:14.160
ここでbindを呼び出すことは､ 何も問題がなければ大したことではありません｡

00:14.160 --> 00:24.970
しかし､ 学んだことを実践して､ アプリ全体の多くの場所でこれを行う必要がある場合は､ デコレータを追加する方が実際に簡単かもしれません｡

00:24.970 --> 00:27.100
だから､ ここで縛りをなくしましょう｡ 

00:27.100 --> 00:30.010
そして､ このクラスの上に､ オートバインド・デコレーターを追加します｡

00:30.010 --> 00:38.750
そして､ このファイルを少しでも整理するために､ ここにコメントを追加します｡

00:38.750 --> 00:40.490
ProjectInputクラス

00:42.260 --> 00:44.790
では､ デコレーターとは何でしょうか？

00:44.790 --> 00:46.770
デコレーターとは､ 関数のことですよね？

00:46.770 --> 00:48.130
そして､ ここにある関数装飾か､

00:48.130 --> 00:51.383
関数式として見つけることができます｡

00:52.490 --> 00:54.780
ここでは､ 関数デコレーションを使用し､

00:54.780 --> 00:57.780
名前をautobindとします｡

00:57.780 --> 01:01.670
そして､ このデコレーターは自由引数としてターゲット､

01:01.670 --> 01:09.083
つまりバインドされているメソッド名を受け取ることになります｡

01:09.980 --> 01:15.720
また､ そのメソッドの記述子も｡

01:15.720 --> 01:18.370
ええと､ プロパティディスクリプターです｡ なぜなら､

01:18.370 --> 01:22.760
結局のところメソッドは単なるプロパティであり､ 関数を保持するプロパティだからです｡

01:22.760 --> 01:24.400
さて､ なぜこれがメソッド・デコレーターなのでしょうか？

01:24.400 --> 01:32.210
なぜなら､ このようにsubmitHandlerに追加して終わりという考え方だからです｡

01:32.210 --> 01:33.680
そういうことです｡ 

01:33.680 --> 01:35.500
今はまだ完全にそうなっていませんが､

01:35.500 --> 01:38.143
最終的にはこうなるはずです｡

01:39.090 --> 01:42.950
さて､ この機能を実現するために､ 先ほどの関数に戻り､

01:42.950 --> 01:46.880
関数本体に何を入れなければならないか？

01:46.880 --> 01:51.950
まあ､ その中で､ まずはオリジナルのメソッドにアクセスできるようにしたいですね｡

01:51.950 --> 01:59.380
ディスクリプター付き｡  の値を変更し､ 元々定義していたメソッドを保存するようにしました｡

01:59.380 --> 02:04.873
次に､ 調整済みのディスクリプターを作成します｡

02:06.650 --> 02:11.090
実はPropertyDescriptorと入力するんです｡ 

02:11.090 --> 02:13.880
configurable は､ 常に変更できるように

02:13.880 --> 02:15.910
true に設定する必要があります｡

02:15.910 --> 02:17.573
そして､ そこで必要となるのがゲッターです｡ 

02:18.510 --> 02:21.770
そして､ このゲッターでは､ 関数にアクセスしようとしたときに実行されるはずのものが､

02:21.770 --> 02:24.270
ここにあります｡

02:24.270 --> 02:27.710
ここで､ 上で抽出しているオリジナルメソッドを使って､

02:27.710 --> 02:31.030
バウンド関数を設定します｡

02:31.030 --> 02:34.063
そして､ その上でこれを縛ることを呼びかける｡ 

02:35.370 --> 02:36.203
そして､ その束縛された関数を返す､

02:37.860 --> 02:41.603
それだけでいいはずだ｡

02:42.510 --> 02:48.653
もちろん､ 全体としては､ そのメソッド・デコレーターで調整したディスクリプターを返すことになります｡

02:49.510 --> 02:52.880
これで､ submitHandlerでエラーが発生するようになりました｡ 

02:52.880 --> 02:57.960
その､ デコレータの実験的なサポートは､ 基本的に有効化する必要がある機能です｡

02:57.960 --> 03:02.320
そこで､ tsconfigファイルに移動し､ その中で下にスクロールしてください｡

03:02.320 --> 03:05.770
experimentalDecorators "オプションが見つかるはずですので､

03:05.770 --> 03:07.450
それをコメントアウトしてください｡

03:07.450 --> 03:09.980
そして､ その前にカンマをつける｡ 

03:09.980 --> 03:14.183
それを保存して､ 型のコンパイル作業を再開してください｡ 

03:15.180 --> 03:17.700
これを展開すると､ メソッド名は宣言されているが､

03:17.700 --> 03:23.170
その値は読み込まれないというエラーが表示されます｡

03:23.170 --> 03:25.410
アプリで｡  ts ライン4｡ 

03:25.410 --> 03:26.760
これは､ 私がここで受け取った､

03:26.760 --> 03:30.940
実際には使用しなかったこの議論を参照しているのです｡

03:30.940 --> 03:34.370
ターゲットも同様で､ 私は使ったことがありません｡ 

03:34.370 --> 03:36.343
さて､ これを解決する方法は2つあります｡ 

03:37.200 --> 03:39.610
1つの方法は､ tsconfigにアクセスして､

03:39.610 --> 03:42.813
ここで厳密性のルールを緩めることです｡

03:44.160 --> 03:46.740
noUnusedParameters､ これをfalseに設定すると､

03:46.740 --> 03:49.090
実際に未使用のパラメータを許可することになる｡

03:49.090 --> 03:50.670
つまり､ これは1つだろうし､

03:50.670 --> 03:56.653
アンダースコア､ アンダースコア2という特殊な名前を使う｡

03:57.770 --> 04:03.130
これは､ typescriptやjavascriptが､ これらの値を使用するつもりはないが､

04:03.130 --> 04:08.740
引数が必要なので受け入れる必要があることを示すヒントです｡

04:08.740 --> 04:11.810
これを保存すると､ エラーなしでコンパイルされ､

04:11.810 --> 04:14.700
戻ってここに hello と入力して送信すると､

04:14.700 --> 04:20.060
自動バインド・デコレーターのおかげでまだ動作しています｡

04:20.060 --> 04:24.950
また､ このデコレーターが実際に使用できることを示すものであることを期待します｡

04:24.950 --> 04:29.510
さて､ ここでバインドを呼び出すだけでなく､ 実際にはもう少し手間がかかります｡

04:29.510 --> 04:33.820
しかし､ これがどんどん多くのメソッドに使われ､ すべてがバインドされることを想像してみてください｡

04:33.820 --> 04:36.140
手動でバインドを呼び出す必要がないため､

04:36.140 --> 04:42.343
時間を節約でき､ また忘れてしまった場合のエラーも防ぐことができます｡
