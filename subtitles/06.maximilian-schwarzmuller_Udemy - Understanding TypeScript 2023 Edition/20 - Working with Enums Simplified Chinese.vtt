WEBVTT

00:02.230 --> 00:04.860
教师：与元组的概念松散相关的是,

00:04.860 --> 00:09.760
在应用中使用几个特定的标识符和全局常量,

00:09.760 --> 00:18.530
您希望将其表示为数字, 但希望为其分配一个人类可读的标签｡

00:18.530 --> 00:20.500
为此, 您需要使用Enum类型｡ 

00:20.500 --> 00:23.800
同样, 在一些高级编程语言中也存在这种情况｡ 

00:23.800 --> 00:25.780
但JavaScript并不知道它｡ 

00:25.780 --> 00:26.613
它看起来像这样｡ 

00:26.613 --> 00:28.110
这就是创建枚举的方法｡ 

00:28.110 --> 00:30.540
使用enum关键字, 它只存在于TypeScript世界中,

00:30.540 --> 00:36.810
而不存在于JavaScript中, 然后使用花括号, 然后是标识符｡

00:36.810 --> 00:42.030
而这个由TypeScript添加的类型为您提供了一个枚举列表｡

00:42.030 --> 00:45.070
所以这些标签在最后, 只是被转换成从零开始的数字,

00:45.070 --> 00:50.133
你可以在你的代码中使用人类可读的标签｡

00:51.310 --> 00:55.620
为了给大家展示一个例子, 让我们回到我们的人及其角色｡

00:55.620 --> 00:59.710
我将复制该代码, 然后将其注释掉, 因为我将对其进行一些更改｡

00:59.710 --> 01:01.600
然后这里, 我将去掉显式类型赋值,

01:01.600 --> 01:07.150
而返回到推理, 因为我现在要改变角色｡

01:07.150 --> 01:10.330
现在, 假设我们希望有一个管理员､ 一个作者,

01:10.330 --> 01:12.350
也许还有一个只读用户｡

01:12.350 --> 01:14.750
管理员的ID应为零, 只读用户的ID为一,

01:14.750 --> 01:18.660
作者的ID为两｡

01:18.660 --> 01:22.550
当然, 我们可以像这样用这些数字来存储｡

01:22.550 --> 01:26.670
一个缺点是, 我们总是可以添加一个我们可能没有角色的数字,

01:26.670 --> 01:33.392
如果我们随后在代码中尝试提取角色, 使用if检查可能会导致错误｡

01:33.392 --> 01:39.690
此外, 作为开发人员, 我们很难理解该用户的角色｡

01:39.690 --> 01:41.310
是给作者的吗

01:41.310 --> 01:43.020
或者是对用户的读取？

01:43.020 --> 01:46.140
你可能会忘记这一点后, 作出更长的停顿,

01:46.140 --> 01:48.810
当工作在更大的团队, 等等｡

01:48.810 --> 01:50.540
因此, 作为开发人员,

01:50.540 --> 01:54.310
您可能需要人类可读的标识符, 例如ADMIN和READ

01:54.310 --> 01:58.630
ONLY USER｡

01:58.630 --> 02:00.240
当然, 我们可以使用它,

02:00.240 --> 02:02.880
我们可以处理这样的字符串值｡

02:02.880 --> 02:06.100
问题是, 如果我们后来需要一个if检查, 我们检查人员角色是否等于,

02:06.100 --> 02:11.100
它是READ_ONLY_USER吗？

02:12.260 --> 02:13.500
还是一个词？

02:13.500 --> 02:15.380
有下划线吗？

02:15.380 --> 02:17.440
你看, 然后我们必须记住我们是如何写这些字符串的,

02:17.440 --> 02:20.970
我们在那里有哪些确切的文本｡

02:20.970 --> 02:24.330
因为这个字符串中间有破折号, 当然,

02:24.330 --> 02:27.430
和这个字符串不一样｡

02:27.430 --> 02:29.973
所以这里, 我们永远不会把它放在那里,

02:31.150 --> 02:39.170
如果你试图编译和打印它, 它是只读的, 因为, 好吧, 检查根本不会产生true｡

02:39.170 --> 02:42.150
我们没有将其作为person上的角色, 因此,

02:42.150 --> 02:43.930
在控制台中无法获得输出｡

02:43.930 --> 02:47.290
所以字符串标识符也有缺点｡ 

02:47.290 --> 02:52.340
对于这样的场景, 在JavaScript中定义全局常量是很常见的｡

02:52.340 --> 02:55.580
例如, admin, 它会保存某些值,

02:55.580 --> 03:00.060
如数字或字符串, 两者都是可能的｡

03:00.060 --> 03:04.370
数字, 当然可以节省我们一些额外的代码和比特内存｡

03:04.370 --> 03:09.370
在那里我们可能有ADMIN､ READ_ONLY和AUTHOR,

03:09.390 --> 03:10.870
就像这样, 在下面,

03:10.870 --> 03:13.750
我们只需要使用这个角色｡

03:13.750 --> 03:17.343
这样做的好处是我们可以在代码中的任何地方使用它｡

03:18.230 --> 03:22.600
例如, 如果我运行这段代码, 如果我编译它, 然后让它重新加载,

03:22.600 --> 03:23.680
我们在这里看到admin,

03:25.260 --> 03:31.520
所以这是有效的, 这是JavaScript中的一个常见模式｡

03:31.520 --> 03:34.190
缺点是, 现在, 角色被推断为只是一个数字,

03:34.190 --> 03:39.630
所以我们可以在其中存储任何数字, 甚至是我们不支持的数字｡

03:39.630 --> 03:42.450
另外, 我们必须定义所有这些常量,

03:42.450 --> 03:44.060
我们必须管理它们｡

03:44.060 --> 03:45.920
这就是枚举可以为我们节省工作的地方｡ 

03:45.920 --> 03:48.730
这完全没问题, 但是枚举会使它更容易｡ 

03:48.730 --> 03:50.970
我们用enum关键字创建一个枚举,

03:50.970 --> 03:58.620
我们可以将其命名为Role, 约定是以大写字符开头, 因为枚举也是一个自定义类型｡

03:58.620 --> 04:01.760
这是你的第一个自定义类型, 我们将在本课程中编写更多,

04:01.760 --> 04:03.860
这是第一个｡

04:03.860 --> 04:06.560
然后在你想赋给这个枚举的类型的名字后面,

04:06.560 --> 04:09.520
加上大括号, 就像这样, 没有冒号,

04:09.520 --> 04:14.040
没有等号, 只是名字后面的大括号｡

04:14.040 --> 04:15.800
然后是分号｡ 

04:15.800 --> 04:19.433
在这里, 您可以指定值, 如admin､

04:20.650 --> 04:24.300
read only和author｡

04:24.300 --> 04:28.180
而在幕后, 这里的数字是0, 这里的数字是1,

04:28.180 --> 04:31.780
这里的数字是2｡

04:31.780 --> 04:34.650
在这里, 您可以访问角色｡  ADMIN, 就像在对象上一样,

04:34.650 --> 04:37.840
您可以访问您的标识符｡

04:37.840 --> 04:40.380
您也可以在代码中的任何其他地方使用它,

04:40.380 --> 04:43.890
在这里我们可以检查角色是否为AUTHOR, 然后打印作者,

04:43.890 --> 04:46.710
当然, 如果我现在运行它, 我们应该看不到它,

04:46.710 --> 04:50.630
因为我们在这里分配了ADMIN角色｡

04:50.630 --> 04:53.333
但关键的一点是, 我们在枚举的帮助下完成了所有这些工作,

04:53.333 --> 04:57.490
枚举为数字分配标签｡

04:57.490 --> 04:59.210
如果我们在JavaScript中看一下｡ 

04:59.210 --> 05:02.830
在编译后的代码中, 我们看到它是如何重建的｡ 

05:02.830 --> 05:05.080
最后, 它被重建, 这里有一个如果｡ 

05:05.080 --> 05:07.940
所以执行自身的函数｡ 

05:07.940 --> 05:11.770
这里的Role最后作为一个对象进行管理,

05:11.770 --> 05:19.970
它有admin属性, 只读属性和AUTHOR属性, 我们在这里存储数字值.

05:19.970 --> 05:24.210
因此, 它比这要复杂一些, 但这就是TypeScript在编译代码时,

05:24.210 --> 05:28.560
在JavaScript代码中复制这个枚举结构的最终目的｡

05:28.560 --> 05:32.680
在这里, 作为开发人员, 我们只是有这些方便创建的数字｡

05:32.680 --> 05:34.290
如果您将鼠标悬停在这些数字上,

05:34.290 --> 05:39.883
您将看到我们将存储在其中的数字, 您可以在此处以人类可读的方式使用这些数字｡

05:40.750 --> 05:44.790
现在对于枚举, 您也不局限于默认行为｡

05:44.790 --> 05:47.470
假设由于某种原因, 您不想以零作为起始数字,

05:47.470 --> 05:50.533
那么您可以在标识符后面添加一个等号,

05:50.533 --> 05:59.610
然后输入任何其他数字, 现在admin被分配给数字5和您分配值的标识符后面的其他标识符, 然后选择该值,

05:59.610 --> 06:04.580
并简单地递增此起始值｡

06:04.580 --> 06:08.140
所以现在我们有好的, 六, 七, 而不是零, 一, 二｡ 

06:08.140 --> 06:10.642
当然, 如果您需要自己的数字,

06:10.642 --> 06:14.820
也可以为所有这些标识符分配自己的值｡

06:14.820 --> 06:17.070
你也不局限于数字, 你也可以在这里使用文本,

06:17.070 --> 06:19.390
甚至混合使用, 就像我在这里做的那样,

06:19.390 --> 06:24.900
任何东西都可以, 但是通常默认的从零开始递增数字是你想要的, 但是如果你需要不同的行为,

06:24.900 --> 06:31.530
如果你想在这里使用一个字符串, 然后在这里使用一个数字, 这里也是一个数字, 或者一个数字字符串,

06:31.530 --> 06:48.270
那么你完全可以这样做, 其优点是, 您可以在上面定义它, 然后, 您总是将您的Role类型引用到您创建的这个自定义类型, 引用到您创建的这个自定义枚举｡

06:48.270 --> 06:50.320
你在if检查和类型赋值中使用它,

06:50.320 --> 06:52.970
你就很好了｡

06:52.970 --> 06:59.420
这就是枚举的强大之处, 每当您需要人类可读的标识符并在后台具有一些映射值时,

06:59.420 --> 07:03.173
它都是一个很好的构造｡
