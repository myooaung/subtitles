WEBVTT

00:00.000 --> 00:02.410
(Stille) -: Wir sehen also bereits,

00:02.410 --> 00:04.190
wie TypeScript uns bei der

00:04.190 --> 00:06.200
Entwicklung helfen kann.

00:06.200 --> 00:10.560
Wir wissen auch, dass es in JavaScript einen Zahlentyp gibt.

00:10.560 --> 00:14.010
Und wir können es mit dem eingebauten Typ des Operators sehen.

00:14.010 --> 00:15.781
Dies ist nun nicht mehr TypeScript-spezifisch,

00:15.781 --> 00:17.560
sondern ein eingebauter Operator und ein

00:17.560 --> 00:20.420
Schlüsselwort, das von JavaScript unterstützt wird.

00:20.420 --> 00:22.910
Wir können damit den Typ eines bestimmten Wertes ermitteln.

00:22.910 --> 00:27.050
Hier könnten wir also den Sperrtyp Nummer eins trösten.

00:27.050 --> 00:27.992
Und was wir sehen werden,

00:27.992 --> 00:30.780
wenn wir das tun, ist, dass wir den aktualisierten Code ausführen,

00:30.780 --> 00:32.623
sobald wir ihn kompilieren.

00:33.780 --> 00:37.040
Hier wird die Zahl auf der Konsole ausgegeben.

00:37.040 --> 00:39.330
Jetzt tun wir das, dank dieser Ausgabe hier, und

00:39.330 --> 00:41.180
dank des Typs des Operators und in Vanilla

00:41.180 --> 00:43.770
JavaScript, ohne TypeScript, könnten wir das verwenden,

00:43.770 --> 00:46.710
um unsere Funktion hier immer zu verbessern.

00:46.710 --> 00:51.500
Wir könnten prüfen, ob der Typ der Zahl gleich der Zahl ist.

00:51.500 --> 00:54.300
Entschuldigung, Typ von n1, ich meine,

00:54.300 --> 00:56.350
ob das gleich Zahl ist, und wir

00:56.350 --> 01:00.710
könnten auch prüfen, ob Typ von n2 gleich Zahl ist.

01:00.710 --> 01:02.349
und führen Sie unsere Operation hier

01:02.349 --> 01:05.220
nur aus, wenn es sich um einen Fehler handelt, der andernfalls

01:05.220 --> 01:07.860
ausgelöst wird, oder machen Sie das Gegenteil und prüfen

01:07.860 --> 01:10.820
Sie, ob es nicht gleich ist, oder ob n2 nicht gleich ist.

01:10.820 --> 01:13.230
Und wenn eine der beiden Zahlen keine Zahl

01:13.230 --> 01:16.360
ist, könnten wir eine neue Fehlermeldung ausgeben, die

01:16.360 --> 01:19.690
besagt: Falsche Eingabe. Das wäre eigentlich eine TypeScript-fremde

01:19.690 --> 01:22.300
Methode, um sicherzustellen, dass wir diese Funktion

01:22.300 --> 01:25.700
hier nicht mit einem String aufrufen können.

01:25.700 --> 01:26.760
Wenn ich dies jetzt tue und

01:26.760 --> 01:29.060
neu kompiliere, erhalten wir unseren TypeScript-Fehler,

01:29.060 --> 01:30.830
aber ignorieren wir das erst einmal.

01:30.830 --> 01:31.730
Wenn wir dies wiederholen,

01:31.730 --> 01:33.100
erhalten wir die falsche Eingabe,

01:33.100 --> 01:34.940
die wir selbst auslösen.

01:34.940 --> 01:38.080
Jetzt haben wir also die Fehlfunktion in JavaScript gehärtet,

01:38.080 --> 01:39.930
sie schlägt zur Laufzeit fehl, aber

01:39.930 --> 01:41.970
ein Fehlschlagen ist hier vielleicht besser

01:41.970 --> 01:44.950
als eine falsche Ausgabe, die wir vorher hatten.

01:44.950 --> 01:47.640
Dies wäre also eine Möglichkeit, die Eingaben nur in JavaScript

01:47.640 --> 01:48.715
zu überprüfen.

01:48.715 --> 01:50.640
Dafür brauchen Sie kein TypeScript.

01:50.640 --> 01:53.200
Das ist normaler JavaScript-Code.

01:53.200 --> 01:54.033
Aber natürlich hat dieser Ansatz

01:54.033 --> 01:55.160
auch seine Schattenseiten.

01:55.160 --> 01:57.160
Manchmal ist es das Richtige, das zu tun.

01:57.160 --> 02:01.440
Manchmal können Sie nur bestimmte Eingaben zur Laufzeit validieren.

02:01.440 --> 02:03.150
Aber der Nachteil ist, dass wir

02:03.150 --> 02:05.480
hier etwas überprüfen, was wir bei der Entwicklung

02:05.480 --> 02:08.950
mit TypeScript eigentlich vermeiden können.

02:08.950 --> 02:11.180
Also ja, wir geben einen Fehler aus.

02:11.180 --> 02:14.210
Und in unserer Anwendung könnten wir Maßnahmen eingebaut haben,

02:14.210 --> 02:16.860
die dann auf ein anderes Verhalten zurückgreifen können,

02:16.860 --> 02:19.080
um die laufende Anwendung zu retten.

02:19.080 --> 02:20.750
Dennoch wird ein Fehler ausgegeben,

02:20.750 --> 02:24.180
der eigentlich gar nicht auftreten müsste.

02:24.180 --> 02:27.350
Mit TypeScript hätten wir das verhindern können.

02:27.350 --> 02:28.830
Und hier sehen wir wirklich den Unterschied

02:28.830 --> 02:30.400
zwischen JavaScript und TypeScript, wenn

02:30.400 --> 02:31.450
es um Typen geht.

02:31.450 --> 02:33.750
JavaScript ist dynamisch typisiert, d.h.

02:33.750 --> 02:35.610
es ist völlig in Ordnung, dass wir

02:35.610 --> 02:36.880
eine Variable haben, die

02:36.880 --> 02:39.100
anfangs eine Zahl enthält, der wir später

02:39.100 --> 02:41.600
eine Zeichenkette zuweisen.

02:41.600 --> 02:44.500
Deshalb müssen wir den Type-Off-Operator verwenden,

02:44.500 --> 02:48.024
damit wir den aktuellen Typ von etwas zur Laufzeit überprüfen können,

02:48.024 --> 02:50.124
wenn wir einen Code haben, der von einem

02:50.124 --> 02:52.267
bestimmten Typ abhängt.

02:52.267 --> 02:53.570
TypeScript hingegen

02:53.570 --> 02:55.094
ist statisch typisiert,

02:55.094 --> 02:58.480
d. h. wir definieren die Typen von Variablen und Parametern

02:58.480 --> 03:01.740
während der Entwicklung, sie ändern sich nicht plötzlich

03:01.740 --> 03:04.980
während der Laufzeit.

03:04.980 --> 03:05.813
Da TypeScript

03:05.813 --> 03:09.090
zu JavaScript kompiliert wird, könnten sie das

03:09.090 --> 03:10.660
theoretisch tun.

03:10.660 --> 03:12.510
Aber wenn wir TypeScript verwenden

03:12.510 --> 03:13.790
und Code schreiben, in dem

03:13.790 --> 03:17.530
wir plötzlich einen neuen Datentyp in eine Variable zuweisen, wo wir

03:17.530 --> 03:18.810
vorher gesagt haben, dass

03:18.810 --> 03:19.840
dies zum Beispiel eine

03:19.840 --> 03:22.900
Zahl sein sollte, und jetzt weisen wir eine Zeichenkette

03:22.900 --> 03:25.810
zu, dann bekommen wir während der Entwicklung einen Fehler,

03:25.810 --> 03:27.480
so dass wir gezwungen sind, uns

03:27.480 --> 03:29.670
über die Typen klar zu werden, was wir halten

03:29.670 --> 03:32.120
können oder nicht.

03:32.120 --> 03:33.710
Das ist hier der Unterschied.

03:33.710 --> 03:36.620
Wir wollen also nicht wirklich Implementierungen oder

03:36.620 --> 03:38.330
Lösungen wie diese verwenden, wenn

03:38.330 --> 03:40.810
wir es mit TypeScript vermeiden können.

03:40.810 --> 03:42.200
Dennoch ist es wichtig

03:42.200 --> 03:43.890
zu wissen, dass JavaScript

03:43.890 --> 03:46.400
natürlich das Konzept der Typen kennt.

03:46.400 --> 03:48.740
Es kennt einige Typen wie Zahlen,

03:48.740 --> 03:50.640
String und Boolean.

03:50.640 --> 03:52.300
Aber das bedeutet immer, dass wir

03:52.300 --> 03:53.540
nur zur Laufzeit Fehler

03:53.540 --> 03:56.400
machen können und nicht während der Entwicklung, was

03:56.400 --> 03:58.700
für uns als Entwickler besser ist.

03:58.700 --> 04:01.550
So können wir Fehler früher beheben.

04:01.550 --> 04:02.840
Außerdem kennt JavaScript

04:02.840 --> 04:05.410
nur ein paar Typen.

04:05.410 --> 04:07.170
Wie Sie im Laufe dieses Kurses lernen werden.

04:07.170 --> 04:10.540
TypeScript kennt viel mehr Typen als JavaScript.

04:10.540 --> 04:14.450
Die Laufzeitüberprüfung ist also nicht so flexibel oder so leistungsfähig

04:14.450 --> 04:18.030
wie das, was wir mit TypeScript machen können.

04:18.030 --> 04:19.490
Und aus all diesen Gründen ist dieser

04:19.490 --> 04:20.660
Ansatz eigentlich nicht der

04:20.660 --> 04:22.550
Ansatz, den wir hier verwenden wollen.

04:22.550 --> 04:26.540
Manchmal kann es nützlich sein, den Typ zur Laufzeit zu ermitteln.

04:26.540 --> 04:28.790
Aber manchmal, wie in diesem Beispiel, ist es

04:28.790 --> 04:31.740
viel besser, sie während der Entwicklung zu bekommen.

04:31.740 --> 04:34.280
Wichtig ist nur, dass TypeScript nur während

04:34.280 --> 04:36.070
der Entwicklung unterstützt wird,

04:36.070 --> 04:39.596
nicht zur Laufzeit, da diese TypeScript-Funktionen und -Prüfungen

04:39.596 --> 04:41.610
nicht in die JavaScript-Engine eingebaut

04:41.610 --> 04:44.650
sind, so dass die Logik nicht im Browser ausgeführt werden

04:44.650 --> 04:51.223
kann, sondern nur während der Entwicklung, wenn Sie Ihren Code kompilieren.
