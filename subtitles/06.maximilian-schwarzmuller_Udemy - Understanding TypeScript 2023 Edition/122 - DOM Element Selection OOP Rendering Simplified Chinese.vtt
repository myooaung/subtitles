WEBVTT

00:02.300 --> 00:03.420
Tutor：首先,

00:03.420 --> 00:07.060
我将运行npm start来启动开发服务器｡

00:07.060 --> 00:09.384
它提供HTML文件和菜单选项卡,

00:09.384 --> 00:21.740
tsc-w在监视模式下启动编译类型, 以便我们的应用程序JavaScript文件不断重建, 我们可以在运行的应用程序中查看它｡

00:21.740 --> 00:24.480
当然, 现在我们的应用程序看起来并不太花哨｡ 

00:24.480 --> 00:26.340
这是一个空白页｡ 

00:26.340 --> 00:30.250
因此, 要开始, 有许多方法可以做到这一点｡

00:30.250 --> 00:35.040
现在, 我想从使该窗体可见开始｡ 

00:35.040 --> 00:36.660
现在, 有很多方法,

00:36.660 --> 00:40.208
我将用面向对象的方法编写这个应用程序｡

00:40.208 --> 00:43.303
这是100%可选的, 但是因为我们学习了类等等,

00:43.303 --> 00:51.140
我想演示一下它是如何工作的, 所以我将使用这种方法｡

00:51.140 --> 00:51.973
在应用程序键中,

00:51.973 --> 00:55.510
我将添加一个新类, 并将其命名为Project

00:55.510 --> 00:59.120
Input, 当然, 类名完全由您决定｡

00:59.120 --> 01:00.570
在这个类中,

01:00.570 --> 01:04.590
我们的目标是, 访问这个模板和其中的表单,

01:04.590 --> 01:11.710
并访问这个div, 最后在该div中呈现我们的模板｡

01:11.710 --> 01:15.160
所以模板的内容, div中的表单｡ 

01:15.160 --> 01:17.130
这必须是我们的目标｡ 

01:17.130 --> 01:18.850
为了实现这一点, 在Project

01:18.850 --> 01:20.588
Input中, 我将添加一个构造函数,

01:20.588 --> 01:27.970
在这里, 我最终希望访问我的模板, 并访问它应该呈现的位置｡

01:28.830 --> 01:33.310
在这里, 我将动态添加两个属性,

01:33.310 --> 01:40.180
模板元素属性和宿主元素属性｡

01:40.180 --> 01:42.420
名字100%由你决定｡ 

01:42.420 --> 01:44.990
最后, 我的想法是, 宿主元素,

01:44.990 --> 01:49.650
包含对元素的引用, 我最终要在其中呈现我的模板内容,

01:49.650 --> 01:54.050
模板元素让我可以访问包含此内容的模板｡

01:54.050 --> 01:56.120
现在要访问该模板, 让我们看一下index

01:56.120 --> 02:01.870
html, 看看如何识别保存表单的模板｡

02:01.870 --> 02:06.120
它有一个项目输入ID, 所以这看起来是一个很好的策略｡

02:06.120 --> 02:11.022
所以这里我们可以使用文档getElementById项目输入｡

02:11.022 --> 02:15.410
这使我们可以访问此模板元素｡ 

02:15.410 --> 02:17.820
现在, 有几件重要的事情｡ 

02:17.820 --> 02:21.320
在这里我们得到一个错误, 模板元素是一个属性,

02:21.320 --> 02:23.900
它不存在于项目输入｡

02:23.900 --> 02:31.610
现在要去掉这个, 我们实际上应该把它作为一个新字段直接加到类里.

02:31.610 --> 02:34.050
然后我们就可以放心地分配给它了｡ 

02:34.050 --> 02:37.450
在这里, 我还想明确存储在其中的类型｡

02:37.450 --> 02:41.070
这将是一个HTML模板元素｡ 

02:41.070 --> 02:43.270
这种类型是全局可用的, 因为在tsconfig

02:43.270 --> 02:47.380
js文件中, 我将DOM作为库添加, 这样就将所有这些DOM类型､

02:47.380 --> 02:55.493
所有这些HTML元素类型作为typescript类型添加到了整个项目中｡

02:57.280 --> 03:00.400
现在, 这会在这里引入一个新的错误, 但是, 您可以看到,

03:00.400 --> 03:04.760
当我们通过ID获取元素时, 最终可能为null, 当然, 我们知道它不会失败,

03:04.760 --> 03:12.757
但typescript没有机会知道这一点, 因为它不会分析我们的html文件｡

03:12.757 --> 03:18.210
因此, 可能不存在具有此ID的元素, 因此这将生成null｡

03:18.210 --> 03:20.680
这里我们说不存储null,

03:20.680 --> 03:23.920
只存储HTML模板元素.

03:23.920 --> 03:25.800
所以, 为了消除这种危险, 我们必须告诉typescript,

03:25.800 --> 03:29.470
这永远不会是null｡

03:29.470 --> 03:31.290
你知道怎么做吗？

03:31.290 --> 03:33.580
您可以在此处添加感叹号｡ 

03:33.580 --> 03:36.170
当然, 如果你不确定,

03:36.170 --> 03:37.820
另一种方法是,

03:37.820 --> 03:41.640
把它存储在一个常量中, 然后检查模板元素是否为真,

03:41.640 --> 03:51.490
如果它不为空, 那么就把它存储在if检查中｡

03:51.490 --> 03:52.720
现在, 我们仍然得到一个错误,

03:52.720 --> 03:54.190
但这将是一个不同的错误,

03:54.190 --> 03:55.840
我稍后会回来｡

03:55.840 --> 03:59.650
如果我们还不确定的话, 现在这个可以解决问题｡

03:59.650 --> 04:01.930
不过, 现在在这里, 我可以肯定｡ 

04:01.930 --> 04:02.763
顺便说一下, 如果你不确定,

04:02.763 --> 04:06.000
你应该在else的情况下提供一个后备｡

04:06.000 --> 04:08.530
但在这里我确信我们会得到这样的元素,

04:08.530 --> 04:11.803
因此我们可以简单地在后面添加一个感叹号来告诉打字稿,

04:11.803 --> 04:13.710
“一切顺利｡

04:13.710 --> 04:18.133
我们将访问具有该ID的元素｡  正如我提到的, 我们还有一个错误｡

04:18.133 --> 04:20.220
HTML元素类型中缺少属性内容

04:20.220 --> 04:29.550
这里的问题是, 我们告诉typescript我们要存储一个html模板元素类型的模板元素｡

04:29.550 --> 04:32.160
事实上, 情况将会如此｡ 

04:32.160 --> 04:38.730
当然, getElementById并不知道它最终会返回哪个元素｡

04:38.730 --> 04:41.130
它只知道它将是一些html元素,

04:41.130 --> 04:43.920
但不知道它的哪个专用版本｡

04:43.920 --> 04:48.720
如果它是一个div､ 一个段落､ 一个按钮或类似于本例中的模板元素｡

04:48.720 --> 04:51.387
getElementById不可能知道这一点｡ 

04:51.387 --> 04:57.460
所以为了告诉打字稿, 我们当然也知道确切的类型｡

04:57.460 --> 05:00.660
我们可以使用类型转换｡ 

05:00.660 --> 05:02.260
你也知道了｡ 

05:02.260 --> 05:03.730
您可以使用两种语法｡ 

05:03.730 --> 05:07.690
开头的尖括号, 然后是你要转换的类型,

05:07.690 --> 05:10.130
你告诉typeScript,

05:10.130 --> 05:11.847
"嘿！

05:11.847 --> 05:12.700
这个东西,

05:12.700 --> 05:17.650
这个表达式在这后面, 这是那种类型的. 或者作为HTML模板元素添加, 这是我要使用的方法｡

05:17.650 --> 05:23.040
这样, 您就可以保证在typescript中获取的内容不会为null,

05:23.040 --> 05:25.700
而是这种类型｡

05:25.700 --> 05:32.016
很多人都在谈论选择这个, 但这是一个共同的任务, 重要的是要把这个做对｡

05:32.016 --> 05:33.630
现在, 让我们继续处理主体元素｡ 

05:33.630 --> 05:35.563
在这里, 我们还应该添加host元素作为字段,

05:36.890 --> 05:39.360
我们知道当我们实际想要呈现我们的项目输入时,

05:39.360 --> 05:45.960
host元素最终将是这里的div｡

05:45.960 --> 05:48.560
这就是我想要呈现表单的地方｡ 

05:48.560 --> 05:51.410
所以, 这里我们可以说HTML div元素｡ 

05:51.410 --> 05:54.000
这就是我们要添加的元素类型｡ 

05:54.000 --> 06:02.740
我们也可以不那么具体, 只说HTML元素, 因为在这里我真的不关心它是否是div｡

06:02.740 --> 06:04.970
但是既然我们已经确定了,

06:04.970 --> 06:08.400
为什么不加上它呢？

06:08.400 --> 06:10.250
现在, 我想访问div,

06:10.250 --> 06:11.263
当然, 应该在哪里添加它,

06:12.110 --> 06:16.530
如果我们看一下索引｡ html文件中, 我们可以再次通过ID来标识此div｡

06:16.530 --> 06:18.970
在本例中为应用程序ID｡ 

06:18.970 --> 06:19.945
现在, 回到app ts中,

06:19.945 --> 06:24.640
我们可以再次使用文档getElementById并访问id为app的元素｡

06:24.640 --> 06:28.780
现在, 我们遇到了与前面相同的问题, 它可以为空,

06:28.780 --> 06:35.112
因此我们必须添加感叹号, 因为我们同样知道它不会为空,

06:35.112 --> 06:39.620
并且getElementById不知道它将是HTML

06:39.620 --> 06:46.030
div元素, 因此, 我们也应该在此处转换它｡

06:46.030 --> 06:51.210
有了它, 我们现在可以找到我们如何获得所有我们需要的元素｡

06:51.210 --> 06:53.990
你说了这么多｡ 

06:53.990 --> 06:56.070
遗憾的是, 我们并没有取得太大的成就｡ 

06:56.070 --> 07:01.970
我们可以访问这些元素, 但我们不会在那里呈现任何内容｡

07:01.970 --> 07:03.940
让我们继续｡ 

07:03.940 --> 07:05.790
为此, 我们需要导入该模板元素的内容,

07:05.790 --> 07:11.760
因此基本上导入模板标记内的内容并将其呈现到DOM｡

07:11.760 --> 07:15.520
我们可以在构造函数中这样做, 因为我的想法,

07:15.520 --> 07:17.603
当然, 这只是我的想法,

07:18.510 --> 07:21.870
你可以用不同的方式来设置它｡

07:21.870 --> 07:22.940
但我的想法是,

07:22.940 --> 07:24.550
当我们创建这个类的一个新实例时,

07:24.550 --> 07:28.250
我会立即呈现一个属于这个实例的窗体｡

07:28.250 --> 07:30.190
所以我们将在构造函数中执行此操作｡ 

07:30.190 --> 07:31.770
在那里我们可以得到导入的节点或导入的HTML内容,

07:31.770 --> 07:37.430
或者你想给它命名的任何名称, 我们可以用document

07:37.430 --> 07:40.627
importNode得到它, 这是一个在全局document对象上提供的方法,

07:40.627 --> 07:49.260
你可以在模板元素上向importNode传递一个指针｡

07:49.260 --> 07:54.410
那么这个模板元素到底是什么, 或者确切地说不是元素而是点号内容在那里｡

07:54.410 --> 08:00.891
Content是存在于HTML模板元素上的一个属性,

08:00.891 --> 08:05.320
它只是给出了对模板内容的引用｡

08:05.320 --> 08:07.480
这样就可以在HTML代码之间插入模板文本｡ 

08:07.480 --> 08:09.520
ImportNode还接受第二个参数,

08:09.520 --> 08:15.670
该参数定义是否应使用深度克隆导入此节点｡

08:15.670 --> 08:17.940
所以模板中的所有嵌套层次我都想这样做,

08:17.940 --> 08:19.630
所以我在这里提供true.

08:19.630 --> 08:22.570
现在, 我们有了importedNode, 正如您将看到的,

08:22.570 --> 08:28.830
这是typescript自动假定或推断的类型文档片段｡

08:28.830 --> 08:30.770
现在我们可以使用importedNode,

08:30.770 --> 08:34.910
当然我想用它来呈现一些内容｡

08:34.910 --> 08:36.960
为此, 我将添加一个新方法,

08:36.960 --> 08:40.970
一个私有方法, 我将其命名为attach｡

08:40.970 --> 08:45.150
你不需要这样做, 我只是想分开我的选择和渲染逻辑｡

08:45.150 --> 08:46.390
在attach中, 我将访问host元素,

08:46.390 --> 08:54.930
也就是我希望呈现内容的地方, 并调用insertAdjacentElement,

08:54.930 --> 09:00.770
这是浏览器在JavaScript中最终提供的默认方法｡

09:00.770 --> 09:02.980
要插入HTML元素, 插入相邻的元素,

09:02.980 --> 09:04.340
首先需要一个关于插入位置的描述,

09:04.340 --> 09:13.180
这样你就可以在目标元素的开头之后插入它, 也就是说就在宿主元素的开始标记之后, 在开始标记之前或开始标记之前,

09:13.180 --> 09:20.870
在结束标记之前或结束标记之后｡

09:20.870 --> 09:23.570
在这里我将在开始之后插入它,

09:23.570 --> 09:27.020
就在开始标记的开头｡

09:27.020 --> 09:30.580
然后我想插入的是我的importedNode,

09:30.580 --> 09:39.140
然而, 首先, 这是一个只在构造函数中可用的常量,

09:39.140 --> 09:42.970
其次, 这是一个文档片段｡

09:42.970 --> 09:44.630
我们无法像这样插入｡ 

09:44.630 --> 09:49.800
相反, 我们需要访问其中的具体HTML元素, 我们可以将其存储在另一个属性元素中｡

09:49.800 --> 09:52.770
我们还必须将其添加为一个字段,

09:52.770 --> 09:55.560
该字段可以是HTML元素类型,

09:55.560 --> 09:58.270
或者在我们的示例中, 我们知道它将位于模板内部,

09:58.270 --> 10:02.500
因此它将是一个表单｡

10:02.500 --> 10:05.790
这是模板中的第一个元素｡ 

10:05.790 --> 10:07.010
这里我们可以说它是一个HTML表单元素,

10:07.010 --> 10:10.960
这里, 这个元素等于importNode

10:10.960 --> 10:15.200
firstElementChild, 现在我们只需要再次告诉typescript,

10:15.200 --> 10:20.106
这将是一个HTML表单元素｡

10:20.106 --> 10:25.510
现在这个元素就是具体的属性指向我们要插入的节点.

10:25.510 --> 10:28.360
在下面的insertAdjacentElement中,

10:28.360 --> 10:31.110
我们在这里插入这个元素｡

10:31.110 --> 10:33.690
现在我们只需要确保在构造函数中,

10:33.690 --> 10:36.350
在它的最后我们调用了attach,

10:36.350 --> 10:42.260
这个私有的attach方法, 这样这段代码也会执行.

10:42.260 --> 10:46.620
现在有了所有的格式, 这就是我的代码看起来的样子｡

10:46.620 --> 10:48.200
所以现在是项目输入类, 理论上,

10:48.200 --> 10:53.950
当我们实例化它时, 它应该呈现窗体｡

10:53.950 --> 10:56.920
现在让我们来试试｡ 

10:56.920 --> 10:59.440
在类下面, 让我们简单地创建一个新的常量, 例如prjInput,

10:59.440 --> 11:01.120
名称由您决定｡

11:01.120 --> 11:05.415
并将新项目命名为Input, 如下所示｡ 

11:05.415 --> 11:08.930
如果我们现在保存它, 它应该重新编译和重新加载, 如果你回到浏览器,

11:08.930 --> 11:16.050
你确实应该在这里看到这个表单｡

11:16.050 --> 11:17.990
这非常好, 因为有了它,

11:17.990 --> 11:20.660
我们迈出了非常重要第一步

11:20.660 --> 11:22.450
我们有我们的形式呈现,

11:22.450 --> 11:29.150
即使有很多是失踪, 这总比没有好｡

11:29.150 --> 11:36.430
这个表单来自索引html文件, 它是在我们面向对象的typescript代码的帮助下呈现的｡
