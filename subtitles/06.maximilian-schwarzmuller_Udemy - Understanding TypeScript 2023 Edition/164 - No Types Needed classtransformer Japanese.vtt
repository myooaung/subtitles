WEBVTT

00:02.270 --> 00:08.270
講師：そこで､ JavaScriptのためにJavaScriptで作られたサードパーティライブラリであるLodashを見ていただきました｡

00:08.270 --> 00:13.287
また､ サードパーティのライブラリには､ タイプスクリプトやタイプスクリプトの機能を採用しているものがあり､

00:13.287 --> 00:21.230
タイプスクリプトを使用しているため､ まったく新しいコードの書き方ができます｡

00:21.230 --> 00:28.067
その一例がクラス・トランスフォーマーであり､ さらに良い例がクラス・バリデーターです｡

00:28.067 --> 00:31.360
しかし､ まずはクラストランスから始めましょう｡ 

00:31.360 --> 00:38.150
このプロジェクトでは､ 実際にモデル､ データモデルを持っていて､ それを「product」と名付けることにします｡

00:38.150 --> 00:43.820
では､ 商品名とします｡  のモデルです｡  tsですが､ このファイルには好きな名前を付けることができます｡

00:43.820 --> 00:48.820
私の考えは､ このファイルで製品のクラスを定義することです｡ 

00:49.420 --> 00:52.180
そこで私は､ 製品がどのようなものであるべきかを説明します｡ 

00:52.180 --> 00:55.550
例えば､ 文字列であるタイトルと数値である価格を持っていて､

00:55.550 --> 01:02.120
両方を初期化できるコンストラクタ関数を追加しています｡

01:02.120 --> 01:09.360
そこで､ 文字列､ 価格を追加し､ このタイトルが't'に､ この価格価格が'p'に等しいと言ったのです｡

01:09.360 --> 01:14.423
もちろん､ コンストラクタのみを使用するショートカットの初期化も使用できました｡

01:16.150 --> 01:20.400
最初の要素はタイトルで､

01:20.400 --> 01:25.400
2番目の要素はドル記号を含む文字列で､

01:25.950 --> 01:37.833
この文字列に価格が注入されています｡

01:39.030 --> 01:43.030
このように､ 非常にシンプルなモデル､ 非常にシンプルなクラスです｡ 

01:43.030 --> 01:49.590
そして､ このクラスはもちろん､ アプリで使うことができます｡

01:49.590 --> 01:49.590
そこで､

01:49.590 --> 02:05.800
Lodashを廃止し､ 代わりに.NET Frameworkから製品をインポートすることにしました｡ /プロダクト モデル さて､ そのためにはproductモデルで実際にこのクラスをエクスポートする必要があります｡

02:05.800 --> 02:11.950
そうしないとインポートすることができません｡

02:11.950 --> 02:23.150
ここで､ もちろん新しい商品､ 12円の本を作ることができます｡

02:23.150 --> 02:23.150
99以降､

02:24.080 --> 02:28.190
私はコンソールログp1は情報を取得し､ 我々は実際にこの配列をログに記録する必要があります｡

02:28.190 --> 02:31.390
ここで npm start を実行すると､ Web Pack

02:31.390 --> 02:37.340
Dev が起動し､ この本に関する情報を含む素敵な配列が表示されるはずです｡

02:37.340 --> 02:39.463
そこで､ ここでリロードすると､ こうなります｡ 

02:40.630 --> 02:44.930
今のは､ もちろん派手すぎず､ 効果的ですが､ 何も新しいことではありません｡

02:44.930 --> 02:47.270
大規模なアプリケーションでよくあるシナリオは､

02:47.270 --> 02:49.610
データをダウンロードすることです｡

02:49.610 --> 02:54.490
例えば､ バックエンドサーバーからデータを取得し､ そのサーバーがjsonデータを返すと､

02:54.490 --> 03:01.560
それが商品のリストであるかもしれません｡

03:01.560 --> 03:05.520
ここで､ サーバーから取得した商品には､ タイトル､ カーペット､

03:05.520 --> 03:10.520
価格､ 29があります｡ 99円､ そしてこの本もタイトル､

03:13.047 --> 03:22.830
本､ そして価格も10円です｡

03:22.830 --> 03:22.830
99とする｡ 

03:22.830 --> 03:27.730
これは､ バックエンドから取得するデータの非常にシンプルな配列です｡

03:27.730 --> 03:30.590
もちろん､ これらはJavaScriptのオブジェクトですが､

03:30.590 --> 03:33.730
製品モデルのインスタンスではありません｡

03:33.730 --> 03:37.220
そして､ これは典型的なシナリオで､ データをjsonで取得し､

03:37.220 --> 03:42.850
そのデータがどのコンストラクタ関数に属しているかというような付属データはありません｡

03:42.850 --> 03:46.770
jsonは基本的なデータを送信するためのフォーマットで､

03:46.770 --> 03:53.540
オブジェクトに付随するリッチなメタデータは含まれていません｡

03:53.540 --> 03:56.300
少なくとも､ 手動で行う必要があります｡ 

03:56.300 --> 04:03.310
つまり､ ここで取得する製品は､ 情報取得メソッドを持たないオブジェクトということになる｡

04:03.310 --> 04:08.230
従来は､ これをモデルのインスタンスに変換する場合､

04:08.230 --> 04:12.680
手動で行わなければなりませんでした｡

04:12.680 --> 04:17.680
例えば､ products を読み込んで､ products を使って map メソッドを呼び出し､ その配列のすべての商品に対して､

04:19.260 --> 04:30.680
prod 用に新しい商品を返すことができます｡

04:30.680 --> 04:30.680
タイトル・プロデュース 価格と､

04:34.330 --> 04:40.230
それ以降の実際の製品コンストラクタ関数のインスタンスでいっぱいの配列ができ､ それを実際にループして製品をロードし､

04:40.230 --> 04:51.083
例えばコンソールログ prod のようなものができます｡

04:51.083 --> 04:51.083
getinformationを使用します｡ 

04:52.150 --> 04:56.010
このように､ 配列や単一の無名Vanilla JavaScriptオブジェクトを､

04:56.010 --> 05:05.000
特定のコンストラクタ関数のインスタンスに手動で変換することができます｡

05:05.000 --> 05:07.220
今､ これを手作業で行うのは面倒です｡ 

05:07.220 --> 05:09.590
ここでは余計な手順がたくさんある､

05:09.590 --> 05:12.710
これはもちろん単純な変換に過ぎないのだが｡

05:12.710 --> 05:16.690
そこで､ クラス変換パッケージが役に立ちます｡ 

05:16.690 --> 05:19.330
それが､ とてもとてもシンプルになるのです｡ 

05:19.330 --> 05:22.390
この場合､ スクリプトでクラスを定義し､

05:22.390 --> 05:25.010
サーバーからデータを取得して､

05:25.010 --> 05:36.893
簡単なメソッドを呼び出せば､ 自動的にデータを正しいモデルに変換してくれます｡

05:38.100 --> 05:40.030
そのために､ まず､ このようにnmp

05:40.030 --> 05:44.840
install class transformer--saveを実行し､

05:45.730 --> 05:54.470
これが終わったら､ npm install reflect-metadata--saveを実行してみましょう｡

05:54.470 --> 05:57.460
これもインポートして､ セットアップの説明にあるように､

05:57.460 --> 06:11.410
ルートエントリーファイル（私の場合はapp）にあるメタデータを反映してインポートしましょう｡

06:11.410 --> 06:11.410
ts

06:11.410 --> 06:14.970
今インストールしたサードパーティライブラリを､ 私たちのライブラリの依存関係としてインポートします｡

06:14.970 --> 06:17.210
今､ 実際にjsステップなしという言葉が出てきましたので､

06:17.210 --> 06:18.610
これをスキップすることができます｡

06:18.610 --> 06:20.180
ブラウザでは､ まだ同じパッケージをインストールする必要がありますが､

06:20.180 --> 06:30.090
このインポートを追加することで､ Webパックを使用しているため､ 実際に使用することができます｡

06:30.090 --> 06:40.210
そして､ クラス・トランスフォーマーから何かをインポートし､ その何かが「プレーン・トゥ・クラス」メソッドとなるのです｡

06:40.210 --> 06:42.630
このパッケージには､ 他にもいくつかのメソッドがあります｡ 

06:42.630 --> 06:45.200
詳しくは､ こちらの公式ドキュメントをご覧ください｡ 

06:45.200 --> 06:49.060
しかし､ 'plain to class'はメインメソッドです｡ 

06:49.060 --> 06:54.060
ここでは､ 例えば読み込んだ商品を設定するのに使用します｡ 

06:55.150 --> 07:01.480
以前のように手動で行うのではなく､ loaded productsをplainに等しくしてclassに設定し､

07:01.480 --> 07:03.760
ここで2つの引数を渡すことができます｡

07:03.760 --> 07:08.070
第一引数は､ 変換したいクラスです｡ 

07:08.070 --> 07:10.190
私の場合はここで､ 製品｡ 

07:10.190 --> 07:12.700
そして､ インスタンス化も呼び出しもせず､

07:12.700 --> 07:15.560
ただそのクラスを指し示すだけなのです｡

07:15.560 --> 07:19.460
第2引数は､ 変換したいデータである｡ 

07:19.460 --> 07:23.520
つまり､ 私の場合､ それが製品ということになります｡ 

07:23.520 --> 07:25.840
そして､ このパッケージが行うことは､ この配列の上で､

07:25.840 --> 07:28.100
ここにあるすべての普通のVanilla

07:28.100 --> 07:34.090
JavaScriptオブジェクトを､ このクラスのインスタンスに変換することです｡

07:34.090 --> 07:37.830
これを保存して､ もう一度npm startを実行すると､ サーバーを起動するWebページが再び起動し､

07:37.830 --> 07:43.270
エラーなしでこのプロジェクトをビルドするはずです｡

07:43.270 --> 07:46.540
ページを再読み込みすると､ 前と同じ出力が得られますが､

07:46.540 --> 07:51.870
もちろん､ このパッケージを使っているので､ 私たちの側からのコードは少なくなっています｡

07:51.870 --> 07:53.403
このパッケージのすごいところは､

07:53.403 --> 07:57.070
タイプスクリプトの上に構築され､ タイプスクリプトを利用し､

07:57.070 --> 08:04.280
クラスを指すことができるという事実を利用して､ このようにうまく動作していることです｡

08:04.280 --> 08:08.730
ただ､ 正直なところ､ このパッケージはタイプスクリプトと特に相性が良いのですが､

08:08.730 --> 08:12.600
タイプスクリプト特有の機能を使用しているわけではありません｡

08:12.600 --> 08:16.630
例えばクラスは､ Vanilla JavaScriptにも存在します｡ 

08:16.630 --> 08:20.170
そのため､ 主にタイプスクリプト用に開発されていますが､ 実はVanilla

08:20.170 --> 08:23.610
JavaScriptでも動作します｡

08:23.610 --> 08:26.633
次のパッケージではそうはいかないでしょうけど｡ 
