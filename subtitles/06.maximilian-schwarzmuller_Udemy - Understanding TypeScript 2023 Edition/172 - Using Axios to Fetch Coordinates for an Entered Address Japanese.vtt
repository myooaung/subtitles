WEBVTT

00:02.390 --> 00:04.530
講師：サードパーティーのパッケージがなくても､

00:04.530 --> 00:06.890
リクエスト送信が可能になりました｡

00:06.890 --> 00:11.910
モダンブラウザのモダンJavaScriptでは､ APIをフェッチする必要があります｡

00:11.910 --> 00:13.620
これはブラウザに組み込まれており､

00:13.620 --> 00:19.600
グローバルに利用できる機能で､ URLへのリクエスト送信に使用することができます｡

00:19.600 --> 00:22.450
このAPIは､ エラー処理がやや雑であるという事実以外に､

00:22.450 --> 00:27.210
特に不利な点はありません｡

00:27.210 --> 00:31.123
でも､ サードパーティのライブラリの使い方も実践してみたいです｡

00:31.960 --> 00:36.070
そこで､ 非常に人気の高いaxiosパッケージを使用することにします｡ 

00:36.070 --> 00:43.510
これは､ JavaScriptで､ つまりTypeScriptでもHTTPリクエストを送信するために使えるパッケージです｡

00:43.880 --> 00:47.263
なので､ あとはaxiosをインストールすれば使い始められます｡ 

00:48.100 --> 00:51.080
NPM を使って依存関係を管理しているプロジェクトでは､

00:51.080 --> 00:54.150
npm install, dash, dash save

00:54.150 --> 01:00.520
axios を実行すると､ このように axios パッケージがインストールされます｡

01:00.520 --> 01:04.750
これをインストールした状態で､ ここでaxiosからimport

01:04.750 --> 01:09.170
axiosをすると､ 面白いことがわかります｡

01:09.170 --> 01:13.990
今､ これを使い始めて､ ここにドットを入力すると､ オートコンプリートが表示されます｡

01:13.990 --> 01:18.523
例えば､ ここにgetメソッドがあり､ URLにgetリクエストを送信します｡

01:19.850 --> 01:23.150
そこで､ 実際にTypeScriptをビルトインでサポートするようにしました｡ 

01:23.150 --> 01:25.640
そして､ ノードモジュールでaxiosパッケージを見てみると､

01:25.640 --> 01:29.670
ここにあります｡

01:29.670 --> 01:33.970
その中に､ インデックスがあるのがわかると思います｡  dtsファイルです｡ 

01:33.970 --> 01:43.750
そこで､ axiosライブラリの作者は､ すでにこのようなTypeScript翻訳パッケージと一緒にライブラリをバンドルしています｡

01:43.750 --> 01:47.440
そこでは､ すべてがTypeScriptに説明されています｡ 

01:47.440 --> 01:50.120
このパッケージやファイルは､ 基本的にTypeScriptに対して､

01:50.120 --> 01:55.600
このJavaScriptライブラリは何ができるのか､ どの型を使用するのかを説明しています｡

01:55.600 --> 01:59.100
現在､ いくつかのライブラリではそのようなことが行われており､ アクシオスもその一つです｡ 

01:59.100 --> 02:03.420
そのライブラリがそうであるかどうかは､ 使い始めればすぐに分かります｡

02:03.420 --> 02:05.520
もし､ オートコンプリートがサポートされておらず､

02:05.520 --> 02:10.750
コンパイルエラーが多発した場合は､ 追加の型をインストールする必要があると思われます｡

02:10.750 --> 02:12.970
もし､ 私たちのような良いサポートが得られ､

02:12.970 --> 02:20.170
その後コンパイルエラーが発生しないのであれば､ あなたはすでに型変換を組み込んだライブラリを手に入れたということになりますね｡

02:20.170 --> 02:23.120
そのため､ 余計なタイプをインストールする必要はありません｡ 

02:23.120 --> 02:26.240
知ってよかった､ そしてここに素晴らしい例があります｡ 

02:26.240 --> 02:27.800
だから､ サポートが組み込まれているので､

02:27.800 --> 02:30.410
すぐにアクセスを使い始めることができるのです｡

02:30.410 --> 02:34.350
そして､ このURLにHTTPリクエストを送りたいのです｡ 

02:34.350 --> 02:37.980
では､ このURLをコピーして､ ここに入力してみましょう｡ 

02:37.980 --> 02:42.440
そして､ この文字列の一部を他の値のためにダイナミックに簡単に入れ替えられるように､

02:42.440 --> 02:49.050
バックチックの間に入力してテンプレートリテラルを作成することにします｡

02:49.050 --> 02:51.730
この文字列はかなり長いので､ 最後にAPIキーをGoogle

02:51.730 --> 02:59.210
APIキーに置き換えてください（この定数に保存されています）｡

02:59.210 --> 03:01.690
これはテンプレートリテラルなので､

03:01.690 --> 03:04.110
ドル記号と中括弧を追加して､ Google

03:04.110 --> 03:09.110
APIキーを指定すれば､ この定数を使用することができます｡

03:10.820 --> 03:13.240
ついでに､ このアドレスも交換しましょう｡ 

03:13.240 --> 03:15.500
ここでは､ ダミーのアドレスが入力されていますが､

03:15.500 --> 03:19.300
もちろんそこではユーザーが入力したアドレスを使いたいのです｡

03:19.300 --> 03:24.910
このアドレスは､ もちろんユーザーが入力したテキストそのままで､

03:24.910 --> 03:30.650
特殊文字､ 空白､ カンマなどを含むことができます｡

03:30.650 --> 03:32.250
また､ これらの文字や記号は､

03:32.250 --> 03:35.580
URLですべてサポートされているわけではありません｡

03:35.580 --> 03:40.550
そこで､ この入力された文字列をURL互換の文字列に変換する必要があります｡

03:40.550 --> 03:43.810
そしてありがたいことに､ TypeScriptとJavaScriptには､

03:43.810 --> 03:50.460
それを助けてくれる組み込み関数､ encode URI関数があるのです｡

03:50.460 --> 03:53.020
これを呼び出して文字列を渡せば､

03:53.020 --> 03:57.460
この文字列をURL互換の文字列に変換してくれます｡

03:57.460 --> 04:04.900
これで､ 座標を取得するためのリクエストを送信するためのURLが完成しました｡

04:04.900 --> 04:07.390
もちろん､ このようなリクエストを非同期タスクとして送信するため､

04:07.390 --> 04:10.620
getは私たちに約束を与えてくれます｡

04:10.620 --> 04:18.620
そして､ 成功した場合はログを､ 技術的なエラーやエラーレスポンスコードがある場合はキャッチします｡

04:18.620 --> 04:24.710
ここで､ 通常であれば成功するはずなので､ この時点で発生する可能性のあるエラーをコンソールログに記録しておきます｡

04:24.710 --> 04:27.820
したがって､ ここでは､ thenブロックに私の応答を期待し､

04:27.820 --> 04:32.400
この応答をthenに記録したいと思います｡

04:32.400 --> 04:35.820
さて､ これで何が出てくるか､ 見てみましょう｡ 

04:35.820 --> 04:40.953
NPM start を再実行して､ webpack のプロセスを再度立ち上げ､ これを構築し始めましょう｡

04:42.120 --> 04:43.790
そして､ アプリケーションに戻り､

04:43.790 --> 04:47.220
ここに6番街のような場所を入力してみましょう｡

04:47.220 --> 04:51.480
アドレスの検索を押すと､ しばらくしてここに出力されるのがわかると思います｡

04:51.480 --> 04:56.120
そして､ リクエストに成功したことを意味する200のステータスコードが表示されるはずです｡

04:56.120 --> 05:01.240
そして､ サーバーから返信されるデータを保持するデータフィールドがあります｡

05:01.240 --> 05:03.890
そのデータフィールドには結果フィールドがあり､

05:03.890 --> 05:06.570
そこにはお分かりのように配列があります｡

05:06.570 --> 05:10.690
その配列の中に､ いくつかの項目があり､ その数は様々です｡ 

05:10.690 --> 05:13.770
そして､ これらは基本的にGoogleが見つけた結果です｡ 

05:13.770 --> 05:16.740
そして､ 最初の結果は､ 通常､ 最良のものです｡ 

05:16.740 --> 05:20.460
これを見ると､ 例えばアドレスがフォーマットされていることがわかります｡

05:20.460 --> 05:22.520
つまり､ 私たちが入力したこの住所に対してGoogleが見つけた住所は､

05:22.520 --> 05:26.570
私たちが入力したものよりももう少し完成度が高いということです｡

05:26.570 --> 05:29.300
そして､ ここでジオメトリキーを手に入れました｡ 

05:29.300 --> 05:31.880
これを展開すると､ 今度はロケーションキーがあり､

05:31.880 --> 05:39.700
最終的に緯度と経度の座標を持つオブジェクトになります｡

05:39.700 --> 05:43.000
最終的には､ データ､ 結果､ そして最初の結果であるジオメトリ､

05:43.000 --> 05:50.030
位置と､ 緯度と経度を持つオブジェクトにドリルしなければならないわけです｡

05:50.030 --> 05:55.240
そして､ この緯度・経度を後で地図上にレンダリングすることができるようになります｡

05:55.240 --> 05:57.430
では､ とりあえずこれを抽出して､

05:57.430 --> 05:59.360
レスポンスドットデータドット結果にアクセスして､

05:59.360 --> 06:04.360
座標を取得してみましょう｡

06:04.600 --> 06:13.093
そして､ 最初の結果がドットジオメトリのドット位置です｡

06:15.130 --> 06:16.880
ここで､ TypeScriptが文句を言わない一方で､

06:16.880 --> 06:23.280
TypeScriptのサポートが充実していないことにお気づきでしょうか｡

06:23.280 --> 06:27.620
ここにドットを打つと､ resultsプロパティがあることを示唆していないことになります｡

06:27.620 --> 06:30.350
そして実際､ 私はここで､ レスポンス上に存在しないものにもアクセスしようとすることができ､

06:30.350 --> 06:34.820
それは意味のあることでした｡

06:34.820 --> 06:40.920
TypeScriptは､ 私がリクエストを送るURLのレスポンスに何が含まれるかをどうやって知るのだろう？

06:40.920 --> 06:46.510
TypeScriptは､ 開発中にリクエストを送信して中身を確認するようなことはしないので､

06:46.510 --> 06:49.170
それもあまりよろしくないでしょう｡

06:49.170 --> 06:51.400
しかし､ このgetメソッドは実はジェネリックメソッドであり､

06:51.400 --> 06:53.950
ここにあるものはすべて､ 我々が期待するレスポンスの型であるため､

06:53.950 --> 07:02.830
我々が期待するレスポンスをTypeScriptに伝えることができるのだ｡

07:02.830 --> 07:06.880
ここでレスポンスタイプを追加し､ TypeScriptに､

07:06.880 --> 07:11.270
私が期待するのはresultsキーを持つオブジェクトで､

07:11.270 --> 07:18.330
それがオブジェクトでいっぱいの配列になり､ すべてのオブジェクトがgeometryキーを持ち､

07:18.330 --> 07:33.510
それがオブジェクトで､ locationキーを持ち､ それがオブジェクトで､ 緯度と経度を持つ数値であることを伝えることができる｡

07:33.510 --> 07:36.030
だから､ かなり複雑なタイプであることは間違いない｡ 

07:36.030 --> 07:42.220
でも､ これならここにドットを打てばオートコンプリートされるし､ TypeScriptはここにアクセスしていることを理解してくれる｡

07:42.220 --> 07:46.620
もちろん､ ここからこの型を引き出して､ 独自の型別名を作ることもできます｡

07:46.620 --> 07:50.497
多分ここ､ Googleのジオコーディング対応｡ 

07:53.220 --> 08:01.540
これが私のカスタムタイプで､ TypeScriptにGoogleのジオコーディングのレスポンスを期待することを伝えることができる｡

08:01.540 --> 08:03.900
もちろん､ 実際にはレスポンスには結果の配列以外にも､

08:03.900 --> 08:13.040
ステータスコードや､ 結果の配列の各項目に含まれる複数のフィールド､ そしてジオメトリが含まれます｡

08:13.040 --> 08:17.030
もちろん､ これらのフィールドをすべてカスタムタイプに追加することもできますが､

08:18.210 --> 08:25.640
ここでは積極的に関心のある値にのみ焦点を当てたいと思います｡

08:25.640 --> 08:30.900
そのため､ もう1つフィールドを追加することにしました｡

08:30.900 --> 08:38.390
トップレベルにはstatusがあり､ これはGoogleが成功したかどうかを示す文字列です｡

08:38.390 --> 08:44.010
そして､ ステータスは､ 実際には､ OKか､ 他のいくつかの値になります｡

08:44.010 --> 08:51.890
これは基本的に､ Googleがこのアドレスの座標の取得に成功したかどうかを伝えるために応答するステータスメッセージである｡

08:51.890 --> 08:57.280
もちろん､ 公式ドキュメントでは､ ここでどのような回答が返ってくるかも知ることができます｡

08:57.280 --> 09:01.070
少し下にスクロールして､ 「回答を理解する」をクリックすると､

09:01.070 --> 09:07.000
返ってきた回答の中身がわかるので､ 「回答をジオコーディングする」をクリックしてください｡

09:07.000 --> 09:08.580
そして､ ステータスコードでは､

09:08.580 --> 09:11.090
利用可能なステータスコードについて学びます｡

09:11.090 --> 09:15.090
例えば､ 何も見つからなければ全員結果がゼロになる｡ 

09:15.090 --> 09:16.850
他にもいくつかコードがありますが､

09:16.850 --> 09:19.223
ここではこの2つだけにしておきます｡

09:20.200 --> 09:24.890
そこで､ TypeScriptに「ここでは､ この2つの値のうち､ どちらかのステータスコードを取得する」と伝える｡

09:24.890 --> 09:27.480
今また､ それは同様に数字の値を持つかもしれませんが､

09:27.480 --> 09:29.830
これはここで私にとって良いことです｡

09:29.830 --> 09:33.700
先ほども言いましたが､ もちろんもっと完成度の高い書き方ができます｡

09:33.700 --> 09:36.230
つまり､ 何か問題が発生したことを意味します｡

09:36.230 --> 09:44.120
この場合､ ここでエラーをスローすることができるので､ 最終的にはキャッチブロックに移動して､

09:44.120 --> 09:49.810
エラー処理を設定することができます｡

09:49.810 --> 09:54.280
そこで､ ここでは､ could not fetch locationというエラーを投げることにします｡ 

09:54.280 --> 10:01.230
そして､ このエラーハンドラで何かをするために､ 少なくともエラーメッセージを出力するアラートを投げることができるのです｡

10:01.230 --> 10:04.660
もちろん､ これはごく基本的なエラー処理に過ぎない｡ 

10:04.660 --> 10:06.950
そうでなければ､ 成功の応答があれば､

10:06.950 --> 10:12.113
ここで座標を取得し､ 今度はこの座標を使って地図上に出力することができるのです｡
