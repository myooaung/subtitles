WEBVTT

00:02.170 --> 00:08.300
-：さて､ JavaScriptにはオブジェクトのほかに配列もあります｡

00:08.300 --> 00:10.810
JavaScriptではこのように配列が作成され､

00:10.810 --> 00:12.560
そこにあらゆるデータを格納することができます｡

00:12.560 --> 00:15.970
数値､ 文字列､ ブーリアン､ オブジェクト､ 他の配列､ 何しろ配列を入れ子にすることができますし､

00:15.970 --> 00:19.380
データを混ぜることも可能です｡

00:19.380 --> 00:23.200
文字列と数値が混在した配列を持つことができます｡ 

00:23.200 --> 00:25.570
そして､ TypeScriptは配列もサポートしています｡ 

00:25.570 --> 00:32.140
JavaScriptの任意の配列がサポートされ､ その配列の型は柔軟にも厳密にもできます｡

00:32.140 --> 00:35.200
では､ それをTypeScriptで見てみましょう｡ 

00:35.200 --> 00:45.660
そのために､ このアプリで｡  もちろん､ オブジェクトの外側に変数または定数としてhobbiesを持つこともできます｡

00:45.660 --> 00:50.853
つまり､ オブジェクトの内側でも外側でも､ 配列の使い方は全く同じなのです｡

00:51.950 --> 00:54.780
ここで､ 趣味というのがありますが､ 趣味というのは､

00:54.780 --> 00:58.140
例えば､ スポーツであったり､ 料理であったりするわけです｡

00:58.140 --> 01:01.150
そこで､ 2つの要素を用意しました｡ これらの要素は､

01:01.150 --> 01:03.620
おわかりのように､ 文字列です｡

01:03.620 --> 01:10.630
ここで､ 趣味にカーソルを合わせると､ TypeScriptは文字列配列型の距離を正しく検出することができました｡

01:10.630 --> 01:12.500
今までに見たことのない構文ですが､

01:12.500 --> 01:16.140
これがTypeScriptでデータの配列を記述する方法です｡

01:16.140 --> 01:21.340
角括弧があり､ その前に格納されているデータの種類があります｡

01:21.340 --> 01:23.530
さて､ これがタイプ､ タイプのグループの推論です｡ 

01:23.530 --> 01:25.810
ここでは配列があり､ そこには文字列しかないことがわかったので､

01:25.810 --> 01:31.940
趣味はおそらく文字列の配列であるべきだと推論したのです｡

01:31.940 --> 01:34.903
そして実際､ 趣味の世界では､ それはとても理にかなっています｡ 

01:36.210 --> 01:41.040
もちろん､ 明示的に変数の種類を設定することも可能です｡ 

01:41.040 --> 01:44.720
新しい変数favorite activitiesを追加して､

01:45.580 --> 01:53.140
最初は空にしておいて､ そこに格納されるデータのタイプを明示的に設定したい場合があります｡

01:53.140 --> 01:55.590
文字列の配列にする場合は､ 先ほどと同じようにstringと入力し､

01:55.590 --> 02:00.330
その後に角括弧をつければ､ TypeScriptにここに格納されているのは単一の文字列ではなく､

02:00.330 --> 02:05.990
文字列の配列であることを伝えることができる｡

02:05.990 --> 02:12.183
そして､ 確かにスポーツだけを格納しようとすると､ エラーになります｡

02:12.183 --> 02:12.183
ここが文字列の配列ではなく､

02:12.183 --> 02:15.650
単一の文字列であるため､ エラーが発生します｡

02:15.650 --> 02:22.610
もちろん､ これを角括弧で囲んで､ 実質的に配列を作成してもエラーにはなりません｡

02:22.610 --> 02:25.870
しかし､ 文字列の配列と定義しているので､ 例えば数字を追加すると､

02:25.870 --> 02:29.220
またもやエラーが発生します｡

02:29.220 --> 02:31.290
さて､ ここでは配列が混在しています｡ 

02:31.290 --> 02:37.180
文字列と数値の配列なので､ うまくいかず､ ここではサポートされていません｡

02:37.180 --> 02:43.120
もし､ このような混在した配列に対応したい場合は､ ここで「any」を使用するのが一つの解決策となる｡

02:43.120 --> 02:45.880
any」型はTypeScriptの特殊な型です｡ 後で詳しく見ていきますが､

02:45.880 --> 02:50.530
基本的には「好きなことをやってください」という意味です｡

02:50.530 --> 02:55.630
もちろん､ あまり使いたくない型だ｡ TypeScriptが与えてくれる利点を失ってしまうし､

02:55.630 --> 03:00.140
どこでもどんな値でも使えるJavaScriptの世界に戻ってしまうからだ｡

03:00.140 --> 03:02.940
そのため､ "any "はとても柔軟なのですが､ その代償として､

03:02.940 --> 03:08.710
TypeScriptが提供するすべての利点を基本的に放棄することになります｡

03:08.710 --> 03:12.530
ここで､ 文字列に戻ります｡ なぜなら､ そこに数字を入れたくないからです｡

03:12.530 --> 03:14.933
したがって､ 数字を削除すればいいのです｡

03:15.900 --> 03:18.830
配列もまた､ オブジェクトやそのプロパティと同様に､

03:18.830 --> 03:25.730
TypeScriptの型推論がいかに動的であるかを示す良い例である｡

03:25.730 --> 03:28.750
もし､ この下に "for "ループを追加して､ その人のすべての趣味を調べたいなら､

03:28.750 --> 03:38.220
もちろん従来の "for "ループでその人の趣味を一定にすることができます｡

03:38.220 --> 03:38.220
hobbiesプロパティにアクセスし､

03:41.130 --> 03:42.793
そこにあるすべての趣味を調べ､

03:43.690 --> 03:50.090
各繰り返しの趣味をこの定数に格納し､ ここで趣味のログを参照できるようにします｡

03:50.090 --> 03:53.710
さて､ これはあまり派手なことではなく､ JavaScriptで知っていることですね｡

03:53.710 --> 03:58.280
今､ このアプリをコンパイルすると｡  tsのファイルを下に置くと､

03:58.280 --> 04:04.750
この行から名前を取得し､ それ以降は印刷される2つの趣味を取得します｡

04:04.750 --> 04:07.800
しかし､ ここで興味深いのは､ 趣味の世界では､ どんなものにもアクセスでき､

04:07.800 --> 04:11.040
どんな文字列にもアクセスできることです｡

04:11.040 --> 04:16.230
例えばUpperCaseにすると､ このように自動補完され､ TypeScriptは文句を言いません｡

04:16.230 --> 04:18.070
なぜ､ 文句を言わないのか？

04:18.070 --> 04:25.830
なぜなら､ hobbiesが文字列配列型であることを知っているので､ personにアクセスすると､ hobbiesが文字列配列型であることを知っているからです｡

04:25.830 --> 04:25.830
の場合､

04:25.830 --> 04:29.700
TypeScriptの推論では､ hobbiesは文字列の配列になることが検出されます｡

04:29.700 --> 04:33.450
一方､ hobbyは文字列であると正しく認識されます｡

04:33.450 --> 04:36.000
なぜなら､ 文字列の配列を通過するため､

04:36.000 --> 04:40.510
個々の値は単なる文字列でなければならないからです｡

04:40.510 --> 04:46.490
なぜなら､ 私たちが設定したtypeのおかげで､

04:46.490 --> 04:53.810
hobbyが文字列になることが確実にわかるからです｡

04:53.810 --> 04:56.300
そしてそれは本当に柔軟で､ もちろん､ コードを書くのがずっと簡単になり､

04:56.300 --> 05:01.360
ずっと柔軟で安全になる素晴らしい機能です｡

05:01.360 --> 05:08.570
例えば､ 趣味にアクセスしようとすると､ ここでエラーが発生します｡

05:08.570 --> 05:08.570
の地図､ これが配列になると思えば｡ 

05:08.570 --> 05:12.060
mapメソッドは配列には使えますが､ 文字列には使えません｡ 

05:12.060 --> 05:17.810
そして､ ここでも正しく､ 文字列型にmapが存在しないというエラーが発生します｡

05:17.810 --> 05:21.290
ここでエラーが出るのは良いことです｡

05:21.290 --> 05:27.343
なぜなら､ これは間違っているからです｡
