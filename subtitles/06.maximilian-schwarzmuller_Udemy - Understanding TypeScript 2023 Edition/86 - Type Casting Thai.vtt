WEBVTT

00:02.260 --> 00:03.920
ผู้สอน: ดังนั้น สหภาพแรงงานที่เลือกปฏิบัติ

00:03.920 --> 00:05.750
มีประโยชน์จริงๆ

00:05.750 --> 00:09.060
อีกคุณสมบัติที่มีประโยชน์มากคือการหล่อแบบ

00:09.060 --> 00:12.640
Type Casting ช่วยให้คุณบอก TypeScript ว่าค่าบางค่าเป็นค่าเฉพาะที่

00:12.640 --> 00:15.350
TypeScript ไม่สามารถตรวจจับได้ด้วยตัวเอง

00:15.350 --> 00:22.660
แต่คุณในฐานะนักพัฒนารู้ดีว่าจะเป็นกรณีนี้

00:22.660 --> 00:25.030
ตัวอย่างที่ดีคือถ้าเราได้รับ

00:25.030 --> 00:27.120
X กับบางสิ่งในโดม

00:27.120 --> 00:29.560
สมมติว่าที่นี่เรามีย่อหน้าในโดมเพียงย่อหน้า

00:29.560 --> 00:33.390
ไม่มีอย่างอื่นในนั้น และเป็นย่อหน้าว่าง

00:33.390 --> 00:37.150
แน่นอนว่าถ้าเราบันทึก เราจะไม่เห็นอะไรที่นี่บนหน้าจอ

00:37.150 --> 00:40.543
ตอนนี้เราสามารถเข้าถึงย่อหน้านั้นได้จากภายในสคริปต์ของเราที่นี่

00:43.160 --> 00:48.160
Const ย่อหน้าด้วยตัวเลือกการสืบค้นเอกสาร P เป็นต้น

00:49.180 --> 00:51.890
ตอนนี้เมื่อเราใช้ตัวเลือกการสืบค้นและเราส่งผ่าน

00:51.890 --> 00:54.500
P เป็นตัวเลือก ดังนั้นมันจึงเลือกโดยแท็ก P ดังนั้น

00:54.500 --> 00:59.510
TypeScript จะสามารถค้นหาได้จริง อย่างที่คุณเห็นถ้าฉันวางเมาส์เหนือสิ่งนี้ จะเป็นองค์ประกอบย่อหน้าประเภทหรือ

00:59.510 --> 01:07.050
null เพราะองค์ประกอบดังกล่าวอาจไม่มีอยู่ในหน้า แต่นั่นเป็นสิ่งที่แตกต่างออกไป

01:07.050 --> 01:09.920
ตอนนี้ไม่ต้องสนใจกรณีหรือโมฆะ

01:09.920 --> 01:14.600
สิ่งสำคัญคือ TypeScript พบว่านี่คือองค์ประกอบย่อหน้า

01:14.600 --> 01:16.800
ตอนนี้ การเปลี่ยนแปลงนี้ถ้าเราเลือกโดยสิ่งอื่น

01:16.800 --> 01:18.460
สมมุติว่า ID

01:18.460 --> 01:22.020
เราตั้งชื่อสิ่งนี้ที่นี่ว่า message-output ดังนั้นย่อหน้านี้จึงมี

01:22.020 --> 01:23.920
ID ของ message-output

01:23.920 --> 01:25.890
ตอนนี้เราในฐานะผู้พัฒนาทราบแล้วว่าเรากำหนด

01:25.890 --> 01:29.780
ID นี้ให้กับย่อหน้านี้ แต่ TypeScript ไม่ทราบ

01:29.780 --> 01:34.590
TypeScript ไม่ได้ดำดิ่งลงไปในไฟล์ HTML ของเราและวิเคราะห์มัน

01:34.590 --> 01:37.360
ดังนั้น หากตอนนี้เราเลือกตาม ID นั้นที่นี่

01:37.360 --> 01:41.720
เช่น ด้วย getElementById เราจะเห็นสิ่งที่ TypeScript อนุมานว่านี่เป็นเพียงองค์ประกอบ

01:41.720 --> 01:45.130
HTML หรือค่าว่าง ก็จะไม่รู้ว่าองค์ประกอบ HTML

01:45.130 --> 01:49.830
ใดที่เจาะจง

01:49.830 --> 01:52.720
ตอนนี้ สำหรับย่อหน้านั้นอาจไม่สำคัญมากนัก

01:52.720 --> 01:54.830
บางทีเราแค่ต้องการทำสิ่งต่างๆ

01:54.830 --> 01:57.290
กับมันที่เราสามารถทำได้กับองค์ประกอบ

01:57.290 --> 02:01.470
HTML ใดๆ เช่น เข้าถึงเนื้อหาข้อความหรืออะไรทำนองนั้น

02:01.470 --> 02:03.220
แต่ถ้าเรามีข้อมูลตรงนี้ล่ะ

02:03.220 --> 02:07.750
จะเกิดอะไรขึ้นถ้าเรามีข้อความประเภทอินพุต และเราต้องการรับค่าที่ผู้ใช้ป้อน

02:07.750 --> 02:12.760
ดังนั้นฉันจะให้ ID ของผู้ใช้อินพุต และตอนนี้ฉันเลือกสิ่งนี้ในโค้ด

02:12.760 --> 02:15.500
TypeScript ของฉัน

02:15.500 --> 02:17.730
ดังนั้นฉันจึงเลือกตาม ID ที่ผู้ใช้ป้อน

02:17.730 --> 02:21.530
และไม่ใช่ย่อหน้าอีกต่อไป แต่เป็น userInputElement

02:21.530 --> 02:24.023
ตอนนี้เราในฐานะนักพัฒนา เรารู้ว่าที่นี่ เราเข้าถึงองค์ประกอบอินพุตนี้

02:24.909 --> 02:28.530
แต่อย่างที่ฉันพูดไป TypeScript ไม่รู้เรื่องนั้น

02:28.530 --> 02:31.140
TypeScript ไม่อ่านโค้ด HTML ของเรา ดังนั้น TypeScript

02:31.140 --> 02:34.435
จึงรู้เพียงว่าเป็นองค์ประกอบ HTML บางส่วน

02:34.435 --> 02:37.860
ทีนี้ ถ้าผมต้องการตั้งค่าคุณสมบัติค่าของสิ่งนี้

02:37.860 --> 02:45.000
และมันก็จะพยายามทำ userInputElement

02:45.000 --> 02:45.000
ค่าเท่ากับ

02:45.000 --> 02:47.050
สวัสดี คุณเห็นว่าฉันได้รับข้อผิดพลาดจริงๆ

02:47.050 --> 02:48.960
ฉันได้รับข้อผิดพลาดเนื่องจากอย่างใดอย่างหนึ่ง

02:48.960 --> 02:50.780
วัตถุนี้อาจเป็นโมฆะ

02:50.780 --> 02:54.220
เราสามารถแก้ไขได้โดยการเพิ่มเครื่องหมายอัศเจรีย์หลังจากนี้

02:54.220 --> 03:03.890
และผมจะกลับมาในวินาทีนี้ แต่ถึงอย่างนั้น ผมก็ยังได้รับข้อผิดพลาดว่าไม่มีค่าในองค์ประกอบ HTML ประเภทเนื่องจากประเภททั่วไปนี้

03:03.890 --> 03:11.630
ซึ่งโดยพื้นฐานแล้ว HTML ใดๆ องค์ประกอบมีเป็นประเภท ไม่สนับสนุนคุณสมบัติที่เฉพาะเจาะจงกับองค์ประกอบ HTML

03:11.630 --> 03:14.510
ที่เฉพาะเจาะจง

03:14.510 --> 03:17.540
ดังนั้น เราจะต้องบอก TypeScript ว่าจริง

03:17.540 --> 03:20.860
ๆ แล้วสิ่งที่เราเลือกที่นี่ไม่ใช่แค่ไม่ใช่ค่าว่าง

03:20.860 --> 03:25.080
แต่เป็นประเภท HTMLInputElement ด้วย

03:25.080 --> 03:28.240
และนั่นคือสิ่งที่เราสามารถทำได้ด้วยการหล่อแบบ

03:28.240 --> 03:31.153
ตอนนี้ มีสองวิธีในการแคสติ้งประเภท ไวยากรณ์สองแบบที่เราสามารถใช้ได้

03:31.153 --> 03:34.170
และพวกมันเทียบเท่ากัน

03:34.170 --> 03:36.971
หนึ่งคือเราเพิ่มบางสิ่งข้างหน้าสิ่งที่เราต้องการแปลง

03:36.971 --> 03:41.920
หรือตำแหน่งที่เราต้องการบอกให้ TypeScript พิมพ์

03:41.920 --> 03:44.170
เราเพิ่มวงเล็บมุมเปิดและปิด

03:44.170 --> 03:45.810
และระหว่างวงเล็บเหล่านี้

03:45.810 --> 03:49.480
ประเภทของสิ่งที่อยู่หลังวงเล็บเหลี่ยม

03:49.480 --> 03:51.223
ในกรณีนี้ HTMLInputElement

03:53.110 --> 03:54.970
และประเภทนี้มีอยู่ทั่วโลกเพราะในไฟล์

03:54.970 --> 03:57.963
tsconfig ของฉัน ฉันรวม dom lib ไว้ด้วย

03:59.180 --> 04:00.810
ด้วยเหตุนี้ TypeScript

04:00.810 --> 04:03.830
จึงรู้ว่าสิ่งที่เราเลือกที่นี่หลังวงเล็บมุมจะเป็นประเภท

04:03.830 --> 04:08.950
HTMLInputElement ดังนั้นจึงไม่บ่นอีกต่อไป

04:08.950 --> 04:10.330
ดังนั้นนี่คือรุ่นที่หนึ่ง

04:10.330 --> 04:14.750
ให้ฉันคัดลอกสิ่งนั้นและแสดงความคิดเห็นและแสดงทางเลือกให้คุณ

04:14.750 --> 04:18.000
ใช้งานได้ดีอย่างแน่นอนและคุณสามารถใช้สิ่งนี้ได้

04:18.000 --> 04:21.210
อย่างไรก็ตาม ตอนนี้ ถ้าคุณรู้จัก React คุณจะรู้ว่าที่นั่น

04:21.210 --> 04:24.400
คุณยังมีไวยากรณ์วงเล็บเหลี่ยมมุมดังกล่าวภายใน

04:24.400 --> 04:29.200
JavaScript หรือ TypeScript หากคุณใช้สิ่งนั้นกับไฟล์ React ซึ่งคุณเขียนโค้ด

04:29.200 --> 04:33.550
JSX ในส่วนประกอบ React ของคุณ

04:33.550 --> 04:36.060
ตอนนี้ หากคุณไม่รู้จัก React นั่นอาจไม่ได้บอกอะไรคุณมากนัก

04:36.060 --> 04:43.320
โปรดทราบว่าไวยากรณ์ที่คล้ายกันมีอยู่ในโปรเจ็กต์ React และวงเล็บเหลี่ยมมุมนั้นไม่ได้ใช้เพื่อส่งผ่านข้อมูลใด

04:43.320 --> 04:47.480
ๆ เกี่ยวกับประเภทที่คุณใช้ แต่จะถูกแยกวิเคราะห์โดยเครื่องมือสร้างและโดย

04:47.480 --> 04:50.390
React ในท้ายที่สุดเพื่อให้รู้ว่าคุณทำอะไร

04:50.390 --> 04:54.390
ต้องการเรนเดอร์บนหน้าจอ

04:54.390 --> 04:56.750
ดังนั้นแยกออกจาก TypeScript โดยสิ้นเชิง

04:56.750 --> 04:59.880
เพื่อไม่ให้ขัดแย้งกับไวยากรณ์ JSX นั้น ทีม TypeScript

04:59.880 --> 05:04.350
ให้ทางเลือกแทนการแคสต์ประเภทวงเล็บเหลี่ยมมุมนี้

05:04.350 --> 05:07.920
คุณยังสามารถเพิ่มบางสิ่งหลังสิ่งที่คุณต้องการพิมพ์

05:07.920 --> 05:09.960
cast ดังนั้นหลังจากการเลือกนี้

05:09.960 --> 05:12.600
ในกรณีนี้ และสิ่งนั้นก็คือ as คำหลัก

05:12.600 --> 05:16.750
จากนั้นคุณเพิ่มประเภทที่คุณต้องการแคสต์อีกครั้ง

05:16.750 --> 05:19.970
ดังนั้น ตอนนี้จึงบอก TypeScript ว่านิพจน์ข้างหน้า

05:19.970 --> 05:23.730
ในกรณีนี้ นิพจน์ตรงนี้ จะให้ค่าเป็นประเภท

05:23.730 --> 05:27.405
HTMLInputElement

05:27.405 --> 05:30.067
ดังนั้นเราจึงไม่พบข้อผิดพลาดอีกครั้ง

05:30.067 --> 05:31.650
ดังนั้น นี่เป็นอีกทางเลือกหนึ่ง

05:31.650 --> 05:33.940
และคุณสามารถใช้หนึ่งในสองไวยากรณ์นี้

05:33.940 --> 05:42.377
อะไรก็ได้ที่คุณต้องการ คุณควรพยายามทำให้สอดคล้องกันตลอดทั้งโครงการ เพื่อไม่ให้คุณสลับระหว่างสองไวยากรณ์นี้

05:42.377 --> 05:45.220
และด้วยวิธีนั้น คุณสามารถส่งข้อมูลพิเศษที่มีค่านี้ไปยัง

05:45.220 --> 05:47.480
TypeScript และสร้างโค้ดในลักษณะนี้

05:47.480 --> 05:56.000
แม้ว่า TypeScript เองจะไม่สามารถทราบได้ว่าสิ่งนี้ให้ผลลัพธ์เป็น HTMLInputElement

05:56.000 --> 05:57.940
แน่นอน เนื่องจากคุณบังคับให้ TypeScript

05:57.940 --> 06:05.620
ใช้ประเภทนี้ จึงเป็นความรับผิดชอบของคุณในฐานะนักพัฒนาที่ต้องแน่ใจว่าอะไรก็ตามที่นิพจน์นี้ให้ผลจะเป็นประเภทนั้น

06:05.620 --> 06:09.920
มิฉะนั้น คุณอาจได้รับข้อผิดพลาดรันไทม์หรือพฤติกรรมที่ไม่คาดคิดในขณะรันไทม์

06:09.920 --> 06:14.423
หากคุณพยายามโต้ตอบกับองค์ประกอบนั้นด้วยวิธีที่ไม่ได้รับการสนับสนุน

06:15.610 --> 06:18.060
ดังนั้น การหล่อแบบจึงเป็นคุณสมบัติที่มีประสิทธิภาพ

06:18.060 --> 06:20.490
เครื่องหมายอัศเจรีย์นี้อยู่ที่นี่

06:20.490 --> 06:24.820
อันที่จริงฉันได้สำรวจสิ่งนี้ก่อนหน้านี้เล็กน้อยในหลักสูตรแล้ว

06:24.820 --> 06:27.470
เครื่องหมายอัศเจรีย์นี้ช่วยให้เราสามารถบอก TypeScript

06:27.470 --> 06:31.090
ว่านิพจน์ที่อยู่ข้างหน้าจะไม่มีวันให้เป็นค่าว่าง

06:31.090 --> 06:33.170
และสิ่งนี้จำเป็นสำหรับบางนิพจน์

06:33.170 --> 06:35.070
เช่น ตรงนี้ เมื่อคุณเลือกบางอย่างจาก

06:35.070 --> 06:38.010
dom ที่อาจคืนค่า null

06:38.010 --> 06:40.980
หากเราทราบในฐานะนักพัฒนาว่าสิ่งนี้จะไม่คืนค่า null

06:40.980 --> 06:43.690
เราสามารถใช้เครื่องหมายอัศเจรีย์นี้ได้

06:43.690 --> 06:45.470
มิฉะนั้น และคุณได้เรียนรู้แล้วว่า

06:45.470 --> 06:48.248
ฉันแค่ต้องการย้ำในเรื่องนี้

06:48.248 --> 06:49.380
มิฉะนั้น หากคุณไม่แน่ใจว่าการดำเนินการนี้จะไม่คืนค่า

06:49.380 --> 06:52.600
null คุณสามารถใช้เครื่องหมาย if ได้

06:52.600 --> 06:56.070
ดังนั้น คุณสามารถตรวจสอบได้ว่า userInputElement เป็นจริงหรือไม่

06:56.070 --> 06:59.440
ดังนั้น จึงไม่เป็นโมฆะ จากนั้นใช้มันในนั้น

06:59.440 --> 07:02.720
ตอนนี้ ฉันต้องลบการแคสต์ประเภทออกในกรณีนี้ เพราะหากเราพิมพ์การแคสต์ที่นี่

07:02.720 --> 07:04.670
เราจะบอก TypeScript ด้วยว่าสิ่งนี้จะไม่เป็นโมฆะ

07:04.670 --> 07:10.470
และเนื่องจากฉันไม่แน่ใจเกี่ยวกับสิ่งนั้น ฉันจึงแคสต์ที่นี่ไม่ได้

07:10.470 --> 07:16.600
แต่ฉันต้องทำที่นี่เมื่อฉันใช้ค่า ดังนั้นฉันจึงต้องการทำก่อนที่จะเข้าถึงคุณสมบัติค่า

07:16.600 --> 07:19.820
โดยเพิ่มเป็น HTMLInputElement แบบนี้

07:19.820 --> 07:21.530
แน่นอนว่าจะล้มเหลว

07:21.530 --> 07:24.060
นี่เป็นไวยากรณ์ที่ไม่ถูกต้อง คุณจะพยายามเข้าถึงคุณสมบัติค่าใน

07:24.060 --> 07:30.280
HTMLInputElement ซึ่งไม่สมเหตุสมผลด้วยซ้ำ

07:30.280 --> 07:35.670
เราเพียงแต่ใส่นิพจน์นี้ไว้ในวงเล็บ จากนั้นตรวจสอบให้แน่ใจว่านิพจน์นี้ได้รับการประเมินก่อน

07:35.670 --> 07:39.480
จากนั้นเราจึงพยายามเข้าถึงค่าจากผลลัพธ์ของนิพจน์นี้

07:39.480 --> 07:42.893
และตอนนี้เรามีทางเลือกในการใช้เครื่องหมายอัศเจรีย์
