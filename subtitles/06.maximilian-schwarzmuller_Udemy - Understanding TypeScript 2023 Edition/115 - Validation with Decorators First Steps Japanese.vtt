WEBVTT

00:02.160 --> 00:06.440
プレゼンター：さて､ デコレーターを使った素敵な例をもう1つ見たので､

00:06.440 --> 00:09.040
最後にもう1つ例を紹介します｡

00:09.040 --> 00:11.997
そして､ それが検証のためのデコレーターです｡ 

00:11.997 --> 00:14.560
そのために､ ファイルの一番下に､

00:14.560 --> 00:17.733
また新しいクラスをここに追加します｡

00:18.780 --> 00:20.530
それはコースになるかもしれませんね｡ 

00:20.530 --> 00:23.903
さて､ コースにはタイトルが必要です｡ これは文字列です｡ 

00:25.430 --> 00:27.483
そして､ 価格という数字もあるかもしれません｡ 

00:29.730 --> 00:32.640
次に､ コンストラクタで両方の値を取得します｡

00:32.640 --> 00:40.953
ここでは､ プロパティ・デコレータを簡単に追加できるように､ 意図的にショートカットを使用していません｡

00:42.690 --> 00:44.560
そして､ このタイトルをt､

00:44.560 --> 00:46.653
この価格をpとした｡

00:47.990 --> 00:50.530
さて､ もちろん､ このコースをインスタンス化する場合､

00:50.530 --> 00:53.610
有効なタイトルと有効な価格を渡さなければなりません｡

00:53.610 --> 00:56.730
しかし､ あるアプリケーションでよくあるシナリオは､

00:56.730 --> 00:59.630
例えばウェブリソースからデータを取得し､

00:59.630 --> 01:03.340
例えばいくつかのコースがあると推測されるデータを取得するが､

01:03.340 --> 01:08.110
確かなことは分からないというものです｡

01:08.110 --> 01:12.839
あるいは､ もう一つの可能性として､ ユーザーにデータを入力させ､ そのデータを単純に割り当て､

01:12.839 --> 01:15.490
ユーザーが入力したデータで新しいコースを取引したい､

01:15.490 --> 01:24.210
それが正しいと仮定するが､ それが正しいという保証はないので､ 入力の検証を行いたい､ などが考えられます｡

01:24.210 --> 01:26.380
それが､ 私がここで作りたいシナリオです｡ 

01:26.380 --> 01:29.940
index html

01:30.894 --> 01:32.840
ファイルで､

01:32.840 --> 01:36.074
ここにシンプルなフォームがあり､

01:36.074 --> 01:50.605
スタイル付けはしませんので､ 美しいフォームになります｡

01:50.605 --> 01:55.030
そして､ これを送信するためのボタンがあります｡ 

01:55.030 --> 02:00.030
つまり､ ボタンのタイプはsubmitです｡ 

02:00.040 --> 02:04.280
非常にシンプルなフォームで､ 先ほども言ったように､ ここで見てみるとそれほど美しいものではありませんが､

02:04.280 --> 02:06.070
必要なものはすべて揃っています｡

02:06.070 --> 02:08.763
さて､ ここでフォームにリスナーをフックアップしてみましょう｡ 

02:09.830 --> 02:18.840
ここでは､ document, querySelector,

02:18.840 --> 02:25.050
formで取得できるcourseFormを取得し､

02:26.390 --> 02:32.360
感嘆符を追加しています｡

02:32.360 --> 02:35.450
そこでイベントpreventDefaultを呼び出して､ フォームを送信せず､

02:35.450 --> 02:38.030
httpリクエストを送信しないようにしたいのです｡

02:38.030 --> 02:42.910
そして､ タイトルと価格のデータを抽出したいと思います｡

02:42.910 --> 02:49.700
タイトルはdocument, querySelectorにアクセスすることで抽出できますし､

02:49.700 --> 02:54.700
実際にはidを割り当てているので､ getElementById,

02:55.560 --> 03:01.700
titleで､ これはHTMLInputElementになることがわかっているので､

03:01.700 --> 03:09.672
typescriptにこのことを知らせるためにタイプキャストを使用できます｡

03:09.672 --> 03:11.320
具体的なタイトルを取得するには､

03:11.320 --> 03:30.060
titleElに移動してvalueプロパティにアクセスし､ 価格を取得するには､ priceElementに同じことをして､ そこでも値を取得することができます｡

03:30.060 --> 03:36.090
さて､ それはそれとして､ 今度はその情報を使って新しいコースを作りたいと思います｡

03:36.090 --> 03:39.060
ここで､ 作成されたコースは､ 新しいコースを呼び出すことができ､

03:39.060 --> 03:43.850
タイトルと価格を渡すことができます｡

03:43.850 --> 03:46.770
これでtypescriptは､ タイトルが文字列になり､ この入力を数値に変換するので､

03:46.770 --> 03:50.200
価格が数値になることを受け入れました｡

03:50.200 --> 03:55.530
そこで､ その後､ 作成されたコースをコンソールログに記録すれば､ これがうまくいくかどうかを確認することができます｡

03:55.530 --> 03:58.693
これを保存してリロードし､ 出力をはっきりと見ることができるようにコンソールをクリアして､

03:58.693 --> 04:02.400
新しいコースをここに追加しましょう｡

04:02.400 --> 04:05.785
Javascriptのコンプリートガイドは199ドルもしますが､

04:05.785 --> 04:08.010
これなら大丈夫そうです｡

04:08.010 --> 04:13.290
さて､ 残念ながら､ これは何も入力しない場合にのみ機能します｡

04:13.290 --> 04:16.600
保存をクリックすると､ このコースが作成されることが確認できます｡ 

04:16.600 --> 04:23.121
さて､ これは技術的には有効なコースですが､ もちろん､ 私たちのアプリケーションにはあまり有効ではありません｡

04:23.121 --> 04:28.620
タイトルが空でないこと､ 価格が0より大きいことが望ましいと思われます｡

04:28.620 --> 04:30.660
そこで､ バリデーションを追加します｡ 

04:30.660 --> 04:32.670
もちろん､ ここで単純に if チェックを追加して､

04:32.670 --> 04:41.100
title, trim, length が 0 より大きいかどうか､ つまり空でないかどうかをチェックし､ さらに価格の検証を行うこともできます｡

04:41.100 --> 04:47.880
しかし､ それは新しいコースを作成するたびに､ 追加する前にここでバリデーションロジックを追加しなければならないことを意味します｡

04:47.880 --> 04:53.940
デコレータの助けを借りて､ バリデーションロジックがコースクラスに含まれるのはいいことだと思いませんか?

04:53.940 --> 04:56.770
そして､ それこそが､ 私がここでやりたいことなのです｡ 

04:56.770 --> 05:04.861
次のモジュールでは､ これをより精巧に行うパッケージの例を紹介し､

05:04.861 --> 05:12.080
それを使って少し遊んでみることにします｡

05:12.080 --> 05:16.300
しかし､ ここでは独自のデコレータでこれを実装したいと思います｡

05:16.300 --> 05:24.433
ここに必要なデコレータを追加し､ さらにPositiveNumberという名前のデコレータ関数を追加します｡

05:26.710 --> 05:28.510
そこで､ ここに2人のデコレーターを配置しました｡ 

05:28.510 --> 05:35.369
そして3つ目の関数validateにオブジェクトを渡すと､

05:35.369 --> 06:03.410
typescriptがプロジェクトを見て､ 先ほどこのオブジェクトに対してこのクラスで登録したバリデーションを見つけ､ バリデーションロジックを適用する､ というものです｡

06:03.410 --> 06:05.480
それが､ 私がここで考えていることです｡ 

06:05.480 --> 06:08.240
つまり､ これはサードパーティライブラリの一部として公開され､

06:08.240 --> 06:11.170
必須正数値とバリデータをインポートして最初にバリデータを設定し､

06:11.170 --> 06:16.750
ある時点でバリデータを呼び出すことができるのです｡

06:16.750 --> 06:18.634
例えば､ ここでコースを作成したとき､

06:18.634 --> 06:42.960
validateを呼び出し､ createdCourseを渡して､ これがtrueでない場合､ つまり､ trueまたはfalseを返すとします｡

06:42.960 --> 06:43.870
というのが私の考えです｡ 

06:43.870 --> 06:46.540
これはvalidateと呼ばれるもので､ trueかfalseを返します｡ 

06:46.540 --> 06:51.670
有効であれば真､ 無効であれば偽､ したがってその結果を利用することができる｡

06:51.670 --> 06:53.730
それゆえ､ 私たちは2つのことを手に入れることができるのです｡ 

06:53.730 --> 06:59.350
ここにデコレーターを追加したとき､ これが何らかの形でどこかに保存されていることを確認する必要があります｡

06:59.350 --> 07:12.480
このクラスとタイトルのプロパティを保存するためのストレージを用意することができます｡

07:12.480 --> 07:15.630
そして､ validateでは､ 取得したオブジェクトのストレージに､

07:15.630 --> 07:23.330
そのオブジェクトが基づいているクラスについて､ タイトルや価格などのバリデータが登録されているかどうかを確認します｡

07:23.330 --> 07:25.260
そして､ 検証ロジックを実行します｡ 

07:25.260 --> 07:26.453
それが､ ここでの私の考えです｡ 
