WEBVTT

00:02.270 --> 00:04.390
المدرب: حسنًا ، هذا يكفي بشأن الوظائف العامة.

00:04.390 --> 00:06.490
سنستخدمها دائمًا طوال هذه الدورة

00:06.490 --> 00:08.150
، كل مشروع الدورة.

00:08.150 --> 00:10.390
لذلك يجب أن يصبح ذلك أكثر وضوحًا

00:10.390 --> 00:11.890
، وكلما عملنا معه.

00:11.890 --> 00:14.823
الفكرة العامة التي نأمل أن تكون واضحة الآن بالفعل.

00:15.660 --> 00:18.490
الوظائف العامة ليست كل ما يمكننا استخدامه على الرغم

00:18.490 --> 00:20.550
من ذلك ، فلدينا أيضًا فئات عامة ، وبالتالي

00:20.550 --> 00:21.560
، دعونا نرى كيف يمكننا

00:21.560 --> 00:23.740
إنشاء مثل هذه الفئة العامة ولماذا يمكننا

00:23.740 --> 00:25.170
القيام بذلك ، ولماذا قد يكون

00:25.170 --> 00:27.760
ذلك مفيدًا لنا.

00:27.760 --> 00:31.950
يمكننا إنشاء فئة تخزين هنا.

00:31.950 --> 00:36.060
فئة دعنا نقول ، والتي لديها بيانات الملكية الخاصة.

00:36.060 --> 00:38.850
والتي ستحتوي في النهاية على مجموعة من البيانات.

00:38.850 --> 00:40.940
ثم تحتوي على طريقة addItem ،

00:40.940 --> 00:44.200
والتي تأخذ عنصرنا ويجب إضافتها إلى البيانات

00:44.200 --> 00:45.763
بالدفع ، دعنا نقول.

00:48.570 --> 00:50.830
ولدينا طريقة removeItem ، والتي تأخذ

00:50.830 --> 00:52.173
العنصر الخاص بنا ، حيث

00:53.010 --> 00:57.740
يمكننا قول هذا. بيانات. لصق ثم نحتاج فقط إلى

00:57.740 --> 01:01.730
الحصول على indexOff (العنصر) هنا ولصق عنصر

01:01.730 --> 01:02.910
واحد.

01:02.910 --> 01:06.030
هذه هي الطريقة التي يمكننا بها إزالة عنصر من المصفوفة.

01:06.030 --> 01:07.873
وبالطبع getItems ، حيث العودة

01:09.750 --> 01:13.120
، دعنا نقول نسخة من هذا. البيانات ، مثل ذلك مع

01:13.120 --> 01:15.770
عامل الانتشار الذي تعرفت عليه.

01:16.610 --> 01:17.443
الآن يمكننا فعل

01:17.443 --> 01:19.450
ذلك ولدينا مجموعة من الأخطاء هنا.

01:19.450 --> 01:20.500
نحصل على مجموعة من الأخطاء

01:20.500 --> 01:23.900
، الآن لأحدها لأن اسم التخزين هو اسم محجوز ، لذلك دعونا نسميه

01:23.900 --> 01:25.230
Datastorage.

01:25.230 --> 01:26.620
من السهل التخلص من.

01:26.620 --> 01:27.920
الآن حصلنا أيضًا على خطأ

01:27.920 --> 01:29.400
هنا لأننا لا نقول أي شيء عن نوع

01:29.400 --> 01:30.880
البيانات التي نقوم بتخزينها

01:30.880 --> 01:32.960
، ونوع العنصر الموجود هنا.

01:32.960 --> 01:35.870
وهذا هو بالضبط المكان الذي يمكننا فيه تحويل هذا

01:35.870 --> 01:38.860
إلى فئة عامة لأنك قد لا تهتم بنوع البيانات.

01:38.860 --> 01:40.880
نريد التأكد من أنها بيانات موحدة

01:40.880 --> 01:42.410
، لذا فهي إما مجرد سلاسل

01:42.410 --> 01:44.830
، أو مجرد أرقام ، أو مجرد كائنات.

01:44.830 --> 01:47.550
لكن بخلاف ذلك ، لا أهتم بذلك.

01:47.550 --> 01:50.820
لذلك يمكننا هنا تحويل هذا إلى فئة عامة ، عن

01:50.820 --> 01:53.300
طريق إضافة أقواس زاوية بعد اسم

01:53.300 --> 01:56.330
الفئة ثم مرة أخرى T ، U ، أيًا كان ما تريد

01:56.330 --> 02:00.110
استخدامه كمعرف ، وإضافة هذا هنا كنوع عام.

02:00.110 --> 02:01.083
الآن يمكننا

02:01.083 --> 02:04.490
أن نقول هنا ، هذه مصفوفة من النوع T ، لذا فهي تخزن

02:04.490 --> 02:07.413
بيانات من هذا النوع العام فيها.

02:07.413 --> 02:09.670
لذلك ، نضيف هنا هذه البيانات

02:09.670 --> 02:12.400
، ونحاول إزالة هذه البيانات هنا.

02:12.400 --> 02:15.140
وبالتالي ، هنا نحصل على العناصر بشكل صحيح

02:15.140 --> 02:18.490
يتم استنتاجها لإرجاع مجموعة من الأنواع العامة.

02:18.490 --> 02:20.860
والآن يمكننا إنشاء وحدات تخزين مختلفة

02:20.860 --> 02:24.690
، ويمكننا الحصول على اللدغة أو التخزين النصي الخاص بنا

02:24.690 --> 02:29.500
هنا ، من خلال استدعاء DataStorage الجديدة ، وتعيين هذا النوع العام لكتابة

02:29.500 --> 02:31.250
سلسلة هنا.

02:31.250 --> 02:33.070
ثم هنا في textStorage ، يمكنني

02:33.070 --> 02:34.340
استدعاء addItem ، وإذا

02:34.340 --> 02:36.410
حاولت إضافة رقم ، فسأحصل على خطأ

02:36.410 --> 02:37.513
لأنني أقول إن هذا

02:37.513 --> 02:40.800
سيكون DataStorage الذي يخزن اللسعات فقط.

02:40.800 --> 02:45.800
لذا ، يمكنني بالفعل تخزين Max هنا ، وربما أيضًا تخزين Manu ، ثم

02:46.830 --> 02:51.450
الاتصال بـ textStorage. removeItem ('Max') ثم وحدة

02:51.450 --> 02:55.073
التحكم. سجل. textStorage. getItems.

02:56.520 --> 02:58.870
ويجب أن ينجح كل هذا إذا حفظنا

02:58.870 --> 03:00.300
ذلك لأنه نوع عام ،

03:00.300 --> 03:03.103
وفي النهاية لدينا فقط مانو هناك.

03:04.400 --> 03:08.240
لذلك سيكون هذا صنفًا عامًا واحدًا بسيطًا يمكننا إنشاؤه.

03:08.240 --> 03:10.500
الآن ، لماذا نبني مثل هذه الفئة العامة؟

03:10.500 --> 03:11.770
حسنًا كما قلت ، لأنه

03:11.770 --> 03:14.220
ربما لا نريد فقط تخزين النصوص ، قد

03:14.220 --> 03:17.110
أرغب أيضًا في تخزين بعض الأرقام في تخزين

03:17.110 --> 03:18.950
بيانات مختلف.

03:18.950 --> 03:21.510
بعد ذلك يمكنني إنشاء مثل DataStorage ،

03:21.510 --> 03:23.810
وتعيين هذا على رقم يضمن أنه يمكننا الآن

03:23.810 --> 03:26.250
إضافة أرقام فقط إلى هذا التخزين.

03:26.250 --> 03:28.330
بالطبع ، يمكننا أيضًا إعداد تخزين حيث

03:28.330 --> 03:30.520
نسمح بهما باستخدام نوع الاتحاد.

03:30.520 --> 03:32.550
لذلك ، لدينا مرونة كاملة

03:32.550 --> 03:36.470
هناك ، لكننا نعطي كتابة بعض المعلومات الإضافية

03:36.470 --> 03:38.490
، مما يجعل هذا الفصل مرنًا

03:38.490 --> 03:41.450
ولا يزال مكتوبًا بقوة.

03:41.450 --> 03:43.470
تمامًا كما كان لدينا مع الوظائف.

03:43.470 --> 03:46.910
أنواع مرنة حقًا ولا تزال مثالية.

03:46.910 --> 03:49.900
هذه هي الفكرة الكاملة وراء الأنواع العامة.

03:49.900 --> 03:52.680
لذلك ، يمكننا هنا فعل ذلك باستخدام فئة DataStorage

03:52.680 --> 03:53.750
من خلال تخزين السلاسل

03:53.750 --> 03:55.130
، أو عن طريق تخزين الأرقام

03:55.130 --> 03:56.513
، أو أي شيء نريده.

03:57.790 --> 04:01.300
ومع ذلك ، سنواجه مشكلة واحدة حول فئة تخزين البيانات الخاصة بنا.

04:01.300 --> 04:04.880
لنفترض هنا أن لدي تخزين كائني ، يمكنني الآن

04:04.880 --> 04:07.090
إنشاء DataStorage جديد وأقول

04:07.090 --> 04:10.490
هناك أريد تخزين كائنات ، حسنًا ، أريد تخزين

04:10.490 --> 04:12.270
العناصر وبالطبع يمكننا

04:12.270 --> 04:17.270
الانتقال إلى تخزين الكائنات وإضافة عنصر.

04:17.300 --> 04:20.460
دعنا نقول كائنًا لدي أسماء ماكس هناك.

04:20.460 --> 04:22.920
دعونا أيضًا نخزن كائنًا آخر ، حيث

04:22.920 --> 04:24.760
أقوم بتخزين Manu.

04:24.760 --> 04:26.770
بعد ذلك ، لنفترض أننا نقوم ببعض الأشياء

04:26.770 --> 04:28.310
في الكود الخاص بنا ، ثم في وقت

04:28.310 --> 04:29.740
لاحق هنا ، سأرغب في إزالة

04:29.740 --> 04:34.100
العنصر ، وأريد إزالة العنصر الذي يحمل الاسم: "Manu" هنا.

04:34.100 --> 04:37.863
وبعد ذلك ، أريد أن أعزّي. سجل. objStorage. getItems.

04:39.450 --> 04:40.550
مثل هذا.

04:40.550 --> 04:41.883
إذا حفظنا ذلك ، نرى

04:42.920 --> 04:45.840
أن لدينا كائنًا هناك وهو Max.

04:45.840 --> 04:47.470
لذلك يبدو ذلك جيدًا حقًا.

04:47.470 --> 04:49.140
الآن ، هذا ليس جيدًا حقًا.

04:49.140 --> 04:52.490
دعنا نقول هنا ، أريد إزالة Max الآن ، لذلك

04:52.490 --> 04:55.740
يجب أن نترك مانو في تخزين البيانات.

04:55.740 --> 04:59.653
ومن ثم ، إذا قمت بإعادة التحميل ، بئر ، فلا يزال Max.

05:00.550 --> 05:03.660
المشكلة الآن هي أننا نعمل مع الكائنات هنا ، كما

05:03.660 --> 05:07.350
تعلم أن الكائنات في JavaScript هي أنواع مرجعية.

05:07.350 --> 05:09.440
الآن ، أرفق للعثور على مورد إضافي

05:09.440 --> 05:11.460
، والذي يتيح لك الغوص في المرجع.

05:11.460 --> 05:12.730
بينما القيم البدائية

05:12.730 --> 05:14.650
، أفترض هنا أنك تعرف الفرق لأنه

05:14.650 --> 05:16.970
شيء أساسي في JavaScript ، وغير مرتبط

05:16.970 --> 05:19.060
تمامًا بالنص المطبوع.

05:19.060 --> 05:20.600
تكمن المشكلة هنا ، في

05:20.600 --> 05:22.300
الطريقة التي تم بها بناء

05:22.300 --> 05:26.243
فصلنا الدراسي بهذا المنطق حول كيفية إزالة البيانات

05:27.080 --> 05:29.580
وتحديدها ، فإننا لا نقوم بعمل جيد حقًا

05:29.580 --> 05:32.200
عندما نعمل بقيم غير بدائية.

05:32.200 --> 05:35.130
لذلك ، عندما نعمل مع كائنات أو مصفوفات

05:35.130 --> 05:37.840
، لأن indexOf ، إذا مررنا كائنًا هنا

05:37.840 --> 05:40.910
، فلن يعمل لأنه تقنيًا هذا كائن جديد.

05:40.910 --> 05:43.800
قد يبدو مثل هذا ولكنه لا يعمل لأن هذا

05:43.800 --> 05:46.520
تقنيًا كائن جديد تمامًا في الذاكرة

05:46.520 --> 05:48.290
وله عنوان مختلف.

05:48.290 --> 05:52.110
وبالفعل هنا ، ستبحث JavaScript عن العنوان ولا تجده

05:52.110 --> 05:54.930
بشكل أساسي ، لذا ما تفعله بعد ذلك هو إزالة

05:54.930 --> 05:58.453
العنصر الأخير في المصفوفة هنا ، لأن هذا في النهاية

05:59.510 --> 06:01.473
يعيد -1.

06:02.419 --> 06:06.070
تعيد IndexOf -1 حتى لو لم تجد أي شيء.

06:06.070 --> 06:07.990
مما يعني أنه يبدأ في نهاية المصفوفة

06:07.990 --> 06:09.770
، وهذا سلوك جافاسكريبت عادي ويزيل

06:09.770 --> 06:11.921
العنصر الأخير من المصفوفة.

06:11.921 --> 06:14.190
لهذا السبب نجحت مع Manu ، لم تنجح حقًا

06:14.190 --> 06:16.810
، لقد نجحت عن طريق الخطأ ، ولكن لماذا لا تعمل

06:16.810 --> 06:19.020
مع Max ، فنحن دائمًا نزيل العنصر الأخير

06:19.020 --> 06:19.880
من المصفوفة في

06:19.880 --> 06:21.760
الوقت الحالي ، نظرًا لعدم قدرتنا

06:21.760 --> 06:23.670
على تحديده.

06:23.670 --> 06:25.890
الآن ، عمل واحد على الأقل لإصلاح

06:25.890 --> 06:29.140
ذلك هو التحقق مما إذا وجدنا العنصر الخاص بنا

06:29.140 --> 06:32.260
، حتى نتمكن من التحقق مما إذا كان هذا الرمز هنا

06:32.260 --> 06:36.260
، إذا كان هذا يساوي -1 ، مما يعني أننا لم نعثر عليه.

06:36.260 --> 06:37.360
ثم يمكننا العودة

06:37.360 --> 06:40.780
والتأكد من عدم إزالة العنصر الخطأ عن طريق الخطأ.

06:40.780 --> 06:42.900
لكن بالطبع الآن قمنا فقط بإصلاح هذا الشريط

06:42.900 --> 06:44.850
، لكننا ما زلنا لا نملك هذه الحالة الداخلية

06:44.850 --> 06:46.580
حيث ستعمل مع الكائنات.

06:46.580 --> 06:48.890
حسنًا ، الطريقة الوحيدة التي يمكن أن تعمل بها

06:48.890 --> 06:51.740
مع الأشياء ، هي إذا مررنا نفس الشيء بالضبط مرة أخرى.

06:51.740 --> 06:55.700
لذلك إذا كان لدي كائن max الخاص بي مخزّنًا في ثابت

06:55.700 --> 06:58.840
، مثل هذا ، وهنا قمت بتمرير كائن max.

06:58.840 --> 07:02.050
وأنا أفعل الشيء نفسه هنا ، ثم أستخدم نفس الشيء ، نفس

07:02.050 --> 07:05.330
الشيء بالضبط ، نفس الشيء بالضبط في الذاكرة ، وبالتالي

07:05.330 --> 07:06.540
، الآن سيعمل.

07:06.540 --> 07:08.930
ستكون هذه هي الطريقة الوحيدة لإنجاح هذا العمل.

07:08.930 --> 07:12.340
لذلك ، هنا ، قد تكون الفكرة الأفضل هي التأكد

07:12.340 --> 07:16.150
من أن هذا لا يعمل إلا مع القيم البدائية.

07:16.150 --> 07:20.100
لذلك ، يمكننا القول أن T يمتد السلسلة ،

07:20.100 --> 07:24.010
العدد ، وربما كل الإضافات المنطقية.

07:24.010 --> 07:25.990
لذلك نقول الآن بشكل أساسي أن DataStorage

07:25.990 --> 07:27.920
يجب أن يعمل فقط مع هذه الأنواع.

07:27.920 --> 07:30.470
لذلك لم يعد مسموحًا بالأشياء.

07:30.470 --> 07:32.500
قد يكون هذا أفضل هنا لأننا سنحتاج

07:32.500 --> 07:35.220
إلى DataStorage أكثر تخصصًا ، والذي يعمل

07:35.220 --> 07:38.290
على الأرجح فقط مع الكائنات بدورها ، وليس مع

07:38.290 --> 07:40.080
القيم الأولية.

07:40.080 --> 07:42.430
لضبط منطق الاسترجاع لدينا هنا ، ربما للتحقق

07:42.430 --> 07:44.800
من وجود بعض معرفات iD في العنصر الذي يجب

07:44.800 --> 07:45.880
إزالته.

07:45.880 --> 07:46.970
الطريقة التي تعمل بها

07:46.970 --> 07:48.910
هنا ، إنها تعمل حقًا فقط للأنواع البدائية

07:48.910 --> 07:52.320
، لذا فإن وضع مثل هذا القيد هو بالتأكيد فكرة جيدة.

07:52.320 --> 07:55.610
وبهذا إذا حفظناها ، بعد التعليق عليها ، ستنجح

07:55.610 --> 07:57.253
مرة أخرى بالطبع.

07:58.810 --> 08:00.540
الآن وغني عن القول ، على أمل

08:00.540 --> 08:02.620
أنه بالطبع يمكن أن يكون لديك أكثر

08:02.620 --> 08:04.310
من نوع عام هنا أيضًا.

08:04.310 --> 08:05.910
أنت لا تقتصر على نوع واحد عندما

08:05.910 --> 08:07.600
تعمل مع الفصول الدراسية.

08:07.600 --> 08:09.610
ويمكنك أيضًا الحصول على طرق

08:09.610 --> 08:13.080
لها أنواع عامة خاصة بها بدلاً من الفئات.

08:13.080 --> 08:16.630
لذلك يمكنك تقديم أنواع عامة جديدة في طرق الفصل ، إذا

08:16.630 --> 08:18.010
كان لديك نوع عام ، وهو

08:18.010 --> 08:19.750
مطلوب فقط في طريقة معينة ،

08:19.750 --> 08:21.580
وليس في الفصل بأكمله.

08:21.580 --> 08:23.000
لذا فأنت مرن حقًا هناك.

08:23.000 --> 08:25.570
يمكنك استخدام القيود في كل

08:25.570 --> 08:28.100
مكان وبشكل عام ، توجد أنواع

08:28.100 --> 08:30.240
عامة لجعل حياتك أسهل

08:30.240 --> 08:33.900
ولإعطائك هذا المزيج المثالي من المرونة

08:33.900 --> 08:36.010
الكاملة.

08:36.010 --> 08:39.310
يمكننا استخدام أي قيمة أولية تريدها هنا وكتابة

08:39.310 --> 08:40.900
الأمان ، لأننا نعرف جيدًا

08:40.900 --> 08:42.820
ما يتم تخزينه في DataStorage

08:42.820 --> 08:44.710
وما يتم تخزينه في DataStorage

08:44.710 --> 08:46.770
هذا.

08:46.770 --> 08:50.660
لذا فإن هذا المزيج هو الشيء الرائع الذي تعطينا إياه

08:50.660 --> 08:52.283
الأنواع العامة.
