WEBVTT

00:02.100 --> 00:04.870
Instrutor: Vamos nos ater a arrays e objetos.

00:04.870 --> 00:06.750
Outra sintaxe importante, que você

00:06.750 --> 00:09.160
verá muito em JavaScript moderno e também

00:09.160 --> 00:10.440
em projetos Typescript,

00:10.440 --> 00:13.133
é a desestruturação de array e objetos.

00:14.180 --> 00:15.013
Como funciona?

00:15.013 --> 00:17.220
Bem, vamos começar com nossa série que

00:17.220 --> 00:20.220
temos, a série de hobbies que tem dois hobbies.

00:20.220 --> 00:22.200
Digamos que você queira extrair

00:22.200 --> 00:26.340
estes dois hobbies e armazená-los em variáveis ou constantes.

00:26.340 --> 00:28.891
Naturalmente, podemos fazer isso

00:28.891 --> 00:32.340
com um hobby igual a um hobby para o índice zero,

00:32.340 --> 00:33.470
que é o primeiro

00:33.470 --> 00:34.820
elemento.

00:34.820 --> 00:38.720
E o mesmo talvez com o hobby dois para os hobbies no índice um.

00:38.720 --> 00:40.500
Isto irá puxar estes dois elementos

00:40.500 --> 00:43.330
e armazená-los em constantes.

00:43.330 --> 00:44.720
Levou-nos duas linhas de código,

00:44.720 --> 00:46.710
e quanto mais elementos você quiser recuperar,

00:46.710 --> 00:48.493
mais linhas de código nos leva.

00:49.340 --> 00:51.690
A desestruturação da matriz nos permite encurtá-la.

00:51.690 --> 00:53.090
Com a desestruturação da

00:53.090 --> 00:56.250
matriz, que também funciona com let, não apenas com const,

00:56.250 --> 00:59.760
você adiciona colchetes no lado esquerdo do sinal de igualdade,

00:59.760 --> 01:01.400
que é um lugar incomum.

01:01.400 --> 01:02.900
Nunca tinha visto isso antes.

01:02.900 --> 01:04.780
E no lado direito você tem a matriz,

01:04.780 --> 01:06.480
que você quer desestruturar.

01:06.480 --> 01:08.430
Agora a desestruturação realmente significa

01:08.430 --> 01:10.470
que você retira elementos da matriz.

01:10.470 --> 01:13.570
E aqui no lado esquerdo entre estes colchetes, você

01:13.570 --> 01:15.040
os armazena em constantes,

01:15.040 --> 01:17.250
ou se você usar let, em variáveis.

01:17.250 --> 01:21.170
Portanto, aqui, poderíamos então ter o hobby um e o hobby dois.

01:21.170 --> 01:23.000
E o que esta sintaxe faz é, ela passa

01:23.000 --> 01:25.640
pela matriz de hobbies, pega o primeiro elemento

01:25.640 --> 01:26.920
e o armazena em uma constante

01:26.920 --> 01:29.050
com este nome, pega o segundo elemento,

01:29.050 --> 01:30.290
o armazena em uma constante

01:30.290 --> 01:32.320
com este nome.

01:32.320 --> 01:35.490
Você pode até mesmo adicionar parâmetros de descanso

01:35.490 --> 01:38.720
aqui e ter aqui os demais passatempos, caso o conjunto de

01:38.720 --> 01:42.130
passatempos tivesse mais elementos do que apenas dois.

01:42.130 --> 01:46.260
Então, todos os elementos restantes que não foram retirados para o hobby

01:46.260 --> 01:48.070
um ou hobby dois serão armazenados

01:48.070 --> 01:51.290
em um novo conjunto chamado hobbies restantes.

01:51.290 --> 01:54.090
Portanto, eles serão fundidos em um novo conjunto.

01:54.090 --> 01:57.940
A propósito, a desestruturação não altera a matriz original.

01:57.940 --> 02:02.940
Portanto, se nós consolarmos. hobbies de log, hobby um, e hobby dois aqui, você

02:04.260 --> 02:06.840
verá que os hobbies ainda são a velha série.

02:06.840 --> 02:08.840
Não está vazio ou nada parecido.

02:08.840 --> 02:11.780
Portanto, os valores que extraímos entre aspas são

02:11.780 --> 02:14.870
realmente apenas copiados em novas constantes ou variáveis,

02:14.870 --> 02:17.720
não realmente removidos da matriz.

02:17.720 --> 02:18.980
Isso é que é desestruturação de matriz.

02:18.980 --> 02:20.600
Nós temos o mesmo para os objetos.

02:20.600 --> 02:21.690
Temos aqui nossa pessoa.

02:21.690 --> 02:23.440
Agora vamos dizer que queremos armazenar

02:23.440 --> 02:26.630
nome e idade em constantes autônomas, ou variáveis.

02:26.630 --> 02:28.480
Assim como a desestruturação de array,

02:28.480 --> 02:31.840
a desestruturação de objetos funciona tanto com const como com let.

02:31.840 --> 02:33.010
Aqui vou com const.

02:33.010 --> 02:34.930
E agora podemos usar o aparelho de amarrar

02:34.930 --> 02:37.090
no lado esquerdo do sinal de igualdade.

02:37.090 --> 02:38.883
Embora seja uma nova sintaxe, acho eu.

02:39.920 --> 02:43.750
E ter nosso objeto, ou a variável apontando para o objeto do

02:43.750 --> 02:44.890
lado direito.

02:44.890 --> 02:46.110
A propósito, por favor, note

02:46.110 --> 02:48.770
que este não é um tipo de objeto que estou atribuindo aqui.

02:48.770 --> 02:51.200
Eu não tenho dois pontos aqui.

02:51.200 --> 02:54.080
Na verdade, é apenas um aparelho de amarrar como

02:54.080 --> 02:58.210
este no lado esquerdo, sem um cólon depois de um nome constante.

02:58.210 --> 03:01.000
Portanto, não estou atribuindo o tipo do valor que poderia

03:01.000 --> 03:02.720
ser armazenado uma constante.

03:02.720 --> 03:05.470
Estou realmente apenas usando uma sintaxe especial.

03:05.470 --> 03:08.450
Porque aqui, agora também podemos nos referir

03:08.450 --> 03:11.340
a nomes de propriedade que temos em um objeto,

03:11.340 --> 03:13.920
por exemplo, nome e idade, para retirar

03:13.920 --> 03:18.030
os valores dessas chaves de pessoa e armazená-las em constantes

03:18.030 --> 03:21.283
do mesmo nome.

03:23.290 --> 03:24.390
Agora aqui estou recebendo

03:24.390 --> 03:27.820
erros porque no topo eu já tenho uma variável de idade.

03:27.820 --> 03:30.890
E o nome acaba sendo uma variável disponível globalmente que existe

03:30.890 --> 03:32.173
de qualquer forma.

03:33.240 --> 03:34.940
Portanto, aí, o trabalho seria

03:34.940 --> 03:38.313
realmente apenas usar um nome chave diferente aqui, primeiro

03:40.240 --> 03:41.920
Nome, por exemplo.

03:41.920 --> 03:45.020
E agora podemos retirar o valor por essa chave aqui.

03:45.020 --> 03:46.900
Assim, é assim que funciona a desestruturação de objetos.

03:46.900 --> 03:50.110
O importante aqui é para a desestruturação da matriz,

03:50.110 --> 03:52.260
os elementos são puxados para fora em

03:52.260 --> 03:55.110
ordem porque uma matriz é uma lista ordenada.

03:55.110 --> 03:58.110
Nos objetos, a ordem nem sempre é garantida e, portanto,

03:58.110 --> 04:00.720
não retiramos elementos por posição, mas por

04:00.720 --> 04:02.070
nome chave.

04:02.070 --> 04:04.790
Portanto, os valores, ou os nomes que você especifica aqui

04:04.790 --> 04:05.930
entre as chaves encaracoladas,

04:05.930 --> 04:07.630
não são arbitrários.

04:07.630 --> 04:09.700
Você não pode inventar nomes aqui.

04:09.700 --> 04:13.860
Estes devem ser nomes de propriedade que você encontra no objeto, para que

04:13.860 --> 04:16.010
os valores para estas chaves possam ser

04:16.010 --> 04:18.160
retirados do objeto E então eles são armazenados

04:18.160 --> 04:21.880
em constantes ou variáveis com o mesmo nome.

04:21.880 --> 04:24.120
Se você quiser substituir esse nome, você poderia

04:24.120 --> 04:25.970
fazê-lo com um cólon aqui.

04:25.970 --> 04:28.050
Mais uma vez, não é uma atribuição de tipo aqui.

04:28.050 --> 04:29.680
Ele apenas estabelece um novo nome.

04:29.680 --> 04:31.970
Portanto, isto é tudo sintaxe JavaScript,

04:31.970 --> 04:33.820
não tem nada a ver com Typescript.

04:33.820 --> 04:35.370
Portanto, aqui poderíamos armazenar

04:35.370 --> 04:38.750
isto em uma constante de nome de usuário, por exemplo.

04:38.750 --> 04:39.840
E, portanto, a partir

04:39.840 --> 04:44.040
daí, podemos consolar. log userName e idade, mas não firstName,

04:44.040 --> 04:45.290
porque basicamente

04:45.290 --> 04:47.870
sobrescreveu firstName para ser nomeado

04:47.870 --> 04:50.900
userName na constante que criamos quando retiramos

04:50.900 --> 04:52.790
valores aqui.

04:52.790 --> 04:55.880
A idade não é sobregravada, portanto, podemos usá-la assim.

04:55.880 --> 04:58.183
Mais uma vez, esta não é uma tarefa do tipo aqui.

04:58.183 --> 05:00.210
Esta é a sintaxe JavaScript, onde

05:00.210 --> 05:03.680
nós também renomeamos uma propriedade que estamos

05:03.680 --> 05:05.500
retirando de pessoa.

05:05.500 --> 05:07.430
Além disso, assim como antes com a

05:07.430 --> 05:09.840
matriz, a pessoa objeto em si não mudou.

05:09.840 --> 05:13.380
Nós realmente apenas copiamos esses valores do objeto.

05:13.380 --> 05:15.643
E, portanto, obtemos este resultado aqui.
