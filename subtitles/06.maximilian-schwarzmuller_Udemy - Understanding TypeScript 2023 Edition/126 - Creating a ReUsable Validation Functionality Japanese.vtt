WEBVTT

00:02.160 --> 00:06.060
講師：では､ バリデーションについてはどうでしょう｡ 

00:06.060 --> 00:10.450
そうですね､ たぶん､ 望ましい最終結果から始めましょう｡ 

00:10.450 --> 00:14.850
私の考えでは､ まだ存在しないが､ 後で検証関数を用意し､

00:14.850 --> 00:17.950
そこにenteredTitle､

00:17.950 --> 00:25.360
つまり値がenteredTitleである構成オブジェクトを渡して､

00:25.360 --> 00:30.300
検証の対象とすることだ｡

00:30.300 --> 00:39.130
しかし､ バリデーション関数にどのようにバリデーションを行うかを指示する追加のプロパティを用意します｡

00:39.130 --> 00:43.210
例えば､ ここではrequiredをtrueに設定し､ minLengthを5文字に設定し､

00:43.210 --> 00:48.360
5文字を強制する､ といった具合です｡

00:48.360 --> 00:50.040
そして､ これを3つの入力に対して行います｡

00:50.040 --> 00:59.580
validateは､ 入力が有効な場合はtrueを､ 無効な場合はfalseを返す関数で､ 最終的にはこのようなものになります｡

00:59.580 --> 01:04.580
あるいはenteredDescriptionとenteredPeople､

01:04.790 --> 01:06.790
大体そんな感じでしょうか｡

01:06.790 --> 01:11.703
もちろん､ これは一つの方法ですが､ 私はこの方法をとても気に入っています｡

01:12.600 --> 01:19.470
そのために､ ファイルの先頭で､ いくつかの検証ロジックを追加することにします｡

01:19.470 --> 01:22.380
そして､ やはり､ いろいろなやり方があります｡ 

01:22.380 --> 01:27.840
まず最初に､ このようなバリデータ・オブジェクトの構造を定義することから始めることにする｡

01:27.840 --> 01:31.280
このオブジェクトをバリデート関数に渡します｡

01:31.280 --> 01:37.820
もちろん､ このオブジェクトは常に同じような構造を持ち､

01:37.820 --> 01:49.870
そこに存在しうる一定の量のプロパティと一定のタイプのプロパティが必要だからです｡

01:49.870 --> 01:52.850
そこで､ まずインターフェイスを定義することから始めます｡ 

01:52.850 --> 01:56.550
また､ カスタムタイプにすることも可能で､ 完全にお任せします｡

01:56.550 --> 01:58.690
オブジェクトの構造を定義するので､

01:58.690 --> 02:02.793
私はいつもインターフェースだけを定義することの方が好きなんです｡

02:03.810 --> 02:06.700
これはバリデーション可能なオブジェクトを記述し､

02:06.700 --> 02:09.940
文字列または数値であるべき値を持つので､

02:09.940 --> 02:17.140
ここではValidatableと名付けることにする｡

02:17.140 --> 02:18.980
これは必須のプロップであり､

02:18.980 --> 02:22.630
ブール値､ つまり真か偽を持つ｡

02:22.630 --> 02:28.212
そして､ 数値であるべきminLengthの検証､ 数値であるべきmaxLengthの検証､

02:28.212 --> 02:30.220
さらに､ 数値を取得する場合には､

02:30.220 --> 02:35.240
minとmaxの値もサポートするとする｡

02:35.240 --> 02:37.417
minLengthやmaxLengthとの違いは､

02:37.417 --> 02:46.010
これは文字列の長さをチェックするもので､ これはある数値以上か最大値以下の場合にその数値をチェックするものです｡

02:46.010 --> 02:48.870
私が応援したいのは､ こういう物件です｡ 

02:48.870 --> 02:52.140
さて､ 値以外に､ これらはすべてオプションであるべきですが､

02:52.140 --> 02:57.650
名前の後にクエスチョンマークを追加することで強制することができます｡

02:57.650 --> 03:00.070
ちなみに､ クエスチョンマークを使う代わりに､

03:00.070 --> 03:02.720
未定義の値を許容することができます｡

03:02.720 --> 03:04.880
クエスチョンマークも基本的には同じです｡ 

03:04.880 --> 03:09.370
requiredはブール値か未定義と書いてある｡ 

03:09.370 --> 03:12.610
これでvalidatableインターフェイスができました｡ 

03:12.610 --> 03:13.893
それを使って何ができるのか？

03:14.930 --> 03:17.893
さて､ このインターフェースができたので､

03:18.830 --> 03:24.220
私が探している検証用の関数を作ることができます｡

03:24.220 --> 03:27.410
そのような検証可能なオブジェクトを得ることができるはずです｡ 

03:27.410 --> 03:32.410
したがって､ ValidatableInputはValidatable型である｡ 

03:32.410 --> 03:33.450
それが､ ここでの私の考えです｡ 

03:33.450 --> 03:36.400
そこで､ この構造を持つオブジェクトを取得する｡ 

03:36.400 --> 03:38.270
そして､ その中で､ これらのプロパティがすべて存在するかどうかをチェックし､

03:38.270 --> 03:44.810
適切な検証を行うことができるようになりました｡

03:44.810 --> 03:48.200
では､ validate関数では一体何をするのでしょうか？

03:48.200 --> 03:49.033
さて､ 最後にisValidという変数を作りたいのですが､

03:49.033 --> 03:52.330
これは初期状態ではtrueになっています｡

03:52.330 --> 03:55.510
だから､ デフォルトでは､ 得られたものが真実であることが前提です｡

03:55.510 --> 03:57.430
しかし､ 少なくとも1つのチェックが失敗したら､

03:57.430 --> 04:01.330
すぐにfalseに設定します｡

04:01.330 --> 04:03.480
そして､ いよいよ最初のチェックに入ります｡ 

04:03.480 --> 04:06.410
このvalidatableInput､

04:06.410 --> 04:11.380
つまり取得する引数に必須のpropがあるかどうか見てみましょう｡

04:11.380 --> 04:13.260
それが未定義でないなら

04:13.260 --> 04:16.490
これが設定され､ したがってそれが真である場合､

04:16.490 --> 04:20.630
これは値が必須であり､ 空であってはならないことを意味する｡

04:20.630 --> 04:22.080
ここで､ isValidをisValidと等しくすることで､

04:22.080 --> 04:34.330
JavaScriptの動作として､ andの後にあるものがfalseであれば､ isValidの新しい値はfalseになることが保証されます｡

04:34.330 --> 04:36.870
なぜなら､ 2つのうち少なくとも1つが偽であれば､

04:36.870 --> 04:38.660
全体の値も偽になるからです｡

04:38.660 --> 04:40.500
これで､ isValidの初期値は真ですが､

04:40.500 --> 04:46.300
論理演算子や演算子の後が偽であれば､ isValidは偽になります｡

04:46.300 --> 04:48.700
そして､ 最後にisValidを返すことにしています｡ 

04:48.700 --> 04:53.550
では､ 次に2つのアンパサンドシンボルの後に何を追加すればよいのでしょうか｡

04:53.550 --> 04:58.170
さて､ 私はvalidatableInput.Fileが､ そのような入力に対応しているかどうかをチェックしたいのです｡  の値が空であれば､ その値を使用する｡

04:58.170 --> 05:00.530
そのためには､ トリミングして長さを確認すればいいわけですが､

05:00.530 --> 05:04.210
どうでしょう？

05:04.210 --> 05:07.510
さて､ 問題は､ valueが文字列かどうかわからないことです｡

05:07.510 --> 05:09.090
文字列か数字です｡ 

05:09.090 --> 05:10.910
そのため､ 文字列であることが保証されていないため､

05:10.910 --> 05:14.100
trimメソッドが常に使えるわけではありません｡

05:14.100 --> 05:17.570
今はそれを回避するために､ さまざまな工夫がなされています｡ 

05:17.570 --> 05:23.390
タイプガードを追加して､ typeof validatableInputかどうかをチェックすることができます｡

05:23.390 --> 05:23.390
の値が文字列と等しい場合にのみ､

05:25.250 --> 05:30.250
このチェックを行います｡

05:30.920 --> 05:33.040
でも､ 実はそれだとちょっと冗長になるんです｡ 

05:33.040 --> 05:36.120
ここでできることは､ とてもシンプルです｡ 

05:36.120 --> 05:39.140
単純に「じゃあ､ 文字列に変換してくれ」と言えばいいのです｡

05:39.140 --> 05:39.140
数字だったら､ 今度は文字列に戻す｡ 

05:39.140 --> 05:41.370
文字列であれば､ 何も変わりませんでした｡ 

05:41.370 --> 05:44.170
それを踏まえて､ こうしているのです｡ 

05:44.170 --> 05:45.900
あとはここでチェックを入れて､

05:45.900 --> 05:47.950
それがゼロかどうかを確認します｡

05:47.950 --> 05:50.360
正確には､ ゼロでない場合です｡ 

05:50.360 --> 05:53.463
つまり､ もしそれがゼロでなければ､ これは真を返し､

05:54.680 --> 05:58.740
isValidは真のままである｡

05:58.740 --> 06:00.500
もし､ 長さがゼロなら､ もし､

06:00.500 --> 06:02.760
空なら､ これはfalseを返すので､

06:02.760 --> 06:04.940
isValidはfalseになる｡

06:04.940 --> 06:08.280
そして､ requiredをtrueに設定して必須チェックのフラグが立った場合のみ､

06:08.280 --> 06:11.190
このチェックを行うようにしています｡

06:11.190 --> 06:13.530
それが､ 私がここで行いたい最初のチェックです｡ 

06:13.530 --> 06:15.560
もちろん､ それだけではありません｡ 

06:15.560 --> 06:18.950
続けて､ validatableInput.

06:18.950 --> 06:18.950
minLengthが設定されている場合､

06:18.950 --> 06:27.050
取得するこの文字列は､ ある最小の長さでなければなりません｡

06:27.050 --> 06:30.440
重要なのは､ 文字列が一定の長さ以上であることです｡

06:30.440 --> 06:33.600
ここでは数値にはこだわらず､ 数値の最小値をチェックしているわけではありません｡

06:33.600 --> 06:37.060
ここで実際にタイプガードを追加し､ このチェックに組み込んで､

06:37.060 --> 06:42.320
typeof validatableInputかどうかをチェックすることができるのです｡

06:42.320 --> 06:42.320
の値は文字列と等しい｡

06:46.910 --> 06:48.460
そうでない場合は､ チェックするものがないので､

06:48.460 --> 06:50.357
このifチェックに入る必要はないのです｡

06:50.357 --> 06:52.570
値が数値の場合､ これは気にしない｡ 

06:52.570 --> 06:55.330
数値に最小の長さを設定した場合､ あまり意味がないので､

06:55.330 --> 06:59.330
基本的にこのチェックをスキップします｡

06:59.330 --> 07:03.420
しかし､ 文字列があり､ minLengthが設定されている場合､

07:03.420 --> 07:05.663
isValidをisValidと等しく設定し､

07:06.570 --> 07:10.053
再度､ チェックを行うようにしたい｡

07:11.181 --> 07:12.600
そして､ ここでのチェックは､

07:12.600 --> 07:24.070
validatableInput. の値は､ この時点では文字列であることがわかっていますが､ 長さがvalidatableInputよりも大きくなっています｡

07:24.070 --> 07:24.070
minLengthを指定します｡ 

07:24.070 --> 07:28.520
つまり､ ここで定義された値よりも大きい｡ 

07:28.520 --> 07:31.660
しかし､ ここで1つだけ潜在的な問題があります｡

07:31.660 --> 07:33.920
それが何かわかりますか？

07:33.920 --> 07:38.630
これは一般的に動作するはずですが､ minLengthが0に設定されている場合は失敗します｡

07:38.630 --> 07:42.210
開発者が0にした意図は､ このチェックをスキップするためではなく､

07:42.210 --> 07:50.170
最小の長さが0であるかどうかを確認するためでしょう｡

07:50.170 --> 07:53.800
というのも､ このチェックは基本的に何も持っていないかどうかを確認するものであり､

07:53.800 --> 07:57.260
必要なチェックはすでに行っているからです｡

07:57.260 --> 07:59.300
だから､ 大きな問題ではないんです｡ 

07:59.300 --> 08:01.330
それでも､ ここで超安全を期すなら､

08:01.330 --> 08:05.470
実際にvalidatableInputかどうかをチェックすべきです｡

08:05.470 --> 08:05.470
minLength が undefined と等しくない｡ 

08:05.470 --> 08:10.470
あるいは､ nullと等しくない場合は､

08:10.640 --> 08:17.130
等号を1つ付ける｡ これは､ nullとundefinedを含む､ JavaScriptの仕組みである｡

08:17.130 --> 08:20.470
これは､ minLengthが0に設定されている場合でも､

08:20.470 --> 08:25.140
常にこのチェックを実行するようにしたため､ 少し安全になっています｡

08:25.140 --> 08:27.222
繰り返しになりますが､ 基本的に上と同じチェックなので､

08:27.222 --> 08:32.270
意味があるかどうかは議論の余地がありますが､ それでもここでは実行したいのです｡

08:32.270 --> 08:34.930
つまり､ これがminLengthです｡ 

08:34.930 --> 08:38.130
さて､ これをコピーして､ 基本的にmaxLengthも同じようにします｡

08:38.130 --> 08:40.720
そのため､ ここでのmaxLengthは､

08:40.720 --> 08:44.350
ここでも､ また､ 文字列に対してのみチェックされます｡

08:44.350 --> 08:46.870
そしてもちろんここでは､ これを元に戻すだけです｡ 

08:46.870 --> 08:52.380
提供される値の長さが最大長以下であることを確認する必要があります｡

08:52.380 --> 09:00.160
さて､ そして今度は､ 数値にしか意味をなさないminとmaxの値のチェックが2つ残されています｡

09:00.160 --> 09:05.150
そこで､ ここではもう一つチェックを追加し､ validatableInput.Dataが入力可能かどうかをチェックします｡

09:05.150 --> 09:05.150
minはnullと等しくない｡

09:09.720 --> 09:11.100
繰り返しになりますが､ 真偽を確かめるだけでは､

09:11.100 --> 09:13.820
値がゼロの場合に問題が生じるからです｡

09:13.820 --> 09:21.770
そして､ validatableInputのタイプかどうかをチェックします｡  の値は数値と等しい｡

09:21.770 --> 09:25.640
なぜなら､ これを文字列でチェックすることにあまり意味がないように思えるからです｡

09:25.640 --> 09:28.020
文字列かどうか確認したい場合は､ もちろんこれを省略することができます｡

09:28.020 --> 09:29.680
あとは､ これから書くチェックで使うときに､

09:29.680 --> 09:34.380
その値を数値に変換するようにすればいいんです｡

09:34.380 --> 09:37.220
これから書くチェックも､ 古いisValidの値を使い､

09:37.220 --> 09:41.500
新しいチェックと組み合わせて､ 再びisValidに格納するものです｡

09:41.500 --> 09:44.000
そして､ 新しいチェックでは､ 私たちの数値をうまく取り込んで､

09:44.000 --> 09:48.730
それが最小値より大きいかどうかをチェックするようにしました｡

09:48.730 --> 09:50.720
そこで､ ここでは､ validatableInput. の値が validatableInput

09:50.720 --> 09:54.650
よりも大きい場合｡ min.

09:54.650 --> 09:58.690
次に､ これをmaxについて繰り返します｡

09:58.690 --> 10:06.190
ここではmaxが必要ですが､ ここではmaxも必要です｡

10:06.190 --> 10:13.230
それを踏まえて､ ここで考えられるさまざまなシナリオを確認しているのです｡

10:13.230 --> 10:16.930
そして､ isValidを返しています｡ 

10:16.930 --> 10:18.710
あとは､ このインターフェイスに準拠したオブジェクトを作成し､

10:19.840 --> 10:23.630
validate関数に送るだけです｡

10:23.630 --> 10:26.573
そのために､ プロジェクト入力に移動し､

10:28.160 --> 10:34.000
そこで gatherUserInput で検証可能なオブジェクトを作成します｡

10:34.000 --> 10:36.360
余談ですが､ インターフェース以外にも､ もちろんここでクラスを作成し､

10:36.360 --> 10:40.870
newキーワードでインスタンス化することもできましたが､ ここでは練習とデモのために､

10:40.870 --> 10:46.070
インターフェースでどのように動作するかをお見せしたいと思います｡

10:46.070 --> 10:48.990
ここで titleValidatable は Validatable

10:48.990 --> 10:51.900
型である必要があります｡

10:52.850 --> 10:56.830
そしてそれはもちろん､ valueプロパティを持つ必要のあるオブジェクトである｡

10:56.830 --> 10:58.930
そして､ これがenterdTitleです｡ 

10:58.930 --> 11:01.020
他のプロパティは必要ないのですが､

11:01.020 --> 11:06.750
空でないことを確認したいので､ requiredをtrueに設定します｡

11:06.750 --> 11:12.430
そして､ それをコピーして､ 説明文や人物のために繰り返すことができます｡

11:12.430 --> 11:16.270
そして､ ここに説明文があります｡ おっと､

11:16.270 --> 11:19.250
入力された説明文のことですね｡

11:19.250 --> 11:21.880
ここでは､ エントリーされた人たちを紹介します｡ 

11:21.880 --> 11:24.260
正確には数字が欲しいところです｡ 

11:24.260 --> 11:26.230
そこで､ これをプラス記号で数字に変換しています｡ 

11:26.230 --> 11:30.810
すべて必須ですが､ ここでは説明文の長さを5文字以上とし､

11:30.810 --> 11:32.890
人物については最低1人にして､

11:32.890 --> 11:38.823
少なくとも2人の人物が割り当てられるようにします｡

11:39.820 --> 11:42.030
ちなみに､ これをどう実装するかは､ あなた次第です｡ 

11:42.030 --> 11:44.020
もちろん､ 検証ロジックで､

11:44.020 --> 11:50.080
大なり小なり等しいかどうかをチェックすることも可能です｡

11:50.080 --> 11:52.030
コースの長さも同じです｡ 

11:52.030 --> 11:54.200
より大きなイコール､ より小さなイコール｡ 

11:54.200 --> 11:56.940
それもありですね｡ 

11:56.940 --> 11:58.660
実は､ この変更はそのままにしておきます｡ 

11:58.660 --> 12:01.920
これで最低1人､ 最高5人が割り当てられたわけです｡

12:01.920 --> 12:05.253
3つの検証可能なオブジェクトがあり､ ここで検証関数に

12:06.100 --> 12:08.500
titleValidatable

12:08.500 --> 12:16.440
を渡し､ 2番目の関数呼び出しに descriptionValidatable を渡し､ 3番目の関数呼び出しに

12:16.440 --> 12:21.310
peopleValidatable を渡しています｡

12:21.310 --> 12:26.380
そして､ validateはそれらがすべて有効であればtrueを､ そうでなければfalseを返すようにしました｡

12:26.380 --> 12:32.420
そこで今度は､ これらのうち少なくとも1つが失敗しているかどうかをチェックするために､

12:32.420 --> 12:41.560
感嘆符を前に付けてこれらがすべて偽であるかどうかをチェックしたいと思います｡

12:41.560 --> 12:42.740
そして､ 少なくとも1つがfalseであれば､

12:42.740 --> 12:45.730
つまり､ 少なくとも1つのvalidate関数呼び出しがfalseを返せば､ その中に作り､

12:45.730 --> 12:47.760
アラートを表示することにします｡

12:47.760 --> 12:49.860
そして､ これをテストするために､

12:51.930 --> 12:54.860
indexに移動してみます｡

12:54.860 --> 12:54.860
htmlの場合､

12:56.270 --> 13:00.410
入力欄には最大10個､ 最小0個まで入力できるようにしました｡

13:00.410 --> 13:01.460
そのため､ 入力では技術的に無効な値を入力することが可能です｡ 

13:01.460 --> 13:06.240
もちろん､ ロジックを検証するために､ わざとです｡

13:06.240 --> 13:08.090
そしてそこでとりあえず全部保存してみましょう､

13:08.090 --> 13:10.200
エラーなしでコンパイルできます｡

13:10.200 --> 13:11.750
さあ､ 試してみましょう｡ 

13:11.750 --> 13:13.083
プロジェクトの追加をクリックすると､

13:13.920 --> 13:16.000
エラーが表示されますが､ これは良いことです｡

13:16.000 --> 13:17.430
ここでテストを入力してみますが､ やはりエラーになります｡ 

13:17.430 --> 13:21.370
ここにテスト､ ここに5と入力してみましょう､

13:21.370 --> 13:24.180
それでもエラーが出ます｡

13:24.180 --> 13:25.390
私の説明が短すぎるからです｡ 

13:25.390 --> 13:26.870
もう1文字入力すると､ 最小の長さになり､

13:26.870 --> 13:29.500
これを作成することができます｡

13:29.500 --> 13:31.210
では､ 今度は､ 例えばマイナス1人の人を入力してみると､

13:31.210 --> 13:34.580
まあいいやhtmlはこれをサポートしていない｡

13:34.580 --> 13:39.200
しかし､ 0や6を入力しようとしても､ エラーが出てしまう｡

13:39.200 --> 13:42.040
そして､ 1から5の間の何かを入力した場合のみ､

13:42.040 --> 13:43.840
動作します｡

13:43.840 --> 13:46.100
それで､ その通りに動作しているようで､

13:46.100 --> 13:49.260
なかなかいい感じです｡

13:49.260 --> 13:51.850
もちろん､ これはバリデーションの実装方法のひとつに過ぎないのですが｡

13:51.850 --> 13:53.570
もちろんtypescriptの利点を生かし､

13:53.570 --> 14:04.480
不要なミスを避けるための素晴らしいサポートと型チェックを提供してくれています｡
