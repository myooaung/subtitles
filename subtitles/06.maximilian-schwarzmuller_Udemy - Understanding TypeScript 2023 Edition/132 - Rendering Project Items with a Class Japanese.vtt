WEBVTT

00:02.190 --> 00:05.900
講師：継承の作業が一段落したので､ リストアイテムのレンダリングに戻り､

00:05.900 --> 00:10.590
より詳細なレンダリングを行いましょう｡

00:10.590 --> 00:14.900
そして､ 先ほども言ったように､ レンダリングの方法も工夫しましょう｡

00:14.900 --> 00:18.050
ここまではオブジェクト指向のアプローチで､ 例えばプロジェクトリストにはクラスがあり､

00:18.050 --> 00:26.560
そのクラスをインスタンス化すると､ このようなボックスがここにレンダリングされるのです｡

00:26.560 --> 00:30.000
入力についても同様で､ プロジェクト入力クラスがあり､ これをインスタンス化すると､

00:30.000 --> 00:34.880
上部にあるこのプロジェクト入力エリアがレンダリングされます｡

00:34.880 --> 00:38.330
次に､ プロジェクトアイテムにも同じことを行って､ レンダリングしたプロジェクトのプロジェクトリストの中で､

00:38.330 --> 00:55.100
このようにリストアイテムを作成する代わりに､ プロジェクトアイテムクラスをインスタンス化して､ そのプロジェクトアイテムクラスのコンストラクタで､ すべての初期化などを行うようにしてはどうでしょう｡

00:55.100 --> 00:57.240
少なくとも私はそう考えています｡ 

00:57.240 --> 01:01.680
さて､ いつものように､ ここでビデオを一時停止して､

01:01.680 --> 01:06.960
まず自分でやってみることができます｡

01:09.080 --> 01:12.980
プロジェクト・リスト・クラスの上に､ プロジェクト・アイテム・クラスを追加し､

01:12.980 --> 01:22.920
これが単一のプロジェクト・アイテムのレンダリングを担当するクラスとなります｡

01:22.920 --> 01:28.940
なぜなら､ このクラスは画面上に何かを表示するためのものであり､

01:28.940 --> 01:36.410
そのためにコンポーネントクラスがあるのですから｡

01:36.410 --> 01:40.100
テンプレートやホストエレメントなどを渡すように｡ 

01:40.100 --> 01:43.560
ですから､ プロジェクト・アイテムでは､ もちろんコンストラクタが必要です｡

01:43.560 --> 01:47.030
コンストラクタでは､ superも呼び出す必要があります｡

01:47.030 --> 01:53.610
そして､ 実はsuperを呼び出す前に､ 継承するベースクラスにこれらの汎用型を設定しましょう｡

01:53.610 --> 02:00.410
ここで渡す最初の型はホスト要素であり､ 何かをレンダリングする場所であることに留意してください｡

02:00.410 --> 02:04.800
2つ目の汎用型は､ レンダリングする要素である｡

02:04.800 --> 02:07.040
つまり､ プロジェクト項目の場合､

02:07.040 --> 02:22.550
最初に渡す要素は､ 何かをレンダリングする場所なので､ HTML U リスト､ つまり順序不同のリストということになります｡

02:22.550 --> 02:29.313
そして､ 2番目の要素はHTMLのLI要素になるので､ 具体的なリスト項目要素が作成されることになります｡

02:30.210 --> 02:38.210
ここでsuperを選択し､ プロジェクトアイテムがレンダリングされる要素のIdを指定する必要があります｡

02:38.210 --> 02:41.410
そしてもちろん､ そのIdは固定されていません｡

02:41.410 --> 02:47.480
なぜなら､ そのアイテムがレンダリングされる可能性のあるリストが2つあるからです｡

02:47.480 --> 02:51.760
コンストラクタでIdを取得し､

02:51.760 --> 02:59.140
そこでホストIdを取得します｡

02:59.140 --> 03:02.220
しかし､ 最初にスーパーに転送するのは､

03:02.220 --> 03:07.410
単一のリスト・アイテムのためのテンプレートIDです｡

03:07.410 --> 03:09.620
だから､ それをラップすればいいんです｡ 

03:09.620 --> 03:11.580
もちろん､ これは非常に単純なテンプレートです｡

03:11.580 --> 03:13.580
本当に必要かどうか議論することもできますし､

03:13.580 --> 03:16.380
単なるリストアイテムですから､ コード内で document

03:16.380 --> 03:18.920
create 要素を使って作成することもできます｡

03:18.920 --> 03:22.560
しかし､ テンプレートに依存するコンポーネントベース節を再利用できるようにするために､

03:22.560 --> 03:26.240
この方法を使用することにします｡

03:26.240 --> 03:29.680
つまり､ 単一プロジェクトは､ テンプレートID､

03:29.680 --> 03:34.500
ホストID､ そしてベース節コンストラクタに転送したいIDです｡

03:34.500 --> 03:37.150
では､ これを最初にレンダリングするのか､ 最後にレンダリングするのか､

03:37.150 --> 03:40.010
という問いにお答えします｡

03:40.010 --> 03:48.450
新しい項目はすべてリストの最後に追加されるべきですが､

03:48.450 --> 03:53.423
それは完全にあなた次第です｡

03:54.410 --> 04:01.580
そして､ 新しい要素のIdには､ 新しく作成された要素に割り当てられるべきIdを売ります｡

04:01.580 --> 04:03.760
プロジェクトごとに異なるので､

04:03.760 --> 04:09.860
外部からの情報提供も期待しています｡

04:09.860 --> 04:12.240
ここで､ 私はIdを取得することを期待しますが､

04:12.240 --> 04:15.060
それはすべて文字列であり､ 私はそれを転送するだけです｡

04:15.060 --> 04:17.820
これが今のコンストラクタですね｡ 

04:17.820 --> 04:22.250
これで､ このプロジェクトアイテムに属するプロジェクトを､ このプロジェクトアイテムクラスに格納することは､

04:23.500 --> 04:27.280
すべて理にかなっていると言えるでしょう｡

04:27.280 --> 04:33.770
また､ プロジェクトとは､ 上で作成したプロジェクトクラスに基づくプロジェクトのことです｡

04:33.770 --> 04:37.490
基本的にはこのようなデータで仕事をしています｡ 

04:37.490 --> 04:40.440
そして､ このレンダリングされたプロジェクトアイテムに属するプロジェクトを､

04:40.440 --> 04:44.000
そのプロジェクトアイテムクラスに格納したいのです｡

04:44.000 --> 04:47.650
したがって､ ここでは､ 例えば､ 私有地プロジェクトを追加することができますが､

04:47.650 --> 04:51.510
このようなプロジェクトタイプである必要があります｡

04:51.510 --> 04:58.090
コンストラクタでIdを取得し､ これを変更して実際にプロジェクトをこのように取得し､

04:58.090 --> 05:09.440
このプロジェクトはプロジェクトに等しいと言うだけです｡

05:09.440 --> 05:09.440
イド

05:09.440 --> 05:12.330
その設定は､ もう少し理にかなっていると思います｡ 

05:12.330 --> 05:14.710
ここで､ 必ずいくつかのメソッドを追加する必要があります｡

05:14.710 --> 05:17.760
もちろん､ configureメソッドも追加する必要があります｡

05:17.760 --> 05:22.300
拡張する基底クラスで必要とされる render content

05:22.300 --> 05:25.040
メソッドを追加する必要があります｡

05:25.040 --> 05:29.850
そして､ コンストラクタの最後には必ずconfigureとrender

05:29.850 --> 05:32.000
contentを呼び出します｡

05:32.000 --> 05:37.730
さて､ 設定についてですが､ 今すぐレンダリングしたい内容については何もする必要はありませんが､

05:37.730 --> 05:40.050
やるべきことは確実にあります｡

05:40.050 --> 05:42.710
このテンプレートは非常にシンプルなものですが､

05:42.710 --> 05:47.650
実はこれをインデックスのHTMLファイルでもう少し複雑に変更することができます｡

05:47.650 --> 05:50.850
例えば､ すべてのプロジェクトにh2タグを付け､

05:50.850 --> 06:03.290
その下にh3タグを付け､ さらにパラグラフを付けて､ プロジェクトのタイトル､ 担当者の数､ そして説明を出力することができます｡

06:03.290 --> 06:05.720
そして､ コンテンツのレンダリングを行うapp

06:05.720 --> 06:10.130
tsでは､ h2タグなど､ 要素内のさまざまな要素に手を伸ばして､

06:10.130 --> 06:14.440
コンテンツを挿入するだけです｡

06:14.440 --> 06:17.300
そこで､ レンダリングされた要素であるこの要素に手を伸ばせば､

06:17.300 --> 06:21.750
レンダリングされたLI要素にたどり着くことができます｡

06:21.750 --> 06:24.970
そして､ その中で､ これらの異なるものを選択する必要があるのです｡ 

06:24.970 --> 06:28.930
そこで､ クエリセレクタh2を使って､ ここにテキストの内容を設定します｡

06:28.930 --> 06:33.930
これに対して､ こう言いましょう｡  プロジェクトに参加しています｡  と入力すると､ そこにタイトルが表示されます｡ 

06:34.350 --> 06:36.470
もちろん､ ここでは感嘆符を付けて､

06:36.470 --> 06:42.563
テンプレートの一部であるため､ 確実に知っているこの要素を常に取得することを明確にすべきです｡

06:43.980 --> 06:46.870
さて､ 実際にはこれを繰り返すだけですが､

06:46.870 --> 06:49.170
今度はh3タグを探して､ そこに人数を出力したいと思います｡

06:49.170 --> 06:58.030
ただし､ peopleはプロパティ名ですが､ これを少し微調整します｡

06:58.030 --> 07:00.300
一方は数字で､

07:00.300 --> 07:04.110
もう一方は文字列です｡

07:04.110 --> 07:06.900
しかし､ それは主要な問題ではありません｡ 実は､ ここで単なる数字以上のものを出力するように調整したいのですが､

07:06.900 --> 07:12.590
それはまた今度お話しすることにします｡

07:14.960 --> 07:19.600
まず､ もう一回繰り返して､ ここの段落をクエリしてみましょう｡

07:19.600 --> 07:22.623
そして､ これをこのプロジェクトに等しく設定する｡  を記述しています｡ 

07:23.810 --> 07:27.140
さて､ これも後で微調整しますが､ 今はこのままにしておきましょう｡

07:27.140 --> 07:29.880
そして､ レンダリングされるプロジェクトアイテムができ､

07:29.880 --> 07:33.470
すべてのコンテンツが設定されるはずです｡

07:33.470 --> 07:35.460
そこで､ 今度はプロジェクト項目を使用する必要があります｡

07:35.460 --> 07:37.880
使用する場所は､ プロジェクトのリストをレンダリングするため､

07:37.880 --> 07:40.450
プロジェクトリストです｡

07:40.450 --> 07:48.260
そして､ 特にレンダリングプロジェクトで､ プロジェクトアイテムをレンダリングすることを確認する必要があります｡

07:48.260 --> 07:52.860
ここでは､ 割り当てられたプロジェクトの全項目を確認します｡

07:52.860 --> 07:55.870
割り当てられたプロジェクトは､ このプロパティで､

07:55.870 --> 07:58.960
プロジェクトのリストまたは配列を持っています｡

07:58.960 --> 08:02.330
このループの中で､ リスト項目を手動で作成したりする代わりに､

08:02.330 --> 08:13.740
それらをすべて取り除き､ 単純にここに新しいプロジェクト項目と､ 2つのプロジェクト項目と言うことにします｡

08:13.740 --> 08:16.110
ホストのアイデアを渡す必要があります｡

08:16.110 --> 08:22.730
これはもちろん､ ここのリスト項目に座っていたIdです｡

08:22.730 --> 08:25.990
だから基本的にはこれ｡  要素で構成されています｡  idは､ ホスト要素のIdです｡

08:25.990 --> 08:27.800
なぜなら､ 順序なしリストであるこの要素は､

08:27.800 --> 08:31.670
ホストになるはずだからです｡

08:31.670 --> 08:34.210
次に､ 2番目の引数はプロジェクトで､

08:34.210 --> 08:37.400
これは基本的にここでパージされる項目です｡

08:37.400 --> 08:40.950
つまり､ この定数は､ ループの内部で得られるものです｡ 

08:40.950 --> 08:42.790
そして､ 添付ファイルは､ プロジェクトアイテムの内部か､

08:42.790 --> 08:49.770
プロジェクトアイテムが継承するコンポーネントクラスのベース句の内部で行われることになります｡

08:49.770 --> 08:53.570
そして､ プロジェクト・アイテムのインスタンス化を行うだけでよいはずです｡ 

08:53.570 --> 09:00.890
これを保存して､ またこのコードに戻ると､ またこの入力があるわけです｡

09:00.890 --> 09:04.140
ほら､ これがレンダリングされるわけですが､ これがなかなかいい感じなんですよ｡ 

09:04.140 --> 09:10.220
もちろん､ この箇条書きはあまり好きではありません｡

09:10.220 --> 09:12.710
そして､ ここで無料になったからといって､

09:12.710 --> 09:15.590
すべてが超幸せになるわけではありません｡

09:15.590 --> 09:17.293
では､ どうすれば今すぐ解決できるのか｡ 

09:18.730 --> 09:21.380
箇条書きの部分を修正するために､ 内容を点検してみましょう｡ 

09:21.380 --> 09:28.060
そして､ 実際に表示されるのは､ リスト項目が順序なしリストの外側にレンダリングされている状態です｡

09:28.060 --> 09:29.600
だから､ 中身はないんです｡ 

09:29.600 --> 09:35.530
中に入っていればちゃんと動くのですが､ そこに引きずり込むことができないのです｡

09:35.530 --> 09:39.000
そのため､ 順序なしリストの内部でレンダリングされるようにする必要があります｡

09:39.000 --> 09:41.363
では､ なぜそうならないのか､ その理由を探ってみましょう｡ 

09:42.220 --> 09:50.430
なぜなら､ project itemでは､ base節のコンストラクタにfalseを渡しているからです｡

09:50.430 --> 09:53.660
ここでfalseを渡すということは､ 最初に挿入されないということであり､

09:53.660 --> 10:02.670
その結果､ attachでは､ 前に､ 値として､ 挿入されることになります｡

10:02.670 --> 10:05.660
しかし､ これは私たちが起こしたいことなので､

10:05.660 --> 10:08.360
問題はないでしょう｡

10:08.360 --> 10:14.970
まあ､ それでも問題は､ 当然ながらホストエレメントに挿入していることです｡

10:14.970 --> 10:19.460
そして､ 今一度､ プロジェクトリストのホスト要素とは何なのかを考えてみましょう｡

10:19.460 --> 10:20.900
プロジェクトをレンダリングするときに､

10:20.900 --> 10:34.180
新しいプロジェクトアイテムを作成し､ プロジェクトリストのレンダリングされた要素のIDをプロジェクトアイテムに転送します｡

10:34.180 --> 10:38.120
そうすると､ 1つのプロジェクトアイテムのホスト要素の考え方になりますね｡

10:38.120 --> 10:40.720
しかし､ ここでいう要素とは何でしょうか？

10:40.720 --> 10:43.770
この要素は､ ボックス内にある順序なしリストではなく､

10:43.770 --> 10:44.900
ボックスそのものであり､

10:44.900 --> 10:47.350
私たちのセクションです｡

10:47.350 --> 10:50.260
テンプレートを調べてみると､ プロジェクト・リスト・クラスで実際にレンダリングされるのは､

10:50.260 --> 10:53.810
このセクションです｡

10:53.810 --> 10:58.300
リストだけでなく､ ヘッダーも含むセクションです｡

10:58.300 --> 11:00.320
ここでは､

11:00.320 --> 11:05.070
実際にリストにIDを設定しているので､

11:05.070 --> 11:12.230
IDは存在します｡

11:12.230 --> 11:14.880
だから､ 素子そのものをイメージするのは､

11:14.880 --> 11:16.790
単純に正しくないんです｡

11:16.790 --> 11:20.580
むしろここでは､ 要素に順序なしリストの考えを得るべきであり､

11:20.580 --> 11:23.580
順序なしリストが存在することが確実に分かっているので､

11:23.580 --> 11:30.063
感嘆符を追加することでNULLチェックを省略することができるのです｡

11:30.930 --> 11:34.463
これで､ 新しい要素をここに追加すると､ 見栄えがよくなります｡

11:35.490 --> 11:37.680
適切なスタイルが適用されているので､

11:37.680 --> 11:39.920
箇条書きがなくなり､ LI､ リストアイテムは､

11:39.920 --> 11:46.320
ご覧のように､ 本当に順番なしリストの内部に追加されています｡

11:46.320 --> 11:49.390
さて､ それはそれとして､ 次は「5」の話です｡ なぜなら､

11:49.390 --> 11:52.990
ただ「5」を入れるだけでは､ 私のやりたいこととは違うからです｡

11:52.990 --> 11:56.143
もう少し有益な情報を出力してはどうだろうか｡ 
