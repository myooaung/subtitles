WEBVTT

00:02.090 --> 00:04.750
ナレーター: デコレーターでより高度なことをするためには､

00:04.750 --> 00:14.650
例えばクラスデコレーターやメソッドデコレーターのように､ 実は何かを返すことができるデコレーターもあることに注意する必要があります｡

00:14.650 --> 00:17.510
今は､ どこのデコトラでも何も返さない｡

00:17.510 --> 00:22.460
デコレータファクトリで返されるデコレータ関数のことではありません｡

00:22.460 --> 00:26.040
本当はデコレータ関数の中の戻り値を意味しているのですが､

00:26.040 --> 00:28.890
そのような値はどこにもないのです｡

00:28.890 --> 00:31.559
さて､ このWithTemplate関数､ つまりこのWithTemplateデコレータ関数に､

00:31.559 --> 00:36.930
このような戻り値を追加することができますね｡

00:36.930 --> 00:40.430
そして､ 何を返せるか､ TypeScriptが何を使えるかは､

00:40.430 --> 00:43.660
どの種類のデコレーターを扱うかに依存する｡

00:43.660 --> 00:44.990
ここでは､ クラスに追加されるデコレータを扱っていますが､

00:44.990 --> 00:53.800
このようなデコレータ関数では､ 古いコンストラクタを置き換える新しいコンストラクタ関数を返すことができます｡

00:53.800 --> 00:55.590
つまり､ デコレータを追加したクラスを置き換えるのはどちらか､

00:55.590 --> 00:58.330
と言うことです｡

00:58.330 --> 01:02.490
ここでは新しい関数､ 新しいコンストラクタ関数を返すことができます

01:02.490 --> 01:08.280
あるいは単に新しいクラスを返すこともできます なぜならクラス（classキーワード）を使うと

01:08.280 --> 01:13.360
このようなコンストラクタ関数を作成するための構文解析を行うことができるからです

01:13.360 --> 01:22.250
ここで作成したクラスは名前を持つ必要はありませんが ここで得たコンストラクタは拡張できますし拡張すべきです｡

01:22.250 --> 01:28.060
ここでやっているのはデコレータ関数で､

01:28.060 --> 01:30.910
新しいクラスを返しています｡

01:30.910 --> 01:50.520
これはコンストラクタ関数の構文上の糖分で､ 元のコンストラクタ関数をベースにしたコンストラクタ関数を返しているのです｡

01:50.520 --> 01:53.670
そして､ この中に新しい機能を追加することができます｡ 

01:53.670 --> 01:56.716
たとえば､ ここでいくつか名前を変えなければなりませんが､

01:56.716 --> 02:00.340
新しいコンストラクタ関数を追加して､ 混乱を避けるために､

02:00.340 --> 02:04.040
ここで取得するコンストラクタの名前を変更します｡

02:04.040 --> 02:06.640
このデコレーターを追加したクラスを､ ここでは

02:06.640 --> 02:09.620
originalConstructor と名付け､

02:12.889 --> 02:15.690
ここにすべてコピーします｡

02:15.690 --> 02:18.950
そして今度はこのコンストラクタ関数の代わりに super

02:18.950 --> 02:20.853
を呼び出して元のコンストラクタ関数を内部から呼び出す必要があります｡

02:20.853 --> 02:33.630
なぜなら､ 他のクラスを継承するクラスにコンストラクタ関数を追加した場合､ 結局のところ､ ここでやっていることは super を呼び出すことになるからです｡

02:33.630 --> 02:36.108
そして今､ この中では､ どんなロジックでも書くことができます｡ 

02:36.108 --> 02:42.782
例えば､ このテンプレートレンダリングのロジックをデコレーター関数から､

02:42.782 --> 02:49.020
ここで返す新しいコンストラクター関数に移動させることができます｡

02:49.020 --> 02:50.960
繰り返しますが､ ここではクラスを作成しており､

02:50.960 --> 02:55.833
最終的にはこのロジックを含むコンストラクタ関数を作成するだけであることに留意してください｡

02:56.670 --> 03:01.367
そこで今度は､ クラスを置き換えることにしました｡

03:01.367 --> 03:04.298
新しいクラスでデコレータを追加したコンストラクタ関数では､

03:04.298 --> 03:21.340
古いロジックも実行されますが､ 新しいロジックも追加されるので､ ここでオブジェクトを本当にインスタンス化した場合にのみ､ テンプレートが実際にDOMにレンダリングされるはずです｡

03:21.340 --> 03:22.890
そして､ このデコレータ関数が実行されるのは､

03:22.890 --> 03:29.620
常にというわけではありません｡ このデコレータ関数は､ クラスを定義するとすぐに発生します｡

03:29.620 --> 03:31.010
ここで少し手を加えて､ 元のコンストラクタを呼び出さず､

03:31.010 --> 03:37.380
代わりにこれにアクセスするようにしました｡

03:37.380 --> 03:37.380
という名前を付けて､

03:37.380 --> 03:42.750
作成するインスタンスの name プロパティの値を取得します｡

03:42.750 --> 03:47.750
今､ 下界では､ 型が正しくないということでちょっとした苦情が来ています｡

03:47.750 --> 03:51.330
これを解決するには､ デコレータ関数をジェネリック関数にして､

03:51.330 --> 04:01.668
型を取得し､ これをオリジナルのコンストラクタの型として設定し､ これが基本的にコンストラクタ関数であることを明確にします｡ そして､

04:01.668 --> 04:05.780
オブジェクト型という特別な型を割り当て､ 新しいプロパティ､

04:05.780 --> 04:17.760
これはもちろん予備の名前ですが､ 最終的にこれは新規作成できるオブジェクトであることを TypeScript に伝えます｡

04:17.760 --> 04:19.690
つまり､ これがコンストラクタ関数となり､

04:19.690 --> 04:24.380
newキーワードで呼び出して新しいオブジェクトを生成する関数となるわけです｡

04:24.380 --> 04:27.410
そしてこの新しい関数､ この新しいメソッドは､

04:27.410 --> 04:30.660
Tがベースとするオブジェクトが持つ､

04:30.660 --> 04:44.000
任意の数の引数を取得します｡ ここではレストパラメータを使って､ 好きなだけ引数を受け取れるようにしています｡

04:45.420 --> 04:46.430
新しい関数を追加すると､

04:46.430 --> 04:49.063
最終的にここにオブジェクトが返されます｡

04:50.140 --> 04:53.500
残りのパラメータの定義もコンストラクタにコピーして､

04:53.500 --> 04:57.640
このコンストラクタがすべての引数を受け取ることができるようにし､

04:57.640 --> 05:00.260
基本的に､ ここに渡したい引数を指定して

05:00.260 --> 05:04.380
Person をインスタンス化できるようにします｡

05:04.380 --> 05:09.279
ここで必要な引数は､ 元のコンストラクタ関数で指定します｡

05:09.279 --> 05:11.600
そして､ 唯一の問題は､ そのような name

05:11.600 --> 05:14.021
プロパティが存在するかどうかわからないということです｡

05:14.021 --> 05:16.250
正しくは､ この WithTemplate

05:16.250 --> 05:19.639
デコレータをどのクラスに追加するかわからないので､ 追加したクラスに

05:19.639 --> 05:23.951
name プロパティが存在するかどうかわかりません｡

05:23.951 --> 05:27.140
しかし､ TypeScriptにTのベースとなるオブジェクトを伝えるだけで､

05:27.140 --> 05:35.530
これを解決することができます｡ つまり､ 元のコンストラクタ関数は､ 単に任意のオブジェクトを生成するのではなく､ 実際には文字列型のnameプロパティを持つオブジェクトを生成し､

05:35.530 --> 05:41.140
これは正しいのです｡

05:41.140 --> 05:46.250
WithTemplateデコレータはクラスに追加され､ そのクラスはnameプロパティを持つことになります｡

05:46.250 --> 05:50.740
なぜなら､ このデコレーターはこの基準を満たさないクラスに追加しようとするからです｡

05:50.740 --> 05:55.543
しかし､ ここではこの基準を満たします｡

05:55.543 --> 05:58.790
ここでargsを使っていないのでコンパイルしようとするとエラーが出ますが､

05:58.790 --> 06:02.660
これを_に変更することでtypescriptにargsを使っていないことを伝え､

06:02.660 --> 06:06.230
これを無視するようにできます｡

06:06.230 --> 06:10.678
これは有効なパラメータ名で､ typescriptがパラメータとして受け取る特別な名前に過ぎません｡

06:10.678 --> 06:15.260
私はそれを受け取り､ 受け入れる必要がありますが､ それをパラメータとして使うことはありません｡

06:15.260 --> 06:18.273
これですべてがコンパイルされ､ リロードすると､ ほら､

06:19.440 --> 06:22.420
このページにはまだMaxが表示されています｡

06:22.420 --> 06:25.480
面白いのは､ Personをインスタンス化するコードを削除して､

06:25.480 --> 06:30.740
Personクラスを見つけるだけで､ インスタンス化しないようにコメントアウトすると､

06:30.740 --> 06:36.890
リロード時に画面上にMaxが表示されないことです｡

06:36.890 --> 06:39.467
すべてのデコレーターはまだ実行されますが､

06:39.467 --> 06:42.410
画面にはもう何も表示されません｡

06:42.410 --> 06:43.243
その理由は､

06:43.243 --> 06:46.340
デコレータの機能をさらに強化して､

06:46.340 --> 06:55.350
新しい値､ つまりこの場合は新しいコンストラクタ関数を返すことができるようにしたからです｡

06:55.350 --> 06:57.205
クラス・デコレーターの場合

06:57.205 --> 07:00.780
これは新しいコンストラクタ関数､ つまり新しいクラスです｡

07:00.780 --> 07:04.300
説明したように､ これはコンストラクタ関数のための単なる構文上の糖分で､

07:04.300 --> 07:06.750
したがってこのコンストラクタ関数は､

07:06.750 --> 07:12.160
元のクラス､ 元のコンストラクタ関数に取って代わります｡

07:12.160 --> 07:15.220
さて､ ここでsuperを呼び出したので､

07:15.220 --> 07:17.610
元の関数を保存します｡

07:17.610 --> 07:19.690
元のクラスを保存し､ ここで初期化したことは基本的にそのまま起こります｡

07:19.690 --> 07:22.540
なぜなら､ 置き換えるコンストラクタでも同様に初期化を行い､

07:22.540 --> 07:27.480
元のクラスを拡張しているからです｡

07:27.480 --> 07:30.420
そこで､ 元のクラスにあったものをすべて保存します｡ 

07:30.420 --> 07:31.550
そんなことをしなくてもいいのですが､

07:31.550 --> 07:32.670
その元データを失いたくないので､

07:32.670 --> 07:35.560
ここでやっているのです｡

07:35.560 --> 07:36.850
しかし､ 裏側では､ このクラスを新しいカスタムクラスで置き換えて､

07:36.850 --> 07:45.600
このクラスがインスタンス化されたときに実行されるべき追加のロジックを追加できるようにしています｡

07:45.600 --> 07:54.660
そして今､ 突然､ クラスが定義されたときではなく､ クラスがインスタンス化されたときに実行されるロジックを追加することができるようになったのです｡

07:54.660 --> 07:57.150
このように､ デコレーターで何ができるかを理解すれば､

07:57.150 --> 08:04.480
その力を存分に発揮できることを示す最初の例となるはずです｡

08:04.480 --> 08:06.800
また､ 単に関数として定義するだけでなく､

08:06.800 --> 08:09.970
因子関数で定義することもできます｡

08:09.970 --> 08:12.600
クラス・デコレータのようなデコレータでは､

08:12.600 --> 08:14.400
デコレータを追加したもの

08:14.400 --> 08:25.711
(この例ではクラス) を､ 古いクラスを実装しつつ新しいカスタムロジックを追加した新しいクラスで置き換えるために､ 何かを返すこともできます｡

08:25.711 --> 08:28.004
そして､ これをコメントアウトして戻すと､

08:28.004 --> 08:31.570
古いクラスを置き換える､ あるいは拡張して置き換える独自のクラスで､

08:31.570 --> 08:35.793
再びMaxを画面にレンダリングすることができます｡
