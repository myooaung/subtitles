WEBVTT

00:01.850 --> 00:03.270
ผู้สอน: ตอนนี้เรารู้เกี่ยวกับพื้นฐานของ

00:03.270 --> 00:06.760
TypeScript และความแตกต่างของมันแล้ว และทั้งหมดนี้เกี่ยวข้องกับ

00:06.760 --> 00:11.410
JavaScript เรามาเจาะลึกลงไปอีกสักหน่อยถึงประเภทหลักต่างๆ ที่ TypeScript

00:11.410 --> 00:14.148
รู้จัก

00:14.148 --> 00:18.500
ตัวเลขคือประเภทที่เราเห็นที่นี่ และอย่างที่ฉันอธิบาย ไม่มีความแตกต่างระหว่างจำนวนเต็มเช่น

00:18.500 --> 00:25.640
5 ในที่นี้กับทศนิยมหรือสองเท่า เนื่องจากจะถูกเรียกในภาษาโปรแกรมอื่นๆ เช่น 2

00:25.640 --> 00:25.640
8 ที่นี่

00:25.640 --> 00:28.440
แท้จริงแล้วใน JavaScript และเช่นเดียวกันใน TypeScript

00:28.440 --> 00:30.810
ตัวเลขทั้งหมดจะลอยตามค่าเริ่มต้น

00:30.810 --> 00:33.270
ดังนั้นสำหรับ JavaScript และสำหรับ TypeScript

00:33.270 --> 00:36.770
ด้วย จึงไม่มีความแตกต่างระหว่างห้าแบบนี้กับห้าแบบนี้

00:36.770 --> 00:38.640
มันคือเลขเดียวกันโดยพื้นฐานแล้ว

00:38.640 --> 00:42.720
ตอนนี้ นอกจากตัวเลขแล้ว เรายังมีแกนประเภทอื่นๆ ด้วย

00:42.720 --> 00:46.350
และนั่นจะเป็นสตริง ดังนั้นข้อความ และบูลีน

00:46.350 --> 00:47.800
ลองดูที่สิ่งเหล่านั้นด้วย

00:47.800 --> 00:50.650
เราเห็นการกระทำทั้งหมดที่นี่ในคำสั่ง if นี้แล้ว

00:50.650 --> 00:53.291
ซึ่งเราได้เรียนรู้ว่าซ้ำซ้อนเล็กน้อย

00:53.291 --> 00:55.971
อย่างไรก็ตามนี่จะเป็นสตริง

00:55.971 --> 01:00.389
นอกจากนี้ ห้าตัวที่มีเครื่องหมายคำพูดจะเป็นสตริงเพราะเป็นข้อความ

01:00.389 --> 01:03.851
และผลลัพธ์ เช่น ของการเปรียบเทียบตรงนี้

01:03.851 --> 01:05.170
จะเป็นบูลีน

01:05.170 --> 01:10.950
โอเปอเรเตอร์นี้ เครื่องหมายเท่ากับสามเท่าหรือโอเปอเรเตอร์การเท่ากันแบบลบตรงนี้

01:10.950 --> 01:13.640
ซึ่งสร้างค่าจริงหรือเท็จ

01:13.640 --> 01:14.720
และแน่นอน เราสามารถสร้างการตรวจสอบ

01:14.720 --> 01:18.850
innerRef แบบไดนามิกได้ ซึ่งเราจะทำบ่อยๆ

01:18.850 --> 01:23.379
หรือเราเริ่มต้นตัวแปรด้วยค่าจริงหรือเท็จ ลองทำทั้งสองอย่างที่นี่

01:23.379 --> 01:27.509
ที่นี่ เราสามารถเพิ่มค่าคงที่ใหม่ "printResult"

01:27.509 --> 01:29.990
และตั้งค่านี้เป็นจริงเช่น

01:29.990 --> 01:31.320
และเพื่อให้ชัดเจนจริงๆ

01:31.320 --> 01:33.130
นี่อาจเป็นตัวแปรเช่นกัน

01:33.130 --> 01:34.460
ไม่จำเป็นต้องเป็น const

01:34.460 --> 01:36.030
มันสามารถเป็นตัวแปรที่คุณจะสร้างโดยให้ใน

01:36.030 --> 01:37.730
JavaScript

01:37.730 --> 01:39.870
แต่เนื่องจากฉันไม่ได้วางแผนที่จะเปลี่ยนที่นี่

01:39.870 --> 01:40.703
ฉันจะใช้ค่าคงที่

01:40.703 --> 01:43.670
และเราสามารถส่งค่านี้เป็นพารามิเตอร์ตัวที่สามตรงนี้

01:43.670 --> 01:46.960
สมมติว่าเราส่ง "printResult" ซึ่งถือว่าเป็นจริงที่นี่

01:46.960 --> 01:53.160
ตอนนี้เราได้รับข้อผิดพลาดทันที เนื่องจากฟังก์ชันเพิ่มของเราไม่สนับสนุนอาร์กิวเมนต์ที่สาม

01:53.160 --> 01:55.560
เราเห็นว่า "คาดว่าจะมีการโต้แย้ง 2 ข้อ แต่ได้ 3 ข้อโต้แย้ง"

01:55.560 --> 01:58.920
ดังนั้น เราต้องแน่ใจว่าเราสนับสนุนข้อโต้แย้งที่สาม

01:58.920 --> 02:03.920
และที่นั่น เราสามารถเพิ่มพารามิเตอร์ "showResult"

02:03.940 --> 02:05.920
คุณสามารถตั้งชื่อว่า "printResult" ที่นี่ได้เช่นกัน

02:05.920 --> 02:07.910
ฉันจะใช้ "showResult" เพื่อหลีกเลี่ยงความสับสนเกี่ยวกับการตั้งชื่อ

02:07.910 --> 02:12.930
แต่โดยทางเทคนิคแล้ว ชื่อทั้งสองนี้จะไม่ขัดแย้งกัน

02:12.930 --> 02:14.320
ในที่นี้ขอตั้งชื่อว่า "showResult"

02:14.320 --> 02:19.500
และฉันต้องการให้แน่ใจว่านี่เป็นประเภทบูลีนโดยตั้งค่าเป็นบูลีน

02:19.500 --> 02:22.109
อีกครั้งโดยการเพิ่มเครื่องหมายทวิภาคหลังพารามิเตอร์ที่นี่

02:22.109 --> 02:25.120
จากนั้นเพิ่มชื่อประเภท

02:25.120 --> 02:28.100
ตอนนี้ฟังก์ชันนี้ยอมรับสิ่งนี้ และตอนนี้สิ่งที่เราทำได้คือเราเพิ่มเครื่องหมาย

02:28.100 --> 02:36.480
if ตรงนี้และกาเครื่องหมาย "if showResult" หากเป็นจริง แน่นอนว่าเราสามารถเปรียบเทียบกับจริงได้

02:36.480 --> 02:37.628
แต่อย่างที่คุณทราบใน

02:37.628 --> 02:41.990
JavaScript คุณสามารถส่งค่าจริงหรือค่าเท็จได้ที่นี่

02:41.990 --> 02:43.970
และจาวาสคริปต์จะประเมินค่านั้น

02:43.970 --> 02:47.389
และถ้าค่านี้ให้ค่าจริงหรือค่าความจริงโดยทั่วไป เราจะทำให้มันอยู่ในบล็อก

02:47.389 --> 02:48.989
if

02:48.989 --> 02:50.011
มิฉะนั้นเราจะไม่

02:50.011 --> 02:52.900
และสมมติว่าเราสร้างมันขึ้นมาที่นี่ แล้วฉันต้องการ

02:52.900 --> 02:55.429
"ปลอบใจ ล็อก n1 บวก n2"

02:55.429 --> 02:58.581
มิฉะนั้น ในกรณีอื่น หากเราไม่เข้าไปที่นั่น

02:58.581 --> 03:00.549
ฉันขอคืนสิ่งนี้

03:00.549 --> 03:04.760
ดังนั้น นี่คือฟังก์ชันที่บางครั้งส่งคืนค่าและบางครั้งไม่ส่งคืนค่า

03:04.760 --> 03:08.309
แต่ส่งออกทันที

03:08.309 --> 03:11.550
ตอนนี้คุณสามารถโต้เถียงได้ ถ้าคุณต้องการเขียนฟังก์ชันแบบนั้น

03:11.550 --> 03:14.310
ซึ่งคาดเดาไม่ได้หรืออาจทำงานโดยไม่คาดคิด

03:14.310 --> 03:18.349
ถ้าคุณผ่านค่าจริงตรงนี้

03:18.349 --> 03:19.990
แต่นี่เรากำลังทำมันอยู่

03:19.990 --> 03:22.090
ดังนั้นฟังก์ชันนี้จะส่งคืนในบางครั้งเท่านั้น

03:22.090 --> 03:27.830
บางครั้งมันจะไม่ส่งคืน แต่เพียงบันทึกบางอย่างลงในคอนโซลแทน

03:27.830 --> 03:31.120
ตรงนี้ เราสามารถเรียก add แบบนี้ได้จริงๆ

03:31.120 --> 03:33.640
และไม่ต้องเก็บมันไว้ในผลลัพธ์

03:33.640 --> 03:37.570
และไม่ต้องคอนโซล บันทึกผลลัพธ์เนื่องจากเมื่อตั้งค่า "printResult"

03:37.570 --> 03:39.550
เป็น true ให้เพิ่มตัวเอง

03:39.550 --> 03:41.869
ดังนั้นฟังก์ชันจะพิมพ์ผลลัพธ์เอง

03:41.869 --> 03:47.880
ดังนั้น หากตอนนี้เราบันทึกและคอมไพล์แอปของเราใหม่

03:47.880 --> 03:47.880
ts ที่นี่ด้วยคำสั่ง tsc

03:47.880 --> 03:52.600
เมื่อเสร็จสิ้น หน้าเว็บจะโหลดซ้ำ และเรายังคงเห็นผลลัพธ์ของเราที่นี่

03:52.600 --> 03:54.677
แต่ตอนนี้มันมาจากสายหก

03:54.677 --> 03:58.980
และถ้าเราดูแล้ว บรรทัดที่หกคือภายในฟังก์ชันจริงๆ

03:58.980 --> 03:59.891
นี่คือบูลีน

03:59.891 --> 04:02.429
สมมติว่าเราต้องการปรับแต่งเอาต์พุต

04:02.429 --> 04:06.190
ใน if ที่นี่ เรามีค่าคงที่ "resultPhase" ที่นี่โดยที่เราพูดว่า

04:06.190 --> 04:10.181
"Result is" เครื่องหมายทวิภาคและช่องว่างสีขาว

04:10.181 --> 04:14.205
และเราส่งต่อสิ่งนั้นด้วย "resultPhase" ที่นี่

04:14.205 --> 04:17.410
ถ้าอย่างนั้นเราก็คาดหวังได้ว่านี่เป็นข้อโต้แย้งที่นี่เช่นกัน

04:17.410 --> 04:20.750
วลีซึ่งจะให้สตริงไปป์โดยการเพิ่มเครื่องหมายทวิภาค

04:20.750 --> 04:22.291
จากนั้นสตริงคือชื่อของประเภท

04:22.291 --> 04:26.469
และตอนนี้เราสามารถใช้วลีนั้นเพื่อส่งออกเป็นส่วนหนึ่งของเอาต์พุตผลลัพธ์ของเรา

04:26.469 --> 04:31.193
หากเรากำลังพิมพ์ผลลัพธ์โดยตรงในฟังก์ชัน

04:31.193 --> 04:34.789
ดังนั้น ตรงนี้ เราสามารถมี "วลีบวก n1 บวก n2"

04:34.789 --> 04:37.440
และถ้าเราทำเช่นนั้นและคอมไพล์ใหม่โดยทำซ้ำคำสั่งนั้น

04:37.440 --> 04:41.720
เราจะเห็นว่าวลีนี้เป็นส่วนหนึ่งของผลลัพธ์

04:41.720 --> 04:48.141
แต่ตอนนี้เรายังแนะนำข้อผิดพลาดเก่าอีกครั้งเพราะฉันมีสตริงซึ่งฉันรวมกับตัวเลขสองตัว

04:48.141 --> 04:53.240
ทุกอย่างถูกแปลงเป็นสตริงที่นี่ และนั่นไม่ใช่สิ่งที่ฉันต้องการ

04:53.240 --> 04:57.708
เพื่อหลีกเลี่ยงปัญหานี้ ในฟังก์ชันนี้ เราสามารถเพิ่มตัวแปรผลลัพธ์ได้ที่นี่

04:57.708 --> 05:02.027
หรือค่าคงที่ของผลลัพธ์และเก็บผลลัพธ์ของเราไว้ที่นี่

05:02.027 --> 05:04.530
สิ่งนี้จะถูกจัดการด้วยวิธีทางคณิตศาสตร์

05:04.530 --> 05:07.990
เพราะมีเพียงตัวเลขเท่านั้นที่เกี่ยวข้อง จากนั้น ที่นี่

05:07.990 --> 05:11.430
เราสามารถรวมสิ่งนั้นเข้ากับวลีหรือเพียงแค่ส่งกลับ

05:11.430 --> 05:15.160
และตอนนี้ เนื่องจากสิ่งนี้ไม่เคยคำนวณโดยตรงร่วมกับสตริง

05:15.160 --> 05:17.029
นี่จึงเป็นตัวเลขเสมอ

05:17.029 --> 05:21.140
และใช่แล้ว ที่นี่ ตัวเลขนี้รวมกับสตริงนี้จะถูกแปลงเป็นสตริง

05:21.140 --> 05:25.548
แต่เนื่องจากการคำนวณทางคณิตศาสตร์เสร็จสิ้นก่อนหน้านั้น เราจะได้ผลลัพธ์ที่ถูกต้อง

05:25.548 --> 05:30.181
ตอนนี้ถ้าเราทำซ้ำแล้วคอมไพล์ใหม่ เราจะได้ผลลัพธ์ที่ถูกต้อง

05:30.181 --> 05:33.050
ตอนนี้สิ่งเหล่านี้คือประเภทข้อมูลหลักที่ใช้งานจริง

05:33.050 --> 05:35.541
ตอนนี้ ตรวจสอบให้แน่ใจว่าเราเข้าใจอย่างถ่องแท้ถึงวิธีการกำหนดประเภท

05:35.541 --> 05:41.343
และเหตุใดเราจึงไม่กำหนดประเภทอย่างชัดเจนลงไปที่นั่น
