WEBVTT

00:02.150 --> 00:03.930
教师：所以我们添加了第一个POST请求,

00:03.930 --> 00:06.120
我们能够创建TODO｡

00:06.120 --> 00:07.250
现在我们有更多的路线｡ 

00:07.250 --> 00:10.170
我们还得到了一个为我们创建的所有TODOS服务的路由｡ 

00:10.170 --> 00:11.750
现在请注意, 每次您更改并保存代码时,

00:11.750 --> 00:14.160
您的TODOS都将重置, 因为这会重新启动您的服务器,

00:14.160 --> 00:21.330
并丢失存储在内存中的所有内容, 而我们只在内存中管理我们的TODOS｡

00:21.330 --> 00:23.560
这只是我们在虚拟应用程序中的一些东西,

00:23.560 --> 00:24.930
在真正的应用程序中,

00:24.930 --> 00:28.200
你当然会将其存储在真正的数据库中, 从那里获取它,

00:28.200 --> 00:30.280
等等, 因此它会生存下来｡

00:30.280 --> 00:35.060
尽管如此, 在这里我们可以创建一个新函数getTodos,

00:35.060 --> 00:38.030
它将是一个RequestHandler,

00:38.030 --> 00:42.330
因此您不必分别设置所有参数的类型｡

00:42.330 --> 00:46.120
然后在那里, 我只想返回一个响应, 在那里我返回一些JSON数据,

00:46.120 --> 00:52.420
我在那里有我的待办事项, 我只想访问我的TODOs数组, 并将其发送回客户端,

00:52.420 --> 00:56.530
这已经可以了｡

00:56.530 --> 00:57.810
当然, 你可以调整一下,

00:57.810 --> 00:59.640
也许你想有一个不同的逻辑,

00:59.640 --> 01:03.120
也许你想先对TODOS排序, 或者类似的东西, 但是最简单的形式已经是我们需要的了,

01:03.120 --> 01:10.530
它返回我们的TODOS, 所以是一个非常简单的函数｡

01:10.530 --> 01:13.240
在TODOS路由中, 我们现在只需要连接这个｡ 

01:13.240 --> 01:17.680
因此, 让我们也从控制器导入getTodos,

01:17.680 --> 01:20.640
并将其与此路由连接｡

01:20.640 --> 01:25.250
这样, 如果我们现在保存它, 我们就可以看到它的运行｡

01:25.250 --> 01:29.860
如果我们返回并创建一个新的请求, 一个GET请求,

01:29.860 --> 01:34.860
发送到http：//localhost：3000/todos/,

01:39.400 --> 01:41.410
我们会得到一个空数组,

01:41.410 --> 01:44.400
为什么呢？

01:44.400 --> 01:48.010
我说过, 只要我们更改代码, TODOS就会被清除,

01:48.010 --> 01:51.470
因此服务器会重新启动, 所以我们现在应该创建一个新的TODO,

01:51.470 --> 01:54.110
而不重新启动服务器｡

01:54.110 --> 01:57.360
如果我们创建了TODO, 现在得到了TODOS,

01:57.360 --> 02:01.770
我们会看到创建的TODO的ID为, 序列号为9811等等,

02:01.770 --> 02:04.380
这里也是如此｡

02:04.380 --> 02:05.960
这已经奏效了｡ 

02:05.960 --> 02:08.980
现在, 既然我们已经开始了, 让我们也来修补和删除,

02:08.980 --> 02:12.680
当然, 你可以自由地提出一些自己的逻辑｡

02:12.680 --> 02:16.130
最后, 现在你有了所有你需要的构建块｡

02:16.130 --> 02:18.480
当然, 我们现在也会一起做｡ 

02:19.390 --> 02:21.570
现在, 在修补程序请求中,

02:21.570 --> 02:24.350
让我们添加一个新的控制器函数｡

02:24.350 --> 02:29.350
导出const updateTodo, 它是RequestHandler类型,

02:30.660 --> 02:34.680
应该保存一个我们已经知道的格式的函数｡

02:34.680 --> 02:40.630
在那里, 目标是从传入的请求中提取有关新TODO的数据,

02:40.630 --> 02:44.140
然后用新数据更新TODO｡

02:44.140 --> 02:47.240
现在, 请注意, 作为我们路线的一部分,

02:47.240 --> 02:48.900
我们有一个动态段｡

02:48.900 --> 02:51.140
我们有这个id段｡ 

02:51.140 --> 02:54.610
因此, 我们可以从URL中提取这些内容,

02:54.610 --> 02:58.750
可以提取此动态段的具体值｡

02:58.750 --> 03:07.987
因此, 在这里, 对于传入的请求, 您可以从请求参数中获取todoId｡

03:07.987 --> 03:07.987
ID､ . id, 因为这是我在这里选择的名称｡ 

03:07.987 --> 03:13.060
如果您在此处选择了不同的名称, 则必须在此处使用不同的名称｡

03:13.060 --> 03:15.810
现在, 我们在这里得不到任何支持, 对吧？

03:15.810 --> 03:18.410
参数的类型为any｡ 

03:18.410 --> 03:20.450
因为类型可以解析这个String,

03:20.450 --> 03:23.400
并理解其中的内容.

03:23.400 --> 03:25.460
因此 , 为了 获得 更 好 的 类型 支持

03:25.460 --> 03:28.920
, 我们 实际 上 可以 利用 这里 的 RequestHandler

03:28.920 --> 03:32.880
是 一 个 泛型 类型 , 我们 可以 添加 尖 括号 , 基本 上 告诉 TypeScript

03:32.880 --> 03:35.880
哪些 参数 将 具有 ｡

03:35.880 --> 03:37.800
我们只需将其设置为一个对象,

03:37.800 --> 03:42.180
现在就有了URL中所有父对象的键值映射｡

03:42.180 --> 03:43.830
例如, 我们有一个ID参数,

03:43.830 --> 03:46.730
它最后保存一个String｡

03:46.730 --> 03:48.610
这是我们可以在这里添加的东西, 现在你会看到我们得到了自动完成,

03:48.610 --> 03:52.560
TypeScript知道这将是一个字符串｡

03:52.560 --> 03:55.520
所以使用这个泛型类型会更好｡ 

03:55.520 --> 03:58.640
现在, 我们有了ID, 我们还需要请求主体中的一些内容,

03:58.640 --> 04:03.560
确切地说, 我们需要请求主体中的新文本｡

04:03.560 --> 04:08.130
所以updatedText可以从请求主体中检索,

04:08.130 --> 04:11.700
现在我们再次使用类型转换, 以明确主体中将有一个text属性,

04:11.700 --> 04:16.910
并且该属性的类型为String｡

04:16.910 --> 04:19.750
然后检索文本｡ 

04:19.750 --> 04:22.373
现在我们可以更新上面的TODOS数组中的TODO｡ 

04:23.830 --> 04:28.710
为此, 让我们查找要更新的TODO的索引｡

04:28.710 --> 04:30.808
todoIndex, 通过访问TODOS,

04:30.808 --> 04:36.090
并使用findIndex, 我们可以在TODOS数组中的每一项上运行一些逻辑｡

04:36.090 --> 04:38.060
在这里我们查看每个待办事项,

04:38.060 --> 04:40.010
如果待办事项id等于我们这里的待办事项Id,

04:40.010 --> 04:44.300
我们就知道这是我们要更新的待办事项.

04:44.300 --> 04:47.140
现在如果因为某种原因它应该是-1, 这意味着我们没有找到那个TODO,

04:47.140 --> 04:52.610
所以如果它本质上小于0, 我们就知道出了问题, 在这种情况下, 我会抛出一个新的错误,

04:52.610 --> 04:59.630
我说, Could not find todo！

04:59.630 --> 05:06.130
这应该会触发我们默认的错误处理中间件｡

05:06.130 --> 05:08.633
现在如果我们通过了if检查, 我们就找到了TODO,

05:09.870 --> 05:15.040
然后我们可以简单地将TODOS数组中这个索引处的TODO更新为一个新的TODO,

05:15.040 --> 05:18.960
在那里我们保留旧的id｡

05:18.960 --> 05:23.270
所以我们访问TODOS的地方是todoIndex｡  id, 所以我们访问旧的ID并存储它,

05:23.270 --> 05:27.030
但这里的文本是我设置的,

05:27.030 --> 05:31.713
当然我们不会像这样分配它｡

05:32.870 --> 05:34.570
但是我们在这里设置的文本现在是updatedText｡ 

05:34.570 --> 05:41.340
这会取代此处的TODO, 之后我们可以传回回应,

05:41.340 --> 05:45.280
例如Updated消息｡

05:45.280 --> 05:47.053
然后我们将updatedTodo附加到传出的响应中,

05:47.990 --> 05:55.090
并将其设置为等于TODOS todoIndex, 它现在保存了新的值｡

05:55.090 --> 05:59.090
这是我们在更新逻辑中称之为do的东西, 当然, 是一些伪代码,

05:59.090 --> 06:02.430
因为我们仍然在内存中使用这个TODOS数组,

06:02.430 --> 06:09.060
但它显示了我们如何在这里使用TypeScript, 这是主要的东西｡

06:09.060 --> 06:11.100
现在让我们来试试这个更新功能｡ 

06:11.100 --> 06:13.620
为此, 我们可以回到Postman, 最后,

06:13.620 --> 06:16.260
现在我想发送一个PATCH请求, 因为在路由中,

06:16.260 --> 06:19.960
我们正在等待此路由的修补程序请求｡

06:19.960 --> 06:26.490
说到这里, 我们也许应该先将此路由连接到控制器函数｡

06:26.490 --> 06:28.850
因此, 让我们转到routes文件并导入updateTodo,

06:28.850 --> 06:33.420
然后在此处建立此连接｡

06:33.420 --> 06:35.590
之后, 我们就可以继续发送此请求｡ 

06:35.590 --> 06:38.570
现在回到Postman, PATCH是我们要发送的内容,

06:38.570 --> 06:41.890
然后是http：//localhost：3000/todos,

06:41.890 --> 06:49.430
现在是TODO的概念, 我们要将其更新为URL的一部分｡

06:49.430 --> 06:50.573
现在, 由于我们保存了一些东西,

06:51.500 --> 06:54.970
由于我们保存了一些更改, 我们的服务器重新启动, 所以所有的TODOS将丢失无论如何｡

06:54.970 --> 07:01.150
因此, 让我们首先重新发送POST请求以创建新的TODO｡

07:01.150 --> 07:02.450
这里我们得到了该TODO的ID｡ 

07:02.450 --> 07:05.170
现在, 我们可以将此ID添加到此URL｡ 

07:05.170 --> 07:11.780
我还将添加一个JSON类型的主体, 在其中设置要发送到服务器的新数据｡

07:11.780 --> 07:20.970
现在请记住, 在我们的更新控制器中, 我要在传入的请求主体中查找一个名为text的字段｡

07:20.970 --> 07:24.580
因此, 我们应该在发送的JSON数据中再次提供这些信息｡

07:24.580 --> 07:26.690
在一个月内完成这门课程,

07:26.690 --> 07:29.440
这可能是我们的新课文｡

07:29.440 --> 07:31.520
如果我们现在发送此消息, 则会看到它已更新｡ 

07:31.520 --> 07:37.180
如果我现在得到所有的TODO, 我们也会看到仍然只有一个TODO,

07:37.180 --> 07:39.430
但只是简单地改变了文本｡

07:39.430 --> 07:41.623
现在, 我们可以更新TODO了｡ 

07:42.950 --> 07:46.470
让我们再检查一下如果我有一个不存在的id会发生什么,

07:46.470 --> 07:48.780
例如, 通过删除这里的最后一位数字,

07:48.780 --> 07:53.430
然后我得到, 在我的错误响应类型500中找不到todo｡

07:53.430 --> 07:57.670
所以这看起来也不错｡ 

07:57.670 --> 07:59.660
作为最后一步, 让我们添加一个函数来删除TODO｡ 

07:59.660 --> 08:03.800
因此 , 在 controllers 文件 夹 中 , 我 将 导出 一 个 名 为 deleteTodo

08:03.800 --> 08:07.210
的 常量 , 它 的 类型 为 RequestHandler ｡

08:07.210 --> 08:14.040
同样, 我们得到了请求, 响应, 然后是下一个函数｡

08:14.040 --> 08:20.270
在这里, 现在我想找到TODO并简单地删除它｡

08:20.270 --> 08:21.543
为此, 我们实际上可以复制此代码,

08:22.380 --> 08:25.090
其中我们获取TODO的ID, 然后获取索引｡

08:25.090 --> 08:29.360
只需去掉我们提取更新文本的那一行, 因为对于DELETE请求,

08:29.360 --> 08:32.210
将没有请求主体, 但我们需要TODO的id,

08:32.210 --> 08:37.400
它是URL路由的一部分｡

08:37.400 --> 08:40.340
然后我们找到索引, 一旦我们得到了索引, 我们就可以转到TODO,

08:40.340 --> 08:43.530
调用splice方法, 并删除todoIndex处的todo,

08:43.530 --> 08:47.350
并且只删除该todo｡

08:47.350 --> 08:51.620
然后我们可以发送回一个响应, 我们说,

08:51.620 --> 08:54.040
待办事项已删除！ 就像那样｡ 

08:54.040 --> 08:58.490
这可能是我们的删除逻辑｡ 

08:58.490 --> 08:59.380
现在是连接的时候了,

08:59.380 --> 09:01.760
所以在routes文件夹中, 让我们从控制器TODO导入deleteTodo,

09:01.760 --> 09:04.560
并将其连接到下面的位置｡

09:04.560 --> 09:07.440
连接后, 如果我们现在保存它, 我们需要再次添加一个TODO,

09:08.340 --> 09:09.963
因为每次服务器重新启动时都会清除所有TODO,

09:11.120 --> 09:14.370
所以它就在这里｡

09:14.370 --> 09:16.720
复制身份证｡ 

09:16.720 --> 09:20.550
现在让我们发送DELETE请求｡ 

09:20.550 --> 09:22.680
因此, 在这里有一个新的DELETE请求, 发送到http：/localhost：3000/todos/this

09:22.680 --> 09:24.980
id｡

09:24.980 --> 09:27.160
不需要添加几何体｡ 

09:27.160 --> 09:32.160
单击“发送”, 它就会生效｡ 

09:32.800 --> 09:34.880
如果我再次发送它, 我们会收到找不到错误,

09:34.880 --> 09:37.180
因为我们刚刚删除了它｡

09:37.180 --> 09:41.570
如果我们得到了所有的TODOS, 那应该是一个空数组｡

09:41.570 --> 09:42.723
现在可以使用了, 这基本上是一个CRUD功能,

09:42.723 --> 09:49.550
在这个简单的Node和Express应用程序中添加了TypeScript｡

09:49.550 --> 09:52.940
当然, 这是一个相当简单的应用程序, 但它已经向我们展示了TypeScript的一些用法｡

09:52.940 --> 09:56.060
它向我们展示了我们编写的代码, 如果您学习完本课程的其余部分, 您应该会觉得这些代码很熟悉,

09:56.060 --> 10:02.000
并且我们使用了您在那里学到的所有功能｡

10:02.000 --> 10:04.750
正如在反应部分, 这是所有重要的｡ 

10:04.750 --> 10:07.610
您也可以在这里使用您学到的关于TypeScript的任何内容,

10:07.610 --> 10:11.520
因为它最终会被编译为常规JavaScript代码,

10:11.520 --> 10:14.990
然后我们会提供这些代码｡
