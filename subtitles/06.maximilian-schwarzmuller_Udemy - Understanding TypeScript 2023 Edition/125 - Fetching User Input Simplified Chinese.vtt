WEBVTT

00:02.150 --> 00:06.180
教师：我们可以收集标题输入值, 并将其打印到控制台,

00:06.180 --> 00:10.160
但当然, 这不是最终的想法｡

00:10.160 --> 00:13.940
相反, 我们的想法是收集所有的输入值,

00:13.940 --> 00:15.420
快速验证它们,

00:15.420 --> 00:17.890
然后用它们做一些事情｡

00:17.890 --> 00:21.860
为此, 我将添加另一个新方法, 另一个私有方法,

00:21.860 --> 00:28.530
因为我将只从类内部调用它, 这就是gatherUserInput方法｡

00:28.530 --> 00:30.460
名字完全由你决定｡ 

00:30.460 --> 00:33.240
我的想法是在这里调用这个方法｡ 

00:33.240 --> 00:35.230
在我们阻止了默认设置之后,

00:35.230 --> 00:40.870
它基本上应该访问我们在这里的所有输入, 在那里收集用户输入, 验证它,

00:40.870 --> 00:43.060
然后返回它｡

00:43.060 --> 00:45.950
这里, 我得到了userInput,

00:45.950 --> 00:50.090
它可以是一个元组, 其中包含标题､ 描述和人物,

00:50.090 --> 00:53.810
作为自由元组值｡

00:53.810 --> 00:55.510
事实上, 我喜欢这个主意｡ 

00:55.510 --> 00:57.800
因此, 我们已经在这里定义了一个返回类型｡ 

00:57.800 --> 00:59.880
返回类型为元组｡ 

00:59.880 --> 01:02.620
现在您还记得元组是如何定义的吗？

01:02.620 --> 01:05.630
元组的类型是如何定义的？

01:05.630 --> 01:08.620
不是字符串, 是方括号｡ 

01:08.620 --> 01:12.260
这意味着返回的是一个字符串数组｡ 

01:12.260 --> 01:14.550
相反, 我想说的是, 我返回了一个数组,

01:14.550 --> 01:21.510
其中包含X个元素, 这些元素都是这三种类型｡

01:21.510 --> 01:23.650
为此, 你在这里设置返回类型,

01:23.650 --> 01:27.160
两个方括号, 然后在方括号内, 你添加不同的元素,

01:27.160 --> 01:30.240
和元素类型｡

01:30.240 --> 01:32.900
例如, 字符串､ 字符串和数字｡ 

01:32.900 --> 01:37.130
也就是说, 这个方法返回一个元组, 它有三个元素,

01:37.130 --> 01:38.510
其中第一个元素是字符串,

01:38.510 --> 01:40.300
第二个元素是字符串,

01:40.300 --> 01:44.080
第三个元素实际上是一个数字.

01:44.080 --> 01:48.540
现在我们可以在这个方法中添加一些逻辑来使它成为真的｡

01:48.540 --> 01:57.210
因此, 我们首先从这个titleInputElement中获取输入的标题｡

01:57.210 --> 01:57.210
的值｡ 

01:57.210 --> 01:58.340
我们可以重复这一点｡ 

01:58.340 --> 02:05.100
我们还需要从这个descriptionInputElement中输入的课程描述｡

02:05.100 --> 02:05.100
值,

02:05.100 --> 02:12.440
以及enteredPeople金额, 或者只从这个peopleInputElement输入enteredPeople｡

02:12.440 --> 02:13.870
现在我把它存储在常量中,

02:13.870 --> 02:17.640
这样我就不用总是重复这些长表达式了｡

02:17.640 --> 02:19.370
现在, 我们可以验证这一点｡ 

02:19.370 --> 02:24.850
一个简单的验证是检查是否输入了标题｡

02:24.850 --> 02:24.850
trim,

02:24.850 --> 02:27.610
所以去掉了X开头和结尾的宽空格｡

02:27.610 --> 02:35.350
长度等于零, 如果输入, 则为Description｡

02:35.350 --> 02:35.350
修剪长度等于零,

02:35.350 --> 02:37.570
或者如果输入了People,

02:37.570 --> 02:44.380
则为｡ 修整长度等于零｡

02:44.380 --> 02:48.410
这将检查是否没有输入为空｡ 

02:48.410 --> 02:51.860
现在, 它并没有检查我们可能想要检查的所有内容｡

02:51.860 --> 02:57.160
我们不会检查输入的人数是否为正数｡

02:57.160 --> 03:00.170
我们无法设置最小长度｡ 

03:00.170 --> 03:02.190
我们必须在这里添加越来越多的条件,

03:02.190 --> 03:06.820
虽然我们可以做到这一点, 但这并不是一个真正可扩展的解决方案｡

03:06.820 --> 03:09.110
如果我们在应用程序中的某些部分还需要验证用户输入,

03:09.110 --> 03:14.440
那么我们总是必须重复长if语句｡

03:14.440 --> 03:21.960
因此, 我将很快提出一个更智能的验证解决方案或更可扩展的验证解决方案｡

03:21.960 --> 03:23.780
现在, 我们可以这样｡ 

03:23.780 --> 03:26.190
你们已经可以考虑这个问题了,

03:26.190 --> 03:32.220
当然在这节课之后, 停下来想一想如何把它外包到一个单独的验证函数中,

03:32.220 --> 03:38.350
这个函数是可配置的, 以及类型对你有什么帮助｡

03:38.350 --> 03:44.040
肯定有很多可能的方法, 我会在下一堂课中和你们分享我的方法｡

03:44.040 --> 03:45.620
但是在我们到达那里之前,

03:45.620 --> 03:48.350
让我们用这个简单的方法, 如果所有这些条件都满足的话,

03:48.350 --> 03:52.130
做一些事情｡

03:52.130 --> 03:53.620
现在如果我们把它放到if块中,

03:53.620 --> 03:57.350
我们知道至少有一个验证失败了, 然后我们可以通过alert, 在这里我们说Invalid

03:57.350 --> 04:01.833
input, please try again｡

04:03.450 --> 04:04.910
否则, 如果我们没有成功,

04:04.910 --> 04:11.310
我们知道我们有一个有效的输入, 否则, 我想返回我的元组｡

04:11.310 --> 04:14.170
所以在这里, 我想返回输入的标题,

04:14.170 --> 04:19.660
输入的描述, 以及输入的人｡

04:19.660 --> 04:20.630
现在你可以告诉虽然,

04:20.630 --> 04:21.850
类型组是不高兴的,

04:21.850 --> 04:25.370
因为输入的人应该是一个数字, 而不是文本｡

04:25.370 --> 04:32.350
实际上, 默认情况下, 从input元素的value属性中提取的所有内容都是文本｡

04:32.350 --> 04:34.520
要把它转换成一个数字,

04:34.520 --> 04:38.060
我们可以调用parseFloat, 比如,

04:38.060 --> 04:40.610
或者简单地在它前面加一个加号,

04:40.610 --> 04:42.850
这样就会把它转换成一个数字,

04:42.850 --> 04:48.910
但是类型组还是不满意, 因为我们不总是返回元组｡

04:48.910 --> 04:50.830
这部分呢？

04:50.830 --> 04:52.310
如果我们把它放到if块中,

04:52.310 --> 04:53.510
我们会显示一个警告,

04:53.510 --> 04:55.820
但不会返回元组｡

04:55.820 --> 04:59.810
我们可以做很多事情来代替｡ 

04:59.810 --> 05:03.460
我们可以什么都不返回, 就像这样｡ 

05:03.460 --> 05:06.320
或者, 我们可以抛出一个错误｡ 

05:06.320 --> 05:08.360
然后, 我们实际上不会返回任何东西,

05:08.360 --> 05:11.100
但在这种情况下, 我们会抛出一个错误｡

05:11.100 --> 05:12.820
现在, 我不想在这里抛出一个错误,

05:12.820 --> 05:18.090
因为我真的不想实现错误处理, 所以我要做的就是添加一个return语句,

05:18.090 --> 05:20.100
当然这不是元组｡

05:20.100 --> 05:23.110
所以实际上, 这里的返回类型是一个元组,

05:23.110 --> 05:25.923
或者它实际上是未定义的｡

05:27.320 --> 05:32.550
但是, 正如您所了解的, 您不应该在这里使用undefined作为函数的返回类型｡

05:32.550 --> 05:34.040
请改用void｡ 

05:34.040 --> 05:35.410
它几乎是一样的,

05:35.410 --> 05:37.040
但是只对函数有效,

05:37.040 --> 05:46.930
这告诉TypeScript这个函数至少有一个分支不像这个函数那样返回任何值｡

05:46.930 --> 05:49.160
这里我们当然也使用联合类型,

05:49.160 --> 05:51.240
因为我们有两种可能性｡

05:51.240 --> 05:53.170
我们可能什么都不返回,

05:53.170 --> 05:55.660
或者实际上返回一个元组｡

05:55.660 --> 05:59.370
现在, 我们有了gatherUserInput和userInput,

05:59.370 --> 06:04.130
因为要么是未定义的, 要么就是那个元组｡

06:04.130 --> 06:09.620
现在, 在我们继续改进验证之前, 让我们在userInput的基础上进行构建｡

06:09.620 --> 06:12.480
当我们在下面收集userInput时, 我们现在有了userInput,

06:12.480 --> 06:17.050
现在我们可以检查它是否是一个元组｡

06:17.050 --> 06:22.620
现在的问题是在运行时, 我们没有办法检查它是否是一个元组｡

06:22.620 --> 06:25.200
没有可以使用的执行严修｡ 

06:25.200 --> 06:28.560
没有可以检查的元组类型｡ 

06:28.560 --> 06:31.020
我们也不能检查userInput的类型是否等于tuple,

06:33.803 --> 06:40.050
因为Vanilla JavaScript中不存在这种情况｡

06:40.050 --> 06:41.850
例如, 字符串确实存在,

06:41.850 --> 06:44.950
但元组不是JavaScript类型｡

06:44.950 --> 06:47.020
所以要检查它是否是元组,

06:47.020 --> 06:50.990
我们必须记住元组在最后只是被擦除｡

06:50.990 --> 06:52.750
它们在TypeScript中是特殊的,

06:52.750 --> 06:55.940
但是一旦我们进入JavaScript领域, 它们就被删除了,

06:55.940 --> 07:04.470
因为元组的元素数量和元素类型是固定的, 这种想法实际上只存在于TypeScript中｡

07:04.470 --> 07:05.930
在运行时, 我们需要检查的是它是否是数组,

07:05.930 --> 07:15.180
为此, 我们可以在JavaScript中使用数组对象, isArray方法.

07:15.180 --> 07:17.500
这是VanillaJavaScript内置的一个方法,

07:17.500 --> 07:20.290
它允许我们检查这里是否是一个数组｡

07:20.290 --> 07:23.200
我们知道它要么是未定义的要么是元组｡ 

07:23.200 --> 07:26.000
元组是一个数组, 所以如果返回true,

07:26.000 --> 07:27.400
我们就得到了元组｡

07:27.400 --> 07:31.010
在这里, 我们可以使用结构化, 例如从用户输入中获取标题､

07:31.010 --> 07:37.720
描述和人物, 然后对这些输入进行处理｡

07:37.720 --> 07:39.230
比如现在,

07:39.230 --> 07:42.623
控制台｡ 日志标题､ 说明和人员｡ 

07:43.980 --> 07:46.060
如果我们做了所有这些并保存了它,

07:46.060 --> 07:47.950
它编译时就没有错误了, 如果我们回到这里,

07:47.950 --> 07:53.050
我点击像这样的项目, 我会得到无效的输入｡

07:53.050 --> 07:54.580
如果我输入Hello, 仍然会得到它,

07:54.580 --> 07:56.950
因为我们没有得到描述｡

07:56.950 --> 07:58.890
这是描述｡ 

07:58.890 --> 08:00.180
当然我们还是可以理解的,

08:00.180 --> 08:02.940
但是如果我现在也把一些东西输入到人的体内, 这就可以了,

08:02.940 --> 08:05.220
我们在这里打印出来｡

08:05.220 --> 08:09.330
这当然是朝着正确方向迈出的一步｡ 

08:09.330 --> 08:10.990
我们还没有完全做到这一点｡ 

08:10.990 --> 08:13.330
正如我所说, 我们可以改进验证｡ 

08:13.330 --> 08:20.070
在此之前, 我只想做一件事, 我想在单击“添加项目”后清除所有输入｡

08:20.070 --> 08:22.440
所以我想再次清空所有输入｡ 

08:22.440 --> 08:25.290
现在, 我们可以添加一个新的私有方法, clearInput或clearInputs,

08:25.290 --> 08:32.740
在那里, 我们可以设置这个titleInputElement｡

08:32.740 --> 08:32.740
等于空字符串的值,

08:36.200 --> 08:38.980
并对其他输入重复该操作｡

08:38.980 --> 08:41.960
这里有描述输入元素, 这里有人输入元素,

08:41.960 --> 08:48.190
现在, 如果我们调用它.

08:48.190 --> 08:48.190
clear在此处输入,

08:48.190 --> 08:51.730
我们应该确保表单在提交后即被清除｡

08:51.730 --> 08:52.870
如果我们再试一次,

08:52.870 --> 08:57.740
在这里输入一些内容, 您会看到它会打印在这里, 并且表单会被清除｡

08:57.740 --> 09:00.720
这样, 我对我们的处理方式总体上很满意,

09:00.720 --> 09:03.300
但现在我想改进验证, 并以一种更可重用､

09:03.300 --> 09:06.970
更可伸缩的方式编写它｡

09:06.970 --> 09:07.840
正如我提到的,

09:07.840 --> 09:10.320
你可以先自己做｡

09:10.320 --> 09:12.580
在下一节课中, 我们会一起做｡
