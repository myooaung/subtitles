WEBVTT

00:02.130 --> 00:03.970
教师：首先, 我们可以在这里用npm

00:03.970 --> 00:10.940
start启动我们的开发服务器, 这是一个我们应该继续运行的进程, 因为它将监视我们的文件是否有更改｡

00:10.940 --> 00:13.270
如果有什么变化, 也就是说, 如果你专门保存了一个变化,

00:13.270 --> 00:22.500
它会将代码类型重新编译为JavaScript, 将JSX重新编译为JavaScript, 最后, 构建你的react应用程序, 并在本地主机3000上提供它,

00:22.500 --> 00:27.630
目前, 你在那里看不到太多｡

00:27.630 --> 00:29.430
您可以在Dev控制台中看到,

00:29.430 --> 00:31.800
由于此处的输出, 它似乎可以正常工作｡

00:31.800 --> 00:36.700
当然, 你看不到太多, 因为我们在应用程序中没有渲染任何内容｡

00:36.700 --> 00:36.700
现在是tsx｡ 

00:36.700 --> 00:38.170
这当然会改变｡ 

00:38.170 --> 00:39.420
现在, 让我们编写一些代码,

00:39.420 --> 00:43.580
或者分析一下我们得到的结果｡

00:43.580 --> 00:46.750
在索引中｡  txx我们没有什么特别的, 对吗？

00:46.750 --> 00:49.060
这是常规JavaScript代码｡ 

00:49.060 --> 00:52.950
在应用程序 tsx, 我们看到了这个类型分配,

00:52.950 --> 00:57.980
我们可以看到我们将这个奇怪的类型分配给了App｡

00:57.980 --> 01:02.480
现在, 如果我们暂时忽略这种类型, 那么App中实际存储的是什么呢？

01:02.480 --> 01:04.840
一个函数, 一个箭头函数,

01:04.840 --> 01:07.290
但它仍然是一个正则函数｡

01:07.290 --> 01:12.570
为什么这个类型不起作用, 或者为什么它不是我们学过的函数类型之一？

01:12.570 --> 01:14.030
当然, 这是在引擎盖下面,

01:14.030 --> 01:16.450
但这是react提供的类型,

01:16.450 --> 01:21.070
现在, 重要的是react类型包提供的类型｡

01:21.070 --> 01:26.070
如果进入节点模块, 我们会在这里和那里看到@types文件夹, 我们会看到很多类型,

01:26.390 --> 01:28.470
我们还可以在这里看到react类型,

01:28.470 --> 01:32.600
所有react-dom类型｡

01:32.600 --> 01:35.840
最后, 可以说, 这个类型是从react

01:35.840 --> 01:39.340
types文件夹中隐式自动导入的｡

01:39.340 --> 01:40.870
现在, 这是什么类型？

01:40.870 --> 01:44.490
FC简单地代表功能组件｡ 

01:44.490 --> 01:47.570
还有一个更长的形式, 你可以用它来代替｡

01:47.570 --> 01:49.240
完全是同一种类型｡ 

01:49.240 --> 01:51.090
另一个只是一个快捷方式,

01:51.090 --> 01:54.300
它只是定义了我们在应用程序中存储的必须是函数,

01:54.300 --> 02:00.550
但是一个在react中符合函数组件条件的函数｡

02:00.550 --> 02:02.840
当然, 你也可以编写基于类的组件,

02:02.840 --> 02:05.760
因此, 这里也有一个经典的组件, 然后,

02:05.760 --> 02:12.720
你必须在其中存储一个类而不是函数, 但我们在本课程中将使用函数组件.

02:12.720 --> 02:14.670
这是一个函数组件, 因为它是一个返回JSX的函数,

02:14.670 --> 02:20.850
这就是react中创建函数组件的方式｡

02:20.850 --> 02:24.180
如果我临时删除这个return语句, 我们可能会在这里得到一个错误,

02:24.180 --> 02:28.800
如果我试图保存它, 它想编译它｡

02:28.800 --> 02:32.440
我们会得到一个错误, 因为现在, 我们告诉TypeScript,

02:32.440 --> 02:34.960
在这里, 我们要存储一个函数组件,

02:34.960 --> 02:42.800
我们存储的是一个普通函数, 而不是返回JSX或任何其他符合反应元素条件的函数｡

02:42.800 --> 02:44.440
因此 , 这 将 是 无效 的 ,

02:44.440 --> 02:45.810
我们 必须 修复 它 ｡

02:45.810 --> 02:50.360
在这里, 我们已经可以看到TypeScript是如何对我们的项目进行一些改进的｡

02:50.360 --> 02:52.500
它为我们提供了额外的类型安全,

02:52.500 --> 02:55.420
并确保我们不能在某种情况下运行, 例如,

02:55.420 --> 02:58.353
我们构建了一个无效的组件｡

02:59.200 --> 03:03.230
顺便说一下, 如果忘记这个return语句似乎不现实,

03:03.230 --> 03:11.070
那么考虑一下您正在构建一个具有多个if语句和不同return语句的更大组件｡

03:11.070 --> 03:14.370
你可能在if语句的一个分支中忘记了一个,

03:14.370 --> 03:17.010
那么TypeScript肯定会救你一命,

03:17.010 --> 03:19.130
比运行时早一点给你警告,

03:19.130 --> 03:23.710
否则在某些情况下它可能会崩溃｡

03:23.710 --> 03:25.620
这是TypeScript在做一些事情,

03:25.620 --> 03:27.740
但是关于对话就到此为止了｡

03:27.740 --> 03:28.690
让我们来构建一些东西,

03:28.690 --> 03:31.670
我想在这里构建一个相对简单的应用程序, 一个待办事项应用程序,

03:31.670 --> 03:39.480
非常经典, 但一个待办事项应用程序, 它允许我们练习一些使用TypeScript反应的核心概念｡

03:39.480 --> 03:41.270
因此, 在接下来的课程中,

03:41.270 --> 03:44.363
让我们真正开始第一个自定义组件｡
