WEBVTT

00:02.130 --> 00:02.963
ナレーター：そのためにまた､

00:02.963 --> 00:06.690
何度も何度も使ったダミーのプロジェクト設定に戻りました｡

00:06.690 --> 00:08.260
そこで､ NPM starts を実行して､

00:08.260 --> 00:10.190
その開発サーバーを立ち上げることができます｡

00:10.190 --> 00:13.690
そして､ 別のターミナルウィンドウでサーバーを動かしながら､

00:13.690 --> 00:15.260
TSC dash Wを実行して､

00:15.260 --> 00:17.419
TypeScriptのコンパイル処理を開始し､

00:17.419 --> 00:21.540
それを継続的に実行しています｡

00:21.540 --> 00:24.560
もちろん､ 何もないので空のページができましたが､

00:24.560 --> 00:29.480
これでアプリのTSファイルで遊んで､ ジェネリックを使い始めることができます｡

00:29.480 --> 00:44.410
ジェネリックを理解するには､ TypeScriptに組み込まれているデフォルトの型を見てみるのが一番わかりやすいと思います｡

00:44.410 --> 00:46.900
例えば､ 名前の配列があるとします｡ 

00:46.900 --> 00:50.370
マックスとマニュアルとでも言いましょうか｡ 

00:50.370 --> 00:51.620
そこで､ 2つの名前を取得します｡

00:51.620 --> 00:57.210
もちろん､ 名前の定数の型は文字列の配列です｡

00:57.210 --> 01:02.460
さて､ 実はこれ､ 2つのタイプが合体していると考えることができます｡

01:02.460 --> 01:09.310
オブジェクトにさまざまなプロパティがあり､ それぞれのプロパティに異なる型が格納されていることがあるのと同じです｡

01:09.310 --> 01:16.440
配列は常に異なるデータを含むもので､ この場合は文字列を含むものである｡

01:16.440 --> 01:20.230
実際に配列型､ ただの配列があるわけですが､ ここで名前を外してカットすると､

01:20.230 --> 01:29.140
TypeScriptはこれを任意のデータが入ったanything型の配列と推論することがわかりますね｡

01:29.140 --> 01:32.690
確かにTypeScriptは配列の型を把握しています｡ 

01:32.690 --> 01:35.280
つまり､ これは配列であるべきなのですが､

01:35.280 --> 01:39.900
このように指定すると､ TypeScriptにはこのような配列型が存在するにもかかわらず､

01:39.900 --> 01:43.570
エラーになるのです｡

01:43.570 --> 01:48.710
しかし､ これは汎用型であり､ 1つの型引数を必要とすることがわかる｡

01:48.710 --> 01:50.950
そして今､ それは今までにないものです｡ 

01:50.950 --> 01:53.870
ジェネリックタイプについては､ これまで聞いたことがありませんでした｡ 

01:53.870 --> 01:58.120
さて､ この奇妙な記法だが､ TypeScriptでこのようなものを見かけたら､

01:58.120 --> 02:01.060
それはジェネリック型を扱っているのだ｡

02:01.060 --> 02:12.920
汎用型とは､ ある種の他の型とつながっていて､ その他の型がどのような型であるかについて非常に柔軟性がある型のことです｡

02:12.920 --> 02:14.130
難しそうですか？

02:14.130 --> 02:16.820
さて､ 配列の例に戻りましょう｡ 

02:16.820 --> 02:19.380
ここに配列を格納したいことは分かっています｡ 

02:19.380 --> 02:24.610
つまり､ 配列自体が型になり得るわけで､ それ自体がすでに型を構成しているデータのリストである､

02:24.610 --> 02:26.730
と言えるでしょう｡

02:26.730 --> 02:32.200
オブジェクトがそれ自体で型であるように､ たとえどのデータがそこに入るのかがまだ分からなくても｡

02:32.200 --> 02:34.490
つまり､ 配列はそれ自体が一つの型なのです｡ 

02:34.490 --> 02:39.860
しかし､ 配列はもちろんそこにある種のデータを格納します｡

02:39.860 --> 02:44.810
さて､ 配列の型自体は､ そこに格納されているデータの種類を気にしません｡

02:44.810 --> 02:48.150
配列型は､ 文字列のリスト､ 数値のリスト､ オブジェクトのリスト､

02:48.150 --> 02:52.430
混合データのリストのどれを格納するかは気にしません｡

02:52.430 --> 02:54.500
配列の型は本当に気にしませんが､

02:54.500 --> 03:02.960
少なくとも何らかの情報を取得することは気にします｡

03:02.960 --> 03:05.870
何も指定しないよりはマシです｡ 

03:05.870 --> 03:08.330
さて､ これは配列の型､ そこに格納されるデータの型､

03:08.330 --> 03:11.430
そして角括弧を定義する方法の1つです｡

03:11.430 --> 03:14.620
もうひとつの方法は､ まったく同じ型を作成するために､

03:14.620 --> 03:17.630
配列と角括弧を使用することです｡

03:17.630 --> 03:20.030
そして､ この角括弧の間に､

03:20.030 --> 03:24.140
配列に入れるべきデータの種類を指定します｡

03:24.140 --> 03:31.330
例えば文字列で､ ここはこの型を定義するのと100％同じです｡

03:32.030 --> 03:37.730
もちろん､ ここでユニオン型を使用して､ この配列には文字列や数値が格納されていることを示すこともできますし､

03:37.730 --> 03:42.970
型について何も言いたくない場合は､ 任意の型を使用することもできます｡

03:42.970 --> 03:44.330
つまり､ これはTypeScriptに組み込まれた汎用的な型､

03:44.330 --> 03:46.900
ジェネリック型なのです｡

03:46.900 --> 03:56.810
他の型に接続された型｡ TypeScriptでどの型がより良いサポートをしてくれるかを知りたい｡

03:56.810 --> 04:01.510
例えば､ ここに格納するものが文字列であることが分かっていれば､

04:01.510 --> 04:09.410
配列の要素にアクセスするたびに､ 文字列を扱うことができることが分かるからです｡

04:09.410 --> 04:12.260
例えば､ これらの文字列メソッドをすべて呼び出しても､

04:12.260 --> 04:18.220
TypeScriptは文句を言わない｡

04:18.220 --> 04:20.410
それがジェネリックタイプの考え方です｡ 

04:20.410 --> 04:26.780
ある型､ この場合は配列型ですが､ この配列型で提供されるデータの型に関する追加情報を提供すれば､

04:26.780 --> 04:29.040
よりうまく機能したり､ まったく機能しなかったりするかもしれません｡

04:29.040 --> 04:36.590
もちろん､ 配列型は単なる一例にすぎません｡

04:36.590 --> 04:42.130
TypeScriptに組み込まれているもう一つの汎用型がpromise型である｡

04:42.130 --> 04:45.470
さて､ プロミスはJavaScriptの機能ですね｡ 

04:45.470 --> 04:46.970
TypeScriptの機能ではありません｡ 

04:46.970 --> 04:49.437
JavaScriptでプロミスを作成することができます｡

04:49.437 --> 04:53.870
プロミスが何であるか分からない場合のために､ リンクを貼っておきます｡

04:53.870 --> 04:58.150
プロミスはnew promiseで作成することができます｡ 

04:58.150 --> 05:05.870
繰り返しますが､ これはJavaScriptに組み込まれたクラスであるコンストラクタ関数で､

05:05.870 --> 05:12.580
プロミスのコンストラクタ関数は1つの引数を取り､ それ自体は関数です｡

05:12.580 --> 05:17.790
これで､ ブラウザのJavaScriptから自動的に渡されるようになる｡

05:17.790 --> 05:22.400
そして､ プロミスの中で､ 例えばタイマーを設定し､ そのタイマーのコールバック関数で､

05:22.400 --> 05:28.140
外側のプロミスを解決することができるのです｡

05:28.140 --> 05:30.140
このコールバック関数の中で､

05:30.140 --> 05:34.823
resolveを呼び出して､ これは完了したと言うことができます｡

05:36.500 --> 05:41.020
そうすると, このプロミスは新しいオブジェクト, プロミス・オブジェクトを生成し,

05:41.020 --> 05:43.860
プロミス定数に格納されます．

05:43.860 --> 05:47.700
さて､ このプロミス定数ですが､ 実は特定の型を持っています｡ 

05:47.700 --> 05:49.470
これはpromise型で､

05:49.470 --> 05:51.130
この角括弧があるのは､

05:51.130 --> 05:56.130
このpromiseが最終的に何かに解決されるからです｡

05:56.480 --> 05:58.930
ここでunknownと表示されているのは､ TypeScriptが､

05:58.930 --> 06:03.880
実際にはここで文字列に解決されることを完全に理解できていないためです｡

06:03.880 --> 06:05.870
しかし､ それゆえ､ これは約束であり､

06:05.870 --> 06:11.450
最終的に文字列を生成すると言うことができます｡

06:11.450 --> 06:14.030
主な型はpromiseですが､ promiseは配列と同じように､

06:14.030 --> 06:18.380
他の型と一緒に使うことができます｡

06:18.380 --> 06:23.350
配列はデータを格納するため､ 他の型を使用し､

06:23.350 --> 06:25.640
プロミスは最終的にある型のデータを返すため､

06:25.640 --> 06:32.940
他の型と一緒に動作します｡

06:32.940 --> 06:34.470
さて､ もう一度､ なぜそれが役に立つのか｡ 

06:34.470 --> 06:37.550
この余分な型情報はなぜ役に立つのでしょうか？

06:37.550 --> 06:40.350
もし､ ここにプロミス型があれば､ それは許されませんが､

06:40.350 --> 06:41.430
もし､ promise

06:41.430 --> 06:44.770
of type anythingと言えば､ 基本的にof typesと同じで､

06:44.770 --> 06:51.280
何が返ってくるかについての情報を持っていなければ､ ジェネリック型は分かりません｡

06:51.280 --> 06:53.340
もちろん､ この約束でも､ すべての約束と同じように使うことができますし､

06:53.340 --> 06:55.750
最終的には何らかのデータを得ることができますが､

06:55.750 --> 06:59.770
そのデータについては何もわかりません｡

06:59.770 --> 07:02.500
例えば文字列のメソッドを呼び出すことができないんだ｡ 

07:02.500 --> 07:04.850
まあ､ この場合はどれでもいいので､ できるのですが､

07:04.850 --> 07:07.590
特にTypeScriptのサポートは受けられません｡

07:07.590 --> 07:11.313
また､ いろいろと試してみましたが､ これは絶対にうまくいきません｡ 

07:12.170 --> 07:13.800
例えば､ ここで数値を返しても､

07:13.800 --> 07:19.390
TypeScriptはこのプロミスが最終的に生成するデータについての情報を持っていないので､

07:19.390 --> 07:22.640
ここで文字列メソッドを呼び出すことができる｡

07:22.640 --> 07:26.280
ジェネリックタイプでは､ その情報をTypeScriptに渡します｡

07:26.280 --> 07:30.240
このプロミスが最終的に文字列やこの場合は数値を返すことをTypeScriptに伝えると､

07:30.240 --> 07:34.940
TypeScriptはここで警告を出すことができる｡

07:34.940 --> 07:37.390
もしこれを保存しようとすると､ このプロミスは最終的に数字を生成し､

07:37.390 --> 07:40.870
その上でsplitを呼び出すことができることを知っているので､

07:40.870 --> 07:44.092
エラーが発生します｡

07:44.092 --> 07:48.010
そのため､ ジェネリックタイプを使用することで､ より良い型安全性を得ることができます｡ 

07:48.010 --> 07:50.510
そのため､ 汎用的な情報をどう使うかについては､

07:50.510 --> 07:52.720
非常に柔軟性があります｡

07:52.720 --> 07:57.140
配列はどのデータを格納するか､ プロミスはどのデータを返すかを知っています｡

07:57.140 --> 08:02.140
自分でジェネリッククラスや関数を作る場合は､ そことは全く違うことをするかもしれません｡

08:02.140 --> 08:04.570
しかし最終的には､ より複雑なクラスや関数で､

08:04.570 --> 08:06.970
入力されたデータに対して何かを行う場合､

08:06.970 --> 08:10.640
データが特定の型であることはあまり気にせず､

08:10.640 --> 08:27.590
入力されたデータの型情報を保存して､ 汎用型を扱うときにTypeScriptのサポートをより良くしたい場合に､ 汎用型は追加の型情報を得るのに役立つのだ｡

08:27.590 --> 08:30.450
つまり､ プロミスやデータ配列を扱うときはいつでも､

08:30.450 --> 08:33.270
それがジェネリックの基本的な考え方なのです｡

08:33.270 --> 08:36.300
つまり､ ここは､ すべてジェネリックで作られていたのです｡ 

08:36.300 --> 08:37.460
それをコメントアウトしよう｡ 

08:37.460 --> 08:40.450
それでは､ 独自の汎用型ワードを構築してみましょう｡ 

08:40.450 --> 08:42.653
独自の汎用型を使ってみよう
