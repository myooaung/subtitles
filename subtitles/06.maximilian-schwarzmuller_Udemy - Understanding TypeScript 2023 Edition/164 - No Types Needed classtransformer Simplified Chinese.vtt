WEBVTT

00:02.270 --> 00:04.040
教师：我们看了一下Lodash,

00:04.040 --> 00:05.900
这是一个第三方库, 使用JavaScript

00:05.900 --> 00:08.270
for JavaScript构建｡

00:08.270 --> 00:13.287
您还可以找到某些第三方库, 它们真正包含类型脚本和类型脚本特性,

00:13.287 --> 00:21.230
并为您提供了一种全新的编写代码的方法, 因为您使用的是类型脚本｡

00:21.230 --> 00:28.067
一个例子是类转换器, 一个更好的例子是类验证器;我们将在这里查看这两种方法｡

00:28.067 --> 00:31.360
但让我们从类转换器开始｡ 

00:31.360 --> 00:38.150
比如说, 在我们的项目中, 我实际上有一个模型, 一个数据模型, 我们将其命名为“product”｡

00:38.150 --> 00:43.820
现在我将它命名为product｡  模型｡  ts, 但是您可以随意命名此文件｡

00:43.820 --> 00:48.820
我的想法是在这个文件中为产品定义一个类｡ 

00:49.420 --> 00:52.180
所以我描述一个产品应该是什么样子｡ 

00:52.180 --> 00:55.550
例如, 它有一个字符串的标题和一个数字的价格,

00:55.550 --> 01:02.120
然后我添加了一个构造函数, 在那里两者都可以初始化｡

01:02.120 --> 01:09.360
所以字符串加上price然后我说这个标题等于t这个price等于p.

01:09.360 --> 01:10.810
当然, 我们可以使用快捷方式初始化,

01:10.810 --> 01:14.423
其中我们只使用构造函数｡

01:16.150 --> 01:20.400
然后我们有一个方法, 获取信息,

01:20.400 --> 01:25.400
返回一个数组, 第一个元素是标题, 第二个元素是一个字符串,

01:25.950 --> 01:37.833
其中有美元符号, 然后注入到这个字符串中, 这个价格｡

01:39.030 --> 01:43.030
这里有一个非常简单的模型, 一个非常简单的类｡ 

01:43.030 --> 01:45.940
现在我们当然可以使用这个类, 如果你想的话,

01:45.940 --> 01:49.590
在app里｡ ts所以在那里我会摆脱Lodash,

01:49.590 --> 01:54.590
而不是进口产品从｡ /产品｡  model现在, 你需要确保在product

01:56.200 --> 02:11.950
model中, 你确实导出了这个类, 否则你就不能导入它了, 这里我们必须这样导出product, 因为我在这里使用了一个命名的导出, 在类的前面加上了export关键字｡

02:11.950 --> 02:16.497
所以现在我们当然可以创造一个新产品, 一本书,

02:18.150 --> 02:23.150
售价12美元｡ 99和之后I控制台日志p1获取信息,

02:24.080 --> 02:28.190
我们应该实际记录该数组｡

02:28.190 --> 02:31.390
如果我们现在在这里运行npm start, 我们的web

02:31.390 --> 02:34.250
pack dev就会启动, 我们应该会看到这个很好的数组,

02:34.250 --> 02:37.340
里面有关于这本书的信息｡

02:37.340 --> 02:39.463
所以如果我在这里重新加载, 它就在这里｡ 

02:40.630 --> 02:43.170
当然, 这并不太花哨, 这是可行的,

02:43.170 --> 02:44.930
但这并不是什么新鲜事｡

02:44.930 --> 02:47.270
在大型应用程序中, 一个常见的场景是,

02:47.270 --> 02:49.610
你可能会从服务器下载一些数据,

02:49.610 --> 02:54.490
你从后端服务器获取数据, 然后服务器返回一些json数据,

02:54.490 --> 03:01.560
你传递这些数据, 然后这些数据可能是一个产品列表｡

03:01.560 --> 03:05.520
这里我们可能有从服务器上得到的产品, 然后我们有一个标题,

03:05.520 --> 03:10.520
一个地毯和一个价格, 29｡ 99然后我们也有这本书,

03:13.047 --> 03:22.830
所以标题, 书和有一个价格10｡

03:22.830 --> 03:22.830
比如说99年｡ 

03:22.830 --> 03:25.310
这是一个非常简单的数据数组,

03:25.310 --> 03:27.730
然后我们从后端获得｡

03:27.730 --> 03:30.590
这些当然是JavaScript对象,

03:30.590 --> 03:33.730
但它们不是产品模型的实例｡

03:33.730 --> 03:37.220
这是一个典型的场景, 你得到的数据是json,

03:37.220 --> 03:42.850
它没有附加的数据, 比如你前面编码的构造函数属于哪个构造函数｡

03:42.850 --> 03:46.770
你的服务器知道这一点, json也是一种只传输基本数据的格式,

03:46.770 --> 03:53.540
你没有丰富的元数据给你的对象｡

03:53.540 --> 03:56.300
或者至少您必须手动执行此操作｡ 

03:56.300 --> 04:03.310
换句话说, 我们在这里得到的产品是没有获取信息方法的对象｡

04:03.310 --> 04:08.230
传统上, 如果你想把它转换成你的模型的实例,

04:08.230 --> 04:12.680
你必须手动完成｡

04:12.680 --> 04:17.680
你可以有你加载的产品, 然后, 比如说, 使用产品, 调用map方法,

04:19.260 --> 04:30.680
然后对数组中的每个产品返回新的产品｡

04:30.680 --> 04:30.680
标题和产品 price,

04:34.330 --> 04:40.230
然后我们将有一个充满实际产品构造函数实例的数组, 然后我们可以实际循环加载的产品,

04:40.230 --> 04:51.083
然后在那里, 例如控制台日志prod｡

04:51.083 --> 04:51.083
获取信息

04:52.150 --> 04:56.010
这就是我们如何手动将一个数组或一个没有名字的Vanilla

04:56.010 --> 05:00.070
JavaScript对象转换为一个特定构造函数的实例,

05:00.070 --> 05:05.000
因此, 我们将得到以下输出｡

05:05.000 --> 05:07.220
现在手动执行此操作非常麻烦｡ 

05:07.220 --> 05:09.590
这是一系列额外的步骤,

05:09.590 --> 05:12.710
当然这只是一个简单的转换｡

05:12.710 --> 05:16.690
这就是类转换器包可以帮助我们的地方｡ 

05:16.690 --> 05:19.330
这让事情变得非常非常简单｡ 

05:19.330 --> 05:22.390
在这里, 我们还在类型脚本中定义了一个类,

05:22.390 --> 05:25.010
然后我们可能会从服务器获取一些数据,

05:25.010 --> 05:36.893
然后我们实际上可以调用一个简单的方法, 它会自动将我们的数据转换为正确的模型｡

05:38.100 --> 05:40.030
现在, 我们首先运行一个nmp安装类转换器--save,

05:40.030 --> 05:54.470
就像这样, 完成后, 我们运行npm安装reflect-metadata--save一个包, 这个包最终取决于｡

05:54.470 --> 05:57.460
在这里, 让我们也导入它, 然后按照这里的设置说明中的指示,

05:57.460 --> 06:11.410
在您的路线条目文件中导入反射元数据, 在我的情况下是在应用程序中｡

06:11.410 --> 06:11.410
ts我导入这个第三方库,

06:11.410 --> 06:14.970
我们刚刚安装了它作为我们库的依赖项｡

06:14.970 --> 06:18.610
现在, 实际上措辞没有js步骤, 因此我们可以跳过这一个｡

06:18.610 --> 06:20.180
在浏览器中, 我们仍然必须安装相同的软件包,

06:20.180 --> 06:30.090
但在这里添加此导入是好的, 因为我们正在使用web包, 因此现在我们实际上很好去｡

06:30.090 --> 06:35.090
现在我们可以从类转换器中导入一些东西, 然后这个东西就是'plain

06:36.290 --> 06:40.210
to class'方法｡

06:40.210 --> 06:42.630
这个包还有其他几个方法｡ 

06:42.630 --> 06:45.200
您可以在官方文档中了解更多信息｡ 

06:45.200 --> 06:49.060
但“平实到类”才是主要方法｡ 

06:49.060 --> 06:54.060
例如, 您可以在此处使用它来设置加载的产品｡ 

06:55.150 --> 06:58.230
我们可以将loaded products设置为等于plain

06:58.230 --> 07:03.760
to class, 并在此处传递两个参数, 而不是像以前那样手动执行此操作｡

07:03.760 --> 07:08.070
第一个参数是我们要将其转换为的类｡ 

07:08.070 --> 07:10.190
在我的例子中, 产品｡ 

07:10.190 --> 07:12.700
我不会实例化或调用它,

07:12.700 --> 07:15.560
我只是指向那个类｡

07:15.560 --> 07:19.460
第二个参数是我们要转换的数据｡ 

07:19.460 --> 07:23.520
所以在我这里, 这就是产品｡ 

07:23.520 --> 07:25.840
现在这个包要做的是, 遍历这个数组,

07:25.840 --> 07:28.100
把每个普通的Vanilla

07:28.100 --> 07:34.090
JavaScript对象, 转换成这个类的一个实例.

07:34.090 --> 07:37.830
因此, 如果我们现在保存这个并再次运行npm start,

07:37.830 --> 07:43.270
启动服务器的网页将再次启动, 它应该会毫无错误地构建这个项目｡

07:43.270 --> 07:46.540
如果我重新加载页面, 我会得到和以前一样的输出,

07:46.540 --> 07:51.870
但是当然我们这边的代码更少, 因为我们使用的是这个包｡

07:51.870 --> 07:53.403
这个包的惊人之处在于它在这里工作得很好,

07:53.403 --> 07:57.070
因为它建立在类型脚本上, 利用类型脚本,

07:57.070 --> 08:04.280
并利用我们在那里有一个类可以指向的事实｡

08:04.280 --> 08:08.730
但老实说, 这个包在类型脚本中工作得特别好,

08:08.730 --> 08:12.600
但它没有使用类型脚本特有的特性｡

08:12.600 --> 08:16.630
例如, 类也存在于Vanilla JavaScript中｡ 

08:16.630 --> 08:20.170
因此, 虽然这主要是为类型脚本开发的, 但它实际上也适用于Vanilla

08:20.170 --> 08:23.610
JavaScript｡

08:23.610 --> 08:26.633
不过, 下一个包就不会是这样了｡ 
