WEBVTT

00:02.260 --> 00:05.340
解释者：是时候在App组件中进行一些状态管理了,

00:05.340 --> 00:07.240
因为当我们像这样更新数组时,

00:07.240 --> 00:08.880
组件不会被重新呈现｡

00:08.880 --> 00:10.530
这就是React的工作原理｡ 

00:10.530 --> 00:15.000
在我们的函数组件中, 我们可以使用useState挂接来管理State｡

00:15.000 --> 00:16.820
同样, 如果你不知道这一点,

00:16.820 --> 00:18.750
或者如果状态或函数组件或钩子没有告诉你任何东西,

00:18.750 --> 00:21.120
一定要查看一些专门的React资源,

00:21.120 --> 00:26.480
比如我的React, 完整的指南课程｡

00:26.480 --> 00:31.760
现在我想用state来管理我的todos, 为此我会清除我开始时的那个dummy

00:31.760 --> 00:36.430
todo, 然后通过调用useState来初始化state, 然后,

00:36.430 --> 00:44.510
我可以把空数组作为一个起始状态值传递给它, 这样我的state一开始就是一个空数组.

00:44.510 --> 00:49.370
现在, useState始终返回正好包含两个元素的数组｡

00:49.370 --> 00:53.630
第一个元素是此渲染周期的最新状态快照｡

00:53.630 --> 00:56.720
第二个参数, 数组中的第二个元素是一个函数,

00:56.720 --> 01:01.110
用于更新该状态并重新呈现组件｡

01:01.110 --> 01:02.660
我们可以使用数组重组,

01:02.660 --> 01:05.060
我们在前面的课程中学习过, 来取出这两个元素,

01:05.060 --> 01:09.230
并将它们存储在单独的常量中｡

01:09.230 --> 01:13.103
这里有todos, 比如一个名为setTodos的函数.

01:14.920 --> 01:16.820
这样, 我们仍然得到了todos数组,

01:16.820 --> 01:19.530
现在在todoAddHandler中,

01:19.530 --> 01:27.373
我想调用setTodos并将todos数组设置为一个新数组, 其中添加了新的todoText｡

01:28.240 --> 01:29.283
现在, 我们当然可以,

01:30.400 --> 01:32.130
传入一个新的数组, 并添加一个新的对象,

01:32.130 --> 01:42.530
比如说一个ID, 在这里我们用数学创建一个随机ID｡

01:42.530 --> 01:42.530
随机（）｡  字符串｡ 

01:42.530 --> 01:44.830
它并不是唯一的, 但在这里已经足够了,

01:44.830 --> 01:48.760
我们还有文本, 也就是我在这里得到的文本值｡

01:48.760 --> 01:51.910
但奇怪的是, 我在这里得到了一个错误｡ 

01:51.910 --> 01:56.860
我们得到的错误是这个参数是不可赋值的｡

01:56.860 --> 02:01.970
基本上就是一个什么都没有的数组｡

02:01.970 --> 02:03.590
这当然不是你想要的｡ 

02:03.590 --> 02:06.010
我们不希望有一个空的数组作为我们的状态｡ 

02:06.010 --> 02:07.110
为什么会这样？

02:07.950 --> 02:11.800
因为这里当我用一个空数组初始化useState时, TypeScript会推断出我们的状态是什么样子的,

02:11.800 --> 02:20.130
如果我将它初始化为一个字符串, TypeScript会推断出我的状态是一个字符串｡

02:20.130 --> 02:23.010
所以如果我暂时删除它并传递一些文本,

02:23.010 --> 02:24.123
它会被接受｡

02:25.160 --> 02:26.137
如果我在数组中传递它,

02:26.137 --> 02:28.260
TypeScript期望它是一个数组,

02:28.260 --> 02:32.000
但不是任何东西的数组, 但基本上总是一个空数组｡

02:32.000 --> 02:36.070
一个空的数组, 当然我不想在这里｡ 

02:36.070 --> 02:38.050
为了解决这个问题, 我们必须告诉反应,

02:38.050 --> 02:40.460
我们的遗产将如何随着时间的推移｡

02:40.460 --> 02:44.630
为此我们可以再次使用useState是一个泛型函数,

02:44.630 --> 02:48.080
因为我们可以传入资产的结构｡

02:48.080 --> 02:51.240
我们的状态是哪种类型的数据,

02:51.240 --> 02:54.200
我们可以传入状态, 应该是一个对象数组,

02:54.200 --> 02:59.570
准确地说是一个对象数组, 其中ID属性是字符串,

02:59.570 --> 03:04.860
文本属性是字符串.

03:04.860 --> 03:08.050
现在允许此状态更新｡ 

03:08.050 --> 03:10.100
现在在这里写这个当然是好的, 但是因为我们在应用程序的不同地方需要它,

03:10.100 --> 03:16.710
我实际上会创建一个新文件并将其命名为todo｡

03:16.710 --> 03:16.710
模型｡  ts.

03:16.710 --> 03:18.210
文件名由您决定｡ 

03:18.210 --> 03:19.940
这里我想导出一个名为Todo的接口,

03:19.940 --> 03:21.710
我只想描述一下Todo

03:21.710 --> 03:30.190
ID在我的应用中的样子, 我想让它有一个字符串类型的ID和一个字符串类型的文本属性｡

03:30.190 --> 03:42.543
在应用程序组件中导出此信息后, 我们可以导入此信息, 以便从此处导入待办事项｡

03:42.543 --> 03:42.543
/待办事项｡  模型｡ 

03:43.900 --> 03:46.720
这里我们有一个todos的数组,

03:46.720 --> 03:49.550
它当然更短, 更容易阅读｡

03:49.550 --> 03:51.480
现在我们的状态更新仍然有效,

03:51.480 --> 03:52.870
但这是一个有点干净｡

03:52.870 --> 03:55.100
正如你所看到的, 这在这里非常重要,

03:55.100 --> 03:57.210
当处理像数组这样的东西时,

03:57.210 --> 03:59.170
如果你用一个空数组初始化它,

03:59.170 --> 04:04.270
你最终要存储的是什么类型的内容｡

04:04.270 --> 04:06.250
不过, 有了这个, 它就起作用了｡ 

04:06.250 --> 04:07.450
当然, 缺点是,

04:07.450 --> 04:09.910
我们这里的状态更新逻辑是不正确的,

04:09.910 --> 04:17.400
因为现在我总是用一个只有一个元素的新数组覆盖现有的todos数组｡

04:17.400 --> 04:20.110
相反, 我想用一个新的数组来覆盖它,

04:20.110 --> 04:23.730
这个数组包含了所有的旧元素和新元素｡

04:23.730 --> 04:26.583
我们在下一节课里调整一下这个逻辑｡ 
