WEBVTT

00:02.270 --> 00:03.850
مدرس: إذن فنحن نستخدم

00:03.850 --> 00:07.450
الأنواع الأساسية للعدد والمنطقية والسلسلة.

00:07.450 --> 00:10.840
وهنا في قائمة معلمات هذه الوظيفة ،

00:10.840 --> 00:13.970
نقوم دائمًا بتعيين الأنواع صراحةً

00:13.970 --> 00:16.540
بنقطتين بعد اسم المعلمة ،

00:16.540 --> 00:18.410
ثم اسم النوع.

00:18.410 --> 00:21.350
هنا ، الأسماء هي رقم ، منطقي ، سلسلة.

00:21.350 --> 00:23.100
وفي حال كنت تتساءل ،

00:23.100 --> 00:25.420
فهذه الآن معرّفات خاصة.

00:25.420 --> 00:28.530
هذا بشكل عام ، هنا ، هو بناء جملة خاص تمت إضافته

00:28.530 --> 00:30.170
بواسطة TypeScript.

00:30.170 --> 00:32.900
إنه ليس جزءًا من كود JavaScript المترجم.

00:32.900 --> 00:35.040
إذا تحققنا من هذا الرمز هنا ،

00:35.040 --> 00:37.280
فستختفي تعيينات الأنواع هذه

00:37.280 --> 00:39.530
، لأن JavaScript لا يدعمها.

00:39.530 --> 00:42.390
هذا الشيء عبارة عن نقطتين بعد متغير

00:42.390 --> 00:43.920
، أو بعد معامل.

00:43.920 --> 00:46.320
ثم العدد والمنطقية والسلسلة.

00:46.320 --> 00:48.290
هذه الكلمات الرئيسية الخاصة.

00:48.290 --> 00:50.840
تم تقديم هذا بواسطة TypeScript.

00:50.840 --> 00:53.500
يفهمها مترجم TypeScript.

00:53.500 --> 00:55.480
يدعم IDE هنا TypeScript ، وبالتالي

00:55.480 --> 00:58.580
لا يشكو من هذه الكلمات الرئيسية الخاصة.

00:58.580 --> 01:01.760
لا يفهم JavaScript بناء الجملة هذا.

01:01.760 --> 01:04.590
لا يفهم النقطتين بعد المعلمة ، أو النقطتين

01:04.590 --> 01:06.560
بعد المتغير ، ثم الرقم الخاص

01:06.560 --> 01:09.190
أو الكلمة الأساسية للسلسلة.

01:09.190 --> 01:11.540
JavaScript لا يفهم هذا وبالتالي هذا ليس

01:11.540 --> 01:13.560
جزءًا من إخراج JavaScript.

01:13.560 --> 01:15.920
إنه حقًا مستخدم فقط بواسطة مترجم TypeScript.

01:15.920 --> 01:18.130
وبعد ذلك ، حسنًا ، إنه مترجم

01:18.130 --> 01:21.820
لأنه يحول هذه الشفرة إلى كود JavaScript.

01:21.820 --> 01:24.880
ملاحظة جانبية ، سترى أيضًا أنها تقوم بتبديل const

01:24.880 --> 01:27.700
لـ var ولكن هذا شيء سأعود إليه لاحقًا.

01:27.700 --> 01:30.590
لذلك ، لدينا تعيينات النوع الصريحة الخاصة بنا هنا

01:30.590 --> 01:33.060
ولا يتم فهمها إلا بواسطة TypeScript.

01:33.060 --> 01:35.763
عظيم ، لماذا لا نضعهم هناك؟

01:36.880 --> 01:39.890
ليس لدي مهام نوع صريحة هنا.

01:39.890 --> 01:41.180
وبالمناسبة ، ليس هنا

01:41.180 --> 01:43.450
أيضًا عندما نحسب النتيجة ، على سبيل

01:43.450 --> 01:45.530
المثال ، لأن TypeScript يحتوي

01:45.530 --> 01:48.400
على ميزة مضمنة تسمى استدلال النوع.

01:48.400 --> 01:51.000
هذا يعني أن TypeScript يبذل

01:51.000 --> 01:53.010
قصارى جهده ، ويقوم بعمل

01:53.010 --> 01:56.400
جيد جدًا هناك ، لفهم أي نوع لديك في متغير

01:56.400 --> 01:58.860
أو ثابت معين.

01:58.860 --> 02:02.300
وهنا ، على سبيل المثال ، يفهم أن الرقم 1

02:02.300 --> 02:05.780
سيكون دائمًا من نوع الرقم في النهاية ، لأنك

02:05.780 --> 02:08.020
تقوم بتهيئته برقم.

02:08.020 --> 02:09.950
الآن ، هذا في الواقع ثابت ، لذا

02:09.950 --> 02:11.740
فهو أكثر تحديدًا من ذلك.

02:11.740 --> 02:15.350
والنوع الذي تحدده هنا ليس فقط أي رقم

02:15.350 --> 02:17.490
، إنه الرقم خمسة.

02:17.490 --> 02:20.110
لأنك لن تتمكن من تعيين رقم جديد

02:20.110 --> 02:23.870
أو قيمة جديدة لقيمة ثابتة على أي حال.

02:23.870 --> 02:25.840
إذا كنت تريد تغيير هذا إلى متغير ،

02:25.840 --> 02:28.460
لذلك إذا كنت ستستخدم let بدلاً من ذلك ، فلن يؤدي

02:28.460 --> 02:30.180
هذا بالطبع إلى كسر أي شيء.

02:30.180 --> 02:32.940
يمكننا استخدام متغير هناك ، قد لا يكون أفضل ممارسة

02:32.940 --> 02:34.540
لأن هذه القيمة لا تتغير أبدًا

02:34.540 --> 02:36.210
ولكنها أيضًا ليست مروعة.

02:36.210 --> 02:38.260
ولكن الآن إذا مررنا فوق هذا ، نرى أن

02:38.260 --> 02:41.210
TypeScript لا تقول ، حسنًا ، يجب أن يكون هذا خمسة.

02:41.210 --> 02:45.510
لكنه لا يزال يكتشف أن النوع هنا هو رقم.

02:45.510 --> 02:49.260
الآن ، يمكننا بالتأكيد كتابة هذا الرمز هنا بمفردنا.

02:49.260 --> 02:51.970
يمكننا إضافة نقطتين بعد اسم المتغير على

02:51.970 --> 02:53.870
الجانب الأيسر من علامة التساوي

02:53.870 --> 02:55.590
، ثم اسم النوع.

02:55.590 --> 02:56.880
لذلك ، نفس الشيء الذي

02:56.880 --> 02:59.470
فعلناه في معلمات هذه الوظيفة.

02:59.470 --> 03:01.860
لكن هذا زائد عن الحاجة وهو في الواقع

03:01.860 --> 03:04.620
لا يعتبر أيضًا ممارسة جيدة.

03:04.620 --> 03:06.790
لأن TypeScript قادر على

03:06.790 --> 03:09.990
استنتاج هذا النوع تمامًا من هناك.

03:09.990 --> 03:13.690
لذا ، فإن تعيين هذه ليست فكرة جيدة.

03:13.690 --> 03:16.420
يتغير هذا فقط إذا كنت ستنشئ هذا المتغير

03:16.420 --> 03:18.053
بطريقة غير مخصصة.

03:19.000 --> 03:22.130
مثل هذا ، إذا لم تقم بتهيئته على الفور.

03:22.130 --> 03:25.700
بعد ذلك ، من الجيد إخبار TypeScript بالقيمة

03:25.700 --> 03:29.070
التي سيتم تخزينها هناك في النهاية.

03:29.070 --> 03:32.590
لذلك عندما تقوم لاحقًا بتعيين قيمة لها ، وبالطبع فإنه

03:32.590 --> 03:34.080
من الزائد هنا تقسيم هذا

03:34.080 --> 03:35.320
إلى سطرين.

03:35.320 --> 03:37.800
أنا أفعل هذا فقط لأغراض العرض.

03:37.800 --> 03:39.480
ولكن الآن إذا قمت بتعيين هذا

03:39.480 --> 03:42.460
هنا ، فسيتم كسر هذا لأنني أخبرت TypeScript مسبقًا

03:42.460 --> 03:44.630
أن هذا سيكون من النوع رقم.

03:44.630 --> 03:45.610
ليس عليك القيام بذلك.

03:45.610 --> 03:47.420
إنه يعمل أيضًا إذا لم تفعل ذلك.

03:47.420 --> 03:50.330
ولكن الآن يمكنك أيضًا إضافة هذه الخمسة

03:50.330 --> 03:51.630
ولن تحصل على خطأ لأنك

03:51.630 --> 03:53.470
لا تخبر TypeScript بأي شيء

03:53.470 --> 03:55.350
عن النوع الذي سيتم تخزينه

03:55.350 --> 03:56.975
في هذا المتغير ، وبالتالي

03:56.975 --> 03:59.630
يسمح TypeScript بأي نوع.

03:59.630 --> 04:02.600
إذا أضفت رقم النقطتين هنا بدلاً من ذلك ، فأنت

04:02.600 --> 04:05.417
تخبر TypeScript ، "مرحبًا ، في النهاية"

04:05.417 --> 04:07.370
، سيتم تخزين رقم هناك. وبالتالي ، إذا قمت بتخزين شيء آخر هناك

04:07.370 --> 04:10.060
لاحقًا ، كما في هذه الحالة حيث قمنا بتخزين سلسلة ،

04:10.060 --> 04:12.470
فسوف تحصل على خطأ هنا في IDE ، وبالطبع أيضًا إذا

04:12.470 --> 04:15.170
قمت بتجميع التعليمات البرمجية الخاصة بك.

04:15.170 --> 04:17.570
سنحصل على الخطأ الذي رأيناه بالفعل من قبل.

04:17.570 --> 04:20.253
هذه هي الطريقة التي يمكنك بها تعيين الأنواع.

04:22.300 --> 04:24.920
الآن ، حتى لو استنتجت TypeScript نوعًا ما

04:24.920 --> 04:27.830
، واسمحوا لي أن أصلح هذا ، فسيصيح عليك إذا كسرت

04:27.830 --> 04:29.310
هذا النوع المستنتج.

04:29.310 --> 04:32.720
في الواقع ، من الخطأ القول حتى بسبب ذلك

04:32.720 --> 04:35.670
بالطبع ، فلماذا لا يفعل ذلك؟

04:35.670 --> 04:37.000
يوجد استدلال الكتابة من أجلك

04:37.000 --> 04:39.750
لحفظ الرمز ، لتجنب الاضطرار إلى تعيين نوع يدويًا.

04:39.750 --> 04:42.730
بالطبع تصيح TypeScript في وجهك إذا استخدمت

04:42.730 --> 04:44.520
نوعًا خاطئًا ، وهو نوع

04:44.520 --> 04:46.510
لم يستدل عليه.

04:46.510 --> 04:48.640
على سبيل المثال ، هنا إذا تم إنشاء

04:48.640 --> 04:52.460
resultPhrase باستخدام let بحيث يكون متغيرًا ، فإن TypeScript

04:52.460 --> 04:54.000
هنا يستنتج أن هذا سيكون

04:54.000 --> 04:57.670
من نوع سلسلة لأننا نقوم بتهيئته بسلسلة.

04:57.670 --> 04:59.850
إذن ، هذا يعادل في الأساس عدم

04:59.850 --> 05:03.060
تهيئته ، وتعيين النوع بمفردنا ، ثم تعيين

05:03.060 --> 05:04.970
قيمة لاحقًا.

05:04.970 --> 05:07.410
الآن ، إذا غيرنا resultPhrase إلى

05:07.410 --> 05:12.310
، دعنا نقول ، صفر هنا ، لأي سبب من الأسباب قد نرغب في القيام بذلك ، حسنًا

05:12.310 --> 05:15.660
، لدينا خطأ هنا أن النوع صفر غير قابل للتخصيص من

05:15.660 --> 05:17.330
نوع السلسلة.

05:17.330 --> 05:21.210
وهذا منطقي ، أليس كذلك؟

05:21.210 --> 05:22.690
استنتجت TypeScript

05:22.690 --> 05:25.430
أننا نريد تخزين سلسلة ، نحاول الآن تخزين

05:25.430 --> 05:27.290
رقم ، لدينا خطأ.

05:27.290 --> 05:28.530
هذا هو العمل ، المهمة الأساسية لـ TypeScript.

05:28.530 --> 05:33.000
التحقق من الأنواع والصراخ علينا إذا كنا نستخدمها

05:33.000 --> 05:35.280
بشكل غير صحيح.
