WEBVTT

00:02.130 --> 00:05.180
教师：我们介绍了TypeScript知道的几个核心类型｡

00:05.180 --> 00:06.590
现在我们继续｡ 

00:06.590 --> 00:09.140
为此, 我将重命名应用程序｡  我们将其命名为objs-arrays-enums,

00:09.140 --> 00:17.130
或者您想给它命名的任何名称, 基本上这样我们仍然拥有该文件, 但我将创建一个全新的应用程序｡

00:17.130 --> 00:17.130
ts文件,

00:17.130 --> 00:20.500
这样我们又有了一个空文件, 可以在其中工作｡

00:20.500 --> 00:25.790
现在, 在这个文件中, 我想深入了解TypeScript中的另一个有趣的类型｡

00:25.790 --> 00:28.640
这就是联合类型｡ 

00:28.640 --> 00:30.190
那是什么？

00:30.190 --> 00:37.270
让我们回到前面写的add函数, 我将复制它并将它们移到app中.

00:37.270 --> 00:37.270
ts.

00:37.270 --> 00:39.190
在这里去掉那个评论, 在这里添加,

00:39.190 --> 00:44.170
让我们关闭基础｡ 这样我们就可以消除这个错误｡

00:44.170 --> 00:49.920
在此补充一句, 我现在想对我们在此接受的内容采取更灵活的态度｡

00:49.920 --> 00:52.570
我还将去掉showResult和短语,

00:52.570 --> 00:54.370
我不需要它们｡

00:54.370 --> 00:58.590
我唯一想做的就是计算一个结果并返回它｡

00:58.590 --> 01:01.960
但我想在输入方面更加灵活｡ 

01:01.960 --> 01:06.045
以前, 我们确保只处理数字｡ 

01:06.045 --> 01:09.357
现在让我们来命名这个联合收割机,

01:09.357 --> 01:13.190
它应该可以处理数字和字符串｡

01:13.190 --> 01:15.710
因为我们可以用这个加号运算符组合数字和字符串,

01:15.710 --> 01:24.030
唯一的区别是在一种情况下, 我们得到一个数字作为结果, 在另一种情况下, 我们得到一个连接的字符串,

01:24.030 --> 01:30.150
正如我们在本单元前面已经看到的｡

01:30.150 --> 01:32.040
但是现在我想允许这种行为,

01:32.040 --> 01:33.950
因为你可能有一个应用程序,

01:33.950 --> 01:38.963
你想有一个灵活的组合函数, 确实与数字和字符串的工作｡

01:39.830 --> 01:42.360
因此, 我也将在这里命名这个输入1,

01:42.360 --> 01:47.340
和这个输入2, 现在将这两个组合起来｡

01:47.340 --> 01:49.740
但是我们会遇到一个问题,

01:49.740 --> 01:53.180
现在我们把两个参数都设为数字｡

01:53.180 --> 01:58.190
这意味着我们可以调用这个函数, 只要我们确实想处理数字｡

01:58.190 --> 01:59.130
假设在下面, 我们创建了一个新的常量,

01:59.130 --> 02:01.640
combinedAges.

02:02.931 --> 02:04.690
这里我调用combine并传入30和26,

02:04.690 --> 02:12.000
作为我们构建的应用程序中的年龄｡

02:12.000 --> 02:15.014
另一个在控制台日志combinedAges之后,

02:15.014 --> 02:17.240
如果我们现在在这里编译这个文件,

02:17.240 --> 02:19.830
然后重新加载这个页面, 我们得到56,

02:19.830 --> 02:22.360
这不应该太令人惊讶｡

02:22.360 --> 02:24.690
这个方法可行, 我们得到这个数字｡ 

02:24.690 --> 02:26.710
当然, 如果我们试图在这里创建一个字符串,

02:26.710 --> 02:28.838
我们会遇到一个问题｡

02:28.838 --> 02:31.610
例如, 组合名称｡ 

02:31.610 --> 02:36.033
如果我试着把Max和Anna结合起来, 那么我们马上会得到一个错误,

02:37.230 --> 02:44.350
Max不能赋值给type number, 因为这是一个字符串｡

02:44.350 --> 02:45.790
当然, 我们可以改变它,

02:45.790 --> 02:50.130
接受字符串而不是数字, 但是现在第一个函数调用会失败｡

02:50.130 --> 02:52.750
这就是联合类型可以帮助我们的地方｡ 

02:52.750 --> 02:55.692
如果我们在应用程序中有一个地方,

02:55.692 --> 02:58.810
无论是函数的参数, 还是常量或变量,

02:58.810 --> 03:05.030
我们都可以接受两种不同的值｡

03:05.030 --> 03:07.410
那么, 联合类型可以帮助我们｡ 

03:07.410 --> 03:12.690
为了告诉TypeScript我们可以使用数字或字符串,

03:12.690 --> 03:14.220
我们使用数字,

03:14.220 --> 03:20.660
然后在这里使用管道符号, 然后我们也接受另一种类型｡

03:20.660 --> 03:22.340
而且 你 可以 有 两 种 以上 的 类型

03:22.340 --> 03:25.220
, 你 可以 在 这里 接受 你 需要 的 任意 多 的 类型 ｡

03:25.220 --> 03:27.050
所以在这里, 我只需要两个,

03:27.050 --> 03:28.880
这就是我将使用的提供的类型赋值,

03:28.880 --> 03:31.720
数字或字符串｡

03:31.720 --> 03:33.690
现在我在这里得到一个错误,

03:33.690 --> 03:39.120
加号运算符不能应用于类型字符串或数字和字符串或数字｡

03:39.120 --> 03:41.500
这实际上并不完全正确, 这应该是可行的,

03:41.500 --> 03:46.670
因为我们可以对数字和字符串使用加号运算符｡

03:46.670 --> 03:49.600
但是TypeScript只看到我们这里有一个联合类型,

03:49.600 --> 03:52.540
它不分析联合类型中有什么, 它只看到,

03:52.540 --> 03:56.010
“好吧, 你需要多个类型｡

03:56.010 --> 03:59.460
也许这包括我不能使用加号运算符的类型,

03:59.460 --> 04:01.640
因此我将在这里抱怨｡ 现在谢天谢地, 我们可以解决这个问题｡ 

04:01.640 --> 04:15.170
我们可以在这里添加运行时类型检查, 看看input1的typeof是否等于number,

04:16.530 --> 04:21.283
input2的typeof是否等于number, 然后把这个计算移到那里,

04:24.100 --> 04:28.510
现在只是一个改进, 让我们在if检查的开头创建一个变量result,

04:28.510 --> 04:37.873
因为锁的作用域, 所以这是一个在整个函数中可用的变量, 然后在那里赋一个新值｡

04:37.873 --> 04:40.310
现在我们检查是否有两个数字｡ 

04:40.310 --> 04:42.818
因此TypeScript知道在这里,

04:42.818 --> 04:45.890
input1和input2都是数字｡

04:45.890 --> 04:49.790
现在, 让我们在此处添加一个else检查｡ 

04:49.790 --> 04:53.900
我们可以设置result等于input1｡  tostring, 将其显式转换为字符串,

04:53.900 --> 05:00.570
以及input2｡

05:00.570 --> 05:00.570
串起来

05:00.570 --> 05:04.160
这对于TypeScript和JavaScript也是很好的,

05:04.160 --> 05:05.700
因为我们可以连接两个字符串｡

05:05.700 --> 05:08.220
现在我们有了几乎相同的计算, 但是我们清楚地表明,

05:08.220 --> 05:15.730
这里我们总是处理数字, 这里我们总是处理字符串, 然后我们返回结果｡

05:15.730 --> 05:17.490
现在, 如果我们控制台记录下面的组合名称,

05:17.490 --> 05:20.870
并编译这个文件, 我们会看到, 一旦我们再次访问我们的页面,

05:20.870 --> 05:35.090
我们在那里得到了组合的数字, 它们被简单地加在一起, 因此我们得到了一个数字作为结果, 这里有两个组合的名称｡

05:35.090 --> 05:40.830
因此, 这就是我们如何使用联合类型来更灵活地处理函数中的操作,

05:40.830 --> 05:43.770
或者代码中的任何其他地方｡

05:43.770 --> 05:51.230
当您使用联合类型时, 并不总是需要进行这种额外的运行时类型检查,

05:51.230 --> 05:54.090
但通常是这样的, 因为使用联合类型时, 您可以更灵活地接受参数,

05:54.090 --> 06:00.940
但随后您可能会根据所获取的确切类型在函数中使用不同的逻辑｡

06:00.940 --> 06:03.730
这样你的函数就可以处理多种类型的值,

06:03.730 --> 06:05.640
但是根据你得到的类型,

06:05.640 --> 06:10.320
它会做一些稍微不同的事情｡

06:10.320 --> 06:12.410
通常, 在处理联合类型时可能需要这样的运行时检查,

06:12.410 --> 06:16.700
但并不总是需要｡

06:16.700 --> 06:18.490
在TypeScript程序中,

06:18.490 --> 06:24.060
您肯定也会遇到这样的情况：您可以使用联合类型而无需运行时类型检查｡

06:24.060 --> 06:25.870
这取决于你写的逻辑｡ 
