WEBVTT

00:02.160 --> 00:06.060
教师：那么, 我们对验证有什么看法呢？

00:06.060 --> 00:10.450
好吧, 也许, 让我们从期望的最终结果开始｡ 

00:10.450 --> 00:14.850
我的想法是, 我们以后会有一些验证函数, 它现在还不存在,

00:14.850 --> 00:21.230
但是我们以后会有它, 我会把enteredTitle传递给它, 或者实际上是一个配置对象,

00:21.230 --> 00:30.300
我会说它的值是enteredTitle, 所以要验证的东西｡

00:30.300 --> 00:33.260
但是 我 还有 其他 属性 告诉

00:33.260 --> 00:37.350
validate 函数 如何 验证

00:37.350 --> 00:39.130
它 ｡

00:39.130 --> 00:47.009
例如, 我们要求在这里设置为true, minLength设置为5以强制使用5个字符,

00:47.009 --> 00:48.360
等等｡

00:48.360 --> 00:50.040
然后我们在这里对所有三个输入都这样做,

00:50.040 --> 00:51.540
validate是一个函数,

00:51.540 --> 00:53.900
如果它有效, 就返回true, 如果它无效,

00:53.900 --> 00:59.580
就返回false, 最后, 我们可以得到这样的结果｡

00:59.580 --> 01:06.790
或者输入“描述”和“人”, 大致就是这样｡

01:06.790 --> 01:09.210
当然, 这只是实现这一点的一种方式,

01:09.210 --> 01:11.703
但我非常喜欢这种方式｡

01:12.600 --> 01:15.320
为此, 在文件的顶部,

01:15.320 --> 01:19.470
我将添加一些验证逻辑｡

01:19.470 --> 01:22.380
同样, 有很多方法可以做到这一点｡ 

01:22.380 --> 01:27.840
首先, 我将定义这样一个可验证对象的结构｡

01:27.840 --> 01:31.280
我们把这个对象传递给validate函数,

01:31.280 --> 01:33.430
因为它总是需要一个类似的结构,

01:33.430 --> 01:49.870
包含一定数量的属性和特定类型的属性, 这样validate函数才知道它在处理什么, 才能正确地提取属性等等.

01:49.870 --> 01:52.850
因此, 我将从定义接口开始｡ 

01:52.850 --> 01:56.550
我们也可以去一个自定义类型, 完全取决于你｡

01:56.550 --> 01:58.690
因为我将定义对象的结构,

01:58.690 --> 02:02.793
所以我总是更喜欢只定义接口｡

02:03.810 --> 02:06.700
我在这里将它命名为Validatable,

02:06.700 --> 02:09.940
因为它描述了一个可验证的对象,

02:09.940 --> 02:17.140
并且它的值应该是一个字符串或数字｡

02:17.140 --> 02:18.980
它将有一个必需的prop,

02:18.980 --> 02:22.630
它将有一个布尔值, 所以真或假｡

02:22.630 --> 02:26.470
假设 我们 支持 minLength 验证 , 它 应该

02:26.470 --> 02:28.212
是 一 个 数字 , maxLength

02:28.212 --> 02:30.220
也 应该 是 一 个 数字 , 如果

02:30.220 --> 02:32.510
我们 得到 一 个 数字 , 一 个 最 小

02:32.510 --> 02:35.240
值 和 一 个 最 大 值 ｡

02:35.240 --> 02:37.417
与minLength和maxLength的区别在于,

02:37.417 --> 02:46.010
它检查字符串的长度, 如果数值大于某个数值或小于某个最大值, 它就是数值.

02:46.010 --> 02:48.870
这些是我想要支援的属性｡ 

02:48.870 --> 02:50.470
现在, 除了值之外,

02:50.470 --> 02:52.140
它们都应该是可选的,

02:52.140 --> 02:57.650
我们可以通过在名称后面添加问号来强制执行｡

02:57.650 --> 03:02.720
顺便说一下, 使用问号的替代方法是允许未定义的值｡

03:02.720 --> 03:04.880
问号的作用基本相同｡ 

03:04.880 --> 03:09.370
它表示required是布尔值或未定义｡ 

03:09.370 --> 03:12.610
现在我们有了validatable接口｡ 

03:12.610 --> 03:13.893
我们能用它做什么？

03:14.930 --> 03:17.893
好了, 现在创建了接口,

03:18.830 --> 03:24.220
我们可以创建函数, 我正在寻找的验证函数｡

03:24.220 --> 03:27.410
应该会得到这样一个可验证的对象｡ 

03:27.410 --> 03:32.410
因此, ValidatableInput的类型为Validatable｡ 

03:32.410 --> 03:33.450
这是我的主意

03:33.450 --> 03:36.400
所以它得到了一个对象, 这个对象有这样的结构｡ 

03:36.400 --> 03:41.670
现在, 我们可以检查所有这些属性是否存在,

03:41.670 --> 03:44.810
然后进行适当的验证｡

03:44.810 --> 03:48.200
那么, 我们在validate函数中究竟做了些什么呢？

03:48.200 --> 03:50.930
最后, 我想创建一个变量isValid,

03:50.930 --> 03:52.330
初始值为true.

03:52.330 --> 03:55.510
所以默认的假设是我们得到的是真的｡

03:55.510 --> 03:57.430
但只要至少有一个检查失败,

03:57.430 --> 04:01.330
我们就会将其设置为false｡

04:01.330 --> 04:03.480
现在让我们从第一次检查开始｡ 

04:03.480 --> 04:06.410
让我们看看validatableInput,

04:06.410 --> 04:08.220
我们得到的这个参数,

04:08.220 --> 04:11.380
是否有一个必需的属性？

04:11.380 --> 04:13.260
如果不是未定义的话｡ 

04:13.260 --> 04:16.490
如果设置了该值, 并且该值为true,

04:16.490 --> 04:18.630
则意味着该值是必需的,

04:18.630 --> 04:20.630
并且不能为空｡

04:20.630 --> 04:27.700
在这里, 我们可以设置isValid等于isValid和JavaScript的工作方式,

04:27.700 --> 04:34.330
这确保了如果和之后的值为假, 则isValid的新值为假｡

04:34.330 --> 04:36.870
因为如果这两件事中至少有一件是假的,

04:36.870 --> 04:38.660
那么总的价值就会是假的｡

04:38.660 --> 04:40.500
现在isValid最初是真的,

04:40.500 --> 04:46.300
但如果逻辑与运算符后的东西是假的, isValid也会是假的｡

04:46.300 --> 04:48.700
最后我将返回isValid｡ 

04:48.700 --> 04:53.550
那么现在我们在两个&amp;符号之后加什么呢？

04:53.550 --> 04:58.170
我想检查validatableInput是否正确｡  值（如果为空）｡

04:58.170 --> 05:00.530
为了这个, 我们可以修剪它,

05:00.530 --> 05:04.210
检查长度, 或者我们可以吗？

05:04.210 --> 05:07.510
问题是, 我们不知道value是不是字符串.

05:07.510 --> 05:09.090
它是一个字符串或一个数字｡ 

05:09.090 --> 05:10.910
所以它不一定是字符串,

05:10.910 --> 05:14.100
因此trim方法并不总是可用的｡

05:14.100 --> 05:17.570
现在有很多方法可以解决这个问题｡ 

05:17.570 --> 05:23.390
我们可以添加一个类型保护, 我们可以检查类型是否为validatableInput｡

05:23.390 --> 05:23.390
值等于字符串,

05:25.250 --> 05:30.250
并且仅在它等于字符串时执行此检查｡

05:30.920 --> 05:33.040
但实际上这有点多余｡ 

05:33.040 --> 05:36.120
我们能做的很简单｡ 

05:36.120 --> 05:37.257
我们可以简单地说“好吧,

05:37.257 --> 05:39.140
把它转换成字符串｡ 如果它是一个数字, 现在它又是一个字符串｡ 

05:39.140 --> 05:41.370
如果是一根弦, 什么都不会改变｡ 

05:41.370 --> 05:44.170
有 了 这个 ,  我们 就 可以 开始 了 ｡ 

05:44.170 --> 05:45.900
现在, 我只需要在这里添加我的检查,

05:45.900 --> 05:47.950
以检查它是否为零｡

05:47.950 --> 05:50.360
或者更准确地说, 如果不是零的话｡ 

05:50.360 --> 05:53.463
因此, 如果它不为零, 则返回true,

05:54.680 --> 05:58.740
isValid保持为true｡

05:58.740 --> 06:00.500
如果它是零, 那么如果它的长度是零,

06:00.500 --> 06:04.940
如果它是空的, 这将返回false, 因此isValid将变为false｡

06:04.940 --> 06:08.280
只有当必需的检查被标记为将required设置为true时,

06:08.280 --> 06:11.190
我们才会检查此检查｡

06:11.190 --> 06:13.530
这是我要做的第一个检查

06:13.530 --> 06:15.560
当然, 这不是唯一的一个｡ 

06:15.560 --> 06:18.950
我们可以继续并检查validatableInput是否有效｡

06:18.950 --> 06:18.950
如果设置了minLength,

06:18.950 --> 06:27.050
那么我们得到的这个字符串应该有一定的最小长度｡

06:27.050 --> 06:30.440
重要的是, 字符串应具有特定的最小长度｡

06:30.440 --> 06:31.620
这里我们不关心数字,

06:31.620 --> 06:33.600
我们不检查数字的最小值｡

06:33.600 --> 06:37.060
所以这里我们实际上可以添加一个类型保护, 我们可以将它合并到这个检查中,

06:37.060 --> 06:42.320
并检查typeof validatableInput是否有效｡

06:42.320 --> 06:42.320
值等于字符串

06:46.910 --> 06:48.460
如果不是, 我们就不需要进行if

06:48.460 --> 06:50.357
check了, 因为没有什么可检查的｡

06:50.357 --> 06:52.570
如果我们的值是一个数字, 我们不关心这个｡ 

06:52.570 --> 06:55.330
如果我们为一个数字设置一个最小长度,

06:55.330 --> 06:59.330
我们基本上跳过了这个检查, 因为它没有多大意义｡

06:59.330 --> 07:03.420
如果我们有一个字符串, 并且minLength被设置了,

07:03.420 --> 07:05.663
那么我想设置isValid等于isValid,

07:06.570 --> 07:10.053
然后再一次, 我们的检查.

07:11.181 --> 07:16.580
这里检查的是validatableInput是否有效｡

07:16.580 --> 07:16.580
值,

07:16.580 --> 07:20.810
我们知道这里是一个字符串, 长度,

07:20.810 --> 07:24.070
大于validatableInput｡ 最小长度｡ 

07:24.070 --> 07:28.520
因此大于此处定义的值｡ 

07:28.520 --> 07:31.660
现在我们有一个潜在的问题,

07:31.660 --> 07:33.920
你知道是哪个吗？

07:33.920 --> 07:36.163
这通常应该有效, 但如果minLength设置为零,

07:37.030 --> 07:38.630
则会失败｡

07:38.630 --> 07:42.210
开发人员将其设置为零的意图可能不是跳过此检查,

07:42.210 --> 07:50.170
而是检查我们是否具有最小长度零｡

07:50.170 --> 07:51.960
可以说这是一个多余的检查,

07:51.960 --> 07:53.800
因为它基本上是检查我们是否有任何东西,

07:53.800 --> 07:57.260
我们已经在必要的检查中做了｡

07:57.260 --> 07:59.300
所以这不是什么大问题｡ 

07:59.300 --> 08:01.330
不过, 如果你想在这里超级安全,

08:01.330 --> 08:05.470
我们实际上应该检查validatableInput是否有效｡

08:05.470 --> 08:05.470
minLength不等于undefined｡ 

08:05.470 --> 08:10.470
或者不等于null, 有一个等号,

08:10.640 --> 08:17.130
这包括null和undefined, 这就是JavaScript的工作原理.

08:17.130 --> 08:23.010
这样更安全一些, 因为现在我们确保即使minLength设置为零（这是一个伪值）,

08:23.010 --> 08:25.140
也始终运行此检查｡

08:25.140 --> 08:27.222
同样, 你可以争论它是否有意义,

08:27.222 --> 08:29.740
因为它基本上是和上面一样的检查,

08:29.740 --> 08:32.270
但是我仍然想在这里执行它｡

08:32.270 --> 08:34.930
这就是最小长度｡ 

08:34.930 --> 08:38.130
现在我将复制它, 并基本上对maxLength做同样的操作｡

08:38.130 --> 08:40.720
所以这里的maxLength也被选中了,

08:40.720 --> 08:44.350
也是这里的, 也是只针对字符串的｡

08:44.350 --> 08:46.870
当然这里我们只需要把它还原｡ 

08:46.870 --> 08:52.380
我们要确保提供的值的长度小于最大长度｡

08:52.380 --> 08:55.173
好了, 现在我们还有两个检查剩下的最小值和最大值,

08:56.810 --> 09:00.160
这只对一个数字有意义｡

09:00.160 --> 09:05.150
因此, 在这里我将添加另一个检查, 检查validatableInput是否有效｡

09:05.150 --> 09:05.150
最小值不等于空值｡

09:09.720 --> 09:11.100
再次强调, 我不仅仅是在检查真实性,

09:11.100 --> 09:13.820
因为如果值为零, 那会有问题｡

09:13.820 --> 09:21.770
然后我将检查validatableInput的类型｡  值等于数字

09:21.770 --> 09:25.640
因为我看不出检查字符串有什么意义｡

09:25.640 --> 09:26.760
如果你想检查一个字符串,

09:26.760 --> 09:28.020
当然你可以省略这个｡

09:28.020 --> 09:29.680
然后你只需要确保在我们将要写的支票中使用它时,

09:29.680 --> 09:34.380
你把这个值转换成了一个数字｡

09:34.380 --> 09:35.970
我们要写的检查, 同样,

09:35.970 --> 09:37.220
使用isValid的旧值,

09:37.220 --> 09:41.500
并将其与新检查组合, 然后将其存储回isValid｡

09:41.500 --> 09:44.000
新的检查现在应该很好地结合了我们的数字,

09:44.000 --> 09:48.730
并检查它是否大于最小值｡

09:48.730 --> 09:54.650
所以我在这里检查validatableInput是否有效｡  值大于validatableInput

09:54.650 --> 09:54.650
最小值

09:54.650 --> 09:58.690
现在我们可以对max重复这个过程,

09:58.690 --> 10:02.010
这里我们需要max, 这里我们也需要max,

10:02.010 --> 10:06.190
我们需要把这里改成一个小于号｡

10:06.190 --> 10:13.230
有了它, 我们正在检查所有不同的情况, 你可以在这里｡

10:13.230 --> 10:16.930
我们返回isValid｡ 

10:16.930 --> 10:18.710
现在, 我们只需要创建符合此接口的对象,

10:19.840 --> 10:23.630
然后将它们发送到validate函数｡

10:23.630 --> 10:31.360
为此, 让我们转到项目输入, 在gatherUserInput中,

10:31.360 --> 10:34.000
我想构造我的可验证对象｡

10:34.000 --> 10:36.360
旁注, 除了接口, 当然我们也可以在这里创建一个类,

10:36.360 --> 10:40.870
然后我们可以用new关键字实例化它, 但是为了练习和演示的目的,

10:40.870 --> 10:46.070
我想在这里展示它是如何使用接口的｡

10:46.070 --> 10:48.990
这里我们有我们的titleValidatable,

10:48.990 --> 10:51.900
它的类型应该是Validatable｡

10:52.850 --> 10:56.830
当然, 这是一个需要有值属性的对象｡

10:56.830 --> 10:58.930
这就是我们输入的标题｡ 

10:58.930 --> 11:01.020
它不需要任何其他属性, 但我想检查它是否为空,

11:01.020 --> 11:06.750
所以我们将required设置为true｡

11:06.750 --> 11:08.743
然后我们可以复制它,

11:09.710 --> 11:12.430
重复它来描述和描述人们｡

11:12.430 --> 11:19.250
这里我们有描述, 哎呀, 我是说输入的描述｡

11:19.250 --> 11:21.880
这是进入的人｡ 

11:21.880 --> 11:24.260
准确地说, 我想要一个数字｡ 

11:24.260 --> 11:26.230
所以我把它转换成一个带加号的数字｡ 

11:26.230 --> 11:29.020
都 应该 是 必需 的 , 但 这里 我们 也 假设

11:29.020 --> 11:30.810
描述 的 minLength

11:30.810 --> 11:32.890
应为 五 个 字符 , 而 对于 人员

11:32.890 --> 11:35.420
, 最 小 长度 应为 一 个 字符 , 这样

11:35.420 --> 11:38.823
我们 就 至少 分配 了 两 个 人员 ｡

11:39.820 --> 11:42.030
顺便说一句, 这取决于你如何实现这一点｡ 

11:42.030 --> 11:44.020
当然, 在验证逻辑中,

11:44.020 --> 11:50.080
如果愿意, 也可以检查大于等于小于等于｡

11:50.080 --> 11:52.030
当然长度也一样｡ 

11:52.030 --> 11:54.200
大小相等｡ 

11:54.200 --> 11:56.940
也有可能｡ 

11:56.940 --> 11:58.660
实际上, 我会保留这些更改｡ 

11:58.660 --> 12:00.520
所以现在我们最少分配一个人,

12:00.520 --> 12:01.920
最多分配五个人｡

12:01.920 --> 12:05.253
现在我们有了这三个validatable对象,

12:06.100 --> 12:11.680
现在我们把我们的titleValidatable传递给validate函数,

12:11.680 --> 12:16.440
把descriptionValidatable传递给第二个函数调用,

12:16.440 --> 12:21.310
把peopleValidatable传递给第三个函数调用｡

12:21.310 --> 12:24.460
如果它们都有效, validate应该返回true,

12:24.460 --> 12:26.380
否则返回false｡

12:26.380 --> 12:36.580
所以现在我想检查是否至少有一个失败了通过在前面加一个感叹号来检查这些是否都是假的,

12:36.580 --> 12:41.560
来检查这是假的还是这是假的｡

12:41.560 --> 12:42.740
如果其中至少有一个是假的,

12:42.740 --> 12:45.730
那么如果至少有一个验证函数调用返回假, 我们就把它放进去,

12:45.730 --> 12:47.760
并显示警报｡

12:47.760 --> 12:49.860
说完了, 还要测试这个,

12:51.930 --> 12:54.860
我会去索引｡

12:54.860 --> 12:54.860
html,

12:56.270 --> 12:58.210
因为在人的输入上, 我实际上允许最大值为10,

12:58.210 --> 13:00.410
最小值为0｡

13:00.410 --> 13:01.460
因此, 在输入中, 技术上我们可以输入无效值｡ 

13:01.460 --> 13:06.240
当然是有目的的, 这样我们就可以检验我们的逻辑了｡

13:06.240 --> 13:08.090
现在让我们保存它,

13:08.090 --> 13:10.200
编译时没有错误｡

13:10.200 --> 13:11.750
现在让我们来试一试｡ 

13:11.750 --> 13:13.083
如果我点击添加项目,

13:13.920 --> 13:16.000
我得到一个错误, 这是好的｡

13:16.000 --> 13:17.430
现在让我们在这里输入测试, 仍然得到一个错误｡ 

13:17.430 --> 13:21.370
我们在这里输入test, 在这里输入5,

13:21.370 --> 13:24.180
但还是会出现错误｡

13:24.180 --> 13:25.390
因为我的描述太简短了｡ 

13:25.390 --> 13:26.870
如果我再输入一个字符,

13:26.870 --> 13:29.500
我有最小长度, 我可以创建这个｡

13:29.500 --> 13:31.210
现在让我们输入, 比如说,

13:31.210 --> 13:32.640
减去一个人, 好吧,

13:32.640 --> 13:34.580
html不支持这个｡

13:34.580 --> 13:39.200
但如果我们输入0或6, 就会出现错误｡

13:39.200 --> 13:42.040
只有当我输入1到5之间的数字时,

13:42.040 --> 13:43.840
它才能工作｡

13:43.840 --> 13:46.100
这看起来像它应该的那样工作,

13:46.100 --> 13:49.260
这很好｡

13:49.260 --> 13:51.850
当然, 这只是实现验证的一种方式｡

13:51.850 --> 13:53.570
但是一种现在已经可以重用的方法,

13:53.570 --> 13:56.510
也可以像这样在应用程序的不同部分使用,

13:56.510 --> 14:04.480
当然, 它利用了打字脚本, 为我们提供了很好的支持和类型检查, 以避免不必要的错误｡
