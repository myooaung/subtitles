WEBVTT

00:00.000 --> 00:02.410
(cisza) -: Widzimy więc już, jak

00:02.410 --> 00:04.190
TypeScript może nam pomóc

00:04.190 --> 00:06.200
podczas rozwoju.

00:06.200 --> 00:10.560
Teraz wiemy również, że w JavaScript istnieje typ liczbowy.

00:10.560 --> 00:14.010
I możemy to zobaczyć dzięki wbudowanemu typowi operatora.

00:14.010 --> 00:15.781
To teraz nie jest specyficzne dla TypeScript,

00:15.781 --> 00:17.560
jest to wbudowany operator i słowo

00:17.560 --> 00:20.420
kluczowe obsługiwane przez JavaScript.

00:20.420 --> 00:22.910
Możemy go użyć, aby uzyskać typ określonej wartości.

00:22.910 --> 00:27.050
Tak więc tutaj moglibyśmy konsolować blokadę typu numer jeden.

00:27.050 --> 00:27.992
I to, co zobaczymy, jeśli

00:27.992 --> 00:30.780
to zrobimy, jest to, że jak tylko skompilujemy to, tak że uruchomimy

00:30.780 --> 00:32.623
zaktualizowany kod.

00:33.780 --> 00:37.040
Tutaj wypisujemy liczbę do konsoli.

00:37.040 --> 00:39.330
Teraz robimy to, dzięki temu wyjściu tutaj

00:39.330 --> 00:41.180
i dzięki typowi operatora i w Vanilla

00:41.180 --> 00:43.770
JavaScript, bez TypeScript, moglibyśmy użyć tego,

00:43.770 --> 00:46.710
aby zawsze poprawić naszą funkcję tutaj.

00:46.710 --> 00:51.500
Możemy sprawdzić, czy typ liczby jest równy liczbie.

00:51.500 --> 00:54.300
Przepraszam, typ n1 mam na myśli, czy

00:54.300 --> 00:56.350
to jest równe liczbie i moglibyśmy

00:56.350 --> 01:00.710
też sprawdzić, czy typ n2 jest równy liczbie.

01:00.710 --> 01:02.349
i wykonać naszą operację

01:02.349 --> 01:05.220
tylko tutaj, jeśli jest to inaczej rzucony

01:05.220 --> 01:07.860
błąd lub zrobić odwrotnie i sprawdzić,

01:07.860 --> 01:10.820
czy nie jest równy, czy n2 nie jest równy.

01:10.820 --> 01:13.230
A jeśli któryś z nich nie jest liczbą, wtedy

01:13.230 --> 01:16.360
moglibyśmy rzucić nowy błąd, w którym mówimy, nieprawidłowe

01:16.360 --> 01:19.690
dane wejściowe. To właściwie byłby nie TypeScriptowy

01:19.690 --> 01:22.300
sposób zapewnienia, że nie możemy wywołać

01:22.300 --> 01:25.700
tej funkcji z ciągiem tutaj.

01:25.700 --> 01:26.760
Jeśli zrobię to teraz

01:26.760 --> 01:29.060
i przekompiluję, otrzymamy nasz błąd TypeScript,

01:29.060 --> 01:30.830
ale zignorujmy to na razie.

01:30.830 --> 01:31.730
Jeśli ponownie uruchomimy

01:31.730 --> 01:33.100
to, otrzymamy nieprawidłowe dane

01:33.100 --> 01:34.940
wejściowe, które sami rzucamy.

01:34.940 --> 01:38.080
Więc teraz utwardziliśmy dysfunkcję w JavaScript, kończy się niepowodzeniem

01:38.080 --> 01:39.930
w czasie biegu, ale niepowodzenie może

01:39.930 --> 01:41.970
być tutaj lepsze niż pokazanie nieprawidłowego

01:41.970 --> 01:44.950
wyjścia, które mieliśmy wcześniej.

01:44.950 --> 01:47.640
Byłby to więc sposób na sprawdzenie danych wejściowych w

01:47.640 --> 01:48.715
zwykłym JavaScript.

01:48.715 --> 01:50.640
Nie potrzebujesz do tego TypeScript.

01:50.640 --> 01:53.200
To jest zwykły kod JavaScript.

01:53.200 --> 01:54.033
Ale oczywiście takie

01:54.033 --> 01:55.160
podejście ma minusy.

01:55.160 --> 01:57.160
Czasami jest to słuszne rozwiązanie.

01:57.160 --> 02:01.440
Czasami możesz zatwierdzić tylko niektóre dane wejściowe w czasie wykonywania.

02:01.440 --> 02:03.150
Ale minusem jest tutaj sprawdzanie

02:03.150 --> 02:05.480
czegoś, czego faktycznie możemy uniknąć

02:05.480 --> 02:08.950
podczas rozwoju z TypeScript.

02:08.950 --> 02:11.180
Więc tak, rzucamy błąd.

02:11.180 --> 02:14.210
I w naszej aplikacji możemy mieć wbudowane środki, które

02:14.210 --> 02:16.860
mogą następnie spaść do jakiegoś innego zachowania,

02:16.860 --> 02:19.080
aby zapisać działającą aplikację.

02:19.080 --> 02:20.750
Ale nadal rzucamy błąd, który naprawdę

02:20.750 --> 02:24.180
nie jest konieczny do wystąpienia w pierwszej kolejności.

02:24.180 --> 02:27.350
Mogliśmy temu zapobiec za pomocą TypeScript.

02:27.350 --> 02:28.830
I tutaj naprawdę widzimy różnicę

02:28.830 --> 02:30.400
między JavaScriptem a TypeScriptem,

02:30.400 --> 02:31.450
jeśli chodzi o typy.

02:31.450 --> 02:33.750
JavaScript jest dynamicznie typowany,

02:33.750 --> 02:35.610
co oznacza, że doskonale jest, że

02:35.610 --> 02:36.880
mamy zmienną, która początkowo

02:36.880 --> 02:39.100
może trzymać liczbę, gdzie później przypisujemy

02:39.100 --> 02:41.600
do niej ciąg znaków.

02:41.600 --> 02:44.500
I po to mamy operator type off, abyśmy mogli

02:44.500 --> 02:48.024
sprawdzić aktualny typ czegoś w czasie runtime,

02:48.024 --> 02:50.124
jeśli mamy jakiś kod, który zależy

02:50.124 --> 02:52.267
od określonego typu.

02:52.267 --> 02:53.570
TypeScript z drugiej

02:53.570 --> 02:55.094
strony jest statycznie

02:55.094 --> 02:58.480
typowany, co oznacza, że definiujemy typy zmiennych

02:58.480 --> 03:01.740
i parametrów kończy się na podczas rozwoju, nie zmieniają

03:01.740 --> 03:04.980
się one nagle podczas runtime.

03:04.980 --> 03:05.813
Teraz, oczywiście,

03:05.813 --> 03:09.090
ponieważ TypeScript jest skompilowany do JavaScript, teoretycznie

03:09.090 --> 03:10.660
mogliby.

03:10.660 --> 03:12.510
Ale jeśli używamy TypeScript,

03:12.510 --> 03:13.790
i piszemy kod, w którym

03:13.790 --> 03:17.530
nagle przypisujemy nowy typ danych do zmiennej, gdzie wcześniej

03:17.530 --> 03:18.810
powiedzieliśmy, że

03:18.810 --> 03:19.840
to powinna być liczba,

03:19.840 --> 03:22.900
na przykład, a teraz przypisujemy ciąg znaków, to

03:22.900 --> 03:25.810
otrzymujemy błąd podczas rozwoju, więc jesteśmy

03:25.810 --> 03:27.480
zmuszeni do jasności w odniesieniu

03:27.480 --> 03:32.120
do typów, coś może lub nie może trzymać.

03:32.120 --> 03:33.710
To jest właśnie ta różnica.

03:33.710 --> 03:36.620
Więc naprawdę nie chcemy używać implementacji lub

03:36.620 --> 03:38.330
rozwiązań tego typu, jeśli możemy

03:38.330 --> 03:40.810
tego uniknąć za pomocą TypeScript.

03:40.810 --> 03:42.200
Mimo to warto wiedzieć,

03:42.200 --> 03:43.890
że JavaScript Oczywiście

03:43.890 --> 03:46.400
zna pojęcie typów.

03:46.400 --> 03:48.740
Wie o niektórych typach takich jak

03:48.740 --> 03:50.640
liczby, string i Boolean.

03:50.640 --> 03:52.300
Ale używanie tego zawsze oznacza,

03:52.300 --> 03:53.540
że możemy zawieść tylko

03:53.540 --> 03:56.400
w runtime zamiast podczas rozwoju, co jest lepszym

03:56.400 --> 03:58.700
miejscem dla nas jako dewelopera.

03:58.700 --> 04:01.550
Dzięki temu możemy wcześniej naprawiać błędy.

04:01.550 --> 04:02.840
A w dodatku JavaScript

04:02.840 --> 04:05.410
wie tylko o kilku typach.

04:05.410 --> 04:07.170
Jak dowiesz się w trakcie tego kursu.

04:07.170 --> 04:10.540
TypeScript wie o znacznie więcej typów niż JavaScript.

04:10.540 --> 04:14.450
Więc czy sprawdzanie runtime jest naprawdę nie tak elastyczne lub

04:14.450 --> 04:18.030
nie tak potężne, jak to, co możemy zrobić z TypeScript.

04:18.030 --> 04:19.490
I z tych wszystkich powodów to podejście

04:19.490 --> 04:20.660
nie jest właściwie podejściem,

04:20.660 --> 04:22.550
które chcemy tu zastosować.

04:22.550 --> 04:26.540
Czasami może być przydatne, aby uzyskać typ w czasie wykonywania.

04:26.540 --> 04:28.790
Ale czasami, jak w tym przykładzie, o

04:28.790 --> 04:31.740
wiele lepiej jest uzyskać go podczas rozwoju.

04:31.740 --> 04:34.280
Jedyną ważną rzeczą do rozpoznania oczywiście,

04:34.280 --> 04:36.070
po prostu jest to, że z TypeScript,

04:36.070 --> 04:38.670
dostajesz tylko wsparcie podczas rozwoju, a

04:38.670 --> 04:39.596
nie w runtime, ponieważ

04:39.596 --> 04:41.610
te funkcje i kontrole TypeScript nie

04:41.610 --> 04:44.650
są wbudowane w silnik JavaScript, więc logika nie może

04:44.650 --> 04:47.590
wykonać w przeglądarce, może tylko wykonać podczas

04:47.590 --> 04:51.223
rozwoju, gdy kompilujesz swój kod.
