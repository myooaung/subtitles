WEBVTT

00:02.040 --> 00:04.180
师：所以这是一堂非常基础的课｡ 

00:04.180 --> 00:08.400
在构建类时, 它们通常会变得更复杂｡

00:08.400 --> 00:10.800
您可能希望在其中存储更多数据｡ 

00:10.800 --> 00:15.160
比方说一个部门都应该有员工｡ 

00:15.160 --> 00:20.290
这可能是一个数组, 最初可能是一个空数组｡

00:20.290 --> 00:23.520
为了更精确地确定要在其中存储什么,

00:23.520 --> 00:24.980
它可以是一个字符串数组,

00:24.980 --> 00:28.800
以保持相对简单.

00:28.800 --> 00:31.733
现在我们可以在这里使用一个方法addEmployee｡ 

00:33.030 --> 00:36.880
在这里, 我们需要一个employee作为参数, 在我们的示例中,

00:36.880 --> 00:39.430
它应该只是一个字符串｡

00:39.430 --> 00:42.650
然后我们可以设置这个｡  员工｡  用力推｡ 

00:42.650 --> 00:48.373
因此, 使用以下代码将一个新雇员推送到雇员的数组中｡

00:50.750 --> 00:55.749
现在, 我们还可以添加另一个方法printEmployeeInformation｡

01:00.508 --> 01:12.766
我想安慰一下｡  记录（此. 员工｡  我也想安慰你｡

01:12.766 --> 01:12.766
记录（此. 员工）本身｡ 

01:15.510 --> 01:18.480
现在如果我们继续往下, 我们可以注释掉这里的代码,

01:18.480 --> 01:25.870
它会再次中断, 因为我们再次不符合部门描述和下面的对象｡

01:25.870 --> 01:29.200
而在这里, 在这个会计部门, 我们可以添加一个员工,

01:29.200 --> 01:32.234
比如说Max｡

01:32.234 --> 01:35.400
还有一个员工, 比如说马努.

01:35.400 --> 01:41.520
然后除了描述它, 我还想把我的员工信息放在那里｡

01:41.520 --> 01:44.600
如果我们保存这个, 我们应该得到这个输出,

01:44.600 --> 01:47.830
两个雇员和这里的一些信息｡

01:47.830 --> 01:50.240
现在这一切都很好｡ 

01:50.240 --> 01:52.700
这个类的一个问题是我们可以从外部更改雇员,

01:52.700 --> 01:55.960
不仅可以通过add employee,

01:55.960 --> 01:58.160
还可以通过直接访问雇员的属性,

01:58.160 --> 02:04.430
就像我们也可以对名字进行更改一样.

02:04.430 --> 02:07.630
所以我的意思是我们也可以去会计部,

02:07.630 --> 02:10.560
然后联系员工, 也许在索引2处再加一个员工,

02:10.560 --> 02:16.400
然后传递一个安娜, 就像这样｡

02:16.400 --> 02:18.210
如果我们这样做, 我们保存它,

02:18.210 --> 02:20.290
我们得到三个雇员, 我们得到安娜｡

02:20.290 --> 02:22.710
现在你可能会想, 太好了, 我们有另一种方法｡ 

02:22.710 --> 02:25.230
在构建更复杂的应用程序时,

02:25.230 --> 02:27.980
您通常希望避免类似的情况｡

02:27.980 --> 02:30.930
你要确保有一条清晰的路径, 一种使用类的方法,

02:30.930 --> 02:34.870
而诸如此类的东西, 使用类的替代方法,

02:34.870 --> 02:38.530
并不真正被支持｡

02:38.530 --> 02:41.230
因为如果你在一个更大的团队中工作,

02:41.230 --> 02:42.920
那么一个同事会使用这种方法来添加员工,

02:42.920 --> 02:48.050
另一个同事可能会使用这种方法｡

02:48.050 --> 02:49.280
你也不想这样｡ 

02:49.280 --> 02:52.640
你需要一种统一的方式来完成这件事｡ 

02:52.640 --> 02:58.420
另外, 因为在add employee方法中, 您可能要做的不仅仅是将其添加到数组中｡

02:58.420 --> 03:02.400
也许你首先想有一些验证等在这里｡

03:02.400 --> 03:04.940
所以你可能有额外的代码,

03:04.940 --> 03:06.610
如果你直接给数组赋值,

03:06.610 --> 03:09.470
或者用这一行给数组加一个新值,

03:09.470 --> 03:12.970
这些代码就不会执行.

03:12.970 --> 03:19.884
所以你不想允许员工像这样从课堂外被访问｡

03:19.884 --> 03:22.340
而TypeScript可以满足您的需求｡ 

03:22.340 --> 03:26.760
您可以在这里将employees转换为私有属性,

03:26.760 --> 03:32.220
即通过在其前面添加private关键字来转换为私有字段｡

03:32.220 --> 03:34.303
private的意思是,

03:34.303 --> 03:38.030
employees现在是一个属性, 只能从类内部访问,

03:38.030 --> 03:43.480
也就是从creative对象内部访问.

03:43.480 --> 03:49.770
所以department类中的任何方法仍然可以处理employee｡

03:49.770 --> 03:52.570
但你不能再这样访问了｡ 

03:52.570 --> 03:54.710
在这里, 您可以看到我现在得到一个错误｡ 

03:54.710 --> 03:57.280
如果我试图保存它, 我会得到一个编译错误,

03:57.280 --> 03:59.870
即属性'employees'是私有的,

03:59.870 --> 04:03.550
只能在类'department'中访问｡

04:03.550 --> 04:07.100
因此, 现在我们强制要求, 当雇员应该被添加到这个部门时,

04:07.100 --> 04:12.690
人们必须使用addEmployee方法｡

04:12.690 --> 04:16.760
因为 如果 他们 写 这样 的 代码 ,  他们 会 得到 一 个 错误 ｡ 

04:16.760 --> 04:20.460
这是一个所谓的修饰符, private关键字｡ 

04:20.460 --> 04:23.470
除了private, 我们还有public,

04:23.470 --> 04:25.000
这是默认的｡

04:25.000 --> 04:26.590
您不需要添加public｡ 

04:26.590 --> 04:31.650
所以像这样的名字和前面有public的名字是完全一样的｡

04:31.650 --> 04:36.350
不同之处在于公共属性可从外部访问｡

04:36.350 --> 04:43.600
例如, 如果我愿意, 我还可以在这里访问名称并分配一个新名称｡

04:43.600 --> 04:45.260
这是有可能的｡ 

04:45.260 --> 04:49.270
对于私有属性, 这在这里是不可能的｡ 

04:49.270 --> 04:51.580
我们只能从内部使用它们｡ 

04:51.580 --> 04:52.800
顺便说一下, 从技术上讲,

04:52.800 --> 04:55.700
JavaScript不知道public和private｡

04:55.700 --> 05:01.320
只有在非常现代的版本添加最近这样的事情存在｡

05:01.320 --> 05:05.690
过去, JavaScript不知道私有或公共属性｡

05:05.690 --> 05:08.520
所有的财产总是公共的｡ 

05:08.520 --> 05:10.630
TypeScript引入了这一特性,

05:10.630 --> 05:18.780
但它在运行时当然不起作用, 因为JavaScript直到最近才知道公共属性｡

05:18.780 --> 05:23.130
所以这一行, 在TypeScript编译期间冻结错误｡

05:23.130 --> 05:27.000
尽管如此, 如果您将其编译为JavaScript,

05:27.000 --> 05:34.900
此代码仍将在运行时执行而不会出错, 因为JavaScript本身直到最近才知道这个概念｡

05:34.900 --> 05:38.720
因此, 根据您编译的版本, 它仍然不会知道它｡

05:38.720 --> 05:40.770
因此, TypeScript只支持这一点,

05:40.770 --> 05:44.650
因为它在编译期间而不是在运行时检查它｡

05:44.650 --> 05:47.370
然而, 有了它, 我们可以避免这样的代码,

05:47.370 --> 05:49.863
并迫使每个人编写更干净的代码｡
