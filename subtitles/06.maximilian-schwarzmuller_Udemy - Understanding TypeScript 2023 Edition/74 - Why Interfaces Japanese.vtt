WEBVTT

00:02.250 --> 00:04.870
-：さて､ これらの強力な機能を知ったところで､ 当然の疑問として､

00:04.870 --> 00:07.960
なぜそれを使うのか､ ということがあります｡

00:07.960 --> 00:09.610
なぜそれが役に立つのか？

00:09.610 --> 00:15.820
まあ､ こういうときに便利なんですよ､ ある一定の機能を持たせたいということが分かっているときに｡

00:15.820 --> 00:18.750
例えば､ ある節がそのような greet メソッドを持っていて､

00:18.750 --> 00:24.450
別の節も同じように greet メソッドを持っていることを確認したい場合､ このメソッドの存在を

00:24.450 --> 00:29.570
強制するインターフェースを実装すればよいのです｡

00:29.570 --> 00:38.060
そして､ 各節は独自の実装､ つまりメソッドが呼ばれたときに実行されるべき正確なコードを追加しなければなりませんが､

00:38.060 --> 00:39.450
インターフェースの助けを借りて､

00:39.450 --> 00:43.280
一定の構造を強制することができます｡

00:43.280 --> 00:48.550
これは､ コードの他の部分にその構造に依存する部分がない場合に便利です｡

00:48.550 --> 00:51.680
ここでは user1 を Greetable

00:51.680 --> 00:55.240
型に設定し､ user の中身はどうでもいいが､

00:55.240 --> 01:03.510
greet メソッドは必ず入れておく必要があると述べています｡

01:03.510 --> 01:11.710
そのため､ オブジェクトや句のすべてを知る必要はなく､ user1で取得するものがgreetメソッドを持っていることだけを知っていれば､

01:11.710 --> 01:16.210
本当にパワフルで柔軟なコードを書くことができます｡

01:16.210 --> 01:20.630
Personが他の何かを持っているかどうかは気にしませんが､

01:20.630 --> 01:22.400
ここではgreetに興味があるので､

01:22.400 --> 01:25.180
Greetableに送りました｡ したがって､

01:25.180 --> 01:27.190
user1には何も格納できず､

01:27.190 --> 01:32.333
greetメソッドを持たないことになります｡
