WEBVTT

00:02.350 --> 00:03.921
المدرب: الآن ، لدينا أنواع اتحادات هنا.

00:03.921 --> 00:07.440
دعونا نبني على فكرة أنواع النقابات ونقدم

00:07.440 --> 00:09.764
أيضًا الأنواع الحرفية.

00:09.764 --> 00:14.290
الأنواع الحرفية هي أنواع لا تقول فيها فقط أن متغيرًا أو معلمة

00:14.290 --> 00:16.436
معينة يجب أن تصمد ، دعنا نقول

00:16.436 --> 00:19.700
رقمًا أو سلسلة ، ولكن عندما تكون واضحًا جدًا

00:19.700 --> 00:21.230
بشأن القيمة الدقيقة

00:21.230 --> 00:23.800
التي يجب أن تحملها.

00:23.800 --> 00:26.064
لقد رأينا ذلك في وقت مبكر هنا بالفعل في الأساسيات.

00:26.064 --> 00:28.408
رقم اثنين ، على سبيل المثال.

00:28.408 --> 00:32.098
هناك ، إذا قمت بالمرور فوق أن ترى أن النوع الذي تم استنتاجه

00:32.098 --> 00:35.680
ليس رقمًا ، فهو 2. 8.

00:35.680 --> 00:37.290
واستنتجت مجموعة الأنواع

00:37.290 --> 00:41.220
هذا الرقم الملموس كنوع هنا لأنه ثابت.

00:41.220 --> 00:43.810
لن يتغير أبدًا ، وبالتالي تعرف مجموعة الأنواع القيمة التي

00:43.810 --> 00:48.211
قمت بتعيينها هنا هي النوع المحدد الذي أمتلكه. لذلك بالطبع هذا رقم

00:48.211 --> 00:52.796
، يمكنك القول 2. 8 مشتق من نوع الرقم ولكنه

00:52.796 --> 00:56.320
رقم محدد. وهذا لا ينطبق فقط على

00:56.320 --> 00:59.160
الأرقام ، ولكن أيضًا على السلاسل

00:59.160 --> 01:02.860
وما إلى ذلك. وخاصة بالنسبة للسلاسل ، يمكن أن تكون مفيدة للغاية.

01:02.860 --> 01:07.420
لنفترض هنا في وظيفتنا المدمجة ، أننا نتوقع أرقامًا

01:07.420 --> 01:10.190
أو سلاسل ونجمعها بشكل مختلف بناءً

01:10.190 --> 01:13.756
على ما نحصل عليه ، لكننا نريد أيضًا أن نسمح

01:13.756 --> 01:18.756
للمتصل بالوظيفة بتحديد كيفية إرجاع النتيجة حتى نتمكن من

01:18.880 --> 01:22.530
فرض التحويل بشكل أساسي من رقم إلى سلسلة أو

01:22.530 --> 01:25.370
العكس. يمكننا القيام بذلك

01:25.370 --> 01:29.740
باستخدام المعلمة الثالثة ويمكننا تسمية ذلك لنقل نوع النتيجة

01:29.740 --> 01:33.208
أو تحويل النتيجة أو مع ذلك تريد تسميته وأريد

01:33.208 --> 01:37.240
وصف ذلك بسلسلة. لذلك سأقوم بتعيين هذا

01:37.240 --> 01:41.122
لكتابة سلسلة. الآن فكرتي هي أنه يمكنني

01:41.122 --> 01:45.625
الاتصال هنا برقمين وعلى سبيل المثال تمرير سلسلة

01:45.625 --> 01:50.625
من "as-number" والأمر متروك لك تمامًا للمعرف الذي

01:50.630 --> 01:55.630
تستخدمه هنا. هناك في الأسفل قد يكون لدينا "as-text"

01:56.260 --> 01:59.357
ولكن بعد ذلك قد يكون لدينا مجموعة أخرى

02:02.910 --> 02:07.310
هنا CombinedStringAges حيث أمرر في سلسلتين ولكني ما

02:07.310 --> 02:10.030
زلت أرغب في إخراج هذا "as-number"

02:10.030 --> 02:13.540
وستكون هذه الحالة حيث يمكن أن تكون المعلمة

02:13.540 --> 02:17.050
الثالثة مفيدة لفرض تحويل لأنني إذا قمت بتمرير

02:17.050 --> 02:19.950
سلسلتين هنا بشكل طبيعي ، فسنجعله في

02:19.950 --> 02:24.730
هذا الفرع الآخر ونقوم بتسلسله وقد أرغب في إرجاع هذا كرقم بدلاً

02:24.730 --> 02:29.639
من ذلك حتى أتمكن أيضًا من التحكم في تسجيل وكلاء السلاسل المدمجة

02:29.639 --> 02:34.030
هنا. لذا علينا الآن فقط أن نأخذ هذه المعرفات

02:34.030 --> 02:37.512
في الاعتبار في وظيفتنا من خلال تضمين resultConversion

02:37.512 --> 02:41.730
في عمليات التحقق إذا. السؤال الآن هو ماذا نريد

02:41.730 --> 02:45.700
أن نفعل بالضبط ؛ هل نريد التأكد من أنه يمكننا

02:45.700 --> 02:49.930
إجبار هاتين السلسلتين على إضافتهما كأرقام

02:49.930 --> 02:54.012
أو هل نريد فرض النتيجة بغض النظر عما إذا كانت

02:54.012 --> 02:58.695
عملية حسابية أو سلسلة سلسلة ليتم تحويلها إلى نص

02:58.695 --> 03:03.039
أو رقم. إذا أردنا فرض تحويل ، فيمكننا

03:03.039 --> 03:05.960
إضافة علامة if هنا والتحقق مما

03:05.960 --> 03:10.382
إذا كان تحويل النتيجة يساوي "as-number" وإذا

03:10.382 --> 03:15.340
كانت هذه هي الحالة ، فأنا أريد إرجاع النتيجة بعلامة

03:15.340 --> 03:18.826
زائد أمامها مما يحولها إلى رقم ، سيكون

03:18.826 --> 03:24.420
البديل هو parseFloat على سبيل المثال ، لكن هنا سأذهب فقط للإشارة

03:24.420 --> 03:33.593
لأن هذا أقصر قليلاً وإلا أريد إرجاع النتيجة إلى String لفرض الإخراج كسلسلة.

03:34.570 --> 03:38.883
الآن نقوم بالحساب على أساس النوع الحقيقي الذي نحصل عليه ولكن بعد

03:38.883 --> 03:42.300
ذلك نقوم بالتحويل إلى النتيجة وهذه طريقة واحدة للقيام

03:42.300 --> 03:46.360
بذلك وإذا حفظنا ذلك ثم قمنا بتجميع هذا الملف ، نرى أن هذه هي النتيجة

03:47.470 --> 03:51.020
التي أحصل عليها ونحصل على هذا الناتج على سبيل المثال

03:51.020 --> 03:54.759
لتركيبة السلسلة الخاصة بنا هنا لأنه كما قلت ، يتم إجراء

03:54.759 --> 03:58.520
المجموعة نفسها العملية الحسابية على أساس النوع الذي

03:58.520 --> 04:02.530
نقوم بتغذيته حيث يوجد هنا سلسلة ، لذلك نقوم بتسلسلها ثم نقوم

04:02.530 --> 04:05.860
بالتحويل إلى النتيجة.

04:05.860 --> 04:09.593
سيكون المنطق البديل هو التحقق من النوع

04:09.593 --> 04:14.320
هنا والقيام بعملية مختلفة بناءً على نوع الإرجاع

04:14.320 --> 04:19.180
الذي نحدده هنا. لذلك يمكننا التعليق على ذلك

04:19.180 --> 04:22.600
وبدلاً من ذلك نقول هنا ما إذا كان نوع الإدخال

04:22.600 --> 04:26.230
الأول هو رقم ونوع الإدخال الثاني هو رقم ، أو

04:27.890 --> 04:30.865
إذا كانت نتيجة التحويل تساوي "كرقم"

04:30.865 --> 04:35.865
، فأنا أريد دمج قيم مثل هذه والآن لتجنب هذا الخطأ ، هنا أقوم

04:35.930 --> 04:38.794
بفرض التحويل إلى أرقام عن طريق إضافة

04:38.794 --> 04:42.970
علامة زائد أمام كل إدخال بحيث يتم تحويل كل إدخال

04:42.970 --> 04:45.490
إلى رقم ويضمن أن يكون رقمًا قبل

04:45.490 --> 04:48.490
أن أقوم بدمجها.

04:48.490 --> 04:51.130
ملاحظة جانبية: إذا قمت بتمرير

04:51.130 --> 04:54.610
سلاسل لا يمكن تحويلها إلى رقم ، لذا ستحصل

04:54.610 --> 04:58.800
على NaN ، وليس رقمًا نتيجة لذلك.

04:58.800 --> 05:00.280
حسنًا ، في الحالة

05:00.280 --> 05:03.170
الأخرى ، حتى لا يكون لدينا "كرقم"

05:03.170 --> 05:07.976
، أو أنه ببساطة ليس لدينا مدخلات رقم ، ثم نجعلها في هذه الكتلة

05:07.976 --> 05:12.390
هنا والآن مع ذلك إذا أعدت النتيجة مرة أخرى هنا ، ثم

05:12.390 --> 05:16.230
نحفظ هذا ونعيد تجميعه ، سنرى ناتجًا مختلفًا

05:16.230 --> 05:20.230
على صفحتنا. نحصل الآن على 56 في هذين السطرين

05:20.230 --> 05:22.945
لأننا الآن لا نقوم بتحويل النتيجة ، لذا

05:22.945 --> 05:26.300
فنحن لا نقوم بتحويل السلسلة المتسلسلة لهذا السطر

05:26.300 --> 05:29.070
ولكن بدلاً من ذلك نقوم بالتحويل قبل أن نجمع

05:29.070 --> 05:31.970
القيمتين. إذن ، الأمر متروك لك بشأن المنطق

05:31.970 --> 05:34.760
الذي تريد تنفيذه. أريد في الواقع إلقاء نظرة

05:34.760 --> 05:37.551
فاحصة على مفهوم الأنواع الحرفية الذي وصفته

05:37.551 --> 05:41.180
في بداية هذه المحاضرة. أقوم بتمرير "as-number"

05:41.180 --> 05:44.157
و "as-text" وسلبيات الأعمال التي يتعين

05:44.157 --> 05:47.600
علينا الآن كمطور حفظ هذه القيم.

05:47.600 --> 05:50.450
علينا التأكد من عدم تفويت الكتابة هنا.

05:50.450 --> 05:54.010
الآن يمكننا استخدام رقم e-num لتحسين ذلك ، ولكن إذا

05:54.010 --> 05:57.754
كان لدينا قيمتان فقط هنا ، "as-text" أو "as-number" ،

05:57.754 --> 06:00.940
فربما يكون كل البحث من النوع الحرفي خيارًا.

06:00.940 --> 06:04.173
يمكننا أن نقول "لا ينبغي أن يكون

06:04.173 --> 06:09.173
هذا أي سلسلة ، يجب أن يكون" كرقم "أو" كنص "، لذلك نستخدم

06:09.870 --> 06:12.090
نوع اتحاد مدمجًا مع أنواع

06:12.090 --> 06:15.573
حرفية. الأنواع الحرفية هي الأنواع

06:15.573 --> 06:17.987
التي تعتمد على أنواعك الأساسية ، سلسلة

06:17.987 --> 06:20.933
ورقم وما إلى ذلك ، ولكن بعد ذلك يكون لديك إصدار

06:20.933 --> 06:24.750
محدد من النوع. لذا هنا ، نسمح على وجه التحديد بهاتين

06:24.750 --> 06:27.960
السلسلتين وليس أي سلسلة فقط بهاتين السلاسل.

06:27.960 --> 06:31.460
لذلك نريد سلسلة للتحويل الناتج ، لكن يجب أن تكون إحدى

06:31.460 --> 06:34.207
هاتين القيمتين. لن يُسمح بأي قيمة سلسلة

06:34.207 --> 06:37.560
أخرى ، لذا فهذه هي الفكرة الكامنة وراء النوع الحرفي وغالبًا

06:37.560 --> 06:40.747
ما ستستخدم هذا في سياق نوع الاتحاد لأنك لا تريد فقط السماح

06:40.747 --> 06:43.700
بقيمة واحدة محددة يمكنك ترميزها في التعليمات البرمجية

06:43.700 --> 06:46.500
الخاصة بك إذا كان هذا هو الحال ولكنك تريد أن يكون

06:46.500 --> 06:49.544
لديك قيمتان محتملتان أو أكثر.

06:49.544 --> 06:52.580
في هذه الحالة حصلنا على قيمتين محتملتين.

06:52.580 --> 06:56.240
لذلك نحن نضمن الآن الحصول على تحويل النتيجة الذي

06:56.240 --> 07:00.288
يكون إما "كرقم" أو "كنص" وعلى سبيل المثال هنا ، إذا حاولت

07:00.288 --> 07:03.800
الآن مقارنة هذا بـ as-numbe نظرًا لوجود خطأ

07:03.800 --> 07:07.256
إملائي هنا ، فإن مجموعة الأنواع هي قادر على إخباري

07:07.256 --> 07:10.360
هنا في IDE وبالطبع كل ما نحفظه ونجمعه هنا

07:10.360 --> 07:15.360
في المحطة لأنه يعرف أن as-numbe بدون r في النهاية لن يكون قيمة صالحة

07:15.830 --> 07:18.940
لـ resultConversion لأنني قمت بتعيين

07:18.940 --> 07:24.563
هذا النوع من الاتحاد مع هذه الأنواع الحرفية.

07:25.550 --> 07:27.593
لذا اكتسبنا الآن مرة أخرى نوعًا

07:27.593 --> 07:31.590
إضافيًا من الأمان وتأكدنا من عدم استخدام هذا بشكل غير صحيح.

07:31.590 --> 07:34.720
نفس الشيء بالنسبة لتمرير القيمة. إذا كان لدينا خطأ مطبعي

07:34.720 --> 07:38.747
هنا ، فإننا نحصل على خطأ فقط إذا استخدمنا إما "كرقم" أو "كنص"

07:38.747 --> 07:41.947
، يُسمح لنا بتجميع هذا كما تراه ونقوم الآن بتجميع

07:41.947 --> 07:45.470
هذا ، وهذا يعمل ونحصل على نفس الشيء الإخراج كما كان

07:45.470 --> 07:49.562
من قبل هنا. لذلك فهذه أنواع حرفية مفيدة بشكل

07:49.562 --> 07:52.193
خاص عند استخدامها مع أنواع الاتحاد.
