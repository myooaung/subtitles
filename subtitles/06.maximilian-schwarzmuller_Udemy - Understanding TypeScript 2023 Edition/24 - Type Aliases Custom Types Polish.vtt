WEBVTT

00:02.340 --> 00:05.860
-: Teraz podczas pracy z typami unii, takimi

00:05.860 --> 00:06.970
jak to i to, może

00:06.970 --> 00:11.070
być kłopotliwe, aby zawsze powtarzać typ unii.

00:11.070 --> 00:13.070
Możesz chcieć handlować nowym typem,

00:13.070 --> 00:15.330
który ponownie instaluje ten typ związku.

00:15.330 --> 00:18.540
I możesz to zrobić dzięki kolejnej fajnej funkcji

00:18.540 --> 00:21.410
typów, funkcji aliasów typów.

00:21.410 --> 00:22.723
Tworzysz taki alias,

00:24.280 --> 00:25.670
zazwyczaj przed jego

00:25.670 --> 00:29.240
użyciem, więc tutaj na górze pliku w tym przypadku tutaj,

00:29.240 --> 00:31.240
ze słowem kluczowym type.

00:31.240 --> 00:34.040
Teraz słowo kluczowe type nie jest wbudowane w JavaScript,

00:34.040 --> 00:35.880
jest jednak obsługiwane w TypeScript,

00:35.880 --> 00:40.450
a po typie dodajesz nazwę swojego niestandardowego typu lub swojego aliasu typu,

00:40.450 --> 00:42.860
powinienem powiedzieć.

00:42.860 --> 00:44.980
Na przykład combinable.

00:44.980 --> 00:46.720
Ale nazwa zależy tak naprawdę od Ciebie.

00:46.720 --> 00:48.380
Możesz wymyślić tutaj dowolną nazwę,

00:48.380 --> 00:50.520
która nie jest wbudowana w JavaScript lub

00:50.520 --> 00:52.530
TypeScript jako nazwa klucza.

00:52.530 --> 00:54.360
Więc coś takiego jak data nie byłoby dozwolone,

00:54.360 --> 00:56.250
ponieważ jest to wbudowane w JavaScript, ale

00:56.250 --> 00:58.900
combinable nie jest wbudowane w JavaScript, nie jest wbudowane

00:58.900 --> 01:01.170
w TypeScript, więc możemy go używać.

01:01.170 --> 01:04.550
I teraz znakiem równości przypisujesz typ, który

01:04.550 --> 01:08.320
chcesz zakodować w swoim aliasie, że tak powiem.

01:08.320 --> 01:10.300
Możemy więc przechowywać tutaj liczbę,

01:10.300 --> 01:12.790
a teraz, gdy chcemy się upewnić, że coś powinno

01:12.790 --> 01:14.390
być liczbą, możemy zamiast

01:14.390 --> 01:16.400
tego użyć combinable.

01:16.400 --> 01:18.570
Teraz nie ma to zbyt wiele sensu, prawdopodobnie

01:18.570 --> 01:21.630
nawet sprawiłoby, że nasz kod byłby trudniejszy do odczytania.

01:21.630 --> 01:25.500
Jeśli użyłbym combinable tam na dole na przykład, to działałoby

01:25.500 --> 01:27.420
to technicznie, ale jeśli po prostu

01:27.420 --> 01:29.550
rzucimy okiem na nasz kod, nie jest

01:29.550 --> 01:33.180
oczywiste, że tutaj chcemy liczby lub ciągu.

01:33.180 --> 01:35.560
Cóż, zazwyczaj dlatego używasz tego w

01:35.560 --> 01:37.500
połączeniu z typami związków.

01:37.500 --> 01:40.380
Możemy więc przechowywać typ union w naszym typie

01:40.380 --> 01:42.250
niestandardowym, czyli w naszym

01:42.250 --> 01:45.240
aliasie typu, a teraz po prostu odnosić się do combinable

01:45.240 --> 01:48.170
tam na dole zamiast naszego typu union.

01:48.170 --> 01:51.060
Mamy więc dokładnie taką samą konfigurację jak wcześniej,

01:51.060 --> 01:54.230
mamy tylko nasz alias typu wielokrotnego użytku tutaj, którego

01:54.230 --> 01:55.580
możemy użyć zamiast tego.

01:55.580 --> 01:57.660
I to pozwala nam zaoszczędzić trochę dodatkowego

01:57.660 --> 01:59.200
kodu i upewnić się, że zawsze odnosimy

01:59.200 --> 02:04.200
się do tych samych typów lub tej samej konfiguracji typu, gdy używamy combinable.

02:04.234 --> 02:06.600
I oczywiście nie możemy tego użyć tylko dla liczby

02:06.600 --> 02:08.970
i łańcucha, możemy użyć tego dla każdej konfiguracji

02:08.970 --> 02:11.140
typu, którą możemy chcieć przechowywać

02:11.140 --> 02:14.810
w aliasie, w tym te dwa typy literalne, na przykład.

02:14.810 --> 02:18.210
Tak więc, dla tych dwóch typów tutaj, dla tego typu unii,

02:18.210 --> 02:20.660
moglibyśmy również handlować aliasem

02:20.660 --> 02:24.030
typu, ConversionDescriptor, lub jakkolwiek chcesz

02:24.030 --> 02:28.920
go nazwać, i przechowywać dokładnie ten typ w tym aliasie typu.

02:28.920 --> 02:32.270
I teraz możemy użyć tego aliasu typu tam na dole.

02:32.270 --> 02:34.970
Więc aliasy typów są naprawdę, naprawdę przydatne.

02:34.970 --> 02:37.490
Możesz zakodować bardziej złożone definicje typów

02:37.490 --> 02:40.860
do własnych typów, do własnych nazw typów, że tak powiem, i ponownie

02:40.860 --> 02:43.120
użyć tego wszędzie w swoim kodzie, gdzie potrzebujesz

02:43.120 --> 02:45.920
dokładnie tej konfiguracji typu.

02:45.920 --> 02:48.060
Tak, że unikasz literówek tam na dole i

02:48.060 --> 02:51.000
możesz po prostu zaoszczędzić kod, napisać kod szybciej

02:51.000 --> 02:53.490
i zawsze być jaśniejszym o swoich intencjach,

02:53.490 --> 02:56.010
na przykład wybierając opisowe nazwy aliasów

02:56.010 --> 02:57.653
typu tam na górze.
