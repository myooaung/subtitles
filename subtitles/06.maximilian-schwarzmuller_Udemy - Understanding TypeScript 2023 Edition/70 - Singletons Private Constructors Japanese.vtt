WEBVTT

00:02.260 --> 00:04.960
-ーー最後にもうひとつ､

00:04.960 --> 00:10.330
プライベートコンストラクタを紹介します｡

00:10.330 --> 00:13.823
また､ プライベート・コンストラクタとはどのようなもので､ どのような使い道があるのでしょうか？

00:14.870 --> 00:20.460
オブジェクト指向プログラミングには､ シングルトンパターンと呼ばれるパターンがある｡

00:20.460 --> 00:28.030
シングルトンパターンは､ あるクラスのインスタンスを常に正確に1つだけ持つことを保証するものです｡

00:28.030 --> 00:30.558
これは､ 静的なメソッドやプロパティが使えない､

00:30.558 --> 00:36.440
あるいは使いたくないが､ 同時に､ あるクラスを元にした複数のオブジェクトは作れないが､

00:36.440 --> 00:44.630
あるクラスを元にしたオブジェクトは常に正確に一つであることを確認したいというシナリオで役に立ちます｡

00:44.630 --> 00:47.660
例えば､ AccountingDepartmentの場合､

00:47.660 --> 00:57.840
このクラスに基づいて作成できるオブジェクトは､ 会社全体で1つだけであることを確認したいとします｡

00:57.840 --> 01:00.260
IT部門は複数あるかもしれませんが､

01:00.260 --> 01:03.290
経理部門はきっちり1つです｡

01:03.290 --> 01:05.310
これを強制し､ 手動で何度も new AccountingDepartment

01:05.310 --> 01:09.020
を呼び出すことを避けるために､ AccountingDepartment

01:09.020 --> 01:18.860
クラスのコンストラクタの前に private キーワードを追加して private コンストラクタにすることができるようになりました｡

01:18.860 --> 01:23.480
これで､ この上でnewを呼び出すことができなくなりました｡

01:23.480 --> 01:25.160
コンストラクタが private

01:25.160 --> 01:27.620
なので､ クラスの内部からしかアクセスできないため､

01:27.620 --> 01:37.920
エラーが発生します｡ このクラスに基づいてオブジェクトを作成できないのであれば､ どうやってクラスの内部に入るのでしょうか｡

01:37.920 --> 01:40.490
その答えは､ そう､ 静的メソッドです｡ 

01:40.490 --> 01:46.250
静的メソッドはクラス自体で呼び出せるので､ そのためにインスタンス化する必要はない｡

01:46.250 --> 01:53.260
ここで静的メソッドを追加して､ getInstanceと呼ぶことができます｡

01:53.260 --> 01:56.930
ここでgetInstanceはこのクラスのインスタンスがすでにあるかどうかをチェックし､

01:56.930 --> 02:00.090
なければ新しいインスタンスを返します｡

02:00.090 --> 02:04.300
そのために､ 新しい静的プロパティインスタンスを追加します｡ 静的プライベートプロパティなので､

02:04.300 --> 02:12.040
AccountingDepartment型と呼ばれる静的インスタンスの前にprivateを付けることができます｡

02:12.040 --> 02:16.570
そこで､ そこにAccountingDepartmentのインスタンスを格納することにします｡ 

02:16.570 --> 02:19.100
つまり､ クラス自体からアクセス可能な静的プロパティがありますが､

02:19.100 --> 02:25.960
クラスの内部からのみアクセス可能で､ そこに格納する値は AccountingDepartment 型であり､

02:25.960 --> 02:30.140
クラス自体のものです｡

02:30.140 --> 02:38.880
ここで､ このインスタンスプロパティをgetInstanceで使用し､ このようになるかどうかをチェックすることができます｡

02:38.880 --> 02:38.880
インスタンスがstaticの内部に設定されている場合､

02:39.260 --> 02:47.610
これを使用すると､ クラス自体を参照し､ そのクラスに関する他のすべての静的プロパティにアクセスすることができます｡

02:47.610 --> 02:51.963
その代わりとして､ クラス名を使用することになります｡ 

02:53.720 --> 03:01.600
そして､ これが設定されていれば､ これを返したいのです｡  インスタンス､ または再びクラス名を指定します｡

03:01.600 --> 03:01.600
インスタンスにアクセスできますが､

03:05.680 --> 03:13.550
静的メソッドではクラスそのものにアクセスできます｡

03:13.550 --> 03:17.290
しかし､ ここに入れないと､ まだインスタンスがないことになるので､

03:17.290 --> 03:22.030
これを設定します｡ インスタンスの静的インスタンス・プロパティは

03:22.030 --> 03:44.830
new AccountingDepartment に等しいので､ このクラス・メソッドの内部からこれを使用することができます｡

03:44.830 --> 03:44.830
のインスタンスはこちらです｡ 

03:44.830 --> 03:47.010
つまり､ すでに持っているインスタンスを返すか､

03:47.010 --> 03:50.970
まだ持っていない場合は新たにインスタンスを作成することになります｡

03:50.970 --> 03:53.270
しかし､ このマークされたコードは一度しか実行できません｡

03:53.270 --> 04:00.370
なぜなら､ 一度インスタンスを作成すると､ それをこのifブロックに作成し､ 既存のインスタンスを返すからです｡

04:00.370 --> 04:03.700
では､ AccountingDepartmentを操作する場合､ このように作成するのではなく､ const

04:03.700 --> 04:10.153
accounting AccountingDepartmentと呼ぶことができます｡

04:10.153 --> 04:10.153
を取得し､

04:11.646 --> 04:14.850
AccountingDepartmentの新しいインスタンスを返します｡

04:14.850 --> 04:18.190
しかし､ もう一度やってみると､ ここでコンソールログaccountingとaccounting2を見ればわかるように､

04:18.190 --> 04:23.570
同じインスタンスが表示されます｡

04:23.570 --> 04:28.253
保存してリロードすると､

04:30.550 --> 04:47.900
2つのAccountingDepartmentオブジェクトがあるのがわかると思います｡

04:47.900 --> 04:52.490
これは､ 間違いなく､ 常に使える方法ではないでしょう｡

04:52.490 --> 04:55.010
シングルトンパターンは便利な場合もあるが､

04:55.010 --> 04:56.530
常に必要なわけではない｡

04:56.530 --> 05:00.360
しかし､ プライベートコンストラクタのおかげでTypeScriptで簡単に実装できる興味深いものなので､

05:00.360 --> 05:04.923
知っておく価値はあるだろう｡
