WEBVTT

00:02.460 --> 00:05.590
-: لذلك يتم دعم المصفوفات مع الأرقام والسلاسل والبولونات

00:05.590 --> 00:07.620
والأشياء والمصفوفات.

00:07.620 --> 00:11.400
لقد حصلنا على القيم الأساسية أو أنواع القيم ، JavaScript

00:11.400 --> 00:15.100
nos مدعومة في TypeScript ، كما ستتعلم في مثال الكائنات

00:15.100 --> 00:17.884
في المصفوفات الخاصة بهم ، حتى أن TypeScript

00:17.884 --> 00:21.520
تقدم طريقة أكثر وظيفية ولكنها أكثر تقدمًا ، ولهذا السبب

00:21.520 --> 00:22.720
سيكون لدينا إلقاء

00:22.720 --> 00:24.940
نظرة على ذلك لاحقًا ، ولكن حتى هذه

00:24.940 --> 00:26.810
الأنواع الأساسية مع ما ستتعلمه

00:26.810 --> 00:30.140
في المحاضرات السابقة مدعومة.

00:30.140 --> 00:33.540
الآن ، يحمل TypeScript عدة مفاهيم جديدة ،

00:33.540 --> 00:37.840
أنواع جديدة ، والتي لا نعرفها من نصوص جافا الفانيليا

00:37.840 --> 00:40.300
على سبيل المثال ، نوع tuple.

00:40.300 --> 00:44.360
الآن قد تعرف tuples من لغات البرمجة الأخرى ، لكن JavaScript

00:44.360 --> 00:46.570
لا يحتوي عليها.

00:46.570 --> 00:49.570
هذا هو tuple على سبيل المثال ، ويمكن القول ،

00:49.570 --> 00:52.290
حسنًا هذه مصفوفة. إنها مصفوفة ، لكنها

00:52.290 --> 00:54.520
مصفوفة ذات طول ثابت وهي في الواقع

00:54.520 --> 00:58.650
ليست فقط بطول ثابت ولكن أيضًا من النوع الثابت.

00:58.650 --> 01:00.730
وأين يمكن أن يكون هذا في متناول يدي؟

01:00.730 --> 01:03.350
دعنا نقول هنا على شخصنا

01:03.350 --> 01:07.830
، لدينا بالفعل عدد من الخصائص ، الدور ، وهو

01:07.830 --> 01:11.160
مصفوفة تحتوي على عنصرين بالضبط

01:11.160 --> 01:14.184
، حيث يكون العنصر الأول هو معرف

01:14.184 --> 01:18.547
رقمي مثل اثنين والثاني هو معرف سلسلة وإنسان

01:18.547 --> 01:22.765
وصف مقروء مثل المؤلف.

01:22.765 --> 01:26.496
الآن يجب أن يحتوي هذا دائمًا على عنصرين بالضبط لأن

01:26.496 --> 01:30.100
المستخدم أو الشخص في هذا التطبيق الذي نكتبه ، دعنا

01:30.100 --> 01:32.720
نقول أنه يمكن أن يكون له دور واحد فقط

01:32.720 --> 01:35.185
والدور يتكون فقط من عنصرين.

01:35.185 --> 01:37.400
بالطبع كان بإمكاننا استخدام البصريات

01:37.400 --> 01:39.090
هنا ، ولكن لسبب ما نريد أن يكون

01:39.090 --> 01:41.744
لدينا مصفوفة تحتوي على عنصرين بالضبط حيث

01:41.744 --> 01:43.118
يكون العنصر الأول دائمًا

01:43.118 --> 01:47.570
هو المعرف الرقمي والعنصر الثاني دائمًا هو معرف السلسلة أو الوصف أو مع

01:47.570 --> 01:50.220
ذلك تريد الاتصال هو - هي.

01:50.220 --> 01:52.420
الآن ، إذا قمنا بالتمرير فوق TypeScript

01:52.420 --> 01:55.730
هذا بالفعل يستنتج هذا النوع الغريب الذي لم نره من قبل

01:55.730 --> 01:58.550
، في الواقع ، إذا كنا نعني أن TypeScript يفهم أن

01:58.550 --> 02:01.250
لدينا مصفوفة قد تحتوي على سلاسل أو أرقام ، فهذا

02:01.250 --> 02:03.440
نوع من الاتحاد ونحن ' سوف نتعمق في هؤلاء

02:03.440 --> 02:06.710
لاحقًا. الفكرة الأساسية هي أن

02:06.710 --> 02:09.950
TypeScript يفهم أن هذا يجب أن يكون مصفوفة بهذه

02:09.950 --> 02:11.668
الأنواع من القيم.

02:11.668 --> 02:14.580
العيوب التي ماتت يمكننا تشغيل

02:14.580 --> 02:18.780
هذا الكود رغم ذلك ، دور الشخص ، دفع ، مشرف.

02:18.780 --> 02:20.250
الآن بالنسبة لتطبيقنا ،

02:20.250 --> 02:21.970
قد لا يكون هذا منطقيًا لأننا

02:21.970 --> 02:23.960
نعلم أننا نحتاج فقط إلى عنصرين.

02:23.960 --> 02:25.790
لا يزال TypeScript لا يعرف

02:25.790 --> 02:28.963
أننا نريد عنصرين فقط. سنكون قادرين أيضًا

02:28.963 --> 02:33.283
على تبديل دور الشخص ، والعنصر الثاني مع فهرس واحد

02:33.283 --> 02:35.200
ليكون رقمًا أيضًا.

02:35.200 --> 02:38.010
قد ينجح هذا لأن TypeScript يعرف فقط أن الدور

02:38.010 --> 02:42.360
يجب أن يكون من نوع سلسلة أو مصفوفة أرقام ، وبالتالي فإن تعيين رقم

02:42.360 --> 02:44.700
هنا للعنصر الثاني وبالتالي استبداله

02:44.700 --> 02:46.870
برقم سيكون مسموحًا به لأننا نقول

02:46.870 --> 02:48.680
شيئًا ما عن الأنواع التي نستخدمها

02:48.680 --> 02:52.580
بشكل عام يمكن استخدامها هناك.

02:52.580 --> 02:55.040
نحن نعلم أننا نريد أن يكون لدينا هذا الهيكل بالضبط.

02:55.040 --> 02:58.094
عنصران ، رقم العنصر الأول ، وسلسلة العنصر الثانية

02:58.094 --> 03:01.770
، لكن TypeScript لا يفعل ذلك. حسنًا في مثل هذا السيناريو

03:01.770 --> 03:05.865
، ستكون المجموعة مثالية. يمكننا إخبار TypeScript

03:05.865 --> 03:10.865
بالدور الذي يجب أن يكون ، من خلال تحديد نوع الدور بشكل صريح.

03:11.010 --> 03:13.230
إذن لدينا هنا أيضًا مثال حيث

03:13.230 --> 03:16.600
لا يوجد نوع ضوئي من TypeScript ، لكننا نريد

03:16.600 --> 03:19.927
صراحة تجاوزه. الآن يمكننا هنا إضافة نوع

03:19.927 --> 03:23.041
كائن صريح عن طريق إضافة نقطتين بعد شخص ، ثم الأقواس

03:23.041 --> 03:27.023
المتعرجة ثم الأسماء يجب أن تكون سلسلة ، والعمر يجب أن يكون

03:27.023 --> 03:31.180
رقمًا والهوايات يجب أن تكون مصفوفة سلسلة.

03:31.180 --> 03:33.740
كل ذلك كما استنتج من قبل TypeScript.

03:33.740 --> 03:35.401
لذلك ، لم نكن لنطلب ، هذا

03:35.401 --> 03:36.827
التعيين الصريح وكما

03:36.827 --> 03:38.789
تعلم أنه سيكون سيئًا.

03:38.789 --> 03:40.470
لكن الآن لدينا سيناريو

03:40.470 --> 03:43.565
، حيث لا يعمل الاستدلال بالطريقة التي

03:43.565 --> 03:47.510
نريدها ، ونريد تعيين الدور ليكون مجموعة.

03:47.510 --> 03:49.730
الآن بدلاً من تعيين مصفوفة من سلسلتين أو

03:49.730 --> 03:51.660
مصفوفة أرقام أو استخدام نفس النوع

03:51.660 --> 03:55.180
الذي لم يكن ثالثًا هنا سابقًا ، يمكننا الآن استخدام نوع خاص.

03:55.180 --> 03:56.810
نستخدم الأقواس المربعة

03:56.810 --> 04:01.710
مرة أخرى ، ولكن الآن داخل الأقواس المربعة نضيف رقمًا ، ثم

04:01.710 --> 04:03.637
فاصلة ثم سلسلة.

04:03.637 --> 04:07.340
الآن هذا يشير إلى نوع tuple هنا.

04:07.340 --> 04:10.729
إن tuple هو بناء خاص ، كما يفهم TypeScript ، في Java scripted

04:10.729 --> 04:13.310
سيكون مصفوفة عادية ، لكن أثناء التطوير باستخدام

04:13.310 --> 04:15.750
TypeScript ، سنحصل على أخطاء في التعليمات

04:15.750 --> 04:18.190
البرمجية مثل هذا هنا.

04:18.190 --> 04:20.313
الآن ماذا تفعل المجموعات؟

04:21.620 --> 04:23.564
هذا هنا ، يقول TypeScript ،

04:23.564 --> 04:27.195
أريد أن يكون لدي مصفوفة خاصة ، تحتوي على عنصرين بالضبط

04:27.195 --> 04:30.160
، لأن لدي نوعين بالضبط هناك والعنصر الأول

04:30.160 --> 04:32.020
يجب أن يكون رقمًا.

04:32.020 --> 04:35.436
يجب أن يكون العنصر الثاني عبارة عن سلسلة

04:35.436 --> 04:39.033
، وبالتالي ، إذا قمنا بتجميع هذا الرمز هنا ،

04:40.663 --> 04:45.000
فسأحصل على خطأ بخصوص 10 غير قابلة للتخصيص كنوع هنا ،

04:45.000 --> 04:48.346
لأننا نريد أن يكون لدينا سلسلة كقيمة ثانية

04:48.346 --> 04:50.822
وإذا قمت بعد ذلك بتعيين 10 كـ a

04:50.822 --> 04:52.660
القيمة الثانية هنا ، إذن

04:52.660 --> 04:56.544
من الواضح أنني لا أتبع هذه القاعدة.

04:56.544 --> 05:01.544
إذا قمت بالتعليق على هذا وقمنا بتجميعه ، فهذا يعمل.

05:02.240 --> 05:06.290
هذا غريب بعض الشيء لأن دفع العمل هنا ، لأننا جميعًا

05:06.290 --> 05:08.610
نقول أن هذا الدور يجب أن يحتوي

05:08.610 --> 05:11.901
على عنصرين بالضبط ، فلماذا يمكننا دفع المسؤول

05:11.901 --> 05:14.980
إلى مصفوفة الدور هنا.

05:14.980 --> 05:19.300
الدفع هو في الواقع استثناء مسموح به في المجموعات.

05:19.300 --> 05:22.410
لذلك ، للأسف ، لا تستطيع TypeScript اكتشاف

05:22.410 --> 05:24.840
هذا الخطأ ، ولكنها على الأقل تضمن

05:24.840 --> 05:28.570
عدم تعيين قيمة خاطئة هنا ، وخارج الدفع ، نحصل أيضًا

05:28.570 --> 05:31.500
على بعض الدعم فيما يتعلق بالطول.

05:31.500 --> 05:33.671
إذا وضعنا هذا الدور على قيمة جديدة.

05:33.671 --> 05:36.420
على سبيل المثال ، لا يُسمح بمصفوفة فارغة

05:36.420 --> 05:39.710
، يُسمح بمصفوفة تحتوي على البنية التي حددناها

05:39.710 --> 05:43.510
بالضبط هناك ، إذا أضفت عنصرًا إضافيًا هنا.

05:43.510 --> 05:45.880
ثم سنحصل على خطأ مرة أخرى.

05:45.880 --> 05:49.300
لذلك يتم فرض الطول إذا قمنا بتعيينه على هذا النحو ، ولكن

05:49.300 --> 05:50.720
ليس للدفع وما إلى ذلك.

05:50.720 --> 05:52.840
هذا شيء يجب أن تكون على دراية

05:52.840 --> 05:55.580
به ، ولكن لا تزال تحصل على هذا الدعم وهذا

05:55.580 --> 05:57.899
الدعم ، فهو أمر رائع جدًا وإذا كان

05:57.899 --> 06:02.240
لديك سيناريو حيث تحتاج بالضبط X كمية من القيم في مصفوفة وتعرف

06:02.240 --> 06:05.130
نوع كل قيمة مقدمًا ، ثم قد ترغب في التفكير

06:05.130 --> 06:07.900
في tuple بدلاً من المصفوفة للحصول على

06:07.900 --> 06:11.313
مزيد من الصرامة في تطبيقك حتى تكون أكثر وضوحًا

06:11.313 --> 06:15.230
بشأن نوع البيانات التي تعمل بها ونوع البيانات التي

06:15.230 --> 06:17.543
تتوقعها.
