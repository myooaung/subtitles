WEBVTT

00:02.251 --> 00:05.350
講師：もうひとつ､ プロパティとメソッドに関連した素晴らしい機能があります｡

00:05.350 --> 00:14.010
これはES6以降を使用している場合､ JavaScriptにも存在しますが､ タイプスクリプトはすべて静的プロパティとメソッドになっています｡

00:14.010 --> 00:20.620
静的なプロパティとメソッドは､ クラスのインスタンス上でアクセスされないプロパティとメソッドをクラスに追加することができます｡

00:20.620 --> 00:28.950
したがって､ 最初に新しいクラス名を呼び出す必要はなく､ クラス上で直接アクセスすることができます｡

00:28.950 --> 00:35.922
これは､ 論理的にグループ化したりクラスにマッピングしたりしたいユーティリティ関数や､

00:35.922 --> 00:40.860
クラスに格納したいグローバル定数などによく使われます｡

00:40.860 --> 00:43.270
JavaScriptに組み込まれている例として､

00:43.270 --> 01:01.400
typescriptで定義されているわけでも､ あなたが定義しているわけでもありませんが､ ブラウザのJavaScriptの一部であるMathコンストラクタ関数､ またはこのように呼びたい場合はクラス､

01:01.400 --> 01:08.610
JavaScriptでグローバルに利用可能です｡

01:08.610 --> 01:13.370
これらは､ Mathのインスタンスではアクセスしないメソッドやプロパティです｡

01:13.370 --> 01:16.310
まず新しい数学を呼ぶ必要はない｡ 

01:16.310 --> 01:22.360
確かにそれではうまくいきませんが､ クラス自体のメソッドで直接これらのプロパティにアクセスするのです｡

01:22.360 --> 01:28.640
静的メソッドやプロパティは一般的な使用例で､

01:28.640 --> 01:33.650
自分のクラスにも追加できます｡

01:33.650 --> 01:40.050
Departmentに従業員を作成するためのメソッドが必要だとします｡

01:40.050 --> 02:07.621
これはDepartmentをインスタンス化しなくてもアクセスできるようにしたいもので､ 通常､ IT部門や会計部門などより専門的なバージョンをインスタンス化し､ ユーティリティメソッドを呼び出すためだけにDepartmentをインスタンス化したくありません｡

02:07.621 --> 02:12.920
このメソッドを静的メソッドにして､ このクラスをインスタンス化せずにアクセスできるようにするには､

02:12.920 --> 02:16.250
このメソッドの前にstaticキーワードを追加します｡

02:16.250 --> 02:23.549
そして､ このメソッドの中で､ nameプロパティがこのname値にマップされたオブジェクトを返すようにします｡

02:25.170 --> 02:27.010
もちろん､ これは非常にシンプルな方法ですが､

02:27.010 --> 02:28.690
イメージはつかめると思います｡

02:28.690 --> 02:36.940
このコードを使って､ 新しい従業員(employee1)を作成することができます｡

02:39.300 --> 02:46.020
それなら､ Departmentで解決すればいいんです｡

02:46.020 --> 02:46.020
createEmployee

02:46.920 --> 02:50.680
を作成し､ 例えば Max を渡すと､ console. log(employee1) に Max

02:50.680 --> 02:53.170
という名前のオブジェクトが表示されるはずです｡

02:53.170 --> 02:58.240
これを保存すると､ 確かに先ほど作成した社員がここにいます｡

02:58.240 --> 03:01.200
つまり､ これは静的メソッドの典型的な例でしょう｡ 

03:01.200 --> 03:06.360
そのため､ クラスをグループ化のメカニズムとして使用し､

03:06.360 --> 03:13.470
静的プロパティを追加することもできます｡

03:13.470 --> 03:17.950
例えば､ 会社で使用したい fiscalYear があれば､

03:19.730 --> 03:24.980
これを 2020 に設定し､ インスタンス化せずに使用できるように､ このプロパティの前､

03:24.980 --> 03:28.560
あるいはフィールドの前に static を追加し､

03:28.560 --> 03:33.950
アクセスできるようにすることができます｡

03:33.950 --> 03:36.560
だから今､ そこのコンソールの下に｡  ログを表示します｡  (mycreatedemployee)です｡ 

03:38.050 --> 03:42.420
ここでは､ 「部門」へのアクセスも可能です｡  を､ 財政的に支援します｡  インスタンス化せずにそのまま年越しし､

03:43.900 --> 03:51.130
それを保存すると､ 当然のことながら､ ここに2020が記録されていることがわかります｡

03:51.130 --> 03:53.347
つまり､ これらは静的なメソッドとプロパティです｡ 

03:53.347 --> 03:56.947
それらについて､ 重要な一言､ あるいは心に留めておいてほしいことがある｡

03:56.947 --> 04:03.370
クラス上に追加した場合､ 非静的部分の内部からアクセスすることはできません｡

04:03.370 --> 04:04.870
コンストラクタで fiscalYear

04:04.870 --> 04:10.375
にアクセスし､ コンソールに表示したい場合です｡

04:10.375 --> 04:10.375
ログはここに､

04:10.375 --> 04:13.490
これは､ ご覧のように動作しません｡

04:13.490 --> 04:18.690
ここで､ fiscalYearというプロパティがstaticメンバであるというエラーが発生しました｡

04:18.690 --> 04:24.290
なぜならコンストラクタとその中の基本的なもの､

04:24.290 --> 04:26.530
すべてのメソッドは

04:26.530 --> 04:34.770
static でマークされておらず､ コンストラクタを static

04:34.770 --> 04:47.780
でマークできないので､ ここにアクセスすることはできません｡

04:47.780 --> 04:50.930
だから､ 当然ながらthisキーワードでアクセスすることはできない｡ 

04:50.930 --> 04:53.940
もし､ クラス内部からstaticプロパティやメソッドを使用したい場合は､

04:53.940 --> 04:59.380
ここでクラス名を使用してアクセスする必要があります｡

04:59.380 --> 05:04.290
これにより､ クラス内部から静的なプロパティやメソッドにアクセスすることができます｡

05:04.290 --> 05:06.593
それが､ ひとつの重要なポイントです｡ 
