WEBVTT

00:02.200 --> 00:04.920
Speaker: これがTypescriptによるクラス､

00:04.920 --> 00:07.510
プロパティ､ そして継承です｡

00:07.510 --> 00:08.343
そして､ 先ほども述べたように､

00:08.343 --> 00:12.490
これらの機能は一般的にJavascriptでサポートされていますが､

00:12.490 --> 00:14.230
現代のJavaScriptでは､

00:14.230 --> 00:16.940
もちろん型代入と､ protected private

00:16.940 --> 00:21.060
publicを除いてサポートされています｡

00:21.060 --> 00:24.770
これらのキーワードは､ 実際にはTypescriptでのみ利用可能です｡ 

00:24.770 --> 00:28.560
今､ クラスでできることは､ それだけではありません｡ 

00:28.560 --> 00:29.940
バニラJavaScriptにもあり､

00:29.940 --> 00:35.670
Typescriptでもサポートされている､ ゲッターとセッターという機能が必要なときはいつでも､

00:35.670 --> 00:38.610
この機能を利用できます｡

00:38.610 --> 00:42.050
では､ ここで経理部の例として､

00:42.050 --> 00:47.450
最後のレポートである「財産」を見てみましょう｡

00:47.450 --> 00:53.310
これはプライベートプロパティで､ 型は文字列です｡

00:53.310 --> 01:01.480
そして､ ここでレポートプロパティオーダーの引数を初期化して､

01:02.270 --> 01:04.880
最初の値にします｡

01:04.880 --> 01:07.877
もちろん､ 空のレポート配列が渡された場合は､

01:07.877 --> 01:09.890
基本的に未定義です｡

01:09.890 --> 01:17.010
レポートを追加したら､ この最後のレポートをテキストに設定します｡

01:17.010 --> 01:20.440
これがレポート配列に追加される｡ 

01:20.440 --> 01:26.250
さて､ 最後のレポートはプライベートなので､ このメソッドの中からアクセスすることはできますが､

01:26.250 --> 01:30.240
ドット記法で外からアクセスすることはできません｡

01:30.240 --> 01:33.440
今度はゲッターを追加して､ やはりアクセスできるようにします｡ 

01:33.440 --> 01:38.670
ゲッターは基本的に､ 値を取得するときに関数やメソッドを実行するプロパティで､

01:38.670 --> 01:44.460
開発者としてより複雑なロジックを追加することができる｡

01:44.460 --> 01:49.250
ここでは､ getキーワードと任意の名前を使用してゲッターを作成します｡

01:49.250 --> 01:54.180
通常､ アクセスを制御しようとするプロパティに密接に関連しています｡

01:54.180 --> 01:58.180
例えば､ ここでは直近のレポートと名付けることができます｡ 

01:58.180 --> 01:59.340
そういうことなら何でもいいんです｡ 

01:59.340 --> 02:01.630
さて重要なのは､ これがメソッドのように定義されていることです｡ 

02:01.630 --> 02:04.260
そこで､ 括弧を付けて､ 中括弧を付けるのです｡ 

02:04.260 --> 02:07.250
そして今ここで､ あなたは何かを返さなければなりません｡

02:07.250 --> 02:11.990
これは重要なゲッターメソッドで､ 何かを返さなければなりません｡

02:11.990 --> 02:14.610
ですから､ この最後のレポートを返して､

02:14.610 --> 02:19.570
これをカプセル化して､ 今は一般にアクセスできるようにしています｡

02:19.570 --> 02:22.720
しかし､ ここでもっと複雑なロジックを持ちたいと思うことがよくあります｡ 

02:22.720 --> 02:27.600
つまり､ ここに値があるかどうか､ これが真実かどうかをチェックすることができるのです｡

02:27.600 --> 02:28.960
もしundefinedでなければ､

02:28.960 --> 02:31.520
最後のレポートを返します｡ そうでなければ､

02:31.520 --> 02:34.440
例えばthrow new error, no reports

02:34.440 --> 02:42.650
foundというエラーメッセージを投げるように､ 何か別のロジックを返したいかもしれません｡

02:42.650 --> 02:46.650
このプロパティにさらにロジック､ より複雑なロジックを追加し､

02:46.650 --> 02:51.500
それを取得したいときに､ ドット記法でこのプロパティを直接取得することはできませんが､

02:51.500 --> 02:57.240
このロジックをエンドランするプロパティとして使用することは可能です｡

02:57.240 --> 02:58.810
では､ どうすればいいのでしょうか？

02:58.810 --> 03:02.170
その下に､ 私の経理部門があります｡ 

03:02.170 --> 03:08.693
レポートを追加する前に､ Console logを試したところ､ accounting.

03:08.693 --> 03:08.693
最近の報告で､

03:09.630 --> 03:11.010
今重要なのは

03:11.010 --> 03:13.902
おっと､ 会計の話｡  直近の報告書です｡ 

03:13.902 --> 03:16.890
そして今､ 重要なのは､ これをプロパティとしてアクセスすることです｡ 

03:16.890 --> 03:18.690
だから､ ここに括弧はない｡ 

03:18.690 --> 03:20.570
メソッドとして実行するわけではないんですね｡ 

03:20.570 --> 03:23.030
通常のプロパティのようにアクセスするだけで､

03:23.030 --> 03:27.890
裏側ではこのメソッドが実行されるのです｡

03:27.890 --> 03:31.670
レポートを追加する前にこれを試した場合､

03:31.670 --> 03:33.940
エラーなしで再構築され､

03:33.940 --> 03:35.440
リコンパイルもエラーなしで行われます｡

03:35.440 --> 03:48.310
しかしもちろんここでは､ レポートがまだ追加されていないため､ カスタムレポートが見つからないエラーが投げられます｡

03:48.310 --> 03:52.830
レポートがない場合は､ このIFチェック､ またはIF文に入らないので､

03:52.830 --> 03:55.693
この行がクリックされます｡

03:56.590 --> 04:00.250
別の方法として､ レポートを追加した後､ それを下に移動させれば､

04:00.250 --> 04:02.210
もちろん保存することができ､

04:02.210 --> 04:04.100
もうエラーは発生しませんが､

04:04.100 --> 04:08.400
代わりにこの最後のレポートが出力されます｡

04:08.400 --> 04:09.750
それがゲッターなんですね｡ 

04:09.750 --> 04:12.190
そして､ セッターを追加することも可能です｡ 

04:12.190 --> 04:14.550
セッターもほぼ同様に追加されます｡ 

04:14.550 --> 04:18.630
setキーワードを使い､ もう一度好きな名前をつけるのです｡

04:18.630 --> 04:22.870
通常､ 設定されるべきプロパティに関連する名前です｡

04:22.870 --> 04:25.570
そこで､ ここでは最新のレポートを再利用することにします｡ 

04:25.570 --> 04:29.150
値の読み取りと値の設定の両方に使用できるように｡

04:29.150 --> 04:31.850
そしてまた､ これをメソッドのように定義したんですね｡

04:31.850 --> 04:34.850
しかし､ 今､ これは議論を必要とします｡ 

04:34.850 --> 04:38.630
ユーザが入力したであろう値｡ 

04:38.630 --> 04:40.940
この中に文字列の値があるはずです｡

04:40.940 --> 04:46.160
この中に､ これを保存するための任意のロジックを実行することができます｡

04:46.160 --> 04:48.530
ここで､ 直近のレポートの値を渡しているので､

04:48.530 --> 04:53.080
最終的にはレポートを追加して実行したいのです｡

04:53.080 --> 04:57.140
つまり､ ここでは､ セッターは単にレポートの追加メソッドの代替となり得ます｡

04:57.140 --> 05:01.280
そこで､ この追加レポートにアクセスすることができます｡ 

05:01.280 --> 05:03.760
これは､ クラスの内部なので必須です｡ 

05:03.760 --> 05:07.280
ここでは､ クラス､ そしてこのクラスメソッドを参照しています｡ 

05:07.280 --> 05:10.380
そして､ あとはここに値を転送するだけです｡ 

05:10.380 --> 05:12.310
さらに複雑なロジックを追加して､

05:12.310 --> 05:16.130
値が定義されていないかどうかをチェックし､ falseの場合はreturnするか新しいyou

05:16.130 --> 05:24.020
errorを投げて､ 有効な値を渡してくださいということができます｡

05:24.020 --> 05:26.140
それは､ 私たちにもできることです｡ 

05:26.140 --> 05:29.010
そして､ ここでもセッターを使用しています｡ 

05:29.010 --> 05:31.330
それが加わって､ テストができるようになりました｡ 

05:31.330 --> 05:36.570
その下に､ 直近のレポートを追加することができました｡

05:36.570 --> 05:38.780
会計処理でこれにアクセスし､ 同じように読み取ることができます｡

05:38.780 --> 05:47.150
しかし､ 今度は等号を追加することで､ この値に値を設定しようとしており､ このセッターメソッドが起動します｡

05:47.150 --> 05:52.383
先ほどと同様に､ メソッドとして実行するのではなく､ プロパティのように単純にアクセスします｡

05:53.220 --> 05:56.030
ここで､ 空の文字列を渡すと､ 技術的には文字列を渡していることになりますが､

05:56.030 --> 06:02.760
空の文字列はfalseとして扱われます（こちらを参照）｡

06:02.760 --> 06:04.950
従って､ 今はエラーが出るはずです｡ 

06:04.950 --> 06:07.450
そこで､ このコードの行を追加して保存すると､

06:07.450 --> 06:09.850
このようなエラーが発生しました｡ Please

06:11.120 --> 06:14.530
pass in valid value.

06:14.530 --> 06:17.010
しかし､ 有効な値を渡した場合､

06:17.010 --> 06:23.900
例えば､ ここに年末の報告を書いて､ これを保存します｡

06:23.900 --> 06:29.620
これですべてがうまくいき､ 年末レポートがレポートリストの一部となったことがおわかりいただけると思います｡

06:29.620 --> 06:31.150
これらはゲッターとセッターで､

06:31.150 --> 06:40.243
ロジックをカプセル化したり､ プロパティを読み込むときや設定するときに実行される追加のロジックを追加したりするのに適しています｡
