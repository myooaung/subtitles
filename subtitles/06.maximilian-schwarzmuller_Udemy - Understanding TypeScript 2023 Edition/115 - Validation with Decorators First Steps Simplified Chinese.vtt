WEBVTT

00:02.160 --> 00:04.860
演示者：现在我们看到了另一个很好的例子,

00:04.860 --> 00:06.440
说明了如何使用装饰器, 下面是最后一个例子,

00:06.440 --> 00:09.040
我想深入讨论一下｡

00:09.040 --> 00:11.997
这就是用于验证的装饰器｡ 

00:11.997 --> 00:17.733
为此, 在文件的底部, 我将在这里添加另一个新类｡

00:18.780 --> 00:20.530
这可能是一门课程｡ 

00:20.530 --> 00:23.903
现在, 课程应该有一个标题, 它是一个字符串｡ 

00:25.430 --> 00:27.483
也许还有一个价格, 一个数字｡ 

00:29.730 --> 00:32.640
这里我们有一个构造函数, 我们在这里得到两个值,

00:32.640 --> 00:34.440
我在这里故意不使用快捷方式,

00:35.550 --> 00:40.953
这样我就可以很容易地添加属性装饰器｡

00:42.690 --> 00:44.560
然后, 我把这个标题设为t,

00:44.560 --> 00:46.653
这个价格设为p｡

00:47.990 --> 00:50.530
当然, 当我们要实例化这个课程时,

00:50.530 --> 00:53.610
我们必须传入一个有效的标题和价格.

00:53.610 --> 00:56.730
但在某些应用程序中, 您可能会遇到一种常见的情况,

00:56.730 --> 00:59.630
即从Web资源获取数据,

00:59.630 --> 01:08.110
并且您可能会在一些课程中获取数据, 但您并不确定｡

01:08.110 --> 01:12.839
或者, 在另一种可能的情况下, 您让用户输入数据, 您只是想分配该数据,

01:12.839 --> 01:15.490
并使用用户输入的数据交易新课程,

01:15.490 --> 01:24.210
您假设它是正确的, 但无法保证它是正确的, 因此您希望验证输入｡

01:24.210 --> 01:26.380
这就是我想假装的场景｡ 

01:26.380 --> 01:29.940
比如在我们的索引html文件中, 我们在这里得到了一个简单的表单,

01:30.894 --> 01:32.840
我不会给它设置样式, 所以它现在会很漂亮,

01:32.840 --> 01:36.074
但是我们在这里有一个简单的表单, 输入类型为文本,

01:36.074 --> 01:41.074
占位符为title､ woops､ course､ title和一个id, 比如title,

01:41.390 --> 01:50.605
在下面我们有一个数字输入, 其中类型为所有文本, 但它是course price, id是price｡

01:50.605 --> 01:55.030
然后我们有一个按钮, 我们可以在这里提交｡ 

01:55.030 --> 02:00.030
因此按钮的类型为提交｡ 

02:00.040 --> 02:02.780
这是一个非常简单的形式, 就像我说的, 如果我们在这里看它,

02:02.780 --> 02:06.070
它并不漂亮, 但它有我们需要的一切｡

02:06.070 --> 02:08.763
现在, 让我们将侦听器连接到此处的表单｡ 

02:09.830 --> 02:14.780
这里我得到了courseForm, 它可以通过document､ querySelector和form获得,

02:14.780 --> 02:32.360
我添加了感叹号, 因为我知道我会得到一个感叹号, 这样它就不会为空, 然后在表单上, 我们可以添加EventListener, 即提交事件侦听器, 然后我们将事件对象传递到我自动分配的函数中｡

02:32.360 --> 02:35.450
在这里我想调用事件preventDefault, 这样我们就不会提交表单,

02:35.450 --> 02:38.030
也不会发送http请求｡

02:38.030 --> 02:42.910
然后我们要提取标题和价格的数据｡

02:42.910 --> 02:45.779
因此, 可以通过访问document､ querySelector来提取标题,

02:45.779 --> 02:49.700
或者实际上, 因为我们分配了一个id､ getElementById､

02:49.700 --> 03:01.700
title, 我们知道这将是一个HTMLInputElement, 所以我们可以使用类型转换来让typescript知道这一点, 价格是document､ getElementById､

03:01.700 --> 03:09.672
price, 我们还可以将其转换为InputElement｡

03:09.672 --> 03:11.320
实际上, 我在这里是为了这些元素,

03:11.320 --> 03:14.520
所以我们将常量重命名为titleEL和priceEL,

03:14.520 --> 03:17.779
为了得到具体的标题, 我们现在可以转到titleEL,

03:17.779 --> 03:23.400
访问value属性, 然后得到价格, 我们可以对priceElement做同样的事情, 也得到那里的值,

03:23.400 --> 03:30.060
我想把它作为一个数字添加, 所以我在它前面加了加号, 把它转换成一个数字｡

03:30.060 --> 03:36.090
好了, 就这样, 现在我想用这些信息创建一个新课程｡

03:36.090 --> 03:39.060
这里有一个创建的课程, 我可以调用新课程,

03:39.060 --> 03:43.850
并传入标题和价格｡

03:43.850 --> 03:46.770
现在typescript接受了这个, 因为title将是一个字符串,

03:46.770 --> 03:50.200
而我将这个输入转换成了一个数字, price也将是一个数字｡

03:50.200 --> 03:55.530
因此, 如果我随后控制台日志, 创建课程之后, 我们可以检查这是否工作｡

03:55.530 --> 03:58.693
让我们保存它, 重新加载, 也许清除控制台, 以便我们可以清楚地看到输出,

03:58.693 --> 04:02.400
然后在这里添加一个新课程｡

04:02.400 --> 04:05.785
Javascript的完整指南成本199美元,

04:05.785 --> 04:08.010
这似乎工作｡

04:08.010 --> 04:13.290
现在, 不幸的是, 这只工作, 虽然如果我不输入任何东西｡

04:13.290 --> 04:16.600
如果我现在单击“保存”, 我们将看到此课程已创建｡ 

04:16.600 --> 04:19.820
从技术上讲, 这是一门有效的课程, 但当然,

04:19.820 --> 04:23.121
它对我们的应用程序并不有效｡

04:23.121 --> 04:28.620
我们可能需要一个非空的标题和一个大于零的价格｡

04:28.620 --> 04:30.660
所以我们要添加验证｡ 

04:30.660 --> 04:32.670
当然, 我们可以简单地在这里添加一个if检查,

04:32.670 --> 04:41.100
检查title､ trim､ length是否大于零, 这意味着它不是空的, 我们还可以在这里验证价格｡

04:41.100 --> 04:43.870
但这意味着无论何时创建新课程,

04:43.870 --> 04:47.880
都必须在添加之前在此处添加验证逻辑｡

04:47.880 --> 04:49.990
如果在装饰器的帮助下,

04:49.990 --> 04:51.910
验证逻辑被包含在课程类中,

04:51.910 --> 04:53.940
那不是很好吗？

04:53.940 --> 04:56.770
这正是我想做的｡ 

04:56.770 --> 04:59.910
现在, 我将仅提供如何实现此功能的基本概念,

04:59.910 --> 05:01.447
在下一个模块中,

05:01.447 --> 05:12.080
我将向您展示一个示例包, 该示例包以更详细的方式实现此功能, 然后我们将使用该示例包进行一些操作｡

05:12.080 --> 05:14.530
现在我想用我自己的装饰器来实现这个,

05:14.530 --> 05:16.300
我将在这里添加一个所需的装饰器,

05:16.300 --> 05:24.433
我们将添加另一个装饰器函数, 我将其命名为PositiveNumber｡

05:26.710 --> 05:28.510
我这里有两个装修工｡ 

05:28.510 --> 05:31.240
现在我的想法是, 我们可以把它们添加到我们的属性中,

05:31.240 --> 05:44.020
例如, 在title前面添加Required, 在price前面添加positiveNumber, 然后typescript在某个地方注册这个, 然后我们得到了第三个函数,

05:44.020 --> 05:49.020
validate, 我们可以向它传递一个对象, 这样任何对象和typescript都可以查看项目,

05:49.490 --> 06:03.410
查找我们先前在该类上为该对象注册的任何验证, 并应用我们的验证逻辑｡

06:03.410 --> 06:05.480
这就是我的想法｡ 

06:05.480 --> 06:08.240
这可能是我们提供给您的第三方库的一部分,

06:08.240 --> 06:11.170
然后您只需导入所需的正数并验证,

06:11.170 --> 06:16.750
首先设置验证器, 然后在某个时候调用验证｡

06:16.750 --> 06:18.634
例如, 当我们创建课程时,

06:18.634 --> 06:22.462
我们可以调用validate并传入createdCourse,

06:22.462 --> 06:35.040
如果这不为真, 那么我们假设这应该返回true或false, 如果这不为真, 那么我们将抛出错误或显示警报, 无效输入请重试,

06:35.040 --> 06:42.960
否则我们将继续｡

06:42.960 --> 06:43.870
这就是我的想法｡ 

06:43.870 --> 06:46.540
我们可以调用validate, 它返回true或false｡ 

06:46.540 --> 06:48.793
如果有效则为true, 如果无效则为false,

06:48.793 --> 06:51.670
因此我们可以使用结果.

06:51.670 --> 06:53.730
所以我们有几件事要做｡ 

06:53.730 --> 06:56.290
我们需要确保当我们在这里添加一个装饰器时,

06:56.290 --> 06:59.350
它以某种方式存储在某个地方｡

06:59.350 --> 07:02.950
同样, 请记住, 这可能是我们自己的第三方库的一部分,

07:02.950 --> 07:05.710
因此在那里我们可以有某种类型的存储,

07:05.710 --> 07:12.480
例如, 对于这个类和这个标题属性, 我们希望它是必需的｡

07:12.480 --> 07:15.630
在validate中, 我们可以检查我们得到的对象的存储中,

07:15.630 --> 07:23.330
对于对象所基于的类, 我们是否为标题, 价格等注册了一个验证器｡

07:23.330 --> 07:25.260
然后运行验证逻辑｡ 

07:25.260 --> 07:26.453
这是我的主意
