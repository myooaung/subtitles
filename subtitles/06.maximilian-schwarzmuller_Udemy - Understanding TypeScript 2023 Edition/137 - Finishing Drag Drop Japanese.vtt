WEBVTT

00:02.300 --> 00:05.250
講師：もちろん､ そのIDを記録することだけが目的ではないわけです｡

00:05.250 --> 00:11.110
その代わり､ ドロップハンドラのログでプロジェクトIDを抽出します｡

00:11.110 --> 00:18.910
そして､ それによって､ 今本当にプロジェクトを動かすこと､ 正確にはプロジェクトのステータスを変えることが目標になるのです｡

00:18.910 --> 00:21.400
さて､ どうすればいいのでしょうか｡ 

00:21.400 --> 00:26.063
さて､ 私たちのプロジェクトの状態で言うと､ 現在addProjectメソッドがあるところ､

00:26.950 --> 00:33.160
moveProjectメソッドも必要です｡

00:33.160 --> 00:38.550
そして､ この方法の目的は､ 基本的にプロジェクトのステータスを切り替えることでしょう｡

00:38.550 --> 00:40.180
もちろん､ SwitchProjectStatusなど好きな名前をつけることもできますが､

00:40.180 --> 00:46.440
今回はドラッグ＆ドロップを行うので､ MoveProjectと呼ぶことにします｡

00:46.440 --> 00:53.860
そこで､ MoveProjectでは､ プロジェクトを現在入っているリストから新しいリストに移動させることを目的としています｡

00:53.860 --> 00:55.460
さて､ これは必ずしもプロジェクトのステータスをアクティブからフィニッシュへ､

00:55.460 --> 01:00.480
そしてその逆へと反転させればいいということではありません｡

01:00.480 --> 01:05.060
結局､ ユーザーは同じ箱の中でドラッグアンドドロップということをやっている可能性があります｡

01:05.060 --> 01:07.120
そこで､ ステータスを切り替えるメソッドを常に起動するようにすると､

01:07.120 --> 01:15.754
同じボックスをドロップしても､ プロジェクトがもう一方のボックスに切り替わるという予期せぬ効果が得られます｡

01:15.754 --> 01:18.972
そのため､ MoveProjectでは､ どのプロジェクトを移動させるのか､

01:18.972 --> 01:23.402
そして新しいボックスはどれなのかを本当に知らなければなりません｡

01:23.402 --> 01:24.235
では､ 新しいステータスはどれなのか｡ 

01:25.940 --> 01:31.410
つまり､ ここではプロジェクトID（文字列であるべき）と新しいステータスが得られると期待しています｡

01:31.410 --> 01:36.410
そして､ ここでの新しいステータスは､ もちろん､ ProjectStatus型にすることができる｡

01:38.580 --> 01:40.803
そしてMoveProjectの中で､

01:41.692 --> 01:46.830
プロジェクトの配列の中からそのIDを持つプロジェクトを見つけたいのです｡

01:46.830 --> 01:49.090
そこで､ このプロジェクトの配列の中で､

01:49.090 --> 01:51.680
そのステータスを反転させるのです｡

01:51.680 --> 01:54.580
そのためには､ このプロジェクトに手を伸ばして､ その中からプロジェクトを見つければいいわけで､

01:54.580 --> 01:59.440
findメソッドはそれにぴったりです｡

01:59.440 --> 02:02.680
この配列のすべての要素に対して実行され､ すべての要素にアクセスできるようになります｡

02:02.680 --> 02:03.970
そして､ 探している要素であれば､

02:03.970 --> 02:05.770
trueを返さなければなりません｡

02:05.770 --> 02:09.860
そして､ 現在見ている要素のIDが､

02:09.860 --> 02:17.470
ここで引数として受け取ったprojectIdと同じであれば､

02:17.470 --> 02:21.070
trueを返します｡

02:21.070 --> 02:22.653
これはNULLかもしれないので､

02:23.490 --> 02:26.490
ここではprojectと呼んで､ projectという定数として保存し､

02:26.490 --> 02:30.550
projectが存在するかどうかをチェックします｡

02:30.550 --> 02:39.160
そして､ もしそれが存在するなら､ ここで新しいステータスと等しいステータスを設定したい｡

02:39.160 --> 02:39.160
単純なことです｡ 

02:39.250 --> 02:42.900
これでもう配列の中のオブジェクトが変更されるので､

02:42.900 --> 02:45.643
基本的にはこれで終了です｡

02:46.970 --> 02:50.010
しかし､ もちろん､ 完全に終わったわけではありません｡ 

02:50.010 --> 02:52.250
今度は､ 私たちのプロジェクトについて何かが変わったこと､

02:52.250 --> 02:57.870
そして再レンダリングする必要があることを､ リスナー全員に知らせる必要があるのです｡

02:57.870 --> 03:04.080
ここでコードを繰り返すことになるので､

03:04.080 --> 03:13.660
新しいプライベートメソッドにアウトソースすることにします｡

03:13.660 --> 03:17.430
そして､ addProjectとmoveProjectメソッドの両方から､

03:17.430 --> 03:20.890
このupdateListenersを呼び出すことにします｡

03:20.890 --> 03:23.033
ここで､ 何かを変えた場合のみ｡ 

03:24.350 --> 03:26.100
これですべてのリスナーがトリガーされるわけです｡ 

03:26.100 --> 03:33.010
そして､ このアプリのリスナーは､ 基本的にリストのアイテムを再レンダリングするように導きます｡

03:33.010 --> 03:35.310
だから､ それは正確に動作する､

03:35.310 --> 03:37.940
あるいは正確に動作するはずです｡

03:37.940 --> 03:40.640
ドロップハンドラの下にあるmoveProjectメソッドで､

03:40.640 --> 03:43.730
これを使うことができるようになりました｡

03:43.730 --> 03:46.390
そこで､ projectStateを使用して､ moveProjectを呼び出し､

03:46.390 --> 03:52.296
プロジェクトIDを渡すと､ 新しいプロジェクトのステータスになります｡

03:52.296 --> 03:54.190
そして､ 新しいプロジェクトの状況は､

03:54.190 --> 03:57.880
これを投下するリストによって決まります｡

03:57.880 --> 04:04.050
ドロップハンドラのthisキーワードが周囲のクラスを参照するように､

04:04.050 --> 04:08.500
ドロップハンドラを自動バインドしたいと思います｡

04:08.500 --> 04:13.020
この周囲のクラスはプロジェクトリストで､ 覚えていれば､

04:13.020 --> 04:18.120
ここにtypeプロパティを持っています｡

04:18.120 --> 04:22.640
あとはactiveとfinishedをenumの値に変換するだけです｡

04:22.640 --> 04:31.580
だからここで､ 私はこれで合格です｡  この場合､ ProjectStatusを渡します｡

04:31.580 --> 04:31.580
プロジェクトの新しいステータスは､

04:33.750 --> 04:38.160
プロジェクトを移動させたリストのステータスである「アクティブ」です｡

04:38.160 --> 04:45.423
それ以外の場合は､ ProjectStatusを渡す｡  完成しました｡ 読みやすいように整形させてください｡

04:46.730 --> 04:48.110
それを踏まえて､ 試してみましょう｡ 

04:48.110 --> 04:52.440
すべて保存して､ ここに新しいプロジェクトを追加し､ 今度は完成したプロジェクトにドラッグすると切り替わり､

04:52.440 --> 04:58.270
同じように､ 元に戻すと切り替わります｡

04:58.270 --> 05:02.320
アクティブなプロジェクトの中で､ ここで手を離しても何も変わりません｡ 

05:02.320 --> 05:04.400
DOM を検査するとわかりますが､

05:04.400 --> 05:08.100
技術的には再描画されます｡ これは理想的とは言えないので､

05:08.100 --> 05:11.450
ステータスが実際に変更されたかどうかをチェックし､

05:11.450 --> 05:18.890
変更されていない場合は更新しない､ そんな解決策を考えることができます｡

05:18.890 --> 05:22.620
しかし､ UIの観点からは､ その通りにアップデートされます｡ 

05:22.620 --> 05:24.570
次に､ 2つ目のプロジェクトを追加して､

05:24.570 --> 05:27.120
何かが破壊されるかどうか､

05:27.120 --> 05:33.720
すべてがまだ動作するかどうかを見てみましょう｡

05:33.720 --> 05:37.120
すべてが思い通りに動いているようです｡ 

05:37.120 --> 05:40.230
ドラッグ・アンド・ドロップは問題なく動作しますが､ プロジェクトの状態､

05:40.230 --> 05:42.600
moveProjectで､ このupdateListenersを呼び出したときに､

05:42.600 --> 05:51.920
本当に状態を変更したかどうかを実際にチェックできるようにするための､ 1つの改良点があります｡

05:51.920 --> 05:54.150
ここで､ プロジェクトが見つかったかどうかを確認し､

05:54.150 --> 06:03.830
プロジェクトのステータスが新しいステータスと異なる場合にのみ､ ステータスを変更してリスナーを更新します｡

06:03.830 --> 06:06.060
ステータスが同じであれば､ この処理を行わず､

06:06.060 --> 06:09.310
不要な再レンダリングサイクルを回避します｡

06:09.310 --> 06:10.143
これで､ 保存して､

06:10.143 --> 06:12.900
すぐに新しいプロジェクトを追加すると､ ここで要素を検査すると､

06:12.900 --> 06:14.790
L-Iを見て､ これが点滅するかどうかをチェックします｡

06:14.790 --> 06:18.190
つまり､ 再レンダリングすることになりますが､ ここでは点滅せず､

06:18.190 --> 06:30.990
ドロップできるものだけが点滅します｡ 先ほど追加したクラスは､ 同じボックスにドロップしてもL-Iは点滅せず､ 別のボックスに移動するとのみ点滅します｡

06:30.990 --> 06:34.460
そして､ その時にフラッシュが光るはずです｡ なぜなら､ その時に本当に動かしたからです｡ 

06:34.460 --> 06:36.180
このように､ TypeScriptで構築され､

06:36.180 --> 06:42.223
TypeScriptで動作するドラッグ＆ドロップを実現しました｡
