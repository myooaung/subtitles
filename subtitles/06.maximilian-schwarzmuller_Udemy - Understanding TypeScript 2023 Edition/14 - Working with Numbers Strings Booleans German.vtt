WEBVTT

00:01.850 --> 00:03.270
Kursleiter: Nachdem wir nun

00:03.270 --> 00:06.760
die Grundlagen von TypeScript kennen und wissen, wie es sich von

00:06.760 --> 00:09.661
JavaScript unterscheidet, wollen wir nun etwas tiefer

00:09.661 --> 00:11.410
in die verschiedenen Kerntypen

00:11.410 --> 00:14.148
eintauchen, die TypeScript kennt.

00:14.148 --> 00:17.490
Die Zahl ist der Typ, den wir hier sehen, und wie ich bereits erklärt habe, gibt

00:17.490 --> 00:18.500
es keinen Unterschied zwischen

00:18.500 --> 00:22.050
ganzen Zahlen, wie die fünf hier, und Gleitkommazahlen oder Doppelzahlen, wie sie

00:22.050 --> 00:24.330
in anderen Programmiersprachen genannt werden, wie

00:24.330 --> 00:25.640
2. 8 hier.

00:25.640 --> 00:28.440
In der Tat sind in JavaScript, und das gilt auch für TypeScript,

00:28.440 --> 00:30.810
alle Zahlen standardmäßig Fließkommazahlen.

00:30.810 --> 00:33.270
Für JavaScript, und damit auch für TypeScript, gibt

00:33.270 --> 00:35.171
es also keinen Unterschied zwischen fünf

00:35.171 --> 00:36.770
wie hier und fünf wie da.

00:36.770 --> 00:38.640
Es ist im Wesentlichen dieselbe Zahl.

00:38.640 --> 00:42.720
Neben den Zahlen haben wir auch andere Kerntypen.

00:42.720 --> 00:46.350
Und das wären Zeichenketten, also Text, und Boolesche Werte.

00:46.350 --> 00:47.800
Schauen wir uns auch diese an.

00:47.800 --> 00:50.650
Wir haben sie alle bereits in dieser if-Anweisung in Aktion gesehen,

00:50.650 --> 00:53.291
die, wie wir gelernt haben, ein wenig redundant ist.

00:53.291 --> 00:55.971
Nichtsdestotrotz wäre dies hier ein String.

00:55.971 --> 00:57.720
Außerdem wäre fünf mit Anführungszeichen

00:57.720 --> 01:00.389
natürlich eine Zeichenkette, da es sich um Text handelt.

01:00.389 --> 01:03.851
Und das Ergebnis, zum Beispiel, dieses Vergleichs hier, wäre

01:03.851 --> 01:05.170
ein Boolescher Wert.

01:05.170 --> 01:08.090
Dieser Operator, das dreifache Gleichheitszeichen

01:08.090 --> 01:10.950
oder hier der negierte Gleichheitsoperator,

01:10.950 --> 01:13.640
erzeugt wahr oder falsch.

01:13.640 --> 01:14.720
Und natürlich können wir

01:14.720 --> 01:17.340
entweder einen dynamischen innerRef-Check erstellen,

01:17.340 --> 01:18.850
was wir oft tun werden.

01:18.850 --> 01:22.340
Oder wir initialisieren eine Variable mit einem true- oder false-Wert, also machen

01:22.340 --> 01:23.379
wir hier beides.

01:23.379 --> 01:27.509
Hier könnten wir eine neue Konstante "printResult" hinzufügen.

01:27.509 --> 01:29.990
Und setzen Sie dies zum Beispiel auf true.

01:29.990 --> 01:31.320
Und nur um das klarzustellen,

01:31.320 --> 01:33.130
dies könnte auch eine Variable sein.

01:33.130 --> 01:34.460
Es muss nicht unbedingt eine Konstante sein.

01:34.460 --> 01:36.030
Es kann eine Variable sein, die Sie mit

01:36.030 --> 01:37.730
let in JavaScript erstellen würden.

01:37.730 --> 01:39.870
Aber da ich nicht vorhabe, sie hier zu ändern, werde ich eine

01:39.870 --> 01:40.703
Konstante verwenden.

01:40.703 --> 01:43.670
Und wir könnten dies hier als dritten Parameter übergeben.

01:43.670 --> 01:46.960
Nehmen wir an, wir geben "printResult" ein, was hier zutrifft.

01:46.960 --> 01:49.720
Jetzt bekommen wir natürlich sofort eine Fehlermeldung,

01:49.720 --> 01:53.160
weil unsere Add-Funktion kein drittes Argument unterstützt.

01:53.160 --> 01:55.560
Wir sehen: "Wir erwarteten zwei Argumente, bekamen aber drei".

01:55.560 --> 01:57.260
Wir müssen also sicherstellen, dass wir

01:57.260 --> 01:58.920
ein drittes Argument unterstützen.

01:58.920 --> 02:03.920
Und dort könnten wir einen Parameter "showResult" hinzufügen.

02:03.940 --> 02:05.920
Sie könnten es auch "printResult" nennen.

02:05.920 --> 02:07.910
Ich habe mich für "showResult" entschieden, um Verwirrung

02:07.910 --> 02:11.340
bei der Namensgebung zu vermeiden, aber technisch gesehen würden sich diese beiden

02:11.340 --> 02:12.930
Namen nicht widersprechen.

02:12.930 --> 02:14.320
Hier nenne ich sie also "showResult".

02:14.320 --> 02:17.580
Und ich möchte sicherstellen, dass dies vom Typ boolean ist,

02:17.580 --> 02:19.500
indem ich dies auf boolean setze.

02:19.500 --> 02:22.109
Auch hier fügen Sie einen Doppelpunkt nach

02:22.109 --> 02:25.120
dem Parameter und dann den Namen des Typs ein.

02:25.120 --> 02:28.100
Diese Funktion akzeptiert dies, und jetzt können

02:28.100 --> 02:31.787
wir hier eine if-Prüfung hinzufügen und "if showResult" prüfen,

02:31.787 --> 02:36.480
wenn dies wahr ist, können wir es natürlich mit wahr vergleichen.

02:36.480 --> 02:37.628
Aber wie Sie in JavaScript

02:37.628 --> 02:41.990
wissen, können Sie hier auch einfach den Wahrheits- oder Falsy-Wert übergeben.

02:41.990 --> 02:43.970
Und JavaScript wertet es aus, und wenn

02:43.970 --> 02:47.389
das Ergebnis irgendwie wahr oder generell ein wahrer Wert ist, dann

02:47.389 --> 02:48.989
machen wir es zum if-Block.

02:48.989 --> 02:50.011
Andernfalls werden wir es nicht tun.

02:50.011 --> 02:52.900
Und sagen wir mal, wir schaffen es hier rein, und dann

02:52.900 --> 02:55.429
will ich "Konsole". log n1 plus n2".

02:55.429 --> 02:58.581
Im anderen Fall, wenn wir es dort nicht schaffen,

02:58.581 --> 03:00.549
möchte ich dies zurückgeben.

03:00.549 --> 03:02.300
Dies ist also eine Funktion, die

03:02.300 --> 03:04.760
manchmal einen Wert zurückgibt und manchmal

03:04.760 --> 03:07.200
keinen Wert zurückgibt, sondern ihn sofort

03:07.200 --> 03:08.309
ausgibt.

03:08.309 --> 03:11.550
Nun könnte man argumentieren, wenn man eine solche Funktion schreiben

03:11.550 --> 03:14.310
will, die irgendwie unvorhersehbar ist oder die sich

03:14.310 --> 03:16.651
unerwartet verhalten könnte, wenn man hier

03:16.651 --> 03:18.349
ein true übergibt.

03:18.349 --> 03:19.990
Aber hier tun wir es.

03:19.990 --> 03:22.090
Diese Funktion kehrt also nur manchmal zurück.

03:22.090 --> 03:24.869
Manchmal kehrt es auch nicht zurück, sondern

03:24.869 --> 03:27.830
protokolliert nur etwas auf der Konsole.

03:27.830 --> 03:31.120
Hier können wir add einfach so aufrufen und müssen

03:31.120 --> 03:33.640
es nicht im Ergebnis speichern und nicht

03:33.640 --> 03:37.570
auf der Konsole ausgeben. Ergebnis protokollieren, denn mit "printResult"

03:37.570 --> 03:39.550
auf true, addieren sich.

03:39.550 --> 03:41.869
Die Funktion selbst wird also das Ergebnis ausgeben.

03:41.869 --> 03:43.640
Wenn wir das nun speichern und unsere

03:43.640 --> 03:47.880
Anwendung neu kompilieren. ts-Datei hier mit dem Befehl tsc.

03:47.880 --> 03:50.830
Sobald dies geschehen ist, wird die Seite neu geladen, und wir sehen

03:50.830 --> 03:52.600
immer noch unsere Ausgabe hier.

03:52.600 --> 03:54.677
Aber jetzt kommt es aus der sechsten Zeile.

03:54.677 --> 03:57.690
Und wenn wir einen Blick darauf werfen, befindet sich Zeile sechs tatsächlich

03:57.690 --> 03:58.980
innerhalb der Funktion.

03:58.980 --> 03:59.891
Dies ist also ein Boolescher Wert.

03:59.891 --> 04:02.429
Nehmen wir an, wir wollen die Ausgabe anpassen.

04:02.429 --> 04:06.190
In der if-Konstante haben wir hier eine "resultPhrase"-Konstante,

04:06.190 --> 04:10.181
in der wir sagen: "Ergebnis ist" Doppelpunkt und dann etwas Leerraum.

04:10.181 --> 04:14.205
Und auch das geben wir hier mit "resultPhrase" ein.

04:14.205 --> 04:17.410
Nun, dann könnten wir dies auch hier als Argument erwarten.

04:17.410 --> 04:20.750
Phrase, die Pipe-String ergeben würde, durch Hinzufügen eines Doppelpunkts.

04:20.750 --> 04:22.291
Und dann ist string der Name des

04:22.291 --> 04:26.469
Typs, und jetzt könnten wir diese Phrase verwenden, um sie als Teil unserer Ergebnisausgabe

04:26.469 --> 04:31.193
auszugeben, wenn wir das Ergebnis direkt in der Funktion drucken.

04:31.193 --> 04:34.789
Hier könnten wir also "Satz plus n1 plus n2" haben.

04:34.789 --> 04:37.440
Und wenn wir das tun und durch Wiederholung dieses Befehls

04:37.440 --> 04:39.040
neu kompilieren, werden wir sehen,

04:39.040 --> 04:41.720
dass diese Phrase Teil des Ergebnisses ist.

04:41.720 --> 04:44.861
Aber wir haben jetzt auch den alten Fehler wieder eingeführt, weil

04:44.861 --> 04:48.141
ich eine Zeichenkette habe, die ich mit zwei Zahlen kombiniere.

04:48.141 --> 04:52.000
Hier wird alles in eine Zeichenkette umgewandelt, und das ist nicht

04:52.000 --> 04:53.240
das, was ich will.

04:53.240 --> 04:55.930
Um dies zu vermeiden, könnten wir in dieser Funktion eine

04:55.930 --> 04:57.708
Ergebnisvariable hinzufügen.

04:57.708 --> 05:02.027
Oder eine Ergebniskonstante und speichern Sie unser Ergebnis hier.

05:02.027 --> 05:04.530
Dies wird nun auf mathematische Weise behandelt,

05:04.530 --> 05:07.990
da es sich nur um Zahlen handelt, und dann könnten wir dies mit dem

05:07.990 --> 05:11.430
Ausdruck kombinieren oder ihn einfach zurückgeben.

05:11.430 --> 05:15.160
Und da dies nie direkt zusammen mit einer Zeichenkette berechnet wird,

05:15.160 --> 05:17.029
wird es immer eine Zahl sein.

05:17.029 --> 05:19.350
Und ja, dann wird hier diese Zahl in Kombination mit dieser Zeichenkette

05:19.350 --> 05:21.140
in eine Zeichenkette umgewandelt.

05:21.140 --> 05:24.360
Aber da die mathematische Berechnung vorher abgeschlossen wurde, werden wir das

05:24.360 --> 05:25.548
richtige Ergebnis erhalten.

05:25.548 --> 05:28.520
Wenn wir das nun wiederholen und neu kompilieren, erhalten

05:28.520 --> 05:30.181
wir die richtige Ausgabe.

05:30.181 --> 05:33.050
Dies sind also die wichtigsten Datentypen in Aktion.

05:33.050 --> 05:35.541
Stellen wir nun sicher, dass wir vollständig

05:35.541 --> 05:38.061
verstehen, wie Typen zugewiesen werden, und

05:38.061 --> 05:41.343
auch, warum wir Typen dort unten nicht explizit zuweisen.
