WEBVTT

00:02.110 --> 00:03.890
講師：さて､ 型そのものを扱う機能､

00:03.890 --> 00:16.110
つまり型のチェックや型のコスト計算を行った後は､ 柔軟なコードを書くための機能に話を戻しましょう｡

00:16.110 --> 00:17.930
もちろん､ それでも2種類を書きます｡ 

00:17.930 --> 00:20.150
結局typescriptなんですが､

00:20.150 --> 00:23.520
型だけにこだわらず､ 今は管理できるようになりました｡

00:23.520 --> 00:25.830
そのために､ まずはインデックス・タイプから始めたいと思います｡

00:25.830 --> 00:33.010
インデックス・タイプは､ 保持するプロパティに関してより柔軟なオブジェクトを作成することができるようにする機能です｡

00:33.010 --> 00:34.485
さて､ どういうことでしょうか｡ 

00:34.485 --> 00:39.680
例えば､ ユーザーの入力を検証するアプリケーションを書くとしましょう｡

00:39.680 --> 00:41.810
つまり､ 複数の入力フィールドがあり､

00:41.810 --> 00:44.603
ユーザーがそこに何を入力したか､ そしてそれがどのフィールドであるかによって､

00:44.603 --> 00:50.490
異なるエラーメッセージを保存し､ 最終的に表示したい場合があります｡

00:50.490 --> 00:54.360
例えば､ Eメールのフィールドであれば､ Eメールに書かれているのが誰であるかをチェックし､

00:54.360 --> 00:59.830
もしそうでなければ､ 適切なエラーメッセージをエラーコンテナに追加することになるでしょう｡

00:59.830 --> 01:01.133
というわけで､ まずはそんなところから｡ 

01:01.133 --> 01:06.133
ここに私のインターフェースのエラーコンテナを用意します｡ 

01:07.570 --> 01:11.400
そしてそれはオブジェクトであるべきで､ それゆえここではインターフェイスを使っていますが､

01:11.400 --> 01:14.090
それが保持するものについては柔軟であるべきです｡

01:14.090 --> 01:17.692
最終的な目標は､ これでエラーの識別子があるオブジェクトを扱えるようになることで､

01:17.692 --> 01:23.700
それはエラーの属する入力フィールドの理想的な姿かもしれません｡

01:23.700 --> 01:31.581
例えば､ メール｡  そして､ 有効なメールではありませんというエラー文字列が表示されます｡

01:31.581 --> 01:31.581
そして､ もうひとつの財産があります｡ 

01:32.130 --> 01:37.150
例えば､ ユーザー名としましょう｡ そして､ 入力フィールドが正しくない場合､

01:37.150 --> 01:41.611
エラー文字列がその入力フィールドに格納されるかもしれません｡

01:41.611 --> 01:45.770
文字で始まる必要があります｡ 

01:45.770 --> 01:49.170
そのようなものがそのオブジェクトに格納されているはずです｡ 

01:49.170 --> 01:51.992
問題は､ どのプロパティ名が正確に入るのか､

01:51.992 --> 01:55.320
事前にわからないことです｡

01:55.320 --> 01:58.021
メールとユーザー名を用意する､ という方法もありますが､

01:58.021 --> 02:01.650
私はこれを柔軟なコンテナにしたいのです｡

02:01.650 --> 02:05.350
自分のウェブページにあるどんなフォームでも使えるようにしたいのですが｡

02:05.350 --> 02:10.157
そして､ 異なる識別子で異なる入力を持つフォームを持つかもしれません｡

02:10.157 --> 02:16.150
だから､ 私たちのメールとユーザー名のエラーだけに限定したくないんです｡

02:16.150 --> 02:18.461
さらに､ Eメールとユーザー名だけの入力で､

02:18.461 --> 02:23.291
それらのエラーを保存したい場合にも対応します｡

02:23.291 --> 02:27.461
ユーザー名ではなく､ メールアドレスだけが無効な場合はどうすればよいですか？

02:27.461 --> 02:30.912
それから､ このオブジェクトには､ もちろんユーザー名の値としてnullを格納することもできますが､

02:30.912 --> 02:34.421
私はそれを省略したいと思います｡

02:34.421 --> 02:40.419
では､ エラーが発生した入力のプロパティだけを保持するオブジェクトがあったでしょうか｡

02:40.419 --> 02:46.260
このオブジェクトを4回ループして､ 例えば取得したすべてのエラーを読み取ることもできますし､

02:46.260 --> 02:51.112
実際にエラーを保存しないようなプロパティは持たないようにしましょう｡

02:51.112 --> 02:56.861
要するに､ 値の型が明確なオブジェクトが必要なんです｡

02:56.861 --> 03:02.190
文字列であるべきですが､ 私が持っているプロパティの数とプロパティが持っている名前がわからないところでは､

03:02.190 --> 03:05.320
私は事前にしない｡

03:05.320 --> 03:08.171
そして､ そのようなシナリオのために､ インデックスタイプを使用することができます｡ 

03:08.171 --> 03:10.760
ここで角括弧を使ってインデックスの種類を定義します｡ 

03:10.760 --> 03:16.280
通常はここにプロパティ名を書きますが､ ここでは角括弧を使っていることを思い出してください｡

03:16.280 --> 03:21.280
そして､ keyやpropなど､ お好きな名前をつけてください｡ 

03:23.581 --> 03:28.581
そして､ コロン｡  そして､ そのプロパティの値型｡ 

03:29.010 --> 03:30.010
そして､ オブジェ｡ 

03:30.010 --> 03:33.760
文字列､ 数値､ 記号をプロパティとして持つことはできません｡ 

03:33.760 --> 03:37.660
例えば､ ここではbooleanは使えません｡  それはダメなんです｡ 

03:37.660 --> 03:40.504
しかし､ ここでは文字列を使用することができます｡ 

03:40.504 --> 03:43.190
これは､ このエラーコンテナインタフェースに基づいて後で構築するオブジェクトは､

03:43.190 --> 03:46.330
必ず文字列であるプロパティを持たなければならない､

03:46.330 --> 03:51.083
ということを意味している｡

03:52.120 --> 03:55.899
例えば､ Usernameは引用符でくくらなくとも有効な文字列です｡

03:55.899 --> 04:01.629
そして､ コロン（Colon）をつける｡  そして､ 値の型ですが､ これは文字列です｡

04:01.629 --> 04:01.629
ということで､

04:01.629 --> 04:04.320
正確なプロパティ名はわからないということです｡

04:04.320 --> 04:07.620
また､ 物件数もわからない｡ 

04:07.620 --> 04:10.608
エラーコンテナに基づくこのオブジェクトに追加されるすべてのプロパティは､

04:10.608 --> 04:23.080
文字列として解釈できるプロパティ名を持ち､ プロパティの値も文字列でなければならないことだけは分かっています｡

04:23.080 --> 04:23.080
それが､ ここで言っていることです｡ 

04:23.080 --> 04:35.339
これで､ 定義済みのプロパティを追加することもできますが､ ただし､ ここにあるものと同じタイプのものである場合に限ります｡

04:35.339 --> 04:35.339
そこで､ 文字列型であるIDを追加することができます｡ 

04:35.339 --> 04:39.760
そして､ このインターフェイスに準拠したオブジェクトは､ 必ずIDプロパティを持ち､

04:39.760 --> 04:43.360
その他にも好きなだけプロパティを追加することができます｡ しかし､

04:43.360 --> 04:49.277
例えばここではインデックス型があるので､ IDを数値に設定することはできません｡

04:49.277 --> 04:53.033
そのため､ このようなオブジェクトを作る場合は､ 制約があります｡ 

04:55.240 --> 04:56.550
さて､ その結果はどうなるのでしょうか？

04:56.550 --> 05:02.390
例えば､ エラーバッグを作成することができます｡ エラーコンテナのタイプはオブジェクトであり､

05:02.390 --> 05:07.440
プロパティを追加する必要がないため､ このように有効なバッグを作成できます｡

05:07.440 --> 05:10.340
それがすべて有効です｡  しかし､ もちろん､ これから追加することも可能です｡ 

05:10.340 --> 05:13.380
例えば､ email not a valid email｡ 

05:13.380 --> 05:23.001
そして､ これでいいのです｡  なぜなら､ すべてのプロパティには文字列の値型が必要だと言っているからです｡

05:23.001 --> 05:23.001
だから､ ここでは文字列を使わなければならない｡ 

05:23.001 --> 05:25.940
ここで数字を使えば､ 文字列としても解釈できるので､

05:25.940 --> 05:28.610
うまくいくでしょう｡

05:28.610 --> 05:33.031
ですから､ ここでキータイプとして数字を使おうと思えば使うこともできるのです｡

05:33.031 --> 05:33.031
ここでは､

05:33.031 --> 05:35.981
何を使うかはかなり自由です｡ もし､ ここの支柱のタイプを数字に変えてくれるなら､

05:35.981 --> 05:44.810
そうすれば､ これは大丈夫でしょう｡

05:44.810 --> 05:44.810
しかし､

05:44.810 --> 05:46.470
電子メールは数字ではないので､ これはないでしょう｡

05:46.470 --> 05:48.170
これは数字に変換できない｡ 

05:48.170 --> 05:51.550
文字列として扱えるが､ 数値としては扱えない｡ 

05:51.550 --> 05:54.870
つまり､ どのタイプのプロパティ､ あるいはどのプロパティ名を許可するかは､

05:54.870 --> 05:56.990
こうしてコントロールするのです｡

05:56.990 --> 05:59.493
そして､ ここでは､ 文字列のプロパティ名を許可するようにしました｡ 

05:59.493 --> 06:04.740
つまり､ 文字列に変換できるものであれば､ 何でも有効なプロパティ名となります｡

06:04.740 --> 06:04.740
そして､

06:04.740 --> 06:06.413
その値も文字列でなければならない｡

06:06.413 --> 06:08.021
そして､ もちろん､

06:08.021 --> 06:12.830
ここで複数の値を追加することができます｡

06:12.830 --> 06:17.263
大文字で始まる必要があります｡ 

06:18.170 --> 06:22.722
このように､ エラーコンテナを使ってエラーバッグを作ることで､

06:22.722 --> 06:27.522
どのプロパティ名を使い､ いくつのプロパティが必要かをあらかじめ知っておく必要がないため､

06:27.522 --> 06:32.653
柔軟な対応が可能になります｡
