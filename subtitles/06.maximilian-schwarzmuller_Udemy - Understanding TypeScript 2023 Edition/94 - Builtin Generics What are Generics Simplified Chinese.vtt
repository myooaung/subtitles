WEBVTT

00:02.130 --> 00:05.260
解说员：我又回到了我们的虚拟项目设置中,

00:05.260 --> 00:06.690
我们反复使用它｡

00:06.690 --> 00:10.190
在那里, 我们可以运行NPM启动来启动开发服务器｡

00:10.190 --> 00:13.690
然后在一个新的终端窗口中, 服务器在另一个终端窗口中运行,

00:13.690 --> 00:17.419
我运行TSC破折号W来启动我的TypeScript编译过程,

00:17.419 --> 00:21.540
并使其保持运行｡

00:21.540 --> 00:23.470
当然, 我们得到了一个空页面,

00:23.470 --> 00:24.560
因为上面什么都没有,

00:24.560 --> 00:27.060
但是现在我们可以在应用TS文件中玩一下,

00:27.060 --> 00:29.480
然后开始使用泛型｡

00:29.480 --> 00:32.940
我认为如果我们看一下默认类型, 就很容易理解泛型了,

00:32.940 --> 00:39.610
它内置在TypeScript中, 我们实际上用了很多, 它是一个泛型,

00:39.610 --> 00:44.410
它是一个数组｡

00:44.410 --> 00:46.900
假设我们有一个名称数组｡ 

00:46.900 --> 00:50.370
麦克斯和曼纽

00:50.370 --> 00:51.620
我们有两个名字,

00:51.620 --> 00:57.210
当然, 名字的常量类型是一个字符串数组.

00:57.210 --> 01:02.460
实际上, 我们可以把它看作是两种类型的结合｡

01:02.460 --> 01:05.760
就像您可以让物件具有不同的属性, 而在每个属性中,

01:05.760 --> 01:09.310
您可能会储存不同的型别｡

01:09.310 --> 01:16.440
一个数组总是包含不同的数据, 在这个例子中包含字符串｡

01:16.440 --> 01:22.770
所以我们实际上有一个数组类型, 只是一个数组, 如果我删除这里的名称并剪切它们,

01:22.770 --> 01:25.010
你会看到TypeScript会推断这是一个任何类型的数组,

01:25.010 --> 01:29.140
其中有任何数据｡

01:29.140 --> 01:32.690
实际上, TypeScript知道数组类型｡ 

01:32.690 --> 01:35.280
所以我们可以说, 这里应该是一个数组, 但是你可以看到,

01:35.280 --> 01:37.600
如果我这样指定, 我们会得到一个错误,

01:37.600 --> 01:43.570
即使我可以告诉你, 这个数组类型, 像这样存在于TypeScript中｡

01:43.570 --> 01:45.870
但是我们看到它是一个泛型类型,

01:45.870 --> 01:48.710
并且它需要一个类型参数｡

01:48.710 --> 01:50.950
而现在, 这是我们以前从未见过的｡ 

01:50.950 --> 01:53.870
我们以前从未听说过泛型类型｡ 

01:53.870 --> 01:58.120
现在, 这个奇怪的符号, 每当你在TypeScript中看到这样的东西,

01:58.120 --> 02:01.060
你就在处理一个泛型类型｡

02:01.060 --> 02:05.610
泛型类型是一种与其他类型有某种联系的类型,

02:05.610 --> 02:12.920
并且对于其他类型是哪种类型非常灵活｡

02:12.920 --> 02:14.130
听起来很难？

02:14.130 --> 02:16.820
好吧, 让我们回到数组的例子｡ 

02:16.820 --> 02:19.380
我们知道我们要在这里存储一个数组｡ 

02:19.380 --> 02:22.250
所以数组本身可以是一个类型, 它是一个数据列表,

02:22.250 --> 02:26.730
它本身就构成了一个类型, 你可以说｡

02:26.730 --> 02:32.200
就像一个对象本身就是一个类型, 即使我们还不知道哪些数据将进入其中｡

02:32.200 --> 02:34.490
所以数组本身就是一个类型｡ 

02:34.490 --> 02:39.860
但是数组当然存储了特定类型的数据｡

02:39.860 --> 02:44.810
现在, 数组类型本身并不关心存储在其中的数据类型｡

02:44.810 --> 02:48.150
数组类型不关心您存储的是字符串列表､

02:48.150 --> 02:52.430
数字列表､ 对象列表还是混合数据列表｡

02:52.430 --> 02:54.500
数组类型并不关心,

02:54.500 --> 02:58.640
但它至少关心一些信息, 即使你告诉它,

02:58.640 --> 03:02.960
我不知道, 把它设为任意数组类型.

03:02.960 --> 03:05.870
这总比什么都不指定好｡ 

03:05.870 --> 03:08.330
这是定义数组类型的一种方法, 数组类型是存储在there和square

03:08.330 --> 03:11.430
brackets中的数据类型.

03:11.430 --> 03:15.830
另一种方法, 也就是创建完全相同的类型, 就是使用Array,

03:15.830 --> 03:17.630
然后使用尖括号.

03:17.630 --> 03:20.030
现在在尖括号之间, 你指定了数据的类型,

03:20.030 --> 03:24.140
它应该被放入数组中.

03:24.140 --> 03:26.330
比如一个字符串,

03:26.330 --> 03:31.330
这里的定义和这里的定义完全一样｡

03:32.030 --> 03:34.950
当然, 这里你也可以用一个联合类型来表示,

03:34.950 --> 03:37.730
这个数组存储字符串或者数字, 或者如果你不想用任何类型的话,

03:37.730 --> 03:42.970
就用any, 或者就像我们刚才用的字符串一样｡

03:42.970 --> 03:46.900
这是一个泛型类型, 一个内置于TypeScript中的泛型类型｡

03:46.900 --> 03:50.440
一个类型连接到另一个类型, 在那里我们想知道我们的类型是哪一个,

03:50.440 --> 03:56.810
所以对TypeScript能给予我们更好的支持｡

03:56.810 --> 04:01.510
比如说, 如果我们知道存储在数组中的是字符串,

04:01.510 --> 04:04.380
那么我们知道, 每当我访问数组中的一个元素时,

04:04.380 --> 04:09.410
我就可以用它来做字符串操作.

04:09.410 --> 04:12.260
我可以调用所有这些字符串方法, 例如,

04:12.260 --> 04:15.280
TypeScript不会抱怨, 因为它知道,

04:15.280 --> 04:18.220
嗯, 这个数组保存字符串｡

04:18.220 --> 04:20.410
这就是泛型类型的概念｡ 

04:20.410 --> 04:23.230
某种类型在这里, 数组类型可能会更好地工作,

04:23.230 --> 04:29.040
或者根本不工作, 如果你提供了关于这个数组类型中提供的数据类型的附加信息,

04:29.040 --> 04:36.590
当然, 数组类型只是一个例子｡

04:36.590 --> 04:42.130
另一个内置于TypeScript中的泛型类型是promise类型｡

04:42.130 --> 04:45.470
承诺是JavaScript的一个特性, 对吧？

04:45.470 --> 04:46.970
它不是TypeScript功能｡ 

04:46.970 --> 04:49.437
你可以在JavaScript中创建承诺,

04:49.437 --> 04:53.870
如果你不确定什么是承诺, 你可以找到链接｡

04:53.870 --> 04:58.150
可以通过使用新承诺来创建承诺｡ 

04:58.150 --> 05:03.270
这是一个构造函数, 一个内置在JavaScript中的类promise构造函数有一个参数,

05:03.270 --> 05:12.580
它本身就是一个函数, 然后依次得到两个参数, 最终是resolve和reject函数.

05:12.580 --> 05:17.790
现在这些将通过浏览器中的JavaScript自动传递给我们｡

05:17.790 --> 05:22.400
在一个承诺中, 我们可以设置一个计时器, 然后在该计时器的回调函数中,

05:22.400 --> 05:28.140
我们可以解析外部承诺｡

05:28.140 --> 05:30.140
所以在这个回调函数中,

05:30.140 --> 05:34.823
我们可以调用resolve, 然后说这已经完成了.

05:36.500 --> 05:43.860
当我们这样做的时候, 这个promise会创建一个新的对象, promise对象存储在promise常量中.

05:43.860 --> 05:47.700
现在, 这个承诺常量实际上有一个特定的类型｡ 

05:47.700 --> 05:49.470
它是promise类型的,

05:49.470 --> 05:56.130
你会看到这些尖括号因为这个promise最终会得到结果.

05:56.480 --> 06:03.880
现在这里说unknown是因为TypeScript不能完全理解我们实际上会在这里解析为一个字符串｡

06:03.880 --> 06:05.870
但因此我们可以说这是一个承诺,

06:05.870 --> 06:11.450
它最终会产生一个字符串, 我们通过再次使用泛型类型来做到这一点｡

06:11.450 --> 06:16.120
主要类型是promise, 但promise就像数组一样,

06:16.120 --> 06:18.380
可以和其他类型一起工作.

06:18.380 --> 06:22.000
数组使用其他类型是因为它存储的数据, 是特定类型的数据,

06:22.000 --> 06:25.640
而promise和其他类型一起工作是因为最终它会返回某种类型的数据,

06:25.640 --> 06:32.940
在这里, promise最终会返回一个字符串.

06:32.940 --> 06:34.470
再问一次, 为什么这有用？

06:34.470 --> 06:37.550
为什么这个额外的类型信息有用？

06:37.550 --> 06:40.350
如果我们这里只有一个promise类型,

06:40.350 --> 06:41.430
这是不允许的, 但是如果我们说promise

06:41.430 --> 06:51.280
of type, anything, 这基本上和类型一样, 如果它没有任何关于我们返回的信息, 它就不知道泛型类型｡

06:51.280 --> 06:53.340
当然, 在这个承诺上, 我们可以使用它们,

06:53.340 --> 06:55.750
因为我们可以做所有的承诺, 最终我们会得到一些数据,

06:55.750 --> 06:59.770
但是我们对这些数据一无所知｡

06:59.770 --> 07:02.500
例如, 我不能对它调用字符串方法｡ 

07:02.500 --> 07:07.590
我可以, 因为在这种情况下, 它是任何, 但我没有得到任何特定的TypeScript支持｡

07:07.590 --> 07:11.313
我也可以在上面试试, 但肯定不行｡ 

07:12.170 --> 07:15.220
例如, 如果我们反过来, 我们在这里返回一个数字,

07:15.220 --> 07:17.320
我仍然可以在这里调用一个字符串方法,

07:17.320 --> 07:22.640
因为TypeScript没有关于这个承诺最终将产生的数据的信息｡

07:22.640 --> 07:26.280
现在, 对于泛型类型, 我们将该信息提供给TypeScript｡

07:26.280 --> 07:28.160
我们可以告诉TypeScript,

07:28.160 --> 07:30.240
这个承诺最终会产生一个字符串, 或者在这个例子中,

07:30.240 --> 07:34.940
一个数字, 然后TypeScript可以在这里警告我们｡

07:34.940 --> 07:37.390
如果我试图保存它, 它会给我们一个错误,

07:37.390 --> 07:40.870
因为它知道, 嘿, 这个承诺最终会产生一个数字,

07:40.870 --> 07:44.092
你可以在这个数字上调用拆分｡

07:44.092 --> 07:48.010
因此, 我们使用泛型类型获得了更好的类型安全｡ 

07:48.010 --> 07:52.720
因此, 您可以非常灵活地处理泛型类型信息｡

07:52.720 --> 07:54.830
数组知道它存储了哪些数据,

07:54.830 --> 07:57.140
承诺知道它返回了哪些数据｡

07:57.140 --> 08:02.140
如果您构建自己的泛型类或函数, 您可能会做一些完全不同的事情｡

08:02.140 --> 08:06.970
但是, 如果您有一个更复杂的类或更复杂的函数来处理传入的数据,

08:06.970 --> 08:10.640
泛型类型最终会帮助您获得额外的类型信息,

08:10.640 --> 08:16.020
在某种程度上, 泛型类型并不真正关心数据是否属于某个特定类型,

08:16.020 --> 08:27.590
而是您希望将类型信息存储在传入数据之外, 以便在使用泛型类型时获得更好的TypeScript支持｡

08:27.590 --> 08:30.450
所以无论你什么时候使用这个承诺, 或者数据数组,

08:30.450 --> 08:33.270
这基本上就是泛型的概念｡

08:33.270 --> 08:36.300
所以这里, 所有的都是用泛型构建的｡ 

08:36.300 --> 08:37.460
让我们注释掉它｡ 

08:37.460 --> 08:40.450
现在让我们构建自己的泛型类型字｡ 

08:40.450 --> 08:42.653
让我们使用自己的泛型类型｡ 
