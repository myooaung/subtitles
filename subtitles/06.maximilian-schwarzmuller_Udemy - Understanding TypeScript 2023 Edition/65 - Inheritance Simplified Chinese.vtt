WEBVTT

00:02.300 --> 00:03.830
教师：我们与我们的部门合作相当多,

00:03.830 --> 00:07.350
我创建了我的会计部门｡

00:07.350 --> 00:09.610
现在, 对于我们正在构建的应用程序,

00:09.610 --> 00:16.660
我们可能需要部门, 当然, 我们可能需要更多关于特定类型部门的信息｡

00:16.660 --> 00:18.830
我们可能有一个IT部门,

00:18.830 --> 00:22.680
它有一个ID, 一个名称, 一个雇员,

00:22.680 --> 00:24.900
但也有管理员, 例如,

00:24.900 --> 00:28.180
只有IT部门才有｡

00:28.180 --> 00:30.340
我们可能有会计部门,

00:30.340 --> 00:34.280
它也可能有ID､ 姓名和雇员,

00:34.280 --> 00:37.470
但它也可能有报告｡

00:37.470 --> 00:41.030
它生成的报表数组, 等等｡ 

00:41.030 --> 00:44.541
所以你可能有一些基本属性和方法, 所有部门都应该有,

00:44.541 --> 00:54.660
但我们可能有这些部门的专用版本, 它们有自己的特定属性和方法, 只有这个部门才有｡

00:54.660 --> 00:58.100
继承可以帮助我们实现类似的功能｡ 

00:58.100 --> 01:00.010
那么我们如何利用继承呢？

01:00.010 --> 01:01.670
我们有我们的班级部门｡ 

01:01.670 --> 01:05.130
现在我们来创建这些专门的部门｡ 

01:05.130 --> 01:08.483
因此, 我们可以拥有一流的IT部门｡ 

01:09.610 --> 01:14.010
在这堂课中, 我想利用姓名､ ID和综合部门的员工,

01:14.010 --> 01:19.537
但我想添加我自己的功能｡

01:19.537 --> 01:21.970
现在我们可以继承department类,

01:21.970 --> 01:24.270
方法是在这里使用extends关键字,

01:24.270 --> 01:25.970
然后使用我们想要继承的类｡

01:25.970 --> 01:27.530
在这种情况下, 那就是部门｡ 

01:27.530 --> 01:30.600
现在, 重要的是, 你只能从一个类继承,

01:30.600 --> 01:34.660
所以你不能从多个类继承, 如果你需要的话｡

01:34.660 --> 01:38.070
所以现在, 在这里, 我从department继承,

01:38.070 --> 01:40.700
一个结果是, 如果我现在在这里创建一个IT部门,

01:40.700 --> 01:49.400
我确实可以这样调用它, 用这种构造函数, 即使IT部门类是空的｡

01:49.400 --> 01:52.830
如果我们保存它, 我们确实可以看到它和以前一样工作,

01:52.830 --> 01:55.152
因为当我们从另一个类继承时,

01:55.152 --> 02:11.072
继承的类会自动得到基类, 在这个例子中是department, 拥有的所有东西, 包括它的构造函数, 所以只要我们不为这个继承的类添加一个专用的构造函数, 那么对于这个子类,

02:11.130 --> 02:20.800
基类的构造函数, 所以当我们实例化我们的子类时, 这个构造函数会自动被使用｡

02:20.800 --> 02:27.562
所以我们最后神奇地调用了基类构造函数, 用我们在这里传递的参数｡

02:27.562 --> 02:30.350
现在我们可以添加我们自己的构造函数了,

02:30.350 --> 02:35.800
不过, 在IT部门添加构造函数, 现在您可以看到我遇到了错误｡

02:35.800 --> 02:38.580
首先, 我们现在当然应该接受我们在这里得到的数据,

02:38.580 --> 02:44.120
尽管我们可以争辩说, 名字不应该是我们需要在这里传递的东西｡

02:44.120 --> 02:46.430
也不应该是会计｡ 

02:46.430 --> 02:49.110
但在这里, 部门的名称, 因为它是IT部门类,

02:49.110 --> 02:52.563
可以始终是IT｡

02:53.700 --> 02:56.910
虽然我仍然希望接受我的ID,

02:56.910 --> 03:01.130
但现在我希望实质上将其转发给department的构造函数,

03:01.130 --> 03:06.420
就像固定名称IT一样｡

03:06.420 --> 03:09.240
为此我们有一个特殊的关键字, 我们可以, 在这种情况下,

03:09.240 --> 03:11.120
我们必须, 使用｡

03:11.120 --> 03:13.210
这太棒了｡ 

03:13.210 --> 03:15.580
每当你在一个继承自另一个类的类中添加你自己的构造函数时,

03:15.580 --> 03:23.790
你必须在继承类中添加super, 并且你必须像函数一样执行它｡

03:23.790 --> 03:28.070
Super在这里调用基类的构造函数,

03:28.070 --> 03:31.300
所以本例中的部门构造函数｡

03:31.300 --> 03:33.690
现在, 另一个super接受父类构造函数的参数､

03:33.690 --> 03:37.630
ID和名称｡

03:37.630 --> 03:41.060
这里我可以转发ID, 这里得到的ID只是传递给super,

03:41.060 --> 03:46.860
我可以为名称硬编码一个值, 比如IT｡

03:46.860 --> 03:52.500
所以现在它将从子类内部调用基类的构造函数｡

03:52.500 --> 03:55.310
现在, 重要的是, 在使用“this”关键字执行任何操作之前,

03:55.310 --> 03:59.700
必须首先在构造函数中调用super｡

03:59.700 --> 04:06.670
因此, 如果您计划在此处分配任何其他特殊属性, 则必须在调用super之后执行此操作｡

04:06.670 --> 04:10.346
事实上, 我想在这里加上我自己的特性｡ 

04:10.346 --> 04:13.528
我们可以在此处添加管理员｡ 

04:13.528 --> 04:17.800
让我们说作为一个私人的, 或作为一个公共的, 实际上｡ 

04:17.800 --> 04:20.878
作为公共属性, admins,

04:20.878 --> 04:25.630
应该是一个字符串数组.

04:25.630 --> 04:27.780
我 不 想 把 它 转发 给 我

04:27.780 --> 04:31.460
的 基类 , 因为 department

04:31.460 --> 04:34.670
类 不 需要 任何 管理 员 数据 ｡

04:34.670 --> 04:42.150
相反, 我希望将其存储在IT部门的属性中, 这样我们就可以在此处将管理员添加为一个字段,

04:42.150 --> 04:44.922
该字段包含几个管理员并在其中存储管理员,

04:44.922 --> 04:49.070
或者因为我在此处使用了public, 所以我已经使用了该快捷方式,

04:49.070 --> 05:00.148
在该快捷方式中将创建一个同名的属性, 并且我们提供给此参数的数据将存储在该自动创建的属性中｡

05:00.148 --> 05:03.710
还是要说明一下, 必须先调用super, 我将采用较长得路径,

05:03.710 --> 05:12.610
在这里添加管理员, 就像这样, 然后在这里说, this.

05:12.610 --> 05:12.610
admins =管理员｡ 

05:13.260 --> 05:15.160
同样, 捷径会更短｡ 

05:15.160 --> 05:21.020
我在这里这样做是为了表明, 如果你使用的是使用“this”关键字的东西,

05:21.020 --> 05:24.480
你必须在调用super之后这样做｡

05:24.480 --> 05:27.640
如果我们保存它, 我会得到一个错误, 因为我没有传入任何管理员,

05:27.640 --> 05:30.920
所以我们在这里做这个｡

05:30.920 --> 05:33.920
麦克斯是我在这里遇到的唯一管理员｡ 

05:33.920 --> 05:36.950
现在, 我们可以保存它, 并编译它没有错误, 现在在这里,

05:36.950 --> 05:39.910
我们确实看到我们的部门在这里｡

05:39.910 --> 05:41.840
它现在的名称是IT｡ 

05:41.840 --> 05:44.670
如果我们对整个部门进行控制台日志记录,

05:44.670 --> 05:54.250
我们也许可以将其从会计重命名为IT, 然后再重命名为控制台｡

05:54.250 --> 05:54.250
在此处记录IT｡ 

05:54.250 --> 06:00.160
当然, 重命名是可选的, 只是更有意义, 因为我们在这里建立了一个IT部门｡

06:00.160 --> 06:02.510
现在, 我通过控制台记录了整个部门,

06:02.510 --> 06:11.110
我们确实看到了管理员, 但我们也看到了员工和我在部门类中设置的所有内容｡

06:12.000 --> 06:13.990
这就是继承的作用,

06:13.990 --> 06:16.520
这是一个非常有用的特性,

06:16.520 --> 06:20.770
因为现在, 我们当然还可以通过扩展部门来创建会计部门,

06:20.770 --> 06:27.030
然后在那里添加特定于会计的内容｡

06:27.030 --> 06:29.540
我们仍然可以在这里使用构造函数, 现在可以使用快捷方式,

06:29.540 --> 06:31.700
在这里接受几个报告, 这可能是一个私有属性,

06:31.700 --> 06:36.170
然后我们使用addReport, 它接受文本, 这应该是一个字符串, 然后我们在这里访问报告,

06:36.170 --> 06:40.950
并将文本作为一个项目推送到报告中, 也许我们还在这里使用getReports,

06:40.950 --> 06:56.990
在那里我们只是控制台｡

06:56.990 --> 06:56.990
记录（此. reports）,

06:57.563 --> 07:00.860
或者我们将其命名为printReports, 这样更有意义｡

07:00.860 --> 07:02.720
现在我们有了一个非常特殊的部门,

07:02.720 --> 07:04.890
它有两个基本部门没有的方法,

07:04.890 --> 07:09.840
还有一个基本部门没有的额外属性｡

07:09.840 --> 07:13.000
我们还是从基地部门得到一切｡ 

07:13.000 --> 07:15.560
名称, 我将在这里设置为accounting,

07:15.560 --> 07:20.260
ID, 我们也将其转发给基本部门构造函数｡

07:20.260 --> 07:24.770
这样, 如果我们在这里用新的会计部门创建我们的会计,

07:24.770 --> 07:27.510
我们可以输入我们的ID,

07:27.510 --> 07:31.750
然后输入我们的报告｡

07:31.750 --> 07:34.340
假设它最初是一个空数组｡ 

07:34.340 --> 07:39.340
然后, 我们可以调用addReport, 在会计方面出现了问题,

07:40.550 --> 07:43.446
当然, 我想这是不太好的问题,

07:43.446 --> 07:58.890
然后我们还可以在这里打印我们的报告, 这样, 它就可以很好地编译, 我们在这里得到报告, 我们可以看到, 例如, IT部门不会有任何报告｡

07:58.890 --> 08:01.820
会计部门这样做是因为继承, 我们继承了某些功能,

08:01.820 --> 08:05.623
并添加了我们自己的功能｡
