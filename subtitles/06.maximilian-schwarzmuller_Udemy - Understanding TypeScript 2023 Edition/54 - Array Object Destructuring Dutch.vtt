WEBVTT

00:02.100 --> 00:04.870
Instructeur: Laten we het bij arrays en objecten houden.

00:04.870 --> 00:06.750
Een andere belangrijke syntax,

00:06.750 --> 00:09.160
die je veel ziet in moderne JavaScript en

00:09.160 --> 00:10.440
ook Typescript projecten,

00:10.440 --> 00:13.133
is array en object destructurering.

00:14.180 --> 00:15.013
Hoe werkt het?

00:15.013 --> 00:17.220
Nou, laten we beginnen met onze array die

00:17.220 --> 00:20.220
we hebben, de hobby's array die twee hobby's heeft.

00:20.220 --> 00:22.200
Stel dat u deze twee hobby's

00:22.200 --> 00:26.340
wilt extraheren en opslaan in variabelen of constanten.

00:26.340 --> 00:28.891
Natuurlijk kunnen we dat doen met

00:28.891 --> 00:32.340
hobby één gelijk aan hobby's voor index nul,

00:32.340 --> 00:33.470
wat het eerste

00:33.470 --> 00:34.820
element is.

00:34.820 --> 00:38.720
En hetzelfde misschien met hobby twee voor hobby's op index één.

00:38.720 --> 00:40.500
Dit haalt deze twee elementen

00:40.500 --> 00:43.330
eruit en slaat ze op in constanten.

00:43.330 --> 00:44.720
Het kostte ons twee regels code,

00:44.720 --> 00:46.710
en hoe meer elementen je wilt ophalen, hoe

00:46.710 --> 00:48.493
meer regels code het ons kost.

00:49.340 --> 00:51.690
Met array destructurering kunnen we het inkorten.

00:51.690 --> 00:53.090
Met array destructurering,

00:53.090 --> 00:56.250
dat overigens ook werkt met let en niet alleen met const, voeg je vierkante

00:56.250 --> 00:59.760
haakjes toe aan de linkerkant van het gelijkheidsteken, wat een ongebruikelijke

00:59.760 --> 01:01.400
plaats is.

01:01.400 --> 01:02.900
Dat heb ik nog niet eerder gezien.

01:02.900 --> 01:04.780
En aan de rechterkant heb je de array,

01:04.780 --> 01:06.480
die je wilt destructureren.

01:06.480 --> 01:08.430
Nu betekent destructureren eigenlijk

01:08.430 --> 01:10.470
dat je elementen uit de array haalt.

01:10.470 --> 01:13.570
En hier aan de linkerkant tussen deze vierkante haakjes,

01:13.570 --> 01:15.040
sla je ze op in constanten, of

01:15.040 --> 01:17.250
als je let gebruikt, in variabelen.

01:17.250 --> 01:21.170
Dus hier zouden we dan hobby één en hobby twee kunnen hebben.

01:21.170 --> 01:23.000
En wat deze syntaxis doet, is de hobby-array

01:23.000 --> 01:25.640
doorlopen, het eerste element nemen en opslaan

01:25.640 --> 01:26.920
in een constante met deze

01:26.920 --> 01:30.290
naam, het tweede element nemen en opslaan in een constante

01:30.290 --> 01:32.320
met deze naam.

01:32.320 --> 01:35.490
U kunt hier zelfs restparameters toevoegen en hier

01:35.490 --> 01:38.720
resterende hobby's hebben voor het geval de hobby-array

01:38.720 --> 01:42.130
meer elementen had dan slechts twee.

01:42.130 --> 01:46.260
Dan worden alle resterende elementen die je niet in hobby één of hobby

01:46.260 --> 01:48.070
twee hebt getrokken, opgeslagen

01:48.070 --> 01:51.290
in een nieuwe matrix genaamd resterende hobby's.

01:51.290 --> 01:54.090
Dus worden ze samengevoegd tot een nieuwe matrix.

01:54.090 --> 01:57.940
Overigens verandert destructurering de oorspronkelijke array niet.

01:57.940 --> 02:02.940
Dus als we troosten. hobby's, hobby één, en hobby twee hier, zult u

02:04.260 --> 02:06.840
zien dat hobby's nog steeds de oude matrix is.

02:06.840 --> 02:08.840
Het is niet leeg of zoiets.

02:08.840 --> 02:11.780
Dus de waarden die we er tussen aanhalingstekens uithaalden

02:11.780 --> 02:14.870
zijn eigenlijk alleen maar gekopieerd naar nieuwe constanten

02:14.870 --> 02:17.720
of variabelen, niet echt verwijderd uit de array.

02:17.720 --> 02:18.980
Dat is array destructurering.

02:18.980 --> 02:20.600
We hebben hetzelfde voor objecten.

02:20.600 --> 02:21.690
We hebben onze persoon hier.

02:21.690 --> 02:23.440
Stel nu dat we naam en leeftijd willen

02:23.440 --> 02:26.630
opslaan in zelfstandige constanten, of variabelen.

02:26.630 --> 02:28.480
Net als array destructurering

02:28.480 --> 02:31.840
werkt object destructurering met zowel const als let.

02:31.840 --> 02:33.010
Hier ga ik voor const.

02:33.010 --> 02:34.930
En nu kunnen we accolades gebruiken aan

02:34.930 --> 02:37.090
de linkerkant van het gelijkheidsteken.

02:37.090 --> 02:38.883
Hoewel een nieuwe syntaxis, denk ik.

02:39.920 --> 02:43.750
En laat ons object, of de variabele wijzen naar het object aan

02:43.750 --> 02:44.890
de rechterkant.

02:44.890 --> 02:46.110
Let wel, dit is geen

02:46.110 --> 02:48.770
objecttype dat ik hier toeken.

02:48.770 --> 02:51.200
Ik heb hier geen dubbele punt.

02:51.200 --> 02:54.080
Het zijn eigenlijk gewoon accolades zoals deze aan

02:54.080 --> 02:58.210
de linkerkant zonder dubbele punt na een of andere constante naam.

02:58.210 --> 03:01.000
Dus ik wijs het type van de waarde die opgeslagen kan worden

03:01.000 --> 03:02.720
niet toe aan een constante.

03:02.720 --> 03:05.470
Ik gebruik gewoon een speciale syntaxis.

03:05.470 --> 03:08.450
Want hier kunnen we nu ook verwijzen naar namen

03:08.450 --> 03:11.340
van eigenschappen die we in een object hebben,

03:11.340 --> 03:13.920
bijvoorbeeld naam en leeftijd, om de

03:13.920 --> 03:18.030
waarden voor deze sleutels uit persoon te halen en op te slaan

03:18.030 --> 03:21.283
in constanten met dezelfde naam.

03:23.290 --> 03:24.390
Nu krijg ik hier fouten

03:24.390 --> 03:27.820
omdat ik helemaal bovenaan al een leeftijdsvariabele heb.

03:27.820 --> 03:30.890
En naam blijkt een globaal beschikbare variabele te zijn

03:30.890 --> 03:32.173
die toch al bestaat.

03:33.240 --> 03:34.940
Dus daar zou de workaround zijn

03:34.940 --> 03:38.313
om gewoon een andere sleutelnaam te gebruiken, firstName,

03:40.240 --> 03:41.920
bijvoorbeeld.

03:41.920 --> 03:45.020
En nu kunnen we de waarde bij die sleutel eruit halen.

03:45.020 --> 03:46.900
Dus dit is hoe object destructurering werkt.

03:46.900 --> 03:50.110
Het belangrijkste hier is dat bij array destructurering

03:50.110 --> 03:52.260
de elementen op volgorde worden getrokken,

03:52.260 --> 03:55.110
omdat een array een geordende lijst is.

03:55.110 --> 03:58.110
In objecten is de volgorde niet altijd gegarandeerd,

03:58.110 --> 04:00.720
en daarom trekken we elementen niet op positie,

04:00.720 --> 04:02.070
maar op sleutelnaam.

04:02.070 --> 04:04.790
Dus de waarden, of de namen die u hier tussen de

04:04.790 --> 04:05.930
accolades opgeeft,

04:05.930 --> 04:07.630
zijn niet willekeurig.

04:07.630 --> 04:09.700
Je kunt hier geen namen verzinnen.

04:09.700 --> 04:13.860
Dit moeten namen van eigenschappen zijn die je in het object vindt, zodat de

04:13.860 --> 04:16.010
waarden voor deze sleutels uit het object

04:16.010 --> 04:18.160
kunnen worden gehaald En dan worden ze

04:18.160 --> 04:20.600
opgeslagen in constanten of variabelen met

04:20.600 --> 04:21.880
dezelfde naam.

04:21.880 --> 04:24.120
Als u die naam wilt overschrijven, kunt u dat

04:24.120 --> 04:25.970
hier doen met een dubbele punt.

04:25.970 --> 04:28.050
Nogmaals, het is geen typeopdracht hier.

04:28.050 --> 04:29.680
Het stelt gewoon een nieuwe naam in.

04:29.680 --> 04:31.970
Dus dit is allemaal JavaScript syntax, heeft

04:31.970 --> 04:33.820
niets te maken met Typescript.

04:33.820 --> 04:35.370
Dus hier kunnen we dit bijvoorbeeld

04:35.370 --> 04:38.750
opslaan in een constante userName.

04:38.750 --> 04:39.840
En daarom kunnen

04:39.840 --> 04:44.040
we daarna troosten. log userName en age, maar niet firstName,

04:44.040 --> 04:45.290
omdat het in feite

04:45.290 --> 04:47.870
firstName overschreef tot userName

04:47.870 --> 04:50.900
in de constante die we creëren als we hier waarden

04:50.900 --> 04:52.790
ophalen.

04:52.790 --> 04:55.880
Leeftijd wordt niet overschreven, dus we kunnen het zo gebruiken.

04:55.880 --> 04:58.183
Nogmaals, dit is geen type opdracht hier.

04:58.183 --> 05:00.210
Dit is JavaScript syntaxis,

05:00.210 --> 05:03.680
waarbij we een eigenschap die we uit persoon trekken

05:03.680 --> 05:05.500
alias hernoemen.

05:05.500 --> 05:07.430
Ook is, net als eerder met de array,

05:07.430 --> 05:09.840
het persoonsobject zelf niet veranderd.

05:09.840 --> 05:13.380
We kopiëren deze waarden gewoon uit het object.

05:13.380 --> 05:15.643
En daarom krijgen we deze output hier.
