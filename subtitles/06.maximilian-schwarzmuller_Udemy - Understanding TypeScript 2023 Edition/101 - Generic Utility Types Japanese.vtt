WEBVTT

00:02.330 --> 00:04.870
ナレーター：より一般的なタイプといえば､

00:04.870 --> 00:06.970
ちょっとしたボーナスとして､

00:06.970 --> 00:11.410
いくつかの組み込みタイプを紹介することもできます｡

00:11.410 --> 00:20.350
Typescript には､ 特定のユーティリティ機能を提供する､ ジェネリック型またはジェネリック型を利用するものが同梱されています｡

00:20.350 --> 00:22.050
だから､ ここでちょっとだけオマケ｡

00:22.050 --> 00:25.550
時々､ こういう特殊なタイプが役に立つかもしれません｡

00:25.550 --> 00:30.680
さて､ 内蔵されたすべてのユーティリティタイプの完全なドキュメントへのリンクが添付されています｡

00:30.680 --> 00:33.810
ここで､ いくつかの例を挙げたいと思います｡ 

00:33.810 --> 00:36.010
さて､ これらすべての型のものと同様に､

00:36.010 --> 00:38.610
これらの型は世界の型の中にのみ存在し､ したがって､

00:38.610 --> 00:41.300
コンパイルの前にのみ存在します｡

00:41.300 --> 00:43.460
しかし､ このコンパイルの段階で､

00:43.460 --> 00:48.130
型の安全性を高めたり､ 柔軟性を高めたりすることができるのです｡

00:48.130 --> 00:51.670
例えば､ ビルトインのパーシャルタイプがあります｡ 

00:51.670 --> 00:55.580
私たちが新しいタイプを持っているとしましょう､ そして､ 私たちが見つけるか､ カスタムタイプは本当に重要ではありません､

00:55.580 --> 00:59.493
CourseGoalのあなたのインターフェイス｡

01:00.660 --> 01:03.780
CourseGoalはタイトル (文字列) と説明文

01:03.780 --> 01:09.040
(文字列) を持ちますが､ これらはすべて文字列でなければなりません｡

01:09.040 --> 01:14.040
また､ completeUntilプロパティがあり､ これはDateであるかもしれません｡ 

01:15.290 --> 01:17.961
さて､ このようなオブジェクトを作成する関数､

01:17.961 --> 01:21.500
例えば createCourseGoal を用意しましょう｡

01:21.500 --> 01:23.380
もちろん､ そのクラスも作れました｡ 

01:23.380 --> 01:26.290
しかし､ そのような関数があるのは､ その関数の中で､

01:26.290 --> 01:30.590
データベースからデータを取り込んだりすることがあるからです｡

01:30.590 --> 01:32.110
そこで､ このような機能を持たせています｡ 

01:32.110 --> 01:33.330
そして最後に､

01:33.330 --> 01:37.890
タイトル（文字列）､ 説明（文字列）､

01:37.890 --> 01:47.150
日付（日付）を取得したいと思います｡

01:47.150 --> 01:49.680
さて､ この関数では､ もちろんオブジェクトを返すこともできますが､

01:49.680 --> 01:51.740
これらのものをすべてセットアップするだけです｡

01:51.740 --> 01:57.840
そこで､ titleにタイトル､ descriptionに説明文､ completeUntilに日付を設定するところ｡

01:57.840 --> 02:00.760
そして､ この関数が常にCourseGoalを返すと定義すれば､

02:00.760 --> 02:07.120
正しく設定された関数ができあがります｡

02:07.120 --> 02:08.420
しかし､ 何らかの理由で､ このようなやり方ではなく､

02:08.420 --> 02:11.623
1つのステップでこれをすべて行うことにしましょう｡

02:12.680 --> 02:13.870
その代わりに､ まずここに変数を作って､

02:13.870 --> 02:18.700
空のオブジェクトを保持することにします｡

02:18.700 --> 02:22.620
そして段階を追って､ ここにタイトルを追加していきたいと思います｡ 

02:22.620 --> 02:26.420
ここに私の説明を加えたいと思います｡ 

02:26.420 --> 02:31.303
そして､ ここに私の日付を書き加えたいと思います｡ 

02:33.640 --> 02:36.420
もちろん､ このオブジェクトのプロパティではないので､ タイトルを設定することはできませんが､

02:36.420 --> 02:39.170
エラーが発生します｡

02:39.170 --> 02:41.930
そして､ これはバニラJavaScriptではうまくいくのですが､ TypeScriptでは､

02:41.930 --> 02:45.410
ここにオンザフライで追加するのはあまり好きではありません｡

02:45.410 --> 02:49.300
ですから､ ここではCourseGoal型であるべきだと言いたいのでしょう｡

02:49.300 --> 02:51.040
さて､ TypeScriptはこれに対して文句を言っているのではなく､

02:51.040 --> 02:56.223
これが空のオブジェクトであるという事実に対して文句を言っているのである｡

02:57.070 --> 02:58.360
最終的に､ 私はそれを返したいし､

02:58.360 --> 03:04.570
私はこれらのすべてのステップを追加したい､ 多分我々は余分なバリデーションを各ステップの前に､ したがって､

03:04.570 --> 03:07.590
このようにそれを追加するための1｡

03:07.590 --> 03:12.390
さて､ ここでパーシャルタイプが役に立つ｡ 

03:12.390 --> 03:21.600
ここで言うCourseGoalは部分型であるべきで､ 最終的には総称型のおかげでCourseGoalを保持することになります｡

03:21.600 --> 03:28.260
これはTypeScriptに､ これは最終的にcourseGoalになるオブジェクトであることを伝えるものです｡

03:28.260 --> 03:36.620
しかし､ 最初は､ パーシャルが私たち自身の型をラップし､ これらのプロパティがすべてオプションであるような型に変更します｡

03:36.620 --> 03:40.670
それが､ Typescriptに搭載されている組み込み型の1つであるパーシャルです｡

03:40.670 --> 03:45.713
つまり､ これを型に変えるわけですが､ この型もオブジェクト型で､ すべてのプロパティがオプションになっています｡

03:45.713 --> 03:53.030
そのため､ 最初は空のオブジェクトに設定し､ それでも段階的にこれらすべてを追加していくことができます｡

03:53.030 --> 03:54.880
唯一の問題は､ 最終的に､ 今､ それはまだ部分的なCourseGoalのタイプであり､

03:54.880 --> 04:02.130
CourseGoalのタイプではないので､ これを返すことができないことである｡

04:02.130 --> 04:04.630
この時点で､ すべてのデータを追加したことが分かっているので､

04:04.630 --> 04:08.990
これをタイプキャストでcourseGoalに変換することで修正できます｡

04:08.990 --> 04:11.667
だから､ 部分的なものではなく､ 本当の意味でのCourseGoalになるのです｡ 

04:11.667 --> 04:13.510
もちろん､ これはちょっと作り物なんですけどね｡ 

04:13.510 --> 04:15.500
しかし､ このようなシナリオもあり得ます｡

04:15.500 --> 04:23.530
オブジェクト・タイプやインターフェースの1つを一時的にオプションのみに切り替えたい場合です｡

04:23.530 --> 04:28.170
そこにあるすべてのプロパティが､ 一時的にしかオプションにできないようにするためです｡

04:28.170 --> 04:31.223
そして､ パーシャルタイプならそれが可能になる｡ 

04:32.370 --> 04:35.920
また､ ビルトインのユーティリティ・タイプは､

04:35.920 --> 04:40.170
読み取り専用で､ 非常に便利なタイプです｡

04:40.170 --> 04:42.623
例えば､ 名前の配列があるとします｡ 

04:43.460 --> 04:46.330
そして､ その中にマックスとスポーツがありました｡ 

04:46.330 --> 04:49.860
さて､ 正しくTypeScriptはこれが文字列配列であると推論しています｡

04:49.860 --> 04:50.960
さて､ 私たちにできることは何でしょう？

04:50.960 --> 04:52.690
もちろん､ マヌーをそこに押し込むこともできますし､

04:53.700 --> 04:55.400
おそらく､ アンナはスポーツをしないので､

04:55.400 --> 04:59.720
そこに名前を入れるように変更した方がいいと思います｡

04:59.720 --> 05:00.553
だから､ これは有効なのです｡ 

05:00.553 --> 05:04.230
しかし､ ここで､ この配列がロックされた配列であることを確認したいとします｡

05:04.230 --> 05:06.260
ここでこれ以上追加することはできません｡ 

05:06.260 --> 05:07.870
そして､ ここでいつでも追加できるのですが､

05:07.870 --> 05:11.690
少なくとも､ 試しにやってみたら､ Typescriptに怒鳴られるようにしたいのです｡

05:11.690 --> 05:13.730
さて､ そこで読み取り専用の型が使えるわけですが､

05:13.730 --> 05:18.730
これを読み取り専用の文字列配列に設定することができます｡

05:18.930 --> 05:20.510
これでTypeScriptに､ ここに格納されているのは文字列の配列です､

05:20.510 --> 05:23.030
と伝えることができます｡

05:23.030 --> 05:25.830
しかし､ それは文字列の配列でもあり､ 読み取り専用です｡ 

05:25.830 --> 05:28.210
つまり､ pushで何かを追加しようとしたり､

05:28.210 --> 05:36.320
popで何かを削除しようとすると､ エラーが発生するのです｡

05:36.320 --> 05:41.610
ちなみに､ これは配列に限ったことではなく､ オブジェクトに対して読み取り専用を使用することも可能です｡

05:41.610 --> 05:43.990
例えば､ 読み取り専用として販売することで､ このオブジェクトのプロパティを変更したり､

05:43.990 --> 05:49.920
新しいプロパティを追加したりすることができないようにすることができます｡

05:49.920 --> 05:52.240
これは非常に便利で､ より柔軟に､

05:52.240 --> 05:59.490
あるいはより正確に､ コードの中で何をしようとしているのかを示すことができます｡

05:59.490 --> 06:03.610
さて､ これらはすべてTypeScriptの世界にしか存在しないユーティリティ型に過ぎない｡

06:03.610 --> 06:05.881
だから､ 何もコンパイルされていないんです｡ 

06:05.881 --> 06:09.400
しかし､ コンパイル時には､ 余計な厳密さを与えたり､ 余計なチェックを入れたり､

06:09.400 --> 06:14.800
パーシャルでやったように特定のチェックを飛ばしたりします｡

06:14.800 --> 06:17.170
これで､ 読み取り専用やパーシャル以上の機能を手に入れたことになります｡ 

06:17.170 --> 06:22.420
また､ 添付資料として､ これらのユーティリティの全リストを掲載しています｡

06:22.420 --> 06:25.580
ある場面では､ 本当に便利なものなので､

06:25.580 --> 06:28.350
絶対に隠したくなかったんです｡

06:28.350 --> 06:30.500
しかし､ その代わりに､ 何かをロックする必要があるときや､

06:30.500 --> 06:34.060
何かを部分的に開くとき､ あるいはここでは説明しませんでしたが､

06:34.060 --> 06:39.690
これらの組み込みユーティリティの1つを使用して拡張できる操作がある場合に､ それらを使用できるように､

06:39.690 --> 06:45.140
それらを認識しておく必要があります｡

06:45.140 --> 06:47.670
これらのユーティリティ型はすべて汎用です｡ なぜなら､

06:47.670 --> 06:49.170
これらのユーティリティ型が行うことは､

06:49.170 --> 06:54.190
任意の型の他の値を受け取り､ それを使って何かを行うことだからです｡

06:54.190 --> 06:57.970
配列なのかオブジェクトなのか､ 文字列の配列なのか数字の配列なのか､

06:57.970 --> 07:01.330
そんなことは気にせず､ すべてをオプションに設定して､

07:01.330 --> 07:04.430
ロックしてしまうのです｡

07:04.430 --> 07:06.000
だから､ これらは汎用品なのです｡ 

07:06.000 --> 07:10.790
そして､ 先ほど見た上位のビルトインジェネリックと､ 独自のジェネリックも一緒に｡

07:10.790 --> 07:16.793
これで､ ジェネリックがなぜ便利なのか､ その存在意義を改めて理解していただけたと思います｡
