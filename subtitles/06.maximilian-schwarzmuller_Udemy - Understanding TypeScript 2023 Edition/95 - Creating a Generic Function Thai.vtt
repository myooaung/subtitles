WEBVTT

00:02.190 --> 00:04.480
ดังนั้นเพื่อเริ่มต้นด้วยชื่อสามัญของเราเอง

00:04.480 --> 00:06.820
ที่นี่ด้านล่างรหัสแสดงความคิดเห็น

00:06.820 --> 00:09.210
ฉันจะเริ่มต้นด้วยฟังก์ชันทั่วไป

00:09.210 --> 00:11.430
คุณสามารถสร้างคลาสและฟังก์ชันทั่วไปได้

00:11.430 --> 00:15.350
ฉันจะแสดงทั้งสองอย่าง และที่นี่ฉันจะเริ่มต้นด้วยฟังก์ชัน

00:15.350 --> 00:22.490
สมมติว่าเราต้องการมีฟังก์ชันที่รวมสองออบเจกต์และส่งคืนออบเจกต์ใหม่

00:23.660 --> 00:25.380
ตรงนี้เราเรียกมันว่า "ผสาน" ก็ได้

00:25.380 --> 00:28.803
และเราต้องการรับวัตถุ A และวัตถุ B เป็นอินพุต

00:30.010 --> 00:33.990
แน่นอนว่าตอนนี้เราสามารถเขียนฟังก์ชันนี้ด้วยวิธีหนึ่งได้

00:33.990 --> 00:39.033
เราสามารถพูดได้ว่านี่คือวัตถุประเภทและนี่คือวัตถุประเภท

00:39.960 --> 00:45.200
แล้วสิ่งที่ฟังก์ชันนี้ทำคือส่งกลับผลลัพธ์ของการกำหนดวัตถุ

00:45.200 --> 00:48.130
ฉันได้รับวัตถุ A และวัตถุ B ที่ไหน

00:48.130 --> 00:53.000
แน่นอนว่าเนื่องจากเราได้วิธีการกำหนดวัตถุนี้แล้วในจาวาสคริปต์ปกติ

00:53.000 --> 00:58.140
เราอาจโต้แย้งว่าเราต้องการฟังก์ชันการผสานจริงๆ หรือไม่ แต่แน่นอนว่าคุณสามารถทำงานเพิ่มเติมที่นี่ได้

00:58.140 --> 01:00.480
คุณสามารถทำให้สิ่งนี้สมบูรณ์ยิ่งขึ้นด้วยข้อมูลเพิ่มเติม

01:00.480 --> 01:01.833
พร้อมตัวเลือกเพิ่มเติม และท้ายที่สุดแล้ว

01:01.833 --> 01:04.730
นี่เป็นเพียงการสาธิตเท่านั้น และตัวอย่างเท่านั้น

01:04.730 --> 01:07.510
นี่จึงจะถูกต้อง เราสามารถเรียกการผสานที่นี่

01:07.510 --> 01:11.830
และคอนโซลบันทึกผลลัพธ์ เช่นนี้

01:11.830 --> 01:20.010
จากนั้นส่งวัตถุที่มีคีย์ชื่อและวัตถุที่สองซึ่งมีอายุและถ้าเราเรียกใช้สิ่งนั้นและเราบันทึกสิ่งนี้

01:20.010 --> 01:22.780
ที่นี่ในเบราว์เซอร์เราได้รับผลลัพธ์นี้

01:22.780 --> 01:24.280
ดังนั้นเราจึงได้วัตถุผสานนี้

01:24.280 --> 01:33.300
ตอนนี้ได้ผล ปัญหาที่เรามีคือถ้าเราพยายามเก็บชื่อการผสานนี้ไว้สูงสุด

01:33.300 --> 01:38.097
และอายุ 30 ปี

01:39.620 --> 01:50.020
หากเราพยายามจัดเก็บที่นี่ ฉันไม่สามารถเข้าถึงชื่อบนผลลัพธ์ ฉันไม่สามารถเข้าถึงอายุบนผลลัพธ์บนวัตถุที่ผสานนี้

01:50.020 --> 01:52.360
แม้ว่าเราจะรู้ว่าทั้งสองจะมีอยู่

01:52.360 --> 01:54.830
เพราะ typescript ไม่รู้เรื่องนี้

01:54.830 --> 01:57.100
typescript ไม่สามารถรู้เรื่องนี้ได้

01:57.100 --> 02:02.370
เนื่องจากเราแค่บอกว่าคุณจะได้รับวัตถุและในตอนท้ายพิมพ์ก่อนที่เราจะส่งคืนวัตถุ

02:02.370 --> 02:07.810
ข้อใดถูกต้อง แต่ไม่ได้มีข้อมูลทั้งหมดที่เราสามารถใช้ได้ที่นี่

02:07.810 --> 02:09.970
แน่นอนว่าตอนนี้เราสามารถทำ typecast ได้เสมอ

02:09.970 --> 02:15.960
เราสามารถบอก typescript ว่าสิ่งที่เราได้รับกลับมาคือวัตถุที่เรามีคีย์ชื่อและที่ที่เรามีคีย์อายุ

02:15.960 --> 02:19.020
แต่นั่นเป็นเรื่องที่ยุ่งยากมากหากเราต้องทำอย่างนั้น

02:19.020 --> 02:21.420
ดังนั้น ยาชื่อสามัญสามารถช่วยเราได้

02:21.420 --> 02:26.470
เราเปลี่ยนสิ่งนี้ให้เป็นฟังก์ชันทั่วไปโดยเพิ่มวงเล็บมุมเหล่านี้หลังชื่อฟังก์ชัน

02:26.470 --> 02:29.740
จากนั้นเรากำหนดตัวระบุ Q

02:29.740 --> 02:33.190
โดยปกติคุณจะขึ้นต้นด้วย T สำหรับประเภท

02:33.190 --> 02:35.600
แต่คุณสามารถใช้ตัวระบุใดก็ได้ที่นี่ ไม่จำเป็นต้องเป็นอักขระตัวเดียว

02:35.600 --> 02:43.690
แต่หลักการคือใช้อักขระตัวเดียว และโดยทั่วไปแล้ว ถ้าคุณมีประเภททั่วไปเพียงประเภทเดียว คุณจะตั้งชื่อ T นี้

02:43.690 --> 02:48.510
แล้วคุณก็พูดว่า แบบทั่วไปตรงนี้ ตอนนี้มีอยู่ในฟังก์ชันนี้แล้ว

02:48.510 --> 02:51.453
เราจึงบอกได้ว่าสิ่งที่เราได้รับนี่คือประเภท T

02:53.090 --> 02:55.740
ดูแปลก ๆ เราจะไปถึงที่นั่นโดยไม่ต้องกังวล

02:55.740 --> 02:59.570
ทีนี้ เราได้ข้อโต้แย้งสองข้อที่เราไม่รู้แน่ชัดว่ามันจะออกมาเป็นอย่างไร

02:59.570 --> 03:02.450
ดังนั้นฉันจะยอมรับประเภททั่วไปที่สองที่นี่

03:02.450 --> 03:04.340
เพียงเพิ่มเครื่องหมายจุลภาคในวงเล็บเหลี่ยม

03:04.340 --> 03:07.400
จากนั้นเราก็ดำเนินการต่อในตัวอักษร

03:07.400 --> 03:10.490
และสำหรับพารามิเตอร์ทั่วไปตัวที่สองหรือประเภทที่คุณอาจใช้ในฟังก์ชัน

03:10.490 --> 03:15.490
โดยทั่วไปจะมีชื่อว่า U

03:15.630 --> 03:18.560
เราจึงบอกได้ว่านี่คือประเภท U

03:18.560 --> 03:22.100
ตกลงตอนนี้สิ่งนี้ให้อะไรเราบ้าง

03:22.100 --> 03:25.450
อันที่จริง อย่างที่คุณเห็นด้วยสิ่งนี้เพียงอย่างเดียว

03:25.450 --> 03:28.620
หากคุณวางเมาส์เหนือการผสาน typescript จะอนุมานว่าฟังก์ชันนี้ส่งคืนจุดตัดของ

03:28.620 --> 03:33.230
T และ U

03:33.230 --> 03:36.800
และแน่นอนว่าเราสามารถตั้งค่านี้อย่างชัดเจนได้เช่นกัน

03:36.800 --> 03:38.040
แต่เราไม่จำเป็นต้องทำเช่นนั้นด้วยซ้ำ

03:38.040 --> 03:42.010
เพราะ object assign ส่งกลับจุดตัด และเนื่องจากเราส่งคืนผลลัพธ์ของ

03:42.010 --> 03:48.390
object assign typescript จึงเข้าใจโดยอัตโนมัติว่าฟังก์ชันนี้ส่งคืนจุดตัด

03:48.390 --> 03:50.320
แล้วสิ่งนี้มีประโยชน์อย่างไร?

03:50.320 --> 03:52.510
ทีนี้ถ้าเราวางเมาส์เหนือวัตถุที่ผสาน

03:52.510 --> 03:54.260
เราจะเห็นว่าตอนนี้ด้วย typescript

03:54.260 --> 03:59.230
เพียงอย่างเดียวนี้ เข้าใจว่าสิ่งที่เราเก็บไว้ในวัตถุที่ผสานคือจุดตัดของวัตถุทั้งสองประเภทนี้

03:59.230 --> 04:01.690
เพราะมันเห็นว่าเรากำลังผ่านวัตถุเหล่านี้

04:01.690 --> 04:06.100
ซึ่งเป็นของวัตถุเหล่านี้ ประเภทมันอนุมาน

04:06.100 --> 04:08.840
สตริงชื่อและหมายเลขอายุ

04:08.840 --> 04:11.590
และฟังก์ชันของเราคืนค่าจุดตัด

04:11.590 --> 04:13.630
เหตุใดจึงสามารถสรุปสิ่งนี้ได้ในตอนนี้

04:13.630 --> 04:16.313
ไม่ใช่วัตถุที่เราเคยมีมาก่อน

04:17.220 --> 04:19.560
เนื่องจากวัตถุเป็นประเภทที่ไม่เฉพาะเจาะจงสูง

04:19.560 --> 04:22.490
เราพูดว่าวัตถุใด ๆ และใช่สำหรับ typescript

04:22.490 --> 04:26.600
สามารถสรุปได้ว่าเราส่งคืนจุดตัดของวัตถุและวัตถุ

04:26.600 --> 04:32.270
แต่จุดตัดของวัตถุที่ไม่รู้จักสองชิ้นเป็นเพียงวัตถุใหม่ที่ไม่รู้จักซึ่งไม่ได้ให้ข้อมูลประเภทเพิ่มเติมแก่

04:32.270 --> 04:35.420
typescript

04:35.420 --> 04:38.170
สำหรับประเภททั่วไป สิ่งที่เรากำลังบอก

04:38.170 --> 04:43.170
typescript ก็คือ พารามิเตอร์ทั้งสองนี้สามารถและมักจะเป็นประเภทที่แตกต่างกัน

04:43.282 --> 04:49.690
และด้วยเหตุนี้ typescript สามารถเข้าใจได้ว่าเราไม่ได้ทำงานกับวัตถุสุ่มบางประเภทเท่านั้น

04:49.690 --> 04:55.250
แต่เราจะได้รับความแตกต่าง พิมพ์ข้อมูลที่นี่

04:55.250 --> 04:59.770
และฟังก์ชันนี้โดยรวมจะส่งกลับจุดตัดของข้อมูลนั้น

04:59.770 --> 05:07.910
และด้วยเหตุนี้ typescript จึงเข้าใจได้ว่าสิ่งที่เราเก็บไว้ในนี้ในวัตถุที่ผสานนั้นตัดกันข้อมูลของอินพุตทั้งสองนี้

05:07.910 --> 05:09.530
เพราะตอนนี้เราไม่ได้แค่จัดการกับวัตถุที่ไม่รู้จักที่นี่

05:09.530 --> 05:14.423
แต่กับประเภทที่เฉพาะเจาะจงมาก

05:15.330 --> 05:22.980
และสำหรับตอนนี้ ถ้าฉันคอนโซลบันทึกอายุวัตถุที่ผสานที่นี่ สิ่งนี้จะทำงานได้โดยไม่มีข้อผิดพลาดอย่างที่คุณบอกได้

05:22.980 --> 05:26.770
ที่นี่ฉันกำลังพิมพ์ 30 เนื่องจากประเภททั่วไป

05:26.770 --> 05:29.040
เรากำลังให้ข้อมูลเพิ่มเติมเกี่ยวกับ typescript

05:29.040 --> 05:31.950
ที่เราไม่ทราบแน่ชัดว่า typescript จะแน่ใจได้อย่างไร

05:31.950 --> 05:34.780
จะมีวัตถุที่นี่เราสามารถบอกได้

05:34.780 --> 05:36.550
แต่เราไม่รู้ว่ามันเป็นวัตถุที่มีคีย์ชื่อ

05:36.550 --> 05:38.640
มีคีย์อายุ กับคีย์งานอดิเรก

05:38.640 --> 05:41.130
เราไม่รู้และเราไม่สนใจ เราไม่สนใจวัตถุตรงนี้

05:41.130 --> 05:46.050
เราไม่ต้องการระบุว่าสิ่งนี้ต้องเป็นประเภทนี้

05:46.050 --> 05:47.490
เพราะจู่ๆ ถ้าฉันเพิ่มงานอดิเรกเข้าไป

05:47.490 --> 05:50.520
เราจะมีปัญหากัน

05:50.520 --> 05:52.540
ฉันจึงไม่อยากถูกจำกัดขนาดนั้น

05:52.540 --> 05:54.480
ฉันแค่อยากจะบอกว่านี่เป็นประเภทใดก็ได้ที่ฉันไม่สนใจ

05:54.480 --> 05:58.590
แต่น่าจะเป็นประเภทที่แตกต่างจากนี้มากที่สุด

05:58.590 --> 06:00.860
และถ้ามันเหมือนกันก็คงจะดีเหมือนกัน

06:00.860 --> 06:06.530
แต่ typescript เข้าใจว่าเรามีประเภทเฉพาะที่นี่สำหรับพารามิเตอร์สองตัวนี้

06:06.530 --> 06:08.800
และเราส่งคืนจุดตัดของพวกมัน

06:08.800 --> 06:12.660
แทนที่จะมีวัตถุที่ไม่เจาะจงที่นี่

06:12.660 --> 06:14.770
ทีนี้ ความมหัศจรรย์ของที่นี่ไม่ใช่แค่การที่เราบอก

06:14.770 --> 06:18.410
typescript ว่าเรามีสองแบบที่แตกต่างกันที่นี่

06:18.410 --> 06:20.740
แต่ประเภทเหล่านี้ไม่ได้ถูกกำหนดให้เป็นหินเมื่อเรากำหนดฟังก์ชันนี้

06:20.740 --> 06:25.810
แต่จะถูกตั้งค่าแบบไดนามิกเมื่อเราเรียกใช้ฟังก์ชัน

06:25.810 --> 06:27.430
เรากำลังเรียกใช้ฟังก์ชันและ

06:27.430 --> 06:30.560
typescript อนุมานประเภทของอาร์กิวเมนต์ทั้งสอง

06:30.560 --> 06:39.600
สำหรับ T โดยทั่วไปจะเติมประเภทวัตถุด้วยวัตถุที่มีคุณสมบัติชื่อซึ่งเก็บสตริงและคุณสมบัติงานอดิเรกซึ่งเก็บอาร์เรย์ของสตริง

06:39.600 --> 06:47.990
และสำหรับ U จะเติมประเภทของวัตถุที่มีคุณสมบัติอายุโดยที่อายุเป็นตัวเลขประเภท

06:47.990 --> 06:51.030
ตอนนี้เมื่อเราเรียกใช้ฟังก์ชันนี้อีกครั้งในบรรทัดอื่น

06:51.030 --> 06:57.090
และเราส่งผ่านออบเจกต์ต่างๆ และฉันเก็บค่านี้ไว้ในค่าคงที่ใหม่พร้อมชื่อใหม่ แน่นอนว่า

06:57.090 --> 07:03.130
ประเภทต่างๆ จะถูกเติมสำหรับ T และ U สำหรับการเรียกใช้ฟังก์ชันนี้

07:03.130 --> 07:11.320
คุณยังสามารถบอก typescript ได้ว่าควรกรอกประเภทใดโดยการเพิ่มวงเล็บเหลี่ยมหลังชื่อฟังก์ชันเมื่อคุณเรียกใช้

07:11.320 --> 07:13.010
จากนั้นคุณจะต้องกรอกประเภทของคุณเองสำหรับ

07:13.010 --> 07:15.200
T และ U

07:15.200 --> 07:18.030
เราสามารถบอก typescript ได้ว่า T ควรเป็น type string

07:18.030 --> 07:20.180
สำหรับการเรียกใช้ฟังก์ชันนี้ และ U

07:20.180 --> 07:22.710
ควรเป็น type number แต่แน่นอนว่า typescript

07:22.710 --> 07:25.940
จะบ่นเกี่ยวกับค่าที่เป็นรูปธรรมที่เราส่งมา

07:25.940 --> 07:28.270
เนื่องจากสิ่งนี้ไม่ใช่สตริงอย่างชัดเจนและหากเราจะแก้ไขสิ่งนี้

07:28.270 --> 07:32.280
สิ่งนี้จะไม่ใช่หมายเลขประเภทอย่างชัดเจน

07:32.280 --> 07:34.650
ในที่นี้เราสามารถเจาะจงมากและพูดได้ดี

07:34.650 --> 07:41.700
อาร์กิวเมนต์แรกหรือประเภท T เพื่อให้แม่นยำสำหรับการเรียกใช้ฟังก์ชันนี้จะเป็นประเภทวัตถุที่เรามีคุณสมบัติชื่อซึ่งเป็นประเภทสตริง

07:41.700 --> 07:48.850
และคุณสมบัติงานอดิเรกซึ่งเป็นประเภท อาร์เรย์สตริง

07:48.850 --> 07:57.320
และประเภทคอนกรีตสำหรับ U สำหรับการเรียกใช้ฟังก์ชันนี้จะเป็นวัตถุที่เรามีคุณสมบัติอายุซึ่งควรเป็นประเภทตัวเลข

07:57.320 --> 08:02.730
และตอนนี้เราจะทำได้ดีและไม่มีข้อผิดพลาดอีกต่อไปและสิ่งนี้จะได้ผล

08:02.730 --> 08:05.060
แต่สิ่งนี้ซ้ำซ้อน คุณสามารถทำอย่างนั้นได้อย่างแน่นอน

08:05.060 --> 08:15.170
และสิ่งสำคัญคือต้องเข้าใจว่าในท้ายที่สุดนี่คือสิ่งที่ชื่อสามัญเกี่ยวกับที่คุณสามารถเติมในประเภทคอนกรีตต่างๆ สำหรับการเรียกฟังก์ชันต่างๆ

08:15.170 --> 08:16.930
แต่เราไม่จำเป็นต้องทำที่นี่เพราะ

08:16.930 --> 08:22.170
typescript อนุมานประเภทของค่าที่เราส่งเป็นอาร์กิวเมนต์ที่นี่

08:22.170 --> 08:25.120
จากนั้นวางในประเภทที่อนุมานสำหรับ

08:25.120 --> 08:28.240
T และ U สำหรับการเรียกใช้ฟังก์ชันนี้

08:28.240 --> 08:31.283
นั่นเป็นวิธีที่ยาสามัญทำงานอยู่เบื้องหลังในตอนท้าย
