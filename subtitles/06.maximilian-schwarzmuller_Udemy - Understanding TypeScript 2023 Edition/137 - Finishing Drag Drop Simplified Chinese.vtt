WEBVTT

00:02.300 --> 00:03.133
教师：当然,

00:03.133 --> 00:05.250
我们的目标不仅仅是记录ID｡

00:05.250 --> 00:11.110
相反, 我想在日志中提取项目ID, 在drop处理程序中｡

00:11.110 --> 00:15.410
这样, 我们的目标是现在就真正移动项目,

00:15.410 --> 00:18.910
或者确切地说, 改变项目状态｡

00:18.910 --> 00:21.400
现在, 我们如何才能做到这一点？

00:21.400 --> 00:26.063
在我们的状态下, 我会说, 在我们的项目状态下, 我们目前有一个addProject方法,

00:26.950 --> 00:33.160
我们还需要一个moveProject方法｡

00:33.160 --> 00:38.550
而这个方法的目标将是基本上切换一个项目的状态｡

00:38.550 --> 00:40.180
当然, 您也可以将其命名为SwitchProjectStatus或任何您想要的名称,

00:40.180 --> 00:46.440
但由于我们使用的是拖放操作, 因此我将其命名为MoveProject｡

00:46.440 --> 00:49.470
因此, 在MoveProject中,

00:49.470 --> 00:53.860
目标是将项目从其当前所在的列表移动到一个新列表｡

00:53.860 --> 00:58.030
现在, 这并不总是意味着我们必须将项目状态从活动状态转换为已完成状态,

00:58.030 --> 01:00.480
或者相反｡

01:00.480 --> 01:05.060
毕竟, 用户可以在同一个框中拖放｡

01:05.060 --> 01:07.120
因此, 如果我们总是触发一个切换状态的方法,

01:07.120 --> 01:15.754
我们会有一个意想不到的效果, 即放在同一个框中仍然会将项目切换到另一个框｡

01:15.754 --> 01:18.972
因此, 在MoveProject中,

01:18.972 --> 01:23.402
我们必须知道要移动哪个项目, 以及新框是哪个框｡

01:23.402 --> 01:24.235
新状态是哪个状态｡ 

01:25.940 --> 01:31.410
因此, 我希望在这里获得项目ID（应该是字符串）和新状态｡

01:31.410 --> 01:36.410
当然, 这里的新状态可以是ProjectStatus类型｡

01:38.580 --> 01:40.803
然后在MoveProject中,

01:41.692 --> 01:46.830
我想在项目数组中找到一个具有该ID的项目｡

01:46.830 --> 01:49.090
那么在这里, 在这个数组的项目中,

01:49.090 --> 01:51.680
然后翻转它的状态｡

01:51.680 --> 01:54.580
因此我们可以访问这个项目的,

01:54.580 --> 01:59.440
在那里找到一个项目, find方法非常适合｡

01:59.440 --> 02:01.210
它在数组中的每个元素上运行,

02:01.210 --> 02:03.970
让我们访问每个元素, 然后如果它是我们要找的元素,

02:03.970 --> 02:05.770
我们就必须返回true.

02:05.770 --> 02:12.830
如果我们当前看到的元素的ID等于这里作为参数得到的projectId,

02:12.830 --> 02:15.420
那么我们就得到了应该改变的元素,

02:15.420 --> 02:21.070
在这个元素上, 我们只需要把状态改变为新的状态｡

02:21.070 --> 02:22.653
这可能是空的, 所以这里我把它叫做project,

02:23.490 --> 02:30.550
存储为常量, 叫做project, 然后检查project是否存在｡

02:30.550 --> 02:39.160
如果它存在, 那么我想在这里设置状态等于新状态｡

02:39.160 --> 02:39.160
就这么简单｡ 

02:39.250 --> 02:45.643
这已经改变了数组中的对象, 我们基本上已经完成了.

02:46.970 --> 02:50.010
当然, 我们还没有完全完成｡ 

02:50.010 --> 02:52.250
我们现在需要让所有人知道,

02:52.250 --> 02:56.040
我们所有的听众, 我们的项目发生了一些变化,

02:56.040 --> 02:57.870
他们应该重新渲染｡

02:57.870 --> 02:59.980
所以我们必须再次检查所有的监听器,

02:59.980 --> 03:04.080
因为我们会在这里重复代码, 我将在一个新的私有方法中外包,

03:04.080 --> 03:07.920
updateListeners可以是一个可行的名称, 在那里我将有一个for循环,

03:07.920 --> 03:13.660
在那里我们检查所有的监听器, 然后做一些事情｡

03:13.660 --> 03:20.890
然后我将从addProject和moveProject方法调用这个updateListeners｡

03:20.890 --> 03:23.033
在这里, 除非我们改变了什么｡ 

03:24.350 --> 03:26.100
现在所有的监听器都将被触发｡ 

03:26.100 --> 03:33.010
如果你还记得的话, 我们的应用程序中的监听器基本上会引导列表重新呈现它的项目｡

03:33.010 --> 03:35.310
因此, 它将完全按照它应该的方式工作,

03:35.310 --> 03:37.940
或者它应该完全按照它应该的方式工作｡

03:37.940 --> 03:40.640
现在我们有了moveProject方法, 在下面的drop处理程序中,

03:40.640 --> 03:43.730
我们现在可以使用它了.

03:43.730 --> 03:46.390
在这里, 我们现在可以使用projectState,

03:46.390 --> 03:49.670
调用moveProject, 并传入项目ID,

03:49.670 --> 03:52.296
现在是新的项目状态｡

03:52.296 --> 03:57.880
新的项目状态取决于我们放置它的列表｡

03:57.880 --> 04:04.050
所以, 我想自动绑定我的放置处理程序, 这样放置处理程序中的this关键字引用周围的类,

04:04.050 --> 04:10.320
这个周围的类是一个项目列表, 如果你还记得的话, 这里有一个类型属性,

04:10.320 --> 04:13.020
我们在这里存储它, 我们有一个类型,

04:13.020 --> 04:18.120
属性, 它是活动的或完成的｡

04:18.120 --> 04:22.640
所以现在我们只需要将active或finished转换为枚举值｡

04:22.640 --> 04:24.850
所以在这里, 我把这个传了进去｡  类型, 并检查它是否等于active,

04:24.850 --> 04:31.580
如果是, 则传入ProjectStatus｡

04:31.580 --> 04:31.580
活动,

04:31.580 --> 04:38.160
作为项目的新状态, 因为这是我们将项目移动到的列表的状态｡

04:38.160 --> 04:41.733
否则, 我们将传入ProjectStatus｡  完成了, 让我重新格式化,

04:42.660 --> 04:45.423
使它更容易阅读｡

04:46.730 --> 04:48.110
有了那个咱们就试试吧｡ 

04:48.110 --> 04:52.440
让我们保存所有, 并添加一个新的项目在这里, 现在拖动它到已完成的项目和它切换,

04:52.440 --> 04:58.270
和相同的, 如果我把它移回来｡

04:58.270 --> 05:02.320
如果我在活动项目中放开这里, 什么都不会改变｡ 

05:02.320 --> 05:04.400
现在, 如果你检查DOM,

05:04.400 --> 05:08.100
你会看到, 从技术上讲, 它是重新呈现的, 这可能不是理想的,

05:08.100 --> 05:11.450
所以我们可以考虑提出一些解决方案, 检查状态是否确实发生了变化,

05:11.450 --> 05:18.890
如果没有, 我们就不更新, 这是我们可以做的｡

05:18.890 --> 05:22.620
但是从UI的角度来看, 它会按照它应该的方式更新｡ 

05:22.620 --> 05:27.120
现在让我们再加一个项目看看它是否会破坏一些东西,

05:27.120 --> 05:33.720
如果一切都还正常, 我会说它看起来不错, 对我来说很不错.

05:33.720 --> 05:37.120
一切似乎都在按照它应该的方式工作｡ 

05:37.120 --> 05:40.230
拖放操作在这里可以正常工作, 但有一个改进,

05:40.230 --> 05:42.600
我在项目状态中提到过, 在moveProject中,

05:42.600 --> 05:46.305
当我调用这个updateListeners时,

05:46.305 --> 05:51.920
我们实际上可以检查是否确实更改了状态｡

05:51.920 --> 05:54.150
在这里, 我们可以检查项目,

05:54.150 --> 05:57.940
如果我们确实找到了一个项目, 如果项目状态与新状态不同,

05:57.940 --> 06:03.830
只有在这样的情况下, 我们才更改状态并更新侦听器｡

06:03.830 --> 06:06.060
如果状态相同, 则不执行此操作,

06:06.060 --> 06:09.310
从而避免不必要的重新渲染循环｡

06:09.310 --> 06:10.143
现在, 如果我们保存它,

06:10.143 --> 06:14.790
然后快速添加一个新项目, 你会看到我检查这里的元素, 你会看到L-I,

06:14.790 --> 06:18.190
并检查它是否闪烁, 这意味着它会重新渲染,

06:18.190 --> 06:30.990
它在这里不闪烁, 只闪烁可放置的, 我们刚刚添加的类, 但L-I不闪烁, 如果我放置在同一个框中, 它只闪烁, 如果我移动到不同的框中｡

06:30.990 --> 06:34.460
它应该会闪烁, 因为我们确实移动了它｡ 

06:34.460 --> 06:36.180
现在我们对此进行了一些优化,

06:36.180 --> 06:42.223
现在我们有了拖放功能, 所有这些功能都是由TypeScript构建和支持的｡
