WEBVTT

00:02.210 --> 00:04.920
解说员：现在, 一种特殊的类型保护,

00:04.920 --> 00:05.753
你可以说,

00:05.753 --> 00:07.940
或者说, 一些帮助你的类型保护,

00:07.940 --> 00:10.000
是歧视联盟｡

00:10.000 --> 00:11.300
那是什么

00:11.300 --> 00:15.030
这是一种模式, 您可以在使用联合类型时使用它,

00:15.030 --> 00:18.900
它使实现类型保护更容易｡

00:18.900 --> 00:22.000
当您使用物件类型时, 可以使用此选项｡ 

00:22.000 --> 00:24.580
让我来告诉你它是怎么工作的｡ 

00:24.580 --> 00:26.850
假设我们有几个接口, 这也可以是类,

00:26.850 --> 00:32.193
但这里我会用接口来说明它也可以和类一起工作.

00:33.170 --> 00:40.973
这是我的鸟, 它有一个飞行速度, 它应该是类型数｡

00:42.660 --> 00:45.890
而且我还有我的马, 它有一个地速或奔跑速度,

00:45.890 --> 00:51.913
应该是类型号｡

00:53.130 --> 00:55.430
这里有两个接口｡ 

00:55.430 --> 00:59.633
现在我们创建自己的并集类型, animal,

01:00.750 --> 01:03.370
它可以是鸟, 也可以是马.

01:03.370 --> 01:05.743
就像以前一样, 我们可能有一个函数,

01:06.740 --> 01:08.480
moveanimal它把animal作为输入,

01:09.800 --> 01:14.800
它的类型是animal, 所以用我们的并集类型.

01:14.800 --> 01:19.800
在这里, 我想说的是以速度移动, 当然,

01:19.990 --> 01:25.180
现在我需要访问飞行速度或跑步速度｡

01:25.180 --> 01:27.730
当然, 我们可以把它命名为速度｡ 

01:27.730 --> 01:30.840
但这只是您可能面临的真实用例的一个简化示例,

01:30.840 --> 01:33.900
其中通常有一些接口或对象,

01:33.900 --> 01:40.500
它们是相关的, 但具有不同的属性或方法｡

01:40.500 --> 01:42.050
这里是速度特性,

01:42.050 --> 01:43.900
实际上是不同的｡

01:43.900 --> 01:46.780
所以它不能计算飞行速度, 因为当然,

01:46.780 --> 01:49.240
不是所有的动物都有飞行速度｡

01:49.240 --> 01:51.210
现在我们可以做以前学过的事了｡ 

01:51.210 --> 01:56.063
我们可以检查飞行速度是否在动物这里｡ 

01:58.240 --> 02:01.063
如果是这样的话, 我们就可以执行这段代码｡ 

02:01.960 --> 02:04.470
这是我们可以采取的一种方法, 但是我们得到的潜在动物越多,

02:04.470 --> 02:09.233
我们需要检查的东西就越多｡

02:10.880 --> 02:14.100
我们也可能在这个字符串中输入错误｡ 

02:14.100 --> 02:15.810
例如, 我们可以忘记一个E,

02:15.810 --> 02:18.460
并想知道为什么这不起作用｡

02:18.460 --> 02:20.410
现在, 我们不能在这里使用实例,

02:20.410 --> 02:22.570
因为我将中断接口｡

02:22.570 --> 02:27.490
正如我所解释的, bird的动物实例将无法工作, 因为数据是一个接口,

02:27.490 --> 02:31.840
它没有被编译为JavaScript｡

02:31.840 --> 02:36.210
因此在运行时, 它不能作为构造函数使用｡

02:36.210 --> 02:37.690
因此, 这是行不通的｡ 

02:37.690 --> 02:42.460
现在我们可以通过给出每个接口来构建一个区分联合｡

02:42.460 --> 02:45.380
所以每一个对象都应该是并集的一部分,

02:45.380 --> 02:47.130
并且有额外的属性｡

02:47.130 --> 02:48.640
您可以使用任何您想要的名称｡ 

02:48.640 --> 02:51.490
这里通常用kind或type｡ 

02:51.490 --> 02:55.090
我去找类型, 给这只鸟起个名字｡ 

02:55.090 --> 02:57.480
现在重要的是, 我们在这里交换一个界面｡ 

02:57.480 --> 03:02.480
所以这实际上不是type属性的值｡ 

03:02.650 --> 03:05.410
这是一个文本类型, 正如您所了解的, 其中type必须包含一个字符串,

03:05.410 --> 03:09.110
该字符串必须是bird｡

03:09.110 --> 03:10.880
所以这是一个类型赋值,

03:10.880 --> 03:17.590
我们把可以存储在类型中的值缩小到这个字符串值｡

03:17.590 --> 03:22.283
然后对horse做同样的操作, 只是将horse作为一个字面类型｡

03:23.400 --> 03:25.060
在这里, 在我们的函数中,

03:25.060 --> 03:27.550
我们可以使用switch语句,

03:27.550 --> 03:32.280
在animal点类型上进行切换｡

03:32.280 --> 03:34.080
每个动物都有一个类型属性,

03:34.080 --> 03:38.350
因为我们将它添加到了组成动物的所有接口中｡

03:38.350 --> 03:40.730
在这里, 我们可以有几种情况,

03:40.730 --> 03:42.330
我们甚至可以自动完成,

03:42.330 --> 03:49.040
因为TypeScript和我们的IDE知道类型只能是bird或horse｡

03:49.040 --> 03:55.003
如果是鸟, 我们可以设置一些内部变量的速度,

03:55.900 --> 04:02.250
比如说, 动物点的飞行速度, 然后在这之后中断｡

04:02.250 --> 04:11.753
否则, 如果是马的情况, 我们就设定速度等于动物小点的奔跑速度｡

04:14.150 --> 04:17.490
然后我们就可以控制日志,

04:17.490 --> 04:20.843
以更快速度移动｡

04:22.490 --> 04:26.540
如果我现在调用, 移动一个我在这里创建的动物,

04:26.540 --> 04:30.300
我设置类型为bird, 我只允许使用bird或horse,

04:30.300 --> 04:48.980
然后我必须设置我的飞行速度, 顺便说一下, TypeScript甚至识别出一个运行速度的概念, 试图这样做, 并将其设置为10, 它抱怨说, 这不适用于类型bird｡

04:48.980 --> 04:51.360
如果我将其设置为飞行速度,

04:51.360 --> 04:55.120
无论它如何工作, 如果我们保存它, 它会正确输出,

04:55.120 --> 04:57.700
并且编译时也没有错误｡

04:57.700 --> 04:59.530
这是一个区分联合,

04:59.530 --> 05:04.060
因为我们在组成联合的每个对象中都有一个公共属性,

05:04.060 --> 05:11.490
它描述了该对象, 因此我们可以在检查中使用描述该对象的属性, 以实现100%的类型安全,

05:11.490 --> 05:21.930
并了解哪些属性可用于此类对象, 哪些属性不可用｡

05:21.930 --> 05:24.500
因此, 这是一种新颖而有用的模式,

05:24.500 --> 05:28.060
可以在处理对象和联合类型时使用｡

05:28.060 --> 05:30.340
它甚至可以和接口一起工作,

05:30.340 --> 05:37.050
因为这个接口会强制每个基于这个接口构建的对象都有这个类型｡

05:37.050 --> 05:41.200
因此, 我们不检查给定属性是否存在,

05:41.200 --> 05:49.020
也不使用的实例, 而是使用已知存在的属性来检查正在使用的对象类型｡

05:49.020 --> 05:51.930
我们还消除了输入错误的危险, 因为TypeScript明白,

05:51.930 --> 05:54.730
对于动物类型, 我们在这里只能有鸟和马,

05:54.730 --> 06:04.690
因此它给了我们这种完成的艺术, 如果你引入了一个输入错误, 我们会立即得到一个错误｡

06:04.690 --> 06:06.780
因此, 在处理对象和联合类型时,

06:06.780 --> 06:09.333
这是一个非常有用的模式｡
