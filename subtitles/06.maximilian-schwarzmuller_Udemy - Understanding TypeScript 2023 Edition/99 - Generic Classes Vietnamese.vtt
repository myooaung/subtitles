WEBVTT

00:02.270 --> 00:04.390
Người hướng dẫn: Được rồi, đủ về các chức năng chung.

00:04.390 --> 00:06.490
Chúng tôi sẽ luôn sử dụng chúng trong suốt khóa

00:06.490 --> 00:08.150
học này, tất cả các dự án khóa học.

00:08.150 --> 00:10.390
Vì vậy, điều đó sẽ ngày càng rõ ràng hơn, chúng ta

00:10.390 --> 00:11.890
càng làm việc với nó nhiều hơn.

00:11.890 --> 00:14.823
Ý tưởng chung hy vọng đã rõ ràng rồi.

00:15.660 --> 00:18.490
Tuy nhiên, các hàm chung không phải là tất cả những gì chúng

00:18.490 --> 00:20.550
ta có thể sử dụng, chúng ta cũng có các lớp chung

00:20.550 --> 00:21.560
và do đó, hãy xem cách

00:21.560 --> 00:23.740
chúng ta tạo một lớp chung như vậy và tại sao

00:23.740 --> 00:25.170
chúng ta có thể làm điều đó, tại

00:25.170 --> 00:27.760
sao điều đó có thể hữu ích cho chúng ta.

00:27.760 --> 00:31.950
Chúng ta có thể tạo một lớp lưu trữ ở đây.

00:31.950 --> 00:36.060
Giả sử một lớp có thuộc tính riêng data.

00:36.060 --> 00:38.850
Mà cuối cùng sẽ chứa một mảng dữ liệu.

00:38.850 --> 00:40.940
Sau đó, nó có một phương thức addItem,

00:40.940 --> 00:44.200
lấy vật phẩm của chúng ta và nó sẽ được thêm vào dữ liệu bằng

00:44.200 --> 00:45.763
cách đẩy, giả sử.

00:48.570 --> 00:50.830
Và chúng tôi có một phương thức removeItem, phương

00:50.830 --> 00:52.173
thức này sẽ lấy mục của chúng tôi,

00:53.010 --> 00:57.740
nơi chúng tôi có thể nói điều này. dữ liệu. ghép và sau đó chúng

00:57.740 --> 01:01.730
ta chỉ cần lấy indexOff(item) ở đây và ghép một

01:01.730 --> 01:02.910
phần tử.

01:02.910 --> 01:06.030
Đây là cách chúng ta có thể loại bỏ một phần tử khỏi một mảng.

01:06.030 --> 01:07.873
Và tất nhiên getItems, trong đó trả lại,

01:09.750 --> 01:13.120
giả sử là một bản sao của cái này. dữ liệu, giống như với

01:13.120 --> 01:15.770
toán tử trải phổ mà bạn đã học.

01:16.610 --> 01:17.443
Bây giờ chúng tôi có thể

01:17.443 --> 01:19.450
làm điều đó và chúng tôi đang gặp một loạt lỗi ở đây.

01:19.450 --> 01:20.500
Chúng tôi đang nhận được

01:20.500 --> 01:23.900
một loạt lỗi, bây giờ là một lỗi vì tên Lưu trữ là tên dành riêng, vì vậy hãy đặt

01:23.900 --> 01:25.230
tên cho nó là Lưu trữ dữ liệu.

01:25.230 --> 01:26.620
Đó là dễ dàng để thoát khỏi.

01:26.620 --> 01:27.920
Bây giờ chúng tôi cũng gặp lỗi

01:27.920 --> 01:29.400
ở đây vì chúng tôi không nói bất

01:29.400 --> 01:30.880
cứ điều gì về loại dữ liệu chúng

01:30.880 --> 01:32.960
tôi đang lưu trữ và loại mục nào có ở đây.

01:32.960 --> 01:35.870
Và đó chính xác là nơi chúng ta có thể biến nó thành lớp

01:35.870 --> 01:38.860
chung vì bạn có thể không quan tâm đến loại dữ liệu.

01:38.860 --> 01:40.880
Chúng tôi muốn đảm bảo rằng đó là dữ liệu

01:40.880 --> 01:42.410
thống nhất, do đó, nó chỉ là chuỗi

01:42.410 --> 01:44.830
hoặc chỉ là số hoặc chỉ là đối tượng.

01:44.830 --> 01:47.550
Nhưng khác với điều đó, tôi không quan tâm đến nó.

01:47.550 --> 01:50.820
Vì vậy, ở đây chúng ta có thể biến nó thành lớp chung,

01:50.820 --> 01:53.300
bằng cách thêm dấu ngoặc nhọn sau tên lớp

01:53.300 --> 01:56.330
và sau đó lại T, U, bất cứ thứ gì bạn muốn sử dụng

01:56.330 --> 02:00.110
làm định danh và thêm phần này ở đây làm kiểu chung.

02:00.110 --> 02:01.083
Bây giờ ở đây chúng

02:01.083 --> 02:04.490
ta có thể nói, đây là một mảng kiểu T, vì vậy nó lưu trữ

02:04.490 --> 02:07.413
dữ liệu của kiểu chung đó trong đó.

02:07.413 --> 02:09.670
Do đó, ở đây chúng tôi thêm dữ liệu đó

02:09.670 --> 02:12.400
và chúng tôi cố gắng xóa dữ liệu đó ở đây.

02:12.400 --> 02:15.140
Và do đó, ở đây chúng tôi nhận được các mục chính

02:15.140 --> 02:18.490
xác được suy ra để trả về một mảng các loại chung.

02:18.490 --> 02:20.860
Và bây giờ chúng tôi có thể tạo các bộ

02:20.860 --> 02:24.690
lưu trữ khác nhau, chúng tôi có thể có sting hoặc textStorage

02:24.690 --> 02:29.500
của chúng tôi tại đây, bằng cách gọi DataStorage mới, đặt loại chung đó để

02:29.500 --> 02:31.250
nhập chuỗi tại đây.

02:31.250 --> 02:33.070
Và sau đó ở đây trong textStorage,

02:33.070 --> 02:34.340
tôi có thể gọi addItem và

02:34.340 --> 02:36.410
nếu tôi cố gắng thêm một số, tôi sẽ gặp

02:36.410 --> 02:37.513
lỗi vì tôi đang nói rằng

02:37.513 --> 02:40.800
đây sẽ là DataStorage chỉ lưu trữ các vết chích.

02:40.800 --> 02:45.800
Vì vậy, tôi thực sự có thể lưu trữ Max ở đây và cũng có thể lưu trữ Manu,

02:46.830 --> 02:55.073
sau đó gọi textStorage. removeItem('Max') rồi console.

02:55.073 --> 02:55.073
nhật ký. textStorage. getItems.

02:56.520 --> 02:58.870
Và tất cả điều này sẽ hoạt động nếu chúng ta lưu

02:58.870 --> 03:00.300
nó vì nó là một loại chung,

03:00.300 --> 03:03.103
và thực sự là cuối cùng chúng ta chỉ có Manu ở đó.

03:04.400 --> 03:08.240
Vì vậy, đây sẽ là một lớp chung đơn giản mà chúng ta có thể tạo.

03:08.240 --> 03:10.500
Bây giờ, tại sao chúng ta lại xây dựng một lớp chung như vậy?

03:10.500 --> 03:11.770
Đúng như tôi đã nói, bởi

03:11.770 --> 03:14.220
vì có lẽ chúng ta không chỉ muốn lưu trữ văn

03:14.220 --> 03:17.110
bản, tôi cũng có thể muốn lưu trữ một số số trong một

03:17.110 --> 03:18.950
bộ lưu trữ dữ liệu khác.

03:18.950 --> 03:21.510
Vì vậy, sau đó tôi có thể tạo một DataStorage như vậy

03:21.510 --> 03:23.810
và đặt số này thành số để đảm bảo rằng bây giờ chúng

03:23.810 --> 03:26.250
tôi chỉ có thể thêm số vào bộ lưu trữ đó.

03:26.250 --> 03:28.330
Tất nhiên, chúng tôi cũng có thể thiết lập một bộ lưu trữ nơi

03:28.330 --> 03:30.520
chúng tôi cho phép cả hai bằng cách sử dụng loại kết hợp.

03:30.520 --> 03:32.550
Vì vậy, chúng tôi có đầy đủ tính

03:32.550 --> 03:36.470
linh hoạt ở đó, nhưng chúng tôi cung cấp một số thông tin bổ

03:36.470 --> 03:38.490
sung, điều này làm cho lớp này

03:38.490 --> 03:41.450
vừa linh hoạt vừa vẫn được nhập mạnh mẽ.

03:41.450 --> 03:43.470
Giống như chúng ta đã làm với hàm.

03:43.470 --> 03:46.910
Hỗ trợ các loại thực sự linh hoạt và vẫn hoàn hảo.

03:46.910 --> 03:49.900
Đó là toàn bộ ý tưởng đằng sau các loại chung chung.

03:49.900 --> 03:52.680
Vì vậy, ở đây chúng ta có thể làm điều đó với lớp DataStorage bằng

03:52.680 --> 03:53.750
cách lưu trữ các chuỗi hoặc

03:53.750 --> 03:55.130
bằng cách lưu trữ các số hoặc bất

03:55.130 --> 03:56.513
kỳ thứ gì chúng ta muốn.

03:57.790 --> 04:01.300
Tuy nhiên, chúng ta sẽ gặp một vấn đề về lớp dataStorage.

04:01.300 --> 04:04.880
Giả sử ở đây tôi có bộ lưu trữ đối tượng của mình, bây giờ

04:04.880 --> 04:07.090
tôi có thể tạo DataStorage mới và nói

04:07.090 --> 04:10.490
rằng trong đó tôi muốn lưu trữ các đối tượng, đúng vậy,

04:10.490 --> 04:12.270
tôi muốn lưu trữ các đối tượng

04:12.270 --> 04:17.270
và tất nhiên chúng ta có thể vào bộ lưu trữ đối tượng và thêm một mục.

04:17.300 --> 04:20.460
Giả sử một đối tượng tôi có tên Max trong đó.

04:20.460 --> 04:22.920
Hãy cũng lưu trữ một đối tượng khác,

04:22.920 --> 04:24.760
nơi tôi lưu trữ Manu.

04:24.760 --> 04:26.770
Sau đó, giả sử chúng ta đang thực hiện

04:26.770 --> 04:28.310
một số nội dung trong mã của mình

04:28.310 --> 04:29.740
và sau đó tại thời điểm sau

04:29.740 --> 04:34.100
tại đây, tôi sẽ muốn xóa mục đó, tôi muốn xóa mục có tên: 'Manu' tại đây.

04:34.100 --> 04:37.863
Và sau đó, tôi muốn an ủi. nhật ký. objStorage. getItems.

04:39.450 --> 04:40.550
Như vậy.

04:40.550 --> 04:41.883
Nếu chúng tôi lưu nó, chúng

04:42.920 --> 04:45.840
tôi sẽ thấy chúng tôi có một đối tượng trong đó là Max.

04:45.840 --> 04:47.470
Vì vậy, có vẻ tốt phải không.

04:47.470 --> 04:49.140
Bây giờ, nó không thực sự tốt.

04:49.140 --> 04:52.490
Giả sử ở đây, tôi muốn xóa Max ngay bây giờ, vì vậy bây giờ

04:52.490 --> 04:55.740
chúng ta nên để lại Manu trong bộ lưu trữ dữ liệu.

04:55.740 --> 04:59.653
Do đó, nếu tôi tải lại, thì, nó vẫn là Max.

05:00.550 --> 05:03.660
Bây giờ vấn đề là chúng ta đang làm việc với các đối tượng ở đây,

05:03.660 --> 05:07.350
như bạn đã biết các đối tượng trong JavaScript là các kiểu tham chiếu.

05:07.350 --> 05:09.440
Bây giờ, hãy đính kèm để tìm một nguồn tài nguyên

05:09.440 --> 05:11.460
bổ sung, cho phép bạn đi sâu vào tham khảo.

05:11.460 --> 05:12.730
Trong khi các giá trị nguyên

05:12.730 --> 05:14.650
thủy, ở đây tôi cho rằng bạn biết sự khác

05:14.650 --> 05:16.970
biệt bởi vì nó là một thứ cốt lõi của JavaScript,

05:16.970 --> 05:19.060
hoàn toàn không liên quan đến bản thảo.

05:19.060 --> 05:20.600
Vấn đề ở đây là, cách lớp

05:20.600 --> 05:22.300
của chúng ta được xây dựng

05:22.300 --> 05:26.243
với logic này về cách loại bỏ và xác định dữ liệu, chúng ta không

05:27.080 --> 05:29.580
thực sự làm tốt công việc khi làm việc với

05:29.580 --> 05:32.200
các giá trị không nguyên thủy.

05:32.200 --> 05:35.130
Vì vậy, khi chúng ta làm việc với các đối tượng hoặc mảng, bởi

05:35.130 --> 05:37.840
vì indexOf, nếu chúng ta truyền một đối tượng vào đây, nó

05:37.840 --> 05:40.910
sẽ không hoạt động vì về mặt kỹ thuật đây là một đối tượng mới.

05:40.910 --> 05:43.800
Nó có thể trông giống cái này nhưng nó không hoạt động vì

05:43.800 --> 05:46.520
về mặt kỹ thuật, đây là một đối tượng hoàn toàn mới trong

05:46.520 --> 05:48.290
bộ nhớ và có một địa chỉ khác.

05:48.290 --> 05:52.110
Và thực sự ở đây, JavaScript sẽ tìm kiếm địa chỉ và về cơ bản là

05:52.110 --> 05:54.930
không tìm thấy nó, vì vậy những gì nó làm sau đó

05:54.930 --> 05:58.453
là loại bỏ phần tử cuối cùng trong mảng ở đây, bởi vì phần

05:59.510 --> 06:01.473
tử này cuối cùng trả về -1.

06:02.419 --> 06:06.070
IndexOf trả về -1 ngay cả khi không tìm thấy gì.

06:06.070 --> 06:07.990
Điều đó có nghĩa là nó bắt đầu ở cuối mảng,

06:07.990 --> 06:09.770
đó là hành vi Javascript bình thường

06:09.770 --> 06:11.921
và loại bỏ phần tử cuối cùng của mảng.

06:11.921 --> 06:14.190
Đó là lý do tại sao nó hoạt động với Manu, nó không

06:14.190 --> 06:16.810
thực sự hoạt động mà nó vô tình hoạt động, nhưng tại

06:16.810 --> 06:19.020
sao nó không hoạt động với Max, hiện tại chúng

06:19.020 --> 06:19.880
tôi luôn xóa phần

06:19.880 --> 06:21.760
tử cuối cùng của mảng vì chúng tôi không

06:21.760 --> 06:23.670
thể xác định được nó.

06:23.670 --> 06:25.890
Bây giờ, một cách giải quyết ít nhất là

06:25.890 --> 06:29.140
khắc phục đó là kiểm tra xem chúng tôi có tìm thấy mục của mình

06:29.140 --> 06:32.260
không, vì vậy chúng tôi có thể kiểm tra xem mã này có ở đây

06:32.260 --> 06:36.260
không, nếu mã đó bằng -1, có nghĩa là chúng tôi không tìm thấy.

06:36.260 --> 06:37.360
Sau đó, chúng tôi có thể

06:37.360 --> 06:40.780
quay lại và đảm bảo rằng chúng tôi không vô tình xóa nhầm mục.

06:40.780 --> 06:42.900
Nhưng tất nhiên bây giờ chúng tôi chỉ sửa thanh đó,

06:42.900 --> 06:44.850
nhưng chúng tôi vẫn chưa có trạng thái bên trong

06:44.850 --> 06:46.580
này để nó hoạt động với các đối tượng.

06:46.580 --> 06:48.890
Chà, cách duy nhất nó có thể hoạt động với các đối

06:48.890 --> 06:51.740
tượng là nếu chúng ta chuyển lại chính đối tượng đó.

06:51.740 --> 06:55.700
Vì vậy, ở đây nếu tôi có đối tượng tối đa được lưu trữ trong một hằng

06:55.700 --> 06:58.840
số, như thế này, và ở đây tôi chuyển đối tượng tối đa.

06:58.840 --> 07:02.050
Và tôi cũng làm như vậy ở đây, sau đó tôi thực sự đang sử dụng cùng một đối

07:02.050 --> 07:05.330
tượng, cùng một đối tượng, cùng một đối tượng trong bộ nhớ, và do đó, bây

07:05.330 --> 07:06.540
giờ nó sẽ hoạt động.

07:06.540 --> 07:08.930
Đây sẽ là cách duy nhất để thực hiện công việc này.

07:08.930 --> 07:12.340
Vì vậy, ở đây, ý tưởng tốt hơn có thể là đảm bảo rằng điều

07:12.340 --> 07:16.150
này thực sự chỉ hoạt động với các giá trị nguyên thủy.

07:16.150 --> 07:20.100
Vì vậy, chúng ta có thể nói rằng T mở rộng chuỗi, số,

07:20.100 --> 07:24.010
có thể là tất cả các phép toán luận được thêm vào.

07:24.010 --> 07:25.990
Vì vậy, về cơ bản, bây giờ chúng tôi nói rằng DataStorage

07:25.990 --> 07:27.920
chỉ nên hoạt động với các loại này.

07:27.920 --> 07:30.470
Do đó các đối tượng không được phép nữa.

07:30.470 --> 07:32.500
Điều này có thể tốt hơn ở đây bởi vì, chúng

07:32.500 --> 07:35.220
ta sẽ cần một DataStorage chuyên biệt hơn, sau đó

07:35.220 --> 07:38.290
có lẽ chỉ hoạt động với các đối tượng chứ không phải với

07:38.290 --> 07:40.080
các giá trị nguyên thủy.

07:40.080 --> 07:42.430
Để tinh chỉnh logic truy xuất của chúng

07:42.430 --> 07:44.800
tôi ở đây, để có thể kiểm tra một số iD trong

07:44.800 --> 07:45.880
mục cần xóa.

07:45.880 --> 07:46.970
Cách nó hoạt động ở đây, nó

07:46.970 --> 07:48.910
thực sự chỉ hoạt động đối với các kiểu nguyên

07:48.910 --> 07:52.320
thủy, vì vậy việc thiết lập một ràng buộc như vậy chắc chắn là một ý tưởng hay.

07:52.320 --> 07:55.610
Và với điều đó, nếu chúng tôi lưu nó, sau khi nhận xét điều này, tất

07:55.610 --> 07:57.253
nhiên nó sẽ hoạt động trở lại.

07:58.810 --> 08:00.540
Bây giờ không cần phải nói, hy vọng

08:00.540 --> 08:02.620
rằng tất nhiên bạn cũng có thể có nhiều

08:02.620 --> 08:04.310
hơn một loại chung ở đây.

08:04.310 --> 08:05.910
Bạn không bị giới hạn ở một loại

08:05.910 --> 08:07.600
khi làm việc với các lớp.

08:07.600 --> 08:09.610
Và bạn cũng có thể có các phương

08:09.610 --> 08:13.080
thức có kiểu chung riêng thay vì các lớp.

08:13.080 --> 08:16.630
Vì vậy, bạn có thể giới thiệu các loại chung mới trong các phương thức của lớp,

08:16.630 --> 08:18.010
nếu bạn có một số loại chung, chỉ

08:18.010 --> 08:19.750
cần thiết trong một phương thức nhất định

08:19.750 --> 08:21.580
chứ không phải trong toàn bộ lớp.

08:21.580 --> 08:23.000
Vì vậy, bạn thực sự linh hoạt ở đó.

08:23.000 --> 08:25.570
Bạn có thể sử dụng các ràng buộc ở mọi

08:25.570 --> 08:28.100
nơi và nói chung, các loại chung có sẵn

08:28.100 --> 08:30.240
để làm cho cuộc sống của bạn dễ

08:30.240 --> 08:33.900
dàng hơn và mang đến cho bạn sự kết hợp hoàn hảo của tính

08:33.900 --> 08:36.010
linh hoạt hoàn toàn.

08:36.010 --> 08:39.310
Chúng tôi có thể sử dụng bất kỳ giá trị nguyên thủy nào bạn muốn ở

08:39.310 --> 08:40.900
đây và nhập an toàn, bởi vì chúng

08:40.900 --> 08:42.820
tôi biết rất rõ những gì được lưu trữ trong

08:42.820 --> 08:44.710
DataStorage này và những gì được lưu

08:44.710 --> 08:46.770
trữ trong DataStorage này.

08:46.770 --> 08:50.660
Vì vậy, sự kết hợp này là điều tuyệt vời mà các loại chung

08:50.660 --> 08:52.283
mang lại cho chúng ta.
