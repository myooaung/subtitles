WEBVTT

00:02.190 --> 00:05.380
教师：现在让我们来看看这个项目的最后部分,

00:05.380 --> 00:16.410
它涉及到将一个项目拖放到另一个框中的可能性, 例如, 在活动项目框中｡

00:16.410 --> 00:22.780
因此, 基本上将项目从活动项目切换为已完成项目｡

00:22.780 --> 00:25.430
因此, 这不仅仅是视觉更新,

00:25.430 --> 00:27.800
不仅仅是拖放和更新UI,

00:27.800 --> 00:31.050
还涉及在状态管理类中调整后台数据,

00:31.050 --> 00:45.420
项目状态是我们最终管理项目列表的地方, 请记住, 每个项目都有一个状态属性, 我们也需要更新它｡

00:45.420 --> 00:48.610
因此, 我们需要实现两件事：拖放,

00:48.610 --> 00:53.410
然后所有这些后台状态和数据更新｡

00:53.410 --> 00:56.220
现在让我们从拖放开始, 为此我们将基本上实现拖放,

00:56.220 --> 00:59.870
就像我们在vanilla java script中那样,

00:59.870 --> 01:06.970
例如, 您可以在我的完整java script指南中了解它｡

01:06.970 --> 01:09.690
基本上, 这是关于实现一组事件监听器的,

01:09.690 --> 01:11.960
当然, 在下一节课的这个模块中,

01:11.960 --> 01:21.150
你会看到它是如何工作的, 但是我们将以打字脚本样式实现它, 所以我们将通过使用一些打字脚本特性来增强它｡

01:21.150 --> 01:25.790
那么, 让我们开始吧, 我想如何用打字稿功能来增强它呢？

01:25.790 --> 01:28.423
我想在这里重用接口｡ 

01:29.280 --> 01:35.470
拖放接口, 但不只是像我们以前使用接口那样定义一些对象的结构,

01:35.470 --> 01:42.010
而是真正建立一个契约, 某些类可以签署该契约, 以强制这些类,

01:42.010 --> 01:51.980
基本上实现某些方法, 帮助我们进行拖放｡

01:51.980 --> 01:55.250
确切地说, 我考虑了两个接口, 当然,

01:55.250 --> 01:58.590
使用这些接口是可选的, 但这将允许我们,

01:58.590 --> 02:00.920
嗯, 基本上提供一些代码,

02:00.920 --> 02:06.340
迫使类实现它需要的一切, 以使其成为可拖动的或有效的拖放目标,

02:06.340 --> 02:19.080
如果我们构建一个更大的应用程序, 这将有助于我们编写更清晰的代码和更容易理解的代码, 特别是在团队中工作时｡

02:19.080 --> 02:21.710
那么, 我说的是哪些接口呢？

02:21.710 --> 02:23.160
我希望有一个界面,

02:23.160 --> 02:24.617
我将命名为draggable,

02:26.200 --> 02:31.060
我将有第二个界面, 我将命名为拖动目标｡

02:31.060 --> 02:38.030
我的想法是, 我们可以将可拖动的接口添加到任何呈现的类和可拖动的元素中｡

02:38.030 --> 02:41.810
在我们的示例中, 这将是项目项类｡ 

02:41.810 --> 02:46.600
项目项类负责渲染, 这些项目项和这些应该是可拖动的部分,

02:46.600 --> 02:49.230
以及框､ 活动项目和已完成的项目,

02:49.230 --> 02:57.880
因此这里我们的项目列表类应该是拖动目标｡

02:57.880 --> 03:03.890
现在, 这些接口会强制实现什么或将什么添加到类中呢？

03:03.890 --> 03:05.760
让我们从可拖动开始｡ 

03:05.760 --> 03:12.540
这里, 我们基本上需要两个事件侦听器, 因此需要两个处理程序来处理这些事件｡

03:12.540 --> 03:17.070
一个拖动开始处理程序, 它是一个方法和一个拖动结束处理程序,

03:17.070 --> 03:40.440
因为当实现拖放时, 你想拖动的东西将需要一些侦听器来侦听拖动事件的开始, 还可能需要一个侦听器来侦听拖动事件的结束, 这样就可以在那里做你想做的任何类型的更新｡

03:40.440 --> 03:44.225
现在, 拖动开始事件处理程序将获得一个事件对象,

03:44.225 --> 03:47.370
我们将其称为拖动事件, 这是一个内置类型,

03:47.370 --> 03:53.210
带有选项库的类型, 因为我们的TS冲突设置和我们在那里添加的库,

03:53.210 --> 03:59.882
它不会返回任何东西, 它将是一个执行但只是做一些事情的方法, 例如配置拖动事件,

03:59.882 --> 04:03.930
但不会返回｡

04:03.930 --> 04:06.970
现在, 拖动结束处理程序得到一个类似的事件,

04:06.970 --> 04:10.730
它也得到一个拖动事件, 它都不返回任何东西｡

04:10.730 --> 04:13.130
现在, 当然, 你会看到我们如何应用这些在短短几秒钟内,

04:13.130 --> 04:15.810
所以裸与我｡

04:15.810 --> 04:17.810
现在, 拖拽目标呢？

04:17.810 --> 04:22.620
对于目标, 也就是我们可以拖动东西的框,

04:22.620 --> 04:26.280
我想实现三个事件处理程序｡

04:26.280 --> 04:34.280
拖曳行程常式､ 放下行程常式和拖曳离开行程常式｡

04:34.280 --> 04:36.470
这些东西是干什么的？

04:36.470 --> 04:39.370
现在, 在java脚本中实现拖放时,

04:39.370 --> 04:45.140
需要实现一个拖放处理程序, 以便基本上用java脚本向浏览器发出信号,

04:45.140 --> 04:50.160
表明您正在拖动的对象是一个有效的拖动目标｡

04:50.160 --> 04:53.840
如果您没有在拖曳行程常式中执行右边的动作,

04:53.840 --> 04:56.410
就无法放下｡

04:56.410 --> 05:00.760
然后, 您需要放置处理程序来对实际发生的放置做出反应,

05:00.760 --> 05:06.500
因此, 如果拖放处理程序允许放置, 则放置处理程序将处理该放置,

05:06.500 --> 05:08.650
然后, 我们可以在此处更新数据和UI,

05:08.650 --> 05:16.940
例如, 如果我们要在用户将某些内容拖到框上时向用户提供一些视觉反馈, 则拖放处理程序可能会很有用｡

05:16.940 --> 05:22.210
我们改变了背景颜色, 如果没有发生拖放, 而是取消了拖放,

05:22.210 --> 05:32.190
或者用户将元素移走了, 我们可以使用拖拽离开处理程序来恢复视觉更新｡

05:32.190 --> 05:36.250
现在, 所有三个处理程序都接收到一个拖动事件,

05:36.250 --> 05:37.990
并且不返回任何内容,

05:37.990 --> 05:41.473
所以让我们像这样适当地更新它们｡

05:44.070 --> 05:47.250
还有最后一个联络人｡ 

05:47.250 --> 05:49.810
现在, 我们配置了一些接口,

05:49.810 --> 05:52.840
它们本身并不起什么作用, 但现在我们可以使用它们,

05:52.840 --> 05:57.490
我想从项目项开始｡

05:57.490 --> 06:00.380
让我们找到我们的项目项类,

06:00.380 --> 06:02.710
这是组件, 这是项目项,

06:02.710 --> 06:08.540
现在您可能还记得接口不能只用于定义自定义对象类型,

06:08.540 --> 06:12.290
但您可以将其用作类上的协定｡

06:12.290 --> 06:19.290
您可以调用implements, 或者在类名之后和正在进行的潜在扩展之后添加implements,

06:19.290 --> 06:20.900
然后实现接口｡

06:20.900 --> 06:24.340
在本例中为可拖动界面｡ 

06:24.340 --> 06:27.250
现在, 当你这样做的时候, 我只是格式化了这个,

06:27.250 --> 06:29.820
把它放在一个新的行中, 使它更容易阅读｡

06:29.820 --> 06:31.393
当您这样做时, 您会得到一个错误,

06:31.393 --> 06:40.763
因为这里的类不正确地实现了接口, 因为可拖动的接口迫使我们添加两个方法, 如果您还记得的话｡

06:42.840 --> 06:44.480
所以, 让我们在这里添加它们｡ 

06:44.480 --> 06:46.290
也许我们会加载一个构造函数｡ 

06:46.290 --> 06:49.550
让我们添加一个拖动开始处理程序, 它获取一个类型为drag

06:49.550 --> 06:59.143
event的事件, 同时让我们添加一个拖动结束处理程序, 它接收我们的drag事件｡

06:59.990 --> 07:02.010
现在我们添加了这两种方法｡ 

07:02.010 --> 07:05.330
现在, 仅凭这一点并不能实现拖放｡ 

07:05.330 --> 07:08.900
它只是帮助我们以统一的方式编写可拖动组件或可拖动类,

07:08.900 --> 07:14.560
因此, 如果我们添加越来越多的类, 这些类应该是可拖动的, 我们总是会有这些方法,

07:14.560 --> 07:20.700
这些方法只是让我们更容易地推理我们的代码和工作我们的代码, 特别是当在团队中工作时,

07:20.700 --> 07:27.840
因为每个人都知道在哪里为拖动启动事件工作｡

07:27.840 --> 07:32.950
当然, 这并不意味着监听一个拖动启动事件｡

07:32.950 --> 07:35.010
这是我们可以在configure方法中执行的操作,

07:35.010 --> 07:36.730
您已经有了这个方法｡

07:36.730 --> 07:38.980
我们可以访问呈现的元素,

07:38.980 --> 07:41.090
并向其添加一个事件侦听器,

07:41.090 --> 07:43.890
这将是拖动启动事件｡

07:43.890 --> 07:45.780
拖动启动事件是一个事件,

07:45.780 --> 07:49.190
一个默认的浏览器dom事件, 你可以监听,

07:49.190 --> 07:51.750
我们想要触发的事件处理程序,

07:51.750 --> 07:57.793
当然, 是拖动启动处理程序, 我们可以指向这里｡

07:59.080 --> 08:00.750
现在, 我们还想确保在拖动启动处理程序中,

08:00.750 --> 08:02.460
这个关键字引用了我们的类,

08:02.460 --> 08:08.530
正如你在事件侦听器中所学到的, 默认情况下不会是这样, 所以我们可以在这里使用bind,

08:08.530 --> 08:14.750
绑定这个, 这是有效的, 但实际上我们有一个更好的方法｡

08:14.750 --> 08:20.303
我们添加了自动绑定装饰器, 所以我在这里将它添加到拖动启动处理程序中｡

08:21.210 --> 08:28.530
现在, 我们还可以在这里监听拖动结束事件, 并指向拖动结束处理程序｡

08:28.530 --> 08:30.400
如果您计划在此处使用vis关键字,

08:30.400 --> 08:32.690
也可以在此处添加自动绑定, 我将在此处记录拖动结束,

08:32.690 --> 08:40.520
以便我们看到它被触发, 因为在此处, 我实际上并不想对它执行任何具体操作, 因此我还将此参数留空,

08:40.520 --> 08:47.310
并基本上告诉typescript我不使用它｡

08:47.310 --> 08:49.850
在拖动启动中, 我们将使用event,

08:49.850 --> 08:53.720
目前, 我只记录事件发生时的事件｡

08:53.720 --> 08:55.610
现在, 单凭这一点是不行的｡ 

08:55.610 --> 08:57.000
如果保存所有内容并在此处添加某个项目,

08:57.000 --> 09:01.460
您会发现无法重新拖动它, 对吗？

09:01.460 --> 09:04.750
如果您尝试拖动它, 则不会起作用,

09:04.750 --> 09:09.720
因为您还需要更改HTML文件中的某些内容｡

09:09.720 --> 09:11.810
在这个列表项上, 每个项目都会呈现这个列表项,

09:11.810 --> 09:19.830
也就是您要拖动的东西, 您必须添加draggable属性并将其设置为true｡

09:19.830 --> 09:21.040
这很重要｡ 

09:21.040 --> 09:24.200
这会告诉浏览器这将是可拖曳的｡ 

09:24.200 --> 09:28.430
这样, 如果您保存了它, 并在此处重新添加了一个项目,

09:28.430 --> 09:30.400
您现在可以看到, 它确实是可拖动的,

09:30.400 --> 09:32.070
它现在粘在我的鼠标上,

09:32.070 --> 09:35.720
现在我们可以在此处移动它｡

09:35.720 --> 09:38.530
您还可以在右侧看到, 当我开始拖动时触发了拖动事件,

09:38.530 --> 09:43.860
如果我松开, 您将看到拖动结束事件也会触发｡

09:43.860 --> 09:46.510
我们的监听器已经连接好了, 我们可以拖动,

09:46.510 --> 09:56.560
现在我们可以在拖放目标上进行操作, 这样就可以将项目拖动到该框中, 然后将项目添加到该框中｡

09:56.560 --> 10:02.930
其中一个我也会做真正的快速是在应用程序｡

10:02.930 --> 10:02.930
css文件,

10:02.930 --> 10:06.550
在列表项上, 所以在项目LI上, 我将简单地添加一个白色的背景色,

10:06.550 --> 10:09.810
这样我们就可以更好地看到这一点｡

10:09.810 --> 10:12.350
在这里, 项目LI, 我添加了白色,

10:12.350 --> 10:19.150
这样当我们在这里拖动项目时, 我们在这里有白色背景, 这样更容易看到｡

10:19.150 --> 10:20.840
但这不会改变我们下一步的计划｡ 

10:20.840 --> 10:22.700
我们想让他的身体变得可摔｡ 
