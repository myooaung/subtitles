WEBVTT

00:02.370 --> 00:08.630
ナレーター: さて､ ユーザーの入力を取得し､ TypeScriptの助けを借りてすべての検証を行うことができましたが､

00:08.630 --> 00:11.420
ここで駆動する検証ロジックを紹介します｡

00:11.420 --> 00:13.810
次に､ 集めたユーザーの入力をコンソールに出力するだけでなく､

00:13.810 --> 00:18.420
それ以上のことをするようにしましょう｡

00:18.420 --> 00:19.450
というのも､ 今のところ､ 私たちがやっていることはもちろん､

00:19.450 --> 00:21.330
そうなんです｡

00:21.330 --> 00:26.030
結局､ コンソールをやるために集めた物証情報をプリントしているだけで､

00:26.030 --> 00:30.300
このアプリケーションの最終的な目的はそこではないんです｡

00:30.300 --> 00:34.290
その代わりに､ このテンプレートに基づいてプロジェクトのリストをレンダリングし､

00:34.290 --> 00:41.550
すべてのプロジェクト項目がこのテンプレートに基づいているようにすることが目標です｡

00:41.550 --> 00:45.750
そして､ 集まった情報をここにアウトプットしています｡ 

00:45.750 --> 00:48.520
だから､ それが次にやりたいことなんだ｡ 

00:48.520 --> 00:52.970
フォーラムをレンダリングしてユーザーの入力を収集するproject

00:52.970 --> 01:03.230
input節に加え､ プロジェクトのリストをレンダリングするnumber節を用意したい｡

01:03.230 --> 01:06.100
そして実は､ これを2つの節に分けます｡ 

01:06.100 --> 01:11.000
リストに対して1つの節､ リスト内のプロジェクト項目に対して1つのクラスがあります｡

01:11.000 --> 01:14.970
そして､ 集まった入力をプロジェクト・リストに渡して､

01:14.970 --> 01:20.650
新しい項目を追加する方法を考えなければなりません｡

01:20.650 --> 01:26.880
では､ 一歩ずつ取り組んでいきましょう｡ まずは､ プロジェクトリストのクラスを追加することから始めましょう｡

01:26.880 --> 01:29.380
あとは追加した正確な場所で､ それはあなた次第です｡ 

01:29.380 --> 01:32.900
最終的にJavaスクリプトがこのファイル全体を完全にパースしてから実行するので､

01:32.900 --> 01:36.430
順番は関係ありません｡

01:36.430 --> 01:38.860
だから､ 全クラスを意識することになる｡ 

01:38.860 --> 01:45.740
というのも､ これからプロジェクト入力クラスの中に作るプロジェクトリスト節に頼ることになりますが､

01:45.740 --> 01:50.500
やはりこれは本当に重要です｡

01:50.500 --> 01:55.500
ここでは､ プロジェクトリスト節､ プロジェクトリスト､ そしてこの節の考え方は､

01:55.600 --> 02:01.170
プロジェクト入力で行ったことと少し関係があります｡

02:01.170 --> 02:06.930
このテンプレートにアクセスし､ アプリケーションの特定の場所にレンダリングしたいのです｡

02:06.930 --> 02:09.480
したがって､ ここでできることは､

02:09.480 --> 02:22.030
再びコンストラクタを追加し､ 必要なフィールドを追加し､ 最後にテンプレート要素とホスト要素を追加することです｡

02:22.440 --> 02:25.190
レンダリングされる要素そのもの､

02:25.190 --> 02:29.640
つまり具体的な要素も必要になってきますね｡

02:29.640 --> 02:31.800
そして､ その種類も異なってきますが｡ 

02:31.800 --> 02:38.330
ホスト要素はdivのままにしておきます｡

02:38.330 --> 02:40.970
しかし､ 具体的な要素､ それはレンダリングするのです｡ 

02:40.970 --> 02:43.960
もちろん､ これはフォーム要素ではありませんが､ リストテンプレートを見てみると､

02:43.960 --> 02:48.520
その中にセクションがあることがわかります｡

02:48.520 --> 02:51.010
そこで､ セクション要素を用意しました｡ 

02:51.010 --> 02:54.420
今､ 要素とそれらのセクション要素がないことが判明したので､

02:54.420 --> 03:00.490
私たちは通常のHTML要素を持つことにします｡

03:00.490 --> 03:03.060
あればもっと特化したタイプがあり､

03:03.060 --> 03:05.710
HTMLタイプでいいのです｡

03:05.710 --> 03:10.710
そこで､ 今度はもちろん､ これらの要素にアクセスする必要があります｡ 

03:10.970 --> 03:15.600
そこで､ このコードをプロジェクト入力のコンストラクタからコピーして､

03:15.600 --> 03:24.730
プロジェクトリストのコンストラクタに追加し､ いくつかの点を調整します｡

03:24.730 --> 03:29.420
例えば､ 今の私のテンプレート要素には､ もちろんプロジェクトの入力という発想はありません｡

03:29.420 --> 03:32.150
それが今は､ プロジェクトリストになっています｡ 

03:32.150 --> 03:36.660
では､ それをコピーして､ ここでこれを使い､ 要素を選択しましょう｡ 

03:36.660 --> 03:39.760
今でもコストをかけて､ 確実に手に入れるので､

03:39.760 --> 03:42.710
disは変わりません｡

03:42.710 --> 03:45.520
ホスト要素はまだIDアプデで死ぬほどある｡ 

03:45.520 --> 03:47.820
だから､ これは変わりません｡ 

03:47.820 --> 03:52.070
それからコンテンツをインポートして､ それから､ まあ､ 店､

03:52.070 --> 03:53.530
最初の要素ですね｡

03:53.530 --> 03:55.380
インポートのオフ､ テンプレート｡ 

03:55.380 --> 03:57.780
つまり､ 基本的にはテンプレートの最初の要素､

03:57.780 --> 04:01.590
つまりセクションを､ ここの要素プロパティに格納しています｡

04:01.590 --> 04:04.430
ただし､ これはHTMLのform要素ではありません｡ 

04:04.430 --> 04:07.210
ここではただのHTML要素です｡ 

04:07.210 --> 04:11.710
ここでIDを割り当てることもできますが､ 実際には､ プロジェクトのリストが複数あるため､

04:11.710 --> 04:16.970
ハードコードではなく､ ダイナミックに割り当てる必要があります｡

04:16.970 --> 04:21.220
最終的なアプリには､ プロジェクトの行為とプロジェクトの実行のためのツールリストがあり､

04:21.220 --> 04:29.895
それらは､ コンストラクタにいくつかの追加情報を取得したいと思います｡

04:29.895 --> 04:35.703
プロジェクトのタイプで､ stats, TypeScriptのショートカットを使います｡

04:35.703 --> 04:39.250
パラメータ､ private､ publicの前にアクセサを付けると､

04:39.250 --> 04:51.730
自動的に同じ名前のプロパティが作成され､ この引数で渡された値がその同じ名前のプロパティに格納されることを学びます｡

04:51.730 --> 04:55.040
これで､ このクラスもプロパティ名を入力することになりますね｡ 

04:55.040 --> 04:58.790
そして今度は､ この型パラメータの型が何なのかが問題です｡

04:58.790 --> 05:03.640
そして､ これは実際にはリテラル型とユニオン型であるべきなのです｡ 

05:03.640 --> 05:07.270
アクティブか､ 終了か､ どちらかです｡ 

05:07.270 --> 05:11.050
現役のプロジェクトや完成したプロジェクトまであります｡ 

05:11.050 --> 05:16.080
つまり､ プロジェクト・リストがインスタンス化されたときに得られると予想される引数です｡

05:16.080 --> 05:21.870
そして､ お父さんと一緒に､ プロパティDのIDを入力し､ これをベースにする必要があります｡

05:21.870 --> 05:25.090
はずで､ お父さんには､ ここにあるテンプレートリテラルを使っています｡ 

05:25.090 --> 05:33.640
ダッシュプロジェクトの種類は､ アクティブなダッシュプロジェクトか､ 終了したダッシュプロジェクトのどちらかである必要があります｡

05:33.640 --> 05:35.070
それが､ ここでの私の考えです｡ 

05:35.070 --> 05:37.540
このドット型を常に使用することで､ TypeScriptがこのプロパティを使用していること､

05:37.540 --> 05:41.890
そして未使用でないことを理解することができる｡

05:41.890 --> 05:46.200
これで､ すべてのコア要素にアクセスできるようになり､ セクションにIDを追加して､

05:46.200 --> 05:50.790
テンプレートから取得できるようになりました｡

05:50.790 --> 05:53.650
さて､ もちろん､ レンダリングは正しく行いたいものです｡ 

05:53.650 --> 05:58.600
それが､ 今回もすべてプライベートメソッドでの発想です｡ 

05:58.600 --> 06:00.540
正義を取り付ける｡ 

06:00.540 --> 06:06.310
プロジェクトの入力にあったのですが､ そこでは今ゴールキューになっているんです｡

06:06.310 --> 06:12.750
さて､ これをDomに取り付けると､ 今度はDomにお父さんリストをレンダリングすることができます｡

06:12.750 --> 06:19.223
そこで､ 添付ファイルの代わりに､ プロジェクトフォームに添付したのと同じことを実際にやってみます｡

06:20.070 --> 06:24.230
そこで､ その行をここにコピーして､ 態度添付すればよいのです｡ 

06:24.230 --> 06:28.420
ホスト要素があり､ 隣接する要素を挿入したい｡

06:28.420 --> 06:30.240
冒頭の後､ これが要素になるはずです｡ 

06:30.240 --> 06:33.300
ここでは､ それをテンプレートから抽出します｡ 

06:33.300 --> 06:36.990
しかし､ 実際には､ 開始の後ではなく､ 終了の前､

06:36.990 --> 06:41.960
つまり､ 閉じる前に､ ホスト要素を切り離し､ コンストラクタでattachを呼び出し､

06:41.960 --> 06:51.763
もちろん､ ここで作成した要素をDomにアタッチすることができます｡

06:53.880 --> 06:56.370
さて､ このリストですが､ プロジェクトの入力と比較して､

06:56.370 --> 06:59.630
重要な違いが1つあります｡

06:59.630 --> 07:03.220
Domにリストを追加しただけで終わりではありません｡ 

07:03.220 --> 07:05.270
入力は終わっていたんですよね？

07:05.270 --> 07:07.130
こちらのフォームは完成していました｡ 

07:07.130 --> 07:08.720
そこにすべてのインプットがあったのです｡ 

07:08.720 --> 07:12.420
あとは､ イベントリスナーを設定するだけでした｡ 

07:12.420 --> 07:16.673
さて､ こちらのリストですが､ 実はまだ空で飼ったことがないんです｡

07:16.673 --> 07:21.130
例えば､ H to techで､ そこにテキストを追加したいんです｡ 

07:21.130 --> 07:22.990
そこで､ 数字を入れることにします｡ 

07:22.990 --> 07:26.020
プライベートメソッドに新しいメソッドを追加します｡ 

07:26.020 --> 07:29.120
レンダーやコンテンツというのは､ ふさわしい名前かもしれません｡ 

07:29.120 --> 07:36.862
そして､ 私の考えは､ そのテンプレートの空欄を､ ある人生の年号で埋めることです｡

07:36.862 --> 07:37.780
そのために

07:37.780 --> 07:41.580
デッドレンダーコンテンツメソッドに移動して､ いくつかやってみたいことがあります｡

07:41.580 --> 07:47.200
ひとつは､ 私のプロジェクト・リストの一部であるデッド・アンオーダ・リスト用のスタットです｡

07:47.200 --> 07:48.640
IDを付けたい

07:48.640 --> 07:50.860
もちろん､ そんなことをする必要はないのですが､ 後で選択する必要がある場合に､

07:50.860 --> 07:54.390
これらを使って選択できるようにしておきたいのです｡

07:54.390 --> 07:58.220
リストIDは定数に格納され､

07:58.220 --> 08:04.100
これはテンプレートリテラルになるので､

08:04.100 --> 08:14.370
動的なコンテンツを注入できる文字列になります｡

08:15.220 --> 08:19.700
これで､ 注文リストにアクセスできるようになりました｡ この注文リストには､ 「stat section

08:19.700 --> 08:23.820
year」という要素があり､ 右側の要素は「dead section」です｡

08:23.820 --> 08:27.360
そこで､ その中の順序なしリストを取得するために､ 例えば､

08:27.360 --> 08:33.120
クエリーセレクタを使用して､ 最初の､ この場合は唯一の順序なしリストを検索します｡

08:33.120 --> 08:35.720
1つであることは分かっているので､ ここにIDを追加します｡

08:35.720 --> 08:38.280
これはリストIDであるべきです｡

08:38.280 --> 08:40.280
それが､ 私がやりたいことのひとつです｡ 

08:40.280 --> 08:44.970
また､ ageタグのテキストコンテンツをここに設定したいので､

08:44.970 --> 08:50.200
この要素､ クエリセレクタに手を伸ばします｡

08:50.200 --> 08:53.020
最初の､ そして唯一のHQタグを探す｡ 

08:53.020 --> 08:56.340
そのため､ 感嘆符でヌルケースを除外し､

08:56.340 --> 09:05.610
これと同じ内容のテキストを大文字に設定しています｡

09:05.610 --> 09:08.130
リメンバータイプは常にアクティブである｡ 

09:08.130 --> 09:10.060
オペラケースは2つで終了です｡ 

09:10.060 --> 09:15.060
これをオールキャプス＋プロジェクトに変換するのですが､ ステンもそうです｡ 

09:16.200 --> 09:19.853
単純に前方の見出しがセクションです｡ 

09:21.970 --> 09:25.220
これで､ 概ね終了です｡ 

09:25.220 --> 09:27.580
まだ､ その項目はありません｡ 

09:27.580 --> 09:30.230
後で作業しますが､ 概ね終了です｡ 

09:30.230 --> 09:37.210
このレンダーは､ 例えば､ コンテンツやDomにアタッチした後に呼び出すことができます｡

09:37.210 --> 09:39.210
今なら､ それらを実際に見ることができるはずです｡ 

09:39.210 --> 09:42.600
もちろん､ 繰り返しになりますが､ リスト項目の末尾は欠落してしまいますが､

09:42.600 --> 09:45.523
ここで何かアクションを起こすと良いですね｡

09:46.690 --> 09:49.620
そのために､ プロジェクトの入力をインスタンス化するファイルの一番下に行き､

09:49.620 --> 09:55.200
そこで常にリストをインスタンス化できるようにしましょう｡

09:55.200 --> 10:01.230
アクティブなプロジェクトリストがあり､ それをインスタンス化しますが､ 新しいプロジェクトリストを呼び出します｡

10:01.230 --> 10:06.040
そしてそこで､ その型の引数を渡さなければならないのですが､ ここでアクティブか終了かのどちらかになります｡

10:06.040 --> 10:09.950
アクティブリストをレンダリングしているので､ もちろんインアクティブをパスしています｡

10:09.950 --> 10:13.140
そして､ ここには完成したプロジェクトリストがあります｡

10:13.140 --> 10:15.290
もちろん､ 私は完成をパスしています｡

10:15.290 --> 10:18.673
今､ 私たちは､ それがエラーなしでコンパイルする必要があることを安全にする場合｡ 

10:19.520 --> 10:23.090
そして､ 戻ってみると､ この2つの空のセクションと見出し､

10:23.090 --> 10:33.390
そして､ 後の項目やプロジェクトの項目を追加するための空のスペースがあります｡

10:33.390 --> 10:37.440
今はとりあえず､ そのようなプロジェクト項目はありません､ 雪｡ 

10:37.440 --> 10:39.710
そこで次のステップとして､ プロジェクトの追加をクリックしたときに､

10:39.710 --> 10:49.420
コードで新しいプロジェクトが作成されるようにする何らかの方法を考えなければなりません｡

10:49.420 --> 10:53.730
そこで､ プロジェクトを表す新しいデータ構造を作成し､

10:53.730 --> 10:59.870
この新しいプロジェクトに関する情報をプロジェクトの行為に渡します｡

10:59.870 --> 11:06.500
新しいプロジェクトはすべてデフォルトでアクティブになっているはずなので､ このアクティブなプロジェクトのセクションにリストアップします｡

11:06.500 --> 11:12.080
これが次の目標になりますが､ これもまた､ さまざまな方法で実施することになるでしょう｡

11:12.080 --> 11:16.703
次回の講義で思いついた一つの方法で一緒にやってみましょう｡
