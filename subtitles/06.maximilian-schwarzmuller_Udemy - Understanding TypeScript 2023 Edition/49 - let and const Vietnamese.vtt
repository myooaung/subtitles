WEBVTT

00:02.090 --> 00:04.730
Người hướng dẫn: Bây giờ, trước khi chúng ta đi sâu vào bất kỳ tính năng nào, kèm

00:04.730 --> 00:07.002
theo bài giảng này, bạn sẽ tìm thấy một liên kết đến trang này.

00:07.002 --> 00:11.350
Về cơ bản, trang này liệt kê tất cả các tính năng JavaScript

00:11.350 --> 00:13.610
ít nhiều hiện đại, trình duyệt

00:13.610 --> 00:16.770
nào hỗ trợ các tính năng này và trình biên dịch

00:16.770 --> 00:19.700
nào hỗ trợ các tính năng này.

00:19.700 --> 00:23.150
Và ở đó bạn cũng tìm thấy TypeScript, TypeScript

00:23.150 --> 00:25.310
kết hợp với core-js, là nhà cung

00:25.310 --> 00:27.210
cấp polyfill.

00:27.210 --> 00:28.820
Nhưng nói chung, điều này

00:28.820 --> 00:32.070
mô tả những gì TypeScript có thể biên dịch.

00:32.070 --> 00:34.110
Giờ đây, bạn luôn có thể sử dụng tài nguyên này

00:34.110 --> 00:35.990
nếu bạn đang tìm kiếm một tính năng cụ thể,

00:35.990 --> 00:37.960
chẳng hạn như từ khóa const, Nơi bạn muốn biết

00:37.960 --> 00:40.860
liệu TypeScript có hoạt động với tính năng đó hay không.

00:40.860 --> 00:43.340
Sau đó, bạn có thể xem cách nó hoạt động với điều

00:43.340 --> 00:46.580
đó và hạn chế là gì, trình duyệt nào hỗ trợ điều này.

00:46.580 --> 00:48.250
Nhân tiện, điều này cũng cung cấp

00:48.250 --> 00:51.090
cho bạn gợi ý về trình duyệt nào bạn có thể muốn nhắm mục

00:51.090 --> 00:53.967
tiêu, liên quan đến mục tiêu TypeScript, v.v.

00:53.967 --> 00:55.260
Vì vậy, đây là một tài nguyên

00:55.260 --> 00:58.600
tuyệt vời cho phép bạn chuyển đổi giữa các lần lặp lại khác nhau của

00:58.600 --> 01:01.940
JavaScript và các tính năng mà mỗi lần lặp lại được giới thiệu cũng

01:01.940 --> 01:04.220
như cách các tính năng này được hỗ trợ.

01:04.220 --> 01:06.140
Vì vậy, hãy chắc chắn sử dụng tài nguyên này làm

01:06.140 --> 01:08.800
tài nguyên để tìm hiểu những gì bạn có thể sử dụng, những gì bạn

01:08.800 --> 01:11.060
có thể biên dịch và mục tiêu nào bạn có thể cần đặt.

01:11.060 --> 01:14.060
Và cùng với đó, hãy bắt đầu với một trong những phần giới

01:14.060 --> 01:17.030
thiệu quan trọng, rõ ràng và thường được sử dụng nhất, JavaScript

01:17.030 --> 01:19.260
Thế hệ Tiếp theo đã thêm vào.

01:19.260 --> 01:21.780
Nhân tiện, với JavaScript thế hệ

01:21.780 --> 01:24.700
tiếp theo, ý tôi là ES6 hoặc mới hơn.

01:24.700 --> 01:27.860
Và đó là let hoặc const, những gì tôi đang nói đến.

01:27.860 --> 01:32.750
Nó cho phép bạn định nghĩa các hằng hoặc biến.

01:32.750 --> 01:35.350
Sự khác biệt là các hằng số, vì vậy các

01:35.350 --> 01:38.730
biến được xác định bằng từ khóa const không thể

01:38.730 --> 01:39.910
thay đổi được.

01:39.910 --> 01:42.410
Nếu bạn cố gắng gán một giá trị mới ở

01:42.410 --> 01:44.270
đây ngay cả khi nó có đúng loại,

01:44.270 --> 01:47.220
bạn sẽ gặp lỗi vì đó là một hằng số.

01:47.220 --> 01:48.280
Nhân tiện, đây là một

01:48.280 --> 01:50.200
lỗi được hình thành bởi TypeScript.

01:50.200 --> 01:53.340
Trong Vanilla JavaScript, trình duyệt sẽ báo lỗi khi bạn chạy

01:53.340 --> 01:55.100
mã ở đây và đó là ý tưởng đằng sau TypeScript,

01:55.100 --> 01:57.280
như bạn đã biết, chúng tôi đã gặp lỗi trong khi

01:57.280 --> 02:00.410
bạn đang viết mã, vì điều đó, tất nhiên, tốt hơn đối với chúng

02:00.410 --> 02:02.990
tôi với tư cách là nhà phát triển.

02:02.990 --> 02:04.930
Nó cho phép chúng tôi sửa mã này sớm

02:04.930 --> 02:07.820
hơn trước khi kiểm tra nó trong bảng điều khiển.

02:07.820 --> 02:11.330
Vì vậy, do đó, ở đây, nếu chúng tôi xóa dòng đó hoặc nhận xét dòng

02:11.330 --> 02:12.830
này, thì bây giờ nó sẽ biên

02:12.830 --> 02:14.400
dịch lại và do đó, chúng tôi

02:14.400 --> 02:17.130
cũng không gặp lỗi trong trình duyệt.

02:17.130 --> 02:20.860
Vì vậy, đó là const. Let là một biến có thể thay đổi được,

02:20.860 --> 02:23.620
và do đó, tất nhiên, nó tương tự như var.

02:23.620 --> 02:27.260
Var cũng vẫn tồn tại vì JavaScript hoạt động sao cho các tính

02:27.260 --> 02:29.550
năng không đột ngột bị lấy đi, vì khi đó

02:29.550 --> 02:33.460
các trình duyệt cũ hơn và các tập lệnh của chúng có thể bị hỏng.

02:33.460 --> 02:35.160
Nhưng bạn không nên sử dụng var nữa.

02:35.160 --> 02:37.860
Và tại sao bạn không nên sử dụng var nữa?

02:37.860 --> 02:39.670
Ý tôi là, thật hợp lý khi chúng ta có const,

02:39.670 --> 02:42.520
bởi vì điều đó thực sự bổ sung một tính năng mới, hằng số.

02:42.520 --> 02:43.380
Nhưng tại sao lại để?

02:43.380 --> 02:45.380
Tại sao họ giới thiệu một từ khóa mới ở đây?

02:45.380 --> 02:47.223
Tại sao họ không dính vào var?

02:48.280 --> 02:51.460
Let và const có một sự khác biệt quan trọng đối với var.

02:51.460 --> 02:53.300
Chà, sự khác biệt rõ ràng đối với const là

02:53.300 --> 02:55.240
giá trị không thể thay đổi, nhưng đối với let,

02:55.240 --> 02:57.040
chúng ta cũng nhận được sự khác biệt.

02:57.040 --> 03:00.930
Và đó là phạm vi mà biến này có sẵn.

03:00.930 --> 03:04.363
Bây giờ bạn đã biết khái niệm về phạm vi trong JavaScript.

03:05.609 --> 03:09.260
Và với var, bạn có phạm vi chức năng và toàn cầu.

03:09.260 --> 03:10.700
Điều đó có nghĩa là các biến

03:10.700 --> 03:12.550
mà bạn xác định bên ngoài các hàm

03:12.550 --> 03:15.340
có sẵn ở mọi nơi trong tập lệnh của bạn.

03:15.340 --> 03:17.410
Các biến được định nghĩa bên trong các

03:17.410 --> 03:19.370
hàm chỉ khả dụng trong hàm đó.

03:19.370 --> 03:22.610
Ví dụ, ở đây. Nếu tôi có một

03:22.610 --> 03:27.610
hàm cộng, và có thể có hai số a và b.

03:27.670 --> 03:29.750
Sau đó, chúng ta có thể thêm một biến vào

03:29.750 --> 03:32.280
đó với var result, giả sử, và sau đó chúng ta đặt

03:32.280 --> 03:34.730
result = a + b, sau đó chúng ta trả về kết quả, và

03:34.730 --> 03:36.230
tất nhiên, chúng ta có thể viết

03:36.230 --> 03:38.430
điều này theo cách ngắn gọn hơn nhưng tôi

03:38.430 --> 03:40.570
muốn chỉ ra những gì var không.

03:40.570 --> 03:41.860
Và điều này sẽ ổn thôi.

03:41.860 --> 03:43.012
Và kết quả sẽ chỉ có sẵn bên

03:43.012 --> 03:44.188
trong chức năng này.

03:44.188 --> 03:47.723
Nếu tôi cố gắng điều khiển kết quả nhật ký ở đây sẽ không

03:47.723 --> 03:49.470
thành công vì nó chỉ khả dụng

03:49.470 --> 03:52.190
trong phạm vi của chức năng này.

03:52.190 --> 03:53.970
Nếu tôi định nghĩa nó bên ngoài var harbour

03:53.970 --> 03:56.610
thì mọi thứ đều hoạt động vì bây giờ nó có sẵn trên toàn cầu, do

03:56.610 --> 03:58.180
đó ở đây tôi có thể truy cập nó.

03:58.180 --> 04:00.220
Ngoài ra, cách JavaScript hoạt

04:00.220 --> 04:03.580
động, bạn có thể truy cập các biến ở cấp độ cao hơn.

04:03.580 --> 04:05.210
Vì vậy, bên trong một hàm,

04:05.210 --> 04:08.260
bạn có thể làm việc với phạm vi biến đối với hàm này,

04:08.260 --> 04:11.100
nhưng tất cả các biến có phạm vi cao hơn, như phạm

04:11.100 --> 04:12.563
vi toàn cục ở đây.

04:13.580 --> 04:14.980
Vì vậy, đó là var.

04:14.980 --> 04:19.180
Bây giờ đối với let, hành vi nói chung là giống nhau.

04:19.180 --> 04:21.580
Điều này hoạt động và điều này hoạt động.

04:21.580 --> 04:23.800
Vì vậy, nó thường giống nhau cho let.

04:23.800 --> 04:27.180
Nhưng một sự khác biệt quan trọng là đối với var,

04:27.180 --> 04:30.860
bạn thực sự chỉ có phạm vi chức năng và toàn cầu.

04:30.860 --> 04:32.460
Còn câu lệnh if thì sao?

04:32.460 --> 04:36.720
Nếu chúng ta kiểm tra tuổi > 20 ở đây, sau đó ở đó chúng ta tạo

04:36.720 --> 04:38.889
một biến isOld và đặt giá trị này

04:38.889 --> 04:41.190
thành true, thì nếu nhật ký bảng

04:41.190 --> 04:44.500
điều khiển isOld ở đây, chúng ta sẽ gặp lỗi trong

04:44.500 --> 04:46.270
TypeScript, nhưng thực

04:46.270 --> 04:50.090
ra chúng ta không gặp lỗi trong JavaScript.

04:50.090 --> 04:53.620
Mã này ở đây, nếu bạn lấy nó chỉ để thấy rằng nó hoạt động và di chuyển đến các

04:53.620 --> 04:56.280
công cụ dành cho nhà phát triển JavaScript ở đó trong bảng

04:56.280 --> 04:57.190
điều khiển, và chúng

04:57.190 --> 04:59.120
tôi dán nó vào đó và nhấn enter, bạn sẽ thấy

04:59.120 --> 05:00.970
true đang được in ở đây.

05:01.830 --> 05:02.960
Và thực sự, nếu bạn cố gắng

05:02.960 --> 05:05.040
truy cập isOld, bạn sẽ nhận được sự thật.

05:05.040 --> 05:08.380
Vì vậy, biến isOld này được đăng ký trên toàn cầu chứ

05:08.380 --> 05:10.530
không chỉ bên trong câu lệnh if.

05:10.530 --> 05:11.700
Bởi vì với var, JavaScript

05:11.700 --> 05:13.080
không biết bất kỳ phạm vi

05:13.080 --> 05:15.860
nào khác ngoài chức năng và toàn cầu.

05:15.860 --> 05:17.400
Và điều đó thay đổi với let.

05:17.400 --> 05:19.690
Bây giờ, như tôi đã nói, TypeScript vẫn phàn nàn

05:19.690 --> 05:21.600
vì đây không phải là mã tốt để viết, nhưng

05:21.600 --> 05:23.170
về mặt kỹ thuật, nó sẽ hoạt động.

05:23.170 --> 05:25.100
Với let, điều đó sẽ thay đổi.

05:25.100 --> 05:26.350
Bây giờ với let, điều

05:26.350 --> 05:29.880
này thực sự chỉ khả dụng bên trong các dấu ngoặc nhọn này.

05:29.880 --> 05:32.300
Bởi vì let và const đã giới thiệu một khái

05:32.300 --> 05:33.540
niệm mới gọi là phạm vi

05:33.540 --> 05:36.550
khối, có nghĩa là một biến hoặc hằng số luôn có sẵn trong

05:36.550 --> 05:40.420
khối mà bạn xác định nó hoặc trong bất kỳ khối nào thấp hơn.

05:40.420 --> 05:43.060
Và một khối về cơ bản luôn là một đoạn mã được bao quanh

05:43.060 --> 05:44.900
bởi các dấu ngoặc nhọn, như bạn có nó

05:44.900 --> 05:46.710
cho một câu lệnh if, trong một vòng

05:46.710 --> 05:48.760
lặp for, trong một hàm hoặc thậm chí, điều

05:48.760 --> 05:50.590
đó là có thể, nếu bạn chỉ cần thêm các

05:50.590 --> 05:52.670
dấu ngoặc nhọn như thế này.

05:52.670 --> 05:54.230
Bất kỳ biến nào được xác định

05:54.230 --> 05:56.760
ở đây sẽ chỉ khả dụng trong khối đó.

05:56.760 --> 05:57.700
Và đó là một điều

05:57.700 --> 06:00.000
tốt vì nó buộc bạn phải viết mã gọn gàng hơn

06:00.000 --> 06:02.470
và tránh những tình huống như thế này.

06:02.470 --> 06:03.640
Vì vậy, chỉ để cung cấp bằng chứng

06:03.640 --> 06:05.530
rằng có một sự khác biệt trong trình duyệt, nếu

06:05.530 --> 06:09.750
tôi sao chép mã này bằng cách sử dụng let, và tôi tải lại trang của mình tại đây, và bây giờ tôi nhập mã này vào

06:09.750 --> 06:14.706
đây, bạn sẽ thấy tôi gặp lỗi là Old không được xác định.

06:14.706 --> 06:14.706
Chúng tôi đã không nhận được một lỗi trước đây.

06:14.706 --> 06:19.706
Thật vậy, nếu tôi cố xuất isOld, tôi lại gặp lỗi đó.

06:20.070 --> 06:21.060
Vì vậy, đó là sự khác biệt.

06:21.060 --> 06:23.370
Và do đó, let và const tốt hơn, không chỉ

06:23.370 --> 06:25.740
vì chúng ta có được tính năng không đổi

06:25.740 --> 06:29.150
này mà còn vì chúng ta buộc phải viết mã sạch hơn.

06:29.150 --> 06:30.130
Vì vậy, hãy để tôi nhận xét điều

06:30.130 --> 06:31.230
này để làm cho nó hoạt động trở lại.
