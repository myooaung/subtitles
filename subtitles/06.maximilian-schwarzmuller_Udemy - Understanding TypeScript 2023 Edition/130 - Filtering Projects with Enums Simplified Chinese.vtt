WEBVTT

00:02.310 --> 00:03.940
男人：所以我们有两个问题,

00:03.940 --> 00:06.500
如果我们想这样称呼它们的话, 需要解决｡

00:06.500 --> 00:10.960
现在我想从项目同时出现在两个框中的问题开始｡

00:10.960 --> 00:13.050
我想介绍一些过滤,

00:13.050 --> 00:18.930
当然, 最好的过滤位置是我们的侦听器函数｡

00:18.930 --> 00:22.743
如果我们转到注册监听器的地方,

00:26.000 --> 00:29.170
在项目列表子句中｡

00:29.170 --> 00:32.270
然后, 在这里, 我们得到一个-一个项目列表, 对吗？

00:32.270 --> 00:36.170
现在, 该项目列表包含所有项目｡ 

00:36.170 --> 00:43.140
现在, 在项目列表子句中, 我们只对活动的或已完成的项目感兴趣｡

00:43.140 --> 00:44.250
顺便说一句,

00:44.250 --> 00:49.103
理论上我们也可以使用枚举, 但实际上, 我需要具体的值,

00:50.660 --> 00:53.160
存储在下面的枚举中, 或者下面的类型中,

00:53.160 --> 01:02.180
因此, 这里我不想总是使用枚举, 因为我想显示字符串类型｡

01:02.180 --> 01:06.190
因此, 我们在监听器函数中要做的是, 在存储和渲染项目之前,

01:06.190 --> 01:10.470
我们要对它们进行过滤｡

01:10.470 --> 01:13.020
这里我们有相关的项目, 你可以说,

01:13.020 --> 01:16.660
当然, 这是经过筛选的项目｡

01:16.660 --> 01:21.460
filter方法是JavaScript中存在于任何数组上的默认方法｡

01:21.460 --> 01:23.690
这需要一个函数, 然后在该项目数组中的每个项目上执行,

01:23.690 --> 01:35.040
当这个函数返回true时, 我们将项目保存在一个新创建的数组中, 然后将其存储在相关项目中｡

01:35.040 --> 01:38.130
如果此函数返回false, 则我们将删除项目,

01:38.130 --> 01:39.770
而不是从原始列表中删除,

01:39.770 --> 01:41.660
而是在生成的新列表中删除,

01:41.660 --> 01:44.230
新列表存储在相关项目中｡

01:44.230 --> 01:46.600
所以在这里, 我们必须返回true或false,

01:46.600 --> 01:48.810
这取决于我们是否想保留项目｡

01:48.810 --> 01:52.430
当然, 要做到这一点, 我们只需要看看现状｡ 

01:52.430 --> 01:55.310
项目状态是一个枚举, 如果我们在活动项目列表中,

01:55.310 --> 01:59.070
我们要检查项目状态是否等于项目状态活动,

01:59.070 --> 02:12.270
即类型属性是否为活动, 或者如果我们在已完成列表中, 项目状态是否为已完成｡

02:12.270 --> 02:15.430
所以这里我会写一个实函数体,

02:15.430 --> 02:17.250
用花括号把它括起来,

02:17.250 --> 02:20.100
不使用箭头函数快捷键,

02:20.100 --> 02:31.480
然后我们可以检查, 如果这个类型是活动的, 那么我想在这里返回检查的结果, else, 因此,

02:31.480 --> 02:40.160
在if语句之后, 我想把比较返回到完成的项目状态｡

02:40.160 --> 02:42.220
这样, 我们就得到了相关的项目,

02:42.220 --> 02:45.490
现在我们可以将其存储在已分配的项目中｡

02:45.490 --> 02:47.070
现在让我们来看看它是否有效｡ 

02:47.070 --> 02:48.053
如果我重新加载,

02:49.310 --> 02:52.743
并在这里添加一个项目, 这是否有效？

02:54.950 --> 02:55.930
这是可行的, 您可以看到,

02:55.930 --> 03:00.020
它只会添加到活动项目, 而不会添加到已完成的项目｡

03:00.020 --> 03:02.390
然而, 如果我在这里添加第二个项目,

03:02.390 --> 03:04.740
我们仍然会有重复｡

03:04.740 --> 03:08.720
这与我们如何渲染项目有关｡ 

03:08.720 --> 03:10.520
在渲染项目中, 我们总是检查所有项目项,

03:10.520 --> 03:15.090
并将它们添加到列表中｡

03:15.090 --> 03:16.640
当然, 这样做的问题是,

03:16.640 --> 03:21.950
我们可能已经在屏幕上呈现了一个项目项｡

03:21.950 --> 03:25.020
现在, 最好的解决方案是运行一些比较,

03:25.020 --> 03:34.110
检查哪些已经渲染, 哪些需要渲染, 以避免不必要的重新渲染｡

03:34.110 --> 03:39.710
但是, 通过查看真实的DOM来运行这种比较也会消耗相当多的性能｡

03:39.710 --> 03:43.100
因此, 对于本应用程序来说, 通过将内部HTML设置为空字符串,

03:43.100 --> 03:49.640
简单地获取我们的列表元素并清除其所有内容是非常好的, 这意味着我们摆脱了所有列表项,

03:49.640 --> 03:53.710
然后重新呈现｡

03:53.710 --> 03:56.350
这意味着, 无论何时添加新项目,

03:56.350 --> 03:58.470
我们都会重新渲染所有项目,

03:58.470 --> 04:03.490
但对于这里的项目和应用程序来说, 这绝对没有问题｡

04:03.490 --> 04:05.410
所以, 现在, 如果我们保存它,

04:05.410 --> 04:06.987
让我们再试一次｡

04:06.987 --> 04:12.960
“这有用吗？ “是第一个项目, 现在如果我在这里添加另一个项目,

04:12.960 --> 04:14.530
您会看到, 它会被添加,

04:14.530 --> 04:17.453
但另一个项目不会再次添加｡

04:18.430 --> 04:21.870
哎呀, 现在, 这里我得到了（咕哝）错误,

04:21.870 --> 04:23.540
因为描述不够长｡

04:23.540 --> 04:26.230
现在, 这一切都正常了, 正如你所看到的,

04:26.230 --> 04:32.170
我们正在以正确的方式渲染这些项目｡

04:32.170 --> 04:35.050
有了这些, 应用程序看起来还不错｡ 

04:35.050 --> 04:44.040
缺少的一件事是一些拖放功能或一些将项目从第一个列表移到第二个列表的方法｡

04:44.040 --> 04:46.930
我们也没有真正输出我们得到的其他信息,

04:46.930 --> 04:48.900
描述和人数｡

04:48.900 --> 04:50.750
所以, 这也不太好｡ 

04:50.750 --> 04:57.620
而且, 当我们实际查看项目列表中的此子句和项目输入子句时,

04:57.620 --> 05:01.000
也会有一些代码重复｡

05:01.000 --> 05:04.270
在这两种方法中, 我们都有模板元素､ 宿主元素和元素,

05:04.270 --> 05:06.970
还有附加方法等等｡

05:06.970 --> 05:09.180
因此, 我想改进这里的代码,

05:09.180 --> 05:14.480
并通过使用继承和使用base子句来重用一些代码,

05:14.480 --> 05:23.725
此后, 我还想为每个项目项创建一个专用子句, 然后在项目列表中实例化该项目项子句,

05:23.725 --> 05:27.050
而不是手动追加列表项, 就像这样,

05:27.050 --> 05:40.540
然后在“待创建”项目项子句中, 然后我还想输出更多关于项目项的信息, 包括它的描述和分配的人数｡

05:40.540 --> 05:42.080
因此, 还有一些工作要做,

05:42.080 --> 05:48.660
在我们以我希望的形式处理项目项之前, 让我们首先确保添加一些继承,

05:48.660 --> 05:53.660
以使我们的项目列表和项目输入, 或其中的某些部分,

05:53.800 --> 05:57.693
更可重用｡
