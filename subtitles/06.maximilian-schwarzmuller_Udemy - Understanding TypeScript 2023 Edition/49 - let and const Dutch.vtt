WEBVTT

00:02.090 --> 00:04.730
Instructeur: Voordat we echter in de functies duiken,

00:04.730 --> 00:07.002
is er een link naar deze pagina bijgevoegd.

00:07.002 --> 00:11.350
Deze pagina geeft een overzicht van alle min of meer moderne JavaScript-functies,

00:11.350 --> 00:13.610
welke browsers deze functies ondersteunen

00:13.610 --> 00:19.700
en ook welke compilers deze functies ondersteunen.

00:19.700 --> 00:23.150
En daar vind je ook TypeScript, TypeScript gecombineerd

00:23.150 --> 00:25.310
met core-js, wat een polyfill

00:25.310 --> 00:27.210
provider is.

00:27.210 --> 00:28.820
Maar over het algemeen beschrijft

00:28.820 --> 00:32.070
dit wat TypeScript kan compileren.

00:32.070 --> 00:34.110
U kunt deze bron altijd gebruiken als u op zoek

00:34.110 --> 00:35.990
bent naar een specifieke eigenschap zoals,

00:35.990 --> 00:37.960
laten we zeggen, het const sleutelwoord, waarbij

00:37.960 --> 00:40.860
u wilt weten of TypeScript daarmee werkt of niet.

00:40.860 --> 00:43.340
Dan kun je zien hoe het daarmee werkt, en wat

00:43.340 --> 00:46.580
de beperkingen zijn, welke browsers dit ondersteunen.

00:46.580 --> 00:48.250
Dit geeft u trouwens ook een

00:48.250 --> 00:51.090
hint over welke browsers u wilt targeten,

00:51.090 --> 00:53.967
over het TypeScript-doel, enzovoort.

00:53.967 --> 00:55.260
Dit is dus een geweldige bron

00:55.260 --> 00:58.600
waarmee je kunt schakelen tussen verschillende iteraties van JavaScript,

00:58.600 --> 01:01.940
en de functies die elke iteratie introduceerde, en hoe deze functies

01:01.940 --> 01:04.220
worden ondersteund.

01:04.220 --> 01:06.140
Gebruik dit dus zeker als hulpmiddel om uit

01:06.140 --> 01:08.800
te zoeken wat je kunt gebruiken, wat je kunt compileren,

01:08.800 --> 01:11.060
en welke doelen je misschien moet stellen.

01:11.060 --> 01:14.060
En daarmee beginnen we met een van de belangrijkste en meest

01:14.060 --> 01:17.030
voor de hand liggende, en vaak gebruikte introducties,

01:17.030 --> 01:19.260
Next-Gen JavaScript toegevoegd.

01:19.260 --> 01:21.780
Trouwens, met Next-Gen JavaScript

01:21.780 --> 01:24.700
bedoel ik ES6 of recenter.

01:24.700 --> 01:27.860
En dat is laten of const, waar ik het over heb.

01:27.860 --> 01:32.750
Hiermee kunt u constanten of variabelen definiëren.

01:32.750 --> 01:35.350
Het verschil is dat constanten, dus variabelen

01:35.350 --> 01:38.730
gedefinieerd met het const sleutelwoord, niet veranderd

01:38.730 --> 01:39.910
kunnen worden.

01:39.910 --> 01:42.410
Als je hier een nieuwe waarde zou proberen toe te wijzen,

01:42.410 --> 01:44.270
ook al heeft die het juiste type, krijg

01:44.270 --> 01:47.220
je een foutmelding omdat het een constante is.

01:47.220 --> 01:48.280
Nu, dit is trouwens een

01:48.280 --> 01:50.200
fout die gevormd wordt door TypeScript.

01:50.200 --> 01:53.340
In Vanilla JavaScript zou je een foutmelding krijgen van de browser

01:53.340 --> 01:55.100
als je hier je code uitvoert, en dat is het

01:55.100 --> 01:57.280
idee achter TypeScript, zoals je geleerd hebt,

01:57.280 --> 02:00.410
we krijgen al een foutmelding terwijl je de code schrijft, want dat

02:00.410 --> 02:02.990
is natuurlijk beter voor ons als ontwikkelaar.

02:02.990 --> 02:04.930
Zo kunnen we deze code eerder repareren

02:04.930 --> 02:07.820
voordat we hem in de console testen.

02:07.820 --> 02:11.330
Dus als we dat hier verwijderen of deze regel uitcommentariëren,

02:11.330 --> 02:12.830
wordt het opnieuw gecompileerd

02:12.830 --> 02:14.400
en krijgen we dus ook geen foutmelding

02:14.400 --> 02:17.130
in de browser.

02:17.130 --> 02:20.860
Dus, dat is const. Let is een variabele die kan worden veranderd,

02:20.860 --> 02:23.620
en daarom is het natuurlijk vergelijkbaar met var.

02:23.620 --> 02:27.260
Var bestaat ook nog steeds omdat JavaScript zo werkt dat functies

02:27.260 --> 02:29.550
niet plotseling worden weggehaald, want

02:29.550 --> 02:33.460
dan zouden oudere browsers en hun scripts kunnen breken.

02:33.460 --> 02:35.160
Maar je moet var niet meer gebruiken.

02:35.160 --> 02:37.860
En waarom zou je var niet meer gebruiken?

02:37.860 --> 02:39.670
Ik bedoel, het is logisch dat we const hebben,

02:39.670 --> 02:42.520
want dat voegt echt een nieuwe functie toe, constanten.

02:42.520 --> 02:43.380
Maar waarom laten?

02:43.380 --> 02:45.380
Waarom hebben ze hier een nieuw sleutelwoord geïntroduceerd?

02:45.380 --> 02:47.223
Waarom bleven ze niet bij var?

02:48.280 --> 02:51.460
Let en const hebben één belangrijk verschil met var.

02:51.460 --> 02:53.300
Nou, het duidelijke verschil voor const is

02:53.300 --> 02:55.240
dat de waarde niet kan worden veranderd, maar

02:55.240 --> 02:57.040
voor let krijgen we ook een verschil.

02:57.040 --> 03:00.930
En dat is het bereik waarin deze variabele beschikbaar is.

03:00.930 --> 03:04.363
Nu zou je dit concept van scopes in JavaScript moeten kennen.

03:05.609 --> 03:09.260
En met var heb je een globale en een functionele scope.

03:09.260 --> 03:10.700
Dat betekent dat variabelen

03:10.700 --> 03:12.550
die je buiten functies definieert

03:12.550 --> 03:15.340
overal in je scripts beschikbaar zijn.

03:15.340 --> 03:17.410
Variabelen die in functies zijn gedefinieerd,

03:17.410 --> 03:19.370
zijn alleen beschikbaar in die functie.

03:19.370 --> 03:22.610
Bijvoorbeeld, hier. Als ik een functie

03:22.610 --> 03:27.610
add had, en er zouden twee getallen komen, a en b.

03:27.670 --> 03:29.750
Dan kunnen we een variabele toevoegen

03:29.750 --> 03:32.280
met var resultaat, laten we zeggen, en we stellen

03:32.280 --> 03:34.730
resultaat = a + b dan, en dan geven we resultaat

03:34.730 --> 03:36.230
terug, en natuurlijk hadden

03:36.230 --> 03:38.430
we dit korter kunnen schrijven, maar ik

03:38.430 --> 03:40.570
wil laten zien wat var doet.

03:40.570 --> 03:41.860
En dit zou fijn zijn.

03:41.860 --> 03:43.012
En het resultaat zou alleen beschikbaar

03:43.012 --> 03:44.188
zijn binnen deze functie.

03:44.188 --> 03:47.723
Als ik het resultaat hier probeer te loggen, zou dat mislukken

03:47.723 --> 03:49.470
omdat het alleen beschikbaar

03:49.470 --> 03:52.190
is in het bereik van deze functie.

03:52.190 --> 03:53.970
Als ik het buiten var harbor definieer

03:53.970 --> 03:56.610
werkt alles omdat het nu globaal beschikbaar is, daarom

03:56.610 --> 03:58.180
kan ik er hier bij.

03:58.180 --> 04:00.220
En ook, de manier waarop JavaScript

04:00.220 --> 04:03.580
werkt, kun je variabelen op een hoger niveau benaderen.

04:03.580 --> 04:05.210
Binnen een functie kun je dus werken

04:05.210 --> 04:08.260
met variabelen die het bereik van deze functie hebben, maar

04:08.260 --> 04:11.100
alle variabelen die een hoger bereik hebben, zoals het

04:11.100 --> 04:12.563
globale bereik hier.

04:13.580 --> 04:14.980
Dus, dat is var.

04:14.980 --> 04:19.180
Nu voor het laten, is het gedrag over het algemeen hetzelfde.

04:19.180 --> 04:21.580
Dit werkt en dit werkt.

04:21.580 --> 04:23.800
Dus het is over het algemeen hetzelfde voor laten.

04:23.800 --> 04:27.180
Maar een belangrijk verschil is dat je voor var

04:27.180 --> 04:30.860
eigenlijk alleen global en functions scope hebt.

04:30.860 --> 04:32.460
Hoe zit het met if statements?

04:32.460 --> 04:36.720
Als we hier controleren op leeftijd > 20, en dan daarbinnen

04:36.720 --> 04:38.889
een variabele aanmaken, isOld,

04:38.889 --> 04:41.190
en deze op true zetten, dan krijgen

04:41.190 --> 04:44.500
we als een console log isOld hier een foutmelding

04:44.500 --> 04:46.270
in TypeScript, maar eigenlijk

04:46.270 --> 04:50.090
niet in JavaScript.

04:50.090 --> 04:53.620
Deze code hier, als je hem pakt om te zien of hij werkt, en naar de JavaScript-ontwikkelaarstools

04:53.620 --> 05:00.970
gaat in de console, en we plakken hem daar en drukken op enter, dan zie je dat true hier wordt afgedrukt.

05:01.830 --> 05:02.960
En inderdaad, als je probeert

05:02.960 --> 05:05.040
isOld te benaderen, krijg je true.

05:05.040 --> 05:08.380
Dus, deze isOld variabele wordt globaal geregistreerd, en

05:08.380 --> 05:10.530
niet alleen binnen het if statement.

05:10.530 --> 05:11.700
Want met var kent

05:11.700 --> 05:13.080
JavaScript geen andere

05:13.080 --> 05:15.860
scopes dan functies en globaal.

05:15.860 --> 05:17.400
En dat verandert met laten.

05:17.400 --> 05:19.690
Nu, zoals ik al zei, TypeScript klaagt toch, omdat dit

05:19.690 --> 05:21.600
geen goede code is om te schrijven, maar technisch

05:21.600 --> 05:23.170
gezien zou het werken.

05:23.170 --> 05:25.100
Met laten, verandert dat.

05:25.100 --> 05:26.350
Nu met let, dit is echt

05:26.350 --> 05:29.880
alleen beschikbaar binnen deze accolades.

05:29.880 --> 05:32.300
Omdat let en const een nieuw concept introduceerden

05:32.300 --> 05:33.540
dat blokbereik heet, wat

05:33.540 --> 05:36.550
betekent dat een variabele of constante altijd beschikbaar

05:36.550 --> 05:40.420
is in het blok waarin u hem definieert of in lagere blokken.

05:40.420 --> 05:43.060
En een blok is eigenlijk altijd een snippet

05:43.060 --> 05:44.900
omgeven door accolades, zoals

05:44.900 --> 05:46.710
bij een if statement, in een for-lus,

05:46.710 --> 05:48.760
in een functie, of zelfs, dat kan,

05:48.760 --> 05:50.590
als je gewoon accolades toevoegt

05:50.590 --> 05:52.670
zoals hier.

05:52.670 --> 05:54.230
Elke hier gedefinieerde variabele

05:54.230 --> 05:56.760
zou alleen in dat blok beschikbaar zijn.

05:56.760 --> 05:57.700
En dat is goed, want

05:57.700 --> 06:00.000
het dwingt je om schonere code te schrijven

06:00.000 --> 06:02.470
en situaties als deze te vermijden.

06:02.470 --> 06:03.640
Dus om het bewijs te leveren

06:03.640 --> 06:05.530
dat er een verschil is in de browser, als

06:05.530 --> 06:09.750
ik deze code kopieer met let, en ik herlaad mijn pagina hier, en nu voer ik dit hier in, zie

06:09.750 --> 06:12.440
je dat ik een foutmelding krijg dat isOld niet gedefinieerd

06:13.559 --> 06:14.706
is. We kregen niet eerder een foutmelding.

06:14.706 --> 06:19.706
Inderdaad, als ik probeer isOld uit te voeren, krijg ik weer die foutmelding.

06:20.070 --> 06:21.060
Dus dat is het verschil.

06:21.060 --> 06:23.370
En daarom is let en const beter, niet alleen omdat

06:23.370 --> 06:25.740
we deze constante eigenschap krijgen, maar ook

06:25.740 --> 06:29.150
omdat we gedwongen worden schonere code te schrijven.

06:29.150 --> 06:30.130
Dus laat me dit uitleggen

06:30.130 --> 06:31.230
om het weer te laten werken.
