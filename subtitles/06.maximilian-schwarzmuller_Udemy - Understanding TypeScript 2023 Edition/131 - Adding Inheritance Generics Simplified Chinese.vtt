WEBVTT

00:02.410 --> 00:06.370
教师：那么是时候进行一些继承和基类了｡

00:06.370 --> 00:09.189
我想添加一个基类, 它基本上包含templateElement,

00:09.189 --> 00:12.090
hostElement, 一个元素, 它负责在dom中选择元素,

00:12.090 --> 00:18.520
它包含attach方法, 我们总是需要它, 等等.

00:18.520 --> 00:28.220
所以它基本上管理所有这些共享的功能, 这些功能是我们实际向dom呈现某些内容的类所共有的｡

00:28.220 --> 00:30.880
因此, 在ProjectInput和ProjectList类之上,

00:30.880 --> 00:38.250
基本上在这里, 我将添加Component基类｡

00:38.250 --> 00:41.540
现在, 名称由您决定, 但我将命名为Component,

00:41.540 --> 00:45.870
因为您可能从React或Angular中知道这个术语, 如果您使用它,

00:45.870 --> 00:49.873
即使您没有使用它, 您也可以将这些类视为UI, 即用户界面组件,

00:50.770 --> 00:53.950
您可以将其呈现到屏幕上｡

00:53.950 --> 00:57.950
每个组件最终都是一个可渲染的对象, 它具有一些功能,

00:57.950 --> 01:01.370
允许我们渲染它｡

01:01.370 --> 01:10.260
然后, 具体的实例或继承的类添加该特定组件所需的额外功能｡

01:10.300 --> 01:14.370
那么 ,  通用 Component 类 中 包含 什么 呢 ？

01:14.370 --> 01:17.590
嗯, 我会肯定地说这三个要素｡ 

01:17.590 --> 01:21.390
模板元素､ 主机元素和元素｡ 

01:21.390 --> 01:23.590
现在, 我们确实有一个问题,

01:23.590 --> 01:25.470
但是, 关于类型｡

01:25.470 --> 01:28.320
templateElement将始终是HTMLTemplateElement,

01:29.160 --> 01:31.980
但hostElement不必始终是div, 例如,

01:31.980 --> 01:42.360
当我们要添加一个项目项类时, 我们将在ProjectList中呈现它, 而不是直接在这里呈现我们的根div, 因此它并不始终是div｡

01:42.360 --> 01:45.220
这里, 它总是一个HTMLElement, 我们当然可以确定,

01:45.220 --> 01:47.040
但是, 就像ProjectInput类的情况一样,

01:47.040 --> 01:55.230
我们实际上知道它是它的某个特定形式, 它是一个HTMLFormElement｡

01:55.230 --> 02:00.320
因此, 如果我们将自己限制为总是只有一个HTMLElement,

02:00.320 --> 02:02.130
而不存储更具体的信息,

02:02.130 --> 02:05.220
我们将丢失这些额外的信息｡

02:05.220 --> 02:07.690
那么我们如何解决这个问题呢？

02:07.690 --> 02:10.050
好吧, 不仅仅是使用继承,

02:10.050 --> 02:12.920
而是在这里创建一个泛型类, 当我们从它继承时,

02:12.920 --> 02:17.680
我们可以设置具体的类型｡

02:17.680 --> 02:20.940
为此, 我们在类名后面添加尖括号,

02:20.940 --> 02:23.550
然后添加两个标识符, 如T和U,

02:23.550 --> 02:26.690
这是常见的选择｡

02:26.690 --> 02:30.110
现在, 我们还可以在这里添加一些约束,

02:30.110 --> 02:34.820
并说T肯定会是某种HTMLElement｡

02:34.820 --> 02:36.770
它可以只是一个HTMLElement,

02:36.770 --> 02:38.970
也可以是它的一个更具体的版本｡

02:38.970 --> 02:41.870
美国也是如此｡ 

02:41.870 --> 02:44.780
这里 , 我们 知道 hostElement 的 类型

02:44.780 --> 02:46.690
是 T , 元素 的 类型 是 U .

02:46.690 --> 02:48.660
现在, 无论何时我们从这个类继承,

02:48.660 --> 02:54.780
我们都可以指定具体的类型, 这样我们就可以在继承的不同地方使用不同的类型｡

02:56.050 --> 02:58.053
现在, 让我们在这里添加一个构造函数｡ 

02:58.910 --> 03:03.060
在该构造函数中, 我们需要一些信息｡

03:03.060 --> 03:05.950
我们需要知道模板的ID, 以便知道如何选择它,

03:05.950 --> 03:09.750
它应该是一个字符串｡

03:09.750 --> 03:11.590
我们需要知道hostElementId,

03:11.590 --> 03:15.833
它也需要是一个字符串, 这样我们就知道在哪里呈现这个组件｡

03:17.440 --> 03:20.505
我还想得到一个newElementId, 这样我们就得到了一个ID,

03:20.505 --> 03:24.350
这个ID必须分配给新呈现的元素｡

03:24.350 --> 03:26.020
然而, 这是可选的,

03:26.020 --> 03:29.690
我通过在参数后添加问号来表示｡

03:29.690 --> 03:34.050
另一种方法是在这里也接受undefined作为一种类型,

03:34.050 --> 03:36.470
但我只使用问号｡

03:36.470 --> 03:39.793
现在, 在构造函数中有了它, 我们基本上可以在这里得到这个代码,

03:40.640 --> 03:42.083
并将它放入Component类的构造函数中,

03:43.810 --> 03:57.450
这样我们就可以存储templateElement, 但是, 当然, 现在我们在这里得到的ID是templateId, 这就是为什么我在构造函数中将它作为参数｡

03:57.450 --> 04:00.060
对于hostElement, 这里的ID当然是hostElementId,

04:00.060 --> 04:02.733
就像这样｡

04:04.790 --> 04:07.930
当然, 关于这里的强制转换, 同样重要的是, 我们知道它的类型是T,

04:07.930 --> 04:12.580
因为T是这个泛型类型, 我们存储它或者将它用于hostElement,

04:12.580 --> 04:17.163
所以这里我们已经可以强制转换它了｡

04:18.160 --> 04:20.253
这样, 我们就可以选择元素｡ 

04:21.130 --> 04:22.940
我们还可以获取更多代码｡ 

04:22.940 --> 04:26.650
这里的代码, 我们导入一个节点等等, 我们设置ID,

04:26.650 --> 04:30.130
我们可以获取所有这些｡

04:30.130 --> 04:35.317
因此, 让我们将其复制到此处, 并将其添加到Component类的构造函数中｡

04:35.317 --> 04:37.640
importedNode, 然后我们设置element,

04:37.640 --> 04:43.000
这里element有这个通用类型U, 所以当我们在这里转换它的时候, 我们知道它在这里是U类型,

04:43.000 --> 04:46.870
所以我们应该把它转换成U｡

04:46.870 --> 04:51.993
这里很好地使用了泛型, 这使得这个Component类真正可重用｡

04:53.060 --> 04:55.200
现在, 关于身份｡ 

04:55.200 --> 04:58.200
这就是我们在这里得到的, newElementId｡ 

04:58.200 --> 05:00.590
当然, 我们可能并不总是有这个, 因为它是可选的,

05:00.590 --> 05:03.870
所以我们应该检查一下是否有｡

05:03.870 --> 05:06.070
所以如果newElementId是一个东西,

05:06.070 --> 05:07.650
并且只有当它是一个东西时,

05:07.650 --> 05:13.023
我才会尝试给它赋值, 否则我们不会尝试, 因为这样我们就没有ID可赋值了｡

05:14.420 --> 05:16.300
好了, 这样, 我们就有了构造函数｡ 

05:16.300 --> 05:19.160
现在, 让我们在这里使用attach函数｡ 

05:19.160 --> 05:21.970
因此, 让我们从其他类中复制attach方法,

05:21.970 --> 05:28.473
并将其作为私有方法添加到Component类中｡

05:32.690 --> 05:38.540
我们也可以称之为｡  附加在Component类的构造函数的末尾｡

05:38.540 --> 05:39.960
这里我们想添加一个元素,

05:39.960 --> 05:44.193
但是我们不知道应该添加到哪里, 所以这实际上是一些额外的信息,

05:44.193 --> 05:46.450
我们应该在这里获取, 作为构造函数中的第四个参数,

05:46.450 --> 05:56.680
insert Atstart可以是一个名字, 比如说是一个布尔值.

05:56.680 --> 06:00.190
我们应该把它移到可选参数的前面｡ 

06:00.190 --> 06:03.980
可选参数应始终放在最后, 因为人们可能会忽略它们｡

06:03.980 --> 06:09.220
因此, 必需参数不能在这些可选参数之后｡

06:09.220 --> 06:12.700
然后insertAtStart被转发到attach,

06:12.700 --> 06:13.533
在那里, insertAtBeginning,

06:14.615 --> 06:23.470
你也可以重用insertAtStart, 我在这里用了不同的名字以避免混淆, 它被作为一个布尔值接收｡

06:23.470 --> 06:28.040
然后在这里, 我们检查insertAtBeginning是否为真,

06:28.040 --> 06:34.887
如果是, 那么在这里, 我们有afterbegin, 否则我们有beforeend｡

06:36.770 --> 06:39.653
现在, 我们可以灵活选择插入方式｡ 

06:42.980 --> 06:49.600
我现在还想把这个类标记为抽象类, 因为人们永远不应该直接实例化它,

06:49.600 --> 06:52.560
相反, 它应该总是用于继承｡

06:52.560 --> 06:56.090
所以在class前面, 我添加了abstract关键字｡ 

06:56.090 --> 06:58.750
这确保了我们现在不能实例化它｡ 

06:58.750 --> 07:01.963
如果我们尝试这样做, TypeScript会对我们大喊大叫｡ 

07:04.070 --> 07:10.840
我还将添加另外两个方法, 即configure方法和renderContent方法｡

07:10.840 --> 07:13.430
我将把它作为一个抽象方法来添加,

07:13.430 --> 07:22.670
这意味着这里缺少具体的实现, 但我们现在基本上强制任何从组件继承的类添加这两个方法,

07:22.670 --> 07:25.980
并使它们可用｡

07:25.980 --> 07:27.220
我只是在这里添加这个,

07:27.220 --> 07:29.390
这样如果其他人查看我们的代码,

07:29.390 --> 07:34.150
他或她就可以很好地理解Component类背后的思想｡

07:34.150 --> 07:36.340
它完成所有的一般呈现,

07:36.340 --> 07:43.840
或者组件的附加, 但是具体的内容和配置需要在我们继承的地方发生｡

07:43.840 --> 07:47.670
边注, 你不能有私有的抽象方法｡ 

07:47.670 --> 07:49.660
所以这里必须省略private,

07:49.660 --> 07:52.000
这是TypeScript不允许的｡

07:52.000 --> 07:56.480
好了, 通过这个, 我们可以在ProjectList上扩展Component,

07:56.480 --> 07:59.130
现在去掉这三个属性｡

07:59.130 --> 08:00.640
我们保留assignedProjects,

08:00.640 --> 08:03.520
因为它特定于ProjectList｡

08:03.520 --> 08:09.560
我们现在还想指定应该为泛型类型插入的具体值｡

08:09.560 --> 08:16.540
我们知道, 如果我们还原这个, 我们知道我们会有一个HTMLDivElement和一个HTMLElement,

08:16.540 --> 08:22.800
所以在这里我会传入HTMLDivElement和HTMLElement, 就像这样,

08:22.800 --> 08:25.830
然后去掉这三个属性｡

08:25.830 --> 08:32.550
在构造函数中, 我们现在不需要它了, 但是我们需要在开始的时候调用super,

08:32.550 --> 08:38.080
调用基类的构造函数, 然后我们需要传递一些信息给super构造函数,

08:38.080 --> 08:40.840
我们需要传递一些信息｡

08:40.840 --> 08:42.753
out templateElement的ID､

08:44.050 --> 08:45.850
hostElementId､

08:45.850 --> 08:47.870
是否要在hostElement的开头插入此ID,

08:47.870 --> 08:51.920
以及可能要分配给新元素的ID｡

08:51.920 --> 08:54.038
这是我们的模板ID,

08:54.038 --> 08:57.811
有了它, 我们可以在这里删除它｡

08:57.811 --> 09:01.292
这里是hostElement, ID是app,

09:01.292 --> 09:02.670
我们可以去掉它.

09:02.670 --> 09:04.260
我们保留assignedProjects,

09:04.260 --> 09:06.400
因为这里仍然需要它｡

09:06.400 --> 09:08.193
我们在这里去掉了它,

09:10.150 --> 09:16.850
但是, 关于新元素的ID, 我想把它作为第四个参数传递｡

09:16.850 --> 09:19.040
第三个是这个应该插入的地方,

09:19.040 --> 09:25.890
这里, 我们用在结尾之前插入这个, 所以实际上我想在这里插入的insertAtStart值的参数是false,

09:25.890 --> 09:32.283
因为它不应该插入在开头, 而是在结尾｡

09:36.000 --> 09:38.940
现在, 我当然仍然希望在这里设置侦听器｡ 

09:38.940 --> 09:40.730
我不需要调用attach,

09:40.730 --> 09:44.410
这将在基类中, 在基本组件中发生.

09:44.410 --> 09:46.253
我将调用renderContent｡ 

09:47.870 --> 09:50.010
而这里我们不应该使用这个类型,

09:50.010 --> 09:54.410
而只是类型, 因为在超级完成运行之前我们不能使用这个｡

09:54.410 --> 09:57.690
不过这没问题, 因为我们收到的类型是一个参数｡

09:57.690 --> 09:59.680
现在, 您可以看到, 我仍然在这里得到一个错误,

09:59.680 --> 10:03.487
因为我们在ProjectList中有一个attach方法,

10:03.487 --> 10:07.330
它与基类中的attach方法冲突｡

10:07.330 --> 10:10.600
所以, 让我们去掉这个附加方法｡ 

10:10.600 --> 10:16.060
现在我们仍然会得到一个错误, 因为您可以看到, renderContent在这里是私有的,

10:16.060 --> 10:18.270
但我们在这里将其指定为公共方法,

10:18.270 --> 10:22.860
我希望将其指定为私有方法, 但不支持私有抽象方法｡

10:22.860 --> 10:25.680
我将在这里删除private关键字,

10:25.680 --> 10:28.170
这样, 我们就剩下一个问题, 我们没有configure方法,

10:28.170 --> 10:31.990
我承诺我们会在这里有｡

10:31.990 --> 10:33.650
好吧, 让我们把它加进去｡ 

10:33.650 --> 10:38.500
因此, 在这里, 除了renderConfig, 我们还可以添加configure,

10:38.500 --> 10:40.510
尽管我在这里什么也没做｡

10:40.510 --> 10:42.950
或者, 您可以通过添加一个问号将其转换为可选方法,

10:42.950 --> 10:47.520
这样就不会强制您添加它｡

10:47.520 --> 10:50.380
在这里, 我将添加它, 因为我们也可以认为,

10:50.380 --> 10:58.530
对于ProjectList, 我们将在这里设置侦听器的代码实际上放入configure中｡

10:58.530 --> 11:00.810
因此, 我们可以进行配置,

11:00.810 --> 11:03.320
然后在这里进行我们的工作,

11:03.320 --> 11:05.220
即侦听器设置｡

11:05.220 --> 11:06.610
现在, 我们应该确保调用renderContent,

11:06.610 --> 11:10.653
但也要像这样配置｡

11:12.730 --> 11:18.560
如果你想知道为什么我没有在构造器的抽象类中调用configure和renderContent,

11:18.560 --> 11:23.720
我们可以这样做, 但是我们可能会有问题｡

11:23.720 --> 11:26.760
如果我们在Component类中调用它,

11:26.760 --> 11:39.410
那么, 我们可能会调用继承类中的一个方法, 例如在扩展Component的类中, renderContent或configure依赖于继承类的构造器实际上可能设置的东西,

11:39.410 --> 11:41.540
只有在基类构造器完成之后,

11:41.540 --> 11:48.100
renderContent和/或configure依赖于它｡

11:48.100 --> 11:52.410
这就是为什么基本上, 确保继承类调用这些方法,

11:52.410 --> 11:55.410
而不是基类为我们调用这些方法,

11:55.410 --> 11:56.860
会更安全｡

11:57.980 --> 12:01.280
因此, 我们重新构造了ProjectList类,

12:01.280 --> 12:05.040
以利用继承和共享逻辑｡

12:05.040 --> 12:07.730
现在, 让我们对ProjectInput执行相同的操作｡ 

12:07.730 --> 12:13.170
在这里, 我们还想扩展Component｡

12:13.170 --> 12:14.900
使用它的泛型性质, 在那里,

12:14.900 --> 12:19.430
我们有hostElement的HTMLDivElement,

12:19.430 --> 12:23.980
以及呈现的元素的HTMLFormElement｡

12:23.980 --> 12:28.310
这样, 我们就可以去掉这三个属性了, 让我们这样做吧｡

12:28.310 --> 12:32.140
当然, 我们保留这三个属性是因为它们特定于ProjectInput｡

12:33.040 --> 12:35.310
然后我们必须在这里调用super,

12:35.310 --> 12:39.900
我们将模板的ID传递给super, 也就是ProjectInput,

12:39.900 --> 12:41.970
宿主元素的ID, 也就是app,

12:41.970 --> 12:50.510
insertBefore在这里是true, 因为我想在这个ProjectInput类的开头插入新创建的元素.

12:50.510 --> 12:53.110
然后是newElementId,

12:53.110 --> 12:56.913
这里是用户输入, 所以我们也应该转发它｡

12:57.844 --> 12:59.400
有了这个, 我们就可以去掉这个代码,

12:59.400 --> 13:03.480
这个代码, 实际上是所有这些代码｡

13:03.480 --> 13:05.240
当然, 把这个代码保存在这里｡ 

13:05.240 --> 13:09.860
然而, 我们也可以说, 我们把它放在配置也许｡

13:09.860 --> 13:12.100
下面我们来看看configure方法,

13:12.100 --> 13:13.660
这里已经有了这个方法, 在这里添加监听器,

13:13.660 --> 13:17.683
或者在这里添加属性设置来进行配置｡

13:18.880 --> 13:20.780
当然, 我们要去掉attach,

13:20.780 --> 13:29.690
因为这是基类为我们做的, 我们来看看TypeScript不喜欢什么, 当然我们应该去掉attach.

13:29.690 --> 13:32.520
是的, 实际上TypeScript不喜欢的一件事是,

13:32.520 --> 13:44.770
它现在抱怨这些字段没有在构造器中初始化, 因为它不理解或没有检查构造器中调用了configure并进行了初始化｡

13:44.770 --> 13:47.500
为了满足TypeScript的要求,

13:47.500 --> 13:52.170
我将把这些初始化从configure直接移回到构造函数中｡

13:52.170 --> 13:55.953
从技术上讲, 结果是完全相同的, 但现在TypeScript不会抱怨了｡

13:56.800 --> 14:02.310
然而, 它会抱怨我们确实有一个私有的configure方法, 所以就像以前一样,

14:02.310 --> 14:08.940
我们应该改变它, 把configure变成一个公共方法｡

14:08.940 --> 14:13.000
现在, 这不是必须要做的, 但首先使用公共方法是一种惯例,

14:13.000 --> 14:17.240
这就是为什么我在这里将它移到其他私有方法之上｡

14:17.240 --> 14:21.990
当然, 现在它还抱怨我们没有renderContent方法｡

14:21.990 --> 14:25.020
现在, 我将添加一个, 只是因为我们需要｡ 

14:25.020 --> 14:26.780
这里我们没有在其中做任何事情,

14:26.780 --> 14:31.053
所以从技术上讲它不是必需的, 但是现在我们满足了基类｡

14:32.260 --> 14:34.603
在ProjectList类中,

14:35.550 --> 14:39.590
边注､ renderContent和configure也可以移到这个私有方法上面,

14:39.590 --> 14:45.123
原因与我刚才提到的约定完全相同｡

14:46.440 --> 14:49.870
这样, 我们还重新构造了ProjectInput,

14:49.870 --> 14:55.330
以利用继承并让基类完成大量工作｡

14:55.330 --> 14:57.670
让我们看看现在是否一切正常｡ 

14:57.670 --> 15:00.710
如果我们保存它, 它编译时没有错误,

15:00.710 --> 15:05.870
看起来运行得很好, 所以这个工作是不是就成问题了｡

15:05.870 --> 15:07.810
看起来很不错｡ 

15:07.810 --> 15:09.720
它的工作方式和以前一样,

15:09.720 --> 15:11.600
但是现在我们有了更干净的代码,

15:11.600 --> 15:15.850
在这里我们利用了代码重用, 这要归功于继承｡

15:15.850 --> 15:18.540
现在, 这不是我们唯一可以继承的地方｡ 

15:18.540 --> 15:24.230
我想通过重构我们项目的状态来结束这节课｡

15:24.230 --> 15:26.240
从技术上讲, 我们不需要继承,

15:26.240 --> 15:29.450
因为我们在整个应用程序中只管理这一个状态,

15:29.450 --> 15:35.310
但设想一个更大的应用程序, 其中有多个不同的状态｡

15:35.310 --> 15:37.240
一个用于用户状态､

15:37.240 --> 15:39.290
用户是否登录等, 一个用于项目,

15:39.290 --> 15:43.030
一个用于购物车｡

15:43.030 --> 15:48.080
现在, 你会注意到你的状态类的一些特征总是相同的｡

15:48.080 --> 15:52.780
特别是侦听器数组和addListener方法｡

15:52.780 --> 15:54.730
所以我们也可以在这里使用基类｡ 

15:55.650 --> 15:58.170
我们可以在这里使用一个State类,

15:58.170 --> 16:01.230
该类有一个listeners数组, 还有一个addListeners方法,

16:01.230 --> 16:09.160
所以我们将从ProjectState中删除这两个方法, 并将其添加到State中｡

16:09.160 --> 16:16.720
当然, 这也意味着我们不知道监听器是否会返回一组项目｡

16:16.720 --> 16:18.253
所以实际上在这里,

16:19.110 --> 16:20.760
对于这个函数类型,

16:20.760 --> 16:24.740
我还需要一个泛型类型｡

16:24.740 --> 16:27.440
这样我们就可以从外面设置这个了｡ 

16:27.440 --> 16:28.483
我们可以这样做,

16:29.790 --> 16:31.623
我们可以写一个泛型类型,

16:32.680 --> 16:35.730
就像这里这样, 一个自定义类型, 它是泛型的,

16:35.730 --> 16:42.460
我们可以在类型名后面添加尖括号, 使用我们选择的标识符, 然后在这里重用该类型｡

16:42.460 --> 16:44.960
现在, 我们可以使State成为泛型,

16:44.960 --> 16:46.320
我们可以使用相同的标识符,

16:46.320 --> 16:49.530
因为它是与我们的自定义类型不同的构造｡

16:49.530 --> 16:53.520
然后在这里, 当我们说我们想要一个侦听器列表时,

16:53.520 --> 17:01.510
我们必须告诉TypeScript侦听器为我们正在创建的State对象使用哪种泛型类型｡

17:01.510 --> 17:06.490
这仅仅意味着我们可以在这里和这里转发泛型类型｡

17:06.490 --> 17:09.410
因此, 当我们现在扩展状态时, 我们必须指定该状态将使用的数据类型,

17:09.410 --> 17:17.680
而不是状态, 然后将其转发到我们的侦听器自定义类型, 这就是我们的想法｡

17:17.680 --> 17:19.580
我们如何利用这些资源？

17:19.580 --> 17:21.950
在下面的ProjectState类中,

17:21.950 --> 17:27.900
我们只是扩展了State类, 现在, 为通用占位符提供了一个具体的值, 在这里,

17:27.900 --> 17:30.040
这个具体的值就是Project,

17:30.040 --> 17:32.480
因为这个ProjectState完全是关于管理的,

17:32.480 --> 17:36.510
你猜怎么着？

17:36.510 --> 17:37.393
项目｡ 

17:38.970 --> 17:41.650
现在, 这里的私有构造函数有个问题,

17:41.650 --> 17:45.160
你可以看出, 因为我们没有调用super.

17:45.160 --> 17:48.350
好吧, 我们一定要这么做, 让我们打电话给这里的管理员,

17:48.350 --> 17:49.800
这就是我们要做的｡

17:50.640 --> 17:53.490
在这里, 如果我们向下滚动, 在这里我们浏览监听器,

17:53.490 --> 18:00.240
我们看到监听器是私有的, 它在我们的基类中是私有的｡

18:00.240 --> 18:03.580
这意味着我们只能从基类内部访问它｡

18:03.580 --> 18:06.760
但您了解了另一个访问修饰符,

18:06.760 --> 18:09.380
它类似于private,

18:09.380 --> 18:14.990
但也允许从继承类进行访问, 并且它是受保护的｡

18:14.990 --> 18:18.930
Protected表示仍然不能从类外部访问它,

18:18.930 --> 18:23.030
但可以从继承的任何类访问它｡

18:23.030 --> 18:24.740
这样, 让我们保存所有这些,

18:24.740 --> 18:26.650
它应该编译得很好｡

18:26.650 --> 18:28.940
让我们快速测试一下,

18:28.940 --> 18:31.790
看起来不错, 和以前一样, 但是现在,

18:31.790 --> 18:34.160
再一次, 用更好的代码,

18:34.160 --> 18:38.363
使用继承和泛型来管理状态｡
