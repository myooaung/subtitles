WEBVTT

00:02.270 --> 00:05.080
講師：メソッド・デコレーターで何かを返すことができるわけですが､

00:05.080 --> 00:06.820
その何かを記述子にすることで､ メソッドを変更したり､

00:06.820 --> 00:11.000
メソッドの構成を変更したりすることができるようになるはずです｡

00:11.000 --> 00:12.582
そして､ これは私がここでやりたいことなのです｡ 

00:12.582 --> 00:15.985
その前に､ まずindexのHTMLファイルに移動して､

00:15.985 --> 00:18.540
そこに､ ボタンを追加してみましょう｡

00:18.540 --> 00:21.272
私のアプリでは､ とてもシンプルなボタン､ Click

00:21.272 --> 00:24.720
Meを使用しています｡ ts ファイルで､ このボタンをクリックすると､

00:24.720 --> 00:29.800
オブジェクトのメソッドが実行されるようにしたいのです｡

00:29.800 --> 00:32.120
そのために､ ここでは単純に新しいクラス､

00:32.120 --> 00:34.600
まずプリンターを追加します｡

00:34.600 --> 00:38.140
そして､ その中にメッセージというプロパティがあり､

00:38.140 --> 00:41.690
それは単にこの作品のようなもので､ 単純な文字列がそこに格納され､

00:41.690 --> 00:49.630
その中にメッセージ表示メソッドがあり､ そこで単にこのメッセージをコンソールログします｡

00:49.630 --> 00:51.770
もちろん､ これは単純なダミー・クラスですが､ それでも､

00:51.770 --> 00:54.860
これによって私がお見せしたいものをお見せすることができます｡

00:54.860 --> 00:56.550
ドキュメントクエリセレクタボタンで､

00:56.550 --> 01:02.970
今すぐ扉にするボタンを選択し､ イベントリスナーを追加してみましょう｡

01:02.970 --> 01:05.080
まず最初に､ 感嘆符をここに追加して､ TypeScriptにこれが存在すること､

01:05.080 --> 01:10.990
これがNULLにならないことを明確にします｡ 次に､ イベントリスナー､ クリックイベントリスナーを追加して､ ここにあるshow

01:10.990 --> 01:16.450
messageメソッドをトリガーしたいと思います｡

01:16.450 --> 01:23.120
そのために､ このようにここに新しいプリンタを作成し､ ここでpを指します｡

01:23.120 --> 01:23.120
showMessage､

01:23.120 --> 01:24.323
これは私のアイデアです｡

01:25.300 --> 01:27.103
これを保存して､ ページに戻ってこのボタンをクリックすると､

01:28.153 --> 01:36.050
ここでは未定義となり､ メッセージは表示されませんが､ 表示されます｡

01:36.050 --> 01:38.860
その理由は､ イベントリスナーでは､ 実行すべき関数を指定した場合､

01:38.860 --> 01:52.193
その関数内のthisキーワードは､ pだけを呼び出した場合のようなコンテキストやリファレンスを持っていないためです｡

01:52.193 --> 01:52.193
ShowMessage､

01:53.144 --> 01:56.450
この場合はプリンターを指すことになります｡

01:56.450 --> 02:05.777
いいえ､ イベントリスナーを使用するこのシナリオでは､ 最後にaddEventListenerがイベントのターゲットに実行される関数でこれをバインドするので､

02:05.777 --> 02:09.560
これはイベントのターゲットを参照することになります｡

02:09.560 --> 02:11.360
もちろん､ こんなことは望んでいない｡ 

02:11.360 --> 02:12.570
ここで､ 一般的な回避策として､

02:12.570 --> 02:14.170
bindメソッドを使用して､

02:14.170 --> 02:19.170
showMessageをpにバインドするか､ showMessageの中のこれをpにバインドして､

02:19.480 --> 02:31.770
これが実行されたときに､ addEventListenerが参照したいものを参照せず､ showMessageの中のこれがこのp､ ここにあるこのオブジェクトに再び参照されるようにします｡

02:31.770 --> 02:33.300
そして､ 今､ ここでリロードして､ もう一度これをクリアすると､

02:33.300 --> 02:36.270
今度はこれがうまくいくことがわかります｡

02:36.270 --> 02:39.240
これで､ すべてデフォルトのJavaScriptになりました｡ 

02:39.240 --> 02:42.191
このメソッドにデコレーターを追加すると､

02:42.191 --> 02:53.440
このメソッドが呼び出されるたびに､ 周囲のクラス､ つまりこのメソッドが属しているオブジェクトに自動的にバインドされます｡

02:53.440 --> 02:55.974
そのために､ プリンターの上に新しい関数を追加して､

02:55.974 --> 03:01.580
それをautobindと名付けます｡ なぜなら､ 最終的にはそれが私たちが行うことだからです｡

03:01.580 --> 03:03.890
もちろん､ 他の名前と同じように大文字で始めることもできますが､

03:03.890 --> 03:05.960
やはり､ デコレータ関数を定義するときには､

03:05.960 --> 03:10.122
この2つのどちらかを使うことができます｡

03:10.122 --> 03:15.269
さて､ ここがすでに私のデコレーターになるのですが､ この中で2つの引数を取得します｡

03:15.269 --> 03:17.940
ターゲットがわかる､ それはどんなものでも｡ 

03:17.940 --> 03:20.085
スタティックメソッドに追加する場合は､

03:20.085 --> 03:22.533
オブジェクトのプロトタイプかコンストラクタ関数になりますが､

03:22.533 --> 03:30.200
ここではインスタンスメソッドに追加するので､ プロトタイプになります｡

03:30.200 --> 03:32.520
メソッド名やプロパティ名がありますが､ メソッドに追加することで､

03:32.520 --> 03:33.690
このメソッド名を呼び出すことができるため､

03:33.690 --> 03:36.330
より理にかなっています｡

03:36.330 --> 03:38.600
もちろん､ 文字列や記号､

03:38.600 --> 03:40.229
数値も可能ですが､

03:40.229 --> 03:45.061
ここでは通常､ 文字列を使用することがわかっているので､

03:45.061 --> 03:50.170
このデコレータを追加する場所や汎用性によっては､

03:50.170 --> 03:56.340
ここで文字列を使用することも可能です｡

03:56.340 --> 03:57.650
これで3つの引数が揃いました｡

03:57.650 --> 03:59.655
これらはすべて､ 以前メソッド・デコレーターとして使用した

03:59.655 --> 04:03.540
Log3 で使用したものです｡

04:03.540 --> 04:11.973
さて､ autobindで､ 私は今､ このキーワードを常にこのメソッドが属するこのオブジェクトに再び設定することを確認したいです｡

04:11.973 --> 04:14.240
さて､ どうすればこれを実現できるのでしょうか｡ 

04:14.240 --> 04:17.880
まず､ 呼び出すべきメソッドにアクセスする必要がある｡

04:17.880 --> 04:22.013
アプリをリロードして､ このようなメソッド記述子を見ると､

04:22.013 --> 04:25.180
記述子の中にvalueプロパティがあり､

04:25.180 --> 04:29.460
それが関数を指していることがわかります｡

04:29.460 --> 04:32.240
このプロパティの値は関数なので､ この場合､

04:32.240 --> 04:35.498
メソッドは関数を値とするプロパティに過ぎない｡

04:35.498 --> 04:38.630
したがって､ ここで､ 元のメソッドを抽出し､ 記述子にアクセスすることによって､

04:38.630 --> 04:47.320
このように呼び出すことができるのです｡

04:47.320 --> 04:47.320
の値を設定します｡ 

04:47.320 --> 04:50.563
これによって､ まあ､ オリジナルのメソッドにアクセスできるようになります｡ 

04:51.790 --> 04:55.450
次に､ 新しいadjusted descriptorを設定します｡

04:55.450 --> 04:58.320
これは､ 最終的に､ 後で返すものになります｡

04:58.320 --> 05:00.030
これはオブジェクトで､

05:00.030 --> 05:03.620
プロパティディスクリプタのタイプになります｡

05:03.620 --> 05:09.350
さて､ このオブジェクトには､ プロパティ記述子に追加できるすべてのものを追加することができます｡

05:09.350 --> 05:12.110
例えば､ これをconfigurable, trueに設定し､

05:12.110 --> 05:17.130
enumerableをfalseに設定して､ 外部ループに表示されないようにします｡

05:17.130 --> 05:20.310
そして､ ここにゲッターを追加します｡

05:20.310 --> 05:23.400
ここではゲッターを追加しています｡ これはメソッド､ または関数を保持するプロパティで､

05:23.400 --> 05:32.260
同じものです｡ これにより､ ユーザーがこのプロパティにアクセスしようとしたときに､ 特別なロジックを実行することができます｡

05:32.260 --> 05:35.170
このプロパティの値､ つまり関数を直接実行するのではなく､

05:35.170 --> 05:40.850
関数を実行する前にステップインして余分な作業をすることができるようにします｡

05:40.850 --> 05:41.913
それが､ ここでの考え方です｡ 

05:43.230 --> 05:46.290
つまり､ この記述子には値プロパティを追加せず､

05:46.290 --> 05:48.660
ゲッターだけを用意します｡ ゲッターは基本的に､

05:48.660 --> 05:54.777
値が返される前に実行される追加ロジックを持つ値プロパティを持つようなものです｡

05:54.777 --> 05:59.777
さて､ この中にバインドした関数を作り､ ここで抽出したオリジナルのメソッドを使い､

05:59.900 --> 06:07.100
bindとbind thisを呼び出します｡

06:07.100 --> 06:08.590
そして今､ 遺贈はもちろん､

06:08.590 --> 06:11.730
この中で何を指しているのか？

06:11.730 --> 06:13.720
これはこのゲッターメソッドの中にあるので､

06:13.720 --> 06:19.510
このゲッターメソッドのトリガーとなるものを参照することになることに注意してください｡

06:19.510 --> 06:21.110
そして､ これが今のトリックです｡

06:21.110 --> 06:23.700
ゲッターメソッドはそれが属する具象オブジェクトによって起動されるので､

06:23.700 --> 06:33.610
ゲッターメソッドのこの内側は常にゲッターを定義したオブジェクトを参照することになるのです｡

06:33.610 --> 06:36.800
これは､ addEventListenerによって上書きされません｡

06:36.800 --> 06:38.965
なぜなら､ ゲッターは､ 実行されている我々の関数と､

06:38.965 --> 06:44.976
それが属しているオブジェクトとイベントリスナーの間の余分なレイヤーのようなものだからです｡

06:44.976 --> 06:51.610
したがって､ ここでのthisは､ もともとメソッドを定義したオブジェクトを参照することになります｡

06:51.610 --> 06:54.660
そのため､ これを元のメソッドに安全にバインドし､

06:54.660 --> 07:01.170
元のメソッド内のこのメソッドもまったく同じオブジェクトを参照するようにすることができます｡

07:01.170 --> 07:04.300
では､ ここでバインドされた関数を返し､ 以後､ この調整されたディスクリプタの外では､

07:04.300 --> 07:08.910
調整されたディスクリプタを返すことにします｡

07:08.910 --> 07:10.560
これがデコレータ関数で､ 新しい記述子オブジェクトを返す｡

07:10.560 --> 07:18.710
したがって､ この記述子オブジェクトは古い記述子を上書きし､ TypeScriptがそれを使って行うことになる｡

07:18.710 --> 07:21.500
TypeScriptは､ 古いメソッド記述子､

07:21.500 --> 07:23.215
つまり古いメソッド構成を､

07:23.215 --> 07:28.513
ゲッター層を追加した新しい構成に置き換えます｡

07:29.460 --> 07:33.330
さて､ ここではもちろんターゲットやメソッド名には興味がないので､

07:33.330 --> 07:39.083
エラーを避けるために､ このアンダースコアとこのアンダースコア2という名前をつけることにします｡

07:40.260 --> 07:43.070
ここでも､ TypeScriptにこれらの値には興味がないが､

07:43.070 --> 07:45.480
受け入れる必要があることを伝えるだけだ｡

07:45.480 --> 07:49.800
そして､ ここでshowMessageにautobindを追加してみましょう｡ 

07:49.800 --> 07:52.203
ここで､ Autobindを追加し､

07:54.050 --> 07:56.490
イベントリスナーでbindを削除したことを確認し､

07:56.490 --> 07:59.236
これを保存します｡

07:59.236 --> 08:01.450
それでは､ 「Click Me」をクリックすると､

08:01.450 --> 08:04.730
「This Works！」と表示されます｡

08:04.730 --> 08:06.678
リロードすると､ これが効くんです｡ 

08:06.678 --> 08:09.680
これが正しくバインドされるようになったからです｡ 

08:09.680 --> 08:13.520
ゲッターとデコレーターのバインディングを削除して保存すると､

08:13.520 --> 08:17.850
リロードして Click me をクリックすると､ 再び undefined

08:17.850 --> 08:23.626
が表示されることが確認できます｡

08:23.626 --> 08:27.389
つまり､ この特別なゲッター層は､ showMessageをどのように呼び出したとしても､

08:27.389 --> 08:33.260
常に正しくバインドされるようにするために､ ここでその役目を果たしています｡

08:33.260 --> 08:35.380
このようにオブジェクトに直接呼び出すと動作しますが､

08:35.380 --> 08:38.350
イベントリスナーを使用してこのように呼び出すと､

08:38.350 --> 08:40.760
これも動作します｡

08:40.760 --> 08:45.070
このように､ 最終的にはshowMessageの呼び出しによって動作していることがわかります｡

08:45.070 --> 08:48.266
また､ ボタンをクリックしても動作することがわかります｡

08:48.266 --> 08:49.918
このように､ デコレータを利用することで､

08:49.918 --> 08:52.060
非常に素晴らしい機能を構築することができ､

08:52.060 --> 08:55.190
手動であらゆる場所にbindを呼び出す手間を省くことができる､

08:55.190 --> 08:58.718
ということがよくわかります｡

08:58.718 --> 09:01.883
その代わり､ こんな風に縛ればいいんです｡ 
