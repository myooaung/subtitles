WEBVTT

00:02.220 --> 00:03.760
講師：このモジュールで最後に紹介する面白いタイプは､

00:03.760 --> 00:07.490
neverタイプです｡

00:07.490 --> 00:10.660
さて､ voidを返す関数を見ました｡ 

00:10.660 --> 00:13.058
だから､ それは決して何も返しません｡ 

00:13.058 --> 00:17.380
関数が返すことができる別の型は､ 決してありません｡ 

00:17.380 --> 00:19.240
というと､ 変に聞こえるかもしれません｡ 

00:19.240 --> 00:21.110
その仕組みを見てみましょう｡ 

00:21.110 --> 00:24.662
例えば､ generateErrorという関数があるとします｡ 

00:24.662 --> 00:31.610
ここでは､ 文字列であるメッセージと､ 数字であるエラーコードが表示されると考えています｡

00:31.610 --> 00:35.130
さて､ この関数の内部で､ 例えば､ エラーを投げることにしましょう｡

00:35.130 --> 00:41.500
ですから､ これは本来､ エラーオブジェクトを生成してそれを投げるユーティリティ関数であるべきなのです｡

00:41.500 --> 00:42.990
そこで､ ここではJavaScriptでできる､

00:42.990 --> 00:44.380
オブジェクトを投げるかもしれません｡

00:44.380 --> 00:47.366
どんなオブジェクトでも､ どんな値でも､ エラーとして投げることができます｡

00:47.366 --> 00:53.990
メッセージプロパティを持ち､ ここにメッセージ引数の値を格納します｡

00:53.990 --> 00:56.390
そして､ エラーコードのプロパティを持ちたいのですが､

00:56.390 --> 00:59.417
例えば､ .NETのコード引数の単語を消すとします｡

01:00.330 --> 01:02.390
無効な関数と一緒で､ 例えばエラーが発生し､

01:02.390 --> 01:09.640
コードが500になった状態でこれを呼び出せばいいわけです｡

01:09.640 --> 01:12.213
そうして､ このファイルをコンパイルすると､

01:14.120 --> 01:19.150
リロード時にエラーが発生することがわかります｡

01:19.150 --> 01:22.850
と､ かなり抽象的に聞こえるかもしれませんが､ 実はそうでもないんです｡

01:22.850 --> 01:24.640
このようなユーティリティ関数は､

01:24.640 --> 01:44.690
大規模なアプリケーションではごく一般的なものです｡ アプリ内の10か所で手動でエラーをスローしたくない場合､ エラーオブジェクトを生成してすぐにスローしてくれる便利な関数を利用するとよいでしょう｡

01:44.690 --> 01:49.048
さて､ この関数の面白いところは､ 単にvoidを返しているのではないことです｡

01:49.048 --> 01:54.545
もちろん何も返さないので､ voidを返すと指定できるのですが､

01:54.545 --> 01:58.030
実はただ何も返さないのではなく､ 正直に言うと､

01:58.030 --> 02:02.630
この関数は決して返さないのです｡

02:02.630 --> 02:05.518
この関数は､ 決して戻り値を生成しない｡ 

02:05.518 --> 02:08.860
もし､ このコンソールログの結果から戻り値を復元して､

02:08.860 --> 02:11.193
この実行コードでコンパイルすると､

02:12.040 --> 02:16.240
未定義が記録されていないことがわかります｡ なぜなら､

02:16.240 --> 02:25.330
エラーが投げられたので､ これは本質的にスクリプトをクラッシュさせたと言えるからです｡

02:25.330 --> 02:27.080
台本がキャンセルされてしまうんです｡ 

02:27.080 --> 02:30.290
そして､ この機能は常にそうでありたいと思います｡ 

02:30.290 --> 02:32.210
もちろん､ このスクリプトを続けるためにtry

02:32.210 --> 02:34.260
catchでラップすることはできますが､

02:34.260 --> 02:37.620
この関数は基本的に値を生成しません｡

02:37.620 --> 02:41.060
この関数は､ try catchを使用している場合､

02:41.060 --> 02:44.720
常にスクリプトまたはスクリプトのこの部分をクラッシュさせ､

02:44.720 --> 02:47.910
したがって何も返しません｡

02:47.910 --> 02:50.400
したがって､ この関数の戻り値の型は､

02:50.400 --> 02:54.483
voidだけでなく､ neverもあります｡

02:55.710 --> 02:56.700
さて､ 面白いのは､ neverを指定せずにカーソルを合わせると､

02:56.700 --> 03:01.680
推論される型がvoidであることがわかることです｡

03:01.680 --> 03:05.410
Allsはneverが新しい型なので､ 以前からあったのですが､

03:05.410 --> 03:10.000
TypeScriptの最初のバージョンには組み込まれていなかったので､ voidが一般的に想定されており､

03:10.000 --> 03:15.417
そのままにしておくのは恐ろしいことではないのです｡

03:15.417 --> 03:17.740
しかし､ neverを戻り値の型として明示的に設定することで､

03:17.740 --> 03:24.490
決して何も返さないということを明確にすることができます｡

03:24.490 --> 03:29.560
コード品質の観点から､ この関数は何も返さないことを意図しており､

03:29.560 --> 03:40.954
スクリプトやスクリプトの一部をクラッシュさせたり壊したりすることを､ コードを読む開発者たちに明確に伝えることができます｡

03:40.954 --> 03:43.890
ところで､ もう一つ､ 絶対に戻らない関数は､

03:43.890 --> 03:47.190
無限ループを持つ関数である｡

03:47.190 --> 03:51.060
つまり､ while (true)があると無限ループになり､

03:51.060 --> 03:54.410
それもまた､ 決して戻らない関数となるのです｡

03:54.410 --> 03:56.070
ここでのエラー関数､ つまりフリーズしたエラーを発生させる関数の方が､

03:56.070 --> 04:01.305
おそらく一般的なユースケースだと思いますが｡

04:01.305 --> 04:08.553
このような場合､ 関数で使用することができます｡
