WEBVTT

00:02.280 --> 00:06.450
教师：让我们深入了解TypeScript支持的核心类型｡

00:06.450 --> 00:09.800
下一个有趣的类型是对象类型｡ 

00:09.800 --> 00:13.100
现在, 你知道JavaScript中的对象, 它们看起来像这样｡ 

00:13.100 --> 00:16.350
大括号里有键值对, 这些值在TypeScript中也被视为对象类型,

00:16.350 --> 00:23.620
所以任何JavaScript对象都是object类型.

00:23.620 --> 00:28.410
虽然我已经说过, 在TypeScript中有更具体的对象版本,

00:28.410 --> 00:30.030
所以你可以说这不是任何对象,

00:30.030 --> 00:39.490
这是一个必须具有这些属性的对象, 或者必须基于这个或那个构造函数的对象｡

00:39.490 --> 00:41.322
但我们会一步一步来的｡ 

00:41.322 --> 00:49.770
为了深入研究对象, 我将首先重命名app｡  我将把它重命名为basics｡

00:49.770 --> 00:49.770
在这里｡ 

00:49.770 --> 00:55.400
并添加一个新的应用程序｡  ts文件, 然后它将覆盖旧的应用程序｡

00:55.400 --> 00:55.400
js文件,

00:55.400 --> 00:58.600
我们现在可以在其中深入研究对象｡

00:58.600 --> 01:01.110
让我们从创建一个基本对象开始,

01:01.110 --> 01:03.902
比如一个带花括号的人｡

01:03.902 --> 01:05.870
我们给它起个名字｡ 

01:05.870 --> 01:08.230
在这里, 我会用马克西米利安,

01:08.230 --> 01:10.700
因为这是我的名字和30岁｡

01:10.700 --> 01:14.930
现在, 我们当然可以聊以自慰了｡  如果我们这样做,

01:14.930 --> 01:24.536
并编译它, 我们应该会看到对象在控制台中打印出来｡

01:24.536 --> 01:27.284
在JavaScript中,

01:27.284 --> 01:33.970
我们还可以尝试访问, 比如说, 昵称, 一个不存在的属性.

01:33.970 --> 01:37.320
现在, 您可以立即看到TypeScript对此不太满意,

01:37.320 --> 01:39.820
因此我的IDE告诉我｡

01:39.820 --> 01:44.050
它告诉我该类型上不存在属性昵称｡

01:44.050 --> 01:49.907
所以如果我们保存它, 然后编译它, 我们确实会得到同样的错误｡

01:49.907 --> 01:52.210
TypeScript编译器不喜欢这样,

01:52.210 --> 01:56.430
它告诉我, 我们在这个对象上没有nickname属性｡

01:56.430 --> 01:59.813
它发现我们没有这个昵称属性, 因为如果我们把鼠标悬停在它推断的person上,

01:59.813 --> 02:07.970
我们可以看到person后面有一个冒号, 所以在变量或常量名称后面｡

02:07.970 --> 02:12.110
它推断这是存储在那里的数据类型｡

02:12.110 --> 02:14.181
这不仅仅是物体, 你可以看出来｡ 

02:14.181 --> 02:16.349
那是一个具体的物体｡ 

02:16.349 --> 02:18.920
它是一个带有名称键的对象,

02:18.920 --> 02:21.430
而类型必须是字符串.

02:21.430 --> 02:24.700
和年龄键, 其中类型必须是数字｡ 

02:24.700 --> 02:27.116
事实上, 这可能会让人困惑｡ 

02:27.116 --> 02:31.100
这里的这个看起来很像JavaScript对象｡ 

02:31.100 --> 02:33.980
大括号､ 键值对｡ 

02:33.980 --> 02:38.520
首先要注意的是每行后面都有分号｡

02:38.520 --> 02:40.580
我们在JavaScript对象中没有这个｡ 

02:40.580 --> 02:41.750
这里有个逗号｡ 

02:41.750 --> 02:44.160
事实上, 这不是一个JavaScript对象,

02:44.160 --> 02:45.940
它是在某个地方创建的｡

02:45.940 --> 02:50.600
这是由TypeScript推断的对象类型,

02:50.600 --> 02:53.914
对象类型几乎像对象一样编写,

02:53.914 --> 02:59.239
但当然这里没有键值对, 而是键类型对｡

02:59.239 --> 03:06.064
对象类型是用来描述在某个地方使用的对象类型的｡

03:06.064 --> 03:07.653
我们可以更普通一点｡ 

03:07.653 --> 03:13.640
我可以在这里显式地将一个类型赋值给object的常量｡

03:13.640 --> 03:17.460
Object是内置类型之一, 就像number和string一样,

03:17.460 --> 03:21.030
如果我将鼠标悬停在它上面, 我们会看到类型为object的person,

03:21.030 --> 03:26.430
现在TypeScript只关心这是一个对象类型｡

03:26.430 --> 03:28.423
现在, 我们仍然编译这个,

03:28.423 --> 03:32.808
我们得到了这个错误, 因为TypeScript仍然分析我们的代码,

03:32.808 --> 03:36.666
发现我们试图访问不存在的东西, 但是重要的是要理解,

03:36.666 --> 03:42.140
这一切都是从这个最通用的对象类型开始的｡

03:42.140 --> 03:44.660
但通常你想说得更具体一些｡ 

03:44.660 --> 03:47.623
您不只是想使用通用对象类型｡ 

03:47.623 --> 03:50.284
你真想得到全力支持｡ 

03:50.284 --> 03:53.550
例如, 现在, 如果我在这里添加一个点, 然后查看我的自动完成,

03:53.550 --> 03:58.080
我的IDE根本不会提供任何帮助｡

03:58.080 --> 04:00.303
原因是, 我们告诉IDE的只是我们在这里有一个值,

04:00.303 --> 04:05.860
该值的类型是object｡

04:05.860 --> 04:08.300
实际上, 如果我尝试访问name,

04:08.300 --> 04:10.210
我们也会得到一个错误｡

04:10.210 --> 04:12.270
名字在这里, 对不对？

04:12.270 --> 04:14.120
但是我们在这里告诉TypeScript的是,

04:14.120 --> 04:18.889
我们只有一个对象, 在这个对象中, 我们不向TypeScript提供任何信息｡

04:18.889 --> 04:21.739
所以实际上, TypeScript不支持任何类型的属性,

04:21.739 --> 04:26.210
因为我们不告诉它任何关于对象的信息｡

04:26.210 --> 04:28.050
所以我们应该说得更具体些｡ 

04:28.050 --> 04:32.000
通过设置特定的对象类型, 我们可以更加具体｡ 

04:32.000 --> 04:34.795
TypeScript也自动推断出的东西｡ 

04:34.795 --> 04:43.370
我们通过在冒号后面､ 常量或变量名后面添加大括号来实现这一点｡

04:43.370 --> 04:46.213
所以这里并没有创建一个新的JavaScript对象｡ 

04:46.213 --> 04:50.310
这实际上将从编译的JavaScript代码中剥离出来｡

04:50.310 --> 04:55.855
相反, 这只是TypeScript的一种特殊对象类型的表示法｡

04:55.855 --> 05:01.434
因此, 对于对象类型, 我们提供了有关对象结构的一些信息｡

05:01.434 --> 05:04.520
现在, 通过将一对空的花括号赋值为一个类型,

05:04.520 --> 05:07.440
我们基本上与object的操作相同｡

05:07.440 --> 05:09.765
我们告诉TypeScript这是某个对象｡ 

05:09.765 --> 05:12.740
现在我们可以更具体地说｡ 

05:12.740 --> 05:16.550
我们可以在这里添加键值条目, 但不是键值,

05:16.550 --> 05:19.694
而是键类型｡

05:19.694 --> 05:25.091
因此, 这里我们可以说, 应该存储在person中的对象应该有一个name属性,

05:25.091 --> 05:31.140
该name属性的值应该是string类型｡

05:31.140 --> 05:36.440
因此, 这里我们描述了最终将存储在name中的值的类型｡

05:36.440 --> 05:39.320
顺便说一句, 这里有个错误.

05:39.320 --> 05:43.489
因为我现在告诉TypeScript的是我的人应该有一个对象,

05:43.489 --> 05:45.900
只有一个键值对, 其中键是名称,

05:45.900 --> 05:52.730
键的值是字符串, 但是我们没有给一个对象分配两个键值对｡

05:52.730 --> 05:55.020
名字, 它包含一个字符串, 这是好的,

05:55.020 --> 05:58.500
但年龄, 它包含一个数字, 这将是不好的｡

05:58.500 --> 06:01.140
所以这里我们必须调整一下, 添加一个分号,

06:01.140 --> 06:06.300
然后添加另一个键值对, 这里我们说年龄应该是数字类型｡

06:06.300 --> 06:09.670
所以这里不是30, TypeScript实际上支持30,

06:09.670 --> 06:12.673
我们将其限制为一个特定的数字, 但一旦我们改变它,

06:12.673 --> 06:15.600
就会遇到问题｡

06:15.600 --> 06:19.060
相反, 在这里我只想说年龄应该是一些数字｡ 

06:19.060 --> 06:24.870
现在, 我们基本上是显式地分配之前推断的相同TypeScript｡

06:24.870 --> 06:26.900
正如您所了解到的, 这不是一个好的实践,

06:26.900 --> 06:29.940
但为了理解对象类型, 我希望在这里进行此操作｡

06:29.940 --> 06:32.315
不过, 这是你可以做的事情｡ 

06:32.315 --> 06:37.010
最好让TypeScript像我们以前做的那样来推断它,

06:37.010 --> 06:40.440
就像这样｡

06:40.440 --> 06:42.351
现在, 为了展示一些有趣的东西,

06:42.351 --> 06:49.920
如果我切换回这些次优代码, 在那里我们显式地分配一个类型, TypeScript将能够推断,

06:49.920 --> 06:54.920
如果我们编译这些代码, 它当然会工作｡

06:55.180 --> 06:59.077
我们可以访问name属性, 但如果我们随后查看app｡

06:59.077 --> 06:59.077
js我们看到这个类型赋值在这里被删除了｡

07:01.220 --> 07:03.417
当然, 这应该是意料之中的事情｡ 

07:03.417 --> 07:08.120
正如我提到的, 类型和类型赋值不是JavaScript的一部分｡

07:08.120 --> 07:09.460
它们只是TypeScript｡ 

07:09.460 --> 07:10.800
我只是想再演示一遍, 让大家清楚地知道,

07:10.800 --> 07:12.840
这里的语法并不是在创建JavaScript对象,

07:12.840 --> 07:16.485
而是在代码中的某个地方｡

07:16.485 --> 07:25.900
这只是TypeScript对对象类型的表示, 它有助于TypeScript理解您正在使用的对象｡

07:25.900 --> 07:29.950
当然, 更好的语法是这个语法, 正如你所学到的｡ 
