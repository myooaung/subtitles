WEBVTT

00:00.000 --> 00:02.410
(stilte) -: We zien dus al hoe TypeScript

00:02.410 --> 00:04.190
ons kan helpen tijdens de

00:04.190 --> 00:06.200
ontwikkeling.

00:06.200 --> 00:10.560
Nu weten we ook dat er een getalstype is in JavaScript.

00:10.560 --> 00:14.010
En we kunnen het zien met het ingebouwde type operator.

00:14.010 --> 00:15.781
Dit is nu niet TypeScript specifiek,

00:15.781 --> 00:17.560
dit is een ingebouwde operator en

00:17.560 --> 00:20.420
sleutelwoord ondersteund door JavaScript.

00:20.420 --> 00:22.910
We kunnen het gebruiken om het type van een bepaalde waarde te krijgen.

00:22.910 --> 00:27.050
Dus hier, kunnen we de console type nummer een.

00:27.050 --> 00:27.992
En wat we zullen zien

00:27.992 --> 00:30.780
als we dat doen is dat zodra we dit compileren, zodat we

00:30.780 --> 00:32.623
de bijgewerkte code uitvoeren.

00:33.780 --> 00:37.040
Hier drukken we het nummer af op de console.

00:37.040 --> 00:39.330
Nu doen we dat, dankzij deze uitvoer hier, en dankzij

00:39.330 --> 00:41.180
het type operator en in Vanilla JavaScript,

00:41.180 --> 00:43.770
zonder TypeScript, zouden we dat kunnen gebruiken

00:43.770 --> 00:46.710
om onze functie hier steeds te verbeteren.

00:46.710 --> 00:51.500
We kunnen controleren of het type getal gelijk is aan getal.

00:51.500 --> 00:54.300
Pardon, type n1 bedoel ik, als dat gelijk

00:54.300 --> 00:56.350
is aan getal, en we kunnen

00:56.350 --> 01:00.710
ook controleren of type n2 gelijk is aan getal.

01:00.710 --> 01:02.349
en onze bewerking hier alleen

01:02.349 --> 01:05.220
uitvoeren als het een anders gegooide fout is,

01:05.220 --> 01:07.860
of het omgekeerde doen en controleren of het

01:07.860 --> 01:10.820
niet gelijk is, of als n2 niet gelijk is.

01:10.820 --> 01:13.230
En als een van de twee geen getal is,

01:13.230 --> 01:16.360
dan kunnen we een nieuwe foutmelding geven:

01:16.360 --> 01:19.690
onjuiste invoer. Dit zou eigenlijk een niet TypeScript

01:19.690 --> 01:22.300
manier zijn om ervoor te zorgen dat we deze functie

01:22.300 --> 01:25.700
niet kunnen aanroepen met een string hier.

01:25.700 --> 01:26.760
Als ik dit nu doe, en ik

01:26.760 --> 01:29.060
hercompileer, krijgen we onze TypeScript-fout,

01:29.060 --> 01:30.830
maar die negeren we nu even.

01:30.830 --> 01:31.730
Als we dit opnieuw

01:31.730 --> 01:33.100
uitvoeren, krijgen we de verkeerde

01:33.100 --> 01:34.940
invoer, die we zelf gooien.

01:34.940 --> 01:38.080
Dus nu hebben we disfunctie verhard in JavaScript, het

01:38.080 --> 01:39.930
faalt tijdens runtime, maar falen

01:39.930 --> 01:41.970
is hier misschien beter dan een onjuiste

01:41.970 --> 01:44.950
uitvoer tonen die we voorheen hadden.

01:44.950 --> 01:47.640
Dus dit zou een manier zijn om de invoer te controleren in

01:47.640 --> 01:48.715
gewoon JavaScript.

01:48.715 --> 01:50.640
Daar heb je TypeScript niet voor nodig.

01:50.640 --> 01:53.200
Dat is gewone JavaScript code.

01:53.200 --> 01:54.033
Maar deze aanpak heeft

01:54.033 --> 01:55.160
natuurlijk nadelen.

01:55.160 --> 01:57.160
Soms is dat het juiste om te doen.

01:57.160 --> 02:01.440
Soms kun je alleen bepaalde inputs tijdens runtime valideren.

02:01.440 --> 02:03.150
Maar het nadeel is dat we hier

02:03.150 --> 02:05.480
iets controleren dat we eigenlijk kunnen

02:05.480 --> 02:08.950
vermijden tijdens de ontwikkeling met TypeScript.

02:08.950 --> 02:11.180
Dus ja, we gooien een fout.

02:11.180 --> 02:14.210
En in onze toepassing hebben we misschien maatregelen ingebouwd

02:14.210 --> 02:16.860
die terug kunnen vallen op een ander gedrag om de lopende

02:16.860 --> 02:19.080
toepassing te redden.

02:19.080 --> 02:20.750
Maar toch gooien we een

02:20.750 --> 02:24.180
fout, die eigenlijk helemaal niet nodig is.

02:24.180 --> 02:27.350
We hadden het kunnen voorkomen met TypeScript.

02:27.350 --> 02:28.830
En hier zien we echt het verschil

02:28.830 --> 02:30.400
tussen JavaScript en TypeScript,

02:30.400 --> 02:31.450
als het gaat om types.

02:31.450 --> 02:33.750
JavaScript is dynamisch getypeerd, wat

02:33.750 --> 02:35.610
betekent dat het prima is dat we een

02:35.610 --> 02:36.880
variabele hebben die aanvankelijk

02:36.880 --> 02:39.100
een getal kan bevatten, waar we later een

02:39.100 --> 02:41.600
string aan toekennen.

02:41.600 --> 02:44.500
En dat is waarom we de type off operator moeten gebruiken,

02:44.500 --> 02:48.024
zodat we tijdens runtime het huidige type van iets kunnen controleren

02:48.024 --> 02:50.124
als we code hebben die afhankelijk is

02:50.124 --> 02:52.267
van een bepaald type.

02:52.267 --> 02:53.570
TypeScript daarentegen

02:53.570 --> 02:55.094
is statisch getypeerd,

02:55.094 --> 02:58.480
wat betekent dat we de types van variabelen en parameters

02:58.480 --> 03:01.740
definiÃ«ren tijdens de ontwikkeling, ze veranderen

03:01.740 --> 03:04.980
niet plots tijdens runtime.

03:04.980 --> 03:05.813
Aangezien TypeScript

03:05.813 --> 03:09.090
is gecompileerd naar JavaScript, zou dat theoretisch

03:09.090 --> 03:10.660
wel kunnen.

03:10.660 --> 03:12.510
Maar als we TypeScript gebruiken,

03:12.510 --> 03:13.790
en we schrijven code waar

03:13.790 --> 03:17.530
we plotseling een nieuw type gegevens toewijzen aan een variabele,

03:17.530 --> 03:18.810
waar we eerder zeiden dat

03:18.810 --> 03:19.840
dit bijvoorbeeld

03:19.840 --> 03:22.900
een getal moest zijn, en nu wijzen we een string toe, dan

03:22.900 --> 03:25.810
krijgen we een foutmelding tijdens de ontwikkeling,

03:25.810 --> 03:27.480
zodat we gedwongen worden duidelijk

03:27.480 --> 03:29.670
te zijn over de types, iets wel of niet kunnen

03:29.670 --> 03:32.120
houden.

03:32.120 --> 03:33.710
Dat is het verschil hier.

03:33.710 --> 03:36.620
Dus we willen eigenlijk geen implementaties of dergelijke

03:36.620 --> 03:38.330
oplossingen gebruiken, als we het

03:38.330 --> 03:40.810
kunnen vermijden met TypeScript.

03:40.810 --> 03:42.200
Toch is het belangrijk

03:42.200 --> 03:43.890
te weten dat JavaScript natuurlijk

03:43.890 --> 03:46.400
het concept van types kent.

03:46.400 --> 03:48.740
Het kent enkele types zoals getallen,

03:48.740 --> 03:50.640
string en Boolean.

03:50.640 --> 03:52.300
Maar dat betekent altijd

03:52.300 --> 03:53.540
dat we alleen tijdens

03:53.540 --> 03:56.400
runtime kunnen falen in plaats van tijdens

03:56.400 --> 03:58.700
de ontwikkeling.

03:58.700 --> 04:01.550
Zo kunnen we bugs eerder oplossen.

04:01.550 --> 04:02.840
En bovendien kent

04:02.840 --> 04:05.410
JavaScript maar een paar types.

04:05.410 --> 04:07.170
Zoals je in deze cursus zult leren.

04:07.170 --> 04:10.540
TypeScript kent veel meer types dan JavaScript.

04:10.540 --> 04:14.450
Dus is runtime checking echt niet zo flexibel of niet zo

04:14.450 --> 04:18.030
krachtig als wat we met TypeScript kunnen doen.

04:18.030 --> 04:19.490
En om al deze redenen is deze aanpak

04:19.490 --> 04:20.660
eigenlijk niet de aanpak

04:20.660 --> 04:22.550
die we hier willen gebruiken.

04:22.550 --> 04:26.540
Soms kan het nuttig zijn om het type op runtime te krijgen.

04:26.540 --> 04:28.790
Maar soms, zoals in dit voorbeeld, is het veel

04:28.790 --> 04:31.740
beter om het tijdens de ontwikkeling te krijgen.

04:31.740 --> 04:34.280
Het enige belangrijke om te erkennen is natuurlijk

04:34.280 --> 04:36.070
dat je met TypeScript alleen ondersteuning

04:36.070 --> 04:39.596
krijgt tijdens de ontwikkeling, niet tijdens runtime, omdat deze

04:39.596 --> 04:41.610
TypeScript functies en controles niet

04:41.610 --> 04:44.650
zijn ingebouwd in de JavaScript engine zodat de logica niet

04:44.650 --> 04:47.590
kan worden uitgevoerd in de browser, maar alleen tijdens

04:47.590 --> 04:49.416
de ontwikkeling wanneer je je code

04:49.416 --> 04:51.223
compileert.
