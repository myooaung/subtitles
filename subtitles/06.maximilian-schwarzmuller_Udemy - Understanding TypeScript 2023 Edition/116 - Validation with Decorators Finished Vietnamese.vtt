WEBVTT

00:02.320 --> 00:05.210
Người hướng dẫn: Để thực hiện điều này, trước hết

00:05.210 --> 00:08.217
tôi sẽ tạo một giao diện ValidatorConfig, nơi tôi

00:09.550 --> 00:12.680
muốn định cấu hình bộ lưu trữ mà tôi muốn làm việc.

00:12.680 --> 00:15.130
Ý tưởng của tôi là có một vài thuộc tính và do

00:15.130 --> 00:17.653
đó tôi sử dụng ký hiệu loại chỉ mục này ở đây.

00:19.720 --> 00:21.450
Về cơ bản là các chuỗi, trong

00:21.450 --> 00:23.440
đó giá trị là một đối tượng khác.

00:23.440 --> 00:26.380
Bởi vì đây về cơ bản sẽ là tên lớp mà chúng tôi muốn

00:26.380 --> 00:29.570
đăng ký một số thuộc tính đã được xác thực.

00:29.570 --> 00:31.700
Và sau đó trong đối tượng mà chúng tôi lưu

00:31.700 --> 00:34.580
trữ ở đó, chúng tôi có các thuộc tính cụ thể của lớp có các

00:34.580 --> 00:37.010
trình xác thực được đính kèm với chúng.

00:37.010 --> 00:40.610
Vì vậy, ở đây chúng ta có thuộc tính có thể xác thực, nếu

00:40.610 --> 00:42.240
bạn muốn gọi nó như thế này,

00:42.240 --> 00:44.660
đây cũng sẽ là một khóa chuỗi.

00:44.660 --> 00:47.350
Và sau đó, giá trị cho điều đó phải là một

00:47.350 --> 00:50.010
mảng các chuỗi mà về cơ bản chúng ta có

00:52.420 --> 00:55.490
một số thứ như bắt buộc, tích cực, v.v.

00:55.490 --> 00:57.460
Vì vậy, một cái gì đó như thế có thể được thêm vào

00:57.460 --> 00:59.323
đây như một danh sách các trình xác nhận.

01:00.300 --> 01:05.300
Bây giờ chúng ta có thể tạo cấu hình đã đăng kýValidators của mình tại đây, cấu hình này phải

01:05.790 --> 01:07.950
thuộc loại ValidatorConfig mà ban đầu

01:07.950 --> 01:09.640
là một đối tượng trống.

01:09.640 --> 01:11.500
Bởi vì ban đầu khi ứng dụng bắt đầu

01:11.500 --> 01:13.920
khi thư viện bên thứ ba của chúng tôi được tải,

01:13.920 --> 01:16.293
chưa có trình xác thực nào được đăng ký.

01:17.640 --> 01:19.920
Chà, và sau đó ở đây trong các giám đốc của

01:19.920 --> 01:23.490
chúng tôi, chúng tôi muốn thêm một cái gì đó vào sổ đăng ký đó.

01:23.490 --> 01:28.020
Bây giờ, hãy nhớ rằng một hàm trang trí thuộc tính

01:28.020 --> 01:31.010
có hai đối số: đích, là nguyên mẫu

01:31.010 --> 01:33.910
của đối tượng chứa thuộc tính hoặc

01:33.910 --> 01:37.340
hàm tạo nếu nó là một thuộc tính tĩnh và

01:37.340 --> 01:39.300
tên thuộc tính.

01:39.300 --> 01:40.710
Đây là hai đối số chúng tôi

01:40.710 --> 01:44.370
nhận được ở đây, chúng tôi không nhận được mô tả cho các thuộc tính.

01:44.370 --> 01:46.760
Bây giờ chúng tôi có thể truy cập trình xác nhận đã đăng ký

01:46.760 --> 01:51.463
của mình và ở đó tôi muốn thêm một mục mới cho mục tiêu. người xây dựng.

01:52.730 --> 01:56.070
Nguyên mẫu của thể hiện mà chúng ta đang làm

01:56.070 --> 01:58.430
việc sẽ có một khóa hàm tạo trỏ đến

01:58.430 --> 02:02.610
hàm tạo được sử dụng để tạo đối tượng của chúng ta.

02:02.610 --> 02:04.690
Và do đó, về cơ bản sẽ giống như

02:04.690 --> 02:06.120
khóa học ở đây, vì vậy

02:06.120 --> 02:08.460
tên của hàm tạo đó cuối cùng có thể

02:08.460 --> 02:10.560
được truy xuất từ hàm tạo đó.

02:10.560 --> 02:11.900
Bởi vì hàm tạo là một hàm

02:11.900 --> 02:13.400
nên chúng ta có thể sử dụng

02:13.400 --> 02:15.900
thuộc tính tên tồn tại trên bất kỳ hàm nào

02:15.900 --> 02:18.310
trong JavaScript để lấy tên hàm và đây sẽ

02:18.310 --> 02:20.620
là tên khóa học ở đây chẳng hạn.

02:20.620 --> 02:23.390
Vì vậy, bây giờ chúng tôi đăng ký tên lớp làm khóa trong

02:23.390 --> 02:25.030
trình xác thực đã đăng ký.

02:25.030 --> 02:28.130
Và giá trị cho điều đó sau đó phải là một đối tượng khác.

02:28.130 --> 02:30.630
Vì vậy, tôi đặt đối tượng này bằng đối tượng khác ở đây.

02:30.630 --> 02:32.390
Và trong đối tượng đó, tôi cũng

02:32.390 --> 02:34.640
có một thuộc tính được gán động nơi tôi

02:34.640 --> 02:37.400
sử dụng propName của mình, vì vậy thuộc tính mà

02:37.400 --> 02:40.190
tôi muốn thêm trình xác thực làm khóa.

02:40.190 --> 02:42.310
Bây giờ giá trị ở đây là một mảng các chuỗi

02:42.310 --> 02:45.530
và ở đây tôi sẽ thêm yêu cầu dưới dạng một chuỗi.

02:45.530 --> 02:47.920
Tất nhiên, đây là một trình xác thực rất ngây thơ.

02:47.920 --> 02:50.000
Nếu chúng tôi đã có những trình xác thực khác đã

02:50.000 --> 02:52.830
đăng ký cho thuộc tính này, thì bây giờ tôi sẽ ghi đè lên nó ở đây.

02:52.830 --> 02:54.900
Vì vậy, sẽ tốt hơn nếu trước tiên truy

02:54.900 --> 02:58.360
xuất bất kỳ trình xác thực hiện có nào, sau đó sao chép chúng vào

02:58.360 --> 03:01.320
mảng này và chỉ thêm bắt buộc vào mảng hiện có đó.

03:01.320 --> 03:02.870
Một lần nữa, để tiết kiệm thời gian

03:02.870 --> 03:04.740
ở đây và để chỉ ra ý tưởng chung, tôi sẽ

03:04.740 --> 03:06.873
có cách tiếp cận ngây thơ hơn ở đây.

03:07.980 --> 03:11.180
Tuy nhiên, với điều đó, chúng tôi đã nhận được chú thích cần

03:11.180 --> 03:14.690
thiết, bây giờ chúng ta hãy làm việc với chú thích số dương.

03:14.690 --> 03:16.730
Và tất nhiên, về cơ bản là giống nhau.

03:16.730 --> 03:21.410
Tôi sao chép mã đó nhưng tôi đặt mã này ở đây thành dương hoặc bất kỳ số nhận dạng

03:21.410 --> 03:23.600
nào bạn muốn sử dụng và tất nhiên chúng

03:23.600 --> 03:25.010
tôi phải đảm bảo rằng chúng

03:25.010 --> 03:27.650
tôi chấp nhận các đối số đúng.

03:27.650 --> 03:30.990
Vì vậy, cùng với điều này, những gì chúng tôi đã thêm cho đến

03:30.990 --> 03:34.420
nay, chúng tôi đăng ký các thuộc tính này và trình xác thực của

03:34.420 --> 03:38.640
chúng trong cấu hình toàn cầu của chúng tôi khi lớp này được xác định.

03:38.640 --> 03:41.460
Bây giờ chúng ta chỉ cần làm việc với chức năng xác thực.

03:41.460 --> 03:43.400
Hàm xác thực phải đi qua tất cả các

03:43.400 --> 03:46.240
trình xác thực đã đăng ký, sau đó về cơ bản sẽ chạy

03:46.240 --> 03:50.340
logic khác nhau dựa trên trình xác thực mà nó tìm thấy.

03:50.340 --> 03:54.857
Vì vậy, ở đây trước hết tôi muốn truy xuất cấu hình cho đối tượng

03:54.857 --> 03:57.600
cụ thể mà chúng ta đang xử lý.

03:57.600 --> 04:00.390
Để làm được điều đó, chúng ta cần tìm ra hàm tạo

04:00.390 --> 04:04.277
mà đối tượng dựa trên và sau đó lấy cấu hình xác thực hoặc ánh xạ

04:04.277 --> 04:07.040
trình xác thực thuộc tính ở đây mà chúng ta đã

04:07.040 --> 04:09.070
thiết lập cho đối tượng đó.

04:09.070 --> 04:11.960
Vì vậy, ở đây tôi sẽ đặt tên cho trình xác thực đối tượng

04:11.960 --> 04:14.520
này hoặc có thể là objValidatorConfig.

04:14.520 --> 04:17.110
Và chúng tôi liên hệ với những người xác thực đã đăng ký tại đây và

04:17.110 --> 04:22.110
truy cập vào một thuộc tính phải là obj. người xây dựng. tên, logic giống như trước đây,

04:23.900 --> 04:27.060
chúng tôi truy cập thuộc tính hàm tạo tồn tại trên nguyên mẫu

04:27.060 --> 04:28.980
của đối tượng và do đó chúng tôi có thể

04:28.980 --> 04:31.720
truy cập nó trực tiếp trên đối tượng nhờ cách JavaScript

04:31.720 --> 04:33.340
hoạt động và nhờ vào chuỗi nguyên

04:33.340 --> 04:35.050
mẫu, sau đó chúng tôi sẽ tiếp cận

04:35.050 --> 04:36.710
nguyên mẫu nếu chúng ta không thể

04:36.710 --> 04:38.920
tìm thấy thuộc tính hàm tạo trên chính đối

04:38.920 --> 04:41.580
tượng và điều đó sẽ hoạt động.

04:41.580 --> 04:43.840
Và do đó, bây giờ chúng tôi đã có tên hàm

04:43.840 --> 04:46.970
tạo và chúng tôi phát hiện ra rằng, ví dụ, Khóa học này

04:46.970 --> 04:49.050
ở đây dựa trên lớp Khóa học này.

04:49.050 --> 04:51.290
Vì vậy, chúng tôi tra cứu bất kỳ cấu hình trình xác thực

04:51.290 --> 04:52.800
nào mà chúng tôi có cho lớp Khóa học.

04:52.800 --> 04:55.910
Vì vậy, bây giờ chúng tôi đang xem xét đối tượng này, về cơ bản.

04:55.910 --> 04:58.207
Điều này hiện có trong objValidatorConfig.

04:59.310 --> 05:01.540
Tất nhiên, bây giờ chúng tôi có thể không tìm thấy điều

05:01.540 --> 05:03.270
này nếu chúng tôi đang cố xác thực đối tượng

05:03.270 --> 05:05.110
của mình mà không có gì được đăng ký.

05:05.110 --> 05:08.270
Vì vậy, nếu chúng tôi không có bất kỳ cấu hình trình xác thực

05:08.270 --> 05:11.640
nào, nếu chúng tôi không tìm thấy gì ở đó, tôi muốn trả về true vì

05:11.640 --> 05:14.010
điều này chắc chắn là hợp lệ, phải không?

05:14.010 --> 05:15.330
Không có gì để xác nhận,

05:15.330 --> 05:18.350
vì vậy đối tượng chắc chắn là hợp lệ.

05:18.350 --> 05:20.900
Mặt khác, nếu chúng ta tìm thấy nó, tôi muốn

05:20.900 --> 05:24.910
nó lặp qua đối tượng bên trong này ở đây với vòng lặp for in.

05:24.910 --> 05:27.580
Vì vậy, tôi lặp qua các thuộc tính mà tôi

05:27.580 --> 05:29.560
đã đăng ký trình xác thực, với

05:29.560 --> 05:33.007
const prop trong objValidatorConfig.

05:34.380 --> 05:36.950
Điều này cho phép tôi truy cập vào tất cả các tên thuộc

05:36.950 --> 05:39.630
tính mà sau đó chúng tôi có thể có trình xác thực.

05:39.630 --> 05:41.180
Vì vậy, tất nhiên bây giờ tôi cần xem qua

05:41.180 --> 05:43.970
tất cả các trình xác thực mà chúng tôi có thể có đối với một thuộc tính.

05:43.970 --> 05:45.230
Đây luôn phải là một mảng ngay

05:45.230 --> 05:47.680
cả khi chúng ta chỉ thêm một trình xác thực.

05:47.680 --> 05:49.530
Vì vậy, chúng ta có thể sử dụng vòng

05:49.530 --> 05:53.040
lặp for ở đây ngay bây giờ và lấy trình xác thực cụ thể mà chúng

05:53.040 --> 05:56.930
ta có, cho objValidatorConfig cho thuộc tính đã cho này.

05:56.930 --> 06:00.560
Vì vậy, bây giờ chúng tôi đang nhận được những thứ như tích cực hoặc bắt buộc,

06:00.560 --> 06:02.963
được lưu trữ trong hằng số trình xác thực.

06:04.080 --> 06:06.110
Và sau đó chúng ta có thể có một câu lệnh chuyển đổi

06:06.110 --> 06:08.030
ở đây, hoặc tất nhiên là gọi các hàm bên ngoài dựa

06:08.030 --> 06:09.810
trên trình xác thực mà chúng ta tìm thấy.

06:09.810 --> 06:12.130
Nhưng ở đây tôi sẽ sử dụng một câu lệnh chuyển

06:12.130 --> 06:16.620
đổi tích hợp sẵn, bật trình xác thực và sau đó về cơ bản có các trường hợp khác nhau.

06:16.620 --> 06:19.683
Ví dụ, trường hợp bắt buộc ở đây.

06:20.800 --> 06:22.163
Rất tiếc, như thế này.

06:23.470 --> 06:27.900
Ở đây, tôi muốn trả về true nếu tài sản của chúng tôi, mà chúng tôi đang

06:27.900 --> 06:28.950
xem xét...

06:28.950 --> 06:33.260
Vì vậy, thuộc tính này trên đối tượng này có giá trị không trống.

06:33.260 --> 06:38.260
Vì vậy, tôi sẽ trả về true nếu obj prop là true.

06:39.170 --> 06:42.010
Và để chuyển đổi giá trị này thành giá trị true hoặc false thực,

06:42.010 --> 06:44.420
chúng ta có thể sử dụng toán tử double bang.

06:44.420 --> 06:46.840
Bây giờ tôi nghe nhiều loại phàn nàn rằng nó không biết

06:46.840 --> 06:49.440
liệu đối tượng có thuộc tính này hay không, vì vậy ở đây

06:49.440 --> 06:51.220
chúng ta thực sự nên thay đổi điều này

06:51.220 --> 06:53.560
thành bất kỳ để có thêm tính linh hoạt ở đây.

06:53.560 --> 06:56.150
Tất nhiên bạn cũng có thể làm việc với các loại ở đây.

06:56.150 --> 07:00.480
Và ví dụ: cũng biến các số nhận dạng của bạn ở đây thành các loại được xác

07:00.480 --> 07:03.430
định rõ ràng nơi Enums bạn làm việc và cũng có thể

07:03.430 --> 07:05.490
cải thiện việc nhập ở đây.

07:05.490 --> 07:07.420
Mặc dù, thành thật mà nói, vì tôi muốn điều này

07:07.420 --> 07:09.960
hoạt động với bất kỳ đối tượng nào, nên thật khó để cải thiện điều

07:09.960 --> 07:11.810
này theo cách mà TypeScript sẽ thích.

07:11.810 --> 07:13.330
Chúng ta có thể làm việc với

07:13.330 --> 07:16.800
các kiểu chung chung nhưng sau đó, một lần nữa chúng ta sẽ cần

07:16.800 --> 07:19.740
loại giới hạn bản thân đối với những đối tượng mà các

07:19.740 --> 07:22.110
kiểu chung sẽ mở rộng và do đó chấp nhận.

07:22.110 --> 07:25.850
Vì vậy, bất kỳ có thể là lựa chọn tốt nhất của chúng tôi ở đây để thực

07:25.850 --> 07:27.880
sự linh hoạt và chấp nhận nhiều đối tượng

07:27.880 --> 07:30.640
khác nhau trong chức năng xác thực này.

07:30.640 --> 07:32.270
Bây giờ quay lại phân đoạn chuyển đổi,

07:32.270 --> 07:34.750
trường hợp bắt buộc là một trường hợp có thể xảy ra, chúng

07:34.750 --> 07:37.650
tôi cũng có trường hợp tích cực mà chúng tôi muốn xử lý.

07:37.650 --> 07:39.280
Và ở đó tôi muốn trả

07:39.280 --> 07:43.770
về true nếu thuộc tính chúng ta đang xem lớn hơn 0.

07:43.770 --> 07:47.260
Vì vậy, nếu prop đối tượng lớn hơn 0, thì điều này trả

07:47.260 --> 07:50.463
về true, nếu không, điều này sẽ trả về false.

07:52.890 --> 07:55.730
Bây giờ nếu chúng ta không đưa nó vào khối for này hoặc

07:55.730 --> 07:57.970
nếu bằng cách nào đó chúng ta có một vòng

07:57.970 --> 07:59.310
lặp không lặp qua bất kỳ

07:59.310 --> 08:01.500
thứ gì vì chúng ta chưa đăng ký bất kỳ trình

08:01.500 --> 08:04.130
xác thực nào, thì chúng ta đã chuyển một mảng trống

08:04.130 --> 08:06.350
ở đây hoặc thứ gì đó, vì vậy nếu bạn vượt qua

08:06.350 --> 08:10.280
vòng lặp for này, tôi cũng sẽ trả về true như mặc định.

08:10.280 --> 08:12.800
Và bây giờ chúng tôi trả lại một cái gì đó trong mọi trường hợp

08:12.800 --> 08:14.503
và chúng tôi có thể sử dụng xác thực.

08:15.450 --> 08:19.253
Với điều đó, hãy xem liệu nó có hoạt động hay không, nếu bây giờ chúng tôi lưu ứng dụng này và chúng

08:23.610 --> 08:26.330
tôi tải lại ứng dụng của mình tại đây và tôi cố gắng gửi ứng dụng này

08:26.330 --> 08:29.400
thì chúng tôi gặp lỗi, thông tin nhập không hợp lệ, vui lòng thử lại.

08:29.400 --> 08:30.780
Nếu tôi nhập một số văn

08:30.780 --> 08:34.793
bản ở đây: Hướng dẫn đầy đủ về JavaScript, tôi vẫn nhận được

08:35.940 --> 08:38.100
nội dung này vì số của tôi sai.

08:38.100 --> 08:40.440
Nếu tôi nhập trừ một vào đây, chúng ta cũng nhận được

08:40.440 --> 08:42.020
giá trị này vì nó không dương.

08:42.020 --> 08:45.020
Tuy nhiên, nếu tôi nhập một số dương, nó hoạt động.

08:45.020 --> 08:48.230
Nếu tôi có một số dương nhưng trường đầu tiên trống, thì

08:48.230 --> 08:49.860
điều này cũng hoạt động, vì vậy

08:49.860 --> 08:52.190
đó là điều chúng tôi sẽ phải làm việc.

08:52.190 --> 08:54.600
Vì vậy, hãy tìm hiểu vấn đề là gì.

08:54.600 --> 08:57.380
Và để tìm hiểu, tôi thực sự sẽ thêm một nhật ký giao diện điều

08:57.380 --> 08:59.830
khiển nhỏ ở đây và ghi lại thuộc tính mà chúng tôi đang

08:59.830 --> 09:00.720
xem xét.

09:00.720 --> 09:02.340
Tất nhiên, chúng tôi cũng có thể sử dụng các điểm dừng

09:02.340 --> 09:03.513
và công cụ dành cho nhà phát triển.

09:04.820 --> 09:07.410
Bây giờ nếu tôi nhấp vào lưu ở đây, bạn sẽ thấy điều đầu

09:07.410 --> 09:09.250
tiên được xác thực ở đây là giá và sau

09:09.250 --> 09:10.623
đó chúng tôi dừng lại.

09:11.530 --> 09:15.100
Vì vậy, giá là tài sản đầu tiên được xác nhận.

09:15.100 --> 09:16.980
Và đó là điều thú vị ở đây, giá

09:16.980 --> 09:20.090
thực sự là tài sản duy nhất quan trọng ở đây bởi

09:20.090 --> 09:22.230
vì chúng tôi trả về xác thực.

09:22.230 --> 09:25.840
Điều đó có nghĩa là lần đầu tiên chúng tôi tìm thấy bất kỳ trình xác thực nào

09:25.840 --> 09:29.050
trả về đúng hoặc sai, chúng tôi sẽ ngay lập tức quay lại và chúng tôi

09:29.050 --> 09:31.480
không quan tâm đến các trình xác thực khác.

09:31.480 --> 09:33.320
Bây giờ trong trường hợp sai, điều này

09:33.320 --> 09:35.360
không sao cả vì nếu một phần tử là sai, nếu một

09:35.360 --> 09:37.450
thuộc tính là sai, không hợp lệ, thì chúng ta

09:37.450 --> 09:40.140
thậm chí không cần nhìn vào những phần tử khác.

09:40.140 --> 09:42.590
Nhưng đối với trường hợp thật thì đó là cả một vấn đề.

09:42.590 --> 09:44.970
Nếu chúng tôi trả về đúng lần đầu tiên một

09:44.970 --> 09:49.410
thuộc tính đáp ứng mong đợi của chúng tôi, thì chúng tôi gặp sự cố.

09:49.410 --> 09:51.540
Vì vậy, chúng ta nên tăng cường điều này

09:51.540 --> 09:55.130
bằng cách có thuộc tính isValid ở đây, điều này ban đầu là đúng.

09:55.130 --> 09:56.780
Là biến hợp lệ, ý tôi là.

09:56.780 --> 10:01.780
Và sau đó ở đây chúng ta đặt isValid bằng với isValid và cái

10:03.857 --> 10:08.857
này ở đây, và tương tự ở dưới đây, đặt cái này bằng cái này.

10:09.570 --> 10:11.290
Vì vậy, chúng tôi không quay lại

10:11.290 --> 10:14.750
ngay lập tức, thay vào đó chúng tôi chỉ cập nhật isValid và sau

10:14.750 --> 10:16.700
đó chúng tôi ngắt để không bị lỗi.

10:16.700 --> 10:19.200
Kết quả của điều đó là cuối cùng sau tất

10:19.200 --> 10:22.710
cả các vòng lặp này, isValid vẫn đúng, nhưng ngay khi

10:22.710 --> 10:25.710
một trong các kiểm tra này ở đây là sai, nhờ vào

10:25.710 --> 10:27.530
cách thức hoạt động của JavaScript,

10:27.530 --> 10:29.670
giá trị isValid tổng thể sẽ là sai

10:29.670 --> 10:33.000
vì true kết hợp với false sẽ trả về sai.

10:33.000 --> 10:36.020
Và sau đó ở dưới đó, chúng ta nên trả về isValid.

10:36.020 --> 10:39.330
Vì vậy, bây giờ chúng tôi đảm bảo rằng tất cả các thuộc tính đều được kiểm

10:39.330 --> 10:42.433
tra và không chỉ thuộc tính đầu tiên mà JavaScript xem xét.

10:43.320 --> 10:45.460
Tuy nhiên, đây sẽ không phải là vấn đề duy nhất của

10:45.460 --> 10:47.750
chúng tôi, chúng tôi cũng có một vấn đề ở đây khi chúng

10:47.750 --> 10:50.480
tôi xem cách chúng tôi đăng ký logic trình xác thực của mình.

10:50.480 --> 10:53.720
Tôi luôn ghi đè các trình xác thực đã đăng ký

10:53.720 --> 10:57.130
cho một tên lớp đã cho bằng một đối tượng mới.

10:57.130 --> 11:00.050
Thay vào đó, chúng ta nên thêm bất kỳ trình xác thực hiện có nào vào

11:00.050 --> 11:01.630
đây để chúng ta không làm điều đó.

11:01.630 --> 11:04.140
Ví dụ: chúng tôi có toán tử trải rộng như

11:04.140 --> 11:08.130
vậy để lấy bất kỳ cặp giá trị khóa hiện có nào cho tên lớp đó trên trình

11:08.130 --> 11:10.870
xác thực đã đăng ký và thêm nó trước khi chúng

11:10.870 --> 11:14.413
tôi thêm cặp của mình, tất nhiên cũng ở dưới đó.

11:16.890 --> 11:18.733
Và bây giờ với điều đó, nếu chúng tôi lưu cái

11:19.650 --> 11:21.980
này và chúng tôi quay lại ứng dụng của chúng tôi ở đây.

11:21.980 --> 11:24.150
Nếu tôi có cả hai trống, chúng tôi thất bại.

11:24.150 --> 11:26.280
Nếu chúng tôi nhập một giá hợp lệ nhưng chúng tôi

11:26.280 --> 11:28.490
có một tiêu đề không hợp lệ, chúng tôi sẽ thất bại.

11:28.490 --> 11:31.510
Nếu cả hai đều hợp lệ, chúng tôi thành công.

11:31.510 --> 11:35.570
Nếu chúng tôi có một tiêu đề hợp lệ nhưng không có giá, chúng tôi thất bại.

11:35.570 --> 11:37.230
Ngoài ra với một mức giá tiêu cực.

11:37.230 --> 11:39.170
Và do đó, điều này bây giờ có vẻ tốt đối với

11:39.170 --> 11:42.280
tôi và đây hiện là triển khai ngây thơ đầu tiên của chúng tôi về cách

11:42.280 --> 11:44.500
trình xác thực như vậy có thể hoạt động với sự trợ

11:44.500 --> 11:46.670
giúp của trình trang trí TypeScript.

11:46.670 --> 11:49.150
Và hãy nhớ rằng tất cả những thứ đó ở đây, tất

11:49.150 --> 11:52.310
cả các trình trang trí, chức năng xác thực và sổ đăng ký,

11:52.310 --> 11:53.590
sẽ bị ẩn khỏi bạn.

11:53.590 --> 11:55.820
Đó có thể là một phần của thư viện bên thứ ba mà bạn

11:55.820 --> 11:56.780
đang làm việc, tất nhiên

11:56.780 --> 11:59.250
là theo cách phức tạp hơn so với cách bạn có thể chia

11:59.250 --> 12:01.300
sẻ với người dùng cuối của mình.

12:01.300 --> 12:04.160
Và bạn, với tư cách là người dùng cuối, chỉ cần nhập những

12:04.160 --> 12:06.800
thứ này, thêm các bộ trang trí này và gọi tính hợp

12:06.800 --> 12:08.840
lệ, và sau đó bạn sẽ có một cách rất thuận

12:08.840 --> 12:11.763
tiện để thêm xác thực vào các lớp của mình.
