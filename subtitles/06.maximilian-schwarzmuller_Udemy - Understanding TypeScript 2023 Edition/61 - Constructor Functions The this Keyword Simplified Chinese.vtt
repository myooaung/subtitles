WEBVTT

00:02.160 --> 00:03.330
演示者：现在,

00:03.330 --> 00:06.080
类和所有的构造函数都已经存在很长时间了,

00:06.080 --> 00:12.780
它们不只是有属性, 你可以用它们来定义对象的一般结构｡

00:12.780 --> 00:14.770
您也可以加入方法｡ 

00:14.770 --> 00:17.460
这里确实有构造函数方法｡ 

00:17.460 --> 00:19.620
但这只是一个实用函数,

00:19.620 --> 00:22.940
当你实例化类时, 它被调用｡

00:22.940 --> 00:25.584
记住, 过去我们只有构造函数,

00:25.584 --> 00:28.100
现在我们有了语法糖, 但是我们仍然有构造函数,

00:28.100 --> 00:33.300
我们可以添加它来运行任何初始化代码｡

00:33.300 --> 00:36.350
您可能还想添加一些函数或方法,

00:36.350 --> 00:40.980
然后调用它们, 您可以在创建的对象上调用它们｡

00:40.980 --> 00:46.000
例如, 在我们的department类上有一个describe方法｡

00:46.000 --> 00:47.994
现在添加了一个方法,

00:47.994 --> 00:49.382
方法名, 然后没有冒号,

00:49.382 --> 00:56.090
没有等号, 括号, 然后是大括号｡

00:56.090 --> 00:59.070
括号中包含您可能需要的任何参数｡ 

00:59.070 --> 01:00.780
现在假设我们不需要任何参数,

01:00.780 --> 01:05.150
否则你可以像在常规函数中一样添加参数｡

01:05.150 --> 01:12.020
通常你需要的是花括号之间的函数体或方法体｡

01:12.020 --> 01:14.693
现在, 您可以在这里定义方法的逻辑｡ 

01:15.580 --> 01:22.410
在这里, 我们可能需要输出部门的名称, 可能还需要一些额外的信息｡

01:22.410 --> 01:26.230
当然, 我们可以在这里使用控制台来实现这一点｡  日志, 例如部门､

01:26.230 --> 01:30.620
冒号, 然后可能是名称｡

01:30.620 --> 01:32.100
然而, 这是行不通的｡ 

01:32.100 --> 01:34.570
这将查找变量名, 变量名必须存在于所描述的方法内部,

01:34.570 --> 01:40.860
或者作为全局变量存在于类外部｡

01:40.860 --> 01:42.470
你可以看到如果它选择了年龄,

01:42.470 --> 01:44.433
我会得到一个name错误, 我不会这样做,

01:44.433 --> 01:50.100
我不会得到这个, 因为在浏览器的window对象中实际上有一个全局name变量｡

01:50.100 --> 01:53.030
尽管如此, 它在这里不会引用这个name属性,

01:53.030 --> 01:57.130
而是引用这个类之外的某个全局name变量｡

01:57.130 --> 01:59.599
要从类内部引用类属性或方法,

01:59.599 --> 02:01.930
我们必须使用this关键字,

02:01.930 --> 02:05.630
就像我们在构造函数中所做的那样｡

02:05.630 --> 02:12.400
然后, 这通常会指涉回已建立之这个类别的具体执行严修｡

02:12.400 --> 02:17.650
通过点标记, 我们可以访问该实例的所有属性和方法｡

02:17.650 --> 02:19.555
在这种情况下, 这个｡  名称｡ 

02:19.555 --> 02:24.555
所以如果我现在, 在下面, 打电话给会计｡  这样描述｡ 

02:24.583 --> 02:33.730
this关键字在this执行时将引用基于此类构建的具体会计对象｡

02:33.730 --> 02:35.530
所以如果我现在保存它,

02:35.530 --> 02:38.570
然后重新加载, 我们应该会看到这个输出,

02:38.570 --> 02:40.420
其中当然有一个打字错误,

02:40.420 --> 02:42.110
但通常它是有效的｡

02:42.110 --> 02:43.944
现在让我们修正这里的错字｡ 

02:43.944 --> 02:46.190
这就是我们添加方法的方法｡ 

02:46.190 --> 02:48.166
关于这个关键词, 现在有什么重要的词｡ 

02:48.166 --> 02:50.600
正如您可能知道的, 如果您使用过JavaScript,

02:50.600 --> 02:54.890
this关键字可能会比较棘手｡

02:54.890 --> 02:56.090
例如, 如果我在这里添加另一个对象accounting

02:56.090 --> 03:11.270
copy, 这是我们的对象, 它只有describe方法, 我敢指向accounting｡

03:11.270 --> 03:11.270
描述｡ 

03:11.270 --> 03:17.150
那么如果我把会计叫做副本 你认为用一种方法来描述会发生什么？

03:17.150 --> 03:19.200
你觉得我们会出错吗？

03:19.200 --> 03:21.200
我们当然没有得到编译错误,

03:21.200 --> 03:22.927
编译很好｡

03:22.927 --> 03:26.360
但是在运行时, 我们看到department undefined｡ 

03:26.360 --> 03:28.780
原因是我在给这个对象添加一个describe属性,

03:28.780 --> 03:34.040
这个对象是用object literal创建的, 不是基于这个类,

03:34.040 --> 03:41.420
而是一个伪对象, 不基于你定义的任何特定类.

03:41.420 --> 03:49.000
然后这个describe属性的值是一个指针指向我的accounting对象中的describe方法｡

03:49.000 --> 03:54.690
我用这个方法来求这个具体对象的｡

03:54.690 --> 03:56.240
我不会执行的｡ 

03:56.240 --> 04:00.410
所以我不传递这个函数执行的值来描述｡

04:00.410 --> 04:04.090
我在这里实际上是传递函数本身来描述的｡ 

04:04.090 --> 04:06.430
所以当我在副本上调用describe时,

04:06.430 --> 04:10.440
它确实执行了这个方法, 这一切都正常工作｡

04:10.440 --> 04:13.690
问题是, 当这个方法执行时,

04:13.690 --> 04:17.040
它不会引用这个方法最初属于的对象,

04:17.040 --> 04:21.140
因此不会引用会计对象｡

04:21.140 --> 04:22.350
相反, 这是一个很好的经验法则,

04:22.350 --> 04:29.650
你可以记住, 通常是指负责调用方法的东西｡

04:29.650 --> 04:32.190
在本例中, 负责调用describe方法的是accounting

04:32.190 --> 04:34.880
copy｡

04:34.880 --> 04:39.160
因为我们在会计副本上称之为描述｡ 

04:39.160 --> 04:42.320
这里指的是这个点前面的东西,

04:42.320 --> 04:43.980
就是会计副本.

04:43.980 --> 04:47.530
但是, 它是一个没有name属性的对象｡ 

04:47.530 --> 04:49.678
所以当我访问这个｡  name,

04:49.678 --> 04:56.610
我得到一个错误, 因为它没有引用一个带有name属性的对象｡

04:56.610 --> 04:59.220
因此, 名称确实使我们无法定义｡ 

04:59.220 --> 05:02.260
这就是为什么我得到这个奇怪的输出｡ 

05:02.260 --> 05:04.310
这是你必须记住的一件事, 不仅仅是在TypeScript中,

05:04.310 --> 05:07.470
它是JavaScript的一部分｡

05:07.470 --> 05:11.500
当然, 在TypeScript中也可能发生这种情况｡

05:11.500 --> 05:13.940
现在, 要解决这个“this”问题,

05:13.940 --> 05:19.730
可以向describe方法添加一个参数, 称为this｡

05:19.730 --> 05:21.380
这是一个特殊的参数,

05:21.380 --> 05:25.334
一个TypeScript可以理解的特殊指令｡

05:25.334 --> 05:28.430
如果你在这里添加一个名为this的参数,

05:28.430 --> 05:36.010
它实际上并不是一个预期的参数, 你仍然可以调用describe而不传入任何值｡

05:36.010 --> 05:42.980
相反, TypeScript会将其解译为有关此应指涉之内容的提示｡

05:42.980 --> 05:45.960
现在, 为它分配一个类型是很重要的｡ 

05:45.960 --> 05:51.780
而这里的式, 在这个例子中应该是我们这里的类式所以系｡

05:51.780 --> 05:56.250
我想说的是, 当describe在describe内部执行时,

05:56.250 --> 06:05.040
在这里, 应该总是引用一个基于department类的实例.

06:05.040 --> 06:09.160
所以一个对象最后应该是department类型｡ 

06:09.160 --> 06:12.370
所以现在我们实际上得到了一个错误,

06:12.370 --> 06:14.140
我们得到了一个错误,

06:14.140 --> 06:24.100
因为我们得到的是当我们在这里调用描述会计副本时, 我们不是在部门的实例上调用它｡

06:24.100 --> 06:26.350
因此这将被违反｡ 

06:26.350 --> 06:32.250
在这种情况下, 不会引用department类型的对象｡

06:32.250 --> 06:36.920
所以这里我们通过添加这个伪参数来增加一些额外的类型安全,

06:36.920 --> 06:42.480
因为现在如果我试图保存它, 我会得到一个与这行相关的错误｡

06:42.480 --> 06:47.030
因为现在的确, 我们会执行一些无法按预期工作的代码｡

06:47.030 --> 06:49.260
所以我们必须解决这个问题, 例如,

06:49.260 --> 06:51.140
通过在这里添加一个name属性,

06:52.040 --> 06:57.702
因为现在TypeScript看到Okay, 你在其上调用describe的对象,

06:57.702 --> 07:08.070
现在有一个name属性, 就像它所期望的那样, 因为它是基于department对象的, 它也有一个name属性｡

07:08.070 --> 07:12.270
现在, TypeScript会很高兴, 因为我们添加了名称｡

07:12.270 --> 07:14.934
如果我删除它, 我们会得到错误的名称,

07:14.934 --> 07:19.750
但这是工作, 我们避免了这个未定义的输出之前｡

07:19.750 --> 07:22.770
所以理解这一点很重要｡ 

07:22.770 --> 07:26.140
注意到这一改进非常重要, 您可以将其添加到代码中,

07:26.140 --> 07:28.410
以确保捕获不需要的行为,

07:28.410 --> 07:32.993
就像我们以前遇到的那样｡
