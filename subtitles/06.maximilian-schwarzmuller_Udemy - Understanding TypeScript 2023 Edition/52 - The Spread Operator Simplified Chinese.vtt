WEBVTT

00:02.250 --> 00:04.530
教师：我们还学习了一些有用的特性,

00:04.530 --> 00:13.600
这些特性与数组和对象有关, 以及如何检索存储在数组和对象中的数据｡

00:13.600 --> 00:17.180
现在, 我们在这里添加一个新的数组, 比如说爱好,

00:17.180 --> 00:19.880
它可以是一个字符串数组｡

00:22.520 --> 00:26.700
比如这里的运动和烹饪, 显然我们可以通过索引来检索元素,

00:26.700 --> 00:33.030
比如这样.

00:33.030 --> 00:36.150
但是, 您应该了解JavaScript的基本知识｡ 

00:36.150 --> 00:40.310
下一代JavaScript, 如果我们想提取数组的所有值,

00:41.172 --> 00:43.910
引入一个很好的特性｡

00:43.910 --> 00:44.990
你什么时候需要？

00:44.990 --> 00:48.670
假设你有积极的爱好, 我有徒步旅行的爱好,

00:48.670 --> 00:56.510
现在我想加上运动和烹饪.

00:56.510 --> 00:58.960
现在我们可以通过调用push,

00:58.960 --> 01:01.290
把一个项目添加到活动爱好中,

01:01.290 --> 01:08.130
顺便说一下, 如果你想知道我怎么推到一个常量, 请记住数组是对象对象是引用值.

01:08.130 --> 01:11.010
当我们按下时, 我们改变了一个存储器, 但没有改变地址｡ 

01:11.010 --> 01:14.150
如果这没有告诉你什么, 请查看我在这节课上附加的关于这个主题的参考资料,

01:14.150 --> 01:27.540
回到这个例子, 我们可以在这里推送, 但是推送, 如果我们推送了爱好, 我们会把爱好作为一个新的数组添加到数组中, 作为一个新的嵌套数组｡

01:27.540 --> 01:33.690
哪些类型可以检测到它, 它告诉我如果我想把一个字符串数组加到一个字符串数组中,

01:33.690 --> 01:36.143
那是不对的｡

01:37.110 --> 01:40.390
所以push只取一个值, 所以我们可以传递hobbits

01:40.390 --> 01:44.450
0, 实际上push甚至取无限多的参数,

01:44.450 --> 01:51.240
这样我们就可以一次按顺序推送多个项目｡

01:51.240 --> 01:54.890
但这有点麻烦, 这就是Spread算子的用武之地｡

01:54.890 --> 01:57.700
它看起来像这样, 它是三个点, 是的, 这看起来很奇怪, 但这是一个有效的JavaScript运算符,

01:57.700 --> 02:04.770
由[Hypescript？

02:04.770 --> 02:04.770
之后我们指定或者指向数组或者对象,

02:04.770 --> 02:11.700
你们也会学到, 我们要扩展｡

02:11.700 --> 02:15.160
它的作用是, 它告诉JavaScript,

02:15.160 --> 02:17.690
因为这是现代JavaScript中可用的Vanilla

02:17.690 --> 02:28.530
JavaScript运算符, 所以它告诉JavaScript取出数组后面的所有元素, 并将它们作为一个值列表添加, 所以不是作为一个数组,

02:28.530 --> 02:41.740
而是在使用运算符的地方添加一个单独的值列表, 例如这里有一个传递给push的参数列表, 现在你可以在创建新数组时直接使用它｡

02:41.740 --> 02:46.220
在那里, 您还可以将现有数组扩展到该数组中｡ 

02:46.220 --> 02:48.950
所以基本上, 每当你需要一个逗号分隔的值列表时,

02:48.950 --> 02:54.360
你可以使用Spread Operator和一个数组来得到这样一个逗号分隔的列表｡

02:54.360 --> 02:56.660
这就是Spread算子的思想,

02:56.660 --> 03:00.663
因此它对于提取数组元素非常有用｡

03:01.860 --> 03:04.380
扩散算子, 它不仅存在于数组上,

03:04.380 --> 03:07.880
也存在于对象上.

03:07.880 --> 03:10.990
假设我们有一个人, 名字键是Max,

03:10.990 --> 03:16.640
h键是30, 现在我们要创建一个复制的人.

03:16.640 --> 03:19.060
现在如果我们像这样给一个人赋值,

03:19.060 --> 03:27.050
我们实际上是在把内存中这个人对象的指针复制到这个复制人常量中｡

03:27.050 --> 03:30.470
同样, 如果我的参考价值资源没有告诉你太多,

03:30.470 --> 03:32.360
请查看附件｡

03:32.360 --> 03:36.190
因此, 我们并没有真正创建该对象的副本｡ 

03:36.190 --> 03:40.880
现在要创建一个真实的副本, 我们可以对对象使用扩展操作符｡

03:40.880 --> 03:43.400
我们创建了一个带花括号的新对象,

03:43.400 --> 03:46.510
然后使用Spread Operator,

03:46.510 --> 03:49.630
在第一个要复制的对象上加上三个点｡

03:49.630 --> 03:52.970
它的作用是取出所有的元素, 当然这里的元素是键值对,

03:52.970 --> 03:58.630
而不是像数组那样的单个值.

03:58.630 --> 04:00.550
这里有键值对｡ 

04:00.550 --> 04:04.110
因此, 这些键值对被从那里提取出来,

04:04.110 --> 04:08.010
然后可以在任何需要键值对的地方使用,

04:08.010 --> 04:12.920
通常是一个永远不会添加键值对的对象｡

04:12.920 --> 04:15.447
因此, 对于这个空对象, person的键值对被添加了,

04:15.447 --> 04:23.700
因为我们在这里创建了一个新对象, 并把它添加到键值对中, 我们得到了一个原始对象的完美副本,

04:23.700 --> 04:30.803
而不仅仅是指向内存中对象的指针｡
