WEBVTT

1
00:00:01.850 --> 00:00:03.270
<v Instructor>So now that we know</v>

2
00:00:03.270 --> 00:00:06.760
about TypeScript fundamentals and how it differs

3
00:00:06.760 --> 00:00:09.661
and all this related to JavaScript,

4
00:00:09.661 --> 00:00:11.410
let's dig a bit deeper

5
00:00:11.410 --> 00:00:14.148
into the different core types TypeScript knows.

6
00:00:14.148 --> 00:00:17.490
The number is the type we see here, and as I explained,

7
00:00:17.490 --> 00:00:18.500
there is no difference

8
00:00:18.500 --> 00:00:22.050
between integers like the five here and floats or doubles,

9
00:00:22.050 --> 00:00:24.330
as it would be called in other programming languages,

10
00:00:24.330 --> 00:00:25.640
like 2.8 here.

11
00:00:25.640 --> 00:00:28.440
Indeed, in JavaScript, and the same is true in TypeScript,

12
00:00:28.440 --> 00:00:30.810
all numbers are floats by default.

13
00:00:30.810 --> 00:00:33.270
So, for JavaScript, and therefore, also for TypeScript,

14
00:00:33.270 --> 00:00:35.171
there is no difference between five like this

15
00:00:35.171 --> 00:00:36.770
and five like this.

16
00:00:36.770 --> 00:00:38.640
It's the same number, essentially.

17
00:00:38.640 --> 00:00:42.720
Now, besides numbers, we also have other core types.

18
00:00:42.720 --> 00:00:46.350
And that would be strings, so text, and booleans.

19
00:00:46.350 --> 00:00:47.800
Let's also have a look at those.

20
00:00:47.800 --> 00:00:50.650
We actually saw all of those in action here in this

21
00:00:50.650 --> 00:00:53.291
if statement already, which we learned is a bit redundant.

22
00:00:53.291 --> 00:00:55.971
Nonetheless, this here would be a string.

23
00:00:55.971 --> 00:00:57.720
Also, of course, five

24
00:00:57.720 --> 00:01:00.389
with quotes would be a string because it's text.

25
00:01:00.389 --> 00:01:03.851
And the result, for example, of this comparison here,

26
00:01:03.851 --> 00:01:05.170
that would be a boolean.

27
00:01:05.170 --> 00:01:08.090
This operator, the triple equal sign

28
00:01:08.090 --> 00:01:10.950
or the negated equality operator here,

29
00:01:10.950 --> 00:01:13.640
that produces true or false.

30
00:01:13.640 --> 00:01:14.720
And, of course,

31
00:01:14.720 --> 00:01:17.340
we can either produce a dynamically innerRef check,

32
00:01:17.340 --> 00:01:18.850
which we'll often do.

33
00:01:18.850 --> 00:01:22.340
Or we initialize a variable with a true or false value,

34
00:01:22.340 --> 00:01:23.379
so let's do both here.

35
00:01:23.379 --> 00:01:27.509
Here, we could add a new constant, "printResult".

36
00:01:27.509 --> 00:01:29.990
And set this to true, for example.

37
00:01:29.990 --> 00:01:31.320
And just to make it really clear,

38
00:01:31.320 --> 00:01:33.130
this could be a variable as well.

39
00:01:33.130 --> 00:01:34.460
It doesn't have to be const.

40
00:01:34.460 --> 00:01:36.030
It can be a variable, which you would create

41
00:01:36.030 --> 00:01:37.730
with let in JavaScript.

42
00:01:37.730 --> 00:01:39.870
But since I don't plan on changing it here, I will go

43
00:01:39.870 --> 00:01:40.703
with a constant.

44
00:01:40.703 --> 00:01:43.670
And we could pass this as a third parameter here.

45
00:01:43.670 --> 00:01:46.960
Let's say we pass in "printResult", which holds true here.

46
00:01:46.960 --> 00:01:49.720
Now we immediately get an error, of course,

47
00:01:49.720 --> 00:01:53.160
because our add function does not support a third argument.

48
00:01:53.160 --> 00:01:55.560
We see, "Expected two arguments but got three".

49
00:01:55.560 --> 00:01:57.260
So, therefore, we have

50
00:01:57.260 --> 00:01:58.920
to make sure we support a third argument.

51
00:01:58.920 --> 00:02:03.920
And there, we could add a "showResult" parameter.

52
00:02:03.940 --> 00:02:05.920
You could name it "printResult" here as well.

53
00:02:05.920 --> 00:02:07.910
I'm going with "showResult"

54
00:02:07.910 --> 00:02:11.340
to avoid confusion regarding the naming, but, technically,

55
00:02:11.340 --> 00:02:12.930
these two names would not clash.

56
00:02:12.930 --> 00:02:14.320
So, here, I'll name it "showResult".

57
00:02:14.320 --> 00:02:17.580
And I want to make sure that this is of type boolean

58
00:02:17.580 --> 00:02:19.500
by setting this to boolean.

59
00:02:19.500 --> 00:02:22.109
Again, by adding a colon after the parameter here

60
00:02:22.109 --> 00:02:25.120
and then by adding the name of the type.

61
00:02:25.120 --> 00:02:28.100
Now this function accepts this, and now

62
00:02:28.100 --> 00:02:31.787
what we can do is we can add a if check here and check

63
00:02:31.787 --> 00:02:35.610
"if showResult", if this is true, we can, of course,

64
00:02:35.610 --> 00:02:36.480
compare it to true.

65
00:02:36.480 --> 00:02:37.628
But as you know in JavaScript,

66
00:02:37.628 --> 00:02:41.990
you can also just pass in the truthy or falsy value here.

67
00:02:41.990 --> 00:02:43.970
And JavaScript will evaluate it, and

68
00:02:43.970 --> 00:02:47.389
if this yields true somehow or a truthy value in general,

69
00:02:47.389 --> 00:02:48.989
then we'll make it into the if block.

70
00:02:48.989 --> 00:02:50.011
Otherwise, we won't.

71
00:02:50.011 --> 00:02:52.900
And let's say we do make it in here, and then I want

72
00:02:52.900 --> 00:02:55.429
to "console.log n1 plus n2".

73
00:02:55.429 --> 00:02:58.581
Otherwise, in the else case, if we don't make it in there,

74
00:02:58.581 --> 00:03:00.549
then I want to return this.

75
00:03:00.549 --> 00:03:02.300
So now this is a function

76
00:03:02.300 --> 00:03:04.760
which sometimes returns a value

77
00:03:04.760 --> 00:03:07.200
and sometimes does not return a value,

78
00:03:07.200 --> 00:03:08.309
but output it immediately.

79
00:03:08.309 --> 00:03:11.550
Now you could argue, if you wanna write such a function,

80
00:03:11.550 --> 00:03:14.310
which is kind of unpredictable or

81
00:03:14.310 --> 00:03:16.651
which might behave unexpectedly

82
00:03:16.651 --> 00:03:18.349
if you're passing a true here.

83
00:03:18.349 --> 00:03:19.990
But here, we're doing it.

84
00:03:19.990 --> 00:03:22.090
So this function only sometimes returns.

85
00:03:22.090 --> 00:03:24.869
Sometimes it also does not return, but instead,

86
00:03:24.869 --> 00:03:27.830
just logs something to the console.

87
00:03:27.830 --> 00:03:31.120
Now here, we can actually call add just like this

88
00:03:31.120 --> 00:03:33.640
and don't need to store it in result and don't need

89
00:03:33.640 --> 00:03:37.570
to console.log result because, with "printResult" set

90
00:03:37.570 --> 00:03:39.550
to true, add itself.

91
00:03:39.550 --> 00:03:41.869
So the function itself will print the result.

92
00:03:41.869 --> 00:03:43.640
Hence, if we now save that

93
00:03:43.640 --> 00:03:47.880
and we recompile our app.ts file here with the tsc command.

94
00:03:47.880 --> 00:03:50.830
Once this is done, the page will reload,

95
00:03:50.830 --> 00:03:52.600
and we still see our output here.

96
00:03:52.600 --> 00:03:54.677
But now it's coming from line six.

97
00:03:54.677 --> 00:03:57.690
And if we have a look, line six is, indeed,

98
00:03:57.690 --> 00:03:58.980
inside the function.

99
00:03:58.980 --> 00:03:59.891
So this is a boolean.

100
00:03:59.891 --> 00:04:02.429
Now let's say we wanna customize the output.

101
00:04:02.429 --> 00:04:06.190
In the if here, we have a "resultPhrase" constant here

102
00:04:06.190 --> 00:04:10.181
where we say, "Result is" colon and then some white space.

103
00:04:10.181 --> 00:04:14.205
And we pass that in as well with "resultPhrase" here.

104
00:04:14.205 --> 00:04:17.410
Well, then we could expect this as a argument here as well.

105
00:04:17.410 --> 00:04:20.750
Phrase, which would yield pipe string, by adding a colon.

106
00:04:20.750 --> 00:04:22.291
And then string is the name of the type,

107
00:04:22.291 --> 00:04:26.469
and now we could use that phrase to output it as part

108
00:04:26.469 --> 00:04:30.360
of our result output if we're printing the result right

109
00:04:30.360 --> 00:04:31.193
in the function.

110
00:04:31.193 --> 00:04:34.789
So then, here, we could have "phrase plus n1 plus n2".

111
00:04:34.789 --> 00:04:37.440
And if we do that and we recompile

112
00:04:37.440 --> 00:04:39.040
by repeating that command,

113
00:04:39.040 --> 00:04:41.720
we'll see that this phrase is part of the result.

114
00:04:41.720 --> 00:04:44.861
But we also, now, reintroduced the old bug

115
00:04:44.861 --> 00:04:48.141
because I have a string, which I combine with two numbers.

116
00:04:48.141 --> 00:04:52.000
Everything is converted to a string here, and

117
00:04:52.000 --> 00:04:53.240
that's not what I want.

118
00:04:53.240 --> 00:04:55.930
To avoid this, in this function,

119
00:04:55.930 --> 00:04:57.708
we could add a result variable here.

120
00:04:57.708 --> 00:05:02.027
Or a result constant and store our result here.

121
00:05:02.027 --> 00:05:04.530
This will now be treated in a mathematical way

122
00:05:04.530 --> 00:05:07.990
because only numbers are involved, and then, here,

123
00:05:07.990 --> 00:05:11.430
we could combine that with phrase or just return it.

124
00:05:11.430 --> 00:05:15.160
And now, since this is never directly calculated together

125
00:05:15.160 --> 00:05:17.029
with a string, this will always be a number.

126
00:05:17.029 --> 00:05:19.350
And, yes, then here, this number combined

127
00:05:19.350 --> 00:05:21.140
with this string will be converted to a string.

128
00:05:21.140 --> 00:05:24.360
But since the mathematical calculation finished before that,

129
00:05:24.360 --> 00:05:25.548
we'll have the right result.

130
00:05:25.548 --> 00:05:28.520
So now if we repeat that and then recompile,

131
00:05:28.520 --> 00:05:30.181
we get the right output.

132
00:05:30.181 --> 00:05:33.050
So now these are the core data types in action.

133
00:05:33.050 --> 00:05:35.541
Let's now make sure we fully understand

134
00:05:35.541 --> 00:05:38.061
how types are assigned and, also,

135
00:05:38.061 --> 00:05:41.343
why we don't explicitly assign types down there.

