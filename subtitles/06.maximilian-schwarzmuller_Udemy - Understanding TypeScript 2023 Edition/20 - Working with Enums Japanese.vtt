WEBVTT

00:02.230 --> 00:04.860
講師：タプルのアイデアと少し関連しますが､

00:04.860 --> 00:09.760
アプリケーションで扱うグローバルな定数など､ 数値として表現したいが､

00:09.760 --> 00:18.530
人間が読み取れるラベルを付けたい識別子をいくつか持っておくというアイデアもあります｡

00:18.530 --> 00:20.500
そして､ そのためにEnum型があります｡ 

00:20.500 --> 00:23.800
繰り返しになりますが､ 一部の上位のプログラミング言語には存在します｡ 

00:23.800 --> 00:25.780
でも､ JavaScriptはそれを知らない｡ 

00:25.780 --> 00:26.613
こんな感じです｡ 

00:26.613 --> 00:28.110
これがenumの作り方です｡ 

00:28.110 --> 00:33.060
enumキーワードは､ JavaScriptではなくTypeScriptの世界にしか存在しないキーワードで､

00:33.060 --> 00:36.810
中カッコで囲んでから､ 識別子を記述します｡

00:36.810 --> 00:39.141
そして､ TypeScriptで追加されたこの型は､

00:39.141 --> 00:42.030
列挙型リストを与えてくれる｡

00:42.030 --> 00:45.070
つまり､ これらのラベルは最終的にゼロから始まる数字に変換され､

00:45.070 --> 00:50.133
人間が読めるラベルができあがり､ コードで扱うことができるようになります｡

00:51.310 --> 00:55.620
例を挙げると､ この人物とその役割に戻ります｡

00:55.620 --> 00:59.710
そのコードをコピーして､ 少し変更するのでコメントアウトします｡

00:59.710 --> 01:01.600
そして､ ここでは明示的な型付けをやめ､

01:01.600 --> 01:07.150
推論に戻ります｡ なぜなら､ これから役割を変えるからです｡

01:07.150 --> 01:12.350
そして今度は､ 管理者､ 著者､ そして多分読み取り専用ユーザーを持ちたいとします｡

01:12.350 --> 01:14.750
管理者のIDは0､ 読み取り専用ユーザーのIDは1､

01:14.750 --> 01:18.660
作者のIDは2であるべきです｡

01:18.660 --> 01:22.550
さて､ もちろん､ このような数字で正確に保存することができます｡

01:22.550 --> 01:24.830
欠点としては､ ロールを持たない数字を追加した場合､

01:24.830 --> 01:26.670
後でロールを抽出しようとすると､

01:26.670 --> 01:33.392
ifチェックでエラーが発生する可能性があることです｡

01:33.392 --> 01:39.690
さらに､ 開発者としては､ このユーザーがどのような役割を持っているのかを理解するのに苦労しています｡

01:39.690 --> 01:41.310
作者に対してだったのでしょうか？

01:41.310 --> 01:43.020
それとも､ ユーザーの読みがあったのでしょうか？

01:43.020 --> 01:46.140
長いポーズを取ったり､ 大きなチームで仕事をしたりすると､

01:46.140 --> 01:48.810
このことを忘れてしまうかもしれません｡

01:48.810 --> 01:50.540
ですから､ 開発者としては､

01:50.540 --> 01:54.310
ADMINやREAD ONLY USERのような､

01:54.310 --> 01:58.630
人間が読み取れる識別子が必要でしょう｡

01:58.630 --> 02:00.240
さて､ もちろんそれを利用して､

02:00.240 --> 02:02.880
このような文字列の値を扱うこともできます｡

02:02.880 --> 02:11.100
問題は､ 後でチェックする必要がある場合､ 人のロールがREAD_ONLY_USERに等しいかどうかをチェックすることです｡

02:12.260 --> 02:13.500
それとも一言だったのでしょうか？

02:13.500 --> 02:15.380
アンダースコアがついていたのですか？

02:15.380 --> 02:17.440
そうすると､ どのように文字列を書いたか､

02:17.440 --> 02:20.970
どのような正確なテキストを入れたかを覚えておかなければなりませんね｡

02:20.970 --> 02:24.330
なぜなら､ 単語と単語の間にダッシュを入れたこの文字列は､

02:24.330 --> 02:27.430
当然ながら同じものではないからだ｡

02:27.430 --> 02:29.973
ここで､ コンパイルして印刷しようとすると､

02:31.150 --> 02:39.170
チェックが単純にtrueにならないので､ 読み取り専用になります｡

02:39.170 --> 02:43.930
そのため､ コンソールにはこのような出力は表示されません｡

02:43.930 --> 02:47.290
そのため､ 文字列識別子にはデメリットもあります｡ 

02:47.290 --> 02:52.340
さて､ このようなシナリオのために､ JavaScriptではグローバル定数を定義することが一般的です｡

02:52.340 --> 02:55.580
例えば､ adminは､ その後､ 数字や文字列のような特定の値を保持し､

02:55.580 --> 03:00.060
可能な限り両方です｡

03:00.060 --> 03:04.370
もちろん､ 数値はメモリ上の余分なコードやビットを節約することができます｡

03:04.370 --> 03:09.370
そして､ ADMIN､ READ_ONLY､ AUTHORのようなロールがあり､

03:09.390 --> 03:13.750
そのロールを使用する必要があります｡

03:13.750 --> 03:17.343
この利点は､ コードのあらゆる場所でこれを利用できることです｡

03:18.230 --> 03:23.680
例えば､ このコードを実行し､ コンパイルして､

03:25.260 --> 03:31.520
リロードすると､ adminのように表示されます｡

03:31.520 --> 03:34.190
欠点は､ ロールが単なる数字であると推測されるため､

03:34.190 --> 03:39.630
サポートしていない数字であっても､ そこに格納できることです｡

03:39.630 --> 03:44.060
さらに､ これらの定数をすべて定義し､ 管理しなければならないのです｡

03:44.060 --> 03:45.920
そこで､ enumを使うと手間が省ける｡ 

03:45.920 --> 03:48.730
これは全く問題ないのですが､ enumを使うとより簡単になります｡ 

03:48.730 --> 03:50.970
enumキーワードでenumを作成し､

03:50.970 --> 03:58.620
Roleと命名します｡ enumもカスタム型なので､ 大文字で始めるのが慣例です｡

03:58.620 --> 04:01.760
これが最初のカスタムタイプです｡ このコースでは他にもたくさんのカスタムタイプを書いていきますが､

04:01.760 --> 04:03.860
これは最初のものです｡

04:03.860 --> 04:06.560
そして､ このenumに割り当てたい型の名前の後に､

04:06.560 --> 04:09.520
中括弧を追加します｡ コロンも等号も使わず､

04:09.520 --> 04:14.040
名前の後に中括弧を追加するだけです｡

04:14.040 --> 04:15.800
そして､ セミコロン｡ 

04:15.800 --> 04:24.300
ここで､ admin､ read only､ authorなどの値を割り当てることができます｡

04:24.300 --> 04:28.180
そして､ その裏側では､ ここが0番､ ここが1番､

04:28.180 --> 04:31.780
ここが2番と受け取っているのです｡

04:31.780 --> 04:34.650
そして､ ここからRoleにアクセスすることができます｡  ADMINは､ オブジェクトのように､

04:34.650 --> 04:37.840
自分の識別子にアクセスします｡

04:37.840 --> 04:40.380
ここでは､ ロールがAUTHORであるかどうかをチェックし､

04:40.380 --> 04:50.630
authorを表示します｡ もちろん､ ここでADMINのロールを割り当てたので､ 今これを実行しても表示されないはずです｡

04:50.630 --> 04:57.490
しかし､ 重要なのは､ そのすべてを数値にラベルを割り当てるenumの助けを借りて行っていることです｡

04:57.490 --> 04:59.210
それをJavaScriptで見てもらうと｡ 

04:59.210 --> 05:02.830
そこで､ コンパイルされたコードでは､ このように再構築されていることがわかります｡ 

05:02.830 --> 05:05.080
結局､ ここにifを付けて再構築する｡ 

05:05.080 --> 05:07.940
だから､ 自分自身を実行する関数｡ 

05:07.940 --> 05:11.770
そして､ Roleは最終的にオブジェクトとして管理され､ adminプロパティ､

05:11.770 --> 05:14.550
読み取り専用プロパティ､ AUTHORプロパティを持っており､

05:14.550 --> 05:19.970
ここに数値の値を格納することができます｡

05:19.970 --> 05:21.960
しかし､ TypeScriptは最終的に､

05:21.960 --> 05:24.210
このenum構造をJavaScriptのコードで再現するために､

05:24.210 --> 05:28.560
コードをコンパイルする際にこのような処理を行っている｡

05:28.560 --> 05:32.680
ここでは､ 開発者として､ このように都合よく作られた数字があるだけです｡

05:32.680 --> 05:34.290
その上にカーソルを置くと､

05:34.290 --> 05:36.520
数字が表示されます｡ この数字を保存しておくと､

05:36.520 --> 05:39.883
人間が読める形でこれらの数字を使用できます｡

05:40.750 --> 05:44.790
さて､ 列挙型の場合､ デフォルトの動作に制限されることもありません｡

05:44.790 --> 05:47.470
例えば､ 何らかの理由でゼロを開始番号にしたくない場合､

05:47.470 --> 05:50.533
識別子の後にここに等号を付けて他の数字を入力すると､

05:50.533 --> 06:04.580
今度は管理者が数字の5に割り当てられ､ 値を割り当てる識別子の後の他の識別子は､ それを拾って､ 単にこの開始値を増加させるだけです｡

06:04.580 --> 06:08.140
つまり､ 0､ 1､ 2ではなく､ fine､ 6､ 7になったわけです｡ 

06:08.140 --> 06:10.642
もちろん､ 独自の数値が必要な場合は､

06:10.642 --> 06:14.820
これらすべての識別子に独自の値を割り当てることも可能です｡

06:14.820 --> 06:17.070
しかし､ 多くの場合､

06:17.070 --> 06:24.900
ゼロから始まる数値のインクリメントがデフォルトですが､

06:24.900 --> 06:28.530
別の動作が必要な場合､

06:28.530 --> 06:34.850
ここに文字列､ ここに数値､ ここにも数値､

06:34.850 --> 06:48.270
あるいは数値文字列を使用したい場合､ 絶対にそうすることが可能です｡

06:48.270 --> 06:52.970
そして､ それをifチェックやタイプアサインに利用すればいいのです｡

06:52.970 --> 06:56.090
これはenumの威力であり､ 人間が読み取ることができ､

06:56.090 --> 06:59.420
かつ裏側でマッピングされた値を持つ識別子が必要な場合には､

06:59.420 --> 07:03.173
いつでも素晴らしい構成要素です｡
