WEBVTT

00:02.210 --> 00:04.400
这就是继承的基本原理

00:04.400 --> 00:09.810
我们还可以重写基类的方法或属性｡

00:09.810 --> 00:15.020
因此, 假设在会计中, 我想添加自己的addEmployee方法｡

00:15.020 --> 00:16.200
我们能做到的｡ 

00:16.200 --> 00:18.500
我们可以在这里添加我们自己的方法,

00:18.500 --> 00:20.120
并在这里获取名称｡

00:20.120 --> 00:21.330
让我们说｡ 

00:21.330 --> 00:23.860
现在, 在这里, 我想有一个不同的逻辑来添加它｡

00:23.860 --> 00:27.610
一个额外的if检查或者一个if检查if name=Max,

00:27.610 --> 00:34.770
那么我想返回, 而不是把Max添加为雇员, 因为Max完全不适合｡

00:34.770 --> 00:36.360
否则, 如果姓名不是Max,

00:36.360 --> 00:38.050
我想添加该雇员｡

00:38.050 --> 00:40.420
然而, 现在我们面临着另一个问题｡ 

00:40.420 --> 00:47.500
如果我尝试添加这两个雇员, 我们看到雇员不是已知属性｡

00:47.500 --> 00:50.510
原因是员工是私人的｡ 

00:50.510 --> 00:51.890
这很重要

00:51.890 --> 00:54.860
私有属性实际上只能从定义它们的类内部访问,

00:54.860 --> 01:00.670
而不能从继承该类的类内部访问｡

01:00.670 --> 01:06.100
所以, 员工在部门内部是可用的, 但在基于部门的类中是不可用的｡

01:06.100 --> 01:11.320
因此, 会计部门不能直接访问员工属性｡

01:11.320 --> 01:15.930
如果我们想授予该访问权限, 但仍要确保它不是一个可以从外部更改的属性,

01:15.930 --> 01:22.080
我们可以将其切换为受保护的｡

01:22.080 --> 01:25.760
Protected类似于private, 但与private不同的是,

01:25.760 --> 01:32.040
它现在不仅在该类中可用, 而且在扩展该类的任何类中都可用｡

01:32.040 --> 01:37.740
现在, 我们可以从会计部门内部访问员工｡

01:37.740 --> 01:41.377
在这里, 如果不是Max, 我现在可以添加一个员工｡ 

01:41.377 --> 01:43.980
因此, 现在, 如果我去那里,

01:43.980 --> 01:49.240
在我的会计, 我想添加一个名为马克斯的雇员｡

01:49.240 --> 01:50.480
这不应该起作用｡ 

01:50.480 --> 01:52.790
如果我尝试添加Manu, 这应该会起作用｡ 

01:52.790 --> 01:57.110
因此, 如果我们现在保存它, 并在这里输出打印雇员信息,

01:57.110 --> 01:59.196
然后保存它, 我们应该看到,

01:59.196 --> 02:00.840
确实有一个雇员, 即Manu,

02:00.840 --> 02:08.590
因为我自己的AddEmployee会计方法逻辑, 没有添加Max｡

02:08.590 --> 02:14.010
所以, 这里的要点是你A）可以重写你的基类的方法｡

02:14.010 --> 02:16.690
您可以加入自己的实作, 然后使用该实作,

02:16.690 --> 02:21.023
而不是基底类别的实作｡

02:21.023 --> 02:28.100
B）您还必须控制对受保护属性的访问｡

02:28.100 --> 02:29.690
因为如果你使用private,

02:29.690 --> 02:32.120
你就真的被限制在这个类里了,

02:32.120 --> 02:41.123
而protected仍然会让它从外部不可访问, 但是会让它从扩展基类的类内部可访问.
