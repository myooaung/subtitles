WEBVTT

00:02.310 --> 00:06.000
講師：つまり､ AからBにプロジェクトを運ぶことが今の目標です｡

00:06.000 --> 00:11.850
正確には､ ユーザーが新しいプロジェクトを作成するとき､

00:11.850 --> 00:21.990
すべてのデータを入力すると､ 最終的に新しいプロジェクト・オブジェクトを作成します｡

00:21.990 --> 00:23.299
そういうことです｡ 

00:23.299 --> 00:28.890
もちろん､ これを実装する些細な方法は､ 単にユーザー入力が行われる場所に行き､

00:28.890 --> 00:34.513
ここで文書を使用することである｡

00:34.513 --> 00:34.513
getElementbyId

00:36.100 --> 00:39.410
を使用すると､ プロジェクト・リスト・クラスの一部としてレンダリングした､

00:39.410 --> 00:44.470
この ID を持つ順序なしリスト､ つまり active-projects リストまたは finished-projects

00:44.470 --> 00:52.760
リストにアクセスし､ そこに新しいアイテムを簡単に追加することができます｡

00:52.760 --> 00:54.770
しかし､ それは私がこのアプリケーションをどのように作りたいかということとは､

00:54.770 --> 00:57.250
あまり関係がないのです｡

00:57.250 --> 00:59.800
オブジェクト指向の方法で構築したいのですが､

00:59.800 --> 01:02.530
さまざまなクラスが反応的に連携し､

01:02.530 --> 01:10.550
新しいクラスを作成すると､ Domで何かが起こるというものです｡

01:10.550 --> 01:12.730
あるクラスのメソッドを呼び出すと､

01:12.730 --> 01:14.650
そのクラスが何かをする｡

01:14.650 --> 01:16.980
こういうのは､ そういうふうにしたいんです｡ 

01:16.980 --> 01:24.120
もちろん､ プロジェクト・リスト・クラスにメソッドを追加することもできます｡

01:24.120 --> 01:28.200
このメソッドは､ プロジェクトを追加してレンダリングするときに呼び出される必要があり､

01:28.200 --> 01:32.940
プロジェクト入力の内部から呼び出す方法を見つけなければなりません｡

01:32.940 --> 01:40.330
そうすることで､ プロジェクト入力クラスの内部から具象インスタンスを操作し､

01:40.330 --> 01:47.570
そのインスタンスのメソッドを呼び出すことができるようになります｡

01:47.570 --> 01:50.260
なぜなら､ そうせざるを得ないからです｡ 

01:50.260 --> 01:52.050
それはそれでアリだと思いますし､

01:52.050 --> 01:54.400
確かにそういうアプローチもありますが､

01:54.400 --> 01:58.680
私はもっと抽象的なアプローチを取りたいと考えています｡

01:58.680 --> 02:01.393
私としては､ さらに面白いアプローチだと思います｡ 

02:02.330 --> 02:06.210
アプリケーションの状態を管理するクラス､

02:06.210 --> 02:13.840
つまり､ プロジェクトやアプリケーションで管理する必要がある状態を管理するクラスを作成し､

02:13.840 --> 02:21.670
アプリケーションのさまざまな部分でリスナーを設定することができます｡

02:21.670 --> 02:24.540
AngularなどのフレームワークやReact､

02:24.540 --> 02:29.820
Reduxなどのライブラリを使っていた人なら聞き覚えのあるパターンかもしれませんね｡

02:29.820 --> 02:35.443
グローバルな状態管理オブジェクトを持ち､ 変更を聞くだけということです｡

02:35.443 --> 02:37.480
それが､ 私がここで実現したいことです｡ 

02:37.480 --> 02:39.620
もちろん､ これはひとつの方法ですが､

02:39.620 --> 02:41.660
なかなか面白い方法だと思うので､

02:41.660 --> 02:43.680
紹介したいと思います｡

02:43.680 --> 02:45.908
そこで､ アプリのtsファイルの一番上に､

02:45.908 --> 02:50.350
プロジェクトの状態管理クラスを追加します｡

02:50.350 --> 02:53.347
そして､ 単純にprojectStateと名付けます｡

02:54.820 --> 02:57.210
私には､ 賢明な名前に聞こえます｡

02:57.210 --> 03:03.760
このクラスには､ projectsというプロパティまたはフィールド（プライベートフィールド）があり､

03:03.760 --> 03:08.800
プロジェクトの配列が格納されています｡

03:08.800 --> 03:12.000
もちろん完璧ではありませんし､

03:12.000 --> 03:13.360
最終的なものでもありませんが､

03:13.360 --> 03:22.240
今はこの状態管理ソリューションに焦点を当てたいと思います｡

03:22.240 --> 03:25.653
そこで､ ここにプロジェクトのリストを掲載します｡ 

03:26.530 --> 03:30.163
さて､ 私の目標は､ このプロジェクトの追加ボタンをクリックするたびに､

03:30.163 --> 03:35.163
そのリストに項目を追加することです｡

03:36.940 --> 03:39.970
これを実現するために､ プロジェクト・ステート・クラスの内部に､

03:39.970 --> 03:43.460
パブリックなプロジェクト追加メソッドを追加してみます｡

03:43.460 --> 03:45.560
そこで､ タイトル（文字列）､

03:45.560 --> 03:47.060
説明（文字列）､

03:47.060 --> 03:55.220
プロジェクトに参加している人数（数字）を取得することを期待しています｡

03:55.220 --> 04:00.950
そして､ この中で､ とりあえずオブジェクトリテラル表記で新規プロジェクトを作成します｡

04:00.950 --> 04:03.950
ここで､ プロジェクトを一意に識別できるように､ すべてのプロジェクトに何らかのIDが必要です｡

04:03.950 --> 04:12.100
ここでは､ 数学を使ってIDを生成します｡

04:12.100 --> 04:12.100
random()を使用します｡  を文字列に変換します｡ 

04:12.100 --> 04:14.960
同じ番号を複数回生成することは可能ですが､

04:14.960 --> 04:22.570
その可能性は非常に低く､ 今回のデモの目的ではこれで十分です｡

04:22.570 --> 04:25.170
今､ すべてのプロジェクトにはタイトルが必要であり､

04:25.170 --> 04:28.370
私たちが得ているそのタイトルの引数が格納されることに加えて｡

04:28.370 --> 04:33.830
descriptionも同じで､ descriptionを格納する場所です｡

04:33.830 --> 04:37.693
そして､ 私が人数を保存する場所に私の人々｡ 

04:39.700 --> 04:43.440
これは､ とりあえず､ 保存しておきたいプロジェクトです｡ 

04:43.440 --> 04:48.020
このメソッドを作成すると､ projectsの配列にアクセスできるようになります｡

04:48.020 --> 04:48.853
この配列は非公開ですが､

04:48.853 --> 04:53.340
このメソッドがあるクラスの内部からは､ もちろんアクセスできます｡

04:53.340 --> 04:55.900
そして､ そこに新しいプロジェクトを追加したいのですが､

04:55.900 --> 05:00.380
そのためには､ 新しいプロジェクトを単純にプッシュすればいいのです｡

05:00.380 --> 05:03.350
これで､ プロジェクトを追加することができるようになりました｡ 

05:03.350 --> 05:07.027
しかし､ もちろんまだ不明な点がいくつかあります｡ 

05:07.027 --> 05:12.027
サブミットハンドラの内部からユーザー入力を収集する下のクラスの内部から､

05:12.750 --> 05:15.990
どのようにプロジェクトを追加するのでしょうか？

05:15.990 --> 05:17.940
add projectの呼び方は？

05:17.940 --> 05:21.730
そして､ その更新されたプロジェクトのリストが変更されるたびに､

05:21.730 --> 05:25.690
プロジェクトリストクラスにどのように渡せばよいのでしょうか｡

05:25.690 --> 05:29.230
この2つは､ もちろん私たちが今直面している問題です｡ 

05:29.230 --> 05:36.499
さて､ ここで一つ､ プロジェクト状態のインスタンスを作成します｡

05:36.499 --> 05:39.720
グローバルインスタンスは､ ファイル全体から使用することができ､

05:39.720 --> 05:42.760
そのクラスを作成した直後に行うことになります｡

05:42.760 --> 05:50.370
ここでは､ プロジェクト・ステート定数を用意し､ このようにプロジェクトの状態をインスタンス化します｡

05:50.370 --> 05:54.620
このように､ これはファイル内のどの場所でも使用できるグローバル定数なので､

05:54.620 --> 06:01.660
このクラスとの会話は非常にシンプルになりました｡

06:01.660 --> 06:04.850
さらに､ 私たちが学んだ機能であるプライベート・コンストラクタを使って､

06:04.850 --> 06:09.170
これがシングルトン・クラスであることを保証することもできるのです｡

06:09.170 --> 06:11.950
ここでプライベートなコンストラクタを作成し､

06:11.950 --> 06:18.933
別のプライベートプロパティであるインスタンスを作成します｡

06:20.640 --> 06:30.050
そして､ ここにインスタンス取得メソッド（実際には静的メソッド）を追加し､ この.NET Frameworkがインストールされているかどうかをチェックします｡

06:30.050 --> 06:30.050
インスタンスはモノであり､

06:31.020 --> 06:35.800
そのためには､ これも実は静的なインスタンス､ つまり静的なプロパティでなければならないのです｡

06:35.800 --> 06:37.100
もし､ これが物であるならば､

06:37.100 --> 06:39.550
これを返す. のインスタンスを取得した場合は､

06:39.550 --> 06:44.590
取得したインスタンスを返し､ そうでない場合は新しいインスタンスを作成します｡

06:44.590 --> 06:45.423
だから､

06:45.423 --> 06:50.423
そうでなければ､ この. のインスタンスは､ 新しいプロジェクトの状態と同じになります｡ 

06:50.450 --> 06:52.963
そして､ これを返す｡  インスタンスです｡ 

06:54.740 --> 07:00.903
これで､ このようにProjectStateというインスタンスを呼び出すことができます｡

07:00.903 --> 07:00.903
getInstanceを使えば､

07:04.390 --> 07:06.560
常に全く同じオブジェクトを扱うことができ､

07:06.560 --> 07:11.700
アプリケーション全体でその型のオブジェクトは常に1つしかないことが保証されます｡

07:11.700 --> 07:17.503
というのも､ このプロジェクトでは状態管理オブジェクトを1つだけ持ちたいからです｡

07:17.503 --> 07:21.563
これが､ このシングルトンコンストラクタを使ったプロジェクトの状態です｡

07:22.730 --> 07:25.890
これで､ プロジェクトの状態定数ができました｡ 

07:25.890 --> 07:30.270
それでは､ ユーザーからの入力を収集するプロジェクト入力クラスに降りてみましょう｡

07:30.270 --> 07:33.950
ここで､ projectStateを呼び出すことができるようになりました｡  を追加し､ タイトル､

07:33.950 --> 07:40.960
説明､ 人々を転送し､ 我々は最終的にユーザーの入力を収集から返されます｡

07:40.960 --> 07:43.920
これで､ このプロジェクトが作成されるはずです｡ 

07:43.920 --> 07:47.140
あとは､ 新しいプロジェクトができたという情報を､

07:47.140 --> 07:51.530
プロジェクト・リスト・クラスにプッシュするだけです｡ なぜなら､

07:51.530 --> 07:56.500
このクラスは画面に何かを出力する役割を担っているからです｡

07:56.500 --> 08:00.350
そのために､ 最終的には定期購入のパターンを設定したいんです｡

08:00.350 --> 08:03.020
プロジェクトの状態の中で､ リスナーのリスト､

08:03.020 --> 08:11.600
つまり何かが変わるたびに呼び出されるべき関数のリストを管理します｡

08:11.600 --> 08:12.433
そのために､ ここにもう一つ私有財産を追加します､

08:12.433 --> 08:15.830
リスナーの皆さん｡

08:15.830 --> 08:18.810
そしてリスナーは空の配列になります｡

08:18.810 --> 08:22.130
今はまだ､ ただの何でもありの配列ですが､

08:22.130 --> 08:25.543
後で詳しく説明します｡

08:26.760 --> 08:31.382
ここで､ リスナー関数を取得するメソッドaddListenerも用意したいので､

08:31.382 --> 08:39.150
これは最後に関数にする必要があります｡

08:39.150 --> 08:41.370
そして､ リスナーにこう付け加えます｡ 

08:41.370 --> 08:46.500
そこで､ リスナー関数をリスナー配列にプッシュします｡

08:46.500 --> 08:49.580
さて､ そのリスナーズアレイを持つというのはどういうことなのでしょうか？

08:49.580 --> 08:53.070
関数の配列､ 関数参照の配列ですね？

08:53.070 --> 08:57.310
このアイデアは､ 何かが変わるたびに､ 例えばここでは新しいプロジェクトを追加するときに､

08:57.310 --> 08:59.790
すべてのリスナー関数を呼び出すというものです｡

08:59.790 --> 09:03.050
そこで､ このリスナーのすべてのリスナーをループして､

09:03.050 --> 09:04.720
すべてのリスナー関数を通して､

09:04.720 --> 09:11.593
これらは関数参照なので､ 関数としてこれを実行することができます｡

09:13.010 --> 09:14.630
この関数には､ 管理している状態に基づいて､

09:14.630 --> 09:23.280
関連するものを渡します｡ この場合､ このクラスではもちろん､ プロジェクト・リストです｡

09:23.280 --> 09:27.983
このクラスが担当する状態です｡ 

09:29.100 --> 09:29.933
そこで､ このプロジェクトを転送して､

09:30.980 --> 09:39.100
sliceを呼び出して､ 元の配列ではなく､ その配列のコピーだけを返すようにします｡

09:39.100 --> 09:44.210
リスナー機能のあるところから編集できないように｡

09:44.210 --> 09:48.110
配列やオブジェクトはJavascriptでは参照値なので､

09:48.110 --> 09:59.830
元の配列を渡せば外から編集できます｡ 一方､ このクラスの内部から配列に何かを追加すると､ アプリ内の他のすべての場所ですでに変更されますが､

09:59.830 --> 10:12.770
これらの場所では変更にあまり気づきません｡ したがって､ 元の参照を渡すと奇妙なバグが発生する可能性があります｡

10:12.770 --> 10:15.390
これで､ すべてのリスナー関数が実行され､ 私たちのコピー､

10:15.390 --> 10:19.400
つまりプロジェクトの新しいコピーが取得されます｡

10:19.400 --> 10:23.800
あとは､ 変更を通知してほしい場所（ここではプロジェクトリストのクラス）に行き､

10:23.800 --> 10:29.030
そのようなリスナーを設定するだけです｡

10:29.030 --> 10:32.880
プロジェクト・リスト・クラスのコンストラクタで､ コンテンツをアタッチしてレンダリングする前に､

10:32.880 --> 10:43.720
projectStateにアクセスして､ ここでaddListenerを呼び出し､ 基本的にリスナー関数をここに登録します｡

10:43.720 --> 10:49.100
リスナーは関数だと言ったので､ addListenerに関数を渡さなければならない｡

10:49.100 --> 10:52.610
なぜなら､ 私たちがプロジェクトの状態で管理しているリスナーは､

10:52.610 --> 10:57.773
単なる関数のリストであり､ 何かが変更されたときに最終的に呼び出されるものだからです｡

10:58.840 --> 11:04.990
そこで､ ここでaddListener関数に関数を渡す必要があります｡

11:04.990 --> 11:07.520
ここでは､ 無名の矢印関数を渡しています｡ 

11:07.520 --> 11:10.770
そして､ この関数はprojectStateの内部から呼ばれると､

11:10.770 --> 11:14.400
プロジェクトのリストを取得します｡

11:14.400 --> 11:17.430
つまり､ プロジェクトのリストを取得し､ この関数本体の内部で､

11:17.430 --> 11:21.560
このプロジェクトのリストを使用できることがわかります｡

11:21.560 --> 11:30.310
そしてここでは､ assignedProjectsという全く新しいフィールドをプロジェクトリストに追加します｡

11:30.310 --> 11:32.357
これはany array型なので､

11:32.357 --> 11:34.010
配列の中の任意のもの､

11:34.010 --> 11:37.630
任意の値の配列です｡

11:37.630 --> 11:41.780
そして､ この割り当てられたプロジェクトは､ プロジェクトとイコールであると言えるのです｡

11:41.780 --> 11:44.240
だから､ 私たちが得ているプロジェクトに

11:44.240 --> 11:45.870
ここで､ この暗黙の型エラーを取り除くために､

11:45.870 --> 11:51.563
これが実際には何かの配列になることを明確にしなければなりません｡

11:52.610 --> 11:57.660
そこで､ 今､ 私の状態で何かが変わったために得たプロジェクトを追加しています｡

11:57.660 --> 12:00.530
ここでは､ 割り当てられたプロジェクトに追加するのではなく､

12:00.530 --> 12:04.170
割り当てられたプロジェクトを新しいプロジェクトで上書きしています｡

12:04.170 --> 12:08.223
そして､ 私のアイデアは､ これらのプロジェクトをすべてレンダリングすることです｡ 

12:09.080 --> 12:10.883
そのためには､ 例えば renderPrjects

12:11.951 --> 12:15.080
という新しいメソッドを追加すればよい｡

12:15.080 --> 12:16.920
ここから呼び出したい､ このrenderProjectsは､

12:16.920 --> 12:20.063
ちょうどこのように｡

12:22.230 --> 12:24.120
renderProjectsから外れて終了｡ 

12:24.120 --> 12:31.290
このリストに手を伸ばすと､ コンテンツをレンダリングするときにそのIDが割り当てられますね｡

12:31.290 --> 12:34.440
renderProjectsが呼ばれた後にこれを行うように見えますが､

12:34.440 --> 12:40.230
これは関数で終わっており､ 新しいプロジェクトが追加されたときにのみ最終的に呼ばれることになることを覚えておいてください｡

12:40.230 --> 12:43.510
そのため､ 実際にはrenderContentが先に実行されます｡ 

12:43.510 --> 12:49.370
したがって､ renderProjects では､ この ID が順序なしリストに割り当てられていることを頼りに､

12:49.370 --> 12:58.030
ここでは､ これを取得して document を使用してリスト要素を取得できます｡

12:58.030 --> 12:58.030
getElementbyIdで､

12:58.469 --> 13:03.690
このID識別子を､ この具体的なプロジェクト・リスト・クラスの型を使って渡すだけです｡

13:03.690 --> 13:08.563
そして､ このIDの残りは､ 私たちが生成したものを使っています｡ 

13:09.580 --> 13:11.130
そのリストに､ あるいはそのリストの中に､

13:11.130 --> 13:14.170
私たちが持っているすべてのプロジェクトをレンダリングしたいと思います｡

13:14.170 --> 13:21.060
では､ ここでこの割り当てられたプロジェクトの項目をすべて見ていくことにします｡

13:21.060 --> 13:23.150
そして､ すべての項目に対して､ リストに何かを追加し､

13:23.150 --> 13:25.380
後でこれを改良することになります｡

13:25.380 --> 13:32.480
とりあえず､ ここではリスト要素に対してappendChildを呼び出すだけにしておきます｡

13:32.480 --> 13:36.970
ところで､ ここでは感嘆符を付けて､ これがNULLにならないことを明確にする必要があります｡

13:36.970 --> 13:41.970
また､ これをHTMLのULリスト要素にキャストすることもできますので､

13:42.000 --> 13:45.420
順序なしリスト要素にキャストします｡

13:45.420 --> 13:47.530
そして､ この子項目を追加すると､

13:47.530 --> 13:56.160
まったく新しいリスト項目になるはずです｡

13:56.160 --> 13:56.160
createElement LI.

13:56.160 --> 13:58.350
そして､ このリストアイテムには､ テキストコンテンツをproject

13:58.350 --> 14:03.950
Itemと同じに設定します｡

14:03.950 --> 14:03.950
のタイトルが表示されます｡ 

14:03.950 --> 14:06.240
すべてのプロジェクトアイテムは､ プロジェクトの状態でそこまで作成するとプロジェクトになるので､

14:06.240 --> 14:13.100
そのようなオブジェクトになり､ したがって､ タイトルが付きます｡

14:14.210 --> 14:15.940
これで､ 下に行くとリスト項目があり､

14:15.940 --> 14:18.880
ここに追加されています｡

14:18.880 --> 14:20.730
これでほぼ完成です｡ 残りの修正点は､

14:20.730 --> 14:27.080
フィールドを設定したものの､ コンストラクタでそれを参照しないことです｡

14:27.080 --> 14:29.090
ここだけ私のリスナー関数ですが､ 前述の通り､

14:29.090 --> 14:32.640
これはコンストラクタですぐに実行されるわけではありません｡

14:32.640 --> 14:37.640
ここで行うのは､ この割り当てられたプロジェクトを､

14:38.970 --> 14:44.450
最初は空の配列と等しく設定することです｡

14:44.450 --> 14:45.510
これで保存すれば､

14:45.510 --> 14:47.780
エラーなくコンパイルできるはずです｡

14:47.780 --> 14:51.993
そして､ ここに何かを追加したら､ うまくいくでしょうか？

14:53.480 --> 14:56.270
確かにリストに表示されるのを確認しています｡ 

14:56.270 --> 14:58.270
フィルタリングロジックなどがないため､

14:58.270 --> 15:00.847
現時点では両方のリストで｡

15:00.847 --> 15:03.210
それは後で修正できることですが､

15:03.210 --> 15:06.220
機能する､ それが重要なことです｡

15:06.220 --> 15:08.390
しかし､ ここにもバグがあることがおわかりいただけたでしょうか｡ 

15:08.390 --> 15:12.370
2つ目の要素を追加すると､ 前回の要素を複製して新しい要素を追加するので､

15:12.370 --> 15:15.490
そこは修正する必要がありますね｡

15:15.490 --> 15:17.653
しかし､ 少なくともこれで何かを出力できるようになったので､

15:17.653 --> 15:30.733
使用している型をより明確にする､ 重複出力を避ける､ その他多くの改善点について掘り下げていきましょう｡
