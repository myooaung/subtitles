WEBVTT

00:02.160 --> 00:03.330
Người thuyết trình:

00:03.330 --> 00:06.080
Bây giờ các lớp và tất cả các hàm tạo đã tồn tại

00:06.080 --> 00:09.280
lâu hơn không chỉ có các thuộc tính mà bạn có thể sử

00:09.280 --> 00:12.780
dụng để xác định cấu trúc chung của đối tượng.

00:12.780 --> 00:14.770
Bạn cũng có thể thêm các phương thức.

00:14.770 --> 00:17.460
Chúng tôi thực sự có phương thức xây dựng ở đó.

00:17.460 --> 00:19.620
Nhưng đó chỉ là một hàm tiện

00:19.620 --> 00:22.940
ích, được gọi khi bạn khởi tạo lớp.

00:22.940 --> 00:25.584
Hãy nhớ rằng, trong quá khứ, chúng ta chỉ có các

00:25.584 --> 00:28.100
hàm tạo, bây giờ chúng ta có đường cú pháp đó

00:28.100 --> 00:30.460
nhưng chúng ta vẫn có hàm tạo mà chúng ta có

00:30.460 --> 00:33.300
thể thêm vào để chạy bất kỳ mã khởi tạo nào.

00:33.300 --> 00:36.350
Bạn cũng có thể muốn thêm một vài hàm hoặc phương

00:36.350 --> 00:38.600
thức mà sau đó chúng được gọi để bạn

00:38.600 --> 00:40.980
có thể gọi trên đối tượng đã tạo.

00:40.980 --> 00:44.000
Ví dụ, một phương thức mô tả ở đây trên lớp

00:44.000 --> 00:46.000
bộ phận của chúng tôi.

00:46.000 --> 00:47.994
Bây giờ một phương thức được thêm vào

00:47.994 --> 00:49.382
như thế này, tên của phương

00:49.382 --> 00:53.270
thức, sau đó không có dấu hai chấm, thay vào đó không có dấu bằng, dấu

00:53.270 --> 00:56.090
ngoặc đơn và sau đó là dấu ngoặc nhọn.

00:56.090 --> 00:59.070
Các dấu ngoặc đơn có bất kỳ đối số nào bạn có thể cần.

00:59.070 --> 01:00.780
Bây giờ giả sử ở đây, chúng ta không cần bất kỳ

01:00.780 --> 01:03.330
tham số nào, nếu không, bạn có thể thêm các tham số giống như cách

01:03.330 --> 01:05.150
bạn thực hiện trong một hàm thông thường.

01:05.150 --> 01:07.280
Và những gì bạn thường luôn cần,

01:07.280 --> 01:10.000
là thân hàm hoặc thân phương thức nằm giữa

01:10.000 --> 01:12.020
các dấu ngoặc nhọn.

01:12.020 --> 01:14.693
Ở đây bây giờ bạn xác định logic của phương pháp của bạn.

01:15.580 --> 01:19.570
Và ở đó, chúng tôi có thể muốn xuất tên của bộ phận

01:19.570 --> 01:22.410
với một chút thông tin bổ sung.

01:22.410 --> 01:26.230
Tất nhiên chúng ta có thể làm điều này ở đây với console. nhật ký, ví dụ, bộ phận,

01:26.230 --> 01:30.620
dấu hai chấm và sau đó có thể là tên.

01:30.620 --> 01:32.100
Tuy nhiên, điều này sẽ không làm việc.

01:32.100 --> 01:34.570
Điều này sẽ tìm kiếm một tên biến, tên này

01:34.570 --> 01:37.710
phải tồn tại bên trong phương thức được mô tả này

01:37.710 --> 01:40.860
hoặc bên ngoài lớp dưới dạng biến toàn cục.

01:40.860 --> 01:42.470
Và như bạn thấy nếu nó chọn tuổi,

01:42.470 --> 01:44.433
tôi gặp lỗi về tên Tôi không làm điều này,

01:44.433 --> 01:46.540
tôi không hiểu điều này vì thực sự có một

01:46.540 --> 01:50.100
biến tên toàn cầu trong trình duyệt trong đối tượng cửa sổ.

01:50.100 --> 01:53.030
Tuy nhiên, điều này sẽ không đề cập đến thuộc tính

01:53.030 --> 01:57.130
tên này ở đây mà là một số biến tên toàn cầu bên ngoài lớp này.

01:57.130 --> 01:59.599
Để tham chiếu đến một thuộc tính hoặc phương

01:59.599 --> 02:01.930
thức của lớp từ bên trong lớp, chúng ta phải

02:01.930 --> 02:03.590
sử dụng từ khóa this như chúng

02:03.590 --> 02:05.630
ta làm ở đây trong hàm tạo.

02:05.630 --> 02:08.980
Sau đó, điều này thường đề cập đến thể

02:08.980 --> 02:12.400
hiện cụ thể của lớp này đã được tạo.

02:12.400 --> 02:14.240
Và ở đó với ký hiệu dấu chấm, chúng ta có

02:14.240 --> 02:16.600
thể truy cập tất cả các thuộc tính và phương thức trong

02:16.600 --> 02:17.650
trường hợp này.

02:17.650 --> 02:19.555
Trong trường hợp này, điều này. Tên.

02:19.555 --> 02:24.555
Vì vậy, nếu bây giờ tôi, ở dưới đó, gọi kế toán. mô tả như thế này.

02:24.583 --> 02:28.110
Từ khóa this, khi this thực thi sẽ đề cập

02:28.110 --> 02:30.920
đến đối tượng kế toán cụ thể được

02:30.920 --> 02:33.730
xây dựng dựa trên lớp này.

02:33.730 --> 02:35.530
Vì vậy, nếu bây giờ tôi lưu nó và

02:35.530 --> 02:38.570
chúng tôi tải lại, chúng tôi sẽ thấy kết quả này ở đây,

02:38.570 --> 02:40.420
tất nhiên là có lỗi đánh máy, nhưng

02:40.420 --> 02:42.110
nói chung nó hoạt động.

02:42.110 --> 02:43.944
Bây giờ chúng ta hãy sửa lỗi đánh máy ở đây.

02:43.944 --> 02:46.190
Vì vậy, đây là cách chúng ta có thể thêm một phương thức.

02:46.190 --> 02:48.166
Bây giờ những từ quan trọng về từ khóa này.

02:48.166 --> 02:50.600
Như bạn có thể biết, nếu bạn đã từng làm

02:50.600 --> 02:54.890
việc với JavaScript một chút, thì từ khóa this có thể hơi phức tạp.

02:54.890 --> 02:56.090
Ví dụ: nếu tôi thêm

02:56.090 --> 03:00.090
một đối tượng khác vào đây là bản sao kế toán và

03:01.480 --> 03:03.350
đây là đối tượng của chúng

03:03.350 --> 03:06.430
tôi chỉ có phương thức mô tả và tôi dám

03:06.430 --> 03:11.270
chỉ vào kế toán. mô tả.

03:11.270 --> 03:15.470
Sau đó, nếu tôi gọi kế toáncopy. mô tả như một phương pháp, bạn

03:15.470 --> 03:17.150
nghĩ điều gì sẽ xảy ra?

03:17.150 --> 03:19.200
Bạn có nghĩ rằng chúng tôi sẽ nhận được một lỗi?

03:19.200 --> 03:21.200
Chúng tôi chắc chắn không gặp lỗi biên

03:21.200 --> 03:22.927
dịch mà chỉ biên dịch tốt.

03:22.927 --> 03:26.360
Nhưng trong thời gian chạy, chúng tôi thấy bộ phận không xác định.

03:26.360 --> 03:28.780
Và lý do cho điều đó là những gì tôi đang làm

03:28.780 --> 03:32.010
là tôi đang thêm một thuộc tính description vào đối tượng

03:32.010 --> 03:34.040
này, thuộc tính này được tạo bằng đối

03:34.040 --> 03:37.888
tượng theo nghĩa đen, không dựa trên lớp này, mà giống như một đối tượng

03:37.888 --> 03:41.420
giả không dựa trên bất kỳ lớp cụ thể nào bạn xác định.

03:41.420 --> 03:44.360
Và sau đó, giá trị cho thuộc tính mô tả này là

03:44.360 --> 03:49.000
một con trỏ tại phương thức mô tả trong đối tượng kế toán của tôi.

03:49.000 --> 03:52.168
Vì vậy, tôi đang chỉ vào phương pháp này ở

03:52.168 --> 03:54.690
đây để tìm đối tượng cụ thể này.

03:54.690 --> 03:56.240
Tôi không thực hiện nó.

03:56.240 --> 03:57.723
Vì vậy, tôi không chuyển giá

03:57.723 --> 04:00.410
trị của việc thực thi chức năng này để mô tả.

04:00.410 --> 04:04.090
Tôi thực sự chuyển chức năng để mô tả ở đây.

04:04.090 --> 04:06.430
Vì vậy, khi tôi gọi mô tả ở đây trên bản sao,

04:06.430 --> 04:08.950
nó thực sự thực thi phương thức mà tất cả đều

04:08.950 --> 04:10.440
hoạt động chính xác.

04:10.440 --> 04:13.690
Vấn đề chỉ là, khi phương thức này thực thi, this

04:13.690 --> 04:17.040
sẽ không đề cập đến đối tượng này mà phương thức này

04:17.040 --> 04:19.170
là một phần của ban đầu, vì vậy không

04:19.170 --> 04:21.140
phải đối tượng kế toán.

04:21.140 --> 04:22.350
Thay vào đó, điều này,

04:22.350 --> 04:25.050
và đó là một quy tắc ngón tay cái tốt mà bạn có thể

04:25.050 --> 04:27.900
ghi nhớ, thường đề cập đến thứ chịu trách nhiệm

04:27.900 --> 04:29.650
gọi một phương thức.

04:29.650 --> 04:32.190
Và chịu trách nhiệm gọi phương thức mô tả ở

04:32.190 --> 04:34.880
đây trong trường hợp này, là bản sao kế toán.

04:34.880 --> 04:39.160
Bởi vì chúng tôi gọi mô tả trên bản sao kế toán.

04:39.160 --> 04:42.320
Vì vậy, điều này sẽ đề cập đến thứ ở phía trước dấu chấm

04:42.320 --> 04:43.980
ở đây, đó là Bản sao kế toán.

04:43.980 --> 04:47.530
Tuy nhiên, đó là một đối tượng không có thuộc tính tên.

04:47.530 --> 04:49.678
Vì vậy, khi tôi truy cập này. tên, tôi gặp

04:49.678 --> 04:53.968
lỗi vì điều này không đề cập đến một đối tượng

04:53.968 --> 04:56.610
có thuộc tính tên.

04:56.610 --> 04:59.220
Vì vậy, tên thực sự mang lại cho chúng tôi không xác định.

04:59.220 --> 05:02.260
Và đó là lý do tại sao tôi nhận được kết quả kỳ lạ này.

05:02.260 --> 05:04.310
Đó là một điều bạn phải ghi nhớ, không

05:04.310 --> 05:07.470
chỉ trong TypeScript, đó là một thứ của JavaScript.

05:07.470 --> 05:09.540
Và tất nhiên, do đó, điều đó cũng có thể

05:09.540 --> 05:11.500
xảy ra với bạn trong TypeScript.

05:11.500 --> 05:13.940
Bây giờ, để khắc phục sự cố "này",

05:13.940 --> 05:16.660
bạn có thể thêm một tham số vào phương

05:16.660 --> 05:18.150
thức mô tả, được gọi

05:18.150 --> 05:19.730
là this.

05:19.730 --> 05:21.380
Đó là một tham số đặc biệt,

05:21.380 --> 05:25.334
một lệnh đặc biệt mà TypeScript hiểu được.

05:25.334 --> 05:28.430
Nếu bạn thêm một tham số có tên this vào đây, thì đó

05:28.430 --> 05:31.420
không thực sự là một tham số được mong đợi, bạn vẫn

05:31.420 --> 05:36.010
có thể gọi description mà không cần chuyển vào bất kỳ giá trị nào.

05:36.010 --> 05:38.476
Thay vào đó, điều này được giải thích bởi

05:38.476 --> 05:42.980
TypeScript, là một gợi ý về những gì điều này nên được đề cập đến.

05:42.980 --> 05:45.960
Và bây giờ, điều quan trọng là gán một loại cho điều này.

05:45.960 --> 05:48.810
Và loại ở đây, trong trường hợp này

05:48.810 --> 05:51.780
phải là loại lớp của chúng ta ở đây.

05:51.780 --> 05:53.840
Điều tôi đang nói với điều này

05:53.840 --> 05:56.250
là, khi description được thực thi

05:56.250 --> 05:59.375
this bên trong description, vì vậy trong trường

05:59.375 --> 06:02.550
hợp này ở đây, phải luôn đề cập đến một thể hiện

06:02.550 --> 06:05.040
dựa trên lớp bộ phận.

06:05.040 --> 06:09.160
Vì vậy, một đối tượng cuối cùng sẽ thuộc loại bộ phận.

06:09.160 --> 06:12.370
Và do đó, bây giờ chúng tôi thực sự gặp lỗi ở dưới

06:12.370 --> 06:14.140
đó, chúng tôi gặp lỗi ở đây,

06:14.140 --> 06:16.012
bởi vì những gì chúng tôi nhận

06:16.012 --> 06:19.800
được ở đây là khi chúng tôi gọi mô tả ở đây trên bản sao kế

06:19.800 --> 06:24.100
toán, chúng tôi không gọi nó trên phiên bản của bộ phận.

06:24.100 --> 06:26.350
Vì vậy, do đó điều này sẽ bị vi phạm.

06:26.350 --> 06:29.540
Điều này trong trường hợp này, sẽ không đề cập

06:29.540 --> 06:32.250
đến một đối tượng của loại bộ phận.

06:32.250 --> 06:34.690
Vì vậy, ở đây chúng tôi thêm một số loại an

06:34.690 --> 06:36.920
toàn bổ sung bằng cách thêm tham số giả

06:36.920 --> 06:39.450
này, bởi vì bây giờ nếu tôi cố lưu thông số này,

06:39.450 --> 06:42.480
tôi sẽ gặp lỗi liên quan đến dòng này tại đây.

06:42.480 --> 06:44.950
Bởi vì bây giờ Thật vậy, chúng tôi sẽ thực thi một

06:44.950 --> 06:47.030
số mã không hoạt động như mong đợi.

06:47.030 --> 06:49.260
Vì vậy, chúng tôi phải khắc phục điều

06:49.260 --> 06:51.140
này, ví dụ: bằng cách thêm một thuộc

06:52.040 --> 06:55.290
tính tên ở đây để nó hoạt động vì bây giờ TypeScript thấy

06:55.290 --> 06:57.702
Được rồi, đối tượng mà bạn đang gọi mô tả,

06:57.702 --> 07:02.702
giờ có một thuộc tính tên giống như điều này mong đợi nó có bởi vì điều này dựa trên

07:03.840 --> 07:05.803
đối tượng bộ phận, đối tượng này

07:05.803 --> 07:08.070
cũng có thuộc tính tên.

07:08.070 --> 07:10.790
Vì vậy, bây giờ ở đây, TypeScript sẽ rất vui vì

07:10.790 --> 07:12.270
chúng tôi đã thêm tên.

07:12.270 --> 07:14.934
Nếu tôi xóa nó, chúng tôi sẽ gặp lại lỗi với tên tuy

07:14.934 --> 07:17.277
nhiên cách này hoạt động và chúng tôi tránh

07:17.277 --> 07:19.750
đầu ra không xác định này từ trước đó.

07:19.750 --> 07:22.770
Vì vậy, điều quan trọng là phải hiểu về điều này.

07:22.770 --> 07:26.140
Và điều quan trọng là phải biết về cải tiến này mà bạn có thể

07:26.140 --> 07:28.410
thêm vào mã của mình để đảm bảo rằng bạn

07:28.410 --> 07:31.190
nắm bắt được các hành vi không mong muốn như chúng

07:31.190 --> 07:32.993
tôi đã gặp ở đó trước đây.
