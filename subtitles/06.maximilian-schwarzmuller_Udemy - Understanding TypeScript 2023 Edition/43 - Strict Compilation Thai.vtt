WEBVTT

00:02.120 --> 00:04.960
ผู้สอน: นั่นคือตัวเลือกชุดแรกที่สำคัญ

00:04.960 --> 00:07.520
ทีนี้มาดูตัวเลือกที่เข้มงวดเหล่านี้กันดีกว่า

00:07.520 --> 00:09.860
เพราะตัวเลือกเหล่านี้ค่อนข้างน่าสนใจ

00:09.860 --> 00:13.590
มีตัวเลือกจริงที่เข้มงวดนี้ และสิ่งที่ทำคือเปิดใช้ตัวเลือกการตรวจสอบประเภทที่เข้มงวดทั้งหมด

00:13.590 --> 00:22.110
ดังนั้นการตั้งค่านี้จึงมีประสิทธิภาพเหมือนกับว่าคุณได้ตั้งค่าตัวเลือกเหล่านี้ทั้งหมดแยกกัน

00:22.110 --> 00:24.830
คุณจึงสามารถตั้งค่าตัวเลือกเหล่านี้ทั้งหมดทีละรายการ

00:24.830 --> 00:27.110
หรือตั้งค่าตัวเลือกนี้ก็ได้

00:27.110 --> 00:33.020
แน่นอน คุณต้องการตั้งค่าตัวเลือกแต่ละตัวหากคุณต้องการให้บางตัวเลือกตั้งค่าเป็นเท็จ

00:33.020 --> 00:34.790
เพราะไม่เช่นนั้นก็ตั้งค่าเป็นจริงทั้งหมด

00:34.790 --> 00:36.520
หากคุณต้องการตั้งค่าทั้งหมดเป็นจริง

00:36.520 --> 00:39.290
การใช้เพียงตัวเลือกนี้จะสั้นกว่าแน่นอน

00:39.290 --> 00:41.360
ตอนนี้ตัวเลือกเหล่านี้ทำอะไรได้บ้าง

00:41.360 --> 00:43.213
เริ่มจาก noImplicitAny กันก่อน

00:44.282 --> 00:49.180
noImplicitAny เป็นตัวเลือกที่ค่อนข้างน่าสนใจที่จะช่วยให้เราเขียนโค้ดได้ดีขึ้น

00:49.180 --> 00:51.370
ไปที่ไฟล์การวิเคราะห์ของเราที่นี่

00:51.370 --> 00:53.963
และที่นั่นให้เพิ่มฟังก์ชัน sendAnalytics

00:55.270 --> 01:01.010
ที่มีตัวเลือกข้อมูล สมมติว่า และที่นั่น เราสามารถส่งสิ่งนี้ไปยังเซิร์ฟเวอร์ได้ แต่ที่นี่

01:01.010 --> 01:03.430
ฉันแค่คอนโซลกำลังบันทึก

01:03.430 --> 01:08.920
จากนั้นฉันเรียก sendAnalytics ด้วยข้อมูลดังนั้นด้วยสตริง

01:08.920 --> 01:11.080
อย่างที่คุณเห็น IDE ของฉันบ่นที่นี่แล้ว

01:11.080 --> 01:17.040
และ TypeScript คอมไพเลอร์ก็เช่นกัน เพราะแน่นอนว่าทั้งสองเชื่อมต่อกันถ้าฉันพยายามคอมไพล์สิ่งนี้

01:17.040 --> 01:20.070
ข้อมูลพารามิเตอร์โดยปริยายมีประเภทใดก็ได้

01:20.070 --> 01:21.350
ดูเหมือนว่าจะเกี่ยวข้องกับตัวเลือก

01:21.350 --> 01:23.940
noImplicitAny นี้

01:23.940 --> 01:27.150
อันที่จริง หากฉันตั้งค่านี้เป็นเท็จ ดังนั้นหากฉันตั้งค่าตัวเลือกที่เข้มงวดทั้งหมดเป็น

01:27.150 --> 01:29.300
จริง แต่ฉันตั้งค่าตัวเลือกนี้เป็นเท็จ

01:29.300 --> 01:33.810
ซึ่งฉันสามารถทำได้ ข้อผิดพลาดนี้จะหายไป

01:33.810 --> 01:37.140
ทั้งใน IDE และเมื่อเราคอมไพล์โค้ด

01:37.140 --> 01:38.730
ตัวเลือกนี้ใช้ทำอะไร?

01:38.730 --> 01:44.210
ทำให้มั่นใจได้ และฉันจะแสดงความคิดเห็นอีกครั้งเพื่อเปิดใช้อีกครั้งเนื่องจากเข้มงวดจริง

01:44.210 --> 01:53.020
ทำให้แน่ใจว่าเราต้องชัดเจนเกี่ยวกับพารามิเตอร์ของเรา เกี่ยวกับค่าที่เราทำงานในโค้ดของเรา

01:53.020 --> 01:59.930
ที่นี่เราไม่ได้ให้ TypeScript ข้อมูลใด ๆ เกี่ยวกับประเภทของข้อมูลที่เราจะได้รับเป็นพารามิเตอร์ที่นี่

01:59.930 --> 02:01.320
และเราควร

02:01.320 --> 02:03.800
หาก TypeScript สามารถอนุมานสิ่งนี้ได้ แน่นอนว่าก็ไม่เป็นไร

02:03.800 --> 02:05.360
แต่ที่นี่ TypeScript จะสามารถอนุมานได้อย่างไรจากบรรทัดนี้

02:05.360 --> 02:12.950
โปรดทราบว่าฟังก์ชันนี้ได้รับการประกาศก่อนที่ไฟล์นี้จะดำเนินการ

02:12.950 --> 02:15.080
ดังนั้น ณ เวลาที่ฟังก์ชันถูกสร้างขึ้น

02:15.080 --> 02:18.380
จึงไม่มีโอกาสที่จะรู้ว่าอะไรจะเกิดขึ้นในนั้น

02:18.380 --> 02:24.253
ดังนั้น เราสามารถแก้ไขข้อผิดพลาดนี้ได้โดยการประกาศประเภทและระบุให้ชัดเจนว่าเราใช้ประเภทใด

02:25.100 --> 02:29.530
ตอนนี้โปรดทราบว่าหากคุณมีตัวแปรที่บันทึกไว้ เมื่อคุณตั้งค่าเป็นจริงที่นี่

02:29.530 --> 02:32.650
คุณจะไม่ได้รับข้อผิดพลาดเกี่ยวกับการประกาศนี้

02:32.650 --> 02:37.670
แม้ว่าตัวแปรจะได้รับค่าเริ่มต้นเป็นประเภทใดก็ตาม

02:37.670 --> 02:39.250
สำหรับตัวแปรนี้ไม่เป็นไร

02:39.250 --> 02:40.910
สำหรับพารามิเตอร์ไม่เป็นไร

02:40.910 --> 02:42.480
เหตุใดจึงใช้ได้กับตัวแปร

02:42.480 --> 02:44.370
เนื่องจากสิ่งที่ TypeScript ทำกับตัวแปร

02:44.370 --> 02:47.040
สิ่งที่เป็นไปได้สำหรับตัวแปร สิ่งที่เป็นไปไม่ได้ที่นี่

02:47.040 --> 02:48.880
เนื่องจากฟังก์ชันถูกสร้างขึ้นก่อน

02:48.880 --> 02:52.490
ที่นี่ TypeScript สามารถติดตามค่าที่คุณกำหนดได้

02:52.490 --> 02:54.650
คุณเข้าใจไหม โอเค ฉันถูกล็อกที่นี่แบบนี้

02:54.650 --> 02:58.573
ตอนนี้ฉันตั้งค่าเป็นจริง ดังนั้น หลังจากนั้น

02:59.430 --> 03:08.030
ถ้าฉันคอนโซลล็อกล็อกที่นี่ มันจะเป็นบูลีน

03:08.030 --> 03:10.300
ดังนั้น TypeScript จึงสามารถเข้าใจโฟลว์ของโค้ดของคุณได้

03:10.300 --> 03:15.430
ดังนั้น คุณไม่จำเป็นต้องแม่นยำเกี่ยวกับประเภทที่นี่

03:15.430 --> 03:20.310
แน่นอน คุณต้องการความแม่นยำถ้าคุณต้องการหลีกเลี่ยงว่าคุณสามารถกำหนดค่าใหม่ได้อย่างอิสระ

03:20.310 --> 03:22.940
ซึ่งคุณสามารถทำได้ที่นี่เพราะเป็นประเภทใดก็ได้

03:22.940 --> 03:25.700
ดังนั้นคุณยังคงต้องการกำหนดประเภทเพื่อหลีกเลี่ยงสิ่งนี้

03:25.700 --> 03:31.410
แต่อย่างน้อย TypeScript ก็สามารถค้นหาได้ว่ารหัสที่คุณเรียกใช้นั้นใช้งานได้กับประเภทที่มีอยู่หรือไม่

03:31.410 --> 03:35.360
นี่ไม่ใช่กรณีนี้เนื่องจากมีการกำหนดฟังก์ชันก่อนที่คุณจะเรียกใช้

03:35.360 --> 03:41.393
ดังนั้น TypeScript จะไม่เปลี่ยนการรู้ว่าสิ่งที่คุณส่งผ่านนั้นสามารถนำมาใช้ภายในฟังก์ชันได้หรือไม่

03:43.280 --> 03:46.020
เข้มงวด NullChecks ไม่เคยเป็นตัวเลือกที่สำคัญ

03:46.020 --> 03:49.410
มันเกี่ยวข้องกับการเลือกปุ่มที่เรามีอยู่ตรงนี้

03:49.410 --> 03:52.670
จำไว้ว่าฉันต้องเพิ่มเครื่องหมายอัศเจรีย์ที่นี่เพื่อให้ใช้งานได้

03:52.670 --> 03:54.380
มิฉะนั้น ฉันจะได้รับข้อผิดพลาด

03:54.380 --> 04:02.090
ตอนนี้เรายังสามารถกำจัดข้อผิดพลาดนั้นโดยไม่ต้องเพิ่มเครื่องหมายอัศเจรีย์โดยตั้งค่าstrictNullChecksเป็นเท็จ

04:02.090 --> 04:04.200
ลองทำที่นี่และบันทึกสิ่งนี้กัน

04:04.200 --> 04:07.860
และอย่างที่คุณเห็นข้อผิดพลาดนี้หายไปแล้วที่นี่

04:07.860 --> 04:10.120
และฉันสามารถรวบรวมไฟล์ทั้งหมด

04:10.120 --> 04:12.340
ตอนนี้ StrictNullChecks ทำอะไร?

04:12.340 --> 04:19.410
พวกเขาบอกว่า TypeScript นั้นค่อนข้างดีและเข้มงวดมากเกี่ยวกับวิธีที่คุณเข้าถึงและทำงานกับค่าที่อาจมีค่า

04:19.410 --> 04:22.530
Null

04:22.530 --> 04:24.850
และปุ่มที่นี่อาจเป็นโมฆะ

04:24.850 --> 04:29.210
ไม่ได้ชี้ไปที่องค์ประกอบปุ่มเสมอไป

04:29.210 --> 04:31.390
ไม่ได้ชี้ไปที่องค์ประกอบดังกล่าวเสมอไป

04:31.390 --> 04:34.220
เพราะแม้ว่าคุณจะมีตัวเลือกดังกล่าวที่นี่

04:34.220 --> 04:38.490
แต่ปุ่มก็อาจไม่มีอยู่ในหน้าที่สคริปต์นี้ทำงาน

04:38.490 --> 04:40.840
ดังนั้น TypeScript จึงไม่สามารถบอกได้เนื่องจากไม่ได้ดำดิ่งลงไปในไฟล์

04:40.840 --> 04:44.900
html ของคุณและดูสิ่งนั้น

04:44.900 --> 04:48.240
ไม่สามารถบอกได้ว่าจะสำเร็จหรือไม่

04:48.240 --> 04:53.130
และถ้าสิ่งนี้ล้มเหลวในการส่งคืนพอยน์เตอร์และโหนด null ก็จะส่งคืนค่า

04:53.130 --> 04:59.090
null ซึ่งไม่ได้ถูกกำหนดให้แม่นยำ แต่ก็ได้รับการปฏิบัติอย่างเท่าเทียมกันที่นี่

04:59.090 --> 05:01.610
ดังนั้น ปุ่มนั้นอาจเก็บค่า Null

05:01.610 --> 05:03.530
และรหัสนี้อาจล้มเหลว

05:03.530 --> 05:06.610
อันที่จริง ถ้าฉันแสดงความคิดเห็นเกี่ยวกับปุ่มนี้ ถ้าตอนนี้ฉันคอมไพล์ทุกอย่างแล้ว

05:06.610 --> 05:10.733
มันจะทำงานได้เพราะฉันปิดใช้งานการตรวจสอบโมฆะ

05:12.000 --> 05:16.210
แต่ตอนนี้ฉันมีข้อผิดพลาดรันไทม์เพราะฉันไม่สามารถเรียกผู้ฟังเหตุการณ์

05:16.210 --> 05:18.230
addEventListener บน null

05:18.230 --> 05:20.970
และฉันได้ค่าว่างตรงนี้ เพราะฉันไม่มีปุ่ม

05:20.970 --> 05:26.760
นี่เป็นข้อผิดพลาดที่เราสามารถหลีกเลี่ยงได้โดยการตั้งค่าstrictNullChecksให้เป็นจริง

05:26.760 --> 05:30.340
และนั่นจะถูกตั้งค่าโดยอัตโนมัติหากเราตั้งค่าเป็นจริงอย่างเข้มงวด

05:30.340 --> 05:34.450
โดยที่ TypeScript คาดการณ์ว่าสิ่งนี้อาจเกิดขึ้น

05:34.450 --> 05:38.600
ดังนั้นจึงบังคับให้เราต้องหลีกเลี่ยงสิ่งนั้น

05:38.600 --> 05:42.820
วิธีแก้ปัญหาราคาถูกวิธีหนึ่งคือตัวดำเนินการเครื่องหมายอัศเจรีย์ตรงนี้

05:42.820 --> 05:48.360
สิ่งนี้จะบอก TypeScript ว่าคุณซึ่งเป็นผู้พัฒนาทราบว่ามีปุ่มนี้อยู่

05:48.360 --> 05:53.360
หรือการดำเนินการนี้จะให้ค่าที่ไม่ใช่ค่า Null

05:53.710 --> 05:55.830
ตอนนี้คุณอาจทำ แน่นอนถ้าคุณรู้ว่าคุณกำลังทำงานกับโค้ด

05:55.830 --> 06:03.310
HTML และมีปุ่มอยู่ที่นี่ แสดงว่าตัวเลือกนี้จะใช้ได้ผล

06:03.310 --> 06:06.623
ดังนั้นจึงเป็นการดีที่จะใช้เครื่องหมายอัศเจรีย์ในสถานการณ์นี้

06:07.600 --> 06:11.120
หากคุณมีสถานการณ์อื่นที่คุณไม่ทราบแน่ชัดว่ามันใช้งานได้หรือไม่

06:11.120 --> 06:18.210
และคุณแค่หวังว่ามันจะใช้งานได้ มันอาจจะดีกว่าที่จะรวมโค้ดที่อาจล้มเหลวไว้ในการตรวจสอบ if ซึ่งจะมีอยู่ในรันไทม์เช่นกัน

06:18.210 --> 06:21.570
, แน่นอน.

06:21.570 --> 06:27.510
คุณสามารถตรวจสอบว่าปุ่มเป็นจริงที่นี่หรือไม่ ซึ่งจะไม่เป็นเช่นนั้นหากเป็นค่าว่างหรือไม่ได้กำหนด

06:27.510 --> 06:30.060
และย้ายรหัสนั้นไปไว้ที่นี่หากตรวจสอบที่นี่

06:30.060 --> 06:32.470
ตอนนี้แม้จะไม่มีเครื่องหมายอัศเจรีย์

06:32.470 --> 06:35.810
แต่ในโหมดstrictNullChecks เราไม่พบข้อผิดพลาดเนื่องจาก

06:35.810 --> 06:39.750
TypeScript เข้าใจว่ารหัสนี้อยู่ภายในคำสั่ง if และคำสั่ง

06:39.750 --> 06:46.310
this if ทำให้แน่ใจว่าปุ่มนั้นไม่เป็นโมฆะและปุ่มนี้จะไม่ล้มเหลว

06:46.310 --> 06:49.310
นี่อาจเป็นวิธีแก้ปัญหาที่สะอาดกว่า

06:49.310 --> 06:51.060
อย่างไรก็ตาม แน่นอนว่าในการบันทึกโค้ด

06:51.060 --> 06:58.320
หากคุณทราบอย่างแน่นอนว่ามีบางอย่างอยู่ การใช้เครื่องหมายอัศเจรีย์จะสั้นกว่าและเป็นตัวเลือกที่ดีอย่างยิ่ง

06:58.320 --> 07:00.450
ในที่นี้ผมพูดทั้งสองอย่างเพื่อให้เราเห็นทั้งสองอย่าง

07:00.450 --> 07:02.450
แน่นอนว่าคุณต้องใช้อย่างใดอย่างหนึ่งจากสองอย่าง ไม่ว่าจะเป็นเครื่องหมาย

07:02.450 --> 07:04.520
if หรือเครื่องหมายอัศเจรีย์

07:04.520 --> 07:14.830
เคร่งครัดฟังก์ชันประเภท นี่คือการตั้งค่าล่วงหน้าเล็กน้อยที่จับช่องเฉพาะบางช่องซึ่งคุณอาจไม่มีในแอปพลิเคชันจำนวนมาก

07:14.830 --> 07:18.380
มันเกี่ยวข้องกับประเภทฟังก์ชันที่คุณอาจตั้งค่า

07:18.380 --> 07:23.690
ดังนั้นอย่าพิมพ์ภายในฟังก์ชัน แต่ถ้าคุณกำหนดว่าฟังก์ชันควรมีลักษณะอย่างไรเกี่ยวกับพารามิเตอร์และค่าส่งคืน

07:23.690 --> 07:29.990
และคุณสร้างประเภทฟังก์ชันดังกล่าวซึ่งคุณได้เรียนรู้เกี่ยวกับโมดูลพื้นฐาน คุณสามารถแนะนำกล่องได้หากคุณทำงานด้วย

07:29.990 --> 07:39.683
คลาสและการสืบทอดซึ่งเรายังไม่ได้เรียนรู้ ซึ่งเรายังไม่ได้ใช้ ดังนั้น สำหรับตอนนี้ เรามาเพิกเฉยต่อสิ่งนี้

07:40.578 --> 07:43.630
StrictBindCallApply ซึ่งจะมีประโยชน์หากคุณทำงานกับการผูก

07:43.630 --> 07:46.840
โทร หรือสมัคร

07:46.840 --> 07:49.680
เพื่อที่เราจะได้ดูตัวอย่างอย่างรวดเร็ว

07:49.680 --> 07:52.040
ที่นี่เรามีปุ่มและฟังก์ชั่นของเราที่นั่น

07:52.040 --> 07:57.040
สมมติว่านี่คือฟังก์ชัน ซึ่งเรากำหนดที่นี่ด้วยคีย์เวิร์ดของฟังก์ชัน

07:57.780 --> 08:01.100
หรือเป็นฟังก์ชันข้อผิดพลาด

08:01.100 --> 08:03.650
ไม่เป็นไร ฉันจะใช้คำหลักฟังก์ชันที่นี่

08:04.731 --> 08:09.731
คลิก Handler และในนั้นฉันคอนโซล คลิกเข้าสู่ระบบ

08:11.960 --> 08:13.810
และตอนนี้เราชี้ไปที่ clickHandler

08:13.810 --> 08:17.670
และด้วยเหตุผลบางอย่าง เราต้องการให้แน่ใจว่าเมื่อการดำเนินการนี้

08:17.670 --> 08:19.330
เราส่งผ่านอาร์กิวเมนต์บางอย่าง

08:19.330 --> 08:22.780
หรือเราตั้งค่าคำหลักนี้เป็นค่าที่แน่นอน

08:22.780 --> 08:26.480
สมมติว่าที่นี่เราคาดว่าจะมีอาร์กิวเมนต์ข้อความ

08:26.480 --> 08:28.110
ซึ่งควรเป็นสตริง

08:28.110 --> 08:32.110
และเราอยากแสดงผลตรงนี้ด้วย

08:32.110 --> 08:34.400
ตอนนี้ เนื่องจาก clickHandler ถูกส่งผ่านไปยัง

08:34.400 --> 08:36.010
addEventListener แบบนั้น เพื่อให้เบราว์เซอร์ดำเนินการนี้ให้เราโดยพื้นฐาน

08:36.010 --> 08:43.570
หากเราต้องการกำหนดค่าอาร์กิวเมนต์ล่วงหน้าที่จะส่งผ่าน เราสามารถใช้การผูกได้

08:43.570 --> 08:49.320
และผูกเป็นอาร์กิวเมนต์แรก รับสิ่งที่เราต้องการผูกคำหลักนี้

08:49.320 --> 08:53.580
และที่นี่เราสามารถพูดได้ว่าไม่สำคัญสำหรับเราเพราะเราไม่ได้ใช้สิ่งนี้ในฟังก์ชัน

08:53.580 --> 08:55.930
ดังนั้นเราจึงผูกมันให้เป็นโมฆะ

08:55.930 --> 08:57.700
ตอนนี้คุณเห็นที่นี่ว่าฉันได้รับข้อผิดพลาด

08:57.700 --> 09:00.610
ฉันได้รับข้อผิดพลาดที่สามารถหลีกเลี่ยงได้หากฉันตั้งค่า

09:00.610 --> 09:04.613
maximumBindCallApply เป็นเท็จ

09:07.040 --> 09:08.680
ตอนนี้คุณเห็นข้อผิดพลาดหายไปแล้ว

09:08.680 --> 09:10.501
ตอนนี้ตัวเลือกนี้ทำอะไรได้บ้าง

09:10.501 --> 09:14.180
โดยทั่วไปจะตรวจสอบฟังก์ชันที่คุณกำลังเรียกใช้การผูก

09:14.180 --> 09:16.020
การเรียกใช้ หรือนำไปใช้

09:16.020 --> 09:20.080
และจะตรวจสอบว่าสิ่งที่คุณตั้งค่าที่นี่เหมาะสมหรือไม่

09:20.080 --> 09:23.440
และที่นี่ TypeScript เห็นว่าเราต้องการอาร์กิวเมนต์ เราต้องการพารามิเตอร์ใน

09:23.440 --> 09:25.450
clickHandler

09:25.450 --> 09:28.260
ด้วยการผูกเราไม่ได้กำหนดค่านั้น

09:28.260 --> 09:30.600
ดังนั้นเราจึงได้รับข้อผิดพลาดที่นี่

09:30.600 --> 09:34.000
ถ้าฉันตั้งค่ากลับเป็น true หรือฉันแสดงความคิดเห็นเพราะแน่นอน

09:34.000 --> 09:36.230
มันถูกตั้งค่าเป็น true โดยค่าเริ่มต้นโดยตั้งค่า

09:36.230 --> 09:39.790
เข้มงวด เป็น true ดังนั้น เราจะได้รับข้อผิดพลาดอีกครั้ง

09:39.790 --> 09:44.750
ตอนนี้หากเราไม่คาดหวังการโต้แย้งที่นี่ คุณจะเห็นว่าข้อผิดพลาดจะหายไปหากเราลบข้อความออกเท่านั้น

09:44.750 --> 09:52.580
เนื่องจาก TypeScript เข้าใจโค้ดของเราและเห็นว่าคุณไม่ได้ส่งอาร์กิวเมนต์ใดๆ ไปยังเมธอดนั้นหรือฟังก์ชันนี้เพราะ ไม่ต้องใช้อะไรเลย

09:52.580 --> 09:54.760
ไม่เป็นไร

09:54.760 --> 09:57.420
แต่แน่นอน ที่นี่เราต้องการหนึ่งดังนั้นเราได้รับข้อผิดพลาด

09:57.420 --> 10:04.350
วิธีแก้ไขคือใส่อาร์กิวเมนต์ที่สองตรงนี้ ซึ่งเป็นอาร์กิวเมนต์แรกที่คุณต้องการส่งต่อ

10:04.350 --> 10:06.290
ตอนนี้ TypeScript ฉลาดมากที่นี่

10:06.290 --> 10:08.120
และตัวอย่างเช่น ถ้าฉันป้อนตัวเลข

10:08.120 --> 10:11.610
มันก็จะบ่นเพราะมันเข้าใจว่าฉันต้องการสตริงตรงนี้

10:12.500 --> 10:15.960
ถ้าฉันส่งสตริงที่ถูกต้องเหมือนที่คุณยินดี

10:15.960 --> 10:24.840
มันก็จะไม่บ่นอีกต่อไปเพราะไม่เข้าใจสิ่งนี้และเห็นว่าสิ่งนี้ตรงกับคำจำกัดความของฟังก์ชันของฉันที่นี่

10:24.840 --> 10:27.370
นี่เป็นลักษณะการทำงานที่มีประโยชน์มากซึ่งช่วยให้แน่ใจว่าคุณจะไม่ใช้การผูก

10:27.370 --> 10:32.743
การเรียกใช้ หรือนำไปใช้โดยไม่ตั้งใจในลักษณะที่ไม่ทำงานกับโค้ดของคุณ

10:33.930 --> 10:37.810
ตอนนี้ การเข้มงวดพร็อพเพอร์ตีเริ่มต้นมีความสำคัญเมื่อเราทำงานกับคลาส

10:37.810 --> 10:39.213
เราสามารถเพิกเฉยได้ในตอนนี้

10:39.213 --> 10:41.890
noImplicitสิ่งนี้ไม่สำคัญเช่นกันในตอนนี้

10:41.890 --> 10:43.650
ต้องทำคำหลักนี้และโดยทั่วไป

10:43.650 --> 10:51.020
TypeScript จะพยายามเตือนคุณหากคุณใช้คำหลักนี้ในที่ที่ไม่ชัดเจนว่าหมายถึงอะไร

10:51.020 --> 10:53.210
และ alwaysStrict เพียงแค่ควบคุมว่าไฟล์

10:53.210 --> 10:58.663
JavaScript ที่สร้างขึ้นนั้นใช้โหมดเข้มงวดเพื่อเพิ่มสิ่งนี้

10:59.710 --> 11:02.383
ด้วยเหตุนี้ เราจึงครอบคลุมตัวเลือกที่เข้มงวดเหล่านี้ทั้งหมด
