WEBVTT

00:02.260 --> 00:03.920
講師：だから､ 差別された労働組合｡ 

00:03.920 --> 00:05.750
本当に､ 本当に便利です｡ 

00:05.750 --> 00:09.060
また､ 非常に便利な機能として､ タイプキャスティングがあります｡ 

00:09.060 --> 00:15.350
タイプキャスティングは､ ある値が特定の型であることをTypeScriptに伝えるためのもので､

00:15.350 --> 00:22.660
TypeScript自身はそれを検出できないが､ 開発者としてはそれが事実であることを知ることができる｡

00:22.660 --> 00:27.120
この良い例が､ ドムで何かにXを取得する場合です｡

00:27.120 --> 00:29.560
ここでは､ domの中に段落だけがあり､

00:29.560 --> 00:33.390
他には何もない､ 空の段落があるとします｡

00:33.390 --> 00:37.150
だから､ 保存しても画面には何も表示されない｡

00:37.150 --> 00:40.543
これで､ このスクリプトの内部からこのパラグラフにアクセスできるようになりました｡

00:43.160 --> 00:48.160
文書クエリセレクタPで段落を構成する､ といった具合です｡ 

00:49.180 --> 00:51.890
ここでクエリセレクタを使って､ セレクタとしてPを渡すと､

00:51.890 --> 00:54.500
Pタグによって選択されるようになる｡

00:54.500 --> 01:07.050
TypeScriptは実際に､ カーソルを合わせるとわかるように､ これが段落要素のタイプであるか､ あるいはnullであるかを見つけることができる｡

01:07.050 --> 01:09.920
or nullのケースはとりあえず無視しましょう｡ 

01:09.920 --> 01:14.600
重要なのは､ TypeScriptが実際にこれが段落要素であることを発見していることです｡

01:14.600 --> 01:16.800
ここで､ 何か他のもの､ 例えばIDで選択すると､

01:16.800 --> 01:18.460
これは変化します｡

01:18.460 --> 01:23.920
ここではmessage-outputと名付け､ このパラグラフのIDをmessage-outputとしました｡

01:23.920 --> 01:25.890
さて､ 私たち開発者はもちろんこの段落にこのIDを割り当てたことを知っているが､

01:25.890 --> 01:29.780
TypeScriptはそれを知らない｡

01:29.780 --> 01:34.590
TypeScriptは､ 私たちのHTMLファイルに潜り込んで解析するわけではありません｡

01:34.590 --> 01:37.360
例えばgetElementByIdでIDで選択すると､

01:37.360 --> 01:49.830
TypeScriptが推測するのは､ これは単なるHTML要素かNULLで､ どの特定のHTML要素かは分からない｡

01:49.830 --> 01:52.720
さて､ 段落の場合､ それはあまり重要ではないかもしれません｡

01:52.720 --> 01:54.830
例えば､ そのテキストコンテンツにアクセスするなど､

01:54.830 --> 02:01.470
どのHTML要素でもできるようなことをしたいだけかもしれません｡

02:01.470 --> 02:03.220
でも､ ここにインプットがあったらどうでしょう？

02:03.220 --> 02:07.750
入力タイプがtextの場合､ ユーザーが入力した値を取得したいので､

02:07.750 --> 02:10.430
user-inputというIDを与えて､

02:10.430 --> 02:15.500
TypeScriptのコードでこれを選択することにします｡

02:15.500 --> 02:17.730
そこで､ ここではIDのuser-inputで選択すると､

02:17.730 --> 02:21.530
段落ではなくuserInputElementになっています｡

02:21.530 --> 02:24.023
さて､ 私たち開発者は､ ここでこのinput要素に手を伸ばすということを知っています｡

02:24.909 --> 02:28.530
しかし､ 先ほど言ったように､ TypeScriptはそのことを知りません｡

02:28.530 --> 02:34.435
TypeScriptは私たちのHTMLコードを読まないので､ TypeScriptはそれが何らかのHTML要素であることだけを知っています｡

02:34.435 --> 02:37.860
そこで､ このvalueプロパティを設定しようとすると､

02:37.860 --> 02:45.000
userInputElement.

02:45.000 --> 02:45.000
の値が等しい

02:45.000 --> 02:47.050
こんにちは､ 実際にエラーが発生したことがわかりますね｡

02:47.050 --> 02:48.960
1つは､ このオブジェクトがNULLである可能性があるため､

02:48.960 --> 02:50.780
エラーが発生します｡

02:50.780 --> 02:56.210
この後に感嘆符を追加することで修正できますが､

02:56.210 --> 02:58.390
それでも､ value

02:58.390 --> 03:03.890
does not exist on type

03:03.890 --> 03:14.510
HTML Elementというエラーが発生します｡

03:14.510 --> 03:17.540
そこで､ TypeScriptに､ ここで選択したものが単にnullでないだけでなく､

03:17.540 --> 03:25.080
HTMLInputElementのタイプであることを伝える必要がある｡

03:25.080 --> 03:28.240
そして､ それがタイプキャスティングで実現できるのです｡ 

03:28.240 --> 03:31.153
さて､ 型キャストには2つの方法､ 2つの構文があり､

03:31.153 --> 03:34.170
それらは等価である｡

03:34.170 --> 03:41.920
ひとつは､ 変換したいものの前､ つまりTypeScriptに型付けを指示したい場所に何かを追加することです｡

03:41.920 --> 03:44.170
開閉する角括弧を追加し､ この角括弧の間に､

03:44.170 --> 03:49.480
角括弧の後にあるもののタイプを記述します｡

03:49.480 --> 03:51.223
この場合､ HTMLInputElement.

03:53.110 --> 03:54.970
そしてこのタイプは､ tsconfigファイルでdom

03:54.970 --> 03:57.963
libをインクルードしているため､ グローバルに利用可能です｡

03:59.180 --> 04:06.530
これによって､ TypeScriptは角括弧の後で選択するものがHTMLInputElement型であることを認識し､

04:06.530 --> 04:08.950
それ以上文句を言わなくなった｡

04:08.950 --> 04:10.330
というわけで､ これがバージョン1です｡ 

04:10.330 --> 04:12.830
それをコピーしてコメントアウトし､

04:12.830 --> 04:14.750
代替案を示してみます｡

04:14.750 --> 04:18.000
これは全く問題なく動作するので､ これを使うことができます｡ 

04:18.000 --> 04:21.210
Reactをご存知の方ならご存知だと思いますが､

04:21.210 --> 04:29.200
Reactのファイル､ つまりReactコンポーネントにJSXのコードを書くときに使うJavaScriptやTypeScriptの中にも､

04:29.200 --> 04:33.550
このようなアングルブラケット構文があるんですよ｡

04:33.550 --> 04:36.060
さて､ Reactをご存じない方には､ あまりピンとこないかもしれませんね｡ 

04:36.060 --> 04:43.320
Reactのプロジェクトでも同様の構文がありますが､ そこでは角括弧は使用している型に関する情報を渡すために使われるのではなく､

04:43.320 --> 04:54.390
いくつかのビルドツールとReactによって解析され､ 最終的に画面に何をレンダリングしたいかがわかるようになっていることに注意してください｡

04:54.390 --> 04:56.750
だから､ TypeScriptとは完全に切り離されている｡ 

04:56.750 --> 05:04.350
このJSXの構文と衝突しないように､ TypeScriptチームはこのアングルブラケットによる型変換の代替手段を提供している｡

05:04.350 --> 05:07.920
また､ キャストを入力したいものの後に何かを追加することもできますので､

05:07.920 --> 05:12.600
この場合はこの選択の後に､ その何かがasキーワードとなります｡

05:12.600 --> 05:16.750
そして､ ここで再び､ これをキャストしたい型を追加します｡

05:16.750 --> 05:19.970
つまり､ これはTypeScriptの前にある式､

05:19.970 --> 05:27.405
この場合はここにある式がHTMLInputElement型の値を生成することを伝えているのである｡

05:27.405 --> 05:30.067
したがって､ 今回もエラーは出ません｡ 

05:30.067 --> 05:33.940
この2つの構文を交互に使わないように､

05:33.940 --> 05:42.377
プロジェクト全体で一貫性を保つようにしましょう｡

05:42.377 --> 05:45.220
そして､ この貴重な追加情報をTypeScriptに渡すことで､

05:45.220 --> 05:47.480
このようなコードを動作させることができる｡

05:47.480 --> 05:56.000
たとえTypeScript単独では､ ここがHTMLInputElementを生成していることを知ることができなくてもだ｡

05:56.000 --> 05:57.940
もちろん､ TypeScriptにこの型を使わせるのだから､

05:57.940 --> 06:05.620
この式が生み出すものがその型であることを保証するのは開発者としてのあなたの責任である｡

06:05.620 --> 06:07.700
そうでなければ､ 実際にサポートされていない方法でその要素を操作しようとすると､

06:07.700 --> 06:14.423
ランタイムエラーが発生したり､ ランタイムに予期しない動作が発生したりする可能性があります｡

06:15.610 --> 06:18.060
つまり､ タイプキャスティングは強力な機能なのです｡ 

06:18.060 --> 06:20.490
このエクスクラメーションマークもそうです｡ 

06:20.490 --> 06:24.820
実はこれ､ もう講座の序盤で少し探りを入れていたんです｡

06:24.820 --> 06:31.090
この感嘆符は､ その前にある式が決してnullを返さないことをTypeScriptに伝えるためのものである｡

06:31.090 --> 06:35.070
そして､ これは､ domから何かを選択したときにnullを返す可能性のある､

06:35.070 --> 06:38.010
このようないくつかの式に必要です｡

06:38.010 --> 06:40.980
開発者として､ これが決してnullを返さないことが分かっていれば､

06:40.980 --> 06:43.690
この感嘆符を使うことができるのです｡

06:43.690 --> 06:45.470
そうでない場合は､ もうお分かりだと思いますが､

06:45.470 --> 06:48.248
その点をもう一度確認したいと思います｡

06:48.248 --> 06:49.380
そうでない場合､ これがnullを返さないことが確実でない場合は､

06:49.380 --> 06:52.600
ifチェックを使用することができます｡

06:52.600 --> 06:57.510
そこで､ userInputElementがtrueであるか､ つまりnullでないかをチェックし､

06:57.510 --> 06:59.440
そこで使用することができます｡

06:59.440 --> 07:04.670
というのも､ ここで型キャストをすると､ TypeScriptに「これはNULLにはならないよ」とも伝えることになるので､

07:04.670 --> 07:10.470
それが確実でない以上､ ここでキャストをするわけにはいかないからです｡

07:10.470 --> 07:13.120
その代わり､ 値を使うときにここでそれをしなければならないので､

07:13.120 --> 07:14.290
valueプロパティにアクセスする前に､

07:14.290 --> 07:19.820
このようにHTMLInputElementとして追加することで行いたいのです｡

07:19.820 --> 07:21.530
しかし､ それはもちろん失敗します｡ 

07:21.530 --> 07:28.030
これは無効な構文です｡ HTMLInputElementのもののvalueプロパティにアクセスしようとするのでしょうが､

07:28.030 --> 07:30.280
これは意味すらありません｡

07:30.280 --> 07:33.010
この式を括弧で囲んで､ まずこの式が評価されるようにし､

07:33.010 --> 07:39.480
次にこの式の結果の値にアクセスするようにすればいいのです｡

07:39.480 --> 07:42.893
そして､ 感嘆符を使うという選択肢も出てきました｡
