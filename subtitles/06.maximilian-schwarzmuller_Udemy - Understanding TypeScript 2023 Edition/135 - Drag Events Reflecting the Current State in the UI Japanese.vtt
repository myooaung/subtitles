WEBVTT

00:02.320 --> 00:03.570
講師：ドロップできるようにするためには､

00:03.570 --> 00:05.090
最終的にドラッグターゲットとして機能する､

00:05.090 --> 00:11.600
節またはアプリケーションのコンポーネントに移動する必要があります｡

00:11.600 --> 00:14.120
そこで､ プロジェクト・リスト・クラスが正しい節となり､

00:14.120 --> 00:20.130
そこに追加した2番目のインターフェースであるドラッグ・ターゲット・インターフェースを実装することができます｡

00:20.130 --> 00:26.510
さて､ ドラッガブル・インターフェイスと同じように､ これは特定のメソッドを追加することを強制します｡

00:26.510 --> 00:33.500
正確には､ ドラッグオーバーハンドラ､ ドロップハンドラ､ ドラッグリーブハンドラを追加する必要があります｡

00:33.500 --> 00:34.540
では､ そうしましょう｡ 

00:34.540 --> 00:38.640
多分､ 全てはこのconfigureの上のコンストラクタの下にあると思います｡ 

00:38.640 --> 00:40.080
具体的な場所は自由で､

00:40.080 --> 00:42.880
方法の順番は問わない｡

00:42.880 --> 00:49.730
ここでは､ ドラッグイベントを取得するためのドラッグオーバーハンドラを追加します｡

00:49.730 --> 00:51.850
次に､ ここにドロップハンドラを追加して､

00:51.850 --> 00:54.203
ドラッグイベントも取得します｡

00:55.710 --> 01:02.260
そして最後に､ ドラッグイベントを取得するドラッグリーブハンドラーです｡

01:02.260 --> 01:05.410
ところで､ これらのイベントは､ 異なる種類のデータを保持しますが､

01:05.410 --> 01:08.594
すべてケースコアのイベントタイプに基づいています｡

01:08.594 --> 01:11.860
これで､ いろいろなことができるようになりました｡ 

01:11.860 --> 01:15.120
まず､ ドラッグオーバーハンドラから始めましょう｡ 

01:15.120 --> 01:18.770
ドラッグオーバーハンドラでは､ ボックスや順序なしリストの外観を変更し､

01:18.770 --> 01:24.470
これがドロップ可能な領域であることを視覚化したいと思います｡

01:24.470 --> 01:30.200
なぜなら､ 今､ 要素をドラッグしても､ どこにドロップできるかの手がかりが得られないからです｡

01:30.200 --> 01:33.410
UIは何も変わらないので､ これを変えたい｡ 

01:33.410 --> 01:38.680
これを変更するために､ cssのある句を順序なしリストに追加します｡

01:38.680 --> 01:38.680
cssを使用します｡ 

01:38.680 --> 01:42.080
背景色を変更するdropable節､ したがってここでは､

01:42.080 --> 01:49.070
手始めに､ 順序なしリスト要素にアクセスする必要があるだけです｡

01:49.070 --> 01:53.850
この要素に手を伸ばせば､ querySelectror

01:53.850 --> 02:00.963
uLと感嘆符を追加することができます｡

02:02.560 --> 02:05.570
このキーワードがここで機能することを確認する必要があります｡

02:05.570 --> 02:08.600
このキーワードが周囲の節にバインドされていることを確認するために､

02:08.600 --> 02:12.840
ここでこれを自動バインドすることでそれを行うことができます｡

02:12.840 --> 02:15.610
そして､ リスト要素を選択した状態で､ dom要素のclause

02:15.610 --> 02:19.550
listプロパティ､ つまりここでもVanilla JavaScriptを使い､

02:19.550 --> 02:27.540
そこにaddメソッドを呼び出して､ ドロップ可能なclauseを追加することができるのです｡

02:27.540 --> 02:29.360
これで､ この要素やレンダリングされた部分の上に何かをドラッグしたときに､

02:29.360 --> 02:37.333
dragOverHandler が実際に発生することを確認する必要があります｡

02:39.090 --> 02:42.400
そのために､ configureメソッドで､

02:42.400 --> 02:46.020
すでにリスナーが1つあり､ 状態の変化を聞いていますが､

02:46.020 --> 02:50.280
要素自体にもリスナーを登録することにします｡

02:50.280 --> 02:53.380
最初のEventListenerはもちろんドラッグオーバーイベントで､

02:53.380 --> 02:58.090
当然のことながら､ これをdragOverHandlerにバインドします｡

02:58.090 --> 03:01.060
dragLeave イベントをリッスンしてこれを dragLeaveHandler

03:01.060 --> 03:03.740
にバインドし､ drop イベントをリッスンしてこれを

03:03.740 --> 03:10.583
dropHandler にバインドする必要があるので､ これを繰り返します｡

03:11.580 --> 03:16.500
これで､ ドラッグオーバーイベントリスナーと dragOverHandler

03:16.500 --> 03:21.780
が接続されましたが､ コードにいくつかのエラーが発生しました｡

03:21.780 --> 03:24.610
さて､ ここで未使用のイベントオブジェクトがあるはずなので､

03:24.610 --> 03:28.810
とりあえずtypescriptを満たすために､ それらを空白にしましょう｡

03:28.810 --> 03:31.477
後で必要になるのですが､ とりあえず､ この機能を実現するために､

03:31.477 --> 03:37.670
ここでアンダースコアを使って空白にし､ typescriptに「今は使わなくても大丈夫ですよ」と伝えましょう｡

03:37.670 --> 03:37.670
プロジェクトに戻り､

03:37.670 --> 03:38.950
新しいプロジェクトを追加してこれをドラッグすると､

03:38.950 --> 03:45.320
完成したプロジェクトの上にこれをドラッグしたとき､ 背景が水色になったのがわかります｡

03:45.320 --> 03:53.270
ここでは､ アクティブプロジェクトで､ ほんのりピンクのようなライトローズになりました｡

03:53.270 --> 03:58.650
ドラッグを始めるとすぐに､ このボックスの背景がライトピンクになり､

03:58.650 --> 04:09.470
完成したプロジェクトの上にドラッグすると､ ボックスの背景がライトブルーに変わります｡

04:09.470 --> 04:13.360
今は､ そのドロップ可能な句を削除していないので､ 白に戻ることはありませんが､

04:13.360 --> 04:16.050
これは最初の一歩です｡

04:16.050 --> 04:19.480
もちろん､ それでも落とせません｡ 

04:19.480 --> 04:23.890
ここに落としても､ プロジェクトが追加されるわけではありません｡

04:23.890 --> 04:25.300
このためのロジックは追加していません｡ 

04:25.300 --> 04:28.200
そこで､ 停止するとき､ つまり要素から離れるときにも､

04:28.200 --> 04:33.200
スタイリングを更新するようにしましょう｡

04:33.410 --> 04:36.390
基本的にこちらに引きずってきては､ どこかに行ってしまう｡ 

04:36.390 --> 04:39.670
その際､ 青い背景が消えることを確認してください､

04:39.670 --> 04:42.640
それが次にやりたいことです｡

04:42.640 --> 04:44.870
ドラッグされた要素でこの要素から離れるときはいつでも

04:44.870 --> 04:47.020
DragLeaverHandler

04:47.020 --> 04:50.990
が起動するので､ これを使用します｡

04:50.990 --> 04:53.019
もちろん､ 順序なしリストにもアクセスしたいので､

04:53.019 --> 05:01.420
そのコードをコピーして､ dropable節を削除します｡

05:01.420 --> 05:05.553
ここで､ thisキーワードが周囲の節を参照するように､

05:06.448 --> 05:11.220
thisも自動バインドする必要があります｡

05:11.220 --> 05:13.120
これを保存すると､ ここに新しい要素が追加されます｡ 

05:14.040 --> 05:17.740
試してみよう｡ 

05:17.740 --> 05:18.773
私がドラッグを始めると､

05:20.310 --> 05:23.740
ここに私たちの背景があることがわかりますし､ 私が離れると､ それはなくなります｡

05:24.610 --> 05:27.120
それで今､ 本当に背景が更新されました｡ 

05:27.120 --> 05:29.930
マウスカーソルが背景上にある状態からレンダリングされた要素上にある状態になった場合にも

05:29.930 --> 05:40.960
dragLeave イベントが発生するため､ ここでちらつきが見られますが､ ここでは問題ないはずです｡

05:40.960 --> 05:42.500
ここでは大したことではありません｡ 

05:42.500 --> 05:43.620
だから実は､ 期待通りの効果が得られたと言える｡ 

05:43.620 --> 05:47.320
ですから､ UIは今ちょうどアップデートされていますが､

05:47.320 --> 05:50.950
もちろん､ ドロップして本当にデータを転送することはできないので､

05:50.950 --> 05:54.700
それは次のステップになりますね｡
