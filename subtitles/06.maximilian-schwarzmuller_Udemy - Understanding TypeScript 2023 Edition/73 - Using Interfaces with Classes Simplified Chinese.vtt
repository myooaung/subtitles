WEBVTT

00:02.260 --> 00:08.230
教师：现在我们回到这个界面, 问题是我们为什么需要这个界面？

00:08.230 --> 00:10.160
如果我们在这里和那里添加一个自定义类型,

00:10.160 --> 00:13.420
我们会得到完全相同的结果吗？

00:13.420 --> 00:15.580
区别在于我们必须加上一个等号,

00:15.580 --> 00:18.470
然后我们说Person类型是一个对象,

00:18.470 --> 00:19.940
看起来像这样？

00:19.940 --> 00:21.490
事实上, 如果我们保存它,

00:21.490 --> 00:23.220
它编译时就不会出错｡

00:23.220 --> 00:28.490
因此, 我们可以用这样的类型替换我们的接口, 它就像以前一样工作了｡

00:28.490 --> 00:31.290
那么为什么我们有一个接口呢？

00:31.290 --> 00:35.310
当然, 接口和自定义类型并不完全相同,

00:35.310 --> 00:43.520
通常, 您可以互换使用它们, 您可以使用接口代替自定义类型, 或者相反｡

00:43.520 --> 00:45.720
也有一些差异｡ 

00:45.720 --> 00:49.070
一个本质上的区别是接口只能用来描述对象的结构,

00:49.070 --> 00:51.470
你也可以用类型来描述, 但是除了自定义类型,

00:51.470 --> 01:00.350
你还可以存储其他的东西, 比如联合类型等等, 我们在前面的课程中已经做过了.

01:00.350 --> 01:03.740
这听起来像是类型因此更灵活,

01:03.740 --> 01:08.510
但硬币的另一面是界面更清晰｡

01:08.510 --> 01:10.870
当你把某个东西定义为一个接口时,

01:10.870 --> 01:15.580
很明显你想用它来定义一个对象的结构｡

01:15.580 --> 01:18.360
事实上, 当涉及到定义对象类型时,

01:18.360 --> 01:21.630
您更经常看到接口在野外｡

01:21.630 --> 01:23.800
然后, 您会看到自订型别｡ 

01:23.800 --> 01:26.410
现在, 另一件你可以用接口做的事情,

01:26.410 --> 01:27.530
但你只能用自定义类型做,

01:27.530 --> 01:33.360
那就是你可以在一个类中实现一个接口｡

01:33.360 --> 01:34.820
我们这样说是什么意思？

01:34.820 --> 01:38.360
您经常使用接口的原因是,

01:38.360 --> 01:40.550
接口可以用作类可以实现的协定,

01:40.550 --> 01:46.400
然后类必须遵守该协定｡

01:46.400 --> 01:48.150
这是什么意思？

01:48.150 --> 01:52.390
假设我们的接口不是一个有名字和年龄的Person接口,

01:52.390 --> 01:57.690
而是我们把它命名为Greetable｡

01:57.690 --> 01:59.270
这看起来可能是个奇怪的名字,

01:59.270 --> 02:09.251
但最后这只是说, 任何应该被视为Greetable的对象必须是有名字和greet方法的对象｡

02:09.251 --> 02:10.783
现在我们可以这样说,

02:10.783 --> 02:14.630
user1变量应该包含Greetable对象, 当然,

02:14.630 --> 02:19.930
现在我们得到了一个错误, 因为我们不止有name和greet.

02:19.930 --> 02:22.000
但是我们可以用这个接口在多个类之间共享它,

02:22.000 --> 02:33.410
我们必须确保每个类都有一个name属性, 并且有一个greet方法｡

02:33.410 --> 02:35.730
在这里, 我们现在可以添加一个Person类,

02:35.730 --> 02:36.970
因为我们重命名了接口,

02:36.970 --> 02:38.540
所以名称再次可用｡

02:38.540 --> 02:40.790
现在, 告诉typescript,

02:40.790 --> 02:45.480
这个类应该基本上遵守这个接口｡

02:45.480 --> 02:48.350
它应该实作这个界面｡ 

02:48.350 --> 02:53.000
它应该遵循该接口合同设置｡ 

02:53.000 --> 02:56.930
我们通过在类名后面添加implements关键字来实现这一点｡

02:56.930 --> 02:59.280
然后是接口的名称Greetable｡ 

03:00.420 --> 03:02.780
并且可以实现多个接口｡ 

03:02.780 --> 03:04.710
这和继承是有区别的｡ 

03:04.710 --> 03:07.270
你可以只从一个类继承, 你可以实现多个接口,

03:07.270 --> 03:09.370
只要用逗号分隔它们, 所以,

03:09.370 --> 03:16.000
如果我们有一个接口的话, 我们可以有另一个接口｡

03:16.000 --> 03:17.710
我只有一个｡ 

03:17.710 --> 03:21.740
现在, 这意味着我们在这里得到了一个错误,

03:21.740 --> 03:25.200
因为我们的类错误地实现了接口｡

03:25.200 --> 03:27.240
它没有name属性,

03:27.240 --> 03:29.690
也没有greet方法｡

03:29.690 --> 03:35.610
现在, 我们要在类中设置这个, 也许我会设置一个构造函数,

03:35.610 --> 03:38.173
在那里我们可以得到name的值,

03:39.010 --> 03:48.080
然后像这样设置, 我们还要添加greet方法, 这样我们就可以得到这个逻辑了.

03:48.080 --> 03:50.780
现在, 在我们的课堂上, 我们可以有更多的｡ 

03:50.780 --> 03:52.340
我们可以有更多的字段,

03:52.340 --> 03:53.920
我们可以有更多的方法,

03:53.920 --> 03:59.170
我们也可以扩展这个类, 我们可以像往常一样使用这个类｡

03:59.170 --> 04:04.400
但是我们必须正确地实现这个方法才能有这个name属性,

04:04.400 --> 04:07.040
因为我们要实现这个接口.

04:07.040 --> 04:09.740
因此, 接口经常被用来在不同的类之间共享功能,

04:09.740 --> 04:16.550
而不考虑它们的具体实现｡

04:16.550 --> 04:19.240
你不能在接口内部有实现或值,

04:19.240 --> 04:24.980
但要考虑到结构, 考虑到类应该具有的特性｡

04:24.980 --> 04:29.640
这有点像使用抽象类, 不同之处在于接口没有实现细节,

04:29.640 --> 04:42.470
而抽象类可以是你必须重写这些部分, 而我有具体实现部分的混合体.

04:42.470 --> 04:46.860
这是接口和抽象类之间的一个重要区别｡

04:46.860 --> 04:49.790
现在我们有了person类｡

04:49.790 --> 04:55.930
现在, 可以使用new Person创建user1,

04:55.930 --> 04:58.090
并输入名称｡

04:58.090 --> 05:02.300
现在, 在user1中有这个年龄是没问题的因为我们基于Person来绑定user1,

05:02.300 --> 05:15.120
Person实现了Greetable, 你可以在一个类中添加更多Greetable, 但是你必须满足接口设置的条件.

05:15.120 --> 05:17.130
因此, 现在, 如果我们保存所有内容,

05:17.130 --> 05:18.730
我们就有了一个有效的代码,

05:18.730 --> 05:25.430
如果我们用控制台登录user1｡ 日志中, 我们可以看到它是一个普通的对象,

05:25.430 --> 05:27.590
在本例中具有年龄和名称,

05:27.590 --> 05:32.770
但关键的一点是它基于一个实现接口的类｡

05:32.770 --> 05:35.550
然后, 您可以将接口用作类型｡ 

05:35.550 --> 05:37.780
当然, 我们可以将其设置为Person类型,

05:37.780 --> 05:40.580
但正如您所看到的, 在这里使用Greetable类型是可行的,

05:40.580 --> 05:46.300
因为我们最终存储在user1类中的Person对象是基于Greetable接口的｡

05:46.300 --> 05:47.750
它实现了这一点｡ 

05:47.750 --> 05:49.820
这是另一个强大的功能｡ 

05:49.820 --> 05:53.690
你可以使用一个接口作为某个常量或变量的一个类型,

05:53.690 --> 05:58.010
它将实际存储另一个类型的另一个类, 而这个类又基于接口类型,

05:58.010 --> 06:03.950
因为它实现了接口类型｡

06:03.950 --> 06:06.530
这就是界面的简单介绍｡ 

06:06.530 --> 06:08.643
包括很多强大的功能｡ 
