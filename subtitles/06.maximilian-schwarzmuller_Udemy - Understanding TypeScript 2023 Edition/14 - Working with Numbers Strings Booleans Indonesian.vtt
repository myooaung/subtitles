WEBVTT

00:01.850 --> 00:03.270
Instruktur: Jadi sekarang

00:03.270 --> 00:06.760
kita tahu tentang dasar-dasar TypeScript dan bagaimana perbedaannya

00:06.760 --> 00:09.661
dan semua ini terkait dengan JavaScript, mari kita gali

00:09.661 --> 00:11.410
lebih dalam tentang berbagai jenis

00:11.410 --> 00:14.148
inti yang diketahui TypeScript.

00:14.148 --> 00:17.490
Angka adalah tipe yang kita lihat di sini, dan seperti yang saya jelaskan,

00:17.490 --> 00:18.500
tidak ada perbedaan antara

00:18.500 --> 00:22.050
bilangan bulat seperti lima di sini dan float atau double, seperti yang akan

00:22.050 --> 00:24.330
disebut dalam bahasa pemrograman lain, seperti

00:24.330 --> 00:25.640
2. 8 di sini.

00:25.640 --> 00:28.440
Memang, dalam JavaScript, dan hal yang sama berlaku di TypeScript,

00:28.440 --> 00:30.810
semua angka adalah float secara default.

00:30.810 --> 00:33.270
Jadi, untuk JavaScript, dan oleh karena itu, juga untuk

00:33.270 --> 00:35.171
TypeScript, tidak ada perbedaan antara lima

00:35.171 --> 00:36.770
seperti ini dan lima seperti ini.

00:36.770 --> 00:38.640
Ini adalah angka yang sama, pada dasarnya.

00:38.640 --> 00:42.720
Sekarang, selain angka, kita juga memiliki jenis inti lainnya.

00:42.720 --> 00:46.350
Dan itu akan berupa string, jadi teks, dan boolean.

00:46.350 --> 00:47.800
Mari kita juga melihat semua itu.

00:47.800 --> 00:50.650
Kita sebenarnya sudah melihat semua itu beraksi di sini dalam

00:50.650 --> 00:53.291
pernyataan if ini, yang kita pelajari agak berlebihan.

00:53.291 --> 00:55.971
Meskipun demikian, ini di sini akan menjadi sebuah string.

00:55.971 --> 00:57.720
Juga, tentu saja, lima dengan tanda

00:57.720 --> 01:00.389
kutip akan menjadi string karena itu adalah teks.

01:00.389 --> 01:03.851
Dan hasilnya, misalnya, dari perbandingan ini di sini, itu

01:03.851 --> 01:05.170
akan menjadi boolean.

01:05.170 --> 01:08.090
Operator ini, tanda sama dengan tiga kali lipat

01:08.090 --> 01:10.950
atau operator kesetaraan yang dinegasikan di

01:10.950 --> 01:13.640
sini, yang menghasilkan true atau false.

01:13.640 --> 01:14.720
Dan, tentu saja, kita bisa

01:14.720 --> 01:17.340
menghasilkan pemeriksaan innerRef secara dinamis,

01:17.340 --> 01:18.850
yang sering kita lakukan.

01:18.850 --> 01:22.340
Atau kita menginisialisasi variabel dengan nilai true atau false, jadi mari kita lakukan

01:22.340 --> 01:23.379
keduanya di sini.

01:23.379 --> 01:27.509
Di sini, kita bisa menambahkan konstanta baru, "printResult".

01:27.509 --> 01:29.990
Dan menetapkan ini ke true, misalnya.

01:29.990 --> 01:31.320
Dan untuk membuatnya benar-benar

01:31.320 --> 01:33.130
jelas, ini bisa menjadi variabel juga.

01:33.130 --> 01:34.460
Tidak harus const.

01:34.460 --> 01:36.030
Ini bisa berupa variabel, yang akan Anda

01:36.030 --> 01:37.730
buat dengan let dalam JavaScript.

01:37.730 --> 01:39.870
Tetapi karena saya tidak berencana mengubahnya di sini, saya akan

01:39.870 --> 01:40.703
menggunakan konstanta.

01:40.703 --> 01:43.670
Dan kita bisa melewatkan ini sebagai parameter ketiga di sini.

01:43.670 --> 01:46.960
Katakanlah kita mengoper "printResult", yang berlaku di sini.

01:46.960 --> 01:49.720
Sekarang kita langsung mendapatkan error, tentu

01:49.720 --> 01:53.160
saja, karena fungsi add kita tidak mendukung argumen ketiga.

01:53.160 --> 01:55.560
Kita melihat, "Mengharapkan dua argumen tetapi mendapatkan tiga argumen".

01:55.560 --> 01:57.260
Jadi, oleh karena itu, kita harus memastikan

01:57.260 --> 01:58.920
bahwa kita mendukung argumen ketiga.

01:58.920 --> 02:03.920
Dan di sana, kita bisa menambahkan parameter "showResult".

02:03.940 --> 02:05.920
Anda bisa menamainya "printResult" di sini juga.

02:05.920 --> 02:07.910
Saya menggunakan "showResult" untuk menghindari

02:07.910 --> 02:11.340
kebingungan mengenai penamaan, tetapi, secara teknis, kedua nama ini tidak

02:11.340 --> 02:12.930
akan berbenturan.

02:12.930 --> 02:14.320
Jadi, di sini, saya akan menamakannya "showResult".

02:14.320 --> 02:17.580
Dan saya ingin memastikan bahwa ini bertipe boolean dengan

02:17.580 --> 02:19.500
mengatur ini ke boolean.

02:19.500 --> 02:22.109
Sekali lagi, dengan menambahkan titik dua setelah parameter

02:22.109 --> 02:25.120
di sini dan kemudian dengan menambahkan nama jenisnya.

02:25.120 --> 02:28.100
Sekarang fungsi ini menerima ini, dan sekarang apa yang dapat

02:28.100 --> 02:31.787
kita lakukan adalah kita dapat menambahkan pemeriksaan if di sini dan memeriksa

02:31.787 --> 02:35.610
"if showResult", jika ini benar, tentu saja kita dapat membandingkannya dengan

02:35.610 --> 02:36.480
true.

02:36.480 --> 02:37.628
Tetapi seperti yang Anda

02:37.628 --> 02:41.990
ketahui dalam JavaScript, Anda juga bisa memasukkan nilai truthy atau falsy di sini.

02:41.990 --> 02:43.970
Dan JavaScript akan mengevaluasinya, dan jika

02:43.970 --> 02:47.389
ini menghasilkan true entah bagaimana atau nilai kebenaran secara umum, maka kita

02:47.389 --> 02:48.989
akan membuatnya menjadi blok if.

02:48.989 --> 02:50.011
Jika tidak, kami tidak akan melakukannya.

02:50.011 --> 02:52.900
Dan katakanlah kita berhasil masuk ke sini, dan kemudian

02:52.900 --> 02:55.429
saya ingin "konsol. log n1 ditambah n2".

02:55.429 --> 02:58.581
Jika tidak, dalam kasus lain, jika kita tidak berhasil masuk ke sana,

02:58.581 --> 03:00.549
maka saya ingin mengembalikan ini.

03:00.549 --> 03:02.300
Jadi sekarang ini adalah fungsi yang

03:02.300 --> 03:04.760
terkadang mengembalikan nilai dan terkadang tidak

03:04.760 --> 03:08.309
mengembalikan nilai, tetapi langsung mengeluarkannya.

03:08.309 --> 03:11.550
Sekarang Anda bisa berargumen, jika Anda ingin menulis fungsi

03:11.550 --> 03:14.310
seperti itu, yang tidak dapat diprediksi atau yang

03:14.310 --> 03:16.651
mungkin berperilaku tidak terduga jika Anda

03:16.651 --> 03:18.349
melewatkan true di sini.

03:18.349 --> 03:19.990
Tetapi di sini, kami melakukannya.

03:19.990 --> 03:22.090
Jadi fungsi ini hanya kadang-kadang saja kembali.

03:22.090 --> 03:24.869
Kadang-kadang juga tidak kembali, tetapi

03:24.869 --> 03:27.830
hanya mencatat sesuatu ke konsol.

03:27.830 --> 03:31.120
Nah di sini, kita sebenarnya bisa memanggil add seperti

03:31.120 --> 03:33.640
ini dan tidak perlu menyimpannya di result

03:33.640 --> 03:37.570
dan tidak perlu console. hasil log karena, dengan "printResult"

03:37.570 --> 03:39.550
disetel ke true, tambahkan sendiri.

03:39.550 --> 03:41.869
Jadi fungsi itu sendiri akan mencetak hasilnya.

03:41.869 --> 03:43.640
Oleh karena itu, jika sekarang kita menyimpan

03:43.640 --> 03:47.880
itu dan kita mengkompilasi ulang aplikasi kita. ts di sini dengan perintah tsc.

03:47.880 --> 03:50.830
Setelah ini selesai, halaman akan dimuat ulang, dan kita masih

03:50.830 --> 03:52.600
melihat output kita di sini.

03:52.600 --> 03:54.677
Tetapi sekarang datang dari baris keenam.

03:54.677 --> 03:57.690
Dan jika kita lihat, baris keenam memang berada

03:57.690 --> 03:58.980
di dalam fungsi.

03:58.980 --> 03:59.891
Jadi ini adalah boolean.

03:59.891 --> 04:02.429
Sekarang katakanlah kita ingin menyesuaikan output.

04:02.429 --> 04:06.190
Dalam if di sini, kita memiliki konstanta "resultPhrase" di sini di mana

04:06.190 --> 04:10.181
kita mengatakan, "Result is" titik dua dan kemudian beberapa ruang putih.

04:10.181 --> 04:14.205
Dan kita juga mengopernya dengan "resultPhrase" di sini.

04:14.205 --> 04:17.410
Nah, maka kita bisa mengharapkan ini sebagai argumen di sini juga.

04:17.410 --> 04:20.750
Frasa, yang akan menghasilkan string pipa, dengan menambahkan titik dua.

04:20.750 --> 04:22.291
Dan kemudian string adalah nama

04:22.291 --> 04:26.469
jenisnya, dan sekarang kita bisa menggunakan frasa itu untuk mengeluarkannya sebagai

04:26.469 --> 04:31.193
bagian dari output hasil kita jika kita mencetak hasilnya tepat di dalam fungsi.

04:31.193 --> 04:34.789
Jadi, di sini, kita bisa memiliki "frasa plus n1 plus n2".

04:34.789 --> 04:37.440
Dan jika kita melakukan itu dan kita mengompilasi ulang dengan

04:37.440 --> 04:39.040
mengulangi perintah itu, kita akan

04:39.040 --> 04:41.720
melihat bahwa frasa ini adalah bagian dari hasilnya.

04:41.720 --> 04:44.861
Tetapi kami juga, sekarang, memperkenalkan kembali bug lama karena

04:44.861 --> 04:48.141
saya memiliki string, yang saya gabungkan dengan dua angka.

04:48.141 --> 04:52.000
Semuanya dikonversi ke string di sini, dan bukan itu yang

04:52.000 --> 04:53.240
saya inginkan.

04:53.240 --> 04:55.930
Untuk menghindari hal ini, dalam fungsi ini, kita bisa menambahkan

04:55.930 --> 04:57.708
variabel hasil di sini.

04:57.708 --> 05:02.027
Atau konstanta hasil dan menyimpan hasil kita di sini.

05:02.027 --> 05:04.530
Ini sekarang akan diperlakukan secara matematis

05:04.530 --> 05:07.990
karena hanya angka yang terlibat, dan kemudian, di sini, kita bisa

05:07.990 --> 05:11.430
menggabungkannya dengan frasa atau hanya mengembalikannya.

05:11.430 --> 05:15.160
Dan sekarang, karena ini tidak pernah secara langsung dikalkulasi bersama dengan

05:15.160 --> 05:17.029
string, ini akan selalu berupa angka.

05:17.029 --> 05:19.350
Dan, ya, kemudian di sini, angka ini digabungkan dengan string

05:19.350 --> 05:21.140
ini akan dikonversi menjadi string.

05:21.140 --> 05:24.360
Tetapi karena perhitungan matematis selesai sebelum itu, kita akan mendapatkan

05:24.360 --> 05:25.548
hasil yang benar.

05:25.548 --> 05:28.520
Jadi sekarang jika kita mengulanginya dan kemudian mengompilasi ulang,

05:28.520 --> 05:30.181
kita mendapatkan output yang benar.

05:30.181 --> 05:33.050
Jadi, sekarang ini adalah tipe data inti yang sedang beraksi.

05:33.050 --> 05:35.541
Sekarang mari kita pastikan bahwa kita sepenuhnya

05:35.541 --> 05:38.061
memahami bagaimana tipe ditetapkan dan, juga, mengapa

05:38.061 --> 05:41.343
kita tidak secara eksplisit menetapkan tipe di sana.
