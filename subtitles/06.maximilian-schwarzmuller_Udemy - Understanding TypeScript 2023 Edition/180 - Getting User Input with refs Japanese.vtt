WEBVTT

00:02.240 --> 00:04.870
発表者：さて､ 最初のコンポーネントが追加されました｡ 

00:04.870 --> 00:06.090
2つ目を追加しよう｡ 

00:06.090 --> 00:09.970
NewTodoです｡  tsxはファイル名です｡ 

00:09.970 --> 00:13.060
もちろんその中で､ reactからreactをインポートしています｡ 

00:13.060 --> 00:16.170
また､ クラスベースのコンポーネントを作ることももちろん可能です｡ 

00:16.170 --> 00:18.270
これも完全にサポートされていますが､

00:18.270 --> 00:22.410
私はこのモダンファンクショナルコンポーネントのみのスタイルでいきます｡

00:22.410 --> 00:26.180
ここで再び､ 後でコンポーネントを構成する関数を用意しました｡

00:26.180 --> 00:29.258
そして､ NewTodoをデフォルトとしてエクスポートし､ タイプアサインを追加して､

00:29.258 --> 00:34.410
これがタイプファンクション・コンポーネントであることを明確にしましょう｡

00:34.410 --> 00:35.800
したがって､ もちろんここでは､

00:35.800 --> 00:38.220
返されたjsxのコードが欠落しています｡

00:38.220 --> 00:43.780
ここでは､ ユーザーが新しいTODOを追加できるようにするために必要なすべてのコントロールを追加するフォームを返します｡

00:45.060 --> 00:48.650
では､ この新しいTodoコンポーネントをアプリコンポーネントに追加してみましょう｡ 

00:48.650 --> 00:53.650
ここでは､ NewTodoを.NETからインポートします｡  /components/NewTodo

00:55.130 --> 00:58.095
とコメント代わりにここに追加するだけです｡

00:58.095 --> 01:00.520
NewTodo を自己閉鎖型コンポーネントとして使用するのは､

01:00.520 --> 01:04.750
現在､ 開始タグと終了タグの間に何も渡しておらず､ また､ 少なくとも現時点では､

01:04.750 --> 01:09.263
ここにプロップがないからです｡

01:10.140 --> 01:11.540
つまり､ このコンポーネントの代わりに､

01:11.540 --> 01:16.190
入力を追加し､ さらにその後にボタンを追加することができるのです｡

01:16.190 --> 01:18.117
ここに div を追加し､ htmlFor

01:18.117 --> 01:24.880
属性でラベルを指定して､ たとえば「todo-text」を指すようにしたいと思います｡

01:24.880 --> 01:26.560
これはすべて､ 「Todoテキスト」と言い､

01:26.560 --> 01:31.250
idが「Todoテキスト」のtextタイプのinput要素を指定することで､

01:31.250 --> 01:39.640
ラベルと入力が意味的に正しく接続されるようにした､ ここでのマークアップに過ぎないのです｡

01:39.640 --> 01:41.440
そしてこのdivの下に､ フォームの代わりに「ADD

01:41.440 --> 01:49.670
TODO」というボタンを追加し､ そのボタンはフォームを送信するようにsubmitタイプにします｡

01:49.670 --> 01:53.143
これで､ 新しいTodoを追加するのに使える非常に基本的なフォームができました｡

01:54.580 --> 01:57.060
さて､ これがうまくいくことを確認しましょう｡

01:57.060 --> 02:01.820
そのためには､ 実際にいくつかの異なるステップを適用する必要があります｡

02:01.820 --> 02:05.020
ここでユーザーが入力した内容を取得し､ アプリコンポーネントに転送する必要があります｡

02:05.020 --> 02:13.330
なぜなら､ アプリコンポーネントは後でTODOを管理する場所だからです｡

02:13.330 --> 02:16.150
そこでまず､ フォーム送信に反応してみましょう｡ 

02:16.150 --> 02:18.050
新しい関数を追加することができます｡

02:18.050 --> 02:20.300
関数コンポーネントの関数は､ 通常の関数になりますが､

02:20.300 --> 02:27.720
ここでは「todoSubmitsHandler」という好きな名前にします｡

02:28.210 --> 02:31.860
これは､ このフォームが送信されるたびに実行される関数です｡

02:31.860 --> 02:35.571
これを最後にある onSubmit プロパにバインドして､

02:35.571 --> 02:38.770
todoSubmitsHandler を実行せずに指定するだけで､

02:38.770 --> 02:43.810
このフォームが送信されるたびに実行されます｡

02:43.810 --> 02:49.507
ここで､ イベントオブジェクトを取得し､ イベントオブジェクトはreactタイプであることを確認します｡

02:49.507 --> 02:49.507
FormEventです｡ 

02:51.290 --> 02:55.780
そこで､ このアプリを提供しているサーバーに実際のリクエストを送るというデフォルトを防ぐために､

02:55.780 --> 02:59.280
イベント防止デフォルトを呼び出したいと思います｡

02:59.280 --> 03:01.520
それはもちろん､ 私が望んでいるときではありません｡ 

03:01.520 --> 03:04.680
私はこのリクエストをJavaScriptの中だけで処理したいので､

03:04.680 --> 03:08.350
このブラウザのデフォルトを防がなければならないのです｡

03:08.350 --> 03:12.610
これで､ ユーザーが入力した内容を取得することができるようになり､

03:12.610 --> 03:15.250
そのために2つの方法を用意しました｡

03:15.250 --> 03:18.310
入力の状態を双方向バインディングで管理するか､

03:18.310 --> 03:26.520
フォームが送信されたときにユーザーが入力した内容をref（参照）で抽出することができます｡

03:26.520 --> 03:30.420
どうせすぐにアプリコンポーネントで状態管理が行われるのだからと､

03:30.420 --> 03:33.470
後者の方法を取ることにする｡

03:33.470 --> 03:40.580
このようなRefを設定するために､ reactからuseRefフックをインポートします｡

03:40.580 --> 03:48.101
フックとは､ コンポーネントに特定の機能を追加するために実行できる特別な関数です｡ ここでuseRefを実行すると､

03:48.101 --> 03:57.310
Refオブジェクトが返されます｡ これは､ 定数に格納できます｡

03:57.310 --> 04:00.176
そして､ 例えば､ このような参照を使用して

04:00.176 --> 04:06.500
dom 要素に割り当て､ この上のコードの中からその dom 要素を操作することができます｡

04:06.500 --> 04:08.800
だから､ たとえばそのフォームが送信されたとき｡ 

04:09.680 --> 04:11.510
このような接続を設定するには､

04:11.510 --> 04:14.020
任意のhtml要素に特別なRefプロップを追加し､

04:14.020 --> 04:19.150
ここで作成したオブジェクトを指すようにします｡

04:19.150 --> 04:21.530
そこで､ textInputRefを追加します｡ 

04:21.530 --> 04:23.540
これが､ ここでのつながりを生み出します｡ 

04:23.540 --> 04:27.380
しかし､ TypeScriptはこれを好まないことは､ もうお分かりでしょう｡ 

04:27.380 --> 04:33.250
なぜなら､ useRefもジェネリック関数であることが判明しているからです｡

04:33.250 --> 04:35.270
さて､ どの型を渡せばいいのだろう｡ 

04:35.270 --> 04:37.340
ここで知っておくと面白いことは？

04:37.340 --> 04:42.030
グラフの中にどのようなデータが格納されるかは興味深いところですが､

04:42.030 --> 04:43.970
input要素を指摘されたので､

04:43.970 --> 04:47.880
htmlのinput要素を格納することにします｡

04:47.880 --> 04:51.840
なぜなら､ コンポーネントが初めてレンダリングされるとき､

04:51.840 --> 04:57.380
このコードが実行されるとき､ もちろんこれはレンダリングされていないので､

04:57.380 --> 05:01.590
これは何も指し示さないからです｡

05:01.590 --> 05:03.350
しかし､ このレンダリングが完了すると､

05:03.350 --> 05:07.040
接続が確立され､ このRefが動作するようになります｡

05:07.040 --> 05:09.453
そして､ ここtodoSubmitHandlerでは､ textInputRefを使って､

05:10.342 --> 05:21.440
入力されたテキストを取得することができます｡ の電流は､ Ref, .と一緒に仕事をするときに必ず入力する必要があるものです｡

05:21.440 --> 05:21.440
の値は､

05:21.440 --> 05:24.530
html input 要素を扱うので､ もちろんここにあります｡

05:24.530 --> 05:27.940
しかし､ ここで問題なのは､ これがNULLになる可能性があることです｡ 

05:27.940 --> 05:29.630
これはすでに分かっている問題で､

05:29.630 --> 05:31.790
コースの初期にDomで何かを選択したときにもありましたし､

05:31.790 --> 05:38.800
ここでも同様です｡ TypeScriptは､ この接続が確立されていることを確実に知ることができないからです｡

05:38.800 --> 05:40.580
私たちはそれを知っていて､ コードを書いたのですが､

05:40.580 --> 05:45.300
残念ながらTypeScriptは､ 私たちが下の方で接続を確立していることを理解していないのです｡

05:46.310 --> 05:48.920
そこで､ この問題を解決するために､ ここにエクスクラメーションマークを追加して､

05:48.920 --> 05:54.350
TypeScriptに「これは大丈夫だ」「これは設定される」と再度伝えることができる｡

05:54.350 --> 05:56.130
ところで､ TypeScriptは､

05:56.130 --> 05:58.920
ここでtodoSubmitHandlerを呼び出すと､

05:58.920 --> 06:00.590
これは前方に呼び出され､ これが初めてレンダリングされ､

06:00.590 --> 06:05.000
そして実際にこれはまだ初期化されていないことになる｡

06:05.000 --> 06:07.910
初期化されることが確実なのは､ これが呼び出されるのはフォームが送信されたときだけで､

06:07.910 --> 06:13.830
それが起こるのはこれがレンダリングされた後だけであることが分かっているからです｡

06:13.830 --> 06:16.120
だから､ 私たちは自分たちのコードがどのように動くかを知っているのです｡ 

06:16.120 --> 06:18.360
これは決してNULLにはならない｡ 

06:18.360 --> 06:26.030
もし他の可能性があるならば､ ここでif-checkを使ってtextInputRef.

06:26.030 --> 06:26.030
current

06:26.030 --> 06:27.620
が NULL である場合､ 他の処理を行う｡

06:27.620 --> 06:29.550
しかし､ ここではそんなことはありえない｡ 

06:29.550 --> 06:34.640
これで値が抽出され､ コンソールができるわけです｡

06:34.640 --> 06:34.640
をここに記録して､ 動作するかどうかを確認してください｡ 

06:34.640 --> 06:37.040
しかし､ もちろんこれはその時の最終的な設定ではない｡ 

06:37.040 --> 06:40.900
そこで､ これを保存し､ ここに入力し､ 1ヶ月で終了させ､

06:40.900 --> 06:47.970
Todoを追加すると､ コンソールログでここに表示されます｡

06:47.970 --> 06:50.310
それが､ あるべき姿として機能している｡ 

06:50.310 --> 06:51.910
そして､ このように動作するようになったので､

06:51.910 --> 06:55.460
今度はその値をアプリコンポーネントに取得するようにしましょう｡

06:55.460 --> 06:58.820
もし､ ある程度反応があれば､ まず自分で試してみてください｡ 

06:58.820 --> 07:00.963
次回の講義で一緒にやりましょう｡ 
