WEBVTT

00:02.250 --> 00:07.811
教师：现在, 在我们探索一些装饰器的更有用的用例或场景之前｡

00:07.811 --> 00:12.550
我想简要地向您展示所有其他可以添加装饰器的地方｡

00:12.550 --> 00:17.731
显然我们可以在类中添加装饰器, 但是我们可以在更多的地方添加装饰器｡

00:17.731 --> 00:22.460
为此, 我将创建一个新类, 因为我们需要一个类来支持我们想要使用的任何装饰器,

00:22.460 --> 00:26.420
但我们不必将所有装饰器直接添加到类中｡

00:26.420 --> 00:28.480
假设我们有一个产品类在产品类中,

00:28.480 --> 00:34.540
我们有一个标题, 是一个字符串.

00:34.540 --> 00:37.070
我们可以在这里用构造函数赋值｡ 

00:37.070 --> 00:39.600
当然, 我们可以使用快捷方式, 在构造函数中一步完成所有操作,

00:39.600 --> 00:42.680
就像您之前学习的那样｡

00:42.680 --> 00:44.451
在这里我会走更长的路｡ 

00:44.451 --> 00:49.451
我们这里可以有一个方法, 把价格和税收结合起来｡ 

00:50.150 --> 00:53.442
为此, 我希望得到一个税率, 这是一个数字,

00:53.442 --> 00:57.150
并为工作, 我们也应该存储在这里的价格｡

00:57.150 --> 01:01.200
Price属性, 我们也可以将其作为构造函数的一部分｡ 

01:01.200 --> 01:05.340
我们也可以走捷径, 但我会这样做｡

01:05.340 --> 01:08.120
然后在这个方法中我会返回,

01:08.120 --> 01:13.120
This. 价格乘以一再加税｡ 

01:13.200 --> 01:15.300
所以我们有这个实用程序方法, 如果你想的话,

01:15.300 --> 01:19.090
我们也可以添加一个getter和setter｡

01:19.090 --> 01:22.700
例如, 我们可以在这里为价格添加一个setter, 在这里我们可以得到一个应该是数字的值,

01:22.700 --> 01:28.231
在这里我们可以控制我们只能设置某些值｡

01:28.231 --> 01:32.090
现在为了让这个工作正常进行, 我将在这里重新命名price,

01:32.090 --> 01:37.540
以强调price, 并使它实际上是私有的, 这样我们就不能直接访问它｡

01:37.540 --> 01:39.970
在这里我将设置这个下划线价格,

01:39.970 --> 01:42.580
在这里我将使用这个下划线价格｡

01:42.580 --> 01:44.800
在setter中做了这些修改后,

01:44.800 --> 01:48.350
我们就可以把这个下划线价格设置为等于我们得到的值｡

01:48.350 --> 01:52.770
但是在我们这样做之前, 我们可以检查value是否大于零,

01:52.770 --> 01:55.630
这样我们就不会接受负价格｡

01:55.630 --> 01:57.220
因此, 我们只在价格大于零时才设定价格,

01:57.220 --> 02:00.159
否则我们什么都不做｡

02:00.159 --> 02:04.330
事实上, 我们可以在另一种情况下抛出一个错误｡ 

02:04.330 --> 02:08.389
无效价格应为正数｡ 

02:08.389 --> 02:11.350
这是我们可以做的, 现在我们有一个类,

02:11.350 --> 02:14.020
有两个属性, 一个访问器, 还有一个方法,

02:14.020 --> 02:18.570
这个方法有一个参数｡

02:18.570 --> 02:21.180
现在, 我们可以添加装饰器,

02:21.180 --> 02:25.910
让我们从一个老朋友开始, 一个原木装饰器｡

02:25.910 --> 02:28.960
在这里我将它命名为log, 以避免与上面的logger冲突,

02:28.960 --> 02:33.770
因为这个日志装饰器不会被添加到一个类中, 因此它将获得不同的参数｡

02:33.770 --> 02:40.030
但是它会得到参数, 装饰器得到哪些参数取决于您将它添加到何处｡

02:40.030 --> 02:41.960
这就是为什么我不能重用logger,

02:41.960 --> 02:45.700
因为它被微调为只与类一起工作｡

02:45.700 --> 02:49.980
这里我实际上没有装饰器工厂, 我只需要像这样装饰一个函数,

02:49.980 --> 02:55.230
但是, 这个装饰器函数得到哪些参数, 取决于我们在哪里使用它｡

02:55.230 --> 02:58.750
例如, 我们可以为属性添加一个装饰器｡ 

02:58.750 --> 03:01.120
这里我可以像这样添加log,

03:01.120 --> 03:03.840
如果你给一个属性添加一个装饰器,

03:03.840 --> 03:05.759
装饰器会收到两个参数｡

03:05.759 --> 03:09.830
第一个参数是属性的目标, 对于像这样的实例属性,

03:09.830 --> 03:15.290
如果使用实例, 我们将在实例上调用它｡

03:15.290 --> 03:19.490
这将是所创建对象的原型｡ 

03:19.490 --> 03:24.850
如果这里有一个静态属性, target将引用构造函数的状态｡

03:24.850 --> 03:30.140
所以这里我会说any, 因为我不知道对象的具体结构是什么｡

03:30.140 --> 03:35.140
我们得到的第二个参数是属性名称｡ 

03:35.290 --> 03:37.682
这里可以是一个字符串,

03:37.682 --> 03:40.400
当然也可以是一个符号｡

03:40.400 --> 03:43.470
我们不知道我们使用什么作为属性标识符｡ 

03:43.470 --> 03:51.120
然后在这里我将记录属性装饰器, 这样我们就可以看到它何时运行,

03:51.120 --> 03:55.980
我想要一个控制台｡ 日志目标和属性名称｡ 

03:55.980 --> 03:57.780
这样我们就能看到这两个值的含义｡ 

03:57.780 --> 04:01.280
如果我们保存它, 这样它编译时就没有错误了,

04:01.280 --> 04:03.080
如果我们转到服务器,

04:03.080 --> 04:06.871
我们会看到, 属性装饰器在那里打印出来｡

04:06.871 --> 04:08.630
这是我们得到的输出｡ 

04:08.630 --> 04:15.850
我们在这里看到的是对象的原型, 因为我们在这里看不到标题和价格｡

04:15.850 --> 04:18.160
但是我们确实看到了get price with

04:18.160 --> 04:21.900
tax, 而且确实方法是在一个对象的原型上注册的｡

04:21.900 --> 04:24.240
这是对象的原型, 我们在右边看到title,

04:24.240 --> 04:28.943
这是我们要使用的属性名.

04:29.800 --> 04:33.770
那么这个记录器到底什么时候执行呢？

04:33.770 --> 04:37.880
正如您所知, 由于我从未实例化过任何产品,

04:37.880 --> 04:43.980
因此它基本上在JavaScript注册类定义时执行｡

04:43.980 --> 04:47.660
所以当你把这个属性定义为JavaScript时,

04:47.660 --> 04:49.140
它就会执行, 作为类的一部分,

04:49.140 --> 04:52.970
作为构造函数的一部分.

04:52.970 --> 04:54.610
最后在这里被创造出来｡ 

04:54.610 --> 04:58.053
这是执行此属性装饰器的时间｡ 
