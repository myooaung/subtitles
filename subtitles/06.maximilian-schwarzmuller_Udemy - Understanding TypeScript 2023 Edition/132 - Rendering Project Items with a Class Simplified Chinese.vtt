WEBVTT

00:02.190 --> 00:05.900
教师：在完成所有继承工作后, 让我们返回到呈现列表项,

00:05.900 --> 00:10.590
在那里呈现更多细节｡

00:10.590 --> 00:14.900
正如我提到的, 我们还要确保我们以不同的方式呈现它们｡

00:14.900 --> 00:18.050
到目前为止, 我们遵循了面向对象的方法,

00:18.050 --> 00:22.440
例如, 对于我们的项目列表, 我们有一个类, 当我们实例化该类时,

00:22.440 --> 00:26.560
这样一个框会在这里呈现｡

00:26.560 --> 00:30.000
输入也是一样, 我们有一个项目输入类,

00:30.000 --> 00:34.880
当我们实例化它时, 顶部的项目输入区域会被渲染｡

00:34.880 --> 00:38.330
现在我们为什么不对我们的项目项做同样的事情,

00:38.330 --> 00:48.290
然后在呈现的项目中的项目列表中, 而不是像这样创建一个列表项, 我们只需要实例化我们的项目项类, 然后在该项目项类的构造函数中,

00:48.290 --> 00:55.100
我们将做所有的初始化等等｡

00:55.100 --> 00:57.240
至少这是我的想法｡ 

00:57.240 --> 00:59.850
和往常一样, 你们可以在这里暂停视频,

00:59.850 --> 01:01.680
先自己试一下, 但在短暂的休息之后,

01:01.680 --> 01:04.610
如果你们愿意, 我给你们暂停视频的机会,

01:04.610 --> 01:06.960
我们会一起做｡

01:09.080 --> 01:12.980
因此, 让我们一起来做这件事,

01:12.980 --> 01:17.940
在项目列表类之上, 我将添加项目项类,

01:17.940 --> 01:22.920
这将是负责呈现单个项目项的类｡

01:22.920 --> 01:25.620
现在项目项类应该总是扩展组件,

01:25.620 --> 01:28.940
因为它将是一个负责在屏幕上呈现某些内容的类,

01:28.940 --> 01:31.600
这就是我们的组件类的目的,

01:31.600 --> 01:36.410
对, 这就是我们构建它的目的｡

01:36.410 --> 01:40.100
这样我们就可以传递一个模板､ 一个宿主元素等等｡ 

01:40.100 --> 01:43.560
所以在项目item中, 我们当然需要一个构造函数,

01:43.560 --> 01:47.030
一个构造函数, 然后我们还必须调用super｡

01:47.030 --> 01:50.650
实际上在调用super之前, 我们先为基类设置这些泛型类型,

01:50.650 --> 01:53.610
以便继承｡

01:53.610 --> 01:56.440
请记住, 我们传入的第一个类型是宿主元素,

01:56.440 --> 02:00.410
因此我们要渲染的是什么｡

02:00.410 --> 02:04.800
我们传入的第二个泛型类型是呈现的元素｡

02:04.800 --> 02:07.040
因此, 在项目项的情况下,

02:07.040 --> 02:13.570
这意味着我们传入的第一个元素是, 因为它是我们要呈现某些内容的地方,

02:13.570 --> 02:15.587
是一个HTML U列表,

02:15.587 --> 02:22.550
一个无序列表, 因为每个项目项都将在我们的无序列表中呈现｡

02:22.550 --> 02:29.313
第二个元素将是HTML LI元素, 因此将创建具体的列表项元素｡

02:30.210 --> 02:38.210
现在选择super, 我们需要提供项目项应该呈现的元素的ID｡

02:38.210 --> 02:43.030
当然, ID不是固定的, 因为我们有两个列表,

02:43.030 --> 02:47.480
可以将项目呈现到其中｡

02:47.480 --> 02:51.760
我希望在构造函数中得到ID, 在那里我想得到主机ID,

02:51.760 --> 02:59.140
比如说, 应该是一个字符串, 我们可以把它转发给super.

02:59.140 --> 03:02.220
然而, 我们首先转发给super的是模板ID,

03:02.220 --> 03:07.410
对于一个列表项, 就是这里的这个模板｡

03:07.410 --> 03:09.620
所以我们可以把它包起来｡ 

03:09.620 --> 03:11.580
当然, 这是一个非常简单的模板,

03:11.580 --> 03:13.580
您可能会争论是否真的需要它,

03:13.580 --> 03:16.380
它只是一个列表项, 我们也可以使用document

03:16.380 --> 03:18.920
create元素在代码中创建它,

03:18.920 --> 03:26.240
但为了能够重用依赖于模板的组件基本子句, 我们将使用这种方法｡

03:26.240 --> 03:29.680
因此, 单个项目是模板ID, 主机ID,

03:29.680 --> 03:34.500
然后是我要转发给基本子句构造函数的ID｡

03:34.500 --> 03:40.010
然后回答这个问题, 这是应该呈现在开头还是结尾｡

03:40.010 --> 03:43.020
每个新的列表项都应该被添加到列表的末尾,

03:43.020 --> 03:45.630
这完全取决于你, 你也可以把它添加到列表的开头,

03:45.630 --> 03:53.423
但这里我会把它添加到末尾, 所以这里我会传递false.

03:54.410 --> 04:01.580
然后, 对于新元素Id, sell应该分配给新创建的元素的Id｡

04:01.580 --> 04:03.760
我也希望从外部得到这些,

04:03.760 --> 04:09.860
因为每个项目的内容都不同, 我们将渲染多个这样的内容｡

04:09.860 --> 04:12.240
所以这里我期望得到一个Id, 它是一个字符串,

04:12.240 --> 04:15.060
在这里我只需要向前｡

04:15.060 --> 04:17.820
这就是构造函数｡ 

04:17.820 --> 04:27.280
现在, 将属于此项目项的项目存储在此项目项类中就很有意义了｡

04:27.280 --> 04:31.020
我所说的项目是指基于我们的项目类的项目,

04:31.020 --> 04:33.770
我们在上面创建了这个类｡

04:33.770 --> 04:37.490
这基本上就是我们要处理的数据｡ 

04:37.490 --> 04:44.000
我想把属于这个呈现的项目项的项目存储在那个项目项类中｡

04:44.000 --> 04:47.650
因此, 在这里我们可以添加一个私有财产项目,

04:47.650 --> 04:51.510
但类型应为项目, 如下图所示｡

04:51.510 --> 04:55.350
在构造函数中, 我们得到了Id, 我们可以简单地改变它, 这样就得到了这个项目,

04:55.350 --> 05:09.440
然后简单地说这个项目等于项目, 这里因为每个项目都有一个Id属性, 我们就把它转发给项目.

05:09.440 --> 05:09.440
同上｡ 

05:09.440 --> 05:12.330
我认为这样的安排更有意义｡ 

05:12.330 --> 05:17.760
现在我们总是需要添加几个方法, 当然我们需要添加一个configure方法｡

05:17.760 --> 05:25.040
我们需要添加呈现内容方法, 这是我们要扩展的基类所需的｡

05:25.040 --> 05:32.000
它总是在构造函数的末尾调用configure和render内容｡

05:32.000 --> 05:34.890
现在关于配置, 对于我们要渲染的内容,

05:34.890 --> 05:40.050
我们现在没有什么需要做的, 肯定有工作要做｡

05:40.050 --> 05:42.710
现在我们有一个非常简单的模板,

05:42.710 --> 05:47.650
我们可以在索引HTML文件中将其更改为更复杂一些,

05:47.650 --> 05:50.850
这样每个项目都有一个h2标记,

05:50.850 --> 05:59.170
下面有一个h3标记, 还有一个段落, 这样我们就可以输出项目的标题､ 分配的人数,

05:59.170 --> 06:03.290
然后是描述｡

06:03.290 --> 06:05.720
然后在内容呈现的应用中,

06:05.720 --> 06:14.440
我们只需要访问元素中的不同元素, 例如h2标记等, 然后插入一些内容｡

06:14.440 --> 06:17.300
我们可以找到这个元素, 这是我们的渲染元素,

06:17.300 --> 06:21.750
这是我们渲染的LI元素｡

06:21.750 --> 06:24.970
我们现在需要选择这些不同的东西｡ 

06:24.970 --> 06:27.270
所以我们可以使用查询选择器h2,

06:27.270 --> 06:28.930
并在这里设置文本内容｡

06:28.930 --> 06:33.930
咱们说到这｡  项目｡  title以在此处呈现标题｡ 

06:34.350 --> 06:36.470
当然, 我们应该在这里添加一个感叹号,

06:36.470 --> 06:39.010
以明确我们总是会得到这个元素,

06:39.010 --> 06:42.563
因为它是我们模板的一部分｡

06:43.980 --> 06:46.870
实际上, 我们可以重复这个过程,

06:46.870 --> 06:49.170
但是现在查找h3标签,

06:49.170 --> 06:52.990
在那里我想输出人数, 但是这里的people是属性名称,

06:52.990 --> 06:58.030
但是我会稍微调整一下｡

06:58.030 --> 07:00.300
这里是一个数字, 这里是一个字符串,

07:00.300 --> 07:04.110
所以我在这里调用string.

07:04.110 --> 07:06.900
但这不是主要的问题, 实际上我想调整一下,

07:06.900 --> 07:12.590
使它输出的不仅仅是一个数字, 稍后我会再讨论这个问题｡

07:14.960 --> 07:17.260
首先, 让我们再重复一次,

07:17.260 --> 07:19.600
并查询此处的段落｡

07:19.600 --> 07:22.623
并将此设置为等于此项目｡  说明｡ 

07:23.810 --> 07:27.140
我稍后会再做调整, 现在让我们保持原样｡

07:27.140 --> 07:29.880
这样, 我们就有了一个应该呈现的项目项,

07:29.880 --> 07:33.470
然后应该列出它的所有内容｡

07:33.470 --> 07:35.460
因此, 现在我们需要使用项目项,

07:35.460 --> 07:40.450
而使用它的地方是项目列表, 因为它呈现项目列表｡

07:40.450 --> 07:48.260
特别是在渲染项目中, 这是我们需要确保渲染项目项的地方｡

07:48.260 --> 07:52.860
在此, 我们将检查已分配项目中的所有项目项｡

07:52.860 --> 07:55.870
assigned projects是这里的这个属性,

07:55.870 --> 07:58.960
它有一个项目列表或项目数组｡

07:58.960 --> 08:02.330
所以现在在这个循环中, 我不再手动创建一个列表项等等,

08:02.330 --> 08:04.720
我将去掉所有这些, 在这里简单地说是new

08:04.720 --> 08:13.740
project item, 现在是two project item｡

08:13.740 --> 08:16.110
我们需要传递主机的想法,

08:16.110 --> 08:22.730
现在这当然是我们这里的列表项上的ID｡

08:22.730 --> 08:27.800
基本上就是这样｡  元素中的值｡  id, 这是宿主元素的ID,

08:27.800 --> 08:31.670
因为这个无序列表的元素应该是宿主｡

08:31.670 --> 08:34.210
这里的第二个论点, 是这个项目,

08:34.210 --> 08:37.400
它基本上是被清除的项目｡

08:37.400 --> 08:40.950
所以这个常数是我们在循环中得到的｡ 

08:40.950 --> 08:49.770
现在, 附加将发生在项目项内部或项目项扩展的组件类的基本子句内部｡

08:49.770 --> 08:53.570
实例化项目项应该是我们需要做的全部工作｡ 

08:53.570 --> 08:58.380
如果我们保存它, 然后返回, 这里又有了这个代码, 或者说,

08:58.380 --> 09:00.890
我们又有了这个输入｡

09:00.890 --> 09:04.140
你看, 这个被渲染了, 看起来还不错｡ 

09:04.140 --> 09:06.320
现在有两件事我不喜欢,

09:06.320 --> 09:10.220
当然这里的要点, 不太喜欢｡

09:10.220 --> 09:12.710
只是在这里有免费的,

09:12.710 --> 09:15.590
所有的人都不太高兴｡

09:15.590 --> 09:17.293
那我们现在该怎么解决这个问题

09:18.730 --> 09:21.380
为了修正要点, 让我们检查一下内容｡ 

09:21.380 --> 09:28.060
我们看到的是列表项实际上呈现在无序列表之外｡

09:28.060 --> 09:29.600
所以不在里面｡ 

09:29.600 --> 09:32.710
如果它在里面, 那么它会正常工作,

09:32.710 --> 09:35.530
但我不能把它拖到那里｡

09:35.530 --> 09:39.000
所以我们需要确保它在无序列表中呈现｡

09:39.000 --> 09:41.363
让我们来看看为什么不是这样｡ 

09:42.220 --> 09:46.710
可能不是这样的, 因为在project item中, 我在这里传递false,

09:46.710 --> 09:57.640
给base子句构造函数, 在这里传递false意味着它不会在开始处被插入, 这反过来意味着在attach中我们在这里有before,

09:57.640 --> 10:02.670
作为一个值, 它会被插入到这里.

10:02.670 --> 10:05.660
然而, 这是我们希望发生的事情,

10:05.660 --> 10:08.360
所以这可能不是问题所在｡

10:08.360 --> 10:14.970
问题仍然是我们要把它插入到宿主元素中.

10:14.970 --> 10:19.460
现在让我们再想想, 什么是项目列表的主机元素？

10:19.460 --> 10:20.900
这就是这里最重要的,

10:20.900 --> 10:23.850
因为当我们渲染我们的项目时,

10:23.850 --> 10:25.620
我们创建了一个新的项目项,

10:25.620 --> 10:34.180
我将这里的元素的ID, 在项目列表中渲染的元素的ID转发给项目项｡

10:34.180 --> 10:38.120
因此, 这将是单个项目项的主体图元的概念｡

10:38.120 --> 10:40.720
但这个元素是什么呢？

10:40.720 --> 10:43.770
这里的元素不是那个盒子里的无序列表,

10:43.770 --> 10:47.350
它是盒子本身它是我们的部分.

10:47.350 --> 10:53.810
如果我们检查我们看到的模板, 这里的部分就是我们的项目列表类实际呈现的部分｡

10:53.810 --> 10:58.300
这不仅是列表, 它的部分也包括一个标题｡

10:58.300 --> 11:00.320
我们需要访问元素中的列表,

11:00.320 --> 11:02.020
然后了解列表的概念,

11:02.020 --> 11:05.070
因为我们在列表中设置了一个ID,

11:05.070 --> 11:12.230
所以会有一个ID, 我们只需要找到正确的ID.

11:12.230 --> 11:16.790
因此, 获得元素本身的想法是完全不正确的｡

11:16.790 --> 11:20.580
相反, 在这里, 我们应该得到元素中无序列表的概念,

11:20.580 --> 11:30.063
并且我们肯定会有无序列表, 所以我们可以通过添加感叹号来跳过空值检查｡

11:30.930 --> 11:34.463
现在添加了这个元素, 如果我们在这里添加一个新元素,

11:35.490 --> 11:37.680
看起来会更好, 现在项目符号消失了,

11:37.680 --> 11:39.920
因为现在应用了正确的样式,

11:39.920 --> 11:43.100
因为LI, 列表项现在真正添加到无序列表中,

11:43.100 --> 11:46.320
如您所见｡

11:46.320 --> 11:49.390
这是一个问题, 现在让我们来看看5,

11:49.390 --> 11:52.990
因为我不想在这里只放5.

11:52.990 --> 11:56.143
输出更多有用的信息怎么样？
