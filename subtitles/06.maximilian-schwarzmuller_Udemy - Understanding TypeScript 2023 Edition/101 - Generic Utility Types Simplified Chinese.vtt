WEBVTT

00:02.330 --> 00:04.870
旁白：说到更多的泛型类型,

00:04.870 --> 00:06.970
作为一个小奖励, 你可以说,

00:06.970 --> 00:11.410
我想指出你的方向在一对夫妇的内置类型｡

00:11.410 --> 00:15.740
Typescript随附, 它们使用泛型型别,

00:15.740 --> 00:20.350
或是泛型型别, 提供我们特定的公用程式功能｡

00:20.350 --> 00:22.050
所以这里有一点额外的好处,

00:22.050 --> 00:25.550
时不时地这些特殊类型可能会派上用场｡

00:25.550 --> 00:30.680
现在, 您可以在附件中找到指向所有内置实用程序类型的完整文档的链接｡

00:30.680 --> 00:33.810
这里, 我只想给你们举几个例子｡ 

00:33.810 --> 00:36.010
现在正像所有这些类型的东西一样,

00:36.010 --> 00:38.610
这些类型只存在于类型世界中, 因此,

00:38.610 --> 00:41.300
只存在于编译之前｡

00:41.300 --> 00:43.460
但是在这个编译步骤中,

00:43.460 --> 00:48.130
它们可以为您提供额外的类型安全或额外的灵活性｡

00:48.130 --> 00:51.670
例如, 有内置分部类型｡ 

00:51.670 --> 00:55.580
假设我们有一个新的类型, 而你的接口是我们会发现的还是一个自定义类型真的无关紧要,

00:55.580 --> 00:59.493
CourseGoal｡

01:00.660 --> 01:03.780
CourseGoal确实有一个标题, 它应该是一个字符串,

01:03.780 --> 01:09.040
让我们假设一个描述, 它应该都是一个字符串｡

01:09.040 --> 01:14.040
也许我们还有completeUntil属性, 它是一个Date｡ 

01:15.290 --> 01:17.961
现在我们需要一个函数, 比如说createCourseGoal,

01:17.961 --> 01:21.500
它创建了这样一个对象｡

01:21.500 --> 01:23.380
当然, 我们也可以创建该类｡ 

01:23.380 --> 01:26.290
但是我们有这样一个函数, 因为在这个函数中,

01:26.290 --> 01:28.740
我们可能会从数据库中提取一些数据,

01:28.740 --> 01:30.590
或者其他什么数据｡

01:30.590 --> 01:32.110
所以我们有了这个函数｡ 

01:32.110 --> 01:33.330
最后, 我想得到我的标题,

01:33.330 --> 01:37.890
这是一个字符串, 我可能会得到我的描述,

01:37.890 --> 01:42.320
这是一个字符串, 我希望得到我的日期,

01:42.320 --> 01:47.150
这是一个日期｡

01:47.150 --> 01:51.740
在这个函数中, 当然, 我们可以返回一个对象但我们只是设置了所有这些东西.

01:51.740 --> 01:55.340
因此, 我们将title设置为title, 将description设置为description,

01:55.340 --> 01:57.840
并将completeUntil设置为date｡

01:57.840 --> 02:03.890
我们可以做到这一切, 如果我们定义这个函数总是返回一个CourseGoal,

02:03.890 --> 02:07.120
我们就有了一个正确的设置函数｡

02:07.120 --> 02:08.420
因为某种原因,

02:08.420 --> 02:09.530
我们不能这样做,

02:09.530 --> 02:11.623
我们不能一步到位｡

02:12.680 --> 02:13.870
相反, 我想做的是,

02:13.870 --> 02:18.700
首先在这里创建一个变量, 它包含一个空对象.

02:18.700 --> 02:22.620
然后一步一步, 我想在这里加上我的标题｡ 

02:22.620 --> 02:26.420
我想在这里加上我的描述｡ 

02:26.420 --> 02:31.303
我想在这里加上我的日期｡ 

02:33.640 --> 02:36.420
现在我得到了错误, 因为我不能设置标题,

02:36.420 --> 02:39.170
这不是这个对象的属性｡

02:39.170 --> 02:41.930
虽然这可以在普通JavaScript中工作,

02:41.930 --> 02:45.410
但TypeScript并不喜欢在这里添加｡

02:45.410 --> 02:49.300
所以我们可以说它应该是CourseGoal类型.

02:49.300 --> 02:51.040
现在, TypeScript不是在抱怨这一点,

02:51.040 --> 02:56.223
而是抱怨这是一个空对象, 这显然不适合我们这里的类型｡

02:57.070 --> 02:58.360
最后, 我想返回它,

02:58.360 --> 03:01.000
我想一步一步地添加所有这些东西,

03:01.000 --> 03:04.570
可能是因为我们在每一步之前都有额外的验证,

03:04.570 --> 03:07.590
所以像这样添加它｡

03:07.590 --> 03:12.390
现在, 分部类型可以派上用场了｡ 

03:12.390 --> 03:18.413
我们可以说这里的CourseGoal应该是一个部分类型, 由于泛型类型的存在,

03:18.413 --> 03:21.600
它最终会保存一个courseGoal｡

03:21.600 --> 03:28.260
它告诉TypeScript, 这是一个最终会成为courseGoal的对象.

03:28.260 --> 03:32.090
但最初, partial kind包装了我们自己的类型,

03:32.090 --> 03:36.620
并将其更改为所有这些属性都是可选的类型｡

03:36.620 --> 03:40.670
这就是部分内置类型Typescript附带的功能｡

03:40.670 --> 03:45.713
所以它将这个转换为一个类型, 也是一个对象类型, 其中所有的属性都是可选的｡

03:45.713 --> 03:49.290
因此, 我们可以在一开始就将this设置为空对象,

03:49.290 --> 03:53.030
并仍然一步一步地添加所有这些内容｡

03:53.030 --> 03:54.880
唯一的问题是, 我们最终无法返回它,

03:54.880 --> 03:58.130
因为它现在仍然是partial CourseGoal类型,

03:58.130 --> 04:02.130
而不是CourseGoal类型｡

04:02.130 --> 04:04.630
我们可以通过类型转换将其转换为courseGoal来解决这个问题,

04:04.630 --> 04:08.990
因为我们知道此时我们已经添加了所有数据｡

04:08.990 --> 04:11.667
因此, 这将是一个真正的课程目标, 而不是一个部分｡ 

04:11.667 --> 04:13.510
当然, 这是编出来的｡ 

04:13.510 --> 04:15.500
但是你可能会遇到这样的情况,

04:15.500 --> 04:19.650
你想临时切换一个对象类型, 一个接口,

04:19.650 --> 04:23.530
使之成为可选的｡

04:23.530 --> 04:28.170
要确保所有的属性在那里只能是临时可选的｡

04:28.170 --> 04:31.223
然后分部类型允许你这样做｡ 

04:32.370 --> 04:35.920
而你拥有的内置实用程序类型是只读的,

04:35.920 --> 04:40.170
这是非常有用的｡

04:40.170 --> 04:42.623
假设我们有一个名称数组｡ 

04:43.460 --> 04:46.330
里面有麦克斯和体育｡ 

04:46.330 --> 04:49.860
现在, TypeScript正确地推断这是一个字符串数组｡

04:49.860 --> 04:50.960
现在我们该怎么办？

04:50.960 --> 04:52.690
我们当然可以把马努推上去,

04:53.700 --> 04:55.400
也许我应该把它改成安娜而不是体育,

04:55.400 --> 04:59.720
这样就有了名字｡

04:59.720 --> 05:00.553
所以这行得通｡ 

05:00.553 --> 05:01.386
但是, 现在我们假设,

05:01.386 --> 05:04.230
我想确保这是一个锁定的数组｡

05:04.230 --> 05:06.260
无法在此处添加更多内容｡ 

05:06.260 --> 05:07.870
我们可以在这里添加更多内容,

05:07.870 --> 05:11.690
但至少我希望Typescript在我尝试时对我大喊大叫｡

05:11.690 --> 05:13.730
这就是我们可以使用只读类型的地方,

05:13.730 --> 05:18.730
我们可以把它设置成只读的字符串数组｡

05:18.930 --> 05:20.510
我们告诉TypeScript,

05:20.510 --> 05:23.030
我们在这里存储的是一个字符串数组.

05:23.030 --> 05:25.830
但它也是一个字符串数组, 是只读的｡ 

05:25.830 --> 05:28.210
所以当我们试图用push来添加一些东西,

05:28.210 --> 05:36.320
或者用pop来移除一些东西时, 我们会得到错误, 因为我们不允许用这个数组来做这些事情.

05:36.320 --> 05:38.760
顺便说一下, 这并不局限于数组, 你也可以对一个对象使用read

05:38.760 --> 05:41.610
only｡

05:41.610 --> 05:43.990
例如, 以只读方式上市,

05:43.990 --> 05:49.920
这样就不允许您更改属性或向此对象添加新属性｡

05:49.920 --> 05:52.240
所以这也非常方便,

05:52.240 --> 05:59.490
给你更大的灵活性, 或者更精确地确定你在代码中要做什么｡

05:59.490 --> 06:03.610
现在, 所有这些都是只存在于TypeScript世界中实用程序类型

06:03.610 --> 06:05.881
所以它们没有编译成任何东西｡ 

06:05.881 --> 06:09.400
但是在编译过程中, 它们会给你额外的严格性, 或者额外的检查,

06:09.400 --> 06:14.800
或者跳过某些检查, 就像我们对partial所做的那样｡

06:14.800 --> 06:17.170
现在, 您已经获得了比只读和部分更好的结果｡ 

06:17.170 --> 06:22.420
正如我在附件中提到的, 您可以在文档中找到这些实用程序类型的完整列表｡

06:22.420 --> 06:25.580
在某些情况下, 它们可以派上用场, 因此,

06:25.580 --> 06:28.350
我绝对不想对你隐瞒它们｡

06:28.350 --> 06:30.500
但是, 你应该知道它们, 这样当你需要锁定某个东西的时候,

06:30.500 --> 06:34.060
你就可以使用它们, 或者在部分打开某个东西的时候,

06:34.060 --> 06:45.140
或者我在这里没有讨论的所有其他操作的时候, 如果你有一些其他的操作, 可以用这些内置的实用程序类型来增强｡

06:45.140 --> 06:47.670
这些实用程序类型都是通用的,

06:47.670 --> 06:49.170
因为它们所做的就是取其他任何类型的值,

06:49.170 --> 06:54.190
并对其进行处理.

06:54.190 --> 06:57.970
他们把所有的东西都设置为可选的, 他们把它锁定,

06:57.970 --> 07:01.330
不管它是数组, 对象, 还是字符串数组,

07:01.330 --> 07:04.430
数字数组, 等等.

07:04.430 --> 07:06.000
这就是为什么这些都是通用的｡ 

07:06.000 --> 07:10.790
再加上我们前面看到的上层内置泛型和您自己的泛型｡

07:10.790 --> 07:16.793
希望这一切能再次帮助您理解为什么泛型在它们存在的原因中是有用的｡
