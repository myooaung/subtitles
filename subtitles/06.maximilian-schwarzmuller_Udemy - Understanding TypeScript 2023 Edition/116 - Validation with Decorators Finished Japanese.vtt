WEBVTT

00:02.320 --> 00:05.210
講師：これを実装するために､ まずValidatorConfigというインターフェイスを作り､

00:05.210 --> 00:12.680
そこに自分が使いたいストレージを設定することにします｡

00:12.680 --> 00:15.130
私の考えは､ いくつかのプロパティを持つことであり､ それゆえ､

00:15.130 --> 00:17.653
ここではこのインデックス型の記法を使用しています｡

00:19.720 --> 00:23.440
これは基本的に文字列であり､ 値はさらに別のオブジェクトである｡

00:23.440 --> 00:29.570
なぜなら､ ここにあるのは基本的に､ いくつかの有効なプロパティを登録するためのクラス名だからです｡

00:29.570 --> 00:31.700
そして､ そこに格納されたオブジェクトには､

00:31.700 --> 00:37.010
バリデータが付加されたクラスの具体的なプロパティがあります｡

00:37.010 --> 00:42.240
ここでは､ validatableプロパティ（このように呼びたい場合）を用意して､

00:42.240 --> 00:44.660
これも文字列キーとします｡

00:44.660 --> 00:47.350
そして､ その値は文字列の配列でなければならず､

00:47.350 --> 00:50.010
基本的には required や positive

00:52.420 --> 00:55.490
といったものがある｡

00:55.490 --> 00:59.323
ですから､ そのようなものをここにバリデーターのリストとして追加することができます｡

01:00.300 --> 01:05.300
ここでregisteredValidatorsの設定を作成します｡ ValidatorConfigタイプで､

01:05.790 --> 01:09.640
最初は空のオブジェクトである必要があります｡

01:09.640 --> 01:11.500
なぜなら､ サードパーティライブラリがロードされたときにアプリが起動すると､

01:11.500 --> 01:16.293
最初はまだバリデータが登録されていない状態だからです｡

01:17.640 --> 01:19.920
そして､ 私たちのディレクターは､

01:19.920 --> 01:23.490
そのレジストリに何かを加えたいと考えています｡

01:23.490 --> 01:28.020
プロパティ・デコレーター関数は､ 2つの引数を受け取ることを覚えておいてください｡

01:28.020 --> 01:39.300
ターゲットとは､ プロパティが置かれているオブジェクトのプロトタイプ､ または静的プロパティの場合はコンストラクター関数､ そしてプロパティ名です｡

01:39.300 --> 01:40.710
ここで得られるのはこの2つの引数であり､

01:40.710 --> 01:44.370
プロパティの記述子は得られない｡

01:44.370 --> 01:46.760
登録済みのバリデータに移動して､ target

01:46.760 --> 01:51.463
のエントリを追加します｡ のコンストラクタを使用します｡ 

01:52.730 --> 02:02.610
インスタンスのプロトタイプには､ オブジェクトを生成するために使用されたコンストラクタ関数を指すコンストラクタキーが設定されています｡

02:02.610 --> 02:04.690
そのため､ 基本的にはここのコースのようなものになり､

02:04.690 --> 02:10.560
最終的にそのコンストラクタの関数名を取り出すことができるようになります｡

02:10.560 --> 02:11.900
コンストラクタは関数なので､

02:11.900 --> 02:20.620
JavaScriptの関数に存在するnameプロパティを使って関数名を取得することができます｡

02:20.620 --> 02:25.030
そこで､ 今度はクラス名を登録型バリデーターのキーとして登録します｡

02:25.030 --> 02:28.130
そして､ そのときの値は､ 別のオブジェクトであるべきです｡ 

02:28.130 --> 02:30.630
そこで､ このオブジェクトを別のオブジェクトに等しく設定しました｡ 

02:30.630 --> 02:32.390
このオブジェクトには､ propName

02:32.390 --> 02:34.640
というプロパティも動的に割り当てられており､

02:34.640 --> 02:40.190
バリデータを追加したいプロパティをキーとして使用します｡

02:40.190 --> 02:42.310
さて､ ここでの値は文字列の配列ですが､

02:42.310 --> 02:45.530
ここでは文字列としてrequiredを追加します｡

02:45.530 --> 02:47.920
もちろん､ これは非常に素朴なバリデータです｡ 

02:47.920 --> 02:50.000
もし､ このプロパティに他のバリデータが既に登録されていた場合､

02:50.000 --> 02:52.830
ここで上書きすることになりますね｡

02:52.830 --> 02:54.900
そのため､ まず既存のバリデータをすべて取得してからこの配列にコピーし､

02:54.900 --> 03:01.320
必要なものだけを追加していくほうがよいでしょう｡

03:01.320 --> 03:02.870
ここでも､ 時間を節約するため､ また一般的な考え方を示すために､

03:02.870 --> 03:06.873
ここではより素朴なアプローチをとることにします｡

03:07.980 --> 03:14.690
これで必要なアノテーションは揃ったので､ 次は正の数のアノテーションに取り組みましょう｡

03:14.690 --> 03:16.730
もちろん､ それは基本的に同じです｡ 

03:16.730 --> 03:21.410
このコードをコピーしますが､ ここではこれをポジティブに設定したり､

03:21.410 --> 03:23.600
使いたい識別子を設定します｡ もちろん､

03:23.600 --> 03:27.650
正しい引数を受け取るようにしなければなりません｡

03:27.650 --> 03:30.990
このように､ これまでに追加したものと合わせて､

03:30.990 --> 03:38.640
このクラスが定義されたときに､ これらのプロパティとそのバリデーターをグローバル設定に登録するのです｡

03:38.640 --> 03:41.460
あとは､ validate関数に手を入れるだけです｡ 

03:41.460 --> 03:43.400
validate 関数は､ 登録されているすべてのバリデータを調べ､

03:43.400 --> 03:50.340
見つけたバリデータに応じて基本的に異なるロジックを実行する必要があります｡

03:50.340 --> 03:57.600
そこで､ まず最初に､ 扱っている具象オブジェクトの構成を取得したいと思います｡

03:57.600 --> 04:00.390
そのためには､ オブジェクトがどのコンストラクタ関数に基づいているかを調べ､

04:00.390 --> 04:09.070
そのオブジェクトに対して設定したバリデーション設定やプロパティバリデータマッピングを取得する必要があります｡

04:09.070 --> 04:14.520
ここでは､ このオブジェクトをバリデータ（objValidatorConfig）と呼ぶことにします｡

04:14.520 --> 04:22.110
そして､ ここで登録されたバリデータにアクセスし､ objであるはずのプロパティにアクセスするのです｡

04:22.110 --> 04:22.110
のコンストラクタを使用します｡  オブジェクトのプロトタイプに存在するコンストラクタのプロパティにアクセスします｡

04:31.720 --> 04:33.340
JavaScript

04:33.340 --> 04:35.050
の仕組みにより､

04:35.050 --> 04:41.580
オブジェクトに直接アクセスすることができます｡

04:41.580 --> 04:43.840
そして､ コンストラクタの名前がわかり､

04:43.840 --> 04:49.050
例えば､ このCourseはこのCourseクラスに基づいていることがわかりました｡

04:49.050 --> 04:52.800
そこで､ Course クラスに対して持っている任意のバリデータ設定を検索します｡

04:52.800 --> 04:55.910
つまり､ 今は基本的にこのオブジェクトを見ているわけです｡ 

04:55.910 --> 04:58.207
これは現在､ objValidatorConfigにあります｡ 

04:59.310 --> 05:01.540
もちろん､ 何も登録されていないオブジェクトを検証しようとすると､

05:01.540 --> 05:05.110
これが見つからないかもしれません｡

05:05.110 --> 05:08.270
つまり､ バリデータの設定がない場合､ 何も見つからなかったら､

05:08.270 --> 05:14.010
これは確かに有効なので､ trueを返したいのです｡

05:14.010 --> 05:15.330
検証するものがないのだから､

05:15.330 --> 05:18.350
確かにオブジェクトは有効である｡

05:18.350 --> 05:20.900
そうでなければ､ もし見つかったら､ この内側のオブジェクトをfor

05:20.900 --> 05:24.910
inループでループさせたいと思います｡

05:24.910 --> 05:27.580
そこで､ objValidatorConfigにconst

05:27.580 --> 05:33.007
propを指定して､ バリデータを登録したプロパティをループしています｡

05:34.380 --> 05:39.630
これによって､ バリデータを作成するためのすべてのプロパティ名にアクセスできるようになります｡

05:39.630 --> 05:43.970
そこで､ 当然ながら､ あるプロパティに対応するすべてのバリデーターを確認する必要があります｡

05:43.970 --> 05:45.230
これは､ たとえ追加したバリデータが1つだけであっても､

05:45.230 --> 05:47.680
常に配列であるべきです｡

05:47.680 --> 05:49.530
ここで for of ループを使用すると､

05:49.530 --> 05:53.040
指定したプロパティに対する objValidatorConfig

05:53.040 --> 05:56.930
の具体的なバリデータを取得できます｡

05:56.930 --> 06:00.560
そこで今度は､ positiveやrequiredといったものを取得し､

06:00.560 --> 06:02.963
それをバリデータ定数に格納することにしました｡

06:04.080 --> 06:06.110
そして､ ここでswitchステートメントを用意します｡

06:06.110 --> 06:08.030
もちろん､ どのバリデータを見つけたかによって､

06:08.030 --> 06:09.810
外部関数を呼び出すことも可能です｡

06:09.810 --> 06:12.130
しかしここでは､ 組み込みのswitch文､ switch

06:12.130 --> 06:16.620
on validator､ そして基本的に異なるケースを持つことにします｡

06:16.620 --> 06:19.683
例えば､ こちらの必須ケース｡ 

06:20.800 --> 06:22.163
おっと､ こんな感じで｡ 

06:23.470 --> 06:28.950
ここでは､ このプロパティが...であれば､ trueを返したい｡

06:28.950 --> 06:33.260
つまり､ このオブジェクトのこのプロパティは空でない値を持っています｡ 

06:33.260 --> 06:38.260
そこで､ obj propがtruthyであればtrueを返すようにします｡ 

06:39.170 --> 06:42.010
そして､ これを本当の真偽値に変換するために､

06:42.010 --> 06:44.420
ダブルバン演算子を使うことができる｡

06:44.420 --> 06:49.440
オブジェクトがこのプロパティを持っているかどうかがわからないという苦情があるようなので､

06:49.440 --> 06:51.220
ここでは実際にこれをanyに変更して､

06:51.220 --> 06:53.560
柔軟性を高めるようにしましょう｡

06:53.560 --> 06:56.150
もちろん､ こちらのタイプに取り組むことも可能です｡ 

06:56.150 --> 07:00.480
また､ 例えば､ 識別子を明確に定義された型に変換し､

07:00.480 --> 07:05.490
Enumsで作業し､ さらに型付けを改善します｡

07:05.490 --> 07:07.420
とはいえ､ 正直なところ､ どんなオブジェクトでも動くようにしたいので､

07:07.420 --> 07:11.810
TypeScriptに気に入られるように改良するのは難しいです｡

07:11.810 --> 07:13.330
ジェネリック型を使うこともできますが､

07:13.330 --> 07:16.800
その場合､ ジェネリック型がどのオブジェクトを拡張し､

07:16.800 --> 07:22.110
どのオブジェクトを受け入れるべきかを制限する必要があります｡

07:22.110 --> 07:25.850
ですから､ この検証関数でさまざまなオブジェクトを柔軟に受け入れるには､

07:25.850 --> 07:30.640
anyが最適な選択肢かもしれません｡

07:30.640 --> 07:32.270
さて､ スイッチ・セグメントに戻りますが､

07:32.270 --> 07:37.650
必要なケースは1つだけですが､ 処理したいポジティブなケースもあります｡

07:37.650 --> 07:43.770
そしてそこで､ 見ているプロパティが0より大きい場合にtrueを返すようにしたい｡

07:43.770 --> 07:47.260
つまり､ prop が 0 よりも大きい場合は true を返し､

07:47.260 --> 07:50.463
そうでない場合は false を返します｡

07:52.890 --> 07:55.730
もしこのforブロックに入らなかったり､

07:55.730 --> 07:59.310
バリデータを登録していないために何もループしないような場合は､

07:59.310 --> 08:10.280
ここで空の配列を渡したりしているので､ このforループを抜けたら､ デフォルトとしてtrueも返すことにします｡

08:10.280 --> 08:14.503
そして､ どんな状況でも何かを返すようになり､ validateが使えるようになりました｡

08:15.450 --> 08:19.253
この状態で保存し､ アプリをリロードして送信しようとすると､

08:23.610 --> 08:29.400
「無効な入力です､ 再試行してください」というエラーが発生することを確認しましょう｡

08:29.400 --> 08:30.780
ここにJavaScript完全ガイドというテキストを入力しても､

08:30.780 --> 08:38.100
「番号が違うから」と表示されます｡

08:38.100 --> 08:40.440
ここでマイナス1を入力すると､ これもプラスにならないので､

08:40.440 --> 08:42.020
こうなります｡

08:42.020 --> 08:45.020
しかし､ 正の数を入力すると､ 動作します｡ 

08:45.020 --> 08:48.230
もし正の数があっても､ 最初のフィールドが空であれば､

08:48.230 --> 08:49.860
これもうまくいくので､

08:49.860 --> 08:52.190
そこは工夫が必要です｡

08:52.190 --> 08:54.600
では､ 何が問題なのかを探ってみましょう｡ 

08:54.600 --> 08:57.380
そして､ それを知るために､ ここに小さなコンソールログを追加して､

08:57.380 --> 09:00.720
見ているプロパティを記録します｡

09:00.720 --> 09:03.513
もちろん､ ブレークポイントやデベロッパーツールを使うことも可能です｡

09:04.820 --> 09:07.410
ここで保存をクリックすると､ 最初に価格が検証され､

09:07.410 --> 09:10.623
それ以降は停止します｡

09:11.530 --> 09:15.100
つまり､ 価格は最初に検証されるプロパティなのです｡ 

09:15.100 --> 09:16.980
そして､ ここが面白いところなのですが､

09:16.980 --> 09:22.230
検証で返すので､ 実はここで重要なのは価格だけという財産なのです｡

09:22.230 --> 09:25.840
つまり､ 最初にtrueかfalseを返すバリデータを見つけたら､

09:25.840 --> 09:29.050
すぐに戻り､ 他のバリデータのことは気にしない､

09:29.050 --> 09:31.480
ということです｡

09:31.480 --> 09:33.320
1つの要素が偽であれば､

09:33.320 --> 09:35.360
1つのプロパティが偽で無効であれば､

09:35.360 --> 09:40.140
他の要素には目もくれず､ 問題ないからです｡

09:40.140 --> 09:42.590
しかし､ 本当の場合は問題です｡ 

09:42.590 --> 09:44.970
ある物件で初めて期待に応えてtrueを返すとしたら､

09:44.970 --> 09:49.410
問題です｡

09:49.410 --> 09:51.540
そこで､ ここにisValidプロパティを設けて､

09:51.540 --> 09:55.130
最初はtrueになるように拡張する必要があります｡

09:55.130 --> 09:56.780
有効な変数かどうか､ ですね｡ 

09:56.780 --> 10:01.780
そして､ ここではisValidをisValidと同じに設定し､

10:03.857 --> 10:08.857
この下でも同じように､ これをこれと同じに設定します｡

10:09.570 --> 10:11.290
そのため､ すぐに戻らないように､

10:11.290 --> 10:16.700
代わりにisValidを更新するだけで､ それ以降は落ちないようにブレークしているのです｡

10:16.700 --> 10:22.710
その結果､ これらのループの後､ 最終的にisValidのどちらかはまだ真ですが､

10:22.710 --> 10:25.710
JavaScriptの動作のおかげで､

10:25.710 --> 10:33.000
これらのチェックの1つが偽になるとすぐに､ 全体のisValidの値は偽になります｡

10:33.000 --> 10:36.020
そして､ その下にisValidを返すようにします｡ 

10:36.020 --> 10:39.330
そこで､ JavaScriptが最初に見るプロパティだけでなく､

10:39.330 --> 10:42.433
すべてのプロパティがチェックされるようにしました｡

10:43.320 --> 10:45.460
しかし､ これだけでなく､

10:45.460 --> 10:50.480
バリデータロジックの登録方法にも問題があります｡

10:50.480 --> 10:57.130
私はいつも､ 指定したクラス名の登録済みバリデーターを新しいオブジェクトで上書きしています｡

10:57.130 --> 11:01.630
その代わりに､ 既存のバリデータをここに追加して､ このようなことがないようにしましょう｡

11:01.630 --> 11:04.140
たとえば spread 演算子を使えば､

11:04.140 --> 11:08.130
登録済みのバリデータからそのクラス名のキーと値のペアを取り出し､

11:08.130 --> 11:14.413
それを先に追加してからこちらのバリデータを追加することができます｡

11:16.890 --> 11:21.980
これで､ これを保存して､ このアプリケーションに戻ればいいわけです｡

11:21.980 --> 11:24.150
両方が空だと失敗するんです｡ 

11:24.150 --> 11:26.280
有効な価格を入力しても､ 無効なタイトルがあれば､

11:26.280 --> 11:28.490
失敗します｡

11:28.490 --> 11:31.510
両方が成立すれば成功です｡ 

11:31.510 --> 11:35.570
有効なタイトルがあっても価格がなければ､ 失敗です｡ 

11:35.570 --> 11:37.230
また､ 価格もマイナスで｡ 

11:37.230 --> 11:39.170
そしてこれが､ TypeScriptのデコレータの助けを借りて､

11:39.170 --> 11:46.670
このようなバリデーターがどのように機能するかを示す最初の素朴な実装となったのです｡

11:46.670 --> 11:49.150
そして､ ここにあるすべてのデコレータ､ validate関数､

11:49.150 --> 11:53.590
レジストリは､ あなたからは見えないところにあることを心に留めておいてください｡

11:53.590 --> 11:55.820
もちろん､ エンドユーザーと共有するよりも､

11:55.820 --> 12:01.300
より精巧な方法で作業しているサードパーティ製ライブラリの一部である可能性もあります｡

12:01.300 --> 12:04.160
そして､ エンドユーザーとしては､ これらをインポートし､

12:04.160 --> 12:06.800
デコレータを追加し､ validateを呼び出すだけで､

12:06.800 --> 12:11.763
クラスに検証を追加する非常に便利な方法を手に入れることができるのです｡
