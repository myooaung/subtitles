WEBVTT

00:02.480 --> 00:06.780
男：现在, 有了关于工厂函数, 或者工厂装饰器的知识,

00:06.780 --> 00:10.523
我们可以做一些非常有趣的事情｡

00:11.570 --> 00:17.693
例如, 我们可以用一个新装饰器工厂来交换模板｡

00:19.400 --> 00:21.590
在这里, 我期望得到一个模板,

00:21.590 --> 00:23.780
它应该是一些字符串｡

00:23.780 --> 00:28.780
和一个hookId, 它也应该是一个字符串｡ 

00:28.870 --> 00:32.050
然后在这里, 我返回我的匿名函数, 正如您所了解的,

00:32.050 --> 00:34.800
它是实际的装饰器｡

00:34.800 --> 00:37.440
因为我有一家装潢厂｡ 

00:37.440 --> 00:40.570
在那里, 我想呈现一些模板, 应该是一些HTML代码,

00:40.570 --> 00:46.590
到dom的某个地方, 在那里我找到了这个hookId｡

00:46.590 --> 00:49.160
现在我们可以进入索引｡  html并添加这样一个地方,

00:49.160 --> 00:51.250
这样我们就可以看到它是有效的｡

00:51.250 --> 00:54.483
我们可以在这里添加一个div, 也许可以使用app的id｡ 

00:55.430 --> 00:59.560
然后在应用程序｡  我添加了WithTemplate,

00:59.560 --> 01:01.357
而不是记录器｡

01:02.570 --> 01:06.810
我们先传递一个空字符串作为第一个参数, 然后传递app作为第二个参数｡

01:06.810 --> 01:09.313
所以, 这个ID我分配给了这个div｡ 

01:10.170 --> 01:13.830
在这个内部函数里面是我们真正的装饰器｡

01:13.830 --> 01:16.540
在这个装饰器函数中,

01:16.540 --> 01:19.500
我想访问元素｡

01:19.500 --> 01:24.500
将元素与文档挂钩｡  按标识获取元素｡ 

01:25.662 --> 01:29.390
我们在这里争论的那个钩子｡ 

01:29.390 --> 01:33.480
如果HookEl是一个存在的东西, 那么我想访问它的innerHTML,

01:34.330 --> 01:39.920
并且把它设置为template｡

01:39.920 --> 01:41.440
当然, 这是一个非常简单的设置,

01:41.440 --> 01:43.640
但这应该可以达到目的｡

01:43.640 --> 01:45.460
现在, 我对构造函数不感兴趣｡ 

01:45.460 --> 01:48.110
为了告诉打字稿我对这里不感兴趣, 我可以添加一个下划线作为名字,

01:48.110 --> 01:54.580
这基本上是在告诉打字稿, “是的, 我知道我得到了这个参数, 但我不需要它｡

01:54.580 --> 01:56.170
但我必须说明｡ 

01:56.170 --> 01:58.920
所以, 用这个下划线, 我告诉你我知道它,

01:58.920 --> 02:02.300
但是我不会用它｡ 因为, 我现在想做的, 就是今年的渲染｡

02:02.300 --> 02:04.033
现在, 当我们在这里添加WithTemplate时,

02:05.580 --> 02:07.750
我们可以在这里添加一个h1标记, 我的个人对象,

02:07.750 --> 02:10.400
就像这样｡

02:10.400 --> 02:14.570
还有, 关上它｡ 

02:14.570 --> 02:15.653
如果我们现在保存它, 它编译时不会出错｡ 

02:19.130 --> 02:22.380
事实上, 这里你可以看到这是在屏幕上呈现的｡ 

02:22.380 --> 02:29.720
希望这能向你展示装饰师的力量｡

02:29.720 --> 02:31.720
你可以构建像这样的高级装饰器,

02:31.720 --> 02:34.780
它突然在幕后产生了一些魔力｡

02:34.780 --> 02:38.500
这就是我所说的元编程｡ 

02:38.500 --> 02:43.930
我们在这里添加了一些逻辑, 如果这是我们与其他用户共享的第三方库,

02:43.930 --> 02:46.190
我们可以公开这些逻辑｡

02:46.190 --> 02:47.890
我们可以将其公开为库的一部分,

02:47.890 --> 02:52.630
任何使用我们库的人都可以导入这个装饰器函数, 并将其添加到一个类中,

02:52.630 --> 02:57.408
然后突然神奇地呈现一些内容｡

02:57.408 --> 03:00.500
当然, 你是, 你甚至不限于这样做｡ 

03:00.500 --> 03:05.340
如果你想在类实例化时输出类的名字,

03:05.340 --> 03:07.850
你也可以这样做｡

03:07.850 --> 03:09.570
我们得到构造函数：毕竟功能在这里｡ 

03:09.570 --> 03:12.427
现在我们能做的就是在这里创建一个新的人,

03:14.190 --> 03:16.010
通过调用我们的构造函数,

03:16.010 --> 03:20.380
因为这是我们的构造函数：毕竟功能在这里｡

03:20.380 --> 03:26.570
让我把它转换成any, 这样打字稿就允许这样做并且不认为这是一个普通函数｡

03:26.570 --> 03:29.240
然后我们可以转到hook元素,

03:29.240 --> 03:31.880
查询h1标记, 当然在实践中,

03:31.880 --> 03:35.160
您并不总是拥有h1标记｡

03:35.160 --> 03:37.330
但出于演示的目的, 我假设我们将永远有一个在这里｡

03:37.330 --> 03:39.820
哎呀, 我应该总是关闭h1标记在那里,

03:39.820 --> 03:42.330
现在我看到它｡

03:42.330 --> 03:43.850
然后这里, 用一个感叹号,

03:43.850 --> 03:49.900
再次假设我们总是找到一个h1元素, 我们可以设置textContent等于p｡

03:49.900 --> 03:49.900
名称｡ 

03:49.900 --> 03:53.660
如果我这样做并保存它,

03:53.660 --> 03:59.400
现在我输出名称, 它是模板中对象的一部分｡

03:59.400 --> 04:01.540
所以这是你可以做的,

04:01.540 --> 04:06.010
当然你可以写比我在这里做的更精细的装饰｡

04:06.010 --> 04:09.550
以Angular为例, 它是一个非常流行的使用打字脚本的框架｡

04:09.550 --> 04:12.270
它们使用装饰器, 比如这个组件装饰器,

04:12.270 --> 04:21.020
来允许你传入一个对象, 在那里你可以指定一些东西, 比如反组件的模板｡

04:21.020 --> 04:23.950
和应呈现此模板的DOM中的选择器｡

04:23.950 --> 04:25.760
这与我们在这里定义的相对接近｡ 

04:25.760 --> 04:28.170
一个模板, 然后是一个应该呈现该模板的位置｡ 

04:28.170 --> 04:36.550
现在不用说, 角度装饰器当然比我们这里的基本装饰器更先进和精致｡

04:36.550 --> 04:38.740
尽管如此, 核心思想是相同的｡ 

04:38.740 --> 04:43.900
Angular在这里给你装饰器, 这样你就可以指定一些HTML代码,

04:43.900 --> 04:46.700
这些代码可以连接到你的组件类, 当这个组件被呈现时,

04:46.700 --> 04:51.760
这些组件类将被呈现到DOM｡

04:51.760 --> 04:53.830
如果你不知道Angular是如何工作的,

04:53.830 --> 04:55.850
那不是问题｡

04:55.850 --> 04:58.700
你只需要明白, 它和类和装饰器一起工作,

04:58.700 --> 05:01.300
然后它基本上和我们在这里做的一样｡

05:01.300 --> 05:03.600
这是你可以用装饰器做的另一件事,

05:03.600 --> 05:06.400
或者特别是在这里, 用装饰器工厂｡

05:06.400 --> 05:12.210
因为这让我们可以传递我们需要的额外冲突｡

05:12.210 --> 05:13.610
这也是我所说的元编程｡ 

05:13.610 --> 05:16.590
我们正在创建东西, 我们正在创建装饰器函数,

05:16.590 --> 05:21.130
你可能会说这对最终用户有一些影响｡

05:21.130 --> 05:24.840
在NP双渲染或屏幕上的东西在这里｡ 

05:24.840 --> 05:29.090
但是我们使用一个工具来实现这一点, 我们向其他开发人员公开了这个工具｡

05:29.090 --> 05:31.370
因为这个装饰器就是这样一个工具,

05:31.370 --> 05:36.000
其他开发人员必须通过将它添加到这个示例中的类来使用它｡

05:36.000 --> 05:38.580
否则, 这将毫无作用｡ 

05:38.580 --> 05:40.300
因此我们为开发人员提供了额外的实用程序,

05:40.300 --> 05:43.490
其他开发人员可以使用这些实用程序, 例如,

05:43.490 --> 05:49.050
方便地为给定的类在屏幕上呈现某些内容｡

05:49.050 --> 05:50.590
这和Angular在这里做的事情是一样的,

05:50.590 --> 05:54.220
以一种更先进的方式, 这是评分人员的完美选择｡
