WEBVTT

00:02.120 --> 00:04.960
教师：这是第一组重要的选项｡

00:04.960 --> 00:07.520
现在让我们深入研究这些严格的选项,

00:07.520 --> 00:09.860
因为它们非常有趣｡

00:09.860 --> 00:13.590
这里有一个strict true选项,

00:13.590 --> 00:16.750
实际上它会启用所有严格类型检查选项,

00:16.750 --> 00:22.110
所以有效地设置它就像分别设置所有这些选项一样.

00:22.110 --> 00:24.830
因此, 您可以逐个设置所有这些选项,

00:24.830 --> 00:27.110
也可以只设置此选项｡

00:27.110 --> 00:29.510
当然, 如果您想将某些选项设置为false,

00:29.510 --> 00:33.020
则需要设置单独的选项｡

00:33.020 --> 00:34.790
否则它们都是真的

00:34.790 --> 00:36.520
如果您希望将它们都设置为true,

00:36.520 --> 00:39.290
那么只使用此选项当然要短得多｡

00:39.290 --> 00:41.360
这些选项有什么作用？

00:41.360 --> 00:43.213
让我们从noImplicitAny开始｡ 

00:44.282 --> 00:49.180
noImplicitAny是一个非常有趣的选项, 它可以帮助我们编写更好的代码｡

00:49.180 --> 00:53.963
让我们转到这里的分析文件, 在那里我们添加一个函数sendAnalytics,

00:55.270 --> 00:58.070
它可以获得一个数据选项, 在那里我们可以将此数据发送到服务器,

00:58.070 --> 01:03.430
但在这里我只是通过控制台记录它｡

01:03.430 --> 01:07.500
然后我用数据调用sendAnalytics,

01:07.500 --> 01:08.920
所以用字符串｡

01:08.920 --> 01:11.080
现在您可以看到, 我的IDE已经在这里抱怨了,

01:11.080 --> 01:13.160
编译器TypeScript也是如此,

01:13.160 --> 01:17.040
因为如果我试图编译它, 这两者当然是相连的｡

01:17.040 --> 01:20.070
参数数据隐式具有any类型｡ 

01:20.070 --> 01:23.940
这似乎与noImplicitAny选项有关｡

01:23.940 --> 01:29.300
实际上, 如果我把这个设置为false, 那么如果我把所有strict选项都设置为true,

01:29.300 --> 01:31.521
但是我把这个选项设置为false, 我可以这样做,

01:31.521 --> 01:33.810
那么这个错误就会消失｡

01:33.810 --> 01:37.140
无论是在IDE中还是在编译代码时｡ 

01:37.140 --> 01:38.730
那么这个选项有什么作用呢？

01:38.730 --> 01:41.440
它确保了, 我会再次注释掉它,

01:41.440 --> 01:44.210
再次打开它, 因为strict为true,

01:44.210 --> 01:53.020
它确保了我们必须清楚我们的参数, 我们在代码中使用的值｡

01:53.020 --> 01:59.930
在这里, 我们没有向TypeScript提供任何有关我们将在这里作为参数获得的数据类型的信息｡

01:59.930 --> 02:01.320
我们应该这样做｡ 

02:01.320 --> 02:03.800
如果TypeScript能够推断出这一点,

02:03.800 --> 02:08.770
那么当然, 这是好的, 但是这里TypeScript如何能够从这一行推断出它,

02:08.770 --> 02:12.950
请记住, 在执行这个文件之前, 首先声明了这个函数｡

02:12.950 --> 02:15.080
所以在创建函数的时候,

02:15.080 --> 02:18.380
不可能知道函数的最终结果.

02:18.380 --> 02:24.253
因此, 在这里我们可以通过简单地声明类型并明确我们在那里使用的类型来修复这个错误｡

02:25.100 --> 02:29.530
现在请注意, 如果您记录了一个变量, 当您在这里将其设置为true时,

02:29.530 --> 02:37.670
您不会得到关于此声明的错误, 即使它也得到了默认类型any｡

02:37.670 --> 02:39.250
对于变量, 这是可以的｡ 

02:39.250 --> 02:40.910
对于参数, 这是不好的｡ 

02:40.910 --> 02:42.480
为什麽变数可以？

02:42.480 --> 02:44.370
因为TypeScript对变量做了什么,

02:44.370 --> 02:48.880
对变量来说什么是可能的, 什么是不可能的, 因为函数是先创建的｡

02:48.880 --> 02:52.490
在这里, TypeScript能够跟踪您分配的值｡ 

02:52.490 --> 02:54.650
你看, 好的, 我在这里这样记录,

02:54.650 --> 02:58.573
现在我把它设置为true, 所以,

02:59.430 --> 03:08.030
此后, 如果我在这里记录控制台日志, 它是一个布尔值｡

03:08.030 --> 03:11.893
所以这里的TypeScript能够理解你的代码流,

03:11.893 --> 03:15.430
因此, 你不需要在这里精确地定义一个类型｡

03:15.430 --> 03:18.020
当然, 如果你想避免随意赋值,

03:18.020 --> 03:22.940
你需要精确, 因为它是any类型｡

03:22.940 --> 03:25.700
因此, 您仍然希望分配一个类型来避免这种情况,

03:25.700 --> 03:31.410
但TypeScript至少能够确定您正在调用的代码是否与它当前拥有的类型一起工作｡

03:31.410 --> 03:32.410
这里的情况不是这样的,

03:32.410 --> 03:41.393
因为函数在调用之前就定义好了, 因此TypeScript不会知道你传入的内容是否可以在函数内部使用｡

03:43.280 --> 03:46.020
strictNullChecks从来都不是重要选项

03:46.020 --> 03:49.410
它实际上与我们的按钮选择有关, 我们在这里有｡

03:49.410 --> 03:52.670
记住我必须在这里加上这个感叹号才能让它工作｡

03:52.670 --> 03:54.380
否则, 我会得到一个错误｡ 

03:54.380 --> 03:58.430
现在, 我们还可以通过将strictNullChecks设置为false来消除该错误,

03:58.430 --> 04:02.090
而无需添加感叹号｡

04:02.090 --> 04:04.200
所以我们在这里做这个, 然后保存这个｡ 

04:04.200 --> 04:07.860
如你所见, 这个错误现在消失了｡ 

04:07.860 --> 04:10.120
而且我可以编译所有的文件｡ 

04:10.120 --> 04:12.340
现在, strictNullChecks的作用是什么？

04:12.340 --> 04:22.530
它们告诉TypeScript在如何访问和处理可能包含空值的值方面要非常严格｡

04:22.530 --> 04:24.850
此处 的 按钮 可能 为 空 ｡ 

04:24.850 --> 04:29.210
它并不总是指向按钮元素｡ 

04:29.210 --> 04:31.390
它并不总是指向这样一个元素,

04:31.390 --> 04:34.220
因为即使您在这里有这样一个选择器,

04:34.220 --> 04:38.490
按钮可能只是不存在于该脚本运行的页面上｡

04:38.490 --> 04:40.840
因此, TypeScript无法判断,

04:40.840 --> 04:44.900
因为它没有深入到html文件中查看｡

04:44.900 --> 04:48.240
它不知道这是否会成功｡ 

04:48.240 --> 04:53.130
如果它没有返回一个指针和一个空节点, 那么它将返回空值,

04:53.130 --> 04:59.090
准确地说是未定义的, 但是这里是同等对待的｡

04:59.090 --> 05:03.530
因此, 该按钮可能包含空值, 因此此代码可能会失败｡

05:03.530 --> 05:08.480
事实上, 如果我在这里注释掉这个按钮, 如果我现在编译它工作的所有东西,

05:08.480 --> 05:10.733
因为我禁用了空检查｡

05:12.000 --> 05:18.230
但是, 我现在有一个运行时错误, 因为我不能在null上调用事件侦听器addEventListener｡

05:18.230 --> 05:20.970
这里是null因为我没有按钮｡ 

05:20.970 --> 05:26.760
现在, 我们可以通过将strictNullChecks设置为true来避免这个错误｡

05:26.760 --> 05:30.340
如果我们将strict设置为true, 则会自动设置此值｡ 

05:30.340 --> 05:34.450
其中TypeScript预期可能会发生这种情况,

05:34.450 --> 05:38.600
因此, 迫使我们解决该问题｡

05:38.600 --> 05:42.820
现在, 一个简单的解决方案是这里的感叹号操作符｡

05:42.820 --> 05:46.020
这会告诉TypeScript,

05:46.020 --> 05:48.360
您（开发人员）知道这个按钮存在,

05:48.360 --> 05:53.360
或者这个作业会产生非Null值｡

05:53.710 --> 05:58.990
现在也许你知道了, 如果你知道你正在处理HTML代码,

05:58.990 --> 06:00.430
这里有一个按钮,

06:00.430 --> 06:03.310
这个选择器可以工作｡

06:03.310 --> 06:06.623
因此, 在这种情况下使用感叹号就可以了｡

06:07.600 --> 06:09.040
如果你有另一种情况,

06:09.040 --> 06:11.120
你不知道它是否工作,

06:11.120 --> 06:18.210
你只是希望它工作, 那么它可能是更好的简单包装代码可能失败的if检查, 这将是在运行时,

06:18.210 --> 06:21.570
当然也有｡

06:21.570 --> 06:24.960
您可以在这里简单地检查button是否为true, 如果它为null或未定义,

06:24.960 --> 06:27.510
则不会为true｡

06:27.510 --> 06:30.060
如果选中此处, 则将该代码移到此处｡ 

06:30.060 --> 06:35.810
现在, 即使没有感叹号, 在strictNullChecks模式下我们也不会收到错误,

06:35.810 --> 06:39.750
因为TypeScript理解此代码在此if语句内部,

06:39.750 --> 06:41.991
并且此if语句确保按钮不为空,

06:41.991 --> 06:46.310
并且此操作不会失败｡

06:46.310 --> 06:49.310
所以这可能是一个更简单的解决方案｡ 

06:49.310 --> 06:51.060
然而, 当然, 为了节省代码,

06:51.060 --> 06:58.320
如果您确信某些东西确实存在, 使用感叹号是一个更短的绝对好的选择｡

06:58.320 --> 07:00.450
这里我说了both, 这样我们就可以看到两者,

07:00.450 --> 07:02.450
当然你只需要其中之一, 要么是if检查,

07:02.450 --> 07:04.520
要么是感叹号｡

07:04.520 --> 07:07.680
这里strictFunctionTypes是一个更高级的设置,

07:07.680 --> 07:14.830
它捕捉了一些在许多应用程序中可能没有的小范围框｡

07:14.830 --> 07:18.380
它与您可能要设置的函数类型有关｡

07:18.380 --> 07:23.690
函数中没有类型, 但是如果你定义了函数的参数和返回值,

07:23.690 --> 07:27.840
你创建了一个函数类型, 你在基础模块中学过,

07:27.840 --> 07:29.990
然后你可以引入box,

07:29.990 --> 07:39.683
如果你使用类和继承, 我们还没有学过, 也没有用到, 所以现在我们先忽略这个.

07:40.578 --> 07:43.630
strictBindCallApply, 如果您确实使用绑定､

07:43.630 --> 07:46.840
调用或应用, 它可能会很有帮助｡

07:46.840 --> 07:49.680
为此, 让我们快速看一个示例｡ 

07:49.680 --> 07:52.040
这里有按钮和函数｡ 

07:52.040 --> 07:57.040
假设这是一个函数, 我们在这里用function关键字定义,

07:57.780 --> 08:01.100
或者说是一个错误函数.

08:01.100 --> 08:03.650
没关系, 我在这里使用function关键字｡ 

08:04.731 --> 08:09.731
单击处理程序, 然后在那里我控制台｡  已单击日志｡ 

08:11.960 --> 08:13.810
现在我们指向clickHandler,

08:13.810 --> 08:22.780
出于某种原因, 我们希望确保在执行时, 传入某些参数或将this关键字设置为某个值.

08:22.780 --> 08:28.110
现在假设我们需要一个消息参数, 它应该是一个字符串｡

08:28.110 --> 08:32.110
我们还想在这里输出这个｡ 

08:32.110 --> 08:36.010
既然clickHandler像这样被传递给addEventListener,

08:36.010 --> 08:43.570
那么浏览器基本上会为我们执行它, 如果我们想预先配置将要传递的参数, 我们可以使用bind.

08:43.570 --> 08:49.320
bind, 作为第一个参数, 接受this关键字要绑定到的内容｡

08:49.320 --> 08:53.580
这里我们可以说这对我们来说无关紧要因为我们在函数中没有使用它,

08:53.580 --> 08:55.930
所以我们把它绑定为null｡

08:55.930 --> 08:57.700
现在您可以看到, 我得到了一个错误｡ 

08:57.700 --> 09:00.610
如果将strictBindCallApply设置为false,

09:00.610 --> 09:04.613
则会出现可以避免的错误｡

09:07.040 --> 09:08.680
现在您可以看到错误已消失｡ 

09:08.680 --> 09:10.501
那么, 这个选项有什么作用呢？

09:10.501 --> 09:16.020
它主要检查您正在调用的函数是bind､ call还是apply｡

09:16.020 --> 09:20.080
它会检查您在这里设置的内容是否有意义｡ 

09:20.080 --> 09:25.450
在这里, TypeScript看到我们需要一个参数, 我们需要clickHandler中的参数｡

09:25.450 --> 09:28.260
但是, 使用bind时, 我们并不进行配置｡ 

09:28.260 --> 09:30.600
因此, 我们得到了一个错误｡ 

09:30.600 --> 09:32.180
如果我把它设置回true,

09:32.180 --> 09:34.000
或者我只是注释掉它, 因为, 当然,

09:34.000 --> 09:37.870
通过把strict设置为true, 它在默认情况下被设置为true,

09:37.870 --> 09:39.790
因此, 我们再次得到错误｡

09:39.790 --> 09:42.350
如果我们不希望在这里有参数, 你会看到,

09:42.350 --> 09:44.750
如果我们只删除了消息, 错误就会消失,

09:44.750 --> 09:50.660
因为TypeScript理解我们的代码, 并看到你没有向那个方法或这个函数传递任何参数,

09:50.660 --> 09:54.760
因为它不接受任何参数, 所以这没问题｡

09:54.760 --> 09:57.420
当然, 这里我们想要一个, 所以我们得到一个错误｡ 

09:57.420 --> 10:00.880
解决方法是在这里提供第二个参数,

10:00.880 --> 10:04.350
也就是你要传入的第一个参数.

10:04.350 --> 10:06.290
TypeScript在这方面非常聪明｡ 

10:06.290 --> 10:08.120
例如, 如果我传入一个数字,

10:08.120 --> 10:11.610
它仍然会抱怨, 因为它明白我需要一个字符串｡

10:12.500 --> 10:15.960
如果我传入了一个正确的字符串, 比如你是受欢迎的,

10:15.960 --> 10:17.350
那么它就不会再抱怨了,

10:17.350 --> 10:24.840
因为它不理解这个字符串, 它看到这个字符串与我的函数定义相匹配｡

10:24.840 --> 10:30.260
因此, 这是一个非常有用的行为, 可以确保您不会意外地以不适用于您的代码的方式使用bind､

10:30.260 --> 10:32.743
call或apply｡

10:33.930 --> 10:37.810
现在, 一旦我们使用类, strictPropertyInitialization就变得很重要了｡

10:37.810 --> 10:39.213
我们可以暂时忽略它｡ 

10:39.213 --> 10:41.890
no隐含现在这也不重要｡ 

10:41.890 --> 10:43.650
它必须使用this关键字,

10:43.650 --> 10:45.980
如果你在不清楚它所指的地方使用this关键字,

10:45.980 --> 10:51.020
TypeScript基本上会试图警告你｡

10:51.020 --> 10:55.560
alwaysStrict只是控制所生成的JavaScript文件使用严格模式,

10:55.560 --> 10:58.663
以便添加此模式｡

10:59.710 --> 11:02.383
这样, 我们就涵盖了所有这些严格的选项｡ 
