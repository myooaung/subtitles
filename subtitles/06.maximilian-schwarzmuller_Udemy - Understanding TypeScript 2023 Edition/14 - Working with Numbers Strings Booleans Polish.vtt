WEBVTT

00:01.850 --> 00:03.270
Instruktor: Więc teraz,

00:03.270 --> 00:06.760
gdy wiemy o podstawach TypeScript i jak różni się i wszystko

00:06.760 --> 00:09.661
to związane z JavaScript, wykopmy trochę głębiej

00:09.661 --> 00:11.410
w różnych typach rdzenia,

00:11.410 --> 00:14.148
które zna TypeScript.

00:14.148 --> 00:17.490
Liczba jest typem, który widzimy tutaj, i jak wyjaśniłem, nie ma różnicy między

00:17.490 --> 00:18.500
liczbami całkowitymi,

00:18.500 --> 00:22.050
takimi jak pięć tutaj, a pływakami lub podwójnymi, jak zostałoby to nazwane w innych

00:22.050 --> 00:25.640
językach programowania, jak 2.

00:25.640 --> 00:25.640
8 tutaj.

00:25.640 --> 00:28.440
Rzeczywiście, w JavaScript, a to samo jest prawdziwe w TypeScript,

00:28.440 --> 00:30.810
wszystkie liczby są domyślnie floatami.

00:30.810 --> 00:33.270
Tak więc dla JavaScript, a zatem również dla TypeScript,

00:33.270 --> 00:35.171
nie ma różnicy między pięcioma jak to

00:35.171 --> 00:36.770
i pięcioma jak to.

00:36.770 --> 00:38.640
To jest ten sam numer, w zasadzie.

00:38.640 --> 00:42.720
Teraz, oprócz liczb, mamy też inne typy rdzeni.

00:42.720 --> 00:46.350
I to byłyby ciągi znaków, więc tekst, i booleans.

00:46.350 --> 00:47.800
Przyjrzyjmy się również tym.

00:47.800 --> 00:50.650
Właściwie widzieliśmy wszystkie z nich w akcji tutaj w tym oświadczeniu

00:50.650 --> 00:53.291
if już, które dowiedzieliśmy się, że jest trochę zbędne.

00:53.291 --> 00:55.971
Niemniej jednak, ten tutaj byłby ciągiem.

00:55.971 --> 00:57.720
Również, oczywiście, pięć z cytatami

00:57.720 --> 01:00.389
byłoby ciągiem, ponieważ jest to tekst.

01:00.389 --> 01:03.851
A wynik, na przykład, tego porównania tutaj, to

01:03.851 --> 01:05.170
byłby boolean.

01:05.170 --> 01:08.090
Ten operator, potrójny znak równości lub

01:08.090 --> 01:10.950
zanegowany operator równości tutaj, który

01:10.950 --> 01:13.640
produkuje prawdę lub fałsz.

01:13.640 --> 01:14.720
I oczywiście możemy

01:14.720 --> 01:17.340
albo wyprodukować dynamicznie innerRef check,

01:17.340 --> 01:18.850
co często będziemy robić.

01:18.850 --> 01:22.340
Albo inicjalizujemy zmienną z wartością true lub false, więc zróbmy tutaj

01:22.340 --> 01:23.379
obie te rzeczy.

01:23.379 --> 01:27.509
Tutaj moglibyśmy dodać nową stałą "printResult".

01:27.509 --> 01:29.990
I ustawić to na true, na przykład.

01:29.990 --> 01:31.320
I żeby było naprawdę jasne,

01:31.320 --> 01:33.130
to też może być zmienna.

01:33.130 --> 01:34.460
To nie musi być const.

01:34.460 --> 01:36.030
Może to być zmienna, którą utworzyłbyś

01:36.030 --> 01:37.730
za pomocą let w JavaScript.

01:37.730 --> 01:39.870
Ale ponieważ nie planuję go tutaj zmieniać,

01:39.870 --> 01:40.703
pójdę ze stałą.

01:40.703 --> 01:43.670
I moglibyśmy przekazać to jako trzeci parametr tutaj.

01:43.670 --> 01:46.960
Powiedzmy, że przekazujemy "printResult", który trzyma się tutaj prawdy.

01:46.960 --> 01:49.720
Teraz oczywiście natychmiast otrzymujemy błąd, ponieważ

01:49.720 --> 01:53.160
nasza funkcja add nie obsługuje trzeciego argumentu.

01:53.160 --> 01:55.560
Widzimy: "Spodziewaliśmy się dwóch argumentów, a dostaliśmy trzy".

01:55.560 --> 01:57.260
Dlatego musimy upewnić się, że

01:57.260 --> 01:58.920
popieramy trzeci argument.

01:58.920 --> 02:03.920
I tam moglibyśmy dodać parametr "showResult".

02:03.940 --> 02:05.920
Tutaj również możesz nadać mu nazwę "printResult".

02:05.920 --> 02:07.910
Idę z "showResult", aby uniknąć zamieszania

02:07.910 --> 02:11.340
dotyczącego nazewnictwa, ale, technicznie rzecz biorąc, te dwie nazwy

02:11.340 --> 02:12.930
nie zderzyłyby się.

02:12.930 --> 02:14.320
Tak więc tutaj nazwę ją "showResult".

02:14.320 --> 02:17.580
I chcę się upewnić, że jest to typ boolean, ustawiając

02:17.580 --> 02:19.500
to na boolean.

02:19.500 --> 02:22.109
Ponownie, dodając dwukropek po parametrze

02:22.109 --> 02:25.120
tutaj, a następnie dodając nazwę typu.

02:25.120 --> 02:28.100
Teraz ta funkcja akceptuje to, a teraz to, co możemy

02:28.100 --> 02:31.787
zrobić, to możemy dodać if check tutaj i sprawdzić "if showResult",

02:31.787 --> 02:36.480
jeśli to jest prawda, możemy oczywiście porównać to z true.

02:36.480 --> 02:37.628
Ale jak wiesz w JavaScript,

02:37.628 --> 02:41.990
możesz również po prostu przekazać tutaj wartość truthy lub falsy.

02:41.990 --> 02:43.970
I JavaScript to oceni, i jeśli

02:43.970 --> 02:47.389
to da true jakoś, albo w ogóle wartość truthy, to zrobimy

02:47.389 --> 02:48.989
to w bloku if.

02:48.989 --> 02:50.011
W przeciwnym razie nie będziemy.

02:50.011 --> 02:52.900
I powiedzmy, że robimy to tutaj, a następnie

02:52.900 --> 02:55.429
chcę "konsoli". log n1 plus n2".

02:55.429 --> 02:58.581
W przeciwnym razie, w else case, jeśli nie uda nam się tam

02:58.581 --> 03:00.549
dostać, wtedy chcę zwrócić to.

03:00.549 --> 03:02.300
Więc teraz jest to funkcja, która

03:02.300 --> 03:04.760
czasami zwraca wartość, a czasami nie zwraca

03:04.760 --> 03:08.309
wartości, ale wyprowadza ją natychmiast.

03:08.309 --> 03:11.550
Teraz mógłbyś argumentować, jeśli chcesz napisać taką funkcję,

03:11.550 --> 03:14.310
która jest w pewnym sensie nieprzewidywalna lub która

03:14.310 --> 03:16.651
może zachować się nieoczekiwanie, jeśli przekazujesz

03:16.651 --> 03:18.349
tutaj prawdę.

03:18.349 --> 03:19.990
Ale tutaj, robimy to.

03:19.990 --> 03:22.090
Więc ta funkcja tylko czasami zwraca.

03:22.090 --> 03:24.869
Czasami również nie wraca, ale zamiast

03:24.869 --> 03:27.830
tego po prostu loguje coś do konsoli.

03:27.830 --> 03:31.120
Teraz tutaj możemy właściwie wywołać add tak po prostu

03:31.120 --> 03:33.640
i nie musimy przechowywać go w result

03:33.640 --> 03:37.570
i nie musimy konsoli. wynik dziennika, ponieważ z "printResult"

03:37.570 --> 03:39.550
ustawionym na true, dodaj się.

03:39.550 --> 03:41.869
Czyli sama funkcja będzie drukować wynik.

03:41.869 --> 03:43.640
Stąd, jeśli teraz zapiszemy to

03:43.640 --> 03:47.880
i przekompilujemy naszą aplikację. plik ts tutaj za pomocą polecenia tsc.

03:47.880 --> 03:50.830
Po wykonaniu tego strona przeładuje się, a my nadal

03:50.830 --> 03:52.600
widzimy nasze wyjście tutaj.

03:52.600 --> 03:54.677
Ale teraz pochodzi z linii szóstej.

03:54.677 --> 03:57.690
I jeśli spojrzymy, linia szósta jest, rzeczywiście,

03:57.690 --> 03:58.980
wewnątrz funkcji.

03:58.980 --> 03:59.891
Więc to jest boolean.

03:59.891 --> 04:02.429
Teraz powiedzmy, że chcemy dostosować wyjście.

04:02.429 --> 04:06.190
W if tutaj mamy stałą "resultPhrase", gdzie mówimy "Result

04:06.190 --> 04:10.181
is" dwukropek, a następnie trochę białej przestrzeni.

04:10.181 --> 04:14.205
I to również przekazujemy za pomocą "resultPhrase" tutaj.

04:14.205 --> 04:17.410
W takim razie możemy spodziewać się tego jako argumentu również tutaj.

04:17.410 --> 04:20.750
Fraza, która dałaby ciąg rurowy, przez dodanie dwukropka.

04:20.750 --> 04:22.291
A następnie string jest nazwą

04:22.291 --> 04:26.469
typu, a teraz moglibyśmy użyć tego wyrażenia, aby wyprowadzić go jako część

04:26.469 --> 04:31.193
naszego wyniku wyjściowego, jeśli drukujemy wynik bezpośrednio w funkcji.

04:31.193 --> 04:34.789
Więc wtedy tutaj moglibyśmy mieć "fraza plus n1 plus n2".

04:34.789 --> 04:37.440
A jeśli to zrobimy i przekompilujemy powtarzając

04:37.440 --> 04:39.040
to polecenie, zobaczymy,

04:39.040 --> 04:41.720
że ta fraza jest częścią wyniku.

04:41.720 --> 04:44.861
Ale my również, teraz, ponownie wprowadziliśmy stary

04:44.861 --> 04:48.141
błąd, ponieważ mam ciąg, który łączę z dwoma liczbami.

04:48.141 --> 04:52.000
Wszystko jest tutaj konwertowane na ciąg znaków, a to nie jest

04:52.000 --> 04:53.240
to, czego chcę.

04:53.240 --> 04:55.930
Aby tego uniknąć, w tej funkcji moglibyśmy dodać

04:55.930 --> 04:57.708
tutaj zmienną wynikową.

04:57.708 --> 05:02.027
Lub stała wynikowa i przechowujemy tutaj nasz wynik.

05:02.027 --> 05:04.530
Zostanie to teraz potraktowane w sposób matematyczny,

05:04.530 --> 05:07.990
ponieważ w grę wchodzą tylko liczby, a następnie, tutaj, moglibyśmy

05:07.990 --> 05:11.430
połączyć to z wyrażeniem lub po prostu zwrócić.

05:11.430 --> 05:15.160
I teraz, ponieważ nigdy nie jest to bezpośrednio obliczane razem z ciągiem,

05:15.160 --> 05:17.029
to zawsze będzie to liczba.

05:17.029 --> 05:19.350
I tak, wtedy tutaj ta liczba połączona z tym ciągiem zostanie

05:19.350 --> 05:21.140
przekonwertowana na ciąg znaków.

05:21.140 --> 05:24.360
Ale ponieważ obliczenia matematyczne zakończyły się wcześniej, będziemy

05:24.360 --> 05:25.548
mieli właściwy wynik.

05:25.548 --> 05:28.520
Więc teraz, jeśli powtórzymy to, a następnie przekompilujemy,

05:28.520 --> 05:30.181
otrzymamy właściwe wyjście.

05:30.181 --> 05:33.050
Więc teraz są to podstawowe typy danych w działaniu.

05:33.050 --> 05:35.541
Upewnijmy się teraz, że w pełni rozumiemy,

05:35.541 --> 05:38.061
jak przypisywane są typy, a także, dlaczego

05:38.061 --> 05:41.343
nie przypisujemy jawnie typów tam na dole.
