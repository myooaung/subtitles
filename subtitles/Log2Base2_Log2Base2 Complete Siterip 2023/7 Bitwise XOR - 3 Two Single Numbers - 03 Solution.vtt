WEBVTT

1
00:00:00.140 --> 00:00:03.950
So let us write a function two single numbers by passing 

2
00:00:03.950 --> 00:00:08.350
the array and its size and two integer pointers Numb one 

3
00:00:08.360 --> 00:00:11.950
and numb two first we need to XOR all 

4
00:00:11.950 --> 00:00:16.020
the numbers while doing this all the same numbers will 

5
00:00:16.020 --> 00:00:19.590
cancel out and the XOR value of odd occurring 

6
00:00:19.590 --> 00:00:24.700
numbers will remain so write int i int XOR result 

7
00:00:24.700 --> 00:00:25.700
equal to zero 

8
00:00:26.050 --> 00:00:29.410
And now write the for loop for i equal to zero 

9
00:00:29.420 --> 00:00:33.240
I less than size I plus plus XOR Result 

10
00:00:33.560 --> 00:00:36.150
XOR equal to array of I 

11
00:00:36.740 --> 00:00:40.100
Next we need to find the first set bit to 

12
00:00:40.100 --> 00:00:43.920
split the numbers from the XOR result For that 

13
00:00:44.100 --> 00:00:47.770
we can continuously left shift the number one and perform 

14
00:00:47.770 --> 00:00:51.720
bitwise AND operation on XOR result until we 

15
00:00:51.720 --> 00:00:55.770
get the result as one so write int first 

16
00:00:55.770 --> 00:00:59.040
set bit equal to one that is initialised first set 

17
00:00:59.040 --> 00:01:00.010
bit as one 

18
00:01:00.190 --> 00:01:05.870
Then write while XOR result and first set bit equal 

19
00:01:05.870 --> 00:01:09.740
to zero First set bit left shift equal to one 

20
00:01:10.030 --> 00:01:13.210
Now we need to group all the numbers based on 

21
00:01:13.210 --> 00:01:16.680
the first set bit and perform XOR on each 

22
00:01:16.680 --> 00:01:19.760
group at the end of this process we will get 

23
00:01:19.770 --> 00:01:22.550
two odd occurring numbers as the result 

24
00:01:22.770 --> 00:01:26.320
So declared int N1 equal to zero and N2 

25
00:01:26.320 --> 00:01:29.770
equal to zero to store the result and then 

26
00:01:29.770 --> 00:01:33.820
write for i equal to zero I lessthan size I plus 

27
00:01:33.820 --> 00:01:34.260
plus 

28
00:01:34.840 --> 00:01:37.440
And if the Bit is set this will be the first 

29
00:01:37.440 --> 00:01:40.460
group and if the Bit is unset this will be 

30
00:01:40.460 --> 00:01:41.620
the second group 

31
00:01:41.800 --> 00:01:42.500
So write 

32
00:01:42.590 --> 00:01:47.620
If array of I and first set bit then N1

33
00:01:47.620 --> 00:01:51.410
XOR equal to array of I else N2 

34
00:01:51.420 --> 00:01:54.860
XOR equal to array of I finally we 

35
00:01:54.860 --> 00:01:57.650
can store the result in numb one and numb two 

36
00:01:57.840 --> 00:02:02.150
so write start numb one equal to N1 and 

37
00:02:02.150 --> 00:02:04.250
start numb two equal to N2 

38
00:02:04.640 --> 00:02:05.410
And that's it.

