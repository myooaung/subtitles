WEBVTT

1
00:00:00.040 --> 00:00:03.470
So let us write a function print level order to print 

2
00:00:03.470 --> 00:00:05.850
a level order traverse alot of beina oratory 

3
00:00:06.440 --> 00:00:09.300
So this function takes the root of the tree as 

4
00:00:09.310 --> 00:00:09.850
input.

5
00:00:10.440 --> 00:00:14.570
Firstly if the given tree is empty we can return 

6
00:00:14.570 --> 00:00:15.450
straight away 

7
00:00:15.920 --> 00:00:20.930
So write if root equal to null, then return If not 

8
00:00:21.110 --> 00:00:23.750
we need to declare a queue for level order traversal 

9
00:00:23.750 --> 00:00:26.890
and push the root of the tree into it.

10
00:00:26.890 --> 00:00:27.250


11
00:00:28.210 --> 00:00:31.450
So write q (node *  q)

12
00:00:32.140 --> 00:00:36.790
So a queue named Q is created now write

13
00:00:37.170 --> 00:00:40.350
push(root) to insert the root into the queue 

14
00:00:41.140 --> 00:00:44.140
After that while the queue is north empty 

15
00:00:44.300 --> 00:00:46.730
We need to get front node print 

16
00:00:46.740 --> 00:00:50.540
It's dad out then pop it and push its children 

17
00:00:50.540 --> 00:00:52.680
into the queue and repeat the process.

18
00:00:53.440 --> 00:00:57.050
So write while not Q.empty 

19
00:00:57.640 --> 00:00:59.390
First get the front node 

20
00:00:59.720 --> 00:01:02.810
Using front function, we can get the front node 

21
00:01:02.810 --> 00:01:03.940
so write 

22
00:01:03.940 --> 00:01:08.150
node * node equal to q.front and then print 

23
00:01:08.150 --> 00:01:09.550
the node data 

24
00:01:09.860 --> 00:01:12.650
So write cout.node data 

25
00:01:13.210 --> 00:01:15.850
The next step is to pop the front node 

26
00:01:16.240 --> 00:01:18.570
And since we have took the back up of front node

27
00:01:18.570 --> 00:01:22.170
in variable node we can pop front node from the 

28
00:01:22.170 --> 00:01:22.650
queue.

29
00:01:22.990 --> 00:01:27.130
So write q.pop after that we need to 

30
00:01:27.130 --> 00:01:30.430
push the current node's left and right child into the 

31
00:01:30.430 --> 00:01:30.750
queue.

32
00:01:31.340 --> 00:01:34.340
But before that, we need to check if left and 

33
00:01:34.340 --> 00:01:38.300
right is if it is not feed only to push it 

34
00:01:38.300 --> 00:01:42.200
so write if not left not equal to null 

35
00:01:42.550 --> 00:01:44.690
q.push(node-left)

36
00:01:44.880 --> 00:01:48.760
And if node-right not equal to null 

37
00:01:48.770 --> 00:01:51.290
q.push(node-right) And that's it 

38
00:01:51.720 --> 00:01:54.810
This while loop will execute as long as the queue is 

39
00:01:54.810 --> 00:01:58.390
not empty and when it becomes 70 we will have 

40
00:01:58.390 --> 00:02:00.750
the level order traversal of the tree printed 

