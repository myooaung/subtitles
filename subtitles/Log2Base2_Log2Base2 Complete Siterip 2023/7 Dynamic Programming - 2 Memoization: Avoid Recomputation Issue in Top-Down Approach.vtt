WEBVTT

1
00:00:00.340 --> 00:00:04.470
Hello friends In this video let us understand how to 

2
00:00:04.480 --> 00:00:06.580
avoid the recomputation  issue 

3
00:00:07.940 --> 00:00:12.010
In the previous video we have discussed about dynamic programming 

4
00:00:12.010 --> 00:00:14.960
approaches and the recomputation issues 

5
00:00:14.970 --> 00:00:18.470
In the top-down approach, we can avoid the

6
00:00:18.470 --> 00:00:24.170
recomputation issue using MEMORISATION to avoid the  recomputation issue 

7
00:00:24.180 --> 00:00:27.790
we need to store the result of subproblems in 

8
00:00:27.790 --> 00:00:31.700
the separate memory so that when we face the same 

9
00:00:31.700 --> 00:00:35.300
subproblem again we need not solve them again 

10
00:00:35.640 --> 00:00:39.350
Instead we can reuse the already solve result 

11
00:00:40.020 --> 00:00:42.050
This is called Memorisation 

12
00:00:42.600 --> 00:00:46.560
Let us understand that by solving the same Nth Fibonacci 

13
00:00:46.560 --> 00:00:50.970
problem using a top-down approach with an array additional 

14
00:00:50.970 --> 00:00:51.550
memory 

15
00:00:52.340 --> 00:00:57.050
To find the fourth Fibonacci number locate five memories Lots 

16
00:00:57.740 --> 00:01:01.800
as we know the base case fib(0) is 0 and 

17
00:01:01.800 --> 00:01:05.890
fib(1) is 1  so stores 0 and 1

18
00:01:05.900 --> 00:01:06.750
in the memory 

19
00:01:07.240 --> 00:01:11.310
The idea here is before making any recursive  call 

20
00:01:11.540 --> 00:01:14.650
check if it is already solved in the memory 

21
00:01:15.040 --> 00:01:16.980
If it is solve just returned 

22
00:01:16.980 --> 00:01:20.820
The result otherwise initiate the recursive call to solve the 

23
00:01:20.820 --> 00:01:21.750
sub problem 

24
00:01:22.540 --> 00:01:25.270
So fib(0) and fib(1) are stored 

25
00:01:25.270 --> 00:01:29.050
here now Fib(2) will be calculated which is 

26
00:01:29.200 --> 00:01:32.830
fib(0) plus fib(1) now fib(0)

27
00:01:32.830 --> 00:01:35.730
 and fib(1) are bass cases and are 

28
00:01:35.740 --> 00:01:39.790
already stored in the array so fib(2) will be 

29
00:01:39.790 --> 00:01:44.320
calculated which is zero plus one equal to one and 

30
00:01:44.330 --> 00:01:48.470
it will be stored in the array now fib(3) will be 

31
00:01:48.470 --> 00:01:49.380
calculated 

32
00:01:49.940 --> 00:01:54.400
It is not stored in the array so computed that is 

33
00:01:54.410 --> 00:01:55.750
fib(2) plus fib(1) 

34
00:01:55.750 --> 00:02:00.020
that is one plus one equals 2 So

35
00:02:00.020 --> 00:02:03.080
fib(3) equal to  two at it will be stored in 

36
00:02:03.080 --> 00:02:07.950
the Array now fib(2) should be calculated and when 

37
00:02:07.960 --> 00:02:11.640
it is checked in the array it is already computed and 

38
00:02:11.640 --> 00:02:14.880
stored in the array so it is only a matter of 

39
00:02:14.880 --> 00:02:16.230
returning it from there 

40
00:02:16.240 --> 00:02:19.660
We do not need to call fib(0) and 

41
00:02:19.660 --> 00:02:23.370
one recursively so the repeated work is not 

42
00:02:23.380 --> 00:02:24.350
occurring here 

43
00:02:25.040 --> 00:02:28.380
Now fib(4) should be calculated and it is not 

44
00:02:28.390 --> 00:02:32.210
already stored in the so computed that is fib(3)

45
00:02:32.220 --> 00:02:33.230
 plus fib(2)

46
00:02:33.230 --> 00:02:36.380
that is two plus one equal to three 

47
00:02:36.390 --> 00:02:37.750
and it will be stored

48
00:02:39.240 --> 00:02:43.360
This is how memorization avoids the recomputation of same  

49
00:02:43.360 --> 00:02:48.000
subproblem in the top-down  approach


