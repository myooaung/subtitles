WEBVTT

1
00:00:00.740 --> 00:00:01.620
Hello friends 

2
00:00:01.680 --> 00:00:05.350
In this video let us discuss about hashing and coalition 

3
00:00:06.240 --> 00:00:10.680
So Marty's hashing hashing is an efficient method to store 

4
00:00:10.690 --> 00:00:12.120
and access elements 

5
00:00:12.160 --> 00:00:15.770
It's exactly same as index page of a book in 

6
00:00:15.770 --> 00:00:16.800
the index page 

7
00:00:16.840 --> 00:00:19.930
Every topic is associated with the page number 

8
00:00:20.060 --> 00:00:22.540
If we want to look for some topic we can 

9
00:00:22.540 --> 00:00:25.310
directly get the page number from the index 

10
00:00:25.360 --> 00:00:30.070
Likewise in hashing every value will be associated with a 

11
00:00:30.070 --> 00:00:30.440
key 

12
00:00:30.570 --> 00:00:34.330
Using this key we can point out the element directly 

13
00:00:34.580 --> 00:00:35.620
In this video 

14
00:00:35.790 --> 00:00:40.620
We will learn how hashing improves searching performance letters take 

15
00:00:40.630 --> 00:00:45.150
an unsalted array of eight elements and perform linear search 

16
00:00:45.640 --> 00:00:49.410
What will be the worst case time complexity that is 

17
00:00:49.420 --> 00:00:54.340
finding the element 1 23 Since the area is unsalted 

18
00:00:54.420 --> 00:00:57.180
we need to traverse the whole area to find the 

19
00:00:57.190 --> 00:00:58.550
element 1 23 

20
00:00:58.940 --> 00:00:59.600
Here 

21
00:00:59.610 --> 00:01:03.210
The area has eight elements and the time complex ary 

22
00:01:03.210 --> 00:01:05.350
will be or drop eight 

23
00:01:06.440 --> 00:01:09.570
And in general if the area has any elements the 

24
00:01:09.570 --> 00:01:12.330
worst case time complex we will be or drove 

25
00:01:12.340 --> 00:01:16.750
And now let us take assorted array of eight elements 

26
00:01:16.760 --> 00:01:18.450
and perform beina research 

27
00:01:19.140 --> 00:01:21.770
Now what will be the worst case time complexity 

28
00:01:21.770 --> 00:01:24.850
Here let a search for Element 45 

29
00:01:25.640 --> 00:01:29.360
Here we will divide the into two and searched the 

30
00:01:29.360 --> 00:01:32.950
key in one half only and ignore the other half 

31
00:01:33.440 --> 00:01:35.250
This is done in each step 

32
00:01:35.840 --> 00:01:36.370
Status 

33
00:01:36.570 --> 00:01:38.040
Find the middle element 

34
00:01:38.040 --> 00:01:41.930
First it is 70 and the key 45 is less 

35
00:01:41.930 --> 00:01:42.750
than 70 

36
00:01:43.140 --> 00:01:45.370
So we need to search in first half 

37
00:01:45.380 --> 00:01:49.750
Only now find the middle element again at least 23 

38
00:01:50.140 --> 00:01:53.390
And the key 45 is greater than 23 

39
00:01:53.400 --> 00:01:56.530
So search in second half only and it is found 

40
00:01:56.530 --> 00:01:56.950
here 

41
00:01:57.440 --> 00:02:00.650
So in each step we are reducing the search space 

42
00:02:00.660 --> 00:02:03.110
into half thatis force 

43
00:02:03.110 --> 00:02:06.580
We have any elements then and buy two then and 

44
00:02:06.580 --> 00:02:09.250
buy for then and by eight and soul 

45
00:02:09.740 --> 00:02:12.800
So we will get the time complexity as order of 

46
00:02:12.810 --> 00:02:14.650
lock and two bass two 

47
00:02:15.040 --> 00:02:18.300
So if the air is sorted the worst case time 

48
00:02:18.300 --> 00:02:21.950
complex Serie is order of log and two bass two 

49
00:02:22.060 --> 00:02:22.600
That is 

50
00:02:22.610 --> 00:02:26.130
Here it is All draw Flock 82 Bass two 

51
00:02:26.140 --> 00:02:27.650
That is odd Raftery 

52
00:02:28.440 --> 00:02:30.700
Now the question is can be improved 

53
00:02:30.700 --> 00:02:34.710
The time complexity even further can be search and element 

54
00:02:34.710 --> 00:02:36.050
In order of one time 

55
00:02:36.640 --> 00:02:38.650
The answer is Yes we can 

56
00:02:39.040 --> 00:02:42.390
We can do it Using hashing let us take a 

57
00:02:42.390 --> 00:02:47.670
hash table of size and and the elements 246 and 

58
00:02:47.680 --> 00:02:48.150
eight 

59
00:02:48.940 --> 00:02:52.550
The simplest method is placing the key in the exact 

60
00:02:52.560 --> 00:02:57.160
area index thatis using the function f x equal to 

61
00:02:57.170 --> 00:03:00.970
x so when ex acquitted to f off to is 

62
00:03:00.980 --> 00:03:05.050
equal to so place the element to in index to 

63
00:03:05.640 --> 00:03:09.710
when X equal to 444 is equal to for PSA 

64
00:03:09.710 --> 00:03:13.580
placed the element for in index for when Xs equal 

65
00:03:13.580 --> 00:03:16.640
to sex F off six is equal to six sir 

66
00:03:16.640 --> 00:03:20.710
Place the elements six in index six and similarly when 

67
00:03:20.720 --> 00:03:23.950
x equal to eight f of eight equal to eight 

68
00:03:24.140 --> 00:03:28.300
So place the element eight in index eight and if 

69
00:03:28.300 --> 00:03:31.340
we want to search the element we can directly find 

70
00:03:31.340 --> 00:03:34.970
it using the same method we have f X equal 

71
00:03:34.970 --> 00:03:35.620
to X 

72
00:03:35.870 --> 00:03:38.650
So if we want to search the Element eight we 

73
00:03:38.650 --> 00:03:40.930
have f of eight equal to eight 

74
00:03:41.230 --> 00:03:45.010
So searched the Element eight in area index eight and 

75
00:03:45.010 --> 00:03:48.570
we have eight here so the search is formed and 

76
00:03:48.580 --> 00:03:51.640
if we want to search the elements seven we have 

77
00:03:51.650 --> 00:03:53.560
efforts seven equal to seven 

78
00:03:53.570 --> 00:03:56.420
And in index seven we don't have the Element seven 

79
00:03:56.430 --> 00:03:58.250
so the search is not found 

80
00:03:58.940 --> 00:04:02.170
But there is a major drawback in this technic 

81
00:04:02.180 --> 00:04:03.900
Let us find what it is 

82
00:04:04.070 --> 00:04:09.640
Let us insert the element 100 so 400 equal 201 

83
00:04:09.640 --> 00:04:12.400
100 will be placed in the index 100 

84
00:04:12.590 --> 00:04:15.770
And just because of this one bigger element we are 

85
00:04:15.770 --> 00:04:17.950
wasting so many bytes of data 

86
00:04:18.140 --> 00:04:20.650
So this is not a space efficient method 

87
00:04:20.840 --> 00:04:23.860
So what can we do We can reduce the space 

88
00:04:23.860 --> 00:04:27.150
using the modal Oh operator As we know when we 

89
00:04:27.150 --> 00:04:31.020
used more law an operator the output is always in 

90
00:04:31.020 --> 00:04:33.550
range of zero to end minus one 

91
00:04:34.040 --> 00:04:37.670
For example let us assume N is equal to three 

92
00:04:37.900 --> 00:04:42.700
Let us take a number 003 east equal to 01 

93
00:04:42.700 --> 00:04:46.220
more tree is equal to 12 more tree is acquitted 

94
00:04:46.230 --> 00:04:49.830
to and three more tree is equal to zero for 

95
00:04:49.830 --> 00:04:53.110
more tree is equal to one five more tree is 

96
00:04:53.120 --> 00:04:53.920
equal to two 

97
00:04:54.110 --> 00:04:57.480
If we absorbed the result it will always be in 

98
00:04:57.480 --> 00:05:01.920
between 023 minus one which is 0 to 2 so 

99
00:05:01.920 --> 00:05:05.490
we can change our method using the model operator so 

100
00:05:05.490 --> 00:05:09.270
that it will always provide the index within a range 

101
00:05:09.280 --> 00:05:11.650
so we can effectively save the space 

102
00:05:11.790 --> 00:05:14.580
The new method will be F o X is equal 

103
00:05:14.580 --> 00:05:17.040
to X mode size here 

104
00:05:17.050 --> 00:05:19.850
Size indicate the hash table size 

105
00:05:19.930 --> 00:05:23.500
Let us understand how we can store and retrieve elements 

106
00:05:23.500 --> 00:05:24.640
using this method 

107
00:05:25.540 --> 00:05:30.090
Day hash tables of size seven initialise it with minus 

108
00:05:30.090 --> 00:05:31.520
one minus 

109
00:05:31.520 --> 00:05:35.640
One indicates element is not present or the particular index 

110
00:05:35.650 --> 00:05:37.210
is available to insert 

111
00:05:37.270 --> 00:05:39.490
Let us understand the insult operation 

112
00:05:39.490 --> 00:05:43.340
First we have key is equal to data mode size 

113
00:05:43.400 --> 00:05:46.650
If the element to be inserted or the data is 

114
00:05:46.650 --> 00:05:48.960
24 were should be inserted 

115
00:05:49.030 --> 00:05:50.650
We can apply it here 

116
00:05:50.840 --> 00:05:54.160
Key is equal to data mode size status 

117
00:05:54.330 --> 00:05:57.550
20 for more seven which is equal to three 

118
00:05:57.940 --> 00:06:02.700
So insert 24 at index tree and to insert eight 

119
00:06:02.710 --> 00:06:06.080
we have key is equal to eight more seven which 

120
00:06:06.080 --> 00:06:10.030
is equal to one so a is inserted at index 

121
00:06:10.030 --> 00:06:10.450
one 

122
00:06:11.040 --> 00:06:14.530
And to insert Fortin we have key equal to 14 

123
00:06:14.530 --> 00:06:17.890
more seven which is equal to zero so 14 is 

124
00:06:17.900 --> 00:06:21.960
inserted at index zero So that is how we insert 

125
00:06:21.970 --> 00:06:26.940
elements now let us understand how search can be performed 

126
00:06:27.060 --> 00:06:30.660
We can perform Modelo size operation on the element to 

127
00:06:30.660 --> 00:06:32.850
be searched and we will get a key 

128
00:06:33.240 --> 00:06:35.030
Then we can go and cheque there 

129
00:06:35.280 --> 00:06:38.280
And if it is there it is present and otherwise 

130
00:06:38.290 --> 00:06:39.000
it is not 

131
00:06:39.250 --> 00:06:42.310
For example let a search for Element eight 

132
00:06:42.610 --> 00:06:45.840
Sochi is equal to eight more seven which is equal 

133
00:06:45.840 --> 00:06:46.350
to one 

134
00:06:46.740 --> 00:06:49.650
So go and cheque here and we have eight 

135
00:06:50.240 --> 00:06:53.630
So the search is found now at a search for 

136
00:06:53.780 --> 00:06:58.270
Element 19 Sochi sequel to 19 more seven which is 

137
00:06:58.270 --> 00:06:59.250
equal to five 

138
00:06:59.640 --> 00:07:02.890
So go and cheque here and here We have minus 

139
00:07:02.890 --> 00:07:06.170
one which indicates the element is not present 

140
00:07:06.180 --> 00:07:07.990
So the search is not form 

141
00:07:08.190 --> 00:07:12.270
Now let us discuss about dilation operation to delayed an 

142
00:07:12.280 --> 00:07:16.360
element also we have to first find the key selectors 

143
00:07:16.360 --> 00:07:18.350
delete the Element 24 

144
00:07:18.420 --> 00:07:22.080
So first find the key and we have key sequel 

145
00:07:22.080 --> 00:07:25.130
to 20 for more seven that is equal to three 

146
00:07:25.140 --> 00:07:28.040
So go to index tree and change the value to 

147
00:07:28.040 --> 00:07:30.550
minus one and the delish in is completed 

148
00:07:30.590 --> 00:07:34.160
So that is how we can perform insertion searching and 

149
00:07:34.160 --> 00:07:37.350
delish in now what is Coalition in hashing 

150
00:07:37.840 --> 00:07:41.960
Let us insert the Element 15 in this stable and 

151
00:07:41.960 --> 00:07:45.510
we have Key is equal to a lemon mode size 

152
00:07:45.600 --> 00:07:49.190
that is case equal to 15 more seven which is 

153
00:07:49.200 --> 00:07:50.070
equal to one 

154
00:07:50.150 --> 00:07:53.890
That is the element 15 should be inserted at index 

155
00:07:53.890 --> 00:07:57.220
one but index one already has the element A 

156
00:07:57.230 --> 00:08:00.750
So here to all more different elements are pointing to 

157
00:08:00.750 --> 00:08:04.250
the same index under model of size operation 

158
00:08:04.540 --> 00:08:06.750
And this is what is called coalition 

159
00:08:07.240 --> 00:08:10.510
So how can we handle this kind of coalition Let 

160
00:08:10.510 --> 00:08:13.510
us learn how to avoid a coalition in the next 

161
00:08:13.510 --> 00:08:14.050
video 

162
00:08:14.440 --> 00:08:17.840
So today we have discussed about hashing which is an 

163
00:08:17.850 --> 00:08:22.260
efficient method to perform searching with time complexity or drop 

164
00:08:22.260 --> 00:08:22.650
one 

165
00:08:23.340 --> 00:08:26.270
We found the space where stage problem and we did 

166
00:08:26.270 --> 00:08:29.500
soul with using the mode low operation to get a 

167
00:08:29.500 --> 00:08:31.150
key within the range 

168
00:08:31.740 --> 00:08:35.580
And we also learned how to perform insertion searching and 

169
00:08:35.580 --> 00:08:39.550
dilation and we just had an introduction to coalition 

170
00:08:40.140 --> 00:08:43.750
In the next videos we will learn about coalition resolution 

