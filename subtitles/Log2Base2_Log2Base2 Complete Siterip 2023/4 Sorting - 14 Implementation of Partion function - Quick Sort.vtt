WEBVTT

1
00:00:00.000 --> 00:00:00.920
Hello Friends 

2
00:00:01.060 --> 00:00:05.050
In this video we will learn how to implement partition 

3
00:00:05.050 --> 00:00:06.450
function in Quick sort 

4
00:00:07.020 --> 00:00:10.350
In the previous video we have learned about quick sort 

5
00:00:10.740 --> 00:00:12.680
and how it is performed on an array 

6
00:00:12.840 --> 00:00:16.410
To get it sorted we learnt that there are three 

7
00:00:16.410 --> 00:00:18.650
major steps in quick sort algorithm 

8
00:00:18.660 --> 00:00:22.500
First is to choose the pivot element which can be 

9
00:00:22.510 --> 00:00:23.250
any element 

10
00:00:23.640 --> 00:00:27.060
And then call the partition function which will bring the 

11
00:00:27.070 --> 00:00:31.360
pivot element to it sorted position and all elements 

12
00:00:31.360 --> 00:00:33.950
which are lesser than the pivot will be before the 

13
00:00:33.960 --> 00:00:37.370
pivot element and all the elements which are greater than 

14
00:00:37.370 --> 00:00:40.550
the pivot will be after the pivot in the array

15
00:00:41.340 --> 00:00:44.230
and then we will repeat the process for all the 

16
00:00:44.230 --> 00:00:45.150
partitions 

17
00:00:45.740 --> 00:00:49.720
In this video we will learn how to implement partition 

18
00:00:49.720 --> 00:00:51.250
function of quick sort 

19
00:00:51.640 --> 00:00:55.970
so let us develope the code using this example array So we have 

20
00:00:55.970 --> 00:01:00.060
this array of size five so get it partitioned 

21
00:01:00.080 --> 00:01:04.460
We have to pass the array it's start and its end 

22
00:01:04.630 --> 00:01:05.950
to the partition function 

23
00:01:06.340 --> 00:01:10.050
Now declare the variable p index and initialise it to 

24
00:01:10.050 --> 00:01:13.390
start and let us choose the pivot element as 

25
00:01:13.390 --> 00:01:14.900
the last element of array 

26
00:01:15.200 --> 00:01:20.140
So int pivot equal to arr of end Also 

27
00:01:20.140 --> 00:01:23.590
declare I and it should be initialised to start of 

28
00:01:23.600 --> 00:01:26.050
the array But we will do that later 

29
00:01:26.540 --> 00:01:30.680
Now we have to compare i th element with pivot and 

30
00:01:30.690 --> 00:01:33.680
if I th element is lesser than pivot then 

31
00:01:33.680 --> 00:01:38.060
swap arr of I and arr of P Index and 

32
00:01:38.070 --> 00:01:39.780
increment P index 

33
00:01:40.490 --> 00:01:44.450
And here it is but since both are pointing to same location 

34
00:01:44.590 --> 00:01:47.570
No changes will occur Now we have two increment 

35
00:01:47.570 --> 00:01:51.240
P index so right P index plus plus 

36
00:01:51.740 --> 00:01:55.330
Next I should be incremented and the same process should 

37
00:01:55.330 --> 00:01:58.450
be repeated till we reached the end of the array 

38
00:01:59.240 --> 00:02:02.050
So we can put this code inside a for loop 

39
00:02:02.740 --> 00:02:05.920
for i equal to start I less than end 

40
00:02:06.120 --> 00:02:10.250
I plus plus so this will continue till we reach 

41
00:02:10.250 --> 00:02:14.390
the end of the array And when this loop is exhausted 

42
00:02:14.700 --> 00:02:18.020
we will have the sorted position of the pivot pointed 

43
00:02:18.020 --> 00:02:22.580
by P Index so we can swap arr of end 

44
00:02:22.630 --> 00:02:24.740
and arr of P index 

45
00:02:24.880 --> 00:02:27.950
Now we can return the position of the pivot that 

46
00:02:27.950 --> 00:02:31.540
is P index to the calling function So the return 

47
00:02:31.540 --> 00:02:33.580
type of function should be integer 

48
00:02:34.240 --> 00:02:37.160
So this is how the partition function of quick sort can be implemented. 

