WEBVTT

1
00:00:00.240 --> 00:00:02.850
We can re use the reverse the sub list logic 

2
00:00:02.940 --> 00:00:05.340
and solve the problem in the reverse 

3
00:00:05.340 --> 00:00:06.280
sublist logic 

4
00:00:06.290 --> 00:00:09.500
We have to move to the start index and then 

5
00:00:09.510 --> 00:00:11.870
we need to reverse the linked list from start to 

6
00:00:11.880 --> 00:00:13.440
end here 

7
00:00:13.450 --> 00:00:15.990
We don't need to move to the start position 

8
00:00:16.000 --> 00:00:18.120
Head node is the starting point 

9
00:00:18.270 --> 00:00:21.440
So initially marked the head node as the current node 

10
00:00:21.450 --> 00:00:23.520
and make the previous node point to null 

11
00:00:24.340 --> 00:00:25.700
Now apply the linked list 

12
00:00:25.700 --> 00:00:27.880
Reverse logic to reverse K nodes 

13
00:00:28.340 --> 00:00:30.940
Before that we need to back up the required nodes 

14
00:00:30.940 --> 00:00:32.150
for later Connexion 

15
00:00:32.740 --> 00:00:35.760
As of now the previous pointer is first part 

16
00:00:35.940 --> 00:00:39.950
So Mark previous as first part last node and after 

17
00:00:39.950 --> 00:00:43.160
the reversal node 10 will be the last node of 

18
00:00:43.160 --> 00:00:44.350
reverse K list 

19
00:00:44.620 --> 00:00:48.340
So Mark ten as second part Last node now 

20
00:00:48.340 --> 00:00:51.180
reverse the first k nodes in this case 

21
00:00:51.190 --> 00:00:55.070
We have taken k as three so first three nodes 

22
00:00:55.070 --> 00:00:55.950
will be reversed 

23
00:00:56.640 --> 00:01:00.740
Now we need to make the required connexions like before 

24
00:01:00.750 --> 00:01:01.990
connect the first part 

25
00:01:01.990 --> 00:01:06.010
Last node with previous node If previous is null make 

26
00:01:06.010 --> 00:01:08.710
it head and then connect the second part 

27
00:01:08.710 --> 00:01:10.150
Last node with current 

28
00:01:10.740 --> 00:01:13.090
Now we have reversed the first K nodes 

29
00:01:13.440 --> 00:01:16.340
Now we need to do the same process for Next 

30
00:01:16.340 --> 00:01:17.070
K nodes 

31
00:01:17.080 --> 00:01:19.880
So again we need to mark the previous and current 

32
00:01:19.880 --> 00:01:20.300
nodes 

33
00:01:20.670 --> 00:01:23.230
The current node is already in the right place 

34
00:01:23.490 --> 00:01:25.750
We just need to adjust the previous node 

35
00:01:26.240 --> 00:01:29.970
Now the nodes 30 20 10 is Part one and nodes 

36
00:01:29.980 --> 00:01:32.250
40 50 60 part two 

37
00:01:32.640 --> 00:01:34.770
So the last node of the first part will be 

38
00:01:34.770 --> 00:01:38.510
node ten that is currently pointed by second node last 

39
00:01:38.510 --> 00:01:42.260
part wherever so make prev as second node last part 

40
00:01:42.260 --> 00:01:42.840
variable 

41
00:01:42.850 --> 00:01:46.840
So that's it the previous logic will automatically mark prev 

42
00:01:46.850 --> 00:01:48.920
as last node of the first part 

43
00:01:49.220 --> 00:01:52.320
And current node is the second part last node and 

44
00:01:52.330 --> 00:01:54.950
it will reverse the next K nodes and so on 

45
00:01:55.160 --> 00:01:58.270
So the logic is simple write the logic inside 

46
00:01:58.280 --> 00:02:02.240
The infinite loop First reverse the first K nodes 

47
00:02:02.470 --> 00:02:05.800
after the reversal prepared the previous and current node for 

48
00:02:05.800 --> 00:02:09.140
the next K nodes and that's it it will reverse 

49
00:02:09.150 --> 00:02:12.790
every K nodes of a linked list and finally break 

50
00:02:12.790 --> 00:02:15.550
the infinite loop when the Traversal reaches null. 

