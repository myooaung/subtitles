WEBVTT

1
00:00:00.040 --> 00:00:00.920
Hello Friends 

2
00:00:01.220 --> 00:00:04.360
In this video let us have an introduction to quick 

3
00:00:04.360 --> 00:00:05.450
sort algorithm 

4
00:00:06.240 --> 00:00:07.250
so quick sort 

5
00:00:07.410 --> 00:00:10.790
is a divide and conquer algorithm it divides 

6
00:00:11.010 --> 00:00:13.890
a large array into smaller sub arrays 

7
00:00:14.220 --> 00:00:17.130
And then it will Recursively sort the sub 

8
00:00:17.130 --> 00:00:21.400
arrays There are three major task in quick sort algorithm 

9
00:00:21.670 --> 00:00:26.410
First is pivot elements selection then the partition function 

10
00:00:26.690 --> 00:00:29.230
and finally applying the above process 

11
00:00:29.320 --> 00:00:31.750
recursively to all the sub arrays 

12
00:00:32.290 --> 00:00:33.550
Let us understand it 

13
00:00:33.560 --> 00:00:37.650
Using this example let us take an array of five 

14
00:00:37.660 --> 00:00:42.850
elements 10 25 3 50 and 20 

15
00:00:43.440 --> 00:00:46.180
We need to sort this array using the quick sort 

16
00:00:46.190 --> 00:00:46.950
algorithm 

17
00:00:47.440 --> 00:00:49.760
So the first step is to pick the Pivot

18
00:00:49.770 --> 00:00:51.150
element from this array 

19
00:00:51.730 --> 00:00:54.110
There are many ways in which we can choose the 

20
00:00:54.110 --> 00:00:55.110
pivot element 

21
00:00:55.480 --> 00:00:58.150
It could be the first element of array or the 

22
00:00:58.160 --> 00:01:01.680
last element of the array or the middle element of the array 

23
00:01:01.870 --> 00:01:06.130
Or we can also pick any element randomly here we 

24
00:01:06.130 --> 00:01:08.660
are going to pick the last element as the pivot 

25
00:01:08.660 --> 00:01:09.250
element 

26
00:01:09.940 --> 00:01:11.420
So our pivot element 

27
00:01:11.420 --> 00:01:12.850
Here is 20 

28
00:01:13.340 --> 00:01:15.250
So first task is done 

29
00:01:15.640 --> 00:01:17.200
We chose the pivot element 

30
00:01:17.270 --> 00:01:21.550
It is 20 The next task is to partition the array

31
00:01:21.940 --> 00:01:26.060
that is we will rearrange all the array elements in 

32
00:01:26.060 --> 00:01:29.070
such a way that all values lesser than the Pivot 

33
00:01:29.070 --> 00:01:32.450
should come before the pivot and all values 

34
00:01:32.450 --> 00:01:35.150
greater than the pivot should come after it 

35
00:01:35.720 --> 00:01:38.150
Those elements can be in any order 

36
00:01:38.540 --> 00:01:41.870
At the end of the partition function the pivot element 

37
00:01:41.870 --> 00:01:43.310
will be placed at it 

38
00:01:43.310 --> 00:01:44.450
Sorted position 

39
00:01:45.240 --> 00:01:47.350
Let us apply the partition logic 

40
00:01:47.850 --> 00:01:49.070
It is very simple 

41
00:01:49.080 --> 00:01:53.400
Let us take two variables the partition variable p index 

42
00:01:53.460 --> 00:01:57.990
and iterating variable i initialised both of them to the 

43
00:01:57.990 --> 00:02:01.950
starting of array here starting index zero 

44
00:02:01.960 --> 00:02:06.490
So initialised P Index and I to 0 now check 

45
00:02:06.590 --> 00:02:09.080
If a r r of I is less than the 

46
00:02:09.080 --> 00:02:13.460
pivot that is if 10 is less than 20 and 

47
00:02:13.470 --> 00:02:16.470
if it is true we have to swap elements that 

48
00:02:16.480 --> 00:02:20.580
I and P index both I and p index points 

49
00:02:20.580 --> 00:02:24.260
the same element so 10 will be swapped to its 

50
00:02:24.270 --> 00:02:25.320
actual place 

51
00:02:25.840 --> 00:02:28.410
It will not make any changes in the array 

52
00:02:29.140 --> 00:02:32.510
After this swap we need to increments value of P 

53
00:02:32.520 --> 00:02:33.160
index 

54
00:02:33.450 --> 00:02:37.430
So move of P index to next position now do the 

55
00:02:37.430 --> 00:02:39.680
same process with the next element 

56
00:02:39.880 --> 00:02:44.860
So increment I now compare 25 less than 20 

57
00:02:45.220 --> 00:02:46.650
The condition is false 

58
00:02:46.820 --> 00:02:48.550
So no need of swap 

59
00:02:49.090 --> 00:02:51.720
If there is no swap we should not increment

60
00:02:51.720 --> 00:02:53.320
the value of P index 

61
00:02:53.470 --> 00:02:55.980
So there is no change in P index 

62
00:02:56.740 --> 00:02:59.950
Just continue the same process with the next element 

63
00:03:00.340 --> 00:03:04.150
So again increment i now compare three 

64
00:03:04.640 --> 00:03:07.640
And pivot element which is 20 and three is 

65
00:03:07.640 --> 00:03:08.820
less than 20 

66
00:03:08.900 --> 00:03:10.460
So the condition is true 

67
00:03:10.470 --> 00:03:14.350
So swap arr of I and arr of P index 

68
00:03:14.940 --> 00:03:16.960
and then increment p index 

69
00:03:17.230 --> 00:03:21.380
And please note that whenever the condition is satisfied we 

70
00:03:21.380 --> 00:03:25.230
are performing the swap operation and we are implementing P 

71
00:03:25.230 --> 00:03:25.850
index 

72
00:03:26.240 --> 00:03:29.420
If the condition is false we are just implementing 

73
00:03:29.430 --> 00:03:33.400
I now do the same process with the next element 

74
00:03:33.600 --> 00:03:37.570
So increment I so now compare 50 and 20 and 

75
00:03:37.570 --> 00:03:40.470
the condition fails and the array is completed 

76
00:03:40.470 --> 00:03:44.450
Now now the P index points to the array index two 

77
00:03:44.940 --> 00:03:47.630
this is nothing but the position of the pivot 

78
00:03:47.640 --> 00:03:48.650
element 20 

79
00:03:49.040 --> 00:03:53.140
So finally we should swap arr of end an arr 

80
00:03:53.140 --> 00:03:59.800
of P index swap 25 20 here the element 20 

81
00:03:59.810 --> 00:04:01.570
inserted in It's sorted position 

82
00:04:01.570 --> 00:04:05.380
Now we can assure that all the elements before P 

83
00:04:05.380 --> 00:04:09.150
index is lesser than 20 and elements after P index 

84
00:04:09.160 --> 00:04:13.230
is greater than 20 which means the Element 20 is 

85
00:04:13.230 --> 00:04:14.050
sorted now 

86
00:04:15.040 --> 00:04:16.710
Now we need to recursively 

87
00:04:16.710 --> 00:04:20.100
sort all the elements before P index and 

88
00:04:20.110 --> 00:04:23.810
after p index so there will be two recursive calls 

89
00:04:23.860 --> 00:04:27.510
One is quick sort of arr comma start comma p 

90
00:04:27.510 --> 00:04:31.160
index minus one that is from the starting index to 

91
00:04:31.170 --> 00:04:34.790
p index minus one that is the elements before P 

92
00:04:34.790 --> 00:04:35.320
index 

93
00:04:35.840 --> 00:04:38.910
We will not include the P Index here because it 

94
00:04:38.910 --> 00:04:40.150
is already sorted 

95
00:04:40.840 --> 00:04:44.420
And next is quick sort of arr comma P index 

96
00:04:44.420 --> 00:04:48.340
plus one comma end that is from P index plus 

97
00:04:48.340 --> 00:04:49.400
one to end 

98
00:04:49.710 --> 00:04:53.930
That is the elements after P index here in this 

99
00:04:53.940 --> 00:04:57.430
array start is equal to zero end is equal to 

100
00:04:57.430 --> 00:04:59.950
four and p index is equal to two 

101
00:05:00.640 --> 00:05:04.330
Now after the partition logic the first recursive call 

102
00:05:04.340 --> 00:05:05.450
will be executed 

103
00:05:06.040 --> 00:05:09.270
Here start is equal to zero and end is equal 

104
00:05:09.270 --> 00:05:13.160
to P index minus one and p index value is 

105
00:05:13.170 --> 00:05:16.530
equal to 2 so two minus one equal to one 

106
00:05:16.830 --> 00:05:20.370
So end is equal to one and the next recursive 

107
00:05:20.370 --> 00:05:22.400
call will wait until the task 

108
00:05:22.400 --> 00:05:24.560
Of first recursive call is finished 

109
00:05:24.560 --> 00:05:28.780
So sub array from index 0 to 1 that is elements 10 

110
00:05:28.910 --> 00:05:32.320
and three will be taken in this sub array 

111
00:05:32.380 --> 00:05:36.720
The partition function will be executed first the same process 

112
00:05:36.720 --> 00:05:37.960
will be applied here 

113
00:05:37.960 --> 00:05:42.190
Also partition index P index and Iterating variable 

114
00:05:42.200 --> 00:05:47.290
I will point the starting index here starting index zero 

115
00:05:47.400 --> 00:05:50.450
So both P index and I will point the index 

116
00:05:50.450 --> 00:05:50.920
zero 

117
00:05:50.930 --> 00:05:54.550
The last element 3 will be taken as the pivot element 

118
00:05:55.040 --> 00:05:59.250
Now compare arr of I less than pivot element 

119
00:05:59.690 --> 00:06:01.020
that is compare 

120
00:06:01.030 --> 00:06:04.420
10 is less than three and it is not so 

121
00:06:04.430 --> 00:06:06.140
there will be no swap needed 

122
00:06:06.390 --> 00:06:09.950
Hence the index will point the same index 

123
00:06:10.340 --> 00:06:12.100
Now the array is completed 

124
00:06:12.230 --> 00:06:15.940
Finally we need to swap arr of P index and 

125
00:06:15.950 --> 00:06:17.230
arr of end 

126
00:06:17.570 --> 00:06:21.460
So swap 10 and three and since we're doing the 

127
00:06:21.460 --> 00:06:24.770
process in the original array it will be reflected in 

128
00:06:24.770 --> 00:06:25.650
the above array 

129
00:06:26.240 --> 00:06:30.730
Now arr of P index is sorted so arr 

130
00:06:30.730 --> 00:06:33.050
of 0 3 is sorted 

131
00:06:33.050 --> 00:06:36.750
Now here the P index value is equal to zero 

132
00:06:37.340 --> 00:06:41.550
So this function has two recursive calls now like before 

133
00:06:42.040 --> 00:06:44.650
That is from the starting index to p index minus 

134
00:06:44.650 --> 00:06:47.850
one and next is from p index plus one to 

135
00:06:47.860 --> 00:06:48.250
end 

136
00:06:49.240 --> 00:06:51.040
Like above the first recursive 

137
00:06:51.040 --> 00:06:54.300
call will be executed first and the second call 

138
00:06:54.310 --> 00:06:56.110
will wait until the task 

139
00:06:56.110 --> 00:06:58.970
Of first one is finished here 

140
00:06:58.980 --> 00:07:01.090
Starting index is equal to zero 

141
00:07:01.370 --> 00:07:05.170
End equal to p index minus one which is zero 

142
00:07:05.170 --> 00:07:07.250
minus one that is minus one 

143
00:07:07.740 --> 00:07:13.220
But this is an invalid index zero to minus one so 

144
00:07:13.220 --> 00:07:15.270
we can perform the quick sort task 

145
00:07:15.270 --> 00:07:15.650
Here 

146
00:07:16.040 --> 00:07:20.810
when the sub array has invalid index or only one element 

147
00:07:21.010 --> 00:07:22.640
We should stop the process 

148
00:07:22.900 --> 00:07:26.190
So we should add the condition if start is less 

149
00:07:26.190 --> 00:07:28.550
than and before doing the process 

150
00:07:29.040 --> 00:07:32.420
And this condition will stop the execution when this sub 

151
00:07:32.430 --> 00:07:36.250
array has an invalid index or only one element 

152
00:07:36.940 --> 00:07:39.850
So this recursive call will not be executed here 

153
00:07:40.340 --> 00:07:44.150
Now the first recursive call has finished its task 

154
00:07:44.740 --> 00:07:47.500
So now the second recursive call will be executed 

155
00:07:47.840 --> 00:07:51.670
Here start is equal to P index plus one which 

156
00:07:51.670 --> 00:07:55.270
is zero plus one equal to one and end is 

157
00:07:55.270 --> 00:07:55.980
equal to one 

158
00:07:55.990 --> 00:07:58.800
So in this sub array start and end 

159
00:07:58.880 --> 00:08:00.280
Both are equal to one 

160
00:08:00.290 --> 00:08:03.410
So there is only one element so we can stop 

161
00:08:03.410 --> 00:08:07.660
the process Now Here If start less than end condition 

162
00:08:07.660 --> 00:08:08.590
will be false 

163
00:08:08.740 --> 00:08:11.940
since start is equal to end so it will not 

164
00:08:11.940 --> 00:08:16.330
be executed Now this quick sort function has finished its 

165
00:08:16.330 --> 00:08:16.850
task 

166
00:08:17.120 --> 00:08:20.970
so Control will reach the main quick sort function here 

167
00:08:21.090 --> 00:08:24.350
The first recursive call has finished its task 

168
00:08:25.040 --> 00:08:28.450
So now the second recursive call starts its execution 

169
00:08:28.940 --> 00:08:32.260
So quick sort of arr comma p Index plus one 

170
00:08:32.270 --> 00:08:36.270
comma end will be executed now and here start is 

171
00:08:36.280 --> 00:08:39.930
equal to p index plus one and P index equal 

172
00:08:39.930 --> 00:08:43.650
two so start equal to two plus one That three 

173
00:08:44.140 --> 00:08:47.340
and end is equal to four and the last element 

174
00:08:47.340 --> 00:08:51.150
25 at index four will be taken as the pivot 

175
00:08:51.150 --> 00:08:51.750
element 

176
00:08:52.240 --> 00:08:55.750
Now compare arr of I less than pivot element 

177
00:08:56.140 --> 00:09:00.470
that is compare 50 is less than 25 but it 

178
00:09:00.470 --> 00:09:03.380
is not so there will be no swap needed 

179
00:09:03.940 --> 00:09:06.950
Hence P index will point the same index three 

180
00:09:07.440 --> 00:09:09.050
Now the array is completed 

181
00:09:09.440 --> 00:09:12.930
Finally we need to swap arr of p index and 

182
00:09:12.940 --> 00:09:16.850
arr of end So swap 50 and 25 

183
00:09:17.440 --> 00:09:20.580
Since we're doing the process in the original array it will 

184
00:09:20.580 --> 00:09:21.840
be reflected here 

185
00:09:21.840 --> 00:09:22.320
Also 

186
00:09:22.330 --> 00:09:25.960
Now arr of the index is sorted so arr

187
00:09:25.960 --> 00:09:28.190
of 3 25 is sorted 

188
00:09:28.190 --> 00:09:31.450
Now here p index value equal to three 

189
00:09:31.940 --> 00:09:35.640
Now this function has two recursive calls like we had 

190
00:09:35.640 --> 00:09:36.850
in previous cases 

191
00:09:37.440 --> 00:09:40.710
That is from starting index to P index minus one 

192
00:09:41.020 --> 00:09:43.420
and next is from P index +1 to end 

193
00:09:44.440 --> 00:09:47.630
Like above the first recursive call will be executed 

194
00:09:47.630 --> 00:09:50.890
first and the second call will wait until the task 

195
00:09:50.890 --> 00:09:52.550
of first one is finished 

196
00:09:52.940 --> 00:09:56.290
So here starting index equal to three end equal to 

197
00:09:56.290 --> 00:09:57.680
P index minus one 

198
00:09:57.880 --> 00:10:01.030
That is three minus one which is two So when 

199
00:10:01.030 --> 00:10:02.200
we checked the condition 

200
00:10:02.240 --> 00:10:05.640
If start is less than end it will fail since 

201
00:10:05.640 --> 00:10:08.850
three is not less than two so it will stop 

202
00:10:08.850 --> 00:10:09.730
the execution 

203
00:10:10.070 --> 00:10:13.650
So the first recursive call has finished its task 

204
00:10:14.340 --> 00:10:16.640
So now the second recursive call will be 

205
00:10:16.640 --> 00:10:18.510
executed here 

206
00:10:18.570 --> 00:10:22.330
start is equal to p index plus one that is three 

207
00:10:22.330 --> 00:10:25.430
plus one which is equal to four and end is 

208
00:10:25.430 --> 00:10:26.350
equal to four 

209
00:10:26.840 --> 00:10:30.050
So in this sub array start and end is equal 

210
00:10:30.050 --> 00:10:30.570
to four 

211
00:10:30.920 --> 00:10:32.710
So there is only one element 

212
00:10:32.840 --> 00:10:37.420
So if start less than end condition will fail so 

213
00:10:37.420 --> 00:10:41.590
this recursive call also will not be executed now 

214
00:10:41.700 --> 00:10:46.080
This quick sort function has also finished its task so 

215
00:10:46.080 --> 00:10:48.650
control will reach the main quick sort function 

216
00:10:49.240 --> 00:10:52.250
And here it is also completed its execution 

217
00:10:52.840 --> 00:10:56.200
And finally the array is sorted out Now using the 

218
00:10:56.210 --> 00:11:00.550
quick sort algorithm the sorted array elements are 3 

219
00:11:00.870 --> 00:11:04.050
10 20 25 50 

220
00:11:05.040 --> 00:11:05.590
Now 

221
00:11:05.600 --> 00:11:08.250
Let us quickly summarise the quick sort concept 

222
00:11:08.840 --> 00:11:11.050
Partition logic will be executed first 

223
00:11:11.540 --> 00:11:15.540
After the process the partition function will return the Partition 

224
00:11:15.540 --> 00:11:16.850
Index P index 

225
00:11:17.440 --> 00:11:21.050
After that the whole array will be recursively sorted 

226
00:11:21.250 --> 00:11:24.900
using the two recursive calls That is one recursive 

227
00:11:24.900 --> 00:11:27.940
call from START index to P index minus one 

228
00:11:28.250 --> 00:11:31.530
That is the elements before P index and another Recursive 

229
00:11:31.530 --> 00:11:35.270
call from P index plus one to end that 

230
00:11:35.270 --> 00:11:36.220
is elements 

231
00:11:36.230 --> 00:11:40.000
After p index this recursive calls will be stopped 

232
00:11:40.140 --> 00:11:43.830
when the sub array has an invalid index or only 

233
00:11:43.840 --> 00:11:44.850
one element 

234
00:11:45.340 --> 00:11:47.150
So this is the process of quick sort

235
00:11:47.640 --> 00:11:50.600
In the next video we will learn how to implement the partition function from this logic.

