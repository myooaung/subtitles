WEBVTT

1
00:00:00.340 --> 00:00:01.160
Hello friends 

2
00:00:01.220 --> 00:00:04.320
In this video let us discuss about the need for 

3
00:00:04.320 --> 00:00:05.750
binary search tree 

4
00:00:07.440 --> 00:00:10.280
So we have learned about array data structures 

5
00:00:10.620 --> 00:00:14.490
It was simple but was it efficient Say this array 

6
00:00:14.490 --> 00:00:14.960
here 

7
00:00:15.210 --> 00:00:18.300
If you want to search for the Element 80 we 

8
00:00:18.300 --> 00:00:21.420
have to start from the first node and then visit 

9
00:00:21.430 --> 00:00:25.210
every element and compare the key to find it so 

10
00:00:25.220 --> 00:00:27.050
it will take order of n time 

11
00:00:27.440 --> 00:00:31.360
Same for insertion and deletion if we need to delete 

12
00:00:31.360 --> 00:00:34.680
80 we need to traverse the whole array to find 

13
00:00:34.690 --> 00:00:38.710
80 first and then deleted so it will take order of 

14
00:00:38.720 --> 00:00:39.360
n time 

15
00:00:40.040 --> 00:00:42.120
Also array is static 

16
00:00:42.210 --> 00:00:45.380
It cannot grow or shrink on demand so that is 

17
00:00:45.380 --> 00:00:49.640
also a problem so it is not very efficient for 

18
00:00:49.640 --> 00:00:50.790
the size issue 

19
00:00:50.840 --> 00:00:52.990
It can be sold using a linked list 

20
00:00:53.080 --> 00:00:55.480
It can grow or shrink on demand 

21
00:00:55.710 --> 00:00:58.690
If we need to access the Element 50 we have 

22
00:00:58.700 --> 00:01:01.090
to traverse the whole linked list so

23
00:01:01.090 --> 00:01:04.790
Still the cost of operation is the same order of 

24
00:01:04.800 --> 00:01:09.290
n so these issues can be addressed by binary search 

25
00:01:09.290 --> 00:01:11.210
trees in be BSTs 

26
00:01:11.470 --> 00:01:14.320
The value of left child will be less than the 

27
00:01:14.320 --> 00:01:17.480
value of parent and the value of parent will be 

28
00:01:17.480 --> 00:01:20.530
less than the value of right child so we can 

29
00:01:20.540 --> 00:01:23.740
easily find the minimum element in BST 

30
00:01:23.750 --> 00:01:27.240
It will be the left most node and similarly the 

31
00:01:27.240 --> 00:01:30.970
maximum element will be the right most node in this 

32
00:01:30.970 --> 00:01:31.350
way 

33
00:01:31.500 --> 00:01:34.630
For every sub tree we can easily find the minimum 

34
00:01:34.630 --> 00:01:35.990
and maximum elements 

35
00:01:36.080 --> 00:01:40.860
Also duplicate elements are not normally allowed in binary search 

36
00:01:40.860 --> 00:01:41.510
trees 

37
00:01:41.750 --> 00:01:44.960
Now let us construct binary search tree with these 

38
00:01:44.970 --> 00:01:45.650
elements 

39
00:01:46.040 --> 00:01:48.820
So first insert 100 it becomes the root  

40
00:01:49.060 --> 00:01:52.500
Now as features discussed all the values which are greater 

41
00:01:52.500 --> 00:01:55.270
than root  will be in its right sub tree and 

42
00:01:55.280 --> 00:01:57.810
all the values which are smaller than root  will be 

43
00:01:57.810 --> 00:01:59.050
in the left sub tree 

44
00:01:59.640 --> 00:02:03.980
now let us insert 50 50 is less than hundreds so 

45
00:02:03.990 --> 00:02:06.140
it will become hundreds left child 

46
00:02:06.600 --> 00:02:10.710
Next we have 200 since 200 is greater than hundreds 

47
00:02:10.940 --> 00:02:13.050
it will become hundreds right child 

48
00:02:13.940 --> 00:02:17.650
Next we have 10 ten is less than hundreds so it 

49
00:02:17.650 --> 00:02:20.480
should be placed in left sub tree and we have 

50
00:02:20.480 --> 00:02:24.380
50 here and 10 is less than 50 also so 

51
00:02:24.390 --> 00:02:27.740
again ten will be placed as fifties left child 

52
00:02:27.910 --> 00:02:32.080
Next we have 60 60 less than 100 so it 

53
00:02:32.080 --> 00:02:33.750
should be in the left sub tree 

54
00:02:34.040 --> 00:02:37.390
And there we have 50 and 60 is greater than 

55
00:02:37.390 --> 00:02:40.450
50 so 60 becomes the right child of 50 

56
00:02:40.940 --> 00:02:44.920
Next we have 150 150 is greater than 100 

57
00:02:45.250 --> 00:02:47.750
So it should be placed in the right sub tree 

58
00:02:48.240 --> 00:02:52.480
And in here we have 200 150 is less than 

59
00:02:52.480 --> 00:02:53.160
200 

60
00:02:53.350 --> 00:02:56.440
So 150 becomes the left child of 200 

61
00:02:56.710 --> 00:03:01.890
Next we have 300 since 300 is greater than 100 and 200 

62
00:03:01.890 --> 00:03:05.410
300 will be placed as the right child of 

63
00:03:05.420 --> 00:03:06.150
200 

64
00:03:06.880 --> 00:03:11.460
Next we have 500 500 is greater than 100 greater 

65
00:03:11.460 --> 00:03:15.350
than 200 greater and 300 so it becomes the right 

66
00:03:15.360 --> 00:03:16.650
child of 300 

67
00:03:17.140 --> 00:03:20.010
So that is how we can insert nodes to binary 

68
00:03:20.010 --> 00:03:22.830
search tree and see the minimum value 

69
00:03:22.830 --> 00:03:25.720
10 is the left most node and the maximum value 

70
00:03:25.720 --> 00:03:27.850
500 is the right Most node 

71
00:03:28.340 --> 00:03:31.430
Now let us discuss about searching and deleting and node 

72
00:03:31.430 --> 00:03:32.250
from BST 

73
00:03:32.640 --> 00:03:37.600
For example let's find the elements 60 so first compares 

74
00:03:37.600 --> 00:03:41.930
60 with roots data and 60 is less than hundreds 

75
00:03:42.070 --> 00:03:46.210
So we can understand that since sixties less than 100 

76
00:03:46.220 --> 00:03:49.050
it can only be present in the left sub tree 

77
00:03:49.640 --> 00:03:51.650
so we can ignore the right sub tree 

78
00:03:52.040 --> 00:03:56.110
Now compare the key 60 with left child's data and 

79
00:03:56.110 --> 00:03:59.670
we got key greater than data here that is sixties 

80
00:03:59.670 --> 00:04:00.850
greater than 50 

81
00:04:01.440 --> 00:04:04.300
So 60 can only be present in fifties 

82
00:04:04.300 --> 00:04:07.590
right sub tree so we can ignore it's left sub 

83
00:04:07.590 --> 00:04:08.910
tree and we goto 60 

84
00:04:08.910 --> 00:04:09.420
Here 

85
00:04:09.480 --> 00:04:13.850
now let us find 150 150 is greater than hundreds 

86
00:04:14.010 --> 00:04:16.810
so we can ignore the left sub tree and compare 

87
00:04:16.810 --> 00:04:18.750
150 with the right child 

88
00:04:18.820 --> 00:04:23.260
200 and one fifty's less than 200 so it can 

89
00:04:23.270 --> 00:04:25.380
only be present in the left sub tree 

90
00:04:25.390 --> 00:04:29.250
So ignore the right sub tree and compare 150 

91
00:04:29.250 --> 00:04:32.060
with left childs data and regard it equal 

92
00:04:32.200 --> 00:04:33.750
So the key is found 

93
00:04:33.950 --> 00:04:34.930
so like This 

94
00:04:34.940 --> 00:04:38.650
If we have n nodes the total searchable size will be 

95
00:04:38.650 --> 00:04:42.450
reduced n by two then n by four then n

96
00:04:42.450 --> 00:04:45.160
by eight and at the end it will boil down 

97
00:04:45.160 --> 00:04:48.620
to a single element that is n by to raise to

98
00:04:48.620 --> 00:04:51.590
0 n by to raise to 1 n by to raise 

99
00:04:51.590 --> 00:04:54.150
to 2 n by 2 raise to 3 up to one 

100
00:04:54.640 --> 00:04:57.870
that is in general n by to raise to k 

101
00:04:57.880 --> 00:05:02.810
k equal to 0123 etc equal to one so 

102
00:05:02.820 --> 00:05:03.890
n equal to 

103
00:05:03.900 --> 00:05:07.560
2 raise to k now let us take log on both 

104
00:05:07.560 --> 00:05:10.900
sides and we will get log 2 raise to K to 

105
00:05:10.900 --> 00:05:14.710
base two equal to log n two base two that 

106
00:05:14.710 --> 00:05:19.380
is K into log two base two that this one 

107
00:05:20.040 --> 00:05:23.000
So we got k equal to log2base2 

108
00:05:23.000 --> 00:05:23.650
 

109
00:05:24.140 --> 00:05:26.600
So if we need to search an element in a 

110
00:05:26.600 --> 00:05:30.940
BST So the time complexity is log n and here 

111
00:05:30.940 --> 00:05:34.250
we had eight elements so n equal to eight which 

112
00:05:34.250 --> 00:05:36.300
is equal to 2 raise to 3 

113
00:05:36.310 --> 00:05:40.000
So K equal to log two raise to 3 to base 

114
00:05:40.000 --> 00:05:43.530
two that is three into log2base2 which 

115
00:05:43.530 --> 00:05:45.750
is three into one equal to three 

116
00:05:46.540 --> 00:05:50.730
Now consider array we have eight elements so in worst case 

117
00:05:50.740 --> 00:05:54.740
eight iterations are needed and same thing happens for linked 

118
00:05:54.740 --> 00:05:55.030
list 

119
00:05:55.030 --> 00:05:59.210
Also eight iterations are needed for eight nodes but in 

120
00:05:59.210 --> 00:06:04.210
BST in same case it requires three iterations only and 

121
00:06:04.210 --> 00:06:07.280
this is why binary search tree is widely used for 

122
00:06:07.280 --> 00:06:09.350
searching and retrieval purposes. 

