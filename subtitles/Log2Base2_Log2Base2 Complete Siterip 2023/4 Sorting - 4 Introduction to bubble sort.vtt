WEBVTT

1
00:00:00.840 --> 00:00:01.700
Hello everyone 

2
00:00:01.960 --> 00:00:04.710
In this video let us have an introduction to bubble 

3
00:00:04.710 --> 00:00:05.150
sort 

4
00:00:07.540 --> 00:00:11.260
So bubble sort is a very simple sorting algorithm and 

5
00:00:11.260 --> 00:00:13.830
it is similar to the movement of an air bubble 

6
00:00:13.840 --> 00:00:15.750
that raises up in the water 

7
00:00:16.020 --> 00:00:18.690
That is the larger bubble will rise first and the 

8
00:00:18.690 --> 00:00:20.450
smaller once will follow it 

9
00:00:20.940 --> 00:00:26.170
Likewise in bubble sort each iteration the largest or smaller 

10
00:00:26.170 --> 00:00:28.850
element will get to its actual place 

11
00:00:29.440 --> 00:00:33.180
Here we have five bubbles each of different size 

12
00:00:33.740 --> 00:00:37.350
As we said the largest bubble will rise first 

13
00:00:37.840 --> 00:00:41.800
And what bubble suit actually does is it will continuously 

14
00:00:41.800 --> 00:00:43.550
compare adjacent bubbles
15
00:00:43.940 --> 00:00:47.330
And if the first bubble is larger than second it 

16
00:00:47.330 --> 00:00:48.220
is swapped 

17
00:00:48.580 --> 00:00:51.870
So here we have first bubble larger than the second 

18
00:00:51.870 --> 00:00:52.360
bubble 

19
00:00:52.680 --> 00:00:54.920
So both are swapped now 

20
00:00:54.920 --> 00:00:58.580
The second bubble is larger than the third bubble again 

21
00:00:58.590 --> 00:01:00.840
we need to swap now 

22
00:01:00.850 --> 00:01:03.690
The third bubble is larger than the fourth bubble 

23
00:01:03.700 --> 00:01:07.690
So again swap that and see the fourth bubble is now 

24
00:01:07.700 --> 00:01:09.150
larger than the fifth one 

25
00:01:09.500 --> 00:01:14.100
So again swap these bubbles and now the largest bubble 

26
00:01:14.100 --> 00:01:17.940
has reached the last position and it will rise now 

27
00:01:18.740 --> 00:01:20.570
Now repeat the same process 

28
00:01:20.610 --> 00:01:24.450
Compare 1st and 2nd bubbles which one is larger Here 

29
00:01:24.700 --> 00:01:25.900
it is the second one 

30
00:01:26.130 --> 00:01:29.450
So there is no issue so we can compare 2nd 

31
00:01:29.460 --> 00:01:30.650
and 3rd bubbles 

32
00:01:31.040 --> 00:01:35.320
The second one is larger here so swap them now 

33
00:01:35.320 --> 00:01:38.410
compared third and fourth bubbles which is larger 

34
00:01:38.690 --> 00:01:41.700
It is the fourth bubble so no need to swap 

35
00:01:41.870 --> 00:01:44.550
And now we have the largest bubble at the last 

36
00:01:44.550 --> 00:01:49.270
position and it will rise now again Repeat the process 

37
00:01:49.740 --> 00:01:52.980
So here we have first bubble larger than the second 

38
00:01:52.980 --> 00:01:53.450
bubble 

39
00:01:53.840 --> 00:01:57.590
So both are swapped so we can compare the 2nd 

40
00:01:57.600 --> 00:01:59.920
and 3rd bubbles and which is larger 

41
00:01:59.920 --> 00:02:01.620
Here it is the third one 

42
00:02:01.880 --> 00:02:04.140
So again there is no need to swap 

43
00:02:04.150 --> 00:02:08.290
And now the largest bubble will rise again 

44
00:02:08.290 --> 00:02:12.060
Compare 1st and 2nd bubbles which is larger here it 

45
00:02:12.060 --> 00:02:13.020
is the second one 

46
00:02:13.080 --> 00:02:16.350
So there is no issue and it will rise now 

47
00:02:16.740 --> 00:02:19.850
and now there is only one bubble left and it 

48
00:02:19.850 --> 00:02:20.620
will raise now 

49
00:02:21.240 --> 00:02:23.190
So this is what bubble sort is

50
00:02:23.290 --> 00:02:27.310
In each cycle of comparison the largest bubble gets into 

51
00:02:27.310 --> 00:02:29.410
last position and it will rise 

52
00:02:30.540 --> 00:02:32.720
So now let us see how it works 

53
00:02:32.720 --> 00:02:35.750
With an array we have an array of size five 

54
00:02:35.760 --> 00:02:39.610
with elements 50 25 5 

55
00:02:39.820 --> 00:02:40.540
20 

56
00:02:40.550 --> 00:02:43.600
and ten First take the first pair 

57
00:02:43.700 --> 00:02:45.850
That is index zero and one 

58
00:02:46.440 --> 00:02:50.070
The elements are 50 and 25 is in the right 

59
00:02:50.070 --> 00:02:50.620
order 

60
00:02:50.630 --> 00:02:51.160
No 

61
00:02:51.170 --> 00:02:53.300
25 is less than 50 

62
00:02:53.370 --> 00:02:57.230
So 25 should come 1st and 50 should come after 

63
00:02:57.230 --> 00:02:57.550
it 

64
00:02:57.940 --> 00:03:01.150
so swap and the next pair is 50 and 

65
00:03:01.150 --> 00:03:03.840
five again It is in the wrong order so

66
00:03:03.930 --> 00:03:04.750
Swap 

67
00:03:05.140 --> 00:03:06.170
Take then next pair 

68
00:03:06.170 --> 00:03:09.400
Now we have 15 and 20 again 

69
00:03:09.410 --> 00:03:10.680
It is in the wrong order 

70
00:03:10.690 --> 00:03:15.100
So Swap Next is 50 and 10 against it is wrong 

71
00:03:15.100 --> 00:03:16.260
order So swap 

72
00:03:16.270 --> 00:03:19.380
And we got 50 the largest element at the last 

73
00:03:19.380 --> 00:03:20.050
position 

74
00:03:20.640 --> 00:03:24.550
Now the next cycle begins compared the first two elements 

75
00:03:24.560 --> 00:03:28.840
25 5 and five is less than 25 

76
00:03:28.850 --> 00:03:30.890
So it is not the right position 

77
00:03:31.130 --> 00:03:36.570
So swap Next we have 25 20 and 20 is 

78
00:03:36.570 --> 00:03:39.250
less than 25 again swap

79
00:03:39.740 --> 00:03:44.030
Next we have 25 10 and 10 is less than 

80
00:03:44.030 --> 00:03:44.770
25 

81
00:03:44.780 --> 00:03:49.300
So again perform swap now The largest element in these four 

82
00:03:49.310 --> 00:03:51.500
elements came to the fourth position 

83
00:03:51.610 --> 00:03:54.080
So this is what happens in each step 

84
00:03:54.310 --> 00:03:57.950
The nth largest element will come to end position 

85
00:03:58.640 --> 00:04:02.640
Hence one element is being sorted that is brought to 

86
00:04:02.640 --> 00:04:07.170
correct position in each step in next step compare five 

87
00:04:07.180 --> 00:04:10.440
and 20 and five is less than 20 and there 

88
00:04:10.440 --> 00:04:12.310
is no issue with this placing 

89
00:04:12.310 --> 00:04:14.580
So do not swap and compare 

90
00:04:14.580 --> 00:04:17.860
The next pair which is 20 and 10 and 20 

91
00:04:17.860 --> 00:04:18.980
is greater than 10 

92
00:04:18.990 --> 00:04:20.340
So it is not right 

93
00:04:20.350 --> 00:04:20.970
So swap 

94
00:04:21.260 --> 00:04:24.080
So now the third largest element came to the third 

95
00:04:24.080 --> 00:04:27.760
position in next step compare five and 10 

96
00:04:27.880 --> 00:04:30.550
It is okay so do not swap and it is 

97
00:04:30.550 --> 00:04:35.240
done for its size five we needed four iterations that 

98
00:04:35.240 --> 00:04:37.110
is in fifth step 

99
00:04:37.290 --> 00:04:40.530
We will be left with one element only which will 

100
00:04:40.530 --> 00:04:42.870
be the smallest element and it will be in the 

101
00:04:42.880 --> 00:04:43.850
right position 

102
00:04:44.340 --> 00:04:47.680
So if the size of array is n we need n 

103
00:04:47.680 --> 00:04:49.350
minus one steps only 

104
00:04:49.840 --> 00:04:53.410
So to implement this we can use two Loops the 

105
00:04:53.410 --> 00:04:57.590
outer loop execute for size minus one times and the 

106
00:04:57.600 --> 00:05:01.240
inner loop will compare the adjacent elements and swap if 

107
00:05:01.240 --> 00:05:06.270
needed for index 0 0 and one will be compared for 

108
00:05:06.280 --> 00:05:10.980
index 1 1 and two will be compared for index two 

109
00:05:10.990 --> 00:05:14.520
two and three will be compared and for Index Three 

110
00:05:14.530 --> 00:05:17.620
three and four will be compared but in index four 

111
00:05:17.630 --> 00:05:20.860
we don't have an element at Index five so we 

112
00:05:20.860 --> 00:05:24.070
should run the loop until size minus one instead of 

113
00:05:24.070 --> 00:05:25.750
framing the loop till size 

114
00:05:26.290 --> 00:05:29.480
If we run the loop till J less than size it 

115
00:05:29.480 --> 00:05:33.530
will produce an unexpected result as Index five might have 

116
00:05:33.530 --> 00:05:34.750
some garbage value 

117
00:05:35.540 --> 00:05:38.680
We can also optimise the running time by analysing the 

118
00:05:38.680 --> 00:05:39.430
procedure 

119
00:05:39.930 --> 00:05:43.630
In the first iteration one element is sorted so we 

120
00:05:43.630 --> 00:05:46.070
can excluded in the next iteration 

121
00:05:46.470 --> 00:05:50.220
In the second iteration two elements are sorted so we 

122
00:05:50.220 --> 00:05:53.650
can exclude those two elements in the next iteration 

123
00:05:53.990 --> 00:05:58.060
And similarly in the third iteration three elements are sorter 

124
00:05:58.410 --> 00:06:02.830
So exclude those three elements in the next iteration so 

125
00:06:02.840 --> 00:06:07.250
each iteration an element is sorted so we can excluded in 

126
00:06:07.250 --> 00:06:11.540
the next iteration by placing size minus one minus I 

127
00:06:12.140 --> 00:06:16.210
It will optimise the running time even further and inside 

128
00:06:16.210 --> 00:06:19.190
this loop we need to compare the elements and if 

129
00:06:19.240 --> 00:06:21.490
it is not in the right order we have to 

130
00:06:21.490 --> 00:06:21.990
swap 

131
00:06:22.000 --> 00:06:25.570
So in this video we learnt what is bubble sort 

132
00:06:25.570 --> 00:06:26.710
and how it works 

133
00:06:27.060 --> 00:06:30.070
In the next video we will learn how the implementation works in detail.

