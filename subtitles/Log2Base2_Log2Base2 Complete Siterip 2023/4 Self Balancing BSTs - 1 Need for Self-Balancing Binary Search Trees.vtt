WEBVTT

1
00:00:00.040 --> 00:00:03.810
Why do we need self balancing binary search trees We 

2
00:00:03.810 --> 00:00:07.330
have learn that in the worst case searching a value 

3
00:00:07.330 --> 00:00:11.080
in the linked list is order of n because they 

4
00:00:11.080 --> 00:00:14.800
don't follow any ordering rules for an alternative 

5
00:00:14.810 --> 00:00:18.180
We have used the binary search trees since the binary 

6
00:00:18.180 --> 00:00:21.450
search tree follows left right ordering rules 

7
00:00:21.460 --> 00:00:24.700
We can search an element in order of Log n time 

8
00:00:24.700 --> 00:00:25.550
complexity 

9
00:00:26.140 --> 00:00:29.200
But what will be the time complexity if we insert 

10
00:00:29.210 --> 00:00:33.800
sorted numbers in a binary search tree like 10 20 30 

11
00:00:33.800 --> 00:00:35.350
40 50 60 

12
00:00:36.340 --> 00:00:39.830
In this case the binary search tree will look something 

13
00:00:39.830 --> 00:00:40.480
like this 

14
00:00:41.040 --> 00:00:44.620
Here All the nodes are inserted only on the right 

15
00:00:44.620 --> 00:00:48.600
side of the Binary search tree and in structure looks 

16
00:00:48.610 --> 00:00:50.350
as same as the linked list 

17
00:00:50.940 --> 00:00:54.050
So if we want to search the elements 60 it 

18
00:00:54.050 --> 00:00:57.150
will take order of n time and not log n 

19
00:00:57.150 --> 00:00:57.550
time 

20
00:00:58.140 --> 00:01:01.700
So even if we use the binary search tree 

21
00:01:01.850 --> 00:01:04.730
in the worst case the time complexity to search 

22
00:01:04.730 --> 00:01:07.390
an element is order of n so 

23
00:01:07.390 --> 00:01:10.280
What is the solution to this problem We need to 

24
00:01:10.280 --> 00:01:13.740
write a self adjusting logic on top of binary search 

25
00:01:13.740 --> 00:01:18.080
tree implementation which automatically balances the height of the tree 

26
00:01:18.090 --> 00:01:20.550
whenever insertion and deletion happens 

27
00:01:21.040 --> 00:01:23.700
If we can do that we can always keep the 

28
00:01:23.700 --> 00:01:27.280
BST size as minimum as possible so that even in 

29
00:01:27.280 --> 00:01:30.530
the worst case we can retrieve elements in order of 

30
00:01:30.530 --> 00:01:32.260
log n time complexity 

31
00:01:32.570 --> 00:01:36.640
These kinds of binary search trees are called self balancing 

32
00:01:36.640 --> 00:01:37.950
binary search trees 

33
00:01:38.340 --> 00:01:41.250
A self balancing binary search tree is a hike 

34
00:01:41.250 --> 00:01:45.170
balance binary search tree that automatically keep the height as 

35
00:01:45.170 --> 00:01:46.320
small as possible 

36
00:01:46.550 --> 00:01:50.050
Then insertion and deletion operations are performed on the tree 

37
00:01:50.540 --> 00:01:53.560
So even in the worst case we can retrieve elements 

38
00:01:53.560 --> 00:01:55.050
in order of log n time 

39
00:01:55.740 --> 00:01:57.070
These are the two widely 

40
00:01:57.070 --> 00:02:00.730
use self balance binary search trees a V L tree and 

41
00:02:00.730 --> 00:02:03.830
red black tree we will learn how to construct AVL 

42
00:02:03.830 --> 00:02:06.740
tree and red black tree in the coming lessons. 

