WEBVTT

1
00:00:00.440 --> 00:00:03.550
hello friends in this video to see how to search 

2
00:00:03.550 --> 00:00:06.350
for an element in hash table with linear probing 

3
00:00:07.340 --> 00:00:10.270
So we have a function search here which takes the 

4
00:00:10.270 --> 00:00:13.680
value to be searched and we have this hash table 

5
00:00:13.680 --> 00:00:14.060
here 

6
00:00:14.740 --> 00:00:18.480
Let a search for element four first so value equal 

7
00:00:18.480 --> 00:00:22.370
to four on by our hash function four should have 

8
00:00:22.370 --> 00:00:25.540
been stored an index four mod five which is equal 

9
00:00:25.540 --> 00:00:26.480
to four 

10
00:00:26.550 --> 00:00:29.640
So just copy to index and check if index 

11
00:00:29.640 --> 00:00:33.330
four has the value four so just as we did an 

12
00:00:33.340 --> 00:00:36.900
insertion and deletion in use of while loop with condition 

13
00:00:37.210 --> 00:00:41.070
arr  of index not equal to value and if it is 

14
00:00:41.080 --> 00:00:44.850
equal to value search is found and otherwise we have to 

15
00:00:44.850 --> 00:00:48.810
check in the next indices and if it is not 

16
00:00:48.810 --> 00:00:51.810
found in any of the indices the search is 

17
00:00:51.810 --> 00:00:52.550
not found 

18
00:00:53.140 --> 00:00:54.490
So that is how it works 

19
00:00:54.940 --> 00:00:57.850
And here arr  of index equal to four 

20
00:00:58.110 --> 00:01:02.790
So while fails that is we found the element four 

21
00:01:02.800 --> 00:01:03.760
at index four 

22
00:01:04.130 --> 00:01:07.350
So simply return one as the search was successful 

23
00:01:08.540 --> 00:01:10.690
now let us a search for element 12 

24
00:01:11.440 --> 00:01:14.080
So find the key first and we have 12 mod 

25
00:01:14.080 --> 00:01:18.380
five equal to two now copy this index two index 

26
00:01:18.610 --> 00:01:21.880
and check if index two has the value 12 and 

27
00:01:21.880 --> 00:01:25.950
here arr  of index that is arr  of two equal to 

28
00:01:25.950 --> 00:01:28.080
two not value 12 

29
00:01:28.570 --> 00:01:32.390
So while condition is true so we find the next 

30
00:01:32.390 --> 00:01:36.340
index that is index plus one mod size that is 

31
00:01:36.340 --> 00:01:38.780
two plus one mod five that is three mod five 

32
00:01:38.780 --> 00:01:42.010
equal to three and check if it is equal to 

33
00:01:42.010 --> 00:01:45.440
key and it is not so if fails and this 

34
00:01:45.440 --> 00:01:49.470
iteration is completed now in the next iteration check the 

35
00:01:49.470 --> 00:01:53.070
while condition and we have arr  of three equal to 

36
00:01:53.070 --> 00:01:55.350
minus one and not our value 12 

37
00:01:55.940 --> 00:01:59.190
So again while is true that his 12 is not 

38
00:01:59.200 --> 00:02:02.870
present in this index so find the new index and 

39
00:02:02.870 --> 00:02:06.370
we have index equal to three plus one mod five 

40
00:02:06.460 --> 00:02:10.010
that is four mod five equal to four and check 

41
00:02:10.020 --> 00:02:12.450
if it is equal to key and it is not 

42
00:02:12.940 --> 00:02:13.190
so 

43
00:02:13.200 --> 00:02:17.220
If fails and this iteration is completed now in the 

44
00:02:17.220 --> 00:02:20.870
next iteration check the while condition and we have  

45
00:02:20.870 --> 00:02:23.410
arr of four equal to four and not our 

46
00:02:23.410 --> 00:02:24.250
value 12 

47
00:02:25.140 --> 00:02:27.570
So again while is true that is 12 

48
00:02:27.580 --> 00:02:31.110
It's not present in this index also so find the 

49
00:02:31.110 --> 00:02:34.120
new index and we have index equal to index plus 

50
00:02:34.120 --> 00:02:36.990
one mod size that is four plus one mod five 

51
00:02:37.000 --> 00:02:40.460
that is five mod five equal to zero and check 

52
00:02:40.470 --> 00:02:41.750
if it is equal to key 

53
00:02:41.800 --> 00:02:43.460
But it is not so 

54
00:02:43.460 --> 00:02:46.500
check the while condition for the next iteration and we have 

55
00:02:46.510 --> 00:02:49.650
arr  of zero equal to 10 and not 12 

56
00:02:50.140 --> 00:02:53.770
So again while is true and we have to find 

57
00:02:53.770 --> 00:02:57.070
a new index and we have index equal to zero 

58
00:02:57.070 --> 00:03:00.150
plus one mod five that is one mod five equal 

59
00:03:00.150 --> 00:03:02.820
to one check if it is equal to key 

60
00:03:02.890 --> 00:03:04.580
But it is not so 

61
00:03:04.590 --> 00:03:07.820
If fails and the iteration is completed and for the 

62
00:03:07.820 --> 00:03:10.790
next iteration let us check the while condition and we 

63
00:03:10.790 --> 00:03:14.450
have arr  of one equal to 15 and not 12 

64
00:03:14.840 --> 00:03:18.600
Which means 12 is not present in this index also 

65
00:03:19.010 --> 00:03:21.070
So we have to find the new index and we 

66
00:03:21.070 --> 00:03:24.850
have index equal to one plus one mod five that 

67
00:03:24.850 --> 00:03:27.790
is two mod five equal to two now check if 

68
00:03:27.790 --> 00:03:30.820
it is equal to key and it is that is 

69
00:03:30.890 --> 00:03:34.240
we have searched all the indices is for element 12 

70
00:03:34.280 --> 00:03:37.490
and we did not find it so written zero as 

71
00:03:37.500 --> 00:03:39.350
the search was unsuccessful 

72
00:03:40.040 --> 00:03:43.050
So that is how we implement hash table using linear 

73
00:03:43.050 --> 00:03:47.800
probing method we learnt how to implement insertion deletion 

74
00:03:47.800 --> 00:03:50.000
and searching in insertion 

75
00:03:50.100 --> 00:03:53.450
We can find the key using value mod size equation 

76
00:03:53.820 --> 00:03:57.350
And if collision occurs simply check the next index 

77
00:03:57.840 --> 00:04:01.490
And in deletion and searching we first check the supposed 

78
00:04:01.490 --> 00:04:02.010
index 

79
00:04:02.280 --> 00:04:05.360
And if it is not there check the next indices 

80
00:04:05.940 --> 00:04:09.180
and to delete an element just make that index equal 

81
00:04:09.180 --> 00:04:09.950
to minus one 

82
00:04:10.840 --> 00:04:12.350
So that was close hashing 

83
00:04:12.740 --> 00:04:15.560
And in the next video let us discuss about open 

84
00:04:15.560 --> 00:04:16.050
hashing. 

