WEBVTT

1
00:00:00.040 --> 00:00:04.280
so let us write a function duplicate number which takes two 

2
00:00:04.280 --> 00:00:07.120
arguments the array and its size. 

3
00:00:07.640 --> 00:00:11.500
Let us declare an iterating variable i and initialise 

4
00:00:11.510 --> 00:00:17.260
it to 0. Then write while i is less than size. So first 

5
00:00:17.260 --> 00:00:21.090
check if the number is not present in its index 

6
00:00:21.430 --> 00:00:24.500
So write if array[i] not equal to i+1

7
00:00:24.510 --> 00:00:28.570
 here why are we writing i+1?

8
00:00:28.570 --> 00:00:28.950


9
00:00:29.240 --> 00:00:31.400
The array index starts from zero 

10
00:00:31.730 --> 00:00:35.350
But in our problem the numbers are from one to n

11
00:00:35.360 --> 00:00:35.670


12
00:00:36.030 --> 00:00:38.840
That is why we are checking if array[i]

13
00:00:38.850 --> 00:00:40.750
not equal to i+1 

14
00:00:41.340 --> 00:00:43.450
If yes, we need to swap them 

15
00:00:44.040 --> 00:00:46.980
Otherwise we can move to the next element 

16
00:00:47.330 --> 00:00:49.750
So write else i++ 

17
00:00:50.440 --> 00:00:53.540
Now we need to find the correct index of array[i] 

18
00:00:53.540 --> 00:00:56.250
and we need to swap the elements 

19
00:00:56.670 --> 00:00:59.530
So find the correct index of array[i]

20
00:00:59.810 --> 00:01:02.180
That is array[i-1].

21
00:01:02.520 --> 00:01:07.210
So write int index equal to array[i]-1

22
00:01:07.210 --> 00:01:07.600


23
00:01:08.040 --> 00:01:11.600
If value of array[i] and array[index]

24
00:01:11.600 --> 00:01:14.650
are not equal, we can swap the elements. 

25
00:01:15.100 --> 00:01:18.820
So write if array[i] not equal to array[index]

26
00:01:18.820 --> 00:01:24.330
then swap &array[i] and 

27
00:01:24.340 --> 00:01:26.870
&array[index].

28
00:01:28.240 --> 00:01:31.430
Now if they are equal, we have found the duplicate 

29
00:01:31.440 --> 00:01:35.750
element. So we can simply return it. So write else 

30
00:01:36.010 --> 00:01:39.080
return array[i] which is the duplicate element 

31
00:01:39.190 --> 00:01:40.000
And that's it.

32
00:01:40.320 --> 00:01:43.920
And if there are no duplicates present, just return -1

33
00:01:43.920 --> 00:01:45.490
 in the end. 

