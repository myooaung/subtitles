WEBVTT

1
00:00:00.140 --> 00:00:02.310
hello friends in this video 

2
00:00:02.430 --> 00:00:07.650
Let us understand why analysing time complexity is very important 

3
00:00:08.540 --> 00:00:13.220
We can understand why analysing time complexity is so important 

4
00:00:13.230 --> 00:00:17.840
Using this example assumed that we have to find all 

5
00:00:17.840 --> 00:00:21.980
the devices of a given natural number we can write 

6
00:00:21.990 --> 00:00:23.650
many algorithms for this 

7
00:00:24.140 --> 00:00:27.690
Let us take these two algorithms and analysed their time 

8
00:00:27.690 --> 00:00:29.990
complexity algorithm 

9
00:00:29.990 --> 00:00:33.850
One is using this for Loop from i till n

10
00:00:34.420 --> 00:00:38.140
and algorithm two is using this for Loop from i 

11
00:00:38.400 --> 00:00:42.430
till square root of n if we assume one millisecond 

12
00:00:42.430 --> 00:00:46.840
time is required for the inside operation for input 

13
00:00:46.850 --> 00:00:51.390
10 the first algorithm will run 10 milliseconds whereas the 

14
00:00:51.390 --> 00:00:56.080
second algorithm will take only three milliseconds since it solves 

15
00:00:56.080 --> 00:00:59.530
the problem in square root of n iterations as the 

16
00:00:59.530 --> 00:01:02.150
input number and gets higher and higher 

17
00:01:02.310 --> 00:01:05.820
The time taken by the first algorithm is proportional to 

18
00:01:05.820 --> 00:01:06.350
input 

19
00:01:06.520 --> 00:01:10.250
But the second algorithm takes only square root of n

20
00:01:10.260 --> 00:01:16.140
iterations even though both algorithms provide the same result algorithm 

21
00:01:16.150 --> 00:01:19.650
to has efficiently solved the given problem 

22
00:01:20.240 --> 00:01:22.980
So this is how a small difference in the time 

23
00:01:22.980 --> 00:01:27.600
complexity will make a major impact on the code performance 

24
00:01:28.040 --> 00:01:32.510
So writing an efficient algorithm and analysing it's running time is very very important

