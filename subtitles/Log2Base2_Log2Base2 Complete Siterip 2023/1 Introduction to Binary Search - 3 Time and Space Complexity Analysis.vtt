WEBVTT

1
00:00:00.440 --> 00:00:03.470
Now let us discuss about the time complexity of this 

2
00:00:03.470 --> 00:00:04.250
operation 

3
00:00:04.640 --> 00:00:07.420
So we have this array and we are searching for 

4
00:00:07.420 --> 00:00:09.950
key 70 which is a middle element 

5
00:00:10.340 --> 00:00:14.150
Then it can be found in the first comparison itself 

6
00:00:14.640 --> 00:00:17.910
So the best case time complexity is order of one 

7
00:00:18.190 --> 00:00:20.730
and it will be when the key is a middle 

8
00:00:20.730 --> 00:00:21.350
element 

9
00:00:22.040 --> 00:00:25.390
Now again we have this array and we are searching 

10
00:00:25.390 --> 00:00:27.050
for key 45 

11
00:00:27.540 --> 00:00:29.650
So first there are n elements 

12
00:00:30.040 --> 00:00:33.970
Then we find the middle element 70 and understood that 

13
00:00:34.140 --> 00:00:37.200
the key 45 could be present in the left half 

14
00:00:37.200 --> 00:00:37.750
only 

15
00:00:38.340 --> 00:00:42.650
So now we will consider only n by two elements 

16
00:00:43.040 --> 00:00:45.470
Now we will find the middle element here which is 

17
00:00:45.470 --> 00:00:49.350
23 45 could be present in the right half only 

18
00:00:49.940 --> 00:00:53.210
So now we will consider only this part which is 

19
00:00:53.220 --> 00:00:54.810
n by four elements 

20
00:00:55.190 --> 00:00:59.000
That is this algorithm is dividing the array into half 

21
00:00:59.140 --> 00:01:02.060
in each iteration that is first 

22
00:01:02.060 --> 00:01:05.290
We have n elements then n by two then n 

23
00:01:05.290 --> 00:01:08.510
by four then n by eight and so on till 

24
00:01:08.510 --> 00:01:12.190
we have just one element that is n by two 

25
00:01:12.190 --> 00:01:15.170
raise to 0 n by to raise to 1 n by to 

26
00:01:15.170 --> 00:01:17.940
raise to 2 n by to raise to 3 up to one 

27
00:01:18.440 --> 00:01:21.550
that is in general n by two raise to key 

28
00:01:21.560 --> 00:01:24.310
equal to one so n equal to 

29
00:01:24.320 --> 00:01:27.980
Two raise to K now let us take log on both 

30
00:01:27.980 --> 00:01:31.190
sides and we will get log two raise to K 

31
00:01:31.200 --> 00:01:34.720
to base to equal to log n to base two 

32
00:01:34.770 --> 00:01:38.250
and by here is we can write log n raise to 

33
00:01:38.260 --> 00:01:40.860
n equal to n into log n

34
00:01:41.740 --> 00:01:45.050
So we will get K into log2base2 

35
00:01:45.540 --> 00:01:46.640
the value of log 

36
00:01:46.650 --> 00:01:49.590
A base A equal to one so value of 

37
00:01:49.590 --> 00:01:51.520
log2base2 is also equal to one 

38
00:01:51.960 --> 00:01:55.020
So we will get K into one equal to log n 

39
00:01:55.030 --> 00:01:59.150
so the average or worst case time complexity of 

40
00:01:59.160 --> 00:02:01.770
binary search is order of log n 

41
00:02:01.770 --> 00:02:05.120
now let us have a quick comparison of the 

42
00:02:05.120 --> 00:02:08.750
time complexity of linear search and binary search 

43
00:02:09.440 --> 00:02:13.380
If we have this array and key 123 we 

44
00:02:13.380 --> 00:02:17.520
have to make eight comparisons checking each and every element 

45
00:02:17.560 --> 00:02:20.960
in order to find it in linear search and the 

46
00:02:20.960 --> 00:02:24.980
worst case time complexity is order of n that is order 

47
00:02:24.980 --> 00:02:28.370
of eight here and in binary search the worst case 

48
00:02:28.370 --> 00:02:31.920
time complexity is order of log n that is order of 

49
00:02:32.020 --> 00:02:35.600
log eight which can be returned two raise to three

50
00:02:35.600 --> 00:02:35.990


51
00:02:36.210 --> 00:02:38.710
And it can be returns three into log2base2 

52
00:02:38.710 --> 00:02:41.150
and value of log2base2 equal to 

53
00:02:41.150 --> 00:02:45.520
one so three into one equal to three and for 

54
00:02:45.530 --> 00:02:47.050
array of eight elements 

55
00:02:47.200 --> 00:02:47.540
Linear

56
00:02:47.540 --> 00:02:50.950
search takes eight iterations but binary search takes 

57
00:02:50.950 --> 00:02:52.470
only three iterations 

58
00:02:52.610 --> 00:02:56.280
So that is how binary search is very efficient than 

59
00:02:56.280 --> 00:02:57.130
linear search 

60
00:02:57.380 --> 00:03:01.050
But we always need a sorted array in binary search 

61
00:03:01.140 --> 00:03:04.640
If the array is sorted then we can undoubtedly go 

62
00:03:04.640 --> 00:03:05.850
for binary search 

63
00:03:05.940 --> 00:03:09.560
And if we have an unsorted array and to apply 

64
00:03:09.560 --> 00:03:12.550
binary search we have to sort it first then 

65
00:03:12.560 --> 00:03:15.740
pass it to binary search function so it may not 

66
00:03:15.740 --> 00:03:17.650
give that much efficiency.

