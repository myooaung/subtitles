WEBVTT

1
00:00:00.040 --> 00:00:02.860
in this video let us learn how to perform the 

2
00:00:02.870 --> 00:00:04.640
enqueue operation in a circular 

3
00:00:04.640 --> 00:00:05.050
queue 

4
00:00:05.540 --> 00:00:09.470
First let us taken integer array of size three and 

5
00:00:09.480 --> 00:00:12.650
initialised the front and rear pointer as minus one 

6
00:00:13.040 --> 00:00:16.700
Now let us enqueue element 10 as usual 

7
00:00:16.840 --> 00:00:20.260
In the enqueue operation we increment the rear pointer and 

8
00:00:20.270 --> 00:00:21.590
insert given value 

9
00:00:21.910 --> 00:00:25.720
So circular increment the rear pointer and placed the value 

10
00:00:25.730 --> 00:00:29.860
10 so rear will become rear plus one mod size 

11
00:00:30.190 --> 00:00:33.360
Here the value of rear is minus one and value 

12
00:00:33.360 --> 00:00:36.630
of size is three so it will become rear equal 

13
00:00:36.630 --> 00:00:39.370
to minus one plus one mod three 

14
00:00:39.620 --> 00:00:42.370
It will be zero mod three which is zero so 

15
00:00:42.370 --> 00:00:44.450
the value of rear pointer will be zero 

16
00:00:44.640 --> 00:00:47.610
So place the Element 10 in array of rear that 

17
00:00:47.610 --> 00:00:50.980
is array of zero since it is the first element 

18
00:00:50.990 --> 00:00:54.090
we need to set the front pointer to zero which 

19
00:00:54.090 --> 00:00:55.190
will be useful to check 

20
00:00:55.190 --> 00:00:58.660
The queue empty case that's it performed the circular 

21
00:00:58.660 --> 00:01:01.780
increment on the rear Pointer and placed the value in 

22
00:01:01.790 --> 00:01:05.190
array of rear and for the first element alone set 

23
00:01:05.190 --> 00:01:06.450
front as zero 

24
00:01:07.040 --> 00:01:09.450
Now let us enqueue Element 20 

25
00:01:10.020 --> 00:01:13.820
Similarly perform circular increment on the rear Pointer it will 

26
00:01:13.820 --> 00:01:17.100
become zero plus one mod three which will be one 

27
00:01:17.100 --> 00:01:20.010
mod three and the value of one mod three is 

28
00:01:20.010 --> 00:01:23.850
one so placed the value 20 in array of one 

29
00:01:24.440 --> 00:01:28.470
Now let us enqueue one more element 30 Similarly 

30
00:01:28.470 --> 00:01:32.220
perform circular increment on rear pointer it will become 

31
00:01:32.220 --> 00:01:35.220
one plus One mod three which will be two mod 

32
00:01:35.220 --> 00:01:38.150
three and the value of two mod three is two 

33
00:01:38.620 --> 00:01:41.250
so placed the value 30 in array of two 

34
00:01:41.800 --> 00:01:44.810
Now the queue is full so we can't perform the 

35
00:01:44.820 --> 00:01:48.470
enqueue operation here The value of front is zero and the value 

36
00:01:48.470 --> 00:01:50.670
of rear is two which is size minus one 

37
00:01:51.240 --> 00:01:54.270
So when front is equal to zero and Rear is equal to size 

38
00:01:54.270 --> 00:01:57.150
minus one we can say that the queue is full 

39
00:01:57.630 --> 00:01:59.170
Let us note this condition 

40
00:01:59.350 --> 00:02:01.450
We will use this in the implementation 

41
00:02:01.940 --> 00:02:03.870
Now let us dequeue one element 

42
00:02:04.150 --> 00:02:05.040
We will learn the dequeue 

43
00:02:05.040 --> 00:02:07.870
operation elaboratly in the next video as of 

44
00:02:07.870 --> 00:02:09.750
now just dequeue one element 

45
00:02:10.060 --> 00:02:13.070
So what will happen in dequeue operation We will 

46
00:02:13.070 --> 00:02:16.600
move the front pointer and returned the value So here 

47
00:02:16.690 --> 00:02:19.350
the front pointer will move to the next index 

48
00:02:19.440 --> 00:02:22.050
An element 10 will be dequeued from the queue 

49
00:02:22.540 --> 00:02:25.870
Now we have one empty space so we can  

50
00:02:25.870 --> 00:02:27.250
enqueue one element here 

51
00:02:27.640 --> 00:02:31.600
now let us enqueue Element 40 so perform circular increment 

52
00:02:31.610 --> 00:02:32.660
on rear pointer 

53
00:02:33.000 --> 00:02:35.440
The value of rear pointer is twwo so it will 

54
00:02:35.440 --> 00:02:38.530
become two plus one mod three which will be three 

55
00:02:38.530 --> 00:02:41.360
mod three and the value of three mod three is zero 

56
00:02:41.710 --> 00:02:44.450
So placed the value 40 in array of zero 

57
00:02:44.740 --> 00:02:48.750
We can say that the reappointed adjust itself circularly 

58
00:02:48.760 --> 00:02:50.650
when it reaches the end of the queue 

59
00:02:50.940 --> 00:02:52.710
That's why it is called a circular 

60
00:02:52.710 --> 00:02:53.050
queue 

61
00:02:53.540 --> 00:02:55.600
After the insertion of 40

62
00:02:55.600 --> 00:02:59.680
the queue is full again we can't perform enqueue operation here 

63
00:02:59.680 --> 00:03:01.900
The value of front is one and the value of 

64
00:03:01.900 --> 00:03:02.790
rear is zero 

65
00:03:02.800 --> 00:03:05.030
That is rear is one indicts behind 

66
00:03:05.030 --> 00:03:08.030
The front point of that is when rear are equal 

67
00:03:08.030 --> 00:03:09.230
to front  minus one 

68
00:03:09.330 --> 00:03:11.250
We can say that queue is full 

69
00:03:11.640 --> 00:03:14.350
We should also include this condition as well in the 

70
00:03:14.350 --> 00:03:14.600
queue 

71
00:03:14.600 --> 00:03:15.350
Full check 

72
00:03:15.730 --> 00:03:18.920
So not this condition as well so the logic for 

73
00:03:18.930 --> 00:03:20.760
enqueue operation is very simple 

74
00:03:20.880 --> 00:03:21.810
First check 

75
00:03:21.820 --> 00:03:24.380
Whether the queue is full or not if it is 

76
00:03:24.380 --> 00:03:28.730
full just written otherwise performs circular increment on the rear 

77
00:03:28.730 --> 00:03:32.390
Pointer and placed the value for the first enqueue operation 

78
00:03:32.400 --> 00:03:34.050
set front as zero 

79
00:03:35.140 --> 00:03:38.770
Let us quickly implement the enqueue operation write a function 

80
00:03:38.770 --> 00:03:42.120
named enqueue which takes one integer argument 

81
00:03:42.130 --> 00:03:45.840
val Val is the value which should be inserted into 

82
00:03:45.840 --> 00:03:49.240
the queue this function won't written anything so write 

83
00:03:49.240 --> 00:03:50.850
It's return type as void 

84
00:03:51.340 --> 00:03:53.900
First we need to check whether the queue is full 

85
00:03:53.910 --> 00:03:54.540
or not 

86
00:03:54.760 --> 00:03:59.190
So write If isQueuefull if the queue is full we 

87
00:03:59.190 --> 00:04:01.150
can't insert the element so 

88
00:04:01.150 --> 00:04:02.520
print queue is full 

89
00:04:02.850 --> 00:04:05.490
If the queue is not full we can insert the 

90
00:04:05.490 --> 00:04:06.000
value 

91
00:04:06.220 --> 00:04:08.800
For that we need to perform a circular increment on 

92
00:04:08.800 --> 00:04:12.570
the rear pointer so write rear equal to rear plus 

93
00:04:12.570 --> 00:04:13.750
one mod size 

94
00:04:14.070 --> 00:04:16.660
And then we need to place the value in array 

95
00:04:16.660 --> 00:04:17.180
of rear 

96
00:04:17.250 --> 00:04:20.550
So write array of rear equal to val we have 

97
00:04:20.560 --> 00:04:22.270
almost completed the logic 

98
00:04:22.390 --> 00:04:25.280
We just need to check one more case here 

99
00:04:25.290 --> 00:04:27.940
When we insert the first element we need to set 

100
00:04:27.950 --> 00:04:32.070
the value front zero So write if front equal to 

101
00:04:32.070 --> 00:04:34.050
minus one front  equal to zero 

102
00:04:34.440 --> 00:04:38.200
that's it we have implemented the logic for enqueue operation 

103
00:04:38.450 --> 00:04:42.010
Now let us quickly implement the isQueuefull function 

104
00:04:42.300 --> 00:04:45.020
This function will check whether the queue is full or 

105
00:04:45.020 --> 00:04:45.480
not 

106
00:04:45.740 --> 00:04:47.970
If it is full it will return true 

107
00:04:48.170 --> 00:04:49.480
Otherwise it will return 

108
00:04:49.480 --> 00:04:51.060
false so let us write 

109
00:04:51.060 --> 00:04:54.750
A function named isQueuefull with return type as bool 

110
00:04:55.140 --> 00:04:58.300
We have already discussed two Queue full cases 

111
00:04:58.380 --> 00:04:59.920
One is when front 

112
00:04:59.920 --> 00:05:02.760
equal to 0 and rear equal to size minus one 

113
00:05:03.110 --> 00:05:05.160
And the second one is when rear equal to 

114
00:05:05.160 --> 00:05:08.110
front minus one that is rear pointer 

115
00:05:08.110 --> 00:05:10.440
is one index behind the front pointer 

116
00:05:10.750 --> 00:05:12.920
For these two cases we need to return 

117
00:05:12.930 --> 00:05:13.350
True 

118
00:05:13.660 --> 00:05:16.780
So write if front  equal to 0 and rear equal 

119
00:05:16.780 --> 00:05:18.050
to size minus one 

120
00:05:18.230 --> 00:05:19.170
Return true 

121
00:05:19.340 --> 00:05:22.370
And if rear equal to front minus 1

122
00:05:22.370 --> 00:05:22.950
return true 

123
00:05:23.440 --> 00:05:24.350
Otherwise the queue 

124
00:05:24.350 --> 00:05:25.240
is not full 

125
00:05:25.340 --> 00:05:27.090
So we need to return False 

126
00:05:27.290 --> 00:05:29.950
So in the end just returned False 

127
00:05:30.540 --> 00:05:33.710
that's it in this video we have learned the 

128
00:05:33.710 --> 00:05:35.920
enqueue operation and its implementation 

129
00:05:36.170 --> 00:05:38.350
In the next video we will learn the dequeue operation and its implementation. 

