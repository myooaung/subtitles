WEBVTT

1
00:00:00.040 --> 00:00:02.990
Why to be needed circular queue to understand the 

2
00:00:02.990 --> 00:00:04.110
need for the circular 

3
00:00:04.110 --> 00:00:04.500
queue 

4
00:00:04.710 --> 00:00:07.780
First let us understand the limitation of the normal 

5
00:00:07.780 --> 00:00:08.150
Queue

6
00:00:08.640 --> 00:00:10.050
Let us take a sample queue 

7
00:00:10.050 --> 00:00:11.050
Of size five 

8
00:00:11.600 --> 00:00:12.150
Let us 

9
00:00:12.150 --> 00:00:17.680
enqueue five elements 10 2030 40 50 After the  

10
00:00:17.680 --> 00:00:17.870
enqueue 

11
00:00:17.870 --> 00:00:20.850
Operations the queue will look something like this 

12
00:00:21.440 --> 00:00:22.950
Now let us dequeue 

13
00:00:22.960 --> 00:00:23.890
Three elements 

14
00:00:24.340 --> 00:00:28.490
So the first inserted elements 10 20 and 30 will 

15
00:00:28.490 --> 00:00:31.010
be removed from the queue and it will look like 

16
00:00:31.010 --> 00:00:34.550
this now suppose if we want to add one more 

17
00:00:34.550 --> 00:00:34.960
element 

18
00:00:34.960 --> 00:00:35.560
60

19
00:00:35.560 --> 00:00:36.050
in the queue 

20
00:00:36.060 --> 00:00:40.150
What will happen Even though we have three empty spaces 

21
00:00:40.390 --> 00:00:44.650
we cannot enqueue element 60 because the rear pointer 

22
00:00:44.650 --> 00:00:46.150
is at the end of the queue 

23
00:00:46.540 --> 00:00:50.980
So this non usable empty space is the major limitations 

24
00:00:50.990 --> 00:00:52.050
of the normal queue 

25
00:00:52.540 --> 00:00:55.860
But we can eliminate this issue by using a circular

26
00:00:55.860 --> 00:00:58.290
Queue in the circular queue 

27
00:00:58.520 --> 00:01:02.590
Instead of a normal increment we will perform circular increment 

28
00:01:03.040 --> 00:01:06.260
The circular increment is performed by modulo division with the 

29
00:01:06.260 --> 00:01:07.060
queue size 

30
00:01:07.460 --> 00:01:10.120
So whenever we reached the end of the queue to 

31
00:01:10.120 --> 00:01:13.890
rear pointer automatically come to the Start index and 

32
00:01:13.890 --> 00:01:16.750
we can utilise the available space effectively 

33
00:01:17.140 --> 00:01:19.660
So in this case if we want to enqueue 

34
00:01:19.660 --> 00:01:22.150
Element 60 it will be added here 

35
00:01:22.740 --> 00:01:25.040
And we can also add two more elements in the 

36
00:01:25.040 --> 00:01:26.050
available space 

37
00:01:26.640 --> 00:01:30.030
So this is how a circular queue effectively utilises non 

38
00:01:30.030 --> 00:01:30.960
usable memory 

39
00:01:31.440 --> 00:01:34.000
That's it and in this video we have learned the 

40
00:01:34.000 --> 00:01:35.100
need for a circular 

41
00:01:35.100 --> 00:01:35.480
queue 

42
00:01:35.750 --> 00:01:38.570
In the next videos we will learn how to perform 

43
00:01:38.580 --> 00:01:42.020
and implement enqueue and Deque operations on a circular 

44
00:01:42.020 --> 00:01:42.450
queue.

