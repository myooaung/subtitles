WEBVTT

1
00:00:00.040 --> 00:00:02.230
you will be given a string and you need to 

2
00:00:02.230 --> 00:00:04.510
check if it is a palindrome or not 

3
00:00:04.520 --> 00:00:09.060
Using recursion so let us take two different palindrome strings 

4
00:00:09.070 --> 00:00:11.550
and form the logic to solve this problem 

5
00:00:12.340 --> 00:00:16.130
The first one is the odd length string Madam and 

6
00:00:16.130 --> 00:00:18.410
the next is the even length string 

7
00:00:18.420 --> 00:00:18.750
ACCA

8
00:00:20.110 --> 00:00:22.120
So how will we check If it is a palindrom 

9
00:00:22.120 --> 00:00:26.510
we will take the start and end index characters 

10
00:00:26.690 --> 00:00:29.350
and check whether both of them are equal 

11
00:00:30.240 --> 00:00:33.820
If equal we moved to the next pair by incrementing 

12
00:00:33.820 --> 00:00:36.850
the Start Index and decrementing the end index 

13
00:00:37.540 --> 00:00:39.950
So what will be the base case for an odd 

14
00:00:39.950 --> 00:00:44.180
length string in an odd length string If we continue 

15
00:00:44.180 --> 00:00:47.740
to do this palindrom check the start and END 

16
00:00:47.750 --> 00:00:49.930
index will meet at the middle index 

17
00:00:50.120 --> 00:00:53.050
So when start is equal to end we can stop 

18
00:00:53.050 --> 00:00:53.850
the process 

19
00:00:54.340 --> 00:00:57.140
But in the case of an even length string the 

20
00:00:57.140 --> 00:01:00.380
Start and END Index will not meet at the same 

21
00:01:00.380 --> 00:01:00.950
index 

22
00:01:01.340 --> 00:01:03.620
So what will be the base case of even length 

23
00:01:03.620 --> 00:01:08.110
strings in even length strings If all the pairs of 

24
00:01:08.110 --> 00:01:12.290
characters are equal at some point the START Index will 

25
00:01:12.300 --> 00:01:15.840
cross the end index and that is the base case 

26
00:01:15.840 --> 00:01:19.960
for even length string that is when start is greater 

27
00:01:19.960 --> 00:01:20.760
than end 

28
00:01:20.910 --> 00:01:22.750
Then we can stop the process 

29
00:01:23.440 --> 00:01:27.440
So the overall base case of this problem is when 

30
00:01:27.440 --> 00:01:30.450
start is greater than or equal to end 

31
00:01:30.840 --> 00:01:34.550
Here start is equal to end is for odd length 

32
00:01:34.550 --> 00:01:38.650
strings and start greater than end for even length strings 

33
00:01:39.340 --> 00:01:42.770
So when start index is greater than or equal to 

34
00:01:42.780 --> 00:01:46.050
end we can stop the recursive call and return true 

35
00:01:46.440 --> 00:01:47.800
Let us see an example 

36
00:01:47.810 --> 00:01:52.780
We have the string ACCA so passed the string its Start index 

37
00:01:52.790 --> 00:01:56.190
and end index into the function checked the base case 

38
00:01:56.200 --> 00:01:59.890
if start is greater than or equal to end and 

39
00:01:59.900 --> 00:02:01.330
it is not so check 

40
00:02:01.340 --> 00:02:04.170
If the characters had start and end indices 

41
00:02:04.180 --> 00:02:07.860
are equal and they are so called the function again 

42
00:02:07.860 --> 00:02:11.680
with the string incremented start index and decremented end 

43
00:02:11.690 --> 00:02:15.950
index that is start plus one and end minus one 

44
00:02:16.740 --> 00:02:19.900
Now here also first check for the base case 

45
00:02:19.910 --> 00:02:20.880
and it fails 

46
00:02:20.990 --> 00:02:24.480
So check if characters had start and end are the 

47
00:02:24.480 --> 00:02:27.630
same and they are so make the next recursive 

48
00:02:27.630 --> 00:02:30.870
call Start plus one and end minus one 

49
00:02:30.970 --> 00:02:32.950
That is two and one 

50
00:02:33.440 --> 00:02:36.460
So in this function when we check the base case 

51
00:02:36.470 --> 00:02:39.200
if start is greater than or equal to end it 

52
00:02:39.200 --> 00:02:42.950
is true since two is greater than one so we 

53
00:02:42.950 --> 00:02:45.250
can stop the process and return one. 

