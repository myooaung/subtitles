WEBVTT

1
00:00:00.800 --> 00:00:04.200
in this video let us discuss the basics of binary 

2
00:00:04.200 --> 00:00:04.950
search tree 

3
00:00:05.940 --> 00:00:08.700
So a binary search tree as you know is a 

4
00:00:08.700 --> 00:00:12.340
binary tree that is it can have a maximum of 

5
00:00:12.350 --> 00:00:15.940
two Children and the important property of a binary search 

6
00:00:15.940 --> 00:00:19.270
tree is that the value of left child will be 

7
00:00:19.270 --> 00:00:22.710
less than the value of parent and value of parent 

8
00:00:22.720 --> 00:00:25.050
will be less than the value of right child 

9
00:00:25.240 --> 00:00:28.160
So all the values in the left sub tree will 

10
00:00:28.160 --> 00:00:30.820
be less than the root and all the values in 

11
00:00:30.820 --> 00:00:33.460
the right sub tree will be greater than the root 

12
00:00:33.550 --> 00:00:36.820
So here we have a series of values given let us 

13
00:00:36.820 --> 00:00:40.260
construct a binary search tree using these values 

14
00:00:40.500 --> 00:00:42.850
So how can we do that let us see 

15
00:00:43.340 --> 00:00:46.260
We need to insert the nodes in the same order 

16
00:00:46.260 --> 00:00:46.650
given 

17
00:00:47.140 --> 00:00:50.390
So first we have to insert the first node 

18
00:00:50.470 --> 00:00:53.870
So insert 100 it becomes the root of the binary 

19
00:00:53.870 --> 00:00:54.780
search tree 

20
00:00:54.810 --> 00:00:58.300
Next we have 50 and is 50 less than the 

21
00:00:58.300 --> 00:01:00.230
root 100 yes it's 

22
00:01:00.290 --> 00:01:03.640
So place it as the left child and why did 

23
00:01:03.640 --> 00:01:06.840
we do that Remember the property of binary search 

24
00:01:06.840 --> 00:01:10.020
tree The value of left child will be less than 

25
00:01:10.020 --> 00:01:13.120
the value of parent and value of right child will 

26
00:01:13.120 --> 00:01:15.100
be greater than the value of parent 

27
00:01:15.260 --> 00:01:18.940
That's why we placed 50 as the left child of 

28
00:01:18.940 --> 00:01:19.490
100 

29
00:01:19.770 --> 00:01:23.470
So next we have 200 at is 200 less than 

30
00:01:23.470 --> 00:01:24.570
the root No 

31
00:01:24.580 --> 00:01:27.610
200 is actually greater than root 100 So 

32
00:01:27.610 --> 00:01:30.260
Place it as the right child of 100 

33
00:01:30.570 --> 00:01:34.110
Next we have the value 10 Travers from the root 

34
00:01:34.300 --> 00:01:36.800
and east then less than the root 100 

35
00:01:37.070 --> 00:01:39.160
Yes so go to left side 

36
00:01:39.170 --> 00:01:41.410
And there we have 50 again 

37
00:01:41.410 --> 00:01:44.510
check is 10 less than 50 against 

38
00:01:44.510 --> 00:01:48.060
It is So place 10th as the left child of 

39
00:01:48.060 --> 00:01:48.650
50 

40
00:01:49.140 --> 00:01:51.580
And next we have 60 again 

41
00:01:51.580 --> 00:01:54.230
Travers from the root is 60 less than the root 

42
00:01:54.230 --> 00:01:55.470
100 yes 

43
00:01:55.540 --> 00:01:58.360
So go to left side and there we have 50 

44
00:01:58.390 --> 00:01:58.820
again 

45
00:01:58.820 --> 00:02:03.130
check is 60 less than 50 no sixties actually greater 

46
00:02:03.130 --> 00:02:06.700
than 50 so place 60 as the right child of 

47
00:02:06.700 --> 00:02:07.250
50 

48
00:02:07.640 --> 00:02:10.570
And this is how we insert nodes in a binary 

49
00:02:10.570 --> 00:02:13.790
search tree and see you can take any node and 

50
00:02:13.790 --> 00:02:15.210
this order will be followed 

51
00:02:15.350 --> 00:02:18.470
That is value of left child less than value of 

52
00:02:18.470 --> 00:02:20.890
parent less than value of right child 

53
00:02:21.080 --> 00:02:22.830
So next we have 150 

54
00:02:23.020 --> 00:02:26.650
So check if 150 less than 100 No 

55
00:02:26.740 --> 00:02:29.900
So 150 actually greater than 100 so go 

56
00:02:29.900 --> 00:02:32.430
to right side and that we have 200 

57
00:02:32.440 --> 00:02:36.570
So check if 150 less than 200 it is 

58
00:02:36.830 --> 00:02:39.640
so 150 should be placed in the left sub 

59
00:02:39.640 --> 00:02:40.830
tree of 200 

60
00:02:41.020 --> 00:02:42.010
So Place it here 

61
00:02:42.200 --> 00:02:43.760
Next we have 300 

62
00:02:43.980 --> 00:02:47.590
So again start from the root is 300 less than or 

63
00:02:47.590 --> 00:02:48.670
greater than 100 

64
00:02:48.680 --> 00:02:50.190
It is greater than 100 

65
00:02:50.240 --> 00:02:52.670
So go to the right side and there we have 

66
00:02:52.680 --> 00:02:53.400
200 

67
00:02:53.670 --> 00:02:56.990
So check if 300 is less than or greater than 

68
00:02:56.990 --> 00:02:59.530
200 it is greater than 200 

69
00:02:59.690 --> 00:03:02.250
So again go to the right side and we can 

70
00:03:02.250 --> 00:03:03.080
place it there 

71
00:03:03.250 --> 00:03:05.140
So that is the logic and that is how we 

72
00:03:05.140 --> 00:03:07.500
can construct a binary search tree 

73
00:03:07.620 --> 00:03:10.390
Now what will be the structure of a single node 

74
00:03:10.390 --> 00:03:13.280
in a binary search tree As you can see in 

75
00:03:13.280 --> 00:03:18.240
a node there is a data like 100 10 200 50 

76
00:03:18.250 --> 00:03:18.850
etc 

77
00:03:19.440 --> 00:03:22.760
Also every node has a link to the left child 

78
00:03:22.900 --> 00:03:24.000
and it's right child 

79
00:03:24.260 --> 00:03:27.750
So each node in a binary search tree should have 

80
00:03:27.750 --> 00:03:30.580
a key which can be of any data type for 

81
00:03:30.580 --> 00:03:31.580
example integer 

82
00:03:31.750 --> 00:03:35.800
So int key should be there and also each node 

83
00:03:35.800 --> 00:03:38.850
points to its left child and right child 

84
00:03:39.040 --> 00:03:42.350
So two references must be there of our node type 

85
00:03:42.740 --> 00:03:44.650
So node left and node 

86
00:03:44.650 --> 00:03:45.150
Right 

87
00:03:45.540 --> 00:03:47.980
So this is our class for a node in a 

88
00:03:47.980 --> 00:03:49.460
binary search tree 

89
00:03:49.470 --> 00:03:52.260
Now let us create a node and let us name 

90
00:03:52.260 --> 00:03:56.380
it root so declare root and allocate memory to it 

91
00:03:56.390 --> 00:03:59.450
So right root equal to new node 

92
00:04:00.040 --> 00:04:03.630
So a node is created and we have key left 

93
00:04:03.640 --> 00:04:07.010
And right now we can add the data to it 

94
00:04:07.180 --> 00:04:10.360
So write root dot key equal to 10 

95
00:04:10.840 --> 00:04:14.200
So 10 will be stored in key field of root 

96
00:04:14.460 --> 00:04:17.050
Let us suppose this is the only node in the 

97
00:04:17.050 --> 00:04:19.320
tree so it has no Children 

98
00:04:19.500 --> 00:04:21.950
So left and right should point null 

99
00:04:22.340 --> 00:04:25.890
So right root dot Left equal to null and root 

100
00:04:25.890 --> 00:04:27.220
dot Right equal to null 

101
00:04:27.800 --> 00:04:29.950
So that is how we can create a node 

102
00:04:30.060 --> 00:04:33.800
So to allocate nodes we can simply create a constructor 

103
00:04:33.810 --> 00:04:34.850
inside the class 

104
00:04:35.240 --> 00:04:39.050
It will receive the node value as parameter and create a new binary search tree node with a given value.

