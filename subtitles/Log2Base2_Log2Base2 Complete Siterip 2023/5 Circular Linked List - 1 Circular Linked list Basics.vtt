WEBVTT

1
00:00:00.840 --> 00:00:03.790
in this video let us have an introduction to circular 

2
00:00:03.790 --> 00:00:08.840
linked List So circular linked lists are very much similar 

3
00:00:08.840 --> 00:00:10.490
to normal linked list 

4
00:00:10.750 --> 00:00:14.260
But the only difference is that in normal linked list 

5
00:00:14.430 --> 00:00:16.710
the last node will be pointing null 

6
00:00:16.840 --> 00:00:20.020
But in circular linked list the nodes are connected in 

7
00:00:20.020 --> 00:00:23.360
a circular manner so the last node will be linked 

8
00:00:23.360 --> 00:00:24.870
to the first node again 

9
00:00:25.000 --> 00:00:27.830
So in a circular linked list the last nodes 

10
00:00:27.830 --> 00:00:31.430
next will be connected to head and we can have 

11
00:00:31.430 --> 00:00:33.480
circular singly Linked list as well 

12
00:00:33.480 --> 00:00:34.030
A circular 

13
00:00:34.030 --> 00:00:35.410
doubly linked list 

14
00:00:35.430 --> 00:00:38.450
Let us see a sample programme to create a circular 

15
00:00:38.450 --> 00:00:42.320
singly Linked list with three nodes with data 10 

16
00:00:42.330 --> 00:00:43.670
20 and 30 

17
00:00:43.680 --> 00:00:46.370
So first we need to create and then we should 

18
00:00:46.370 --> 00:00:49.530
have next of node type and it is used to 

19
00:00:49.530 --> 00:00:50.950
refer to a next node 

20
00:00:51.540 --> 00:00:53.650
So write node next 

21
00:00:53.740 --> 00:00:57.260
Now let us declared the node head middle and last 

22
00:00:57.270 --> 00:00:59.520
so memories allocated in the stack 

23
00:00:59.530 --> 00:01:03.090
Now we can use new to allocate memory dynamically for 

24
00:01:03.100 --> 00:01:03.840
each node 

25
00:01:04.170 --> 00:01:08.500
So right head equal to new node so memory will 

26
00:01:08.500 --> 00:01:11.780
be allocated in the heap section and it's reference will 

27
00:01:11.780 --> 00:01:12.550
be returned 

28
00:01:12.640 --> 00:01:13.500
Similarly 

29
00:01:13.510 --> 00:01:17.520
Memories allocated in heap for middle node and last node 

30
00:01:17.690 --> 00:01:21.140
So now we have the nodes next we need values in 

31
00:01:21.140 --> 00:01:21.970
these nodes 

32
00:01:22.110 --> 00:01:26.000
So let us assigned the values 10 20 and 30 to these 

33
00:01:26.000 --> 00:01:29.330
nodes so the values will be stored in the data 

34
00:01:29.330 --> 00:01:31.460
Part of the node so write 

35
00:01:31.470 --> 00:01:36.510
Head dot data equal to 10 and middle dot data equal 

36
00:01:36.510 --> 00:01:40.230
to 20 and last dot data equal to 30 so 

37
00:01:40.230 --> 00:01:42.300
the values are stored in the nodes 

38
00:01:42.480 --> 00:01:44.150
The next step is these 

39
00:01:44.150 --> 00:01:45.680
Nodes should be linked 

40
00:01:45.940 --> 00:01:48.740
That is the linked list should be like head node 

41
00:01:48.740 --> 00:01:49.910
linked to middle node 

42
00:01:49.980 --> 00:01:53.370
Middle node linked to last node and last node linked 

43
00:01:53.370 --> 00:01:56.300
to head again then only it becomes a circular linked 

44
00:01:56.300 --> 00:01:59.580
list so let us linked them using the reference part 

45
00:01:59.770 --> 00:02:03.220
Firstly the next of first node should point to the 

46
00:02:03.220 --> 00:02:04.070
second node 

47
00:02:04.160 --> 00:02:08.470
So said head dot next equal to middle so 2000 

48
00:02:08.470 --> 00:02:10.580
will be stored in the next of head 

49
00:02:11.050 --> 00:02:11.960
now let us handle 

50
00:02:11.960 --> 00:02:12.740
The middle node 

51
00:02:12.900 --> 00:02:16.960
It's next should be pointing the last node so write 

52
00:02:16.970 --> 00:02:20.440
middle dot next equal to last so 3000 will be 

53
00:02:20.440 --> 00:02:23.570
stored in next of middle and the last node 

54
00:02:23.580 --> 00:02:25.620
It's next should point the head 

55
00:02:25.620 --> 00:02:29.350
Node so write last dot next equal to head 

56
00:02:29.740 --> 00:02:32.370
And now we have a circular linked list with three 

57
00:02:32.370 --> 00:02:32.930
nodes 

58
00:02:33.300 --> 00:02:34.290
Now let us print 

59
00:02:34.300 --> 00:02:36.650
Each nodes data in the linked list 

60
00:02:37.040 --> 00:02:40.360
So to print each nodes data we have to traverse 

61
00:02:40.360 --> 00:02:41.680
the linked list fully 

62
00:02:41.880 --> 00:02:45.310
Normally we traverse the linked list from head till we 

63
00:02:45.310 --> 00:02:48.180
reach the end but there is no end in a 

64
00:02:48.180 --> 00:02:49.480
circular linked list 

65
00:02:49.710 --> 00:02:52.460
It is cyclic but there is no end in 

66
00:02:52.460 --> 00:02:53.770
a circular linked list 

67
00:02:53.980 --> 00:02:54.370
It is 

68
00:02:54.370 --> 00:02:55.050
cyclic 

69
00:02:55.240 --> 00:02:57.980
The last node will point to the head and this 

70
00:02:57.980 --> 00:03:01.580
cycle will continue So we have to traverse from head 

71
00:03:01.700 --> 00:03:03.730
till we reach the head again 

72
00:03:03.740 --> 00:03:06.320
So let us use the display function to print the 

73
00:03:06.320 --> 00:03:09.150
data so we have public void display 

74
00:03:09.540 --> 00:03:12.430
First we need to check if the head is null 

75
00:03:12.720 --> 00:03:15.180
then the linked list is empty so we just need 

76
00:03:15.180 --> 00:03:17.120
to return first check 

77
00:03:17.130 --> 00:03:19.640
If head equal to null Then the linked list is 

78
00:03:19.650 --> 00:03:21.690
empty so we can just return 

79
00:03:21.840 --> 00:03:25.140
Otherwise we need to create a temporary node temp and 

80
00:03:25.150 --> 00:03:26.750
initialised to head node 

81
00:03:27.210 --> 00:03:32.060
So right node Temp equal to head so temp is pointing 

82
00:03:32.060 --> 00:03:35.020
to head and we have to traverse the list print 

83
00:03:35.020 --> 00:03:38.260
the nodes data till we reach the head again so 

84
00:03:38.260 --> 00:03:41.170
we can use a do while loop instead of normal 

85
00:03:41.170 --> 00:03:42.010
while loop 

86
00:03:42.180 --> 00:03:46.250
So we have do while tempt not equal to head 

87
00:03:46.340 --> 00:03:49.620
So first the data will be printed and then temp 

88
00:03:49.630 --> 00:03:51.930
will be moved to the next node and the next 

89
00:03:51.930 --> 00:03:52.900
node will be checked 

90
00:03:52.910 --> 00:03:56.840
And when temp reaches head again the traversal is completed 

91
00:03:56.950 --> 00:04:00.660
So write system dot out dot Println of temp dot 

92
00:04:00.670 --> 00:04:03.890
data and then move temp to next node 

93
00:04:03.980 --> 00:04:06.950
write temp equal to temp dot Next 

94
00:04:07.340 --> 00:04:11.190
So in first iteration so in first iteration print temp 

95
00:04:11.190 --> 00:04:15.000
data so it prints 10 and now temp is moved 

96
00:04:15.010 --> 00:04:19.000
to the next node so temp now points to 2000 

97
00:04:19.230 --> 00:04:21.070
Now check the condition it holds 

98
00:04:21.180 --> 00:04:24.350
So start the next iteration and print the data at 

99
00:04:24.360 --> 00:04:27.890
Address 2000 which is 20 now moved temp to the 

100
00:04:27.890 --> 00:04:28.650
next node 

101
00:04:28.840 --> 00:04:31.320
So now temp is equal to 3000 

102
00:04:31.620 --> 00:04:32.050
Now check 

103
00:04:32.050 --> 00:04:35.160
The condition temp is not equal to head so condition 

104
00:04:35.160 --> 00:04:35.750
holds 

105
00:04:35.960 --> 00:04:40.040
So starting next iteration print the data at Address 3000 

106
00:04:40.040 --> 00:04:43.020
which is 30 and now move temp to the next 

107
00:04:43.020 --> 00:04:43.350
node 

108
00:04:43.740 --> 00:04:45.990
So now temp is equal 1000 

109
00:04:46.130 --> 00:04:50.330
Now check The condition again temp is equal to 1000 which 

110
00:04:50.330 --> 00:04:51.200
is equal to head 

111
00:04:51.450 --> 00:04:54.940
So the condition temp not equal to head fails and control 

112
00:04:54.940 --> 00:04:56.170
comes out of the loop 

113
00:04:56.740 --> 00:04:59.800
So that is how we can print each nodes data 

114
00:04:59.810 --> 00:05:01.480
in a circular linked list 

115
00:05:01.490 --> 00:05:05.060
The only difference is that since the last node is pointing 

116
00:05:05.060 --> 00:05:08.360
the head and not null we have to Traverse from 

117
00:05:08.360 --> 00:05:10.590
head till we reach the head again 

118
00:05:10.670 --> 00:05:13.750
And not till we reach any node pointing to null 

119
00:05:14.240 --> 00:05:16.750
So that's all and thank you for watching this video 

