WEBVTT

1
00:00:00.240 --> 00:00:03.130
instead of Max heap we can use min heap to 

2
00:00:03.130 --> 00:00:06.780
solve this problem with less time complexity Let us 

3
00:00:06.780 --> 00:00:10.450
see how Let us take this array of size seven 

4
00:00:10.750 --> 00:00:17.770
with elements 421896 and 5 and the value of 

5
00:00:17.780 --> 00:00:18.950
k as three 

6
00:00:19.540 --> 00:00:23.200
Now we to find the top three elements from this array

7
00:00:24.040 --> 00:00:27.050
we can find it by following this procedure 

8
00:00:27.640 --> 00:00:31.090
First create a min heap for the first K elements 

9
00:00:31.410 --> 00:00:36.210
that is create min heap for first three elements four 

10
00:00:36.220 --> 00:00:37.450
two and one 

11
00:00:38.140 --> 00:00:40.890
The initial tree will look something like this 

12
00:00:41.540 --> 00:00:45.610
After applying the heapify process the value one will 

13
00:00:45.610 --> 00:00:47.930
come to the top of the heap as it is 

14
00:00:47.930 --> 00:00:49.150
the smallest element 

15
00:00:49.840 --> 00:00:54.080
So the first step is over next we need to compare 

16
00:00:54.090 --> 00:00:57.490
the remaining elements with the root nodes value if it 

17
00:00:57.490 --> 00:01:00.690
is greater than the root replaced the value and called 

18
00:01:00.690 --> 00:01:02.350
the heapify process again 

19
00:01:02.940 --> 00:01:06.160
Otherwise we can simply skip and proceed with the 

20
00:01:06.160 --> 00:01:10.620
next element for example compared the Element eight with the 

21
00:01:10.620 --> 00:01:13.930
value of root it is greater than root so replace 

22
00:01:13.930 --> 00:01:16.620
it and then called the heapify process 

23
00:01:16.930 --> 00:01:19.980
Now the value two will come to the top of 

24
00:01:19.990 --> 00:01:23.400
the heap now compared the next element nine 

25
00:01:23.410 --> 00:01:26.120
With the value of root it is greater than root 

26
00:01:26.130 --> 00:01:28.480
so replace it and then called the heapify 

27
00:01:28.480 --> 00:01:31.850
process now the value four will come to 

28
00:01:31.850 --> 00:01:35.710
the top of the heap similarly compared the next element 

29
00:01:35.710 --> 00:01:37.150
six with value of four 

30
00:01:37.540 --> 00:01:40.870
It is also greater than root so replace it and 

31
00:01:40.870 --> 00:01:42.670
then called the heapify process 

32
00:01:42.930 --> 00:01:46.520
Since it is in correct min heap order the value six 

33
00:01:46.520 --> 00:01:50.050
will remain at the top of the heap and finally 

34
00:01:50.130 --> 00:01:53.360
compared the last Element five with value of root 

35
00:01:53.600 --> 00:01:56.110
It is lesser than root so we can skip the 

36
00:01:56.110 --> 00:01:57.790
process and that's it 

37
00:01:57.880 --> 00:02:00.980
And we can see that the top three values are 

38
00:02:00.980 --> 00:02:03.700
present in the heap and now we can just print 

39
00:02:03.700 --> 00:02:08.150
it and the top three elements are 6 8 and 9

40
00:02:08.540 --> 00:02:11.780
So using this logic we can easily solve the problem 

41
00:02:12.000 --> 00:02:13.700
and the idea is very simple 

42
00:02:13.930 --> 00:02:16.700
Construct  min heap for first K elements 

43
00:02:16.980 --> 00:02:20.640
Next iterate the remaining elements and update the heap 

44
00:02:20.650 --> 00:02:25.200
whenever we find an element with higher value and finally print the values present in the key that's it.

