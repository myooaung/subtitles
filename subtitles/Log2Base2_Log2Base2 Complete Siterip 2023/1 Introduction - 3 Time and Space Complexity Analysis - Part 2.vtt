WEBVTT

1
00:00:00.240 --> 00:00:01.010
Hello friends 

2
00:00:01.640 --> 00:00:04.260
In this video we will learn how to do the 

3
00:00:04.270 --> 00:00:07.550
time and space complexity analysis of loops. 

4
00:00:13.340 --> 00:00:17.360
Here we have an example algorithm with a single for loop.

6
00:00:18.140 --> 00:00:21.890
The first statement here is int i and sum equal 

7
00:00:21.890 --> 00:00:25.390
to zero which is a simple statement and hence it 

8
00:00:25.390 --> 00:00:27.650
will take only one unit of time. 

9
00:00:28.440 --> 00:00:31.670
Next we have for ( i equal to one i less than or 

10
00:00:31.670 --> 00:00:33.710
equal to n and i plus plus )  

11
00:00:34.640 --> 00:00:38.720
And how many iterations will this loop have? Let us suppose 

12
00:00:38.730 --> 00:00:42.170
n equal to a three, then the for loop condition 

13
00:00:42.170 --> 00:00:45.660
will be true for i equal to one, i equal to two

14
00:00:45.670 --> 00:00:48.830
and i equal to three and for i equal to four 

15
00:00:48.840 --> 00:00:52.830
when the condition is checked it will fail. So total 

16
00:00:52.840 --> 00:00:56.800
n plus one (n+1) times this will be executed, n times 

17
00:00:56.810 --> 00:00:59.460
the condition will be true and the next time it 

18
00:00:59.460 --> 00:01:02.460
will fail and the statement inside the for loop will 

19
00:01:02.460 --> 00:01:06.840
execute only n times. In the n plus one (n+1)th iteration 

20
00:01:07.010 --> 00:01:10.620
the for loop condition fails and control will come out. 

21
00:01:10.910 --> 00:01:14.720
So this inner statement sum equal to sum + i 

22
00:01:14.880 --> 00:01:19.010
will be executed only n times and finally we have 

23
00:01:19.010 --> 00:01:22.080
the return sum statement which will take one unit of 

24
00:01:22.080 --> 00:01:26.260
time. So total time taken by this programme t of x

25
00:01:26.260 --> 00:01:30.080
t(x) = 1 + ( n+1 ) + n + 1

26
00:01:30.080 --> 00:01:33.990
that is t of x

27
00:01:34.000 --> 00:01:34.900
t(x) = 2n + 3.

28
00:01:34.980 --> 00:01:37.090
That is, if n equal to one 

29
00:01:37.140 --> 00:01:39.890
the total time will be two into one plus three 

30
00:01:39.890 --> 00:01:43.140
which is five units and if n equal to five. 

31
00:01:43.330 --> 00:01:46.220
Then the total time taken will be to two into five 

32
00:01:46.220 --> 00:01:48.250
plus three which is 13 units. 

33
00:01:48.840 --> 00:01:52.410
So time taken depends on the input value the smaller 

34
00:01:52.410 --> 00:01:54.650
the input the lesser the time taken. 

35
00:01:55.240 --> 00:01:57.830
But how do we say that time complexity here? 

36
00:01:57.900 --> 00:02:01.000
See here we have a polynomial expression and 

37
00:02:01.010 --> 00:02:03.630
if we have a polynomial expression like this 

38
00:02:03.860 --> 00:02:06.610
in general, we will take the largest exponents 

39
00:02:06.790 --> 00:02:09.470
that is the degree of the polynomial as the 

40
00:02:09.470 --> 00:02:14.280
time complexity. And here the largest exponent is

41
00:02:14.280 --> 00:02:14.560
n power 1.  

42
00:02:14.810 --> 00:02:18.770
So the complexity is order of n O(n). Now what about 

43
00:02:18.770 --> 00:02:23.100
the space complexity? Here we have n taking one unit 

44
00:02:23.100 --> 00:02:26.990
of memory, then we have i and sum also requiring 

45
00:02:26.990 --> 00:02:30.510
one unit each and we don't have any other memory 

46
00:02:30.510 --> 00:02:32.220
requirements in this programme. 

47
00:02:32.330 --> 00:02:36.480
So the total memory required s of x s(x) equal to one 

48
00:02:36.480 --> 00:02:39.940
plus one plus one equal to 3 which is a constant. 

49
00:02:40.120 --> 00:02:43.550
So the space complexity is order of one O(1). 

50
00:02:44.440 --> 00:02:47.960
Now let us take another example algorithm which takes a 

51
00:02:47.960 --> 00:02:50.250
one dimensional array as input. 

52
00:02:51.040 --> 00:02:53.450
First let us find the time complexity. 

53
00:02:53.840 --> 00:02:57.710
The first statement will take one unit time and next 

54
00:02:57.710 --> 00:02:58.730
we have the for loop. 

55
00:02:59.140 --> 00:03:02.580
And how many iterations will it have ? Let's suppose  

56
00:03:02.590 --> 00:03:03.650
n equal to three,

57
00:03:04.040 --> 00:03:06.900
then the for loop condition will be true for i equal 

58
00:03:06.900 --> 00:03:11.250
to zero, one and two and for i equal to three 

59
00:03:11.260 --> 00:03:13.790
when the condition is checked it will fail. 

60
00:03:13.800 --> 00:03:17.350
So total n plus one times this will be executed. 

61
00:03:17.740 --> 00:03:20.930
n times the for loop condition will be true and 

62
00:03:20.930 --> 00:03:24.670
the next time it will fail, and the statement inside 

63
00:03:24.670 --> 00:03:27.440
the for loop will execute only n times. 

64
00:03:27.520 --> 00:03:30.210
That is when the for loop condition is true 

65
00:03:30.300 --> 00:03:34.000
the statement inside will be executed. In the n plus one th   

66
00:03:34.000 --> 00:03:37.290
iteration of the for loop the condition will fail 

67
00:03:37.380 --> 00:03:38.920
and control will come out. 

68
00:03:39.340 --> 00:03:42.980
So this inner statement sum equal to sum plus arr 

69
00:03:42.980 --> 00:03:47.450
of i will be executed only n times and finally 

70
00:03:47.460 --> 00:03:50.440
we have the return statement which will also take one 

71
00:03:50.440 --> 00:03:51.250
unit of time. 

72
00:03:51.940 --> 00:03:55.710
So the total time taken t(x) equals to one 

73
00:03:55.710 --> 00:03:59.810
plus n plus one plus n plus one that is 

74
00:04:00.080 --> 00:04:02.350
t(x) = 2n + 3.

75
00:04:02.840 --> 00:04:05.350
And as we just learnt we have to take the 

76
00:04:05.350 --> 00:04:08.110
degree of this polynomial expression and we will get 

77
00:04:08.110 --> 00:04:10.550
the time complexity as order of n O(n). 

78
00:04:11.640 --> 00:04:13.540
So that was the time complexity. 

79
00:04:13.580 --> 00:04:16.250
Now let us discuss about the space complexity. 

80
00:04:16.840 --> 00:04:21.620
Firstly we have function parameters arr[] and n.  

81
00:04:21.630 --> 00:04:24.690
An arr[] is an array of size n, so it will take 

82
00:04:24.700 --> 00:04:27.980
n units of memory. And there is a variable n 

83
00:04:28.200 --> 00:04:30.940
and it will also take one unit of memory. 

84
00:04:31.230 --> 00:04:33.150
So total n plus one.

85
00:04:33.640 --> 00:04:36.670
Next we have the variables i and sum which will 

86
00:04:36.670 --> 00:04:40.450
require one unit of memory each and that's all. So 

87
00:04:40.450 --> 00:04:44.420
that total memory taken here s of x equal to 

88
00:04:44.420 --> 00:04:47.320
s(x) = n + 1 + 1 + 1 that is  

89
00:04:47.320 --> 00:04:48.880
s(x) = n + 3 again 

90
00:04:48.880 --> 00:04:49.840
it is a polynomial.

91
00:04:49.850 --> 00:04:52.290
So what do we do? we find the degree and 

92
00:04:52.300 --> 00:04:52.990
it is one. 

93
00:04:53.240 --> 00:04:57.250
So the space complexity is order of n O(n). Now 

94
00:04:57.250 --> 00:04:58.100
in the same code

95
00:04:58.100 --> 00:05:00.690
let us take one more for loop and analyse its 

96
00:05:00.690 --> 00:05:02.650
space and time complexities. 

97
00:05:02.660 --> 00:05:05.810
So for this new loop for i equal to zero i less than

98
00:05:05.810 --> 00:05:08.610
n and i plus plus it will also have n 

99
00:05:08.610 --> 00:05:12.190
plus one executions. 'n times' the condition will be true 

100
00:05:12.190 --> 00:05:13.800
and one time it will fail. 

101
00:05:14.340 --> 00:05:17.090
So this will be executed n plus one times. 

102
00:05:17.740 --> 00:05:20.570
Now what about the inner statement? it will be 

103
00:05:20.570 --> 00:05:24.060
executed only when the for loop condition is true 

104
00:05:24.190 --> 00:05:25.600
that is n times. 

105
00:05:25.810 --> 00:05:29.620
So the total time taken here will be n units 

106
00:05:29.680 --> 00:05:33.620
So the total time taken is 1 +

107
00:05:33.620 --> 00:05:37.450
 (n+1) + n + (n+1) + n + 1

108
00:05:37.450 --> 00:05:39.850
 that is 4n + 4. 

109
00:05:40.240 --> 00:05:43.310
But again if you say the degree of polynomial is 

110
00:05:43.310 --> 00:05:46.520
still one, so the time complexity is order of n  

111
00:05:46.530 --> 00:05:51.370
again now what about the space complexity? For 

112
00:05:51.370 --> 00:05:51.980
this loop 

113
00:05:51.990 --> 00:05:54.730
it will not take any more memory units because there 

114
00:05:54.730 --> 00:05:56.790
are no new variables or anything. 

115
00:05:56.820 --> 00:05:59.940
So the space complexity will also remain the same. 

116
00:06:00.740 --> 00:06:03.680
So what can we conclude from this example? Say we 

117
00:06:03.680 --> 00:06:07.370
can observe that having a separate loop doesn't make any 

118
00:06:07.370 --> 00:06:09.640
major impact on the time complexity. 

119
00:06:10.140 --> 00:06:13.660
So if an algorithm has n separate loops then the 

120
00:06:13.660 --> 00:06:17.100
loop which takes largest time will be the time complexity 

121
00:06:17.100 --> 00:06:18.050
of the algorithm. 

122
00:06:18.940 --> 00:06:20.640
Now see another example 

123
00:06:20.650 --> 00:06:23.750
Here we have a two dimensional array and a nested 

124
00:06:23.750 --> 00:06:26.740
for loop. So let us find the time complexity first.

125
00:06:26.740 --> 00:06:29.790
The first statement will take just one unit of 

126
00:06:29.790 --> 00:06:33.180
time and next we have the for loop and how 

127
00:06:33.180 --> 00:06:37.200
many iterations will it have? We have for i equal to 

128
00:06:37.200 --> 00:06:40.410
zero i less than n i plus plus. So it will 

129
00:06:40.410 --> 00:06:42.310
have total n iterations. 

130
00:06:42.320 --> 00:06:44.930
That is if n equal to 3 then the condition will 

131
00:06:44.930 --> 00:06:47.190
be true for i equal to zero 

132
00:06:47.200 --> 00:06:49.950
i equal to one and i equal to two, and for 

133
00:06:49.950 --> 00:06:50.880
i equal to three 

134
00:06:50.890 --> 00:06:52.120
the condition will fail. 

135
00:06:52.200 --> 00:06:57.060
So including the failed case check total n + 1 

136
00:06:57.060 --> 00:06:58.950
times this will be executed. 

137
00:06:59.740 --> 00:07:02.450
And what about these inner statements? We have a 

138
00:07:02.450 --> 00:07:06.410
loop inside first and it will be executed whenever the 

139
00:07:06.410 --> 00:07:08.110
outer loop condition is true. 

140
00:07:08.280 --> 00:07:09.820
That is n times. 

141
00:07:10.160 --> 00:07:13.790
So n times this will be executed for i equal to 

142
00:07:13.790 --> 00:07:17.390
zero i equal to one i equal to two up to i equal 

143
00:07:17.390 --> 00:07:19.260
to n. And each time 

144
00:07:19.440 --> 00:07:23.180
how many iterations will it have? it will have iterations 

145
00:07:23.180 --> 00:07:24.070
for j equal to 0 

146
00:07:24.070 --> 00:07:27.110
j equal to 1, j equal to 2 

147
00:07:27.110 --> 00:07:30.120
up to n that is n times the condition will 

148
00:07:30.120 --> 00:07:33.130
be true and one time that is for the n 

149
00:07:33.130 --> 00:07:37.190
plus oneth time it will fail. So total n plus 

150
00:07:37.190 --> 00:07:40.330
one times this will be executed and it will be 

151
00:07:40.330 --> 00:07:44.260
executed for n times by the outer loop. So total 

152
00:07:44.590 --> 00:07:46.000
n into n plus one. 

153
00:07:46.010 --> 00:07:48.480
Now what about this inner most statement? It will 

154
00:07:48.480 --> 00:07:51.970
be executed whenever the inner loop condition is true 

155
00:07:52.150 --> 00:07:55.290
that is n times and n times 

156
00:07:55.290 --> 00:07:58.800
the outer loop will execute the inner loop and n 

157
00:07:58.800 --> 00:07:59.260
times 

158
00:07:59.410 --> 00:08:02.900
the inner loop will be true so n into n 

159
00:08:02.900 --> 00:08:05.160
times this statement will be executed 

160
00:08:05.700 --> 00:08:08.720
So n * n will be the time taken by 

161
00:08:08.720 --> 00:08:09.710
this statement 

162
00:08:10.240 --> 00:08:13.930
And the final return statement will take one unit time 

163
00:08:14.340 --> 00:08:17.710
So total time taken will be t of x equal 

164
00:08:17.710 --> 00:08:21.520
to 1 + ( n+1) + n * ( n+1 ) 

165
00:08:21.520 --> 00:08:25.450
+ n * n + 1 that is 

166
00:08:25.550 --> 00:08:29.000
1 + n + 1 plus, n * n 

167
00:08:29.000 --> 00:08:32.710
n square, plus n * 1  n, plus n * n 

168
00:08:32.720 --> 00:08:36.600
n square plus 1 that is 2 n square + 

169
00:08:36.610 --> 00:08:37.750
2n + 3

170
00:08:38.240 --> 00:08:40.130
So it's a polynomial expression. 

171
00:08:40.440 --> 00:08:42.850
And what do we do now? We find the degree 

172
00:08:42.860 --> 00:08:45.440
and here we have n raised to two and then 

173
00:08:45.440 --> 00:08:46.100
n raised to one. 

174
00:08:46.850 --> 00:08:49.580
So 2 is the degree so the time complexity will 

175
00:08:49.590 --> 00:08:51.020
be order of n square.

176
00:08:51.640 --> 00:08:55.480
So if n equal to 2, total time is 4 and 

177
00:08:55.480 --> 00:08:59.030
if n equal to 5 total time is 25 units 

178
00:08:59.840 --> 00:09:02.040
now that was the time complexity. 

179
00:09:02.050 --> 00:09:05.220
Now what about the space complexity? Here we have a 

180
00:09:05.230 --> 00:09:08.710
two dimensional array, so it will have n rows and 

181
00:09:08.720 --> 00:09:12.700
n columns. So it requires n * n memory units 

182
00:09:12.710 --> 00:09:15.070
that is n square memory units. 

183
00:09:15.440 --> 00:09:18.160
Then we have n which will take one unit 

184
00:09:18.390 --> 00:09:22.050
and then we have i, j and sum each requiring one 

185
00:09:22.050 --> 00:09:22.950
unit of memory. 

186
00:09:23.440 --> 00:09:27.270
So that total memory required s of x equal to  

187
00:09:27.270 --> 00:09:30.970
n square + 1 + 1 + 1 + 1 that 

188
00:09:30.970 --> 00:09:34.640
is n square + 4. Again it's a polynomial and 

189
00:09:34.640 --> 00:09:38.680
we have the degree 2, so the space complexity 

190
00:09:38.680 --> 00:09:40.850
will be equal to order of n square. 

191
00:09:41.340 --> 00:09:43.230
Now see another example, 

192
00:09:43.400 --> 00:09:46.850
here we have a two dimensional array and nested triple 

193
00:09:46.850 --> 00:09:47.420
for loop.

194
00:09:48.040 --> 00:09:51.240
So let us find the time complexity of this algorithm first.

195
00:09:51.240 --> 00:09:55.110
The first statement will take just one unit of 

196
00:09:55.110 --> 00:09:55.460
time 

197
00:09:55.840 --> 00:09:58.700
Next we have the for loop and how many 

198
00:09:58.700 --> 00:09:59.110
iterations 

199
00:09:59.110 --> 00:10:03.730
will it have? We have the outermost loop for ( i equal 

200
00:10:03.730 --> 00:10:06.550
to zero, i less than n, i plus plus ).

201
00:10:07.040 --> 00:10:09.440
So it will have total n iterations,

202
00:10:09.470 --> 00:10:12.210
that is if n equal to 3, the condition will be 

203
00:10:12.210 --> 00:10:15.170
true for i equal to 0, 1 and 2, 

204
00:10:15.450 --> 00:10:18.550
and when i equal to 3 the condition will fail. 

205
00:10:19.240 --> 00:10:23.150
So total n plus one times this will be executed. 

206
00:10:23.540 --> 00:10:28.070
And what about these inner statements? All these statements inside 

207
00:10:28.080 --> 00:10:31.920
will be executed whenever the outer loop condition is true, 

208
00:10:32.090 --> 00:10:33.550
that is n times. 

209
00:10:34.040 --> 00:10:36.780
So n times all these will be executed. 

210
00:10:36.950 --> 00:10:41.780
That is for i equal to 0, 1, 2 up to n. And inside 

211
00:10:41.790 --> 00:10:42.270
first 

212
00:10:42.270 --> 00:10:43.450
we have a for loop. 

213
00:10:44.040 --> 00:10:48.150
And how many iterations will it have? It will have 

214
00:10:48.160 --> 00:10:49.650
iterations for ( j equal to 0, 

215
00:10:49.650 --> 00:10:52.880
j equal to 1, j equal to 2 

216
00:10:53.090 --> 00:10:55.200
up to j equal to n-1.

217
00:10:55.530 --> 00:10:57.500
when j equal to n it will fail. 

218
00:10:58.240 --> 00:11:01.270
That is n times the condition will be true and 

219
00:11:01.270 --> 00:11:04.470
one time that is for the n plus one time 

220
00:11:04.510 --> 00:11:07.990
it will fail. So total n plus one times this 

221
00:11:07.990 --> 00:11:11.410
will be executed and it will be executed for n 

222
00:11:11.410 --> 00:11:13.140
times by the outer loop. 

223
00:11:13.320 --> 00:11:15.850
So total n into n plus one. 

224
00:11:16.540 --> 00:11:19.610
And what about the statements inside the second for loop? 

225
00:11:20.440 --> 00:11:21.730
it will be executed 

226
00:11:22.050 --> 00:11:24.310
when the second for loop condition is true 

227
00:11:24.400 --> 00:11:27.990
that is n times, and inside we have a for 

228
00:11:27.990 --> 00:11:28.250
loop 

229
00:11:28.640 --> 00:11:32.020
and how many iterations will it have? It will have 

230
00:11:32.030 --> 00:11:33.260
n iterations 

231
00:11:33.270 --> 00:11:35.970
That is for k equal to 0, k equal to 1, 

232
00:11:35.980 --> 00:11:39.270
up to k equal to n-1 and for

233
00:11:39.400 --> 00:11:40.600
k equal to n,

234
00:11:40.610 --> 00:11:41.790
the condition will fail.

235
00:11:42.150 --> 00:11:44.750
That is n times the condition will be true 

236
00:11:44.900 --> 00:11:47.430
and for the n plus one time the condition will 

237
00:11:47.440 --> 00:11:47.870
fail. 

238
00:11:48.240 --> 00:11:51.550
So total n plus one times this will be executed 

239
00:11:51.840 --> 00:11:54.700
and it will be executed for n times by the 

240
00:11:54.700 --> 00:11:58.290
second for loop and n times by the outermost for 

241
00:11:58.290 --> 00:12:01.800
loop. So total n * n * 

242
00:12:01.800 --> 00:12:02.650
(n+1) times. 

243
00:12:03.040 --> 00:12:05.930
Now what about this inner most statement? It will 

244
00:12:05.930 --> 00:12:09.350
be executed whenever the innermost loop condition is true. 

245
00:12:09.840 --> 00:12:14.300
That is n times. So n times the outermost loop 

246
00:12:14.300 --> 00:12:17.300
will execute the inner loop and n times 

247
00:12:17.300 --> 00:12:19.990
the inner loop will be true and it executes the 

248
00:12:20.000 --> 00:12:22.320
innermost loop and n times 

249
00:12:22.320 --> 00:12:23.150
it will be true, 

250
00:12:23.840 --> 00:12:27.650
just as we discussed. So n * n * n

251
00:12:27.650 --> 00:12:28.170
times 

252
00:12:28.180 --> 00:12:29.950
this statement will be executed. 

253
00:12:29.960 --> 00:12:33.750
Now the final returns statement will take one unit time, 

254
00:12:34.140 --> 00:12:37.320
so total time taken will be t of x equal to 

255
00:12:37.320 --> 00:12:41.060
1 + (n+1) + n *

256
00:12:41.060 --> 00:12:44.220
(n+1) + n * n * (n+1)

257
00:12:44.230 --> 00:12:47.770
+ n * n * n + 1 that is 

258
00:12:47.930 --> 00:12:51.300
1 + n + 1 + n * n = n square plus

259
00:12:51.300 --> 00:12:54.950
n * 1 = n plus n * n *

260
00:12:54.950 --> 00:12:58.250
n = n cube plus n * n * one =

261
00:12:58.410 --> 00:13:02.210
n square plus n * n * n = n cube

262
00:13:02.220 --> 00:13:06.530
plus one that is 2 n cube + 2n 

263
00:13:06.530 --> 00:13:09.050
square + 2n + 3.

264
00:13:09.740 --> 00:13:11.670
And again it's a polynomial expression 

265
00:13:11.670 --> 00:13:13.950
So what do we do? we find the degree and 

266
00:13:13.950 --> 00:13:17.660
here we have n cube, n square, and n raised to 

267
00:13:17.660 --> 00:13:18.050
one. 

268
00:13:18.540 --> 00:13:21.090
So 3 is the degree here, so we can say 

269
00:13:21.100 --> 00:13:25.230
the time complexity of this algorithm is order of 

270
00:13:25.230 --> 00:13:26.440
n cube .

271
00:13:26.440 --> 00:13:28.370
So that was the time complexity. 

272
00:13:28.630 --> 00:13:31.510
Now what about the space complexity? Here we have 

273
00:13:31.510 --> 00:13:32.360
a 2D array, 

274
00:13:32.550 --> 00:13:35.340
so it will have n rows and n columns. So it 

275
00:13:35.340 --> 00:13:39.120
requires an n * n memory units that is n square 

276
00:13:39.120 --> 00:13:40.020
memory units. 

277
00:13:40.610 --> 00:13:43.460
Then we have n which will require one unit of 

278
00:13:43.470 --> 00:13:44.060
memory, 

279
00:13:44.190 --> 00:13:48.020
and then we have i, j, k and sum each 

280
00:13:48.020 --> 00:13:49.850
requiring one unit of memory. 

281
00:13:50.440 --> 00:13:55.950
So total memory required is n square + 5. Again 

282
00:13:55.950 --> 00:13:56.960
it is a polynomial,

283
00:13:56.960 --> 00:13:59.230
so if we find the degree and we got degree 

284
00:13:59.230 --> 00:14:03.320
equal to 2 here. So space complexity of this algorithm 

285
00:14:03.330 --> 00:14:05.090
is order of n square. 

286
00:14:05.940 --> 00:14:08.570
So that is how we can find the time and 

287
00:14:08.570 --> 00:14:12.020
space complexities of algorithms with loops. 

288
00:14:12.640 --> 00:14:16.200
And we understood that the time complexity of a loop 

289
00:14:16.300 --> 00:14:19.380
is actually equal to the number of times the innermost 

290
00:14:19.380 --> 00:14:21.450
statement is to be executed. 

291
00:14:22.040 --> 00:14:24.940
That is in the last example we saw that the 

292
00:14:24.940 --> 00:14:29.430
innermost statement executed n * n * n times and 

293
00:14:29.430 --> 00:14:32.520
hence we got the time complexity order of n cube.

294
00:14:32.560 --> 00:14:35.940
And even if you have separate loops in your algorithm 

295
00:14:36.140 --> 00:14:38.820
it really doesn't make a major impact on the time 

296
00:14:38.820 --> 00:14:39.580
complexity. 

297
00:14:40.240 --> 00:14:43.730
And if you have n separate loops, the loop which 

298
00:14:43.730 --> 00:14:47.240
takes the largest time will be the time complexity of 

299
00:14:47.250 --> 00:14:48.320
the whole algorithm. 

300
00:14:48.650 --> 00:14:52.030
For example if your algorithm has a simple for loop 

301
00:14:52.040 --> 00:14:55.490
and a nested triple for loop then the time complexity 

302
00:14:55.490 --> 00:14:58.750
of that algorithm will be order of n cube.

