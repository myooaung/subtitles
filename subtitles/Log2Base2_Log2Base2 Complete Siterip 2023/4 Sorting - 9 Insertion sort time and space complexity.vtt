WEBVTT

1
00:00:00.040 --> 00:00:00.840
Hi friends 

2
00:00:00.890 --> 00:00:04.390
In this video let us analyse the time and space 

3
00:00:04.390 --> 00:00:07.150
complexity of the insertion sort algorithm 

4
00:00:07.840 --> 00:00:11.550
In the previous videos we have learnt about insertion sort 

5
00:00:11.560 --> 00:00:12.870
and how to implement it 

6
00:00:13.150 --> 00:00:16.930
so let us analyse the time complexity first and let us 

7
00:00:16.940 --> 00:00:19.550
assume that the array of size is five 

8
00:00:20.540 --> 00:00:23.330
let us see the best case first and the best 

9
00:00:23.330 --> 00:00:26.820
case here will be the array elements are already 

10
00:00:26.820 --> 00:00:27.350
sorted 

11
00:00:28.440 --> 00:00:31.370
so let us see how much time it takes in this best 

12
00:00:31.370 --> 00:00:31.810
case 

13
00:00:32.440 --> 00:00:35.510
So for the outer loop when i equal to one the 

14
00:00:35.510 --> 00:00:36.700
condition will be true 

15
00:00:36.890 --> 00:00:39.770
So it will go inside and check the while loop 

16
00:00:39.770 --> 00:00:40.450
condition 

17
00:00:40.840 --> 00:00:43.640
And when the while loop condition is checked that is 

18
00:00:43.900 --> 00:00:47.440
if first element is greater than the second one it 

19
00:00:47.440 --> 00:00:48.050
will fail 

20
00:00:48.640 --> 00:00:51.370
So this condition will be checked and it will be 

21
00:00:51.370 --> 00:00:51.960
failed 

22
00:00:52.100 --> 00:00:56.320
So the inner statements will be skipped in the next 

23
00:00:56.320 --> 00:00:57.870
iteration of outer loop 

24
00:00:57.990 --> 00:00:59.650
That is when i equal to two 

25
00:00:59.700 --> 00:01:04.260
Then also while loop will fail while comparing second and 

26
00:01:04.270 --> 00:01:07.940
third elements in the next iteration of outer loop that 

27
00:01:07.940 --> 00:01:10.850
is when i equal to three then also the while loop 

28
00:01:10.850 --> 00:01:15.730
condition will fail while comparing 3rd and 4th elements in 

29
00:01:15.730 --> 00:01:18.600
the next iteration when i equal to four 

30
00:01:18.820 --> 00:01:22.830
Then also the while loop condition will fail since Fourth 

31
00:01:22.970 --> 00:01:25.650
Element is not greater than fifth element 

32
00:01:26.240 --> 00:01:30.160
And in next iteration when i equal to five the condition 

33
00:01:30.160 --> 00:01:32.950
will fail and the execution will be stopped 

34
00:01:34.040 --> 00:01:37.180
So we can see that for five elements which were 

35
00:01:37.190 --> 00:01:40.980
already in sorted order we needed four which is five 

36
00:01:40.980 --> 00:01:42.850
minus one comparisons only 

37
00:01:43.340 --> 00:01:47.780
So in general for end sorted elements we require only 

38
00:01:47.790 --> 00:01:49.540
n minus one comparisons 

39
00:01:50.140 --> 00:01:53.420
So the best case time complexity of insertion sort 

40
00:01:53.430 --> 00:01:57.770
algorithm is order of n So that was the best 

41
00:01:57.770 --> 00:01:58.230
case 

42
00:01:58.380 --> 00:02:00.650
And now let us talk about the worst case 

43
00:02:01.140 --> 00:02:04.270
So when will be the worst case happening here The 

44
00:02:04.270 --> 00:02:07.860
worst case is when the elements are in descending order and 

45
00:02:07.860 --> 00:02:11.450
we have to make it in ascending order so let us see 

46
00:02:12.140 --> 00:02:15.260
So for the outer loop when i equal to one the 

47
00:02:15.270 --> 00:02:18.250
inner while loop condition will be checked and it will 

48
00:02:18.250 --> 00:02:22.410
be true that is to compare 1st and 2nd elements 

49
00:02:22.480 --> 00:02:24.180
and they are not in the right order 

50
00:02:24.550 --> 00:02:27.680
So while condition will be true and the swapping will 

51
00:02:27.680 --> 00:02:31.610
be performed and next when while is checked I would 

52
00:02:31.610 --> 00:02:34.650
be equal to zero Hence the condition will fail 

53
00:02:35.540 --> 00:02:38.440
So in the first iteration of outer for loop the 

54
00:02:38.440 --> 00:02:43.430
inner loop statement executed one time next when I equal

55
00:02:43.430 --> 00:02:46.530
to 2 first while will be checked and it will 

56
00:02:46.530 --> 00:02:47.030
be true 

57
00:02:47.040 --> 00:02:49.050
So inner statements will be executed 

58
00:02:49.540 --> 00:02:53.050
Then in second iteration of while loop it will still 

59
00:02:53.060 --> 00:02:56.050
be true and the inner statements will be executed 

60
00:02:56.440 --> 00:02:59.180
And in third iteration of while loop I would be 

61
00:02:59.180 --> 00:03:00.950
equal to zero so it will fail 

62
00:03:01.640 --> 00:03:05.540
So in the second iteration of outer for loop the 

63
00:03:05.550 --> 00:03:10.840
inner loop statement executed two times Next when I equal 

64
00:03:10.840 --> 00:03:13.520
to three first while will be checked and it will 

65
00:03:13.520 --> 00:03:14.090
be true 

66
00:03:14.100 --> 00:03:17.470
So inner statements will be executed and in second 

67
00:03:17.470 --> 00:03:20.460
iteration of while loop it will still be true 

68
00:03:20.470 --> 00:03:24.080
So inner statements will again be executed and in 

69
00:03:24.080 --> 00:03:27.320
third iteration of while loop the while condition will still 

70
00:03:27.320 --> 00:03:27.850
be true 

71
00:03:28.140 --> 00:03:31.350
So again the inner statements will be executed and in 

72
00:03:31.350 --> 00:03:34.650
fourth iteration of while loop I will be equal to 

73
00:03:34.650 --> 00:03:37.960
zero so it will fail so we can say in 

74
00:03:37.960 --> 00:03:41.510
third iteration of the outer for loop the inner loop 

75
00:03:41.510 --> 00:03:48.110
statement executed three times next when i equal to three First 

76
00:03:48.120 --> 00:03:49.600
as usual while will be checked 

77
00:03:49.610 --> 00:03:50.390
It will be true 

78
00:03:50.400 --> 00:03:52.350
So inner statements will be executed 

79
00:03:52.840 --> 00:03:55.650
And in second iteration of while loop again it will 

80
00:03:55.650 --> 00:03:56.120
be true 

81
00:03:56.130 --> 00:03:59.170
So inner statements will be executed and in third 

82
00:03:59.170 --> 00:03:59.720
iteration 

83
00:03:59.730 --> 00:04:01.640
Also the condition will be true 

84
00:04:01.810 --> 00:04:05.010
So inner statements will be executed and in fourth 

85
00:04:05.010 --> 00:04:05.540
iteration 

86
00:04:05.540 --> 00:04:07.750
Also the while condition will be true 

87
00:04:07.990 --> 00:04:11.260
So inner statements will be executed and in fifth 

88
00:04:11.270 --> 00:04:14.960
iteration of while loop I will become zero so the 

89
00:04:14.960 --> 00:04:18.780
condition will fail so we can say in fourth iteration 

90
00:04:18.780 --> 00:04:22.870
of outer for loop the inner loop statement executed four 

91
00:04:22.870 --> 00:04:23.450
times 

92
00:04:23.840 --> 00:04:27.440
Next when I equal to five the outer for loop 

93
00:04:27.440 --> 00:04:31.850
condition it will fail so it will stop its execution 

94
00:04:32.440 --> 00:04:36.140
So when size equal to five the total time taken 

95
00:04:36.140 --> 00:04:39.400
is t of X equal to one plus two plus 

96
00:04:39.410 --> 00:04:42.630
three plus four that is five minus one which is 

97
00:04:42.670 --> 00:04:43.900
size minus one 

98
00:04:44.640 --> 00:04:48.290
So in general when size equal to n we will 

99
00:04:48.290 --> 00:04:48.900
have t(x) 

100
00:04:48.900 --> 00:04:52.300
equal to one plus two plus three Plus 

101
00:04:52.310 --> 00:04:54.530
etc plus n minus one 

102
00:04:55.290 --> 00:04:57.760
And we know that the sum of natural numbers from 

103
00:04:57.760 --> 00:05:00.850
1 to n is n into n plus one by two 

104
00:05:01.340 --> 00:05:04.470
But here the last number is n minus one 

105
00:05:04.940 --> 00:05:08.250
So we have to replace n as n minus one 

106
00:05:08.740 --> 00:05:13.020
So the equation will become n minus one into n 

107
00:05:13.020 --> 00:05:15.670
minus one plus one divided by two 

108
00:05:16.130 --> 00:05:18.850
And this minus one plus one will get cancelled 

109
00:05:19.070 --> 00:05:22.830
So this will become n minus one into n 

110
00:05:22.880 --> 00:05:27.280
Divided by two that is n square minus n whole 

111
00:05:27.280 --> 00:05:28.350
divided by two 

112
00:05:28.740 --> 00:05:30.430
So we got the time required 

113
00:05:30.440 --> 00:05:33.440
Now how can we get the time complexity Here We 

114
00:05:33.440 --> 00:05:36.580
just have to find the highest exponential and it is 

115
00:05:36.590 --> 00:05:37.650
n square here 

116
00:05:38.140 --> 00:05:42.080
So the worst case time complexity of insertion sort is  

117
00:05:42.080 --> 00:05:43.140
order of n square 

118
00:05:43.410 --> 00:05:46.550
So that was the time complexity and analysis of insertion 

119
00:05:46.550 --> 00:05:46.950
sort 

120
00:05:47.300 --> 00:05:50.040
Now let us do the space complexity analysis 

121
00:05:50.260 --> 00:05:54.090
So space complexity is a total amount of space a 

122
00:05:54.090 --> 00:05:57.150
particular algorithm takes to produce the output 

123
00:05:57.740 --> 00:06:01.200
So here array arr takes n units of 

124
00:06:01.200 --> 00:06:06.560
memory and size will take one unit and I value 

125
00:06:06.570 --> 00:06:07.420
and index 

126
00:06:07.580 --> 00:06:09.780
Each will take one unit of memory 

127
00:06:10.050 --> 00:06:13.430
So the total space S(X) is equal to n 

128
00:06:13.430 --> 00:06:16.300
plus four and it is a polynomial and the 

129
00:06:16.300 --> 00:06:20.300
degree is one so the space complexity will be order of 

130
00:06:20.310 --> 00:06:23.590
n so that was the space complexity 

131
00:06:23.820 --> 00:06:27.690
let us discuss about the auxillary space complexity so 

132
00:06:27.690 --> 00:06:31.080
as we learned auxillary space is the extra space 

133
00:06:31.090 --> 00:06:33.750
or temporary space use by an algorithm 

134
00:06:34.240 --> 00:06:38.250
So here the array arr and size are given input 

135
00:06:38.640 --> 00:06:43.090
The extra memory used by this insertion sort algorithm is 

136
00:06:43.300 --> 00:06:45.940
for I value and index 

137
00:06:46.330 --> 00:06:50.070
So one unit of space for I one for value 

138
00:06:50.080 --> 00:06:51.350
and one for index 

139
00:06:51.680 --> 00:06:55.350
So total auxillary space is equal to three units 

140
00:06:56.340 --> 00:06:59.250
Since it is a constant value we can say The 

141
00:06:59.250 --> 00:07:03.380
auxillary Space complexity of this algorithm is order of 

142
00:07:03.380 --> 00:07:03.650
one 

143
00:07:04.540 --> 00:07:07.560
And we know that if a sorting algorithm sorts all 

144
00:07:07.560 --> 00:07:11.210
the elements without using any extra memory or sorts all 

145
00:07:11.210 --> 00:07:15.080
the elements with auxillary Space Complexity as order of 

146
00:07:15.080 --> 00:07:18.480
one then we can call that sorting algorithm as an 

147
00:07:18.520 --> 00:07:20.050
in place sorting algorithm 

148
00:07:20.540 --> 00:07:25.030
So by that definition here insertion sort is definitely as inplace sorting algorithm. 

