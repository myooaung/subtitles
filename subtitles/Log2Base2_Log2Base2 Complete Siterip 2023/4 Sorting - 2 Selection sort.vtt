WEBVTT

1
00:00:00.140 --> 00:00:00.960
Hello friends 

2
00:00:01.020 --> 00:00:04.690
In this video let us learn how selection sort algorithm 

3
00:00:04.690 --> 00:00:06.350
works in step by step 

4
00:00:06.840 --> 00:00:10.600
In the previous video we have learned how selection sort 

5
00:00:10.600 --> 00:00:13.230
works and designed an algorithm for it 

6
00:00:13.450 --> 00:00:16.740
So as we know the selection sort algorithm will find 

7
00:00:16.750 --> 00:00:21.320
the minimum or maximum element in each iteration and places 

8
00:00:21.320 --> 00:00:22.800
it in the correct position 

9
00:00:23.010 --> 00:00:26.100
So in this video let us learn how selection 

10
00:00:26.100 --> 00:00:29.550
sort algorithm works in step by step So we have 

11
00:00:29.550 --> 00:00:32.870
the function selection sort which takes the array to be 

12
00:00:32.870 --> 00:00:35.920
sorted and its size as input parameters 

13
00:00:36.100 --> 00:00:39.440
So we have an array of size five with elements 

14
00:00:39.560 --> 00:00:44.840
180 165 150 170 and 145 

15
00:00:44.940 --> 00:00:47.950
We are going to sort this array and here we

16
00:00:47.950 --> 00:00:49.250
Will use nested for loop 

17
00:00:49.440 --> 00:00:52.900
where the inner for loop will find the minimum element 

18
00:00:52.910 --> 00:00:56.180
in the array and places it in the right position and 

19
00:00:56.180 --> 00:00:58.630
the outer loop will execute the inner loop 

20
00:00:58.630 --> 00:01:01.150
 size minus one times So let us  

21
00:01:01.150 --> 00:01:02.350
See how it works 

22
00:01:02.940 --> 00:01:06.950
First we're declaring i and j and in first iteration of 

23
00:01:06.960 --> 00:01:10.770
outer loop i is equal to zero and inside we have 

24
00:01:10.770 --> 00:01:14.640
the inner for loop and here in first iteration J 

25
00:01:14.640 --> 00:01:17.710
equal to I place one that is zero plus one 

26
00:01:17.710 --> 00:01:18.840
which is equal to one 

27
00:01:19.160 --> 00:01:20.630
And now we have 

28
00:01:20.960 --> 00:01:24.980
If arr of I greater than arr of J that 

29
00:01:24.980 --> 00:01:27.400
is we are checking if element at 

30
00:01:27.410 --> 00:01:31.330
Index I is greater than element at Index J and 

31
00:01:31.330 --> 00:01:34.620
we have 180 greater than 165 

32
00:01:34.820 --> 00:01:36.690
That is the element at Index 

33
00:01:36.700 --> 00:01:38.260
I is not the minimum 

34
00:01:38.350 --> 00:01:40.530
So we need to swap these elements 

35
00:01:40.650 --> 00:01:44.030
That is we're finding the minimum element from this array 

36
00:01:44.060 --> 00:01:47.500
and bringing it to the index I in every iteration 

37
00:01:47.610 --> 00:01:51.440
So 180 165 are swap now in the next 

38
00:01:51.440 --> 00:01:53.450
iteration J is equal to two 

39
00:01:53.460 --> 00:01:56.970
And we have if arr of I greater than arr 

40
00:01:56.970 --> 00:02:00.940
of J that is if 165 greater than 150

41
00:02:00.940 --> 00:02:04.930
150 and it is so swap them now in the next 

42
00:02:04.930 --> 00:02:05.660
iteration 

43
00:02:05.670 --> 00:02:07.050
j is equal to three 

44
00:02:07.440 --> 00:02:11.190
And we have if arr of I greater than arr 

45
00:02:11.190 --> 00:02:15.330
of J that is if 150 greater than 

46
00:02:15.330 --> 00:02:16.020
170 

47
00:02:16.030 --> 00:02:17.610
But it is not so 

48
00:02:17.620 --> 00:02:21.130
If fails that is still the element at index 

49
00:02:21.140 --> 00:02:24.140
I is minimum so we don't need to swap now 

50
00:02:24.140 --> 00:02:27.260
In the next iteration j is equal to four and we 

51
00:02:27.260 --> 00:02:27.750
have 

52
00:02:27.940 --> 00:02:32.030
If arr of I greater than arr of J that 

53
00:02:32.030 --> 00:02:36.550
is if 150 is greater than 145 and 

54
00:02:36.560 --> 00:02:38.190
it is so swap them 

55
00:02:38.280 --> 00:02:41.360
So 150 145 are now swap 

56
00:02:41.570 --> 00:02:44.650
Now in the next iteration j is equal to five 

57
00:02:45.040 --> 00:02:49.050
But now the condition j less than size fails 

58
00:02:49.440 --> 00:02:52.720
So control comes out of the inner for loop and 

59
00:02:52.720 --> 00:02:55.980
the first iteration of outer loop is now completed 

60
00:02:56.270 --> 00:02:59.390
Now the minimum element of this array is brought to the 

61
00:02:59.390 --> 00:03:00.390
first position 

62
00:03:00.530 --> 00:03:02.610
That is it's right position 

63
00:03:02.710 --> 00:03:05.480
That is it is sorted now So from now we 

64
00:03:05.480 --> 00:03:06.750
don't need to consider 

65
00:03:06.840 --> 00:03:10.010
But we will repeat the process for the remaining elements 

66
00:03:10.240 --> 00:03:14.700
That is after first iteration the element at first index 

67
00:03:14.710 --> 00:03:17.720
is sorted and that is why we have the initial 

68
00:03:17.720 --> 00:03:21.810
-isation J equal to I place one in every iteration 

69
00:03:21.810 --> 00:03:22.490
the elements 

70
00:03:22.490 --> 00:03:25.740
Still I will be sorted now In the second iteration 

71
00:03:25.750 --> 00:03:29.130
I equal to one and inside we have the inner 

72
00:03:29.130 --> 00:03:30.140
loop and J 

73
00:03:30.150 --> 00:03:32.820
equal to I plus one that is one plus one 

74
00:03:32.820 --> 00:03:35.910
which is equal to two and we have if arr of i

75
00:03:35.920 --> 00:03:39.800
greater than arr of J that is if 180 

76
00:03:39.800 --> 00:03:41.590
greater than 165 

77
00:03:41.600 --> 00:03:44.930
And it is so swap them now in the next 

78
00:03:44.930 --> 00:03:46.950
iteration j is equal to three 

79
00:03:47.040 --> 00:03:50.480
And we have If arr of I greater than arr 

80
00:03:50.480 --> 00:03:54.100
of J that is if 165 is greater than 

81
00:03:54.100 --> 00:03:54.960
170 

82
00:03:55.230 --> 00:03:56.260
But it is not 

83
00:03:56.270 --> 00:03:57.900
That is element at index 

84
00:03:57.910 --> 00:04:01.030
I still the minimum value so we don't need to 

85
00:04:01.030 --> 00:04:01.460
swap 

86
00:04:01.610 --> 00:04:04.670
And remember we are not considering the index zero now 

87
00:04:05.000 --> 00:04:06.450
It is already sorted 

88
00:04:06.840 --> 00:04:09.520
It is the sorted part of the array We are dealing 

89
00:04:09.520 --> 00:04:11.450
with the Unsorted part only 

90
00:04:12.140 --> 00:04:15.380
So now in the next iteration j is equal to four 

91
00:04:15.600 --> 00:04:19.070
And we have if arr of I greater than arr 

92
00:04:19.070 --> 00:04:23.200
of J that is if 165 is greater than 

93
00:04:23.200 --> 00:04:26.500
150 and it is that is we have found an 

94
00:04:26.510 --> 00:04:29.650
element which is smaller than the Element at Index I

95
00:04:30.340 --> 00:04:33.980
So swap them now in the next iteration j is equal 

96
00:04:33.980 --> 00:04:34.480
to five 

97
00:04:34.490 --> 00:04:38.010
But now the conditions j less than size fails so 

98
00:04:38.010 --> 00:04:40.920
control comes out of the inner for loop and second 

99
00:04:40.920 --> 00:04:43.410
iteration of Outer Loop is now completed 

100
00:04:43.730 --> 00:04:48.050
Now the minimum element of the unsorted part is found 

101
00:04:48.100 --> 00:04:52.110
and brought to its right position Now the elements at 

102
00:04:52.120 --> 00:04:55.420
index Zero and Index one are sorted that 

103
00:04:55.420 --> 00:04:58.340
is this is the sorted part and the remaining is the 

104
00:04:58.350 --> 00:04:59.350
unsorted part 

105
00:04:59.630 --> 00:05:03.060
Now in the next iteration of outer loop i Equal to 

106
00:05:03.060 --> 00:05:03.350
two 

107
00:05:04.140 --> 00:05:08.130
So in Inner loop first iteration j is equal to two 

108
00:05:08.140 --> 00:05:12.210
plus one that is three and we have if arr 

109
00:05:12.210 --> 00:05:16.430
of i greater than arr of J that is if 180

110
00:05:16.430 --> 00:05:21.310
180 greater and 170 it is so swap them 

111
00:05:21.310 --> 00:05:24.250
180 170 are now swapped

112
00:05:25.140 --> 00:05:28.010
Now in the next iteration j is equal to four 

113
00:05:28.370 --> 00:05:32.350
And we have if arr of I greater than arr 

114
00:05:32.350 --> 00:05:36.370
of J that is if 170 is greater than 165 

115
00:05:36.370 --> 00:05:39.990
165 and it is so we have found a much 

116
00:05:39.990 --> 00:05:42.550
smaller element so we have to swap them 

117
00:05:42.740 --> 00:05:45.950
So these are swapped and now in the next iteration 

118
00:05:45.950 --> 00:05:47.250
j is equal to five 

119
00:05:47.640 --> 00:05:51.510
But now the condition j less than size fails so control 

120
00:05:51.510 --> 00:05:54.790
comes out of the inner for loop and this iteration 

121
00:05:54.790 --> 00:05:57.050
of outer loop is also completed 

122
00:05:57.350 --> 00:06:01.110
Now the minimum element of unsorted part is found and brought 

123
00:06:01.120 --> 00:06:02.420
to its right position 

124
00:06:02.560 --> 00:06:06.830
Now the elements at Index zero index one and index 

125
00:06:06.830 --> 00:06:07.750
two are sorted 

126
00:06:08.140 --> 00:06:10.880
Now we have to sort the remaining part of the array

127
00:06:11.060 --> 00:06:14.420
so in the next iteration i equal to a three and 

128
00:06:14.430 --> 00:06:18.000
in inner loop first iteration J equal to three plus 

129
00:06:18.000 --> 00:06:19.180
one that is four 

130
00:06:19.440 --> 00:06:23.380
And we have If arr of I greater than arr 

131
00:06:23.380 --> 00:06:27.540
of J that is if 180 is greater than 

132
00:06:27.540 --> 00:06:30.610
170 and it is so swap them 

133
00:06:30.820 --> 00:06:33.650
So 180 170 are now swapped 

134
00:06:33.930 --> 00:06:36.560
Now in the next iteration j equal to 5 

135
00:06:36.760 --> 00:06:40.090
But now the condition fails and control comes out of 

136
00:06:40.100 --> 00:06:41.150
the inner for loop 

137
00:06:41.410 --> 00:06:44.750
And this iteration of outer loop is also completed 

138
00:06:45.440 --> 00:06:48.250
Now in the next iteration i equal to four 

139
00:06:48.840 --> 00:06:52.660
But now the condition i less than size minus one fails 

140
00:06:52.790 --> 00:06:56.390
since size equal to five so size minus one equal to 

141
00:06:56.390 --> 00:06:56.810
four 

142
00:06:57.090 --> 00:06:59.340
And I is also equal to four 

143
00:06:59.550 --> 00:07:02.520
So the condition fails and control comes out of the 

144
00:07:02.520 --> 00:07:02.800
for loop

145
00:07:02.800 --> 00:07:06.270
and we have only one element left now 

146
00:07:06.530 --> 00:07:09.260
and in each iteration what are we doing We are 

147
00:07:09.260 --> 00:07:12.480
taking the minimum element and placing it at its right 

148
00:07:12.480 --> 00:07:13.090
position 

149
00:07:13.260 --> 00:07:16.760
So if we have one element left at last it 

150
00:07:16.760 --> 00:07:20.590
must be the maximum element of the whole array and 

151
00:07:20.730 --> 00:07:22.150
it is at the right position 

152
00:07:23.140 --> 00:07:26.200
So the function is completely executed and we got the 

153
00:07:26.210 --> 00:07:27.050
array sorted 

154
00:07:27.740 --> 00:07:29.990
So this is how selection sort works 

155
00:07:31.140 --> 00:07:34.400
We have to find the minimum element in every iteration 

156
00:07:34.630 --> 00:07:37.250
and we are placing it at its right position .

