WEBVTT

1
00:00:00.140 --> 00:00:02.580
Hi friends In this video we are going to learn 

2
00:00:02.590 --> 00:00:03.880
how to perform inorder 

3
00:00:03.880 --> 00:00:06.050
Traversal on a binary search tree 

4
00:00:06.940 --> 00:00:09.300
So we have a binary search tree here 

5
00:00:09.310 --> 00:00:11.410
And the logic here is very simple 

6
00:00:11.570 --> 00:00:14.390
We shift the left sub tree first followed by the root 

7
00:00:14.400 --> 00:00:17.270
and then the right sub tree so let us see The code 

8
00:00:17.270 --> 00:00:20.550
to implement this and there is a function named

9
00:00:20.550 --> 00:00:23.630
inorder for performing inorder traversal and we passed 

10
00:00:23.630 --> 00:00:25.500
the root of the tree into the function 

11
00:00:26.140 --> 00:00:28.660
So the case 100 here and to the left we 

12
00:00:28.660 --> 00:00:30.780
have 50 and 200 to the right 

13
00:00:31.340 --> 00:00:33.700
So first we want to check if root is null 

14
00:00:33.710 --> 00:00:36.580
But it is not so we Travers the left sub 

15
00:00:36.580 --> 00:00:40.360
tree by recursively calling the function by passing the left 

16
00:00:40.360 --> 00:00:43.270
child of root which is 50 here 

17
00:00:43.440 --> 00:00:46.520
And we pass the note 50 and it's left is 

18
00:00:46.520 --> 00:00:50.040
ten and it's right is 60 again We check if root 

19
00:00:50.040 --> 00:00:53.150
is null But here root is 50 and it is not null 

20
00:00:53.240 --> 00:00:53.490
so 

21
00:00:53.490 --> 00:00:55.630
We want to traverse the left sub tree first 

22
00:00:55.640 --> 00:00:58.560
So we call the function again with the left child 

23
00:00:58.570 --> 00:01:02.370
10 and it's left and right are null and we first 

24
00:01:02.370 --> 00:01:02.670
check 

25
00:01:02.680 --> 00:01:05.020
If root is null but it is not so 

26
00:01:05.020 --> 00:01:07.420
We travels the left side and we call the function 

27
00:01:07.430 --> 00:01:10.510
in order by passing null to the function and in the 

28
00:01:10.510 --> 00:01:13.700
function would be first check is if root is null 

29
00:01:13.990 --> 00:01:15.270
and it is null here 

30
00:01:15.280 --> 00:01:17.890
So we go back to the calling function and continue 

31
00:01:17.890 --> 00:01:22.300
execution there and the next statement execute is print root 

32
00:01:22.300 --> 00:01:25.300
key and 10 will be printed and next we need 

33
00:01:25.300 --> 00:01:26.740
to traverse the right side 

34
00:01:26.800 --> 00:01:29.580
So we call inorder by passing the right child which 

35
00:01:29.580 --> 00:01:30.510
is null here 

36
00:01:30.710 --> 00:01:33.910
So when the function checks if root is null that condition 

37
00:01:33.910 --> 00:01:36.260
is true and it comes back to this function and 

38
00:01:36.260 --> 00:01:39.900
it is executed completely and control comes back to calling 

39
00:01:39.900 --> 00:01:41.650
function and continue execution 

40
00:01:41.650 --> 00:01:45.290
there and the next statement executed print root key and 

41
00:01:45.290 --> 00:01:46.500
50 will be printed 

42
00:01:46.770 --> 00:01:50.130
So left sub trees visited root is visited And now we 

43
00:01:50.130 --> 00:01:51.790
need to visit the right sub tree 

44
00:01:52.040 --> 00:01:54.850
So we call the function by passing the right child of 

45
00:01:54.860 --> 00:01:57.890
the node 50 which is 60 and inside 

46
00:01:57.890 --> 00:02:00.290
The function first we check if root is null 

47
00:02:00.410 --> 00:02:01.930
But it is not so 

48
00:02:01.930 --> 00:02:04.310
We call inorder of left child which is null 

49
00:02:04.310 --> 00:02:04.750
here 

50
00:02:05.110 --> 00:02:07.920
So in the function it finds root equal to null 

51
00:02:08.020 --> 00:02:10.200
So it comes back and print the key which is 

52
00:02:10.200 --> 00:02:13.690
60 and calls the function by passing right child which is 

53
00:02:13.700 --> 00:02:15.300
again null and again 

54
00:02:15.300 --> 00:02:18.480
The function will do nothing but returned by finding root 

55
00:02:18.490 --> 00:02:20.340
equal to null and here 

56
00:02:20.350 --> 00:02:23.550
The function is execute er completely and control comes back 

57
00:02:23.550 --> 00:02:27.260
to calling function and it is also completed now so 

58
00:02:27.260 --> 00:02:31.480
control again reaches the function for 100 continue execution and 

59
00:02:31.480 --> 00:02:35.450
next statement executed print Key 100 will be printed 

60
00:02:36.350 --> 00:02:40.020
So the left sub trees travels root is Travels and now 

61
00:02:40.020 --> 00:02:42.200
it is time to traverse the right subject 

62
00:02:42.370 --> 00:02:45.450
So we call the function by passing the right child which 

63
00:02:45.450 --> 00:02:46.470
is 200 

64
00:02:46.480 --> 00:02:49.160
And please note that 200 left child is  

65
00:02:49.160 --> 00:02:53.530
150 right Child is 300 in the function first we 

66
00:02:53.530 --> 00:02:56.380
check if root is null but it is not so 

67
00:02:56.380 --> 00:02:59.520
We traverse the left sub tree by passing 150 

68
00:02:59.520 --> 00:03:02.250
to the function and in the function we check if 

69
00:03:02.250 --> 00:03:02.990
root is null 

70
00:03:03.100 --> 00:03:04.420
But it isn't so 

71
00:03:04.420 --> 00:03:07.250
We call inorder of left child which is null 

72
00:03:07.540 --> 00:03:07.840
so 

73
00:03:07.840 --> 00:03:11.000
This function will do nothing but return and it will 

74
00:03:11.000 --> 00:03:14.400
print 150 and call inorder of right child which 

75
00:03:14.400 --> 00:03:15.310
is again null 

76
00:03:15.540 --> 00:03:18.600
And since root is null it will do nothing and control 

77
00:03:18.600 --> 00:03:21.180
goes back to the calling function and it is also 

78
00:03:21.180 --> 00:03:24.820
completed So the control again reaches the function in order 

79
00:03:24.820 --> 00:03:29.130
of 200 we continue execution that and we already travels 

80
00:03:29.130 --> 00:03:30.040
the left sub tree 

81
00:03:30.050 --> 00:03:33.630
Now we print the key which is 200 now we 

82
00:03:33.630 --> 00:03:36.650
call inorder of right child which is 300 

83
00:03:37.340 --> 00:03:40.020
And there we first travels the left sub tree and 

84
00:03:40.020 --> 00:03:43.420
it is null So the function is doing nothing and we print 

85
00:03:43.430 --> 00:03:46.720
300 call inorder of right child which is null 

86
00:03:46.720 --> 00:03:47.210
again 

87
00:03:47.430 --> 00:03:50.290
So this function also does nothing but returned to the 

88
00:03:50.290 --> 00:03:52.680
calling function and it is completed here 

89
00:03:52.830 --> 00:03:55.010
So we go back to the calling function which is 

90
00:03:55.020 --> 00:03:58.650
in order of 100 it is also completed now and 

91
00:03:58.660 --> 00:04:01.400
we got in order traversal sequence as a 

92
00:04:01.400 --> 00:04:02.150
result 

93
00:04:02.540 --> 00:04:05.190
And if you see closely the result in sequence is 

94
00:04:05.190 --> 00:04:06.230
in ascending order 

95
00:04:06.240 --> 00:04:08.850
And that will always be like that since we have 

96
00:04:08.850 --> 00:04:12.120
this ordering for BST that the value of left child 

97
00:04:12.130 --> 00:04:14.950
will always be less than the value of parent and 

98
00:04:14.950 --> 00:04:17.250
the value of parent will always be less than the 

99
00:04:17.250 --> 00:04:18.350
value of right child 

100
00:04:18.700 --> 00:04:21.660
And the in order traverse of sequence is like complete 

101
00:04:21.670 --> 00:04:24.190
left sub tree and then the root and then the 

102
00:04:24.190 --> 00:04:27.410
right subtree so that in order Traversal of sequence will 

103
00:04:27.420 --> 00:04:29.610
always be in the increasing order. 

