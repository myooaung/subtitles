WEBVTT

1
00:00:00.340 --> 00:00:01.260
Hello friends 

2
00:00:01.270 --> 00:00:04.810
In this video let us learn the bubble sort algorithm 

3
00:00:04.820 --> 00:00:05.870
implementation 

4
00:00:05.910 --> 00:00:09.410
So in the previous video we have learnt how bubble 

5
00:00:09.410 --> 00:00:12.460
sort works and we designed an algorithm for it 

6
00:00:13.240 --> 00:00:15.000
so let us quickly revise it 

7
00:00:15.010 --> 00:00:17.980
We will have the array and in bubble sort we will 

8
00:00:17.980 --> 00:00:20.430
continuously compare adjacent elements 

9
00:00:20.570 --> 00:00:24.650
And after four cycle of comparison the largest element will 

10
00:00:24.650 --> 00:00:26.150
reach the last position 

11
00:00:26.640 --> 00:00:29.530
And we will compare the remaining elements then and the 

12
00:00:29.530 --> 00:00:32.670
largest element of these will then come to the second 

13
00:00:32.670 --> 00:00:35.130
last position and this will continue 

14
00:00:35.140 --> 00:00:37.050
And finally we will get this sorted array

15
00:00:37.520 --> 00:00:39.050
So that was bubble sort 

16
00:00:39.640 --> 00:00:42.660
So in this video let us learn the bubble sort 

17
00:00:42.670 --> 00:00:46.650
algorithm implementation how it works and step by step 

18
00:00:47.640 --> 00:00:50.830
So we have the function bubble sort which takes the 

19
00:00:50.840 --> 00:00:54.250
array to be sorted and its size as parameters 

20
00:00:54.840 --> 00:01:00.120
So we have this array with elements 50 25 5 

21
00:01:00.290 --> 00:01:04.150
20 and 10 and its size is five 

22
00:01:04.740 --> 00:01:07.250
And here we will use nested for loop 

23
00:01:07.640 --> 00:01:11.230
The inner for loop will compare the adjacent elements and 

24
00:01:11.230 --> 00:01:12.550
swap if needed 

25
00:01:13.040 --> 00:01:16.280
And this should be done for size minus one times 

26
00:01:16.290 --> 00:01:19.310
to get the sort of array And for that we 

27
00:01:19.310 --> 00:01:22.370
have the outer for loop which will run size minus 

28
00:01:22.370 --> 00:01:23.300
one times 

29
00:01:23.760 --> 00:01:27.280
So first we declare I and j and we have 

30
00:01:27.280 --> 00:01:28.540
the outer for loop 

31
00:01:28.790 --> 00:01:31.850
And in first iteration I equal to 0 

32
00:01:32.640 --> 00:01:35.760
And for the inner loop in first iteration J 

33
00:01:35.770 --> 00:01:36.850
is equal to zero 

34
00:01:37.440 --> 00:01:41.500
And we have if arr of j greater than arr 

35
00:01:41.500 --> 00:01:45.380
of J plus one that is we have comparing two 

36
00:01:45.380 --> 00:01:46.510
adjacent elements 

37
00:01:46.520 --> 00:01:49.250
And if the first one is larger than the second 

38
00:01:49.390 --> 00:01:51.050
it is not in the right order 

39
00:01:51.440 --> 00:01:52.550
So we have to swap 

40
00:01:53.140 --> 00:01:56.030
That is if this condition is true the first one 

41
00:01:56.030 --> 00:02:00.050
is larger than the second one so swap arr of J 

42
00:02:00.060 --> 00:02:03.980
and arr of J plus one Here arr of J 

43
00:02:03.990 --> 00:02:06.880
is equal to 50 and arr of J plus one 

44
00:02:06.890 --> 00:02:10.490
is equal to 25 and we have 50 greater than 

45
00:02:10.490 --> 00:02:11.150
25 

46
00:02:11.640 --> 00:02:15.780
So if is true so swap these two elements now 

47
00:02:15.780 --> 00:02:18.840
in the next iteration J is equal to one 

48
00:02:19.140 --> 00:02:22.840
And we have if arr of j greater than arr 

49
00:02:22.840 --> 00:02:25.780
of J plus one that is we're comparing the elements 

50
00:02:25.780 --> 00:02:29.300
that index one and two and we have 50 greater 

51
00:02:29.300 --> 00:02:29.950
than five 

52
00:02:30.340 --> 00:02:31.970
So if is again true 

53
00:02:31.980 --> 00:02:35.300
So we have to swap now in the next iteration 

54
00:02:35.310 --> 00:02:38.940
J is equal to two and we have if arr of 

55
00:02:38.950 --> 00:02:42.800
j greater than arr of J plus one that is 

56
00:02:42.800 --> 00:02:46.910
we are comparing elements at Index two and three and 

57
00:02:46.910 --> 00:02:49.150
we have 50 greater than 20 

58
00:02:49.640 --> 00:02:52.070
So if it is true so we have to swap 

59
00:02:52.070 --> 00:02:53.150
these two elements 

60
00:02:53.160 --> 00:02:56.540
So 50 and 20 are swapped now in the next 

61
00:02:56.540 --> 00:02:59.510
iteration J is equal to three again 

62
00:02:59.510 --> 00:03:02.790
We have to compare the elements at index three and 

63
00:03:02.790 --> 00:03:05.550
four and we have 50 greater than 10 

64
00:03:05.940 --> 00:03:07.530
So if is again true 

65
00:03:07.540 --> 00:03:09.690
So we have to swap these two elements 

66
00:03:10.240 --> 00:03:13.610
Now in the next iteration J is equal to four and 

67
00:03:13.610 --> 00:03:17.380
now the condition J lessthan size minus one minus 

68
00:03:17.390 --> 00:03:20.750
I fails since four is not less than four 

69
00:03:21.340 --> 00:03:24.750
So the first iteration of outer loop is now completed 

70
00:03:25.140 --> 00:03:28.380
That is the first cycle of comparison is done and 

71
00:03:28.380 --> 00:03:31.450
we got the largest element in the correct position 

72
00:03:32.440 --> 00:03:35.910
And this is what bubble sort does in each iteration 

73
00:03:35.910 --> 00:03:36.530
of outer 

74
00:03:36.530 --> 00:03:40.710
For loop one element comes to right position and from 

75
00:03:40.710 --> 00:03:44.350
now we won't consider it as it is already sorted 

76
00:03:44.650 --> 00:03:47.310
And that is why we have the condition J less 

77
00:03:47.310 --> 00:03:49.110
than size minus one minus 

78
00:03:49.120 --> 00:03:50.550
I in inner for loop 

79
00:03:51.240 --> 00:03:54.290
Now in the second iteration of Outer for Loop I 

80
00:03:54.300 --> 00:03:55.260
is equal to one 

81
00:03:55.840 --> 00:03:58.250
And inside we have the inner for Loop

82
00:03:58.740 --> 00:04:02.270
And in first iteration of this loop J is equal to 

83
00:04:02.270 --> 00:04:02.650
zero 

84
00:04:03.300 --> 00:04:06.970
And we have if arr of J greater than an arr 

85
00:04:06.970 --> 00:04:10.060
of J Plus one and we are comparing the elements 

86
00:04:10.060 --> 00:04:13.960
that are index zero and one and we have 25 greater 

87
00:04:13.960 --> 00:04:14.550
than five 

88
00:04:14.940 --> 00:04:17.560
So if it's true here so we have to swap 

89
00:04:17.560 --> 00:04:21.520
these two elements now in the next iteration J is equal 

90
00:04:21.520 --> 00:04:22.030
to one 

91
00:04:22.400 --> 00:04:26.180
And we have if arr of J greater than arr 

92
00:04:26.180 --> 00:04:29.690
of J plus one that is we are comparing elements 

93
00:04:29.690 --> 00:04:33.400
that index one and two and we have 25 greater 

94
00:04:33.400 --> 00:04:34.350
than 20 

95
00:04:34.360 --> 00:04:37.050
So if it's true here also so we have to 

96
00:04:37.050 --> 00:04:40.150
swap 25 20 and it is done 

97
00:04:40.430 --> 00:04:43.350
And in the next iteration J is equal to two 

98
00:04:43.940 --> 00:04:44.710
And we have 

99
00:04:44.940 --> 00:04:47.700
If a r r of J greater than arr of 

100
00:04:47.710 --> 00:04:50.880
J plus one that is we are comparing the elements 

101
00:04:50.880 --> 00:04:55.330
at index two and three and we have 25 greater than 

102
00:04:55.330 --> 00:04:55.670
10 

103
00:04:55.890 --> 00:04:58.570
So if it's true here also so we have to 

104
00:04:58.570 --> 00:05:03.390
swap  25 10 now in the next iteration J is equal 

105
00:05:03.390 --> 00:05:03.900
to three 

106
00:05:03.910 --> 00:05:07.620
But now the condition J less than size minus one 

107
00:05:07.620 --> 00:05:08.070
minus 

108
00:05:08.080 --> 00:05:09.150
I fails 

109
00:05:09.540 --> 00:05:13.100
So second iteration of Outer for Loop is also completed 

110
00:05:13.100 --> 00:05:15.780
now and we got the second largest element 

111
00:05:15.790 --> 00:05:20.110
Also sorted now in the third iteration of Outer loop 

112
00:05:20.140 --> 00:05:21.550
is equal to two 

113
00:05:21.940 --> 00:05:24.230
And inside we have the inner for loop 

114
00:05:24.410 --> 00:05:27.600
And in first iteration of this loop J equal to 

115
00:05:27.600 --> 00:05:27.950
zero 

116
00:05:28.520 --> 00:05:32.270
And we have if arr of J greater than arr 

117
00:05:32.270 --> 00:05:35.020
of J plus one that is we are comparing the 

118
00:05:35.020 --> 00:05:38.120
elements that index zero and zero plus one that is 

119
00:05:38.120 --> 00:05:42.150
one and we have five not greater than 20 

120
00:05:42.540 --> 00:05:46.200
So if fails that is these two elements are already 

121
00:05:46.200 --> 00:05:48.920
in sorted order so there is no need to swap  

122
00:05:48.920 --> 00:05:50.080
them now 

123
00:05:50.080 --> 00:05:53.260
In the next iteration J is equal to one and 

124
00:05:53.260 --> 00:05:56.700
we have if arr of j greater than arr of 

125
00:05:56.710 --> 00:06:00.600
J plus one that is if arr of one greater 

126
00:06:00.600 --> 00:06:04.500
than arr of two and we have 20 greater than 

127
00:06:04.500 --> 00:06:04.790
10 

128
00:06:05.110 --> 00:06:07.380
So if it is true so we have to swap  

129
00:06:07.380 --> 00:06:08.410
these two elements 

130
00:06:08.520 --> 00:06:12.260
So 20 and 10 are swap Now in the next 

131
00:06:12.260 --> 00:06:14.250
iteration J is equal to two 

132
00:06:14.740 --> 00:06:18.100
But now the condition J less than size minus one 

133
00:06:18.100 --> 00:06:22.490
minus i that is five minus one minus two which is J less 

134
00:06:22.490 --> 00:06:25.850
than two fails as two is not less than two 

135
00:06:26.340 --> 00:06:29.800
So third iteration of outer for loop is also completed 

136
00:06:29.800 --> 00:06:32.990
now And we got the third largest element at the 

137
00:06:32.990 --> 00:06:33.740
right place 

138
00:06:34.270 --> 00:06:37.520
Now in the fourth iteration of outer loop i is equal 

139
00:06:37.520 --> 00:06:38.360
to three 

140
00:06:38.370 --> 00:06:41.460
And inside we have the inner for loop and in 

141
00:06:41.460 --> 00:06:44.870
first iteration of this inner for loop J is equal to 

142
00:06:44.870 --> 00:06:49.800
zero and we have if arr of J greater than arr 

143
00:06:49.800 --> 00:06:52.630
of J plus one that is We are comparing the 

144
00:06:52.630 --> 00:06:56.570
elements at index zero and one and we have five 

145
00:06:56.580 --> 00:06:57.930
not greater than 10

146
00:06:58.160 --> 00:07:00.120
So if fails here that is 

147
00:07:00.300 --> 00:07:03.450
These two elements are already in sorted order so we 

148
00:07:03.450 --> 00:07:05.610
don't need to swap  them now 

149
00:07:05.610 --> 00:07:08.070
The next iteration J is equal to one 

150
00:07:08.480 --> 00:07:12.320
But now the condition J less than size minus one minus 

151
00:07:12.330 --> 00:07:16.280
I fails as one is not less than one so 

152
00:07:16.280 --> 00:07:16.670
fourth 

153
00:07:16.670 --> 00:07:20.660
iteration of outer for loop is also completed and regard 

154
00:07:20.660 --> 00:07:22.080
the fourth largest element 

155
00:07:22.090 --> 00:07:23.050
Also sorted 

156
00:07:23.640 --> 00:07:26.740
Now in the next iteration of outer loop I is 

157
00:07:26.750 --> 00:07:27.650
equal to four 

158
00:07:28.040 --> 00:07:32.170
But now the condition i less than size minus one fails 

159
00:07:32.180 --> 00:07:34.250
as four is not less than four 

160
00:07:35.040 --> 00:07:37.950
And now the control comes out of the loop and 

161
00:07:37.950 --> 00:07:39.450
we got the arry sorted 

162
00:07:39.940 --> 00:07:42.410
So that is how bubble sort function works 

163
00:07:42.940 --> 00:07:45.950
now let us take sorted array and analyse it 

164
00:07:46.540 --> 00:07:49.600
If we give this arrange of bubble sort function 

165
00:07:49.860 --> 00:07:53.050
it will first compare the 1st and 2nd elements 

166
00:07:53.430 --> 00:07:56.010
Since they are in sorted order there is no need 

167
00:07:56.020 --> 00:07:59.920
to swap next it will compare 2nd and 3rd elements 

168
00:08:00.040 --> 00:08:01.750
and it is also in sorted order 

169
00:08:01.760 --> 00:08:03.750
So again there is no need to swap 

170
00:08:04.140 --> 00:08:08.160
Similarly all comparisons will fail and we can understand that 

171
00:08:08.440 --> 00:08:09.950
there is no need to swap 

172
00:08:10.340 --> 00:08:14.560
It is already sorted but however our bubble sort function 

173
00:08:14.560 --> 00:08:17.200
will go on to the next cycle and compare the 

174
00:08:17.200 --> 00:08:18.920
first four elements again 

175
00:08:19.280 --> 00:08:21.760
And in the next cycle the first three elements will 

176
00:08:21.760 --> 00:08:23.550
be compared and this will continue 

177
00:08:24.040 --> 00:08:28.200
So the programme is unnecessarily comparing the sorted elements and 

178
00:08:28.200 --> 00:08:29.470
wasting CPU time 

179
00:08:30.140 --> 00:08:33.130
So what can we do here We can notice that 

180
00:08:33.130 --> 00:08:36.420
the sorted array doesn't need any swap  operation 

181
00:08:36.740 --> 00:08:40.490
So if no swap operation takes plus we can be 

182
00:08:40.490 --> 00:08:43.400
sure that the array sorted and we can break the 

183
00:08:43.400 --> 00:08:44.050
process 

184
00:08:44.540 --> 00:08:47.850
It will improve the efficiency of bubble Sort algorithm 

185
00:08:48.340 --> 00:08:51.800
Let us see how there is only a small change 

186
00:08:51.810 --> 00:08:52.860
that we need to make 

187
00:08:52.870 --> 00:08:56.510
In this function we will declare a flag variable and 

188
00:08:56.520 --> 00:08:59.950
initialised it to zero in the beginning of each iteration 

189
00:08:59.950 --> 00:09:00.950
of the outer loop

190
00:09:01.540 --> 00:09:05.040
And whenever a swap operation takes place we will set 

191
00:09:05.050 --> 00:09:08.910
flag equal to one and at the end of each 

192
00:09:08.910 --> 00:09:10.410
iteration we will check 

193
00:09:10.420 --> 00:09:12.750
The flag is still equal to zero 

194
00:09:13.140 --> 00:09:16.960
Then we can understand that no swap operation took place 

195
00:09:16.970 --> 00:09:19.150
so we can break out of the loop 

196
00:09:19.740 --> 00:09:23.150
So see here we have assorted array of size five 

197
00:09:23.640 --> 00:09:26.230
and we passed this array to the function and 

198
00:09:26.230 --> 00:09:29.650
in first iteration of Outer loop i is equal to zero 

199
00:09:30.440 --> 00:09:33.450
and we declare and initialised flat to 0 

200
00:09:34.840 --> 00:09:38.200
And in first iteration of inner loop J is equal to 

201
00:09:38.200 --> 00:09:41.620
zero and we compare elements at J and J plus 

202
00:09:41.620 --> 00:09:45.170
one that is zero and one and we have 10 

203
00:09:45.370 --> 00:09:47.950
not greater than 20 so no Swap 

204
00:09:48.500 --> 00:09:51.700
And in next iteration J is equal to one and we 

205
00:09:51.700 --> 00:09:54.550
compare elements at J and J Plus one that is 

206
00:09:54.560 --> 00:09:58.480
one and two and 20 is not greater than 30 

207
00:09:58.490 --> 00:10:00.250
So there is no swap again 

208
00:10:00.990 --> 00:10:04.510
And in the next iteration J is equal to two and 

209
00:10:04.510 --> 00:10:08.980
we compare elements at two and three and we have 30 

210
00:10:08.990 --> 00:10:10.450
not greater than 40 

211
00:10:10.940 --> 00:10:12.750
So again there is no swap  

212
00:10:13.290 --> 00:10:16.900
And in next iteration J is equal to three and we 

213
00:10:16.900 --> 00:10:20.480
compare elements at J and J plus one that is 

214
00:10:20.480 --> 00:10:24.600
three and four and we have 40 not greater than 

215
00:10:24.600 --> 00:10:25.150
50 

216
00:10:25.640 --> 00:10:27.350
So again there is no swap 

217
00:10:28.240 --> 00:10:31.620
And in next iteration J is equal to four and now 

218
00:10:31.620 --> 00:10:35.010
the for loop condition fails and control comes out of 

219
00:10:35.020 --> 00:10:37.490
the Inner for loop and it checks 

220
00:10:37.500 --> 00:10:40.950
If flag is still equal to zero and it is 

221
00:10:41.540 --> 00:10:45.550
so it means that there was no swap operation and 

222
00:10:45.550 --> 00:10:48.510
the elements are sorted and we can break out of 

223
00:10:48.520 --> 00:10:48.880
the loop 

224
00:10:49.540 --> 00:10:52.420
So we have saved a lot of time an improved 

225
00:10:52.430 --> 00:10:55.950
efficiency of bubble sort function using this method 

226
00:10:56.540 --> 00:10:59.520
If this was the old function it would have gone 

227
00:10:59.530 --> 00:11:02.040
for three more iterations of outer for 

228
00:11:02.040 --> 00:11:05.540
Loop each with inner for loop printing for size minus 

229
00:11:05.540 --> 00:11:07.050
one minus i times 

230
00:11:07.840 --> 00:11:11.790
And now suppose the input array was not sorted and 

231
00:11:11.790 --> 00:11:13.950
there was one unsorted element 

232
00:11:14.340 --> 00:11:17.910
And in the first iteration there was one swap operation 

233
00:11:18.180 --> 00:11:20.320
which sets flag equal to one 

234
00:11:20.610 --> 00:11:24.360
And also in this iteration the array become sorted 

235
00:11:25.040 --> 00:11:27.790
So in the second iteration of outer for loop there 

236
00:11:27.790 --> 00:11:29.670
will be no swap operation 

237
00:11:29.860 --> 00:11:32.470
So when it checks for the flag value it will 

238
00:11:32.470 --> 00:11:33.650
be equal to zero 

239
00:11:34.840 --> 00:11:38.530
So the process will be stopped there that is 

240
00:11:38.530 --> 00:11:40.380
whenever Array becomes sorted 

241
00:11:40.730 --> 00:11:43.150
We can stop the process right there 

242
00:11:43.740 --> 00:11:46.560
So this is how bubble sort algorithm works 

243
00:11:46.660 --> 00:11:49.590
And we also learned how to improve the efficiency of 

244
00:11:49.600 --> 00:11:50.510
this algorithm 

245
00:11:51.240 --> 00:11:54.230
So in the next video we will analyse the time 

246
00:11:54.280 --> 00:11:57.350
and space complexity of the bubble sort algorithm .

