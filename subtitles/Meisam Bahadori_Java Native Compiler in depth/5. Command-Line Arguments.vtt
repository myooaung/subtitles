WEBVTT
1
00:00:00.900 --> 00:00:03.390
Hello and welcome to another tutorial.

2
00:00:03.390 --> 00:00:07.560
We're going to continue our discussion on a and native image.

3
00:00:07.590 --> 00:00:14.640
We saw that every platform has its own toolchain, Mac, OS and Linux and then Windows you.

4
00:00:14.640 --> 00:00:20.610
Your best option is going to be to install Microsoft, the visual C compiler, mac os is Xcode.

5
00:00:20.610 --> 00:00:21.600
You install it.

6
00:00:21.630 --> 00:00:26.910
If you don't want to install the entire Xcode application, you can install the command line tools that

7
00:00:26.910 --> 00:00:31.890
are basically the tool chains or the compilers that Mac OS supports.

8
00:00:31.890 --> 00:00:37.890
And then I will show you in the future lectures how to basically install those command line tools,

9
00:00:37.890 --> 00:00:38.250
right?

10
00:00:38.250 --> 00:00:44.430
So every platform has its own compiler and the job of the compiler is to compile C++ or C applications

11
00:00:44.430 --> 00:00:45.480
to native binary.

12
00:00:45.480 --> 00:00:51.390
We know that all the operating systems today like Mac OS, Linux, Windows, they're built based on

13
00:00:51.570 --> 00:00:54.000
C code or C++ code.

14
00:00:54.900 --> 00:01:02.550
Now what I'm going to show you now is go back to our IDE and you saw that we had three folders and in

15
00:01:02.550 --> 00:01:07.680
each one we had the Java class, we compiled them and then we compiled the entire application into a

16
00:01:07.680 --> 00:01:08.400
native binary.

17
00:01:08.400 --> 00:01:14.850
What I'm going to do, I'm going to create another directory called the example, and then in the example

18
00:01:14.850 --> 00:01:20.010
I'm going to create, maybe let's create an empty file, let's call it the

19
00:01:22.050 --> 00:01:30.660
C++ example, example, underscore CP and then or just example dot.

20
00:01:30.660 --> 00:01:31.320
CP.

21
00:01:31.350 --> 00:01:34.590
This is going to be a C++ file.

22
00:01:34.590 --> 00:01:43.350
And here I'm going to first of all, we want to write a quick C++ program that writes the same things

23
00:01:43.350 --> 00:01:47.190
to the console Hello World and then print some number.

24
00:01:47.190 --> 00:01:53.280
And then the other thing that we want to do, we want to check whether our basically toolchain platform

25
00:01:53.280 --> 00:02:00.630
toolchain in this case the compiler that comes from Mac OS are installed and ready to go.

26
00:02:00.780 --> 00:02:09.450
So if we type C++, hyphen hyphen version 8.2, the apple clang toolchain and then it tells us where

27
00:02:09.450 --> 00:02:14.400
it can find the installation directory, which is this one is in the Xcode app, right?

28
00:02:14.460 --> 00:02:19.470
When you install the Xcode and then these applications, the toolchain comes with it.

29
00:02:19.560 --> 00:02:22.530
Same with G plus plus hyphen, hyphen version.

30
00:02:22.980 --> 00:02:30.420
Same thing you see, they point to the same location, which means basically when you install the Xcode

31
00:02:30.420 --> 00:02:37.050
and the command line tools, all these aliases are generated automatically for the compiler, mac OS

32
00:02:37.050 --> 00:02:37.790
compiler, right.

33
00:02:37.800 --> 00:02:38.880
Apple clang.

34
00:02:39.930 --> 00:02:44.730
So what we're going to do, we're going to so right now we are in this example.

35
00:02:44.730 --> 00:02:54.600
So let's type some code, let's include the iOS stream and then we're going to say that INT Main, we

36
00:02:54.600 --> 00:02:59.820
know that main in in general by convention is going to return zero on success.

37
00:02:59.850 --> 00:03:02.220
It's not necessary in modern C++.

38
00:03:02.220 --> 00:03:14.520
So basically when successfully terminated, return zero, right in Java, they try to make it simpler.

39
00:03:14.520 --> 00:03:16.770
So the main actually doesn't return anything.

40
00:03:16.770 --> 00:03:20.130
Its signature is void in C++, it's main, but it's INT.

41
00:03:20.130 --> 00:03:21.930
But you don't really need to return zero.

42
00:03:21.930 --> 00:03:22.260
Right.

43
00:03:22.260 --> 00:03:25.170
So that's just kept by convention.

44
00:03:26.630 --> 00:03:28.370
All right, now what what do we want to do?

45
00:03:28.400 --> 00:03:33.080
We want to say in the 13 we had the STD namespace.

46
00:03:33.080 --> 00:03:42.800
So STD C out, which means console out hello world from C++ application and exclamation mark and then

47
00:03:42.800 --> 00:03:46.940
a backslash in character and then stdc out five.

48
00:03:46.940 --> 00:03:47.540
Right.

49
00:03:47.540 --> 00:03:53.510
And this insertion operator is overloaded for the console output stream so it understands the types.

50
00:03:53.510 --> 00:03:58.550
So it's aware of the type five is an integer, it knows how to handle it and convert it to a string.

51
00:03:58.700 --> 00:04:05.360
And then let's also add we can also add a backslash n for the new line character.

52
00:04:05.450 --> 00:04:13.790
So we save this, we go back to our terminal, we say that g plus plus example dot c hyphen out.

53
00:04:13.790 --> 00:04:16.400
The output file is called my app.

54
00:04:17.360 --> 00:04:18.890
So let's see if this works fine.

55
00:04:18.890 --> 00:04:20.720
And as you can see, everything worked fine.

56
00:04:20.720 --> 00:04:26.210
If we do an LZ, you see that my app is generated and it doesn't have any extension, which makes sense.

57
00:04:26.210 --> 00:04:30.470
We said that executables on macOS and Linux, they don't have any extension.

58
00:04:30.560 --> 00:04:37.910
And then and this asterisk means this is a binary application, it's executable and it has the permission

59
00:04:37.910 --> 00:04:38.810
to be executed.

60
00:04:38.810 --> 00:04:46.280
This asterisk note that I'm running fish which is friendly, intelligent shell on top of my macOS terminal.

61
00:04:46.280 --> 00:04:50.210
That's why it has more intelligent features like color highlighting.

62
00:04:50.210 --> 00:04:55.700
And in this asterisk that tells me that this is an executable which has the permissions to be executed.

63
00:04:55.730 --> 00:05:02.630
If we look at if we list the files with the long details, it tells me that my app has the exe permission

64
00:05:02.630 --> 00:05:09.140
and in the previous lecture we saw that how we can give a binary application executable permission.

65
00:05:09.140 --> 00:05:09.350
Right.

66
00:05:09.350 --> 00:05:11.410
Or we can remove this with the CMD.

67
00:05:11.420 --> 00:05:14.390
Right now that I have my app, I can execute it.

68
00:05:14.390 --> 00:05:20.450
And we said that in Java, if you want to launch a Java application with the JVM, you specify the name

69
00:05:20.450 --> 00:05:26.150
of the class that has the main and then the path to that class is specified in the directories that

70
00:05:26.150 --> 00:05:30.260
are in the class path for C++ or executable native binaries.

71
00:05:30.260 --> 00:05:31.040
It's not the case.

72
00:05:31.040 --> 00:05:33.500
You just specify to the path to that file.

73
00:05:33.530 --> 00:05:40.640
Right now my app is my in my current working directory so I can specify the relative path and then enter.

74
00:05:40.640 --> 00:05:45.410
And then it says Hello World from C++ application and file.

75
00:05:45.440 --> 00:05:51.740
So we successfully compiled our C++ application source code to a binary application for this particular

76
00:05:51.740 --> 00:05:54.140
platform and we were able to execute it.

77
00:05:54.140 --> 00:05:54.710
Right.

78
00:05:54.710 --> 00:06:02.840
So if I go back and execute that hello world that we created by compiling our Java application to native

79
00:06:02.840 --> 00:06:09.680
binary, I have to go one level up and then say Hello World, right and hello world from Java Application

80
00:06:09.680 --> 00:06:11.120
five Core Machine.

81
00:06:11.120 --> 00:06:15.950
All right, so everything works fine if you.

82
00:06:16.070 --> 00:06:22.040
I can also quickly show you how to, for example, create a car object so we can declare a class core,

83
00:06:22.070 --> 00:06:22.640
right?

84
00:06:22.730 --> 00:06:26.600
And then know that we have to terminate with semicolon here.

85
00:06:26.600 --> 00:06:28.460
And then we're going to say that.

86
00:06:29.540 --> 00:06:32.750
So we're going to hear our core had the end price.

87
00:06:32.750 --> 00:06:34.640
So into price.

88
00:06:35.480 --> 00:06:36.140
Right.

89
00:06:36.140 --> 00:06:44.690
And then we're going to have a public constructor car that takes an end price.

90
00:06:45.020 --> 00:06:45.650
All right.

91
00:06:45.650 --> 00:06:49.280
And then we're going to have a initialize list to say price price.

92
00:06:49.280 --> 00:06:52.400
So and then our constructor is empty.

93
00:06:52.400 --> 00:06:52.670
Right.

94
00:06:52.670 --> 00:06:58.730
So it's better to initialize your fields using the initialize at least instead of in the body of the

95
00:06:59.210 --> 00:07:00.920
in the body of the constructor.

96
00:07:00.920 --> 00:07:02.810
Whereas in Java you don't have that option.

97
00:07:02.810 --> 00:07:03.050
Right?

98
00:07:03.050 --> 00:07:05.630
Everything has to be inside the body of the constructor.

99
00:07:05.630 --> 00:07:06.440
That's fine.

100
00:07:06.440 --> 00:07:08.840
And then we want to overload the output stream.

101
00:07:08.840 --> 00:07:15.560
So basically what we want to say stdc out and then we want to create a car instance, right.

102
00:07:17.300 --> 00:07:24.560
So we want to say car, car allocated on the stack with a, uh, let's say how much was the price here?

103
00:07:24.920 --> 00:07:25.760
100.

104
00:07:27.260 --> 00:07:27.860
All right.

105
00:07:27.860 --> 00:07:33.920
And then we want to say stdc out and then push car to the and then to the console.

106
00:07:33.920 --> 00:07:35.780
And then this.

107
00:07:35.780 --> 00:07:41.810
Obviously, if we do this, if we try to compile, it's going to fail on compilation because right now

108
00:07:41.840 --> 00:07:47.930
the console sea out object, it doesn't know how to handle a type a car.

109
00:07:47.930 --> 00:07:54.590
Right so if we say gee plus plus my app and then it's going to give us error and the error is going

110
00:07:54.590 --> 00:07:56.420
to be a complicated.

111
00:07:56.420 --> 00:07:57.410
Let's go back up.

112
00:07:57.410 --> 00:08:02.600
It says that I don't know what to do with this car candidate function not viable no known conversion

113
00:08:02.600 --> 00:08:04.280
from car type to cost void.

114
00:08:04.280 --> 00:08:11.150
Basically this is trying to convert to the character arrays right for the strings.

115
00:08:11.150 --> 00:08:17.150
So what we're going to do, we're going to overload the basically see out operator, right.

116
00:08:17.150 --> 00:08:19.190
So and you have to do it globally.

117
00:08:19.190 --> 00:08:23.570
So overload see out operator for car type.

118
00:08:23.570 --> 00:08:29.630
Now in Java, things are much easier because every object has the potential to be converted to a string.

119
00:08:29.630 --> 00:08:36.680
Now that when we when we do these, when we send a car type to a print line, it calls the overloaded

120
00:08:37.070 --> 00:08:44.600
function that actually basically it calls the to a string.

121
00:08:44.600 --> 00:08:45.110
Right?

122
00:08:45.110 --> 00:08:49.700
So this behind the scenes, this gets converted to to a string.

123
00:08:49.700 --> 00:08:57.320
And then basically this is equivalent to saying car to string and pass that string to the print line

124
00:08:57.320 --> 00:08:57.980
to the console.

125
00:08:57.980 --> 00:09:01.250
So this call to the two string happens behind the scenes.

126
00:09:01.250 --> 00:09:09.020
And the reason it's implicit because all the objects inherit from the object class implicitly, and

127
00:09:09.020 --> 00:09:11.600
therefore they all inherit the two string method, right?

128
00:09:11.600 --> 00:09:17.450
So to a string method, the object class provides a default to a string implement implementation, but

129
00:09:17.450 --> 00:09:24.080
then you can override it in your own classes in C++ types like classes they don't inherit from any other

130
00:09:24.080 --> 00:09:24.380
type.

131
00:09:24.380 --> 00:09:31.130
So really there is no implicit inheritance here, unlike Java, where every class has implicit inheritance

132
00:09:31.130 --> 00:09:37.130
from object class and therefore you have to manually overload the to a string.

133
00:09:37.130 --> 00:09:38.930
So we're going to.

134
00:09:40.970 --> 00:09:52.820
We're going to return a steady stream and then by reference and then operator insertion.

135
00:09:52.820 --> 00:09:53.300
Right?

136
00:09:53.300 --> 00:10:01.370
And then we're going to take that steady or stream with reference, let's say see out.

137
00:10:01.370 --> 00:10:08.330
And then and then we're going to say car, car by reference, we don't want to create another copies.

138
00:10:08.330 --> 00:10:15.260
And then obviously at the end we're going to return to the OS, see out again this output stream.

139
00:10:15.260 --> 00:10:19.580
But then before returning back by reference, remember that it is c outs.

140
00:10:19.580 --> 00:10:21.560
These console outputs are not copy.

141
00:10:21.800 --> 00:10:25.040
So you cannot you have to only take them by reference.

142
00:10:25.040 --> 00:10:30.620
You cannot take them by value because when you take them by value, a copy is generated and copy constructor

143
00:10:30.620 --> 00:10:35.450
for the output streams for the console output is a deleted function.

144
00:10:35.900 --> 00:10:44.240
So we're going to say that see out card basically what did we do here in the car?

145
00:10:46.660 --> 00:10:50.500
Basically we're going to do the same thing, obviously in C++.

146
00:10:50.560 --> 00:10:51.460
There is no force.

147
00:10:51.460 --> 00:10:54.700
So we have to break this down into smaller pieces.

148
00:10:54.700 --> 00:11:04.960
So this is one piece and then we insert the price and then we insert a bracket again, right?

149
00:11:04.960 --> 00:11:10.990
So this is basically the same thing and then a semicolon.

150
00:11:11.980 --> 00:11:15.760
So let's go back and see if we can compile our application again.

151
00:11:15.850 --> 00:11:17.190
And now it doesn't work.

152
00:11:17.200 --> 00:11:19.610
It says that, okay, so this is correct.

153
00:11:19.630 --> 00:11:19.930
Price.

154
00:11:19.930 --> 00:11:22.570
I know that this is a disease by default.

155
00:11:22.570 --> 00:11:25.090
This is private, so we cannot inherit it.

156
00:11:25.120 --> 00:11:30.250
So we can either make it public or create a getter.

157
00:11:30.250 --> 00:11:38.680
So we're going to say that int get price and then and it's a cost function because it doesn't modify

158
00:11:38.680 --> 00:11:47.050
usually getters in C++, they define as cost because they don't they don't change the set right.

159
00:11:47.050 --> 00:11:53.200
In Java, there is no such thing as const method, but in C++ you can declare them as cons and here

160
00:11:53.200 --> 00:11:57.790
we can say code that get price right and then everything works fine.

161
00:11:57.790 --> 00:12:00.340
Let's go back and compile one more time.

162
00:12:04.030 --> 00:12:05.080
Where is that?

163
00:12:05.110 --> 00:12:08.440
Is there a semicolon missing c out.

164
00:12:08.440 --> 00:12:08.770
Okay.

165
00:12:08.770 --> 00:12:09.960
Returns the idea.

166
00:12:10.610 --> 00:12:10.880
Okay.

167
00:12:11.170 --> 00:12:12.310
One more time.

168
00:12:15.220 --> 00:12:16.650
And now everything works fine.

169
00:12:16.660 --> 00:12:17.050
All right.

170
00:12:17.050 --> 00:12:21.680
And then now we can say my app executed and car price then.

171
00:12:21.700 --> 00:12:22.090
Right?

172
00:12:22.090 --> 00:12:28.330
And again, if we go back to say a hello world, this is our executable binary, native binary that

173
00:12:28.330 --> 00:12:34.840
came by from compiling our Java application and hello world from a Java application.

174
00:12:34.840 --> 00:12:38.980
Hello world from C++ Application five core price 100.

175
00:12:38.980 --> 00:12:39.460
Right.

176
00:12:39.460 --> 00:12:42.280
So as you can see, there are differences in Java and C++.

177
00:12:42.280 --> 00:12:48.670
Java development is much easier because you just right click and then source override to string method

178
00:12:48.670 --> 00:12:49.510
for example.

179
00:12:49.510 --> 00:12:55.060
In this case because we're not using Eclipse Bell to build system, it doesn't find the necessary stuff.

180
00:12:55.060 --> 00:13:00.450
But in general, using an Java ID makes your development much, much faster.

181
00:13:00.460 --> 00:13:07.630
Obviously there are also good IDs for C++, but the fact that if you define a class and you just want

182
00:13:07.630 --> 00:13:13.780
to push it to the console output, you have to do extra work by overloading operators because this class

183
00:13:13.780 --> 00:13:18.970
doesn't really implicitly inherit from some other class that provides an implementation or a default

184
00:13:18.970 --> 00:13:19.990
implementation.

185
00:13:19.990 --> 00:13:22.270
That's why you have to do extra work here.

186
00:13:22.270 --> 00:13:26.930
It gives more control to you have to know that console output is not copy able.

187
00:13:26.950 --> 00:13:29.200
You have to always pass them by reference.

188
00:13:29.200 --> 00:13:32.530
And in in this case, we don't want to create a copy of the car object.

189
00:13:32.530 --> 00:13:38.710
So we're also passing by reference and then you have to return the console output again by reference

190
00:13:38.710 --> 00:13:43.930
so that you can cascade or chain all these operator calls.

191
00:13:43.930 --> 00:13:44.380
Right?

192
00:13:44.380 --> 00:13:52.540
So these are basically examples of how we can compile a C++ application to the native binary.

193
00:13:52.540 --> 00:13:59.920
And then previously we saw a quick example of how to compile and how to compile a Java application to

194
00:13:59.920 --> 00:14:07.270
Java binaries that class files and then have to then compile those classifiers into operating system

195
00:14:07.270 --> 00:14:09.580
or platform binaries or native binaries.

196
00:14:09.580 --> 00:14:10.000
Right.

197
00:14:10.120 --> 00:14:15.850
So there is a difference between Java binary, which are the class files and native binaries which are

198
00:14:15.880 --> 00:14:17.560
don't have really any extensions.

199
00:14:17.560 --> 00:14:19.840
They're fully compiled and ready to be executed.

200
00:14:19.840 --> 00:14:20.290
Right.

201
00:14:20.770 --> 00:14:27.250
And then when you want to execute a native binary, you just give the relative path or the full path

202
00:14:27.250 --> 00:14:29.470
on where they are on the hard disk.

203
00:14:29.470 --> 00:14:35.830
And the operating system knows before obviously executing this operating system takes the permissions

204
00:14:36.190 --> 00:14:42.280
of the files to make sure that they are allowed to be executed, otherwise the operating system doesn't

205
00:14:42.670 --> 00:14:43.570
execute them.

206
00:14:44.860 --> 00:14:49.930
So if you go back to the PowerPoint, what is the command line argument?

207
00:14:50.260 --> 00:14:55.930
We said that we run applications with the terminal, and terminal is a text based application.

208
00:14:55.930 --> 00:15:02.200
And any application, obviously, you want to pass, the user wants to pass some argument to them,

209
00:15:02.200 --> 00:15:02.470
right.

210
00:15:02.470 --> 00:15:07.480
So that the application behaves differently based on the parameters that you pass or the arguments you

211
00:15:07.480 --> 00:15:07.750
pass.

212
00:15:07.750 --> 00:15:08.230
Right?

213
00:15:08.440 --> 00:15:11.080
The C++ compiled binary applications.

214
00:15:11.080 --> 00:15:13.480
The main is the entry point to the execution.

215
00:15:13.480 --> 00:15:14.440
And same with Java.

216
00:15:14.440 --> 00:15:14.860
Right?

217
00:15:14.860 --> 00:15:22.240
We know that both in C++, in Java, if you are trying to create an executable application, then you

218
00:15:22.240 --> 00:15:23.500
have to have a main method.

219
00:15:23.980 --> 00:15:32.410
And now in the more general sense, it's not necessary that the entry point your application is made

220
00:15:32.410 --> 00:15:39.340
right in Java, it's mandatory in C++, it's not that much mandatory, but it's a strong convention

221
00:15:39.340 --> 00:15:41.710
and I recommend that you always follow this convention.

222
00:15:41.710 --> 00:15:47.320
Some compilers make it mandatory, other compilers may not make it mandatory.

223
00:15:47.410 --> 00:15:54.550
You may be able to define a command line flag for the for the compiler so that it knows which function

224
00:15:54.550 --> 00:15:56.290
is the entry point to your execution.

225
00:15:56.290 --> 00:15:58.030
Some compilers make it mandatory.

226
00:15:58.030 --> 00:15:59.770
For example, apple clang.

227
00:15:59.770 --> 00:16:00.790
It makes it mandatory.

228
00:16:00.790 --> 00:16:04.810
That main is the entry point to the execution, aesthetic and dynamic.

229
00:16:04.810 --> 00:16:06.910
Libraries don't require a main entry point.

230
00:16:06.910 --> 00:16:07.750
Same with Java.

231
00:16:07.750 --> 00:16:13.990
If you're creating just a library, so some functions that can be used in another cases, then you don't

232
00:16:13.990 --> 00:16:18.670
need to have main method because your goal is not to create an executable binary.

233
00:16:18.670 --> 00:16:24.910
Your goal is to create an archive binary, a binary that has some function declarations and implementation,

234
00:16:24.910 --> 00:16:26.980
but you cannot execute that file, right?

235
00:16:27.940 --> 00:16:35.140
So the C++ main, the signature is INT Main, and then you can decide whether you want to take arguments,

236
00:16:35.140 --> 00:16:36.570
command line arguments or not.

237
00:16:36.580 --> 00:16:37.120
Right.

238
00:16:37.240 --> 00:16:43.720
And if you if you go back here, you see in my main method, I decided not to take any arguments.

239
00:16:43.720 --> 00:16:43.930
Right?

240
00:16:43.930 --> 00:16:52.030
So if I go back here and try to say my app, hyphen, hyphen or some value, let's say hello, it just

241
00:16:52.030 --> 00:16:55.420
disregards this because this doesn't mean anything to my application.

242
00:16:55.420 --> 00:16:55.960
All right.

243
00:16:56.380 --> 00:17:02.560
Now, if we say if we want to accept command line arguments, you have to declare ARG, see the count

244
00:17:02.560 --> 00:17:08.700
of the arguments and can start a star, for example, arg v, right.

245
00:17:09.340 --> 00:17:10.540
Something like that.

246
00:17:10.810 --> 00:17:13.660
Or you can say an array of characters.

247
00:17:13.660 --> 00:17:15.700
So this is a two dimensional array, right?

248
00:17:15.700 --> 00:17:17.580
Which means an array of strings.

249
00:17:17.590 --> 00:17:23.470
So array of strings is basically an array of array of characters.

250
00:17:25.730 --> 00:17:26.060
Right.

251
00:17:26.060 --> 00:17:30.410
An array of characters is a string, and then you have to take an array of strings.

252
00:17:30.410 --> 00:17:33.050
So if you save these, let's see if we can compile

253
00:17:35.180 --> 00:17:38.000
C++ and it it compiles fine.

254
00:17:38.000 --> 00:17:38.480
Right.

255
00:17:38.480 --> 00:17:41.630
But again, if I launch my application, it works.

256
00:17:41.630 --> 00:17:45.080
But it disregards this command line arguments because I'm not using.

257
00:17:45.320 --> 00:17:49.460
So let's check the let's check the command line.

258
00:17:49.850 --> 00:17:57.260
Check the command line arguments in arguments in C++.

259
00:17:57.560 --> 00:18:11.030
So let's say steady C out and in and let's create some separation here, backslash n and then std c

260
00:18:11.030 --> 00:18:11.660
out.

261
00:18:11.690 --> 00:18:20.570
We're going to say are C equals and in arg c, this is the count of the arguments and you will see that

262
00:18:20.840 --> 00:18:29.150
actually the count is a it also counts then the name of the application.

263
00:18:29.150 --> 00:18:29.450
Right.

264
00:18:29.450 --> 00:18:32.240
As the as the argument.

265
00:18:32.660 --> 00:18:33.470
So this is the.

266
00:18:37.290 --> 00:18:43.410
And then next we want to basically write a for loop and iterate through this.

267
00:18:43.860 --> 00:18:49.680
So basically, we know the number of arguments that are passed to our main method, right to our C++

268
00:18:49.680 --> 00:18:50.630
application.

269
00:18:50.640 --> 00:18:56.610
And then this is a character array which is a string and array.

270
00:18:56.610 --> 00:19:01.270
So this is a array of a strings or array of character arrays.

271
00:19:01.290 --> 00:19:05.100
A character is a string and then array of strings.

272
00:19:05.100 --> 00:19:10.380
So we say four int I equals zero i less than arg c, right.

273
00:19:10.420 --> 00:19:13.080
I plus plus this is obviously in Java.

274
00:19:13.110 --> 00:19:16.500
You write arg width length because it's an array.

275
00:19:16.500 --> 00:19:19.280
And in Java, every built in array has a length field.

276
00:19:19.290 --> 00:19:23.340
But in C++, the built in array type doesn't have any feel.

277
00:19:23.340 --> 00:19:26.220
It's purely like it's just a block of memory.

278
00:19:26.220 --> 00:19:32.820
That's why your application or the operating system has to also tell your application how many command

279
00:19:32.820 --> 00:19:33.810
line arguments were passed.

280
00:19:33.810 --> 00:19:37.050
And we know that this is the terminal does this job right.

281
00:19:37.500 --> 00:19:44.820
And the other thing is that INT is a signed integer and it is recommended in modern C++ to instead of

282
00:19:44.820 --> 00:19:48.420
using it use size to type, right.

283
00:19:48.420 --> 00:19:50.760
So the size D is platform dependent.

284
00:19:50.760 --> 00:19:55.350
And I believe when you include something like iOS trim, the size is already there.

285
00:19:55.350 --> 00:19:59.910
So if we open declaration, for example, let's see if we can open it up now.

286
00:20:00.810 --> 00:20:07.080
So I see right now because this is not a C++ project, it doesn't really can find it, but size D,

287
00:20:07.080 --> 00:20:15.870
if you include iOS, it's there and it's sized in modern 64 bit platform is equivalent to, for example,

288
00:20:15.870 --> 00:20:22.050
unsigned, long unsigned line or 64 bit integer, 64 bit integer.

289
00:20:22.050 --> 00:20:27.660
It's more about the address and we know that in Java arrays can only be indexed with integers, which

290
00:20:27.660 --> 00:20:28.710
are 32 bit.

291
00:20:28.740 --> 00:20:36.720
However, in modern C++, they decided to standardize the the type of index for the arrays, which is

292
00:20:36.720 --> 00:20:38.940
60 and it's platform dependent.

293
00:20:39.660 --> 00:20:49.290
And then we're going to say that stdc out and we're going to say arg v at index I right.

294
00:20:50.070 --> 00:20:59.880
Is going to be equal to and then we're going to say ARG, we add index I and we're going to also push

295
00:20:59.880 --> 00:21:03.120
a backslash n to the to the.

296
00:21:04.300 --> 00:21:04.990
Terminal, right?

297
00:21:04.990 --> 00:21:07.900
So this is how we do it.

298
00:21:07.900 --> 00:21:16.210
So we're we're saying that Arc V at Index II is equal to the value of this string area right at Index

299
00:21:16.210 --> 00:21:16.560
II.

300
00:21:16.570 --> 00:21:19.030
So let's open up the terminal here.

301
00:21:20.590 --> 00:21:22.030
And then we're going to compile.

302
00:21:22.030 --> 00:21:30.100
Note that right now we're not using any extra libraries, so we're just going to use the simple command

303
00:21:30.100 --> 00:21:35.860
line G plus and then we're going to say example, dot, CP hyphen.

304
00:21:35.860 --> 00:21:40.240
Oh, it means that name the output file with my app.

305
00:21:41.050 --> 00:21:43.780
So again, G plus plus.

306
00:21:43.780 --> 00:21:51.850
First it runs the compiler, your CP becomes an object file and then after that.

307
00:21:53.560 --> 00:22:00.220
The linker kicks in and then it combines all the object files to create the output executable.

308
00:22:00.220 --> 00:22:07.630
And then we say that in my app and right now it prints and it says that r seven and then arg v zero

309
00:22:07.630 --> 00:22:08.830
is dot my app.

310
00:22:08.830 --> 00:22:16.660
So again, in C++ applications, the first argument is always the name of the application, whatever

311
00:22:16.660 --> 00:22:19.240
you actually type on the operating system, right?

312
00:22:19.240 --> 00:22:27.640
So the first argument, argument adding is always the name of the application, right?

313
00:22:27.640 --> 00:22:37.540
So if you pass a what this means is that I just typed dot my app, I could say my app and then hello,

314
00:22:37.720 --> 00:22:42.940
how are you doing right now.

315
00:22:42.940 --> 00:22:43.460
These.

316
00:22:43.510 --> 00:22:45.730
Hello, how are you doing these strings.

317
00:22:45.730 --> 00:22:51.010
Each one of them is going to be considered a command line argument and it's going to be passed to this

318
00:22:51.280 --> 00:22:52.690
very area with strings.

319
00:22:52.690 --> 00:22:56.230
But hello is not going to be at index zero.

320
00:22:56.230 --> 00:23:00.400
So we are running a application which was compiled from C++.

321
00:23:00.400 --> 00:23:05.050
And in general what happens is that the name of the application, whatever you type, either a relative

322
00:23:05.050 --> 00:23:09.190
path to the name of the executable or the absolute path.

323
00:23:09.190 --> 00:23:11.490
This is always the first argument in ARG.

324
00:23:11.490 --> 00:23:18.500
V So if you run this as you see RC six whereas we passed five command line arguments because our guide

325
00:23:18.550 --> 00:23:26.050
index zero is whatever we type for the path to the executable and then are given at index one which

326
00:23:26.050 --> 00:23:28.900
is the silicon index is this hello.

327
00:23:28.900 --> 00:23:29.560
Right.

328
00:23:29.560 --> 00:23:35.920
So this is how the C++ application work when you compile them to the native executable binary.

329
00:23:36.100 --> 00:23:41.380
However, now we see that there's actually a difference between that and the Java application.

330
00:23:41.380 --> 00:23:43.600
So let's go back to our Java application.

331
00:23:43.600 --> 00:23:46.840
Hello World and I have already wrote that.

332
00:23:47.200 --> 00:23:55.600
So again, a string arrays if you compile your java application this hello world that Java and then

333
00:23:55.600 --> 00:23:57.190
you compile it to hell over that class.

334
00:23:57.190 --> 00:23:58.570
Let's quickly do it.

335
00:23:58.570 --> 00:23:59.920
Java C hyphen.

336
00:24:00.880 --> 00:24:05.620
I've already defined a class path, so let's check that class path.

337
00:24:05.860 --> 00:24:10.180
So it already has test three directory test and then test two.

338
00:24:10.180 --> 00:24:11.050
So all these three.

339
00:24:11.050 --> 00:24:15.400
So when I'm compiling my main class, I don't need to specify hyphen php.

340
00:24:15.400 --> 00:24:20.920
So Java C dot dot go to the test and then helloworld java.

341
00:24:21.370 --> 00:24:24.940
So there is an error somewhere.

342
00:24:26.070 --> 00:24:27.210
So let's see.

343
00:24:27.210 --> 00:24:28.740
Line 36.

344
00:24:31.000 --> 00:24:36.940
So I guess we have an extra brace here, so maybe we can just remove this.

345
00:24:37.930 --> 00:24:40.120
And I think this one is for the main method.

346
00:24:40.120 --> 00:24:40.360
Yeah.

347
00:24:40.360 --> 00:24:41.950
So we had an extra brace.

348
00:24:42.700 --> 00:24:46.180
So let's go back clear and run our job application.

349
00:24:46.180 --> 00:24:54.490
And then now it's compiled finds and then we say Java hello of old and we don't specify that class and

350
00:24:54.490 --> 00:25:02.260
I'm not specifying the CPP class path and then I'm in an example directory, not in the test data.

351
00:25:02.260 --> 00:25:10.450
So but this works fine because it if you don't explicitly write hyphen CPP, Java JVM looks for the

352
00:25:10.450 --> 00:25:14.050
environment variable basically class path.

353
00:25:14.050 --> 00:25:17.560
Right now what you see here is that the same behavior.

354
00:25:17.560 --> 00:25:19.240
But look at the RC here.

355
00:25:19.240 --> 00:25:21.400
RC is the dot length.

356
00:25:21.400 --> 00:25:29.050
We know that in Java, arrays built in arrays or arrays basically have a final feed called length.

357
00:25:29.050 --> 00:25:35.740
So you already know the length of and only the type of indices that the arrays accept is the int right.

358
00:25:35.740 --> 00:25:40.120
You cannot do, for example, lying here, it's going to cause a compilation error.

359
00:25:40.120 --> 00:25:46.320
So I'm going to do it here and then I'm just printing to console.log.

360
00:25:46.330 --> 00:25:51.940
We add index percentage percent s I'm using the formatted command which was added, I believe from JDK

361
00:25:51.940 --> 00:25:53.950
15, which is a very nice feature.

362
00:25:53.980 --> 00:25:59.980
Or you can use the static method string format, but I prefer to type the string first and then call

363
00:25:59.980 --> 00:26:03.610
the non static method formatted which is very nice feature.

364
00:26:04.120 --> 00:26:09.490
And then what you see that not only you can pass the command line arguments to your job application

365
00:26:09.490 --> 00:26:13.810
and the way you do it is after invoking the JVM on the main class.

366
00:26:13.810 --> 00:26:18.760
So you tell JVM which class is the entry point to your job application, which one has the main method

367
00:26:18.760 --> 00:26:20.560
and after that you can type.

368
00:26:20.560 --> 00:26:23.080
Hello, how are you doing?

369
00:26:23.080 --> 00:26:23.610
Right.

370
00:26:23.620 --> 00:26:28.210
All of these five are going to be passed as the command line arguments.

371
00:26:28.240 --> 00:26:29.290
Your string array.

372
00:26:29.860 --> 00:26:30.190
All right.

373
00:26:30.190 --> 00:26:35.350
You see, we have RC five, which means the length of this string area is five and at index zero is.

374
00:26:35.350 --> 00:26:37.360
Hello, how are you doing?

375
00:26:37.360 --> 00:26:37.840
Right.

376
00:26:37.840 --> 00:26:45.040
So unlike the C++ application, when you compile them and the name of the application is not part of

377
00:26:45.040 --> 00:26:47.860
this string array, which because JVM already knows that.

378
00:26:47.860 --> 00:26:48.100
Right.

379
00:26:48.100 --> 00:26:50.380
So and the terminal so doesn't pass it.

380
00:26:50.560 --> 00:26:53.590
But then you see I have this name Arrow.

381
00:26:53.590 --> 00:26:54.760
Now what is this?

382
00:26:54.760 --> 00:27:01.240
So in Java you can also set parameters for the JVM for the Java application, right?

383
00:27:01.240 --> 00:27:07.270
So remember when you launch the Java, you use the Java Command, it's an executable binary which launches

384
00:27:07.270 --> 00:27:07.570
Java.

385
00:27:07.720 --> 00:27:14.410
So it's a native application and you can pass arguments directly to the Java.

386
00:27:15.280 --> 00:27:19.990
So when you use JVM to launch your job application, there are two different things at play.

387
00:27:20.020 --> 00:27:24.340
One is your application, which has the main method, right?

388
00:27:24.340 --> 00:27:25.990
That's the entry point to your job application.

389
00:27:25.990 --> 00:27:30.280
And then you can pass arguments to that, a main method using the string args.

390
00:27:30.280 --> 00:27:38.020
But then Java itself you can change or set properties for the JV that loads your Java application.

391
00:27:38.020 --> 00:27:38.200
Right.

392
00:27:38.200 --> 00:27:39.820
So you can configure the JVM.

393
00:27:39.820 --> 00:27:46.720
So one of the ways that you can do it, you can use the system properties and these are like a dictionary.

394
00:27:46.720 --> 00:27:52.720
So using hyphen dx, any command line arguments when you type your java, hello.

395
00:27:52.720 --> 00:27:58.570
And then some command line arguments if you type hyphen DX, some key equals some value.

396
00:27:58.600 --> 00:28:01.540
These are not going to be passed to the string array.

397
00:28:01.540 --> 00:28:02.410
So let's see.

398
00:28:02.410 --> 00:28:06.580
So Java Helloworld hyphen name equals bar and.

399
00:28:08.070 --> 00:28:15.990
Now, first of all, at the moment it does pass as a regular command in arguments because you didn't

400
00:28:15.990 --> 00:28:19.680
we put this hyphen the name equal Bob after the name of the class.

401
00:28:19.680 --> 00:28:23.460
So after the name of the class, your main class, anything else?

402
00:28:23.460 --> 00:28:25.530
Every string becomes a command line arguments.

403
00:28:25.530 --> 00:28:32.400
But there is another option for us, and that option is to put this hyphen DX before the name of the

404
00:28:32.400 --> 00:28:33.030
main class.

405
00:28:33.030 --> 00:28:39.420
So and therefore we are passing an argument or a property for the JVs equals bar.

406
00:28:40.050 --> 00:28:46.140
And now you see we have our C five, so Java hyphen D name equals Bob.

407
00:28:46.140 --> 00:28:46.290
Right?

408
00:28:46.290 --> 00:28:50.130
So what we did, we set a property for the JV team.

409
00:28:51.180 --> 00:28:57.330
So our axes are still five after our main class, we have five strings that are passed as the string

410
00:28:57.330 --> 00:28:58.140
array, right?

411
00:28:58.680 --> 00:29:05.220
But then we have this name, Bob, and the way we access these or check these system properties, the

412
00:29:05.220 --> 00:29:11.130
JV team configuration or JV and properties are using the system DOT Get Property Command.

413
00:29:11.820 --> 00:29:13.230
So there is a difference here.

414
00:29:13.230 --> 00:29:16.530
So we have two types of command joint arguments for Java application.

415
00:29:16.530 --> 00:29:19.440
One is the ones that are passed as the string array.

416
00:29:19.470 --> 00:29:25.080
These are command line arguments for your job application, but there are other ones that start with,

417
00:29:25.080 --> 00:29:28.260
for example, hyphen DX key equals value, right?

418
00:29:28.290 --> 00:29:29.910
These are system properties.

419
00:29:29.910 --> 00:29:35.050
These are the properties of the JV team and you can access them in your Java code using system that

420
00:29:35.520 --> 00:29:40.170
get property and you pass a string and get property, returns the string.

421
00:29:40.170 --> 00:29:47.490
And if you if you can also check if this property is set by the user or not at the time of running the

422
00:29:48.180 --> 00:29:51.690
basically Java application.

423
00:29:51.690 --> 00:29:58.800
So if this method returns a null string, then it means that this property does not exist or has not

424
00:29:58.800 --> 00:29:59.610
been set.

425
00:30:00.180 --> 00:30:07.950
But if the user passes the property using hyphen dx name equals bob, then the this method system that

426
00:30:07.950 --> 00:30:12.660
get property returns a valid string and then I'm printing it.

427
00:30:12.660 --> 00:30:18.780
So again, if you just run this without that hyphen DX This property comes back as null, which means

428
00:30:18.780 --> 00:30:20.550
this property does not exist.

429
00:30:20.550 --> 00:30:27.030
But if we set this hyphen DX name, we call Bob and then you stand name becomes A now later when we

430
00:30:27.480 --> 00:30:29.640
compile our Java application.

431
00:30:30.610 --> 00:30:33.520
Well, we did grow old VM native image.

432
00:30:33.730 --> 00:30:34.600
We know that.

433
00:30:34.810 --> 00:30:38.250
We just typed the name of the application, just like a C++ one.

434
00:30:38.260 --> 00:30:41.290
And after that we have to pass a command line arguments.

435
00:30:41.320 --> 00:30:47.740
You see that when the native image compiles the Java application, the native executable binary still

436
00:30:47.770 --> 00:30:53.860
distinguishes between hyphen dx parameters and the strings that don't have hyphen.

437
00:30:54.340 --> 00:30:55.620
So we can quickly see this.

438
00:30:55.630 --> 00:31:03.670
So let's go up and then let's go in the we don't need to go into the test directory, but let's go there.

439
00:31:03.970 --> 00:31:12.670
I am going to delete this compilation, the old compilation and let's say gravel home being native image

440
00:31:12.670 --> 00:31:20.440
and just a hyphen c p class path and then a hello world.

441
00:31:20.980 --> 00:31:22.630
So hello world class.

442
00:31:22.630 --> 00:31:26.430
And then we want to put it in the same directory.

443
00:31:26.440 --> 00:31:28.900
Call it my Java app.

444
00:31:28.900 --> 00:31:29.500
Right?

445
00:31:29.710 --> 00:31:36.130
So it's going to put the output of the compiling this class which has a main method into the current

446
00:31:36.130 --> 00:31:39.880
working directory which is test and it's going to name it my Java app.

447
00:31:39.880 --> 00:31:45.190
So I just want to quickly show you what happens when you compile your native Java application to a native

448
00:31:45.190 --> 00:31:45.520
pioneer.

449
00:31:45.520 --> 00:31:48.370
Obviously I will go in in the future lectures.

450
00:31:48.370 --> 00:31:54.370
I will go into all the details of how to install this native image, how to set it up, and what these

451
00:31:54.370 --> 00:31:55.330
parameters are.

452
00:31:55.330 --> 00:32:01.630
And yeah, so for now, I just want to quickly show you what happens when you compile this and the difference

453
00:32:01.630 --> 00:32:09.430
between executing a native binary when it's it's coming from a compiling a job application versus what

454
00:32:09.430 --> 00:32:14.560
we already saw from compiling a C++ application into native binary.

455
00:32:14.560 --> 00:32:15.040
Right?

456
00:32:15.040 --> 00:32:15.910
So that's done.

457
00:32:15.910 --> 00:32:17.080
It was pretty quick.

458
00:32:18.130 --> 00:32:22.540
And now we say that my Java app hyphen name equals Bob.

459
00:32:22.570 --> 00:32:25.690
Hello, how are you doing?

460
00:32:25.690 --> 00:32:33.040
So right now we are running a native executable file exactly like a C++ application, but we are giving

461
00:32:33.040 --> 00:32:33.720
it to.

462
00:32:33.880 --> 00:32:37.840
So every string that comes after that is a command line argument.

463
00:32:37.840 --> 00:32:43.540
But this because this is compiled from Java application, it's going to distinguish between the ones

464
00:32:43.540 --> 00:32:49.150
that have hyphen DX, some key equals, some value and the other ones that don't start with hyphen dx.

465
00:32:49.600 --> 00:32:51.280
So as you can see it is still tells us.

466
00:32:51.280 --> 00:32:53.890
ARX five So hello, how are you doing?

467
00:32:53.890 --> 00:32:55.300
So five but why is that?

468
00:32:55.300 --> 00:33:01.540
It doesn't say it's six because this hyphen DX name is called Bob is considered as a system property.

469
00:33:01.540 --> 00:33:07.440
So again, when you compile with your native compiler two, you compile your Java applications.

470
00:33:07.450 --> 00:33:08.950
The native executed binary.

471
00:33:08.980 --> 00:33:15.880
That native executable binary still distinguishes between hyphen DX parameters and the regular strings.

472
00:33:15.880 --> 00:33:21.460
So I want you to understand this and this is a good advantage because you can then take advantage of

473
00:33:21.460 --> 00:33:28.510
these parameters and configure your applications separately from the command line arguments that the

474
00:33:28.510 --> 00:33:29.290
user parses.

475
00:33:29.290 --> 00:33:29.830
Right.

476
00:33:29.830 --> 00:33:31.300
So I hope you enjoyed this lecture.

477
00:33:31.300 --> 00:33:33.850
Please stay tuned and I'll see the next one.
