1
00:00:01,810 --> 00:00:04,660
Hello and welcome to another tutorial.

2
00:00:04,660 --> 00:00:08,950
We're going to continue our discussion on default platform tool chains.

3
00:00:08,950 --> 00:00:16,930
We saw Mac OS, which uses Apple Clang, we saw Linux Ubuntu which uses GCC and we saw Windows which

4
00:00:16,930 --> 00:00:22,480
uses by default Microsoft visual compiler, which you should install it and instead of the past environment

5
00:00:22,480 --> 00:00:23,200
variables.

6
00:00:23,710 --> 00:00:32,500
And now let's before jumping to the global VM native image, let's take a moment and discuss how we

7
00:00:32,500 --> 00:00:36,250
are going to set up our C++ development environment.

8
00:00:36,250 --> 00:00:46,960
And we've already saw that for a basically for a simple C++ application like one CP file, you probably

9
00:00:46,960 --> 00:00:52,930
can just do it in a command line, but if you want to develop a large C++ application, then you have

10
00:00:52,930 --> 00:00:55,300
to use some sort of IDE or build system.

11
00:00:55,300 --> 00:01:02,890
And the idea is the same for Java because both C++ and Java are similar in the way that they are aesthetically

12
00:01:02,890 --> 00:01:07,270
type languages and they have compilers that compile the source files.

13
00:01:07,270 --> 00:01:14,260
And we know that in the case of C++, the source file gets compiled to the native executable binary.

14
00:01:14,400 --> 00:01:22,870
In the case of Java, the source file gets compiled by the Java compiler or Java C to an intermediate

15
00:01:22,870 --> 00:01:28,060
level called a basically byte code or classifiers.

16
00:01:28,060 --> 00:01:30,790
Those are still binary files, but they are not.

17
00:01:31,600 --> 00:01:35,680
The operating system doesn't understand them, but the GM or Java virtual machine understands them.

18
00:01:36,730 --> 00:01:38,440
Now, obviously we're not.

19
00:01:38,560 --> 00:01:42,820
The focus of this course is not developing C++ applications.

20
00:01:43,090 --> 00:01:50,230
I will have a few lectures about native methods in Java and then once we get to the LLVM native.

21
00:01:51,480 --> 00:01:55,770
So the native methods in Java require using the Java native interface.

22
00:01:55,770 --> 00:01:56,040
Right.

23
00:01:56,040 --> 00:02:00,180
And which means we are calling some C++ functions from Java.

24
00:02:00,180 --> 00:02:03,190
So you bind a Java method to a C++ function.

25
00:02:03,210 --> 00:02:05,930
In that case, you have to write the C++ code.

26
00:02:06,120 --> 00:02:11,580
The bridge that allows this communication between a Java method and then C++.

27
00:02:11,610 --> 00:02:17,910
In that case, I will show you an example of how to write a C++ source file and then compile it to a

28
00:02:17,910 --> 00:02:23,940
dynamic library and then load it, load it back in Java and then use the native method in Java.

29
00:02:24,120 --> 00:02:31,020
So first of all, we need to set up some sort of C++ development environment after getting familiar

30
00:02:31,020 --> 00:02:34,350
with the default toolchain of our platform.

31
00:02:34,350 --> 00:02:34,650
Right.

32
00:02:34,650 --> 00:02:41,700
And we saw that the job we use the platforms toolchain or the compiler to convert source files to executable

33
00:02:41,700 --> 00:02:42,150
binaries.

34
00:02:42,150 --> 00:02:47,760
And when we say source files, it means C, C++ and mainly the modern C++.

35
00:02:47,760 --> 00:02:48,780
That's my focus.

36
00:02:48,990 --> 00:02:55,390
C++ source for the convention is that CPP headers are dot H or dot HTTP.

37
00:02:56,250 --> 00:03:01,350
My convention is to use dot CP for the source files and H for the header files.

38
00:03:01,350 --> 00:03:03,180
It is recommended to use an ID.

39
00:03:03,180 --> 00:03:04,650
It's highly recommended.

40
00:03:05,640 --> 00:03:06,780
Let's write it down.

41
00:03:06,780 --> 00:03:12,480
It's highly recommended to use an ID and then in the Mac OS ID you have a couple of options.

42
00:03:12,480 --> 00:03:15,990
Obviously the default ID that comes with MapQuest is Xcode.

43
00:03:15,990 --> 00:03:19,290
You just install the Xcode app and you can develop that code.

44
00:03:19,290 --> 00:03:22,080
BLOCK is open source vs code is open source.

45
00:03:22,080 --> 00:03:29,140
I believe even Microsoft Visual Studio has a mac version and I think the community edition is still

46
00:03:29,220 --> 00:03:29,850
free.

47
00:03:30,540 --> 00:03:40,440
So we're going to say RMS, Visual Studio, I believe there is a mac version available.

48
00:03:40,440 --> 00:03:45,510
And then my favorite is Eclipse EDT C Development Tool.

49
00:03:45,510 --> 00:03:53,460
And the reason is that I'm a big fan of Eclipse ID first of all, it runs on the JVM and it's platform

50
00:03:53,460 --> 00:03:54,210
independent now.

51
00:03:54,210 --> 00:04:00,390
Obviously Code block and V is code and all these IDs escrow doesn't have a Windows version or Linux

52
00:04:00,390 --> 00:04:06,180
version code block, I believe it has a mac OS and Linux a mac OS and Windows version.

53
00:04:06,180 --> 00:04:10,320
I'm not sure if a Linux version is available and RMS Visual Studio.

54
00:04:10,320 --> 00:04:15,450
I don't think there is a Linux version available, but Eclipse EDT, it's based on Java, right?

55
00:04:15,450 --> 00:04:18,720
It runs on a JVM and therefore it's platform independent.

56
00:04:18,720 --> 00:04:23,340
Basically, Eclipse Eclipse EDT is available for all platforms.

57
00:04:23,340 --> 00:04:27,020
Not only that, but the interface is exactly the same, right?

58
00:04:27,030 --> 00:04:31,890
Because the interface is designed in Java, so it's the same.

59
00:04:31,890 --> 00:04:39,330
That's why I'm a big fan of Eclipse EDT You go ahead and download Eclipse ID and then you can directly

60
00:04:39,330 --> 00:04:43,530
download an Eclipse ID version that already comes with the seed plugin.

61
00:04:43,530 --> 00:04:48,720
If you just eclipse a download the Eclipse ID that has the Java development tool by default, then you

62
00:04:48,720 --> 00:04:53,460
can just separately install the CD plugin from Eclipse Marketplace.

63
00:04:53,700 --> 00:05:00,450
And after that, once once you install and restart Eclipse, you have in the prospective list, there

64
00:05:00,450 --> 00:05:02,760
is a new perspective for C C++.

65
00:05:02,760 --> 00:05:08,370
And then once you switch to that, all the menus immediately switch to C++ development, right?

66
00:05:08,370 --> 00:05:16,200
And then you can create a C++ managed build project which so eclipse EDT by default, use it, you can

67
00:05:16,200 --> 00:05:19,200
select which kind of build system you want to use.

68
00:05:19,200 --> 00:05:24,930
Is it a C, make or make or just internal build the system of the eclipse?

69
00:05:24,930 --> 00:05:25,260
Right.

70
00:05:25,260 --> 00:05:31,140
I usually use the make system build, which is which I'm familiar with.

71
00:05:32,220 --> 00:05:37,170
Recent versions of the Eclipse CD also also work with the CME.

72
00:05:37,200 --> 00:05:37,800
Right?

73
00:05:37,800 --> 00:05:46,530
So basically you go to Eclipse Marketplace and search for C C development tool and then you just install

74
00:05:46,530 --> 00:05:49,710
it and after that you restart Eclipse and you're ready to go.

75
00:05:49,710 --> 00:05:56,400
So let's head to Eclipse here and I'm going to close all these files and then help we go to Eclipse

76
00:05:56,400 --> 00:06:00,930
Marketplace and in the marketplace, basically.

77
00:06:03,290 --> 00:06:07,270
It's a way to second for this to load and then you can search for creat.

78
00:06:07,310 --> 00:06:16,340
Obviously I've already installed it and the perspective is available and so once this start finishes

79
00:06:16,340 --> 00:06:19,850
loading, we can search for the Crete.

80
00:06:20,420 --> 00:06:21,670
Now there are some tabs here.

81
00:06:21,680 --> 00:06:24,040
Search recent popular favorites and installed.

82
00:06:24,050 --> 00:06:32,590
If you're not sure if you've installed a CDB four so you can go to the install tab and then see if Crete

83
00:06:32,900 --> 00:06:33,490
is installed.

84
00:06:33,500 --> 00:06:35,270
I've already installed this, right.

85
00:06:35,510 --> 00:06:42,740
And then once you install and restart, you come here, this corner, this is the window that you add

86
00:06:42,740 --> 00:06:43,610
perspectives, right?

87
00:06:43,610 --> 00:06:47,930
I have Java perspective, C, C, C++ perspective and even Python.

88
00:06:47,930 --> 00:06:52,790
So Eclipse IDE allows you to seamlessly jump between development.

89
00:06:52,820 --> 00:07:00,950
You can even install a plugin for developing Fortran and so you can seamlessly jump between different

90
00:07:01,040 --> 00:07:01,580
perspectives.

91
00:07:01,580 --> 00:07:09,770
So this is your perspective menu and I have the option to select C++, Java or Python if you install

92
00:07:09,770 --> 00:07:11,270
Fortran, for example.

93
00:07:11,450 --> 00:07:17,510
And you have a perspective for for right now if you look at the main, for example, the file new Java

94
00:07:17,510 --> 00:07:19,670
project package class interface.

95
00:07:19,970 --> 00:07:22,010
So these are related to Java development.

96
00:07:22,100 --> 00:07:28,400
If I switch to C perspective and by the way, each perspective, you can also set it to have a different

97
00:07:28,400 --> 00:07:31,040
window configuration, which is very nice, right?

98
00:07:31,040 --> 00:07:38,510
If I jump back to my java, you see the tabs are different, C++, the tabs are different, Python it's

99
00:07:38,510 --> 00:07:38,930
different.

100
00:07:38,930 --> 00:07:43,370
So it's very nice that you can seamlessly jump between different developments.

101
00:07:43,370 --> 00:07:50,300
So if I jump to the C++ development and look at the files new Makefile project with existing code C++

102
00:07:50,300 --> 00:07:54,020
project project, convert a C++ R to tools project.

103
00:07:54,020 --> 00:08:03,590
So all the all the menus now are basically a change to C++ development, which is very nice.

104
00:08:03,590 --> 00:08:04,040
Right?

105
00:08:04,040 --> 00:08:07,250
So what do you do once you jump to the C++ perspective?

106
00:08:07,250 --> 00:08:09,890
Right click new C++ project.

107
00:08:09,890 --> 00:08:13,490
And so you see we have different options.

108
00:08:13,490 --> 00:08:16,820
C management, obviously we want to create a C++.

109
00:08:17,030 --> 00:08:21,530
So C++ manage build using the managed build system.

110
00:08:21,530 --> 00:08:26,990
So this is the internal it's management.

111
00:08:27,020 --> 00:08:32,360
Now you can select a C project, so you have to have C make install and then you configure it.

112
00:08:32,840 --> 00:08:38,600
Makefile project create a new project that builds with the make build tool using this new core bell

113
00:08:38,620 --> 00:08:38,870
system.

114
00:08:38,870 --> 00:08:45,680
This is experimental and then you can also select this one mission project.

115
00:08:45,680 --> 00:08:54,710
So I'm going to select the C++ managed build and then what it's going to do on any platform, it basically

116
00:08:54,710 --> 00:08:57,170
automatically recognizes your toolchain.

117
00:08:57,200 --> 00:09:02,420
A toolchain is a set of tools compiler linker assembler intended to build your project.

118
00:09:02,420 --> 00:09:08,120
Additional tools like a debugger can be associated with Tuesday, so Eclipse EDT usually automatically

119
00:09:08,120 --> 00:09:14,750
picks up on the or detects the the default toolchain of your operating system, which is very nice.

120
00:09:14,750 --> 00:09:18,200
And usually what I do I create a executable project.

121
00:09:18,200 --> 00:09:26,720
Hello world just to quickly so test CTT to quickly compile make sure everything is fine so I'm not going

122
00:09:26,720 --> 00:09:34,040
to add any other I'm going to manage all my C++ files into a CRC directory next and then you can select

123
00:09:34,040 --> 00:09:36,680
whether you want to compile in release and debug mode.

124
00:09:36,680 --> 00:09:40,640
Right now I'm just going to show it demo, so I'm not going to compile in debug, I'm just going to

125
00:09:40,640 --> 00:09:41,600
compile and release.

126
00:09:41,600 --> 00:09:47,660
And the difference here is that it just passes different flags to the default toolchain to the C++ compiler,

127
00:09:47,660 --> 00:09:52,940
right in release you get hyphen oh three, which means the maximum level of optimization and finish.

128
00:09:53,270 --> 00:09:56,510
And now it's going to create this test CD project.

129
00:09:58,080 --> 00:10:03,390
And then it automatically picks up on your default toolchain and adds all the default to include directories.

130
00:10:03,390 --> 00:10:03,630
Right?

131
00:10:03,630 --> 00:10:09,180
In order to develop C++ applications, you have to add all the header files necessary.

132
00:10:09,180 --> 00:10:09,600
Right.

133
00:10:09,600 --> 00:10:11,570
And we've seen these header files.

134
00:10:11,580 --> 00:10:12,660
These are in there.

135
00:10:13,410 --> 00:10:20,580
Basically, they come with the X Code app and then the X code tool and then all the header files and

136
00:10:20,580 --> 00:10:23,310
then also some command line tools cards.

137
00:10:23,610 --> 00:10:25,950
And so these are different libraries.

138
00:10:25,950 --> 00:10:33,120
So basically based on your default toolchain eclipse, it figures out what are all the header files

139
00:10:33,120 --> 00:10:34,770
that are available for your development.

140
00:10:34,770 --> 00:10:39,240
Now in MapQuest and Linux, there is an extra folder per user.

141
00:10:39,240 --> 00:10:42,120
It's called user locale include.

142
00:10:42,120 --> 00:10:49,590
So if you've installed additional C++ libraries, for example, I've installed Boost and then all the

143
00:10:49,590 --> 00:10:51,690
header files for the boost are available.

144
00:10:51,690 --> 00:10:56,850
And then once you compile, you can also link to the binaries, static libraries or dynamic libraries.

145
00:10:56,850 --> 00:10:59,310
So these are different libraries.

146
00:10:59,310 --> 00:11:02,940
For example, boost GSL your new scientific library.

147
00:11:02,940 --> 00:11:09,750
I've added I've also installed it manually on my computer, so not only it picks up on the default toolchain,

148
00:11:09,750 --> 00:11:15,720
it also tries to pick up all the C++ libraries that you as a user have installed.

149
00:11:15,720 --> 00:11:22,080
And this made this user local include obviously only exists for macOS and Linux on Windows.

150
00:11:22,080 --> 00:11:26,430
You kind of need to figure out what to do and I'll show you how to do it maybe in the future lectures.

151
00:11:26,430 --> 00:11:34,800
But for now I'm going to focus on just a quick demo based on macros, right.

152
00:11:34,800 --> 00:11:43,020
So if you cannot if your ID doesn't pick up on the basically default toolchain, you can go to right

153
00:11:43,020 --> 00:11:50,130
click, go to the properties of your C C++ project and you have to manually configure this build.

154
00:11:50,700 --> 00:11:55,980
So right now it tells me that this build is the configuration is released, you can manage it, you

155
00:11:55,980 --> 00:12:03,600
can add a debug and then build the build type is external builder and it's by default is using the make

156
00:12:03,990 --> 00:12:07,680
and let's see if I have make installed on my computer.

157
00:12:07,680 --> 00:12:13,740
So let's open up a new obviously in order to be able to do this make should be available on your operating

158
00:12:13,740 --> 00:12:20,550
system which means the issue the terminal should be able to find it which make user being make so make

159
00:12:20,550 --> 00:12:23,790
hyphen hyphen version and make right.

160
00:12:23,790 --> 00:12:28,020
And I believe once you it comes with the x code.

161
00:12:28,260 --> 00:12:33,660
So if you don't have Mac installed, you have to install it.

162
00:12:33,660 --> 00:12:38,820
It's I believe it's an open source thing and you can use it.

163
00:12:38,820 --> 00:12:42,300
You can basically switch the internal builder.

164
00:12:42,600 --> 00:12:49,140
The the difference is that with the match builder it creates a makefile and then you can compile using

165
00:12:49,140 --> 00:12:55,860
the make and it does that internal builder, it doesn't you use the Makefile so it doesn't create a

166
00:12:55,860 --> 00:13:00,660
Makefile that you can even use it on the terminal to compile.

167
00:13:00,660 --> 00:13:07,200
So for now I'm going to start with the external builder generate make false automatically expand environment

168
00:13:07,200 --> 00:13:09,690
variable references, make files that's good.

169
00:13:09,690 --> 00:13:11,730
And it also shows the bell directory.

170
00:13:12,690 --> 00:13:19,230
Right now my configuration is released so it creates a directory called release and puts the binaries

171
00:13:19,230 --> 00:13:20,400
there in the release.

172
00:13:20,580 --> 00:13:21,240
All right.

173
00:13:21,240 --> 00:13:25,290
And then the behavior and use a standard build arguments.

174
00:13:25,290 --> 00:13:25,620
Right.

175
00:13:25,620 --> 00:13:32,730
And you can even do parallel building multi core if you think you have a large project and you want

176
00:13:32,730 --> 00:13:38,820
to do because the C++ compilers allow you to use multiple threads or multiple cores.

177
00:13:38,820 --> 00:13:39,150
Right.

178
00:13:39,150 --> 00:13:41,250
Right now we're just not going to use it.

179
00:13:41,290 --> 00:13:43,050
Use custom build arguments.

180
00:13:43,050 --> 00:13:46,620
These arguments will be passed to make command line arguments.

181
00:13:46,920 --> 00:13:52,410
But right now we're going to use the standard build arguments, workbench build, behavior build and

182
00:13:52,410 --> 00:13:53,450
resource save.

183
00:13:53,790 --> 00:13:58,200
So basically the idea is that you have work in space and if you change something, for example, in

184
00:13:58,200 --> 00:14:05,490
the source code, do you want to automatically rebuild the project or the default behavior is that you

185
00:14:05,490 --> 00:14:05,840
want to.

186
00:14:05,880 --> 00:14:11,940
So this is your build configuration, this hammer which is released and this is so when you click on

187
00:14:11,940 --> 00:14:15,090
this, it builds and this is the configuration release.

188
00:14:15,090 --> 00:14:17,070
So this one is the configuration.

189
00:14:17,490 --> 00:14:20,520
So right now I'm compiling to a executable.

190
00:14:20,520 --> 00:14:25,920
I have a main, so let's select our C project, C++ and run the build manually.

191
00:14:26,190 --> 00:14:30,300
So as you can see, it runs a few terminal commands.

192
00:14:30,300 --> 00:14:34,350
The first one is make all so what it does, it creates the Makefile.

193
00:14:34,350 --> 00:14:36,210
So let's look at the release.

194
00:14:36,210 --> 00:14:37,980
You see, we have the Makefile.

195
00:14:38,590 --> 00:14:45,940
Which just tells me include this makefile that you need and then remove all the files and then include

196
00:14:46,510 --> 00:14:48,430
that make source that make.

197
00:14:48,730 --> 00:14:52,060
And these are all the directories that will be included.

198
00:14:52,060 --> 00:14:54,730
It says that just include the Z in the make.

199
00:14:54,730 --> 00:15:05,830
Right, because this Z director has our source files and then make cmd goals and then CC dependencies,

200
00:15:05,830 --> 00:15:08,590
C++ dependencies, a lot of the options.

201
00:15:08,590 --> 00:15:17,800
So and then eventually the target is building this executable by including all these, by executing

202
00:15:17,800 --> 00:15:18,580
all these goals.

203
00:15:18,580 --> 00:15:18,960
Right.

204
00:15:18,970 --> 00:15:22,180
If you're not familiar with what makes this term is you can just.

205
00:15:24,520 --> 00:15:26,850
Basically Google it and get familiar.

206
00:15:26,860 --> 00:15:34,330
So after you create this binary, right, this is our executable binary right in the release, it also

207
00:15:34,330 --> 00:15:41,500
in the source also puts the object file or hyphen or these are the binaries and D is the directories

208
00:15:41,500 --> 00:15:44,620
that were used to create this object file.

209
00:15:44,620 --> 00:15:45,070
Right.

210
00:15:45,070 --> 00:15:52,410
So Z test also came from compiling Z test TCP.

211
00:15:52,420 --> 00:15:52,810
Right.

212
00:15:52,810 --> 00:15:58,870
So it tells you which CPP files were compiled to generate this object file.

213
00:15:58,870 --> 00:16:05,140
Right, so that this object file test or came from compiling this C++.

214
00:16:05,140 --> 00:16:07,690
So it gives you extra information.

215
00:16:08,480 --> 00:16:16,550
And you can just select your source file and hit run and it automatically said, let's write something

216
00:16:16,550 --> 00:16:17,090
here.

217
00:16:17,120 --> 00:16:17,900
Hello.

218
00:16:17,960 --> 00:16:23,570
When you do that, eclipse automatically executes the binary that it compiled.

219
00:16:23,570 --> 00:16:25,130
So I changed something.

220
00:16:25,130 --> 00:16:26,630
So let's build again.

221
00:16:27,320 --> 00:16:29,270
It builds, and then let's run.

222
00:16:31,230 --> 00:16:31,950
And he works fine.

223
00:16:31,950 --> 00:16:36,330
So again, when you hit run on your source file, what happens?

224
00:16:36,570 --> 00:16:39,120
Eclipse actually executes this binary.

225
00:16:39,120 --> 00:16:43,470
So if I manually delete this binary and hit run.

226
00:16:44,240 --> 00:16:45,210
And it says mad.

227
00:16:45,230 --> 00:16:47,000
It says binary, not found.

228
00:16:47,000 --> 00:16:47,410
Right.

229
00:16:47,420 --> 00:16:52,720
So basically when you run the source file, I don't want you to get the wrong idea.

230
00:16:52,730 --> 00:16:57,710
What actually happens is that it clips, executes that the binary that has the name right.

231
00:16:57,860 --> 00:17:01,760
But right now it says, I cannot find a binary, so you have to build it again.

232
00:17:01,760 --> 00:17:07,700
And now you build it and you get the binary and then it can run it.

233
00:17:07,700 --> 00:17:12,650
So so when you run a source file, it doesn't mean that it keeps running the source for it just means

234
00:17:12,650 --> 00:17:16,560
it keeps runs the binary that is associated with the executable binary.

235
00:17:16,580 --> 00:17:21,020
Now obviously we can also open a terminal here and manually run the binary.

236
00:17:21,050 --> 00:17:22,460
I've shown you how to do it.

237
00:17:22,460 --> 00:17:29,360
You just in the Mac OS and Linux, the current working directory which is our release, does not by

238
00:17:29,360 --> 00:17:36,590
default it does not get appended to the path you have to say DOT and then test CTT and it says hello.

239
00:17:36,590 --> 00:17:37,010
All right.

240
00:17:37,010 --> 00:17:42,200
So we can execute the binary just like any other native application in the terminal.

241
00:17:43,580 --> 00:17:48,050
Now what we can do here is what I'm going to do.

242
00:17:48,050 --> 00:17:50,450
I'm going to delete this release.

243
00:17:50,750 --> 00:17:54,410
And then so let's see.

244
00:17:55,110 --> 00:17:58,200
So you can also look at the outline of your application.

245
00:17:58,200 --> 00:17:59,640
We're including iOS Stream.

246
00:17:59,640 --> 00:18:00,330
We don't.

247
00:18:00,420 --> 00:18:06,330
The best practice is to not so use the open up the entire STD namespace.

248
00:18:06,330 --> 00:18:08,700
Same with this one and line.

249
00:18:08,700 --> 00:18:13,500
And then you can build this write, build, release.

250
00:18:14,620 --> 00:18:17,560
So you can now recompile again.

251
00:18:17,560 --> 00:18:23,620
And as you can see, Eclipse actually uses the G plus plus hyphen O three, which means Eclipse just

252
00:18:23,830 --> 00:18:28,810
calling the G plus plus compiler, which is our default toolchain.

253
00:18:28,810 --> 00:18:35,440
And it also tells you that I found the GCC C++ compiler, the command is G plus plus and also tells

254
00:18:35,440 --> 00:18:40,780
you which flags it's passing to to the compiler to compile your CP file.

255
00:18:40,780 --> 00:18:43,240
Hyphen O three is maximum optimisation.

256
00:18:43,240 --> 00:18:45,130
That's why we are compiling the release mode.

257
00:18:45,130 --> 00:18:52,930
Hyphen W O means, show all the warning, hyphen C and then hyphen F, message length zero hyphen MD

258
00:18:52,930 --> 00:18:54,910
and then which directories?

259
00:18:54,910 --> 00:18:59,650
And then we're compiling this test CD2.

260
00:18:59,680 --> 00:19:00,940
CP Right.

261
00:19:02,240 --> 00:19:09,560
Now the question is what is the working directory when, um, when eclipse launches the compiler and

262
00:19:09,560 --> 00:19:16,220
as you can see, the relative directory is one go, one level up and then Z and then tested TCP.

263
00:19:16,280 --> 00:19:23,060
So basically what happens is that when you build run the build eclipse seed, it changes the current

264
00:19:23,060 --> 00:19:26,330
working directory to the release directory.

265
00:19:26,330 --> 00:19:26,840
Right.

266
00:19:27,050 --> 00:19:33,350
And then in order to get access to the CPP, you have to go one level up and then you go into the root

267
00:19:33,380 --> 00:19:38,180
of the C++ project and then go to the Z and then test CP.

268
00:19:38,210 --> 00:19:42,800
Now we could actually let's delete all these files.

269
00:19:43,900 --> 00:19:50,080
And then let's open a terminal here, open a terminal in the release directory.

270
00:19:51,520 --> 00:19:55,420
Now we can manually compile our application because it's a very simple one.

271
00:19:55,420 --> 00:19:56,590
Source file application.

272
00:19:56,680 --> 00:19:59,580
C++ hyphen oh three, hyphen w all.

273
00:19:59,590 --> 00:20:09,220
And then go up and we can do use double code, go up into the CRC and then test T dot CP and we can

274
00:20:09,220 --> 00:20:15,100
compile again and then it puts it in the current working directory so we get a dot out.

275
00:20:15,100 --> 00:20:20,260
That's because we did not specify a particular name for the output.

276
00:20:20,260 --> 00:20:21,760
So we can also do that.

277
00:20:21,760 --> 00:20:26,500
So let's close this one in order to give it a specific name for the output.

278
00:20:26,500 --> 00:20:35,170
You say hyphen o, which means the output name and then let's say test hyphen score CTT Right.

279
00:20:35,560 --> 00:20:40,300
And we compile now it puts it in the current working directory, which is this.

280
00:20:40,600 --> 00:20:42,820
And then if I right click and hit run.

281
00:20:44,860 --> 00:20:46,960
So let's see.

282
00:20:46,960 --> 00:20:52,360
Oh, so eclipse always tries to use the Makefile.

283
00:20:52,360 --> 00:20:59,770
So when you try to build with Eclipse, basically it, it cleans up all the files that are currently

284
00:20:59,770 --> 00:21:00,310
in the release.

285
00:21:00,310 --> 00:21:05,200
And if you look at the main file, the, the main, the first line is remove all the files that are

286
00:21:05,200 --> 00:21:07,570
in the current working directory, which is the release.

287
00:21:07,570 --> 00:21:07,960
Right.

288
00:21:07,960 --> 00:21:14,110
So it cleans up everything, all the current, all the binaries that were already compiled and then

289
00:21:14,260 --> 00:21:15,760
tries to redo.

290
00:21:15,760 --> 00:21:17,560
So let's clean this up.

291
00:21:18,540 --> 00:21:21,630
But right now we are directly compiling our applications.

292
00:21:21,630 --> 00:21:24,600
So we're not using any make build system, right?

293
00:21:24,600 --> 00:21:32,040
So when you just type G plus plus and then compile the C++ code source file to a executable binary,

294
00:21:32,040 --> 00:21:37,320
you're not using a make a build system, you're just directly invoking the compiler.

295
00:21:37,350 --> 00:21:42,540
Obviously, this only works for various small applications, but if the application gets large, then

296
00:21:45,000 --> 00:21:50,370
then you have to use some sort of build system, otherwise it easily goes out of control.

297
00:21:50,400 --> 00:21:51,030
All right.

298
00:21:51,030 --> 00:21:54,420
So what we're going to do, I'm going to delete this release.

299
00:21:55,170 --> 00:21:57,900
And then he bailed on our project.

300
00:21:57,900 --> 00:22:03,150
And now it creates all the make files and then executes the make write.

301
00:22:04,740 --> 00:22:13,890
Uh, so and again, to refresh your memory, there are two steps towards compiling a C++ source code

302
00:22:13,890 --> 00:22:15,210
to the native executable.

303
00:22:15,210 --> 00:22:22,560
One is compiling the CPP files, source files to object files, which are the binaries, and each CP

304
00:22:22,560 --> 00:22:28,980
gets compiled to a separate binary and then linker puts or connects all these object files together

305
00:22:28,980 --> 00:22:30,910
and creates one executable binary.

306
00:22:30,930 --> 00:22:31,200
Right.

307
00:22:31,200 --> 00:22:38,640
There are two stages and the command both for compiling and linking is the same.

308
00:22:38,640 --> 00:22:39,990
It's just C++.

309
00:22:39,990 --> 00:22:46,380
So based on the flags that you pass, C++ decides whether you're compiling or linking, right?

310
00:22:46,380 --> 00:22:53,370
If you just say G plus plus, it tries to do the compilation first and then linking.

311
00:22:53,370 --> 00:22:59,700
But if you just say hyphen C, so hyphen C is the flag that tells the G pass, hey, I just want to

312
00:22:59,700 --> 00:23:00,180
compile.

313
00:23:00,180 --> 00:23:05,340
Don't do the linking and I can show you by again clearing this.

314
00:23:05,760 --> 00:23:07,020
So let me write this here.

315
00:23:07,020 --> 00:23:19,230
So C++ by default, by default first runs the compilation and then runs a linking.

316
00:23:19,230 --> 00:23:24,780
If you just want to compile, create the object files which are the binaries you have to pass the hyphen.

317
00:23:24,810 --> 00:23:32,190
C So a flag hyphen c tells a g plus plus only compile don't link.

318
00:23:32,190 --> 00:23:32,820
Right.

319
00:23:33,300 --> 00:23:33,960
So.

320
00:23:34,320 --> 00:23:36,840
So if I open a terminal again here.

321
00:23:39,310 --> 00:23:46,720
So previously we use this command to directly compile to executable.

322
00:23:46,720 --> 00:23:54,340
But now what we're going to say is that we're going to say G plus plus hyphen oh three, hyphen W all

323
00:23:54,370 --> 00:23:58,270
hyphen C, right and then hyphen oh.

324
00:23:58,270 --> 00:24:02,020
The output is going to be dot O, for example.

325
00:24:02,620 --> 00:24:10,090
And if you look at the release mode, there is no release folder, there is no executable file, it's

326
00:24:10,090 --> 00:24:11,800
just a binary file object file.

327
00:24:11,800 --> 00:24:14,590
So if you open this up, it's just binary, right?

328
00:24:14,980 --> 00:24:22,600
And then if you want to convert this binary to a executable, you have to invoke the linker again,

329
00:24:22,600 --> 00:24:22,840
right?

330
00:24:22,840 --> 00:24:30,940
G plus plus and then test a CD dot or a hyphen or test my app, for example.

331
00:24:31,660 --> 00:24:39,070
And now if you have multiple object files, you list all of them here, and then the linker tries to

332
00:24:39,070 --> 00:24:42,310
combine them together into one single binary.

333
00:24:42,310 --> 00:24:45,790
And if I say my app, it's going to execute fine.

334
00:24:45,790 --> 00:24:51,700
Again, I'm telling you, this stuff, these are not directly relevant to Java development or compiling

335
00:24:51,700 --> 00:24:56,950
a Java application to native executable binary, but it's very helpful for you to understand what's

336
00:24:56,950 --> 00:25:01,960
going on when you're compiling some source file to native executable binary.

337
00:25:01,960 --> 00:25:02,560
Right?

338
00:25:03,610 --> 00:25:05,770
So back to the PowerPoint.

339
00:25:05,920 --> 00:25:12,850
So we can you can quickly install this C++ CD development environment and then it takes care of the

340
00:25:12,850 --> 00:25:14,320
make files and everything.

341
00:25:14,320 --> 00:25:16,720
You just add source files and then compile.

342
00:25:16,720 --> 00:25:21,100
Everything is very automatic, very nice, and then the next step is terminal.

343
00:25:21,100 --> 00:25:25,450
And I've already been using terminal quite some time in these lectures.

344
00:25:25,450 --> 00:25:29,830
And terminal, just a brief introduction or quick overview.

345
00:25:29,860 --> 00:25:36,580
Terminal is also known as command line console shell bash, which is born again Shell, etc. Right in

346
00:25:36,580 --> 00:25:37,030
windows.

347
00:25:37,030 --> 00:25:40,090
It's they call it command line or console.

348
00:25:40,360 --> 00:25:47,620
In Mac OS Linux, we call it Shell and terminal is the bridge between the human and the operating system.

349
00:25:47,620 --> 00:25:54,340
And it's a purely text based application, which means unlike a graphical interface, the terminal doesn't

350
00:25:54,340 --> 00:25:55,840
have any button that you can click.

351
00:25:55,840 --> 00:26:01,630
You basically end up typing a lot of stuff just like any other executable binary.

352
00:26:02,050 --> 00:26:07,090
It's a text based application and the way it works is let's close this.

353
00:26:07,690 --> 00:26:11,620
There are binary executable binary applications.

354
00:26:12,310 --> 00:26:20,470
If you want to tell the operating system or terminal to do something, you type a name, which then

355
00:26:20,470 --> 00:26:27,040
the operating system or the terminal interprets it as a application and executable binary.

356
00:26:27,040 --> 00:26:34,900
For example, ls ls is a application executable binary and lists the or basically the directories and

357
00:26:34,900 --> 00:26:36,070
the files, everything.

358
00:26:36,070 --> 00:26:41,770
If you type something that the terminal cannot find, it gives you an error saying that I cannot find

359
00:26:41,770 --> 00:26:42,160
it.

360
00:26:42,190 --> 00:26:48,340
Obviously I'm using a interactive shell which already highlights it in red, which means a terminal

361
00:26:48,340 --> 00:26:49,810
couldn't find this command.

362
00:26:51,380 --> 00:26:58,100
If I say blue means the terminal is able to locate this application or for example, make right.

363
00:26:58,100 --> 00:26:58,870
It's blue.

364
00:26:58,880 --> 00:27:03,460
If I say make two or makes a means, it cannot find it because it becomes red.

365
00:27:03,470 --> 00:27:10,460
And again, this is because I installed this fish friendly, interactive shell on top of my regular

366
00:27:10,460 --> 00:27:11,600
macOS terminal.

367
00:27:11,870 --> 00:27:12,470
All right.

368
00:27:13,580 --> 00:27:22,310
And terminal has a buffers or streams which are either input streams or output streams or error streams.

369
00:27:22,310 --> 00:27:28,670
And usually if you want to save the outputs, for example, if you if you run an application, let's

370
00:27:28,670 --> 00:27:29,900
run this one more time.

371
00:27:30,530 --> 00:27:36,560
So what happens here is that when you type, for example, ls this executable and the feedback that

372
00:27:36,560 --> 00:27:39,470
the terminal gives you is a text based feedback, right?

373
00:27:39,470 --> 00:27:46,220
Obviously this interactive shell has some highlighting etc., but it has a buffer or a character buffer

374
00:27:46,220 --> 00:27:48,770
that shows to the terminal.

375
00:27:48,890 --> 00:27:52,130
Now sometimes what you want to do, you want to save these.

376
00:27:52,130 --> 00:27:56,210
Whenever you have characters, characters or strings, you can save them to a file.

377
00:27:56,240 --> 00:28:01,790
So you can say ls on this directory and then a hyphen.

378
00:28:02,630 --> 00:28:09,680
Basically, you can tell it your direct the output of this application, which is a string to one to

379
00:28:09,680 --> 00:28:11,040
a file or something like this.

380
00:28:11,060 --> 00:28:20,150
Arrows means this arrow means grab the output of this application, which is a string and redirected

381
00:28:20,150 --> 00:28:22,760
to a file, for example, a text file or anything.

382
00:28:22,760 --> 00:28:23,180
Right.

383
00:28:23,450 --> 00:28:29,570
And if you want to filter some of them, there is a pipe operator instead of arrow.

384
00:28:29,570 --> 00:28:30,380
You have pipe.

385
00:28:30,410 --> 00:28:35,450
Pipe means when you use arrow, you are directing to a file, right?

386
00:28:35,450 --> 00:28:43,100
When you pipe, when you use the pipe, you are direct redirecting the output of these to another binary

387
00:28:43,100 --> 00:28:43,700
application.

388
00:28:43,700 --> 00:28:47,300
For example, grep grep is for filtering something, right?

389
00:28:47,300 --> 00:28:55,940
Let's say any application that any of the outputs, everything that starts with M or for example and

390
00:28:55,940 --> 00:29:02,060
it says movie and this interactive shell also tells me more is red, which means it was this was fine.

391
00:29:02,060 --> 00:29:07,730
So the pipe means a redirect, the output to the other application.

392
00:29:07,730 --> 00:29:09,980
So if you have a application, you execute it.

393
00:29:09,980 --> 00:29:15,470
And now you want to redirect the text output of this application to another application, you use the

394
00:29:15,470 --> 00:29:20,540
pipe operator if you use the arrow operator.

395
00:29:21,530 --> 00:29:23,030
Let's see if this works.

396
00:29:24,140 --> 00:29:29,750
No, because arrow means redirect the output to a file, not another application.

397
00:29:29,750 --> 00:29:31,280
Remember grep is also an application.

398
00:29:31,280 --> 00:29:34,310
So you redirecting the output to a file.

399
00:29:34,340 --> 00:29:35,930
No such file or directory.

400
00:29:35,930 --> 00:29:36,440
Right.

401
00:29:36,440 --> 00:29:38,870
With the arrows you can redirect the file.

402
00:29:38,870 --> 00:29:46,010
So if you want to read the context of a file and then take them as the input to an application, you

403
00:29:46,010 --> 00:29:51,860
can basically use the input as stream of the application.

404
00:29:51,860 --> 00:29:58,520
Right now, the arrow, if you right, type the name of application and then the arrow it means you're

405
00:29:58,520 --> 00:30:01,400
using the output buffer of the application or the terminal.

406
00:30:01,400 --> 00:30:01,820
Right.

407
00:30:01,820 --> 00:30:03,440
So I want you to understand this again.

408
00:30:03,440 --> 00:30:06,740
These mainly these concepts mainly apply to Mac OS and Linux.

409
00:30:07,190 --> 00:30:11,480
So Unix based operating systems interaction with the terminal is very important.

410
00:30:11,480 --> 00:30:13,910
Advanced users prefer working with terminal.

411
00:30:14,120 --> 00:30:20,720
The main reason is that terminal provides a scripting, so you can create a script that runs hundreds

412
00:30:20,720 --> 00:30:23,210
of commands using terminal, right?

413
00:30:23,210 --> 00:30:27,830
So you just run the script and it does a lot of things behind the scenes.

414
00:30:27,830 --> 00:30:34,130
It learns runs lots and lots of commands, which is very nice because now it gives you a way of automating

415
00:30:34,130 --> 00:30:41,870
a lot of routine tasks, a lot of commands, which is an application that runs in terminal and add some

416
00:30:41,870 --> 00:30:42,500
enhancements.

417
00:30:42,500 --> 00:30:44,810
It's available both for macOS and Linux.

418
00:30:44,810 --> 00:30:48,080
I highly recommend you install it and use it.

419
00:30:48,080 --> 00:30:55,370
It has a lot of highlighting features and even in my bash RC, I've set it to set by default.

420
00:30:55,370 --> 00:31:02,600
Any time I run a new terminal, it immediately runs fish so that I'm always in the fish shell instead

421
00:31:02,600 --> 00:31:03,500
of the original shell.

422
00:31:03,500 --> 00:31:09,890
If I want to exit the fish, I type exit and I go back to the Mac OS terminal, which is a little bit

423
00:31:09,890 --> 00:31:12,320
boring, it doesn't have any highlighting, etc..

424
00:31:12,320 --> 00:31:16,310
So I recommend you use the fish application, right?

425
00:31:16,310 --> 00:31:18,050
So I hope you really enjoy this lecture.

426
00:31:18,050 --> 00:31:20,450
Please stay tuned and I'll see the next one.
