WEBVTT
1
00:00:00.810 --> 00:00:03.840
Hello and welcome to another tutorial.

2
00:00:03.930 --> 00:00:09.990
I'm going to continue our discussion on creating a simple hello world and compiling it to a native executable

3
00:00:09.990 --> 00:00:10.690
binary.

4
00:00:10.710 --> 00:00:16.770
We saw this already on the Mac OS platform and Linux platform and I said that in your Linux, if you

5
00:00:16.800 --> 00:00:21.870
cannot compile, you probably are missing one of the one or more dependencies.

6
00:00:21.870 --> 00:00:23.640
So you can look at the output.

7
00:00:24.030 --> 00:00:29.550
What output or error native image tool creates right here.

8
00:00:29.550 --> 00:00:35.190
For example, I ran it and it tells me that it appears that Lib SDA is missing and then you search to

9
00:00:35.190 --> 00:00:42.090
Google and install the zlib one g hyphen dev for compilation.

10
00:00:42.300 --> 00:00:47.760
We looked at the output stages both in the Mac, like all the details and in this lecture I'm going

11
00:00:47.760 --> 00:00:49.620
to go into more details.

12
00:00:50.700 --> 00:00:53.100
What this means, just a brief introduction.

13
00:00:53.100 --> 00:00:58.080
We don't need to really be concerned that much with what this means.

14
00:00:58.080 --> 00:01:03.420
Eventually, if the compilation succeeds, we get the executable binary.

15
00:01:04.170 --> 00:01:12.660
But before that, let's also try to recap quickly how this native compilation works by creating a quick

16
00:01:12.660 --> 00:01:19.890
helloworld application in Java and then using the global VM native image on the Windows platform to

17
00:01:19.890 --> 00:01:21.870
compile it to native executable binaries.

18
00:01:21.870 --> 00:01:30.240
So install native image, you download download basically gradle VM and then use the Google Updater

19
00:01:30.240 --> 00:01:32.310
or the G2 in Windows.

20
00:01:32.310 --> 00:01:38.910
It's the shell script, so you have to use a dot cmd and then you have to install Microsoft Visual Studio

21
00:01:38.910 --> 00:01:45.510
Community Edition Native image on Windows only recognizes the default Windows platform toolchain, which

22
00:01:45.510 --> 00:01:48.060
is RMS, V.C. or Microsoft Visual Compiler.

23
00:01:48.060 --> 00:01:51.200
And then you have to run this script, shell script.

24
00:01:51.210 --> 00:01:55.290
We see WAAS 64 dot bat, which I already showed you where you can find it.

25
00:01:55.290 --> 00:02:03.970
You go into the build in the MSI community and then build auxiliary and then run this script.

26
00:02:03.990 --> 00:02:10.860
This sets up the correct environment variables for your shell or the command prompt so that it can know.

27
00:02:11.130 --> 00:02:17.700
It can find a slot x, which is the command line tool for calling the MSC compiler and native image

28
00:02:17.700 --> 00:02:23.880
relies on finding that sealed exit so that it can compile to native executable binary.

29
00:02:24.000 --> 00:02:31.470
And I also told you that the easiest way is to actually create an environment variable, a global environment

30
00:02:31.470 --> 00:02:38.910
variable, and then basically so that when you just type it and execute it, it executes this shell

31
00:02:38.910 --> 00:02:39.480
in terminal.

32
00:02:39.480 --> 00:02:46.500
So compile helloworld java with Java C, you can use JDK 17 or the Java Sea that comes with the LLVM

33
00:02:46.500 --> 00:02:49.140
17 and run native image CMD.

34
00:02:49.140 --> 00:02:51.210
So know that this is a command line script.

35
00:02:51.210 --> 00:02:56.970
This is not a native executable file, unlike Linux and Mac OS where the native image is actually an

36
00:02:56.970 --> 00:03:02.400
executable on Windows, it's just a command line script and a class file.

37
00:03:02.400 --> 00:03:08.250
So again, native image, we always run it on a class file, so let's head to windows and quickly do

38
00:03:08.250 --> 00:03:08.520
this.

39
00:03:08.520 --> 00:03:11.190
So here's my windows.

40
00:03:11.550 --> 00:03:16.170
I have created this test directory on my desktop and I am going to.

41
00:03:18.060 --> 00:03:20.640
So my virtual machine is running a little bit slow.

42
00:03:20.970 --> 00:03:27.030
But what I'm going to do, I'm going to open up a CMD or command prime, the simple command prompt in

43
00:03:28.320 --> 00:03:31.110
windows and then I'm going to create a Java file.

44
00:03:31.110 --> 00:03:31.710
Hello World.

45
00:03:31.710 --> 00:03:32.280
And then.

46
00:03:34.110 --> 00:03:35.910
Just print the hello wall to the council.

47
00:03:35.910 --> 00:03:41.560
So we're going to hear right click new.

48
00:03:41.580 --> 00:03:44.790
Let's create a text file and then rename it to something.

49
00:03:45.300 --> 00:03:46.560
Hello World Java.

50
00:03:51.270 --> 00:03:52.020
All right.

51
00:03:55.280 --> 00:03:58.370
My return machine freezes a little bit.

52
00:04:00.690 --> 00:04:09.910
So right click new and then it takes the command and then we want to rename these to Hello World to

53
00:04:10.020 --> 00:04:10.740
Java.

54
00:04:15.160 --> 00:04:15.820
Okay.

55
00:04:16.860 --> 00:04:26.190
And after that, I'm going to quickly open it up and then run the type to create a class, and then

56
00:04:26.190 --> 00:04:28.770
we're going to compile it and then we're going to.

57
00:04:29.580 --> 00:04:32.760
So, yes, let's change the extension.

58
00:04:35.680 --> 00:04:37.300
And then right click.

59
00:04:40.210 --> 00:04:43.090
I'm going to open it with a text editor on Windows.

60
00:04:43.090 --> 00:04:45.700
I prefer to use notepad plus plus.

61
00:04:45.760 --> 00:04:52.210
Now obviously in the future lectures I will switch to the Eclipse ID and we will see actually how to

62
00:04:52.240 --> 00:04:58.600
set up the external tool in Eclipse ID so that it can automatically call the native image tool.

63
00:04:58.780 --> 00:05:03.490
Now, if you're not familiar with the concept of external tool in Eclipse ID, I will go into the details

64
00:05:03.490 --> 00:05:11.710
so you understand how how the meaning of the external tools that the eclipse provides.

65
00:05:26.250 --> 00:05:30.390
So let's open it up with the external, basically with a notepad plus.

66
00:05:30.390 --> 00:05:31.020
Plus.

67
00:05:36.960 --> 00:05:40.740
All right, so we're going to say that public class.

68
00:05:41.040 --> 00:05:42.600
Hello, world.

69
00:05:43.170 --> 00:05:43.530
All right.

70
00:05:43.530 --> 00:05:48.120
Just a routine and then a public static void main.

71
00:05:48.120 --> 00:05:51.990
That's the entry point to our Java application, a string args.

72
00:05:52.320 --> 00:05:57.810
And then in the main method, we're just going to say that system dot out dot print line.

73
00:05:58.350 --> 00:06:00.490
Hello world from C++.

74
00:06:00.510 --> 00:06:00.870
Hello.

75
00:06:00.870 --> 00:06:05.550
World from C++ in Java.

76
00:06:05.550 --> 00:06:08.370
And then exclamation marks and then semicolon.

77
00:06:08.370 --> 00:06:09.690
We're going to save this.

78
00:06:09.690 --> 00:06:11.040
Yes, we want to save this.

79
00:06:11.040 --> 00:06:11.640
And then.

80
00:06:13.210 --> 00:06:20.290
Obviously the first thing that we do, we compile and then we run our job application on the JV team

81
00:06:20.290 --> 00:06:24.040
to make sure that there is no error.

82
00:06:24.070 --> 00:06:24.700
There is nothing.

83
00:06:24.700 --> 00:06:28.860
And after that we just compile the native executable binary.

84
00:06:28.870 --> 00:06:33.900
So my recommendation is that always check your job application, run it on the JV team to make sure

85
00:06:34.240 --> 00:06:35.170
everything works fine.

86
00:06:35.170 --> 00:06:39.670
And after that at the final stage, compile it to the native executable binary.

87
00:06:39.820 --> 00:06:43.300
So let's change our directory to this test directory on the desktop.

88
00:06:43.330 --> 00:06:50.710
We're just going to drag and drop and then we have this Helloworld Java and then I'm going to say Java

89
00:06:50.710 --> 00:06:59.710
hyphen, hyphen version and we're using open JDK 11 from Microsoft.

90
00:06:59.710 --> 00:07:05.740
So did we define the overall home?

91
00:07:08.500 --> 00:07:09.220
Yes.

92
00:07:09.220 --> 00:07:14.410
And then we also on Windows, I also define the Bing directory.

93
00:07:14.410 --> 00:07:14.740
Right.

94
00:07:14.740 --> 00:07:17.140
So and we set that in order to use this.

95
00:07:17.140 --> 00:07:19.540
Unfortunately, this program for us has a space in it.

96
00:07:19.540 --> 00:07:26.710
So we kind of need to put these in double quotes describing and then for a backward slash, java hyphen,

97
00:07:26.710 --> 00:07:27.820
hyphen version.

98
00:07:31.210 --> 00:07:33.880
Now we shouldn't basically equate.

99
00:07:34.510 --> 00:07:35.740
So this one.

100
00:07:41.690 --> 00:07:43.430
So open JDK 17.

101
00:07:43.430 --> 00:07:50.690
So we're going to also use a Java Sea and then we're going to say Hello World to Java, right?

102
00:07:50.690 --> 00:07:52.310
So we're going to compile these.

103
00:07:55.230 --> 00:07:58.170
And it's going to create the class file and put it there.

104
00:07:58.200 --> 00:07:59.250
Right, done.

105
00:07:59.250 --> 00:08:05.010
And now we're going to launch this our Java application, which is the class file on the Java, right,

106
00:08:05.010 --> 00:08:06.690
because it's much easier.

107
00:08:07.500 --> 00:08:11.760
So we're going to say grabbing instead of Java, see just Java.

108
00:08:12.150 --> 00:08:18.390
And then we don't need to specify the class path or we can we just tell it this current directory and

109
00:08:18.390 --> 00:08:21.270
then we're going to tell it the hello world.

110
00:08:21.510 --> 00:08:23.220
And then we don't use the dot class.

111
00:08:23.220 --> 00:08:23.640
Right.

112
00:08:23.820 --> 00:08:26.280
And Hello World from C++ in Java.

113
00:08:26.280 --> 00:08:27.610
So everything works fine.

114
00:08:27.630 --> 00:08:36.840
Now if I want to finally compile to the native executable binary, I need to call the native image.

115
00:08:36.840 --> 00:08:42.150
But if I just call the native image now and this class file is going to fail because if I look at my

116
00:08:42.150 --> 00:08:51.060
path environment variable at the moment, it doesn't have any of the any of the RMS, V.C. or Microsoft

117
00:08:51.060 --> 00:08:52.170
visual compiler.

118
00:08:52.410 --> 00:08:52.710
Mark.

119
00:08:52.710 --> 00:08:58.590
So visual issue is not added to the path environment variable, which means if I see a lot X hyphen

120
00:08:58.590 --> 00:09:02.690
hyphen version, it's going to say that I cannot find clt x.

121
00:09:02.730 --> 00:09:03.090
All right.

122
00:09:03.090 --> 00:09:06.540
That's because it's not added to the path environment variable yet.

123
00:09:06.540 --> 00:09:09.620
So the command prompt will terminal, it cannot find it.

124
00:09:09.630 --> 00:09:10.740
So what should we do?

125
00:09:10.740 --> 00:09:14.280
If you recall in the environment variables.

126
00:09:14.280 --> 00:09:18.180
So in any terminal, if you type in V and hit enter.

127
00:09:18.720 --> 00:09:20.400
All right, it's one more time.

128
00:09:20.400 --> 00:09:26.250
It tells you which environment variables, which global environment variables are defined for your terminal.

129
00:09:26.250 --> 00:09:30.480
Right in mac OS Windows Linux doesn't matter this end V works.

130
00:09:30.960 --> 00:09:38.250
And then if you recall we defined a RMS, we c vars, right?

131
00:09:38.250 --> 00:09:42.540
We define this environment variable, global environment variable for the operating system and it's

132
00:09:42.540 --> 00:09:52.500
pointing to the VC var 64 dot bat and this is a shell script so we can just execute it right as we see

133
00:09:53.010 --> 00:09:54.240
underscore vars.

134
00:09:54.240 --> 00:10:02.190
So if I type it and hit enter, it's equivalent to typing this full path to this and let's see if the

135
00:10:02.190 --> 00:10:03.870
space works fine or not.

136
00:10:03.870 --> 00:10:04.290
No.

137
00:10:04.290 --> 00:10:08.940
So we have to put it in double code so that the space spacing program files does it.

138
00:10:08.940 --> 00:10:16.560
So now this executes and then it sets up the Microsoft Visual Studio to enter Developer Edition and

139
00:10:16.560 --> 00:10:23.460
it's a pen's own all the required directory to the environment variable and it tells us that, hey,

140
00:10:23.460 --> 00:10:29.550
I set it up for the 64 bit compilation, which is the correct I want 64 bit compilation instead of 32

141
00:10:29.550 --> 00:10:29.780
bit.

142
00:10:30.000 --> 00:10:37.170
And if I clear and look at my path environment variable again and you see that now there are a lot of

143
00:10:37.170 --> 00:10:42.750
directories that from a MSC, VC, Microsoft Visual Studio that has been appended to the path.

144
00:10:42.750 --> 00:10:42.960
Right.

145
00:10:42.960 --> 00:10:44.160
Lots of directories.

146
00:10:44.160 --> 00:10:49.890
That's why I recommend instead of trying to manually add these directories to the path, just define

147
00:10:49.890 --> 00:10:58.200
that global environment variable as we see worse, that points to the right shell script that comes

148
00:10:58.200 --> 00:11:01.770
with the marks of listed and just execute this environment variable each time.

149
00:11:01.770 --> 00:11:02.190
Right?

150
00:11:02.580 --> 00:11:05.580
So this works and now now that is set up.

151
00:11:05.580 --> 00:11:13.470
If I say select exa, for example, hyphen, hyphen version, the terminal is able to find the right

152
00:11:13.590 --> 00:11:14.100
tool right.

153
00:11:14.100 --> 00:11:20.010
The CL, which is the command line interface for the calling, the MSC compiler.

154
00:11:20.010 --> 00:11:24.180
And now I'm ready to call the native image on this class file.

155
00:11:24.270 --> 00:11:30.690
So again, double quotes and then use our global environment variable grabbing directory.

156
00:11:31.320 --> 00:11:31.920
Right?

157
00:11:32.040 --> 00:11:33.810
And then backwards slash.

158
00:11:33.810 --> 00:11:39.870
I believe forward slash might also work on windows, but here I'm using backwards slash native image

159
00:11:41.310 --> 00:11:42.270
dot cmd.

160
00:11:42.270 --> 00:11:50.970
It's a command line script and then we're going to tell it the hyphen CP here and then Hello World and

161
00:11:50.970 --> 00:11:58.500
we don't specify the name and we kind of specify the name of the output file, let's say my app and

162
00:11:58.500 --> 00:11:59.610
then hit enter.

163
00:12:00.240 --> 00:12:07.230
It is going to take a few a little bit of time because I'm running on a virtual machine, but hopefully

164
00:12:07.230 --> 00:12:10.770
this will finish up and we will get a native executable.

165
00:12:10.770 --> 00:12:17.610
And we've we've seen in the past that the executable is already like ten, 11 megabytes, whereas our

166
00:12:17.610 --> 00:12:19.560
class file is just like one kilobyte.

167
00:12:19.560 --> 00:12:25.740
And the main reason obviously is that it has to compile a JVM added garbage collector and then compile

168
00:12:25.740 --> 00:12:27.840
all the class files from the JDK.

169
00:12:27.840 --> 00:12:34.290
So they all say basically require some space, ten megabytes or so.

170
00:12:42.790 --> 00:12:46.670
So this is still doing some stuff.

171
00:12:46.690 --> 00:12:50.380
Let's see if this is going to work.

172
00:13:01.970 --> 00:13:03.860
Still waiting a little bit trying to.

173
00:13:05.120 --> 00:13:08.120
So the first thing that it will output is the.

174
00:13:09.870 --> 00:13:13.500
Is the version which version of grab me using.

175
00:13:13.500 --> 00:13:18.000
So I'm going to let this to run and then let's head back to our PowerPoints.

176
00:13:18.120 --> 00:13:25.680
So you write your class voice and then you run the native image CMD and then run it on the class file

177
00:13:25.680 --> 00:13:30.570
that has the main method, and then it goes ahead and compiles and eventually you get a Hello World

178
00:13:30.570 --> 00:13:31.100
exit.

179
00:13:31.200 --> 00:13:36.300
And we said that in Mac OS and Linux, the executable files don't have any extension on Windows.

180
00:13:36.300 --> 00:13:37.890
They have dot exe extension.

181
00:13:37.890 --> 00:13:44.550
And you see here it's like 11, 12 megabytes which is very large, whereas your class file was only

182
00:13:44.550 --> 00:13:45.240
one kilobyte.

183
00:13:45.240 --> 00:13:45.690
Right?

184
00:13:46.170 --> 00:13:52.420
So this executable file not only has your job application, it has a lot of stuff like a garbage collector,

185
00:13:52.470 --> 00:13:54.440
a JVM, all class wise.

186
00:13:55.290 --> 00:14:00.720
Now let's quickly go through the build stages, which is all the information that the Native Image tool

187
00:14:00.720 --> 00:14:05.220
prints to the terminal in the process of compiling your Java application.

188
00:14:05.550 --> 00:14:07.410
And here's the documentation.

189
00:14:07.410 --> 00:14:14.340
So it's just a graph VM, the version and then reference hyphen manual and then the native image tool

190
00:14:14.340 --> 00:14:15.840
and in the build output.

191
00:14:16.440 --> 00:14:22.020
And so you can go let me just quickly open this up in a browser.

192
00:14:24.150 --> 00:14:26.490
And then you will see that we can.

193
00:14:27.090 --> 00:14:34.710
Basically, the material that I'm writing here, more or less a concise version of what's on the reference

194
00:14:34.710 --> 00:14:35.040
manual.

195
00:14:35.190 --> 00:14:42.540
In the future lectures, I will walk you through all the actual official documentation of the native

196
00:14:42.540 --> 00:14:44.140
image on the VN website.

197
00:14:44.160 --> 00:14:48.570
But for now, I just wrote a concise or very brief

198
00:14:50.880 --> 00:14:53.630
basically explanation of what happens here.

199
00:14:53.640 --> 00:14:59.460
It also has an example that what's going on and then it walks you through all the stages, right?

200
00:14:59.670 --> 00:15:02.670
So first of all, the first stage is initialization.

201
00:15:02.910 --> 00:15:04.440
Let's look at the Linux output.

202
00:15:04.470 --> 00:15:08.430
It just tells you graph VM, native image generating hello world.

203
00:15:08.430 --> 00:15:09.690
So nothing went wrong.

204
00:15:09.720 --> 00:15:12.450
The native tool was able to execute, right?

205
00:15:12.690 --> 00:15:17.250
So that's the first stage initialization in this stage.

206
00:15:17.250 --> 00:15:24.390
The Native Image build process is set up and features are initialized and version info user provided

207
00:15:24.390 --> 00:15:31.320
features right version info is basically here in the initialization version info global VM 22 something

208
00:15:31.320 --> 00:15:33.330
we saw that in the most recent version.

209
00:15:33.330 --> 00:15:40.110
They also print which GC is being used and which default toolchain is being used.

210
00:15:40.110 --> 00:15:40.590
Right.

211
00:15:42.660 --> 00:15:45.000
The version info of the native image process.

212
00:15:45.000 --> 00:15:48.030
This string is also used for the Java VM version.

213
00:15:48.030 --> 00:15:54.360
So in we saw that there are system properties that JVM uses and when you compile to the native executable

214
00:15:54.360 --> 00:16:01.140
binary, you can still access these system properties using the system class write system dot get property

215
00:16:01.140 --> 00:16:05.640
Java VM version within the generated image user provided features.

216
00:16:05.970 --> 00:16:09.240
These are the extra system properties, right?

217
00:16:09.240 --> 00:16:13.560
All features that are provided by the user or implicitly registered for the user.

218
00:16:13.560 --> 00:16:21.000
For example, BI framework gradle VM Native Image deploys a number of internal features which are excluded

219
00:16:21.000 --> 00:16:21.990
from this list.

220
00:16:23.540 --> 00:16:24.080
All right.

221
00:16:24.290 --> 00:16:27.470
And then the next step is performing analysis.

222
00:16:27.470 --> 00:16:34.220
So performing analysis in this stage, it points to analysis is performed, which means the compiler

223
00:16:34.220 --> 00:16:39.950
chases all the pointers on the stack, write all the references to see which objects they're pointing

224
00:16:39.950 --> 00:16:41.300
to in the Java heap.

225
00:16:41.690 --> 00:16:45.590
The Progress Indicator visualizes the number of analysis iterations.

226
00:16:45.590 --> 00:16:47.030
You see these stars.

227
00:16:47.060 --> 00:16:49.490
These are progress indicators, right?

228
00:16:49.490 --> 00:16:52.400
So each star means one round of iteration.

229
00:16:54.260 --> 00:16:58.940
So the progress indicator visualizes the number of analysis iterations.

230
00:16:59.030 --> 00:17:05.690
A large number of iterations can indicate problems in the analysis likely caused by Misconfiguration

231
00:17:05.690 --> 00:17:07.280
or a misbehaving feature.

232
00:17:08.350 --> 00:17:12.310
Now performing analysis has to analyze a couple of different things.

233
00:17:12.310 --> 00:17:15.200
One is reachable classes, fields and methods.

234
00:17:15.220 --> 00:17:22.720
What this means is that if there are some classes in your application that your main method right doesn't

235
00:17:22.720 --> 00:17:25.600
really rely on them, doesn't call them, doesn't use them.

236
00:17:25.600 --> 00:17:31.600
And none of the classes that are used or the types that are used in main method, they don't really

237
00:17:32.500 --> 00:17:33.940
use some of the classes.

238
00:17:33.940 --> 00:17:39.010
Then those classes are not reachable and they're not going to be compiled because the compiler of the

239
00:17:39.010 --> 00:17:44.830
native image is smart enough to know that your the entirety of your job application doesn't really depend

240
00:17:44.830 --> 00:17:45.370
on them.

241
00:17:45.430 --> 00:17:51.340
Remember that we're doing a static compilation, so the compiler at the compile time has to chase all

242
00:17:51.340 --> 00:17:57.250
the pointers, all the types, all the figures, all the dependencies to eventually figure out which

243
00:17:57.250 --> 00:18:03.040
classes are reachable and they have to be compiled or which classes are not reachable, then they have

244
00:18:03.040 --> 00:18:07.660
no effect on your application reflection registrations, right?

245
00:18:07.660 --> 00:18:13.120
If you're using Reflection API and access registrations, if some of the methods in your classes are

246
00:18:13.120 --> 00:18:20.680
native methods, we already know that most of the JDK classes have at least the classes that are in

247
00:18:20.680 --> 00:18:22.690
the core Java Lang package.

248
00:18:22.690 --> 00:18:24.550
They have general access, right?

249
00:18:24.550 --> 00:18:27.520
They have native methods and runtime compiled method, right?

250
00:18:27.520 --> 00:18:34.600
So these are the things and if you look at here, it tells you, for example, in this output, 3251

251
00:18:34.600 --> 00:18:35.740
classes reachable.

252
00:18:35.740 --> 00:18:41.410
So your Java application depends on 3251 classes to be run.

253
00:18:41.410 --> 00:18:45.370
Obviously, you didn't write 3000 classes in your job application.

254
00:18:45.370 --> 00:18:53.890
We just wrote a simple hello world class, but the rest are the JDK dependencies 5529 fields reachable

255
00:18:53.890 --> 00:19:03.820
and 16,881 methods reachable and in 28 classes, zero fields and 173 methods registered for reflection

256
00:19:03.820 --> 00:19:11.020
57 classes, 58 fields and 51 methods registered for access, which means of all the dependencies of

257
00:19:11.020 --> 00:19:17.950
your job application, there are 51 native methods that have to be registered and compiled and the compiler

258
00:19:17.950 --> 00:19:21.880
has to figure them out in order for your Java application to successfully run.

259
00:19:21.880 --> 00:19:22.330
Right?

260
00:19:22.330 --> 00:19:24.010
So these are more like a statistics.

261
00:19:24.010 --> 00:19:25.000
What's going on?

262
00:19:25.870 --> 00:19:32.710
And after that building universe, this is where we start putting all these information together and

263
00:19:32.710 --> 00:19:33.790
start compiling.

264
00:19:33.790 --> 00:19:39.760
And this stage, a universe with all classes, fields and methods is built, which is then used to create

265
00:19:39.760 --> 00:19:40.780
a native image.

266
00:19:41.110 --> 00:19:47.770
Parsing methods right part parsing methods means in this stage the graph compiler, the native image

267
00:19:47.770 --> 00:19:50.590
compiler parses all reachable methods.

268
00:19:50.620 --> 00:19:55.660
Parsing just means it, tokenize them in a way that the compiler understands them.

269
00:19:55.660 --> 00:19:59.080
And then because method it means it's source file, right?

270
00:19:59.680 --> 00:20:04.570
Or basically classify these are Java, these are the way that Java JVM understands.

271
00:20:04.570 --> 00:20:11.260
But now the compiler needs to compile them into native executable instructions for the CPU.

272
00:20:11.470 --> 00:20:17.980
The progress indicator is printed periodically at an increasing interval and again, those stars are

273
00:20:17.980 --> 00:20:22.630
showing you how long it's going to take to finish up this method.

274
00:20:23.540 --> 00:20:23.790
Okay.

275
00:20:24.130 --> 00:20:30.190
And then in lining methods, and I've mentioned this before in is a common technique that the compilers

276
00:20:30.190 --> 00:20:34.810
use to save some time for calling and methods or functions.

277
00:20:34.810 --> 00:20:42.370
Usually what happens here is that whenever you call a method or function in the actual file compiled

278
00:20:42.370 --> 00:20:49.210
file, which is basically assembly instructions for the CPU, it says go to this memory address and

279
00:20:49.210 --> 00:20:51.790
then basically a function is just a pointer, right?

280
00:20:51.790 --> 00:20:53.290
It's an address in memory.

281
00:20:53.290 --> 00:20:58.120
The CPU jumps to the memory address and then loads all the instructions, all the lines of the code

282
00:20:58.120 --> 00:21:04.000
in a function or method are stored somewhere, and that block of memory has an address, which is the

283
00:21:04.000 --> 00:21:05.950
method or function which points to it.

284
00:21:05.980 --> 00:21:06.520
Right.

285
00:21:06.940 --> 00:21:12.370
And in learning means the compiler copies all that code in the actual main method.

286
00:21:12.370 --> 00:21:16.420
So or whatever other function is that is calling your method.

287
00:21:17.170 --> 00:21:21.760
Therefore there is no jumping from one address to another to load the extra instructions.

288
00:21:22.150 --> 00:21:26.320
And the compilers nowadays are very smart about this.

289
00:21:26.320 --> 00:21:29.800
So in this stage, trivial method in learning is performed.

290
00:21:29.830 --> 00:21:33.730
The Progress Indicator visualizes the number of in and iterations.

291
00:21:33.730 --> 00:21:40.720
Right now we know that the Java compiler, Java C is a very dumb compiler, which means it really uses

292
00:21:40.720 --> 00:21:41.740
any in learning.

293
00:21:41.740 --> 00:21:47.710
Now Java C is good for for example, if you have a public aesthetic final field, it just replaced all

294
00:21:47.710 --> 00:21:52.690
those basically fields with the actual value.

295
00:21:52.690 --> 00:21:59.350
But Java C doesn't really do any optimization in terms of inline, so it's mainly the LLVM compiler

296
00:21:59.350 --> 00:22:01.390
that does all these aesthetic analysis.

297
00:22:01.570 --> 00:22:07.300
So in lining methods, you see this stage has four stars, which means actually there's quite.

298
00:22:07.400 --> 00:22:12.020
Some time and effort to for the compiler to inline this a lot of methods.

299
00:22:13.150 --> 00:22:15.010
Build stages, compiling methods.

300
00:22:15.010 --> 00:22:18.670
So after we in line now we go ahead and do the compilation.

301
00:22:18.670 --> 00:22:24.190
In this stage, the global compiler compiles all reachable methods to machine code.

302
00:22:24.190 --> 00:22:28.150
Now again, it's smart about it and the reachable is the keyword here.

303
00:22:28.240 --> 00:22:34.930
Now, a class might have a lot of methods, but your application might not use some of those methods.

304
00:22:34.930 --> 00:22:35.140
Right?

305
00:22:35.140 --> 00:22:37.270
They're just there, but they're not usable.

306
00:22:37.270 --> 00:22:43.720
So the compiler doesn't compile those methods to native binaries because they don't have any effect

307
00:22:43.720 --> 00:22:45.280
on your application.

308
00:22:45.280 --> 00:22:46.780
They are never used.

309
00:22:46.930 --> 00:22:51.520
Whereas in the java like the class file already includes the BI code for those methods.

310
00:22:51.520 --> 00:22:58.210
But the compiler realizes that some of the methods are never used or called in your application, so

311
00:22:58.210 --> 00:23:00.130
there is no point of compiling them.

312
00:23:01.040 --> 00:23:04.490
So it's a smart about it and it means it's doing optimisation.

313
00:23:04.490 --> 00:23:09.410
And previously we saw that there is an optimisation flag that you can pass to the Native Image compiler,

314
00:23:09.410 --> 00:23:14.870
so you can turn the optimisation off, but then most likely the size of your native image becomes larger

315
00:23:14.870 --> 00:23:21.140
because it's not as smart about selectively compiling method, it just compiles everything.

316
00:23:21.140 --> 00:23:26.990
The progress indicator is perfectly printed periodically at the at an increasing interval and you see

317
00:23:26.990 --> 00:23:33.050
there is like four star here, which means it also takes time and effort for the compiler to finish

318
00:23:33.050 --> 00:23:36.890
this phase, compiling methods and then creating image.

319
00:23:36.890 --> 00:23:42.380
Finally, once everything is done, we know that just like C++ application after compilation, there

320
00:23:42.380 --> 00:23:49.640
is a linking phase and it's the linker that puts all the compiled files together, right, and creates

321
00:23:49.670 --> 00:23:51.650
one native executable.

322
00:23:51.650 --> 00:23:52.460
Same here.

323
00:23:52.460 --> 00:23:56.930
There is a linking phase that happens that puts all the compilations together.

324
00:23:57.410 --> 00:24:01.310
In this stage the native image is created and written to disk.

325
00:24:01.310 --> 00:24:04.640
Debug info is also generated as part of this state.

326
00:24:04.640 --> 00:24:07.400
And what is this debug info here?

327
00:24:07.400 --> 00:24:13.700
It says it gives you some information of what's the total size of the native image here, 11.96 megabyte

328
00:24:13.700 --> 00:24:20.510
and it gives you a kind of a brief breakdown of what is which parts of this.

329
00:24:20.660 --> 00:24:23.300
So what constitutes this total?

330
00:24:23.300 --> 00:24:32.000
11.96 megabyte It tells you that almost four megabyte is for the code area, which consists the binary

331
00:24:32.000 --> 00:24:41.540
code of 7383 compilation unit, just like C++ that each CP file is called a compilation unit here.

332
00:24:41.540 --> 00:24:48.590
Most likely each class file is called a compilation unit almost seven megabyte for Image Heap.

333
00:24:48.590 --> 00:24:50.510
Just this is similar to Java Heap.

334
00:24:50.510 --> 00:25:00.350
Even when you launch the JVM, there is a heap or memory area that stores information 1634 classes and

335
00:25:00.350 --> 00:25:01.940
90,000 objects.

336
00:25:01.940 --> 00:25:02.200
Right.

337
00:25:02.270 --> 00:25:05.150
Objects are stored on the heap and on the stack.

338
00:25:05.150 --> 00:25:07.160
They have pointers to those objects.

339
00:25:07.580 --> 00:25:14.630
One megabyte for other data, just like JVM has meta information, meta space that stores the static

340
00:25:14.630 --> 00:25:19.130
fields or like the class informations for reflection.

341
00:25:19.160 --> 00:25:24.140
It also has to allocate some space for that.

342
00:25:24.620 --> 00:25:27.890
And so it just gives us a breakdown of what's going on.

343
00:25:28.340 --> 00:25:34.880
So code area, the code area contains machine code produced by the compiler for all reachable methods.

344
00:25:34.880 --> 00:25:35.330
Right?

345
00:25:35.330 --> 00:25:42.560
Again, the compiler is smart about which methods to compile and which to not include in the final binary.

346
00:25:42.560 --> 00:25:48.260
If you have turned on the optimization which is already turned on by default, right?

347
00:25:48.350 --> 00:25:52.850
Therefore, reducing the number of reachable methods also reduces the size of the code area.

348
00:25:52.850 --> 00:25:53.660
Makes sense.

349
00:25:53.660 --> 00:25:54.740
Image heap.

350
00:25:55.660 --> 00:26:00.730
So again, code area means the machine code or the assembly code, right?

351
00:26:00.730 --> 00:26:01.720
For the methods.

352
00:26:01.720 --> 00:26:08.410
Each method, the code that is inside each method gets translated into instructions, write assembly

353
00:26:08.410 --> 00:26:09.640
instructions or machine code.

354
00:26:09.670 --> 00:26:13.300
Now obviously, besides that, you need the Java heap, right?

355
00:26:13.300 --> 00:26:17.060
A memory that basically the objects, the state of the objects are stored.

356
00:26:17.080 --> 00:26:23.950
So Image Heap mimics basically the Java heap when you launch your application on a JVM, image heap

357
00:26:23.950 --> 00:26:25.690
contains reachable objects.

358
00:26:25.690 --> 00:26:31.270
These are the state or the data that object is stored right, such as aesthetic data classes initialized

359
00:26:31.270 --> 00:26:35.890
at runtime like static fields and byte array for different purposes.

360
00:26:36.160 --> 00:26:40.510
Now we have general heap data stored byte array similar with JVM.

361
00:26:40.510 --> 00:26:40.810
Right.

362
00:26:40.810 --> 00:26:48.280
There is a byte array that stores data graph encoding is stored in byte array method metadata is stored

363
00:26:48.280 --> 00:26:48.970
in byte array.

364
00:26:48.970 --> 00:26:55.000
I mean, metadata just means some stuff, extra stuff in the class files.

365
00:26:55.000 --> 00:26:58.090
Each object has a class file associated with it.

366
00:26:58.120 --> 00:27:02.470
What this means is that each object or each class has some meta information, right?

367
00:27:02.560 --> 00:27:11.140
So finally, if you have enabled the debug information for the Native Image compiler, it also shows

368
00:27:11.140 --> 00:27:12.370
the debug information.

369
00:27:12.370 --> 00:27:15.310
And you see there is also some other data here.

370
00:27:16.040 --> 00:27:22.610
So other data means the amount of data in the image that is needed in the code area, which means the

371
00:27:22.610 --> 00:27:30.590
instructions machine assembly codes for the methods nor in the image heap object data nor debug information.

372
00:27:31.070 --> 00:27:33.890
And we know that same with the C++ compilers.

373
00:27:33.890 --> 00:27:39.380
You can compile in the debug mode or release mode, which means if you compile in the debug mode, the

374
00:27:39.380 --> 00:27:44.750
binary file has extra information for debugging purposes by default.

375
00:27:44.750 --> 00:27:50.820
If you turn on the optimization for the Native Image compiler, you don't get any debug information.

376
00:27:50.840 --> 00:27:57.320
This data typically contains informal internal information for native image and should not be dominating.

377
00:27:57.320 --> 00:28:01.340
So here it says that one megabyte was for other data.

378
00:28:03.060 --> 00:28:03.420
All right.

379
00:28:03.420 --> 00:28:06.630
So finally, resource usage statistics.

380
00:28:06.630 --> 00:28:14.400
So this this line, this section, and also the GC peak, RSS and CPU load, it just tells you more

381
00:28:14.400 --> 00:28:15.090
information.

382
00:28:15.090 --> 00:28:22.530
It doesn't really it's not directly related to the application.

383
00:28:22.530 --> 00:28:27.810
Job application is just tells you what happened, how much CPU load was doing the compilation, how

384
00:28:27.810 --> 00:28:34.230
much memory was used, garbage collections, the total time spent in all garbage collectors.

385
00:28:34.230 --> 00:28:40.320
Total GC time divided by the total process, time in person and the total number of garbage collections.

386
00:28:41.190 --> 00:28:47.570
A large number of collections or time is spent in collectors usually indicates that the system is under

387
00:28:47.580 --> 00:28:48.540
memory pressure.

388
00:28:48.570 --> 00:28:52.500
Increase the amount of available memory to reduce the time to build the image.

389
00:28:52.680 --> 00:29:01.200
Now what this means is that so what what happens is the graph VM remember we're doing a static compilation,

390
00:29:01.200 --> 00:29:01.500
right?

391
00:29:01.500 --> 00:29:08.310
So it's not like when you run your Java application on the JVM at runtime, some garbage collection

392
00:29:08.310 --> 00:29:11.880
might happen to optimize the memory to compact ify the memory.

393
00:29:11.880 --> 00:29:20.610
But here we're doing a static compilation so that if you allocate a byte array for the Java heap, right?

394
00:29:21.450 --> 00:29:23.460
But then and then.

395
00:29:24.120 --> 00:29:27.570
But this array doesn't dynamically get optimized.

396
00:29:28.110 --> 00:29:28.710
Right.

397
00:29:28.710 --> 00:29:36.180
So when you create your native binary and running despite array might get fragmented because there is

398
00:29:36.180 --> 00:29:36.690
no GC.

399
00:29:36.690 --> 00:29:42.930
So what happens here is that behind the scenes the static compiler actually runs through your Java application

400
00:29:43.050 --> 00:29:52.170
and a native image or the global VM has a GC built in and it actually runs the application, your Java

401
00:29:52.170 --> 00:29:56.970
application and then runs a couple of GC cycles to optimize your image heap.

402
00:29:56.970 --> 00:29:57.210
Right.

403
00:29:57.210 --> 00:30:02.400
So it's very interesting that this happens behind the scene and this is one of the difficulties that

404
00:30:02.400 --> 00:30:10.290
they had to overcome to enable this kind of native, native compilation, which is very interesting

405
00:30:10.290 --> 00:30:10.830
job to do.

406
00:30:10.830 --> 00:30:13.860
It's I'm sure it's not easy, but they were able to do it.

407
00:30:13.860 --> 00:30:20.730
So your native image compiler in order to optimize your application, right.

408
00:30:20.730 --> 00:30:27.120
This image heap which mimics the Java heap, we know that once you allocate and then objects and then

409
00:30:27.120 --> 00:30:34.140
they go out of the scope, your heap becomes fragmented and it's the job of the garbage collector to

410
00:30:34.560 --> 00:30:37.530
reclaim those memory and also compact ify the heap.

411
00:30:37.530 --> 00:30:47.240
So make all the live objects into like put them one after another so that the, the heap is very compact

412
00:30:47.250 --> 00:30:47.640
file.

413
00:30:47.670 --> 00:30:52.890
So it tells you it actually the compiler actually ran through your Java application.

414
00:30:52.890 --> 00:31:01.140
It ran 38 GC cycles to make sure that the image heap that it creates is mimicking a very compact, ified

415
00:31:01.140 --> 00:31:03.510
and optimized version of a java heap.

416
00:31:03.510 --> 00:31:03.870
Right?

417
00:31:03.870 --> 00:31:09.750
So 38 GC cycles were ran before the compiler decides that.

418
00:31:09.750 --> 00:31:13.950
Okay, this the state of the Java here is now is the most optimized.

419
00:31:13.950 --> 00:31:20.610
Let's print it permanently as the image heap, let's say it permanently as the image here.

420
00:31:20.610 --> 00:31:23.370
And it took it becomes about seven megabyte.

421
00:31:25.080 --> 00:31:25.590
All right.

422
00:31:25.950 --> 00:31:31.710
And then peak RSS peak resident said size as reported by the operating system, this value indicates

423
00:31:31.710 --> 00:31:34.390
the maximum amount of memory consumed by the build process.

424
00:31:34.410 --> 00:31:41.130
Now we see when you're when you compile anything, you need some some memory space, some ram so that

425
00:31:41.130 --> 00:31:43.260
the compiler can store some information.

426
00:31:43.260 --> 00:31:49.110
And eventually Linker uses those information to build your binary CPU load.

427
00:31:49.110 --> 00:31:51.300
And this is pretty much self explanatory.

428
00:31:51.300 --> 00:31:58.050
The CPU time used by the process divided by the total process time increase, the number of CPU threads

429
00:31:58.050 --> 00:31:59.280
to reduce the time.

430
00:31:59.280 --> 00:32:05.280
And by default, the native image tries to take advantage of all the threads that your CPU the hardware

431
00:32:05.280 --> 00:32:09.660
provides, so you don't need to pass any flags for changing number of threads.

432
00:32:09.660 --> 00:32:15.600
I recommend you just use the default, whatever the number is for the default threads that the compiler

433
00:32:15.600 --> 00:32:16.230
uses.

434
00:32:16.230 --> 00:32:18.450
So let's go back to our Windows machine.

435
00:32:18.450 --> 00:32:22.500
And as you can see, the compilation has succeeded.

436
00:32:22.500 --> 00:32:24.720
We get my apt exit.

437
00:32:24.750 --> 00:32:32.310
It tells us that we're using the most recent version of the LLVM compiler 22.1, the C compiler.

438
00:32:32.310 --> 00:32:38.250
It was able to find the sealed exit, which is the Microsoft Visual Studio compiler.

439
00:32:38.250 --> 00:32:41.910
And we use the 64 bit configuration.

440
00:32:41.910 --> 00:32:42.420
Right.

441
00:32:42.420 --> 00:32:47.250
And this is the version of the compiler 19.31 The garbage collector is real.

442
00:32:47.250 --> 00:32:49.650
GC It's performing the analysis.

443
00:32:49.650 --> 00:32:56.670
It actually took six stars, so a lot of iterations to try to find all the classes that are all the

444
00:32:56.670 --> 00:33:02.850
methods, all the fields that are related to our job application building universe parsing methods.

445
00:33:02.850 --> 00:33:04.350
It takes two stars.

446
00:33:05.100 --> 00:33:11.700
If I go back to my Linux, you see, under Linux it took one star, but here it took two stars.

447
00:33:11.700 --> 00:33:18.270
So it tried to work a little bit harder in lining methods and in compiling method, creating image image

448
00:33:18.270 --> 00:33:19.650
here it's actually larger.

449
00:33:19.650 --> 00:33:22.290
12.54 megabyte Right.

450
00:33:22.290 --> 00:33:30.240
And it tells me about 4.7 megabyte is for code area, about seven megabyte for image size.

451
00:33:30.480 --> 00:33:35.010
And it tells me it ran 19 GC cycles here.

452
00:33:35.250 --> 00:33:42.120
If you go back to PowerPoint on Linux, it actually ran a 38 GC cycles.

453
00:33:42.330 --> 00:33:45.090
So on different platform, it's going to be different.

454
00:33:46.290 --> 00:33:48.660
And then CPU load one, right?

455
00:33:48.660 --> 00:33:56.310
And eventually we get our executable, see if I clear up and then I just say my underscore app dot exit.

456
00:33:56.310 --> 00:33:57.990
I don't need to really type the exit.

457
00:33:57.990 --> 00:33:58.950
I'm going to do it.

458
00:33:59.070 --> 00:34:02.010
It's going to say Hello World from C++ in Java.

459
00:34:02.010 --> 00:34:09.840
So we successfully compiled our simple Hello World Java application into a native executable binary.

460
00:34:09.840 --> 00:34:13.230
So I hope you really enjoyed this lecture and I've seen the next one.
