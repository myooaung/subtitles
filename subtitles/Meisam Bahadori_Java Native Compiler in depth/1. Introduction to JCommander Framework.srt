1
00:00:00,990 --> 00:00:03,390
Hello and welcome to another tutorial.

2
00:00:03,390 --> 00:00:08,220
In this tutorial I'm going to continue the discussion on Native Image and we're going to look at a very

3
00:00:08,220 --> 00:00:16,530
important discussion, which is how to design our job application and later compile it to native executable

4
00:00:16,560 --> 00:00:17,340
binary.

5
00:00:17,430 --> 00:00:24,090
And in such a way that our application is a command line application and it accepts some command line

6
00:00:24,090 --> 00:00:29,910
arguments and you know that whenever you have some command line application, usually it accepts flags

7
00:00:29,910 --> 00:00:34,050
with a hyphen, hyphen, some word or hyphen some letter.

8
00:00:34,050 --> 00:00:37,080
For example, if I open up a.

9
00:00:38,580 --> 00:00:45,360
Basically a terminal here and then say, for example, Java and then hyphen, hyphen version, right?

10
00:00:45,360 --> 00:00:52,200
So this is a command line argument and it doesn't accept any parameter for these particular arguments.

11
00:00:52,200 --> 00:00:52,580
Right?

12
00:00:52,590 --> 00:00:59,430
So if we say Java, hyphen, hyphen version, this application, which is Java, which is a binary application,

13
00:00:59,430 --> 00:01:01,020
understands this flag.

14
00:01:01,020 --> 00:01:06,150
And then if we say Java, hyphen, hyphen help, it lists all the flags, right?

15
00:01:06,150 --> 00:01:07,980
That this Java application accepts.

16
00:01:07,980 --> 00:01:11,640
And some of the flags start with hyphen and a single letter.

17
00:01:11,670 --> 00:01:17,970
Some of the one is start with hyphen and usually abbreviations, for example, hyphen, XRP or hyphen

18
00:01:17,970 --> 00:01:18,900
class path.

19
00:01:18,930 --> 00:01:25,320
If we want to introduce a hyphen in between the name of the flag, we normally use two hyphens hyphen,

20
00:01:25,320 --> 00:01:31,020
hyphen and in class hyphen path or single hyphen CP or single hyphen class path.

21
00:01:31,020 --> 00:01:37,740
So usually single hyphen is used with letters and abbreviations and hyphen hyphen is used with the words

22
00:01:37,740 --> 00:01:39,570
that have more than one part.

23
00:01:39,570 --> 00:01:45,450
So module dash path or hyphen path, we use a hyphen hyphen, right?

24
00:01:45,840 --> 00:01:48,690
So hyphen, hyphen, dri, hyphen, round or hyphen.

25
00:01:48,750 --> 00:01:49,800
So this is the convention.

26
00:01:49,800 --> 00:01:55,020
You don't have to necessarily follow these, but that's a good practice to follow this convention.

27
00:01:55,020 --> 00:02:00,000
For example, instead of saying Java, hyphen, hyphen help, we can say Java hyphen H, that's also

28
00:02:00,000 --> 00:02:00,840
the abbreviation.

29
00:02:00,840 --> 00:02:05,610
So you can either use hyphen, hyphen help or hyphen etch, right?

30
00:02:05,610 --> 00:02:11,010
So this is how we can set up our basically.

31
00:02:12,440 --> 00:02:13,360
Commando agreements.

32
00:02:13,370 --> 00:02:17,870
So now you can do the same thing even with the Java application which runs on the Java.

33
00:02:17,870 --> 00:02:23,390
So command line arguments are passed to the Java application during the launch of the game and we've

34
00:02:23,390 --> 00:02:28,190
seen this before that that's the string array args that the main method has, right?

35
00:02:28,190 --> 00:02:34,520
JVM knows which class has the main method and the main method accepts a array of strings.

36
00:02:34,520 --> 00:02:34,880
Right.

37
00:02:34,880 --> 00:02:39,830
If you don't specify any arguments after the name of the main class on the command line when you run

38
00:02:39,830 --> 00:02:43,280
the Java, then it means the string area arg is empty.

39
00:02:43,280 --> 00:02:44,120
There is nothing there.

40
00:02:44,120 --> 00:02:44,540
Right.

41
00:02:44,960 --> 00:02:48,470
We can use a command line parser framework that already is available.

42
00:02:48,500 --> 00:02:57,710
Now the question basically is when somebody passes a command line arguments right to your job application,

43
00:02:57,710 --> 00:03:00,920
how do we grab those and transform them into the objects?

44
00:03:00,920 --> 00:03:03,050
Remember your Java, your Java code.

45
00:03:03,050 --> 00:03:09,320
Java is object oriented, so we have to kind of transform those command lines into objects or create

46
00:03:09,320 --> 00:03:14,480
objects, set some of the fields or properties of those objects based on the command line arguments.

47
00:03:14,600 --> 00:03:20,330
Now, the naive thing to do is to write, if else, a statements or a switch statement and go through

48
00:03:20,330 --> 00:03:23,810
all the strings in that string array args.

49
00:03:24,260 --> 00:03:30,200
And we manually write the parser somehow we manually write the logic down and then based on the command

50
00:03:30,200 --> 00:03:32,300
lines we decide what kind of objects to create.

51
00:03:32,300 --> 00:03:34,010
And that's that's possible.

52
00:03:34,010 --> 00:03:35,210
But nobody does that right.

53
00:03:35,210 --> 00:03:41,660
It's better to stick with a framework that has already been tested, and it provides a lot of nice and

54
00:03:41,660 --> 00:03:42,680
flexible features.

55
00:03:42,680 --> 00:03:47,030
Now, the framework that I recommend is called J Commander.

56
00:03:48,140 --> 00:03:57,380
The source code is on the GitHub, you can just go to GitHub dot com slash CB USD and then DJ Commander

57
00:03:59,060 --> 00:04:02,960
and then the online documentation is DJ Commander's org.

58
00:04:02,960 --> 00:04:05,600
It has a very, very nice documentation.

59
00:04:05,600 --> 00:04:09,620
That's also one of the reasons that I'm recommending this framework because it's documentation, it's

60
00:04:09,620 --> 00:04:10,460
very nice.

61
00:04:10,460 --> 00:04:14,750
It's also available on Maven, Grader or any other build tool that you use.

62
00:04:14,750 --> 00:04:15,980
I personally use Maven.

63
00:04:15,980 --> 00:04:17,920
It's very easy to group ID is com.

64
00:04:17,990 --> 00:04:24,440
The abused artifact ID is j commander and the version you can just set it as latest version as of today

65
00:04:24,440 --> 00:04:25,910
it's 1.82.

66
00:04:27,020 --> 00:04:32,570
And basically the way this works is that you create empty objects and then you pass them.

67
00:04:32,570 --> 00:04:39,500
And the commander has a static builder pattern which uses reflection to build the objects, or basically

68
00:04:39,680 --> 00:04:41,090
it doesn't call the constructor.

69
00:04:41,090 --> 00:04:46,700
You create empty objects and then you pass it to the commander, you pass the command line arguments

70
00:04:46,700 --> 00:04:52,670
and the commander sets the the fields or the state of those objects.

71
00:04:53,600 --> 00:04:58,400
Using reflection, it has a pass method to parse the string array arcs.

72
00:04:58,430 --> 00:05:00,650
It uses reflection to accomplish parsing.

73
00:05:00,650 --> 00:05:07,670
And then obviously the first question that you're going to ask is how does it know which fields to parse

74
00:05:07,670 --> 00:05:09,620
or set values based on the command line arguments?

75
00:05:09,620 --> 00:05:14,270
And it provides a very nice annotation feature which I will show you.

76
00:05:14,270 --> 00:05:16,010
But first, let's look at the features.

77
00:05:16,010 --> 00:05:17,820
Why am I recommending this commander?

78
00:05:17,840 --> 00:05:23,480
Obviously, one of them is it has very nice documentation, very detailed, very nice examples, but

79
00:05:23,480 --> 00:05:25,700
it's very easy and intuitive to use.

80
00:05:26,000 --> 00:05:28,190
All complexity is hidden from the user.

81
00:05:28,310 --> 00:05:30,620
You literally don't need to do anything.

82
00:05:30,830 --> 00:05:33,500
It can pass multiple objects at the same time.

83
00:05:33,650 --> 00:05:38,600
Let's say based on the command line arguments, you want to parse multiple objects, parameters that

84
00:05:38,600 --> 00:05:41,390
are not set on the command line, get default values.

85
00:05:41,390 --> 00:05:47,480
That's one of the nice features and I believe most of the frameworks that work in different programming

86
00:05:47,480 --> 00:05:53,230
languages like Python, C++ or this one in Java, they have this feature that what if somebody what

87
00:05:53,240 --> 00:05:58,550
if you have lots of parameters but somebody doesn't provide some values for some of the parameters.

88
00:05:58,550 --> 00:06:05,720
So it makes sense that to design the this framework for Python parsing command line in such a way that

89
00:06:05,720 --> 00:06:12,350
if, if one of the parameters is not set on the command line, it gets a default value, right?

90
00:06:12,380 --> 00:06:15,590
Each Java field can get multiple names under command line.

91
00:06:15,590 --> 00:06:21,230
As I mentioned, for example, Java, we can use either hyphen, hyphen help or hyphen H, right?

92
00:06:21,230 --> 00:06:23,000
That's usually the convention we use.

93
00:06:23,000 --> 00:06:27,620
And both of these hyphen, hyphen, help and hyphen should do the same thing.

94
00:06:27,620 --> 00:06:29,570
So they map to the same command, right?

95
00:06:30,170 --> 00:06:35,630
It has a rich online documentation, as I mentioned, and it works with Java collection as well, which

96
00:06:35,630 --> 00:06:40,520
means you can even set a flag on the command line to say and give multiple values.

97
00:06:40,520 --> 00:06:47,270
And then internally the commander can map all those value and build a list, release or a set or something,

98
00:06:47,270 --> 00:06:48,980
which is the field of an object.

99
00:06:49,130 --> 00:06:51,260
Now, a very simple example is here.

100
00:06:52,280 --> 00:06:56,420
First of all, as I mentioned, the builder pattern that the commander follows.

101
00:06:56,450 --> 00:07:03,290
It doesn't really directly call any constructor, so you kind of use it mainly for data classes or pogos

102
00:07:03,290 --> 00:07:04,610
plain old Java objects.

103
00:07:04,610 --> 00:07:06,770
So you just want to set some fields, right?

104
00:07:07,490 --> 00:07:15,740
So you create an empty object and then basically pass it to the J commander and it parses the command

105
00:07:15,740 --> 00:07:18,440
line arguments and then sets the values of the fields.

106
00:07:18,440 --> 00:07:18,860
Right?

107
00:07:18,980 --> 00:07:27,650
So create a class with an int field called value and then I'm going to assign it to command line flags

108
00:07:27,650 --> 00:07:29,420
to for setting up this value.

109
00:07:29,450 --> 00:07:35,480
The user can either give hyphen V and then a space and then the value or hyphen hyphen value.

110
00:07:35,480 --> 00:07:44,900
I want both these commands or flags to map, to basically parse, to set the this int field value,

111
00:07:45,350 --> 00:07:47,330
int field called value in an object.

112
00:07:47,750 --> 00:07:54,110
So the first thing you do, obviously you add your j commander to the build path and we'll use Maven.

113
00:07:54,110 --> 00:07:54,860
So it's very easy.

114
00:07:54,860 --> 00:08:03,890
You just add the maven to the maven coordinates the dependency to your point file and after that you

115
00:08:03,890 --> 00:08:07,550
create your class as usual, but then you annotate it with add parameter.

116
00:08:07,550 --> 00:08:17,510
This is the nice annotation that the the the J commander framework provides and it has a list or array

117
00:08:17,510 --> 00:08:23,390
of strings called names and then you can directly initialize it in with this nice syntax.

118
00:08:23,390 --> 00:08:23,870
Right?

119
00:08:23,960 --> 00:08:25,370
So this is an area of a string.

120
00:08:25,370 --> 00:08:31,730
You can provide as many strings as you want or as many flags as you want so that they all map to the

121
00:08:31,730 --> 00:08:32,420
same field.

122
00:08:32,420 --> 00:08:32,990
Right.

123
00:08:33,500 --> 00:08:35,450
A step to create an empty object.

124
00:08:35,780 --> 00:08:37,520
I called my class test class.

125
00:08:37,710 --> 00:08:42,620
It it it has an empty or default constructive, which doesn't do anything.

126
00:08:42,770 --> 00:08:44,540
So you have to create this object.

127
00:08:44,540 --> 00:08:46,760
And then you use the j commander.

128
00:08:46,790 --> 00:08:47,240
Get the base.

129
00:08:47,390 --> 00:08:51,860
They're ADD object and obviously you can add multiple objects, that's fine.

130
00:08:51,860 --> 00:09:01,670
And then you call the build and then when you call the bell, it uses the reflection to basically figure

131
00:09:01,670 --> 00:09:08,630
out what fields have been annotated, etc. So this build is mandatory and after that pass and you pass

132
00:09:08,630 --> 00:09:14,150
the a string array arcs of the main method to it, and then after that it already has figured out which

133
00:09:14,150 --> 00:09:16,220
fields have been annotated.

134
00:09:16,220 --> 00:09:21,950
So it goes through the a string area arcs and then maps, all those command line or all those flags

135
00:09:21,950 --> 00:09:24,620
to the to set the right values right.

136
00:09:24,620 --> 00:09:29,960
And then once after that, if we say object that value this object, you will see that it's been properly

137
00:09:29,960 --> 00:09:30,380
set.

138
00:09:30,590 --> 00:09:35,480
So and then obviously we're going to run our job application on top of the JVM first to make sure everything

139
00:09:35,480 --> 00:09:41,750
works fine, and then we'll figure out how to compile our job application with this capability into

140
00:09:41,750 --> 00:09:47,330
a native executable binary so that when we launch that native binary, all these flags are still available.

141
00:09:47,360 --> 00:09:52,730
We've already seen that how to include dependencies, because right now, in order to use this framework,

142
00:09:52,790 --> 00:09:57,230
our job application is going to have a dependency, which is the commander we've seen.

143
00:09:57,260 --> 00:10:03,920
We've gone into details how to work with Maven, when we want to compile to native executable, how

144
00:10:03,920 --> 00:10:08,000
to handle the dependencies and eclipse ID basically takes care of everything.

145
00:10:08,900 --> 00:10:14,000
So let's head to Eclipse and try to go through this example and have a good understanding of what's

146
00:10:14,000 --> 00:10:14,390
going on.

147
00:10:14,390 --> 00:10:15,530
So here's Eclipse.

148
00:10:15,530 --> 00:10:21,370
I have this Maven project and in my file, if you look at the dependencies, I've already added a J

149
00:10:21,410 --> 00:10:23,330
Commander version 1.82.

150
00:10:23,330 --> 00:10:26,150
You just basically copy and paste this one, right?

151
00:10:26,420 --> 00:10:27,620
J commander.

152
00:10:27,620 --> 00:10:31,700
And after that maven grabs the repository, complete views.

153
00:10:32,090 --> 00:10:39,500
And then in the j commander we have converters, default provider internals, partial validators and

154
00:10:39,500 --> 00:10:41,030
lots of classes, right?

155
00:10:41,030 --> 00:10:44,570
For integer parsing strings, other parameters.

156
00:10:44,570 --> 00:10:52,670
This is the main annotation that we use parameter a string array names and then a string.

157
00:10:52,670 --> 00:10:56,330
You can also add description whether it's required or not.

158
00:10:56,330 --> 00:11:03,530
And this means that it has to, if you set it to be required, means that the user has to set it as

159
00:11:03,530 --> 00:11:04,880
a flag on the command line.

160
00:11:04,880 --> 00:11:07,970
It's not possible to give it a default value description.

161
00:11:07,970 --> 00:11:14,120
Key default array or default entity is minus one.

162
00:11:14,130 --> 00:11:20,810
Entity means usually you have one, which means when you set the flag, you only pass one parameter

163
00:11:20,810 --> 00:11:25,220
or you can set it to have multiple values, whether it's a password or not.

164
00:11:25,220 --> 00:11:32,510
And then you can also define your own converters how to convert the string that is passed to the command

165
00:11:32,510 --> 00:11:38,000
line, to the actual value of the field, and then a lot of other capabilities.

166
00:11:38,000 --> 00:11:39,820
I will have a full course on J.

167
00:11:39,830 --> 00:11:41,420
Commander to go into the details.

168
00:11:41,420 --> 00:11:45,350
But for now, we're just going to start with a very simple example.

169
00:11:46,540 --> 00:11:46,900
All right.

170
00:11:46,900 --> 00:11:48,680
So we have this test class.

171
00:11:48,700 --> 00:11:50,050
It has a Field eight value.

172
00:11:50,050 --> 00:11:59,590
And I want to parse these arguments such that essentially the user provides a flag, let's say.

173
00:11:59,590 --> 00:12:05,620
So I want the user to provide hyphen, hyphen value and some value, let's say ten or hyphen V and some

174
00:12:05,620 --> 00:12:07,120
value like 20, right?

175
00:12:07,360 --> 00:12:09,310
Usually there is at least one space here.

176
00:12:09,340 --> 00:12:10,940
Multiple spaces are fine.

177
00:12:10,960 --> 00:12:12,610
It's not going to break the code.

178
00:12:12,610 --> 00:12:14,790
But for now, I want to do this right.

179
00:12:14,800 --> 00:12:20,350
So first, the very first thing that I do is create a test class here, right?

180
00:12:23,740 --> 00:12:30,820
And then if I do a six out on object value, obviously it gets the default value because it hasn't been

181
00:12:30,820 --> 00:12:31,420
initialized.

182
00:12:31,430 --> 00:12:33,320
JVM will initialize it to zero.

183
00:12:33,340 --> 00:12:36,460
So if I run this, I will get zero, right?

184
00:12:36,460 --> 00:12:38,530
And I'm printing this one also.

185
00:12:38,980 --> 00:12:40,150
So I will get zero.

186
00:12:41,110 --> 00:12:45,910
And then if I want to run this using eclipse and pass command line arguments.

187
00:12:45,910 --> 00:12:51,640
So what I need to do is go here and here, hyphen, hyphen, value ten.

188
00:12:51,640 --> 00:12:52,120
Right?

189
00:12:52,120 --> 00:12:56,110
So if I run this, I still don't get because right now I'm not parsing it.

190
00:12:56,110 --> 00:13:00,100
So what I can do manually is say.

191
00:13:02,390 --> 00:13:06,140
Basically I can write a for loop.

192
00:13:06,960 --> 00:13:07,490
Um.

193
00:13:08,980 --> 00:13:10,300
For ain't.

194
00:13:10,450 --> 00:13:13,030
For example, I equals zero.

195
00:13:13,240 --> 00:13:15,390
Less than that length.

196
00:13:15,740 --> 00:13:16,090
Plus.

197
00:13:16,090 --> 00:13:17,170
Plus I.

198
00:13:17,280 --> 00:13:28,660
I can say if basically if args at index are equals equals hyphen hyphen value or args at index i equals

199
00:13:28,660 --> 00:13:29,380
equals.

200
00:13:29,410 --> 00:13:40,090
Actually this should be double code, not a single code, hyphen, hyphen, value or args at index i

201
00:13:40,090 --> 00:13:41,230
is hyphen v.

202
00:13:41,260 --> 00:13:52,180
Then we're going to say that object that value equals or basically integer dot parse int.

203
00:13:54,030 --> 00:13:57,150
And then args add index I plus one.

204
00:13:57,150 --> 00:13:57,660
Right?

205
00:13:59,160 --> 00:14:03,480
So and then let's run this and now we still get zero.

206
00:14:04,620 --> 00:14:05,420
Um.

207
00:14:05,430 --> 00:14:06,630
Okay, let's see.

208
00:14:06,630 --> 00:14:07,800
Let's run this.

209
00:14:09,260 --> 00:14:11,750
Let's go back to our own configuration.

210
00:14:13,420 --> 00:14:15,230
Hyphen, hyphen, value ten.

211
00:14:15,250 --> 00:14:16,480
We're running this.

212
00:14:17,670 --> 00:14:20,190
So let's do a six out on the ark.

213
00:14:20,340 --> 00:14:21,360
So let's see.

214
00:14:26,230 --> 00:14:28,960
Let's see what kind of command line arguments are past.

215
00:14:30,220 --> 00:14:31,750
A string array.

216
00:14:32,320 --> 00:14:39,700
Maybe we also print these so called args at index i.

217
00:14:42,640 --> 00:14:44,680
So we have hyphen, hyphen value.

218
00:14:46,940 --> 00:14:59,090
Uh, and so actually we shouldn't use double e quality equals this one or args equals hyphen hyphen.

219
00:14:59,270 --> 00:15:02,570
So for string equality we have to use equals.

220
00:15:03,730 --> 00:15:05,020
And now we get ten, right?

221
00:15:05,020 --> 00:15:09,600
So this is how you can manually pass this error.

222
00:15:09,610 --> 00:15:11,380
You have to kind of loop through this.

223
00:15:11,380 --> 00:15:17,900
And then you you write a general for loop and then you write a lot of, if else, statements to figure

224
00:15:17,920 --> 00:15:20,950
out at Index II which flags are passed.

225
00:15:20,950 --> 00:15:26,740
And then once you find a flag, then you can figure out what to do.

226
00:15:26,770 --> 00:15:32,380
You you want to parse it or somehow convert it to some sort of integer value or some other things,

227
00:15:32,380 --> 00:15:32,950
right?

228
00:15:32,950 --> 00:15:35,440
So run this and then this works fine.

229
00:15:35,440 --> 00:15:42,100
But this is tedious and as if you have many, many objects, this, this for loop and if else statements

230
00:15:42,100 --> 00:15:43,240
can become very long.

231
00:15:43,240 --> 00:15:44,470
So we don't want to do this.

232
00:15:44,470 --> 00:15:46,300
So then the question, how do we do that?

233
00:15:46,630 --> 00:15:48,790
We're going to use a framework, right?

234
00:15:48,790 --> 00:15:52,120
So use a J command framework.

235
00:15:52,660 --> 00:15:55,690
So we are creating our empty objects and we want to set its field.

236
00:15:55,690 --> 00:16:00,220
The very first thing that we're going to say, do this, we're going to annotate it with add parameter

237
00:16:01,420 --> 00:16:06,880
and we're going to use the names, which is a string array, and then we're going to initialize it with

238
00:16:07,690 --> 00:16:11,320
the flags, hyphen, hyphen value or hyphen V, right?

239
00:16:12,100 --> 00:16:13,060
And then that's it.

240
00:16:13,060 --> 00:16:14,050
That's all it takes.

241
00:16:14,050 --> 00:16:19,940
And then here we're just going to say that J commander, new builder.

242
00:16:19,960 --> 00:16:28,090
So J Commander only already only has this a new builder which uses the inner class builder that the

243
00:16:28,090 --> 00:16:29,230
J commander has.

244
00:16:29,230 --> 00:16:34,960
And after this we're going to say that basically add object.

245
00:16:36,340 --> 00:16:39,400
And we're going to add our OBJ class.

246
00:16:39,400 --> 00:16:42,940
So we are only going to build one object from this string.

247
00:16:42,940 --> 00:16:48,370
RS And then after that we're going to build it returns the builder, right?

248
00:16:48,370 --> 00:16:55,600
So the new builder builder and then add object returns the builder and in build returns the j commander.

249
00:16:56,500 --> 00:17:02,860
So basically this is a fluent builder interface, fluent builder interface.

250
00:17:04,030 --> 00:17:06,220
And then after we build it, we just tell it.

251
00:17:06,220 --> 00:17:07,900
Now go ahead and pass it.

252
00:17:08,110 --> 00:17:09,580
ARGs Right, that's it.

253
00:17:09,940 --> 00:17:18,070
And so until this build the builder goes through all the objects that we add and then figures out which

254
00:17:18,070 --> 00:17:25,060
ones have this annotation so that it knows which parameters to parse and after that utility now go ahead

255
00:17:25,060 --> 00:17:25,660
and pass it.

256
00:17:25,660 --> 00:17:28,150
So it loops basically it's more or less the same idea.

257
00:17:28,150 --> 00:17:29,580
It just hidden from you.

258
00:17:29,590 --> 00:17:30,970
So if we run this.

259
00:17:32,310 --> 00:17:33,690
We still get ten, right?

260
00:17:33,690 --> 00:17:42,660
And if I go ahead and change this to, let's say -25 and run it, I get -25.

261
00:17:42,660 --> 00:17:44,160
So everything is working fine.

262
00:17:44,190 --> 00:17:46,250
J Commander is a very nice syntax.

263
00:17:46,260 --> 00:17:47,880
You don't need to manually do any.

264
00:17:47,880 --> 00:17:52,320
And if I add a new parameter, let's say double

265
00:17:54,720 --> 00:18:00,780
basically some basically let's say double x, right?

266
00:18:00,780 --> 00:18:10,470
And all I have to do I can do add parameter and then names and then let's say a hyphen, hyphen x.

267
00:18:12,070 --> 00:18:23,140
So if I go ahead and basically so object X, if I run this right now, we're not setting it.

268
00:18:23,140 --> 00:18:28,930
So it gets the default value that the JVM says, but we can also give it a default, right?

269
00:18:30,100 --> 00:18:33,550
So description, hidden order password requires.

270
00:18:36,130 --> 00:18:48,610
So if you look at the parameter again, it has description at arity converter, hidden echo input help.

271
00:18:49,390 --> 00:18:50,860
It does have the help.

272
00:18:50,860 --> 00:18:51,190
Right.

273
00:18:51,190 --> 00:18:52,840
If true, this parameter is for help.

274
00:18:52,840 --> 00:18:58,360
If such a parameter is specified, requirements are no longer checked for their presence and order.

275
00:18:58,360 --> 00:18:58,630
Right.

276
00:18:58,630 --> 00:19:00,220
So these are all the details.

277
00:19:01,150 --> 00:19:07,990
So we said this with the hyphen hyphen x and then pretty much we don't do anything else.

278
00:19:07,990 --> 00:19:08,650
That's it.

279
00:19:08,830 --> 00:19:09,610
You don't.

280
00:19:09,760 --> 00:19:15,160
So if you manually write your own for loop, then if you add more parameters for parsing, you have

281
00:19:15,160 --> 00:19:19,580
to go ahead and add more lines of code for if else statement and check for the flags.

282
00:19:19,600 --> 00:19:24,910
Whereas in Commander, you could just add this annotation, your code doesn't change.

283
00:19:25,390 --> 00:19:28,060
So if I go ahead and.

284
00:19:29,370 --> 00:19:37,410
Into arguments, say hyphen hyphen X is 2.5 and then running it and my ex now gets 2.5.

285
00:19:37,440 --> 00:19:38,950
It's very easy to use.

286
00:19:38,970 --> 00:19:39,510
All right.

287
00:19:40,380 --> 00:19:43,560
So then the question is, now we're using these.

288
00:19:43,680 --> 00:19:48,670
How do we go about and converting it or compiling it to native executable binary?

289
00:19:48,690 --> 00:19:54,330
So if I try to select this and run my native image.

290
00:19:58,020 --> 00:20:03,000
If I compile this, this is most likely not going to work.

291
00:20:03,030 --> 00:20:06,840
The reason is that we've we've said this before.

292
00:20:06,870 --> 00:20:11,790
Right now, the native compiler doesn't know what's going on behind the scenes in the GE Command.

293
00:20:11,790 --> 00:20:19,110
And we know that this uses reflection, uses reflection to figure out.

294
00:20:19,410 --> 00:20:22,710
So let's see what error was given.

295
00:20:23,100 --> 00:20:28,890
So it's it's pretty much giving us error that there are some reflections going on, which I don't know

296
00:20:28,890 --> 00:20:29,360
about.

297
00:20:29,370 --> 00:20:31,470
So it tries to do a fallback.

298
00:20:33,160 --> 00:20:36,280
Now it tries to do a fall back as a rapper.

299
00:20:36,280 --> 00:20:36,580
Right.

300
00:20:36,580 --> 00:20:42,280
So so it uses refraction to figure out the annotations.

301
00:20:42,280 --> 00:20:51,610
And then after that, it uses reflection again to set up basically the values.

302
00:20:51,940 --> 00:20:52,510
Right.

303
00:20:52,630 --> 00:20:53,890
All the parameters.

304
00:20:57,180 --> 00:21:00,300
To access the parameters of all the objects that we register.

305
00:21:00,540 --> 00:21:05,670
If I open up a terminal here, the native image is already telling me it's a fallback which requires

306
00:21:05,670 --> 00:21:07,410
a JDK for execution.

307
00:21:07,860 --> 00:21:14,940
So if I try to run the binary test class with, let's say, hyphen, hyphen, value 25, I could not

308
00:21:14,940 --> 00:21:15,520
find our load.

309
00:21:15,540 --> 00:21:19,530
So we know that when the fallback happens, we can't really run this.

310
00:21:19,860 --> 00:21:20,730
So.

311
00:21:22,240 --> 00:21:23,210
Let's delete this.

312
00:21:23,230 --> 00:21:24,520
So what's the solution?

313
00:21:24,670 --> 00:21:25,090
We know.

314
00:21:25,090 --> 00:21:27,300
We've already seen how to deal with reflection.

315
00:21:27,310 --> 00:21:30,820
We have to tell native image and create those configuration files.

316
00:21:30,820 --> 00:21:33,460
And the way we do it, we run our application.

317
00:21:33,460 --> 00:21:36,280
We the Java Trace, right?

318
00:21:36,280 --> 00:21:42,160
But then because our application accepts command line arguments, we kind of need to go here.

319
00:21:44,290 --> 00:21:51,250
So we are running the Java or Java from the VM and activating the agent lib for the native image.

320
00:21:51,400 --> 00:21:58,690
And we are manually setting the class path and then Java type name.

321
00:21:58,690 --> 00:22:03,520
This is our main class and we're passing some parameters, let's say hyphen, hyphen, value ten and

322
00:22:03,520 --> 00:22:06,100
hyphen hyphen x 2.5.

323
00:22:07,120 --> 00:22:14,590
So you only need to do this once because the tracing agent needs to know and you don't really need to

324
00:22:14,590 --> 00:22:15,400
pass all of them.

325
00:22:15,400 --> 00:22:25,270
Let's say let's only pass value and we will see that basically the compilation will work, right?

326
00:22:25,270 --> 00:22:25,780
So.

327
00:22:27,430 --> 00:22:30,400
So let's run this and our test class right now.

328
00:22:30,910 --> 00:22:34,050
We didn't pass any value for X, so it says to the default.

329
00:22:34,060 --> 00:22:40,870
And if you look at the matter in native image and then reflect config, you see that a lot of the j

330
00:22:40,930 --> 00:22:47,770
commander classes I registered and then we have a name int and then Java and then our main class is

331
00:22:47,770 --> 00:22:49,450
also registered for reflection.

332
00:22:49,450 --> 00:22:57,370
So now if we go ahead and compile to native executable, remember the meta is our is on the class path

333
00:22:57,370 --> 00:23:00,070
of the native image that we use.

334
00:23:00,070 --> 00:23:00,460
Right.

335
00:23:00,460 --> 00:23:03,890
So it's going to pick up on the meta inf.

336
00:23:03,910 --> 00:23:12,700
So let's close these, select our class and then run our native image so it will automatically pick

337
00:23:12,700 --> 00:23:13,620
up this matter.

338
00:23:13,630 --> 00:23:18,670
INF And is a reflection config and hopefully it's going to work fine.

339
00:23:24,210 --> 00:23:27,110
So let's wait for it to finish compilation.

340
00:23:27,140 --> 00:23:33,110
No, that what we needed to do was to also pass some command line arguments because if you don't pass

341
00:23:33,110 --> 00:23:39,200
when you run the job or tracing agent, we know that reflections happen in two places, one at the time

342
00:23:39,200 --> 00:23:42,470
of the build and the other one at a time of passing.

343
00:23:42,470 --> 00:23:47,990
So when we run our Java Trace agent, if we don't pass any command line arguments, we don't get all

344
00:23:47,990 --> 00:23:49,130
the configurations.

345
00:23:49,130 --> 00:23:52,250
So let's open up a terminal here.

346
00:23:56,010 --> 00:23:58,690
So let's say hyphen hyphen value 25.

347
00:23:58,710 --> 00:23:59,560
It works fine.

348
00:23:59,580 --> 00:24:04,220
X gets the default value zero and then hyphen hyphen x 2.5.

349
00:24:04,230 --> 00:24:05,730
And this doesn't work.

350
00:24:05,730 --> 00:24:05,970
Right?

351
00:24:05,970 --> 00:24:11,550
So the reason this doesn't work because we didn't register this hyphen hyphen x, so you really have

352
00:24:11,550 --> 00:24:13,740
to run this with all the parameters.

353
00:24:14,070 --> 00:24:19,470
And then so that in the configuration we know everything about it.

354
00:24:20,610 --> 00:24:22,850
So let's go back and terminate.

355
00:24:22,860 --> 00:24:29,220
So I'm going to delete the matter INF And then I'm going to also delete this binary.

356
00:24:29,910 --> 00:24:33,990
And now what I'm going to do, I'm going to run my Java Trace agent.

357
00:24:35,220 --> 00:24:43,050
But then also add hyphen, hyphen X, let's say -11.5, something to invoke this reflection that happens

358
00:24:43,050 --> 00:24:44,160
for the X as well.

359
00:24:44,490 --> 00:24:48,220
So let's run this and everything works fine.

360
00:24:48,240 --> 00:24:54,690
And now if we look at the meta inf and then reflect config, we have two reflection fields.

361
00:24:54,690 --> 00:24:57,600
One is double, the other one is eight.

362
00:24:57,600 --> 00:24:57,840
Right?

363
00:24:57,840 --> 00:25:01,200
So you have to register all these fields a little bit tedious.

364
00:25:01,380 --> 00:25:03,180
It kind of defeats the purpose.

365
00:25:03,390 --> 00:25:07,560
But if you just want to run your application on top of Gvm, obviously you don't care.

366
00:25:07,560 --> 00:25:08,340
It's very easy.

367
00:25:08,340 --> 00:25:14,580
But if you want to compile to a native executable, you have to tell a native compiler about all these

368
00:25:14,580 --> 00:25:18,810
parameters and that use reflection.

369
00:25:18,810 --> 00:25:26,130
And for that you have to run your application with a Java Trace agent at least one time and then pass

370
00:25:26,130 --> 00:25:32,370
all the flags that your application will accept so that that configuration file, the reflect config

371
00:25:32,370 --> 00:25:37,710
picks up on all the parameters that will be set or can be set on the command line.

372
00:25:38,190 --> 00:25:44,190
So if we now select our class and then run our native image, this time everything should work fine.

373
00:25:44,520 --> 00:25:51,060
We accept only two command line parameters hyphen, hyphen value or hyphen V equivalently, and then

374
00:25:51,060 --> 00:25:56,700
hyphen hyphen X and then the native image has information about all these two parameters.

375
00:25:58,690 --> 00:26:01,270
So let's wait until this finishes up.

376
00:26:01,270 --> 00:26:02,080
And then.

377
00:26:03,630 --> 00:26:05,400
We will test the result.

378
00:26:16,410 --> 00:26:17,520
Almost done.

379
00:26:17,520 --> 00:26:18,060
Done.

380
00:26:18,060 --> 00:26:20,670
So let's look at let's open a terminal here.

381
00:26:22,720 --> 00:26:25,570
And then let's run this.

382
00:26:26,110 --> 00:26:29,800
So hyphen value 25, hyphen x 2.5.

383
00:26:29,800 --> 00:26:30,870
Everything works fine.

384
00:26:30,880 --> 00:26:36,820
We don't get any exception now for x because it's already in it was already in the configuration file

385
00:26:36,820 --> 00:26:37,840
for reflection.

386
00:26:38,110 --> 00:26:43,750
The other thing is now we can also test the other option hyphen hyphen, hyphen v still works fine,

387
00:26:43,750 --> 00:26:44,200
right?

388
00:26:44,200 --> 00:26:48,670
If we pass a different flag, let's say hyphen P, it's not going to work.

389
00:26:48,670 --> 00:26:50,260
So we get an exception.

390
00:26:50,620 --> 00:26:53,650
But no main parameter was defined in your class.

391
00:26:53,650 --> 00:26:53,890
Right.

392
00:26:53,890 --> 00:26:56,710
So that's kind of exception happens.

393
00:26:57,580 --> 00:27:01,660
I believe we can configure it to kind of ignore that flag.

394
00:27:02,050 --> 00:27:06,810
But for now and the other thing that you might already know, that the order of the flags don't matter,

395
00:27:06,820 --> 00:27:10,960
hyphen, hyphen X, if we don't pass it, we get zero.

396
00:27:10,990 --> 00:27:12,760
We can't set the required flag.

397
00:27:12,760 --> 00:27:23,020
So if here we say that required equal to then and then we go ahead and compile.

398
00:27:26,050 --> 00:27:29,010
We already have the basically metal.

399
00:27:29,380 --> 00:27:31,210
So we just go ahead and compile.

400
00:27:33,380 --> 00:27:34,420
Quickly.

401
00:27:34,430 --> 00:27:37,430
Let's see what happens if we set the required to true.

402
00:27:37,430 --> 00:27:43,610
But then we don't pass this flag at the right at the time we run our binary file.

403
00:27:51,730 --> 00:27:52,840
Almost done.

404
00:28:04,410 --> 00:28:07,140
All right, Don, let's refresh this.

405
00:28:07,770 --> 00:28:10,710
We get the binary, let's open up our terminal.

406
00:28:10,800 --> 00:28:15,210
And now let's see what happens if we don't set it exception.

407
00:28:15,210 --> 00:28:19,050
The following option is required hyphen hyphen value or hyphen v.

408
00:28:19,050 --> 00:28:21,540
Now it says that you have to have to pass it.

409
00:28:22,770 --> 00:28:27,150
So we have to say hyphen v 12.

410
00:28:27,180 --> 00:28:27,840
It works.

411
00:28:27,840 --> 00:28:29,400
What if we pass a float?

412
00:28:29,580 --> 00:28:34,450
It's going to give us exception saying that couldn't convert 12.5 to an integer.

413
00:28:34,470 --> 00:28:35,400
So what's it saying?

414
00:28:35,400 --> 00:28:37,650
That you have to make sure that this is all

415
00:28:40,830 --> 00:28:42,360
this is all set.

416
00:28:42,360 --> 00:28:42,900
Right.

417
00:28:43,590 --> 00:28:48,360
So I hope you enjoyed this lecture and now have a good understanding how to easily use this command

418
00:28:48,360 --> 00:28:53,730
and framework to set up flags for your Java application and then what to do when you want to compile

419
00:28:53,730 --> 00:28:55,680
it to native executable binary.

420
00:28:55,680 --> 00:29:02,580
You have to run it with the JVM using the tracing agent so that you you create the configuration file

421
00:29:02,580 --> 00:29:07,890
for all the reflections that happen in the command there, and then the rest is very easy.

422
00:29:07,890 --> 00:29:11,280
You just compile your application and all the flags stay the same.

423
00:29:11,280 --> 00:29:12,630
I hope you enjoyed this lecture.

424
00:29:12,630 --> 00:29:14,970
Please stay tuned and I'll see the next one.
