1
00:00:01,010 --> 00:00:03,380
Hello and welcome to another tutorial.

2
00:00:03,380 --> 00:00:09,890
We are going to continue our discussion on how to run a Java application and then look at what is the

3
00:00:09,890 --> 00:00:13,910
difference between running your job application and the JV team.

4
00:00:13,910 --> 00:00:19,550
Basically you launch the JV team or the Java command line tool and then you tell it where your class

5
00:00:19,550 --> 00:00:21,950
file that contains the main method is.

6
00:00:21,950 --> 00:00:23,060
And then what is?

7
00:00:23,060 --> 00:00:28,040
What happens when we actually compile our job application to a native binary using the native image

8
00:00:28,040 --> 00:00:29,930
tool that comes with grad VM?

9
00:00:29,930 --> 00:00:30,440
All right.

10
00:00:30,890 --> 00:00:38,960
So in the previous lecture, we saw that basically organizing your Java application and let me bring

11
00:00:38,960 --> 00:00:39,560
up the terminal.

12
00:00:39,560 --> 00:00:42,140
We saw that organizing your Java application.

13
00:00:42,170 --> 00:00:45,830
Obviously, you don't want every job, all the Java files to be in the same directory.

14
00:00:45,830 --> 00:00:51,980
Sometimes you have multiple directories and then also sometimes you want them to belong to some package,

15
00:00:51,980 --> 00:00:52,310
right?

16
00:00:52,310 --> 00:00:58,340
Just because if you're creating a library, you want to put your class files, you make them belong

17
00:00:58,340 --> 00:01:06,140
to packages so that later on somebody else can add them to their basically class path and be able to

18
00:01:07,460 --> 00:01:11,510
use those codes that already exists in their application too.

19
00:01:11,510 --> 00:01:17,840
But then the problem was that compiling and running the Java application is not a trivial task because

20
00:01:17,840 --> 00:01:25,970
of the way that Java Java compiler and the JVM, which is the Java command line, handle the dependencies

21
00:01:25,970 --> 00:01:26,780
of your classes.

22
00:01:26,780 --> 00:01:33,380
And we saw that if I have a helloworld class and a core class and each one is defined its own in its

23
00:01:33,380 --> 00:01:39,710
own Java source file, and then if they're in two different directories and we saw that in this example

24
00:01:39,710 --> 00:01:44,120
for simplicity, we didn't make these classes to belong to any packages.

25
00:01:44,420 --> 00:01:52,280
And basically the idea was that I couldn't just directly compile the hello world because it had a dependency

26
00:01:52,280 --> 00:01:53,120
on the car.

27
00:01:53,240 --> 00:01:59,780
So I have to I had to first tell the Java compiler to compile the car Java to create the card that class.

28
00:02:00,020 --> 00:02:05,840
Because when I run the Java compiler and the Helloworld Java, it realizes that there is a dependency

29
00:02:05,840 --> 00:02:12,740
and then it needs to ensure that Java always tries to be on the safe side and ensure that if it's trying

30
00:02:12,740 --> 00:02:17,180
to compile this class, there shouldn't be any error, which means all the dependencies, all other

31
00:02:17,180 --> 00:02:20,720
types that this class use have to be known to the compiler.

32
00:02:20,720 --> 00:02:26,870
The compiler has to ensure that at compile time the ODIs, the other class files that are associated

33
00:02:26,870 --> 00:02:32,060
with these types such as CAR in this case already exist on the on the hard disk.

34
00:02:32,060 --> 00:02:32,570
Right.

35
00:02:33,780 --> 00:02:41,130
So we had to specify the hyphen CPO or hyphen class path write this class path parameter and this here

36
00:02:41,140 --> 00:02:46,560
released all the directories that the Java compiler or the JVM can search into.

37
00:02:46,560 --> 00:02:52,710
And we said this is very similar to the path environment variable that the operating system and the

38
00:02:52,710 --> 00:02:53,610
terminal understand.

39
00:02:53,610 --> 00:02:53,820
Right.

40
00:02:53,820 --> 00:02:54,510
It's very similar.

41
00:02:54,780 --> 00:03:00,000
Path is an environment variable that has or has a list of directories.

42
00:03:00,000 --> 00:03:06,720
So so that when you type some in some name, the terminal assumes that this is some sort of binary executable

43
00:03:06,720 --> 00:03:08,010
binary application.

44
00:03:08,010 --> 00:03:14,160
So it tries to search into all the directories that are included in the path to see where it can find

45
00:03:14,160 --> 00:03:15,270
an application with this name.

46
00:03:15,270 --> 00:03:15,690
Right.

47
00:03:15,870 --> 00:03:22,560
And we said that in Java you cannot tell it Java and then the full path or the relative path to the

48
00:03:22,560 --> 00:03:24,730
class file that doesn't board in order.

49
00:03:24,750 --> 00:03:32,160
Instead you have to tell JVM this hyphen CP parameter and give it a list of directories that the JVM

50
00:03:32,160 --> 00:03:37,290
can search into to find all the classifiers that it needs to run your job application.

51
00:03:37,290 --> 00:03:37,740
Right?

52
00:03:38,700 --> 00:03:41,310
So the concept of class path is very important.

53
00:03:41,640 --> 00:03:51,750
And then basically there is another thing that we can do and that's I mentioned that you can define

54
00:03:51,750 --> 00:03:55,020
something called the class path environment variable.

55
00:03:55,020 --> 00:04:02,820
And if you define it in your terminal, when you launch your JVM, then basically you don't really need

56
00:04:02,820 --> 00:04:03,660
to specify that.

57
00:04:03,660 --> 00:04:04,200
CPP.

58
00:04:04,230 --> 00:04:07,380
So what I mean by that, right now I'm in the test directory, right?

59
00:04:07,380 --> 00:04:12,900
So if I say Java and then Hello World, I've already compiled these, right?

60
00:04:12,930 --> 00:04:16,260
It's not going to work because it cannot find this card class.

61
00:04:16,260 --> 00:04:16,680
Right.

62
00:04:16,680 --> 00:04:23,760
So I have to tell it Java hyphen CPP and then the current directory where my hell of all classes and

63
00:04:23,760 --> 00:04:30,270
then colon which is a class path separator and I'm going to tell it, go to one level up and then go

64
00:04:30,270 --> 00:04:32,070
into the Test two directory.

65
00:04:32,070 --> 00:04:40,980
So I'm specifying two directories on my class path when I launch my application that have these that

66
00:04:40,980 --> 00:04:43,620
have all my class files that the application needs.

67
00:04:43,620 --> 00:04:49,680
And then Italy launched the Hello World Class, which means JVM launches or runs the main method of

68
00:04:49,680 --> 00:04:50,730
this particular class.

69
00:04:50,730 --> 00:04:52,830
And this works right now.

70
00:04:52,830 --> 00:04:57,360
So if I don't specify the class path, I get an exception, right?

71
00:04:57,360 --> 00:05:04,080
So the application terminates unexpectedly just because it cannot find these core class, right?

72
00:05:04,200 --> 00:05:12,540
But then what I can do is I can basically open up a text file, right?

73
00:05:12,540 --> 00:05:21,570
And then I'm going to open Subtree, I'm going to go and then open up this bash.

74
00:05:21,570 --> 00:05:27,870
RC So this is where you can define the environment variables, right, for your terminal.

75
00:05:27,870 --> 00:05:36,570
So I'm going to define another one, define or a class path, class path environment variable.

76
00:05:36,600 --> 00:05:42,480
Now when you globally define these class path environment variable for your terminal, every time you

77
00:05:42,480 --> 00:05:48,060
launch the terminal, those directories that the class path is pointing to or are already available

78
00:05:48,060 --> 00:05:48,570
to JVM.

79
00:05:48,570 --> 00:05:56,670
So we say export class path equals right and then we give it a list of directories and then the separator

80
00:05:56,670 --> 00:05:57,540
is colon.

81
00:05:57,540 --> 00:05:59,600
So we can say, for example.

82
00:06:01,290 --> 00:06:02,970
I'm going to give you the absolute path.

83
00:06:02,970 --> 00:06:09,090
So I'm going to copy the full path to the clipboard and then go back here and put it here.

84
00:06:09,270 --> 00:06:09,930
All right.

85
00:06:10,230 --> 00:06:17,460
Now, what this does is this is basically the full path to this test to.

86
00:06:17,490 --> 00:06:17,970
Right.

87
00:06:18,000 --> 00:06:26,640
Now, I can also appendix dot and then give it another path and what you can do basically export class

88
00:06:26,640 --> 00:06:27,660
path again.

89
00:06:27,660 --> 00:06:31,650
But here what we're going to say that we're going to give it this test.

90
00:06:31,650 --> 00:06:36,060
Also the fully qualified name of this test.

91
00:06:36,270 --> 00:06:37,800
I'm going to put it in double code.

92
00:06:37,800 --> 00:06:44,400
If your name, the folder name has a space or something, you have to put it into inside double codes.

93
00:06:44,400 --> 00:06:48,450
But I'm going to append it with the original class path variable.

94
00:06:48,480 --> 00:06:49,830
So this appends.

95
00:06:49,830 --> 00:06:55,410
So the class path operator is calling it reads the when you use dollar sign, it means it's an environment

96
00:06:55,410 --> 00:06:57,050
variable and it's reading the value.

97
00:06:57,060 --> 00:07:01,110
The original value is test two and now the test directory is also appended.

98
00:07:01,110 --> 00:07:01,590
Right.

99
00:07:02,400 --> 00:07:05,910
So if I save this and then go back to my terminal.

100
00:07:07,620 --> 00:07:08,730
What I'm going to do.

101
00:07:09,750 --> 00:07:16,020
Either you have to restart the terminal or use a command called source to that.

102
00:07:16,200 --> 00:07:18,390
Reload this bash RC file.

103
00:07:18,420 --> 00:07:21,660
So I'm going to say that source from home directory.

104
00:07:21,690 --> 00:07:23,340
Load the bash RC file again.

105
00:07:24,400 --> 00:07:25,150
Let's see.

106
00:07:25,390 --> 00:07:27,280
And everything is successful.

107
00:07:28,090 --> 00:07:38,110
And then if I try to read this basically class path environment, variable eco class path, you see

108
00:07:38,110 --> 00:07:40,570
there are two directories on my class path.

109
00:07:40,600 --> 00:07:41,170
All right.

110
00:07:41,470 --> 00:07:44,050
Now let's go out.

111
00:07:44,560 --> 00:07:51,190
So I'm going to let's even go to the desktop right from home direct.

112
00:07:51,190 --> 00:07:52,240
I'm on my desktop.

113
00:07:52,240 --> 00:07:52,690
Right.

114
00:07:52,960 --> 00:07:56,440
And then what I'm going to do, I'm going to say Java Hello World.

115
00:07:57,850 --> 00:08:00,960
Let's see if it's successful in running this or not.

116
00:08:00,970 --> 00:08:06,400
And as you can see, it's fully successful despite the fact that I'm not even in any of these tests

117
00:08:06,400 --> 00:08:09,540
or test two directories in my desktop.

118
00:08:09,550 --> 00:08:16,660
But when I told JVM to find a class file called Hello World Class and execute its main method, it had

119
00:08:16,660 --> 00:08:23,320
no problem because Java behind the scenes, it tries to see if there is a global environment variable

120
00:08:23,320 --> 00:08:27,010
for your operating system called the class path if it finds one.

121
00:08:27,700 --> 00:08:33,960
It also includes all the directories that are defined by the class path to your class path variable.

122
00:08:33,970 --> 00:08:39,210
So I can still specify hyphen c p something like current directory.

123
00:08:39,220 --> 00:08:39,760
Right.

124
00:08:40,390 --> 00:08:43,030
And then say hello world.

125
00:08:43,630 --> 00:08:44,860
And this doesn't work.

126
00:08:44,860 --> 00:08:54,250
When you explicitly basically provide this hyphen CPP for the Java it overwrites, it doesn't look for

127
00:08:54,250 --> 00:08:56,200
the class path environment very well again.

128
00:08:56,200 --> 00:09:02,560
So what you can do is say, for example, current directory call in and then that class path environment

129
00:09:02,560 --> 00:09:04,200
variable and then hello.

130
00:09:04,300 --> 00:09:06,640
All right, so.

131
00:09:08,360 --> 00:09:10,420
Uh, basically.

132
00:09:10,430 --> 00:09:17,210
So what happens here is that the problem with this is that you I guess we should put this in double

133
00:09:17,210 --> 00:09:19,070
code or do something else.

134
00:09:20,450 --> 00:09:21,920
Let's see if this works.

135
00:09:23,400 --> 00:09:25,380
Double code and now it works.

136
00:09:25,380 --> 00:09:29,820
So that's because there are forward slashes and other things.

137
00:09:29,820 --> 00:09:32,760
So put this environment variables.

138
00:09:32,760 --> 00:09:36,770
If you want to read the value, put them in double code so that there is no problem.

139
00:09:36,780 --> 00:09:43,500
So basically this if there are some dependencies for your classes, let's say there are some libraries

140
00:09:43,500 --> 00:09:50,700
that you always use, it's better to define the directories that contain those libraries as a class

141
00:09:50,700 --> 00:09:56,700
path, as an environment variable, so that whatever application and you write, you compile those directories

142
00:09:56,700 --> 00:09:59,580
are available to your Java application, right?

143
00:09:59,910 --> 00:10:01,860
So for example, if I,

144
00:10:04,710 --> 00:10:11,700
let's say, if I, if I create a new directory, let's say test three and here I'm going to create a

145
00:10:11,700 --> 00:10:12,660
class file.

146
00:10:14,310 --> 00:10:14,940
Right.

147
00:10:15,270 --> 00:10:18,510
And let's rename these to something else.

148
00:10:18,510 --> 00:10:25,560
Let's say instead of car, let's say machine and let's open it.

149
00:10:25,740 --> 00:10:31,220
And here we're going to we have to rename it to Machine because if there is a public class definition,

150
00:10:31,230 --> 00:10:33,270
a source file, the name has to match.

151
00:10:33,300 --> 00:10:47,400
And then we're going to say that a string type and then we're going to pass the string here and then

152
00:10:47,580 --> 00:10:54,990
we're going to obviously the name of the constructor should also be machine and we're going to say that

153
00:10:56,610 --> 00:11:02,640
machine and then type equals percent s and then this is going to be type.

154
00:11:02,880 --> 00:11:03,540
All right.

155
00:11:03,540 --> 00:11:07,560
And then we go back to the hello world and then we create a car.

156
00:11:07,560 --> 00:11:09,420
Then we create also a machine.

157
00:11:10,020 --> 00:11:15,360
New machine type is a printer, for example.

158
00:11:15,360 --> 00:11:21,240
And then we we're saying that sys print line machine.

159
00:11:22,170 --> 00:11:22,740
All right.

160
00:11:23,400 --> 00:11:24,990
Now going back here.

161
00:11:26,230 --> 00:11:29,890
Right now I am in my desktop directory.

162
00:11:29,890 --> 00:11:35,650
So what I'm going to do, I'm going to back go back to the bash RC and then try to export basically

163
00:11:35,650 --> 00:11:37,540
do the same thing I'm going to.

164
00:11:39,740 --> 00:11:41,030
Go back here.

165
00:11:41,390 --> 00:11:43,550
Class path equals.

166
00:11:43,880 --> 00:11:44,430
And then.

167
00:11:44,450 --> 00:11:48,960
And I'm going to basically append the test three to my class path.

168
00:11:48,980 --> 00:11:49,520
All right.

169
00:11:49,910 --> 00:11:54,320
Now I'm going to source the bash RC again to reload this environment variable.

170
00:11:54,330 --> 00:11:58,640
So if I say a class path now, there are three directories on my class path.

171
00:11:58,640 --> 00:11:59,150
Right.

172
00:11:59,390 --> 00:12:02,720
Test three and then let's see.

173
00:12:04,260 --> 00:12:05,810
So we have a.

174
00:12:07,640 --> 00:12:09,950
Test two and then test.

175
00:12:10,820 --> 00:12:10,970
Okay.

176
00:12:11,060 --> 00:12:11,900
So.

177
00:12:13,100 --> 00:12:13,940
Let's see.

178
00:12:14,460 --> 00:12:16,250
So I'm going to let's close these.

179
00:12:18,980 --> 00:12:19,490
All right.

180
00:12:19,490 --> 00:12:21,860
And then reload a new window.

181
00:12:24,800 --> 00:12:27,560
And Echo Classpass.

182
00:12:27,560 --> 00:12:30,590
And now we have test three, test and test two.

183
00:12:30,620 --> 00:12:31,190
Right.

184
00:12:31,310 --> 00:12:39,260
So there are three directories and I can say Java C and then directly compile that helloworld java.

185
00:12:40,490 --> 00:12:51,380
So file not for obviously here you have to specify the full path to that basically helloworld java.

186
00:12:51,380 --> 00:12:59,060
So let's say right click on this and then copy full path to clipboard and then go back to the terminal.

187
00:12:59,060 --> 00:13:07,610
And then we are going to compile this and note that I'm not specifying the I didn't specify this machine,

188
00:13:07,610 --> 00:13:08,300
it's not there.

189
00:13:08,300 --> 00:13:14,540
But because Java C also looks at looks at an environment variable called class path.

190
00:13:14,870 --> 00:13:20,960
And if your class file if your Java source for Helloworld depends on a dependency like machine class

191
00:13:20,990 --> 00:13:28,490
Java C also looks at those directories that are included in the environment variable to see if it can

192
00:13:28,490 --> 00:13:35,750
find a dependent file called machine class and now I can even executed hello world.

193
00:13:35,840 --> 00:13:41,510
Now note the difference when you compile a file, you have to give it a path where it is on the operating

194
00:13:41,510 --> 00:13:42,110
system.

195
00:13:42,230 --> 00:13:48,110
When you launch a Java application, you have to tell JVM the name of the class file that has the main

196
00:13:48,110 --> 00:13:48,380
method.

197
00:13:48,380 --> 00:13:51,920
You don't specify the path to that class file, right?

198
00:13:51,920 --> 00:13:58,550
You just tell it the name and JVM fully relies on the class path, all the directories on the class

199
00:13:58,550 --> 00:14:00,560
path, and it tries to search into them.

200
00:14:01,010 --> 00:14:01,910
So this works.

201
00:14:01,910 --> 00:14:02,540
Why?

202
00:14:02,540 --> 00:14:04,700
Because I didn't specify any class path.

203
00:14:04,700 --> 00:14:06,800
I'm not even in the test directory.

204
00:14:06,800 --> 00:14:07,910
I'm somewhere else.

205
00:14:07,910 --> 00:14:14,210
But when I launch it in terminal, the class path environment variable is defined.

206
00:14:14,210 --> 00:14:14,840
All right.

207
00:14:15,020 --> 00:14:22,370
And therefore, what happens here is that the JVM just searches into all the three directories and tries

208
00:14:22,370 --> 00:14:26,060
to find a class file called Hello World.

209
00:14:26,240 --> 00:14:26,750
All right.

210
00:14:26,750 --> 00:14:32,420
So again, for when you launch your Java application, you don't provide the fully full name of the

211
00:14:32,420 --> 00:14:33,980
file all class.

212
00:14:33,980 --> 00:14:35,480
That's not how it works, right?

213
00:14:35,480 --> 00:14:42,620
You just provide the name of the class file or the name of the type if it belongs to a package.

214
00:14:42,620 --> 00:14:47,630
You have to also specify the package hierarchy here, the type or the class that has the main method,

215
00:14:47,630 --> 00:14:53,330
and JVM only searches into the directories that are specified on the class path.

216
00:14:53,630 --> 00:15:00,620
Now you can manually specify the class path directories using hyphen, CPP command line argument, or

217
00:15:00,620 --> 00:15:06,290
you can define them globally in a variable in an environment variable called class path, right?

218
00:15:06,290 --> 00:15:11,780
And you can append multiple directories using the colon, which is the class path separator.

219
00:15:12,410 --> 00:15:13,730
So I hope you understand this.

220
00:15:13,730 --> 00:15:17,210
Now what I want to show you is the concept of native image.

221
00:15:17,210 --> 00:15:21,110
So let's go back here.

222
00:15:21,110 --> 00:15:26,780
So copy, fully qualified name, let's change the directory into that.

223
00:15:26,780 --> 00:15:27,410
All right.

224
00:15:28,520 --> 00:15:37,550
And then so right now what we want to do, let's see if we can basically compile this hello world.

225
00:15:37,910 --> 00:15:39,830
Hello world class to the native bytes.

226
00:15:39,830 --> 00:15:47,990
So I have installed the VM basically native image I will show you in the future lectures how to do it

227
00:15:47,990 --> 00:15:48,500
right.

228
00:15:48,800 --> 00:15:58,670
And then what I'm going to do, I'm going to tell it to compile test let's it's in the test and then

229
00:15:59,690 --> 00:16:00,920
basically.

230
00:16:02,080 --> 00:16:03,540
What do we want to compile?

231
00:16:03,550 --> 00:16:04,420
Hello world.

232
00:16:04,450 --> 00:16:05,890
Let's see if this works.

233
00:16:08,200 --> 00:16:10,600
Actually, I think the class path is already defined.

234
00:16:10,600 --> 00:16:11,830
So what we want to do.

235
00:16:11,860 --> 00:16:15,000
We just want to compile the hello world.

236
00:16:15,010 --> 00:16:21,400
I believe it will able to it will be able to find a hello world not found.

237
00:16:21,400 --> 00:16:23,650
So let's see.

238
00:16:24,850 --> 00:16:25,330
Tess.

239
00:16:25,330 --> 00:16:26,260
Hello world.

240
00:16:28,690 --> 00:16:32,620
Not found, so it's still not able to find it.

241
00:16:33,990 --> 00:16:40,560
So what we can do, we can specify basically I guess the same class path argument.

242
00:16:40,560 --> 00:16:43,640
So hyphen c p class path.

243
00:16:43,650 --> 00:16:44,130
All right.

244
00:16:44,130 --> 00:16:44,790
And then

245
00:16:48,000 --> 00:16:50,520
hello world.

246
00:16:55,410 --> 00:17:00,930
Now it's working, which means what it does, it searches into all the directories that are specified

247
00:17:00,930 --> 00:17:07,500
in this environment variable and it is able to find a class file called Hello World Class and it starts

248
00:17:07,500 --> 00:17:09,330
to compiling it to the native binary.

249
00:17:09,360 --> 00:17:16,020
Obviously this class has dependencies caught on machine and both of them are specified in the class

250
00:17:16,020 --> 00:17:16,260
path.

251
00:17:16,260 --> 00:17:21,330
So the native image has no problem finding them and also compiling them to the native binary.

252
00:17:21,360 --> 00:17:25,620
What it does eventually it creates a native image.

253
00:17:25,860 --> 00:17:32,670
Now the compilation succeeded and it says that I created a executable binary, which is Hello World.

254
00:17:32,670 --> 00:17:33,750
And you see, it's here.

255
00:17:33,780 --> 00:17:34,320
All right.

256
00:17:35,390 --> 00:17:37,010
Now let's see if we can execute it.

257
00:17:37,130 --> 00:17:43,280
So the execution of the native binaries applications in terminal are different from KVM, right?

258
00:17:43,280 --> 00:17:46,970
When you launch the Java, you cannot give the path to the file.

259
00:17:46,970 --> 00:17:50,450
You have to specify the directories in the class path.

260
00:17:50,450 --> 00:17:55,190
Whereas when you want to execute a native binary, you provide the full path.

261
00:17:55,190 --> 00:17:57,680
So I'm in the Java native image.

262
00:17:57,680 --> 00:18:00,110
So from the current directory hello world.

263
00:18:00,350 --> 00:18:02,630
And this is a fully executable file.

264
00:18:02,630 --> 00:18:04,040
It's a binary application.

265
00:18:04,040 --> 00:18:07,700
It doesn't rely any under any JVM, it doesn't anything.

266
00:18:07,700 --> 00:18:11,210
It's fully dead and it works pretty well.

267
00:18:11,210 --> 00:18:11,690
Right?

268
00:18:11,690 --> 00:18:15,950
So we compiled our Java application into a native binary.

269
00:18:15,950 --> 00:18:18,410
So this helloworld is a native binary.

270
00:18:19,220 --> 00:18:23,180
I can give the full qualified name of this file.

271
00:18:23,180 --> 00:18:23,840
Right?

272
00:18:23,840 --> 00:18:31,850
So this is the, the fully basically the path, the directory hierarchy to the name of the executable

273
00:18:31,970 --> 00:18:36,170
and in terminal Wendy this works.

274
00:18:36,170 --> 00:18:43,250
You can always execute a native binary by providing either a relative path to it or a full path to it.

275
00:18:43,640 --> 00:18:45,470
But if I execute it, it still works fine.

276
00:18:45,500 --> 00:18:47,210
Hello world from Java application.

277
00:18:47,210 --> 00:18:49,730
But this is not we're not launching JVM.

278
00:18:49,730 --> 00:18:53,600
We just compiled our application directly to a native binary.

279
00:18:53,690 --> 00:18:54,320
All right?

280
00:18:54,680 --> 00:18:56,450
And now it works fine.

281
00:18:56,450 --> 00:18:58,520
It gives us the output that we expect.

282
00:18:58,520 --> 00:19:05,060
And right now, the way we compile our application was to rely on this class path, which is globally

283
00:19:05,060 --> 00:19:09,920
defined and native image had no problem finding our class files.

284
00:19:09,970 --> 00:19:14,900
Hello all and all the dependencies that it has, which is called class and machine class.

285
00:19:15,860 --> 00:19:20,930
Obviously for large programs it's not recommended to basically.

286
00:19:22,500 --> 00:19:25,830
Rely on this environment variable because you have to manually add them.

287
00:19:25,830 --> 00:19:27,450
So there are better ways to manage them.

288
00:19:27,450 --> 00:19:33,120
But in the terminal, if there are some dependencies that you always use for all your Java application,

289
00:19:33,120 --> 00:19:37,560
it's best to also define them as a global variable called class path.

290
00:19:37,560 --> 00:19:43,350
And the point here was to show you that you can define this class path environment variable and the

291
00:19:43,350 --> 00:19:46,590
Java Sea and Java or the JVM.

292
00:19:46,590 --> 00:19:52,320
They will also look at try to search for a variable called class path that is defined or known to your

293
00:19:52,320 --> 00:19:52,730
terminal.

294
00:19:52,740 --> 00:19:53,220
All right.

295
00:19:53,790 --> 00:19:54,540
So.

296
00:19:55,500 --> 00:19:59,190
I just showed you an example, a quick example of what a native image is.

297
00:19:59,190 --> 00:20:02,520
You write your application in Java using a Java ID.

298
00:20:02,520 --> 00:20:06,540
It saves you a lot of time for developing a big application.

299
00:20:06,990 --> 00:20:12,450
Note that what we're comparing to, we're comparing developing a Java application to a C++ application,

300
00:20:12,450 --> 00:20:17,670
because once you compile your application to native binary, you essentially are equivalent.

301
00:20:17,670 --> 00:20:23,640
You're getting an equivalent to a C++ application that is compile to native binary launching.

302
00:20:23,640 --> 00:20:25,350
This is instantaneous.

303
00:20:25,350 --> 00:20:30,090
There is no JVM, there is no loading any JDK class files into memory, nothing.

304
00:20:30,150 --> 00:20:36,210
Now the main difference, you will see that the size of this native binary from Java is much larger

305
00:20:36,210 --> 00:20:39,960
than if you write an equivalent C++ application the file size.

306
00:20:40,260 --> 00:20:44,100
If you compile, write this application that prints something to the console.

307
00:20:44,100 --> 00:20:45,390
It's just a hello world.

308
00:20:45,390 --> 00:20:53,820
Some objects in C++, the final file, which is executable, it's going to be like a couple of kilobytes.

309
00:20:53,820 --> 00:20:56,250
But here this helloworld is probably around.

310
00:20:57,420 --> 00:21:04,680
We can look at the properties, so it's run 11 megabytes and most of these size comes from compiling

311
00:21:04,680 --> 00:21:05,790
the JDK classes.

312
00:21:05,790 --> 00:21:07,800
Remember, your application depends on them.

313
00:21:07,800 --> 00:21:12,240
So the native image compiler has to compile also all of them, right?

314
00:21:12,420 --> 00:21:19,320
So this 11 megabyte, essentially a compiled version of all the classes that come with the JDK and your

315
00:21:19,320 --> 00:21:24,120
application is probably just a few kilobytes that gets added to that 11 megabyte.

316
00:21:24,120 --> 00:21:24,630
All right.

317
00:21:24,870 --> 00:21:32,310
But again, the benefit is that this launched instantaneously and you pretty much get the optimized

318
00:21:32,310 --> 00:21:38,460
version because the native binary has a static compiler that does a lot of static optimization.

319
00:21:38,460 --> 00:21:43,740
So you get more or less equivalent to a C++ optimized the compilation.

320
00:21:45,160 --> 00:21:51,040
So now that you've seen the example of Native Image, I'm going to give you more details of what this

321
00:21:51,040 --> 00:21:51,420
is.

322
00:21:51,430 --> 00:21:56,110
So the job of operating system is to manage the applications running on your computer.

323
00:21:56,110 --> 00:22:01,030
Every time you double click on an executable file, it gets executed.

324
00:22:01,030 --> 00:22:08,440
Every time you type the name of a executable file, write this helloworld in executable executable file.

325
00:22:08,440 --> 00:22:13,390
And when you hit enter, the operating system realizes that this is an executable file.

326
00:22:13,390 --> 00:22:19,870
So basically if I do ls hyphen a and then let's see.

327
00:22:19,870 --> 00:22:23,530
So you see this hello world is red and has an asterisk.

328
00:22:23,530 --> 00:22:31,930
This means this is an executable file, which means if you just type the name and hit enter, the operating

329
00:22:31,930 --> 00:22:37,120
system is able to execute it and give you the feedback which are the output of the application.

330
00:22:37,120 --> 00:22:37,540
Right.

331
00:22:37,900 --> 00:22:41,680
The other ones that end with the slash, these are directories, right.

332
00:22:43,210 --> 00:22:49,330
If I say hyphen basically ls hyphen l which means a long version of the listing.

333
00:22:49,330 --> 00:22:55,570
This helloworld comes out as x, so x means it's an executable file.

334
00:22:57,320 --> 00:22:57,920
All right.

335
00:22:57,920 --> 00:23:00,020
And we will look at these attributes later on.

336
00:23:00,020 --> 00:23:06,710
But for now, we're just looking at the Native Image Compiler application to the Java application to

337
00:23:06,710 --> 00:23:07,760
a native binary.

338
00:23:07,790 --> 00:23:09,980
Developing a Java application is much faster.

339
00:23:10,010 --> 00:23:13,640
Java has a much nicer API, much easier to do.

340
00:23:13,640 --> 00:23:19,550
And then when you combine that fact with the fact that we have very, very capable IDs, you see that

341
00:23:19,550 --> 00:23:21,860
a native image gives us a lot of benefit.

342
00:23:22,400 --> 00:23:24,140
So what is a compiled application?

343
00:23:24,140 --> 00:23:26,420
A file cabinet containing binaries?

344
00:23:27,260 --> 00:23:30,320
And these files have just the instructions for the CPU.

345
00:23:30,350 --> 00:23:34,130
These are directly tied to the architecture of the CPU you're using.

346
00:23:34,130 --> 00:23:41,840
For example, if you're using an AMD CPU 32 bit, 64 bit, if you're using a ARM CPU.

347
00:23:41,870 --> 00:23:42,560
These are different.

348
00:23:42,560 --> 00:23:48,740
So the binaries are not compatible because the CPU instruction sets are not compatible and instructions

349
00:23:48,740 --> 00:23:50,840
sent for the CPU is just a machine code.

350
00:23:50,840 --> 00:23:55,220
And usually machine code is just zeros and ones which we humans don't understand.

351
00:23:55,370 --> 00:24:02,000
So at one level, higher than machine code is assembly code, which is very simplified instruction sets.

352
00:24:02,030 --> 00:24:04,400
Humans are understand that, right?

353
00:24:04,520 --> 00:24:06,710
Assembly code is human readable.

354
00:24:07,610 --> 00:24:14,600
But then again, one level above assembly code are like C++ or C codes.

355
00:24:14,600 --> 00:24:14,840
Right.

356
00:24:14,840 --> 00:24:19,220
And the compiler compiles them to assembly and then an assembly application.

357
00:24:19,220 --> 00:24:19,730
Right.

358
00:24:20,630 --> 00:24:22,850
Compiles the assembly code into machine code.

359
00:24:23,030 --> 00:24:27,650
So binary files can be directly run if they have executable permission.

360
00:24:27,650 --> 00:24:33,620
And when you compile your job application with the native image, we see that when you do.

361
00:24:33,620 --> 00:24:36,290
LS Which lists all the files with the hyphen.

362
00:24:36,290 --> 00:24:40,610
L It tells you that this helloworld is executable.

363
00:24:40,640 --> 00:24:44,720
It has an asterisk and it has the executable permissions.

364
00:24:44,720 --> 00:24:46,660
And we will look at these permissions later.

365
00:24:46,670 --> 00:24:48,890
Usually you have three groups of permissions.

366
00:24:49,190 --> 00:24:54,680
The owner, which in this case is mean, is me, the group and then everybody else.

367
00:24:54,680 --> 00:25:02,960
So right now this application has the I have the I'm the owner of this file and I have the permission

368
00:25:02,960 --> 00:25:03,710
to execute it.

369
00:25:03,710 --> 00:25:09,770
So the three first letters means I can write to this file, read to this file, x means execute.

370
00:25:09,770 --> 00:25:16,150
So executable permissions mean I can just say hello world type the name and the terminal and operations

371
00:25:16,150 --> 00:25:20,870
and will execute it for me now I can change the permission to execute permission.

372
00:25:20,870 --> 00:25:30,020
So C mod means that change the mod or the demo that these files and I can say hyphen x and then helloworld

373
00:25:30,710 --> 00:25:37,310
so what this does if I do ls hyphen l as you can see now this helloworld is not doesn't have an asterisk

374
00:25:37,310 --> 00:25:41,420
anymore, which means this doesn't have the executable permission anymore.

375
00:25:41,450 --> 00:25:47,830
If you look at it, the third character was x, but now that X is gone for everybody, right?

376
00:25:47,870 --> 00:25:53,300
So if the owner removes the executable permission, everybody else also loses that.

377
00:25:53,450 --> 00:25:56,450
What this means is if I just type hello world.

378
00:25:58,310 --> 00:26:01,970
It says the file helloworld is not executable by this user.

379
00:26:01,970 --> 00:26:02,360
Right.

380
00:26:02,360 --> 00:26:10,580
I manually remove the permission for executing that, but I can bring it back by saying that c mod.

381
00:26:10,580 --> 00:26:18,170
So let's go back c mod instead of saying minus x, which means remove the x attribute plus x, add the

382
00:26:18,170 --> 00:26:19,490
executable attribute.

383
00:26:19,490 --> 00:26:20,030
All right.

384
00:26:20,330 --> 00:26:25,040
And now if I say ls hyphen l, now this binary has the permission.

385
00:26:25,040 --> 00:26:29,000
So you can have a binary that has the instructions for the CPU.

386
00:26:29,000 --> 00:26:34,130
But obviously the operating system is the guard between the applications and the hardware.

387
00:26:34,130 --> 00:26:40,100
Right operating system has to make sure that if somebody tries to execute a file, that file has the

388
00:26:40,100 --> 00:26:41,570
permissions, write permissions.

389
00:26:41,570 --> 00:26:44,900
Otherwise, it's an illegal operation right to the operating system.

390
00:26:44,900 --> 00:26:51,950
So there are checks and bounds so that the operating system ensures that it's not a malicious application.

391
00:26:52,280 --> 00:26:56,840
So if I say hello world now I can I I'm able to run this binary again.

392
00:26:56,840 --> 00:27:05,150
So file permissions, it's separate from whether the the file is basically a binary executable or not.

393
00:27:06,170 --> 00:27:14,060
The nature of this helloworld is an executable binary, but you can only execute these if you have the

394
00:27:14,660 --> 00:27:21,230
execute if the file has executable permissions right now, for example, this text file, it's a text

395
00:27:21,230 --> 00:27:21,770
file, right?

396
00:27:21,770 --> 00:27:23,540
It is not executable.

397
00:27:24,140 --> 00:27:31,700
If you look at this, you see it doesn't have an executable or X attribute just because it's not really

398
00:27:31,700 --> 00:27:32,420
executable.

399
00:27:32,420 --> 00:27:33,530
You cannot execute this.

400
00:27:33,530 --> 00:27:40,490
You can open it and read the characters from it, but it doesn't have instructions for the CPU.

401
00:27:40,880 --> 00:27:46,160
Whenever you have a executable, it has really zeros and ones that the CPU understands, but it takes

402
00:27:46,160 --> 00:27:51,020
file has zeros and ones that the operating system understands.

403
00:27:51,020 --> 00:27:51,230
Right.

404
00:27:51,230 --> 00:27:53,690
So the text file only character encoding.

405
00:27:53,690 --> 00:27:57,890
So if you look at it, these characters are UTF eight.

406
00:27:57,890 --> 00:28:01,940
Each character is encoded in 8 to 8 bits or one byte.

407
00:28:01,970 --> 00:28:06,440
This is not something that the CPU understands, but it's the operating system that understands it.

408
00:28:06,440 --> 00:28:12,020
So when you double click on this and open it, operating system realizes that there are zeros and ones

409
00:28:12,080 --> 00:28:18,980
and because it's a text file, then it knows how to correctly translate those zeros and ones to a format

410
00:28:18,980 --> 00:28:20,210
that the humans understand.

411
00:28:20,210 --> 00:28:20,660
Right?

412
00:28:21,080 --> 00:28:26,690
So there is a difference between binaries which have instructions for the CPU and the.

413
00:28:26,760 --> 00:28:29,640
For example, it takes they don't have instructions for a CPU.

414
00:28:29,670 --> 00:28:32,100
Those are just character encoding.

415
00:28:32,100 --> 00:28:37,950
The zeros and ones in a text file are something that the operating system understands, not the CPU.

416
00:28:39,390 --> 00:28:44,100
So binary files can be run if they have executable permissions on MAC OS or Linux.

417
00:28:44,100 --> 00:28:46,500
You write smart, which means change.

418
00:28:46,500 --> 00:28:53,910
The mode of operation of this file plus x means add the executable attribute minus x means remove the

419
00:28:53,910 --> 00:28:58,020
executable attribute on macros and Linux executable files.

420
00:28:58,020 --> 00:29:02,790
Don't have any extension right now when we compile our application here.

421
00:29:02,820 --> 00:29:03,540
Helloworld.

422
00:29:03,540 --> 00:29:05,220
It doesn't have any extension.

423
00:29:05,220 --> 00:29:06,330
It's just executable.

424
00:29:06,330 --> 00:29:10,350
Write extensions are extra information for the operating system.

425
00:29:10,440 --> 00:29:15,270
If a file is executable binary, there is no instruction for the operating system.

426
00:29:15,390 --> 00:29:21,090
You just tell the operating system, hey, this is executable and execute it, which means this file

427
00:29:21,090 --> 00:29:23,940
only has instructions for the CPU.

428
00:29:23,940 --> 00:29:29,670
Write a text file, has instructions or extra information for the operating system so that it knows

429
00:29:29,670 --> 00:29:32,370
that how to display the contents correctly.

430
00:29:32,670 --> 00:29:37,800
But the executable file it doesn't have, you cannot display it as characters, for example, because

431
00:29:38,220 --> 00:29:40,920
it's just zeros and ones that the CPU understands.

432
00:29:42,120 --> 00:29:42,910
On Windows.

433
00:29:42,930 --> 00:29:47,130
Executable files have dot x dot xy permission.

434
00:29:47,130 --> 00:29:47,400
Right.

435
00:29:47,400 --> 00:29:52,680
So Windows is always a little bit different from Mac OS X and Linux platform tool change.

436
00:29:52,680 --> 00:29:59,910
As you saw in my quick example of the native image, you have to use a compiler to compile some application

437
00:29:59,910 --> 00:30:06,060
to or basically some source file into a executable binaries that CPU understands.

438
00:30:06,330 --> 00:30:08,040
C++ is very easy.

439
00:30:08,040 --> 00:30:13,560
They always have a strong compilers that understand the C++ source code for Java.

440
00:30:13,560 --> 00:30:15,240
We had a two step process.

441
00:30:15,240 --> 00:30:21,720
One, use the Java compiler to compile the Java source code to Java binaries to the JVM.

442
00:30:21,720 --> 00:30:22,380
Understand.

443
00:30:22,380 --> 00:30:27,960
And then on top of that, after that, we use the native image compiler that understands the class files

444
00:30:27,960 --> 00:30:31,290
and produces a native executable binary.

445
00:30:32,370 --> 00:30:38,910
So eventually you have to need some sort of compiler and feed your files, source files or in this case

446
00:30:38,910 --> 00:30:41,160
class files from Java to that compiler.

447
00:30:41,160 --> 00:30:45,540
And then it understands how to translate it to the instructions that the CPU understands.

448
00:30:45,780 --> 00:30:51,780
And obviously compilers are optimized or they optimize your source file source code, which means they

449
00:30:51,780 --> 00:30:58,890
can provide some levels of static analysis and static basically optimization compilers that compile

450
00:30:58,890 --> 00:31:03,840
source code to binary for CPU every platform, which means every operating system.

451
00:31:03,840 --> 00:31:10,740
In this case, they come with their own compilers because every operating system has a different API

452
00:31:10,770 --> 00:31:13,590
that allows the user to talk to the hardware.

453
00:31:13,590 --> 00:31:20,610
I mean, hardware could be the same but operate different operating system, use different APIs, the

454
00:31:20,610 --> 00:31:23,850
functions they use, the conventions they use, they're different.

455
00:31:23,850 --> 00:31:29,490
That's why when you compile to binary for different operating systems, you have to compile on those

456
00:31:29,490 --> 00:31:30,730
operating systems, right?

457
00:31:30,780 --> 00:31:34,350
Or use the compilers that are specific to that operating system.

458
00:31:34,710 --> 00:31:40,320
Mac OS developed by Apple, they provide their own compilers, which is Xcode.

459
00:31:40,320 --> 00:31:40,550
Right?

460
00:31:40,560 --> 00:31:46,680
Xcode is the tool you can basically it's a general application, provides a nice interface.

461
00:31:46,680 --> 00:31:52,230
You can type your code and compile it, but if you want to judge just the compiler, you can use command

462
00:31:52,230 --> 00:31:59,250
line tools, you can type, you can so you can just install the Xcode application from the App Store

463
00:31:59,250 --> 00:32:06,360
and then it automatically also installs all the toolchain, all the compilers and the dependencies that

464
00:32:06,360 --> 00:32:07,170
those have.

465
00:32:08,130 --> 00:32:15,390
But so Xcode on Mac OS, that's the easiest way to get all the platform tool change that you need.

466
00:32:15,390 --> 00:32:20,880
And when you do that, let's open up a terminal here on Mac OS.

467
00:32:20,880 --> 00:32:28,290
If you when you install the Xcode, it creates some aliases on the terminal for the compiler.

468
00:32:28,290 --> 00:32:35,280
So if I type C++ hyphen version, it's pointing to the apple clang.

469
00:32:35,280 --> 00:32:38,130
So it's a clang, but it has an alias to C++.

470
00:32:38,130 --> 00:32:43,920
If I say clang, hyphen, hyphen version, it's pointing to the clang.

471
00:32:43,920 --> 00:32:48,690
Again, if I say C++ hyphen version, it's pointing to the same thing, right?

472
00:32:48,690 --> 00:32:54,090
All these aliases are created so that you can use that, right?

473
00:32:54,090 --> 00:33:02,280
So even GKE hyphen version, if you want to compile a C instead of C++, it's going to basically I mean,

474
00:33:02,280 --> 00:33:07,110
these days we just use the again, it's also pointing to the apple clang.

475
00:33:07,110 --> 00:33:15,630
So when you the easiest way on MapQuest is just install the Xcode and then the toolchain is apple clang.

476
00:33:15,630 --> 00:33:22,050
So it's based on clang, it's not based on, for example, the GCC or know and this is a proprietary

477
00:33:22,200 --> 00:33:22,830
compiler.

478
00:33:22,830 --> 00:33:24,810
So you cannot it's not open source.

479
00:33:24,810 --> 00:33:28,170
You cannot download it for free unless you are using a mac OS.

480
00:33:30,230 --> 00:33:33,080
Uh, there are uh, for example, Linux obviously open source.

481
00:33:33,080 --> 00:33:37,010
So there are open source compilers, GKE, compiler collection.

482
00:33:37,010 --> 00:33:40,580
You can even download and install GKE on Windows, for example.

483
00:33:40,580 --> 00:33:41,930
They also provide that.

484
00:33:42,110 --> 00:33:45,030
And on Linux you also have the option for Clang.

485
00:33:45,050 --> 00:33:46,250
Same for Windows.

486
00:33:46,250 --> 00:33:51,470
You also have the option for clang and these are open source free to use on windows.

487
00:33:52,040 --> 00:33:57,380
If windows when you install it, usually when you install Linux, it always comes by default with the

488
00:33:57,400 --> 00:34:04,160
GCC macros you you need to install Xcode, but it's a very easy installation.

489
00:34:04,160 --> 00:34:05,630
You don't really need to do anything.

490
00:34:05,630 --> 00:34:08,480
Windows by default doesn't come with any toolchain.

491
00:34:08,810 --> 00:34:09,770
The options.

492
00:34:09,860 --> 00:34:16,400
One of them obviously is provided by the Microsoft itself, which is SVC Microsoft Visual C compiler.

493
00:34:17,150 --> 00:34:21,350
And in this lecture I'm going to show you how to install this.

494
00:34:21,350 --> 00:34:27,230
This is the recommended way for working with the native image in Windows, but there are also other

495
00:34:27,230 --> 00:34:28,700
options like GCC clang.

496
00:34:28,700 --> 00:34:29,630
These are open source.

497
00:34:29,640 --> 00:34:32,810
MSC is not open source, so it's also proprietary.

498
00:34:32,810 --> 00:34:34,640
And why use native image?

499
00:34:34,640 --> 00:34:40,790
Because a compiled binary which is pretty much ready to execute for the Java application, it has a

500
00:34:40,790 --> 00:34:42,530
very fast startup time.

501
00:34:42,530 --> 00:34:47,060
All the JDK classes have already been compiled and there is nothing.

502
00:34:47,240 --> 00:34:53,420
We don't launch a JVM and really it's just the operating system that loads your application and instructs

503
00:34:53,420 --> 00:34:53,900
the hardware.

504
00:34:53,900 --> 00:34:54,530
That's it.

505
00:34:54,560 --> 00:34:57,590
There is no middle step, which in general is the JVM.

506
00:34:57,590 --> 00:34:57,800
Right?

507
00:34:57,830 --> 00:34:59,900
JVM has been removed from the equation.

508
00:34:59,900 --> 00:35:05,420
So the, the, the execution time of your application is very fast.

509
00:35:05,510 --> 00:35:07,040
So I hope you enjoyed this lecture.

510
00:35:07,040 --> 00:35:09,320
Please stay tuned and I'll see the next one.
