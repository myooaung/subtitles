WEBVTT
1
00:00:00.840 --> 00:00:03.600
Hello and welcome to another tutorial.

2
00:00:03.600 --> 00:00:08.040
We're going to continue our discussion with how to handle Java resources.

3
00:00:08.400 --> 00:00:17.400
In our example, it was reading data from some text file and how to deal with them or embed those resources

4
00:00:17.400 --> 00:00:24.810
directly in the native image in the final binary executable file that the Native Image compiler creates.

5
00:00:24.810 --> 00:00:25.200
Right?

6
00:00:25.650 --> 00:00:31.140
And we saw that we can read the text, a text file or any data, any stream of bytes.

7
00:00:31.140 --> 00:00:35.430
We can read them and bring them into our Java application using this connect class.

8
00:00:35.430 --> 00:00:42.060
So whenever you want to deal with text retakes, understand them or go through them word by word, line

9
00:00:42.060 --> 00:00:42.660
by line.

10
00:00:42.690 --> 00:00:45.720
Your first thought should go to the scanner class.

11
00:00:45.720 --> 00:00:46.770
It's very powerful.

12
00:00:46.770 --> 00:00:57.120
It has a very versatile set of constructors and you can even define how the scanner can interpret those

13
00:00:57.120 --> 00:01:00.420
a stream of bytes using the character set or car set.

14
00:01:00.690 --> 00:01:06.990
And I showed you there are many different ways to catch this that Java supports.

15
00:01:08.760 --> 00:01:15.000
Basically, UTF eight is basically usually is the default platform encoding.

16
00:01:15.000 --> 00:01:17.280
UTF 16 is usually what Java supports.

17
00:01:17.280 --> 00:01:17.760
Right.

18
00:01:18.270 --> 00:01:24.570
And we saw that if you want to read the text file, you have to pass it as a file object because file

19
00:01:24.570 --> 00:01:26.040
object is an abstraction.

20
00:01:26.040 --> 00:01:35.940
You cannot pass directly the the path to that file as a string because the constructor of this candidate

21
00:01:35.940 --> 00:01:41.430
takes a string, actually tokenize the string itself instead of assuming that it's a path to a file.

22
00:01:41.430 --> 00:01:41.850
Right?

23
00:01:42.810 --> 00:01:46.620
So we can use this class to read the text file.

24
00:01:46.620 --> 00:01:51.060
The path relative or absolute should be passed to a scanner as a file.

25
00:01:51.060 --> 00:01:58.590
And again, this file object handles basically the underlying operating systems file system, and it

26
00:01:58.590 --> 00:02:01.350
can work with both absolute and relative path.

27
00:02:01.350 --> 00:02:03.150
So both of them are supported.

28
00:02:03.150 --> 00:02:09.900
And whenever you pass a relative or absolute, you can also the file object has methods for retrieving,

29
00:02:09.900 --> 00:02:16.620
for example, where this basically file is an absolute path or relative path.

30
00:02:16.620 --> 00:02:19.470
There are other things like canonical path, etc..

31
00:02:19.470 --> 00:02:19.740
Right.

32
00:02:19.740 --> 00:02:22.140
And we will look at the methods inside the file object.

33
00:02:22.410 --> 00:02:27.030
We want to have a platform independent representation of the resources.

34
00:02:27.030 --> 00:02:31.590
And this was one of the examples that we discussed in the previous lecture.

35
00:02:31.590 --> 00:02:37.260
So if you use a file object and give it a relatively absolute path to where the resource is and then

36
00:02:37.260 --> 00:02:43.950
pass it to a scanner, obviously that is that resource is directly tied to the underlying directories

37
00:02:43.950 --> 00:02:44.790
at the operating system.

38
00:02:44.790 --> 00:02:50.370
So if I give my job application to somebody else, they might have that resource file.

39
00:02:50.370 --> 00:02:55.650
Also, I can package or bundle that resource file, let's say a text file into my jar file.

40
00:02:55.680 --> 00:03:02.700
But in the problem is that they might not have the same file structure, the directories.

41
00:03:02.700 --> 00:03:10.350
So really it's not a good idea to have a file that is or basically a resource that our job application

42
00:03:10.350 --> 00:03:14.730
uses that is directly tied to the underlying file structure of the operating system.

43
00:03:14.730 --> 00:03:18.990
We know that Java is all about platform independence, so how do we do this?

44
00:03:19.020 --> 00:03:21.600
JVM has a platform, independent behavior.

45
00:03:21.600 --> 00:03:22.880
That's that's the whole meaning, right?

46
00:03:22.890 --> 00:03:27.960
If I write a job application, if I bundle all the resources we need, I want to give it to somebody

47
00:03:27.960 --> 00:03:28.470
else.

48
00:03:28.470 --> 00:03:33.480
And because they already have their JVM, even if their operating system is different, even if their

49
00:03:33.510 --> 00:03:40.080
CPU is different, as long as there is a JVM is available for their platform, I want them to just get

50
00:03:40.080 --> 00:03:43.440
my class files or whatever application is.

51
00:03:43.440 --> 00:03:48.450
Let's say I package it as a jar file, give it to them, and I just want them to run it successfully.

52
00:03:48.450 --> 00:03:48.900
Right.

53
00:03:49.170 --> 00:03:51.450
So portable code, that's the whole meaning, right?

54
00:03:51.450 --> 00:03:51.960
Right.

55
00:03:52.740 --> 00:03:54.420
Once run anywhere.

56
00:03:55.080 --> 00:03:58.200
And unfortunately again, they're loading resources.

57
00:03:58.470 --> 00:04:04.560
If you just use the file class, it's going to be tied to the operating system, the directory, etc.

58
00:04:04.980 --> 00:04:07.680
Accessing textual should be also platform independent.

59
00:04:07.680 --> 00:04:12.780
Is there a way to load a resource at runtime in a in a platform independent way?

60
00:04:12.780 --> 00:04:13.890
And the answer is yes.

61
00:04:14.040 --> 00:04:23.130
So if we hardcoded the path to a file in the source file in our Java application, then we can't really

62
00:04:23.130 --> 00:04:24.510
have a portable application.

63
00:04:24.510 --> 00:04:24.690
Right.

64
00:04:24.690 --> 00:04:28.020
The code is not platform independent and probably not portable.

65
00:04:28.050 --> 00:04:28.590
Why?

66
00:04:28.590 --> 00:04:33.930
Because again, we're using relative or absolute path.

67
00:04:34.440 --> 00:04:42.060
First of all, it depends which directory is your working directory where you run your job Java application

68
00:04:42.060 --> 00:04:44.610
from, especially if you use the relative path.

69
00:04:44.820 --> 00:04:48.900
It also depends which working directory the Java application is run from.

70
00:04:48.900 --> 00:04:49.440
Right.

71
00:04:49.440 --> 00:04:52.950
So especially when using relative path in the source code.

72
00:04:52.950 --> 00:04:59.310
So if you define a file and then give it a relative path, that means whatever the way Java interprets

73
00:04:59.310 --> 00:04:59.700
that is when.

74
00:04:59.900 --> 00:05:00.880
This is a relative path.

75
00:05:00.910 --> 00:05:03.820
It assumes that it's with the working directory.

76
00:05:03.820 --> 00:05:04.390
Right.

77
00:05:04.390 --> 00:05:09.490
And working directly for Jim is where you launch your JV team, which directly you launch your JV and

78
00:05:09.490 --> 00:05:11.290
we set that inside terminal.

79
00:05:12.400 --> 00:05:16.600
The idea here is that inside a terminal you are always in a working directory, right?

80
00:05:16.760 --> 00:05:17.890
CD desktop.

81
00:05:21.010 --> 00:05:22.540
And then I can write Java.

82
00:05:22.540 --> 00:05:26.950
And then let's say my application is in a format of a jar file and give it a jar.

83
00:05:26.950 --> 00:05:33.190
And whenever I type Java it means I'm launching a GVM and the JVM understands that this current directory

84
00:05:33.190 --> 00:05:36.450
that I'm launching the JVM from is my working directory.

85
00:05:36.460 --> 00:05:41.860
So if, if in my source file a source code, I have something like dot something, right?

86
00:05:41.860 --> 00:05:48.310
And then some, some text file, some files text, then the JVM interprets it.

87
00:05:48.310 --> 00:05:51.810
This dot means the current working directly in this example is this stuff.

88
00:05:51.820 --> 00:05:53.350
So this is really limiting, right?

89
00:05:53.350 --> 00:06:00.040
This is not a portable code because somebody else might want their job application from some other directory.

90
00:06:00.040 --> 00:06:02.800
They might not have this directory under operating system.

91
00:06:02.800 --> 00:06:04.510
So it won't work.

92
00:06:04.510 --> 00:06:04.750
Right.

93
00:06:04.750 --> 00:06:06.760
So it's not really a portable code.

94
00:06:08.230 --> 00:06:09.760
So what is the solution?

95
00:06:10.000 --> 00:06:12.920
For platform independent resource access.

96
00:06:12.940 --> 00:06:18.520
Let's say I want to access a text file and load it in a way that it really is not dependent on the operating

97
00:06:18.520 --> 00:06:19.100
system.

98
00:06:19.210 --> 00:06:24.370
You probably can guess that in that case, we're not really going to use a file class because again,

99
00:06:24.370 --> 00:06:30.130
file class represents the underlying directory hierarchy, whatever is on the computer that we're actually

100
00:06:30.130 --> 00:06:31.390
writing the source code.

101
00:06:31.570 --> 00:06:36.580
There is no unique solution, but there is a good solution, or at least my recommendation.

102
00:06:36.700 --> 00:06:39.040
So it's best to rely on JVM.

103
00:06:39.040 --> 00:06:43.120
And JVM provides a way at runtime to load classes.

104
00:06:43.120 --> 00:06:44.500
So JVM has a mechanism, right?

105
00:06:44.500 --> 00:06:52.330
Because we know that JVM is a lazy loading machinery, which means whenever you use a type in your source

106
00:06:52.330 --> 00:06:59.560
code, like let's say you have a type called car, as long as you never use it, JVM won't search for

107
00:06:59.560 --> 00:07:02.290
a class file called Core and never load it.

108
00:07:02.290 --> 00:07:13.930
But the first time you use a type JVM searches for basically a file called whatever the type is a dot

109
00:07:13.930 --> 00:07:15.610
class, and then loads it into memory.

110
00:07:15.640 --> 00:07:16.960
How does JVM do that?

111
00:07:16.990 --> 00:07:19.270
It uses a concept called class loader.

112
00:07:19.270 --> 00:07:27.520
So class loader in a class that comes with the JDK, and I've said it many times that JVM searches for

113
00:07:27.520 --> 00:07:34.900
classifiers in a particular directory which are called which are known at runtime in the class path.

114
00:07:34.900 --> 00:07:35.350
Right?

115
00:07:35.350 --> 00:07:42.730
So class path is more or less abstracts away where the JVM has to look into when it tries to find a

116
00:07:42.730 --> 00:07:43.530
resources.

117
00:07:43.540 --> 00:07:47.470
So class loader also works with class path, right?

118
00:07:47.590 --> 00:07:53.410
So class rose loader is the tool in the JDK that can locate the class file at runtime.

119
00:07:55.390 --> 00:08:03.400
And what we do, basically, we say a class loader, there is a static method called get system resource.

120
00:08:03.400 --> 00:08:11.470
And a get system resource means whenever you type deal with system, it means a search for a resource

121
00:08:11.470 --> 00:08:16.390
that the system or the JVM understands, which means look into the directories that are on the class

122
00:08:16.390 --> 00:08:16.870
path.

123
00:08:16.990 --> 00:08:23.320
So class loader is like an abstract way of how to search and locate resources at runtime, because at

124
00:08:23.320 --> 00:08:26.620
runtime you have to always specify some sort of class path.

125
00:08:26.620 --> 00:08:31.810
Even if you bundle your Java application as a jar file, there is a manifest file inside of it that

126
00:08:31.870 --> 00:08:34.300
specifies how this jar should be interpreted.

127
00:08:34.300 --> 00:08:34.540
Right?

128
00:08:34.540 --> 00:08:36.070
What's the directory hierarchy?

129
00:08:36.070 --> 00:08:39.490
What's the top level directory that will be added to the class path?

130
00:08:39.910 --> 00:08:47.140
So and then this returns a particular object here I'm using var for simplicity, but in eclipse we look

131
00:08:47.140 --> 00:08:54.010
at what exactly is the type of this resource that gets system resource which is a static method returns

132
00:08:54.010 --> 00:08:59.740
and it has a method called get path that gives you actually the exact path, the full absolute path

133
00:08:59.740 --> 00:09:00.580
of that resource.

134
00:09:00.580 --> 00:09:01.030
Right.

135
00:09:02.080 --> 00:09:11.350
So what we're doing here, obviously we are translating the file that we use to a resource that is available

136
00:09:11.350 --> 00:09:16.300
on the class path at runtime, and then the class loader can figure it out.

137
00:09:16.300 --> 00:09:19.380
And then after that we can get the absolute path right.

138
00:09:19.390 --> 00:09:25.810
And again, this concept of get system resource from class loader is a is a platform independent code.

139
00:09:25.990 --> 00:09:28.000
It works on any platform, right?

140
00:09:28.000 --> 00:09:33.940
So on any platform, when the class loader searches for that resource and this get path could be different

141
00:09:33.970 --> 00:09:36.070
depending on where that resource is.

142
00:09:36.340 --> 00:09:36.610
All right.

143
00:09:36.610 --> 00:09:40.870
Let's head to Eclipse and try to have a hands on experience with this.

144
00:09:41.140 --> 00:09:49.090
We had this code called the class called resource demo, and we saw that if we want to, we have a text

145
00:09:49.090 --> 00:09:51.270
file called Run Me that is Edge.

146
00:09:52.150 --> 00:09:55.240
It just has some simple characters in it and we try to read it.

147
00:09:55.240 --> 00:10:00.250
We said that we have to give the scanner a file and here I'm using the relative path.

148
00:10:00.250 --> 00:10:03.370
And the question, the first question was, what is this relative path?

149
00:10:03.520 --> 00:10:05.380
And it depends on runtime, right?

150
00:10:05.380 --> 00:10:07.210
Wherever you launch your JVM from.

151
00:10:07.210 --> 00:10:15.250
And we know that in Eclipse ID, whenever you run your Java application, the way Eclipse handles this,

152
00:10:15.250 --> 00:10:23.530
it creates a run configuration and it sets the working directory to the top, the project folder workspace,

153
00:10:23.530 --> 00:10:25.390
a project folder, right?

154
00:10:25.690 --> 00:10:27.670
That's how Eclipse ID handles it.

155
00:10:27.670 --> 00:10:30.370
So some other ID might handle it differently.

156
00:10:30.370 --> 00:10:35.650
That's why if you if I give you this code or even the class file and you run it in different IDs, you

157
00:10:35.650 --> 00:10:37.150
might it might not work.

158
00:10:37.150 --> 00:10:37.600
Right.

159
00:10:37.600 --> 00:10:37.930
Right.

160
00:10:37.930 --> 00:10:45.670
Now, this this relative path is really, really the ties is tying us to the the way the eclipse ID

161
00:10:45.700 --> 00:10:46.420
handles it.

162
00:10:47.680 --> 00:10:49.120
And we saw that.

163
00:10:50.110 --> 00:10:56.290
So basically this dot at the moment inside the eclipse ID means this project directory right the top

164
00:10:56.290 --> 00:11:02.290
level and my text file remind me that S-H is just inside this directory.

165
00:11:02.290 --> 00:11:02.770
Right.

166
00:11:03.820 --> 00:11:07.450
And then and then this works.

167
00:11:07.450 --> 00:11:09.820
And then we said that, okay, this is not good.

168
00:11:09.820 --> 00:11:17.680
And even when we compile this to native executable file, we saw that this relative path is really interpreted

169
00:11:17.680 --> 00:11:24.520
the same way, which means the native executable file also interprets this dot as the current working

170
00:11:24.520 --> 00:11:28.660
directory wherever we're running our native executable file from.

171
00:11:28.810 --> 00:11:29.920
And this doesn't work.

172
00:11:29.920 --> 00:11:36.970
But if I go up one level in the project root and now I go inside the native directory and run it, it

173
00:11:36.970 --> 00:11:44.560
can find it because this dot is still interpreted as this working directory and our native executable

174
00:11:44.560 --> 00:11:47.400
file searches from this current directory.

175
00:11:47.400 --> 00:11:50.650
It tries to search for the file called Run Search and it can find it.

176
00:11:50.650 --> 00:11:51.040
Right.

177
00:11:51.280 --> 00:11:53.290
So again, this is not the best idea.

178
00:11:54.220 --> 00:11:56.080
And the other thing is that

179
00:11:59.170 --> 00:12:07.720
if this file ideally what I want is that this native, I want to kind of embed the contents of this,

180
00:12:07.750 --> 00:12:18.340
this text file inside my native executable file so that I don't need to have to rely on this file,

181
00:12:18.340 --> 00:12:19.090
external file.

182
00:12:19.090 --> 00:12:19.210
Right.

183
00:12:19.270 --> 00:12:24.010
That's something that that's what we're trying to move towards it.

184
00:12:24.010 --> 00:12:24.430
Right.

185
00:12:25.060 --> 00:12:29.200
So the first step, we want to get rid of this platform dependent file.

186
00:12:30.100 --> 00:12:34.900
And what we're going to do here is to we're going to change our code a little bit.

187
00:12:36.340 --> 00:12:40.510
So instead of doing this, what I'm going to do, first of all, let's comment all this out.

188
00:12:41.230 --> 00:12:47.320
How else are we going to get access to this file, get access to this resource?

189
00:12:47.320 --> 00:12:51.100
So I mentioned we want to rely on the class loader, right?

190
00:12:51.100 --> 00:12:56.680
So so class loader, it's in the Java lang, it's automatically imported.

191
00:12:56.680 --> 00:13:03.460
And then if you look at the static methods, get platform class loader, this returns the class loader

192
00:13:03.460 --> 00:13:09.490
gets sys class loader class loader and a different series that sys class loader loads all the class

193
00:13:09.490 --> 00:13:17.140
files third party classifiers on the class path platform class loader loads only the JDK classes, the

194
00:13:17.140 --> 00:13:19.000
classes that come with the JVM.

195
00:13:19.090 --> 00:13:25.150
And if you are familiar with these a little bit in more details, you know that there are security levels

196
00:13:25.150 --> 00:13:32.380
that these class loaders have or basically security clearances on what classes they can access and load.

197
00:13:32.410 --> 00:13:36.490
So sys class loader means anything that is not part of the JDK, right?

198
00:13:36.490 --> 00:13:40.960
All the resources classes that are third party get system resource.

199
00:13:40.960 --> 00:13:42.430
Again, these are the resources.

200
00:13:42.430 --> 00:13:48.910
These are files that are not class files that are third party file, they're not part of JDK git system

201
00:13:48.910 --> 00:13:56.980
resource as a stream and get system resource, you give it a name here you get system resources.

202
00:13:56.980 --> 00:14:00.190
So here you give it the.

203
00:14:00.750 --> 00:14:06.270
Basically if there are multiple files that have the same name, these can return all of them.

204
00:14:06.270 --> 00:14:06.680
Right.

205
00:14:06.690 --> 00:14:13.080
So let's we're going what we're going to do, we're going to say get system resource and what is the

206
00:14:13.080 --> 00:14:14.400
name of our resource.

207
00:14:15.330 --> 00:14:16.960
Run me search.

208
00:14:16.980 --> 00:14:21.930
Remember now we are not providing any path, any relative or absolute path.

209
00:14:21.930 --> 00:14:28.230
You just provide the name and how those the class loader works this system class loader again it works

210
00:14:28.230 --> 00:14:30.060
with the concept of the class path.

211
00:14:33.870 --> 00:14:40.510
When my class pass abstracts away all the directories or where the resources are, where the class files

212
00:14:40.510 --> 00:14:41.690
are, where the resources are.

213
00:14:41.730 --> 00:14:42.210
Right.

214
00:14:42.250 --> 00:14:54.760
So this returns something called a u r l, so we can just use a dot var template to create a resource.

215
00:14:54.790 --> 00:15:01.300
Now I prefer normally I prefer to just use var here, but the type here is u r l in java we have in

216
00:15:01.300 --> 00:15:02.950
JDC we have two types.

217
00:15:02.950 --> 00:15:06.250
You are l and you are I.

218
00:15:06.790 --> 00:15:10.990
Normally you are l is more your r is more like network stuff.

219
00:15:10.990 --> 00:15:15.960
The protocols that we use you are l universal are universal resource locator.

220
00:15:15.970 --> 00:15:20.020
This is an independent way or platform independent way.

221
00:15:21.080 --> 00:15:27.370
So the class URL represents a uniform resource locator, a pointer to a resource on the World Wide Web.

222
00:15:27.380 --> 00:15:30.200
These are also the concepts that came from networking.

223
00:15:30.350 --> 00:15:35.270
A resource can be something as simple as a file or a directory, or it can be a reference to a more

224
00:15:35.270 --> 00:15:40.160
complicated object, such as a query to a database or to a search engine.

225
00:15:40.160 --> 00:15:41.030
More information.

226
00:15:41.030 --> 00:15:43.070
You can find it here, right?

227
00:15:46.710 --> 00:15:49.600
So there is also you are this also you are I.

228
00:15:49.620 --> 00:15:50.790
So java net.

229
00:15:50.790 --> 00:15:52.890
You are you are I.

230
00:15:54.200 --> 00:15:57.240
Represents a uniform resource identifier.

231
00:15:57.260 --> 00:16:03.230
Aside from some minor deviations noted below, an instance of this class represents a URI reference

232
00:16:03.230 --> 00:16:05.180
as defined by these standards.

233
00:16:05.180 --> 00:16:05.720
Right.

234
00:16:07.340 --> 00:16:11.300
And again, these are more like network protocols, how the binaries get translated.

235
00:16:11.300 --> 00:16:18.170
But here the system resource returns a URL which is again a more like platform independent way because

236
00:16:18.170 --> 00:16:24.110
everybody every platform, every operating system uses follows the same protocols when it comes to World

237
00:16:24.170 --> 00:16:25.460
Wide Web or networking.

238
00:16:25.460 --> 00:16:25.830
Right.

239
00:16:25.850 --> 00:16:31.610
Networking are standards that are independent of the operating system platforms.

240
00:16:31.640 --> 00:16:33.620
I believe that's why Java adopted this.

241
00:16:34.550 --> 00:16:37.490
So what can we do with this URL?

242
00:16:37.520 --> 00:16:40.610
So let's look at the methods it has equals.

243
00:16:40.610 --> 00:16:43.460
Get authority, get class, get contents.

244
00:16:43.490 --> 00:16:48.020
Let me zoom out to look at the help get content.

245
00:16:48.020 --> 00:16:55.130
It returns an object of type URL gets the contents of this URL get default port.

246
00:16:55.160 --> 00:16:59.990
Obviously we're not using a basically networking, right?

247
00:16:59.990 --> 00:17:04.400
This system resource doesn't come from the network, it comes from the class path.

248
00:17:04.430 --> 00:17:06.770
Get file, get host get path.

249
00:17:06.920 --> 00:17:10.490
So get file, returns the string, get the file name of this URL.

250
00:17:10.490 --> 00:17:17.660
So let's start with that see out resource dot get file and this returns a string.

251
00:17:17.660 --> 00:17:19.400
So let's see what we get here.

252
00:17:23.030 --> 00:17:26.420
Cannot invoke you file because resource is not.

253
00:17:26.450 --> 00:17:27.590
Why is it that so?

254
00:17:27.590 --> 00:17:34.310
Obviously what happens here is that when this class loader searches the class path for a file or a resource

255
00:17:34.310 --> 00:17:35.900
called Run M.A.S.H.

256
00:17:35.930 --> 00:17:37.700
If it doesn't work, it returns null.

257
00:17:37.700 --> 00:17:46.910
So you should you should always do an all to a null check to see if the resource was found or not.

258
00:17:46.910 --> 00:17:54.620
So if a resource is not equal to null, we're going to say that.

259
00:17:54.860 --> 00:17:56.270
Get the file right.

260
00:17:57.050 --> 00:18:02.390
Else we're going to see out that resource not found.

261
00:18:06.370 --> 00:18:07.840
All right, let's run this.

262
00:18:08.410 --> 00:18:14.110
And this tells us that resource not found, which means the class loader wasn't able to find this resource.

263
00:18:14.110 --> 00:18:14.590
Why?

264
00:18:14.590 --> 00:18:15.470
It's already dead.

265
00:18:15.490 --> 00:18:22.990
That's because now we are moving to a concept towards a platform, independent way of locating resources.

266
00:18:22.990 --> 00:18:25.900
But again, JVM still needs to know where to look at.

267
00:18:25.900 --> 00:18:28.450
And JVM only understands class path.

268
00:18:28.450 --> 00:18:35.710
And you know, the way that Eclipse ID organizes the class path is that at the moment, the source project,

269
00:18:35.710 --> 00:18:38.950
the directory of the project is not on the class path.

270
00:18:39.040 --> 00:18:43.000
Only stuff that are in the Z folder are on the class path.

271
00:18:43.150 --> 00:18:50.530
So what I can do first is to move this run meta search inside the CRC directory.

272
00:18:50.770 --> 00:18:51.310
Right.

273
00:18:51.310 --> 00:18:56.920
And now it keeps actually if you look at the hierarchy anything that is inside CRC Eclipse copies them

274
00:18:56.920 --> 00:19:00.430
also to go to the bin directory.

275
00:19:00.430 --> 00:19:06.250
So if I look at my Z directory, you see that the run me search is now.

276
00:19:06.430 --> 00:19:13.510
So actually if I look at my being directory here, you see now run me that search was copied.

277
00:19:13.510 --> 00:19:18.280
If I move it back, you see Eclipse removes it also from the bin directory.

278
00:19:18.280 --> 00:19:22.720
So I'm going to move this to CRC directory, which is a source directory.

279
00:19:24.270 --> 00:19:31.260
And now if I run, this is going to work fine, because now this run method is at runtime, it's available

280
00:19:31.260 --> 00:19:36.060
on the class pass, which means it's one or it's inside one of the directories that is on the class

281
00:19:36.060 --> 00:19:36.330
path.

282
00:19:36.330 --> 00:19:36.780
Right.

283
00:19:38.690 --> 00:19:39.590
And now it works.

284
00:19:39.590 --> 00:19:45.980
And you see, now, if I give this application to somebody else who is using another operating system

285
00:19:45.980 --> 00:19:48.360
and other computer, this will still work.

286
00:19:48.380 --> 00:19:55.310
This code is fully platform independent and it has a platform independent way of locating this resource.

287
00:19:55.340 --> 00:19:55.970
Why?

288
00:19:56.030 --> 00:20:03.150
Because when they go and run the Java Java application, they have to specify the class path.

289
00:20:03.170 --> 00:20:04.820
That's something that mandatory.

290
00:20:04.820 --> 00:20:09.470
Whenever you want to launch a JVM to run a job application, you have to provide a class path.

291
00:20:09.500 --> 00:20:17.210
JVM needs to know where to load all the class was all the resources from, but then after that everything

292
00:20:17.210 --> 00:20:18.170
else is in.

293
00:20:18.170 --> 00:20:24.800
This code is platform independent because this class loader, based on where you run your job application,

294
00:20:24.800 --> 00:20:29.000
just searches into the class path and then finds this resource.

295
00:20:29.000 --> 00:20:35.510
And interestingly enough, when you get the file or get the path, it tells you exactly gives you a

296
00:20:35.510 --> 00:20:39.140
platform dependent representation of the file.

297
00:20:39.140 --> 00:20:45.290
So on Windows you probably get C column backslash, something on Mac OS, you start from the root,

298
00:20:45.290 --> 00:20:45.740
etc..

299
00:20:45.740 --> 00:20:46.190
Right.

300
00:20:46.370 --> 00:20:51.020
So it's very interesting that we are loading this resource in a platform independent way, but then

301
00:20:51.020 --> 00:20:57.760
the absolute path to the file can be a platform dependent thing, which is very nice, right?

302
00:20:57.770 --> 00:21:04.760
This is one of the nice capabilities of JVM because you can load the resources in a platform independent

303
00:21:04.760 --> 00:21:05.150
way.

304
00:21:05.450 --> 00:21:10.150
Now, there was another option in this for this resource get path.

305
00:21:10.160 --> 00:21:12.530
Let's also try that get path.

306
00:21:12.530 --> 00:21:13.940
Returns a string.

307
00:21:15.230 --> 00:21:17.630
And they kind of work the same way.

308
00:21:17.990 --> 00:21:20.810
There's not difference in in this.

309
00:21:20.810 --> 00:21:21.350
Right.

310
00:21:23.800 --> 00:21:24.250
All right.

311
00:21:24.250 --> 00:21:32.140
So, um, so these two at the moment for a file that is working at the resource get path and get file

312
00:21:32.140 --> 00:21:33.250
are more or less the same thing.

313
00:21:33.250 --> 00:21:33.700
Right?

314
00:21:34.900 --> 00:21:40.980
And so right now we have been able to successfully roll this resource in a platform independent way.

315
00:21:40.990 --> 00:21:44.590
The key is to make it available on the class path at runtime.

316
00:21:44.590 --> 00:21:44.800
Right.

317
00:21:44.800 --> 00:21:54.940
So the key here is to the key here to make the resource file available on the class path at runtime.

318
00:21:55.690 --> 00:21:57.970
This is this is the key, right?

319
00:21:59.050 --> 00:22:04.330
Because after that, everything else becomes platform independent, which is very nice.

320
00:22:05.560 --> 00:22:12.580
Now, if we do this, how do we basically now read the contents?

321
00:22:12.580 --> 00:22:17.170
Let's say we get this URL, how do we do this one thing that we can do?

322
00:22:17.170 --> 00:22:23.860
Now, obviously, instead of hard coding this string, we can ask our resource to get file, right?

323
00:22:24.670 --> 00:22:31.660
What this does is now it gets the absolute path and then pass it to the file, which is a abstraction

324
00:22:31.660 --> 00:22:34.030
of the underlying file of the operating system.

325
00:22:34.030 --> 00:22:35.920
And hopefully this is still works fine.

326
00:22:36.370 --> 00:22:37.780
Yes, this works fine.

327
00:22:37.780 --> 00:22:38.350
All right.

328
00:22:39.550 --> 00:22:46.030
However, let's see what happens now if we go ahead and compile our compile or Java application to a

329
00:22:46.030 --> 00:22:50.620
native executable file again, class loader, this kind of stuff, they're fully supported with the

330
00:22:50.620 --> 00:22:53.410
Native Image compiler because they're part of the JDK.

331
00:22:53.440 --> 00:22:57.430
Anything that is part of the JDK is fully supported, so no worry about that.

332
00:22:57.880 --> 00:23:03.460
So we select our Java File Resource demo and we run our native image.

333
00:23:05.610 --> 00:23:07.470
And we see what's going on.

334
00:23:11.750 --> 00:23:13.970
So it's preparing to compile.

335
00:23:21.360 --> 00:23:24.990
Just know that this gets the same resource if it doesn't find it.

336
00:23:24.990 --> 00:23:27.460
So it has a unchecked exception, right?

337
00:23:27.480 --> 00:23:29.040
Not point to exception.

338
00:23:29.280 --> 00:23:30.780
So we're getting a warning.

339
00:23:30.780 --> 00:23:37.500
And the warning is that, hey, resource access methods, your line class loader invoked at main method.

340
00:23:37.500 --> 00:23:38.070
Right?

341
00:23:38.070 --> 00:23:44.340
So Native Image Compiler realizes that you're accessing a resource in a platform independent way.

342
00:23:44.550 --> 00:23:48.120
And the native image says, I don't know what this resource is.

343
00:23:48.120 --> 00:23:50.400
So what it did, it actually failed.

344
00:23:50.400 --> 00:23:51.480
We've seen this before.

345
00:23:51.480 --> 00:23:59.130
When we look at the exception reflection and now it's basically false.

346
00:23:59.160 --> 00:24:08.580
It goes to a fallback mode which is creating an executable that needs to be backed up by a by a JDK.

347
00:24:09.770 --> 00:24:13.220
So if we look at this and open a terminal here.

348
00:24:16.760 --> 00:24:24.320
So if we say this one, it says that it's a fallback so it cannot run.

349
00:24:24.320 --> 00:24:24.860
Right.

350
00:24:25.580 --> 00:24:29.060
So native image failed because we're accessing a resource.

351
00:24:29.060 --> 00:24:38.540
And previously we said that anything that has with some some sort of runtime stuff that cannot be figured

352
00:24:38.540 --> 00:24:45.590
out at compile time has to be fed as extra information to Native Image compiler.

353
00:24:45.590 --> 00:24:46.570
And how do we do this?

354
00:24:46.580 --> 00:24:52.070
We did this for the reflection part using the Java Trace agent.

355
00:24:52.070 --> 00:24:58.100
So we have to run this with the Java Trace, which is the JV that comes with the native image, right,

356
00:24:58.280 --> 00:24:59.060
with the global VM.

357
00:24:59.060 --> 00:25:03.110
So let's run our Java application with the GVM that comes with the.

358
00:25:04.370 --> 00:25:10.160
With the album and it creates this meta enough and then native image.

359
00:25:10.160 --> 00:25:18.350
And then if you now look at the resource, interestingly enough, now the the then basically native

360
00:25:18.350 --> 00:25:25.790
image agent that came with the global album, a JVM realises that we are accessing a resource run media

361
00:25:25.790 --> 00:25:26.320
search.

362
00:25:26.330 --> 00:25:26.870
Right.

363
00:25:27.230 --> 00:25:33.650
And it means that this has to be available on the class path.

364
00:25:33.650 --> 00:25:41.030
And when we now we run our compilation with the native image, we select our source for resource and

365
00:25:41.030 --> 00:25:41.450
then.

366
00:25:42.950 --> 00:25:43.910
Native image.

367
00:25:43.940 --> 00:25:51.050
What you realize is that that native image looks into this configuration file resource and it tries

368
00:25:51.050 --> 00:25:52.690
to add when it tries to compile.

369
00:25:52.700 --> 00:25:58.400
We said that you have to specify the class path for the native image compiler so it is able to find

370
00:25:58.400 --> 00:25:58.670
these.

371
00:25:58.760 --> 00:26:06.440
Ramey does a search on the class path at compile time, and now it's not going to complain about accessing

372
00:26:06.440 --> 00:26:17.330
a resource because it understands that this basically this basically this resource has to be available.

373
00:26:17.330 --> 00:26:18.710
And you see there is no warning.

374
00:26:18.710 --> 00:26:21.080
It was a native image was able to find it.

375
00:26:21.080 --> 00:26:21.560
Right.

376
00:26:22.160 --> 00:26:26.300
Well, let's go ahead and run our job, this executable file.

377
00:26:28.400 --> 00:26:32.660
So if we say here and still there is a problem here.

378
00:26:34.620 --> 00:26:39.810
So research resource get filed research get past they are on this but you see there is a difference

379
00:26:39.810 --> 00:26:41.940
if I run my Java application.

380
00:26:43.410 --> 00:26:54.180
Obviously I get this result and I am able to read the contents, but when I run with basically my native

381
00:26:54.180 --> 00:26:56.160
image, I get a different result.

382
00:26:56.160 --> 00:26:58.300
It says Forward slash run me, that is H.

383
00:26:58.320 --> 00:27:03.630
And the reason is that obviously when you compile to the executable file, there is no concept of like

384
00:27:03.630 --> 00:27:06.330
a kind of class path anymore.

385
00:27:06.330 --> 00:27:14.850
You just want to run your executable file and whenever you run this it is still understands that file,

386
00:27:15.300 --> 00:27:19.830
at least the string or that resource, but it still says I cannot find that file.

387
00:27:19.860 --> 00:27:20.370
Right?

388
00:27:20.400 --> 00:27:26.580
This file fails because get file returns this from the root of the operating system.

389
00:27:26.580 --> 00:27:27.930
Go to run me that s edge.

390
00:27:27.930 --> 00:27:28.440
Right.

391
00:27:28.680 --> 00:27:31.110
Obviously this is not the correct path for this file.

392
00:27:31.110 --> 00:27:39.060
That's why our code at the moment is not exactly platform independent because of using this file.

393
00:27:39.090 --> 00:27:45.000
So we have to abandon the idea of using this this this concept of file.

394
00:27:45.000 --> 00:27:52.320
So if I want to use a scanner, I have to kind of feed this resource in a, in another way to a scanner

395
00:27:52.530 --> 00:27:55.500
and we already know what to do.

396
00:27:55.500 --> 00:28:03.000
So we saw that a scanner has another constructor that you can directly feed it, input a stream to a

397
00:28:03.000 --> 00:28:04.230
stream of bytes.

398
00:28:04.620 --> 00:28:07.860
And interestingly enough, this you are l.

399
00:28:08.840 --> 00:28:21.440
And that resource that we get as a URL has a method called the SO get authority, get file host, get

400
00:28:21.440 --> 00:28:26.030
path, get protocol, get query, get ref, get user info, get class.

401
00:28:27.110 --> 00:28:30.590
So it has a open a stream.

402
00:28:32.030 --> 00:28:34.730
This open a stream returns an input stream.

403
00:28:34.730 --> 00:28:41.870
And what this does, it gives the feeds, the scanner and input a stream that is kind of can read all

404
00:28:41.870 --> 00:28:43.880
the bytes right from that stream.

405
00:28:43.880 --> 00:28:46.720
And again, this becomes something that is platform independent.

406
00:28:46.730 --> 00:28:48.770
Now this is not tied.

407
00:28:48.770 --> 00:28:50.780
So using file

408
00:28:53.780 --> 00:29:06.890
ties us to OWS using a stream or input stream is in makes it makes it independent makes it independent

409
00:29:08.690 --> 00:29:17.420
of OS because we we have a way of independently loading that resource.

410
00:29:17.570 --> 00:29:26.180
And now there is also an a way to independently read all the bytes of that file and a scanner understands

411
00:29:26.180 --> 00:29:28.400
how to translate those bytes to character.

412
00:29:28.580 --> 00:29:34.460
So if I run this as a job application in my eclipse is still voice and nothing has changed the only

413
00:29:34.460 --> 00:29:34.760
way.

414
00:29:34.760 --> 00:29:38.810
The only thing that has changed is that we're not using the file anymore.

415
00:29:38.840 --> 00:29:39.290
Right?

416
00:29:39.290 --> 00:29:42.620
We're using the input stream that the resource provides.

417
00:29:44.640 --> 00:29:46.260
Steel works fine right now.

418
00:29:46.260 --> 00:29:48.150
Let's see what happens.

419
00:29:49.350 --> 00:29:53.060
Now we still need to run our Java trace.

420
00:29:53.070 --> 00:29:54.630
It will give us the same thing.

421
00:29:54.630 --> 00:29:54.930
Right?

422
00:29:54.930 --> 00:29:55.470
So.

423
00:29:56.460 --> 00:30:00.580
So I have to select my resource demo and then run the java trace.

424
00:30:00.600 --> 00:30:03.750
It is still has a native image in the configuration file.

425
00:30:03.760 --> 00:30:08.200
There is a resource config and we're using this run ssh as before.

426
00:30:08.220 --> 00:30:14.670
So the native image compiler understands this file can find it as at compile time.

427
00:30:14.670 --> 00:30:18.180
But now let's see what's happening now that we're using the stream.

428
00:30:18.210 --> 00:30:25.230
Actually what the native image compiler does it it reads all the bytes of this stream and hardcoded

429
00:30:25.230 --> 00:30:28.500
them into the native executable file.

430
00:30:28.530 --> 00:30:30.210
So input a stream.

431
00:30:32.400 --> 00:30:38.100
What happens is that the native image compiler at compile time, we give it the class file the class

432
00:30:38.100 --> 00:30:43.710
path and it accesses this resource and reads all the bytes, reads all the bytes.

433
00:30:43.710 --> 00:30:44.020
This.

434
00:30:44.040 --> 00:30:47.040
Obviously any compiler can read all the bytes of any file.

435
00:30:47.040 --> 00:30:47.640
That's fine.

436
00:30:47.640 --> 00:30:48.080
Right.

437
00:30:48.090 --> 00:30:56.580
And if file is just a bunch of bytes and then the compiler hardcoded them, hardcoded them into the

438
00:30:56.580 --> 00:31:01.650
final mutable binary, which is very interesting.

439
00:31:02.310 --> 00:31:05.770
So let's go ahead and select our.

440
00:31:05.790 --> 00:31:10.770
Obviously, we need to have this method in and run the Java resource to tell the native image there

441
00:31:10.770 --> 00:31:12.390
is this resource we're accessing.

442
00:31:12.720 --> 00:31:20.130
But then now let's go and finally run our compiler native image to get the executable and hopefully

443
00:31:20.130 --> 00:31:21.660
this time it's going to work.

444
00:31:21.810 --> 00:31:26.250
Our Java application, we're going to run it as a executable file.

445
00:31:26.280 --> 00:31:27.360
It's going to run.

446
00:31:27.390 --> 00:31:32.720
It's not going to actually depend on whether this run me search is available or not.

447
00:31:32.730 --> 00:31:34.510
It's completely independent of this file.

448
00:31:34.530 --> 00:31:40.440
All the contents of this file is already copied into the final file.

449
00:31:40.530 --> 00:31:41.430
Binary file.

450
00:31:43.270 --> 00:31:47.920
And that's a very powerful concept using these streams and these class loaders.

451
00:31:48.520 --> 00:31:52.720
It's really something that makes this kind of native compilation very powerful.

452
00:31:52.750 --> 00:32:00.440
So if I open a terminal here and then say, resource demo, now everything works fine, right?

453
00:32:00.460 --> 00:32:02.350
Java, hyphen, hyphen, agent version.

454
00:32:02.350 --> 00:32:07.170
We were able to successfully read the contents because we're not relying on any file.

455
00:32:07.180 --> 00:32:07.690
Remember this?

456
00:32:07.690 --> 00:32:11.120
Remind me that S-H is not available in this native directory folder.

457
00:32:11.120 --> 00:32:12.030
It doesn't matter.

458
00:32:12.040 --> 00:32:16.780
Even if I go up one level and then now say Native, this works fine.

459
00:32:16.810 --> 00:32:22.930
The binary contents of this resource has been already copied into the final executable file.

460
00:32:22.960 --> 00:32:24.630
I want you to really understand this.

461
00:32:24.640 --> 00:32:30.880
In the next lecture, I'm going to show you an example where I have a very large file, text file.

462
00:32:31.270 --> 00:32:35.500
The size of this text file is going to be like ten megabytes or so.

463
00:32:35.650 --> 00:32:42.220
And then when we compile our application and use read the contents, you see that this final size is

464
00:32:42.220 --> 00:32:49.660
like 25 megabytes because all the contents of this file have been already copied into the final file.

465
00:32:50.080 --> 00:32:51.400
So I hope you enjoy this lecture.

466
00:32:51.400 --> 00:32:53.650
Please stay tuned and I'll see the next one.
