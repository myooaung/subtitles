WEBVTT
1
00:00:00.450 --> 00:00:02.910
Hello and welcome to another tutorial.

2
00:00:02.910 --> 00:00:10.260
We are going to continue our discussion on VM Native Image and how to compile our Java application to

3
00:00:10.260 --> 00:00:11.310
Native Binary.

4
00:00:11.310 --> 00:00:17.610
And I mentioned that the first thing that you need to learn or be really familiar with is how we actually

5
00:00:17.610 --> 00:00:21.510
launch a Java application using the JDK or the tools that come.

6
00:00:21.510 --> 00:00:24.120
And we say that JDK has development tools.

7
00:00:24.120 --> 00:00:30.900
These are usually the compilers, the debugging tool like JDB, etc., or J or for example, Java flight

8
00:00:30.900 --> 00:00:35.580
recorder GFR, which monitors the performance of your application inside the JVM.

9
00:00:35.580 --> 00:00:40.560
And we said that you launch your Java application by using the Java command line tool, right?

10
00:00:40.560 --> 00:00:44.700
It's an executable binary that comes with the JDK and this is the runtime.

11
00:00:44.700 --> 00:00:51.750
And in the past it used to be called J or E or Java runtime environment, and now they decided to only

12
00:00:51.750 --> 00:00:55.200
provide one JDK, which also includes the JRA.

13
00:00:55.230 --> 00:00:55.490
Right?

14
00:00:55.500 --> 00:01:02.370
In the past you could just download the Java or Jari as a smaller file, but now it's just just one

15
00:01:02.370 --> 00:01:06.420
JDK and it has all the development tool and the runtime tools, right?

16
00:01:07.720 --> 00:01:12.520
And we said that eventually what we want to learn is that how the JV team handles your job application.

17
00:01:12.520 --> 00:01:15.460
JV team understands only the class files.

18
00:01:15.460 --> 00:01:20.230
Each class declaration in your source file will be compiled to a separate class file.

19
00:01:20.230 --> 00:01:27.040
Whenever JV team at runtime encounters an object of some type, it tries to find a class file that corresponds

20
00:01:27.040 --> 00:01:27.670
to that.

21
00:01:27.700 --> 00:01:33.190
The first time that this happens, the JVM loads the class file into memory so that it understands the

22
00:01:33.190 --> 00:01:35.560
properties or the attributes of that type.

23
00:01:35.560 --> 00:01:36.070
Right.

24
00:01:36.070 --> 00:01:40.240
Every type in Java is a class or object, with two exceptions.

25
00:01:40.240 --> 00:01:43.150
One is the primitive types like integer flow double.

26
00:01:43.720 --> 00:01:44.920
These are built in types.

27
00:01:44.920 --> 00:01:50.470
JVM doesn't need to look for a class file for them, and the other one is the built in arrays like int

28
00:01:50.470 --> 00:01:52.930
array, double array or any object array.

29
00:01:52.960 --> 00:02:00.610
Those arrays or primitive arrays in Java arrays are built in types inside the Java, which means JVM

30
00:02:00.610 --> 00:02:05.710
doesn't need to search for a class file to understand what an array type is.

31
00:02:05.710 --> 00:02:05.980
Right?

32
00:02:05.980 --> 00:02:09.400
So primitives and array types, these are built in types.

33
00:02:09.670 --> 00:02:14.230
Other types like for example, an object or whatever class you define.

34
00:02:14.230 --> 00:02:20.110
These get compiled to a separate class file and JVM loads the class file into memory to understand what

35
00:02:20.110 --> 00:02:24.460
the properties of this type are, what are the attributes, what are the aesthetic methods, what are

36
00:02:24.460 --> 00:02:26.620
the non static methods, etc. right.

37
00:02:26.710 --> 00:02:31.600
And loading the class file is only happens one during the lifetime of your application.

38
00:02:31.600 --> 00:02:36.820
The very first time JVM looks at the type and sees that it doesn't understand it.

39
00:02:36.820 --> 00:02:44.260
It tries to search for this a class file that is associated with that type, and that's where the importance

40
00:02:44.260 --> 00:02:47.440
of the class path comes into play.

41
00:02:47.440 --> 00:02:48.340
We said that.

42
00:02:49.150 --> 00:02:50.950
When you interact with the terminal.

43
00:02:50.950 --> 00:02:58.620
We said that there is a there is a environment variable called the path, right?

44
00:02:58.630 --> 00:03:02.170
This is what your operating system and the terminal understands.

45
00:03:03.420 --> 00:03:08.210
Similarly, when you launch your Java application, you can specify class path.

46
00:03:08.570 --> 00:03:11.730
Class path, hyphen, hyphen, class pairs.

47
00:03:11.730 --> 00:03:20.220
Or I usually prefer the shorter version hyphen CPP and this tells the JV team all the directories that

48
00:03:20.520 --> 00:03:24.040
it can look into to find a particular class file.

49
00:03:24.060 --> 00:03:25.320
So that's how you do it.

50
00:03:25.320 --> 00:03:30.000
And it's exactly the same as the behavior of the class.

51
00:03:30.000 --> 00:03:37.140
Path for the JVM is very similar to the behavior of the path environment variable for the terminal or

52
00:03:37.140 --> 00:03:38.340
operating system, right.

53
00:03:38.340 --> 00:03:43.050
So if I say Java, what happens behind the scenes, as I mentioned in the previous lecture, is that

54
00:03:44.850 --> 00:03:51.030
the operating system starts to search in all the directories that are specified in the path and tries

55
00:03:51.030 --> 00:03:57.540
to find for a look for an executable binary that has this name at the very first directory that has

56
00:03:57.540 --> 00:03:58.890
an application with this name.

57
00:03:58.890 --> 00:04:05.460
It just assumes that that's the case and it uses that application, right?

58
00:04:05.610 --> 00:04:09.750
Same with the Java class files and we will look at it.

59
00:04:09.750 --> 00:04:16.680
And in general, if you want to launch your Java application with a with a terminal from the terminal,

60
00:04:17.370 --> 00:04:23.190
now obviously these days everybody uses an ID and I will show you how an ID like Eclipse handles this.

61
00:04:23.190 --> 00:04:29.190
But every idea has a build system, which means the way they organize the classes and then they configure

62
00:04:29.190 --> 00:04:34.770
the class path because you can launch your Java application from within your ID and ID behind the scenes,

63
00:04:35.550 --> 00:04:38.280
basically configures this parameter hyphen TCP.

64
00:04:38.280 --> 00:04:42.600
Basically, it tells the JVM where where are the directories that the class files are.

65
00:04:42.600 --> 00:04:43.020
Right?

66
00:04:43.410 --> 00:04:51.360
But then you even for your terminal, you can define a global environment variable environment variable

67
00:04:51.360 --> 00:04:54.990
called the I believe class path.

68
00:04:55.230 --> 00:04:55.740
Right.

69
00:04:55.740 --> 00:04:57.450
This is the JVM understands.

70
00:04:57.450 --> 00:05:07.050
So by default, if you define a global environment variable called the class path, then the JV team

71
00:05:07.050 --> 00:05:11.430
actually also looks for this in the environment variables of the operating system.

72
00:05:11.850 --> 00:05:12.720
Same with Python.

73
00:05:12.720 --> 00:05:18.030
If you're familiar with Python, you can define a global environment variable for your terminal, for

74
00:05:18.030 --> 00:05:20.130
your operating system called Python path.

75
00:05:20.130 --> 00:05:20.760
Right?

76
00:05:20.880 --> 00:05:26.310
And then when you launch Python application, it also says if it finds a global environment variable

77
00:05:26.310 --> 00:05:32.910
with this name, it also adds all the directories that this has into into the Python path.

78
00:05:32.910 --> 00:05:33.180
Right.

79
00:05:33.180 --> 00:05:36.090
So JVM looks for a variable called class path.

80
00:05:36.090 --> 00:05:37.890
You don't need to define this.

81
00:05:37.890 --> 00:05:38.760
You can.

82
00:05:38.760 --> 00:05:44.340
But if you define this, then you don't need to really pass this hyphen CPP at the launch.

83
00:05:44.550 --> 00:05:45.030
All right.

84
00:05:45.210 --> 00:05:53.580
So the idea here is that when you launch your Java application with the Java, what happens is that

85
00:05:53.580 --> 00:05:59.490
obviously your application depends on the Java API, which means the JDK classes and libraries that

86
00:05:59.490 --> 00:06:00.660
come by default.

87
00:06:00.660 --> 00:06:00.990
Right.

88
00:06:00.990 --> 00:06:06.930
With the JDK, we know that Java Lang, all the classes, all the types in the Java Lang package, they

89
00:06:06.930 --> 00:06:13.080
always implicitly imported, you don't even need to to import them, which means they are very essential

90
00:06:13.080 --> 00:06:15.030
part of every Java application.

91
00:06:15.390 --> 00:06:22.020
And then JVM loads the all these APIs into memory before even loading the class voids that are associated

92
00:06:22.020 --> 00:06:26.430
with your application before even starting the main method of your application.

93
00:06:26.640 --> 00:06:31.230
And JVM sits between your Java application and operating system, right?

94
00:06:31.230 --> 00:06:35.520
So every line of code in your application gets executed by the JVM.

95
00:06:35.790 --> 00:06:39.240
Basically, JVM interprets that for your operating system.

96
00:06:39.240 --> 00:06:48.690
And operating system is the is the thing that sits between a user and application and hardware, right?

97
00:06:48.720 --> 00:06:53.340
The only way to talk to the hardware, utilize the hybrid hardware is through the operating system.

98
00:06:54.340 --> 00:06:57.460
So the application talks to the JV team, right.

99
00:06:57.460 --> 00:06:59.950
Or it gets executed on top of JV team.

100
00:07:00.130 --> 00:07:04.960
JV team talks the operating system and an operating system handles all the hardware events.

101
00:07:04.960 --> 00:07:05.380
Right.

102
00:07:05.650 --> 00:07:11.230
And we started this communication between your Java application and the JV team is in the form of class

103
00:07:11.230 --> 00:07:11.830
files.

104
00:07:11.830 --> 00:07:18.070
So you define classes, define types, those types get compiled to classifieds.

105
00:07:18.070 --> 00:07:21.250
And then when you're applying, you run your Java application.

106
00:07:21.520 --> 00:07:27.610
JVM loads the class files into memory and then understands the types that you're using right now.

107
00:07:27.610 --> 00:07:32.290
What we want to do, we want to transition from this behavior to a native image.

108
00:07:32.290 --> 00:07:37.990
Native image means that we launch your job, we run, we write our source files, right?

109
00:07:37.990 --> 00:07:39.220
Our job application.

110
00:07:39.370 --> 00:07:43.240
And then there is a compiler which we call it Native Image compiler.

111
00:07:44.080 --> 00:07:51.700
And then what happens here is that instead of compiling all the JDK classes, all the JDK classes and

112
00:07:51.700 --> 00:07:59.290
our Java source code to class files, the compiler does a static compilation, which means it compiles

113
00:07:59.290 --> 00:08:04.150
all of these into and native executable binary, right?

114
00:08:04.150 --> 00:08:10.510
And then when you run that executable binary, it means you're launching your Java application.

115
00:08:10.540 --> 00:08:12.460
There is no JVM in between.

116
00:08:12.460 --> 00:08:12.700
Right?

117
00:08:12.700 --> 00:08:16.480
So operating system directly loads that into the memory.

118
00:08:16.480 --> 00:08:22.570
So basically the execution of the your application now it is in the hands of the operating system,

119
00:08:22.570 --> 00:08:23.110
right?

120
00:08:23.860 --> 00:08:30.520
The standard procedure is on the left side where the execution of your Java application is in the hands

121
00:08:30.520 --> 00:08:33.910
of JVM and then JVM talks to the operating system.

122
00:08:33.910 --> 00:08:38.110
Obviously you can see that because the JVM is an extra step here.

123
00:08:38.140 --> 00:08:45.970
The execution is a little bit slower than if you directly execute your application via the operating

124
00:08:45.970 --> 00:08:46.510
system.

125
00:08:46.510 --> 00:08:52.480
And that's why people always say that C++ applications are obviously faster because the execution is

126
00:08:52.480 --> 00:08:55.240
really in the hands of the operating system itself.

127
00:08:55.240 --> 00:08:55.660
Right.

128
00:08:56.890 --> 00:08:59.620
So let's head to Eclipse.

129
00:08:59.620 --> 00:09:06.360
I'm going to show you how to write a Java application, a very simple one, the hello world application,

130
00:09:06.370 --> 00:09:11.950
how to manually compile it through the terminal, how to run it with the JVM, with the Java tool.

131
00:09:11.950 --> 00:09:18.370
And then we're going to discuss a complexities like packages and then what's the importance of the class

132
00:09:18.370 --> 00:09:18.910
path?

133
00:09:18.910 --> 00:09:19.480
All right.

134
00:09:19.660 --> 00:09:25.750
But again, all these I'm going to show them how they work in the terminal first and then we look at

135
00:09:25.750 --> 00:09:27.070
how the ID handles them.

136
00:09:27.100 --> 00:09:30.610
So I've created a project in my Eclipse IDE called Java Native Image.

137
00:09:30.610 --> 00:09:31.120
Right.

138
00:09:31.210 --> 00:09:37.930
And I've configured this project to use Java 17, but I'm not going to use this Java project that Eclipse

139
00:09:37.930 --> 00:09:38.380
manages.

140
00:09:38.380 --> 00:09:45.730
I'm going to create an empty folder like test and then I'm going to open a terminal here.

141
00:09:47.430 --> 00:09:48.060
All right.

142
00:09:48.150 --> 00:09:55.140
So what I'm going to do, I'm going to create a basically empty Java file.

143
00:09:55.170 --> 00:10:07.200
So I'm going to say, for example, chat or maybe a cool hello to a file.

144
00:10:07.650 --> 00:10:11.250
Let's say hello vol dot java, right.

145
00:10:12.030 --> 00:10:18.300
If I do an LZ, you see there is a helloworld java and I'm going to open it with the eclipse ID.

146
00:10:18.330 --> 00:10:18.840
Right.

147
00:10:19.170 --> 00:10:23.850
Eclipse text editor and I'm going to define type my class.

148
00:10:23.850 --> 00:10:24.270
Right.

149
00:10:24.270 --> 00:10:25.980
So let's call it a public class.

150
00:10:25.980 --> 00:10:28.050
So public class.

151
00:10:28.410 --> 00:10:29.340
Hello world.

152
00:10:29.340 --> 00:10:29.840
Right.

153
00:10:29.850 --> 00:10:35.250
In Java, every, every your everything is inside the scope of a class.

154
00:10:35.250 --> 00:10:35.550
Right.

155
00:10:35.550 --> 00:10:42.810
And when the Java compiler compiles this class definition, this gets compiled into a binary file which

156
00:10:42.810 --> 00:10:44.580
has an extension dot class.

157
00:10:44.580 --> 00:10:45.030
Right.

158
00:10:45.030 --> 00:10:56.190
So it gets a compile to a binary file which which ends the name is going to be hello world dot class.

159
00:10:56.460 --> 00:11:02.040
And when you launch your Java application, the JVM loads this class into memory and in order to execute.

160
00:11:02.040 --> 00:11:08.940
So the entry point, the entry point to your Java application, if you are not developing a library,

161
00:11:08.940 --> 00:11:09.140
right?

162
00:11:09.150 --> 00:11:14.820
If you're developing a Java application, which means you want to execute your application is the main

163
00:11:14.820 --> 00:11:15.150
method.

164
00:11:15.150 --> 00:11:19.830
So public static, it has to be public so that JVM can always access it.

165
00:11:19.860 --> 00:11:23.910
It has to be a static so that the JVM doesn't need to instantiate this class.

166
00:11:23.910 --> 00:11:25.830
It doesn't need to create an object.

167
00:11:27.120 --> 00:11:29.850
Main doesn't return anything in C++.

168
00:11:29.850 --> 00:11:37.500
You know, that Main actually can return a zero an integer, but it's not necessarily the default nowadays.

169
00:11:37.500 --> 00:11:42.900
The default behavior is that if the main executes successfully, it returns zero.

170
00:11:42.900 --> 00:11:44.340
But JVM doesn't care.

171
00:11:44.340 --> 00:11:46.650
That's why they decided to declare this as void.

172
00:11:46.650 --> 00:11:51.570
You don't need to return zero or whatever public aesthetic void main.

173
00:11:52.290 --> 00:11:56.970
And we said that there is a concept of a command line arguments and that's the string array.

174
00:11:57.120 --> 00:12:02.640
Remember when you launch your application in the terminal, terminal is a text based interface.

175
00:12:02.640 --> 00:12:06.840
Everything in the terminal is text, right?

176
00:12:06.840 --> 00:12:14.310
You run your application, the application can get some input as text and eventually it returns something

177
00:12:14.310 --> 00:12:15.420
back as text.

178
00:12:15.450 --> 00:12:18.870
Even if your application returns, a number does some calculation.

179
00:12:18.870 --> 00:12:23.370
The terminal in order to display on the terminal, it has to be in the format of text.

180
00:12:23.370 --> 00:12:23.730
Right.

181
00:12:23.730 --> 00:12:25.140
Why do we have a string arrays?

182
00:12:25.140 --> 00:12:31.110
Because when you launch your job application Java, let's say eventually we will say hello world, right.

183
00:12:31.710 --> 00:12:38.100
You tell you tell the operating system to launch the Java, the Java tool use this class file which

184
00:12:38.100 --> 00:12:45.360
has a main method and then after that whatever comes arg one, a space, arg two, etc., right?

185
00:12:45.360 --> 00:12:52.920
So you can have a comma separated list of strings and all these are going to be translated into this

186
00:12:52.980 --> 00:12:53.910
string array.

187
00:12:54.660 --> 00:12:57.420
So you have to add a spaces between them.

188
00:12:58.740 --> 00:13:03.870
And then we're going to say system dot out, dot print line.

189
00:13:03.870 --> 00:13:05.430
This is from the JDK.

190
00:13:05.460 --> 00:13:08.700
That's why our application always depends on the JDK.

191
00:13:09.300 --> 00:13:12.120
Hello World, right?

192
00:13:13.290 --> 00:13:15.330
Hello World from Java application.

193
00:13:16.850 --> 00:13:19.220
From Java application.

194
00:13:19.610 --> 00:13:21.410
And some exclamation marks.

195
00:13:21.410 --> 00:13:22.540
So we save this.

196
00:13:22.550 --> 00:13:25.880
This text file is ready right now to the operating system.

197
00:13:25.880 --> 00:13:27.110
This is just a text file, right?

198
00:13:27.140 --> 00:13:28.520
It doesn't have any meaning.

199
00:13:28.520 --> 00:13:32.240
So let's go back to our terminal and what we want to do.

200
00:13:32.240 --> 00:13:38.180
We want to convert this text file, which is our source file into a class file so that JVM can load

201
00:13:38.180 --> 00:13:40.250
it into memory and execute our application.

202
00:13:40.370 --> 00:13:43.460
So the way we do it, we have to use the compiler.

203
00:13:43.460 --> 00:13:50.060
So and again, what I always like to do first to see which version of Java I'm using and where is this

204
00:13:50.060 --> 00:13:51.740
Java executable come from.

205
00:13:51.800 --> 00:13:59.060
Remember I said that the which command it tells searches in the path environment variable to see where

206
00:13:59.060 --> 00:14:01.580
the operating system can locate this executable.

207
00:14:01.700 --> 00:14:04.130
Now I'm using the Oracle JDK 17.

208
00:14:05.180 --> 00:14:11.870
And so my Java is Java hotspot and same with the Java Sea or Java compiler.

209
00:14:11.870 --> 00:14:15.950
It comes from the JDK 17 Java Sea hyphen, hyphen version.

210
00:14:16.970 --> 00:14:20.150
And as you can see, I'm using the Java 17, right?

211
00:14:20.150 --> 00:14:28.460
So what we're going to do is compile this source, file A Java C, and then you give it the name of

212
00:14:28.460 --> 00:14:30.320
the class HELLOWORLD Java.

213
00:14:30.350 --> 00:14:33.530
It takes a little bit of time if we do a list again.

214
00:14:33.530 --> 00:14:35.990
You see, now we have a hello world class.

215
00:14:35.990 --> 00:14:42.670
So if I refresh here, the Helloworld class comes in and it clips when I drag it into the editor.

216
00:14:42.680 --> 00:14:51.050
I've configured the eclipse to decompile the class, but you can also open it with the class file editor.

217
00:14:51.050 --> 00:14:55.600
So this translates the binary contents of this class file.

218
00:14:55.610 --> 00:15:00.740
Remember, the contents of this class file is binary, it's not a text.

219
00:15:01.220 --> 00:15:10.400
But then you can basically look at the context, basically the contents of this using the eclipse class

220
00:15:10.400 --> 00:15:11.150
file we were.

221
00:15:11.690 --> 00:15:15.710
So the binaries translate into a public helloworld this is the constructor.

222
00:15:15.710 --> 00:15:21.590
We know that if we don't provide any constructor, the compiler will add a default.

223
00:15:21.590 --> 00:15:24.320
No argument constructor which is public that's there.

224
00:15:24.320 --> 00:15:28.010
And the job all it does is it calls the Superclass constructor.

225
00:15:28.010 --> 00:15:33.890
We know that the object class Java line object is the superclass of every type and the superclass of

226
00:15:33.890 --> 00:15:37.550
a type has to be initialized in the constructor of the subtype.

227
00:15:37.550 --> 00:15:39.950
That's why we call the constructor of the superclass.

228
00:15:40.100 --> 00:15:43.430
And then we have one method main which is public static void.

229
00:15:43.430 --> 00:15:50.540
It gets a static field from Java like system which is out of type print a stream and then loads a constant

230
00:15:50.630 --> 00:15:59.510
string and then invokes a non static or virtual method from this print stream class which is out, right?

231
00:15:59.510 --> 00:16:04.040
This out is a of type print stream and then this method is overloaded.

232
00:16:04.040 --> 00:16:09.710
The print line takes this particular method, it takes a string and returns void and then eventually

233
00:16:09.710 --> 00:16:14.000
we return from our main method and the Java application 10 minutes.

234
00:16:14.000 --> 00:16:14.300
Right.

235
00:16:14.300 --> 00:16:15.200
Successfully.

236
00:16:15.590 --> 00:16:16.730
That's how this works.

237
00:16:16.730 --> 00:16:23.450
So behind the scenes, the very first thing that you see that happens is that Java C adds a default

238
00:16:23.450 --> 00:16:24.290
constructor.

239
00:16:24.590 --> 00:16:28.610
Every class, every type has to have a constructor.

240
00:16:28.610 --> 00:16:34.160
If you don't provide one, a default constructor will be provided by the Java compiler.

241
00:16:34.160 --> 00:16:34.760
All right.

242
00:16:35.090 --> 00:16:41.090
So back here, now that we successfully compiled or Java application, we want to run it, right?

243
00:16:41.090 --> 00:16:44.840
So we use Java C to compile the application and now we want to run it.

244
00:16:44.870 --> 00:16:47.960
We use the JV or Java Command, right?

245
00:16:47.960 --> 00:16:51.140
And then we don't give it the source file.

246
00:16:51.140 --> 00:16:57.180
We don't use the Java file, we use the class file because JVM or the Java tool Java exec only understands

247
00:16:57.180 --> 00:17:01.430
the class file and you give it the class that has the main method, right?

248
00:17:01.430 --> 00:17:08.240
So you may have multiple classes that have main methods and you have to tell the JVM which class is

249
00:17:08.240 --> 00:17:10.190
the entry point to your Java application.

250
00:17:10.190 --> 00:17:16.730
And when you do that, the JV team looks at that class file and see if there is a main method public

251
00:17:16.790 --> 00:17:19.820
static void main method inside that and it tries to execute it.

252
00:17:19.820 --> 00:17:21.110
So hello world.

253
00:17:21.110 --> 00:17:26.060
And when you do that, you don't type the dot class, you don't do that, you only write the name.

254
00:17:26.060 --> 00:17:34.130
So if I launch this, it's successfully executes and you see the terminal again, you launch your applications

255
00:17:34.880 --> 00:17:35.890
through the terminal, right?

256
00:17:35.900 --> 00:17:42.560
Terminal is the window between you and the operating system and every application has to be run through

257
00:17:42.560 --> 00:17:44.690
the terminal, every application.

258
00:17:44.780 --> 00:17:49.100
Therefore when you run it, it has a working directory.

259
00:17:49.100 --> 00:17:52.520
So right now this test directory is our working directory.

260
00:17:53.900 --> 00:17:59.420
And then there are ways in your Java source code to examine the working directory when you launch your

261
00:17:59.420 --> 00:18:01.490
application in the job in eclipse.

262
00:18:01.490 --> 00:18:04.400
Every IDE sets the working directory differently.

263
00:18:04.400 --> 00:18:12.260
Right in in your eclipse IDE, you can just say run as right and then this doesn't work because I didn't

264
00:18:12.260 --> 00:18:13.550
compile this with eclipse.

265
00:18:13.550 --> 00:18:14.090
Eclipse.

266
00:18:14.720 --> 00:18:22.220
When you say run as it tries to basically create a run configuration, eclipse has its own compiler

267
00:18:22.220 --> 00:18:26.510
and it organizes the classifiers into a separate directory called Beam.

268
00:18:26.510 --> 00:18:27.710
But here we didn't do that.

269
00:18:27.710 --> 00:18:35.540
We put the class file exactly in the in the basically source file in the directory that had the source

270
00:18:35.540 --> 00:18:35.690
file.

271
00:18:35.840 --> 00:18:37.700
So Eclipse doesn't understand it.

272
00:18:37.940 --> 00:18:44.710
So remember it is configured the class path and then differently they have different folder directory

273
00:18:44.750 --> 00:18:49.790
hierarchy as to where they put their class files, the binary files.

274
00:18:49.790 --> 00:18:50.210
Right.

275
00:18:50.450 --> 00:18:57.890
And then eventually when you launch an application, the ID tells the GVM or the Java tool which class

276
00:18:57.890 --> 00:19:04.370
to use as the main method that has the main method, and then how the class path is configured.

277
00:19:04.580 --> 00:19:09.020
Which directories to look into when GM tries to search for a class file.

278
00:19:09.380 --> 00:19:13.700
Now again, our application is giving us feedback in the format of text.

279
00:19:13.700 --> 00:19:15.560
And the only that's the only thing that we do.

280
00:19:15.560 --> 00:19:21.290
For example, if we do a System.out.println five, right?

281
00:19:22.100 --> 00:19:25.480
Remember this five is a primitive integer in your Java.

282
00:19:25.490 --> 00:19:29.210
When the Java compiler sees this, this becomes a primitive integer, right?

283
00:19:29.210 --> 00:19:30.860
This is not a string type.

284
00:19:30.950 --> 00:19:37.790
But then in terminal when you tell hey, put out five to the terminal, this out means output to the

285
00:19:37.790 --> 00:19:39.890
system which is output to the terminal.

286
00:19:40.040 --> 00:19:48.320
This five gets translated into five in the format of a string like basically five because terminal doesn't

287
00:19:48.320 --> 00:19:52.820
understand primitive types, it just understands the strings right now.

288
00:19:52.820 --> 00:19:59.150
Obviously, if I change something in the source code and my launch, my application, the changes are

289
00:19:59.150 --> 00:20:02.990
not reflected because I have to recompile the source file.

290
00:20:03.020 --> 00:20:05.270
So you have to first save it, right?

291
00:20:05.270 --> 00:20:06.860
And then go back here.

292
00:20:07.770 --> 00:20:11.460
And say Java Sea Helloworld Java you compile it.

293
00:20:11.460 --> 00:20:13.950
The binary file or reclassified gets updated.

294
00:20:13.980 --> 00:20:20.100
Now if I type a java hello world and see the five is there but again terminal.

295
00:20:20.100 --> 00:20:25.830
When it gives you feedback, it's always in the format of text, which means that there is no really

296
00:20:25.830 --> 00:20:31.890
difference when you run your application between these five as a integer or five as a string.

297
00:20:32.100 --> 00:20:35.220
The feedback that your application gives is basically the same.

298
00:20:35.220 --> 00:20:35.510
Right.

299
00:20:35.550 --> 00:20:39.030
I want you to understand this very carefully.

300
00:20:40.590 --> 00:20:40.890
All right.

301
00:20:40.890 --> 00:20:46.910
So that's the first thing how you handle your Java applications have to commit.

302
00:20:46.950 --> 00:20:48.150
This is the simplest case.

303
00:20:48.150 --> 00:20:48.480
Right.

304
00:20:48.480 --> 00:20:53.010
And then there are a few things that we want to explore.

305
00:20:53.040 --> 00:20:56.270
The one is, what if your application becomes more complicated?

306
00:20:56.280 --> 00:20:56.890
Right.

307
00:20:56.910 --> 00:21:02.580
And one thing that I want to mention, that in this case, I'm not giving any parameter for hyphen,

308
00:21:02.610 --> 00:21:04.080
keep the class path.

309
00:21:04.230 --> 00:21:11.610
But when you don't specify this explicitly, JVM, when you launch your Java application, JVM searches

310
00:21:11.760 --> 00:21:12.990
in two locations.

311
00:21:12.990 --> 00:21:15.510
One is the current working directory.

312
00:21:15.630 --> 00:21:19.830
So you know that I launched my Java application from within the test, right?

313
00:21:20.100 --> 00:21:21.630
Now what I could do.

314
00:21:22.850 --> 00:21:30.020
I could actually go a folder up, go into this Java native image.

315
00:21:30.020 --> 00:21:33.980
Now I'm in this directory which is outside a one level up, right?

316
00:21:34.160 --> 00:21:40.760
And now if I go back, okay, actually, we want to let's close this terminal and then go back to the

317
00:21:40.760 --> 00:21:41.430
other one.

318
00:21:41.450 --> 00:21:42.800
If I say Java, hello?

319
00:21:42.810 --> 00:21:48.890
Well, this doesn't work because JVM says that you tell me to look for a class file with this name.

320
00:21:48.890 --> 00:21:49.700
Hello world.

321
00:21:49.700 --> 00:21:52.340
But I could not find or load the main class.

322
00:21:52.340 --> 00:21:53.180
Hello World.

323
00:21:53.660 --> 00:21:54.710
Java lang class.

324
00:21:54.710 --> 00:21:56.230
Not found exception helloworld.

325
00:21:56.240 --> 00:22:02.930
So basically it's telling me I couldn't find a file, a binary file called Hello Class because when

326
00:22:02.930 --> 00:22:06.860
I launch this application, it tries to search for a class file in this directory.

327
00:22:06.860 --> 00:22:07.340
Right?

328
00:22:07.700 --> 00:22:14.900
So the correct thing to do is tell it to go give it a relative path from current directory, go into

329
00:22:14.900 --> 00:22:19.130
the test and then hello world and you don't add that dot class.

330
00:22:19.130 --> 00:22:19.520
Right.

331
00:22:19.970 --> 00:22:21.530
And again this doesn't work.

332
00:22:21.530 --> 00:22:22.100
Why.

333
00:22:22.760 --> 00:22:23.750
Because.

334
00:22:25.790 --> 00:22:30.200
So the reason this doesn't work is that you cannot specify a path.

335
00:22:30.200 --> 00:22:38.780
So Java tool has a strict rule that you cannot give it a executable in the format of a path.

336
00:22:38.780 --> 00:22:40.340
Java doesn't understand it.

337
00:22:40.880 --> 00:22:46.370
In fact, in your operating system, if you have an executable binary, you can give it a path.

338
00:22:46.370 --> 00:22:47.900
We've already seen this, right?

339
00:22:48.350 --> 00:22:54.620
For example, instead of typing java, you can say a slash library, java virtual machines, JDK 17

340
00:22:54.620 --> 00:22:55.820
being Java, right.

341
00:22:55.820 --> 00:22:57.860
But JVM doesn't do that.

342
00:22:57.860 --> 00:23:03.710
It's not correct for you have to instead of giving a path that leads to your class file, you have to

343
00:23:03.710 --> 00:23:08.660
give it the fully qualified name of the class, which includes the Java packages and Java hierarchy.

344
00:23:08.660 --> 00:23:11.120
I assume you're already familiar with the fully qualified name.

345
00:23:11.210 --> 00:23:14.210
If not, I will discuss this in future lectures.

346
00:23:14.210 --> 00:23:22.520
So when you launch your Java application, you cannot give it a path to the to the to the class file

347
00:23:22.520 --> 00:23:23.480
that has the main method.

348
00:23:23.480 --> 00:23:24.200
That's not correct.

349
00:23:24.200 --> 00:23:27.470
That doesn't work for Java application when you use JVM.

350
00:23:27.500 --> 00:23:27.860
Right.

351
00:23:28.490 --> 00:23:33.500
But for operating system and native executable binaries, that works.

352
00:23:33.500 --> 00:23:39.080
You can give it a relative path, absolute path to a executable binary and the operating system understands

353
00:23:39.080 --> 00:23:39.860
how to execute it.

354
00:23:39.860 --> 00:23:43.430
But that doesn't work for Java application, right?

355
00:23:43.430 --> 00:23:46.640
You have to specify something called the fully qualified name.

356
00:23:46.910 --> 00:23:56.480
Fully qualified name only understands the packages and basically only understands the packages and the

357
00:23:56.480 --> 00:23:57.020
class name.

358
00:23:57.020 --> 00:23:57.260
Right?

359
00:23:57.260 --> 00:24:01.370
So right now this Java class, we didn't put it in any package.

360
00:24:01.370 --> 00:24:05.600
So it does it the fully qualified name is actually the name of the class.

361
00:24:05.750 --> 00:24:08.090
Now you can see the look at the full qualified name.

362
00:24:08.090 --> 00:24:15.380
If you open this with a with a class file we are you see there is no package.

363
00:24:15.380 --> 00:24:22.370
If you put this type or the class file into a package, then the name of the class or the type has a

364
00:24:22.370 --> 00:24:24.880
dot package like package one dot HELLOWORLD.

365
00:24:24.890 --> 00:24:29.630
But right now the name of this type is exactly the name of the class that we define.

366
00:24:29.630 --> 00:24:30.170
All right.

367
00:24:30.290 --> 00:24:33.620
If you don't know what these things are, packages fully qualified name.

368
00:24:33.620 --> 00:24:37.250
I have a full course on becoming the master of Java.

369
00:24:37.250 --> 00:24:42.590
I highly recommend you to go sign up for it and then learn these concepts.

370
00:24:42.590 --> 00:24:43.820
These are very important.

371
00:24:44.770 --> 00:24:45.910
So this doesn't work.

372
00:24:45.910 --> 00:24:46.710
We cannot tell it.

373
00:24:46.720 --> 00:24:52.660
Hey, from this Java native image, go inside the test directory and then execute a binary class that

374
00:24:52.660 --> 00:24:53.500
has hello world.

375
00:24:53.530 --> 00:24:59.410
This doesn't work because Java JVM doesn't understand the operating system path, right?

376
00:24:59.410 --> 00:25:00.850
It doesn't understand the file path.

377
00:25:00.850 --> 00:25:06.100
It understands the Java path which is different from the file path.

378
00:25:06.130 --> 00:25:12.610
Java path is with respect to the class path or directories that are specified in the class file.

379
00:25:12.610 --> 00:25:17.770
So what we need to do, we need to, instead of telling it, go into the test directory and execute

380
00:25:17.770 --> 00:25:19.360
the hello world, which doesn't work.

381
00:25:19.360 --> 00:25:24.520
We have to specify the directory, the test directory as part of the class path.

382
00:25:24.520 --> 00:25:25.780
So dot test.

383
00:25:26.390 --> 00:25:26.950
Right.

384
00:25:27.160 --> 00:25:33.490
So if we launch this now, our application works, which means so we have a class that has a main method,

385
00:25:33.490 --> 00:25:38.080
the name of the class, the fully qualified name is just the name of the class because it doesn't belong

386
00:25:38.080 --> 00:25:39.040
to any package.

387
00:25:40.130 --> 00:25:45.680
And then we tell team to search for this type that has a main method inside this directory.

388
00:25:45.710 --> 00:25:53.060
Now, we could tell it to basically we could have multiple directories and you have to separate them

389
00:25:53.060 --> 00:25:53.710
with colon.

390
00:25:53.720 --> 00:25:59.630
So for example, one thing that we always want to do is also append dot to it.

391
00:25:59.660 --> 00:26:05.570
That means the current directory and the directory in the test directory from current directory, go

392
00:26:05.570 --> 00:26:07.010
inside the test directory.

393
00:26:07.490 --> 00:26:12.830
And what this means again, the concept of the class path is Java looks for the type name, the name

394
00:26:12.830 --> 00:26:17.600
of the type and you cannot give a full path to the class file.

395
00:26:17.630 --> 00:26:19.400
That doesn't work for Java application.

396
00:26:19.550 --> 00:26:26.060
Instead, you specify the directories that the GM can look inside to finding a class file with this

397
00:26:26.060 --> 00:26:28.100
name with the parameter class path.

398
00:26:28.580 --> 00:26:34.070
And usually we have the dot dot means the current directory which is this our Java native image.

399
00:26:34.070 --> 00:26:34.550
Right.

400
00:26:35.000 --> 00:26:41.900
And then the class path separator is colon, always is colon just like the path separator in macros.

401
00:26:41.900 --> 00:26:48.200
And so I'm specifying two directories on my class path when I launch this job application.

402
00:26:48.200 --> 00:26:53.390
One is the current directory, the other one is the direct the test directory which is inside the client

403
00:26:53.390 --> 00:26:53.960
directory.

404
00:26:54.080 --> 00:27:00.860
So when I launch this command, JVM looks for a type called a class file called Hello World.

405
00:27:00.890 --> 00:27:04.940
Inside the current directory it doesn't find it, so it's from Colon Directory.

406
00:27:04.940 --> 00:27:06.680
It goes into the test directory.

407
00:27:06.710 --> 00:27:10.250
It finds that so that it able it is able to execute it.

408
00:27:10.250 --> 00:27:10.850
All right.

409
00:27:11.120 --> 00:27:13.220
Now let's add a little bit of complexity.

410
00:27:13.220 --> 00:27:15.500
What happens if we declare a package?

411
00:27:17.930 --> 00:27:23.960
We say that this class, this type belongs to a Java package, so package my package.

412
00:27:24.610 --> 00:27:25.130
All right.

413
00:27:25.160 --> 00:27:28.010
So you have to tell me with semicolon, what happens now?

414
00:27:28.010 --> 00:27:33.560
Obviously, we changed something in the source code, so we have to go ahead and compile it again.

415
00:27:33.560 --> 00:27:34.070
Right.

416
00:27:34.160 --> 00:27:41.750
So I'm right now I'm inside the Java native image, the source file inside the inside the test.

417
00:27:41.750 --> 00:27:47.510
So I'm going to see the Java compiler go into the test and then hello world Java.

418
00:27:48.050 --> 00:27:48.530
Right.

419
00:27:48.530 --> 00:27:53.390
When you want to compile, obviously you can give you have to specify the file and it can be a relative

420
00:27:53.390 --> 00:27:55.400
path, absolute path, etc..

421
00:27:55.820 --> 00:27:57.080
So this works.

422
00:27:57.860 --> 00:28:04.280
If I open this class file again with the class file view, you see that the name of the type now changes.

423
00:28:04.460 --> 00:28:06.200
Look at the name of the type.

424
00:28:06.200 --> 00:28:07.700
It's the package, dot.

425
00:28:07.700 --> 00:28:08.680
The name of the class.

426
00:28:08.690 --> 00:28:09.070
All right.

427
00:28:09.080 --> 00:28:13.310
This means this helloworld class or type is not a freestanding type.

428
00:28:13.340 --> 00:28:15.200
It has a fully qualified name.

429
00:28:15.380 --> 00:28:18.470
Now, let's see what happens when we try to execute this.

430
00:28:19.330 --> 00:28:19.770
All right.

431
00:28:19.780 --> 00:28:23.130
Now, first of all, I'm going to go back to inside the test folder.

432
00:28:23.140 --> 00:28:23.620
Right.

433
00:28:23.770 --> 00:28:24.790
So we have this.

434
00:28:24.790 --> 00:28:26.080
Hello, world class.

435
00:28:26.110 --> 00:28:30.520
If I say Java Hello World, which we did before.

436
00:28:31.120 --> 00:28:36.400
So this command worked before declaring this class to be belonging to a package.

437
00:28:36.400 --> 00:28:38.550
But now this doesn't work.

438
00:28:39.130 --> 00:28:44.800
Could not find or load main class level because now this class has a fully qualified name.

439
00:28:44.800 --> 00:28:47.830
So what we need to do, we need to specify the fully qualified name.

440
00:28:47.830 --> 00:28:49.120
And that's the package.

441
00:28:49.570 --> 00:28:50.440
My package.

442
00:28:50.440 --> 00:28:50.760
Dot.

443
00:28:50.770 --> 00:28:51.340
Hello.

444
00:28:51.940 --> 00:28:52.480
Fold.

445
00:28:52.480 --> 00:28:54.340
And we don't use the dot class.

446
00:28:54.340 --> 00:28:54.790
Right.

447
00:28:54.970 --> 00:29:01.960
So Java looks into the class path which right now it's the current directory, tries to find a class

448
00:29:01.960 --> 00:29:08.380
file that has this name Hello World and it declares a type that has a fully qualified name my package

449
00:29:09.280 --> 00:29:11.770
and then sees if it has a main method.

450
00:29:11.770 --> 00:29:13.150
If it does, it executed.

451
00:29:13.150 --> 00:29:13.630
Right.

452
00:29:13.810 --> 00:29:15.070
Now, right now, this

453
00:29:17.890 --> 00:29:19.260
this didn't work.

454
00:29:19.270 --> 00:29:21.550
The question is why this didn't work.

455
00:29:23.450 --> 00:29:24.180
So let's see.

456
00:29:24.200 --> 00:29:26.450
Java hyphen CPP.

457
00:29:26.480 --> 00:29:28.670
We specify that dot.

458
00:29:28.670 --> 00:29:29.240
Right.

459
00:29:29.930 --> 00:29:30.600
And then.

460
00:29:33.430 --> 00:29:36.610
The question is so the reason is that.

461
00:29:37.000 --> 00:29:38.530
So my package.

462
00:29:39.220 --> 00:29:40.750
Dot hello world.

463
00:29:41.200 --> 00:29:50.170
Now the reason is that whenever you have a package, Java expects you to have a basically a directory

464
00:29:50.170 --> 00:29:52.090
hierarchy that corresponds to packages.

465
00:29:52.090 --> 00:29:57.030
So I'm going to create a directory, a folder called my package.

466
00:29:57.040 --> 00:29:57.640
Right?

467
00:29:57.790 --> 00:30:04.030
And then what I'm going to do, I'm going to copy this inside this my package.

468
00:30:04.270 --> 00:30:05.020
And then

469
00:30:07.510 --> 00:30:15.700
so and then what we're going to do if I launch Java from the test directory, which is one level up

470
00:30:15.700 --> 00:30:17.290
from this my package directory.

471
00:30:17.290 --> 00:30:25.210
And then this works because whenever your class or type belongs to a package, it tells the JVM from

472
00:30:25.210 --> 00:30:30.670
the current working directory or from whatever directories that are in the class path.

473
00:30:30.670 --> 00:30:30.930
Right.

474
00:30:30.940 --> 00:30:32.830
Right now it's the current directory.

475
00:30:32.830 --> 00:30:33.220
Right.

476
00:30:33.250 --> 00:30:40.810
Class path dot dot means just start from the current test whenever you have a fully qualified name.

477
00:30:40.850 --> 00:30:47.590
The way this is interpreted, interpreted for the Java Tool or JVM is that there is supposed to be a

478
00:30:47.590 --> 00:30:53.950
directory folder inside the current directory called my package and then there's supposed to be a class

479
00:30:53.950 --> 00:30:58.060
file called the Hello World inside that directory.

480
00:30:58.060 --> 00:30:58.600
Right?

481
00:30:58.600 --> 00:31:04.690
So if you your class belongs to a package, then there should be a directory hierarchy corresponding

482
00:31:04.690 --> 00:31:10.780
to the packages on your hard disk and your basically folders.

483
00:31:10.780 --> 00:31:11.200
Right.

484
00:31:12.130 --> 00:31:16.180
So packages are a way of organizing them, organizing class files.

485
00:31:16.180 --> 00:31:22.570
But then there has to be a directory hierarchy that basically correspond to, to the packages.

486
00:31:22.570 --> 00:31:25.600
So you cannot just basically.

487
00:31:27.950 --> 00:31:31.920
You cannot just basically have packages without an actual data hierarchy.

488
00:31:31.940 --> 00:31:36.950
And you can see that when your Java application becomes large, this kind of stuff, adding packages

489
00:31:36.950 --> 00:31:40.060
and creating these directories becomes complicated.

490
00:31:40.070 --> 00:31:41.390
That's why we have IDs.

491
00:31:41.390 --> 00:31:47.540
And for programming languages like Java, you really have to use an ID because a lot of these complexities

492
00:31:47.540 --> 00:31:49.820
are automatically managed by an ID.

493
00:31:49.970 --> 00:31:54.590
Now, the last thing that I want to show in this example is that now I compiled my class.

494
00:31:54.590 --> 00:32:02.720
It's it, it belongs to a package and it's correctly put in a directory that has the same name as package,

495
00:32:02.720 --> 00:32:03.590
which is correct.

496
00:32:03.590 --> 00:32:04.460
Everything is great.

497
00:32:04.460 --> 00:32:11.660
But what happens if right now we saw that java my package helloworld works because I'm inside the test

498
00:32:11.660 --> 00:32:12.260
directory.

499
00:32:12.260 --> 00:32:14.630
What if I go inside another directory?

500
00:32:14.630 --> 00:32:16.490
So right now I'm in the Java native.

501
00:32:16.520 --> 00:32:22.640
How do I launch this helloworld application which belongs to a package from another directory?

502
00:32:22.640 --> 00:32:27.350
So in order to do that now I have to tell the Java where the class path is.

503
00:32:27.350 --> 00:32:33.830
I have to if I say Java my package hello world, it's not going to work because my current working directory

504
00:32:33.950 --> 00:32:37.550
doesn't have a directory called my package inside it.

505
00:32:37.550 --> 00:32:38.000
Right.

506
00:32:38.000 --> 00:32:44.840
And if I tell Java and then from current directory go into the test and look for this, this is also

507
00:32:44.840 --> 00:32:45.770
not going to work.

508
00:32:45.770 --> 00:32:53.090
We said that when you launch a Java application using JVM, you cannot specify the path to the class

509
00:32:53.090 --> 00:32:53.420
file.

510
00:32:53.450 --> 00:32:54.380
That doesn't work.

511
00:32:54.410 --> 00:33:01.910
Instead, you have to specify the directory which is in this case is test right as part of the class

512
00:33:01.910 --> 00:33:02.360
path.

513
00:33:02.360 --> 00:33:09.230
So we want to say dot from current directory go inside the test, which means a search for a class file

514
00:33:09.230 --> 00:33:16.010
hello world which is inside a directory in my package and that directory is inside one of the directories

515
00:33:16.010 --> 00:33:18.290
that are specified in the class path right now.

516
00:33:18.290 --> 00:33:19.700
It's test, right.

517
00:33:19.700 --> 00:33:21.680
So this is going to work.

518
00:33:22.580 --> 00:33:23.210
Yes.

519
00:33:23.210 --> 00:33:26.540
So the name of your application is always the fully qualified name.

520
00:33:26.540 --> 00:33:31.220
You cannot specify a path to that class file that that never works for Java.

521
00:33:31.220 --> 00:33:38.690
Instead, you specify the directories that your application needs to launch search for all class files

522
00:33:38.690 --> 00:33:41.720
using basically the class path.

523
00:33:41.720 --> 00:33:50.290
Now the last example that I'm going to show you is which also highlights the importance of class package.

524
00:33:50.300 --> 00:33:51.620
I'm going to delete this.

525
00:33:51.620 --> 00:33:53.300
I'm going to delete this class file.

526
00:33:53.510 --> 00:33:54.590
Right now.

527
00:33:54.770 --> 00:33:59.270
I'm going to create another class folder called Test two, right?

528
00:33:59.270 --> 00:34:08.540
And I am going to create a new let's and then I'm going to let's copy this java hello world into here.

529
00:34:10.800 --> 00:34:13.140
Let's basically.

530
00:34:15.280 --> 00:34:16.170
A rename it.

531
00:34:16.420 --> 00:34:18.530
I'm going to call this car Java.

532
00:34:18.550 --> 00:34:18.910
Right.

533
00:34:18.910 --> 00:34:20.140
And then let's open it.

534
00:34:20.140 --> 00:34:21.750
I'm going to define a class car.

535
00:34:21.760 --> 00:34:26.740
Remember, one of the rules is that if you have a public class in a source file, the name of that class

536
00:34:26.740 --> 00:34:28.570
has to match the name of the source file.

537
00:34:28.610 --> 00:34:29.200
Right.

538
00:34:29.350 --> 00:34:36.220
And what I'm going to do here is that this car is going to have a field int a price, for example,

539
00:34:36.220 --> 00:34:44.710
and I'm going to have a public constructor which takes the int and then the start price equals price.

540
00:34:44.710 --> 00:34:45.220
All right.

541
00:34:45.520 --> 00:34:48.490
And then I'm going to have a two string method.

542
00:34:48.520 --> 00:34:53.260
Let's see if this works source generate to a string.

543
00:34:54.010 --> 00:34:56.620
So we cannot use those features so public.

544
00:34:57.900 --> 00:35:00.110
A string to a string, right?

545
00:35:00.310 --> 00:35:11.480
It doesn't take any parameters and return a car price equals basically a person to have.

546
00:35:12.450 --> 00:35:18.300
A person d for integers and then dot formatted and then a price.

547
00:35:18.330 --> 00:35:21.630
And this dot formatted, I believe was added from JDK 15.

548
00:35:21.630 --> 00:35:23.580
So I'm using JDK 17.

549
00:35:23.580 --> 00:35:24.720
That's totally fine.

550
00:35:25.050 --> 00:35:28.790
If not, you can use a string format, which is a static method.

551
00:35:28.800 --> 00:35:29.370
All right.

552
00:35:30.360 --> 00:35:36.300
So back to Hello World in the main method, what I'm going to do, I am going to now create a car,

553
00:35:36.750 --> 00:35:47.850
object, car, car, new car and pass a price 100 and then do a system dot, dot, print line car.

554
00:35:48.090 --> 00:35:58.440
And we know that this actually calls the two string method to a string method on the car reference.

555
00:35:58.440 --> 00:35:58.950
Right.

556
00:35:58.950 --> 00:36:00.060
Or a variable.

557
00:36:00.990 --> 00:36:06.060
Now let's see how complicated it is to actually get this application to run.

558
00:36:06.060 --> 00:36:09.580
Right now we have two directories, right?

559
00:36:09.580 --> 00:36:13.740
Write test and test two and these two directories have to source files.

560
00:36:13.950 --> 00:36:15.420
Hello, world and car.

561
00:36:15.420 --> 00:36:19.620
And these two source files define public classes.

562
00:36:19.620 --> 00:36:20.010
Right.

563
00:36:20.010 --> 00:36:24.450
And we know that for the public class, the name of the class must match the name of the source file,

564
00:36:24.450 --> 00:36:25.290
which is correct.

565
00:36:25.770 --> 00:36:31.260
None of them belong to any class, any package, which means we don't really need to put them in when

566
00:36:31.260 --> 00:36:32.550
we compile to the class file.

567
00:36:32.550 --> 00:36:37.830
We don't need to put those class files into the directories that correspond to the names of the package.

568
00:36:37.980 --> 00:36:41.670
So these classes don't belong to any package for now.

569
00:36:41.670 --> 00:36:48.060
If they belong to a package, then we have to create directories that have the same names as packages

570
00:36:48.060 --> 00:36:50.640
and then put the class false into those directories.

571
00:36:50.640 --> 00:36:57.570
But for now, for simplicity, I'm just going to basically not add these to any packages.

572
00:36:57.570 --> 00:36:59.520
Now let's see how we're going to launch this.

573
00:37:00.420 --> 00:37:02.730
So first of all, I have to compile the source file.

574
00:37:02.730 --> 00:37:08.190
So I use the Java Sea and note that right now I'm inside the Java Native Image Directory.

575
00:37:09.120 --> 00:37:11.970
I'm going to go to the test and compile the hello world.

576
00:37:12.240 --> 00:37:13.440
And this doesn't work.

577
00:37:13.440 --> 00:37:14.100
Why?

578
00:37:14.130 --> 00:37:20.790
Because this helloworld has a dependency on another type and we know that each type in this case car

579
00:37:21.270 --> 00:37:27.960
compiles to a class file and even at compile time, the JV team needs to understand where this class

580
00:37:27.960 --> 00:37:28.470
file is.

581
00:37:28.470 --> 00:37:28.830
Right.

582
00:37:28.980 --> 00:37:30.660
The Java compiler, not the Java.

583
00:37:31.740 --> 00:37:39.990
So in this case, what we need to do, we need to basically compile the core class first because it

584
00:37:39.990 --> 00:37:46.110
doesn't have any dependency Java C test two and then Java and this compiles fine.

585
00:37:46.110 --> 00:37:48.780
So we get this discard doesn't have any dependency.

586
00:37:48.780 --> 00:37:53.490
So how do we compile this Java hello world that has a type dependency?

587
00:37:53.790 --> 00:37:55.140
So Java C.

588
00:37:57.240 --> 00:37:58.290
What we need to do.

589
00:37:58.290 --> 00:38:04.380
Again, even for the Java compiler, it has to know where to find the types because of the type safety

590
00:38:04.380 --> 00:38:10.620
that the Java provides, which means even at compile time, all the types that you use have to be known

591
00:38:10.620 --> 00:38:11.450
to the compiler.

592
00:38:11.460 --> 00:38:14.670
Otherwise there is no point of allowing allowing the compilation.

593
00:38:14.880 --> 00:38:17.950
And again, you have to specify them on the class path.

594
00:38:17.970 --> 00:38:21.630
So on the class path you tell it, go into the test to write.

595
00:38:21.990 --> 00:38:31.440
And then now this is the class path that the Java compiler can search for in order to see the dependencies

596
00:38:31.440 --> 00:38:32.600
of other classes.

597
00:38:32.610 --> 00:38:34.830
And then now I want to compile this hello world.

598
00:38:34.830 --> 00:38:39.060
So I tell it go to inside the test and then hello world java.

599
00:38:39.570 --> 00:38:45.900
And now this works because when the Java compiler goes to compile this file, which we give it as an

600
00:38:45.900 --> 00:38:49.020
either absolute path or relative path, doesn't matter.

601
00:38:49.470 --> 00:38:52.860
It needs to first understand what this car type is.

602
00:38:52.860 --> 00:38:57.330
And because this car type doesn't belong to any package, so we don't have an import statement.

603
00:38:57.660 --> 00:39:04.950
But then in order for it to understand, the Java compiler needs to first know whether there is a file

604
00:39:04.950 --> 00:39:06.750
called Core Class.

605
00:39:06.750 --> 00:39:09.840
So Java compiler when it tries to compile is helloworld java.

606
00:39:09.870 --> 00:39:17.760
It first needs to make sure that a class file called called court class exists on your hard disk, which

607
00:39:17.760 --> 00:39:24.030
means now you have to go ahead and compile that car java first to create a court class.

608
00:39:25.230 --> 00:39:32.250
And then the next step is that for the Java compiler, if the car class court class file exists, you

609
00:39:32.250 --> 00:39:39.750
have to tell the tell the Java compiler a directory that the Java compiler can search into them to make

610
00:39:39.750 --> 00:39:41.550
sure that that court class exists.

611
00:39:41.550 --> 00:39:42.020
Right.

612
00:39:42.030 --> 00:39:48.060
In order to do that again, you have to specify a specified those directories using the class path.

613
00:39:48.060 --> 00:39:48.600
Right.

614
00:39:49.140 --> 00:39:53.670
So we tell the Java compiler, compile this helloworld java file.

615
00:39:53.700 --> 00:39:59.950
But if it has dependencies, search for dependencies inside this directory, it has to.

616
00:39:59.970 --> 00:40:00.480
All right.

617
00:40:00.480 --> 00:40:09.990
We could do, for example, test two and um, and then for example, test, um, actually the, the

618
00:40:09.990 --> 00:40:13.070
class path separator is in test, right?

619
00:40:13.080 --> 00:40:15.390
We could also do that, that it still works fine.

620
00:40:15.390 --> 00:40:19.470
There is no dependency that the Java compiler needs, which is inside the test.

621
00:40:19.710 --> 00:40:26.880
So we were able to successfully compile our source files which were physically in separate or different

622
00:40:26.880 --> 00:40:28.140
directories on our hard disk.

623
00:40:28.140 --> 00:40:32.610
But because they don't belong to a package, you can compile them directly, right?

624
00:40:33.720 --> 00:40:44.070
Now, if I go and try to if I go inside this test directory, right, that's where my head of all classes

625
00:40:44.070 --> 00:40:50.040
you can definitely guess that if I tries to if I try to execute it, know that it doesn't belong to

626
00:40:50.040 --> 00:40:50.550
any package.

627
00:40:50.550 --> 00:40:52.650
So just you specify the name of the class.

628
00:40:52.650 --> 00:40:53.880
It's not going to work.

629
00:40:54.150 --> 00:40:59.220
It actually works up until hitting this line car, right?

630
00:40:59.220 --> 00:41:04.950
Because these two lines execute because they don't have any dependency.

631
00:41:04.950 --> 00:41:09.090
They only depend on the JDK classes that JVM already knows.

632
00:41:09.090 --> 00:41:13.230
The Java Command already knows where to load them, but then it says there is an exception.

633
00:41:13.230 --> 00:41:20.310
In the no class they found error which says I couldn't find a class file called Core Class because you're

634
00:41:20.310 --> 00:41:24.210
trying to use the new operator to create an object of type car.

635
00:41:24.210 --> 00:41:30.930
But JVM says, I need to first understand what this car is and the way JVM understands that it looks

636
00:41:30.930 --> 00:41:33.900
for a class file, a file called the car class.

637
00:41:33.900 --> 00:41:34.830
It couldn't find it.

638
00:41:35.910 --> 00:41:40.830
So what we need to do, we need to specify another directory that has discarded class.

639
00:41:40.830 --> 00:41:49.680
And you can guess that we do it with the basically with the with the class path or hyphen CP parameter.

640
00:41:50.490 --> 00:41:57.750
And we say that from a current directory which is in the test, go one level up, go to the Java native

641
00:41:57.750 --> 00:42:00.510
image, go to inside the test to right.

642
00:42:00.900 --> 00:42:06.120
That's where you find the discarded class and now we're going to launch our application.

643
00:42:06.120 --> 00:42:12.900
The class file could not find or load the helloworld y because when you specify the class path, you

644
00:42:13.230 --> 00:42:19.470
right now I'm launching this Helloworld event for the Helloworld Java searches inside the class path

645
00:42:19.470 --> 00:42:25.530
directory, so you should always add the current directory if your class is inside the current directory.

646
00:42:25.530 --> 00:42:34.740
So dot colon, which means current directory which has my class file and another directory which goes

647
00:42:34.740 --> 00:42:38.100
to level up with respect to the current directory.

648
00:42:38.100 --> 00:42:40.170
And then it goes inside test two.

649
00:42:40.470 --> 00:42:40.860
All right.

650
00:42:40.860 --> 00:42:43.470
And we shouldn't have any spaces.

651
00:42:43.470 --> 00:42:48.840
So right now there are two directories that are on my on my class path.

652
00:42:48.840 --> 00:42:55.200
One is the current directory Y because my hello world class, which is the entry point to my application

653
00:42:55.200 --> 00:42:58.890
which has the main method is inside the current directory, this test directory.

654
00:42:58.890 --> 00:43:00.330
That's why I specified dot.

655
00:43:00.630 --> 00:43:07.530
But then this helloworld class has a dependency on the car and the car class file class is inside the

656
00:43:07.530 --> 00:43:14.400
test two directory and I specify a relative path from the current directory from the this test which

657
00:43:14.400 --> 00:43:17.940
means go one level up and then go inside the test two directory.

658
00:43:17.940 --> 00:43:24.780
And now my application works fine because at lunchtime JVM can find a class file called Hello World

659
00:43:24.780 --> 00:43:25.470
Class.

660
00:43:25.470 --> 00:43:27.690
It has a main method, it executes that.

661
00:43:27.690 --> 00:43:30.030
And inside that there is another type car.

662
00:43:30.060 --> 00:43:35.820
So JVM can also find a class A file called the court class.

663
00:43:36.120 --> 00:43:39.270
So it can also understand what the car type is.

664
00:43:39.270 --> 00:43:39.810
All right.

665
00:43:40.560 --> 00:43:42.600
So I hope you really enjoy this lecture.

666
00:43:42.600 --> 00:43:46.470
I my goal was to really go into depth of what's going on.

667
00:43:46.470 --> 00:43:51.960
And in the next lectures, when we compiled this Java application to native executable binary, you

668
00:43:51.960 --> 00:43:59.580
see that there is no concept called class path and executing native binaries are easier in terms of

669
00:43:59.580 --> 00:44:03.030
you don't need to deal with kind of class path stuff, right?

670
00:44:03.030 --> 00:44:05.790
So please do stay tuned and I'll see the next one.
