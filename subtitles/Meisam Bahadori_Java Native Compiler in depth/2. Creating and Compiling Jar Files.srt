1
00:00:01,770 --> 00:00:04,380
Hello and welcome to another tutorial.

2
00:00:04,380 --> 00:00:12,510
We're going to continue our discussion with the native image options and one of them is trying to compile

3
00:00:12,510 --> 00:00:14,340
a jar file.

4
00:00:14,340 --> 00:00:20,520
So we saw that first of all, the class path is the most important parameter or flag because the native

5
00:00:20,520 --> 00:00:26,400
image tool, just like the Java JVM, needs to know where all the class files are.

6
00:00:26,700 --> 00:00:31,920
And then after that we said that some of the dependencies could be in the format of a jar file.

7
00:00:31,920 --> 00:00:36,510
Remember, jar is just a compressed directory or a compressed archive.

8
00:00:36,510 --> 00:00:38,760
Right jar stands for Java Archive.

9
00:00:39,090 --> 00:00:46,080
So you typically give the path on your class path, you have the separator which is colon and then give

10
00:00:46,290 --> 00:00:51,750
the path to the directories that contain the patches, packages and class ones.

11
00:00:51,900 --> 00:00:54,920
But then you can also give the full path to the jar files.

12
00:00:54,930 --> 00:00:58,740
Remember, you should also include the name of the jar file and the class path.

13
00:00:58,740 --> 00:00:59,190
Right?

14
00:00:59,940 --> 00:01:02,100
Not the directory that includes the java.

15
00:01:02,100 --> 00:01:06,600
So when you add the jar file to your class path, the name of the jar file must be also included.

16
00:01:06,600 --> 00:01:07,050
Right.

17
00:01:08,190 --> 00:01:11,310
And then this is basically what Maven build tool does.

18
00:01:11,310 --> 00:01:11,580
Right.

19
00:01:11,580 --> 00:01:18,090
So whenever you specify a dependency in your POM file for Maven, Maven just adds that jar file to the

20
00:01:18,090 --> 00:01:18,810
class path.

21
00:01:19,200 --> 00:01:21,870
It downloads jar files and add them to the class path.

22
00:01:21,870 --> 00:01:28,200
If the JAR file obviously already has been downloaded and is available on your local repository, which

23
00:01:28,200 --> 00:01:34,320
is the dot m folder in your home directory, then maven doesn't download it right unless you request

24
00:01:34,320 --> 00:01:35,130
a different version.

25
00:01:35,160 --> 00:01:41,970
For example, this Helloworld Java has a dependency on this jar file util for dash 1.0.

26
00:01:41,970 --> 00:01:43,050
This is the version.

27
00:01:44,040 --> 00:01:52,110
And let's say I have this app app directory that has a helloworld java in it and then there is a lib

28
00:01:52,110 --> 00:01:57,000
directory that I put all my jar files and then add them to the class path right where I try to compile

29
00:01:57,000 --> 00:01:58,230
or run this application.

30
00:01:58,500 --> 00:01:59,370
Note that path.

31
00:01:59,370 --> 00:02:02,760
The Jar file must include the name of the jar file as well.

32
00:02:02,760 --> 00:02:03,120
Right.

33
00:02:03,120 --> 00:02:07,140
Remember, this is very important because JAR is already a compressed directory.

34
00:02:07,140 --> 00:02:08,490
So it's a directory.

35
00:02:08,640 --> 00:02:11,460
So you have to also include the name of that jar file.

36
00:02:12,270 --> 00:02:17,520
Remember jar first are compressed directories and the class files and packages are inside the jar file.

37
00:02:17,550 --> 00:02:21,390
I will show you what inside a jar file would look like.

38
00:02:21,390 --> 00:02:27,000
But then here we're just using this complex which we also use in the previous lecture and then this

39
00:02:27,000 --> 00:02:30,570
complex class, complex number class is inside this forge.

40
00:02:31,710 --> 00:02:38,580
Now, the other thing that you can do is we've seen that you can either run the negative image and give

41
00:02:38,580 --> 00:02:44,910
it a class that has the main method, or you can give the native image a jar, file a complete, complete

42
00:02:44,910 --> 00:02:45,630
jar file.

43
00:02:45,990 --> 00:02:53,340
But then in order to create a executable file from compiling that file, you have to tell the native

44
00:02:53,340 --> 00:02:58,590
image that this jar file, first of all, you have to tell the, Hey, I want to compile this jar file.

45
00:02:58,590 --> 00:03:01,290
So hyphen jar and then the name of the jar file, right?

46
00:03:01,560 --> 00:03:08,820
But then you have to make sure that this jar file is executable, which means it has a manifest file

47
00:03:08,820 --> 00:03:16,290
inside of it, which can at that point the runtime to the main class.

48
00:03:16,290 --> 00:03:16,490
Right.

49
00:03:16,500 --> 00:03:22,680
The class that has the main method and the easiest thing to do to you can usually if you're using Maven,

50
00:03:22,680 --> 00:03:25,260
you can create an executable jar with Maven.

51
00:03:25,260 --> 00:03:26,970
I will show you in the next lecture.

52
00:03:26,970 --> 00:03:30,540
But in this lecture I'm going to just show you how to use your ID.

53
00:03:30,540 --> 00:03:32,160
For example, eclipse ID.

54
00:03:34,730 --> 00:03:37,400
So native image can also compile a jar file.

55
00:03:37,400 --> 00:03:41,380
It must be executable, which means it has a manifest.

56
00:03:41,390 --> 00:03:49,810
If you if you export or create an executable jar with your from your ID, this is an inside the disk

57
00:03:49,910 --> 00:03:51,380
jar file I've created.

58
00:03:51,380 --> 00:03:57,710
I've installed applying for my eclipse ID that allows me to look inside the compressed or zip directories.

59
00:03:57,710 --> 00:04:03,620
Remember jar is just a compressed format, so I recommend you also install this plugin if you're using

60
00:04:03,620 --> 00:04:04,220
eclipse ID.

61
00:04:04,220 --> 00:04:10,010
And inside that you see I have my packages, I have my class files and there is a meter dash enough

62
00:04:10,010 --> 00:04:13,370
and inside that there is a manifest that EMF right.

63
00:04:13,370 --> 00:04:19,250
And inside that it tells me obviously what the version is, what the class path is from the top of this

64
00:04:19,250 --> 00:04:19,790
jar file.

65
00:04:19,790 --> 00:04:21,560
Remember jar is just a directory.

66
00:04:21,740 --> 00:04:29,000
And when you create a jar file with Eclipse, it tells the runtime that hey class path is dot, which

67
00:04:29,000 --> 00:04:34,100
means anything, any directory inside this jar file is a package.

68
00:04:34,100 --> 00:04:40,070
So for example, this class third class as is actually belongs to a package and that package is Java

69
00:04:40,070 --> 00:04:41,120
native image for example.

70
00:04:41,120 --> 00:04:41,600
Right.

71
00:04:41,600 --> 00:04:43,610
And in the main class is Java native image.

72
00:04:43,610 --> 00:04:48,590
This is my package and dirt test class and this is basically the fully qualified name of the class that

73
00:04:48,590 --> 00:04:53,000
has the executable or basically that has the main method.

74
00:04:53,000 --> 00:04:53,390
Right.

75
00:04:53,390 --> 00:05:00,290
And we already know that you can even run a executable jar using the Java Command or the Gvm and I will

76
00:05:00,290 --> 00:05:00,650
show you.

77
00:05:00,650 --> 00:05:02,030
So it's very easy.

78
00:05:02,030 --> 00:05:07,220
And Eclipse ID, you select your Java project, right click and select the export on the Java project.

79
00:05:07,220 --> 00:05:13,220
And then you know that whenever you run a Java class that has a main method, eclipse creates a launch

80
00:05:13,220 --> 00:05:15,380
configuration or run configuration.

81
00:05:15,380 --> 00:05:17,210
So you want to select one of them.

82
00:05:17,690 --> 00:05:24,080
And the properties of that run configuration, the JVM flags, everything is you've already set them

83
00:05:24,080 --> 00:05:26,090
up in that run configuration.

84
00:05:26,090 --> 00:05:29,510
So here you just point this jar utility.

85
00:05:29,520 --> 00:05:33,950
Remember, you have to select the run jar so you can create two types of jars in Eclipse.

86
00:05:33,950 --> 00:05:37,700
One is just a jar file, jar archive or a jar.

87
00:05:37,730 --> 00:05:43,280
When you select the eclipse to create a reasonable jar, it asks you which launch configuration you

88
00:05:43,280 --> 00:05:48,380
want to select, and when you select, whatever that you select, Eclipse knows that class has a main

89
00:05:48,380 --> 00:05:53,900
method, so it belongs to whatever project and Eclipse already avails of everything, already aware

90
00:05:53,990 --> 00:05:59,750
of the class path that is required to run that main class and export destination.

91
00:05:59,750 --> 00:06:05,540
Remember that first of all, you cannot use eclipse internal variables here like project location is

92
00:06:05,540 --> 00:06:07,250
kind of stuff that we saw before.

93
00:06:07,250 --> 00:06:12,200
And then there is a hint here that the export destination will be relative to your workspace.

94
00:06:12,200 --> 00:06:14,390
Remember not the project, the workspace.

95
00:06:14,390 --> 00:06:20,270
So if the project name is java native image I'm using dot, you don't really need to use dot or forward

96
00:06:20,330 --> 00:06:20,590
slash.

97
00:06:20,610 --> 00:06:21,410
Doesn't matter.

98
00:06:21,410 --> 00:06:23,900
It always is relative to your workspace.

99
00:06:24,080 --> 00:06:29,090
So I'm going to set from DOT, which is my workspace, go inside this Java Native Image project, go

100
00:06:29,090 --> 00:06:32,980
inside the jar directory and create a file called My App Jar.

101
00:06:33,200 --> 00:06:38,780
And then the other thing is that because Eclipse is aware of dependencies or the class path, it tells

102
00:06:38,780 --> 00:06:42,200
you what you want to do about library handling or the dependencies.

103
00:06:42,200 --> 00:06:49,580
Obviously, if you want to create a self contained jar or Java archive, which is executable when you

104
00:06:49,580 --> 00:06:54,740
execute it, you have to also have those dependencies on the class path and Eclipse gives you three

105
00:06:54,740 --> 00:06:57,890
options extract required libraries into generate a jar.

106
00:06:57,950 --> 00:07:03,740
So any class that is on a class path from other projects, they will be copied inside your jar file.

107
00:07:04,010 --> 00:07:08,510
So everything, all the dependencies are there and sometimes you don't have the license for the other

108
00:07:08,510 --> 00:07:09,350
libraries, right?

109
00:07:09,350 --> 00:07:12,620
So you have to be careful about licensing this kind of stuff.

110
00:07:12,830 --> 00:07:19,580
Package record labels into the JAR file, which means it doesn't extract the class files, it just copies

111
00:07:19,580 --> 00:07:21,590
the entire project, the entire package.

112
00:07:21,620 --> 00:07:25,910
Let's say there is a package from another jar file and other project that you're only using one of the

113
00:07:25,910 --> 00:07:28,880
classes it doesn't copy only that class.

114
00:07:28,880 --> 00:07:30,440
It copies the entire package.

115
00:07:30,440 --> 00:07:31,250
Everything, right?

116
00:07:31,460 --> 00:07:35,070
Copy record libraries into a sub folder next to generate a jar.

117
00:07:35,090 --> 00:07:41,300
So if there is a jar file, there is a library that you don't have license to use those files to extract

118
00:07:41,300 --> 00:07:42,410
them and put them in your jar.

119
00:07:42,410 --> 00:07:50,900
You have to extract them as separate libraries and then distribute them because you don't own the binaries.

120
00:07:50,900 --> 00:07:53,630
So you have to be careful, right?

121
00:07:53,630 --> 00:07:59,090
So the third option copy required libraries into a sub folder next to generate a jar is a good idea.

122
00:07:59,090 --> 00:08:04,460
Again, if you don't have the license to the binaries so you can't really incorporate them directly

123
00:08:04,460 --> 00:08:05,420
inside your jar file.

124
00:08:05,420 --> 00:08:14,120
So you have to basically you have to basically extract them as the separate jars and eclipse does that

125
00:08:14,120 --> 00:08:14,690
for you.

126
00:08:14,720 --> 00:08:16,370
Now save as anti script.

127
00:08:16,610 --> 00:08:18,200
This is not really necessary.

128
00:08:18,200 --> 00:08:19,310
You don't need to worry about that.

129
00:08:19,310 --> 00:08:24,710
And then you hit finish eclipse creates the jar file and then you can execute it and see everything

130
00:08:24,710 --> 00:08:25,580
works fine.

131
00:08:25,580 --> 00:08:26,570
So let's head to Eclipse.

132
00:08:26,570 --> 00:08:28,700
I'll give you a quick demo of this.

133
00:08:29,680 --> 00:08:32,260
So here we have this Java Native Image project.

134
00:08:32,260 --> 00:08:35,050
There's a package here, test class and we wrote this.

135
00:08:35,050 --> 00:08:37,180
This is something to the standard output.

136
00:08:37,180 --> 00:08:38,980
And then we look at the class path.

137
00:08:38,980 --> 00:08:44,590
We have a dependency on another Java project inside the Eclipse workspace and we have a dependency here

138
00:08:44,590 --> 00:08:54,970
complex on a on a on this jar file util forge and eclipse has a nice view reference dependencies that

139
00:08:54,970 --> 00:08:58,270
tells you which external jars are on your class path.

140
00:08:58,270 --> 00:09:00,370
Right, which is a very nice feature to have.

141
00:09:00,370 --> 00:09:06,670
So what we want to do, we want to first of all, I can run it when I run this, I can successfully

142
00:09:06,670 --> 00:09:07,120
run this.

143
00:09:07,120 --> 00:09:10,540
And whenever you run something, eclipse creates a run configuration.

144
00:09:10,540 --> 00:09:15,670
So if you go here, this test class is what I just used to run.

145
00:09:15,670 --> 00:09:20,680
And for example, it tells you what the main classes arguments you can provide.

146
00:09:21,070 --> 00:09:27,220
Um, basically JVM arguments and Eclipse already provides two arguments here.

147
00:09:27,250 --> 00:09:33,250
Jerry we're using the project executable environment, which is Java C 17 dependencies.

148
00:09:33,340 --> 00:09:34,900
Everything is on the class path.

149
00:09:34,900 --> 00:09:41,680
We have one project and a class path, one jar and also the system libraries on a class path source.

150
00:09:41,680 --> 00:09:50,410
Our source is just the basically the default which is all the Java projects and the Java is from system

151
00:09:50,410 --> 00:09:55,570
environment variables if you need to manually define it, environment variables, the common allocate

152
00:09:55,570 --> 00:09:56,050
console.

153
00:09:56,050 --> 00:10:02,770
These are not really necessary because this is something that only attributes to the console environment

154
00:10:02,770 --> 00:10:04,390
inside eclipse prototype.

155
00:10:04,720 --> 00:10:07,060
This is also not that important for now.

156
00:10:07,060 --> 00:10:13,540
For now, what's important is that you can configure this run configuration by going here, selecting

157
00:10:13,540 --> 00:10:21,340
that run, because every time you run a class eclipse creates a new or basically a run configuration

158
00:10:21,340 --> 00:10:21,940
for that.

159
00:10:21,940 --> 00:10:27,910
And now if I select my project or maybe the package or the Java file doesn't matter, it doesn't matter

160
00:10:27,910 --> 00:10:30,670
where you click, right click and then export.

161
00:10:31,000 --> 00:10:36,160
And in the Java there is a jar file jar file with aspect j support.

162
00:10:36,160 --> 00:10:37,030
This is not important.

163
00:10:37,030 --> 00:10:42,940
That's I have this option because I also installed this aspect but there's jar file and run a jar file.

164
00:10:42,940 --> 00:10:48,310
So if you just want to create a library which is not running but you just want to distribute your class

165
00:10:48,310 --> 00:10:53,710
words, you can use Java, but if you want to create a reasonable jar file, which means a jar file

166
00:10:53,710 --> 00:10:56,560
that can be directly run on the VM gvm.

167
00:10:56,560 --> 00:10:57,790
You have to select this option.

168
00:10:57,790 --> 00:10:58,810
Run a jar file.

169
00:10:59,620 --> 00:11:01,440
And it already recognized this.

170
00:11:01,450 --> 00:11:03,850
This is the last one, this class, which I just ran.

171
00:11:03,850 --> 00:11:04,060
Right?

172
00:11:04,060 --> 00:11:05,590
This is the last configuration.

173
00:11:05,590 --> 00:11:09,940
And it tells me that this export destination, you can browse this.

174
00:11:09,940 --> 00:11:10,480
Right.

175
00:11:10,660 --> 00:11:18,760
And then this has to be with respect or relative to your workspace, right?

176
00:11:18,760 --> 00:11:27,160
So I can say DOT for example, if you want to export Java native image to eclipse recognizes that I

177
00:11:27,160 --> 00:11:33,460
am putting a relative path and when you use a relative path it means relative to the workspace.

178
00:11:33,460 --> 00:11:39,730
So I usually what I do my convention is that to create a directory called jar in the top level of my

179
00:11:39,730 --> 00:11:46,840
Java project and then tell it, let's say my app dot jar, right?

180
00:11:46,840 --> 00:11:49,750
And right now I have some dependencies.

181
00:11:49,750 --> 00:11:55,600
So let's see what each of these options does as extract the library required libraries into the Java

182
00:11:55,630 --> 00:11:56,290
generated jar.

183
00:11:56,290 --> 00:11:57,550
Let's see what happens.

184
00:11:57,550 --> 00:12:02,560
So he'd finish this operation requests repack the reference library.

185
00:12:02,560 --> 00:12:04,990
So Eclipse is giving us a warning.

186
00:12:05,020 --> 00:12:09,760
Please review the licenses associated with libraries you wish to reference to make sure that you are

187
00:12:09,760 --> 00:12:11,770
able to repack them using this application.

188
00:12:11,770 --> 00:12:17,380
What this does is it actually grabs all those class files that inside are the libraries or dependencies

189
00:12:17,380 --> 00:12:19,090
and copies them into our jar file.

190
00:12:19,120 --> 00:12:20,500
It repackages them.

191
00:12:20,500 --> 00:12:23,770
And again, if you don't have the license to them, you have to be careful.

192
00:12:24,520 --> 00:12:26,140
And Eclipse is also warning us.

193
00:12:26,140 --> 00:12:32,050
I have all the licenses jar creation failed a class size and class was not found.

194
00:12:32,860 --> 00:12:34,630
Okay, so let's go.

195
00:12:34,870 --> 00:12:40,990
I think the other project has some compilation issues, so I'm going to remove this car.

196
00:12:42,100 --> 00:12:45,910
All right, let's just run this right now on our class path.

197
00:12:47,110 --> 00:12:48,880
There is being directory here.

198
00:12:49,030 --> 00:12:56,320
I'm going to also go ahead in the build path, configure build path, and I'm going to remove this dependency

199
00:12:56,320 --> 00:12:57,550
on the other project.

200
00:12:57,550 --> 00:12:58,780
So let's run these.

201
00:12:59,640 --> 00:13:02,300
And now we only have a.

202
00:13:03,640 --> 00:13:08,140
So we have a jar file on our class path and it being director of the current project.

203
00:13:08,140 --> 00:13:10,880
So let's delete this privacy jar.

204
00:13:10,960 --> 00:13:16,710
Let's right click export around a jar next and then everything is said.

205
00:13:16,720 --> 00:13:17,710
Java native image.

206
00:13:17,710 --> 00:13:20,890
Remember export destination will be relative to your workspace.

207
00:13:20,890 --> 00:13:25,570
Obviously you can select this browse and choose a absolute path on your file system.

208
00:13:25,570 --> 00:13:25,780
Here.

209
00:13:25,780 --> 00:13:29,980
I want to put it in the work in the work space in my Java project.

210
00:13:29,990 --> 00:13:31,630
So you give it a relative path.

211
00:13:31,750 --> 00:13:32,860
So finish.

212
00:13:33,040 --> 00:13:33,700
Okay.

213
00:13:33,700 --> 00:13:35,950
And then now the jar file was successful.

214
00:13:35,980 --> 00:13:44,200
I have installed this zip archive application, so let me go show you the plugin.

215
00:13:45,250 --> 00:13:46,990
Let's go to the install tab.

216
00:13:49,270 --> 00:13:54,610
So I recommend that if you're using Eclipse, definitely install this plugin Eclipse Zip editor because

217
00:13:54,610 --> 00:14:00,670
it's a very nice thing inside Eclipse, you just double click and opens it up and you can actually edit

218
00:14:00,670 --> 00:14:01,440
anything, right?

219
00:14:01,450 --> 00:14:06,250
For example, this kit ignore, I don't need it, so I just delete it and then save my zip file.

220
00:14:06,280 --> 00:14:07,000
So that's it.

221
00:14:07,000 --> 00:14:11,200
I edited my zip file and then you see, this is our Java project.

222
00:14:11,200 --> 00:14:13,870
Everything else comes from that util forge.

223
00:14:13,900 --> 00:14:20,350
It has some native libraries and then there is a manifest and then Maven or Science Forge.

224
00:14:20,350 --> 00:14:26,260
These are from the dependencies, the files of the other project util forge but there is a manifest

225
00:14:26,270 --> 00:14:30,730
emf and I can actually look at it without even a unzipping.

226
00:14:30,730 --> 00:14:35,410
This this this zip editor plugin for the eclipse is very nice.

227
00:14:36,340 --> 00:14:37,900
All right, so what does this mean?

228
00:14:39,190 --> 00:14:45,610
First of all, this is now a reasonable jar because I have the manifest INF and then manifest EMF tells

229
00:14:45,610 --> 00:14:47,380
the runtime what is the main class?

230
00:14:47,380 --> 00:14:48,970
This this line is very important.

231
00:14:48,970 --> 00:14:52,030
And what is the class path relative to this jar file.

232
00:14:52,030 --> 00:14:52,510
Right.

233
00:14:52,510 --> 00:14:57,340
Which means all these directories java, native image and util forge.

234
00:14:57,370 --> 00:15:01,120
These are the top level packages that the class files are inside.

235
00:15:01,120 --> 00:15:07,180
For example, this array math is actually a type that is part of this array package, which is part

236
00:15:07,180 --> 00:15:08,770
of this forge package.

237
00:15:08,770 --> 00:15:13,180
So the fully qualified name of this type, for example, has two packages and we can see that.

238
00:15:13,180 --> 00:15:16,300
So if I right click open with class file viewer.

239
00:15:16,630 --> 00:15:27,190
Okay, so we cannot we have to basically right now it decompile it so it belongs to this package util

240
00:15:27,190 --> 00:15:28,360
forge array, right?

241
00:15:28,360 --> 00:15:34,210
So the manifest mef, when you export with eclipse, it also gives this option class path so that the

242
00:15:34,210 --> 00:15:38,020
runtime knows which directories are actually the packages.

243
00:15:38,290 --> 00:15:46,000
So if I open up a terminal here, I can actually directly run this jar file and the command is java

244
00:15:46,000 --> 00:15:48,490
hyphen jar and in my app jar.

245
00:15:48,640 --> 00:15:49,240
Right.

246
00:15:49,240 --> 00:15:50,440
So everything works fine.

247
00:15:50,470 --> 00:15:50,680
Hello.

248
00:15:50,680 --> 00:15:52,240
Full from java external tool.

249
00:15:52,240 --> 00:15:54,310
This is this line, the class path.

250
00:15:54,430 --> 00:16:02,380
And again when you run this command hyphen jar, my app jar, what the Java runtime does, it actually

251
00:16:02,380 --> 00:16:07,840
becomes equivalent to Java hyphen C.P.

252
00:16:08,170 --> 00:16:08,800
Right.

253
00:16:08,800 --> 00:16:11,500
And then my app jar.

254
00:16:11,530 --> 00:16:13,810
Now the jar file is on the class path.

255
00:16:13,810 --> 00:16:14,320
Right.

256
00:16:14,320 --> 00:16:22,530
And then we give it the fully qualified name of the main class which is a Java native image dot test

257
00:16:22,540 --> 00:16:23,200
class.

258
00:16:25,410 --> 00:16:26,820
And this is still works, right?

259
00:16:26,820 --> 00:16:31,290
So this Java hyphen jar, my app, the jar is a syntactic sugar.

260
00:16:31,320 --> 00:16:34,860
What happens is this Java Command replaces it with this line.

261
00:16:35,040 --> 00:16:40,710
And we know that in the the reason that this hyphen jar my app jar works because there is a manifest

262
00:16:40,710 --> 00:16:47,880
file inside this jar file which points the Java or the runtime to the fully qualified name of the main

263
00:16:47,880 --> 00:16:49,800
class, the class that has the main method.

264
00:16:49,800 --> 00:16:55,470
But actually when you do this, the jar file is appended added to the class path.

265
00:16:55,470 --> 00:17:02,370
That's why when I'm looking at the class path, obviously it tells me that my app jar is on the class

266
00:17:02,370 --> 00:17:02,790
path.

267
00:17:02,790 --> 00:17:03,330
Right.

268
00:17:03,600 --> 00:17:07,740
And then Java native image, the test test class.

269
00:17:07,740 --> 00:17:07,980
Right.

270
00:17:07,980 --> 00:17:16,620
So this java hyphen jar, my app jar gets translated into Java hyphen, keep my app jar, right.

271
00:17:16,860 --> 00:17:22,320
But then the main because there is a manifest that also has the information about the main class, we

272
00:17:22,320 --> 00:17:23,850
can directly run the jar file.

273
00:17:23,880 --> 00:17:24,270
All right.

274
00:17:24,270 --> 00:17:26,460
I just want you to understand what's going on.

275
00:17:27,240 --> 00:17:27,600
All right?

276
00:17:27,600 --> 00:17:30,810
Now, how do we compile this to a native executable binary?

277
00:17:30,810 --> 00:17:38,790
Because this Java is executable, I can compile a native image hyphen c.p dot.

278
00:17:39,330 --> 00:17:40,380
So again, two options.

279
00:17:40,410 --> 00:17:47,340
Either I put the jar file on my class path and then give the fully qualified name of the main class

280
00:17:47,340 --> 00:17:48,780
inside that jar file.

281
00:17:48,810 --> 00:17:56,400
Or I use the hyphen jar flag my app dot jar and then let's go, let's call it my app underscore native.

282
00:17:56,790 --> 00:18:02,670
So what I'm telling you, the class path is here, but I'm compiling a jar, my jar, and then this

283
00:18:02,670 --> 00:18:12,030
jar has to be executable, which means it should have a manifest file inside of it that tells a which

284
00:18:12,030 --> 00:18:15,270
class is the main class, which class has the main method.

285
00:18:15,270 --> 00:18:17,520
So this way you don't really need to worry about.

286
00:18:17,520 --> 00:18:24,700
I can also basically remove this hyphen zip dot because I'm already inside this jar directory inside

287
00:18:24,700 --> 00:18:25,650
of this jar folder.

288
00:18:25,650 --> 00:18:26,130
Right.

289
00:18:26,370 --> 00:18:30,390
So it makes the, makes the command very simple.

290
00:18:30,390 --> 00:18:36,060
You just tell it, hey, I have a jar file this one and then create a application executable file called

291
00:18:36,060 --> 00:18:37,650
whatever my native image.

292
00:18:37,770 --> 00:18:43,980
So hopefully this works fine because we have the manifest all the dependencies of this class, which

293
00:18:43,980 --> 00:18:47,730
is another jar David directly extracted into this.

294
00:18:47,730 --> 00:18:50,400
So this jar should be self contained.

295
00:18:50,400 --> 00:18:56,130
Again, the reason is that I was able to do it because I had this util forge something that I developed

296
00:18:56,130 --> 00:18:56,670
myself.

297
00:18:56,670 --> 00:19:02,220
So I have the ABC, the licenses and I can repackage it.

298
00:19:04,090 --> 00:19:05,030
So let's look at it.

299
00:19:05,050 --> 00:19:06,710
Everything worked fine so far.

300
00:19:06,730 --> 00:19:16,690
It's compiling and it's going to basically convert our executable jar to a native executable binary.

301
00:19:16,690 --> 00:19:22,480
So let's just quickly check that we can execute this and everything works fine.

302
00:19:22,480 --> 00:19:28,270
Again, we know that when you compile two native executable binaries, there is no concept of class

303
00:19:28,270 --> 00:19:28,540
path.

304
00:19:28,540 --> 00:19:30,550
That's why we're returning nothing.

305
00:19:30,550 --> 00:19:33,220
And then this is the dependency that we had.

306
00:19:33,220 --> 00:19:38,170
It's already contained and we can look at our, for example, the complex number here.

307
00:19:39,490 --> 00:19:45,970
So this is the way that you can directly compile your file like for example, with Maven.

308
00:19:46,990 --> 00:19:52,420
We know that eventually when you build or the artifact is jarred, so then you can directly pass that

309
00:19:52,420 --> 00:20:00,880
jar file to native image in other ways, which we saw was to set up an external tool and then configure

310
00:20:00,970 --> 00:20:05,020
it in a way that a native image gets all the dependencies there.

311
00:20:05,020 --> 00:20:05,500
Right.

312
00:20:08,240 --> 00:20:10,840
So that's the whole idea of the jar files.

313
00:20:10,850 --> 00:20:12,730
It's it's relatively convenient.

314
00:20:12,740 --> 00:20:21,620
You have to make sure that all your jar file is executable and native image has access to all the dependencies.

315
00:20:21,620 --> 00:20:28,940
So I want to do right now, when I exported that jar file, I selected the first option extract required

316
00:20:28,940 --> 00:20:30,560
libraries in to generate a jar.

317
00:20:30,590 --> 00:20:36,050
Let's select the second option package required library into the generated jar and let's look at the

318
00:20:36,050 --> 00:20:36,620
inside.

319
00:20:36,860 --> 00:20:48,920
Now you see that util for j is the entire jar was copied and then the eclipse is eclipse has to add

320
00:20:48,920 --> 00:20:50,600
its own jar loader.

321
00:20:50,600 --> 00:20:56,330
Basically what the eclipse does is it includes its own jar loader and then copies the entire jar.

322
00:20:56,360 --> 00:20:57,350
Now this is a seal.

323
00:20:57,350 --> 00:21:03,200
Okay, so even if you don't have license for this util forge binaries, it's fine.

324
00:21:03,200 --> 00:21:06,530
You can directly copy it into your jar and then that's fine.

325
00:21:06,530 --> 00:21:11,930
So that doesn't violate any licensing because you're not unpacking or accessing the binaries, you just

326
00:21:11,930 --> 00:21:13,250
copying the entire jar.

327
00:21:13,280 --> 00:21:13,730
Right.

328
00:21:13,730 --> 00:21:19,970
And then manifest mfw and now things have changed a little bit because what the eclipse has to do or

329
00:21:19,970 --> 00:21:25,650
tell the runtime, let's say JVM or native image, whatever application that can run executable jar

330
00:21:25,670 --> 00:21:27,680
is that things are a little bit different.

331
00:21:27,680 --> 00:21:32,120
So you have to tell it, this is my package Java native image and this is my main class.

332
00:21:32,120 --> 00:21:35,840
So the first thing is domain class, right?

333
00:21:36,110 --> 00:21:41,420
And in the class path, the top of the jar file, which means everything here has to be on the class

334
00:21:41,420 --> 00:21:41,690
path.

335
00:21:41,690 --> 00:21:44,060
This jar file must be added to the class path.

336
00:21:44,060 --> 00:21:50,450
This directory is a is a directory which is a package because it's on the class path.

337
00:21:50,450 --> 00:21:50,900
Right.

338
00:21:51,170 --> 00:21:58,730
And then what is eclipse also has to add the extra instructions to the manifest so that the runtime

339
00:21:58,730 --> 00:22:02,030
knows that this util forge jar has to be loaded.

340
00:22:02,030 --> 00:22:07,640
And the way it works is that eclipse changes actually the internal main class.

341
00:22:07,640 --> 00:22:14,540
So now this my class test class has been renamed to resource main class and the main class is actually

342
00:22:14,540 --> 00:22:16,880
eclipse's internal jar loader.

343
00:22:17,180 --> 00:22:19,430
So what happens when you run this jar?

344
00:22:19,460 --> 00:22:28,100
It first runs this class, it adds this forward dot from the class path, right for voiceless util for

345
00:22:28,100 --> 00:22:28,580
j.

346
00:22:28,610 --> 00:22:31,190
It adds this entire jar to the class path.

347
00:22:31,280 --> 00:22:36,980
Remember a directory that containing the class path that contains the jar file.

348
00:22:36,980 --> 00:22:42,620
It shouldn't be on the class path at the directory forward slash the jar file the entire the full path

349
00:22:42,620 --> 00:22:46,310
to the jar file, including the name of the jar file should be on the class path.

350
00:22:46,310 --> 00:22:51,770
That's why this main class just makes sure that the current the working directory which is the class

351
00:22:51,770 --> 00:22:57,650
path forward slash util for jar jar is on the class path and then it goes ahead and invokes this main

352
00:22:57,650 --> 00:22:59,540
method, the main or this main class.

353
00:22:59,540 --> 00:22:59,960
Right.

354
00:23:00,230 --> 00:23:08,330
So just eclipse changes a little bit if you copy the entire jar files dependencies into the your extracted

355
00:23:08,330 --> 00:23:13,190
executable jar just because it has to do some stuff behind the scenes.

356
00:23:14,060 --> 00:23:18,920
But let's open a terminal here, make sure that we can actually run this.

357
00:23:18,920 --> 00:23:27,410
So Java hyphen jar, my app jar as you can see it is still works fine and nothing has changed.

358
00:23:27,410 --> 00:23:32,780
So my app jar is still on the class path and then the dependency is there.

359
00:23:32,780 --> 00:23:35,420
But now we didn't actually extract the binaries.

360
00:23:35,420 --> 00:23:38,240
Let's say we didn't have the license for this jar file.

361
00:23:38,240 --> 00:23:44,570
So we can we are we cannot we are not allowed to look inside this Java, but we are still allowed to

362
00:23:44,570 --> 00:23:52,790
copy the entire jar into this for Jar Jar, which is a dependency into our jar and eclipse behind the

363
00:23:52,790 --> 00:23:56,780
scenes changes the manifest EMF to make sure that everything works fine.

364
00:23:56,780 --> 00:24:03,980
But the question is if we do this because right now inside this manifest manifest MFW things have changed.

365
00:24:03,980 --> 00:24:06,740
So the main class is not our test class, right?

366
00:24:06,800 --> 00:24:09,950
It's the eclipses internal jar loaded class.

367
00:24:09,950 --> 00:24:15,500
So does it make a issue for let's close this for the native image.

368
00:24:15,500 --> 00:24:16,310
That's the question.

369
00:24:16,310 --> 00:24:23,540
So let's test it being a native image hyphen jar my app jar and let's see if this works.

370
00:24:26,480 --> 00:24:27,920
So so far, so good.

371
00:24:30,450 --> 00:24:32,970
All right, let's see if everything goes fine.

372
00:24:33,000 --> 00:24:37,290
Remember, the difference here is that the main class is not our class.

373
00:24:37,290 --> 00:24:38,920
It's the eclipses jar.

374
00:24:38,940 --> 00:24:39,990
Loder class.

375
00:24:40,650 --> 00:24:48,900
And so warning reflection method in so this jaw loaded class does some reflection stuff.

376
00:24:52,570 --> 00:24:57,640
Aborting a stand alone image bill due to reflection use without configuration.

377
00:24:58,510 --> 00:25:06,940
So what happens right now is it ran into an issue saying that this jar jar loaded this main class uses

378
00:25:06,940 --> 00:25:07,540
reflection.

379
00:25:07,540 --> 00:25:14,470
And in order to be able to allow reflections for native image to be correct, successfully compiled,

380
00:25:15,400 --> 00:25:17,680
you have to do some other stuff, right?

381
00:25:17,800 --> 00:25:28,000
So as you can see now, the main compilation failed, but then Native Image went into a fallback compilation

382
00:25:28,000 --> 00:25:33,690
which creates an image which requires a JDK to be available on your past environment variable.

383
00:25:33,700 --> 00:25:35,290
So warning image.

384
00:25:35,290 --> 00:25:40,000
My app native is a fallback image that requires a JDK for execution.

385
00:25:40,030 --> 00:25:45,370
If you pass the node fallback, then it should have failed at this line and no other thing would have

386
00:25:45,370 --> 00:25:51,910
happened to suppress fallback image generation and print more details about why fallback image was necessary.

387
00:25:51,940 --> 00:25:59,260
So what happens here is that if I now execute this binary, it is still works.

388
00:25:59,260 --> 00:26:02,110
But now the class path also shows up.

389
00:26:02,110 --> 00:26:07,570
Because what happens behind the scenes, this binary, it actually requires a JDK.

390
00:26:08,020 --> 00:26:13,270
If you don't have a JDK and it's not a standalone binary, it is still used it internally.

391
00:26:13,270 --> 00:26:19,510
This app actually executes the Java hyphen, DHCP, whatever, and then the name of it.

392
00:26:19,560 --> 00:26:20,740
Internally, it does this.

393
00:26:20,740 --> 00:26:23,050
This is not a fully native compilation.

394
00:26:23,170 --> 00:26:25,630
It's called a fallback method, right?

395
00:26:25,630 --> 00:26:27,070
Or a fallback situation.

396
00:26:27,310 --> 00:26:30,490
So in the next lecture, I will show you how to deal with it.

397
00:26:30,940 --> 00:26:37,510
In general, I will have a more detailed lecture on how to deal with reflections, because what this

398
00:26:37,510 --> 00:26:45,070
class, main class, your resource loader uses Java reflection to configure a stuff and it has to call

399
00:26:45,070 --> 00:26:48,310
the main method of this and it does it reflectively.

400
00:26:48,310 --> 00:26:54,490
You know that using Java reflection at runtime you can access the main method, for example, of this

401
00:26:54,490 --> 00:26:57,460
class and invoke it from another class.

402
00:26:57,460 --> 00:26:57,700
Right?

403
00:26:57,700 --> 00:27:05,590
So I will show you how this works and hopefully we will be able to resolve this issue and basically

404
00:27:05,860 --> 00:27:11,290
create a executable file whenever we package the Java files.

405
00:27:12,820 --> 00:27:18,310
Now, the last thing that I want to show you is let's let's try the third option.

406
00:27:18,310 --> 00:27:27,130
Remember, the third option in Eclipse is that instead of packaging everything inside our jar, we just

407
00:27:27,130 --> 00:27:32,590
copied the required dependencies into a directory that the Java is created.

408
00:27:32,590 --> 00:27:33,520
So let's do this.

409
00:27:33,520 --> 00:27:39,100
And now you see it creates my app lib, which means these are the libraries or the dependencies that

410
00:27:39,100 --> 00:27:40,390
this jar file requires.

411
00:27:40,390 --> 00:27:42,670
So now if I open a terminal.

412
00:27:44,590 --> 00:27:51,940
And if I say Java hyphen jar, my app jar, it's going to to succeed.

413
00:27:52,360 --> 00:27:52,990
Right.

414
00:27:53,470 --> 00:27:57,100
And let's see, look at the manifest EMF.

415
00:27:57,370 --> 00:28:01,060
Now manifest that EMF actually changes the class path.

416
00:28:01,060 --> 00:28:03,730
And now there are two directories on the class path.

417
00:28:03,730 --> 00:28:06,640
The current directory, which is the jar inside the jar file.

418
00:28:06,640 --> 00:28:06,820
Right.

419
00:28:06,820 --> 00:28:09,040
This is my package of my application.

420
00:28:09,040 --> 00:28:13,640
But then there is also another directory on my class path which is my app lib.

421
00:28:13,660 --> 00:28:16,960
Obviously from the current working directory and util for jar jar.

422
00:28:16,960 --> 00:28:19,410
So that jar file goes on a class path.

423
00:28:19,420 --> 00:28:20,800
So this is a nicer way.

424
00:28:20,800 --> 00:28:29,510
And now hopefully when this happens, hopefully this now this compilation works.

425
00:28:29,530 --> 00:28:35,920
So let's see, let's see if this works because now inside the manifest that the class path is already

426
00:28:35,920 --> 00:28:36,580
configured.

427
00:28:36,580 --> 00:28:38,800
So hopefully there will be no problem.

428
00:28:39,960 --> 00:28:45,480
Remember, the main class now is still the differences that now the main class is our actual class.

429
00:28:45,480 --> 00:28:48,050
But the class path has two dependencies, right?

430
00:28:48,090 --> 00:28:53,100
The current directory, which is inside the jar file and the other external directory which has all

431
00:28:53,100 --> 00:28:56,580
the dependencies that we might not have the license to it.

432
00:28:57,060 --> 00:28:59,550
And so far the native image is going fine.

433
00:28:59,550 --> 00:29:05,340
And then again, native image when you look, when you do the hyphen jar, my app, the jar, it looks

434
00:29:05,340 --> 00:29:10,890
inside the manifest at MFW and looks at this class path option and then automatically configures the

435
00:29:10,890 --> 00:29:11,430
class path.

436
00:29:11,430 --> 00:29:12,930
So everything worked fine.

437
00:29:12,930 --> 00:29:19,830
We didn't get any message that there was a reflection or something because this main class is exactly

438
00:29:19,830 --> 00:29:21,000
our own main class.

439
00:29:21,000 --> 00:29:28,830
So my app dot native OC my app dot native and it works fine.

440
00:29:28,830 --> 00:29:33,870
There is no class path because this image is a fully is a true native image.

441
00:29:33,870 --> 00:29:38,640
It's not a fallback image which requires a JDK and everything works fine.

442
00:29:39,540 --> 00:29:43,980
Remember when you compile, if you have other dependencies, everything gets compiled.

443
00:29:43,980 --> 00:29:51,990
So you have to see I don't know how the license works because right now the complex class inside, inside

444
00:29:51,990 --> 00:29:57,030
the util forge is fully compiled to native binaries and it's included in our application.

445
00:29:57,030 --> 00:29:57,480
Right.

446
00:29:57,480 --> 00:29:59,220
So I hope you really enjoyed this lecture.

447
00:29:59,220 --> 00:30:07,860
Now have a very solid understanding of how to export a reliable jar in your eclipse ID and then how

448
00:30:07,860 --> 00:30:08,490
to compile it.

449
00:30:08,490 --> 00:30:16,710
I recommend this third option, which is again is it extracts all the dependencies and creates a subdirectory

450
00:30:16,710 --> 00:30:22,620
here which all the jar files there because native image has no problem understanding that because inside

451
00:30:22,620 --> 00:30:26,100
the manifest mfw the class path is already given.

452
00:30:26,130 --> 00:30:32,640
The problem is that you have to make sure you run the native image from exactly where this jar file

453
00:30:32,640 --> 00:30:36,870
is because this class path is relative to where this jar file is.

454
00:30:36,870 --> 00:30:37,380
Right?

455
00:30:38,250 --> 00:30:44,490
And then this dependencies directory is also relative to where this jar file is.

456
00:30:44,490 --> 00:30:49,680
So you have to be careful with the relative path in comparison to the absolute path in this case.

457
00:30:49,680 --> 00:30:52,080
So please stay tuned and I'll see the next one.
