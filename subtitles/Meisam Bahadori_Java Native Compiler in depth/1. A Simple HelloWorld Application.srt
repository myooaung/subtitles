1
00:00:01,610 --> 00:00:03,710
Hello and welcome to another tutorial.

2
00:00:03,710 --> 00:00:08,290
We're going to continue our discussion on Native Image Tool from VMM.

3
00:00:08,300 --> 00:00:14,120
So far we've looked at the default toolchain of different platforms because those are the prerequisites

4
00:00:14,120 --> 00:00:18,860
of compiling a Java application to a native binary using native image tool.

5
00:00:18,860 --> 00:00:24,860
And then we saw also how to install crawl VM, how to download it, install it, and then use the Google

6
00:00:24,860 --> 00:00:30,770
Updater to install Native Image tool on different platforms Mac OS, Linux and Windows.

7
00:00:30,890 --> 00:00:37,880
And now I'm going to just bring up a few notes from the official website of the Native Image Tool,

8
00:00:38,030 --> 00:00:44,480
and there is also a very interesting website, medium.com grad beam using quad beam and native image

9
00:00:44,480 --> 00:00:48,470
on windows and it again walks you through the steps that I also mentioned.

10
00:00:48,470 --> 00:00:58,880
So if you want to learn more or details, then you can also always visit this image, this online website,

11
00:00:59,000 --> 00:01:01,550
some notes from the official Native Image website.

12
00:01:01,550 --> 00:01:05,900
This is from the Google VM website prerequisites for using Native Image on Windows.

13
00:01:06,050 --> 00:01:12,560
So to start using native image on Windows, install Visual Studio and Microsoft Visual Compiler, right?

14
00:01:12,560 --> 00:01:13,850
MSK and Visa.

15
00:01:13,880 --> 00:01:15,320
I showed you how to do it.

16
00:01:15,530 --> 00:01:21,950
Now the thing here is that the native image, especially on Windows, only works for the default toolchain

17
00:01:21,950 --> 00:01:23,930
of the Windows platform, which is MSK.

18
00:01:23,930 --> 00:01:32,240
So really you really don't have much option of using other open source compilers like GCP at this point,

19
00:01:32,240 --> 00:01:35,150
I'm not really sure that it's even possible to use those.

20
00:01:35,300 --> 00:01:43,190
For example, GCP build toolchain with native image on windows, but for now the easiest thing to do

21
00:01:43,190 --> 00:01:44,000
is SVC.

22
00:01:44,000 --> 00:01:49,940
And when you run native image on Windows which I will show you, it searches for CL or command line

23
00:01:50,870 --> 00:01:54,980
command select x, which is the MSC compiler and terminal.

24
00:01:54,980 --> 00:01:59,870
And I showed you that you have to ensure that when you run the terminal and run the native image in

25
00:01:59,870 --> 00:02:08,810
the terminal, the path environment variable already sets up so that all the all the directories that

26
00:02:08,810 --> 00:02:14,060
are from MSC are already on the path so that the compiler has no problem finding, for example, the

27
00:02:14,060 --> 00:02:17,960
header files or other build tools required to compile a application.

28
00:02:17,960 --> 00:02:18,350
Right.

29
00:02:18,440 --> 00:02:26,630
And I told you that it's best to define a few environment variables on on Windows so that you can quickly

30
00:02:26,630 --> 00:02:29,930
set up the path and then call the native image from terminal.

31
00:02:30,140 --> 00:02:33,530
So there are two installation options for the native image on Windows.

32
00:02:33,530 --> 00:02:38,060
Install the Visual Studio, build tools with the Windows ten SDK.

33
00:02:38,060 --> 00:02:39,590
And this is what I showed you.

34
00:02:41,730 --> 00:02:45,690
Install Visual Studio with the Windows ten SDK.

35
00:02:45,690 --> 00:02:50,550
So this is basically the full IDE, the full IDE, and that's what I downloaded.

36
00:02:50,550 --> 00:02:54,840
But you don't really need to also install the ID, you can only use the bell tools.

37
00:02:54,840 --> 00:02:56,460
And that's very similar to Mac OS.

38
00:02:56,460 --> 00:02:56,730
Right.

39
00:02:56,730 --> 00:03:01,010
We said that Xcode, you can download the entire application, it's like ten gigabytes.

40
00:03:01,010 --> 00:03:02,220
It's a very large application.

41
00:03:02,220 --> 00:03:07,620
It has a full, full featured ID, but you don't really need that on macOS.

42
00:03:07,620 --> 00:03:12,410
You just can install the command line tools, which are the build tools for the Mac OS.

43
00:03:12,420 --> 00:03:13,230
Same with Windows.

44
00:03:13,230 --> 00:03:17,220
You can also just download and install Visual Studio build tools, right?

45
00:03:17,520 --> 00:03:22,320
So you can use Visual Studio 2017 version 15.9 or later.

46
00:03:22,320 --> 00:03:29,340
And in my tutorial, I use the Visual Studio Community Edition 2022.

47
00:03:29,340 --> 00:03:29,640
Right?

48
00:03:29,640 --> 00:03:35,130
So I'm going to write down a community edition because that's the free edition.

49
00:03:35,130 --> 00:03:41,010
And obviously every platform must provide its own free build tools, otherwise nobody would be able

50
00:03:41,010 --> 00:03:43,470
to write, write applications.

51
00:03:43,470 --> 00:03:52,050
And so lastly on Windows, the native image builder will only work when it is executed from the x 64

52
00:03:52,050 --> 00:03:53,370
Native Tool Command.

53
00:03:53,880 --> 00:04:00,600
And we saw that in order to do that, you want to go back and set up the path environment variable.

54
00:04:00,600 --> 00:04:01,940
You go to the MSI.

55
00:04:01,950 --> 00:04:07,140
AVC Right, Microsoft Visual Studio Community VC, which is the Visual Compiler Auxiliary and in the

56
00:04:07,140 --> 00:04:08,160
bell directory.

57
00:04:08,160 --> 00:04:13,320
And there are different command line scripts that you can execute them in terminal, and then it correctly

58
00:04:13,320 --> 00:04:17,880
sets up the path environment variable for the build that you want to do.

59
00:04:17,880 --> 00:04:24,990
And we said that we see was 64 is the one that we want to use on a 64 bit platform and it correctly

60
00:04:24,990 --> 00:04:28,500
sets up the, the environment variables.

61
00:04:28,500 --> 00:04:34,890
And I also show you that it's best to actually define an environment variable that points to this file.

62
00:04:34,890 --> 00:04:39,420
And then whenever you type that environment variable and hit enter in terminal, it automatically executes

63
00:04:39,420 --> 00:04:41,960
the script and sets up the path environment variable.

64
00:04:43,260 --> 00:04:43,620
All right.

65
00:04:43,620 --> 00:04:44,370
So.

66
00:04:46,010 --> 00:04:48,410
These are the nodes on the native image.

67
00:04:48,410 --> 00:04:55,790
And again, your main option on windows is to use use the default toolchain, which is the RMS we see.

68
00:04:55,790 --> 00:05:00,620
So native image only mainly searches for this compiler.

69
00:05:00,650 --> 00:05:08,360
Select the command for initiating and 64 Native Tools Command prompt is different if you only have the

70
00:05:08,360 --> 00:05:13,970
Visual Studio tools to install versus if you have the full voice studio installed.

71
00:05:14,000 --> 00:05:16,250
Check this link for a step by step instructions.

72
00:05:16,250 --> 00:05:22,880
And this link is basically pointing to this website medium.com called VM using grab VM and native image

73
00:05:22,880 --> 00:05:23,360
on Windows.

74
00:05:23,360 --> 00:05:23,540
Right.

75
00:05:23,540 --> 00:05:24,530
So you can check this out.

76
00:05:24,530 --> 00:05:30,290
And again, but again, it's I showed you all the steps you have to go ahead and download the Visual

77
00:05:30,290 --> 00:05:35,900
Studio and then you have to set up the past environment where we're correctly by executing one of these

78
00:05:35,900 --> 00:05:42,770
scripts and it automatically adds a lot of directories to the path so that the command clicked exit

79
00:05:42,770 --> 00:05:49,100
can work fine on your terminal, and after that you can go ahead and create a hello world application

80
00:05:49,100 --> 00:05:55,190
and then execute it to make sure that the native image works fine on your Windows platform.

81
00:05:55,190 --> 00:05:57,320
And that's what I'm going to show you next.

82
00:05:57,320 --> 00:06:02,330
So basically so far we've set up the default tool chains of different platforms.

83
00:06:02,360 --> 00:06:04,700
We download it and install the native image.

84
00:06:04,700 --> 00:06:09,980
We made sure that it works fine on all three platforms and now we want to start learning about Native

85
00:06:09,980 --> 00:06:10,310
Image.

86
00:06:10,310 --> 00:06:14,240
What is it so or essentially what is Native Image?

87
00:06:14,240 --> 00:06:16,730
As I mentioned before, it's a compiler.

88
00:06:16,730 --> 00:06:23,840
It's a tool that compiles your Java application to a native executable binary that includes actually

89
00:06:24,470 --> 00:06:29,840
having a compiled version of the JVM, a very compact version of the JVM garbage collector.

90
00:06:29,840 --> 00:06:34,010
All the pieces that the Java application requires to successfully run, right?

91
00:06:35,020 --> 00:06:42,190
But because everything gets compiled to a native binary using using a static compilation instead of

92
00:06:42,940 --> 00:06:44,890
instead of running on JVM, right?

93
00:06:44,920 --> 00:06:50,920
With the operating system takes full control or full responsibility of running your application after

94
00:06:50,920 --> 00:06:53,170
the compilation because there is no JVM, right?

95
00:06:53,500 --> 00:07:01,030
So VM native image building tool, this tool can be used to generate an image that contains ahead of

96
00:07:01,030 --> 00:07:02,560
time compiled Java code.

97
00:07:02,590 --> 00:07:09,340
Now Ahead of Time compilation is a fancy word for saying that we are aesthetically compiling to the

98
00:07:09,340 --> 00:07:10,960
native executable binary.

99
00:07:10,960 --> 00:07:11,380
Right.

100
00:07:11,380 --> 00:07:17,860
And again, to refresh your memory Java compilation or the Java, the job of the Java compiler is to

101
00:07:17,860 --> 00:07:20,680
compile to an intermediate level binary.

102
00:07:20,980 --> 00:07:25,720
It's a binary that the CPU doesn't understand, the operating system doesn't understand, but the Java

103
00:07:25,750 --> 00:07:26,740
understands that.

104
00:07:26,920 --> 00:07:34,600
So when you launch your Java application using Java, JVM loads the class files, which are the binaries

105
00:07:34,600 --> 00:07:36,010
that the JVM understands.

106
00:07:36,100 --> 00:07:40,840
And then after JVM understands your class files, it tells the operating system what to do.

107
00:07:40,840 --> 00:07:46,720
So the Java sits between you and the operating system, and the operating system sits between you and

108
00:07:46,720 --> 00:07:47,710
the hardware, right?

109
00:07:47,740 --> 00:07:53,170
There are some tasks that you want to ask the harbour to do in your job application, and there are

110
00:07:53,170 --> 00:07:56,720
some other tasks that you're not concerned with the hardware.

111
00:07:56,770 --> 00:08:00,670
You just want to talk to the operating system, for example, terminal.

112
00:08:00,670 --> 00:08:04,720
If you want to bring something to the terminal, you don't talk to the hardware, right?

113
00:08:04,720 --> 00:08:07,870
You don't care about the hard disk or the RAM or anything, right?

114
00:08:07,870 --> 00:08:09,670
And it's not an IO operation.

115
00:08:09,670 --> 00:08:14,920
It's just telling the terminal, hey, turning the operating system, hey, print this line to the terminal.

116
00:08:14,920 --> 00:08:15,270
Right?

117
00:08:15,280 --> 00:08:22,450
So whenever you launch an application in in your operating system, the operating system has to allocate

118
00:08:22,450 --> 00:08:25,120
some OS resources or operating system resources.

119
00:08:25,120 --> 00:08:25,360
Right.

120
00:08:25,360 --> 00:08:27,580
And one of the resources is always terminal.

121
00:08:27,580 --> 00:08:35,650
So your application always has IO streams like input streams so that the user can give some feedback

122
00:08:35,650 --> 00:08:37,540
or the commands to your application.

123
00:08:37,540 --> 00:08:43,330
And again, the output stream is when the application can print something to the console, right?

124
00:08:43,360 --> 00:08:45,550
These are not directly related to the hardware.

125
00:08:45,550 --> 00:08:50,890
These are just some resources that the operating system has and it allocates to your application.

126
00:08:51,910 --> 00:08:53,890
And how do we use this native command?

127
00:08:53,890 --> 00:08:58,320
And again, when you open up a terminal, we said that you can either a.

128
00:09:00,010 --> 00:09:06,370
You can either add graph LLVM being directory to the path environment variable so you can just type

129
00:09:06,370 --> 00:09:07,420
native image.

130
00:09:07,540 --> 00:09:15,340
But I didn't do that on Mac or on my on my Mac OS because I want to make sure that when I type Java,

131
00:09:15,340 --> 00:09:19,440
it comes from my JDK 17 that I downloaded from Oracle.

132
00:09:19,450 --> 00:09:19,870
Right?

133
00:09:19,870 --> 00:09:29,860
So if you append a bean environment being directory of the VM to the to the path, the Java comes from

134
00:09:29,860 --> 00:09:34,660
that because Google Beam also includes a JDK, which is an open JDK build.

135
00:09:34,660 --> 00:09:35,860
So I didn't want to do that.

136
00:09:35,860 --> 00:09:43,870
So I define the crawl home and then bean and then a native image, right hyphen, hyphen version.

137
00:09:43,870 --> 00:09:52,330
And we installed the latest version as of this day, which is 20 2.1.0, and it's built based on the

138
00:09:52,330 --> 00:09:53,650
open JDK 17.

139
00:09:53,650 --> 00:09:58,420
And as I mentioned in the Bing directory, there is a Java or Java.

140
00:09:58,450 --> 00:10:01,180
See these are the open JDK versions, right?

141
00:10:01,180 --> 00:10:02,560
Open JDK 17.

142
00:10:03,580 --> 00:10:11,290
But I want on my command line to have the Oracle JDK as my Java application, right?

143
00:10:11,290 --> 00:10:15,160
So just be careful which Java you use.

144
00:10:15,160 --> 00:10:19,630
I always recommend whenever you want to execute Java C or Java first check the version.

145
00:10:19,630 --> 00:10:26,050
So say Java C, hyphen, hyphen version and it tells me Java 17 and Java hyphen hyphen version.

146
00:10:26,050 --> 00:10:28,470
It tells you which JDK it's using, right?

147
00:10:28,480 --> 00:10:33,100
Which JDK the terminal is finding on the path environment.

148
00:10:33,940 --> 00:10:40,950
So you're saying native image options just like any other executable application, any application by

149
00:10:41,140 --> 00:10:46,960
application, take some options or command line arguments and then the name of the class that has the

150
00:10:46,960 --> 00:10:47,680
main method, right?

151
00:10:47,680 --> 00:10:53,620
The class that is entry point to your application and again it's the class file and then you don't include

152
00:10:53,620 --> 00:10:57,400
the dart class extension, you just tell the name of the class.

153
00:10:57,400 --> 00:11:00,970
If it's inside a package, then you have to provide the fully qualified name.

154
00:11:00,970 --> 00:11:04,000
So this class is actually the fully qualified name.

155
00:11:04,480 --> 00:11:09,250
And then you want to tell a native what should be the name of the output binary.

156
00:11:09,250 --> 00:11:16,120
And we know that when we compile a C++ application, we can say hyphen o, which is which means and

157
00:11:16,120 --> 00:11:17,140
then some name, right?

158
00:11:17,140 --> 00:11:23,290
And then the output is going to be named this name that you specify for the compiler.

159
00:11:23,290 --> 00:11:24,910
Same with native image.

160
00:11:25,330 --> 00:11:32,080
You can after you tell it, which class file is the entry point to your application, then you can tell

161
00:11:32,080 --> 00:11:35,050
it the first of all, what's the name of the output is?

162
00:11:35,050 --> 00:11:41,050
And this name can actually be a full path or relative path to the output, which means you can say native

163
00:11:41,050 --> 00:11:42,190
image, right?

164
00:11:42,190 --> 00:11:44,350
And then my main class.

165
00:11:44,350 --> 00:11:52,510
Right, and then you can say for example, put it in a directory called test a relative to this current

166
00:11:52,510 --> 00:11:56,260
working directory and then name it my underscore app.

167
00:11:56,260 --> 00:11:56,740
Right.

168
00:11:56,860 --> 00:12:02,740
So what this does is that if this directory doesn't exist, then the native image actually creates this

169
00:12:02,740 --> 00:12:05,950
directory and then it compiles your main class and puts it.

170
00:12:06,130 --> 00:12:10,210
And then the name of the application is going to be whatever you specify here.

171
00:12:10,210 --> 00:12:16,120
My underscore app in this case and after the compilation Native Image creates this directory and puts

172
00:12:16,120 --> 00:12:19,720
this the application with this name inside this directory.

173
00:12:19,720 --> 00:12:20,170
Right.

174
00:12:20,260 --> 00:12:24,190
So if the directory doesn't exist, native image creates that.

175
00:12:25,270 --> 00:12:29,790
Now, one of the main options here for the native image, as I mentioned, is the class path.

176
00:12:30,040 --> 00:12:34,930
That's the most important parameter when you deal with any job application.

177
00:12:34,960 --> 00:12:36,260
Same with native image.

178
00:12:36,280 --> 00:12:39,340
Native image in order to compile the main class.

179
00:12:39,370 --> 00:12:44,830
Obviously, if your main class has some dependencies on other classes other types, then native image

180
00:12:44,830 --> 00:12:46,840
should be able to find all those classes.

181
00:12:46,840 --> 00:12:47,320
Right.

182
00:12:47,410 --> 00:12:49,690
Remember, Native Image is not a java compiler.

183
00:12:49,690 --> 00:12:56,590
It's a compiler that takes all the class files necessary for your running your job application and builds

184
00:12:56,590 --> 00:12:59,350
a native image and native executable binary.

185
00:12:59,380 --> 00:13:04,870
Now later, we will see that you can actually also create libraries like static or dynamic libraries

186
00:13:04,870 --> 00:13:08,350
that you can then, for example, use in other applications.

187
00:13:08,350 --> 00:13:14,440
So it's not necessarily a it's not you don't have to just create an executable binary, but that's the

188
00:13:14,440 --> 00:13:18,750
most useful way of using native image, right?

189
00:13:18,760 --> 00:13:20,470
You write your job application.

190
00:13:20,470 --> 00:13:25,750
Developing, compiling and maintaining a Java application is much easier and much faster than developing

191
00:13:25,750 --> 00:13:30,660
a C++ application, especially in a huge project, a C plus.

192
00:13:30,670 --> 00:13:33,850
Compiling a C++ application will take a long time.

193
00:13:34,150 --> 00:13:41,260
And the reason is that you might not be familiar with how C++ compiler works, but every CP file has

194
00:13:41,260 --> 00:13:42,820
to include all the other files.

195
00:13:42,820 --> 00:13:43,360
Right?

196
00:13:43,390 --> 00:13:49,540
Let's say if you write a CP just helloworld and then include EOS Stream, the preprocessor copies all

197
00:13:49,540 --> 00:13:55,920
those code in the iOS stream into your current CP and then the compiler compiles the entire thing right.

198
00:13:55,930 --> 00:14:03,640
And then if you have a lot of these includes, then it takes a very long time and resources write CPU

199
00:14:03,640 --> 00:14:04,810
resources to compile.

200
00:14:05,560 --> 00:14:12,850
Whereas in Java we know that import statements have virtually no effect on your class files.

201
00:14:12,850 --> 00:14:13,200
Right?

202
00:14:13,210 --> 00:14:15,640
Every class in Java gets compiled to a class file.

203
00:14:15,640 --> 00:14:20,300
Import statements are not basically written in the class files.

204
00:14:20,500 --> 00:14:22,810
They they don't include any extra code.

205
00:14:22,840 --> 00:14:26,830
Instead, they get translated into the fully qualified name of your types.

206
00:14:26,830 --> 00:14:31,600
And then at runtime the gvm has to be able to locate those fully qualified.

207
00:14:31,900 --> 00:14:33,190
Same with native image.

208
00:14:33,190 --> 00:14:33,520
Right.

209
00:14:33,520 --> 00:14:35,820
Again, import the statements in your class files.

210
00:14:35,830 --> 00:14:44,290
Doesn't do anything but then native image and relies on the class path argument to find all the dependencies

211
00:14:44,290 --> 00:14:45,820
of your application.

212
00:14:45,820 --> 00:14:46,300
Right.

213
00:14:46,990 --> 00:14:53,830
So not only you can compile a main class that has the main method, you can also entire a jar file.

214
00:14:53,920 --> 00:14:59,320
You can compile a jar file using hyphen jar arguments and then jar file.

215
00:14:59,410 --> 00:15:03,250
And you have to be careful that this jar file has to be executable.

216
00:15:03,250 --> 00:15:09,970
And in order to make a jar file executable, you have to have the manifest dot inside of it.

217
00:15:09,970 --> 00:15:16,450
And then the manifest that MAF has, the information about which class is the main class, which class

218
00:15:16,450 --> 00:15:20,440
has the main method or which class is the entry point to your job application.

219
00:15:20,440 --> 00:15:28,180
And I will have examples in the future lectures on how to make a jar file or how to make an executable

220
00:15:28,180 --> 00:15:30,400
jar, and then how to compile it with a native image.

221
00:15:30,400 --> 00:15:30,790
Right.

222
00:15:31,480 --> 00:15:31,810
All right.

223
00:15:31,810 --> 00:15:33,070
So what are these options?

224
00:15:33,070 --> 00:15:34,450
So we have two options here.

225
00:15:34,450 --> 00:15:35,800
One of them is in orange.

226
00:15:35,800 --> 00:15:37,030
One of them is green.

227
00:15:37,660 --> 00:15:40,270
For now, I'm going to look at a few.

228
00:15:40,270 --> 00:15:45,790
This is not the all the options here, but a few of the orange options, options that you give to the

229
00:15:45,790 --> 00:15:46,570
native image.

230
00:15:46,570 --> 00:15:51,610
When you're compiling the application, obviously you can tell that the most important one is the class

231
00:15:51,610 --> 00:15:58,960
path, which you can type it in three ways hyphen XRP, hyphen class path hyphen, hyphen class hyphen

232
00:15:58,960 --> 00:15:59,350
path.

233
00:15:59,350 --> 00:15:59,830
Right.

234
00:16:00,070 --> 00:16:05,980
So if you want to keep this hyphen, you have to use two double hyphens here so that the native image

235
00:16:05,980 --> 00:16:06,850
understands that.

236
00:16:06,850 --> 00:16:08,800
I mean, my favorite is Hyphen XRP.

237
00:16:08,830 --> 00:16:10,060
It's very concise.

238
00:16:10,480 --> 00:16:15,400
And then the class path separator is a colon on any platforms.

239
00:16:15,940 --> 00:16:17,770
Windows, Mac, OS, Linux doesn't matter.

240
00:16:17,800 --> 00:16:21,700
Java always uses a colon for the class path separator.

241
00:16:21,700 --> 00:16:27,400
What this means is that you can have multiple directories on your class path and you separate them with

242
00:16:27,400 --> 00:16:28,270
call it, right?

243
00:16:29,530 --> 00:16:35,920
So any of these can be used with a colon seperated list of directories, jar files, so you can even

244
00:16:35,920 --> 00:16:42,430
point to the jar files because jars are like a compressed archive and the JVM or the native image,

245
00:16:42,430 --> 00:16:47,760
they know how to and archive these, decompress it and access all the class files inside of it.

246
00:16:47,770 --> 00:16:53,980
So not only directory is jar files or even zip archives, the compress archives like zip.

247
00:16:53,980 --> 00:16:55,060
It also works fine.

248
00:16:55,060 --> 00:17:02,830
Native Image knows how to access the class files inside that note that this zip archive shouldn't include

249
00:17:02,830 --> 00:17:03,730
Java source code.

250
00:17:03,880 --> 00:17:07,990
It should include classifies or a compiled java source code.

251
00:17:07,990 --> 00:17:08,380
Right.

252
00:17:08,410 --> 00:17:14,800
Native image works with the class files just like the java works with the class files and then hyphen

253
00:17:14,800 --> 00:17:17,800
D name equal value a set of system properties.

254
00:17:17,800 --> 00:17:23,980
We've already seen these and these are the system properties that is that basically past.

255
00:17:24,050 --> 00:17:30,110
The JV team write again when Native Image compiles your application, it actually has a compiled version

256
00:17:30,110 --> 00:17:30,740
of the JVM.

257
00:17:30,740 --> 00:17:37,580
It's a compact version, hyphen j flag pass a flag directory to the JV team so directly to the JV and

258
00:17:37,590 --> 00:17:39,080
running image generators.

259
00:17:39,080 --> 00:17:46,070
So these flags are like we know that, for example, you can set how much memory is the initial memory,

260
00:17:46,070 --> 00:17:46,340
right?

261
00:17:46,340 --> 00:17:53,780
So hyphen x x flags or for example, hyphen a boolean flag is like print GC, for example.

262
00:17:53,810 --> 00:17:58,340
This is something that you can see the details of the GC.

263
00:17:58,340 --> 00:18:04,220
So these are JV flags and I believe you can pass them with this argument.

264
00:18:04,220 --> 00:18:12,500
We will look at this later and see if this works or not, but for now, hyphen X or hyphen x, these

265
00:18:12,500 --> 00:18:15,680
are usually the JV and flags that you use.

266
00:18:16,100 --> 00:18:18,350
Hyphen oh is the optimisation level.

267
00:18:18,350 --> 00:18:26,750
As I mentioned, the native image does a static compilation and if you say hyphen o zero, it means

268
00:18:26,750 --> 00:18:31,910
no optimization and one means a basic optimization default, right?

269
00:18:31,910 --> 00:18:38,330
So usually in C++ you can also have these flags, for example, GC, G Plus, plus, and then the name

270
00:18:38,330 --> 00:18:42,320
of your CP and then a hyphen or for example, three.

271
00:18:42,320 --> 00:18:49,070
I believe the C++ compilers have three levels of optimisation, zero hyphen or zero hyphen oh one,

272
00:18:49,070 --> 00:18:53,900
hyphen oh two and hyphen oh three and same here.

273
00:18:53,900 --> 00:18:58,670
Here you only have two choices hyphen o zero, hyphen or one, which is the default.

274
00:18:58,670 --> 00:19:05,840
So if you don't specify any optimization level, the native image already uses the most optimized version.

275
00:19:05,840 --> 00:19:12,890
Right hyphen hyphen verbose, enable, verbose output, hyphen, hyphen, virgin print, product version

276
00:19:12,890 --> 00:19:13,490
and x ID.

277
00:19:13,490 --> 00:19:15,560
And that's what we've been using, right?

278
00:19:15,560 --> 00:19:24,860
So if we say crawl VM, crawl home, bing, and then native image and then in for this orange option,

279
00:19:24,860 --> 00:19:26,750
I'm going to tell it hyphen, hyphen, version.

280
00:19:26,750 --> 00:19:29,540
This prints the version and then exits the application.

281
00:19:29,540 --> 00:19:30,650
It doesn't continue.

282
00:19:30,800 --> 00:19:31,450
So grow.

283
00:19:31,490 --> 00:19:37,890
LLVM 20 2.1.0 Java 17 come into edition and then we exit the application, right?

284
00:19:37,910 --> 00:19:39,260
We go back to the terminal.

285
00:19:40,460 --> 00:19:40,820
All right.

286
00:19:40,820 --> 00:19:45,560
So a hello world, a native image in window in MapQuest.

287
00:19:45,590 --> 00:19:50,540
We've already seen this many times, but now let's have a closer look.

288
00:19:50,540 --> 00:19:57,860
You create a Helloworld Java compiler, compiler with any Java See compiler, which is version 17 because

289
00:19:57,860 --> 00:20:04,550
we're using LLVM 17, you have to use a compiler that is at least 17, I believe.

290
00:20:04,760 --> 00:20:10,640
I mean it's best to have the exact match so you can either use the Java Sea that comes with the LLVM

291
00:20:10,640 --> 00:20:14,570
or you can use the Java Sea that comes with the Oracle JDK 17.

292
00:20:14,570 --> 00:20:21,470
They are compatible run native image tool and the class file and then you omit the class, right?

293
00:20:21,470 --> 00:20:24,830
Just like when you launch a Java application using JVM.

294
00:20:24,860 --> 00:20:28,010
So don't use the don't use the DOT class extension.

295
00:20:29,000 --> 00:20:30,500
So here's a quick example.

296
00:20:30,500 --> 00:20:34,760
So public class helloworld and public say vote main is the string args.

297
00:20:34,760 --> 00:20:38,060
System.out.println helloworld from native image.

298
00:20:38,240 --> 00:20:39,800
This is our java source code.

299
00:20:39,800 --> 00:20:48,920
And then here in my terminal I use the Java Sea from google vm growler home being java c helloworld

300
00:20:49,040 --> 00:20:49,670
java.

301
00:20:49,910 --> 00:20:55,390
Note that I'm in the same directory that this Java source code is, so I don't need to specify hyphen

302
00:20:55,400 --> 00:21:02,510
CPP and give it the directories for the class path and then a girl home being Java C hyphen version.

303
00:21:02,510 --> 00:21:06,680
I'm using Java C 17 and after I compile to the class file.

304
00:21:06,710 --> 00:21:07,940
Hello world class.

305
00:21:07,940 --> 00:21:08,840
I just tell it.

306
00:21:08,840 --> 00:21:11,090
Crawl home being native image.

307
00:21:11,120 --> 00:21:11,900
Hello world.

308
00:21:11,900 --> 00:21:19,670
And I'm omitting the dot class extension and the compilation goes through and then it creates the Hello

309
00:21:19,670 --> 00:21:20,600
World application.

310
00:21:20,600 --> 00:21:27,080
Note that I'm not specifying the name of the output file and then by default, if you don't specify

311
00:21:27,080 --> 00:21:34,160
the name of the output application output executable, it's going to use the name of your class main

312
00:21:34,160 --> 00:21:35,540
class, the class that has made.

313
00:21:35,540 --> 00:21:37,700
But all the letters are lowercase.

314
00:21:37,700 --> 00:21:40,850
That's why you see that the output application is Hello world.

315
00:21:41,030 --> 00:21:42,950
All the letters are lowercase.

316
00:21:44,160 --> 00:21:46,340
So let's, for example, head to Eclipse.

317
00:21:46,350 --> 00:21:52,230
We've already done this many times and even our Hello World application had more complexity.

318
00:21:52,230 --> 00:21:56,990
It had dependencies, but I'm going to create a new directory here.

319
00:21:57,000 --> 00:22:02,310
Let's say hello app or just app.

320
00:22:02,310 --> 00:22:09,740
Right, let's close this and here we're going to new instead of direct.

321
00:22:09,750 --> 00:22:15,480
So we're going to create a new directory or file, let's call it Hello World dot Java.

322
00:22:16,020 --> 00:22:24,930
And we're going to say public, public class again, this is for refreshing your memory and then showing

323
00:22:24,930 --> 00:22:30,780
you that now that we've installed the default toolchain and then we've installed VMM and a native image

324
00:22:30,780 --> 00:22:35,850
is set up, how we go ahead and create a simple hello world application.

325
00:22:36,180 --> 00:22:47,760
So hello world and then public static void main string args and then let's do a see out system that

326
00:22:47,760 --> 00:22:48,810
add print line.

327
00:22:48,810 --> 00:22:54,750
Hello world from Java in a native image and an exclamation mark.

328
00:22:54,990 --> 00:22:55,530
Right.

329
00:22:55,770 --> 00:22:57,780
So this is our Java application.

330
00:22:58,890 --> 00:23:01,770
We open up a terminal at here.

331
00:23:01,770 --> 00:23:07,310
So where our source code is exactly in our current working directory.

332
00:23:07,320 --> 00:23:14,160
And then I can say Google Home and then being a Java C and then hell of all the java I'm using the Java

333
00:23:14,160 --> 00:23:15,900
compiler from LLVM.

334
00:23:16,290 --> 00:23:17,820
If I do an LS, you see that?

335
00:23:17,820 --> 00:23:21,390
Now I have the hello world class which also shows up here.

336
00:23:21,900 --> 00:23:24,370
And finally, now that the class file is ready.

337
00:23:24,390 --> 00:23:29,670
First of all, I can check that my Java application is correct by running it on a JVM.

338
00:23:29,700 --> 00:23:30,500
Hello world.

339
00:23:30,510 --> 00:23:31,090
Right.

340
00:23:31,110 --> 00:23:36,810
So you use the Java command line application and then pass it the class file.

341
00:23:36,810 --> 00:23:38,970
That is, your main class has the main method.

342
00:23:39,330 --> 00:23:44,760
And now, as you can see, my application works fine.

343
00:23:47,660 --> 00:23:48,310
Let's see.

344
00:23:48,320 --> 00:23:48,910
Oh, okay.

345
00:23:48,950 --> 00:23:56,570
So the reason is that right now it's I had another hello world in my test directory and this was part

346
00:23:56,570 --> 00:23:59,540
of the my global environment variable class path.

347
00:23:59,540 --> 00:24:07,250
So that's why now Java, this Java is picking up the class path and executing that application.

348
00:24:07,250 --> 00:24:13,250
So in order to avoid this, I have to explicitly override this class path variable.

349
00:24:13,250 --> 00:24:21,440
And the way we do it, we explicitly provide the hyphen CPP here, which means only look into the current

350
00:24:21,440 --> 00:24:25,490
working directory and now it's correctly picking up.

351
00:24:25,700 --> 00:24:33,020
Okay, we have a one here, so let's remove this and then let's quickly compile our Java application

352
00:24:33,020 --> 00:24:33,650
again.

353
00:24:36,400 --> 00:24:36,940
All right.

354
00:24:36,940 --> 00:24:41,560
So if you've already set up your class path environment variable, you have to be careful.

355
00:24:42,580 --> 00:24:52,000
You can always override the class path environment variable by by explicitly providing this hyphen CPP

356
00:24:52,030 --> 00:24:52,990
to the Java.

357
00:24:53,140 --> 00:24:54,430
You can even append it.

358
00:24:54,430 --> 00:24:57,290
So I can tell you the first look into the current directory.

359
00:24:57,310 --> 00:24:59,180
Append right with the colon.

360
00:24:59,200 --> 00:25:00,910
That's our class path separator.

361
00:25:00,910 --> 00:25:06,850
And then provide a class path in double code, which means.

362
00:25:09,460 --> 00:25:11,920
So what this does, I believe.

363
00:25:11,920 --> 00:25:13,450
Let's see if this works.

364
00:25:15,950 --> 00:25:17,340
Or, um.

365
00:25:17,750 --> 00:25:19,790
Okay, so we made a mistake.

366
00:25:21,050 --> 00:25:21,410
Yeah.

367
00:25:21,410 --> 00:25:22,670
So let's clean up.

368
00:25:24,020 --> 00:25:25,850
So hyphen seep first.

369
00:25:26,000 --> 00:25:29,990
So the dot goes first, and then a class path.

370
00:25:32,370 --> 00:25:33,830
And then double quote, right?

371
00:25:33,840 --> 00:25:42,060
So what this does, it is still ranks correctly, despite the fact that I have to hell of all classes

372
00:25:42,060 --> 00:25:43,980
that are on my class path.

373
00:25:44,100 --> 00:25:50,520
But when you give the current working directory as the first directory in the class path, Java tries

374
00:25:50,520 --> 00:25:54,630
to search a class called Hello World in the current directory.

375
00:25:54,630 --> 00:26:00,810
First, if you cannot find it, then it goes into the directory that the class path specifies.

376
00:26:00,840 --> 00:26:06,360
Now, if you if I change the order, I tell it first, search the class path environment variable and

377
00:26:06,360 --> 00:26:09,150
then use the search the current directory you see.

378
00:26:09,150 --> 00:26:16,320
Now it uses or finds this hello world class because that's the class that comes up in the first directories

379
00:26:16,320 --> 00:26:17,420
which are in the class path.

380
00:26:17,430 --> 00:26:17,880
Right.

381
00:26:18,210 --> 00:26:26,070
So you can explicitly override the class path by just providing all the directories using hyphen CPP.

382
00:26:26,100 --> 00:26:32,250
Or you can also append the class path to the directory that you are specifying.

383
00:26:32,250 --> 00:26:32,730
Right.

384
00:26:35,470 --> 00:26:39,160
So we're going to compile the class file now with the native image.

385
00:26:39,160 --> 00:26:43,240
So Google Home being a native image, I'm going to tell it hyphen.

386
00:26:44,140 --> 00:26:49,570
This current working directory, the name of the class file is Hello World and then I'm going to tell

387
00:26:49,570 --> 00:26:49,810
it.

388
00:26:49,960 --> 00:26:55,450
The name of my application is going to be my app, so it's going to compile my job application.

389
00:26:55,660 --> 00:26:58,150
The entry point is this class hello world.

390
00:26:58,150 --> 00:26:59,680
It's not inside the package.

391
00:26:59,680 --> 00:27:03,490
If it were inside the package, we have to provide the fully qualified name.

392
00:27:04,770 --> 00:27:10,140
Of the class that has the main method and then the output is going to my app is going to create this

393
00:27:10,200 --> 00:27:15,000
native binary and puts it in the current working directory.

394
00:27:15,000 --> 00:27:20,010
So let's go ahead and run this generating my app and that's executable.

395
00:27:20,010 --> 00:27:23,370
So it's telling us that it's creating a native executable.

396
00:27:23,370 --> 00:27:29,670
We're using a version 17 of Java CC, Apple Clang compiler and then Garbage Collector is going to be

397
00:27:29,680 --> 00:27:30,720
serial GC.

398
00:27:37,080 --> 00:27:41,880
So compiling methods looks like everything works fine.

399
00:27:45,490 --> 00:27:47,710
Almost done creating image.

400
00:27:47,710 --> 00:27:49,690
Now it's and it's finished.

401
00:27:49,690 --> 00:27:51,550
So everything went fine.

402
00:27:51,550 --> 00:27:59,650
And then, um, project artifacts, it's my app, which is executable and then build artifact.

403
00:27:59,650 --> 00:28:04,990
The build artifact is a text file that tells you what kind of file you generated executable and what's

404
00:28:04,990 --> 00:28:07,420
the path or the.

405
00:28:07,750 --> 00:28:09,970
To this application which is my app.

406
00:28:09,970 --> 00:28:10,450
Right.

407
00:28:12,040 --> 00:28:18,820
So let's go ahead and obviously we want to check that the compilation work fine so dot forward slash

408
00:28:18,820 --> 00:28:25,420
which means from the current directory execute my app and hello fold from Java in native image.

409
00:28:25,420 --> 00:28:31,990
So we successfully created a binary native executable binary for our Java application, which was a

410
00:28:31,990 --> 00:28:33,070
simple hello world.

411
00:28:33,370 --> 00:28:42,010
And the other thing that I'm going to point out here, we saw already the command line arguments, right?

412
00:28:42,010 --> 00:28:43,870
And those are passed.

413
00:28:44,200 --> 00:28:48,040
If your application requires some, you can pass them here.

414
00:28:48,040 --> 00:28:58,240
But we saw that also we can use the system like get property and give it the name and then this returns

415
00:28:58,240 --> 00:28:59,440
a string, right?

416
00:28:59,440 --> 00:29:02,890
A string, val or value.

417
00:29:03,280 --> 00:29:11,710
And then I'm going to say that see out name, arrow, arrow and then a plus value.

418
00:29:12,040 --> 00:29:16,240
So if this system property is not set, we're going to get null.

419
00:29:17,020 --> 00:29:23,860
So what I'm going to do is let's run our application with the Java or first of all, we have to compile

420
00:29:23,860 --> 00:29:24,040
it.

421
00:29:24,040 --> 00:29:28,000
So let's compile with Java C and then HELLOWORLD Java.

422
00:29:28,360 --> 00:29:29,230
It works fine.

423
00:29:29,230 --> 00:29:36,280
And then now we can run it with Java a specifying that use this current directory and then name becomes

424
00:29:36,280 --> 00:29:36,820
null.

425
00:29:37,360 --> 00:29:46,930
And then we know that after hyphen CPP we can tell java hyphen DX variables name equals bob and now

426
00:29:46,930 --> 00:29:55,210
this system property is set and what we can do now also use the native image hyphen CPP here and before

427
00:29:55,270 --> 00:29:59,080
specifying the main class, we're going to give it hyphen DX name equals bar.

428
00:29:59,470 --> 00:30:01,000
So let's compile again.

429
00:30:04,640 --> 00:30:07,760
So let's see if this works or not.

430
00:30:08,000 --> 00:30:14,000
If this doesn't work, then after the native executable binary is generated, we can also pass these

431
00:30:14,090 --> 00:30:16,670
at the time that we run the application.

432
00:30:16,910 --> 00:30:24,350
But if this works, then by default this parameter is going to pass to our native executable binary.

433
00:30:24,380 --> 00:30:27,710
Every time you run the application.

434
00:30:27,980 --> 00:30:29,870
So compiling the methods.

435
00:30:30,200 --> 00:30:33,430
And after that, it's going to generate creating the image.

436
00:30:33,440 --> 00:30:34,490
Let's see if this works.

437
00:30:34,490 --> 00:30:36,170
Everything seems to work fine.

438
00:30:36,710 --> 00:30:40,910
And then if I said that my underscore app and now name is NULL.

439
00:30:40,910 --> 00:30:46,130
So that hyphen DX parameter did not work as expected.

440
00:30:46,610 --> 00:30:52,160
But then now we can pass it here hyphen dynamical bar and now this works, right?

441
00:30:52,160 --> 00:30:59,090
So and we saw this before that not only you can pass arguments to this string array, you can also pass

442
00:30:59,210 --> 00:31:05,390
or set the system properties using hyphen DX and the native image differentiates between the parameters

443
00:31:05,390 --> 00:31:06,440
that you pass.

444
00:31:07,340 --> 00:31:14,600
For example, these two strings are passed to this string array, but this hyphen, the name equal Bob,

445
00:31:14,600 --> 00:31:17,120
is passed to as the system property.

446
00:31:17,120 --> 00:31:22,130
So they are this this argument is not passed to this string array.

447
00:31:22,130 --> 00:31:26,990
Just I want you to understand this very clearly, that there is a difference in that.

448
00:31:26,990 --> 00:31:27,470
Right?

449
00:31:28,370 --> 00:31:36,590
So but then let's go back and see if we can actually put this hyphen DX name.

450
00:31:37,490 --> 00:31:41,090
So let's see if we can pass it to the options here.

451
00:31:41,090 --> 00:31:43,100
Hyphen name equals bar.

452
00:31:43,610 --> 00:31:46,040
Let's see if this works or not.

453
00:31:48,570 --> 00:31:51,960
So initializing performing analysis.

454
00:31:59,440 --> 00:32:01,060
So almost done.

455
00:32:02,020 --> 00:32:05,620
And in in lining methods, compiling methods.

456
00:32:12,710 --> 00:32:16,400
And then finally creating the executable file or the image.

457
00:32:16,400 --> 00:32:21,610
So the compilation was, okay, so let's see if we run my app.

458
00:32:21,620 --> 00:32:22,370
What do we get?

459
00:32:22,400 --> 00:32:24,440
Name is still comes as null.

460
00:32:25,470 --> 00:32:30,210
So it looks like we can't really set the system property directly when we compiling them.

461
00:32:30,210 --> 00:32:36,390
But as I mentioned, you can always pass them at the runtime when you run your application, right?

462
00:32:36,390 --> 00:32:37,940
So I hope you enjoy this lecture.

463
00:32:37,950 --> 00:32:43,560
Obviously in the future lectures we're going to go into more depth about all the details of Native Image.

464
00:32:43,560 --> 00:32:46,110
So please stay tuned and I'll see the next one.
