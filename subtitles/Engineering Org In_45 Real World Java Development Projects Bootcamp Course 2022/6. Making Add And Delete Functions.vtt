WEBVTT
1
00:00:01.510 --> 00:00:09.760
So in the last part we have created or like we have put things inside the frame using the panels delivers.

2
00:00:09.790 --> 00:00:17.920
Now we have created this action performed and key type function for checking for the inputs by the user,

3
00:00:17.920 --> 00:00:26.410
whether it is by pressing the buttons or with the text field, how the application is going to handle

4
00:00:26.410 --> 00:00:27.190
the inputs.

5
00:00:27.190 --> 00:00:32.920
We have checked every exception inside this action performed on key type functions.

6
00:00:32.950 --> 00:00:40.630
Now, after checking all of them, we are coming to the main part that how the add and delete are going

7
00:00:40.630 --> 00:00:41.190
to work.

8
00:00:41.200 --> 00:00:47.080
So currently it is showing that once we will create method then automatically this red underline will

9
00:00:47.080 --> 00:00:48.190
be gone.

10
00:00:48.310 --> 00:00:56.800
So let us try by creating public void add function and see how it works.

11
00:00:56.800 --> 00:01:02.080
So it is going to take our first integer inputs only.

12
00:01:02.530 --> 00:01:08.850
And inside this function add function, we are going to add like notes.

13
00:01:08.860 --> 00:01:20.830
Of course this add method is going to make new notes, so let us create a new node and the method will

14
00:01:21.910 --> 00:01:22.960
call a new note.

15
00:01:22.960 --> 00:01:28.330
Of course, we have created this note as a global variables already.

16
00:01:28.450 --> 00:01:29.890
Now this new.

17
00:01:31.410 --> 00:01:32.640
More info.

18
00:01:32.640 --> 00:01:38.190
So info is going to contain the data inside the node.

19
00:01:39.930 --> 00:01:43.320
And there is a word for the known.

20
00:01:44.610 --> 00:01:47.340
So into it, we'll get it through it.

21
00:01:48.760 --> 00:01:53.740
We have already created this get with method above in the core.

22
00:01:54.250 --> 00:01:57.670
So new node will take that from there.

23
00:01:58.060 --> 00:02:10.160
I think it was 4040 for the new node and checking that how we could like add this nodes to the three.

24
00:02:10.750 --> 00:02:18.340
So if root is null, so suppose that the tree is empty, then how this addition is going to be done.

25
00:02:19.510 --> 00:02:28.240
So inside this if statement, we are going to create a root which will contain the new node.

26
00:02:29.250 --> 00:02:30.000
And.

27
00:02:31.470 --> 00:02:39.790
If we are adding that new node, then we have to set up ten heights for that new node, of course.

28
00:02:39.810 --> 00:02:49.800
So the new node is going to be our first layer data don't get mounts or we have to set the bounds for

29
00:02:49.800 --> 00:02:51.600
the new node.

30
00:02:53.040 --> 00:02:53.460
Okay.

31
00:02:53.460 --> 00:02:55.800
So set months and.

32
00:02:56.880 --> 00:03:05.190
Arguments will be three panels, so the node should be added inside the three panel only it should not

33
00:03:05.190 --> 00:03:08.280
like get anywhere in the frame.

34
00:03:08.280 --> 00:03:16.890
There is a fixed place for the new node inside the frame, so it should like attach that only and the

35
00:03:16.890 --> 00:03:17.670
width.

36
00:03:18.390 --> 00:03:19.410
Why do?

37
00:03:21.250 --> 00:03:22.000
Cuomo.

38
00:03:22.540 --> 00:03:24.880
Ten Cuomo.

39
00:03:26.800 --> 00:03:29.980
So basically this is the dimension for the.

40
00:03:31.210 --> 00:03:31.990
Noonan.

41
00:03:33.580 --> 00:03:33.880
New.

42
00:03:36.630 --> 00:03:42.690
Is going to initially, like the new node is the starting point of the tree.

43
00:03:42.690 --> 00:03:50.490
So we have talked about the points we have there declared it as P and that point for the new node is

44
00:03:50.490 --> 00:03:54.840
going to be like we have x one, y1x2 and y two.

45
00:03:54.870 --> 00:04:06.180
So we have to set those points for this new node and it is going to be 000 and zero.

46
00:04:07.080 --> 00:04:15.090
So yes, if the root is like null, we have to like make a new root for the tree.

47
00:04:15.090 --> 00:04:20.760
Then the x1y1x2y2 is going to be 0000.

48
00:04:22.050 --> 00:04:24.030
Yes, this is about the point.

49
00:04:24.060 --> 00:04:32.700
Now suppose if the root is not null like there is already members present inside the tree, then the

50
00:04:32.700 --> 00:04:36.360
f statement should be taken into consideration.

51
00:04:36.810 --> 00:04:39.360
The node current.

52
00:04:39.960 --> 00:04:45.330
The current node will be pointing to the already created nodes.

53
00:04:46.160 --> 00:04:49.550
Which will become the route for the three.

54
00:04:50.440 --> 00:04:54.760
And we will assign the route.

55
00:04:55.660 --> 00:04:59.500
So we are adding a new node to the tree.

56
00:04:59.530 --> 00:05:03.250
So we will be talking about the new node.

57
00:05:03.280 --> 00:05:09.110
We will call it as current and already present node there in the tree.

58
00:05:09.130 --> 00:05:10.900
We will call it as pre.

59
00:05:10.930 --> 00:05:19.840
So an integer will contain the data of the new node, which is like being created right now.

60
00:05:20.080 --> 00:05:28.840
So X is going to be our decide the x axis of that new newly made coordinate.

61
00:05:29.950 --> 00:05:32.320
So three panels don't get bounce.

62
00:05:33.420 --> 00:05:36.480
And so I guess this gets bounced.

63
00:05:37.690 --> 00:05:40.000
And after this, getting the bounty.

64
00:05:40.030 --> 00:05:41.320
Now we have to.

65
00:05:41.670 --> 00:05:41.960
Okay.

66
00:05:41.980 --> 00:05:48.850
So for the last block, we are checking that if that is or not already present in the tree, then how

67
00:05:48.850 --> 00:05:51.850
the new node is going to be attached inside the tree.

68
00:05:52.000 --> 00:05:59.260
So yes, checking that if current is not equal to null, like what we are adding to the tree has our

69
00:05:59.260 --> 00:06:04.810
data should contain a valid integer that could be added inside the tree.

70
00:06:05.650 --> 00:06:09.160
And we are assigning that tree to current.

71
00:06:09.550 --> 00:06:15.600
Like basically we are pointing things and how this tree linking is done.

72
00:06:15.610 --> 00:06:26.650
So we use pointers in order to point the current node to the already existing known as these nodes to

73
00:06:26.650 --> 00:06:31.420
be like our task as we are making a hierarchical data structure.

74
00:06:31.450 --> 00:06:37.930
Then the new node suppose it is lesser than the already present node, then it should be added in the

75
00:06:37.930 --> 00:06:42.100
left side and if it is greater then then it should be added in the right subtree.

76
00:06:42.100 --> 00:06:45.520
So we have to point things to each other.

77
00:06:45.520 --> 00:06:52.660
So if it is less than then we have to use this current which is pointing to the previous like tree which

78
00:06:52.810 --> 00:07:00.400
we are calling it, and they should be linked in a manner that that shows the relation between them.

79
00:07:00.400 --> 00:07:04.450
That is it is the left side of this already existing node.

80
00:07:04.750 --> 00:07:12.130
So yes, we are checking it head inside that function and if it is less then then it is added in the

81
00:07:12.130 --> 00:07:15.280
left part, otherwise it is added in the right.

82
00:07:15.730 --> 00:07:17.170
So here we are doing that.

83
00:07:17.260 --> 00:07:25.000
So if the current data is greater then then we will add current to the left and otherwise to the right.

84
00:07:25.000 --> 00:07:32.290
Subtree and suppose we try to add a like integer which is already present in the tree.

85
00:07:32.290 --> 00:07:36.820
Then also there should be our exception checking that OC.

86
00:07:36.820 --> 00:07:43.660
So dialog box will appear, which will say that this node is already existing inside the tree.

87
00:07:43.690 --> 00:07:45.640
Try adding something again.

88
00:07:45.880 --> 00:07:48.070
So this is how it is working.

89
00:07:48.070 --> 00:07:49.720
We have to check that.

90
00:07:49.720 --> 00:07:55.990
Yes, this node is already present or not like it is a unique node for the tree or not.

91
00:07:55.990 --> 00:07:59.500
And then only we should add inside the tree.

92
00:07:59.770 --> 00:08:11.950
Now after adding this, the x is like decrease to half as suppose initially the x is five centimetres.

93
00:08:11.980 --> 00:08:15.580
You can see this line, the height is continuously decreasing.

94
00:08:15.580 --> 00:08:22.150
So suppose if it is five centimetres then in the next part it will be decreased to half again.

95
00:08:22.540 --> 00:08:25.840
Here you can see that it is again reduced to half.

96
00:08:25.840 --> 00:08:27.760
So this is how it is working.

97
00:08:27.760 --> 00:08:30.610
We are dividing this thing into two parts.

98
00:08:31.090 --> 00:08:34.030
We are working with the same length of line.

99
00:08:34.030 --> 00:08:37.480
But how to like manage everything with the same length of right.

100
00:08:37.480 --> 00:08:40.840
So this is a division of two things.

101
00:08:40.840 --> 00:08:43.150
We are talking about a binary thing.

102
00:08:43.150 --> 00:08:49.030
So we will simply split this line only to two parts and then add it to the left and right.

103
00:08:49.030 --> 00:08:49.720
Subtree.

104
00:08:50.410 --> 00:08:53.500
Okay, so after this we are going to.

105
00:08:55.600 --> 00:09:08.140
Inside current data it's going to pass into like we are going to pass this data in a string format to

106
00:09:08.140 --> 00:09:09.880
be displayed on the frame.

107
00:09:10.150 --> 00:09:15.220
So percent reader data don't get text.

108
00:09:16.210 --> 00:09:28.210
So getting the current node, which is added as a test and index, is going to contain the pre data,

109
00:09:29.170 --> 00:09:36.130
not get text or so getting the X coordinate for the previous node which is already present in the.

110
00:09:37.710 --> 00:09:41.190
And using a bracket to call this get X.

111
00:09:41.190 --> 00:09:47.340
And similarly for the Y three dot data, get Y.

112
00:09:48.800 --> 00:09:51.060
Okay, so this is how it is done.

113
00:09:51.540 --> 00:09:57.420
Now, after this, we have to also set a dimension for the pre.

114
00:09:58.090 --> 00:10:07.000
So dimension pre dimension for the pre data don't get size.

115
00:10:08.870 --> 00:10:17.690
So pre data again getting the previous size for the node as that is a size we have already decided for

116
00:10:17.690 --> 00:10:20.160
a node and the current.

117
00:10:20.240 --> 00:10:30.920
So similar way we will use it for the current dimension and new dimension.

118
00:10:32.930 --> 00:10:33.370
Wait.

119
00:10:34.340 --> 00:10:38.900
So wait for the new note or we can call it current.

120
00:10:39.230 --> 00:10:39.650
No.

121
00:10:39.650 --> 00:10:41.950
Dot text.

122
00:10:42.140 --> 00:10:42.770
Hide.

123
00:10:45.170 --> 00:10:52.400
So that text, which is like input inside the frame, is containing a height of course.

124
00:10:52.400 --> 00:10:57.360
So we have to decide the dimension of the node according to that height.

125
00:10:57.410 --> 00:11:04.010
We have to adjust that text inside the rectangle, which we have created in that manner.

126
00:11:05.090 --> 00:11:07.640
So this was all about the add part.

127
00:11:07.640 --> 00:11:17.240
The we have created the ADD function correctly, but how to add nodes inside the beast now coming to

128
00:11:17.240 --> 00:11:18.830
the delete function.

129
00:11:18.830 --> 00:11:22.760
So public void delete.

130
00:11:25.190 --> 00:11:27.200
So inside this delete function.

131
00:11:27.200 --> 00:11:32.060
Also we have to check that whether the tree is empty or full.

132
00:11:32.090 --> 00:11:39.520
So suppose if we want to delete any note from empty tree, then definitely it will throw exception inside

133
00:11:39.530 --> 00:11:42.350
a dialog box that BSD is empty.

134
00:11:42.380 --> 00:11:45.830
You cannot delete anything from an empty BSD.

135
00:11:45.830 --> 00:11:49.430
You have to add something to the tree in order to delete it.

136
00:11:49.910 --> 00:11:55.820
So yes, this if and LS is checking that only that whether the tree is empty or not.

137
00:11:55.820 --> 00:12:03.860
So suppose if a tree is containing a node like there are members inside the BSD, then we will set the

138
00:12:03.860 --> 00:12:06.740
current to root and tree to root.

139
00:12:06.830 --> 00:12:14.600
So once the current is not equal to none, like suppose the tree is containing some elements.

140
00:12:14.600 --> 00:12:24.530
Then again we have to pass that integer in the form of string and then the info will like info.

141
00:12:24.530 --> 00:12:25.490
So what is info?

142
00:12:25.490 --> 00:12:29.270
Info is the data inside the node.

143
00:12:29.420 --> 00:12:38.780
So if we have to delete something, firstly we have to check that whether the subtree presented, how

144
00:12:38.780 --> 00:12:40.520
it should be like relocated.

145
00:12:40.520 --> 00:12:43.040
So we are basically rearranging them.

146
00:12:43.040 --> 00:12:52.040
So suppose we want to delete 350 then where this 400 should be attached in order to like only remove

147
00:12:52.040 --> 00:12:58.040
tree 50 and the tree should not even violate the principle of a binary search string.

148
00:12:58.040 --> 00:13:05.340
So suppose we are removing this tree 15 then this 400 should be added as the right subtree of 250.

149
00:13:05.750 --> 00:13:10.400
Then only the principle of BSD will not be violated.

150
00:13:10.400 --> 00:13:14.210
So we are checking that inside this.

151
00:13:14.210 --> 00:13:23.870
If then info is greater than data of the node which we are like wishing to delete, then we have to

152
00:13:23.900 --> 00:13:26.900
set it as its left subtree.

153
00:13:26.900 --> 00:13:30.010
So here we have already 200.

154
00:13:30.140 --> 00:13:37.760
So suppose if we have something, suppose we have 150 and we want to delete.

155
00:13:37.760 --> 00:13:45.980
Suppose we have had 150 as its or left subtree and we want to delete 200 from her.

156
00:13:46.010 --> 00:13:57.530
Then we have to add that 150 as the left is like left subtree of this 200 and this part should be removed.

157
00:13:57.530 --> 00:14:04.640
And otherwise, if I want to correct myself, it is not 150, but it is 250.

158
00:14:04.640 --> 00:14:09.590
So suppose we want to remove this to 50 from this tree then how?

159
00:14:09.590 --> 00:14:17.360
This tree will relocate itself so the left child of 500 should be changed.

160
00:14:17.360 --> 00:14:18.650
So what it could be.

161
00:14:18.650 --> 00:14:26.390
So suppose if we are deleting this to 50, then any of them could be the left sub sub child of this

162
00:14:26.390 --> 00:14:27.260
500.

163
00:14:27.260 --> 00:14:29.960
So once this to 50 will be deleted.

164
00:14:30.810 --> 00:14:35.300
So 1050 will become the child left child of 500.

165
00:14:35.310 --> 00:14:43.950
And we have an element less than 350, which is 200, which can be its left child and 400 which is greater

166
00:14:43.950 --> 00:14:45.000
than 50.

167
00:14:45.000 --> 00:14:47.820
So we can make it as it's right.

168
00:14:47.850 --> 00:14:53.550
Child So this is how this rearrangement will be done once a node is deleted.

169
00:14:53.550 --> 00:15:00.930
And that is what exactly we are checking inside this code by, like pointing to current left and current

170
00:15:00.930 --> 00:15:01.410
right.

171
00:15:01.530 --> 00:15:07.620
Basically, current is the node which is being deleted and we are checking it left, left and right

172
00:15:07.620 --> 00:15:08.060
subject.

173
00:15:08.190 --> 00:15:14.490
That's how we can rearrange them in order to not to violate the principles of binary search tree.

174
00:15:15.000 --> 00:15:22.920
And yes, this is all about checking that how the derangement should be done and this repentance for

175
00:15:23.010 --> 00:15:26.460
we have already discussed repent once in a project.

176
00:15:26.460 --> 00:15:33.060
So this repaint is about removing unknown, like removing the graphics which is present and then adding

177
00:15:33.060 --> 00:15:35.910
something in place in a minimum amount of time.

178
00:15:35.910 --> 00:15:42.360
Like there should be no time lag in removing this node after hitting this delete button and forming

179
00:15:42.360 --> 00:15:43.350
the new subtree.

180
00:15:43.350 --> 00:15:47.040
So this is done with the help of this repaint function.

181
00:15:47.870 --> 00:15:48.620
Yes.

182
00:15:49.580 --> 00:15:56.300
So after all the checking, we have to rearrange the notes according to the best law.

183
00:15:56.420 --> 00:16:02.840
We will create this rearrange function in then net how the notes are going to rearrange themselves.

184
00:16:02.840 --> 00:16:08.270
So yes, we will creating this rearrange function in the next part and also create functions for in

185
00:16:08.270 --> 00:16:09.710
order to reorder and post order.
