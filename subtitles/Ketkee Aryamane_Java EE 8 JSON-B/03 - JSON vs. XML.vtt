WEBVTT
1
00:00:00.050 --> 00:00:03.050
- [Narrator] Now let's get into the debate of JSON vs. XML.

2
00:00:03.050 --> 00:00:06.000
Now those who've already worked with XML before

3
00:00:06.000 --> 00:00:09.050
already know that this is another way of exchanging data

4
00:00:09.050 --> 00:00:11.070
between heterogeneous systems.

5
00:00:11.070 --> 00:00:15.000
But, JSON is something that we are talking about right now

6
00:00:15.000 --> 00:00:17.070
for this course, so we are stressing on why JSON is better.

7
00:00:17.070 --> 00:00:20.030
But that's not how it works because JSON is going to

8
00:00:20.030 --> 00:00:22.060
work well with certain systems;

9
00:00:22.060 --> 00:00:25.020
XML may work well with its own set of systems.

10
00:00:25.020 --> 00:00:28.030
It's like that. However, let's just talk about this.

11
00:00:28.030 --> 00:00:29.050
Now, when you talk about JSON,

12
00:00:29.050 --> 00:00:31.010
it's of course as we said earlier:

13
00:00:31.010 --> 00:00:34.090
text-based, simple, and it is structured.

14
00:00:34.090 --> 00:00:37.010
Now like extensive and mark-up language, yes,

15
00:00:37.010 --> 00:00:40.010
it is language and platform independent; but, it's easy to

16
00:00:40.010 --> 00:00:44.040
read and understand by both machines and humans.

17
00:00:44.040 --> 00:00:46.010
Or, maybe I should've said it the other way around:

18
00:00:46.010 --> 00:00:50.080
humans and machines. Okay, XML is a little harder to read.

19
00:00:50.080 --> 00:00:54.030
Take a look at the 2 blocks of code that I have on my slide.

20
00:00:54.030 --> 00:00:56.080
The left-hand side is adjacent representation,

21
00:00:56.080 --> 00:00:59.050
and the right-hand side is an XML document.

22
00:00:59.050 --> 00:01:01.000
When you look at the left-hand side,

23
00:01:01.000 --> 00:01:03.070
you understand that it's talking something about the books.

24
00:01:03.070 --> 00:01:05.020
Okay. Which means that it's a collection of books

25
00:01:05.020 --> 00:01:07.050
that have been mentioned there.

26
00:01:07.050 --> 00:01:11.000
On the right-hand side, you actually take a little more time

27
00:01:11.000 --> 00:01:13.090
to figure that out-- that it is talking about books.

28
00:01:13.090 --> 00:01:16.080
Because the data and the text that you are able to see--

29
00:01:16.080 --> 00:01:18.040
the angle brackets on all of that--

30
00:01:18.040 --> 00:01:21.040
they are the elements of XML. And that is the additional

31
00:01:21.040 --> 00:01:24.020
stuff that goes in inside of an XML document.

32
00:01:24.020 --> 00:01:27.020
So when you read JSON, yes it is definitely a little easier

33
00:01:27.020 --> 00:01:30.010
to quickly understand what the reader is talking about.

34
00:01:30.010 --> 00:01:32.080
So, that's the first thing. Next is,

35
00:01:32.080 --> 00:01:34.050
when you talk about JSON structures,

36
00:01:34.050 --> 00:01:38.000
now we saw simple data types: we saw strings, numbers,

37
00:01:38.000 --> 00:01:41.090
booleans and their values; all of these data types

38
00:01:41.090 --> 00:01:45.020
are so commonly used in the entire universe of

39
00:01:45.020 --> 00:01:47.050
programming languages that we have today.

40
00:01:47.050 --> 00:01:50.020
Every other programming language that you see

41
00:01:50.020 --> 00:01:52.010
definitely knows these basic data types.

42
00:01:52.010 --> 00:01:54.020
Even when you talk about JSON structures,

43
00:01:54.020 --> 00:01:57.060
like a name value pair, or you have a JSON object,

44
00:01:57.060 --> 00:01:59.050
or you have a JSON array, these are such

45
00:01:59.050 --> 00:02:02.090
common data structures used across languages.

46
00:02:02.090 --> 00:02:05.080
JSON is like a giant hashmap which has got multiple

47
00:02:05.080 --> 00:02:09.020
key value pairs and the nesting can be to any level.

48
00:02:09.020 --> 00:02:11.000
But when you talk about an XML,

49
00:02:11.000 --> 00:02:13.060
XML has got a lot of data types.

50
00:02:13.060 --> 00:02:16.040
It could have a start tag, an end tag, an element,

51
00:02:16.040 --> 00:02:21.030
attributes, a schema, an XSD, a DTD, so it comes in with

52
00:02:21.030 --> 00:02:25.080
a lot of chunks which are extra in addition to the data.

53
00:02:25.080 --> 00:02:28.080
When it comes to an object-oriented system,

54
00:02:28.080 --> 00:02:31.060
JSON is definitely going to be the choice to pick up

55
00:02:31.060 --> 00:02:34.070
because it's very close to these object-oriented systems

56
00:02:34.070 --> 00:02:37.090
and helps us to design the system a little better.

57
00:02:37.090 --> 00:02:40.050
The next thing is, we said that XML has got DTDs,

58
00:02:40.050 --> 00:02:44.000
schemas, and all of this extra information along with it,

59
00:02:44.000 --> 00:02:46.080
so there is an overhead. JSON has no overhead,

60
00:02:46.080 --> 00:02:48.060
and that's why when you quote it across systems,

61
00:02:48.060 --> 00:02:51.090
it's definitely easier, it is faster, and it is way easier

62
00:02:51.090 --> 00:02:54.080
to even convert it into the kind of object that you need

63
00:02:54.080 --> 00:02:58.050
for your system for further processing.

64
00:02:58.050 --> 00:03:01.000
Then you have JSON, which is based on Javascript,

65
00:03:01.000 --> 00:03:03.010
we said that it is derived out of Javascript.

66
00:03:03.010 --> 00:03:05.090
That's why, let's say, when you make ajax calls--

67
00:03:05.090 --> 00:03:09.000
asynchronous calls--in your systems or in your applications,

68
00:03:09.000 --> 00:03:12.020
and the data that you get, that's the output of that call.

69
00:03:12.020 --> 00:03:15.050
It's very easy to render that data into the UI

70
00:03:15.050 --> 00:03:18.010
or into the front-end pages very quickly.

71
00:03:18.010 --> 00:03:21.010
But when it is an XML, it becomes a little tedious because

72
00:03:21.010 --> 00:03:23.030
you have to enter it through the entire document and

73
00:03:23.030 --> 00:03:25.080
find out certain elements from where you want to

74
00:03:25.080 --> 00:03:27.050
pick up values and then attach it to the

75
00:03:27.050 --> 00:03:29.060
document-object model of your front-end.

76
00:03:29.060 --> 00:03:34.010
So it's a little difficult and tedious to do that with XML.

77
00:03:34.010 --> 00:03:37.090
But having said all this, XML has its own advantages too.

78
00:03:37.090 --> 00:03:39.090
Let's look back at that XML document we were looking at

79
00:03:39.090 --> 00:03:44.030
before. You have this book element and it has got something

80
00:03:44.030 --> 00:03:48.030
which has id="book1". That's an attribute.

81
00:03:48.030 --> 00:03:50.070
An attribute always helps to specify metadata about the

82
00:03:50.070 --> 00:03:52.080
element that you're trying to describe.

83
00:03:52.080 --> 00:03:55.000
So when you have a schema; when you have a

84
00:03:55.000 --> 00:03:59.000
defined, strict structure; every tag is already defined

85
00:03:59.000 --> 00:04:00.090
in a document type definition.

86
00:04:00.090 --> 00:04:03.010
Every tag will have certain number of attributes.

87
00:04:03.010 --> 00:04:06.060
Every tag will have nesting only to a certain level, etc.

88
00:04:06.060 --> 00:04:08.030
All of these rules are specified

89
00:04:08.030 --> 00:04:10.030
in the document type definition.

90
00:04:10.030 --> 00:04:14.030
And when it comes to these schemas and DTDs and attributes,

91
00:04:14.030 --> 00:04:17.090
you have a rule set to write out the XML document; and

92
00:04:17.090 --> 00:04:21.020
rules are good sometimes. Because imagine this situation:

93
00:04:21.020 --> 00:04:23.060
You have this XML data being transported to, let's say,

94
00:04:23.060 --> 00:04:26.080
ten systems and when you have a strict structure

95
00:04:26.080 --> 00:04:30.000
to that XML document, it's definitely an assurance that

96
00:04:30.000 --> 00:04:33.020
none of the systems are going to tamper with it.

97
00:04:33.020 --> 00:04:35.010
But that's not the case with JSON.

98
00:04:35.010 --> 00:04:37.010
If I quote it across multiple systems,

99
00:04:37.010 --> 00:04:40.020
I can definitely add key and value pairs the way I want.

100
00:04:40.020 --> 00:04:44.080
Yes so in that way definitely XML is at an advantage.

101
00:04:44.080 --> 00:04:47.090
Next is, when you want to provide a very good data model

102
00:04:47.090 --> 00:04:50.070
into your systems, you are supposed to definitely go for

103
00:04:50.070 --> 00:04:53.020
XML rather than going for JSON.

104
00:04:53.020 --> 00:04:54.080
JSON does not have the capabilities for a

105
00:04:54.080 --> 00:04:59.040
well-modeled structure. XML can contain special data types.

106
00:04:59.040 --> 00:05:03.020
For example, it can help you to port audio files,

107
00:05:03.020 --> 00:05:06.010
audio data, or it can also help you to transfer

108
00:05:06.010 --> 00:05:09.020
activeX components and all of these special data types

109
00:05:09.020 --> 00:05:12.040
which JSON does not possess the capability for.

110
00:05:12.040 --> 00:05:15.000
And then you also have something which is called an XSL,

111
00:05:15.000 --> 00:05:18.000
which is used to beautify an XML document.

112
00:05:18.000 --> 00:05:20.050
XSL is a very powerful language because it can actually

113
00:05:20.050 --> 00:05:23.060
retrieve portions of the XML document, beautify it,

114
00:05:23.060 --> 00:05:25.090
and then display it for the customer.

115
00:05:25.090 --> 00:05:30.050
Not only that, XML definitely has this behavior to give you

116
00:05:30.050 --> 00:05:33.090
a lot of views for the same piece of data.

117
00:05:33.090 --> 00:05:36.020
You can look at the same chunk of data

118
00:05:36.020 --> 00:05:37.070
in a number of different ways.

119
00:05:37.070 --> 00:05:40.040
That's something that XML can do for you.

120
00:05:40.040 --> 00:05:43.020
So, this debate is actually never-ending

121
00:05:43.020 --> 00:05:45.020
and it's going to definitely take a long time

122
00:05:45.020 --> 00:05:46.070
to decide which one of them is better.

123
00:05:46.070 --> 00:05:49.000
But let's not say which one of them is better.

124
00:05:49.000 --> 00:05:51.030
Let's just say that when it comes to data interchange,

125
00:05:51.030 --> 00:05:54.040
JSON does the best job; and when it comes to modeling

126
00:05:54.040 --> 00:05:55.090
and when it comes to special data types

127
00:05:55.090 --> 00:05:58.040
when you have requirements of looking at the data in a

128
00:05:58.040 --> 00:06:01.010
number of ways, then yeah, XML will do that better.

129
00:06:01.010 --> 00:06:03.090
It's a well-documented markup, and let's understand

130
00:06:03.090 --> 00:06:06.000
that that is the job it does best.

