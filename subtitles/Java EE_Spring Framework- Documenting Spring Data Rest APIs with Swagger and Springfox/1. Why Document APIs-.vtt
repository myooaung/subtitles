WEBVTT
1
00:00:01.040 --> 00:00:01.430
Hi,

2
00:00:01.430 --> 00:00:05.210
this is Craig Golightly, and welcome to Spring Framework: Documenting

3
00:00:05.210 --> 00:00:09.740
Spring Data Rest APIs with Swagger and Springfox.

4
00:00:09.740 --> 00:00:14.240
So why would you need to document an API? Most APIs are consumed by

5
00:00:14.240 --> 00:00:19.560
users who did not write the API. Documentation helps answer questions

6
00:00:19.560 --> 00:00:22.760
your users may have when they access your API.

7
00:00:22.760 --> 00:00:27.340
It helps communicate what services your API can provide and how users

8
00:00:27.340 --> 00:00:32.080
should access those services. And documentation is a key piece to ensure

9
00:00:32.080 --> 00:00:37.890
your API gets used and is successful and also helps to identify changes

10
00:00:37.890 --> 00:00:42.680
when you update your API. Keeping documentation up to date with your

11
00:00:42.680 --> 00:00:44.540
code can be challenging.

12
00:00:44.540 --> 00:00:47.690
Some documentation is better than no documentation,

13
00:00:47.690 --> 00:00:52.500
but incorrect documentation can be worse than no documentation at all.

14
00:00:52.500 --> 00:00:54.840
Once you start documenting your API,

15
00:00:54.840 --> 00:00:58.650
you must maintain that documentation so that it stays accurate.

16
00:00:58.650 --> 00:01:01.480
Since Swagger is generated from the source code,

17
00:01:01.480 --> 00:01:04.100
you are less likely to introduce errors.

18
00:01:04.100 --> 00:01:09.640
You also have the advantage of speed. The documentation ships with the code.

19
00:01:09.640 --> 00:01:14.340
You don't have to wait for a team to create the docs after the API is released.

20
00:01:14.340 --> 00:01:17.340
Swagger aims to be quick and easy,

21
00:01:17.340 --> 00:01:23.800
almost a free way to get documentation for your API.

22
00:01:23.800 --> 00:01:28.140
Let's take a look at an example API that uses Swagger and

23
00:01:28.140 --> 00:01:30.740
Springfox to generate documentation.

24
00:01:30.740 --> 00:01:34.820
What you're going to see is mostly the default documentation you get by

25
00:01:34.820 --> 00:01:38.810
adding just a few lines of code to your Spring project.

26
00:01:38.810 --> 00:01:41.620
Here is some documentation that was generated from

27
00:01:41.620 --> 00:01:44.270
a Spring Data REST API project.

28
00:01:44.270 --> 00:01:48.090
You can see some information about the title and the version,

29
00:01:48.090 --> 00:01:50.840
as well as all of the exposed endpoints.

30
00:01:50.840 --> 00:01:55.340
You can also see the models that are defined and used with the API.

31
00:01:55.340 --> 00:01:58.590
Let's take a look at the Employee model.

32
00:01:58.590 --> 00:02:02.630
It has a department, id, name, and title.

33
00:02:02.630 --> 00:02:05.740
If we drill into, say, the Employee Entity,

34
00:02:05.740 --> 00:02:09.140
we can see all of the different endpoints that are available.

35
00:02:09.140 --> 00:02:14.740
Not only does Swagger document the API, it also acts as a REST client.

36
00:02:14.740 --> 00:02:19.940
I can drill into one of the methods and see additional

37
00:02:19.940 --> 00:02:25.140
information about that endpoint.

38
00:02:25.140 --> 00:02:29.610
Back at the top, there's a Try it out button.

39
00:02:29.610 --> 00:02:32.370
I could fill in some of the parameter values, I'll just leave

40
00:02:32.370 --> 00:02:37.010
them blank for the default, and hit Execute.

41
00:02:37.010 --> 00:02:41.320
It will then show us the equivalent curl and request URL command for what

42
00:02:41.320 --> 00:02:46.000
we just did, as well as the response body and response headers. Note that

43
00:02:46.000 --> 00:02:49.120
for this call there are zero employees.

44
00:02:49.120 --> 00:02:52.790
I just started up the application, and it uses an in‑memory database,

45
00:02:52.790 --> 00:02:54.490
so there's nothing there yet.

46
00:02:54.490 --> 00:02:59.140
Let's go ahead and find the POST method and add an employee.

47
00:02:59.140 --> 00:03:02.080
We'll hit the same Try it out button,

48
00:03:02.080 --> 00:03:06.740
then edit the model for the values that we want.

49
00:03:06.740 --> 00:03:12.140
I'm going to remove id since it's autogenerated.

50
00:03:12.140 --> 00:03:15.740
Once the model is filled in how we want,

51
00:03:15.740 --> 00:03:22.150
we'll click Execute, and we can view the equivalent curl and request URL,

52
00:03:22.150 --> 00:03:25.520
as well as the response body and response headers.

53
00:03:25.520 --> 00:03:27.740
Now if we called get employees again,

54
00:03:27.740 --> 00:03:30.490
we'll see the employee that was just added: Craig,

55
00:03:30.490 --> 00:03:34.440
developer, in the development department.

56
00:03:34.440 --> 00:03:39.600
In this case, the employee entity is a Spring Data REST managed object.

57
00:03:39.600 --> 00:03:43.000
All of these endpoints were automatically generated by Spring data

58
00:03:43.000 --> 00:03:46.560
REST, and Swagger was able to pick these up with the help of

59
00:03:46.560 --> 00:03:50.180
Springfox and generate all of this documentation.

60
00:03:50.180 --> 00:03:54.160
It also works for other services that you may add to your project.

61
00:03:54.160 --> 00:03:56.840
Let's take a look at the example‑service.

62
00:03:56.840 --> 00:04:00.500
This just has a single get endpoint to get the

63
00:04:00.500 --> 00:04:05.660
schedule. We can go in and try it out, then see the response.

64
00:04:05.660 --> 00:04:09.240
Your schedule is Monday through Friday, 9 to 5.

65
00:04:09.240 --> 00:04:10.030
Overall,

66
00:04:10.030 --> 00:04:13.930
it's a great way to add some documentation to your API and

67
00:04:13.930 --> 00:04:21.000
have a REST client to be able to do some exploratory testing and interact with your API.

