WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.000
Hi,

00:00:02.000 --> 00:00:02.400
everybody,

00:00:02.400 --> 00:00:06.390
and welcome this lesson on looking at Jupiter kernels.

00:00:06.390 --> 00:00:09.300
So this is as far as we had gotten in the proofs lesson.

00:00:09.300 --> 00:00:12.500
And I had mentioned that behind every notebook runs a carnal.

00:00:12.500 --> 00:00:13.700
So when you run a coat sell,

00:00:13.700 --> 00:00:18.130
that code is executed within the colonel and any output has returned back to the cell to be

00:00:18.130 --> 00:00:18.880
displayed,

00:00:18.880 --> 00:00:22.540
and the Colonel state persists over time and between cells,

00:00:22.540 --> 00:00:26.270
it pertains to the document as a whole and not individual cells.

00:00:26.270 --> 00:00:26.840
So,

00:00:26.840 --> 00:00:27.240
for example,

00:00:27.240 --> 00:00:31.800
if he import libraries or dickered declare variables in one cell that will be available in

00:00:31.800 --> 00:00:32.920
another in this way,

00:00:32.920 --> 00:00:36.810
you can think of a notebook document is being somewhat comparable to a script file except

00:00:36.810 --> 00:00:37.920
that it's multimedia.

00:00:37.920 --> 00:00:42.590
So first will import a python package and define a function.

00:00:42.590 --> 00:00:46.740
We're gonna import numpty as MP,

00:00:46.740 --> 00:00:50.170
and then we're going to define a function for square,

00:00:50.170 --> 00:00:52.830
so want to Once we've executed to sell above,

00:00:52.830 --> 00:00:56.000
we can reference NP and square in any other cell.

00:00:56.000 --> 00:00:59.860
So you let's see how that would work.

00:00:59.860 --> 00:01:05.700
So here what I'm going to do is I'm going to specify X as being any a random into gear from

00:01:05.700 --> 00:01:06.650
1 to 10.

00:01:06.650 --> 00:01:07.810
And why,

00:01:07.810 --> 00:01:18.950
as the square root off X and what I want to do is go ahead and print that saying that X is

00:01:18.950 --> 00:01:25.960
X squared is why they rebuilt again.

00:01:25.960 --> 00:01:30.310
This will work regardless of the order of the cells in your notebook,

00:01:30.310 --> 00:01:38.240
and you can try it for yourself by printing the various variables regardless,

00:01:38.240 --> 00:01:41.360
if it it will work on any cell regardless off,

00:01:41.360 --> 00:01:42.470
as I have mentioned,

00:01:42.470 --> 00:01:45.360
which order it's in.

00:01:45.360 --> 00:01:49.250
So let's say,

00:01:49.250 --> 00:01:53.080
if we specify a value for why which,

00:01:53.080 --> 00:01:54.590
as you guys can see above,

00:01:54.590 --> 00:01:58.450
I have said that it should be a square of X.

00:01:58.450 --> 00:01:59.420
So let's say,

00:01:59.420 --> 00:02:07.270
if we specify a specific integer for why there's were specified,

00:02:07.270 --> 00:02:09.120
wise equals to 10.

00:02:09.120 --> 00:02:12.840
So what do you think will happen if we run the cell again?

00:02:12.840 --> 00:02:15.130
Do you think that output will change?

00:02:15.130 --> 00:02:21.650
Or do you think that output will stay where having it being the square root off X?

00:02:21.650 --> 00:02:25.490
Because most of the time the floor in your notebook will be about top to bottom,

00:02:25.490 --> 00:02:33.020
but it's common to go back to make changes here in the kernel.

00:02:33.020 --> 00:02:33.330
Well,

00:02:33.330 --> 00:02:36.720
we have an option to either restart the Colonel weaken,

00:02:36.720 --> 00:02:42.650
restart and run all or restart and clear All so this will basically do is if we do our

00:02:42.650 --> 00:02:50.150
restart the colonel and read Run all It will rerun all of the cells from top to bottom so

00:02:50.150 --> 00:02:55.310
it will go order by order Will do the 1st 1 the 2nd 1 all the way down.

00:02:55.310 --> 00:02:56.000
So if,

00:02:56.000 --> 00:02:56.610
for example,

00:02:56.610 --> 00:02:59.370
want her on the code all over again from a fresh start,

00:02:59.370 --> 00:03:00.620
we're able to do that.

00:03:00.620 --> 00:03:02.630
And as you guys can see,

00:03:02.630 --> 00:03:04.360
once I specified,

00:03:04.360 --> 00:03:08.750
why equals 10 as you guys can see from where it is in number seven,

00:03:08.750 --> 00:03:12.540
it's saying that eight squared is 10 which is mathematically and correct.

00:03:12.540 --> 00:03:16.710
About the reason is saying that is the cell previous to that I specified why,

00:03:16.710 --> 00:03:19.270
as being 10 I gave it a specific,

00:03:19.270 --> 00:03:20.350
hard courting number.

00:03:20.350 --> 00:03:24.680
So regardless of the equation which precedes it after the equation,

00:03:24.680 --> 00:03:27.710
you guys can see that the eight squared is 64 which is correct.

00:03:27.710 --> 00:03:28.370
But after that,

00:03:28.370 --> 00:03:29.160
I specified,

00:03:29.160 --> 00:03:30.390
why is being 10?

00:03:30.390 --> 00:03:31.510
So next time,

00:03:31.510 --> 00:03:34.000
every time it does that is going to specify why,

00:03:34.000 --> 00:03:34.990
as being 10.

00:03:34.990 --> 00:03:39.310
Just keep in mind that whenever you're running cold in a Jupiter notebook.

00:03:39.310 --> 00:03:40.150
Instances,

00:03:40.150 --> 00:03:41.900
they're going from top to bottom.

00:03:41.900 --> 00:03:49.770
So make sure you are aware that because if you have a significant number off cells that are

00:03:49.770 --> 00:03:52.600
running cold and they're in different orders,

00:03:52.600 --> 00:03:56.600
it might impact the results that you're trying to achieve.

00:03:56.600 --> 00:03:59.570
And lastly,

00:03:59.570 --> 00:04:04.200
you condone you've noticed that Jupiter gives an option to change the colonel and in fact,

00:04:04.200 --> 00:04:06.170
there many different options to choose from.

00:04:06.170 --> 00:04:11.700
So when you initially created the notebook from the dashboard by selecting python version,

00:04:11.700 --> 00:04:14.420
you can actually choose which Colonel you want to use.

00:04:14.420 --> 00:04:18.710
So not only are there kernels for different versions off Python,

00:04:18.710 --> 00:04:21.550
but they're literally over 100 languages,

00:04:21.550 --> 00:04:22.660
including Java,

00:04:22.660 --> 00:04:24.160
sea and even four track.

00:04:24.160 --> 00:04:24.830
So,

00:04:24.830 --> 00:04:26.740
as a data scientists you can,

00:04:26.740 --> 00:04:32.090
particularly a lot of from are interested in kernels For our and Julia as well as as both,

00:04:32.090 --> 00:04:32.870
Um,

00:04:32.870 --> 00:04:34.960
I'm at Lab and Callisto.

00:04:34.960 --> 00:04:36.740
Matt Lab Colonel Format Lab.

00:04:36.740 --> 00:04:37.330
The S.

00:04:37.330 --> 00:04:41.810
O S Colonel provides multi lane would support within single notebook.

00:04:41.810 --> 00:04:45.420
So each cardinal had just own installation instructions,

00:04:45.420 --> 00:04:49.050
but will likely require to run some commands on your computer.

00:04:49.050 --> 00:04:54.060
You have to make sure depending on what type off machine learning that you're trying to do

00:04:54.060 --> 00:04:54.060
,

00:04:54.060 --> 00:04:58.950
or what type of data analysis you're trying to do will determine what type of colonel

00:04:58.950 --> 00:04:59.990
you'll be working with.

00:04:59.990 --> 00:05:02.390
One of the most common ones is Python.

00:05:02.390 --> 00:05:06.980
That's why I have stuck with it for the purposes of my demonstrations.

00:05:06.980 --> 00:05:14.070
But just keep in mind that you are able to use any different kernel based on what type of

00:05:14.070 --> 00:05:15.650
data you're trying to analyze,

00:05:15.650 --> 00:05:19.110
missed on what type of data you're trying to analyze.

