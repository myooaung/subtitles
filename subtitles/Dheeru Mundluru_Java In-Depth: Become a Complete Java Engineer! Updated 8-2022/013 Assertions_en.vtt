WEBVTT
1
00:00:01.140 --> 00:00:07.620
Not let's look at assertions they are mainly about detecting errors during development and testing time

2
00:00:07.620 --> 00:00:08.370
.

3
00:00:08.370 --> 00:00:10.440
So let's see how they make that possible.

4
00:00:10.680 --> 00:00:16.760
In this listen to what assertions are along with their benefits in the next lesson they will leave office

5
00:00:16.770 --> 00:00:18.350
options.

6
00:00:19.380 --> 00:00:23.390
There are two factors that contribute to software and reliability.

7
00:00:23.670 --> 00:00:27.540
One is robustness while the other is correctness.

8
00:00:27.540 --> 00:00:34.080
Robustness is the software's ability to withstand any errors that may happen in exceptional situations

9
00:00:34.080 --> 00:00:34.980
.

10
00:00:35.010 --> 00:00:41.370
That is the software should continue to execute in such exceptional situations and we have seen throughout

11
00:00:41.400 --> 00:00:46.500
this chapter that this would be possible through exceptions and the corresponding exception handling

12
00:00:46.500 --> 00:00:47.960
mechanism.

13
00:00:47.970 --> 00:00:54.810
So what we have seen so far is all about robustness not Kirkman's as the name suggests deals with the

14
00:00:54.810 --> 00:00:57.780
software working correctly.

15
00:00:57.780 --> 00:01:01.350
And Sessions can help with correctness.

16
00:01:01.440 --> 00:01:07.620
Normally when we develop software we write a record based on what we gather from our product managers

17
00:01:07.770 --> 00:01:11.690
or any requirements documentation in the process.

18
00:01:11.850 --> 00:01:18.050
We make certain assumptions and most of the time these are options would be right but sometimes them

19
00:01:18.080 --> 00:01:24.130
emit wrongdo and it would be ideal could be kept them at development time itself.

20
00:01:25.080 --> 00:01:28.110
So an exemption would be either right or wrong.

21
00:01:28.530 --> 00:01:33.720
That is it is some kind of a boolean expression and we need to be able to test it.

22
00:01:34.140 --> 00:01:37.960
And Sessions are helpful and testing out as options.

23
00:01:37.980 --> 00:01:43.850
That is the correct method for programs and inserts statement has two forms.

24
00:01:44.040 --> 00:01:45.690
And here is the first one.

25
00:01:45.730 --> 00:01:50.350
In most keyword Essar followed by a boolean expression.

26
00:01:50.400 --> 00:01:56.340
So this statement gets the boolean expression if boolean expression evaluates to true then everything

27
00:01:56.340 --> 00:01:56.930
is good.

28
00:01:57.030 --> 00:01:59.430
Uncontrolled most of the next statement.

29
00:02:00.020 --> 00:02:03.480
Either way it implies that the program is not working correctly.

30
00:02:03.810 --> 00:02:10.100
That is there is something wrong in our assumption in this case and it is such an error is thrown.

31
00:02:10.199 --> 00:02:15.630
And the program is dominated immediately as there is no point continuing when the program is working

32
00:02:15.690 --> 00:02:17.090
incorrectly.

33
00:02:17.500 --> 00:02:23.010
As such an adder is a subclass of at a class and it is from the Dollard outline package.

34
00:02:23.010 --> 00:02:25.050
Here we have a couple of examples.

35
00:02:25.050 --> 00:02:29.630
First one is checking whether a reference variable named graph is null or not.

36
00:02:30.030 --> 00:02:33.870
If it is not then an assertion error will be wrong.

37
00:02:33.900 --> 00:02:39.530
Similarly a second example is checking whether the variable named index is greater than zero or normal

38
00:02:40.380 --> 00:02:42.200
if it is less than or equal to zero.

39
00:02:42.300 --> 00:02:45.400
And as such an order will be drawn.

40
00:02:46.200 --> 00:02:48.250
Here is the second form of Kasota statement.

41
00:02:48.430 --> 00:02:54.780
Here's the boolean expression is followed by a colon which is then followed by an error message.

42
00:02:55.020 --> 00:03:01.320
In this case if boolean expression evaluates to false then an assertion at a restaurant but is initialized

43
00:03:01.320 --> 00:03:03.250
with the error message.

44
00:03:03.300 --> 00:03:05.850
We can also see an example here.

45
00:03:06.800 --> 00:03:14.570
As for benefits assertions are very effective in quickly detecting bugs during development time and

46
00:03:14.570 --> 00:03:19.010
as a statement implies an assumption that you think is right.

47
00:03:19.530 --> 00:03:25.020
So if it fails for a particular instance of data then it means that you are as the it is wrong and you

48
00:03:25.020 --> 00:03:26.770
have to fix it.

49
00:03:27.620 --> 00:03:32.160
Moreover another might benefit as d also service documentation.

50
00:03:32.580 --> 00:03:36.420
In some situations assertions can be better than comments.

51
00:03:36.420 --> 00:03:42.360
For example let's assume that is a non-obvious competition and there is also a comment explaining it

52
00:03:42.370 --> 00:03:42.860
.

53
00:03:43.500 --> 00:03:49.650
But if some of the assumptions change and consequently the competition logic also changes then comments

54
00:03:49.650 --> 00:03:52.300
will also have to change.

55
00:03:52.470 --> 00:03:59.130
Otherwise comments would become out-of-date and hence will be out of sync with the code decisions on

56
00:03:59.130 --> 00:04:05.850
the other hand are check that on time on so would most likely fail and will force their Blipper to update

57
00:04:05.850 --> 00:04:08.070
them.

58
00:04:08.070 --> 00:04:12.590
So in that sense assertions are like active comments.

59
00:04:12.600 --> 00:04:19.130
Just the resources section where I included a few good pointers about benefits of assertions.

60
00:04:20.260 --> 00:04:26.060
Assertions can be used anywhere in the program but one good place to use them is for validating method

61
00:04:26.060 --> 00:04:27.030
parameters.

62
00:04:27.130 --> 00:04:31.890
As this particular item recommends release because this item is the last lesson.

63
00:04:31.950 --> 00:04:34.350
It's about validating metric parameters.

64
00:04:34.530 --> 00:04:39.350
If parameters have any restrictions which are also referred to as preconditions.

65
00:04:39.690 --> 00:04:43.880
So we perform some barometer checks for public methods.

66
00:04:43.950 --> 00:04:48.580
The items are just throwing an unchecked exception if there is a violation of it.

67
00:04:48.620 --> 00:04:50.330
Precondition.

68
00:04:50.520 --> 00:04:57.420
We know that this would be a programming error from the API client but for non-public methods like the

69
00:04:57.420 --> 00:05:01.590
private method the items are just using associates.

70
00:05:01.860 --> 00:05:09.490
You shouldn't use assertions for public methods for reasons one reason his assertions are disabled by

71
00:05:09.490 --> 00:05:10.370
default.

72
00:05:10.870 --> 00:05:16.080
So there wouldn't be any barometer of validity checks and consequently any programming errors from Abiah

73
00:05:16.150 --> 00:05:19.720
glance may go unnoticed.

74
00:05:19.720 --> 00:05:26.710
Second reason is assertions to the universal assertion error which might not be that helpful for API

75
00:05:26.710 --> 00:05:28.720
clients in fixing the problem.

76
00:05:29.380 --> 00:05:34.260
But for non-public methods API clients are not in working them directly.

77
00:05:34.480 --> 00:05:37.370
It is that in been the code that is invoking them.

78
00:05:37.750 --> 00:05:43.150
So the owner of the board would be expected to test them extensively during development.

79
00:05:43.250 --> 00:05:45.360
Get the help off as options.

80
00:05:45.640 --> 00:05:50.110
This way in production non-public methods should always be invoked bit.

81
00:05:50.200 --> 00:05:53.140
But I'm going to reduce.

82
00:05:53.230 --> 00:05:59.050
No if you recall when the unit is also about correctness like assertions.

83
00:05:59.340 --> 00:06:04.730
So the question would be Do we still need G-Unit or would only Jane itself wise.

84
00:06:04.930 --> 00:06:08.800
Or can we have both G-Unit as well as options.

85
00:06:08.950 --> 00:06:12.870
I would say as options would complement G-Unit what instance.

86
00:06:12.970 --> 00:06:16.980
Let's assume you do not have G-Unit on how only assertions.

87
00:06:16.990 --> 00:06:23.290
Now if you update some logic on your object and relevant assertions then how would you as the new logic

88
00:06:23.300 --> 00:06:23.880
.

89
00:06:24.210 --> 00:06:26.770
You mean tested with Vornado data instances.

90
00:06:27.110 --> 00:06:30.650
I would just hope that it would work for other kinds of The Doctor.

91
00:06:31.150 --> 00:06:37.540
But with you and it typically does the overcoaching Yes but different kinds of data in an automated

92
00:06:37.540 --> 00:06:39.370
way.

93
00:06:39.490 --> 00:06:44.590
We know that unit testing is all about automated repeatable dusting off.

94
00:06:44.590 --> 00:06:46.100
Program correctness.

95
00:06:46.410 --> 00:06:50.640
That is not if the program changes should break our desk Issus.

96
00:06:50.740 --> 00:06:54.860
So you definitely do need G-Unit also.

97
00:06:55.000 --> 00:07:01.830
G-Unit is generally about functioning of the entire metrics and not just about method parameters or

98
00:07:01.840 --> 00:07:03.850
a single statement within a method.

99
00:07:04.360 --> 00:07:10.990
So generally speaking G-Unit is about a block of code but with assertions most of the time you're dealing

100
00:07:10.990 --> 00:07:17.830
at a more granular level like a single statement or one on one method parameters but the granular level

101
00:07:17.830 --> 00:07:24.790
of testing is also important in validating our exemptions so we need both of them for program correctness

102
00:07:24.810 --> 00:07:25.070
.

103
00:07:25.380 --> 00:07:32.340
But J testing is definitely a required thing especially if you want to sleep peacefully.

104
00:07:32.350 --> 00:07:36.880
Also just note that g unit also had some kind of met that.

105
00:07:37.060 --> 00:07:37.570
Also true.

106
00:07:37.570 --> 00:07:45.040
An assertion error in case of any issues so G-Unit is making use of a standard exception as recommended

107
00:07:45.040 --> 00:07:50.890
by one of the effective dhal items which were discussed earlier.

108
00:07:50.950 --> 00:07:57.040
Finally assertions are disabled by default to ensure that they are not performance liability on production

109
00:07:57.040 --> 00:08:00.010
systems to enable them.

110
00:08:00.000 --> 00:08:06.480
The command line option hyphenate can be passed with a job lined up later as transfer enabled as options

111
00:08:06.550 --> 00:08:06.880
.

112
00:08:07.290 --> 00:08:12.280
Alternatively hyphen an able assertions can also be used.

113
00:08:12.310 --> 00:08:18.970
Assertions can be enabled disabled at specific class and package levels too put the sibling heifer India

114
00:08:19.180 --> 00:08:22.360
or hyphen miscible exceptions can be used.

115
00:08:23.250 --> 00:08:24.310
Here's an example.

116
00:08:24.400 --> 00:08:28.650
Their assertions are unable that a class level here that enabled.

117
00:08:28.690 --> 00:08:34.380
Only for the class hello and for all other classes that are disabled which as we said is their default

118
00:08:34.380 --> 00:08:35.830
behavior.

119
00:08:35.909 --> 00:08:41.700
As you can see we have the year flag followed by a colon which is in turn followed by a fully qualified

120
00:08:41.710 --> 00:08:47.530
class name and that's how you enable it for a single class.

121
00:08:47.530 --> 00:08:54.040
This example shows disabling off assertions at a class level so the previous one was an Eberling across

122
00:08:54.040 --> 00:08:54.530
level.

123
00:08:54.610 --> 00:08:57.330
Well this one is about disabling.

124
00:08:57.330 --> 00:09:04.120
Your assertions are unable dupatta you like but they are disabled only for that class Hello.

125
00:09:04.450 --> 00:09:11.630
What it means is assertions are enabled for the class Miklas on any class as it may be accessing with

126
00:09:11.640 --> 00:09:15.150
the exception of Hello class.

127
00:09:15.150 --> 00:09:20.190
No this example shows discipling of assertions at package level here.

128
00:09:20.200 --> 00:09:23.330
Assertions or anybody from my class and he grasps it.

129
00:09:23.320 --> 00:09:27.130
Maybe accessing except for all classes in the package.

130
00:09:27.120 --> 00:09:32.170
Com dot semantics career 3.0 suggest a package.

131
00:09:32.160 --> 00:09:38.320
So basically if you're dealing with specific class or package then you or be flag will be followed by

132
00:09:38.320 --> 00:09:42.310
a colon which isn't followed by class or package name.

133
00:09:42.550 --> 00:09:49.600
Just having an able flag by itself will enable assertions in Gendron having just disable flag by itself

134
00:09:49.750 --> 00:09:53.920
has no effect as as options are disabled by default.

135
00:09:54.610 --> 00:10:00.190
Ideally assertions should help in fixing all issues during development time and should be turned off

136
00:10:00.280 --> 00:10:01.670
during production.

137
00:10:02.230 --> 00:10:06.180
So that's what assertions and we will look at them off as options.

138
00:10:06.280 --> 00:10:06.730
Thank you

