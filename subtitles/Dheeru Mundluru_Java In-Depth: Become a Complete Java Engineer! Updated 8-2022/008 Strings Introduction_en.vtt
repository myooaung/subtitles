WEBVTT
1
00:00:01.070 --> 00:00:07.370
Now let's look at strings of string manipulation is one of the most common activities in programming

2
00:00:07.370 --> 00:00:08.260
.

3
00:00:08.270 --> 00:00:14.690
That's because strings represent text and we know that it is impossible to imagine any application VIDOT

4
00:00:14.750 --> 00:00:20.090
next strings in are unique due to the way they get stored internally.

5
00:00:20.340 --> 00:00:25.320
If you don't have a clear understanding of strings in Java then you may end up writing very inefficient

6
00:00:25.320 --> 00:00:26.010
code.

7
00:00:26.330 --> 00:00:31.010
So to try to cover everything related to strings so that we can use it in the right way.

8
00:00:32.590 --> 00:00:39.400
A string is simply an object of the class jobs are not blank docstring the fact that stringless is part

9
00:00:39.400 --> 00:00:43.550
of our Rockline package tells us that it is a fundamental class job.

10
00:00:45.160 --> 00:00:49.540
So we can simply instantiate the String class to create String objects.

11
00:00:49.540 --> 00:00:57.110
In this case a variable S represents an empty string not if you want a variable as to represent some

12
00:00:57.170 --> 00:01:01.050
text like hello then we can invoke a different constructor.

13
00:01:01.460 --> 00:01:05.930
In this example the argument passed to the constructor is a Citrin return.

14
00:01:06.200 --> 00:01:12.580
So a string literal consists of zero or more characters enclosed in double quotes Well Carter letters

15
00:01:12.580 --> 00:01:14.200
are enclosed in single quotes.

16
00:01:14.200 --> 00:01:20.330
String literals are enclosed in double quotes know this particular constructor has a single parameter

17
00:01:20.630 --> 00:01:28.220
that is an object reference of byte string so it means that you DOCSIS String objects it also means

18
00:01:28.220 --> 00:01:31.940
that a string literal is also a String object.

19
00:01:32.540 --> 00:01:39.720
So intimately as ringleader is Bastos a string object or insert a string we can you can also pass an

20
00:01:39.810 --> 00:01:46.420
object reference of by a string that is all we are creating an object reference of pipe string.

21
00:01:46.420 --> 00:01:54.040
We are creating it by passing another object reference as input to the constructor Alternatively you

22
00:01:54.050 --> 00:01:59.760
can also do this very first create a character tree representing the text Hello.

23
00:02:00.010 --> 00:02:07.160
Then the characters race past us and put to run off the constructor's finally we can also create strengths

24
00:02:07.460 --> 00:02:14.690
just like the way we create perimeter variables simply assign a string literal with a variable as not

25
00:02:14.690 --> 00:02:18.160
that he had available as is still an object reference.

26
00:02:18.470 --> 00:02:22.680
So don't think that it's a primitive variable just because we are sending a letter.

27
00:02:23.120 --> 00:02:26.410
You can also see that the variable type is a class or not.

28
00:02:26.420 --> 00:02:33.180
But it go get a Also this is the recommended way to create strings are strings created using string

29
00:02:33.180 --> 00:02:38.410
literals are internally implemented in an efficient way as we will soon see.

30
00:02:38.730 --> 00:02:43.770
So all the previous approaches of creating strings using the new keyword are not recommended.

31
00:02:46.120 --> 00:02:54.360
Not that in Donelly string class use a psychotic rate to that text but we know that in characters I

32
00:02:54.360 --> 00:03:00.210
didn't and the data presented using you'd be 16 and coding scheme which is an implementation of Unicode

33
00:03:00.220 --> 00:03:08.400
characters that what this means is that a string in Java is basically a sequence off Unicode characters

34
00:03:09.320 --> 00:03:15.290
here we are using the term sequence as strings and Dunalley using characters to store that text.

35
00:03:17.210 --> 00:03:19.640
Estrin in July is also immutable.

36
00:03:20.090 --> 00:03:24.860
That is once a string of dip is created its value can never be changed.

37
00:03:25.100 --> 00:03:33.050
String mutability will be discussed later so always keep in mind that a string object basically contains

38
00:03:33.050 --> 00:03:36.670
an immutable sequence of Unicode characters.

39
00:03:38.480 --> 00:03:42.070
String is given special treatment in Java it's common usage.

40
00:03:42.440 --> 00:03:48.970
Let's look at some off its special features we have already seen that like primitives a string can be

41
00:03:48.970 --> 00:03:52.930
constructed by directly assigning a string literal.

42
00:03:52.930 --> 00:04:00.100
You can do this for regular job objects but one exception is baulks primitives or wrapper classes which

43
00:04:00.100 --> 00:04:03.270
we briefly discussed while covering switch statements.

44
00:04:03.270 --> 00:04:06.180
They can be directly assigned litotes also.

45
00:04:06.310 --> 00:04:13.170
For example an object reference of type integer can be directly assigned an int..

46
00:04:13.270 --> 00:04:15.290
We'll be looking at baulks primitives later.

47
00:04:17.010 --> 00:04:22.740
If you recall we mentioned that bless our pricker which is one of the Artomatic operators can also be

48
00:04:22.740 --> 00:04:29.490
additionally used for string concatenation that is as you can see here we can use bless to concatenate

49
00:04:29.620 --> 00:04:30.160
strings.

50
00:04:30.230 --> 00:04:31.520
Hello and goodbye.

51
00:04:31.970 --> 00:04:39.260
So bailable as we be the little hello world literally a lot to discuss about string concatenation as

52
00:04:39.260 --> 00:04:47.440
there is a performance implication associated with it finally all strings created using string literals

53
00:04:47.680 --> 00:04:53.900
are stored in a special area of memory called string this does not happen with strings that are created

54
00:04:53.900 --> 00:04:55.470
using nucula.

55
00:04:55.880 --> 00:05:02.050
That is they don't get stored in that string when the main benefit that drink will provide is that if

56
00:05:02.290 --> 00:05:08.080
strings are created using the same string return then they both would be represented by the same string

57
00:05:08.080 --> 00:05:09.700
object in the string.

58
00:05:10.150 --> 00:05:12.320
So basically memory is served here.

59
00:05:12.910 --> 00:05:18.700
But if you create two strings with a Nuki word and they both have the same text then they are still

60
00:05:18.710 --> 00:05:21.820
represented by different string objects.

61
00:05:21.820 --> 00:05:27.030
This was the reason why it was recommended to create strings by assigning literals are not true.

62
00:05:27.040 --> 00:05:35.120
Using the new keyword and you have even discussed Trinkle later in detail in a lesson so that's about

63
00:05:35.120 --> 00:05:35.840
it.

64
00:05:35.840 --> 00:05:41.020
We now understand what a string is and how it can be created in the next few lessons.

65
00:05:41.030 --> 00:05:43.520
We will try to explore everything about strings

