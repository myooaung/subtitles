WEBVTT
1
00:00:01.070 --> 00:00:06.570
Not just look at it later which helps in it creating elements these are an exception in the previous

2
00:00:06.570 --> 00:00:10.820
lesson and we'll see how it can be prevented by using any.

3
00:00:12.120 --> 00:00:18.890
And it there is simply an interface and to access an instance of a character Vinita in the IT DID IT

4
00:00:18.890 --> 00:00:25.800
AND method that is declared in the interface which is from the Gelada lying package because the collection

5
00:00:25.800 --> 00:00:32.090
interface extends the digital interface on collection implementations like the deadliest implement.

6
00:00:32.140 --> 00:00:38.310
It did it at a method by extending it above that collection interfaces saying that its elements can

7
00:00:38.310 --> 00:00:46.380
be triggered from each statement or request any object it takes to implement the table interface later

8
00:00:46.380 --> 00:00:47.050
in the demo.

9
00:00:47.130 --> 00:00:50.620
We will actually test this out as we can see here.

10
00:00:50.730 --> 00:00:56.460
You did have an interface that's three minutes later for each and speculator you did it that is abstract

11
00:00:56.590 --> 00:01:00.690
when the other two are different methods which are what I did in July 8.

12
00:01:00.930 --> 00:01:07.180
So the interface provides a different implementation for these last two methods that are meant there

13
00:01:07.200 --> 00:01:07.300
.

14
00:01:07.380 --> 00:01:13.020
As mentioned earlier written an iterator which can be used for it reading the elements of the collection

15
00:01:14.030 --> 00:01:20.170
internally for each statement also invokes this method for dating the collection elements.

16
00:01:20.520 --> 00:01:26.580
Next is for each method and this method can be in-road if we want to perform certain action for each

17
00:01:26.580 --> 00:01:28.410
element of the collection.

18
00:01:28.620 --> 00:01:34.920
And this action would be a method in an object which is passed us input but for each method.

19
00:01:34.920 --> 00:01:38.590
Hence we can see that the parameter name here is action.

20
00:01:38.670 --> 00:01:44.660
So the method that is part of the input object will be invoked for each element of the collection and

21
00:01:44.690 --> 00:01:48.500
the methods input will be the element itself.

22
00:01:48.540 --> 00:01:51.920
So the method would how only a single parameter.

23
00:01:51.960 --> 00:01:57.840
Now you can see that the parameter type for this for each method is consumer which is an interface that

24
00:01:57.840 --> 00:01:59.020
was introduced in July.

25
00:01:59.030 --> 00:02:03.550
It doesn't if it has a single abstract matter will accept.

26
00:02:04.130 --> 00:02:09.990
So we need to pass either an instance of consumer which implements accepte method or we can pass lambda

27
00:02:09.990 --> 00:02:15.720
expressions on method references which are Djala 8 features that we will discuss later.

28
00:02:15.720 --> 00:02:17.590
So let's not worry about this method for now.

29
00:02:17.880 --> 00:02:23.580
But to briefly look at it in our Demel tournament with the disputed rigor which is also ordered in Java

30
00:02:23.580 --> 00:02:29.670
8 and we're also not going to discuss it for now but it seems to be mainly useful for splitting elements

31
00:02:29.670 --> 00:02:36.110
of collection into partitions so that we can process those partitions using some interrupts.

32
00:02:36.270 --> 00:02:41.190
So if we have elements which would run into several hundreds of millions then this method can be used

33
00:02:41.400 --> 00:02:47.160
to partition those elements on unprocessed does partitions through some parallel competition.

34
00:02:47.160 --> 00:02:49.390
That way it would be very efficient.

35
00:02:49.430 --> 00:02:54.010
We may look at it later but it is definitely not important for now.

36
00:02:54.480 --> 00:02:59.990
And here is likely to create an interface if you will that it did it in matter of our list Egerton's

37
00:03:00.000 --> 00:03:06.600
an instance of this interface idlest basically has a nested class which implements this interface.

38
00:03:06.720 --> 00:03:12.070
So an instance of that master class will be returned when it did it at a method is invoked.

39
00:03:12.230 --> 00:03:17.120
It can be used to all of the elements of the collection we already know that.

40
00:03:17.520 --> 00:03:23.310
But in addition it also lets you remove an element during their duration which we could not do in the

41
00:03:23.310 --> 00:03:24.360
previous demo.

42
00:03:25.160 --> 00:03:30.390
And the use skills for this could be that you may have to do with a list of elements from the database

43
00:03:30.520 --> 00:03:31.080
.

44
00:03:31.100 --> 00:03:34.920
Now you want to the most some of them which meet certain criteria.

45
00:03:35.250 --> 00:03:42.160
In this case as we address the elements VIGEN be the ones which meet that criteria are needed it has

46
00:03:42.220 --> 00:03:42.910
this format.

47
00:03:42.930 --> 00:03:48.660
It's obviously remore would be used for removing an element forEachRamaining meaning that there is a

48
00:03:48.660 --> 00:03:54.570
default method which is similar to the from each method and it did it all end of his let's actually

49
00:03:54.570 --> 00:03:58.890
head over to eclipse to see how all these methods work.

50
00:04:00.160 --> 00:04:00.430
OK.

51
00:04:00.430 --> 00:04:02.810
Before we implement it today the related code.

52
00:04:03.180 --> 00:04:06.730
Let's take a look at the exception that we got in the previous demo.

53
00:04:06.750 --> 00:04:09.020
So here we are in the list Demopolis.

54
00:04:09.150 --> 00:04:14.610
And here we are iterating through the elements of the order list and when we reach the element which

55
00:04:14.610 --> 00:04:20.100
is the second element we are trying to remove that element and that's when we're getting this exception

56
00:04:20.100 --> 00:04:22.440
called concurrent modification exception.

57
00:04:22.470 --> 00:04:26.610
So let's just go ahead and run this program.

58
00:04:26.640 --> 00:04:27.550
So here we are.

59
00:04:27.600 --> 00:04:32.250
So when we run it when we reach element 9 the element 9 is getting branded.

60
00:04:32.370 --> 00:04:37.350
And then when we tried to remove that element we are getting this exception called concurrent modification

61
00:04:37.350 --> 00:04:39.130
exception.

62
00:04:39.240 --> 00:04:42.330
We'll see how this can be prevented using a good actor.

63
00:04:42.420 --> 00:04:49.700
So let me just comment this ok no one change I made in this method is rerouting the other list in the

64
00:04:49.700 --> 00:04:51.690
earlier the more we were turning a wide.

65
00:04:51.710 --> 00:04:57.210
So now we are reading and we are returning an hour elapsed and then the main matter.

66
00:04:57.650 --> 00:04:58.800
Here we are.

67
00:04:59.270 --> 00:05:04.890
So the the other is a miser getting an alias so be it assigning it to an other list here or list under

68
00:05:04.950 --> 00:05:06.420
invoking that pneumatic call.

69
00:05:06.440 --> 00:05:07.440
It did it demo.

70
00:05:07.490 --> 00:05:11.150
And we are passing this list as an argument.

71
00:05:11.150 --> 00:05:13.180
And here is the new method.

72
00:05:13.430 --> 00:05:15.980
So let's just go ahead and finish this matter.

73
00:05:16.370 --> 00:05:18.750
So the input parameter is list.

74
00:05:19.160 --> 00:05:24.980
So we know that in order to get the data we need to enroll it in it and get there off idlest on the

75
00:05:24.980 --> 00:05:25.540
list.

76
00:05:25.550 --> 00:05:26.480
So let's do that.

77
00:05:26.540 --> 00:05:34.720
So it's just an iterator here and its name it does it later.

78
00:05:34.730 --> 00:05:39.620
Now this one would return an instance of it did it or interface.

79
00:05:39.650 --> 00:05:45.610
And since the list has integers so the Jenrette notation would include integer.

80
00:05:45.700 --> 00:05:48.540
OK now we need to iterate it unfolded it.

81
00:05:48.560 --> 00:05:56.420
We can use either a white or a look but normally do it direct using an iterator wide loop is more cleaner

82
00:05:56.420 --> 00:05:56.460
.

83
00:05:56.480 --> 00:06:00.130
So let's use dot here.

84
00:06:00.140 --> 00:06:06.160
All we need to do is say it greater DOT has Next we need to invoke the has an X method.

85
00:06:06.290 --> 00:06:07.490
So Hasenfus McMurtry.

86
00:06:07.520 --> 00:06:10.260
Either a true or false if it returns true.

87
00:06:10.280 --> 00:06:13.930
It means that there are more elements to be evaluated.

88
00:06:13.940 --> 00:06:18.870
Now if it returns false it means that we are done with it rating through all the elements.

89
00:06:19.040 --> 00:06:21.970
OK so now let's assume that it has returned true.

90
00:06:21.980 --> 00:06:23.610
That's right the body here.

91
00:06:24.050 --> 00:06:30.700
So in order to get the next element we need to just invoke the next method.

92
00:06:31.810 --> 00:06:34.040
And the next method would read and the next element.

93
00:06:34.220 --> 00:06:40.440
But since this is this idlest has integers let's assign it to an integer here it's called it does a

94
00:06:40.500 --> 00:06:42.750
element here.

95
00:06:43.310 --> 00:06:43.610
OK.

96
00:06:43.640 --> 00:06:49.400
So this would automatically unblocks and would assign it to the meadow.

97
00:06:49.910 --> 00:06:53.150
And let's also bring this element here.

98
00:06:53.150 --> 00:07:01.090
Now we know that if element equals nine we need to remove it.

99
00:07:01.380 --> 00:07:08.830
And for that we can use the every moment third on the letter K and it's also printed here.

100
00:07:08.900 --> 00:07:12.520
So let's go under on this.

101
00:07:12.530 --> 00:07:16.510
So as you can see initially there are five elements of 1 9 8 6 and 1.

102
00:07:16.610 --> 00:07:20.810
So after removing the element only four elements are there.

103
00:07:20.890 --> 00:07:21.340
OK.

104
00:07:21.470 --> 00:07:23.450
That is what is getting printed here.

105
00:07:23.600 --> 00:07:29.300
So we no longer get to get that particular exception called concurrent modification exception.

106
00:07:29.390 --> 00:07:33.920
So if you want to remove an element during a duration need to use the editor.

107
00:07:33.950 --> 00:07:36.280
So that's the main benefit of it.

108
00:07:36.560 --> 00:07:42.830
Now we also mentioned that in order to integrate this object list one for example in this because it's

109
00:07:42.830 --> 00:07:47.750
an analyst has to implement the interface and we know that it implements they did have an interface

110
00:07:47.750 --> 00:07:48.290
.

111
00:07:48.440 --> 00:07:53.630
So if it doesn't implement a terrible interface then we would get a compilation error which means that

112
00:07:53.630 --> 00:07:56.590
we cannot it the elements of the collection.

113
00:07:56.600 --> 00:08:01.990
No let's say for example for instance we want to iterate through the list M-y itself.

114
00:08:02.110 --> 00:08:09.740
OK so let's create an object here as you can see if we get a compile error it says can only iterate

115
00:08:09.830 --> 00:08:13.880
over an array or an instance off of July Dr. Langhart.

116
00:08:13.910 --> 00:08:14.230
It did.

117
00:08:14.240 --> 00:08:18.980
But so this particular class this demo is not implementing it did happen.

118
00:08:18.980 --> 00:08:22.130
So let's just go ahead and make it implement.

119
00:08:22.130 --> 00:08:22.840
It did.

120
00:08:23.030 --> 00:08:24.700
So let's go here.

121
00:08:24.740 --> 00:08:25.250
Here it is.

122
00:08:25.250 --> 00:08:32.240
Let me just uncommon this so it is implementing and it did have it but it was a compilation error because

123
00:08:32.240 --> 00:08:36.210
we need to implement unimplemented methods which is that it did it.

124
00:08:36.230 --> 00:08:38.640
So we need to implement a method here.

125
00:08:38.870 --> 00:08:40.429
So let's do that.

126
00:08:41.010 --> 00:08:42.900
I'd say public.

127
00:08:42.900 --> 00:08:45.980
It should have done it better off and deeper

128
00:08:48.770 --> 00:08:55.670
and could be delayed or monitored and it should return an instance of a director because right I would

129
00:08:55.670 --> 00:09:04.160
only do later are in this case since we are just doing a demo on let's just see new idlest let's use

130
00:09:04.160 --> 00:09:08.030
the it did it at off what it asked.

131
00:09:08.210 --> 00:09:14.600
So in this case it would been ambulanced are now you can see that there is no more no more exception

132
00:09:14.600 --> 00:09:15.830
here competition.

133
00:09:16.160 --> 00:09:18.130
There is no computer that are here anymore.

134
00:09:18.320 --> 00:09:21.610
So it is able do here.

135
00:09:21.770 --> 00:09:24.360
So which means that the list is a little bit long.

136
00:09:24.540 --> 00:09:25.120
OK.

137
00:09:25.370 --> 00:09:26.570
So that's what you need to do.

138
00:09:26.570 --> 00:09:32.320
You need to implement the interface if you want your objects to be iterated.

139
00:09:32.430 --> 00:09:36.340
If you are elements to be triggered not like me change it back.

140
00:09:36.620 --> 00:09:37.560
Good list.

141
00:09:37.760 --> 00:09:46.070
So what it means is what it meant internally it invokes the the later method off the object that is

142
00:09:46.070 --> 00:09:52.620
here and then it uses the instance that is returned by the director who did it with the elements.

143
00:09:52.760 --> 00:09:57.530
OK so it is internally going to invoke the method of this particular object.

144
00:09:58.140 --> 00:09:58.780
OK.

145
00:09:59.050 --> 00:10:04.780
Now the reason why this concussion modification exception has generated is because it is actually generated

146
00:10:04.780 --> 00:10:07.830
by the data that is internally written.

147
00:10:08.320 --> 00:10:16.480
So on VH1 and it is a rating it is using the data internally to get the elements but externally here

148
00:10:16.490 --> 00:10:24.300
within this method it is trying to remove some limit and it does not allow us to do that.

149
00:10:24.310 --> 00:10:28.840
So it does not allow us to concurrently modify the underlying idlest.

150
00:10:28.880 --> 00:10:32.070
So that's why it's called a concurrent modification exception.

151
00:10:32.170 --> 00:10:37.160
And if we tried to do that the next method the next method within the iterator.

152
00:10:37.280 --> 00:10:40.210
Through this concurrent modification exception.

153
00:10:40.220 --> 00:10:47.050
For instance you may be able to remove this element but then in the next iteration Venite window for

154
00:10:47.050 --> 00:10:55.510
each statement internally when it tries to use the next method then the underlying iterator built through

155
00:10:55.510 --> 00:11:00.800
that exception the the next method with toady's concurrent modification exception because it does not

156
00:11:00.790 --> 00:11:03.660
allow us to concurrently modify the audio list.

157
00:11:03.830 --> 00:11:10.400
OK so now when it means modification it means structural modification and structural modification would

158
00:11:10.390 --> 00:11:16.180
be either removing an element or adding an element of adding an element.

159
00:11:16.270 --> 00:11:21.430
We would see in the next lesson when rediscuss listed character which is a sub interface of a character

160
00:11:21.480 --> 00:11:21.710
.

161
00:11:21.830 --> 00:11:25.080
So you can also add an element using glister detector.

162
00:11:25.150 --> 00:11:31.850
So if you structurally modify either using art or a moment that's then we get this exception but replacement

163
00:11:31.850 --> 00:11:32.270
is fine.

164
00:11:32.260 --> 00:11:33.640
You can use Set method.

165
00:11:33.640 --> 00:11:38.070
There is in list distributor which you will see again in the next lesson.

166
00:11:38.120 --> 00:11:41.950
So that is fine as long as it is not concurrent modification.

167
00:11:41.950 --> 00:11:47.150
We are good but if it is going to go and modification it is not possible to do it.

168
00:11:47.140 --> 00:11:48.870
We will get this exception.

169
00:11:48.880 --> 00:11:53.740
And if it has to be concurrently I mean if it has to be modified structurally modified then it can be

170
00:11:53.750 --> 00:11:57.190
done only one way which is using it did it at itself.

171
00:11:57.190 --> 00:12:02.690
So you can either use the you can use the remote method offer did it as we have seen and that gives

172
00:12:02.680 --> 00:12:03.460
it just fine.

173
00:12:03.700 --> 00:12:09.700
But if we are trying to modify the structure in any way other than using the methods of a director then

174
00:12:09.700 --> 00:12:11.030
we will get this exception.

175
00:12:11.160 --> 00:12:11.670
OK.

176
00:12:11.950 --> 00:12:17.420
On such an iterator which gives a concrete modification exception is called as a fail fast.

177
00:12:17.440 --> 00:12:18.040
It did it.

178
00:12:18.230 --> 00:12:19.940
It's called Failed fast.

179
00:12:19.930 --> 00:12:26.380
The reason is because it is failing fast it is failing quickly and all that general purpose implementations

180
00:12:26.380 --> 00:12:29.660
like are a list link list and so on.

181
00:12:29.870 --> 00:12:31.720
Do implement do support only fail fast.

182
00:12:31.730 --> 00:12:37.830
It does get so they do throw this exception so that it can get an modification exception and do.

183
00:12:37.880 --> 00:12:43.240
Why did we need to we can modify the structure thought it is using an iterator.

184
00:12:43.250 --> 00:12:44.680
OK so that's the iterator.

185
00:12:44.770 --> 00:12:46.330
That's all you need to know about it.

186
00:12:46.580 --> 00:12:52.600
But we also looked at the for each method in the interface and we also look for each of the meaning

187
00:12:52.690 --> 00:12:52.860
.

188
00:12:52.940 --> 00:12:56.140
Ok so those I don't think we will use it very often.

189
00:12:56.140 --> 00:13:00.350
For each Maybe we will use but I don't think for each of the meaning we will use it very often.

190
00:13:00.400 --> 00:13:02.600
I don't see any uses for that.

191
00:13:02.600 --> 00:13:07.740
So you might argue use it very much so but for the sake of completeness let's also look at those matters

192
00:13:07.750 --> 00:13:08.970
.

193
00:13:09.040 --> 00:13:10.470
So it's already here.

194
00:13:10.820 --> 00:13:16.970
So here we are calling for each method and which is a declared an incredible interface.

195
00:13:16.960 --> 00:13:17.270
OK.

196
00:13:17.330 --> 00:13:20.160
So we would just say our IList object not for each.

197
00:13:20.550 --> 00:13:24.730
And here for each of the input the input parameter is consumer.

198
00:13:24.760 --> 00:13:27.580
But we said that it can be invoked using a matter reference.

199
00:13:27.590 --> 00:13:30.310
So this is metadata for instance this is something new for us.

200
00:13:30.320 --> 00:13:33.580
So here we are just passing a reference to the matter.

201
00:13:33.700 --> 00:13:39.370
So the method is putting a line on this Prindle and motard system dot dot print Dalen will be invoked

202
00:13:39.380 --> 00:13:43.140
for each element off the order list.

203
00:13:43.480 --> 00:13:48.530
And that element will also be passed as input with the print on and printed on method.

204
00:13:48.620 --> 00:13:52.150
OK so let's just go ahead and run it.

205
00:13:53.140 --> 00:13:55.930
Actually let me Coleman this out here it's

206
00:14:00.870 --> 00:14:02.830
not real good.

207
00:14:02.990 --> 00:14:09.040
So as you can see these four elements are printed by them for each for each motard in location 1 8 6

208
00:14:09.040 --> 00:14:09.580
and 1.

209
00:14:09.660 --> 00:14:10.470
OK.

210
00:14:10.490 --> 00:14:13.610
Now let me comment it out.

211
00:14:13.730 --> 00:14:21.040
Now I haven't done a matter call your filter sorry a classical filter here and that filter glass also

212
00:14:21.040 --> 00:14:23.140
has a method called Filter.

213
00:14:23.240 --> 00:14:24.970
So we are here we are.

214
00:14:25.580 --> 00:14:30.010
And it would print an element only if input.

215
00:14:30.270 --> 00:14:32.950
But I mean if the value passed in what parameter is 1.

216
00:14:32.990 --> 00:14:36.190
So it's just earlier we hope the print doesn't matter.

217
00:14:36.190 --> 00:14:41.910
Here we are invoking the free delimiter of our own custom class that we have done.

218
00:14:42.220 --> 00:14:43.250
OK so far.

219
00:14:43.250 --> 00:14:47.790
When we look at the reference we use this Colons double 2 colons here.

220
00:14:47.840 --> 00:14:49.060
So let me just print it.

221
00:14:49.120 --> 00:14:54.740
But in this case it would print only 1 and 1 and that's because the filter method is of the four elements

222
00:14:54.790 --> 00:14:56.290
at this printing only one.

223
00:14:56.360 --> 00:14:56.820
OK.

224
00:14:56.920 --> 00:14:59.340
Because there are 1 8 6 and 1.

225
00:14:59.440 --> 00:15:05.000
So here the filter that we are applying is 1 if we are saying if it is I equals one or need an open

226
00:15:05.020 --> 00:15:05.940
ended.

227
00:15:06.220 --> 00:15:12.310
So that's the one on the third one as we can either posit matter differences or lambda us which are

228
00:15:12.320 --> 00:15:17.630
Djala 8 features are we can also pass an instance of consumer.

229
00:15:17.650 --> 00:15:22.930
Can I read is giving a compilation error because we need to implement the consumer interface.

230
00:15:22.930 --> 00:15:27.730
Ok so we need to implement it because the filter here is not implementing it.

231
00:15:27.740 --> 00:15:30.050
So let me uncommon did.

232
00:15:30.100 --> 00:15:34.540
Now it implements the Kansi you want interface which has only a method called accept.

233
00:15:34.780 --> 00:15:37.590
So we need to do this method gets invoked now.

234
00:15:37.930 --> 00:15:43.350
So it is also doing the same thing printing the elemental if I is equal to 1.

235
00:15:43.390 --> 00:15:46.660
So as you can see there is no more compilation error.

236
00:15:46.660 --> 00:15:48.990
I don't need that element one is getting another.

237
00:15:49.250 --> 00:15:55.240
OK so even in this case when we are invoking the method through using a method reference in dentally

238
00:15:55.450 --> 00:15:56.160
there some magic.

239
00:15:56.170 --> 00:16:01.850
I think it's dynamic by using dynamic proxy or whatever it internally in the byte code.

240
00:16:02.330 --> 00:16:09.420
We will be passing an instance of guns you would get passed on that instance would include the accepte

241
00:16:09.430 --> 00:16:10.180
method.

242
00:16:10.420 --> 00:16:15.260
So the instance will be created everything will be done internally itself inside the bytecode the compiler

243
00:16:15.250 --> 00:16:16.110
will do that.

244
00:16:16.450 --> 00:16:23.170
So so so that they can get off in Bonaly so it will still pass an instance of consumer even though it

245
00:16:23.170 --> 00:16:24.430
is a matter reference.

246
00:16:24.740 --> 00:16:27.290
So that is done internally but let's not worry about it.

247
00:16:27.280 --> 00:16:30.120
Now finally let's look at for each of the many.

248
00:16:30.130 --> 00:16:36.100
So it's a bit confusing this for each motard on for each of the meeting mattered since they have similar

249
00:16:36.560 --> 00:16:40.920
names for each is inside is defined by terrible.

250
00:16:40.930 --> 00:16:45.160
But for each any meaning is defined by the interface.

251
00:16:45.420 --> 00:16:46.850
It's also a Djala 8.

252
00:16:47.120 --> 00:16:51.090
And here we are in working the odd matter in the filter and the augmented.

253
00:16:51.110 --> 00:16:56.510
All it does is it adds this value 7 to the element unfussy each new meaning.

254
00:16:56.530 --> 00:16:58.300
All it does is.

255
00:16:58.540 --> 00:17:01.060
So so far we have two elements.

256
00:17:01.100 --> 00:17:03.850
The first element and the second element was nine here.

257
00:17:03.880 --> 00:17:09.460
So nine is that the matter is activated and once we reach nine we are removing it.

258
00:17:09.660 --> 00:17:12.710
And for all the subsequent elements 8 6 and 1.

259
00:17:12.760 --> 00:17:17.000
So we are saying for each remaining element in will the add method.

260
00:17:16.990 --> 00:17:21.460
So basically the remaining three elements will be activated by this method itself.

261
00:17:21.599 --> 00:17:24.839
And so the wild method will not continue to exit.

262
00:17:25.069 --> 00:17:30.460
OK so all the remaining elements will be directed by using through this single location.

263
00:17:30.490 --> 00:17:36.230
So that's where it says it is Galdos for each remaining again for each here for each method we do for

264
00:17:36.220 --> 00:17:41.970
all of the elements but for each remaining is all it did it through all the uninitiated elements the

265
00:17:42.010 --> 00:17:44.370
items that were not iterated so far.

266
00:17:44.380 --> 00:17:47.080
So let's just go ahead and run this.

267
00:17:47.140 --> 00:17:54.800
So it is for each of the meaning here as printing Rufin because 7 was added to 8 in the Agde method

268
00:17:55.340 --> 00:18:00.360
and 6 7 was added to 6 which resulted in 13 and 7 was added to 1.

269
00:18:00.380 --> 00:18:05.630
So the last three elements for the last three elements this method I'd got I got involved.

270
00:18:05.710 --> 00:18:08.830
So that's for each remaining but I don't think you will use it very much.

271
00:18:08.840 --> 00:18:09.610
So that's about it.

272
00:18:09.620 --> 00:18:10.740
So that's the iterator.

273
00:18:10.760 --> 00:18:15.620
The main advantage as you can direct and at the same time you can also remove the elements and we also

274
00:18:15.620 --> 00:18:20.600
looked at for each unflushed each remaining richer Gela 8 features.

275
00:18:20.600 --> 00:18:26.780
Now one thing I forgot to mention is that the location of that of a moment there must be must be preceded

276
00:18:26.870 --> 00:18:29.260
by the invocation of next method.

277
00:18:29.330 --> 00:18:33.470
OK so only after you invoke the next method will you be able to invoke the right moment.

278
00:18:33.530 --> 00:18:38.770
Otherwise we get a compilation error because that implementor would remove the element that was returned

279
00:18:38.890 --> 00:18:40.220
by the next method.

280
00:18:40.400 --> 00:18:41.020
OK.

281
00:18:41.240 --> 00:18:45.220
So if you can be taught in walking next then we get a compilation error.

282
00:18:45.470 --> 00:18:48.430
So for instance let's put in the statement here.

283
00:18:48.430 --> 00:18:49.940
It did it or not remote.

284
00:18:50.170 --> 00:18:57.250
So this is the second amendment that would throw an exception here that you are giving us an illegal

285
00:18:57.260 --> 00:18:58.230
state exception.

286
00:18:58.240 --> 00:18:58.680
OK.

287
00:18:58.820 --> 00:19:03.760
So the flustering moment there was fine because it was secured by next but the second remote method

288
00:19:03.940 --> 00:19:08.610
is giving us this exception OK because it has to be preceded by next.

289
00:19:08.620 --> 00:19:11.470
So that's that's one thing I wanted to mention.

290
00:19:11.470 --> 00:19:12.440
So that's about it.

291
00:19:12.470 --> 00:19:12.900
Thank you.

292
00:19:12.890 --> 00:19:13.640
And happy coding.

293
00:19:13.640 --> 00:19:17.120
Or you can find the find the code in the resources section.

294
00:19:17.120 --> 00:19:17.460
Thank you

