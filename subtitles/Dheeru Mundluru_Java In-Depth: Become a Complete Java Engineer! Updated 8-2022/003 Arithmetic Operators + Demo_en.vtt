WEBVTT
1
00:00:02.080 --> 00:00:03.080
Hi there.

2
00:00:03.100 --> 00:00:04.260
This is Lou.

3
00:00:04.270 --> 00:00:05.170
And welcome back.

4
00:00:05.350 --> 00:00:07.810
Let's now begin with arithmetic operators.

5
00:00:07.990 --> 00:00:14.320
And we already discussed them when learning about the absolute basics of the Java language in the previous

6
00:00:14.320 --> 00:00:14.980
section.

7
00:00:15.190 --> 00:00:18.550
And we also used a couple of them while demonstrating methods.

8
00:00:19.150 --> 00:00:24.280
And of course, we also use them pretty frequently in our daily lives, like addition and subtraction.

9
00:00:24.880 --> 00:00:31.000
Well, Java also uses familiar notations like plus and minus that we use in the real world.

10
00:00:31.300 --> 00:00:36.550
There are also certain representations that are specific to Java and we will look at them in this lecture.

11
00:00:38.360 --> 00:00:45.470
Java supports five arithmetic operations, addition, subtraction, multiplication, division and modulus

12
00:00:46.010 --> 00:00:47.010
for addition.

13
00:00:47.030 --> 00:00:54.560
A plus symbol is used and the example here shows addition of two literals and assigning the resulting

14
00:00:54.560 --> 00:00:55.790
sum to the variable.

15
00:00:58.240 --> 00:01:02.590
And there are also a couple of other ways in which a plus operator can be used.

16
00:01:02.800 --> 00:01:09.550
One use is as a unit plus, which is used to just indicate that a number is positive.

17
00:01:10.320 --> 00:01:14.640
Second, it can also be used in concatenating multiple strings.

18
00:01:14.760 --> 00:01:17.280
That is joining multiple strings.

19
00:01:18.230 --> 00:01:21.140
And we have been seeing such trend statements here.

20
00:01:21.140 --> 00:01:24.620
Plus symbol is performing a concatenation operation.

21
00:01:25.190 --> 00:01:32.630
It is concatenating the value of the variable name, which is on its right to the text username on the

22
00:01:32.630 --> 00:01:39.350
left here user name and closed in double quotes is a string literal and we will discuss it in a subsequent

23
00:01:39.350 --> 00:01:41.450
section when discussing strings.

24
00:01:42.310 --> 00:01:47.770
The variable name here is of type string and string is also a class in Java.

25
00:01:49.290 --> 00:01:52.020
Next for subtraction, a minus symbol is used.

26
00:01:52.880 --> 00:01:58.580
Unlike plus and minus operator can also be additionally used as a unit operator.

27
00:01:59.150 --> 00:02:04.730
In this case, it is a unity minus, which basically negates an expression.

28
00:02:05.240 --> 00:02:13.250
For example, here, if X is minus five, then due to unity, minus the expression, minus x will return

29
00:02:13.250 --> 00:02:14.480
a positive five.

30
00:02:15.250 --> 00:02:21.730
Just note that unlike unity, minus unity plus does not change the sign of the expression.

31
00:02:22.550 --> 00:02:28.730
That is, even if the operant is negative, the expression would still evaluate to a negative value.

32
00:02:29.510 --> 00:02:33.110
So Unity Plus doesn't seem to have any real value.

33
00:02:33.410 --> 00:02:39.650
My guess is it is only used to visually emphasize that a number is a positive number.

34
00:02:40.960 --> 00:02:45.470
Next for multiplication, an asterisk is used for division.

35
00:02:45.490 --> 00:02:49.810
A forward slash is used, and for modulus, a percentage symbol is used.

36
00:02:50.500 --> 00:02:57.730
Modulus operation gives the remainder of division and here five more two for instance, results in a

37
00:02:57.730 --> 00:02:58.990
value of one.

38
00:03:00.720 --> 00:03:07.230
And one example use case of modulus is to detect whether a number is or even.

39
00:03:08.070 --> 00:03:14.700
You would simply do a motto, and if the remainder is zero, then it means that the number in context

40
00:03:14.700 --> 00:03:16.140
is an even number.

41
00:03:16.530 --> 00:03:21.660
Otherwise, if the remainder is not zero, then it means it is an odd number.

42
00:03:22.530 --> 00:03:26.520
So those are the arithmetic operations that Java supports.

43
00:03:27.900 --> 00:03:31.860
And they are applicable to only primitive numeric types.

44
00:03:32.070 --> 00:03:36.210
That is, they apply to all primitives except boolean.

45
00:03:38.000 --> 00:03:38.330
Now.

46
00:03:38.330 --> 00:03:44.240
Java also supports a few shorthand operators for performing arithmetic operations.

47
00:03:44.540 --> 00:03:51.290
First one is a pre and post increment or decrement operators, and the second category of shorthand

48
00:03:51.290 --> 00:03:56.180
operators are referred to as compound arithmetic assignment operators.

49
00:03:57.750 --> 00:04:02.010
Pre and post operators are specific to only addition and subtraction.

50
00:04:03.080 --> 00:04:04.610
And here are the notations.

51
00:04:05.940 --> 00:04:12.810
And they're used for incrementing or incrementing a variable value by one plus plus would increment

52
00:04:12.810 --> 00:04:16.079
by one and minus minus word decrement by one.

53
00:04:16.680 --> 00:04:22.230
So x plus plus means the value of variable x is incremented by one.

54
00:04:23.710 --> 00:04:27.700
Which is identical to this statement, X is equal to X plus one.

55
00:04:28.000 --> 00:04:30.100
So it is a shorthand notation.

56
00:04:30.100 --> 00:04:33.670
And in the next slide we will see what pre and post means.

57
00:04:35.650 --> 00:04:41.320
While pre and post operators are specific to addition and subtraction, component operators apply to

58
00:04:41.350 --> 00:04:43.480
all of the arithmetic operators.

59
00:04:44.560 --> 00:04:47.620
And here are the notations for all the operators.

60
00:04:48.720 --> 00:04:50.160
And here is an example.

61
00:04:50.190 --> 00:04:55.260
This statement would increment the value of the variable X by five.

62
00:04:56.930 --> 00:04:59.180
So it is same as this statement.

63
00:04:59.180 --> 00:05:00.860
X is equal to x plus five.

64
00:05:01.520 --> 00:05:05.780
Important thing here is that plus is followed by equal to symbol.

65
00:05:06.080 --> 00:05:09.920
If you have equal to symbol followed by plus, then it will not work.

66
00:05:10.370 --> 00:05:12.410
We will also soon test this out.

67
00:05:12.890 --> 00:05:16.430
So x plus plus increments by exactly one.

68
00:05:16.460 --> 00:05:22.940
While using such a compound operator, we can increment by any value and we can also perform similar

69
00:05:22.940 --> 00:05:26.450
operations for the remaining four arithmetic operators.

70
00:05:28.290 --> 00:05:31.620
Let's now see what pre and post operators actually do.

71
00:05:31.800 --> 00:05:35.340
Let's consider a variable x which is initialized to five.

72
00:05:37.080 --> 00:05:43.890
Post increment operator would look like this where plus plus follows the variable and this can be a

73
00:05:43.890 --> 00:05:47.310
single statement and it would increment x to six.

74
00:05:48.860 --> 00:05:54.140
And this is a pre increment operator where plus plus symbol is followed by the variable.

75
00:05:54.200 --> 00:05:56.000
So plus plus symbol comes first.

76
00:05:56.390 --> 00:05:58.960
And this can be a single statement by itself.

77
00:05:58.970 --> 00:06:01.730
And this would also increment X to six.

78
00:06:01.940 --> 00:06:03.200
So X was five.

79
00:06:03.230 --> 00:06:07.280
And if we perform plus plus x, it would make x six.

80
00:06:07.910 --> 00:06:11.720
So both are essentially performing an increment operation.

81
00:06:12.200 --> 00:06:14.510
So what is pre and post then?

82
00:06:15.020 --> 00:06:20.390
For that we need to consider either an assignment or a declaration statement.

83
00:06:22.130 --> 00:06:28.340
For instance, let's consider this declaration statement where Y is initialized with X plus plus.

84
00:06:28.670 --> 00:06:37.070
And this statement would first assign the current value of X to Y, and after that X would be incremented.

85
00:06:37.640 --> 00:06:42.770
So once the statement is executed, Y would be five and X would be six.

86
00:06:44.330 --> 00:06:47.690
Essentially it is identical to these two statements.

87
00:06:47.840 --> 00:06:53.210
The current value of X is first assigned to Y and then X is incremented.

88
00:06:55.270 --> 00:06:59.860
Now let's consider this declaration statement to understand pre increment operation.

89
00:07:00.460 --> 00:07:05.500
This would first increment x and then the resulting value is assigned to Y.

90
00:07:06.010 --> 00:07:11.440
That is x is first incremented to six and then that value six is assigned to Y.

91
00:07:11.950 --> 00:07:15.880
So both X and Y would be six after this statement is executed.

92
00:07:17.140 --> 00:07:20.940
So it is identical to these two statements compared to posts.

93
00:07:20.950 --> 00:07:23.710
Just the order of operations is swept.

94
00:07:24.570 --> 00:07:31.740
So premium price increment will happen first and then the assignment post implies assignment will happen

95
00:07:31.740 --> 00:07:34.410
first, which is then followed by increment.

96
00:07:35.070 --> 00:07:38.110
Post and payment will also work in the same way.

97
00:07:38.130 --> 00:07:40.470
It is just that it would be decrement.

98
00:07:42.070 --> 00:07:49.390
Here in why is equal to x minus minus implies Y is first assigned the current value of x, which is

99
00:07:49.390 --> 00:07:53.650
five, and then after that x is incremented to four.

100
00:07:54.190 --> 00:07:55.990
So that's suppose decrement.

101
00:07:57.040 --> 00:08:03.580
And if you how and why is equal to minus minus x, then x is plus decrement to four and then that value

102
00:08:03.580 --> 00:08:05.350
four is assigned to Y.

103
00:08:05.380 --> 00:08:06.620
That is predictive.

104
00:08:07.570 --> 00:08:10.960
Now let's just head over to my editor and test all of this.

105
00:08:11.230 --> 00:08:16.540
And it would also be interesting to look at these pre and post operators in the context of.

106
00:08:17.440 --> 00:08:22.780
So we will also look at that and we will also look at the compound arithmetic assignment operators.

107
00:08:22.990 --> 00:08:24.970
So let's switch over to Ed now.

108
00:08:27.660 --> 00:08:30.620
Here we are in the basics demo class in the main method.

109
00:08:30.630 --> 00:08:33.240
So we are going to test three of them here.

110
00:08:33.539 --> 00:08:36.799
And for each of the test we have a separate method.

111
00:08:36.809 --> 00:08:41.820
So first we are going to look at pre and post and so we have this method called pre and post for that.

112
00:08:41.909 --> 00:08:45.150
And then we are going to look at compound arithmetic assignment operators.

113
00:08:45.150 --> 00:08:50.790
And finally we will also look at the modulus operator for this particular use case of testing, whether

114
00:08:50.790 --> 00:08:53.670
a number is or even so, let's also test that.

115
00:08:53.700 --> 00:08:56.250
So let's look at what we have in the pre and post.

116
00:08:56.280 --> 00:08:57.210
Here it is.

117
00:08:57.420 --> 00:09:05.010
So here we have this variable called X which is initialized to five and let's go ahead and just increment

118
00:09:05.010 --> 00:09:05.490
it.

119
00:09:05.820 --> 00:09:11.610
So let's have a post increment operator and we know that it increments.

120
00:09:12.770 --> 00:09:13.550
Buy one.

121
00:09:13.550 --> 00:09:14.810
So X.

122
00:09:15.840 --> 00:09:18.400
Should be six now, and that's what we have.

123
00:09:18.420 --> 00:09:19.650
So here it is.

124
00:09:19.920 --> 00:09:21.590
So this is a statement by itself.

125
00:09:21.600 --> 00:09:25.980
Now let's make it plus plus X so straightforward.

126
00:09:31.440 --> 00:09:32.790
X is once again six.

127
00:09:33.900 --> 00:09:38.010
Let's make it x minus minus post decrement.

128
00:09:42.270 --> 00:09:43.180
Access for now.

129
00:09:43.200 --> 00:09:44.790
So it was initially five.

130
00:09:45.090 --> 00:09:48.450
Let's also do three decrement so that we will be done with that.

131
00:09:51.800 --> 00:09:52.520
Sorry.

132
00:09:55.750 --> 00:09:57.820
OC x is once again for.

133
00:09:58.690 --> 00:10:01.750
Now let's look at previous post.

134
00:10:01.750 --> 00:10:06.070
And for that we were using a declaration statement.

135
00:10:06.520 --> 00:10:11.560
So we had something like this Y is equal to X plus plus.

136
00:10:11.890 --> 00:10:20.170
And we know that the current value of X, which is five, would be assigned to Y, and then after that

137
00:10:20.170 --> 00:10:22.390
X would be incremented, right?

138
00:10:22.390 --> 00:10:25.270
So this is a nice, elegant way of doing it.

139
00:10:25.690 --> 00:10:33.760
So here we are printing both Y and X and you can see that the plus symbol is being used as a concatenation.

140
00:10:33.940 --> 00:10:37.810
So this is a string literal and string literals will be discussed later.

141
00:10:38.140 --> 00:10:41.890
So we are using this plus to do a concatenation.

142
00:10:41.890 --> 00:10:46.480
So the variable Y value would be concatenated to this string.

143
00:10:46.840 --> 00:10:53.770
And after that, this string literal, which has comma and X will be appended to that string.

144
00:10:54.590 --> 00:10:58.970
And finally, x value that the value of the variable x will also be appended.

145
00:10:58.970 --> 00:11:01.010
So we'll have one full string here.

146
00:11:01.250 --> 00:11:05.240
So we are using three plus symbols to build a string.

147
00:11:05.840 --> 00:11:08.330
So let me compile and run it.

148
00:11:09.550 --> 00:11:10.510
We are the screen.

149
00:11:13.210 --> 00:11:13.780
Here you go.

150
00:11:13.780 --> 00:11:18.040
So why is 5x6 all right now?

151
00:11:18.370 --> 00:11:24.070
If you do plus plus six, then ex would be first incremented.

152
00:11:27.360 --> 00:11:30.870
And then the current value of X is assigned to Y.

153
00:11:30.900 --> 00:11:32.550
So both of them are six.

154
00:11:33.030 --> 00:11:35.850
Now, if we do minus minus X.

155
00:11:36.590 --> 00:11:38.580
Then both of them will be four.

156
00:11:38.600 --> 00:11:38.960
Right.

157
00:11:38.960 --> 00:11:40.850
X would be incremented first.

158
00:11:40.850 --> 00:11:43.790
And then the resulting value will be assigned to.

159
00:11:44.750 --> 00:11:45.320
Why?

160
00:11:46.380 --> 00:11:49.620
Here you go, axis four and why is also four?

161
00:11:49.950 --> 00:11:53.820
And let's also test the final one for the sake of completeness.

162
00:11:54.240 --> 00:11:56.190
So why would be five now?

163
00:11:56.190 --> 00:12:01.020
Because X will be assigned to Y the current value, and after that X will be incremented.

164
00:12:01.020 --> 00:12:04.080
So Y will be five and X will be four in this case.

165
00:12:07.420 --> 00:12:07.850
There you go.

166
00:12:07.870 --> 00:12:09.520
So why is five exes for.

167
00:12:10.790 --> 00:12:11.670
So that's with that.

168
00:12:11.690 --> 00:12:13.220
Now, let's look at.

169
00:12:14.800 --> 00:12:19.450
Pre and post in the context of it is slightly interesting here.

170
00:12:19.690 --> 00:12:21.760
So let's also look at that.

171
00:12:22.390 --> 00:12:25.840
So normally when we declare our we do this.

172
00:12:25.840 --> 00:12:27.370
So let's have a variable.

173
00:12:29.030 --> 00:12:29.360
Right.

174
00:12:29.360 --> 00:12:38.150
And let's say the size is three here and we know that we can initialize it in this way of zero ten.

175
00:12:41.800 --> 00:12:42.100
Right.

176
00:12:42.100 --> 00:12:47.650
So this is one way of initializing the area where the index value is hardcoded.

177
00:12:48.040 --> 00:12:55.210
But in certain scenarios, instead of hot coding the index values here, we can use a variable.

178
00:12:55.780 --> 00:13:01.600
So sometimes you would have to do that and you would you cannot hard code in this way so you would be

179
00:13:01.600 --> 00:13:03.280
forced to use a variable.

180
00:13:03.760 --> 00:13:05.890
So let's do that.

181
00:13:05.890 --> 00:13:10.540
For instance, we can define a variable called index.

182
00:13:11.590 --> 00:13:13.090
Let's say zero here.

183
00:13:13.870 --> 00:13:16.390
And we can have index here.

184
00:13:17.270 --> 00:13:17.630
Och.

185
00:13:17.690 --> 00:13:19.910
So that would be Audi of zero.

186
00:13:20.120 --> 00:13:25.700
And next we need to increment index so we can do something like this index.

187
00:13:25.700 --> 00:13:26.000
Plus.

188
00:13:26.000 --> 00:13:26.720
Plus.

189
00:13:28.070 --> 00:13:35.300
And we would have the same index here because it means that index is one now because it got incremented

190
00:13:35.510 --> 00:13:41.300
and we can increment it one more time so that we can increment it to two.

191
00:13:41.930 --> 00:13:48.200
So we will have it like this and we can of course, if you want to, you can increment it one more time.

192
00:13:48.680 --> 00:13:52.280
So this is what this is how a variable can be used.

193
00:13:52.610 --> 00:13:55.040
Let's not worry about the context.

194
00:13:55.280 --> 00:13:59.120
That will be clear when you when you look at the particular scenario.

195
00:13:59.120 --> 00:14:04.070
But sometimes you would have to do that, especially when using something like a first statement or

196
00:14:04.070 --> 00:14:06.410
a wild statement or in certain scenarios.

197
00:14:06.410 --> 00:14:07.790
It will be it will be there.

198
00:14:07.790 --> 00:14:09.530
But let's not worry about that.

199
00:14:10.300 --> 00:14:12.170
So we have two statements here.

200
00:14:12.190 --> 00:14:19.120
Now, instead of doing this having these two statements, just like in the case of the variable declaration

201
00:14:19.120 --> 00:14:22.600
that we have seen earlier, we can also do this and we can remove this.

202
00:14:24.190 --> 00:14:29.710
So in this case, what happens is first array of index, index is zero.

203
00:14:30.010 --> 00:14:33.160
So array of zero will get the value ten.

204
00:14:33.160 --> 00:14:35.680
And after that index will be incremented.

205
00:14:36.250 --> 00:14:38.660
So index will be incremented to one.

206
00:14:38.680 --> 00:14:41.470
So similarly, we also don't need this.

207
00:14:41.470 --> 00:14:43.540
So at this point, index is already one.

208
00:14:43.720 --> 00:14:47.950
So area of one will be 20 and then we will have this post increment.

209
00:14:47.950 --> 00:14:50.710
So index will get incremented to two now.

210
00:14:51.070 --> 00:14:53.950
And the same thing is here.

211
00:14:54.130 --> 00:14:58.330
So first area of index will be assigned with the value on the right.

212
00:14:58.330 --> 00:15:00.910
And after that the increment is performed.

213
00:15:01.240 --> 00:15:03.460
So let's print index now.

214
00:15:05.570 --> 00:15:06.470
We compile.

215
00:15:08.430 --> 00:15:09.320
So here it is.

216
00:15:09.330 --> 00:15:10.980
Index value is three.

217
00:15:11.310 --> 00:15:12.540
Initially it was zero.

218
00:15:12.570 --> 00:15:15.140
At this point it got incremented to one, then two.

219
00:15:15.150 --> 00:15:18.450
Then after this, it gets incremented to three.

220
00:15:19.150 --> 00:15:21.810
Now let's see what happens if we make it pre increment.

221
00:15:24.010 --> 00:15:26.140
You can actually guess what happens.

222
00:15:28.190 --> 00:15:31.220
So instead of post we are doing a pre increment here.

223
00:15:31.820 --> 00:15:36.320
So index value here will get incremented to one.

224
00:15:36.650 --> 00:15:39.740
So array of one will get the value of ten.

225
00:15:40.220 --> 00:15:41.450
And so.

226
00:15:41.450 --> 00:15:46.730
So increment is happening first like we already know because it is a pre increment operator.

227
00:15:46.970 --> 00:15:49.640
So let's see the output.

228
00:15:51.570 --> 00:15:52.120
Here it is.

229
00:15:52.140 --> 00:15:54.620
We are getting an exception here.

230
00:15:54.630 --> 00:16:02.580
We're getting an error because we are trying to access an index which is outside the boundary tree.

231
00:16:02.820 --> 00:16:05.550
So over here the index was one.

232
00:16:05.790 --> 00:16:08.220
So we add area of one, we are storing ten.

233
00:16:08.820 --> 00:16:12.550
Then with this, the index value is two.

234
00:16:12.570 --> 00:16:15.300
So we are storing area of two, which is 20.

235
00:16:15.450 --> 00:16:18.780
And with this it will the index value will be three.

236
00:16:19.020 --> 00:16:24.480
With that, we are outside the boundary of array because an array can store only three elements.

237
00:16:24.660 --> 00:16:28.020
An array of three would reference the fourth element.

238
00:16:28.170 --> 00:16:28.740
Right.

239
00:16:29.190 --> 00:16:31.200
Because our indexing starts at zero.

240
00:16:31.650 --> 00:16:36.990
So an array of index, an array of zero, we are actually storing the default value zero.

241
00:16:37.410 --> 00:16:43.590
So in this case, to avoid that error, it has to be minus one and then it should be fine.

242
00:16:47.750 --> 00:16:49.250
So in this case, it is fine.

243
00:16:50.080 --> 00:16:50.560
That's it.

244
00:16:50.560 --> 00:16:51.760
So that's what that.

245
00:16:52.570 --> 00:16:54.520
Now the second thing.

246
00:16:55.710 --> 00:16:58.290
As a compound arithmetic assignment.

247
00:17:00.070 --> 00:17:02.170
So you would want to do something like this.

248
00:17:02.530 --> 00:17:03.590
You would want to do something.

249
00:17:03.610 --> 00:17:07.510
Use a post increment instead of or a pre increment.

250
00:17:07.630 --> 00:17:12.460
But a lot of developers, you know, they just do a ray of index equal to ten and then they increment

251
00:17:12.460 --> 00:17:13.780
in the next statement.

252
00:17:14.619 --> 00:17:18.319
That is probably because of lack of knowledge about this.

253
00:17:18.339 --> 00:17:23.800
But you now know that we can achieve the same thing using a post increment operator.

254
00:17:24.250 --> 00:17:24.880
So that's with that.

255
00:17:24.880 --> 00:17:30.430
Let's let's look at the next one now, which is the compound assignment operators.

256
00:17:31.390 --> 00:17:32.980
So the code is already here.

257
00:17:32.980 --> 00:17:39.190
X is initialized to 100 and we have these five compound arithmetic assignment operators.

258
00:17:39.190 --> 00:17:43.210
We said that it can be used with all of the arithmetic operators.

259
00:17:43.210 --> 00:17:45.210
So we are just printing here.

260
00:17:45.220 --> 00:17:53.080
For instance, here we are incrementing by five on the same x, we are incrementing by five, so x got

261
00:17:53.080 --> 00:17:58.330
incremented by five and the same x value which got incremented will be incremented here and we have

262
00:17:58.330 --> 00:17:59.500
the similar notations.

263
00:17:59.500 --> 00:18:01.570
So let's go ahead and just.

264
00:18:02.760 --> 00:18:04.230
Execute and run it.

265
00:18:05.770 --> 00:18:06.600
Here it is.

266
00:18:06.610 --> 00:18:08.650
So X was initially 100.

267
00:18:09.010 --> 00:18:11.980
Then we incremented by five.

268
00:18:12.010 --> 00:18:14.350
So it became 105.

269
00:18:14.870 --> 00:18:15.400
OC.

270
00:18:16.470 --> 00:18:17.040
Here.

271
00:18:17.580 --> 00:18:20.140
Then we are documenting this 105.

272
00:18:20.160 --> 00:18:22.110
Bye bye file.

273
00:18:22.530 --> 00:18:24.390
So once again, it becomes 100.

274
00:18:24.660 --> 00:18:27.420
And then we are multiplying with five.

275
00:18:27.900 --> 00:18:28.890
The 100 value.

276
00:18:28.890 --> 00:18:32.060
The current value of X, which is 100, is being multiplied by five.

277
00:18:32.070 --> 00:18:33.330
So we get 500.

278
00:18:33.750 --> 00:18:38.790
And then we are applying this division operator on that value 500.

279
00:18:38.790 --> 00:18:40.380
So we are getting 100.

280
00:18:40.410 --> 00:18:44.010
And finally, we are doing 100 MOD five.

281
00:18:44.400 --> 00:18:46.110
We get a reminder of zero.

282
00:18:47.100 --> 00:18:48.170
So that's what it is.

283
00:18:48.180 --> 00:18:56.010
So here you can see that although it is a print statement, we are able to execute this particular expression.

284
00:18:56.130 --> 00:18:59.600
And to do that, we have to use this parenthesis.

285
00:18:59.610 --> 00:19:03.510
And if you use a parenthesis, then it will execute it as an expression.

286
00:19:03.810 --> 00:19:05.220
So that is possible.

287
00:19:05.670 --> 00:19:06.810
So that's with that.

288
00:19:06.840 --> 00:19:13.500
Now, I also mentioned that the notation here should be plus followed by equal to or minus followed

289
00:19:13.500 --> 00:19:18.270
by equal to, but it shouldn't be equal to followed by plus or equal to followed by minus.

290
00:19:18.270 --> 00:19:20.530
So you wouldn't get the same output.

291
00:19:20.550 --> 00:19:22.080
So let's also test that.

292
00:19:22.650 --> 00:19:27.060
So equal to plus would be would be same as this thing.

293
00:19:27.480 --> 00:19:28.680
This is a unity plus.

294
00:19:28.680 --> 00:19:32.760
So it gets it will be considered as x equal to plus five.

295
00:19:32.880 --> 00:19:39.420
And for here, if you do this X equal to minus, it would be considered as x is equal to minus five.

296
00:19:40.080 --> 00:19:43.260
So it's not performing the addition or subtraction operation.

297
00:19:43.500 --> 00:19:45.450
So let's go ahead and.

298
00:19:47.140 --> 00:19:48.190
Compile and run it.

299
00:19:50.720 --> 00:19:51.640
Here it is.

300
00:19:51.650 --> 00:19:54.060
So access no longer 105.

301
00:19:54.080 --> 00:19:55.610
Here it is, just five.

302
00:19:56.300 --> 00:19:58.850
And here it is, a unity minus.

303
00:19:58.850 --> 00:20:01.730
So it X is getting assigned minus five.

304
00:20:02.240 --> 00:20:05.060
Now, let's look at this one.

305
00:20:07.220 --> 00:20:10.670
Actually, let me also add the modulus.

306
00:20:14.160 --> 00:20:22.560
So while plus and minus here we for them we have unity and unity minus these actually give us compilation

307
00:20:22.560 --> 00:20:23.040
errors.

308
00:20:23.250 --> 00:20:25.560
So it's not even going to compile at least for this.

309
00:20:25.560 --> 00:20:29.340
It is compiling and it is performing these operations.

310
00:20:29.340 --> 00:20:32.880
But for this you end up with compilation errors.

311
00:20:35.900 --> 00:20:36.560
There you go.

312
00:20:36.680 --> 00:20:41.480
So it says that all three of the operations are invalid.

313
00:20:41.840 --> 00:20:47.900
So it is not even possible to compile using star, forward, slash or modulus.

314
00:20:48.320 --> 00:20:54.230
So that's the compound arithmetic assignment operators and this is just equivalent to X is equal to

315
00:20:54.230 --> 00:20:55.070
X plus five.

316
00:20:56.070 --> 00:20:57.700
Now let's look at the final one.

317
00:20:57.720 --> 00:20:59.480
So it is very simple.

318
00:20:59.490 --> 00:21:06.510
We are just invoking this method is or even so if you pass an even number, it would print a zero because

319
00:21:06.510 --> 00:21:11.820
we are doing mod two and if you pass an odd number it would print one.

320
00:21:13.050 --> 00:21:15.600
It would actually print something other than zero.

321
00:21:15.780 --> 00:21:18.320
So let's get up.

322
00:21:23.400 --> 00:21:25.230
Still getting the compilation error here.

323
00:21:25.230 --> 00:21:27.060
So commenting it out.

324
00:21:28.120 --> 00:21:29.470
So we are passing 50.

325
00:21:29.470 --> 00:21:30.520
So it will print.

326
00:21:33.200 --> 00:21:33.560
There you go.

327
00:21:33.560 --> 00:21:34.610
It printed zero.

328
00:21:34.700 --> 00:21:37.670
Now let's pass something like 51.

329
00:21:43.140 --> 00:21:44.550
So I press one.

330
00:21:44.550 --> 00:21:46.110
So that is an odd number.

331
00:21:46.470 --> 00:21:51.740
So percentage symbol can be used for finding whether a number is odd or UN.

332
00:21:51.750 --> 00:21:57.000
And there are also other ways to to detect that, to detect whether a number is or even but at least

333
00:21:57.000 --> 00:21:58.770
modulus can be used for that.

334
00:21:58.770 --> 00:22:01.020
So that's one use case of modulus.

335
00:22:01.470 --> 00:22:02.640
So that's about it.

336
00:22:02.640 --> 00:22:04.800
That's about arithmetic operators.

337
00:22:04.800 --> 00:22:10.230
And next, we will look at some rules that are specific to arithmetic operator operators.

338
00:22:10.440 --> 00:22:11.250
Thank you.

339
00:22:11.250 --> 00:22:12.900
And I'll see you in the next lecture.

