WEBVTT
1
00:00:02.110 --> 00:00:03.130
Hi there.

2
00:00:03.160 --> 00:00:04.250
This is the De La Rue.

3
00:00:04.270 --> 00:00:05.270
And welcome back.

4
00:00:05.290 --> 00:00:08.980
So we now have a good understanding of first statement.

5
00:00:09.220 --> 00:00:16.059
And in the last lecture we looked at this particular four statement example, and we have seen how this

6
00:00:16.059 --> 00:00:18.850
first statement could be represented in different ways.

7
00:00:18.850 --> 00:00:24.190
And we also said that this is the most common way in which a first statement would be represented.

8
00:00:24.280 --> 00:00:28.060
That is, we will have an initialization statement and we will have some condition.

9
00:00:28.240 --> 00:00:34.020
And then we have this expression where we increment the variable, right?

10
00:00:34.570 --> 00:00:41.440
And in this lecture, let's go ahead and explore the first statement a bit more, and we will look at

11
00:00:41.440 --> 00:00:45.910
the common ways in which a first statement is typically used.

12
00:00:46.870 --> 00:00:54.490
And this is really very helpful for complete beginners, because we will see the different ways in which

13
00:00:54.490 --> 00:01:01.240
the initialization statements and the condition expressions here, the boolean conditions as well as

14
00:01:01.270 --> 00:01:06.100
the expression statements can be set up for different problems.

15
00:01:06.520 --> 00:01:13.630
So it's going to be very useful for complete beginners and we will especially look at how to traverse

16
00:01:13.630 --> 00:01:16.120
or iterate through a one dimensional array.

17
00:01:16.120 --> 00:01:23.020
We already have a basic idea about that from the last lecture and we will also see how a two dimensional

18
00:01:23.020 --> 00:01:28.300
or a multi dimensional array can be iterated using nested for statements.

19
00:01:28.570 --> 00:01:33.670
So we will also look at nested first statements and we will also look at a simple example where we will

20
00:01:33.670 --> 00:01:37.600
use a first statement, but we will not be iterating through an array.

21
00:01:38.230 --> 00:01:43.090
So it is an example where an array is not used in a first statement.

22
00:01:43.420 --> 00:01:45.640
So let's go ahead and look at this.

23
00:01:45.640 --> 00:01:47.980
First thing is let's change this.

24
00:01:47.980 --> 00:01:49.780
Here we are incrementing by one.

25
00:01:49.780 --> 00:01:52.570
So here we are iterating through this particular array.

26
00:01:53.020 --> 00:01:56.470
Let's just change it to two.

27
00:01:56.800 --> 00:02:03.940
So we are going to increment the variable I width two in each iteration it's going to be incremented

28
00:02:03.940 --> 00:02:04.600
by two.

29
00:02:04.630 --> 00:02:10.509
So this is just to show that the incremental expression need not be just one.

30
00:02:10.780 --> 00:02:12.850
We can also increment by more than one.

31
00:02:13.210 --> 00:02:16.120
So let me just recompile this.

32
00:02:16.120 --> 00:02:21.220
So this is in the basics demo class and here we are in the basics directory.

33
00:02:21.400 --> 00:02:24.550
So I'm just making the changes in the main method.

34
00:02:26.950 --> 00:02:27.460
Okay.

35
00:02:27.550 --> 00:02:28.090
There you go.

36
00:02:28.090 --> 00:02:31.720
So it's sprinting 0 to 4, six and eight.

37
00:02:32.140 --> 00:02:39.880
So it's going to skip one, three, five, seven, and it's going to just print 02468.

38
00:02:39.880 --> 00:02:44.080
So it's printing all the alternate values and this can be any value.

39
00:02:44.080 --> 00:02:46.840
You can also make it three or four and so on.

40
00:02:47.350 --> 00:02:48.480
So that's one thing.

41
00:02:48.490 --> 00:02:52.810
Now let's say we want to print this in reverse order.

42
00:02:53.500 --> 00:02:57.310
So we start from here from nine and we need to print in the reverse order.

43
00:02:57.580 --> 00:03:04.480
So since we need to start from nine, so we have to take a dot length.

44
00:03:06.400 --> 00:03:14.890
Minus one, because we know that the last element would be dot length, minus one, and here we would

45
00:03:14.890 --> 00:03:17.380
decrement instead of increment.

46
00:03:17.530 --> 00:03:23.470
And this decrement can also be by any value, it can be equal to IE minus two and so on.

47
00:03:23.980 --> 00:03:32.020
And here since we are going in the backward direction, it has to be greater than or equal to zero.

48
00:03:32.110 --> 00:03:37.240
So we will decrement until we reach the index number zero.

49
00:03:37.930 --> 00:03:39.160
So this should.

50
00:03:42.770 --> 00:03:44.300
Print and reverse order.

51
00:03:45.170 --> 00:03:45.770
There you go.

52
00:03:45.780 --> 00:03:49.160
So it is printing all the values in the reverse order.

53
00:03:50.060 --> 00:03:55.110
Now, let's say we want to reverse the elements in this particular array.

54
00:03:55.130 --> 00:03:57.170
Sometimes we would want to do that.

55
00:03:57.170 --> 00:04:04.250
And Java Library also provides a method in one of the classes in order to reverse the elements in the

56
00:04:04.250 --> 00:04:04.640
array.

57
00:04:04.940 --> 00:04:11.030
So when we say we want to reverse the elements, nine has to go into the last element has to go into

58
00:04:11.030 --> 00:04:12.170
the first position.

59
00:04:12.350 --> 00:04:20.029
And the the element at the zero position should go into the last position and it has to go here and

60
00:04:20.029 --> 00:04:23.090
one has to go into the eighth position.

61
00:04:23.570 --> 00:04:27.290
So we will do that in in using the first statement.

62
00:04:27.290 --> 00:04:32.470
But in each iteration we are doing, we are swapping a paid off elements.

63
00:04:32.480 --> 00:04:38.140
So in the first iteration, we would swap zero and nine and in the second iteration we would swap one

64
00:04:38.150 --> 00:04:38.900
and eight.

65
00:04:38.930 --> 00:04:44.210
In the third we would swap two and seven and then three and six and then four and five.

66
00:04:44.210 --> 00:04:45.950
And, and we would end with that.

67
00:04:46.610 --> 00:04:52.250
So in each iteration, we need to have access to two index numbers, right?

68
00:04:52.280 --> 00:04:57.980
For example, in the first iteration it would be zero and the index corresponding to this, which would

69
00:04:57.980 --> 00:04:58.610
be nine.

70
00:04:58.880 --> 00:05:01.490
So we would have to use two variables for this.

71
00:05:01.760 --> 00:05:08.060
Now, I would like you to pause the video here and try to write the logic for that.

72
00:05:08.390 --> 00:05:14.060
You can take around 5 minutes for that, and I'm going to take 5 seconds break, and then I will come

73
00:05:14.060 --> 00:05:16.450
back and show you how to write the code.

74
00:05:16.460 --> 00:05:23.600
But I would suggest you to pause the video and try it, and then you can see whether your solution matches

75
00:05:23.600 --> 00:05:24.380
mine or not.

76
00:05:28.470 --> 00:05:29.670
I hope you have done it.

77
00:05:29.760 --> 00:05:33.660
So let's go ahead and write the code and you can compare it with mine.

78
00:05:34.080 --> 00:05:36.360
So the first thing is we need two variables.

79
00:05:36.390 --> 00:05:39.150
First is I would be zero.

80
00:05:40.210 --> 00:05:45.760
Then we need another variable, let's call it as Jay and Jay would be.

81
00:05:47.300 --> 00:05:48.480
Let me also copy this.

82
00:05:48.500 --> 00:05:49.940
We would need this here.

83
00:05:52.740 --> 00:06:02.910
J would be I.R.A. length minus one, and here I would be incremented by one in each iteration, and

84
00:06:02.910 --> 00:06:06.210
J would be decrement in each iteration.

85
00:06:06.810 --> 00:06:16.440
And now coming to this one, the condition expression it would be a less than j oc.

86
00:06:18.210 --> 00:06:18.930
That is it.

87
00:06:19.140 --> 00:06:21.480
And we need to also write the logic here.

88
00:06:22.510 --> 00:06:24.490
So the condition is islas dengue.

89
00:06:24.610 --> 00:06:32.080
So initially I would be zero j would be nine here and in the second iteration it would be one and eight.

90
00:06:32.080 --> 00:06:38.950
So those elements would be swapped in the third iteration, two and seven would be swabbed and three

91
00:06:38.950 --> 00:06:41.890
and six and four and five.

92
00:06:41.920 --> 00:06:43.930
That's when I is less than J.

93
00:06:44.200 --> 00:06:51.700
And in the subsequent iteration I would be five and J would be four, and that's when we exit the first

94
00:06:51.700 --> 00:06:52.300
statement.

95
00:06:52.960 --> 00:06:58.330
So that's what when we have even number of elements like in this case there are ten elements.

96
00:06:58.330 --> 00:07:03.490
But if we have our number of elements, then three and five would be swab.

97
00:07:03.490 --> 00:07:08.980
We would increment A to three and J would be decrement at five.

98
00:07:08.980 --> 00:07:12.250
And after that I and J would be four.

99
00:07:12.670 --> 00:07:17.590
So the condition is still less than J, but we have is equal to J here.

100
00:07:17.980 --> 00:07:20.740
And so the first statement would exit there.

101
00:07:20.740 --> 00:07:27.760
So the condition is same whether we have even number of elements are or number of elements, that's

102
00:07:27.760 --> 00:07:27.910
it.

103
00:07:27.910 --> 00:07:31.030
And now coming to the logic in the body.

104
00:07:31.210 --> 00:07:32.590
So the first thing is.

105
00:07:33.480 --> 00:07:35.400
Let's define a temp variable.

106
00:07:36.340 --> 00:07:42.040
And store the element in the first iteration, it would be zero element.

107
00:07:42.040 --> 00:07:44.140
So we will say array of AI.

108
00:07:45.160 --> 00:07:48.670
So that is stored in temp, which means that we can.

109
00:07:53.720 --> 00:07:58.100
Take the git element and save it in its position.

110
00:07:59.180 --> 00:08:00.470
And then after that.

111
00:08:03.080 --> 00:08:11.630
In the G8 position, we will have to store the value in temp, which has the original value that was

112
00:08:11.630 --> 00:08:12.320
at position.

113
00:08:12.710 --> 00:08:14.600
So that is the swab.

114
00:08:14.990 --> 00:08:17.450
And let's go ahead and print this.

115
00:08:21.510 --> 00:08:24.090
So the condition here is I.

116
00:08:26.170 --> 00:08:28.540
Less than or equal to this.

117
00:08:29.990 --> 00:08:34.309
Or you can just have less than an A-plus plus.

118
00:08:35.929 --> 00:08:38.450
And let's just print in the same row.

119
00:08:39.220 --> 00:08:42.450
So let's just say plus and whitespace.

120
00:08:42.460 --> 00:08:45.070
So it would print all of the elements in the same row.

121
00:08:45.250 --> 00:08:49.000
So we are printing from zero to length minus one.

122
00:08:49.150 --> 00:08:51.490
So this is just for printing the elements.

123
00:08:52.120 --> 00:08:56.950
So let's go ahead and let me compile and recompile and run it.

124
00:09:00.590 --> 00:09:01.160
There you go.

125
00:09:01.160 --> 00:09:03.470
So the elements have been reversed.

126
00:09:04.430 --> 00:09:05.360
So that's it.

127
00:09:06.200 --> 00:09:10.250
So when I is equal to J, that's when we have exited the loop.

128
00:09:10.370 --> 00:09:14.820
Now we can also, instead of J, we can also say Ira.

129
00:09:15.860 --> 00:09:18.440
Dot leant by to.

130
00:09:18.830 --> 00:09:26.630
So we can also use this condition because I r length is 1010 by two is five.

131
00:09:26.840 --> 00:09:30.890
So when as long as I is less than five, we are good.

132
00:09:31.250 --> 00:09:35.600
But as soon as I becomes five, then we exit the loop.

133
00:09:35.600 --> 00:09:41.150
So this is a different way in which the same expression, the same four statement can be written.

134
00:09:41.570 --> 00:09:48.680
So this is just to give you an idea and how we can represent our statement in different ways and still

135
00:09:48.680 --> 00:09:49.820
get the same result.

136
00:09:51.200 --> 00:09:51.590
Here you go.

137
00:09:51.590 --> 00:09:53.570
So you get the same values.

138
00:09:54.110 --> 00:09:59.960
Now, here, what is happening is in each iteration we are performing this division operation.

139
00:10:00.260 --> 00:10:07.820
So if you have 1000 or a million elements here, then it would be computationally intensive.

140
00:10:07.820 --> 00:10:09.560
It's going to be very expensive.

141
00:10:09.860 --> 00:10:15.410
So because in each iteration, we have to do this computation so we can do an optimization.

142
00:10:15.410 --> 00:10:21.830
And the optimization is I will take this expression from here and define another variable here in the

143
00:10:21.830 --> 00:10:25.850
initialization statement part, and let's call it as middle.

144
00:10:26.570 --> 00:10:28.220
And let's have it like this.

145
00:10:28.610 --> 00:10:30.710
And now we will say.

146
00:10:32.170 --> 00:10:32.770
Medal.

147
00:10:33.460 --> 00:10:39.850
So in this case, we know that the initialization statement part gets executed only once.

148
00:10:40.120 --> 00:10:45.820
So this expression would also be computed only once, and that would suffice for us.

149
00:10:46.210 --> 00:10:50.320
So it's calculated once and that value would be plugged here.

150
00:10:50.350 --> 00:10:55.930
And so with each iteration, we are not recalculating this value.

151
00:10:56.170 --> 00:10:57.280
It's only done once.

152
00:10:57.280 --> 00:10:59.170
So this is done only once.

153
00:10:59.200 --> 00:11:01.930
We know that this is this gets evaluated only once.

154
00:11:02.170 --> 00:11:10.390
But the condition expression as well as the expression list is what gets evaluated with each iteration.

155
00:11:10.430 --> 00:11:10.870
All right.

156
00:11:11.170 --> 00:11:15.070
So let's go ahead and re verify our results.

157
00:11:17.880 --> 00:11:21.690
Once again, it's unchanged, so we get the same values.

158
00:11:21.990 --> 00:11:23.730
So that's an optimization.

159
00:11:23.760 --> 00:11:27.630
Now, can you think of if there is a way to optimize this further?

160
00:11:28.110 --> 00:11:30.390
So here we are saying division by two.

161
00:11:31.500 --> 00:11:32.910
Now, you may recall that.

162
00:11:33.950 --> 00:11:43.490
The unsigned right shift can be used for that because it is equivalent to division by power of two.

163
00:11:44.360 --> 00:11:47.840
So here we will make it one because we need to divide by two.

164
00:11:48.080 --> 00:11:52.610
So this is like a length divided by two to the power of one.

165
00:11:53.120 --> 00:12:00.890
And we know that the the bit shift operators are more or more efficient than multiplication and division.

166
00:12:00.890 --> 00:12:04.280
So we can use an unsigned right shift for division operation.

167
00:12:04.730 --> 00:12:08.270
So let's re verify once again.

168
00:12:10.070 --> 00:12:12.950
So the output is the same.

169
00:12:13.760 --> 00:12:14.780
So that's with that.

170
00:12:15.500 --> 00:12:21.920
Now, I also want to say that mostly we use four statements to iterate through data structures like

171
00:12:21.920 --> 00:12:25.580
arrays or other data structures, which we will explore later.

172
00:12:25.910 --> 00:12:29.540
But first statement can also be used in other problems.

173
00:12:29.540 --> 00:12:34.010
Also, like, for instance, if you just want to iterate through some logic for some number of times

174
00:12:34.010 --> 00:12:34.880
it can be used.

175
00:12:34.970 --> 00:12:42.740
Now one example, simple example where an array is not used is one example problem, which you which

176
00:12:42.740 --> 00:12:49.850
is typically seen in common in programming courses as to to count the number of divisors of a particular

177
00:12:49.850 --> 00:12:50.480
value.

178
00:12:50.840 --> 00:13:01.400
For example, for example, if there is a value X and a value y would be a divisor of x if x mod y results

179
00:13:01.400 --> 00:13:06.080
in zero, if the remainder is zero, when you divide by Y, then that's a common.

180
00:13:06.140 --> 00:13:10.130
Then we say that y is it is a divisor for x.

181
00:13:10.340 --> 00:13:15.500
So for a given number, let's count the number of divisors it has.

182
00:13:16.100 --> 00:13:17.060
So let's say.

183
00:13:19.220 --> 00:13:19.840
Let's write it.

184
00:13:19.850 --> 00:13:21.620
It's very simple.

185
00:13:26.650 --> 00:13:34.840
Let's call the number as 24 and we are supposed to find all the we are supposed to find how many divisors

186
00:13:34.840 --> 00:13:35.650
it has.

187
00:13:35.890 --> 00:13:37.930
So let's use a variable.

188
00:13:40.960 --> 00:13:48.880
And Divisor 421 would include one as well as 24 for 24 one as well as 24.

189
00:13:48.880 --> 00:13:53.380
And there would be there can be other divisors in between one and 24.

190
00:13:53.380 --> 00:13:56.170
So it has to start with one.

191
00:13:56.970 --> 00:14:01.560
I'm not zero and we need to iterate till 24.

192
00:14:01.560 --> 00:14:05.340
So that is less than or equal to x and I plus.

193
00:14:05.340 --> 00:14:05.970
Plus.

194
00:14:07.540 --> 00:14:17.470
And in each iteration we make a check, we say f, x mod I is equal to zero.

195
00:14:17.590 --> 00:14:19.360
Then it's a divisor.

196
00:14:20.490 --> 00:14:22.150
Then I is a divisor.

197
00:14:23.310 --> 00:14:26.070
So we are iterating from 1 to 24.

198
00:14:26.250 --> 00:14:28.710
So in this case, we need to increment the count.

199
00:14:29.920 --> 00:14:33.040
And this is also a common programming pattern here.

200
00:14:33.670 --> 00:14:37.600
We have a first statement and each in each iteration we do a check.

201
00:14:37.870 --> 00:14:41.240
And if the check succeeds, only then we execute some logic.

202
00:14:41.260 --> 00:14:44.710
That's a common programming pattern that you encounter.

203
00:14:44.980 --> 00:14:47.010
Now, let's just print the count.

204
00:14:56.550 --> 00:14:56.940
Okay.

205
00:14:57.150 --> 00:15:01.040
And let's also print the actual divisor also.

206
00:15:01.050 --> 00:15:03.450
So let's take this.

207
00:15:08.120 --> 00:15:10.010
B I so looks good.

208
00:15:14.530 --> 00:15:17.530
So these are all the divisors for 24.

209
00:15:17.560 --> 00:15:21.670
One, two, three, four, six, eight and 12.

210
00:15:22.600 --> 00:15:27.860
So if you put more of 24 of any of these numbers, you get a reminder of zero.

211
00:15:27.880 --> 00:15:29.320
And so there are eight of them.

212
00:15:29.800 --> 00:15:30.960
So that's what that.

213
00:15:31.150 --> 00:15:33.280
Now, let's say for instance.

214
00:15:34.730 --> 00:15:36.830
Let's now look at a nested first statement.

215
00:15:36.840 --> 00:15:43.250
Nested first statements also come up very commonly when we are programming, especially if you have

216
00:15:43.280 --> 00:15:50.030
a data structure like an array, and if each element is also another array that is like a two dimensional

217
00:15:50.030 --> 00:15:55.280
or a three dimensional array or any data structure whose elements are other data structures.

218
00:15:55.490 --> 00:16:02.390
Then you can use a force statement where the outer force statement will iterate through the data structure

219
00:16:02.390 --> 00:16:08.720
itself like an array, and the inner first statement will iterate through the will iterate through each

220
00:16:08.720 --> 00:16:14.150
of the elements because each of them element can be something like an array.

221
00:16:14.570 --> 00:16:16.190
So let's look at that.

222
00:16:16.490 --> 00:16:22.970
And one thing is that I mentioned earlier in the last lecture is the scope of these variables ends with

223
00:16:22.970 --> 00:16:23.720
the far loop.

224
00:16:23.720 --> 00:16:26.360
So here we have the entire is equal to zero.

225
00:16:26.360 --> 00:16:31.880
And you can see that we used another int equal to zero here because this eye is different from this,

226
00:16:31.880 --> 00:16:35.540
because the scope of the variable I ends with this particular block.

227
00:16:35.780 --> 00:16:41.750
And similarly we also have the AI here and the variable of x.

228
00:16:41.750 --> 00:16:47.840
The scope would be from here till the end of the method, the main method later we will formally also

229
00:16:47.840 --> 00:16:51.560
look at variable scope in a couple of lectures from now.

230
00:16:52.100 --> 00:16:53.510
So the first thing is this.

231
00:16:53.510 --> 00:16:56.060
So let me just copy a little bit of code here.

232
00:17:01.870 --> 00:17:04.390
So here, let's say these are.

233
00:17:04.569 --> 00:17:08.349
So here we have a two dimensional array and we are calling it as 210 grids.

234
00:17:08.470 --> 00:17:14.650
So it represents some grades of the student, let's say this element here, the first element of the

235
00:17:14.650 --> 00:17:16.900
to the array is an array.

236
00:17:16.900 --> 00:17:22.839
And it and it has the grades of students in a particular section or a particular class.

237
00:17:22.930 --> 00:17:28.630
And this is the grades of students in the second section or the second class and grades for the third

238
00:17:28.630 --> 00:17:29.190
class.

239
00:17:29.200 --> 00:17:32.410
Now we want to iterate through this particular.

240
00:17:33.980 --> 00:17:37.370
2D array and display all of these elements.

241
00:17:37.490 --> 00:17:42.320
So first we'll have an outer first statement and within that.

242
00:17:43.360 --> 00:17:44.110
We would have another.

243
00:17:45.130 --> 00:17:46.330
So fast we will say.

244
00:17:46.330 --> 00:17:48.340
And I equals to zero.

245
00:17:48.850 --> 00:17:50.440
I less than.

246
00:17:53.410 --> 00:17:54.040
Land.

247
00:17:55.040 --> 00:17:57.710
So that would be three, because there are three elements.

248
00:17:59.570 --> 00:18:01.190
And then we would have to.

249
00:18:01.220 --> 00:18:05.260
So in, in each iteration we have an element which is a one dra.

250
00:18:05.510 --> 00:18:09.830
So we need to iterate through that and for that we use another nested for loop.

251
00:18:09.830 --> 00:18:17.210
So let's have a new variable called int j is equal to zero and j less than.

252
00:18:19.400 --> 00:18:22.910
We can say student grades of I.

253
00:18:24.290 --> 00:18:24.540
Okay.

254
00:18:24.680 --> 00:18:30.560
So in the first iteration, this would be student grades of zero, which is nothing but this array,

255
00:18:30.770 --> 00:18:36.590
which corresponds to the first class and we have to say dot length because we need to iterate through

256
00:18:36.590 --> 00:18:40.610
these elements and j plus plus.

257
00:18:42.500 --> 00:18:42.980
Okay.

258
00:18:43.640 --> 00:18:44.990
And here.

259
00:18:48.290 --> 00:18:49.850
So displaying.

260
00:18:52.610 --> 00:18:53.870
Of Section.

261
00:18:56.640 --> 00:18:59.010
And those grades will be printed here.

262
00:18:59.010 --> 00:19:01.410
So we'll assess them.

263
00:19:03.510 --> 00:19:04.740
And instead of I.

264
00:19:04.770 --> 00:19:05.670
This would be.

265
00:19:08.230 --> 00:19:08.390
Okay.

266
00:19:08.580 --> 00:19:17.100
So we are displaying the students of the grades of students in each section and within each section

267
00:19:17.100 --> 00:19:19.140
we are displaying these grades.

268
00:19:30.190 --> 00:19:30.490
Okay.

269
00:19:30.490 --> 00:19:30.910
There you go.

270
00:19:30.910 --> 00:19:34.960
So you're saying the spelling rights of Section Zero and we're displaying the grades and of Section

271
00:19:34.960 --> 00:19:38.380
one is being shown here and two is being shown here.

272
00:19:38.620 --> 00:19:44.620
Now, one last, final thing is let's also find the highest grade in each of the sections, and let's

273
00:19:44.620 --> 00:19:45.670
also display that.

274
00:19:45.820 --> 00:19:48.610
So let's use a variable called Max here.

275
00:19:48.940 --> 00:19:52.030
Let's say Max is equal to zero.

276
00:19:53.940 --> 00:19:55.560
And we need to find.

277
00:19:57.590 --> 00:19:58.460
The max.

278
00:19:58.460 --> 00:20:02.060
So we'll say here in the second iteration will say F.

279
00:20:03.230 --> 00:20:07.190
So we are iterating through one of the each of the sections here.

280
00:20:08.110 --> 00:20:14.470
So in the first iteration we are it will be this array in the second iteration of the outer loop.

281
00:20:14.740 --> 00:20:18.610
So this would be the second array, the second class.

282
00:20:19.750 --> 00:20:22.140
And then I is equal to three.

283
00:20:22.150 --> 00:20:23.320
We are iterating through.

284
00:20:23.350 --> 00:20:24.130
I is equal to two.

285
00:20:24.160 --> 00:20:25.870
We are iterating through this thing.

286
00:20:26.470 --> 00:20:29.590
The inner far loop would iterate through this particular one.

287
00:20:30.160 --> 00:20:36.520
So here we are saying if student grades of I am a J is greater than max.

288
00:20:37.360 --> 00:20:39.070
So it is initially zero.

289
00:20:40.360 --> 00:20:42.340
Then we need to reassign.

290
00:20:43.960 --> 00:20:44.950
Max bet.

291
00:20:48.560 --> 00:20:50.150
Student greats of icon magic.

292
00:20:51.920 --> 00:20:55.070
And finally, we will print the max value here.

293
00:21:03.950 --> 00:21:04.580
There you go.

294
00:21:05.000 --> 00:21:07.850
So the outer loop is printing this.

295
00:21:08.090 --> 00:21:13.430
And in each iteration we are also finding the max and the max value is printed here.

296
00:21:13.430 --> 00:21:15.140
So over here the max is 90.

297
00:21:15.290 --> 00:21:22.010
And when we have when we are in the second iteration, we are finding the max in this particular area.

298
00:21:22.040 --> 00:21:25.610
So in the second iteration, the max would be re initialized again.

299
00:21:26.300 --> 00:21:29.210
In fact, it is declared inside this for loop.

300
00:21:29.210 --> 00:21:31.880
So Max is declared once again.

301
00:21:32.150 --> 00:21:36.680
So in the second iteration it prints 71 because that's the highest.

302
00:21:36.680 --> 00:21:41.210
And in the final iteration, Max would be 91.

303
00:21:41.720 --> 00:21:45.650
So that's how you can find the maximum value here.

304
00:21:45.950 --> 00:21:47.360
So that's about it.

305
00:21:47.630 --> 00:21:48.230
Thank you.

306
00:21:48.230 --> 00:21:53.570
And do code this up and that's it and happy coding and see you in the next lecture.

