WEBVTT
1
00:00:00.980 --> 00:00:07.470
Let's not look at two dimensional art Gutierrez what we saw in the previous lesson we're one dimensional

2
00:00:07.470 --> 00:00:15.360
art is a one dimensional array can be visualized as a sequence of elements laid out along a line in

3
00:00:15.360 --> 00:00:21.490
a tree you can visualize elements to be laid out in a great form like in The Matrix.

4
00:00:21.570 --> 00:00:25.020
In fact mattresses are usually implemented using tree areas.

5
00:00:25.410 --> 00:00:30.630
It's also possible to how arrays of higher dimensions but they are very rare in practice.

6
00:00:30.690 --> 00:00:38.790
So let's just go ahead and see how UDRS are created integrated elements are arranged in rows and columns

7
00:00:38.790 --> 00:00:39.780
.

8
00:00:39.790 --> 00:00:47.610
Here is a two dimensional array that has four rows and columns and has a total of eight elements like

9
00:00:47.610 --> 00:00:48.810
a one dimensional array.

10
00:00:48.820 --> 00:00:56.250
It is also an object in Java and it can start with primitives an object references index numbering for

11
00:00:56.250 --> 00:00:59.370
both rows and columns beginning with zero.

12
00:01:00.420 --> 00:01:07.140
Now if this arrays named as my array then my array at indexes 0 and 1 will get it and the element from

13
00:01:07.140 --> 00:01:11.260
0 throw unfussy column which has a value of 11.

14
00:01:11.520 --> 00:01:14.910
So with this can be implemented using such dreariest.

15
00:01:15.390 --> 00:01:21.120
Similarly for the common student example unconsidered would students on their assignments scores in

16
00:01:21.120 --> 00:01:22.480
a particular course.

17
00:01:22.800 --> 00:01:28.410
Then we can store that information in a query each that can correspond with a student and the values

18
00:01:28.410 --> 00:01:35.210
stored in each row can be the assignment of course like in the case of one dimensional arrays.

19
00:01:35.340 --> 00:01:40.530
There are three ways to create gutiérrez And they're also created using similar syntax.

20
00:01:40.530 --> 00:01:43.900
Let's look at how we can create Overmeyer example.

21
00:01:44.520 --> 00:01:48.000
And here's a fast way to do it similar to one dimensional arrays.

22
00:01:48.030 --> 00:01:51.520
We use the word new in one dimensional array.

23
00:01:51.570 --> 00:01:55.770
We had only one pair of square brackets on either side of the assignment.

24
00:01:56.130 --> 00:02:01.080
Since we know how two dimensions we will have two pairs so square brackets on either side of the assignment

25
00:02:01.920 --> 00:02:03.040
on the right hand side.

26
00:02:03.120 --> 00:02:08.310
The number of rows is indicated in the first square brackets while the number of columns is indicated

27
00:02:08.310 --> 00:02:10.380
in the second square brackets.

28
00:02:10.380 --> 00:02:13.300
The square brackets on the left hand side will be empty.

29
00:02:13.410 --> 00:02:20.370
Let's see how JVM internally implements this to the three Gibeon basically creates a one dimensional

30
00:02:20.370 --> 00:02:24.690
array with four elements corresponding to the four rows.

31
00:02:25.500 --> 00:02:32.370
And these four elements do not contain the raw data but each of the elements is actually an object reference

32
00:02:32.720 --> 00:02:36.320
reference to another and array with two elements.

33
00:02:36.330 --> 00:02:42.840
And these are referenced in arrays represent actual rows and they contain the actual data as a byte

34
00:02:42.840 --> 00:02:48.510
for the arrays and all of the internal arrays are initialized with default 0.

35
00:02:48.540 --> 00:02:52.960
You can also see the two dimensional index numbers associated with each element.

36
00:02:53.550 --> 00:03:00.330
So you can see that it is actually implemented as a one be array under elements or simply object references

37
00:03:00.900 --> 00:03:07.140
which are done differencing one dimensional address this fact can be observed in the declaration itself

38
00:03:07.160 --> 00:03:07.590
.

39
00:03:08.010 --> 00:03:11.430
So let's review the declaration once again.

40
00:03:11.430 --> 00:03:17.280
We know that an articulation includes a type followed by square brackets which is then followed by the

41
00:03:17.340 --> 00:03:21.850
Iranian and we can read it as an army of bike.

42
00:03:22.770 --> 00:03:31.490
Now if the pipe is and we can read it as an army off and on we know it is a one dimensional array.

43
00:03:31.570 --> 00:03:40.230
Now the pipe itself is trade off and then we can read it as an arc of RF and or in other words on off

44
00:03:40.290 --> 00:03:42.180
and of it.

45
00:03:42.240 --> 00:03:47.880
So although it doesn't set the machinery in reality it is actually one dimensionality.

46
00:03:49.160 --> 00:03:53.170
No not my example elements where any dealings with default value.

47
00:03:53.490 --> 00:03:55.680
So we need to initialize them explicitly.

48
00:03:55.740 --> 00:03:58.490
And that can be done as shown here.

49
00:03:59.290 --> 00:04:04.890
And this is an illustration of how the RL looks after element initialization.

50
00:04:05.400 --> 00:04:09.330
Here is the second way to create a query in one be array.

51
00:04:09.360 --> 00:04:16.810
We only had commas operator values but we know that a 2D array is an array of some type.

52
00:04:17.339 --> 00:04:23.760
So we have one array and within that array we have nested arrays with each an asterisk corresponding

53
00:04:23.760 --> 00:04:31.290
to zero and for each history we will have a pair of nested braces on the actual DWB side in that nested

54
00:04:31.290 --> 00:04:33.950
braces.

55
00:04:34.260 --> 00:04:39.990
Finally as in the case of one dimensional arrays we have this simplest notation.

56
00:04:39.990 --> 00:04:43.680
Now here we have something interesting in our Meyera example.

57
00:04:43.800 --> 00:04:49.000
We saw that there were four rows on all of the rows were sorting the same number of elements.

58
00:04:49.020 --> 00:04:50.700
That is two elements.

59
00:04:50.700 --> 00:04:55.050
So each will have two elements but due to the bit Djala implements.

60
00:04:55.050 --> 00:05:01.580
Or is it also possible for different rows in a truly array to have different number of elements.

61
00:05:01.620 --> 00:05:02.880
So let's see how that's possible.

62
00:05:02.940 --> 00:05:05.540
And also where it can be useful.

63
00:05:06.540 --> 00:05:14.620
So here we created €2 with duros but we don't specify any value for the number of columns.

64
00:05:14.700 --> 00:05:21.360
Next we cleared the first row which would have five elements or five columns Mexicans would be created

65
00:05:21.360 --> 00:05:23.280
with two elements.

66
00:05:23.280 --> 00:05:26.380
So as you can see the column size is not fixed.

67
00:05:26.550 --> 00:05:28.230
Kruskal now has five columns.

68
00:05:28.260 --> 00:05:35.950
When the second row has only two columns one example use of this kind of recreation is a symmetric marker

69
00:05:35.950 --> 00:05:42.300
X with the number of rows is equal to the number of columns and elements about the diagonal which are

70
00:05:42.300 --> 00:05:47.250
shown in red here are simply duplicate of elements below that I acknowledged which are shown in blue

71
00:05:47.250 --> 00:05:49.710
.

72
00:05:49.740 --> 00:05:55.050
So by creating an array with irregular row sizes begin to watch dooring that duplicate in red.

73
00:05:55.270 --> 00:06:00.270
And so the symmetric matrix will now be a triangular matrix as shown here.

74
00:06:00.270 --> 00:06:03.470
Each row will be represented by an array of different.

75
00:06:03.690 --> 00:06:06.780
In this example frontrow would be an array of length one.

76
00:06:06.810 --> 00:06:10.400
Well secondo would be an array of Lendu and so on.

77
00:06:10.410 --> 00:06:16.530
So that's a pretty cool way to save some storage space and it would be very useful for very large mattresses

78
00:06:18.720 --> 00:06:20.850
like in the case of one dimensional array.

79
00:06:21.060 --> 00:06:24.630
Lenth field can also be used on it.

80
00:06:25.280 --> 00:06:31.230
However since internally the array is implemented as a one dimensional array accessing lenth from the

81
00:06:31.230 --> 00:06:37.930
ARI would return the number of rows in our miring example which are four rows on two columns land would

82
00:06:37.940 --> 00:06:46.590
read for accessing left on the first element of my arm would return to this example shows how we can

83
00:06:46.590 --> 00:06:50.030
make a reference to one of the rows which is a suburb.

84
00:06:50.460 --> 00:06:55.260
So he had a variable called row which is an array is assigned the third row.

85
00:06:55.380 --> 00:06:57.770
Since index numbering begins with zero.

86
00:06:58.300 --> 00:07:01.070
And that's the end of our discussion on the arrays.

87
00:07:01.140 --> 00:07:06.270
Probiotics are sometimes very useful but are much less commonly used than one dimensional allergies

88
00:07:07.230 --> 00:07:09.070
later in the first version of our project.

89
00:07:09.090 --> 00:07:14.940
We will use two areas similar to the way we extended the syntax from one to two dimensions.

90
00:07:15.000 --> 00:07:21.240
We can further extend to higher dimensions dimensions higher than two dimensions are pretty rare in

91
00:07:21.240 --> 00:07:21.900
practice

