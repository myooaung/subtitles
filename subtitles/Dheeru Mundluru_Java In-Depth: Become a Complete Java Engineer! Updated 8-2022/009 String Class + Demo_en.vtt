WEBVTT
1
00:00:02.110 --> 00:00:02.920
Hi there.

2
00:00:02.950 --> 00:00:04.240
This is the model group.

3
00:00:04.570 --> 00:00:06.939
So we understand what a string is.

4
00:00:07.300 --> 00:00:10.000
Next, we need to learn about string manipulation.

5
00:00:10.690 --> 00:00:14.110
For that, we need to get a good understanding of the string class.

6
00:00:16.010 --> 00:00:21.470
We know that that string class is from the Java Lang package, which means that it's a very fundamental

7
00:00:21.470 --> 00:00:25.310
class and it supports several methods to manipulate strings.

8
00:00:25.610 --> 00:00:30.710
And these methods allow us to perform certain common operations which are shown here.

9
00:00:31.630 --> 00:00:38.980
So we have methods to compare to strengths or to search for one string within another, or to examine

10
00:00:38.980 --> 00:00:44.110
individual characters in a string, or to even extract some strings from a string.

11
00:00:44.980 --> 00:00:46.960
There are also key conversion methods.

12
00:00:46.990 --> 00:00:51.160
For example, we may want a copy of a string button uppercase on the.

13
00:00:52.020 --> 00:00:57.600
And there are also methods to replace one or more parts of a string with some other text.

14
00:00:58.570 --> 00:01:03.040
Finally, there are also methods to split a string based on some characters.

15
00:01:03.670 --> 00:01:08.380
So let's go ahead and look at several methods that perform these common operations.

16
00:01:10.840 --> 00:01:10.970
Okay.

17
00:01:11.050 --> 00:01:15.700
I'm going to show this demo in my Eclipse editor, but you can continue using the editor that you're

18
00:01:15.700 --> 00:01:18.880
using right now, and it's not going to make any difference.

19
00:01:19.150 --> 00:01:26.230
So for this demo, I added a new method called string examples to the basic demo class, and the string

20
00:01:26.230 --> 00:01:28.540
examples is going to be invoked from the main method.

21
00:01:28.870 --> 00:01:35.410
So all the code has been written and we are just going to run and look at the and analyze the output

22
00:01:35.740 --> 00:01:39.580
because there are a lot of methods that we are going to look at in the string class.

23
00:01:39.670 --> 00:01:43.510
So it will be very time consuming to write everything down.

24
00:01:43.600 --> 00:01:50.410
So we are going to look at a lot of these methods now and we know that it's already mentioned that the

25
00:01:50.410 --> 00:01:55.000
methods fall under different categories like the common operations are comparison searching.

26
00:01:55.000 --> 00:01:57.400
So we are going to look at all of the common operations.

27
00:01:58.030 --> 00:02:03.910
So this is the method and initially we are declaring this method, this variable called TSS, which

28
00:02:03.910 --> 00:02:09.699
is string, and it has the string called as Helloworld and we are printing it out and the first two

29
00:02:09.699 --> 00:02:16.510
methods here are length and is empty and all the methods are here and the remaining methods they have

30
00:02:16.510 --> 00:02:22.150
been commented out and we are going to uncomment them and look, look at those methods one at a time.

31
00:02:22.750 --> 00:02:26.050
So let me just go ahead and run it around the class.

32
00:02:26.050 --> 00:02:27.700
So let me just click here on.

33
00:02:28.910 --> 00:02:29.470
Here.

34
00:02:29.480 --> 00:02:33.410
So the length method returns the the size of the string.

35
00:02:33.410 --> 00:02:34.730
That is the length of the string.

36
00:02:34.730 --> 00:02:38.090
In this case it has 12 characters, so it's going to return 12.

37
00:02:39.170 --> 00:02:40.760
And that is empty method.

38
00:02:40.760 --> 00:02:42.590
It's it returns a Boolean value.

39
00:02:42.590 --> 00:02:48.290
It just returns a true if the string is empty, which means that the length is zero.

40
00:02:48.350 --> 00:02:52.490
But in this case, since the length is 12, it is going to return a false.

41
00:02:53.250 --> 00:02:55.640
So those are the left and the SNP methods.

42
00:02:55.650 --> 00:03:03.240
So let me just comment these two statements and let's let's look at the next.

43
00:03:04.090 --> 00:03:09.910
Bunch of methods which are comparison methods may comment this.

44
00:03:11.320 --> 00:03:15.520
So here there are three methods equals equals ignore case and compare to.

45
00:03:16.240 --> 00:03:17.710
And let me just run them.

46
00:03:19.320 --> 00:03:19.650
Okay.

47
00:03:19.650 --> 00:03:24.120
So the equals method is just going to compare the two strings.

48
00:03:24.510 --> 00:03:31.680
TSS Here is as has the hello world and the argument is also hello world.

49
00:03:31.680 --> 00:03:37.020
So it's, it's going to compare both the strings and if both the strings are equal it's going to return

50
00:03:37.020 --> 00:03:37.440
it true.

51
00:03:37.440 --> 00:03:38.940
Otherwise it returns a false.

52
00:03:38.940 --> 00:03:45.300
In this case it returns a false because one of them is in lowercase while the other one is in uppercase.

53
00:03:45.300 --> 00:03:49.410
So the case matters here and so it returns a false.

54
00:03:50.070 --> 00:03:53.130
Now the next method is equals ignore case.

55
00:03:53.130 --> 00:03:56.040
So it is saying that we need to ignore the case.

56
00:03:56.040 --> 00:03:59.370
So that's the reason why we get a true value here.

57
00:03:59.370 --> 00:04:02.220
Because once we ignore the case, both the strings are same.

58
00:04:03.000 --> 00:04:08.920
Now the third method is compared to so the earlier two methods return a boolean value, whereas a compared

59
00:04:08.920 --> 00:04:15.520
to method returns an end value and it will return either a negative integer or a positive integer or

60
00:04:15.520 --> 00:04:16.180
zero.

61
00:04:16.209 --> 00:04:19.660
It will return zero if the two strings are exactly identical.

62
00:04:20.410 --> 00:04:25.120
But what this method does is it compares the two strings, lexicography.

63
00:04:25.900 --> 00:04:32.380
Now we know that the strings are internally represented as UTF 16, which is one of the Unicode schemes.

64
00:04:32.710 --> 00:04:38.500
So the strings would have some each character in the string would have a Unicode value.

65
00:04:38.740 --> 00:04:44.530
And what this method is going to do is it's going to compare the Unicode value of the characters in

66
00:04:44.530 --> 00:04:45.550
the two strings.

67
00:04:45.700 --> 00:04:47.740
So that's what it says it's going to do.

68
00:04:48.100 --> 00:04:49.960
Compare the two strings lexical graphically.

69
00:04:49.960 --> 00:04:54.370
And the comparison here is based on the Unicode value of each character in the strings.

70
00:04:54.970 --> 00:05:02.200
So when we hover over this method, we get this description here and here it says the result is a negative

71
00:05:02.200 --> 00:05:02.930
integer.

72
00:05:02.950 --> 00:05:08.470
If this string object, whenever it says this string object, it means that we are talking about the

73
00:05:08.470 --> 00:05:11.260
current object, which would be as in this case.

74
00:05:11.440 --> 00:05:17.710
And it says, if the string object lexicography actually precedes the argument string, then the result

75
00:05:17.710 --> 00:05:19.330
is a negative integer.

76
00:05:19.750 --> 00:05:26.920
But if the string if the string object lexicography really follows the argument string, then it would

77
00:05:26.920 --> 00:05:28.870
be a positive integer.

78
00:05:29.800 --> 00:05:33.810
So in this case, it returns a 32.

79
00:05:33.820 --> 00:05:41.290
And that's because this particular the input string which is in lowercase, actually follows the, the,

80
00:05:41.390 --> 00:05:43.780
the argument string which is in uppercase.

81
00:05:44.410 --> 00:05:50.320
So in Unicode, always, if you look at the Unicode table, you will see that the uppercase letters

82
00:05:50.920 --> 00:05:53.140
come before the lowercase letters.

83
00:05:53.140 --> 00:05:58.960
And because of that, in this case, because the two strings are identical, but the character small

84
00:05:58.960 --> 00:06:06.940
lowercase h here in the that is being referenced by s here comes after the uppercase H.

85
00:06:06.940 --> 00:06:10.240
So because of that, it returns a positive integer.

86
00:06:10.420 --> 00:06:15.520
Now, let me just change this to let's say let's make it Z here.

87
00:06:16.150 --> 00:06:17.560
And this one is H.

88
00:06:17.950 --> 00:06:21.520
In this case, this is going to precede this one.

89
00:06:21.520 --> 00:06:23.950
And so we will get a negative value.

90
00:06:26.770 --> 00:06:28.450
See it returns -18.

91
00:06:29.410 --> 00:06:30.910
So that's what it is.

92
00:06:30.910 --> 00:06:33.520
So you can take a look at this compared to a method.

93
00:06:33.520 --> 00:06:40.930
You can look at the API and you can read this carefully so that you can digest it properly.

94
00:06:41.230 --> 00:06:43.570
So basically, it returns three values only.

95
00:06:43.750 --> 00:06:46.690
So that's that's about the comparison methods.

96
00:06:46.690 --> 00:06:49.090
So let me just comment them out.

97
00:06:51.270 --> 00:06:54.600
And let's look at the search methods now.

98
00:06:57.050 --> 00:06:59.030
So there are a lot of search methods here.

99
00:07:01.130 --> 00:07:01.250
Okay.

100
00:07:01.430 --> 00:07:05.120
So these are the search methods and let's run it.

101
00:07:06.980 --> 00:07:13.000
Okay so we have contains starts with and with index of and last index of.

102
00:07:13.880 --> 00:07:21.470
So here it just checks if this string contains the argument string and once again case matters.

103
00:07:21.470 --> 00:07:24.530
So because they are of different case, it returns false.

104
00:07:25.270 --> 00:07:33.040
Now the second method is as DOT contains word world and it is also in lowercase and our input on our

105
00:07:33.040 --> 00:07:38.590
string that s is referencing is Hello world and world is part of that string, right?

106
00:07:38.590 --> 00:07:40.810
So because of that it returns it true.

107
00:07:41.440 --> 00:07:48.280
Now the next one is starts with starts with is also a very important method and it says F the current

108
00:07:48.280 --> 00:07:50.950
string starts with the input string.

109
00:07:51.400 --> 00:07:54.820
Once again case matters so it would return a false.

110
00:07:55.180 --> 00:08:01.240
But for the second one we are using the same case as as the as the current string.

111
00:08:01.240 --> 00:08:03.340
So because of that it would return it.

112
00:08:03.340 --> 00:08:03.820
True.

113
00:08:05.080 --> 00:08:07.780
So it could be helloworld or it could be just hello.

114
00:08:07.780 --> 00:08:10.760
Also, even in that case it would return it now.

115
00:08:10.900 --> 00:08:17.110
And so it is just exactly reverse of starts with it just checks if the current string ends with this

116
00:08:17.110 --> 00:08:21.400
particular string, it need not be a single character, it can be multiple characters also.

117
00:08:21.670 --> 00:08:24.610
So in this case it's an exclamation mark on the current string.

118
00:08:24.610 --> 00:08:30.460
Also Hello World also ends with and with an exclamation so it would return it to.

119
00:08:31.760 --> 00:08:38.720
The next one is index of here we are doing a search and we are checking if this input string, the argument

120
00:08:38.720 --> 00:08:43.490
string is present in the in the current string.

121
00:08:43.520 --> 00:08:51.160
If this if if these characters appear in the string, then it is going to return the index of that now.

122
00:08:51.440 --> 00:08:51.880
Hello.

123
00:08:52.070 --> 00:08:53.450
Okay, let's just consider this.

124
00:08:53.450 --> 00:08:54.410
Hello world here.

125
00:08:54.560 --> 00:08:56.540
So low is appearing here.

126
00:08:56.570 --> 00:08:59.550
Zero, zero, one, two and three.

127
00:08:59.570 --> 00:08:59.920
Hello.

128
00:08:59.930 --> 00:09:00.290
It's.

129
00:09:00.510 --> 00:09:00.950
It's good.

130
00:09:01.020 --> 00:09:02.570
So that's the index position.

131
00:09:02.570 --> 00:09:04.810
That's the start of the index position at three.

132
00:09:04.820 --> 00:09:07.310
So that's why we get an index of three.

133
00:09:07.790 --> 00:09:14.360
So if you want to if you want to know the index of a particular string, then you can use the index

134
00:09:14.360 --> 00:09:15.200
of operation.

135
00:09:15.470 --> 00:09:21.440
And here we are just doing index of or instead of L or we are doing an index of O and O is actually

136
00:09:21.440 --> 00:09:23.810
appearing here at the fourth position.

137
00:09:23.810 --> 00:09:27.080
I'm just showing it here because it's just the same string that we have.

138
00:09:27.410 --> 00:09:31.550
So all will over return an index of four.

139
00:09:32.000 --> 00:09:33.980
The index position starts with zero.

140
00:09:34.190 --> 00:09:42.140
Just remember that it's not from one and the last one is last index of because this particular character

141
00:09:42.140 --> 00:09:45.680
here can appear at multiple places in the string.

142
00:09:45.890 --> 00:09:51.350
So this one here we are requesting to give the last index of position.

143
00:09:54.000 --> 00:09:57.900
Now, if the character does not appear in this thing, then it would return a minus one.

144
00:09:58.290 --> 00:10:02.940
So if it appears, then it would return the index position, otherwise it would return the minus one.

145
00:10:03.210 --> 00:10:08.280
So here index of would return the first index position where the character is appearing or it would

146
00:10:08.280 --> 00:10:15.600
return minus one last index of would return the last index position where the particular character is

147
00:10:15.600 --> 00:10:16.170
appearing.

148
00:10:16.410 --> 00:10:19.200
So the methods, as you can see, are very meaningfully named.

149
00:10:19.530 --> 00:10:22.110
So that's about those methods.

150
00:10:22.110 --> 00:10:26.400
So let me just go ahead and comment this out.

151
00:10:35.200 --> 00:10:38.950
Next, let's look at both individual characters and also extracting some strengths.

152
00:10:39.840 --> 00:10:40.040
Okay.

153
00:10:40.050 --> 00:10:41.580
So let me just run this.

154
00:10:42.440 --> 00:10:42.590
Okay.

155
00:10:42.770 --> 00:10:44.210
So this particular.

156
00:10:45.210 --> 00:10:45.990
Here.

157
00:10:46.560 --> 00:10:48.650
This particular method character.

158
00:10:49.200 --> 00:10:54.240
So it's just we are requesting to retain the character at that particular position for.

159
00:10:54.600 --> 00:10:56.010
So here is the hello world.

160
00:10:56.190 --> 00:11:02.070
And at fourth position, zero one, two, three and four, we have the letter.

161
00:11:02.850 --> 00:11:05.130
The letter O, and that's being written here.

162
00:11:06.110 --> 00:11:11.720
So here we can see the output and the next two methods are about extracting sub strings.

163
00:11:12.050 --> 00:11:13.990
So these are also important methods.

164
00:11:14.000 --> 00:11:23.210
So the first method would return the substring starting from the index position for the end of the current

165
00:11:23.210 --> 00:11:23.720
string.

166
00:11:24.200 --> 00:11:32.000
So from here the fourth position is oh, and it's going to return the the entire substring from the

167
00:11:32.000 --> 00:11:36.590
index position for the end of the string which would be this particular string.

168
00:11:37.010 --> 00:11:38.870
So that's how you will get substring.

169
00:11:39.110 --> 00:11:45.380
And there is also an overloaded substring method which would return a substring between these two indices

170
00:11:45.380 --> 00:11:48.020
where for it's four and nine.

171
00:11:48.020 --> 00:11:53.810
Here, four is inclusive and nine is exclusive, which means that we should not include the character

172
00:11:53.810 --> 00:11:59.480
at the ninth position, but we should include the character at position four and all the characters

173
00:11:59.480 --> 00:12:02.030
in between two, but not the one at nine.

174
00:12:02.300 --> 00:12:05.330
So that would return this particular string.

175
00:12:05.630 --> 00:12:06.590
It starts from here.

176
00:12:06.590 --> 00:12:09.970
Four, five, six, seven, eight.

177
00:12:09.980 --> 00:12:12.230
And it's not going to include the ninth one.

178
00:12:12.800 --> 00:12:14.960
So that's about extracting some strings.

179
00:12:16.970 --> 00:12:21.740
So these are all very important methods when we are doing string manipulation, text manipulation,

180
00:12:22.490 --> 00:12:29.630
which should be pretty common these days because we have a lot of text on the web and we have to process

181
00:12:29.630 --> 00:12:30.560
a lot of text.

182
00:12:31.100 --> 00:12:34.250
So next are the uppercase and the lowercase.

183
00:12:34.250 --> 00:12:35.840
And let's look at both of these.

184
00:12:36.720 --> 00:12:38.370
The key is conversion methods.

185
00:12:38.520 --> 00:12:39.870
So to look at that train method.

186
00:12:39.870 --> 00:12:40.890
So let me run it.

187
00:12:42.000 --> 00:12:42.330
Here.

188
00:12:42.330 --> 00:12:47.490
Uppercase is simply going to convert the current string, which is in lowercase.

189
00:12:47.490 --> 00:12:55.440
It's going to convert it into uppercase and the lowercase method simply converts it into lowercase,

190
00:12:55.440 --> 00:12:56.820
but it's already in lowercase.

191
00:12:56.820 --> 00:12:59.250
So we are good, but still it tries to convert.

192
00:12:59.820 --> 00:13:03.330
In case if if it was in some other case, it would have converted it.

193
00:13:03.690 --> 00:13:04.410
So okay.

194
00:13:04.470 --> 00:13:08.730
And just note that we mentioned that string is immutable.

195
00:13:08.880 --> 00:13:14.130
So when we do two uppercase, it's going to return a copy of the string.

196
00:13:14.130 --> 00:13:16.980
It's not going to convert that particular string itself.

197
00:13:17.580 --> 00:13:23.700
So it's just going to return a copy of the of this particular string, but an uppercase.

198
00:13:23.970 --> 00:13:25.620
That's because string is immutable.

199
00:13:25.620 --> 00:13:27.810
We cannot we cannot mutate it.

200
00:13:28.800 --> 00:13:30.570
And here is the trim method.

201
00:13:30.570 --> 00:13:38.400
And the trim method would simply return a copy of a string after trimming any leading and trailing white

202
00:13:38.400 --> 00:13:39.210
spaces.

203
00:13:39.540 --> 00:13:45.510
So if there are any white spaces, either at the beginning of the string or at the end, so those will

204
00:13:45.510 --> 00:13:46.200
be trimmed.

205
00:13:46.620 --> 00:13:53.640
So sometimes that would be very important because when we in documents be a lot of times we have white

206
00:13:53.640 --> 00:13:57.510
spaces, especially when we're dealing with web pages.

207
00:13:58.780 --> 00:14:02.110
Now next is the replace method, which is also very important.

208
00:14:02.800 --> 00:14:07.960
Sometimes we may want to replace some special characters in a piece of text with with whitespace or

209
00:14:07.960 --> 00:14:08.920
something like that.

210
00:14:09.010 --> 00:14:10.450
So we will need that.

211
00:14:10.630 --> 00:14:11.500
So.

212
00:14:12.630 --> 00:14:13.750
Let me comment that.

213
00:14:15.820 --> 00:14:15.980
Okay.

214
00:14:16.030 --> 00:14:22.420
So here we are replacing the character and the input string with the character.

215
00:14:22.420 --> 00:14:26.130
Ah, so you can see that o is replaced with ah here.

216
00:14:27.070 --> 00:14:33.640
Typically you might want to replace a particular some special symbols with you know with an empty,

217
00:14:33.700 --> 00:14:36.900
with an empty string or something like that or replace commas here.

218
00:14:37.050 --> 00:14:37.870
Here is an example.

219
00:14:37.870 --> 00:14:39.970
So we have nice little description here.

220
00:14:40.090 --> 00:14:45.340
If you want to replace commas with whitespace, then you can put a comma here and you can put an empty

221
00:14:45.340 --> 00:14:45.940
string here.

222
00:14:45.940 --> 00:14:50.020
So you would just do this, it would be an empty string and that's it.

223
00:14:50.020 --> 00:14:52.390
And it would replace the cosmos with the empty string.

224
00:14:53.440 --> 00:14:54.700
So that's very useful.

225
00:14:56.110 --> 00:14:56.830
Now.

226
00:14:59.730 --> 00:15:02.160
Let's look at the spring split method.

227
00:15:02.340 --> 00:15:05.340
And after the split we have the value of.

228
00:15:05.880 --> 00:15:07.230
So let's look at.

229
00:15:10.830 --> 00:15:11.850
The split method.

230
00:15:12.060 --> 00:15:18.060
So as the name suggests, it's going to split the input string using this particular character here,

231
00:15:18.060 --> 00:15:23.280
which is Oh, so when we split it returns an array of strings here.

232
00:15:23.280 --> 00:15:25.290
You can see that it's an array of strings.

233
00:15:26.160 --> 00:15:30.840
Now, in this case, all is appearing twice, one here and one here.

234
00:15:30.990 --> 00:15:33.210
So it's going to return three strings.

235
00:15:33.540 --> 00:15:43.080
This is one substring hel here l And between the two occurrences there is one more substring whitespace

236
00:15:43.080 --> 00:15:52.020
and w and after the last substring is this one are d followed by an exclamation, and we are just iterating

237
00:15:52.020 --> 00:15:55.320
through the list of string sub strings and we are printing it.

238
00:15:55.560 --> 00:16:02.820
So sometimes you might want to split a document into words, you might want to split them by whitespace

239
00:16:02.820 --> 00:16:06.960
so you can just put a whitespace here and it would split the entire document.

240
00:16:07.320 --> 00:16:12.720
If the document is being stored in the string here, if the string represents a document, it would

241
00:16:13.050 --> 00:16:13.800
do that.

242
00:16:14.280 --> 00:16:20.280
Or if sometimes if you are processing some documents and if you're processing a particular line of text

243
00:16:20.310 --> 00:16:26.520
and in the line of text, you might have some data and the data might be separated by types or comma

244
00:16:26.520 --> 00:16:30.060
or whitespace, in which case you can split them.

245
00:16:30.060 --> 00:16:35.400
So the tab would be a delimiter here, or comma, comma or whitespace could be the delimiter.

246
00:16:35.400 --> 00:16:38.790
So you can specify the delimiter here and split that particular line.

247
00:16:38.790 --> 00:16:46.980
So you can split when you're processing certain documents you where the data is delimited by these kind

248
00:16:46.980 --> 00:16:47.940
of characters.

249
00:16:48.000 --> 00:16:48.930
Mm.

250
00:16:48.930 --> 00:16:51.240
Then you can make use of the split.

251
00:16:51.990 --> 00:16:54.900
So that's the split method, very useful method.

252
00:16:59.440 --> 00:17:01.810
And finally we have the static method.

253
00:17:03.310 --> 00:17:03.450
Okay.

254
00:17:03.640 --> 00:17:05.550
So this is a static method.

255
00:17:05.560 --> 00:17:10.359
All the methods that we have seen so far are instance methods of the string class.

256
00:17:10.359 --> 00:17:15.040
But this one is a static method and that's why we are directly accessing the value of method here.

257
00:17:15.880 --> 00:17:20.260
And it would return a string representation of this double value.

258
00:17:20.829 --> 00:17:22.540
So it returns a string of the double value.

259
00:17:22.540 --> 00:17:28.720
As you can see here, it returns the data type that's being returned is a string, so it's just going

260
00:17:28.720 --> 00:17:29.770
to return the string.

261
00:17:29.770 --> 00:17:30.850
So let me just run it.

262
00:17:32.580 --> 00:17:33.100
Here it is.

263
00:17:33.120 --> 00:17:37.110
It returns a string representation and there are also other overloaded methods.

264
00:17:37.380 --> 00:17:41.940
So these are some of the important methods and there are many other methods, many of them overloaded

265
00:17:41.940 --> 00:17:45.780
methods, and there are also there can be also other methods in the string class.

266
00:17:45.780 --> 00:17:52.800
So I would encourage you to look at the API and familiarize yourself with all the methods in the API

267
00:17:52.800 --> 00:17:55.650
in the string class, because it's a very important class.

268
00:17:56.250 --> 00:17:58.740
So that's about the string class.

269
00:17:58.860 --> 00:18:03.240
Now let's just head back to our slides and finish off the lecture.

270
00:18:05.760 --> 00:18:12.900
Here are some extremely useful third party string utility classes, and these classes do offer additional

271
00:18:12.900 --> 00:18:18.960
features that are usually not available in the standard string class that comes with the Java library.

272
00:18:19.530 --> 00:18:25.110
Sometimes they may offer very similar features like the string class, but they may enable you to write

273
00:18:25.110 --> 00:18:26.580
much more cleaner code.

274
00:18:27.150 --> 00:18:33.240
So although you will extensively use the string class, it is very likely that you will use one or both

275
00:18:33.240 --> 00:18:34.440
of these utilities.

276
00:18:35.190 --> 00:18:41.220
The first one is the Apache Common Slang Library, which is from the Apache Commons project, and it

277
00:18:41.220 --> 00:18:46.560
includes a very popular class called String Utils, which is used for string manipulation.

278
00:18:47.160 --> 00:18:50.730
I have also used this class quite a bit and some of my projects.

279
00:18:51.740 --> 00:18:52.130
Next.

280
00:18:52.130 --> 00:18:56.210
Google's go up project also includes a few string utility classes.

281
00:18:56.900 --> 00:19:01.910
So just be aware that these classes exist and they are commonly used by developers.

282
00:19:02.360 --> 00:19:04.820
At some point you should check out their APIs.

283
00:19:05.210 --> 00:19:11.690
And also, don't forget to check out the API of the string class as it is very commonly used in general.

284
00:19:11.690 --> 00:19:16.760
If you have to perform some string manipulation and if you are not aware of any of the methods in the

285
00:19:16.760 --> 00:19:20.480
string class which may help you with it, then just go for it.

286
00:19:20.480 --> 00:19:26.090
And it is likely that there will be some method either in the string class or one of these third party

287
00:19:26.090 --> 00:19:28.520
libraries that may help you with your task.

288
00:19:29.150 --> 00:19:34.820
In the worst case, almost always you will discover some post on StackOverflow which could help you

289
00:19:34.820 --> 00:19:35.390
with that.

290
00:19:35.990 --> 00:19:39.830
So always do your research on Google before coming up with some new logic.

291
00:19:40.490 --> 00:19:41.210
All right, then.

292
00:19:41.210 --> 00:19:42.080
That's about it.

293
00:19:42.080 --> 00:19:44.630
And I hope you like learning about the string class.

294
00:19:44.630 --> 00:19:45.380
Thank you.

