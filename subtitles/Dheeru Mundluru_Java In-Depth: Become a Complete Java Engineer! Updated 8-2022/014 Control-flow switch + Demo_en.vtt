WEBVTT
1
00:00:01.030 --> 00:00:04.960
Now let's look at the next control flow statement, which is a switch statement.

2
00:00:05.680 --> 00:00:10.390
A switch statement has a lot of details involved, and we'll try to get a very clear understanding of

3
00:00:10.390 --> 00:00:10.810
it.

4
00:00:11.230 --> 00:00:16.210
And as we go along, we will also look at some code and test most of the stuff we learn.

5
00:00:16.750 --> 00:00:18.940
So let's get started with the switch statement.

6
00:00:20.810 --> 00:00:25.040
A switch statement can be used as an alternative to if statement.

7
00:00:25.760 --> 00:00:32.030
Notice that can hear, which means that we cannot represent all if statements using switch statements.

8
00:00:32.330 --> 00:00:37.970
Only a certain type of statements can be represented using switch statements and we will see what those

9
00:00:37.970 --> 00:00:38.390
are.

10
00:00:40.110 --> 00:00:44.310
Let's consider this if statement where the variable month is initialized to three.

11
00:00:44.850 --> 00:00:50.580
The if statement has a sequence of conditions where each condition simply tests if the month matches

12
00:00:50.580 --> 00:00:56.430
a certain value here since month is three, the third condition will be true and the value match gets

13
00:00:56.430 --> 00:00:57.000
printed.

14
00:00:57.630 --> 00:01:01.350
Now let's see how the same code can be represented using a switch statement.

15
00:01:03.090 --> 00:01:05.940
And here is the switch statement and it is not yet complete.

16
00:01:06.300 --> 00:01:10.500
We will build it gradually by comparing it with the if example we just saw.

17
00:01:11.280 --> 00:01:17.730
So to begin with, the syntax involves the keyword switch followed by parentheses with a switch expression,

18
00:01:18.210 --> 00:01:21.570
and the switch expression is the variable month in our example.

19
00:01:22.350 --> 00:01:25.200
Parenthesis is followed by the opening and closing presses.

20
00:01:25.380 --> 00:01:30.810
Closing press indicates the end of the switch statement and the entire block of code between the two

21
00:01:30.810 --> 00:01:33.720
braces is referred to as a switch block.

22
00:01:34.570 --> 00:01:38.680
Now notice that the switch expression in the parentheses is simply the variable month.

23
00:01:39.480 --> 00:01:42.690
So it is not a condition but simply a variable.

24
00:01:43.170 --> 00:01:46.650
But we know that control flow statements are all about conditions.

25
00:01:47.250 --> 00:01:48.800
So we need to have conditions.

26
00:01:48.810 --> 00:01:54.990
And for that, a switch statement uses something called case statements, which involves the reserved

27
00:01:54.990 --> 00:02:00.990
keyboard case, which is followed by what is called a case label, which is in turn followed by a column.

28
00:02:01.410 --> 00:02:04.710
And after the colon, we may optionally have some statements.

29
00:02:05.490 --> 00:02:11.460
Now, a condition would be the switch expression compared with the case label using an E quality operator.

30
00:02:12.000 --> 00:02:17.520
So in our example, we have three conditions with variable month being matched with the case labels

31
00:02:17.520 --> 00:02:18.780
one, two and three.

32
00:02:19.410 --> 00:02:24.240
Since month is three, it will match the third case label and so the corresponding statements will be

33
00:02:24.240 --> 00:02:25.050
executed.

34
00:02:25.860 --> 00:02:28.620
Not that the switch expression can also be a literal.

35
00:02:29.010 --> 00:02:34.560
So instead of having variable montage speech expression, we can also instead have the literal three.

36
00:02:35.640 --> 00:02:41.160
You can notice the optional brake statement too, and it indicates the end of switch statement itself.

37
00:02:41.520 --> 00:02:45.710
That is a terminates the enclosing switch without a brake statement.

38
00:02:45.720 --> 00:02:52.050
All subsequent case blocks are executed in sequence regardless of their case tables until a brake is

39
00:02:52.050 --> 00:02:52.830
encountered.

40
00:02:53.860 --> 00:02:57.270
Also the break statement has to be the last statement in the case block.

41
00:02:57.640 --> 00:03:02.560
Otherwise, we get a compiler error as any statements following it are unreachable.

42
00:03:03.510 --> 00:03:03.750
No.

43
00:03:03.750 --> 00:03:10.200
Comparing the speech example with our F example, you may wonder what corresponds to the default block

44
00:03:10.710 --> 00:03:14.670
for that which supports a default block, as you can see here.

45
00:03:15.490 --> 00:03:20.740
The default blog simply has the keyword default followed by colon, which is followed by its block of

46
00:03:20.740 --> 00:03:22.450
code like any case block.

47
00:03:22.960 --> 00:03:25.570
So a default block does not have a case label.

48
00:03:26.470 --> 00:03:33.190
Note that we can have at most one default block, but one difference from if statement is that default

49
00:03:33.190 --> 00:03:35.350
block may be followed by case blocks.

50
00:03:35.680 --> 00:03:38.290
That is default block need not be the last block.

51
00:03:39.170 --> 00:03:45.620
However, if you recall in an EF statement, the LS block if present must be the last block of the code.

52
00:03:46.400 --> 00:03:51.320
Since default block need not be the last block, it can also have an optional brake statement.

53
00:03:53.130 --> 00:03:56.940
Now, here is an important thing to note about the type of speech expression.

54
00:03:58.690 --> 00:04:05.050
A speech explosion can be an integer, that it can be a little like seven or it can be an integer variable,

55
00:04:05.080 --> 00:04:10.000
or it can also be an expression involving more than one variable like x plus y.

56
00:04:10.600 --> 00:04:14.950
Only requirement is that the final value the expression evaluates to should be an integer.

57
00:04:17.240 --> 00:04:22.820
Now when we say an integer variable, it can be a variable of type eight or any of the smaller data

58
00:04:22.820 --> 00:04:23.390
types.

59
00:04:24.630 --> 00:04:28.770
Additionally, the variable can also be an instance of these classes.

60
00:04:29.190 --> 00:04:31.860
That is a variable can be an object reference to.

61
00:04:32.650 --> 00:04:39.340
And these classes are called box primitives or wrapper classes as the wrapper primitive value.

62
00:04:39.970 --> 00:04:43.810
For example, here, integer class would wrap a primitive end value.

63
00:04:44.600 --> 00:04:50.660
So at runtime, when the variable is evaluated, the primitive value will be unwrapped and will be compared

64
00:04:50.660 --> 00:04:51.830
with the case labels.

65
00:04:52.430 --> 00:04:55.490
Later, we will look at box parameters and how they are useful.

66
00:04:57.180 --> 00:05:01.950
A switch expression can also be a string, and this works only from Java seven onwards.

67
00:05:02.280 --> 00:05:07.340
That is using string as a switch expression in an earlier version of Java will result in a compiler

68
00:05:07.350 --> 00:05:07.860
error.

69
00:05:09.580 --> 00:05:14.770
Finally, a switch expression can also be an enum and idioms will be discussed much later.

70
00:05:15.550 --> 00:05:19.720
So if a switch expression is something other than these three, then we get a compiler error.

71
00:05:20.540 --> 00:05:26.120
Moreover, if such expression evaluates to null at one time, then we get a null pointer exception.

72
00:05:26.600 --> 00:05:31.880
Since we mentioned that we can have object references as fetch expression, there is a possibility for

73
00:05:31.880 --> 00:05:35.270
ending up with a null reference and getting a null pointer exception.

74
00:05:37.060 --> 00:05:39.640
There are also a few things to note about case labels.

75
00:05:40.480 --> 00:05:46.780
First restriction is that the value of case label must be within the range of the data type of the switch

76
00:05:46.780 --> 00:05:47.410
expression.

77
00:05:47.950 --> 00:05:50.410
In the next slide, we will look at an example of this.

78
00:05:51.010 --> 00:05:56.230
The second restriction is that the value of case label must be known at compile time itself.

79
00:05:57.180 --> 00:05:58.890
We will also look at an example of this.

80
00:05:58.890 --> 00:06:00.840
So let's not worry about it for now.

81
00:06:01.640 --> 00:06:04.910
Third restriction is that the case label value must be unique.

82
00:06:05.300 --> 00:06:08.900
That is, you cannot have duplicate case labels in the same switch statement.

83
00:06:09.380 --> 00:06:12.110
And fourth is that case label cannot be null.

84
00:06:12.860 --> 00:06:16.340
If any of these restrictions are not met, we get a compiler error.

85
00:06:18.110 --> 00:06:20.760
Now let's look at the first restriction with an example.

86
00:06:21.380 --> 00:06:27.260
First restriction is that the case label value must be within the range of the data type of the switch

87
00:06:27.260 --> 00:06:27.920
expression.

88
00:06:28.790 --> 00:06:31.520
In this example, we have declared as a byte.

89
00:06:31.940 --> 00:06:39.080
So we know that the range of byte data type is -128 to 127, and hence the case labels should also be

90
00:06:39.080 --> 00:06:40.010
within this range.

91
00:06:40.720 --> 00:06:46.060
Since the second case level is 128, which is outside the range of byte, we get a compiler error.

92
00:06:46.960 --> 00:06:50.770
Let's now actually start our demo and look at this particular restriction to.

93
00:06:53.000 --> 00:06:53.570
Look at this time.

94
00:06:53.570 --> 00:06:59.150
Let me show the demo in my eclipse ide and this is to just save some time development.

95
00:06:59.150 --> 00:07:05.510
Using Eclipse ID is very fast and in this particular demo we will have to compile the program several

96
00:07:05.510 --> 00:07:09.950
times and it would be very time consuming without without using an ID.

97
00:07:09.980 --> 00:07:13.460
So with using Eclipse, the program will be auto compiled.

98
00:07:13.460 --> 00:07:15.380
So it's very easy to do so.

99
00:07:15.380 --> 00:07:16.970
It will basically save us some time.

100
00:07:17.300 --> 00:07:17.440
Okay.

101
00:07:17.540 --> 00:07:22.340
So a new method called switch example has been added to the basics demo class and you can also download

102
00:07:22.340 --> 00:07:25.970
it from the resources section and it's just the same example.

103
00:07:25.970 --> 00:07:31.100
So we are defining a variable called Month with three and here is the switch statement and here are

104
00:07:31.100 --> 00:07:36.440
the three case labels, three case labels and we are just printing the month values and we have the

105
00:07:36.440 --> 00:07:38.540
break statements and we also have a default.

106
00:07:38.540 --> 00:07:41.030
BLOCK So let me just start on this program.

107
00:07:41.030 --> 00:07:47.150
We have to just go here and click Run and it says Inside Switch example and it's printing March because

108
00:07:47.150 --> 00:07:50.690
month is matching with the value with the case level value three.

109
00:07:51.650 --> 00:07:59.390
Now let's look at one of the things we said was that switch expression type has to be only integer string

110
00:07:59.390 --> 00:08:00.260
or enum.

111
00:08:00.380 --> 00:08:02.150
So let's just make it double here.

112
00:08:02.150 --> 00:08:05.930
So let's just put 2.0, which is a double value.

113
00:08:05.930 --> 00:08:10.280
And as you can see, it shows this, it's underlined with with this red thing.

114
00:08:10.280 --> 00:08:16.130
So it means that there is a compilation error and it says that cannot switch on a value of type double.

115
00:08:16.340 --> 00:08:22.250
So it has to be either int integer or it has to be a string or an enum.

116
00:08:23.250 --> 00:08:27.300
And we also said that we can use a box primitive as a speech expression.

117
00:08:27.300 --> 00:08:28.620
So let's also try that.

118
00:08:29.190 --> 00:08:32.460
So let's use integer class.

119
00:08:33.270 --> 00:08:34.320
Let's call it month.

120
00:08:37.030 --> 00:08:38.030
The value three.

121
00:08:41.070 --> 00:08:42.150
And as you can see.

122
00:08:43.020 --> 00:08:47.250
So the compiler error has also gone and if you run it, it still prints much.

123
00:08:47.580 --> 00:08:50.610
So you can use a wrapper class like an integer.

124
00:08:52.020 --> 00:08:56.550
And next, let me just delete this.

125
00:08:57.500 --> 00:09:02.900
Let's look at the range restriction where the case label should be, should fall within the range of

126
00:09:02.900 --> 00:09:05.150
the data type of the switch expression.

127
00:09:05.270 --> 00:09:07.640
So let me just change it to byte here.

128
00:09:09.440 --> 00:09:11.270
And so we have these three values.

129
00:09:11.270 --> 00:09:14.150
So byte range is -128 to 127.

130
00:09:14.480 --> 00:09:18.350
Now, let me just change this to 128.

131
00:09:18.920 --> 00:09:26.510
Now it says it gives a compiler error and it says that cannot convert from INT to byte.

132
00:09:27.620 --> 00:09:32.660
So and that's because this is an eight and it cannot be converted to byte.

133
00:09:32.660 --> 00:09:34.040
We need an explicit cast.

134
00:09:34.310 --> 00:09:38.510
And since the range is outside of byte, we are getting this error.

135
00:09:38.510 --> 00:09:44.150
So one thing we can do is just do a cast here, and that's one solution.

136
00:09:44.810 --> 00:09:51.490
So it needs to be within the range because if you do the cast, then you know the value gets Doncaster

137
00:09:51.500 --> 00:09:52.430
to some value.

138
00:09:52.440 --> 00:09:56.230
So we are numbered between between -128 to 127.

139
00:09:56.240 --> 00:09:59.750
So without this it's outside the range and it gives the compiler error.

140
00:10:00.600 --> 00:10:03.200
Okay, let's just head back to our slides.

141
00:10:05.330 --> 00:10:06.560
So as we just saw.

142
00:10:06.590 --> 00:10:12.950
Compiler must know the value of case label, otherwise it will never know whether or not the value is

143
00:10:12.950 --> 00:10:15.800
within the range of the switch expressions data type.

144
00:10:16.460 --> 00:10:22.370
Due to this, the second restriction says that case label value has to be a constant expression.

145
00:10:22.640 --> 00:10:24.560
And let's look at it through this example.

146
00:10:25.460 --> 00:10:28.070
The example is almost identical to the previous code.

147
00:10:28.700 --> 00:10:31.910
Only addition is a variable month to here.

148
00:10:31.910 --> 00:10:36.140
The value of the first case label, which is one is known at compile time itself.

149
00:10:36.720 --> 00:10:41.580
So the compiler knows that the value is within the range of byte, which is the data type of the switch

150
00:10:41.580 --> 00:10:42.240
expression.

151
00:10:42.780 --> 00:10:46.260
But for the second case label, the variable month too is used.

152
00:10:46.800 --> 00:10:52.350
However, such variables are evaluated only at runtime, and so their values are not known at compile

153
00:10:52.350 --> 00:10:52.800
time.

154
00:10:53.130 --> 00:10:59.100
So the compiler does not know if the value that month to host would be within the range of byte data

155
00:10:59.100 --> 00:10:59.940
type or not.

156
00:11:00.480 --> 00:11:03.180
So this causes a code to generate a compiler error.

157
00:11:03.660 --> 00:11:06.630
So the solution is to use a constant expression.

158
00:11:08.300 --> 00:11:13.190
And a constant expression would be either an integer literal or a string literal.

159
00:11:14.040 --> 00:11:19.200
A string letter is simply text enclosed in double chords and we will look at strings in the next chapter.

160
00:11:20.750 --> 00:11:27.650
Also a constant expression can be a constant variable, and a constant variable is just a variable like

161
00:11:27.650 --> 00:11:34.010
month two, but it must be declared with a keyword called final and it must also have been initialized.

162
00:11:34.780 --> 00:11:38.440
So in our example, since month two, it's already initialized.

163
00:11:38.680 --> 00:11:45.220
If you just add the keyword final before the variable type byte, then it would become a constant variable

164
00:11:45.880 --> 00:11:48.060
and final variables will be discussed later.

165
00:11:48.070 --> 00:11:53.560
But it just means that the value of the variable once initialized can never be changed.

166
00:11:53.770 --> 00:11:55.660
That is, value is constant.

167
00:11:56.170 --> 00:11:59.740
Value is final since the value is constant.

168
00:11:59.770 --> 00:12:05.260
Compiler knows whether or not the value is within the range of the switch expressions data type.

169
00:12:05.830 --> 00:12:09.400
So if the value is outside the range, then it would give a compiler error.

170
00:12:10.210 --> 00:12:14.080
Just note that a constant expression has a more broader definition.

171
00:12:14.260 --> 00:12:21.310
But within the context of such statement, it just boils down to integer or string literals and constant

172
00:12:21.310 --> 00:12:21.910
variable.

173
00:12:22.660 --> 00:12:25.420
Let's now actually test this example in our code.

174
00:12:27.900 --> 00:12:28.110
Okay.

175
00:12:28.110 --> 00:12:32.580
Let's just go ahead and add the new variable month, too, which is also byte.

176
00:12:33.820 --> 00:12:36.160
Initialize it to two and.

177
00:12:37.510 --> 00:12:38.860
Change this label.

178
00:12:40.240 --> 00:12:41.080
Two month to.

179
00:12:42.070 --> 00:12:48.550
And we can see that there is a compiler error and it says case expressions must be constant expressions.

180
00:12:48.760 --> 00:12:49.300
Right.

181
00:12:49.480 --> 00:12:56.170
So so the case label has to be a constant expression and a constant expression, as we saw earlier,

182
00:12:56.320 --> 00:13:02.200
can be either an integer literal or a string literal within the context of a switch.

183
00:13:03.070 --> 00:13:05.830
Or it can be a constant variable.

184
00:13:06.280 --> 00:13:07.750
And we said for that we need to.

185
00:13:08.910 --> 00:13:12.880
Add this key word called final and it has to be initialized also.

186
00:13:12.900 --> 00:13:16.710
If it's not initialized, then it's not a constant variable.

187
00:13:17.340 --> 00:13:19.710
They also call it as a compile time constant.

188
00:13:20.100 --> 00:13:21.390
So this is what it is.

189
00:13:21.390 --> 00:13:25.920
So now you can see that we don't have the compilation error anymore.

190
00:13:26.370 --> 00:13:32.220
So what is going to happen is at compile time, if it's a compile time, if it's a constant variable,

191
00:13:32.880 --> 00:13:38.730
then the compiler would take this value too and would insert it here in the byte code.

192
00:13:38.880 --> 00:13:40.460
And why is it doing so?

193
00:13:40.470 --> 00:13:42.510
Because it's a compile time constant.

194
00:13:42.510 --> 00:13:48.370
It's a final variable, which means that the value is not going to be changed once initialized.

195
00:13:48.390 --> 00:13:50.010
So it's a final value.

196
00:13:50.670 --> 00:13:55.860
So since it's not going to be changed, it can just take this value and plug it here so it's going to

197
00:13:55.890 --> 00:13:56.880
hardwire it.

198
00:13:57.600 --> 00:14:00.300
So that's the benefit of it.

199
00:14:00.480 --> 00:14:08.820
But you might also say if it is like this, you might ask, why doesn't compiler do the same thing?

200
00:14:08.820 --> 00:14:10.230
Because it knows that it's two.

201
00:14:10.230 --> 00:14:12.480
Then why does it have to give a compiler error?

202
00:14:13.140 --> 00:14:17.250
That's because the value is not final in this case, so the value can be changed.

203
00:14:17.280 --> 00:14:20.880
Now let's just, for instance, assume that it's an instance variable.

204
00:14:20.880 --> 00:14:22.560
So it's defined at the class level.

205
00:14:23.190 --> 00:14:26.070
So the so the value could have been changed.

206
00:14:26.100 --> 00:14:30.830
Let's say if it was an instance variable and it was initialized to two, that value could have been

207
00:14:30.840 --> 00:14:33.080
changed anywhere in some other method also.

208
00:14:33.150 --> 00:14:33.710
Right.

209
00:14:33.870 --> 00:14:37.350
So and the compiler is not going to keep track of all of that.

210
00:14:38.070 --> 00:14:40.770
So it's just way too complicated for it.

211
00:14:40.920 --> 00:14:48.810
So so that's the reason it's not a final value and such kind of variables which are not final are evaluated

212
00:14:48.810 --> 00:14:50.340
only at runtime.

213
00:14:51.270 --> 00:14:52.470
So that's the thing.

214
00:14:52.470 --> 00:14:55.670
So it needs to be a constant variable like this.

215
00:14:55.680 --> 00:14:57.060
Now it's not going to change.

216
00:14:57.390 --> 00:15:00.120
Now, let me just comment this out.

217
00:15:02.770 --> 00:15:05.440
And let's not worry about this also.

218
00:15:06.620 --> 00:15:08.360
Let's just say switch example.

219
00:15:08.360 --> 00:15:14.150
I wrote a second method switch example of let's just pass two.

220
00:15:15.540 --> 00:15:18.260
It's to it's right below this method.

221
00:15:19.670 --> 00:15:20.480
Here it is.

222
00:15:21.520 --> 00:15:22.750
So it's just the same code.

223
00:15:22.750 --> 00:15:25.630
The code, the entire switch statement has been moved here.

224
00:15:27.240 --> 00:15:32.850
And here the parameter is month to over here.

225
00:15:33.980 --> 00:15:37.040
And even in this scenario you see everything else is same.

226
00:15:37.040 --> 00:15:40.590
So month two is here, month two is here, month is defined here, month as defined here.

227
00:15:40.610 --> 00:15:45.410
Even in this case, it's going to give a compiler error because it's a method parameter.

228
00:15:45.410 --> 00:15:48.680
Here you see it's a final, but it's still a method parameter.

229
00:15:49.070 --> 00:15:51.140
So it's got to be initialized.

230
00:15:51.170 --> 00:15:53.090
It's got to be initialized to begin with.

231
00:15:53.210 --> 00:15:56.960
So only then it can be considered as a constant variable.

232
00:15:56.960 --> 00:15:58.760
Otherwise it's not a constant variable.

233
00:15:59.480 --> 00:16:01.370
So this is not a constant variable.

234
00:16:02.180 --> 00:16:03.590
So that's all there is.

235
00:16:03.920 --> 00:16:07.670
And let's also look at the last two restrictions of case labels.

236
00:16:07.670 --> 00:16:10.790
One is that it needs to be unique and the other as constant.

237
00:16:11.660 --> 00:16:12.890
The case label cannot be null.

238
00:16:12.890 --> 00:16:14.420
So let's also test that out.

239
00:16:15.640 --> 00:16:16.600
Minimum this.

240
00:16:18.650 --> 00:16:22.970
And let's change it back to let's make it one here.

241
00:16:22.970 --> 00:16:24.350
So both of them are one.

242
00:16:24.350 --> 00:16:25.970
And so we have a compiler error.

243
00:16:25.970 --> 00:16:33.920
So it needs to be unique and this cannot be null also cannot be non excess, cannot convert from null

244
00:16:33.920 --> 00:16:34.520
to byte.

245
00:16:34.520 --> 00:16:35.960
So this is byte and this is null.

246
00:16:36.290 --> 00:16:40.190
So those were the last two restrictions and that's about it.

247
00:16:40.190 --> 00:16:45.770
So just go ahead and you can download this program and you can try it out to OC OC then.

248
00:16:45.770 --> 00:16:46.280
Thank you.

249
00:16:46.280 --> 00:16:48.530
And let's just go back to the slides.

250
00:16:51.040 --> 00:16:52.420
Here is a useful tip.

251
00:16:52.750 --> 00:16:55.840
It's a good practice to always use a break statement.

252
00:16:56.050 --> 00:17:02.920
That is, you can have one even within the last block as it would avoid any errors if new case blocks

253
00:17:02.920 --> 00:17:04.119
are introduced later.

254
00:17:06.310 --> 00:17:10.839
Next question is when is it not feasible to use a switch statement?

255
00:17:13.089 --> 00:17:17.170
Switch statement cannot be used when we have more than one condition to test.

256
00:17:19.190 --> 00:17:22.040
Next is one condition to test is not equality.

257
00:17:22.490 --> 00:17:26.450
That is we can use which only if we need to do equality tests.

258
00:17:28.130 --> 00:17:29.360
This one is important.

259
00:17:29.390 --> 00:17:35.000
It cannot be used when switch expression is something other than integer string or enum.

260
00:17:35.480 --> 00:17:37.190
This was already discussed earlier.

261
00:17:39.260 --> 00:17:44.840
Finally, a switch cannot be used if at least one of the case label restrictions does not apply.

262
00:17:45.110 --> 00:17:46.370
So that's obvious.

263
00:17:47.240 --> 00:17:52.340
So for all these cases, we cannot use a switch statement and have to go with an EF statement.

264
00:17:53.370 --> 00:17:58.020
In the next lesson, we will see when a switch can be preferred over an EF statement.

265
00:17:58.710 --> 00:17:59.810
So that's about it.

266
00:17:59.820 --> 00:18:03.270
And we have taken a pretty in-depth look at the switch statement.

267
00:18:03.300 --> 00:18:04.050
Thank you.

