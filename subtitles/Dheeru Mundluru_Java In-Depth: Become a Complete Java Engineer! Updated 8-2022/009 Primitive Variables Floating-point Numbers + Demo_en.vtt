WEBVTT
1
00:00:02.009 --> 00:00:02.980
Hello there.

2
00:00:03.000 --> 00:00:04.170
This is De La Rue.

3
00:00:04.170 --> 00:00:05.190
And welcome back.

4
00:00:05.310 --> 00:00:09.660
Now, let's look at data types that represent floating point numbers.

5
00:00:11.020 --> 00:00:16.780
Floating point numbers are real numbers like 3.14, and they can be negative two.

6
00:00:17.350 --> 00:00:24.910
And they are good for measurements such as product rating or distances between two points or temperature

7
00:00:24.910 --> 00:00:26.560
and so on and so forth.

8
00:00:27.100 --> 00:00:32.800
And in Java they can be represented by either float or double data types.

9
00:00:33.800 --> 00:00:36.280
And here is the table with more information about it.

10
00:00:36.290 --> 00:00:40.700
And double table is similar to the one that we saw for integers.

11
00:00:40.910 --> 00:00:47.450
One new column has been added to indicate precision, which indicates the number of digits we can have

12
00:00:47.450 --> 00:00:49.250
after the decimal point.

13
00:00:50.170 --> 00:00:52.450
Like integer data types float and double.

14
00:00:52.450 --> 00:00:54.640
Also get a default of zero.

15
00:00:55.210 --> 00:01:02.260
Note that variables declared within the methods do not get such a default value and here the trailing

16
00:01:02.260 --> 00:01:05.830
f indicates float while the trailing D indicates double.

17
00:01:06.610 --> 00:01:08.530
So let's start with fraud.

18
00:01:08.560 --> 00:01:17.650
Fraud is represented in 32 bits and can take any value between plus or -3.4 times ten to the power of

19
00:01:17.680 --> 00:01:18.340
38.

20
00:01:18.970 --> 00:01:25.600
Here the notation with an E is called as exponential or scientific notation, and E can be in either

21
00:01:25.600 --> 00:01:27.100
upper or lower case.

22
00:01:27.580 --> 00:01:34.120
Generally, such a scientific notation is used only when representing very large or very small numbers.

23
00:01:35.020 --> 00:01:41.950
And with regards to precision with flawed, we can have at most 6 to 7 decimal digits.

24
00:01:43.450 --> 00:01:48.940
Next double is represented in 64 beds and hence can store larger range of values.

25
00:01:49.480 --> 00:01:57.310
And the range of values it can store is in between plus or -1.7 times ten to the power of 308.

26
00:01:58.190 --> 00:02:04.550
And with regards to precision, with double, we can have at most 15 to 16 decimal digits.

27
00:02:05.120 --> 00:02:09.500
So as we can see, double is more precise when compared to float.

28
00:02:10.280 --> 00:02:15.800
So just try to memorize this, the information in this table as much as possible, just like in the

29
00:02:15.800 --> 00:02:17.030
case of integers.

30
00:02:17.780 --> 00:02:23.880
Here we can see that we have the value 1.74 double and 3.4 for float.

31
00:02:23.900 --> 00:02:25.240
So it's just twice.

32
00:02:25.250 --> 00:02:26.840
So that's a way to remember.

33
00:02:27.020 --> 00:02:32.420
And for the exponent part, you have 38 for float and 308 for double.

34
00:02:33.380 --> 00:02:35.360
So that's just a tip to remember.

35
00:02:35.780 --> 00:02:41.330
So we can see precision here, 6 to 7 digits for float and 15 to 16 digits for double.

36
00:02:41.600 --> 00:02:48.050
So if a number has more decimal digits than what a float or double can represent, then it cannot be

37
00:02:48.050 --> 00:02:52.160
accurately represented and hence would be approximated.

38
00:02:52.850 --> 00:02:59.300
That is, the number of decimal digits would be reduced to 6 to 7 or 15 to 16 depending on the data

39
00:02:59.300 --> 00:02:59.780
type.

40
00:03:00.380 --> 00:03:02.810
Number PI is one such example.

41
00:03:03.630 --> 00:03:10.110
With real numbers, even within a small range of numbers like, say, point one and point two, we can

42
00:03:10.110 --> 00:03:12.330
have infinite real numbers.

43
00:03:12.930 --> 00:03:19.560
So many of these numbers cannot be accurately represented by either float or double because they have

44
00:03:19.560 --> 00:03:21.270
limited number of bits.

45
00:03:22.270 --> 00:03:28.390
And of the two it is recommended to use double as it is more precise.

46
00:03:29.330 --> 00:03:32.780
And in general, you should stick with eight and double.

47
00:03:33.170 --> 00:03:40.220
So among the integer data types and is what you should be using, but if the value falls outside the

48
00:03:40.220 --> 00:03:42.710
range of it, then you can use long.

49
00:03:44.090 --> 00:03:50.240
And if memory saving is critical, then you can think about using smaller sized data types like byte

50
00:03:50.240 --> 00:03:55.730
short and float, and you can also use them if you think it helps with readability.

51
00:03:56.570 --> 00:04:00.920
And it seems game development is one area where float is preferred.

52
00:04:02.520 --> 00:04:10.650
Now internally java users ie seven 5414 point scheme to represent float and double recall that it was

53
00:04:10.650 --> 00:04:13.080
signed to complement scheme for integers.

54
00:04:13.680 --> 00:04:16.149
In the earlier lecture on integer data types.

55
00:04:16.170 --> 00:04:22.079
I mentioned about a link provided in the resources section which discusses about these internal data

56
00:04:22.079 --> 00:04:25.710
representation schemes like Tripoli 754 format.

57
00:04:26.340 --> 00:04:28.800
So if needed, at some point you can check it out.

58
00:04:28.830 --> 00:04:30.360
It's a really good article.

59
00:04:30.780 --> 00:04:36.060
Now let's switch over to Ed and look at how float and double variables are declared.

60
00:04:38.750 --> 00:04:40.430
Here we are in the student class.

61
00:04:40.460 --> 00:04:45.170
So let's go ahead and extend this class and add a new floating point variable.

62
00:04:45.470 --> 00:04:48.090
But before doing that, let's do some cleanup here.

63
00:04:48.110 --> 00:04:49.790
Let's remove all of this.

64
00:04:50.210 --> 00:04:51.870
Let's remove this main value.

65
00:04:51.890 --> 00:04:54.200
Max value variables.

66
00:04:54.530 --> 00:04:56.900
And let's also remove this rank here.

67
00:04:56.900 --> 00:04:58.470
I think we don't need that.

68
00:04:58.490 --> 00:05:00.020
So this is good enough.

69
00:05:00.650 --> 00:05:02.250
So let's leave this as byte.

70
00:05:02.270 --> 00:05:04.400
We don't have to change it to end.

71
00:05:05.000 --> 00:05:10.100
We said that we should be preferring int and double data types, but let's leave it like that and let's

72
00:05:10.100 --> 00:05:11.960
also remove this the print statements.

73
00:05:13.160 --> 00:05:14.920
So this is the student class.

74
00:05:14.930 --> 00:05:20.090
Just in case you have missed the previous lectures, let me just give a quick recap of this.

75
00:05:20.090 --> 00:05:24.320
So we have the student class and we declared a few variables like the ID here.

76
00:05:24.320 --> 00:05:27.380
So the student ID is thousand and the age is 18.

77
00:05:27.380 --> 00:05:29.120
And then the phone number is this one.

78
00:05:29.810 --> 00:05:34.610
And we have one method here called compute where we are printing all of these values.

79
00:05:34.910 --> 00:05:39.950
And here we have one variable called next ID, which is nothing but ID plus one.

80
00:05:39.950 --> 00:05:41.690
So it would be 1001.

81
00:05:42.170 --> 00:05:49.340
And in the main method we are creating an object of student and we are just invoking this method compute.

82
00:05:49.730 --> 00:05:50.720
So that's all we are doing.

83
00:05:50.720 --> 00:05:59.000
So let's add our new variable, lets the data type be float and the variable is GPA.

84
00:05:59.150 --> 00:06:07.100
GPA stands for grade point average and it is used to judge the performance of a student in a particular

85
00:06:07.100 --> 00:06:14.660
semester based on the grades he or she receives for the different courses, for the different courses

86
00:06:14.660 --> 00:06:16.280
that the student is enrolled in.

87
00:06:16.280 --> 00:06:18.440
So it's called a grade point average.

88
00:06:18.440 --> 00:06:20.600
So it's just an average of the grades.

89
00:06:20.870 --> 00:06:28.250
So GPA is something that many universities and colleges across the world use to judge students performance

90
00:06:28.760 --> 00:06:29.750
in every semester.

91
00:06:29.750 --> 00:06:35.180
They have a certain GPA, but for the entire program itself, let's say it's a bachelor's or a master's

92
00:06:35.180 --> 00:06:42.470
program, they would also have GPA, which would be an average of the grades of all of the courses.

93
00:06:43.170 --> 00:06:50.280
So many universities across the world follow GPA and GPA typically is for 4.0.

94
00:06:50.280 --> 00:06:51.540
So that's the maximum.

95
00:06:51.840 --> 00:06:57.960
And let's say the student has a GPA of 3.8, which is a very good GPA.

96
00:06:58.290 --> 00:06:59.220
So that's it.

97
00:06:59.220 --> 00:07:04.440
And for flawed, we have a trailing F, so that's mandatory.

98
00:07:04.440 --> 00:07:09.600
So that's a must and it can be either in lowercase or uppercase.

99
00:07:09.600 --> 00:07:11.610
And let's also print this value here.

100
00:07:15.600 --> 00:07:19.310
And so this is in the basics folder.

101
00:07:19.320 --> 00:07:21.720
So we need to be in the basics folder.

102
00:07:21.720 --> 00:07:27.150
So we have the directory structure here and let's just compile student.

103
00:07:31.950 --> 00:07:34.290
So I prints GPA here.

104
00:07:34.950 --> 00:07:36.770
So this is a float literal.

105
00:07:36.780 --> 00:07:40.380
So let's see what happens if we remove the trailing f.

106
00:07:43.620 --> 00:07:47.910
So it gives a compilation error and this error message should be familiar to you.

107
00:07:47.910 --> 00:07:52.800
It says incompatible types, possible lossy conversion from double to float.

108
00:07:53.820 --> 00:07:57.690
So what it means is we are trying to assign a double literal.

109
00:07:58.140 --> 00:08:04.350
So if you do not include the trailing f here, then it would be a double data type.

110
00:08:04.650 --> 00:08:09.690
So by default, if you do not include anything, it's going to be a double literal and we are trying

111
00:08:09.690 --> 00:08:15.630
to assign a double to a float and that's not possible and double is a larger data type.

112
00:08:15.660 --> 00:08:16.590
So that's the thing.

113
00:08:16.590 --> 00:08:18.480
So we need to change this to double.

114
00:08:18.480 --> 00:08:19.980
So let's change it to double.

115
00:08:21.030 --> 00:08:22.560
Now let's compile it.

116
00:08:24.810 --> 00:08:25.890
And compiles fine.

117
00:08:26.310 --> 00:08:28.200
And it prints a value 3.8.

118
00:08:28.470 --> 00:08:31.590
So by default, it would be a double letter.

119
00:08:31.830 --> 00:08:38.730
Now, if you wish, you can also put a DD here and it can be either in lowercase or uppercase.

120
00:08:38.730 --> 00:08:41.630
And that would indicate that it's a double data type.

121
00:08:41.640 --> 00:08:45.150
So if you do not include anything, it's still going to be double literal.

122
00:08:48.860 --> 00:08:49.970
And run it.

123
00:08:50.300 --> 00:08:51.620
So that's that.

124
00:08:52.440 --> 00:08:53.820
And you clear up the screen.

125
00:08:54.690 --> 00:08:59.020
Now, we also mentioned about the scientific notation or exponential notation.

126
00:08:59.040 --> 00:09:03.590
So that would be E and let's say we have four.

127
00:09:03.600 --> 00:09:07.500
So it would be 3.8 times ten to the power of four.

128
00:09:08.190 --> 00:09:09.600
So that would be how much?

129
00:09:09.600 --> 00:09:10.680
38,000.

130
00:09:15.290 --> 00:09:15.980
There you go.

131
00:09:16.460 --> 00:09:22.700
So such a scientific notation is used when you want to represent very large or very small numbers.

132
00:09:23.330 --> 00:09:26.990
Now, next thing is let's look at the precision.

133
00:09:29.150 --> 00:09:32.090
We said with double, it would be 15 to 16 digits.

134
00:09:32.090 --> 00:09:33.470
So we have more than that.

135
00:09:38.330 --> 00:09:38.890
Okay.

136
00:09:38.900 --> 00:09:41.930
Now, here, let me market.

137
00:09:42.260 --> 00:09:43.820
So it's four here.

138
00:09:44.300 --> 00:09:45.200
Eight.

139
00:09:46.540 --> 00:09:48.100
12 and 15.

140
00:09:48.520 --> 00:09:56.860
So this huge number has been truncated to 15 digits because double has a precision of 15.

141
00:09:56.860 --> 00:09:58.210
So that's a truncation.

142
00:09:58.210 --> 00:10:04.690
So there is an approximation and besides that, there is something called rounding that has been done.

143
00:10:04.690 --> 00:10:10.330
So the last digit is actually nine, so it has been rounded to nine.

144
00:10:10.330 --> 00:10:11.620
So that's what they say.

145
00:10:12.010 --> 00:10:13.570
So that's called a rounding.

146
00:10:14.200 --> 00:10:16.960
So the number is just approximate.

147
00:10:17.380 --> 00:10:21.130
So we can see that the preciseness is around 15 to 16 digits.

148
00:10:21.130 --> 00:10:27.430
Now let's change this to float and let's put the mandatory F here.

149
00:10:31.040 --> 00:10:34.850
Recompile and rerun it.

150
00:10:35.210 --> 00:10:41.150
Now it is printing three, four, five, six, seven can have a max of seven digits.

151
00:10:41.150 --> 00:10:44.930
So that's why the rest of the digits have been truncated.

152
00:10:45.170 --> 00:10:46.340
So that's very flawed.

153
00:10:46.700 --> 00:10:51.140
So that's all there is with float and double data types.

154
00:10:51.140 --> 00:10:56.960
So let me just change it back to double, because double is what we need to be using.

155
00:10:56.960 --> 00:10:58.910
So that's the suggested data type.

156
00:10:59.540 --> 00:11:04.100
And among INT it is the INT data type that we need to be using most of the time.

157
00:11:04.580 --> 00:11:05.260
That's it.

158
00:11:05.270 --> 00:11:06.110
Thank you.

159
00:11:06.140 --> 00:11:08.480
Happy coding and see you in the next lecture.

