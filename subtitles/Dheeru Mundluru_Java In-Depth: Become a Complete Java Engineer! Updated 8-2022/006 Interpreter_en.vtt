WEBVTT
1
00:00:01.050 --> 00:00:02.009
Hi there.

2
00:00:02.040 --> 00:00:02.730
This is zero.

3
00:00:03.870 --> 00:00:10.080
So we have seen that software developed using compiler languages like C are not platform independent.

4
00:00:10.620 --> 00:00:16.620
Now let's look at interpreters which address the platform dependency issue but have some other limitations.

5
00:00:17.130 --> 00:00:23.130
It's an interesting lecture and sometimes even senior engineers do not really know how interpreters

6
00:00:23.130 --> 00:00:23.520
work.

7
00:00:25.480 --> 00:00:29.950
We know that in a compiler language machine code is first generated by the compiler.

8
00:00:31.080 --> 00:00:35.430
And the generated machine code is separately executed by the CPU.

9
00:00:36.420 --> 00:00:38.700
An interpreted language works differently.

10
00:00:39.920 --> 00:00:41.150
In an interpreted language.

11
00:00:41.150 --> 00:00:46.850
We have an interpreter, which is a program that directly executes the source code.

12
00:00:47.960 --> 00:00:53.420
That is, there is no separate compensation and execution step like in the case of a compiled language,

13
00:00:54.110 --> 00:00:55.200
as you can see here.

14
00:00:55.220 --> 00:01:02.060
Input to the interpreter is the source code and output is the result of execution of that source code.

15
00:01:02.980 --> 00:01:06.670
So you can see the similarity between an interpreter and a CPU.

16
00:01:07.120 --> 00:01:07.900
A CPU.

17
00:01:07.930 --> 00:01:13.330
Turns machine code into results while an interpreter turns source code into results.

18
00:01:14.050 --> 00:01:17.770
So machine code serves as the instruction set for the CPU.

19
00:01:18.280 --> 00:01:21.910
While source code serves as the instruction set for the interpreter.

20
00:01:22.700 --> 00:01:27.200
Just note that interpreter is also a program and it needs to be run.

21
00:01:27.800 --> 00:01:33.290
So CPU executes the interpreter and interpreter in turn executes the source code.

22
00:01:35.070 --> 00:01:39.960
So interpreter is nothing but a virtual machine that simulates a CPU.

23
00:01:41.460 --> 00:01:48.010
That is just the way a CPU executes machine language instructions using the fetch and execute cycle.

24
00:01:48.090 --> 00:01:54.360
An interpreter also executes instructions in the source code in a similar fetch and execute cycle.

25
00:01:55.990 --> 00:01:59.470
Let's now look at how a computer's fetch and execute cycle works.

26
00:01:59.950 --> 00:02:06.550
Fetch and execute cycle is the most fundamental operation of a computer and every programmer must know

27
00:02:06.550 --> 00:02:06.790
it.

28
00:02:07.450 --> 00:02:10.990
In case you're not familiar with it, this brief discussion should be helpful.

29
00:02:11.810 --> 00:02:17.150
Now here we have a CPU memory and a hard disk with a program to be executed.

30
00:02:19.060 --> 00:02:23.890
When the program is executed or started, the program first gets loaded into memory.

31
00:02:24.490 --> 00:02:30.460
And we know that a program is a machine code and is basically a sequence of instructions where each

32
00:02:30.460 --> 00:02:33.940
instruction is simply a sequence of zeros and ones.

33
00:02:35.470 --> 00:02:38.140
Next CPU search is an instruction from the memory.

34
00:02:38.980 --> 00:02:40.390
And it then executes it.

35
00:02:41.340 --> 00:02:46.140
And in the process, it may also fetch any data needed to execute the instruction.

36
00:02:47.760 --> 00:02:52.710
Any data generated by the execution of the instruction will be returned back to the memory.

37
00:02:53.430 --> 00:02:56.160
CPU then fetches the next instruction and executes it.

38
00:02:56.640 --> 00:03:01.560
So the cycle continues until all of the instructions in the program are executed.

39
00:03:02.130 --> 00:03:06.180
So that's basically the CPUs fetch and execute life cycle.

40
00:03:07.990 --> 00:03:09.790
Now let's look at interpreters.

41
00:03:09.790 --> 00:03:11.080
Such an execute cycle.

42
00:03:12.490 --> 00:03:16.570
Like a CPU interpreter also fetches its instructions from the memory.

43
00:03:17.050 --> 00:03:23.050
However, an interpreter case, the instruction is basically a statement in the source code.

44
00:03:24.630 --> 00:03:28.530
It then understands what is necessary to carry out that statement.

45
00:03:29.560 --> 00:03:32.350
And these two steps are also done by a compiler.

46
00:03:34.120 --> 00:03:37.180
Next step would be to execute the program statement.

47
00:03:37.570 --> 00:03:39.130
And here is the interesting thing.

48
00:03:39.760 --> 00:03:47.590
Interpreter maintains a library of compile machine code, and it just executes the appropriate compile

49
00:03:47.590 --> 00:03:50.410
machine code that corresponds to the program statement.

50
00:03:51.190 --> 00:03:54.400
So the interpreter is not generating machine code.

51
00:03:54.880 --> 00:04:01.120
It simply uses its own compile machine code to accomplish what the source code directs.

52
00:04:03.000 --> 00:04:05.010
Let's actually look at an example here.

53
00:04:05.010 --> 00:04:11.370
We have an ad statement in the source code and the interpreter executes the corresponding compile code

54
00:04:11.370 --> 00:04:17.010
from its library, which is the machine code version of this block of code that you see here.

55
00:04:17.940 --> 00:04:24.210
The code is fetching the two numbers to add from the memory and then is performing the actual addition

56
00:04:24.210 --> 00:04:27.060
and finally storing the output back in the memory.

57
00:04:27.900 --> 00:04:31.770
So once again, interpreter is not generating machine code.

58
00:04:32.070 --> 00:04:36.210
It just uses its library of pre compiled machine code.

59
00:04:37.900 --> 00:04:41.440
One main advantage of interpreter is platform independence.

60
00:04:42.100 --> 00:04:47.800
As you can see in this illustration, the same source code can be executed on any of the platforms.

61
00:04:48.310 --> 00:04:52.330
Only requirement is to install an interpreter specific to the platform.

62
00:04:53.180 --> 00:04:57.110
Recall that with the compiler language we could not achieve platform independence.

63
00:04:57.590 --> 00:05:03.590
That was because instead of source code, we were using machine code which was platform dependent.

64
00:05:04.220 --> 00:05:09.980
That is, the machine code includes attributes specific to the platform on which it was generated.

65
00:05:10.800 --> 00:05:16.410
So the target platform on which the machine code is to be executed could have different set of attributes,

66
00:05:16.950 --> 00:05:19.590
and thus the machine code would fail to execute.

67
00:05:20.010 --> 00:05:25.740
But with an interpreted language, we are executing source code which is identical regardless of the

68
00:05:25.740 --> 00:05:27.570
platform on which it is written.

69
00:05:27.810 --> 00:05:30.120
That is, it is platform independent.

70
00:05:30.970 --> 00:05:36.610
It is just that the interpreter on the Target platform ensures that the platform independent source

71
00:05:36.610 --> 00:05:39.400
code is executed without any issues.

72
00:05:41.070 --> 00:05:43.860
Now let's look at the pros and cons of an interpreter.

73
00:05:45.450 --> 00:05:50.190
One advantage of an interpreter include platform independence, as we have just seen.

74
00:05:51.500 --> 00:05:51.830
Next.

75
00:05:51.830 --> 00:05:53.240
There is no compensation step.

76
00:05:53.660 --> 00:05:54.470
There is a program.

77
00:05:54.470 --> 00:05:56.840
Execution can start immediately.

78
00:05:58.670 --> 00:06:04.940
I think one main advantage of not having a compilation step is that it would enable easier updates.

79
00:06:05.510 --> 00:06:12.290
For example, in some of my projects there were instances where I had to fix bugs in the JavaScript

80
00:06:12.290 --> 00:06:14.000
code on production servers.

81
00:06:14.510 --> 00:06:20.570
JavaScript is an interpreter language and so I could easily make the required code changes directly

82
00:06:20.570 --> 00:06:23.210
on production servers, which saved me a lot of time.

83
00:06:23.810 --> 00:06:29.570
Now, had it been a compile language, I would have to make the changes externally, compile the code

84
00:06:29.690 --> 00:06:35.270
and then deploy the compile code onto production servers, which would consume a lot of valuable time.

85
00:06:37.280 --> 00:06:43.520
Now in terms of limitations, interpretation is orders of magnitude slower than compile code.

86
00:06:44.350 --> 00:06:45.850
There are a couple of reasons for this.

87
00:06:46.890 --> 00:06:50.040
One is due to costly memory access operations.

88
00:06:51.650 --> 00:06:57.050
For example, this is the library code from the ADD Instruction example, which we saw earlier.

89
00:06:57.650 --> 00:07:03.200
As you can see, there are several costly memory access operations in a compiler language.

90
00:07:03.230 --> 00:07:10.310
It would have been taken care of in registers which could result in code that runs very fast, probably

91
00:07:10.310 --> 00:07:11.840
even 100 times faster.

92
00:07:13.710 --> 00:07:19.710
Second reason for slowness is program has to be reinterpreted every single time it is run.

93
00:07:21.280 --> 00:07:25.930
Another limitation is that interpreter is loaded into memory along with the source code.

94
00:07:26.290 --> 00:07:29.680
So you have an extra program that is getting loaded into the memory.

95
00:07:30.160 --> 00:07:33.520
I don't think it's a big deal, but it is just something we need to know.

96
00:07:34.090 --> 00:07:38.680
So as we can see though, interpreters solve the platform independence issue.

97
00:07:38.890 --> 00:07:42.520
They do have other limitations, like slow execution speed.

98
00:07:43.270 --> 00:07:49.180
We will see how Java takes care of the speed issue without compromising on platform independence.

99
00:07:49.330 --> 00:07:50.080
Thank you.

