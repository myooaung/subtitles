1
00:00:02,029 --> 00:00:03,080
Hi there.

2
00:00:03,110 --> 00:00:04,240
This is the LA Room.

3
00:00:04,280 --> 00:00:05,210
And welcome back.

4
00:00:05,420 --> 00:00:09,980
Let's not learn about the next type of operators called comparison operators.

5
00:00:10,610 --> 00:00:15,410
There are six comparison operators and they are very straightforward and they are also referred to as

6
00:00:15,410 --> 00:00:16,880
relational operators.

7
00:00:17,390 --> 00:00:23,570
And a comparison operator, as the name suggests, is used for comparing one operand with another option.

8
00:00:24,320 --> 00:00:28,070
Let's consider a student object and the student has an H.

9
00:00:28,100 --> 00:00:34,700
And let's say if we want to compare age with some value, let's say if we want to check if the H is

10
00:00:34,700 --> 00:00:41,000
greater than a value like 21 here, greater than is the comparison operator.

11
00:00:41,450 --> 00:00:43,790
And this is a comparison operation.

12
00:00:43,790 --> 00:00:50,990
So it is comparing H with 21 and it evaluates to either a true or a false.

13
00:00:51,440 --> 00:00:58,640
So a comparison operation basically evaluates to a boolean value, which means that a comparison operation

14
00:00:58,640 --> 00:01:06,620
represents a condition and such conditions are very useful and control flow statements like an F statement.

15
00:01:06,860 --> 00:01:12,890
In the previous section we looked at the F statement and an F statement checks for a condition, and

16
00:01:12,890 --> 00:01:16,310
if the condition is true, then it executes a block of code.

17
00:01:16,880 --> 00:01:22,340
And one of the subsequent lectures we will look at other control flow statements and we will also look

18
00:01:22,340 --> 00:01:24,110
at the F statement in detail.

19
00:01:24,970 --> 00:01:29,320
So let's go ahead and construct a simple statement here.

20
00:01:29,560 --> 00:01:34,420
So let's say F age is greater than 21.

21
00:01:34,810 --> 00:01:36,700
Then we want to print some value.

22
00:01:36,700 --> 00:01:38,590
So let's say H is.

23
00:01:40,440 --> 00:01:41,610
25.

24
00:01:43,030 --> 00:01:47,220
So if age is 21, then we want to print some value.

25
00:01:47,230 --> 00:01:48,610
Let's say we want to print.

26
00:01:50,100 --> 00:01:52,460
A text called graduate student.

27
00:01:52,470 --> 00:01:56,510
So if age is greater than 21, it means it's a graduate student.

28
00:01:56,520 --> 00:01:59,130
Otherwise it is an undergraduate student.

29
00:01:59,850 --> 00:02:02,700
So let's just assume so here.

30
00:02:02,700 --> 00:02:07,530
This method is called as comparison operators, and it is the basic stream of class and we are just

31
00:02:07,530 --> 00:02:09,500
invoking it from the main method here.

32
00:02:09,509 --> 00:02:13,590
So let me just go ahead and compile and execute that.

33
00:02:16,810 --> 00:02:17,240
That's it.

34
00:02:17,260 --> 00:02:22,960
So it prints a graduate student because age is 25 and it is greater than 21.

35
00:02:23,440 --> 00:02:29,530
So this is one of the reasons it is called as relational operator because you're kind of checking a

36
00:02:29,530 --> 00:02:32,470
relation between age and this particular letter.

37
00:02:32,920 --> 00:02:35,260
Now, let's go ahead and look at other operators.

38
00:02:35,380 --> 00:02:38,560
And for that, let me just use some print statements.

39
00:02:38,560 --> 00:02:43,390
It would be more easier to look at those different operators.

40
00:02:43,390 --> 00:02:44,710
So here they are.

41
00:02:44,740 --> 00:02:46,900
So let me copy them.

42
00:02:50,030 --> 00:02:50,930
Here they are.

43
00:02:50,960 --> 00:02:52,910
So H Field is still there.

44
00:02:52,910 --> 00:02:58,010
And in the first statement we are printing F ages greater than 21.

45
00:02:58,730 --> 00:03:00,410
So we are not using an F statement.

46
00:03:00,410 --> 00:03:07,550
But here also we are going to evaluate this expression because we are we are using this parentheses

47
00:03:07,550 --> 00:03:12,290
and these parentheses will allow us to evaluate this particular condition.

48
00:03:13,190 --> 00:03:19,580
So here we have all of the different comparison operators in the first statement we have greater than

49
00:03:19,580 --> 00:03:23,900
and in the second statement we are checking f age is greater than or equal to 21.

50
00:03:23,900 --> 00:03:29,150
So we are just printing this expression here in the text so that we can see it in the output.

51
00:03:29,630 --> 00:03:34,490
And the next one is age is less than 21, age is less than or equal to 21.

52
00:03:34,490 --> 00:03:38,090
And here this is called as equal to operation.

53
00:03:38,210 --> 00:03:40,700
And we are checking if age is equal to 21.

54
00:03:40,700 --> 00:03:44,420
And in this case, we are checking if age is not equal to 21.

55
00:03:44,420 --> 00:03:51,590
So it is an exclamation mark followed by equal to and both of these here, the last ones are referred

56
00:03:51,590 --> 00:03:53,750
to as equality operators.

57
00:03:54,260 --> 00:04:00,590
And this is equal to and this is not equal to equal to sometimes is also referred to as equivalent operator

58
00:04:00,590 --> 00:04:05,030
and not equal to is sometimes referred to as not equivalent operator.

59
00:04:05,780 --> 00:04:09,200
So here we are going to check if age is greater than 21.

60
00:04:09,860 --> 00:04:13,160
Since age is 25, it is obviously greater than 21.

61
00:04:13,430 --> 00:04:19,899
And this expression will evaluate to true and and that will be printed in the output.

62
00:04:20,839 --> 00:04:26,840
So if you enclose this and a parentheses like this, then it would get evaluated.

63
00:04:26,840 --> 00:04:31,130
So we don't really have to have an F condition if statement like this.

64
00:04:31,460 --> 00:04:37,670
So in this case, in the second case, age is 25 and it is greater than or equal to 21.

65
00:04:37,670 --> 00:04:39,380
So that that is also true.

66
00:04:39,380 --> 00:04:44,030
So it will print a true third condition will be false because age is less than 21.

67
00:04:44,120 --> 00:04:47,600
So let me just go ahead and compile and print this.

68
00:04:52,160 --> 00:04:52,990
Here it is.

69
00:04:53,870 --> 00:04:55,220
So it's just the same thing.

70
00:04:55,220 --> 00:04:59,030
So age is 25 and when it is greater than 21, it prints true.

71
00:04:59,060 --> 00:05:02,540
In the second statement it is greater than or equal to 21.

72
00:05:02,540 --> 00:05:03,620
So it prints true.

73
00:05:04,070 --> 00:05:08,090
Third, it is false because age is not less than 21.

74
00:05:08,090 --> 00:05:11,660
Here we are checking if age is less than 21 and that's not true.

75
00:05:11,660 --> 00:05:13,400
So it prints false even.

76
00:05:13,400 --> 00:05:20,990
This also is false because it is not less than or equal to 21 and age is equal to 21 is also false because

77
00:05:20,990 --> 00:05:27,020
age is 25, but here age is 25 and it is not equal to 21 and hence this printing.

78
00:05:27,020 --> 00:05:27,470
True.

79
00:05:28,570 --> 00:05:30,520
Now let's change this to 21.

80
00:05:31,740 --> 00:05:33,780
So it's just easy comparisons.

81
00:05:39,680 --> 00:05:40,170
Here it is.

82
00:05:40,190 --> 00:05:46,760
Age is 21, so age greater than 21 would be false because 21 is greater than 21 is false.

83
00:05:47,240 --> 00:05:53,930
But this one is true because here age is 21 and it is greater than or equal to 21.

84
00:05:53,930 --> 00:05:56,420
So the equal to part is true.

85
00:05:56,420 --> 00:05:58,700
And because of that it evaluates to true.

86
00:05:59,180 --> 00:06:00,620
Age is less than 21 is false.

87
00:06:00,620 --> 00:06:08,030
Age is less than or equal to 21 is once again true because we have equal to here an age equal to 21

88
00:06:08,030 --> 00:06:08,570
is true.

89
00:06:08,600 --> 00:06:12,420
Age not equal to 21 is false, right?

90
00:06:12,470 --> 00:06:16,580
21 is not equal to 21 is false because they are equal.

91
00:06:17,060 --> 00:06:20,840
So let's just make it 20 and very straightforward.

92
00:06:20,840 --> 00:06:22,250
But I still want to.

93
00:06:23,480 --> 00:06:25,010
Run through that example to.

94
00:06:26,300 --> 00:06:27,790
So age is 20.

95
00:06:27,800 --> 00:06:29,840
So 20 greater than 21 is false.

96
00:06:29,840 --> 00:06:32,140
20 greater than or equal to 21 is false.

97
00:06:32,150 --> 00:06:33,690
20 less than 21 is true.

98
00:06:33,710 --> 00:06:35,180
20 less than or equal to.

99
00:06:35,180 --> 00:06:36,230
21 is true.

100
00:06:36,260 --> 00:06:40,700
20 equals to 21 is false and 20 not equal to 21 as true.

101
00:06:41,270 --> 00:06:42,210
So that's it.

102
00:06:42,230 --> 00:06:44,810
So those are the different operators.

103
00:06:45,920 --> 00:06:53,180
Now here the first four operators are applicable to only primitive numeric types.

104
00:06:53,540 --> 00:06:57,890
So primitive numeric types would be all primitive types except boolean.

105
00:06:58,310 --> 00:07:04,550
Now you may also recall that in arithmetic operations also all of the arithmetic operators are applicable

106
00:07:04,550 --> 00:07:09,680
to only primitive numeric types and so they are not applicable to two boolean operations.

107
00:07:09,680 --> 00:07:13,370
So the same goes with the first four operators.

108
00:07:13,490 --> 00:07:19,220
However, the last two operators, the equality operators, would apply for all of the primitive types.

109
00:07:20,090 --> 00:07:26,870
So for example, if let's consider that this variable is boolean and Boolean less than or equal to something

110
00:07:26,870 --> 00:07:29,510
like true or false just doesn't make sense.

111
00:07:29,600 --> 00:07:29,870
Right?

112
00:07:30,080 --> 00:07:36,770
But if boolean is equal to true or if it is not equal to true is something that is meaningful and it

113
00:07:36,770 --> 00:07:37,460
is valid.

114
00:07:38,060 --> 00:07:40,680
Let's actually go ahead and also test this.

115
00:07:40,700 --> 00:07:46,490
Let's say we have a variable called Ease International, whether the student is international or not.

116
00:07:47,640 --> 00:07:51,720
So let's say it is true and let's check this.

117
00:07:52,770 --> 00:07:54,300
So I have three more statements here.

118
00:07:54,300 --> 00:07:55,380
Let me just copy them.

119
00:07:59,270 --> 00:08:05,030
So we just have these final three statements less than or equal to, equal to or not equal to over here.

120
00:08:05,330 --> 00:08:10,400
So we are just checking f is international is less than equal to true or is equal to true or not equal

121
00:08:10,400 --> 00:08:10,970
to true.

122
00:08:11,150 --> 00:08:11,960
Straightforward.

123
00:08:12,260 --> 00:08:13,130
So.

124
00:08:15,470 --> 00:08:19,610
So it gives a compilation error because the first one is invalid.

125
00:08:19,760 --> 00:08:23,720
We are checking if it is international is less than or equal to true.

126
00:08:24,110 --> 00:08:32,480
So it says bad operand types for binary operator less than or equal to because boolean cannot be used

127
00:08:32,480 --> 00:08:36,740
with this particular operator and hence it says that it is a bad operand type.

128
00:08:37,010 --> 00:08:44,450
So we cannot use a boolean here for this comparison operator, but it works with equal to or not equal

129
00:08:44,450 --> 00:08:44,810
to.

130
00:08:44,840 --> 00:08:47,750
So let me just recompile and execute.

131
00:08:50,580 --> 00:08:50,850
Okay.

132
00:08:50,910 --> 00:08:51,450
Here it is.

133
00:08:51,450 --> 00:08:52,950
So it says for ease.

134
00:08:52,950 --> 00:08:54,240
International was true.

135
00:08:54,540 --> 00:08:54,840
True.

136
00:08:54,840 --> 00:08:57,450
Equal to true will return a true and true.

137
00:08:57,450 --> 00:09:01,440
Not equal to true is a false right true.

138
00:09:01,440 --> 00:09:02,600
Equal to true is true.

139
00:09:02,610 --> 00:09:08,400
So if both of them are true and we have the symbol not equal to it would be a false.

140
00:09:08,790 --> 00:09:10,350
So that's that.

141
00:09:11,360 --> 00:09:18,080
So equal equality here, equality operators, which are both of these, they are applicable to all of

142
00:09:18,080 --> 00:09:19,130
the parameters.

143
00:09:19,340 --> 00:09:24,120
Now these equality operators are also applicable to object references.

144
00:09:24,620 --> 00:09:29,640
So if you recall, we created this student class in the previous section, the student class.

145
00:09:29,660 --> 00:09:32,120
So let's create two objects here.

146
00:09:32,330 --> 00:09:33,680
Let's say student.

147
00:09:34,420 --> 00:09:35,200
S one.

148
00:09:37,140 --> 00:09:37,800
Student.

149
00:09:38,700 --> 00:09:41,730
And it takes two parameters to the constructor.

150
00:09:42,150 --> 00:09:46,560
One is thousand, which is the ID and the other one is the name of the student.

151
00:09:46,560 --> 00:09:48,030
So let's just pass my name.

152
00:09:48,180 --> 00:09:48,520
Row.

153
00:09:50,870 --> 00:09:57,680
And let's create another object as to and it is also referencing a new student object, but it has the

154
00:09:57,680 --> 00:09:58,430
same state.

155
00:09:58,700 --> 00:10:02,930
So we are passing the same values, but they are still two different objects.

156
00:10:02,930 --> 00:10:03,530
Right?

157
00:10:04,680 --> 00:10:05,670
So let me.

158
00:10:07,180 --> 00:10:10,030
Print these two statements.

159
00:10:14,300 --> 00:10:19,230
So we are just checking if one is equal to S2 or S1 is not equal to S2.

160
00:10:19,250 --> 00:10:26,200
So S1 is equal to S2 would be false because both of these are referencing two different objects.

161
00:10:26,210 --> 00:10:30,560
Even though the state is same, they are still two different objects in the memory and they have separate

162
00:10:30,560 --> 00:10:35,210
memory addresses and S1 is S1 is pointing to one of the objects.

163
00:10:35,210 --> 00:10:39,770
So it holds the memory address of this object as two holds the memory address of this object.

164
00:10:40,040 --> 00:10:41,870
And so those memory addresses are different.

165
00:10:42,050 --> 00:10:43,730
So let's just compile.

166
00:10:48,840 --> 00:10:50,970
As you can see for us, one is equal to se two.

167
00:10:51,000 --> 00:10:55,290
It returns a false and for us one not equal to SE two, it returns true.

168
00:10:55,860 --> 00:10:59,760
So this is also called US identity comparison.

169
00:11:00,300 --> 00:11:06,300
Doing such kind of a comparison is also called US Identity comparison and it is also done very commonly

170
00:11:06,300 --> 00:11:07,840
in many of the Java classes.

171
00:11:07,860 --> 00:11:13,470
For instance, there is this class called Less Object, which we will see later when dealing with inheritance

172
00:11:13,470 --> 00:11:15,180
and other object oriented concepts.

173
00:11:15,180 --> 00:11:21,720
And it has a method called equals, and the method compares the input object with the current object.

174
00:11:21,720 --> 00:11:26,730
The current object is referenced by this, and for that it is using this equal to operation.

175
00:11:27,660 --> 00:11:30,000
So that's one example from the Java Library.

176
00:11:30,030 --> 00:11:32,190
Now let's go back.

177
00:11:32,490 --> 00:11:33,980
And so that's one thing.

178
00:11:33,990 --> 00:11:40,590
And equality, such equality operators are also very useful for doing something called as null checks.

179
00:11:40,590 --> 00:11:42,030
So that's one example.

180
00:11:42,060 --> 00:11:44,430
So let's just write a simple method here.

181
00:11:44,430 --> 00:11:51,690
Let's say let's call it this update and let's pass, let's just pass null to that method and let's also

182
00:11:51,690 --> 00:11:53,340
pass some value.

183
00:11:53,730 --> 00:11:54,630
Let's say, John.

184
00:11:55,830 --> 00:11:57,750
The example should be clear in a bed.

185
00:11:58,170 --> 00:11:58,950
So.

186
00:11:59,770 --> 00:12:00,370
Here.

187
00:12:02,860 --> 00:12:07,420
It said the first method parameter is student say as.

188
00:12:08,440 --> 00:12:11,170
And the second one is actually name string.

189
00:12:13,700 --> 00:12:19,520
And we just want to update the name of the student that is passed to this method, but we are still

190
00:12:19,520 --> 00:12:20,450
passing now.

191
00:12:20,810 --> 00:12:26,570
So the student object class has this variable called name and we are just updating it.

192
00:12:26,570 --> 00:12:31,910
So we'll just say start name equals to name the new name that is passed here.

193
00:12:33,250 --> 00:12:33,630
That's it.

194
00:12:33,700 --> 00:12:36,760
And we return a true.

195
00:12:37,180 --> 00:12:38,710
So this is the thing.

196
00:12:38,860 --> 00:12:41,080
But this will give us another pointer.

197
00:12:41,080 --> 00:12:42,670
Exception memory compile.

198
00:12:45,660 --> 00:12:48,000
So it gives an error called null pointer.

199
00:12:48,000 --> 00:12:51,650
Exception and exceptions will be dealt later.

200
00:12:51,660 --> 00:12:58,440
But the reason it is giving is this because as is null and if we invoke anything on null, we get another

201
00:12:58,440 --> 00:12:59,340
pointer exception.

202
00:12:59,340 --> 00:13:01,500
And we have discussed it earlier too.

203
00:13:01,860 --> 00:13:05,220
So the method should not be passed null.

204
00:13:05,220 --> 00:13:07,320
So that is the that is the thing.

205
00:13:07,320 --> 00:13:11,790
But sometimes, sometimes it may still be invoked with null.

206
00:13:11,790 --> 00:13:13,830
Some developers might pass null.

207
00:13:14,400 --> 00:13:20,100
So we need to take certain safety measures so we will say as equal to null.

208
00:13:21,610 --> 00:13:23,740
In this case, we return a false.

209
00:13:27,280 --> 00:13:29,920
So for SS not then we return a false.

210
00:13:30,160 --> 00:13:31,960
So in this case.

211
00:13:36,650 --> 00:13:37,000
See.

212
00:13:37,010 --> 00:13:41,570
So the method has executed, has been invoked, and it executed successfully.

213
00:13:41,840 --> 00:13:48,080
And if you pass as one, for example, as one, then as one's name will be updated.

214
00:13:49,220 --> 00:13:51,760
Although there is nothing being printed and the method.

215
00:13:51,770 --> 00:13:53,150
But still it would.

216
00:13:54,400 --> 00:13:58,630
These last two statements will get executed because as will not be equal to none.

217
00:13:58,930 --> 00:14:02,950
So this such kind of a check is called as parameter validation.

218
00:14:03,190 --> 00:14:11,080
Sometimes methods do this because the invoke might pass a value such as null, which shouldn't be passed.

219
00:14:11,110 --> 00:14:16,000
So in order to safeguard against that, they would do such kind of parameter validation.

220
00:14:16,000 --> 00:14:20,660
And if it is not equal to null only then the rest of the method will be executed.

221
00:14:20,680 --> 00:14:26,740
So this is one of the use cases and we will also look at one more use case and when learning about logical

222
00:14:26,740 --> 00:14:28,750
operators in a subsequent lecture.

223
00:14:29,080 --> 00:14:30,880
So it is also useful.

224
00:14:30,910 --> 00:14:32,590
NULL checks are also useful.

225
00:14:32,590 --> 00:14:37,960
The equality and not equality operators are useful for performing null checks and they are very useful

226
00:14:37,960 --> 00:14:38,500
for that.

227
00:14:38,980 --> 00:14:39,960
So that's about it.

228
00:14:39,970 --> 00:14:42,340
That's about the comparison operators.

229
00:14:42,370 --> 00:14:44,710
Thank you and see you in the next lecture.

