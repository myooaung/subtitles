WEBVTT
1
00:00:02.070 --> 00:00:02.880
Hello there.

2
00:00:02.910 --> 00:00:03.969
This is the Uluru.

3
00:00:04.019 --> 00:00:04.950
And welcome back.

4
00:00:05.160 --> 00:00:12.300
Now let's look at how integer variables can be represented in other less frequently used formats.

5
00:00:12.870 --> 00:00:17.100
So this is something that we have seen in the last lecture and this is how it is commonly used.

6
00:00:17.460 --> 00:00:21.780
So here the Integer Literals, there there were two types of integer literals.

7
00:00:21.780 --> 00:00:24.750
One is integral and the other one is long, literal.

8
00:00:24.870 --> 00:00:31.170
So this is an integer, whereas this one is the long literal, which is ending with a trailing L.

9
00:00:31.470 --> 00:00:37.770
And we also said that individuals can be assigned to variables of all four data types, like in byte,

10
00:00:37.770 --> 00:00:38.590
short and long.

11
00:00:38.610 --> 00:00:43.230
Whereas the long return can only be assigned to a variable of type long.

12
00:00:43.560 --> 00:00:44.010
Right?

13
00:00:44.370 --> 00:00:46.170
So this is what we will see.

14
00:00:46.170 --> 00:00:49.470
Mostly the sort of decimal format.

15
00:00:49.560 --> 00:00:56.220
But these integer literals, like I said earlier, can also be represented in other less frequently

16
00:00:56.220 --> 00:00:57.150
used formats.

17
00:00:57.150 --> 00:01:01.290
And we have seen one example here, one of them is hexadecimal.

18
00:01:01.620 --> 00:01:07.950
And we looked at this integer class where the max and min value were initialized in this format.

19
00:01:07.980 --> 00:01:11.850
These are also intellectuals, but in hexadecimal formats.

20
00:01:12.090 --> 00:01:17.790
So this is a hexadecimal, but we also have binary and also octal.

21
00:01:17.820 --> 00:01:21.990
Octal is perhaps very rarely used and so is not important.

22
00:01:21.990 --> 00:01:27.200
But these other formats also improve code readability in certain contexts.

23
00:01:27.210 --> 00:01:31.790
For instance, here we are representing some very small number and very large number.

24
00:01:31.800 --> 00:01:38.460
So instead of having that number itself, we can represent n the hexadecimal format in this way.

25
00:01:38.670 --> 00:01:41.030
So it improves with code readability.

26
00:01:41.040 --> 00:01:44.100
But like I said, they are very less commonly used.

27
00:01:44.340 --> 00:01:50.400
But in your professional life, if you happen to work on projects where you need to use such kind of

28
00:01:50.400 --> 00:01:52.890
formats, then you know how to use them.

29
00:01:53.040 --> 00:01:57.720
I personally did not have a chance to use them in my professional career.

30
00:01:58.410 --> 00:02:04.770
So let's go ahead and quickly look at these different formats like the binary and the hexadecimal.

31
00:02:05.010 --> 00:02:08.699
So we already have the student class here, but let's not use this.

32
00:02:08.699 --> 00:02:13.530
Let's go back to the other class, the basics demo class, which we have written earlier.

33
00:02:13.680 --> 00:02:18.590
And here let's introduce a new method called primitives.

34
00:02:18.590 --> 00:02:24.000
So let me comment this old print where we were invoking the print method, let's call it as primitives.

35
00:02:25.050 --> 00:02:30.270
Let's write a new method here called primitives because we are dealing with primitives.

36
00:02:31.850 --> 00:02:34.970
And we are calling this primitive method from the main method.

37
00:02:35.120 --> 00:02:36.500
And that's also how.

38
00:02:37.640 --> 00:02:38.870
A print statement.

39
00:02:40.710 --> 00:02:43.900
And let's say inside primitives.

40
00:02:44.580 --> 00:02:45.100
Okay.

41
00:02:45.480 --> 00:02:51.960
Now, one thing that you may have observed here is in student class, we are creating an object of student

42
00:02:51.960 --> 00:02:54.150
and then we are invoking the compute method.

43
00:02:54.450 --> 00:02:59.940
But here we are not creating an object of basic demo we are directly invoking.

44
00:02:59.940 --> 00:03:05.340
That's because this is a type of method called a static method, whereas here it's called as an instance

45
00:03:05.340 --> 00:03:05.910
method.

46
00:03:05.920 --> 00:03:09.420
So those are different types of methods and we will discuss them later.

47
00:03:09.420 --> 00:03:13.560
In fact, we have to still discuss methods itself in a formal way.

48
00:03:13.890 --> 00:03:20.610
So just in case, if you have noticed why basic demo object was not created, that's only because we

49
00:03:20.610 --> 00:03:26.430
are using static methods here, and static methods can be directly invoked from the main method, which

50
00:03:26.430 --> 00:03:29.670
is also a static method, but just don't worry about that for now.

51
00:03:29.910 --> 00:03:36.570
So we are invoking the primitives method here and let's introduce our first variable, let's call it

52
00:03:36.570 --> 00:03:44.220
as int hex and let's initialize it with the number zero zero 41.

53
00:03:44.220 --> 00:03:50.640
So hexadecimal format starts with zero and X and X can be in uppercase also.

54
00:03:50.940 --> 00:03:58.230
So that's the hexadecimal format and this is the hexadecimal number itself, zero zero for one here.

55
00:03:59.100 --> 00:04:01.740
So zero x indicates hexadecimal number.

56
00:04:02.040 --> 00:04:07.350
And if you are not aware of hexadecimal system, then you can read about it later.

57
00:04:07.350 --> 00:04:13.080
But just note that it includes the numbers 0 to 9 and A to F in case you are not aware of it.

58
00:04:13.350 --> 00:04:22.019
And here the variable int hex will be assigned 65 as this hexadecimal number 41 maps to the decimal

59
00:04:22.019 --> 00:04:25.680
65 and you can read about that, how that happens.

60
00:04:25.680 --> 00:04:30.750
But essentially the base here in hexadecimal system is 60 is 16.

61
00:04:31.020 --> 00:04:35.400
So this is the zero position here and the value is one.

62
00:04:35.640 --> 00:04:42.360
So for zero position it will be I'll just quickly show you so that you it will you at least have an

63
00:04:42.360 --> 00:04:42.840
idea.

64
00:04:42.840 --> 00:04:49.890
So it will be 16 power zero because it's a08 position and because we have a one in that position, you

65
00:04:49.890 --> 00:04:56.580
multiply with one, then you will say Plus, then the next position is 16 power one.

66
00:04:58.680 --> 00:05:09.210
And you will multiply with 416 power zero as one and one into one is one and here 16 power one is 16

67
00:05:09.210 --> 00:05:10.940
and times four is 64.

68
00:05:10.950 --> 00:05:15.590
So 64 plus one is 65 and that's what gets printed.

69
00:05:15.600 --> 00:05:17.010
So let's print it.

70
00:05:24.320 --> 00:05:25.100
Index.

71
00:05:25.100 --> 00:05:27.350
So let's compile.

72
00:05:33.600 --> 00:05:33.720
Okay.

73
00:05:33.840 --> 00:05:36.420
So it prints 65 because this maps to 65.

74
00:05:37.080 --> 00:05:44.130
So such hexadecimal formats is very useful and representing very large or very small numbers.

75
00:05:44.460 --> 00:05:48.710
And it is also very useful in performing something called bitwise operations.

76
00:05:48.720 --> 00:05:51.020
And we will also look at bitwise operations later.

77
00:05:51.030 --> 00:05:52.430
So let's not worry about it.

78
00:05:52.440 --> 00:05:59.130
But sometimes in such bitwise operations, it may be even better if we can use binary numbers directly

79
00:05:59.130 --> 00:06:04.830
instead of hexadecimal numbers, and you can also use decimal numbers in bitwise operations, but in

80
00:06:04.830 --> 00:06:10.690
certain low level programming, you might want to use binary numbers instead of hexadecimal.

81
00:06:10.710 --> 00:06:13.620
And using binary numbers is only possible.

82
00:06:13.620 --> 00:06:17.110
Binary letters is only possible from Java seven onwards.

83
00:06:17.130 --> 00:06:19.040
It was not possible before that.

84
00:06:19.050 --> 00:06:23.490
So let's also use the next format, which is the binary format.

85
00:06:23.610 --> 00:06:27.420
So it is only possible from Java seven.

86
00:06:28.540 --> 00:06:33.070
So let me have this and let's call it ain't binary.

87
00:06:33.280 --> 00:06:36.430
So this sort of a naming convention is not good.

88
00:06:36.460 --> 00:06:38.560
We will look at naming conventions later on.

89
00:06:38.590 --> 00:06:44.800
It needs to be much more meaningful, like in this case, like the these kinds of naming conventions

90
00:06:44.800 --> 00:06:45.970
is what you need to use.

91
00:06:46.330 --> 00:06:50.740
But later, we will look at naming conventions for variables and classes and methods, and it will be

92
00:06:50.740 --> 00:06:51.250
clear.

93
00:06:51.760 --> 00:07:01.660
So the binary format starts with zero and B and the number let's use 0100 and 0001.

94
00:07:01.870 --> 00:07:05.650
So that's the binary number with eight digits here.

95
00:07:06.700 --> 00:07:09.670
So this also translates to 65.

96
00:07:09.790 --> 00:07:12.860
So if you compute it, it will translate to 65.

97
00:07:12.880 --> 00:07:19.000
It's just that here, since binary is based two, you would just replace with two here and you would

98
00:07:19.000 --> 00:07:19.810
get the number.

99
00:07:20.610 --> 00:07:25.560
So if you are from non computer science background and do not know how this binary number translates

100
00:07:25.560 --> 00:07:32.550
to 65 then or if you have never heard of signed tools complement scheme, then you can check out the

101
00:07:32.550 --> 00:07:37.680
link I mentioned in the previous lecture, which is included in the resources section of that particular

102
00:07:37.680 --> 00:07:40.500
lecture, and it is all very nicely explained there.

103
00:07:40.650 --> 00:07:47.220
So in this case it will be one times two power zero, which will be one, and this will be zero times

104
00:07:47.220 --> 00:07:49.800
two, power one zero times to power two.

105
00:07:49.920 --> 00:07:55.350
So all of that will be zero, but this will be one times two power six, which is 64.

106
00:07:55.350 --> 00:07:59.940
And that 64 is added to this one, which is one times two power zero.

107
00:08:00.150 --> 00:08:03.830
So that's how you compute the value.

108
00:08:03.840 --> 00:08:07.200
So it will also translate to 65.

109
00:08:16.580 --> 00:08:17.810
So let me recompile.

110
00:08:19.310 --> 00:08:21.200
Execute it so you can see 65.

111
00:08:22.020 --> 00:08:28.650
And you can also have underscores, which was also introduced in Java seven and we looked at underscore

112
00:08:28.680 --> 00:08:31.050
here with phone value.

113
00:08:31.080 --> 00:08:36.450
So similarly, even in these formats, you can use an underscore and it will show the same value.

114
00:08:37.110 --> 00:08:43.320
And these can also be used with long literals to and with long.

115
00:08:43.350 --> 00:08:46.920
We know that it's got to be by a sorry long.

116
00:08:48.140 --> 00:08:49.530
Only then it would compile.

117
00:08:49.550 --> 00:08:51.740
So let's compile and execute this.

118
00:08:53.410 --> 00:08:54.310
Recompile.

119
00:08:56.720 --> 00:08:57.710
And here it is.

120
00:08:57.710 --> 00:08:59.000
So it prints 65.

121
00:08:59.000 --> 00:09:07.070
But this one is a long and here we used this underscore but it still prints 65 so that's just for the

122
00:09:07.070 --> 00:09:08.270
readability sake.

123
00:09:08.390 --> 00:09:16.220
So especially if you have a 32 bit number or a 64 bit binary number, you might want to separate them

124
00:09:16.220 --> 00:09:22.700
after every eight digits for readability and octal is not important at all because it's very rarely

125
00:09:22.700 --> 00:09:22.940
used.

126
00:09:22.940 --> 00:09:27.350
But let me just show you how octal is, just for the sake of completeness.

127
00:09:30.120 --> 00:09:37.770
Let's call it octal here and octal starts with zero and is followed by digits.

128
00:09:37.770 --> 00:09:40.380
So there is no X or B here.

129
00:09:40.650 --> 00:09:43.890
And also keep in mind that this X and B can be in uppercase.

130
00:09:44.460 --> 00:09:50.280
So for octal it starts with zero and there is nothing like character here a letter.

131
00:09:50.280 --> 00:09:52.530
So it just follows with more digits.

132
00:09:52.830 --> 00:09:55.110
So let's have 101.

133
00:09:55.110 --> 00:09:56.570
So this is based eight.

134
00:09:56.580 --> 00:09:59.970
So you would also translate in the same way as here.

135
00:10:00.060 --> 00:10:02.640
It's just that instead of 16, you would use eight.

136
00:10:09.130 --> 00:10:09.810
Here it is.

137
00:10:09.810 --> 00:10:11.460
So it also prints 65.

138
00:10:12.510 --> 00:10:13.250
So that's it.

139
00:10:13.260 --> 00:10:19.770
So these are other less commonly used formats and it's good that you also know about this.

140
00:10:20.010 --> 00:10:23.940
And just keep in mind that the underscore has to be in between the number.

141
00:10:24.300 --> 00:10:27.870
Like I mentioned in the previous lecture, it cannot be at the beginning or at the end.

142
00:10:28.200 --> 00:10:29.070
So that's about it.

143
00:10:29.100 --> 00:10:32.280
Thank you and see you in the next lecture and happy coding.

