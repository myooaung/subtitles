WEBVTT
1
00:00:00.980 --> 00:00:03.660
Heider knowledge just continue on.

2
00:00:03.670 --> 00:00:09.270
Arrest them all in the last name or look that sequence of operations which are the code operations on

3
00:00:09.270 --> 00:00:12.820
which would be used which would be using most frequently.

4
00:00:12.880 --> 00:00:15.530
Now let's look at the pattern operations.

5
00:00:15.540 --> 00:00:20.250
We said that there are some parlays operations which have been introduced in July 8.

6
00:00:20.310 --> 00:00:24.920
So let's go ahead and look at them and we're just going to look at three of them attached.

7
00:00:25.170 --> 00:00:30.540
So these are Barlows operations which means that if there is a multi If your system has multiple cost

8
00:00:31.080 --> 00:00:36.070
then these methods can use make use of those multiple course in order to you parallelism.

9
00:00:36.180 --> 00:00:43.010
And also a Jew efficiency would be more much more efficient because things are done and batla OK.

10
00:00:43.200 --> 00:00:47.000
So there are three matters that we're are going to look at what is palace saw on his panel prefix.

11
00:00:47.010 --> 00:00:48.770
Another one is Bartlet's set.

12
00:00:49.380 --> 00:00:51.790
So popular sought is just like the song.

13
00:00:52.050 --> 00:00:57.600
The output would be just a song sort operation we have seen in the last lesson Sirtis and and put out

14
00:00:57.600 --> 00:00:59.240
a undercharge elements.

15
00:00:59.450 --> 00:01:00.570
OK so the input arrays.

16
00:01:00.570 --> 00:01:03.210
Once again the same elements going to be three for them.

17
00:01:03.290 --> 00:01:11.490
Right now the specification says that this would be beneficial only if for large art is OK for large

18
00:01:11.550 --> 00:01:13.090
arrays we're missing large areas.

19
00:01:13.110 --> 00:01:16.940
It has to have at least eight thousand one hundred or nine elements.

20
00:01:17.040 --> 00:01:18.390
That is one love shift.

21
00:01:19.590 --> 00:01:26.760
So if that's the minimum size only then it will use closed operations otherwise internally if it is

22
00:01:26.760 --> 00:01:31.600
less than this size it would only use the same old sequential sock method.

23
00:01:31.810 --> 00:01:34.200
OK so let me just go ahead and run this.

24
00:01:34.200 --> 00:01:40.820
Let me just comment this sequential part.

25
00:01:41.220 --> 00:01:44.200
So in this case it would still use the oil soaked method.

26
00:01:44.590 --> 00:01:45.010
OK.

27
00:01:45.060 --> 00:01:50.260
So if it has more than this then you can make use of a bottle of soft and liquid be faster.

28
00:01:50.340 --> 00:01:54.930
I think roughly it is around four times faster just based on some article that I read.

29
00:01:55.230 --> 00:01:58.290
So I did not do any performance tests on this bench months.

30
00:01:58.470 --> 00:01:59.800
So that's about the I.

31
00:02:00.180 --> 00:02:01.860
The parallel sorting.

32
00:02:02.490 --> 00:02:02.720
OK.

33
00:02:02.730 --> 00:02:06.880
Next Next look at parler prefix on batla prefix.

34
00:02:06.890 --> 00:02:11.100
Basically it would communards that each element of w an array.

35
00:02:11.310 --> 00:02:16.890
So which means that if you have elements like this to 1 0 3 then the returned array.

36
00:02:17.010 --> 00:02:19.900
Well how elements like you.

37
00:02:20.130 --> 00:02:23.720
And the second would be accumulation of first and the second element.

38
00:02:23.720 --> 00:02:25.330
So it would be three.

39
00:02:25.410 --> 00:02:29.180
And the third element would be the sum of the sum three.

40
00:02:29.280 --> 00:02:31.420
And the third element which is zero.

41
00:02:31.680 --> 00:02:36.060
So it would be accumulator of the element values.

42
00:02:36.070 --> 00:02:43.510
So to me just run this as you can see it is foretold 706 initially is four than four and 23 are harder

43
00:02:43.560 --> 00:02:46.640
to get 27 and so on and 59.

44
00:02:46.690 --> 00:02:52.930
And in order to get the final value which is 86 yes that's Parnell it's OK.

45
00:02:53.040 --> 00:02:54.220
Now this mattered.

46
00:02:54.360 --> 00:02:55.630
It takes two parameters.

47
00:02:55.650 --> 00:03:03.540
One is an injury and the other one the corner does and the binary operator and binary operator is an

48
00:03:03.720 --> 00:03:07.830
interface and they call that as a function interface function interfaces.

49
00:03:07.830 --> 00:03:09.100
How just one method.

50
00:03:09.330 --> 00:03:16.950
And so we can pass an implementation on that implementation could be lambda function or it can be matter

51
00:03:16.950 --> 00:03:21.540
or France or it can be an anonymous function or it can be an implementation such as this which we are

52
00:03:21.540 --> 00:03:22.700
going to show you her.

53
00:03:22.710 --> 00:03:27.630
So later about the same thing also applies here for Barlas cycle.

54
00:03:27.630 --> 00:03:30.450
We can use all of those new features like lambda.

55
00:03:30.450 --> 00:03:36.960
So we merely revisit these methods when we discuss some of those features like clampdowns Armato references

56
00:03:37.010 --> 00:03:38.780
on anonymous functions.

57
00:03:38.970 --> 00:03:44.720
But for now we are going to implement this interface that we have seen here call it binary operator

58
00:03:44.910 --> 00:03:47.080
and it's already done here.

59
00:03:47.080 --> 00:03:53.910
It's here in binary operator implementation or implements that method function interface under interface

60
00:03:53.970 --> 00:03:54.960
as meticulous.

61
00:03:54.960 --> 00:04:01.710
Apply as an extra parameters and we are simply arding dup the values that are passed to this method

62
00:04:01.720 --> 00:04:01.950
.

63
00:04:02.150 --> 00:04:10.260
OK so we are passing an instance of this implementation and Parlow prefix in Donelly it in walk that

64
00:04:10.260 --> 00:04:13.090
particular method in this implementation.

65
00:04:13.590 --> 00:04:15.860
So that's the panel prefix.

66
00:04:15.870 --> 00:04:24.810
Now let's look at the third one which is Barlows set all parlance at all basically sets each element

67
00:04:24.810 --> 00:04:34.110
in the eye array in the array to some value OK some value and Barlas at all is also like like the previous

68
00:04:34.110 --> 00:04:35.260
Metoprolol prefix.

69
00:04:35.370 --> 00:04:37.770
It also takes a functional interferes as in book.

70
00:04:37.770 --> 00:04:42.720
So you need to pass an instance of this an instance of this particular interface function interface

71
00:04:42.730 --> 00:04:42.910
.

72
00:04:43.080 --> 00:04:49.560
Once again we are passing an implementation and we call it us into unity operator Grampian it is here

73
00:04:50.970 --> 00:04:52.090
it is here.

74
00:04:52.440 --> 00:04:57.540
I implemented it and this is the method which I'm introducing in this class.

75
00:04:57.570 --> 00:05:00.980
Ok it doesn't belong to any unity operator.

76
00:05:01.170 --> 00:05:03.590
And you protect them how does matter apply as.

77
00:05:03.600 --> 00:05:05.300
And so we are writing that.

78
00:05:05.550 --> 00:05:06.140
OK.

79
00:05:06.270 --> 00:05:10.690
And basically for each invocation this matter

80
00:05:15.570 --> 00:05:22.170
despotically particular palace that all matter well invoke that mattered in the function interface.

81
00:05:22.440 --> 00:05:28.530
For each of the elements and it passes the index on B it doesn't pass the element value but it passes

82
00:05:28.530 --> 00:05:30.110
on the index.

83
00:05:30.570 --> 00:05:32.440
Once again here we go.

84
00:05:32.850 --> 00:05:33.600
If you look at that.

85
00:05:33.600 --> 00:05:35.520
So this is a parlor set all matter.

86
00:05:35.670 --> 00:05:44.460
So as you can see it in walks that Blye as in k now under underpasses only eyeball you eye is basically

87
00:05:44.460 --> 00:05:46.760
the index.

88
00:05:46.830 --> 00:05:48.490
So if you go back here.

89
00:05:49.020 --> 00:05:52.410
So that's what it is happening in the this or mogas

90
00:05:56.410 --> 00:05:57.430
comin out.

91
00:05:57.570 --> 00:05:59.750
So let me do this.

92
00:06:00.060 --> 00:06:05.670
So as you can see it is simply passing 0 1 and 2.

93
00:06:06.240 --> 00:06:08.390
Here it is it's passing.

94
00:06:08.490 --> 00:06:10.160
Initially it passes zero.

95
00:06:10.420 --> 00:06:16.190
And this not ever be 0 ever been null because I'm not invoking the perimeter.

96
00:06:16.290 --> 00:06:18.060
So in that case I thought it would be none.

97
00:06:18.060 --> 00:06:23.030
So every time it goes into this block on your computer turns the index that is passed.

98
00:06:23.220 --> 00:06:30.270
OK so finally the order the input articles passed then have these three values initially in the first

99
00:06:30.330 --> 00:06:35.180
iteration it were a zero would be past which is a next number then one and then two.

100
00:06:35.470 --> 00:06:35.820
OK.

101
00:06:35.820 --> 00:06:36.320
So that.

102
00:06:36.450 --> 00:06:38.840
So the update will be updated with those values.

103
00:06:39.030 --> 00:06:46.080
But if you want to update the army because something has to do each element of the or if you want to

104
00:06:46.080 --> 00:06:51.080
update because some other value rather than an index then you can do something like this.

105
00:06:51.090 --> 00:06:53.380
You can pass the ID OK.

106
00:06:53.550 --> 00:06:59.310
And which means that it will be none here there is this and this is the second method and it would not

107
00:06:59.310 --> 00:07:00.190
be null.

108
00:07:00.570 --> 00:07:07.350
And here we are saying when it passes the zeroth index we are seeing modify that element out of 5 in

109
00:07:07.350 --> 00:07:07.820
this case.

110
00:07:07.830 --> 00:07:11.900
But it can be anything it can be plus operation or multiplication.

111
00:07:12.120 --> 00:07:14.950
It just depends on your on your project.

112
00:07:15.060 --> 00:07:15.480
OK.

113
00:07:15.600 --> 00:07:21.100
So but in this case I'm just simply adding 5 to every other element.

114
00:07:21.320 --> 00:07:21.770
OK.

115
00:07:21.960 --> 00:07:28.810
So instead of doing it in a for loop or something like that using a single statement you can have fit

116
00:07:28.950 --> 00:07:31.780
the values of in the ID.

117
00:07:31.800 --> 00:07:32.170
OK.

118
00:07:32.220 --> 00:07:38.730
Say for example if it's a banking application and if there are lot of balances and if you want to just

119
00:07:38.760 --> 00:07:42.790
multiply them with some interest rate then you can do it in one go.

120
00:07:43.080 --> 00:07:48.870
So if I do this as you can see we're writing five survivors being added too far and then going to seven

121
00:07:48.870 --> 00:07:48.950
.

122
00:07:48.950 --> 00:07:50.390
So it's good study too.

123
00:07:50.420 --> 00:07:53.030
I was ordered to 86 and that's 91.

124
00:07:53.100 --> 00:07:59.140
So these are paralyzed operations and they will be used only if there is a multi-course system.

125
00:07:59.390 --> 00:08:03.200
In English what Barlow saw this is the number of elements that are needed.

126
00:08:03.360 --> 00:08:06.600
I'm not sure about other other two methods.

127
00:08:06.670 --> 00:08:10.290
So so Palethorpe is mainly for achieving vandalism.

128
00:08:10.470 --> 00:08:10.850
OK.

129
00:08:10.860 --> 00:08:13.120
So those are ordered in Java 8.

130
00:08:13.230 --> 00:08:14.030
So that's about it.

131
00:08:14.070 --> 00:08:19.350
So this also this new method is also added to the class on what is available in the resource section

132
00:08:19.710 --> 00:08:20.400
.

133
00:08:20.730 --> 00:08:21.300
Thank you.

134
00:08:21.300 --> 00:08:22.530
And happy coding.

