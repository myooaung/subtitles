WEBVTT
1
00:00:02.190 --> 00:00:04.190
Hi there this is determined.

2
00:00:04.230 --> 00:00:05.310
And welcome back.

3
00:00:05.310 --> 00:00:10.800
Now let's look at fuel important restrictions that we have it genetics.

4
00:00:10.890 --> 00:00:16.260
We did it is because few of the restrictions earlier this one was one of them pipe argument cannot be

5
00:00:16.260 --> 00:00:17.130
primitive.

6
00:00:17.250 --> 00:00:24.480
And in this example type argument it would give us a compiler We also very well know this restriction

7
00:00:24.730 --> 00:00:29.510
a class level by parameter cannot be used in this context.

8
00:00:29.640 --> 00:00:34.730
For instance it cannot be used as a type for static variables.

9
00:00:34.770 --> 00:00:41.790
Similarly it cannot be used in static methods as static initializers and we know that if it were static

10
00:00:41.790 --> 00:00:48.840
method needed genetic mess then we can define the genetic static method which defines its own parameters

11
00:00:48.840 --> 00:00:50.290
.

12
00:00:50.490 --> 00:00:57.540
We also know this we got overload methods that will have the same signature after type in nature.

13
00:00:57.540 --> 00:01:02.520
He had these two methods would have the same signature after type behavior and hence it is an invalid

14
00:01:02.520 --> 00:01:04.030
overload.

15
00:01:05.160 --> 00:01:06.460
And this is a new one.

16
00:01:06.480 --> 00:01:09.500
Genetics on Arrius do not mix.

17
00:01:10.230 --> 00:01:15.690
For instance you cannot create an idea or permit race type.

18
00:01:15.690 --> 00:01:20.440
Similarly you cannot also create an army off a type barometer.

19
00:01:20.580 --> 00:01:25.580
Both of these a generally are a creation error at compile time.

20
00:01:25.730 --> 00:01:31.350
And the reason why we cannot create a generic array is because it does not types.

21
00:01:32.370 --> 00:01:33.650
Let's look at an example.

22
00:01:34.050 --> 00:01:39.470
For the purpose of this discussion let's assume that genetic areas can be created.

23
00:01:40.020 --> 00:01:47.470
Let's consider the statement here the reference type is an array of object NBA creating an art offering

24
00:01:47.610 --> 00:01:53.490
Behrami Christ type or a list of string not set in big zero.

25
00:01:53.520 --> 00:02:01.070
We are storing and our eldest offspring nextstep in next one we want to store and idlest off India.

26
00:02:01.530 --> 00:02:05.470
And this will be possible as a reference type of the object reference.

27
00:02:05.480 --> 00:02:11.880
Here is an idea of object and we know that anything can be assigned to an object.

28
00:02:11.980 --> 00:02:18.420
So at compile time there will not be an error and we would expect that at runtime we would get an idea

29
00:02:18.420 --> 00:02:23.540
stored exception for going to store an element of wrong type in the art.

30
00:02:23.700 --> 00:02:26.970
We know that arrays and short typesafe be at runtime.

31
00:02:27.540 --> 00:02:30.270
Unfortunately that will not happen here.

32
00:02:30.470 --> 00:02:37.800
As we know that there is Pypard engine that is all of the pipe arguments here get airiest and we only

33
00:02:37.800 --> 00:02:41.690
have plain aerialist instances in the bytecode.

34
00:02:41.790 --> 00:02:47.140
So both elements are simple are illest instances and there is no distinction between them.

35
00:02:47.220 --> 00:02:53.820
So John under-prepared does not throw out a strong exception and with that type safety is broken not

36
00:02:53.890 --> 00:02:55.090
terminology wise.

37
00:02:55.110 --> 00:03:00.930
I would like to bring up a system called refired arrays are set to be refire.

38
00:03:01.290 --> 00:03:03.810
What it means is a run by him.

39
00:03:03.980 --> 00:03:08.170
Or is the type of element that can be stored in the ID.

40
00:03:08.280 --> 00:03:13.560
Now if you start it wrong type we know that we would get an artist or exception.

41
00:03:13.560 --> 00:03:19.930
So this property of knowing the element type information and forcing it at runtime is what makes Arrius

42
00:03:20.060 --> 00:03:22.030
refined.

43
00:03:22.140 --> 00:03:29.160
On the other hand generics in Java are nondairy fight as they're enforced by constraints only at compile

44
00:03:29.160 --> 00:03:34.720
time type information is airiest off and is not available at runtime.

45
00:03:34.890 --> 00:03:40.420
So just wanted to highlight this from a fight as sooner or later he would surely come across it.

46
00:03:40.500 --> 00:03:47.280
It is basically retention and enforcing of type information at runtime.

47
00:03:47.280 --> 00:03:53.430
This restriction is related to exceptions that cannot have generic exceptions and etiquettes.

48
00:03:53.790 --> 00:04:00.810
That is we cannot have generic types that are direct or indirect subtypes of the class Thorburn we know

49
00:04:00.810 --> 00:04:05.960
the plural is the root class in the exception class hierarchy.

50
00:04:06.510 --> 00:04:12.300
So you cannot have something like this where we are trying to create generic exception class by extending

51
00:04:12.390 --> 00:04:13.900
exception class.

52
00:04:14.100 --> 00:04:22.019
If this was legal then we may have something like this but we know that after type it ajor that pipe

53
00:04:22.019 --> 00:04:28.570
arguments would go away on the catch crosses would be identical and that would be meaningless right

54
00:04:28.570 --> 00:04:29.350
.

55
00:04:29.400 --> 00:04:35.370
So just go ahead and try creating such an exception class and you can see the compiler error.

56
00:04:35.400 --> 00:04:37.680
So those are the important restrictions that we have.

57
00:04:37.700 --> 00:04:42.510
But generics we may have missed a few but these are important ones.

58
00:04:42.510 --> 00:04:43.600
That's about it.

59
00:04:43.680 --> 00:04:44.160
Thank you

