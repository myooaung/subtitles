WEBVTT
1
00:00:02.100 --> 00:00:03.040
Hello there.

2
00:00:03.060 --> 00:00:04.260
This is Diamond de la Rue.

3
00:00:04.260 --> 00:00:05.310
And welcome back.

4
00:00:05.550 --> 00:00:07.440
Let's now look at variables.

5
00:00:08.810 --> 00:00:12.830
We know that object state is represented by variables.

6
00:00:13.460 --> 00:00:19.730
That is variables store state information like the student ID, student name and student gender.

7
00:00:20.690 --> 00:00:25.820
So essentially variables are like containers that hold some data.

8
00:00:26.670 --> 00:00:33.960
On some variables hold numeric data like student ID, while some others hold textual data like the student

9
00:00:33.960 --> 00:00:38.400
name, and some may hold objects like the student object.

10
00:00:38.790 --> 00:00:46.050
And we saw this when discussing class and object, and what a variable can hold is determined by the

11
00:00:46.050 --> 00:00:47.670
data type of the variable.

12
00:00:48.300 --> 00:00:52.620
So every variable has a data type associated with it.

13
00:00:52.620 --> 00:00:59.250
And we saw this earlier when discussing Class An object and we can simply call this data type as a variable

14
00:00:59.310 --> 00:00:59.700
type.

15
00:01:00.480 --> 00:01:04.500
So if the type is end, it can hold numeric data like thousand.

16
00:01:05.010 --> 00:01:09.030
And if the type is string, it can hold textual data like John.

17
00:01:09.510 --> 00:01:13.020
Or if the type is a class name like student.

18
00:01:13.050 --> 00:01:16.140
Then the variable can hold a student object.

19
00:01:17.150 --> 00:01:25.940
In Java, a variable type is defined when the variable is first declared or created and that type cannot

20
00:01:25.940 --> 00:01:27.500
be changed thereafter.

21
00:01:28.040 --> 00:01:34.880
That is, the type is fixed, which means the variable can only hold that type of data.

22
00:01:35.300 --> 00:01:39.740
And if you try to store some other type of data, then you get a compilation error.

23
00:01:40.460 --> 00:01:47.330
For instance, if you say that a variable is of type and then you can only store integers in it, and

24
00:01:47.330 --> 00:01:52.880
if you try to store a string in that variable, then you get a compilation error and soon we will see

25
00:01:52.880 --> 00:01:53.930
this in our demo.

26
00:01:54.840 --> 00:02:03.420
And due to this Java is referred to as a statically type language as the type of the variable is static

27
00:02:03.420 --> 00:02:07.050
once defined, that is, it cannot be changed.

28
00:02:07.940 --> 00:02:13.490
And the compiler ensures this and this type of checking performed during compilation is referred to

29
00:02:13.490 --> 00:02:15.380
as static type checking.

30
00:02:16.010 --> 00:02:20.780
So always keep in mind that Java is a statically type language.

31
00:02:21.290 --> 00:02:27.230
Now in some languages like JavaScript, same variable can hold different types of data.

32
00:02:27.650 --> 00:02:29.960
That is at one point in the program.

33
00:02:29.960 --> 00:02:36.770
It may hold a numeric value while later, at some other point in the program, it may hold textual data.

34
00:02:37.310 --> 00:02:44.540
And due to this, such languages are referred to as dynamic elite type languages as the type of the

35
00:02:44.540 --> 00:02:48.500
variable is dynamic that is it is not constant anymore.

36
00:02:49.040 --> 00:02:55.880
And the type checking in such languages is mostly done at runtime and therefore is referred to as dynamic

37
00:02:55.880 --> 00:02:56.570
type chicken.

38
00:02:57.560 --> 00:03:03.770
Now one main advantage of static type checking over dynamic type checking is that static type checking

39
00:03:03.770 --> 00:03:06.740
allows earlier detection of programming mistakes.

40
00:03:07.100 --> 00:03:11.780
That is, during compilation time itself, you will be able to find the mistakes.

41
00:03:12.230 --> 00:03:20.150
For instance, if you assign a variable or a lateral of one type to a variable of another type, then

42
00:03:20.150 --> 00:03:23.840
the compiler will report that it is an error and you can fix it.

43
00:03:23.840 --> 00:03:30.410
So subsequently during the program execution, you will not have any issues, but with a dynamically

44
00:03:30.410 --> 00:03:36.710
typed language, you will find the issue at runtime itself when you are executing the program and at

45
00:03:36.710 --> 00:03:39.800
that point it is too late, so you would have to fix it.

46
00:03:39.890 --> 00:03:45.170
And in the meanwhile your users might have bad experience in the resources section.

47
00:03:45.170 --> 00:03:51.530
I will include some nodes which you can check out and it lists all the advantages of a statically type

48
00:03:51.530 --> 00:03:53.990
language along with some interesting links.

49
00:03:54.410 --> 00:03:56.540
You don't have to read it right away.

50
00:03:56.540 --> 00:04:02.750
You can save that article or nodes and you can do it later when you are more comfortable with the language.

51
00:04:03.610 --> 00:04:11.290
Now here we can see that a variable is holding either raw data like 1000, like in the case of ID or

52
00:04:11.290 --> 00:04:14.650
is holding an object like in the case of variable SW.

53
00:04:15.310 --> 00:04:17.920
If the variable holds raw data like thousand.

54
00:04:17.950 --> 00:04:24.640
We refer to such a variable as primitive variable as the data it is holding is really primitive.

55
00:04:24.700 --> 00:04:29.920
That is as basic as it can be, as primitive as it can be.

56
00:04:30.250 --> 00:04:37.210
So variable ID is a primitive variable, whereas the variable that holds an object is referred to as

57
00:04:37.210 --> 00:04:38.860
an object reference.

58
00:04:39.100 --> 00:04:41.680
So the variable s is an object reference.

59
00:04:41.680 --> 00:04:45.040
That is it is holding a reference to an object.

60
00:04:45.610 --> 00:04:49.480
So it is actually not holding an object but a reference to an object.

61
00:04:49.840 --> 00:04:51.400
But we will discuss that later.

62
00:04:52.320 --> 00:04:58.410
So a variable can be a primitive or an object reference, and that is determined by the variables data

63
00:04:58.410 --> 00:04:58.860
type.

64
00:04:59.430 --> 00:05:03.930
And in Java there are eight primitive types and enter only one of them.

65
00:05:04.590 --> 00:05:10.230
So if a variable has any of those eight primitive types, then it would be a primitive variable.

66
00:05:11.010 --> 00:05:18.330
If the variable type is a class like student, then the variable will be an object reference and it

67
00:05:18.330 --> 00:05:20.000
will also be an object reference.

68
00:05:20.010 --> 00:05:26.280
If the variables type is something called an interface, an interfaces will be introduced after a few

69
00:05:26.280 --> 00:05:28.080
sections here.

70
00:05:28.080 --> 00:05:35.610
The variable name which is of type string, is also an object reference as string is a class n java.

71
00:05:36.180 --> 00:05:39.600
So string is a class in the Java library and we will look at it later.

72
00:05:39.990 --> 00:05:47.370
So it looks like a primitive as it does not have the new keyword, but internally it is an object reference.

73
00:05:47.850 --> 00:05:50.950
That is, it holds a reference to a string object.

74
00:05:50.970 --> 00:05:52.500
But more on that later.

75
00:05:53.010 --> 00:05:56.580
Both primitive types and object references will be discussed later.

76
00:05:58.190 --> 00:06:00.990
Now we know how a variable declaration looks like.

77
00:06:01.010 --> 00:06:03.620
But let's look at it in a more formal way.

78
00:06:04.040 --> 00:06:11.570
And declaring a variable involves stating the variable type followed by the variable name, and it can

79
00:06:11.570 --> 00:06:16.430
be optionally initialized with something called a literal or an expression.

80
00:06:17.310 --> 00:06:24.780
Here equal to symbol is referred to as an assignment operator as it assigns the value on its right to

81
00:06:24.780 --> 00:06:26.520
the variable on its left.

82
00:06:27.440 --> 00:06:29.870
And literal is simply raw data.

83
00:06:30.980 --> 00:06:34.520
And these are a few example declarations involving literals.

84
00:06:34.850 --> 00:06:40.250
In the first example, we are declaring an integer variable called ID, which is initialized with the

85
00:06:40.250 --> 00:06:41.450
literal thousand.

86
00:06:42.140 --> 00:06:47.540
In the second example, we are declaring a boolean variable called flag, which is initialized with

87
00:06:47.540 --> 00:06:52.070
the literal true and boolean is another primitive like int.

88
00:06:52.700 --> 00:06:59.300
And the third example we are declaring a string variable called name which is initialized with the literal

89
00:06:59.300 --> 00:06:59.900
John.

90
00:07:00.590 --> 00:07:08.170
So all of these are literals and an expression is something that gets evaluated to a single value.

91
00:07:08.180 --> 00:07:09.980
And let's look at a few examples.

92
00:07:11.270 --> 00:07:11.810
Here.

93
00:07:11.810 --> 00:07:16.640
An integer variable ID is initialized with another variable called x.

94
00:07:17.210 --> 00:07:23.510
The variable x is an expression and the value it holds will be assigned to the variable ID.

95
00:07:24.380 --> 00:07:27.980
So X would have been declared somewhere earlier in the program.

96
00:07:28.580 --> 00:07:35.030
So when the program is executing and when this statement executes, X would have some value and that

97
00:07:35.030 --> 00:07:37.730
value gets assigned to the variable ID.

98
00:07:38.660 --> 00:07:41.900
So you can see the difference between literal and expression.

99
00:07:42.230 --> 00:07:47.390
Literal is just a value like 1000 and needs no further computation.

100
00:07:47.900 --> 00:07:50.390
Whereas an expression involves computation.

101
00:07:51.020 --> 00:07:56.720
In this case, computation would be to take the value of X and assign it to ID.

102
00:07:57.930 --> 00:08:03.420
And this example, the expression is X plus Y, where X and Y are two variables.

103
00:08:03.960 --> 00:08:10.770
So during program execution, the values that X and Y hold will be added and the result is assigned

104
00:08:10.770 --> 00:08:12.030
to the variable ID.

105
00:08:13.680 --> 00:08:21.210
And here the expression is the student object creation part, which at runtime creates a student object

106
00:08:21.210 --> 00:08:23.610
and assigns it to the variable as.

107
00:08:24.610 --> 00:08:30.130
And such kind of declarations are referred to as declaration statements.

108
00:08:30.760 --> 00:08:33.580
So they are a type of statements.

109
00:08:34.380 --> 00:08:39.030
And declaration statements can appear anywhere in a class.

110
00:08:39.570 --> 00:08:41.909
And soon we will see this in our demo.

111
00:08:43.780 --> 00:08:50.650
So we have looked at variable declaration, but often we would want to change the value assigned to

112
00:08:50.650 --> 00:08:51.520
a variable.

113
00:08:52.060 --> 00:08:56.230
That is, the variable would have been initialized during variable declaration.

114
00:08:56.500 --> 00:09:01.750
But later on in the program we would want to reassign the variable with a different value.

115
00:09:02.260 --> 00:09:07.240
In fact, the term variable itself suggests that it is something whose value can be changed.

116
00:09:08.690 --> 00:09:12.320
And an assignment statement is used to change the variable value.

117
00:09:12.740 --> 00:09:15.050
Earlier we have seen the declaration statement.

118
00:09:15.920 --> 00:09:18.500
And here is the syntax of an assignment statement.

119
00:09:18.650 --> 00:09:24.830
It is similar to a declaration statement, but without the variable type as the type has already been

120
00:09:24.830 --> 00:09:26.870
defined in the declaration statement.

121
00:09:28.210 --> 00:09:33.400
And here are two example assignment statements one with the literal and the other with an expression.

122
00:09:35.300 --> 00:09:39.860
Not that such assignment statements cannot appear at class level.

123
00:09:40.460 --> 00:09:44.510
That is, they cannot appear directly within the body of a class.

124
00:09:44.990 --> 00:09:48.800
They can appear inside members of a class such as methods.

125
00:09:49.160 --> 00:09:55.100
And we would get a compilation error if we try to declare them directly within the body of a class.

126
00:09:55.520 --> 00:09:58.820
And we will also see this in our demo in the next lecture.

127
00:09:59.210 --> 00:10:00.420
So that's about it.

128
00:10:00.440 --> 00:10:02.450
That's a short introduction to variables.

129
00:10:02.480 --> 00:10:08.570
A variable is simply a container, and what it holds depends on its data type.

130
00:10:09.380 --> 00:10:13.400
Keep in mind that Java is a statically type language.

131
00:10:14.090 --> 00:10:18.320
Next, we will write a simple program and test everything we have seen in this lecture.

132
00:10:18.590 --> 00:10:19.310
Thank you.

