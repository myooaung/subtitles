WEBVTT
1
00:00:00.720 --> 00:00:01.460
Hi there.

2
00:00:01.530 --> 00:00:02.210
Welcome back.

3
00:00:02.260 --> 00:00:03.710
This is Duminy loop.

4
00:00:03.920 --> 00:00:09.330
Now we're going to do them all off the genetic markets and we are going to test out pretty much everything

5
00:00:09.330 --> 00:00:11.740
that we have seen in the previous lesson.

6
00:00:11.760 --> 00:00:17.220
So here we are in the genetics class under a new method called genetic math that the devil will has

7
00:00:17.220 --> 00:00:20.250
been Ardit our Niccol been walk from the main matter.

8
00:00:20.340 --> 00:00:26.100
In fact we are not going to run this method will mostly look at only compilation errors.

9
00:00:26.100 --> 00:00:27.620
That's what we'll be doing.

10
00:00:27.690 --> 00:00:33.420
So here we will look at many things like We will look at the type argument inference we are motard arguments

11
00:00:33.780 --> 00:00:37.310
and also the type argument input and we are target type.

12
00:00:37.350 --> 00:00:40.100
We will also look at explicit type arguments justification.

13
00:00:40.290 --> 00:00:45.280
We will also look at generic constructor and we would also look at the aggregate mattered.

14
00:00:45.390 --> 00:00:51.090
If you recall in the Wild Card them all there was an aggregate Metford which was not gambling properly

15
00:00:51.090 --> 00:00:51.490
.

16
00:00:51.510 --> 00:00:54.570
So Google fixed that and this using generic methods.

17
00:00:54.600 --> 00:00:56.370
So we also look at that.

18
00:00:56.370 --> 00:01:02.250
So let's get started now and let's look at this thing called S-type are our inference so everything

19
00:01:02.250 --> 00:01:06.410
has been written and this particular method in the interest of time.

20
00:01:06.420 --> 00:01:11.670
So you're not going to write any new code because it is locked or demonstrative here so here.

21
00:01:11.880 --> 00:01:14.780
So this is the type argument type or inference.

22
00:01:15.090 --> 00:01:18.280
So it is pretty similar to the method we saw earlier.

23
00:01:18.300 --> 00:01:24.840
So here it's a static method and it uses this type barometer deep under written byte is void.

24
00:01:25.050 --> 00:01:31.170
But despite parameter D is also used here as a matter of experimentor type and we're just printing the

25
00:01:31.170 --> 00:01:32.980
name of this object in this way.

26
00:01:33.130 --> 00:01:36.140
Plus on Dot get name which give us the simple name.

27
00:01:36.150 --> 00:01:37.910
Now let's go back.

28
00:01:38.400 --> 00:01:40.890
So in this case a double is being passed.

29
00:01:41.060 --> 00:01:41.820
OK.

30
00:01:41.860 --> 00:01:42.300
And the.

31
00:01:42.300 --> 00:01:47.310
Type argument that is inferred is from this from the method arguments.

32
00:01:47.520 --> 00:01:50.000
So we are going to infer it does double.

33
00:01:50.010 --> 00:01:57.090
So if I how know what hit my Eclipse editor is showing declination of the method which says that the

34
00:01:57.090 --> 00:02:04.170
type argument invert is double on the same double is also being shown here as a moderate parameter.

35
00:02:04.540 --> 00:02:06.280
So eclipse is doing that for us.

36
00:02:06.300 --> 00:02:08.030
It is showing this nicely.

37
00:02:08.259 --> 00:02:14.100
And then once the the code will be available in the resources section on everything all the comments

38
00:02:14.100 --> 00:02:14.840
are included.

39
00:02:14.850 --> 00:02:18.430
So you can also look at all the comments and you get a chance.

40
00:02:18.810 --> 00:02:21.480
And in the second example we are passing a string Djala.

41
00:02:21.570 --> 00:02:24.200
So that type in four is string.

42
00:02:24.480 --> 00:02:28.970
Now here there is a very similar megger it's named as type or inference.

43
00:02:29.010 --> 00:02:31.300
Only one is added here.

44
00:02:31.320 --> 00:02:37.110
So in addition to the methode here in the in addition to the method parameter the type parameter is

45
00:02:37.110 --> 00:02:39.710
also used as the return type.

46
00:02:39.750 --> 00:02:41.400
So we are simply returning object.

47
00:02:41.400 --> 00:02:42.970
Earlier it was wired.

48
00:02:43.080 --> 00:02:45.450
Other than that there is no difference here.

49
00:02:45.690 --> 00:02:47.180
So the pipe in foot.

50
00:02:47.190 --> 00:02:48.950
Once again we are passing string.

51
00:02:48.960 --> 00:02:51.540
So the type inferred is string.

52
00:02:51.750 --> 00:02:55.800
Right but the return type is also the type barometer B.

53
00:02:55.920 --> 00:02:59.610
Ok so the compiler knows that it is going to return a string.

54
00:02:59.820 --> 00:03:02.550
But in this case we are assigning it to a double.

55
00:03:02.640 --> 00:03:02.960
Right.

56
00:03:02.960 --> 00:03:05.130
On the string cannot be converted to debug.

57
00:03:05.190 --> 00:03:11.460
So compiler is is telling us that it is wrong assignment here so that this needs to be changed.

58
00:03:11.520 --> 00:03:16.850
So that's the compile time type safety benefit we get by using a genetic method.

59
00:03:17.250 --> 00:03:20.870
So this just demonstrates the compiler error.

60
00:03:21.320 --> 00:03:27.690
Not in this case we are displaying the compiler error but it highlights the fact that we are going to

61
00:03:27.690 --> 00:03:29.260
pass some wrong arguments.

62
00:03:29.430 --> 00:03:35.490
Ok so here we are using a method called audit collection which takes an ID and also a collection and

63
00:03:35.760 --> 00:03:38.290
copies all the elements of the Adinda collection.

64
00:03:38.530 --> 00:03:42.050
OK that's all it does on Hensick as named as outer to collection.

65
00:03:42.060 --> 00:03:44.130
So let's go ahead and look at this method.

66
00:03:44.130 --> 00:03:47.130
So here is the byte information be on.

67
00:03:47.130 --> 00:03:51.440
Here is the audio off of that pipe on here is a collection of the pipe.

68
00:03:51.630 --> 00:03:55.820
On here we are iterating through the elements of the array our days.

69
00:03:56.250 --> 00:04:02.730
And we are just adding that element as you can see here the pipe is deep and we're adding it the element

70
00:04:02.870 --> 00:04:04.610
all here always that element.

71
00:04:04.770 --> 00:04:06.380
We are adding it to the collection.

72
00:04:06.420 --> 00:04:12.830
That's all we are doing and first we are passing on in digerati and we're passing a collection off in

73
00:04:12.840 --> 00:04:14.440
major underbite.

74
00:04:14.440 --> 00:04:17.990
If you'll see it just be right.

75
00:04:18.360 --> 00:04:20.579
So it should be inferred ASC-P.

76
00:04:21.029 --> 00:04:23.790
So if I over it it says in danger.

77
00:04:23.790 --> 00:04:29.760
So this is the type argument that is inferred and it is an integer array a mixed collection off into

78
00:04:29.780 --> 00:04:30.050
.

79
00:04:30.210 --> 00:04:33.820
So once again it is inferred from the arguments here.

80
00:04:33.840 --> 00:04:42.430
Now if I change your train so we get our completion at her right we get a compilation here because I

81
00:04:42.530 --> 00:04:47.340
would not be in for it but because this is an integer and this is a string.

82
00:04:47.520 --> 00:04:52.520
But we were supposed to how as single type single type needs to be inferred.

83
00:04:52.560 --> 00:05:00.810
And that is not possible because this is integer and district but if I change this to number then it

84
00:05:00.810 --> 00:05:02.730
will be inferred as a number.

85
00:05:02.760 --> 00:05:09.840
And that's because between digit a number numbers the supertype most common supertype And in this case

86
00:05:09.840 --> 00:05:11.000
this is in court.

87
00:05:11.010 --> 00:05:15.910
We also discussed that in the lecture so set.

88
00:05:15.940 --> 00:05:22.710
So that's a bug in coding from the method arguments but if method arguments are not there are not specified

89
00:05:22.830 --> 00:05:26.200
then we know that it can also infer from the target type.

90
00:05:26.240 --> 00:05:28.300
And this is what is demonstrated here.

91
00:05:28.500 --> 00:05:30.540
OK so let's ignore this method name.

92
00:05:30.610 --> 00:05:31.380
Huge matter.

93
00:05:31.410 --> 00:05:34.540
But to say that we are inserting from target type.

94
00:05:34.590 --> 00:05:41.580
So if you look at this method it has a target type it has a method return type is also B but the method

95
00:05:41.580 --> 00:05:45.070
does not or does not use any method parameters.

96
00:05:45.310 --> 00:05:47.950
So inference has to be from the target type.

97
00:05:47.950 --> 00:05:48.420
OK.

98
00:05:48.690 --> 00:05:49.890
So if you go back.

99
00:05:50.160 --> 00:05:55.020
So if I hover over it it says that string is that type that is inferred.

100
00:05:55.380 --> 00:06:02.110
Now here in this case you see here in this case it is integer that Ogger type is integer.

101
00:06:02.110 --> 00:06:04.110
So B would be in for integer.

102
00:06:04.380 --> 00:06:09.720
But the only thing is if I wanted to get a compilation error I will get a runtime exception because

103
00:06:09.730 --> 00:06:16.470
this method is actually returning a string but the compiler is going to insert a cast here saying that

104
00:06:16.480 --> 00:06:20.500
it is integer because that's what it inferred from the target.

105
00:06:20.710 --> 00:06:25.740
OK so if I had run it probably this is the only time you run it.

106
00:06:25.750 --> 00:06:31.110
So we get a classic exception because Djalma long line docstring which was found here to be returned

107
00:06:31.440 --> 00:06:33.660
cannot be Casta Gelada or $9.9.

108
00:06:33.660 --> 00:06:42.510
OK so the compiler is going to insert ghast like this internally into a bytecode Mogami.

109
00:06:43.080 --> 00:06:44.480
So that's about that.

110
00:06:44.820 --> 00:06:52.990
So here the target pipe is being used but sometimes this kind of a motard can be part of another method

111
00:06:52.990 --> 00:06:53.740
invocation.

112
00:06:53.740 --> 00:07:00.210
So here we have a target type in Wilker one which is a method and to this method as an argument we are

113
00:07:00.210 --> 00:07:03.150
passing we are invoking this method.

114
00:07:03.310 --> 00:07:09.090
So this method does not have any method parameters here so it has two method arguments so it needs to

115
00:07:09.250 --> 00:07:09.460
.

116
00:07:09.610 --> 00:07:13.230
It needs to infer but that is not target type 2.

117
00:07:13.260 --> 00:07:18.720
So in this case it would it would infer from the method in Wookey shouldn't context.

118
00:07:19.020 --> 00:07:20.300
And we will see what that is.

119
00:07:20.460 --> 00:07:26.870
But that works on me from July 8 onwards are not going to work in all the motions before July 8.

120
00:07:27.030 --> 00:07:31.080
So I guess this is just the same at but the method name and Smith do.

121
00:07:31.120 --> 00:07:32.390
This ends with one.

122
00:07:32.620 --> 00:07:35.650
So let's just look at what this method is.

123
00:07:35.670 --> 00:07:36.460
So it takes it.

124
00:07:36.490 --> 00:07:37.080
Be here.

125
00:07:37.120 --> 00:07:41.060
This is the type under written by is a list of a.

126
00:07:41.440 --> 00:07:44.130
And it does something here let's not worry about it.

127
00:07:44.500 --> 00:07:47.080
But the return type is list offbeat.

128
00:07:47.110 --> 00:07:47.330
OK.

129
00:07:47.350 --> 00:07:56.130
Now if we go back if we look at this matter type target type in worker 1 it has a list off-Strip.

130
00:07:56.310 --> 00:07:59.540
OK this is a primary Kreiss type gander just done.

131
00:07:59.560 --> 00:08:07.570
Wired So the the method parameter list of string for this for on for this it is the return type is list

132
00:08:07.580 --> 00:08:08.310
off.

133
00:08:08.670 --> 00:08:14.830
So that list of B will be compared with the list of strik this one since this has a list of string as

134
00:08:14.830 --> 00:08:16.990
the method parameter now.

135
00:08:17.030 --> 00:08:25.220
So that acts like a target type and the compiler would infer the type argument of this method as B.

136
00:08:25.500 --> 00:08:32.280
But here it says a list of object are night that should be some bug within the eclipse Marsh which is

137
00:08:32.280 --> 00:08:38.850
the editor that I'm using because if it is a list of object and if this one is taking a list of string

138
00:08:38.940 --> 00:08:41.130
then that the assignment is not right.

139
00:08:41.190 --> 00:08:41.549
Right.

140
00:08:41.549 --> 00:08:43.840
That's because of invariance.

141
00:08:44.039 --> 00:08:47.420
So it's got to be a list of string only then it will work.

142
00:08:47.520 --> 00:08:52.090
If it was a list of string if it was something other than a list of string it would have shown a compiler

143
00:08:52.150 --> 00:08:53.850
error but it is not showing.

144
00:08:54.120 --> 00:08:56.470
So it should be a bug in a eclipse marsh.

145
00:08:56.670 --> 00:08:57.960
So that's what it is.

146
00:08:57.960 --> 00:09:06.730
Now let me just go ahead and change this properties and let me change this to 1.7 here.

147
00:09:06.820 --> 00:09:08.880
So it's not going to work anymore.

148
00:09:09.440 --> 00:09:14.060
So yes you can see it as giving some compilation orders here.

149
00:09:14.380 --> 00:09:14.940
OK.

150
00:09:14.940 --> 00:09:19.830
So it's not going to work so let's change it back to one point eight.

151
00:09:19.840 --> 00:09:20.100
OK.

152
00:09:20.110 --> 00:09:29.180
So that particular feature of inputting that kind of inputting was only introduced in Java 8 because

153
00:09:29.360 --> 00:09:34.720
go compilation error has gone on here it's just a similar thing and start off.

154
00:09:35.080 --> 00:09:41.080
This method we are creating an instance of idlest and we have the diamond notation.

155
00:09:41.220 --> 00:09:45.290
Now the diamond notation also uses the type argument here.

156
00:09:45.630 --> 00:09:49.460
But if it is not there then it would have used the target type.

157
00:09:49.620 --> 00:09:50.060
OK.

158
00:09:50.110 --> 00:09:51.180
Which is something like.

159
00:09:51.170 --> 00:09:56.770
Or at least all string equals Do you want a list off this one which we have been seeing in the in our

160
00:09:56.760 --> 00:09:57.680
demos.

161
00:09:57.880 --> 00:10:03.000
So that's not the case here because it is it is in-circuit it is added here in the method and location

162
00:10:03.000 --> 00:10:03.730
.

163
00:10:03.750 --> 00:10:06.000
So in this case also it works in the same way.

164
00:10:06.070 --> 00:10:13.430
This one takes a list of string so a string will be inferred here for this for this year for the generic

165
00:10:13.440 --> 00:10:22.830
type but unfortunately the same of the bug that we saw here also seems to be appearing here we are.

166
00:10:22.860 --> 00:10:24.970
We seem to have the same problem.

167
00:10:24.990 --> 00:10:25.260
OK.

168
00:10:25.280 --> 00:10:26.360
So that's about it.

169
00:10:26.370 --> 00:10:31.250
Now here we are in walking type argument inference from Target type 2.

170
00:10:31.250 --> 00:10:36.500
It's just the same method but here we are using a different type target type in walk or run.

171
00:10:36.500 --> 00:10:40.290
This is not a great typing marker do you get that.

172
00:10:40.350 --> 00:10:47.790
So this one uses list of the early articles list all string on it also written setlist offbeat but Gazzetta

173
00:10:47.780 --> 00:10:48.410
irrelevant.

174
00:10:48.450 --> 00:10:51.200
Solist offbeat so here.

175
00:10:51.300 --> 00:10:53.980
So this would be a list of the now.

176
00:10:54.000 --> 00:10:56.530
In this case it's a list of B.

177
00:10:56.550 --> 00:10:56.880
Right.

178
00:10:56.880 --> 00:11:00.610
So that type of this has to be inferred fast.

179
00:11:00.660 --> 00:11:03.710
OK but this is also not inferred.

180
00:11:03.770 --> 00:11:04.040
OK.

181
00:11:04.080 --> 00:11:07.610
There are two non inferred things here.

182
00:11:07.620 --> 00:11:13.350
So in this guess sense since it cannot be inferred because its argument is also not there and that is

183
00:11:13.350 --> 00:11:15.390
not archetype also for this method.

184
00:11:15.620 --> 00:11:18.980
So here the compiler places in it as object.

185
00:11:19.070 --> 00:11:26.180
OK if it cannot infer it will just keep it as object its what is happening here now here and this method

186
00:11:26.190 --> 00:11:28.210
is just the same invocation.

187
00:11:28.400 --> 00:11:31.350
But we have a target type here just off string.

188
00:11:31.620 --> 00:11:38.370
So if I holler at it it says that fart does matter type dargah typing work or do or does in court as

189
00:11:38.380 --> 00:11:39.120
strict.

190
00:11:39.570 --> 00:11:46.170
So it would become a list of string and then this one also because it has a list of B as the return

191
00:11:46.160 --> 00:11:46.790
type.

192
00:11:46.980 --> 00:11:52.810
So it will be in for a string but for this eclipse is not showing any is any issue.

193
00:11:52.950 --> 00:11:56.230
So it says that it is in for the string even for this.

194
00:11:56.250 --> 00:12:02.720
So for both of them are just string even for this method we are passing Nautilus off Diamond notation

195
00:12:03.140 --> 00:12:06.090
even for this its target type in walk or do.

196
00:12:06.470 --> 00:12:09.000
And for this also it will be a list of object.

197
00:12:09.530 --> 00:12:16.030
But in this statement We are using a target type on your list of string and we are having the new order

198
00:12:16.150 --> 00:12:17.820
list off this.

199
00:12:17.820 --> 00:12:20.640
So in this case it is going to infer as string.

200
00:12:20.930 --> 00:12:24.460
What about the method as well as for our list.

201
00:12:24.470 --> 00:12:31.340
And you can say as I know it is not strict only in this case because there is no way for us to infer

202
00:12:31.340 --> 00:12:33.180
it is seeing saying list of objects.

203
00:12:33.500 --> 00:12:34.870
OK so thats the thing.

204
00:12:34.880 --> 00:12:36.460
Now thats more ahead.

205
00:12:36.500 --> 00:12:41.520
And now this is another example of inferring the most specific supertype we saw this in the lecture

206
00:12:41.510 --> 00:12:42.140
.

207
00:12:42.140 --> 00:12:50.730
So this method has a beat and then return type is B and both the parameters are also using the type

208
00:12:50.730 --> 00:12:51.450
.

209
00:12:51.450 --> 00:12:56.360
So if you go back we are passing a string on another list here.

210
00:12:56.360 --> 00:13:03.130
If I hower Serializable is being in what we saw that in the lecture and this is also serializable.

211
00:13:03.320 --> 00:13:11.900
Now if it does something as like an integer then it is going to give us a combination error.

212
00:13:12.350 --> 00:13:17.280
So it needs to be serializable here because the return type is D.

213
00:13:17.310 --> 00:13:19.800
Now this is another example.

214
00:13:20.340 --> 00:13:22.570
Same things similar kind of thing.

215
00:13:23.070 --> 00:13:28.420
But we are passing out elist instance of list on an instance off a set here has said.

216
00:13:28.520 --> 00:13:32.290
So the common supertype is abstract collection.

217
00:13:32.390 --> 00:13:33.920
Implements collection.

218
00:13:33.920 --> 00:13:38.570
So thats why it is going great is footing as abstract collection here.

219
00:13:39.210 --> 00:13:44.430
So lets not worry about all this thing but it is basically abstract collection.

220
00:13:44.730 --> 00:13:47.810
And here we are calling it as useless generic method.

221
00:13:48.050 --> 00:13:49.550
Lets see why it does use you has.

222
00:13:49.740 --> 00:13:56.330
So if you go here this is the type parameter but the return type is void and the type parameter that

223
00:13:56.340 --> 00:13:59.900
is not a parameter here and the method parameter list.

224
00:13:59.930 --> 00:14:05.870
So basically it is pretty much we are passing it explicitly but it will not be used in any way in the

225
00:14:05.880 --> 00:14:06.920
client order right.

226
00:14:06.920 --> 00:14:08.870
Thats the benefit of genetics.

227
00:14:08.980 --> 00:14:15.360
Had it been if it was using editor type then it could have inserted a cast but thats not the case it

228
00:14:15.360 --> 00:14:18.950
is what are doing it under the parameters are also not there.

229
00:14:18.960 --> 00:14:21.460
So there is no scope of passing in arguments.

230
00:14:21.500 --> 00:14:24.740
So its just a list by parameter.

231
00:14:24.750 --> 00:14:29.690
So this is just to highlight the usefulness of parameters.

232
00:14:30.120 --> 00:14:32.560
So thats what it is ironed.

233
00:14:33.040 --> 00:14:35.570
Now let's ignore this for now.

234
00:14:35.900 --> 00:14:38.260
Not look at generally constrictors.

235
00:14:38.460 --> 00:14:42.270
So here is the genetics demo we are in that Benedix demo class.

236
00:14:42.360 --> 00:14:45.180
So lets look at these go here.

237
00:14:45.170 --> 00:14:52.620
So it uses this class level parameter b and this is the generics Demel generics constructor.

238
00:14:52.830 --> 00:14:57.360
And just like generic methods we are using this extents D.

239
00:14:57.410 --> 00:15:04.490
So it is easy for this I need is extending this class level by parameter and this is also used here

240
00:15:05.280 --> 00:15:07.500
as the parameter type.

241
00:15:07.540 --> 00:15:10.310
The thing is genetic constructors are very rare.

242
00:15:10.380 --> 00:15:13.850
I really did not find any examples for us.

243
00:15:14.000 --> 00:15:22.690
So I think we dont have to worry too much about it but the eldest class here it uses here are enlist

244
00:15:23.470 --> 00:15:28.640
he is a class level type parameter but this is a bonded bonded wild card.

245
00:15:28.640 --> 00:15:30.580
So it is using like this.

246
00:15:30.710 --> 00:15:37.260
We still did not discuss it or discuss bonded wild cards later but it can be converted into a genetic

247
00:15:37.530 --> 00:15:38.590
constrictor.

248
00:15:38.940 --> 00:15:40.740
But still this is the right way to do it.

249
00:15:40.750 --> 00:15:45.120
In this case so it does really relate to how genetic construct hurts.

250
00:15:45.180 --> 00:15:49.300
But this is just for your information.

251
00:15:49.720 --> 00:15:50.920
And this case.

252
00:15:50.910 --> 00:15:52.760
So here it is.

253
00:15:52.800 --> 00:15:55.960
So we have this we are instantiating genetics to them all.

254
00:15:55.980 --> 00:16:00.920
So this will be the pipe argument for the genetics demo class.

255
00:16:00.920 --> 00:16:01.490
OK.

256
00:16:01.530 --> 00:16:07.950
Now coming to the genetics constructor it will be inferred from the type argument just like genetic

257
00:16:07.950 --> 00:16:08.460
metrics.

258
00:16:08.460 --> 00:16:12.270
So it looks like genetic methods on a genetic constrictors we're going to limit that.

259
00:16:12.290 --> 00:16:18.450
So it is going to be for Howard what it is saying that that argument inferred from the constructor is

260
00:16:18.720 --> 00:16:25.590
double whereas for girls it is number no it is fine because doubleness going ekster number is futile

261
00:16:25.880 --> 00:16:26.080
.

262
00:16:26.220 --> 00:16:30.870
If you remember if you recall the constructor had the extents B.

263
00:16:30.910 --> 00:16:37.440
So B is number here which is a classloader type but done on E is double now in the next line here.

264
00:16:37.680 --> 00:16:42.880
So this one has a diamond notation under Diamon notation also uses repipe argument.

265
00:16:43.120 --> 00:16:50.100
OK so in this case this will be double here and the constructor also uses the type argument.

266
00:16:50.110 --> 00:16:55.040
So the type argument is used by both this notation but that I'm a notation as well as this.

267
00:16:55.050 --> 00:16:57.790
So it's like Hower says double here.

268
00:16:57.840 --> 00:16:59.990
It also says W here.

269
00:17:00.000 --> 00:17:06.390
Now here you are you're passing it explicitly you're passing double for the constructor but for the

270
00:17:06.390 --> 00:17:11.130
Class B a passing number that is perfectly valid because double extents number.

271
00:17:11.130 --> 00:17:13.010
So here everything is explicit.

272
00:17:13.060 --> 00:17:14.700
So that's pretty nice.

273
00:17:14.700 --> 00:17:16.960
So here you pass it this way.

274
00:17:17.109 --> 00:17:21.119
This is how you explicitly specify right before Gosney.

275
00:17:21.510 --> 00:17:26.190
You can also specified here just after the there need not be the space here.

276
00:17:26.270 --> 00:17:27.589
This also looks.

277
00:17:27.770 --> 00:17:34.990
Now here this is this I'm really not sure why this is so this is explicit but here this is supposed

278
00:17:34.980 --> 00:17:36.100
to be implicit.

279
00:17:36.340 --> 00:17:41.840
So I assumed that it would infer that automatically that this is a double.

280
00:17:42.180 --> 00:17:44.460
But it is not doing it are not.

281
00:17:44.490 --> 00:17:47.010
I wish it could have inferred better does not doing.

282
00:17:47.010 --> 00:17:52.890
So I really do not know why it does look as if I know what it says explicit type arguments cannot be

283
00:17:52.890 --> 00:17:55.840
used with a diamond notation in an allocation expression.

284
00:17:55.840 --> 00:17:58.180
So this is an allocation expression.

285
00:17:58.280 --> 00:18:00.590
So I don't know the reason for that.

286
00:18:00.710 --> 00:18:07.890
I know I did not find any not Hondas and I searched for that particular exception on in Google.

287
00:18:08.010 --> 00:18:10.990
I did not find any any anything about that.

288
00:18:11.280 --> 00:18:13.360
So let's just leave it like that.

289
00:18:13.380 --> 00:18:19.480
Now here is another example where the constructor for the constructor does inferring from here like

290
00:18:19.520 --> 00:18:21.840
it should from the method argument.

291
00:18:22.090 --> 00:18:29.100
But for this it is inferring from the target type because if it is first double it this is going to

292
00:18:29.110 --> 00:18:32.730
be generics and I'm off number then we have the invariance issue.

293
00:18:32.730 --> 00:18:37.170
So the compiler is smart enough to infer a number from this guy.

294
00:18:37.470 --> 00:18:38.360
So that's the thing.

295
00:18:38.550 --> 00:18:41.520
And here is the final thing.

296
00:18:41.520 --> 00:18:42.220
This is from.

297
00:18:42.280 --> 00:18:44.390
We saw this in the wild cards demo.

298
00:18:44.620 --> 00:18:46.020
So we had one less.

299
00:18:46.160 --> 00:18:46.570
OK.

300
00:18:46.720 --> 00:18:53.400
Then it was called as invalid agregate and we were aggregating the elements from this list from the

301
00:18:53.400 --> 00:18:55.600
second list into the list.

302
00:18:55.800 --> 00:19:01.650
So that to the three lists are surpassed here the the elements from the first on the second list here

303
00:19:02.130 --> 00:19:03.880
are inserted into this.

304
00:19:04.120 --> 00:19:09.520
And we know that in aggregate in reality that was a matter and you can go back and look at that because

305
00:19:09.570 --> 00:19:12.110
of me because we were using wild cards.

306
00:19:12.120 --> 00:19:18.570
It did not allow us to art here it was giving a compassionate heart because because of using the wild

307
00:19:18.580 --> 00:19:19.280
card game.

308
00:19:19.300 --> 00:19:22.030
But now we can add them.

309
00:19:22.330 --> 00:19:26.570
So that means that the common disorder I think it's this one.

310
00:19:27.140 --> 00:19:29.540
So as you can see this is all good.

311
00:19:29.620 --> 00:19:31.010
One two three and four.

312
00:19:31.020 --> 00:19:32.510
It's working fine.

313
00:19:32.970 --> 00:19:36.640
So that's all there is for that not only thing here.

314
00:19:37.100 --> 00:19:45.030
As I commented on this one this one we are also explicitly passing type witness here stood a monster

315
00:19:45.050 --> 00:19:45.080
.

316
00:19:45.100 --> 00:19:47.330
But here it's genetics Demel.

317
00:19:47.530 --> 00:19:54.560
It is supposed to be when you remove this you're just a monster tinga.

318
00:19:55.200 --> 00:19:55.820
OK.

319
00:19:56.220 --> 00:19:59.040
So in this case is.

320
00:19:59.130 --> 00:20:01.530
So in this case this is all compilation.

321
00:20:01.570 --> 00:20:02.770
Let's not worry about it.

322
00:20:02.800 --> 00:20:03.880
It's just demonstrate.

323
00:20:03.900 --> 00:20:04.990
I'm just a monster getting dark.

324
00:20:04.990 --> 00:20:09.260
This pipe argument inference I'm passing on explicit here.

325
00:20:09.320 --> 00:20:10.290
Preakness here.

326
00:20:10.470 --> 00:20:11.570
That's all there is.

327
00:20:11.590 --> 00:20:17.170
So if you look at Doc takes a beat on we're passing genetics demarche self.

328
00:20:17.220 --> 00:20:20.940
So that's why here I am passing an instance off in an accident.

329
00:20:21.300 --> 00:20:23.370
So that's all that is so then.

330
00:20:23.400 --> 00:20:26.220
My thoughts are really useful for static utility classes.

331
00:20:26.320 --> 00:20:32.220
If you have something really genetic reuseable algorithmic kind of methods which can work on any input

332
00:20:32.590 --> 00:20:34.450
then you need to go for that.

333
00:20:34.650 --> 00:20:36.400
And by inference is there.

334
00:20:36.630 --> 00:20:37.720
So that's about EQ.

335
00:20:37.740 --> 00:20:40.510
So it's really useful you need to favor genetic methods.

336
00:20:40.600 --> 00:20:41.360
OK.

337
00:20:41.640 --> 00:20:42.180
Thank you.

338
00:20:42.190 --> 00:20:44.950
Arne the code is available in the resources section.

339
00:20:45.030 --> 00:20:46.480
Happy coding.

