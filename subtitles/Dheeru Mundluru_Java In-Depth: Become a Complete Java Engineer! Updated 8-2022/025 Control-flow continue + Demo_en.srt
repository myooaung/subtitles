1
00:00:01,000 --> 00:00:08,500
Not just look at your statement which is similar to a vague statement a continual statement is used

2
00:00:08,500 --> 00:00:11,380
with only loops that is either with furler.

3
00:00:11,410 --> 00:00:11,990
Why not.

4
00:00:12,010 --> 00:00:14,670
Or do I look so unlike break.

5
00:00:14,800 --> 00:00:16,520
It's not used with a switch statement.

6
00:00:18,270 --> 00:00:24,700
And as the names are just a continual statement continues with the next iteration of the innermost loop

7
00:00:25,660 --> 00:00:32,290
on any statements immediately following it are not executor so well a big statement is used to break

8
00:00:32,290 --> 00:00:40,060
out of the innermost loop a continual statement is used to continue with the innermost true here's an

9
00:00:40,060 --> 00:00:46,060
example the continue statement is used in a while statement typically as shown here continue would be

10
00:00:46,060 --> 00:00:50,760
engrossed in an IF statement so then continue stateman gets executed.

11
00:00:51,040 --> 00:00:56,340
The rest of the why loop escape and we continue with the next iteration with the condition expression

12
00:00:56,340 --> 00:00:57,400
is evaluated.

13
00:00:59,160 --> 00:01:04,650
Not this book it can be a statement in a fuddle hit as soon as the continue statement is encountered

14
00:01:04,849 --> 00:01:06,620
the rest of the for loop is good.

15
00:01:06,860 --> 00:01:12,860
And then any expressions in the expression this study evaluated only after that the condition expression

16
00:01:12,860 --> 00:01:14,520
is evaluated.

17
00:01:14,660 --> 00:01:20,390
We know that this is how a for loop cycle normally books on it is no different when a continuous treatment

18
00:01:20,390 --> 00:01:21,300
is involved.

19
00:01:23,040 --> 00:01:27,960
Here's an invalid example which is similar to the one we saw when discussing break.

20
00:01:28,290 --> 00:01:31,260
It gives a compiler as there is no and closing look.

21
00:01:33,080 --> 00:01:38,150
Like in the case of a break statement there is actually a label can be in your statement which is very

22
00:01:38,150 --> 00:01:46,120
useful when dealing with nested loops husbandly to label the loop which we want to continue read for

23
00:01:46,150 --> 00:01:51,710
this we have the label name followed by a colon which is in turn followed by a loop statement like a

24
00:01:51,730 --> 00:01:58,310
for a while next somewhere within that loop we can have a label can in your statement.

25
00:01:58,620 --> 00:02:04,340
Well the key word continue is followed by the label name know I want to highlight a difference between

26
00:02:04,430 --> 00:02:08,250
label break a label continue here we continue.

27
00:02:08,360 --> 00:02:15,260
The label is associated with only an end closing loop statement like a fire Otterbein hover over the

28
00:02:15,260 --> 00:02:16,230
break statement.

29
00:02:16,280 --> 00:02:23,270
The label can be associated with any block statement number block statement can also be an if statement

30
00:02:24,080 --> 00:02:28,360
so it means that labels continue cannot be used with an if statement.

31
00:02:29,940 --> 00:02:36,810
Here it is called on the left use label break and the label is associated with an if statement and it

32
00:02:36,810 --> 00:02:38,200
is perfectly valid.

33
00:02:38,750 --> 00:02:44,820
Whereas on the right is an example of often label continue and we get a compiler error at the continue

34
00:02:44,820 --> 00:02:53,060
statement as the label it uses is associated with an if statement rather than an enclosing local not

35
00:02:53,100 --> 00:02:55,400
lost your shot them off label continue.

36
00:02:55,550 --> 00:03:01,320
The code is very similar to the Corbie software and they will bring a new medical label continue has

37
00:03:01,320 --> 00:03:04,000
been added but the basics democracy.

38
00:03:04,190 --> 00:03:04,990
Let's look at the code.

39
00:03:04,990 --> 00:03:09,840
Now OK here is the new method label continue.

40
00:03:10,140 --> 00:03:16,470
And as you can see it is very identical to the label brick method which we have seen in the break statement

41
00:03:16,620 --> 00:03:17,100
.

42
00:03:17,430 --> 00:03:23,670
OK so we have the same number variable initialized to zero and we have the nested for loop and we have

43
00:03:23,670 --> 00:03:29,820
the same if condition our number is getting incremented here and we are printing it here pending the

44
00:03:29,820 --> 00:03:31,180
final value of.

45
00:03:31,770 --> 00:03:33,960
And we have the same label outermost.

46
00:03:34,080 --> 00:03:39,330
And the only difference the only difference here is that we how this statement continues.

47
00:03:39,330 --> 00:03:44,010
So the break statement the label break has been replaced with a label continue.

48
00:03:44,010 --> 00:03:47,490
That's the only difference even the condition is also seen.

49
00:03:47,790 --> 00:03:52,650
OK so here we are initialising number zero and up within the nested for loop.

50
00:03:52,740 --> 00:03:56,860
Each nested For each for loop is iterating 14 times.

51
00:03:57,270 --> 00:04:04,470
And here the condition is if I equals five and Jake was five in that case we are going to continue with

52
00:04:04,470 --> 00:04:05,730
the outermost loop.

53
00:04:05,840 --> 00:04:06,490
OK.

54
00:04:06,510 --> 00:04:10,980
So normally this would in a for loop What did it for 100 times.

55
00:04:11,160 --> 00:04:19,140
But when I is equal to 5 then we are in J's equal to 5 then we are skipping the last five iterations

56
00:04:19,200 --> 00:04:25,760
of the innermost loop and we are just continuing with the next iteration of the outer outer most for

57
00:04:25,770 --> 00:04:26,130
low.

58
00:04:26,190 --> 00:04:26,660
OK.

59
00:04:26,760 --> 00:04:30,440
So we are just keeping the five five iterations here.

60
00:04:30,450 --> 00:04:37,710
One is equal to five and J is equal to five which means that we are skipping Jake will do 5 6 7 8 and

61
00:04:37,710 --> 00:04:38,380
9.

62
00:04:38,380 --> 00:04:38,710
OK.

63
00:04:38,730 --> 00:04:45,620
Five of them sort of hundred hundred iterations we are skipping five and so numb would be incremental

64
00:04:45,630 --> 00:04:46,310
to 95.

65
00:04:46,310 --> 00:04:50,600
So they know for loop isn't rim is it rating for 95 times.

66
00:04:50,610 --> 00:04:53,510
OK so let's just go ahead and run it.

67
00:04:53,520 --> 00:05:00,930
It's already compiled as you can see it is printing 95 so that's about labeled on Daneel statement.

68
00:05:00,990 --> 00:05:01,670
OK.

69
00:05:01,830 --> 00:05:05,580
Know you can also find this program in the resource section.

70
00:05:05,580 --> 00:05:06,220
OK.

71
00:05:06,540 --> 00:05:07,100
Thank you.

72
00:05:07,100 --> 00:05:07,990
And happy coding.

