1
00:00:00,330 --> 00:00:01,530
Hello and welcome back.

2
00:00:02,250 --> 00:00:07,290
This is going to be a little bit of a different kind of a lesson, if you will.

3
00:00:07,620 --> 00:00:12,420
I didn't plan for it to be a lesson at all and in fact, I wasn't even planning to make this type of

4
00:00:12,420 --> 00:00:13,080
video.

5
00:00:13,890 --> 00:00:19,890
I was actually working on the exercises for section eight of the course.

6
00:00:20,220 --> 00:00:26,670
And when I started working specifically on exercise eight of the course, I started going down a path

7
00:00:26,670 --> 00:00:31,830
of creating basically a miniature project just for that exercise.

8
00:00:31,830 --> 00:00:40,140
And I realized that it was so involved that I should probably step back and actually make at least one

9
00:00:40,140 --> 00:00:44,410
full video explaining all of my solutions for exercise.

10
00:00:44,430 --> 00:00:44,820
Eight.

11
00:00:45,000 --> 00:00:50,520
And all of these sub exercises under it, of which there are quite a large number of.

12
00:00:50,790 --> 00:00:59,550
So this lesson will be more of a walk through my solutions for exercise aid of Section eight.

13
00:01:00,210 --> 00:01:06,840
As such, I would say that if you are planning to actually do those exercises yourself and you have

14
00:01:06,840 --> 00:01:13,890
not done them yet, I would encourage you probably to stop watching this video right now and go attempt

15
00:01:13,890 --> 00:01:21,180
to those exercises first and then come back to this video after you've either completed them or given

16
00:01:21,180 --> 00:01:24,090
up because you weren't sure how to how to go about them.

17
00:01:24,540 --> 00:01:30,780
Now that being said, I'm going to try first in this in this video to just explain a little bit of the

18
00:01:30,780 --> 00:01:33,270
background on chess and how it works.

19
00:01:34,050 --> 00:01:36,030
So you could stick around for that part.

20
00:01:36,030 --> 00:01:41,430
But when I start jumping into the code and the solutions for the code, like I said, if you're planning

21
00:01:41,430 --> 00:01:47,220
to actually do these exercises yourself, then I would strongly recommend that you not watch this video

22
00:01:47,220 --> 00:01:49,320
until you've tried the exercises.

23
00:01:49,530 --> 00:01:53,340
And you know, one big reason I'm saying that is is for your benefit.

24
00:01:53,640 --> 00:02:00,480
You will learn best if you attempt to do these exercises independently on your own first.

25
00:02:00,840 --> 00:02:04,410
And even if you don't accomplish them, even if you get stuck.

26
00:02:04,860 --> 00:02:11,910
The thought process of struggling through how to implement those exercises will help you to understand

27
00:02:11,910 --> 00:02:14,790
my explanations better when you see how I did it.

28
00:02:15,090 --> 00:02:19,500
So you won't get as much out of out of the exercises if you just watch this.

29
00:02:19,500 --> 00:02:23,670
And in fact, if you just watch what I'm about to show now, that won't really be any different from

30
00:02:23,670 --> 00:02:28,260
you watching how I've been doing all of the other coding throughout the entire course up until this

31
00:02:28,260 --> 00:02:28,680
point.

32
00:02:29,010 --> 00:02:29,280
All right.

33
00:02:29,290 --> 00:02:31,530
So let me give you a quick little background.

34
00:02:31,530 --> 00:02:42,000
Then I chose to use chess as a domain to create these exercises around because chess is a very world

35
00:02:42,000 --> 00:02:42,960
famous game.

36
00:02:43,080 --> 00:02:48,360
A lot of people know at least a little bit about how to play it, though many people are not experts,

37
00:02:48,360 --> 00:02:49,470
including myself.

38
00:02:50,040 --> 00:02:54,900
And it is a game that is that has what I call a rich domain.

39
00:02:55,350 --> 00:03:03,150
That means that there are a good number of pieces, a good number of nouns associated in the chess domain,

40
00:03:03,450 --> 00:03:05,970
and there's a lot of business logic.

41
00:03:06,120 --> 00:03:09,750
Now, since we're talking about a game, usually we won't call that business logic.

42
00:03:09,750 --> 00:03:13,920
We might call it game logic, but those are the rules of the game.

43
00:03:14,100 --> 00:03:19,260
So it has a pretty rich set of game rules or business logic.

44
00:03:19,680 --> 00:03:26,400
And one problem that I've seen in a lot of books that try to teach technical things like programming

45
00:03:26,400 --> 00:03:35,010
or in online courses is that their examples are usually either way too simple so that they don't really

46
00:03:35,010 --> 00:03:38,040
fully prepare you for work in the real world.

47
00:03:38,070 --> 00:03:43,950
Or they're way too complicated, in which case they go right over everybody's head.

48
00:03:44,100 --> 00:03:49,560
And a lot of beginners like you presumably are don't really understand what's going on.

49
00:03:49,890 --> 00:03:55,920
So I was hoping that this domain of chess would be a good middle of the road.

50
00:03:55,920 --> 00:04:03,450
Perhaps where the rules are not super simplistic, they can get a little bit involved, but not to the

51
00:04:03,450 --> 00:04:05,130
point of being rocket science.

52
00:04:05,370 --> 00:04:10,800
So you'll have to be the judge of whether or not I hit the mark in getting a domain that's kind of somewhere

53
00:04:10,800 --> 00:04:11,430
in the middle.

54
00:04:11,610 --> 00:04:13,620
Not too easy, not too hard.

55
00:04:14,160 --> 00:04:23,040
So I will let you know that in creating the solutions for these exercises, even I had to think a bit

56
00:04:23,250 --> 00:04:27,450
on how I thought it would be best to solve some of these exercises.

57
00:04:27,480 --> 00:04:27,840
OK.

58
00:04:28,050 --> 00:04:35,370
So if you're thinking that you're meant to get through all of these exercises under exercise eight quickly,

59
00:04:35,370 --> 00:04:37,020
like in an hour or something?

60
00:04:37,260 --> 00:04:39,390
I doubt that that's realistic at all.

61
00:04:39,660 --> 00:04:45,750
I suspect that for many of you, these exercises could take a week, maybe even take a couple of weeks

62
00:04:45,750 --> 00:04:46,590
for some of you.

63
00:04:46,860 --> 00:04:50,100
Some of you may be able to do them in a day or two.

64
00:04:50,100 --> 00:04:50,910
I don't know.

65
00:04:51,180 --> 00:04:56,550
It just depends on how you go about doing it and what your desired end goal is.

66
00:04:56,850 --> 00:04:59,810
My desired end goal is usually to create.

67
00:04:59,890 --> 00:05:07,570
Code that is concise and relatively easy to understand, but but still relatively simple looking at

68
00:05:07,570 --> 00:05:08,470
the same time.

69
00:05:08,830 --> 00:05:16,180
And that's actually not a very easy thing to do when you're dealing with a non-trivial domain like chess.

70
00:05:16,870 --> 00:05:22,960
So I myself have worked on these solutions actually over the course of two or three days, and I will

71
00:05:22,960 --> 00:05:30,190
even admit that at one point I didn't like my approach, and so I actually deleted everything and recreated

72
00:05:30,190 --> 00:05:31,360
it all from scratch.

73
00:05:31,540 --> 00:05:36,460
Now, when I recreated it, I recreated it pretty quickly because I had already worked out a lot of

74
00:05:36,460 --> 00:05:37,750
what I wanted there.

75
00:05:37,990 --> 00:05:45,580
But my point here is that even I, a seasoned Java developer, had to put some serious thought into

76
00:05:45,580 --> 00:05:50,500
how I wanted to model this chess domain for these exercises.

77
00:05:50,860 --> 00:05:54,040
It was not just elementary school for me, OK?

78
00:05:54,130 --> 00:05:56,020
I really did put some thought into it.

79
00:05:56,020 --> 00:06:03,010
And so I presume you two will need to put some significant thought into your domain and how your modeling

80
00:06:03,010 --> 00:06:05,500
classes and implementing some of the methods here.

81
00:06:05,650 --> 00:06:05,910
All right.

82
00:06:05,920 --> 00:06:10,540
So the first thing we're going to do, though, is just to make sure we're all on the same page.

83
00:06:10,720 --> 00:06:17,080
I'm going to just do a very quick review of some of the basics of how chess works so that I can just

84
00:06:17,080 --> 00:06:18,970
make sure that we're all on the same page with this.

85
00:06:19,390 --> 00:06:24,580
OK, so here I have a little chess board open up and this is actually from Wikipedia.

86
00:06:24,580 --> 00:06:30,220
So if you just you go to Wikipedia and look up chess, and I think I included a link, in fact, to

87
00:06:30,430 --> 00:06:35,380
a part of the chess article on Wikipedia that tells you some of the basic rules and how some of the

88
00:06:35,380 --> 00:06:39,970
main pieces that we're going to be modeling actually move on on the board.

89
00:06:40,150 --> 00:06:40,540
OK.

90
00:06:40,900 --> 00:06:43,710
So anyway, here is a typical chess board.

91
00:06:43,720 --> 00:06:45,130
We've got the black pieces now.

92
00:06:45,130 --> 00:06:50,950
They're not showing the white pieces, but if you can imagine that this is a mirror here, then down

93
00:06:50,950 --> 00:06:57,400
here in these rows, one in two, you'd have white chess pieces that mirror the black pieces that we're

94
00:06:57,400 --> 00:06:58,330
seeing up here.

95
00:06:58,360 --> 00:06:58,810
OK.

96
00:06:59,290 --> 00:07:06,730
And on this particular board, we've got these letters going down here along the x axis and then we've

97
00:07:06,730 --> 00:07:09,730
got numbers going along the y axis here.

98
00:07:10,120 --> 00:07:17,520
And by using these letters and numbers, we are able to label all of the squares on the chess board.

99
00:07:17,530 --> 00:07:20,740
So we see here that this square is a one.

100
00:07:20,890 --> 00:07:24,550
This is B because there's B and there's two there, right?

101
00:07:24,700 --> 00:07:26,980
D four, D and four.

102
00:07:27,070 --> 00:07:32,050
So anyone who's been through probably middle school should understand how that is working.

103
00:07:32,380 --> 00:07:35,410
This is part of what is called chess notation.

104
00:07:35,560 --> 00:07:42,760
And it is simply a way for us to specify what square on the board we may be talking about.

105
00:07:42,910 --> 00:07:43,390
OK.

106
00:07:43,750 --> 00:07:44,140
All right.

107
00:07:44,350 --> 00:07:47,050
Now there are several pieces in chess.

108
00:07:47,050 --> 00:07:52,690
We're not going to get into all of them now and in the exercises of exercise.

109
00:07:52,690 --> 00:08:00,820
Eight, I'm really only focused on two of the pieces Pons, which are these pieces here on Row seven

110
00:08:01,330 --> 00:08:08,740
and Knights, which are which is this horse looking piece right here at the G8 and there's another one

111
00:08:08,740 --> 00:08:09,940
here at G8.

112
00:08:10,060 --> 00:08:10,510
OK.

113
00:08:11,080 --> 00:08:18,310
The reason I chose these two pieces is because to me, they represent a little bit of a range in complexity.

114
00:08:18,610 --> 00:08:23,560
Pons might arguably be the simplest piece on the chessboard.

115
00:08:24,040 --> 00:08:31,090
They are certainly worth the least in terms of points, and they have fairly simplistic movements that

116
00:08:31,090 --> 00:08:31,810
they can make.

117
00:08:32,350 --> 00:08:38,620
Most of the time, they can only move one square at a time forward, except for on their initial move

118
00:08:38,620 --> 00:08:40,080
at the very beginning of the game.

119
00:08:40,090 --> 00:08:48,850
If the player chooses to, the player can choose to move upon two squares forward just on the very first

120
00:08:48,850 --> 00:08:49,270
move.

121
00:08:49,360 --> 00:08:54,760
It's up to the player, though it can move one square forward or two squares forward after that initial

122
00:08:54,760 --> 00:09:02,080
movement, though, all subsequent moves have to be one square forward unless the pawn is capturing

123
00:09:02,230 --> 00:09:10,150
an enemy and really quickly, I will just say, let us pretend that there is a white piece right here

124
00:09:10,480 --> 00:09:14,260
on Square D6 six in that case.

125
00:09:14,980 --> 00:09:26,200
This pawn on C7 or this pawn on E7 could choose to move diagonally one square to here and take or capture

126
00:09:26,470 --> 00:09:27,890
that white piece.

127
00:09:27,910 --> 00:09:32,710
OK, that is the one time when pawns can move diagonally.

128
00:09:33,100 --> 00:09:38,320
However, even then, they are only allowed to move one square diagonally.

129
00:09:38,830 --> 00:09:43,150
Pons cannot capture an enemy piece that is directly in front of them.

130
00:09:43,300 --> 00:09:45,490
They can only capture diagonally.

131
00:09:46,990 --> 00:09:47,410
All right.

132
00:09:47,890 --> 00:09:49,390
And then the night.

133
00:09:50,410 --> 00:09:57,280
I chose for us to also work on modeling the night because the night has perhaps the strangest type of

134
00:09:57,280 --> 00:10:04,990
movement nights do not move just simplistically forward or sideways or sideways or diagonally.

135
00:10:05,200 --> 00:10:13,510
They actually move in a pattern of two squares and then one square so they can move two squares forward

136
00:10:13,510 --> 00:10:21,150
and then one square to the right, two squares forward, or one square to the left or two squares sideways

137
00:10:21,150 --> 00:10:29,920
and one square forward, two squares sideways and one square backward or one square, and then two squares

138
00:10:29,920 --> 00:10:30,370
forward.

139
00:10:30,370 --> 00:10:39,190
So as long as their movement is some combination of one and two or two and one in any direction other

140
00:10:39,190 --> 00:10:44,890
than diagonal, they are generally allowed to make that movement and they make the same movement, whether

141
00:10:44,890 --> 00:10:48,190
they're just traveling or capturing a piece, OK?

142
00:10:48,220 --> 00:10:55,010
Unlike pawn, when pawns are just simply traveling, they can only move forward when they're capturing.

143
00:10:55,030 --> 00:10:56,650
They can only move diagonally.

144
00:10:56,680 --> 00:11:05,440
However, knights can move in this to slash one configuration or one slash two configuration for both

145
00:11:05,440 --> 00:11:07,840
movement and for capturing.

146
00:11:08,080 --> 00:11:14,470
OK, one other thing I should note, I think, is that pawns cannot move backward, generally speaking.

147
00:11:14,860 --> 00:11:18,490
So once upon has moved forward, he cannot then back up.

148
00:11:18,880 --> 00:11:23,170
So he has to just keep moving forward or diagonally to capture an enemy.

149
00:11:23,920 --> 00:11:26,550
Knights, on the other hand, can move all over the place.

150
00:11:26,560 --> 00:11:32,590
They can go backward and forward and sideways as long as it's in their two squares and then one square

151
00:11:32,590 --> 00:11:36,070
or one square and then two square type of L pattern.

152
00:11:36,100 --> 00:11:41,290
OK, so I think that might be about enough for us to jump in to these exercises.

153
00:11:41,590 --> 00:11:41,890
All right.

154
00:11:41,890 --> 00:11:44,140
So let's jump into the code now.

155
00:11:44,170 --> 00:11:45,970
So again, fair warning.

156
00:11:45,970 --> 00:11:49,600
If you are planning to do these exercises, then you haven't done them yet.

157
00:11:49,750 --> 00:11:51,310
You should probably stop now.

158
00:11:51,460 --> 00:11:56,260
Go do the exercises and then come back here after you've done them, and I'll see you in a week or a

159
00:11:56,260 --> 00:12:00,190
month or a year, and hopefully it won't take you that long.

160
00:12:00,700 --> 00:12:01,120
All right.

161
00:12:01,630 --> 00:12:07,620
OK, so I'm going to actually start off here in the exercise guide here.

162
00:12:07,990 --> 00:12:11,860
And you see the same picture, in fact, that we were just looking at.

163
00:12:11,980 --> 00:12:18,850
So here we are in exercise eight and you'll see that I've broken it up into these sub exercises.

164
00:12:18,850 --> 00:12:21,820
So 8.1, 8.2, et cetera, et cetera.

165
00:12:21,850 --> 00:12:22,210
OK.

166
00:12:22,450 --> 00:12:27,520
So what we're going to do, I think, is just go through these exercises one at a time and see how I

167
00:12:27,550 --> 00:12:28,740
solution them.

168
00:12:29,260 --> 00:12:36,940
So starting here with exercise one, you'll need to create classes for a chessboard and a pawn, per

169
00:12:36,940 --> 00:12:45,910
the J Unit test can add PON Method Write Code to allow an instance of the -- class to be added to

170
00:12:45,910 --> 00:12:47,700
an instance of the chess board.

171
00:12:47,710 --> 00:12:55,420
Add a square on the board using chess notation such as A1, C three, etc. then assert that the PON

172
00:12:55,420 --> 00:13:03,130
is actually at that location on the board by calling a method on the board to retrieve a piece by location.

173
00:13:03,460 --> 00:13:12,250
So what I'm basically saying is write some code that lets you model a chessboard and a pawn and then

174
00:13:12,250 --> 00:13:16,930
programmatically place an instance of a pawn somewhere on the board.

175
00:13:17,170 --> 00:13:24,520
So like at D7, for example, and then ask the board, What piece is that B7?

176
00:13:24,530 --> 00:13:27,730
That way, you can make sure that you actually place the piece there.

177
00:13:27,760 --> 00:13:33,610
OK, so I know it might seem kind of trivial, but in order to do this correctly, you actually have

178
00:13:33,610 --> 00:13:35,500
to implement a number of things.

179
00:13:35,740 --> 00:13:36,130
All right.

180
00:13:36,250 --> 00:13:39,040
So that's what that exercise is asking you to do.

181
00:13:39,550 --> 00:13:39,790
All right.

182
00:13:39,790 --> 00:13:41,560
So let's go see how I did this.

183
00:13:41,890 --> 00:13:50,440
OK, so here we are in my test and I used TDD for this, though I will admit that I wasn't 120 percent

184
00:13:50,440 --> 00:13:58,690
strict in how I did TDD, but I did generally start off with a test, created classes only as I needed

185
00:13:58,690 --> 00:13:59,200
to.

186
00:13:59,530 --> 00:14:06,670
Where I wasn't so strict was that I didn't always do the cat and mouse game extensively throughout throughout

187
00:14:06,670 --> 00:14:12,520
my TDD exercise because I have a lot of coding that I have to do for you guys, and I just don't have

188
00:14:12,520 --> 00:14:16,750
the time to sit there and go through all of that while nobody's watching.

189
00:14:17,260 --> 00:14:18,490
So just being honest.

190
00:14:19,150 --> 00:14:19,570
OK.

191
00:14:19,920 --> 00:14:21,640
But you should do it correctly.

192
00:14:22,270 --> 00:14:22,690
All right.

193
00:14:22,930 --> 00:14:25,810
So here's my first test can add punch.

194
00:14:25,810 --> 00:14:31,060
So I just wrote this test and then I said, OK, I'm going to need something that represents a chessboard

195
00:14:31,390 --> 00:14:33,890
and I'm going to need something that represents upon.

196
00:14:33,910 --> 00:14:40,990
So as you know, by now, when we are dealing with modeling concepts in Java, generally speaking,

197
00:14:40,990 --> 00:14:47,890
the nouns of the domain that we are modeling for which in this case would be chess typically will become

198
00:14:47,890 --> 00:14:48,650
classes.

199
00:14:48,880 --> 00:14:49,360
So I.

200
00:14:49,680 --> 00:14:51,990
Third to a class called chessboard.

201
00:14:52,140 --> 00:14:56,760
I could have named this anything, but I thought chess board would be a good logical name.

202
00:14:56,760 --> 00:14:59,940
I could have called it bored or anything, really.

203
00:15:00,330 --> 00:15:06,120
And then I decided to name the instance of my chess board simply bored because I didn't want to have

204
00:15:06,120 --> 00:15:08,400
to type out the whole world chess board.

205
00:15:08,550 --> 00:15:10,960
And so here I am, creating that new instance.

206
00:15:10,980 --> 00:15:15,360
OK, now when I first did this, there was no real functionality here.

207
00:15:15,480 --> 00:15:20,820
All I did was simply create a class called chess board that initially at this point had nothing in it.

208
00:15:21,540 --> 00:15:24,950
Then I did the same thing for another class of pawn.

209
00:15:25,080 --> 00:15:25,440
Right?

210
00:15:25,620 --> 00:15:32,190
So this is me modeling this chess piece right here called a pawn.

211
00:15:32,520 --> 00:15:32,910
All right.

212
00:15:32,970 --> 00:15:39,390
Now, actually, a little bit later on, I didn't do this initially, but a little later on I realized

213
00:15:39,540 --> 00:15:44,310
that I would need to be able to describe what color the piece was.

214
00:15:44,490 --> 00:15:49,080
So I'm not going to talk about this too much right now, and we'll come back to that a little bit later

215
00:15:49,080 --> 00:15:50,380
when it actually comes up.

216
00:15:50,400 --> 00:15:50,820
OK.

217
00:15:51,090 --> 00:15:52,230
But I'm just pointing that out.

218
00:15:52,410 --> 00:15:52,750
All right.

219
00:15:52,770 --> 00:15:58,710
And then I envisioned that, OK, if I've got this thing called a chess board and I've got a pawn,

220
00:15:58,920 --> 00:16:03,300
I want to somehow place a pawn somewhere on this board.

221
00:16:03,570 --> 00:16:10,110
And so what I imagined was that I would have an add method where I could say, Hey, board, hey, chess

222
00:16:10,110 --> 00:16:15,920
board, let me add a pawn to you at some coordinates, OK?

223
00:16:16,170 --> 00:16:17,640
And so this is me doing that.

224
00:16:17,910 --> 00:16:24,330
I'm I referred to a method called Add, and then I passed in my pawn with a comma.

225
00:16:24,480 --> 00:16:30,450
And then a string representing the chess notation or the location on the chess board.

226
00:16:30,570 --> 00:16:37,080
So here I'm referring to Square a two, which would be here a to sit right there.

227
00:16:37,230 --> 00:16:43,500
So this would be a pawn placed right here, which would be the mirror of this pawn right here, by the

228
00:16:43,500 --> 00:16:43,770
way.

229
00:16:43,950 --> 00:16:44,340
All right.

230
00:16:44,350 --> 00:16:49,710
So I'm I'm trying to place a piece at a to a pawn at a.

231
00:16:50,580 --> 00:16:59,400
Then I turn around and I want to basically ask the board, Hey, chess board, what piece?

232
00:16:59,400 --> 00:17:03,840
What chess piece do I have at coordinates a two?

233
00:17:04,230 --> 00:17:11,460
So I imagined that I could have a method called get peace at coordinates, and I just shortened that

234
00:17:11,640 --> 00:17:12,810
to co-ords.

235
00:17:12,900 --> 00:17:13,230
Right?

236
00:17:13,440 --> 00:17:20,730
But that stands for coordinates where I could pass in some coordinates and then it would give me back

237
00:17:20,730 --> 00:17:21,930
a chess piece.

238
00:17:22,170 --> 00:17:29,430
And if I got that chess piece back, I could capture it in a variable like I'm doing here for right

239
00:17:29,430 --> 00:17:31,990
now, I'm going to ignore the fact that I'm casting it.

240
00:17:32,010 --> 00:17:34,590
We'll talk about that a little bit later as well.

241
00:17:34,650 --> 00:17:35,000
All right.

242
00:17:35,010 --> 00:17:40,020
So if there is a piece of a, I would be capturing it into this variable.

243
00:17:40,350 --> 00:17:48,360
And then finally, I would assert that the pond that I started with is equal to the pond that I got

244
00:17:48,360 --> 00:17:49,230
back right.

245
00:17:49,350 --> 00:17:55,890
So in other words, I placed upon at eight two, and then I asked the chess board, Give me whatever

246
00:17:55,890 --> 00:17:57,150
piece is that a two?

247
00:17:57,540 --> 00:18:03,480
And then I'm testing that this thing that I put at a two is the same thing that I got back from the

248
00:18:03,480 --> 00:18:05,130
chess board at a two.

249
00:18:05,190 --> 00:18:06,180
They should be equal.

250
00:18:06,390 --> 00:18:08,310
I think that should make a lot of sense, right?

251
00:18:09,030 --> 00:18:15,090
So it was easy to write the test a little bit more work to actually make it pass properly.

252
00:18:15,480 --> 00:18:17,190
So now let's dig in on that.

253
00:18:17,430 --> 00:18:19,800
We'll start here with the add method.

254
00:18:20,010 --> 00:18:22,590
So I'm going to jump into the add method now.

255
00:18:22,890 --> 00:18:29,250
So this method is taking something called a chess piece and then returning chess coordinates.

256
00:18:29,670 --> 00:18:34,140
Now you might have thought that I would be passing in something called a pawn.

257
00:18:34,410 --> 00:18:41,070
And if I recall correctly, when I actually wrote that first test, I may have actually modeled this

258
00:18:41,070 --> 00:18:42,240
to just take a pawn.

259
00:18:42,750 --> 00:18:48,030
However, I'm going to go ahead and give you a little bit of insight into something now.

260
00:18:48,660 --> 00:18:56,610
Later on, I am also going to want to call add to add in other types of pieces, namely a night.

261
00:18:57,150 --> 00:19:03,990
And if I had made this first parameter of type pawn specifically, then I wouldn't be able to use this

262
00:19:03,990 --> 00:19:07,980
same add method to also add in a night.

263
00:19:08,310 --> 00:19:15,630
I would have had to create a second add method that takes a night, and that wouldn't have been the

264
00:19:15,630 --> 00:19:22,080
most efficient way to make good use of a lot of the concepts that you should have learned in object

265
00:19:22,080 --> 00:19:28,200
orientation now, because that would mean that I'd have to create an overloaded add method for every

266
00:19:28,200 --> 00:19:31,050
different type of chess piece there is right.

267
00:19:31,320 --> 00:19:32,340
And that would.

268
00:19:32,520 --> 00:19:35,850
And honestly, that's just not necessary to do so.

269
00:19:35,850 --> 00:19:43,380
This is one of the first lessons that I wanted to force you to learn from or implement the fact that

270
00:19:43,380 --> 00:19:49,530
in order to make one method, such as ad, that could be used for different types.

271
00:19:49,600 --> 00:19:50,890
Have chess pieces.

272
00:19:51,430 --> 00:19:55,210
You probably would need to make those different chess pieces.

273
00:19:55,540 --> 00:20:01,150
All have the same interface or all have the same superclass.

274
00:20:01,660 --> 00:20:07,240
So what I did was I chose to introduce a super class called chess piece.

275
00:20:07,450 --> 00:20:14,680
This is a more generic class than pawn or as you'll see in a moment here the night.

276
00:20:15,070 --> 00:20:19,720
OK, now I'm not going to talk too much more about that right now, but I did want to go ahead and just

277
00:20:19,720 --> 00:20:25,120
explain why you're seeing this thing called chess piece and not pawn.

278
00:20:25,150 --> 00:20:32,230
OK, so you can infer from what I've just told you that my pawn class actually ends up extending another

279
00:20:32,230 --> 00:20:34,310
class called chess piece.

280
00:20:34,360 --> 00:20:34,810
OK.

281
00:20:35,200 --> 00:20:39,400
And then here we've got the chess coordinates, which are just a simple string.

282
00:20:39,670 --> 00:20:40,120
All right.

283
00:20:40,870 --> 00:20:48,790
Now, the very first thing I do in the body of this method is I take those chess coordinates and I create

284
00:20:48,790 --> 00:20:53,800
something called a coordinate or coordinates from that string.

285
00:20:54,040 --> 00:20:55,510
Now why do I do that?

286
00:20:55,840 --> 00:21:00,190
Well, if we keep going here, you'll see why in just a minute.

287
00:21:00,820 --> 00:21:05,080
So let's let's put that aside for just a minute and go to the next part.

288
00:21:05,230 --> 00:21:12,460
So the next thing I do is I say piece that set coordinates and then I pass in this coordinates thing

289
00:21:12,460 --> 00:21:12,730
here.

290
00:21:12,940 --> 00:21:20,230
So what you need to know, first off, is that this class coordinates is really just a class implementation

291
00:21:20,230 --> 00:21:22,970
of the concept of coordinates.

292
00:21:22,990 --> 00:21:23,440
OK.

293
00:21:24,280 --> 00:21:29,650
And one of the reasons I created this class was because I needed a lot of convenience.

294
00:21:30,640 --> 00:21:37,930
Over here, the most convenient way for me to refer to coordinates is really just by typing the chest

295
00:21:37,930 --> 00:21:39,250
coordinates as a string.

296
00:21:39,370 --> 00:21:40,900
That's really, really convenient.

297
00:21:41,170 --> 00:21:46,240
However, in my internal code, I sometimes need these broken apart.

298
00:21:46,480 --> 00:21:49,870
Sometimes I need to know what is the letter here?

299
00:21:49,870 --> 00:21:55,690
And by the way, I forgot to mention these rows here numbered one to three through eight one through

300
00:21:55,690 --> 00:21:56,050
eight.

301
00:21:56,260 --> 00:22:00,110
These are called ranks in chess, so these are ranks.

302
00:22:00,220 --> 00:22:08,140
Each row is a rank and then the columns a through h are called files.

303
00:22:08,170 --> 00:22:14,710
OK, so this would be file a, file B, File C and so on.

304
00:22:14,740 --> 00:22:15,070
OK.

305
00:22:15,100 --> 00:22:16,720
Files and ranks.

306
00:22:17,110 --> 00:22:21,910
So sometimes I may need to be able to determine easily in my code.

307
00:22:22,150 --> 00:22:26,170
What file are we on or what rank are we on?

308
00:22:26,500 --> 00:22:31,270
And I don't want to have to write low level code every single time.

309
00:22:31,270 --> 00:22:37,480
I need to know that where I can split the eh, apart from the three or the C, apart from the from the

310
00:22:37,540 --> 00:22:39,460
from the two or something like that.

311
00:22:39,490 --> 00:22:39,910
OK.

312
00:22:40,180 --> 00:22:46,330
And so one of the reasons that I introduced this class called coordinates is so that I would have a

313
00:22:46,330 --> 00:22:53,500
convenient place to have additional methods that that make it easy for me to split out the file from

314
00:22:53,500 --> 00:22:54,070
the rank.

315
00:22:54,130 --> 00:22:55,870
OK, so that's one of the reasons.

316
00:22:56,470 --> 00:22:56,770
All right.

317
00:22:56,770 --> 00:23:04,270
So the next thing I do on line 14, though, is that I set the coordinates on the piece.

318
00:23:04,420 --> 00:23:12,040
That is to simply say that when I'm placing a piece, when I'm adding a piece onto a particular square

319
00:23:12,040 --> 00:23:19,060
of the board, not only do I want the board to know that I put that piece on that square, I may want

320
00:23:19,060 --> 00:23:22,570
that piece to know where it is on the board as well.

321
00:23:22,750 --> 00:23:26,500
That just seems like a good intrinsic thing for the piece to know.

322
00:23:26,650 --> 00:23:31,720
And you'll see a little bit later how we actually make really good use of that knowledge, in fact being

323
00:23:31,720 --> 00:23:33,880
added into the piece itself.

324
00:23:34,150 --> 00:23:34,420
All right.

325
00:23:34,420 --> 00:23:40,630
And then finally, here and this is really, really important now I've got this thing here called internal

326
00:23:40,630 --> 00:23:41,260
board.

327
00:23:42,160 --> 00:23:48,340
And if you'll notice now this internal board is a two dimensional array.

328
00:23:49,180 --> 00:23:57,910
So what this is, is this is the internal representation that I chose to utilize for representing the

329
00:23:57,910 --> 00:23:58,750
chess board.

330
00:23:59,200 --> 00:24:06,700
I thought a good way to represent this chess board in code ultimately was to just create a two dimensional

331
00:24:06,700 --> 00:24:13,270
array because we've got here a board in two dimensions, right X and Y files and ranks.

332
00:24:13,570 --> 00:24:15,250
And it has eight.

333
00:24:15,340 --> 00:24:18,220
It's an eight by eight square matrix.

334
00:24:18,850 --> 00:24:23,920
So I chose to create an array that is eight by eight.

335
00:24:23,920 --> 00:24:31,990
And that way, I could just let each of the elements of this two dimensional array be represent each

336
00:24:31,990 --> 00:24:34,090
of the squares on the chessboard.

337
00:24:34,690 --> 00:24:43,690
So in that case, this first square here could be zero zero one zero two zero three zero zero one one

338
00:24:43,690 --> 00:24:47,740
one two one three one, et cetera, et cetera, et cetera.

339
00:24:47,770 --> 00:24:56,710
OK, now if we're going to use an internal array to actually represent what's on this chessboard and

340
00:24:56,710 --> 00:25:03,700
that array has numbers zero zero zero one, etc., etc. That would mean that we would need a way to

341
00:25:03,700 --> 00:25:13,570
translate between the chess notation, such as D four or a eight into the array coordinates, right?

342
00:25:13,600 --> 00:25:16,870
In other words, we need to have a way to translate that, for example.

343
00:25:17,470 --> 00:25:27,370
Square eight becomes location zero zero in our array, and that's another thing that we're able to do

344
00:25:27,370 --> 00:25:29,440
with this coordinate class.

345
00:25:29,650 --> 00:25:37,690
This coordinates class is containing or encapsulating the ability to do that kind of translation.

346
00:25:37,870 --> 00:25:39,640
So we're able to encapsulate that.

347
00:25:40,060 --> 00:25:47,950
So then down here, in fact, the act of me adding a chess piece to the board is actually me simply

348
00:25:47,950 --> 00:25:53,920
placing that piece at a particular element in this two dimensional array.

349
00:25:54,460 --> 00:26:03,880
And I'm able to use the coordinates class that get X method here to determine where on the x axis that

350
00:26:03,880 --> 00:26:08,530
piece would belong, according to its chess coordinates, right?

351
00:26:09,070 --> 00:26:13,210
Hopefully, this is making sense to most of you, but for the few for whom it may not be.

352
00:26:13,300 --> 00:26:15,370
Let me just say this in another way.

353
00:26:15,820 --> 00:26:23,170
If I go back over here again, so in this particular case, replacing this -- at Area A2?

354
00:26:23,200 --> 00:26:23,710
Right?

355
00:26:23,800 --> 00:26:26,590
So a two would be right here.

356
00:26:26,620 --> 00:26:29,950
However, in the array, that would be.

357
00:26:30,160 --> 00:26:41,930
Coordinates zero six zero on the x axis, because zero is the first is the first column and then the

358
00:26:42,020 --> 00:26:43,970
sixth row from the top right.

359
00:26:44,000 --> 00:26:47,720
Zero one two three four five six.

360
00:26:48,020 --> 00:26:56,900
So zero six So something needs to translate a two into zero six, and that's something is this coordinates

361
00:26:56,900 --> 00:26:57,170
here.

362
00:26:57,470 --> 00:27:04,460
And so when I call cords that get X, that in this particular case would return a zero.

363
00:27:04,790 --> 00:27:10,520
And then when I call co-ords, I get why that would return a sixth in this case.

364
00:27:11,030 --> 00:27:14,080
So let's dig in here now and see how that's working.

365
00:27:14,120 --> 00:27:18,320
So first, we'll take a look at the constructor for the coordinates.

366
00:27:19,130 --> 00:27:19,540
All right.

367
00:27:19,550 --> 00:27:24,950
So the first thing we do is just take that string of chest coordinates, which in this case would be

368
00:27:24,980 --> 00:27:29,240
a two, and we just store it in an internal field right here.

369
00:27:29,270 --> 00:27:30,980
OK, chest coordinates.

370
00:27:31,190 --> 00:27:36,380
And I just decided to do that just in case I wanted to be able to get that back out for some reason.

371
00:27:36,830 --> 00:27:42,860
Then the next thing I'm doing, though, is I get the first part of that coordinate.

372
00:27:42,860 --> 00:27:49,430
So just for reference here, let's just remember we've got in this one case and a and a two a two,

373
00:27:49,850 --> 00:27:57,870
so I can use the string method care at zero to get the very first character in this, which is the file.

374
00:27:57,890 --> 00:27:58,290
OK.

375
00:27:58,310 --> 00:28:01,790
And so I actually store that in a character called file.

376
00:28:02,330 --> 00:28:07,320
And then the next thing I do is to get the rank now to do that.

377
00:28:07,340 --> 00:28:08,180
That's a number.

378
00:28:08,180 --> 00:28:09,860
And it's always going to be a number.

379
00:28:09,890 --> 00:28:10,340
OK?

380
00:28:10,610 --> 00:28:17,000
And so the first thing I can do starting on the inside here is I can get the second character, which

381
00:28:17,000 --> 00:28:20,210
is character set at one because it's zero based.

382
00:28:20,430 --> 00:28:22,910
I get the second character, which would be a two.

383
00:28:22,940 --> 00:28:29,720
Now this care at method by default will return a character, OK, a primitive character.

384
00:28:29,730 --> 00:28:36,050
And so I want to translate that primitive character into a string, and I can do that easily by referencing

385
00:28:36,050 --> 00:28:38,600
the character class asked to string.

386
00:28:39,140 --> 00:28:39,590
OK.

387
00:28:39,800 --> 00:28:44,960
And so I'm turning this character of a two into a string of two.

388
00:28:46,010 --> 00:28:47,120
At this point.

389
00:28:48,240 --> 00:28:56,870
And then I can turn that string of a two into an actual number or an integer two by using integer that

390
00:28:56,940 --> 00:28:57,840
pass int.

391
00:28:58,930 --> 00:29:04,270
And then I can store that inside of this variable called rank of type integer, so now I've got the

392
00:29:04,270 --> 00:29:06,670
file and I've got the rank.

393
00:29:07,000 --> 00:29:18,190
Then finally, here I'm able to translate the file into an Array X coordinate and the rank into an Array

394
00:29:18,220 --> 00:29:19,420
Y coordinate.

395
00:29:19,630 --> 00:29:25,690
And I do that using these two methods here get X for file, get y for rank.

396
00:29:26,230 --> 00:29:30,970
And so let's jump into this method get X for file and see what I'm doing here.

397
00:29:31,090 --> 00:29:37,060
Now, this should look familiar to you because these are somewhat based on some of the earlier exercises

398
00:29:37,060 --> 00:29:38,330
that I had you doing here.

399
00:29:38,350 --> 00:29:38,740
Right?

400
00:29:38,920 --> 00:29:41,140
Let me see, where are those exercises?

401
00:29:41,260 --> 00:29:44,290
Yeah, this one right here exercise for, I think, right?

402
00:29:44,290 --> 00:29:47,590
A method that takes an input of one lowercase letter.

403
00:29:47,620 --> 00:29:54,580
Only one letter like a through A, B, C or Z, et cetera, and returns that letters ordinal position

404
00:29:54,580 --> 00:29:59,350
in the alphabet, i.e. a one or a two or three.

405
00:29:59,380 --> 00:29:59,710
OK.

406
00:29:59,950 --> 00:30:00,760
So basic.

407
00:30:00,770 --> 00:30:08,110
And I asked you to try to do this without using any conditionals because you can do it mathematically

408
00:30:08,410 --> 00:30:12,130
and without using an array, which would also not be necessary here.

409
00:30:12,400 --> 00:30:18,700
So if you were able to do this, then you should have a pretty good idea of how you can generally translate

410
00:30:19,120 --> 00:30:22,330
a character into a number of any kind.

411
00:30:22,330 --> 00:30:28,030
As long as the numerical pattern is sequential as the character patterns are OK.

412
00:30:28,270 --> 00:30:33,970
And then we had a similar problem down here as well, where I said Translate an aide into a zero and

413
00:30:33,970 --> 00:30:39,700
a seven and to a one, I was preparing you for all of the basic skills that you would need to be able

414
00:30:39,700 --> 00:30:42,220
to do what we're doing now on the chessboard.

415
00:30:42,670 --> 00:30:43,000
OK.

416
00:30:43,030 --> 00:30:44,260
So quick reminder there.

417
00:30:44,500 --> 00:30:45,730
OK, so down here.

418
00:30:45,760 --> 00:30:47,230
Get X for file.

419
00:30:47,530 --> 00:30:51,700
So we get a file, which in this case is an A.

420
00:30:52,090 --> 00:30:55,720
And to turn that into what it should be, let's look at this here.

421
00:30:55,720 --> 00:31:04,640
So we want an a to give us a zero because that is the first column into our array.

422
00:31:04,660 --> 00:31:07,630
OK, so we want an a to give us a zero.

423
00:31:07,930 --> 00:31:15,940
So the way we can do that is simply to take the character of file and subtract 97 from it.

424
00:31:16,030 --> 00:31:22,060
Now, if you remember from the numbers, section or module in this course, you learned that primitive

425
00:31:22,060 --> 00:31:28,390
characters are really the same thing as an integer, except that integers have negative and positive

426
00:31:28,390 --> 00:31:34,580
numbers, whereas characters are all positive because negative numbers don't make any sense for a character.

427
00:31:34,690 --> 00:31:37,750
That's pretty much the only difference in Java.

428
00:31:38,380 --> 00:31:45,040
And so we can actually do math on characters, and I think we did that in the numbers section, in fact.

429
00:31:45,460 --> 00:31:53,150
So I happen to know that a lowercase a has a numerical value of ninety seven.

430
00:31:53,170 --> 00:32:01,000
And therefore, if I take that lowercase a minus 97, then that will give me a zero, and that's exactly

431
00:32:01,000 --> 00:32:01,660
what I want.

432
00:32:01,810 --> 00:32:07,630
And then if I pass in a B, which would have a sequential logical value of ninety eight, lowercase

433
00:32:07,630 --> 00:32:13,350
B would have a value of ninety eight, then ninety eight minus ninety seven would give me a one.

434
00:32:13,360 --> 00:32:15,970
And that's exactly the pattern that I would want here, right?

435
00:32:16,270 --> 00:32:19,160
Zero one two three.

436
00:32:19,180 --> 00:32:20,290
So on and so forth.

437
00:32:20,470 --> 00:32:21,970
So that works out perfectly.

438
00:32:22,300 --> 00:32:22,660
All right.

439
00:32:22,960 --> 00:32:33,730
So that's how we can translate the file into an X coordinate for our array look up and then for getting

440
00:32:33,730 --> 00:32:36,280
the Y coordinate for our array.

441
00:32:36,460 --> 00:32:38,620
That's similarly easy as well.

442
00:32:38,770 --> 00:32:44,920
In that case, we just take eight minus whatever the rank is, and that gives us the value that we want.

443
00:32:44,920 --> 00:32:51,010
Then again, this should have been something that you may have worked out in the exercises prior to

444
00:32:51,040 --> 00:32:52,080
exercise eight.

445
00:32:52,180 --> 00:32:55,900
So that's how we are able to get our array coordinates.

446
00:32:56,110 --> 00:32:56,470
All right.

447
00:32:56,680 --> 00:33:01,720
So now we can jump back over to the chessboard implementation for the add method.

448
00:33:02,020 --> 00:33:11,800
And so now, armed with our actual array coordinates of zero and six, we are now able to simply put

449
00:33:12,010 --> 00:33:18,670
this chess piece inside of that particular element of this two dimensional array.

450
00:33:18,850 --> 00:33:20,500
And that's what I'm doing right here.

451
00:33:20,530 --> 00:33:20,960
OK.

452
00:33:20,980 --> 00:33:23,530
And now we're done with the add method.

453
00:33:23,590 --> 00:33:28,240
OK, so then we simply need to turn around and then look up.

454
00:33:28,240 --> 00:33:35,470
Whatever piece we have at chess coordinates a two with this method, get peace at coordinates.

455
00:33:35,650 --> 00:33:38,170
So let's see how this method is implemented.

456
00:33:39,730 --> 00:33:45,880
So again, we take an input of a string of chess coordinates, and the very first thing I do now is

457
00:33:45,880 --> 00:33:52,900
I just convert that string back into actual coordinates because this coordinate method does a lot of

458
00:33:52,900 --> 00:33:59,660
really useful things like giving us these X and Y coordinates from the chest, from the chest notation.

459
00:33:59,680 --> 00:34:00,090
OK.

460
00:34:01,150 --> 00:34:08,350
And so now you see me just using this same approach again that I just used up here, except instead

461
00:34:08,350 --> 00:34:12,700
of putting something inside of an element of this two dimensional array.

462
00:34:12,880 --> 00:34:20,080
Now I'm simply reading whatever may be in that two dimensional array at that element instead.

463
00:34:20,200 --> 00:34:25,930
OK, so it's the same code just used kind of in the other direction, essentially.

464
00:34:26,380 --> 00:34:33,910
And so that will return whatever object I placed in that element, which in this case would be the pawn

465
00:34:33,910 --> 00:34:35,110
that we had up here.

466
00:34:35,110 --> 00:34:36,400
And then I simply return it.

467
00:34:36,550 --> 00:34:43,240
Now, if we had not placed any object in this array at that location, I would have just gotten back

468
00:34:43,240 --> 00:34:44,830
a null, by the way.

469
00:34:44,880 --> 00:34:51,520
OK, and now note that this method is coded to return something of type chess piece.

470
00:34:51,640 --> 00:34:58,990
And so if I want this piece to be treated as an actual pawn, I need to cast it now.

471
00:34:58,990 --> 00:35:01,150
Honestly, I didn't actually need to do this at all.

472
00:35:01,300 --> 00:35:06,070
This method, a third equals this assertion would have worked even without the cast that I did here.

473
00:35:06,460 --> 00:35:12,610
I did this originally because I didn't want anyone who was looking at this code to be overly confused

474
00:35:12,850 --> 00:35:17,110
by seeing something of Typekit chess piece coming out of here directly.

475
00:35:17,110 --> 00:35:22,990
But now that I'm explaining it to you in real time, it's a lot less important that I'm casting this.

476
00:35:23,000 --> 00:35:26,360
So this casting is not necessary whatsoever.

477
00:35:26,380 --> 00:35:31,750
I just did it just to make things a little more straightforward so that so that it would be more symmetrical.

478
00:35:31,840 --> 00:35:33,880
You know, we're creating a pawn up here.

479
00:35:34,180 --> 00:35:40,390
I thought it would be nice for you to see a pawn coming out of here and then the equals is being applied,

480
00:35:40,390 --> 00:35:45,910
in which case these are the same object in memory, and therefore they absolutely will be equal to each

481
00:35:45,910 --> 00:35:46,210
other.

482
00:35:46,270 --> 00:35:46,630
All right.

483
00:35:46,960 --> 00:35:52,360
So that's a full explanation for this first exercise or first sub exercise.

484
00:35:52,360 --> 00:35:56,380
And honestly, like I said, I didn't know how long it was going to take me to explain all of these

485
00:35:56,380 --> 00:35:56,710
things.

486
00:35:56,890 --> 00:36:00,760
I thought I might have gotten through a few more exercises than this, but apparently not.

487
00:36:00,940 --> 00:36:06,760
So I'm going to go ahead and stop right here, and we'll pick back up with the next exercise, which

488
00:36:06,760 --> 00:36:09,520
should go quicker because it's pretty much the same thing.

489
00:36:09,550 --> 00:36:11,740
OK, so I'll see you in the next lesson.
