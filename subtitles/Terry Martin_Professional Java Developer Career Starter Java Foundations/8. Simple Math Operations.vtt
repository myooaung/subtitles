WEBVTT
1
00:00:00.900 --> 00:00:05.280
All right, now, let's jump in to doing some basic math with Java.

2
00:00:05.490 --> 00:00:12.750
So what we can do, first of all, is let's create another class just to have a clean slate.

3
00:00:14.000 --> 00:00:17.210
And so I'm going to create a new class under the source folder.

4
00:00:19.120 --> 00:00:21.410
And with did I call the other one?

5
00:00:21.430 --> 00:00:22.750
No stuff, I don't know.

6
00:00:22.930 --> 00:00:25.120
Call this one man -- stuff.

7
00:00:25.750 --> 00:00:26.270
All right.

8
00:00:26.290 --> 00:00:28.690
And again, we'll do a public static void.

9
00:00:28.690 --> 00:00:29.350
Main.

10
00:00:30.220 --> 00:00:30.790
All right.

11
00:00:30.940 --> 00:00:37.180
So the first thing we can do is just print out the results of some really simple math.

12
00:00:37.210 --> 00:00:38.590
Let's let's try that first.

13
00:00:38.600 --> 00:00:41.710
So we'll do a system that out with a duty.

14
00:00:42.190 --> 00:00:47.020
And probably the simplest thing we could do is just add two numbers together.

15
00:00:47.020 --> 00:00:51.520
So let's add three plus five, just like that.

16
00:00:51.730 --> 00:00:53.650
And let's run this cool.

17
00:00:53.680 --> 00:00:54.040
All right.

18
00:00:55.020 --> 00:00:55.920
Really straightforward.

19
00:00:56.220 --> 00:01:01.560
Now we can keep stringing more things together here, like so.

20
00:01:03.070 --> 00:01:06.370
And the compiler will figure out what to do with all of that.

21
00:01:06.730 --> 00:01:07.330
There we go.

22
00:01:07.390 --> 00:01:09.070
OK, so there you go.

23
00:01:09.220 --> 00:01:09.470
All right.

24
00:01:09.490 --> 00:01:10.630
We're done with Java math.

25
00:01:10.990 --> 00:01:11.680
No, I'm kidding.

26
00:01:12.010 --> 00:01:12.640
All right.

27
00:01:13.980 --> 00:01:20.730
So that's addition we can do subtraction, of course, 10 minus seven.

28
00:01:22.340 --> 00:01:22.730
All right.

29
00:01:23.780 --> 00:01:26.940
Now, of course, these are all in terms of algebra.

30
00:01:26.990 --> 00:01:32.090
These are all integers that we're working with right now, but we can work with the other data types

31
00:01:32.090 --> 00:01:33.920
as well, and we'll see that in a moment.

32
00:01:34.340 --> 00:01:40.610
I mentioned these are all integers, though, because we can also work with negative numbers so we could

33
00:01:40.610 --> 00:01:43.130
do seven minus 10, for example.

34
00:01:44.350 --> 00:01:45.670
Here we go negative three.

35
00:01:46.000 --> 00:01:52.330
OK, so that's not a problem for Java, and we can mix and match as well.

36
00:01:56.020 --> 00:01:56.490
All right.

37
00:01:56.530 --> 00:01:57.760
So let's run that.

38
00:01:58.480 --> 00:01:58.720
All right.

39
00:01:58.750 --> 00:02:00.240
Negative nine we get.

40
00:02:00.850 --> 00:02:07.120
Now you may be wondering what's the order in which it's grouping things together for subtraction and

41
00:02:07.120 --> 00:02:07.660
addition?

42
00:02:07.660 --> 00:02:09.910
It goes in order from left to right.

43
00:02:09.940 --> 00:02:17.500
So this would have been seven minus 10, which would yield might which would yield negative three plus

44
00:02:17.500 --> 00:02:21.990
three, which is zero and then zero minus nine, would yield negative nine.

45
00:02:22.000 --> 00:02:23.380
So that's how it got that.

46
00:02:23.470 --> 00:02:23.950
OK.

47
00:02:24.180 --> 00:02:24.500
Four.

48
00:02:24.500 --> 00:02:30.370
For addition and subtraction, it just goes left to right, and addition and subtraction are both of

49
00:02:30.370 --> 00:02:32.440
equal precedence, if you will.

50
00:02:32.680 --> 00:02:33.270
OK.

51
00:02:33.520 --> 00:02:36.010
Let's look at multiplication.

52
00:02:36.670 --> 00:02:39.250
So let's do seven times.

53
00:02:39.250 --> 00:02:39.970
Four.

54
00:02:40.720 --> 00:02:45.010
So we use the asterisk for multiplication.

55
00:02:45.100 --> 00:02:47.110
And I'm sorry, I failed to mention.

56
00:02:47.350 --> 00:02:50.740
I mean, obviously we were using plus and minus, right?

57
00:02:50.770 --> 00:02:52.150
That was pretty straightforward.

58
00:02:52.390 --> 00:02:57.070
Multiplication might be a little less obvious, though, if you're brand new to any kind of programming

59
00:02:57.070 --> 00:02:57.330
at all.

60
00:02:57.340 --> 00:03:00.940
So for multiplication, we use the asterisk symbol.

61
00:03:01.090 --> 00:03:02.650
So this is seven times four.

62
00:03:02.860 --> 00:03:07.000
So if we run this, we get the predictable 28.

63
00:03:07.270 --> 00:03:13.540
And just as in real life with multiplication, the order of these two numbers doesn't matter seven times

64
00:03:13.540 --> 00:03:16.510
four or four times seven going to going to give you the same thing.

65
00:03:17.650 --> 00:03:20.680
OK, and so of course, we can do division as well.

66
00:03:20.710 --> 00:03:25.240
We'll start off with something easy, like eight divided by four.

67
00:03:25.540 --> 00:03:27.160
Let's run this.

68
00:03:28.270 --> 00:03:35.970
OK, so obviously that's two, by the way, so the division symbol is a forward slash, which is this

69
00:03:35.980 --> 00:03:36.930
this thing right here?

70
00:03:36.940 --> 00:03:37.730
Forward slash?

71
00:03:37.960 --> 00:03:41.980
Not to be confused by a backslash.

72
00:03:42.190 --> 00:03:42.700
OK.

73
00:03:44.960 --> 00:03:46.310
So not that one.

74
00:03:47.630 --> 00:03:48.440
This one.

75
00:03:51.110 --> 00:03:52.370
All right, let's see.

76
00:03:52.400 --> 00:03:59.330
And although it's a little bit weirder to see, we could string a few of these together, I suppose.

77
00:04:02.390 --> 00:04:03.530
Something like that.

78
00:04:05.030 --> 00:04:11.060
We'll run that, OK, so still just to add the order of precedence for this.

79
00:04:11.180 --> 00:04:14.150
Well, here I'm not mixing other operations, right?

80
00:04:14.150 --> 00:04:16.220
So it's just going to go from left to right.

81
00:04:16.220 --> 00:04:20.180
So 64 divided by eight is eight, then eight divided by Force two.

82
00:04:20.630 --> 00:04:21.030
All right.

83
00:04:21.050 --> 00:04:33.170
And then you can also mix the operations so we could do eight groups eight times eight divided by blah

84
00:04:33.170 --> 00:04:33.830
blah blah, right?

85
00:04:34.280 --> 00:04:35.060
Let's run that.

86
00:04:36.640 --> 00:04:43.930
Still, to because multiplication and division are on the same level of precedence or order, so in

87
00:04:43.930 --> 00:04:46.810
this particular case, you're still just going left to right.

88
00:04:47.000 --> 00:04:52.660
So eight times eight is 64, divided by eight is eight, divided by four is two.

89
00:04:52.810 --> 00:05:00.010
OK, let's see what happens if we do some division problems that don't yield whole numbers.

90
00:05:00.550 --> 00:05:03.860
So let's do something like seven divided by four, by the way.

91
00:05:03.880 --> 00:05:07.240
As usual, these spaces here are not required.

92
00:05:07.330 --> 00:05:09.400
I just put them there for readability.

93
00:05:09.430 --> 00:05:13.150
I think it looks a little easier to read with a little bit of space there.

94
00:05:13.330 --> 00:05:13.540
All right.

95
00:05:13.540 --> 00:05:15.880
So we'll do seven divided by four.

96
00:05:16.210 --> 00:05:21.700
And we're going to obviously, you know, putting this directly in the system that out that print line.

97
00:05:21.700 --> 00:05:23.590
So let's run that and see what we get.

98
00:05:24.580 --> 00:05:29.770
OK, so that's kind of interesting, and probably not what you might have expected.

99
00:05:29.800 --> 00:05:31.060
We just got a one.

100
00:05:31.390 --> 00:05:33.130
Why did we get a one?

101
00:05:33.940 --> 00:05:41.830
Well, the reason we got a one is because by default, these numbers that we're specifying here, if

102
00:05:41.830 --> 00:05:50.410
they don't have a decimal point in them as these do not, then java's default number type will be integer.

103
00:05:50.590 --> 00:06:00.760
OK, well, and in this particular case, since both numbers are integers, the result will be an integer

104
00:06:00.760 --> 00:06:01.570
as well.

105
00:06:01.630 --> 00:06:02.140
OK.

106
00:06:02.500 --> 00:06:07.030
So four does not go into seven evenly, obviously, right?

107
00:06:07.270 --> 00:06:11.440
In fact, four cannot even go into seven two times.

108
00:06:11.530 --> 00:06:16.690
It can only go into seven one time and then you'll have some remainder or some fractional part.

109
00:06:16.870 --> 00:06:19.790
But integers cannot handle fractions, right?

110
00:06:19.810 --> 00:06:23.320
You can't do decimal points or anything like that with an integer.

111
00:06:23.410 --> 00:06:25.750
Both algebraically and in Java.

112
00:06:25.990 --> 00:06:31.120
And so what ends up happening is that that fractional part just just gets thrown off.

113
00:06:31.450 --> 00:06:37.240
And so you're left with just the whole number part, which is just a one, right?

114
00:06:38.130 --> 00:06:40.230
And so that's why we're getting a one here.

115
00:06:40.890 --> 00:06:50.130
Now, if we wanted to get a more correct answer, we would have to tell Jarvis somehow to give us more

116
00:06:50.130 --> 00:06:51.030
than an integer.

117
00:06:51.300 --> 00:06:53.820
And there are multiple ways to do this.

118
00:06:54.030 --> 00:07:01.980
So first off, the simplest way perhaps to do this is to tell Java that we want the answer back in something

119
00:07:01.980 --> 00:07:03.990
other than an integer.

120
00:07:04.290 --> 00:07:11.880
So first off, we must consider what is another numerical type that is capable of giving us fractional

121
00:07:11.880 --> 00:07:13.350
or decimal answers, right?

122
00:07:13.590 --> 00:07:21.330
So if we go back over to the spreadsheet and zoom back out a little bit, we'll look over here again

123
00:07:21.660 --> 00:07:26.070
and we learned about float and double, right?

124
00:07:26.190 --> 00:07:34.620
And I said that by default in Java, if you don't specify but you use a decimal point, then the default

125
00:07:34.620 --> 00:07:36.240
numerical type will be double.

126
00:07:36.600 --> 00:07:40.800
So if you don't use a decimal point, the default type will be integer.

127
00:07:41.070 --> 00:07:45.810
If you do use decimals, though, then the default type will be double.

128
00:07:45.960 --> 00:07:52.830
So let's see what we can do to get a more meaningful answer out out of the seven divided by four.

129
00:07:53.100 --> 00:07:55.890
So there are actually a few ways we could do this.

130
00:07:56.130 --> 00:08:01.250
One thing we can do is what's called casting where we tell Java.

131
00:08:01.260 --> 00:08:09.000
Yeah, I know that I entered two integers here, but pretend like they're some other type, like a float

132
00:08:09.000 --> 00:08:09.720
or a double.

133
00:08:09.750 --> 00:08:15.720
Maybe one of the simplest ways is to pick one of these numbers, and it probably makes a little more

134
00:08:15.720 --> 00:08:24.180
sense in a division problem to pick the larger number, perhaps and put an f behind it to tell Java

135
00:08:24.190 --> 00:08:27.840
that that's a floating point number and not an integer.

136
00:08:27.870 --> 00:08:28.260
OK.

137
00:08:28.380 --> 00:08:30.150
So let's see what happens when we do this.

138
00:08:30.390 --> 00:08:31.590
I'll run this again.

139
00:08:32.250 --> 00:08:35.220
Yeah, look at that now we get one point seventy five.

140
00:08:35.250 --> 00:08:35.700
OK.

141
00:08:36.480 --> 00:08:44.280
So the basic rule of thumb in Java, when determining how it will handle calculations of this sort is

142
00:08:44.280 --> 00:08:54.720
to know that Java will look at the level of precision of, in this case, these two numbers and whichever

143
00:08:54.720 --> 00:09:03.480
number has the higher level of precision that will determine what the data type will be for the result.

144
00:09:03.840 --> 00:09:06.300
So in other words, here we have these two numbers.

145
00:09:06.300 --> 00:09:12.680
One is a float, one is an integer float is capable of having a higher level of precision.

146
00:09:12.690 --> 00:09:20.130
Or rather, it is capable of expressing more in terms of fractional units or decimal places than an

147
00:09:20.130 --> 00:09:20.850
integer.

148
00:09:21.060 --> 00:09:25.500
And so the result will be a float by default.

149
00:09:26.160 --> 00:09:32.880
Now I could also have put this f here more run that we should get the same thing.

150
00:09:33.510 --> 00:09:33.810
Yeah.

151
00:09:33.810 --> 00:09:39.600
So we get the same thing here because again, the rule is that Java's going to look at the different

152
00:09:39.600 --> 00:09:43.890
types and it's going to see, Oh, well, one of them is a float, and that's more precise for what

153
00:09:43.890 --> 00:09:45.480
we're doing, at least then.

154
00:09:45.490 --> 00:09:49.020
And so therefore the result needs to be a float.

155
00:09:49.740 --> 00:09:52.800
So that's one way we could force this.

156
00:09:53.130 --> 00:10:01.260
Another way is by doing something called casting, where we tell Java to treat one of these integers

157
00:10:01.260 --> 00:10:05.040
as as if it were something with higher precision.

158
00:10:05.040 --> 00:10:10.560
And the way we do that is with parentheses so we can put parentheses here and then say something like

159
00:10:11.010 --> 00:10:13.990
double and then close parentheses.

160
00:10:14.010 --> 00:10:22.230
OK, so now we're we're telling Java, even though this seven is actually an integer kind of like internally,

161
00:10:22.230 --> 00:10:24.900
I want you to convert it to being a double.

162
00:10:24.900 --> 00:10:30.450
And then the previous rule will kick in after that, which is that OK, this will now be treated as

163
00:10:30.450 --> 00:10:35.550
though it were a double, which means that the response will also be a double.

164
00:10:36.240 --> 00:10:37.230
So let's run that.

165
00:10:38.720 --> 00:10:39.590
There we go again.

166
00:10:39.800 --> 00:10:42.170
And of course, I also could have made this a float.

167
00:10:43.680 --> 00:10:47.040
Just the same right, except less precision than a double.

168
00:10:48.380 --> 00:10:49.100
And.

169
00:10:50.710 --> 00:10:55.390
I could have cast the four to a float or a double.

170
00:10:55.750 --> 00:10:56.590
Just the same.

171
00:10:57.660 --> 00:10:58.070
OK.

172
00:10:59.190 --> 00:10:59.880
Or double?

173
00:11:02.360 --> 00:11:10.820
OK, now some of the smarty pants out there might be wondering what would happen if we grouped the whole

174
00:11:10.820 --> 00:11:17.210
entire math problem seven divided by four into parentheses like this.

175
00:11:17.540 --> 00:11:21.980
And then we tried to cast the whole entire thing, right?

176
00:11:21.980 --> 00:11:26.150
So we did something like double, for example, right?

177
00:11:26.690 --> 00:11:28.520
Let's see what what this yields.

178
00:11:30.510 --> 00:11:34.200
Oh, isn't that interesting now we get a one point zero.

179
00:11:34.530 --> 00:11:35.670
Now why is that?

180
00:11:36.240 --> 00:11:42.960
Well, the reason we get a one point zero is because what's happening here is that first, the integer

181
00:11:42.960 --> 00:11:46.800
math is happening inside of these parentheses seven divided by four.

182
00:11:46.830 --> 00:11:50.510
These are still just integers inside of these parentheses here.

183
00:11:50.750 --> 00:11:53.520
Well, I'll highlight exactly what I'm referring to, right?

184
00:11:53.850 --> 00:11:57.450
So the seven divided by four, the seven is an integer, the four is an integer.

185
00:11:57.690 --> 00:12:02.850
And therefore the result of this is going to be an integer, which is going to be one.

186
00:12:03.060 --> 00:12:12.060
And only after this evaluates to a one will then be cast to a double, so one will be cast to a double,

187
00:12:12.270 --> 00:12:13.820
which would just be still.

188
00:12:13.830 --> 00:12:15.900
One is just going to be 1.0.

189
00:12:16.080 --> 00:12:17.670
And that's what we get down here.

190
00:12:17.670 --> 00:12:19.710
A 1.0, so nice try.

191
00:12:19.710 --> 00:12:24.180
If anybody was thinking that, that would be a way that you could get the same level of precision.

192
00:12:24.180 --> 00:12:26.160
But no, it does not work like that.

193
00:12:26.190 --> 00:12:32.010
OK, now let's introduce some variables to do the same things.

194
00:12:32.220 --> 00:12:39.810
So here will I'll undo this and I'm going to extract out a couple of variables.

195
00:12:39.810 --> 00:12:47.760
I suppose I'm going to do a command option fee to extract the variable, and I'll just call this number

196
00:12:47.760 --> 00:12:51.150
one and then I'll do the same thing for the four.

197
00:12:52.880 --> 00:12:56.990
Command option, the or control all TV.

198
00:12:57.290 --> 00:12:59.120
And I will call this one, too.

199
00:13:00.170 --> 00:13:07.280
Now notice by default, the IED extracts these out as integers because that is the default data type

200
00:13:07.280 --> 00:13:09.260
if there is no decimal here.

201
00:13:09.380 --> 00:13:11.960
In fact, let me undo one of these.

202
00:13:12.050 --> 00:13:18.650
And let's see what happens if we make this a 4.0 and then we extract a variable from that.

203
00:13:18.980 --> 00:13:23.810
OK, so then it defaults to double, just as I said earlier, OK?

204
00:13:24.320 --> 00:13:25.910
So I just wanted to show that.

205
00:13:27.680 --> 00:13:28.020
All right.

206
00:13:28.040 --> 00:13:28.700
So anyway.

207
00:13:31.060 --> 00:13:32.170
Numb to.

208
00:13:33.550 --> 00:13:34.030
All right.

209
00:13:35.480 --> 00:13:41.990
So now we can do the same things that we did before, except a little more straightforwardly now, we

210
00:13:41.990 --> 00:13:47.390
could just change these to different types like I could make that a double.

211
00:13:48.490 --> 00:13:53.260
I could make this a float, right, just like that.

212
00:13:53.590 --> 00:13:58.320
And now between a double and a float, if we were to do this, what would be the data type of the result

213
00:13:58.330 --> 00:14:00.640
if we did double divided by float?

214
00:14:00.910 --> 00:14:02.530
I'll give you a second to think about it.

215
00:14:04.070 --> 00:14:11.000
OK, so let's go back over to the spreadsheet and see which one offers the higher level of precision.

216
00:14:11.210 --> 00:14:17.530
So here's float, which is, you know, zoom out a little bit 32 bit.

217
00:14:17.720 --> 00:14:18.110
Right?

218
00:14:19.940 --> 00:14:24.170
And then double is double that, so 64 bit.

219
00:14:25.540 --> 00:14:34.810
So double is higher precision than float, and therefore the result of a double divided by a float would

220
00:14:34.810 --> 00:14:36.040
result in a double.

221
00:14:36.550 --> 00:14:36.970
OK.

222
00:14:37.780 --> 00:14:38.080
All right.

223
00:14:38.080 --> 00:14:45.880
So now let's look at a little bit more advanced concepts with doing math in Java, where we look at

224
00:14:45.880 --> 00:14:47.440
the order of operations.

225
00:14:47.440 --> 00:14:53.920
And that just means like if you have a math problem in Java or an equation or something that mixes different

226
00:14:53.920 --> 00:14:59.560
kinds of operations and operation means addition, subtraction, multiplication, division, et cetera,

227
00:14:59.560 --> 00:15:00.210
et cetera.

228
00:15:00.220 --> 00:15:02.410
In what order will they all be done?

229
00:15:02.410 --> 00:15:05.170
Because they won't always just go from left to right?

230
00:15:05.170 --> 00:15:08.950
Some operations take precedence over other operations.

231
00:15:09.220 --> 00:15:10.780
So let me show you what I mean here.

232
00:15:10.780 --> 00:15:16.210
I guess I'm going to delete these two and we'll just reuse this little area here.

233
00:15:16.210 --> 00:15:21.850
And let's do a problem like two plus three times five.

234
00:15:22.060 --> 00:15:22.570
OK.

235
00:15:23.290 --> 00:15:25.240
So what do you think the answer is going to be?

236
00:15:25.270 --> 00:15:28.720
I'll give you a second to think about this and then we'll run it and see.

237
00:15:29.830 --> 00:15:30.190
OK.

238
00:15:30.520 --> 00:15:31.960
Do you have your answer?

239
00:15:32.290 --> 00:15:33.730
All right, let's run it and see.

240
00:15:35.400 --> 00:15:40.260
OK, we got 17, if you thought it was going to be 25.

241
00:15:40.530 --> 00:15:43.920
Nice try, but I will explain what happened here.

242
00:15:44.340 --> 00:15:54.060
So in the order of operations, multiplication and division take higher priority over addition and subtraction.

243
00:15:54.540 --> 00:15:59.340
And so in this particular problem, two plus three times five.

244
00:15:59.340 --> 00:16:07.410
The compiler the thing that translates our Java code into machine code scans this equation, and it

245
00:16:07.410 --> 00:16:10.020
sees that we have multiplication and we have that addition.

246
00:16:10.020 --> 00:16:15.930
And so it decides, well, multiplication has to be done before the addition, and it needs two things

247
00:16:15.930 --> 00:16:16.740
to multiply.

248
00:16:16.770 --> 00:16:20.760
So it's going to take the three and the five and multiply those and get 15.

249
00:16:21.150 --> 00:16:25.500
Only after it's done doing that multiplication will it then do some addition.

250
00:16:25.710 --> 00:16:28.710
It will do the addition with the result of the multiplication.

251
00:16:28.710 --> 00:16:32.300
So then it will become two plus 15.

252
00:16:32.760 --> 00:16:38.850
This is equivalent to grouping these up for those of you who have ever had algebra or pre-algebra,

253
00:16:38.860 --> 00:16:39.210
right?

254
00:16:39.390 --> 00:16:40.320
This might help.

255
00:16:40.590 --> 00:16:45.060
This is what's actually happening three times five, 15 plus two.

256
00:16:45.090 --> 00:16:46.560
That's that's how that's going.

257
00:16:46.980 --> 00:16:51.600
And so it wouldn't have mattered if we had had it written this way or.

258
00:16:53.230 --> 00:16:56.560
Five times, three plus two.

259
00:16:56.710 --> 00:17:02.440
You'd still have gotten the same result because multiplication will occur before addition.

260
00:17:02.680 --> 00:17:08.350
Let me also state that most of the math stuff that I'm showing here a good deal of the math, things

261
00:17:08.350 --> 00:17:13.660
that I'm showing in this entire section, not just this one lesson, but in the entire math section

262
00:17:13.660 --> 00:17:19.300
here is fairly universal to most programming languages.

263
00:17:19.390 --> 00:17:25.270
The fact that you've got integers and floats and doubles then and the fact that multiplication and division

264
00:17:25.270 --> 00:17:28.300
will take precedence over addition and subtraction.

265
00:17:28.300 --> 00:17:34.660
These are longstanding standards of most programming languages, if not all in the world.

266
00:17:34.750 --> 00:17:41.110
Programming languages have been following these general rules, probably for at least 50 years, maybe

267
00:17:41.110 --> 00:17:41.800
even longer.

268
00:17:41.830 --> 00:17:51.730
OK, now if we don't want the normal order of operations to take precedent, we can override it by using

269
00:17:51.730 --> 00:17:52.480
parentheses.

270
00:17:52.490 --> 00:18:00.520
So if we don't want the five times three to happen first, we can put parentheses around the parts that

271
00:18:00.520 --> 00:18:05.410
we want to have happen, not necessarily first, but atomically or, you know, together, right?

272
00:18:05.420 --> 00:18:10.390
So we want to make sure that the three plus two happens and then the multiplication.

273
00:18:10.540 --> 00:18:17.920
So now if we do this now we get to 25 that some of you might have expected because we're forcing three

274
00:18:17.920 --> 00:18:23.050
point three plus two to be done before the multiplication times five can be done.

275
00:18:23.470 --> 00:18:26.830
And then, you know, you can you can keep going with this as well.

276
00:18:26.830 --> 00:18:31.780
So we could do divided by just making up anything now.

277
00:18:32.410 --> 00:18:32.970
10.

278
00:18:33.160 --> 00:18:36.460
And if you wanted to, you could even group that all up.

279
00:18:39.840 --> 00:18:41.130
Like so right.

280
00:18:41.610 --> 00:18:49.320
So you can you can make some pretty long problems there that more or less resemble some algebraic equation

281
00:18:49.320 --> 00:18:50.490
or something of that sort.

282
00:18:50.550 --> 00:18:55.080
But keep in mind, currently I'm specifying integers here.

283
00:18:55.410 --> 00:19:01.680
And so if I want more accuracy in my results, I may have to keep that in mind.

284
00:19:01.860 --> 00:19:07.500
Maybe I want to, you know, tell Java explicitly that these are doubles or floats.

285
00:19:07.500 --> 00:19:09.810
By the way, I can put a d behind here.

286
00:19:09.810 --> 00:19:15.750
I didn't tell you this before, because by default, if I just put a decimal point, they'd be doubles

287
00:19:15.750 --> 00:19:16.040
anyway.

288
00:19:16.050 --> 00:19:24.030
But I can also tell Java to make to treat these numbers as as doubles by putting a D behind them just

289
00:19:24.030 --> 00:19:26.070
as I can put an f behind them.

290
00:19:26.100 --> 00:19:26.520
OK.

291
00:19:26.640 --> 00:19:28.470
And so I get a two point five.

292
00:19:29.040 --> 00:19:29.430
OK.

293
00:19:29.460 --> 00:19:36.270
There's one more basic operation that I would like you to be aware of, and I think I even showed it

294
00:19:36.270 --> 00:19:40.470
in one of the earliest like introduction videos for the entire course.

295
00:19:40.710 --> 00:19:46.590
And that is called modulo and modulo is represented by the percent sign.

296
00:19:47.130 --> 00:19:55.380
But when used in math, for example, I will do four modulo two like this.

297
00:19:55.950 --> 00:19:58.950
OK, so what modulo does?

298
00:19:58.950 --> 00:20:00.930
You can think of it as doing two things.

299
00:20:00.960 --> 00:20:06.450
First, it performs the regular division in this case four divided by two.

300
00:20:06.720 --> 00:20:12.840
But then it also calculates what is the remainder of that operation?

301
00:20:13.320 --> 00:20:13.860
OK.

302
00:20:13.950 --> 00:20:20.280
So if you think back to like 3rd grade long division you learned about, you know, getting a remainder

303
00:20:20.280 --> 00:20:25.360
and what it does is it actually returns the remainder of this division problem.

304
00:20:25.380 --> 00:20:30.330
So in this case, four is divided by two evenly, so there will be no remainder.

305
00:20:30.330 --> 00:20:34.560
So this operation should return a zero because there is no remainder.

306
00:20:34.560 --> 00:20:41.760
So that's what the modulo does is that it returns the remainder of the division of the two numbers.

307
00:20:41.790 --> 00:20:42.300
OK.

308
00:20:42.660 --> 00:20:44.040
And so if we run this?

309
00:20:45.610 --> 00:20:47.020
Yeah, we get a zero there.

310
00:20:47.500 --> 00:20:50.140
However, if we make this a five.

311
00:20:50.320 --> 00:20:54.660
Right, so now we'll hear we'll run this, and that makes sense, right?

312
00:20:54.670 --> 00:20:59.230
Because two goes into five, two times, which would be four.

313
00:20:59.680 --> 00:21:02.540
But now you have a remainder of one.

314
00:21:02.740 --> 00:21:04.340
In order to get to the five.

315
00:21:04.390 --> 00:21:09.840
OK, so the modulo operation is actually quite useful.

316
00:21:09.850 --> 00:21:17.350
Any time you have a repeating pattern where you want something to keep happening, like alternating

317
00:21:17.350 --> 00:21:22.000
rows of a table, every other row should be white or black.

318
00:21:22.270 --> 00:21:27.970
And what you can do, I'm going to I'm going to show you in a particular way here.

319
00:21:28.690 --> 00:21:37.060
So let's say we ran through the rows of a table in each row was numbered.

320
00:21:37.570 --> 00:21:38.080
OK.

321
00:21:41.920 --> 00:21:42.790
Like so.

322
00:21:44.620 --> 00:21:56.020
If you have a sequence that is in order, but you want an output to alternate in some way, you can

323
00:21:56.020 --> 00:21:56.850
use the modular.

324
00:21:57.210 --> 00:22:00.520
Now let me show you what happens when we run this in this way.

325
00:22:01.150 --> 00:22:02.640
Let's see what the output will be.

326
00:22:03.970 --> 00:22:09.040
Look at that, we get alternating one zero one zero one zero one zero.

327
00:22:09.190 --> 00:22:09.700
OK.

328
00:22:10.060 --> 00:22:16.660
Given a straight sequence of numbers one through ten like this, you're basically saying give me a way

329
00:22:16.660 --> 00:22:20.660
to distinguish every other one with the number two, OK?

330
00:22:20.680 --> 00:22:21.610
Every other one.

331
00:22:21.730 --> 00:22:22.960
Now watch this.

332
00:22:23.230 --> 00:22:29.110
We can change this number here to something else.

333
00:22:29.740 --> 00:22:34.780
OK, so if we change these twos two or three, let's see what happens.

334
00:22:34.990 --> 00:22:41.710
And by the way, one way that I can select most of these twos quickly is by changing the selection mode

335
00:22:41.950 --> 00:22:47.620
of the I.D. from this horizontal kind of style to a vertical style.

336
00:22:47.830 --> 00:22:53.920
I'll show you how to do that so I can do a command shift eight, which I think is, well, I'm sorry,

337
00:22:53.920 --> 00:22:56.980
I don't know how to do that for Windows and PC, but actually hold on.

338
00:22:56.980 --> 00:22:58.390
Let me turn that off for a second.

339
00:22:58.420 --> 00:23:01.750
So for Windows and PC users, I think you can just right click.

340
00:23:02.260 --> 00:23:02.800
Let's see.

341
00:23:02.800 --> 00:23:06.970
You can right click and then select Column Selection mode.

342
00:23:06.970 --> 00:23:08.350
Yes, so you can do it that way.

343
00:23:08.740 --> 00:23:08.980
All right.

344
00:23:08.980 --> 00:23:15.430
So Command Shift eight and now I can put my cursor right here and go down.

345
00:23:16.940 --> 00:23:20.510
Oops, I lost my selection down.

346
00:23:21.410 --> 00:23:26.600
And then to the right, and now I'm selecting all of those tools, and now I can change them all to

347
00:23:26.600 --> 00:23:29.600
threes, all in one go by just hitting three.

348
00:23:29.960 --> 00:23:35.510
And then when I want to get out of column selection mode, I can just toggle this off with another command

349
00:23:35.510 --> 00:23:36.290
shift eight.

350
00:23:36.530 --> 00:23:42.170
And then for Windows and Linux users, you'll have to just right click and then I'll change this last

351
00:23:42.170 --> 00:23:43.160
one down here.

352
00:23:44.180 --> 00:23:46.070
OK, so now what I'm saying is.

353
00:23:47.360 --> 00:23:53.000
Go by threes every third one, I want the pattern to change.

354
00:23:53.120 --> 00:23:54.480
So let's run this and see.

355
00:23:55.880 --> 00:24:00.320
OK, so one two zero one two zero one two zero.

356
00:24:00.620 --> 00:24:08.600
So if I keyed on the zero, for example, so that, you know, every third one, I would highlight something

357
00:24:08.600 --> 00:24:09.680
or do something right.

358
00:24:09.920 --> 00:24:18.890
So basically, you can use the modulo anytime you want to impose a pattern on a sequence of things,

359
00:24:18.890 --> 00:24:19.130
right?

360
00:24:19.150 --> 00:24:22.370
So here's here's our sequence of things the one through 10.

361
00:24:22.610 --> 00:24:25.700
And we want a pattern of every third.

362
00:24:25.970 --> 00:24:32.360
One of these do something or every two, which is the same as saying every other right?

363
00:24:32.510 --> 00:24:33.240
Do something.

364
00:24:33.260 --> 00:24:37.070
OK, so that's where modulo becomes actually quite quite useful.

365
00:24:37.310 --> 00:24:42.950
And you'll see this from time to time in programming most often, probably when you have rows of a table

366
00:24:42.950 --> 00:24:47.810
and you just want to alternate in terms of the coloring of the row or something like that.

367
00:24:48.260 --> 00:24:48.500
All right.

368
00:24:48.500 --> 00:24:50.200
So that's what modulo is for.

369
00:24:51.190 --> 00:24:56.950
All right, now, let's look at a very common thing that we do in programming all the time.

370
00:24:56.980 --> 00:24:58.300
Let me clear this out.

371
00:24:59.090 --> 00:25:06.550
Let's say that we're writing a program where let's let's create a variable and we'll just call it X

372
00:25:06.970 --> 00:25:08.890
and we'll let X equal.

373
00:25:09.130 --> 00:25:12.130
We will initialize X to one.

374
00:25:12.430 --> 00:25:12.940
OK.

375
00:25:14.030 --> 00:25:18.280
And then let's print out X, OK?

376
00:25:18.770 --> 00:25:23.090
And now let's say that after we do something with that, it's like printing out the X.

377
00:25:23.300 --> 00:25:27.740
We want to increment the value of X.

378
00:25:28.010 --> 00:25:33.560
So it started off as one, but we want to increment it by one increment means to basically just add

379
00:25:33.560 --> 00:25:34.460
one to it.

380
00:25:34.590 --> 00:25:35.060
OK.

381
00:25:35.090 --> 00:25:37.430
And then we want to print out X again.

382
00:25:37.670 --> 00:25:46.370
So one way we could do that is by just writing out a statement like X equals x plus one.

383
00:25:46.610 --> 00:25:51.470
OK, now this is starting to look like algebra, and it kind of pretty much is right.

384
00:25:51.710 --> 00:25:56.090
So we're saying X will now equal x plus one.

385
00:25:56.330 --> 00:25:57.880
I know that might look a little weird.

386
00:25:58.070 --> 00:26:02.990
Again, you're really, really new to programming, and maybe it's been a long time since you had algebra

387
00:26:02.990 --> 00:26:03.620
or something.

388
00:26:03.920 --> 00:26:08.210
So what's happening here is we first started setting X equal to one.

389
00:26:08.210 --> 00:26:09.330
So X is one.

390
00:26:09.800 --> 00:26:20.330
Now down here, what's happening is we're saying one is we're saying X will now equal one plus one,

391
00:26:20.330 --> 00:26:21.110
which is two.

392
00:26:21.320 --> 00:26:28.490
And so when this is done, evaluating X will now be set to two instead of one.

393
00:26:28.610 --> 00:26:29.120
OK.

394
00:26:29.480 --> 00:26:35.960
So you can redefine a variable from whatever the variable already was set to.

395
00:26:36.470 --> 00:26:38.300
And then if we.

396
00:26:41.680 --> 00:26:47.320
If we run the print line again, we'll get it too, so let's run this and confirm that behavior.

397
00:26:47.860 --> 00:26:48.800
OK, there we go.

398
00:26:48.820 --> 00:26:55.540
So first we got a one which was line four and then we got a two, which was line six.

399
00:26:56.050 --> 00:27:03.160
Now there are a few ways to do this kind of pattern because it's an incredibly common pattern to do

400
00:27:03.160 --> 00:27:04.030
in programming.

401
00:27:04.270 --> 00:27:09.610
Frequently, we will be going through what are called loops of code, where you kind of just repeat

402
00:27:09.880 --> 00:27:14.770
the same code over and over and over again and you want to keep a track or keep a count or something

403
00:27:14.770 --> 00:27:15.340
like that.

404
00:27:15.520 --> 00:27:17.130
And so you'll do something like this.

405
00:27:17.140 --> 00:27:19.450
However, there are a few other ways to do this.

406
00:27:19.810 --> 00:27:23.650
So this is one way that you could increment a value, right?

407
00:27:23.650 --> 00:27:30.250
Just explicitly saying X equals X plus whatever we could count by twos if we wanted to x equals x plus

408
00:27:30.250 --> 00:27:32.650
two x equals X plus three, et cetera.

409
00:27:32.800 --> 00:27:33.250
OK.

410
00:27:33.280 --> 00:27:38.790
Another way we could do this, though there's a shorthand for this because it's so common.

411
00:27:40.360 --> 00:27:45.280
And that is to say X Plus equals one.

412
00:27:46.490 --> 00:27:53.570
Like so and I know that probably looks pretty, pretty weird, but it's just a shorthand because saying.

413
00:27:54.790 --> 00:28:01.420
X equals X plus whatever in or one or whatever is such a common thing.

414
00:28:01.670 --> 00:28:06.850
So a shorthand was created and by the way, the shorthand doesn't even originate from Java.

415
00:28:06.850 --> 00:28:13.570
It actually, as far as I know, it originates from the language of C, which was invented around 1970,

416
00:28:13.570 --> 00:28:20.080
1969, 1970 somewhere around in there, and it may have existed even with some earlier programming language

417
00:28:20.350 --> 00:28:21.190
for all I know.

418
00:28:21.220 --> 00:28:21.580
OK.

419
00:28:21.820 --> 00:28:23.860
So anyway, we can do it this way as well.

420
00:28:23.890 --> 00:28:24.910
So let's run this.

421
00:28:26.260 --> 00:28:28.720
OK, so we get the same output, right?

422
00:28:29.050 --> 00:28:32.230
And you could change this number, of course, to whatever.

423
00:28:32.860 --> 00:28:36.970
So then it's just going to be the equivalent of saying X equals X plus four.

424
00:28:37.630 --> 00:28:38.140
There you go.

425
00:28:38.140 --> 00:28:39.220
One and then five.

426
00:28:39.580 --> 00:28:40.000
OK.

427
00:28:41.410 --> 00:28:45.700
Now, what's nice about this is that you can keep doing it.

428
00:28:47.470 --> 00:28:55.180
So if you do that multiple times, like in a repeating loop of code, for example, let's see what our

429
00:28:55.180 --> 00:28:58.120
output will be having called this multiple times.

430
00:28:58.150 --> 00:29:02.980
Now we get 21 right because it's going to just keep adding four.

431
00:29:03.190 --> 00:29:14.560
OK, now if you only are wanting to add one to the previous value of the variable, there's another

432
00:29:14.560 --> 00:29:22.120
shorthand, which is even a little shorter than this because adding one is extremely common pattern.

433
00:29:22.510 --> 00:29:32.620
And what you can do here is you can just do this X plus plus that is equivalent to saying X equals X

434
00:29:32.620 --> 00:29:34.570
plus one or.

435
00:29:37.500 --> 00:29:39.670
X Plus equals one.

436
00:29:39.690 --> 00:29:42.300
OK, so X Plus Plus.

437
00:29:42.690 --> 00:29:45.240
So we can run this.

438
00:29:46.960 --> 00:29:49.090
There you go and you still get one and two.

439
00:29:49.660 --> 00:29:52.750
But wait, you can do even a little bit more.

440
00:29:53.620 --> 00:30:03.760
So I'm going to delete that line now you with the Plus Plus operator, you can actually just embed that

441
00:30:04.240 --> 00:30:07.810
right into some code just like this.

442
00:30:08.590 --> 00:30:10.450
Now, what do you think this is going to do?

443
00:30:10.480 --> 00:30:16.060
We set X equal to one and then we print X Plus Plus and then we print X.

444
00:30:16.570 --> 00:30:19.030
Why don't you take a quick guess before I run this?

445
00:30:19.840 --> 00:30:21.530
All right, so now I'm going to run it.

446
00:30:21.550 --> 00:30:22.810
Let's see what this does.

447
00:30:23.530 --> 00:30:26.080
OK, it's still just gives us one two.

448
00:30:27.130 --> 00:30:36.070
Now the reason it gives us one and two is because this plus plus coming after the X like it is here

449
00:30:36.250 --> 00:30:44.610
is really telling Java and the compiler first and foremost, print the current value of X at line four.

450
00:30:44.740 --> 00:30:54.010
And then right after it's done printing the value of X, the value of X will be incremented by one right

451
00:30:54.010 --> 00:30:54.610
after.

452
00:30:54.970 --> 00:30:58.630
OK, so the fact that these pluses are coming?

453
00:30:59.320 --> 00:30:59.740
Oops.

454
00:31:00.880 --> 00:31:05.380
Are coming right after the X is kind of like your your hint.

455
00:31:05.410 --> 00:31:05.890
OK.

456
00:31:06.460 --> 00:31:14.350
And so then when we get to line five and we print X again, by now, this increment has happened and

457
00:31:14.350 --> 00:31:18.550
now X equals x plus one, which in this case is two.

458
00:31:18.760 --> 00:31:19.210
OK.

459
00:31:19.600 --> 00:31:21.080
And so that's what's happening there.

460
00:31:21.820 --> 00:31:29.440
Now you could on another line, do another x plus plus again, and now you would get three here.

461
00:31:29.440 --> 00:31:31.480
By the time you got here, you'd have a three.

462
00:31:31.480 --> 00:31:33.370
In fact, here we'll just run that and prove it.

463
00:31:33.730 --> 00:31:34.280
There you go.

464
00:31:34.300 --> 00:31:35.390
So there's your three.

465
00:31:35.590 --> 00:31:36.030
OK.

466
00:31:36.100 --> 00:31:43.120
If you wanted to do it, to do that for some reason, now there's another shorthand that's related to

467
00:31:43.120 --> 00:31:43.570
this.

468
00:31:44.050 --> 00:31:48.340
What if we wanted the increment to occur online for?

469
00:31:48.700 --> 00:31:50.410
Well, you could do that, too.

470
00:31:50.650 --> 00:31:51.850
And what you would do is.

471
00:31:53.360 --> 00:31:58.100
But the plus plus in front of the ex instead of behind the ex.

472
00:31:58.250 --> 00:32:04.380
So now if we run this look at that now we get two and two was.

473
00:32:04.400 --> 00:32:09.530
Were you all expecting that or are we expecting two and three or were you expecting one and two?

474
00:32:10.010 --> 00:32:13.970
So what's happening here is we started off with X equal to one.

475
00:32:14.510 --> 00:32:20.960
Then we get here and now what happens is the compiler sees this plus plus, and this takes precedent

476
00:32:20.960 --> 00:32:24.250
over executing this statement.

477
00:32:24.260 --> 00:32:32.570
So the first thing it does online for is to Increment X by one, which means that now it's set to two.

478
00:32:33.050 --> 00:32:35.450
Then it prints two.

479
00:32:35.900 --> 00:32:41.090
And that's the only incriminating that is that we're asking it to do so when we print X again.

480
00:32:41.330 --> 00:32:44.390
It was already set to to appear, so we didn't change.

481
00:32:44.510 --> 00:32:45.430
We didn't change it.

482
00:32:45.440 --> 00:32:47.120
It's still two, OK.

483
00:32:47.140 --> 00:32:50.300
And that's why we get to print it twice.

484
00:32:50.690 --> 00:32:51.110
OK.

485
00:32:52.010 --> 00:33:01.280
Now also me put this back to X like so I showed you that we could do X plus equals.

486
00:33:02.340 --> 00:33:09.270
One like this, we can also decrement that means subtract from or go down.

487
00:33:09.690 --> 00:33:13.770
So just as we can do X Plus equals, we can also do X.

488
00:33:14.970 --> 00:33:18.030
We can also do x minus equals.

489
00:33:18.060 --> 00:33:18.510
OK.

490
00:33:18.990 --> 00:33:20.760
So if we run this.

491
00:33:22.670 --> 00:33:25.520
We start with the one and then we get a zero.

492
00:33:25.670 --> 00:33:35.630
OK, so you can you can go up or down, you can increment or decrement and then also we can do x minus

493
00:33:35.630 --> 00:33:36.230
minus.

494
00:33:39.110 --> 00:33:40.040
And we'll run that.

495
00:33:41.530 --> 00:33:43.400
And same thing, one in zero.

496
00:33:43.420 --> 00:33:47.710
And of course, you can do it as a prefix or a postfix.

497
00:33:51.150 --> 00:33:53.370
And then you end up with zero zero.

498
00:33:53.700 --> 00:33:54.690
So that makes sense.

499
00:33:55.230 --> 00:34:01.470
There's another basic math operator I want to show you, in addition to the increments in decrement

500
00:34:01.470 --> 00:34:03.300
things that we were learning before.

501
00:34:03.510 --> 00:34:06.240
Now this is one that applies to billions.

502
00:34:06.420 --> 00:34:12.600
So let's say we have a Boolean, and you may not think of a Boolean as being related to math, but if

503
00:34:12.600 --> 00:34:18.810
you think back to the lowest level of what's actually happening in the computer, where everything is

504
00:34:19.110 --> 00:34:26.280
eventually becoming bits and bytes, whenever we have a Boolean, that is just one bit, I'll show you

505
00:34:26.280 --> 00:34:27.020
again.

506
00:34:28.660 --> 00:34:30.490
Just to refresh your memory here.

507
00:34:31.210 --> 00:34:41.230
So when we instantiate a Boolean, all Java is really doing is just allocating one bit out of some memory

508
00:34:41.230 --> 00:34:41.680
space.

509
00:34:41.680 --> 00:34:48.520
And as I mentioned a few lessons ago, it may it may be allocating an entire byte or even 32 bits or

510
00:34:48.520 --> 00:34:53.050
something like that and then tracking each time we ask for a Boolean.

511
00:34:53.230 --> 00:34:59.860
It may just be assigning that Boolean to some 32 bit value that it stores internally.

512
00:34:59.860 --> 00:35:01.870
For all I know, and I don't really care.

513
00:35:01.990 --> 00:35:05.680
And you don't need to care either, but a Boolean is just one bit.

514
00:35:05.740 --> 00:35:06.250
OK?

515
00:35:06.460 --> 00:35:11.350
Because all it can store is whether something is true or false on or off zero or one.

516
00:35:11.380 --> 00:35:11.860
OK.

517
00:35:11.950 --> 00:35:12.340
All right.

518
00:35:12.490 --> 00:35:19.780
So I'm going to create a Boolean here, and I'm going to call it my flag and I'm going to set it to

519
00:35:19.810 --> 00:35:20.500
true.

520
00:35:21.430 --> 00:35:25.720
And then let's just print that out my flag.

521
00:35:26.840 --> 00:35:30.500
All right, now, I'm not going to run this because you already know it's going to print.

522
00:35:30.890 --> 00:35:31.310
True.

523
00:35:32.070 --> 00:35:40.880
However, similarly to how we were able to increment and decrement a variable, you know, we had like

524
00:35:41.210 --> 00:35:43.280
whatever number one plus plus.

525
00:35:43.550 --> 00:35:44.660
Something like that.

526
00:35:45.170 --> 00:35:51.770
There is a short little thing that we can do to manipulate what is stored in a Boolean as well.

527
00:35:52.220 --> 00:36:00.230
And what we can do is actually put an exclamation mark in front of the variable.

528
00:36:00.530 --> 00:36:08.780
And what that does is it negates or flips the the the value of the Boolean.

529
00:36:08.900 --> 00:36:11.690
So in this case, we had set the Boolean.

530
00:36:11.690 --> 00:36:13.940
We had initialized the Boolean to true.

531
00:36:14.150 --> 00:36:21.200
But when we print this, this little exclamation, which I would read as not, is going to flip the

532
00:36:21.200 --> 00:36:25.550
value of that of what's printed to the opposite.

533
00:36:25.610 --> 00:36:27.830
OK, so here, let's run this now.

534
00:36:28.340 --> 00:36:29.900
And so now it prints false.

535
00:36:30.140 --> 00:36:38.510
OK, so we just negated that so we could do something like my flag equals, not my flag.

536
00:36:39.110 --> 00:36:44.150
And then we could print this, print my flag again.

537
00:36:44.340 --> 00:36:47.450
Oh, now let me remember to get rid of that.

538
00:36:48.260 --> 00:36:48.620
All right.

539
00:36:49.610 --> 00:36:57.500
So in these two system that our print lines were just printing my flag, but in between them, we should

540
00:36:57.500 --> 00:36:59.640
be flipping the bit, so to speak.

541
00:36:59.660 --> 00:37:01.130
So let's run this and see.

542
00:37:01.490 --> 00:37:01.850
Yeah.

543
00:37:02.030 --> 00:37:03.680
So first it printed true.

544
00:37:03.680 --> 00:37:05.070
Then it printed false.

545
00:37:05.090 --> 00:37:08.690
OK, so we're flipping the bit if you've ever heard that expression.

546
00:37:09.560 --> 00:37:15.830
It refers to one bit of a memory location or of a byte or whatever.

547
00:37:16.550 --> 00:37:16.850
All right.

548
00:37:16.880 --> 00:37:23.240
I'm going to wrap this up, but we've have we have plenty more of these little math operations to look

549
00:37:23.240 --> 00:37:25.040
at, so I will see you in the next one.
