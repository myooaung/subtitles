WEBVTT
1
00:00:00.600 --> 00:00:00.930
All right.

2
00:00:00.960 --> 00:00:06.600
So now let's go ahead and run all of the tests and see what we've got to fix here because I know we're

3
00:00:06.600 --> 00:00:07.710
going to have to fix something.

4
00:00:07.970 --> 00:00:13.050
Someone to jump up here to the top and click this and just run all of the tests.

5
00:00:15.350 --> 00:00:20.690
All right, so I'm a little bit surprised that it's only two failing tests, to be honest with you.

6
00:00:20.930 --> 00:00:25.430
So let's see what we've got here, so can find person by I.D..

7
00:00:25.760 --> 00:00:26.120
Yeah.

8
00:00:26.330 --> 00:00:31.250
So this is definitely one of the issues that I was kind of expecting to see here.

9
00:00:31.520 --> 00:00:40.060
So this can find person by ID test is saving a person and then retrieving them by ID without an address.

10
00:00:40.070 --> 00:00:44.990
And in this new update that we just recently made, we didn't put any condition or code in there to

11
00:00:44.990 --> 00:00:51.140
check and see, Hey, if we're doing this joint query and and we're joining to these address fields

12
00:00:51.140 --> 00:00:56.510
and those address fields happened to all be null, how should we handle that situation?

13
00:00:56.810 --> 00:00:59.300
And I think that's what we're seeing here.

14
00:00:59.330 --> 00:01:00.590
So let's see.

15
00:01:00.620 --> 00:01:07.370
Couldn't invoke the string that two uppercase because the string value of the result said get string

16
00:01:07.610 --> 00:01:08.390
is null.

17
00:01:08.960 --> 00:01:13.610
And let's see if we click on this extract address method.

18
00:01:13.610 --> 00:01:14.540
Call here.

19
00:01:14.600 --> 00:01:15.110
Yeah.

20
00:01:15.500 --> 00:01:22.910
So I'm guessing that probably all of these get string calls here are returning a null, which is, you

21
00:01:22.910 --> 00:01:24.110
know, kind of fine.

22
00:01:24.110 --> 00:01:30.740
But then we're getting down here to this enum value of and the value of isn't going to know what to

23
00:01:30.740 --> 00:01:32.180
do with a null.

24
00:01:32.270 --> 00:01:34.730
And so we're getting a null pointer exception here.

25
00:01:35.090 --> 00:01:35.530
All right.

26
00:01:35.540 --> 00:01:41.360
So we need to figure out how do we want to handle the situation where there isn't an address to retrieve

27
00:01:41.360 --> 00:01:42.110
essentially.

28
00:01:42.680 --> 00:01:44.720
So first off, let me make some room here.

29
00:01:44.720 --> 00:01:48.380
So let's just pay a little more attention to this code here.

30
00:01:48.800 --> 00:01:54.500
Extract, address and you've got your results set and then we start pulling these values out.

31
00:01:54.500 --> 00:02:02.300
Actually, a thought just crossed my mind right now, and that is perhaps we could just do a quick,

32
00:02:02.300 --> 00:02:05.000
conditional check when we're retrieving the ID.

33
00:02:05.390 --> 00:02:12.500
And maybe what we do is do an arrest, get long on the I.D. and if this call returns a value that is

34
00:02:12.500 --> 00:02:14.240
maybe less than zero.

35
00:02:14.270 --> 00:02:18.890
I'm not even exactly sure what this get long method is even returning.

36
00:02:18.890 --> 00:02:25.880
If the ID value for the address is is is null, but I'm assuming it's certainly not going to be a number

37
00:02:25.880 --> 00:02:27.200
that's greater than zero.

38
00:02:27.230 --> 00:02:35.120
So perhaps we could say something like if this resulting deal here is less than zero, or perhaps even

39
00:02:35.120 --> 00:02:41.630
if our stock get object of I.D. is null, that might be even more to the point.

40
00:02:41.900 --> 00:02:48.530
Then don't do any of this and perhaps just return an empty optional of an address.

41
00:02:48.710 --> 00:02:54.800
And so maybe we'd want even consider just changing this method signature to return an optional of an

42
00:02:54.800 --> 00:02:58.040
address so that we don't even have to make a null.

43
00:02:58.250 --> 00:03:00.680
Or we could just return a null directly.

44
00:03:00.680 --> 00:03:02.390
I guess that would work too, actually.

45
00:03:02.780 --> 00:03:09.040
But maybe getting away from Noelle's as soon as possible is probably almost never a bad thing.

46
00:03:09.050 --> 00:03:18.070
So maybe about the easiest way we could address this quickly might be to do something like this if our

47
00:03:18.110 --> 00:03:19.850
stock get object.

48
00:03:20.980 --> 00:03:21.340
I'd.

49
00:03:23.630 --> 00:03:27.630
Equals null, then return null.

50
00:03:27.950 --> 00:03:32.570
Let me start with that, even though I was saying that it might be better to return an optional from

51
00:03:32.570 --> 00:03:36.050
here, but let let me start with this so that I don't have to do too much surgery.

52
00:03:36.230 --> 00:03:40.370
Now I want to also show you something that I hadn't really gone out of my way to explain this because

53
00:03:40.370 --> 00:03:44.180
it's a pattern that I really didn't want to emphasize is something you can do.

54
00:03:44.180 --> 00:03:50.570
But in some statements that can work with a code block like here, we could have enclosed this return

55
00:03:50.570 --> 00:03:53.360
null inside of curly braces like so.

56
00:03:53.630 --> 00:03:53.900
Right.

57
00:03:53.900 --> 00:03:56.120
And that's a very typical thing to do.

58
00:03:56.120 --> 00:04:01.790
If the statements that you would have put inside of the code block are capable of fitting on one line

59
00:04:01.790 --> 00:04:04.700
and you're only making one statement like, I'm making here.

60
00:04:05.090 --> 00:04:07.100
You don't even need the curly braces.

61
00:04:07.850 --> 00:04:14.180
Now there are actually a lot of code checker utilities that will discourage you from coding in this

62
00:04:14.180 --> 00:04:19.820
way, because as soon as you add one more expression or statement here, and especially if you jump

63
00:04:19.830 --> 00:04:23.420
down to another line, you now have ambiguous code.

64
00:04:23.750 --> 00:04:30.080
And so for safety's sake, it's generally just better to go ahead and wrap all of that inside a curly

65
00:04:30.080 --> 00:04:30.830
braces.

66
00:04:31.960 --> 00:04:37.320
But I just wanted to show you that you technically don't have to have the curly braces, actually.

67
00:04:37.360 --> 00:04:40.000
And while I'm at it, let me show you one more thing here too.

68
00:04:40.300 --> 00:04:43.840
In fact, I don't technically even have to keep that all on one line.

69
00:04:44.140 --> 00:04:45.370
I can actually.

70
00:04:45.380 --> 00:04:46.390
Now this is really bad.

71
00:04:46.400 --> 00:04:47.530
Don't ever do this.

72
00:04:47.950 --> 00:04:51.730
You, I can actually just have this one line here just like this.

73
00:04:52.060 --> 00:04:55.360
And the curly braces are kind of implied.

74
00:04:55.480 --> 00:04:55.930
OK.

75
00:04:56.470 --> 00:05:03.100
That's why the ad is depicting this return null as being indented to show that it's still subordinate

76
00:05:03.100 --> 00:05:04.720
to this if statement here.

77
00:05:04.840 --> 00:05:06.400
But really don't do this.

78
00:05:06.400 --> 00:05:12.580
It's just way too easy for this code to get messed up as soon as you put one more line of code in here,

79
00:05:12.580 --> 00:05:14.140
like, you know, whatever.

80
00:05:14.380 --> 00:05:15.490
Do something.

81
00:05:23.600 --> 00:05:29.060
So in general, I strongly recommend that you stay away from any of this kind of coating of style.

82
00:05:29.720 --> 00:05:30.470
So instead.

83
00:05:31.560 --> 00:05:38.550
Either just keep this wrapped inside a curly braces or maybe at the most, you can do this if you're

84
00:05:38.550 --> 00:05:41.790
going to literally do it all on one line like that.

85
00:05:42.450 --> 00:05:49.500
So basically, what I'm experimenting with here is to say, if this idea is null, then don't even bother

86
00:05:49.500 --> 00:05:51.720
doing any of this business at all.

87
00:05:52.110 --> 00:05:55.530
Just short circuit the rest of this code and return a null.

88
00:05:56.130 --> 00:06:00.750
Now, another thing that I have mentioned in this course is that quite often I'm not actually a big

89
00:06:00.750 --> 00:06:05.130
fan of having multiple return statements in a method.

90
00:06:05.310 --> 00:06:11.280
And some of those same code checkers that don't like us doing these if statements without the curly

91
00:06:11.280 --> 00:06:17.250
braces, some of those code checkers will also complain a little bit about having multiple return statements

92
00:06:17.250 --> 00:06:18.420
from the same method.

93
00:06:18.430 --> 00:06:22.920
But again, I kind of just wanted to show you some other techniques and approaches.

94
00:06:22.920 --> 00:06:29.190
And me personally, maybe I could live OK with this because I like the conciseness of it.

95
00:06:29.730 --> 00:06:36.330
If I don't do it in this way, quite then I need to introduce more curly braces and probably even an

96
00:06:36.330 --> 00:06:38.430
else statement or something like that.

97
00:06:38.580 --> 00:06:44.280
And then that makes my method even bigger so I can probably live with with this approach.

98
00:06:44.820 --> 00:06:45.120
All right.

99
00:06:45.120 --> 00:06:50.340
So it's taking me longer to explain why I'm doing it this way than to actually fix the problem, because

100
00:06:50.340 --> 00:06:52.110
I think this might fix it.

101
00:06:52.320 --> 00:06:57.720
So let me open back up the tests and just run them again, and let's see what we get now.

102
00:07:00.290 --> 00:07:02.840
Oh, OK, so still not quite working.

103
00:07:02.900 --> 00:07:04.280
Let's see here.

104
00:07:04.940 --> 00:07:13.010
Ah, OK, so it looks like in this case, the call to arrest I get object ID isn't null.

105
00:07:13.400 --> 00:07:16.400
So now I'm really curious to see what is the value of this.

106
00:07:16.670 --> 00:07:22.610
And this might be a good opportunity actually to use the debugger, which we haven't used in quite some

107
00:07:22.610 --> 00:07:23.000
time.

108
00:07:23.240 --> 00:07:29.750
So if I use the debugger and just put a breakpoint right on this line and then run just this one test

109
00:07:29.750 --> 00:07:35.870
method in debug mode, I can stop and execute this and see exactly what it's returning.

110
00:07:35.900 --> 00:07:36.290
OK.

111
00:07:36.530 --> 00:07:44.360
So let's try that and see someone to put a breakpoint right there and notice I just clicked not on the

112
00:07:44.360 --> 00:07:45.960
number, but to the right of it.

113
00:07:46.430 --> 00:07:47.870
And then I'm going to double click on.

114
00:07:47.870 --> 00:07:51.980
This can find person by ID to jump straight to this method here.

115
00:07:52.160 --> 00:07:57.620
Come over here to the play button, right click on that and then run this in debug mode.

116
00:07:57.620 --> 00:07:58.840
Or you could do control shift.

117
00:07:59.330 --> 00:08:02.370
So let's run that in debug mode and see what we end up with.

118
00:08:02.390 --> 00:08:04.580
OK, so it hits the breakpoint.

119
00:08:05.060 --> 00:08:13.100
And now what I can actually do is I actually just want to run this in a separate thread, kind of like

120
00:08:13.370 --> 00:08:21.290
so I can select just this little expression here restart, get object ID, right, click on it and then

121
00:08:21.290 --> 00:08:24.740
choose to evaluate expression like so.

122
00:08:24.980 --> 00:08:27.080
And let me make that so you can see what's going on.

123
00:08:27.080 --> 00:08:29.080
And so then I can just click evaluate.

124
00:08:29.720 --> 00:08:32.060
Oh, OK, and OK.

125
00:08:32.060 --> 00:08:35.310
So in this particular case, that actually does have a value.

126
00:08:35.330 --> 00:08:35.840
OK.

127
00:08:36.020 --> 00:08:39.320
So that's why that's proceeding just fine.

128
00:08:39.350 --> 00:08:39.830
All right.

129
00:08:39.830 --> 00:08:45.800
So then we really are just running into a situation where the region is probably null.

130
00:08:46.000 --> 00:08:50.510
Let me let's try running that some selecting just the rest.

131
00:08:50.510 --> 00:08:51.290
I get string.

132
00:08:51.470 --> 00:08:55.400
Don't forget to include the parentheses, both the opening and the closing.

133
00:08:55.400 --> 00:09:01.970
Right clicking on the rest, I get string coming down here to evaluate expression, clicking evaluate.

134
00:09:02.000 --> 00:09:03.890
Ah, OK, so that is null.

135
00:09:04.070 --> 00:09:05.420
So that's kind of interesting.

136
00:09:05.420 --> 00:09:07.640
So oh OK.

137
00:09:07.730 --> 00:09:09.350
I see what the problem is here.

138
00:09:09.980 --> 00:09:15.140
This idea is not the idea of the address.

139
00:09:15.410 --> 00:09:19.250
This idea is actually the ID of the person.

140
00:09:19.280 --> 00:09:22.190
Let's see our query up here.

141
00:09:22.220 --> 00:09:28.700
We're saying select P that ID and all these other and then we're getting another ID again, a date ID.

142
00:09:29.090 --> 00:09:33.360
But we did not provide an alias for either of these IDs.

143
00:09:33.380 --> 00:09:39.050
So there's that ambiguity that I think I mentioned when we were over in the Squirrel sequel client.

144
00:09:39.500 --> 00:09:47.090
So when I am saying down here to get ID, it's being interpreted as the person that ID instead of the

145
00:09:47.090 --> 00:09:48.260
address ID.

146
00:09:48.860 --> 00:09:49.190
Yeah.

147
00:09:49.190 --> 00:09:52.130
So that's that's the problem that we're running into there.

148
00:09:52.160 --> 00:09:54.050
So what can we do about that?

149
00:09:54.440 --> 00:09:57.940
Well, I think we could provide a column alias.

150
00:09:57.950 --> 00:10:00.260
So what do I mean by column alias?

151
00:10:00.470 --> 00:10:06.650
Well, since we've got ambiguity now because we've got two columns from two different tables that are

152
00:10:06.650 --> 00:10:08.900
named the same ID and ID.

153
00:10:09.050 --> 00:10:17.330
This this prefix here does not factor in to the column names that we have access to down here, obviously,

154
00:10:17.340 --> 00:10:17.720
right?

155
00:10:18.830 --> 00:10:26.720
So since we've got this ambiguity, we need to create aliases for these column names that will be seen

156
00:10:26.990 --> 00:10:29.360
when we use these column names down here.

157
00:10:29.450 --> 00:10:31.100
OK, now with the H.

158
00:10:31.100 --> 00:10:36.590
Two database specifically, there are a couple of ways that we can achieve this.

159
00:10:37.160 --> 00:10:38.900
And one is more work than the other.

160
00:10:38.900 --> 00:10:41.270
So let's first take a look at the easier way.

161
00:10:41.750 --> 00:10:48.710
So generally speaking, all we need to do is just create one alias for one of these so that we can differentiate.

162
00:10:48.860 --> 00:10:54.830
And since we already have more code tied to the column names that we're using for the people table,

163
00:10:55.070 --> 00:11:01.490
I'm inclined to instead introduce an alias just for our ID column of the address table.

164
00:11:01.670 --> 00:11:04.070
And so the way we can do that is quite easy.

165
00:11:04.370 --> 00:11:13.040
We can simply add on here the word as and then specify a new name for this field, and we could do something

166
00:11:13.040 --> 00:11:18.860
rather simple, like maybe a underscore ID as an address ID.

167
00:11:19.610 --> 00:11:26.870
Now, ideally, I would actually be creating aliases, at least for all of the address columns, if

168
00:11:26.870 --> 00:11:30.350
not for really all of the columns across both tables.

169
00:11:30.650 --> 00:11:37.820
And as you advance into learning more about Java and its frameworks, you may encounter the fact that

170
00:11:37.820 --> 00:11:44.420
the most popular frameworks for doing that will tend to use aliases for every single column automatically

171
00:11:44.630 --> 00:11:49.360
so that there's no chance of this kind of conflict or ambiguity occurring.

172
00:11:49.370 --> 00:11:54.440
But I don't feel like renaming every single column here, so I'm just going to only rename that one

173
00:11:54.440 --> 00:11:55.820
address ID for now.

174
00:11:56.360 --> 00:11:56.630
All right.

175
00:11:56.630 --> 00:11:59.730
So unfortunately, now that's not enough to make.

176
00:11:59.810 --> 00:12:07.810
This work, by default, the H2 database will honor this, but not in the way that we are expecting

177
00:12:07.840 --> 00:12:13.690
it will not treat this new alias as a new column name, which is what we're using down here.

178
00:12:14.080 --> 00:12:20.650
Instead, it will treat that alias as an additional name, which it will refer to as a column label.

179
00:12:21.340 --> 00:12:26.560
And this gets a little confusing because as you see down here, when we're working with these results

180
00:12:26.560 --> 00:12:33.520
sets and we're calling the various getter methods here the name of the parameters that we're passing

181
00:12:33.520 --> 00:12:38.050
in here, the string parameters are technically being called column labels.

182
00:12:38.140 --> 00:12:41.890
However, our aliases by default won't work here.

183
00:12:42.010 --> 00:12:48.960
These are going to continue to refer to the original column names that we used when we created the tables.

184
00:12:49.180 --> 00:12:56.860
When we create an alias with H2, as we're doing up here, this alias, like I said, is an additional

185
00:12:56.860 --> 00:12:58.360
name for this column.

186
00:12:58.540 --> 00:12:59.020
OK.

187
00:12:59.290 --> 00:13:05.140
And to access it by default, let me show you what it would look like, just for an example here.

188
00:13:05.320 --> 00:13:08.500
We actually cannot do our get string or whatever.

189
00:13:08.650 --> 00:13:15.520
We'd actually have to do something like this R's dot get metadata because this would be part of the

190
00:13:15.520 --> 00:13:19.370
metadata, which is like, add on data, are stuck.

191
00:13:19.380 --> 00:13:20.500
Get metadata.

192
00:13:20.710 --> 00:13:24.770
And then you'd kind of like have to know what column you're already dealing with.

193
00:13:24.790 --> 00:13:27.550
So let's say that that's column one.

194
00:13:27.550 --> 00:13:29.440
So get column label.

195
00:13:29.560 --> 00:13:31.840
We pass in an integer like column one.

196
00:13:31.990 --> 00:13:36.760
And now this method would presumably return our new alias.

197
00:13:36.790 --> 00:13:37.270
OK.

198
00:13:37.420 --> 00:13:40.450
So that might not even seem all that useful to you.

199
00:13:40.480 --> 00:13:45.040
Upon inspection, because how can you use that to get the value, which is what we're really trying

200
00:13:45.040 --> 00:13:45.280
to get?

201
00:13:45.400 --> 00:13:51.490
We want the value for the column whose alias is a underscore ID.

202
00:13:51.670 --> 00:13:53.170
That's what we're trying to get to.

203
00:13:53.290 --> 00:13:58.610
So unfortunately, there is no direct method for us to do that by default.

204
00:13:58.630 --> 00:14:02.260
However, we can make this work in a relatively easy way.

205
00:14:02.740 --> 00:14:04.510
So I'm going to delete that.

206
00:14:04.690 --> 00:14:10.570
Now, what we have to do is actually modify how we connect to the H2 database.

207
00:14:10.810 --> 00:14:17.380
So if we jump over to the test, to the very top of this class, we're not the very top, but near the

208
00:14:17.380 --> 00:14:21.640
top right down here where we are creating our connection.

209
00:14:21.880 --> 00:14:24.280
We can actually pass in another option.

210
00:14:24.430 --> 00:14:29.650
So I don't know if you remember where we started passing in this tracing option here so that we could

211
00:14:29.650 --> 00:14:33.100
see what was going on with the database while it was running.

212
00:14:33.340 --> 00:14:40.870
But there are actually quite a large number of options that we can specify to the H2 database to modify

213
00:14:40.870 --> 00:14:41.830
how it behaves.

214
00:14:42.040 --> 00:14:50.580
And we can actually tell the H2 database that it should treat the aliases column aliases as column names

215
00:14:50.590 --> 00:14:58.090
effectively so that the JTBC API, specifically the result set that getter methods will be capable of

216
00:14:58.090 --> 00:15:05.500
retrieving values by either the column name or if a column has an alias, then it will use the column

217
00:15:05.500 --> 00:15:07.840
alias so we can actually control that.

218
00:15:08.260 --> 00:15:13.090
So the way to do that is to simply add in another connection string option.

219
00:15:13.240 --> 00:15:22.120
And to do so, we can simply add in this new option alias underscore column underscore name equals true

220
00:15:22.240 --> 00:15:23.860
and then another semicolon.

221
00:15:24.040 --> 00:15:28.420
So each of these options is separated by a semicolon.

222
00:15:28.720 --> 00:15:34.360
So this is actually just a flag where we are telling aides to database that it should treat alias columns

223
00:15:34.360 --> 00:15:36.500
or column aliases as names.

224
00:15:36.520 --> 00:15:37.720
That's what we're doing there.

225
00:15:38.110 --> 00:15:46.540
And so now if we jump back over to the test, we then will need to change this name here to match the

226
00:15:46.540 --> 00:15:47.410
new alias.

227
00:15:47.410 --> 00:15:51.610
So address underscore ID or a underscore ID.

228
00:15:51.910 --> 00:15:55.570
And then we're going to want to do that here as well, eh?

229
00:15:55.600 --> 00:15:56.640
Underscore ID?

230
00:15:56.980 --> 00:16:04.000
Now, if we wanted to, we could also jump over to the address repository and make the same changes

231
00:16:04.000 --> 00:16:04.270
here.

232
00:16:04.300 --> 00:16:10.760
However, for now, that's actually not necessary since this repository isn't currently doing any joins.

233
00:16:11.110 --> 00:16:14.620
So there would be no opportunity for such ambiguity here.

234
00:16:14.800 --> 00:16:20.230
And with this new approach of fetching the addresses with the people by using a joint query, we're

235
00:16:20.230 --> 00:16:25.330
not actually even utilizing this repository for that operation at this time.

236
00:16:25.720 --> 00:16:26.380
All right.

237
00:16:26.470 --> 00:16:31.150
So now let us try running this test again.

238
00:16:31.390 --> 00:16:37.150
So again, I'm just double clicking on can find person by ID, and I'm not going to run this in debug.

239
00:16:37.150 --> 00:16:40.270
I'm just going to run the whole entire test and see what happens now.

240
00:16:41.750 --> 00:16:44.810
Hey, seems to be happier for whatever that's worth.

241
00:16:45.020 --> 00:16:46.640
It didn't blow up this time.

242
00:16:46.670 --> 00:16:47.060
All right.

243
00:16:47.240 --> 00:16:51.050
So now let's just run all of the tests and see.

244
00:16:53.030 --> 00:16:56.030
All right, so now everything seems to be working.

245
00:16:56.270 --> 00:17:00.080
So that was a pretty easy solution to this particular problem.

246
00:17:00.260 --> 00:17:07.040
Now I want to emphasize, though, that this particular problem and solution that we used are specific

247
00:17:07.040 --> 00:17:08.900
to the H2 database.

248
00:17:09.620 --> 00:17:13.220
Some other databases may not have had this issue to begin with.

249
00:17:13.250 --> 00:17:20.960
And in fact, as I think back on my career, I've never explicitly had to do this, but most of my database

250
00:17:20.960 --> 00:17:27.170
experience has been involved with me connecting to what are called enterprise level databases.

251
00:17:27.320 --> 00:17:31.370
That is large, expensive database systems that I didn't set up.

252
00:17:31.370 --> 00:17:37.400
They are set up by whole entire teams that have a full time job of administering those databases, such

253
00:17:37.400 --> 00:17:41.270
as Oracle or DB to or Microsoft SQL Server.

254
00:17:41.630 --> 00:17:48.740
And so for all I know, maybe those databases had their own proprietary equivalent of this already enabled,

255
00:17:48.950 --> 00:17:56.180
but I suspect that those databases may have already behaved by default the way that we are now making

256
00:17:56.180 --> 00:17:58.220
it to behave with this setting.

257
00:17:58.550 --> 00:18:03.170
That's my suspicion, but I don't know that for certain because I do know that I've used column aliases

258
00:18:03.170 --> 00:18:06.760
before and I've never really had to think about it.

259
00:18:06.770 --> 00:18:10.790
But with this version of H2, apparently I do need to think about it a little bit more.

260
00:18:10.820 --> 00:18:13.430
So I wanted to just kind of call that out.

261
00:18:13.790 --> 00:18:16.520
Now, if we didn't know how to do this?

262
00:18:16.550 --> 00:18:20.330
Let me show you what else we could have done, which would have been more involved.

263
00:18:20.510 --> 00:18:26.460
I'm going to jump back over to the system under test, which is our people repository class.

264
00:18:26.540 --> 00:18:26.810
All right.

265
00:18:26.820 --> 00:18:32.990
So the other way that we might have done this could have been to introduce a little helper or utility

266
00:18:32.990 --> 00:18:34.100
method, if you will.

267
00:18:34.370 --> 00:18:36.290
And let me show you what that could have looked like.

268
00:18:36.300 --> 00:18:38.240
In fact, I guess I'll go ahead and just write it.

269
00:18:38.450 --> 00:18:47.360
So what we would have wanted is the ability to retrieve the value of the column, whose alias is a underscore

270
00:18:47.360 --> 00:18:48.470
idea, right?

271
00:18:48.800 --> 00:18:54.080
And so what we could do there is maybe imagine that we would have had a method.

272
00:18:54.290 --> 00:18:59.540
I'm going to make another ADR IED to just as an example here.

273
00:18:59.570 --> 00:19:00.020
OK.

274
00:19:00.350 --> 00:19:07.320
So we could have made another method like get value by alias.

275
00:19:07.730 --> 00:19:16.790
And then we'd pass in a column alias like a underscore IED, and we'd pass in the result set and to

276
00:19:16.790 --> 00:19:20.030
make this more useful for all types of use cases.

277
00:19:20.660 --> 00:19:24.530
We also might need to pass in what the data type is.

278
00:19:26.200 --> 00:19:32.770
That we're expecting back out of here, so in other words, I want this method in this instance to return

279
00:19:32.770 --> 00:19:34.990
a long because that's what I'm trying to get here.

280
00:19:35.200 --> 00:19:38.200
But what if I had aliases for these other things as well?

281
00:19:38.380 --> 00:19:41.440
Well, then in that case, I'd want a string for this one.

282
00:19:41.440 --> 00:19:42.820
And what else do we have here?

283
00:19:42.970 --> 00:19:44.830
You know, maybe a date or whatever.

284
00:19:44.830 --> 00:19:49.420
So I could specify the data type that that we're supposed to be getting back out.

285
00:19:49.420 --> 00:19:51.370
That's that's the that's the gist, OK?

286
00:19:51.700 --> 00:19:58.510
So we could do that and then I could have the I.D. create this method by putting my cursor right there

287
00:19:58.510 --> 00:20:02.170
on the method and then doing the option return, go ahead and create the method.

288
00:20:02.200 --> 00:20:03.790
OK, so here's the method now.

289
00:20:03.940 --> 00:20:05.960
Here's what I would do in this case.

290
00:20:06.280 --> 00:20:13.180
I want this method to actually literally be generic so that it can return any data type that I'm trying

291
00:20:13.180 --> 00:20:13.600
to get.

292
00:20:13.840 --> 00:20:17.650
So now we get to revisit generics for a minute here because this is kind of cool.

293
00:20:17.710 --> 00:20:23.110
So what I would say is I want it to just return t I don't want a hard code, the type of long, OK,

294
00:20:23.500 --> 00:20:24.340
return t.

295
00:20:24.460 --> 00:20:27.600
Now, if I'm going to make this method generic, remember you.

296
00:20:27.620 --> 00:20:32.380
Not only can you make classes generic, you can make methods generic as well.

297
00:20:32.380 --> 00:20:33.610
And that's what I'm doing here.

298
00:20:34.000 --> 00:20:39.810
So in order for this method to be generic, though, I need to also do one of these deals here.

299
00:20:39.820 --> 00:20:44.110
And that's just signaling to Java that this method is generic.

300
00:20:44.320 --> 00:20:49.510
And the variable that I will be using for generics is T for type.

301
00:20:50.530 --> 00:20:58.840
All right, so T and then we'll take an input here, which will be the column name, which will be the

302
00:20:58.840 --> 00:21:01.480
alias, the column alias or something like that.

303
00:21:01.840 --> 00:21:06.370
So maybe I will just call that alias and then we'll have a result set.

304
00:21:06.640 --> 00:21:11.050
And then over here, we're going to take in a generic class type.

305
00:21:11.320 --> 00:21:13.510
So I don't want a hard code this too long.

306
00:21:13.690 --> 00:21:17.410
Instead, I'm just going to say it's going to be class of type T.

307
00:21:18.280 --> 00:21:23.620
And then over here, this will just refer to some class that represents a data type.

308
00:21:23.800 --> 00:21:29.650
So a pattern that you'll see from time to time and code that does this kind of thing is to call this

309
00:21:29.980 --> 00:21:37.950
type of parameter Keller's class just to prevent it from conflicting with the actual word class cla

310
00:21:37.960 --> 00:21:38.480
ss.

311
00:21:38.500 --> 00:21:41.350
So sometimes you'll see people just name it something like that.

312
00:21:41.500 --> 00:21:41.990
Clay.

313
00:21:42.850 --> 00:21:49.630
OK, so now that we're here, what I can do is first, I need to know how many columns are in the table,

314
00:21:49.930 --> 00:21:56.440
and I can learn that by doing an RC dot, get metadata that get column.

315
00:21:57.400 --> 00:22:03.160
Count, all right, now, these results set methods do throw exceptions.

316
00:22:03.340 --> 00:22:07.780
Now I don't want to handle them because I can just let this exception bubble up through the top.

317
00:22:07.930 --> 00:22:13.540
So what I'm going to do here is put my cursor there, option return and then choose Add exception to

318
00:22:13.540 --> 00:22:14.560
Method Signature.

319
00:22:14.710 --> 00:22:22.480
It's OK for me to do this here, because this method is a private method internal to this class.

320
00:22:22.660 --> 00:22:28.660
And so this exception, if it occurs, is going to bubble up to this method, which already is designated

321
00:22:28.660 --> 00:22:29.800
as throwing this exception.

322
00:22:29.800 --> 00:22:33.130
And then that will bubble up again to our credit repository.

323
00:22:33.130 --> 00:22:38.800
Superclass Anyway, so I'm OK with all of that happening under this circumstance.

324
00:22:39.070 --> 00:22:39.300
All right.

325
00:22:39.310 --> 00:22:45.310
So anyway, we're getting the column count and I'm going to capture that and I'm OK calling it column

326
00:22:45.310 --> 00:22:45.640
count.

327
00:22:45.640 --> 00:22:46.510
That makes sense.

328
00:22:46.780 --> 00:22:51.770
Now I can use a for loop and just as a little visual reference here.

329
00:22:51.790 --> 00:22:53.380
So here's the basic idea.

330
00:22:53.920 --> 00:22:54.160
All right.

331
00:22:54.160 --> 00:22:58.540
So we've got these column names right on this joined result said.

332
00:22:58.540 --> 00:23:00.100
Imagine that this is our result.

333
00:23:00.110 --> 00:23:00.820
Said OK.

334
00:23:01.540 --> 00:23:07.010
And let me just temporarily add another had a row above here.

335
00:23:07.030 --> 00:23:07.480
OK.

336
00:23:08.020 --> 00:23:15.610
And so now what we're saying is this column here, which is also called ID, is going to have an alias.

337
00:23:16.600 --> 00:23:19.780
Of a underscore IED.

338
00:23:20.170 --> 00:23:20.560
Right?

339
00:23:20.770 --> 00:23:22.400
That's what I'm saying here.

340
00:23:22.420 --> 00:23:29.740
OK, so first, we're going to find out how many columns we have in this result set.

341
00:23:29.810 --> 00:23:38.470
OK, and then what we can do is we can iterate over each of these columns and basically say, does this

342
00:23:38.470 --> 00:23:44.800
column have an alias or a column label, which is what it will be called of a underscore ID?

343
00:23:45.310 --> 00:23:47.620
If no, then move on to the next.

344
00:23:47.620 --> 00:23:50.590
Does this one have a column label of a underscore ID?

345
00:23:50.710 --> 00:23:51.400
How about this one?

346
00:23:51.400 --> 00:23:52.390
How about this one, this one?

347
00:23:52.690 --> 00:23:56.400
Finally, we'll get to this column here, and the answer will be yes.

348
00:23:56.410 --> 00:24:02.640
This column does indeed have a column label of a underscore I.D..

349
00:24:02.980 --> 00:24:09.520
And now we will make note of the index of this column out of all of these columns, right?

350
00:24:09.610 --> 00:24:15.880
We will make note of that columns index and then we can turn around and say, OK, so this column is

351
00:24:15.970 --> 00:24:19.000
one two three four five six column six.

352
00:24:19.660 --> 00:24:24.520
So then we can turn around and say, OK, give me the value of Column six.

353
00:24:24.700 --> 00:24:31.960
So that's how we can obtain values from a result set by using the column aliases or the column labels

354
00:24:31.960 --> 00:24:34.000
as they will be called in JTB.

355
00:24:34.630 --> 00:24:34.960
OK.

356
00:24:34.990 --> 00:24:37.240
So I just wanted to kind of layout the thinking here.

357
00:24:37.240 --> 00:24:41.320
OK, that's the algorithm or the approach that we are going to take.

358
00:24:41.350 --> 00:24:41.800
OK.

359
00:24:42.130 --> 00:24:42.510
All right.

360
00:24:42.520 --> 00:24:45.370
So here we're getting the column count.

361
00:24:45.730 --> 00:24:52.030
So in order to iterate through these columns, can you think of a good way to do that where you've got

362
00:24:52.030 --> 00:24:58.570
a column count and now you need to just kind of step through each column using that count, that counter,

363
00:24:58.570 --> 00:24:58.900
right?

364
00:24:59.020 --> 00:25:00.400
Can you think of a way to do that?

365
00:25:01.600 --> 00:25:01.880
All right.

366
00:25:01.900 --> 00:25:02.750
Did you think of it?

367
00:25:02.800 --> 00:25:04.030
Maybe you even coded it.

368
00:25:04.420 --> 00:25:04.710
All right.

369
00:25:04.720 --> 00:25:05.950
So here's what I would do.

370
00:25:06.610 --> 00:25:08.620
I would just use a for loop here.

371
00:25:10.850 --> 00:25:18.650
Just like this, so I'm going to say it's going to be an integer, and I will refer to this variable

372
00:25:18.650 --> 00:25:22.010
as column index, which I will call call IDEX.

373
00:25:22.910 --> 00:25:23.300
All right.

374
00:25:23.510 --> 00:25:26.320
Now column indexes, I think I mentioned this before.

375
00:25:26.330 --> 00:25:28.150
Column indexes are not zero based.

376
00:25:28.160 --> 00:25:29.180
They are one based.

377
00:25:29.570 --> 00:25:34.010
You won't have to memorize that, though, if you ever if you ever forget, which I forget all the time,

378
00:25:34.010 --> 00:25:35.330
to be perfectly honest with you.

379
00:25:35.690 --> 00:25:42.560
So one way you can learn that is by going into the Java docs of the results at class, and you can pull

380
00:25:42.560 --> 00:25:47.690
up the Java doc for any of those getter methods like get along, for example.

381
00:25:47.720 --> 00:25:48.110
OK.

382
00:25:48.320 --> 00:25:53.540
So you can just jump into the get long now you want the one that takes the integer, which is the column

383
00:25:53.540 --> 00:25:54.010
index.

384
00:25:54.020 --> 00:25:55.170
You want that one, OK?

385
00:25:55.430 --> 00:25:58.910
And then you can take a look of the Java doc for the get long method here.

386
00:25:58.910 --> 00:26:03.680
And if you just come up here, you can see that it reaches the value of the designated column in the

387
00:26:03.800 --> 00:26:06.110
in the current row of this result, said object.

388
00:26:06.110 --> 00:26:12.860
As a long in the Java programming language and the parameters it takes as an input, our column index

389
00:26:13.040 --> 00:26:14.480
and right here is the key.

390
00:26:14.690 --> 00:26:16.670
The first column is one.

391
00:26:17.120 --> 00:26:18.840
The second is two.

392
00:26:18.920 --> 00:26:21.320
So they're just letting you know this is not zero base.

393
00:26:21.320 --> 00:26:22.460
This is one based.

394
00:26:22.460 --> 00:26:24.820
OK, so that's how you don't have to memorize it.

395
00:26:24.830 --> 00:26:26.420
You can just jump into the Java docs.

396
00:26:26.600 --> 00:26:26.870
All right.

397
00:26:26.880 --> 00:26:32.810
So going back over here now, so I'm going to initialize this as one.

398
00:26:33.080 --> 00:26:33.520
OK.

399
00:26:34.160 --> 00:26:38.570
And then while column index is less than.

400
00:26:38.780 --> 00:26:45.470
And so now my next part of this for loop is going to be the wild part like do this loop while column

401
00:26:45.470 --> 00:26:47.690
index is less than blah blah blah, right?

402
00:26:47.900 --> 00:26:55.280
Now here's one thing to not get tripped up on the sense column indexes are one based and not zero based,

403
00:26:55.490 --> 00:26:58.760
and we are getting a count of the columns.

404
00:26:59.210 --> 00:27:06.800
That means that we will need to use the pattern of while column indexes less than, or equal to or equal

405
00:27:06.800 --> 00:27:11.030
to the column count, normally with most for loops.

406
00:27:11.240 --> 00:27:18.470
You're usually initializing your loop variable to zero and then you're saying while the loop variable

407
00:27:18.470 --> 00:27:23.630
is less than whatever your count is, that's how you would normally be doing it.

408
00:27:23.840 --> 00:27:25.970
And that's fine because you're zero based.

409
00:27:25.970 --> 00:27:31.850
But here, because we're one based, we actually need to be inclusive of the actual count.

410
00:27:31.880 --> 00:27:32.240
OK.

411
00:27:32.270 --> 00:27:34.520
Otherwise, you'll miss that last column.

412
00:27:34.670 --> 00:27:35.750
Why does that matter?

413
00:27:35.870 --> 00:27:41.270
Well, because let's say that post code was the column that we were looking for that had an alias on

414
00:27:41.270 --> 00:27:41.630
it.

415
00:27:42.110 --> 00:27:43.670
We missed this column.

416
00:27:43.880 --> 00:27:49.100
If we didn't say while column index is less than or equal to column count.

417
00:27:49.310 --> 00:27:51.110
That's that's why that really matters.

418
00:27:51.440 --> 00:27:51.840
All right.

419
00:27:51.860 --> 00:27:54.920
And then finally, column index + +.

420
00:27:56.000 --> 00:27:56.420
OK.

421
00:27:56.510 --> 00:28:02.360
So now if we come back over here, the next thing we would need to do is start testing each column to

422
00:28:02.360 --> 00:28:05.670
see, Do you have an alias of a underscore ID?

423
00:28:05.810 --> 00:28:06.560
How about you?

424
00:28:06.590 --> 00:28:07.250
How about you?

425
00:28:07.280 --> 00:28:07.620
Right?

426
00:28:07.640 --> 00:28:08.990
So that's what we need to do now.

427
00:28:09.560 --> 00:28:09.860
All right.

428
00:28:09.870 --> 00:28:20.360
So the way to do that is to call results set, get metadata dot, get column label and then we can pass

429
00:28:20.360 --> 00:28:22.010
in the column index.

430
00:28:23.470 --> 00:28:31.150
Like so, all right, so now this bit of code here is going to return whatever we have up here, if

431
00:28:31.150 --> 00:28:32.440
we have something up here.

432
00:28:32.800 --> 00:28:39.070
So let's just take a quick look at the Java doc for the Get column label method gets the designated

433
00:28:39.070 --> 00:28:43.450
columns suggested title for use in print outs and displays.

434
00:28:43.690 --> 00:28:48.700
The suggested title is usually specified by the sequel as clause.

435
00:28:49.390 --> 00:28:56.770
If a sequel as is not specified, the value returned from Get column label will be the same as the value

436
00:28:56.770 --> 00:28:58.960
returned by the Get column name.

437
00:28:59.620 --> 00:29:06.460
So that's telling us simply that for each column, if there is no column label or alias designated,

438
00:29:06.580 --> 00:29:09.640
then it will return the regular column name.

439
00:29:09.650 --> 00:29:12.270
So in this case, it would return it because we don't have one.

440
00:29:12.280 --> 00:29:15.400
It would return the last name, first name, date of birth, home address.

441
00:29:15.550 --> 00:29:21.670
But when it gets to this one, since we are specifying an alias here, it will return a underscore ID

442
00:29:22.060 --> 00:29:23.530
instead of just ID.

443
00:29:24.040 --> 00:29:26.550
So that's important to understand and know.

444
00:29:26.560 --> 00:29:27.010
OK.

445
00:29:27.490 --> 00:29:27.870
All right.

446
00:29:27.880 --> 00:29:34.450
So then what we can do here is say something like if alias?

447
00:29:35.700 --> 00:29:38.580
Equals right.

448
00:29:39.860 --> 00:29:43.820
Like so then do something right.

449
00:29:44.450 --> 00:29:52.250
So if the alias that we passed in which in this case would be the underscore ID equals whatever is coming

450
00:29:52.250 --> 00:30:00.050
off a here like here, then go ahead and extract the actual value for the row that we're currently on.

451
00:30:00.050 --> 00:30:04.130
Because remember now these result sets represent one row, essentially.

452
00:30:04.150 --> 00:30:04.580
OK.

453
00:30:04.610 --> 00:30:09.500
And we just have one result set, so you can really think of that as one row at a time.

454
00:30:09.860 --> 00:30:13.850
Result sets are more like a table with a row level cursor.

455
00:30:14.210 --> 00:30:19.190
But when we're using them in our code, you can mostly think of it as one row at a time.

456
00:30:19.370 --> 00:30:19.760
OK.

457
00:30:20.180 --> 00:30:20.590
All right.

458
00:30:20.600 --> 00:30:26.990
So now that we are here, we can then say something like RSA Dot get.

459
00:30:27.470 --> 00:30:33.020
Now here's where we would normally just say, get along or get string or get data or whatever, right.

460
00:30:33.030 --> 00:30:39.920
But we don't know what the data type is ourselves, right, because we're keeping this method generic.

461
00:30:40.220 --> 00:30:47.270
So the nice thing that we can do here is we can just use a very generic method called get object and

462
00:30:47.270 --> 00:30:51.650
we can use this version of it where we pass in a column index, OK?

463
00:30:51.710 --> 00:31:00.230
So we can pass in the current index that we are on in this loop, which is column index like so OK.

464
00:31:00.350 --> 00:31:06.350
And so that is us saying, OK, well, we were looping through column one and we didn't have any match

465
00:31:06.350 --> 00:31:10.070
in column two, column three, column for column five, column six.

466
00:31:10.070 --> 00:31:14.330
Hey, we've got a match now for the column name or alias, right?

467
00:31:14.450 --> 00:31:22.130
And so now go ahead and just do a regular old RSA, get object to get whatever value we're pointing

468
00:31:22.130 --> 00:31:23.510
at our stack.

469
00:31:23.510 --> 00:31:24.380
Get object.

470
00:31:24.620 --> 00:31:27.320
And really, we can just return that.

471
00:31:27.470 --> 00:31:30.090
However, we're going to run into a little bit of a problem.

472
00:31:30.110 --> 00:31:37.640
OK, now the problem that we're running into is that this method wants to return something of type object,

473
00:31:37.880 --> 00:31:42.500
and this method says it returns a specific generic type.

474
00:31:43.130 --> 00:31:45.830
So what do you think we can do to remedy this?

475
00:31:47.130 --> 00:31:47.700
Did you get it?

476
00:31:48.360 --> 00:31:49.980
OK, so it's actually pretty easy.

477
00:31:50.100 --> 00:31:53.170
Actually, we probably could let the aid just figure it out for us.

478
00:31:53.210 --> 00:31:53.490
Yes.

479
00:31:53.490 --> 00:31:55.680
In fact, the idea is smart enough to figure this out.

480
00:31:55.680 --> 00:31:57.150
It can just cast to T.

481
00:31:58.410 --> 00:32:02.170
Just like that, and that's what I would have done, I promise that's what I would have done to.

482
00:32:02.700 --> 00:32:03.100
All right.

483
00:32:03.120 --> 00:32:06.030
So yeah, it's this casting to data type T.

484
00:32:06.330 --> 00:32:08.340
Now some of you are probably a little confused.

485
00:32:08.370 --> 00:32:08.850
Wait a minute.

486
00:32:08.850 --> 00:32:09.300
What?

487
00:32:10.050 --> 00:32:13.470
So here's how this is actually going to work.

488
00:32:13.470 --> 00:32:16.710
And I'm not quite done down here, but I want to show you this before we go any further.

489
00:32:16.950 --> 00:32:22.230
So this tee is literally going to end up just getting replaced with the type of long.

490
00:32:22.260 --> 00:32:22.600
OK?

491
00:32:22.620 --> 00:32:24.150
In this particular case.

492
00:32:24.300 --> 00:32:29.150
And like I said, if I wanted to use this get value by alias method for all of these, and in fact,

493
00:32:29.160 --> 00:32:33.240
I could replace all of these arrests that get strings with get value by alias.

494
00:32:33.390 --> 00:32:39.090
And I could even pass in these same strings here for the column labels because we already know that

495
00:32:39.090 --> 00:32:44.370
this would work with either the aliases if they do exist or the column labels if they don't.

496
00:32:44.760 --> 00:32:45.210
OK.

497
00:32:45.420 --> 00:32:50.520
So anyway, I could replace all of these with this, and the only difference would be instead of calling

498
00:32:50.520 --> 00:32:51.570
RC, that gets string.

499
00:32:51.570 --> 00:32:53.700
In fact, here, let me just just do it.

500
00:32:54.120 --> 00:33:01.440
Let me just show you one more of these would look like so I could do String Street Address two equals

501
00:33:01.710 --> 00:33:15.360
get value by alias and then pass in street address comma R's comma string dot class, right?

502
00:33:15.660 --> 00:33:16.230
So.

503
00:33:17.800 --> 00:33:25.720
This line here is totally equivalent to this line here, functionally equivalent to this line here.

504
00:33:25.900 --> 00:33:31.900
And in fact, in some ways, this line is a little bit better or smarter or more flexible, perhaps

505
00:33:32.140 --> 00:33:39.130
because now if I decide to change the sequel that's associated with this and introduce an alias for

506
00:33:39.130 --> 00:33:44.350
this column, this method would actually work without us having to change that connection.

507
00:33:44.350 --> 00:33:45.130
String stuff.

508
00:33:45.160 --> 00:33:45.560
OK.

509
00:33:46.030 --> 00:33:47.440
So there's that.

510
00:33:47.680 --> 00:33:47.960
All right.

511
00:33:47.980 --> 00:33:54.430
Now finally, the last thing that we would need is to handle this little squiggly line here, and this

512
00:33:54.430 --> 00:33:54.850
is this thing.

513
00:33:54.850 --> 00:33:56.230
We're missing a return statement.

514
00:33:56.470 --> 00:34:00.700
And some of you may have forgotten how all of this works, and you may be thinking, Well, you've got

515
00:34:00.700 --> 00:34:01.660
to return statement here.

516
00:34:01.660 --> 00:34:07.180
And yes, I do have a return statement here, but this return statement is short circuiting the entire

517
00:34:07.180 --> 00:34:07.790
method.

518
00:34:07.840 --> 00:34:08.260
OK?

519
00:34:08.440 --> 00:34:12.760
Because consider what if we never got a match, right?

520
00:34:12.790 --> 00:34:14.530
What if there was no match here?

521
00:34:14.620 --> 00:34:22.510
What if I had a typo and I just typed in the wrong alias and nothing matches that for any of the columns

522
00:34:22.510 --> 00:34:22.930
at all?

523
00:34:23.140 --> 00:34:28.840
Then Line 105 would never be executed, and I would have an invalid method because there would be no

524
00:34:28.840 --> 00:34:32.530
return statement, even though this method says that it returns something.

525
00:34:32.830 --> 00:34:35.230
So I need to do something about that.

526
00:34:35.420 --> 00:34:41.440
Now, there's no alternative that I'm inclined to actually return from this method, to be honest with

527
00:34:41.440 --> 00:34:41.650
you.

528
00:34:41.800 --> 00:34:48.160
If this method can't find what I told it to look for, then we've got problems anyway that I can't really

529
00:34:48.160 --> 00:34:52.030
easily remedy by returning some made up value or something.

530
00:34:52.270 --> 00:35:01.060
So in that case, instead of trying to think of another alternative thing to return, I can just throw

531
00:35:01.060 --> 00:35:07.510
an exception so I can throw a new sequel exception because that's what we have declared here anyway.

532
00:35:07.540 --> 00:35:11.350
So I could add another type of exception on here, but I'm not inclined to do so.

533
00:35:11.530 --> 00:35:16.440
And this is largely illustrative purposes that I'm showing you this throw new exception.

534
00:35:16.450 --> 00:35:22.810
Now I can provide a string, which will be a message that will be seen so that I can understand why

535
00:35:22.810 --> 00:35:26.050
this exception is being thrown under this circumstance.

536
00:35:26.230 --> 00:35:32.200
And that would be a very good idea to do, and I'm going to use a string dot format to do this because

537
00:35:32.200 --> 00:35:37.930
I want to be able to specify a little bit of dynamic information here so I can say something like a

538
00:35:38.320 --> 00:35:42.250
column not found for Alias.

539
00:35:42.580 --> 00:35:46.420
And then I can maybe say percent as and then.

540
00:35:47.570 --> 00:35:51.450
And then just pass in the alias that this method was looking for.

541
00:35:51.490 --> 00:35:52.970
And let me close off that.

542
00:35:53.360 --> 00:35:53.840
There we go.

543
00:35:54.290 --> 00:35:55.820
And now no more errors.

544
00:35:55.820 --> 00:36:03.500
So I don't know if I ever said this explicitly, but methods that are expected to return something don't

545
00:36:03.500 --> 00:36:08.620
have to explicitly return something if they are throwing an exception.

546
00:36:08.630 --> 00:36:15.290
So my method here is saying under happy circumstances, go ahead and return what you found.

547
00:36:15.500 --> 00:36:19.250
But if you didn't find anything, then just throw an exception.

548
00:36:19.490 --> 00:36:22.820
Don't worry about throwing some other useless value.

549
00:36:22.820 --> 00:36:23.900
Just throw an exception.

550
00:36:24.020 --> 00:36:25.910
And that satisfies this method.

551
00:36:25.970 --> 00:36:31.610
All right, so sorry that that took way longer to show, but I think it was probably valuable to show

552
00:36:31.610 --> 00:36:32.810
you this for two reasons.

553
00:36:32.990 --> 00:36:38.540
First off, it never hurts to review a lot of these techniques that we've learned before, right?

554
00:36:38.690 --> 00:36:44.780
Using this loop here, and also a chance to see how to think about solving problems here.

555
00:36:44.810 --> 00:36:45.200
OK.

556
00:36:45.410 --> 00:36:47.930
These are problems that we encounter on the fly.

557
00:36:48.050 --> 00:36:54.380
In fact, I did not contrive this use case so that I would have an excuse to show you this code.

558
00:36:54.650 --> 00:37:01.610
I encountered this problem with you, and I'm showing you in almost real time how I as a professional

559
00:37:01.610 --> 00:37:05.060
developer would have to figure out a way to solve this.

560
00:37:05.540 --> 00:37:12.380
And I'm also showing you this because in this particular case, what if there hadn't been that H2 connection

561
00:37:12.380 --> 00:37:14.720
string option that we were able to add?

562
00:37:14.930 --> 00:37:16.580
I would have had to do this right?

563
00:37:16.940 --> 00:37:19.250
So there were a lot of good reasons to show you this.

564
00:37:19.250 --> 00:37:26.510
This is some good review and and you get a chance to see some more of the JTBC API where we dig in to

565
00:37:26.510 --> 00:37:27.890
the metadata, right?

566
00:37:28.190 --> 00:37:32.120
So you can think of this row here as metadata, essentially.

567
00:37:32.150 --> 00:37:32.600
OK.

568
00:37:33.170 --> 00:37:33.560
All right.

569
00:37:33.650 --> 00:37:38.150
So since we went ahead and wrote all of this, let's see if it actually works.

570
00:37:38.690 --> 00:37:46.910
So to test that out, I'm going to jump back over to the tests and let's just take this connection string

571
00:37:46.940 --> 00:37:54.650
option out like so and then let's just run all the tests again and see if everything still works.

572
00:37:55.140 --> 00:37:58.580
Oh, now if we're going to do that, let's see here, I guess.

573
00:37:58.590 --> 00:38:05.510
Let me comment out this line and then rename this to that there.

574
00:38:05.520 --> 00:38:06.050
There we go.

575
00:38:06.170 --> 00:38:11.150
OK, so now let's go ahead and rerun all the tests and see what we get.

576
00:38:12.920 --> 00:38:13.880
There we go.

577
00:38:13.970 --> 00:38:14.510
Very good.

578
00:38:14.720 --> 00:38:17.150
So that actually works, right?

579
00:38:17.750 --> 00:38:23.480
And I guess I'm going to go ahead and just leave that in because again, it's just a nice little chunk

580
00:38:23.480 --> 00:38:25.550
of code review for us.

581
00:38:26.000 --> 00:38:30.260
So now you saw two ways to get around this aliasing issue, though.

582
00:38:30.770 --> 00:38:34.790
And so I guess I can delete that line there.

583
00:38:35.540 --> 00:38:41.690
Oh, and and one more thing I'm so sorry I forgot about this original line here.

584
00:38:42.140 --> 00:38:44.310
So actually, let's do this.

585
00:38:44.330 --> 00:38:46.790
Let me move that line up above.

586
00:38:46.910 --> 00:38:53.240
And then and let me make this variable a rapper long.

587
00:38:53.360 --> 00:38:56.850
And that way, I can still test for null.

588
00:38:56.870 --> 00:38:59.650
Like I originally meant to do anyway, right?

589
00:38:59.660 --> 00:39:06.950
Because remember, this all started because I was saying if we encounter a table joined results set

590
00:39:07.220 --> 00:39:12.050
like here, where there is no address data like right here, right?

591
00:39:12.410 --> 00:39:17.950
Then in that case, this eight underscore ID alias column should actually be null.

592
00:39:17.960 --> 00:39:22.820
So I'm not depicting it here, but it should actually be like there's the word null here, right?

593
00:39:23.240 --> 00:39:28.880
And then I said, if that happens, then go ahead and just return a null.

594
00:39:28.940 --> 00:39:31.850
That's what we were originally going for.

595
00:39:32.390 --> 00:39:41.540
So to still make that work, I can now just replace all of this with A.D.D., our ID like.

596
00:39:41.540 --> 00:39:43.340
So and just to confirm that.

597
00:39:43.370 --> 00:39:46.070
Let me go ahead and run all the tests again.

598
00:39:48.880 --> 00:39:49.300
OK.

599
00:39:49.360 --> 00:39:49.990
Very good.

600
00:39:50.350 --> 00:39:51.070
All right.

601
00:39:51.310 --> 00:39:56.500
So I think we're in an OK place now with this functionality.

602
00:39:56.860 --> 00:39:57.220
OK.

603
00:39:57.400 --> 00:40:02.260
And so with that, we can go ahead and allow this lesson and I will see you for the next one.
