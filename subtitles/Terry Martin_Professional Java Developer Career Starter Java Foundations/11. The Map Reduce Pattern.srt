1
00:00:00,900 --> 00:00:01,440
All right.

2
00:00:01,470 --> 00:00:08,520
Welcome back to another exciting video in this lesson, we're going to learn about the MapReduce pattern.

3
00:00:08,970 --> 00:00:16,260
Now the MapReduce pattern is a very commonly used pattern in functional programming to allow developers

4
00:00:16,260 --> 00:00:23,760
to take large amounts of data and sift through it and and reduce it down to its essence or to a summary.

5
00:00:23,970 --> 00:00:28,860
An example of this would be something that we've actually already done before, where in fact, we've

6
00:00:28,860 --> 00:00:37,350
already kind of seen the MapReduce pattern in action a few lessons ago when we wrote a stream pipeline

7
00:00:37,350 --> 00:00:43,020
to process all of our employees and total up their salaries.

8
00:00:43,260 --> 00:00:49,520
The total of the salaries at the end was the was an example of a reduced function.

9
00:00:49,530 --> 00:00:53,400
The sum function that we used, in fact, was the reduced function.

10
00:00:53,640 --> 00:00:59,590
OK, so there are many other things that we can do with the MapReduce pattern, though.

11
00:00:59,610 --> 00:01:06,150
Besides just summing up a grand total of objects, we could count the number of objects we could get

12
00:01:06,150 --> 00:01:06,810
an average.

13
00:01:06,810 --> 00:01:13,710
We could find the max, the max value, a minimum value and also MapReduce doesn't necessarily only

14
00:01:13,710 --> 00:01:17,550
have to apply to numerical summaries, either.

15
00:01:17,730 --> 00:01:24,450
We can do things with other types of data as long as the end goal is to kind of summarize or condense

16
00:01:24,450 --> 00:01:25,380
the data down.

17
00:01:25,680 --> 00:01:29,640
All right, so let's turn to the ADP and play around with MapReduce.

18
00:01:30,150 --> 00:01:35,880
Oh, by the way, the map part of MapReduce is the mapping that we've already used before, where we

19
00:01:35,880 --> 00:01:44,550
use the map function to convert one data type to another or one, or to convert one object or item to

20
00:01:44,550 --> 00:01:45,330
another type.

21
00:01:45,540 --> 00:01:54,000
So for example, in our existing application, here we are using map to do things like convert from

22
00:01:54,000 --> 00:01:59,760
the text form of those lines that represent an employee into an actual employee.

23
00:01:59,850 --> 00:02:03,360
And in fact, we first convert to an AI employee, right?

24
00:02:03,570 --> 00:02:09,070
And then we do another mapping to convert from an employee to just a regular employee.

25
00:02:09,090 --> 00:02:11,340
So we use map in a lot of different ways.

26
00:02:11,850 --> 00:02:17,750
We even use Map again, I believe, to extract out the salary from the employee, right?

27
00:02:17,760 --> 00:02:19,830
So then we don't even care about the employee anymore.

28
00:02:19,830 --> 00:02:21,630
We're just focused on just the salary.

29
00:02:21,990 --> 00:02:24,810
So there are a lot of uses of the map function there.

30
00:02:24,810 --> 00:02:31,770
And now we'll learn more of the uses of of the of how we can reduce from a stream.

31
00:02:32,970 --> 00:02:39,060
All right, so turning to the ABC, let's just take a quick look again at some of the things I was just

32
00:02:39,060 --> 00:02:39,750
talking about.

33
00:02:39,750 --> 00:02:47,790
So here's a map here where we're taking the a stream of strings and then converting them into a stream

34
00:02:47,790 --> 00:02:48,990
of an employee.

35
00:02:49,170 --> 00:02:53,370
Then we're taking that stream and converting it into a stream of employee.

36
00:02:53,940 --> 00:02:54,680
Let's see.

37
00:02:54,690 --> 00:03:01,800
And then down here on line forty nine, we're even converting the employees after we've sorted and filtered

38
00:03:01,800 --> 00:03:02,370
them a bit.

39
00:03:02,550 --> 00:03:07,310
We're converting those employees into just their salaries.

40
00:03:07,340 --> 00:03:10,440
Now we're doing that here with a method reference.

41
00:03:10,450 --> 00:03:12,180
This is just a very quick review.

42
00:03:12,930 --> 00:03:17,760
And in here, we're just using this method reference so that we could get a print out to the terminal

43
00:03:18,180 --> 00:03:22,110
in addition to returning or extracting the salary, right?

44
00:03:22,740 --> 00:03:24,330
So we're doing all of those things.

45
00:03:24,330 --> 00:03:30,060
And then finally, we're pumping all of that into this some function here that we already learned about.

46
00:03:30,060 --> 00:03:36,780
So this some function is one of our reduced functions, right, because it takes all that data and reduces

47
00:03:36,780 --> 00:03:38,220
it down to a sum total.

48
00:03:39,060 --> 00:03:45,720
However, there are a number of additional methods that we can use besides just these some, and now

49
00:03:45,720 --> 00:03:47,190
we'll play around with some of those.

50
00:03:47,790 --> 00:03:48,240
All right.

51
00:03:48,660 --> 00:03:52,890
Oh, by the way, I did delete what we were previously working on.

52
00:03:52,920 --> 00:03:54,360
We don't need that anymore.

53
00:03:54,360 --> 00:03:55,450
So that's where that went.

54
00:03:55,470 --> 00:04:01,410
Sorry, I didn't show that on screen, and it looks like it looks like I may have deleted a bit too

55
00:04:01,410 --> 00:04:05,160
much because I think we were also printing out that some weren't we.

56
00:04:05,340 --> 00:04:08,490
So let's let me let me just add that back in real quick.

57
00:04:09,390 --> 00:04:09,840
OK.

58
00:04:10,620 --> 00:04:16,350
And I think I'm going to rename this variable sum because now we're about to use it to do a lot more

59
00:04:16,350 --> 00:04:21,210
things than just something as we experiment with additional reduced functions.

60
00:04:21,450 --> 00:04:27,510
So maybe I will just rename this variable to result or something for for now.

61
00:04:28,080 --> 00:04:30,110
OK, so let me just run this.

62
00:04:30,120 --> 00:04:32,280
Make sure that that all still works.

63
00:04:33,330 --> 00:04:34,110
OK, there we go.

64
00:04:34,110 --> 00:04:37,170
Yes, so was that 1.5 million or so?

65
00:04:37,210 --> 00:04:38,550
OK, that looks good.

66
00:04:39,810 --> 00:04:41,700
OK, so there's a sum.

67
00:04:41,970 --> 00:04:47,610
So let's just see what else can we do within the realm of the reduced functions?

68
00:04:47,760 --> 00:04:51,450
So there's a sum we can take an average.

69
00:04:53,550 --> 00:04:58,920
Now, the average method, if we hover over it, as you notice here, we as soon as I change that sum

70
00:04:58,920 --> 00:05:00,780
to average, we got squiggly lines here.

71
00:05:00,780 --> 00:05:03,180
So if we hover over this, we will see, OK.

72
00:05:03,420 --> 00:05:10,080
Now the problem here is that the average method does not return an integer, as the sum method was.

73
00:05:10,290 --> 00:05:14,130
This method is returning something called an optional double.

74
00:05:14,880 --> 00:05:19,620
Now we just learned in the last lesson what an optional is, but we didn't talk about an optional double.

75
00:05:19,620 --> 00:05:21,540
But it's it's pretty.

76
00:05:21,750 --> 00:05:22,950
It's pretty straightforward.

77
00:05:23,190 --> 00:05:30,570
It's really just a hybrid data type of an optional that can only hold doubles.

78
00:05:31,050 --> 00:05:38,130
The regular optional class can hold on to any type of class, but the optional double can only hold

79
00:05:39,270 --> 00:05:39,870
doubles.

80
00:05:40,920 --> 00:05:46,920
It's just being more specific, essentially, so that it can help to protect us from making stupid mistakes,

81
00:05:47,370 --> 00:05:49,950
since we already know that we're working with numbers here.

82
00:05:50,290 --> 00:05:56,340
So, so the main point of the optional double is the fact that if you're going to take an average,

83
00:05:56,730 --> 00:06:01,110
we know that the average that is calculated may not be an integer.

84
00:06:01,110 --> 00:06:04,140
In fact, that there's a high probability that it won't be an integer, right?

85
00:06:04,140 --> 00:06:05,340
Because how do you find an average?

86
00:06:05,340 --> 00:06:12,450
You take the grand total of summing up a bunch of numbers, right, divided by how many numbers or how

87
00:06:12,450 --> 00:06:14,700
many items were in that list, right?

88
00:06:15,570 --> 00:06:23,100
And so if the numerator is not evenly divisible by the denominator, then you're going to have fractional

89
00:06:23,100 --> 00:06:25,650
components to the to the result, right?

90
00:06:25,890 --> 00:06:29,010
And those cannot be conveyed via integer.

91
00:06:29,130 --> 00:06:33,450
You're going to need a data type with higher precision, such as a double.

92
00:06:33,660 --> 00:06:34,830
And so you need a double.

93
00:06:34,950 --> 00:06:35,450
Now why?

94
00:06:35,580 --> 00:06:42,420
Why are they making it optional while they're making it optional in case the average cannot be calculated

95
00:06:42,420 --> 00:06:43,260
for some reason?

96
00:06:43,380 --> 00:06:51,020
The most obvious reason would be that there are no items in the stream to even calculate on right.

97
00:06:51,030 --> 00:06:52,540
You could have an empty stream.

98
00:06:52,860 --> 00:06:55,170
And so what should you return there?

99
00:06:55,470 --> 00:07:02,190
And so rather than returning a zero, which may, you know, they could do that, they decided to be

100
00:07:02,190 --> 00:07:07,200
technically even more accurate and just make it an optional double right.

101
00:07:07,200 --> 00:07:13,680
And that way, if there are no items in the stream at all rather than return to zero, just return an

102
00:07:13,680 --> 00:07:19,080
empty, optional essentially right, and then the programmer can decide how they want to handle that.

103
00:07:19,170 --> 00:07:24,990
Maybe they want to convert an empty optional to a zero, or maybe they just want to test for whether

104
00:07:24,990 --> 00:07:30,570
or not the optional is empty and then say some string like, you know, no data found or something like

105
00:07:30,570 --> 00:07:30,870
that.

106
00:07:31,140 --> 00:07:31,490
All right.

107
00:07:31,500 --> 00:07:35,090
So that's the reason for the optional so to fix this.

108
00:07:35,100 --> 00:07:38,970
Now all we need to do is come down here and just click on this change.

109
00:07:38,970 --> 00:07:44,370
Variable result type two optional double and watch what will happen when I do this bam.

110
00:07:44,730 --> 00:07:50,130
The return data type switch from end to optional double right now down here.

111
00:07:50,790 --> 00:07:55,680
To make good use of that, I could just print this and it would give us something.

112
00:07:55,680 --> 00:08:01,140
In fact, you know, let's go ahead and just run this and see what we get if I just leave that result

113
00:08:01,410 --> 00:08:02,610
alone as it is.

114
00:08:03,840 --> 00:08:09,120
OK, so we get this thing here where it's saying like optional double and then it's kind of enclosing

115
00:08:09,120 --> 00:08:14,730
it in brackets there and then we get the actual average coming out of it right now.

116
00:08:14,730 --> 00:08:20,730
If we don't want it to be presented like that, which we don't, because that's like showing the raw

117
00:08:20,730 --> 00:08:21,420
data type.

118
00:08:21,420 --> 00:08:27,240
Essentially, it's calling the two string on the optional double data class data type.

119
00:08:28,020 --> 00:08:36,120
What we would probably prefer to do is to call one of the methods on the optional class and interpret

120
00:08:36,120 --> 00:08:38,070
this in some meaningful way.

121
00:08:38,970 --> 00:08:45,570
If we're certain that there is a value there, we could simply call the get as double method, which

122
00:08:45,570 --> 00:08:47,580
returns the actual double.

123
00:08:47,730 --> 00:08:52,080
However, if there is nothing in there, that's a bad idea.

124
00:08:53,340 --> 00:09:01,140
So in general, it's not well recommended that you use optional in that way where you call the get method

125
00:09:01,140 --> 00:09:03,930
right or in this case, the get as double method.

126
00:09:04,830 --> 00:09:12,960
A better approach would be to either call something like the or else method, which will return the

127
00:09:12,960 --> 00:09:15,390
value in the optional if it exists.

128
00:09:15,570 --> 00:09:21,630
But if it does not exist, then it will return a default or alternative value, right?

129
00:09:21,870 --> 00:09:23,870
And that's a pretty easy one to use.

130
00:09:23,880 --> 00:09:26,790
So we could say like, OK or else zero.

131
00:09:26,880 --> 00:09:30,840
So this is saying if result is not empty, then return.

132
00:09:30,840 --> 00:09:37,050
It's double value or else meaning if it is empty, then return in this case, a zero.

133
00:09:37,200 --> 00:09:39,450
So let's let's try running that.

134
00:09:41,280 --> 00:09:46,710
Here we go, and so now it just stripped off the optional double that they're right and we're getting

135
00:09:46,710 --> 00:09:48,840
the the true value.

136
00:09:49,320 --> 00:09:49,770
All right.

137
00:09:50,130 --> 00:09:54,450
So there's how to do an average very easily and straightforward.

138
00:09:54,460 --> 00:09:56,880
So keep in mind now, what does that actually doing?

139
00:09:57,030 --> 00:10:03,150
That's doing a couple of things that is determining the number of items, which in this case would be

140
00:10:03,150 --> 00:10:08,940
the number of integers that are coming out of this map to end this stream here.

141
00:10:09,180 --> 00:10:09,660
OK.

142
00:10:10,350 --> 00:10:12,300
Because it needs to know the count, right?

143
00:10:12,300 --> 00:10:17,550
The number, and then it's also taking, and then it's also determining the sum.

144
00:10:17,550 --> 00:10:21,480
So it's actually doing a little bit of what we were already doing previously with the sum, right?

145
00:10:21,780 --> 00:10:25,770
And then it's dividing those to get the to calculate the average.

146
00:10:26,850 --> 00:10:27,180
All right.

147
00:10:27,690 --> 00:10:28,590
But we can do more.

148
00:10:28,740 --> 00:10:30,840
We can find out the max salary.

149
00:10:30,960 --> 00:10:32,400
And that's pretty straightforward.

150
00:10:32,400 --> 00:10:34,200
We can just call the max method.

151
00:10:34,200 --> 00:10:36,690
Now, look at this as soon as I put this.

152
00:10:37,020 --> 00:10:41,400
As soon as I change that to Max, we get errors again if I hover over.

153
00:10:41,580 --> 00:10:46,110
Now it's returning an optional end short for optional integer.

154
00:10:46,140 --> 00:10:54,420
The max method here in this particular case knows that it's taking as an input a stream of integers,

155
00:10:54,600 --> 00:10:56,790
and it's going to sum up those integers.

156
00:10:56,790 --> 00:11:02,220
And so logically, it knows that the sum of integers is going to be another integer.

157
00:11:02,910 --> 00:11:11,220
However, just as with the average method, it is possible that that stream could be empty and therefore

158
00:11:11,790 --> 00:11:19,650
it models the result as an optional integer rather than just an integer, so that we can decide what

159
00:11:19,650 --> 00:11:25,500
we want to do in the event that it is in fact empty, rather than just assuming that it should just

160
00:11:25,830 --> 00:11:28,500
model empty as zero.

161
00:11:28,650 --> 00:11:29,100
OK.

162
00:11:29,760 --> 00:11:34,170
So, yeah, so we can change this by again, just clicking on this little thing here.

163
00:11:34,200 --> 00:11:36,690
That's the idea that's doing that for us, by the way.

164
00:11:36,870 --> 00:11:40,050
And so bam, now it changes that to an optional end.

165
00:11:40,440 --> 00:11:44,790
So let's find out what the max value is for our data set.

166
00:11:44,890 --> 00:11:48,600
Now, keep in mind, we're doing some filtering here.

167
00:11:49,710 --> 00:11:52,950
Let's see what else we doing and we're doing some skipping as well, right?

168
00:11:52,950 --> 00:11:56,270
So we're not really dealing with the entire dataset.

169
00:11:56,310 --> 00:11:59,790
We could remove some of these and maybe we'll play around with that, but it doesn't really matter right

170
00:11:59,790 --> 00:12:00,000
now.

171
00:12:00,180 --> 00:12:06,690
Anyway, let's go ahead and run this and see what the max salary is for the given filtered data set

172
00:12:06,690 --> 00:12:08,010
that we have at this time.

173
00:12:09,540 --> 00:12:10,370
OK.

174
00:12:10,400 --> 00:12:13,700
It looks like it's 1.5 million even.

175
00:12:13,710 --> 00:12:15,120
Yeah, one point five million.

176
00:12:15,300 --> 00:12:20,310
And if there's a max function, then you know there's going to be a mean function as well, right?

177
00:12:20,320 --> 00:12:23,970
To find the minimum salary in this stream, right?

178
00:12:24,420 --> 00:12:30,060
Thankfully, Max and men do essentially the opposite of the same thing, and so I don't need to change

179
00:12:30,060 --> 00:12:31,590
the return type there.

180
00:12:31,950 --> 00:12:32,390
All right.

181
00:12:32,400 --> 00:12:34,980
So let's run that and see what the minimum is.

182
00:12:36,570 --> 00:12:36,900
Cool.

183
00:12:36,900 --> 00:12:37,960
6500.

184
00:12:37,980 --> 00:12:38,430
All right.

185
00:12:38,670 --> 00:12:45,120
Now, if I put my cursor after the period and do a control space, we can take a look at a few more

186
00:12:45,120 --> 00:12:50,010
of the of the reduced methods that exist here because there are a number of them.

187
00:12:50,010 --> 00:12:52,670
So we've done max average men.

188
00:12:53,820 --> 00:12:54,810
Let's see.

189
00:12:55,200 --> 00:12:56,420
There's count.

190
00:12:57,330 --> 00:13:00,150
That's that's sometimes quite useful, right?

191
00:13:00,720 --> 00:13:01,920
Let's try that one out.

192
00:13:04,430 --> 00:13:11,090
All right, and again and again, we we get an error here, so if I hover over what's this going to

193
00:13:11,090 --> 00:13:13,130
return, OK, now this one returns along.

194
00:13:14,390 --> 00:13:18,020
Now if you're wondering, OK, what's up with this one?

195
00:13:18,320 --> 00:13:21,350
Well, the thing here is we're asking it to count, right?

196
00:13:21,590 --> 00:13:29,780
So even if the stream that precedes this step is empty, that should return a number, right, that

197
00:13:29,780 --> 00:13:31,090
should return a zero.

198
00:13:31,100 --> 00:13:37,130
If you're asking someone to count the number of things and there are and there is nothing to count.

199
00:13:37,520 --> 00:13:39,900
You should still say, well, there are zero.

200
00:13:39,920 --> 00:13:40,310
Right?

201
00:13:40,520 --> 00:13:46,070
And so we don't need to model this with an optional we can return an actual value.

202
00:13:46,220 --> 00:13:49,340
Now, if you're wondering, why is it a long instead of an end?

203
00:13:49,490 --> 00:13:51,560
Well, think about way back in.

204
00:13:51,570 --> 00:13:56,180
Was it Module two or whatever where we learned about number systems and things, right?

205
00:13:56,510 --> 00:14:01,640
You know that a long data type allows for a greater range of values than an end.

206
00:14:01,790 --> 00:14:02,000
Right.

207
00:14:02,040 --> 00:14:11,240
In fact, a long is twice the number of bits as an end right, an integer is 32 bits as long as 64 bits,

208
00:14:11,240 --> 00:14:15,930
and therefore we can represent much larger numbers when you're counting things in Java.

209
00:14:15,950 --> 00:14:19,670
Typically, you will want to model them with a long.

210
00:14:20,450 --> 00:14:26,600
Now, we don't usually model just counting things generically with big decimal, which could go even

211
00:14:26,600 --> 00:14:32,840
further or a big or a big integer, because that's a very heavy weight data type.

212
00:14:33,570 --> 00:14:40,700
Usually, we allow the long data type to suffice for most day to day Typekit counting.

213
00:14:40,850 --> 00:14:43,610
OK, so at any rate, that's why we're getting along.

214
00:14:43,700 --> 00:14:46,790
So again, we'll just click here and have that data type change.

215
00:14:46,970 --> 00:14:53,270
Now here I get an error because now that I'm no longer getting an optional of some sort back, there

216
00:14:53,270 --> 00:14:54,740
are no methods on long.

217
00:14:54,770 --> 00:15:00,560
Long is a primitive data type, and therefore it does not implement any methods, right?

218
00:15:00,560 --> 00:15:02,570
So I need to delete that there.

219
00:15:02,870 --> 00:15:08,990
And let's run this and see how many records or how many employees it's counting.

220
00:15:09,500 --> 00:15:13,520
What really technically it's how many integers it's counting.

221
00:15:14,090 --> 00:15:15,620
OK, so we're only getting back four.

222
00:15:16,310 --> 00:15:16,870
All right.

223
00:15:16,880 --> 00:15:24,470
So there's count, and that's probably going to cover these convenience, reduce functions and by convenience,

224
00:15:24,470 --> 00:15:29,630
I mean, like, they're all, you know, wrapped up in a nice, pretty bow and ready for us to just

225
00:15:29,630 --> 00:15:31,070
use just like this.

226
00:15:31,190 --> 00:15:38,120
However, there there is one more reduced function that I want to take a look at, and it's kind of

227
00:15:38,120 --> 00:15:40,610
like the granddaddy of all of what we've seen here.

228
00:15:41,450 --> 00:15:45,650
It's a it's a lower level function and it's actually just called reduce.

229
00:15:45,830 --> 00:15:47,890
So let's take a look at that now.

230
00:15:47,900 --> 00:15:55,130
So if we select this word here and then put in Reduce and we'll first play around with with the first

231
00:15:55,130 --> 00:15:56,420
version of this here.

232
00:15:57,590 --> 00:16:03,050
So this first overloaded version of the reduced function takes two inputs.

233
00:16:03,290 --> 00:16:08,780
It takes something called an identity, which in this case will be of type entry, and then it takes

234
00:16:08,780 --> 00:16:11,380
something called an end binary operator.

235
00:16:11,390 --> 00:16:13,850
Don't be frightened by these names.

236
00:16:14,540 --> 00:16:20,870
So into binary operator, that just means this is one of our functional interfaces, OK?

237
00:16:21,950 --> 00:16:29,930
And this is an interface that defines one functional method on it that takes two integer inputs.

238
00:16:30,590 --> 00:16:31,080
OK.

239
00:16:31,100 --> 00:16:34,850
And then it returns one integer value out.

240
00:16:35,060 --> 00:16:35,570
OK.

241
00:16:35,840 --> 00:16:42,140
This reduced function allows us to actually implement a lot of the reduced functions that we just were

242
00:16:42,140 --> 00:16:46,190
playing with before, like the sum marksmen.

243
00:16:46,340 --> 00:16:50,990
So in fact, let's go ahead and try re implementing some of those so that you can see what that would

244
00:16:50,990 --> 00:16:51,620
look like.

245
00:16:51,650 --> 00:16:52,040
OK.

246
00:16:52,400 --> 00:16:58,550
So let me go ahead and just type it out first, and then I'll I'll circle back around and explain in

247
00:16:58,550 --> 00:17:00,320
detail how it's working.

248
00:17:00,470 --> 00:17:07,010
So if we wanted to do a sum right, the sum function using this lower level reduce, what we would do

249
00:17:07,010 --> 00:17:13,130
is we would set the identity to zero, which I will explain why in just a moment, and then we would

250
00:17:13,130 --> 00:17:17,870
supply it with a lambda or a method or a method reference, if you like.

251
00:17:18,470 --> 00:17:26,310
But a lambda sufficient here and our lambda expression will need to essentially sum up two numbers.

252
00:17:26,330 --> 00:17:26,780
OK.

253
00:17:27,110 --> 00:17:34,850
So it's a lambda expression that describes a method that will take two inputs that need to be summed

254
00:17:34,850 --> 00:17:35,510
together.

255
00:17:35,540 --> 00:17:37,790
OK, so two inputs.

256
00:17:37,790 --> 00:17:43,790
So we'll call them A and B, and then we've got our Arrow operator here, and then we're going to simply

257
00:17:43,790 --> 00:17:45,800
say a plus b.

258
00:17:47,080 --> 00:17:47,590
That's it.

259
00:17:49,000 --> 00:17:49,330
All right.

260
00:17:49,360 --> 00:17:51,550
So let's run that and see if it works.

261
00:17:52,620 --> 00:17:53,220
There we go.

262
00:17:53,250 --> 00:17:53,520
OK.

263
00:17:53,550 --> 00:17:58,860
One point five million, I believe that is what we got originally when we did just our basic thumb before.

264
00:17:59,220 --> 00:17:59,580
All right.

265
00:17:59,590 --> 00:18:02,450
So now let me explain how this is working.

266
00:18:02,460 --> 00:18:07,910
It's less it's not as complicated as it might be looking to explain this.

267
00:18:07,920 --> 00:18:10,680
I'm going to turn to a spreadsheet.

268
00:18:12,230 --> 00:18:14,570
All right, so here we are in a spreadsheet.

269
00:18:14,780 --> 00:18:21,980
Let's pretend like we have our integer stream with the values 10, nine, seven, five and two in it.

270
00:18:22,370 --> 00:18:24,830
And here are our A and B.

271
00:18:24,890 --> 00:18:29,870
So let me show you what the the reduced function is doing currently.

272
00:18:30,320 --> 00:18:35,300
Basically, what it's going to do is it's going to start off by taking this.

273
00:18:37,120 --> 00:18:46,540
This first value, which is called an identity, and it's going to plug that in to this a here, then

274
00:18:46,540 --> 00:18:55,390
it's going to take the first number in the stream and plug that in to B, then it's going to take these

275
00:18:55,390 --> 00:18:59,860
two values and call our lambda, which in this case would say zero plus 10.

276
00:19:00,190 --> 00:19:03,910
And it's going to take the result of that, which would be a 10.

277
00:19:05,500 --> 00:19:10,510
Then it takes that result and it calls the lambda expression again.

278
00:19:10,780 --> 00:19:17,140
But this time it passes in the result of the previous iteration, which is 10, and it plugs that into

279
00:19:17,170 --> 00:19:26,140
a then it grabs the next value in the stream, which is a nine, and then it does the lambda and executes

280
00:19:26,140 --> 00:19:29,440
lambda expression, which is to add those which would be 19.

281
00:19:30,370 --> 00:19:36,190
Then it just comes down to the next iteration takes that previous value of 19 in this case.

282
00:19:37,870 --> 00:19:41,800
And then it plugs in the next value from the stream, which is a seven.

283
00:19:44,500 --> 00:19:47,410
And then it adds those up, which will be twenty six.

284
00:19:49,430 --> 00:19:52,400
And then so on and so forth, so I think you get the pattern right.

285
00:19:53,060 --> 00:19:58,880
It just keeps taking the result of the previous iteration and bringing it down into the A.

286
00:19:59,090 --> 00:20:04,910
Then it gets the next value and puts that in B and then it does whatever the operation is.

287
00:20:04,920 --> 00:20:08,420
So the key thing here is to understand that

288
00:20:11,240 --> 00:20:15,250
the operation that we're doing is is pluggable, right?

289
00:20:15,260 --> 00:20:16,960
That's the part that we supply.

290
00:20:16,970 --> 00:20:21,140
If we jump back over here, we are supplying this.

291
00:20:21,290 --> 00:20:26,420
And really, out of all of this, what we're really supplying when you get right down to it is just

292
00:20:26,420 --> 00:20:27,020
this bit here.

293
00:20:27,020 --> 00:20:28,880
In fact, it's even smaller than that.

294
00:20:28,880 --> 00:20:34,640
It's really just the operation, literally like the the plus in this particular case, right?

295
00:20:34,940 --> 00:20:36,710
That's what we're really supplying.

296
00:20:36,710 --> 00:20:40,160
Like, what is it that we should do with a and B, right?

297
00:20:40,550 --> 00:20:43,520
All the rest of this is can can be thought of as boilerplate.

298
00:20:43,520 --> 00:20:50,600
The fact that you're always going to be given two numbers or two values rather and you're going to do

299
00:20:50,600 --> 00:20:52,520
something with those two values.

300
00:20:52,520 --> 00:21:00,480
And the result of that is going to be plugged back in as one of the two values for the next cycle.

301
00:21:00,500 --> 00:21:00,970
OK.

302
00:21:02,870 --> 00:21:08,390
So that is the essence of a reduced function, and that is how it works.

303
00:21:09,350 --> 00:21:13,060
The reason for the identity should hopefully be kind of obvious.

304
00:21:13,070 --> 00:21:22,160
It is simply so that when you're starting the iteration process, you're starting with a value that

305
00:21:22,160 --> 00:21:26,630
serves as an identity for the type of operation you're doing.

306
00:21:26,630 --> 00:21:33,980
And by identity, I mean, for a given operation and identity will give you whatever value you're plugging

307
00:21:33,980 --> 00:21:34,190
in.

308
00:21:34,200 --> 00:21:37,940
So in this case, we're plugging in a 10 and we're doing addition.

309
00:21:38,090 --> 00:21:43,820
So what value can we use with 10 and addition that will return a 10 back?

310
00:21:44,030 --> 00:21:45,530
That would be zero, right?

311
00:21:45,680 --> 00:21:52,070
If you want to get out of this addition operation the value that you're plugging in, which in this

312
00:21:52,070 --> 00:21:55,160
case is just the 10, you need to use a zero.

313
00:21:55,280 --> 00:22:02,180
If we're doing multiplication and you're passing in a 10, what value can you combine with that?

314
00:22:02,180 --> 00:22:05,450
10 for multiplication to get back out a 10?

315
00:22:05,480 --> 00:22:06,590
That would be a one, right?

316
00:22:06,590 --> 00:22:09,880
Because ten times one gives you whatever.

317
00:22:10,070 --> 00:22:12,530
In fact, that's the identity, right?

318
00:22:12,920 --> 00:22:21,530
So we are supplying the identity value that will allow us to get back out what we put in for that very

319
00:22:21,530 --> 00:22:23,240
first iteration, right?

320
00:22:23,240 --> 00:22:27,860
So that you're kind of like initializing the iteration, if you will.

321
00:22:28,070 --> 00:22:28,490
OK.

322
00:22:29,120 --> 00:22:29,360
All right.

323
00:22:29,370 --> 00:22:33,890
So let's try a slightly more complex one now.

324
00:22:34,340 --> 00:22:39,530
What if we wanted to implement our own max function here, right?

325
00:22:39,960 --> 00:22:43,580
Max function using the reduced function here?

326
00:22:43,820 --> 00:22:44,960
How could we do that?

327
00:22:45,170 --> 00:22:49,040
Do you want to try to take a stab at trying this out yourself first?

328
00:22:49,970 --> 00:22:50,690
Why don't you?

329
00:22:50,690 --> 00:22:53,300
And then I'll show you how I would do this.

330
00:22:54,440 --> 00:22:54,740
All right.

331
00:22:54,800 --> 00:22:55,430
Did you get it?

332
00:22:56,180 --> 00:22:56,690
All right.

333
00:22:57,230 --> 00:23:03,650
So here's the thing if we want to find the MAX, let's just speak in English and figure out what are

334
00:23:03,650 --> 00:23:04,580
we trying to do here?

335
00:23:04,580 --> 00:23:08,690
So we've got a list of numbers, right?

336
00:23:09,290 --> 00:23:13,160
And we want to find out what is the largest number there.

337
00:23:13,340 --> 00:23:19,100
So what we're likely going to do is we're just going to be comparing the previous number to the next

338
00:23:19,100 --> 00:23:20,660
number and just keep going.

339
00:23:20,810 --> 00:23:24,260
And if one wins, then we then we keep that one.

340
00:23:24,710 --> 00:23:29,660
So in in this case, here would actually be nicer, I suppose.

341
00:23:31,090 --> 00:23:37,450
So since we want to do the Max, let me it might be actually a little nicer if we flip this around.

342
00:23:37,900 --> 00:23:38,980
Let me let me do that.

343
00:23:39,010 --> 00:23:43,800
Let me put these around to 15 percent.

344
00:23:44,710 --> 00:23:52,780
OK, so if we had this stream of integers and we wanted to find the max, right?

345
00:23:53,800 --> 00:24:01,390
Well, we know that we'd have some reduced function that was going to start off with a zero and a two,

346
00:24:01,390 --> 00:24:02,490
presumably, right?

347
00:24:02,500 --> 00:24:05,440
So we'll even just plug those in real quick here.

348
00:24:06,040 --> 00:24:06,430
All right.

349
00:24:06,610 --> 00:24:07,660
So what do we want to do?

350
00:24:07,670 --> 00:24:11,560
What operation do we want to do that, should we?

351
00:24:11,770 --> 00:24:16,000
That should result in us getting a two out of this right now?

352
00:24:16,000 --> 00:24:20,740
Obviously, we could do in addition, in this particular case for this one iteration, and that would

353
00:24:20,740 --> 00:24:21,430
give us a two.

354
00:24:21,430 --> 00:24:24,610
But as soon as we came down here, in fact, here we'll just do it.

355
00:24:24,850 --> 00:24:26,320
We'll think this through a little bit.

356
00:24:26,770 --> 00:24:27,150
Oops.

357
00:24:29,670 --> 00:24:35,220
Two and five right now, as soon as we get down here to two and five, obviously we we don't want to

358
00:24:35,220 --> 00:24:37,140
do addition because that would yield to seven.

359
00:24:37,260 --> 00:24:39,630
What we would want instead is to get a five.

360
00:24:39,900 --> 00:24:44,100
So what operation is there, in fact, here?

361
00:24:44,250 --> 00:24:45,450
Let's do one more.

362
00:24:45,780 --> 00:24:51,600
So then we'd want the five here and we'd want the seven here.

363
00:24:51,660 --> 00:24:52,140
OK.

364
00:24:53,310 --> 00:24:58,650
In fact, let me show what what the what the winning results should be in each of these two should win

365
00:24:58,650 --> 00:24:59,910
here, right?

366
00:25:00,750 --> 00:25:05,310
Then five should win and then seven should win.

367
00:25:05,340 --> 00:25:12,780
OK, so now the question is simply what operation can we do that would give us these results, given

368
00:25:12,780 --> 00:25:14,400
these two inputs right?

369
00:25:14,550 --> 00:25:16,290
That's what we need to figure out.

370
00:25:17,700 --> 00:25:29,430
So what we could use here is a simple, conditional check really combined with like a greater than or

371
00:25:29,430 --> 00:25:33,180
something like that, greater than or less than however you want to look at it.

372
00:25:33,900 --> 00:25:43,320
So, for example, we could say something like if zero is greater than to then return zero.

373
00:25:43,950 --> 00:25:54,480
Otherwise or else return to or stated more algebraically, I suppose if A is greater than B, then return

374
00:25:54,480 --> 00:26:00,430
a ealth return B and then you would get it to and then you'd bring the two down here.

375
00:26:00,450 --> 00:26:01,920
Well, you wouldn't bring the two down here.

376
00:26:01,920 --> 00:26:06,000
The reduced function would bring the two down and then it would do it all over again.

377
00:26:06,180 --> 00:26:15,780
If A is greater than B, then return a alth return B and then you'd get a five, right?

378
00:26:16,350 --> 00:26:18,330
So I think we figured out our logic in general.

379
00:26:18,330 --> 00:26:24,510
We just want to implement a conditional that says if A is greater than B, then return a Else. return

380
00:26:25,020 --> 00:26:25,710
B, right?

381
00:26:26,460 --> 00:26:35,070
Or you could flip flip it around and say if A is less, then B then return B else return.

382
00:26:35,340 --> 00:26:39,600
You could flip it around, but that feels a little less straightforward somehow.

383
00:26:41,370 --> 00:26:44,940
Now what's the most concise way that we could do that, right?

384
00:26:45,570 --> 00:26:47,850
There's a way that we could do that in one line, can you think?

385
00:26:47,850 --> 00:26:49,590
Did you think of what that was already?

386
00:26:50,730 --> 00:26:51,060
All right.

387
00:26:51,060 --> 00:26:53,280
So we can simply use a ternary?

388
00:26:53,460 --> 00:26:53,820
Right?

389
00:26:54,180 --> 00:26:56,160
So let's go ahead and implement this now.

390
00:26:57,090 --> 00:27:05,730
So we want to say for a and B, if A is greater than B, now, here's where the IFF comes from.

391
00:27:05,730 --> 00:27:10,200
If you remember how to use the ternary, there's there's kind of like you're if at least that's how

392
00:27:10,200 --> 00:27:17,400
I think of it, the question mark, I think of that as being the if if a is greater than B, then return

393
00:27:17,400 --> 00:27:18,590
a l.

394
00:27:18,660 --> 00:27:20,790
S Return B.

395
00:27:21,810 --> 00:27:22,500
There you go.

396
00:27:22,950 --> 00:27:29,580
Right now, it's not the most readable thing here, but that's how Turner's always look right.

397
00:27:29,580 --> 00:27:32,610
So you just got to get used to reading a ternary like this.

398
00:27:33,240 --> 00:27:39,440
If A is greater than B, then return a else, return B.

399
00:27:39,810 --> 00:27:40,100
Right?

400
00:27:40,680 --> 00:27:47,580
So that should give us the max value out of this entire list.

401
00:27:47,580 --> 00:27:48,930
So let's run it and see.

402
00:27:50,490 --> 00:27:51,000
There it is.

403
00:27:51,000 --> 00:27:57,000
And I remember that from when we actually just used the max method directly, we got a one point five

404
00:27:57,000 --> 00:27:57,390
million.

405
00:27:57,390 --> 00:27:59,830
So that is working right now.

406
00:27:59,940 --> 00:28:02,640
Let's do the opposite and do a men, right?

407
00:28:02,640 --> 00:28:05,940
So here, let's see if we can just flip that around.

408
00:28:06,180 --> 00:28:12,070
If A is less than B, then return a otherwise return B, I think that's all we need there, right?

409
00:28:12,090 --> 00:28:13,980
We just flip that operation around.

410
00:28:14,190 --> 00:28:19,800
Let's run that and I think we got a 6500, if I recall correctly.

411
00:28:21,420 --> 00:28:23,310
Now this is a fun one.

412
00:28:23,580 --> 00:28:24,510
We got a zero.

413
00:28:24,810 --> 00:28:26,820
Does anyone know why we got a zero here?

414
00:28:28,970 --> 00:28:35,810
It's because the minimum value out of all of this is going to be the zero again, turning back over

415
00:28:35,810 --> 00:28:36,200
here.

416
00:28:36,530 --> 00:28:38,000
There's the zero there, right?

417
00:28:38,000 --> 00:28:40,760
So zero is going to win every single time.

418
00:28:41,120 --> 00:28:43,070
How can we prevent that?

419
00:28:43,310 --> 00:28:46,370
I can think of two ways, one of which I haven't taught you yet.

420
00:28:46,880 --> 00:28:48,860
Still using the reduced function.

421
00:28:49,250 --> 00:28:56,990
So maybe one thing we could do is just initialize that to a really large number, right?

422
00:28:58,540 --> 00:29:00,370
Let's let's see what happens if we do that.

423
00:29:00,730 --> 00:29:04,810
So actually, to be honest with you, it doesn't even need to be all that large.

424
00:29:05,980 --> 00:29:14,890
So maybe if we just set it to the max value that we already saw was at one point five one to three,

425
00:29:14,890 --> 00:29:15,190
right?

426
00:29:15,910 --> 00:29:17,560
So now let's run this.

427
00:29:18,490 --> 00:29:19,020
There we go.

428
00:29:19,030 --> 00:29:20,440
There's our 6500.

429
00:29:20,710 --> 00:29:30,340
So having seen this now, I would I would suggest that probably if you wanted to use the reduced function

430
00:29:30,340 --> 00:29:34,930
to find a men, which I don't even know why you would want to do that, though, instead of just calling

431
00:29:34,930 --> 00:29:36,460
the men function itself.

432
00:29:36,490 --> 00:29:36,850
Right?

433
00:29:37,000 --> 00:29:38,530
That's probably what you really should do.

434
00:29:38,770 --> 00:29:46,090
But if for some reason you're looking for the minimum or something or a pattern similar to this, you

435
00:29:46,090 --> 00:29:51,710
need to be really careful and aware about this identity business here.

436
00:29:51,760 --> 00:29:52,210
OK?

437
00:29:52,690 --> 00:30:00,490
For exactly this reason, that identity that you are supplying could could cause you problems, basically.

438
00:30:01,180 --> 00:30:09,610
Now that being said, I want to go ahead and show you the other overloaded version of the reduce function

439
00:30:09,610 --> 00:30:16,420
because there's another version that doesn't require us to supply an identity at all.

440
00:30:16,720 --> 00:30:19,680
But watch what happens when I use this one.

441
00:30:19,690 --> 00:30:21,740
Bam, everything blows up again.

442
00:30:21,880 --> 00:30:25,750
So let's see why if I hover over any of the red squiggly lines.

443
00:30:25,900 --> 00:30:36,850
So the other version of Reduce is the same, except it doesn't take the identity and it returns an optional

444
00:30:36,850 --> 00:30:37,240
end.

445
00:30:37,240 --> 00:30:41,260
In this case, it returns an optional for whatever the stream data type is.

446
00:30:41,270 --> 00:30:43,630
So in our case, we're passing in it.

447
00:30:43,660 --> 00:30:46,600
We're working previously with an end to end stream.

448
00:30:46,810 --> 00:30:49,060
And so all of the values will be integers.

449
00:30:49,060 --> 00:30:53,250
If we were using doubles or whatever, then it would be optional double right?

450
00:30:54,190 --> 00:30:57,270
It's Typekit, all right.

451
00:30:57,280 --> 00:31:02,680
So it returns an optional end, and it does so for the same reasons as we learned with some of those

452
00:31:03,040 --> 00:31:06,880
other reduced functions that we looked at earlier.

453
00:31:07,090 --> 00:31:13,450
It could be that there are no values in the stream, and it doesn't want to just assume that it should

454
00:31:13,450 --> 00:31:14,440
return a zero.

455
00:31:14,680 --> 00:31:21,130
Now, the reason that the other version of Reduced doesn't go ahead and just return an optional of some

456
00:31:21,130 --> 00:31:26,710
sort is because of that identity because we're passing in that identity.

457
00:31:27,190 --> 00:31:35,620
It should not be possible to not have some value at all, basically turning back over here again, even

458
00:31:35,620 --> 00:31:42,760
if this list were empty because we had to pass in that identity and we were passing in, for example,

459
00:31:42,760 --> 00:31:45,370
a zero, you'd at least have a zero.

460
00:31:45,760 --> 00:31:46,100
Right?

461
00:31:46,120 --> 00:31:51,460
That's that's the basic idea behind the other version of Reduce.

462
00:31:51,760 --> 00:31:59,560
And so the versions of reduce that, take the identity don't need to consider the case where there's

463
00:31:59,560 --> 00:32:04,000
nothing at all in the in the stream, right, that where the stream is empty.

464
00:32:04,750 --> 00:32:05,040
All right.

465
00:32:05,050 --> 00:32:10,720
So coming back over here, so again, we'll just hover over this and then click on this to change that

466
00:32:10,720 --> 00:32:11,440
data type.

467
00:32:11,800 --> 00:32:12,490
There we go.

468
00:32:12,730 --> 00:32:18,910
And then we'll come down here to the result and we'll do something a little better than whatever.

469
00:32:19,270 --> 00:32:22,180
And I don't know, I'll make this negative one.

470
00:32:23,350 --> 00:32:24,040
All right.

471
00:32:25,570 --> 00:32:29,290
So now if we run this, let's see what we get.

472
00:32:31,060 --> 00:32:31,900
OK, so cool.

473
00:32:31,940 --> 00:32:33,490
Now we get our 6500.

474
00:32:33,490 --> 00:32:41,620
So this this reduced function that doesn't take the identity is reasonably smart.

475
00:32:41,830 --> 00:32:47,710
Now you may be wondering, well, how is it figuring out what to do if we're not passing in the identity?

476
00:32:47,950 --> 00:32:52,300
So let's jump over to the spreadsheet and we'll take a look at what it's doing.

477
00:32:53,500 --> 00:33:03,610
OK, so what this version of Reduced does, since we're not supplying it with an identity to start with,

478
00:33:04,210 --> 00:33:11,560
what it does is it simply takes the first value in the list and returns it.

479
00:33:12,130 --> 00:33:12,640
OK?

480
00:33:12,880 --> 00:33:18,440
And then each subsequent iteration then picks up where that left off.

481
00:33:18,470 --> 00:33:24,100
OK, so it's just going to say, OK, two, well, I'm just going to bring that two over and then just

482
00:33:24,100 --> 00:33:25,180
keep going that way.

483
00:33:25,300 --> 00:33:26,290
That's all it's doing.

484
00:33:26,980 --> 00:33:30,220
Now we'll see in a moment here that that will have some interesting.

485
00:33:31,000 --> 00:33:37,630
I don't know if you want to call it a side effect, but an interesting effect, particularly if you're

486
00:33:37,630 --> 00:33:39,400
not working with numbers.

487
00:33:40,000 --> 00:33:42,760
Well, let's see, even if you are working with numbers.

488
00:33:43,420 --> 00:33:44,710
Hey, and I got one more thing.

489
00:33:44,710 --> 00:33:49,480
I want to show you really quickly that we can do with the reduced method here.

490
00:33:50,110 --> 00:33:56,890
So here we're passing in this lambda expression to implement, you know, the ability to find the minimum

491
00:33:56,890 --> 00:33:57,430
and we've looked.

492
00:33:57,500 --> 00:34:00,980
At How to do Maxson and sums and things of that sort.

493
00:34:01,880 --> 00:34:08,240
And obviously, you also could just not use the reduce and use some of the built in streams API or in

494
00:34:08,240 --> 00:34:16,010
this case, the entire stream API methods that also let us some and find the men and find the MAX.

495
00:34:16,190 --> 00:34:21,690
One more way that I want to show you, though, just so you just for complete completeness.

496
00:34:22,670 --> 00:34:25,190
We could also do this.

497
00:34:25,760 --> 00:34:32,060
You can use them a method reference, and there are some methods that that are given to us for free

498
00:34:32,060 --> 00:34:33,160
to do these same things.

499
00:34:33,220 --> 00:34:39,320
OK, so on the integer class, for example, look at that there's a min max and some right there.

500
00:34:39,620 --> 00:34:44,700
So you can just pass that in and that's going to do what you think it should write.

501
00:34:44,990 --> 00:34:48,530
Just like we could use Max, I'll run that real quick.

502
00:34:49,760 --> 00:34:50,150
OK.

503
00:34:50,360 --> 00:34:51,710
So I think you get the idea.

504
00:34:51,890 --> 00:34:58,010
Just remember, pretty much any method that will take a lambda expression will also take a method reference

505
00:34:58,010 --> 00:35:01,550
as long as they both are adhering to the expected interface.

506
00:35:01,880 --> 00:35:03,530
So that's all I wanted to show you there.

507
00:35:04,250 --> 00:35:04,550
All right.

508
00:35:04,560 --> 00:35:13,430
So I mentioned at the beginning of this lesson that these reduce functions can be used for more than

509
00:35:13,430 --> 00:35:14,390
just numbers.

510
00:35:14,960 --> 00:35:17,120
So let's see one or two examples of that.

511
00:35:17,540 --> 00:35:23,850
So I think what I will do here is just just make a few lines.

512
00:35:23,870 --> 00:35:25,340
This will just be some quick thing.

513
00:35:25,460 --> 00:35:26,780
So let's use some words.

514
00:35:28,610 --> 00:35:33,410
Let's create a stream of words.

515
00:35:33,830 --> 00:35:40,940
And I think what we can do is simply start off by typing the word stream of and then we can pass in

516
00:35:40,940 --> 00:35:41,690
whatever we like.

517
00:35:41,690 --> 00:35:43,100
Now, I need to import that.

518
00:35:44,030 --> 00:35:45,380
So let's pass.

519
00:35:45,380 --> 00:35:48,470
In some words, let's pass the names, Tom.

520
00:35:50,240 --> 00:35:50,960
Terry.

521
00:35:52,900 --> 00:35:53,650
Mary.

522
00:35:55,260 --> 00:35:56,340
And Sam.

523
00:35:58,910 --> 00:35:59,250
All right.

524
00:35:59,270 --> 00:36:05,630
So here's a stream, and then let's do some things with this stream, so let's call the reduced function

525
00:36:07,190 --> 00:36:09,770
and we'll use the second.

526
00:36:10,070 --> 00:36:14,420
We'll use the version of the reduced function that does not require an identity.

527
00:36:15,680 --> 00:36:20,270
And well, here let me first tell you what we're actually trying to do here.

528
00:36:20,280 --> 00:36:31,010
So let's let's let's start off by making this reduce function that will take these names and maybe just

529
00:36:31,280 --> 00:36:37,760
concatenate them essentially something like Tom underscore Jerry underscore Mary underscore Sam.

530
00:36:37,760 --> 00:36:39,800
OK, let's just spit that out.

531
00:36:39,920 --> 00:36:40,880
So think about that.

532
00:36:41,120 --> 00:36:45,620
You've got this stream of individual names, right?

533
00:36:46,010 --> 00:36:53,400
And all we're wanting to do is to reduce them down to one string, one concatenated string, right?

534
00:36:53,450 --> 00:37:00,200
So that's an example of how we can use a reduced function on non numeric data, right?

535
00:37:00,500 --> 00:37:05,840
As long as we're essentially just taking the list of things or the stream of things and then spitting

536
00:37:05,840 --> 00:37:15,410
out one one combined or summarized output, that's basically what the reduced function is for.

537
00:37:15,500 --> 00:37:16,640
So how can we do this?

538
00:37:16,790 --> 00:37:22,730
Do you want to take a stab at thinking of how you can implement a reduced function to do this?

539
00:37:22,730 --> 00:37:23,870
Why don't you try that?

540
00:37:26,290 --> 00:37:26,710
All right.

541
00:37:26,740 --> 00:37:27,370
Did you get it?

542
00:37:28,090 --> 00:37:30,110
OK, so now let me try.

543
00:37:30,130 --> 00:37:31,380
So let's see here.

544
00:37:31,390 --> 00:37:38,770
So we're going to have a a lambda expression that we know is going to take two values A and B.

545
00:37:38,800 --> 00:37:39,190
Right?

546
00:37:39,550 --> 00:37:44,050
So here's our a comma B and then our arrow here.

547
00:37:44,470 --> 00:37:50,770
And so what we're going to want to do, I think, is something like a dog can cat.

548
00:37:53,470 --> 00:37:54,610
Underscore.

549
00:37:55,640 --> 00:37:57,320
Dot can cat.

550
00:37:58,690 --> 00:37:59,140
Be.

551
00:38:01,610 --> 00:38:02,780
I think that is.

552
00:38:04,310 --> 00:38:05,610
I think that's all we need there.

553
00:38:06,440 --> 00:38:08,720
And then we'll want to capture that.

554
00:38:12,950 --> 00:38:16,550
Output, I'll just call it, and then we'll print that.

555
00:38:17,410 --> 00:38:17,980
Output.

556
00:38:18,730 --> 00:38:19,040
All right.

557
00:38:19,060 --> 00:38:23,350
Let's run that and see if that does what what we're looking for.

558
00:38:24,280 --> 00:38:27,070
Yeah, it does what we're looking for, except for it, I forgot to.

559
00:38:27,820 --> 00:38:34,870
I forgot to extract out the actual raw value from the optional because this is returning an optional

560
00:38:34,880 --> 00:38:35,190
right.

561
00:38:35,200 --> 00:38:36,730
It's an optional of a string.

562
00:38:37,030 --> 00:38:42,640
And that's because we're not using any identity, you know, initializing identity, right?

563
00:38:42,940 --> 00:38:47,980
So yeah, let's let's extract that out or else.

564
00:38:49,850 --> 00:38:50,280
I don't know.

565
00:38:50,300 --> 00:38:52,730
We'll just do A. quotes for that for now.

566
00:38:52,910 --> 00:38:53,160
All right.

567
00:38:53,180 --> 00:38:56,750
So at any rate, that works the way that we expected it to.

568
00:38:58,030 --> 00:39:02,530
Now, let me show you something kind of interesting here.

569
00:39:03,010 --> 00:39:10,090
Let's modify this to uppercase everything, OK?

570
00:39:10,300 --> 00:39:13,330
So if we wanted this to uppercase everything.

571
00:39:13,690 --> 00:39:19,900
And so now that's the output, by the way, I just uppercase that selection by doing a command shift.

572
00:39:19,930 --> 00:39:25,990
You and I can toggle it up and down with that same command shift you which or control shift you for

573
00:39:25,990 --> 00:39:26,950
Windows and Linux.

574
00:39:28,000 --> 00:39:30,520
So, yeah, that's sometimes really convenient.

575
00:39:30,610 --> 00:39:32,380
So that's the output that we want.

576
00:39:32,650 --> 00:39:35,620
So again, you want to take a moment to figure out how to do that.

577
00:39:37,390 --> 00:39:37,840
All right.

578
00:39:37,840 --> 00:39:39,280
So let's see.

579
00:39:39,280 --> 00:39:41,950
Now, here's how I might do that.

580
00:39:41,980 --> 00:39:45,090
A dot to uppercase.

581
00:39:45,100 --> 00:39:51,790
I'll take this version here and then concatenate an underscore and then concatenate a b.

582
00:39:54,600 --> 00:39:55,830
To upper case.

583
00:39:56,900 --> 00:39:57,440
All right.

584
00:39:57,500 --> 00:40:00,380
Let's let's run that and see what we get.

585
00:40:02,080 --> 00:40:02,390
Yeah.

586
00:40:02,410 --> 00:40:02,830
Cool.

587
00:40:02,920 --> 00:40:04,480
Tom, Jerry, Mary, Sam.

588
00:40:04,750 --> 00:40:05,320
Very good.

589
00:40:05,620 --> 00:40:13,990
Now here's the thing I want to show you what happens if there's only one item in this list, right?

590
00:40:15,430 --> 00:40:21,190
So let's I'm just going to delete these guys and just leave just Tom.

591
00:40:21,760 --> 00:40:22,600
Watch this.

592
00:40:22,690 --> 00:40:23,160
Now, what do you?

593
00:40:23,200 --> 00:40:25,060
First off, what do you think is going to happen?

594
00:40:26,970 --> 00:40:27,360
All right.

595
00:40:27,600 --> 00:40:28,380
So let's see.

596
00:40:30,060 --> 00:40:31,620
Oh, look at that.

597
00:40:31,650 --> 00:40:34,980
We just got Tom all by himself, right?

598
00:40:35,010 --> 00:40:35,790
Nothing else.

599
00:40:36,030 --> 00:40:40,520
Is that what you were expecting for some of you may be?

600
00:40:40,530 --> 00:40:41,010
Yes.

601
00:40:41,190 --> 00:40:42,990
I bet for some of you, maybe no.

602
00:40:43,440 --> 00:40:49,590
So this proves that when we don't supply an identity, if we jump back over here to the spreadsheet,

603
00:40:49,770 --> 00:40:56,370
this proves that when we don't supply an identity, that very first iteration that the reduced function

604
00:40:56,370 --> 00:41:02,670
is going to do simply takes whatever you passed in and then just like spits it back out without trying

605
00:41:02,670 --> 00:41:05,820
to do anything else on it because there is nothing else it can do right?

606
00:41:06,210 --> 00:41:08,100
Let me be a little more explicit here.

607
00:41:08,340 --> 00:41:16,710
So if Tom was what we passed, then then on that very first iteration, A is going to kind of be left

608
00:41:16,710 --> 00:41:18,000
blank, essentially.

609
00:41:18,240 --> 00:41:21,060
And Tom's going to get dropped in there.

610
00:41:21,060 --> 00:41:28,470
And the logic of the reduced function itself is going to say, if I only have one item in the stream,

611
00:41:28,830 --> 00:41:33,030
then don't even bother applying that item to the lambda.

612
00:41:33,210 --> 00:41:39,600
Just spit that same item right back out again, which would be this one right here.

613
00:41:40,260 --> 00:41:43,620
And in this particular case, you're done right?

614
00:41:43,860 --> 00:41:45,900
And so it didn't get processed.

615
00:41:46,050 --> 00:41:53,040
And we're seeing the proof of that right here by the fact that it didn't uppercase or our concatenate

616
00:41:53,040 --> 00:41:59,280
an underscore or anything, you would need at least two items in the stream for that to happen.

617
00:41:59,490 --> 00:42:05,100
And so if I add back in one more Brady, I'm not a sports guy.

618
00:42:05,370 --> 00:42:07,650
That's just the name that popped up in my head.

619
00:42:08,760 --> 00:42:13,590
I mean, I guess I know enough sports to know that there's a sports guy named Tom Brady, and that's

620
00:42:13,590 --> 00:42:14,370
about all I know.

621
00:42:15,150 --> 00:42:15,830
There you go.

622
00:42:15,840 --> 00:42:18,030
And now you get a Tom underscore Brady.

623
00:42:18,030 --> 00:42:18,720
All caps.

624
00:42:19,050 --> 00:42:19,410
Right?

625
00:42:20,940 --> 00:42:21,490
All right.

626
00:42:21,500 --> 00:42:23,460
So this was a little bit long.

627
00:42:23,460 --> 00:42:30,690
But I think a very important lesson because the MapReduce pattern can be highly effective when needing

628
00:42:30,690 --> 00:42:34,020
to process large amounts of data.

629
00:42:34,410 --> 00:42:40,080
Now one last thing I want to say about that pattern is one of the reasons why it's so darn popular is

630
00:42:40,080 --> 00:42:46,440
because when you get into these functional techniques like MapReduce, one of their benefits is that

631
00:42:46,440 --> 00:42:48,420
they can easily be parallel.

632
00:42:48,950 --> 00:42:56,040
And what that means is you can implement these techniques in such a way that you can process lots of

633
00:42:56,040 --> 00:42:58,410
data across multiple processes.

634
00:42:58,410 --> 00:43:01,020
We've already touched on this in previous lessons.

635
00:43:01,290 --> 00:43:10,680
But the MapReduce pattern together lends itself exceedingly well to being parallel lysed or or implemented

636
00:43:10,680 --> 00:43:12,560
across multiple processors.

637
00:43:12,570 --> 00:43:20,250
So let's say again to use some of my previous examples that we've got a list, if you will, of one

638
00:43:20,250 --> 00:43:22,710
billion items, right?

639
00:43:22,800 --> 00:43:25,680
One billion employees, one billion, whatever, right?

640
00:43:25,890 --> 00:43:33,990
And we need to determine something like the grand total sum of some property of all of those items,

641
00:43:33,990 --> 00:43:34,320
right?

642
00:43:34,530 --> 00:43:42,060
Well, basically, what can be done in that case is that that large list of one billion can be segmented

643
00:43:42,420 --> 00:43:47,440
into groupings, right, depending on how many processors you have.

644
00:43:47,460 --> 00:43:53,610
For example, let's say you have 10 processors, so one billion divided by 10.

645
00:43:53,880 --> 00:44:01,550
So then in that case, the computer might choose to segment out 10 groups of a billion.

646
00:44:01,560 --> 00:44:05,820
So you'd get 100 million items per grouping, right?

647
00:44:06,030 --> 00:44:10,830
And then those hundred million each would be fed into their own processor.

648
00:44:11,040 --> 00:44:16,650
And then that processor could could sift through that data and sum up whatever the property is that

649
00:44:16,650 --> 00:44:17,700
you're looking for there.

650
00:44:17,820 --> 00:44:22,050
And then it would spit out the result of all of that, right?

651
00:44:22,050 --> 00:44:23,070
Just that result.

652
00:44:23,190 --> 00:44:25,620
So you've just done a map reduce.

653
00:44:25,620 --> 00:44:29,520
Although in this case, I'm not really talking too much about the map part, right?

654
00:44:29,520 --> 00:44:36,630
But you've reduced the hundred million on that one processor down to just one value and the other and

655
00:44:36,630 --> 00:44:40,170
the other nine processors would presumably do the same thing.

656
00:44:40,410 --> 00:44:44,880
And then all of their values can get summed up together as well.

657
00:44:44,880 --> 00:44:51,570
And bam, now you've got the grand total and you were able to arrive at it, presumably in one tenth

658
00:44:51,570 --> 00:44:56,950
the time, roughly minus the overhead of doing the segmentation and all of that.

659
00:44:56,970 --> 00:44:57,810
We won't get into that.

660
00:44:57,810 --> 00:45:04,710
But you know, hypothetically, theoretically, roughly, you know, one tenth the time that it would

661
00:45:04,710 --> 00:45:11,920
have taken if you only had one processor sifting through all one billion of those records all at once.

662
00:45:11,950 --> 00:45:12,230
Right.

663
00:45:12,240 --> 00:45:23,310
So the MapReduce pattern is extremely important to get familiar with when you do more of these types

664
00:45:23,310 --> 00:45:26,730
of parallel processing for large amounts of data and things of that sort.

665
00:45:26,970 --> 00:45:29,100
All right, so let's wrap this up.

666
00:45:29,200 --> 00:45:31,060
And I will see you in the next one.
