WEBVTT
1
00:00:00.300 --> 00:00:05.760
All right, so we ran all the tests and almost everything worked, except for this can find all method

2
00:00:06.030 --> 00:00:07.560
and we're getting this issue here.

3
00:00:07.560 --> 00:00:10.530
Column not found for alias parent I.D..

4
00:00:10.860 --> 00:00:16.140
All right, so let's jump back over here, and that sounds super familiar to one of the other issues

5
00:00:16.140 --> 00:00:17.640
that we've seen a little bit ago.

6
00:00:18.120 --> 00:00:23.880
All right, I'm clicking on this line 151 people repository because it's the first line that I can do

7
00:00:23.880 --> 00:00:26.610
something about in our stack trace, right?

8
00:00:27.120 --> 00:00:30.030
And so that's just where we're throwing that exception to.

9
00:00:30.030 --> 00:00:30.930
That's not telling me much.

10
00:00:30.930 --> 00:00:36.690
So now I'm going to go to the previous line right before that people repository here.

11
00:00:36.990 --> 00:00:38.370
OK, so here we are.

12
00:00:38.400 --> 00:00:42.210
Column not found for alias parent underscore I.D..

13
00:00:42.300 --> 00:00:52.500
OK, so now I think I'm going to run just this test in debug mode, so I'm going to double click on

14
00:00:52.500 --> 00:00:57.600
it, come up here to the top of it and run and debug.

15
00:00:58.050 --> 00:01:00.360
OK, so let's see what we've got here.

16
00:01:00.370 --> 00:01:04.170
First off, I'm curious what is this alias prefix set to?

17
00:01:04.320 --> 00:01:11.220
So it is parent underscore I.D. And then I think I'm going to just step in to this get value by Alias,

18
00:01:11.220 --> 00:01:12.690
so similar to what we did before.

19
00:01:12.690 --> 00:01:13.800
So I'm going to step in.

20
00:01:14.160 --> 00:01:14.820
OK?

21
00:01:15.090 --> 00:01:20.580
And then I'm going to step over this column count business here.

22
00:01:20.820 --> 00:01:25.290
And if I hover over this, the column count is five currently, OK?

23
00:01:25.650 --> 00:01:33.300
And so now we're setting up our loop and we are looking for parent underscore I.D..

24
00:01:33.630 --> 00:01:37.560
Now I do still have a watch variable set up for restart.

25
00:01:37.560 --> 00:01:41.460
That metadata don't get column label, which is right here now.

26
00:01:41.460 --> 00:01:46.660
Currently, it's not reporting anything because we're not inside of this loop yet.

27
00:01:46.740 --> 00:01:47.160
OK.

28
00:01:47.340 --> 00:01:54.530
So as soon as I step over and into this loop now I'm getting a value of I.D..

29
00:01:54.650 --> 00:01:55.530
Ah, OK.

30
00:01:55.740 --> 00:01:58.830
And so instantly I can see what the issue is now.

31
00:01:59.370 --> 00:02:08.220
The issue here is that the label that we are getting for column one is not parent underscore ID, it

32
00:02:08.220 --> 00:02:09.270
is simply ID.

33
00:02:09.840 --> 00:02:10.360
OK.

34
00:02:10.380 --> 00:02:16.590
And that makes sense because we did not change the SQL for our find all query to use aliases, right?

35
00:02:16.830 --> 00:02:18.930
It's just doing it the original way.

36
00:02:19.200 --> 00:02:20.700
So let's see what we need to do here.

37
00:02:20.700 --> 00:02:23.790
Do we need to update the sequel for our find all?

38
00:02:23.790 --> 00:02:26.850
Or can we fix the code so that it would work either way?

39
00:02:27.150 --> 00:02:28.050
Let's just see.

40
00:02:28.500 --> 00:02:35.730
So I'm going to actually step backward in our stack here to see how we got here in the first place.

41
00:02:36.210 --> 00:02:36.570
All right.

42
00:02:36.580 --> 00:02:37.860
So let's see.

43
00:02:37.860 --> 00:02:44.790
There's that call, and I'm stepping back again to the extract entity from results set, and I think

44
00:02:44.790 --> 00:02:50.520
I want to step back even further, maybe all the way back to the credit repository itself, because

45
00:02:50.520 --> 00:02:52.790
I want to see what method is, is call it.

46
00:02:52.800 --> 00:03:00.210
So it is the find all method that we are in, and then I'm going to jump back in to this extract entity

47
00:03:00.210 --> 00:03:01.530
from results set.

48
00:03:01.680 --> 00:03:02.190
OK.

49
00:03:02.220 --> 00:03:04.290
And I think I see it right here.

50
00:03:04.500 --> 00:03:12.120
So yes, we have hardcoded the fact that the parents should always be depended with this prefix of the

51
00:03:12.120 --> 00:03:17.880
word parent underscore and our Find All sequel, which is up here.

52
00:03:17.920 --> 00:03:21.270
Find All Sequel is not expecting that, right?

53
00:03:21.660 --> 00:03:24.360
So there's at least a couple of ways we could fix this.

54
00:03:24.660 --> 00:03:30.480
The most straightforward way, I think, would be to just revise the sequel to alias all of these columns

55
00:03:30.750 --> 00:03:33.190
with the word parent in front of them.

56
00:03:33.210 --> 00:03:34.890
That would be one way of doing it.

57
00:03:35.010 --> 00:03:41.430
The other way would be to determine if there is a way of knowing whether or not we need to use this

58
00:03:41.430 --> 00:03:42.360
prefix.

59
00:03:42.930 --> 00:03:50.400
I'm kind of inclined, though, to just revise our sequel to go ahead and add in the aliases because

60
00:03:50.580 --> 00:03:57.450
we might someday want find all to be capable of retrieving the parents with their children.

61
00:03:57.660 --> 00:04:00.330
And in that case, we're going to need this prefix anyway.

62
00:04:00.360 --> 00:04:08.010
So I think that would be probably the way to go here is just to revise the sequel now to add in the

63
00:04:08.040 --> 00:04:09.000
aliases.

64
00:04:09.150 --> 00:04:16.500
So I'm going to stop this test, and one way I can do that is by coming down here to this little to

65
00:04:16.500 --> 00:04:21.570
greater than symbols, which immediately turns into this pop up thing here and now I can hit that stop

66
00:04:21.570 --> 00:04:22.770
button right there.

67
00:04:23.750 --> 00:04:28.960
All right, so I just killed that test because I got my answer, I think I understand why that test

68
00:04:28.960 --> 00:04:29.470
failed.

69
00:04:30.460 --> 00:04:37.480
OK, so what I'm going to do now is convert this find all sequel into a tax block first.

70
00:04:39.310 --> 00:04:46.690
Like so and then I'm just going to reformat it a little bit, and in fact, I'm wondering if I can pretty

71
00:04:46.690 --> 00:04:49.630
much just copy everything that I've got up here.

72
00:04:49.630 --> 00:04:58.720
So let's see, select parent I.D. first name, last name, date of birth, salary, and I'm actually

73
00:04:58.720 --> 00:05:00.900
missing a few things in an email.

74
00:05:00.910 --> 00:05:04.030
I don't even think we're grabbing the email down here.

75
00:05:04.060 --> 00:05:04.690
No, we're not.

76
00:05:04.870 --> 00:05:08.740
OK, so yeah, let's see if we can just grab.

77
00:05:09.720 --> 00:05:16.620
All of that, and maybe it will go down to a new line, though, and maybe it will put the from clause

78
00:05:16.620 --> 00:05:18.520
on its own line as well.

79
00:05:18.540 --> 00:05:21.900
And then just paste right over that.

80
00:05:22.260 --> 00:05:25.360
Well, that's a lot of stuff, isn't it, from people?

81
00:05:25.380 --> 00:05:30.570
Now we're going to have to do a few changes here as well because we'll need an alias here from people

82
00:05:30.570 --> 00:05:31.230
as.

83
00:05:32.670 --> 00:05:38.490
Parent and I think that's what we have up here, yes, from people as parent and then that first 100

84
00:05:38.490 --> 00:05:41.670
rows, and I think that might be all we need.

85
00:05:41.730 --> 00:05:42.030
All right.

86
00:05:42.040 --> 00:05:44.880
So let's just try running this one test.

87
00:05:45.060 --> 00:05:50.940
So I'm double clicking on can find all and then I'm going to come up here and just run that one test.

88
00:05:51.390 --> 00:05:51.740
All right.

89
00:05:51.750 --> 00:05:56.740
So still failing column not found for alias child I.D..

90
00:05:57.270 --> 00:06:02.550
OK, so let's jump in to the Stack Trace here in a minute.

91
00:06:03.060 --> 00:06:07.410
So I just started at this at the top of the stack trace, but that's a little too deep.

92
00:06:07.710 --> 00:06:14.610
So I'm going to back off by one, and I think I'm going to back off again to the extract entity method

93
00:06:14.610 --> 00:06:14.760
here.

94
00:06:14.790 --> 00:06:17.880
So here we are trying to get a child now in this case.

95
00:06:18.240 --> 00:06:24.690
Our school doesn't even try to join to grab the children, and I'm going to leave that school the way

96
00:06:24.690 --> 00:06:28.440
that it is for now, because I think ideally this should work either way.

97
00:06:28.470 --> 00:06:33.510
So what we're going to do now is modify our code to be a little more flexible.

98
00:06:33.660 --> 00:06:34.110
OK.

99
00:06:34.590 --> 00:06:39.060
So we're jumping into this extract person method and we're looking for a child.

100
00:06:39.420 --> 00:06:45.450
So I'm going to jump in there myself, and then we're doing get value by alias and we're looking for

101
00:06:45.450 --> 00:06:46.530
that child ID.

102
00:06:46.980 --> 00:06:52.980
And currently, what we do is we're saying if we can't find what we were looking for, then just throw

103
00:06:52.980 --> 00:06:54.180
a school exception.

104
00:06:54.330 --> 00:06:57.360
But maybe now we don't want to do that.

105
00:06:57.510 --> 00:07:02.040
Maybe now we could consider, perhaps just returning a null.

106
00:07:02.250 --> 00:07:03.550
Let's let's see here.

107
00:07:03.900 --> 00:07:10.170
So if we go back to the method that's calling this one, which I just went back one to the extract person

108
00:07:10.170 --> 00:07:10.740
method here.

109
00:07:10.750 --> 00:07:17.370
So we're saying go get the value of the child underscore ID in this particular case.

110
00:07:17.640 --> 00:07:24.960
So if there is no column called child underscore I.D. In fact, we've already coded this in such a way

111
00:07:24.960 --> 00:07:31.950
as to say that if what we get back from this call is null, then just return an empty object.

112
00:07:31.960 --> 00:07:35.730
So I think, yeah, let's jump back over here again.

113
00:07:35.730 --> 00:07:42.210
So maybe now we don't want to be throwing an exception, and instead we just want to return a null.

114
00:07:42.600 --> 00:07:44.220
So let's see what that would look like.

115
00:07:45.030 --> 00:07:49.440
So I'm going to select all of this and instead just say return null.

116
00:07:49.590 --> 00:07:51.090
And I think that's it.

117
00:07:51.270 --> 00:07:53.340
Let's run this again and see what we get.

118
00:07:53.640 --> 00:07:53.910
All right.

119
00:07:53.910 --> 00:07:54.930
Still fails.

120
00:07:55.140 --> 00:07:59.080
So we were expecting one to be greater than or equal to 10.

121
00:07:59.100 --> 00:08:07.590
OK, so now I think we are hitting the original issue that I was thinking we were going to have to address,

122
00:08:08.100 --> 00:08:14.100
which is if we come back up here to our extract entity from results, that method here.

123
00:08:14.760 --> 00:08:15.030
All right.

124
00:08:15.030 --> 00:08:17.700
So here's what I think is happening now.

125
00:08:17.730 --> 00:08:24.660
We're in this situation right here, where for each person in our results set the current row or the

126
00:08:24.660 --> 00:08:31.110
current person that we're iterating over is not going to match essentially the previous person that

127
00:08:31.110 --> 00:08:33.040
we encountered in our results set.

128
00:08:33.060 --> 00:08:34.320
So let's see here.

129
00:08:34.500 --> 00:08:39.420
Since the database is closed at the moment, I'm not going into school into scroll sequel, but I think

130
00:08:39.420 --> 00:08:40.770
I can show this even here.

131
00:08:41.010 --> 00:08:44.160
So let's pretend like these are all parents now, OK?

132
00:08:44.520 --> 00:08:48.390
And so our first row is Jerry Smith.

133
00:08:48.720 --> 00:08:54.900
So let's say we're iterating through all of this code for the very first time and we land on our first

134
00:08:54.900 --> 00:08:56.280
row of Jerry Smith.

135
00:08:56.520 --> 00:09:01.350
So we extract Terry Smith and we set Jerry Smith on current parent.

136
00:09:01.560 --> 00:09:05.580
Then we get down here to final parent, which if this is the very first time we're going through all

137
00:09:05.580 --> 00:09:07.590
of this code, final parent will be null.

138
00:09:08.100 --> 00:09:13.410
So then we decide to set the Jerry Smith on final parent.

139
00:09:13.420 --> 00:09:19.620
So now current parent and final parent are both pointing to Jerry Smith object.

140
00:09:19.680 --> 00:09:21.660
OK, and then we get down here.

141
00:09:21.660 --> 00:09:23.460
Final Parent does not equal current parent.

142
00:09:23.460 --> 00:09:26.490
That won't be true, so this isn't going to do anything.

143
00:09:26.790 --> 00:09:31.320
And then we jump down here and now we're trying to extract the child, which in this particular case,

144
00:09:31.320 --> 00:09:34.440
we're not querying or joining to the child data.

145
00:09:34.440 --> 00:09:35.820
And so there won't be any child.

146
00:09:36.060 --> 00:09:39.570
And we do whatever we want to do with the addresses, those don't really matter.

147
00:09:40.110 --> 00:09:40.530
OK.

148
00:09:40.950 --> 00:09:42.890
And so all of the rest of this works out, OK.

149
00:09:42.900 --> 00:09:44.670
And then we do an arrest start next.

150
00:09:45.060 --> 00:09:51.720
This call here is going to take us now to the next row, which in this case would be Frank Jones.

151
00:09:51.730 --> 00:09:54.750
So again, let's pretend like all of these are just parents, OK?

152
00:09:55.110 --> 00:09:57.750
And then we're going to jump back up here to the top of this loop.

153
00:09:57.750 --> 00:10:01.920
So now we're going to extract Frank Jones and then we get here.

154
00:10:01.920 --> 00:10:04.260
Final parent is not null now.

155
00:10:04.290 --> 00:10:11.550
Final parent equals Jerry Smith, OK, because that's what we said on it from the first row final parent

156
00:10:11.730 --> 00:10:18.030
currently equals Jerry Smith, so we're going to skip over all of this and now we get here.

157
00:10:18.390 --> 00:10:27.750
If Final Parent, which is Jerry Smith, does not equal current parent, which is Frank Jones, then

158
00:10:27.750 --> 00:10:28.830
that would be true.

159
00:10:29.460 --> 00:10:31.410
And so now we will be on line 109.

160
00:10:31.410 --> 00:10:32.190
However, we're not.

161
00:10:32.230 --> 00:10:35.830
Actually doing anything here yet, but I think we're going to need to.

162
00:10:35.990 --> 00:10:39.400
OK, so currently nothing's going to happen here.

163
00:10:39.610 --> 00:10:46.210
So then we're going to do all of these things and then jump down here and call start next again, which

164
00:10:46.210 --> 00:10:51.830
is going to advance our row counter to Ann Jackson.

165
00:10:51.850 --> 00:10:52.330
OK.

166
00:10:52.420 --> 00:10:53.620
And then we're going to jump back up here.

167
00:10:53.620 --> 00:10:53.890
So.

168
00:10:54.050 --> 00:10:58.150
So as you can see, what's going to happen is we're going to iterate all over all of these parents,

169
00:10:58.270 --> 00:10:59.080
essentially.

170
00:10:59.380 --> 00:11:04.930
And then when we're done iterating over all of them that came back in our results set, whether it's

171
00:11:05.080 --> 00:11:11.290
five, 10 or 100, we will then return one parent, final parent.

172
00:11:11.770 --> 00:11:15.370
So what will have happened to all of these other parents?

173
00:11:15.610 --> 00:11:20.410
They will effectively have just been ignored, and that's not quite what we want.

174
00:11:20.530 --> 00:11:26.950
So what should be happening is we're going to extract Jerry Smith starting back over again.

175
00:11:26.950 --> 00:11:33.460
We're going to extract Jerry Smith right here and final parent would be null pretending, pretending

176
00:11:33.460 --> 00:11:35.080
like we're starting over from scratch.

177
00:11:35.200 --> 00:11:36.460
Final parent would be no.

178
00:11:36.580 --> 00:11:39.490
So we will set final parent to Jerry Smith.

179
00:11:39.490 --> 00:11:44.170
Then we will advance to the next row, which would be Frank Jones.

180
00:11:44.800 --> 00:11:46.450
We come back up here again.

181
00:11:47.050 --> 00:11:48.760
We extract Frank Jones.

182
00:11:48.790 --> 00:11:50.950
We skip over this bit.

183
00:11:51.610 --> 00:11:58.000
Then we determine that Frank Jones is not equal to Jerry Smith right here and now.

184
00:11:58.000 --> 00:12:05.620
What should happen, I think, is that I think we should break out of this loop right here and just

185
00:12:05.620 --> 00:12:11.080
return what we already had and final parent, which would have been Jerry Smith.

186
00:12:11.380 --> 00:12:16.810
If we just do that, then the rest of our credit repository framework will work properly.

187
00:12:17.170 --> 00:12:24.640
So when we get here, I think all we need to do is two things we need to back up our road cursor back

188
00:12:24.640 --> 00:12:32.950
to this first row and then we need to break out of this loop, which will allow us to return Jerry Smith

189
00:12:32.980 --> 00:12:37.500
right here because Jerry Smith is what will have been in the final parent variable.

190
00:12:37.510 --> 00:12:42.610
So we will return Jerry Smith and then we return back up to.

191
00:12:46.600 --> 00:12:54.730
In this case, back up to the find all method, which would then advance here down to the next row of

192
00:12:54.730 --> 00:12:55.630
Frank Jones.

193
00:12:55.750 --> 00:13:00.910
So in other words, when we're doing a fine final, each time we proceed to a new row and that's a different

194
00:13:00.910 --> 00:13:04.240
person from the previous parent that we had retrieved.

195
00:13:04.660 --> 00:13:11.830
We want to break out of our extract person method and back up one and then allow this find all method

196
00:13:11.830 --> 00:13:13.660
to do all of that advancing.

197
00:13:13.690 --> 00:13:14.140
OK.

198
00:13:14.290 --> 00:13:15.190
I hope that's clear.

199
00:13:15.190 --> 00:13:20.950
I know this is kind of hard to explain well, but that's why I'm taking the time to kind of really step

200
00:13:20.950 --> 00:13:22.210
through the steps.

201
00:13:22.210 --> 00:13:23.430
OK, walk through the steps.

202
00:13:23.440 --> 00:13:23.740
OK?

203
00:13:23.950 --> 00:13:28.960
So let me go ahead and implement it, and then maybe I will walk through those steps with you one more

204
00:13:28.960 --> 00:13:29.440
time.

205
00:13:29.530 --> 00:13:34.300
OK, so again, we're going to jump into the people repo here.

206
00:13:34.600 --> 00:13:37.420
So I think all we need to do is two steps here.

207
00:13:37.600 --> 00:13:41.530
We need to back up our road counter by one.

208
00:13:41.860 --> 00:13:46.030
So we were back up to row one again, OK, in this case.

209
00:13:46.300 --> 00:13:48.290
So to do that, we can do an R-Sport.

210
00:13:48.310 --> 00:13:57.840
Previous that just makes the row cursor back up one and then we can break out of this do while loop,

211
00:13:57.850 --> 00:14:03.850
and then that's going to simply return back the previous row that we had already extracted.

212
00:14:03.910 --> 00:14:04.360
OK.

213
00:14:04.660 --> 00:14:08.260
So let's try running this first and make sure that I'm right.

214
00:14:08.620 --> 00:14:12.430
And then if this works, I'm going to explain it one more time.

215
00:14:15.000 --> 00:14:16.620
Oh, and it still doesn't work.

216
00:14:16.920 --> 00:14:21.840
Let's see here the result set is not scrollable and cannot be reset.

217
00:14:22.080 --> 00:14:26.370
You may need to use connection that create statement.

218
00:14:27.480 --> 00:14:31.470
Result, set type, scroll insensitive are OK.

219
00:14:31.500 --> 00:14:31.860
All right.

220
00:14:32.160 --> 00:14:38.430
So it's this telling me that we're not allowed to scroll around and go back to the previous role with

221
00:14:38.430 --> 00:14:43.450
the current way that we created our statement, but it's giving us a hint of how we should do that.

222
00:14:43.470 --> 00:14:50.550
OK, so let's jump back up to the find all method here.

223
00:14:50.790 --> 00:14:53.740
And here's where we are creating our prepared statement.

224
00:14:53.760 --> 00:14:56.460
So let's see what other options we've got here.

225
00:14:56.610 --> 00:14:59.690
If we can do what it pretty much is suggesting.

226
00:14:59.700 --> 00:15:06.030
So currently we are using this version of the prepare statement method where we are only passing in

227
00:15:06.030 --> 00:15:11.040
our SQL string, but there are some other versions of this as well.

228
00:15:11.280 --> 00:15:17.910
And maybe we can look at this second one here where it takes the sequel string and then it takes a result

229
00:15:17.920 --> 00:15:22.110
set type and a result set concurrency.

230
00:15:22.140 --> 00:15:24.060
So let's see what our options are here.

231
00:15:24.360 --> 00:15:31.320
So I'm going to put my cursor right there and then put a comma and then say, Result set dot.

232
00:15:32.610 --> 00:15:35.220
And now I can choose a result set type.

233
00:15:35.340 --> 00:15:40.590
Now, hold on a second here because my screen is scrolling off, I'm kind of scrolling off the screen

234
00:15:40.590 --> 00:15:41.160
a little bit.

235
00:15:41.280 --> 00:15:44.950
In fact, here at what I'll do to make sure that you can see this is I'm going to hit enter.

236
00:15:45.450 --> 00:15:45.790
All right.

237
00:15:45.810 --> 00:15:48.090
And now results set in.

238
00:15:48.090 --> 00:15:49.800
Let me also get some space here.

239
00:15:49.800 --> 00:15:53.460
Results that dot type scroll insensitive.

240
00:15:53.880 --> 00:15:56.080
So that's what it's suggested we do.

241
00:15:56.130 --> 00:15:56.410
All right.

242
00:15:56.430 --> 00:15:58.140
Let's see our options here again.

243
00:15:58.500 --> 00:16:01.530
And let me also reformat this a little bit better.

244
00:16:02.340 --> 00:16:02.580
All right.

245
00:16:02.620 --> 00:16:05.030
So I'm doing a command p.

246
00:16:05.040 --> 00:16:10.840
And so it is expecting one more parameter to be passed in here, which is the results.

247
00:16:10.860 --> 00:16:12.000
Add concurrency.

248
00:16:12.450 --> 00:16:15.060
So let me go ahead and specify that as well.

249
00:16:16.270 --> 00:16:19.210
Comma result set.

250
00:16:19.630 --> 00:16:21.160
Dot concur.

251
00:16:21.190 --> 00:16:26.470
Read only now I will explain these options in just a moment here, but first, let's just see if we

252
00:16:26.470 --> 00:16:27.550
can get this to work.

253
00:16:28.300 --> 00:16:29.590
Oh, there we go.

254
00:16:29.620 --> 00:16:30.220
There we go.

255
00:16:30.280 --> 00:16:30.760
OK.

256
00:16:31.270 --> 00:16:31.540
All right.

257
00:16:31.570 --> 00:16:33.550
Now let me explain what we just did.

258
00:16:34.150 --> 00:16:41.740
So if we jump back into our extract entity from results set method here in the people repository, let

259
00:16:41.740 --> 00:16:42.800
me make some room.

260
00:16:43.000 --> 00:16:47.590
OK, so let me just explain this whole entire flow.

261
00:16:47.710 --> 00:16:48.740
One more time.

262
00:16:48.760 --> 00:16:51.000
So let us pretend that this is our data set.

263
00:16:51.010 --> 00:16:55.940
Let's pretend like there's no such thing as children for right now and that everybody is a parent.

264
00:16:55.970 --> 00:17:01.670
OK, and we're doing a fine doll, and we've got four records in the people table.

265
00:17:01.690 --> 00:17:02.110
OK.

266
00:17:02.770 --> 00:17:09.550
So when we first start off, we're going to get back a results set and it's going to be kind of on row

267
00:17:09.580 --> 00:17:10.270
zero.

268
00:17:10.360 --> 00:17:10.840
OK?

269
00:17:11.020 --> 00:17:13.450
Which in this case, Rosie Roe has no data.

270
00:17:13.480 --> 00:17:13.820
OK.

271
00:17:13.840 --> 00:17:15.640
It's not a it's not a regular row.

272
00:17:15.670 --> 00:17:16.040
OK.

273
00:17:16.390 --> 00:17:18.040
So we would be here.

274
00:17:18.220 --> 00:17:23.590
And so the first thing that's going to happen is we're going to jump into this while loop and call results

275
00:17:23.590 --> 00:17:24.640
said that next.

276
00:17:24.850 --> 00:17:31.360
So that's going to cause our row cursor to go to row one, OK, which is Jerry Smith.

277
00:17:31.900 --> 00:17:36.880
And then we're going to call extract entity from results set.

278
00:17:36.880 --> 00:17:37.330
So.

279
00:17:37.360 --> 00:17:41.500
So let's jump into that in the people repository.

280
00:17:41.590 --> 00:17:41.970
All right.

281
00:17:41.980 --> 00:17:43.450
So here we are.

282
00:17:43.660 --> 00:17:46.570
And now we're going to jump into this do while loop.

283
00:17:47.140 --> 00:17:54.670
And so the first thing we're going to do is extract a person from the current row, which is this Jerry

284
00:17:54.670 --> 00:17:55.410
Smith Rowe.

285
00:17:55.420 --> 00:18:01.930
We're going to extract a person from this row using these prefixes as aliases, and that's why we had

286
00:18:01.930 --> 00:18:04.960
to go update our sequel for the Find All method.

287
00:18:04.990 --> 00:18:06.040
This is all for find.

288
00:18:06.070 --> 00:18:06.640
All right.

289
00:18:06.910 --> 00:18:13.020
We had to update the SQL for the Find All method to now add in these prefixes for the parent column.

290
00:18:13.150 --> 00:18:22.450
OK, so this call is going to result in a person object being created, which will represent Jerry Smith.

291
00:18:22.450 --> 00:18:27.070
OK, and then that person will be stored in this local variable current parent.

292
00:18:27.820 --> 00:18:33.550
Then we will come here and test if the final parent is null, which it will be null because this is

293
00:18:33.550 --> 00:18:36.310
the first time that we're going through any of this code.

294
00:18:36.310 --> 00:18:38.410
In this case, it will be null.

295
00:18:38.860 --> 00:18:45.730
So then we will set the current parent to the final parent, which means that we will have two variables

296
00:18:46.000 --> 00:18:53.680
current parent and final parent that are both pointing to the same object, which represents Jerry Smith.

297
00:18:53.710 --> 00:18:58.270
OK, so two variables pointing to Jerry Smith object.

298
00:18:58.570 --> 00:19:08.080
Then we will come down to this next f block here and test if the final parent is not equal to the current

299
00:19:08.080 --> 00:19:08.470
parent.

300
00:19:08.470 --> 00:19:15.610
Which is to say, if Jerry Smith is not equal to Jerry Smith, which won't be true, then blah blah

301
00:19:15.610 --> 00:19:15.870
blah.

302
00:19:15.880 --> 00:19:16.890
So that won't be true.

303
00:19:16.900 --> 00:19:20.510
So none of this is going to occur, so that'll get skipped over.

304
00:19:20.530 --> 00:19:24.960
And then if there was a child, we would extract that, but there won't be in this particular query.

305
00:19:24.970 --> 00:19:27.900
So that's just going to return an empty optional.

306
00:19:27.910 --> 00:19:31.900
And then if we were trying to grab addresses, then we would grab the addresses, but we're not.

307
00:19:32.260 --> 00:19:35.930
So we don't really care about any of this now.

308
00:19:35.950 --> 00:19:43.570
OK, so now we're going to call R-Sport next, which is going to cause our row cursor to go down to

309
00:19:43.570 --> 00:19:46.540
the next row row to which is Frank Jones.

310
00:19:47.110 --> 00:19:51.760
OK, and then we're going to jump back up here for another iteration through our loop.

311
00:19:51.850 --> 00:19:57.940
So now we're on row two and we're going to extract a person again, which is now Frank Jones.

312
00:19:58.390 --> 00:20:04.020
And then we're going to come down here and test if final parent is null, final parent is not null now.

313
00:20:04.030 --> 00:20:10.360
Final Parent is equal to Jerry Smith because that's what we set it to in the first iteration.

314
00:20:10.370 --> 00:20:10.820
OK?

315
00:20:11.230 --> 00:20:17.350
It's set to Jerry Smith, so we're going to skip over this line because this is not true anymore.

316
00:20:17.920 --> 00:20:21.280
Final parent is not null, so this will not be executed.

317
00:20:21.550 --> 00:20:30.490
And then we'll jump here if Final Parent, which is Jerry Smith, is not equal to parent parent, which

318
00:20:30.490 --> 00:20:32.020
is Frank Jones.

319
00:20:32.560 --> 00:20:37.390
So if this is true, which it is, then we will execute these two lines.

320
00:20:37.960 --> 00:20:44.250
Now, the first thing we're going to try to do is to roll back our row cursor to the previous row.

321
00:20:44.260 --> 00:20:52.870
That is to say, we want JD B.C. to jump back to this previous row here and then we will break out of

322
00:20:52.870 --> 00:20:59.140
this loop, OK, which means we will land down here on Line 121, so we'll just skip over all of this

323
00:20:59.140 --> 00:21:04.510
and land on line 121 and return whatever was in final parent.

324
00:21:04.810 --> 00:21:07.480
So what is in final parent at this point?

325
00:21:07.810 --> 00:21:13.660
Jerry Smith is in final parent at this point, and then we will return Jerry Smith.

326
00:21:13.960 --> 00:21:15.750
So then let's jump back up.

327
00:21:16.660 --> 00:21:24.250
To our find all method up here, and so then we will add Jerry Smith to this collection of entities,

328
00:21:24.880 --> 00:21:28.970
then we will loop back again and then call R-Sport next.

329
00:21:28.970 --> 00:21:35.590
So we're now in the credit repository again, OK, just to be clear and call R-Sport next, which is

330
00:21:35.590 --> 00:21:40.510
going to now take us back to the second row, which is Frank Jones.

331
00:21:40.510 --> 00:21:44.470
And then we're going to call extract entity from results set again.

332
00:21:45.370 --> 00:21:50.110
And so Final Parent is going to get reset to null and then we're going to extract persons.

333
00:21:50.110 --> 00:21:55.660
So now we're going to extract Frank Jones and set Frank Jones on current parent.

334
00:21:55.690 --> 00:21:58.770
And then we're going to test is final parent null?

335
00:21:58.780 --> 00:22:02.450
Yes, final parent is null because we just re-entered this method.

336
00:22:02.470 --> 00:22:08.890
OK, so these are local variables and local variables get wiped out every time you exit a method and

337
00:22:08.890 --> 00:22:09.910
then come back in.

338
00:22:09.940 --> 00:22:10.360
OK.

339
00:22:10.510 --> 00:22:13.210
And so Final Parent is indeed null.

340
00:22:13.450 --> 00:22:18.430
And so we will now set Frank Jones on Final Parents.

341
00:22:18.430 --> 00:22:24.530
So now we've got final parent and current parent, both pointing to Frank Jones object in memory.

342
00:22:24.550 --> 00:22:30.730
OK, then we will test if Frank Jones does not equal Frank Jones, which makes no sense.

343
00:22:30.970 --> 00:22:32.180
So that would be false.

344
00:22:32.320 --> 00:22:39.070
We will skip over these two lines and now we will come down here and we can ignore all of this for our

345
00:22:39.070 --> 00:22:40.000
purposes.

346
00:22:40.450 --> 00:22:43.540
None of that matters, and we can ignore all of this as well.

347
00:22:43.840 --> 00:22:51.640
And now we will advance to the next row, which would be this row here and Jackson.

348
00:22:52.000 --> 00:22:59.140
And so then we loop back up here again and then we extract and Jackson and then we test.

349
00:22:59.140 --> 00:23:05.980
If Final Parent is the final parent is not null, final parent now is set to Frank Jones, so we will

350
00:23:05.980 --> 00:23:08.920
skip over that line and then we will test.

351
00:23:09.010 --> 00:23:15.780
If Frank Jones is not equal to Ann Jackson, which is true.

352
00:23:15.790 --> 00:23:18.850
Frank Jones is not equal to Ann Jackson then.

353
00:23:19.850 --> 00:23:27.500
Back up one row, which takes us to this row here, Frank Jones, and then break out of this loop,

354
00:23:27.770 --> 00:23:35.910
which takes us down to line 121 and then return Frank Jones because that's what's in final parent.

355
00:23:35.930 --> 00:23:37.700
And so then we will end up.

356
00:23:38.610 --> 00:23:44.280
Returning Frank Jones object and adding it to this collection of entities.

357
00:23:44.310 --> 00:23:52.290
OK, so now this collection of entities contains Gerry Smith and Frank Jones, and we are back on the

358
00:23:52.290 --> 00:23:54.210
Frank Jones row right now.

359
00:23:54.240 --> 00:23:59.190
OK, then we will loop back up here again and advance one row.

360
00:23:59.790 --> 00:24:05.940
So now we go from Frank Jones back down to and Jackson, and then we will jump in here again.

361
00:24:06.060 --> 00:24:07.890
So do you get what's happening here?

362
00:24:08.170 --> 00:24:12.180
OK, I hope I don't need to go through that, go through that again, but I'm stepping.

363
00:24:12.230 --> 00:24:18.300
I'm trying to be very, very methodical here and step through each and every line of code so that you

364
00:24:18.300 --> 00:24:21.000
can get the pattern of what's happening here, OK?

365
00:24:21.300 --> 00:24:27.120
So we just, you know, slowly and methodically step through each of these lines, OK, and that's what's

366
00:24:27.120 --> 00:24:28.180
enabling this to work.

367
00:24:28.200 --> 00:24:32.820
So now the last thing I want to explain is this little bit that we had to do up here to make everything

368
00:24:32.820 --> 00:24:33.150
work.

369
00:24:33.420 --> 00:24:38.970
So if I jump back into this extract entity from results set method.

370
00:24:41.980 --> 00:24:49.390
So right here when we call results said that previous, which is causing our row cursor to back up one

371
00:24:49.390 --> 00:24:55.420
and go back to the previous row, that's just so that we can get things set up again in the way that

372
00:24:55.420 --> 00:25:00.370
our credit repository find all method is expecting things to be.

373
00:25:00.550 --> 00:25:04.510
It's not expecting that we're skipping over rows behind its back.

374
00:25:04.550 --> 00:25:11.620
OK, so we are advancing to the next road just so that we can see just so that we can see essentially,

375
00:25:11.800 --> 00:25:17.620
is this a child or is this another parent now in this particular case, in the example that I just ran

376
00:25:17.620 --> 00:25:17.950
through?

377
00:25:18.160 --> 00:25:19.550
Everybody as a parent?

378
00:25:19.570 --> 00:25:20.070
OK?

379
00:25:20.500 --> 00:25:25.450
But if this had been a child, then we would have had Gerry Smith duplicated again.

380
00:25:25.540 --> 00:25:26.050
OK.

381
00:25:26.260 --> 00:25:27.340
That's what would have happened.

382
00:25:27.340 --> 00:25:32.470
And then we would have just extracted that child and then added the child to the parent.

383
00:25:32.500 --> 00:25:32.950
OK.

384
00:25:33.460 --> 00:25:38.300
But in this case, none of these people are children of the previous person.

385
00:25:38.320 --> 00:25:38.680
Right?

386
00:25:38.710 --> 00:25:41.440
They're all parents, if you want to think of it in that way.

387
00:25:41.440 --> 00:25:48.190
And so we're kind of taking a peek at the next row to see, is this is this Gerry Smith again with another

388
00:25:48.190 --> 00:25:50.650
child or is this a brand new person?

389
00:25:50.800 --> 00:25:56.290
And basically, we're saying, if it's a brand new person, a brand new parent, then we're done taking

390
00:25:56.290 --> 00:25:56.830
a peek.

391
00:25:56.980 --> 00:26:02.620
Let's reset everything back to where it should be, which, which would mean we have to back up to the

392
00:26:02.620 --> 00:26:03.670
previous row.

393
00:26:03.700 --> 00:26:04.150
OK.

394
00:26:04.630 --> 00:26:10.300
However, we aren't allowed to back up to the previous row by default with J.D. DC.

395
00:26:10.600 --> 00:26:17.950
If you want to be able to back up and and and change what row you're on besides calling R-St next.

396
00:26:18.190 --> 00:26:23.500
Then you have to tell your connection that you want a statement or, in this case, a prepared statement

397
00:26:23.500 --> 00:26:24.890
that is scrollable.

398
00:26:24.910 --> 00:26:26.790
OK, so that's what we're doing here.

399
00:26:26.800 --> 00:26:31.540
We're saying that we want the ability to kind of move around backward and forward, OK?

400
00:26:32.110 --> 00:26:38.530
And this insensitive setting here is basically just saying we do not want to have to pay attention to

401
00:26:38.560 --> 00:26:42.070
changes that occur in the underlying data set.

402
00:26:42.370 --> 00:26:48.560
That really doesn't even apply for us right now, but that could come into play in a database that allows

403
00:26:48.580 --> 00:26:52.090
multiple applications to connect to it simultaneously.

404
00:26:52.270 --> 00:26:58.000
So let's say that you've got two copies of this program, both connecting to the database at the same

405
00:26:58.000 --> 00:27:03.400
time from different computers, and the first computer gets a results set from this find all method,

406
00:27:03.400 --> 00:27:08.710
and then the other computer is adding additional rows into the same table.

407
00:27:08.800 --> 00:27:16.000
This insensitive setting here is simply saying once the first computer gets its results set while we're

408
00:27:16.000 --> 00:27:21.340
in this find all method, don't worry about additional rows getting added or updated or changed and

409
00:27:21.340 --> 00:27:22.070
things like that.

410
00:27:22.090 --> 00:27:22.480
OK.

411
00:27:22.810 --> 00:27:29.110
So it's kind of like taking a snapshot of the way that the records looked at the moment that we entered

412
00:27:29.110 --> 00:27:31.600
this find all method on that first computer.

413
00:27:31.610 --> 00:27:31.990
OK?

414
00:27:32.170 --> 00:27:34.240
So don't don't get any fancier than that.

415
00:27:34.600 --> 00:27:41.410
And then this concur read only is simply saying that we're not going to try to make changes to our results.

416
00:27:41.410 --> 00:27:42.410
Set data, OK?

417
00:27:42.610 --> 00:27:47.290
We're not going to programmatically get a result set and then try to change values in it.

418
00:27:47.470 --> 00:27:52.300
We're only reading, OK, we're not going to update or change or write any data here.

419
00:27:52.930 --> 00:27:59.470
And the reason these settings are important to note is because it allows the database to optimize for

420
00:27:59.470 --> 00:28:00.940
whatever it is that we're trying to do.

421
00:28:01.090 --> 00:28:06.430
Because if we wanted a results set that we could update, that's a little harder for the database to

422
00:28:06.430 --> 00:28:07.690
allow us to do.

423
00:28:07.720 --> 00:28:08.200
OK.

424
00:28:08.440 --> 00:28:13.660
So by choosing in this case, read only and insensitive, we're basically saying, Hey, database,

425
00:28:13.660 --> 00:28:17.230
we don't need you to do the fanciest, most complicated things here.

426
00:28:17.410 --> 00:28:23.470
Just let us move our cursor backward and forward on a static data set.

427
00:28:23.530 --> 00:28:27.250
OK, which that would be this data set here in this example.

428
00:28:27.310 --> 00:28:27.730
All right.

429
00:28:28.270 --> 00:28:34.660
OK, so hopefully now you understand what this is doing and why we're doing it in this way and how we

430
00:28:34.660 --> 00:28:35.680
came up with it.

431
00:28:35.800 --> 00:28:36.280
OK.

432
00:28:36.730 --> 00:28:42.760
So if you didn't catch everything I said here, though, hey, just go back, play it back even slower.

433
00:28:42.970 --> 00:28:48.220
Watch through my step by step, line by line explanation for what everything is doing.

434
00:28:48.250 --> 00:28:48.620
OK?

435
00:28:48.640 --> 00:28:51.460
And I think you probably will be able to get it then.

436
00:28:51.730 --> 00:28:56.680
And if you're still having problems, you can always shoot me a message in this course and I will try

437
00:28:56.710 --> 00:28:58.940
my best to to address it for you.

438
00:28:58.960 --> 00:28:59.380
OK.

439
00:28:59.980 --> 00:29:04.570
But with that, I'm going to go ahead and end this lesson and I will see you in the next one.
