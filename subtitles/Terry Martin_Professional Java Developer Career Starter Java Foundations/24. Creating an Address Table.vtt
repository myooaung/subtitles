WEBVTT
1
00:00:00.090 --> 00:00:00.750
Welcome back.

2
00:00:01.200 --> 00:00:07.710
So now that we've learned a little bit about optimizing our database tables for faster queries by adding

3
00:00:07.710 --> 00:00:12.930
indexes, I want to model another concept that sets the table and as a class so that we can see another

4
00:00:12.930 --> 00:00:17.760
way that we can create tables with at least one key index included right from the start.

5
00:00:18.390 --> 00:00:18.690
All right.

6
00:00:18.720 --> 00:00:26.040
So turning back to scroll, SQL Client will go back into the Aliases tab and then back into the People

7
00:00:26.040 --> 00:00:28.380
Test table, and I will connect to it.

8
00:00:28.440 --> 00:00:28.710
All right.

9
00:00:28.710 --> 00:00:34.380
So if you recall some of the additional columns that exist in our five million road test data set,

10
00:00:34.680 --> 00:00:40.620
there were a few address related columns that I intentionally decided not to deal with while we were

11
00:00:40.620 --> 00:00:42.000
initially loading this data.

12
00:00:42.390 --> 00:00:44.730
Let's go back to the sample data in our spreadsheet.

13
00:00:44.880 --> 00:00:46.360
Just as a quick reminder.

14
00:00:46.380 --> 00:00:53.970
OK, so here we are back in our spreadsheet and if I scroll towards the right, yeah, we've got a few

15
00:00:53.970 --> 00:00:55.100
other fields here.

16
00:00:55.110 --> 00:01:01.650
We've got a place name county, city, state and zip and even a region.

17
00:01:01.860 --> 00:01:07.440
Now we don't have a street address that's just not included in this particular test data set, but we've

18
00:01:07.440 --> 00:01:08.970
got these other columns here.

19
00:01:09.300 --> 00:01:16.800
Now, we certainly could have just added fields in our Java class and in our people table to hold this

20
00:01:16.800 --> 00:01:17.550
information.

21
00:01:17.880 --> 00:01:21.420
But I wanted to show some alternative ways of dealing with data.

22
00:01:21.810 --> 00:01:27.120
I don't want to get into much to whether or not one way is better or worse than the other right now.

23
00:01:27.270 --> 00:01:33.540
But I do want to show you that it can be somewhat common to separate out certain related fields from

24
00:01:33.540 --> 00:01:34.080
others.

25
00:01:34.200 --> 00:01:41.730
So in this case, we've got one two three four five six, I think six columns here that are all related

26
00:01:41.730 --> 00:01:46.890
to location or address essentially out of all of these fields here.

27
00:01:47.220 --> 00:01:52.620
And it's very common that you might not want to have one table with all of those columns in it in the

28
00:01:52.620 --> 00:01:58.710
database, and you might want to just separate them out, but you may want to still link them somehow.

29
00:01:59.040 --> 00:02:02.220
And so we'll see how to do that in subsequent lessons.

30
00:02:02.550 --> 00:02:08.520
But for now, the main thing I want to focus on is modeling a table that will allow us to hold this

31
00:02:08.520 --> 00:02:10.220
location data separately.

32
00:02:10.240 --> 00:02:15.440
OK, so let's see if we've got place name county, city, state, zip region.

33
00:02:15.450 --> 00:02:18.180
OK, so let's jump back over to squirrel.

34
00:02:20.070 --> 00:02:22.680
And we will create another table.

35
00:02:23.720 --> 00:02:27.740
So we can do a create table, give it a name.

36
00:02:27.980 --> 00:02:34.580
And I'm inclined to just call it addresses and then parentheses, and then we can start naming the columns

37
00:02:34.580 --> 00:02:36.770
and the data types for each column.

38
00:02:36.770 --> 00:02:40.910
So let's see, we've got a place name.

39
00:02:41.480 --> 00:02:47.600
So the first column that I would like this table to have and I usually like to have this column in most

40
00:02:47.600 --> 00:02:51.320
tables, though, there can be certain exceptions that I'll try to mention.

41
00:02:51.320 --> 00:02:53.710
Here will be the ID column.

42
00:02:53.720 --> 00:03:01.280
This ID column just gives us a really convenient shorthand way to refer to any particular record in

43
00:03:01.280 --> 00:03:02.150
a database.

44
00:03:03.350 --> 00:03:10.310
So I'm going to call it ID, but this time we're going to create this slightly differently from when

45
00:03:10.310 --> 00:03:14.360
we created the people table, when we created the people table.

46
00:03:14.370 --> 00:03:18.110
In fact, let me just remind you of exactly how we created the people table.

47
00:03:18.110 --> 00:03:24.440
So we did a create table people and then I.D., a data type big event.

48
00:03:24.940 --> 00:03:32.120
And then we use this auto underscore increment keyword here to specify that we wanted this ID column

49
00:03:32.120 --> 00:03:34.540
to automatically be numbered for us.

50
00:03:34.550 --> 00:03:38.060
And then we moved on with the rest of our fields, which I won't finish this up.

51
00:03:38.060 --> 00:03:43.970
But you know, we did a bar car 255 and then all of the other fields, OK?

52
00:03:44.150 --> 00:03:49.190
The main thing I wanted to remind you of, though, was that we did create an ID field, obviously for

53
00:03:49.190 --> 00:03:52.910
the people table, and we specified its data type as big end.

54
00:03:52.910 --> 00:03:58.220
And then we specified that it should auto increments for this address table, though we're going to

55
00:03:58.220 --> 00:04:02.680
do things in a way that I would say is a little bit more typical, probably.

56
00:04:02.690 --> 00:04:10.460
And what I mean by that is since I specified that we want an ID column here, and we now know that ideally,

57
00:04:10.460 --> 00:04:17.420
if we're going to be looking up records by a column like ID, ideally we would prefer to have that column

58
00:04:17.420 --> 00:04:20.000
have an index generated for it.

59
00:04:20.270 --> 00:04:26.960
Well, we can actually have that index generated automatically upon creation of this table, depending

60
00:04:26.960 --> 00:04:29.560
on how we define the ID column.

61
00:04:29.570 --> 00:04:35.600
And it is very common to have a column on a table that is usually called something like ID, and that

62
00:04:35.600 --> 00:04:42.650
ID column will typically be used as a quick way to just access one record out of all the records in

63
00:04:42.650 --> 00:04:43.370
that table.

64
00:04:43.940 --> 00:04:50.120
More often than not, when you see a table that is defined in this way, that ID column will usually

65
00:04:50.120 --> 00:04:56.030
be set up as what is called a primary key field, and that term means what it sounds like.

66
00:04:56.030 --> 00:05:02.440
It means that primary key field is a very convenient identifier for records in that table.

67
00:05:02.450 --> 00:05:09.620
And if you tell the database that that column of that table is the primary key column, you'll usually

68
00:05:09.620 --> 00:05:11.540
get a number of features for free.

69
00:05:11.570 --> 00:05:17.120
So one of those features will be an index being generated for that column for you.

70
00:05:17.150 --> 00:05:20.540
Another feature will be what's called a unique constraint.

71
00:05:20.660 --> 00:05:28.040
And in short, a unique constraint just ensures that when we insert new records into that table, the

72
00:05:28.040 --> 00:05:32.540
IDs for each of those records has to be unique among the records.

73
00:05:32.540 --> 00:05:38.510
So in other words, if our ID column is going to hold numbers one through, you know, five million,

74
00:05:38.510 --> 00:05:42.410
for example, no two or more rows can have the same ID.

75
00:05:43.220 --> 00:05:45.490
And just think about it, that makes sense, right?

76
00:05:45.500 --> 00:05:50.960
If they have the same ID, then it's harder to specify quickly which row you're trying to query for

77
00:05:50.960 --> 00:05:51.990
or work on.

78
00:05:52.010 --> 00:05:56.360
So we can get indexes for free, we can get unique constraints for free.

79
00:05:56.450 --> 00:06:02.420
Some databases may offer various other features as well, but those are two really important ones that

80
00:06:02.420 --> 00:06:04.730
are quite typical for a primary key field.

81
00:06:04.970 --> 00:06:09.860
Other fields, by the way, can also have these unique constraints in other types of constraints as

82
00:06:09.860 --> 00:06:10.190
well.

83
00:06:10.790 --> 00:06:14.300
But you tend to get those for free with a primary key field.

84
00:06:14.660 --> 00:06:20.570
All right, so let's make this ID field a primary field, and to do that, it's not that hard.

85
00:06:20.750 --> 00:06:25.730
I do want to show you as we're creating this, how I myself know what keywords to enter here.

86
00:06:25.880 --> 00:06:27.770
I don't actually have this memorized.

87
00:06:27.770 --> 00:06:31.190
This isn't something I do very frequently in any database.

88
00:06:31.370 --> 00:06:32.600
So let me show you what I do.

89
00:06:33.050 --> 00:06:40.310
OK, so here I've got a web browser open to the H2 Databases website, and for H2 now, it's going to

90
00:06:40.310 --> 00:06:42.350
be a little different for every database.

91
00:06:42.350 --> 00:06:50.180
But for H2, if I want to create a primary key field, what I can do is I can come down here two commands

92
00:06:50.180 --> 00:06:56.080
under the under reference and I do have a general idea of where I'm going with this.

93
00:06:56.090 --> 00:07:02.360
So, you know, so hopefully after you've taken my course, you also will have enough of an idea that

94
00:07:02.360 --> 00:07:04.970
you can find your way towards what you're looking for.

95
00:07:05.000 --> 00:07:05.390
OK.

96
00:07:05.480 --> 00:07:10.460
So I know that I'm creating a table so I can come down to the commands for creating what is called a

97
00:07:10.460 --> 00:07:11.690
data definition.

98
00:07:11.840 --> 00:07:14.830
That's where you can define your data tables and things.

99
00:07:14.840 --> 00:07:15.200
OK.

100
00:07:15.740 --> 00:07:20.660
And I can look for create a table which is right here so I can click on that.

101
00:07:21.320 --> 00:07:23.210
And now this is showing me based.

102
00:07:23.240 --> 00:07:26.910
Quickly, the syntax of the Create Table Command.

103
00:07:27.330 --> 00:07:27.750
OK.

104
00:07:27.930 --> 00:07:35.760
So each of these little sections here is a section that may or may not be necessary for the whole entire

105
00:07:35.760 --> 00:07:39.060
statement that you're going to build in this case to create a table.

106
00:07:39.100 --> 00:07:44.760
OK, so you've got to start with create and then the rest of these bits here are optional.

107
00:07:44.940 --> 00:07:49.680
The way I know that they're optional is that there's this line that goes straight through, which is

108
00:07:49.680 --> 00:07:52.080
telling me that I could start with create.

109
00:07:52.290 --> 00:07:54.790
And then nothing else for this part of the command.

110
00:07:55.020 --> 00:07:57.600
And then I'd have to come down to the next bit table.

111
00:07:57.870 --> 00:08:03.570
Or I could optionally say create and then add either cached or memory, but not both.

112
00:08:03.810 --> 00:08:07.590
That's why this this is branching off into these two bits like this.

113
00:08:07.590 --> 00:08:09.840
You can do cached or memory, but not both.

114
00:08:10.200 --> 00:08:12.060
And then from there you can have nothing.

115
00:08:12.270 --> 00:08:14.010
Or you could specify temp.

116
00:08:14.220 --> 00:08:20.700
But if you specify temp, you cannot additionally specify temporary, low, global or local, OK.

117
00:08:20.710 --> 00:08:22.920
So each of these branches is exclusive.

118
00:08:23.100 --> 00:08:25.780
You can only pick one of these branches ever.

119
00:08:25.800 --> 00:08:26.310
OK.

120
00:08:26.340 --> 00:08:27.390
So create.

121
00:08:27.390 --> 00:08:31.030
And in my case, I don't want any of these other things at this time.

122
00:08:31.050 --> 00:08:36.400
So if I follow this line through, then that takes me down to the next bit, which is table.

123
00:08:36.420 --> 00:08:39.570
I do need the keyword table, so that is mandatory.

124
00:08:39.930 --> 00:08:45.960
If not exists, is a really useful little segment of a command here because sometimes we will issue

125
00:08:45.960 --> 00:08:48.300
these commands in the form of a script.

126
00:08:48.600 --> 00:08:54.480
And that script at the time of writing may not know whether or not you already may have these tables

127
00:08:54.480 --> 00:08:58.710
or other database objects as they are called existing in the database.

128
00:08:58.710 --> 00:09:04.980
So you can use these keywords like, if not exists, to say, go ahead and make this table if it doesn't

129
00:09:04.980 --> 00:09:07.800
already exist, but if it does, then don't do anything.

130
00:09:08.190 --> 00:09:08.590
All right.

131
00:09:08.610 --> 00:09:09.870
So I don't need that.

132
00:09:09.870 --> 00:09:13.530
In this particular case, though, it wouldn't hurt for me to add it in.

133
00:09:14.040 --> 00:09:19.950
So table and then a table name and I could click on this and see what are all the rules of how to create

134
00:09:19.950 --> 00:09:22.440
a table name, but I'm not worried about that right now.

135
00:09:22.530 --> 00:09:25.890
So we've got create table addresses so far.

136
00:09:26.040 --> 00:09:32.730
Then next, I could specify nothing for the next bit and then go down to the subsequent bits and really

137
00:09:32.730 --> 00:09:34.620
everything else could be optional.

138
00:09:34.920 --> 00:09:39.780
Of course, though, in our case, just specifying the table name and nothing else isn't very useful.

139
00:09:40.140 --> 00:09:46.440
So on the next bit here, I would branch down to where we start off with a an opening parentheses,

140
00:09:47.340 --> 00:09:54.060
which we have here and then either a column name or a table constraint definition.

141
00:09:54.420 --> 00:10:01.350
In our case, we want a column name, which in our case is the column ID so far and then a column definition.

142
00:10:01.350 --> 00:10:03.240
And that's where we actually are right now.

143
00:10:03.360 --> 00:10:03.520
Right.

144
00:10:03.550 --> 00:10:05.250
I stopped right there at the ID.

145
00:10:06.300 --> 00:10:11.550
So if I click on this column definition, we can see what our additional options here.

146
00:10:11.580 --> 00:10:14.040
So the first one is not really optional.

147
00:10:14.040 --> 00:10:16.020
It's a data type or domain.

148
00:10:16.200 --> 00:10:22.830
So I can click on data type to see what are my options there, and I can even drill in further and see

149
00:10:22.830 --> 00:10:27.990
data type, and I can use a predefined type or an array type or a road type.

150
00:10:28.200 --> 00:10:30.420
So here are the predefined types.

151
00:10:30.780 --> 00:10:36.960
There are various types of character types and binaries and Boolean since small lens and integers and

152
00:10:36.960 --> 00:10:38.040
big end types.

153
00:10:38.280 --> 00:10:42.840
So if I click on this begin to type, for example, then I get to see here, OK?

154
00:10:42.990 --> 00:10:44.070
There's a big end.

155
00:10:44.250 --> 00:10:50.100
So this is just showing how you don't have to necessarily memorize what are all the types and all the

156
00:10:50.100 --> 00:10:51.150
syntax and everything.

157
00:10:51.270 --> 00:10:57.360
You can drill into this syntax tree essentially to see what are all the different things that you can

158
00:10:57.360 --> 00:10:59.580
specify to build up a command.

159
00:10:59.760 --> 00:11:05.190
Now it really helps, obviously, if you have a general understanding, though, of what these commands

160
00:11:05.190 --> 00:11:06.600
would typically look like.

161
00:11:06.780 --> 00:11:11.310
Otherwise, it might take you forever to figure out how to do even the most basic thing.

162
00:11:11.520 --> 00:11:13.800
All right, so I'm going to back out a few here.

163
00:11:13.950 --> 00:11:14.160
All right.

164
00:11:14.160 --> 00:11:21.330
So I'm back on the column definition, so I am going to have a data type of big event.

165
00:11:23.890 --> 00:11:26.710
So that's this bit here, data type or domain?

166
00:11:27.490 --> 00:11:30.190
I won't specify visible or invisible.

167
00:11:30.430 --> 00:11:34.540
Then the next bit here I can specify a number of these options here.

168
00:11:34.840 --> 00:11:41.140
And one of these I am actually interested in, which is generated always as identity.

169
00:11:41.140 --> 00:11:47.970
So that allows me to tell the database that I want that column to be generated all the time.

170
00:11:47.980 --> 00:11:53.740
That is largely equivalent to using this auto increment keyword that we used here when we originally

171
00:11:53.740 --> 00:11:55.120
created the people table.

172
00:11:55.450 --> 00:12:00.280
So I can specify generated always as identity.

173
00:12:00.490 --> 00:12:08.100
Now this as identity business here just lets me specify that this column is an identity column.

174
00:12:08.110 --> 00:12:16.030
In other words, all of the data in that row can be identified by this ID column that we are defining.

175
00:12:16.180 --> 00:12:20.860
And you can come down here and read a bit more about what all of this means and how it's going to work

176
00:12:20.860 --> 00:12:21.970
and things of that sort.

177
00:12:22.030 --> 00:12:22.320
All right.

178
00:12:22.330 --> 00:12:25.210
So I'm going to specify that now generated.

179
00:12:26.710 --> 00:12:30.580
Always as identity.

180
00:12:30.730 --> 00:12:36.820
All right, and then I could finish that up, or I could branch down here to some options.

181
00:12:37.600 --> 00:12:43.630
So basically, when we tell the database to auto number a column like we're doing here and like we did

182
00:12:43.630 --> 00:12:47.330
with the auto increment, we can specify additional options.

183
00:12:47.350 --> 00:12:52.540
In fact, I think we might have touched on that if I, if I recall correctly when we created the people

184
00:12:52.540 --> 00:12:54.820
table, we might have done an altar or something.

185
00:12:54.820 --> 00:13:01.180
But at any rate, we can specify things like what number to start numbering our rows from.

186
00:13:01.210 --> 00:13:04.000
So by default, it'll start at one.

187
00:13:04.240 --> 00:13:08.380
But we could have it start with 100 or 1000 or whatever.

188
00:13:08.680 --> 00:13:09.560
Things like that.

189
00:13:09.580 --> 00:13:14.050
So in this case, we don't need to specify that, but I wanted to point that out.

190
00:13:14.260 --> 00:13:14.650
OK.

191
00:13:14.860 --> 00:13:15.970
So let's go back.

192
00:13:16.120 --> 00:13:19.510
So we won't be specifying any of this down here.

193
00:13:19.900 --> 00:13:22.540
So then we can move on to these other bits here.

194
00:13:22.550 --> 00:13:25.870
So on update, we won't be doing anything on update.

195
00:13:26.680 --> 00:13:30.160
We won't be doing anything with default on or selectivity.

196
00:13:30.700 --> 00:13:33.550
This last bit, though, we do want something from.

197
00:13:33.730 --> 00:13:37.090
And so if we click on, it's called column constraint definition.

198
00:13:37.090 --> 00:13:41.500
So if you click on that now, we can see some additional options here.

199
00:13:41.920 --> 00:13:47.020
We could start off with nothing and then come down to this next bid, or we could specify a constraint

200
00:13:47.020 --> 00:13:49.150
name def. We won't be doing that.

201
00:13:49.690 --> 00:13:52.840
So we've got some exclusive options here.

202
00:13:53.110 --> 00:13:58.210
And can you guess which one we may be interested in based on what I've said so far?

203
00:13:58.450 --> 00:13:58.720
All right.

204
00:13:58.730 --> 00:14:01.570
So if you said primary key, you'd be right.

205
00:14:01.870 --> 00:14:06.940
We want this ID column to be known or specified as a primary key.

206
00:14:07.150 --> 00:14:13.240
And if you come down here, the documentation even says primary key and unique require unique values.

207
00:14:13.570 --> 00:14:19.640
Primary key also disallows null values and marks the column as a primary key.

208
00:14:19.660 --> 00:14:25.630
So not only do the values in our primary key column, which in this case would be the ID column.

209
00:14:25.780 --> 00:14:32.470
Not only do those values have to be unique, meaning there can't be duplicates across rows in the table,

210
00:14:32.770 --> 00:14:36.160
but also you can't have a null value either.

211
00:14:36.160 --> 00:14:42.430
And that makes sense because since it is a primary key column, it is the identifier for the column.

212
00:14:42.430 --> 00:14:45.040
It would kind of be like having a person with no name.

213
00:14:45.340 --> 00:14:45.700
All right.

214
00:14:45.730 --> 00:14:47.830
So we will specify primary key.

215
00:14:50.200 --> 00:14:59.620
Primary key, and now that's everything that I want to put on the definition of the ID column, I know

216
00:14:59.620 --> 00:15:04.660
it feels like a lot, but when you get used to doing these kinds of things, then it won't feel like

217
00:15:04.660 --> 00:15:05.560
quite so much.

218
00:15:05.890 --> 00:15:09.930
It's taking me a longer time to explain it than it does to actually just type it in.

219
00:15:09.940 --> 00:15:13.480
And now what other columns would we want in this address table?

220
00:15:13.810 --> 00:15:16.770
Well, before we go, look back at the sample data.

221
00:15:17.080 --> 00:15:22.960
I can tell you now that it's very common to have like an address, one field and an address, two field

222
00:15:22.960 --> 00:15:26.140
or a street address field or something like that.

223
00:15:26.440 --> 00:15:35.800
So let's go ahead and define something like a street address, and let's make that a bar car.

224
00:15:36.130 --> 00:15:37.180
255.

225
00:15:37.480 --> 00:15:42.970
And by the way, when I specify this VAR car 255, that's just the default length that I tend to make

226
00:15:42.970 --> 00:15:45.670
for VAR cards, as I've stated before.

227
00:15:45.790 --> 00:15:48.220
You can actually specify various things here.

228
00:15:48.220 --> 00:15:52.810
I could make it one thousand twenty four or I could make it twenty five, although obviously you want

229
00:15:52.810 --> 00:15:58.270
it to be long enough to make sure that you can cover every type of street address that might need to

230
00:15:58.270 --> 00:16:00.070
be inserted into this table.

231
00:16:00.100 --> 00:16:02.580
For now, though, 255 is fine for me.

232
00:16:02.590 --> 00:16:09.400
And then maybe let's also have an address to field and I will make that also of our car.

233
00:16:09.610 --> 00:16:14.170
And that would be like if you live in an apartment, you know you've got the street address, the number

234
00:16:14.170 --> 00:16:17.110
in the street on address one or in this case, street address.

235
00:16:17.260 --> 00:16:21.160
But then you might also need to specify Apartment 1A or whatever.

236
00:16:21.280 --> 00:16:24.400
And so that would go here in the address to field.

237
00:16:24.670 --> 00:16:28.390
And then we can have a city as a bar car.

238
00:16:30.030 --> 00:16:35.490
And a state now, let's go look at our sample data because I don't remember if states were in there

239
00:16:35.490 --> 00:16:36.060
or not.

240
00:16:36.150 --> 00:16:36.540
OK.

241
00:16:36.570 --> 00:16:43.140
Yes, we do have states and what I wanted to see is whether or not the states are two characters consistently

242
00:16:43.140 --> 00:16:44.400
or if they were spelled out.

243
00:16:44.550 --> 00:16:46.770
So they are the two character abbreviations.

244
00:16:46.950 --> 00:16:50.580
So we'll model our database to accommodate this format here.

245
00:16:50.610 --> 00:16:50.880
All right.

246
00:16:50.880 --> 00:16:54.720
So the state can be a VAR car, too.

247
00:16:54.750 --> 00:16:55.050
All right.

248
00:16:55.050 --> 00:17:00.180
And then back over here and then we've got a zip code, which is a postal code for those of you who

249
00:17:00.180 --> 00:17:02.250
don't live in North America.

250
00:17:02.310 --> 00:17:04.220
Zip code is a postal code.

251
00:17:04.260 --> 00:17:04.620
OK.

252
00:17:04.860 --> 00:17:10.530
And in fact, we could even just call it postal code or postal code, whatever you want to say there,

253
00:17:10.530 --> 00:17:17.700
and I'm going to go ahead and model this as of our car, even though here we we see it new as numerical

254
00:17:18.120 --> 00:17:25.020
because at least in North America, postal codes actually have a more formal format, which is longer

255
00:17:25.020 --> 00:17:26.640
than this with a hyphen in it.

256
00:17:27.060 --> 00:17:30.690
And so I would want to just make sure that I accommodated that.

257
00:17:30.690 --> 00:17:36.330
And now that's a very specific thing for me as an American who knows what postal codes tend to look

258
00:17:36.330 --> 00:17:42.030
like in the U.S., though I think in some other parts of the world, postal codes can be alphanumeric,

259
00:17:42.030 --> 00:17:46.770
meaning they can have alphabet letters mixed with numbers as well.

260
00:17:46.770 --> 00:17:50.850
And so far, car would just safely cover all of those scenarios.

261
00:17:52.530 --> 00:17:58.080
And now maybe I don't need it to be 255 characters in length for this.

262
00:17:58.290 --> 00:18:00.600
Maybe we can safely do 50.

263
00:18:01.140 --> 00:18:01.500
All right.

264
00:18:01.500 --> 00:18:05.040
And then we need to cover county and region also.

265
00:18:05.040 --> 00:18:16.650
So I'm going to just add those two fields county as of our car 255 and region as a VAR car 255.

266
00:18:16.650 --> 00:18:20.910
And then finally, I'm also going to go ahead and allow us to specify the country.

267
00:18:22.880 --> 00:18:25.490
As a bar car, maybe 100.

268
00:18:26.240 --> 00:18:29.720
All right, and then a closing parentheses there to close that off.

269
00:18:29.960 --> 00:18:30.440
OK.

270
00:18:30.530 --> 00:18:33.110
And so now we're ready to create this table.

271
00:18:33.860 --> 00:18:36.920
So I'm just going to do a controlled return.

272
00:18:39.150 --> 00:18:39.630
OK.

273
00:18:39.930 --> 00:18:46.470
And then I can just check real quick that that got created safely, so I'll do a select everything from

274
00:18:46.510 --> 00:18:48.810
addresses and run that.

275
00:18:49.260 --> 00:18:50.110
And there we go.

276
00:18:50.130 --> 00:18:56.520
So we've got an I.D. street address address to city state postal code at country region, all of these

277
00:18:56.520 --> 00:18:56.730
things.

278
00:18:56.730 --> 00:19:04.680
So that all looks pretty good and we can come over here to the objects and drill back into the database

279
00:19:05.070 --> 00:19:07.800
itself, public table.

280
00:19:08.130 --> 00:19:11.700
And now we see an addresses table here.

281
00:19:12.270 --> 00:19:21.530
And if we look at this tab for primary key, we see that we do have one record here for a primary key.

282
00:19:22.440 --> 00:19:24.960
And it is on the ID column, right?

283
00:19:25.080 --> 00:19:31.560
So that got created properly, and then if we come over here to the indexes, we see that we do in fact

284
00:19:31.560 --> 00:19:35.130
have one row for an index that got created for us.

285
00:19:35.160 --> 00:19:41.220
Now we didn't have to go in and explicitly create the index like we did for the people table because

286
00:19:41.220 --> 00:19:47.010
we specified that the ID column is a primary key column and you get an index for three when you designate

287
00:19:47.010 --> 00:19:48.660
a column as a primary key column.

288
00:19:48.900 --> 00:19:54.480
And so here's that and this is specifying that the index is for the ID column.

289
00:19:54.810 --> 00:19:56.670
So that's all looking very good.

290
00:19:56.730 --> 00:19:56.970
All right.

291
00:19:56.980 --> 00:19:59.910
So let's jump back over to the school table now.

292
00:19:59.910 --> 00:20:05.280
One more thing I want to do before we close out this lesson, where we've mainly just focused on creating

293
00:20:05.280 --> 00:20:06.540
the address table.

294
00:20:06.840 --> 00:20:14.910
I want to show you now that one of the amazing things that we can do with a relational database is actually

295
00:20:14.910 --> 00:20:18.000
relate data in the relational database.

296
00:20:18.000 --> 00:20:21.690
That's why it's called a relational database, and you haven't really had a chance to see that part

297
00:20:21.690 --> 00:20:23.430
of what these databases can do yet.

298
00:20:23.880 --> 00:20:31.200
So now that we've got a people table and we've got an addresses table, we can establish a relationship

299
00:20:31.230 --> 00:20:37.710
between these tables because the whole point is going to be that as we have these people in the table,

300
00:20:37.860 --> 00:20:45.510
these people live at various places so we can actually have a column in the people table that essentially

301
00:20:45.510 --> 00:20:48.600
points to addresses in the address table.

302
00:20:48.600 --> 00:20:53.000
That is to say, so-and-so lives at this address, right?

303
00:20:53.010 --> 00:20:57.990
And we can marry any two or more records together with these relationships.

304
00:20:58.380 --> 00:21:00.360
So let me show you how we can do that.

305
00:21:00.690 --> 00:21:05.790
So first, let me just query for from the People Table.

306
00:21:06.210 --> 00:21:09.300
And I don't want to select everything from there.

307
00:21:09.300 --> 00:21:13.440
So we'll specify something like first ten rows only.

308
00:21:13.710 --> 00:21:14.130
OK.

309
00:21:14.220 --> 00:21:19.770
So I just wanted to get a quick reminder of the columns that are currently in this table.

310
00:21:20.370 --> 00:21:28.350
So what I'm thinking is we can add an additional column to this table and call it something like primary

311
00:21:28.350 --> 00:21:29.070
address.

312
00:21:29.250 --> 00:21:29.700
OK.

313
00:21:30.180 --> 00:21:39.840
But that column will only hold a number, and that number will be the primary key or the idea of an

314
00:21:39.840 --> 00:21:40.500
address.

315
00:21:40.530 --> 00:21:40.840
OK.

316
00:21:40.860 --> 00:21:46.680
So in other words, that number in here will point to an address in the addresses table.

317
00:21:46.860 --> 00:21:53.430
And this is one of the ways that we can use a relational database to relate data from one table to another.

318
00:21:53.550 --> 00:21:53.970
OK.

319
00:21:54.570 --> 00:22:01.440
So the way we can do this is we can alter table people.

320
00:22:01.440 --> 00:22:06.990
And actually, why don't I show you exactly how I would learn how to do this, just like we did for

321
00:22:06.990 --> 00:22:08.490
the creation of the address table?

322
00:22:08.500 --> 00:22:10.950
So let me open back up the web browser.

323
00:22:10.980 --> 00:22:16.800
OK, so here we are back in the web browser again, and I will go back to the commands and now I'm doing

324
00:22:16.800 --> 00:22:18.300
an altar table.

325
00:22:19.320 --> 00:22:27.870
And we are going to add so altar, table, add altar, table, table name, add column, altar, table,

326
00:22:27.900 --> 00:22:36.150
table name, which is people add column and let's call this column primary address.

327
00:22:36.480 --> 00:22:41.850
So column and then on the next bit here, that's where we can specify the name of the column, which

328
00:22:41.850 --> 00:22:45.060
is right here, column name and then a column definition.

329
00:22:45.660 --> 00:22:50.430
So our options for column definition will be a data type again.

330
00:22:50.700 --> 00:22:58.770
Now, because this column is going to be pointing to the I-D column of the Addresses column, this column

331
00:22:58.770 --> 00:23:03.410
here only needs to be a data type that can hold a large amount of numbers, right?

332
00:23:03.420 --> 00:23:08.670
In fact, it's basically the same thing as an ID column because it's the IDs from the addresses that

333
00:23:08.670 --> 00:23:10.080
it's going to hold anyway.

334
00:23:10.440 --> 00:23:17.520
So a safe bet for a data type to use here would be a big event, just as we used for the ID columns

335
00:23:17.520 --> 00:23:21.330
on both the people table and the addresses table itself.

336
00:23:21.930 --> 00:23:22.320
All right.

337
00:23:23.070 --> 00:23:27.450
So a big hint, and I can tell you now we can skip over all this other stuff.

338
00:23:27.450 --> 00:23:31.200
However, this last bit here column constraint definition.

339
00:23:31.410 --> 00:23:32.910
We do want to take a look at that.

340
00:23:33.360 --> 00:23:33.680
All right.

341
00:23:33.690 --> 00:23:41.670
So now here we won't be making this column a primary key, but there is another option that we could

342
00:23:41.670 --> 00:23:44.970
specify, which is this references specification.

343
00:23:45.180 --> 00:23:51.720
And if we click on that, what we can do here is we can tell the database that this column is going

344
00:23:51.720 --> 00:23:56.680
to refer to another column somewhere else.

345
00:23:56.730 --> 00:24:02.190
And this is where we're really setting up this relationship between one table and another, or at least

346
00:24:02.190 --> 00:24:05.520
specifically between one column and another column.

347
00:24:05.970 --> 00:24:14.220
So here we can specify that this new primary address column will be referencing, or it references the

348
00:24:14.220 --> 00:24:17.070
address tables ID column.

349
00:24:17.070 --> 00:24:24.080
OK, so that's what we want to specify here and so we can type in this references keyword here references.

350
00:24:25.110 --> 00:24:33.870
Then we need the table name, which in this case is addresses, then a parentheses and then the name

351
00:24:33.870 --> 00:24:36.780
of a column that this should point to or reference.

352
00:24:38.280 --> 00:24:44.130
Parentheses, I.D. And then I can close it off like that with a closing parentheses.

353
00:24:44.460 --> 00:24:46.020
And that's what we need here.

354
00:24:46.320 --> 00:24:52.380
Now the reason for doing this, this is actually optional, but by doing it, the database can help

355
00:24:52.380 --> 00:24:55.740
us to maintain what is called referential integrity.

356
00:24:55.950 --> 00:25:02.760
And that basically just means that if we choose to specify a value in the primary address column, the

357
00:25:02.760 --> 00:25:09.960
database will make sure that that value that we specify there is a legitimate ID of an actual address

358
00:25:09.960 --> 00:25:11.010
in the database.

359
00:25:11.490 --> 00:25:18.510
The database will also ensure that we cannot accidentally delete an address if that address is being

360
00:25:18.510 --> 00:25:20.370
used by a person.

361
00:25:20.640 --> 00:25:24.150
It will give us a warning and actually it won't even allow us to do it.

362
00:25:24.360 --> 00:25:30.510
We'd have to do a little extra work if we wanted to be able to delete an address that's being utilized

363
00:25:30.510 --> 00:25:34.860
or or or referenced or referred to by a person.

364
00:25:34.890 --> 00:25:42.270
OK, so those are some of the things that we get for free when we specify these relationships explicitly,

365
00:25:42.270 --> 00:25:43.380
as we're doing here.

366
00:25:43.410 --> 00:25:46.050
All right, so let's go ahead and execute this.

367
00:25:47.380 --> 00:25:54.130
Now, notice this actually is taking a few seconds to execute because we are in effect modifying in

368
00:25:54.130 --> 00:25:55.690
some ways every single row.

369
00:25:55.720 --> 00:26:00.220
All five million and 11 rows of the people table.

370
00:26:00.280 --> 00:26:00.640
All right.

371
00:26:04.160 --> 00:26:09.500
All right, and let's just take a quick look here, so that actually took 46 seconds on my computer,

372
00:26:09.500 --> 00:26:14.210
so that may take even longer for some of you have got a pretty fast computer that I'm running on right

373
00:26:14.210 --> 00:26:14.570
now.

374
00:26:15.110 --> 00:26:15.530
OK.

375
00:26:15.890 --> 00:26:22.100
And so now if we come back over here and execute this query to just look at the first 10 rows of the

376
00:26:22.100 --> 00:26:27.980
people table, we now see that we've got an additional primary address column, which is currently null,

377
00:26:27.980 --> 00:26:33.770
which makes sense because we haven't actually put any data in there, but it's ready to go if and when

378
00:26:33.770 --> 00:26:34.640
we want to.

379
00:26:34.820 --> 00:26:40.880
And now let me even show you here that I can't just insert any random thing in here because of the referential

380
00:26:40.880 --> 00:26:42.710
integrity, constraints and things.

381
00:26:43.010 --> 00:26:55.760
So if I try to update the people table and set primary and dress equal to 1000, which is a record that

382
00:26:55.760 --> 00:27:04.880
does not exist currently in the address table where ID equals and I'm just going to pick somebody equals

383
00:27:04.880 --> 00:27:05.240
one.

384
00:27:05.690 --> 00:27:05.970
OK?

385
00:27:05.990 --> 00:27:12.080
So in other words, we are going to tell the database to update the first rose primary address to be

386
00:27:12.080 --> 00:27:12.870
1000.

387
00:27:12.890 --> 00:27:15.080
OK, so let's try that and see what happens.

388
00:27:15.590 --> 00:27:19.610
We get a referential integrity constraint violation.

389
00:27:20.150 --> 00:27:26.150
And so it's just doing what I said it would do, which is it's saying you can't refer to an Address

390
00:27:26.150 --> 00:27:28.970
1000 because there is no address 1000.

391
00:27:28.970 --> 00:27:30.410
So I'm not going to let you do that.

392
00:27:30.680 --> 00:27:35.990
That's what this is saying and that is expected and quite frequently in many databases.

393
00:27:35.990 --> 00:27:38.510
That is desirable functionality, in fact.

394
00:27:39.260 --> 00:27:39.570
All right.

395
00:27:39.590 --> 00:27:45.650
And then let's also go back over here to the Objects tab, and I'm going to right click on addresses

396
00:27:45.650 --> 00:27:46.760
to refresh it.

397
00:27:48.590 --> 00:27:48.950
OK.

398
00:27:49.100 --> 00:27:54.260
And so now one more thing I want to look at here is the Exported Keys tab.

399
00:27:54.470 --> 00:28:00.080
Now, although we didn't look at it explicitly before, I can tell you that right after we created this

400
00:28:00.080 --> 00:28:05.450
address, this table initially, if I had clicked on this exported keys tab, there wouldn't have been

401
00:28:05.450 --> 00:28:06.200
anything there.

402
00:28:06.320 --> 00:28:08.210
Let's see if we have anything there now.

403
00:28:08.540 --> 00:28:09.350
Yes, we do.

404
00:28:10.070 --> 00:28:16.580
So we have one row in here, and so let me expand out a few of these columns and explain what we're

405
00:28:16.580 --> 00:28:19.130
seeing here, if it's not obvious.

406
00:28:19.640 --> 00:28:20.120
OK.

407
00:28:20.150 --> 00:28:28.280
So what we're seeing here is that now that we have added that constraint between the people tables primary

408
00:28:28.280 --> 00:28:36.620
address column and the ID column of the Addresses column, the database has further made note of these

409
00:28:36.620 --> 00:28:37.640
relationships.

410
00:28:37.880 --> 00:28:44.720
And so this is telling us that not only do we have a relationship now between these two tables, but

411
00:28:44.750 --> 00:28:54.630
the address tables idea column is said to be exported out to the people tables primary address column.

412
00:28:54.650 --> 00:28:55.100
OK.

413
00:28:55.190 --> 00:29:01.460
In other words, values that exist in the people tables primary address field should be values that

414
00:29:01.460 --> 00:29:04.360
are coming from the address tables ID column.

415
00:29:04.370 --> 00:29:07.820
OK, so we're just restating things from from different perspectives.

416
00:29:07.820 --> 00:29:15.950
From the perspective of the address table, its ID column is exported out to the People Tables primary

417
00:29:15.950 --> 00:29:16.880
address column.

418
00:29:17.120 --> 00:29:22.400
And then if we come down here and click on People Table, there are no exported keys here, but there

419
00:29:22.400 --> 00:29:24.170
is one imported key.

420
00:29:24.230 --> 00:29:28.220
OK, so this is just showing the relationship from both sides of these tables.

421
00:29:28.490 --> 00:29:33.560
Another way of describing this type of relationship is to say we now have a foreign key.

422
00:29:33.950 --> 00:29:42.050
The people tables primary address, column or field has a foreign key, pointing to the address tables

423
00:29:42.050 --> 00:29:42.920
ID column.

424
00:29:42.920 --> 00:29:46.070
OK, so you've got a foreign key and there's a constraint there.

425
00:29:46.070 --> 00:29:51.830
So in fact, you'll often hear or see even databases refer to something called a foreign key constraint.

426
00:29:52.070 --> 00:29:58.100
So again, that foreign key constraint just means that you can't just willy nilly put any value into

427
00:29:58.100 --> 00:29:59.450
the people tables.

428
00:29:59.630 --> 00:30:01.280
Primary address column.

429
00:30:01.520 --> 00:30:08.270
The values that you can put in there are constrained by legitimate IDs of the addresses table.

430
00:30:08.450 --> 00:30:10.610
All right, so I think that's enough of this.

431
00:30:10.610 --> 00:30:16.460
In the next lesson, we will go back into the Java side of the world and we will model this address

432
00:30:16.460 --> 00:30:19.950
concept there, and then we will marry these two things up.

433
00:30:19.970 --> 00:30:20.390
OK.

434
00:30:20.510 --> 00:30:22.370
So that's what we're going to do in the next one.

435
00:30:22.400 --> 00:30:22.940
See you then.
