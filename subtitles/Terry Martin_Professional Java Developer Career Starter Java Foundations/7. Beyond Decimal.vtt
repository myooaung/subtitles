WEBVTT
1
00:00:00.180 --> 00:00:07.200
There's one more thing I want to show you with these numbers systems in Java, when we are defining

2
00:00:07.200 --> 00:00:13.530
variables or just creating constants of numbers with more than just decimal notation.

3
00:00:13.710 --> 00:00:25.350
Let me show you what I mean, so we could create a byte variable, another byte and instead of assigning

4
00:00:25.350 --> 00:00:36.030
it a value like whatever 45, we could use a different number system here, so I could specify a number

5
00:00:36.030 --> 00:00:44.250
in hexadecimal and to do so, what I need to do is I just prepend the hexadecimal number with zero x.

6
00:00:44.820 --> 00:00:53.640
So that tells Java that the number I'm about to type in is going to be in hexadecimal instead of decimal.

7
00:00:54.000 --> 00:00:59.500
So now I can type something like one F, and that's perfectly valid.

8
00:00:59.520 --> 00:01:00.750
That's that's a number.

9
00:01:01.050 --> 00:01:01.500
OK.

10
00:01:02.220 --> 00:01:04.610
I can also do the same.

11
00:01:04.620 --> 00:01:06.360
And by the way, it doesn't have to be a byte.

12
00:01:06.360 --> 00:01:09.030
It could be anything so I could use an end.

13
00:01:09.960 --> 00:01:11.110
Another Oops.

14
00:01:11.160 --> 00:01:11.800
Another.

15
00:01:11.820 --> 00:01:14.790
And so I could do.

16
00:01:16.320 --> 00:01:17.670
The same thing here as well.

17
00:01:18.030 --> 00:01:26.310
Now I can also type in numbers in binary, and to do that, I do a zero B and then I can type whatever.

18
00:01:26.320 --> 00:01:26.640
Oops.

19
00:01:26.640 --> 00:01:29.370
Well, and that's not a two to two wouldn't work, right?

20
00:01:29.490 --> 00:01:35.020
So there that's how you can enter a binary number, so binary or hexadecimal numbers.

21
00:01:35.520 --> 00:01:42.000
So obviously, the places where you'd actually need or want to do this will be probably considerably

22
00:01:42.000 --> 00:01:45.210
less for most programmers than just using decimal.

23
00:01:45.330 --> 00:01:49.500
But there are a few really good reasons why you might want to do this.

24
00:01:49.860 --> 00:01:55.920
I showed in one of the earlier programs let me see if I can bring that up, in fact.

25
00:01:56.190 --> 00:01:56.490
Yeah.

26
00:01:56.760 --> 00:02:00.480
So going back to the X lesson here.

27
00:02:00.870 --> 00:02:09.930
OK, so if you recall down here where where we are creating our pattern for a Rig X, we can pass in

28
00:02:09.930 --> 00:02:20.430
a second parameter which is turning on or off various additional capabilities of the regular expression

29
00:02:20.430 --> 00:02:21.210
engine.

30
00:02:21.720 --> 00:02:28.290
And so here I've turned on comments, but there are many other what are called flags that I could turn

31
00:02:28.290 --> 00:02:37.110
on, and I turn those on by using a pipe symbol and then adding in more of these constants are these

32
00:02:37.110 --> 00:02:40.530
flags so I can turn on the dot all, for example, the MI.

33
00:02:42.340 --> 00:02:49.420
Let's make a little room here, and I could do another pipe and pass in another flag cannon.

34
00:02:49.690 --> 00:02:50.520
Q Right.

35
00:02:50.530 --> 00:02:54.610
So I could just keep doing this to specify all these different.

36
00:02:56.940 --> 00:02:58.290
All these different flags.

37
00:02:58.650 --> 00:03:09.360
Now what's actually going on, though, is that these flags are actually binary bits that we are setting

38
00:03:09.390 --> 00:03:11.570
to one or zero.

39
00:03:11.570 --> 00:03:13.680
Well, in this case, we're setting them to one.

40
00:03:13.920 --> 00:03:14.370
OK?

41
00:03:14.670 --> 00:03:22.590
Each of these values here is a binary bit of a binary number.

42
00:03:23.040 --> 00:03:31.470
And when we specify them here, we're setting that particular bit on a binary number to one.

43
00:03:31.590 --> 00:03:35.730
So what I mean is, for example, this that, well, actually here we can act.

44
00:03:35.740 --> 00:03:38.250
We can actually go, look and see what this value is.

45
00:03:38.280 --> 00:03:40.200
So if I just control, click on it.

46
00:03:40.590 --> 00:03:41.820
This is and look at that.

47
00:03:41.820 --> 00:03:44.040
Actually, it's specified in hexadecimal.

48
00:03:44.370 --> 00:03:46.790
So this is a hexadecimal two.

49
00:03:47.640 --> 00:03:49.530
This is a hexadecimal one.

50
00:03:49.860 --> 00:03:53.010
Now look at look at how these values are being set.

51
00:03:53.190 --> 00:03:57.630
Unix lines, this is a constant Unix lines is set to one case.

52
00:03:57.630 --> 00:04:02.310
Insensitive as to comments is for multi-line is ET.

53
00:04:03.300 --> 00:04:04.920
Do you notice a pattern here?

54
00:04:05.040 --> 00:04:07.110
Now these are hex hexadecimal, though.

55
00:04:07.280 --> 00:04:13.920
However, from one to not R from zero to nine, those are going to be the same as they would be in decimal.

56
00:04:13.950 --> 00:04:14.400
OK.

57
00:04:14.550 --> 00:04:20.340
It's not until we get up here to hexadecimal one zero that we actually are doing something different

58
00:04:20.340 --> 00:04:21.480
from decimal now.

59
00:04:21.660 --> 00:04:24.390
So this would not actually be a 10.

60
00:04:24.900 --> 00:04:27.510
This would actually be 16.

61
00:04:27.720 --> 00:04:28.230
OK.

62
00:04:28.470 --> 00:04:32.740
So look at that one two four eight 16.

63
00:04:33.510 --> 00:04:34.020
You get it.

64
00:04:34.230 --> 00:04:36.030
Thirty two, et cetera.

65
00:04:36.240 --> 00:04:38.520
Why are these being numbered in this way?

66
00:04:38.670 --> 00:04:45.920
Well, the reason is because each of these represents one bit in a binary number.

67
00:04:45.930 --> 00:04:53.250
So if we go look at our little binary chart here, I'll zoom in a bit.

68
00:04:56.110 --> 00:05:01.180
One, two, four, eight, 16, 32, 64, 128.

69
00:05:01.480 --> 00:05:09.310
So each of those constants represents one bit in awe, one of the places in a binary number.

70
00:05:10.950 --> 00:05:18.720
So if we were to specify that we wanted this constant here Unix lines, which has a value of one, what

71
00:05:18.720 --> 00:05:21.810
that would in effect do is it would set here.

72
00:05:22.000 --> 00:05:23.730
Well, I'll convey it down here.

73
00:05:23.880 --> 00:05:26.670
That would set a one right there.

74
00:05:27.450 --> 00:05:35.080
And then if we were to turn on this case insensitive, which has a value of two, that would set a binary

75
00:05:35.080 --> 00:05:37.440
bet right here in the two's column.

76
00:05:38.070 --> 00:05:44.400
And if we wanted to turn on comments which has a binary value or a hex value, rather a four that would

77
00:05:44.400 --> 00:05:45.600
set a one.

78
00:05:48.430 --> 00:05:51.010
Right here and so on and so forth.

79
00:05:51.130 --> 00:05:58.600
So we'd be turning on and off various settings of how the regular expression engine should behave.

80
00:05:58.840 --> 00:06:05.590
You're really just flipping toggles on and off each of these places is would be thought of as a toggle

81
00:06:05.590 --> 00:06:06.130
switch.

82
00:06:06.400 --> 00:06:08.230
If there's a zero, it's off.

83
00:06:08.380 --> 00:06:11.230
If there's a one, then you're toggling it on.

84
00:06:11.290 --> 00:06:11.800
OK.

85
00:06:11.980 --> 00:06:20.590
And so if you were to use a bite to represent all of those possible capabilities being turned on or

86
00:06:20.590 --> 00:06:26.920
off, then you could have up to eight possible things that you could turn on or off.

87
00:06:27.340 --> 00:06:30.550
If we go back over here, I want to show you what?

88
00:06:30.550 --> 00:06:32.590
What's up with this little symbol here?

89
00:06:32.860 --> 00:06:41.530
So this this little or this is this is and this is a symbol that represents what is called an or function.

90
00:06:41.770 --> 00:06:42.220
OK.

91
00:06:42.820 --> 00:06:47.980
And again, don't worry, I don't want to get too deep into this, but it's actually pretty simple.

92
00:06:48.370 --> 00:06:58.540
So all we're really saying is this symbol is enabling Java to combine all of these different bits into

93
00:06:58.570 --> 00:07:07.090
one number one binary number, and it doesn't matter what order they come in because each of these is

94
00:07:07.090 --> 00:07:11.500
a value in its own column of a bite.

95
00:07:11.680 --> 00:07:12.160
OK.

96
00:07:12.670 --> 00:07:21.220
So if we wanted to have a value of one one one, whatever that turns on the way we could do that in

97
00:07:21.220 --> 00:07:23.410
Java is just like this.

98
00:07:23.710 --> 00:07:30.250
You could have whatever the value is for the one's place, which now now I'm ignoring what these values

99
00:07:30.250 --> 00:07:31.960
really are because I don't remember what they were.

100
00:07:31.970 --> 00:07:37.300
But let's say that this was the ones place that's two, four and eight.

101
00:07:37.480 --> 00:07:37.930
OK.

102
00:07:38.380 --> 00:07:45.070
So if you wanted to turn all of those on, all you have to do is specify that here's a number that has

103
00:07:45.070 --> 00:07:46.280
a one.

104
00:07:46.420 --> 00:07:53.230
And then you would use this symbol to add in a SIM, a two and a four and an eight.

105
00:07:53.440 --> 00:07:57.490
And you would end up with ones in all of these locations.

106
00:07:57.640 --> 00:08:04.030
Let me show you a little bit better, maybe what that actually might look like.

107
00:08:04.630 --> 00:08:07.750
So if we go back over here to the numbers, stuff thing here.

108
00:08:09.650 --> 00:08:12.230
And actually, I can show you this in binary.

109
00:08:13.920 --> 00:08:16.040
So I'll start with the number one here.

110
00:08:17.220 --> 00:08:20.910
And we will print this out.

111
00:08:22.450 --> 00:08:23.860
Another event.

112
00:08:24.160 --> 00:08:28.150
OK, so if we just run this, that should print out the number one.

113
00:08:29.990 --> 00:08:30.890
Yeah, there we go.

114
00:08:30.920 --> 00:08:32.330
So we got a one here.

115
00:08:33.020 --> 00:08:40.340
Now if we wanted the number three to start over here, so currently we've got a one.

116
00:08:40.580 --> 00:08:46.370
Now, if we wanted the number three, that would be in binary, a one here, plus a one here in the

117
00:08:46.370 --> 00:08:47.570
twos place, right?

118
00:08:48.290 --> 00:08:50.150
So that would be a three.

119
00:08:50.720 --> 00:08:54.770
Now we could put the number three in here in a couple of ways.

120
00:08:55.040 --> 00:08:58.910
We could obviously we could just set it to three like that.

121
00:08:58.910 --> 00:09:01.580
And when we run this, that would give us a three.

122
00:09:02.100 --> 00:09:06.440
Or we could do this in binary with one one.

123
00:09:07.010 --> 00:09:07.750
That would be a three.

124
00:09:07.760 --> 00:09:09.860
In fact, let's go ahead and run that and prove it.

125
00:09:10.550 --> 00:09:11.090
There we go.

126
00:09:11.120 --> 00:09:12.620
So there's a three, right?

127
00:09:13.160 --> 00:09:15.770
But another way we could do this.

128
00:09:15.920 --> 00:09:23.000
I'm going to I'm going to put a binary one here, and then I'm going to order this with that pipe symbol

129
00:09:23.000 --> 00:09:23.330
there.

130
00:09:24.350 --> 00:09:30.410
I'm going to or this with another binary number of a two, which is one zero.

131
00:09:30.860 --> 00:09:31.370
OK.

132
00:09:32.330 --> 00:09:34.460
So I've got a zero one.

133
00:09:35.420 --> 00:09:39.860
And you can almost think of this as a plus plus one zero.

134
00:09:40.400 --> 00:09:46.100
And so if I run this in, don't worry, I'm going to show this visually in a couple more ways in just

135
00:09:46.100 --> 00:09:46.550
a moment here.

136
00:09:46.550 --> 00:09:50.830
But if I run this, I should still get a three look at that.

137
00:09:50.840 --> 00:09:52.130
I still get a three.

138
00:09:53.000 --> 00:09:59.030
The reason I'm getting this, this is kind of like you can almost think of this sort of like a binary

139
00:09:59.060 --> 00:09:59.990
addition.

140
00:09:59.990 --> 00:10:00.900
Sort of kind of.

141
00:10:01.250 --> 00:10:04.400
It's not quite adicional, but it's something kind of like that.

142
00:10:04.550 --> 00:10:06.830
Let me show you what this looks like over here.

143
00:10:06.980 --> 00:10:11.270
So what I just did is I'm going to clear that out.

144
00:10:12.530 --> 00:10:14.170
In fact, I'm going to put a zero here.

145
00:10:14.350 --> 00:10:14.860
I just.

146
00:10:15.190 --> 00:10:17.920
First, we had a binary one.

147
00:10:19.220 --> 00:10:24.140
And then I ordered that with a binary, too.

148
00:10:25.220 --> 00:10:35.150
And what the order function does is it says I want a value at the end of this function, which is the

149
00:10:35.480 --> 00:10:37.850
composite of the two inputs.

150
00:10:37.850 --> 00:10:41.360
So I input it a one and then I input it a two.

151
00:10:41.600 --> 00:10:48.590
And the way that it does this is it looks at this one and this zero here, and it says if either of

152
00:10:48.590 --> 00:10:52.700
these is a one, then let the final answer be one.

153
00:10:53.510 --> 00:10:54.410
And same thing here.

154
00:10:54.410 --> 00:10:58.190
If either of these is a one, then let the final answer be a one.

155
00:10:58.640 --> 00:11:02.090
And then this final thing here, two ones, that's a three.

156
00:11:03.370 --> 00:11:08.830
Now with or if you had a zero and a zero.

157
00:11:10.090 --> 00:11:12.160
The result would be zero.

158
00:11:12.370 --> 00:11:12.820
OK.

159
00:11:13.790 --> 00:11:20.060
So all it's doing is just saying for any two inputs, both inputs are zero than the output is going

160
00:11:20.060 --> 00:11:20.770
to be a zero.

161
00:11:20.780 --> 00:11:25.880
If either of the inputs is a one, then the output is going to be one.

162
00:11:26.030 --> 00:11:31.580
And if both are a one, then the output will also be a one.

163
00:11:32.120 --> 00:11:35.400
OK, so that's how an order works.

164
00:11:35.420 --> 00:11:35.790
OK.

165
00:11:36.140 --> 00:11:39.080
So that's what we're doing here.

166
00:11:39.080 --> 00:11:44.780
We're we're saying, I want you to order a one and a two together.

167
00:11:44.930 --> 00:11:48.620
Now, interestingly, we could also do this in decimal.

168
00:11:48.740 --> 00:11:52.880
We could just do this one or two.

169
00:11:52.910 --> 00:11:53.600
Just like that.

170
00:11:53.600 --> 00:11:55.280
I know it looks super weird, right?

171
00:11:55.850 --> 00:12:03.290
And when we run, this is still going to give us a three because fundamentally you're still just manipulating

172
00:12:03.290 --> 00:12:06.220
bits and we could even do more.

173
00:12:06.230 --> 00:12:08.660
We could or another number here.

174
00:12:08.660 --> 00:12:10.370
So let's see.

175
00:12:10.370 --> 00:12:10.850
We've got two.

176
00:12:11.330 --> 00:12:14.630
Yeah, if we order a binary for.

177
00:12:17.060 --> 00:12:18.530
Which would look like this.

178
00:12:19.130 --> 00:12:21.110
I'll put the leading zeros in.

179
00:12:21.920 --> 00:12:26.550
So we're just dealing with these three binary numbers right here.

180
00:12:26.630 --> 00:12:28.610
So we're offering all of these together.

181
00:12:28.820 --> 00:12:35.120
So now we should get what do you know, what the result of this would be if we were to or these three

182
00:12:35.120 --> 00:12:43.760
numbers, these three binary numbers together, we should get a seven because starting from the highest

183
00:12:43.760 --> 00:12:48.980
bit here, zero AUD with a zero or with a one will still be a one.

184
00:12:49.520 --> 00:12:51.890
You're going to get a one here because of that one.

185
00:12:52.310 --> 00:12:54.980
And you're going to get a one here because of this one.

186
00:12:55.130 --> 00:13:00.290
And the result of that is four plus two, which is six plus one, which is seven.

187
00:13:01.070 --> 00:13:01.490
OK.

188
00:13:01.730 --> 00:13:06.860
So if we were to order a one, a two and a four like so.

189
00:13:08.230 --> 00:13:13.450
We should get a seven, which looks like addition when you're looking at it in decimal, right, four

190
00:13:13.450 --> 00:13:15.820
plus two or six plus one is is seven.

191
00:13:16.030 --> 00:13:18.160
So obviously we're going to get a seven here.

192
00:13:18.700 --> 00:13:19.270
There we go.

193
00:13:19.570 --> 00:13:22.600
Now let's translate this into binary.

194
00:13:23.080 --> 00:13:23.350
All right.

195
00:13:23.350 --> 00:13:37.090
So if we do this in binary, we'll do a a one or two with a two chord with a four and run that.

196
00:13:37.960 --> 00:13:38.640
And there we go.

197
00:13:38.650 --> 00:13:39.970
We still have a seven there.

198
00:13:40.240 --> 00:13:44.740
And you could do this in hexadecimal as well, but I'll leave that as an exercise for you.

199
00:13:45.220 --> 00:13:50.920
So going back to the regular expression thing here.

200
00:13:52.750 --> 00:14:01.570
Yeah, so all we're doing is adding up smaller bits of a binary number to make up one total number and

201
00:14:01.570 --> 00:14:09.580
then the code that was written to determine how the compile method should work is going to look at these

202
00:14:09.580 --> 00:14:13.840
and it can actually pass these out and determine what to turn on and off.

203
00:14:14.470 --> 00:14:23.030
So let me show really briefly how this compile method is possibly learning what to turn on or off.

204
00:14:23.050 --> 00:14:26.590
Also, just so you have a little bit of a picture of that as well.

205
00:14:27.010 --> 00:14:34.960
So if we go back over here to numbers stuff, so this another end now has three bits turned on, if

206
00:14:34.960 --> 00:14:37.180
you will, one, two and four.

207
00:14:37.390 --> 00:14:47.260
OK, now if we wanted to know programmatically if the bit in the fourth place is enabled, one way we

208
00:14:47.260 --> 00:14:49.960
could do that is with binary math.

209
00:14:50.890 --> 00:14:58.300
Now, the way to determine which of these bits is turned on is by using another binary operation, which

210
00:14:58.300 --> 00:15:02.320
is called And let me show you what that would look like.

211
00:15:02.800 --> 00:15:10.690
So let's say we have one, two and four all turned on and stored in a variable, but our code is looking

212
00:15:10.690 --> 00:15:15.700
at that variable and wants to determine programmatically which of these bits has turned on.

213
00:15:15.940 --> 00:15:24.160
The code can basically test whether any of these bits are on or off by using another binary operation

214
00:15:24.160 --> 00:15:24.530
called.

215
00:15:24.550 --> 00:15:27.990
And so we've seen what an order looks like.

216
00:15:28.000 --> 00:15:30.940
Now let's look at look at what an end does.

217
00:15:31.390 --> 00:15:34.600
I'm going to clear these out and we'll start with something simple here.

218
00:15:34.600 --> 00:15:43.900
If we have a one and a zero and we want to ask what happens with an end operation between one and zero?

219
00:15:44.140 --> 00:15:51.880
Well, the way that an and works is all of the inputs have to be on or set to one for an output to be

220
00:15:51.880 --> 00:15:52.240
one.

221
00:15:52.480 --> 00:16:00.610
So if you have a one and a zero, the output will be zero because they're not both on.

222
00:16:00.730 --> 00:16:05.890
They both have to be on or set to one for the output to be one.

223
00:16:05.920 --> 00:16:08.500
OK, so one in zero yields zero.

224
00:16:09.870 --> 00:16:15.120
Zero and zero also yields a zero.

225
00:16:15.780 --> 00:16:20.640
Only a one and a one can yield a one.

226
00:16:21.330 --> 00:16:29.880
And conversely, zero and one, I'll just show that zero and one will also be a zero.

227
00:16:30.240 --> 00:16:39.240
So with that, armed with that knowledge, what we can do is, let's say we have a variable with the

228
00:16:39.240 --> 00:16:47.100
number seven or a binary one one one, and we want to determine whether or not the 4S place here is

229
00:16:47.100 --> 00:16:48.300
on or not.

230
00:16:48.630 --> 00:16:55.800
Well, what we can do is we can apply what's called a bit mask, where we can start off with a known

231
00:16:55.800 --> 00:17:01.290
number of just for what's in binary would be a one zero zero.

232
00:17:01.590 --> 00:17:02.040
OK.

233
00:17:02.640 --> 00:17:07.440
And then when we and these two numbers together?

234
00:17:09.200 --> 00:17:21.800
If this number has the four place set to one or on and we end it with a four, then we will get a four

235
00:17:22.160 --> 00:17:22.730
out.

236
00:17:24.730 --> 00:17:25.580
Just like that.

237
00:17:25.600 --> 00:17:30.130
And that's how you would know whether or not this was on or not.

238
00:17:30.430 --> 00:17:33.550
And the same goes for the twos and the ones place.

239
00:17:33.550 --> 00:17:35.020
So you could and.

240
00:17:37.130 --> 00:17:39.170
I'll set that to zero, and I'll set this to one.

241
00:17:39.410 --> 00:17:47.570
So if we ended these two numbers together, that would tell us if two was on or not because we'd get

242
00:17:47.570 --> 00:17:48.860
a two back out.

243
00:17:49.370 --> 00:17:51.740
Conversely, if two was not on.

244
00:17:53.250 --> 00:18:02.370
And we ended this number with a two like, so you'd get a zero out, and that would tell you that this

245
00:18:02.370 --> 00:18:04.650
bit is not on.

246
00:18:05.070 --> 00:18:06.600
Let me show you what that looks like.

247
00:18:07.050 --> 00:18:09.830
So here we've got a seven, right?

248
00:18:09.840 --> 00:18:11.370
We've got one one one.

249
00:18:12.380 --> 00:18:18.710
And we want to know if the fourth place is, which is here is on.

250
00:18:19.250 --> 00:18:26.330
So what we could do is we could take this variable another event and we could and it now the way that

251
00:18:26.330 --> 00:18:31.520
you do it and you don't use a pipe, instead, you use the ampersand symbol.

252
00:18:32.030 --> 00:18:38.540
We could end that with the number four and I can enter this number four in any number of ways now,

253
00:18:38.540 --> 00:18:38.750
right?

254
00:18:38.750 --> 00:18:46.700
I could do decimal as I have here, or I could do binary one zero zero or I could do hexadecimal, which

255
00:18:46.700 --> 00:18:49.280
would just be four, right?

256
00:18:49.280 --> 00:18:51.410
So I could enter that in any number of ways.

257
00:18:52.410 --> 00:19:00.030
And so when I run this, I should get the number four out because I do have the fourth bit or the four

258
00:19:00.030 --> 00:19:01.890
place bit enabled.

259
00:19:02.130 --> 00:19:02.670
There it is.

260
00:19:02.670 --> 00:19:03.360
There's the floor.

261
00:19:03.570 --> 00:19:06.360
Now if I set this to zero.

262
00:19:08.640 --> 00:19:11.940
And I run this again, I should now get a zero.

263
00:19:12.480 --> 00:19:13.770
There it is zero.

264
00:19:13.950 --> 00:19:21.780
And so that's how I can determine programmatically which bits are on or off using something called a

265
00:19:22.080 --> 00:19:22.770
mask.

266
00:19:23.100 --> 00:19:30.930
One place where you will see that masks used is with internet addresses or IP addresses.

267
00:19:31.110 --> 00:19:39.000
I mean, if you've ever seen an address that looks like this for on the internet 192.168.1.1, these

268
00:19:39.000 --> 00:19:41.080
are actually bytes.

269
00:19:41.790 --> 00:19:42.210
OK?

270
00:19:42.270 --> 00:19:45.450
Each of these is is a byte in networking.

271
00:19:45.450 --> 00:19:50.220
These would be called octet, but an octet is a byte, meaning a grouping of eight.

272
00:19:50.280 --> 00:19:50.580
Right?

273
00:19:50.760 --> 00:19:53.100
It really means a grouping of eight bits.

274
00:19:53.160 --> 00:19:53.610
OK.

275
00:19:53.940 --> 00:19:55.380
So these are octet.

276
00:19:55.770 --> 00:19:58.800
These could be represented in pure binary.

277
00:19:59.400 --> 00:20:02.190
I'm going to make a really simple IP address.

278
00:20:02.190 --> 00:20:06.010
In fact, here I'll just say IP address.

279
00:20:06.030 --> 00:20:06.440
OK.

280
00:20:06.480 --> 00:20:08.670
Just so you know what we're talking about here.

281
00:20:08.970 --> 00:20:14.100
I'm going to make a simpler IP address because I don't feel like trying to convert these into something

282
00:20:14.370 --> 00:20:16.230
that in my head or quickly.

283
00:20:16.620 --> 00:20:22.890
So let's say we had an IP address of 5.5 Dot five Dot three.

284
00:20:23.430 --> 00:20:23.880
OK.

285
00:20:24.570 --> 00:20:32.970
So that could be represented as zero b one zero one and then zero b one zero one and then zero B one

286
00:20:32.970 --> 00:20:36.600
zero one and then zero b zero one one.

287
00:20:36.930 --> 00:20:37.380
OK.

288
00:20:37.710 --> 00:20:40.230
So that is an IP address.

289
00:20:40.590 --> 00:20:47.070
Now, if any of you have ever had to configure your router at home or something like that, if you got

290
00:20:47.070 --> 00:20:54.270
a little fancy with it, you may have noticed that sometimes routers will have a setting called netmask

291
00:20:54.450 --> 00:21:00.400
or or network mask or something along those words.

292
00:21:00.420 --> 00:21:01.560
The word mask will.

293
00:21:01.560 --> 00:21:03.150
It will usually be in it.

294
00:21:03.540 --> 00:21:07.900
That mask there is the same thing that I just did down here.

295
00:21:07.980 --> 00:21:09.930
It specifies something.

296
00:21:09.930 --> 00:21:17.640
So in this case, what it specifies is which actually here let me let me actually make these a little

297
00:21:17.640 --> 00:21:21.060
more normalized with four bits each.

298
00:21:22.110 --> 00:21:22.590
Here we go.

299
00:21:22.860 --> 00:21:23.250
OK.

300
00:21:24.190 --> 00:21:33.250
And in fact, I will even write these out a little more like this zero one zero one zero one zero one

301
00:21:33.250 --> 00:21:35.920
zero one zero one zero zero one one.

302
00:21:36.190 --> 00:21:36.580
OK.

303
00:21:37.120 --> 00:21:46.570
So in internet address is part of an IP address or an internet protocol address can be thought of as

304
00:21:46.930 --> 00:21:51.110
a city and a street address.

305
00:21:51.190 --> 00:21:51.640
OK.

306
00:21:51.700 --> 00:21:53.590
I'm just giving you kind of an analogy here.

307
00:21:54.160 --> 00:21:54.460
All right.

308
00:21:54.490 --> 00:22:01.840
So for any given IP address, part of that address might represent the city.

309
00:22:02.140 --> 00:22:06.520
And I don't mean geographically, I just mean like to two levels of grouping.

310
00:22:06.550 --> 00:22:07.000
OK.

311
00:22:07.390 --> 00:22:12.010
One level of grouping literally is is considered the network address.

312
00:22:12.340 --> 00:22:19.270
And then the other part of that address, well, technically it's called the host, the host, the address.

313
00:22:19.300 --> 00:22:19.720
OK.

314
00:22:20.110 --> 00:22:27.640
But all both of those the network address and the host address will be encapsulated all inside of the

315
00:22:27.640 --> 00:22:29.140
total IP address.

316
00:22:29.380 --> 00:22:36.220
However, which parts are the network and which parts are the host will not be clear.

317
00:22:36.520 --> 00:22:42.490
Just by looking at one IP address, you need something else to tell you.

318
00:22:42.670 --> 00:22:47.800
Where does the network address stop and the host address begin?

319
00:22:48.070 --> 00:22:53.650
And that thing that is typically used to tell us that is called a network mask.

320
00:22:54.130 --> 00:23:00.400
And the way the network mask works is, I'll just show you here it will be.

321
00:23:02.990 --> 00:23:04.490
Something like this.

322
00:23:08.200 --> 00:23:16.060
So in this case, what we're saying is any bits that correspond to where these ones are?

323
00:23:16.750 --> 00:23:18.670
That is the network mask.

324
00:23:18.690 --> 00:23:22.100
So that would be these to these two nibbles here.

325
00:23:22.150 --> 00:23:22.480
Right?

326
00:23:22.720 --> 00:23:26.740
These sets of bits and then any place where the zeros are.

327
00:23:27.010 --> 00:23:29.700
That's the host address.

328
00:23:29.710 --> 00:23:30.160
OK?

329
00:23:30.340 --> 00:23:32.980
Now this could be any kind of configuration.

330
00:23:32.980 --> 00:23:34.050
Or you could have.

331
00:23:35.380 --> 00:23:36.370
You could have.

332
00:23:38.020 --> 00:23:38.800
Like this.

333
00:23:39.100 --> 00:23:44.830
So the network portion of this address could be all of these bits here and then the rest.

334
00:23:45.900 --> 00:23:50.820
The rest of it could be the host address, so that's pretty arbitrary.

335
00:23:50.850 --> 00:23:51.330
OK.

336
00:23:51.720 --> 00:23:58.770
How that set up, but what ends up happening is that the router or your computer or whatever takes these

337
00:23:58.770 --> 00:24:08.460
two binary numbers and it applies an end operation to them to pass through or filter out whichever parts

338
00:24:08.460 --> 00:24:09.360
shouldn't go.

339
00:24:09.540 --> 00:24:10.020
OK.

340
00:24:10.470 --> 00:24:10.760
All right.

341
00:24:10.770 --> 00:24:18.810
So I'm going to remind you, don't worry if don't worry, if a lot of this isn't super meaningful to

342
00:24:18.810 --> 00:24:21.910
you, there are two two things that I want you to keep in mind.

343
00:24:21.930 --> 00:24:28.530
First off, sometimes it's helpful just to hear the very high level concepts of how things are working.

344
00:24:28.680 --> 00:24:34.860
Even if you're not fully grasping this, even whatever small percentage you might be grasping your kind

345
00:24:34.860 --> 00:24:36.530
of store that in the back of your mind.

346
00:24:36.540 --> 00:24:43.560
And someday, if and when you encounter a problem where you might need this knowledge, you may recall.

347
00:24:43.830 --> 00:24:49.500
You know, that sounds vaguely familiar to me, and you might come back and watch this video and it

348
00:24:49.500 --> 00:24:52.050
might have a little more meaning for you at that time.

349
00:24:52.290 --> 00:24:53.640
So don't don't worry about it.

350
00:24:53.760 --> 00:24:56.160
Sometimes you have to hear these things multiple times.

351
00:24:56.430 --> 00:25:03.240
My purpose here really isn't to make you 100 percent totally knowledgeable about all of these numbers,

352
00:25:03.240 --> 00:25:09.900
systems and and masks and and and binary operations and things like that.

353
00:25:10.050 --> 00:25:16.470
My purpose is really just to kind of introduce you to a little bit more of what's going on, because

354
00:25:16.620 --> 00:25:23.610
the deeper you get into programming, the more often from time to time you will see little hints and

355
00:25:23.610 --> 00:25:30.870
glimpses of these things, like what we saw in this regex configuration here.

356
00:25:31.050 --> 00:25:39.150
This would not be obvious to anyone who had not really gone through and studied how binary masks work,

357
00:25:39.390 --> 00:25:43.140
what's going on here and why we're using this symbol here.

358
00:25:43.230 --> 00:25:47.040
So these symbols, this or here comes from binary.

359
00:25:47.070 --> 00:25:47.550
OK.

360
00:25:48.150 --> 00:25:53.490
And so I just wanted you to have a little deeper understanding of why this was working the way that

361
00:25:53.490 --> 00:25:58.290
it is and how it all comes back to these number systems in one way or another.

362
00:25:59.010 --> 00:25:59.320
All right.

363
00:25:59.340 --> 00:26:02.160
That's going to wrap up this lesson and I'll see you in the next one.
