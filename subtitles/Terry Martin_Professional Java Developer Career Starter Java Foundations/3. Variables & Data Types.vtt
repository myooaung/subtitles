WEBVTT
1
00:00:00.420 --> 00:00:07.380
All right, so in this lesson, we're going to learn a little bit about data types and variables.

2
00:00:07.530 --> 00:00:13.920
This will not be an exhaustive lesson on these topics, but I want to give you enough of a foundation

3
00:00:13.920 --> 00:00:20.370
so that when we pull it all together to do a little more analysis on the the code that we wrote in the

4
00:00:20.370 --> 00:00:25.980
object oriented program and the Hello world, you'll have a basic understanding of what's going on.

5
00:00:26.970 --> 00:00:34.300
So when we turn to the idea here, let's create a new class in the in the business project.

6
00:00:34.300 --> 00:00:38.610
So I'm going to just highlight the source folder here, and I'm going to tell it.

7
00:00:38.610 --> 00:00:40.950
I want to create a new class and I don't know.

8
00:00:40.950 --> 00:00:43.470
I'll just create a person class here.

9
00:00:44.550 --> 00:00:45.750
All right now.

10
00:00:45.750 --> 00:00:47.470
So what are variables?

11
00:00:47.490 --> 00:00:53.730
If you've ever taken algebra or even pre-algebra in school, you probably already pretty much know what

12
00:00:53.790 --> 00:00:54.660
a variable is.

13
00:00:54.990 --> 00:01:01.100
It's just a thing that can hold a value in algebra.

14
00:01:01.110 --> 00:01:03.320
Its use usually a symbol.

15
00:01:03.330 --> 00:01:11.010
It's usually a one character symbol in algebra like X or Y that can be assigned a value like three or

16
00:01:11.010 --> 00:01:20.250
five, or sometimes even assigned an entire function like Y equals index plus B in programming and particularly

17
00:01:20.250 --> 00:01:22.680
in Java, it's pretty similar.

18
00:01:22.740 --> 00:01:28.890
Some differences are that variables in Java can be more than just one character like X or Y.

19
00:01:29.040 --> 00:01:35.490
They can and often should be more descriptive names, and they can hold more than just numbers.

20
00:01:35.670 --> 00:01:37.320
You can store numbers in them.

21
00:01:37.320 --> 00:01:40.530
You can store references to objects in them.

22
00:01:40.980 --> 00:01:41.880
So, yeah, you can.

23
00:01:41.880 --> 00:01:48.170
You can use variables for a few more things than than in math, but same basic idea.

24
00:01:48.180 --> 00:01:54.690
You are assigning a value to something and then you're giving that thing a name so that you can refer

25
00:01:54.690 --> 00:01:56.610
back to it conveniently.

26
00:01:56.730 --> 00:02:02.220
So as I said at the top of this lesson, this lesson is going to talk a little bit about data types

27
00:02:02.220 --> 00:02:03.090
and variables.

28
00:02:03.240 --> 00:02:10.290
Not only is Java an object oriented language, it is also a statically typed language.

29
00:02:10.320 --> 00:02:21.930
What that means is that when we do assign values to variables in Java, we need to declare what type

30
00:02:21.930 --> 00:02:29.700
of data we are storing in those variables or what type of data those variables are referring to that

31
00:02:29.700 --> 00:02:40.200
is in opposition to dynamically typed languages where you don't need to specify what kind of data is

32
00:02:40.200 --> 00:02:40.910
going into them.

33
00:02:40.920 --> 00:02:46.230
So a language like JavaScript, for example, is a dynamically typed language.

34
00:02:46.440 --> 00:02:50.550
You don't have to specify what you're putting in it in variables rather.

35
00:02:51.000 --> 00:02:57.780
So some of the reasons why there are both dynamically typed languages and statically typed languages

36
00:02:57.900 --> 00:03:04.470
kind of comes down to, to a certain extent to personal preferences and what kinds of code you're planning

37
00:03:04.470 --> 00:03:07.440
to write or what what your needs are real quick.

38
00:03:07.590 --> 00:03:14.190
So dynamic languages are often beloved by some people for a few reasons.

39
00:03:14.190 --> 00:03:19.650
Some of those reasons could be that people feel like they can go a little faster with their coding because

40
00:03:19.650 --> 00:03:20.310
they don't have.

41
00:03:20.340 --> 00:03:26.250
They're not as encumbered with having to think about what the data types are and declaring them.

42
00:03:26.430 --> 00:03:32.910
In some cases, the languages can figure it out on their own to a to a high degree and do the right

43
00:03:32.910 --> 00:03:33.300
thing.

44
00:03:33.540 --> 00:03:38.730
You should also know, though, that different types of data like integers that we're going to look

45
00:03:38.730 --> 00:03:45.540
at in a moment here strings, integers and and other types of values and variable types cost something

46
00:03:45.540 --> 00:03:46.380
in memory.

47
00:03:46.530 --> 00:03:53.610
And so traditionally in programming, we wanted to be as conservative as we possibly could be with what

48
00:03:53.970 --> 00:03:59.640
kinds of data types we were using, because different data types take up more room, more or less room

49
00:03:59.640 --> 00:04:01.380
in the memory of the computer.

50
00:04:01.710 --> 00:04:07.710
And until relatively recently in computer history, computers were very constrained with how much memory

51
00:04:07.710 --> 00:04:08.880
they actually had.

52
00:04:08.940 --> 00:04:14.760
It's only been very recently that we're getting to the point that a lot of people barely even care anymore

53
00:04:14.760 --> 00:04:17.820
how much RAM is in their computers, but that was not always the case.

54
00:04:17.820 --> 00:04:20.770
And for programmers, it definitely was not always the case.

55
00:04:20.790 --> 00:04:26.730
And then there are also issues with programming itself, where sometimes dynamic languages like JavaScript

56
00:04:26.730 --> 00:04:33.810
can be a little harder to debug because the computer has a harder time knowing definitely what kind

57
00:04:33.810 --> 00:04:35.640
of data is stored in variables.

58
00:04:35.880 --> 00:04:38.830
Whereas with static languages, there's no guesswork there at all.

59
00:04:38.850 --> 00:04:40.920
You are very explicit about it.

60
00:04:41.250 --> 00:04:48.030
So just a few points on some of the differences between statically typed and dynamically typed languages.

61
00:04:48.150 --> 00:04:49.590
They have their pros and cons.

62
00:04:49.590 --> 00:04:54.000
So let's look at a few examples of what I mean by this, and we've already seen a few, but I didn't

63
00:04:54.000 --> 00:04:55.910
spend much time talking about them.

64
00:04:55.920 --> 00:04:56.550
So let's see.

65
00:04:56.550 --> 00:04:59.640
We had the we had in a previous program, we had a.

66
00:04:59.730 --> 00:05:07.680
Person class and we had like a field that stored the first name, and I said something like this, right?

67
00:05:08.190 --> 00:05:17.610
OK, so here I'm I'm declaring a variable called first name and the type of data that it can store is

68
00:05:17.610 --> 00:05:18.480
a string.

69
00:05:18.720 --> 00:05:21.450
And what a string is, is text.

70
00:05:21.660 --> 00:05:22.020
OK.

71
00:05:22.050 --> 00:05:23.460
A string is just text.

72
00:05:23.580 --> 00:05:29.280
We'll have a whole lesson where we go much deeper into strings, but for now, just know that a string

73
00:05:29.280 --> 00:05:30.760
is basically just text.

74
00:05:30.780 --> 00:05:31.260
OK?

75
00:05:31.290 --> 00:05:36.630
And so this variable firstname is capable of holding text.

76
00:05:36.630 --> 00:05:39.810
And in this line here, I'm not assigning any text.

77
00:05:39.810 --> 00:05:41.220
I could do that here.

78
00:05:41.220 --> 00:05:45.750
If I don't assign any text right now, I'm simply declaring this variable.

79
00:05:45.750 --> 00:05:53.160
I'm letting the Java system know that I need space to hold on to some text, and I'm going to call it

80
00:05:53.160 --> 00:05:53.910
first name.

81
00:05:54.330 --> 00:06:00.840
Now, I could assign or initialize this variable at the time of declaration.

82
00:06:00.840 --> 00:06:09.450
Like right now, I could say something like Jack, and now I am initializing this variable right now.

83
00:06:09.540 --> 00:06:11.700
Now, I could still change it later.

84
00:06:11.700 --> 00:06:17.100
But if no value is ever set in this in this variable later in the program or whatever, this would be

85
00:06:17.100 --> 00:06:18.570
its default value.

86
00:06:18.630 --> 00:06:19.080
OK.

87
00:06:20.550 --> 00:06:26.550
So I can initialize a variable at the time that I declare it a few more examples.

88
00:06:26.760 --> 00:06:28.920
I could store the age, for example.

89
00:06:29.280 --> 00:06:29.710
OK.

90
00:06:30.000 --> 00:06:38.730
So here I'm creating a variable called age that stores data of type int, and that's short for integer.

91
00:06:39.000 --> 00:06:45.870
So again, if you've ever taken algebra, you may recall that the concept of integers is very big in

92
00:06:45.870 --> 00:06:50.940
algebra, and integer is simply a negative or positive whole number.

93
00:06:51.090 --> 00:06:53.360
And in Java, it is the same.

94
00:06:53.370 --> 00:06:57.600
However, integers in Java cannot be infinitely large.

95
00:06:57.840 --> 00:07:04.040
There is a limit to the range, and we'll get into that in a lesson where we concentrate more on numbers

96
00:07:04.050 --> 00:07:05.220
and what we can do with them.

97
00:07:05.220 --> 00:07:07.080
But there are numbers.

98
00:07:07.170 --> 00:07:07.650
Let's see.

99
00:07:07.650 --> 00:07:11.400
There's and I'm not going to show every, every data type here either.

100
00:07:11.400 --> 00:07:13.140
I just want to give you a general sense.

101
00:07:13.440 --> 00:07:15.030
There's something called a long.

102
00:07:15.450 --> 00:07:18.090
So you might see something like this in code often.

103
00:07:18.180 --> 00:07:22.860
So a is also an integer, but it has a bigger range than integer.

104
00:07:22.890 --> 00:07:23.400
OK.

105
00:07:23.550 --> 00:07:31.590
And frequently, when you see Ides for a foreign object or something, oftentimes those will be modeled

106
00:07:31.740 --> 00:07:39.660
as a long so that we can make sure that however many objects of that type we're going to create, we

107
00:07:39.660 --> 00:07:41.310
have enough room for enough ideas.

108
00:07:41.550 --> 00:07:42.300
Let's see.

109
00:07:42.300 --> 00:07:48.480
We've got characters middle initial.

110
00:07:49.080 --> 00:07:49.520
Maybe.

111
00:07:50.130 --> 00:07:50.490
OK.

112
00:07:50.730 --> 00:07:53.340
Not saying I would actually model a person in this way.

113
00:07:53.340 --> 00:07:54.390
I probably wouldn't.

114
00:07:54.390 --> 00:07:56.550
But there's there's one small example.

115
00:07:56.550 --> 00:08:01.140
So a character is just one character of a string, right?

116
00:08:01.140 --> 00:08:01.530
So.

117
00:08:01.700 --> 00:08:07.710
So if I had a program that storing the first name and the middle initial may be, for some reason,

118
00:08:07.710 --> 00:08:13.200
I would only want to model the middle initial to literally only be capable of holding one character,

119
00:08:13.200 --> 00:08:13.410
right?

120
00:08:13.410 --> 00:08:15.930
Just the person's one middle initial.

121
00:08:16.110 --> 00:08:21.270
OK, so maybe I would use a care short for character for that.

122
00:08:21.480 --> 00:08:26.720
An example of initializing this, by the way, would would look like this, J.

123
00:08:27.720 --> 00:08:30.330
There are bytes.

124
00:08:31.920 --> 00:08:36.840
I don't even know what would make sense there, but there are bytes.

125
00:08:36.930 --> 00:08:39.360
There are a lot of data types, whole lot.

126
00:08:39.750 --> 00:08:43.800
Now let's get into some slightly more advanced data types.

127
00:08:43.810 --> 00:08:46.110
Well, so we did one here string.

128
00:08:46.500 --> 00:08:51.540
OK, but let's do a couple more so we could have a company.

129
00:08:54.230 --> 00:08:55.610
And I need to import that.

130
00:08:55.790 --> 00:08:59.450
And we could have a news agency.

131
00:09:01.500 --> 00:09:03.960
OK, so notice something here.

132
00:09:04.410 --> 00:09:09.990
Some of the data types are white and then some of the data types are orange.

133
00:09:11.070 --> 00:09:12.000
So why is that?

134
00:09:12.180 --> 00:09:18.020
Well, these data types in white are actual classes, OK?

135
00:09:18.060 --> 00:09:24.060
They are actual classes, which means that when an instance of these classes is created, what you're

136
00:09:24.060 --> 00:09:25.980
actually creating is an object.

137
00:09:26.250 --> 00:09:26.730
OK?

138
00:09:27.180 --> 00:09:31.830
Whereas these orange data types here are not classes.

139
00:09:32.100 --> 00:09:34.290
They are what are called primitives.

140
00:09:34.740 --> 00:09:38.960
They are lower level than an actual object.

141
00:09:38.970 --> 00:09:39.390
OK?

142
00:09:40.050 --> 00:09:41.550
So there's a few differences here.

143
00:09:41.580 --> 00:09:49.770
One is that since these are classes, these variables are meant to hold what are called a reference

144
00:09:49.770 --> 00:09:51.060
to objects.

145
00:09:51.300 --> 00:09:53.880
Classes give birth to objects.

146
00:09:54.030 --> 00:09:59.120
We saw some examples of that in the object oriented lesson where we were creating person.

147
00:09:59.150 --> 00:10:03.660
And in fact, here will jump over there real quick and just do a quick little refresher.

148
00:10:03.660 --> 00:10:10.770
So here in the Hello World program, with this new keyword here we created an object or an instance

149
00:10:10.770 --> 00:10:14.400
of a person that results in the creation of an object.

150
00:10:14.400 --> 00:10:22.170
And then we took that that person object and assigned a reference to it to this variable, Tom.

151
00:10:22.290 --> 00:10:28.050
OK, now I'll explain in just a moment what I mean by we assigned a reference to it, but that's what

152
00:10:28.050 --> 00:10:28.560
we did.

153
00:10:28.590 --> 00:10:28.950
OK.

154
00:10:29.190 --> 00:10:32.820
So if we jump back over here to the business project again?

155
00:10:33.900 --> 00:10:44.430
So, yeah, when we create variables that are four classes, those variables will hold a reference to

156
00:10:44.430 --> 00:10:49.440
an object when we create variables for primitives.

157
00:10:49.470 --> 00:10:50.730
There is no object.

158
00:10:50.910 --> 00:10:51.390
OK.

159
00:10:51.780 --> 00:10:54.030
So here this is a class.

160
00:10:54.600 --> 00:10:59.580
And here we are creating an instance of that class a string.

161
00:11:00.000 --> 00:11:00.510
OK.

162
00:11:00.810 --> 00:11:09.480
I was saying a moment ago that when we create an instance of a class and and store it in a variable,

163
00:11:09.480 --> 00:11:11.790
what we're actually storing as a reference.

164
00:11:12.300 --> 00:11:15.060
Let me show you what that looks like for a minute here.

165
00:11:16.800 --> 00:11:24.900
OK, so here, because I'm using this new keyword, I am creating an instance of my company.

166
00:11:25.080 --> 00:11:28.350
So it's kind of like just to remind you from previous lesson.

167
00:11:28.680 --> 00:11:31.080
Company is like a blueprint.

168
00:11:31.560 --> 00:11:32.040
OK.

169
00:11:32.610 --> 00:11:40.020
And when I say new company with parentheses, I'm telling Java, Take the blueprint for a company and

170
00:11:40.020 --> 00:11:42.330
go build me an actual company.

171
00:11:42.360 --> 00:11:44.400
Now go build one of these things.

172
00:11:44.670 --> 00:11:53.590
And so Java asks the computer system on which it is running to give it a location where it can build.

173
00:11:53.610 --> 00:11:55.350
In this case, the company.

174
00:11:55.620 --> 00:11:56.070
OK.

175
00:11:56.370 --> 00:12:05.030
And then once that company is built, Java will return not to me, but to the rest of the program.

176
00:12:05.040 --> 00:12:11.580
It will return the address of that object that it just created.

177
00:12:12.300 --> 00:12:17.610
And it is actually the address itself that gets stored in this variable.

178
00:12:17.700 --> 00:12:20.160
So it's not the actual company.

179
00:12:20.460 --> 00:12:23.850
It's actually a reference to the company.

180
00:12:24.000 --> 00:12:27.390
And the reference that we use is the address.

181
00:12:27.720 --> 00:12:33.570
It's almost like if you asked a builder to build a house for you.

182
00:12:34.230 --> 00:12:43.170
And after they finished building the house, they dropped off a key and on the key was printed the address

183
00:12:43.170 --> 00:12:45.060
of the new house that they built for you.

184
00:12:45.060 --> 00:12:45.970
And they give you that.

185
00:12:46.050 --> 00:12:46.530
OK.

186
00:12:46.650 --> 00:12:53.880
So that key refers back to the house or the building that they just built for you?

187
00:12:53.910 --> 00:12:54.390
OK.

188
00:12:54.690 --> 00:12:56.610
So that's kind of what's happening here.

189
00:12:56.790 --> 00:13:03.840
The Java system is building this object from the blueprint called company.

190
00:13:04.290 --> 00:13:14.610
And then when it's done building it, it returns an address of where this object lives in memory in

191
00:13:14.610 --> 00:13:15.540
your computer.

192
00:13:15.960 --> 00:13:18.750
And that address is actually what is stored here.

193
00:13:19.230 --> 00:13:19.740
OK.

194
00:13:20.160 --> 00:13:28.740
And if you recall when we ran the Hello World program before and we tried to print out a variable that

195
00:13:28.740 --> 00:13:34.140
was referring to a person object before we implemented the two string method, it actually printed out

196
00:13:34.140 --> 00:13:34.560
an address.

197
00:13:34.560 --> 00:13:37.110
And in fact, you know, it will do that real quick.

198
00:13:37.290 --> 00:13:38.130
I will.

199
00:13:39.060 --> 00:13:45.930
I'll create a quick little method here just to allow us to print out company.

200
00:13:47.160 --> 00:13:52.350
And in order to make this work, I will have to make it static and you'll learn why I had to do that

201
00:13:52.350 --> 00:13:53.580
in a later lesson.

202
00:13:53.670 --> 00:13:54.810
But I have to make that static.

203
00:13:54.990 --> 00:13:55.350
OK.

204
00:13:55.710 --> 00:14:00.330
So this is going to print out whatever it knows about the company and let.

205
00:14:00.390 --> 00:14:06.810
See what it actually prints, OK, and what it printed was business start company at.

206
00:14:07.080 --> 00:14:16.200
And then like this hexadecimal number here, this hexadecimal number here is the actual location in

207
00:14:16.200 --> 00:14:16.550
memory.

208
00:14:16.560 --> 00:14:18.070
It's a memory address.

209
00:14:18.090 --> 00:14:23.400
It is saying I have an object that is a business that company.

210
00:14:23.400 --> 00:14:28.110
This is the fully qualified name of the company class that we are using here.

211
00:14:28.290 --> 00:14:36.990
So it's saying I have an object that is a business company at this particular address in memory.

212
00:14:37.410 --> 00:14:44.280
That is the default behavior that you will get whenever you create an object and you try to print it.

213
00:14:44.550 --> 00:14:45.000
OK?

214
00:14:45.180 --> 00:14:55.410
And this proves that when we create a new object, we are actually getting a reference to that object

215
00:14:55.530 --> 00:14:58.800
by way of its address in memory.

216
00:14:59.220 --> 00:15:10.500
If we were to create one more, I can just duplicate this and then I'll call this company one and I'll

217
00:15:10.500 --> 00:15:13.920
duplicate this and refer to company one.

218
00:15:14.490 --> 00:15:16.110
And then we run this again.

219
00:15:19.650 --> 00:15:22.320
OK, now we get this printed out twice.

220
00:15:22.710 --> 00:15:30.780
And each instance of the company has a different address, which makes sense because we asked Java to

221
00:15:30.780 --> 00:15:36.930
build two different companies so they can't both reside at the same address.

222
00:15:36.960 --> 00:15:37.290
Right?

223
00:15:37.800 --> 00:15:40.680
OK, so let's talk a little bit about variable naming.

224
00:15:41.160 --> 00:15:46.800
Generally speaking, variable names follow pretty much the same rules as class names.

225
00:15:47.520 --> 00:15:53.610
Let me talk more about conventions, though the convention for most variable names, there are a there's

226
00:15:53.610 --> 00:16:00.150
at least one exception here is that variable names begin with a lowercase letter, and that's just the

227
00:16:00.150 --> 00:16:00.900
convention.

228
00:16:01.050 --> 00:16:06.750
One of the reasons for that is in part to distinguish variable names from class names.

229
00:16:06.750 --> 00:16:10.920
Class names by convention start with an uppercase variable.

230
00:16:10.920 --> 00:16:13.680
Names by convention start with a lowercase one.

231
00:16:13.680 --> 00:16:17.340
Exception to that, though, is what is called a constant.

232
00:16:17.530 --> 00:16:20.010
So I'll show you an example of a constant.

233
00:16:20.460 --> 00:16:22.680
Let's see if we did.

234
00:16:29.890 --> 00:16:39.280
OK, so if we wanted to define a variable called PI and and whether well, yeah, and we assign it a

235
00:16:39.280 --> 00:16:45.430
value at the time that we're creating it and I'm making it final, and that just means that I don't

236
00:16:45.430 --> 00:16:49.000
ever want anyone to be able to change this later in the program.

237
00:16:49.180 --> 00:16:54.970
So later on in the program, any time I want to refer to the value three point one four rather than

238
00:16:54.970 --> 00:16:58.300
having to type out three point one four, I can just type PI.

239
00:16:58.630 --> 00:17:05.020
And what's nice about this is it gives a name to this value so that it's potentially a little more meaningful

240
00:17:05.020 --> 00:17:07.150
to the readers of this code.

241
00:17:07.180 --> 00:17:07.600
OK.

242
00:17:07.750 --> 00:17:09.760
And I don't have to do this just with numbers.

243
00:17:09.760 --> 00:17:17.500
I can do this with with anything strings, whatever, any time I have a value that I might want to refer

244
00:17:17.500 --> 00:17:24.610
to throughout my code and I want to give it a meaningful name, I could assign it to a constant.

245
00:17:24.730 --> 00:17:30.910
So when I'm creating constants, constants by convention are all caps the whole entire thing.

246
00:17:31.030 --> 00:17:36.010
And if you have a multi word constant, I'll create one of those.

247
00:17:38.840 --> 00:17:42.590
My big constant.

248
00:17:51.710 --> 00:17:52.130
OK.

249
00:17:53.450 --> 00:17:59.640
So by convention, Constance, are all caps, and because they are all caps, we can't do camel case.

250
00:17:59.840 --> 00:18:05.720
And so in that case, we use underscores to separate the words of the constant right.

251
00:18:05.960 --> 00:18:09.680
So again, just a reminder of what camel case would look like.

252
00:18:09.770 --> 00:18:16.150
Camel case would be like my big constant.

253
00:18:16.730 --> 00:18:17.780
It would look like that.

254
00:18:18.920 --> 00:18:19.310
OK.

255
00:18:19.490 --> 00:18:25.250
But since constants are meant to be all uppercase, we use underscores instead.

256
00:18:26.780 --> 00:18:27.200
OK.

257
00:18:28.310 --> 00:18:34.210
So by no means is this an exhaustive review of variables and data types.

258
00:18:34.220 --> 00:18:42.230
I just wanted to give a brief, slightly more formal introduction to variables and data types before

259
00:18:42.230 --> 00:18:43.870
we jumped in to methods.

260
00:18:43.880 --> 00:18:46.520
And then this will start to kind of pull everything together.

261
00:18:46.760 --> 00:18:50.360
So that's about it for this lesson, and I'll see you in the next one.
