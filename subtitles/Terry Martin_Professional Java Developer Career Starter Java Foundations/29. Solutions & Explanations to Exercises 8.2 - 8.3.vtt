WEBVTT
1
00:00:00.420 --> 00:00:00.850
All right.

2
00:00:00.870 --> 00:00:04.260
So picking up from where I left off in the last lesson.

3
00:00:04.560 --> 00:00:08.060
We're going to take a look at the next sub exercise.

4
00:00:08.130 --> 00:00:14.550
So we were doing 8.1 and now we're on 8.2, which is going to be pretty much the same thing.

5
00:00:14.910 --> 00:00:16.500
Do the same as 8.1.

6
00:00:16.500 --> 00:00:24.240
But for the night to get the can add night test method working the method you wrote an eight point one

7
00:00:24.240 --> 00:00:28.100
to add a pun should also be able to accept a night.

8
00:00:28.110 --> 00:00:31.520
So we want to be able to reuse that same add method.

9
00:00:31.530 --> 00:00:33.060
That's kind of the key there.

10
00:00:33.480 --> 00:00:38.100
Please be mindful that you'll need to utilize object oriented techniques you learned in this section

11
00:00:38.100 --> 00:00:40.200
to get this all working properly.

12
00:00:40.440 --> 00:00:42.150
So let's go take a look at the code.

13
00:00:42.450 --> 00:00:47.490
All right, so here's our first add method for the pun, and we did this board that add here.

14
00:00:47.790 --> 00:00:53.730
And so down here now I'm doing the exact same things, except instead of creating a pun, I'm creating

15
00:00:53.730 --> 00:00:54.870
a night, right?

16
00:00:55.230 --> 00:00:57.240
And I'm setting a color on that.

17
00:00:57.240 --> 00:01:02.670
And that's just I was just doing something different here just to force myself to have something different.

18
00:01:02.910 --> 00:01:06.910
I don't know that I'm going to get too deep into why I'm doing this here yet.

19
00:01:06.930 --> 00:01:08.790
Let's just go a little further and see.

20
00:01:09.090 --> 00:01:11.220
But here's the main thing board dot add.

21
00:01:11.220 --> 00:01:14.440
And now I'm adding a night instead of a pawn.

22
00:01:14.500 --> 00:01:15.030
OK.

23
00:01:15.390 --> 00:01:21.960
And so as I already mentioned in the last lesson, if we want this, if we want to be able to use the

24
00:01:21.960 --> 00:01:29.550
same add method, which is what the exercise is calling for, but we need that method to be able to

25
00:01:29.550 --> 00:01:32.070
accept two different types.

26
00:01:32.370 --> 00:01:39.630
Then, according to the rules of object orientation, those two different types need to have something

27
00:01:39.630 --> 00:01:42.450
in common, need to have a type in common.

28
00:01:42.750 --> 00:01:46.440
And there are two ways that we could conceivably do that.

29
00:01:46.710 --> 00:01:55.020
Either those two classes, Pon and Night, need to implement the same interface, or they need to extend

30
00:01:55.020 --> 00:01:59.220
either directly or indirectly from the same superclass.

31
00:01:59.670 --> 00:02:06.480
OK, so now let's go dig in to this night class and see how I decided to solve that issue.

32
00:02:07.750 --> 00:02:15.760
OK, so here we are in the night class, and you can see that I made it extend a class called chess

33
00:02:15.760 --> 00:02:16.240
piece.

34
00:02:16.810 --> 00:02:25.100
And if we jump over to the -- class, you will see that -- also extends chess piece.

35
00:02:25.120 --> 00:02:25.630
OK.

36
00:02:25.840 --> 00:02:31.360
And then if we go over to the chess board class where we've got the add method, you will see that the

37
00:02:31.360 --> 00:02:36.220
add method doesn't accept a knight or a pawn.

38
00:02:36.400 --> 00:02:40.250
It actually just accepts a chess piece in general.

39
00:02:40.270 --> 00:02:40.780
OK.

40
00:02:41.410 --> 00:02:49.750
And so that is how we are able to make one add method that can accept different kinds of chess pieces.

41
00:02:49.930 --> 00:02:56.890
As long as those chess pieces have common properties that we are able to refer to from within whatever

42
00:02:56.900 --> 00:03:01.360
our add method or wherever we're using these generic chess pieces, OK?

43
00:03:01.540 --> 00:03:08.680
And in fact, if I'm not mistaken, I don't think we will see any references specifically to a pawn

44
00:03:08.860 --> 00:03:12.880
or to a knight in this chess board class.

45
00:03:13.420 --> 00:03:19.180
If we need to refer to a chess piece in general, we will just use the term chess piece here.

46
00:03:20.150 --> 00:03:20.530
OK.

47
00:03:20.570 --> 00:03:27.410
So I think that's a true statement, I shouldn't have any references specifically to any particular

48
00:03:27.410 --> 00:03:28.520
type of chess piece.

49
00:03:28.550 --> 00:03:28.910
OK.

50
00:03:29.660 --> 00:03:30.080
All right.

51
00:03:30.260 --> 00:03:32.630
So let's go back over to the test.

52
00:03:34.720 --> 00:03:37.990
And other than that, everything else is the same.

53
00:03:38.290 --> 00:03:45.580
And so now again, you understand why I am casting when I get the chess piece that is that location,

54
00:03:45.580 --> 00:03:52.600
see one in this case, when I get that chess piece back from that location, you see now why I am casting

55
00:03:52.600 --> 00:03:57.280
it to something of tape night, though I did mention in the last lesson.

56
00:03:57.370 --> 00:04:00.070
I don't need to do this for anything to work.

57
00:04:00.070 --> 00:04:04.700
In fact, I will take that out just to show you that it's completely unnecessary.

58
00:04:04.720 --> 00:04:05.860
I could just.

59
00:04:06.920 --> 00:04:10.010
Do this, and that will still work just as well.

60
00:04:11.500 --> 00:04:17.950
OK, so there's that, I guess I will put that back, though, for now just because.

61
00:04:18.520 --> 00:04:18.820
All right.

62
00:04:18.820 --> 00:04:24.130
So I don't think any further explanation is needed for this test.

63
00:04:24.370 --> 00:04:31.230
So, so now jumping back into the exercise is let's look at exercise number three, switching to the

64
00:04:31.240 --> 00:04:41.080
J Unit test in the Pond Test Java File Enable the pond can move one forward test to pass by implementing

65
00:04:41.080 --> 00:04:42.370
the necessary code.

66
00:04:42.760 --> 00:04:47.800
This is where you'll really begin to try implementing some business or game logic.

67
00:04:47.830 --> 00:04:49.560
OK, so I'm not going to read this whole thing.

68
00:04:49.600 --> 00:04:51.580
You've probably already read it, hopefully.

69
00:04:52.060 --> 00:04:55.330
But let's jump over into that test class pond test.

70
00:04:55.510 --> 00:04:55.900
All right.

71
00:04:56.170 --> 00:04:58.210
So that is right here.

72
00:04:58.210 --> 00:04:59.190
Pond test.

73
00:04:59.200 --> 00:05:01.390
OK, so we've got this test method here.

74
00:05:01.390 --> 00:05:03.220
Pond can move one forward.

75
00:05:03.490 --> 00:05:05.110
So what am I saying here?

76
00:05:05.500 --> 00:05:12.670
Well, what I'm saying is if we have a pond such as this black pond here and remember for the black

77
00:05:12.670 --> 00:05:18.580
pieces, they're going down this board white pieces, which would be down in these two rows down here,

78
00:05:18.760 --> 00:05:20.570
they'd be going up the board.

79
00:05:20.590 --> 00:05:20.950
OK.

80
00:05:21.280 --> 00:05:29.320
So for this pond right here, that test is just saying that one of the legally allowed or valid moves

81
00:05:29.320 --> 00:05:33.640
of this pond would be to go forward by one square.

82
00:05:33.790 --> 00:05:38.230
Now that's not saying that that's the only legal move that this pond can make.

83
00:05:38.440 --> 00:05:42.190
That's just saying that is one of the legal moves that this pond could make.

84
00:05:42.430 --> 00:05:50.080
So this test wants to test whether or not that is in fact one of the legal moves that that pond could

85
00:05:50.080 --> 00:05:50.290
make.

86
00:05:50.380 --> 00:05:54.070
Now, in our particular case, let me be a little more accurate here.

87
00:05:55.000 --> 00:05:55.510
Let's see.

88
00:05:55.510 --> 00:05:58.900
I don't know if I specified exactly what Oh yeah, I did, OK.

89
00:05:59.680 --> 00:06:07.420
So we're saying that there's a pond on square a two and we want to confirm or verify or assert actually

90
00:06:07.690 --> 00:06:13.240
that that pond on a two is allowed to move to square a three.

91
00:06:13.270 --> 00:06:15.910
And let me just show that right here.

92
00:06:15.920 --> 00:06:21.400
So if we're on a two and we've got a pond here, then we're saying one of the valid squares that that

93
00:06:21.400 --> 00:06:25.090
pond could move to in general is a three.

94
00:06:25.270 --> 00:06:25.750
OK.

95
00:06:25.840 --> 00:06:31.780
Likewise, if the pond were on B to one of its legal moves could be two square B three.

96
00:06:32.320 --> 00:06:32.620
All right.

97
00:06:32.630 --> 00:06:36.820
And I think I even said that here B to B three e five to Essex, et cetera.

98
00:06:36.850 --> 00:06:37.290
All right.

99
00:06:37.300 --> 00:06:39.460
So how do we code this?

100
00:06:39.640 --> 00:06:44.050
Now this is going to be a little bit more involved for the way that I went about doing it.

101
00:06:44.050 --> 00:06:49.480
And I'm going to acknowledge that I probably hit a number of steps that you may or may not have hit

102
00:06:49.630 --> 00:06:50.800
in order to do this.

103
00:06:51.100 --> 00:06:58.200
So here I am, creating a pond and I'm going to going ahead and just stating that that's a white pond,

104
00:06:58.210 --> 00:07:02.620
because my example here states that the pond is on square a two.

105
00:07:02.800 --> 00:07:09.520
And so with this depiction of a chessboard where the black pieces are going down the board, then that

106
00:07:09.520 --> 00:07:13.660
would mean that the that white pieces have to be down here going up the board.

107
00:07:13.660 --> 00:07:17.290
OK, so that's why I just decided to make the pond white.

108
00:07:17.410 --> 00:07:21.520
You certainly could have a chess board depiction where the white pieces are at the top, so that doesn't

109
00:07:21.520 --> 00:07:23.860
actually matter for for chess necessarily.

110
00:07:24.010 --> 00:07:30.070
That's just the way I chose to do it because I was referring to this particular image while I was working

111
00:07:30.070 --> 00:07:33.610
on the code and I wanted it everything to kind of make sense.

112
00:07:34.840 --> 00:07:35.080
All right.

113
00:07:35.080 --> 00:07:40.660
So we've got a pun here on a two and and so we want to confirm or assert that one of its legal moves

114
00:07:40.660 --> 00:07:41.870
would be to a three.

115
00:07:41.890 --> 00:07:48.310
So I'm creating upon it's white, then I'm explicitly setting its coordinates now here because this

116
00:07:48.310 --> 00:07:51.640
is a test class for just testing the pond.

117
00:07:52.030 --> 00:07:59.110
And so my tests here are more from the perspective of a pond, rather than from the perspective of a

118
00:07:59.110 --> 00:08:00.040
chess board.

119
00:08:00.250 --> 00:08:07.750
So those last tests that we were looking at over here in chess board test, these tests are testing

120
00:08:07.750 --> 00:08:10.360
functionality of the chess board itself, right?

121
00:08:10.390 --> 00:08:17.530
We were testing the add method and we were also really testing the get piece at co-ords method as well.

122
00:08:17.560 --> 00:08:21.820
These are two sides of the same coin, if you will, these two methods, OK.

123
00:08:21.970 --> 00:08:25.360
But now we're testing functionality of the pawn.

124
00:08:25.600 --> 00:08:31.570
And so I need a way to set some coordinates on the pawn without having a chess board.

125
00:08:31.720 --> 00:08:32.170
OK.

126
00:08:32.500 --> 00:08:38.260
And so I created this method set coordinates, and I'm sending it to A-2 now here.

127
00:08:38.260 --> 00:08:43.090
I was a little less consistent, and I'm going to talk a little bit more about this in just a second.

128
00:08:43.240 --> 00:08:45.460
So here I decided to re-use.

129
00:08:45.460 --> 00:08:51.580
This coordinates class that I created already when I was working on the chess board.

130
00:08:51.790 --> 00:08:54.550
And so I decided to just allow myself to pass in.

131
00:08:54.550 --> 00:08:55.990
This coordinates thing.

132
00:08:56.290 --> 00:09:03.490
Now, one thing I could do here is I could consider overloading this method set coordinates to allow

133
00:09:03.490 --> 00:09:09.850
myself to not have to explicitly create this new coordinates object every time I call this method so

134
00:09:10.090 --> 00:09:10.360
that.

135
00:09:10.600 --> 00:09:14.770
If I were to do it, it would look like pond at set coordinates.

136
00:09:14.980 --> 00:09:19.810
And then I could just pass in the A2, which is the way that I was using some of the methods on the

137
00:09:20.080 --> 00:09:22.240
chessboard class itself.

138
00:09:22.450 --> 00:09:27.460
I could do this and I could have both of these methods, or I could get rid of this one and just have

139
00:09:27.460 --> 00:09:28.180
this version.

140
00:09:28.180 --> 00:09:32.950
And then internal to this method, I would just be doing this right.

141
00:09:32.950 --> 00:09:38.860
So I wouldn't I would just be kind of pushing this down and kind of hiding the fact that we have this

142
00:09:39.130 --> 00:09:41.590
coordinates object that's being created.

143
00:09:41.740 --> 00:09:45.010
I could hide that down and, you know, stuff that down into this method.

144
00:09:45.160 --> 00:09:47.560
There are things like that that you could consider doing.

145
00:09:47.740 --> 00:09:50.980
I'm not going to bother with that now, but those are things that you could consider.

146
00:09:51.010 --> 00:09:54.010
So let's step back and consider now, what are we really doing here?

147
00:09:54.460 --> 00:10:01.240
So what we're really wanting to do is we're wanting to ask the pawn a pawn, considering that you are

148
00:10:01.240 --> 00:10:04.090
currently on square a two.

149
00:10:04.510 --> 00:10:11.020
Can you tell me where are all of the valid squares that you would be allowed to move to?

150
00:10:11.050 --> 00:10:16.870
Just in general, OK, let's assume that no other squares are occupied or, you know, they're all wide

151
00:10:16.870 --> 00:10:18.250
open and everything else.

152
00:10:18.490 --> 00:10:23.500
What are all of the valid places where you would be allowed to move right now?

153
00:10:23.800 --> 00:10:28.720
That's what we're kind of going to ask the pawn and then we're going to assert, OK.

154
00:10:28.750 --> 00:10:35.180
Of all of the squares that you would be allowed to move is square a three.

155
00:10:35.200 --> 00:10:36.070
One of them.

156
00:10:36.670 --> 00:10:38.320
That's what we're doing in this test.

157
00:10:38.320 --> 00:10:39.850
OK, so we're asking upon.

158
00:10:40.060 --> 00:10:46.500
Give me all your valid squares and then we're going to check and see is one of those squares square

159
00:10:46.510 --> 00:10:47.230
a three.

160
00:10:47.500 --> 00:10:47.890
OK.

161
00:10:48.190 --> 00:10:54.400
And so the way we ask the pawn, gimme all your valid moves is right here on line 16, we call this

162
00:10:54.400 --> 00:10:56.260
method pawn that get valid moves.

163
00:10:56.260 --> 00:10:58.980
Now, obviously, I created this method OK.

164
00:10:59.250 --> 00:11:03.580
And I was forced to create this method in order to get this test working.

165
00:11:03.790 --> 00:11:11.260
Now, you may have thought of a completely different way to go about doing this, but this is the approach

166
00:11:11.260 --> 00:11:20.020
that I came up with was to actually create a method called get valid moves that returns back an array

167
00:11:20.320 --> 00:11:22.200
of coordinates.

168
00:11:22.210 --> 00:11:23.210
In my case, OK?

169
00:11:23.230 --> 00:11:24.520
And these are all the valid moves.

170
00:11:24.700 --> 00:11:26.440
Now you might have made a method.

171
00:11:26.440 --> 00:11:31.990
You may have come up with the idea, perhaps of making a method that maybe is something like pond.

172
00:11:32.500 --> 00:11:32.920
I don't know.

173
00:11:32.920 --> 00:11:36.940
Get next, move or get permissible move or something like that.

174
00:11:37.030 --> 00:11:44.800
And maybe your method just returns a string, you know, and maybe that string would just say a three,

175
00:11:45.160 --> 00:11:51.820
which really would be kind of similar to what I'm doing here, but maybe a little less object oriented

176
00:11:51.820 --> 00:11:52.410
in some ways.

177
00:11:52.420 --> 00:11:56.250
OK, so that might be OK, that might be OK.

178
00:11:56.260 --> 00:12:02.650
But the way that I decided to do it was to have a method that returns back a whole entire array of all

179
00:12:02.650 --> 00:12:03.610
of the valid moves.

180
00:12:03.610 --> 00:12:05.710
And you'll see why I did that shortly.

181
00:12:05.740 --> 00:12:11.110
OK, so let's see how that method is working because this gets a little more involved.

182
00:12:11.290 --> 00:12:12.610
Get valid moves.

183
00:12:12.850 --> 00:12:14.290
Let me make a little room here.

184
00:12:14.860 --> 00:12:18.700
OK, so the get valid moves method is pretty involved.

185
00:12:18.700 --> 00:12:24.250
Now you're going to see it looking even more complex than it needs to for that one test because you're

186
00:12:24.250 --> 00:12:30.800
seeing my code as it now exists in order to satisfy all of the exercises.

187
00:12:30.820 --> 00:12:37.540
OK, so you're not unfortunately, you're not getting a chance to see me build this up one unit test

188
00:12:37.540 --> 00:12:38.270
at a time.

189
00:12:38.290 --> 00:12:38.570
OK.

190
00:12:38.590 --> 00:12:43.810
You're seeing all of the code that I needed to write eventually in order to get all of the unit tests

191
00:12:43.810 --> 00:12:45.490
for all of the exercises working.

192
00:12:45.760 --> 00:12:51.190
But it will try to ignore to some extent the parts of the code that are not pertinent to what we're

193
00:12:51.190 --> 00:12:52.540
looking at, if we can.

194
00:12:52.630 --> 00:12:59.620
So my approach for getting the valid moves is a little bit involved, but this is where we really get

195
00:12:59.620 --> 00:13:08.320
into how we can use object orientation to rate sophisticated code that doesn't have to be too scary

196
00:13:08.320 --> 00:13:09.340
looking, hopefully.

197
00:13:09.520 --> 00:13:17.260
OK, so first, let's jump over to the chess board, and I want to try to explain the general philosophy

198
00:13:17.260 --> 00:13:26.320
and the approach that I decided to take in calculating all of the valid moves of any particular piece.

199
00:13:26.350 --> 00:13:26.770
OK.

200
00:13:27.190 --> 00:13:35.170
So if we've got a pun on Square A2, I know that one of the valid moves for for that pawn would be one

201
00:13:35.170 --> 00:13:37.240
square forward in general.

202
00:13:37.390 --> 00:13:42.550
I keep saying in general, because I'm saying like, let's ignore for right now whether or not that

203
00:13:42.550 --> 00:13:46.270
square might already have been occupied by some other chess piece.

204
00:13:46.280 --> 00:13:51.640
OK, so let's just assume that we don't care about that for right now, which actually we don't.

205
00:13:51.820 --> 00:13:52.210
OK.

206
00:13:53.110 --> 00:14:00.280
So if the one rule that we need for right now is wherever there is a pawn, one of that pawn valid moves

207
00:14:00.280 --> 00:14:05.290
is always to move one square forward from wherever it currently is.

208
00:14:05.320 --> 00:14:05.740
OK.

209
00:14:06.520 --> 00:14:10.390
So one way of thinking about that is to consider.

210
00:14:10.460 --> 00:14:15.860
Or if I met at an X-Y location like, well, let's say, a two.

211
00:14:15.980 --> 00:14:23.760
Then if I want to calculate one of my valid moves for a pawn, then I can take that coordinated way

212
00:14:23.810 --> 00:14:24.340
too.

213
00:14:24.710 --> 00:14:29.900
And I can add +1 to the rank.

214
00:14:30.200 --> 00:14:34.280
OK, so the rank is two so I can take the existing.

215
00:14:35.300 --> 00:14:41.230
The existing rank of two and just add one to it, and that is one of the valid moves for upon.

216
00:14:41.600 --> 00:14:48.530
OK, so I can think of it in terms of the delta or the difference between where you currently are and

217
00:14:48.530 --> 00:14:49.430
where you want to be.

218
00:14:49.550 --> 00:14:51.440
So just add one essentially.

219
00:14:51.440 --> 00:14:59.180
OK, so armed with that knowledge, what I decided to do was to come up with a way that I could take

220
00:14:59.180 --> 00:15:00.740
an existing coordinate.

221
00:15:00.740 --> 00:15:03.950
And remember, now I created a class for coordinates, right?

222
00:15:04.100 --> 00:15:10.490
This coordinate class, I came up with a way that I could take an existing coordinate and supply it

223
00:15:10.490 --> 00:15:11.960
with an offset.

224
00:15:12.380 --> 00:15:20.620
So an offset in this case would be X and Y integers that can be added to the existing coordinate.

225
00:15:20.630 --> 00:15:20.970
OK?

226
00:15:21.170 --> 00:15:27.440
So if I have a given coordinate like I have right here, then I created a method called Get Offset,

227
00:15:27.590 --> 00:15:36.770
where I could pass in an additional amount of X and an additional amount of Y to add to that existing

228
00:15:36.770 --> 00:15:37.370
coordinate.

229
00:15:37.400 --> 00:15:37.810
OK.

230
00:15:38.540 --> 00:15:44.690
So if I have a coordinate of a two and I set the X.

231
00:15:45.740 --> 00:15:46.880
Two zero.

232
00:15:48.090 --> 00:15:50.110
X would be going in this direction.

233
00:15:50.130 --> 00:15:50.610
OK.

234
00:15:50.790 --> 00:15:59.760
Left and right, if I said the X offset to zero and I set the Y offset to one, then that would simply

235
00:15:59.760 --> 00:16:09.990
add zero to the file, which would mean I'd stay on the a file here and it would add one to the rank,

236
00:16:09.990 --> 00:16:12.720
which means I would go from two to three.

237
00:16:12.990 --> 00:16:13.470
OK.

238
00:16:13.770 --> 00:16:20.940
And in this way, because I'm giving relative deltas, I don't need to even care where I actually am

239
00:16:20.940 --> 00:16:21.850
starting from.

240
00:16:21.930 --> 00:16:24.450
OK, my code doesn't need to care where it's starting from.

241
00:16:24.570 --> 00:16:27.240
It's doing it relative to where it already is.

242
00:16:28.730 --> 00:16:34.070
So here you see that I'm supplying a zero for an ex offset.

243
00:16:34.610 --> 00:16:37.070
And then I'm doing this complicated looking stuff here.

244
00:16:37.070 --> 00:16:41.700
But the main thing for you to note is that I'm setting a negative one for the why offset?

245
00:16:41.720 --> 00:16:43.470
Now that's probably not what you were expecting.

246
00:16:43.490 --> 00:16:45.200
Why is it a negative one?

247
00:16:46.040 --> 00:16:55.760
Well, the reason for the negative one is because my X and Y offsets are not using chess notation.

248
00:16:56.030 --> 00:17:01.400
They are actually using the array, the array, the two dimensional array.

249
00:17:01.970 --> 00:17:07.760
And so coming back over here again, if we look at this chessboard in terms of it being a two dimensional

250
00:17:07.760 --> 00:17:15.710
array, the way to look at that would be that this row here is not row eight, it's actually row zero.

251
00:17:16.010 --> 00:17:24.320
And this would be one two three four five six and seven right zero through seven.

252
00:17:25.370 --> 00:17:29.600
And so right here in array notation, if you will.

253
00:17:30.080 --> 00:17:36.200
We are actually on square zero six zero comma six.

254
00:17:36.290 --> 00:17:36.830
OK.

255
00:17:36.890 --> 00:17:43.850
And now we want to go from zero comma six to this square here, which would in our array notation would

256
00:17:43.850 --> 00:17:46.220
be zero comma five.

257
00:17:46.470 --> 00:17:46.730
Right.

258
00:17:46.730 --> 00:17:49.760
So we'd be going from six to five.

259
00:17:49.970 --> 00:17:57.200
OK, now that's just the way that I decided to encode the chessboard using a two dimensional array.

260
00:17:57.620 --> 00:18:03.860
If you had decided to use a two two dimensional array, you may have decided that this square right

261
00:18:03.860 --> 00:18:05.420
here is zero zero.

262
00:18:05.810 --> 00:18:08.990
And your numbers are going up like this.

263
00:18:09.000 --> 00:18:10.550
You might have decided to do that.

264
00:18:11.060 --> 00:18:18.440
I decided to make this square zero zero because that matches up with more of how I think of arrays.

265
00:18:18.440 --> 00:18:24.020
I think of arrays typically as starting in the top left, especially the two dimensional array.

266
00:18:24.260 --> 00:18:32.720
And I wanted everything to align with what I was visually seeing here on this board, minus the minus

267
00:18:32.720 --> 00:18:35.180
the chess coordinates, that is OK.

268
00:18:35.480 --> 00:18:38.510
And so that's just how I decided to map this.

269
00:18:38.990 --> 00:18:44.720
I don't know if this is true or not, but I was a little concerned that if I mapped it with the square

270
00:18:44.720 --> 00:18:49.790
down here being zero zero, that I might get a little confused by other things.

271
00:18:49.790 --> 00:18:50.600
But you know what?

272
00:18:51.020 --> 00:18:54.780
You may have to flip things around one way or the other anyway, right?

273
00:18:54.800 --> 00:18:58.110
Some people, for some strange reason, might have decided to make this square.

274
00:18:58.130 --> 00:18:58.850
Zero zero.

275
00:18:59.030 --> 00:19:00.680
You could do it any way you want.

276
00:19:00.890 --> 00:19:05.240
You're just going to have to know that you'll have to translate something somewhere.

277
00:19:05.510 --> 00:19:10.880
I'm having to translate now the zero to an eight right on the chess notation.

278
00:19:10.890 --> 00:19:11.720
This is an eight.

279
00:19:11.930 --> 00:19:14.210
But in the array notation, this is a zero.

280
00:19:14.300 --> 00:19:14.750
OK.

281
00:19:14.870 --> 00:19:20.600
But anyway, the main thing to note here is that for the array notation, which is what I'm using for

282
00:19:20.600 --> 00:19:24.500
the X Y coordinates, this is six.

283
00:19:24.650 --> 00:19:25.850
And this is five.

284
00:19:25.850 --> 00:19:34.880
And so to move forward visually on this chessboard for a white piece, I actually need to decrease or

285
00:19:34.880 --> 00:19:37.310
decrement the Y value here.

286
00:19:37.340 --> 00:19:37.790
OK.

287
00:19:38.420 --> 00:19:42.380
And so you see me here using a negative one.

288
00:19:42.410 --> 00:19:49.700
OK, so I'm saying take whatever the y value is right here, which in this case is a six and then add

289
00:19:50.240 --> 00:19:53.360
negative one to a six, which would be five.

290
00:19:53.690 --> 00:19:57.140
And that brings me to here, and that's how I move forward.

291
00:19:57.320 --> 00:19:57.740
OK.

292
00:19:58.370 --> 00:19:59.720
And so that's what I'm doing here.

293
00:20:00.140 --> 00:20:03.770
Now this other bit here calculate y with direction factor.

294
00:20:04.250 --> 00:20:08.960
This is kind of interesting, so I don't think I'm going to get too deep into this right now.

295
00:20:08.960 --> 00:20:16.310
But I will simply state that this method here is allowing my code to factor in whether or not we're

296
00:20:16.310 --> 00:20:18.770
talking about white pieces or black pieces.

297
00:20:18.770 --> 00:20:24.680
Because if we're talking about white pieces down here on this part of the board, then moving forward

298
00:20:24.680 --> 00:20:33.440
means to go this way, which in array notation means to go negatively right or to subtract numbers essentially

299
00:20:33.440 --> 00:20:33.770
right.

300
00:20:33.800 --> 00:20:39.500
If you're going in this direction, however, if you are a black piece and a pawn is going forward,

301
00:20:39.500 --> 00:20:45.510
forward means to increase the array numbers in the y axis.

302
00:20:45.530 --> 00:20:45.920
OK.

303
00:20:46.070 --> 00:20:47.540
Because again, this would be zero.

304
00:20:47.540 --> 00:20:49.200
This is one two three.

305
00:20:49.220 --> 00:20:56.870
So if you want this pawn to move forward some squares, then that means wherever he currently is, which

306
00:20:56.870 --> 00:21:00.020
in this case would be a y axis value of one.

307
00:21:00.290 --> 00:21:04.820
Then he's going to you're going to be adding like a one to it or something.

308
00:21:04.820 --> 00:21:06.770
So now you're at two or three or whatever.

309
00:21:06.800 --> 00:21:07.190
OK.

310
00:21:07.580 --> 00:21:18.110
And so this method here takes into account what color your pawn is and then allows the same offset values

311
00:21:18.110 --> 00:21:22.610
to work, whether or not we're talking about black pieces or white pieces.

312
00:21:22.640 --> 00:21:26.600
OK, well, I guess I'm getting into it now, so let me go ahead and just finish explaining this.

313
00:21:26.600 --> 00:21:32.300
So basically, if we take a look at this method here, calculate y with direction factor, that's what

314
00:21:32.300 --> 00:21:33.390
this stands for.

315
00:21:34.070 --> 00:21:35.930
Let's see, where did I put that method?

316
00:21:36.020 --> 00:21:41.060
I think I actually pushed this method up into the chess piece class itself.

317
00:21:41.240 --> 00:21:41.960
Yep, I did.

318
00:21:42.260 --> 00:21:49.550
So all this does is it just takes a look at what the color of the chess piece is, and it says, Right

319
00:21:49.550 --> 00:21:51.180
here I'm using a ternary.

320
00:21:51.200 --> 00:21:51.680
OK.

321
00:21:51.950 --> 00:21:58.400
So I'm saying, if the color of this chess piece, this is a property, by the way, color here, and

322
00:21:58.400 --> 00:22:01.580
that's just a property of all chess pieces, OK?

323
00:22:01.880 --> 00:22:09.620
So if the color of this particular chess piece at this time is white, so you can think if the color

324
00:22:09.620 --> 00:22:16.490
of this chess piece is white, then returned a positive one.

325
00:22:16.760 --> 00:22:19.250
Otherwise, return a negative one.

326
00:22:19.280 --> 00:22:22.220
OK, so let's see what how that what that would do.

327
00:22:22.220 --> 00:22:24.770
And then and then we take whatever the offset.

328
00:22:24.820 --> 00:22:26.450
Was and then we just multiply.

329
00:22:26.600 --> 00:22:32.480
So this is a a programming math trick that you will see from time to time and encoding.

330
00:22:32.660 --> 00:22:41.600
If you want to flip the sign of a number, especially an integer, very easily, you can simply multiply

331
00:22:41.600 --> 00:22:43.110
it times negative one.

332
00:22:43.130 --> 00:22:43.420
Right.

333
00:22:43.430 --> 00:22:49.490
So if the number was positive and you multiply it times negative one, it will now be negative.

334
00:22:49.820 --> 00:22:54.530
And if it was a negative, then you multiply it times negative one, then it will suddenly flip back

335
00:22:54.530 --> 00:22:55.760
to being positive, right?

336
00:22:55.780 --> 00:22:57.770
It's just a nice algebraic trick.

337
00:22:58.130 --> 00:22:58.550
OK.

338
00:22:58.580 --> 00:23:05.270
So that essentially just says that if this is a white piece, which would mean it's down here, then

339
00:23:05.270 --> 00:23:11.210
we want the negative one to remain negative one, which means that the direction factor will be positive

340
00:23:11.210 --> 00:23:14.930
one and positive one times negative one will be negative one, right?

341
00:23:15.200 --> 00:23:22.010
On the other hand, if the pun happens to be black and we wanted to move forward by one square, then

342
00:23:22.010 --> 00:23:25.700
the y direction factor will be negative one.

343
00:23:25.850 --> 00:23:30.410
And so that will get multiplied times the negative one that we already have here, which will end up

344
00:23:30.410 --> 00:23:37.940
being a positive one, which means that it will move forward using array notation forward by one, which

345
00:23:37.940 --> 00:23:42.140
would mean we'll go from zero one two zero one two, right?

346
00:23:42.710 --> 00:23:45.930
And so that's what this method is doing.

347
00:23:45.950 --> 00:23:52.730
OK, now what you unfortunately don't get to see here is the time that I spent thinking of, huh, how

348
00:23:52.730 --> 00:23:55.550
can I make it so that if it's black, it goes this way?

349
00:23:55.550 --> 00:23:57.380
And if it's white, it goes that way, right?

350
00:23:57.530 --> 00:24:00.020
And honestly, I don't remember how long it took me to think of that.

351
00:24:00.020 --> 00:24:04.850
Probably not that long, because, you know, I've been coding a long time and I was pretty familiar

352
00:24:04.850 --> 00:24:09.620
with the fact that, yeah, we've got these, you know, I could just use a trick like this to get that

353
00:24:09.620 --> 00:24:10.040
going.

354
00:24:10.340 --> 00:24:12.890
For some of you who have never thought in this way before.

355
00:24:12.920 --> 00:24:16.070
It may have taken you longer or you might not have ever thought of that.

356
00:24:16.370 --> 00:24:22.100
I'm kind of jumping ahead, though, to a future use case, but I went ahead and just decided to explain

357
00:24:22.100 --> 00:24:22.670
that now.

358
00:24:22.910 --> 00:24:23.210
All right.

359
00:24:23.220 --> 00:24:32.060
So at any rate, this get offset method here simply creates a new coordinate from the existing one.

360
00:24:32.070 --> 00:24:35.570
So let's jump into that and see what it's doing.

361
00:24:35.570 --> 00:24:39.800
So this is a method that lives on the coordinates class, OK?

362
00:24:40.250 --> 00:24:48.920
And so it takes the existing coordinate, which in this case would be a two which in array notation

363
00:24:48.920 --> 00:24:53.670
would be zero comma six zero comma six.

364
00:24:54.110 --> 00:24:58.970
And then it takes our offset, which would be zero comma negative one.

365
00:24:59.080 --> 00:25:00.860
OK, zero comma negative one.

366
00:25:00.860 --> 00:25:04.490
And then it just does the math to create a new coordinate.

367
00:25:04.520 --> 00:25:04.940
OK.

368
00:25:05.270 --> 00:25:11.210
So we take the existing value of X, which is zero and we're adding a zero in this particular case.

369
00:25:11.210 --> 00:25:12.530
So that's still going to be zero.

370
00:25:12.800 --> 00:25:20.930
And then we take the existing Y, which is six, and then we're adding the offset, which will now be

371
00:25:20.930 --> 00:25:24.440
negative one, which will result in a five, right?

372
00:25:24.770 --> 00:25:29.300
And so we end up with a new coordinate of zero comma five.

373
00:25:29.780 --> 00:25:31.250
That's what this is doing.

374
00:25:31.250 --> 00:25:32.330
This gets offset.

375
00:25:32.450 --> 00:25:32.870
OK.

376
00:25:33.530 --> 00:25:39.440
And then I end up storing that in a variable called forward one.

377
00:25:39.470 --> 00:25:46.970
So in other words, I'm saying one of the valid moves that our pawn can make is to move forward by one

378
00:25:46.970 --> 00:25:47.630
square.

379
00:25:47.660 --> 00:25:53.640
And so I'm taking this new coordinate and then I'm setting it on an array of valid moves.

380
00:25:53.670 --> 00:25:56.750
OK, so I'm just collecting all of the valid moves.

381
00:25:56.750 --> 00:25:59.750
OK, I know what all the valid moves are for a pawn.

382
00:25:59.780 --> 00:26:00.230
OK?

383
00:26:00.380 --> 00:26:03.770
And so I'm just adding them into this array.

384
00:26:03.860 --> 00:26:04.340
All right.

385
00:26:04.550 --> 00:26:12.680
Now you'll see in the, I think, maybe next section or module where we cover collections, where we

386
00:26:12.680 --> 00:26:17.960
will probably decide to revise this and make use of proper Java collections because there's a way better

387
00:26:17.960 --> 00:26:18.650
way to do this.

388
00:26:18.830 --> 00:26:24.610
I just was trying to only utilize the things that you have actually learned up into this point.

389
00:26:24.620 --> 00:26:25.850
Mostly, OK.

390
00:26:26.120 --> 00:26:31.130
I tried not to cheat, but this can be done way more easily with an actual proper collection.

391
00:26:31.280 --> 00:26:35.610
I almost never use actual arrays, and I think I mentioned that in somewhere.

392
00:26:35.630 --> 00:26:36.020
I don't know.

393
00:26:36.380 --> 00:26:42.530
Anyway, OK, so then I store that in in this array, and let's pretend like these other things aren't

394
00:26:42.530 --> 00:26:46.160
here yet because those are future use cases or future exercises.

395
00:26:46.190 --> 00:26:46.520
OK.

396
00:26:47.090 --> 00:26:51.240
And then all I need to do now is just return this array.

397
00:26:51.270 --> 00:26:51.980
All right, really?

398
00:26:52.400 --> 00:26:53.840
This array right here?

399
00:26:53.870 --> 00:26:54.320
OK.

400
00:26:54.680 --> 00:27:00.440
This bit up here, by the way, is me just tracking how many moves I have hardcoded into this array.

401
00:27:00.500 --> 00:27:00.950
OK.

402
00:27:01.490 --> 00:27:04.310
So you can sort of ignore that for right now.

403
00:27:04.550 --> 00:27:12.620
And then I return the array, so get valid news will return an array of all of the valid moves.

404
00:27:13.070 --> 00:27:19.850
Then I create an expected destination as a coordinate and I set that to a three.

405
00:27:20.090 --> 00:27:24.740
And then all I'm doing is asserting that, hey, one of the valid moves in.

406
00:27:24.800 --> 00:27:31.310
Here should look like this one right here with a three, that's basically what I'm doing.

407
00:27:31.430 --> 00:27:38.960
OK, now I'm doing it in a slightly fancy way because this is an array and all I want to say is is one

408
00:27:38.960 --> 00:27:44.330
of the elements in this array, something that looks like this.

409
00:27:45.410 --> 00:27:51.230
There is no direct way for me to do that with just the basic J unit methods.

410
00:27:51.590 --> 00:27:57.260
I needed some kind of helper method or something that could actually search through my array and find

411
00:27:57.260 --> 00:27:58.910
a match if there is one.

412
00:27:59.240 --> 00:28:04.820
And so I decided to write a method called Is move found in array.

413
00:28:05.180 --> 00:28:09.260
And if we jump into this method, all it is is a for loop.

414
00:28:09.380 --> 00:28:18.260
So it takes an input of an array and the move that we're looking for and it iterate over that array

415
00:28:18.530 --> 00:28:21.410
according to the number of elements that are in the array.

416
00:28:21.440 --> 00:28:21.740
OK.

417
00:28:21.920 --> 00:28:25.250
So I set up a variable, an integer variable starting at zero.

418
00:28:25.430 --> 00:28:33.710
And while X is less than however many elements are inside of this coordinates array, I increment the

419
00:28:33.710 --> 00:28:39.830
variable and that allows me to iterate over each of the elements in the array.

420
00:28:40.310 --> 00:28:42.770
So that's that's how this is working now.

421
00:28:42.980 --> 00:28:47.630
As I'm looking at this, even I'm kind of wondering why I didn't use the enhanced for Loop.

422
00:28:47.630 --> 00:28:49.220
I think I've taught that already.

423
00:28:49.470 --> 00:28:52.970
Now, forgive me, I'm actually recording these lessons a little bit out of order.

424
00:28:52.970 --> 00:28:57.730
I've already recorded many, many more sections beyond this one, and now I've been creating the exercises

425
00:28:57.740 --> 00:28:58.400
that have gone back.

426
00:28:58.400 --> 00:29:03.620
So I can't remember offhand if I've thought the enhanced for Loop yet, I think I'm pretty sure I have,

427
00:29:03.620 --> 00:29:04.790
though I'm pretty sure I have.

428
00:29:05.030 --> 00:29:09.620
So I think I alternatively could have just done this as well.

429
00:29:09.620 --> 00:29:11.450
I probably just didn't think of it at the time.

430
00:29:11.750 --> 00:29:18.190
Let's see, I could do something like for it in its current chords.

431
00:29:19.700 --> 00:29:30.230
Moves, moves and then if current cohort study equals expected move.

432
00:29:31.590 --> 00:29:33.720
Then return true.

433
00:29:34.870 --> 00:29:36.550
Think I could have just done this to.

434
00:29:36.940 --> 00:29:41.170
And actually, that's maybe even a little nicer looking, so there's another way to do that.

435
00:29:41.200 --> 00:29:42.340
Yeah, that does look better.

436
00:29:42.550 --> 00:29:43.380
I don't know why.

437
00:29:43.640 --> 00:29:46.690
I don't know why I didn't do it this way before I might have started off.

438
00:29:46.690 --> 00:29:52.470
I might have evolved the code in some way that caused me to want to do it with the old fashioned for

439
00:29:52.480 --> 00:29:52.750
loop.

440
00:29:52.820 --> 00:29:55.900
Let's run the tests real quick and just confirm that this still works.

441
00:29:57.980 --> 00:29:59.720
In fact, I will run all the tests.

442
00:30:00.350 --> 00:30:02.150
Yeah, so that still works just fine.

443
00:30:02.450 --> 00:30:09.320
So yeah, so that's a probably arguably a better way to do that anyway, using the enhanced for loop

444
00:30:09.470 --> 00:30:12.500
and forgive me if I hadn't taught the enhanced for loop at this point.

445
00:30:12.500 --> 00:30:14.480
But like I said, I'm pretty sure I have.

446
00:30:15.350 --> 00:30:16.070
So there you go.

447
00:30:16.520 --> 00:30:18.440
There's a nicer way to do that.

448
00:30:18.890 --> 00:30:24.080
Oh, and so one other thing I want to show you, though, is where this method is now.

449
00:30:24.440 --> 00:30:30.770
I created this method inside of a class called chess piece test.

450
00:30:31.550 --> 00:30:32.960
Now, why did I do that?

451
00:30:33.560 --> 00:30:41.280
Well, I was thinking that I would reuse this method, probably for other chest piece tests, right?

452
00:30:41.300 --> 00:30:47.450
So if you see here currently I'm in the pond test where I wanted to use this, but what if I wanted

453
00:30:47.450 --> 00:30:53.240
to do this same kind of checking for the night test class, right?

454
00:30:53.600 --> 00:30:58.310
I don't want to duplicate this method in two different places.

455
00:30:58.460 --> 00:31:00.290
I want to just reuse the same method.

456
00:31:00.560 --> 00:31:03.080
So there are generally two ways that I could do that.

457
00:31:03.650 --> 00:31:12.830
I can either do what I did and just introduce a super class for my test class itself and then write

458
00:31:12.830 --> 00:31:14.960
that method up in that super class.

459
00:31:15.110 --> 00:31:20.690
And then my night test class could extend this same class and then reuse that method.

460
00:31:21.080 --> 00:31:22.100
I could do it that way.

461
00:31:22.100 --> 00:31:30.770
Or I could also have just made this method a static method on a what I like to call utility class.

462
00:31:31.100 --> 00:31:32.510
And that would work too.

463
00:31:32.510 --> 00:31:37.340
And in fact, I know a lot of Java developers might have even preferred that I had done it that way

464
00:31:37.490 --> 00:31:43.970
because a lot of Java developers are horrified of using object orientation and class hierarchies.

465
00:31:44.180 --> 00:31:45.890
And let me just say this real quick.

466
00:31:45.890 --> 00:31:50.450
I think I might have said it in one of the other lessons, but I will repeat this one of the reasons

467
00:31:50.450 --> 00:31:57.620
why a lot of developers, a lot of Java developers are, in my opinion, kind of scarred and horrified

468
00:31:57.650 --> 00:32:05.450
to use class hierarchies very much is because they've been on projects where class hierarchies are abused

469
00:32:05.450 --> 00:32:10.490
and used so badly that it that they just kind of want to mostly stay away from it.

470
00:32:10.910 --> 00:32:17.870
What that looks like when you do see a class hierarchy that is run amuck is you'll often see many,

471
00:32:17.870 --> 00:32:20.240
many levels in the class hierarchy.

472
00:32:20.450 --> 00:32:21.860
I don't mean like two or three.

473
00:32:21.860 --> 00:32:25.640
I mean, like eight, nine, 10, whatever, just ridiculous numbers.

474
00:32:25.820 --> 00:32:29.090
And that becomes really complicated and confusing to follow.

475
00:32:29.210 --> 00:32:34.940
And so in that case, it is perfectly understandable why someone who is scarred from working in projects

476
00:32:34.940 --> 00:32:39.920
like that would almost want to just square off using class hierarchies at all.

477
00:32:40.760 --> 00:32:47.270
Unfortunately, the way human beings tend to work is we tend to swing wildly from one extreme to the

478
00:32:47.270 --> 00:32:47.660
other.

479
00:32:48.020 --> 00:32:54.800
So some Java architect, probably on some project, learned about class hierarchies and then went crazy

480
00:32:54.800 --> 00:33:02.000
with them and made a class hierarchy that was way too deep and way too complex, and brought much pain

481
00:33:02.000 --> 00:33:04.610
and suffering to everyone else on that project.

482
00:33:04.790 --> 00:33:11.600
And so then smart people who felt that pain and suffering swung all the way to the other side of the

483
00:33:11.600 --> 00:33:17.660
spectrum and decided I will almost never use class hierarchies for anything ever.

484
00:33:17.870 --> 00:33:21.800
And in my opinion, both of these extremes are wrong.

485
00:33:22.220 --> 00:33:28.310
The better solution is to learn when to use class hierarchy and when not to.

486
00:33:28.430 --> 00:33:30.170
And don't use it when you shouldn't.

487
00:33:30.200 --> 00:33:30.620
OK.

488
00:33:31.490 --> 00:33:39.890
So in my case, for now, I'm not afraid to introduce one level of class hierarchy to my unit tests

489
00:33:40.130 --> 00:33:40.880
for two reasons.

490
00:33:40.910 --> 00:33:47.150
First off, I wanted to show you the fact that, yes, even tests can make use of these object oriented

491
00:33:47.150 --> 00:33:47.840
techniques.

492
00:33:48.050 --> 00:33:51.380
Basically, we're just trying not to have duplicated code.

493
00:33:51.440 --> 00:33:51.890
OK.

494
00:33:52.070 --> 00:33:54.110
That's basically what we're trying to do here.

495
00:33:54.950 --> 00:34:03.020
If the only place where I might ever use this method is in tests that are related to test pieces, then

496
00:34:03.020 --> 00:34:09.950
it might very well make sense for me to just introduce a super class called test piece test and put

497
00:34:09.950 --> 00:34:10.820
this method there.

498
00:34:11.180 --> 00:34:17.180
Now, the minute that I start to realize that I want to use this method in some other contexts beyond

499
00:34:17.180 --> 00:34:23.690
just a chess piece, then the alternative that I outlined earlier might make sense where I might make

500
00:34:23.690 --> 00:34:27.560
this method a static method on a separate class.

501
00:34:27.830 --> 00:34:34.400
And maybe I will just call it chess, test utilities or something like that.

502
00:34:34.640 --> 00:34:39.080
And then that would be a static method there, and I could still use it just like I'm using it here,

503
00:34:39.230 --> 00:34:41.120
and it would still be reusable and everything.

504
00:34:41.120 --> 00:34:43.310
But now I'm not using a class hierarchy.

505
00:34:43.580 --> 00:34:50.180
My point here is don't be afraid to use class hierarchies and also don't abuse class hierarchies.

506
00:34:50.330 --> 00:34:55.070
And I know a lot of humans just aren't really good with living kind of in the middle place there.

507
00:34:55.340 --> 00:34:57.530
It's much easier to just be all the way on one.

508
00:34:57.590 --> 00:34:59.000
Side are all the way on the other.

509
00:34:59.240 --> 00:35:02.900
Unfortunately, that is rarely the right place to be, in my opinion.

510
00:35:02.930 --> 00:35:03.350
All right.

511
00:35:03.830 --> 00:35:04.450
Let's see.

512
00:35:04.460 --> 00:35:05.120
So.

513
00:35:05.200 --> 00:35:10.550
So yeah, that method is simply iterating through our array looking for a match.

514
00:35:10.550 --> 00:35:16.130
And if it finds a match, then it short circuits the iterations by short circuit.

515
00:35:16.130 --> 00:35:17.060
I mean, it stops.

516
00:35:17.510 --> 00:35:21.140
It jumps out of the method early with this return statement here.

517
00:35:21.620 --> 00:35:21.980
Right?

518
00:35:22.700 --> 00:35:24.650
And it just returns a true right away.

519
00:35:25.190 --> 00:35:32.570
Otherwise, if it gets to the end of this array loop and it never finds a match with this equals method,

520
00:35:32.570 --> 00:35:33.920
then it returns a false.

521
00:35:33.950 --> 00:35:40.100
OK, now another thing I need to mention here is the fact that we're using this equals method at all.

522
00:35:40.310 --> 00:35:45.770
And I think this is one place where I probably did have to cheat a little bit because I believe I haven't

523
00:35:45.770 --> 00:35:49.430
explicitly thought much about the equals method yet.

524
00:35:49.610 --> 00:35:51.020
So forgive me for that.

525
00:35:51.380 --> 00:35:54.620
But let me go ahead and just show you really quickly what I'm doing there.

526
00:35:55.130 --> 00:36:02.780
So this equals method is just a way for us to allow Java to test whether or not two objects have the

527
00:36:02.780 --> 00:36:03.880
same values.

528
00:36:03.890 --> 00:36:10.040
OK, so they don't have to actually explicitly be the same object in memory, but as long as they have

529
00:36:10.040 --> 00:36:14.240
the same properties, they will be considered to be equal.

530
00:36:14.330 --> 00:36:14.720
OK.

531
00:36:14.900 --> 00:36:18.290
Let me jump in to this method so you can see what that looks like.

532
00:36:18.560 --> 00:36:23.720
So the way I got this method, you may have seen me do this, but I don't know that I taught it explicitly

533
00:36:23.720 --> 00:36:24.020
yet.

534
00:36:24.170 --> 00:36:29.120
I knew I will be teaching it in more depth in the collections section.

535
00:36:29.420 --> 00:36:34.250
But I allowed the idea to generate this method for me.

536
00:36:34.280 --> 00:36:34.730
OK.

537
00:36:34.940 --> 00:36:37.640
And that's the main thing you need to know for right now.

538
00:36:37.640 --> 00:36:46.160
So I can put my cursor somewhere on some blank space in a class and then I can do a command in four

539
00:36:46.280 --> 00:36:46.880
generate.

540
00:36:46.880 --> 00:36:52.370
Or if you're in Windows or Linux, then you can just right click, I think, on empty space somewhere

541
00:36:52.370 --> 00:36:53.750
and go down to generate.

542
00:36:54.050 --> 00:36:58.160
You can come down here and then choose to generate equals and hash code method.

543
00:36:58.340 --> 00:37:02.750
And then it will take a look at all the properties that are on the given class.

544
00:37:02.750 --> 00:37:07.730
And it will ask you, Do you want to use those properties to factor them in to the generation of your

545
00:37:07.730 --> 00:37:08.880
equals and hash code method?

546
00:37:08.910 --> 00:37:15.530
So what that's basically doing is it's just going to say if I see two coordinate objects and you want

547
00:37:15.530 --> 00:37:19.580
me to compare them to determine if they are equivalent to each other.

548
00:37:19.850 --> 00:37:24.740
What are the properties of the coordinate objects that you want me?

549
00:37:24.750 --> 00:37:30.590
The the idea generating your equals method to use to determine whether or not they are equal.

550
00:37:30.800 --> 00:37:37.310
So if you have to coordinate objects and they both have the same X in the same Y values, for example,

551
00:37:37.610 --> 00:37:41.300
maybe that is sufficient to determine that they are equal.

552
00:37:41.510 --> 00:37:41.900
OK?

553
00:37:41.990 --> 00:37:48.080
You get to decide that when you have the idea, generate an equals method for you.

554
00:37:48.380 --> 00:37:53.060
Now, it will also generate this hash code thing that you will definitely learn about in the.

555
00:37:53.180 --> 00:37:56.120
I think, next next module or section.

556
00:37:56.450 --> 00:38:02.840
But in general, whatever properties you choose to tie to your equals method should also be used for

557
00:38:02.840 --> 00:38:03.800
the hash code method.

558
00:38:03.800 --> 00:38:04.160
OK?

559
00:38:04.580 --> 00:38:06.110
That's the long and short of that.

560
00:38:06.260 --> 00:38:08.090
And so that's what's going on here.

561
00:38:08.090 --> 00:38:11.750
And then we can return a true otherwise we will just return a false.

562
00:38:12.320 --> 00:38:18.320
And so then you get to see me use another assertion from J Unit, which is assert true.

563
00:38:18.530 --> 00:38:24.110
I can't use assert equals now because I'm not explicitly comparing two items anymore.

564
00:38:24.140 --> 00:38:30.380
Instead, I'm just saying loop over all the items in this array and find a match for this guy here.

565
00:38:30.380 --> 00:38:32.270
And if you do find one return, true.

566
00:38:32.810 --> 00:38:35.720
So if that happens, then this assertion will be true.

567
00:38:36.110 --> 00:38:36.410
Right?

568
00:38:36.770 --> 00:38:41.090
And if it doesn't find a match, then this method returns false, which isn't true.

569
00:38:41.360 --> 00:38:45.050
And therefore this assertion will fail and therefore the test will fail.

570
00:38:45.200 --> 00:38:52.430
OK, now if this test does fail, then I'm also using this alternative version of the assertion where

571
00:38:52.430 --> 00:38:59.450
I can supply a message and my message here will be move blah blah blah not found and this blah blah

572
00:38:59.450 --> 00:38:59.720
blah.

573
00:38:59.750 --> 00:39:02.690
Here is the expected destination.

574
00:39:02.960 --> 00:39:09.350
Now what will actually be printed here is the two string method of the coordinates of this expected

575
00:39:09.350 --> 00:39:10.730
destination or the coordinates.

576
00:39:10.730 --> 00:39:12.590
OK, and that two string method.

577
00:39:12.590 --> 00:39:19.070
If we jump into the coordinates class here, you will see that I have actually explicitly written a

578
00:39:19.070 --> 00:39:23.930
two string method and I'm using the string that format because I want that to look nice.

579
00:39:23.960 --> 00:39:24.410
OK?

580
00:39:24.740 --> 00:39:30.070
And so I'm printing something and then an arrow and then and then the chess coordinates.

581
00:39:30.080 --> 00:39:36.320
So when I'm printing here, printing here is the chess coordinates like this chess coordinates and then

582
00:39:36.320 --> 00:39:37.580
the array coordinates.

583
00:39:37.580 --> 00:39:41.120
Sorry, if I said chess coordinates when I was pointing at this earlier X and Y.

584
00:39:41.270 --> 00:39:45.390
So in other words, I want to be able to see really nicely everything that's there.

585
00:39:45.410 --> 00:39:45.850
OK?

586
00:39:46.190 --> 00:39:52.190
And that is the reason and really the only reason at this point why I am storing the original chess

587
00:39:52.190 --> 00:39:57.230
coordinates as a string here really just so that I could have a nice.

588
00:39:57.440 --> 00:40:01.100
To string method that gives me all of this pretty stuff here, OK?

589
00:40:01.250 --> 00:40:05.390
And of course, I'm using the string that format just so that I can get that nicely formatted.

590
00:40:05.570 --> 00:40:05.930
OK.

591
00:40:06.320 --> 00:40:07.580
So it's really just for show.

592
00:40:07.700 --> 00:40:08.420
All right.

593
00:40:08.690 --> 00:40:11.210
And so that is what's going on here.

594
00:40:11.420 --> 00:40:13.070
Oh, and one last thing now.

595
00:40:13.520 --> 00:40:14.030
Yes.

596
00:40:14.390 --> 00:40:22.070
So originally when I wrote this, this test method, I didn't do it quite in such a fancy way where

597
00:40:22.070 --> 00:40:25.850
I was iterating through all of the arrays.

598
00:40:25.870 --> 00:40:27.860
So the first to all of the chess moves.

599
00:40:28.010 --> 00:40:35.030
When I first wrote this method, I only needed to implement one particular type of movement that the

600
00:40:35.030 --> 00:40:36.050
pawn could make.

601
00:40:36.080 --> 00:40:36.500
OK.

602
00:40:36.980 --> 00:40:44.390
And so at that time, I knew that I could count on the one and only chess movement that the pawn could

603
00:40:44.390 --> 00:40:51.080
make being the first and only element in my valid moves array here.

604
00:40:51.290 --> 00:40:52.430
And so you're just seeing that.

605
00:40:52.430 --> 00:40:57.830
I originally wrote this a little bit more simplistically within a third equals, I just said assert

606
00:40:57.830 --> 00:41:05.270
that the expected destination is equal to the zero ETH or the first element in this array.

607
00:41:05.300 --> 00:41:05.660
OK.

608
00:41:06.020 --> 00:41:14.480
But as I implemented more movements that the pawn could possibly make, this array started to grow in

609
00:41:14.480 --> 00:41:15.110
size.

610
00:41:15.110 --> 00:41:21.890
And I no longer wanted to just assume that the move one forward movement was always going to be the

611
00:41:21.890 --> 00:41:24.250
first one in this array.

612
00:41:24.260 --> 00:41:26.660
I didn't want to assume that any longer.

613
00:41:26.840 --> 00:41:34.250
And so then I thought a safer thing to do here would be to just loop over all of the movements and search

614
00:41:34.250 --> 00:41:37.190
for one that matches what I'm looking for.

615
00:41:37.220 --> 00:41:37.580
OK.

616
00:41:37.730 --> 00:41:41.420
But this is how I actually started it with this equal thing.

617
00:41:41.420 --> 00:41:48.050
And then eventually I came back and I refactored this method to use this more complex approach where

618
00:41:48.050 --> 00:41:52.250
I'm searching through things so that the method the test itself would be safer.

619
00:41:52.520 --> 00:41:52.910
OK.

620
00:41:53.180 --> 00:41:53.630
All right.

621
00:41:53.930 --> 00:41:58.270
Another really long one, and I only got to explain like two tests here.

622
00:41:58.280 --> 00:42:03.170
So again, see, I'll see you in the next one, and I will explain some more of what's going on here.

623
00:42:03.290 --> 00:42:04.310
See in the next one.
