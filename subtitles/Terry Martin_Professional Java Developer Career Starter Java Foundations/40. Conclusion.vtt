WEBVTT
1
00:00:00.510 --> 00:00:05.160
All right, guess what, we're finally at the end of this module.

2
00:00:05.550 --> 00:00:11.850
It is the largest module of the entire course, at least at the time of this recording.

3
00:00:12.480 --> 00:00:19.740
Personally, I think it's a fantastic module because I've had a chance to show you, I think so much

4
00:00:19.740 --> 00:00:25.500
that I've always wanted to make sure that developers that I've worked with and managed on my own teams

5
00:00:25.500 --> 00:00:27.570
actually understood and knew.

6
00:00:27.780 --> 00:00:34.950
And so now you've had an opportunity to be exposed to all of these fundamental and foundational skills

7
00:00:34.950 --> 00:00:40.540
and techniques and technologies that are related to relational database programming and data.

8
00:00:40.550 --> 00:00:41.190
ABC.

9
00:00:41.640 --> 00:00:46.200
So in this last lesson, I mostly just want to recap what we've gone over.

10
00:00:46.350 --> 00:00:51.480
And I also want to let you know a little bit about a few of the things that I didn't go into or that

11
00:00:51.480 --> 00:00:52.260
I didn't go into.

12
00:00:52.470 --> 00:00:55.870
Very much so that you kind of have an understanding of what might be left.

13
00:00:55.890 --> 00:00:56.280
OK.

14
00:00:56.880 --> 00:00:59.850
So let me just summarize some of what we went over.

15
00:01:00.300 --> 00:01:06.780
First off, we started off by doing all of this development in this module using TDD or test driven

16
00:01:06.780 --> 00:01:07.470
development.

17
00:01:07.710 --> 00:01:10.830
And we used the G-Unit unit framework to do that.

18
00:01:10.920 --> 00:01:15.030
We also brought in an add on framework, which is a cert j.

19
00:01:15.840 --> 00:01:21.870
One thing that I did not explicitly mention, though throughout this entire module is more specifically

20
00:01:21.870 --> 00:01:23.640
the type of testing we've been doing.

21
00:01:23.820 --> 00:01:29.790
So yes, we've been doing TDD, but one distinction that I did not make or call out was the fact that

22
00:01:30.330 --> 00:01:37.680
the vast majority of the testing we've done in this module is not technically unit testing unit testing

23
00:01:37.680 --> 00:01:43.530
as the general term that you will usually hear for the most common type of testing you can do.

24
00:01:43.560 --> 00:01:49.620
However, most of what we've done, I'd say 98 percent of the tests that we've written are not technically

25
00:01:49.620 --> 00:01:50.480
unit tests.

26
00:01:50.490 --> 00:01:53.550
They are actually called integration tests.

27
00:01:54.000 --> 00:01:56.400
And let me just call out the distinction here.

28
00:01:56.580 --> 00:02:02.400
Unit tests are typically tests that mostly only test one class.

29
00:02:02.610 --> 00:02:09.330
OK, so we do have an example of one unit test if we jump over here into the UI and I'll jump over to

30
00:02:09.330 --> 00:02:10.860
our person class.

31
00:02:11.100 --> 00:02:12.740
Well, actually, I don't have to go to the person class.

32
00:02:12.750 --> 00:02:16.560
We created a test class for the person class called person test.

33
00:02:16.890 --> 00:02:21.060
These two tests here are strictly unit tests.

34
00:02:21.390 --> 00:02:27.840
They only test the functionality that exists within our person class, and they don't go any further

35
00:02:27.840 --> 00:02:28.320
than that.

36
00:02:28.500 --> 00:02:35.460
However, if I go back to our other main test class where we've where we've written the vast majority

37
00:02:35.460 --> 00:02:42.480
of our tests, the people repository test class, the tests in here are not technically unit tests at

38
00:02:42.480 --> 00:02:42.790
all.

39
00:02:42.810 --> 00:02:48.720
They are called integration tests, and the reason that they are considered integration tests is because

40
00:02:48.720 --> 00:02:56.370
they're actually testing a wider range of functionality than what's just in one test class to a certain

41
00:02:56.370 --> 00:03:00.930
degree, and they depend on other systems being available to even work.

42
00:03:01.200 --> 00:03:05.160
Mainly, they depend on the database actually existing.

43
00:03:05.310 --> 00:03:13.110
So we're testing the integration between our database and the repository classes themselves.

44
00:03:13.140 --> 00:03:13.530
OK.

45
00:03:13.830 --> 00:03:17.760
So these tests are really more of integration tests.

46
00:03:18.300 --> 00:03:24.840
One of the reasons for calling out this distinction is the fact that integration tests are typically

47
00:03:24.840 --> 00:03:26.310
slower than unit tests.

48
00:03:26.460 --> 00:03:31.500
And I think you can even see that whenever I run all of the tests now, they don't go nearly as quickly

49
00:03:31.500 --> 00:03:35.070
as if I had written a whole entire suite of unit tests.

50
00:03:35.280 --> 00:03:41.370
Because unit tests don't depend on talking to a database and waiting for data to go backward and back

51
00:03:41.370 --> 00:03:42.630
and forth and all of that.

52
00:03:42.870 --> 00:03:46.590
They just test pure logic, typically business logic.

53
00:03:47.130 --> 00:03:53.700
So we'll probably cover a little bit more explicitly about integration tests in the next module, and

54
00:03:53.700 --> 00:03:59.520
you'll definitely learn more about integration testing in one of my upcoming courses where we go way,

55
00:03:59.520 --> 00:04:03.870
way deeper into frameworks like the spring framework and things like that.

56
00:04:03.900 --> 00:04:04.350
OK.

57
00:04:04.530 --> 00:04:06.030
So enough about testing.

58
00:04:06.150 --> 00:04:09.690
We also learned how to create our own custom annotations, right?

59
00:04:09.960 --> 00:04:14.190
So let's see if we go back into the person class again.

60
00:04:15.510 --> 00:04:23.430
You'll remember that we created this custom annotation here, the ID annotation, and I can jump into

61
00:04:23.700 --> 00:04:28.080
into its code, and it's just an interface that's really all it is.

62
00:04:28.110 --> 00:04:28.560
OK.

63
00:04:28.680 --> 00:04:30.150
So it's pretty straightforward.

64
00:04:30.840 --> 00:04:38.910
And we also had another annotation that we used on our repository classes like the people repository.

65
00:04:38.910 --> 00:04:46.290
So I'll come up here to the top and remind you that we've got this custom notation here, the at school

66
00:04:46.290 --> 00:04:53.130
annotation that we created from scratch just for our own purposes and then to actually make these annotations

67
00:04:53.130 --> 00:04:56.010
useful because on their own, they don't do anything at all.

68
00:04:56.220 --> 00:04:57.720
We had to process them.

69
00:04:57.960 --> 00:04:59.400
And so we learned about.

70
00:04:59.660 --> 00:05:08.960
Java Reflection API, which allows us to basically introspect our own code at runtime, that is while

71
00:05:08.960 --> 00:05:16.670
the program is running to find fields and methods in our case that are annotated with annotations that

72
00:05:16.670 --> 00:05:18.560
we created in this case.

73
00:05:18.710 --> 00:05:21.740
So we got to do some of that, and I thought that was pretty cool.

74
00:05:22.070 --> 00:05:27.920
That gets you a little more into some of the types of programming that more advanced developers or even

75
00:05:27.920 --> 00:05:29.720
software architects might do.

76
00:05:29.900 --> 00:05:33.050
But you saw that it's really not that hard to do, really.

77
00:05:33.230 --> 00:05:39.980
And so there's no reason why you, even as beginners, can't start to dip your toes into creating your

78
00:05:39.980 --> 00:05:46.550
own annotations and using reflection to find things that you've annotated when it's appropriate to do

79
00:05:46.550 --> 00:05:47.720
or when it's useful.

80
00:05:48.050 --> 00:05:51.440
And then, of course, we learned a whole lot about GDC now.

81
00:05:51.560 --> 00:05:58.580
I mean, we've basically written an entire database layer of application code using low level raw J.D.,

82
00:05:58.580 --> 00:06:04.730
B.S. and J.D. B.S. again stands for Java database connectivity, and that's how we're talking to the

83
00:06:04.730 --> 00:06:05.360
database.

84
00:06:05.690 --> 00:06:13.280
Now, the JTBC API is generally meant to be used with relational databases, and that's what we've been

85
00:06:13.280 --> 00:06:19.700
using in this module H2, which can be used as an embedded database, but it can connect to many other

86
00:06:19.700 --> 00:06:20.630
types of databases.

87
00:06:20.630 --> 00:06:28.160
And in fact, as long as you're relational database has a JTBC driver existing for it, you can use

88
00:06:28.160 --> 00:06:29.690
JTBC to connect to it.

89
00:06:29.930 --> 00:06:36.080
And so many of the most popular databases that you may encounter as a professional developer in a company

90
00:06:36.080 --> 00:06:40.890
would be Oracle database or SQL Server.

91
00:06:40.910 --> 00:06:46.430
Those are probably the top two most popular ones by and large, especially for commercial databases.

92
00:06:46.580 --> 00:06:51.590
And then there are some open source ones that are very popular as well, such as MySQL that's called

93
00:06:51.590 --> 00:06:53.030
MySQL.

94
00:06:53.210 --> 00:06:57.380
MySchool is very popular and PostgreSQL as well.

95
00:06:57.650 --> 00:06:59.910
IBM has one called DB two.

96
00:06:59.930 --> 00:07:01.670
I don't know how popular that is anymore.

97
00:07:01.680 --> 00:07:06.500
I haven't looked at it in a while, but used to be kind of popular among the commercial ones.

98
00:07:06.500 --> 00:07:12.320
And then also now there are many other types of databases that are not relational databases at all.

99
00:07:12.590 --> 00:07:18.800
We did not look at any of those technologies here because by far, to become a professional Java developer,

100
00:07:19.190 --> 00:07:24.260
if you only know how to write code for one type of database, it had better be relational databases.

101
00:07:24.440 --> 00:07:30.530
Now, lots of progressive teams in the world have moved either beyond relational databases to other

102
00:07:30.530 --> 00:07:36.470
types of database technologies, or they use alternative database technologies in addition to relational.

103
00:07:36.710 --> 00:07:42.440
But like I said, if you only know one database technology for right now, it had better be relational

104
00:07:42.440 --> 00:07:43.070
database.

105
00:07:43.070 --> 00:07:44.930
That's just kind of foundational.

106
00:07:45.230 --> 00:07:51.950
And so within the JBC API, let me jump in to our crud repository here.

107
00:07:51.980 --> 00:07:56.870
We learned a number of things, and maybe I'll just kind of roll down this class for a little bit and

108
00:07:56.870 --> 00:07:58.700
remind you of some of the things we learned.

109
00:07:58.700 --> 00:08:06.560
So we learned how to create a prepared statement, and that is the JBC type of class that represents

110
00:08:06.800 --> 00:08:10.190
the sequel commands that we are issuing to the database.

111
00:08:10.580 --> 00:08:15.170
So we can do that either with a prepared statement or just with a regular statement.

112
00:08:15.170 --> 00:08:21.320
Prepared statements have an advantage in that they can be pre compiled essentially by the database itself

113
00:08:21.440 --> 00:08:25.490
so that they can execute more quickly when you actually need them to do something.

114
00:08:25.790 --> 00:08:28.550
And we can bind parameters to them.

115
00:08:28.730 --> 00:08:31.580
Let me remind you of what that looks like real quick.

116
00:08:31.850 --> 00:08:35.600
So here are some parameters that are bound to some sequel.

117
00:08:35.960 --> 00:08:43.670
And by using these parameter bindings with our daily DC prepared statements, we can actually protect

118
00:08:43.670 --> 00:08:50.450
ourselves from SQL injection attacks, which is one of the common ways that hackers can break into or

119
00:08:50.450 --> 00:08:51.620
hack systems.

120
00:08:51.620 --> 00:08:58.970
Because software developers make it a little too easy for them to insert their own sequel into user

121
00:08:58.970 --> 00:09:06.710
input that we are interpreting so we can use prepared statements to help protect from that kind of attack.

122
00:09:07.040 --> 00:09:12.170
And we encountered the sequel exception plenty while while working with this, and you already learned

123
00:09:12.170 --> 00:09:17.810
about exceptions previously, but now you've got a little bit more of a real world opportunity to see

124
00:09:17.990 --> 00:09:22.610
firsthand where they come into play and how they affect our coding.

125
00:09:23.060 --> 00:09:31.010
We spent a lot of time working with results sets, so essentially any time that we execute a statement

126
00:09:31.010 --> 00:09:37.010
or prepared statement, we can get back a result set and you can really just think of the results set

127
00:09:37.010 --> 00:09:39.140
as a table of results.

128
00:09:39.710 --> 00:09:44.240
So you could kind of think of the results set as looking like this red table down here where you get

129
00:09:44.240 --> 00:09:51.080
back a bunch of rows and then you can iterate over those rows by calling usually R-Sport next to go

130
00:09:51.080 --> 00:09:54.110
from one row to the next like I'm doing here.

131
00:09:54.140 --> 00:09:59.450
Results sets have metadata associated with them that can let us determine things like.

132
00:09:59.480 --> 00:10:03.980
How many columns are in the results at table, if you want to think of it as a table?

133
00:10:04.160 --> 00:10:09.470
And what are the names of the columns and the names of any aliases for those columns?

134
00:10:09.770 --> 00:10:10.940
Things of that sort.

135
00:10:11.240 --> 00:10:14.760
So we spent quite a bit of time dealing with result sets.

136
00:10:14.930 --> 00:10:21.470
And then we implemented a much more realistic implementation of the repository pattern.

137
00:10:21.770 --> 00:10:28.130
Now, I don't know that I spent a lot of time really letting you know that my choice to call this class

138
00:10:28.130 --> 00:10:34.910
crud repository and having the other classes people repository and address repository, I didn't just

139
00:10:34.910 --> 00:10:36.890
make up that term repository.

140
00:10:37.190 --> 00:10:45.020
That term comes from a very common design pattern in object oriented programming, which is the repository

141
00:10:45.020 --> 00:10:45.560
pattern.

142
00:10:45.680 --> 00:10:53.300
And basically, the repository pattern, in a nutshell, is a way of making a class that forms an abstraction

143
00:10:53.300 --> 00:10:56.270
on top of a collection of objects.

144
00:10:56.450 --> 00:11:05.330
OK, so if you think of other collection classes like lists and sets and things of that sort, the repository

145
00:11:05.330 --> 00:11:12.530
pattern is supposed to sort of act like an interface on top of other types of collections.

146
00:11:12.560 --> 00:11:19.940
OK, now in our case, we're using the repository pattern to make data from the database sort of feel

147
00:11:19.940 --> 00:11:22.760
like it may be coming from a collection.

148
00:11:22.760 --> 00:11:26.150
That's the original intent of the repository pattern.

149
00:11:26.330 --> 00:11:32.540
However, you will find as you proceed in your journey of learning Java and all of the add on frameworks

150
00:11:32.540 --> 00:11:39.170
that are most commonly associated with it, that the repository pattern isn't usually used purely in

151
00:11:39.170 --> 00:11:40.070
that regard.

152
00:11:40.310 --> 00:11:47.060
And there will be a lot of mixture between the repository pattern being an abstraction over the general

153
00:11:47.060 --> 00:11:54.590
concept of a collection versus or in addition to it just being an abstraction on top of just databases

154
00:11:54.590 --> 00:11:55.430
in general.

155
00:11:56.030 --> 00:12:01.160
There's another pattern that I have not explicitly mentioned, which from the average Java developers

156
00:12:01.160 --> 00:12:06.800
perspective, will look pretty much identical to the repository, and that's called the data access

157
00:12:06.800 --> 00:12:08.570
object or Dayo.

158
00:12:08.810 --> 00:12:15.560
So after you take this course and you get your first job and you're working on a team with a lot of

159
00:12:15.560 --> 00:12:21.290
experienced Java developers, you may find yourself working in a code base by code base.

160
00:12:21.290 --> 00:12:28.040
I mean, just a project in a code base where you don't see any classes that are talking to the database

161
00:12:28.040 --> 00:12:33.200
that are called something repository, but you may instead see a lot of classes that are called something

162
00:12:33.210 --> 00:12:33.850
Dayo.

163
00:12:34.030 --> 00:12:38.780
You may see something like person Dayo or address Dayo.

164
00:12:39.200 --> 00:12:46.460
For the most part, those Dayo classes will be pretty much identical and in functionality to what you

165
00:12:46.460 --> 00:12:50.990
have now become accustomed to seeing here with our use of the repository class.

166
00:12:51.200 --> 00:12:54.470
The duo is another data access pattern.

167
00:12:54.860 --> 00:13:02.150
The real distinction between repository pattern and pattern is that while I said earlier, the repository

168
00:13:02.150 --> 00:13:08.300
pattern is really meant to be more of an abstraction on top of the idea of a collection of objects.

169
00:13:08.620 --> 00:13:14.780
The Dayo pattern is a little more explicitly meant to be an abstraction on top of a database.

170
00:13:14.810 --> 00:13:15.120
OK.

171
00:13:15.380 --> 00:13:20.390
So it's not trying as hard to pretend like it's not sitting on top of the database.

172
00:13:20.660 --> 00:13:27.590
It's more OK with its users that it being the dog class, with its users knowing explicitly that it's

173
00:13:27.590 --> 00:13:31.580
there to bridge between the rest of your code and a database.

174
00:13:31.700 --> 00:13:38.330
Whereas the repository pattern might try a little bit more explicitly to hide the fact that it may be

175
00:13:38.330 --> 00:13:40.460
sitting on top of a database.

176
00:13:40.580 --> 00:13:47.060
And that implies, though, that the repository pattern can be used potentially to not just be an abstraction

177
00:13:47.060 --> 00:13:48.830
on top of a database.

178
00:13:48.860 --> 00:13:54.650
OK, so there's a chance some of you may not fully get that distinction, and honestly, it doesn't

179
00:13:54.650 --> 00:13:55.280
really matter.

180
00:13:55.310 --> 00:14:00.620
Don't worry about it as beginning developers or even intermediate developers, the distinction is going

181
00:14:00.620 --> 00:14:01.940
to be relatively minimal.

182
00:14:02.090 --> 00:14:07.370
OK, so just know that you may encounter projects that don't have anything called repository.

183
00:14:07.490 --> 00:14:09.140
They have something called D&amp;O.

184
00:14:09.350 --> 00:14:15.680
But from your perspective, what those two types of classes may be doing in the code is likely to be

185
00:14:15.680 --> 00:14:23.360
pretty much the same thing, which is to translate records from the database into objects and vice versa.

186
00:14:23.750 --> 00:14:26.660
OK, and then we obviously learned quite a bit of sequel.

187
00:14:26.960 --> 00:14:32.950
So I'm going to jump back over to our people repository and we'll just look at some of the sequel here.

188
00:14:32.960 --> 00:14:40.610
So we learned how to obviously select records from the database and how to insert data into the database

189
00:14:40.610 --> 00:14:42.980
and how to update records that are in the database.

190
00:14:42.980 --> 00:14:45.320
Although we didn't do a whole lot of that, we did.

191
00:14:45.470 --> 00:14:50.540
We did implement one simple update method, though in our people repository.

192
00:14:50.990 --> 00:14:58.520
OK, so within the sequel stuff, obviously we learned how to select for specific columns from from

193
00:14:58.520 --> 00:14:59.210
various tables.

194
00:14:59.640 --> 00:15:05.610
We learned how to rename those columns using aliases by using the as key word, right, so parent that

195
00:15:05.610 --> 00:15:09.390
ID as parent underscore ID how to rename those columns.

196
00:15:09.540 --> 00:15:12.230
We learned how to make those renamed columns show up for us.

197
00:15:12.240 --> 00:15:15.930
We learned how to do that in two ways, specifically with age two database.

198
00:15:16.050 --> 00:15:21.750
Well, one of the ways the way that we settled on and code to do it programmatically should work with

199
00:15:21.750 --> 00:15:22.960
any database.

200
00:15:23.220 --> 00:15:29.610
The other technique where we turned on that flag when we establish our connection to to that approach

201
00:15:29.610 --> 00:15:34.800
is specific to H2, which is why we did not depend on that any further.

202
00:15:35.040 --> 00:15:37.380
We learned how to do table joints.

203
00:15:37.650 --> 00:15:43.800
We learned specifically mostly about left outer joins because usually when we're querying for parent

204
00:15:43.800 --> 00:15:49.140
child relationships, we want all of the parents, even if they don't have any children.

205
00:15:49.140 --> 00:15:52.710
And to do that, you need to do a left outer join.

206
00:15:53.070 --> 00:15:58.110
I mentioned briefly, though, about some of the other join types, such as right outer joints, which

207
00:15:58.110 --> 00:15:59.430
really just flips it around.

208
00:15:59.430 --> 00:16:02.070
So you'd get children who are orphans essentially, right?

209
00:16:02.070 --> 00:16:06.750
So children who don't have a parent, you'd still get the kids with a right outer join.

210
00:16:07.020 --> 00:16:08.100
We've got inner joined.

211
00:16:08.100 --> 00:16:13.470
That's kind of where we started with the whole entire join conversation in which in our case, you'd

212
00:16:13.470 --> 00:16:16.560
only get the parents and children where both exist.

213
00:16:16.770 --> 00:16:20.040
So if there are parents with no kids, you won't get anything at all.

214
00:16:20.160 --> 00:16:22.710
If there are kids with no parents, you won't get anything at all.

215
00:16:22.860 --> 00:16:26.160
You have to have both the parents and the children with an inner join.

216
00:16:26.640 --> 00:16:29.160
So those are some of the more common join types.

217
00:16:29.160 --> 00:16:33.390
There are a few others as well, but you're in good shape to know these ones.

218
00:16:33.750 --> 00:16:39.690
We learned how to execute various functions, though I don't think we coded any use of the database

219
00:16:39.690 --> 00:16:40.620
functions here.

220
00:16:40.770 --> 00:16:46.920
But we did learn towards the beginning of our school journey how to do averaging and math and things

221
00:16:46.920 --> 00:16:51.360
like summaries and group by and things of that sort in school.

222
00:16:51.540 --> 00:16:53.430
All very useful things to do.

223
00:16:53.550 --> 00:16:58.440
Essentially, pretty much a lot of the same tricks that we learned how to do with collections and the

224
00:16:58.440 --> 00:16:59.580
streams API.

225
00:16:59.700 --> 00:17:02.820
You can do a lot of those same tricks in the database as well.

226
00:17:03.150 --> 00:17:08.790
We learned how to create indexes on the database so that we can make sure that our queries run quickly

227
00:17:09.030 --> 00:17:15.600
by making sure that there are indexes on any of the columns that we query by write that look ups have

228
00:17:15.600 --> 00:17:17.280
to occur on that.

229
00:17:17.280 --> 00:17:20.280
And I stated to you that that's one of the things that I've noticed.

230
00:17:20.520 --> 00:17:25.920
A lot of developers don't even seem to understand that they can speed up their application so much by

231
00:17:25.920 --> 00:17:28.410
simply creating an index on those columns.

232
00:17:28.590 --> 00:17:32.910
Now there are some cases where you don't even need to explicitly do it, like where we were creating

233
00:17:32.910 --> 00:17:37.840
tables and then defining foreign keys or primary keys when we're doing that.

234
00:17:37.920 --> 00:17:43.860
Typically, you'll get the indexes created for you automatically by virtue of the fact that you're defining

235
00:17:43.980 --> 00:17:46.380
a foreign key or primary key field.

236
00:17:46.650 --> 00:17:53.160
But if you want indexes on other fields that are not foreign or primary keys or things of that sort,

237
00:17:53.370 --> 00:17:55.490
you can explicitly create those as well.

238
00:17:55.500 --> 00:17:56.760
And we did do that too.

239
00:17:57.000 --> 00:17:57.280
All right.

240
00:17:57.300 --> 00:18:03.360
One one other thing I want to mention, though, is that in this module we did, we did not create a

241
00:18:03.360 --> 00:18:08.640
traditional interface for any of the application coding that we did by interface.

242
00:18:08.700 --> 00:18:13.170
I don't mean a Java interface, I mean user interface, that's what I should have said.

243
00:18:13.620 --> 00:18:18.840
So typically, an application will have a user interface, such as either a command line.

244
00:18:18.960 --> 00:18:22.710
We would think back to our guessing game program that we wrote.

245
00:18:22.980 --> 00:18:28.590
The interface was command line where you had to type it, where it prompted us in text at the bottom

246
00:18:28.590 --> 00:18:33.870
of the screen, and we had to enter values to guess a number and things like that.

247
00:18:33.870 --> 00:18:37.140
So we had a user interface that was based on the command line.

248
00:18:37.560 --> 00:18:41.580
There are other types of user interfaces that we could have implemented.

249
00:18:41.850 --> 00:18:48.390
There are web interfaces where you're in a web browser and that's how you'd interact with your application.

250
00:18:48.600 --> 00:18:55.680
You can have an interface on your smartphone or tablet or a desktop application itself.

251
00:18:55.830 --> 00:18:56.100
Right.

252
00:18:56.100 --> 00:18:57.510
There are lots of interfaces.

253
00:18:57.510 --> 00:19:03.880
However, in this module, our interface here was really just our unit tests themselves.

254
00:19:03.900 --> 00:19:04.320
OK.

255
00:19:04.590 --> 00:19:07.140
And that's not like a real user interface.

256
00:19:07.380 --> 00:19:12.060
That's just the only interface that we bothered to create, because I really haven't taught you how

257
00:19:12.070 --> 00:19:15.540
to create any more advanced types of interfaces yet.

258
00:19:15.990 --> 00:19:17.850
But I just want you to think about that.

259
00:19:18.060 --> 00:19:26.310
The our use of the unit tests essentially can be thought of as the interface into our application.

260
00:19:26.850 --> 00:19:28.680
From our perspective, at least.

261
00:19:29.100 --> 00:19:29.440
All right.

262
00:19:29.460 --> 00:19:35.610
So finally, the last thing I want to mention here is some of the things that I may have left out and

263
00:19:35.610 --> 00:19:39.060
what you will see in your continuing journey down this road.

264
00:19:39.600 --> 00:19:46.050
So I want to remind you again that the reason that we spent so much time in this module and the reason

265
00:19:46.050 --> 00:19:50.520
that we learned the techniques that we did and we called these things in the way that we called them

266
00:19:50.520 --> 00:19:58.140
is because I based almost everything we did here off of well-known frameworks that you will be learning

267
00:19:58.140 --> 00:19:58.950
in the future.

268
00:19:59.110 --> 00:20:06.670
There's a very popular framework called Hibernate, and another one is called spring data, and particularly

269
00:20:06.670 --> 00:20:07.840
with spring data.

270
00:20:08.260 --> 00:20:14.950
When we create database applications using the spring data framework, our programming can look almost

271
00:20:14.950 --> 00:20:16.750
identical to what we did here.

272
00:20:17.110 --> 00:20:23.140
I intended it to be that way on purpose so that when you do learn spring data, it will feel very comfortable

273
00:20:23.140 --> 00:20:24.520
and familiar to you.

274
00:20:24.730 --> 00:20:28.780
So spring data, for example, has a credit repository interface.

275
00:20:28.780 --> 00:20:30.400
It's it's not a class.

276
00:20:30.400 --> 00:20:36.310
If I recall correctly, it's an interface, but they have something called credit repository that you

277
00:20:36.310 --> 00:20:38.440
can implement instead of extending.

278
00:20:38.560 --> 00:20:40.150
And it is generic.

279
00:20:40.270 --> 00:20:46.930
So you must specify what the data type is for your domain model that the repository will be helping

280
00:20:46.930 --> 00:20:48.940
you to manage, if you will.

281
00:20:49.240 --> 00:20:54.820
Now, in addition, with the spring data framework, you not only have to specify what the entity class

282
00:20:54.820 --> 00:20:55.930
type is like.

283
00:20:55.930 --> 00:21:02.200
In our case here, person, you also have to specify what the data type is for the ID property.

284
00:21:02.230 --> 00:21:06.310
So typically that would be like a long or something like that.

285
00:21:06.490 --> 00:21:10.290
Now we could have done that here as well, but we didn't need to as most.

286
00:21:10.300 --> 00:21:17.560
So we just hardcoded our credit repository to just assume that all IDs were going to be of type long.

287
00:21:17.830 --> 00:21:26.890
But I could have generic size this as well by just adding that I just adding another generic type right

288
00:21:26.890 --> 00:21:31.630
here t comma something else like T comma I for ID or whatever.

289
00:21:32.080 --> 00:21:39.580
And then in all the places here where where I'm referring to type long, I could have just used that

290
00:21:39.580 --> 00:21:41.440
generic type right there as well.

291
00:21:41.650 --> 00:21:46.870
And you will find that in the spring data framework, that's exactly what they do.

292
00:21:46.870 --> 00:21:50.170
So they just went another step beyond what we did here.

293
00:21:50.410 --> 00:21:53.710
But I thought that would be going a little bit too far for us.

294
00:21:53.740 --> 00:21:55.180
So I held back on that.

295
00:21:55.750 --> 00:22:02.410
Additionally, some of the annotations that we created well, specifically the Ad ID annotation is going

296
00:22:02.410 --> 00:22:08.740
to look very familiar when we do learn about spring data and hibernate because we use that same type

297
00:22:08.740 --> 00:22:11.920
of annotation with the spring data framework as well.

298
00:22:12.280 --> 00:22:15.790
So that's also going to be very familiar now with spring data.

299
00:22:15.800 --> 00:22:23.050
There are additional annotations that we didn't create here that you will learn, but you will understand

300
00:22:23.050 --> 00:22:28.750
what those other annotations are generally doing because of all the types of work that we did here.

301
00:22:29.230 --> 00:22:35.500
So one of the biggest things that you're going to learn with spring data is the fact that spring data

302
00:22:35.500 --> 00:22:43.660
and frameworks like ID and Hibernate can actually generate the sequel for you like magic.

303
00:22:43.900 --> 00:22:50.350
So all of this cumbersome and tedious sequel that we've been writing explicitly, we didn't need to

304
00:22:50.350 --> 00:22:57.040
write any of that if we were using one of the more modern Java database frameworks like spring data.

305
00:22:57.430 --> 00:23:03.310
So these modern framework, which are generally referred to as object relational mappers, well, technically

306
00:23:03.310 --> 00:23:09.010
their object relational mappers, if they're being used to work with a relational database.

307
00:23:09.010 --> 00:23:14.650
But actually, frameworks like spring data can actually work with more than just relational databases.

308
00:23:14.830 --> 00:23:20.800
So you can write the same types of code regardless of what type of database you may be connecting to.

309
00:23:20.800 --> 00:23:25.060
Though, like I said earlier, relational database is still kind of like the most foundational thing

310
00:23:25.060 --> 00:23:29.800
that you see most common, probably especially in the corporate Java development world.

311
00:23:30.190 --> 00:23:35.830
So anyway, these frameworks, though, can generate all of the sequel for you.

312
00:23:36.100 --> 00:23:41.080
So if that's true, you may be wondering, Well, why did you make us learn all of the sequel?

313
00:23:41.530 --> 00:23:47.860
And the reason for that is that if you do not understand sequel well enough to know how you would have

314
00:23:47.860 --> 00:23:54.220
written the sequel to accomplish what you're trying to do, quite often, you will misunderstand how

315
00:23:54.220 --> 00:24:01.470
these higher level frameworks will generate the sequel, and you'll end up with highly inefficient sequel

316
00:24:01.690 --> 00:24:05.080
and you won't understand why the sequel is inefficient.

317
00:24:05.620 --> 00:24:11.050
I've worked out a lot of places, in fact, where there were developers who were highly skeptical of

318
00:24:11.050 --> 00:24:15.250
using these great frameworks for the most part, hibernate and spring data.

319
00:24:15.400 --> 00:24:19.630
They've just sworn, you know, we're not even going to use these frameworks or they don't use them

320
00:24:19.630 --> 00:24:24.940
to very good effect, usually because they tried to use them in the past.

321
00:24:24.940 --> 00:24:29.410
And the results were very, very slow and cumbersome and inefficient.

322
00:24:29.710 --> 00:24:35.020
And really, they blame the framework, but it's actually not the frameworks fault nine times out of

323
00:24:35.020 --> 00:24:35.470
10.

324
00:24:35.620 --> 00:24:39.220
It's just the fact that they have no idea what they're doing with those frameworks.

325
00:24:39.490 --> 00:24:44.980
And I think it's very, very useful when you're using these frameworks that can generate SQL for you

326
00:24:45.160 --> 00:24:52.510
to first think through what cycle would you write if you had to write it yourself and then consider

327
00:24:52.690 --> 00:24:58.130
what you need to do with those frameworks to get them to generate that same sequel?

328
00:24:58.150 --> 00:24:58.600
OK.

329
00:24:59.100 --> 00:25:04.950
So you still save yourself a lot of time and effort by not having to write out all the columns and all

330
00:25:04.950 --> 00:25:11.660
of these things, but you do still need to think through what would I do if I were writing this myself?

331
00:25:11.670 --> 00:25:15.120
And that's one of the biggest reasons why we went through all of this.

332
00:25:15.330 --> 00:25:20.430
That's one of the biggest reasons why we I spent the time teaching you the various techniques for doing

333
00:25:20.430 --> 00:25:26.610
various types of joining for one to ones and one to many type relationships, which are among the most

334
00:25:26.610 --> 00:25:31.920
common types of relationships you will encounter in these upcoming frameworks.

335
00:25:32.220 --> 00:25:38.820
So as long as you keep in mind how you would write these low level sequel queries yourself, you'll

336
00:25:38.820 --> 00:25:45.810
have a much better time and a much better understanding of how to work with these frameworks like hibernate

337
00:25:45.810 --> 00:25:46.830
and spring data.

338
00:25:46.950 --> 00:25:52.950
And that's something that I see so many developers just completely forget or ignore, or they don't

339
00:25:52.950 --> 00:25:53.730
appreciate.

340
00:25:53.880 --> 00:25:58.860
And then they go down a really bad road with those frameworks, and then either they use them blindly

341
00:25:58.860 --> 00:26:05.460
and very badly with very poor results, or they give up on using them completely.

342
00:26:05.460 --> 00:26:11.190
And then they just blame the framework instead of realizing that it's their lack of understanding that

343
00:26:11.190 --> 00:26:13.560
is causing the vast majority of the problems.

344
00:26:13.770 --> 00:26:19.650
Not to say that these frameworks are perfect, by the way, but they can be used to great effect if

345
00:26:19.650 --> 00:26:21.120
you know how to use them.

346
00:26:21.570 --> 00:26:21.930
All right?

347
00:26:21.930 --> 00:26:25.650
And then maybe one or two other points that I would like to make.

348
00:26:26.070 --> 00:26:30.230
So if I go back over to the tests here, let's see.

349
00:26:30.240 --> 00:26:38.370
So here we are with the people repository declaration here and then down here, we're actually creating

350
00:26:38.370 --> 00:26:42.840
an instance of this repository and we're passing in the connection.

351
00:26:43.170 --> 00:26:44.460
So a couple of things here.

352
00:26:44.550 --> 00:26:51.210
When we learn about these upcoming frameworks like the spring framework, spring data, spring boot,

353
00:26:51.210 --> 00:26:52.470
et cetera, et cetera.

354
00:26:52.680 --> 00:26:57.330
One of the things that you're going to see, and I will obviously talk about this more, but I'm just

355
00:26:57.330 --> 00:26:58.770
giving you a little sneak preview here.

356
00:26:58.920 --> 00:27:06.510
One of the things that you're going to probably not see very often is explicit use of the new operator

357
00:27:06.510 --> 00:27:12.600
here to create instances of important key classes like repository classes.

358
00:27:12.810 --> 00:27:18.000
You will not see us creating new instances of these classes, probably ever.

359
00:27:18.330 --> 00:27:24.300
And one reason for that is because frameworks like the spring framework and there aren't that many in

360
00:27:24.300 --> 00:27:25.020
the Java world.

361
00:27:25.020 --> 00:27:28.020
Really, the spring framework is the most famous one for sure.

362
00:27:28.440 --> 00:27:34.350
Employ a pattern called dependency injection and or inversion of control.

363
00:27:34.740 --> 00:27:41.400
And basically, what that means for you is that the spring framework itself will actually create the

364
00:27:41.400 --> 00:27:46.710
instances of many of these types of very important classes behind the scenes.

365
00:27:46.740 --> 00:27:51.940
So you won't even see the code that's calling new people repository, for example.

366
00:27:52.410 --> 00:27:59.640
And then you can just tell the framework where you want to use that instance and it will inject the

367
00:27:59.640 --> 00:28:02.190
instance into your class somewhere.

368
00:28:02.370 --> 00:28:08.580
So, for example, just as a really quick sneak preview here, if we wanted to have a new instance of

369
00:28:08.580 --> 00:28:15.840
the people repository in our unit, test and use it just like this right here, what you might see instead

370
00:28:15.840 --> 00:28:22.980
of this is some type of annotation where you are specifying to the spring framework, for example,

371
00:28:23.190 --> 00:28:30.870
to please inject a new instance of the people repository into this variable right here that would be

372
00:28:30.870 --> 00:28:37.560
equivalent to having some code somewhere that says create a new people repository and set the repo variable

373
00:28:37.560 --> 00:28:38.550
equal to that.

374
00:28:38.940 --> 00:28:45.690
Now, the reason that frameworks like the spring framework prefer to do it in this way is so that the

375
00:28:45.690 --> 00:28:51.570
framework can manage all of the dependencies that your key classes depend on.

376
00:28:51.750 --> 00:28:57.570
So, for example, the people repository class here depends on having a connection.

377
00:28:57.750 --> 00:29:04.080
Now, I decided to create this class in this way intentionally to prepare you a little bit for when

378
00:29:04.080 --> 00:29:05.430
we learn about spring.

379
00:29:05.640 --> 00:29:09.390
So here is a small example of dependency injection.

380
00:29:09.540 --> 00:29:15.870
We are, in effect, injecting the connection instance into our people repository.

381
00:29:16.140 --> 00:29:22.160
We could have created this thing, this connection directly inside of the people repository class.

382
00:29:22.170 --> 00:29:23.820
We absolutely could have done that.

383
00:29:24.180 --> 00:29:31.470
But instead, I chose for us to created outside of the class and then injected because the spring framework

384
00:29:31.470 --> 00:29:33.570
would have done a very similar thing for us.

385
00:29:33.840 --> 00:29:36.450
So you'll likely see more of that very soon.

386
00:29:36.630 --> 00:29:38.880
Just giving you a little bit of a preview there.

387
00:29:39.180 --> 00:29:46.800
Oh, and then one last thing that I wanted to mention to you about our database connections being created,

388
00:29:46.800 --> 00:29:55.350
and you may recall that our test here is actually using transactions with the database to, in effect,

389
00:29:55.350 --> 00:29:58.710
erase whatever data changes we are making to the.

390
00:29:58.760 --> 00:30:01.570
Database while the tests are running, right?

391
00:30:01.720 --> 00:30:07.960
And so that's what allows us to keep rerunning these tests over and over and over again and not permanently

392
00:30:07.960 --> 00:30:11.080
affect the subsequent tests that are running.

393
00:30:11.300 --> 00:30:18.430
So for example, if we put two people into the database permanently without cleaning up after ourselves

394
00:30:18.670 --> 00:30:24.970
on each test, some of these tests wouldn't work correctly anymore because they make assumptions as

395
00:30:24.970 --> 00:30:31.390
to what data exists in the database before the test runs and what data will be there after the assertion

396
00:30:31.390 --> 00:30:32.500
or things like that.

397
00:30:32.740 --> 00:30:40.090
And so if you'll recall, we set this connection that set out to commit to false to just turn off the

398
00:30:40.090 --> 00:30:47.560
default behavior of the connection, which is to permanently commit whatever changes we're making to

399
00:30:47.560 --> 00:30:51.520
the records in the tables of our database, right?

400
00:30:51.790 --> 00:30:56.680
We turn that off by default, and at the end of each test, we happen to be closing the connection.

401
00:30:56.800 --> 00:31:01.030
Now, let me tell you one thing right now I could have actually included this when I was talking about

402
00:31:01.030 --> 00:31:03.520
optimizations, but I'll just mention it very briefly here.

403
00:31:03.730 --> 00:31:08.080
There's actually an even more efficient thing that we probably could have done here.

404
00:31:08.320 --> 00:31:11.230
I just, for whatever reason, didn't choose to do it this way.

405
00:31:11.230 --> 00:31:15.340
But currently we're using this before each and after each.

406
00:31:15.340 --> 00:31:22.000
And if you'll recall this before each annotated method and after each method run right before each test

407
00:31:22.000 --> 00:31:23.470
and right after each test, right?

408
00:31:23.470 --> 00:31:28.600
So we get a before and before each and then this happens and then the after each and then that that's

409
00:31:28.600 --> 00:31:32.830
done and then it happens again for this test and that test and for each of these tests, right?

410
00:31:32.980 --> 00:31:40.090
Well, and recall, now that we're creating a connection, a new connection now in our before each method,

411
00:31:40.210 --> 00:31:45.250
which means that we're getting a new connection for each and every one of these tests that actually

412
00:31:45.250 --> 00:31:48.370
isn't necessary to do, that's actually a little wasteful.

413
00:31:48.610 --> 00:31:52.540
What we could have done Alternatively, though, we will not do it now, but I will leave it to you

414
00:31:52.540 --> 00:31:53.380
as an exercise.

415
00:31:53.380 --> 00:31:55.300
If you would like to try, it is.

416
00:31:55.300 --> 00:32:00.970
We could have used, alternatively, an app before all method to create our connection.

417
00:32:01.150 --> 00:32:05.290
And then we'd only create one connection for all of the tests to run.

418
00:32:05.770 --> 00:32:09.850
And then we could use an, after all, to tear it down as well.

419
00:32:10.210 --> 00:32:16.550
And then we could also just use an after each method to simply roll back.

420
00:32:16.570 --> 00:32:19.770
So let me even show you real quick what that would look like, I suppose.

421
00:32:19.780 --> 00:32:25.180
So instead of before each, we could do it before all and then instead of an after each, we could do

422
00:32:25.180 --> 00:32:33.040
and after all, and then we could introduce one more method here now, which would be another after

423
00:32:33.070 --> 00:32:33.850
each.

424
00:32:35.710 --> 00:32:39.610
And I don't know what I'll call this real after each for right now.

425
00:32:40.360 --> 00:32:40.690
OK.

426
00:32:40.720 --> 00:32:45.640
And then in here, what we could do now is call connection dot rollback.

427
00:32:45.670 --> 00:32:50.330
OK, now that's going to throw an exception because, you know, it's database stuff.

428
00:32:50.330 --> 00:32:51.820
So I'll just do that for right now.

429
00:32:52.060 --> 00:32:58.450
And so now with this approach, what would happen is we'd only create a connection one time for all

430
00:32:58.450 --> 00:33:03.130
of the tests, and we'd only close the connection one time for all of the tests.

431
00:33:03.460 --> 00:33:10.540
But after each test was done, dirtying up the database with our test data or whatever.

432
00:33:10.720 --> 00:33:18.130
We would roll back, which means to just basically erase, erase whatever changes had been made to the

433
00:33:18.130 --> 00:33:23.360
database tables since the last time we called roll back essentially OK.

434
00:33:23.650 --> 00:33:28.280
So that would in many ways be a more efficient way that we could have done this.

435
00:33:28.300 --> 00:33:32.740
Now one thing I'll mention here is that if you wanted to do it this way, even though I'm not getting

436
00:33:32.740 --> 00:33:37.660
errors here, this won't work on its own because I would need to make the set up method and the tear

437
00:33:37.660 --> 00:33:39.310
down method static.

438
00:33:39.340 --> 00:33:39.650
OK?

439
00:33:39.670 --> 00:33:42.010
They'd have to be static with with this approach.

440
00:33:42.160 --> 00:33:45.190
And that would mean that the connection also has to be static.

441
00:33:45.190 --> 00:33:49.540
So I'm just giving a little warning there that a few things would need to change to make that all work,

442
00:33:49.540 --> 00:33:54.880
but that would, in theory, make the running of our tests a little more efficient.

443
00:33:54.910 --> 00:33:55.360
OK.

444
00:33:55.390 --> 00:33:55.780
All right.

445
00:33:55.900 --> 00:33:57.010
So that's it.

446
00:33:57.460 --> 00:33:58.240
I am done.

447
00:33:58.420 --> 00:34:04.680
Let's get out of this module and get on to bigger and better things in the next module.

448
00:34:04.690 --> 00:34:07.060
So I hope you've learned a whole lot in this module.

449
00:34:07.240 --> 00:34:11.470
Please make sure that you really take it to heart everything that we've learned here because this is

450
00:34:11.470 --> 00:34:12.520
just great stuff.

451
00:34:12.730 --> 00:34:17.410
And plus, we also got a chance to incorporate so many of the other things we've learned throughout

452
00:34:17.410 --> 00:34:20.260
the throughout the course into this module, right?

453
00:34:20.440 --> 00:34:25.750
And so this is huge and a lot of the code that we've written here represents pretty much real world

454
00:34:25.750 --> 00:34:26.500
type code.

455
00:34:26.690 --> 00:34:28.180
We went fairly deep here.

456
00:34:28.210 --> 00:34:28.540
OK.

457
00:34:28.690 --> 00:34:29.020
All right.

458
00:34:29.030 --> 00:34:32.020
So take it easy and I will see you in the next one.
