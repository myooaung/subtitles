WEBVTT
1
00:00:00.600 --> 00:00:08.880
All right, so now we're going to have a dedicated lesson and learn how to use the contains method of

2
00:00:08.880 --> 00:00:15.690
the list interface and actually the contains method, to be honest, isn't a an exclusive member of

3
00:00:15.690 --> 00:00:20.640
the list interface, it's actually a member of the collection.

4
00:00:20.790 --> 00:00:24.260
Interface list actually extends from collection.

5
00:00:24.270 --> 00:00:25.830
Let me show you that real quick, in fact.

6
00:00:26.070 --> 00:00:33.150
So if I do a command, oh, and I can go to the list interface, which is under Java dot util.

7
00:00:33.150 --> 00:00:34.110
So we'll go here.

8
00:00:34.890 --> 00:00:35.910
And here we are.

9
00:00:35.920 --> 00:00:38.340
So it's a public interface list.

10
00:00:38.580 --> 00:00:42.330
It uses some generics here so that we can specify what the data type is.

11
00:00:43.020 --> 00:00:47.970
But as you see here, this interface of list actually extends collection.

12
00:00:48.160 --> 00:00:59.340
OK, and the contains method here actually is is inherited, if you will, from the collection interface

13
00:00:59.340 --> 00:01:02.710
itself that's indicated by this little up arrow here.

14
00:01:02.730 --> 00:01:12.330
So if you think of the inheritance of both classes and interfaces as being like this inheritance tree,

15
00:01:12.330 --> 00:01:18.810
right, then the superclass or in this case, the super interface of list is kind of up above.

16
00:01:18.810 --> 00:01:22.170
And so that's why they showed this little arrow pointing up.

17
00:01:22.500 --> 00:01:31.170
OK, so they're saying this method contains is actually being overridden is actually overriding the

18
00:01:31.170 --> 00:01:37.080
inherited method from the collection class and so we can actually jump into that guy.

19
00:01:38.210 --> 00:01:45.230
And now we're in the collection interface, and it has a method defined on it which is contained.

20
00:01:45.270 --> 00:01:52.190
OK, so anyway, contains is inherited ultimately from the collection interface.

21
00:01:52.850 --> 00:01:53.190
All right.

22
00:01:53.210 --> 00:01:57.020
So anyway, let's close these and jump back over here.

23
00:01:57.050 --> 00:02:06.290
OK, so now we'll dive in to how the containers method actually can be utilized, and you'll see in

24
00:02:06.290 --> 00:02:09.050
a moment here why it needs its own lesson, OK?

25
00:02:09.230 --> 00:02:11.330
There's actually a little more going on to it.

26
00:02:11.540 --> 00:02:15.320
But let's start off with with a simple exercise.

27
00:02:15.620 --> 00:02:18.650
So we've got all of these people here, right?

28
00:02:18.650 --> 00:02:19.820
These employees.

29
00:02:20.120 --> 00:02:30.620
And so first thing we can do is just, let's just pull one person out of the let's see out of this collection

30
00:02:30.620 --> 00:02:36.980
here and then ask the collection if that person is contained in the in the collection.

31
00:02:36.980 --> 00:02:40.190
OK, so if that's not clear, let me just show you what I mean.

32
00:02:41.030 --> 00:02:42.790
Let me see, do we want to keep removing these?

33
00:02:42.800 --> 00:02:48.350
I don't think we even need to be removing these anymore, so let's just not do that.

34
00:02:48.620 --> 00:02:54.590
OK, so we'll take our collection of employees and we'll just get a random employee out.

35
00:02:54.600 --> 00:03:00.080
Let's just do the sixth one, which is index five and then we'll capture that employee.

36
00:03:02.000 --> 00:03:04.640
And I don't even know who that is, but.

37
00:03:05.680 --> 00:03:08.330
My employee, that's what I will name it.

38
00:03:08.350 --> 00:03:08.800
OK.

39
00:03:09.190 --> 00:03:16.990
And then I will turn around and we'll just print out whether or not that employee is indeed contained

40
00:03:16.990 --> 00:03:19.770
in the employees list, right?

41
00:03:19.780 --> 00:03:23.680
So we'll do a system that out and then we'll say employees.

42
00:03:24.490 --> 00:03:27.730
Dot contains my employees.

43
00:03:27.740 --> 00:03:34.870
So in other words, does the employee's list or collection contain this employee?

44
00:03:34.930 --> 00:03:36.020
Obviously, it will.

45
00:03:36.040 --> 00:03:36.400
Right?

46
00:03:36.700 --> 00:03:42.220
And just to keep it really simple, let's I'm just going to I'm just going to select everything else

47
00:03:42.220 --> 00:03:47.770
to the bottom of this method, and I'm going to comment it out so that none of that will run.

48
00:03:48.100 --> 00:03:53.180
And that way, we can run this code really easily and just see just this little focus bit.

49
00:03:53.200 --> 00:03:55.000
So I'm going to go ahead and run this now.

50
00:03:57.070 --> 00:03:59.800
OK, and as we expect, it is true.

51
00:04:00.130 --> 00:04:01.890
So, yeah, that makes sense, right?

52
00:04:01.900 --> 00:04:06.910
It's an object that really, truly is in that list and therefore it should come back with true.

53
00:04:07.780 --> 00:04:08.620
All right.

54
00:04:08.890 --> 00:04:14.110
Now let's try something a little more interesting, perhaps.

55
00:04:14.530 --> 00:04:17.440
Let's kind of sort of create an employee from scratch.

56
00:04:17.620 --> 00:04:19.880
But based on one of these?

57
00:04:19.900 --> 00:04:20.320
OK.

58
00:04:20.500 --> 00:04:22.630
And so here's how I think we'll do this.

59
00:04:23.680 --> 00:04:34.300
Let's use the employee that create employee method here employee create employee method and will pass

60
00:04:34.300 --> 00:04:37.000
in one of these existing strings.

61
00:04:37.030 --> 00:04:43.630
OK, I'm going to pass in this programmer right here.

62
00:04:47.320 --> 00:04:53.710
So we'll just paste that in like so OK, and then we'll capture that.

63
00:04:55.480 --> 00:04:56.040
That's fine.

64
00:04:56.050 --> 00:04:59.020
Yeah, we'll take that default name and let me let's get some more room here.

65
00:04:59.050 --> 00:04:59.410
OK.

66
00:04:59.620 --> 00:05:00.770
So does this make sense?

67
00:05:00.770 --> 00:05:07.240
So we're using this this method here to create employee more passing in the string, because that's

68
00:05:07.240 --> 00:05:08.500
what that method takes.

69
00:05:08.500 --> 00:05:13.120
And then it'll figure out, you know, it'll go through the all the code that we've been working on

70
00:05:13.120 --> 00:05:18.130
forever now where it will see that this is a programmer and therefore it needs to create an instance

71
00:05:18.130 --> 00:05:24.940
of a programmer and then initialize it with all of this information and then spit that out over here.

72
00:05:25.180 --> 00:05:25.540
Right.

73
00:05:26.020 --> 00:05:27.700
So that's what we should have here.

74
00:05:28.120 --> 00:05:28.630
All right.

75
00:05:29.140 --> 00:05:38.600
So then if we were to turn around and do the same thing we just did a moment ago, employee's oops in

76
00:05:38.950 --> 00:05:45.670
Ployees Dot contains employee one.

77
00:05:46.240 --> 00:05:50.900
What do you expect we will get here because this is identical?

78
00:05:50.920 --> 00:05:51.290
Right?

79
00:05:51.310 --> 00:05:59.530
All of the identical information as what we have for this person right here, and we're no longer removing

80
00:05:59.530 --> 00:06:04.150
people from the collection, so there's no chance for any of that kind of thing to go wrong.

81
00:06:04.420 --> 00:06:04.750
All right.

82
00:06:04.760 --> 00:06:05.920
So let's run this.

83
00:06:05.920 --> 00:06:08.500
So we've still got this one here, which we know is true.

84
00:06:08.710 --> 00:06:10.360
And now we've got this one as well.

85
00:06:10.360 --> 00:06:13.330
Let's run it, OK?

86
00:06:13.360 --> 00:06:14.770
Look at what we got now.

87
00:06:15.220 --> 00:06:23.590
So we got true for our original test here, right where we pulled one employee out of the list and then

88
00:06:23.590 --> 00:06:28.240
said, Hey, is this person who is in that list contained in that list?

89
00:06:28.240 --> 00:06:30.790
And of course, you get it true for that, as you would expect.

90
00:06:31.090 --> 00:06:33.760
However, this one is a little more interesting.

91
00:06:34.840 --> 00:06:44.710
In this case, we duplicated essentially an employee verbatim, you know, using the parameters right,

92
00:06:44.710 --> 00:06:49.300
using the data parameters that are already being used up here, right?

93
00:06:49.930 --> 00:06:51.700
Let me close that.

94
00:06:52.570 --> 00:06:57.010
So we we duplicated one of the employees that we know is in that list.

95
00:06:58.150 --> 00:07:05.290
But then when we asked if that employee who was a duplicate is contained in the list, we get back a

96
00:07:05.290 --> 00:07:05.950
false.

97
00:07:06.880 --> 00:07:14.410
And this brings us to a whole line of interesting things to learn what is going on with this contains

98
00:07:14.410 --> 00:07:14.950
method.

99
00:07:15.220 --> 00:07:25.210
Why is this employee not showing as being contained in this list, even though it's identical to one

100
00:07:25.210 --> 00:07:26.740
that we know is in that list?

101
00:07:26.890 --> 00:07:27.400
And you know it.

102
00:07:27.400 --> 00:07:29.440
In fact, let's just prove this.

103
00:07:30.040 --> 00:07:31.630
So let's see.

104
00:07:31.630 --> 00:07:33.840
I chose Flintstone five.

105
00:07:33.850 --> 00:07:34.720
Let's just make sure.

106
00:07:34.730 --> 00:07:38.380
So this would be index zero one two three four five.

107
00:07:38.410 --> 00:07:38.710
Right?

108
00:07:38.920 --> 00:07:39.190
Yeah.

109
00:07:39.220 --> 00:07:41.650
So that's yeah, that's this person right here.

110
00:07:41.950 --> 00:07:53.740
So, yeah, so this employee five or this person here is a perfect duplicate of this one.

111
00:07:54.100 --> 00:07:57.730
And yet the contains method says he doesn't exist.

112
00:07:58.270 --> 00:08:04.870
Well, to understand this, let's first take a look at the Java Dock for the containers method and see

113
00:08:04.870 --> 00:08:07.370
what it says about how it works.

114
00:08:07.390 --> 00:08:07.810
OK.

115
00:08:08.140 --> 00:08:09.940
So I'll just hover on it.

116
00:08:10.060 --> 00:08:12.850
We'll see that this method returns true.

117
00:08:12.850 --> 00:08:22.840
If this list contains the specified element more formally, it returns true if and only if this list

118
00:08:22.840 --> 00:08:30.730
contains at least one element e such that objects dot equals o comma e.

119
00:08:30.770 --> 00:08:41.080
Now this object equals is kind of like a utility method on a class called objects, and what it does

120
00:08:41.080 --> 00:08:42.400
is kind of interesting.

121
00:08:42.400 --> 00:08:49.720
So actually, let's jump into the objects that equals method so that we can see what this is doing because

122
00:08:49.720 --> 00:08:52.120
that's what this is actually relying on.

123
00:08:52.150 --> 00:08:52.450
All right.

124
00:08:52.460 --> 00:09:01.120
So if I do a command o and type in objects that will take us to the object's class and then we can look

125
00:09:01.120 --> 00:09:02.670
at this equals method here.

126
00:09:02.680 --> 00:09:10.090
So the equals method here returns true if the arguments are equal to each other and false otherwise.

127
00:09:10.090 --> 00:09:17.920
Consequently, if both arguments are null, true or is determined otherwise, if the first argument

128
00:09:17.920 --> 00:09:25.120
is not null, equality is determined by calling the equals method of the first argument with the second

129
00:09:25.120 --> 00:09:26.690
argument of this method.

130
00:09:26.710 --> 00:09:28.450
Otherwise false returns.

131
00:09:28.450 --> 00:09:34.200
So I'm going to simplify that and get down to the crux.

132
00:09:34.210 --> 00:09:42.040
OK, the crux of what that is basically saying for our intents and purposes right now is it's going

133
00:09:42.040 --> 00:09:46.830
to call the inherited equals method of of an object.

134
00:09:46.980 --> 00:09:51.400
To determine if that object is equal to another object.

135
00:09:51.420 --> 00:09:52.980
OK, that's the bottom line.

136
00:09:53.220 --> 00:09:54.750
And so what's happening here?

137
00:09:54.780 --> 00:09:56.430
Let me close this.

138
00:09:57.090 --> 00:09:59.430
So let me explain what's actually happening here.

139
00:09:59.670 --> 00:10:01.020
Close that down as well.

140
00:10:02.280 --> 00:10:09.750
So this newly created employee, one object, basically what contains does is it will take this newly

141
00:10:10.020 --> 00:10:18.420
created employee, one object, which is a perfect duplicate of of this object that came out of the

142
00:10:18.420 --> 00:10:19.110
list, right?

143
00:10:19.770 --> 00:10:27.720
It's going to take that object and it's going to compare it to each and every one of these objects in

144
00:10:27.750 --> 00:10:28.900
the list.

145
00:10:28.920 --> 00:10:29.380
OK.

146
00:10:29.820 --> 00:10:39.000
And it's going to do that by calling the equals method of each of these elements in the collection.

147
00:10:39.030 --> 00:10:48.570
OK, so the equals method is the key here to what determines whether or not to objects are considered

148
00:10:48.570 --> 00:10:51.120
to be equivalent to each other.

149
00:10:51.150 --> 00:10:51.630
OK.

150
00:10:51.930 --> 00:11:00.420
And what's actually happening here that that's causing us to get a false is that when the compare method

151
00:11:00.780 --> 00:11:04.110
is comparing this object?

152
00:11:05.580 --> 00:11:09.990
Using its equals method to.

153
00:11:11.910 --> 00:11:13.170
This object.

154
00:11:14.220 --> 00:11:20.550
The equals method is returning a false and so we need to dig in to what is this equals method all about

155
00:11:20.550 --> 00:11:23.610
and how does it work and can we do anything about this?

156
00:11:23.730 --> 00:11:31.590
Because what we really would expect is that these two objects should be considered to be equal to each

157
00:11:31.590 --> 00:11:31.980
other.

158
00:11:32.070 --> 00:11:32.490
OK.

159
00:11:32.610 --> 00:11:33.510
And you know what?

160
00:11:33.540 --> 00:11:36.510
Let me even show you one more example here real quick.

161
00:11:36.510 --> 00:11:40.020
So I'll do one more system that out and I'll cut to the chase.

162
00:11:40.230 --> 00:11:48.270
What what the what the contains method is actually really doing here is it is ultimately taking this

163
00:11:48.630 --> 00:11:54.000
my employee and it's calling equals and then it's passing in employee one.

164
00:11:55.290 --> 00:11:56.820
That's what it's actually doing.

165
00:11:56.820 --> 00:12:01.260
And so if we run this, this also will return a false.

166
00:12:03.110 --> 00:12:03.660
There we go.

167
00:12:03.680 --> 00:12:11.330
So there's the third output there, and that's also false, and we really weren't expecting that we

168
00:12:11.330 --> 00:12:13.400
would expect that it would return true.

169
00:12:14.450 --> 00:12:18.860
So we need to figure out how can we make it so that it would return a true right?

170
00:12:19.310 --> 00:12:19.560
All right.

171
00:12:19.580 --> 00:12:20.480
So a couple of things.

172
00:12:20.510 --> 00:12:25.790
So this equals method is an inherited method from the object class.

173
00:12:25.940 --> 00:12:33.890
And as I've stated before, all classes in Java ultimately extend from the original superclass called

174
00:12:33.890 --> 00:12:34.640
object.

175
00:12:34.730 --> 00:12:35.180
OK.

176
00:12:35.540 --> 00:12:41.030
And the object class has honored a number of methods.

177
00:12:41.570 --> 00:12:43.880
It has the two string method on it.

178
00:12:44.180 --> 00:12:50.960
It also has the equals method, and it also has an a method called hash code, which we will also look

179
00:12:50.960 --> 00:12:51.980
at a little later.

180
00:12:52.550 --> 00:13:01.100
The equals methods intent is to allow us to do exactly what we're doing here on Line 48 to compare two

181
00:13:01.460 --> 00:13:04.400
objects to determine if they are equal.

182
00:13:04.880 --> 00:13:13.100
However, the default way that the equals method does this is not always what we might expect.

183
00:13:13.680 --> 00:13:23.480
So if I were to create a process programmer and I'm not going to fill in the the bit there, right?

184
00:13:23.480 --> 00:13:30.320
But if I were to create a programmer and then I stored a reference to it in a variable, and I'll just

185
00:13:30.320 --> 00:13:31.940
call this p one for now.

186
00:13:32.300 --> 00:13:40.820
What that's really doing is it's going to tell Java at runtime to go find some unused memory in the

187
00:13:40.820 --> 00:13:49.790
computer and then go build an instance of a programmer in that memory location and then take the address

188
00:13:49.790 --> 00:13:55.340
of that memory location and stored in this variable essentially, right?

189
00:13:55.700 --> 00:14:01.610
That's and this is all this should all just be review form from many, many, many, many lessons ago,

190
00:14:01.610 --> 00:14:01.900
right?

191
00:14:01.910 --> 00:14:03.890
So that's basically what we're saying here.

192
00:14:04.250 --> 00:14:09.050
Now, if I were to create a second one and I'll name it P2.

193
00:14:10.490 --> 00:14:14.870
And then I did pick one that equals P two.

194
00:14:15.950 --> 00:14:16.400
OK.

195
00:14:16.880 --> 00:14:24.920
This line fifty two would be basically asking something about the equality of P one and P two.

196
00:14:25.220 --> 00:14:31.970
Now, since this programmer class is a class that I have written and I have not supplied it with my

197
00:14:32.000 --> 00:14:34.820
own implementation of an equals method.

198
00:14:35.090 --> 00:14:42.860
It is currently using the default inherited implementation of the equals method inherited by the ultimate

199
00:14:42.860 --> 00:14:44.610
super class of object.

200
00:14:44.630 --> 00:14:45.020
OK.

201
00:14:45.350 --> 00:14:55.730
And so the default implementation of equals method is to simply compare whether or not P one and P two

202
00:14:55.760 --> 00:15:00.510
are both pointing to the same address in memory.

203
00:15:00.530 --> 00:15:00.890
OK.

204
00:15:00.920 --> 00:15:04.550
That's the default implementation of the equals method.

205
00:15:04.790 --> 00:15:12.450
It is actually equivalent to doing P one equals equals P two, in fact.

206
00:15:12.470 --> 00:15:12.920
OK.

207
00:15:13.040 --> 00:15:23.120
If you will recall the equals operator, this thing here really tests for whether or not two references

208
00:15:23.120 --> 00:15:31.760
to object references point to the same address in memory, which would mean that they are effectively

209
00:15:31.760 --> 00:15:33.320
the same object, right?

210
00:15:35.190 --> 00:15:39.360
And so that is the default implementation of the equals method as well.

211
00:15:39.870 --> 00:15:42.570
However, you might not want that.

212
00:15:43.080 --> 00:15:50.400
And this is a perfect example of where you may not want that type of behavior because when we ask is

213
00:15:50.410 --> 00:16:00.900
P1 equal to P2, what we usually actually mean is are the intrinsic and usually unchangeable properties

214
00:16:00.900 --> 00:16:03.810
of P1 and P2 the same.

215
00:16:04.230 --> 00:16:12.540
That's a different question than to ask whether or not P1 and P2 point to the same object in memory.

216
00:16:12.750 --> 00:16:15.000
There's an interesting distinction here.

217
00:16:15.030 --> 00:16:15.540
OK.

218
00:16:15.780 --> 00:16:21.150
And it's one that can be a little confusing for some developers, especially when you're getting started

219
00:16:21.150 --> 00:16:21.990
as a developer.

220
00:16:22.440 --> 00:16:25.020
But here's the perfect example right here.

221
00:16:25.110 --> 00:16:35.670
So what's happening is that this my employee here is taking up space at a particular address in memory.

222
00:16:36.000 --> 00:16:44.400
But then down here on line 45, we're creating a brand new object which is automatically going to exist

223
00:16:44.400 --> 00:16:47.380
in a different location in memory.

224
00:16:47.400 --> 00:16:47.910
OK.

225
00:16:48.450 --> 00:16:54.150
Because ultimately, if we jump in here, you'll you'll recall that ultimately we're using the new operator

226
00:16:54.150 --> 00:16:56.370
here to create these instances, right?

227
00:16:56.490 --> 00:16:59.880
And so you're going to get a new object automatically.

228
00:17:00.690 --> 00:17:01.020
OK?

229
00:17:01.080 --> 00:17:02.400
With with this approach.

230
00:17:03.240 --> 00:17:12.060
And so if we have not overridden the equals method of our programmer class, then we are going to get

231
00:17:12.060 --> 00:17:18.570
the default implementation of equals, which will simply ask the question of whether or not the two

232
00:17:18.570 --> 00:17:23.550
objects are both pointing to the same address in memory.

233
00:17:23.700 --> 00:17:29.190
And they cannot be pointing to the same address in memory because there are two different objects and

234
00:17:29.190 --> 00:17:31.350
therefore you instantly get a false.

235
00:17:31.590 --> 00:17:32.010
OK.

236
00:17:32.190 --> 00:17:33.780
That's why we're getting a false.

237
00:17:34.110 --> 00:17:42.870
Now, if we want to fix this problem, we have to supply our own custom implementation of the equals

238
00:17:42.870 --> 00:17:48.720
method for that class and then we can do whatever we like.

239
00:17:49.170 --> 00:17:56.250
So what what we might prefer to do is to have our custom equals method.

240
00:17:56.250 --> 00:18:01.050
Compare the first name, last name and date of birth or whatever, right?

241
00:18:01.380 --> 00:18:08.340
And say, like, OK, who cares whether or not these two objects are at the same memory location?

242
00:18:08.340 --> 00:18:14.190
What I want to know is if they both have the same last name and they both have the same first name and

243
00:18:14.190 --> 00:18:19.830
they both have the same date of birth and whatever other fields that you feel are important here to

244
00:18:19.830 --> 00:18:23.550
determine whether or not you're referring to the same person or not.

245
00:18:23.820 --> 00:18:24.150
Right?

246
00:18:24.600 --> 00:18:26.460
Then compare all of those things.

247
00:18:26.460 --> 00:18:32.850
And if those things are all equal, then yeah, these two objects are equal to each other, regardless

248
00:18:32.850 --> 00:18:36.750
of whether or not they're in different locations in memory.

249
00:18:36.990 --> 00:18:38.790
That's what we need to do.

250
00:18:38.850 --> 00:18:39.390
OK.

251
00:18:40.710 --> 00:18:45.750
And if we do that, then the contains method will be able to find a match.

252
00:18:46.560 --> 00:18:48.330
So that's what we're going to do.

253
00:18:48.360 --> 00:18:53.040
We're going to implement our own custom equals method.

254
00:18:53.130 --> 00:18:53.580
OK.

255
00:18:54.930 --> 00:19:02.040
So to do that, the first thing we really want to do is to consider, OK, well, what do we want to

256
00:19:02.040 --> 00:19:11.130
actually constitute equality between two objects, especially between two programmers or two employees

257
00:19:11.130 --> 00:19:12.110
or whatever, right?

258
00:19:12.240 --> 00:19:14.790
What constitutes equality here?

259
00:19:15.780 --> 00:19:17.520
So let's look at that for a moment.

260
00:19:18.900 --> 00:19:26.490
So the fields that we've got here are the last name, first name, date of birth, the role.

261
00:19:27.060 --> 00:19:31.170
And then we've got the role specific properties as well.

262
00:19:31.350 --> 00:19:33.000
Lines of code per day.

263
00:19:34.290 --> 00:19:36.470
Years of experience and IQ.

264
00:19:36.480 --> 00:19:44.070
So we've got to ask ourselves a question what belongs in here in order to determine whether or not to

265
00:19:44.070 --> 00:19:48.030
employees are equivalent equivalent to each other?

266
00:19:48.090 --> 00:19:50.940
Really, what you're asking is, are they the same person, right?

267
00:19:52.400 --> 00:19:58.820
So I think it's pretty obvious that at the very least, we'd want the last name, first name and date

268
00:19:58.820 --> 00:20:00.370
of birth, for sure.

269
00:20:00.380 --> 00:20:01.910
I think we want those three.

270
00:20:02.030 --> 00:20:03.200
Wouldn't you agree?

271
00:20:03.920 --> 00:20:09.680
Now the other question would be what about the role and this other stuff?

272
00:20:09.860 --> 00:20:12.750
So let's let's consider a scenario here.

273
00:20:13.340 --> 00:20:21.080
If a company hired Fred five Flintstone five, let's call him Fred Flintstone for four for ease right

274
00:20:21.080 --> 00:20:22.040
now, OK?

275
00:20:22.370 --> 00:20:25.010
Born 19 January 1st.

276
00:20:26.380 --> 00:20:32.410
And and let's say that Fred, this Fred Flintstone is on a few different lists.

277
00:20:32.650 --> 00:20:33.880
I don't mean programming list.

278
00:20:33.880 --> 00:20:35.870
I mean actual lists at the company.

279
00:20:35.890 --> 00:20:36.310
OK.

280
00:20:36.460 --> 00:20:42.670
For various query, for various reasons, he's on various lists and we just want to compare and make

281
00:20:42.670 --> 00:20:43.060
sure.

282
00:20:43.480 --> 00:20:46.750
Is this Fred Flintstone who was on this list over here?

283
00:20:47.410 --> 00:20:50.080
The same Fred Flintstone who who's on this list here?

284
00:20:50.080 --> 00:20:56.080
So maybe one list is a list of all the programmers in the company, and maybe another list is all of

285
00:20:56.080 --> 00:21:01.690
the people who volunteered last year to help out the company or something.

286
00:21:01.720 --> 00:21:07.000
OK, and we just want to reconcile these two lists and make sure we're talking about the same people

287
00:21:07.720 --> 00:21:08.770
where applicable.

288
00:21:09.780 --> 00:21:17.400
So we know that we want to start off by defining equality with last name, first name and date of birth,

289
00:21:17.520 --> 00:21:17.910
right?

290
00:21:18.300 --> 00:21:20.170
But then we get to programmer.

291
00:21:20.730 --> 00:21:26.190
Now is that something that we should add to our test of equality?

292
00:21:26.670 --> 00:21:32.760
So here's a scenario what if Fred Flintstone used to be?

293
00:21:33.730 --> 00:21:37.450
Not a programmer, what if he used to be an analyst?

294
00:21:37.570 --> 00:21:38.830
A few years ago?

295
00:21:39.520 --> 00:21:40.020
OK.

296
00:21:40.900 --> 00:21:44.170
But then later on, he became a programmer.

297
00:21:44.950 --> 00:21:47.080
Is that still the same Fred Flintstone?

298
00:21:47.620 --> 00:21:48.360
I would argue.

299
00:21:48.370 --> 00:21:50.650
Yeah, that's still the same Fred Flintstone.

300
00:21:50.660 --> 00:21:51.880
He used to be an analyst.

301
00:21:51.890 --> 00:21:54.640
Now he's a programmer, but he's still the same person.

302
00:21:54.670 --> 00:21:55.060
Right?

303
00:21:55.450 --> 00:22:05.170
So maybe we might not want to include the role in the test for equality, because that is something

304
00:22:05.170 --> 00:22:06.640
that could change.

305
00:22:06.790 --> 00:22:07.210
Right?

306
00:22:08.020 --> 00:22:13.630
And then the same goes for these other properties here that are programmers specific lines of code per

307
00:22:13.630 --> 00:22:14.020
day.

308
00:22:14.170 --> 00:22:18.640
That metric could change day by day, year by year, whatever, right?

309
00:22:19.030 --> 00:22:27.310
So just because Fred Fred Flintstone was coding five lines of code per day last year, maybe now he

310
00:22:27.310 --> 00:22:29.140
codes 10 lines of code per day.

311
00:22:29.140 --> 00:22:31.020
That doesn't mean he's a different person, right?

312
00:22:31.030 --> 00:22:32.260
He's the same person.

313
00:22:32.260 --> 00:22:35.260
He's just, you know, coding more lines of code.

314
00:22:35.560 --> 00:22:35.920
Right?

315
00:22:36.040 --> 00:22:36.640
Same thing.

316
00:22:36.640 --> 00:22:39.920
For years of experience, obviously, that's going to change every year.

317
00:22:39.940 --> 00:22:40.300
Right?

318
00:22:40.840 --> 00:22:42.940
Last year, you only had 10 years of experience.

319
00:22:43.180 --> 00:22:48.190
This year he has 11 years, for example, IQ.

320
00:22:48.640 --> 00:22:49.270
I don't know.

321
00:22:49.660 --> 00:22:53.680
That probably is going to fluctuate every time someone takes an IQ test.

322
00:22:53.980 --> 00:23:01.270
So definitely you're not a different person just because your IQ results are different each time you

323
00:23:01.270 --> 00:23:02.230
take the test.

324
00:23:02.260 --> 00:23:02.590
Right?

325
00:23:03.040 --> 00:23:12.190
So this gets us to a point that I that's really important to understand when we are deciding on what

326
00:23:12.190 --> 00:23:17.830
fields to include in in determining equality of objects.

327
00:23:18.970 --> 00:23:26.330
We may want to be really careful to pick fields that are not very likely to change in many cases.

328
00:23:26.350 --> 00:23:32.620
Now you may have some very specific reason why you want to include the program or other things, and

329
00:23:32.620 --> 00:23:34.990
I can't project what those reasons would be.

330
00:23:35.260 --> 00:23:40.780
But maybe even the bigger point that I want to make here is that you need to think this through a little

331
00:23:40.780 --> 00:23:41.680
bit, OK?

332
00:23:41.980 --> 00:23:48.250
Don't just automatically pick all fields just because they're they all exist, right?

333
00:23:48.520 --> 00:23:53.110
You need to know why you're picking those fields and what are the ramifications of doing so.

334
00:23:53.560 --> 00:24:00.670
And if you don't know how to think that through very well, then maybe play it safe initially and just

335
00:24:00.670 --> 00:24:04.450
pick the fields that are the least likely to ever change, right?

336
00:24:04.840 --> 00:24:11.020
Last name, first name and date of birth are probably the least likely fields to change out of these

337
00:24:11.290 --> 00:24:12.880
out of all of these fields.

338
00:24:12.910 --> 00:24:20.350
OK, so that's the first thing you probably want to do now that we know that much.

339
00:24:20.830 --> 00:24:24.730
Now we can jump over to where these fields are.

340
00:24:24.940 --> 00:24:30.340
So first, let's jump over to the programmer class itself, and we'll jump to the top because it's at

341
00:24:30.340 --> 00:24:32.680
the top where we usually have all of our fields.

342
00:24:32.860 --> 00:24:38.020
Now, if you'll recall, we don't actually store any of those pertinent fields first name, last name

343
00:24:38.020 --> 00:24:44.590
or date of birth directly on the programmer class or any of these subclasses, for that matter, because

344
00:24:44.590 --> 00:24:47.440
they're all common to employee.

345
00:24:47.470 --> 00:24:47.800
Right?

346
00:24:48.160 --> 00:24:52.170
And so these are actually fields that exist on the employee class.

347
00:24:52.180 --> 00:24:53.830
So let's jump over to there.

348
00:24:54.370 --> 00:25:00.580
And now we see that we've this is where we've got the last name, first name and date of birth, right?

349
00:25:00.880 --> 00:25:09.490
So we probably want to be overwriting the equals method here to start off with.

350
00:25:11.320 --> 00:25:19.180
And I will usually put these boilerplate type methods more towards the bottom of my class, as we did

351
00:25:19.180 --> 00:25:24.910
with the two string method, which is another one of the overridden inherited methods from the superclass

352
00:25:24.910 --> 00:25:25.990
of object, right?

353
00:25:26.320 --> 00:25:34.780
So what's nice is if I put my if I put my cursor here and make a couple of spaces, maybe I can do a

354
00:25:34.780 --> 00:25:42.610
command in four new or two to tell the ABC I want to generate a new method and then I can go down here

355
00:25:42.610 --> 00:25:46.930
to equals and hash code OK and press return.

356
00:25:47.380 --> 00:25:54.250
Now I'm presented with some options and I will explain what these options are real quick.

357
00:25:54.820 --> 00:25:58.530
Now we're not going to concern ourselves too much with hash code right now.

358
00:25:58.540 --> 00:26:06.990
But as of Java version seven, Java comes with this utility class called Objets SE with the plural right,

359
00:26:07.000 --> 00:26:13.960
not the not the superclass of object, which is singular, but objects with an s on the end.

360
00:26:14.230 --> 00:26:21.340
It comes with this utility class that has these utility methods on it that help us to implement some

361
00:26:21.340 --> 00:26:25.570
of these methods, such as equals and hash code, a little more easily.

362
00:26:25.750 --> 00:26:31.590
And so if as long as you're using version Java seven or higher, you have access to this.

363
00:26:31.600 --> 00:26:39.820
And so it's asking, do I want the ADP to help generate an equals and hash code method utilizing the

364
00:26:39.820 --> 00:26:43.600
objects that equals in hash code methods here?

365
00:26:43.720 --> 00:26:46.810
And yeah, I think that's not a bad idea, OK?

366
00:26:47.050 --> 00:26:53.620
It is possible to create some very poor implementations of equals and hash code, especially hash code.

367
00:26:53.800 --> 00:26:58.090
And so unless you really, really, really, really know what you're doing and almost nobody does.

368
00:26:58.420 --> 00:27:00.310
I think this is not a bad way to go.

369
00:27:00.790 --> 00:27:01.090
All right.

370
00:27:01.120 --> 00:27:04.060
So, yeah, I would leave that set that way.

371
00:27:04.540 --> 00:27:11.140
Then also, it asks, do we want to accept subclasses as a parameter to equals method?

372
00:27:12.070 --> 00:27:18.130
I will talk a little bit more about what this means, but for now, you can go ahead and leave that

373
00:27:18.130 --> 00:27:19.000
selected.

374
00:27:19.060 --> 00:27:19.600
OK.

375
00:27:19.930 --> 00:27:22.990
And I will leave this last option unchecked.

376
00:27:23.320 --> 00:27:23.620
OK.

377
00:27:24.040 --> 00:27:25.570
And so click next.

378
00:27:25.780 --> 00:27:32.080
And now what it's doing is it's asking what fields do we want to actually include in our definition

379
00:27:32.080 --> 00:27:32.650
of equals?

380
00:27:32.650 --> 00:27:35.020
Or, in other words, what fields should we use?

381
00:27:35.230 --> 00:27:37.090
And so that's what we were just talking about.

382
00:27:37.090 --> 00:27:40.330
Do we want to use the role of programmer, for example?

383
00:27:40.330 --> 00:27:44.920
And the answer is no, we probably don't want to use that because that's something that could change

384
00:27:44.920 --> 00:27:46.090
right now.

385
00:27:46.450 --> 00:27:51.400
The employee class has more fields on it than just the last name, first name and date of birth, right?

386
00:27:51.400 --> 00:27:54.790
We've got the people matter in the money format or in all of these things.

387
00:27:54.820 --> 00:28:00.240
These fields have nothing to do with what a person is, right?

388
00:28:00.580 --> 00:28:04.950
These are not true data of a person.

389
00:28:04.960 --> 00:28:07.660
And so we don't want to include these fields.

390
00:28:07.660 --> 00:28:12.970
And that's another reason why we need to think about this a little bit and not just select whatever

391
00:28:12.970 --> 00:28:13.930
happens to be there.

392
00:28:13.930 --> 00:28:15.460
That would be a huge mistake.

393
00:28:15.610 --> 00:28:22.150
So I'm going to uncheck the date time format or the money format and the people matter as well.

394
00:28:22.150 --> 00:28:23.650
I don't want any of those.

395
00:28:23.920 --> 00:28:26.680
We just want the last name, first name and date of birth.

396
00:28:26.710 --> 00:28:32.780
Those are actual real world properties of a person or an employee.

397
00:28:32.800 --> 00:28:33.310
OK.

398
00:28:33.940 --> 00:28:35.050
So keep that in mind.

399
00:28:35.050 --> 00:28:43.210
You want the the meaningful fields or properties of whatever your class type may be that you have modeled.

400
00:28:43.750 --> 00:28:44.190
All right.

401
00:28:44.200 --> 00:28:45.820
So now I will click next.

402
00:28:46.510 --> 00:28:50.790
And now it's asking me, what fields do I want for the hash code method?

403
00:28:50.790 --> 00:28:57.670
And I'm not going to talk much about hash code right now, but it's very, very, very similar in use

404
00:28:57.670 --> 00:29:00.200
and importance to the equals method.

405
00:29:00.220 --> 00:29:00.620
OK.

406
00:29:00.640 --> 00:29:06.370
And so generally speaking, whatever fields you're using for your equals method, you want to use those

407
00:29:06.370 --> 00:29:09.310
same fields for the hash code method as well.

408
00:29:09.340 --> 00:29:09.790
OK.

409
00:29:10.150 --> 00:29:13.750
So I will leave all of those selected and click next again.

410
00:29:14.110 --> 00:29:18.180
And finally, it's asking me to select all non null fields.

411
00:29:18.190 --> 00:29:26.500
Now, this is interesting if you're selecting fields that are capable of being null, especially in

412
00:29:26.500 --> 00:29:28.450
this case, the last name and first name.

413
00:29:28.450 --> 00:29:36.040
That could be problematic because we already identified that we probably don't want to be defining our

414
00:29:36.040 --> 00:29:41.500
equals method or hash code for that matter, with properties that can change.

415
00:29:41.680 --> 00:29:47.620
So the role, for example, that could change and possibly in some contexts, maybe it could change

416
00:29:47.620 --> 00:29:50.440
from not having been set to being set to something else, right?

417
00:29:50.650 --> 00:29:56.470
In this case, maybe it's possible to create an object without even specifying the last name, first

418
00:29:56.470 --> 00:29:57.490
name or date of birth.

419
00:29:57.640 --> 00:30:03.310
That would be very problematic, because that would mean that your equals in hash code methods in this

420
00:30:03.310 --> 00:30:07.630
case could change as well, and that that's almost never a good thing.

421
00:30:08.770 --> 00:30:09.610
And so.

422
00:30:11.540 --> 00:30:15.560
I would actually go ahead and specify that these cannot be null.

423
00:30:15.830 --> 00:30:21.950
And I'll talk a little bit in a moment about how we want to just make sure that we enforce this using

424
00:30:21.950 --> 00:30:23.480
our constructors, right?

425
00:30:24.410 --> 00:30:26.300
So I'm going to go ahead and select these.

426
00:30:26.510 --> 00:30:32.120
So in general, the fields that you're selecting for the equals and hash code ideally cannot be null.

427
00:30:32.150 --> 00:30:32.630
OK?

428
00:30:32.660 --> 00:30:39.980
In fact, ideally, maybe you shouldn't even be allowed to create instances of that object without those

429
00:30:39.980 --> 00:30:43.550
fields being initialized that at the time of creation.

430
00:30:43.580 --> 00:30:44.000
OK.

431
00:30:44.450 --> 00:30:44.780
All right.

432
00:30:44.810 --> 00:30:46.640
And now I will click finish.

433
00:30:47.240 --> 00:30:54.920
And so what happens now is that the idea has generated an equals method that's overwriting the inherited

434
00:30:54.920 --> 00:31:00.880
equals method, the one that just compares two objects to say, do they point to the same memory location?

435
00:31:00.890 --> 00:31:08.180
And now I have a more proper equals method that doesn't just compare same memory location, it actually

436
00:31:08.180 --> 00:31:11.210
is going to compare those individual fields now.

437
00:31:11.240 --> 00:31:11.660
OK?

438
00:31:12.020 --> 00:31:15.110
And so let's run through this and really understand what it's doing.

439
00:31:15.500 --> 00:31:23.990
So the first thing it says is if this object on which this equals method exists equals using the equals

440
00:31:23.990 --> 00:31:31.250
operator, which means points to the same memory location as this object that's being passed in to the

441
00:31:31.250 --> 00:31:32.180
equals method.

442
00:31:32.630 --> 00:31:40.100
So in other words, if this object is at the same location, memory location as this other object,

443
00:31:40.100 --> 00:31:43.070
if they are pointing to the same thing, then definitely they are.

444
00:31:43.610 --> 00:31:44.870
They are equal, right?

445
00:31:45.050 --> 00:31:46.100
For sure, they're equal.

446
00:31:46.430 --> 00:31:53.380
The the problem is, if they don't point to the same memory location, they might also still be equal,

447
00:31:53.390 --> 00:31:53.740
right?

448
00:31:55.490 --> 00:32:01.550
So if they are pointing to the same memory location, return a true you don't even need to test anything

449
00:32:01.550 --> 00:32:04.340
more because that's the same object being compared to itself.

450
00:32:04.730 --> 00:32:05.000
All right.

451
00:32:05.000 --> 00:32:06.350
So that's the first test.

452
00:32:06.680 --> 00:32:16.130
The second test says if this other object that's being passed in for equality testing is not even of

453
00:32:16.130 --> 00:32:19.610
the same type as this object that I'm in here.

454
00:32:19.610 --> 00:32:21.740
So we're in the employee class, right?

455
00:32:21.740 --> 00:32:29.300
So we're saying if the object be your object in this case is not of the same type, using the instance

456
00:32:29.300 --> 00:32:35.360
of operator here, right, is not of the same type as this object here.

457
00:32:35.870 --> 00:32:38.510
Then automatically, that's a fail, right?

458
00:32:38.660 --> 00:32:40.520
They got to be the same type, right?

459
00:32:41.210 --> 00:32:48.380
And so if we got past this test and this test, well, now we know that they're the same type.

460
00:32:48.590 --> 00:32:56.030
And so now we can cast this oh to something of of the same type specifically because here we're just

461
00:32:56.060 --> 00:32:57.410
allowing for object.

462
00:32:57.650 --> 00:33:03.710
And that's just because it needs to be super flexible and that is the signature of the equals method

463
00:33:03.710 --> 00:33:04.830
that is being inherited.

464
00:33:04.850 --> 00:33:09.200
OK, so we can't change the signature because then you're not overriding the equals method.

465
00:33:09.200 --> 00:33:14.780
You're creating your own equals method, which won't have any bearing on what we need to do and won't

466
00:33:14.780 --> 00:33:17.000
be utilized by the container method.

467
00:33:17.000 --> 00:33:23.780
The contained method only knows to look for the inherited equals method with this exact signature.

468
00:33:24.200 --> 00:33:31.190
All right, so now we can cast this generic object into a specific type of employee.

469
00:33:31.280 --> 00:33:37.380
We need to do that so that we can drill in now and start actually grabbing data out of its fields.

470
00:33:37.400 --> 00:33:37.700
Right?

471
00:33:37.730 --> 00:33:40.040
You wouldn't be able to do that as an object.

472
00:33:40.730 --> 00:33:47.990
So now the last thing that happens is we start comparing the important fields, the fields that we decided

473
00:33:47.990 --> 00:33:52.340
would be important, such as the last name, first name and date of birth.

474
00:33:52.550 --> 00:33:59.480
And so now we're simply delegating down to the inherited equals method of these individual properties.

475
00:33:59.690 --> 00:34:06.830
Now this is OK to do because at this level, in this particular case, we're just drilling down to the

476
00:34:06.830 --> 00:34:09.650
more fundamental data types such as string.

477
00:34:09.890 --> 00:34:17.030
So for string, we don't need to supply an equals method here because the implementation of equals four

478
00:34:17.030 --> 00:34:19.350
string already does the right thing OK.

479
00:34:19.370 --> 00:34:23.330
It doesn't use the the inherited default implementation.

480
00:34:23.330 --> 00:34:26.960
It has a more meaningful and smarter implementation of equals.

481
00:34:27.230 --> 00:34:28.550
So we can trust this one.

482
00:34:29.270 --> 00:34:30.890
And so it's just comparing last name.

483
00:34:31.040 --> 00:34:31.880
Are those equal?

484
00:34:31.940 --> 00:34:37.850
If they are and if the first things are equal and if the dates of birth are equal, then the whole entire

485
00:34:37.850 --> 00:34:40.010
thing is equal and you're good to go.

486
00:34:40.130 --> 00:34:42.140
And so that's what gets returned here.

487
00:34:42.200 --> 00:34:42.620
OK.

488
00:34:42.980 --> 00:34:47.780
So I know that's kind of a lot to go through, but that's why it's actually really nice to just let

489
00:34:47.780 --> 00:34:50.990
the ADP generate this equals method for us.

490
00:34:51.590 --> 00:34:52.040
All right.

491
00:34:52.340 --> 00:35:00.140
So now that we have all of that, if we go back to the main class.

492
00:35:02.140 --> 00:35:04.600
All right, so if we come back over here now.

493
00:35:05.050 --> 00:35:10.120
So now back in the main class, let me, I think I'm going to just delete these.

494
00:35:12.410 --> 00:35:14.750
And now we can rerun this.

495
00:35:15.680 --> 00:35:16.940
And now let's see what we get.

496
00:35:18.480 --> 00:35:20.730
Hey, look at that now.

497
00:35:20.970 --> 00:35:27.210
Everything is true, so we just needed to implement the equals method here.

498
00:35:28.110 --> 00:35:36.300
So as a quick reminder, the contains method takes the object that is passed into it.

499
00:35:37.140 --> 00:35:46.770
And what it does is it simply iterate through each object in the collection, calling that objects equals

500
00:35:46.770 --> 00:35:50.880
method, which would look just like this.

501
00:35:51.630 --> 00:35:54.420
In fact, it does exactly this.

502
00:35:56.190 --> 00:36:02.640
It calls the equals method, and it simply says, Does this object or this object?

503
00:36:03.840 --> 00:36:04.650
Equal.

504
00:36:05.640 --> 00:36:11.550
Whatever current object I'm pointing at in my iterations here, right?

505
00:36:12.500 --> 00:36:18.860
And if it finds a match, so to speak, then the contains method returns a true.

506
00:36:19.280 --> 00:36:23.480
And if it does not find a match, then it returns a false.

507
00:36:23.900 --> 00:36:24.380
OK.

508
00:36:24.620 --> 00:36:26.480
That's all the contains method does.

509
00:36:26.490 --> 00:36:31.580
So really, the method that's doing all the heavy lifting on this contains method here is actually the

510
00:36:31.580 --> 00:36:32.360
equals method.

511
00:36:32.360 --> 00:36:39.230
And in fact, we could even jump into an actual implementation of the contains method and confirm that's

512
00:36:39.230 --> 00:36:40.490
exactly what it's doing.

513
00:36:40.670 --> 00:36:49.040
So if I put my cursor on contains and then do a command Option B, I have to pick a class that implements

514
00:36:49.040 --> 00:36:50.090
the contained method.

515
00:36:50.090 --> 00:36:54.170
So all these classes here are actually implementing the contains method.

516
00:36:54.410 --> 00:36:58.670
Let's just go for the one that we're actually using, which is on ArrayList itself.

517
00:36:58.970 --> 00:37:04.850
And so what this is actually doing is it's relying on the index of method and passing in the subjects

518
00:37:04.850 --> 00:37:12.050
of the index of method, if you may recall, says, if this object is contained inside of this collection,

519
00:37:12.260 --> 00:37:15.500
give me the index of that object.

520
00:37:15.510 --> 00:37:24.110
So if we jump into this guy then and it uses an index of range which will kind of check our list, look

521
00:37:24.110 --> 00:37:26.000
for the index in a range.

522
00:37:26.000 --> 00:37:29.230
And so if we jump into this one, here we go.

523
00:37:29.240 --> 00:37:33.920
That's starting to look a little convoluted, but the bottom line here is right down here.

524
00:37:33.920 --> 00:37:35.180
Here's a loop.

525
00:37:35.240 --> 00:37:43.670
OK, so we're looping through all of the items that are in the internal array of this array list and

526
00:37:43.670 --> 00:37:47.150
we're calling the equals method here, right?

527
00:37:47.960 --> 00:37:51.200
So we're just saying, is this equal to that?

528
00:37:51.200 --> 00:37:53.120
And that's the bottom line right there.

529
00:37:53.300 --> 00:37:58.250
This equals method, and that's why we have to implement the equals method if we want that to actually

530
00:37:58.250 --> 00:37:58.760
work.

531
00:37:59.420 --> 00:37:59.720
All right.

532
00:37:59.730 --> 00:38:05.900
Sorry for the convolution there, but I thought it might be kind of cool to see how the sausage is made.

533
00:38:06.050 --> 00:38:10.610
For those of you who live in an English speaking country and know that expression.

534
00:38:11.330 --> 00:38:17.480
All right, so I'm going to wrap this up, but I just want to recap a couple of really key points.

535
00:38:17.780 --> 00:38:26.030
So there are a few methods that are going to rely on us having implemented equals and or the hash code

536
00:38:26.030 --> 00:38:27.410
methods properly.

537
00:38:27.830 --> 00:38:31.730
Some of those methods are obviously contains let's just look through here.

538
00:38:31.730 --> 00:38:41.300
Real quick contains all that's also going to require a good implementation of equals index of uses equals

539
00:38:41.300 --> 00:38:41.660
as well.

540
00:38:41.670 --> 00:38:46.820
That's how it finds right, because it's using that for loop looping to all the elements and then just

541
00:38:46.820 --> 00:38:47.980
calling equals right.

542
00:38:47.990 --> 00:38:54.440
So you've got to have a proper implementation of equals for index of to work properly as well.

543
00:38:54.710 --> 00:38:57.080
Last index of this pretty much the same thing.

544
00:38:57.770 --> 00:39:01.820
Remove the version of the removed method that takes an object.

545
00:39:01.970 --> 00:39:03.440
Same thing again, right?

546
00:39:03.680 --> 00:39:09.610
How will it know if the object that you're passing in here matches one of the objects in the list?

547
00:39:09.620 --> 00:39:11.900
It's going to call the equals method?

548
00:39:11.930 --> 00:39:12.350
OK?

549
00:39:12.530 --> 00:39:17.900
So any of these methods that involve kind of comparing, Hey, you're passing in an object and then

550
00:39:17.900 --> 00:39:24.440
you're expecting that method to kind of know whether or not the object you passed in matches, any of

551
00:39:24.440 --> 00:39:30.050
the objects that are already inside of the collection, any of those kinds of methods are going to require

552
00:39:30.050 --> 00:39:36.500
you to have a proper implementation of the equals and or hash code methods.

553
00:39:36.530 --> 00:39:36.980
OK.

554
00:39:37.790 --> 00:39:39.830
So remove, remove all.

555
00:39:40.510 --> 00:39:40.830
All right.

556
00:39:40.850 --> 00:39:45.860
And that might be about all of them for lists, at least.

557
00:39:45.890 --> 00:39:46.310
OK.

558
00:39:46.760 --> 00:39:49.640
So super important lesson to know.

559
00:39:50.330 --> 00:39:57.430
Oh, and then let me also just be clear in our example here we're creating a programmer, right?

560
00:39:57.440 --> 00:39:58.940
And we're comparing programmers.

561
00:39:59.270 --> 00:40:06.110
I added the equals method, though not on the programmer class, but on the employee class, because

562
00:40:06.350 --> 00:40:09.950
our equals method is based on first name, last name and date of birth.

563
00:40:10.160 --> 00:40:16.070
And therefore what what's happening is that the programmer class and all of the other employee subclasses

564
00:40:16.070 --> 00:40:21.670
are inheriting now the equals method that exists purely on the employee class.

565
00:40:21.680 --> 00:40:22.610
So that's kind of cool.

566
00:40:22.790 --> 00:40:31.130
Now, if I had wanted to also include other fields that are more specific to the programmer, let me

567
00:40:31.130 --> 00:40:33.350
show you what that would look like really quickly.

568
00:40:33.650 --> 00:40:37.560
So I'm going to jump into the programmer class.

569
00:40:37.940 --> 00:40:39.170
I'll just do it this way.

570
00:40:40.280 --> 00:40:40.670
All right.

571
00:40:41.000 --> 00:40:47.830
So what I could do, let's say that I wanted to include IQ for equality of a programmer.

572
00:40:47.840 --> 00:40:54.380
OK, so I can generate a custom equals method for just the programmer class going to the bottom and

573
00:40:54.380 --> 00:40:58.580
doing a command in and then equals in hash code and enter.

574
00:40:58.880 --> 00:40:59.120
All right.

575
00:40:59.120 --> 00:41:03.080
So I'll just accept all the same settings that I did before.

576
00:41:03.230 --> 00:41:04.130
Click Next.

577
00:41:05.030 --> 00:41:07.880
And again, it's going to ask me what fields I'm carrying about.

578
00:41:08.000 --> 00:41:10.160
So let's say I only care about the IQ.

579
00:41:10.370 --> 00:41:11.930
OK, so I'm going to.

580
00:41:12.070 --> 00:41:14.130
You select everything else.

581
00:41:14.230 --> 00:41:14.770
All right.

582
00:41:14.950 --> 00:41:19.480
And then I can click next, and that's good for hash code.

583
00:41:20.650 --> 00:41:21.130
All right.

584
00:41:21.310 --> 00:41:29.440
And so just as before, I get this nice generated method for me and it does all the same things that

585
00:41:29.440 --> 00:41:30.880
we saw before, right?

586
00:41:31.030 --> 00:41:36.700
Except it's also delegating up to the superclass equal.

587
00:41:36.710 --> 00:41:40.720
So this is the equals method that we just generated on the superclass.

588
00:41:40.730 --> 00:41:43.210
That's why we're calling SuperDart equals here.

589
00:41:43.330 --> 00:41:48.970
And so this is going to give it a chance to also compare the first name, last name and date of birth

590
00:41:49.300 --> 00:41:49.900
first.

591
00:41:49.930 --> 00:41:50.350
Right.

592
00:41:50.890 --> 00:41:53.860
We need that because we're overwriting the equals method.

593
00:41:53.860 --> 00:42:01.510
So we want to still get all of that other functionality of the equals method in the superclass now that

594
00:42:01.510 --> 00:42:03.250
we're overwriting the equals method.

595
00:42:03.550 --> 00:42:03.970
OK.

596
00:42:04.870 --> 00:42:12.700
And then after all of that is equal, then we also can additionally compare that the accused are equal

597
00:42:12.700 --> 00:42:13.480
to each other.

598
00:42:13.510 --> 00:42:19.650
OK, so that's how we could add in yet another field in a subclass or other fields.

599
00:42:19.660 --> 00:42:25.150
I could have selected all of the pertinent fields on this class as well.

600
00:42:25.180 --> 00:42:25.690
OK.

601
00:42:26.800 --> 00:42:34.150
So in fact, if we jump back over to the main class and run this one more time, I'll just show you

602
00:42:34.150 --> 00:42:38.170
something very quickly and then we'll we'll end this lesson.

603
00:42:39.280 --> 00:42:41.710
OK, so still, everything's true, right?

604
00:42:41.980 --> 00:42:48.700
However, now that I've added an IQ, if I change this IQ just by one.

605
00:42:49.510 --> 00:42:49.990
OK.

606
00:42:50.410 --> 00:42:53.620
So yeah, it's 100 up there, right?

607
00:42:53.830 --> 00:42:56.860
But now it's 101 here, and I run this again.

608
00:42:58.090 --> 00:42:59.890
I think, you know what's going to happen?

609
00:43:00.400 --> 00:43:03.570
Look at that false false, right?

610
00:43:03.580 --> 00:43:07.300
Because now I've added IQ in the definition of equality.

611
00:43:07.330 --> 00:43:12.910
OK, so now it's actually looking at that IQ to help determine whether or not the two objects are equal

612
00:43:13.480 --> 00:43:19.180
before I had added in the overridden equals method on the programmer class.

613
00:43:19.330 --> 00:43:23.560
If I had changed this, it wouldn't have mattered because it wasn't being looked at.

614
00:43:23.650 --> 00:43:26.800
It was only looking at the last name, first name and date of birth.

615
00:43:26.890 --> 00:43:34.180
But now that I've added IQ into the programmers overridden implementation of equals, now the IQ actually

616
00:43:34.180 --> 00:43:34.760
matters.

617
00:43:34.790 --> 00:43:35.110
Right?

618
00:43:35.380 --> 00:43:40.720
And so now I'm getting a fall, so I hope that kind of helps to show some of the interesting things

619
00:43:40.720 --> 00:43:42.580
that we have to consider here.

620
00:43:43.090 --> 00:43:43.510
All right.

621
00:43:43.810 --> 00:43:49.210
Now I'm going to wrap this up and we will look at a few more really important topics like this one in

622
00:43:49.210 --> 00:43:49.720
the next.

623
00:43:49.930 --> 00:43:50.620
I'll see you there.
