1
00:00:00,150 --> 00:00:07,260
All right, so now that we have worked out all of the parsing in the most procedural way possible,

2
00:00:07,290 --> 00:00:11,040
let's now explore some object oriented solutions.

3
00:00:11,040 --> 00:00:18,030
We can maybe try applying to this and see what the various approaches in the object oriented realm may

4
00:00:18,030 --> 00:00:18,660
look like.

5
00:00:19,020 --> 00:00:25,890
So looking at our data here, so we've got all these people right, all these employees of different

6
00:00:25,890 --> 00:00:26,850
types, right?

7
00:00:27,210 --> 00:00:36,270
And so one of the first approaches that I can think of that we could try doing to make this a little

8
00:00:36,270 --> 00:00:40,290
more object oriented is to actually introduce some classes in here.

9
00:00:40,380 --> 00:00:44,790
I can think of a couple of approaches with classes right off the bat, but one I think I'm going to

10
00:00:44,790 --> 00:00:45,630
skip right over.

11
00:00:45,870 --> 00:00:53,700
So one is that we could just create a class called employee and then somehow create and initialize a

12
00:00:53,700 --> 00:00:56,260
bunch of employees for each of these lines.

13
00:00:56,280 --> 00:01:00,970
But I'm not confident that that's going to bring us all that much value.

14
00:01:01,010 --> 00:01:08,760
And so I'm sort of inclined to skip past that and do one step beyond that, which would be to actually

15
00:01:08,760 --> 00:01:17,280
introduce one two three four, I guess four classes, one class per role, essentially.

16
00:01:17,430 --> 00:01:24,180
Now let me explain some of my thinking here when we did the first implementation of this program, where

17
00:01:24,210 --> 00:01:31,170
all we were doing was just determining a salary based on the role and nothing else.

18
00:01:31,450 --> 00:01:31,700
Right.

19
00:01:31,710 --> 00:01:34,050
We didn't have we didn't have all of this.

20
00:01:34,410 --> 00:01:37,610
We only had the role in that case.

21
00:01:37,620 --> 00:01:42,690
I'm not even sure that doing much of an object oriented approach would have would have paid us much

22
00:01:42,890 --> 00:01:44,040
at that point.

23
00:01:44,130 --> 00:01:45,720
Things were so simple, right?

24
00:01:45,900 --> 00:01:49,950
And all we were doing was basically saying, if it's a programmer, it's this much.

25
00:01:49,950 --> 00:01:52,560
If it's a manager, it's this much right now.

26
00:01:52,590 --> 00:01:59,310
When we introduced these details here and the fact that the details can be different per role and the

27
00:01:59,310 --> 00:02:06,960
fact that the algorithm for D for calculating salary with the details is different per role.

28
00:02:07,500 --> 00:02:15,330
That's when it maybe starts to make more sense to look at having different classes per role because

29
00:02:15,480 --> 00:02:17,670
we've got different behavior.

30
00:02:17,910 --> 00:02:24,030
Well, because we have different implementation details in some of the behavior, right?

31
00:02:24,040 --> 00:02:30,210
And in other words, the way that we calculate salary for a programmer is totally different from the

32
00:02:30,210 --> 00:02:35,170
way that we calculate salary for a manager or an analyst or a CEO.

33
00:02:35,250 --> 00:02:35,640
OK.

34
00:02:36,000 --> 00:02:43,470
And those are some, some clues that maybe at least we should explore what doing this in an object oriented

35
00:02:43,470 --> 00:02:45,090
approach might look like.

36
00:02:45,150 --> 00:02:47,610
OK, so let's let's try that.

37
00:02:47,610 --> 00:02:53,460
So let's just create four classes, and we'll just call them programmer, manager, analyst and CEO.

38
00:02:53,790 --> 00:02:54,230
All right.

39
00:02:55,680 --> 00:03:02,070
So I'm opening up my project pain here, and I'm going to throw those classes, I guess just in here

40
00:03:02,190 --> 00:03:05,190
in the calm neutrino SIS employees package.

41
00:03:07,040 --> 00:03:10,080
Java class programmer.

42
00:03:10,850 --> 00:03:14,020
And maybe I'll go ahead and just create them all all at once here.

43
00:03:14,030 --> 00:03:19,330
So programmer and then we need a manager, Java class manager.

44
00:03:20,300 --> 00:03:27,350
And we need a an analyst, Java class analyst.

45
00:03:29,260 --> 00:03:31,240
And then we need a CEO.

46
00:03:32,330 --> 00:03:37,460
Now you'll see some programmers call this class like, which is an acronym.

47
00:03:38,090 --> 00:03:39,080
Maybe they'll do that.

48
00:03:39,680 --> 00:03:41,080
That doesn't feel good to me.

49
00:03:41,090 --> 00:03:43,370
I think that feels a little better to me.

50
00:03:43,370 --> 00:03:43,970
All caps.

51
00:03:44,210 --> 00:03:46,230
I'm not telling you you have to do it that way.

52
00:03:46,250 --> 00:03:48,230
You'll see programmers do it both ways.

53
00:03:48,430 --> 00:03:51,740
But maybe this feels a little better to me, at least in this case.

54
00:03:51,740 --> 00:03:54,650
So I'm going for all caps with my acronym.

55
00:03:55,550 --> 00:03:56,060
All right.

56
00:03:57,170 --> 00:04:02,930
All right, so there's our CEO, OK, now that we have these classes, what are we going to do with

57
00:04:02,930 --> 00:04:03,290
them?

58
00:04:04,010 --> 00:04:11,720
Well, so the first thing I'm thinking is I want code to create instances of these new four data types

59
00:04:11,720 --> 00:04:19,340
that we have these new four classes that we have and initialize them with all of the pertinent information,

60
00:04:19,340 --> 00:04:19,580
right?

61
00:04:19,580 --> 00:04:21,320
All of the pertinent data.

62
00:04:21,440 --> 00:04:30,320
So, you know, we've got the the first name, last name, the date of birth and and now we won't we

63
00:04:30,320 --> 00:04:39,370
won't even really need a field for the role because that is inherent in the actual data type itself,

64
00:04:39,380 --> 00:04:39,710
right?

65
00:04:40,040 --> 00:04:41,150
So let's see here.

66
00:04:41,930 --> 00:04:49,130
So here's our code where we loop over each of the people, right and we do a bunch of stuff.

67
00:04:50,120 --> 00:04:50,450
Right.

68
00:04:50,480 --> 00:04:50,730
Who?

69
00:04:50,840 --> 00:04:52,280
A whole bunch of stuff.

70
00:04:52,490 --> 00:04:53,600
A lot of stuff there.

71
00:04:54,110 --> 00:05:06,110
So maybe what we can do first off is simply instantiate each of these data types according to whatever

72
00:05:06,110 --> 00:05:07,070
the role is.

73
00:05:07,310 --> 00:05:11,150
So maybe something like this inside of the case statement there.

74
00:05:11,540 --> 00:05:16,280
Maybe we do something like programmer.

75
00:05:20,310 --> 00:05:21,720
Equals new.

76
00:05:23,380 --> 00:05:24,310
Programmer.

77
00:05:25,690 --> 00:05:30,700
Now here's the big question, what do we what do we do with the constructor for it?

78
00:05:32,140 --> 00:05:43,810
What I'm kind of leaning towards is maybe we simply pass in the entire string for one employee and then

79
00:05:43,810 --> 00:05:47,980
we maybe allow code inside of the class to do its own parsing.

80
00:05:48,370 --> 00:05:56,620
And what I like about this is that once we do this, maybe this main program here doesn't need to know

81
00:05:56,620 --> 00:06:01,810
the internal details of how to properly pass a person anymore.

82
00:06:02,050 --> 00:06:05,050
And therefore, maybe the code can get a little simpler.

83
00:06:05,110 --> 00:06:06,880
So let me show you what I mean by that.

84
00:06:06,970 --> 00:06:12,940
So here we are pretending like we've got this constructor, which we have not created yet, and I think

85
00:06:12,940 --> 00:06:15,760
I just want to pass in that whole entire line.

86
00:06:16,150 --> 00:06:18,520
So let's see here.

87
00:06:19,450 --> 00:06:28,630
So we could access the entire line of text for the one employee with people.

88
00:06:28,630 --> 00:06:31,690
Matt Dot Group.

89
00:06:33,220 --> 00:06:42,670
So calling a matchers group with no input there that should access the entire line.

90
00:06:43,090 --> 00:06:44,790
OK, the whole entire thing.

91
00:06:47,920 --> 00:06:52,690
Now we're getting the Red Squiggly Line because we haven't actually created this constructor yet, a

92
00:06:52,690 --> 00:06:55,360
constructor that essentially takes a string, right?

93
00:06:55,390 --> 00:07:02,350
So if I put my cursor right here and do an option return, then the ID gives me the option to create

94
00:07:02,350 --> 00:07:04,930
the constructor, which I am good with.

95
00:07:05,260 --> 00:07:11,620
Yes, I want that to be a string and I don't know what I'm going to call this.

96
00:07:11,800 --> 00:07:15,880
Maybe just person text for now.

97
00:07:16,220 --> 00:07:17,080
Yep, there we go.

98
00:07:17,230 --> 00:07:17,740
All right.

99
00:07:17,860 --> 00:07:19,600
Now what do we do with that?

100
00:07:20,350 --> 00:07:23,290
Well, let's come up here and see.

101
00:07:23,300 --> 00:07:29,050
So we know we've got a last name, first name, date of birth roll is implied.

102
00:07:29,980 --> 00:07:30,670
Then we've got all this.

103
00:07:30,670 --> 00:07:32,140
So let's start with these fields here.

104
00:07:32,140 --> 00:07:38,170
Let's just model these fields with these first three fields, at least on the programmer.

105
00:07:38,290 --> 00:07:38,740
OK.

106
00:07:39,760 --> 00:07:40,060
All right.

107
00:07:40,090 --> 00:07:45,040
So let's throw the private string last name.

108
00:07:46,270 --> 00:07:51,610
And then a private string first name, and then we had a date of birth.

109
00:07:51,640 --> 00:07:56,050
Now many of you might have been inclined and I know many programs.

110
00:07:56,050 --> 00:08:01,150
In fact, I don't know if I'll say most programmers, but a heck of a lot, at least 40 percent, if

111
00:08:01,150 --> 00:08:02,290
not 50 or more.

112
00:08:02,350 --> 00:08:06,910
Let's go back over to the main thing here would possibly without even thinking.

113
00:08:07,120 --> 00:08:11,740
Think of modeling this date of birth as a string.

114
00:08:12,640 --> 00:08:20,230
So I don't remember if I've already said this, but when we are modeling, it is highly advisable that

115
00:08:20,230 --> 00:08:28,720
you use data types that most closely resemble the actual type of data that you are modeling.

116
00:08:28,930 --> 00:08:33,040
So in this case, we'd be modeling a field that represents a date of birth.

117
00:08:33,520 --> 00:08:35,290
The key word there is date.

118
00:08:35,830 --> 00:08:36,310
OK.

119
00:08:36,610 --> 00:08:44,620
So while we certainly could just grab that as a string and store it as a string and model it as a string,

120
00:08:44,620 --> 00:08:51,760
we would be missing out on a lot of power that we can have when we actually convert this string into

121
00:08:51,760 --> 00:08:56,890
a proper date by converting it into an actual date field of some sort.

122
00:08:57,130 --> 00:08:59,690
We then can do date math on it.

123
00:08:59,710 --> 00:09:06,040
You know, if we need to calculate or determine how old this person is, that's trivial to do with the

124
00:09:06,100 --> 00:09:08,610
date types that are built into Java.

125
00:09:08,620 --> 00:09:14,080
Whereas if we leave this as a string, it's a big headache and a big hassle and you miss out on a lot

126
00:09:14,080 --> 00:09:17,260
of the semantic meaning of these data.

127
00:09:17,290 --> 00:09:17,710
OK.

128
00:09:17,980 --> 00:09:23,110
So let's model the date of birth as an actual proper date.

129
00:09:23,680 --> 00:09:24,010
All right.

130
00:09:24,020 --> 00:09:31,120
So we'll come over here and we'll say private and we'll make this a local date.

131
00:09:31,660 --> 00:09:35,050
Notice I just type L.D in my I.D. figures.

132
00:09:35,320 --> 00:09:38,140
You must be talking about some class that it starts with an L. A..

133
00:09:38,170 --> 00:09:39,450
Yes, I am local date.

134
00:09:39,460 --> 00:09:42,880
I can just hit return and that gets imported automatically.

135
00:09:43,660 --> 00:09:46,690
And for now, I'll just call that filled Yobe.

136
00:09:47,470 --> 00:09:48,940
And we've done this pattern before.

137
00:09:48,940 --> 00:09:50,200
So you're familiar with it.

138
00:09:50,230 --> 00:09:51,190
All right.

139
00:09:52,030 --> 00:09:55,780
Now, do we need to go ahead and implement something here?

140
00:09:55,810 --> 00:09:57,160
I'm thinking, Yeah, we do.

141
00:09:57,160 --> 00:09:59,620
We probably want to go ahead and pass this out.

142
00:10:00,010 --> 00:10:03,130
So if we jump back over to the main class here.

143
00:10:04,510 --> 00:10:07,000
So we're already parsing this right.

144
00:10:07,030 --> 00:10:08,350
We're already doing that.

145
00:10:08,380 --> 00:10:09,010
Let's see.

146
00:10:09,010 --> 00:10:11,170
We've got this regex right here.

147
00:10:11,350 --> 00:10:12,790
And let's see.

148
00:10:12,790 --> 00:10:16,250
We're compiling it here and we've got a matter here.

149
00:10:16,420 --> 00:10:25,060
So what I'm contemplating is just exactly how do I want to be able to reuse a lot of the code that's

150
00:10:25,060 --> 00:10:25,900
already here?

151
00:10:26,350 --> 00:10:31,570
I'm just trying to decide what's the what's a nice approach to doing that?

152
00:10:32,380 --> 00:10:37,510
What I'm inclined to try first off, is to just copy all of this.

153
00:10:38,500 --> 00:10:39,790
So let's copy this.

154
00:10:41,050 --> 00:10:48,410
Go over here to the programmer class, and I'm going to throw those copied lines in as fields.

155
00:10:48,430 --> 00:10:51,660
First off, mostly, let's see.

156
00:10:51,670 --> 00:10:53,350
So we've got a match here.

157
00:10:53,560 --> 00:10:54,880
Oh yeah, so OK.

158
00:10:54,880 --> 00:10:56,090
So we don't have the.

159
00:10:56,110 --> 00:10:56,830
Yeah, okay.

160
00:10:56,830 --> 00:11:02,380
So this matter doesn't make sense because to use a matter, you need the string that you're actually

161
00:11:02,380 --> 00:11:04,120
going to be matching on, right?

162
00:11:04,390 --> 00:11:05,500
And we don't have that.

163
00:11:05,800 --> 00:11:08,530
So let's see for now, just comment that out.

164
00:11:08,860 --> 00:11:15,310
While I think for a minute here and I'm going to close the project pain.

165
00:11:15,880 --> 00:11:16,260
All right.

166
00:11:16,270 --> 00:11:24,820
So I think it may be appropriate to grab that line and bring it into the constructor.

167
00:11:25,030 --> 00:11:31,370
And maybe we can just take this text which should match this rejects.

168
00:11:31,480 --> 00:11:33,460
It should just be one line of it, right?

169
00:11:33,460 --> 00:11:35,740
But it should perfectly match this rejects.

170
00:11:36,040 --> 00:11:43,180
So if we take this and throw it right there, I think we've got something there.

171
00:11:43,300 --> 00:11:52,030
And then from here, as long as that's a match, we should be able to say something like if people matched

172
00:11:52,510 --> 00:11:56,290
Dot we can use, find or matches here.

173
00:11:59,980 --> 00:12:07,120
Then now I could have used I could have used while, but I already know I'm only passing in one person

174
00:12:07,120 --> 00:12:07,750
here, right?

175
00:12:07,960 --> 00:12:13,480
So at most I'd only have looped once, and so I'm just as good to just use one if.

176
00:12:13,780 --> 00:12:14,710
Does that make sense?

177
00:12:15,640 --> 00:12:16,030
All right.

178
00:12:16,570 --> 00:12:26,080
So now I can start extracting these fields right so I can extract the last name so people match the

179
00:12:26,510 --> 00:12:29,560
group last name.

180
00:12:31,120 --> 00:12:41,260
And I can set that this last name equals just like that, and then maybe I'm just going to duplicate

181
00:12:41,260 --> 00:12:48,490
that once and then say, here I'll be fancy again and use my dual cursors here.

182
00:12:50,230 --> 00:12:55,720
First name and then escape to stop with the dual cursor business.

183
00:12:56,770 --> 00:12:59,230
And then I want the date of birth.

184
00:12:59,740 --> 00:13:03,130
Now let's see two to pass this date of birth.

185
00:13:03,220 --> 00:13:08,920
I'm going to do something that I don't think I've shown you yet, and we will have a module where we

186
00:13:08,920 --> 00:13:10,510
get into dates.

187
00:13:11,020 --> 00:13:16,390
But I guess you're going to get a quick little sneak preview on a little bit more of the date handling

188
00:13:16,390 --> 00:13:16,650
stuff.

189
00:13:16,660 --> 00:13:22,450
So if you think back to the module on numbers at the end of that module, we learned about the number

190
00:13:22,450 --> 00:13:23,470
format, right?

191
00:13:23,770 --> 00:13:26,860
And you may recall, although you may have forgotten it now.

192
00:13:27,250 --> 00:13:33,970
So we've been using no format or to take big decimals and numbers and to format them into formatted

193
00:13:33,970 --> 00:13:34,750
strings, right?

194
00:13:34,770 --> 00:13:40,750
So going from a number to a formatted string, well, we can also go the opposite way.

195
00:13:40,750 --> 00:13:49,240
And we did that in one of our lessons in the number module where we went from a formatted string to

196
00:13:49,270 --> 00:13:50,430
a number, right?

197
00:13:50,860 --> 00:13:59,230
Well, Java has a date format that does pretty much the same kind of thing, and it can go both ways

198
00:13:59,230 --> 00:13:59,950
as well.

199
00:14:00,250 --> 00:14:06,130
And so what we're going to have here if we jump back over to the main class.

200
00:14:07,700 --> 00:14:15,890
We're going to have this formatted date string here, and we're going to want to go from that to an

201
00:14:15,890 --> 00:14:17,240
actual local date.

202
00:14:17,340 --> 00:14:17,650
Right.

203
00:14:17,660 --> 00:14:21,020
So we need to pass this somehow.

204
00:14:21,140 --> 00:14:23,900
And so we can actually use a date format to do that.

205
00:14:24,080 --> 00:14:26,210
So I will show you how we can do that.

206
00:14:26,750 --> 00:14:27,590
Jump back over here.

207
00:14:27,590 --> 00:14:29,080
So let's see here.

208
00:14:29,090 --> 00:14:31,560
Let's create a date format.

209
00:14:31,580 --> 00:14:40,640
Now, these format guys oftentimes are good to have as fields because oftentimes you only need one instance

210
00:14:40,640 --> 00:14:41,210
of them.

211
00:14:41,330 --> 00:14:43,190
So let's see what that will look like.

212
00:14:43,220 --> 00:14:48,620
So Java has a class called date time format.

213
00:14:48,800 --> 00:14:49,430
There it is.

214
00:14:49,700 --> 00:14:50,720
Well, all right.

215
00:14:50,780 --> 00:14:51,860
Daytime format.

216
00:14:53,240 --> 00:14:55,130
And I'll just call it dirty.

217
00:14:56,800 --> 00:14:57,850
Format or.

218
00:15:01,380 --> 00:15:09,960
Now, there are a bunch of basic ones already in existence here, and if our date format already happens

219
00:15:09,960 --> 00:15:12,540
to match one of these, then we could just use it.

220
00:15:12,750 --> 00:15:18,300
So what we can do here is take a quick look at the Java doc.

221
00:15:20,130 --> 00:15:27,120
And see if there is a format that already matches what we want here, so there's only.

222
00:15:34,600 --> 00:15:40,030
All right, so I'm not sure that I see one there, but it's easy enough to just create one ourselves

223
00:15:40,030 --> 00:15:43,960
anyway, so what we can do is simply say of.

224
00:15:45,630 --> 00:15:46,170
Pattern.

225
00:15:47,820 --> 00:15:53,350
And then we can pass in a date pattern if you need to know what the symbols are for the patterns.

226
00:15:53,370 --> 00:15:56,100
This is very similar to what we did with the no format.

227
00:15:56,160 --> 00:16:00,840
Click on of pattern and then pull up the Java dock with an F1 or just hover over it.

228
00:16:01,230 --> 00:16:02,850
And let's see here.

229
00:16:02,970 --> 00:16:07,680
If you notice in this Java dock here, it talks about pattern of letters and symbols.

230
00:16:07,680 --> 00:16:13,170
So if you click on that article, it will tell you what all of the patterns and symbols are.

231
00:16:13,380 --> 00:16:15,810
So we're going to want the month, the day in the year.

232
00:16:15,810 --> 00:16:22,980
So month is specified with a capital M and depending on if you do one or two, that tells it whether

233
00:16:22,980 --> 00:16:29,850
or not it's a it's a two decimal month with a leading zero or just like we're doing it currently with

234
00:16:30,060 --> 00:16:31,230
no leading zero.

235
00:16:31,530 --> 00:16:38,370
So a capital M and lowercase D for the month and then the year is Capital Y.

236
00:16:38,700 --> 00:16:39,030
All right.

237
00:16:39,040 --> 00:16:40,350
So let's try that out.

238
00:16:41,470 --> 00:16:43,500
So capital M.

239
00:16:44,050 --> 00:16:49,270
Forward slash lowercase D forward slash one two, three four.

240
00:16:49,660 --> 00:16:51,940
Because I think that's our format, right?

241
00:16:52,000 --> 00:16:53,830
Let's just double check.

242
00:16:56,610 --> 00:16:57,000
Yeah.

243
00:16:57,300 --> 00:16:59,190
One digit, one digit, four digits.

244
00:16:59,350 --> 00:17:00,270
Yep, that's it.

245
00:17:00,510 --> 00:17:01,020
OK.

246
00:17:01,620 --> 00:17:01,890
All right.

247
00:17:01,900 --> 00:17:03,330
So there's our formatter.

248
00:17:04,140 --> 00:17:09,270
So now when we get ready to grab.

249
00:17:10,500 --> 00:17:12,390
The date group.

250
00:17:13,890 --> 00:17:24,660
T0 be like, so then we should be able to pass it to dty Formatter Dot Pass.

251
00:17:25,590 --> 00:17:29,880
So it even looks just about like the no format method did.

252
00:17:30,120 --> 00:17:36,720
Now this past method is going to return something called a temporal access survey, which we're not

253
00:17:36,720 --> 00:17:38,280
going to talk about right now.

254
00:17:38,730 --> 00:17:44,460
But what we can do next is simply create a local date.

255
00:17:46,040 --> 00:17:47,030
Local date.

256
00:17:48,940 --> 00:17:55,960
From now, a local date class now we've used the local date sort of many times already.

257
00:17:56,350 --> 00:18:00,970
But now we're going to use another method on the local date, which is from.

258
00:18:01,330 --> 00:18:06,520
And this takes something called a temporal accessory, which is what this pass method is returning.

259
00:18:06,730 --> 00:18:08,770
And then it will give us back a local date.

260
00:18:08,770 --> 00:18:10,600
So we'll just use this from method here.

261
00:18:10,600 --> 00:18:12,700
Local date dot from.

262
00:18:14,100 --> 00:18:15,200
Pass that all in.

263
00:18:16,410 --> 00:18:18,180
And now we can just capture all of this.

264
00:18:19,050 --> 00:18:20,250
And there's our date of birth.

265
00:18:21,270 --> 00:18:21,660
OK.

266
00:18:21,870 --> 00:18:27,600
Don't worry, this isn't something you need to, you know, master right here about the local date business.

267
00:18:27,600 --> 00:18:32,670
Like I said, we'll have a whole entire unit where we'll learn about date, stuff, date and time stuff.

268
00:18:33,120 --> 00:18:35,420
So you're getting a little bit more of a sneak preview here.

269
00:18:36,890 --> 00:18:44,720
But this is how we can pass the string representation of a date in a particular format into an actual

270
00:18:44,960 --> 00:18:45,920
date object.

271
00:18:46,280 --> 00:18:52,040
And you know what I did wrong here, I created a new one and I actually meant to just say this that

272
00:18:52,100 --> 00:18:53,540
oops, this state job.

273
00:18:53,780 --> 00:18:55,190
That's that's what I meant to do.

274
00:18:55,370 --> 00:18:56,150
All right.

275
00:18:56,270 --> 00:19:00,560
So we now have all of those fields passed.

276
00:19:01,500 --> 00:19:02,250
Presumably.

277
00:19:02,310 --> 00:19:04,280
Let's jump back over to Main.

278
00:19:04,800 --> 00:19:09,210
And now let's let's let's think about what we're going to do with with these bits here.

279
00:19:09,600 --> 00:19:14,040
So I think we're going to probably just do the same basic approach.

280
00:19:14,250 --> 00:19:15,300
Let's see here.

281
00:19:15,300 --> 00:19:19,020
So we've got yeah, we've got this regex here.

282
00:19:19,380 --> 00:19:21,210
So let's let's grab all of that.

283
00:19:22,140 --> 00:19:22,850
Also.

284
00:19:24,370 --> 00:19:25,750
Jump back over here.

285
00:19:25,900 --> 00:19:33,640
Let's see, by the way, let's make this let's make this people rejects private and let's also make

286
00:19:33,640 --> 00:19:40,210
it final because it's not ever going to need to be changed by making it final, by the way.

287
00:19:40,240 --> 00:19:45,490
Not only do we protect ourselves from inadvertently changing it later on in the program, but we also

288
00:19:45,490 --> 00:19:52,120
allow the Java compiler that converts our readable Java code into machine language.

289
00:19:52,120 --> 00:19:58,210
Essentially, we allow the compiler to have opportunities to make optimizations.

290
00:19:58,450 --> 00:20:03,730
Now, there's no guarantee that it can optimize in every single case, but we're kind of flagging it

291
00:20:03,730 --> 00:20:09,190
like, Hey, this is never going to change, so it may be able to do certain optimal things with that.

292
00:20:10,330 --> 00:20:10,660
All right.

293
00:20:10,700 --> 00:20:11,420
Let's see.

294
00:20:11,440 --> 00:20:15,710
And same thing goes for the pattern as well.

295
00:20:15,730 --> 00:20:18,160
Private final.

296
00:20:18,370 --> 00:20:25,200
And then let's go ahead and paste these other two bits and do the same thing here.

297
00:20:25,210 --> 00:20:31,720
Private final for the programmer Reg X and for the pattern as well.

298
00:20:34,770 --> 00:20:35,430
All right.

299
00:20:35,880 --> 00:20:43,350
And so now we want to be able to parse the lines of code and the years of experience in the IQ.

300
00:20:43,500 --> 00:20:45,330
So let's create fields for those.

301
00:20:46,730 --> 00:20:47,330
Private.

302
00:20:48,570 --> 00:20:51,350
Let's call this lines of code.

303
00:20:52,420 --> 00:20:53,890
Oh, forgot my type.

304
00:20:54,310 --> 00:20:55,690
I guess this will be an integer.

305
00:20:56,960 --> 00:20:58,790
We'll initialize it to zero.

306
00:20:59,030 --> 00:21:06,470
And what else did we have years of experience, private and years of experience, I'll just call it

307
00:21:06,600 --> 00:21:12,800
exp equals zero and private and.

308
00:21:14,130 --> 00:21:16,980
IQ equals zero.

309
00:21:17,370 --> 00:21:19,920
We'll just default them all to zero.

310
00:21:20,130 --> 00:21:25,020
All right, so now we need to parse out those bits.

311
00:21:26,830 --> 00:21:33,880
And so we will use this or pattern, I just realized that I called the program, I called the Rejects

312
00:21:33,880 --> 00:21:38,440
program or rejects, but then I called the pattern coder Oh, well, all right, so we'll use this code

313
00:21:38,440 --> 00:21:40,810
or pattern, so we'll use it inside of the block.

314
00:21:40,810 --> 00:21:47,170
Because if this fifth block isn't true, then surely you won't be able to parse out the rest of the

315
00:21:47,170 --> 00:21:48,550
programmer bits, either.

316
00:21:48,550 --> 00:21:49,300
That wouldn't make sense.

317
00:21:49,300 --> 00:21:52,360
So it has to be done inside of the f block here.

318
00:21:52,390 --> 00:21:52,870
OK.

319
00:21:53,410 --> 00:21:53,820
All right.

320
00:21:53,830 --> 00:21:55,150
So let's see.

321
00:21:55,150 --> 00:21:57,670
We'll we'll work with this code or pattern.

322
00:21:57,670 --> 00:21:59,230
So let's see what this might look like.

323
00:21:59,470 --> 00:22:02,530
Maybe we can do something like code or pattern.

324
00:22:03,130 --> 00:22:10,120
So first thing we'll need is to make a matcher again, write code or pattern that matter.

325
00:22:10,390 --> 00:22:20,440
Now we will pass in one particular field, which should be the People Match or Dot Group.

326
00:22:22,550 --> 00:22:25,820
Details, but details.

327
00:22:27,130 --> 00:22:34,680
And then let's capture that, and we'll call it, I don't know, programmer matter.

328
00:22:34,990 --> 00:22:38,290
And I guess I'll be more consistent here and call this.

329
00:22:38,350 --> 00:22:42,520
Well, I'll leave it for now because we called it code or pattern in the other thing, some being a

330
00:22:42,520 --> 00:22:43,540
little inconsistent.

331
00:22:43,720 --> 00:22:44,650
Forgive me for that.

332
00:22:44,800 --> 00:22:48,100
Well, you know, so let's go ahead and change this to be programmers.

333
00:22:48,100 --> 00:22:53,830
Since the class is now called programmer, let's make all references to programmers be use the word

334
00:22:53,830 --> 00:22:57,210
program at least, so I will do a shift.

335
00:22:57,460 --> 00:22:58,150
Six.

336
00:23:01,580 --> 00:23:04,360
And change the word coder to Prague.

337
00:23:06,040 --> 00:23:09,790
All right, now, at least, I'm a little more consistent inside of this class.

338
00:23:10,790 --> 00:23:18,620
OK, so now that we've got the matter here, we'll have to tell it to actually find things right, so

339
00:23:18,620 --> 00:23:20,240
we'll see if.

340
00:23:21,570 --> 00:23:25,680
Prague matcher Dot find.

341
00:23:26,250 --> 00:23:32,940
So if it finds anything, then we can extract its bits, right?

342
00:23:33,510 --> 00:23:38,540
So will do pretty much the same pattern that we have here.

343
00:23:38,730 --> 00:23:47,550
So we can say this the lines of code equals integer dot pass.

344
00:23:48,060 --> 00:23:48,600
And.

345
00:23:51,530 --> 00:23:55,310
Prague matcher that group.

346
00:23:56,660 --> 00:23:59,550
And the field is called l'Eau Sepedi.

347
00:24:02,700 --> 00:24:12,510
Just like that, then I'll duplicate this line two more times, and now the other two fields were years

348
00:24:12,510 --> 00:24:23,550
of experience, years of experience equals and then this bit is why Zoe and then the next bit is IQ

349
00:24:24,270 --> 00:24:26,580
and this is IQ.

350
00:24:27,060 --> 00:24:27,930
All right.

351
00:24:28,410 --> 00:24:37,140
So now when we create a new programmer and pass in one line of text that's representing an entire person.

352
00:24:37,500 --> 00:24:44,250
All of this should get passed into the person in a nice, usable way.

353
00:24:44,940 --> 00:24:45,330
All right.

354
00:24:45,330 --> 00:24:47,790
So now let's jump back over.

355
00:24:48,450 --> 00:24:50,760
By the way, I'm jumping around with command.

356
00:24:50,800 --> 00:24:51,240
Oh.

357
00:24:54,920 --> 00:24:55,490
Main.

358
00:24:57,920 --> 00:25:03,530
All right, so let's jump down here and see now what was I, how was I doing this up until now?

359
00:25:03,540 --> 00:25:04,850
So.

360
00:25:05,870 --> 00:25:08,730
Most of this code is just a lot of parsing.

361
00:25:09,200 --> 00:25:14,360
The only part that's actually doing any calculating is this one line right here.

362
00:25:14,480 --> 00:25:20,930
So let's implement this one line in our program or let's in our programmer class.

363
00:25:21,500 --> 00:25:26,080
So let's in fact, you know, let's just grab this whole line.

364
00:25:27,960 --> 00:25:36,060
Let's jump back over to our programmer now that one line can become a method all by itself, maybe a

365
00:25:36,060 --> 00:25:37,530
method called get salary.

366
00:25:38,280 --> 00:25:39,600
Let's see what that'll look like.

367
00:25:39,690 --> 00:25:41,880
So let's see here.

368
00:25:43,770 --> 00:25:45,630
Here's our constructor.

369
00:25:46,990 --> 00:25:49,420
So I'm going to make a new method.

370
00:25:49,450 --> 00:25:50,540
It'll be public.

371
00:25:50,560 --> 00:25:51,940
It'll return.

372
00:25:54,030 --> 00:25:54,530
Hmm.

373
00:25:55,080 --> 00:25:59,760
Debating on whether or not it should return an integer or a string because it would be formatted, I

374
00:25:59,760 --> 00:26:01,290
guess it'll return an integer.

375
00:26:03,680 --> 00:26:05,840
Get salary.

376
00:26:09,080 --> 00:26:09,470
All right.

377
00:26:09,590 --> 00:26:11,760
So now for the implementation of it.

378
00:26:11,780 --> 00:26:17,540
Well, you know, I was going to paste well here, I'll do this, I'll paste a reference to it.

379
00:26:17,540 --> 00:26:20,240
But you know, we've got different fields and things now.

380
00:26:20,750 --> 00:26:31,730
So the way we want to do this, I suppose, is let's just return 3000 plus.

381
00:26:33,050 --> 00:26:34,370
Lines of code.

382
00:26:34,790 --> 00:26:35,690
Times.

383
00:26:36,810 --> 00:26:40,980
Years of experience Times IQ.

384
00:26:41,960 --> 00:26:42,270
Oops!

385
00:26:42,380 --> 00:26:43,220
IQ.

386
00:26:45,790 --> 00:26:51,550
Now, if you recall in the main program here, we have this health block to say, like somehow like

387
00:26:51,760 --> 00:26:57,040
if we weren't able to pass anything, then just returned three thousand.

388
00:26:57,370 --> 00:27:02,320
I'm not inclined to do that in the new program or class.

389
00:27:02,560 --> 00:27:08,170
And the reason is because we're defaulting all of these to zero anyway.

390
00:27:08,590 --> 00:27:14,860
And so if any of that is zero or can't be read, then these are all going to end up just being zero

391
00:27:14,860 --> 00:27:16,540
and this will just be 3000 anyway.

392
00:27:16,660 --> 00:27:21,040
And probably if I had thought about that a little more deeply, that's probably true even in the other

393
00:27:21,250 --> 00:27:23,410
in the other implementation, too.

394
00:27:23,560 --> 00:27:25,420
But I can see it a little more clearly here.

395
00:27:26,400 --> 00:27:26,680
All right.

396
00:27:26,700 --> 00:27:29,160
And I don't need this reference anymore.

397
00:27:29,460 --> 00:27:29,940
All right.

398
00:27:30,090 --> 00:27:31,980
Jump back over to Maine again.

399
00:27:32,280 --> 00:27:38,400
And now what I'm really wondering is if I can get rid of a whole bunch of this code and more like just

400
00:27:38,400 --> 00:27:43,620
depend on this programmer here, and I sort of think I possibly can.

401
00:27:43,980 --> 00:27:48,060
I'm kind of wondering if I can do something like.

402
00:27:51,430 --> 00:27:52,810
Comment out.

403
00:27:54,020 --> 00:27:55,190
All of that.

404
00:27:57,110 --> 00:28:04,190
And then maybe just do programmer get salary.

405
00:28:04,530 --> 00:28:10,550
Oh, now you see where we're getting here now, really, I mean, we haven't saved ourselves a lot of

406
00:28:10,550 --> 00:28:18,320
lines of code, but we have saved ourselves some a little bit of simplification in two different classes

407
00:28:18,320 --> 00:28:18,950
now, right?

408
00:28:19,280 --> 00:28:27,050
So whereas this class has all of this code that our brain has to kind of track when we're done with

409
00:28:27,050 --> 00:28:33,080
all of this, each of these cases may become just like two lines of code.

410
00:28:33,140 --> 00:28:33,540
Right.

411
00:28:33,560 --> 00:28:39,890
And actually, I can see we could even boil it down to maybe one line of code per case, possibly.

412
00:28:40,220 --> 00:28:47,180
And the equivalent of what all of this code is doing will now be kind of moved into those classes.

413
00:28:47,390 --> 00:28:51,780
And so it will be a little more manageable in our heads.

414
00:28:51,810 --> 00:28:53,630
Do you see where this is going?

415
00:28:53,660 --> 00:28:54,010
All right.

416
00:28:54,020 --> 00:28:55,460
So let's see here.

417
00:28:56,300 --> 00:29:02,600
Let's rerun this and see if we're still getting what was it, around eight million or so?

418
00:29:03,320 --> 00:29:04,640
So let's just rerun this.

419
00:29:06,120 --> 00:29:06,460
Hmm.

420
00:29:06,640 --> 00:29:10,690
OK, let's see, unable to obtain local data from.

421
00:29:13,590 --> 00:29:19,110
Oh, maybe I used the wrong format character for the year.

422
00:29:20,200 --> 00:29:24,040
I was feeling like that was looking a little weird to me, let's see here.

423
00:29:32,900 --> 00:29:34,100
Let's see.

424
00:29:34,490 --> 00:29:41,990
So if you see here the the issue, it says unable to obtain local data from temporal access, sir,

425
00:29:43,430 --> 00:29:46,640
which was right here, local date, blah blah blah.

426
00:29:47,090 --> 00:29:48,950
So this formatter here?

427
00:29:50,700 --> 00:29:53,190
Y y y y let me look at this.

428
00:29:53,730 --> 00:29:56,250
I mean, look at the Java doc for this again.

429
00:29:57,540 --> 00:30:00,360
Pattern of letters and symbols.

430
00:30:07,220 --> 00:30:08,110
Oh, yeah, yeah.

431
00:30:08,390 --> 00:30:13,940
Lower case y, I don't know why I had that that way command shift to you.

432
00:30:14,390 --> 00:30:14,820
There we go.

433
00:30:14,840 --> 00:30:23,450
So you see that command shift, you toggle the text of your selection or control, shift you for Windows

434
00:30:23,450 --> 00:30:24,080
and Linux.

435
00:30:25,010 --> 00:30:25,460
All right.

436
00:30:26,270 --> 00:30:32,420
Let's jump back over to main and run that again and see if that was the issue.

437
00:30:33,940 --> 00:30:34,270
Hey.

438
00:30:35,320 --> 00:30:41,760
Yeah, we're still getting eight point six million, I'm pretty sure that was the number before now.

439
00:30:41,770 --> 00:30:46,290
We're not printing out any more, though, but I think we can fix that, right?

440
00:30:46,300 --> 00:30:49,360
So we're not printing out for the programmers now.

441
00:30:49,870 --> 00:30:51,070
Let's fix that.

442
00:30:51,280 --> 00:30:51,520
All right.

443
00:30:51,520 --> 00:30:54,850
So let's jump over to the programmer class.

444
00:30:55,150 --> 00:30:59,710
So here's where we're getting the salary so we could do one or two things.

445
00:31:00,070 --> 00:31:04,840
So I think what we can do here is to simply override the two string method.

446
00:31:05,170 --> 00:31:06,790
So let's see what that looks like.

447
00:31:06,970 --> 00:31:09,250
I'll do a control o to override.

448
00:31:09,490 --> 00:31:11,470
I will choose to string.

449
00:31:11,920 --> 00:31:22,630
And so in this, we will return string dot format because this will be equivalent to what we were doing

450
00:31:22,660 --> 00:31:26,990
to print out these names and amounts here.

451
00:31:27,010 --> 00:31:30,760
So we'll pretty much do the exact same code just about.

452
00:31:31,150 --> 00:31:39,460
So we'll do a percent Ask.com percent as Kolan percent s.

453
00:31:40,600 --> 00:31:42,370
And then we will do.

454
00:31:42,610 --> 00:31:43,450
Let's see.

455
00:31:43,900 --> 00:31:46,960
Last name, come up, first name.

456
00:31:47,350 --> 00:31:51,250
Now we are formatting this amount though, right?

457
00:31:51,580 --> 00:32:01,120
So we will want a format again, and I guess I'm going to make that format or as a field here.

458
00:32:01,480 --> 00:32:01,720
All right.

459
00:32:01,720 --> 00:32:05,440
So let's make a no format final.

460
00:32:07,030 --> 00:32:08,290
No format.

461
00:32:10,820 --> 00:32:12,140
Let's see money.

462
00:32:12,170 --> 00:32:14,060
I'm just going to call it money for a minute.

463
00:32:15,620 --> 00:32:20,900
Equals no format, get currency instance.

464
00:32:22,590 --> 00:32:26,100
And then we will use it down in here.

465
00:32:29,540 --> 00:32:31,700
Oh, look at I call it money format.

466
00:32:33,210 --> 00:32:35,040
Money format that.

467
00:32:36,080 --> 00:32:40,790
Format and then we'll just pass in the get salary.

468
00:32:42,640 --> 00:32:53,710
Like so now, if we jump back over to the main we can call system out the print line and then call programmer,

469
00:32:54,490 --> 00:32:54,910
oops.

470
00:32:56,420 --> 00:32:58,910
Pro Grammar.

471
00:33:00,050 --> 00:33:01,250
Talked to string.

472
00:33:02,210 --> 00:33:06,620
Which technically, we probably don't need the two string, but I'll be more explicit here.

473
00:33:07,070 --> 00:33:07,370
All right.

474
00:33:07,370 --> 00:33:08,140
So let's see.

475
00:33:08,150 --> 00:33:09,280
Let's run this now.

476
00:33:11,630 --> 00:33:12,180
All right.

477
00:33:12,200 --> 00:33:16,250
Let's see if we got those hey, yet looking good.

478
00:33:17,870 --> 00:33:19,430
Got all the values there.

479
00:33:20,890 --> 00:33:26,140
So now from this class's perspective, we now.

480
00:33:27,530 --> 00:33:29,810
Don't need any of this.

481
00:33:35,080 --> 00:33:37,810
Look, how much nicer that just got, right?

482
00:33:39,060 --> 00:33:40,710
The code's a lot more manageable.

483
00:33:41,460 --> 00:33:41,950
All right.

484
00:33:41,970 --> 00:33:47,780
So I think we have accomplished what we set out to do for the programmer.

485
00:33:47,790 --> 00:33:55,590
And so in the next lesson, let's just do it again for the manager and the analyst and CEO.

486
00:33:55,860 --> 00:33:56,280
All right.

487
00:33:56,520 --> 00:33:59,610
And I'm just letting you know we're just getting started, OK?

488
00:33:59,620 --> 00:34:06,730
There's a lot more that we can do to make this much more object oriented and you'll see that as we proceed,

489
00:34:06,750 --> 00:34:08,760
but we're off to a nice little start here.

490
00:34:08,790 --> 00:34:10,770
OK, so I'll see you in the next one.
