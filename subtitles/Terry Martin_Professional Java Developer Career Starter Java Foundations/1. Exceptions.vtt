WEBVTT
1
00:00:00.450 --> 00:00:04.920
All right, so in this lesson, we're going to learn a little more about exceptions.

2
00:00:05.130 --> 00:00:11.130
Now we won't be going super deep into this because honestly, in this whole entire course, the purpose

3
00:00:11.130 --> 00:00:15.210
is to get you the core knowledge that you need to be useful.

4
00:00:15.360 --> 00:00:20.430
And there are plenty and plenty of professional developers who themselves don't really know a whole

5
00:00:20.430 --> 00:00:24.450
lot about how to properly make use of exceptions, and that doesn't hold them back.

6
00:00:24.690 --> 00:00:30.330
So I'm not trying to inundate you with a ton of knowledge about exceptions, but just give you the core

7
00:00:30.330 --> 00:00:34.620
basics so that you don't feel like you have no idea what's going on.

8
00:00:34.770 --> 00:00:40.740
When we're looking at these, but look at how far we've come in this course already without me really

9
00:00:40.770 --> 00:00:43.140
going into any significant detail about them.

10
00:00:43.140 --> 00:00:45.030
So here we go.

11
00:00:45.420 --> 00:00:45.780
All right.

12
00:00:45.780 --> 00:00:50.850
So there are, generally speaking, three types of exceptions.

13
00:00:50.860 --> 00:00:52.740
First off, let me explain what is an exception.

14
00:00:52.740 --> 00:00:55.470
I've talked about it before, but let me just kind of reiterate.

15
00:00:55.800 --> 00:01:07.080
So basically, any time something can go pretty wrong in your program, an exception can be what we

16
00:01:07.080 --> 00:01:08.130
call thrown.

17
00:01:08.430 --> 00:01:11.580
And what that basically means is an exception can occur.

18
00:01:11.610 --> 00:01:12.090
OK.

19
00:01:13.140 --> 00:01:15.480
There are three general types of exceptions.

20
00:01:15.720 --> 00:01:18.180
There are checked exceptions.

21
00:01:18.480 --> 00:01:24.510
There are runtime exceptions which are said to be unchecked and then there are errors.

22
00:01:25.080 --> 00:01:30.060
We won't be handling errors because there's not a whole lot that you can do about them anyway.

23
00:01:30.480 --> 00:01:36.930
So the main two types of exceptions that you are most likely to encounter from day to day will be checked.

24
00:01:36.930 --> 00:01:39.660
Exceptions and unchecked exceptions.

25
00:01:40.260 --> 00:01:46.890
Checked exceptions are supposed to be situations that occur programmatically that you, as the programmer,

26
00:01:46.920 --> 00:01:49.440
might be able to do something about.

27
00:01:49.890 --> 00:01:57.870
So one example of that is where we've been opening up the file with the five million records and iterating

28
00:01:57.870 --> 00:01:58.200
through it.

29
00:01:58.530 --> 00:02:05.730
Every time we open up that file using the files that lines method, we have to handle the exception

30
00:02:05.730 --> 00:02:09.930
that can occur as a result of us making the call to the lines method.

31
00:02:10.170 --> 00:02:16.740
And I stated before that the exception that can occur there is that the file that we refer to might

32
00:02:16.740 --> 00:02:17.480
not exist.

33
00:02:17.490 --> 00:02:22.470
In fact, let me just open up one of those programs real quick so that we can all be on the same page

34
00:02:22.470 --> 00:02:22.770
here.

35
00:02:24.050 --> 00:02:32.000
OK, so here we are back in the big data class, and you will recall that we were using the files that

36
00:02:32.000 --> 00:02:40.700
lines method to open up our CSV file with five billion plus one header row, five million records in

37
00:02:40.700 --> 00:02:40.970
it.

38
00:02:41.930 --> 00:02:46.220
And every time we make a call to this method, here lines.

39
00:02:46.730 --> 00:02:53.810
This method actually throws an exception and I'm hovering over it so that we can see its Java document.

40
00:02:54.050 --> 00:03:01.250
So you may notice that the signature of this method is defined to return a stream of strings, but it

41
00:03:01.250 --> 00:03:06.600
also throws something called a java o that io exception.

42
00:03:06.620 --> 00:03:07.040
OK.

43
00:03:07.400 --> 00:03:12.560
So we're going to learn a little more about what that actually means, but the basic gist of it is that

44
00:03:12.560 --> 00:03:19.250
it's telling us that, hey, you can call this method, but just know that it is possible that something

45
00:03:19.250 --> 00:03:24.590
could go wrong when you're trying to call this method and you will need to handle that situation.

46
00:03:24.830 --> 00:03:30.980
And that's what this AOA exception is, indicating that when we're dealing with files, there could

47
00:03:30.980 --> 00:03:35.310
be something that goes wrong with the input output, the file stuff.

48
00:03:35.330 --> 00:03:35.750
OK.

49
00:03:35.900 --> 00:03:37.580
So that's what that's saying.

50
00:03:38.390 --> 00:03:45.230
And Throws just says that this method is capable of producing that type of exception.

51
00:03:45.470 --> 00:03:52.370
That kind of that kind of situation is capable of happening when you call the lines method.

52
00:03:52.400 --> 00:03:52.760
OK.

53
00:03:53.060 --> 00:03:56.330
So we'll talk a little bit more about that briefly.

54
00:03:56.330 --> 00:03:58.910
But I just wanted to show you that as a quick reminder.

55
00:03:59.450 --> 00:04:03.770
And then while we're here, though, I might as well show that what we decided to do about it in this

56
00:04:03.770 --> 00:04:09.830
particular case was to surround this line in particular.

57
00:04:09.830 --> 00:04:16.730
But really, we went ahead and just put all of the pertinent code inside of a try catch block, and

58
00:04:16.730 --> 00:04:19.940
we're going to learn more details about that as well.

59
00:04:20.360 --> 00:04:26.210
OK, so for now, though, jumping back over to this other little bit of code that I have here prepared,

60
00:04:26.990 --> 00:04:28.940
let's look at a couple of scenarios here.

61
00:04:29.270 --> 00:04:37.250
So in this code, I've created an array, a string array with and I've initialized it with three values

62
00:04:37.250 --> 00:04:39.410
one, two and three strings.

63
00:04:39.410 --> 00:04:42.500
And then I've also created an integer variable called Numb.

64
00:04:42.560 --> 00:04:43.820
Set it to zero.

65
00:04:44.150 --> 00:04:46.460
And here I am doing a couple of things.

66
00:04:46.670 --> 00:04:50.840
I want to print out the result of some math here.

67
00:04:51.680 --> 00:04:58.400
Get the length of the array, which should be three divided by whatever number I have in this variable

68
00:04:58.400 --> 00:05:00.680
num, which currently is zero.

69
00:05:00.860 --> 00:05:01.340
OK.

70
00:05:01.580 --> 00:05:10.910
And then let's print whatever value is in the third element of this of this array.

71
00:05:11.270 --> 00:05:11.510
All right.

72
00:05:11.510 --> 00:05:13.670
So let's just run this and see what happens.

73
00:05:15.780 --> 00:05:23.190
All right, so it actually blows up immediately and in by blow up, I mean, an exception is generated

74
00:05:23.190 --> 00:05:31.050
and thrown and the exception it says here exception in thread main java ling arithmetic exception.

75
00:05:31.950 --> 00:05:37.500
Forward slash by zero, which means divide divide by zero.

76
00:05:37.630 --> 00:05:46.170
So you may recall from math class that it is impossible to divide by zero or it's considered to be impossible,

77
00:05:46.170 --> 00:05:46.770
at least.

78
00:05:47.580 --> 00:05:49.770
And so the computer won't do that.

79
00:05:49.980 --> 00:05:52.980
It detected that we were trying to do that.

80
00:05:53.130 --> 00:05:59.940
And so it being the JVM generated this arithmetic exception.

81
00:05:59.970 --> 00:06:00.510
OK.

82
00:06:00.870 --> 00:06:02.760
That's why that happened.

83
00:06:03.060 --> 00:06:09.390
And what happens then is that once we get to this line in that arithmetic exception is thrown.

84
00:06:09.630 --> 00:06:11.510
The program just dies.

85
00:06:11.520 --> 00:06:12.660
Right, right then and there.

86
00:06:12.660 --> 00:06:18.390
So this Line six is never even reached because that exception got thrown.

87
00:06:18.480 --> 00:06:18.990
OK.

88
00:06:20.440 --> 00:06:26.770
Now I want to show you something that you kind of could do and just just know before we even start down

89
00:06:26.770 --> 00:06:27.400
this path.

90
00:06:28.090 --> 00:06:31.480
What I'm about to show you here is really just for illustrative purposes.

91
00:06:31.480 --> 00:06:39.610
This this isn't actually, generally speaking, a good idea to do what I'm about to do right now, but

92
00:06:40.090 --> 00:06:46.720
I can handle this exception or I can catch this particular exception.

93
00:06:46.750 --> 00:06:47.200
OK.

94
00:06:47.560 --> 00:06:51.640
And let me show you how I can do that, and there are few ways that I can do this.

95
00:06:52.060 --> 00:06:57.490
So first, I'm going to select this whole entire line and then I will do an option command T.

96
00:06:57.970 --> 00:07:04.960
And what I want to do is I want to surround just that line with a try catch block, and I will explain

97
00:07:04.960 --> 00:07:06.790
what that's really doing and why.

98
00:07:06.940 --> 00:07:11.140
But I'm going to select number six here, or I could click on it for a try catch.

99
00:07:12.270 --> 00:07:12.690
All right.

100
00:07:12.900 --> 00:07:19.500
So now that looks a little messier, but the pertinent thing here is that here's the original line right

101
00:07:19.500 --> 00:07:22.260
there, and now it's inside of a code block.

102
00:07:22.890 --> 00:07:25.270
And this is called a try catch block.

103
00:07:25.290 --> 00:07:29.250
OK, so now we've got this keyword try.

104
00:07:29.270 --> 00:07:36.030
So we're now telling the JVM essentially try executing this line.

105
00:07:36.660 --> 00:07:45.480
And if anything goes wrong, maybe we'll catch it and do something about it down here.

106
00:07:45.750 --> 00:07:46.230
OK.

107
00:07:47.100 --> 00:07:50.700
So now if I run this again, let's see what happens.

108
00:07:53.010 --> 00:07:57.930
OK, so we still have an exception happening here.

109
00:07:58.260 --> 00:08:07.320
The divide by zero, but the next line line 10 is executing now again, I want to state this is generally

110
00:08:07.320 --> 00:08:11.600
not a good idea, and I'll explain a little more about why it's not a great idea to do this.

111
00:08:11.610 --> 00:08:18.180
I'm showing this to you for illustrative purposes so that you can learn how exceptions work and how

112
00:08:18.180 --> 00:08:22.050
they can be caught and when to catch them and how and why, and all of that.

113
00:08:22.320 --> 00:08:22.670
All right.

114
00:08:22.680 --> 00:08:32.070
So what just happened now is that an exception was still generated in throne when the JVM realized that

115
00:08:32.070 --> 00:08:36.240
we were about to attempt a divide by zero operation here.

116
00:08:36.270 --> 00:08:41.880
OK, so it generated the arithmetic exception and it threw it.

117
00:08:43.560 --> 00:08:48.420
But now that we have this try catch block here, we cut the exception.

118
00:08:48.420 --> 00:08:52.140
And so that's why they used these terms to throw and to catch right.

119
00:08:52.410 --> 00:08:53.100
The exception?

120
00:08:53.100 --> 00:08:59.010
You can think of it as an object and it is an object, actually, it's an object that's sort of being

121
00:08:59.010 --> 00:08:59.770
thrown.

122
00:09:00.090 --> 00:09:08.630
And if you set up a catcher to catch it, then you can do something sometimes with that exception,

123
00:09:08.640 --> 00:09:09.140
OK?

124
00:09:09.510 --> 00:09:17.220
In this particular case, all we're doing with it is simply printing its stack trace, and we'll talk

125
00:09:17.220 --> 00:09:18.960
a little more about what a stack traces.

126
00:09:18.960 --> 00:09:24.590
But basically, it's printing the details of the error that occurred, right?

127
00:09:24.600 --> 00:09:26.850
And that's how we get to see this divide by zero.

128
00:09:27.030 --> 00:09:32.820
Now, previously, before I surrounded this line with a try catch, we were still seeing this, this

129
00:09:32.820 --> 00:09:38.460
output here, and that was happening because the exception was being handled by the JVM itself.

130
00:09:38.640 --> 00:09:42.970
Beyond the main method here, we're doing all of this inside of one main method.

131
00:09:42.990 --> 00:09:43.350
OK?

132
00:09:43.560 --> 00:09:45.990
Something called the main method, though.

133
00:09:46.260 --> 00:09:53.310
And so what happened before we had this try catch block here is that the exception was thrown and it

134
00:09:53.310 --> 00:09:55.740
made its way outside of the main method.

135
00:09:55.740 --> 00:09:59.880
And then the JVM were the thing that called our main method handled it.

136
00:10:00.060 --> 00:10:06.120
And in its handling of the method, it displayed the stack trace just like we're doing now.

137
00:10:06.240 --> 00:10:12.330
So you can imagine that whatever the thing is within the JVM that calls main method, it has code that

138
00:10:12.330 --> 00:10:14.550
looks sort of like this as well.

139
00:10:14.580 --> 00:10:15.000
OK.

140
00:10:16.520 --> 00:10:24.350
Now, because we are now handling this method right here, kind of in line like as soon as we call this

141
00:10:24.500 --> 00:10:31.640
this line here because we're handling it and we're not killing the application as a result of it.

142
00:10:32.030 --> 00:10:35.420
This next line is allowed to proceed.

143
00:10:35.570 --> 00:10:43.100
OK, now that might seem like a good idea, but in this particular case, it's not really a good idea

144
00:10:43.100 --> 00:10:51.150
at all, because with this divide by zero happening here, we're not able to fix anything.

145
00:10:51.170 --> 00:10:55.820
All we're doing is just saying, Oh yeah, that divide by zero occurred.

146
00:10:56.330 --> 00:10:57.140
Let's move on.

147
00:10:57.350 --> 00:11:05.750
It's kind of like if your house was on fire and you're driving by and you see your house is on fire

148
00:11:05.750 --> 00:11:09.980
and you say, Oh, look, my house is on fire and then you just keep driving.

149
00:11:11.330 --> 00:11:12.590
It's a lot like that.

150
00:11:12.800 --> 00:11:19.880
That's why in this particular case, this is not a good idea to to do just this right.

151
00:11:20.030 --> 00:11:23.000
I'm not really handling the exception in any way.

152
00:11:23.120 --> 00:11:27.320
All I'm doing is just noting yet there's that exception and I'm printing it out.

153
00:11:28.820 --> 00:11:36.230
Oftentimes, the better thing to do in a case like this might be to just let the program die, which

154
00:11:36.230 --> 00:11:38.660
would be the default behavior of the JVM.

155
00:11:38.660 --> 00:11:42.920
Anyway, as we originally saw before I was catching this, OK?

156
00:11:42.950 --> 00:11:44.900
But anyway, that's what's going on here.

157
00:11:44.930 --> 00:11:49.400
OK, now I want to show you another situation.

158
00:11:50.480 --> 00:11:55.880
So currently we are printing the third element of this array.

159
00:11:56.300 --> 00:12:03.260
Let's see what happens if we try to print an imaginary fourth element of this array.

160
00:12:03.290 --> 00:12:05.660
OK, so now let's run the program.

161
00:12:06.900 --> 00:12:10.020
All right, so now we're getting two exceptions here.

162
00:12:10.200 --> 00:12:15.480
We're getting our familiar divide by zero exception and then we're getting an index out of bounds,

163
00:12:15.480 --> 00:12:21.750
and we've seen this before when we were playing with arrays, I believe so.

164
00:12:22.050 --> 00:12:28.440
Yeah, so it's just telling us we're just trying to access an element that does not exist in this array

165
00:12:28.590 --> 00:12:29.700
of only three elements.

166
00:12:29.700 --> 00:12:32.580
We're trying to get a fourth element and there is no fourth element.

167
00:12:32.580 --> 00:12:34.430
And so that's illegal.

168
00:12:34.440 --> 00:12:35.370
You can't do that.

169
00:12:35.970 --> 00:12:38.370
So we could do the same thing here.

170
00:12:39.150 --> 00:12:47.100
We could select this line and then do an option command T and surrounded with a try catch again.

171
00:12:47.130 --> 00:12:47.550
Right?

172
00:12:49.370 --> 00:12:55.700
And just so that we know that we've changed something in a seemingly useful way.

173
00:12:55.850 --> 00:13:03.600
Let's just add one more system that out here and say, you made it to the end, OK?

174
00:13:03.890 --> 00:13:05.300
And then let's run this.

175
00:13:06.620 --> 00:13:13.400
All right, so we're seeing are you made it to the end message, but we're also seeing these two exceptions

176
00:13:13.400 --> 00:13:14.380
being thrown, OK?

177
00:13:14.780 --> 00:13:21.680
And again, I'm going to say it again what I'm doing here by catching each of these exceptions explicitly

178
00:13:21.680 --> 00:13:27.920
like this, but not really doing anything to attempt to fix the problem other than just printing out

179
00:13:27.920 --> 00:13:28.190
that.

180
00:13:28.190 --> 00:13:34.520
Yet there's that problem generally not a good idea in, in most cases, not a good idea.

181
00:13:36.110 --> 00:13:36.490
All right.

182
00:13:36.500 --> 00:13:38.450
So now that we're doing that?

183
00:13:38.510 --> 00:13:41.300
Let me show you a few other things that we can do.

184
00:13:41.690 --> 00:13:49.010
One thing we could do is to consolidate these try catch blocks so that we would only have one try,

185
00:13:49.040 --> 00:13:49.880
for example.

186
00:13:50.750 --> 00:13:56.930
And so what we can do here is I can take this line that I know is capable of generating a particular

187
00:13:56.930 --> 00:13:58.130
type of exception.

188
00:13:58.640 --> 00:14:05.510
And I can move it up into the first try catch block, right?

189
00:14:05.870 --> 00:14:09.680
And then I'm going to go ahead and just delete those two.

190
00:14:09.950 --> 00:14:14.420
OK, so now that I've done that, let's see what will happen when I run this.

191
00:14:15.720 --> 00:14:21.570
So now we're only seeing one exception here, but we are still making it to the end message here, you

192
00:14:21.570 --> 00:14:22.440
made it to the end.

193
00:14:22.770 --> 00:14:29.700
So the reason for that is because the divide by zero exception is occurring at Line six.

194
00:14:30.330 --> 00:14:37.830
And as soon as that exception occurs, the thread will stop executing any more lines of code within

195
00:14:37.830 --> 00:14:39.000
that try block.

196
00:14:39.060 --> 00:14:42.750
OK, so this next line seven just gets skipped.

197
00:14:43.080 --> 00:14:51.030
And basically, what's happening here is that the thread goes from this line down to line nine and then

198
00:14:51.030 --> 00:14:55.800
from line nine down to line 11, that's effectively what's happening here.

199
00:14:56.220 --> 00:15:02.670
So now let's say that we wanted to go ahead and address this issue here with the divide by zero.

200
00:15:02.670 --> 00:15:08.190
OK, so I'm going to change the NUM variable to a one, for example.

201
00:15:08.520 --> 00:15:10.890
And now let's run it again and see what happens.

202
00:15:10.920 --> 00:15:16.470
OK, now we're still getting an exception, but now we're getting the index three out of bounds for

203
00:15:16.470 --> 00:15:17.280
length three.

204
00:15:17.310 --> 00:15:24.300
So now this line is running and we're seeing that here because we're printing out a three, right?

205
00:15:24.720 --> 00:15:26.130
So Line six is running.

206
00:15:26.130 --> 00:15:32.280
But now when we get to Line seven, which we are getting to line seven now, so that's progress, I

207
00:15:32.280 --> 00:15:32.910
suppose.

208
00:15:33.420 --> 00:15:35.940
But now Line seven is throwing an exception.

209
00:15:36.210 --> 00:15:46.530
And so interestingly, now this line eight catch exception E is capable of handling both of these exceptions

210
00:15:46.530 --> 00:15:48.450
in a somewhat generic way, though.

211
00:15:48.870 --> 00:15:52.560
So now let's talk a little bit about what this catch is really doing.

212
00:15:52.560 --> 00:16:01.800
So basically, what it's saying is if you see an exception of type in this case, exception, then do

213
00:16:01.800 --> 00:16:04.170
whatever I have in this code block here.

214
00:16:04.200 --> 00:16:07.620
OK, so let's talk a little bit about exceptions.

215
00:16:08.070 --> 00:16:12.090
So I said that there are three types of exceptions.

216
00:16:12.090 --> 00:16:20.670
There are checked exceptions, runtime exceptions and errors, checked exceptions and runtime exceptions.

217
00:16:20.670 --> 00:16:25.740
Both extend from the same superclass, which is exception.

218
00:16:25.950 --> 00:16:31.020
And then the exception class itself extends from a superclass called Throw a ball.

219
00:16:31.680 --> 00:16:35.790
Errors, on the other hand, do not extend from exception.

220
00:16:35.970 --> 00:16:38.820
They extend from throw a ball also.

221
00:16:38.970 --> 00:16:45.960
So you've got exception and throw a ball and then under exception, we've got runtime exception.

222
00:16:45.960 --> 00:16:49.710
And actually there's a whole lot of exceptions, but that's the basic hierarchy.

223
00:16:50.820 --> 00:16:59.250
So we are able to say what these catch blocks here, what type of exception we are expecting to catch

224
00:16:59.700 --> 00:17:02.940
and then do something accordingly to that.

225
00:17:03.000 --> 00:17:07.590
Now one thing that's kind of interesting is that we can actually have multiple catch blocks.

226
00:17:07.620 --> 00:17:08.070
OK.

227
00:17:08.520 --> 00:17:15.480
So in this particular case, we see that the actual exception type that got thrown here was not something

228
00:17:15.480 --> 00:17:16.710
called exception.

229
00:17:17.010 --> 00:17:21.480
It was actually something called array index out of bounds exception.

230
00:17:21.630 --> 00:17:25.140
So this is a subclass of exception.

231
00:17:25.500 --> 00:17:33.180
And one interesting thing we can do with this is we could actually be much more specific in what exception

232
00:17:33.180 --> 00:17:35.010
we're actually looking for here.

233
00:17:35.250 --> 00:17:41.760
So I could change this to say array index out of bounds exception.

234
00:17:42.180 --> 00:17:42.900
Like so.

235
00:17:44.330 --> 00:17:49.880
And then we could even change this bit here and say something like.

236
00:17:51.340 --> 00:17:58.000
The array index, blah blah blah was thrown here.

237
00:17:58.420 --> 00:17:58.930
OK.

238
00:17:59.200 --> 00:18:01.720
And so now let me run that and you'll see.

239
00:18:02.410 --> 00:18:02.710
All right.

240
00:18:02.720 --> 00:18:07.450
So we got three and then we got our message the array index, blah blah blah was thrown here.

241
00:18:07.840 --> 00:18:11.590
Now what happens, though, if I return this bit?

242
00:18:13.340 --> 00:18:14.750
Back to zero.

243
00:18:15.320 --> 00:18:16.670
Let's see what that does.

244
00:18:18.870 --> 00:18:26.310
OK, so now we're getting an exception here, and it's the familiar divide by zero exception, which

245
00:18:26.310 --> 00:18:28.050
is an arithmetic exception.

246
00:18:28.260 --> 00:18:29.790
But look now what's happening?

247
00:18:30.630 --> 00:18:35.490
We're not even making it to the end of the program anymore, even though we've got to try catch block

248
00:18:35.490 --> 00:18:35.650
here.

249
00:18:35.670 --> 00:18:38.160
We're not making it to the end of the program anymore.

250
00:18:38.370 --> 00:18:43.590
And the reason for that is because we are no longer catching this arithmetic exception.

251
00:18:43.710 --> 00:18:49.200
Now I know what some of you may be thinking Well, we never were catching an arithmetic exception.

252
00:18:49.320 --> 00:18:52.230
Initially, we were catching just an exception.

253
00:18:52.530 --> 00:18:55.710
And now we're catching an array index out of bounds exception.

254
00:18:55.890 --> 00:19:00.420
We were never explicitly catching an arithmetic exception, and that is true.

255
00:19:00.450 --> 00:19:04.700
We weren't ever catching explicitly an arithmetic exception.

256
00:19:04.710 --> 00:19:13.170
However, since arithmetic exception and array index out of bounds exception, both extend from exception.

257
00:19:13.530 --> 00:19:16.770
And we were explicitly catching exception.

258
00:19:17.700 --> 00:19:22.620
That catch was handling both types and so many more, by the way.

259
00:19:23.100 --> 00:19:25.290
And so that's something for you to make a note of.

260
00:19:26.040 --> 00:19:30.490
You can always catch the more generic exception data type.

261
00:19:30.510 --> 00:19:30.960
OK.

262
00:19:31.080 --> 00:19:32.730
The JVM will honor that.

263
00:19:33.000 --> 00:19:34.380
That can be a good thing.

264
00:19:34.380 --> 00:19:41.490
Sometimes it can also be a bad thing if you're not aware that that could be happening in general.

265
00:19:41.610 --> 00:19:48.030
You do actually want to catch the most specific exception data type that is meaningful for whatever

266
00:19:48.030 --> 00:19:49.400
it is that you're doing, OK?

267
00:19:49.680 --> 00:19:57.510
So what we can do here is if we want to handle either of these cases that are both existing within this

268
00:19:57.510 --> 00:20:02.010
one try block, we can actually specify multiple catches.

269
00:20:02.280 --> 00:20:09.540
So we've got the one there, but we could add another one here to handle the arithmetic exception as

270
00:20:09.540 --> 00:20:09.960
well.

271
00:20:12.870 --> 00:20:24.030
And we'll give ourselves a nice message here to say this is due to the aromatic exception.

272
00:20:24.910 --> 00:20:28.850
Being thrown, all right, so now.

273
00:20:29.290 --> 00:20:31.120
Well, first, let's just run this again.

274
00:20:31.930 --> 00:20:37.050
OK, so now that we've run this again, liquid, now we're getting the message.

275
00:20:37.060 --> 00:20:41.860
This is due to the arithmetic exception being thrown so that this guy here, right?

276
00:20:41.860 --> 00:20:47.980
So it's not this guy here isn't catching because nothing is throwing the array index out of bounds.

277
00:20:47.980 --> 00:20:51.140
However, an arithmetic exception is being thrown.

278
00:20:51.490 --> 00:20:54.340
And now we're catching it and printing a message.

279
00:20:54.490 --> 00:21:02.620
And because we are now handling that exception with this explicit catch here, the program in this case

280
00:21:02.620 --> 00:21:03.610
isn't dying.

281
00:21:04.000 --> 00:21:08.530
It's proceeding on to the next line outside of our try catch block.

282
00:21:08.560 --> 00:21:11.900
OK, now the try catch block is this whole entire thing.

283
00:21:11.920 --> 00:21:12.400
All right.

284
00:21:13.420 --> 00:21:14.830
And so we've got these two catches.

285
00:21:14.830 --> 00:21:22.810
So in general, you can have as many catches as you need to handle, whatever the situations are.

286
00:21:22.840 --> 00:21:26.800
OK, now I want to show you one more thing here.

287
00:21:27.790 --> 00:21:31.450
What if we just had the same message for both of these?

288
00:21:31.460 --> 00:21:41.770
So what if we just said something went terribly wrong, which is not a good thing to say in your catch,

289
00:21:41.770 --> 00:21:43.570
by the way, it's not a helpful message.

290
00:21:43.720 --> 00:21:46.430
We want to know what went wrong and why did it go wrong?

291
00:21:46.450 --> 00:21:52.060
So you actually really want to capture more information, but for the purposes of this stupid, you

292
00:21:52.060 --> 00:21:58.720
know, little tutorial here for right now, let's just say that you wanted to say the same thing, both

293
00:21:58.720 --> 00:22:03.640
in this catch block and in this one as well.

294
00:22:03.820 --> 00:22:04.330
OK.

295
00:22:05.410 --> 00:22:05.760
All right.

296
00:22:05.770 --> 00:22:07.720
So let's run that real quick.

297
00:22:07.960 --> 00:22:08.230
All right.

298
00:22:08.230 --> 00:22:08.820
So there we go.

299
00:22:08.830 --> 00:22:09.520
Something went wrong.

300
00:22:09.520 --> 00:22:11.430
So now we don't know where it went wrong, right?

301
00:22:11.440 --> 00:22:16.630
We don't know which one of these catches went wrong, but we know that something went wrong.

302
00:22:16.900 --> 00:22:27.220
So the point here is if we wanted to do basically the same error handling for both for either of these

303
00:22:27.220 --> 00:22:32.180
catches, we could consolidate this because now this is duplicated code.

304
00:22:32.410 --> 00:22:34.660
OK, we're doing the same thing here, essentially.

305
00:22:35.170 --> 00:22:39.370
So what we can do here is implement what's called a multi catch.

306
00:22:39.550 --> 00:22:41.950
And this is a little bit newer functionality.

307
00:22:41.950 --> 00:22:46.600
I think as of either Java eight or nine doesn't really matter too much, but just know that it's not

308
00:22:46.600 --> 00:22:48.940
an old old old versions of Java.

309
00:22:49.270 --> 00:22:55.270
So what we can do is actually combine these two bits into one catch block here, and the way we can

310
00:22:55.270 --> 00:22:57.100
do that is simply within order.

311
00:22:57.130 --> 00:23:01.900
Operator and the or operator is this guy here just the pipe?

312
00:23:02.290 --> 00:23:04.990
And then we can say arithmetic exception like so.

313
00:23:05.200 --> 00:23:09.580
And now notice that this has gone in red because it is redundant.

314
00:23:10.330 --> 00:23:14.950
And so we can actually just get rid of all of that like so.

315
00:23:15.520 --> 00:23:24.190
And so now we're saying if array index out of bounds exception or arithmetic exception are thrown,

316
00:23:24.610 --> 00:23:32.380
let's refer to that exception with this variable called E and then do whatever we're saying to do within

317
00:23:32.380 --> 00:23:34.750
the catch block here, OK?

318
00:23:34.900 --> 00:23:37.060
And so, by the way, that is a variable there.

319
00:23:37.060 --> 00:23:42.130
Sorry, I did not mention that explicitly before we could call this something a little longer.

320
00:23:42.250 --> 00:23:42.610
Right?

321
00:23:42.730 --> 00:23:43.600
Exception.

322
00:23:43.630 --> 00:23:43.960
Right.

323
00:23:44.680 --> 00:23:46.600
And we can even do something with this.

324
00:23:46.600 --> 00:23:50.050
So I did mention these exceptions are actually objects.

325
00:23:50.260 --> 00:23:53.710
And so they have methods on them and properties and things.

326
00:23:53.710 --> 00:23:57.250
And so we can actually access those methods and do stuff with them.

327
00:23:57.460 --> 00:24:01.250
So for example, let's see here we could do something like this.

328
00:24:02.290 --> 00:24:04.000
Let's put a colon there.

329
00:24:04.000 --> 00:24:09.880
And then plus and we'll refer to the exception and we can say, like get message.

330
00:24:11.440 --> 00:24:12.670
Let's see what this does.

331
00:24:14.770 --> 00:24:15.100
OK.

332
00:24:15.130 --> 00:24:15.790
Look at that.

333
00:24:16.090 --> 00:24:21.550
So now we're getting the same message that we were seeing in the stack trace from before.

334
00:24:22.180 --> 00:24:28.150
So we're getting the divide by zero, so that's at least giving us a little bit more of a hint of what

335
00:24:28.150 --> 00:24:29.770
exactly went wrong, right?

336
00:24:29.770 --> 00:24:35.170
Especially since now we're handling it all in the same code with the same single catch, right?

337
00:24:35.350 --> 00:24:41.170
And let's stop that particular error from occurring again by putting a one here and now.

338
00:24:41.170 --> 00:24:44.110
Let's let the other error kind of bubble through, right?

339
00:24:44.120 --> 00:24:45.790
So let's run this again.

340
00:24:46.210 --> 00:24:46.540
All right.

341
00:24:46.540 --> 00:24:50.950
And so now something went terribly wrong index three out of bounds for length.

342
00:24:51.340 --> 00:24:58.920
So at least with this approach, we're able to again kind of get an idea of what is actually going wrong,

343
00:24:58.930 --> 00:24:59.320
right?

344
00:25:00.920 --> 00:25:07.190
Now, we don't know what the exception type was, although we could determine that I suppose what we

345
00:25:07.190 --> 00:25:12.230
could do there is maybe, maybe we could change this to a print death.

346
00:25:13.850 --> 00:25:17.630
And let's see, let's just change this message.

347
00:25:18.620 --> 00:25:23.090
Exception type percent death.

348
00:25:27.740 --> 00:25:31.670
Message percent s.

349
00:25:32.000 --> 00:25:34.250
And a new line like that.

350
00:25:34.460 --> 00:25:36.920
And so now what we'll do is.

351
00:25:38.630 --> 00:25:43.850
So we can grab the type of the class exception that.

352
00:25:45.850 --> 00:25:46.810
Get class.

353
00:25:49.340 --> 00:25:50.600
And then a comma there.

354
00:25:51.780 --> 00:25:59.280
Now, this class is going to return a class, but since we're trying to assign it as a string, the

355
00:25:59.280 --> 00:26:04.200
JVM will call the two string method of the class okay.

356
00:26:04.200 --> 00:26:12.030
So I could explicitly just do that here, I could say to string, but I don't actually have to in this

357
00:26:12.030 --> 00:26:13.080
particular case.

358
00:26:13.500 --> 00:26:13.840
All right.

359
00:26:13.860 --> 00:26:15.260
And then the message there.

360
00:26:15.270 --> 00:26:17.070
So let's see how this works.

361
00:26:17.790 --> 00:26:18.120
All right.

362
00:26:18.120 --> 00:26:24.270
So exception type class array index out of bounds message index three out of bounds.

363
00:26:24.270 --> 00:26:28.320
And so now this is looking a lot like the stack trace that we were seeing before.

364
00:26:28.350 --> 00:26:30.630
Right now, I could even have both.

365
00:26:31.260 --> 00:26:36.750
I could have that there, and then I could also refer to the exception and then say, Prince backtrace,

366
00:26:36.750 --> 00:26:37.080
right?

367
00:26:37.650 --> 00:26:40.170
So we can we can do both here and we'll run that.

368
00:26:40.740 --> 00:26:45.330
So now we're getting our custom message as well as the stack trace, too.

369
00:26:45.720 --> 00:26:45.960
All right.

370
00:26:45.960 --> 00:26:49.080
So let's talk a little bit more about the Stack Trace business now.

371
00:26:50.070 --> 00:26:56.430
So these stack traces are actually quite helpful in this particular case, not so much, because there's

372
00:26:56.430 --> 00:26:58.530
no depth to what we're doing here.

373
00:26:59.190 --> 00:27:01.110
But let me show you this now.

374
00:27:01.380 --> 00:27:10.710
So if we were to take all of this code here and extract it out into a new method, and I will do an

375
00:27:10.710 --> 00:27:13.140
option command m for method.

376
00:27:13.380 --> 00:27:18.540
And I don't know, I will just call this second level.

377
00:27:20.000 --> 00:27:21.650
Well, actually, I should put a verb in here.

378
00:27:22.020 --> 00:27:25.100
I'll just call this do second level.

379
00:27:26.370 --> 00:27:27.000
Like that?

380
00:27:27.660 --> 00:27:28.080
OK.

381
00:27:28.590 --> 00:27:34.680
All right, so now what what I've done is I've created a new method with all of that code in it, right?

382
00:27:34.680 --> 00:27:36.450
All the try catch business here.

383
00:27:36.810 --> 00:27:41.280
But our main method is still going to be the starting point into our program.

384
00:27:41.280 --> 00:27:46.270
So the main method is going to start up and we're going to call this second level method.

385
00:27:46.290 --> 00:27:47.700
It's going to do its thing.

386
00:27:47.850 --> 00:27:54.540
And then if everything were to go right, then we'd wrap it up by returning from that do second level

387
00:27:54.540 --> 00:27:58.020
method and hit the and then execute line four.

388
00:27:58.050 --> 00:27:58.440
OK.

389
00:27:58.710 --> 00:28:01.050
So let's run this and see what what we get here.

390
00:28:02.980 --> 00:28:06.670
All right, so we did make it to the end.

391
00:28:07.510 --> 00:28:07.840
Right.

392
00:28:08.860 --> 00:28:11.510
However, we also got this stack trace.

393
00:28:11.800 --> 00:28:15.310
And if we look at the Stack Trace now, let's see what it's saying here.

394
00:28:16.060 --> 00:28:24.670
So we got that familiar output, but then we got at exception tests that do second level exception test

395
00:28:24.820 --> 00:28:27.190
Java 12, and then we see another line here.

396
00:28:27.370 --> 00:28:29.740
Exception tests dot main.

397
00:28:30.100 --> 00:28:35.860
So what this is showing us is the tracing of the path that our thread took.

398
00:28:35.980 --> 00:28:41.290
And again, I will remind you that a thread is just like this little guy who is actually stepping through

399
00:28:41.290 --> 00:28:47.890
each line of our program and executing those lines, and then he can jump to new lines as needed.

400
00:28:48.070 --> 00:28:54.040
So when our program is running, the thread will start at line to write and it'll it'll bring in, it'll

401
00:28:54.040 --> 00:28:57.850
carry in, so to speak, the any arguments that we passed in.

402
00:28:58.120 --> 00:29:03.040
Then it sees Line three do second level and it knows that this is a method call.

403
00:29:03.050 --> 00:29:09.160
So then the thread jumps down to line eight while line seven or eight.

404
00:29:09.580 --> 00:29:10.720
However, you want to look at it.

405
00:29:12.120 --> 00:29:15.480
And then it starts executing each of these lines.

406
00:29:15.510 --> 00:29:15.960
OK.

407
00:29:16.650 --> 00:29:24.060
All right, so it executes line 11 fine and then it gets down to Line 12, where we are trying to access

408
00:29:24.060 --> 00:29:30.990
an element of this array that does not exist, which causes the JVM to generate the exception.

409
00:29:31.230 --> 00:29:38.070
And so then the thread ends up jumping down to Line 14, where it executes this print death.

410
00:29:38.250 --> 00:29:40.410
And that's what we're seeing here.

411
00:29:40.590 --> 00:29:43.920
And then the thread is told to print the stack trace.

412
00:29:44.070 --> 00:29:46.590
Now this is a little bit of an interesting bit here.

413
00:29:47.490 --> 00:29:51.660
You would expect to see the stack trace next, right?

414
00:29:52.200 --> 00:29:59.430
Then the thread would jump back up to Line four because that's where it left off.

415
00:29:59.460 --> 00:30:01.620
In other words, it would return from this.

416
00:30:01.620 --> 00:30:09.210
Do second level method call and go back to line four and print you made it to the end.

417
00:30:09.600 --> 00:30:12.810
But what we're actually seeing is that the JVM is printing.

418
00:30:12.810 --> 00:30:18.490
You made it to the end before we are seeing this stack trace here.

419
00:30:18.510 --> 00:30:25.740
So just know that the way these stack traces are generated and the timing and order of the thread stuff,

420
00:30:25.950 --> 00:30:32.740
you should not expect that to print out in the exact order that you would intuitively assume it would.

421
00:30:32.760 --> 00:30:40.500
OK, just know that the other thing I want you to notice is that in this stack trace, we're seeing

422
00:30:40.920 --> 00:30:44.310
the most immediate method first.

423
00:30:44.970 --> 00:30:49.950
OK, so it's kind of like the most recently called method will be at the top.

424
00:30:49.960 --> 00:30:53.520
So it's kind of backward to how a lot of people will tend to think.

425
00:30:53.760 --> 00:31:00.390
And I've seen a lot of junior to intermediate developers who have been coding for a few years, and

426
00:31:00.390 --> 00:31:03.330
they seem to still not understand how to read a stack trace.

427
00:31:03.570 --> 00:31:05.970
So maybe like sometimes they'll kind of start at the bottom.

428
00:31:06.270 --> 00:31:13.440
Typically, though, with a stack trace, the line of code where the exception occurred will be at the

429
00:31:13.440 --> 00:31:13.860
top.

430
00:31:14.160 --> 00:31:15.210
And that would make sense, right?

431
00:31:15.210 --> 00:31:18.390
That's where you want to start is where did the problem begin?

432
00:31:18.600 --> 00:31:24.750
But sometimes you want to know, how did we get there, especially if that Stack Trace was generated

433
00:31:24.750 --> 00:31:29.310
due to certain parameters that were being passed in to the secondary method?

434
00:31:29.310 --> 00:31:30.540
And in fact, you know what?

435
00:31:30.810 --> 00:31:32.040
Let me simulate that.

436
00:31:32.250 --> 00:31:39.030
What I can do here is I can take this variable here and we can turn it into a parameter with an option

437
00:31:39.030 --> 00:31:40.140
command p.

438
00:31:40.590 --> 00:31:41.040
OK.

439
00:31:41.340 --> 00:31:46.560
So what I'm doing here is I'm telling the ADP to take this variable here that is currently local to

440
00:31:46.560 --> 00:31:53.130
this method and turn it into a parameter that gets passed into this method instead.

441
00:31:53.190 --> 00:31:53.640
OK.

442
00:31:53.880 --> 00:31:55.170
So I will hit enter.

443
00:31:55.740 --> 00:31:56.760
And so you see that.

444
00:31:56.970 --> 00:32:05.490
And NUM line just disappeared and got replaced as a parameter of this method.

445
00:32:05.670 --> 00:32:06.010
OK.

446
00:32:06.030 --> 00:32:08.430
And that's a really cool capability, by the way.

447
00:32:08.670 --> 00:32:14.010
And not only that, we were explicitly setting that value to a one.

448
00:32:14.310 --> 00:32:19.680
And now with the ad has done is it has come up here to where we're calling this method and it is passed

449
00:32:19.680 --> 00:32:21.030
in that same one.

450
00:32:21.060 --> 00:32:25.650
OK, so it knows that at the end of the day, we don't want any of the functionality to change.

451
00:32:25.650 --> 00:32:27.480
We just wanted to change how we're calling this.

452
00:32:27.690 --> 00:32:32.880
And so we've introduced this value of one here so that, you know, we're not actually functionally

453
00:32:32.880 --> 00:32:33.690
changing anything.

454
00:32:33.930 --> 00:32:39.300
But now having done that, if I change this to a zero.

455
00:32:40.550 --> 00:32:42.080
And then run this again.

456
00:32:43.340 --> 00:32:48.620
All right, so now with our stack trace, we see that we're getting a divide by zero.

457
00:32:48.890 --> 00:32:55.040
So the way that you'd want to use the stack trace to analyze this is you'd say, OK, we're getting

458
00:32:55.040 --> 00:33:00.680
a divide by zero where and so you'd see this very first line here and you'd click on that so you can

459
00:33:00.680 --> 00:33:04.640
actually click on that and it takes us right here to this line.

460
00:33:05.210 --> 00:33:05.720
OK.

461
00:33:07.430 --> 00:33:11.550
And so we can see, oh, so number is zero.

462
00:33:11.570 --> 00:33:17.750
And now we can see that that zero of NUM was passed in to the do second level method.

463
00:33:17.960 --> 00:33:24.440
Now it could be in some programs that lots of other methods may all be capable of calling this method.

464
00:33:24.710 --> 00:33:31.520
And in that case, you wouldn't necessarily know well which calling method was it that called this one

465
00:33:31.520 --> 00:33:32.930
and passed in a zero.

466
00:33:33.110 --> 00:33:38.570
And that's where the Stack Trace can be really, really helpful because you want to know which method

467
00:33:38.570 --> 00:33:43.130
was it that called me that passed in this bad information, right?

468
00:33:43.130 --> 00:33:44.120
This zero?

469
00:33:44.330 --> 00:33:49.850
And so you can come down here and see, well, the guy who called this one is this one here.

470
00:33:50.630 --> 00:33:52.860
The exception test main.

471
00:33:52.920 --> 00:33:53.200
OK.

472
00:33:53.220 --> 00:33:55.070
And it was called on line three.

473
00:33:55.220 --> 00:34:02.900
So now I can click on this and that takes me straight to Line three, where I can see, Ah, OK, someone

474
00:34:02.900 --> 00:34:06.110
explicitly passed a zero in.

475
00:34:06.170 --> 00:34:06.680
OK.

476
00:34:07.610 --> 00:34:08.960
So does that make sense?

477
00:34:09.200 --> 00:34:16.730
So we could have multiple methods defined in this class or in other classes that are all capable of

478
00:34:16.730 --> 00:34:18.620
calling this do second level?

479
00:34:18.800 --> 00:34:24.320
And some of those methods might pass in numbers that don't result in a divide by zero.

480
00:34:24.410 --> 00:34:26.420
But this particular method did.

481
00:34:26.540 --> 00:34:33.980
The main method did, and we'd want to know which method passed this in so that we can analyze and figure

482
00:34:33.980 --> 00:34:36.710
out how to stop that from happening again.

483
00:34:36.740 --> 00:34:41.810
OK, so let's talk a little bit more about these different types of exceptions.

484
00:34:42.050 --> 00:34:46.310
So far, we're looking at this array index out of bounds and the arithmetic exception.

485
00:34:46.640 --> 00:34:54.170
These two exceptions are actually both runtime exceptions, and that means that they don't actually

486
00:34:54.170 --> 00:34:55.610
have to be caught.

487
00:34:56.810 --> 00:35:03.020
As you already saw when we first started writing this, I'm going to just comment these out.

488
00:35:05.760 --> 00:35:10.110
Like so and there are no errors here right now.

489
00:35:10.140 --> 00:35:13.080
If I run this, it's going to blow up, of course.

490
00:35:13.470 --> 00:35:22.170
But my point here is that Java is not forcing me to surround any of these lines with a try catch block.

491
00:35:22.530 --> 00:35:24.570
And that is because of a couple of things.

492
00:35:24.600 --> 00:35:32.760
First off, the IED and Java do not know at this point in time that either of these calls could result

493
00:35:32.760 --> 00:35:33.870
in an exception.

494
00:35:34.020 --> 00:35:38.370
It won't know that until runtime when we're actually running the the code.

495
00:35:38.460 --> 00:35:44.160
And that's one of the reasons why the type of exceptions that can be thrown from these kinds of errors

496
00:35:44.460 --> 00:35:46.260
are runtime exceptions.

497
00:35:46.440 --> 00:35:49.800
They can't easily be known before you start running.

498
00:35:49.800 --> 00:35:55.380
I mean, a human could analyze this particular code and see that we're passing a zero in and we're about

499
00:35:55.380 --> 00:35:57.150
to try to do a divide by zero.

500
00:35:57.240 --> 00:35:58.680
And that is a no no.

501
00:35:58.840 --> 00:36:01.710
Yes, a human could analyze this and see that.

502
00:36:02.040 --> 00:36:06.390
But the JVM can't really see it until you actually do it.

503
00:36:06.630 --> 00:36:11.490
And there's no guarantee that every time you divide by this variable that it's always going to be zero.

504
00:36:11.520 --> 00:36:16.140
Like I said earlier, you can have additional methods that could call this passing and other things

505
00:36:16.140 --> 00:36:16.410
right.

506
00:36:16.860 --> 00:36:19.020
So that's runtime exceptions.
