WEBVTT
1
00:00:00.860 --> 00:00:01.400
All right.

2
00:00:01.610 --> 00:00:07.370
So moving along, there are some other character classes that we can learn, so we just learned about

3
00:00:07.370 --> 00:00:10.190
the square bracket character class, OK?

4
00:00:10.610 --> 00:00:19.520
There are lots of other character classes and shorthand that shorthand symbols we can use to specify

5
00:00:19.520 --> 00:00:22.220
our regular expressions or our patterns.

6
00:00:22.250 --> 00:00:22.670
OK.

7
00:00:22.940 --> 00:00:27.800
So another one that you'll use probably quite often.

8
00:00:28.100 --> 00:00:34.070
Let's say that we want to allow a three letter word.

9
00:00:34.460 --> 00:00:40.550
And we don't care what the letters are, but we just want to specify that we want to allow for a word

10
00:00:40.550 --> 00:00:43.240
that has three Latin letters.

11
00:00:43.250 --> 00:00:46.610
OK, and I'm going to specify specifically Latin letters, OK?

12
00:00:46.760 --> 00:00:49.100
Or word characters, even, OK?

13
00:00:49.130 --> 00:00:51.440
Characters that would typically be in a word.

14
00:00:51.530 --> 00:00:51.950
OK.

15
00:00:52.310 --> 00:01:00.470
Well, there's a symbol for that that we can use, which is backslash W, and that's the backslash lowercase

16
00:01:00.470 --> 00:01:04.670
W and that stands for word character.

17
00:01:04.940 --> 00:01:10.070
Now you'll notice, though, that as I have this backslash w here, I've got a squiggly line.

18
00:01:10.220 --> 00:01:16.220
And if I hover over that, the ad is telling me that there's an illegal escape character in string literal.

19
00:01:16.460 --> 00:01:23.330
And the problem here is that Java doesn't like by default that I've got this backslash here.

20
00:01:23.450 --> 00:01:26.450
That backslash has special meaning in Java.

21
00:01:26.630 --> 00:01:31.580
And so if I want to use that, which I need to, because that's what I need for the regular expression

22
00:01:31.580 --> 00:01:37.040
itself, I'm going to have to do what is called escaping that backslash.

23
00:01:37.130 --> 00:01:41.780
And the way I do that in Java is to simply use one more backslash.

24
00:01:41.900 --> 00:01:42.350
OK.

25
00:01:42.890 --> 00:01:51.020
And the reason I call this out is because if you go Google for more reading on regular expressions.

26
00:01:51.230 --> 00:01:53.090
First off, let me back up and just explain.

27
00:01:53.300 --> 00:01:58.940
So regular expressions are not something that is specific to the Java programming language.

28
00:01:59.060 --> 00:02:05.510
Regular expressions have existed for decades, and they transcend any particular programming language.

29
00:02:05.510 --> 00:02:12.020
And in fact, I would venture to say most modern programming languages these days have some support

30
00:02:12.020 --> 00:02:17.960
for regular expressions, but they will all utilize them slightly differently.

31
00:02:18.200 --> 00:02:24.500
So if you go Google for how to do various things with regular expressions or rejects, you will likely

32
00:02:24.500 --> 00:02:32.690
find examples where they are showing expressions that just use single back slashes unless those examples

33
00:02:32.690 --> 00:02:35.360
are specifically geared towards Java.

34
00:02:35.690 --> 00:02:41.240
And so you'll need to know that if you do find expressions on the internet that look like this with

35
00:02:41.240 --> 00:02:46.040
one single backslash, you'll need to put a second backslash.

36
00:02:46.040 --> 00:02:50.440
You'll need to escape those if you're going to paste them into Java code.

37
00:02:50.450 --> 00:02:50.810
OK?

38
00:02:51.230 --> 00:02:53.000
So just like that?

39
00:02:53.270 --> 00:02:53.540
All right.

40
00:02:53.550 --> 00:03:02.150
So now what we are saying is this pattern should match any string that contains one word character,

41
00:03:02.150 --> 00:03:05.300
followed by lowercase a lowercase T.

42
00:03:05.420 --> 00:03:05.840
OK.

43
00:03:06.080 --> 00:03:07.760
So if I run this now?

44
00:03:10.560 --> 00:03:14.790
That matches because L is one word character.

45
00:03:14.820 --> 00:03:15.270
OK.

46
00:03:15.660 --> 00:03:23.430
So any Latin character or letter is going to match in this position now plus underscore also the regular

47
00:03:23.430 --> 00:03:29.370
expression standard allows for an underscore to be treated essentially as a letter.

48
00:03:30.090 --> 00:03:36.780
I don't know why, but whoever came up with this decided that underscores should, should, should match

49
00:03:36.780 --> 00:03:37.200
that as well.

50
00:03:37.200 --> 00:03:45.180
But hyphen, if we use a hyphen here, that does not work because hyphen is not considered to be a word

51
00:03:45.180 --> 00:03:45.810
character.

52
00:03:46.080 --> 00:03:49.350
Also, within the range of word characters are numbers.

53
00:03:49.560 --> 00:03:53.220
OK, so I could put a single digit in here as well.

54
00:03:55.370 --> 00:03:56.360
And that's fine.

55
00:03:57.520 --> 00:04:04.090
Now again, I cannot use a two or three digit number or anything like that, because now my string is

56
00:04:04.090 --> 00:04:11.170
four characters long, whereas my regular expression is only expecting a string of three characters

57
00:04:11.170 --> 00:04:11.530
here.

58
00:04:11.570 --> 00:04:14.320
OK, so that won't work.

59
00:04:15.960 --> 00:04:22.410
All right, now, I can use this shorthand for word character multiple times as well.

60
00:04:22.710 --> 00:04:25.890
So I could get rid of the A and T and I could just do.

61
00:04:28.520 --> 00:04:28.880
Right.

62
00:04:28.970 --> 00:04:36.740
So now I'm saying match on any string that is three word characters long.

63
00:04:37.040 --> 00:04:37.360
Right?

64
00:04:37.370 --> 00:04:39.920
So that, of course, will match.

65
00:04:42.430 --> 00:04:47.590
And because the underscore is considered a word character, I could have three underscores.

66
00:04:51.040 --> 00:04:51.400
Right.

67
00:04:51.580 --> 00:04:54.100
And of course, I can have any combination.

68
00:05:00.020 --> 00:05:00.420
OK.

69
00:05:00.440 --> 00:05:02.420
So I think you get the you get the idea.

70
00:05:05.060 --> 00:05:11.480
So there are a number of these shorthand character classes that we can use besides just one four word

71
00:05:11.480 --> 00:05:12.080
characters.

72
00:05:12.380 --> 00:05:20.260
There's something that represents numbers or digits as well, and that is slash the backslash D.

73
00:05:20.390 --> 00:05:20.900
OK.

74
00:05:21.140 --> 00:05:23.300
So same basic idea.

75
00:05:23.480 --> 00:05:28.100
So if I do a one here or yeah, and I run this.

76
00:05:29.540 --> 00:05:32.480
That matches, but if I do a z here.

77
00:05:35.640 --> 00:05:36.810
That does not match.

78
00:05:36.960 --> 00:05:44.610
Now you may be scratching your head and let me just make it clear word characters do allow for letters,

79
00:05:44.940 --> 00:05:46.980
numbers and underscore.

80
00:05:47.960 --> 00:05:54.380
But digit or no character class only allows for numbers.

81
00:05:54.410 --> 00:05:56.480
OK, so there is a little bit of overlap there.

82
00:05:56.510 --> 00:05:58.010
Just want to be clear on that?

83
00:05:58.910 --> 00:06:03.140
OK, so then we could have multiples of these.

84
00:06:08.090 --> 00:06:12.350
Like so and that will that should match.

85
00:06:13.040 --> 00:06:17.090
And then, of course, if we substitute out one of those for a letter.

86
00:06:20.600 --> 00:06:22.400
Now, we don't have a match anymore.

87
00:06:22.490 --> 00:06:22.880
OK.

88
00:06:23.600 --> 00:06:27.020
So I think that's hopefully making good sense to you.

89
00:06:27.170 --> 00:06:29.780
We're still in the pretty simple examples here.

90
00:06:29.810 --> 00:06:32.540
Don't worry, though, it's going to start ratcheting up a little bit.

91
00:06:34.410 --> 00:06:39.360
OK, so now let's say we wanted to match a phone number, right?

92
00:06:39.390 --> 00:06:42.420
And that's one of the examples where we're heading towards anyway.

93
00:06:42.430 --> 00:06:53.760
So let's say we had a phone number like three to one hyphen three three three seven six five two.

94
00:06:54.120 --> 00:06:54.570
OK.

95
00:06:55.590 --> 00:06:56.040
All right.

96
00:06:56.490 --> 00:07:02.670
So obviously, this should not match because our expression is only calling for three digits and now

97
00:07:02.670 --> 00:07:07.050
we've got was that 10 digits plus a couple of hyphens as well.

98
00:07:07.080 --> 00:07:07.470
Right.

99
00:07:07.890 --> 00:07:10.380
So how can we match this?

100
00:07:10.620 --> 00:07:15.720
I'd like you to take a moment to see if you can figure out how to make an expression that would match

101
00:07:15.810 --> 00:07:20.370
this phone number and get back with you in just a second.

102
00:07:22.790 --> 00:07:32.060
OK, so the simplest thing we could probably do is a combination of the digit shorthand plus a string

103
00:07:32.060 --> 00:07:41.450
literal, so I'm going to literally put a hyphen there, followed by the right and then another hyphen

104
00:07:41.450 --> 00:07:44.680
and then four more of these three.

105
00:07:44.790 --> 00:07:45.290
Four.

106
00:07:46.010 --> 00:07:47.780
Let's see if that matches.

107
00:07:49.730 --> 00:07:50.690
Yes, it does.

108
00:07:50.780 --> 00:07:51.200
OK.

109
00:07:51.620 --> 00:07:58.670
So, yeah, so kind of, you know, it's a little it's a little verbose, but it's very clear as to

110
00:07:58.670 --> 00:08:00.350
what we're trying to do here, right?

111
00:08:00.590 --> 00:08:06.110
Match three numbers followed by a hyphen, followed by three more numbers by a hyphen, followed by

112
00:08:06.110 --> 00:08:07.270
four numbers.

113
00:08:07.460 --> 00:08:09.410
And that's exactly what we have here.

114
00:08:09.590 --> 00:08:11.660
And so that matches perfectly well.

115
00:08:13.190 --> 00:08:21.170
OK, so now what if we're lazy and we don't we don't want to have to keep repeating a million shades

116
00:08:21.170 --> 00:08:23.360
or double use or whatever, right?

117
00:08:23.510 --> 00:08:31.580
Well, we can also use something called a quantifier in regular expressions so that we can quantify

118
00:08:31.580 --> 00:08:38.000
how many times we want a particular pattern or expression or character class to match.

119
00:08:38.210 --> 00:08:44.990
And so instead of having to explicitly write out all of these D's here, we could do this.

120
00:08:44.990 --> 00:08:51.860
Instead, we can get rid of the duplicates there and we can use the curly brace and then the number

121
00:08:51.860 --> 00:08:54.560
of times we want that match to happen.

122
00:08:54.710 --> 00:09:03.920
So in this case, we expect three digits there and then C, we'll get rid of these in three digits there

123
00:09:04.940 --> 00:09:10.790
and then we want four of those.

124
00:09:11.090 --> 00:09:13.100
And so now if we run this again.

125
00:09:14.810 --> 00:09:15.530
We get true.

126
00:09:16.070 --> 00:09:23.300
All right, so now we're telling the regular expression engine to match on any string that contains

127
00:09:23.300 --> 00:09:33.170
a pattern of three digits, followed by a hyphen followed by three digits, followed by a hyphen, followed

128
00:09:33.170 --> 00:09:34.520
by four digits.

129
00:09:35.520 --> 00:09:38.550
And that's exactly the pattern that we have here.

130
00:09:39.210 --> 00:09:42.660
And we can test this out a little bit more, let's put it like the.

131
00:09:42.690 --> 00:09:47.340
I don't know what that is even called the long distance thingy right in North America.

132
00:09:47.670 --> 00:09:54.480
So if we try this pattern, we get a false because obviously our regular expression is not expecting

133
00:09:54.480 --> 00:10:00.180
us to have a leading single digit, followed by a hyphen.

134
00:10:00.180 --> 00:10:03.610
So it's not allowing for that particular pattern at this time.

135
00:10:03.630 --> 00:10:03.960
Right?

136
00:10:04.440 --> 00:10:07.290
So again, pretty, I think, pretty straightforward, right?

137
00:10:07.620 --> 00:10:13.590
And now we saved ourselves a little bit of hyping as well with all those duplicated ads all over the

138
00:10:13.590 --> 00:10:14.130
place.

139
00:10:15.280 --> 00:10:19.090
OK, now what if we also wanted to meet me?

140
00:10:19.360 --> 00:10:20.830
Let me put this back the way it was.

141
00:10:21.040 --> 00:10:24.250
Now what if we also wanted to allow for?

142
00:10:24.250 --> 00:10:28.120
I don't know, not just hyphens, but let's say periods.

143
00:10:29.690 --> 00:10:30.050
Right.

144
00:10:30.320 --> 00:10:33.440
Sometimes you see phone numbers entered in that way.

145
00:10:33.680 --> 00:10:35.010
So if we wanted to allow that?

146
00:10:35.030 --> 00:10:36.560
Well, let's first try this out.

147
00:10:38.850 --> 00:10:45.120
OK, so that does not match anymore, because we have periods here in our expression is expecting hyphens

148
00:10:45.120 --> 00:10:46.440
where those periods are.

149
00:10:47.070 --> 00:10:52.020
What if we wanted to allow either write the hyphens or periods?

150
00:10:52.320 --> 00:10:55.890
Can you think of how to do that with what we've learned so far?

151
00:10:55.980 --> 00:10:57.390
I'm going to give you a few moments.

152
00:10:59.660 --> 00:11:07.850
OK, so well, we did learn at the beginning of the lesson a way that we could test for one character

153
00:11:07.880 --> 00:11:09.890
or another character, right?

154
00:11:09.920 --> 00:11:11.210
Do you remember what that was?

155
00:11:11.720 --> 00:11:14.330
That was the square bracket character class, right?

156
00:11:14.570 --> 00:11:20.510
So we had these square brackets just like this, and I'm going to go and just put these in place first

157
00:11:20.510 --> 00:11:23.000
before I completely solve this, right?

158
00:11:23.180 --> 00:11:24.440
So we'll start off with that.

159
00:11:25.190 --> 00:11:25.610
OK.

160
00:11:25.760 --> 00:11:29.420
So what we can do here is we can tell it.

161
00:11:29.660 --> 00:11:39.500
We want to match at this location in the string, a hyphen or a period just like this, and I'm going

162
00:11:39.500 --> 00:11:41.500
to put one here as well, right?

163
00:11:41.510 --> 00:11:48.920
Because whatever is inside of these square brackets by default has the implication of matching whatever

164
00:11:48.920 --> 00:11:53.250
character or the other character or characters within the square brackets.

165
00:11:53.250 --> 00:11:55.340
So you're implying or right?

166
00:11:56.550 --> 00:11:57.810
Either or rather.

167
00:11:58.320 --> 00:11:58.620
All right.

168
00:11:58.650 --> 00:12:00.630
And so now if we run this.

169
00:12:02.480 --> 00:12:11.390
We get a match for these periods, and then if we change these periods back to hyphens and run that.

170
00:12:13.560 --> 00:12:15.960
That works also, right?

171
00:12:16.970 --> 00:12:22.670
So either of those and then let's try a negative case, though let's do common.

172
00:12:25.780 --> 00:12:26.770
Let's run that.

173
00:12:28.510 --> 00:12:29.080
False.

174
00:12:29.110 --> 00:12:34.600
So, yeah, it's not allowing us to use commas there, only hyphen or period now, of course, if we

175
00:12:34.600 --> 00:12:39.790
wanted to use to be to allow for commas as well, we could just add that in as well, right?

176
00:12:40.120 --> 00:12:42.550
We could put that in here and now run this.

177
00:12:44.920 --> 00:12:51.040
Bam, and now we've got commas, and then you could mix and match as well, so I can have a hyphen in

178
00:12:51.040 --> 00:12:54.460
the first place in a common the second place and this should work.

179
00:12:56.020 --> 00:13:02.590
Right, because there's two of these bracketed expressions here, so either any of those characters

180
00:13:02.590 --> 00:13:05.980
within the bracket expressions for either of these expressions is fine.

181
00:13:06.130 --> 00:13:06.430
Right?

182
00:13:06.640 --> 00:13:08.440
So any combination of those?

183
00:13:08.890 --> 00:13:09.310
All right.

184
00:13:10.030 --> 00:13:12.220
In fact, now there's one more scenario.

185
00:13:12.460 --> 00:13:17.200
Sometimes you might maybe even see phone numbers with just spaces.

186
00:13:17.200 --> 00:13:21.940
Maybe I don't know, especially like in some foreign countries, perhaps where they just have a slightly

187
00:13:21.940 --> 00:13:25.120
different standard for how they specify their phone numbers.

188
00:13:25.330 --> 00:13:28.600
So what if we wanted to allow for a space, right?

189
00:13:28.840 --> 00:13:30.310
How could we do that?

190
00:13:30.950 --> 00:13:31.390
Well.

191
00:13:32.380 --> 00:13:36.250
You could try this where you just put a space in here.

192
00:13:37.060 --> 00:13:39.220
Let's let's see what happens when we do that.

193
00:13:42.090 --> 00:13:46.200
OK, so it seems to be OK with that, right?

194
00:13:46.710 --> 00:13:53.340
However, I'm going to just tell you now that's probably not the greatest way to do this, because it's

195
00:13:53.340 --> 00:14:01.080
a little difficult to see visually that one of the characters that you're allowing for is just a space.

196
00:14:01.440 --> 00:14:09.360
And so in regular expression engines, there is a shorthand that actually means a space character.

197
00:14:09.540 --> 00:14:11.370
And can you guess what that might be?

198
00:14:11.400 --> 00:14:14.910
So word characters are w digit characters or.

199
00:14:15.750 --> 00:14:17.520
What do you think a space character will be?

200
00:14:19.430 --> 00:14:23.750
OK, so if you guessed backslash, yes, you would be correct.

201
00:14:23.960 --> 00:14:31.670
And so we can be a little more explicit here and put a backslash, yes, although because we're in Java,

202
00:14:31.790 --> 00:14:34.310
we have to use two back slashes, right?

203
00:14:34.880 --> 00:14:36.760
And then we run this again.

204
00:14:38.560 --> 00:14:39.200
All right, cool.

205
00:14:39.220 --> 00:14:48.100
So that still works, so now we can allow for commas and spaces and hyphens and periods.

206
00:14:52.450 --> 00:14:52.810
Right.

207
00:14:53.080 --> 00:15:00.080
And so maybe now you're beginning to get a deeper sense of the power of regular expressions.

208
00:15:00.100 --> 00:15:07.840
It is in their ability to be highly flexible and yet still constrain what you are allowed to match on

209
00:15:07.840 --> 00:15:11.030
or to to check against with text.

210
00:15:11.050 --> 00:15:11.440
Right?

211
00:15:12.160 --> 00:15:19.180
OK, so now what if we have an arbitrary number of spaces separating these sections?

212
00:15:19.180 --> 00:15:24.100
So what if you know, by accident, somebody typed a few too many spaces in here?

213
00:15:24.220 --> 00:15:25.450
So if we run this?

214
00:15:27.850 --> 00:15:36.580
Now we get a false and the reason is because we're only expecting up to one space or period or a comma

215
00:15:36.580 --> 00:15:39.610
or hyphen in these places here, right?

216
00:15:39.640 --> 00:15:41.950
Only one that we are expecting.

217
00:15:42.160 --> 00:15:48.310
So what if we wanted to allow for the possibility that you could have multiple of those in here?

218
00:15:48.310 --> 00:15:50.440
And mostly I'm referring to spaces.

219
00:15:50.740 --> 00:15:53.350
But whatever whatever you want it to be.

220
00:15:53.500 --> 00:15:58.300
Well, for that scenario, we have another type of quantifier that we can use.

221
00:15:58.300 --> 00:16:01.390
We have another set of quanta fires that we could use.

222
00:16:01.630 --> 00:16:11.920
So if you want to allow for the possibility of one or more spaces, one way that we could do that is

223
00:16:12.250 --> 00:16:19.000
right outside of our square bracket, just as we were putting these curly braces and then a number here

224
00:16:19.180 --> 00:16:26.140
right outside of the square bracket, if we want to allow for one or more of the things that are inside

225
00:16:26.140 --> 00:16:27.400
of the square brackets.

226
00:16:28.430 --> 00:16:37.580
We can do a plus symbol here, so that means one or more of the character class that is in front of

227
00:16:37.580 --> 00:16:45.140
that plus symbol in this case, just as this means three of whatever is in front of it.

228
00:16:45.470 --> 00:16:46.910
So in this case, three digits.

229
00:16:47.240 --> 00:16:50.870
So here we're saying one or more.

230
00:16:52.850 --> 00:16:56.750
Of any of those characters that are in this square bracket here.

231
00:16:57.050 --> 00:16:57.470
OK.

232
00:16:57.740 --> 00:17:00.260
And so we can put another one here.

233
00:17:00.290 --> 00:17:06.740
Now I understand this is starting to look a little difficult to read, and that is one major downside

234
00:17:06.740 --> 00:17:08.240
to regular expressions.

235
00:17:08.240 --> 00:17:15.200
And probably one of the reasons why a lot of programmers, especially more junior to intermediate programmers,

236
00:17:15.200 --> 00:17:18.590
may tend to be somewhat intimidated by their use.

237
00:17:18.890 --> 00:17:25.520
They're really great at encoding a whole lot of rules of how you want to match things very concisely,

238
00:17:25.790 --> 00:17:32.270
but they can quickly turn into something that isn't real easy to read and decode for a human.

239
00:17:32.600 --> 00:17:39.200
And part of the reason for that is because the conciseness of of a regular expression is a language

240
00:17:39.200 --> 00:17:40.010
in and of itself.

241
00:17:40.020 --> 00:17:45.890
This is a computer language, really, and one might argue it's intended to be a little easier to be

242
00:17:45.890 --> 00:17:48.050
read by the computer than by humans.

243
00:17:48.560 --> 00:17:53.930
But, you know, take your time and just kind of pass it through, and hopefully you can understand

244
00:17:53.930 --> 00:17:56.750
what you're seeing, especially if you're the one making it.

245
00:17:57.650 --> 00:17:57.950
All right.

246
00:17:57.950 --> 00:18:01.040
So now that we've got this plus here, let's run this again.

247
00:18:03.830 --> 00:18:04.880
And now we get a true.

248
00:18:05.810 --> 00:18:12.560
So now, as long as I have one or more of any of these characters in either of these places, it's always

249
00:18:12.560 --> 00:18:13.400
going to match.

250
00:18:13.650 --> 00:18:15.120
I'll put one.

251
00:18:15.140 --> 00:18:17.630
I'll go back down to one and run this again.

252
00:18:19.900 --> 00:18:20.230
OK.

253
00:18:20.380 --> 00:18:23.620
However, what if I don't have a space there?

254
00:18:26.660 --> 00:18:30.800
All right, because sometimes people will enter a phone number with no spaces at all.

255
00:18:34.100 --> 00:18:35.600
And now I'm getting a false.

256
00:18:35.840 --> 00:18:43.820
So what if I want to allow for the possibility of zero of these dividing characters, including a space

257
00:18:44.060 --> 00:18:46.070
or as many as you want?

258
00:18:46.310 --> 00:18:48.320
What if I want that zero or more?

259
00:18:48.470 --> 00:18:54.020
Well, there's a character that represents zero or more also, so the plus means one or more.

260
00:18:54.200 --> 00:18:58.460
But if I want zero or more, I can use an asterisk.

261
00:18:59.270 --> 00:19:04.550
OK, so that's what that's what you can use for that situation and asterisk.

262
00:19:04.580 --> 00:19:09.290
So that means zero or more of the characters proceeding.

263
00:19:10.790 --> 00:19:20.120
So now in this case, I have three digits, three, two, one, followed by zero of any of these things

264
00:19:20.120 --> 00:19:21.170
here, right?

265
00:19:23.260 --> 00:19:30.880
Followed by three more digits, followed by zero spaces or hyphens or commas, followed by four digits.

266
00:19:30.880 --> 00:19:31.930
So if I run this.

267
00:19:35.010 --> 00:19:35.940
That matches.

268
00:19:36.240 --> 00:19:39.120
However, if I put one space in here and run it.

269
00:19:41.520 --> 00:19:42.780
That also matches.

270
00:19:43.080 --> 00:19:48.870
OK, and then if I put a bunch of spaces on the on the in between the three and the four digits and

271
00:19:48.870 --> 00:19:49.620
run that.

272
00:19:51.610 --> 00:19:52.990
That also matches.

273
00:19:53.320 --> 00:19:59.500
OK, so again, you're starting to see the real power and flexibility of of regular expressions, right?

274
00:20:00.010 --> 00:20:02.080
You can just do so much with them.

275
00:20:02.320 --> 00:20:08.410
And just to be clear here, let's put, I don't know, let's put a z here and try that.

276
00:20:11.020 --> 00:20:13.840
That's false, right, because, yeah, Z.

277
00:20:14.750 --> 00:20:22.370
Is not zero or more of a hyphen period comma or space, right, so so the regular expression engine

278
00:20:22.370 --> 00:20:24.000
is smart enough to understand.

279
00:20:24.020 --> 00:20:28.250
Nope, that's not matching the pattern that you have specified here.

280
00:20:28.400 --> 00:20:28.780
OK.

281
00:20:28.910 --> 00:20:31.670
So get rid of that Z, and I'll put a space back in there.

282
00:20:31.790 --> 00:20:36.020
And also, let's just go back to a more traditional pattern.

283
00:20:36.230 --> 00:20:37.850
Just make sure that still works.

284
00:20:39.410 --> 00:20:39.840
Yes.

285
00:20:39.860 --> 00:20:41.810
So hyphens still work.

286
00:20:42.830 --> 00:20:49.760
And while we're at it, there's at least one more common pattern for quanta fires that you may want

287
00:20:49.760 --> 00:20:50.040
to use.

288
00:20:50.060 --> 00:20:56.870
What if we only want to allow for zero or one of these dividing characters?

289
00:20:56.900 --> 00:20:59.660
So not multiple, just zero or one?

290
00:20:59.930 --> 00:21:02.690
There's a special character for that situation as well.

291
00:21:02.840 --> 00:21:08.390
So we've learned that plus symbol allows for one or more asterisk.

292
00:21:08.390 --> 00:21:11.150
Symbol allows for zero or more.

293
00:21:11.300 --> 00:21:13.820
And now we want zero or just one.

294
00:21:13.850 --> 00:21:14.360
OK.

295
00:21:14.630 --> 00:21:17.960
So you can have one or you can have none, but you can't have more than one.

296
00:21:18.380 --> 00:21:20.990
For that, you'll use question mark.

297
00:21:23.110 --> 00:21:26.990
Some putting the question mark in there, and I will run this now.

298
00:21:27.010 --> 00:21:28.150
So this will work.

299
00:21:29.480 --> 00:21:29.840
Right.

300
00:21:30.290 --> 00:21:33.770
And I can have nothing here, that's zero.

301
00:21:34.400 --> 00:21:35.180
And I'll run it.

302
00:21:37.080 --> 00:21:42.870
And that will work, but I can't have one to two spaces.

303
00:21:46.330 --> 00:21:49.840
That doesn't work because it's two spaces now if I have one space.

304
00:21:53.010 --> 00:21:53.700
That's fine.

305
00:21:53.970 --> 00:22:02.880
OK, so a question mark means zero matches or one match, but not more than one.

306
00:22:03.090 --> 00:22:03.450
OK.

307
00:22:03.870 --> 00:22:09.540
Also, one other thing I want to show with these numerical quantify errors is you can put some more

308
00:22:09.540 --> 00:22:10.500
inputs in here.

309
00:22:10.740 --> 00:22:16.560
So in this particular case, we're saying we want to allow for three digit numbers.

310
00:22:16.800 --> 00:22:22.050
What if you're in a country where and I don't know if this is even a thing, some kind of contriving

311
00:22:22.050 --> 00:22:22.290
this.

312
00:22:22.560 --> 00:22:31.680
Let's say you're in a country where this last bit here could be three or four digits long.

313
00:22:31.920 --> 00:22:33.990
Either one would be acceptable.

314
00:22:34.020 --> 00:22:36.420
OK, how could we do that?

315
00:22:36.990 --> 00:22:44.040
Now, this curly brace quantifier format here can allow for some additional things.

316
00:22:44.160 --> 00:22:48.240
So what we can do is we can tell at a minimum and a maximum range, OK?

317
00:22:48.330 --> 00:22:50.460
Right now we're telling it an exact range.

318
00:22:50.470 --> 00:22:54.060
We just want exactly four digits, but we could tell it.

319
00:22:54.060 --> 00:22:56.880
We want between three to four digits.

320
00:22:56.880 --> 00:23:03.530
And the way to do that is just to start with the minimal minimum, which is three and then a comma there.

321
00:23:03.540 --> 00:23:11.310
OK, and now we're saying we will allow for three to four digits here on this last match.

322
00:23:11.640 --> 00:23:15.780
OK, so first we'll run this and just make sure this is still working.

323
00:23:16.970 --> 00:23:19.520
OK, so we still get a match there, that's true.

324
00:23:19.790 --> 00:23:24.710
But now if we reduce this down to three digits and run this.

325
00:23:26.760 --> 00:23:28.560
That also works, right?

326
00:23:28.950 --> 00:23:30.930
But if we make it five digits.

327
00:23:36.250 --> 00:23:37.660
That no longer matches.

328
00:23:38.020 --> 00:23:38.390
Right?

329
00:23:38.410 --> 00:23:39.250
That's too many.

330
00:23:39.400 --> 00:23:39.710
Right.

331
00:23:39.730 --> 00:23:43.990
So it has to be between three and four, according to our regular expression here.

332
00:23:44.170 --> 00:23:44.440
All right.

333
00:23:44.560 --> 00:23:47.200
And then likewise, if we only have two digits.

334
00:23:50.830 --> 00:23:52.690
That also does not match.

335
00:23:52.780 --> 00:23:55.060
OK, now I'm going to put this back.

336
00:23:56.430 --> 00:24:00.630
Two four digits for a typical North American phone number.

337
00:24:02.250 --> 00:24:06.060
Like so, but I just wanted to show that you can have.

338
00:24:06.180 --> 00:24:13.830
Oh, and we can also say things like you could just specify one or the other as well.

339
00:24:13.830 --> 00:24:21.870
So you could say I want to allow for a minimum of three digits with no upper limit, so I can put this

340
00:24:21.870 --> 00:24:24.320
comma here and not specify that second number.

341
00:24:24.330 --> 00:24:28.410
So this is saying it has to be at least three digits long.

342
00:24:28.650 --> 00:24:31.680
But there's no upper limit to how long it can be.

343
00:24:31.710 --> 00:24:33.360
OK, so now if I run this?

344
00:24:36.590 --> 00:24:37.490
This is true.

345
00:24:39.050 --> 00:24:43.130
And if I put this many digits here.

346
00:24:45.440 --> 00:24:47.390
This also works now, OK?

347
00:24:47.720 --> 00:24:50.330
But if I only have to.

348
00:24:51.550 --> 00:24:52.390
Digits here.

349
00:24:56.750 --> 00:25:04.460
That does not match because I said here I want a minimum of three digits on this last little bit here.

350
00:25:04.820 --> 00:25:05.300
OK.

351
00:25:06.080 --> 00:25:07.190
Just this last bit.

352
00:25:07.280 --> 00:25:11.640
Now I can put that anywhere, by the way, but I have these three groupings of digits here.

353
00:25:11.640 --> 00:25:16.670
File are separated by spaces or hyphens or periods, commas, whatever, right?

354
00:25:16.670 --> 00:25:19.370
So I'm only dealing with this last little bit here.

355
00:25:19.580 --> 00:25:22.850
So I'm saying that that has to be at least three digits long.

356
00:25:23.690 --> 00:25:24.030
All right.

357
00:25:24.050 --> 00:25:28.520
And I think for one of the last things that we're going to go through in this particular lesson, which

358
00:25:28.520 --> 00:25:36.380
will set us up for the next lesson, by the way, there's one more thing here that you may want to know,

359
00:25:36.380 --> 00:25:40.070
and that is notice here in our phone number pattern.

360
00:25:40.100 --> 00:25:46.910
We allow three digits, followed by some separator, followed by three digits, followed by some separator,

361
00:25:46.910 --> 00:25:48.320
followed by four digits.

362
00:25:48.530 --> 00:25:52.370
So in other words, we're we're using the same pattern twice here.

363
00:25:52.670 --> 00:26:01.040
What if we don't want to have to specify here three digits followed by all of this zero or zero or one?

364
00:26:01.640 --> 00:26:04.040
And then do all of that again, right?

365
00:26:04.220 --> 00:26:08.060
What if we want to kind of be a little bit lazier here?

366
00:26:08.330 --> 00:26:13.080
Well, we could get rid of all of this.

367
00:26:13.100 --> 00:26:18.680
The second pattern here, right, which is a duplication of the first pattern.

368
00:26:18.800 --> 00:26:20.630
One hundred percent duplication, right?

369
00:26:21.050 --> 00:26:23.420
So we could get rid of this.

370
00:26:24.850 --> 00:26:28.660
And what we could do is to group all of this.

371
00:26:28.900 --> 00:26:34.330
And the way to do that, we could just put a parentheses here.

372
00:26:34.390 --> 00:26:39.410
Let me start at the beginning of it, though, so I'm going to put an opening parentheses here and then

373
00:26:39.410 --> 00:26:41.320
I'm going to go to the end of this pattern.

374
00:26:42.420 --> 00:26:47.040
And I'm going to put a closing parentheses right there, so now I'm I'm grouping.

375
00:26:48.350 --> 00:26:50.330
All of that right there.

376
00:26:50.360 --> 00:26:55.490
These digits, plus whatever separator there is going to be there as well, right?

377
00:26:55.500 --> 00:26:56.570
I'm grouping all of that.

378
00:26:56.720 --> 00:27:04.040
And now I can put a quantifier on the end of this grouping to simply say, let me match that two times.

379
00:27:04.250 --> 00:27:06.410
So right, here is the end of this grouping.

380
00:27:06.410 --> 00:27:09.860
And now I can put a quantifier and say to.

381
00:27:11.590 --> 00:27:12.490
Just like that.

382
00:27:12.700 --> 00:27:19.810
So now I'm saying matched this pattern, this type of pattern three digits, followed by a separator

383
00:27:19.810 --> 00:27:28.240
of a hyphen period comma or space two times, which is what I have here three digits and a space followed

384
00:27:28.240 --> 00:27:30.100
by three digits and a space, right?

385
00:27:30.100 --> 00:27:32.080
So I have that pattern two times.

386
00:27:32.080 --> 00:27:38.950
So I can just make that pattern one time here in the expression in the rejects and then say match that

387
00:27:38.950 --> 00:27:41.290
two times or however many times, right?

388
00:27:41.500 --> 00:27:43.120
And so now if I run this.

389
00:27:46.320 --> 00:27:49.170
I get a match right that that works.

390
00:27:50.880 --> 00:27:56.430
Now, if I get rid of that pattern and only have have it one time and run this.

391
00:27:58.930 --> 00:28:00.760
Now, that's not matching anymore.

392
00:28:01.210 --> 00:28:06.310
Now let's say I want to allow for this because in North America, this is a legitimate phone number

393
00:28:06.310 --> 00:28:09.010
for a local number, right, just seven digits.

394
00:28:09.280 --> 00:28:14.230
So if I wanted to allow for either of those scenarios, what could I do?

395
00:28:15.740 --> 00:28:25.280
OK, so I could say that I want to allow up to two matches of that pattern, and the way I can do that

396
00:28:25.880 --> 00:28:31.100
is to simply say one comma two just like that, right?

397
00:28:31.310 --> 00:28:35.600
So now I'm saying I will allow to match this pattern once or twice.

398
00:28:36.170 --> 00:28:37.700
So now if I run this?

399
00:28:39.880 --> 00:28:40.840
I get a true.

400
00:28:41.470 --> 00:28:42.550
And then if I.

401
00:28:45.430 --> 00:28:46.180
Do this.

402
00:28:48.750 --> 00:28:50.340
That also works right?

403
00:28:50.580 --> 00:28:55.260
And then I can still come back in here, and I haven't used the period in a while, so we'll do the

404
00:28:55.260 --> 00:28:56.640
period version of this.

405
00:29:00.070 --> 00:29:00.430
Right.

406
00:29:00.760 --> 00:29:03.820
So all of these scenarios work now.

407
00:29:04.030 --> 00:29:06.190
And just I don't know, I just kind of for grins.

408
00:29:06.190 --> 00:29:08.950
I want to go back one more time to the seven digit version.

409
00:29:09.680 --> 00:29:09.990
Yep.

410
00:29:10.000 --> 00:29:12.310
So that that works to undo that.

411
00:29:12.670 --> 00:29:13.030
All right.

412
00:29:13.270 --> 00:29:19.090
So I know again, I know these expressions can start to look really unwieldy and you really need to

413
00:29:19.090 --> 00:29:19.720
pay attention.

414
00:29:19.870 --> 00:29:24.010
So what I like to do is just kind of start at the beginning and go slowly so I can see there that I've

415
00:29:24.010 --> 00:29:24.830
got OK.

416
00:29:24.880 --> 00:29:26.570
Digits, three digits.

417
00:29:26.570 --> 00:29:35.080
So then I come over here and say, OK, there's my three digits, followed by either a hyphen, a period,

418
00:29:35.320 --> 00:29:37.990
a comma or a space.

419
00:29:39.580 --> 00:29:48.970
And I've got a period here, so I know that that matched and I'm looking for zero or one of whatever

420
00:29:48.970 --> 00:29:50.560
that was right.

421
00:29:50.560 --> 00:29:52.270
And I've got one here.

422
00:29:53.630 --> 00:29:59.570
And then this whole entire pattern matched once or twice.

423
00:30:00.860 --> 00:30:02.600
And so here it is again.

424
00:30:03.500 --> 00:30:04.670
Followed by.

425
00:30:06.080 --> 00:30:07.790
Four digits.

426
00:30:08.660 --> 00:30:10.790
And that's what I've got here.

427
00:30:11.510 --> 00:30:11.960
OK.

428
00:30:13.270 --> 00:30:19.780
And so that's how you can kind of read these expressions and break them down into smaller, bite sized

429
00:30:19.780 --> 00:30:20.530
pieces.

430
00:30:22.330 --> 00:30:22.670
All right.

431
00:30:22.690 --> 00:30:26.390
So now I want to give you one more tiny challenge.

432
00:30:27.190 --> 00:30:31.180
How could you make an expression that would accept?

433
00:30:32.940 --> 00:30:37.830
One more number in front, again, if you're familiar with North American phone numbers.

434
00:30:38.040 --> 00:30:42.210
Typically, you'd actually have to dial one and then the rest of the digits, right?

435
00:30:42.510 --> 00:30:45.560
So how could you make an expression that would allow for this?

436
00:30:45.570 --> 00:30:46.230
Take a moment?

437
00:30:48.310 --> 00:30:54.130
OK, so really, you can pretty much just use what we already have here.

438
00:30:54.160 --> 00:30:54.550
Right.

439
00:30:54.640 --> 00:30:57.160
In fact, I think I will exactly do that.

440
00:30:57.170 --> 00:31:05.530
I'll start off by just copying this and then I'll go right in front of here and paste.

441
00:31:05.950 --> 00:31:12.700
And the only thing that I'm going to do differently is that I don't want three digits here.

442
00:31:12.700 --> 00:31:14.500
I'm only expecting one digit.

443
00:31:14.740 --> 00:31:22.030
So for that, I could I certainly could just put a one here, but I don't even need that because that's

444
00:31:22.030 --> 00:31:25.060
implied if you just have one thing right there, right?

445
00:31:25.060 --> 00:31:26.140
One digit, right?

446
00:31:26.380 --> 00:31:29.500
And so now this is going to match.

447
00:31:32.930 --> 00:31:33.530
There you go.

448
00:31:33.800 --> 00:31:42.620
Right now, if we wanted this leading bit here, the one in the period or whatever to be optional,

449
00:31:43.250 --> 00:31:44.960
can you think of how to do that?

450
00:31:45.860 --> 00:31:46.700
Go ahead and try.

451
00:31:47.960 --> 00:31:55.520
All right, so if I wanted to make that first bit the one in the period or one in a separate or character

452
00:31:55.610 --> 00:32:00.530
optional, I would probably go ahead and group that all first.

453
00:32:04.090 --> 00:32:11.650
And then I could say allow for zero or one of that with a question mark just like this.

454
00:32:11.890 --> 00:32:13.150
So now if I run this.

455
00:32:15.520 --> 00:32:16.420
That works.

456
00:32:17.230 --> 00:32:20.260
But if I get rid of this and run it.

457
00:32:23.000 --> 00:32:24.080
That also works.

458
00:32:24.810 --> 00:32:26.060
So isn't that pretty cool?

459
00:32:27.530 --> 00:32:32.330
So either of those scenarios will work now, and I know this looks a little weird because you got the

460
00:32:32.330 --> 00:32:36.360
question mark and then a closing parentheses and then another question mark.

461
00:32:36.380 --> 00:32:44.930
So remember this this question mark here is for this bracket expression saying zero or more of a hyphen

462
00:32:44.930 --> 00:32:46.730
period comma or a space.

463
00:32:47.180 --> 00:32:56.750
This question mark is for this entire grouping of the one one digit, followed by period or a hyphen

464
00:32:56.750 --> 00:32:57.390
or whatever.

465
00:32:57.410 --> 00:32:57.800
OK.

466
00:32:57.890 --> 00:33:03.470
And by the way, so in North America, I guess the rule really is that that leading thing there can

467
00:33:03.470 --> 00:33:04.440
only be a one.

468
00:33:04.460 --> 00:33:08.300
I think I can't think of any example where I've ever not seen it be a one.

469
00:33:08.300 --> 00:33:13.640
So you could constrain this further instead of being generic and allowing because here the way this

470
00:33:13.640 --> 00:33:20.840
is written now, not only is this valid, that would be valid too, and I've never seen a North American

471
00:33:20.840 --> 00:33:21.740
phone number like this.

472
00:33:22.100 --> 00:33:24.170
I think they're always starting with a one.

473
00:33:24.650 --> 00:33:31.340
So you could be even more technical here, technically correct and get rid of that cigarette and just

474
00:33:31.550 --> 00:33:36.800
put a literal of a one here saying, I'm only going to allow a one.

475
00:33:36.800 --> 00:33:38.780
If you're going to do this at all, it has to be a one.

476
00:33:38.930 --> 00:33:40.520
You don't have to have anything there.

477
00:33:40.520 --> 00:33:44.990
But if you do put something there in front of the 10 digits, it has to be a one, right?

478
00:33:45.230 --> 00:33:46.310
So if we run this?

479
00:33:48.370 --> 00:33:49.600
Yet we get a true.

480
00:33:50.020 --> 00:33:52.780
But if we do a four year.

481
00:33:55.620 --> 00:33:56.550
That's a false.

482
00:33:57.000 --> 00:34:00.400
But if we get rid of it completely, that's OK.

483
00:34:02.780 --> 00:34:03.380
There you go.

484
00:34:03.830 --> 00:34:04.890
Isn't that powerful?

485
00:34:04.910 --> 00:34:11.450
That's incredibly powerful to do all of this with without using regular expressions, just with regular

486
00:34:11.450 --> 00:34:14.300
code would be quite a bit of work.

487
00:34:14.510 --> 00:34:20.450
So anyway, let's go ahead and wrap this up, and in the next lesson, we'll we'll do a whole lot more

488
00:34:20.450 --> 00:34:22.640
with regular expressions I'll see in the next one.
