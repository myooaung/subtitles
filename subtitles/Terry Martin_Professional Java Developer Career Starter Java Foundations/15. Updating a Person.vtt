WEBVTT
1
00:00:00.480 --> 00:00:06.570
All right, now in this lesson, let's also implement the ability to update records, which is a function

2
00:00:06.570 --> 00:00:09.300
that we often need when working with databases.

3
00:00:09.900 --> 00:00:13.070
So first thing I want to do is back over here in the tests.

4
00:00:13.080 --> 00:00:17.130
Let me clear out this little experimental test method here.

5
00:00:17.130 --> 00:00:19.260
And by the way, let me say something real quick about that.

6
00:00:19.680 --> 00:00:23.370
So this is a technique that I like to use from time to time.

7
00:00:23.460 --> 00:00:31.500
If I need to just test out my understanding of how a snippet of code might work within the bigger context

8
00:00:31.500 --> 00:00:33.340
of an entire application, right?

9
00:00:33.360 --> 00:00:36.690
I just need a place to run some code really quickly.

10
00:00:36.960 --> 00:00:42.210
I often will turn to a unit test like this where I'll just create a quick test.

11
00:00:42.330 --> 00:00:47.150
It's not something that I plan to keep around, but I just want to try something out real quick.

12
00:00:47.160 --> 00:00:48.960
So this is one way that you can do that.

13
00:00:49.080 --> 00:00:54.090
It's kind of the equivalent to creating a public static void main method somewhere.

14
00:00:54.090 --> 00:01:00.630
But as you will start to see as you progress in learning Java and when we implement a more fully fledged

15
00:01:00.630 --> 00:01:07.260
web application, the public static void main approach that we've been doing a lot of things with really

16
00:01:07.260 --> 00:01:08.710
doesn't even apply anymore.

17
00:01:08.730 --> 00:01:13.440
So you kind of just need a place that's separate and distinct where you can try things out real quick

18
00:01:13.440 --> 00:01:13.860
in this.

19
00:01:13.870 --> 00:01:18.360
This is a this is an OK place to try some of those things sometimes.

20
00:01:18.660 --> 00:01:18.910
All right.

21
00:01:18.940 --> 00:01:19.950
So anyway, bye bye.

22
00:01:21.480 --> 00:01:22.050
All right.

23
00:01:23.570 --> 00:01:25.280
And I'll clear that all out there.

24
00:01:25.490 --> 00:01:29.240
All right, so let's create a new test method.

25
00:01:32.350 --> 00:01:37.150
And let's see public void, and let's just say can update.

26
00:01:38.650 --> 00:01:39.100
All right.

27
00:01:39.550 --> 00:01:41.560
So what do we want to do here?

28
00:01:42.010 --> 00:01:50.020
I'm thinking we will create a new person, will put that person into the database, then we will retrieve

29
00:01:50.020 --> 00:01:56.710
that person from the database, then we will modify that person object.

30
00:01:57.160 --> 00:02:04.810
Then we will call a new update method passing in this modified person to the database.

31
00:02:05.020 --> 00:02:08.420
Then we will retrieve that person by their ID.

32
00:02:08.770 --> 00:02:10.540
Again, from the database.

33
00:02:10.540 --> 00:02:19.000
And so now we should have the two person objects in our code and then we can assert that whatever field

34
00:02:19.000 --> 00:02:22.520
we changed is actually different between those two fields.

35
00:02:22.980 --> 00:02:24.280
Something along those lines?

36
00:02:24.310 --> 00:02:24.700
OK.

37
00:02:25.000 --> 00:02:25.390
All right.

38
00:02:25.400 --> 00:02:26.890
So let's see here.

39
00:02:26.890 --> 00:02:33.430
I think I will start by just duplicating a save line like this one and then bringing it down.

40
00:02:34.060 --> 00:02:34.480
All right.

41
00:02:34.630 --> 00:02:35.590
That's step one.

42
00:02:36.250 --> 00:02:36.790
OK.

43
00:02:36.820 --> 00:02:39.000
And then so let's see.

44
00:02:39.010 --> 00:02:44.860
So we just created a person and we just saved them to the database, all in one fell swoop.

45
00:02:45.160 --> 00:02:48.190
So now let's retrieve them from the database.

46
00:02:49.360 --> 00:02:56.110
Find by ads so we can refer to their saved person that get added method there, and so that should that

47
00:02:56.110 --> 00:02:57.190
should retrieve them.

48
00:02:57.460 --> 00:03:04.210
Now keep in mind that with this, find by ID method currently returns an optional person, and I don't

49
00:03:04.210 --> 00:03:05.950
feel like being bothered with all of that.

50
00:03:05.950 --> 00:03:10.180
So I'm just going to call get directly again because I'm in a test.

51
00:03:10.390 --> 00:03:17.680
I know for certain that under normal circumstances, this call to get will return an actual instance,

52
00:03:17.680 --> 00:03:21.060
and if it doesn't, then this test should should actually fail.

53
00:03:21.070 --> 00:03:22.270
So that's fine.

54
00:03:22.570 --> 00:03:24.520
All right, then I'll capture that person.

55
00:03:24.520 --> 00:03:25.060
And I don't know.

56
00:03:25.060 --> 00:03:27.490
I'll call it a found p.

57
00:03:27.530 --> 00:03:28.750
All right for person.

58
00:03:28.780 --> 00:03:29.650
All right.

59
00:03:30.130 --> 00:03:33.100
So then we will update a field on this person.

60
00:03:33.100 --> 00:03:37.480
And I actually was thinking something here in the people table of the database.

61
00:03:37.600 --> 00:03:45.430
We actually created a salary column as well, but we haven't actually modeled that column in Java.

62
00:03:45.640 --> 00:03:50.950
So I'm thinking, let's go ahead and model that column in Java and then let's modify that.

63
00:03:50.950 --> 00:03:52.480
Let's update that.

64
00:03:52.570 --> 00:03:53.000
OK.

65
00:03:53.410 --> 00:03:53.710
All right.

66
00:03:53.720 --> 00:04:01.980
So to do that, let's jump over to the person class and let's add a salary filled now.

67
00:04:02.950 --> 00:04:06.940
First thing we got to consider is what data type to use to model this.

68
00:04:07.180 --> 00:04:08.770
So it's salaries, right?

69
00:04:09.070 --> 00:04:10.390
So we're talking about money.

70
00:04:10.660 --> 00:04:17.170
So possibly the most correct way to model this might be using a big decimal.

71
00:04:17.380 --> 00:04:19.960
So let's let's try that big decimal.

72
00:04:21.160 --> 00:04:27.700
And we'll call this salary, and I don't know, let's see here, let's go down towards the bottom ish.

73
00:04:27.880 --> 00:04:33.280
Not quite that far, but with all these getters and setters here, it's generate a getter and setter

74
00:04:33.280 --> 00:04:35.380
for the new salary.

75
00:04:35.380 --> 00:04:38.350
They're so getter setter every girl.

76
00:04:39.720 --> 00:04:41.640
All right, so there's that.

77
00:04:42.180 --> 00:04:46.710
And so now let's return to our test class.

78
00:04:46.860 --> 00:04:54.360
And so now let's take this found person here and let's set a salary on them, which shouldn't be there

79
00:04:54.360 --> 00:04:58.320
now at this point that lie at the point of line one of six, right?

80
00:04:58.680 --> 00:05:06.210
So we will call found peaked set salary and let's go ahead and set a salary on this person.

81
00:05:06.210 --> 00:05:11.820
So a decent way to do this would be to actually create a new instance of a big decimal and then use

82
00:05:11.820 --> 00:05:12.450
a string.

83
00:05:12.480 --> 00:05:12.900
OK.

84
00:05:13.200 --> 00:05:14.090
So I don't know.

85
00:05:14.100 --> 00:05:21.570
We can say something like seventy three thousand and thirty four cents.

86
00:05:22.020 --> 00:05:22.410
OK.

87
00:05:22.680 --> 00:05:29.130
Notice I'm leaving off the dollar signs and commas and all of that because the big decimal wouldn't

88
00:05:29.130 --> 00:05:30.360
understand all of that.

89
00:05:30.390 --> 00:05:36.210
We'd have to use an instance of a no format, a currency instance of a no format to be more specific.

90
00:05:36.360 --> 00:05:40.440
If we wanted to be able to input all of that stuff and we're not, I'm not going to bother with all

91
00:05:40.440 --> 00:05:40.830
of that.

92
00:05:41.220 --> 00:05:41.510
All right.

93
00:05:41.520 --> 00:05:43.860
So there's the new salary, OK?

94
00:05:44.130 --> 00:05:52.710
And so now I think we can call our repo, that update, which doesn't exist yet, and then we will pass

95
00:05:52.710 --> 00:06:00.180
in this found person like so and so let's go ahead and make the ADP happy here.

96
00:06:00.450 --> 00:06:01.890
Yeah, I'm fine with that.

97
00:06:01.890 --> 00:06:07.630
Returning a void and fine with the data type being person and we'll call the variable their person.

98
00:06:07.650 --> 00:06:09.270
OK, so that's enough for that.

99
00:06:09.690 --> 00:06:11.490
Let's go back over to the test.

100
00:06:11.520 --> 00:06:12.270
OK, good.

101
00:06:12.300 --> 00:06:20.340
OK, so the red mark went away and then let's go ahead and retrieve this person again.

102
00:06:20.670 --> 00:06:24.090
So we will do another find by I.D..

103
00:06:25.150 --> 00:06:32.530
And we will reference, I mean, I guess we can reference the found persons I.D. and I will do a get

104
00:06:32.530 --> 00:06:35.110
again as well and then capture that.

105
00:06:35.590 --> 00:06:40.060
And this time, I guess I will call this found person to OK.

106
00:06:40.570 --> 00:06:52.600
And so finally, let's assert that found person found person to that salary is not equal.

107
00:06:52.930 --> 00:06:56.230
Now here's the thing we've got a few choices to make here.

108
00:06:56.230 --> 00:07:03.790
Now we could do not equal to or we've got this is not equal by comparing two.

109
00:07:03.970 --> 00:07:05.440
I'm kind of liking that.

110
00:07:05.470 --> 00:07:12.790
I'm really liking that because I know that the comparing to is going to actually call the comparator

111
00:07:13.090 --> 00:07:15.260
of the big decimal class.

112
00:07:15.310 --> 00:07:22.330
And so I know that by using the comparator, it's going to use the most context aware approach to comparing

113
00:07:22.330 --> 00:07:23.620
these two big decimals.

114
00:07:24.100 --> 00:07:25.660
So let's try that out.

115
00:07:26.200 --> 00:07:26.520
All right.

116
00:07:26.530 --> 00:07:33.910
And so then we will reference the original found person instance dont get salary.

117
00:07:33.920 --> 00:07:38.140
Now I can already anticipate one problem that we are going to run into here.

118
00:07:38.170 --> 00:07:43.570
Now, can you anticipate what problem we are pretty much certainly going to run into right away?

119
00:07:44.290 --> 00:07:44.660
All right.

120
00:07:44.680 --> 00:07:50.980
So I think what's going to end up happening even after we implement properly this update method is that

121
00:07:51.280 --> 00:07:57.130
the original instance here that that was in the database that is now loaded into memory?

122
00:07:57.130 --> 00:08:01.960
This found PPI, not the found P2, but the found PPI doesn't have a salary at all.

123
00:08:02.170 --> 00:08:08.860
With the current implementation of code that we have here, that salary is going to be null because

124
00:08:08.860 --> 00:08:11.380
it's never been defined or set anywhere at all.

125
00:08:11.590 --> 00:08:18.180
And so when we get down here to this assertion, we're going to end up with a null pointer exception

126
00:08:18.190 --> 00:08:24.730
on this call right here if we use this as is, but let's go ahead and run it and see.

127
00:08:29.580 --> 00:08:30.510
All right.

128
00:08:32.280 --> 00:08:38.490
Expecting actual not to be null, yes, so it's null as as as we could anticipate.

129
00:08:38.940 --> 00:08:39.240
All right.

130
00:08:39.250 --> 00:08:46.620
So one thing we could do to ensure that we don't have that kind of problem is let's go back into the

131
00:08:46.620 --> 00:08:47.970
person class here.

132
00:08:47.970 --> 00:08:56.760
We could actually initialize this salary to a value right off the bat, just in memory and in memory

133
00:08:56.760 --> 00:08:57.240
value.

134
00:08:57.240 --> 00:08:58.200
We could do that.

135
00:08:58.290 --> 00:08:59.340
Let's see what that would look like.

136
00:08:59.340 --> 00:09:04.500
So we could do something in line right here at the declaration new big decimal.

137
00:09:04.650 --> 00:09:06.600
And then we could just pass in a zero.

138
00:09:06.630 --> 00:09:07.020
Right?

139
00:09:07.140 --> 00:09:09.810
We could just initialize that salary to zero.

140
00:09:09.820 --> 00:09:14.520
So if you don't specify anything, the salary will well, at least not be null.

141
00:09:14.520 --> 00:09:16.020
It will be set to something.

142
00:09:16.020 --> 00:09:17.580
And that is zero.

143
00:09:18.060 --> 00:09:19.320
We could we could do that.

144
00:09:20.420 --> 00:09:20.810
All right.

145
00:09:20.870 --> 00:09:22.850
So let's see what this does now.

146
00:09:23.180 --> 00:09:27.710
OK, so let's see here, what do we have that should not have passed, right?

147
00:09:27.710 --> 00:09:35.360
Assert that the found persons salary is not equal to the original salary?

148
00:09:36.320 --> 00:09:39.950
OK, so I see the flaw in this test here.

149
00:09:40.040 --> 00:09:45.380
Do you see the flaw in it if you don't go ahead and take a moment to look at this carefully?

150
00:09:46.830 --> 00:09:48.120
All right, did you find the floor?

151
00:09:48.660 --> 00:09:53.340
So we're creating a new person and saving them, and currently the implementation of Repot Saved does

152
00:09:53.340 --> 00:09:54.610
not save the salary.

153
00:09:54.630 --> 00:09:55.050
OK.

154
00:09:56.310 --> 00:10:04.470
Then we're retrieving that person by their I.D. here now because we are going ahead and initializing

155
00:10:04.470 --> 00:10:06.780
that salary in the Java code.

156
00:10:07.440 --> 00:10:10.440
There will be a salary equal to zero.

157
00:10:10.470 --> 00:10:10.890
Right?

158
00:10:11.580 --> 00:10:17.460
So then we are going ahead and explicitly setting the salary to 73000.

159
00:10:17.650 --> 00:10:18.150
OK.

160
00:10:18.180 --> 00:10:21.300
And then we're calling Update, which currently doesn't do anything right?

161
00:10:21.330 --> 00:10:23.880
It's literally just an empty method right now.

162
00:10:23.880 --> 00:10:25.400
So that's not doing anything.

163
00:10:25.440 --> 00:10:29.790
But this first person in memory has a salary of seventy three thousand.

164
00:10:29.790 --> 00:10:30.720
Keep that in mind.

165
00:10:31.440 --> 00:10:39.510
Then we're calling find bid to retrieve that person, according to their I.D. and storing that instance

166
00:10:39.510 --> 00:10:42.660
of the same person in found P2.

167
00:10:42.750 --> 00:10:46.680
Now what do you think this person's salary is going to be at this point?

168
00:10:46.860 --> 00:10:55.110
We just loaded them up from the database right into a new instance in memory, so their salary is going

169
00:10:55.110 --> 00:10:56.400
to be zero.

170
00:10:56.580 --> 00:10:57.000
Right?

171
00:10:57.210 --> 00:11:02.480
Because we don't save salary information to the database yet, we haven't taught any.

172
00:11:02.490 --> 00:11:07.440
We haven't touched the repository how to save any salary data anywhere at all yet.

173
00:11:07.620 --> 00:11:08.100
OK.

174
00:11:08.760 --> 00:11:14.910
And so this guy here is going to have a salary of zero, which is going to come from the line where

175
00:11:14.910 --> 00:11:19.960
we are declaring an initializing the big decimal for the salary right here.

176
00:11:19.980 --> 00:11:21.330
Line 13, right.

177
00:11:21.340 --> 00:11:23.310
That's where the zero is going to come from.

178
00:11:23.730 --> 00:11:24.180
OK.

179
00:11:24.540 --> 00:11:29.060
And so then we're going to assert that these two instances have different salaries.

180
00:11:29.070 --> 00:11:31.170
Well, yes, they do have different salaries, right?

181
00:11:31.170 --> 00:11:36.120
Because we're explicitly setting the first person salary to 73000.

182
00:11:36.150 --> 00:11:36.570
OK.

183
00:11:36.750 --> 00:11:38.520
So this approach is flawed.

184
00:11:38.700 --> 00:11:40.530
We don't want to do it this way.

185
00:11:41.880 --> 00:11:45.420
So I think let's try this a little differently.

186
00:11:45.780 --> 00:11:49.200
And I'm actually going to go ahead and just get rid of all of this.

187
00:11:49.500 --> 00:11:52.410
Let's let's just let's do this a little differently here.

188
00:11:53.610 --> 00:11:54.060
OK.

189
00:11:54.270 --> 00:11:57.150
So I think let's try this way.

190
00:11:57.990 --> 00:12:02.730
Let's retrieve this person signed by I.D..

191
00:12:03.750 --> 00:12:09.300
Saved person, oops, saved the person, Kennedy, don't get.

192
00:12:11.880 --> 00:12:15.420
And let's just store them in someone called P.1.

193
00:12:15.450 --> 00:12:21.390
OK, now let's set a salary on this instance here.

194
00:12:22.830 --> 00:12:33.600
Like this saved person that said salary to new big, small 73000 in some sense.

195
00:12:34.260 --> 00:12:41.760
And then let's call a report update and an update that saved the person.

196
00:12:41.790 --> 00:12:44.820
OK, so basically that means like we save them, right?

197
00:12:46.070 --> 00:12:55.610
And then let's call a report, find loops, find by I.D. and then let's get their I.D. that get.

198
00:12:56.510 --> 00:13:01.580
And let's save a reference to this person in P2.

199
00:13:02.150 --> 00:13:16.310
And now let's assert that P2 that get salary is not equal by comparing to P1 that gets salary.

200
00:13:17.410 --> 00:13:19.480
All right, so let's analyze this now.

201
00:13:20.170 --> 00:13:21.160
I think we got it here.

202
00:13:21.390 --> 00:13:23.230
So let me make some room here.

203
00:13:23.470 --> 00:13:23.740
All right.

204
00:13:23.740 --> 00:13:31.580
So we're getting a snapshot of P1 loaded from the database before we make any changes and that's P1.

205
00:13:31.600 --> 00:13:32.050
OK.

206
00:13:32.530 --> 00:13:37.600
And then we're going to take this originally saved instance of the same person, and we're going to

207
00:13:37.600 --> 00:13:39.690
update their salary, right?

208
00:13:39.700 --> 00:13:42.390
We're going to set the salary and then call update.

209
00:13:42.400 --> 00:13:47.590
And that should update the one and only record for this person in the database.

210
00:13:47.860 --> 00:13:53.680
If this were implemented right, and then we're going to turn around and retrieve that person again

211
00:13:53.680 --> 00:13:54.850
from the database.

212
00:13:55.330 --> 00:14:03.340
And so if update was implemented properly, this P2 should have a salary of seventy three thousand.

213
00:14:03.340 --> 00:14:09.890
But this P1, which was retrieved before we made any changes anywhere, should have a salary of zero.

214
00:14:09.910 --> 00:14:10.300
Right.

215
00:14:10.420 --> 00:14:12.520
So this one should have a salary of zero.

216
00:14:12.730 --> 00:14:15.550
This one should have a salary of 73000.

217
00:14:15.560 --> 00:14:16.660
That's the point, right?

218
00:14:16.990 --> 00:14:23.980
And if P1 and P2 have different salaries, then this test will pass if they have the same salary.

219
00:14:24.010 --> 00:14:25.360
This test should fail.

220
00:14:25.630 --> 00:14:29.500
So let's run this and see what we end up with now.

221
00:14:30.560 --> 00:14:31.460
There we go.

222
00:14:31.490 --> 00:14:35.180
OK, so now we've got a properly failing test.

223
00:14:35.390 --> 00:14:44.210
And so this really highlights the fact that we need our tests to fail before we go implementing anything.

224
00:14:44.240 --> 00:14:49.850
Otherwise, you can't be certain that you've actually implemented the needed functionality.

225
00:14:50.060 --> 00:14:56.270
So I chose to go ahead and leave my own mistake of how I initially tried to write this test.

226
00:14:56.450 --> 00:15:02.990
I've chosen to leave this in this lesson because I'm human, and no matter how good you are, you're

227
00:15:02.990 --> 00:15:05.840
going to get confused and make mistakes like this.

228
00:15:05.990 --> 00:15:11.960
And this really under underscores the reason why with TDD or any testing, but especially especially

229
00:15:11.960 --> 00:15:19.280
with TDD, you first write the test and then you have to see it fail, especially if it's the first

230
00:15:19.280 --> 00:15:20.090
of its kind.

231
00:15:20.240 --> 00:15:26.030
Now, you know, if we implemented update and then we wrote some more update related test methods and

232
00:15:26.030 --> 00:15:33.020
the implementation of Update was so good that had already happened to cover whatever additional test

233
00:15:33.020 --> 00:15:35.000
methods we wanted to to run.

234
00:15:35.450 --> 00:15:36.550
That's one thing, right?

235
00:15:36.560 --> 00:15:40.880
But this is the first of its kind here to test the ability to update, right?

236
00:15:41.060 --> 00:15:44.210
And so we need to see this test fail first.

237
00:15:44.360 --> 00:15:52.820
Now, the only way hopefully, that this test should be able to pass is by us actually implementing

238
00:15:52.820 --> 00:15:55.070
a proper update method.

239
00:15:55.160 --> 00:15:55.640
OK.

240
00:15:55.850 --> 00:16:00.860
And so that's why your tests have to fail first before you can proceed.

241
00:16:01.340 --> 00:16:01.940
All right.

242
00:16:02.150 --> 00:16:05.150
So now let's go make this pass.

243
00:16:06.500 --> 00:16:06.770
All right.

244
00:16:06.770 --> 00:16:11.480
So I'm going to jump into the update method here and let me make some room.

245
00:16:12.470 --> 00:16:12.980
All right.

246
00:16:12.980 --> 00:16:20.570
And so now we can pretty much do our boilerplate type thing connection dot prepared statement.

247
00:16:20.570 --> 00:16:31.190
And so what we'll do here is we will update people set first name.

248
00:16:31.610 --> 00:16:37.450
Now we're the way we're going to do this, by the way, is we're going to just make our update method

249
00:16:37.460 --> 00:16:38.060
update.

250
00:16:38.510 --> 00:16:40.310
I think all of the fields.

251
00:16:40.340 --> 00:16:44.810
OK, we could get fancy and we could do this in a lot of ways.

252
00:16:44.930 --> 00:16:49.760
We could have update methods that specialize in each and every field.

253
00:16:49.760 --> 00:16:55.970
And then you could even write code that would figure out which field in the Java side had changed and

254
00:16:55.970 --> 00:16:58.880
then only update just that field in the database.

255
00:16:58.880 --> 00:17:00.890
That would be highly efficient to do.

256
00:17:01.190 --> 00:17:03.920
But it would be a lot of code that we don't have time to write.

257
00:17:04.130 --> 00:17:05.600
So not going to do that.

258
00:17:05.600 --> 00:17:10.910
We'll just make our update almost identical to the save, except that it will update.

259
00:17:10.940 --> 00:17:11.210
All right.

260
00:17:11.210 --> 00:17:16.640
So we'll set the first name equal to a parameter comma.

261
00:17:16.670 --> 00:17:22.610
This is how we can set multiple fields or multiple columns, OK, just with the set keyword and then

262
00:17:22.610 --> 00:17:23.000
comma.

263
00:17:23.000 --> 00:17:32.960
So set first name equal to whatever last last name, equal to whatever date of birth, equal to whatever.

264
00:17:33.140 --> 00:17:40.250
And now we'll also throw in salary salary equal to whatever where.

265
00:17:40.880 --> 00:17:47.240
And this is important now because without the where clause, we'd be changing all of these values for

266
00:17:47.240 --> 00:17:49.400
all records in that table.

267
00:17:49.580 --> 00:17:50.480
That would be terrible.

268
00:17:50.870 --> 00:17:53.780
Where ID equals whatever.

269
00:17:55.040 --> 00:17:55.520
OK.

270
00:17:55.760 --> 00:17:57.170
So that's what we need there.

271
00:17:57.320 --> 00:17:58.990
I keep doing this a little backward, don't I?

272
00:17:59.210 --> 00:18:02.900
Let me first capture the prepared statement.

273
00:18:04.050 --> 00:18:10.350
All right, and then let's wrap this in a try catch block, sorry, might try catch stuff as run off

274
00:18:10.350 --> 00:18:12.450
the screen, but you've seen it enough by now.

275
00:18:12.720 --> 00:18:13.140
OK.

276
00:18:13.290 --> 00:18:13.920
All right.

277
00:18:14.220 --> 00:18:15.930
So there's that.

278
00:18:16.050 --> 00:18:19.560
So now we need to start binding all of these values, right?

279
00:18:19.570 --> 00:18:23.070
So that set string, because we'll do the first thing.

280
00:18:23.070 --> 00:18:26.790
First of the first parameter will be the person died.

281
00:18:27.060 --> 00:18:28.440
Get first name.

282
00:18:28.980 --> 00:18:29.580
All right.

283
00:18:29.790 --> 00:18:31.440
Then search string.

284
00:18:31.440 --> 00:18:34.480
And we'll do the second parameter, which is the person died.

285
00:18:34.500 --> 00:18:35.850
Get last name.

286
00:18:36.810 --> 00:18:42.810
All right, and then starts, what is it, date of birth, so now that was a timestamp.

287
00:18:43.920 --> 00:18:44.240
All right.

288
00:18:44.250 --> 00:18:45.660
So that's the third parameter.

289
00:18:45.840 --> 00:18:51.090
Now we had to do a bunch of stuff before when we did the save, right?

290
00:18:51.270 --> 00:18:52.020
Yeah, here it is.

291
00:18:52.020 --> 00:18:55.720
We had to do all of this right now.

292
00:18:55.740 --> 00:19:00.360
What we can do, I mean, I could go ahead and just duplicate this, this little snippet of code, but

293
00:19:00.450 --> 00:19:05.430
I want to be a little fancy for you and teach you to make sure that you look for opportunities to extract

294
00:19:05.430 --> 00:19:08.370
methods and reuse code and things like that, right?

295
00:19:08.700 --> 00:19:17.550
So what we can do is just select all of this up to the parentheses that closes off this value of right

296
00:19:17.550 --> 00:19:17.790
here.

297
00:19:17.940 --> 00:19:23.490
And I'm inclined to go ahead and extract a method of this selection here.

298
00:19:23.490 --> 00:19:30.030
So I'm going to do an option command M to select the method here, and I'm going to call this maybe

299
00:19:30.330 --> 00:19:37.020
convert D0 B to time stamp enter.

300
00:19:37.350 --> 00:19:37.770
All right.

301
00:19:38.040 --> 00:19:40.680
And now let's jump down to this method here.

302
00:19:40.710 --> 00:19:46.830
Now it went a little overzealous for what I was meaning to do, and it assumed that I wanted the entire

303
00:19:46.830 --> 00:19:48.240
person as the input.

304
00:19:48.390 --> 00:19:52.380
But actually, what I was kind of more like wanting was just the date of birth.

305
00:19:52.740 --> 00:20:00.420
So I think what we can do here is to select just that bit there and we can parameter ize that.

306
00:20:00.870 --> 00:20:07.440
So I'm selecting the date of birth from the person that get the job here, and then I'm going to do

307
00:20:07.440 --> 00:20:09.780
an option command p for parameters.

308
00:20:09.810 --> 00:20:11.640
This is to introduce a parameter.

309
00:20:11.640 --> 00:20:13.560
We've done this maybe once before.

310
00:20:14.490 --> 00:20:14.910
All right.

311
00:20:15.420 --> 00:20:16.680
There it is, right there.

312
00:20:17.680 --> 00:20:18.160
All right.

313
00:20:18.190 --> 00:20:22.450
And notice now it's even basically scratching out that person there, right?

314
00:20:22.840 --> 00:20:29.260
And so yes, we'll call this new thing this new parameter date of birth or in them and hit enter.

315
00:20:29.530 --> 00:20:30.180
There we go.

316
00:20:30.190 --> 00:20:32.860
So until the is pretty, pretty intelligent, right?

317
00:20:33.070 --> 00:20:38.000
It knew that I no longer needed or wanted the person that we were passing in.

318
00:20:38.020 --> 00:20:40.450
I'm replacing that with the date of birth there.

319
00:20:40.600 --> 00:20:47.110
And if we go back up to where this method is being utilized now right up here, convert date of birth

320
00:20:47.110 --> 00:20:48.880
to time stamp, now it's doing the right thing.

321
00:20:48.880 --> 00:20:49.930
It's passing in person.

322
00:20:49.930 --> 00:20:55.000
Typekit date of birth, which is the way I intended for this method to work in the first place.

323
00:20:55.300 --> 00:20:58.720
And now I can just call this method.

324
00:20:58.870 --> 00:21:07.420
Now I prefer for this to be out of the way, though I'm going to cut that and get rid of the gaps there,

325
00:21:07.420 --> 00:21:14.730
and I'm going to move that somewhere down out of my way because now it's kind of like a utility type,

326
00:21:15.340 --> 00:21:16.750
type of method, really.

327
00:21:16.900 --> 00:21:18.550
So I'm going to put it down here.

328
00:21:19.650 --> 00:21:29.010
OK, so now back to the update method, now I can call this convert method here and then just pass in

329
00:21:29.010 --> 00:21:33.270
the person died, get date of birth like that, OK?

330
00:21:33.300 --> 00:21:40.500
And so now that's that's taking that date of birth and converting it into a time stamp in the way needed,

331
00:21:40.500 --> 00:21:40.860
right?

332
00:21:40.890 --> 00:21:42.420
Doing all of that stuff.

333
00:21:42.750 --> 00:21:49.920
And I don't have to duplicate the the specific details of how I convert the date of birth to a timestamp

334
00:21:49.920 --> 00:21:53.400
by warping the time to GMT zero and all of that.

335
00:21:53.730 --> 00:21:54.130
OK.

336
00:21:54.150 --> 00:22:00.340
And perhaps equally as importantly, there's only one place where I do that now.

337
00:22:00.360 --> 00:22:00.600
Right.

338
00:22:00.610 --> 00:22:08.310
So if I decide ever to change how we are storing dates in the database and not have it be relative to

339
00:22:08.310 --> 00:22:12.090
GMT zero, I can just go to one place and do that there.

340
00:22:12.180 --> 00:22:17.730
And as long as I was smart enough to use this same method everywhere where I have to do timestamp stuff,

341
00:22:18.300 --> 00:22:20.580
they all will update accordingly.

342
00:22:21.420 --> 00:22:26.250
All right, so there's that and then we need to set the salary now.

343
00:22:26.430 --> 00:22:33.330
Now, the salary we modeled as a, I think what we use here, let's jump over to the database and see,

344
00:22:33.600 --> 00:22:39.810
OK, so for the salary, we used a data type in H2 called decimal.

345
00:22:40.020 --> 00:22:40.520
OK.

346
00:22:40.890 --> 00:22:44.220
Let's see what that maps to in Java sequel.

347
00:22:44.460 --> 00:22:46.100
So let's see what we've got here.

348
00:22:46.110 --> 00:22:46.870
Set?

349
00:22:47.250 --> 00:22:49.380
Oh, we got a big decimal right there.

350
00:22:49.440 --> 00:22:50.040
There we go.

351
00:22:50.640 --> 00:22:51.040
OK.

352
00:22:51.060 --> 00:22:52.980
So this is our fourth parameter.

353
00:22:53.550 --> 00:22:56.730
And so this will be person that gets salary.

354
00:22:57.000 --> 00:22:57.600
Here we go.

355
00:22:57.630 --> 00:22:58.320
Looks good.

356
00:22:58.590 --> 00:23:04.260
And finally, I think we should have a last parameter one two three four.

357
00:23:04.260 --> 00:23:10.590
Yeah, a fifth parameter, which is going to be the ID piece that set long.

358
00:23:10.710 --> 00:23:15.690
We modeled that as a long fifth parameter person died.

359
00:23:15.720 --> 00:23:16.810
Get IED.

360
00:23:16.860 --> 00:23:17.610
There we go.

361
00:23:18.120 --> 00:23:20.550
All right, so that's everybody now.

362
00:23:21.090 --> 00:23:21.560
All right.

363
00:23:21.570 --> 00:23:27.120
And so then we can simply call PPS Dot Execute Update.

364
00:23:27.210 --> 00:23:31.110
I'm not even going to bother to capture the output of that at this time.

365
00:23:31.860 --> 00:23:32.540
OK.

366
00:23:32.610 --> 00:23:34.200
Let's see if that's all we needed.

367
00:23:34.710 --> 00:23:39.960
So let's jump back over to our test and run it.

368
00:23:43.240 --> 00:23:43.750
Nope.

369
00:23:44.320 --> 00:23:49.150
Let's click on it and see oh, well, as usual, I'm in the database already.

370
00:23:49.300 --> 00:23:51.220
So let me get out of the database.

371
00:23:51.490 --> 00:23:51.790
All right.

372
00:23:51.820 --> 00:23:52.720
Let's try that again.

373
00:23:53.140 --> 00:23:53.530
OK.

374
00:23:53.560 --> 00:23:55.810
No, let's see.

375
00:23:56.050 --> 00:23:56.440
Ah.

376
00:23:57.040 --> 00:24:01.090
And I know another problem that we're going to see here now.

377
00:24:02.020 --> 00:24:03.790
Do you know what the next problem is?

378
00:24:05.710 --> 00:24:08.530
The next problem is with our find by Edy.

379
00:24:10.300 --> 00:24:12.220
So let's go take a look at find by.

380
00:24:13.590 --> 00:24:18.630
So when we find a person first off, what columns do we actually retrieve?

381
00:24:18.780 --> 00:24:20.130
Let's go look at our sequel.

382
00:24:21.270 --> 00:24:28.140
So when we find a person by IED, we are getting the I.D., the name, the first name, the last name

383
00:24:28.140 --> 00:24:29.490
and the date of birth, and that's it.

384
00:24:29.640 --> 00:24:31.650
We're not even retrieving the salary.

385
00:24:31.800 --> 00:24:33.660
So now we need that salary.

386
00:24:33.690 --> 00:24:35.520
OK, so let's add that in.

387
00:24:38.420 --> 00:24:39.230
Salary.

388
00:24:40.820 --> 00:24:46.880
Now we're going to run into issues, potentially if we write enough tests with the Find All as well.

389
00:24:47.480 --> 00:24:52.520
We'll hold off on that for right now, though, because technically we should probably write test that

390
00:24:52.520 --> 00:24:54.200
would force us to fix that.

391
00:24:54.260 --> 00:24:54.710
OK.

392
00:24:55.610 --> 00:24:55.910
All right.

393
00:24:55.910 --> 00:24:56.720
So find my ID.

394
00:24:57.050 --> 00:24:59.300
So now we need to retrieve the salary.

395
00:24:59.510 --> 00:25:04.170
OK, so that's one issue that's not going to be the only one, though.

396
00:25:04.180 --> 00:25:07.670
OK, so there's that query we'd be getting that.

397
00:25:07.670 --> 00:25:12.500
But then we have this method here extract person from results set, right?

398
00:25:12.680 --> 00:25:18.890
So if we jump down into here, we also have to then take those values from the results set and then

399
00:25:18.890 --> 00:25:20.720
set them back on the person.

400
00:25:20.720 --> 00:25:22.430
And we don't currently do that.

401
00:25:22.670 --> 00:25:24.530
So we'll need to do that also.

402
00:25:24.540 --> 00:25:31.790
So let's just make another line here and we will do results that get big decimal.

403
00:25:32.890 --> 00:25:40.060
And so now this will be a column called salary, right?

404
00:25:41.390 --> 00:25:45.320
And let's capture that, yeah, and we'll call it salary.

405
00:25:45.680 --> 00:25:48.950
And now we need to set that on this person now.

406
00:25:48.960 --> 00:25:55.550
Currently, we're using a constructor to do that, but we don't have a constructor that takes the salary

407
00:25:55.700 --> 00:25:55.880
now.

408
00:25:55.970 --> 00:26:01.850
Now we could modify this constructor here, but I can tell you what's going to happen if we do that,

409
00:26:01.850 --> 00:26:04.010
which we maybe should eventually.

410
00:26:04.020 --> 00:26:09.440
But then that's going to break any other code where we're currently using this constructor and then

411
00:26:09.440 --> 00:26:11.090
we'd have to go and fix all of those.

412
00:26:11.090 --> 00:26:12.860
And there would be a big ripple effect.

413
00:26:13.340 --> 00:26:20.970
You usually want to try to keep your code breakages as narrow as you can so that you're not just having

414
00:26:20.970 --> 00:26:23.330
to play whack a mole all over the place.

415
00:26:23.570 --> 00:26:23.810
Right.

416
00:26:23.810 --> 00:26:27.560
You don't want these ripple effects or these cascading breakages, if you will.

417
00:26:27.710 --> 00:26:34.490
You kind of want to try, if you can, to keep your breakages of your code as narrow as possible.

418
00:26:34.700 --> 00:26:44.000
So what I'm thinking to do here is I'm going to go ahead and reference woops reference this new salary

419
00:26:44.000 --> 00:26:46.490
field, but here's what I'm going to do.

420
00:26:46.670 --> 00:26:52.610
Now the idea is telling me that there is no constructor that takes this many arguments right of this

421
00:26:52.610 --> 00:26:53.060
type.

422
00:26:53.450 --> 00:27:00.090
So I'm going to let it create a new constructor for us, for me.

423
00:27:00.110 --> 00:27:02.180
OK, so I'm going to go ahead and click on that.

424
00:27:02.390 --> 00:27:03.350
Create new constructor.

425
00:27:03.350 --> 00:27:06.200
By the way, I got that by hovering over the red marks, right?

426
00:27:06.200 --> 00:27:07.850
And then create constructor.

427
00:27:07.850 --> 00:27:13.490
You could also come over to this light bulb here, and it gives you even more options right there.

428
00:27:13.490 --> 00:27:17.660
You could change the signature of an existing constructor, but I don't want to do that right now.

429
00:27:17.900 --> 00:27:20.840
I'm just going to create an additional constructor.

430
00:27:20.900 --> 00:27:26.660
OK, one that takes all of these fields like so.

431
00:27:28.110 --> 00:27:36.870
So I'm going to accept that, and I'm going to call this just IED, and I'll accept all of these things

432
00:27:37.590 --> 00:27:39.000
as they are.

433
00:27:41.410 --> 00:27:41.740
Yeah.

434
00:27:42.250 --> 00:27:42.610
OK.

435
00:27:43.000 --> 00:27:50.980
And then what I will do now is I will delegate to an existing constructor and we did this before already

436
00:27:50.980 --> 00:27:53.490
when we created this constructor up here, right?

437
00:27:53.500 --> 00:27:56.290
So we're just going to basically do that kind of pattern again.

438
00:27:56.320 --> 00:27:56.620
Right.

439
00:27:56.770 --> 00:27:58.420
So I'm going to call this now.

440
00:27:58.570 --> 00:28:05.620
Remember that if I call the this method here to refer to a different constructor, it needs to be the

441
00:28:05.620 --> 00:28:07.750
very first line in the constructor, OK?

442
00:28:08.170 --> 00:28:14.900
This and I will pass in the idea in the first name and the last name and the date of birth, right?

443
00:28:14.920 --> 00:28:16.150
Just like that.

444
00:28:16.870 --> 00:28:24.130
And then I can just additionally call this that salary equals salary.

445
00:28:24.190 --> 00:28:24.790
There we go.

446
00:28:25.120 --> 00:28:25.540
OK.

447
00:28:25.570 --> 00:28:31.810
That way, I don't have to type a whole lot of stuff and I can reuse as much code in the form of these

448
00:28:31.810 --> 00:28:33.790
constructors as possible, right?

449
00:28:34.030 --> 00:28:34.870
And I don't know.

450
00:28:34.870 --> 00:28:38.020
I would kind of like to move all of this up.

451
00:28:38.170 --> 00:28:38.860
I think.

452
00:28:39.940 --> 00:28:45.850
Above here, because this guy is depending on this one and this one's depending on that one, I just

453
00:28:46.120 --> 00:28:46.390
that.

454
00:28:46.840 --> 00:28:47.070
All right.

455
00:28:47.080 --> 00:28:52.480
So that just makes me feel good to have my constructor's kind of make some kind of sense there.

456
00:28:52.990 --> 00:28:53.800
All right.

457
00:28:54.070 --> 00:28:57.130
Let's jump back over to the repository.

458
00:28:57.130 --> 00:28:57.730
OK, cool.

459
00:28:57.730 --> 00:28:59.800
So the red marks have gone away now.

460
00:29:00.460 --> 00:29:01.390
All right.

461
00:29:01.630 --> 00:29:03.400
Let's see.

462
00:29:03.520 --> 00:29:09.850
So we are returning the newly created person who now should have an an actual salary.

463
00:29:10.300 --> 00:29:17.260
Oh, now I can see that the find all method probably is going to be broken because I did not update

464
00:29:17.260 --> 00:29:21.530
its query to retrieve the salary, but we'll cross that bridge when we get to it.

465
00:29:21.550 --> 00:29:21.880
OK.

466
00:29:22.300 --> 00:29:22.600
All right.

467
00:29:22.600 --> 00:29:25.390
So let's jump back over to the test now.

468
00:29:26.170 --> 00:29:27.280
Let's run it again.

469
00:29:28.280 --> 00:29:29.510
All right, still failing.

470
00:29:30.600 --> 00:29:36.960
Let's see what's up now, cannot read field scale, because Val is null.

471
00:29:38.350 --> 00:29:39.490
OK, interesting.

472
00:29:39.670 --> 00:29:45.640
So this looks like it's getting pretty far now, and it might be hanging, getting hung up on the assertion

473
00:29:45.640 --> 00:29:48.610
where we're doing the equal not equals by comparison.

474
00:29:48.850 --> 00:29:50.710
So let's try something here.

475
00:29:51.040 --> 00:29:59.320
Let's just try doing a is not equal to a little bit simpler, maybe.

476
00:29:59.590 --> 00:29:59.900
All right.

477
00:29:59.920 --> 00:30:01.270
Let's see what that does.

478
00:30:02.380 --> 00:30:03.700
Hey, there we go.

479
00:30:05.830 --> 00:30:12.550
Now, to make absolutely certain, because now I just changed a fundamental aspect of of what I'm comparing

480
00:30:12.550 --> 00:30:18.190
here, and so now I need to make absolutely certain that the update method really is still working,

481
00:30:18.190 --> 00:30:18.970
actually.

482
00:30:19.390 --> 00:30:26.230
So what I'm going to do here is this for a minute, I'm just going to comment out that that implementation

483
00:30:26.230 --> 00:30:30.070
of update to take it back to before we actually had implemented anything.

484
00:30:30.070 --> 00:30:32.830
And then I'm going to rerun this and see this fail again.

485
00:30:33.340 --> 00:30:33.860
There we go.

486
00:30:33.880 --> 00:30:34.300
Cool.

487
00:30:34.330 --> 00:30:34.960
OK, good.

488
00:30:35.290 --> 00:30:40.540
So that does fail if you don't have an actual implementation of update.

489
00:30:40.870 --> 00:30:41.260
All right.

490
00:30:41.290 --> 00:30:47.230
Now I'm pretty satisfied, so I'm going to undo that comment and then I'm going to run this again.

491
00:30:47.260 --> 00:30:48.220
There we go.

492
00:30:48.940 --> 00:30:49.390
There you go.

493
00:30:49.420 --> 00:30:53.640
OK, so now let's jump back over to the test method again.

494
00:30:53.650 --> 00:31:00.940
OK, so that is not equal with compared to I had actually not used that before.

495
00:31:01.060 --> 00:31:06.400
I just wanted to give it a try, and I'm going to have to read up on that and see exactly what it's

496
00:31:06.400 --> 00:31:06.670
doing.

497
00:31:06.680 --> 00:31:11.650
I assumed it would have just been calling the compared to method of the big decimal.

498
00:31:11.860 --> 00:31:16.120
And maybe it is, and maybe there's some issues that we have to be more mindful of.

499
00:31:16.360 --> 00:31:22.330
But with just the basic is not equal to this is working as I was expecting.

500
00:31:22.540 --> 00:31:28.030
And it looks like you do have to have a working implementation of update now to make ourselves feel

501
00:31:28.030 --> 00:31:28.840
a little worse.

502
00:31:29.110 --> 00:31:34.600
Let's go ahead and run all the tests, and I'm pretty sure the find all method and maybe some other

503
00:31:34.600 --> 00:31:37.260
stuff too for all I know is going to fail.

504
00:31:37.270 --> 00:31:38.920
So let's try everything now.

505
00:31:39.250 --> 00:31:46.000
Yeah, we got one failed test and it is the can find, OK, well, that's pretty good actually, that

506
00:31:46.000 --> 00:31:49.930
only the can find all method is failing and nothing else, right?

507
00:31:50.320 --> 00:31:53.440
So I think we can go ahead and fix this really, really quickly.

508
00:31:54.730 --> 00:32:00.760
So what we'll do is we'll jump back over to the repository, and I think we already know where to go.

509
00:32:00.970 --> 00:32:02.860
It's with this find all sequel.

510
00:32:02.860 --> 00:32:07.690
We need to add in the retrieving of the salary as well now.

511
00:32:07.690 --> 00:32:12.340
So I'm going to just add that in real quick salary, just like that.

512
00:32:12.730 --> 00:32:17.220
And maybe this will work with no further changes.

513
00:32:17.230 --> 00:32:17.670
I don't know.

514
00:32:17.680 --> 00:32:21.730
Let's just see this is where it's nice again to have a nice suite of tests.

515
00:32:22.060 --> 00:32:26.140
Sometimes you can kind of turn your brain off a little bit and just trust the tests.

516
00:32:26.200 --> 00:32:26.650
OK.

517
00:32:27.020 --> 00:32:32.290
So before I have to get super smart and second, guess everything, let's just run the tests and see

518
00:32:32.290 --> 00:32:33.400
if that's all we needed.

519
00:32:33.670 --> 00:32:34.000
Hey.

520
00:32:34.570 --> 00:32:36.640
Apparently, that is all we needed now.

521
00:32:36.700 --> 00:32:37.960
I do want to point out something.

522
00:32:37.960 --> 00:32:45.310
One of the reasons why that's all we needed is because we were relatively smart in some of our preparations

523
00:32:45.310 --> 00:32:45.820
for things.

524
00:32:46.060 --> 00:32:54.490
By reusing methods like extract person from results sat here and yeah, and here as well in the find

525
00:32:55.060 --> 00:32:59.530
when when we fixed it for one, we fixed it for all, essentially.

526
00:32:59.650 --> 00:33:02.950
Also, though, when we broke it for one, we broke it for all right.

527
00:33:03.370 --> 00:33:10.750
So by just adding the salary portion up here, that's all we needed to do to make that all work again,

528
00:33:10.750 --> 00:33:11.560
apparently.

529
00:33:12.250 --> 00:33:16.150
So now we have implemented an update method.

530
00:33:16.390 --> 00:33:22.090
Now just looking at this again, just acknowledging that we had to think this through a little bit more

531
00:33:22.090 --> 00:33:25.540
just in terms of how to get a working test scenario.

532
00:33:26.110 --> 00:33:34.900
So a big part of testing with TD or even without TDD is taking the time to really come up with a halfway

533
00:33:34.900 --> 00:33:36.970
decent test scenario, right?

534
00:33:36.980 --> 00:33:40.330
Like how are we going to test this scenario?

535
00:33:40.480 --> 00:33:45.520
And sometimes that's not so straightforward as as we saw here, right?

536
00:33:45.640 --> 00:33:51.040
We first have to just figure out, OK, how do we do we save the thing first and then we retrieve it

537
00:33:51.040 --> 00:33:55.390
and then we change it, and then we put it back, and then we have to get it back again and then we

538
00:33:55.390 --> 00:33:55.840
change it.

539
00:33:56.080 --> 00:33:58.210
You know, you have to think through these things.

540
00:33:58.480 --> 00:34:05.230
But the main thing is make sure that whatever you do, you have a failing test before you go and implement

541
00:34:05.230 --> 00:34:08.860
any real code, right, as long as you start with a failing test.

542
00:34:09.130 --> 00:34:13.930
Then you implement some code, then you run the test again and then hopefully it passes.

543
00:34:14.170 --> 00:34:18.220
Then you can mostly trust that you're probably on the right path.

544
00:34:18.310 --> 00:34:18.760
OK.

545
00:34:19.360 --> 00:34:20.190
All right.

546
00:34:20.200 --> 00:34:24.760
So let's go ahead and bring this one to a close and I will see you in the next one.
