1
00:00:00,120 --> 00:00:06,960
All right, so now let's take a step back and look a little bit deeper into where these streams actually

2
00:00:06,960 --> 00:00:13,470
can come from, because right now we're only seeing one example of where we can even get a stream from.

3
00:00:13,650 --> 00:00:21,750
And in this case, it's coming from this, this string, this people text variable rates that we're

4
00:00:21,750 --> 00:00:23,580
calling people text that get lines.

5
00:00:23,850 --> 00:00:31,960
So this line's method here is returning a stream, and that's the start of this entire pipeline.

6
00:00:31,980 --> 00:00:32,400
OK.

7
00:00:32,640 --> 00:00:40,080
But there are other ways to create a stream, and I want to show you some of those real quick.

8
00:00:40,470 --> 00:00:47,760
Now, I would say the most common place to get a stream started is actually from any of the collection's

9
00:00:47,760 --> 00:00:48,570
classes.

10
00:00:48,810 --> 00:00:56,070
So generally speaking, the classes that implement the collection interface, which we have previously

11
00:00:56,070 --> 00:01:03,390
learned about right like lists and sets and maps and all those guys, those classes, generally speaking,

12
00:01:03,660 --> 00:01:12,180
have great support for the Streams API, and I would go so far as to say that the Streams API was really

13
00:01:12,480 --> 00:01:16,830
created with the Collections API in mind.

14
00:01:16,890 --> 00:01:17,370
OK.

15
00:01:18,240 --> 00:01:20,490
So let me show you a few examples of what I mean.

16
00:01:21,510 --> 00:01:28,170
Real quick, I'm going to kind of just ignore this bit of code, and we'll just make some new lines

17
00:01:28,170 --> 00:01:29,160
here real quick here.

18
00:01:29,460 --> 00:01:35,160
So let's say that I wanted to create a list of strings.

19
00:01:35,280 --> 00:01:42,510
Now the things that we run, the objects that we run through the streams API do not have to be strings,

20
00:01:42,510 --> 00:01:45,600
by the way, they can be objects and we will see some of that later.

21
00:01:45,810 --> 00:01:51,420
But for example, purposes, it's just easy for me to create a quick collection of strings so that I

22
00:01:51,420 --> 00:01:54,120
don't have to work with creating whole entire objects.

23
00:01:55,110 --> 00:01:56,430
So let's see.

24
00:01:56,430 --> 00:02:06,630
Let's say that I do a list of and then I let import that and I will just do something like one two,

25
00:02:07,620 --> 00:02:10,650
three four.

26
00:02:12,000 --> 00:02:16,970
Then I will capture that inside of a variable nums.

27
00:02:17,880 --> 00:02:18,270
All right.

28
00:02:18,280 --> 00:02:21,990
So there's my variable called NUM's, that it is a list, right?

29
00:02:22,350 --> 00:02:30,270
So now I can refer to the NUM's variable and start doing things with it via the Streams API.

30
00:02:30,630 --> 00:02:39,120
So let's say first off that I just want to print out each of the items in the NUM's collection similarly

31
00:02:39,120 --> 00:02:41,360
to how we're doing up here with the for each right.

32
00:02:41,370 --> 00:02:42,510
So what would that look like?

33
00:02:42,780 --> 00:02:46,920
Well, I will reference Nums and then there's a method on nuns now.

34
00:02:46,950 --> 00:02:48,840
I guess I'll hit enter oops!

35
00:02:48,840 --> 00:02:53,040
And back up a little bit and do a period here.

36
00:02:53,190 --> 00:02:59,340
And the first thing I will need to do is to reference the method stream, right?

37
00:02:59,340 --> 00:03:08,730
Their stream that is how you get a stream or you start a stream from a collection.

38
00:03:08,820 --> 00:03:11,280
Usually the stream method.

39
00:03:11,310 --> 00:03:13,170
OK, so stream.

40
00:03:13,620 --> 00:03:17,520
And then from here I can do something like a for each.

41
00:03:18,540 --> 00:03:27,510
And then I can do what I'm doing up above system outline, print line, just like so and so that would

42
00:03:27,510 --> 00:03:28,800
print out our one two, three four.

43
00:03:28,800 --> 00:03:30,210
And in fact, I guess I'll run this.

44
00:03:30,420 --> 00:03:36,960
Now, mind you, let's see here for right now, I guess I'll comment this out just so we don't have

45
00:03:36,960 --> 00:03:39,330
to see the noise of of both of these.

46
00:03:39,600 --> 00:03:40,920
And I'm running this now.

47
00:03:42,220 --> 00:03:44,290
OK, so there we go one, two, three four.

48
00:03:44,680 --> 00:03:53,680
Just like so and then I can do other neat tricks like I can use the map method here and maybe convert

49
00:03:53,680 --> 00:03:55,000
all of these to uppercase.

50
00:03:55,390 --> 00:03:57,820
Let's see what that would look like, so I can call map.

51
00:03:59,380 --> 00:04:03,490
Let's see String two uppercase.

52
00:04:03,790 --> 00:04:04,300
Look at that.

53
00:04:04,600 --> 00:04:09,610
And so that's the most concise way that I can do this.

54
00:04:10,120 --> 00:04:16,660
And again, notice that I'm not having to explicitly put parentheses in here like this and then pass

55
00:04:16,660 --> 00:04:18,250
in some variable or something.

56
00:04:18,340 --> 00:04:24,370
I could do that, but then I could not use this method reference syntax.

57
00:04:24,550 --> 00:04:30,490
I would need to revert to the two something like a lambda, which is fine.

58
00:04:30,490 --> 00:04:31,570
I can do that right.

59
00:04:31,720 --> 00:04:40,510
I can do like a in four number and then the Arrow operator and then in in that to upper.

60
00:04:40,510 --> 00:04:42,970
And I want this one here, right?

61
00:04:43,120 --> 00:04:44,410
So I can do that.

62
00:04:45,010 --> 00:04:56,290
But many times it's actually less verbose just to use the method reference syntax like so and and some

63
00:04:56,290 --> 00:04:57,980
might argue it's a little clearer.

64
00:04:58,000 --> 00:05:03,310
Also, because essentially, you can if you once you understand the streams API, then you understand

65
00:05:03,310 --> 00:05:09,760
that each of these objects is going to pass through this pipeline and then each thing that we're saying

66
00:05:09,760 --> 00:05:13,660
to do is going to be done on each of those objects, right?

67
00:05:13,660 --> 00:05:18,670
So we're uppercase in each of these things and then we're printing each of these things, right?

68
00:05:18,910 --> 00:05:21,130
So let's run that and see what that looks like.

69
00:05:22,090 --> 00:05:22,720
There you go.

70
00:05:22,870 --> 00:05:24,190
So nice, right?

71
00:05:25,400 --> 00:05:26,030
Let's see.

72
00:05:26,050 --> 00:05:30,040
We could get the length of each of them in just print that out.

73
00:05:35,510 --> 00:05:36,080
There you go.

74
00:05:36,500 --> 00:05:38,030
Let's see what that looks like.

75
00:05:40,140 --> 00:05:44,310
I think we should get a three, three, five, yeah, three, three, five four.

76
00:05:44,340 --> 00:05:45,030
Right, yeah.

77
00:05:45,270 --> 00:05:45,600
Cool.

78
00:05:46,560 --> 00:05:48,690
So that's really, really nice right now.

79
00:05:48,720 --> 00:05:53,780
Believe me, there's so much more that we can do with this API.

80
00:05:53,790 --> 00:05:57,180
We're we're not even scratching the surface of all of what it can do.

81
00:05:57,220 --> 00:06:03,510
I just want to kind of ease you into it a little bit here not to imply that it's difficult, but there's

82
00:06:03,510 --> 00:06:05,550
a lot there's a lot of cool stuff that we can do.

83
00:06:06,360 --> 00:06:08,000
So let's see.

84
00:06:08,010 --> 00:06:10,890
So in this particular case, we're working with a list.

85
00:06:11,010 --> 00:06:13,910
Actually tell you what, let me change this collection.

86
00:06:14,100 --> 00:06:19,710
Let me change this interface here to something even more generic like collection.

87
00:06:21,630 --> 00:06:22,020
All right.

88
00:06:22,200 --> 00:06:23,830
And I can do that, right?

89
00:06:23,850 --> 00:06:31,140
That's valid because list is a subclass, technically a sub interface of collection, and so I can always

90
00:06:31,140 --> 00:06:39,570
store instances of of a sub in the super class, right on a subclass in the super class, right?

91
00:06:41,340 --> 00:06:45,990
The reason I did that is, though, is because I want to change the implementation here also.

92
00:06:45,990 --> 00:06:49,530
So instead of a list, let's say I do a set.

93
00:06:51,060 --> 00:06:52,620
And I will import that.

94
00:06:53,580 --> 00:06:54,210
There we go.

95
00:06:54,360 --> 00:06:57,150
And nothing needs to change here.

96
00:06:57,990 --> 00:06:58,440
OK.

97
00:06:58,860 --> 00:06:59,910
And I don't know.

98
00:06:59,970 --> 00:07:01,510
Let's do one more little thing here.

99
00:07:01,530 --> 00:07:02,530
How about calling?

100
00:07:02,550 --> 00:07:04,500
How about getting the hash code?

101
00:07:05,790 --> 00:07:10,170
So if we want the hash code, we can refer to that.

102
00:07:10,710 --> 00:07:11,980
Let's see what that'll look like.

103
00:07:14,210 --> 00:07:16,130
There they are, there are the hash codes.

104
00:07:16,340 --> 00:07:17,630
Now these are in decimal.

105
00:07:17,960 --> 00:07:20,420
What if we wanted them to be in hexadecimal?

106
00:07:22,570 --> 00:07:27,310
Can you think of a way to convert these to hexadecimal and get them all printed out?

107
00:07:28,170 --> 00:07:36,390
One way that I can think of converting that to hash code to a hexadecimal representation would be maybe

108
00:07:36,390 --> 00:07:39,240
to to do another map.

109
00:07:41,190 --> 00:07:47,700
So you can you can stream together pretty much infinite numbers of steps in your pipeline and you can

110
00:07:47,700 --> 00:07:52,870
do multiple of the multiples of the same steps if you like, if it makes sense to do.

111
00:07:53,190 --> 00:07:55,410
So what I what we're getting here is the hat.

112
00:07:55,680 --> 00:08:04,440
This first map is converting the string into a hash code, which is an integer, right?

113
00:08:04,890 --> 00:08:12,180
But I want that integer to be represented as a hexadecimal value, and one way that I can think of doing

114
00:08:12,180 --> 00:08:14,520
that would be to call another map.

115
00:08:14,730 --> 00:08:21,900
And there's a there's a magical method on the integer class integer Cohen.

116
00:08:25,370 --> 00:08:29,420
To Hex String, there it is like that.

117
00:08:30,500 --> 00:08:32,210
Let's try that out and see what we get.

118
00:08:33,770 --> 00:08:35,060
Yeah, there we go.

119
00:08:35,810 --> 00:08:37,610
Pretty nice right now.

120
00:08:37,610 --> 00:08:39,470
I can think of another way to do this as well.

121
00:08:39,470 --> 00:08:41,350
And just for grins, I'll show you real quick.

122
00:08:41,360 --> 00:08:46,610
This doesn't have much to do with streams anymore, but always good to do a little tiny bit of review.

123
00:08:46,760 --> 00:08:53,930
So the other way that I can think of to get these hacked strings, I'll delete that would be to do it

124
00:08:53,930 --> 00:08:55,250
down here in the for each.

125
00:08:55,550 --> 00:09:03,290
So I will delete this system out line and I will revert to using the lambda notation again.

126
00:09:03,500 --> 00:09:06,620
So I'll do something like an h and then an arrow.

127
00:09:06,620 --> 00:09:09,980
I'm just picking a random variable name here h for Hex, right?

128
00:09:11,300 --> 00:09:23,360
And then system got out print f and then I will use a print format code right and I can do a percent

129
00:09:23,360 --> 00:09:30,560
h and then a percent in for a new line and then refer to that variable.

130
00:09:30,560 --> 00:09:37,310
So what I'm saying here is take this value h, which is going to be passed in from the previous step

131
00:09:37,310 --> 00:09:38,030
in the pipeline.

132
00:09:38,030 --> 00:09:45,710
So this is going to be the Hex, the hash code in in decimal form, though, right?

133
00:09:47,510 --> 00:09:49,190
H, here's four hash code, I guess.

134
00:09:50,990 --> 00:09:58,730
And then we're going to call a system out print f where we're going to pass in that hash code in decimal

135
00:09:58,730 --> 00:10:03,820
form, but we're asking print f to convert the decimal to hex.

136
00:10:03,830 --> 00:10:05,570
That's what this is actually doing.

137
00:10:05,600 --> 00:10:06,080
OK.

138
00:10:06,680 --> 00:10:07,820
Let's see if this works.

139
00:10:09,560 --> 00:10:09,800
All right.

140
00:10:09,810 --> 00:10:13,970
So yeah, so there's an alternative way that we could get that done right?

141
00:10:14,150 --> 00:10:21,350
But I would say that this is a little noisier than than than that.

142
00:10:22,100 --> 00:10:22,610
I don't know.

143
00:10:25,070 --> 00:10:29,910
To my eye, this looks a little a little cleaner, a little more straightforward.

144
00:10:30,360 --> 00:10:32,580
So just to reiterate.

145
00:10:33,670 --> 00:10:40,300
You can call the stream method on any collection to start using the Streams API to do things right.

146
00:10:40,630 --> 00:10:47,890
And so any types of objects that would be valid in a collection can be manipulated or worked with in

147
00:10:47,890 --> 00:10:49,330
with the Streams API, right?

148
00:10:49,330 --> 00:10:50,620
So they don't have to be strings.

149
00:10:50,740 --> 00:10:56,350
You could have a collection of people or or integers or whatever.

150
00:10:56,360 --> 00:10:58,000
It doesn't really matter.

151
00:10:58,870 --> 00:10:59,210
All right.

152
00:10:59,230 --> 00:11:04,060
Now, did you think we were done learning how to create streams because we're not even nearly done?

153
00:11:04,390 --> 00:11:10,000
There are a whole lot of other ways to create your initial stream, and we're going to try to just do

154
00:11:10,000 --> 00:11:13,900
a quick marathon run through most, if not all, of those ways.

155
00:11:14,170 --> 00:11:26,380
So right now, we're creating a stream of strings from a set by calling the dot stream method on this

156
00:11:26,380 --> 00:11:27,120
set right.

157
00:11:27,130 --> 00:11:29,530
And so in general, we can do this with collections.

158
00:11:29,710 --> 00:11:32,050
However, there's so much more that we can do.

159
00:11:32,800 --> 00:11:33,390
Let's see here.

160
00:11:33,400 --> 00:11:35,290
So what I want to show you.

161
00:11:35,320 --> 00:11:38,020
Let's let's let's just let's see.

162
00:11:38,020 --> 00:11:42,460
Let's get rid of all of this, I think.

163
00:11:43,030 --> 00:11:45,850
And I think we can even get rid of that.

164
00:11:46,330 --> 00:11:49,640
And now let me show you what else we can do.

165
00:11:49,660 --> 00:11:58,720
Alternatively, so the stream class itself has the ability to create streams, and it's actually quite

166
00:11:58,720 --> 00:11:59,320
useful.

167
00:11:59,980 --> 00:12:02,800
And so if we just do a stream dot.

168
00:12:04,060 --> 00:12:04,810
There you go.

169
00:12:05,050 --> 00:12:11,770
And we'll get rid of the semicolon, and then of course, we won't need to call a stream method explicitly,

170
00:12:11,770 --> 00:12:13,870
and in fact, it doesn't exist anyway.

171
00:12:14,110 --> 00:12:15,070
So we'll get rid of that.

172
00:12:15,070 --> 00:12:22,160
And voila, we are now creating a stream of strings, just using the stream class.

173
00:12:22,180 --> 00:12:25,450
Boy, that's that's a that's a bit of a tongue twister, isn't it?

174
00:12:26,350 --> 00:12:28,390
So anyway, very straightforward.

175
00:12:28,390 --> 00:12:29,320
Super convenient.

176
00:12:29,500 --> 00:12:33,340
Now this of method here can do quite a bit more.

177
00:12:33,550 --> 00:12:40,720
So in this particular case, we're using it to, you know, create a stream of strings, right?

178
00:12:40,990 --> 00:12:44,320
However, look what else we can do.

179
00:12:45,240 --> 00:12:52,710
If I get rid of these, we could refer to a bunch of numbers one two three four.

180
00:12:53,520 --> 00:12:56,310
Like so and no problem there.

181
00:12:56,340 --> 00:13:00,270
However, we do end up with a problem with the mapping, right?

182
00:13:00,390 --> 00:13:08,400
So the thing is this of method here recognizes the general type of the objects that we're passing in.

183
00:13:08,550 --> 00:13:14,610
In this particular case, it recognizes that we're referring to numbers, integers, and so it automatically

184
00:13:14,610 --> 00:13:19,950
returns a stream of integer now because it's returning a stream of integers.

185
00:13:20,190 --> 00:13:23,700
We can't refer to the string hash code, right?

186
00:13:23,880 --> 00:13:26,490
So I don't know, we could just get rid of that.

187
00:13:27,090 --> 00:13:27,720
There you go.

188
00:13:28,290 --> 00:13:34,440
Let's say that we even wanted to create a stream of some custom class of some sort.

189
00:13:35,070 --> 00:13:36,110
So we could do that.

190
00:13:36,120 --> 00:13:38,850
In fact, I'll do it real quickly in line here.

191
00:13:39,060 --> 00:13:41,610
Now, I won't technically create an actual class.

192
00:13:42,300 --> 00:13:43,710
I will create a record.

193
00:13:43,710 --> 00:13:51,600
If you remember, records are basically just like more streamlined classes with a lot less boilerplate.

194
00:13:51,810 --> 00:13:54,510
So I can create a record right here in line.

195
00:13:54,840 --> 00:13:58,500
I can just use the keyword record just as I would have used the keyword class.

196
00:13:59,520 --> 00:14:02,430
Let's say we want a model cars, for example.

197
00:14:02,430 --> 00:14:07,860
So here's a car and then I can just specify kind of like the constructor, right?

198
00:14:08,070 --> 00:14:09,240
All in line here.

199
00:14:09,450 --> 00:14:16,140
So let's say that we're going to have we're going to model a car and we can have properties of a make

200
00:14:16,650 --> 00:14:20,460
and a model like so.

201
00:14:22,140 --> 00:14:25,290
Here we go now down here.

202
00:14:26,760 --> 00:14:30,600
I can start creating a stream of cars.

203
00:14:32,460 --> 00:14:33,540
Like this?

204
00:14:37,870 --> 00:14:38,440
Ford.

205
00:14:40,660 --> 00:14:41,620
Bronco.

206
00:14:45,220 --> 00:14:46,450
And A.

207
00:14:48,160 --> 00:14:49,060
Tesla.

208
00:14:51,750 --> 00:14:52,410
ABC's.

209
00:14:53,590 --> 00:14:54,910
And one more.

210
00:14:57,460 --> 00:14:58,840
We'll do another Tesla.

211
00:15:00,270 --> 00:15:01,080
Tesla.

212
00:15:02,980 --> 00:15:03,550
Three.

213
00:15:06,280 --> 00:15:14,080
OK, so like that now, of course, in this particular case, mapping to the integer hex string doesn't

214
00:15:14,080 --> 00:15:21,550
make sense, so we'll just get rid of that and we can run this now that's going to end up just calling

215
00:15:21,550 --> 00:15:24,820
the default implementation of the two string method, right?

216
00:15:27,310 --> 00:15:27,940
There we go.

217
00:15:28,150 --> 00:15:29,020
So wonderful.

218
00:15:30,340 --> 00:15:35,110
And you know, we could even do some fancy things here, like the filtering filter.

219
00:15:35,920 --> 00:15:44,290
Let's see for car looks for cars where car does not make.

220
00:15:46,450 --> 00:15:47,440
Equals.

221
00:15:48,940 --> 00:15:55,360
Tesla, and as you know, maybe we'd prefer to put the Tesla in the front.

222
00:15:55,960 --> 00:15:58,240
Tesla, that equals.

223
00:15:59,510 --> 00:16:00,560
See that make.

224
00:16:03,920 --> 00:16:07,370
All right, so that should only give us the Teslas, right?

225
00:16:08,660 --> 00:16:09,200
There we go.

226
00:16:09,230 --> 00:16:09,590
Yes.

227
00:16:09,830 --> 00:16:13,940
Only the Teslas, OK, so we can do that.

228
00:16:14,390 --> 00:16:19,460
Now I want to show you a couple other things before we leave the stream sort of method here.

229
00:16:19,460 --> 00:16:21,710
So I'm going to get rid of these cars.

230
00:16:24,380 --> 00:16:28,460
And let's just go back to using strings for a second here.

231
00:16:29,090 --> 00:16:31,430
So we'll just do one easy string.

232
00:16:31,670 --> 00:16:35,660
We'll get rid of the filter, OK, so we already know that this will work.

233
00:16:35,720 --> 00:16:41,590
So here we're creating a stream that will contain one string in it right now.

234
00:16:41,600 --> 00:16:51,170
What would happen if, for whatever reason, we happened to be populating a null value into the stream?

235
00:16:51,350 --> 00:16:56,580
So for example, let's say that we had a let's say that we had a variable here.

236
00:16:57,110 --> 00:17:06,830
My VAR equals and we were using some kind of a method call that would populate this my VAR string.

237
00:17:07,010 --> 00:17:14,420
But under certain circumstances that we could not foresee, sometimes that value could be null.

238
00:17:14,450 --> 00:17:14,750
Right.

239
00:17:14,750 --> 00:17:18,080
So so sometimes it's hello in here.

240
00:17:18,080 --> 00:17:22,040
We'll even change this to be my VAR.

241
00:17:22,070 --> 00:17:22,420
All right.

242
00:17:22,430 --> 00:17:23,690
So that would be valid.

243
00:17:24,020 --> 00:17:32,240
But what if this was null because of some method call that was being made to populate the my VAR, right?

244
00:17:32,420 --> 00:17:34,370
So let's see what happens then.

245
00:17:35,520 --> 00:17:39,090
OK, so we get a novel getting printed out here.

246
00:17:39,210 --> 00:17:41,790
Maybe that's what you were expecting, maybe that's fine.

247
00:17:41,820 --> 00:17:47,370
However, you might want to consider, is that really what you want?

248
00:17:47,790 --> 00:17:55,500
If you've got a null value getting populated in to your stream, why not just not have it be in the

249
00:17:55,500 --> 00:17:56,390
stream at all, right?

250
00:17:56,400 --> 00:17:59,790
Like if it's null, meaning it's essentially nothing, right?

251
00:18:00,450 --> 00:18:02,340
Do we really want that in the stream at all?

252
00:18:02,580 --> 00:18:08,160
So if you don't want novels to be in the stream, in other words, you kind of want them just filtered

253
00:18:08,160 --> 00:18:09,300
out magically, right?

254
00:18:09,300 --> 00:18:11,970
If there's nothing for a particular value.

255
00:18:12,000 --> 00:18:13,770
Maybe you don't want that in the stream at all.

256
00:18:14,040 --> 00:18:20,110
Well, instead of doing stream, sort of, you can call streamed out of Nullarbor.

257
00:18:21,450 --> 00:18:29,550
And now we're just telling the stream sort of method Hey, look out for null values and if you encounter

258
00:18:29,550 --> 00:18:30,390
them, watch this.

259
00:18:30,750 --> 00:18:33,480
So if we run it now, watch what happens.

260
00:18:34,960 --> 00:18:36,940
Nothing, we get nothing now.

261
00:18:37,210 --> 00:18:42,940
The reason we're getting nothing now is that because we're only attempting to put one object in this

262
00:18:42,940 --> 00:18:47,560
stream, and in this particular case, the object happens to be null.

263
00:18:47,770 --> 00:18:50,740
We end up ultimately with an empty stream.

264
00:18:51,100 --> 00:18:58,870
And when a stream is empty, then the subsequent steps in that pipeline and that streams pipeline don't

265
00:18:58,870 --> 00:19:02,140
even execute right because you're at the end of the stream already.

266
00:19:02,380 --> 00:19:07,600
And so it's like we have it's almost like there's a filter step in there that's looking for needles

267
00:19:07,600 --> 00:19:08,710
and just getting rid of them.

268
00:19:08,740 --> 00:19:09,160
OK.

269
00:19:09,520 --> 00:19:14,740
So keep that in mind if you ever need that need or want that type of functionality where you just get

270
00:19:14,740 --> 00:19:16,570
rid of the the null, OK?

271
00:19:17,200 --> 00:19:21,070
And speaking of empty streams, there's one more here.

272
00:19:21,760 --> 00:19:28,420
There might be some circumstances where you actually explicitly want to create an empty stream, and

273
00:19:28,420 --> 00:19:30,760
if you ever did want to do that, bam, there you go.

274
00:19:31,570 --> 00:19:38,170
One example of where I can think you might have wanted this in the past, maybe you'd have something

275
00:19:38,170 --> 00:19:41,110
like this stream.

276
00:19:42,250 --> 00:19:45,910
My stream equals no.

277
00:19:46,900 --> 00:19:50,620
Then here let's let's get rid of that.

278
00:19:51,160 --> 00:20:00,490
Then you might have some logic that said something like, if my VAR is null, then my stream.

279
00:20:02,200 --> 00:20:04,750
Equals stream that in the.

280
00:20:06,670 --> 00:20:09,400
Else my stream.

281
00:20:10,450 --> 00:20:16,090
Equals streamed out of my VAR.

282
00:20:18,560 --> 00:20:23,600
Then down here, you would just reference my stream, right?

283
00:20:23,900 --> 00:20:31,940
So this would have been like an old school poor man's way of maybe, you know, trying to be efficient

284
00:20:31,940 --> 00:20:34,430
with your use of streams or something like that, right?

285
00:20:35,120 --> 00:20:40,520
Obviously, you don't really need to write this kind of code, but that's one example of maybe why you

286
00:20:40,520 --> 00:20:42,980
might have used the stream that empty.

287
00:20:43,130 --> 00:20:45,470
I'm sure you'll think of some really good reasons for that.

288
00:20:45,500 --> 00:20:51,770
Now, in addition to using the stream method itself, which is very, very useful, right?

289
00:20:52,610 --> 00:20:53,080
Let's see.

290
00:20:53,090 --> 00:20:54,620
We can also do a few other things.

291
00:20:54,620 --> 00:20:58,480
We can create what's called an end to stream it.

292
00:20:58,670 --> 00:21:00,890
So let me show you the entire stream.

293
00:21:01,220 --> 00:21:05,600
So what this is is just an explicit stream of integers, right?

294
00:21:05,990 --> 00:21:07,730
But it's but it's its own thing.

295
00:21:07,730 --> 00:21:10,910
So I'll show you what I mean here so we can reference the streams.

296
00:21:11,390 --> 00:21:14,720
Let's say that we just want to count from one through four.

297
00:21:14,780 --> 00:21:15,230
OK.

298
00:21:15,560 --> 00:21:22,460
So one way we could do that is to reference an end to stream like so and then call the of method of

299
00:21:22,550 --> 00:21:30,590
the stream and then just pass in some values like so and then we can, yeah, maybe do a for each and

300
00:21:30,590 --> 00:21:34,310
do a system that our loops print line like.

301
00:21:34,310 --> 00:21:38,110
So and let's just run that and you know what that's going to do.

302
00:21:38,120 --> 00:21:39,620
It'll be very straightforward.

303
00:21:40,340 --> 00:21:41,150
And there you go.

304
00:21:41,600 --> 00:21:43,640
OK, so that makes good sense, right?

305
00:21:44,270 --> 00:21:49,010
However, I don't know what if you wanted to do the same thing, but you wanted to go like from one

306
00:21:49,010 --> 00:21:50,030
to 100.

307
00:21:50,900 --> 00:21:56,870
You probably don't want to have to do five, six, seven eight now, you know, et cetera, et cetera,

308
00:21:56,870 --> 00:21:57,140
right?

309
00:21:57,350 --> 00:21:58,160
And guess what?

310
00:21:58,190 --> 00:21:59,060
You don't need to.

311
00:21:59,960 --> 00:22:01,520
So there's another method.

312
00:22:01,940 --> 00:22:05,180
In fact, there's a couple that we can use on the stream.

313
00:22:05,180 --> 00:22:13,190
There's one called range where we can pass in an inclusive starting number and an exclusive ending number.

314
00:22:13,190 --> 00:22:19,760
So if we want to list out the numbers one through 100, for example, we could do something like this

315
00:22:19,760 --> 00:22:21,020
one comma 101.

316
00:22:21,530 --> 00:22:23,800
That last number is exclusive, right?

317
00:22:23,810 --> 00:22:28,070
So the last digit that you refer to here won't be printed, right?

318
00:22:28,070 --> 00:22:31,940
So it'll go up to that, but not including that exclusive right.

319
00:22:31,940 --> 00:22:38,690
So if we went one through 100, then we probably want to say one one for our end number here.

320
00:22:38,870 --> 00:22:42,140
So if we do this, let's let's run that.

321
00:22:42,740 --> 00:22:43,300
There we go.

322
00:22:43,310 --> 00:22:45,980
So we're getting a bunch of numbers, right?

323
00:22:46,370 --> 00:22:47,660
One through 100.

324
00:22:48,050 --> 00:22:48,920
Pretty easy.

325
00:22:48,920 --> 00:22:49,730
Straightforward.

326
00:22:49,820 --> 00:22:50,270
OK.

327
00:22:50,780 --> 00:22:57,020
And then there's one other version of this, which is almost the exact same thing, except it's called

328
00:22:57,020 --> 00:22:57,770
closed.

329
00:22:57,950 --> 00:22:59,720
Now this one is inclusive.

330
00:22:59,720 --> 00:23:01,730
That's really about the only difference.

331
00:23:02,450 --> 00:23:02,780
Right?

332
00:23:02,780 --> 00:23:05,750
So starting inclusive and ending inclusive, right?

333
00:23:06,020 --> 00:23:12,590
So if we just want to end right on 100, in fact, maybe I won't go so far this time we'll do 40 right

334
00:23:12,590 --> 00:23:13,580
one through 40.

335
00:23:13,850 --> 00:23:14,660
Let's run that.

336
00:23:15,410 --> 00:23:16,880
That's going to do what you think it should.

337
00:23:18,170 --> 00:23:18,590
OK.

338
00:23:18,860 --> 00:23:25,280
Now, in addition to the enter stream, there's also a double stream and a long stream.

339
00:23:25,310 --> 00:23:32,360
OK, and actually, there's even a there's even more classes that actually inherit from the same parent

340
00:23:32,360 --> 00:23:36,410
that these these numeric stream classes inherit from.

341
00:23:36,410 --> 00:23:40,790
But those are probably the main ones that you might ever be, you know, interested in.

342
00:23:41,450 --> 00:23:43,460
So, you know, integers now.

343
00:23:44,030 --> 00:23:47,990
So integers, longs and doubles, right, is what they're all about.

344
00:23:48,140 --> 00:24:01,070
Now, one thing to be aware of the end stream is spitting out something different from from from this.

345
00:24:09,590 --> 00:24:17,960
So in this case, the streamed out of one two three is actually returning, I'll show you here a stream

346
00:24:18,050 --> 00:24:26,780
of integer like that, whereas the entire stream is actually spitting out an actual thing called an

347
00:24:26,780 --> 00:24:29,390
end loops stream.

348
00:24:29,390 --> 00:24:29,780
OK?

349
00:24:30,020 --> 00:24:34,850
So it's not a stream of integers, it's it's its own thing.

350
00:24:34,850 --> 00:24:36,870
It's an end to stream now.

351
00:24:37,990 --> 00:24:45,080
Now, conceptually, it is still a stream of integers, but one of the key differences, as I think

352
00:24:45,080 --> 00:24:54,140
we did see already, there are context aware methods that exist exclusively on these numerical streams,

353
00:24:54,140 --> 00:25:01,880
such as the stream, such as being able to get a max number and and summing up the total.

354
00:25:01,920 --> 00:25:07,580
You know, the total of all the numbers in the stream and things like that, you cannot do those operations

355
00:25:07,580 --> 00:25:09,740
on a generic stream, right?

356
00:25:10,040 --> 00:25:15,940
This generic stream type doesn't care what what type of data is in the stream, right?

357
00:25:15,950 --> 00:25:16,970
It can be cars.

358
00:25:17,150 --> 00:25:18,410
It can be strings.

359
00:25:18,530 --> 00:25:19,730
It can be integers.

360
00:25:20,120 --> 00:25:21,800
So think about it.

361
00:25:22,130 --> 00:25:29,750
If you're using a generic stream, it doesn't make sense to call a some method on a generic stream.

362
00:25:29,930 --> 00:25:36,050
That stream doesn't doesn't actively know that you've put numbers inside of it, right?

363
00:25:36,200 --> 00:25:37,310
And it doesn't care, right?

364
00:25:37,310 --> 00:25:38,360
It doesn't really know that.

365
00:25:38,360 --> 00:25:39,290
So it wouldn't know.

366
00:25:39,740 --> 00:25:43,550
Like, it wouldn't know to make the some method available.

367
00:25:43,580 --> 00:25:46,460
Only if you have put numbers in here, right?

368
00:25:46,460 --> 00:25:48,360
Because it's the same class, no matter what.

369
00:25:48,770 --> 00:25:56,330
So what the Java creators have done is they've given us specific numerical stream types when we want

370
00:25:56,330 --> 00:26:02,240
to do numeric operations on the data that's in those streams.

371
00:26:02,330 --> 00:26:06,380
And and as such, the data has to be numerical, right?

372
00:26:07,010 --> 00:26:07,350
All right.

373
00:26:07,370 --> 00:26:10,040
Now we may have already seen this again.

374
00:26:10,040 --> 00:26:10,670
Forgive me.

375
00:26:10,700 --> 00:26:14,480
We may have already seen this or I'm getting ready to show it to you in a future lesson.

376
00:26:14,480 --> 00:26:19,550
But either way, I want to show you a little bit more about the end stream here.

377
00:26:19,700 --> 00:26:22,400
Let's say that we let's see here.

378
00:26:22,430 --> 00:26:24,710
Let's let's get rid of that.

379
00:26:25,160 --> 00:26:26,930
And let's.

380
00:26:28,550 --> 00:26:28,850
All right.

381
00:26:28,850 --> 00:26:35,960
So let's say that we wanted to, I don't know, have some output that looks like something like this

382
00:26:36,710 --> 00:26:41,590
where maybe like we're just tacking on a hyphen after each number, right?

383
00:26:41,600 --> 00:26:44,000
So I don't know, maybe we do five of them.

384
00:26:44,030 --> 00:26:44,390
OK.

385
00:26:44,630 --> 00:26:46,910
So let's say that that's the output that we want.

386
00:26:47,150 --> 00:26:47,540
OK.

387
00:26:47,810 --> 00:26:49,460
How can we get that output?

388
00:26:50,740 --> 00:26:56,830
Well, one way that I could think of doing this might be to if we could treat each of these numbers

389
00:26:56,830 --> 00:27:04,990
as a string, then we could contact concatenate the hyphens onto the end of them, right and then just

390
00:27:04,990 --> 00:27:06,100
print it all out, right?

391
00:27:06,340 --> 00:27:07,660
That would be pretty straightforward.

392
00:27:07,750 --> 00:27:08,950
So let's see if we can do that.

393
00:27:09,730 --> 00:27:10,020
All right.

394
00:27:10,030 --> 00:27:11,200
So we know how to.

395
00:27:11,410 --> 00:27:13,980
We know how to generally convert within a stream.

396
00:27:13,980 --> 00:27:20,140
We know how to generally convert an object from one type to another, right with with the map method,

397
00:27:20,140 --> 00:27:20,410
right?

398
00:27:20,420 --> 00:27:22,420
So maybe we could do something like map.

399
00:27:22,630 --> 00:27:25,990
So we want to convert these numbers to strings.

400
00:27:26,020 --> 00:27:27,580
Can you think of how to do that?

401
00:27:28,730 --> 00:27:30,670
You're wanting a string from a number.

402
00:27:32,110 --> 00:27:32,470
All right.

403
00:27:32,500 --> 00:27:33,460
Did you think of it?

404
00:27:33,730 --> 00:27:35,230
We learned it a long time ago.

405
00:27:35,500 --> 00:27:35,850
All right.

406
00:27:35,860 --> 00:27:41,380
So that'll since the thing that we're going to is a string and it's coming from a simple, primitive

407
00:27:41,380 --> 00:27:43,990
type, essentially, which is a number.

408
00:27:44,080 --> 00:27:50,080
What we can do is just make use of the string value of method.

409
00:27:50,200 --> 00:27:50,530
Right?

410
00:27:50,950 --> 00:27:52,810
Generally speaking, that's what we can do.

411
00:27:52,900 --> 00:27:57,430
However, if you try this, let's see what error we're getting here.

412
00:27:57,430 --> 00:28:06,490
Bad return type in method reference cannot convert string to end cannot code cannot convert string to

413
00:28:06,490 --> 00:28:07,690
end what's going on?

414
00:28:07,870 --> 00:28:14,530
Well, if you look down here, look at this little hint that is telling us replace map with map to object.

415
00:28:16,150 --> 00:28:19,120
So let's go ahead and click that and see what happens.

416
00:28:20,220 --> 00:28:26,130
OK, now the little error went away, so what is that all about?

417
00:28:27,060 --> 00:28:34,710
Well, the problem here is essentially the fact that we're again, we're not dealing with a stream of

418
00:28:34,710 --> 00:28:36,270
integers, right?

419
00:28:36,510 --> 00:28:41,220
We're dealing with something that is its own type and end stream.

420
00:28:41,520 --> 00:28:49,350
And unfortunately, an entire stream is fundamentally incompatible with the idea of taking the individual

421
00:28:49,350 --> 00:28:56,550
numbers in it and converting them and and mapping them to other things in and of themselves, right?

422
00:28:56,820 --> 00:29:03,120
We first must get our hands on those individual numbers that are in this special enter stream so that

423
00:29:03,120 --> 00:29:05,220
we can convert them into something else, right?

424
00:29:05,490 --> 00:29:10,200
And so the entire stream class gives us a couple of ways to do that.

425
00:29:10,440 --> 00:29:14,370
One way is by calling the map to object method here.

426
00:29:14,550 --> 00:29:21,840
Now this is useful if you know that you want to map or convert the the values that are in your into

427
00:29:21,900 --> 00:29:26,700
stream to something that is probably not numerical, although it could be numerical.

428
00:29:26,700 --> 00:29:29,880
But I'm going to show you another way that you could do that as well.

429
00:29:29,910 --> 00:29:30,300
OK.

430
00:29:30,420 --> 00:29:36,150
So in our case, we want to convert these numbers in the stream to strings themselves, right?

431
00:29:36,810 --> 00:29:43,560
And so we're wanting to map the information or the values that are in the stream to some object type.

432
00:29:43,560 --> 00:29:46,500
And in this case, the objects are strings, right?

433
00:29:46,740 --> 00:29:49,380
And so we can do that just like this.

434
00:29:49,410 --> 00:29:49,800
OK.

435
00:29:49,950 --> 00:29:57,030
And now that we've got strings now we can do a regular map like so and we've got these strings.

436
00:29:57,030 --> 00:30:01,350
So I'll just use a lambda here and we'll say something like a second cat.

437
00:30:02,310 --> 00:30:08,550
And then there's our hyphens, and now if we run this, we should get the desired output.

438
00:30:09,960 --> 00:30:10,590
There we go.

439
00:30:10,650 --> 00:30:11,580
There it is, right?

440
00:30:12,090 --> 00:30:12,450
All right.

441
00:30:12,460 --> 00:30:17,580
So that's one way we can do that now instead of the map to object.

442
00:30:17,580 --> 00:30:26,430
The other way we could do this is to insert one more method call up above, which is called boxed.

443
00:30:27,510 --> 00:30:33,030
And then here we can just do a regular old map.

444
00:30:33,480 --> 00:30:42,930
OK, now the difference is that the box, the method, what it actually returns is a stream of integers,

445
00:30:42,930 --> 00:30:43,290
right?

446
00:30:43,830 --> 00:30:49,320
So again, what fundamentally comes from an end to stream is its own data type.

447
00:30:49,320 --> 00:30:53,400
It's something called end stream, so it's not a stream of anything.

448
00:30:53,550 --> 00:30:59,760
It is an entire stream just if you're having trouble understanding this.

449
00:30:59,910 --> 00:31:05,430
Maybe you should just think of it this way and into stream doesn't have numbers in it.

450
00:31:05,880 --> 00:31:08,760
It has things in it that we can't know about.

451
00:31:09,000 --> 00:31:09,480
OK.

452
00:31:09,870 --> 00:31:17,950
But it can give us numbers if we either call the box method or if we call the map to object.

453
00:31:17,970 --> 00:31:18,870
OK, now what?

454
00:31:19,080 --> 00:31:27,000
So the boxed method is actually returning a traditional stream of integers.

455
00:31:27,030 --> 00:31:27,420
OK.

456
00:31:27,600 --> 00:31:35,010
So in this case, if you knew that you wanted a stream of integers explicitly and you weren't planning

457
00:31:35,040 --> 00:31:42,060
to convert them to something else soon afterwards, then using the boxed method might make sense.

458
00:31:42,240 --> 00:31:47,910
Although, generally speaking, what that's doing, the reason it's called boxed is because it is boxing.

459
00:31:48,210 --> 00:31:56,380
It is boxing our integers using the using the numerical wrapper classes that we've learned about before.

460
00:31:56,400 --> 00:31:56,640
Right.

461
00:31:56,640 --> 00:31:56,970
So.

462
00:31:57,070 --> 00:31:59,880
So this integer here, right, that's the box class.

463
00:31:59,880 --> 00:32:06,240
And I don't know if you'll recall, but I but I stated before that these these wrapper classes are a

464
00:32:06,240 --> 00:32:07,620
little expensive, right?

465
00:32:07,710 --> 00:32:14,820
That's the whole reason that Java has the primitive data types, in fact, was to kind of avoid having

466
00:32:14,820 --> 00:32:22,110
the expense of using full full on objects for something so fundamental as just like numbers and things.

467
00:32:22,890 --> 00:32:29,610
But if you know you need that for whatever reason, there you have it now with these two approaches

468
00:32:29,610 --> 00:32:33,180
that I've just shown better approach would be, I'm going to undo.

469
00:32:33,180 --> 00:32:41,340
This would be to just use the map to object because we're avoiding the unnecessary additional step of

470
00:32:41,340 --> 00:32:49,410
having a stream of integers and then only to turn around and convert the stream of integers into strings

471
00:32:49,410 --> 00:32:50,430
anyway, right?

472
00:32:50,640 --> 00:32:57,060
So with this approach, we skip that middleman step and just go straight from the unknowable numbers

473
00:32:57,210 --> 00:33:02,610
that we're not supposed to know about that are in the stream directly to strings, right?

474
00:33:03,480 --> 00:33:09,270
OK, and then we've touched this once in one of the less previous lessons.

475
00:33:09,270 --> 00:33:15,450
I can't remember exactly what we were doing in there, but so the next thing I want to show you is we

476
00:33:15,450 --> 00:33:16,710
can create an array.

477
00:33:17,070 --> 00:33:17,730
So I don't know.

478
00:33:17,730 --> 00:33:19,200
Let's create a string array.

479
00:33:19,750 --> 00:33:24,250
OK, we'll call it names.

480
00:33:25,400 --> 00:33:27,980
And we will initialize it.

481
00:33:31,110 --> 00:33:33,960
Terry Sam.

482
00:33:35,480 --> 00:33:36,080
Jake?

483
00:33:40,410 --> 00:33:41,730
All right, so there we go.

484
00:33:42,360 --> 00:33:44,730
Three three names in this array.

485
00:33:45,360 --> 00:33:56,940
So if we want to create a stream from this array, we can simply call arrays dot stream and then we

486
00:33:56,940 --> 00:33:59,130
can pass in our array.

487
00:34:00,210 --> 00:34:00,640
All right.

488
00:34:00,660 --> 00:34:04,830
So arrays that stream and then we pass in our array.

489
00:34:05,250 --> 00:34:08,040
And now we can use these streams API methods.

490
00:34:08,040 --> 00:34:16,290
So again, we can do like a for each system that out print line, right?

491
00:34:17,810 --> 00:34:18,470
There we go.

492
00:34:18,650 --> 00:34:24,020
And I don't know, we can get a little fancier with it and do a mapping as well and maybe like uppercase

493
00:34:24,020 --> 00:34:24,920
them, all right.

494
00:34:25,550 --> 00:34:34,250
So we can do string to uppercase like, so there we go.

495
00:34:34,280 --> 00:34:34,970
OK, cool.

496
00:34:35,510 --> 00:34:35,810
All right.

497
00:34:35,810 --> 00:34:37,550
So that's pretty straightforward.

498
00:34:37,700 --> 00:34:38,450
Very nice.

499
00:34:38,660 --> 00:34:45,500
Easy, convenient way to go from an array to a stream of whatever the value types that were in that

500
00:34:45,500 --> 00:34:45,890
array.

501
00:34:45,920 --> 00:34:48,660
And note, it does not have to be an array of strings.

502
00:34:48,680 --> 00:34:50,580
It can be an array of anything, really.

503
00:34:50,600 --> 00:34:50,960
Right?

504
00:34:51,770 --> 00:34:52,490
OK.

505
00:34:53,090 --> 00:35:00,950
And then finally, the last one and this is going to be a sneak preview into a future module where we

506
00:35:00,950 --> 00:35:06,710
will learn how to work with files like actual files, data files, text files, things like that.

507
00:35:06,890 --> 00:35:09,050
So I'm going to give you a quick little sneak preview here.

508
00:35:09,260 --> 00:35:16,130
So one thing that we've been doing for a long time now in many, many lessons is we keep copying and

509
00:35:16,130 --> 00:35:16,910
pasting.

510
00:35:17,060 --> 00:35:22,070
You know, this big thing here, but we could actually put all of this inside of a text file.

511
00:35:22,310 --> 00:35:24,440
So what I'm going to do is I'm going to shift.

512
00:35:24,530 --> 00:35:30,290
I'm going to switch over into the column selection mode with a command shift eight.

513
00:35:30,560 --> 00:35:40,250
And what that's going to allow me to do is to select just the columns that I want of text rather than

514
00:35:40,250 --> 00:35:42,230
the entire lines like so.

515
00:35:42,470 --> 00:35:42,890
OK.

516
00:35:43,100 --> 00:35:45,860
And then when I do a command c, I can copy all of that.

517
00:35:45,860 --> 00:35:48,320
Then I'll get out of out of this mode.

518
00:35:48,590 --> 00:35:57,920
Now I'm going to come up here and I'm going to create a new file, new new file, and I'm going to call

519
00:35:57,920 --> 00:36:00,470
it employees that you like.

520
00:36:00,470 --> 00:36:00,980
So.

521
00:36:01,220 --> 00:36:08,120
And here we are in this file, and then I will just paste everybody in there like so right?

522
00:36:08,120 --> 00:36:10,160
And then I will save that.

523
00:36:10,580 --> 00:36:18,290
And now, if I open up the the Project Explorer pane on the left here, you'll see that I now have this

524
00:36:18,290 --> 00:36:19,970
file employees that text.

525
00:36:20,390 --> 00:36:29,420
Now what I will do is I'm going to right click on this file and I'm going to select copy path and I'm

526
00:36:29,420 --> 00:36:32,870
going to choose absolute path.

527
00:36:33,020 --> 00:36:40,970
And now that's what that's telling me is where on my computer's hard drive or in my case, solid state

528
00:36:40,970 --> 00:36:41,600
drive, right?

529
00:36:41,720 --> 00:36:47,420
Where on the on the storage device of my computer, what path is this file actually at?

530
00:36:47,510 --> 00:36:51,170
I'm going to need that for in a moment here, so I'm going to select that.

531
00:36:51,290 --> 00:36:52,460
OK, cool.

532
00:36:52,670 --> 00:36:58,550
Now I will go back over to the streams stuff and I can close the project bit there.

533
00:36:59,060 --> 00:37:03,260
And if I come down here, watch this.

534
00:37:03,290 --> 00:37:06,020
Now, let's not lose sight of what we're actually trying to do.

535
00:37:06,140 --> 00:37:15,470
What I want to do is I want to read in this data as a stream, but from a file, not from a variable

536
00:37:15,470 --> 00:37:16,520
like we've been doing.

537
00:37:16,700 --> 00:37:19,280
And it's actually incredibly easy to do.

538
00:37:19,430 --> 00:37:27,200
So what I can do is simply reference the files class, and this class has a method on it.

539
00:37:28,660 --> 00:37:31,750
Called lines, does that look familiar?

540
00:37:31,870 --> 00:37:37,930
You know, we've been reading these, we've been reading these lines here from the string variable because

541
00:37:37,930 --> 00:37:41,200
the string class also has a short lines method, right?

542
00:37:41,410 --> 00:37:44,710
Well, so does this class called files, right?

543
00:37:45,010 --> 00:37:53,140
So I can refer to this line's method here and notice it takes as input something called a path.

544
00:37:53,620 --> 00:37:54,940
That's a file path.

545
00:37:55,120 --> 00:38:04,030
So if I actually just type in the refer to another class called Path Dot of, they're really fond of

546
00:38:04,030 --> 00:38:08,950
this of pattern because it just makes everything so easy to to do, you know?

547
00:38:09,130 --> 00:38:11,140
So anyway, path sort of.

548
00:38:11,320 --> 00:38:13,330
And now I can pass in a string.

549
00:38:13,330 --> 00:38:17,450
Guess what, string I'm going to paste in here, the one that I just copied a little bit ago, right?

550
00:38:17,470 --> 00:38:21,010
Here's this this full this full path here.

551
00:38:22,580 --> 00:38:24,840
Like so OK.

552
00:38:25,580 --> 00:38:32,150
And now what what will happen is this lines method here, just like the lines method of the string class,

553
00:38:32,330 --> 00:38:36,290
it returns a stream of strings, right?

554
00:38:36,290 --> 00:38:43,070
The lines in this case loads returning a stream of the lines of text in that text file.

555
00:38:43,940 --> 00:38:48,560
Now, before I do that, though, I have to address this little squiggly line here.

556
00:38:48,770 --> 00:38:51,320
Now that's telling me I have an unhindered exception.

557
00:38:51,320 --> 00:38:56,510
We haven't learned explicitly a whole lot about exceptions, but I've mentioned them from time to time,

558
00:38:56,510 --> 00:39:01,730
and I've told you that essentially they represent errors going wrong in the program.

559
00:39:01,880 --> 00:39:09,440
The problem here is that it is possible that the path that I'm passing in here is invalid, and any

560
00:39:09,440 --> 00:39:15,500
time you're dealing, particularly with files and things, you have the potential to screw things up

561
00:39:15,500 --> 00:39:16,200
badly, right?

562
00:39:16,220 --> 00:39:19,310
Like you could refer to a file that doesn't exist in the file system.

563
00:39:19,520 --> 00:39:26,870
And if that were to happen, basically, Java wants me to programmatically tell it, what should I do

564
00:39:26,870 --> 00:39:32,810
or what should the what should Java do if the file that I tell it to go look for doesn't exist right

565
00:39:33,050 --> 00:39:33,290
now?

566
00:39:33,290 --> 00:39:39,980
What I can do here is if I hover over this, I'm getting a little helper here that's saying, Hey,

567
00:39:39,980 --> 00:39:43,430
do you want me to add what's called an exception to this method signature?

568
00:39:44,240 --> 00:39:47,030
Actually, no, I don't want that in this particular case.

569
00:39:47,030 --> 00:39:50,480
But but that that might have been one of the things I could have done.

570
00:39:50,660 --> 00:39:55,760
Instead, one minute is also going to click on this more here, and it's going to offer me a few other

571
00:39:55,760 --> 00:39:56,450
options.

572
00:39:56,480 --> 00:39:56,960
OK?

573
00:39:57,140 --> 00:40:01,000
And one of the options that I like is to surround with a try catch.

574
00:40:01,010 --> 00:40:02,660
We're going to learn about this later.

575
00:40:02,870 --> 00:40:04,670
So don't worry about it right now, OK?

576
00:40:04,940 --> 00:40:09,980
Basically, though, I'm telling it with this code, try to open this file.

577
00:40:10,280 --> 00:40:16,550
And if it doesn't work out for you, then do whatever I say to do down here, right like this is kind

578
00:40:16,550 --> 00:40:17,780
of an alternative, right?

579
00:40:18,140 --> 00:40:20,120
So don't worry about the rest of that for now.

580
00:40:20,300 --> 00:40:26,420
So now I can come back up here now in the rest of this code inside of what's called a try block here.

581
00:40:26,660 --> 00:40:31,580
I can proceed with with doing things as if everything worked out right.

582
00:40:31,850 --> 00:40:37,100
So now I can just call my strings that API things.

583
00:40:37,100 --> 00:40:45,680
And so let's say I want to do a for each and I'll just print out those lines for now.

584
00:40:46,840 --> 00:40:49,840
OK, so if I run this, let's see what happens.

585
00:40:51,430 --> 00:40:52,630
Hey, look at that.

586
00:40:52,660 --> 00:40:53,350
Look at that.

587
00:40:53,410 --> 00:40:53,740
Right.

588
00:40:54,880 --> 00:41:00,910
So there's all those lines now just to prove that that's not coming from from here.

589
00:41:01,570 --> 00:41:04,330
Let me comment all of this out.

590
00:41:05,020 --> 00:41:05,590
There we go.

591
00:41:05,860 --> 00:41:06,160
All right.

592
00:41:06,160 --> 00:41:08,920
So now nothing could be coming from there.

593
00:41:09,150 --> 00:41:10,870
And if I run this one more time?

594
00:41:11,800 --> 00:41:12,210
Cool.

595
00:41:12,220 --> 00:41:13,690
So it still works, right?

596
00:41:13,690 --> 00:41:19,420
So we can see that this is actually loading that data from an actual file.

597
00:41:19,660 --> 00:41:27,910
And this would be a much more realistic way that if you really wanted to be loading data, long lines

598
00:41:27,910 --> 00:41:33,280
of data and things, this would be a more realistic way that we'd be doing it as professional Java developers

599
00:41:33,280 --> 00:41:41,830
rather than copying and pasting text into our program inside of a variable multi-line or a text block

600
00:41:41,830 --> 00:41:42,700
or something like that.

601
00:41:42,790 --> 00:41:43,060
Right.

602
00:41:43,210 --> 00:41:49,660
I've just been doing that for you with you for now because we haven't learned how to do file things

603
00:41:49,660 --> 00:41:50,050
yet.

604
00:41:50,290 --> 00:41:53,380
But like I said, this is a little sneak preview of how to do that.

605
00:41:53,590 --> 00:42:00,490
So the main takeaway here is that this file stat lines method here really has a lot of functionality

606
00:42:00,490 --> 00:42:02,290
packed into very little code.

607
00:42:02,830 --> 00:42:10,480
It knows how to go find that file at that path, open it up if it's readable and in good and all of

608
00:42:10,480 --> 00:42:16,510
that, it will read the individual lines out just like the string that lines method does, and then

609
00:42:17,230 --> 00:42:21,310
and then spit out a stream of strings, right?

610
00:42:21,520 --> 00:42:25,750
And then we can process them just as just as we've been doing for a while here.

611
00:42:25,990 --> 00:42:26,240
All right.

612
00:42:26,260 --> 00:42:33,040
And so I know this again was a pretty long one because I just wanted to show you and one big set most

613
00:42:33,040 --> 00:42:35,290
of the ways that you can create a stream.

614
00:42:35,320 --> 00:42:35,800
OK.

615
00:42:37,150 --> 00:42:38,200
And there you go.

616
00:42:38,320 --> 00:42:40,390
So I will see you in the next one.
