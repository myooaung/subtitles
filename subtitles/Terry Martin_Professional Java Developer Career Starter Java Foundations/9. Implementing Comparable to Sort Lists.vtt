WEBVTT
1
00:00:00.450 --> 00:00:00.910
All right.

2
00:00:00.930 --> 00:00:10.890
So in the last lesson, we learned how to sort items in a list using the list Typekit sort method where

3
00:00:10.890 --> 00:00:13.830
we are able to pass in a comparator.

4
00:00:13.980 --> 00:00:22.440
We also learned a couple of basic ways to create a comparator kind of in line by first using an anonymous

5
00:00:22.590 --> 00:00:30.720
class and then letting the ADC also convert that anonymous class directly into a lambda expression for

6
00:00:30.720 --> 00:00:34.600
us, which are both more or less functionally equivalent.

7
00:00:34.620 --> 00:00:36.210
I've made a pun there, functional.

8
00:00:36.450 --> 00:00:40.680
If you don't know about functional programming, you won't get that joke, and it's probably not a very

9
00:00:40.680 --> 00:00:41.130
good joke.

10
00:00:41.130 --> 00:00:49.200
But anyway, I want to show you a couple of other things about being able to sort lists in that way

11
00:00:49.200 --> 00:00:53.010
before we jump into another approach to sorting lists.

12
00:00:53.940 --> 00:00:55.740
So a couple of little things I want to show you.

13
00:00:56.010 --> 00:01:00.000
Turning to the ADC, let me minimize this really quickly.

14
00:01:00.150 --> 00:01:07.950
So first thing I want to show you is a little peek into how this sort method of the list and in this

15
00:01:07.950 --> 00:01:11.130
case, it'll be the sort method of the ArrayList class, right?

16
00:01:11.130 --> 00:01:13.050
Because list is just an interface.

17
00:01:14.340 --> 00:01:21.210
So let me just show you, let's just take a quick little peek into how this is actually implemented.

18
00:01:21.510 --> 00:01:30.570
So if I just jump into this now, the idea is asking me, well, which implementing class of list do

19
00:01:30.570 --> 00:01:34.860
I want to jump into to see this implementation of the sort method?

20
00:01:35.110 --> 00:01:39.240
I'm going to go ahead and just choose array list since that's what we're actually using.

21
00:01:39.960 --> 00:01:40.170
All right.

22
00:01:40.180 --> 00:01:48.540
So here we are in the sort method implementation on the array list class, and we're not going to do

23
00:01:48.540 --> 00:01:53.460
a deep analysis, but I just wanted to share a couple little things with you that I thought might be

24
00:01:53.460 --> 00:01:55.110
kind of interesting to see.

25
00:01:55.440 --> 00:01:56.280
Mainly.

26
00:01:57.640 --> 00:02:04.540
The the core thing here that's actually doing the sorting is this bit right here.

27
00:02:05.000 --> 00:02:06.730
Arrays, dots, sort.

28
00:02:06.970 --> 00:02:15.280
This is effectively a utility method that we could call directly ourselves to do the actual sorting.

29
00:02:15.790 --> 00:02:24.550
And if we hover over this sort of method to get the Java Dock for a moment here, we can see that what

30
00:02:24.550 --> 00:02:32.830
it's actually taking as input is an array, not a list or a collection, but an actual array.

31
00:02:33.070 --> 00:02:42.220
So what's happening here is this method is being passed the actual internal array of our list.

32
00:02:42.340 --> 00:02:49.810
Remember, I said that array lists actually store their data internally in an actual array.

33
00:02:49.840 --> 00:02:52.480
That's why they're called an array list.

34
00:02:52.810 --> 00:02:58.870
And so that internal array is the thing that's actually being passed in to this sort method.

35
00:02:59.200 --> 00:03:04.120
So I think that's kind of cool, along with a few other parameters, such as where it should start from

36
00:03:04.120 --> 00:03:04.960
and how big it is.

37
00:03:05.950 --> 00:03:13.450
So that's just to show you there are even other ways to to perform source if you wanted to, you could

38
00:03:13.450 --> 00:03:18.940
sort an array if you happened to be working with an array because that's what's actually happening right

39
00:03:18.940 --> 00:03:19.210
here.

40
00:03:19.660 --> 00:03:22.270
So that's one little thing I wanted to point out.

41
00:03:22.810 --> 00:03:28.450
And then let's see if I close this and we go back over here to our original code.

42
00:03:28.660 --> 00:03:36.280
I want to show you another very similar, almost identical way of doing almost the exact same thing

43
00:03:36.280 --> 00:03:36.580
here.

44
00:03:36.940 --> 00:03:44.470
In this case, we've got this list and then we are calling an object oriented method of sort telling

45
00:03:44.470 --> 00:03:47.020
it to sort itself essentially right.

46
00:03:47.440 --> 00:03:52.570
But we can also kind of invert that, if you will, and have an outside thing.

47
00:03:52.990 --> 00:03:58.390
Sort the list from the outside in and let me show you what that could look like.

48
00:03:58.660 --> 00:04:07.570
So there's a class called collections, and this is another utility class, just like the arrays class

49
00:04:07.570 --> 00:04:12.220
that we just saw for the internal implementation of that sort method on list.

50
00:04:12.760 --> 00:04:18.130
There's a collections class with a number of utility methods on it.

51
00:04:18.310 --> 00:04:21.490
And one of the utility methods is sort.

52
00:04:21.700 --> 00:04:26.470
And in fact, there are a couple different versions of these sort method.

53
00:04:26.800 --> 00:04:33.610
We'll take a look at this one right here, though, because this one here is pretty much effectively

54
00:04:33.610 --> 00:04:36.790
the same as the sort method that we're already using right now.

55
00:04:36.940 --> 00:04:39.940
So I'm going to go ahead and select that, in fact.

56
00:04:41.380 --> 00:04:49.030
And it takes as input a list as the first input and a comparator as the second input.

57
00:04:49.240 --> 00:04:52.060
So almost identical to what we have right here.

58
00:04:52.150 --> 00:05:01.690
So I could do this exact same thing by passing in a reference to our employees list like so comma space.

59
00:05:01.930 --> 00:05:09.940
And then what I can do is I can actually just grab this lambda expression, and I have to be kind of

60
00:05:09.970 --> 00:05:11.590
careful when I'm grabbing here.

61
00:05:11.740 --> 00:05:15.460
It actually ends with the closing curly brace here.

62
00:05:15.610 --> 00:05:23.710
I can grab all of that command C to copy it or control C on Windows and Linux and then paste it right

63
00:05:23.710 --> 00:05:24.190
there.

64
00:05:24.460 --> 00:05:30.490
And now that is equivalent to what I just commented out there.

65
00:05:30.490 --> 00:05:31.780
That's that's the same thing.

66
00:05:31.810 --> 00:05:38.200
And in fact, if we go and take a peek at how this guy is implemented, you'll see something kind of

67
00:05:38.200 --> 00:05:38.950
interesting.

68
00:05:39.580 --> 00:05:40.690
Look at what it's doing.

69
00:05:41.050 --> 00:05:43.570
It's just turning around and calling list that sort.

70
00:05:43.570 --> 00:05:46.420
So we're passing in the list, right?

71
00:05:46.930 --> 00:05:52.410
And then it's just calling list that sort and then passing in the comparator that we passed.

72
00:05:52.420 --> 00:05:57.880
And so this is calling the exact same method that we started off calling all along.

73
00:05:58.000 --> 00:05:59.770
It's just delegating down to it.

74
00:05:59.800 --> 00:06:07.930
Just kind of interesting to to see how Java is basically trying its best to reuse its own bits and pieces,

75
00:06:07.930 --> 00:06:08.530
really.

76
00:06:09.400 --> 00:06:12.730
So that's kind of worth just making a note of.

77
00:06:13.600 --> 00:06:14.080
All right.

78
00:06:14.230 --> 00:06:23.740
Now I want to show you, though, another way that you can do this sorting and let's see here.

79
00:06:24.460 --> 00:06:26.180
So in order to show you this.

80
00:06:26.200 --> 00:06:31.480
Let me first show you a short little example and we'll talk about it for a moment.

81
00:06:32.740 --> 00:06:41.270
So I think I will show you this example by referring to our undesirables list right here.

82
00:06:41.290 --> 00:06:43.360
So we created this undesirables list.

83
00:06:43.360 --> 00:06:46.330
Let me let me an uncommon at that.

84
00:06:46.960 --> 00:06:47.320
All right.

85
00:06:47.650 --> 00:06:51.010
So here's our undesirables list, right?

86
00:06:51.400 --> 00:06:54.820
And this is just a list of strings, right?

87
00:06:54.850 --> 00:06:56.020
Nothing, nothing else.

88
00:06:56.050 --> 00:06:57.760
Just a list of strings.

89
00:06:58.360 --> 00:07:00.100
So let me show you something here.

90
00:07:00.460 --> 00:07:05.740
So let's say that we wanted to sort this list alphabetically, right?

91
00:07:06.010 --> 00:07:08.010
So let's in fact, let's go ahead and just do it.

92
00:07:08.020 --> 00:07:10.500
So it's a list of strings undesirables.

93
00:07:10.510 --> 00:07:12.250
OK, so hit.

94
00:07:12.250 --> 00:07:16.330
Enter here and we'll do undesirables that sort.

95
00:07:17.230 --> 00:07:20.710
Now I have to pass in a comparator.

96
00:07:21.580 --> 00:07:26.500
Here's the thing, though in this case, I'm not going to create my own comparator.

97
00:07:26.950 --> 00:07:34.510
Instead, I can actually refer to a comparator that already comes with Java.

98
00:07:34.630 --> 00:07:36.760
And let me show you how I will do that.

99
00:07:37.090 --> 00:07:39.100
So I will start typing comparator.

100
00:07:39.370 --> 00:07:48.280
And if I scroll, if I go down a little bit here, you see that I've got access to an already made comparator

101
00:07:48.280 --> 00:07:54.220
called natural order, which just means that it will order these strings.

102
00:07:54.400 --> 00:08:03.730
Naturally, computer natural, which is mostly natural to humans, but it defers in a few key ways with

103
00:08:03.730 --> 00:08:05.650
computer natural ordering.

104
00:08:05.650 --> 00:08:12.130
A string holding the number 10 that is one zero would come before a string holding the number two.

105
00:08:12.460 --> 00:08:18.350
Because in natural ordering, the computer doesn't know that a ten is a 10.

106
00:08:18.370 --> 00:08:26.260
It just sees a one, and then a zero and one will always come before two in natural ordering.

107
00:08:26.350 --> 00:08:29.580
It doesn't perceive the one zero as a 10.

108
00:08:29.590 --> 00:08:32.370
It perceives it as a one, followed by zero.

109
00:08:32.410 --> 00:08:39.850
And that's why something that looks to humans like a 10 in text will actually come before something

110
00:08:39.850 --> 00:08:41.740
that looks like a two in text.

111
00:08:41.770 --> 00:08:43.180
OK, so that's natural ordering.

112
00:08:43.390 --> 00:08:46.810
Anyway, so I can select this.

113
00:08:49.270 --> 00:08:57.430
And then close that, and then I can print this out now, I will just do this this way, system out

114
00:08:57.440 --> 00:09:03.460
that print line, and then I will just pass in a reference, and I think that'll I think that will suffice.

115
00:09:03.880 --> 00:09:08.800
And then down here, I'm going to comment that bit out where we were printing out.

116
00:09:08.980 --> 00:09:12.550
The workers will just not do that for a moment.

117
00:09:12.580 --> 00:09:17.890
OK, so let's run this and see what we get with these undesirables who are currently in the order of

118
00:09:17.890 --> 00:09:19.390
Wilma, Barney and Fred.

119
00:09:20.290 --> 00:09:23.920
OK, so now we get Barney, Fred and Wilma, right?

120
00:09:23.950 --> 00:09:25.150
As you would expect.

121
00:09:25.300 --> 00:09:31.300
And you know what, I maybe what I should have done here is to not sort them in print that first.

122
00:09:31.300 --> 00:09:35.470
So I'll come and take out the sorting and then we'll run this one more time.

123
00:09:35.470 --> 00:09:42.670
Just so you just so I can prove that without that sorting, they would be in this same order that we

124
00:09:42.670 --> 00:09:44.410
have in the code up here.

125
00:09:44.890 --> 00:09:46.240
So let's see that real quick.

126
00:09:47.260 --> 00:09:47.830
There we go.

127
00:09:47.860 --> 00:09:50.190
Wilma, Barney, Fred Yes.

128
00:09:50.200 --> 00:09:52.460
So that's what you get if you don't sort them.

129
00:09:52.480 --> 00:09:58.780
OK, so what I'm basically showing you here is that in this particular case, I'll uncomment that again,

130
00:09:58.780 --> 00:10:00.580
and I will minimize this now.

131
00:10:00.700 --> 00:10:06.160
In this particular case, on Line sixty three, I didn't even have to write a comparator or anything.

132
00:10:06.160 --> 00:10:09.790
I was able to just use one that that we get for free, right?

133
00:10:10.660 --> 00:10:12.730
And there's a few of these that we can use.

134
00:10:13.060 --> 00:10:16.840
I think there's one to reverse yet reverse order.

135
00:10:16.960 --> 00:10:17.310
Yeah.

136
00:10:17.590 --> 00:10:21.640
So, you know, you could reverse things if you wanted to, whatever you want to do.

137
00:10:21.940 --> 00:10:22.280
Right?

138
00:10:22.480 --> 00:10:23.740
So that's that's pretty cool.

139
00:10:24.280 --> 00:10:32.380
So now maybe some of you should be wondering, OK, well, if Java gives you competitors already, how

140
00:10:32.380 --> 00:10:36.010
come we didn't just use it up here?

141
00:10:36.040 --> 00:10:36.290
Right?

142
00:10:36.310 --> 00:10:39.730
And in fact, I'll go ahead and even show you what that would look like.

143
00:10:40.780 --> 00:10:46.210
Compare or dot natural order just like that.

144
00:10:47.600 --> 00:10:49.580
Now what's going on?

145
00:10:49.880 --> 00:10:56.870
I'm getting if I hover my cursor here under the red squiggles, I get a message saying reason.

146
00:10:56.870 --> 00:11:04.280
No instance of type variables t exist so that I employee conforms to comparable.

147
00:11:05.060 --> 00:11:06.860
What does all of that mean?

148
00:11:07.490 --> 00:11:09.050
It's almost like gobbledygook.

149
00:11:10.160 --> 00:11:12.290
Well, there's there's a couple of issues.

150
00:11:13.220 --> 00:11:22.610
One of the issues is the question of what does it actually mean to naturally order employees in the

151
00:11:22.610 --> 00:11:23.270
first place?

152
00:11:23.320 --> 00:11:23.500
Right?

153
00:11:23.520 --> 00:11:29.960
Like, what does that even mean if we didn't write any code as we did here?

154
00:11:30.650 --> 00:11:37.550
How would Java know how we want to sort and order these employees?

155
00:11:38.150 --> 00:11:39.260
How would it know?

156
00:11:39.560 --> 00:11:39.980
Would it?

157
00:11:39.980 --> 00:11:44.930
Would it just assume that you wanted to sort them by the first name or the last name or the date of

158
00:11:44.930 --> 00:11:45.350
birth?

159
00:11:45.350 --> 00:11:45.740
Or what?

160
00:11:45.770 --> 00:11:49.970
Like, how would it know what fields to sort this by?

161
00:11:50.090 --> 00:11:52.250
It doesn't even know what an employee is, right?

162
00:11:52.260 --> 00:11:55.430
That's our own custom made class.

163
00:11:55.700 --> 00:12:02.600
So Java would have to make quite a number of assumptions for something like this to even work right?

164
00:12:02.900 --> 00:12:04.910
And so that's a big problem right there.

165
00:12:05.150 --> 00:12:08.780
How can it know what it actually means to sort these things?

166
00:12:08.840 --> 00:12:18.710
OK, so the short answer as to how this comparator could even know how to sort the elements in this

167
00:12:18.710 --> 00:12:25.880
employees list has to do with another interface, and I mentioned it briefly in the last lesson.

168
00:12:26.390 --> 00:12:35.450
There's another interface called comparable and classes in Java that already know how to be sorted are

169
00:12:35.480 --> 00:12:40.940
able to be sorted because they all implement the comparable interface.

170
00:12:40.950 --> 00:12:50.780
So coming down here, I didn't have to create my own comparator because the items in this list that

171
00:12:50.780 --> 00:12:58.820
I am wanting to sort and order are actually implementing the comparable interface and let me prove that

172
00:12:58.820 --> 00:12:59.190
to you.

173
00:12:59.210 --> 00:13:05.840
So the items that I want to sort here are strings if I jump into the string class.

174
00:13:07.470 --> 00:13:08.220
Like so.

175
00:13:09.650 --> 00:13:11.780
And look at its definition.

176
00:13:12.020 --> 00:13:18.320
Final Class String implements a number of interfaces serialize label.

177
00:13:18.620 --> 00:13:24.240
But look at this implements comparable for string or comparable string.

178
00:13:24.260 --> 00:13:24.680
OK.

179
00:13:24.890 --> 00:13:28.220
And if I jump in to this interface?

180
00:13:29.910 --> 00:13:31.080
We will see.

181
00:13:31.980 --> 00:13:36.570
That it declares one method on it, which is compare to.

182
00:13:37.410 --> 00:13:39.660
Which takes one object.

183
00:13:40.350 --> 00:13:46.710
This is the key to enabling any type of class to be sortable.

184
00:13:47.280 --> 00:13:57.690
OK, so if we want our class employee to be sortable with minimal effort on our part from the perspective

185
00:13:57.690 --> 00:14:04.050
of calling the Swart method, we would need to implement the comparable interface.

186
00:14:04.080 --> 00:14:08.400
OK, so we're going to go and do that, and then I will show you what that looks like.

187
00:14:08.910 --> 00:14:11.190
So let's close this and this.

188
00:14:15.180 --> 00:14:22.440
OK, so here we are now, we're going to have a few issues that we have to work out, and that's why

189
00:14:22.440 --> 00:14:24.420
I didn't want to start off with this.

190
00:14:25.200 --> 00:14:30.990
I've been taking you down a particular path so that I had good excuses to teach you various techniques.

191
00:14:30.990 --> 00:14:35.250
But now we need to actually undo one or two of those techniques.

192
00:14:35.250 --> 00:14:38.280
But I will explain every single thing we're doing as we do it.

193
00:14:38.310 --> 00:14:47.880
OK, so one problem we're going to run into is the fact that right now, this collection is not technically

194
00:14:47.880 --> 00:14:49.830
a collection of employees.

195
00:14:50.010 --> 00:14:57.720
It's actually a collection of I employee, which is an interface, and under certain circumstances,

196
00:14:57.720 --> 00:14:58.950
that would be just fine.

197
00:14:59.190 --> 00:15:03.060
However, that has the potential to mess us up in a few ways right now.

198
00:15:03.450 --> 00:15:09.770
So here's the issue we could potentially allow this list.

199
00:15:09.780 --> 00:15:10.770
Where are we creating it?

200
00:15:10.780 --> 00:15:12.660
We're creating this list.

201
00:15:14.870 --> 00:15:17.030
Right up here on line 34, right?

202
00:15:17.360 --> 00:15:19.100
We're creating this list up here.

203
00:15:19.280 --> 00:15:24.080
We're declaring it to be of type I employee, which is our interface, right?

204
00:15:24.290 --> 00:15:30.140
That interface only has one method declared on it, which is the get salary method, right?

205
00:15:30.170 --> 00:15:39.860
So the issue is that in order for this comparator to be able to do its job, it wants to know that the

206
00:15:39.860 --> 00:15:47.000
items inside of this list are items that implement the comparable interface.

207
00:15:47.360 --> 00:15:47.800
OK.

208
00:15:48.890 --> 00:15:58.070
So potentially one thing we could consider doing is to jump into the employee interface right here and

209
00:15:58.730 --> 00:16:01.430
declare that it extends.

210
00:16:04.680 --> 00:16:05.520
Comparable.

211
00:16:07.220 --> 00:16:15.920
For four I employee, so because this is an interface, you don't use implements here when you're declaring

212
00:16:15.920 --> 00:16:22.250
its relationship to another interface, instead, it can extend other interfaces.

213
00:16:22.280 --> 00:16:22.670
OK.

214
00:16:23.000 --> 00:16:30.500
So that would mean that the method that is declared on comparable with which is compare to would also

215
00:16:30.500 --> 00:16:36.770
have to be implemented by classes that implement the AI employee interface.

216
00:16:36.890 --> 00:16:37.310
OK.

217
00:16:38.210 --> 00:16:43.340
That's what that would mean, however, that messes up something else now.

218
00:16:44.210 --> 00:16:44.480
All right.

219
00:16:44.510 --> 00:16:55.220
So in fact, here let me let me just show this so I can do an override here and just explicitly add

220
00:16:55.220 --> 00:16:55.820
this here.

221
00:16:56.750 --> 00:16:58.270
I don't know why this comes in.

222
00:16:58.280 --> 00:17:01.880
This is part of this is part of intelligence.

223
00:17:01.910 --> 00:17:03.260
We don't need it.

224
00:17:04.490 --> 00:17:09.180
So I'm just putting this here just to be kind of explicit in showing you what's going on.

225
00:17:09.200 --> 00:17:09.560
OK.

226
00:17:09.800 --> 00:17:16.550
So now this would mean that any classes that want to implement the AI employee interface must also implement

227
00:17:16.550 --> 00:17:18.890
compared to right now.

228
00:17:19.160 --> 00:17:26.480
By doing this, this interface is no longer what we call functional functional means.

229
00:17:26.480 --> 00:17:31.850
In this case, that it's an interface that only declares one method.

230
00:17:32.330 --> 00:17:40.100
If it defines more than one method, specifically more than one abstract method, then we can no longer

231
00:17:40.100 --> 00:17:43.700
use this interface with lambda expressions.

232
00:17:43.850 --> 00:17:45.560
And here's the problem with that.

233
00:17:45.860 --> 00:17:58.220
If we jump into the employee class, you may recall that we are indeed using lambda expressions in two

234
00:17:58.220 --> 00:18:00.110
places right here in here.

235
00:18:00.980 --> 00:18:08.270
The way that this lambda expression is working just as a quick review, is that this entire method is

236
00:18:08.270 --> 00:18:13.940
expected to return something of type I employee the interface right.

237
00:18:16.270 --> 00:18:22.840
When it does so, it uses this switch statement to determine if it needs to create a programmer that

238
00:18:22.840 --> 00:18:26.140
implements high employee or a manager or an analyst or whatever.

239
00:18:26.170 --> 00:18:26.530
Right.

240
00:18:26.920 --> 00:18:31.630
But this final bit right down here is a lambda expression.

241
00:18:31.870 --> 00:18:37.540
It's really just a function or a method, if you will, though technically not really a method because

242
00:18:37.540 --> 00:18:40.330
in this form, it's not part of the class yet.

243
00:18:40.840 --> 00:18:42.910
So this is really just a function.

244
00:18:43.390 --> 00:18:51.610
And what ends up happening, though, is that Java will take this function and try to map it to one

245
00:18:51.880 --> 00:18:58.210
method that is defined on some data type that matches this signature.

246
00:18:58.300 --> 00:19:05.050
And that signature would be a method that takes no inputs and returns an integer.

247
00:19:05.080 --> 00:19:05.560
OK.

248
00:19:06.490 --> 00:19:16.000
Now, in order to know what method it can map this to, we need to help Java to infer a data type to

249
00:19:16.000 --> 00:19:21.040
map this to, and the data type that it knows that it can map this to.

250
00:19:21.040 --> 00:19:22.990
In this case is I employee.

251
00:19:23.140 --> 00:19:24.100
How does it know that?

252
00:19:24.580 --> 00:19:28.660
Well, it knows that because that's the only data type that we are saying.

253
00:19:28.660 --> 00:19:35.200
This method returns and Java sees that we are returning something from this switch.

254
00:19:35.410 --> 00:19:38.550
So Java is actually pretty smart in its analysis and things.

255
00:19:38.560 --> 00:19:45.340
It can see that, OK, this is something that you're trying to return from this switch, and that return

256
00:19:45.460 --> 00:19:51.310
has to be something that maps to the return type of this method in this particular case.

257
00:19:51.670 --> 00:20:00.220
And so it can infer that this has to somehow map to this well.

258
00:20:01.520 --> 00:20:10.580
If there is only one method on this interface and if that method signature matches this signature here,

259
00:20:10.790 --> 00:20:12.170
then that's that's easy.

260
00:20:12.500 --> 00:20:18.520
Java says, OK, you have they get salary method that takes no input and returns an integer.

261
00:20:18.530 --> 00:20:26.900
I'm going to map this lambda expression to the get salary method that is defined on this interface.

262
00:20:27.140 --> 00:20:35.210
However, if this interface has more than one abstract method and by abstract, I just mean, it's not

263
00:20:35.210 --> 00:20:37.940
static and it's not a default method, essentially, right?

264
00:20:38.840 --> 00:20:49.400
So if this interface has more than one abstract method defined on it, then Java says, I don't know.

265
00:20:49.580 --> 00:21:02.210
I'm not confident as to how to map this lambda to one of the methods that you have defined on this interface.

266
00:21:02.240 --> 00:21:02.630
OK.

267
00:21:02.660 --> 00:21:06.260
So the interface is no longer said to be functional.

268
00:21:06.740 --> 00:21:07.130
Right.

269
00:21:07.550 --> 00:21:10.250
And and so that's kind of a problem for us.

270
00:21:11.870 --> 00:21:21.950
So what I am actually inclined to do at this point is to say, let's no longer use lambda expressions

271
00:21:21.950 --> 00:21:22.090
here.

272
00:21:22.100 --> 00:21:25.300
The only reason I have this here was just because it was cool to show you right.

273
00:21:25.520 --> 00:21:26.660
And it's a good thing to know.

274
00:21:26.660 --> 00:21:31.310
I mean, it saved us a little bit of typing and everything, but we don't have to use a lambda expression.

275
00:21:31.490 --> 00:21:33.740
You now know two or three other ways to do this.

276
00:21:34.130 --> 00:21:38.250
We could convert this back into an anonymous class.

277
00:21:38.270 --> 00:21:43.810
We could make an enter class, any number of variations of class classes.

278
00:21:43.820 --> 00:21:50.300
In fact, a local in her class or an embedded in her class or just a regular class, right, we can

279
00:21:50.300 --> 00:21:51.860
do it in a lot of different ways.

280
00:21:52.160 --> 00:21:59.090
So I think the easiest thing that we can do here in order to move past this issue is going to be to

281
00:21:59.090 --> 00:22:04.130
just get away from using the lambda and use something else.

282
00:22:04.160 --> 00:22:04.490
Right?

283
00:22:05.060 --> 00:22:12.440
OK, so what we can do is just kind of revert back to a previous version of how we had some of this

284
00:22:12.440 --> 00:22:13.310
code before.

285
00:22:13.430 --> 00:22:20.090
If we go down to the bottom here, you may recall that we actually had already defined a dummy employee

286
00:22:20.090 --> 00:22:21.110
right here, right?

287
00:22:21.380 --> 00:22:26.030
And so we can really just go back to using this guy.

288
00:22:26.480 --> 00:22:31.310
So if we come back up here, what we can do is we can let's see.

289
00:22:31.310 --> 00:22:37.790
We'll just select all of that lambda and then I'm going to hold down on the option and shift, and I'm

290
00:22:37.790 --> 00:22:42.800
going to select this other lambda at the same time so that I can type everything all at once.

291
00:22:43.070 --> 00:22:48.230
And now I'm just going to create a new dummy employee like so.

292
00:22:49.130 --> 00:22:50.210
And voila!

293
00:22:51.470 --> 00:22:53.450
That problem is now solved.

294
00:22:53.780 --> 00:23:00.530
OK, now we still haven't actually directly addressed the issue at hand, though, which is how can

295
00:23:00.530 --> 00:23:04.490
we make it so that we can sort these employees easily?

296
00:23:04.520 --> 00:23:04.860
Right?

297
00:23:04.880 --> 00:23:07.580
That's what we really want to resolve.

298
00:23:08.090 --> 00:23:14.960
Well, now all we need to do is implement the comparable interface.

299
00:23:15.410 --> 00:23:18.050
So there's a couple of ways we can do this.

300
00:23:18.380 --> 00:23:26.600
But I think the way that's going to make the most sense since we want to be able to sort employees using

301
00:23:26.600 --> 00:23:34.640
their last name, maybe even their first name to write it makes the most sense to implement the comparable

302
00:23:34.640 --> 00:23:38.780
interface right here on the employee class.

303
00:23:39.410 --> 00:23:41.510
Now we can do even that in a couple of ways.

304
00:23:41.520 --> 00:23:46.190
We could just directly declare that this implements comparable.

305
00:23:46.760 --> 00:23:51.770
And then we're going to also state that it it's comparable for employee.

306
00:23:53.300 --> 00:24:00.020
So we could do that and then we'd have to go and actually implement the one method on here, the compare

307
00:24:00.020 --> 00:24:00.800
to method.

308
00:24:00.980 --> 00:24:07.820
That's one way we could do it or another way we could consider doing this would be to go back to implementing

309
00:24:07.820 --> 00:24:16.760
the I employee interface because we did already declare that the employee interface itself extends the

310
00:24:16.790 --> 00:24:17.600
comparable.

311
00:24:17.600 --> 00:24:27.140
However, it extends comparable for I employee, which again doesn't give us direct access to first

312
00:24:27.140 --> 00:24:27.980
and last names.

313
00:24:28.010 --> 00:24:29.300
We got to keep that in mind.

314
00:24:29.540 --> 00:24:31.700
Now we could still keep it this way.

315
00:24:31.700 --> 00:24:39.080
And then when we get into implementing the compare to method, we could cast it from an employee to

316
00:24:39.110 --> 00:24:40.710
specifically employee.

317
00:24:40.730 --> 00:24:42.350
That's one thing we could do.

318
00:24:43.130 --> 00:24:44.960
So there's a lot of options here, right?

319
00:24:46.700 --> 00:24:47.510
So I don't know.

320
00:24:47.540 --> 00:24:56.420
Maybe for now, what we will do is just leave it this way and we will just cast them inside of the employee

321
00:24:56.420 --> 00:24:56.870
class.

322
00:24:57.140 --> 00:25:00.620
And the reason I'm thinking this, though, I may change my mind later.

323
00:25:00.860 --> 00:25:01.010
The.

324
00:25:01.270 --> 00:25:08.560
I'm thinking this is because I don't want to have to change all of the places in the main class where

325
00:25:08.560 --> 00:25:11.530
we're currently referring to an I am employee.

326
00:25:11.710 --> 00:25:17.920
And I think we can save ourselves a little trouble there if we just cast it once in the compare to method

327
00:25:18.130 --> 00:25:21.220
inside of the employee class.

328
00:25:21.490 --> 00:25:24.430
And also, we can get rid of this.

329
00:25:25.990 --> 00:25:26.230
All right.

330
00:25:26.240 --> 00:25:33.550
So if we jump back over to the employee class here and we go down to the bottom.

331
00:25:37.400 --> 00:25:38.600
Here's what we're going to do.

332
00:25:40.100 --> 00:25:41.300
We're going to do a couple of things.

333
00:25:41.330 --> 00:25:47.570
First off, we don't need this guy to implement to declare that it implements I employee because it

334
00:25:47.570 --> 00:25:52.540
is extending employee, which itself is now implementing an employee.

335
00:25:52.550 --> 00:25:54.230
Do you get the redundancy there?

336
00:25:54.890 --> 00:25:57.020
So that's one thing that we don't need to do.

337
00:25:57.500 --> 00:26:03.140
Now, one thing that we do need to do, though, is we do need to go ahead and implement the compare

338
00:26:03.140 --> 00:26:04.640
to method itself.

339
00:26:05.510 --> 00:26:09.440
That's one of the reasons why we're getting a few little error messages here and there.

340
00:26:10.340 --> 00:26:17.590
So if I do a control, oh, I've put my cursor down here at the bottom, and if I do a control zero

341
00:26:17.660 --> 00:26:18.860
four override.

342
00:26:19.100 --> 00:26:19.820
There we go.

343
00:26:20.060 --> 00:26:26.240
I'm giving the option to override or implement really the Compare two method right there.

344
00:26:27.880 --> 00:26:37.060
All right, now again, I'm going to just get rid of this jet brains annotation thing here, which I'll

345
00:26:37.060 --> 00:26:41.340
have to read up on what that's all about, but I don't care right now, and it's not it's not part,

346
00:26:41.390 --> 00:26:42.940
it's not a standard part of Java.

347
00:26:43.450 --> 00:26:43.980
All right.

348
00:26:43.990 --> 00:26:46.960
So here is our compared to method.

349
00:26:46.990 --> 00:26:51.160
Now, this one doesn't take two objects, it just takes one.

350
00:26:51.160 --> 00:26:57.490
And the reason it only takes one object is because what you're comparing is this object like the whole

351
00:26:57.490 --> 00:27:01.780
entire thing to a second object that's being passed in.

352
00:27:01.810 --> 00:27:03.550
OK, if that makes sense, right?

353
00:27:03.820 --> 00:27:07.780
So you're comparing this to the thing that's being passed in.

354
00:27:08.650 --> 00:27:09.000
All right.

355
00:27:09.010 --> 00:27:17.740
So what will want to do in that case is first, maybe we'll just want to make sure that the object that's

356
00:27:17.740 --> 00:27:23.260
being passed in is actually of type employee.

357
00:27:23.590 --> 00:27:25.030
Now we can do that manually.

358
00:27:25.240 --> 00:27:36.160
So what we'll want to do here is first cast this oh, to type employee and and I don't think we really

359
00:27:36.160 --> 00:27:43.960
technically have to check that it's an instance of the employee because now we're no longer using that

360
00:27:43.960 --> 00:27:44.510
lambda.

361
00:27:44.530 --> 00:27:50.830
Everything here really, truly is going to be something of type employee, right, dummy employee extends

362
00:27:50.830 --> 00:27:53.560
employee and all of these extend employee as well.

363
00:27:53.680 --> 00:27:58.570
So we don't actually need to check anything anymore in this particular case.

364
00:27:59.350 --> 00:28:08.530
So I could just do something like employee and say other equals and then just cast it.

365
00:28:10.980 --> 00:28:18.090
Like so and I don't have to really worry about a class cast exception occurring in this case.

366
00:28:18.420 --> 00:28:24.480
If there was any chance for that, though, then yes, you would see me doing something like you've

367
00:28:24.480 --> 00:28:32.520
seen us do already where we'd say if, oh, instance of employee, and then maybe I'd go ahead and use

368
00:28:32.700 --> 00:28:39.780
a pattern match here as well and then put all the rest of the code defensively inside of the curly braces

369
00:28:39.780 --> 00:28:40.290
and all of that.

370
00:28:40.290 --> 00:28:43.380
But in this particular case, I'm comfortable that I don't need to do that.

371
00:28:44.280 --> 00:28:44.740
All right.

372
00:28:45.180 --> 00:28:57.750
Then down here, I can now say something like this last name compared to other Typekit last name.

373
00:28:58.200 --> 00:29:03.750
I can just return that now with this implementation, this is just a one level deep implementation,

374
00:29:03.750 --> 00:29:04.050
right?

375
00:29:04.170 --> 00:29:07.860
It's not going to get fancy and then also compare the first name.

376
00:29:08.010 --> 00:29:12.990
We've shown you how you could do that, though in the previous lesson, and you could do the exact same

377
00:29:13.140 --> 00:29:13.860
thing here.

378
00:29:15.060 --> 00:29:20.700
So I'll leave that to to you as an exercise if that's something you want to pursue further.

379
00:29:21.330 --> 00:29:21.650
All right.

380
00:29:21.660 --> 00:29:24.530
So now we've got the Compare two method implemented.

381
00:29:25.440 --> 00:29:25.790
All right.

382
00:29:25.800 --> 00:29:31.560
So now if we jump back over to the main class, oh, look at that.

383
00:29:31.890 --> 00:29:34.230
The red squiggly already went away.

384
00:29:37.030 --> 00:29:42.910
So now if we run this code again.

385
00:29:43.880 --> 00:29:54.680
And let's see here now I'm going to go back to commenting all of this out, and I will again uncomment

386
00:29:54.680 --> 00:29:57.860
this little loop where we're actually printing things.

387
00:29:58.190 --> 00:29:58.640
OK.

388
00:29:59.870 --> 00:30:00.260
All right.

389
00:30:00.290 --> 00:30:01.880
So let's run this again.

390
00:30:02.840 --> 00:30:07.370
And really, we shouldn't see any difference from the last time it was all sorted.

391
00:30:11.320 --> 00:30:11.980
There we go.

392
00:30:12.100 --> 00:30:12.430
Yeah.

393
00:30:13.120 --> 00:30:15.040
Flintstones are all looking good.

394
00:30:15.280 --> 00:30:17.200
There's are not applicable.

395
00:30:17.800 --> 00:30:18.160
Right?

396
00:30:18.340 --> 00:30:21.910
So that's what used to be a lambda and now it's just our dummy class.

397
00:30:22.090 --> 00:30:26.950
But it's still, you know, in the correct order, all the way down to rubble.

398
00:30:27.190 --> 00:30:27.880
So very cool.

399
00:30:28.060 --> 00:30:34.630
Now, if we wanted to change the sort, the sorting on that, we have a few options now.

400
00:30:35.620 --> 00:30:42.010
Let's see what happens if we if we call the reverse, let's see reverse order.

401
00:30:43.210 --> 00:30:45.040
Let's try that out and see what it does.

402
00:30:46.370 --> 00:30:48.140
Yeah, it does what you would expect.

403
00:30:48.440 --> 00:30:52.040
It reversed everything, so that's pretty cool, right?

404
00:30:53.120 --> 00:30:57.530
OK, so let me summarize then the gist of what you've just learned here.

405
00:30:57.530 --> 00:31:06.290
The main thing you just learned is that if you don't want to have to define and create your own comparator,

406
00:31:06.380 --> 00:31:10.490
as we did in the previous lesson, you can avoid doing that.

407
00:31:10.610 --> 00:31:19.570
However, the things the objects that you plan to compare have to implement the comparable interface.

408
00:31:19.580 --> 00:31:23.990
OK, and we'll just go take another quick peek at what that looks like.

409
00:31:23.990 --> 00:31:27.260
Again, I'll I'll jump into the employee class.

410
00:31:28.640 --> 00:31:29.300
So.

411
00:31:30.840 --> 00:31:38.010
This class is now indirectly implementing the comparable interface, it's indirect because it's inheriting

412
00:31:38.190 --> 00:31:45.240
the comparable interface via the employee interface right here extends comparable of an employee.

413
00:31:45.330 --> 00:31:45.690
Right.

414
00:31:48.030 --> 00:31:51.810
And then the implementing method is down here at the bottom.

415
00:31:51.810 --> 00:31:53.070
It's compared to.

416
00:31:53.880 --> 00:31:54.330
All right.

417
00:31:54.690 --> 00:32:03.900
Now, since the interface declared that it is implementing comparable for an employee, that's what's

418
00:32:03.900 --> 00:32:06.090
getting passed in here by default.

419
00:32:06.330 --> 00:32:09.210
And so that's unfortunately not quite enough.

420
00:32:09.360 --> 00:32:11.580
We actually need it to be an employee.

421
00:32:11.820 --> 00:32:18.570
Now, if I had chosen to directly implement comparable on employee itself, like, for example, if

422
00:32:18.570 --> 00:32:23.670
I had chosen to just get rid of this interface, which I very well could have done, one of the reasons

423
00:32:23.970 --> 00:32:29.490
one of the only reasons I originally left the the interface in here from many lessons ago was because

424
00:32:29.490 --> 00:32:36.180
we were using the lambda expressions here and you needed to be returning something of a of an interface

425
00:32:36.180 --> 00:32:38.940
type in order for the lambda to work correctly.

426
00:32:39.180 --> 00:32:45.630
Now that I'm not even using lambda expressions, I could actually just get rid of this interface completely

427
00:32:45.630 --> 00:32:48.630
and turn everything back into just returning employees.

428
00:32:48.870 --> 00:32:51.060
And that would simplify quite a few things.

429
00:32:51.330 --> 00:32:59.040
The only reason I didn't do that was because back over here in the main class I have, I am employee

430
00:32:59.040 --> 00:33:04.440
all over the place, and I just didn't feel like wasting the time hunting and finding it and getting

431
00:33:04.440 --> 00:33:09.200
rid of it in all these different places and replacing it back with just an employee.

432
00:33:09.210 --> 00:33:11.700
Again, though, I absolutely could have done that.

433
00:33:11.910 --> 00:33:16.170
And if I thought about it, I probably could have refactored using the ADC to do that.

434
00:33:16.170 --> 00:33:21.090
But that's the only reason I didn't get rid of that, OK, at least for now.

435
00:33:22.310 --> 00:33:27.080
At any rate, though, here's our compare to method back on the employee class.

436
00:33:27.260 --> 00:33:30.380
It's taking something of type I employee the interface.

437
00:33:30.560 --> 00:33:37.280
I am then casting it back to just an employee so that I can access the last name, right?

438
00:33:37.300 --> 00:33:45.590
That's the only reason I need this to be of type employee because I employee doesn't define any methods

439
00:33:45.590 --> 00:33:50.120
that would allow me to gain access to the name, right?

440
00:33:50.270 --> 00:33:52.820
And then from there, I'm able to call Compare two.

441
00:33:53.000 --> 00:34:01.700
And the reason that this compare to works without having to do any further comparators or things is

442
00:34:01.700 --> 00:34:10.760
because this is a string and strings are one of many native Java types that already implement comparable

443
00:34:10.880 --> 00:34:11.260
right?

444
00:34:11.420 --> 00:34:13.070
So you've got strings dates.

445
00:34:13.280 --> 00:34:17.180
All of the numeric wrapper classes implement comparable.

446
00:34:17.300 --> 00:34:18.200
Quite a number of things.

447
00:34:18.200 --> 00:34:27.620
In fact, real quick, let's just if I jump in to the comparable interface right here and then I click

448
00:34:27.620 --> 00:34:34.730
on this little down thing here we can actually see what are all the classes that implement comparable?

449
00:34:34.970 --> 00:34:38.330
Now it's going to be a long list, so we're not going to exhaustively look at it.

450
00:34:38.330 --> 00:34:41.280
But I just wanted you to have some some idea, right?

451
00:34:41.300 --> 00:34:46.820
Like, there's a lot of there's a lot of classes that implement this interface, and that means that

452
00:34:46.820 --> 00:34:52.400
they are all classes that you could sort if you had them in a collection of some sort.

453
00:34:53.030 --> 00:34:53.900
No pun intended.

454
00:34:54.650 --> 00:34:54.980
All right.

455
00:34:55.010 --> 00:35:00.650
So in fact, yeah, there's so many here that my computer is actually kind of freezing up on me as I

456
00:35:00.650 --> 00:35:02.090
try to scroll through them all.

457
00:35:02.360 --> 00:35:06.410
So this is actually isn't going to work as well as I thought it would.

458
00:35:06.420 --> 00:35:07.520
So oh, look at that.

459
00:35:07.550 --> 00:35:08.840
There's like 790.

460
00:35:08.850 --> 00:35:13.370
So yeah, let me just hit escape and get out of that before I kill my computer.

461
00:35:13.550 --> 00:35:14.930
So anyway, you get the idea.

462
00:35:15.080 --> 00:35:17.510
There's a lot of classes that implement comparable.

463
00:35:17.720 --> 00:35:25.460
And you know, it's not a terrible idea if you make domain classes yourself, such as things, things

464
00:35:25.460 --> 00:35:28.100
that are modeling, you know, real world concepts.

465
00:35:28.100 --> 00:35:35.750
And if there's even the slightest chance that you may want to store instances of that class in lists

466
00:35:35.750 --> 00:35:42.740
or in collections so that you can sort them at a later date, it's not a bad idea to go ahead and implement

467
00:35:42.740 --> 00:35:43.520
comparable.

468
00:35:43.790 --> 00:35:44.120
All right.

469
00:35:44.120 --> 00:35:53.690
So that's that's basically all that I wanted to show you for now on some of the key methods and techniques

470
00:35:53.690 --> 00:35:57.380
that you can use for sorting elements in lists.

471
00:35:57.740 --> 00:36:03.590
So one other thing that I'll mention is that there are actually more algorithms that you can utilize

472
00:36:03.800 --> 00:36:04.880
for sorting.

473
00:36:05.540 --> 00:36:09.020
And one thing I want to show you really quickly here.

474
00:36:09.020 --> 00:36:09.520
Yeah, yeah.

475
00:36:09.530 --> 00:36:13.670
So if we go down here back on line 47, I'm back in the main class now, right?

476
00:36:13.670 --> 00:36:15.530
And we're calling collections that sort.

477
00:36:15.860 --> 00:36:17.600
Let me show you something real quick here.

478
00:36:19.160 --> 00:36:21.170
Collections dot.

479
00:36:23.430 --> 00:36:24.270
Look at this.

480
00:36:24.540 --> 00:36:26.700
There's a collections that shuffle.

481
00:36:30.210 --> 00:36:37.410
And if I pull up the Java dock for this look at this, I'll pull up.

482
00:36:37.410 --> 00:36:44.130
The first one randomly permits the specified list using a default source of randomness.

483
00:36:44.850 --> 00:36:45.450
So.

484
00:36:46.670 --> 00:36:48.680
That's actually really cool.

485
00:36:49.970 --> 00:36:58.460
Imagine when we were working on our blackjack game, if we were to create a deck of cards.

486
00:36:59.430 --> 00:37:09.930
And as actual objects and stored them in a list and then call collections, dot shuffle, right, we

487
00:37:09.930 --> 00:37:15.180
could literally have the code shuffle the deck for us.

488
00:37:15.240 --> 00:37:15.690
Right?

489
00:37:15.720 --> 00:37:16.290
You get it.

490
00:37:16.530 --> 00:37:22.710
That's one of the reasons why we put that project on pause and we came here to learn about collections

491
00:37:22.920 --> 00:37:30.120
because in real life as a professional developer, the way that I actually would have continued working

492
00:37:30.120 --> 00:37:37.830
on that blackjack game would have been to model an actual card and then store instances of those cards

493
00:37:37.830 --> 00:37:39.270
in a list.

494
00:37:39.570 --> 00:37:44.700
And then I could use methods like this to easily shuffle, and I could also do it with the race.

495
00:37:44.700 --> 00:37:46.740
But but where's the fun in that?

496
00:37:47.670 --> 00:37:55.050
So, yeah, you can explore more of these types of methods that are on the collections class to do various

497
00:37:55.050 --> 00:38:01.200
things we reverse ordered and we've shuffled and we've gone forward and cool things like that, and

498
00:38:01.200 --> 00:38:03.960
you can write your own ordering algorithms as well.

499
00:38:04.860 --> 00:38:05.200
All right.

500
00:38:05.220 --> 00:38:10.710
So with that, I'm going to bring this lesson to a close and I will see you in the next one.
