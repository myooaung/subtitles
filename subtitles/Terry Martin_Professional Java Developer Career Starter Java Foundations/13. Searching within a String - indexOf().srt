1
00:00:00,270 --> 00:00:08,460
OK, now let's learn about index of this is an extremely commonly used method, probably overused by

2
00:00:08,460 --> 00:00:13,920
most Java developers, in fact, and later in the course, you'll learn why, although I'll probably

3
00:00:13,920 --> 00:00:17,130
try to remember mention a little bit more about this towards the end of this lesson.

4
00:00:17,490 --> 00:00:23,850
So the index of method is super useful, though it can tell us where inside of a string.

5
00:00:23,880 --> 00:00:27,270
According to its index, a substring exists.

6
00:00:27,480 --> 00:00:29,550
Now let me show you what I mean by that.

7
00:00:29,850 --> 00:00:35,190
So again, I've cleared out what we had before, and I'm going to create a string here.

8
00:00:35,730 --> 00:00:45,030
My text equals and let's see four score and seven years ago.

9
00:00:45,570 --> 00:00:49,170
OK, so we've got some text here doing so.

10
00:00:49,170 --> 00:00:56,250
You T and we'll reference that string and now we'll use the index of method.

11
00:00:56,340 --> 00:00:56,730
OK.

12
00:00:57,060 --> 00:01:02,340
So one way that I might use this is if I wanted to know two things.

13
00:01:02,610 --> 00:01:10,590
If I want to know is the word seven in this string and where in this string does it begin?

14
00:01:10,620 --> 00:01:17,250
OK, so we learned another way that we could determine whether or not the word seven or any other sub

15
00:01:17,250 --> 00:01:20,640
string here is contained within this string.

16
00:01:20,640 --> 00:01:23,760
We could use the contains method, right?

17
00:01:24,060 --> 00:01:31,680
But if we want to know where in this string is the word seven, we could use the index of.

18
00:01:31,920 --> 00:01:36,540
So it tells us the index, which is the place in the string, which character, right?

19
00:01:36,540 --> 00:01:37,800
Starting from zero.

20
00:01:37,950 --> 00:01:40,920
Where in this string is the word seven?

21
00:01:41,070 --> 00:01:43,950
If we if I do something like that.

22
00:01:44,640 --> 00:01:45,060
OK.

23
00:01:45,870 --> 00:01:48,510
And so let's run this and see what we get.

24
00:01:49,020 --> 00:01:49,410
OK.

25
00:01:49,530 --> 00:01:51,450
So it returns the number 15.

26
00:01:51,600 --> 00:02:01,650
So if we count, starting with zero zero one to three, including spaces for five six seven eight nine

27
00:02:01,650 --> 00:02:05,880
10, 11 12, 13 14 15.

28
00:02:06,270 --> 00:02:12,000
So the fifteenth index here is where the word seven begins.

29
00:02:12,270 --> 00:02:14,700
So it's telling us where we could find that.

30
00:02:14,820 --> 00:02:23,190
OK, now there are several variations of the index of method, and we'll take a look at at least some

31
00:02:23,190 --> 00:02:23,640
of them.

32
00:02:23,760 --> 00:02:28,800
So I'm going to change this string to something a little more a little simpler.

33
00:02:29,040 --> 00:02:32,190
A B C D e f g.

34
00:02:33,170 --> 00:02:35,780
A B C D e f g.

35
00:02:36,640 --> 00:02:43,960
OK, so there's another version of the index of method that does not take a string, but instead takes

36
00:02:43,960 --> 00:02:46,720
a number an integer, actually.

37
00:02:47,110 --> 00:02:53,590
And the reason it takes an integer is because, oops, I deleted too many parentheses there.

38
00:02:53,740 --> 00:02:54,070
OK.

39
00:02:54,310 --> 00:03:02,260
The reason this version of index of takes an integer is because this integer represents the code for

40
00:03:02,260 --> 00:03:03,340
a character.

41
00:03:03,670 --> 00:03:14,890
If you'll recall, I stated that all characters in Java have a numerical code associated with them,

42
00:03:15,250 --> 00:03:21,400
and that is really the way that these characters in letters and things are being stored in the memory

43
00:03:21,400 --> 00:03:22,240
of the computer.

44
00:03:22,420 --> 00:03:28,150
As as numbers, as you may know, like everything in a computer is really comes down to numbers, right?

45
00:03:28,330 --> 00:03:37,780
And so what we can do is we can ask the index of method to find the character whose encoding is this

46
00:03:37,780 --> 00:03:41,590
number or any other number and then give us the index of that.

47
00:03:41,680 --> 00:03:50,050
OK, now I happen to know that 65 is the character encoding the standard encoding for a capital A..

48
00:03:50,260 --> 00:03:50,620
OK.

49
00:03:50,980 --> 00:03:55,510
So if we run this, it should give us the index of this first A..

50
00:03:56,110 --> 00:03:58,450
So let's let's run it and see what we get.

51
00:03:59,800 --> 00:04:02,920
Yeah, we get zero, which means the first one there.

52
00:04:02,990 --> 00:04:10,900
OK, now if I delete that first, eh, I've got another a here and it should find that one.

53
00:04:11,200 --> 00:04:12,040
So let's see.

54
00:04:14,070 --> 00:04:14,310
Yeah.

55
00:04:14,700 --> 00:04:20,310
So let's see zero one, two, three, four, five six, that's correct.

56
00:04:20,430 --> 00:04:20,760
Right.

57
00:04:21,150 --> 00:04:21,430
All right.

58
00:04:21,450 --> 00:04:23,680
So if I put the first aid back in.

59
00:04:23,700 --> 00:04:30,240
So something to note here is the fact that the index of method stops once it finds a first match.

60
00:04:30,660 --> 00:04:36,750
Now you might be wondering why would you ever want to use this particular version of the index of method

61
00:04:36,750 --> 00:04:38,250
that's taking a number?

62
00:04:38,490 --> 00:04:45,090
And one reason for that is because there are some characters that are not easy to type in here that

63
00:04:45,090 --> 00:04:49,740
you might want to search for, especially like white space characters and things of that sort.

64
00:04:49,770 --> 00:04:54,090
So, for example, a new line character or carriage return.

65
00:04:54,390 --> 00:05:01,050
There are a lot of special characters that don't represent easily visually here, but you may still

66
00:05:01,050 --> 00:05:02,520
want to search for them.

67
00:05:03,180 --> 00:05:09,240
So if you look up their values, the values of some of those characters, you could search for them

68
00:05:09,240 --> 00:05:10,920
by their numerical value.

69
00:05:11,160 --> 00:05:17,910
By the way, I did mention the most common character encoding, which is used in Java by default, is

70
00:05:17,910 --> 00:05:19,110
called Unicode.

71
00:05:19,470 --> 00:05:26,490
You may have heard of ASCII AC III, so that's a different encoding system from Unicode.

72
00:05:26,580 --> 00:05:34,260
One of the main differences is that ASCII really only supports Latin characters, whereas Unicode and

73
00:05:34,260 --> 00:05:36,830
there are several sub standards within Unicode.

74
00:05:36,840 --> 00:05:44,460
But in general, Unicode has encoding and values for many, many characters of many parts of the world,

75
00:05:44,460 --> 00:05:47,070
if not by now, virtually the entire world.

76
00:05:47,100 --> 00:05:54,810
So if there is a a known country that has its own writing system and characters, it's very likely that

77
00:05:54,810 --> 00:06:00,480
those characters have been encoded and included in the Unicode encoding standard.

78
00:06:00,630 --> 00:06:06,750
But all you really need to just understand from this is that there is a standard encoding for turning

79
00:06:06,750 --> 00:06:14,250
characters into numbers, and that encoding that is used by default in Java is called Unicode, and

80
00:06:14,250 --> 00:06:20,550
all it means is that every single character has a numerical value associated with it.

81
00:06:21,000 --> 00:06:26,820
OK, so let's take a look at some of the other variations of the index of method to see what else we

82
00:06:26,820 --> 00:06:28,170
could do with this.

83
00:06:28,620 --> 00:06:28,920
All right.

84
00:06:28,920 --> 00:06:31,980
So we've looked at the index of that takes a number.

85
00:06:31,980 --> 00:06:35,880
That's this entire thing here in the states, there's just stands for character.

86
00:06:35,890 --> 00:06:40,710
So they're just saying you could search for a character by its numerical value.

87
00:06:41,010 --> 00:06:41,390
All right.

88
00:06:41,400 --> 00:06:46,730
And then we also started off with this version here that takes a string, right?

89
00:06:46,740 --> 00:06:48,840
So we searched for an entire string.

90
00:06:49,230 --> 00:06:57,750
And now let's say, let's say that we asked index of to search for a character or string that isn't

91
00:06:57,750 --> 00:07:00,300
contained in the source string here.

92
00:07:00,300 --> 00:07:06,540
So I'm going to put a number in here that I know isn't here, like 122.

93
00:07:07,260 --> 00:07:07,740
OK.

94
00:07:08,190 --> 00:07:09,780
And let's see what we get now.

95
00:07:10,380 --> 00:07:10,770
OK.

96
00:07:11,190 --> 00:07:12,720
We get a negative one.

97
00:07:12,930 --> 00:07:14,520
And this is normal behavior.

98
00:07:14,530 --> 00:07:22,770
So what what index of is telling us is that there is no character in this string that matches the encoding

99
00:07:22,770 --> 00:07:23,700
of 122.

100
00:07:23,820 --> 00:07:26,450
So negative one means no match.

101
00:07:26,460 --> 00:07:27,390
It's not in there.

102
00:07:27,420 --> 00:07:27,870
OK?

103
00:07:28,140 --> 00:07:36,180
And again, you'll see code all the time written by Java developers that tests to see if some string

104
00:07:36,180 --> 00:07:41,610
or some characters are contained inside of a bigger string or something, and it'll explicitly look

105
00:07:41,610 --> 00:07:43,440
for like a negative one or whatever.

106
00:07:43,770 --> 00:07:47,820
So that's something really important to learn and be aware of.

107
00:07:48,420 --> 00:07:51,690
And we can do this with a string input as well.

108
00:07:52,560 --> 00:07:56,100
In fact, I guess I could have just left that as a stream, but I don't want to be confusing here,

109
00:07:56,100 --> 00:07:57,540
so I'll do this instead.

110
00:07:57,900 --> 00:07:59,610
Car, OK, so we'll see.

111
00:08:00,030 --> 00:08:06,180
Is the combination of C.A.R. in that order contained in this string and we'll run this.

112
00:08:07,440 --> 00:08:12,510
OK, and again, we get a negative one, which means no car is not contained in that string.

113
00:08:12,720 --> 00:08:13,140
OK.

114
00:08:13,530 --> 00:08:17,900
And by the way, this is case sensitive, so there would be a different.

115
00:08:17,910 --> 00:08:20,130
So in fact, here I'll just prove that real quick.

116
00:08:20,220 --> 00:08:28,440
If we do a b c all uppercase, we get a match of zero, meaning ABC starts at the beginning here.

117
00:08:28,650 --> 00:08:32,940
However, if we do a b c a lower case.

118
00:08:36,330 --> 00:08:37,530
And we run this.

119
00:08:39,550 --> 00:08:42,470
We get a negative one, meaning there is no lower case.

120
00:08:42,490 --> 00:08:45,010
ABC contained within this string.

121
00:08:45,250 --> 00:08:47,470
OK, so that's enough of that.

122
00:08:47,740 --> 00:08:52,670
Now let's look at another variation of the index of method.

123
00:08:52,690 --> 00:08:55,120
I'm going to tell it to search for capital A..

124
00:08:55,270 --> 00:09:01,750
However, we're going to use we're going to use the last index of variation here.

125
00:09:02,140 --> 00:09:07,570
So this method searches for the last occurrence of whatever we're telling it to search.

126
00:09:07,780 --> 00:09:11,620
So let me run it and make that a little more clear as to what I mean.

127
00:09:12,670 --> 00:09:13,420
And so we're here.

128
00:09:13,720 --> 00:09:16,300
We're going to have a search for the letter A.

129
00:09:17,550 --> 00:09:22,620
And look at that, it returned a seven, even though this string starts with an A., which should have

130
00:09:22,620 --> 00:09:23,340
been zero.

131
00:09:23,520 --> 00:09:30,430
But we're telling it to find the last index of a which means find the the last time you find a match.

132
00:09:30,450 --> 00:09:32,670
So this is the first time we find a match.

133
00:09:32,670 --> 00:09:40,260
But if we keep going zero one two three four five six seven The seventh character in here, or the seventh

134
00:09:40,260 --> 00:09:45,960
index, which is the eighth character really is another A and that happens to be the last A.

135
00:09:46,170 --> 00:09:54,420
So you can use this or last index of method to find, you know, the last time there was a match in

136
00:09:54,420 --> 00:09:55,260
any string.

137
00:09:55,740 --> 00:10:00,480
OK, and then there's a few others that we can take a quick look at.

138
00:10:03,180 --> 00:10:08,520
So we've got this one here, index of that takes two parameters.

139
00:10:08,790 --> 00:10:15,120
The first one is, well, here, I like this one, so the first one again is just the numerical code

140
00:10:15,120 --> 00:10:16,350
of one character.

141
00:10:16,950 --> 00:10:20,880
But then it also says you can start from an index.

142
00:10:21,060 --> 00:10:27,060
So what that is telling it is to start searching from a particular index.

143
00:10:27,210 --> 00:10:31,630
So by default, the index of method is starting from the beginning zero.

144
00:10:31,770 --> 00:10:37,710
It would be the index, but you can tell it to skip past some number of characters and then start searching

145
00:10:37,710 --> 00:10:38,520
from there.

146
00:10:38,640 --> 00:10:39,150
OK.

147
00:10:39,600 --> 00:10:47,580
So what happens if we tell it to search for a starting on the third character, let's say.

148
00:10:47,850 --> 00:10:49,470
So let's see what we get here.

149
00:10:52,390 --> 00:10:57,160
So search for a starting from the third.

150
00:10:58,450 --> 00:11:01,090
Character, which is an index of two.

151
00:11:01,210 --> 00:11:04,690
So we're going to skip over that first a in other words.

152
00:11:04,900 --> 00:11:05,410
OK.

153
00:11:05,890 --> 00:11:06,370
All right.

154
00:11:06,580 --> 00:11:08,170
So let's see what we get now.

155
00:11:09,860 --> 00:11:12,080
OK, so this is kind of interesting.

156
00:11:12,410 --> 00:11:19,340
We get a seven, which is what we got when we told when we used the last index of, but now we're using

157
00:11:19,340 --> 00:11:24,020
just the index of which normally would have started at the beginning and it would have found the very

158
00:11:24,020 --> 00:11:24,920
first, eh.

159
00:11:25,070 --> 00:11:30,140
But we told it to skip over the first three characters or so and then start searching.

160
00:11:30,140 --> 00:11:32,540
So now it's returning a seven.

161
00:11:32,690 --> 00:11:39,740
So if I change this to two a zero, which will cause it to behave as if I didn't even have this second

162
00:11:39,740 --> 00:11:42,050
bid here at all, because that's the default behavior.

163
00:11:42,440 --> 00:11:44,410
Let's just confirm what it does.

164
00:11:45,620 --> 00:11:46,070
OK.

165
00:11:46,130 --> 00:11:51,800
And now it does as expected, and it returns to zero, so we are indeed just telling it start searching

166
00:11:51,800 --> 00:11:57,650
from the very beginning and find the first aid you can see, and that would be the very first one.

167
00:11:57,860 --> 00:12:05,060
Whereas when we had when we had the we had the two here, we were telling it start searching.

168
00:12:06,000 --> 00:12:09,510
From here and then go find an A..

169
00:12:10,080 --> 00:12:11,460
And when it found the A..

170
00:12:12,090 --> 00:12:18,420
It then told us what was the index of that a for the entire string, not from where we started searching

171
00:12:18,420 --> 00:12:20,310
from, but for the entire string.

172
00:12:20,340 --> 00:12:24,300
So that might not have been entirely intuitive, but that's what it's actually doing.

173
00:12:24,450 --> 00:12:24,840
OK?

174
00:12:25,020 --> 00:12:30,720
And the last index of has the same variations as well, so I'm not going to show those here.

175
00:12:31,890 --> 00:12:32,400
All right.

176
00:12:32,400 --> 00:12:35,250
So now we can do something kind of interesting.

177
00:12:35,250 --> 00:12:37,170
I've got a little bit of a challenge for you.

178
00:12:37,290 --> 00:12:42,090
Now, this challenge might be a little more advanced, but technically you have learned enough that

179
00:12:42,090 --> 00:12:43,530
you may be able to do this.

180
00:12:44,100 --> 00:12:57,480
So what I want to challenge you to try is to write some code that can extract out parts of a phone number,

181
00:12:57,690 --> 00:13:00,180
and I'm going to give you the format of that phone number.

182
00:13:00,180 --> 00:13:02,370
So first off here, you know what?

183
00:13:02,370 --> 00:13:05,100
I'm going to just clear this out completely.

184
00:13:06,000 --> 00:13:06,390
Oops.

185
00:13:08,890 --> 00:13:09,100
But.

186
00:13:13,550 --> 00:13:13,880
All right.

187
00:13:14,060 --> 00:13:14,480
And.

188
00:13:16,860 --> 00:13:19,680
I will create a phone number.

189
00:13:22,360 --> 00:13:26,440
And I'm going to use a very specific format here, I'm going to do.

190
00:13:28,160 --> 00:13:30,620
Two, three, four space.

191
00:13:31,610 --> 00:13:33,410
Three, three, three hyphen.

192
00:13:33,920 --> 00:13:36,200
Five, five five one.

193
00:13:37,010 --> 00:13:40,400
OK, so we've got the area code.

194
00:13:41,430 --> 00:13:45,960
The exchange and then the line, no.

195
00:13:46,590 --> 00:13:58,680
So the challenge is, can you write some code that can extract out these three parts of this phone number

196
00:13:58,680 --> 00:14:02,010
in this exact format into variables?

197
00:14:02,010 --> 00:14:05,580
So in other words, when you're done, you would have.

198
00:14:06,600 --> 00:14:11,670
A variable that holds the area code equals.

199
00:14:14,810 --> 00:14:15,680
Blah blah blah.

200
00:14:17,920 --> 00:14:20,300
And you would have a variable that holds the.

201
00:14:21,300 --> 00:14:22,320
Exchange.

202
00:14:25,690 --> 00:14:28,420
And you would have a variable that holds the line.

203
00:14:28,720 --> 00:14:29,440
No.

204
00:14:31,390 --> 00:14:33,310
And then you could print those out.

205
00:14:35,440 --> 00:14:37,180
Like, maybe like.

206
00:14:43,870 --> 00:14:44,560
Like this?

207
00:14:47,860 --> 00:14:50,740
OK, so the part that I'm not showing you is.

208
00:14:52,410 --> 00:14:55,800
How did you populate each of these with code, right?

209
00:14:55,840 --> 00:15:02,400
You're not going to just copy and paste these in, you're going to write code to pass this string and

210
00:15:02,400 --> 00:15:06,820
extract out the bits and then put them in their right places.

211
00:15:06,870 --> 00:15:07,380
OK.

212
00:15:07,980 --> 00:15:10,050
Oh, and let me give you one other hint.

213
00:15:10,380 --> 00:15:15,150
I would strongly recommend that to parse out these three bits.

214
00:15:15,480 --> 00:15:21,480
You make three separate static methods to to parse these out.

215
00:15:21,780 --> 00:15:27,000
And so here, in fact, I'm going to go ahead and even give you a starter here of what those methods

216
00:15:27,000 --> 00:15:30,540
might look like in case this isn't clear to you.

217
00:15:31,350 --> 00:15:33,150
This is going to be more than you've done before.

218
00:15:33,150 --> 00:15:34,140
So public static.

219
00:15:34,680 --> 00:15:37,200
So this is going to be a method that will return a string.

220
00:15:38,800 --> 00:15:40,690
And we'll call it pass.

221
00:15:42,200 --> 00:15:47,900
Area code, and it will take a string of a phone number.

222
00:15:48,780 --> 00:15:49,190
Oops.

223
00:15:51,150 --> 00:15:52,830
OK, so there's one.

224
00:15:52,860 --> 00:15:56,790
Let me close this out of the way and then another method.

225
00:15:58,750 --> 00:16:03,910
That looks real similar, but this one will be called pass exchange.

226
00:16:04,480 --> 00:16:07,510
And it also will take a phone number.

227
00:16:10,690 --> 00:16:12,700
And then one more.

228
00:16:15,990 --> 00:16:21,060
Pass line ups line, no.

229
00:16:23,100 --> 00:16:26,430
And this will take a phone number to.

230
00:16:27,510 --> 00:16:35,850
So if these methods are implemented correctly, they should return, respectively, this part for this

231
00:16:35,850 --> 00:16:36,390
method.

232
00:16:37,660 --> 00:16:39,750
This part for this method.

233
00:16:40,670 --> 00:16:48,920
And this part for this method, and in fact, they will look something like this pass area code.

234
00:16:50,290 --> 00:16:51,010
Phone number.

235
00:16:55,070 --> 00:16:56,780
So I'm giving you the scaffolding here.

236
00:16:57,890 --> 00:17:00,950
Pass exchange, phone number.

237
00:17:03,620 --> 00:17:07,640
Pass line, no phone number.

238
00:17:08,420 --> 00:17:17,030
OK, so your task is to fill in the body of each of these methods to actually return what's expected

239
00:17:17,030 --> 00:17:17,390
here.

240
00:17:18,980 --> 00:17:19,340
Go.

241
00:17:23,050 --> 00:17:26,290
All right, so let's see how you did.

242
00:17:27,160 --> 00:17:28,810
Let's see how would I do this?

243
00:17:28,820 --> 00:17:31,630
So phone number?

244
00:17:32,440 --> 00:17:36,520
So the first thing I want to get is this two, three four here.

245
00:17:36,790 --> 00:17:43,900
I know that it's in between an opening parentheses and a closing parentheses.

246
00:17:44,380 --> 00:17:51,960
One thing that I could do is I could search for where does the opening parentheses start?

247
00:17:51,970 --> 00:17:55,890
What's the index of that and what's the index of the closing parentheses?

248
00:17:55,930 --> 00:17:57,670
So yeah, I'm going to I'm going to try it that way.

249
00:17:58,090 --> 00:18:01,300
So I know that the index of these things is going to be an integer.

250
00:18:01,300 --> 00:18:05,200
So I'm going to have an integer variable and I'm going to call it.

251
00:18:06,340 --> 00:18:07,000
Open.

252
00:18:08,190 --> 00:18:15,790
Parents equals, and I'm going to do a phone number.

253
00:18:15,900 --> 00:18:23,760
That index of and I'll just put that opening thingy in there like that.

254
00:18:23,910 --> 00:18:30,870
So that should be the index of where the opening parentheses begins, which should be the first one.

255
00:18:30,870 --> 00:18:33,180
But who knows, maybe whatever.

256
00:18:33,570 --> 00:18:39,720
All right, then I need the closing parentheses, so I'm going to do another integer variable here.

257
00:18:40,350 --> 00:18:41,010
Close.

258
00:18:42,570 --> 00:18:46,710
Parents, and that's just, you know, my shorthand for parentheses.

259
00:18:47,720 --> 00:18:50,750
Phone number, that index of.

260
00:18:52,720 --> 00:18:58,240
The close parentheses there, and I know that could look a little confusing, but hopefully you can

261
00:18:58,240 --> 00:19:00,410
follow it that's saying, all right.

262
00:19:00,430 --> 00:19:01,510
Now here's the trick.

263
00:19:01,810 --> 00:19:07,820
Hopefully, you remember that we learned about sub strings, and that is what we want to use here.

264
00:19:08,650 --> 00:19:10,750
So I'm going to now.

265
00:19:10,750 --> 00:19:11,860
There's a couple of things I could do this.

266
00:19:11,860 --> 00:19:13,750
I'm going to I guess I'll do it this way.

267
00:19:14,620 --> 00:19:15,040
Let's see.

268
00:19:15,340 --> 00:19:21,690
Area code equals phone number, dot substring.

269
00:19:21,700 --> 00:19:23,200
Now here's what I want.

270
00:19:23,740 --> 00:19:32,320
I want a substring that starts with a particular index and ends with a particular index.

271
00:19:32,670 --> 00:19:39,120
Now, programmers get these indexes confused all the time, and I'm no exception to this.

272
00:19:39,130 --> 00:19:40,450
So let's see what we get here.

273
00:19:40,570 --> 00:19:42,220
So I know I want the second one.

274
00:19:43,210 --> 00:19:49,960
Now the up the index of the opening parentheses is stored in this variable called open parents.

275
00:19:50,710 --> 00:19:54,820
However, I don't want the actual parentheses.

276
00:19:54,820 --> 00:19:56,470
I want the the two.

277
00:19:56,800 --> 00:19:59,560
I want to start with that two, and I want to end with that four.

278
00:19:59,800 --> 00:20:04,240
So I don't want to start with the index of this open parents here.

279
00:20:04,240 --> 00:20:05,840
That would be zero here.

280
00:20:05,980 --> 00:20:08,020
I want to start at one.

281
00:20:08,410 --> 00:20:13,120
So what I'm going to do here is I'm going to do a little math and say I'm going to take the index of

282
00:20:13,120 --> 00:20:16,210
the open parents plus one.

283
00:20:17,730 --> 00:20:24,210
Comma, and then I have to give it the index of the last character.

284
00:20:24,540 --> 00:20:30,210
And I'm going to pass that in which would be the close parents now with the substring method.

285
00:20:30,540 --> 00:20:35,760
The closing are the ending index is non-inclusive.

286
00:20:35,760 --> 00:20:41,700
So in other words, if I tell it to use the index of this closing character here, it's not going to

287
00:20:41,700 --> 00:20:42,930
include that anyway.

288
00:20:43,350 --> 00:20:46,020
And so I don't need to do any math here.

289
00:20:47,000 --> 00:20:49,910
And that's just something you would need to just memorize and know.

290
00:20:50,240 --> 00:20:50,630
All right.

291
00:20:50,660 --> 00:20:52,730
And then finally, I need to return.

292
00:20:54,060 --> 00:20:58,440
The variable that I just populated right there.

293
00:20:59,280 --> 00:21:05,880
OK, now, just so that I can run this and see if I'm on the right track here, I'm going to satisfy

294
00:21:05,880 --> 00:21:10,710
the compiler and the ADC because I've got these little red squiggles here because I'm not returning

295
00:21:10,710 --> 00:21:11,040
anything.

296
00:21:11,190 --> 00:21:16,860
So for right now, I'm just going to return empty strings just to make these methods valid.

297
00:21:20,340 --> 00:21:26,100
And that way, I can go ahead and actually run this and see if I'm on the right path.

298
00:21:29,250 --> 00:21:35,100
There we go, and I got what I was looking for, which is the two three four without the parentheses,

299
00:21:35,100 --> 00:21:38,520
so that parsing trick worked correctly.

300
00:21:38,700 --> 00:21:45,240
All right, so let me close this and now I want to grab the three three three.

301
00:21:45,570 --> 00:21:52,320
So what I want to look for is some distinguishing characteristic within this string to anchor my search

302
00:21:52,770 --> 00:21:53,250
with.

303
00:21:53,320 --> 00:21:59,040
I mean, I can't anchor it on the actual numbers here because those are the parts that could change,

304
00:21:59,070 --> 00:21:59,370
right?

305
00:21:59,520 --> 00:22:05,400
I want to pretend like the format of this string will always be exactly like this, but the numbers

306
00:22:05,400 --> 00:22:06,420
could be different.

307
00:22:06,660 --> 00:22:11,460
So I can't tell my code to search for a three because it could be something different, right?

308
00:22:11,880 --> 00:22:15,720
So what I could do is tell it to search for this space, though.

309
00:22:15,990 --> 00:22:18,150
So I think I'm going to I'm going to try that.

310
00:22:18,540 --> 00:22:18,840
All right.

311
00:22:18,840 --> 00:22:26,220
So on this next method here, I'm going, I'm going to do pretty much the same thing, same basic approach

312
00:22:26,220 --> 00:22:27,510
that I used above.

313
00:22:27,750 --> 00:22:32,400
I'm going to store the index of that, that first space.

314
00:22:33,230 --> 00:22:35,610
I call it space index.

315
00:22:35,610 --> 00:22:37,650
And I'll just use ADX here.

316
00:22:38,250 --> 00:22:46,200
So phone number, that index of and I'm going to just use a space.

317
00:22:47,340 --> 00:22:53,250
Now I could have used the ASCII or the Unicode character for a space, but honestly, I don't even remember

318
00:22:53,250 --> 00:22:55,140
what that is, and I don't feel like looking it up.

319
00:22:55,560 --> 00:22:56,850
And I think this will be fine.

320
00:22:57,240 --> 00:22:57,570
All right.

321
00:22:57,570 --> 00:22:59,610
So that's where we'll start.

322
00:22:59,730 --> 00:23:03,650
And then I think where we'll end is with the hyphen there.

323
00:23:03,660 --> 00:23:04,170
So.

324
00:23:04,330 --> 00:23:07,200
So then we'll do and.

325
00:23:09,520 --> 00:23:13,840
Hyphen index equals phone number.

326
00:23:14,260 --> 00:23:18,820
That index of hyphen character.

327
00:23:19,090 --> 00:23:24,700
And then I will create a string variable to hold the What am I going for here?

328
00:23:24,700 --> 00:23:25,570
Exchange?

329
00:23:28,840 --> 00:23:32,290
Phone number, dot, substring.

330
00:23:34,220 --> 00:23:40,880
And again, we'll do space index plus one comma.

331
00:23:42,330 --> 00:23:43,770
Hyphen index.

332
00:23:44,960 --> 00:23:49,820
So let me explain this again, because repetition is sometimes very useful.

333
00:23:50,420 --> 00:24:01,970
So we're telling the substring method to start with the index of the space, which would be here, which

334
00:24:01,970 --> 00:24:04,910
would be a zero one two three four five.

335
00:24:06,140 --> 00:24:06,610
OK.

336
00:24:06,800 --> 00:24:09,510
But we don't want to actually start here.

337
00:24:09,530 --> 00:24:10,400
We want to start.

338
00:24:11,920 --> 00:24:14,670
I want to start on this three here.

339
00:24:14,910 --> 00:24:22,110
So that would be the space plus one, which is why you see me doing space index plus one, because I

340
00:24:22,110 --> 00:24:24,650
want to start on this three here.

341
00:24:24,660 --> 00:24:32,130
The character right after this space is where I want to start and then I want to grab all the characters

342
00:24:32,130 --> 00:24:33,270
up until.

343
00:24:34,480 --> 00:24:40,000
But not including the hyphen character, which is the hyphen index here.

344
00:24:40,630 --> 00:24:41,030
OK.

345
00:24:41,290 --> 00:24:46,720
And the way that substring works is that it stops short of the last index anyway.

346
00:24:46,930 --> 00:24:50,290
So I don't need to do like minus one or something like that here.

347
00:24:50,770 --> 00:24:51,160
All right.

348
00:24:51,310 --> 00:24:53,860
And then finally, I just return.

349
00:24:55,520 --> 00:24:56,300
Exchange.

350
00:24:56,780 --> 00:24:57,200
All right.

351
00:24:57,740 --> 00:25:00,980
And so now let's run this and see what we've got.

352
00:25:02,000 --> 00:25:03,320
OK, looking good.

353
00:25:03,620 --> 00:25:08,930
So we got two, three, four and then we got three, three, three looking good.

354
00:25:09,440 --> 00:25:09,890
All right.

355
00:25:09,890 --> 00:25:15,260
And so now we need to pass out the last bit, which is called the line number.

356
00:25:15,860 --> 00:25:16,520
All right.

357
00:25:16,520 --> 00:25:18,710
So let's see.

358
00:25:18,710 --> 00:25:22,070
And so that starts with the hyphen and then it goes to the end.

359
00:25:22,940 --> 00:25:23,510
All right.

360
00:25:23,780 --> 00:25:27,770
So for that, I think this will be even a little easier.

361
00:25:29,960 --> 00:25:36,380
So for that, we'll start off the same as we did before, in fact, I'm going to be a little lazy here

362
00:25:36,380 --> 00:25:41,120
and I'm going to just duplicate this line and then I'm going to bring it down, by the way.

363
00:25:41,120 --> 00:25:46,910
So the way that I just duplicated that I put my cursor online 24 on my on my I.D..

364
00:25:47,270 --> 00:25:52,070
Your lines might be a little different if you're hitting enter in different places, but I put my cursor

365
00:25:52,070 --> 00:25:58,110
on this line and then I did a Command D for duplicate or control, D for Windows and Linux.

366
00:25:58,130 --> 00:26:03,800
OK, so I duplicated that line, and now I'm going to just drag that line down in the way I can do that

367
00:26:03,800 --> 00:26:12,320
is with an option shift or alt shift and the down arrow key I could have copied and pasted or cut and

368
00:26:12,320 --> 00:26:13,490
pasted or whatever.

369
00:26:13,790 --> 00:26:18,110
If I weren't explaining this, though, the approach that I just used was probably the quickest.

370
00:26:18,980 --> 00:26:19,400
All right.

371
00:26:19,400 --> 00:26:26,600
So now I have that index here and I don't need a last index or closing index.

372
00:26:26,740 --> 00:26:29,250
I mean, you'll see why in just a moment if you don't recall.

373
00:26:29,480 --> 00:26:38,160
So string line number equals phone number, not substring.

374
00:26:38,480 --> 00:26:44,390
Now for this one, I can use another version of the sub string, which just takes the beginning index

375
00:26:44,390 --> 00:26:45,740
and no end index.

376
00:26:46,010 --> 00:26:51,800
If you will recall, this version of the sub string method takes the beginning index and then it just

377
00:26:51,800 --> 00:26:56,180
takes the rest of that string to the end anyway, which is exactly what we want.

378
00:26:56,420 --> 00:27:01,160
And so I don't need to specify an end index, which is great because I don't know what I would anchor

379
00:27:01,160 --> 00:27:01,970
it to anyway.

380
00:27:02,240 --> 00:27:13,160
So, yeah, so we can just pass in the hyphen index just like so and then return line number.

381
00:27:13,340 --> 00:27:14,250
Oh, you know what?

382
00:27:14,280 --> 00:27:16,370
Sorry, almost messed up here.

383
00:27:16,370 --> 00:27:19,370
Forgot to add plus one plus one.

384
00:27:19,400 --> 00:27:20,270
Sorry about that.

385
00:27:21,120 --> 00:27:25,370
See, even seasoned developers make simple mistakes like this all the time.

386
00:27:25,370 --> 00:27:27,470
It's super easy to make this kind of mistake.

387
00:27:28,130 --> 00:27:30,770
All right, so now let me explain what's going on here.

388
00:27:31,340 --> 00:27:36,320
So we have the index of the hyphen plus one would be.

389
00:27:37,520 --> 00:27:39,290
This first five here.

390
00:27:39,740 --> 00:27:40,160
Right.

391
00:27:41,030 --> 00:27:48,470
And then we use the substring method, which takes this index, and if you don't supply an end and end

392
00:27:48,470 --> 00:27:54,920
index, it will just grab all of the characters to the end of the string, which is exactly what we

393
00:27:54,920 --> 00:27:55,430
want.

394
00:27:56,060 --> 00:27:58,250
And that's what we're doing here, substring.

395
00:27:58,580 --> 00:28:06,530
So we're telling it to start at the index of the hyphen plus one, which is this first five here and

396
00:28:06,530 --> 00:28:12,560
then keep going and grab all the rest of that substring substring, meaning the smaller part of this

397
00:28:12,560 --> 00:28:13,700
whole entire string, right?

398
00:28:14,600 --> 00:28:15,050
All right.

399
00:28:15,260 --> 00:28:16,520
So let's run that.

400
00:28:18,950 --> 00:28:24,560
And look what we got here, so now we've passed out all the parts of that phone number.

401
00:28:24,830 --> 00:28:31,220
As long as that phone number is in this format now to double check that this is true, let's change

402
00:28:31,220 --> 00:28:33,320
this to something else now.

403
00:28:33,620 --> 00:28:35,870
Seven, six three.

404
00:28:38,050 --> 00:28:40,060
Eight seven to.

405
00:28:42,010 --> 00:28:43,420
Six, six, three three.

406
00:28:44,260 --> 00:28:45,250
And let's run that.

407
00:28:47,090 --> 00:28:50,110
There we go, seven, six, three eight seven two, six, six three.

408
00:28:50,390 --> 00:28:57,980
So this is actually pretty much 100 percent real type of code, I'm 1000 percent certain.

409
00:28:58,220 --> 00:29:03,590
Many Java developers in the world have written code that looks pretty much exactly like this, except

410
00:29:03,590 --> 00:29:07,460
for maybe not the static methods, possibly not the static methods.

411
00:29:07,610 --> 00:29:14,420
But yeah, many developers will have written code that passes a 10 digit phone number in this way,

412
00:29:14,540 --> 00:29:19,250
or they might have had a phone number that had another hyphen in it, you know, so something like.

413
00:29:23,010 --> 00:29:28,370
Like that, and we could have done this as well, but in that case, we might have used the index up

414
00:29:28,380 --> 00:29:34,800
for the hyphen for this one here and then the last index for the second hyphen to differentiate those

415
00:29:34,800 --> 00:29:35,430
two hyphens.

416
00:29:35,430 --> 00:29:37,500
That might have been what we what we might have done.

417
00:29:37,530 --> 00:29:37,980
OK.

418
00:29:38,490 --> 00:29:39,690
So this is pretty cool.

419
00:29:39,690 --> 00:29:42,840
If you were able to get that, then you are really coming along.

420
00:29:42,840 --> 00:29:47,520
And if you weren't, hopefully my walk through here clarified what?

421
00:29:47,520 --> 00:29:48,690
What was needed here?

422
00:29:48,900 --> 00:29:51,570
Now I do want to point out one quick thing.

423
00:29:51,810 --> 00:29:58,380
While it is true that in my experience, I've seen a probably a majority of Java developers who would

424
00:29:58,380 --> 00:30:05,670
have solved this problem, and in pretty much just like this, using a combination of index of and substring,

425
00:30:06,210 --> 00:30:10,740
I personally almost certainly wouldn't have done this in this way.

426
00:30:10,860 --> 00:30:12,990
There's actually an easier way.

427
00:30:13,050 --> 00:30:21,570
Well, there is actually a more concise way to do this, but it involves learning a more advanced technique

428
00:30:21,570 --> 00:30:25,950
called regular expressions, and we will be learning that shortly.

429
00:30:26,310 --> 00:30:33,210
But you will encounter as a professional Java developer, lots of code that looks very similar to this,

430
00:30:33,210 --> 00:30:39,450
where there's lots of index UVs and sub strings in any time you need to parse some formatted text of

431
00:30:39,450 --> 00:30:40,140
some sort.

432
00:30:40,260 --> 00:30:44,760
But there is a better way to do a lot of these kinds of things, and we will see that shortly.

433
00:30:45,000 --> 00:30:50,490
Anyway, this concludes this lesson, and this was a good one because we really got a chance to put

434
00:30:50,490 --> 00:30:52,200
together a lot of things, by the way.

435
00:30:52,230 --> 00:30:57,030
Real quick, you also might have wanted to do something like what if there could have been some spaces

436
00:30:57,030 --> 00:30:57,360
here?

437
00:30:57,570 --> 00:31:02,460
What if the user had been asked to enter the phone number?

438
00:31:02,510 --> 00:31:03,240
Let me let me put.

439
00:31:03,780 --> 00:31:06,300
Let me put this back the way it was real quick.

440
00:31:07,530 --> 00:31:14,130
What if the user had been prompted to enter a phone number in this format, but you couldn't be certain

441
00:31:14,130 --> 00:31:20,190
that they didn't put a few extra spaces in here with these extra spaces that would cause this whole

442
00:31:20,190 --> 00:31:21,930
entire program to blow up.

443
00:31:22,110 --> 00:31:24,690
In fact, let me just do that real quick.

444
00:31:26,460 --> 00:31:28,770
OK, so now look at what we get.

445
00:31:29,070 --> 00:31:32,370
The program isn't quite working correctly anymore.

446
00:31:32,640 --> 00:31:38,340
It's very fragile, and that's because of these unexpected leading spaces here.

447
00:31:38,730 --> 00:31:44,940
Now we could fix that, though, by using the strip method.

448
00:31:46,110 --> 00:31:52,770
Anywhere in here so we can use it here or we could use it here or whatever, but by using the strip

449
00:31:52,770 --> 00:31:57,180
method and we run this again, we're back to working again.

450
00:31:57,510 --> 00:31:57,960
OK.

451
00:31:58,140 --> 00:32:01,410
And so now you get a chance to see a little more real world.

452
00:32:01,410 --> 00:32:05,340
Why something like the strip method could be very, very useful.

453
00:32:05,910 --> 00:32:07,650
All right, now, I'm going to wrap it up.

454
00:32:07,650 --> 00:32:10,590
So good lesson and I will see you in the next one.
