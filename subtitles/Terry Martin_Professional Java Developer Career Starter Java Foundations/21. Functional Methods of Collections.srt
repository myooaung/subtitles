1
00:00:01,050 --> 00:00:07,650
All right, so in this lesson, I want to wrap up the final loose end and that final Lucentis is something

2
00:00:07,650 --> 00:00:11,640
that I had actually sort of promised to get back to a while back.

3
00:00:11,640 --> 00:00:19,560
So if you will recall in the collections module, I was going through a lot of the methods on the various

4
00:00:19,560 --> 00:00:23,670
collections interfaces, and there were some methods that I was skipping over.

5
00:00:23,670 --> 00:00:29,280
And the reason I was skipping over those is because I knew that we weren't quite ready to learn how

6
00:00:29,280 --> 00:00:30,300
to use those yet.

7
00:00:30,510 --> 00:00:36,120
But now that you've learned about the Stream's API and lambda expressions and method references as well,

8
00:00:36,420 --> 00:00:42,390
we are now ready to go back and revisit some of those methods that we skipped over before.

9
00:00:42,420 --> 00:00:42,900
OK.

10
00:00:43,170 --> 00:00:47,610
And so that's all we're going to do now is just take a look at a few of the methods on the collections,

11
00:00:47,610 --> 00:00:55,050
classes or interfaces that pertain to doing streams and lambda expression type things.

12
00:00:55,890 --> 00:00:58,410
And we've already been playing with a few of them anyway.

13
00:00:58,950 --> 00:01:05,940
For example, let's see, do we have I don't remember if I still have any here, but at one point we

14
00:01:05,940 --> 00:01:11,160
did something where we captured the map and then we did some things on the map.

15
00:01:11,160 --> 00:01:14,130
And so in fact, here we can do just do that again right now.

16
00:01:14,250 --> 00:01:15,480
Let me make some room here.

17
00:01:15,490 --> 00:01:21,570
So for example, we were capturing, we're capturing this map result, right?

18
00:01:21,570 --> 00:01:25,890
And it's a map of string string to long at at the moment.

19
00:01:26,190 --> 00:01:27,030
That's what it is.

20
00:01:27,870 --> 00:01:34,620
And so if I just refer to the result map and hit a period here, now we can start looking at all the

21
00:01:34,620 --> 00:01:37,770
methods that exist on this class, right?

22
00:01:38,040 --> 00:01:42,130
And one of them that I know we used before was the for each.

23
00:01:42,150 --> 00:01:42,510
Right?

24
00:01:42,810 --> 00:01:43,050
Yeah.

25
00:01:43,060 --> 00:01:48,780
In fact, I remember we we stuck a dot for each ride at the end of the dot collect method.

26
00:01:48,790 --> 00:01:50,070
That's I think that's what we did.

27
00:01:50,880 --> 00:01:52,890
So, yeah, we could do a for each here.

28
00:01:53,070 --> 00:01:56,190
So let me just go ahead and hit that real quick.

29
00:01:56,220 --> 00:01:58,490
So what does this guy take as input?

30
00:01:58,500 --> 00:02:00,300
It takes a by consumer, right?

31
00:02:00,540 --> 00:02:09,360
So we now know that a by consumer is going to be a functional interface that is expecting two inputs

32
00:02:09,360 --> 00:02:10,200
and returns.

33
00:02:10,200 --> 00:02:10,770
Nothing.

34
00:02:10,860 --> 00:02:11,190
Right?

35
00:02:11,790 --> 00:02:18,720
And so, for example, if we wanted to print out the key value pairs for each entry in our map, we

36
00:02:18,720 --> 00:02:20,520
could use this function now.

37
00:02:20,700 --> 00:02:26,370
Now, one thing that isn't obvious here, the fact that this is taking a by consumer is cool, but you

38
00:02:26,370 --> 00:02:33,570
don't necessarily know just from looking at this that the two inputs that this buy consumer are expecting

39
00:02:33,570 --> 00:02:35,490
are the key and the value, right?

40
00:02:35,520 --> 00:02:36,360
How do I know that?

41
00:02:36,630 --> 00:02:41,130
Well, the way that you could learn that would be by just looking at the Java Dock for the for each

42
00:02:41,130 --> 00:02:42,150
method itself.

43
00:02:42,960 --> 00:02:50,490
So if I just go to the Java Dock here, I can see that I'd have to read it a little bit, but it performs

44
00:02:50,490 --> 00:02:53,550
the given action for each entry in this map.

45
00:02:53,850 --> 00:02:58,400
So right here, entry, I know that entries are key value pairs of a map, right?

46
00:02:58,410 --> 00:03:04,740
So it performs the given action for each entry in this map until all entries have been processed or

47
00:03:04,740 --> 00:03:06,550
the action throws an exception.

48
00:03:07,440 --> 00:03:13,500
And if I skip around a little more down here now, one nice thing about a lot of these functional methods

49
00:03:13,770 --> 00:03:19,050
are about a lot of these functional methods on the collections classes is that they will often give

50
00:03:19,050 --> 00:03:24,960
you this implementation requirements type thing here, which shows you kind of in a more procedural

51
00:03:24,960 --> 00:03:32,910
format, what the expectation would be or how how you can think of using or kind of how you can think

52
00:03:32,910 --> 00:03:36,600
of using whatever it is that it's expecting here, like this by consumer.

53
00:03:36,600 --> 00:03:43,590
So down here, it says the default implementation is equivalent to this is equivalent to for this map.

54
00:03:44,790 --> 00:03:45,900
So for.

55
00:03:46,470 --> 00:03:54,650
So what they're showing here is a for loop that is looping over the set of entries in this map.

56
00:03:54,660 --> 00:04:04,470
So again, a map can be thought of as a list of key value pairs and a key value pair is also called

57
00:04:04,470 --> 00:04:05,490
an entry.

58
00:04:07,460 --> 00:04:14,180
And so a set of entries of the map is just that list or set, I'm using less than the English fence,

59
00:04:14,180 --> 00:04:15,850
not in the programming sense.

60
00:04:17,690 --> 00:04:21,290
It's just a list of key value pairs or entries.

61
00:04:21,530 --> 00:04:27,230
And so we're setting up a for loop using the enhanced for loop, we're setting up a for loop that will

62
00:04:27,230 --> 00:04:28,940
loop over those entries.

63
00:04:28,940 --> 00:04:30,680
And here's your entry there, right?

64
00:04:31,010 --> 00:04:35,720
And then it is going to call the by consumer that you are going to supply to it.

65
00:04:36,530 --> 00:04:42,200
So that could be a lambda expression or a method reference as long as it refers to a method that can

66
00:04:42,200 --> 00:04:43,280
take two inputs.

67
00:04:43,400 --> 00:04:46,760
And so now we can see what are the two inputs that it's going to pass us.

68
00:04:46,910 --> 00:04:53,180
It's showing us right here, it's going to pass in the key from the entry and the value from the entry.

69
00:04:53,210 --> 00:04:53,660
OK.

70
00:04:53,930 --> 00:04:57,020
So all of this stuff here.

71
00:04:58,610 --> 00:05:03,330
That's kind of like internal code of the for each method itself.

72
00:05:03,350 --> 00:05:03,740
OK.

73
00:05:03,920 --> 00:05:09,570
But that lets us see what how it is going to use what we are supplying it.

74
00:05:09,590 --> 00:05:12,420
Essentially, that's kind of how you can think of it at least, right?

75
00:05:12,440 --> 00:05:14,630
So that's how I know that this takes a key and a value.

76
00:05:14,930 --> 00:05:15,320
All right.

77
00:05:17,330 --> 00:05:18,770
So we've done that many times.

78
00:05:18,770 --> 00:05:21,740
I'm not going to I'm not going to do that again.

79
00:05:22,790 --> 00:05:24,380
Let's see what else we've got here.

80
00:05:25,670 --> 00:05:26,110
Let's see.

81
00:05:26,120 --> 00:05:27,530
Oh, replace all.

82
00:05:27,800 --> 00:05:28,170
All right.

83
00:05:28,190 --> 00:05:29,000
That's what.

84
00:05:31,900 --> 00:05:33,040
Replace all.

85
00:05:33,310 --> 00:05:40,960
So this one also now this one takes a buy function, meaning it's going to be a function that takes

86
00:05:40,960 --> 00:05:43,690
two inputs and returns an output.

87
00:05:43,750 --> 00:05:44,110
Right?

88
00:05:44,500 --> 00:05:52,330
So again, I can click on the method here and do an F1 to bring up the Java dock to get a little better

89
00:05:52,330 --> 00:05:56,620
sense of exactly what is this thing trying to do or what is its intent.

90
00:05:56,960 --> 00:05:57,270
Right.

91
00:05:57,280 --> 00:06:00,520
And so I can come down here to the implementation requirements and see.

92
00:06:01,730 --> 00:06:03,200
So what is this guy doing?

93
00:06:03,440 --> 00:06:14,360
So again, it's iterating over the set of entries and it's going to intricate set value, so I can see

94
00:06:14,360 --> 00:06:17,390
now that it really does mean to replace something, right?

95
00:06:17,390 --> 00:06:22,160
Because it's going to replace the value of each entry.

96
00:06:24,110 --> 00:06:24,890
Let's see.

97
00:06:25,100 --> 00:06:29,870
And it's going to call the apply method of our supplied function, whatever.

98
00:06:30,380 --> 00:06:35,420
Let me take a quick side note here to make sure I explain what the function data pie is.

99
00:06:36,080 --> 00:06:40,250
So the word function here is referring to our lambda expression.

100
00:06:40,280 --> 00:06:40,640
OK.

101
00:06:40,670 --> 00:06:41,810
Or a method reference?

102
00:06:42,110 --> 00:06:48,800
And you know that we are looking at using the in this case to replace all method, but it could be any

103
00:06:48,800 --> 00:06:50,100
of these functional methods.

104
00:06:50,120 --> 00:06:50,480
OK.

105
00:06:50,900 --> 00:06:54,440
And the replace all method is taking as an input.

106
00:06:54,440 --> 00:06:58,160
A bi function by function is an interface.

107
00:06:58,670 --> 00:07:02,300
As all of these functional interfaces are, it's it's an interface.

108
00:07:02,480 --> 00:07:09,860
So when we supply a lambda expression or a method reference, what's really happening is that Java is

109
00:07:09,860 --> 00:07:15,800
going to take our lambda and plug it into an object that it's going to create for us.

110
00:07:16,040 --> 00:07:21,710
And that object will look like whatever the functional interface is that we're that is being expected.

111
00:07:21,720 --> 00:07:27,300
So for replace all, it's going to create an object that looks like a bi function object.

112
00:07:27,320 --> 00:07:27,770
OK.

113
00:07:28,460 --> 00:07:35,480
And then it's going to take our our lambda expression and plug that in as a method of that by function

114
00:07:35,480 --> 00:07:36,170
object.

115
00:07:36,500 --> 00:07:44,600
And then in order to actually call our supplied lambda expression, it will be mapped to the apply method.

116
00:07:44,810 --> 00:07:50,670
And generally speaking, all of these functional interfaces have an apply method, OK?

117
00:07:50,690 --> 00:07:52,760
And so that's why we're seeing here function that apply.

118
00:07:52,880 --> 00:07:58,760
So basically, you can just take it to mean when it says function that applied, it means call the lambda

119
00:07:58,760 --> 00:08:01,580
expression or method reference that we are supplying.

120
00:08:02,450 --> 00:08:06,200
I hope that helps clear up a few things we're supplying to it.

121
00:08:06,920 --> 00:08:07,340
What was it?

122
00:08:07,340 --> 00:08:10,010
A bi function that we're going to supply?

123
00:08:10,280 --> 00:08:14,480
It's going to pass in as input for our function, the key and the value.

124
00:08:14,480 --> 00:08:20,330
So, OK, so it's going to give us the key and a value, and then it's going to take whatever we return

125
00:08:20,540 --> 00:08:28,370
from our lambda expression and replace the value of the current entry with whatever we're supplying

126
00:08:28,370 --> 00:08:28,460
it.

127
00:08:28,490 --> 00:08:31,940
So let me think real quick off hand, why might you want that?

128
00:08:34,010 --> 00:08:43,790
So in this particular case, let's say that since we have currently a mapping of states to what we're

129
00:08:43,790 --> 00:08:46,340
doing here counts, I think, yeah, we're counting, right?

130
00:08:46,340 --> 00:08:49,460
We're counting the number of people in each state.

131
00:08:49,740 --> 00:08:55,610
Currently, I'm looking up here to see that right here, the dot collect grouping by state and then

132
00:08:55,610 --> 00:08:56,180
counting, right?

133
00:08:56,180 --> 00:08:58,850
So we're counting the number of people by state, right?

134
00:08:59,180 --> 00:09:05,330
So maybe now I don't have a real great reason why we would want to do what I'm about to say.

135
00:09:05,330 --> 00:09:11,210
But let's say we wanted to double all of the counts for each state, right?

136
00:09:11,480 --> 00:09:13,220
Maybe that's something we'd want to do.

137
00:09:13,580 --> 00:09:14,010
OK.

138
00:09:14,030 --> 00:09:18,380
So in that case, we could do that by supplying a bi function.

139
00:09:18,710 --> 00:09:22,490
That would be a lambda that would take two inputs.

140
00:09:22,490 --> 00:09:24,790
And I know that those inputs are going to be the key in the value.

141
00:09:24,800 --> 00:09:28,100
So I'm going to just call them Canva, which is a common convention.

142
00:09:29,540 --> 00:09:36,590
And and then what I'm going to do is return maybe v times to write.

143
00:09:36,860 --> 00:09:42,050
And so that would double all of the counts of the populations in this particular case.

144
00:09:42,230 --> 00:09:44,330
Now I could get fans here with this notice.

145
00:09:44,330 --> 00:09:50,360
I didn't use the K for my actual, you know, calculation I could have, right?

146
00:09:51,600 --> 00:09:57,570
I could have said something like if K, which I know is going to be a state code rights of K Dot, I

147
00:09:57,570 --> 00:10:02,280
don't know starts with, I don't know, Z.

148
00:10:04,130 --> 00:10:06,440
I'm just making up something silly here.

149
00:10:06,680 --> 00:10:12,830
If Kay starts with Z and I can use a ternary here to make it kind of concise.

150
00:10:13,040 --> 00:10:23,150
If Kay starts with Z, then returned the value times to otherwise just return the original value that

151
00:10:23,150 --> 00:10:24,770
was already there before, right?

152
00:10:24,920 --> 00:10:32,000
So that's just a random example of something that I could yeah, of of a way that I could use the replaceable.

153
00:10:32,150 --> 00:10:32,510
All right.

154
00:10:33,500 --> 00:10:33,920
All right.

155
00:10:33,960 --> 00:10:35,540
So there's that.

156
00:10:37,130 --> 00:10:37,970
What else we got?

157
00:10:39,290 --> 00:10:40,310
Let's see.

158
00:10:40,310 --> 00:10:40,940
We've got merge.

159
00:10:40,940 --> 00:10:41,420
I'm going to skip.

160
00:10:41,420 --> 00:10:43,070
Merge will come back to it, though.

161
00:10:43,840 --> 00:10:46,010
Yeah, I guess let's do compute.

162
00:10:46,790 --> 00:10:47,060
All right.

163
00:10:47,060 --> 00:10:49,400
So now let's take a look at the compute method.

164
00:10:49,640 --> 00:10:55,520
So first off, we can take a quick look at what it takes for inputs, so it takes a key and then it

165
00:10:55,520 --> 00:10:57,170
takes a bi function.

166
00:10:57,320 --> 00:11:03,470
And so we now know that a bi function is a function that takes two inputs and returns one output.

167
00:11:03,560 --> 00:11:03,890
Right?

168
00:11:04,490 --> 00:11:07,280
But that doesn't really tell us how to use this thing.

169
00:11:07,490 --> 00:11:13,850
So if I put my cursor on the compute method itself and do an f one to bring up the Java Dock for it,

170
00:11:14,150 --> 00:11:20,030
I can now kind of take a look so it attempts to compute a mapping for the specified key that was that

171
00:11:20,030 --> 00:11:27,020
first parameter that it takes compute, a mapping for the key and it's current mapped value or null.

172
00:11:27,020 --> 00:11:34,940
If there is no current mapping, for example, to either create or append a string message to a value

173
00:11:34,940 --> 00:11:35,570
mapping.

174
00:11:35,600 --> 00:11:36,080
OK.

175
00:11:37,160 --> 00:11:42,530
So we can jump down here to the implementation requirements.

176
00:11:42,530 --> 00:11:46,130
And as you can kind of see here, it's a little more involved than on the.

177
00:11:46,130 --> 00:11:49,940
The other method that we took a look at earlier was that the replace all.

178
00:11:51,830 --> 00:11:53,840
So let's see what this guy is doing.

179
00:11:54,110 --> 00:11:59,570
So it's getting the value for the given key that we have passed into it.

180
00:11:59,760 --> 00:12:04,100
So again, keep in mind, we're going to pass the key into this thing as the first parameter.

181
00:12:04,280 --> 00:12:04,730
OK.

182
00:12:05,000 --> 00:12:11,180
You're going to pass in a key and then it's going to call your lambda expression.

183
00:12:11,180 --> 00:12:12,750
Let's just assume we're using a lambda.

184
00:12:13,310 --> 00:12:19,520
It's going to call your lambda expression and it's going to pass in the key and an old value so that

185
00:12:19,520 --> 00:12:21,980
old values the value that it got for the key.

186
00:12:22,130 --> 00:12:27,920
So let's say, for example, that we used it here where we're counting populations, and so we passed

187
00:12:27,920 --> 00:12:29,300
into the compute method.

188
00:12:30,770 --> 00:12:32,930
I don't know M for Missouri.

189
00:12:33,440 --> 00:12:39,410
And so then this implementation is going to look up Missouri in the map and get the current value for

190
00:12:39,410 --> 00:12:42,800
Missouri, which will presumably be some population.

191
00:12:42,800 --> 00:12:44,840
Let's say it's whatever, I don't know, a million.

192
00:12:46,010 --> 00:12:54,200
And so then your lambda expression is going to be passed M0 and 1000000, and then you can do whatever

193
00:12:54,200 --> 00:12:56,330
you want with those two values.

194
00:12:56,570 --> 00:12:58,940
You just need to return something back.

195
00:12:58,970 --> 00:12:59,510
OK?

196
00:13:00,260 --> 00:13:05,390
And it will need to be of type long, because that's what this particular map is dealing with in this

197
00:13:05,390 --> 00:13:06,230
case, right?

198
00:13:07,040 --> 00:13:09,530
So it needs to be another value that you're going to return.

199
00:13:09,830 --> 00:13:16,400
So now here's the thing I can't really think of a great reason to use compute in this program.

200
00:13:16,640 --> 00:13:23,510
So I've actually prepared another smaller program with a very specific scenario so that we have a good

201
00:13:23,510 --> 00:13:26,280
reason or a better reason, at least to use compute.

202
00:13:26,300 --> 00:13:32,510
So let me let's jump over into that and I will show you a good use case, a potentially good use case

203
00:13:32,510 --> 00:13:33,590
for using compute.

204
00:13:33,860 --> 00:13:34,230
All right.

205
00:13:34,250 --> 00:13:36,140
So let me just delete that.

206
00:13:36,470 --> 00:13:37,280
And then.

207
00:13:38,570 --> 00:13:41,570
And then we'll jump over here to my state counter.

208
00:13:42,710 --> 00:13:44,450
Now this isn't something you need to write.

209
00:13:45,110 --> 00:13:50,630
I just wrote this just so we'd have a little a little scaffolding to play around with some things here.

210
00:13:51,830 --> 00:13:54,930
All right, so let me lay out a quick scenario for us here.

211
00:13:56,660 --> 00:13:58,730
And actually, this will be kind of real world.

212
00:14:00,080 --> 00:14:06,200
As a professional programmer, I've run into the following scenario a few times in my career.

213
00:14:06,620 --> 00:14:13,280
So basically, here's the scenario I'm going to iterate through the five million records of people,

214
00:14:13,430 --> 00:14:19,790
and I just want to tally up each time I find a person from a particular state so that by the time I'm

215
00:14:19,790 --> 00:14:24,530
done going through it all, I have the total counts of population per state.

216
00:14:24,560 --> 00:14:24,980
OK?

217
00:14:25,220 --> 00:14:29,460
It's just a more procedural way of getting counts by state.

218
00:14:29,480 --> 00:14:29,750
Right.

219
00:14:29,870 --> 00:14:35,750
Obviously, we know that we can do this quite efficiently using the Streams API, but let's say that

220
00:14:36,350 --> 00:14:39,770
maybe we don't have all of this data all at once.

221
00:14:40,010 --> 00:14:44,180
Maybe this is a program that's running over the course of a month.

222
00:14:44,570 --> 00:14:50,180
And different people go online and fill out something, and every time they fill something out, one

223
00:14:50,180 --> 00:14:53,900
of the things that they're filling out is what state they live in.

224
00:14:54,170 --> 00:14:59,630
And so at that moment, when they submit their form, we're just tallying up.

225
00:14:59,630 --> 00:15:01,190
Oh, here's one for Missouri.

226
00:15:01,220 --> 00:15:02,080
Add another one.

227
00:15:02,090 --> 00:15:03,410
Here's one for California.

228
00:15:03,560 --> 00:15:07,100
Add one to the California stack or stash, right?

229
00:15:07,490 --> 00:15:12,410
So maybe we're keeping track of all of this in a map.

230
00:15:12,530 --> 00:15:12,950
OK.

231
00:15:13,790 --> 00:15:20,900
So the problem is that by default, if you just use the very simple, straightforward methods of a map

232
00:15:20,900 --> 00:15:25,220
which are basically put and get, you end up having to write some.

233
00:15:25,220 --> 00:15:28,100
Really, I don't like writing this code at all.

234
00:15:28,100 --> 00:15:32,070
And in fact, maybe I can show you what that code would look like real quick here.

235
00:15:32,130 --> 00:15:35,110
So right here, I have a map, right?

236
00:15:35,450 --> 00:15:37,430
Already called state count.

237
00:15:37,480 --> 00:15:37,850
OK.

238
00:15:38,240 --> 00:15:47,270
And so what I'd normally be end up doing is every time somebody from a particular state submits their

239
00:15:47,270 --> 00:15:55,490
form, I might end up doing something like this state counts that get and then I'm going to pass in

240
00:15:55,490 --> 00:15:57,000
whatever state they're from.

241
00:15:57,020 --> 00:15:57,370
Right.

242
00:15:57,380 --> 00:15:58,790
So let's say it's CIA.

243
00:15:59,180 --> 00:16:04,040
Now, that would have been a variable, really, because I would have received that as an input somehow,

244
00:16:04,040 --> 00:16:04,340
right?

245
00:16:05,030 --> 00:16:10,610
But so just pretend like that's a variable that came through some form of metal or something like that

246
00:16:11,180 --> 00:16:15,560
and not not a not a static and not a constant like I'm doing here.

247
00:16:15,650 --> 00:16:23,390
But anyway, so we're going to need to get the current value for that particular person state, right?

248
00:16:23,660 --> 00:16:24,170
And.

249
00:16:25,870 --> 00:16:28,510
And we'll call that current population.

250
00:16:30,170 --> 00:16:31,010
And then.

251
00:16:32,850 --> 00:16:40,110
I might need to say something like if current population is null, because like, this is the first

252
00:16:40,110 --> 00:16:44,940
time we're ever running this program and we've not encountered anyone from California before, then

253
00:16:44,940 --> 00:16:46,140
that could be not right.

254
00:16:46,350 --> 00:16:53,250
So if if it's null, then then maybe we want to do something like State Council that put

255
00:16:55,650 --> 00:17:00,090
K again pretend like that's a variable one.

256
00:17:01,150 --> 00:17:01,480
All right.

257
00:17:03,900 --> 00:17:06,960
So consider that to be our first tally mark.

258
00:17:07,110 --> 00:17:07,460
Right?

259
00:17:09,200 --> 00:17:17,870
On the other hand, if it was not known, then we'll need to do something like state counts that put

260
00:17:18,740 --> 00:17:24,020
see a comma current population plus one.

261
00:17:26,510 --> 00:17:34,510
Or I suppose maybe I also could have done I maybe could also have done that right, incriminate.

262
00:17:34,610 --> 00:17:34,930
Right.

263
00:17:35,120 --> 00:17:40,040
Notice I'm using the prefixed interim increment here, though, because I want to make sure that that

264
00:17:40,040 --> 00:17:43,610
happens at the time that I'm putting in, not after I'm putting right.

265
00:17:45,440 --> 00:17:49,820
And for that reason, maybe you'd be better off just doing the plus one because it's more obvious and

266
00:17:49,820 --> 00:17:50,510
explicit.

267
00:17:51,530 --> 00:17:52,990
So here's the thing.

268
00:17:54,710 --> 00:18:00,560
That's, you know, that's a bit of code that you have to write just to do that one stupid thing, right?

269
00:18:00,890 --> 00:18:09,080
So this is like one of the classic scenarios, though, for using something like this compute method.

270
00:18:09,320 --> 00:18:12,320
So now let's see how to do it with with compute.

271
00:18:13,070 --> 00:18:14,150
And I don't know.

272
00:18:14,150 --> 00:18:16,490
We'll I'll just I'll leave this here for reference.

273
00:18:16,700 --> 00:18:17,050
All right.

274
00:18:17,060 --> 00:18:25,100
So what we could do instead is now I'm going to cheat a little bit here and I'm going to still use the

275
00:18:25,100 --> 00:18:29,210
Stream's API just to read in a bunch of data, OK?

276
00:18:29,390 --> 00:18:31,760
And I'm even going to use the for each here.

277
00:18:31,790 --> 00:18:32,110
All right.

278
00:18:32,120 --> 00:18:34,850
Just to simulate my scenario here.

279
00:18:34,850 --> 00:18:38,000
But inside of the four, each is where I will actually make use of the compute.

280
00:18:38,030 --> 00:18:41,300
OK, so here's our state counts.

281
00:18:41,510 --> 00:18:44,600
So what I'm going to do now is do this with compute.

282
00:18:44,900 --> 00:18:49,370
And the way I can do that might be something like this.

283
00:18:50,270 --> 00:18:51,410
Let's see here.

284
00:18:52,220 --> 00:18:56,750
So we'll refer to the state counts dot compute.

285
00:18:57,470 --> 00:18:59,020
And then it once a key.

286
00:18:59,030 --> 00:19:01,160
So our key would be now here.

287
00:19:01,160 --> 00:19:02,990
In this case, we've got this array.

288
00:19:02,990 --> 00:19:08,690
So I need to refer to the element of the array that holds the state.

289
00:19:08,690 --> 00:19:10,310
And I think that's thirty two.

290
00:19:11,750 --> 00:19:12,050
All right.

291
00:19:12,080 --> 00:19:13,280
So there's our key.

292
00:19:14,740 --> 00:19:17,650
And then it takes a buy function.

293
00:19:17,920 --> 00:19:20,230
And so this by function.

294
00:19:21,350 --> 00:19:22,730
Let's go look one more time.

295
00:19:23,340 --> 00:19:29,990
I'm going to do a pull up the Java docs, so if I come down here so our buy function is being referred

296
00:19:29,990 --> 00:19:33,870
right here, it's going to pass in the key and the old value.

297
00:19:33,900 --> 00:19:43,730
OK, so we will put in here key comma value like that and then we can do whatever we want with those

298
00:19:43,730 --> 00:19:44,120
values.

299
00:19:44,120 --> 00:19:51,230
So the key is going to be using our other example here, whatever was passed in here, which is the

300
00:19:51,230 --> 00:19:57,620
state and then the old value would be this guy right here, the current population, as I called it,

301
00:19:57,620 --> 00:19:58,610
right down here.

302
00:19:59,330 --> 00:20:02,960
So what we could do is something like the.

303
00:20:05,660 --> 00:20:09,410
If he is null and I'll do this as a ternary, if this is null.

304
00:20:12,080 --> 00:20:20,720
Then return a one, otherwise return the plus one.

305
00:20:22,530 --> 00:20:25,170
OK, now here's the gist.

306
00:20:26,520 --> 00:20:35,190
What I'm doing just in this bit right here, just this little bit, it looks a little cryptic, but

307
00:20:35,190 --> 00:20:38,310
what I'm doing here is equivalent to all of this.

308
00:20:38,640 --> 00:20:40,800
That's the whole point here, right?

309
00:20:41,070 --> 00:20:49,680
This compute method lets me more concisely say potentially slightly complex things.

310
00:20:49,680 --> 00:20:57,120
I mean, it's not that complex, but let me say all of this kind of scenario much more straightforwardly,

311
00:20:57,330 --> 00:21:05,340
and some of the astute ones of you might even be noticing that this feels a lot like the reduce function

312
00:21:05,520 --> 00:21:07,260
of the MapReduce pattern.

313
00:21:07,380 --> 00:21:09,870
It's very, very similar to that.

314
00:21:09,900 --> 00:21:10,290
OK.

315
00:21:10,440 --> 00:21:16,680
Because what it's really going to do is it's going to let us iterate well, not this part, this part

316
00:21:16,680 --> 00:21:19,020
of here because of the fact that we're using this loop, right?

317
00:21:19,020 --> 00:21:19,770
This, Fareed.

318
00:21:19,920 --> 00:21:22,920
It's going to iterate over all of the entries, essentially.

319
00:21:23,070 --> 00:21:26,400
Basically, that's what it's going to iterate over each record.

320
00:21:26,430 --> 00:21:26,910
OK.

321
00:21:27,090 --> 00:21:32,250
And for each record, we're going to pull the current state, which is going to be like us doing this

322
00:21:32,250 --> 00:21:32,970
bit here.

323
00:21:33,240 --> 00:21:38,460
And then we're going to get the value that's associated with that state in the map.

324
00:21:38,700 --> 00:21:43,590
And if this is the first time we're encountering that particular state, then the value is going to

325
00:21:43,590 --> 00:21:44,130
be null.

326
00:21:44,220 --> 00:21:46,920
And so we're going to initialize it to one.

327
00:21:47,100 --> 00:21:47,580
OK.

328
00:21:47,910 --> 00:21:54,880
But the next time we encounter someone from that same state now we will equal one.

329
00:21:54,900 --> 00:21:58,650
And now we're simply going to add one plus one, which will be to right.

330
00:21:58,650 --> 00:22:01,560
We're going to increment whatever we had in there before.

331
00:22:01,650 --> 00:22:07,830
And each time we encounter someone from that particular state, we're just going to keep incrementing

332
00:22:07,950 --> 00:22:09,840
the count for that state.

333
00:22:10,020 --> 00:22:15,000
And by the time we get to the end, we will have the full count of people from that state.

334
00:22:15,150 --> 00:22:17,490
And let me prove that by running this real quick.

335
00:22:19,170 --> 00:22:23,880
All right, so let's just yeah, let's just run this.

336
00:22:24,570 --> 00:22:29,340
All right, and so we've got our output and I don't have all these numbers memorized, but I do recognize

337
00:22:29,340 --> 00:22:30,240
this number right here.

338
00:22:30,270 --> 00:22:31,800
Sixteen thousand two hundred eighty eight.

339
00:22:32,040 --> 00:22:35,610
So I'm quite comfortable that we're on the right track here.

340
00:22:35,880 --> 00:22:39,460
So that's that's what the compute method does.

341
00:22:39,480 --> 00:22:43,920
Sorry that it takes a little while to kind of explain it because I wanted to give you a kind of a real

342
00:22:43,920 --> 00:22:46,770
world example of how to use this.

343
00:22:46,920 --> 00:22:47,850
Now you could do this.

344
00:22:47,940 --> 00:22:53,850
You can use the compute method for doing more than just this type of like tallying up, you know, values

345
00:22:53,850 --> 00:22:55,020
and summing up things, right?

346
00:22:55,350 --> 00:22:56,190
You could use it.

347
00:22:56,370 --> 00:23:04,440
Maybe if the values that we were tracking in some other use case, in some other example were words

348
00:23:04,440 --> 00:23:09,860
or something, you might want to append something to the words or whatever.

349
00:23:09,870 --> 00:23:14,760
I mean, you could go crazy with all of the scenarios that you might be able to think of, but I think

350
00:23:14,760 --> 00:23:22,140
this is a fairly classic scenario to cover with with the use of the compute method here.

351
00:23:22,320 --> 00:23:22,620
All right.

352
00:23:22,620 --> 00:23:23,640
So that's compute.

353
00:23:23,790 --> 00:23:28,230
And while we're here, we might as well just take a look at a few other variations of this because there

354
00:23:28,230 --> 00:23:32,430
are other variations, but they're all going to let us do very similar things.

355
00:23:32,430 --> 00:23:33,900
So let's get rid of that.

356
00:23:34,230 --> 00:23:35,310
And let's see.

357
00:23:35,310 --> 00:23:38,850
So we looked at compute and there's compute if absent.

358
00:23:39,090 --> 00:23:40,620
So let's see what that guy does.

359
00:23:40,620 --> 00:23:43,920
So he also takes a key and takes a function.

360
00:23:44,610 --> 00:23:51,090
Now, the compute method was taking a bi function, which was passing in the key in the value.

361
00:23:51,300 --> 00:23:55,500
This one is just taking a function, so let's see why that's a little different.

362
00:23:56,100 --> 00:23:59,100
We'll jump in to the Java doc here.

363
00:23:59,520 --> 00:23:59,790
All right.

364
00:23:59,800 --> 00:24:06,330
So the Java doc says that if the specified key is not already associated with a value or is mapped to

365
00:24:06,330 --> 00:24:13,410
null, this one attempts to compute its value using the given mapping function and enters it into the

366
00:24:13,410 --> 00:24:14,910
map unless null.

367
00:24:15,240 --> 00:24:19,650
I'm not going to read the whole thing there, but if we jump down to the implementation, we can see

368
00:24:19,650 --> 00:24:21,120
here what it's kind of expecting.

369
00:24:21,120 --> 00:24:24,060
So it's going to first try to get the value for the given key.

370
00:24:24,330 --> 00:24:32,400
If that value is null, then and only then will it call our supplied function right and it's only going

371
00:24:32,400 --> 00:24:33,510
to pass in one input.

372
00:24:33,510 --> 00:24:36,540
And that's why it does not use a bi function.

373
00:24:36,540 --> 00:24:38,100
It's just using a regular function.

374
00:24:38,100 --> 00:24:42,630
The difference being that a bi function takes two inputs, whereas the regular function just takes one

375
00:24:42,630 --> 00:24:45,840
input, which will be the key in this case.

376
00:24:45,840 --> 00:24:51,270
And then it's expecting our function to take that key and do whatever it wants with it.

377
00:24:51,480 --> 00:25:01,450
OK, now if our function returns a null value, then that won't be stored into the map, right?

378
00:25:01,470 --> 00:25:07,860
So it'll only store whatever value we we we return from our function if that value that we return from

379
00:25:07,860 --> 00:25:09,690
our function is not null.

380
00:25:10,110 --> 00:25:16,020
So this would not work for what we just previously did, where we were kind of just tallying up things

381
00:25:16,020 --> 00:25:22,980
because once you put one value into it, it's not going to give us another callback with that same key.

382
00:25:23,070 --> 00:25:30,840
This will only call our supplied function if there wasn't already a value in the map associated with

383
00:25:30,840 --> 00:25:31,660
that key.

384
00:25:31,700 --> 00:25:32,160
OK.

385
00:25:35,110 --> 00:25:41,170
So I don't know, like if we wanted to just initialize the map with something right, that might be

386
00:25:41,170 --> 00:25:43,390
an example where we might want to use this.

387
00:25:43,390 --> 00:25:53,050
So let's say here we could do again the a thirty two and then we're going to supply a function which

388
00:25:53,050 --> 00:25:54,100
is going to be a key.

389
00:25:54,580 --> 00:26:00,700
And I don't know, maybe we'll just initialize it with the length of the key.

390
00:26:01,330 --> 00:26:02,680
I'm just saying something.

391
00:26:02,710 --> 00:26:04,990
I'm just doing something kind of random here now.

392
00:26:05,080 --> 00:26:10,060
I'm getting an error there because the value that comes back from this needs to be of type long because

393
00:26:10,060 --> 00:26:12,400
those are what the values of this particular map are.

394
00:26:12,550 --> 00:26:15,430
So I could satisfy that by doing an option.

395
00:26:15,430 --> 00:26:23,530
Enter here and have the ID convert my convert, the integer that's coming out of the court length to

396
00:26:23,530 --> 00:26:30,880
a long right by using long that value of OK, that's not a real useful thing to do, obviously, but

397
00:26:30,880 --> 00:26:33,940
that's an example of how to use the compute if absent.

398
00:26:34,060 --> 00:26:34,420
OK.

399
00:26:34,870 --> 00:26:35,320
All right.

400
00:26:35,350 --> 00:26:38,170
And then let's see, what else do we have here?

401
00:26:38,170 --> 00:26:38,980
So we've got compute.

402
00:26:38,980 --> 00:26:39,370
Let's see.

403
00:26:40,090 --> 00:26:40,780
I think there's one more.

404
00:26:40,780 --> 00:26:42,460
Yeah, there's compute if present.

405
00:26:43,810 --> 00:26:45,880
So let's take a look at this guy.

406
00:26:45,880 --> 00:26:48,970
So it also takes the key and it takes the bi function again.

407
00:26:51,010 --> 00:26:58,960
So this one, if the value of the for the specified key is present and non null, it will attempt to

408
00:26:58,960 --> 00:27:00,700
compute a new mapping.

409
00:27:00,700 --> 00:27:03,520
Given the key and it's current map the value.

410
00:27:03,520 --> 00:27:08,170
I'm not going to show an example of this because it'll look just like the compute one did.

411
00:27:08,350 --> 00:27:15,010
The difference being the compute was calling our lambda, regardless of whether or not there was a value

412
00:27:15,010 --> 00:27:21,880
already associated with the key compute of absent was only calling our lambda if there was not already

413
00:27:21,880 --> 00:27:23,790
a value associated with the key.

414
00:27:23,800 --> 00:27:25,420
And this one is the opposite of that.

415
00:27:25,630 --> 00:27:30,880
It's only going to call our lambda if there was already a value associated with the key.

416
00:27:31,120 --> 00:27:38,200
So again, doing the counting thing, probably not real great fit for this method because we would for

417
00:27:38,200 --> 00:27:45,910
the counting that we did, we would need a method that will call our lambda, whether or not there's

418
00:27:45,910 --> 00:27:50,710
a value already associated because presumably when you first start, you won't have any tally marks

419
00:27:50,710 --> 00:27:51,160
at all.

420
00:27:51,310 --> 00:27:53,320
I'm saying tally marks conceptually, right?

421
00:27:54,010 --> 00:27:56,620
And so you'll want to initialize with some tally marks.

422
00:27:56,620 --> 00:28:01,540
And then from there, you'll want to keep adding up as you encounter the same key over and over and

423
00:28:01,540 --> 00:28:02,060
over again.

424
00:28:02,080 --> 00:28:02,440
OK.

425
00:28:02,590 --> 00:28:05,500
But that's what this compute, if present, would be for.

426
00:28:05,830 --> 00:28:06,290
All right.

427
00:28:06,310 --> 00:28:07,150
Moving on.

428
00:28:10,980 --> 00:28:17,480
Let's see, let's do merge, which is actually for this use case of tallying up stuff.

429
00:28:17,700 --> 00:28:19,170
Merge is actually my favorite.

430
00:28:20,310 --> 00:28:25,740
This is even more concise, so we're going to use this again to do the tallying thing OK, so again,

431
00:28:25,740 --> 00:28:26,670
it takes a key.

432
00:28:27,480 --> 00:28:31,440
It also takes a long value and then it takes a buy function.

433
00:28:31,440 --> 00:28:38,160
So it looks almost identical to the compute method, except that it has this extra second parameter

434
00:28:38,160 --> 00:28:39,600
here of a long.

435
00:28:39,810 --> 00:28:44,580
And if we go take a look at its Java dock, let's see.

436
00:28:44,590 --> 00:28:52,140
So if the specified key is not already associated with a value or is associated with null, it associates

437
00:28:52,140 --> 00:28:54,720
it with the given non null value.

438
00:28:54,720 --> 00:29:00,270
Otherwise, it replaces the associated value with the results of the give and remapping function, or

439
00:29:00,270 --> 00:29:02,310
removes if the result is null.

440
00:29:02,310 --> 00:29:05,260
So that's pretty much identical to what Compute said.

441
00:29:06,000 --> 00:29:10,980
This method may be of use when combining multiple map values for a key.

442
00:29:12,030 --> 00:29:19,890
So going down here to the to the requirements here, so it's going to first look up a value for the

443
00:29:19,890 --> 00:29:22,110
given key and stored in old value.

444
00:29:22,380 --> 00:29:28,800
And then if all value is null, then it's going to return the value that you supplied, which was the

445
00:29:28,800 --> 00:29:30,420
second parameter, OK?

446
00:29:30,720 --> 00:29:35,520
It's going to return to the old, but it's going to return the value that you supplied as an input.

447
00:29:36,900 --> 00:29:42,720
Otherwise, that's what this two columns here is, because this is a ternary operator.

448
00:29:43,080 --> 00:29:50,850
Otherwise, if the old value was not null, then it's going to actually call our supplied lambda expression

449
00:29:52,890 --> 00:29:57,270
passing in the old value and the new value, and then we can do with those what we want.

450
00:29:57,660 --> 00:29:58,110
All right.

451
00:29:58,350 --> 00:30:00,600
So let's see how to use this.

452
00:30:00,990 --> 00:30:02,550
This will be kind of cool, I think.

453
00:30:04,770 --> 00:30:11,010
All right, so we're going to pass them the key again, a thirty two, then we get to pass in a value.

454
00:30:11,190 --> 00:30:15,270
Now I'm going to pass in a one here and you'll see why in just a moment.

455
00:30:16,530 --> 00:30:16,860
All right.

456
00:30:16,860 --> 00:30:21,570
And then we will have our function here by function.

457
00:30:21,750 --> 00:30:24,450
That's going to take the old value in the new value.

458
00:30:24,460 --> 00:30:25,530
So I don't know.

459
00:30:25,530 --> 00:30:27,720
I'll call them X and Y.

460
00:30:29,560 --> 00:30:33,100
And then I'm going to do here is this ad those two guys up?

461
00:30:33,670 --> 00:30:38,710
Oh, and I just need to put an L here because that should be a long right so I can just put an L there

462
00:30:38,710 --> 00:30:39,370
and there we go.

463
00:30:39,850 --> 00:30:43,720
So this is also going to sum up everything.

464
00:30:43,720 --> 00:30:51,490
And what it's going to do is essentially it's going to it's going to look up this key in the in the

465
00:30:51,490 --> 00:30:51,940
map.

466
00:30:52,330 --> 00:30:59,020
And if this key did not already exist in the map, then it's going to create a new entry in the map

467
00:30:59,020 --> 00:30:59,980
with this key.

468
00:31:00,370 --> 00:31:04,120
And it's going to populated with this value of one.

469
00:31:04,120 --> 00:31:09,460
So that's like kind of just the initializing the first tally mark for that given key or if the key was

470
00:31:09,460 --> 00:31:14,800
already in the map but its value was null, it's going to replace the null with this value here of the

471
00:31:14,800 --> 00:31:15,230
one.

472
00:31:15,250 --> 00:31:15,670
OK.

473
00:31:15,940 --> 00:31:19,450
And that's what's going to happen the first time it encounters this particular key.

474
00:31:19,450 --> 00:31:21,490
So it could be California, for example.

475
00:31:21,520 --> 00:31:21,970
OK.

476
00:31:22,330 --> 00:31:28,450
Like I have down here now, the second time it encounters someone from California, it's going to do

477
00:31:28,450 --> 00:31:32,620
a look up and it's going to see, Oh, I already have a value there for California and it's one.

478
00:31:32,740 --> 00:31:39,850
So then it's going to call my lambda expression where it's going to pass in the one that was previously

479
00:31:39,850 --> 00:31:40,900
stored here.

480
00:31:41,560 --> 00:31:45,710
And it's also going to pass in this value here for the X and Y.

481
00:31:45,730 --> 00:31:46,180
OK.

482
00:31:46,390 --> 00:31:50,950
I think this will be the old value which was associated here and then it'll be the new value, which

483
00:31:50,950 --> 00:31:51,790
is this guy here.

484
00:31:52,270 --> 00:31:56,740
So it's going to pass these two values in which would be one and one, and then I'm adding them up,

485
00:31:56,740 --> 00:31:57,460
which is two.

486
00:31:57,610 --> 00:32:05,710
And then that two is going to be placed inside of back inside of the entry for that given key of, let's

487
00:32:05,710 --> 00:32:06,610
say, California.

488
00:32:08,280 --> 00:32:13,830
And so the next time California is encountered again, we're going to go through the same steps again.

489
00:32:14,340 --> 00:32:20,160
It's going to extract the current value that is set in the entry for California, which by now would

490
00:32:20,160 --> 00:32:20,910
be too.

491
00:32:21,360 --> 00:32:25,680
And so it's going to pass in to here and it's going to pass in the one here.

492
00:32:25,770 --> 00:32:27,840
And then I'm going to get to do the addition here.

493
00:32:27,840 --> 00:32:32,250
Two plus one is three and then it's going to put the three back in here and then you see how it's tallying

494
00:32:32,250 --> 00:32:36,660
things up, but it's doing it by and by key, right?

495
00:32:36,810 --> 00:32:43,440
And so the end result is going to be the same thing that we did with the original compute, except even

496
00:32:43,440 --> 00:32:44,250
more concise.

497
00:32:44,250 --> 00:32:50,820
Because if you recall with the previous version of this where I was doing the compute, I had to have

498
00:32:50,820 --> 00:32:57,090
a little bit of a ternary operator there that said, like, if the value is null, then return to one,

499
00:32:57,090 --> 00:33:00,720
otherwise return the new value plus one or something like that, right?

500
00:33:00,900 --> 00:33:05,040
So now I don't even have to do that anymore because this has that logic built into it.

501
00:33:05,430 --> 00:33:05,790
Right?

502
00:33:07,410 --> 00:33:13,230
And again, I can't emphasize enough these this merge method doesn't have to just be used with numbers,

503
00:33:13,230 --> 00:33:17,850
though again, this is probably one of the quintessential use cases for it, for sure.

504
00:33:18,690 --> 00:33:24,270
And like I said before, I've had to do this kind of code so many times in my career, and I always

505
00:33:24,270 --> 00:33:28,140
sort of hate it, even though it's not hard to do, but I kind of just don't like having to write it

506
00:33:28,140 --> 00:33:28,620
all out.

507
00:33:28,830 --> 00:33:32,690
And now, bam, you can do it so much more concisely, right?

508
00:33:32,710 --> 00:33:34,500
So that's what these methods are for.

509
00:33:34,980 --> 00:33:35,270
All right.

510
00:33:35,280 --> 00:33:43,110
And so I think that's going to cover all of the methods of map that were kind of functional, right,

511
00:33:43,110 --> 00:33:46,440
that were that were working with any of this kind of functional business, right?

512
00:33:46,590 --> 00:33:48,450
And so now you know how to use these.

513
00:33:48,510 --> 00:33:54,120
And now you also know I skipped over them when we were actually learning collections before.

514
00:33:55,290 --> 00:34:02,310
And let's take a real, real quick look at the list and set interfaces as well, though we may not go

515
00:34:02,310 --> 00:34:08,460
in quite as much detail, but let's just create a list here of some words.

516
00:34:08,460 --> 00:34:08,940
Maybe.

517
00:34:11,130 --> 00:34:13,680
It's important that interface there.

518
00:34:14,040 --> 00:34:16,830
And let's see here.

519
00:34:17,040 --> 00:34:20,540
So if we've got a list, let's just look at the.

520
00:34:20,970 --> 00:34:23,220
Any of the functional methods for list.

521
00:34:23,220 --> 00:34:28,680
So we've got to replace all that takes a unitary operator of type string because that's what we're passing

522
00:34:28,680 --> 00:34:29,550
in here, right?

523
00:34:30,300 --> 00:34:34,650
So the replace all method here, let's just do this.

524
00:34:35,550 --> 00:34:39,990
So we'll take a look at its Java doc and we can look at the implementation for it.

525
00:34:40,650 --> 00:34:40,920
All right.

526
00:34:40,950 --> 00:34:46,530
So this replaces each element of the list with the result of applying the operator to that element.

527
00:34:46,800 --> 00:34:47,100
All right.

528
00:34:47,110 --> 00:34:55,080
So basically, if you wanted to replace the values of a list in some kind of way, you can use the replace

529
00:34:55,080 --> 00:34:56,160
all method to do it.

530
00:34:56,520 --> 00:34:59,550
And here's how you can expect that it would actually be working.

531
00:34:59,550 --> 00:35:03,120
So it would iterate over the elements in the list.

532
00:35:03,330 --> 00:35:11,520
And for each one, it would simply call your supplied gunnery operator passing in whatever the current

533
00:35:11,520 --> 00:35:12,280
element was.

534
00:35:12,300 --> 00:35:16,980
So in this particular case, it would get called twice, once for the cat, once for the dog, and then

535
00:35:16,980 --> 00:35:19,500
you'd have an opportunity to do something with that.

536
00:35:19,650 --> 00:35:25,710
So for example, if you wanted to uppercase everything in that list, right, you could do that really,

537
00:35:25,710 --> 00:35:26,820
really easily.

538
00:35:27,960 --> 00:35:34,770
Let's say you could just do something like a start to uppercase.

539
00:35:35,780 --> 00:35:36,130
Right.

540
00:35:36,200 --> 00:35:36,890
So you could do that.

541
00:35:36,980 --> 00:35:42,170
And in fact, I think we could even do that more concisely, though, with a method reference, so we

542
00:35:42,170 --> 00:35:45,380
could do string to upper case.

543
00:35:45,920 --> 00:35:46,180
Right?

544
00:35:46,190 --> 00:35:46,450
Yeah.

545
00:35:46,460 --> 00:35:48,050
So we could do that, bam.

546
00:35:48,170 --> 00:35:50,720
Now you just uppercase every single thing in there, right?

547
00:35:51,170 --> 00:35:51,480
All right.

548
00:35:51,500 --> 00:35:53,660
So that's an example of the replace all.

549
00:35:55,070 --> 00:35:55,460
All right.

550
00:35:55,610 --> 00:36:00,420
So taking a look at it, maybe a couple more, and I think that's all that's about left anyway.

551
00:36:00,440 --> 00:36:02,360
There's a big move within a Ford each.

552
00:36:02,660 --> 00:36:05,660
I think you should be really comfortable with the Ford each by now.

553
00:36:06,320 --> 00:36:08,870
This for each is one that just takes a consumer.

554
00:36:08,870 --> 00:36:13,610
So we just know that that's going to take one input and no outputs, right?

555
00:36:13,610 --> 00:36:14,960
And then you can do whatever you want with it.

556
00:36:14,960 --> 00:36:18,020
So typically we'd be using that to print to print things.

557
00:36:18,650 --> 00:36:20,030
That's how we have been using it.

558
00:36:20,120 --> 00:36:24,230
And then the removal is maybe an interesting one, so it takes a predicate.

559
00:36:24,240 --> 00:36:30,350
So we now know that a predicate is a function that takes one input and returns a true or false.

560
00:36:30,530 --> 00:36:35,270
So that true or false, presumably is going to be used to tell the remove this, whether or not it should

561
00:36:35,270 --> 00:36:36,050
remove something.

562
00:36:36,200 --> 00:36:41,630
So one way that we could use that in this case would be if we wanted to wanted to remove all entries

563
00:36:41,630 --> 00:36:44,390
that start with the letter S., for example, right?

564
00:36:44,630 --> 00:36:46,100
So let's see what that would look like.

565
00:36:46,100 --> 00:36:49,100
So we'd get a word as an input, right?

566
00:36:49,100 --> 00:36:56,600
And then we could say something like, Oh W, it starts with C, right?

567
00:36:56,990 --> 00:36:59,390
So that would remove the word cad.

568
00:36:59,690 --> 00:37:05,060
One thing to note, by the way, I did this list thought up, and then I'm showing these examples here.

569
00:37:05,060 --> 00:37:13,070
In real life, this wouldn't quite work because list that of will return and UN modifiable list, which

570
00:37:13,070 --> 00:37:16,880
means it can't be changed in all of these methods here would be trying to change it.

571
00:37:16,880 --> 00:37:20,420
And so we'd actually get errors if we were to try this.

572
00:37:20,600 --> 00:37:27,770
The way to make this work in real life would be to maybe do something like create a new array list and

573
00:37:27,770 --> 00:37:32,150
wrap wrap this on modifiable list.

574
00:37:32,150 --> 00:37:38,270
Inside of that, and I did show that technique in the in the collections module before.

575
00:37:38,720 --> 00:37:40,010
So yeah, we'll import that.

576
00:37:40,100 --> 00:37:42,290
And so now you could you could do this.

577
00:37:43,040 --> 00:37:47,180
However, now it's complaining that it doesn't know that W is a string anymore.

578
00:37:47,180 --> 00:37:54,800
So really, you kind of need to you'd need to actually assign it to a variable and go through all of

579
00:37:54,800 --> 00:37:54,970
that.

580
00:37:54,980 --> 00:37:57,710
I'm not going to do all of that here, but hopefully you get what I'm getting.

581
00:37:58,310 --> 00:38:00,020
Hopefully, you understand what I'm saying here.

582
00:38:00,950 --> 00:38:05,900
I'm just showing this bit here just for illustrative purposes, so we can wrap this up.

583
00:38:06,740 --> 00:38:07,010
All right.

584
00:38:07,020 --> 00:38:09,980
And then you're going to see very similar things for the set, right?

585
00:38:10,160 --> 00:38:17,630
So I hope now you'll feel very much empowered and not intimidated by the various functional methods

586
00:38:18,230 --> 00:38:20,510
that exist on the collections class.

587
00:38:20,840 --> 00:38:25,800
And so I now have wrapped up the odds and ends that I wanted to.

588
00:38:25,940 --> 00:38:28,550
And with that, I will close out this lesson.
