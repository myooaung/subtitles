WEBVTT
1
00:00:00.540 --> 00:00:06.690
All right, and so now we get to jump in to another really interesting method that is pretty much taken

2
00:00:06.690 --> 00:00:10.530
straight from the Streams API for this, we're going to do a little bit of setup, though.

3
00:00:10.830 --> 00:00:17.190
So the first thing I want to do is I'm going to create a couple of small model classes here.

4
00:00:17.310 --> 00:00:17.820
Let's see.

5
00:00:17.820 --> 00:00:24.390
First, I will create a record class and I'm again just going to make this as a nested record.

6
00:00:24.690 --> 00:00:27.090
So I'm going to model a car.

7
00:00:28.770 --> 00:00:36.330
With a make and a model, and I don't know a color.

8
00:00:37.840 --> 00:00:45.790
And a year now, I could use a local date like you've seen me do this before, when I needed to model

9
00:00:45.790 --> 00:00:47.620
like birth dates and things like that.

10
00:00:47.800 --> 00:00:52.030
But cars typically only go down to the model a year.

11
00:00:52.210 --> 00:00:54.400
And so and we're going to learn more about this.

12
00:00:54.410 --> 00:01:01.510
I think maybe in the next lesson, in fact, we can model just a year all on its own and not a whole

13
00:01:01.510 --> 00:01:08.950
entire date, so we can just use year of the job that time package so year and then we'll just call

14
00:01:08.950 --> 00:01:10.450
this property year.

15
00:01:11.260 --> 00:01:12.010
All right.

16
00:01:12.460 --> 00:01:14.830
And then let's model a person.

17
00:01:17.010 --> 00:01:21.390
With the first name and a last name.

18
00:01:22.580 --> 00:01:24.230
And a car.

19
00:01:25.340 --> 00:01:25.850
All right.

20
00:01:26.780 --> 00:01:28.460
So we've got those two.

21
00:01:29.270 --> 00:01:29.600
All right.

22
00:01:29.640 --> 00:01:34.940
And so now let's go ahead and create, I don't know, one or two people, I suppose.

23
00:01:35.480 --> 00:01:37.580
So let's create a person looks.

24
00:01:38.390 --> 00:01:42.110
We'll call this one p one equals new person.

25
00:01:42.920 --> 00:01:45.280
And let's see, Tom.

26
00:01:48.140 --> 00:01:48.790
Some.

27
00:01:51.780 --> 00:01:53.250
And he's going to have a car now.

28
00:01:53.270 --> 00:01:58.740
I don't know that you've seen me do this before, but I'm going to create a car inside of the constructor

29
00:01:58.740 --> 00:01:59.550
for the person.

30
00:01:59.970 --> 00:02:04.500
It's not anything special, but you may not have seen me do it explicitly like this before, so I can

31
00:02:04.500 --> 00:02:11.280
just do new car and then I can create the car with the car's constructor while I'm creating the person

32
00:02:11.280 --> 00:02:12.900
inside of the person's constructor.

33
00:02:13.140 --> 00:02:19.050
All in one, I wouldn't do a lot of this typically because it may result in a really long line, but

34
00:02:19.050 --> 00:02:21.570
just for convenience here I'm doing it this way.

35
00:02:21.930 --> 00:02:24.420
All right, so my make will be a Tesla.

36
00:02:24.420 --> 00:02:31.470
I'm very partial to Tesla and this will be a Model X and the color will be red.

37
00:02:31.890 --> 00:02:34.290
And the year will be now here.

38
00:02:34.470 --> 00:02:36.270
I can just do a year, sort of.

39
00:02:36.860 --> 00:02:41.400
That nice 2018 and I'm running off the screen here.

40
00:02:41.400 --> 00:02:42.810
But let's see.

41
00:02:42.810 --> 00:02:43.410
There we go.

42
00:02:43.530 --> 00:02:46.910
I've got enough to get the semicolon in there and I don't know.

43
00:02:46.920 --> 00:02:53.100
Let's make one more, I suppose, to and we'll call this person Jerry.

44
00:02:53.790 --> 00:02:56.400
And they also have a Tesla.

45
00:02:56.400 --> 00:03:02.340
But it'll be a Y and it'll be white and it'll be a 2020.

46
00:03:03.120 --> 00:03:03.720
There we go.

47
00:03:04.380 --> 00:03:04.920
OK.

48
00:03:05.220 --> 00:03:10.170
So we've got a couple of people here, and let's close this down.

49
00:03:10.440 --> 00:03:10.710
All right.

50
00:03:10.710 --> 00:03:20.310
So first up, let us simply, you know, let's let's get rid of let's get rid of all of this and we'll

51
00:03:20.310 --> 00:03:21.570
kind of start fresh here.

52
00:03:22.110 --> 00:03:27.270
So let's start off by creating an optional of.

53
00:03:28.810 --> 00:03:31.960
P1 and capture that.

54
00:03:32.990 --> 00:03:38.870
And we'll call it up, person, and then let's get ready to just print that out.

55
00:03:39.560 --> 00:03:39.790
All right.

56
00:03:39.800 --> 00:03:41.840
So first, let's just see what this does.

57
00:03:42.050 --> 00:03:44.530
I think we already know, but OK, so there we go.

58
00:03:44.540 --> 00:03:50.960
It's an optional and then we get the string representation of the person class, which also yields the

59
00:03:50.960 --> 00:03:54.050
string representation, the two string method of the car, right?

60
00:03:54.050 --> 00:03:55.400
So that's what we're getting there.

61
00:03:55.520 --> 00:03:56.180
OK, cool.

62
00:03:56.780 --> 00:04:03.560
Now let's say that we want to obtain just the first name, for example, of this person.

63
00:04:03.590 --> 00:04:03.920
Right?

64
00:04:04.640 --> 00:04:11.270
So some of you who maybe weren't paying total attention might think that you could have just done something

65
00:04:11.270 --> 00:04:15.110
like, you know, get or are or first name.

66
00:04:15.110 --> 00:04:20.270
But obviously, you can't do any of those things because this isn't a person that I'm working with right

67
00:04:20.270 --> 00:04:20.510
now.

68
00:04:20.510 --> 00:04:21.740
It's an optional right.

69
00:04:21.980 --> 00:04:28.070
So I would have to first peel off the optional layer to get to the person underneath so that I can then

70
00:04:28.070 --> 00:04:30.050
get to the first name, right?

71
00:04:30.410 --> 00:04:40.570
So I could do a get, which we already know is generally not a good idea or I could do and or else right.

72
00:04:40.940 --> 00:04:48.140
However, now the or else is wanting me to specify an alternative object that it should return if there

73
00:04:48.140 --> 00:04:50.390
wasn't anything in the optional.

74
00:04:50.540 --> 00:04:55.160
And that might be a little annoying in this case, because the alternative object isn't the string anymore.

75
00:04:55.160 --> 00:04:56.600
It's actually a person, right?

76
00:04:56.780 --> 00:05:01.910
I'd have to supply a whole other person as a backup person, right?

77
00:05:02.000 --> 00:05:04.160
And that feels a little awkward to me.

78
00:05:04.340 --> 00:05:07.640
I don't really want to have to do all of that right?

79
00:05:08.360 --> 00:05:12.440
But there's another thing that I could do that I think is kind of cool.

80
00:05:12.830 --> 00:05:18.050
And that is there's a map function on here, just like from the Streams API.

81
00:05:18.290 --> 00:05:25.220
Now, if you'll recall in the Streams API, we used the map function to basically convert or translate

82
00:05:25.520 --> 00:05:31.160
whatever our main starring object type was within the stream to something else.

83
00:05:31.190 --> 00:05:39.770
So if we had a stream of strings that were numeric, we could convert those text representations of

84
00:05:39.770 --> 00:05:41.860
numbers into actual numbers, right?

85
00:05:41.870 --> 00:05:48.790
So we could go from a stream of strings to a stream of integers or longs or something like that, right?

86
00:05:48.800 --> 00:05:51.230
So the map function simply converts.

87
00:05:51.410 --> 00:05:56.150
It takes an input of whatever the wrapped type is.

88
00:05:56.150 --> 00:06:02.690
So in the streams API, those objects are wrapped inside of a stream in the optional API.

89
00:06:02.810 --> 00:06:05.420
The objects are wrapped inside of optional right.

90
00:06:05.690 --> 00:06:11.090
So it takes the objects that are wrapped inside of the optional, and then it allows us to implement

91
00:06:11.090 --> 00:06:15.840
a function that will access or convert from the one type to the other types.

92
00:06:15.920 --> 00:06:20.690
So in this case, where we want to get the first name, for example, basically we can think of this

93
00:06:20.690 --> 00:06:25.580
as a mapping function where we will map a person to just their name.

94
00:06:26.150 --> 00:06:31.580
So let's first look at what this would look like as a traditional lambda expression.

95
00:06:32.000 --> 00:06:39.410
So it'll take an input of the object that was wrapped inside of the optional, which would be a person

96
00:06:39.410 --> 00:06:40.190
in this case.

97
00:06:40.520 --> 00:06:47.150
So I could call that person and then I'll use my arrow indicator and then I can do anything with that

98
00:06:47.150 --> 00:06:49.850
person, such as access the first name method here, right?

99
00:06:49.850 --> 00:06:51.260
So that's pulling the first name.

100
00:06:51.260 --> 00:06:55.520
So we're converting the person into just their first name, right?

101
00:06:55.880 --> 00:06:56.540
Like so.

102
00:06:56.900 --> 00:07:03.350
So if we hover over the map function here, we see that it wants to return an optional.

103
00:07:03.560 --> 00:07:06.260
So it works with options of T.

104
00:07:06.260 --> 00:07:11.810
That's one type, but it will return optional of another type, which they're calling you here.

105
00:07:11.840 --> 00:07:12.260
OK.

106
00:07:12.470 --> 00:07:18.410
So it's just conveying that whatever data type you had coming in doesn't have to be the same data type

107
00:07:18.410 --> 00:07:19.520
that's going out.

108
00:07:19.610 --> 00:07:21.860
It could be, but it doesn't have to be right.

109
00:07:22.160 --> 00:07:23.510
So T and u.

110
00:07:24.140 --> 00:07:27.350
So here we're going from type person to type string.

111
00:07:27.710 --> 00:07:28.670
OK, now.

112
00:07:28.670 --> 00:07:32.810
So what's coming out of this is still wrapped in an optional, though it's a new optional.

113
00:07:33.050 --> 00:07:33.500
OK.

114
00:07:33.740 --> 00:07:38.030
So let's go ahead and just see what this looks like real quick before we complete this.

115
00:07:38.030 --> 00:07:39.260
So let's run that.

116
00:07:40.130 --> 00:07:40.430
All right.

117
00:07:40.430 --> 00:07:42.850
So now we see that we've got an optional of Tom.

118
00:07:42.860 --> 00:07:43.130
Right.

119
00:07:43.130 --> 00:07:44.660
So there's Tom's first name.

120
00:07:44.840 --> 00:07:51.650
Now we can do this more concisely, as some of you may recall by simply using a method reference, which

121
00:07:51.650 --> 00:07:56.720
is really awesome so we can just do first name same thing, right?

122
00:07:57.440 --> 00:08:03.920
So we've already learned in the Lambda and Streams API module that this is equivalent to the lambda

123
00:08:03.920 --> 00:08:05.420
expression that we just had there.

124
00:08:05.420 --> 00:08:07.370
And in fact, I'll just go ahead and run that.

125
00:08:07.670 --> 00:08:08.000
All right.

126
00:08:08.030 --> 00:08:09.800
And so it's a little more concise.

127
00:08:09.800 --> 00:08:10.820
So that's pretty nice.

128
00:08:11.000 --> 00:08:12.860
Now it's an optional still.

129
00:08:12.860 --> 00:08:16.700
So we will likely want to unwrap that still.

130
00:08:16.790 --> 00:08:21.290
But now we're dealing with something a little more concise, which is just a string.

131
00:08:21.560 --> 00:08:27.320
And so now I don't feel quite as awkward about using the or else right and then saying, like, I don't

132
00:08:27.320 --> 00:08:29.630
know, unknown first name.

133
00:08:30.080 --> 00:08:31.160
So let's run this.

134
00:08:31.530 --> 00:08:32.540
All right, so there's Tom.

135
00:08:33.010 --> 00:08:41.440
But if I point this at a null value to do this, I'm going to have to use the of Nullarbor version,

136
00:08:41.440 --> 00:08:41.800
right?

137
00:08:43.770 --> 00:08:47.610
Now I can just do this, and now I get unknown first name.

138
00:08:48.090 --> 00:08:55.350
So one of the many nice things about this pattern that we're using here is that typically if you had

139
00:08:55.860 --> 00:09:00.240
a variable that was null, you're in fact, let's do this.

140
00:09:00.240 --> 00:09:02.790
Let's create one more P3 equals null.

141
00:09:02.970 --> 00:09:03.390
OK.

142
00:09:03.540 --> 00:09:09.360
So if you had a variable that's null like P3 here and then you had some code where you tried to access

143
00:09:09.360 --> 00:09:12.300
P3 Dot first name, right?

144
00:09:12.360 --> 00:09:18.540
This is always kind of annoying that you have to somehow check first whether or not P3 is null before

145
00:09:18.540 --> 00:09:22.560
you bother digging deeper into that object, right?

146
00:09:22.800 --> 00:09:31.200
And so the nice thing here is that by using Map, we get a safer way of digging into the deeper properties

147
00:09:31.400 --> 00:09:37.650
and or methods of this object without having to worry about null pointer exceptions and things of that

148
00:09:37.650 --> 00:09:38.100
sort.

149
00:09:38.310 --> 00:09:44.220
And even if this thing is null, then we just fall back to the or else and then we can get whatever

150
00:09:44.220 --> 00:09:44.670
we want.

151
00:09:44.820 --> 00:09:51.210
And ideally, this will be a much simpler data type at the bottom of the food chain, so to speak,

152
00:09:51.210 --> 00:09:51.500
right?

153
00:09:51.510 --> 00:09:56.820
And so we don't have to like, create a real big complex dummy object or something of that sort.

154
00:09:56.850 --> 00:09:59.460
Right now, we're just creating an alternative string.

155
00:09:59.880 --> 00:10:03.420
OK, so now that we've done it this way, let's go even one step further.

156
00:10:03.780 --> 00:10:05.940
Let's not just try to grab the first name.

157
00:10:06.000 --> 00:10:08.250
Let's try to grab something from this car, right?

158
00:10:08.250 --> 00:10:10.500
So now we're going a couple layers deep.

159
00:10:10.650 --> 00:10:16.110
And again, that's where it really starts to pay off to use like this mapping pattern here so that you

160
00:10:16.110 --> 00:10:18.300
don't have to keep checking for null ability.

161
00:10:18.420 --> 00:10:23.790
We'd have to normally check is the personal No, OK, is the cardinal no, yes or no?

162
00:10:23.820 --> 00:10:28.320
Then finally, we could dig into whatever thing, but by using the map, we won't have to do that.

163
00:10:28.320 --> 00:10:32.870
So let's change this now to obtain the I don't know.

164
00:10:33.090 --> 00:10:36.150
To obtain the make of the person's car.

165
00:10:36.180 --> 00:10:36.630
OK.

166
00:10:37.050 --> 00:10:44.490
So what we can do now is simply change from first name to car like.

167
00:10:44.490 --> 00:10:53.250
So and then let's get rid of this or else for for a minute here and now we can do another map and do

168
00:10:53.250 --> 00:10:55.380
car make.

169
00:10:55.950 --> 00:11:01.230
And then we can do another or else make unknown.

170
00:11:02.370 --> 00:11:04.260
So you see how much easier this is now.

171
00:11:04.410 --> 00:11:11.790
Maybe we might want to format the code a little bit nicer, kind of like we did in the Streams API,

172
00:11:11.790 --> 00:11:15.390
just so that we can read this stuff a bit more fluidly.

173
00:11:16.520 --> 00:11:17.090
There we go.

174
00:11:17.330 --> 00:11:17.690
Right.

175
00:11:18.140 --> 00:11:24.740
So there's our optional person, and if he's not null, then get his car, and if his car's not null,

176
00:11:24.740 --> 00:11:29.030
then get the make and then if any or all of that is null, then just return.

177
00:11:29.030 --> 00:11:31.520
A string of make is unknown, right?

178
00:11:31.880 --> 00:11:32.090
All right.

179
00:11:32.120 --> 00:11:32.840
Let's run that.

180
00:11:35.500 --> 00:11:38.440
Oops and I forgot to get rid of my little example there.

181
00:11:38.470 --> 00:11:40.690
Let's get rid of that and then let's run that.

182
00:11:41.380 --> 00:11:41.940
There we go.

183
00:11:41.950 --> 00:11:46.510
And so we've got make unknown for our Nullarbor guy there.

184
00:11:46.720 --> 00:11:51.610
And now let's put something legit in and we'll use peat to run that again.

185
00:11:51.880 --> 00:11:52.510
And there we go.

186
00:11:52.540 --> 00:11:54.160
Now we're getting Tesla out of that.

187
00:11:54.520 --> 00:12:00.910
So again, this is just really concise how we can avoid having to write a bunch of conditional statements

188
00:12:00.910 --> 00:12:06.610
to test for null ability first before we can access various sub fields of an object.

189
00:12:06.790 --> 00:12:09.370
Really, really nice and concise way to do this.

190
00:12:10.060 --> 00:12:17.200
Now another scenario I want to show you there are increasingly more developers who are really embracing

191
00:12:17.200 --> 00:12:23.920
the whole optional thing to the point that they're even beginning to create their own APIs and domain

192
00:12:23.920 --> 00:12:26.980
models with optionality just baked right in.

193
00:12:27.160 --> 00:12:31.600
And so I want to show you a little bit of what that could look like if you wanted to do that.

194
00:12:31.930 --> 00:12:37.420
So let's say that you're modeling a person and you say, OK, a person will always have to have a first

195
00:12:37.420 --> 00:12:41.450
name and last name, but they may optionally own a car.

196
00:12:41.470 --> 00:12:41.740
Right?

197
00:12:41.860 --> 00:12:46.360
Not everybody owns a car, especially people who live in big, major cities like New York City.

198
00:12:46.360 --> 00:12:49.450
Lots of people in New York City might not own a car at all.

199
00:12:49.480 --> 00:12:49.720
Right?

200
00:12:49.870 --> 00:12:54.460
And so literally owning a car could be considered optional.

201
00:12:54.910 --> 00:13:01.480
So you might want to model your person class with that concept baked right in.

202
00:13:01.690 --> 00:13:10.090
And one way you could do that would be not to make the person have a car, but to make them have an

203
00:13:10.090 --> 00:13:11.590
optional car.

204
00:13:11.890 --> 00:13:14.140
And so you can actually do this right?

205
00:13:14.620 --> 00:13:18.100
So you can just say they have an option of a car.

206
00:13:18.550 --> 00:13:21.720
And right there it implies that they might have a car.

207
00:13:21.730 --> 00:13:22.450
They might not.

208
00:13:22.840 --> 00:13:24.970
They're under no obligation to own one.

209
00:13:25.150 --> 00:13:31.720
Now notice as soon as I've done this, part of my constructor went into error now because I'm trying

210
00:13:31.720 --> 00:13:38.140
to create a new car and then return that for this field in this field is now expecting this to be optional.

211
00:13:38.410 --> 00:13:40.120
So you know what to do, right?

212
00:13:40.390 --> 00:13:43.990
We can simply wrap this inside of an optional.

213
00:13:46.250 --> 00:13:51.540
So we'll just select all of that and then optional of.

214
00:13:52.040 --> 00:13:52.670
There we go.

215
00:13:53.630 --> 00:13:57.050
And I guess I could have done that a fancier way, but that's all right.

216
00:13:57.170 --> 00:14:02.420
So notice what I'm doing here is I'm selecting all of this text and again, I'm using this control W

217
00:14:02.420 --> 00:14:10.430
for Windows users or alt up arrow for Mac users to select all of the new car statement there, right?

218
00:14:10.640 --> 00:14:16.790
And then I'm going to hit parentheses to the left parentheses and that automatically is surrounding

219
00:14:16.790 --> 00:14:18.620
the entire selection in parentheses.

220
00:14:18.740 --> 00:14:21.730
That is an option, by the way, that has to be turned on an intelligent.

221
00:14:21.740 --> 00:14:25.430
I think I've shown this before, but let me see here if I can show it to you again.

222
00:14:25.430 --> 00:14:34.250
Real quick, if I go over here and type in surround and then jump down here to editor general Smart

223
00:14:34.250 --> 00:14:37.950
Keys, I believe the option is this one right here.

224
00:14:37.970 --> 00:14:41.290
Surround selection on typing quote or brace.

225
00:14:41.570 --> 00:14:46.550
I think that's actually working for more than just quotes or braces, as you just saw me use parentheses

226
00:14:46.550 --> 00:14:47.180
as well.

227
00:14:47.390 --> 00:14:49.280
OK, so that's the option right there.

228
00:14:49.970 --> 00:14:50.550
All right.

229
00:14:50.570 --> 00:14:52.160
So let's cancel out of that.

230
00:14:52.610 --> 00:14:52.850
All right.

231
00:14:52.850 --> 00:14:58.610
So then I'll move my cursor over here to the left of this and optional sort of.

232
00:14:59.890 --> 00:15:04.870
All right, and so now I'm creating an option and notice I'm not using of Nullarbor because I don't

233
00:15:04.870 --> 00:15:05.620
need it here.

234
00:15:05.860 --> 00:15:08.170
I'm the one calling this right now.

235
00:15:08.170 --> 00:15:13.930
And so I know for a fact that these aren't null, right and cannot be null in this constructor.

236
00:15:13.930 --> 00:15:15.810
Use that I'm doing right here.

237
00:15:15.820 --> 00:15:17.800
OK, so I don't need the unknowable there.

238
00:15:18.190 --> 00:15:18.430
All right.

239
00:15:18.430 --> 00:15:22.760
So now my cars will be here as optional.

240
00:15:23.320 --> 00:15:29.650
So notice down here now that we're I'm trying to convert a car into just its make, I'm getting red

241
00:15:29.650 --> 00:15:30.160
squiggly.

242
00:15:30.250 --> 00:15:32.530
And if I hover over that, let's see what we get.

243
00:15:32.770 --> 00:15:33.760
Let's see.

244
00:15:34.300 --> 00:15:40.990
So I'm providing a method reference, which is the reference to the make method, the get make method

245
00:15:40.990 --> 00:15:41.770
effectively.

246
00:15:42.370 --> 00:15:49.090
But it says it's expecting a function of something that extends an optional of a car.

247
00:15:49.870 --> 00:15:51.850
So here's the actual problem with this.

248
00:15:52.240 --> 00:15:57.970
You may want to go back and look at the lesson in the Streams API, where I thought about the flat map.

249
00:15:58.270 --> 00:16:03.760
Remember, though, with the flat map, if you're doing a mapping and that mapping returns something

250
00:16:03.760 --> 00:16:11.530
that is inside of its own stream, you must first unwrap that thing from its own stream before you can

251
00:16:11.530 --> 00:16:13.750
continue to use it with the Streams API.

252
00:16:14.230 --> 00:16:17.200
In this case, we're getting a similar situation here.

253
00:16:17.290 --> 00:16:22.300
The map method in this case is expecting that whatever function you're supplying it, that function

254
00:16:22.300 --> 00:16:29.200
is returning just a regular old object, not an object that is wrapped inside of an optional but a regular

255
00:16:29.200 --> 00:16:29.580
object.

256
00:16:29.590 --> 00:16:36.160
And the reason it's assuming that is because the map method will then take that regular object and wrap

257
00:16:36.160 --> 00:16:38.200
it inside of an optional itself.

258
00:16:38.230 --> 00:16:38.530
Right?

259
00:16:38.650 --> 00:16:40.630
That's what the map method does.

260
00:16:40.840 --> 00:16:44.230
But in this case, we're getting a car online.

261
00:16:44.230 --> 00:16:45.170
17.

262
00:16:45.370 --> 00:16:45.850
OK.

263
00:16:46.390 --> 00:16:55.060
And this person car method referenced that we have here used to return a car, and then the map method

264
00:16:55.060 --> 00:17:01.570
was taking that car and wrapping it in a new optional and then passing it on to the next line.

265
00:17:01.810 --> 00:17:07.660
However, now that we've changed things a bit, this person, that car method no longer returns.

266
00:17:07.660 --> 00:17:10.630
And I'm just talking about just this bit right here.

267
00:17:10.630 --> 00:17:14.080
For now, this person, that car method no longer returns a car.

268
00:17:14.320 --> 00:17:17.140
It returns an optional of a car.

269
00:17:17.350 --> 00:17:17.800
OK.

270
00:17:18.220 --> 00:17:25.000
However, that optional of a car is still getting wrapped again by the map method inside of another

271
00:17:25.000 --> 00:17:25.510
optional.

272
00:17:25.510 --> 00:17:28.000
So we've got an optional inside of an optional.

273
00:17:28.390 --> 00:17:37.000
And so now we're down here trying to call cards make and the object that's being passed into the lambda

274
00:17:37.000 --> 00:17:37.180
here.

275
00:17:37.180 --> 00:17:43.300
If you want to remember, you can you can think of this as a lambda expression that would look something

276
00:17:43.300 --> 00:17:44.200
like car.

277
00:17:45.710 --> 00:17:47.660
Car died, get and make right.

278
00:17:47.690 --> 00:17:50.750
That's kind of how you can think of this method reference here, right?

279
00:17:50.900 --> 00:17:57.000
However, the problem is we're not actually receiving an object of type car anymore.

280
00:17:57.020 --> 00:17:59.210
Right now we're receiving.

281
00:18:00.170 --> 00:18:08.630
And optional car and the optional class does not have a get make method on it, and therefore we're

282
00:18:08.630 --> 00:18:10.010
getting an error here.

283
00:18:10.040 --> 00:18:19.430
OK, so we need to unwrap this car out of this optional now and the way we can do that is actually pretty

284
00:18:19.430 --> 00:18:19.910
easy.

285
00:18:20.390 --> 00:18:23.270
There's another method, just as we learned in the Streams API.

286
00:18:23.300 --> 00:18:28.940
There was a flat map, there's a flat map here as well, which can unwrap something that is already

287
00:18:28.940 --> 00:18:35.420
wrapped in an optional so we can just invoke the flat map method right here.

288
00:18:35.450 --> 00:18:36.620
Flat map.

289
00:18:37.280 --> 00:18:38.090
There we go.

290
00:18:38.150 --> 00:18:38.510
Right.

291
00:18:38.780 --> 00:18:44.180
So now the car that's coming out of here won't be doubly wrapped inside of a map, right?

292
00:18:44.180 --> 00:18:50.930
It'll flatten the car that comes out of that person acar method down into just one optional to then

293
00:18:50.930 --> 00:18:57.950
proceed here and the input into this map, by the way, it's going to unwrap one optional for us, right?

294
00:18:58.010 --> 00:19:00.320
We get that one unwrapping for free.

295
00:19:00.530 --> 00:19:00.950
OK.

296
00:19:01.040 --> 00:19:02.780
And so now this is happy.

297
00:19:03.500 --> 00:19:03.860
All right.

298
00:19:03.890 --> 00:19:05.810
And so now we can run this.

299
00:19:07.360 --> 00:19:08.750
And no change, right?

300
00:19:08.770 --> 00:19:09.910
I mean, which is good.

301
00:19:09.940 --> 00:19:11.530
It's working the way that it should be.

302
00:19:12.310 --> 00:19:19.090
And again, just to kind of show how annoying this might have been without using options, we traditionally

303
00:19:19.090 --> 00:19:29.740
would have done something like P1 to get car dot, get make you know, something along those lines.

304
00:19:30.160 --> 00:19:40.690
And we would have had to do some sort of checks to say, like if P1 is not null, then P1 don't get

305
00:19:40.690 --> 00:19:41.410
car.

306
00:19:42.840 --> 00:19:45.150
And then we might have captured the car.

307
00:19:48.240 --> 00:19:57.900
And then we might have had to say something like if a car is not null, then car died, get.

308
00:19:59.170 --> 00:19:59.770
Make.

309
00:20:01.600 --> 00:20:07.000
You see how tedious all of that is, and however deep you want it to go, you might have had to keep

310
00:20:07.000 --> 00:20:10.900
writing all these nested ifs or something equivalent to that, right?

311
00:20:11.140 --> 00:20:17.200
So again, this is just so much more concise to be able to use the mapping and flat map.

312
00:20:17.290 --> 00:20:23.680
The only thing is to keep in mind that with this flat map, the fact that you do have to kind of have

313
00:20:23.680 --> 00:20:30.850
a little bit of awareness of the internal model or API to know, Oh, this method, what does it get?

314
00:20:30.850 --> 00:20:34.840
Car now returns and optional of a car and not an actual car?

315
00:20:35.200 --> 00:20:35.740
I don't know.

316
00:20:35.770 --> 00:20:42.760
I wonder if maybe some at some point in the future, perhaps the makers will give us a third map method

317
00:20:42.760 --> 00:20:49.300
that's like really smart, like smart map or something, and it'll maybe just test for that double optionality

318
00:20:49.300 --> 00:20:50.050
or something like that.

319
00:20:50.050 --> 00:20:52.600
And just or maybe you just use a flat map everywhere.

320
00:20:52.630 --> 00:20:53.440
I don't know.

321
00:20:53.680 --> 00:20:56.320
I'm sure there's pros and cons to that, but I don't know.

322
00:20:56.320 --> 00:20:59.230
I think a lot of developers might not mind seeing something like that.

323
00:20:59.620 --> 00:21:03.430
So at any rate, there you go with the flat mapping and all of that.

324
00:21:03.440 --> 00:21:05.680
So let's get rid of all of that.

325
00:21:06.880 --> 00:21:11.170
And so now that we've done that, I want to do something even a little more interesting.

326
00:21:11.170 --> 00:21:19.570
I think I want to revisit our repository class and I want to be able to use the repository class now

327
00:21:19.870 --> 00:21:24.640
to save these instances of this person or these people.

328
00:21:24.670 --> 00:21:25.000
Right.

329
00:21:25.180 --> 00:21:29.590
I think that would be kind of cool, but we're going to do this for a particular reason.

330
00:21:29.920 --> 00:21:37.330
If you recall when we modeled the repository class, in fact, here, let's just jump into it so you

331
00:21:37.330 --> 00:21:38.080
can see.

332
00:21:39.790 --> 00:21:42.490
OK, so here we are in the repository class.

333
00:21:42.760 --> 00:21:46.840
And if we go down to there it is fined by IED.

334
00:21:47.110 --> 00:21:50.470
You'll notice that it just returns whatever our data type was.

335
00:21:50.800 --> 00:21:57.370
And if it can't find an object by that particular I.D., it just throws an exception.

336
00:21:57.790 --> 00:22:05.650
So now that we are learning about options, I can tell you that a lot of newer APIs that do things like

337
00:22:05.650 --> 00:22:13.570
this may opt not to throw an exception anymore, but instead to model the API such that it would just

338
00:22:13.570 --> 00:22:14.890
return an optional.

339
00:22:14.950 --> 00:22:15.430
OK.

340
00:22:15.580 --> 00:22:18.010
And that way, no exceptions are needed.

341
00:22:18.550 --> 00:22:23.500
You either have something in the optional or you don't right, and then you can use these optional techniques

342
00:22:23.500 --> 00:22:27.610
to proceed accordingly with whatever you did or didn't get.

343
00:22:27.940 --> 00:22:33.630
So I think what I want to do here is let's revise this method now to no longer throw this exception

344
00:22:33.760 --> 00:22:40.270
and instead to just return an optional every time, which should be actually quite easy because that's

345
00:22:40.270 --> 00:22:42.790
what we're getting out of the fine first, anyway.

346
00:22:42.820 --> 00:22:43.180
Right?

347
00:22:44.470 --> 00:22:44.770
All right.

348
00:22:44.800 --> 00:22:47.890
So in fact, while we're here, we might as well just start with that.

349
00:22:48.070 --> 00:22:56.080
So let's just get rid of this like so and now we get an error because this is returning an optional

350
00:22:56.080 --> 00:22:57.520
but we said it returns a T.

351
00:22:57.670 --> 00:23:06.010
So now we need to change this to be an optional oops optional of a T.

352
00:23:07.030 --> 00:23:08.980
And I need to import optional.

353
00:23:09.280 --> 00:23:09.820
There we go.

354
00:23:09.850 --> 00:23:11.260
And so that part was easy.

355
00:23:11.380 --> 00:23:14.010
Now I see that have got an error down here, by the way.

356
00:23:14.020 --> 00:23:18.850
So you've seen me kind of look at these a few times, but I've never called it out explicitly.

357
00:23:18.850 --> 00:23:24.400
So yeah, you can see your errors right there and you can even click on that and jump straight to that

358
00:23:24.400 --> 00:23:25.180
error there.

359
00:23:25.390 --> 00:23:28.000
So the error now is what?

360
00:23:28.090 --> 00:23:35.230
OK, so now the error is the fact that we're doing pre product find by I.D. And now and currently we're

361
00:23:35.230 --> 00:23:38.800
coating this as if it was this going to return an actual person.

362
00:23:38.800 --> 00:23:43.630
But we know that it's not now and now it's returning an optional of a person, and so we will have to

363
00:23:43.630 --> 00:23:45.520
actually dig that out.

364
00:23:46.420 --> 00:23:52.960
So in this particular case, don't do as I show, do as I say, but I am, in this particular case,

365
00:23:52.960 --> 00:23:58.510
going to go ahead and just call that get because I happen to know, without a doubt for this simple

366
00:23:58.510 --> 00:24:04.210
code that we're writing here, which is example code anyway, that there's no chance in this particular

367
00:24:04.210 --> 00:24:06.320
case that that is going to be null.

368
00:24:06.340 --> 00:24:07.870
I know that it's not null.

369
00:24:08.110 --> 00:24:10.390
And so I'm just going to call that get.

370
00:24:10.960 --> 00:24:13.930
So now let's jump back over here to the optional test.

371
00:24:14.410 --> 00:24:22.570
And so now we want to create an instance of our repository and then use it to save a few people and

372
00:24:22.570 --> 00:24:26.300
then retrieve one of those people back out by I.D..

373
00:24:26.620 --> 00:24:33.580
Now if you will recall, though, before we can use the person class, this person class with that repository,

374
00:24:33.880 --> 00:24:38.650
this person class has to first implement a couple of interfaces, right?

375
00:24:38.710 --> 00:24:40.180
Because that's how we kind of wrote it.

376
00:24:40.450 --> 00:24:47.470
So one thing is that the person class is going to have to have an I.D. and it needs to be of type long.

377
00:24:47.470 --> 00:24:50.290
So I'm just going to model that here.

378
00:24:50.290 --> 00:24:51.140
Like so.

379
00:24:51.160 --> 00:24:54.280
And now these are in error because they don't have IDs.

380
00:24:54.700 --> 00:24:57.040
So I'm going to go ahead and just apply them now.

381
00:24:57.070 --> 00:25:01.210
I will say this will let me go ahead and put these IDs in first, and I can use anything here.

382
00:25:01.360 --> 00:25:06.580
One hundred al and 200 L like sir.

383
00:25:06.790 --> 00:25:09.700
And now the errors have gone away, so we're good there.

384
00:25:09.880 --> 00:25:15.490
Now one thing I will say is that in real life, you typically wouldn't be creating these records and

385
00:25:15.490 --> 00:25:17.830
hard coding IDs into them.

386
00:25:18.310 --> 00:25:25.690
Most APIs that let us save data to a data store of some sort like a database or whatever you would create

387
00:25:25.690 --> 00:25:28.510
the person and leave the I.D. null.

388
00:25:28.780 --> 00:25:35.140
And then when you save the person to the data, store the code that does the saving to the data store

389
00:25:35.140 --> 00:25:41.200
would actually be responsible for either generating an I.D. for you or the data store would generate

390
00:25:41.200 --> 00:25:43.720
the I.D. and then the code.

391
00:25:43.720 --> 00:25:51.100
The repository in this case would take that generated ID and then stick it back into our person class

392
00:25:51.100 --> 00:25:51.820
in this case.

393
00:25:52.000 --> 00:25:57.190
And then it would return us, that person in large part so that we would have an easy way of determining

394
00:25:57.190 --> 00:25:59.170
what the newly generated ID was.

395
00:25:59.350 --> 00:26:01.210
And we could have modeled it that way.

396
00:26:01.210 --> 00:26:02.860
And I know maybe we'll go back and do it.

397
00:26:02.860 --> 00:26:07.840
But I just wanted to point out in real life, you wouldn't normally be creating your own IDs.

398
00:26:08.080 --> 00:26:14.860
You'd be letting the underlying database code and database system generate those ideas for you.

399
00:26:15.280 --> 00:26:15.730
OK.

400
00:26:16.750 --> 00:26:19.240
But this is a poor man's implementation for right now.

401
00:26:19.570 --> 00:26:26.440
OK, so now we've addressed that, and then we need the person class to implement our two interfaces,

402
00:26:26.440 --> 00:26:26.770
right?

403
00:26:27.070 --> 00:26:30.880
So to do that, we can simply say implements.

404
00:26:30.880 --> 00:26:38.680
And I think it was ideal, and we need to specify what is the data type for the IDs here as a generic.

405
00:26:38.680 --> 00:26:39.850
And that was long.

406
00:26:41.690 --> 00:26:48.650
And then I think we also had to implement one other flag interface, so I could have just gone back

407
00:26:48.650 --> 00:26:50.630
and remove that flag interface, but that's all right.

408
00:26:50.900 --> 00:26:52.400
And that was like savable.

409
00:26:52.940 --> 00:26:53.480
Here we go.

410
00:26:53.840 --> 00:26:58.670
And notice again that these are being presented with the class that they live in because these are both

411
00:26:58.670 --> 00:27:01.550
nested classes or nested interfaces, really.

412
00:27:01.760 --> 00:27:02.000
Right.

413
00:27:02.000 --> 00:27:05.000
So their repository that savable and repository that idea.

414
00:27:05.660 --> 00:27:06.100
OK.

415
00:27:06.110 --> 00:27:11.000
And so now our repository can work with this person class.

416
00:27:11.450 --> 00:27:17.090
Now notice I don't need to do anything for the car because we're not saving cars on their own.

417
00:27:17.330 --> 00:27:20.570
The cars are kind of embedded inside of the person, right?

418
00:27:20.810 --> 00:27:25.880
And that's another thing that we haven't done a whole lot of in this course is showing these slightly

419
00:27:25.880 --> 00:27:33.770
more hierarchical domain models where you can have a domain object or class that itself is comprised

420
00:27:33.770 --> 00:27:35.810
of other classes, right?

421
00:27:35.840 --> 00:27:42.800
And you can build these fairly complex, potentially complex hierarchies, class hierarchies.

422
00:27:43.310 --> 00:27:43.550
All right.

423
00:27:43.550 --> 00:27:50.480
So now that we've got that, let's go ahead and create an instance of a repository so repository.

424
00:27:50.600 --> 00:27:55.490
And I have to say now what kind of data types this repository is going to be working with.

425
00:27:55.490 --> 00:27:58.820
So it's going to be working with my person class.

426
00:27:58.970 --> 00:28:05.000
Now notice here I have two persons because we also modeled a nested person class inside of the repository

427
00:28:05.000 --> 00:28:05.770
class itself.

428
00:28:05.780 --> 00:28:06.680
We don't want that one.

429
00:28:06.680 --> 00:28:10.840
We want the person that is the nested class inside of the optional test.

430
00:28:10.850 --> 00:28:16.130
And again, I'm using the word class and record interchangeably because they are almost the same thing.

431
00:28:16.700 --> 00:28:25.880
So there's our person and then we have to also supply the data type for the IDs, which is type long.

432
00:28:26.540 --> 00:28:26.880
All right.

433
00:28:26.900 --> 00:28:33.140
And then we'll call this repo and then we'll say new repository like so.

434
00:28:33.620 --> 00:28:39.290
And I just want to point out also that again, our use of these generics here where we're specifying

435
00:28:39.290 --> 00:28:45.560
the data type of the objects that we will be storing and then also the data type of the IDs for those

436
00:28:45.560 --> 00:28:51.290
objects, you're actually going to see this pattern exactly like this in my next course, where I will

437
00:28:51.290 --> 00:28:53.180
be teaching the spring framework.

438
00:28:53.390 --> 00:28:58.160
So again, I just wanted you to know that this isn't totally contrived.

439
00:28:58.160 --> 00:29:04.100
This is modeled off of a real framework that does things pretty identically to this, at least at this

440
00:29:04.100 --> 00:29:04.520
point.

441
00:29:04.550 --> 00:29:04.940
OK.

442
00:29:05.210 --> 00:29:05.660
All right.

443
00:29:05.670 --> 00:29:13.460
So now that we've got that, we can go ahead and start saving our object, so then we can call Repo

444
00:29:13.460 --> 00:29:21.320
Dot Save P1 now the save method is returning a reference to the P1, but I'm just ignoring that right?

445
00:29:21.320 --> 00:29:25.800
So I could capture that if I wanted to save P1, right?

446
00:29:25.820 --> 00:29:26.750
I could do that.

447
00:29:26.750 --> 00:29:33.470
But I'm I don't have any intention of doing anything with that saved P1, so I'm not capturing these.

448
00:29:33.950 --> 00:29:34.340
All right.

449
00:29:35.420 --> 00:29:37.190
And let's save the other one.

450
00:29:37.190 --> 00:29:41.720
Also P2 like so all right.

451
00:29:41.720 --> 00:29:43.760
So we've got a couple of records saved.

452
00:29:43.910 --> 00:29:51.110
And so now I guess I'm going to delete all of that and then let's just try to retrieve something.

453
00:29:51.350 --> 00:30:00.470
So let's do Repo Dot, find my I.D. And first, we'll start off with the happy path and we'll just retrieve

454
00:30:00.470 --> 00:30:02.780
Item 200 right now.

455
00:30:02.780 --> 00:30:06.500
As you already know, this should return an optional, but let's just run it and see.

456
00:30:07.280 --> 00:30:07.730
There we go.

457
00:30:07.730 --> 00:30:11.390
Yeah, so we're getting an optional of a person, so that's working, OK?

458
00:30:11.720 --> 00:30:17.990
And so now we can dig in on that person and let's start off by just getting like the first name, maybe.

459
00:30:17.990 --> 00:30:23.180
And so I will use Map and we'll do person first name.

460
00:30:23.360 --> 00:30:28.580
Now that's going to still return an optional it'll be an optional of the of a string, right?

461
00:30:28.760 --> 00:30:30.890
So then we can supply and or else.

462
00:30:33.440 --> 00:30:35.720
First name not found.

463
00:30:37.210 --> 00:30:38.170
So we'll run that.

464
00:30:38.350 --> 00:30:43.750
There we go, so we get Jerry out of that, and maybe I should reformat that a bit, and in fact, maybe

465
00:30:43.750 --> 00:30:48.400
I should just extract all of that out into its own line.

466
00:30:49.750 --> 00:30:52.840
First, let's just call it f name.

467
00:30:53.260 --> 00:30:53.740
Here we go.

468
00:30:53.920 --> 00:30:58.690
And then let's let's clean this up a little bit.

469
00:30:59.170 --> 00:30:59.740
There we go.

470
00:31:00.460 --> 00:31:01.720
Run that one more time.

471
00:31:01.750 --> 00:31:02.320
OK, cool.

472
00:31:02.560 --> 00:31:03.550
So there's Jerry.

473
00:31:03.820 --> 00:31:09.100
So now let's refer to an idea that we know doesn't exist, right?

474
00:31:09.110 --> 00:31:12.550
So 300 should not be in here.

475
00:31:12.700 --> 00:31:14.230
So now if we run this?

476
00:31:15.820 --> 00:31:17.980
See, see, now isn't that nice?

477
00:31:18.280 --> 00:31:23.490
We don't have to deal with an exception where we'd have to use a try catch block and then try it in

478
00:31:23.700 --> 00:31:28.600
and then catch it and then do some alternative business because we didn't get the thing that we were

479
00:31:28.600 --> 00:31:31.600
looking for the record that we were looking for right now.

480
00:31:31.600 --> 00:31:38.980
Instead, we can just use the same code for both circumstances of whether or not we found the actual

481
00:31:38.980 --> 00:31:42.370
person from the data store from the repository.

482
00:31:42.730 --> 00:31:44.830
And we don't have to really change anything else.

483
00:31:45.040 --> 00:31:50.830
And this is much more concise code than even having to do the try catch block and all of that business,

484
00:31:50.980 --> 00:31:52.500
which I really don't like.

485
00:31:52.510 --> 00:31:56.800
And most Java developers don't really care for doing a whole lot of try catch blocks because it just

486
00:31:56.800 --> 00:31:57.850
kind of looks nasty.

487
00:31:58.420 --> 00:32:01.090
So isn't that just really concise and nice?

488
00:32:01.330 --> 00:32:09.880
And like I said before, there is a bit of a movement in the Java community to embrace the use of optional,

489
00:32:09.880 --> 00:32:11.800
particularly in APIs.

490
00:32:12.310 --> 00:32:12.560
All right.

491
00:32:12.590 --> 00:32:14.650
And so now I've got one more technique.

492
00:32:14.650 --> 00:32:17.470
I want to show you with the optional.

493
00:32:18.100 --> 00:32:19.630
And let's see for this technique.

494
00:32:19.630 --> 00:32:23.710
I think I'm going to delete all of that again, but I'll keep these people.

495
00:32:23.710 --> 00:32:28.450
And in fact, I think I want to make maybe a couple more people here.

496
00:32:28.870 --> 00:32:31.420
So let's just do this.

497
00:32:31.420 --> 00:32:38.260
I'm just, by the way, I did a command there or control D to duplicate Line 13 a couple of times,

498
00:32:38.260 --> 00:32:40.030
and I will just make a p.

499
00:32:40.450 --> 00:32:41.130
Let's see here.

500
00:32:41.140 --> 00:32:41.560
Well.

501
00:32:42.700 --> 00:32:45.970
Let me select these and then I'm going to move these down.

502
00:32:46.120 --> 00:32:47.710
Yeah, I guess we'll do it that way.

503
00:32:48.130 --> 00:32:55.980
So let's call this PS4 and PS5 and let's have a Jake and a Jonny.

504
00:32:56.380 --> 00:33:06.700
And let's see, this person was driving a three and this person is driving an s and we've got a blue.

505
00:33:08.080 --> 00:33:11.740
And a black and.

506
00:33:13.180 --> 00:33:17.230
2019 and 2021.

507
00:33:18.730 --> 00:33:19.120
All right.

508
00:33:19.360 --> 00:33:23.110
So now we've got these five variables here.

509
00:33:23.140 --> 00:33:24.400
One of them is null.

510
00:33:24.670 --> 00:33:25.030
Right?

511
00:33:25.420 --> 00:33:25.680
All right.

512
00:33:25.690 --> 00:33:27.250
So now here's what I want to do.

513
00:33:27.610 --> 00:33:35.800
I want to create a list of optional people so these people wrapped inside of options, OK?

514
00:33:35.920 --> 00:33:37.710
And I'll show you why in just a moment here.

515
00:33:37.720 --> 00:33:38.680
So let's just do that.

516
00:33:38.700 --> 00:33:42.040
So here's a list of optional.

517
00:33:43.740 --> 00:33:44.700
Persons.

518
00:33:48.090 --> 00:33:51.980
And we will call these people equals.

519
00:33:52.590 --> 00:34:00.180
Now I'm going to initialize this list using the list that of convenience method here and notice all

520
00:34:00.180 --> 00:34:01.620
this junk shows up.

521
00:34:01.620 --> 00:34:03.930
I'm just going to hit escape to make that go away.

522
00:34:04.500 --> 00:34:11.940
And now I want to just wrap all of my people inside of this list that of now, because this is a list

523
00:34:11.940 --> 00:34:15.870
of optional people, though I cannot just do like this.

524
00:34:15.960 --> 00:34:16.950
I can't do that.

525
00:34:17.130 --> 00:34:30.180
What I need to do instead is to do optional dot of one comma, optional dot of optional dot of P2.

526
00:34:32.430 --> 00:34:38.130
Optional now, this third one is null, so I'll have to use of Nullarbor for P3.

527
00:34:41.930 --> 00:34:43.850
Optional thought of.

528
00:34:45.140 --> 00:34:46.160
For P4.

529
00:34:47.240 --> 00:34:53.270
Scroll over here and optional thought of four P5.

530
00:34:54.080 --> 00:34:54.680
There we go.

531
00:34:55.590 --> 00:34:57.210
All right, so now I've got my list.

532
00:34:57.450 --> 00:35:06.960
And now that I have a list of people, I want to stream over them and let's see, I want to maybe just,

533
00:35:06.960 --> 00:35:11.710
I don't know, print out their first names using something like a for each.

534
00:35:11.730 --> 00:35:12.120
Right?

535
00:35:12.570 --> 00:35:20.370
So you might think of doing something like p p dot, whatever.

536
00:35:20.370 --> 00:35:20.760
But.

537
00:35:21.770 --> 00:35:23.120
What are these objects?

538
00:35:23.750 --> 00:35:25.490
He is not a person.

539
00:35:25.550 --> 00:35:30.340
He is an optional because I have a list of options of person, right?

540
00:35:30.350 --> 00:35:38.060
So I can't just start referring to, you know, the properties of a person down here in this for each

541
00:35:38.060 --> 00:35:38.870
like this.

542
00:35:38.900 --> 00:35:39.260
Right?

543
00:35:40.100 --> 00:35:43.670
So I would actually need to map these first.

544
00:35:43.970 --> 00:35:47.030
So let me do that so I can do a map.

545
00:35:48.570 --> 00:35:50.910
And then I can do an optional.

546
00:35:52.980 --> 00:35:58.920
Get now, I said before not to use get, but in this particular case, I'm going to make it OK and I'll

547
00:35:58.920 --> 00:36:00.450
show you why in just a moment here.

548
00:36:00.870 --> 00:36:02.130
All right, so I can do it get.

549
00:36:02.250 --> 00:36:06.870
So now that's going to unwrap the objects out of their options.

550
00:36:06.870 --> 00:36:09.900
And now I have the actual objects at this point.

551
00:36:10.230 --> 00:36:17.160
And now I can access the fields of the individual people, right?

552
00:36:17.310 --> 00:36:26.670
And so now if I wanted to print out their first names, I could do system that out that print line.

553
00:36:28.130 --> 00:36:28.820
He dot.

554
00:36:30.480 --> 00:36:33.480
First name, right, I could do that.

555
00:36:35.050 --> 00:36:37.420
And actually, I could be even more concise than that.

556
00:36:37.510 --> 00:36:42.670
I could do another mapping, so this first mapping is unwrapping the people out of the options, right?

557
00:36:43.690 --> 00:36:49.720
Then I could do another mapping where I could convert the people to just their first names, right?

558
00:36:49.720 --> 00:36:53.530
So I could do person first name like this.

559
00:36:53.800 --> 00:37:01.430
And then down here in the in the for each, I could get even more concise and then just say system dot

560
00:37:01.480 --> 00:37:06.340
out the oops front line like that, right?

561
00:37:06.490 --> 00:37:12.070
And I don't even have to pass in any arguments because it knows to just take this simple value and match

562
00:37:12.070 --> 00:37:12.850
it up right there.

563
00:37:13.150 --> 00:37:16.960
Now I showed you all of this because there's a problem with it.

564
00:37:17.260 --> 00:37:19.870
Let me go ahead and run it and we'll see what that problem is.

565
00:37:20.830 --> 00:37:21.580
Ooh, look at that.

566
00:37:21.580 --> 00:37:22.210
It blew up.

567
00:37:22.510 --> 00:37:23.630
Where do you think it blew up?

568
00:37:23.650 --> 00:37:30.580
It blew up when the stream got to P3 because P3 is no right, no value present.

569
00:37:32.470 --> 00:37:34.450
So what can we do about that?

570
00:37:34.720 --> 00:37:36.070
It's actually pretty simple.

571
00:37:36.640 --> 00:37:42.670
We can simply do an easy filtering here, and all we need to do is this.

572
00:37:43.750 --> 00:37:48.460
Flip-Flops that filter optional.

573
00:37:49.760 --> 00:37:51.470
Is present.

574
00:37:52.340 --> 00:37:57.530
So remember that now that all of these people objects are wrapped inside an optional.

575
00:37:57.770 --> 00:38:04.630
If any of them happen to be null, we can simply filter those out by using the optional that is present

576
00:38:04.640 --> 00:38:06.590
method like we have here, right?

577
00:38:06.600 --> 00:38:09.500
And so then they'll never even make it to the through the rest of this.

578
00:38:09.710 --> 00:38:10.970
So now if I run this?

579
00:38:12.360 --> 00:38:13.470
We're all good, right?

580
00:38:13.740 --> 00:38:19.170
Anything that any Noel person is just getting ignored out of the stream anyway.

581
00:38:20.310 --> 00:38:24.810
And while we're talking about streams and as I'm wrapping this up, one other thing I just want to show

582
00:38:24.810 --> 00:38:29.460
you real quick here is that the optional class?

583
00:38:29.880 --> 00:38:38.220
Let me let's see here if I let me just create an optional of one of these real quick optional of P1,

584
00:38:38.220 --> 00:38:39.870
and then I will capture that.

585
00:38:42.790 --> 00:38:44.140
Sure, we'll call it that.

586
00:38:44.590 --> 00:38:44.890
All right.

587
00:38:45.040 --> 00:38:51.340
So if I jump on here, there's one other method that we didn't really take a look at explicitly, and

588
00:38:51.340 --> 00:38:52.330
that is stream.

589
00:38:52.340 --> 00:39:00.430
So this is kind of cool because just as the collection's classes have a stream method on them, the

590
00:39:00.430 --> 00:39:07.060
optional class has a stream method too, though that is a little bit of a weird concept because it makes

591
00:39:07.060 --> 00:39:13.660
more sense conceptually to probably most of you, including me, that a collections class would have

592
00:39:13.660 --> 00:39:17.320
a stream because you're streaming over objects in the stream, right?

593
00:39:17.320 --> 00:39:19.540
You potentially have multiple objects.

594
00:39:19.870 --> 00:39:28.600
In the case of optional, it also has a stream, but there's only ever going to be at most one object

595
00:39:28.600 --> 00:39:30.160
in that stream, right?

596
00:39:30.460 --> 00:39:38.020
And that one object will be if the optional object isn't null right, then that object will be in the

597
00:39:38.020 --> 00:39:40.090
stream if it is null.

598
00:39:40.300 --> 00:39:42.310
Then there will be nothing there.

599
00:39:42.580 --> 00:39:46.120
So let's see how we could just use this real quick.

600
00:39:46.510 --> 00:39:53.200
So similarly to what we've got down here, if we do a stream here and let's say that we ultimately just

601
00:39:53.200 --> 00:39:57.280
want to print out the first the name, then we can do a map.

602
00:39:58.430 --> 00:40:02.300
Of person, first name, like so.

603
00:40:03.170 --> 00:40:05.570
And then a four each, for example.

604
00:40:06.050 --> 00:40:11.270
And then we can just say system died out front line.

605
00:40:11.960 --> 00:40:14.600
And so here I'll just comment all of this out.

606
00:40:15.730 --> 00:40:16.870
And we'll run this.

607
00:40:17.960 --> 00:40:21.020
All right, so there's Tom, that's coming out of this.

608
00:40:22.100 --> 00:40:30.440
But now if I point this at P3, which is null and because it's null, I need to now use a of null bowl,

609
00:40:30.470 --> 00:40:30.820
right?

610
00:40:30.980 --> 00:40:32.060
I need to do that.

611
00:40:32.240 --> 00:40:35.570
But now let's run this and now we just get nothing.

612
00:40:35.720 --> 00:40:37.590
But nothing blows up either.

613
00:40:37.970 --> 00:40:43.700
We just get nothing because now what ends up happening is this is going to end up being a stream with

614
00:40:43.700 --> 00:40:45.530
no valid object in it.

615
00:40:45.740 --> 00:40:56.030
So using the stream method on an optional is quite similar to kind of doing this bit here, having an

616
00:40:56.030 --> 00:41:04.040
array of options, but you only have one optional in the array and then testing for is present before

617
00:41:04.040 --> 00:41:06.040
you proceed with the rest of the stream, right?

618
00:41:06.050 --> 00:41:12.620
So this is sort of the equivalent to using the stream method directly on an optional.

619
00:41:12.800 --> 00:41:17.780
And so that's just another nice way of doing some type of processing or whatever it is that you may

620
00:41:17.780 --> 00:41:24.530
want to do at the end of the chain at the end of the pipeline, with that optional without having to

621
00:41:24.530 --> 00:41:27.950
explicitly write like some type of test code or something like that.

622
00:41:28.280 --> 00:41:28.640
All right.

623
00:41:29.270 --> 00:41:35.210
And so finally, that will wrap up what we are learning with the optional class.

624
00:41:35.420 --> 00:41:37.280
Very, very powerful class.

625
00:41:37.670 --> 00:41:42.980
I would I definitely encourage you to use it in place of a lot of null checks and things like that.

626
00:41:43.280 --> 00:41:48.590
And if you end up getting a job some place as a Java developer, there's a good chance that you won't

627
00:41:48.590 --> 00:41:54.500
see people taking full advantage of optional, probably because they just don't realize how powerful

628
00:41:54.500 --> 00:41:55.130
it is.

629
00:41:55.340 --> 00:42:01.070
I went many, many, many, many years of knowing that the optional class was there, and I even used

630
00:42:01.070 --> 00:42:06.350
it a little bit, but I barely even scratched the surface of what it could do.

631
00:42:06.590 --> 00:42:13.250
And now, with your knowledge of lambdas and streams, you can combine that with the optional class

632
00:42:13.250 --> 00:42:19.460
and really write some incredibly powerful code that is much more concise and more readable at the same

633
00:42:19.460 --> 00:42:19.850
time.

634
00:42:20.120 --> 00:42:20.500
All right.

635
00:42:20.540 --> 00:42:22.610
That's going to wrap this up, see in the next one.
