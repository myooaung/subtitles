WEBVTT
1
00:00:00.390 --> 00:00:06.750
All right, so in the last lesson, we were able to implement the ability to upload a file from the

2
00:00:06.750 --> 00:00:10.050
web browser to our back end, which is our Java code.

3
00:00:10.170 --> 00:00:16.080
And we were able to confirm that we really were receiving the file because we got the file name and

4
00:00:16.080 --> 00:00:17.730
the file size, OK.

5
00:00:18.000 --> 00:00:23.340
And we also had to configure our application to permit us to upload larger files than one Meg.

6
00:00:23.380 --> 00:00:28.500
OK, so we got all of that working, but now we need to actually do something with the files because

7
00:00:28.500 --> 00:00:30.380
we're not actually like storing it anywhere.

8
00:00:30.390 --> 00:00:31.620
We're just like receiving it.

9
00:00:31.620 --> 00:00:36.750
And then it kind of evaporates into the mysterious internet ethers of our computer.

10
00:00:37.200 --> 00:00:40.200
So now we're going to actually save it someplace.

11
00:00:40.230 --> 00:00:42.930
Let's talk a little bit about our options for saving it.

12
00:00:44.340 --> 00:00:49.440
In my experience, there are usually a couple of different approaches that I will see teams use when

13
00:00:49.590 --> 00:00:55.590
when dealing with uploaded files, they will either take that file and store it into the database itself

14
00:00:55.980 --> 00:00:59.280
or and when I say the file, I mean the data of it, right?

15
00:00:59.280 --> 00:01:07.560
So all the bytes or some teams may take the file and stored on the file system of a server or on a network

16
00:01:07.560 --> 00:01:09.180
shared drive, which is better.

17
00:01:09.450 --> 00:01:10.650
Something along those lines?

18
00:01:10.660 --> 00:01:10.980
OK.

19
00:01:11.280 --> 00:01:16.290
So I don't want to get too deep into it, but I've probably been on more teams where the file was just

20
00:01:16.290 --> 00:01:17.700
stored into the database.

21
00:01:17.910 --> 00:01:22.080
And sometimes that's for very practical reasons that I might mention in just a second here.

22
00:01:22.260 --> 00:01:26.730
But honestly, that has never been my favorite thing to do with a file.

23
00:01:27.120 --> 00:01:32.400
My problem with that approach is that while it certainly does work, it works just fine.

24
00:01:32.820 --> 00:01:39.150
I know that databases for the most part, especially relational databases that are used in corporations,

25
00:01:39.420 --> 00:01:45.960
are never optimized for storing potentially lots of large binary data and files.

26
00:01:45.960 --> 00:01:46.710
They can do it.

27
00:01:46.980 --> 00:01:49.620
Every database vendor will say, Oh, we can do that.

28
00:01:49.740 --> 00:01:52.820
You can store all of our data in what's called a blob data type.

29
00:01:52.830 --> 00:01:58.110
So remember when we learned in the database section about different data types like VAR, cars in and

30
00:01:58.110 --> 00:02:00.690
big and end dates and things like that?

31
00:02:00.810 --> 00:02:06.540
So there are other data types that we didn't really look too much at, such as blobs and clubs.

32
00:02:06.720 --> 00:02:11.920
And these are data types that are meant to potentially store large amounts of data.

33
00:02:11.940 --> 00:02:14.190
Now, I don't know what they want to define as large.

34
00:02:14.190 --> 00:02:19.590
It's probably going to differ from one database to the other and how the DBUS, the administrators of

35
00:02:19.590 --> 00:02:22.540
the database, have configured the database as well.

36
00:02:22.560 --> 00:02:28.530
But there are data types that are designed in every single database there is, including H2 for holding

37
00:02:28.530 --> 00:02:30.240
on to large amounts of data.

38
00:02:30.600 --> 00:02:33.360
And so you very well could just map all of this.

39
00:02:33.570 --> 00:02:40.500
In fact, what we probably could have done is to go into our person class, and we might have modeled

40
00:02:40.500 --> 00:02:45.330
this field right here as an array of bytes, as a byte array.

41
00:02:45.600 --> 00:02:50.850
And then JPA would have figured out the right thing to do with that pretty much right away.

42
00:02:51.180 --> 00:02:52.710
And that might have been fine.

43
00:02:52.740 --> 00:02:53.940
We might have done that.

44
00:02:54.090 --> 00:02:56.790
But like I said, I'm not a big fan of doing that.

45
00:02:56.790 --> 00:03:05.250
I just feel that if you are comparing the databases ability to efficiently store and retrieve large

46
00:03:05.250 --> 00:03:12.990
amounts of binary file data versus a file system, I think a raw file system is going to win every time.

47
00:03:13.260 --> 00:03:18.600
And so my preference tends to be to store that kind of data in a file system of some sort.

48
00:03:18.840 --> 00:03:22.890
Now, in a corporate environment that's well managed and well implemented.

49
00:03:23.190 --> 00:03:31.920
Chances are you'd actually be storing that data on to some kind of a dedicated network file system device

50
00:03:31.920 --> 00:03:37.200
of some sort where it can be replicated behind the scenes and it's really, really fast in all kinds

51
00:03:37.200 --> 00:03:39.330
of cool things anyway.

52
00:03:39.360 --> 00:03:45.450
So what we're going to do here is store our data on the local file system of the computer, not in the

53
00:03:45.450 --> 00:03:46.210
database.

54
00:03:46.230 --> 00:03:47.130
For now, at least.

55
00:03:47.460 --> 00:03:51.930
I think in one of my future courses, maybe for the next spring courts or something, I will have to

56
00:03:51.930 --> 00:03:54.570
show you how to store it in the database as well.

57
00:03:54.720 --> 00:04:00.660
Because, like I said, that actually ends up being done in my experience more frequently than storing

58
00:04:00.660 --> 00:04:02.310
it on a file system.

59
00:04:02.400 --> 00:04:05.700
Oh, and one other thing I was going to mention now about the file system thing.

60
00:04:06.060 --> 00:04:12.030
So there is a very popular technology for application development and deployment, really.

61
00:04:12.030 --> 00:04:15.070
It's more for deployment than development, called Docker.

62
00:04:15.390 --> 00:04:21.240
And for those of you who have no idea what Docker is, I will try to explain it in this way and say,

63
00:04:21.390 --> 00:04:25.980
imagine if you could open up a piece of software on the computer.

64
00:04:26.520 --> 00:04:32.190
And right now I'm running on a Mac, but imagine if I opened up a piece of software that allowed me

65
00:04:32.190 --> 00:04:36.260
to run windows in a window on my Mac.

66
00:04:36.270 --> 00:04:41.520
OK, and it would actually simulate a PC running inside of my Mac.

67
00:04:41.550 --> 00:04:43.740
OK, now there is software that does that.

68
00:04:44.010 --> 00:04:50.200
It's usually referred to as virtualization software, and there's even an older technology called emulation.

69
00:04:50.220 --> 00:04:50.590
OK.

70
00:04:50.880 --> 00:04:56.050
So there are programs that can do this if you're fairly unfamiliar with these concepts.

71
00:04:56.070 --> 00:04:59.640
I will simply say that Docker is kind of like that.

72
00:04:59.720 --> 00:05:05.570
Although for those of you who want to be most technically accurate, I will simply say that DR definitely

73
00:05:05.570 --> 00:05:09.440
doesn't emulate and doesn't really virtualize either.

74
00:05:09.590 --> 00:05:17.570
It more like puts a sandbox around something that appears to be a copy of its own operating system running

75
00:05:17.570 --> 00:05:19.190
inside of your operating system.

76
00:05:19.280 --> 00:05:21.350
And that's as far as I'm going to go with that right now.

77
00:05:21.530 --> 00:05:29.150
So anyway, Docker is an extremely common popular tool for developers to write an application and then

78
00:05:29.420 --> 00:05:37.070
have it packaged up into something that you can think of as a virtual computer, which can then be deployed

79
00:05:37.070 --> 00:05:42.510
onto a server that hosts lots of virtual computer images.

80
00:05:42.530 --> 00:05:42.920
OK.

81
00:05:43.220 --> 00:05:50.570
And there is a technology that is probably the most commonly used for hosting all of these so-called

82
00:05:50.570 --> 00:05:54.680
Docker images, and that technology is called Kubernetes.

83
00:05:54.920 --> 00:06:00.740
So Kubernetes can be thought of as a Docker container manager or orchestrator.

84
00:06:00.770 --> 00:06:01.150
OK.

85
00:06:01.520 --> 00:06:09.470
And one of the things about using Kubernetes is that it can be configured to make file system storage

86
00:06:09.470 --> 00:06:12.170
available to Docker containers.

87
00:06:12.170 --> 00:06:17.450
And when I say Docker containers, I mean, your application that has been packaged up into something

88
00:06:17.450 --> 00:06:21.680
that looks like its own dedicated operating system image, if you will.

89
00:06:21.830 --> 00:06:24.830
So you may hear me say Docker container or Docker image.

90
00:06:24.890 --> 00:06:25.280
All right.

91
00:06:25.850 --> 00:06:32.420
So anyway, Kubernetes can make file system storage like a C drive or, you know, some some folder

92
00:06:32.420 --> 00:06:34.070
on a on a on a computer.

93
00:06:34.220 --> 00:06:41.450
It can make that available for use by a Docker container, which is housing your application.

94
00:06:41.630 --> 00:06:48.170
However, some organizations may be better at doing this or worse at doing this, or may not configure

95
00:06:48.170 --> 00:06:49.100
it at all.

96
00:06:49.460 --> 00:06:56.630
And one has to be careful about writing applications that will live in a Docker container that are trying

97
00:06:56.630 --> 00:07:04.790
to write or read files to and from a file system that is made available to your Docker container.

98
00:07:04.940 --> 00:07:12.470
You got to be careful with that, because sometimes these Docker containers can blink into existence

99
00:07:12.470 --> 00:07:15.740
and then out of existence and then back into existence again.

100
00:07:15.920 --> 00:07:23.630
And each time they may do that for various orchestration and management reasons, files that they may

101
00:07:23.630 --> 00:07:27.140
have written out to a file system may no longer be there.

102
00:07:27.420 --> 00:07:33.650
OK, so if you write an application like this and it's trying to store these images somewhere and then

103
00:07:33.830 --> 00:07:41.060
the application temporarily gets sort of, we'll call it moved by Kubernetes and then comes back into

104
00:07:41.060 --> 00:07:47.630
existence again or something along those lines, files that it had written out to the file system might

105
00:07:47.630 --> 00:07:48.960
not be there anymore.

106
00:07:48.980 --> 00:07:55.070
And like I said, some organizations will be better at managing this than others, and some may have

107
00:07:55.070 --> 00:07:57.020
rules that you just can't do this at all.

108
00:07:57.230 --> 00:08:04.010
So in those instances, developers might just kind of hit their heads and say, OK, you know what?

109
00:08:04.040 --> 00:08:07.160
We're not even going to deal with those kinds of ambiguities.

110
00:08:07.310 --> 00:08:10.510
Let's just store the files in the database and be done with it.

111
00:08:10.520 --> 00:08:18.560
And in those cases, if the organization that is managing the Kubernetes platform is not being very

112
00:08:18.560 --> 00:08:22.610
helpful with solving those kinds of issues, then yeah, I won't.

113
00:08:22.610 --> 00:08:29.090
I wouldn't really argue with the developers who in that case prefer to just save their files to a database

114
00:08:29.090 --> 00:08:30.260
or somewhere else.

115
00:08:45.670 --> 00:08:49.900
All right, so having said all of that, how can we do this?

116
00:08:50.440 --> 00:08:56.860
Well, the first thing I want to tell you is that if we're going to write code, which we will need

117
00:08:56.860 --> 00:09:06.430
to do to save this file somewhere, I would strongly advised not to write that code in the controller.

118
00:09:06.460 --> 00:09:14.020
OK, so so far, we've just been putting all of our code in the controller, and so far that's been

119
00:09:14.020 --> 00:09:20.980
pretty much OK because we don't really have any business logic because business logic would not belong

120
00:09:20.980 --> 00:09:22.040
in the controller here.

121
00:09:22.060 --> 00:09:27.040
So remember this diagram here where we talk about the service layer and that's where your business logic

122
00:09:27.040 --> 00:09:27.420
goes.

123
00:09:27.430 --> 00:09:31.900
And then you get the presentation layer, which should be handling for our purposes, just all of the

124
00:09:31.900 --> 00:09:38.620
logic that's related to web stuff like receiving the request and then getting the data out of the request

125
00:09:38.740 --> 00:09:44.380
and then storing it someplace which usually in our case, is storing it in the one and only domain model

126
00:09:44.380 --> 00:09:46.750
class that we have, which is the person, right?

127
00:09:46.900 --> 00:09:51.340
And then we do have a database layer now, which is our person repository, right?

128
00:09:51.580 --> 00:09:55.900
But currently, we do not have this business logic or service layer here in the middle.

129
00:09:56.020 --> 00:10:02.830
So our person repository, which represents the database layer, is being injected or interacting directly

130
00:10:02.830 --> 00:10:03.670
with our web layer.

131
00:10:03.670 --> 00:10:08.380
And that's that's OK for right now because we don't have anything in the middle and we don't need any.

132
00:10:08.530 --> 00:10:14.050
Now you will see some teams who will just create an artificial, I would call it artificial business

133
00:10:14.050 --> 00:10:20.080
logic layer, and it will have what I call pass through methods that simply pass through whatever we're

134
00:10:20.080 --> 00:10:22.480
doing in the web down to the database.

135
00:10:22.780 --> 00:10:28.600
So in other words, like like right here where we're calling person repository that save what you might

136
00:10:28.600 --> 00:10:35.350
have seen on some teams is that they will create a class called person service, OK?

137
00:10:35.530 --> 00:10:40.450
And then the person service class will have a saved method.

138
00:10:40.870 --> 00:10:45.640
And so you'd see them call person service that save person so would look exactly like this.

139
00:10:45.730 --> 00:10:50.860
And then if you drilled into the person service method, you would just see this line right here.

140
00:10:52.510 --> 00:11:00.190
That's understandable why they're doing it, because technically that is arguably good architecture.

141
00:11:00.370 --> 00:11:05.310
However, that person service save method is doing nothing at all.

142
00:11:05.320 --> 00:11:07.720
It's what I call a pass through method, right?

143
00:11:07.720 --> 00:11:13.060
It's just passing through to the real thing that's doing the real work, which is the person repository

144
00:11:13.060 --> 00:11:13.540
method.

145
00:11:13.720 --> 00:11:20.590
And so in a case like that, if that person's service that saved method or the person service itself

146
00:11:20.740 --> 00:11:27.580
isn't bringing any value at all to anything at all, like you could just erase it and just do this and

147
00:11:27.580 --> 00:11:32.110
nothing would be better or worse, then you might want to rethink that.

148
00:11:32.170 --> 00:11:38.590
I'm just saying now I've been guilty of following blindly that that three tier pattern to that degree

149
00:11:38.620 --> 00:11:39.370
myself.

150
00:11:39.610 --> 00:11:40.810
But I don't know.

151
00:11:40.840 --> 00:11:43.180
At some point I kind of woke up and realized, You know what?

152
00:11:43.180 --> 00:11:44.780
This is maybe a little bit dumb.

153
00:11:44.800 --> 00:11:46.180
So something to think about.

154
00:11:46.190 --> 00:11:53.290
So anyway, now that we're going to save files, I think we may have a good reason to introduce another

155
00:11:53.320 --> 00:11:55.790
dependency on the people controller.

156
00:11:55.810 --> 00:12:04.000
OK, now actually, you could consider that the ability to store and eventually retrieve files to and

157
00:12:04.000 --> 00:12:10.570
from the file system is really another data access layer responsibility when you think about it, right?

158
00:12:10.780 --> 00:12:15.790
Because currently we are storing people objects to the database and then retrieving them back out and

159
00:12:15.790 --> 00:12:16.960
doing crud on them, right?

160
00:12:17.230 --> 00:12:22.150
Well, we may want to basically just do the exact same kinds of things with files, right?

161
00:12:22.360 --> 00:12:28.750
We want to be able to store a file somewhere and retrieve a file from that same somewhere, right?

162
00:12:29.020 --> 00:12:35.290
So we could consider that we could just create another data access class, right?

163
00:12:35.590 --> 00:12:38.800
And this one will simply work with the file system.

164
00:12:38.830 --> 00:12:39.190
OK.

165
00:12:39.340 --> 00:12:40.900
So let's see what that might look like.

166
00:12:41.050 --> 00:12:42.520
So let's see here.

167
00:12:42.580 --> 00:12:48.780
We currently have a package called data, and that's where we put our personal repository.

168
00:12:48.790 --> 00:12:49.590
So I don't know.

169
00:12:49.600 --> 00:12:51.070
Let's see what this might look like.

170
00:12:51.100 --> 00:12:59.130
So let's create another class called file storage repository.

171
00:12:59.230 --> 00:13:00.250
Let's just do that.

172
00:13:00.520 --> 00:13:03.850
Now I'm going to make this as an actual class because we're not using spring data.

173
00:13:03.850 --> 00:13:06.340
Spring data is primarily for talking to databases.

174
00:13:06.460 --> 00:13:12.250
So let's see, we'll create this out and that let's close that.

175
00:13:12.370 --> 00:13:12.850
All right.

176
00:13:13.150 --> 00:13:19.150
And let's just say that we're going to have a method called, let's see.

177
00:13:19.150 --> 00:13:20.980
I don't even want to think of the data type for right now.

178
00:13:20.980 --> 00:13:27.220
So let's say it's void and it's going to allow us to save a file to the file system.

179
00:13:27.340 --> 00:13:28.990
I guess we could call it save.

180
00:13:29.170 --> 00:13:30.470
Yeah, let's let's do that.

181
00:13:30.760 --> 00:13:31.900
So save.

182
00:13:33.640 --> 00:13:37.570
Now, what will this method take as an input, though?

183
00:13:37.930 --> 00:13:42.670
So now let's jump back over here to our controller and see what we're dealing with when we're using

184
00:13:42.670 --> 00:13:43.600
the save method.

185
00:13:43.780 --> 00:13:48.710
So we're receiving this multi-part photo file name object right here, right?

186
00:13:48.730 --> 00:13:50.260
This guy, actually, you know what?

187
00:13:50.260 --> 00:13:51.520
I just realized something.

188
00:13:51.670 --> 00:13:55.810
I named this photo file name, but it's actually not representing the file name.

189
00:13:55.810 --> 00:13:58.180
It's it's representing the entire file, right?

190
00:13:58.510 --> 00:14:02.230
So actually, I think that should be renamed.

191
00:14:02.260 --> 00:14:02.920
Sorry about that.

192
00:14:02.920 --> 00:14:04.060
I just realized it.

193
00:14:04.540 --> 00:14:08.290
I like naming to be accurate and meaningful.

194
00:14:08.590 --> 00:14:10.180
So that's not really a file name.

195
00:14:10.180 --> 00:14:12.310
That's a file photo file.

196
00:14:13.510 --> 00:14:20.710
Now, since I renamed that, though, its name now no longer matches with what the request is, that's

197
00:14:20.710 --> 00:14:21.430
coming in now.

198
00:14:21.640 --> 00:14:26.440
I could go into the trial and change that, but I don't feel like doing that, to be perfectly honest.

199
00:14:26.450 --> 00:14:32.920
So what I'm going to do instead is come over here to the request parameter and now specify what that

200
00:14:33.100 --> 00:14:35.650
request parameter name actually is.

201
00:14:35.660 --> 00:14:42.430
So this here is called photo file name, OK, and we're going to map that guy's value to this photo

202
00:14:42.430 --> 00:14:42.730
file.

203
00:14:42.730 --> 00:14:45.130
So that's just a kind of a technicality there.

204
00:14:45.400 --> 00:14:45.610
All right.

205
00:14:45.610 --> 00:14:48.880
So we have this photo file now, right?

206
00:14:49.120 --> 00:14:52.330
Of type multi-part file.

207
00:14:52.660 --> 00:14:56.980
Now let's take a look at where that multi-part file is coming from.

208
00:14:57.010 --> 00:15:02.890
So here's the import for the multipart file, and it is part of the web tier from spring framework,

209
00:15:02.890 --> 00:15:09.640
which means that this this class is intended to be used from the web tier perspective.

210
00:15:09.640 --> 00:15:17.650
So again, in our three tier architecture, that multipart file class, as specified by the spring framework,

211
00:15:17.650 --> 00:15:23.320
at least according to its package, is considered part of the web tier.

212
00:15:23.770 --> 00:15:30.940
So this gives me pause because I might have considered taking that multipart file object and simply

213
00:15:30.940 --> 00:15:35.830
passing it down in to my new file storage repository.

214
00:15:36.370 --> 00:15:44.590
However, the apparent fact that that object and class appear to be somewhat tightly connected to the

215
00:15:44.590 --> 00:15:52.560
web tier makes me highly reluctant to allow web stuff to be utilized down here in the data tier.

216
00:15:52.570 --> 00:15:58.780
So you get what I'm saying here now, and nothing is going to happen exactly if I choose to break that

217
00:15:58.780 --> 00:16:04.560
convention, if you will, and let the multipart file thingy come down here into my database tier or

218
00:16:04.570 --> 00:16:08.680
database level or whatever, at least not right now, nothing bad is going to happen.

219
00:16:08.680 --> 00:16:13.360
But let me explain one reason why you might not want to do that.

220
00:16:13.450 --> 00:16:21.970
OK, so what if I wanted to add another presentation layer on top of these two layers here on top in

221
00:16:21.970 --> 00:16:23.680
the business and data access layer?

222
00:16:23.890 --> 00:16:30.070
So right now we've got the web interface and maybe we'd have a mobile client, which for the most part,

223
00:16:30.070 --> 00:16:33.090
would look very similar from the perspective of these guys.

224
00:16:33.100 --> 00:16:36.010
That would look very similar to the the web browser client.

225
00:16:36.190 --> 00:16:43.210
But what if I had a third presentation layer which wasn't internet related at all, and it was like

226
00:16:43.210 --> 00:16:45.870
a local desktop application?

227
00:16:45.880 --> 00:16:48.790
OK, so just the local desktop application.

228
00:16:49.330 --> 00:16:50.500
And do you know what I mean by that?

229
00:16:50.500 --> 00:16:57.640
So not running in the browser, not running on a on a on a phone or anything, but like a native application

230
00:16:57.640 --> 00:17:01.840
that runs on Windows or runs on macOS or something like that, OK?

231
00:17:02.050 --> 00:17:09.790
And so when you open up a file to upload into this database, that file isn't being transmitted over

232
00:17:09.910 --> 00:17:13.090
over a network or over the internet or anything like that.

233
00:17:13.240 --> 00:17:21.670
That file is just being saved in a directory or in a in a database on the same computer as the as the

234
00:17:21.670 --> 00:17:23.470
user interface and everything else.

235
00:17:23.580 --> 00:17:24.710
OK, so it's all local.

236
00:17:24.730 --> 00:17:25.120
OK.

237
00:17:25.600 --> 00:17:29.530
So in that case, multipart file would not make sense.

238
00:17:29.740 --> 00:17:34.310
Multipart file only makes sense in in a web context.

239
00:17:34.330 --> 00:17:34.750
OK.

240
00:17:35.020 --> 00:17:40.450
You only need a multipart file if you're transmitting data multipart form data over the web.

241
00:17:40.600 --> 00:17:47.340
But if you've got a local user interface written in Windows, you know, C-sharp or something like that,

242
00:17:47.350 --> 00:17:53.980
I don't know that that would make sense here, but Java actually has an API and a framework for writing

243
00:17:53.980 --> 00:17:55.350
local applications.

244
00:17:55.360 --> 00:17:58.460
In fact, traditionally all Java IDs.

245
00:17:58.480 --> 00:17:58.660
Yeah.

246
00:17:58.680 --> 00:18:00.490
Actually, let me use that as an example.

247
00:18:00.550 --> 00:18:05.110
Traditionally, all Java IDs are written in Java.

248
00:18:05.230 --> 00:18:10.270
Now, I don't know if intelligence is written in Java anymore, but I'm pretty sure it used to be.

249
00:18:10.600 --> 00:18:16.180
And one of its competitors, Eclipse, as far as I know, that's still written in Java.

250
00:18:16.450 --> 00:18:22.720
So these ideas would be examples of local desktop applications that are likely written in Java.

251
00:18:22.750 --> 00:18:23.110
OK.

252
00:18:23.260 --> 00:18:31.060
So if I wrote a program that looked like this and I could go to file open and then or file save or whatever,

253
00:18:31.060 --> 00:18:34.420
and I could save a picture that I drew inside of this program.

254
00:18:34.420 --> 00:18:38.080
If you could draw draw pictures in here and I could save that somewhere.

255
00:18:38.290 --> 00:18:41.050
And I had code that was allowing me to save that file.

256
00:18:41.170 --> 00:18:44.890
I would not be using this multi-part thing here because there's no web.

257
00:18:45.070 --> 00:18:51.230
I'm not using the web to open or save, you know, files that I'm working with within this application.

258
00:18:51.260 --> 00:18:52.420
OK, so I hope you understand that.

259
00:18:52.750 --> 00:19:00.670
So for that reason, it would probably be a bit inappropriate for me to pass this multi-part file object

260
00:19:00.880 --> 00:19:06.400
down into my new what did I call it, file storage repository?

261
00:19:06.430 --> 00:19:08.620
OK, that probably would not be appropriate.

262
00:19:08.800 --> 00:19:12.520
I probably want a representation of a.

263
00:19:12.660 --> 00:19:14.820
While that has nothing to do with the Web.

264
00:19:15.180 --> 00:19:15.600
All right.

265
00:19:15.630 --> 00:19:16.620
That's my point.

266
00:19:17.160 --> 00:19:28.110
So what I'm thinking is, first off, let's get a reference to this new repository into this controller

267
00:19:28.110 --> 00:19:28.380
here.

268
00:19:28.560 --> 00:19:34.080
So just as we got a reference to the person repository, we can get a reference to the what did I call

269
00:19:34.080 --> 00:19:35.910
it, file storage repository.

270
00:19:37.580 --> 00:19:45.830
Like so and then we can let spring inject that into this constructor, and I'm just going to kind of

271
00:19:45.830 --> 00:19:52.310
come down here on a new line and reference the and say this should be something of type file storage

272
00:19:52.310 --> 00:19:53.330
repository.

273
00:19:54.600 --> 00:19:55.590
Just like that.

274
00:19:55.620 --> 00:19:56.040
OK.

275
00:19:56.520 --> 00:20:02.790
All right, and then the last thing we need to do, of course, is to actually inject our parameter

276
00:20:02.790 --> 00:20:04.290
into the actual field.

277
00:20:04.530 --> 00:20:10.170
So we'll do a vista file storage repository equals file storage repository.

278
00:20:10.230 --> 00:20:13.590
OK, that way we're setting it on that field there.

279
00:20:14.160 --> 00:20:21.090
And just a quick reminder now, so spring will see this one and only constructor of this controller

280
00:20:21.090 --> 00:20:21.630
class.

281
00:20:21.900 --> 00:20:27.240
It will see the data types that are being specified as inputs for the constructor.

282
00:20:27.240 --> 00:20:32.850
And then it'll check its own registry of beans to see if it has any beans of these type.

283
00:20:32.850 --> 00:20:38.730
And if it does, it will inject them onto this controller or rather it will call this controller and

284
00:20:38.730 --> 00:20:41.590
pass in any beans that match this type.

285
00:20:41.620 --> 00:20:43.050
OK, so that's how that's working.

286
00:20:43.230 --> 00:20:49.380
And some of you, if you look online at examples that do similar things, you might see references to

287
00:20:49.380 --> 00:20:52.980
using the at auto wired annotation to do the same thing.

288
00:20:52.980 --> 00:20:58.770
But as of spring version four point three, I think it is worth somewhere around in there.

289
00:20:58.950 --> 00:21:04.210
You don't need the at auto wired annotation for a specific situation like this one.

290
00:21:04.230 --> 00:21:08.610
OK, so that's why I'm not using it, but it wouldn't hurt anything if I did OK.

291
00:21:08.970 --> 00:21:12.360
And so now let's jump over here to this file storage repository.

292
00:21:12.510 --> 00:21:20.550
And so if I annotate this class as a repository, then that will let spring know that it should create

293
00:21:20.550 --> 00:21:26.910
an instance of this guy and then injected into our controller, OK, the same way that it's doing with

294
00:21:26.910 --> 00:21:28.920
our person repository.

295
00:21:28.950 --> 00:21:29.310
All right.

296
00:21:29.580 --> 00:21:31.380
So that's one step.

297
00:21:33.030 --> 00:21:40.080
Then down here, where we are saving a person now, just as we can save that person, we also could

298
00:21:40.080 --> 00:21:41.730
save the file.

299
00:21:41.790 --> 00:21:42.180
Right?

300
00:21:42.420 --> 00:21:47.910
So we could do something like file storage repository Dot Save.

301
00:21:47.940 --> 00:21:51.930
So now the question was, OK, so what are we actually passing into here?

302
00:21:51.960 --> 00:21:52.310
No.

303
00:21:52.680 --> 00:21:58.020
So what we what I just got finished saying is we probably shouldn't be passing in this photo file thing

304
00:21:58.020 --> 00:21:59.490
directly, but we need those.

305
00:21:59.490 --> 00:22:03.960
We need at least the binary data of this photo file thing, right?

306
00:22:04.200 --> 00:22:10.890
So let me cut to the chase and say that what we can do is we can reference the lower level data.

307
00:22:10.890 --> 00:22:14.310
And by the way, we're also going to need the file name itself.

308
00:22:14.310 --> 00:22:16.180
So let's pass that in for sure.

309
00:22:16.200 --> 00:22:21.300
OK, so we can pass that in as one of our inputs and we can pass in multiple inputs on this method,

310
00:22:21.300 --> 00:22:21.690
by the way.

311
00:22:21.810 --> 00:22:24.750
In fact, let's get a little more space here for a little while.

312
00:22:24.780 --> 00:22:25.110
OK.

313
00:22:25.470 --> 00:22:25.740
All right.

314
00:22:25.740 --> 00:22:32.340
So we can pass that in and then we can also get a representation of the binary data of our uploaded

315
00:22:32.340 --> 00:22:36.420
file without passing in the whole entire multi-part thing, though.

316
00:22:36.600 --> 00:22:43.140
And one way that we can do this is by referencing this thing here called Get Input Stream, which represents

317
00:22:43.140 --> 00:22:47.550
a stream of bytes that themselves represent the uploaded file.

318
00:22:47.580 --> 00:22:48.000
OK.

319
00:22:48.240 --> 00:22:52.640
So that's what we can pass in, and maybe that is all we will need to pass.

320
00:22:52.650 --> 00:22:58.020
And now I'm getting a red squiggly because this method can throw an exception.

321
00:22:58.350 --> 00:23:02.010
So for right now, I don't even want to deal with that at all.

322
00:23:02.010 --> 00:23:07.470
So I'm going to let that exception just jump onto the signature itself for now.

323
00:23:08.280 --> 00:23:13.080
Might do something with it later, but for right now, I'm just going to add it there and let's see

324
00:23:13.080 --> 00:23:13.170
it.

325
00:23:13.230 --> 00:23:17.520
OK, and so now I'm getting another red squiggly, which is just telling me that the saved method that

326
00:23:17.520 --> 00:23:23.670
I started to write on here doesn't actually know how to accept these data types because I wasn't done

327
00:23:23.850 --> 00:23:25.020
defining the saved method.

328
00:23:25.020 --> 00:23:27.390
So now I will let Java fix that.

329
00:23:27.390 --> 00:23:35.340
So I will just do an option return and I will tell it to change the signature of the saved method like

330
00:23:35.340 --> 00:23:39.690
so and so then if I jump back on to this method.

331
00:23:39.720 --> 00:23:45.810
So now we've got a saved method that accepts a string for the original file name and an input stream

332
00:23:45.810 --> 00:23:47.910
itself, and that is looking pretty good.

333
00:23:48.090 --> 00:23:48.330
All right.

334
00:23:48.340 --> 00:23:53.280
So now let's go ahead and just flesh this out really quickly so that we can be done with this lesson

335
00:23:53.280 --> 00:23:55.650
because I know I'm having to explain a lot of things.

336
00:23:56.070 --> 00:24:04.050
So what we can do now is we need to save this input stream as a file on the file system.

337
00:24:04.050 --> 00:24:08.760
So the first thing we'll want to do, perhaps, is to decide where on our file system.

338
00:24:08.760 --> 00:24:10.230
We want this thing to go.

339
00:24:10.380 --> 00:24:17.340
And what I'm going to do actually is is I'm going to make that a variable that can be configured each

340
00:24:17.340 --> 00:24:19.500
time we run the program, essentially.

341
00:24:19.500 --> 00:24:24.870
So where I want to store this file in my version of this program won't be the same places where you

342
00:24:24.900 --> 00:24:27.090
may want to store it on your computer, OK?

343
00:24:27.660 --> 00:24:33.150
So I'm going to make a variable that will represent that storage location, so I'm going to make it

344
00:24:33.270 --> 00:24:35.190
a private string.

345
00:24:35.580 --> 00:24:46.650
And I will call it storage folder, and I'm going to use a cool little feature of spring where I can

346
00:24:46.650 --> 00:24:53.490
have spring inject a value that comes from the environment of the computer, OK?

347
00:24:53.760 --> 00:25:01.470
And if any of you know Linux at all, then you might be familiar with the concept of a pass and exporting

348
00:25:01.470 --> 00:25:05.130
a path or actually paths even exists in windows.

349
00:25:05.220 --> 00:25:05.550
Right?

350
00:25:05.790 --> 00:25:08.800
And there's even a path environment variable, even in windows.

351
00:25:08.830 --> 00:25:09.120
OK.

352
00:25:09.270 --> 00:25:17.340
So what I want to do here is I want to have spring find an environment variable that I will define outside

353
00:25:17.340 --> 00:25:22.680
of this program as the location where files should be stored for this program.

354
00:25:22.680 --> 00:25:27.990
OK, and then Spring will find out what that folder is called and then inject the name in that folder

355
00:25:27.990 --> 00:25:29.640
into this variable.

356
00:25:29.700 --> 00:25:31.170
OK, that's what I'm going to do.

357
00:25:31.350 --> 00:25:38.820
So the way I can do that is by using an annotation of spring called at value and then quotes and then

358
00:25:38.820 --> 00:25:40.740
a dollar sign and then two curly braces.

359
00:25:40.750 --> 00:25:47.010
So this is a very common way of using kind of like variables and things that bind to stuff.

360
00:25:47.040 --> 00:25:47.400
OK.

361
00:25:47.940 --> 00:25:53.100
And I will name this variable storage underscore folder.

362
00:25:53.670 --> 00:26:01.380
And so what I am saying to spring is, Hey, spring, I want you to find an environment variable called

363
00:26:01.410 --> 00:26:02.250
storage folder.

364
00:26:02.250 --> 00:26:06.840
Now, many of you may not know what I mean when I say environment variable, so I will explain that

365
00:26:06.840 --> 00:26:07.710
a little bit later.

366
00:26:07.710 --> 00:26:12.120
OK, but it's going to find something called an environment variable.

367
00:26:12.120 --> 00:26:18.600
That's just the variable that I can define outside of my program here outside of this entire program.

368
00:26:18.750 --> 00:26:25.200
It's a variable that will exist within the scope of my whole entire computer, not just within this

369
00:26:25.200 --> 00:26:25.800
program.

370
00:26:26.190 --> 00:26:32.100
And as it's starting up, it will look for an environment variable called storage folder and if it finds.

371
00:26:32.180 --> 00:26:38.720
One, it will take whatever value I have bound to that variable, and it will inject that value down

372
00:26:38.720 --> 00:26:39.050
here.

373
00:26:39.140 --> 00:26:45.440
Now this is an extremely common technique again, particularly for applications that are being deployed

374
00:26:45.440 --> 00:26:48.170
to environments like Docker.

375
00:26:48.210 --> 00:26:55.490
OK, so using environment variables to configure how your application will work is probably like the

376
00:26:55.490 --> 00:26:59.370
most common pattern you'll see when dealing with Docker.

377
00:26:59.600 --> 00:27:03.200
All right, so that's how we will determine the folder.

378
00:27:03.590 --> 00:27:12.950
And so then what we can do is we can create a path, footpath, a path starting with that folder and

379
00:27:12.950 --> 00:27:14.180
let me import that.

380
00:27:14.720 --> 00:27:22.610
So we'll create a path starting with that folder storage folder, and then we will tack on the original

381
00:27:22.610 --> 00:27:23.510
file name.

382
00:27:24.200 --> 00:27:31.130
So if you're on windows, for example, and your storage folder is C colon backslash downloads or uploads

383
00:27:31.130 --> 00:27:38.100
or something uploads second backslash uploads and then the uploaded file name is called Cat, that jpg.

384
00:27:38.510 --> 00:27:47.360
So then doing this path of and sticking this on here would say see colon backslash uploads slash cat

385
00:27:47.360 --> 00:27:48.200
that jpg.

386
00:27:48.230 --> 00:27:50.600
So this is just going to kind of combine all of that together.

387
00:27:50.630 --> 00:27:53.960
It's a way to concatenate paths effectively, OK?

388
00:27:54.350 --> 00:27:55.790
So there's that part.

389
00:27:56.000 --> 00:28:02.090
And then just in case there's any weird symbols and things that shouldn't exist in this original file

390
00:28:02.090 --> 00:28:06.040
name because this is coming from like the uploaded data from the browser.

391
00:28:06.050 --> 00:28:13.010
So just in case there's any weirdness there, we can tell this path object to kind of clean up any weirdness

392
00:28:13.010 --> 00:28:16.740
in the file name, and we'll do that by calling Normalize.

393
00:28:16.760 --> 00:28:17.550
Like So.

394
00:28:17.570 --> 00:28:17.960
OK.

395
00:28:18.170 --> 00:28:25.190
And so now we will have this path, and I'm going to capture that path and just call it file path,

396
00:28:25.190 --> 00:28:25.940
I suppose.

397
00:28:26.840 --> 00:28:27.270
All right.

398
00:28:27.290 --> 00:28:28.800
So that's step one.

399
00:28:29.360 --> 00:28:36.530
And then all we need to do is really just kind of save this input stream to this path.

400
00:28:36.770 --> 00:28:42.290
And there's a super nice, convenient way to do that by calling files dot copy.

401
00:28:42.410 --> 00:28:48.200
And so there's a version of it that can take an input stream and then a target path, and then it can

402
00:28:48.200 --> 00:28:52.040
take some optional inputs as well that I don't think we even need to care about right now.

403
00:28:52.400 --> 00:29:01.280
So if we call a copy and let me import that and then pass in our input stream and then our file path.

404
00:29:01.760 --> 00:29:05.240
Like so now this copy method throws an exception.

405
00:29:05.570 --> 00:29:08.330
So we will want to handle that exception now.

406
00:29:08.540 --> 00:29:15.530
And so what I'm inclined to do here is actually just select all of that and then wrap this in a try

407
00:29:15.560 --> 00:29:16.280
catch.

408
00:29:17.090 --> 00:29:19.520
So a number six, like so.

409
00:29:19.640 --> 00:29:20.660
And keep going now.

410
00:29:20.690 --> 00:29:22.970
I want to do something with this a little bit later.

411
00:29:22.970 --> 00:29:24.980
But for right now, let's just finish this up.

412
00:29:24.990 --> 00:29:25.880
We're almost done.

413
00:29:26.150 --> 00:29:32.300
So we're going to copy that input stream to this file so that right there we'll write the file to the

414
00:29:32.300 --> 00:29:33.290
file system.

415
00:29:33.290 --> 00:29:37.650
And that is all we need to get the basic functionality working.

416
00:29:37.670 --> 00:29:38.090
OK.

417
00:29:38.630 --> 00:29:38.900
OK.

418
00:29:38.930 --> 00:29:44.840
And then let me explain a little bit more now about this mechanism here and environment variables,

419
00:29:44.840 --> 00:29:49.850
and I think I have a relatively concise way to explain environment variables.

420
00:29:50.300 --> 00:29:56.000
So in order to understand environment variables, you must first understand what is the meaning of environment.

421
00:29:56.450 --> 00:30:02.360
The most basic definition for an environment in relation to application development is it's the computer

422
00:30:02.360 --> 00:30:04.130
that your application is running on.

423
00:30:04.460 --> 00:30:10.370
Now, in this case, where I'm actually going to be starting up the application from within the ADP,

424
00:30:10.610 --> 00:30:16.630
you could possibly say that the Eddy is the environment for the application as well.

425
00:30:16.640 --> 00:30:17.600
You could say that.

426
00:30:17.930 --> 00:30:23.200
But usually when we talk about environment, variables were mostly just referring to the computer.

427
00:30:23.210 --> 00:30:28.510
OK, so environment mostly means computer for the sake of this conversation.

428
00:30:28.520 --> 00:30:36.800
So environment variables are really a nice mechanism to allow a computer to pass information into the

429
00:30:36.800 --> 00:30:42.440
application without the users of the application needing to pass that information in.

430
00:30:42.650 --> 00:30:48.860
And the information will usually be information that is somewhat specific to the computer that the program

431
00:30:48.860 --> 00:30:50.780
or application is running on.

432
00:30:50.810 --> 00:30:51.260
OK.

433
00:30:51.650 --> 00:30:58.490
So in in our case, this makes perfect sense because I am running this application on my computer,

434
00:30:58.580 --> 00:31:05.780
which is a Mac laptop, and I'm going to be storing my uploaded folders into a particular folder in

435
00:31:05.780 --> 00:31:08.720
my home directory on my Mac.

436
00:31:08.810 --> 00:31:11.330
OK, so that's going to have a very specific path.

437
00:31:11.600 --> 00:31:19.100
But if I were to pick up this application and deploy it on to a Windows computer, the path that I want

438
00:31:19.100 --> 00:31:23.560
to use would have to be different because windows paths are different, right?

439
00:31:23.570 --> 00:31:31.370
So on this Mac, I might use forward slash user slash terry slash uploads or something like that on

440
00:31:31.400 --> 00:31:32.090
a windows.

441
00:31:32.180 --> 00:31:34.730
Computer, I might use something a little different.

442
00:31:34.760 --> 00:31:36.530
See, colon backslash.

443
00:31:36.950 --> 00:31:42.290
I'm not even sure that I remember offhand where home directories are stored on modern versions of Windows,

444
00:31:42.290 --> 00:31:43.640
but it would be a little different.

445
00:31:43.820 --> 00:31:49.550
And so those are two different environments, which require two different paths for specifying where

446
00:31:49.550 --> 00:31:50.630
to upload things.

447
00:31:50.660 --> 00:31:58.490
OK, so it would be inappropriate to ask the users of my web application to specify where on the server

448
00:31:58.760 --> 00:32:04.700
that is running the application, which they presumably did not right, where they want the file to

449
00:32:04.700 --> 00:32:05.260
be stored.

450
00:32:05.270 --> 00:32:07.610
That would that would not be appropriate at all.

451
00:32:07.880 --> 00:32:13.760
That would be something that should be configured by the person who maintains the server may maybe working

452
00:32:13.760 --> 00:32:16.550
along with the person who wrote the software.

453
00:32:16.580 --> 00:32:22.460
OK, so that's a variable that may need to be changed from one computer to the next.

454
00:32:22.610 --> 00:32:25.370
So let's jump back over to the controller.

455
00:32:25.490 --> 00:32:31.910
OK, so now that we've got all of this going, the only other thing I think we need to do is to define

456
00:32:31.910 --> 00:32:33.410
that environment variable.

457
00:32:33.410 --> 00:32:35.420
So you're probably wondering, how do we do that?

458
00:32:35.600 --> 00:32:37.820
There's a really easy way for us to do this.

459
00:32:38.030 --> 00:32:38.350
All right.

460
00:32:38.360 --> 00:32:45.740
So what I'm going to do now is first, let me get out of presentation mode for a minute here, and then

461
00:32:45.740 --> 00:32:52.370
I'm going to do a control option are which or an alt shift F10 for Windows and Linux.

462
00:32:52.520 --> 00:32:54.710
And then I'm going to choose edit configuration.

463
00:32:54.710 --> 00:32:58.670
So this is where I can edit how this spring application starts.

464
00:32:59.060 --> 00:33:04.970
And I've got this section here called environment variables, where I can define environment variables

465
00:33:05.030 --> 00:33:05.780
really easily.

466
00:33:05.810 --> 00:33:09.620
Now, this isn't the only way you can define an environment variable on a computer.

467
00:33:09.890 --> 00:33:13.290
This is just an easy way that intelligence allows me to do that.

468
00:33:13.550 --> 00:33:17.630
For applications that I am running within Intel.

469
00:33:18.170 --> 00:33:23.750
But in real life now, when you're deploying this application to a server or something, there are server

470
00:33:23.750 --> 00:33:26.540
centric ways to do the equivalent of this.

471
00:33:26.990 --> 00:33:27.230
All right.

472
00:33:27.230 --> 00:33:32.480
So anyway, I'll click on this little button right here and then I can click on the plus.

473
00:33:32.690 --> 00:33:37.340
And now I can define that environment variable that I just reference.

474
00:33:37.350 --> 00:33:40.580
So I think I call it storage underscore folder.

475
00:33:40.610 --> 00:33:43.160
Notice that I'm using all uppercase, all caps.

476
00:33:43.160 --> 00:33:48.890
That is a common convention and using the underscore, just like when we're creating constants in Java.

477
00:33:49.370 --> 00:33:58.400
And then I think for the value I'm going to on my computer, I'm going to bind this value to users.

478
00:33:59.540 --> 00:34:06.700
Terry uploads Now, don't just blindly copy that, OK, that's an actual folder on my computer.

479
00:34:06.710 --> 00:34:11.780
So you go find a folder on your computer where you want your uploaded files to go.

480
00:34:11.900 --> 00:34:14.550
That's where I'm going to put them on my computer, though.

481
00:34:14.570 --> 00:34:19.460
OK, and then I'm going to click OK and apply.

482
00:34:21.110 --> 00:34:27.020
And then I can close this, all right, and now I am likely going to need to restart because of that

483
00:34:27.020 --> 00:34:29.330
environment, very like an actual restart.

484
00:34:29.390 --> 00:34:35.420
OK, so if I come up here, I can click on that little restart button there and I'm going to go ahead

485
00:34:35.420 --> 00:34:36.230
and do that.

486
00:34:37.280 --> 00:34:38.450
Now I'm going to warn you.

487
00:34:39.380 --> 00:34:43.940
Yeah, I was just about to say, I'm going to warn you, if spring doesn't think that environment variable

488
00:34:43.940 --> 00:34:47.240
is defined and when you restart spring, it's going to complain immediately.

489
00:34:47.240 --> 00:34:48.620
And that's exactly what I'm getting here.

490
00:34:48.860 --> 00:34:52.340
Could not resolve placeholder storage underscore folder.

491
00:34:53.210 --> 00:34:53.880
Oh, OK.

492
00:34:53.900 --> 00:34:55.760
And I know what the problem is now.

493
00:34:55.910 --> 00:34:58.330
I need to start this up.

494
00:34:59.370 --> 00:35:00.750
From within here.

495
00:35:01.140 --> 00:35:07.230
The first time, at least, so now that I've created this new change here, I think I need to actually

496
00:35:07.230 --> 00:35:08.370
click run from here.

497
00:35:08.400 --> 00:35:09.030
Let's see.

498
00:35:09.750 --> 00:35:10.560
Yeah, there we go.

499
00:35:10.920 --> 00:35:17.730
OK, so I think now subsequently, if I were to stop this and start it up again, it would be fine because

500
00:35:17.730 --> 00:35:19.780
now it's kind of like a new configuration.

501
00:35:19.800 --> 00:35:22.370
In fact, it is a new configuration, essentially.

502
00:35:22.880 --> 00:35:23.130
Yeah.

503
00:35:23.170 --> 00:35:23.730
So that started.

504
00:35:23.850 --> 00:35:26.010
In fact, here I'll just test that out real quick.

505
00:35:26.010 --> 00:35:30.090
I will stop this and then I will start it up again.

506
00:35:30.810 --> 00:35:31.540
Yeah, there we go.

507
00:35:31.560 --> 00:35:33.330
So now it starts up happily.

508
00:35:33.690 --> 00:35:35.700
OK, let's see.

509
00:35:35.700 --> 00:35:45.570
Let's put this back where it was, and let's come over here and let's reload.

510
00:35:47.300 --> 00:35:48.230
Everything.

511
00:35:49.570 --> 00:35:54.520
And let me open up my command line console now.

512
00:35:55.390 --> 00:35:55.730
All right.

513
00:35:55.750 --> 00:35:57.040
So I am.

514
00:35:57.040 --> 00:35:57.850
Where am I here?

515
00:35:57.880 --> 00:36:02.800
I'm going to open up another tab and I'm going to go into that folder that I just created.

516
00:36:07.080 --> 00:36:12.270
Now, I happen to have a few other previous files in here from some other tests that I was doing before,

517
00:36:12.630 --> 00:36:15.630
but I'm in my uploads folder and that is one more thing to consider now.

518
00:36:15.750 --> 00:36:21.600
You will likely have to create the folder that you are referring to.

519
00:36:21.870 --> 00:36:27.330
Make sure that that folder actually exists before you try to use this web application to upload something.

520
00:36:27.330 --> 00:36:29.280
Otherwise it will likely blow up.

521
00:36:29.670 --> 00:36:33.540
All right, so then let's go ahead and try uploading another file.

522
00:36:34.530 --> 00:36:39.990
And now we should see that if it's successful, we'll see that files show up in our uploads folder here.

523
00:36:39.990 --> 00:36:41.400
So let's see.

524
00:36:41.400 --> 00:36:47.070
I will again start by picking a person and let's do Bin Parker.

525
00:36:47.490 --> 00:36:47.760
All right.

526
00:36:47.760 --> 00:36:51.840
So there's been Parker, and then we'll add a record for him.

527
00:36:51.840 --> 00:37:03.970
Then Parker and I don't know for four 1984 and B Parker at photos dot com and a salary of 65000.

528
00:37:03.970 --> 00:37:05.460
And let's see what we get here.

529
00:37:08.650 --> 00:37:16.510
Okay, so there's the record there, so we didn't run into any apparent errors, and now here is the

530
00:37:16.510 --> 00:37:17.710
moment of truth.

531
00:37:18.010 --> 00:37:19.780
What will we have over here?

532
00:37:21.910 --> 00:37:24.460
Hey, look at that, there's been Parker.

533
00:37:25.740 --> 00:37:26.250
OK.

534
00:37:26.820 --> 00:37:34.350
So, yeah, so our uploading is now working, and we were able to store this file onto our local file

535
00:37:34.350 --> 00:37:37.710
system, so all of that is working as expected, OK?

536
00:37:38.010 --> 00:37:44.730
So now in the next lesson, let us continue on with fleshing out more of the crud operations for the

537
00:37:44.730 --> 00:37:46.020
file storage.

538
00:37:46.050 --> 00:37:49.610
OK, so we've got it for the person repository now.

539
00:37:49.620 --> 00:37:52.100
Let's do it for the file storage itself, right?

540
00:37:52.110 --> 00:37:57.630
So when we delete a record from here, we should not only delete the person record out of the database,

541
00:37:57.780 --> 00:38:02.750
we will now also have to delete the file from the file system, right?

542
00:38:02.760 --> 00:38:08.400
So we've got to kind of maintain what we do in the database with what we do on the file system.

543
00:38:08.400 --> 00:38:11.880
So we'll address more of those kinds of use cases in the next lessons.

544
00:38:12.060 --> 00:38:12.990
So I'll see you there.
