WEBVTT
1
00:00:00.870 --> 00:00:01.290
All right.

2
00:00:01.680 --> 00:00:07.470
Let's see what else can we do with the list interface, what other methods are on it?

3
00:00:07.920 --> 00:00:17.310
So let's jump down here and we'll just invoke our collection and do a period and then a control space

4
00:00:17.520 --> 00:00:19.860
and then we can see all the other methods that are here.

5
00:00:19.860 --> 00:00:22.570
So we've already used add.

6
00:00:22.650 --> 00:00:24.120
That's pretty straightforward.

7
00:00:24.780 --> 00:00:30.000
But there's another overloaded version of the add method that does almost the same thing, except that

8
00:00:30.000 --> 00:00:36.450
we can also specify where in the list the new object should be added.

9
00:00:37.080 --> 00:00:37.830
So I don't know.

10
00:00:37.860 --> 00:00:40.770
Let's let's try that out real quick and see how it works.

11
00:00:41.130 --> 00:00:42.510
So we'll do an ad.

12
00:00:42.510 --> 00:00:51.360
And then if we look at this list here, let's just add we'll just had someone to the beginning of the

13
00:00:51.360 --> 00:00:53.040
list, OK, and we'll make a new person.

14
00:00:53.040 --> 00:00:54.650
In fact, let's see.

15
00:00:54.660 --> 00:00:56.340
So we'll say zero, right?

16
00:00:56.370 --> 00:00:58.590
That'll be the first location.

17
00:00:58.890 --> 00:01:05.670
And so what's going to happen here is that all of these other people will be shifted down or to the

18
00:01:05.670 --> 00:01:05.960
right.

19
00:01:05.970 --> 00:01:08.640
However, you want to think of your your list there, right?

20
00:01:08.640 --> 00:01:15.900
So they'll be shifted down by one to make room for a new zero with employee.

21
00:01:16.080 --> 00:01:21.030
OK, so zero comma and then I can now I can do this in line.

22
00:01:21.030 --> 00:01:25.410
Like this new let's see programmer, let's say.

23
00:01:29.550 --> 00:01:36.120
And then I could pass in some text or something, I'm not going to complete this, but you get the idea

24
00:01:36.120 --> 00:01:36.510
right?

25
00:01:38.100 --> 00:01:44.250
And so that would result in a new programmer being added to the to the top of this list or to the first

26
00:01:45.030 --> 00:01:49.740
slot in this list and all of the subsequent people would be shifted down.

27
00:01:51.600 --> 00:01:51.870
All right.

28
00:01:51.880 --> 00:01:54.240
So that's the alternative to add.

29
00:01:55.140 --> 00:01:55.560
Let's see.

30
00:01:55.560 --> 00:01:56.700
What else can we do?

31
00:02:01.430 --> 00:02:09.920
Let's see, we've already seen a little bit of contains, which we used right here on Line 68 to determine

32
00:02:09.920 --> 00:02:17.180
whether or not the list of names to be removed contained any of these first names.

33
00:02:17.630 --> 00:02:25.550
Now we will revisit the contains method in its own separate lesson because there are some additional

34
00:02:25.550 --> 00:02:30.590
things that you should know if you ever wanted to use it in a little bit more of a sophisticated way

35
00:02:30.590 --> 00:02:33.890
than what we have currently done by just comparing strings.

36
00:02:34.070 --> 00:02:36.380
So I'm not going to go into any more detail on that here.

37
00:02:36.530 --> 00:02:37.880
It'll get its own lesson.

38
00:02:38.300 --> 00:02:39.960
All right, let's see at all.

39
00:02:39.960 --> 00:02:41.210
It can be pretty convenient.

40
00:02:41.240 --> 00:02:43.220
Let's take a quick look at that.

41
00:02:45.020 --> 00:02:50.540
I think what we'll do here, I'm going to create a new list.

42
00:02:52.020 --> 00:02:53.640
Of strings.

43
00:02:55.290 --> 00:03:01.440
New strings equals new, and I'm going to start off with it being empty.

44
00:03:03.880 --> 00:03:09.880
And then what I will do is new strings, dot add all.

45
00:03:10.660 --> 00:03:15.980
And now what I can do here, actually, I put that in the wrong place.

46
00:03:16.000 --> 00:03:18.220
Let me move it down here.

47
00:03:18.700 --> 00:03:19.270
Here we go.

48
00:03:23.260 --> 00:03:23.860
There we go.

49
00:03:24.370 --> 00:03:36.370
OK, now what I can do is I can add our undesirables list to this list, to this new list using at all.

50
00:03:36.400 --> 00:03:43.070
OK, so whereas add method allows us to add one new object at a time.

51
00:03:43.150 --> 00:03:51.640
Add all allows us to add a whole entire collection to an already existing list altogether, right?

52
00:03:51.940 --> 00:03:53.950
So let's see.

53
00:03:53.980 --> 00:04:03.070
So I can just reference the undesirables list like so and then if I were to do something like new strings

54
00:04:03.070 --> 00:04:10.570
that size and now if I were to do new strings that size, it would have the same size as our undesirables

55
00:04:10.570 --> 00:04:11.860
list, which would be three.

56
00:04:12.070 --> 00:04:14.830
OK, so that would just add all of these to this.

57
00:04:15.010 --> 00:04:18.610
Sometimes that comes up in programming where you'll need to create a new list.

58
00:04:18.880 --> 00:04:24.100
Maybe that new list already had some items in it and then you have some other list from somewhere else

59
00:04:24.100 --> 00:04:27.370
with items in it and you want to basically put them all together.

60
00:04:27.940 --> 00:04:33.160
So add all can be used to do that kind of thing in a non-destructive way.

61
00:04:33.700 --> 00:04:43.930
By the way, let me also mention this while I'm at it on this list sort of method here, where we were

62
00:04:43.930 --> 00:04:48.820
conveniently able to create a new list of three items is great.

63
00:04:49.000 --> 00:04:57.140
However, one thing that I failed to point out is the resulting list that gets created when we use lists

64
00:04:57.140 --> 00:05:05.230
sort of is what we call unmodified beable, which means that once this guy has been created, we can't

65
00:05:05.230 --> 00:05:12.010
add anything else to it or we can't delete anything from it, either we can't add or remove any any

66
00:05:12.010 --> 00:05:14.400
further items to or from this list.

67
00:05:14.410 --> 00:05:15.820
It's on modifiable.

68
00:05:15.970 --> 00:05:22.360
And that's just the pattern of the of methods for set for collections.

69
00:05:22.540 --> 00:05:28.120
So you'll we'll learn that set also has an of a method on it.

70
00:05:28.450 --> 00:05:35.920
So one of the reasons for this is that it is generally just considered dangerous or error prone to have

71
00:05:36.310 --> 00:05:42.460
objects, including collections that can be modified after they've been initialized.

72
00:05:42.820 --> 00:05:51.340
And lately, Java has been adopting more and more functional programming paradigms and using unmodified

73
00:05:51.340 --> 00:05:55.420
liable objects is a big part of functional programming.

74
00:05:55.600 --> 00:06:00.340
And so we're seeing more and more of these kinds of patterns where you can create a lot of things real

75
00:06:00.340 --> 00:06:02.500
quick, but they can't be modified.

76
00:06:02.800 --> 00:06:09.520
So if you did want to be able to create this list as we're doing here and then modify it later, one

77
00:06:09.520 --> 00:06:19.240
way you could do that would be to create a new modifiable list, as we're doing here online 51, and

78
00:06:19.240 --> 00:06:25.660
then just add all of the items from the UN modifiable list into the modifiable list.

79
00:06:25.660 --> 00:06:27.640
And now you have something that you can modify.

80
00:06:27.670 --> 00:06:30.820
OK, so that's a that's one way you can do that.

81
00:06:31.060 --> 00:06:34.750
You also could do something like this.

82
00:06:34.750 --> 00:06:43.180
You could wrap this inside of an array list, a regular array list like so.

83
00:06:43.630 --> 00:06:47.050
And now what comes out of here is modifiable.

84
00:06:47.140 --> 00:06:48.850
OK, so you could do that as well.

85
00:06:49.660 --> 00:06:58.630
So these collection classes all have constructors that can be initialized with another collection.

86
00:06:58.900 --> 00:06:59.380
OK.

87
00:07:00.160 --> 00:07:02.620
And then if you do it this way, it's modifiable.

88
00:07:03.910 --> 00:07:07.840
So these are just like, you know, little knickknacks that are good to know.

89
00:07:08.320 --> 00:07:10.330
OK, so I'm going to delete that.

90
00:07:13.720 --> 00:07:14.170
OK.

91
00:07:14.200 --> 00:07:15.760
Let's see what else we can do.

92
00:07:16.270 --> 00:07:16.810
Clear.

93
00:07:17.140 --> 00:07:21.590
That just deletes that just clears out the collection or the list.

94
00:07:22.420 --> 00:07:24.610
So anything that was in there will just be gone.

95
00:07:24.790 --> 00:07:25.270
OK.

96
00:07:25.540 --> 00:07:26.320
All in one.

97
00:07:26.470 --> 00:07:31.480
So rather than doing remove one at a time, if you just want to clear everything out, you can just

98
00:07:31.480 --> 00:07:32.140
call clear.

99
00:07:34.650 --> 00:07:40.470
Contains all is also kind of a special case will look at that in its own separate lesson when we talk

100
00:07:40.470 --> 00:07:41.460
about contains.

101
00:07:43.900 --> 00:07:49.510
I'm skipping over equals, that's just the regular equals method that is inherited by all objects.

102
00:07:50.440 --> 00:07:57.640
We've already seen get where we pass in an index and then that gives us that particular index of the

103
00:07:57.640 --> 00:07:59.140
object in the list.

104
00:07:59.710 --> 00:08:05.290
Hash code is an inherited method from the superclass of object will skip over that for now.

105
00:08:06.460 --> 00:08:07.390
Index of.

106
00:08:07.420 --> 00:08:08.980
Now that's a that's a nice one.

107
00:08:08.980 --> 00:08:11.620
So let me show you how index of wood work.

108
00:08:11.920 --> 00:08:25.960
What I will do is first, we'll get we'll get the third object in the list, OK, and I'll save it and

109
00:08:25.960 --> 00:08:27.550
I will name it third.

110
00:08:27.730 --> 00:08:28.150
OK.

111
00:08:28.180 --> 00:08:31.840
So this would get the third object in the list because we're zero based.

112
00:08:32.260 --> 00:08:42.700
But then what I could do is employees dot index of and now I can pass in this object called third.

113
00:08:42.700 --> 00:08:51.250
And this index method will return an integer, as you can see here, and it'll just return the number

114
00:08:51.460 --> 00:08:51.910
two.

115
00:08:52.480 --> 00:08:55.480
OK, so it's just the opposite of doing a get.

116
00:08:56.050 --> 00:09:04.450
OK, now there are a couple of things to be aware of that I will try to remember to mention when we

117
00:09:04.450 --> 00:09:08.410
learn a little bit more about containers and some of the a few other methods.

118
00:09:09.040 --> 00:09:12.940
But this approach that I've just shown here would work perfectly well.

119
00:09:12.970 --> 00:09:15.040
So you just get the number to back out.

120
00:09:16.370 --> 00:09:17.060
All right.

121
00:09:17.300 --> 00:09:25.850
So that index of let's see what else is empty.

122
00:09:26.240 --> 00:09:33.680
So if we clear everything out and then we call is empty, it just returns a boolean true or false to

123
00:09:33.680 --> 00:09:35.870
tell us if the collection is empty or not.

124
00:09:36.290 --> 00:09:37.520
So pretty straightforward.

125
00:09:38.210 --> 00:09:43.970
OK, and then very similar to the index of method, we also have a last index of.

126
00:09:44.150 --> 00:09:45.560
Now this is interesting.

127
00:09:45.860 --> 00:09:47.000
It's pretty straightforward.

128
00:09:47.270 --> 00:09:55.400
The reason that there are two index of methods, though, is because a list can hold duplicate objects.

129
00:09:55.440 --> 00:10:00.320
OK, so you could have the same object in a list multiple times.

130
00:10:00.410 --> 00:10:06.410
In fact, every single element in a list could be the same object duplicated multiple times.

131
00:10:06.440 --> 00:10:06.860
OK.

132
00:10:07.670 --> 00:10:08.750
Lists allow that.

133
00:10:08.870 --> 00:10:15.500
Now there's at least one other type of collection, which is a set which does not allow for duplicates.

134
00:10:15.800 --> 00:10:23.630
It will just ignore duplicate objects if you tried to add them to it, but lists do not ignore them.

135
00:10:23.640 --> 00:10:25.160
Lists allow for duplicates.

136
00:10:25.160 --> 00:10:30.920
So if you have the possibility for duplicates, you have the possibility that when you ask a list,

137
00:10:31.250 --> 00:10:33.710
what is the index of an object?

138
00:10:34.100 --> 00:10:38.030
You may want to know what is the index of the first time that object is in the list?

139
00:10:38.210 --> 00:10:43.930
Or what is the index of the last time that same object is in the list, right?

140
00:10:43.940 --> 00:10:46.850
The last time it shows up in that list?

141
00:10:47.030 --> 00:10:50.240
And that's what last index of is for.

142
00:10:50.300 --> 00:10:54.740
OK, I will skip over the iterator methods for now.

143
00:10:55.190 --> 00:10:59.300
We've seen both forms of the removed method remove.

144
00:10:59.300 --> 00:11:05.660
All is very similar to to remove with an object, except it takes an entire collection.

145
00:11:05.870 --> 00:11:12.830
And so every item that is in the incoming collection, if that item exists in the list, it will be

146
00:11:12.830 --> 00:11:14.300
removed from the list.

147
00:11:14.420 --> 00:11:14.870
OK.

148
00:11:15.410 --> 00:11:20.450
And then replace all is a special case that we will look at at a later time.

149
00:11:21.470 --> 00:11:23.750
Retain all is kind of interesting.

150
00:11:24.320 --> 00:11:32.000
So let's say that we have a list containing objects A, B, C, D, E and F, and then we have another

151
00:11:32.000 --> 00:11:41.120
list containing objects A, B and C, if we call retain all on the first list and we pass in the second

152
00:11:41.120 --> 00:11:44.480
list as the input to the retain all.

153
00:11:44.840 --> 00:11:52.820
What will happen is only the intersection of these two lists will be retained in the first list.

154
00:11:52.970 --> 00:12:00.440
That is to say where we had A, B, C, D, E and F in the first list and a B and C in the second.

155
00:12:00.680 --> 00:12:05.840
When you're done with all of this, you'll just have a, B and C in the first list as well.

156
00:12:06.200 --> 00:12:09.680
Everything other than A, B and C will just be let go of.

157
00:12:09.710 --> 00:12:10.160
OK.

158
00:12:10.640 --> 00:12:19.220
So it gives you the it gives you the intersection of those two lists remaining in the first list.

159
00:12:19.850 --> 00:12:20.360
OK.

160
00:12:20.820 --> 00:12:28.100
Set allows us to replace an item or an element in a list.

161
00:12:28.520 --> 00:12:39.830
So if you used to have a B and C in the list and A was at index zero, you could replace A with D,

162
00:12:39.890 --> 00:12:40.760
for example.

163
00:12:41.030 --> 00:12:45.260
OK, so let's see what that kind of looks like.

164
00:12:47.230 --> 00:12:57.580
So currently, we have the first Fred Flintstone in Element Zero or at index zero in the list.

165
00:12:57.970 --> 00:13:01.600
Let's say that we wanted to have Betty rubble.

166
00:13:03.340 --> 00:13:08.890
In that place, instead, we just wanted to erase Fred Flintstone and replace him with Betty rubble.

167
00:13:09.130 --> 00:13:18.010
So one way that we could do that would be to set index zero because that's the first one, right?

168
00:13:19.880 --> 00:13:20.330
And.

169
00:13:22.540 --> 00:13:24.580
We could create a new employee.

170
00:13:27.140 --> 00:13:28.160
Create employee.

171
00:13:30.380 --> 00:13:37.310
And then just pass in the tax form of that, that will result in creating an actual object of type employee

172
00:13:37.310 --> 00:13:38.540
that is a CEO.

173
00:13:38.780 --> 00:13:45.920
And so the resulting person would replace this Fred Flintstone.

174
00:13:46.280 --> 00:13:46.670
OK?

175
00:13:46.700 --> 00:13:47.420
Does that make sense?

176
00:13:47.420 --> 00:13:55.100
So that just lets you replace an element in the list arbitrarily, depending on the index.

177
00:13:55.850 --> 00:14:03.620
OK, sort is actually a really cool method, and I'm going to save that for a later lesson as well,

178
00:14:03.860 --> 00:14:07.010
because we'll want to kind of dive into that very useful.

179
00:14:07.010 --> 00:14:08.720
It does what it sounds like it does.

180
00:14:08.720 --> 00:14:12.780
It allows us to sort the items in a collection.

181
00:14:13.190 --> 00:14:17.000
But there's a couple of things that we need to learn before we can dive into that.

182
00:14:18.230 --> 00:14:18.610
All right.

183
00:14:18.620 --> 00:14:22.760
So we'll come back to that one in another lesson, sub list is pretty cool.

184
00:14:23.240 --> 00:14:30.470
We supply it with a start and an end index of an existing list, and then it returns a smaller list,

185
00:14:30.470 --> 00:14:36.420
supposedly a sub list of the greater list that we started with.

186
00:14:36.440 --> 00:14:39.230
OK, so pretty straightforward, really.

187
00:14:39.440 --> 00:14:44.990
If we take a look at the Java doc for it, it says that it returns a view of the portion of the list

188
00:14:44.990 --> 00:14:47.990
between the specified from index inclusive.

189
00:14:48.170 --> 00:14:53.810
So this is the key thing here, inclusive for on the from and to index exclusive.

190
00:14:53.810 --> 00:14:58.790
So we see this pattern a lot whenever we're able to to pass in a range of things.

191
00:14:58.820 --> 00:15:07.490
Usually, the bottom or the beginning part of the range is inclusive and then the upper bounds is exclusive

192
00:15:07.490 --> 00:15:09.320
in a lot of these Java methods.

193
00:15:09.500 --> 00:15:13.490
So that's one thing that just kind of keep in mind, OK, so what does that mean?

194
00:15:14.240 --> 00:15:22.670
Basically, that means like if we were looking at this list here and we wanted zero, one and two,

195
00:15:23.120 --> 00:15:25.010
I'm talking about the indexes here.

196
00:15:25.130 --> 00:15:25.580
OK?

197
00:15:25.730 --> 00:15:26.930
Zero, one and two.

198
00:15:27.140 --> 00:15:32.270
Then we could get that sub list by passing in a zero and a three.

199
00:15:32.420 --> 00:15:32.960
OK.

200
00:15:33.290 --> 00:15:37.580
And that would give us zero one and two three would not be included.

201
00:15:37.760 --> 00:15:41.690
And so we could do that like this.

202
00:15:42.780 --> 00:15:44.700
Zero comma, three.

203
00:15:47.010 --> 00:15:52.200
So then this would result in a new list being returned.

204
00:15:54.390 --> 00:15:55.440
Subbed list.

205
00:15:55.560 --> 00:15:57.930
For example, we can call it whatever we want.

206
00:15:58.410 --> 00:15:58.850
OK.

207
00:16:00.730 --> 00:16:06.910
But that's how you would use the subleased method to give you a smaller subset of a pre-existing list.

208
00:16:08.660 --> 00:16:12.950
OK, and then we've got these two methods here to array.

209
00:16:13.220 --> 00:16:21.920
Now what this does is it basically just converts our list into an actual array and for the array list,

210
00:16:21.920 --> 00:16:26.060
that should be very trivial to do since internally it's using an array anyway.

211
00:16:26.120 --> 00:16:30.980
Actually, it's pretty trivial to do for both the linked list and the array list, but the array list

212
00:16:30.980 --> 00:16:37.370
may not have to do anything at all other than simply expose what's already inside of its own internal

213
00:16:37.370 --> 00:16:37.940
array.

214
00:16:38.690 --> 00:16:43.160
So as you see here, it returns back an object array.

215
00:16:43.460 --> 00:16:50.330
OK, now the difference between these two implementations is the specificity of the types.

216
00:16:50.600 --> 00:17:00.260
OK, so this first two array method just returns back a generic array of objects, and that's with a

217
00:17:00.260 --> 00:17:01.280
capital o.

218
00:17:01.400 --> 00:17:10.040
So as you will recall, all classes in Java ultimately extend from the super super class called object.

219
00:17:10.340 --> 00:17:19.310
And so you can always store any type of object, no matter what it is inside of a variable or an array

220
00:17:19.310 --> 00:17:21.670
of type object with capital.

221
00:17:22.250 --> 00:17:28.230
Now, that's not a safe thing to do, usually because it's nondescript, right?

222
00:17:28.250 --> 00:17:33.050
You don't get the benefits of of type checking and things of that sort.

223
00:17:33.260 --> 00:17:37.520
You're just putting it in a big giant grab bag of anything.

224
00:17:38.420 --> 00:17:43.760
It pretty much defeats much of the whole point of a statically typed language like Java.

225
00:17:43.940 --> 00:17:45.230
But you can do it.

226
00:17:45.470 --> 00:17:51.370
So this first method doesn't try to honor whatever the data types are.

227
00:17:51.380 --> 00:17:54.860
It just gives you back an array of objects.

228
00:17:55.460 --> 00:18:03.710
The second method, though, actually uses generics so that we can get back an array of the proper type.

229
00:18:03.920 --> 00:18:06.950
So let me show you what that would look like to do.

230
00:18:07.930 --> 00:18:14.470
So first, let me just show you, if we just use the basic two array method and then I capture that.

231
00:18:19.180 --> 00:18:22.300
Generic array, so you just get back.

232
00:18:23.340 --> 00:18:31.080
An array of objects, so not the best, not the best at all, you pretty much don't really want to use

233
00:18:31.080 --> 00:18:37.800
this unless you're working with a method that is that you didn't write that is expecting this as its

234
00:18:37.800 --> 00:18:39.030
input type.

235
00:18:39.240 --> 00:18:40.480
And then you have no choice.

236
00:18:40.510 --> 00:18:45.660
OK, so that's one reason and maybe the only reason I can think of why you should ever use this.

237
00:18:46.650 --> 00:18:48.330
But then the other version?

238
00:18:50.200 --> 00:18:58.180
So for the other version of two array, what it takes as an input is an actual array of whatever the

239
00:18:58.180 --> 00:19:00.250
data type is that we're caring about.

240
00:19:00.280 --> 00:19:00.670
OK.

241
00:19:00.850 --> 00:19:08.140
So basically what that means is we have to create an array of the data type where we're interested in.

242
00:19:08.140 --> 00:19:09.520
So let me show you what that would look like.

243
00:19:09.520 --> 00:19:12.670
So we'll call this method and then to create an array.

244
00:19:12.970 --> 00:19:19.870
You use the new operator and then you refer to the data type, which in this case would be I employee

245
00:19:21.640 --> 00:19:22.390
like so.

246
00:19:23.200 --> 00:19:25.090
And then you use the square brackets.

247
00:19:25.660 --> 00:19:32.010
And then we can initialize it so we don't actually need to store anything in this array.

248
00:19:32.020 --> 00:19:34.510
It's just like a template, if you will.

249
00:19:34.660 --> 00:19:38.920
And so we can initialize it to size zero, like so OK.

250
00:19:39.730 --> 00:19:41.290
And then semicolon.

251
00:19:43.120 --> 00:19:44.680
And now if I capture this.

252
00:19:46.560 --> 00:19:47.900
Other array.

253
00:19:49.230 --> 00:19:52.080
Now I get something of the proper type.

254
00:19:52.290 --> 00:20:04.350
That's the whole point of doing this, OK is just to tell Java what is the actual data type that we

255
00:20:04.350 --> 00:20:05.850
need this array to be?

256
00:20:06.180 --> 00:20:10.320
And then it will spit out an array of that correct type.

257
00:20:10.500 --> 00:20:15.920
Now this array will be populated with all of our elements, though.

258
00:20:16.050 --> 00:20:16.550
OK.

259
00:20:16.620 --> 00:20:17.880
Already populated.

260
00:20:18.210 --> 00:20:19.770
And that's the whole point of this.

261
00:20:19.890 --> 00:20:23.590
So sometimes there will be methods of the library.

262
00:20:23.610 --> 00:20:30.120
Oftentimes, it'll be an old library that is expecting you to pass in an array of objects rather than

263
00:20:30.120 --> 00:20:30.930
a collection.

264
00:20:31.200 --> 00:20:36.010
And so but but internally in your own code, you've been working with collections.

265
00:20:36.030 --> 00:20:43.170
So in that case, you can just ask the collection to convert itself essentially to an array.

266
00:20:43.410 --> 00:20:49.530
And you can do so with either of these approaches, though this second one should be your preferred

267
00:20:49.530 --> 00:20:51.900
approach because it is more type safe.

268
00:20:54.490 --> 00:21:00.820
OK, and there's one last thing that I want to cover in this lesson, and it's a really simple one.

269
00:21:01.420 --> 00:21:09.220
So let's go back up here to line thirty seven, and we had originally created an array list and I showed

270
00:21:09.220 --> 00:21:16.660
you that because restoring our instance of the list in a variable of the generic interface type, right,

271
00:21:16.660 --> 00:21:22.120
we're storing it in a variable of the interface rather than the specific implementation of the list.

272
00:21:22.270 --> 00:21:27.180
We had the flexibility to switch our implementation without making any code changes, right?

273
00:21:27.190 --> 00:21:31.240
So we switched this from an array list to a linked list.

274
00:21:31.780 --> 00:21:32.110
All right.

275
00:21:32.230 --> 00:21:37.180
So I'm going to put this back to an array list because I just want to show you one other little thing

276
00:21:38.230 --> 00:21:39.260
array list.

277
00:21:39.640 --> 00:21:40.060
OK.

278
00:21:41.380 --> 00:21:48.640
So the constructor for array list is overloaded, which means that there are multiple versions of it.

279
00:21:49.480 --> 00:21:52.180
So obviously we have this no ARG version.

280
00:21:52.480 --> 00:21:58.900
I also showed you in this lesson that you could also pass in another collection to the constructors

281
00:21:58.900 --> 00:22:03.250
of most of the collection classes.

282
00:22:03.260 --> 00:22:09.130
So in other words, that you could do something like list of and then specify a bunch of a bunch of

283
00:22:09.130 --> 00:22:09.760
things, right?

284
00:22:09.760 --> 00:22:12.610
And then those would get added to this list so you could do that.

285
00:22:14.620 --> 00:22:17.110
But there's one other thing that I want to show you as well.

286
00:22:17.740 --> 00:22:26.170
Since the array list specifically uses an array internally to store its items, and whenever an array

287
00:22:26.170 --> 00:22:31.780
is initially created, it has to be initialized with a size.

288
00:22:32.230 --> 00:22:38.020
Now we can do that by specifying the actual size as a number when we create the array.

289
00:22:38.030 --> 00:22:39.670
So kind of like we're doing right here.

290
00:22:39.670 --> 00:22:46.780
In fact, this is the size of the array that we want to create, so we could pass in any number here.

291
00:22:46.810 --> 00:22:47.240
OK?

292
00:22:47.710 --> 00:22:54.160
When we use an array list, the array list, if we don't specify anything else, it will use a default

293
00:22:54.160 --> 00:22:58.990
value to initialize its own internal array.

294
00:22:59.080 --> 00:23:02.350
However, we can actually override this.

295
00:23:02.590 --> 00:23:11.290
So if you happen to know, or if you happen to have an idea of how large you want the internal array

296
00:23:11.290 --> 00:23:15.970
of your array list to be, you can specify that right here.

297
00:23:17.260 --> 00:23:25.420
So in our case, if I wanted to count these all up, let's see what is this 30 minus 14.

298
00:23:25.420 --> 00:23:26.980
So that's 16, right?

299
00:23:27.790 --> 00:23:37.240
So if I know that I'm going to have exactly 16 items in this list, initially at least, then I could

300
00:23:37.240 --> 00:23:40.330
initialize it with exactly that number.

301
00:23:40.600 --> 00:23:49.150
Now the benefit to doing this is you prevent the array list from creating an array that is too big and

302
00:23:49.150 --> 00:23:57.730
therefore wasting memory or too small, and therefore wasting time when you exceed the internal arrays

303
00:23:57.730 --> 00:24:06.040
initial capacity and then cause the array list to have to create another bigger array and then copy

304
00:24:06.040 --> 00:24:07.060
everything over.

305
00:24:07.060 --> 00:24:12.340
And by the way, when it does that, it still doesn't know how big does this thing finally need to be?

306
00:24:12.550 --> 00:24:20.890
So if your intention is to ultimately add 16 items to this array list, and let's just say that if you

307
00:24:20.890 --> 00:24:29.170
don't specify a size that the array list decides to initially create an internal array of size.

308
00:24:30.040 --> 00:24:30.820
Seven.

309
00:24:30.850 --> 00:24:33.490
OK, now it won't do that, it's going to be bigger than that.

310
00:24:33.490 --> 00:24:36.310
But let's say it starts off with a seven.

311
00:24:36.340 --> 00:24:36.820
OK.

312
00:24:37.000 --> 00:24:42.490
And so then you're going through your loop and you're adding employees as we're doing here, and then

313
00:24:42.490 --> 00:24:45.250
you get to the eighth one and you try to add that.

314
00:24:45.490 --> 00:24:49.470
So then the array list says, Oh, the array isn't big enough.

315
00:24:49.480 --> 00:24:53.710
The internal array isn't big enough to hold an eighth item.

316
00:24:53.980 --> 00:25:02.560
I better create a bigger array and then copy everything that I have into this new array so that I have

317
00:25:02.560 --> 00:25:03.190
more room.

318
00:25:03.970 --> 00:25:12.070
The array list may choose to simply double whatever it had before, so if it started off with an array

319
00:25:12.070 --> 00:25:16.600
of seven elements size, it may double it to 14.

320
00:25:16.630 --> 00:25:21.190
OK, so now creates an an array of 14.

321
00:25:21.310 --> 00:25:27.170
It copies the existing seven, which takes time, and now you can add the eighth one.

322
00:25:27.190 --> 00:25:36.100
However, when you get to the 15th element, it says, Oh, it's too small again.

323
00:25:36.250 --> 00:25:41.110
And so what you've now done is waste a lot of time in computer time, right?

324
00:25:41.140 --> 00:25:48.910
I mean, we're still talking probably milliseconds here, but it is a waste of time to cause the Java

325
00:25:48.910 --> 00:25:53.590
runtime environment really Java to cause Java to have.

326
00:25:53.710 --> 00:26:04.480
To create a raise three times when you could have gotten it right in one time, if you had known beforehand

327
00:26:04.900 --> 00:26:07.180
how many elements you were actually going to need.

328
00:26:07.330 --> 00:26:11.750
Now if you know it, then it's a great idea to be able to just specify this.

329
00:26:11.770 --> 00:26:14.590
If you don't know it, then you don't have much of a choice, right?

330
00:26:15.700 --> 00:26:21.620
But I just wanted to point that out that if you do know the array size, it certainly doesn't hurt.

331
00:26:21.640 --> 00:26:25.990
It's actually better and more efficient to go ahead and specify it.

332
00:26:26.200 --> 00:26:27.970
Now, it doesn't lock you down.

333
00:26:28.120 --> 00:26:34.510
If you try to add a 17th element to the array list, then it's going to just go through what I just

334
00:26:34.510 --> 00:26:37.460
said, and it's going to create a bigger array.

335
00:26:37.810 --> 00:26:39.100
Copy everything over.

336
00:26:39.250 --> 00:26:43.930
Let the original array get garbage collected and then keep going from there.

337
00:26:43.930 --> 00:26:48.850
And it'll just keep doing that until you run out of memory or you're done adding elements.

338
00:26:49.480 --> 00:26:49.930
All right.

339
00:26:49.960 --> 00:26:52.290
So that's all I'm going to cover in this lesson.

340
00:26:52.300 --> 00:26:57.790
And in the next lesson, we'll dig in on some of those other methods that I intentionally didn't want

341
00:26:57.790 --> 00:27:00.610
to touch here because they will get a little more involved.

342
00:27:00.820 --> 00:27:01.870
I'll see you in the next one.
