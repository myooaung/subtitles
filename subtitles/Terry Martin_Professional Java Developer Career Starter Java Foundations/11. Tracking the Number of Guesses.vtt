WEBVTT
1
00:00:00.720 --> 00:00:01.590
Hey, welcome back.

2
00:00:01.830 --> 00:00:09.840
So in the last few lessons, we've been taking a deeper dive into the random number generation and how

3
00:00:09.840 --> 00:00:15.420
to write a decent test to force us to implement that random number generation.

4
00:00:15.870 --> 00:00:22.380
So now I think we can get back into implementing more of the general rules of the game.

5
00:00:22.740 --> 00:00:28.860
So if you recall in the original guessing game that we wrote, we had a rule.

6
00:00:28.860 --> 00:00:34.860
I think that said something like you only get four guesses and then regardless of whether you got the

7
00:00:34.860 --> 00:00:36.030
number or not.

8
00:00:36.150 --> 00:00:37.170
The game is over.

9
00:00:37.410 --> 00:00:43.260
So let's implement that rule in a test and see what that might look like.

10
00:00:43.530 --> 00:00:45.300
So let's see here.

11
00:00:45.300 --> 00:00:47.880
I'm just going to create another test.

12
00:00:51.260 --> 00:00:53.150
Public void.

13
00:00:53.840 --> 00:00:55.580
How about we test?

14
00:00:56.950 --> 00:00:57.760
For.

15
00:00:58.700 --> 00:00:59.450
Wrong.

16
00:01:00.600 --> 00:01:01.650
Guesses.

17
00:01:03.710 --> 00:01:04.160
All right.

18
00:01:04.970 --> 00:01:08.810
So and I'm going to minimize this.

19
00:01:09.440 --> 00:01:12.830
All right, so we just want to make four wrong guesses, right?

20
00:01:12.890 --> 00:01:18.590
So we already know the easiest way probably to do that is just to guess negative numbers.

21
00:01:18.980 --> 00:01:21.140
So let's see what that might look like.

22
00:01:21.320 --> 00:01:30.890
So if we access the game field game, guess and then we just guess for negative numbers, then we could

23
00:01:30.890 --> 00:01:33.140
use the same negative number four times.

24
00:01:33.170 --> 00:01:34.850
I don't think it really matters.

25
00:01:35.150 --> 00:01:37.190
So we'll do negative three.

26
00:01:38.420 --> 00:01:41.630
And then I'm just going to duplicate that.

27
00:01:43.190 --> 00:01:44.120
Four times.

28
00:01:44.330 --> 00:01:53.450
Now we need an assertion, though, I think I would want to assert that on this fourth wrong, guess

29
00:01:53.450 --> 00:01:59.420
we're going to get back some message that'll tell us not only that we didn't get it, but we had four

30
00:01:59.420 --> 00:02:00.890
tries or something like that.

31
00:02:01.160 --> 00:02:07.160
So I think what we'd want to do in this case is to capture the output from this fourth one into a string

32
00:02:07.160 --> 00:02:10.730
variable because remember, this guest's method returns the string.

33
00:02:11.060 --> 00:02:18.770
So with my cursor on this line, I'm going to do a command option v now because I have four, I have

34
00:02:18.770 --> 00:02:25.340
this line duplicated four times or three other times the ID is asking me if I want to replace just this

35
00:02:25.340 --> 00:02:28.320
occurrence, which yes, I only want this one.

36
00:02:28.340 --> 00:02:28.760
All right.

37
00:02:28.760 --> 00:02:30.550
And I guess I will.

38
00:02:30.560 --> 00:02:32.330
What did I call this before?

39
00:02:32.720 --> 00:02:34.400
Uh, message?

40
00:02:34.430 --> 00:02:38.450
OK, I guess I'll call it message again just to be consistent.

41
00:02:39.230 --> 00:02:42.890
And now I can make an assertion assert.

42
00:02:43.700 --> 00:02:48.470
Now, when we were getting it wrong before we just asserted that we would get this message, you didn't

43
00:02:48.470 --> 00:02:49.250
get it.

44
00:02:49.730 --> 00:02:57.050
So now maybe we want to assert that in addition to it saying you didn't get it.

45
00:02:57.830 --> 00:03:02.410
Maybe we'll tack on you didn't get it and you had four tries.

46
00:03:02.450 --> 00:03:04.700
The game is over something like that.

47
00:03:04.700 --> 00:03:05.120
I don't know.

48
00:03:05.130 --> 00:03:06.110
It doesn't really matter.

49
00:03:06.290 --> 00:03:10.700
So here, Ella, a copy this text as a starting point.

50
00:03:12.520 --> 00:03:13.150
So.

51
00:03:14.160 --> 00:03:15.420
You didn't get it.

52
00:03:16.410 --> 00:03:21.780
And you've had four tries.

53
00:03:22.290 --> 00:03:23.520
Game over.

54
00:03:23.880 --> 00:03:24.630
How about that?

55
00:03:25.170 --> 00:03:29.790
And then we'll compare that to the actual message that we receive.

56
00:03:29.940 --> 00:03:33.630
OK, now I know this message is a little different from what we had in the original.

57
00:03:33.660 --> 00:03:34.500
It doesn't matter.

58
00:03:34.590 --> 00:03:37.230
I don't feel like going back to that project.

59
00:03:37.230 --> 00:03:39.570
We can make it this close enough.

60
00:03:40.200 --> 00:03:40.590
All right.

61
00:03:40.600 --> 00:03:43.920
So let's run all of the tests.

62
00:03:44.280 --> 00:03:47.250
So we'll come up to the top here and run.

63
00:03:47.640 --> 00:03:48.570
All right.

64
00:03:48.600 --> 00:03:52.430
So we have one failing test and it's this one right here.

65
00:03:52.440 --> 00:03:56.160
You didn't get it and you've had four tries game over.

66
00:03:56.430 --> 00:03:59.460
The actual that we got there was you didn't get it.

67
00:03:59.850 --> 00:04:00.270
All right.

68
00:04:00.510 --> 00:04:08.700
So what's the easiest thing we can do to get this test passing without hopefully breaking any of the

69
00:04:08.700 --> 00:04:09.750
other tests?

70
00:04:10.050 --> 00:04:13.290
So let's go look at the actual code here.

71
00:04:14.740 --> 00:04:22.870
All right, so currently we're passing in negative number and calling this method four times, and each

72
00:04:22.870 --> 00:04:27.970
time we simply compare the number, we're passing in to the actual random number.

73
00:04:28.300 --> 00:04:31.350
And if they don't match, then we return.

74
00:04:31.360 --> 00:04:32.650
You didn't get it.

75
00:04:33.310 --> 00:04:43.210
So one thing I can see is it looks like we need to track the number of times that the guest's method

76
00:04:43.210 --> 00:04:44.560
is being called.

77
00:04:45.650 --> 00:04:53.390
So we certainly could use a variable to count the number of times that the gas method is being called.

78
00:04:53.810 --> 00:05:01.340
Now this is a good opportunity to remind you of the idea of scope of variables.

79
00:05:01.670 --> 00:05:06.950
So let us consider what might happen if we were to create a variable here.

80
00:05:09.080 --> 00:05:12.470
And I don't know what will do, we want to call this variable.

81
00:05:12.890 --> 00:05:20.420
I don't know for now, I'm just going to call it counter now if we have this variable counter and we

82
00:05:20.420 --> 00:05:23.840
declare it inside of the guests method.

83
00:05:24.290 --> 00:05:27.380
What happens every time that we call the guest method?

84
00:05:27.830 --> 00:05:30.740
This variable will be reset to zero.

85
00:05:31.160 --> 00:05:38.030
So we don't want this variable to be a local variable inside of this guest's method.

86
00:05:38.030 --> 00:05:46.310
It has to be outside of the guests method so that whatever value it's tracking will be retained in between

87
00:05:46.310 --> 00:05:48.590
calls to the guests method.

88
00:05:48.860 --> 00:05:49.850
Does that make sense?

89
00:05:50.450 --> 00:05:50.790
All right.

90
00:05:50.810 --> 00:05:58.060
So rather than doing it that way, let's just introduce another field by default.

91
00:05:58.080 --> 00:06:00.840
I pretty much always make my fields private.

92
00:06:00.860 --> 00:06:06.950
We can't make this final because it needs to be changed every time the guest method is called in.

93
00:06:06.950 --> 00:06:11.910
Variables that are final can only be initialized one time and then never changed again.

94
00:06:12.140 --> 00:06:13.930
So we don't want it to be final.

95
00:06:13.940 --> 00:06:15.380
It will be an integer.

96
00:06:15.710 --> 00:06:22.560
And for right now, I'm just going to call it counter and I will go ahead and initialize it to zero.

97
00:06:22.580 --> 00:06:32.270
And so now I think let's see what happens if we simply increment this counter every time the guest method

98
00:06:32.330 --> 00:06:37.380
is called and we are going to need some logic here.

99
00:06:37.400 --> 00:06:46.610
We're going to need to say something like if counter is for, maybe then return that message that we

100
00:06:46.610 --> 00:06:47.980
were looking for.

101
00:06:48.020 --> 00:06:48.770
Perhaps.

102
00:06:49.190 --> 00:06:57.200
So let's let's see what that might look like if counter equals four.

103
00:06:58.200 --> 00:07:05.190
Then return, and then I'm going to just go over to our test here, and I'm just going to grab this

104
00:07:05.190 --> 00:07:14.610
entire message here, then jump back into the guest's method again and we'll just paste this whole entire

105
00:07:14.610 --> 00:07:15.060
thing.

106
00:07:15.390 --> 00:07:24.110
So if the counter is for, then return this message so kind of implied here is else.

107
00:07:24.250 --> 00:07:29.610
Now, I'm not putting an else here, but it's almost implied otherwise.

108
00:07:29.820 --> 00:07:31.080
Just do this.

109
00:07:31.350 --> 00:07:31.820
OK.

110
00:07:31.980 --> 00:07:36.540
So these two lines cannot both run right.

111
00:07:36.720 --> 00:07:39.030
If this is true, then this is going to happen.

112
00:07:39.030 --> 00:07:46.170
And because of this return statement, here we are short circuiting line 14 and simply returning this.

113
00:07:46.380 --> 00:07:53.520
Now I will take this opportunity to state that there are some good recommendations in what are called

114
00:07:53.520 --> 00:08:01.920
best practices for coding that would suggest that you may want to try avoiding having multiple return

115
00:08:01.920 --> 00:08:04.050
statements in a method.

116
00:08:04.380 --> 00:08:11.370
And there are alternative and arguably better ways of doing this than to have these two return statements

117
00:08:11.370 --> 00:08:11.670
here.

118
00:08:11.880 --> 00:08:15.390
And perhaps we will evolve our code to get to that.

119
00:08:15.570 --> 00:08:22.320
But for right now, in keeping somewhat with the idea of initially doing the minimal thing that you

120
00:08:22.320 --> 00:08:28.500
can think of to get the test to pass, I'm going to just leave it like this for right now and see what

121
00:08:28.500 --> 00:08:29.130
happens.

122
00:08:29.190 --> 00:08:33.870
OK, so now let's just run this thing again and see what happens.

123
00:08:34.350 --> 00:08:39.360
OK, so all of the tests are now passing, so that works now.

124
00:08:39.360 --> 00:08:40.470
Is that good enough?

125
00:08:40.740 --> 00:08:43.260
So let's jump back over to the test class.

126
00:08:44.570 --> 00:08:50.300
All right, so test for wrong guesses results in us getting this message here.

127
00:08:50.510 --> 00:08:56.330
Now what happens if we make three wrong guesses and then our fourth one is actually correct?

128
00:08:56.570 --> 00:08:59.680
In that case, we probably shouldn't see this message, right?

129
00:08:59.690 --> 00:09:01.190
So let's let's make that.

130
00:09:01.520 --> 00:09:05.420
Let's make that scenario, and I'm going to start by just copying this, I suppose.

131
00:09:07.380 --> 00:09:09.180
And pasting that test.

132
00:09:09.330 --> 00:09:11.070
How about three?

133
00:09:12.700 --> 00:09:14.380
Wrong guesses.

134
00:09:14.950 --> 00:09:16.480
And one.

135
00:09:17.720 --> 00:09:18.380
Correct.

136
00:09:18.530 --> 00:09:18.900
All right.

137
00:09:18.920 --> 00:09:25.250
So three wrong guesses and now to do the correct thing, though, we'll have to ask the game engine

138
00:09:25.250 --> 00:09:26.610
what is the correct one, right?

139
00:09:26.630 --> 00:09:29.270
So we'll create an integer, I don't know.

140
00:09:29.270 --> 00:09:39.380
Correct answer equals game, get random number and then we will use the correct answer here on our final

141
00:09:39.410 --> 00:09:40.100
guess.

142
00:09:40.850 --> 00:09:41.540
Like so?

143
00:09:41.840 --> 00:09:42.340
All right.

144
00:09:42.350 --> 00:09:44.330
So that should be the right answer.

145
00:09:44.480 --> 00:09:46.430
And now what do we expect here?

146
00:09:46.640 --> 00:09:47.030
Let's see.

147
00:09:47.040 --> 00:09:53.180
So when we are doing it correctly, we do expect to just receive you got it.

148
00:09:53.480 --> 00:09:54.620
I think that's fine.

149
00:09:54.650 --> 00:09:56.330
I think let's just stick with that.

150
00:09:57.530 --> 00:10:03.290
We don't need to acknowledge that you it took you four guesses just yet, although I think in the previous

151
00:10:03.290 --> 00:10:08.880
implementation, we did actually show how many guesses it took or something like that, right?

152
00:10:08.900 --> 00:10:13.820
So we'll we'll come back and we'll revise this now that I'm remembering that we did have it implemented

153
00:10:13.820 --> 00:10:15.650
in that way, and that was kind of nice.

154
00:10:15.860 --> 00:10:19.190
But let's start off with just this, I suppose.

155
00:10:19.190 --> 00:10:26.150
So if you made three wrong guesses, followed by one correct guess, let's just say.

156
00:10:27.270 --> 00:10:34.380
You got it for let's start off with that, and we'll refactor this test to add in the, you know, showing

157
00:10:34.380 --> 00:10:36.180
how many guesses it took and all of that.

158
00:10:36.360 --> 00:10:37.140
All right.

159
00:10:37.290 --> 00:10:38.130
You got it.

160
00:10:38.130 --> 00:10:44.040
So now let's run all of the tests and we should see this fail, presumably.

161
00:10:44.310 --> 00:10:44.670
All right.

162
00:10:44.700 --> 00:10:45.230
There it is.

163
00:10:45.240 --> 00:10:46.680
There's our failing test.

164
00:10:46.710 --> 00:10:47.340
You got it.

165
00:10:47.610 --> 00:10:48.080
All right.

166
00:10:48.090 --> 00:10:53.550
So now let's jump over here and see what it's going to take for us to to get this one right.

167
00:10:54.300 --> 00:10:54.540
All right.

168
00:10:54.540 --> 00:11:03.950
So our current logic just blindly says, if you have guessed four times, then just show this message.

169
00:11:03.960 --> 00:11:06.470
So now we know this isn't quite good enough.

170
00:11:06.480 --> 00:11:08.220
This logic isn't good enough, right?

171
00:11:08.850 --> 00:11:09.750
So let's see.

172
00:11:09.750 --> 00:11:11.490
There are a few things we could do here.

173
00:11:11.910 --> 00:11:12.210
All right.

174
00:11:12.210 --> 00:11:13.230
So I don't know.

175
00:11:13.530 --> 00:11:21.630
We could have some logic that says something like if counter equals four and guessed number equals,

176
00:11:21.840 --> 00:11:24.490
get random number, then we return.

177
00:11:24.510 --> 00:11:25.500
You got it.

178
00:11:26.370 --> 00:11:31.380
However, we already have this line here that we know is working, so maybe we could say the opposite.

179
00:11:31.380 --> 00:11:38.550
If counter equals four and guessed number is not equal to get random number.

180
00:11:39.030 --> 00:11:41.430
Then we do what we're already doing here.

181
00:11:42.150 --> 00:11:43.740
And then maybe an else.

182
00:11:44.490 --> 00:11:50.730
Yeah, let's just see a few different scenarios here and see what they look like, and I'll copy all

183
00:11:50.730 --> 00:11:51.390
of this.

184
00:11:52.820 --> 00:11:57.440
Guest, no, not equal to get random, no.

185
00:11:58.250 --> 00:12:04.490
Then we return all of this now, actually, so let's just run this.

186
00:12:04.500 --> 00:12:06.170
This might be enough right here.

187
00:12:06.590 --> 00:12:09.200
Let's just run all the tests again and see what we get.

188
00:12:09.620 --> 00:12:09.920
Huh.

189
00:12:10.160 --> 00:12:11.060
Interesting.

190
00:12:11.480 --> 00:12:15.320
So that right there makes all of our tests pass.

191
00:12:16.280 --> 00:12:23.300
Now, one of the interesting things about coding with TDD is, and I don't know that all TDD practitioners

192
00:12:23.300 --> 00:12:32.360
will agree with me on this, but what I find is that it is an odd way to code in some respects because

193
00:12:32.360 --> 00:12:39.110
if you're doing it strictly where you're just trying to implement what you think might be the simplest

194
00:12:39.230 --> 00:12:46.610
thing you could do in the code to get the code to pass, then sometimes that results in you writing

195
00:12:46.610 --> 00:12:53.240
code that you yourself might not have intentionally wanted to write.

196
00:12:53.390 --> 00:12:57.200
Yet it does actually make the test pass right?

197
00:12:57.350 --> 00:13:04.700
And I'm saying this because this approach isn't something that I would naturally want to do, to be

198
00:13:04.700 --> 00:13:06.260
perfectly honest with you.

199
00:13:06.590 --> 00:13:15.050
And I'm inclined to write more tests to force myself to evolve this code to be what I would consider

200
00:13:15.050 --> 00:13:16.550
to be a bit more elegant.

201
00:13:16.580 --> 00:13:24.740
I feel like there is some potential sort of duplication, if you will, in a couple of spots here.

202
00:13:24.740 --> 00:13:29.300
And I don't like the fact that I have to return statements in this method.

203
00:13:29.510 --> 00:13:36.890
I'd like to kind of get away from that, but I don't necessarily feel that I have tests that are forcing

204
00:13:36.890 --> 00:13:40.340
me to do something different here yet.

205
00:13:40.430 --> 00:13:40.820
Right?

206
00:13:40.970 --> 00:13:50.810
So the onus is on me to come up with tests that would force me and justify me coming in here and spending

207
00:13:50.810 --> 00:13:58.250
more brainpower to transform this code into what I would think is more elegant than I think it currently

208
00:13:58.250 --> 00:13:58.730
is.

209
00:13:58.910 --> 00:14:01.730
But I can't quite justify doing that yet.

210
00:14:01.910 --> 00:14:09.110
Apparently, this is good enough for right now, so let's just carry on and see what else we can come

211
00:14:09.110 --> 00:14:09.890
up with here.

212
00:14:10.340 --> 00:14:10.570
All right.

213
00:14:10.580 --> 00:14:12.020
So I'm going to jump back over.

214
00:14:12.230 --> 00:14:12.590
All right.

215
00:14:12.600 --> 00:14:16.290
So test three wrong guesses and one correct?

216
00:14:16.310 --> 00:14:20.270
Oh well, I can already see another another scenario here.

217
00:14:20.450 --> 00:14:26.030
So, OK, let's see what happens if we test two wrong guesses and one correct right?

218
00:14:26.150 --> 00:14:27.680
Let's see what that would look like.

219
00:14:28.100 --> 00:14:29.870
Let's see how that would behave.

220
00:14:30.320 --> 00:14:30.650
All right.

221
00:14:30.650 --> 00:14:35.930
So I will start off by copying this again paste test.

222
00:14:38.460 --> 00:14:44.820
Two wrong guesses and one correct, and I guess I can just delete one of these, so there are my two

223
00:14:44.820 --> 00:14:47.760
wrong guesses, and then here comes my correct one.

224
00:14:48.060 --> 00:14:50.640
All right, so let's run all the tests again.

225
00:14:51.240 --> 00:14:52.980
OK, well, that works.

226
00:14:53.640 --> 00:14:54.120
All right.

227
00:14:54.300 --> 00:14:55.950
Yeah, that that works.

228
00:14:56.460 --> 00:15:00.270
So at this point, I'm not even doing enough analysis myself.

229
00:15:00.420 --> 00:15:06.270
It's almost like because of TDD, the coding is almost sort of run on autopilot at this point.

230
00:15:06.270 --> 00:15:15.420
So I'm I myself am not doing a deep level of analysis of the code that we have in the in the game engine

231
00:15:15.420 --> 00:15:15.780
here.

232
00:15:15.900 --> 00:15:23.040
I'm just doing the bare minimum with a focus on the one test, and it just so happens that all of that

233
00:15:23.040 --> 00:15:25.630
code is making these tests pass, right?

234
00:15:25.650 --> 00:15:31.830
I might not have even thought that this would have worked to this point so far, but it is so far right.

235
00:15:32.310 --> 00:15:32.670
All right.

236
00:15:32.670 --> 00:15:34.080
So let's see what else.

237
00:15:34.380 --> 00:15:37.950
I'm not sure that I even need to have another scenario here.

238
00:15:38.220 --> 00:15:42.140
Test one wrong guess because we've got Test one correct.

239
00:15:42.150 --> 00:15:45.300
We've got Test three wrong and one correct.

240
00:15:45.300 --> 00:15:47.510
We've got Test two wrong and one correct.

241
00:15:47.520 --> 00:15:53.760
I'm pretty confident that tests one wrong and one correct is going to work as well.

242
00:15:54.540 --> 00:16:02.310
So let me minimize this, and let's just look real quick here and see, do we have any unnecessary amount

243
00:16:02.310 --> 00:16:05.280
of duplication that needs to be refactored?

244
00:16:05.490 --> 00:16:06.940
I don't think we do.

245
00:16:06.960 --> 00:16:08.760
But let's just check real quick here.

246
00:16:08.760 --> 00:16:16.650
So of course, we've got these duplicate lines here where we're making three wrong guesses and and again,

247
00:16:16.650 --> 00:16:17.730
three wrong guesses.

248
00:16:17.910 --> 00:16:27.210
However, I am not inclined to refactor these because this is very explicit, like the test itself is

249
00:16:27.390 --> 00:16:28.200
like this one.

250
00:16:28.200 --> 00:16:31.200
Here is what happens when we have four wrong guesses.

251
00:16:31.200 --> 00:16:35.040
So we I kind of want to see explicitly.

252
00:16:35.040 --> 00:16:39.240
Here's wrong guess one wrong guess to three and then four, right?

253
00:16:39.270 --> 00:16:40.980
I want to see that explicitly.

254
00:16:41.160 --> 00:16:42.120
Same thing here.

255
00:16:42.450 --> 00:16:47.700
The whole premise of this test is what happens if you have three wrong guesses and one correct.

256
00:16:47.940 --> 00:16:54.840
So if I were to somehow refactor these three wrong guesses and these three wrong guesses, for example,

257
00:16:54.840 --> 00:16:56.100
I could extract the method.

258
00:16:56.100 --> 00:16:57.960
In fact, I'll show you what that would look like.

259
00:16:58.110 --> 00:17:04.920
I can select these three calls here, these three lines, and then do a command option em four method.

260
00:17:05.220 --> 00:17:07.860
And that will allow me to extract a method here.

261
00:17:07.980 --> 00:17:14.250
And then I can name this method like, I don't know, make three wrong guesses.

262
00:17:14.730 --> 00:17:20.400
And now it's ask me, do I want to replace this occurrence everywhere in the code, wherever it sees

263
00:17:20.400 --> 00:17:26.580
that I have three wrong guesses like this, I can go ahead and replace those.

264
00:17:26.610 --> 00:17:29.760
All right, so here's the new method that it just extracted.

265
00:17:30.210 --> 00:17:36.360
And now it replaced those three calls with this one thing here make three wrong guesses.

266
00:17:36.870 --> 00:17:39.660
And here's another one make three wrong guesses.

267
00:17:39.870 --> 00:17:42.560
Now it is clear what's happening.

268
00:17:42.570 --> 00:17:45.270
It's definitely clear it's not hurting anything.

269
00:17:45.270 --> 00:17:48.030
In fact, here let's let's just run all the tests.

270
00:17:48.030 --> 00:17:51.390
Again, you'll see that this didn't break anything most likely.

271
00:17:51.990 --> 00:17:52.330
OK.

272
00:17:52.350 --> 00:17:55.950
So, yeah, we didn't break anything by doing that refactoring.

273
00:17:56.220 --> 00:18:02.790
But I'm not super comfortable that we really added a ton of value either.

274
00:18:02.970 --> 00:18:03.450
Maybe.

275
00:18:03.450 --> 00:18:05.050
I mean, it's arguable, right?

276
00:18:05.070 --> 00:18:07.320
Maybe, maybe you do what you want to do there.

277
00:18:07.350 --> 00:18:09.100
On the one hand, it is easy to read.

278
00:18:09.120 --> 00:18:09.560
OK.

279
00:18:09.660 --> 00:18:11.810
Make three wrong guesses, right?

280
00:18:11.820 --> 00:18:15.360
Versus seeing the three explicit calls.

281
00:18:15.600 --> 00:18:21.480
But for me, I don't think this method name make three wrong guesses is bringing that much more clarity

282
00:18:21.480 --> 00:18:22.410
to anything.

283
00:18:22.830 --> 00:18:30.420
I will say, though, that there may me extracting this out into a method and then naming it in a good

284
00:18:30.420 --> 00:18:32.970
clear name like make three wrong guesses.

285
00:18:33.120 --> 00:18:37.080
This is part of a concept called self documenting code.

286
00:18:37.440 --> 00:18:44.820
So you may see a lot of programmers who like to use a lot of comments like they'll say, make three

287
00:18:44.820 --> 00:18:47.930
wrong guesses something like that, right?

288
00:18:48.370 --> 00:18:54.040
And then they'll have a space, and then they'll do the rest of the guesses or whatever.

289
00:18:54.060 --> 00:18:57.390
And, you know, maybe there's nothing much wrong with that.

290
00:18:57.390 --> 00:19:06.810
But my preference and I would recommend this to any programmer is I'd often prefer to extract the method

291
00:19:07.080 --> 00:19:13.260
and then name that method something very meaningful, like make three wrong guesses rather than litter

292
00:19:13.260 --> 00:19:16.500
my code with potentially too many comments.

293
00:19:16.830 --> 00:19:23.280
And one of the reasons for that is because comments have a tendency to eventually, over time, fall

294
00:19:23.280 --> 00:19:26.940
out of sync with the code that they are actually commenting.

295
00:19:27.180 --> 00:19:33.660
Whereas method names have a harder time of getting out of sync with whatever it is that they are doing

296
00:19:33.670 --> 00:19:37.980
so, if you were inclined to at least make a comment that.

297
00:19:38.040 --> 00:19:40.320
These are your three wrong guesses.

298
00:19:40.920 --> 00:19:48.930
It might be better in some cases to extract a method name out of those lines of code and then just call

299
00:19:48.930 --> 00:19:49.650
that method.

300
00:19:50.160 --> 00:19:53.530
Something along the lines of whatever your comment might have been.

301
00:19:53.550 --> 00:19:58.610
OK, so let me undo the refactoring here, right?

302
00:19:58.650 --> 00:20:00.300
So I've undone the refactoring.

303
00:20:00.300 --> 00:20:01.710
So just to be really clear.

304
00:20:01.980 --> 00:20:10.350
So you might have been inclined to just say, make three wrong guesses right here and then you might

305
00:20:10.350 --> 00:20:11.730
do it again here.

306
00:20:12.030 --> 00:20:14.480
And in that case, yeah, I don't know.

307
00:20:14.490 --> 00:20:20.850
Maybe it's maybe it's arguably better to just extract the method and call it make three wrong guesses

308
00:20:20.850 --> 00:20:21.750
or something like that.

309
00:20:21.870 --> 00:20:22.890
That's a judgment call.

310
00:20:23.100 --> 00:20:25.880
I don't want to say absolutely you should have.

311
00:20:25.890 --> 00:20:28.060
You should or should not extract the call.

312
00:20:28.080 --> 00:20:32.430
I just want to add to your toolbox so that you are aware of some options there.

313
00:20:32.850 --> 00:20:33.110
All right.

314
00:20:33.120 --> 00:20:36.300
I'm going to get rid of that particular comment, though.

315
00:20:37.410 --> 00:20:37.710
All right.

316
00:20:37.710 --> 00:20:38.460
So I don't know.

317
00:20:38.470 --> 00:20:46.500
Maybe we do go ahead and refactor these tests, though, to incorporate the count of wrong guesses or

318
00:20:46.500 --> 00:20:49.680
how many tries it took to guess the right number.

319
00:20:49.710 --> 00:20:52.950
So let's see here if we go back up to the top.

320
00:20:53.100 --> 00:20:55.130
Maybe we want to say more than you got it.

321
00:20:55.140 --> 00:20:59.640
Maybe we want to say you got it in X tries, right?

322
00:20:59.670 --> 00:21:00.870
Let's see what that might look like.

323
00:21:00.900 --> 00:21:06.230
You got it in one try.

324
00:21:06.390 --> 00:21:10.020
In this particular case, you got it in one try.

325
00:21:10.530 --> 00:21:16.530
So let's just rerun all the tests, and obviously we're going to see that fail.

326
00:21:17.430 --> 00:21:17.760
All right.

327
00:21:18.420 --> 00:21:20.580
Oh, we got to failing, in fact.

328
00:21:21.450 --> 00:21:23.100
Oh, interesting.

329
00:21:23.250 --> 00:21:24.360
Oh our no.

330
00:21:24.360 --> 00:21:28.350
Our random number generator only got nine out of 10.

331
00:21:28.470 --> 00:21:28.880
Hmm.

332
00:21:29.340 --> 00:21:30.960
That is interesting.

333
00:21:31.350 --> 00:21:39.750
Now, I am confident the reason for this is because we probably just hit some little edge scenario where

334
00:21:39.750 --> 00:21:44.850
the random number generator just by a fluke or whatever, just wasn't quite random enough.

335
00:21:44.970 --> 00:21:50.490
My guess is the easiest thing to do to help that out is to increase this number, and we may want to

336
00:21:50.490 --> 00:21:53.930
go ahead and just bring this number back up to like 100.

337
00:21:53.940 --> 00:21:55.370
That's where I started from.

338
00:21:55.380 --> 00:22:01.260
We ended up at 50 because I was trying to be a little more conservative than and do it only as much

339
00:22:01.260 --> 00:22:03.360
as I thought we absolutely needed to.

340
00:22:03.360 --> 00:22:11.280
But I I'm pretty confident that we got this nine out of 10 here because in this one particular case,

341
00:22:11.280 --> 00:22:14.070
even 50 times wasn't quite enough.

342
00:22:14.610 --> 00:22:20.310
So I'm OK to just make that 100, and then I'll be even more confident.

343
00:22:20.490 --> 00:22:22.440
Now we want to be careful with tests like this.

344
00:22:22.440 --> 00:22:29.160
By the way, this test, if even after 100, we might run all these tests many, many more times and

345
00:22:29.160 --> 00:22:31.710
see that it still fails once in a while.

346
00:22:31.830 --> 00:22:37.950
That could be a strong indication that this test is a little fragile, and we really want to be careful

347
00:22:37.950 --> 00:22:44.610
with fragile tests because in the professional world, when you write a test like this that might be

348
00:22:44.610 --> 00:22:50.790
capable of being somewhat fragile once in a while, it becomes almost a thing where it's the boy who

349
00:22:50.790 --> 00:22:51.750
cried wolf.

350
00:22:52.020 --> 00:22:59.640
If a fragile test is capable of breaking a little too often, people stop paying attention to it, and

351
00:22:59.640 --> 00:23:04.740
they may be inclined to just shut up that test, which may or may not be a good idea, right?

352
00:23:04.760 --> 00:23:07.140
So they might decide to put a.

353
00:23:08.120 --> 00:23:13.790
Disabled on it, right, and then just leave it disabled, which is usually not a great thing to do.

354
00:23:13.820 --> 00:23:18.830
Usually, instead of doing that, you want to really address, well, what is it about the test that's

355
00:23:18.830 --> 00:23:23.320
making it fragile and can we harden it so that it won't be so fragile, right?

356
00:23:23.330 --> 00:23:25.940
So you want to look out for fragile tests?

357
00:23:26.240 --> 00:23:33.200
But I am pretty confident that if we go ahead and increase this to 100, it won't be fragile now.

358
00:23:33.470 --> 00:23:41.330
Doing so also will cause the test to take longer to run, though I think we're talking still milliseconds

359
00:23:41.330 --> 00:23:41.540
here.

360
00:23:41.540 --> 00:23:45.320
So in the grand scheme of things, I don't think it's really going to matter too much, but these are

361
00:23:45.320 --> 00:23:47.480
all things that we really have to consider.

362
00:23:47.750 --> 00:23:48.020
All right.

363
00:23:48.050 --> 00:23:52.730
So one more time, I'm just going to run all the tests now that I just made that one little change here.

364
00:23:53.210 --> 00:23:53.580
All right.

365
00:23:53.600 --> 00:23:55.910
And now we only have one failing test.

366
00:23:56.060 --> 00:24:01.520
One of the thing to, by the way, I mentioned in another lesson about the concept of magic numbers.

367
00:24:01.700 --> 00:24:04.140
This definitely is a magic number.

368
00:24:04.160 --> 00:24:11.060
It represents the number of times we think we need to rerun the guessing game to validate that our random

369
00:24:11.060 --> 00:24:16.550
number generation is good and hitting all numbers between one and 10.

370
00:24:16.700 --> 00:24:20.360
So, you know, we might want to refactor this.

371
00:24:21.750 --> 00:24:24.150
By introducing a constant.

372
00:24:25.120 --> 00:24:27.700
And calling it something I don't know what we want to call it.

373
00:24:27.730 --> 00:24:28.540
Maybe.

374
00:24:29.580 --> 00:24:33.270
Game underscore Reid tries.

375
00:24:34.110 --> 00:24:35.430
Or maybe game.

376
00:24:37.220 --> 00:24:40.820
Rand randomness, Reid tries.

377
00:24:40.850 --> 00:24:41.330
I don't know.

378
00:24:42.200 --> 00:24:43.130
Something like that.

379
00:24:43.580 --> 00:24:48.860
And now we can just change that number right up here as a as a constant.

380
00:24:49.010 --> 00:24:50.540
So that's something worth considering.

381
00:24:50.810 --> 00:24:53.750
All right now going to the contest here, though.

382
00:24:54.050 --> 00:24:54.320
All right.

383
00:24:54.330 --> 00:24:58.070
So we were now expecting you got it in one try and we got it.

384
00:24:58.310 --> 00:24:59.690
And instead, we only got you.

385
00:24:59.690 --> 00:25:00.110
Got it.

386
00:25:00.440 --> 00:25:00.800
All right.

387
00:25:00.830 --> 00:25:02.960
So let's see here.

388
00:25:03.200 --> 00:25:05.390
Let's jump into this guest's method.

389
00:25:06.330 --> 00:25:06.610
All right.

390
00:25:06.630 --> 00:25:14.010
So the only place where we're returning the string you got it is right here, so potentially the easiest

391
00:25:14.010 --> 00:25:18.330
thing to do would be to just change the string to say you got it in one try.

392
00:25:18.360 --> 00:25:22.770
Now we already know that's going to cause a bunch of other things to break, presumably.

393
00:25:22.770 --> 00:25:23.940
But let's just see.

394
00:25:24.090 --> 00:25:27.120
So you got it in one try.

395
00:25:27.120 --> 00:25:27.540
Oops.

396
00:25:29.210 --> 00:25:31.370
Try just like that.

397
00:25:31.400 --> 00:25:34.220
All right, so let's rerun everything and see what happens.

398
00:25:34.880 --> 00:25:35.210
Yeah.

399
00:25:35.270 --> 00:25:35.600
All right.

400
00:25:35.610 --> 00:25:38.000
So that broke three other tests.

401
00:25:38.870 --> 00:25:39.110
All right.

402
00:25:39.110 --> 00:25:43.010
So the three other tests are now expecting that you just got you got it.

403
00:25:43.010 --> 00:25:45.220
And instead, we, you know, we're now passing.

404
00:25:45.230 --> 00:25:46.430
You got it in one try.

405
00:25:46.610 --> 00:25:50.630
So let's go look at these tests and see what is the appropriate thing to do here.

406
00:25:50.640 --> 00:25:56.210
So in this particular test, we're now doing tests to run guesses and one correct so that would be three

407
00:25:56.210 --> 00:25:57.140
tries, right?

408
00:25:57.410 --> 00:26:00.740
So really, this one should now be saying you got it in.

409
00:26:02.340 --> 00:26:04.440
Three tries.

410
00:26:04.650 --> 00:26:05.190
Right?

411
00:26:05.280 --> 00:26:06.910
That's what that should be doing.

412
00:26:06.930 --> 00:26:11.640
So let's run this again, and we'll just address these one at a time.

413
00:26:12.540 --> 00:26:14.910
All right, so we still have three failing tests.

414
00:26:15.300 --> 00:26:22.980
All right, so now we have to actually really do some real coding to figure out how to insert this number

415
00:26:23.310 --> 00:26:25.980
and that word try or tries, right?

416
00:26:26.250 --> 00:26:28.590
So let's jump back over here.

417
00:26:30.690 --> 00:26:34.380
So I think now the easiest thing to do is to do the real coding.

418
00:26:34.410 --> 00:26:38.550
Now this number here you got it in one try.

419
00:26:39.060 --> 00:26:41.010
One thing I'm inclined to do.

420
00:26:41.040 --> 00:26:46.650
First off, I think, is to extract this string into its own variable.

421
00:26:46.650 --> 00:26:52.050
And I'll show you why in just a moment, someone to select all of that and then I'm going to do a command

422
00:26:52.050 --> 00:26:55.670
option V and maybe I'm going to call this.

423
00:26:55.680 --> 00:26:56.160
I don't know.

424
00:26:57.650 --> 00:27:00.140
Winning message.

425
00:27:00.800 --> 00:27:02.540
And I'm just using MzGee here.

426
00:27:02.720 --> 00:27:03.350
All right.

427
00:27:03.800 --> 00:27:13.040
Now maybe what I want to do is to use a formatted string here so I could use the string dot format method,

428
00:27:13.040 --> 00:27:13.970
for example.

429
00:27:13.970 --> 00:27:21.440
And that way I can replace this one with the value of that counter, for example.

430
00:27:22.040 --> 00:27:22.280
All right.

431
00:27:22.280 --> 00:27:27.290
So let's see what that might look like if I do something like string dot format.

432
00:27:27.590 --> 00:27:28.790
Do you remember this method?

433
00:27:29.030 --> 00:27:32.240
It's similar to the print f or format method, right?

434
00:27:32.240 --> 00:27:35.090
Except instead of printing something out on the console.

435
00:27:35.330 --> 00:27:40.730
It just generates a formatted string, which we will then capture in this string object here.

436
00:27:40.970 --> 00:27:43.010
So string that format.

437
00:27:44.300 --> 00:27:52.280
We closed that off, and then instead of hard coding this number, we can do a percent de.

438
00:27:53.600 --> 00:27:59.690
And then we can pass in the value of the counter, right?

439
00:27:59.840 --> 00:28:01.860
So that might give us.

440
00:28:01.880 --> 00:28:04.530
You got it in X tries, right?

441
00:28:04.550 --> 00:28:06.950
You got it in one try, for example.

442
00:28:07.370 --> 00:28:09.440
Let's see if that gets us any closer.

443
00:28:10.550 --> 00:28:12.560
So I'm rerunning all the tests now.

444
00:28:12.920 --> 00:28:15.040
I still got three failing tests, however.

445
00:28:15.050 --> 00:28:15.800
Look at this one.

446
00:28:15.800 --> 00:28:19.210
This first one that we're looking at here is very close now.

447
00:28:19.220 --> 00:28:21.250
You got it in three tries.

448
00:28:21.260 --> 00:28:22.640
OK, let's see.

449
00:28:22.940 --> 00:28:24.470
How about this next one?

450
00:28:25.130 --> 00:28:26.920
Now this one's still pretty broken.

451
00:28:26.930 --> 00:28:27.920
You got it in.

452
00:28:28.250 --> 00:28:30.980
So we'll have to revise that, but we'll come back to it.

453
00:28:31.400 --> 00:28:34.080
And then this one, you got it in one try.

454
00:28:34.100 --> 00:28:35.300
You got it in one.

455
00:28:35.870 --> 00:28:37.040
You got it.

456
00:28:37.520 --> 00:28:38.540
Oh, OK.

457
00:28:38.600 --> 00:28:40.550
So I've got a problem here.

458
00:28:40.550 --> 00:28:41.800
Actually, you got it.

459
00:28:41.810 --> 00:28:42.610
One try.

460
00:28:42.850 --> 00:28:43.550
Ah, OK.

461
00:28:43.820 --> 00:28:49.700
So I should be saying you got it in one try, right?

462
00:28:50.510 --> 00:28:53.810
Let's rerun all the tests again, just to double check that.

463
00:28:54.320 --> 00:28:57.320
So I had a little English typo there.

464
00:28:58.190 --> 00:28:58.460
All right.

465
00:28:58.460 --> 00:29:01.250
So now I think what I'm expecting here has a problem.

466
00:29:01.280 --> 00:29:01.920
Let's see.

467
00:29:01.940 --> 00:29:05.450
Oh, interesting, though, we now only have two failed tests.

468
00:29:05.570 --> 00:29:06.650
OK, I'll take it.

469
00:29:07.220 --> 00:29:09.500
So let's jump in to this test.

470
00:29:09.740 --> 00:29:10.480
You got it.

471
00:29:10.490 --> 00:29:11.090
Three tries.

472
00:29:11.090 --> 00:29:16.490
Yeah, we should be saying you got it in three tries, right?

473
00:29:16.820 --> 00:29:19.970
And I'm going to run all the tests yet again.

474
00:29:20.180 --> 00:29:20.660
All right.

475
00:29:21.560 --> 00:29:24.380
Getting pretty close, getting pretty close.

476
00:29:24.410 --> 00:29:24.860
All right.

477
00:29:25.130 --> 00:29:29.990
So now we need to address the word tribe versus tribes, right?

478
00:29:30.020 --> 00:29:35.510
So again, if the number is greater than one than we looks like, we want to return the word tries.

479
00:29:35.720 --> 00:29:39.590
If it's one, then we want to just return the word try, right?

480
00:29:39.890 --> 00:29:42.080
So let's see how we can do that.

481
00:29:42.500 --> 00:29:44.570
Come over here to the guest method again.

482
00:29:44.750 --> 00:29:51.440
So what I think I'm inclined to do here is to introduce another string.

483
00:29:51.710 --> 00:29:52.760
Make a string.

484
00:29:53.090 --> 00:29:58.430
Call it something like try text is probably what we called it in the previous implementation of this

485
00:29:58.430 --> 00:29:59.010
anyway.

486
00:29:59.030 --> 00:30:05.900
So just as I think we did in the previous version of this application, I think we used a ternary operator

487
00:30:06.290 --> 00:30:16.460
to basically just say, if the counter is one, then return the word, try otherwise return the word

488
00:30:16.700 --> 00:30:17.610
tries.

489
00:30:17.660 --> 00:30:19.670
I think that's I think that's what we did.

490
00:30:19.790 --> 00:30:21.470
So here, let's see what that looks like.

491
00:30:21.500 --> 00:30:26.210
Let's see if counter equals one.

492
00:30:26.690 --> 00:30:28.280
And we're using a ternary here.

493
00:30:28.280 --> 00:30:29.780
So we're getting into the question mark.

494
00:30:29.930 --> 00:30:34.090
If counter equals one, then return the word try.

495
00:30:34.250 --> 00:30:36.710
Else return.

496
00:30:36.710 --> 00:30:38.810
The word tries.

497
00:30:39.290 --> 00:30:39.710
OK.

498
00:30:40.430 --> 00:30:43.100
So yeah, I think that's all we need there.

499
00:30:43.700 --> 00:30:47.570
And then we will replace this hardcoded word.

500
00:30:47.870 --> 00:30:57.320
Try with a string, which would be a percent S. And then that'll just be an additional parameter to

501
00:30:57.320 --> 00:31:00.320
pass in, which is the try text.

502
00:31:01.460 --> 00:31:04.830
Like so I think that would get it.

503
00:31:04.850 --> 00:31:08.600
So let's run the tests again and see what we get this time.

504
00:31:10.290 --> 00:31:10.770
OK.

505
00:31:10.800 --> 00:31:12.240
Only one failing now.

506
00:31:12.540 --> 00:31:13.770
Let's see it expected.

507
00:31:13.800 --> 00:31:19.320
You got it, and instead it got a you got it in four tries, which is probably correct.

508
00:31:19.470 --> 00:31:23.460
So let's jump in to that test and probably we just need to update it.

509
00:31:23.820 --> 00:31:28.400
So this one is in one two three four guesses.

510
00:31:28.410 --> 00:31:28.700
Yep.

511
00:31:28.710 --> 00:31:30.720
So we just need to update this.

512
00:31:30.930 --> 00:31:34.740
You got it in four tries.

513
00:31:35.160 --> 00:31:36.040
All right.

514
00:31:36.090 --> 00:31:38.580
And let's we run all the tests again.

515
00:31:39.640 --> 00:31:42.010
Hey, beautiful, seven tests.

516
00:31:42.490 --> 00:31:45.880
Everything's passing, looking very good, huh?

517
00:31:46.270 --> 00:31:49.480
All right, so looks like we've got some good stuff working here.

518
00:31:49.690 --> 00:31:56.440
Maybe let's do a quick review of what's going on now in the actual guessing game code.

519
00:31:56.440 --> 00:31:58.390
Some of the flip back over there.

520
00:31:58.750 --> 00:32:02.950
And let me minimize this and look at that.

521
00:32:02.950 --> 00:32:04.920
It's really quite short, isn't it?

522
00:32:04.930 --> 00:32:05.880
So.

523
00:32:06.010 --> 00:32:08.560
Yeah, I mean, we're really not doing a whole lot here.

524
00:32:08.860 --> 00:32:16.690
So when we create an instance of the guessing game, we are creating an initializing a random number

525
00:32:16.960 --> 00:32:19.630
right there in line and this counter?

526
00:32:20.080 --> 00:32:20.560
OK.

527
00:32:20.710 --> 00:32:26.290
And that's going to happen whenever we create a new guessing game instance, right?

528
00:32:26.620 --> 00:32:34.180
And then whenever we call the guess method here, we will increase the counter.

529
00:32:34.450 --> 00:32:41.950
And then if the counter is equal to four and the thing the number that you're guessing doesn't match

530
00:32:41.950 --> 00:32:44.350
the random number, then you'll get this message.

531
00:32:45.010 --> 00:32:49.240
Now here's a problem we're hard coding the number of tries, right?

532
00:32:49.300 --> 00:32:50.500
We're hard coding that.

533
00:32:50.500 --> 00:32:54.190
So we're probably going to want to make a test that's going to fix that.

534
00:32:54.190 --> 00:32:55.770
But we'll do that in the next lesson.

535
00:32:55.780 --> 00:32:56.770
We won't do that here.

536
00:32:56.830 --> 00:32:57.510
Let's see.

537
00:32:57.520 --> 00:33:04.690
And here we are formatting our try text to determine whether or not it should use the singular or plural

538
00:33:04.900 --> 00:33:05.770
of try.

539
00:33:05.780 --> 00:33:09.370
And then we're also formatting the winning message.

540
00:33:09.490 --> 00:33:12.860
So, yeah, we're going to probably want to format a losing message.

541
00:33:13.090 --> 00:33:19.120
And then here we are, returning whatever we need to return, and then we've got what's generally referred

542
00:33:19.120 --> 00:33:20.440
to as a getter method.

543
00:33:20.650 --> 00:33:25.120
And all this does is just return the value of this field here.

544
00:33:25.630 --> 00:33:28.390
So, yeah, I mean, it's actually simpler.

545
00:33:28.400 --> 00:33:34.780
We've got just about the same amount of functionality that we had in the previous implementation or

546
00:33:34.780 --> 00:33:35.680
close to it.

547
00:33:35.950 --> 00:33:41.860
We might be forgetting a few things I don't recall, but we're pretty close, but much simpler code

548
00:33:41.860 --> 00:33:45.790
overall, and nothing here is extraneous whatsoever.

549
00:33:45.820 --> 00:33:51.640
Now, one reason why this is probably so much simpler than I think the previous implementation was,

550
00:33:51.640 --> 00:33:55.730
is because it's focused purely on just the game logic.

551
00:33:55.750 --> 00:34:02.470
There is no interaction with the console and waiting for, you know, accepting input from a user or

552
00:34:02.470 --> 00:34:03.610
anything like that.

553
00:34:03.880 --> 00:34:10.420
If we wanted to do that, that would be done in another class that would then interact with this one.

554
00:34:10.420 --> 00:34:14.080
And I think that might be a good exercise for us to do in the future.

555
00:34:14.080 --> 00:34:20.110
Just so you can see the difference between doing a tightly integrated simple application like this all

556
00:34:20.110 --> 00:34:23.470
in one class versus splitting it up into a couple of classes.

557
00:34:23.500 --> 00:34:23.750
All right.

558
00:34:23.770 --> 00:34:30.010
But anyway, let's close this out for now, and we'll pick up where we left off in the next lesson and

559
00:34:30.010 --> 00:34:31.450
we'll fix this message.

560
00:34:31.720 --> 00:34:36.640
And I've got a couple other ideas for some additional features that we could consider implementing as

561
00:34:36.640 --> 00:34:36.850
well.

562
00:34:36.970 --> 00:34:37.840
So I'll see you there.
