WEBVTT
1
00:00:00.720 --> 00:00:10.920
OK, so next up is the integer and integer is probably the most common numerical data type used by default

2
00:00:10.920 --> 00:00:11.610
in Java.

3
00:00:11.610 --> 00:00:17.460
So in other words, I think it's safe to say that most Java developers, when they just need a generic

4
00:00:17.460 --> 00:00:25.240
variable to hold numbers and do basic math on, they're probably going to default to using an integer.

5
00:00:25.260 --> 00:00:31.200
I'm not exactly sure why that is, I guess, probably because it's kind of at the sweet spot of, you

6
00:00:31.200 --> 00:00:39.180
know, having probably enough range for the typical situation that a programmer would need and just,

7
00:00:39.180 --> 00:00:41.430
you know, the right amount of flexibility.

8
00:00:41.550 --> 00:00:45.300
OK, so integer is 32 bit, as you can see here.

9
00:00:45.300 --> 00:00:49.440
Here's the integer I don't know little column, if you will, right?

10
00:00:49.440 --> 00:00:53.090
And then with the numbering here we're going up to 32, right?

11
00:00:53.100 --> 00:00:55.950
So that's a 32 bit long data type.

12
00:00:56.310 --> 00:01:05.940
And because it's 32 bits, it can hold a range from roughly negative two point one billion to positive

13
00:01:05.940 --> 00:01:07.420
two point one billion.

14
00:01:07.440 --> 00:01:07.950
OK.

15
00:01:08.400 --> 00:01:11.900
So, you know, pretty good for a whole lot of things.

16
00:01:11.910 --> 00:01:17.970
I mean, like programmers will do things like make basic loops and stuff, and they might want to well,

17
00:01:17.970 --> 00:01:25.800
they'll have to define a variable of some type to count the number of iterations through that loop.

18
00:01:26.070 --> 00:01:31.680
And like I said before, most Java developers, probably by default, are going to use an integer to

19
00:01:31.680 --> 00:01:32.220
do that.

20
00:01:32.400 --> 00:01:39.660
And so as long as you're loop only needs to go up to roughly 2.1 billion or less, you're you're good

21
00:01:39.660 --> 00:01:40.680
with with end.

22
00:01:40.770 --> 00:01:48.060
Now, you know, knowing that it's 32 bits wide and goes up to 2.1 billion, it certainly could be argued

23
00:01:48.060 --> 00:01:54.800
that end may be overkill for a lot of things that developers may want to do with numbers by default.

24
00:01:54.810 --> 00:02:00.900
And that's one of the reasons why it's so important to make sure that you're aware of all of these basic

25
00:02:00.900 --> 00:02:03.930
data types, the byte, short end, and so on.

26
00:02:03.930 --> 00:02:08.700
Because, you know, maybe when you're going to do a loop and you know, you're only going to loop 20

27
00:02:08.700 --> 00:02:15.360
times, possibly why bother with an end to you could conceivably just use a byte for that, you know,

28
00:02:15.360 --> 00:02:17.310
and save a little space in the computer.

29
00:02:17.580 --> 00:02:24.030
Now, on the other hand, like I said before, modern day computers have a minimum usually of four gigs

30
00:02:24.030 --> 00:02:24.690
of RAM.

31
00:02:25.590 --> 00:02:34.110
And so, you know, even using hundreds of INTs isn't likely to put much of a dent in the total amount

32
00:02:34.110 --> 00:02:35.700
of RAM in a computer.

33
00:02:36.150 --> 00:02:42.690
So with respect to programmers from 30, 40, 50 years ago, I think it's safe to say that a lot of

34
00:02:42.690 --> 00:02:48.450
programmers today probably have become quite wasteful, if you will, because we can afford it, right?

35
00:02:48.450 --> 00:02:50.610
Because the computers have so much ram.

36
00:02:50.940 --> 00:02:56.640
You know, you often just don't need to even think a whole lot about, you know, what data type are

37
00:02:56.640 --> 00:02:57.150
you using?

38
00:02:57.150 --> 00:02:59.610
Are you using the most efficient data type?

39
00:02:59.850 --> 00:03:04.110
But, you know, whatever, it may still be good to think about it from time to time.

40
00:03:04.530 --> 00:03:11.760
OK, so anyway, into 32 bits long, let's let's look at the next largest data type, and then we're

41
00:03:11.760 --> 00:03:13.020
going to backtrack a little bit.

42
00:03:13.020 --> 00:03:20.280
Also, because just as short shares a characteristic with another data type, which is care and also

43
00:03:20.280 --> 00:03:20.580
does.

44
00:03:20.580 --> 00:03:25.530
But we'll come back and look at another data type that is also 32 bit wide.

45
00:03:25.920 --> 00:03:33.540
OK, so the next data type after into that I want to look at is long, and it's really long.

46
00:03:34.290 --> 00:03:42.600
It's twice as long or twice as wide, if you will, as int it is 64 bit, as you can see here, if you

47
00:03:42.600 --> 00:03:46.980
can see that because now I've had to zoom out so much that you can barely see the numbers anymore,

48
00:03:46.980 --> 00:03:49.020
but that's 64 bits wide.

49
00:03:49.050 --> 00:03:49.560
OK.

50
00:03:49.590 --> 00:03:55.410
And that gives it a range of a number that I don't even I honestly don't know how to say this number.

51
00:03:55.440 --> 00:03:55.750
Let's see.

52
00:03:55.770 --> 00:04:00.330
So we're at one hundred thousand million billion trillion.

53
00:04:01.020 --> 00:04:03.650
I don't know if this is quadrillion quintillion.

54
00:04:03.660 --> 00:04:06.750
I'm not even sure how to how to say that number in English.

55
00:04:06.840 --> 00:04:08.830
It's a very large number, though.

56
00:04:08.850 --> 00:04:09.240
OK.

57
00:04:09.270 --> 00:04:09.660
Right.

58
00:04:09.840 --> 00:04:19.470
So one place where you may tend to see long used is often times when we're writing programs that need

59
00:04:19.470 --> 00:04:26.640
to store records to a database, and each record that we will store in the database requires its own

60
00:04:26.880 --> 00:04:27.300
ID.

61
00:04:27.690 --> 00:04:37.080
You'll often see programmers use type long for that idea, and they will do that just to ensure that

62
00:04:37.080 --> 00:04:44.760
it's pretty much impossible that you could run out of potential IDs for those records, whereas it only

63
00:04:44.760 --> 00:04:48.180
goes up to positive two point one billion.

64
00:04:48.360 --> 00:04:57.600
I'm sure there really are a number of applications in the world of programming where you could exhaust

65
00:04:57.600 --> 00:04:59.840
that limit that upper limit of two.

66
00:04:59.920 --> 00:05:07.990
Point one billion, let's say, like if you had to account for every single item that went into the

67
00:05:07.990 --> 00:05:16.540
making of a spacecraft or an aircraft or something like every screw, every bolt, every single thing,

68
00:05:16.540 --> 00:05:22.570
I don't know there might be two billion of every little thing that that goes into making, you know,

69
00:05:22.690 --> 00:05:24.130
some aircraft or something.

70
00:05:24.460 --> 00:05:32.290
So for safety's sake, you will tend to see some programmers just default to using a long for things

71
00:05:32.290 --> 00:05:32.830
like that.

72
00:05:32.860 --> 00:05:40.240
Let's also consider like if you were going to write an application that would assign an I.D. to every

73
00:05:40.270 --> 00:05:43.080
living being on planet Earth.

74
00:05:43.090 --> 00:05:46.570
Currently, I think the population is somewhere around seven billion.

75
00:05:46.750 --> 00:05:52.750
So right there you would not be able to use an end to represent every human being on Earth.

76
00:05:52.750 --> 00:05:58.870
Since it, the upper limit is only 2.1 billion and we're already at roughly seven or eight billion right

77
00:05:58.870 --> 00:05:59.350
now.

78
00:05:59.530 --> 00:06:02.740
So then you've got to jump to using a long.

79
00:06:02.860 --> 00:06:03.340
OK.

80
00:06:03.790 --> 00:06:08.710
So and that's like I said earlier, that's really the thinking behind these different data types.

81
00:06:08.710 --> 00:06:11.950
You're going to ask yourself, what is it that I need to count?

82
00:06:12.610 --> 00:06:18.880
What do I think the upper limit will ever be on whatever it is that I need to count in my program?

83
00:06:19.270 --> 00:06:24.940
And then what data type will comfortably fit with that assumed upper limit?

84
00:06:25.330 --> 00:06:30.700
And that's how you can determine what what data type you probably should be using for whatever it is

85
00:06:30.700 --> 00:06:31.510
that you're doing.

86
00:06:31.630 --> 00:06:37.840
However, like I said, a lot of Java developers won't really go through that thought process, and

87
00:06:37.840 --> 00:06:43.030
instead they will just default to using it for pretty much everything.

88
00:06:43.330 --> 00:06:46.180
And for the most part, that's probably pretty safe.

89
00:06:46.360 --> 00:06:51.880
But it may be wasteful in cases where if they had gone through that thought process, they might have

90
00:06:51.880 --> 00:06:58.240
realized, well, there's no chance on Earth that I will ever get into the billions for whatever I'm

91
00:06:58.240 --> 00:07:04.420
about to count in my program, and perhaps a short or a bite would have been more than sufficient.

92
00:07:04.600 --> 00:07:09.970
Now let me be clear on something because I guess I didn't explicitly show it in code.

93
00:07:10.270 --> 00:07:18.250
So if you were to create variables of these various types, you are going to be limited in how large

94
00:07:18.250 --> 00:07:22.450
a number you can put into those variables and to prove that.

95
00:07:22.480 --> 00:07:27.970
Let me let me go back to the ADP and show you maybe a couple of examples with byte and short.

96
00:07:28.000 --> 00:07:36.970
OK, so here we had this bite and I put the number 13 in it and the upper limit of a byte is 127.

97
00:07:37.120 --> 00:07:43.330
So let me first to show, OK, I can put one hundred and twenty seven in there, and that's perfectly

98
00:07:43.330 --> 00:07:43.750
fine.

99
00:07:43.960 --> 00:07:51.010
I don't get any error, but if I try to do one twenty eight, bam, that line now has an error because

100
00:07:51.010 --> 00:07:58.960
I have now exceeded the number of bits that are allocated to a byte for me to assign a value to it.

101
00:07:59.230 --> 00:07:59.590
Right?

102
00:07:59.950 --> 00:08:00.340
OK.

103
00:08:00.400 --> 00:08:01.750
So I'm going to put that back.

104
00:08:01.910 --> 00:08:02.450
Let's see.

105
00:08:02.470 --> 00:08:09.220
Similarly, the upper limit on a short is thirty two thousand seven hundred sixty seven.

106
00:08:09.250 --> 00:08:09.580
Right?

107
00:08:09.850 --> 00:08:14.500
So let me show you that thirty two thousand seven hundred sixty seven.

108
00:08:14.830 --> 00:08:15.190
OK.

109
00:08:15.220 --> 00:08:15.910
It's happy.

110
00:08:16.090 --> 00:08:21.310
But if I go one more over that 768 bam, that blows up also.

111
00:08:21.670 --> 00:08:24.970
Now I'm going to put this back to 767.

112
00:08:25.660 --> 00:08:32.200
Now, if you'll recall, though, I also mentioned, though, that a short is sixteen bits long or wide

113
00:08:32.560 --> 00:08:36.700
and so is a cr right there, both sixteen bits.

114
00:08:37.360 --> 00:08:44.890
However, a short is a signed data type, which means it has a negative and a positive range.

115
00:08:44.890 --> 00:08:49.270
It can represent both negative and positive numbers, so it can represent negative thirty two thousand

116
00:08:49.270 --> 00:08:54.760
seven hundred sixty eight, up to positive thirty two thousand seven hundred sixty seven.

117
00:08:55.090 --> 00:09:03.100
Now, if you wanted to go twice as big as what the short can give you, which would be what, sixty

118
00:09:03.100 --> 00:09:08.680
four sixty five thousand something like that because you didn't need any negative numbers, you only

119
00:09:08.680 --> 00:09:10.780
were going to need positive numbers.

120
00:09:10.960 --> 00:09:17.140
One trick, if you will, that you can do is to simply use a care for these numbers.

121
00:09:17.170 --> 00:09:25.570
Now here you see me using a card to actually assign characters, but I can assign numbers to a card

122
00:09:25.570 --> 00:09:30.220
just as well, because at the at the end of the day, these characters are numbers.

123
00:09:30.430 --> 00:09:37.570
I am in essence, right here storing the number 65 in this variable, really, and I don't know what

124
00:09:37.570 --> 00:09:39.220
the number is for for this.

125
00:09:39.220 --> 00:09:45.730
But so if I make a care variable, let's call it bigger short.

126
00:09:47.370 --> 00:09:52.140
And I'll start off with the same thing just to show you that I can do this right?

127
00:09:52.170 --> 00:09:55.800
OK, so I just put thirty two thousand seven sixty seven in here.

128
00:09:55.980 --> 00:10:03.060
Now remember on the short when I went one over that it blew up on me because that's the upper range.

129
00:10:03.600 --> 00:10:05.670
But, you know, put this back.

130
00:10:06.450 --> 00:10:08.280
But if I come down here and do that?

131
00:10:10.220 --> 00:10:11.060
That's allowed.

132
00:10:11.540 --> 00:10:18.830
And that's because care doubles the range going in the positive direction because there is no negative

133
00:10:18.860 --> 00:10:19.250
there.

134
00:10:19.370 --> 00:10:26.030
So that last bit here, if we go back over here again and look, OK, so if you'll recall, I stated

135
00:10:26.030 --> 00:10:33.950
that in order to allow for negative and positive, what these data types will generally do is they will

136
00:10:33.950 --> 00:10:41.090
take the last bit and they will use that just to indicate whether or not that number is negative or

137
00:10:41.090 --> 00:10:41.730
positive.

138
00:10:41.750 --> 00:10:42.080
Right.

139
00:10:42.740 --> 00:10:49.640
But if you don't need that last bit to indicate the sign of the number, well, now you just effectively

140
00:10:49.640 --> 00:10:51.050
doubled your range.

141
00:10:51.290 --> 00:10:59.300
And so a care is not signed, it is unsigned, meaning all the all the values in it are positive, and

142
00:10:59.300 --> 00:11:05.810
therefore it has a positive range that is twice that of a short.

143
00:11:06.050 --> 00:11:06.490
OK.

144
00:11:06.770 --> 00:11:14.900
So same number of values, but shifted to all positive instead of short having half negative and roughly

145
00:11:14.900 --> 00:11:17.150
half negative and half being positive.

146
00:11:17.420 --> 00:11:23.270
OK, so now I can put bigger numbers in here, like sixty four.

147
00:11:24.820 --> 00:11:25.210
Oops!

148
00:11:27.440 --> 00:11:28.790
64000.

149
00:11:28.820 --> 00:11:29.240
Right.

150
00:11:29.420 --> 00:11:32.300
That fits where that would never fit in a short.
