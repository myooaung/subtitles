WEBVTT
1
00:00:00.600 --> 00:00:07.350
All right, so in the last lesson, we had a nice marathon there to get our couple of tests working

2
00:00:07.350 --> 00:00:13.440
and get some ABC code written that would allow us to connect to the database and we got that all working.

3
00:00:14.130 --> 00:00:21.060
So in this lesson, I want to just go through a little bit of what we did there, make some clarifications

4
00:00:21.060 --> 00:00:24.240
where needed and clean up a few things as well.

5
00:00:24.600 --> 00:00:28.200
So we're going to start back in the unit test here.

6
00:00:28.440 --> 00:00:33.540
And the first thing I think I want to address is what we're doing with this connection here.

7
00:00:34.020 --> 00:00:34.560
So.

8
00:00:35.630 --> 00:00:42.320
What we're essentially doing first off, we're using a J Unit annotation the before each annotation

9
00:00:42.590 --> 00:00:45.710
in order to set up or create that connection.

10
00:00:45.890 --> 00:00:52.130
So what this means is that we're actually establishing a new database connection for each individual

11
00:00:52.130 --> 00:00:53.120
test here.

12
00:00:53.150 --> 00:00:57.770
OK, now for what we're doing at this time, that's fine.

13
00:00:58.010 --> 00:01:05.120
It could be seen as being a little wasteful, though, because we are actually creating a new connection

14
00:01:05.120 --> 00:01:06.380
for each and every test.

15
00:01:06.680 --> 00:01:13.940
It really depends on the nature of how you're wanting to test, though if you want your database related

16
00:01:13.970 --> 00:01:19.520
tests to be a nice, clean slate for each and every test.

17
00:01:19.820 --> 00:01:25.550
This might be a good way to go where you're setting up a new connection before each test.

18
00:01:26.030 --> 00:01:30.110
Now one thing I think we should be doing, though, and I think we're going to go out and do this now,

19
00:01:30.110 --> 00:01:38.630
is that at the end of each of these tests, it is implied essentially that this connection goes away,

20
00:01:38.660 --> 00:01:42.770
OK, because it's happening for each individual test.

21
00:01:43.010 --> 00:01:49.200
But we can make that more explicit and I think we should and by go away, I mean, close the connection.

22
00:01:49.220 --> 00:01:49.700
OK.

23
00:01:49.790 --> 00:01:56.960
So that way, we can just ensure that there's no database connection leaks or weird things going on

24
00:01:56.960 --> 00:01:57.620
of that sort.

25
00:01:57.770 --> 00:02:04.100
And so if we want to just ensure that we're really closing down these connections at the end of each

26
00:02:04.100 --> 00:02:07.210
test, we can do a teardown method.

27
00:02:07.280 --> 00:02:07.730
OK.

28
00:02:08.060 --> 00:02:14.090
So if I just put my cursor here, make a new line to a command in or right click on blank space for

29
00:02:14.090 --> 00:02:16.940
Windows users and choose Generate.

30
00:02:17.120 --> 00:02:22.190
Then we can choose teardown methods, so that'll generate a tear down method for us.

31
00:02:22.220 --> 00:02:22.530
OK.

32
00:02:22.550 --> 00:02:25.670
So this is the complement to the setup method.

33
00:02:25.730 --> 00:02:26.240
OK?

34
00:02:26.690 --> 00:02:29.720
Or the annotation before each and after each.

35
00:02:30.050 --> 00:02:36.170
And then here we can essentially just refer to our connection and then call close.

36
00:02:36.920 --> 00:02:42.800
Now, calling that close method itself actually can generate an exception as well.

37
00:02:43.970 --> 00:02:46.460
So we'll want to do something about that.

38
00:02:46.460 --> 00:02:52.160
And again, I'm generally OK for now to just add the exception to the signature here.

39
00:02:52.370 --> 00:02:58.610
Now, please, please, please make sure you're understanding that I'm OK for now, with adding the

40
00:02:58.610 --> 00:03:03.200
exception to the signature of our test methods test methods.

41
00:03:03.500 --> 00:03:10.370
We want to be a lot more mindful of what we're doing with the exceptions in our implementation code,

42
00:03:10.370 --> 00:03:12.560
write the code of the system under test.

43
00:03:12.560 --> 00:03:14.570
The thing that we are testing, right?

44
00:03:14.780 --> 00:03:16.100
This is the test code.

45
00:03:16.400 --> 00:03:22.910
The repository class would be the the system under test, which is the class that we are testing, right?

46
00:03:23.330 --> 00:03:30.680
So I'm OK here with us adding the exception to the signature here, because that's just going to cause

47
00:03:30.830 --> 00:03:31.880
those methods.

48
00:03:32.060 --> 00:03:36.480
These test methods to fail, and that's always an OK thing, right?

49
00:03:36.500 --> 00:03:38.420
To let a test method fail.

50
00:03:38.660 --> 00:03:43.880
You'd rather that it hit you in the face and that you see case something's not working correctly.

51
00:03:44.210 --> 00:03:53.570
Now we could be a little bit safer here, perhaps, and do something like if connection is not null,

52
00:03:54.770 --> 00:03:55.970
then do all of that.

53
00:03:56.690 --> 00:04:02.210
You know, we could do something along those lines because if for some reason the setup itself failed,

54
00:04:02.210 --> 00:04:04.670
then the connection should be null.

55
00:04:05.000 --> 00:04:08.330
And in that case, there's nothing to close, right?

56
00:04:08.870 --> 00:04:13.580
Now let me also be a little more explicit about the nature of the setup in the teardown.

57
00:04:14.000 --> 00:04:21.560
So what ends up happening with J Unit with these before each and after each annotated methods here is

58
00:04:21.560 --> 00:04:29.120
that right before J Unit runs each of these tests, it's going to run the set up to do whatever.

59
00:04:29.120 --> 00:04:30.530
And it's going to do that for the set up.

60
00:04:30.530 --> 00:04:35.100
Not because it's called setup, but because there's a B for each annotated method here.

61
00:04:35.120 --> 00:04:35.450
OK.

62
00:04:35.630 --> 00:04:42.410
So it's going to run all of the methods that are annotated with before each, right before it runs any

63
00:04:42.410 --> 00:04:44.090
individual test method.

64
00:04:44.990 --> 00:04:51.320
And then when that test method is done, it's going to call all of the methods that are annotated with

65
00:04:51.320 --> 00:04:53.090
at after each.

66
00:04:53.120 --> 00:04:53.630
OK.

67
00:04:54.260 --> 00:04:58.160
So that's the normal happy path implementation of day unit.

68
00:04:58.280 --> 00:05:01.910
However, there are some neat little things worth noting here.

69
00:05:02.240 --> 00:05:10.730
If an exception happens to be thrown within a test method, the after each methods here, the teardown

70
00:05:10.730 --> 00:05:12.920
in this case still gets to run.

71
00:05:13.520 --> 00:05:18.470
OK, which is great because we will have open the connection successfully.

72
00:05:18.470 --> 00:05:20.990
But then let's say something went wrong down here.

73
00:05:21.200 --> 00:05:27.170
We want to make sure absolutely certain that that connection still gets closed, OK?

74
00:05:27.320 --> 00:05:34.430
So even if this blows up with an exception, the teardown method will still will still get called by

75
00:05:34.430 --> 00:05:35.060
J Unit.

76
00:05:35.950 --> 00:05:43.840
Also, even if something goes wrong in the setup method, tear down, we'll also still get called.

77
00:05:43.910 --> 00:05:49.060
OK, so this is actually very similar to a try catch block looks.

78
00:05:49.510 --> 00:05:54.380
If we had a try, I'm just going to put it kind of like here on one line.

79
00:05:54.410 --> 00:05:55.030
Try.

80
00:05:57.440 --> 00:05:59.420
Open connection.

81
00:05:59.450 --> 00:05:59.840
Right.

82
00:06:03.230 --> 00:06:03.920
Catch.

83
00:06:05.630 --> 00:06:07.760
Exception, whatever it is.

84
00:06:09.590 --> 00:06:17.540
Handle exception, and then you could have a finally right, remember that the final block will always

85
00:06:17.540 --> 00:06:22.550
run no matter what cleanup or recovery or whatever.

86
00:06:22.940 --> 00:06:23.510
So.

87
00:06:24.690 --> 00:06:32.400
This after each annotated method here, the tear down method and the things that it does here are actually

88
00:06:32.400 --> 00:06:38.730
quite equivalent to a final block, and to be honest with you, for all I know the way that J unit is

89
00:06:38.730 --> 00:06:44.490
actually implemented, it may actually be calling these after each annotated methods inside of a final

90
00:06:44.580 --> 00:06:44.910
block.

91
00:06:45.030 --> 00:06:48.810
There's a real strong likelihood that that's probably exactly what it's doing.

92
00:06:49.230 --> 00:06:57.900
So this is our chance to recover or clean up from whatever mess may have happened prior to this method

93
00:06:57.900 --> 00:06:58.590
getting called.

94
00:06:58.770 --> 00:07:04.860
So that's probably a good thing that we'd want to have if we're opening database connections directly

95
00:07:04.860 --> 00:07:07.590
within a test like we're doing here.

96
00:07:08.280 --> 00:07:11.370
All right, let me get rid of that, OK?

97
00:07:11.550 --> 00:07:18.660
Another thing that I want to point out is that I actually kind of forgot to double check this now.

98
00:07:18.810 --> 00:07:24.990
So here in our tests, we're creating people with birthdates, right?

99
00:07:25.380 --> 00:07:35.150
And they've there and like this guy here is born at 3:15 p.m., right at GMT minus six.

100
00:07:35.160 --> 00:07:42.750
No, but we're now trying to make sure that we're normalizing all of the dates and times in the database

101
00:07:42.750 --> 00:07:45.870
to be relative to GMT zero.

102
00:07:46.410 --> 00:07:51.900
So I forgot for us to actually pay attention in the database, though, to confirm that that's actually

103
00:07:51.900 --> 00:07:53.370
what the dates and times are, right?

104
00:07:53.370 --> 00:08:07.170
So 3:15 p.m. GMT minus six should be 9:15 p.m. GMT zero right 9:15, which I think would be 20 100 hours

105
00:08:07.260 --> 00:08:08.730
or 21 hours.

106
00:08:08.970 --> 00:08:09.270
Right.

107
00:08:09.450 --> 00:08:11.670
So let's just double check that real quick.

108
00:08:12.120 --> 00:08:15.600
So we're going to jump into the Squirrel SQL client.

109
00:08:15.660 --> 00:08:16.080
All right.

110
00:08:16.830 --> 00:08:18.720
And here's our data.

111
00:08:19.290 --> 00:08:25.020
And we've got all these rows here with the with the null salaries, and these are all the rows that

112
00:08:25.020 --> 00:08:27.330
got inserted as a result of our tests.

113
00:08:27.600 --> 00:08:33.930
So if we just pay attention here, yet we've got 21, 15, 21, 15.

114
00:08:35.800 --> 00:08:41.230
So that so that time generally looks correct.

115
00:08:42.930 --> 00:08:47.130
Let's see now, let's check on Bob, I can't remember what we set for Bobby.

116
00:08:47.430 --> 00:08:48.660
Bobby.

117
00:08:48.870 --> 00:08:57.630
OK, so Bobby was actually one 13, however, he was one 13 at GMT minus eight.

118
00:08:58.440 --> 00:09:10.980
So one 13 p.m. at GMT minus eight would still be nine 13 p.m. ET GMT, minus zero.

119
00:09:11.980 --> 00:09:12.380
Right.

120
00:09:12.400 --> 00:09:18.370
Which would be 20 100 hours and jumping back into the database for the.

121
00:09:19.770 --> 00:09:26.390
Yeah, there we are, 21, 13, so OK, so great, so our time warping is working correctly, right?

122
00:09:26.400 --> 00:09:33.810
All of these well, all of these dates for the where the salary is zero, all of these dates are indeed

123
00:09:33.870 --> 00:09:42.750
being converted and stored in GMT minus zero, regardless of what time zone they were set in Java code.

124
00:09:42.990 --> 00:09:48.690
OK, so that that time warping code that we put in the repository is working.

125
00:09:49.320 --> 00:09:49.640
All right.

126
00:09:49.650 --> 00:09:50.430
So very good.

127
00:09:50.730 --> 00:09:51.040
OK.

128
00:09:51.060 --> 00:09:52.260
So while we're here.

129
00:09:53.170 --> 00:09:55.570
There's another thing I wanted to point out as well.

130
00:09:56.170 --> 00:10:01.900
So we're dirtying up our database every time we run our tests.

131
00:10:02.290 --> 00:10:08.090
To me, that's not necessarily the most desirable way for these tests to run there.

132
00:10:08.260 --> 00:10:15.670
There may very well be some occasions when you explicitly want to see the data in the database and in

133
00:10:15.670 --> 00:10:21.040
fact, actually even right now, I mean, as we've been just dipping our toes in the pool and wanting

134
00:10:21.040 --> 00:10:26.770
to really confirm, Hey, is our code really, truly putting the right data out into the database?

135
00:10:27.250 --> 00:10:34.120
Nothing beats just opening up a database client like this one and seeing those records in the database.

136
00:10:34.420 --> 00:10:42.760
However, now that we have confirmed that we generally are able to write data to the database, perhaps

137
00:10:42.760 --> 00:10:49.630
we don't want to keep dirtying up our database permanently with all these duplicated records, as we

138
00:10:49.630 --> 00:10:50.440
are doing now.

139
00:10:50.740 --> 00:10:57.730
So there's actually a great technique that we can use if we want to use the database temporarily while

140
00:10:57.730 --> 00:11:03.430
the tests are working, but then have the tests essentially clean up after themselves when they're all

141
00:11:03.430 --> 00:11:07.780
done so that we're not permanently impacting the database?

142
00:11:07.900 --> 00:11:12.550
And this is, you know, you can choose whether or not you want this capability or not, but I want

143
00:11:12.550 --> 00:11:13.630
to show you how to do this.

144
00:11:14.080 --> 00:11:23.200
OK, so jumping back into the test code here, what we can do is we can actually modify the connection

145
00:11:23.200 --> 00:11:23.560
here.

146
00:11:24.250 --> 00:11:31.300
So currently, every time we connect to the database and we interact with it, and particularly we update

147
00:11:31.300 --> 00:11:39.220
or insert records in to the database, our sequel commands or statements are getting committed to the

148
00:11:39.220 --> 00:11:43.330
database and that's happening for us automatically.

149
00:11:43.480 --> 00:11:45.850
We're not having to explicitly do anything.

150
00:11:45.850 --> 00:11:47.680
In fact, let me show you here.

151
00:11:47.890 --> 00:11:53.860
So if we jump into the save code here, so right here we're calling Execute Update and you can think

152
00:11:53.860 --> 00:11:58.510
of that as like making our inserts occur, right?

153
00:11:58.510 --> 00:12:00.010
Like executing them, right?

154
00:12:00.550 --> 00:12:07.000
Well, those insert statements are actually being what we can call auto committed to the database,

155
00:12:07.180 --> 00:12:09.970
but we can actually turn off the auto commits.

156
00:12:10.450 --> 00:12:16.210
And so if we insert data or update the database in any way at all.

157
00:12:16.600 --> 00:12:22.150
But we don't commit the changes and then we close the database connection.

158
00:12:22.390 --> 00:12:26.630
All of the changes that we did to the database will just go away.

159
00:12:26.650 --> 00:12:27.080
OK.

160
00:12:27.310 --> 00:12:28.810
They won't be committed.

161
00:12:28.810 --> 00:12:31.150
They won't be permanently recorded.

162
00:12:31.390 --> 00:12:37.270
They will look as if they all worked for as long as we have a connection to the database.

163
00:12:37.870 --> 00:12:42.790
But once the database connection is gone, so will be those changes that we made.

164
00:12:43.060 --> 00:12:48.510
So that can give us a cool technique for cleaning up after our tests.

165
00:12:48.520 --> 00:12:54.310
If we can just turn off the auto commits that J.D. is doing by default.

166
00:12:54.550 --> 00:12:58.450
So what we can do for that is to jump back into our test.

167
00:13:00.090 --> 00:13:07.200
And right up here where we're actually opening this connection, we can just make a new line here and

168
00:13:07.200 --> 00:13:09.240
then we can refer to the connection.

169
00:13:09.420 --> 00:13:16.560
And we can actually set auto commit, which call the set out to commit method here, which takes a Boolean.

170
00:13:17.160 --> 00:13:19.800
And can you guess what we need to set for this value?

171
00:13:20.190 --> 00:13:21.480
We can just set it to false.

172
00:13:22.440 --> 00:13:25.650
So that will turn off the auto commit.

173
00:13:26.100 --> 00:13:33.420
And so now we could run these tests five billion times, but we won't have five billion or whatever

174
00:13:33.420 --> 00:13:34.330
the number would be.

175
00:13:34.620 --> 00:13:37.270
Additional records showing up in the database.

176
00:13:37.290 --> 00:13:37.740
OK.

177
00:13:38.100 --> 00:13:46.200
So if we jump back over to the SQL client and make a note that currently we've got here, let's just

178
00:13:46.200 --> 00:13:47.250
do a quick count.

179
00:13:49.410 --> 00:13:56.700
Count select count star from people, so that's how we can count how many records we've currently got

180
00:13:56.700 --> 00:13:57.150
in there.

181
00:13:57.840 --> 00:14:00.450
So you currently have 13 records in the database.

182
00:14:00.600 --> 00:14:03.000
So now I'm going to close the connection.

183
00:14:04.840 --> 00:14:10.180
And no, I don't want to save and then we'll jump back over here and then we'll just run all the tests

184
00:14:10.180 --> 00:14:10.600
again.

185
00:14:12.710 --> 00:14:13.070
OK.

186
00:14:13.190 --> 00:14:16.040
And in fact, let's just run the tests several times.

187
00:14:17.380 --> 00:14:17.890
To.

188
00:14:19.040 --> 00:14:19.670
Three.

189
00:14:20.560 --> 00:14:21.190
For.

190
00:14:22.150 --> 00:14:22.870
Five.

191
00:14:24.400 --> 00:14:25.270
Six times.

192
00:14:25.300 --> 00:14:31.990
OK, cool, so we've run the test six times now we'll jump back over to the SQL client and will reopen

193
00:14:31.990 --> 00:14:33.100
our connection.

194
00:14:35.650 --> 00:14:37.090
And then let's see.

195
00:14:40.250 --> 00:14:45.590
And then we'll recall that select count star from people, and we'll run that again.

196
00:14:47.200 --> 00:14:49.910
And we still only have 13 records.

197
00:14:50.170 --> 00:14:56.350
OK, so we didn't add any additional records to the database permanently.

198
00:14:57.010 --> 00:15:02.680
They did make their way in here, but they all got wiped out at the end of each of those tests.

199
00:15:03.010 --> 00:15:09.400
And so that's a really nice technique, and that's the default way that I usually like to test against

200
00:15:09.400 --> 00:15:10.330
a database.

201
00:15:10.630 --> 00:15:14.500
I like to put my own test data in while the test is running.

202
00:15:14.560 --> 00:15:18.370
And then I want to clean up after myself after the test is done.

203
00:15:18.730 --> 00:15:21.370
OK, jumping back to the I.D. OK.

204
00:15:21.550 --> 00:15:30.070
Another thing that I wanted to do was to confirm what IDs are actually being generated.

205
00:15:30.400 --> 00:15:33.660
And one easy way that we can do that is right here in the saved method.

206
00:15:33.670 --> 00:15:40.930
So if we jump into the save method here, so we're setting the I.D. on the person right person that

207
00:15:40.930 --> 00:15:44.530
set I.D. and then we're returning that person.

208
00:15:44.770 --> 00:15:52.990
So one thing we could do is simply print that person, maybe like right after we set the I.D. so we

209
00:15:52.990 --> 00:15:59.050
can do something like just the system that out and then just pass in the person.

210
00:15:59.290 --> 00:16:03.910
Now we want to make sure that we have a two string method generated on the person class.

211
00:16:03.920 --> 00:16:05.680
So let's jump into person.

212
00:16:05.980 --> 00:16:06.850
And I don't remember.

213
00:16:06.860 --> 00:16:13.150
Yeah, we we don't have one currently, so we can generate one really easily at the bottom here.

214
00:16:13.300 --> 00:16:19.150
Again, I will do a command in Windows users, right click on some black space and then choose Generate,

215
00:16:19.150 --> 00:16:21.460
and then I can choose the two string.

216
00:16:21.490 --> 00:16:22.120
There we go.

217
00:16:23.440 --> 00:16:26.080
And then it asked me what fields I want to include.

218
00:16:26.230 --> 00:16:27.880
And I will include all of them.

219
00:16:29.050 --> 00:16:31.750
Which is already selected and click, OK.

220
00:16:32.170 --> 00:16:33.340
All right, so there we go.

221
00:16:33.850 --> 00:16:36.730
And now if we jump back in to the tests.

222
00:16:38.450 --> 00:16:42.190
And closed down the database connection and rerun these tests.

223
00:16:47.420 --> 00:16:49.820
OK, let's we run the tests.

224
00:16:53.610 --> 00:16:56.860
So now if I click on any one of these tests.

225
00:16:57.510 --> 00:16:58.250
There we go.

226
00:16:58.260 --> 00:17:04.590
So now we can see the IDs are actually being generated person ID 42, that number could only have come

227
00:17:04.590 --> 00:17:10.350
from the database and 43 and then we'll click on this one person test and 44.

228
00:17:11.190 --> 00:17:18.600
Now note, even though we're not committing the inserts of these people records, the IDs are going

229
00:17:18.600 --> 00:17:20.070
to keep incrementing.

230
00:17:20.220 --> 00:17:22.920
That's just how H-2 database is working.

231
00:17:23.100 --> 00:17:28.470
It's still keeping track of the last integers that it generated for each record.

232
00:17:28.470 --> 00:17:35.160
And even though we're not permanently committing those records, it continues to increment those IDs.

233
00:17:35.190 --> 00:17:37.350
OK, so just something to make note of.

234
00:17:37.590 --> 00:17:43.410
Not a big deal, but that's how H-2 and probably a lot of other databases would would happen to work.

235
00:17:43.830 --> 00:17:51.180
OK, so now that we've got these two methods working, I would like to clean up a little tiny bit of

236
00:17:51.180 --> 00:17:53.570
the code duplication.

237
00:17:53.580 --> 00:18:00.420
Also, since the whole point of this test, which is called people repository tests, is to test the

238
00:18:00.420 --> 00:18:03.870
functionality of our people repository class.

239
00:18:04.500 --> 00:18:11.070
That implies that probably every single test method we have in this class is going to need an instance

240
00:18:11.070 --> 00:18:13.650
of the people repository class, right?

241
00:18:14.010 --> 00:18:21.000
And if that's the case, then we probably don't need to be creating it explicitly in each and every

242
00:18:21.000 --> 00:18:22.420
test method, right?

243
00:18:22.920 --> 00:18:28.230
So we can factor that out, maybe as a field of the test class itself.

244
00:18:28.260 --> 00:18:35.370
OK, so we can just put our cursor on repo here and do an option command f four field.

245
00:18:35.970 --> 00:18:41.670
And then it's asking us, as usual, where do we want to set up or initialize this repo?

246
00:18:41.880 --> 00:18:47.940
And currently it's set to do that in the set up, which I think is appropriate because that's also where

247
00:18:47.940 --> 00:18:52.470
we're creating the connection and the connection is needed for the repository.

248
00:18:52.710 --> 00:18:54.450
So that sounds good to me.

249
00:18:54.690 --> 00:18:56.500
I'm going to go ahead and just hit return.

250
00:18:56.520 --> 00:18:56.940
All right.

251
00:18:57.450 --> 00:18:57.840
OK.

252
00:18:57.990 --> 00:19:00.480
And so now that repo has disappeared.

253
00:19:00.510 --> 00:19:03.330
Take note, though, that it did not disappear from down here.

254
00:19:03.510 --> 00:19:05.490
OK, so we will need to clean that up.

255
00:19:05.920 --> 00:19:07.560
In fact, let's just go and do it now.

256
00:19:07.560 --> 00:19:11.730
So I'm just putting my cursor on line 44, and then I'm just going to delete that line with a command

257
00:19:11.730 --> 00:19:15.090
delete or control y for Windows and Linux.

258
00:19:15.240 --> 00:19:15.600
All right.

259
00:19:15.840 --> 00:19:23.010
So what happened now is we got a new field, an additional field of type people repository, which we

260
00:19:23.010 --> 00:19:24.120
are calling repo.

261
00:19:24.660 --> 00:19:32.280
But then down here in the setup method is where we're actually initializing it to a new people repository.

262
00:19:32.520 --> 00:19:35.430
And there's our connection that came right from above.

263
00:19:35.490 --> 00:19:35.910
Right.

264
00:19:36.690 --> 00:19:45.720
Just like so and so now this repo that we are referring to both here and here and here are the field

265
00:19:46.290 --> 00:19:47.860
repo of the class.

266
00:19:47.880 --> 00:19:48.360
OK?

267
00:19:48.720 --> 00:19:53.130
And that just means that we're only creating one instance of it per test method, and it's happening

268
00:19:53.130 --> 00:19:55.050
automatically up here for us.

269
00:19:55.380 --> 00:19:55.680
All right.

270
00:19:55.690 --> 00:20:00.990
So now let's jump into the save method and see what other kinds of things we can do in here.

271
00:20:01.020 --> 00:20:02.340
OK, so a couple of things.

272
00:20:02.350 --> 00:20:09.360
So first thing I see is I think we can do something a little better with this sequel here.

273
00:20:10.560 --> 00:20:18.270
Typically, when you have a class that has SQL inside of it, we may prefer to define that SQL code

274
00:20:18.270 --> 00:20:21.330
as a string constant on the class.

275
00:20:21.510 --> 00:20:27.480
Right now, it's just stored in a local variable here, a local string that's local to the save method.

276
00:20:27.660 --> 00:20:32.700
But it's more typical, I'd say, to extract that into a constant.

277
00:20:32.910 --> 00:20:37.560
OK, just so that it's like kind of really in your face within the class itself.

278
00:20:37.800 --> 00:20:40.830
And so we can convert this into a constant really easily.

279
00:20:41.190 --> 00:20:46.860
I'm just going to select the sequel here and then do an option Command C for constant.

280
00:20:47.310 --> 00:20:48.510
OK, like that.

281
00:20:48.990 --> 00:20:51.060
And then I can name this something.

282
00:20:51.300 --> 00:20:56.060
And typically, you might want to call it something that's based on what it's doing.

283
00:20:56.310 --> 00:21:01.770
So it's saving a person or inserting a person, whatever you want to do.

284
00:21:02.040 --> 00:21:06.210
So and because it's a constant, it should be all uppercase, by the way.

285
00:21:06.210 --> 00:21:11.700
So I don't know if we can call it save underscore person now.

286
00:21:12.000 --> 00:21:17.010
You don't use camel case because it's all uppercase, so you'll use an underscore and save person.

287
00:21:17.010 --> 00:21:22.560
And then you may frequently also see something like underscore scale, you know, something something

288
00:21:22.560 --> 00:21:23.580
along those lines.

289
00:21:23.730 --> 00:21:28.320
Well, I also could have named it insert person that that probably would have been fine, too.

290
00:21:28.380 --> 00:21:28.730
All right.

291
00:21:28.740 --> 00:21:29.940
And return.

292
00:21:30.360 --> 00:21:30.710
All right.

293
00:21:30.720 --> 00:21:36.840
So now we've got this public static final constant called Safe Person sequel, and there's our sequel

294
00:21:36.840 --> 00:21:40.080
there and there's the variable right there.

295
00:21:40.440 --> 00:21:46.800
So like I said, that's a pretty common pattern that you'll see any time their sequel embedded within

296
00:21:46.800 --> 00:21:47.490
a class.

297
00:21:47.730 --> 00:21:48.600
OK.

298
00:21:48.930 --> 00:21:52.620
And then let's just do a quick run through here as a reminder of.

299
00:21:52.800 --> 00:21:56.340
All of what has to happen for this type of code to work.

300
00:21:56.550 --> 00:22:00.660
So we need a connection which we happen to be creating in the test.

301
00:22:00.930 --> 00:22:06.900
Now I could have chosen to create this connection in this class, like I could have done it right here

302
00:22:06.900 --> 00:22:08.760
in the constructor, in fact.

303
00:22:08.790 --> 00:22:09.120
Right.

304
00:22:09.330 --> 00:22:13.230
The the the driver manager talked connection and all of that.

305
00:22:13.440 --> 00:22:15.480
We could have done it anywhere in this class.

306
00:22:15.480 --> 00:22:17.280
We could have done it in this test method.

307
00:22:17.280 --> 00:22:19.170
We could have done it here in the constructor.

308
00:22:19.650 --> 00:22:28.590
I chose not to do it here, though, because I knew that I was going to want to have a little bit more

309
00:22:28.590 --> 00:22:37.950
flexibility with being able to turn on or off the auto commit behavior and controlling the auto commit

310
00:22:37.950 --> 00:22:41.400
behavior has everything to do with running the tests.

311
00:22:41.850 --> 00:22:50.340
But keep in mind, in real life, this people repository class would not just be getting called from

312
00:22:50.340 --> 00:22:51.130
a test.

313
00:22:51.150 --> 00:22:55.710
It would be getting called from your real code right from a real working application.

314
00:22:55.980 --> 00:22:59.370
And so you certainly wouldn't want to set the connections.

315
00:22:59.730 --> 00:23:07.080
Auto commit property to false under normal real world circumstances where you're running the application

316
00:23:07.080 --> 00:23:09.240
for real and not via a test.

317
00:23:09.600 --> 00:23:15.960
So you wouldn't want that code to be here where you're setting that out or commit to false.

318
00:23:16.020 --> 00:23:22.770
Right now, you could write some conditional code that would check some kind of a property or something

319
00:23:22.770 --> 00:23:26.100
to know whether or not it should auto commit or not.

320
00:23:26.340 --> 00:23:33.990
But the easier thing to do in a lot of ways is to just not even create the connection within this repository

321
00:23:33.990 --> 00:23:36.620
and instead created somewhere else.

322
00:23:36.690 --> 00:23:37.200
OK.

323
00:23:37.230 --> 00:23:41.070
And that way, it makes it easy to do all kinds of different testing.

324
00:23:41.370 --> 00:23:46.830
We might want to write tests that don't even actually make a real connection to a real database.

325
00:23:47.340 --> 00:23:53.910
Or we might want this people repository to be very flexible in terms of what database it actually can

326
00:23:53.910 --> 00:23:54.780
connect to.

327
00:23:54.960 --> 00:24:00.570
Right now, it happens to be connecting to H2, but we might want it in the future to be able to connect

328
00:24:00.570 --> 00:24:03.180
to an Oracle database or something else.

329
00:24:03.750 --> 00:24:09.800
So it's kind of nice to allow this class to not have to care about quite that level of details.

330
00:24:10.380 --> 00:24:10.830
OK.

331
00:24:10.920 --> 00:24:13.650
We can kind of push those details somewhere else.

332
00:24:13.920 --> 00:24:21.690
Now also, this people repository class has what's called a dependency on the connection.

333
00:24:21.780 --> 00:24:22.290
OK.

334
00:24:22.500 --> 00:24:30.540
And by us being able to pass our connection dependency in to the people repository, we are making use

335
00:24:30.540 --> 00:24:36.540
of another very, very popular design pattern, which is called dependency injection.

336
00:24:37.170 --> 00:24:45.990
So instead of our class, that depends on the connection existing creating its own connection, we inject

337
00:24:45.990 --> 00:24:52.710
a connection into the class as we are doing here and we happen to be doing it right now via the constructor.

338
00:24:52.830 --> 00:24:58.320
We could also have created a setter method on this class and pushed it into the center.

339
00:24:58.590 --> 00:25:03.240
I chose not to do that because using the constructor in this case was just much more straightforward,

340
00:25:03.240 --> 00:25:03.900
number one.

341
00:25:03.990 --> 00:25:12.720
And secondly, it's conceptually invalid to even have a people repository instance without a connection.

342
00:25:13.200 --> 00:25:21.090
And so in terms of coding, the best way to codify the fact that you can't have a people repository

343
00:25:21.090 --> 00:25:27.990
without a connection is to simply make the people repositories constructor accept a connection.

344
00:25:28.200 --> 00:25:33.150
I'm basically saying you can't create a PayPal repository without passing any connection.

345
00:25:33.420 --> 00:25:33.840
OK.

346
00:25:34.320 --> 00:25:41.880
Whereas if I had allowed the people repository class to be created with a no ARG constructor and then

347
00:25:41.880 --> 00:25:47.820
I had an additional setter method for the connection that would imply that maybe it's OK to create a

348
00:25:47.820 --> 00:25:50.100
people repository without a connection.

349
00:25:50.190 --> 00:25:52.800
But what would happen if you did that and then you tried to call save?

350
00:25:53.130 --> 00:25:56.370
This code would blow up immediately right here, right?

351
00:25:57.090 --> 00:26:00.720
So this is semantically speaking a better pattern.

352
00:26:00.960 --> 00:26:08.250
So after we have our connection established, we can then create some type of a statement to allow us

353
00:26:08.280 --> 00:26:10.230
to execute some sequel.

354
00:26:10.680 --> 00:26:14.960
And there are two primary types of statements that we can create.

355
00:26:14.970 --> 00:26:18.780
We can create a prepared statement, or we can just create a statement.

356
00:26:18.810 --> 00:26:19.120
OK?

357
00:26:19.140 --> 00:26:24.960
There's another method on the connection class that we saw and that was create statement.

358
00:26:28.280 --> 00:26:30.680
Right, right there, create statement.

359
00:26:30.720 --> 00:26:37.760
OK, now I told you that we were going to use the prepared statement, and I want to tell you a little

360
00:26:37.760 --> 00:26:39.530
bit more about the prepared statement now.

361
00:26:39.780 --> 00:26:45.050
Now we chose to use the prepared statement primarily for two big reasons, and I only touched on one

362
00:26:45.050 --> 00:26:46.340
in the previous lesson.

363
00:26:47.120 --> 00:26:55.400
The first reason is because we have these parameters here that need to be bound to fields in the person

364
00:26:55.400 --> 00:26:56.510
class, OK?

365
00:26:56.840 --> 00:27:02.960
And the prepared statement gives us a really straightforward way of binding these values.

366
00:27:02.990 --> 00:27:09.950
OK, now we could have done this without using a prepared statement by using just a regular statement.

367
00:27:10.100 --> 00:27:15.980
But if we had used a regular statement, then we would have had to use some string concatenation tricks

368
00:27:15.980 --> 00:27:17.360
to get these values in here.

369
00:27:17.360 --> 00:27:24.470
In other words, we would have had to hard code these values into the values area of our insert statement

370
00:27:24.710 --> 00:27:28.220
and lots of database code in Java has been written in that way.

371
00:27:28.430 --> 00:27:34.880
But I'm going to tell you right now if you've got parameters that you need to pass in using a statement,

372
00:27:34.880 --> 00:27:41.900
a regular statement and using string concatenation is like the worst possible way to get those parameters

373
00:27:41.900 --> 00:27:42.320
in there.

374
00:27:42.530 --> 00:27:50.150
And the reason for this has to do with a major security flaw that exists in lots of code not only just

375
00:27:50.150 --> 00:27:53.420
Java, it's called SQL injection.

376
00:27:53.840 --> 00:27:59.390
Now I'm not going to go super deep right now into all of the details of SQL injection, but the basic

377
00:27:59.390 --> 00:28:06.350
just is this if we had used string concatenation, it might have been possible.

378
00:28:06.350 --> 00:28:13.130
Let's imagine that this code here is part of a web application where there's a web page and the web

379
00:28:13.130 --> 00:28:17.120
page asks people to enter their first name, last name, date of birth.

380
00:28:17.150 --> 00:28:17.570
OK.

381
00:28:17.780 --> 00:28:24.200
And let's say that there is a malicious and intelligent hacker who wants to hack into our application

382
00:28:24.200 --> 00:28:25.730
and still all of our data.

383
00:28:27.170 --> 00:28:34.880
One thing that they might try to do is to utilize this SQL injection technique, and the way they would

384
00:28:34.880 --> 00:28:42.860
do that is that they would try to guess that maybe the developer who wrote the code for this web application

385
00:28:43.100 --> 00:28:50.210
wasn't very knowledgeable, and maybe they used an insert statement kind of like this, and they used

386
00:28:50.270 --> 00:28:55.580
string concatenation to set the first name, last name and date of birth.

387
00:28:55.820 --> 00:28:59.810
Fields here, if they had done that, then what?

388
00:29:00.020 --> 00:29:03.260
What that hacker could do is they could set.

389
00:29:03.350 --> 00:29:05.050
I'm going to use some pseudocode here.

390
00:29:05.060 --> 00:29:05.960
Let me do it right here.

391
00:29:06.260 --> 00:29:12.410
So what they could do is instead of just typing Frank just like that for their first name in the first

392
00:29:12.410 --> 00:29:19.850
name field of a web page, instead of doing that, they might do something like add a single tick here

393
00:29:19.850 --> 00:29:27.410
and then a comma and then Jackson or, you know, a last name, comma and then a date of birth.

394
00:29:28.460 --> 00:29:33.800
1950, blah blah, blah, blah, blah blah, and then now, no, no, now.

395
00:29:34.220 --> 00:29:36.340
Mind you, they're typing all of that.

396
00:29:36.350 --> 00:29:41.310
All of this just in the first named field of a web page.

397
00:29:41.330 --> 00:29:41.810
OK.

398
00:29:42.140 --> 00:29:48.380
And then what they might do is put a closing parentheses here and maybe even a semicolon.

399
00:29:48.710 --> 00:29:54.080
And then they could do something like select star from.

400
00:29:54.260 --> 00:29:58.880
And then maybe they just guess that the name of our table is called people.

401
00:29:59.960 --> 00:30:00.560
Like that.

402
00:30:01.280 --> 00:30:03.560
So what would end up happening is.

403
00:30:04.690 --> 00:30:11.830
All of that would then just get upended into some field here.

404
00:30:12.040 --> 00:30:12.290
Right.

405
00:30:12.310 --> 00:30:14.980
And since we're not using question marks anymore, right?

406
00:30:15.310 --> 00:30:18.520
These would just be appended via a strengthened cat nation.

407
00:30:18.530 --> 00:30:24.340
Maybe they do it on the last name field or on the date of birth field so that it all kind of just matches

408
00:30:24.340 --> 00:30:25.510
up kind of nicely.

409
00:30:25.550 --> 00:30:26.740
OK, somehow.

410
00:30:27.640 --> 00:30:37.330
So the basic idea is that they can kind of hijack our sequel so that they can get this extra code right

411
00:30:37.330 --> 00:30:39.340
here to execute somehow.

412
00:30:39.490 --> 00:30:47.110
And depending on how badly we wrote our database code, our database code might have allowed this to

413
00:30:47.110 --> 00:30:53.230
execute and for the output of this to make its way back to the web browser.

414
00:30:53.650 --> 00:30:57.400
Now, in our case, we don't have a web browser, we're not writing a web application and all of that.

415
00:30:57.400 --> 00:31:01.990
But that's the gist of how SQL injection works, OK?

416
00:31:02.440 --> 00:31:12.010
But by using a prepared statement, this is not possible because with a prepared statement, every parameter

417
00:31:12.010 --> 00:31:18.400
that we're expecting to read in is constrained to just it's one little bit of data.

418
00:31:18.580 --> 00:31:25.600
So in other words, this name Frank here is the only value that can actually be allowed in here, and

419
00:31:25.600 --> 00:31:29.500
all the rest of this stuff would just cause an exception to be thrown.

420
00:31:29.530 --> 00:31:30.010
OK.

421
00:31:30.400 --> 00:31:39.880
And so the rule to live by when when you're writing JTBC code is if you've got parameters that you need

422
00:31:39.880 --> 00:31:43.660
to bind to outside data and by outside data.

423
00:31:43.660 --> 00:31:48.210
I mean, in this case, our person class use a prepared statement.

424
00:31:48.220 --> 00:31:50.560
OK, always use a prepared statement.

425
00:31:51.490 --> 00:31:56.440
And that will save you from this particular level of SQL injection.

426
00:31:56.920 --> 00:31:57.350
All right.

427
00:31:57.370 --> 00:32:03.730
So that was this a quick reminder between using the prepared statement versus just they create statement

428
00:32:04.210 --> 00:32:11.410
they both led us eventually executed some SQL, but one is really good if you need to bind parameters.

429
00:32:11.620 --> 00:32:17.680
If you're not binding any parameters, like if you just had a select star from people and that was all

430
00:32:17.680 --> 00:32:20.020
you were doing and that passing in any parameters.

431
00:32:20.290 --> 00:32:25.570
Maybe in that case, the create statement might be sufficient, but as soon as you've got some parameters

432
00:32:25.570 --> 00:32:30.640
to pass in use, a prepared statement and actually there's a third advantage of prepared statements

433
00:32:30.640 --> 00:32:32.050
as well that I almost forgot.

434
00:32:32.320 --> 00:32:41.290
And that is the fact that prepared statements can be prepared, meaning that the sequel code for a prepared

435
00:32:41.290 --> 00:32:49.570
statement actually gets an opportunity to be analyzed and optimized by the database before it actually

436
00:32:49.570 --> 00:32:57.220
gets executed, which means that prepared statements actually can execute more efficiently than regular

437
00:32:57.220 --> 00:32:57.940
statements.

438
00:32:58.060 --> 00:33:03.490
So there's another reason to really just stick with prepared statements most of the time.

439
00:33:03.680 --> 00:33:09.010
OK, now there's other ways to execute code on a database, by the way, besides statements and prepared

440
00:33:09.010 --> 00:33:09.520
statements.

441
00:33:09.760 --> 00:33:15.130
You can also have things like stored procedures, which are kind of like functions or methods that live

442
00:33:15.130 --> 00:33:17.470
and execute on the database itself.

443
00:33:17.830 --> 00:33:20.350
I don't think we'll be getting into any of that here, though.

444
00:33:20.530 --> 00:33:22.690
But yeah, prepared statements are your friend.

445
00:33:22.720 --> 00:33:23.140
All right.

446
00:33:23.290 --> 00:33:29.200
So we called this prepared statement passed in our school and then because we knew that we wanted to

447
00:33:29.200 --> 00:33:34.210
be able to capture any IDs or keys that were generated.

448
00:33:34.390 --> 00:33:42.010
We also told our connection that we wanted it to return any generated keys, so we needed to do that

449
00:33:42.010 --> 00:33:42.520
here.

450
00:33:42.550 --> 00:33:43.060
OK.

451
00:33:43.660 --> 00:33:51.760
So then after that, we bound all of our three parameters to the school's statement up here.

452
00:33:52.690 --> 00:33:56.060
And to do so, we had to specify what the data type was.

453
00:33:56.080 --> 00:34:01.930
So this is really just allowing us to translate our Java data types into SQL data type.

454
00:34:01.950 --> 00:34:07.870
So the search string becomes of our car, the set timestamp becomes a timestamp essentially right.

455
00:34:07.900 --> 00:34:13.570
And there are several other data types that we can bind to for Boolean and things of that sort, and

456
00:34:14.230 --> 00:34:17.770
we'll probably play around with a few more of those in future lessons.

457
00:34:18.040 --> 00:34:18.310
All right.

458
00:34:18.310 --> 00:34:25.570
So here we're binding all of our parameters and then we actually just execute right here, and there

459
00:34:25.570 --> 00:34:28.210
are a few different flavors of the execute method.

460
00:34:28.660 --> 00:34:34.990
So if you're making updates to the database, you can call execute update, and that will actually return

461
00:34:34.990 --> 00:34:40.060
an integer which lets you know how many records were affected, which is why we're capturing that right

462
00:34:40.060 --> 00:34:40.450
here.

463
00:34:40.900 --> 00:34:47.230
So this method specifically can be utilized if the SQL that you're executing is doing an insert, an

464
00:34:47.230 --> 00:34:48.760
update or delete.

465
00:34:48.910 --> 00:34:49.390
OK.

466
00:34:50.050 --> 00:34:56.110
So if you're just doing a select, you would not use execute update for select because you're not updating

467
00:34:56.110 --> 00:34:57.360
anything in the database.

468
00:34:57.370 --> 00:35:00.610
In that circumstance, you're just reading out of the database.

469
00:35:02.110 --> 00:35:07.390
And and we'll we'll be doing some selects in future lessons, so we'll get a chance to play around with

470
00:35:07.390 --> 00:35:09.310
some of the other forms of execute.

471
00:35:09.520 --> 00:35:09.790
All right.

472
00:35:09.800 --> 00:35:15.640
So we execute and we can find out if the one record that should have been inserted got inserted because

473
00:35:15.640 --> 00:35:22.030
we'll get back, presumably a one and then we can call that get generated keys, which returns something

474
00:35:22.030 --> 00:35:23.170
called a result set.

475
00:35:23.440 --> 00:35:30.270
So you can think of the results set either as an ArrayList or as just a two dimensional array.

476
00:35:30.280 --> 00:35:35.650
In fact, maybe it's better to even think of it explicitly as a two dimensional array, and it behaves

477
00:35:35.650 --> 00:35:45.070
very similarly to an iterator in that you have to call a dot next method on it to iterate over the rows

478
00:35:45.340 --> 00:35:46.630
that exist within it.

479
00:35:46.870 --> 00:35:50.800
So if you think of it as a two dimensional array, that's basically a spreadsheet, right?

480
00:35:51.130 --> 00:35:58.390
And so each row would be one person, so you can think of it as having rows and columns.

481
00:35:58.420 --> 00:35:58.930
OK.

482
00:36:00.220 --> 00:36:04.810
Each time we call our escort next, we're just going to the next row.

483
00:36:04.840 --> 00:36:05.320
OK.

484
00:36:05.830 --> 00:36:12.640
So when we call that get generated keys, the way you can think of it is a spreadsheet with, in this

485
00:36:12.640 --> 00:36:22.240
case, one row and one column, and that one row in one column is going to contain the I.D. that got

486
00:36:22.240 --> 00:36:26.540
generated for the row that we just inserted into the database.

487
00:36:26.590 --> 00:36:27.070
OK.

488
00:36:27.370 --> 00:36:31.700
And so we're calling our next, which takes us to that first row.

489
00:36:31.720 --> 00:36:38.950
If there was a row and then we can call R-Sport, get long from column one and there's only one column

490
00:36:38.950 --> 00:36:45.130
in this particular result, and we're just calling long because these are IDs and IDs can be pretty

491
00:36:45.130 --> 00:36:50.410
large numbers, so it's appropriate to use something like along in this case.

492
00:36:50.740 --> 00:36:55.320
And then we capture that long and then set it on our idea of the person.

493
00:36:55.330 --> 00:37:01.090
So the main thing to remember here is that we're getting results set and you should just think of a

494
00:37:01.090 --> 00:37:07.240
results set as a two dimensional array and you should think of a two dimensional array as a spreadsheet,

495
00:37:07.360 --> 00:37:07.720
right?

496
00:37:07.840 --> 00:37:10.450
We've got rows and columns.

497
00:37:10.600 --> 00:37:11.080
OK.

498
00:37:11.530 --> 00:37:16.090
OK, so that's going to wrap it up for this lesson.

499
00:37:16.090 --> 00:37:21.730
And in the next lesson, we'll jump in to some more use cases because we've got basically all of the

500
00:37:21.730 --> 00:37:24.700
create read update delete type methods.

501
00:37:24.700 --> 00:37:30.310
The crud methods can all be implemented now in Java code, and so we're going to just run through them

502
00:37:30.310 --> 00:37:30.610
all.

503
00:37:30.970 --> 00:37:31.390
All right.

504
00:37:31.420 --> 00:37:32.410
See you in the next one.
