1
00:00:00,540 --> 00:00:00,940
All right.

2
00:00:00,960 --> 00:00:07,500
So in the last lesson, we did a little bit of cleaning up of our previously written code where we implemented

3
00:00:07,500 --> 00:00:15,200
the ability to save a person in this lesson will jump to another one of the standard crud operations.

4
00:00:15,210 --> 00:00:19,380
And if you'll recall, crud stands for create, read, update and delete.

5
00:00:19,590 --> 00:00:24,960
So in this lesson, we're going to implement the ability to find a person by their ID.

6
00:00:25,470 --> 00:00:31,630
And again, we'll start with our test in the interest of test driven development or TDD.

7
00:00:32,280 --> 00:00:32,550
All right.

8
00:00:32,550 --> 00:00:39,720
So here we are back in the people repository tests class and we're going to go ahead and start with

9
00:00:39,720 --> 00:00:40,680
another test here.

10
00:00:40,710 --> 00:00:44,790
So like I said, we're going to be implementing the ability to find a person by ID.

11
00:00:45,450 --> 00:00:48,250
So let's create a test.

12
00:00:48,270 --> 00:00:50,250
We'll start with the annotation for Test.

13
00:00:50,610 --> 00:01:00,360
Public void as all J unit test methods have to be and I don't know, let's just call this can find person

14
00:01:00,360 --> 00:01:01,350
by ID.

15
00:01:03,610 --> 00:01:09,040
And I think I've stated this before, but I try not to get too hung up on what I'm going to name these

16
00:01:09,040 --> 00:01:13,460
test methods initially, even though I know what I'm going for.

17
00:01:13,480 --> 00:01:18,270
I don't always want to take a lot of time to come up with the perfect name for the methods.

18
00:01:18,280 --> 00:01:23,950
Usually, I find that as I implement the test method a little bit further, then a better name comes

19
00:01:23,950 --> 00:01:26,800
to me, although I think this name is probably going to be fine.

20
00:01:27,130 --> 00:01:35,050
So if this test is going to test our ability to find a person by an ID, we'd have to first know an

21
00:01:35,050 --> 00:01:37,540
idea of a person that we want to find.

22
00:01:38,800 --> 00:01:45,100
Now some of you may be tempted to just go pop over to the database and see what records are out there

23
00:01:45,100 --> 00:01:49,180
and take an idea of one of those records and then use that.

24
00:01:49,420 --> 00:01:52,210
And that certainly would work for right now.

25
00:01:52,510 --> 00:02:01,930
However, in order to have our tests be as robust as possible, the ideal situation in most cases is

26
00:02:01,930 --> 00:02:07,870
to have your test methods set up whatever data they are depending on, and then test against that data

27
00:02:07,870 --> 00:02:12,460
and then likely have those test methods clear out that data as well.

28
00:02:12,730 --> 00:02:19,060
So in other words, it would be better to assume that people with IDs that might happen to be in the

29
00:02:19,060 --> 00:02:25,150
database right now won't be there in the future, because if those records get cleared out for whatever

30
00:02:25,150 --> 00:02:30,040
reason, the records that are already out there in the database right now, that test, that's depending

31
00:02:30,040 --> 00:02:32,440
on those records existing there will fail.

32
00:02:32,710 --> 00:02:35,140
And it won't be because your code doesn't work.

33
00:02:35,140 --> 00:02:40,840
It'll be because your test made assumptions as to whether or not those particular records were there.

34
00:02:41,020 --> 00:02:49,360
So a better technique in most cases is to actually have this test method insert data that it knows is

35
00:02:49,360 --> 00:02:49,840
there.

36
00:02:50,140 --> 00:02:56,260
Then it will test whether or not it can find a person by a certain I.D. and then it can just clear it

37
00:02:56,260 --> 00:02:56,770
all out.

38
00:02:57,040 --> 00:02:58,750
So let me show you how we can do that.

39
00:02:58,990 --> 00:03:05,350
Now there's at least a couple of ways that we could go about inserting known data into our test data

40
00:03:05,350 --> 00:03:06,760
into the database.

41
00:03:07,210 --> 00:03:13,810
The easiest way that I can think of at the moment would be to go ahead and just rely on our save method

42
00:03:13,810 --> 00:03:19,210
that we've already implemented, so we could actually just create a person and then call Repo Dot Save

43
00:03:19,210 --> 00:03:25,300
to save that person from within this test method here and now, we'd have a person that we know is there,

44
00:03:25,330 --> 00:03:29,260
and then we can turn right back around and find that person by ID.

45
00:03:30,160 --> 00:03:38,110
Another approach would be to actually write the sequel insert code in our test method using this connection.

46
00:03:38,290 --> 00:03:46,150
So in other words, we could do a, you know, connection that prepared statement insert into people

47
00:03:46,150 --> 00:03:47,680
blah blah blah blah blah, right?

48
00:03:47,680 --> 00:03:49,660
Insert a whole person in there and all of that.

49
00:03:49,870 --> 00:03:55,300
So there can be pros and cons to either of these approaches with the approach of creating a prepared

50
00:03:55,300 --> 00:04:02,620
statement within this test method and then doing the insert in everything, we remove ourselves from

51
00:04:02,620 --> 00:04:04,750
any assumptions that are repo.

52
00:04:04,750 --> 00:04:07,030
That save method works right.

53
00:04:07,240 --> 00:04:13,990
So we just get away from that completely, and we insert our test data that we need for our test purposes

54
00:04:14,230 --> 00:04:21,400
independently of the system under test and the system under test is the repo repository.

55
00:04:21,970 --> 00:04:28,240
However, that means that we'd have to do a little more work number one by, you know, creating this

56
00:04:28,240 --> 00:04:30,490
connection, that prepared statement and all of that.

57
00:04:30,790 --> 00:04:37,480
And very likely, we'd be duplicating a fair amount of the code that already exists in the repo class

58
00:04:37,480 --> 00:04:38,080
itself.

59
00:04:38,380 --> 00:04:41,560
So like I said, there's kind of pros and cons to that approach.

60
00:04:41,560 --> 00:04:48,160
In this particular case, I'm fairly comfortable not to go this route and instead to simply call Repo

61
00:04:48,160 --> 00:04:56,800
Dot Save to save our test data within the confined person by ID test method because I feel fairly comfortable

62
00:04:56,800 --> 00:05:00,100
that we've done enough testing on the safe person.

63
00:05:00,250 --> 00:05:03,880
And by the way, there's certainly more that we could test with this repo.

64
00:05:03,880 --> 00:05:04,480
Don't save.

65
00:05:04,840 --> 00:05:10,360
But I do feel that we've got enough that I'm confident that repo, that save is doing its job right.

66
00:05:10,660 --> 00:05:17,920
And so I'm inclined to go ahead and just use the repo that save method to insert a test person into

67
00:05:17,920 --> 00:05:18,610
the database.

68
00:05:18,790 --> 00:05:23,170
But these are certainly questions and thoughts that you should have things that you should be thinking

69
00:05:23,170 --> 00:05:27,790
about when you're writing these kinds of tests, especially when you're dealing with a database.

70
00:05:27,940 --> 00:05:30,190
Where's my test data going to come from?

71
00:05:30,280 --> 00:05:35,500
Am I just assuming that the test data that I need is already in the database, which is almost always

72
00:05:35,500 --> 00:05:36,490
a bad assumption?

73
00:05:36,700 --> 00:05:40,510
Or do I have a way that I can get test data into the database?

74
00:05:40,930 --> 00:05:47,410
All right, so let's go ahead and get a person, a test person into the database, someone going delete

75
00:05:47,410 --> 00:05:48,160
that line.

76
00:05:48,790 --> 00:05:56,410
And so we will call repo that save and then we can just create a new person in line, perhaps, and

77
00:05:56,800 --> 00:05:58,810
we don't really care about this person too much.

78
00:05:58,810 --> 00:06:01,390
So I'm just going to call this person test.

79
00:06:02,970 --> 00:06:11,220
Jackson, and they'll need a date of birth, and we'll do a zone date time and the date of birth doesn't

80
00:06:11,220 --> 00:06:13,830
really even matter either, so I'm going to do now.

81
00:06:15,410 --> 00:06:18,150
Because that's like the easiest way for me to create a zone.

82
00:06:18,290 --> 00:06:19,070
Date time.

83
00:06:19,100 --> 00:06:19,400
All right.

84
00:06:19,400 --> 00:06:20,480
So there's that person.

85
00:06:20,630 --> 00:06:24,620
So the idea here is that we're going to create this person, save them into the database, then we're

86
00:06:24,620 --> 00:06:31,400
going to turn around and try to find that person by their I.D., which means we need their ID.

87
00:06:31,910 --> 00:06:38,690
So that means I need to capture the output of this save method because the save method is going to return

88
00:06:38,690 --> 00:06:41,870
back the person with their ID filled in, right?

89
00:06:42,320 --> 00:06:42,920
So.

90
00:06:44,480 --> 00:06:47,990
We can do this, and I will call this saved person.

91
00:06:49,570 --> 00:06:49,960
All right.

92
00:06:50,230 --> 00:06:52,300
So there's that that saved person.

93
00:06:52,540 --> 00:06:57,040
So then we're going to turn around and call Repo Dot, find buy it.

94
00:06:57,170 --> 00:07:00,110
Now keep in mind, this method does not exist yet.

95
00:07:00,130 --> 00:07:01,610
This is us doing TDD.

96
00:07:01,750 --> 00:07:07,660
We are writing the code for the Future State that we want the repo to behave in.

97
00:07:07,840 --> 00:07:10,590
So we want to have a method called find by ID.

98
00:07:11,200 --> 00:07:14,770
And that method is going to take as an input an ID.

99
00:07:15,010 --> 00:07:18,970
So I can reference save the person, not get ID like so.

100
00:07:19,300 --> 00:07:27,430
And this method will be expected to return a person and I will call this person found person.

101
00:07:28,390 --> 00:07:28,840
OK.

102
00:07:29,080 --> 00:07:36,040
So we're going to have a method called Find a B ID, find ID that will take an ID as an input and then

103
00:07:36,040 --> 00:07:38,290
return back the person that it found.

104
00:07:38,440 --> 00:07:38,890
OK.

105
00:07:40,070 --> 00:07:47,270
All right, so let's go ahead and satisfy the idea here with that red fine by IDs, I'm putting my cursor

106
00:07:47,270 --> 00:07:55,310
right there on the find my ID and I'm going to do an option return and I'm going to let the I.D. create

107
00:07:55,310 --> 00:07:58,460
this method in the people repository class.

108
00:07:58,850 --> 00:07:59,200
All right.

109
00:07:59,210 --> 00:08:04,220
So yeah, it's suggesting that it will create this method fine by ID that will return a person one hit

110
00:08:04,220 --> 00:08:06,830
enter and it will take an input of a long ID.

111
00:08:07,310 --> 00:08:08,000
That's fine.

112
00:08:08,300 --> 00:08:09,860
I'm good with all of that for now.

113
00:08:10,160 --> 00:08:10,580
OK.

114
00:08:10,880 --> 00:08:17,360
And so then I will do a command shift to jump back over or control shift for Windows and Linux and jump

115
00:08:17,360 --> 00:08:18,890
back over to the test class.

116
00:08:19,040 --> 00:08:23,420
And now the fine by ID method reference there is no longer read.

117
00:08:23,690 --> 00:08:24,000
All right.

118
00:08:24,020 --> 00:08:33,650
And now I need an assertion, so I will assert that the found persons I.D..

119
00:08:36,100 --> 00:08:41,110
Is equal to the saved person's Heidi.

120
00:08:42,260 --> 00:08:42,590
Right.

121
00:08:42,620 --> 00:08:44,090
That's pretty straightforward, right?

122
00:08:45,050 --> 00:08:47,390
All right, so let's run this and see it fell.

123
00:08:48,720 --> 00:08:56,100
And keep in mind, in TDD, you write a test, you satisfy enough of the code to not have red marks

124
00:08:56,100 --> 00:08:57,240
and things like that.

125
00:08:58,020 --> 00:08:59,390
Then you run the test.

126
00:08:59,430 --> 00:09:04,050
It should fail because you won't have implemented any of the necessary logic yet.

127
00:09:04,620 --> 00:09:09,120
Then you go implement just enough logic to make the test pass.

128
00:09:09,480 --> 00:09:16,290
Then you flesh out some more and you keep repeating this cycle until eventually you have enough working

129
00:09:16,290 --> 00:09:17,190
functionality.

130
00:09:17,370 --> 00:09:23,640
And sometimes that will require you to write multiple tests to force yourself to write all of the code

131
00:09:23,640 --> 00:09:24,510
that's needed.

132
00:09:24,960 --> 00:09:26,370
All right, so let's run this.

133
00:09:27,780 --> 00:09:29,070
OK, so it's failing.

134
00:09:29,070 --> 00:09:35,850
I'm going to click here on the failed test method and see what it's failing on.

135
00:09:36,600 --> 00:09:42,990
So it's saying cannot invoke the person that get ID method because the found person is null and that

136
00:09:42,990 --> 00:09:44,580
makes sense, right?

137
00:09:44,940 --> 00:09:45,290
All right.

138
00:09:45,300 --> 00:09:50,460
So we know that it's not all because that's what the ADA implemented will jump over here into the repo.

139
00:09:50,460 --> 00:09:52,290
That fine by ID method here.

140
00:09:52,290 --> 00:09:53,090
And there you go.

141
00:09:53,100 --> 00:09:54,690
There's the null right there.

142
00:09:55,200 --> 00:10:03,540
So perhaps the first and easiest thing we can do is just to create a very simple person instance right

143
00:10:03,540 --> 00:10:03,790
here.

144
00:10:03,810 --> 00:10:07,350
So let's see what that will look like, new person.

145
00:10:08,310 --> 00:10:13,470
And I'm going to keep it really simple and not even put any information in your hardly at all.

146
00:10:14,340 --> 00:10:15,810
So zoned datetime.

147
00:10:15,810 --> 00:10:16,080
I don't know.

148
00:10:16,110 --> 00:10:17,550
Let's see if we can get away with a null.

149
00:10:17,700 --> 00:10:18,540
Yeah, we can.

150
00:10:18,570 --> 00:10:20,970
So I probably could have done that for the first and last names, too.

151
00:10:20,970 --> 00:10:21,750
But that's all right.

152
00:10:22,890 --> 00:10:26,520
OK, let's jump back over here to the test.

153
00:10:26,820 --> 00:10:27,960
Run it again.

154
00:10:31,170 --> 00:10:32,250
OK, still failing.

155
00:10:32,490 --> 00:10:37,830
So I'm going to click on can find person by ID here so we can see what the failure is now.

156
00:10:38,310 --> 00:10:47,070
So the test was expecting a 61 for the equality of the found person versus the saved person, but the

157
00:10:47,070 --> 00:10:48,510
ID was actually null.

158
00:10:49,290 --> 00:10:49,760
All right.

159
00:10:49,770 --> 00:10:55,950
So that makes sense as well because the person that we're creating in the new find by ID method of the

160
00:10:55,950 --> 00:10:59,310
repository class doesn't even have an ID.

161
00:10:59,430 --> 00:11:01,380
We didn't set any ID on it.

162
00:11:01,620 --> 00:11:04,290
So now we've got to consider what we want to do here.

163
00:11:04,500 --> 00:11:13,080
Do we want to just, I don't know, hard code a 61 as an ID into the person that we are returning from

164
00:11:13,080 --> 00:11:14,340
the repository.

165
00:11:14,730 --> 00:11:15,710
We could do that, in fact.

166
00:11:15,720 --> 00:11:17,190
Yeah, let's go ahead and do that.

167
00:11:18,310 --> 00:11:21,950
And see what that does, and I think you can anticipate what that's going to do.

168
00:11:21,970 --> 00:11:26,460
But all right, so the way we'll need to do that then I think, is to capture this person.

169
00:11:26,470 --> 00:11:32,230
So I'm going to put my cursor right here and then do an option command v or control all the and there's

170
00:11:32,230 --> 00:11:33,760
our personal hit enter.

171
00:11:34,060 --> 00:11:38,170
And then I will make the new line right above their on line thirty eight.

172
00:11:38,170 --> 00:11:40,990
And then we will just, I guess, hard code, maybe.

173
00:11:41,290 --> 00:11:43,660
And now we can just put an I.D. on here.

174
00:11:43,780 --> 00:11:51,250
Now, actually, what we could do is set the I.D. to ID.

175
00:11:51,790 --> 00:11:52,120
Right?

176
00:11:52,390 --> 00:11:52,660
Yeah.

177
00:11:52,670 --> 00:11:56,080
So this idea that we're passing and just set that ID right there, right?

178
00:11:56,890 --> 00:11:57,300
All right.

179
00:11:57,310 --> 00:11:59,950
So let's jump back over here to the test.

180
00:12:01,100 --> 00:12:02,480
And let's run this again.

181
00:12:02,600 --> 00:12:04,220
I think that's going to pass now.

182
00:12:04,760 --> 00:12:05,690
Yeah, there you go.

183
00:12:05,960 --> 00:12:07,250
So we're done right now.

184
00:12:07,250 --> 00:12:08,240
Of course we're not done.

185
00:12:08,450 --> 00:12:14,450
This isn't really doing anything that we really want, but this is the cat and mouse game that you can

186
00:12:14,450 --> 00:12:15,560
play with TDD.

187
00:12:16,340 --> 00:12:22,550
So we know that we haven't really forced ourselves to implement the real true find by ID code.

188
00:12:22,760 --> 00:12:28,070
So what would it take to force ourselves to implement the true, you know, querying of the database

189
00:12:28,070 --> 00:12:28,580
by ID?

190
00:12:29,450 --> 00:12:37,070
Well, I think one thing we could force ourselves to do is to also assert that the first name and last

191
00:12:37,070 --> 00:12:39,620
name are what they are supposed to be.

192
00:12:39,650 --> 00:12:46,100
Right now, we could add that as additional assertions in this test method, or we could create another

193
00:12:46,100 --> 00:12:46,670
test.

194
00:12:48,320 --> 00:12:54,500
Oftentimes, I'm actually not that crazy about having multiple assertions and a test method.

195
00:12:54,710 --> 00:13:02,420
However, in this particular case, we'd be asserting that a number of properties of the person class

196
00:13:02,660 --> 00:13:04,520
are what we think they should be.

197
00:13:04,790 --> 00:13:08,270
And so in this particular case, I might be OK with it.

198
00:13:08,540 --> 00:13:11,390
And there are actually a couple of ways that we could do this.

199
00:13:11,390 --> 00:13:16,430
So we could have these these individual assertions where we assert that the idea is the same and then

200
00:13:16,430 --> 00:13:20,720
we assert that the first name is the same and we assert that the last name is the same, right?

201
00:13:20,720 --> 00:13:28,130
We could do it that way explicitly or another thought that I'm having is that we could rely on having

202
00:13:28,160 --> 00:13:36,050
a decent equals method implemented on the person class, maybe one that just compares all of the properties

203
00:13:36,080 --> 00:13:37,520
of a person.

204
00:13:37,820 --> 00:13:42,770
And I'm kind of leaning towards that approach because with that approach, we might not need multiple

205
00:13:42,770 --> 00:13:43,880
assertions anymore.

206
00:13:44,060 --> 00:13:50,240
And instead, we might just be able to to assert that found person is equal to save the person or something

207
00:13:50,240 --> 00:13:53,740
along those or is the same as the saved person.

208
00:13:54,200 --> 00:13:55,490
Something along those lines.

209
00:13:55,650 --> 00:14:00,350
But for that to work, we would need to implement a proper equals method.

210
00:14:00,890 --> 00:14:03,200
So I'm thinking, let's go with that approach.

211
00:14:04,010 --> 00:14:09,170
So I'm going to jump into the person class here and I'm going to go down to the bottom.

212
00:14:09,740 --> 00:14:14,840
And so we could go ahead and have the ADP just generate an equal method for us.

213
00:14:15,020 --> 00:14:18,350
Now there's a couple of things to consider if you're going to do this.

214
00:14:18,890 --> 00:14:25,400
Oftentimes when I have written code along these lines and I'm creating what's called an entity, an

215
00:14:25,400 --> 00:14:34,820
entity, by the way, is generally speaking a domain class, a domain class that is designed to be stored

216
00:14:34,820 --> 00:14:35,990
in the database.

217
00:14:35,990 --> 00:14:37,280
So an entity.

218
00:14:37,580 --> 00:14:43,580
And frequently, when you've got these entities or or database domain classes, they will have an ID

219
00:14:43,970 --> 00:14:49,310
filled like this one, and that ID field is mostly there for database purposes.

220
00:14:50,150 --> 00:14:57,770
Frequently, when I'm implementing an equals method, I often don't want to include that ID filled there

221
00:14:57,800 --> 00:15:06,290
because it is possible to have an instance of a person before you saved them to the database and after

222
00:15:06,290 --> 00:15:07,910
you save them to the database.

223
00:15:08,180 --> 00:15:13,910
And there's still the same person, according to all of their properties, except for that idea.

224
00:15:13,940 --> 00:15:14,360
Right?

225
00:15:15,020 --> 00:15:23,720
In this case, though, I'm considering including the ID because I want that ID to be taken into account

226
00:15:23,720 --> 00:15:25,790
when I'm testing for equality.

227
00:15:25,820 --> 00:15:30,420
So there's some tradeoffs there in how I'm deciding to do this right now.

228
00:15:30,440 --> 00:15:35,450
I don't want to overthink this too much, though, so I'm going to do what simplest for me for right

229
00:15:35,450 --> 00:15:37,880
now, and that would be to just include the ID.

230
00:15:38,280 --> 00:15:44,450
OK, now if we're going to create this equals method for the person class, then ideally we should strongly

231
00:15:44,450 --> 00:15:51,950
consider having a unit test class for the person class where we would test the equality as well.

232
00:15:52,220 --> 00:15:56,900
So sorry for the sidetrack, but I kind of want to show you a little bit more of the right way to do

233
00:15:56,900 --> 00:15:59,970
things, even if we don't go like super in-depth with it.

234
00:15:59,990 --> 00:16:03,290
OK, so what I'm going to do here, I'm on this person class right now.

235
00:16:03,410 --> 00:16:09,050
I'm going to do a command shift T. And that's going to allow me to create a new test for the person

236
00:16:09,050 --> 00:16:09,440
class.

237
00:16:09,440 --> 00:16:15,650
I will select create new test and J Unit already is saying, OK, well, I'm going to assume you want

238
00:16:15,650 --> 00:16:18,560
this new test class to be called person test, which is fine.

239
00:16:18,710 --> 00:16:20,510
It's going to put it in the correct package.

240
00:16:20,510 --> 00:16:21,770
That's cool as well.

241
00:16:22,130 --> 00:16:25,880
And I'm not going to let it generate any of this stuff for me here that it's offering.

242
00:16:25,880 --> 00:16:29,510
Let me let me move this up so you can see what's going on there.

243
00:16:29,540 --> 00:16:35,630
OK, so I could select methods here that I that it would kind of give me some scaffolding for test methods,

244
00:16:35,630 --> 00:16:38,660
but I'm not going to select any of those and I'm going to click, OK.

245
00:16:38,870 --> 00:16:39,140
All right.

246
00:16:39,150 --> 00:16:46,730
So here we've just created a new test class called Person Test, and I'm going to just do that test.

247
00:16:47,780 --> 00:16:52,220
Public void tests for equality.

248
00:16:53,090 --> 00:16:53,400
All right.

249
00:16:53,430 --> 00:16:56,450
And so what I'm going to do here, I guess, is just create two people.

250
00:16:58,160 --> 00:17:09,170
Person P1 equals new person, and I don't know, I'll just call him P1, comma Smith, and we'll give

251
00:17:09,170 --> 00:17:11,180
this person his own date time.

252
00:17:12,330 --> 00:17:14,610
Of two thousand.

253
00:17:15,720 --> 00:17:18,120
September 1st.

254
00:17:19,100 --> 00:17:21,590
12 12 p.m..

255
00:17:23,200 --> 00:17:28,420
And in a zone I.D. of zero.

256
00:17:29,740 --> 00:17:30,120
Oops!

257
00:17:34,210 --> 00:17:34,670
All right.

258
00:17:34,690 --> 00:17:39,340
And then I'm going to duplicate that person because I don't want to type all of that completely.

259
00:17:39,910 --> 00:17:40,330
All right.

260
00:17:40,540 --> 00:17:44,350
And so I guess we'll start off with the happy path and just.

261
00:17:45,560 --> 00:17:48,200
Have everything be the same, right?

262
00:17:50,290 --> 00:17:50,710
All right.

263
00:17:51,160 --> 00:17:54,460
And then we will assert that.

264
00:17:56,470 --> 00:18:02,380
And I'm going to move my cursor over here to the that and then do an option return to import that,

265
00:18:02,800 --> 00:18:03,760
assert that method.

266
00:18:03,760 --> 00:18:10,780
Remember the assert that methods are not from the J Unit framework that we're using in general for testing.

267
00:18:10,780 --> 00:18:15,430
This is an add on from a third party called Assert J.

268
00:18:15,460 --> 00:18:18,400
OK, that's where the assert that methods are coming from.

269
00:18:18,550 --> 00:18:23,830
So if you end up at a company where they want you to unit test and you just jump in and start trying

270
00:18:23,830 --> 00:18:30,520
to use assert that there's a possibility that the assert that methods won't be there for you if that

271
00:18:30,520 --> 00:18:33,250
company or that team hasn't already imported.

272
00:18:33,250 --> 00:18:38,090
The Assert J Library and some teams might not be OK with you using it.

273
00:18:38,110 --> 00:18:38,560
OK.

274
00:18:38,710 --> 00:18:41,640
These are not standard assertions from J Unit.

275
00:18:41,650 --> 00:18:42,790
These are third party.

276
00:18:42,790 --> 00:18:48,880
Add on assertions that make our assertions a little more fluent if you speak English.

277
00:18:49,720 --> 00:18:50,110
All right.

278
00:18:50,260 --> 00:18:56,230
So assert that import static and I'm going to come down here to the simplest looking one assertions

279
00:18:56,230 --> 00:18:59,650
that assert that from the or a search eight core API.

280
00:19:00,730 --> 00:19:01,110
All right.

281
00:19:01,120 --> 00:19:03,460
Assert that p one.

282
00:19:03,640 --> 00:19:04,000
All right.

283
00:19:04,000 --> 00:19:08,170
So then we will do is equal to P two.

284
00:19:08,740 --> 00:19:09,040
All right.

285
00:19:09,070 --> 00:19:11,260
So now let's go ahead and run this.

286
00:19:12,730 --> 00:19:13,050
OK.

287
00:19:13,090 --> 00:19:16,270
And we get our failure, as we would expect.

288
00:19:16,540 --> 00:19:22,090
OK, so now let's go and implement an equals method here.

289
00:19:22,210 --> 00:19:24,790
So we'll just jump back over to the person class.

290
00:19:24,830 --> 00:19:31,780
I'm going to jump to the bottom of this method here, because that's where I like to put my boilerplate

291
00:19:31,780 --> 00:19:36,580
in generated methods and things like like equals and to string and all of that.

292
00:19:36,880 --> 00:19:37,150
All right.

293
00:19:37,180 --> 00:19:40,390
And so we can have the idea generate an equals method for us.

294
00:19:40,630 --> 00:19:44,410
I will do a command in for Mac users and for Windows and Linux users.

295
00:19:44,410 --> 00:19:48,500
You'll have to right click, you know, like here and go down to generate.

296
00:19:48,520 --> 00:19:52,450
Sorry, you can't see generate on my on my screen here, but it's there and here.

297
00:19:52,450 --> 00:19:53,440
I'll do it up here.

298
00:19:53,710 --> 00:19:54,550
Generate right?

299
00:19:55,210 --> 00:19:55,600
OK.

300
00:19:56,200 --> 00:20:02,350
So command in generate and equals.

301
00:20:02,500 --> 00:20:08,890
Now remember also that when you do an equals method, the idea is going to offer to implement both the

302
00:20:08,890 --> 00:20:14,290
equals and the hash code method for you, because those two methods really tend to go hand in hand with

303
00:20:14,290 --> 00:20:14,720
each other.

304
00:20:14,740 --> 00:20:15,970
And again, I apologize.

305
00:20:16,150 --> 00:20:20,230
You can't see it on my screen because it's kind of running off the screen, but I'm choosing the equals

306
00:20:20,230 --> 00:20:28,630
and hash code option there, and then it's asking me if I want to use Java 7's built in template capability

307
00:20:28,630 --> 00:20:32,500
to generate these, which I'm good with and click next.

308
00:20:32,950 --> 00:20:33,230
All right.

309
00:20:33,250 --> 00:20:37,540
Now here is where we actually specify what fields we want to take into account.

310
00:20:37,540 --> 00:20:43,990
And like I already said earlier, frequently in the past for like real business applications, I may

311
00:20:43,990 --> 00:20:48,340
very well have left out this ID field, but in this case, I'm keeping it simple.

312
00:20:48,550 --> 00:20:53,380
And I really want to be able to compare these objects, including their IDs.

313
00:20:53,380 --> 00:20:59,410
So I'm going to leave all of these fields selected here ID, first name, last name and date of birth.

314
00:20:59,500 --> 00:21:04,960
So that's just ask me which fields should be taken into account when we are comparing for equality.

315
00:21:05,080 --> 00:21:10,450
In other words, all of those fields should be the same in order for the entire person to be the same.

316
00:21:10,840 --> 00:21:12,310
All right, so click next.

317
00:21:12,670 --> 00:21:14,940
And same thing here for the hash code.

318
00:21:14,950 --> 00:21:15,940
Same same deal.

319
00:21:16,270 --> 00:21:18,500
And which fields should not be null?

320
00:21:18,520 --> 00:21:22,720
Now, this is a little tricky because when we first create a person, there's not going to be an ID.

321
00:21:22,810 --> 00:21:28,420
So technically I have to leave the ID off for now, so I'm going to do it that way.

322
00:21:29,550 --> 00:21:33,810
OK, so there we go, we've got a nice generated equals n hash code method.

323
00:21:34,140 --> 00:21:38,790
And now I'm going to jump back over to the test and just run it again.

324
00:21:41,280 --> 00:21:43,290
There we go, and so that's passing now.

325
00:21:43,590 --> 00:21:44,160
Very good.

326
00:21:45,500 --> 00:21:48,320
OK, and then let's make a negative test.

327
00:21:48,920 --> 00:21:49,610
So.

328
00:21:51,440 --> 00:21:57,260
Public void test for any quality.

329
00:21:58,550 --> 00:22:03,500
And I suppose I'll start off by duplicating one of these people here, and then I'm going to just bring

330
00:22:03,500 --> 00:22:07,370
him down by doing an option shift down Arrow.

331
00:22:08,910 --> 00:22:11,700
Or all shift down Arrow on Windows and Linux.

332
00:22:11,790 --> 00:22:12,240
OK.

333
00:22:12,570 --> 00:22:17,130
And then I guess I'm going to duplicate him again and change this name to P2.

334
00:22:17,310 --> 00:22:23,850
But now I will change something here, and technically I only need to change one small thing, so I

335
00:22:23,850 --> 00:22:25,830
will change the name to P2.

336
00:22:26,160 --> 00:22:31,830
So keep in mind up here, they're both exactly identical other than the names of the variables down

337
00:22:31,830 --> 00:22:35,490
here, though I'm changing the first name subtly right to P2.

338
00:22:35,910 --> 00:22:36,350
All right.

339
00:22:36,360 --> 00:22:40,380
And then I will assert that.

340
00:22:42,380 --> 00:22:51,220
P1 is not equal to P2, and then let's run both tests.

341
00:22:53,050 --> 00:22:54,220
There we go, looking good.

342
00:22:54,250 --> 00:22:57,490
OK, so we've got an equals method implemented now.

343
00:22:57,850 --> 00:22:58,260
All right.

344
00:22:58,270 --> 00:23:04,840
So now we can jump all the way back over to our repository tests.

345
00:23:05,380 --> 00:23:05,620
All right.

346
00:23:05,630 --> 00:23:07,410
So I'm going to do a command.

347
00:23:07,420 --> 00:23:11,470
Oh, which will let me search for classes and I happened already.

348
00:23:11,470 --> 00:23:14,560
Have the people repository tests class kind of showing up here.

349
00:23:14,560 --> 00:23:15,580
So I'm just selecting that.

350
00:23:15,580 --> 00:23:18,620
But if you don't have that, you can just type PCR tests.

351
00:23:18,760 --> 00:23:20,240
It may be PR tech.

352
00:23:20,300 --> 00:23:25,420
Yeah, see, there you go and then hit, enter and jump back over here and then I'm going to make some

353
00:23:25,420 --> 00:23:26,590
room for myself.

354
00:23:26,890 --> 00:23:29,710
OK, so now can find person by ID?

355
00:23:30,460 --> 00:23:33,430
And where were we so?

356
00:23:33,760 --> 00:23:34,070
Yes.

357
00:23:34,160 --> 00:23:42,610
So now, instead of testing for equality, according to the IDs, only now I can actually just get rid

358
00:23:42,910 --> 00:23:48,880
of that and get rid of that.

359
00:23:49,060 --> 00:23:53,230
And so now I'm just saying assert that the found person is equal to the saved person.

360
00:23:53,530 --> 00:23:53,860
Right?

361
00:23:53,980 --> 00:24:00,520
Because now I have an equals method that will dig in to the ID and the first name in the last name in

362
00:24:00,530 --> 00:24:05,770
the date of birth and all of those, all of those properties have to be identical in order for these

363
00:24:06,070 --> 00:24:10,600
two people to be considered to be identical or the same right equal.

364
00:24:11,230 --> 00:24:11,530
All right.

365
00:24:11,540 --> 00:24:16,120
So now if I run this test test, it fails.

366
00:24:18,450 --> 00:24:23,700
Because now the first names are not the same, the last name is not the same, the date of birth is

367
00:24:23,700 --> 00:24:25,230
not the same, et cetera, et cetera, right?

368
00:24:26,650 --> 00:24:33,130
So obviously now I could go in and hard code, the person that we're returning from the find my ID method

369
00:24:33,130 --> 00:24:37,330
to match these specific parameters here.

370
00:24:37,570 --> 00:24:45,160
But then as soon as I wrote one more test that had a differently named person then want at least one

371
00:24:45,160 --> 00:24:47,350
of them would fail and so on and so forth.

372
00:24:47,500 --> 00:24:51,880
So I'm not going to bother to do that for in the interest of time, but you get it right.

373
00:24:52,360 --> 00:24:57,400
OK, so now let's go ahead and actually implement something here like really implement something.

374
00:24:57,400 --> 00:25:02,050
So let's jump in to the find bad method here.

375
00:25:03,470 --> 00:25:09,530
OK, so now we're going to write some real code, so I'm going to start off by maybe just making a new

376
00:25:09,530 --> 00:25:17,240
line here so we can use a little bit of what we did up here as a template, but I don't think I need

377
00:25:17,240 --> 00:25:17,420
it.

378
00:25:17,420 --> 00:25:23,330
So what we'll do here is we're going to start off with the connection like we did before, and we'll

379
00:25:23,330 --> 00:25:25,440
go ahead and use a prepared statement again.

380
00:25:25,880 --> 00:25:27,740
And we're going to need some sequel.

381
00:25:27,920 --> 00:25:33,220
So what we're going to be doing here is we're going to try to find the person by idea.

382
00:25:33,260 --> 00:25:35,960
OK, so the way to do that would be select.

383
00:25:37,070 --> 00:25:45,320
Now we could do a couple of things, or we could do select star from people where ID equals, and then

384
00:25:45,320 --> 00:25:50,780
I can just use a question mark here and then I will pass in that parameter later.

385
00:25:51,080 --> 00:25:51,590
OK.

386
00:25:52,070 --> 00:25:53,930
So that's one thing that we could do.

387
00:25:54,530 --> 00:26:00,950
Now you oftentimes it is considered a better practice to be a little more explicit in what columns you're

388
00:26:00,950 --> 00:26:02,780
actually querying for, though.

389
00:26:03,140 --> 00:26:06,380
And so I think that's what I'm going to do in this particular case.

390
00:26:06,920 --> 00:26:17,630
So I'm going to query for ID, comma, first name, comma, last name, comma, date of birth, OK,

391
00:26:17,720 --> 00:26:18,670
like that.

392
00:26:19,430 --> 00:26:22,220
And then I'm going to close that off with a semicolon notice.

393
00:26:22,220 --> 00:26:27,200
I have the red marks here, and that is because if I hover over it, I have an unhindered exception

394
00:26:27,200 --> 00:26:27,470
here.

395
00:26:27,650 --> 00:26:35,240
So to handle that exception with my cursor on this line, I'm going to do an option command T and then

396
00:26:35,240 --> 00:26:42,410
I can let the ID surround that line of code with a try catch block by choosing number six.

397
00:26:43,190 --> 00:26:48,020
OK, I could have written that out myself to, by the way, obviously, but I'm lazy.

398
00:26:49,250 --> 00:26:49,670
OK.

399
00:26:49,730 --> 00:26:54,680
So there's that line, and I'm going to make a new line inside of the try catch block here.

400
00:26:54,840 --> 00:27:00,050
Oh, so the other thing I need to do now is to capture this prepared statement, because we're just

401
00:27:00,050 --> 00:27:03,650
telling the connection to create a prepared statement for us.

402
00:27:03,710 --> 00:27:04,070
OK.

403
00:27:04,280 --> 00:27:09,680
So I have my cursor at the end here and I'm going to do an option Command V. And I'm going to call this

404
00:27:09,680 --> 00:27:13,740
prepared statement piece what's not uppercase lowercase piece?

405
00:27:14,390 --> 00:27:15,560
All right, there we go.

406
00:27:17,730 --> 00:27:25,950
So now the next thing we'll want to do is to bind a value in this case, this ID bind this ID to this

407
00:27:25,950 --> 00:27:27,190
question mark here.

408
00:27:27,210 --> 00:27:31,890
OK, so in other words, we're going to plug that question mark in so that when we execute this query,

409
00:27:31,890 --> 00:27:34,830
it will know what ID to actually plug in to the query there, right?

410
00:27:35,160 --> 00:27:40,620
So we can do that by typing piece set long, because that's the data type.

411
00:27:41,190 --> 00:27:44,670
And then it's going to take as an input, a parameter index.

412
00:27:44,670 --> 00:27:48,360
And I only have one parameter in this query, which is that one right there.

413
00:27:48,360 --> 00:27:50,430
So its index is going to be one.

414
00:27:51,960 --> 00:27:55,740
So one comma and then I can pass in the ID there.

415
00:27:55,950 --> 00:27:58,110
OK, so this ID here?

416
00:27:59,590 --> 00:28:01,110
Is this it here, right?

417
00:28:01,120 --> 00:28:07,510
So what we're saying is select all these fields from the people table where the ID equals whatever ID

418
00:28:07,600 --> 00:28:08,610
we passed in here.

419
00:28:08,650 --> 00:28:10,570
That's what we're that's what we're doing here.

420
00:28:10,600 --> 00:28:11,010
OK.

421
00:28:11,560 --> 00:28:12,120
All right.

422
00:28:12,130 --> 00:28:15,430
And then I think we can go ahead and execute this now.

423
00:28:15,430 --> 00:28:21,170
In the previous save method, we did an execute update because we were updating the database.

424
00:28:21,190 --> 00:28:27,610
In this case, we're going to be executing a query because we're querying for some data out of the database,

425
00:28:27,610 --> 00:28:27,880
right?

426
00:28:27,880 --> 00:28:35,020
So I'm going to type execute query or you could really just type IQ, right and then return.

427
00:28:35,380 --> 00:28:39,430
And now the execute query method is going to return a result set.

428
00:28:39,440 --> 00:28:44,230
So I want to capture that result said this will be the results, right that we get from this query.

429
00:28:45,010 --> 00:28:50,570
So I'm going to capture that with my cursor on the Line 43 and do an option Command V..

430
00:28:50,950 --> 00:28:54,790
And there's my results set, and I'm just going to call it IRS out of laziness.

431
00:28:55,750 --> 00:28:57,970
And I want you to remember again the results set.

432
00:28:58,090 --> 00:29:04,840
You should think of it in your mind as a spreadsheet with rows and columns, right?

433
00:29:05,080 --> 00:29:13,270
And so if there was a match for a person with the idea that we pass in here, then you can envision

434
00:29:13,270 --> 00:29:16,510
that's going to look like a spreadsheet with one row.

435
00:29:16,960 --> 00:29:24,310
OK, now to get the data out of there, we will need to use a while loop.

436
00:29:24,580 --> 00:29:26,680
Typically, that's traditionally the way it's done.

437
00:29:27,580 --> 00:29:29,860
While asked next.

438
00:29:31,240 --> 00:29:38,530
OK, so we're telling the results set to go to the next line or the next row.

439
00:29:38,920 --> 00:29:39,370
OK.

440
00:29:39,580 --> 00:29:45,580
And so you can imagine that when you first get the results set, there's a little cursor or a pointer

441
00:29:45,580 --> 00:29:51,970
or something like that, and it's initially starting off up above any rows at all.

442
00:29:52,000 --> 00:29:52,470
OK.

443
00:29:52,600 --> 00:30:00,400
And so by calling RSA next year now telling it to jump to the first row, if there is any data now,

444
00:30:00,400 --> 00:30:06,370
it's possible to not have any data because we passed in an ID for a row that doesn't exist, and we'll

445
00:30:06,370 --> 00:30:09,160
write some tests to test that scenario out.

446
00:30:09,280 --> 00:30:11,020
But right now, we'll just do the happy path.

447
00:30:11,050 --> 00:30:11,440
OK.

448
00:30:11,980 --> 00:30:17,620
So presumably, if it found anything, we are now on the very first row.

449
00:30:17,830 --> 00:30:18,280
OK.

450
00:30:18,310 --> 00:30:22,330
And so next, we'll want to start pulling the data out.

451
00:30:22,840 --> 00:30:30,940
So the way I'm going to do this is let's first grab the ID so we can reference the results set that

452
00:30:30,940 --> 00:30:39,340
get along because the ID is going to be a type long and we can actually use a couple different approaches

453
00:30:39,340 --> 00:30:40,990
to do that to doing this now.

454
00:30:41,260 --> 00:30:44,740
We could specify a column index.

455
00:30:45,370 --> 00:30:53,230
And so the ID was the first column that we specified in our query so we could see for getting the ID.

456
00:30:53,320 --> 00:30:55,840
That's column one first name is column two.

457
00:30:55,870 --> 00:30:57,940
Last name is column three and so on and so forth.

458
00:30:58,120 --> 00:31:03,040
Or we could use the actual column names that we specified as well.

459
00:31:03,190 --> 00:31:08,200
So I'm actually going to go for the column names because I think it'll be a little more readable.

460
00:31:09,130 --> 00:31:11,740
OK, so I'm going to say I'd.

461
00:31:13,200 --> 00:31:13,550
OK.

462
00:31:14,400 --> 00:31:16,020
And then I need to capture that.

463
00:31:17,940 --> 00:31:25,350
And I don't know, I will just call it person ID so that it doesn't conflict with this variable of ID

464
00:31:25,470 --> 00:31:25,920
up here.

465
00:31:27,500 --> 00:31:35,450
All right, then rest get string and we'll grab the first name, first underscore name.

466
00:31:37,480 --> 00:31:42,080
And then we'll capture that, and we'll just call it first name.

467
00:31:42,100 --> 00:31:47,470
Now notice the ABC is offering some is actually suggesting some names for this variable.

468
00:31:47,830 --> 00:31:49,750
And so I can actually just choose that one.

469
00:31:49,870 --> 00:31:51,940
Why am I not going for the underscore name?

470
00:31:51,970 --> 00:31:58,180
Well, because now these are Java variables, and the tradition in Java variable naming is to use camel

471
00:31:58,180 --> 00:32:03,980
case not underscores unless it's a constant which is all uppercase, and then you have to use underscores.

472
00:32:04,000 --> 00:32:05,950
OK, so I'm going for this one.

473
00:32:06,430 --> 00:32:06,820
All right.

474
00:32:07,540 --> 00:32:13,840
And then our state gets string again and we'll grab the last name, last name.

475
00:32:16,200 --> 00:32:21,270
Be careful about your case sensitivity as well and capture that.

476
00:32:22,700 --> 00:32:27,800
Last name, and then we're going to need the date of birth, what's the date of birth?

477
00:32:28,160 --> 00:32:33,440
Now this is a timestamp in the database timestamp, right?

478
00:32:35,020 --> 00:32:41,410
But we're going to need it to be a zoned date time, so we're going to have to do some translating here,

479
00:32:41,590 --> 00:32:42,940
as you've seen before.

480
00:32:42,970 --> 00:32:43,360
Right?

481
00:32:43,720 --> 00:32:48,070
So first off, we'll call this Dobey.

482
00:32:48,640 --> 00:32:48,880
All right.

483
00:32:48,880 --> 00:32:51,300
So now this is going to return a timestamp.

484
00:32:52,640 --> 00:32:58,700
Now, the nice thing is we can go to a local daytime really easily right off of the timestamps, so

485
00:32:58,700 --> 00:33:02,150
we're more than halfway there already with that.

486
00:33:02,960 --> 00:33:08,900
But now we want this guy to be wrapped inside of the zoned daytime, right?

487
00:33:09,230 --> 00:33:13,490
So what I'm going to do here is type ARG for argument.

488
00:33:13,490 --> 00:33:19,520
And that just wrapped this whole entire thing in opening and closing parentheses for me very quickly.

489
00:33:19,910 --> 00:33:28,200
And then I'm going to do a zone date time dot of like so that him and jump back over to the end.

490
00:33:28,220 --> 00:33:35,450
Go inside of here comma, because I believe there's a version of the zone date time of method that takes

491
00:33:35,450 --> 00:33:41,150
a local date time as one input and then a zone ID for the second input.

492
00:33:41,390 --> 00:33:43,340
Now why do I need that Zone ID?

493
00:33:43,940 --> 00:33:50,900
Well, because this local date time that I'm getting from the time stamp in the database doesn't have

494
00:33:50,930 --> 00:33:53,120
time zone information built into it.

495
00:33:53,330 --> 00:34:00,440
And so but a zone date time, which is what our person class requires, needs a time zone right now.

496
00:34:00,560 --> 00:34:02,750
What time zone will I actually use?

497
00:34:03,770 --> 00:34:05,930
This is actually an interesting thing to consider.

498
00:34:06,830 --> 00:34:11,030
When we create our people, our person instances ourselves.

499
00:34:11,150 --> 00:34:15,800
We can specify a time zone for the dates of birth, right?

500
00:34:15,800 --> 00:34:17,840
And it can be any time zone in the world.

501
00:34:18,140 --> 00:34:25,940
But when we get them from the database, they're all going to be normalized to a time zone of GMT zero.

502
00:34:26,360 --> 00:34:33,900
And so with what I have here, I can't know what time zone this person originally was born in.

503
00:34:33,920 --> 00:34:40,070
So with what I have here, I don't know where this person lives, right or where they were born or whatever.

504
00:34:40,340 --> 00:34:48,080
I just know that the moment in time in the world when they were born is whatever it is, relative to

505
00:34:48,080 --> 00:34:49,250
GMT zero.

506
00:34:49,490 --> 00:34:58,190
And so what I'm going to have to do here in setting the Zone I.D. by clicking on that is just to specify

507
00:34:58,190 --> 00:35:01,670
GMT zero, because that's what it is coming out of the database, OK?

508
00:35:02,690 --> 00:35:04,040
So + zero.

509
00:35:05,480 --> 00:35:12,320
And that's actually great, because now that I have a zone date time for their date of birth relative

510
00:35:12,320 --> 00:35:20,060
to GMT zero, if and when I ever do find out what their preferred time zone is, it's easy to just warp

511
00:35:20,060 --> 00:35:24,890
the time of this date of birth to whatever their preferred time zone would be.

512
00:35:25,010 --> 00:35:28,880
All right, and then let's capture that as date of birth.

513
00:35:30,190 --> 00:35:30,790
There we go.

514
00:35:31,570 --> 00:35:37,870
And so now I can just set all these fields on a brand new person instance and return that person.

515
00:35:38,350 --> 00:35:45,370
Now you might be thinking to do something like this creative person found person equals new person and

516
00:35:45,370 --> 00:35:53,560
then start plugging in all of the variables here first name, last name, date of birth, like so and

517
00:35:53,560 --> 00:35:56,840
then even set that ID, said Heidi.

518
00:35:56,860 --> 00:35:59,200
To what did I call it, person ID?

519
00:36:00,150 --> 00:36:00,460
Right?

520
00:36:01,180 --> 00:36:01,780
Like that?

521
00:36:02,140 --> 00:36:05,680
However, you're going to run into a problem if you do it this way.

522
00:36:05,710 --> 00:36:07,300
So here's this found person.

523
00:36:07,300 --> 00:36:09,160
And so we need to return that person here.

524
00:36:09,160 --> 00:36:11,710
So let's see what happens if we try to do this.

525
00:36:13,220 --> 00:36:13,960
It's red.

526
00:36:14,480 --> 00:36:19,610
Now, do you want to take a guess as to why I am not able to return this person here?

527
00:36:20,180 --> 00:36:27,380
OK, so the issue is that I'm creating this person inside of this while loop here.

528
00:36:27,470 --> 00:36:27,920
OK?

529
00:36:28,670 --> 00:36:38,360
And any objects that I create inside of this loop will only exist within the lifetime of that one loop.

530
00:36:38,390 --> 00:36:44,450
OK, so once this code is done executing and the thread leaves this while loop.

531
00:36:44,450 --> 00:36:51,080
In fact, once the thread leaves this one and only iteration of the wire loop, all of the variables

532
00:36:51,080 --> 00:36:57,680
that got created locally inside of this loop ceased to exist, and real quickly they'll get garbage

533
00:36:57,680 --> 00:36:59,600
collected by the JVM, in fact.

534
00:36:59,810 --> 00:37:06,020
And so I cannot refer to this person down here because this person here is out of scope.

535
00:37:06,170 --> 00:37:06,620
OK.

536
00:37:06,770 --> 00:37:11,990
So pretty much any time we're creating objects within code blocks and you know, a code block is pretty

537
00:37:11,990 --> 00:37:13,680
much any code in between.

538
00:37:13,700 --> 00:37:20,630
Curly braces, those objects are local to that block of code, and they will cease to exist once the

539
00:37:20,630 --> 00:37:22,760
thread has left that code block.

540
00:37:22,790 --> 00:37:25,010
OK, so what's the solution for this?

541
00:37:25,370 --> 00:37:26,660
Well, it's actually pretty simple.

542
00:37:26,930 --> 00:37:33,770
All you need to do is to declare the variable outside of that block somewhere where you have a wider

543
00:37:33,770 --> 00:37:34,310
scope.

544
00:37:34,580 --> 00:37:35,030
OK.

545
00:37:35,360 --> 00:37:41,090
So for example, a pier, we're creating this person so I could actually just hijack this person.

546
00:37:41,210 --> 00:37:45,110
I'm going to select all of that and delete that and then set this to null.

547
00:37:45,230 --> 00:37:45,680
OK.

548
00:37:46,220 --> 00:37:55,520
So I'm not creating the person yet, but I am declaring the person up here in the widest scope possible

549
00:37:55,520 --> 00:37:56,720
for this method.

550
00:37:56,750 --> 00:37:57,140
OK?

551
00:37:57,410 --> 00:38:06,230
Any local variables that I declare appear in the outermost level of the find by ID method will be visible

552
00:38:06,470 --> 00:38:07,760
throughout this method.

553
00:38:07,790 --> 00:38:08,240
OK.

554
00:38:08,570 --> 00:38:16,520
And so then down here, I can just set this new person to this person variable.

555
00:38:16,830 --> 00:38:19,890
OK, let me copy that and then paste this here.

556
00:38:19,910 --> 00:38:20,300
OK.

557
00:38:20,900 --> 00:38:29,780
So this person has scope throughout the entire method, whereas any objects that are created down here

558
00:38:30,020 --> 00:38:32,600
only have scope within this loop.

559
00:38:32,750 --> 00:38:33,170
All right.

560
00:38:33,560 --> 00:38:36,410
And so then down here, I can return.

561
00:38:37,400 --> 00:38:38,420
I can return.

562
00:38:40,090 --> 00:38:40,900
That person.

563
00:38:41,380 --> 00:38:47,350
All right, so then let's jump back over to the test now, and let's run it again.

564
00:38:50,730 --> 00:38:52,290
OK, so it's still failed.

565
00:38:52,590 --> 00:38:55,500
Let me click on that and see what's going on now.

566
00:38:56,340 --> 00:38:57,300
OK, so.

567
00:38:58,290 --> 00:39:03,800
The IDs are 64, the first names are Test, last name is Jackson.

568
00:39:03,810 --> 00:39:10,160
Ah, but we've got an issue with our time zone.

569
00:39:10,650 --> 00:39:18,150
Yeah, because the original person that we created the test person here had a time zone of GMT minus

570
00:39:18,150 --> 00:39:24,480
six, but the person were getting out of the database as a time zone or GMT zero in effect, right?

571
00:39:24,600 --> 00:39:27,210
And so that that's not matching.

572
00:39:27,660 --> 00:39:27,920
All right.

573
00:39:27,930 --> 00:39:30,180
So what do we want to do about that?

574
00:39:30,600 --> 00:39:33,750
Well, I can think of one or two approaches here.

575
00:39:34,140 --> 00:39:40,560
One thing I'm wondering about is jumping over here to the person class and coming down to the equals

576
00:39:40,560 --> 00:39:46,590
method and looking at where we're doing the comparisons of the date of birth.

577
00:39:46,740 --> 00:39:53,430
And we could consider normalizing the date of birth to always be something like GMT zero, right, at

578
00:39:53,430 --> 00:39:54,630
least when we're comparing.

579
00:39:54,930 --> 00:39:56,660
So let's see what that might look like.

580
00:39:56,670 --> 00:40:00,150
I'm going to actually drop this down to a new line, so I have a little more space here.

581
00:40:00,150 --> 00:40:01,740
So data birth dot.

582
00:40:02,760 --> 00:40:07,100
So what we could do is something like with zone.

583
00:40:07,890 --> 00:40:11,130
Same instant, which we've seen before with zone.

584
00:40:11,130 --> 00:40:12,150
Same instant.

585
00:40:13,080 --> 00:40:15,720
And then use a zone I.D..

586
00:40:17,020 --> 00:40:17,560
Of.

587
00:40:19,100 --> 00:40:20,540
Loops of zero.

588
00:40:21,700 --> 00:40:22,330
Dot.

589
00:40:23,970 --> 00:40:30,420
And then do the same thing over here, so in other words, we're just normalizing these two dates relative

590
00:40:30,450 --> 00:40:37,020
to GMT zero, we're not changing the the the moment in time when these events occurred.

591
00:40:37,140 --> 00:40:42,450
We're just saying when we want to compare them, we want to compare them as if they were relative to

592
00:40:42,450 --> 00:40:47,010
GMT zero so that you're comparing apples to apples completely, OK?

593
00:40:47,190 --> 00:40:51,260
So same thing here the be with zone.

594
00:40:51,270 --> 00:40:52,560
Same instant.

595
00:40:54,330 --> 00:40:56,700
Zone Edy of.

596
00:40:57,710 --> 00:40:59,240
Plus zero.

597
00:41:00,050 --> 00:41:00,470
OK.

598
00:41:00,770 --> 00:41:06,620
OK, so now let's jump back over to our repository tests and now let's run this again.

599
00:41:08,540 --> 00:41:12,140
There we go, and now it's all matching up.

600
00:41:12,980 --> 00:41:19,520
OK, so that zone daytime stuff through a through a little bit of a wrench in the works there, but

601
00:41:19,520 --> 00:41:21,560
it wasn't too difficult to address.

602
00:41:21,770 --> 00:41:27,980
So in the next less and less flesh out the find by IED use cases a little bit more.

603
00:41:28,070 --> 00:41:30,890
We can do negative cases and perhaps a few other things.

604
00:41:30,890 --> 00:41:32,330
So see in the next one.
