1
00:00:00,330 --> 00:00:06,630
All right, so in this next lesson, we're going to just continue on with our TV version of the guessing

2
00:00:06,630 --> 00:00:06,990
game.

3
00:00:07,560 --> 00:00:14,400
So in the last lesson, we got the first little test to kind of pass, but it's kind of a fake pass

4
00:00:14,400 --> 00:00:22,110
because we basically just hardcoded the response from our new guess method to return exactly the string

5
00:00:22,110 --> 00:00:23,110
that we were looking for.

6
00:00:23,130 --> 00:00:30,270
So there's no actual logic, no business logic, no game logic actually implemented inside of this guessing

7
00:00:30,270 --> 00:00:31,010
method here.

8
00:00:31,020 --> 00:00:36,300
We're just taking it a number, ignoring it and then just returning something because that's all that

9
00:00:36,300 --> 00:00:39,210
the test is kind of calling for us to do at the moment.

10
00:00:39,540 --> 00:00:42,270
So now let's look at what we're doing here.

11
00:00:42,300 --> 00:00:49,170
So our test is called test simple win situation, meaning, you know, we want to test out the scenario

12
00:00:49,170 --> 00:00:54,450
where we just directly put in a winning number and then we get a winning message like, you got it.

13
00:00:54,870 --> 00:01:00,780
Now one thing that I'm thinking is, well, OK, in this particular case here, we just put a random

14
00:01:00,780 --> 00:01:01,620
number in here.

15
00:01:01,740 --> 00:01:08,400
But in real life, maybe we'd want to be able to know what is the actual random number that the game

16
00:01:08,400 --> 00:01:09,240
generated.

17
00:01:09,480 --> 00:01:16,050
And then at least for our test to be able to query the game to find out what is that winning number

18
00:01:16,320 --> 00:01:21,690
and and then take that winning number and pass it in right kind of equivalent to what we did in the

19
00:01:21,690 --> 00:01:22,590
real guessing game.

20
00:01:22,590 --> 00:01:29,130
If you recall, when we were trying to manually test out various situations and scenarios, we put a

21
00:01:29,130 --> 00:01:34,680
little system that out that print line or print out right after we were generating the number and we

22
00:01:34,680 --> 00:01:39,900
were printing out the randomly generated numbers so that we, the tester could know what that number

23
00:01:39,900 --> 00:01:40,170
was.

24
00:01:40,530 --> 00:01:42,870
I think we need an equivalent here.

25
00:01:43,080 --> 00:01:50,430
And what I'm thinking we could do is to add another method onto our guessing game that would actually

26
00:01:50,430 --> 00:01:54,830
return the randomly generated number and then we can use this.

27
00:01:54,830 --> 00:02:03,740
So maybe something like a game dot get brand number and then this method would return.

28
00:02:03,750 --> 00:02:08,870
I guess integer random equals right?

29
00:02:08,880 --> 00:02:15,600
And then instead of passing in this hardcoded three, maybe we would just pass in the random number

30
00:02:15,600 --> 00:02:16,530
instead.

31
00:02:16,590 --> 00:02:16,980
Right?

32
00:02:17,430 --> 00:02:24,330
So that way, we'd be guaranteed that eventually, when this game engine does start truly generating

33
00:02:24,330 --> 00:02:28,590
a random number, we always win in this scenario.

34
00:02:28,710 --> 00:02:29,190
OK.

35
00:02:29,850 --> 00:02:34,650
So I think we just need to implement this method get random number.

36
00:02:34,770 --> 00:02:41,190
So if I put my cursor right here on right after the get random number method and then do an option return,

37
00:02:41,400 --> 00:02:43,230
I can create method.

38
00:02:43,940 --> 00:02:44,910
Get random number.

39
00:02:46,700 --> 00:02:47,330
There we go.

40
00:02:47,600 --> 00:02:53,810
And for now, I will let it just do the default, which is to return to zero, because that's all our

41
00:02:53,810 --> 00:02:56,090
test is really calling for at this time.

42
00:02:57,230 --> 00:03:01,730
All right, and then I will rerun this test, and it should still pass.

43
00:03:02,360 --> 00:03:03,110
OK, cool.

44
00:03:04,060 --> 00:03:04,600
All right.

45
00:03:04,690 --> 00:03:07,210
So what now?

46
00:03:07,810 --> 00:03:14,350
I'm kind of thinking, well, we've got a test to test the simple win situation.

47
00:03:14,350 --> 00:03:18,370
Maybe we can have a test to test the simple lose situation.

48
00:03:18,760 --> 00:03:20,680
Let's let's see what that might look like.

49
00:03:21,860 --> 00:03:28,190
So I'm going to start off by copying this existing test, and then I will paste here and I will rename

50
00:03:28,190 --> 00:03:29,960
this test simple.

51
00:03:30,050 --> 00:03:34,010
Lose lose situation.

52
00:03:34,370 --> 00:03:36,790
And we're creating our guessing game.

53
00:03:36,800 --> 00:03:38,930
And so for this now.

54
00:03:40,090 --> 00:03:46,900
When we did this with the previous implementation of our guessing game, in order to guarantee that

55
00:03:46,900 --> 00:03:53,020
we always would lose or rather that we would always guess an incorrect number which may be, I might

56
00:03:53,020 --> 00:03:57,340
even change this method name in a moment here, because I think that's the actual situation we want

57
00:03:57,340 --> 00:04:01,120
to test here is test what happens when we get the wrong number.

58
00:04:01,150 --> 00:04:01,390
Yeah.

59
00:04:01,390 --> 00:04:02,460
You know, let's change changes.

60
00:04:02,470 --> 00:04:02,950
Test.

61
00:04:03,630 --> 00:04:06,610
Wrong gas situation.

62
00:04:08,060 --> 00:04:13,160
Maybe test one one wrong guess situation.

63
00:04:13,610 --> 00:04:21,440
We want to make sure that we don't accidentally submit the correct number so I can think of a couple

64
00:04:21,440 --> 00:04:23,960
of ways that we might do this.

65
00:04:24,380 --> 00:04:32,840
We could query for the random number and then add +1 to it or minus one from it and then throw that

66
00:04:32,840 --> 00:04:33,680
number in here.

67
00:04:33,710 --> 00:04:40,670
However, what if the random number plus or minus one ends up being maybe like out of the range that

68
00:04:40,670 --> 00:04:42,600
we are allowing or something like that?

69
00:04:42,620 --> 00:04:43,730
Do we want to do that?

70
00:04:44,180 --> 00:04:52,250
Well, I'll tell you what or what we did in the previous guessing game was that we just always submitted

71
00:04:52,250 --> 00:04:52,940
negative.

72
00:04:52,940 --> 00:05:00,110
No guesses to ensure that we were never going to accidentally hit the right number since our allowed

73
00:05:00,110 --> 00:05:03,260
range was really like one to 10 or something like that.

74
00:05:03,410 --> 00:05:08,990
I think maybe we'll just do it that way still, because that's what we did before someone to delete

75
00:05:08,990 --> 00:05:09,980
that thing.

76
00:05:09,980 --> 00:05:12,740
And then we'll just do like a negative five.

77
00:05:12,740 --> 00:05:19,190
And then we will assume that for this scenario, if one wrong guess that you would test one wrong guess

78
00:05:19,190 --> 00:05:21,410
situation, then we'll just say.

79
00:05:24,470 --> 00:05:28,700
You didn't you didn't get it.

80
00:05:29,330 --> 00:05:30,800
Yeah, I guess that's it.

81
00:05:31,400 --> 00:05:31,740
All right.

82
00:05:31,760 --> 00:05:37,370
So let's run all of the tests and see what we get.

83
00:05:38,180 --> 00:05:44,780
OK, so as expected, the first test passes and the second one fails because we hardcoded.

84
00:05:44,780 --> 00:05:47,930
You got it as the return message there.

85
00:05:48,110 --> 00:05:52,780
So now we need to do the smallest, simplest thing to get this method to pass.

86
00:05:52,790 --> 00:06:01,130
So we want to respond with you didn't get it as a result of passing a negative number in.

87
00:06:01,160 --> 00:06:03,740
So let's go look at the gas method here.

88
00:06:03,950 --> 00:06:11,690
So what we could do, the simplest thing to do and perhaps would be to maybe just use a conditional,

89
00:06:11,880 --> 00:06:18,650
maybe something like, well, you know, we could use a ternary operator and then we could keep it really

90
00:06:18,650 --> 00:06:26,330
short and sweet, something like if the guest number is greater than.

91
00:06:29,020 --> 00:06:33,980
Or equal to zero, then return.

92
00:06:34,000 --> 00:06:34,720
You got it.

93
00:06:35,620 --> 00:06:37,750
Otherwise return.

94
00:06:38,970 --> 00:06:39,840
You didn't get it.

95
00:06:40,860 --> 00:06:43,500
And it's about the simplest way we could do this, I think.

96
00:06:44,470 --> 00:06:47,050
Let's rerun all the tests and see what happens.

97
00:06:47,770 --> 00:06:48,670
Hey, there you go.

98
00:06:49,240 --> 00:06:50,680
So we made that all pass.

99
00:06:50,980 --> 00:06:55,780
Now again, I understand that these little changes we're making are us kind of just dancing around the

100
00:06:55,780 --> 00:06:56,500
real issues.

101
00:06:56,500 --> 00:07:03,710
But again, we just want to evolve the tests to force us to write the correct code rather than to to

102
00:07:03,730 --> 00:07:08,140
just assume what all of the code we would need here should be.

103
00:07:08,260 --> 00:07:15,910
That's kind of the whole point, and by doing so, we will end up with close to 100 percent tested testable

104
00:07:15,910 --> 00:07:20,110
code and hopefully no unnecessary lines of code.

105
00:07:20,860 --> 00:07:21,240
All right.

106
00:07:21,250 --> 00:07:28,030
So let's jump back over to the test, and let's think of another scenario that will force us to flesh

107
00:07:28,030 --> 00:07:29,620
out our game engine more.

108
00:07:30,970 --> 00:07:33,580
So test one wrong guest situation.

109
00:07:33,610 --> 00:07:41,050
Well, I don't know, so we could test what happens when you have to run guesses, or maybe we could

110
00:07:41,050 --> 00:07:46,230
test what happens when you have one wrong gas, followed by a correct gas?

111
00:07:46,660 --> 00:07:55,510
Or actually what would happen if we tested another wrong gas situation where we did not hard code a

112
00:07:55,520 --> 00:07:56,630
negative right?

113
00:07:56,660 --> 00:08:03,400
Because we know in real life there will be nine positive numbers that we could guess that would still

114
00:08:03,400 --> 00:08:04,780
be wrong, right?

115
00:08:04,870 --> 00:08:05,830
So I don't know.

116
00:08:05,840 --> 00:08:12,870
Let's see what this looks like if we do something like test.

117
00:08:13,720 --> 00:08:15,610
So let's change this method now.

118
00:08:15,610 --> 00:08:16,810
Let's flesh this out a little more.

119
00:08:16,840 --> 00:08:19,000
Test one wrong gas situation.

120
00:08:19,210 --> 00:08:28,450
Let's call this test one wrong negative, and I'll just write NEG negative guess situation.

121
00:08:28,450 --> 00:08:32,740
And then for this one, let's test one wrong positive.

122
00:08:34,140 --> 00:08:41,580
Guess situation and maybe to derive our positive for now.

123
00:08:42,030 --> 00:08:45,950
Maybe we will go ahead and do something along these lines.

124
00:08:45,960 --> 00:08:49,050
Well, we'll go grab the.

125
00:08:50,120 --> 00:08:55,280
Random number and then we'll just say random number plus one, and for right now, we're not going to

126
00:08:55,280 --> 00:09:00,920
worry about it being out of range or anything since we're not actually enforcing any ranges anyway.

127
00:09:01,100 --> 00:09:09,470
So we know that the random number will eventually always be a positive number between, I guess, one

128
00:09:09,470 --> 00:09:10,040
in 10.

129
00:09:10,370 --> 00:09:17,150
And therefore, if we just add one to it, that will be guaranteed to be the wrong number and also be

130
00:09:17,150 --> 00:09:18,650
guaranteed to be positive.

131
00:09:19,130 --> 00:09:19,860
All right.

132
00:09:19,880 --> 00:09:23,930
And so now let's run all of the tests.

133
00:09:24,560 --> 00:09:25,250
All right.

134
00:09:25,250 --> 00:09:30,020
And so we got to that passed and one that failed in the one that failed is the positive one.

135
00:09:30,020 --> 00:09:37,070
And just as I thought we were expecting, you didn't get it, but we got a you got it because currently

136
00:09:37,070 --> 00:09:44,750
our game logic simply thinks that if we pass a non-negative number in that you win.

137
00:09:45,260 --> 00:09:48,890
So now we need to figure out how to make it smarter than that.

138
00:09:49,700 --> 00:09:51,530
So let's see here.

139
00:09:52,250 --> 00:09:58,010
Maybe the easiest thing we could do now would be something like if.

140
00:09:59,190 --> 00:10:06,690
The guest number equals the random number, then you got it, otherwise you didn't get it.

141
00:10:06,930 --> 00:10:08,940
So that would be pretty easy to do, I think.

142
00:10:09,180 --> 00:10:15,030
So if we do, guest number equals with the equals operator two equal signs.

143
00:10:15,450 --> 00:10:23,280
And then what we can do is we can just call this same method, I suppose, for now, get random number.

144
00:10:23,880 --> 00:10:25,970
Now we're going to have to be a little careful with that.

145
00:10:25,980 --> 00:10:30,420
Perhaps when we flesh this out a little more, I can already kind of foresee something here.

146
00:10:30,420 --> 00:10:34,650
But for now, I think this will make the tests that last test pass.

147
00:10:34,800 --> 00:10:35,400
Let's see.

148
00:10:35,940 --> 00:10:37,410
So we'll rerun everything.

149
00:10:37,830 --> 00:10:38,730
Yeah, there we go.

150
00:10:38,820 --> 00:10:40,350
So now everything's passing.

151
00:10:41,010 --> 00:10:41,390
All right.

152
00:10:41,400 --> 00:10:45,660
Test one wrong positive guest situation.

153
00:10:46,050 --> 00:10:46,590
All right.

154
00:10:46,620 --> 00:10:50,340
What's another test that we can do here?

155
00:10:50,640 --> 00:10:53,550
So we've got one winning situation.

156
00:10:54,670 --> 00:10:57,550
One wrong negative situation.

157
00:10:58,500 --> 00:11:01,320
One wrong positive situation.

158
00:11:01,650 --> 00:11:06,720
So one thing I'm wondering about here is the whole point of the guessing game is that it should start

159
00:11:06,720 --> 00:11:11,880
off by generating a random number.

160
00:11:11,880 --> 00:11:17,550
And right now we know that our game is not generating a random number.

161
00:11:17,850 --> 00:11:31,590
So I think we may want to have a test that somehow validates that our game is actually generating random

162
00:11:31,590 --> 00:11:33,930
numbers whenever we start it.

163
00:11:34,080 --> 00:11:39,480
Oh, actually, OK, so now the next thing that I think we want to do and I apologize, I actually forgot

164
00:11:39,480 --> 00:11:39,840
this.

165
00:11:39,840 --> 00:11:42,360
I should have done it on the second test, but that's OK.

166
00:11:42,360 --> 00:11:43,290
We're on the third test.

167
00:11:43,560 --> 00:11:45,300
We've got duplication, right?

168
00:11:45,660 --> 00:11:47,540
We're generating this guessing game.

169
00:11:47,550 --> 00:11:52,830
We're creating a new instance of the guessing game each time within the each test method here.

170
00:11:52,980 --> 00:11:55,230
And so we can do something about that.

171
00:11:55,860 --> 00:11:57,660
Now we've got the choice to make.

172
00:11:57,720 --> 00:12:05,820
Do we want to extract this game variable out into a field and then initialize it in the field, which

173
00:12:05,820 --> 00:12:10,680
would mean that we'd be using the same exact game engine for each test?

174
00:12:11,010 --> 00:12:17,370
Or do we want to create a new game engine or guessing game each time a test is run?

175
00:12:17,940 --> 00:12:21,630
So we know we're going to have to eventually generate a random number.

176
00:12:21,640 --> 00:12:25,800
So I think a big question is when do we generate that random number?

177
00:12:25,890 --> 00:12:26,210
Right?

178
00:12:26,790 --> 00:12:31,860
If we generate the random number each time we create a new guessing game, which is kind of what I'm

179
00:12:31,860 --> 00:12:40,410
leaning towards, then I would think that we probably do want to have a new instance of this guessing

180
00:12:40,410 --> 00:12:43,110
game for each test.

181
00:12:43,500 --> 00:12:43,890
Right?

182
00:12:44,190 --> 00:12:53,490
And if that is the case, then I think we will want to initialize this guessing game in a setup method.

183
00:12:53,610 --> 00:12:53,940
Right.

184
00:12:54,120 --> 00:12:59,430
So we discussed and one of the previous lessons the difference between initializing the system under

185
00:12:59,430 --> 00:13:04,830
test in a field declaration versus initializing it in a setup method.

186
00:13:04,860 --> 00:13:11,550
The difference is really whether or not you want each test method to share the same system under test,

187
00:13:11,550 --> 00:13:14,940
the exact same instance or if you want different ones.

188
00:13:15,270 --> 00:13:20,940
I'm leaning towards having different instances of the guessing game for each test method.

189
00:13:21,090 --> 00:13:23,310
So let's try that out and see what that will look like.

190
00:13:23,340 --> 00:13:32,120
So if we select the game variable here, we can right click on it, go down to refactor and then introduce

191
00:13:32,130 --> 00:13:32,880
a field.

192
00:13:34,100 --> 00:13:38,210
Just like so and then we can initialize it.

193
00:13:39,170 --> 00:13:43,250
We select this, well, that's acting kind of weird in the setup.

194
00:13:44,180 --> 00:13:46,280
Just like that and then hit return.

195
00:13:47,480 --> 00:13:47,790
All right.

196
00:13:47,830 --> 00:13:54,590
And so now the ABC has extracted out a declaration for the game, the variable there and then it is

197
00:13:54,590 --> 00:13:59,030
initializing it inside of the setup and just a reminder here.

198
00:13:59,060 --> 00:14:08,060
So this setup method having the sanitation of before each means that before each test runs J Unit our

199
00:14:08,270 --> 00:14:15,590
testing framework, we'll call this method each time before this test runs, which means that each test

200
00:14:15,590 --> 00:14:19,910
method will get its own new instance of the guessing game.

201
00:14:20,000 --> 00:14:26,120
And the previous instances of the guessing game will be marked for garbage collection by the JVM, the

202
00:14:26,120 --> 00:14:29,600
Java virtual machine, which I generally refer to as this Java.

203
00:14:31,020 --> 00:14:34,200
All right, so that's just a quick little reminder of what this means.

204
00:14:34,470 --> 00:14:38,190
So now having done this, I can delete this line.

205
00:14:40,160 --> 00:14:43,130
And this line on line 32.

206
00:14:43,550 --> 00:14:48,680
And when whenever we do this kind of refactoring, it's always a good idea to just rerun all the tests

207
00:14:48,680 --> 00:14:51,830
and make sure that what was working before is still working.

208
00:14:52,220 --> 00:14:53,240
So I'm going to rerun.

209
00:14:55,520 --> 00:14:56,070
OK, good.

210
00:14:56,090 --> 00:14:58,340
So apparently, we did not break anything.

211
00:14:58,730 --> 00:14:59,240
Very good.

212
00:15:00,220 --> 00:15:00,850
All right.

213
00:15:01,030 --> 00:15:10,720
So now I think we want to write some kind of a test, if possible, to help us determine whether or

214
00:15:10,720 --> 00:15:15,100
not the game engine is actually generating random numbers, right?

215
00:15:15,400 --> 00:15:20,500
Because that's the whole point of the guessing game is to generate random numbers if it only uses zero

216
00:15:20,500 --> 00:15:22,120
every time as it currently is.

217
00:15:22,420 --> 00:15:24,190
That's not a very good guessing game.

218
00:15:24,670 --> 00:15:26,020
So let's see.

219
00:15:26,020 --> 00:15:32,140
What can we do in a test to ensure that we are generating random number?

220
00:15:32,200 --> 00:15:37,360
I'm going to start off by copying one of these existing methods, and I will paste.

221
00:15:37,750 --> 00:15:38,860
And let's see.

222
00:15:38,860 --> 00:15:48,190
We will test that test random number, generation, something like that.

223
00:15:48,790 --> 00:15:56,590
So we need to think of a strategy for how we can actually ensure that random numbers are being generated.

224
00:15:56,590 --> 00:16:01,660
So let's think about this because I think I think this this may not be super obvious, but I think we're

225
00:16:01,660 --> 00:16:03,160
going to have some fun with this, actually.

226
00:16:03,610 --> 00:16:09,650
So our game is supposed to generate a random number between one and 10.

227
00:16:10,000 --> 00:16:10,450
Right?

228
00:16:11,290 --> 00:16:22,090
And so if we were to run this game 10 times in a row under ideal random circumstances, you might think

229
00:16:22,270 --> 00:16:30,130
that you should see numbers one through 10 equally come up within the random generator, right?

230
00:16:30,280 --> 00:16:35,220
If you run it 10 times, you would expect ideally to see the numbers one through 10.

231
00:16:35,950 --> 00:16:38,770
One time in a perfect random generator.

232
00:16:38,920 --> 00:16:43,840
Now, of course, I already know that the random generators that we have access to here are not that

233
00:16:43,840 --> 00:16:51,730
perfect, and we would need to run it more than 10 times if we wanted to have a chance of seeing numbers

234
00:16:51,730 --> 00:16:54,430
one through 10 come up at least once.

235
00:16:54,910 --> 00:17:02,560
So I'm wondering what would happen if we were to run this game engine 100 times, perhaps.

236
00:17:02,770 --> 00:17:10,990
And then if we kept track of whether or not each of the numbers one through 10 was selected, right?

237
00:17:11,260 --> 00:17:17,980
And then at the end of that 100 times, we just kind of tabulate and say, you know, did we ever get

238
00:17:17,980 --> 00:17:18,400
a one?

239
00:17:18,400 --> 00:17:19,460
Did we ever get it to?

240
00:17:19,480 --> 00:17:22,600
Did we ever get a three, et cetera, et cetera, et cetera, et cetera?

241
00:17:22,810 --> 00:17:27,940
And that might let us know if we have a decent random number generator.

242
00:17:28,370 --> 00:17:33,310
There's I think there's several ways that we could do this, but one way that I'm thinking about might

243
00:17:33,310 --> 00:17:42,430
be, so let's say that we generate numbers one two three four five, six, seven, eight, nine and

244
00:17:42,430 --> 00:17:42,970
10.

245
00:17:43,750 --> 00:17:51,700
And then let's say that we every time we see a number come up from the get random number method, let's

246
00:17:51,700 --> 00:17:55,210
say that we just kind of made a tally mark.

247
00:17:55,210 --> 00:18:02,140
If you will write something like you put a one there and I'll add a one for one, we see a two and a

248
00:18:02,140 --> 00:18:02,560
three.

249
00:18:02,690 --> 00:18:06,730
So, right, so every time these numbers show up, let's say we don't get a five.

250
00:18:06,730 --> 00:18:13,850
The five doesn't show up and then seven doesn't show up in eight does and nine does and 10 does write

251
00:18:13,930 --> 00:18:14,710
something like that.

252
00:18:15,010 --> 00:18:22,030
Now, if we could keep track of that somehow, then at the end of running this program 100 times or

253
00:18:22,030 --> 00:18:28,840
at least generating the random numbers 100 times if we were to add up all of the ones, if we had a

254
00:18:28,840 --> 00:18:34,780
perfect random generator or a good random generator and we ran it 100 times, you would expect that

255
00:18:34,900 --> 00:18:39,190
all of these, including the five and the seven, would have come up at least once.

256
00:18:39,790 --> 00:18:45,940
And so you would expect that if you added up all these ones, you would get at least a 10.

257
00:18:46,330 --> 00:18:46,650
Right?

258
00:18:46,870 --> 00:18:50,710
And then you would know that any number that you added up, that was less than 10.

259
00:18:50,710 --> 00:18:54,220
Especially now let's say that the number two comes up multiple times.

260
00:18:54,490 --> 00:18:56,420
So in that case, maybe we don't tally.

261
00:18:56,500 --> 00:19:01,810
Maybe we simply say, if you ever get any of these to come up, just put a one in it.

262
00:19:01,960 --> 00:19:04,850
Otherwise, let it be a zero or nothing at all.

263
00:19:04,870 --> 00:19:05,200
Right.

264
00:19:05,470 --> 00:19:07,500
So we don't like double and triple count.

265
00:19:07,510 --> 00:19:09,790
We just either it's a one or two zero.

266
00:19:10,000 --> 00:19:10,420
All right.

267
00:19:10,540 --> 00:19:12,570
And then we just add up all the ones.

268
00:19:12,580 --> 00:19:20,410
And so if every single number had come up at least once, you'd have a 10 and anything less than that

269
00:19:20,410 --> 00:19:22,030
would be less than a 10.

270
00:19:22,030 --> 00:19:29,200
And then you would know that the random number generation wasn't maybe completely up to snuff or we

271
00:19:29,200 --> 00:19:32,110
hadn't implemented the random number generation, right?

272
00:19:32,350 --> 00:19:39,730
Furthermore, I think the lower this sum would be, the worse your logic for generating random numbers

273
00:19:39,730 --> 00:19:41,350
would probably be right.

274
00:19:41,800 --> 00:19:47,440
There are definitely some other techniques we could use, but I kind of like this approach because it

275
00:19:47,440 --> 00:19:49,240
tells us a number of things, right?

276
00:19:49,270 --> 00:19:52,630
Like how far off is our random number generation technique?

277
00:19:52,840 --> 00:19:59,740
And it gives us a pretty easy way to quickly determine whether or not we are able to generate.

278
00:20:00,060 --> 00:20:04,110
Random numbers that run the gamut of our range.

279
00:20:04,320 --> 00:20:09,300
So now the question is, OK, how could we code this in a test, right?

280
00:20:10,200 --> 00:20:12,270
Well, here are some patterns that I'm seeing.

281
00:20:12,300 --> 00:20:18,210
I'm seeing that we want to track something that happens across the numbers one through 10 and we want

282
00:20:18,210 --> 00:20:26,070
to associate in this case, some numbers, maybe one in zero with the numbers on top.

283
00:20:27,450 --> 00:20:33,540
And so can you think of a mechanism that we have already learned in programming that would allow us

284
00:20:33,540 --> 00:20:39,560
to associate these bottom numbers with these top numbers?

285
00:20:39,570 --> 00:20:44,070
And this might not be obvious to you, but take a moment to think about this and then I'll tell you

286
00:20:44,070 --> 00:20:44,940
what I'm thinking.

287
00:20:46,770 --> 00:20:47,220
All right.

288
00:20:47,490 --> 00:20:53,580
So I'm thinking this might be a decent scenario for us to use an array.

289
00:20:53,940 --> 00:21:00,180
Now we learned about a raise a while back and you might not remember them, but if you may recall,

290
00:21:00,180 --> 00:21:04,680
an array is basically a collection of things.

291
00:21:04,800 --> 00:21:11,730
You can have an array of integers or an array of strings whenever we create a public static void.

292
00:21:11,730 --> 00:21:14,760
Main method In fact, I'll make one right quick here.

293
00:21:14,790 --> 00:21:22,320
The main method gets passed in to it and array, which is signified by these left and right square brackets.

294
00:21:22,650 --> 00:21:29,160
It gets passed into it an array of strings, which is referred to with this name args, which is short

295
00:21:29,160 --> 00:21:30,040
for arguments.

296
00:21:30,090 --> 00:21:32,820
OK, so that's one example of an array.

297
00:21:33,060 --> 00:21:39,090
So go back and watch the lesson where we cover arrays if you need a quick refresher on how they work.

298
00:21:39,540 --> 00:21:47,970
So one of the characteristics of an array is that arrays have elements in them, and those elements

299
00:21:47,970 --> 00:21:50,250
can be accessed with an index.

300
00:21:50,400 --> 00:21:56,250
And that index is just a number usually zero based, though, but it's just the number.

301
00:21:56,580 --> 00:22:04,290
And so these numbers here could be the index into the array, and we could have an array of integers

302
00:22:04,650 --> 00:22:09,360
and the integers that we would store in the array would be zeros and ones.

303
00:22:09,660 --> 00:22:15,810
So what I'm thinking here is that we would call get random number and it would generate a random number.

304
00:22:15,810 --> 00:22:22,460
And if the implementation of get random number is proper, meaning that it actually truly is generated,

305
00:22:22,500 --> 00:22:28,050
generating a random number between one and 10, then we would take that number and then we would use

306
00:22:28,050 --> 00:22:31,090
it as the index into an array.

307
00:22:31,110 --> 00:22:35,100
So let's say that we call it get random number and it generates a three.

308
00:22:35,220 --> 00:22:43,650
So then we would pass that into an array to say, give us the array element three.

309
00:22:44,650 --> 00:22:53,410
And then we would set that element to a one and then we call get random number again and maybe the next

310
00:22:53,410 --> 00:23:01,510
time it generates a six, and so then we use that six, which would be stored in here to access the

311
00:23:01,510 --> 00:23:05,800
elements six of the same array, and we set that to a one.

312
00:23:06,100 --> 00:23:11,170
But let's also imagine that we never get random number to generate a two.

313
00:23:11,830 --> 00:23:18,460
And so the element two of this array would just be zero, perhaps by default.

314
00:23:18,700 --> 00:23:19,090
Right.

315
00:23:19,420 --> 00:23:27,490
And so when we then finish generating the calling random number, let's say, 100 times or so, we could

316
00:23:27,490 --> 00:23:34,660
simply add up all of the numbers in all of the elements of this array and see if we got 10 and if we

317
00:23:34,660 --> 00:23:41,590
got something less than 10, then we know that our maybe our random number generating method is not

318
00:23:41,590 --> 00:23:42,820
ideal yet.

319
00:23:43,570 --> 00:23:44,020
All right.

320
00:23:44,290 --> 00:23:50,290
Now, if we want to run this 100 times, can you think of a way that we could do this within one test

321
00:23:50,620 --> 00:23:56,220
to run this, plus the logic I just outlined 100 times?

322
00:23:56,230 --> 00:23:57,730
Can you think of how you could do that?

323
00:23:58,000 --> 00:23:59,590
Go ahead and take a moment to think about it?

324
00:24:01,630 --> 00:24:08,650
All right, so I'm thinking we could use a for loop and just tell the far loop to run 100 times, right?

325
00:24:09,220 --> 00:24:09,460
All right.

326
00:24:09,470 --> 00:24:14,650
So without further ado, let's let's try this out and see see how we can do this.

327
00:24:15,220 --> 00:24:17,290
So let's start with the loop.

328
00:24:17,560 --> 00:24:22,600
So we'll have a for loop for integer counters.

329
00:24:22,600 --> 00:24:30,130
So the first thing for our for loop inside of it is we usually will declare and initialize a counter

330
00:24:30,130 --> 00:24:36,280
variable of some sort so we can have an integer called counter or count or whatever.

331
00:24:36,280 --> 00:24:37,770
It doesn't really matter what it's called.

332
00:24:37,780 --> 00:24:40,570
You could call it index, maybe or maybe not index.

333
00:24:40,900 --> 00:24:42,220
And then you'll initialize it.

334
00:24:42,220 --> 00:24:44,800
And so I'll initialize this to zero for now.

335
00:24:45,250 --> 00:24:47,440
And then you'll use a semicolon.

336
00:24:47,890 --> 00:24:54,940
And then the next part of the for loop is where we teach the for loop, when it should stop.

337
00:24:55,150 --> 00:25:03,730
So in this case, I think we want to say something like while the counter is less than 100 because we

338
00:25:03,730 --> 00:25:09,100
want to count 100 times, so this would go from zero to 99, actually.

339
00:25:09,400 --> 00:25:09,670
All right.

340
00:25:09,700 --> 00:25:10,870
But that would be 100.

341
00:25:11,440 --> 00:25:11,710
All right.

342
00:25:11,710 --> 00:25:18,340
And then another semicolon and then we just have to increment the counter counter plus plus like so.

343
00:25:18,880 --> 00:25:19,290
All right.

344
00:25:19,300 --> 00:25:24,850
And then we have the body of the loop, which we start off with a curly brace.

345
00:25:25,390 --> 00:25:27,460
Like so and all right.

346
00:25:27,700 --> 00:25:33,040
And now we can start calling this game that get random numbers.

347
00:25:33,040 --> 00:25:39,310
So I'm actually going to grab this line here, line 41 and bring it inside and then indent.

348
00:25:40,690 --> 00:25:41,090
All right.

349
00:25:41,110 --> 00:25:45,850
So we're going to call get random number and then we're going to need an array.

350
00:25:46,030 --> 00:25:54,550
Now we want this array to exist beyond just the scope of this loop, and therefore we need to declare

351
00:25:54,550 --> 00:25:56,530
this array outside of the loop.

352
00:25:56,530 --> 00:26:02,050
So I'm actually going to trade a new line up here and to create and declare an array.

353
00:26:02,230 --> 00:26:04,540
We have to tell it what the data type is.

354
00:26:04,540 --> 00:26:10,000
So we're going to say here's an integer array and then the name of the array.

355
00:26:10,000 --> 00:26:10,480
I don't know.

356
00:26:10,510 --> 00:26:15,010
Maybe I will call it random number count.

357
00:26:15,220 --> 00:26:18,430
Notice how I abbreviate things out of laziness, really?

358
00:26:18,670 --> 00:26:25,840
Now I think in the lesson where we talked about arrays, I may have shown you that we can initialize

359
00:26:25,840 --> 00:26:30,220
with curly braces, but in this case, we don't actually want to initialize this.

360
00:26:30,460 --> 00:26:36,010
Instead, we just want to say that we want an array of 10 elements.

361
00:26:36,010 --> 00:26:42,610
So to do that, we can say new and 10 colon like so.

362
00:26:42,790 --> 00:26:49,630
So what this is saying is give us a new array of integers with 10 elements.

363
00:26:49,780 --> 00:26:50,230
OK.

364
00:26:50,740 --> 00:26:51,140
All right.

365
00:26:51,160 --> 00:26:59,320
And then down here, now we can start actually storing information in the elements in the 10 elements

366
00:26:59,320 --> 00:27:00,280
of this array.

367
00:27:00,310 --> 00:27:07,090
So what we will do is simply we will access the array by name random count.

368
00:27:07,420 --> 00:27:14,200
And then we use the square brackets and then we access whichever element so that say that get random

369
00:27:14,200 --> 00:27:15,820
number generator for.

370
00:27:15,850 --> 00:27:20,350
So that means we would want element four of this array.

371
00:27:20,560 --> 00:27:23,890
So we'll pass and whatever we get back from this call.

372
00:27:24,100 --> 00:27:25,510
So what?

373
00:27:27,200 --> 00:27:30,440
So we can say random, numb.

374
00:27:32,550 --> 00:27:36,300
Equals and then all we have to do is hard code the number one in here.

375
00:27:36,360 --> 00:27:36,810
OK.

376
00:27:37,410 --> 00:27:38,260
That's all we have to do.

377
00:27:38,260 --> 00:27:39,480
This is hard code one.

378
00:27:39,750 --> 00:27:40,170
All right.

379
00:27:40,470 --> 00:27:45,030
So imagine we call it get random number and it generates the number one.

380
00:27:45,300 --> 00:27:50,610
And so then we store into element one, the number one.

381
00:27:50,880 --> 00:27:55,170
Then we call it again in this loop and it generates a two.

382
00:27:55,530 --> 00:27:58,470
And so we store one in here and then engineering to three.

383
00:27:58,470 --> 00:28:03,330
Now, of course, in real life, our random number generator probably wouldn't go an order like that,

384
00:28:03,480 --> 00:28:06,180
but I'm just kind of trying to illustrate the point, right?

385
00:28:06,180 --> 00:28:10,890
So if it generated each of these numbers, then we'd end up storing a one in each of them.

386
00:28:10,980 --> 00:28:17,760
And then when we're done with this loop, we could run another loop, which simply sums up all the numbers

387
00:28:17,760 --> 00:28:21,990
in this array and hopefully we get a 10 back out.

388
00:28:22,260 --> 00:28:25,110
And then if it repeats certain numbers, that's fine.

389
00:28:25,410 --> 00:28:27,180
That means you already had a one there.

390
00:28:27,180 --> 00:28:30,060
You're not hurting anything by setting it to one again.

391
00:28:30,300 --> 00:28:37,020
And if it misses any numbers, then by default, because they are integers, the default value of an

392
00:28:37,020 --> 00:28:39,120
integer is always a zero anyway.

393
00:28:39,870 --> 00:28:40,360
All right.

394
00:28:40,380 --> 00:28:48,180
So that should set all of the ones for all of the random numbers 100 times.

395
00:28:48,450 --> 00:28:53,250
And then what we'll need to do is to simply sum them all up and to do that.

396
00:28:53,280 --> 00:28:57,600
I think maybe the easiest thing to do is just to use another for loop again.

397
00:28:57,870 --> 00:29:04,740
So on another line, we'll set up another for loop, and I think it'll look the same integer.

398
00:29:04,860 --> 00:29:07,920
In fact, I'm going to use the exact same parameters.

399
00:29:08,970 --> 00:29:13,260
My own counter is less than 100 counter + +.

400
00:29:14,440 --> 00:29:22,210
Now, the reason I can reuse this same counter variable here is because this variable counter only has

401
00:29:22,210 --> 00:29:24,090
scope within this for loop.

402
00:29:24,370 --> 00:29:31,960
So this counter here is different from this counter here, right, because they are only available or

403
00:29:31,960 --> 00:29:34,330
valid inside of this loop.

404
00:29:34,600 --> 00:29:40,390
And once the thread leaves this loop, this counter variable ceases to exist.

405
00:29:40,570 --> 00:29:45,490
And once the thread enters this loop, this is a brand new counter variable that's separate and distinct

406
00:29:45,490 --> 00:29:46,360
from that one.

407
00:29:46,500 --> 00:29:48,430
OK, so that's why I can reuse this name.

408
00:29:49,060 --> 00:29:49,590
All right.

409
00:29:49,600 --> 00:29:54,100
So here we just want to sum up the numbers.

410
00:29:54,280 --> 00:30:00,100
Now I am actually thinking we will want an integer that holds the thumb.

411
00:30:00,340 --> 00:30:05,680
And again, because I want to use that integer outside of this loop, I think we need to define it.

412
00:30:05,770 --> 00:30:08,250
We need to declare it outside of the loop.

413
00:30:08,260 --> 00:30:12,600
So let's let's declare an integer called for now.

414
00:30:12,610 --> 00:30:15,700
Just I'll call it some, and that's all we need.

415
00:30:15,700 --> 00:30:19,540
There is default will be zero with default value will be zero.

416
00:30:19,540 --> 00:30:21,530
So I don't have to say some equals zero.

417
00:30:21,550 --> 00:30:22,810
It already is zero.

418
00:30:23,440 --> 00:30:23,800
All right.

419
00:30:23,840 --> 00:30:26,230
And so now all we need to do.

420
00:30:26,740 --> 00:30:31,540
Oh, actually, one more thing now, actually, we don't need to go 100 times here because we only have

421
00:30:31,540 --> 00:30:32,500
10 elements.

422
00:30:32,500 --> 00:30:37,120
All we're going to do is add up all of the values of those 10 elements.

423
00:30:37,390 --> 00:30:43,090
And so we only need to go to 10 here, 029.

424
00:30:43,210 --> 00:30:50,140
However, now we need to be careful here the numbers that we could be generating with our random number

425
00:30:50,140 --> 00:30:50,980
generator.

426
00:30:51,010 --> 00:30:56,750
Once we implement the logic are meant to be one through 10, not zero through nine.

427
00:30:56,770 --> 00:31:02,170
However, this here currently is expecting zero through nine.

428
00:31:02,440 --> 00:31:05,290
So we want to be careful here how we line this up.

429
00:31:05,530 --> 00:31:11,380
So a couple of thoughts I'm having are that we could just be safe and go zero through 11, which I think

430
00:31:11,380 --> 00:31:12,820
I'm fine to do.

431
00:31:12,820 --> 00:31:17,710
And that way we make sure we get everything or else we need to be a little more careful with what we're

432
00:31:17,710 --> 00:31:22,720
doing up here for now, out of laziness, I suppose I'm going to just say zero to 11.

433
00:31:22,900 --> 00:31:25,150
We may have to come back and revisit this, though.

434
00:31:25,360 --> 00:31:28,780
All right, so let's see now.

435
00:31:28,780 --> 00:31:37,720
All we need to do is to access the array element that is pointed to by this counter.

436
00:31:37,720 --> 00:31:43,420
So what that would look like is random num count counter, right?

437
00:31:43,420 --> 00:31:45,100
So then that gives us the number.

438
00:31:45,940 --> 00:31:49,630
And now what we want to do is just add that to the sum.

439
00:31:49,870 --> 00:31:52,960
And the way we can do that is to say some.

440
00:31:53,200 --> 00:31:54,630
Now there's a few ways we can do this.

441
00:31:54,640 --> 00:32:02,680
We can say some equals some plus that number.

442
00:32:03,060 --> 00:32:06,970
OK, we're being told that the sum may not have been initialized.

443
00:32:07,270 --> 00:32:11,860
So just to make that happy, we can come up here and just say equals zero.

444
00:32:12,340 --> 00:32:12,910
All right.

445
00:32:12,970 --> 00:32:19,300
So what this should do is now we're going to loop over the numbers zero through 11 and we're going to

446
00:32:19,300 --> 00:32:24,010
access each value that would be these values here.

447
00:32:24,190 --> 00:32:27,910
So these are the element indexes which would be in the counter.

448
00:32:28,090 --> 00:32:32,770
And then these would be an example of the potential values that would be in there.

449
00:32:32,920 --> 00:32:40,300
So when this is when counter, it's one we're going to access element one of the array and get whatever

450
00:32:40,300 --> 00:32:43,240
is inside of it, which will be either a zero or a one.

451
00:32:43,420 --> 00:32:46,120
And then we will add that to the sum.

452
00:32:46,300 --> 00:32:51,280
Now do you remember there's also a shorthand way to say some equals some plus random count?

453
00:32:51,610 --> 00:32:52,870
Do you remember what that was?

454
00:32:53,290 --> 00:33:00,700
Instead of writing all of this out, we could just do some plus equals.

455
00:33:01,000 --> 00:33:05,440
So that means the same thing, just in a shorthand sum, equal sum, plus whatever.

456
00:33:05,620 --> 00:33:06,730
Just a little shorthand.

457
00:33:07,000 --> 00:33:07,580
All right.

458
00:33:07,630 --> 00:33:15,190
And then when we're done, I wouldn't mind temporarily just printing out that sum just to make sure

459
00:33:15,190 --> 00:33:18,850
that our logic makes some kind of sense, no pun intended.

460
00:33:19,270 --> 00:33:23,890
And then we're going to need an assertion someone to get rid of that line.

461
00:33:24,220 --> 00:33:29,050
And I think our assertion will be pretty easy.

462
00:33:29,200 --> 00:33:35,200
So if we're completely up to snuff, then I think our assertion is that we would have 10 write a value

463
00:33:35,200 --> 00:33:42,070
of 10, which would mean that all of the elements had been selected at least once.

464
00:33:42,430 --> 00:33:51,070
So 10, we're going to expect a 10 from some and actually in in what sense we are using this assertion

465
00:33:51,070 --> 00:33:51,280
here.

466
00:33:51,280 --> 00:33:56,440
We don't actually need to print that out because the ADP is going to tell us in the report what this

467
00:33:56,440 --> 00:34:00,160
number was, if it's especially if it's different from what we got there.

468
00:34:00,160 --> 00:34:01,600
So we don't actually need that.

469
00:34:01,930 --> 00:34:02,350
All right.

470
00:34:02,380 --> 00:34:03,670
I know this is kind of a lot.

471
00:34:03,880 --> 00:34:08,500
Let's run it real quick, though, and see what we end up with and then we'll go from there.

472
00:34:08,770 --> 00:34:09,970
So see here.

473
00:34:09,970 --> 00:34:13,870
I'm going to go all the way up to the top, and I'm just going to rerun all of the tests.

474
00:34:14,350 --> 00:34:14,760
OK.

475
00:34:15,130 --> 00:34:15,640
Very good.

476
00:34:15,790 --> 00:34:17,770
So that last one is failing.

477
00:34:18,640 --> 00:34:21,400
And we've got an index out of bounds exception.

478
00:34:21,730 --> 00:34:22,040
All right.

479
00:34:22,060 --> 00:34:24,230
So let's see what happened there.

480
00:34:24,250 --> 00:34:31,060
Now, if we come down here and we look at this line, it's going to tell us what line of code were the

481
00:34:31,060 --> 00:34:36,100
exception is happening line 49 and we can actually click on that and it'll take take us right there.

482
00:34:36,370 --> 00:34:37,930
So right here.

483
00:34:38,350 --> 00:34:39,520
Oh, OK, I see.

484
00:34:39,790 --> 00:34:45,760
So I'm told our code to access up to Element 10, right?

485
00:34:45,760 --> 00:34:52,030
Because anything less than 11, which means 10 and there is no Element 10 because we only have 10 elements

486
00:34:52,030 --> 00:34:52,840
in the array.

487
00:34:53,290 --> 00:34:59,530
And the first element is is element zero, which means that the last element would be element nine.

488
00:34:59,950 --> 00:35:05,950
And this allows us to access an element 10 of which there is not one, right?

489
00:35:06,250 --> 00:35:11,410
So we're going to have to think think about these index bounds a little more carefully now.

490
00:35:11,740 --> 00:35:13,750
So let's see here.

491
00:35:14,080 --> 00:35:23,380
Maybe the easiest thing to do for now would actually be to just make 11 elements here.

492
00:35:23,500 --> 00:35:29,890
What I'm concerned with is that eventually we will implement our game logic such that it only generates

493
00:35:29,890 --> 00:35:35,800
numbers one through 10, which means that Element Zero might not ever get used right.

494
00:35:36,040 --> 00:35:39,850
Element zero of this array might never get used.

495
00:35:39,940 --> 00:35:44,350
So we could just let it go unused, which is what I'm inclined to do.

496
00:35:44,350 --> 00:35:47,920
Or else we'd have to get a little fancier and generate this random number.

497
00:35:48,160 --> 00:35:53,410
And then when we set and then when we use that random number, we do something random number minus one,

498
00:35:53,620 --> 00:35:57,070
which I don't really want to do because I think that could get a little confusing.

499
00:35:57,370 --> 00:36:05,680
So I think instead, we'll just generate 11 elements here and now everything should be in sync.

500
00:36:05,740 --> 00:36:05,980
All right.

501
00:36:05,990 --> 00:36:07,300
So let's run that again.

502
00:36:07,810 --> 00:36:08,230
All right.

503
00:36:08,380 --> 00:36:09,910
So it's still failing, which it should.

504
00:36:10,120 --> 00:36:11,540
But now it's failing are.

505
00:36:12,630 --> 00:36:16,440
And a very expected way, we expected 10 and we only got one.

506
00:36:17,350 --> 00:36:18,820
And that makes sense to me.

507
00:36:19,180 --> 00:36:25,540
Currently, they get random, no method is returning zero, which is outside of the range that we will

508
00:36:25,540 --> 00:36:28,500
be allowing in the future, but we haven't implemented that yet.

509
00:36:28,510 --> 00:36:31,150
So right now it's generating a zero.

510
00:36:31,480 --> 00:36:38,380
And so we're setting element zero to one and then we're summing up all of the elements.

511
00:36:38,710 --> 00:36:44,170
So we're setting element zero to one, whereas all the remaining elements would be zero.

512
00:36:44,200 --> 00:36:46,810
And so when you sum all of that up, you get a one.

513
00:36:46,990 --> 00:36:53,200
And so this is failing, which is telling us that our random number generation algorithm isn't implemented

514
00:36:53,200 --> 00:36:53,620
yet.

515
00:36:54,130 --> 00:36:54,480
All right.

516
00:36:54,490 --> 00:36:59,650
So I know that this has been a long lesson, and some of you may feel like you're struggling a little

517
00:36:59,650 --> 00:37:01,250
bit to follow along.

518
00:37:01,270 --> 00:37:01,990
Don't worry.

519
00:37:02,140 --> 00:37:03,560
Stay with me on this.

520
00:37:03,580 --> 00:37:04,750
We'll get this working.

521
00:37:04,750 --> 00:37:09,940
And then for those of you who still feel like you need a little more help, I will make an additional

522
00:37:09,940 --> 00:37:16,720
lesson to go even into more detail, to go really slowly and make sure that you can really see how this

523
00:37:16,720 --> 00:37:17,230
is working.

524
00:37:17,230 --> 00:37:20,110
So please don't worry, just just stick with us, OK?

525
00:37:20,380 --> 00:37:22,480
And so I will see you in the next video.
