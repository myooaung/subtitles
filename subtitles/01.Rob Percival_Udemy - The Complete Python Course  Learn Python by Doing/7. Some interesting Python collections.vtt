WEBVTT
1
1

00:00:00.080  -->  00:00:01.150
<v Jose>Hi and welcome back.</v>
2

2

00:00:01.150  -->  00:00:02.850
In this video I wanted to tell you a little bit
3

3

00:00:02.850  -->  00:00:04.930
about some interesting Python collections
4

4

00:00:04.930  -->  00:00:07.090
that come built in with the language
5

5

00:00:07.090  -->  00:00:10.010
that you can use for a few different things.
6

6

00:00:10.010  -->  00:00:11.470
So the main purpose of this video
7

7

00:00:11.470  -->  00:00:13.690
is to make you aware that these things exist
8

8

00:00:14.590  -->  00:00:17.140
because once you know they exist, later on,
9

9

00:00:17.140  -->  00:00:19.620
you may find a situation where using one of them
10

10

00:00:19.620  -->  00:00:21.000
could be useful.
11

11

00:00:21.000  -->  00:00:22.860
Again going with the analogy of the tools
12

12

00:00:22.860  -->  00:00:24.230
and the construction project,
13

13

00:00:24.230  -->  00:00:27.850
I'm just giving you a few more unorthodox tools
14

14

00:00:27.850  -->  00:00:29.660
that, nonetheless, could be useful.
15

15

00:00:30.710  -->  00:00:32.360
Normally what happens in one of the situations
16

16

00:00:32.360  -->  00:00:33.850
where we could do with one of these tools
17

17

00:00:33.850  -->  00:00:35.590
but we don't know about them,
18

18

00:00:35.590  -->  00:00:37.850
is that we have to work really hard
19

19

00:00:37.850  -->  00:00:40.010
to build one that works well.
20

20

00:00:41.150  -->  00:00:44.340
Instead of doing that, you can just use one of these.
21

21

00:00:44.340  -->  00:00:46.730
So let's get started with the first one.
22

22

00:00:46.730  -->  00:00:48.730
First one's gonna be a counter.
23

23

00:00:48.730  -->  00:00:52.770
A counter, as you can imagine, allows us to count things.
24

24

00:00:52.770  -->  00:00:55.870
So you can give it an iterable or a mapping,
25

25

00:00:55.870  -->  00:00:57.140
like a dictionary,
26

26

00:00:57.140  -->  00:00:58.760
and it would turn it into a counter of elements
27

27

00:00:58.760  -->  00:01:01.330
so you can count how many there are pretty easily.
28

28

00:01:02.260  -->  00:01:05.760
Again, how you do is from collections, import counter
29

29

00:01:06.840  -->  00:01:09.190
and everything we're gonna be looking at in this video
30

30

00:01:09.190  -->  00:01:11.650
comes from the Collections module.
31

31

00:01:11.650  -->  00:01:13.330
These are some pretty useful collections.
32

32

00:01:13.330  -->  00:01:15.130
Feel free to look up the Python documentation
33

33

00:01:15.130  -->  00:01:16.460
if you wanna learn more about these
34

34

00:01:16.460  -->  00:01:17.730
or others that are there.
35

35

00:01:18.760  -->  00:01:21.110
And what we're gonna do is say something
36

36

00:01:21.110  -->  00:01:22.480
like device_temperatures
37

37

00:01:23.560  -->  00:01:28.560
is 13.5, 14.0, 14.0, 14.5, 14.5, 14.5, 14.5, 15.0 and 16.0.
38

38

00:01:32.240  -->  00:01:33.880
Let us imagine we've got some sort of thermometer
39

39

00:01:33.880  -->  00:01:35.430
that's been doing some readings
40

40

00:01:35.430  -->  00:01:37.260
and we want to find out what the most
41

41

00:01:37.260  -->  00:01:39.180
common temperature of our system is.
42

42

00:01:40.730  -->  00:01:44.190
We could do some really contrived thing
43

43

00:01:44.190  -->  00:01:46.790
where we loop over it,
44

44

00:01:46.790  -->  00:01:50.300
We keep track of the ones that we've already seen,
45

45

00:01:50.300  -->  00:01:54.050
we increase one every time we look at it.
46

46

00:01:56.600  -->  00:01:59.130
That's just giving me a headache just thinking about it.
47

47

00:01:59.130  -->  00:02:03.490
So, instead, we can do temperature, counter is going to be
48

48

00:02:03.490  -->  00:02:06.350
a counter of device temperatures
49

49

00:02:06.350  -->  00:02:10.650
and then we can print temperature counter 14.0.
50

50

00:02:10.650  -->  00:02:12.750
So, access it as if it were a dictionary.
51

51

00:02:12.750  -->  00:02:16.470
Just access the key that you want to get the count from
52

52

00:02:16.470  -->  00:02:18.390
and you can see that it gives you two.
53

53

00:02:19.400  -->  00:02:23.260
And if you go for 14.5, it gives you three.
54

54

00:02:24.537  -->  00:02:26.210
Pretty simple counter.
55

55

00:02:26.210  -->  00:02:28.540
You can give it a dictionary as well
56

56

00:02:28.540  -->  00:02:32.460
and it will also turn it into a counter of things.
57

57

00:02:32.460  -->  00:02:35.684
So, for example, you could have a counter
58

58

00:02:35.684  -->  00:02:40.510
of greetings, how many times something has been said.
59

59

00:02:40.510  -->  00:02:43.130
Let's say hello has been said five times,
60

60

00:02:43.130  -->  00:02:45.690
hi has been said three times,
61

61

00:02:45.690  -->  00:02:48.030
and then you can access a particular one
62

62

00:02:48.030  -->  00:02:52.130
and it will just tell you again how many you've done.
63

63

00:02:53.780  -->  00:02:55.360
So here, again, you get the three.
64

64

00:02:55.360  -->  00:02:57.374
This one's not that useful.
65

65

00:02:57.374  -->  00:03:00.330
The official Python documentation uses this example.
66

66

00:03:00.330  -->  00:03:03.330
I'm still not 100% sure on why you would do this.
67

67

00:03:03.330  -->  00:03:06.210
After all, you do have the counts here.
68

68

00:03:06.210  -->  00:03:09.250
You don't need to wrap them in a counter for anything,
69

69

00:03:09.250  -->  00:03:11.130
but I can see the usefulness for a list.
70

70

00:03:11.130  -->  00:03:11.963
So who knows?
71

71

00:03:11.963  -->  00:03:13.890
Maybe I'll find the situation where doing this is useful
72

72

00:03:13.890  -->  00:03:17.610
later on, but I've not yet been able to use
73

73

00:03:17.610  -->  00:03:21.670
a counter mapping for anything professionally,
74

74

00:03:21.670  -->  00:03:24.100
but I've used this and it can be quite useful.
75

75

00:03:26.440  -->  00:03:27.370
That's the counter.
76

76

00:03:27.370  -->  00:03:28.320
Very simple.
77

77

00:03:28.320  -->  00:03:30.530
Again, if you want to learn more about counters,
78

78

00:03:30.530  -->  00:03:32.910
feel free to check out the official Python documentation.
79

79

00:03:32.910  -->  00:03:36.450
It'll be in the further reading lecture of this section,
80

80

00:03:36.450  -->  00:03:38.000
so feel free to check that out.
81

81

00:03:38.880  -->  00:03:41.910
Now, the code for this video will all be available
82

82

00:03:41.910  -->  00:03:44.010
altogether, but I'm going to just delete it
83

83

00:03:44.010  -->  00:03:46.200
and go over to the next collection here
84

84

00:03:46.200  -->  00:03:48.940
just to keep things a bit simpler, but the code will have
85

85

00:03:48.940  -->  00:03:51.450
each counter, sorry not each counter,
86

86

00:03:51.450  -->  00:03:54.890
will have each collection all in the same page.
87

87

00:03:56.390  -->  00:03:58.560
So let's move onto default dict.
88

88

00:03:59.600  -->  00:04:03.620
As we know, when we have a dict, such as this one,
89

89

00:04:03.620  -->  00:04:07.180
hello, we'll set five times for example,
90

90

00:04:07.180  -->  00:04:11.650
and we print my dict hi, we know what's gonna happen
91

91

00:04:11.650  -->  00:04:12.910
when we do this.
92

92

00:04:12.910  -->  00:04:14.720
It's gonna give us an error,
93

93

00:04:14.720  -->  00:04:17.530
and indeed, as you can see here, we get a key error on hi
94

94

00:04:17.530  -->  00:04:18.780
because it doesn't exist.
95

95

00:04:19.880  -->  00:04:23.270
The default dict never raises a key error.
96

96

00:04:24.690  -->  00:04:25.523
Cool.
97

97

00:04:25.523  -->  00:04:27.190
So that's not it, though.
98

98

00:04:27.190  -->  00:04:30.610
Instead, it returns the value returned by the function
99

99

00:04:30.610  -->  00:04:32.850
specified when the object was instantiated.
100

100

00:04:32.850  -->  00:04:34.910
Whew, that was a mouthful.
101

101

00:04:34.910  -->  00:04:37.060
Let's do some code.
102

102

00:04:37.060  -->  00:04:39.570
From collections, import default dict
103

103

00:04:39.570  -->  00:04:41.700
and what we're gonna do is we're going to have a list
104

104

00:04:41.700  -->  00:04:45.020
of coworkers and where they studied,
105

105

00:04:45.020  -->  00:04:48.000
so here we've got a list of tuples
106

106

00:04:48.000  -->  00:04:50.120
where the first element of the tuple is the name
107

107

00:04:50.120  -->  00:04:53.070
of the coworker and the second one is where they studied.
108

108

00:04:53.070  -->  00:04:55.060
So, you can see Rolf went to MIT, Jen went to Oxford,
109

109

00:04:55.060  -->  00:04:57.450
Rolf then went to Cambridge to do a master's degree
110

110

00:04:57.450  -->  00:04:59.650
and then Charlie went to Manchester at the end.
111

111

00:04:59.650  -->  00:05:01.930
Now, let's say we wanted to create a dictionary
112

112

00:05:01.930  -->  00:05:05.440
that maps names to where they've been.
113

113

00:05:05.440  -->  00:05:06.790
Something like this.
114

114

00:05:06.790  -->  00:05:10.730
Rolf went to, oh sorry forgot the colon there,
115

115

00:05:10.730  -->  00:05:15.730
went to MIT and Cambridge and then Jen went to Oxford
116

116

00:05:18.980  -->  00:05:23.770
and then Charlie went to Manchester.
117

117

00:05:23.770  -->  00:05:25.134
Man-Chester.
118

118

00:05:25.134  -->  00:05:26.290
Manchester!
119

119

00:05:26.290  -->  00:05:28.030
There, there we go.
120

120

00:05:28.030  -->  00:05:30.030
Imagine we wanted to make this dictionary,
121

121

00:05:30.030  -->  00:05:31.680
but we only have this data.
122

122

00:05:33.057  -->  00:05:36.910
So an option would be to go over each element
123

123

00:05:36.910  -->  00:05:38.802
and put them in a dictionary.
124

124

00:05:38.802  -->  00:05:41.700
Something more or less that looks like this.
125

125

00:05:41.700  -->  00:05:43.910
We'd create our dictionary, alma maters,
126

126

00:05:43.910  -->  00:05:46.620
which just means places where they've studied,
127

127

00:05:46.620  -->  00:05:49.620
then we would iterate over our coworkers list
128

128

00:05:49.620  -->  00:05:52.410
in coworkers there.
129

129

00:05:53.381  -->  00:05:55.660
The coworker is now a tuple.
130

130

00:05:55.660  -->  00:05:58.080
Zero is Rolf and one is MIT.
131

131

00:05:58.990  -->  00:06:03.990
So we would say alma maters, coworker zero is an empty list,
132

132

00:06:05.880  -->  00:06:10.880
first of all, and alma maters, coworker zero
133

133

00:06:11.040  -->  00:06:14.800
dot append, coworker one.
134

134

00:06:14.800  -->  00:06:17.100
So coworker one is MIT and what we're doing
135

135

00:06:17.100  -->  00:06:20.130
is we're accessing the Rolf value of our dictionary
136

136

00:06:20.130  -->  00:06:24.390
which has just been initialised, that's the word,
137

137

00:06:24.390  -->  00:06:26.260
has been initialised to be an empty list
138

138

00:06:26.260  -->  00:06:28.220
and we're gonna append to that empty list
139

139

00:06:28.220  -->  00:06:30.750
the places where he's been.
140

140

00:06:30.750  -->  00:06:35.250
Now, this works fine as long as they only appear once.
141

141

00:06:35.250  -->  00:06:37.890
The first time they appear, in this case, Rolf,
142

142

00:06:37.890  -->  00:06:41.270
we initialise it to an empty list and then we put MIT in it
143

143

00:06:41.270  -->  00:06:42.210
then we do the same for Jen.
144

144

00:06:42.210  -->  00:06:45.600
We initialise her to an empty list and we put Oxford in,
145

145

00:06:45.600  -->  00:06:48.580
but then we come back to Rolf and what we do
146

146

00:06:48.580  -->  00:06:50.700
is we once again set it to an empty list.
147

147

00:06:50.700  -->  00:06:54.280
So we delete MIT and then we append Cambridge.
148

148

00:06:54.280  -->  00:06:55.620
So we couldn't do this.
149

149

00:06:55.620  -->  00:06:58.050
What we would have to do is say something like
150

150

00:06:58.050  -->  00:07:02.100
if coworker zero not in alma maters,
151

151

00:07:03.273  -->  00:07:08.273
sorry not in alma maters, set the value to the empty list
152

152

00:07:10.570  -->  00:07:12.310
and if they are in the alma maters already,
153

153

00:07:12.310  -->  00:07:13.940
it means we've done this before,
154

154

00:07:13.940  -->  00:07:15.400
we can just append to the list
155

155

00:07:15.400  -->  00:07:17.500
that we've already initialised before.
156

156

00:07:18.600  -->  00:07:21.890
Not the simplest way of working with code.
157

157

00:07:21.890  -->  00:07:23.610
Of course we can make it simpler
158

158

00:07:23.610  -->  00:07:26.470
by destructuring the tuple here and just say
159

159

00:07:26.470  -->  00:07:30.670
coworker, coworker, coworker, place.
160

160

00:07:30.670  -->  00:07:34.770
Saves us from accessing the indices separately.
161

161

00:07:34.770  -->  00:07:36.110
We could do this.
162

162

00:07:36.110  -->  00:07:39.530
Of course, this editor removes closing brackets
163

163

00:07:39.530  -->  00:07:41.760
for you, which is not a great feature.
164

164

00:07:42.710  -->  00:07:44.610
So we could do this a bit better.
165

165

00:07:44.610  -->  00:07:46.740
Still not brilliant.
166

166

00:07:46.740  -->  00:07:48.860
And as you can see, what we're doing here is also,
167

167

00:07:48.860  -->  00:07:51.360
once again, something that very common to do,
168

168

00:07:52.310  -->  00:07:55.060
which is to add things to a dictionary
169

169

00:07:55.060  -->  00:07:57.627
if they don't exist yet and otherwise
170

170

00:07:57.627  -->  00:07:59.650
treat them as though they exist.
171

171

00:08:00.970  -->  00:08:03.250
So what we're doing is when we don't have an element
172

172

00:08:03.250  -->  00:08:07.390
in a dictionary, we're gonna set some default value for it
173

173

00:08:07.390  -->  00:08:08.700
and after that, we're just gonna treat it
174

174

00:08:08.700  -->  00:08:10.401
as though it's already there, for example,
175

175

00:08:10.401  -->  00:08:11.610
appending to the list.
176

176

00:08:13.100  -->  00:08:17.070
Naturally, the default dict is here to save us.
177

177

00:08:17.070  -->  00:08:19.470
We can do default dict list.
178

178

00:08:20.530  -->  00:08:25.320
List, remember, is a type when you have something like this
179

179

00:08:25.320  -->  00:08:28.980
that is of type list and therefore,
180

180

00:08:28.980  -->  00:08:30.900
because it's a type, it's a class.
181

181

00:08:30.900  -->  00:08:32.370
Classes and types, same thing.
182

182

00:08:32.370  -->  00:08:35.860
All things in Python are classes and objects
183

183

00:08:35.860  -->  00:08:38.450
and so this is a class name.
184

184

00:08:39.290  -->  00:08:41.859
Therefore, it's a function as well.
185

185

00:08:41.859  -->  00:08:45.530
Remember, we can call our user constructor.
186

186

00:08:45.530  -->  00:08:47.230
When we initialise a new user,
187

187

00:08:47.230  -->  00:08:49.690
it's a function call essentially.
188

188

00:08:49.690  -->  00:08:53.150
List is also a function call and I said earlier
189

189

00:08:53.150  -->  00:08:56.380
that the default dict takes in a function.
190

190

00:08:56.380  -->  00:08:58.030
This is the function that it takes in,
191

191

00:08:58.030  -->  00:09:00.960
and what happens is when we try to access something
192

192

00:09:00.960  -->  00:09:03.620
that doesn't exist, like Rolf,
193

193

00:09:04.910  -->  00:09:08.470
it gives us the result of this function.
194

194

00:09:08.470  -->  00:09:10.070
So it gives us a new empty list.
195

195

00:09:10.070  -->  00:09:10.960
That's what this function does.
196

196

00:09:10.960  -->  00:09:12.952
It gives you a new list.
197

197

00:09:12.952  -->  00:09:16.170
So it gives you a new list and then you can append to it.
198

198

00:09:17.440  -->  00:09:18.820
Does exactly the same as before,
199

199

00:09:18.820  -->  00:09:21.270
only now we have a bit less boilerplate.
200

200

00:09:22.590  -->  00:09:25.380
So we can do something like print coworker,
201

201

00:09:25.380  -->  00:09:28.750
no, sorry, alma maters, Rolf.
202

202

00:09:28.750  -->  00:09:30.040
That should print out two things.
203

203

00:09:30.040  -->  00:09:31.770
Print alma maters Anne
204

204

00:09:31.770  -->  00:09:33.720
and that should print out zero things.
205

205

00:09:33.720  -->  00:09:35.090
Let's run it.
206

206

00:09:35.090  -->  00:09:38.120
As you can see, we get MIT and Cambridge for Rolf
207

207

00:09:38.120  -->  00:09:41.290
and for Anne, which didn't exist, we didn't have her
208

208

00:09:41.290  -->  00:09:43.840
in our list here, we just print an empty list
209

209

00:09:43.840  -->  00:09:47.200
because that's the default value for anything.
210

210

00:09:50.260  -->  00:09:53.150
Now if you wanted to raise an error
211

211

00:09:53.150  -->  00:09:55.701
or potentially print out none when
212

212

00:09:55.701  -->  00:09:58.480
you try to access something that doesn't exist,
213

213

00:09:58.480  -->  00:10:03.480
you can always do alma maters, default factory equals none.
214

214

00:10:06.640  -->  00:10:08.460
And notice how, then, you get a key error
215

215

00:10:08.460  -->  00:10:10.730
because now you've removed the default factory,
216

216

00:10:10.730  -->  00:10:13.410
which is this list and Anne doesn't exist,
217

217

00:10:13.410  -->  00:10:15.309
but Rolf does, so you still get
218

218

00:10:15.309  -->  00:10:19.680
the default factory working in this bit of code here.
219

219

00:10:19.680  -->  00:10:22.390
Just you don't get it working after this line.
220

220

00:10:22.390  -->  00:10:24.190
So it's a nice tidbit here,
221

221

00:10:24.190  -->  00:10:25.850
in case you want to remove the default factory
222

222

00:10:25.850  -->  00:10:28.350
and not just be returning empty lists for everybody.
223

223

00:10:31.982  -->  00:10:35.750
And similarly, you can, of course, also do alma maters
224

224

00:10:35.750  -->  00:10:40.740
dot default factory is now an int, for example.
225

225

00:10:40.740  -->  00:10:42.322
Then, whenever you try to append,
226

226

00:10:42.322  -->  00:10:45.730
it will give you an empty integer, which is zero,
227

227

00:10:45.730  -->  00:10:48.130
the value zero, and it will fail
228

228

00:10:48.130  -->  00:10:50.980
but you can do things like do something else
229

229

00:10:50.980  -->  00:10:53.930
with an int, with the number zero.
230

230

00:10:53.930  -->  00:10:56.120
You can change the default factory is all I'm trying to say,
231

231

00:10:56.120  -->  00:10:59.820
from list to dictionary or tuple or whatever you want.
232

232

00:11:01.960  -->  00:11:05.550
Okay, let me give you another example.
233

233

00:11:05.550  -->  00:11:07.650
So I'm going to delete all this stuff here
234

234

00:11:08.520  -->  00:11:12.120
and let's say I've got my company, which is called Teclado
235

235

00:11:12.120  -->  00:11:14.730
and if you don't know it, shame on you.
236

236

00:11:14.730  -->  00:11:16.800
Then we've got our coworkers, which, let's say,
237

237

00:11:16.800  -->  00:11:20.630
are Jen, Li, Charlie and Rhys.
238

238

00:11:20.630  -->  00:11:23.891
Some of these are actual coworkers of Teclado.
239

239

00:11:23.891  -->  00:11:26.290
Other coworkers, those are coworkers
240

240

00:11:26.290  -->  00:11:30.170
that don't work at Teclado, we're gonna say they are,
241

241

00:11:30.170  -->  00:11:35.170
for example, these tuples of Rolf and Apple Inc, lucky guy
242

242

00:11:35.340  -->  00:11:37.850
and Anna is gonna be working at Google.
243

243

00:11:37.850  -->  00:11:41.850
As you can see, these two have different structures.
244

244

00:11:41.850  -->  00:11:45.230
For my coworkers, I already know where they work.
245

245

00:11:45.230  -->  00:11:47.140
I only have a simple list.
246

246

00:11:47.140  -->  00:11:48.950
Potentially, a tuple could be better.
247

247

00:11:48.950  -->  00:11:50.200
Doesn't matter.
248

248

00:11:50.200  -->  00:11:53.150
For my other coworkers, I've got a list of tuples,
249

249

00:11:53.150  -->  00:11:55.800
where I define the name and also the place they work.
250

250

00:11:56.890  -->  00:12:01.890
So, what to do is define a place like coworker companies,
251

251

00:12:02.090  -->  00:12:04.470
and this is going to contain something
252

252

00:12:04.470  -->  00:12:07.120
that is going to be like this.
253

253

00:12:07.120  -->  00:12:12.120
Jen works at Teclado, Rolf works at Apple Inc and so forth.
254

254

00:12:15.230  -->  00:12:17.910
So a mapping of names to the place they work.
255

255

00:12:19.650  -->  00:12:20.760
How to do this?
256

256

00:12:20.760  -->  00:12:24.100
default dict, lambda, my company.
257

257

00:12:24.100  -->  00:12:27.100
My company is value of Teclado, this is a lambda function
258

258

00:12:27.100  -->  00:12:28.460
that doesn't take any arguments.
259

259

00:12:28.460  -->  00:12:30.470
There's no x before the colon
260

260

00:12:30.470  -->  00:12:32.750
or no parameter name before the colon.
261

261

00:12:32.750  -->  00:12:33.950
Doesn't take any arguments.
262

262

00:12:33.950  -->  00:12:35.870
Always returns my company.
263

263

00:12:36.840  -->  00:12:39.240
Why can we not just set my company there?
264

264

00:12:39.240  -->  00:12:42.210
Because the default dict takes in a function.
265

265

00:12:42.210  -->  00:12:45.160
So we have to set a function that will be called
266

266

00:12:45.160  -->  00:12:47.940
when we access the key that doesn't exist.
267

267

00:12:47.940  -->  00:12:52.000
Then we're gonna do for person, company in other coworkers.
268

268

00:12:52.000  -->  00:12:54.230
We're gonna say coworker companies,
269

269

00:12:54.230  -->  00:12:57.120
person equal company and that's it.
270

270

00:12:58.940  -->  00:13:00.820
Oh, no, not that one.
271

271

00:13:01.660  -->  00:13:02.493
There.
272

272

00:13:04.390  -->  00:13:09.390
Now, we can do coworker companies, coworkers zero.
273

273

00:13:09.940  -->  00:13:13.360
Remember, this is going to be Jen, our coworker from Teclado
274

274

00:13:14.320  -->  00:13:16.220
and we can also print coworker companies
275

275

00:13:16.220  -->  00:13:21.220
of other coworkers, zero, zero.
276

276

00:13:21.250  -->  00:13:22.630
So this is going to be Rolf.
277

277

00:13:22.630  -->  00:13:23.740
In order to simplify things,
278

278

00:13:23.740  -->  00:13:26.120
I'm just going to type Rolf in here.
279

279

00:13:26.120  -->  00:13:27.330
Now, we can run this.
280

280

00:13:28.383  -->  00:13:32.193
And as you can see, we get Teclado for Jen
281

281

00:13:32.193  -->  00:13:35.980
and we get Apple Inc for Rolf.
282

282

00:13:35.980  -->  00:13:39.800
Rolf and Anna are actually in this dictionary,
283

283

00:13:39.800  -->  00:13:41.630
when we finish the for loop.
284

284

00:13:41.630  -->  00:13:45.360
Jen, Li, Charlie and Rhys are not in the dictionary,
285

285

00:13:45.360  -->  00:13:48.240
but whenever we access them, we get the value
286

286

00:13:48.240  -->  00:13:50.440
returned by this function, which is Teclado.
287

287

00:13:51.410  -->  00:13:54.010
So this is a slightly more contrived example,
288

288

00:13:54.010  -->  00:13:56.790
maybe not a terribly useful one,
289

289

00:13:56.790  -->  00:13:59.800
but nonetheless, this is how you use a default dictionary.
290

290

00:13:59.800  -->  00:14:01.950
I wanted to give you this lambda example here
291

291

00:14:01.950  -->  00:14:03.920
in case you want a default value
292

292

00:14:03.920  -->  00:14:07.210
that isn't initialised by a function.
293

293

00:14:07.210  -->  00:14:09.870
So, just remember you can use a lambda function here.
294

294

00:14:09.870  -->  00:14:10.703
That's fine.
295

295

00:14:10.703  -->  00:14:11.970
You can use lambda functions anywhere,
296

296

00:14:11.970  -->  00:14:13.720
where you can use normal functions.
297

297

00:14:15.480  -->  00:14:18.120
So, what we've done here is created a mapping
298

298

00:14:18.120  -->  00:14:21.150
of the other coworkers and then we can also access it
299

299

00:14:21.150  -->  00:14:22.700
for our own coworkers
300

300

00:14:22.700  -->  00:14:24.700
because we know where they work already.
301

301

00:14:26.660  -->  00:14:31.660
Okay, that's it for this collection, the default dict.
302

302

00:14:32.170  -->  00:14:34.170
We're gonna move on to Ordered Dict.
303

303

00:14:34.170  -->  00:14:35.410
So, let's do it.
304

304

00:14:39.890  -->  00:14:42.860
The Ordered Dict actually is a bit of a bizarre one
305

305

00:14:42.860  -->  00:14:47.040
because it has the capital letters, so just remember that.
306

306

00:14:47.040  -->  00:14:48.630
Remember the capital letters.
307

307

00:14:48.630  -->  00:14:50.909
Ordered Dicts, not so useful.
308

308

00:14:50.909  -->  00:14:53.931
We're gonna look at them more quickly,
309

309

00:14:53.931  -->  00:14:58.270
just because they're going away soon, I think.
310

310

00:15:00.010  -->  00:15:04.030
So, as you can see, we are just accessing normal keys
311

311

00:15:04.030  -->  00:15:05.710
as if this were a normal dictionary.
312

312

00:15:05.710  -->  00:15:10.710
We're setting the values in those keys to six, 12, three.
313

313

00:15:10.810  -->  00:15:12.990
Then we can print them out.
314

314

00:15:12.990  -->  00:15:15.460
And what you'll see here is an Ordered Dict,
315

315

00:15:15.460  -->  00:15:19.020
where the keys here are Rolf, then Jose, then Jen
316

316

00:15:19.020  -->  00:15:21.040
and the values are six, 12 and three.
317

317

00:15:21.040  -->  00:15:23.350
Important is that they are in the order
318

318

00:15:23.350  -->  00:15:25.450
in which they were inserted.
319

319

00:15:25.450  -->  00:15:27.480
It does not mean they are ordered alphabetically
320

320

00:15:27.480  -->  00:15:28.770
or anything like that.
321

321

00:15:28.770  -->  00:15:31.520
It just means they're ordered in the way they were inserted.
322

322

00:15:31.520  -->  00:15:33.460
So Rolf was the first one we added.
323

323

00:15:33.460  -->  00:15:35.660
Rolf is always gonna be the first one there.
324

324

00:15:37.170  -->  00:15:42.110
You can also do o dot move to end, Rolf
325

325

00:15:44.520  -->  00:15:45.760
and that is gonna move Rolf
326

326

00:15:45.760  -->  00:15:48.330
to the very end of this dictionary.
327

327

00:15:48.330  -->  00:15:50.039
As you can see, Jose is now first, Jen is second,
328

328

00:15:50.039  -->  00:15:52.310
Rolf is now at the end.
329

329

00:15:52.310  -->  00:15:54.470
You can also do o dot move to start.
330

330

00:15:55.570  -->  00:15:57.030
Sorry, my bad.
331

331

00:15:57.030  -->  00:15:57.970
I wish that was the case.
332

332

00:15:57.970  -->  00:16:02.270
Move to end, Jose, but now last is false.
333

333

00:16:02.270  -->  00:16:03.560
And instead of it being the last,
334

334

00:16:03.560  -->  00:16:05.030
it's going to move it over to the other end,
335

335

00:16:05.030  -->  00:16:07.720
which is the beginning, but I'm gonna move Jen, of course,
336

336

00:16:07.720  -->  00:16:09.620
because Jose is already the first one.
337

337

00:16:11.570  -->  00:16:13.350
Now, you can see that Jen is the first one,
338

338

00:16:13.350  -->  00:16:15.500
Jose is in the middle and Rolf's at the end.
339

339

00:16:16.770  -->  00:16:18.770
Something else you can do is pop item
340

340

00:16:19.930  -->  00:16:23.710
and this is going to give you a new dictionary
341

341

00:16:23.710  -->  00:16:27.480
where the last item has been popped off, has been removed.
342

342

00:16:27.480  -->  00:16:30.970
So pop, pretty popular programming term.
343

343

00:16:30.970  -->  00:16:32.070
It just removes an item
344

344

00:16:32.070  -->  00:16:33.930
and it normally removes items from the end.
345

345

00:16:33.930  -->  00:16:35.980
So that's what we see here.
346

346

00:16:35.980  -->  00:16:38.430
We've popped off the last item in the dictionary.
347

347

00:16:39.890  -->  00:16:44.030
So, I don't think Ordered Dict is gonna really go away,
348

348

00:16:44.030  -->  00:16:47.110
gonna be deleted from Python, but it's not so useful
349

349

00:16:47.110  -->  00:16:51.090
now because as of Python 3.7, dictionaries themselves
350

350

00:16:51.090  -->  00:16:54.476
are gonna be retaining the order in which they are inserted,
351

351

00:16:54.476  -->  00:16:58.426
so it's going to be slightly less useful, the Ordered Dict.
352

352

00:16:58.426  -->  00:17:00.940
It's still useful to keep these functions, move to end
353

353

00:17:00.940  -->  00:17:03.360
and move to start and pop item and stuff like that,
354

354

00:17:03.360  -->  00:17:05.460
which isn't in normal dictionaries,
355

355

00:17:05.460  -->  00:17:07.380
but the fact that they're ordered
356

356

00:17:07.380  -->  00:17:10.460
is going to be less important now because in Python 3.7,
357

357

00:17:10.460  -->  00:17:13.900
as I said, normal dictionaries will start keeping the order.
358

358

00:17:15.360  -->  00:17:17.420
Okay, let's move over to the next collection
359

359

00:17:17.420  -->  00:17:18.620
and that's the named tuple.
360

360

00:17:18.620  -->  00:17:19.540
I've gotta love this.
361

361

00:17:19.540  -->  00:17:20.610
Named tuple.
362

362

00:17:20.610  -->  00:17:22.460
I love the named tuple.
363

363

00:17:22.460  -->  00:17:25.300
And the named tuple is another object that we can use
364

364

00:17:25.300  -->  00:17:30.300
just like a tuple, but each of the elements has a name
365

365

00:17:31.040  -->  00:17:33.940
and in addition, the tuple itself also has a name.
366

366

00:17:35.230  -->  00:17:36.840
So it improves on tuples by making things
367

367

00:17:36.840  -->  00:17:38.080
a bit more explicit.
368

368

00:17:38.080  -->  00:17:40.210
Let's have an example here.
369

369

00:17:40.210  -->  00:17:44.570
A checking account that has 850.90 dollars in it.
370

370

00:17:44.570  -->  00:17:48.350
We can print account zero and we can print account one,
371

371

00:17:48.350  -->  00:17:50.310
but it's not so clear what these are,
372

372

00:17:50.310  -->  00:17:52.350
unless you're looking at a tuple.
373

373

00:17:53.580  -->  00:17:56.580
If the account was being read from a database
374

374

00:17:56.580  -->  00:17:59.160
and the code was a bit all over the place,
375

375

00:17:59.160  -->  00:18:03.360
you wouldn't necessarily know what account zero is,
376

376

00:18:03.360  -->  00:18:07.110
which is, of course, the name,
377

377

00:18:07.110  -->  00:18:09.000
and you wouldn't necessarily know what account one is,
378

378

00:18:09.000  -->  00:18:11.240
which is, of course, the balance.
379

379

00:18:11.240  -->  00:18:13.890
Maybe you'd think this is the overdraft amount.
380

380

00:18:15.240  -->  00:18:18.420
Maybe you'd think this is some sort of tag for the account.
381

381

00:18:18.420  -->  00:18:19.253
I don't know.
382

382

00:18:19.253  -->  00:18:21.050
You could think anything because it's not terribly clear
383

383

00:18:21.050  -->  00:18:21.910
what they are.
384

384

00:18:22.780  -->  00:18:26.110
If you wanted much more clarity, you could create a class
385

385

00:18:26.110  -->  00:18:28.790
for your account and have a property called name,
386

386

00:18:28.790  -->  00:18:30.460
which was checking, and a property called balance,
387

387

00:18:30.460  -->  00:18:32.230
which is the balance.
388

388

00:18:32.230  -->  00:18:35.150
Or you can use a named tuple.
389

389

00:18:35.150  -->  00:18:37.870
So we're gonna define a new named tuple.
390

390

00:18:38.760  -->  00:18:40.820
Notice how I'm using capital A here.
391

391

00:18:40.820  -->  00:18:44.140
This is going to be a new named tuple.
392

392

00:18:45.220  -->  00:18:49.210
The first parameter is the name of the tuple
393

393

00:18:49.210  -->  00:18:53.950
and that has to be the same as the definition here, account.
394

394

00:18:53.950  -->  00:18:55.620
That's because of the way Python works.
395

395

00:18:55.620  -->  00:19:00.410
It can't quite see the name of the variable first.
396

396

00:19:00.410  -->  00:19:05.410
So this name here has to be what you want your type to be.
397

397

00:19:06.670  -->  00:19:11.670
Then, in a list, we're gonna define name and balance.
398

398

00:19:13.100  -->  00:19:15.480
So these are the two fields on the tuple.
399

399

00:19:15.480  -->  00:19:17.430
First one is checking and the second one
400

400

00:19:17.430  -->  00:19:18.750
is the balance there.
401

401

00:19:19.870  -->  00:19:24.150
Then we can do something like account is account checking
402

402

00:19:24.150  -->  00:19:27.860
and 1850.90, so as you can see,
403

403

00:19:27.860  -->  00:19:31.236
now we've used this named tuple instance
404

404

00:19:31.236  -->  00:19:35.920
to create a new instance of this type account.
405

405

00:19:35.920  -->  00:19:38.840
It's essentially the same as a tuple, except now,
406

406

00:19:38.840  -->  00:19:41.040
we can print account dot name, for example,
407

407

00:19:41.040  -->  00:19:42.910
if we can use the field names.
408

408

00:19:45.950  -->  00:19:50.060
Indeed we can also print the account itself, if we want
409

409

00:19:50.060  -->  00:19:52.970
and it has a nice representation.
410

410

00:19:52.970  -->  00:19:55.460
A nice dunder-repper method here.
411

411

00:19:55.460  -->  00:19:58.410
I like to think of it very much like defining a class,
412

412

00:19:58.410  -->  00:20:01.520
where account is the class name or the type,
413

413

00:20:01.520  -->  00:20:03.540
but it's not quite the same.
414

414

00:20:03.540  -->  00:20:05.410
Named tuple is still a tuple, after all.
415

415

00:20:05.410  -->  00:20:07.040
You don't have any custom methods
416

416

00:20:07.040  -->  00:20:10.820
that you can define in a class, so it's like a nicer tuple
417

417

00:20:10.820  -->  00:20:12.507
that allows you to be a bit more explicit
418

418

00:20:12.507  -->  00:20:16.330
with what things mean.
419

419

00:20:16.330  -->  00:20:17.230
That's the word.
420

420

00:20:18.210  -->  00:20:23.210
You can still do things like name comma balance is account.
421

421

00:20:24.050  -->  00:20:24.930
Tuple destructuring.
422

422

00:20:24.930  -->  00:20:27.340
You can still do tuple destructuring.
423

423

00:20:27.340  -->  00:20:31.640
When you define the account, you can have, of course,
424

424

00:20:32.630  -->  00:20:35.980
named arguments in here, like you can in any function.
425

425

00:20:35.980  -->  00:20:39.160
You can use positional arguments like the checking here
426

426

00:20:39.160  -->  00:20:41.160
or you can used named arguments like here.
427

427

00:20:41.160  -->  00:20:44.150
This makes things much nicer for you to be explicit
428

428

00:20:44.150  -->  00:20:47.020
in what it means when you create a new account.
429

429

00:20:48.200  -->  00:20:51.470
Given a tuple like this account here,
430

430

00:20:51.470  -->  00:20:56.470
you can have an account named tuple
431

431

00:20:57.400  -->  00:21:02.400
which is account dot underscore make account.
432

432

00:21:02.690  -->  00:21:06.770
So, this is the type, dot underscore make
433

433

00:21:06.770  -->  00:21:11.700
takes in a tuple and it will associate each element here
434

434

00:21:11.700  -->  00:21:15.040
with the respective field.
435

435

00:21:15.040  -->  00:21:16.150
This is particularly useful
436

436

00:21:16.150  -->  00:21:18.140
for when you're using the map function.
437

437

00:21:18.140  -->  00:21:19.579
Otherwise, you can, of course,
438

438

00:21:19.579  -->  00:21:23.420
do this and that and that is the same thing.
439

439

00:21:24.900  -->  00:21:28.710
You can also turn an account named tuple.
440

440

00:21:28.710  -->  00:21:29.940
You can do asdict.
441

441

00:21:31.520  -->  00:21:34.170
Let's print that one out for you to see what that is.
442

442

00:21:35.880  -->  00:21:38.130
You can print it out as an ordered dictionary,
443

443

00:21:38.130  -->  00:21:39.980
where it keeps the field orders.
444

444

00:21:39.980  -->  00:21:41.640
Name goes first, balance goes second.
445

445

00:21:41.640  -->  00:21:42.970
You can get it as a dictionary.
446

446

00:21:42.970  -->  00:21:46.540
You can, then, of course, access it as a dictionary.
447

447

00:21:46.540  -->  00:21:48.750
You can use this square bracket notation there
448

448

00:21:48.750  -->  00:21:52.160
and that gives you the number, 1850.9.
449

449

00:21:52.160  -->  00:21:53.380
So it's a pretty useful thing.
450

450

00:21:53.380  -->  00:21:54.660
When you're dealing with data
451

451

00:21:54.660  -->  00:21:57.480
and it doesn't warrant creating classes
452

452

00:21:57.480  -->  00:21:59.190
for the data element you're working with
453

453

00:21:59.190  -->  00:22:01.490
like, for example, when you're reading from a database,
454

454

00:22:01.490  -->  00:22:03.710
you're reading from a csv file,
455

455

00:22:03.710  -->  00:22:06.410
named tuple is a great choice and it's really flexible
456

456

00:22:06.410  -->  00:22:08.390
and it just makes things more explicit
457

457

00:22:08.390  -->  00:22:10.930
and more clear with what's going on.
458

458

00:22:10.930  -->  00:22:13.250
So, definitely something to keep in your arsenal.
459

459

00:22:13.250  -->  00:22:16.420
I think it's a pretty nice thing to use.
460

460

00:22:16.420  -->  00:22:17.960
So definitely remember it.
461

461

00:22:17.960  -->  00:22:20.880
Also the guy that made this, Raymond Hettinger,
462

462

00:22:22.751  -->  00:22:23.870
is a pretty cool guy.
463

463

00:22:23.870  -->  00:22:25.400
He makes a lot of nice Python talks,
464

464

00:22:25.400  -->  00:22:28.840
so what he's made here is useful.
465

465

00:22:29.680  -->  00:22:31.540
Let's move over to our last collection,
466

466

00:22:31.540  -->  00:22:35.830
I know I'm boring you already, which is the deque.
467

467

00:22:35.830  -->  00:22:40.330
The deque stands for double ended queue.
468

468

00:22:40.330  -->  00:22:43.270
So please watch the presentation about queues,
469

469

00:22:43.270  -->  00:22:44.310
if you haven't done so already.
470

470

00:22:44.310  -->  00:22:47.020
It's just the video prior to this one
471

471

00:22:47.020  -->  00:22:49.730
and a double ended queue is just like a queue,
472

472

00:22:49.730  -->  00:22:51.820
but we can push elements from either the start
473

473

00:22:51.820  -->  00:22:54.350
or their end and we can also remove elements
474

474

00:22:54.350  -->  00:22:55.910
from either the start or the end.
475

475

00:22:55.910  -->  00:22:57.860
It's very efficient, performs very well
476

476

00:22:58.720  -->  00:23:01.040
and it's just essentially like a list,
477

477

00:23:01.040  -->  00:23:03.920
but you can append or prepend, start and end
478

478

00:23:03.920  -->  00:23:05.900
and you can pop from the start or from the end.
479

479

00:23:05.900  -->  00:23:07.880
The most important thing about the dequeue
480

480

00:23:07.880  -->  00:23:10.520
and the main reason why we use it sometimes
481

481

00:23:10.520  -->  00:23:13.470
instead of a list, is because of its efficiency,
482

482

00:23:13.470  -->  00:23:17.080
first of all, secondly, because it's thread safe.
483

483

00:23:17.080  -->  00:23:20.100
So you can use dequeues when you're dealing with threads.
484

484

00:23:20.100  -->  00:23:22.350
We're gonna look at threads very soon.
485

485

00:23:22.350  -->  00:23:24.490
I know that we've not looked at them yet,
486

486

00:23:24.490  -->  00:23:26.370
but essentially, a dequeue is really useful
487

487

00:23:26.370  -->  00:23:27.700
when you're dealing with threads
488

488

00:23:27.700  -->  00:23:29.980
because all its operations are thread safe.
489

489

00:23:31.100  -->  00:23:32.770
So when we look at asynchronous development,
490

490

00:23:32.770  -->  00:23:35.180
we're gonna be looking at the dequeue a bit more.
491

491

00:23:35.180  -->  00:23:36.240
For now, just remember it.
492

492

00:23:36.240  -->  00:23:38.810
It's like a list on which you do operations
493

493

00:23:38.810  -->  00:23:40.450
that are very much like a list.
494

494

00:23:40.450  -->  00:23:43.880
So, for example, friends can be a dequeue
495

495

00:23:44.730  -->  00:23:49.730
where they get, let's say, Rolf, Charlie, Jen and Anna
496

496

00:23:52.020  -->  00:23:55.570
and then you can do things like friends append, Jose.
497

497

00:23:55.570  -->  00:23:57.230
What is happening in the dequeue constructor
498

498

00:23:57.230  -->  00:24:00.420
is you're passing it an iterable and one by one,
499

499

00:24:00.420  -->  00:24:04.390
it is appending them to itself, So this tuple here
500

500

00:24:04.390  -->  00:24:06.930
then gets turned into the dequeue objects
501

501

00:24:06.930  -->  00:24:08.530
or the elements of the dequeue.
502

502

00:24:08.530  -->  00:24:10.520
You can then append to it.
503

503

00:24:10.520  -->  00:24:15.520
You can do friends dot append left, Anthony, for example
504

504

00:24:16.900  -->  00:24:20.040
and that Jose will appear at the end of the list,
505

505

00:24:20.040  -->  00:24:20.970
of the dequeue rather.
506

506

00:24:20.970  -->  00:24:23.470
Anthony would appear at the start of the dequeue
507

507

00:24:23.470  -->  00:24:26.110
and you can also do friends dot pop.
508

508

00:24:26.110  -->  00:24:28.020
That removes an element from the end
509

509

00:24:28.020  -->  00:24:31.410
or you can do friends dot pop left.
510

510

00:24:32.360  -->  00:24:35.503
Sorry, append left is with a capital L, my bad.
511

511

00:24:35.503  -->  00:24:37.710
You can do friends dot pop, friends dot pop left,
512

512

00:24:37.710  -->  00:24:39.200
that removes an element from the end.
513

513

00:24:39.200  -->  00:24:40.880
This one removes it from the start.
514

514

00:24:40.880  -->  00:24:44.020
So these are a couple things you can do, just to show you.
515

515

00:24:44.020  -->  00:24:46.670
You can print friends and you can print friends here.
516

516

00:24:50.110  -->  00:24:51.810
And then see that you get the dequeue here
517

517

00:24:51.810  -->  00:24:53.383
with all the elements and then you've popped
518

518

00:24:53.383  -->  00:24:55.600
one off each end there.
519

519

00:24:56.640  -->  00:24:58.450
For more info on dequeues
520

520

00:24:58.450  -->  00:25:01.210
and a comprehensive example on everything you can do,
521

521

00:25:01.210  -->  00:25:03.060
check out the official Python documentation.
522

522

00:25:03.060  -->  00:25:06.760
It is linked on this lecture as a resource.
523

523

00:25:06.760  -->  00:25:09.710
Have a look if you are keen.
524

524

00:25:09.710  -->  00:25:11.850
If not, when we move over to asynchronous development,
525

525

00:25:11.850  -->  00:25:13.470
we're gonna be using it a bit more
526

526

00:25:13.470  -->  00:25:16.910
and you'll understand why we use it instead of a list.
527

527

00:25:16.910  -->  00:25:18.070
So, that's it for this video.
528

528

00:25:18.070  -->  00:25:20.340
I hope I've not bored you too much with these collections.
529

529

00:25:20.340  -->  00:25:22.150
I just think they're really useful tools
530

530

00:25:22.150  -->  00:25:24.560
to keep in the back of your mind
531

531

00:25:24.560  -->  00:25:27.460
and at some point, you may need them.
532

532

00:25:27.460  -->  00:25:29.820
So it's always a good idea to remember that these exist
533

533

00:25:29.820  -->  00:25:32.100
when you do need them, just know, ah, you know,
534

534

00:25:32.100  -->  00:25:34.250
I think something like this existed.
535

535

00:25:34.250  -->  00:25:36.220
Let me have a look at the official Python documentation
536

536

00:25:36.220  -->  00:25:39.570
and see if I can find it and then you'll be able to find it.
537

537

00:25:39.570  -->  00:25:42.180
If you don't know it exists, you're gonna have trouble.
538

538

00:25:42.180  -->  00:25:43.600
You're gonna be trying to recreate
539

539

00:25:43.600  -->  00:25:45.720
your own double ended queue instead of using the one
540

540

00:25:45.720  -->  00:25:47.190
that's already provided and that works
541

541

00:25:47.190  -->  00:25:50.770
and it's tested and it's validated that it all works.
542

542

00:25:50.770  -->  00:25:51.930
So that's it for this video.
543

543

00:25:51.930  -->  00:25:54.550
Thanks for watching and I'll see you on the next one.
