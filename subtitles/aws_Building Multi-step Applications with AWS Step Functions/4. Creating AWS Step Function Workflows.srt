1
00:00:01,240 --> 00:00:04,800
[Autogenerated] creating a W A Step Functions is very straightforward.

2
00:00:04,800 --> 00:00:07,680
AWS makes it very easy for us to use the causal.

3
00:00:07,680 --> 00:00:11,520
Ooh, I to create our work flows for our demo.

4
00:00:11,520 --> 00:00:14,590
We're going to build a simple workflow that execute

5
00:00:14,590 --> 00:00:17,510
to Lambda functions in sequence.

6
00:00:17,510 --> 00:00:21,990
Let's start by navigating to the AWS Step Functions management console.

7
00:00:21,990 --> 00:00:23,740
Once in the Step Functions menu,

8
00:00:23,740 --> 00:00:26,900
we need to navigate through the state machines on the last sidebar.

9
00:00:26,900 --> 00:00:32,670
As with every other service, let's start by creating a new state machine.

10
00:00:32,670 --> 00:00:35,220
When creating workflow, we get the option toe,

11
00:00:35,220 --> 00:00:36,620
author it ourselves,

12
00:00:36,620 --> 00:00:41,650
run a sample project or start with the template for this demo.

13
00:00:41,650 --> 00:00:45,440
We're goingto author the workflow ourselves.

14
00:00:45,440 --> 00:00:50,140
We also have the option to either to standard or express.

15
00:00:50,140 --> 00:00:52,360
We're going to use standard for this day more.

16
00:00:52,360 --> 00:00:55,710
We look into the difference later on.

17
00:00:55,710 --> 00:01:00,180
Now all the work that we have to do is at the definition section.

18
00:01:00,180 --> 00:01:03,140
The definition is based on Amazon States language,

19
00:01:03,140 --> 00:01:05,850
which is a Jason based traction language we will use to

20
00:01:05,850 --> 00:01:09,980
define our state machine For our demo,

21
00:01:09,980 --> 00:01:13,050
we're going to build a simple workflow that execute

22
00:01:13,050 --> 00:01:16,640
to Lambda functions in sequence.

23
00:01:16,640 --> 00:01:18,970
Here is a Jason for our workflow.

24
00:01:18,970 --> 00:01:20,540
Let's break it down.

25
00:01:20,540 --> 00:01:24,280
The main part of a workload is defined in the state's property.

26
00:01:24,280 --> 00:01:25,000
For our demo.

27
00:01:25,000 --> 00:01:26,940
We are going to execute to London functions,

28
00:01:26,940 --> 00:01:29,580
so we're going to have to task states,

29
00:01:29,580 --> 00:01:34,620
which is what we used to do any actual work are States are

30
00:01:34,620 --> 00:01:38,990
named Step one and step to keep things simple.

31
00:01:38,990 --> 00:01:41,160
In order to execute a lambda function,

32
00:01:41,160 --> 00:01:45,150
we need to tell the task what type of resource we're trying to execute.

33
00:01:45,150 --> 00:01:49,630
In our case, it's Lambda and we'll be using the invoke A P I.

34
00:01:49,630 --> 00:01:53,760
Next we have the pyre meters for the resource for London functions,

35
00:01:53,760 --> 00:01:55,570
we need to perimeters Ah,

36
00:01:55,570 --> 00:02:00,570
function name and the payload I have already created to Lambda Functions,

37
00:02:00,570 --> 00:02:03,440
which do nothing but return an object with a property named

38
00:02:03,440 --> 00:02:06,340
Function one and function to respectively.

39
00:02:06,340 --> 00:02:11,250
The function mean is going to be the end of the function and for payload.

40
00:02:11,250 --> 00:02:13,980
We're going to tell you to pass the entire output off the

41
00:02:13,980 --> 00:02:16,840
state machine at the time of execution.

42
00:02:16,840 --> 00:02:19,940
Next, we need to tell it which step to execute next.

43
00:02:19,940 --> 00:02:20,800
For this demo,

44
00:02:20,800 --> 00:02:24,950
it's going to be another similar step named Step two step two is

45
00:02:24,950 --> 00:02:28,760
going to be exactly like Step one with two main differences is

46
00:02:28,760 --> 00:02:31,900
going to invoke a different land, a function called Steptoe,

47
00:02:31,900 --> 00:02:34,750
and it will not have a next step.

48
00:02:34,750 --> 00:02:38,830
These will have a property called and which we need to set it as true.

49
00:02:38,830 --> 00:02:40,810
This will tell the state machine that this step is

50
00:02:40,810 --> 00:02:44,740
the last step on the workflow, and it needs to terminate here.

51
00:02:44,740 --> 00:02:47,470
We also have to define a starting place.

52
00:02:47,470 --> 00:02:49,970
The workflow needs to know which state needs Toby.

53
00:02:49,970 --> 00:02:53,800
First, we specify that using the stock at property on,

54
00:02:53,800 --> 00:02:55,910
we need to provide the name off the first step.

55
00:02:55,910 --> 00:02:58,930
In our case, it's Step one.

56
00:02:58,930 --> 00:03:00,680
Once we get through fresh on the right,

57
00:03:00,680 --> 00:03:03,980
we can see the diagram off our newly created workflow.

58
00:03:03,980 --> 00:03:08,140
On the next page, we need to choose the permissions for our state machine.

59
00:03:08,140 --> 00:03:11,720
If you have already role created for the state machines you use,

60
00:03:11,720 --> 00:03:14,490
then you can go ahead and use that role.

61
00:03:14,490 --> 00:03:17,240
Otherwise, use a create new role option,

62
00:03:17,240 --> 00:03:19,980
which will create a new role based on the state machine

63
00:03:19,980 --> 00:03:25,940
definitions with appropriate permissions already attached

64
00:03:25,940 --> 00:03:28,180
Once on state machine has been created.

65
00:03:28,180 --> 00:03:32,040
Let's go ahead and execute it to see the results we get.

66
00:03:32,040 --> 00:03:34,810
We have the option to provide an input for our demo.

67
00:03:34,810 --> 00:03:36,100
We don't really use the input.

68
00:03:36,100 --> 00:03:39,540
So let's start the execution without any.

69
00:03:39,540 --> 00:03:44,990
We can see the execution ST on the diagram as well as in the execution history.

70
00:03:44,990 --> 00:03:49,140
Clicking on its step, we can see the details of the execution for that step.

71
00:03:49,140 --> 00:03:50,060
For step one,

72
00:03:50,060 --> 00:03:53,660
we can see that the input was empty since we did not provide any

73
00:03:53,660 --> 00:03:56,890
input and the output is the output that was returned by the

74
00:03:56,890 --> 00:03:59,710
lender function in the bailout section.

75
00:03:59,710 --> 00:04:01,700
Off the output, we can see the payload.

76
00:04:01,700 --> 00:04:03,460
We return from the London function.

77
00:04:03,460 --> 00:04:08,140
The rest is meta data from the London function Execution.

78
00:04:08,140 --> 00:04:12,930
Now, if we look into the second step, the input is no longer empty.

79
00:04:12,930 --> 00:04:15,430
The input is the state machine output.

80
00:04:15,430 --> 00:04:18,500
At the time of the execution before it was executed,

81
00:04:18,500 --> 00:04:22,060
the output of the state machine was output of the first step.

82
00:04:22,060 --> 00:04:27,600
And now that output is the second steps input and also the output off.

83
00:04:27,600 --> 00:04:31,400
The second step is very similar to the 1st 1 except the payload

84
00:04:31,400 --> 00:04:34,480
returns the value function to instead of function one.

85
00:04:34,480 --> 00:04:35,500
As we can see,

86
00:04:35,500 --> 00:04:39,040
the output of Step one is now over eaten by the output off Steptoe.

87
00:04:39,040 --> 00:04:41,790
Because they have similar property names.

88
00:04:41,790 --> 00:04:45,510
We can also see that we get a lot of unnecessary information

89
00:04:45,510 --> 00:04:48,600
that we do not need from the Lambda execution.

90
00:04:48,600 --> 00:04:53,200
We can choose what information to get by using a property called Output Path.

91
00:04:53,200 --> 00:04:57,350
We can decide what properties to show on the final output and filter out all

92
00:04:57,350 --> 00:05:00,980
the unnecessary information from the execution meta data.

93
00:05:00,980 --> 00:05:04,310
Let's edit the state machine definition so we can parse the

94
00:05:04,310 --> 00:05:07,940
result from the Lambda Function execution.

95
00:05:07,940 --> 00:05:12,500
We can do so by using the edit state machine bottom for the output.

96
00:05:12,500 --> 00:05:16,630
We only want the payload information toe.

97
00:05:16,630 --> 00:05:19,620
Get that we need to set the output bath $2 sign.

98
00:05:19,620 --> 00:05:23,240
That payload dollar sign is the root object and payload is

99
00:05:23,240 --> 00:05:26,140
the object that we want to retrieve.

100
00:05:26,140 --> 00:05:30,040
We also need to do this for the second step as well.

101
00:05:30,040 --> 00:05:32,340
Once we save, I start a new execution.

102
00:05:32,340 --> 00:05:35,190
We can see now that the Step one output is just a

103
00:05:35,190 --> 00:05:40,190
function one property and also, if we take the second step,

104
00:05:40,190 --> 00:05:44,930
we can see that it's output is the function to property that is pro.

105
00:05:44,930 --> 00:05:48,400
Creating a simple workflow using Amazon step functions and

106
00:05:48,400 --> 00:05:55,000
using Lambda functions for the tasks will build more advanced work flows in the cliffs to come.

