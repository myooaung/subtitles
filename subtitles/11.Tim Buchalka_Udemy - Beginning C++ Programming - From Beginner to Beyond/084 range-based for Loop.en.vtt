WEBVTT
1
00:00:05.470 --> 00:00:11.920
In this video we'll learn about a really great feature that was added in C++ 11 the range based for

2
00:00:11.920 --> 00:00:17.670
loop this loop really makes C++ feel like modern programming language.

3
00:00:17.670 --> 00:00:22.830
The idea with the range based for loop is to loop through a collection of elements and be able to easily

4
00:00:22.830 --> 00:00:28.060
access each element without having to worry about the length of the collection or incrementing or decrement

5
00:00:28.110 --> 00:00:31.920
looping variables or subscripting indexes.

6
00:00:31.980 --> 00:00:34.640
The syntax is very simple and elegant.

7
00:00:34.710 --> 00:00:41.460
We have the keyword four followed by open and closed parentheses as usual inside the parentheses we

8
00:00:41.460 --> 00:00:46.040
provide the type and name for the variable we want to use in the loop body.

9
00:00:46.050 --> 00:00:50.730
This variable will be bound to each element of the collection so it should be of the same type as the

10
00:00:50.730 --> 00:00:52.290
collection elements.

11
00:00:52.290 --> 00:00:55.540
Then we provide a colon and the collection or collection name.

12
00:00:55.710 --> 00:00:57.030
That's it.

13
00:00:57.030 --> 00:01:01.620
Now when we access the variable name in the body of the loop it will have a specific element in the

14
00:01:01.620 --> 00:01:02.460
collection.

15
00:01:02.460 --> 00:01:03.140
Pretty cool.

16
00:01:03.180 --> 00:01:09.650
Let's see an example in this example our collection is an array of integers named scores that we've

17
00:01:09.660 --> 00:01:13.620
initialized to 100 90 and 97.

18
00:01:13.620 --> 00:01:19.110
And here's the code that iterates over that collection using the range based forelimb noticed that in

19
00:01:19.110 --> 00:01:21.890
the parentheses we provide the type of each array element.

20
00:01:21.900 --> 00:01:27.250
In this case it's an integer and we provide the variable name that we can use in the body of the loop.

21
00:01:27.360 --> 00:01:34.240
In this case score finally we provide a colon and the name of the collection which is scores.

22
00:01:34.420 --> 00:01:35.200
That's it.

23
00:01:35.200 --> 00:01:40.870
Now we can you score in the body of the loop the loop displays one hundred ninety and ninety seven which

24
00:01:40.870 --> 00:01:42.680
are the elements in the array.

25
00:01:42.700 --> 00:01:44.930
See how much cleaner less error prone this is.

26
00:01:44.940 --> 00:01:52.290
It was a great addition to C++ we actually don't have to explicitly provide the type of the variable.

27
00:01:52.600 --> 00:01:54.950
Instead we can use the auto keyword.

28
00:01:55.030 --> 00:01:59.460
This tells the C++ compiler to deduce the type itself.

29
00:01:59.470 --> 00:02:05.100
In other words you're asking the C++ compiler to figure out the type based on the declarations.

30
00:02:05.110 --> 00:02:09.490
So in this case the compiler sees that you are using a collection scores in the loop.

31
00:02:09.640 --> 00:02:14.980
So it looks it scores and it sees that it's an array of integers so it uses an integer for the score

32
00:02:14.980 --> 00:02:16.370
variable.

33
00:02:16.420 --> 00:02:23.560
Pretty easy actually in this case using auto versus It doesn't really bias much but C++ can have very

34
00:02:23.560 --> 00:02:29.350
complex collections and sometimes defining the type of a collection variable can be quite long and tricky

35
00:02:29.720 --> 00:02:32.450
auto makes it dead simple.

36
00:02:32.590 --> 00:02:37.660
And this example we want to calculate the average temperature from a vector that contains doubles that

37
00:02:37.660 --> 00:02:44.560
represent temperatures the vector in this case is called temp's and it contains four doubles in order

38
00:02:44.560 --> 00:02:47.050
to calculate the average temperature in this vector.

39
00:02:47.080 --> 00:02:50.850
We need to iterate over the vector axis each temperature.

40
00:02:50.980 --> 00:02:52.950
Add them all up and divide by 4.

41
00:02:52.960 --> 00:02:54.250
That's it.

42
00:02:54.250 --> 00:02:56.910
Notice the for loop and how simple it is.

43
00:02:56.950 --> 00:03:01.810
It's saying loop through the temp's collection and each time through a sign of temperature from the

44
00:03:01.810 --> 00:03:07.040
vector to the loop variable temp which the compiler deduced is to be a double.

45
00:03:07.150 --> 00:03:09.200
We add this to a running sum.

46
00:03:09.340 --> 00:03:13.690
Then when the loop is done we perform a simple division to get the average.

47
00:03:13.690 --> 00:03:18.010
Notice that I'm using the vector's size method which returns the number of elements in the vector.

48
00:03:18.010 --> 00:03:24.130
In this case it would turn for the range based for loop can also use an initializer list as a collection.

49
00:03:24.220 --> 00:03:30.460
Let's see that one this example also calculates the average for temperatures.

50
00:03:30.460 --> 00:03:34.460
Notice how we can explicitly provide the collection right in the for loop.

51
00:03:34.480 --> 00:03:39.730
This is sometimes handy when you know the elements of your collection ahead of time and they won't change.

52
00:03:39.750 --> 00:03:46.420
The only downside is that you have to calculate the sizes you go in this last example.

53
00:03:46.420 --> 00:03:52.110
We can use the range based for loop to iterate over a string which is a collection of characters.

54
00:03:52.300 --> 00:03:56.720
In this case the string is a literal Frank but it could be a variable.

55
00:03:56.740 --> 00:03:59.440
We're going to discuss strings in the next section of the course.

56
00:03:59.500 --> 00:04:02.410
Well that pretty much covers the basics of the range based for loop.

57
00:04:02.620 --> 00:04:05.260
Let's head over to the ID and see some examples.

58
00:04:07.180 --> 00:04:14.750
I'm in the code like ID in the section 9 workspace in the range based for loop project what I'd like

59
00:04:14.750 --> 00:04:20.990
to do in this example is go over a couple of examples of using the range based for loop with an array

60
00:04:21.380 --> 00:04:23.690
with a vector and with a string.

61
00:04:23.840 --> 00:04:27.530
So the first thing we'll do is just use a simple array and they'll notice that I've already included

62
00:04:27.530 --> 00:04:28.480
vector right appear.

63
00:04:28.490 --> 00:04:31.850
Since I'm going to use vector in a minute.

64
00:04:31.850 --> 00:04:39.140
So let's create an array of integers and we'll call it scores and we'll initialize it just say 10 20

65
00:04:39.140 --> 00:04:40.740
and 30.

66
00:04:41.930 --> 00:04:42.200
OK.

67
00:04:42.200 --> 00:04:46.340
So what we want to do now is we want to iterate through that collection.

68
00:04:46.380 --> 00:04:50.510
It's an array in this case using the range based for loop.

69
00:04:50.510 --> 00:04:56.430
It's as simple as can be we can say for it because we know we've got integers here.

70
00:04:56.870 --> 00:05:01.610
And what do we want to call each and we'll call it score his that's what it is a single score that we

71
00:05:01.610 --> 00:05:06.200
have the colon and then we provide the name of the collection in this case scores.

72
00:05:07.010 --> 00:05:14.510
So that's the loop header and then all we really need to do here is just say see out and display the

73
00:05:14.510 --> 00:05:18.130
score.

74
00:05:18.500 --> 00:05:19.270
That's it.

75
00:05:19.340 --> 00:05:25.990
Let's run this and that's exactly what we get 10 20 and 30.

76
00:05:26.100 --> 00:05:32.420
Now as I mentioned in the in the slides we don't have to provide that in there we can simply use the

77
00:05:32.420 --> 00:05:34.280
auto keyword.

78
00:05:34.850 --> 00:05:36.160
And what's going to happen here.

79
00:05:36.170 --> 00:05:39.650
I mean it's pretty straightforward but it's important that you understand what's going on.

80
00:05:39.650 --> 00:05:41.960
You're telling the compiler to figure out the type.

81
00:05:42.110 --> 00:05:45.690
So the compiler is going to come in here and say OK what's going on.

82
00:05:45.740 --> 00:05:47.330
The collection is scores.

83
00:05:47.540 --> 00:05:52.330
OK scores is an array of integers so this must be an it.

84
00:05:52.370 --> 00:05:55.230
So he's going to deduce that type right here to beat it.

85
00:05:55.400 --> 00:05:57.010
Same as we did before.

86
00:05:57.080 --> 00:06:02.720
As I mentioned this is not a big deal it's easy to type and it's easy to type auto but collections in

87
00:06:02.720 --> 00:06:09.620
C++ especially generic collections and templates get really crazy syntax and sometimes it's very difficult

88
00:06:09.620 --> 00:06:13.990
to to write exactly the type that you want.

89
00:06:14.300 --> 00:06:19.230
And this just makes it so easy you just type auto and the compiler will figure it out which is great.

90
00:06:19.400 --> 00:06:24.410
That's what we're doing here we just printed out the score is really really easy let me run this using

91
00:06:24.410 --> 00:06:28.610
the auto key word now you can see the behavior is exactly the same.

92
00:06:28.610 --> 00:06:29.100
All right.

93
00:06:29.150 --> 00:06:29.540
Perfect.

94
00:06:29.540 --> 00:06:33.650
Let me comment that out and let's do another example.

95
00:06:33.740 --> 00:06:36.280
In this case we'll create a vector.

96
00:06:36.470 --> 00:06:45.290
So let's create a vector of doubles and we'll just call it temperatures and we'll initialize these to

97
00:06:45.410 --> 00:06:50.630
let's say eighty seven point nine seventy seven point nine.

98
00:06:50.690 --> 00:06:53.860
Could be really any numbers you like 80 eighty zero.

99
00:06:54.290 --> 00:06:56.450
And how about seventy two point five.

100
00:06:56.570 --> 00:06:59.300
So those are the four temperatures that I'm interested in.

101
00:06:59.420 --> 00:07:03.170
Maybe their temperature is per week per year for a month.

102
00:07:03.170 --> 00:07:04.160
It doesn't really matter.

103
00:07:04.160 --> 00:07:05.870
It all depends on what you try to do.

104
00:07:05.870 --> 00:07:10.460
Now what we want to do is we want to calculate the average of the mean of those temperatures.

105
00:07:10.460 --> 00:07:10.700
All right.

106
00:07:10.700 --> 00:07:17.570
So we're going to need that the average itself so we'll just call it average temp and it's a double

107
00:07:19.340 --> 00:07:20.990
initialized to zero.

108
00:07:21.380 --> 00:07:25.970
And we also need a double that's going to be the running total because we need to sum them all up and

109
00:07:25.970 --> 00:07:29.240
then divide them by whatever size that vector is.

110
00:07:29.240 --> 00:07:32.570
In this case it happens to be four but it could be any size we want.

111
00:07:32.570 --> 00:07:37.440
So there's my double I'd call it total initialized to zero.

112
00:07:37.970 --> 00:07:41.370
All right so now let's loop through that vector.

113
00:07:41.540 --> 00:07:46.880
So we'll say for auto That's create the variable temp.

114
00:07:47.030 --> 00:07:50.020
Be one of those temperatures one at each iteration.

115
00:07:50.210 --> 00:08:01.520
And the name of the collection is temperatures where we do we say total plus equals temp.

116
00:08:02.410 --> 00:08:05.500
And I'll scroll up just a little bit myself a little bit of room.

117
00:08:05.570 --> 00:08:06.650
That's it.

118
00:08:06.650 --> 00:08:10.100
Now we divide by the size of that temperatures vector.

119
00:08:10.100 --> 00:08:14.300
But before we do that always make sure that that size is not equal to zero because we don't want to

120
00:08:14.300 --> 00:08:15.370
divide by zero error.

121
00:08:15.380 --> 00:08:24.380
So we'll just say something like If temperatures drop size that's the method for the vector if that's

122
00:08:24.410 --> 00:08:28.390
equal to zero then we don't want to do the division right.

123
00:08:28.400 --> 00:08:31.860
So what do we want to do we want to make sure it's not what is zero.

124
00:08:32.750 --> 00:08:35.410
If it's not equal to zero it's safe to divide.

125
00:08:35.450 --> 00:08:44.570
And what I'll say is as simple as average temp is equal to the total divided by the temperatures that

126
00:08:44.570 --> 00:08:45.910
size again.

127
00:08:46.430 --> 00:08:49.350
Number of elements in that vector.

128
00:08:49.820 --> 00:08:50.210
That's it.

129
00:08:50.210 --> 00:08:55.460
Notice we don't have to do any casting here because total This is an unsigned integer right here it's

130
00:08:55.460 --> 00:08:57.820
going to return the size which is an unsigned integer.

131
00:08:57.890 --> 00:09:02.270
But total we defined as a double so it's going to do double division.

132
00:09:02.540 --> 00:09:03.080
All right.

133
00:09:03.090 --> 00:09:05.030
So that's it will output.

134
00:09:05.020 --> 00:09:13.310
Now you say something like average temperature is

135
00:09:16.160 --> 00:09:17.160
average temp.

136
00:09:17.240 --> 00:09:22.120
Put an end line at the end and let's run this.

137
00:09:22.590 --> 00:09:26.070
There's the average temperature seventy nine point five seven five.

138
00:09:26.090 --> 00:09:29.690
Now let me show you one of the IO manipulators that you can use.

139
00:09:29.750 --> 00:09:33.520
And as I said I'll cover these later on in the in the course.

140
00:09:33.530 --> 00:09:37.250
There's a whole bunch of them and they're not all that important but they're all they're important to

141
00:09:37.250 --> 00:09:43.640
to help us format our output what we can do is we can say first thing we need to do is we each go up

142
00:09:43.640 --> 00:09:51.660
top here and include I O manip that's the IO manipulation operators.

143
00:09:52.010 --> 00:10:02.090
And what we do here is right before we output we can say see out fixed and then set precision to let's

144
00:10:02.090 --> 00:10:02.900
say 1.

145
00:10:02.930 --> 00:10:07.520
That's one number after the decimal point and it will round.

146
00:10:07.520 --> 00:10:13.670
So in this case let's run that and now you'll see this formatted as seventy nine point six I think before

147
00:10:13.670 --> 00:10:17.410
it was seventy nine point five seven five or something like that I don't recall.

148
00:10:17.480 --> 00:10:20.030
But it's going to rounded up to 70 9.6.

149
00:10:20.030 --> 00:10:23.090
It's always going to have one digit to the right of the decimal point.

150
00:10:23.180 --> 00:10:26.650
If this is what you need this is an easy way to do it otherwise.

151
00:10:26.690 --> 00:10:29.990
Seventy nine point five seven five works for me.

152
00:10:30.020 --> 00:10:33.380
All right so that'll take care of this example.

153
00:10:33.440 --> 00:10:38.130
Let me show you a couple more examples and again I'll comment these out so they don't keep executing.

154
00:10:38.380 --> 00:10:42.200
Let's put in an initializer list right into the loop.

155
00:10:42.200 --> 00:10:46.880
This is not something you see very often but I wanted to show you in case you do see it you know what's

156
00:10:46.880 --> 00:10:47.840
going on.

157
00:10:47.870 --> 00:10:54.050
This case will say for again auto and the value will be Val.

158
00:10:54.350 --> 00:10:56.660
And right in here we can put the initialiser list.

159
00:10:56.660 --> 00:10:59.460
We can say 1 2 3 4 5.

160
00:10:59.600 --> 00:11:03.320
Sometimes you see this when you know that these numbers are ahead of time.

161
00:11:03.440 --> 00:11:11.870
And in this case we could just say see out Vau and we can do in mind here.

162
00:11:12.200 --> 00:11:16.310
So what's going to happen is it's going to iterate through that collection remember this is a collection

163
00:11:16.680 --> 00:11:21.770
and it's going to display one two three four and five and it's run that real quick.

164
00:11:21.980 --> 00:11:25.900
And there you can see the one two three four and five.

165
00:11:25.940 --> 00:11:29.930
Now the last example I want to show you is with a string.

166
00:11:29.960 --> 00:11:32.490
Now there's two kinds of strings and C++.

167
00:11:32.500 --> 00:11:36.800
There is a C style string and there's a C plus plus string.

168
00:11:36.980 --> 00:11:39.250
I'm going to cover these in the next section.

169
00:11:39.340 --> 00:11:41.840
What we're going to use here is just a C-style string.

170
00:11:41.840 --> 00:11:43.250
That's what we've been using all along.

171
00:11:43.250 --> 00:11:46.610
That's a bunch of characters inside double quotes.

172
00:11:46.610 --> 00:11:51.950
So what I want to do is I'm just going to say for again audio in this case is going to be a character

173
00:11:51.950 --> 00:11:59.220
type I'll call it C and my collection is basically a bunch of characters write a sequence of characters

174
00:11:59.260 --> 00:12:03.100
so this is a test.

175
00:12:03.170 --> 00:12:04.580
That's it.

176
00:12:04.580 --> 00:12:05.720
What can I do in here.

177
00:12:05.720 --> 00:12:11.900
Well I can output the character and I'm not going to put a new line because I don't want a newline at

178
00:12:11.900 --> 00:12:14.170
the end of every character that I print them up and down.

179
00:12:14.300 --> 00:12:18.320
In this case it should just print that string right back out at me.

180
00:12:19.700 --> 00:12:20.900
And there you see right up here.

181
00:12:20.900 --> 00:12:22.330
This is a test.

182
00:12:22.370 --> 00:12:24.950
So it's putting it out directly out at me.

183
00:12:25.010 --> 00:12:28.220
Suppose I wanted to skip the spaces.

184
00:12:28.220 --> 00:12:29.000
How would I do that.

185
00:12:29.000 --> 00:12:34.970
Well we just filter the spaces that I would say if the character I'm looking at c in this case right

186
00:12:35.300 --> 00:12:38.380
is not equal to a space.

187
00:12:38.840 --> 00:12:41.210
Then print the character.

188
00:12:41.450 --> 00:12:45.140
So what's going to happen here again at each iteration I'm looking at that character.

189
00:12:45.200 --> 00:12:48.720
If it's not a space I print it if it is a space I'm not doing anything.

190
00:12:48.740 --> 00:12:52.310
So I'm basically just getting rid of all of the spaces inside that string.

191
00:12:52.340 --> 00:12:56.780
So when I display that you should see you see that right there.

192
00:12:56.780 --> 00:12:57.720
This is a test.

193
00:12:57.740 --> 00:13:00.040
All bunched up together.

194
00:13:00.040 --> 00:13:00.480
OK.

195
00:13:00.530 --> 00:13:03.050
Now suppose I wanted to replace the.

196
00:13:03.230 --> 00:13:08.270
And again we're not changing the string here we're just pointing out the string one character at a time.

197
00:13:08.270 --> 00:13:12.950
Suppose what I wanted to do was every time there's a space I want to replace it with a tab character.

198
00:13:12.950 --> 00:13:14.280
I want to display the tab.

199
00:13:14.480 --> 00:13:16.650
I want to spread these characters out a little bit.

200
00:13:16.880 --> 00:13:20.990
Well we can change the logic here a little bit and again let me comment this.

201
00:13:21.050 --> 00:13:23.240
So it's available for you to play with.

202
00:13:23.510 --> 00:13:23.780
And

203
00:13:26.950 --> 00:13:32.150
do something like that just so I can just modify a little bit of code and get this to run right.

204
00:13:32.300 --> 00:13:32.810
OK.

205
00:13:32.810 --> 00:13:37.630
So we're here in the same position I'm going to comment this out and so I'm reading the string again

206
00:13:37.640 --> 00:13:48.500
I've got each character in C and I'm going to say if C is the space then I don't want to print out the

207
00:13:48.500 --> 00:13:55.610
space what I want to do is I want to print out a tab and if I remember the tab is a slash T.

208
00:13:56.930 --> 00:14:00.560
Otherwise I'll just want to protect the character right.

209
00:14:00.590 --> 00:14:04.110
Anything except the space.

210
00:14:05.090 --> 00:14:07.220
Something like that.

211
00:14:07.220 --> 00:14:09.010
So let's try that out.

212
00:14:11.370 --> 00:14:17.630
And there you go it says this then you see a tab is them a tab A and a tab and test and so forth.

213
00:14:17.760 --> 00:14:21.390
We could play all kinds of games you can replace one character with another.

214
00:14:21.390 --> 00:14:24.520
You can create your own little cipher if you want that.

215
00:14:24.870 --> 00:14:28.000
You can send across to a friend and they can decipher it on the other side.

216
00:14:28.130 --> 00:14:32.220
Anyway that's pretty much the range based for loop.

217
00:14:32.220 --> 00:14:38.040
There's a couple of examples I've shown you here that hopefully make it really really easy I mean this

218
00:14:38.040 --> 00:14:39.250
is so much simple.

219
00:14:39.250 --> 00:14:46.440
Notice again there is no and there's no plus plus I were not counting we're simply looping through a

220
00:14:46.440 --> 00:14:50.230
collection and we don't even have to worry about the type with the auto.

221
00:14:50.310 --> 00:14:55.680
So it makes it really easy to think at a very high level to solve your problems without getting bogged

222
00:14:55.680 --> 00:14:57.340
down with all the little details.

223
00:14:57.570 --> 00:14:57.850
OK.

224
00:14:57.870 --> 00:14:59.440
So that's the end of this video.
