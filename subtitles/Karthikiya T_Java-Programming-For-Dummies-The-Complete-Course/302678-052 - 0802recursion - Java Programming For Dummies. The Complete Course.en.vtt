WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.670
in this video,

00:00:01.670 --> 00:00:06.510
we're gonna talk about Ryker Shin in Java and the method calls itself.

00:00:06.510 --> 00:00:08.260
It's called Ryker Shin.

00:00:08.260 --> 00:00:10.220
Take a look at this example.

00:00:10.220 --> 00:00:21.600
Let's say you have a method called example and inside that matter would have some logic And

00:00:21.600 --> 00:00:22.740
Britain this logic,

00:00:22.740 --> 00:00:31.650
we're gonna call the same method example So this will essentially call itself.

00:00:31.650 --> 00:00:37.710
And every time the controller interest inside this mattered and comes across within this

00:00:37.710 --> 00:00:38.550
instruction,

00:00:38.550 --> 00:00:41.330
it will call itself again Ryker.

00:00:41.330 --> 00:00:41.850
Salih.

00:00:41.850 --> 00:00:45.370
This mechanism is called Rick Ocean.

00:00:45.370 --> 00:00:49.100
One of the practical usages.

00:00:49.100 --> 00:00:49.780
Or rather,

00:00:49.780 --> 00:00:56.700
one of the most popular examples off Ryker Shin is to find the factorial off a number to

00:00:56.700 --> 00:00:57.820
find the factorial off.

00:00:57.820 --> 00:01:06.790
Number five went to do find multiplied before multiplied by three multiplied by to multiply

00:01:06.790 --> 00:01:16.790
it by one to find the factorial off three than that three multiplied by two multiplied by

00:01:16.790 --> 00:01:17.610
one.

00:01:17.610 --> 00:01:20.360
As simple as that.

00:01:20.360 --> 00:01:22.780
No.

00:01:22.780 --> 00:01:30.740
How do we find the factory off a number programmatically using the kirsch in Let's take a

00:01:30.740 --> 00:01:31.150
look.

00:01:31.150 --> 00:01:39.010
Let's say you have a method called factorial and it's going to take one perimeter,

00:01:39.010 --> 00:01:41.400
which is off type in Tex.

00:01:41.400 --> 00:01:44.970
Essentially,

00:01:44.970 --> 00:01:50.040
we're sending the value to this matter for which we need the factorial,

00:01:50.040 --> 00:01:53.180
the factory off one would be one.

00:01:53.180 --> 00:02:00.710
The factory law five would be product off all this that would result in 1 20 So in,

00:02:00.710 --> 00:02:01.690
or logic,

00:02:01.690 --> 00:02:08.220
if the perimeter equals equals one,

00:02:08.220 --> 00:02:12.350
that means we just simply need to return one.

00:02:12.350 --> 00:02:15.380
However,

00:02:15.380 --> 00:02:17.200
if it is greater than one,

00:02:17.200 --> 00:02:19.140
then we confined the factorial.

00:02:19.140 --> 00:02:20.790
How do we do that?

00:02:20.790 --> 00:02:26.750
Any guests is just one line off court that will do the magic.

00:02:26.750 --> 00:02:30.960
Can you try to figure out if,

00:02:30.960 --> 00:02:32.280
um sold this lane?

00:02:32.280 --> 00:02:37.250
Then we're finding the factory off a number in this manner.

00:02:37.250 --> 00:02:39.450
To find the factory of five,

00:02:39.450 --> 00:02:42.270
we're gonna say five multiply by,

00:02:42.270 --> 00:02:44.150
find minus one,

00:02:44.150 --> 00:02:48.980
and what are is the result is in this case,

00:02:48.980 --> 00:02:56.410
it's four multiply int by four minus one Again,

00:02:56.410 --> 00:02:57.970
What her is a result of this?

00:02:57.970 --> 00:03:05.170
The result in the result off this would be three multiplied by three minus one.

00:03:05.170 --> 00:03:06.570
So ultimately,

00:03:06.570 --> 00:03:09.930
we're trying to find five multiplied by four or Japan,

00:03:09.930 --> 00:03:15.060
but three so on until we reach the value one.

00:03:15.060 --> 00:03:22.850
So the result would be 1 20 We're gonna have the same logic in here,

00:03:22.850 --> 00:03:28.940
so we're gonna say health and the values,

00:03:28.940 --> 00:03:29.630
not one.

00:03:29.630 --> 00:03:40.450
Then return X multiplied by factorial off X minus one.

00:03:40.450 --> 00:03:45.950
I tried to think about this logic.

00:03:45.950 --> 00:03:49.650
It will definitely find the factorial off any given number.

00:03:49.650 --> 00:03:55.270
Let's say we wanted to find the factorial off five.

00:03:55.270 --> 00:03:58.150
And that's what we send as a perimeter.

00:03:58.150 --> 00:04:00.430
Since five is not equals one,

00:04:00.430 --> 00:04:02.170
we're not going to return the valley one.

00:04:02.170 --> 00:04:07.750
So we will enter inside this else block in else block.

00:04:07.750 --> 00:04:12.480
We're returning something X multiplied by factorial off.

00:04:12.480 --> 00:04:13.350
Explain this one.

00:04:13.350 --> 00:04:24.650
What this statement essentially does is five multiplied by the factorial off form.

00:04:24.650 --> 00:04:32.030
So fine multiplying by drizzled off this method call.

00:04:32.030 --> 00:04:38.350
Whatever gets returned from this method call will be multiplied with five.

00:04:38.350 --> 00:04:43.040
But in here we're calling this method again.

00:04:43.040 --> 00:04:50.380
And this time the value The the perimeter that we're sending is four.

00:04:50.380 --> 00:04:55.910
So once again for is not equal into one.

00:04:55.910 --> 00:04:58.550
So will enter inside the else block.

00:04:58.550 --> 00:05:14.110
And hence the question would be four while deployed by factorial off for minus one which

00:05:14.110 --> 00:05:28.510
will become three again three multiplied by factorial off to it keeps going until the value

00:05:28.510 --> 00:05:29.230
is one.

00:05:29.230 --> 00:05:32.810
Once we hit the number one,

00:05:32.810 --> 00:05:35.890
we're not calling this method anymore.

00:05:35.890 --> 00:05:41.250
So ultimately we're finding the product off.

00:05:41.250 --> 00:05:48.170
Five multiplied by four months of planned by three so on and so forth,

00:05:48.170 --> 00:05:55.450
and we get the result as 1 20 And there's one important thing to understand.

00:05:55.450 --> 00:05:57.800
Whenever you're using Ryker Shin,

00:05:57.800 --> 00:06:03.550
it is your responsibility as a programmer to put a terminating condition.

00:06:03.550 --> 00:06:05.980
Otherwise,

00:06:05.980 --> 00:06:14.050
method will keep calling itself and will cause ever's the error that it causes his called

00:06:14.050 --> 00:06:16.350
stack overflow exception.

00:06:16.350 --> 00:06:22.080
The reason is every time we call a Matin in our stack,

00:06:22.080 --> 00:06:24.570
memory and new section will be dedicated,

00:06:24.570 --> 00:06:25.240
for that matter,

00:06:25.240 --> 00:06:28.950
to store its local variables acceptable.

00:06:28.950 --> 00:06:32.860
If you keep calling the method again and again,

00:06:32.860 --> 00:06:34.650
the stack is going to get full,

00:06:34.650 --> 00:06:38.980
and within no time you'll get an exception.

00:06:38.980 --> 00:06:42.490
And that exception is stack overflow.

00:06:42.490 --> 00:06:43.150
Exception.

00:06:43.150 --> 00:06:51.190
Let's take a look at example of this to let's go to our workbench for this unit.

00:06:51.190 --> 00:06:58.050
Open the project classes and object extended in that open the file factorial example.

00:06:58.050 --> 00:07:03.320
The logic in here exactly is exactly what we have seen in our white board.

00:07:03.320 --> 00:07:05.480
We have X equals.

00:07:05.480 --> 00:07:11.420
One else were using their coercion mechanism to find out the factorial off a given number

00:07:11.420 --> 00:07:13.390
in this case I gave five,

00:07:13.390 --> 00:07:16.360
lets you the result that's on the file.

00:07:16.360 --> 00:07:24.630
The factory of five is 1 20 Let's do another value.

00:07:24.630 --> 00:07:27.950
Let's say I want to you 10.

00:07:27.950 --> 00:07:34.000
Let's have the file and again run the file.

00:07:34.000 --> 00:07:37.480
The factory off 10 is this.

00:07:37.480 --> 00:07:39.850
We're good.

00:07:39.850 --> 00:07:43.150
Now let's take a look at this.

00:07:43.150 --> 00:07:45.280
This stack overflow exception.

00:07:45.280 --> 00:07:45.680
No,

00:07:45.680 --> 00:07:47.770
we haven't talked about exceptions yet.

00:07:47.770 --> 00:07:49.820
We will in our future chapters.

00:07:49.820 --> 00:07:53.150
But essentially you can think off it as as an error.

00:07:53.150 --> 00:07:58.450
Let's take a look at this example that's run the file.

00:07:58.450 --> 00:08:07.780
So what are we trying to do here is we call this method in here the controller interest

00:08:07.780 --> 00:08:14.650
inside this mattered prince are the statement and in our second line off this matter,

00:08:14.650 --> 00:08:21.910
we're calling the same matter game and there is no condition that will stop this and gives

00:08:21.910 --> 00:08:22.860
off factorial.

00:08:22.860 --> 00:08:26.450
We have this condition effects equals one.

00:08:26.450 --> 00:08:28.390
Then we're gonna determine it.

00:08:28.390 --> 00:08:32.050
Whereas in here we don't have such condition.

00:08:32.050 --> 00:08:33.540
And moreover,

00:08:33.540 --> 00:08:40.180
do take note that this message will never be printed because we're just simply kept calling

00:08:40.180 --> 00:08:45.070
the same method again and again every time the controller comes in here and just going to

00:08:45.070 --> 00:08:46.420
go back to the beginning.

00:08:46.420 --> 00:08:52.950
So if you take a look at the output we got for every method call,

00:08:52.950 --> 00:08:59.780
there's a new section in the stack created and after some time when this stack got full,

00:08:59.780 --> 00:09:08.940
we got a stack or Fleder and that's what it is messaging and ultimately our built failed.

00:09:08.940 --> 00:09:15.240
So this is there's a risk associated with precaution.

00:09:15.240 --> 00:09:18.560
You need to use it very carefully or respected.

00:09:18.560 --> 00:09:19.730
Terminating condition.

00:09:19.730 --> 00:09:26.680
Let's go toe white board Another practical example off using the coercion is for Benaki

00:09:26.680 --> 00:09:27.210
sarees.

00:09:27.210 --> 00:09:29.120
So what is for Benaki service?

00:09:29.120 --> 00:09:37.630
It will start with 01 We'll find to some off this to which will make the one and then we

00:09:37.630 --> 00:09:41.000
find some off these last two digits.

00:09:41.000 --> 00:09:54.160
So that will make it to some of these two digits We get three these 25 hate 13.

00:09:54.160 --> 00:10:00.500
So this is called the Benaki sarees and the logic we're using in our program,

00:10:00.500 --> 00:10:02.110
it is somewhat like this.

00:10:02.110 --> 00:10:05.350
We have this variables declared and initialized.

00:10:05.350 --> 00:10:07.100
No,

00:10:07.100 --> 00:10:15.150
we're gonna start of a print forced to values zero and one is in system dot r dot print

00:10:15.150 --> 00:10:18.920
Ellen and in our method for benaki serious number.

00:10:18.920 --> 00:10:20.950
We're going to send a perimeter.

00:10:20.950 --> 00:10:28.450
Let's say we send the Value 1000 when we want women August serous until 1000.

00:10:28.450 --> 00:10:33.010
So the way we're dealing with it is using these three variables,

00:10:33.010 --> 00:10:41.340
we're gonna find the some off A and B and store Whatever is the result in this fib?

00:10:41.340 --> 00:10:41.980
Numb.

00:10:41.980 --> 00:10:46.540
And then So that means essentially,

00:10:46.540 --> 00:10:50.850
let's say value off initial the value of N B or zero and one,

00:10:50.850 --> 00:10:55.480
we find the sum off and B that will make it to one.

00:10:55.480 --> 00:11:04.850
So the Fed numb value would be no one going to store the value off,

00:11:04.850 --> 00:11:18.210
be in to a and we're gonna store the value off this result in to be and we're gonna print

00:11:18.210 --> 00:11:21.780
this number 15 isn't system got ordered.

00:11:21.780 --> 00:11:22.260
Penn Teller.

00:11:22.260 --> 00:11:34.950
Now the values off nbr updated to one and one again will try to find this some off nb so

00:11:34.950 --> 00:11:40.780
that will make it to we're gonna say in the value of B in a.

00:11:40.780 --> 00:11:50.880
So that will make the value off a 21 and then the value off be will become too.

00:11:50.880 --> 00:11:56.210
So we got these two values again.

00:11:56.210 --> 00:12:04.020
We'll find the some of these two values toward the value off three in Feb Nam variable and

00:12:04.020 --> 00:12:10.030
they will now hold the value off to A and B will hold the value off three so on and so

00:12:10.030 --> 00:12:12.430
forth and we'll have a terminating condition.

00:12:12.430 --> 00:12:17.890
Whatever is the value that present to that mattered is the maximum value.

00:12:17.890 --> 00:12:19.890
And we don't want to generating.

00:12:19.890 --> 00:12:25.950
If you've been talking numbers beyond that number now let's take a look at that example in

00:12:25.950 --> 00:12:26.590
our court.

00:12:26.590 --> 00:12:29.590
Here it is.

00:12:29.590 --> 00:12:33.680
We have these three variables in here.

00:12:33.680 --> 00:12:35.590
We have the maximum adopt 1000.

00:12:35.590 --> 00:12:39.820
We're just simply printing the values.

00:12:39.820 --> 00:12:45.010
The first initial values would would always be 01 So where their stride of their printing

00:12:45.010 --> 00:12:45.350
them.

00:12:45.350 --> 00:12:48.850
And we're calling this method for the Nakis Aries.

00:12:48.850 --> 00:12:51.750
This has the logic,

00:12:51.750 --> 00:12:53.750
which I'm talking about,

00:12:53.750 --> 00:12:56.650
and this is the line that does all the magic.

00:12:56.650 --> 00:13:01.210
It's going to call itself recursive Lee until this condition fails.

00:13:01.210 --> 00:13:04.050
Let's stretch run this program.

00:13:04.050 --> 00:13:09.270
There you go.

00:13:09.270 --> 00:13:12.550
Let's give the value off 10 1000.

00:13:12.550 --> 00:13:14.650
Let's have the file.

00:13:14.650 --> 00:13:16.890
Run it again.

00:13:16.890 --> 00:13:19.660
There you go.

00:13:19.660 --> 00:13:23.940
I hope you've enjoyed

