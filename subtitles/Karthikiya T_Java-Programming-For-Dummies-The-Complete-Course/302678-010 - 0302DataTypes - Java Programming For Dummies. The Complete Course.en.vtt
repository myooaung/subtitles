WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:04.990
in our previous video will talk the board variables and data types.

00:00:04.990 --> 00:00:06.490
Now in this video,

00:00:06.490 --> 00:00:10.650
we'll understand how much memory does each off these dinnertime take.

00:00:10.650 --> 00:00:14.010
We've already talked about into Jordana type.

00:00:14.010 --> 00:00:18.190
It takes four bytes off memory just for your information.

00:00:18.190 --> 00:00:24.420
Each bite would constitute eight bits and a bit is the smallest unit off memory in

00:00:24.420 --> 00:00:25.300
computing world,

00:00:25.300 --> 00:00:29.150
and the value can fall in within this range.

00:00:29.150 --> 00:00:30.010
For example,

00:00:30.010 --> 00:00:33.590
in the equals 100 is valid into a equals.

00:00:33.590 --> 00:00:36.770
100,000 million's is not valid.

00:00:36.770 --> 00:00:39.480
The number has to fall within this range.

00:00:39.480 --> 00:00:42.020
Short is a shorter form off indigent,

00:00:42.020 --> 00:00:44.160
and it takes half the memory.

00:00:44.160 --> 00:00:50.190
What indigent would take that they just takes two bites off memory and its value can fall

00:00:50.190 --> 00:00:55.660
within this range but takes the shortest memory off all numerical data types,

00:00:55.660 --> 00:00:58.750
and you can have a number within this range.

00:00:58.750 --> 00:01:02.040
This range actually makes sense,

00:01:02.040 --> 00:01:05.750
given the fact that it just takes one bite off memory.

00:01:05.750 --> 00:01:06.920
As I said,

00:01:06.920 --> 00:01:09.500
one by it would constitute a boots.

00:01:09.500 --> 00:01:11.920
So with one bite,

00:01:11.920 --> 00:01:22.050
you can have 2 55 combinations off zeros and once so hence the range is 1 28 to 1 27 Same

00:01:22.050 --> 00:01:24.660
is the case with all the other data types.

00:01:24.660 --> 00:01:29.310
No long takes eight bites off memory,

00:01:29.310 --> 00:01:33.050
and you can have a number within this range.

00:01:33.050 --> 00:01:35.450
In most of the cases,

00:01:35.450 --> 00:01:36.540
you would have the use,

00:01:36.540 --> 00:01:38.220
integer or shot,

00:01:38.220 --> 00:01:42.120
and only in rare cases it would ever use long.

00:01:42.120 --> 00:01:46.520
So why do we have four different indigent types?

00:01:46.520 --> 00:01:54.530
The problem is the performance it because if you have to use a variable that holds a value

00:01:54.530 --> 00:01:55.650
within this range,

00:01:55.650 --> 00:02:00.560
maybe let's say the value 1 20 Then if you use long for that,

00:02:00.560 --> 00:02:02.880
it occupies eight bites off memory,

00:02:02.880 --> 00:02:04.890
whereas if you use bite,

00:02:04.890 --> 00:02:09.490
it would just consume one bite off memory in guess off high end applications.

00:02:09.490 --> 00:02:11.340
Memory is very appreciates.

00:02:11.340 --> 00:02:12.890
If you keep using long,

00:02:12.890 --> 00:02:14.770
even though it is not necessary,

00:02:14.770 --> 00:02:15.890
then it would be great.

00:02:15.890 --> 00:02:17.660
The performance off your application.

00:02:17.660 --> 00:02:20.950
We've already talked about double their type.

00:02:20.950 --> 00:02:23.790
It consumes eight bites off memory,

00:02:23.790 --> 00:02:28.110
and it can have a decimal number within this range.

00:02:28.110 --> 00:02:28.860
Essentially,

00:02:28.860 --> 00:02:30.020
what this means is,

00:02:30.020 --> 00:02:31.050
in simple terms,

00:02:31.050 --> 00:02:33.700
you can have up to 15 decimal digits,

00:02:33.700 --> 00:02:39.830
which means the numbers that come after the decimal point float is a shorter version off

00:02:39.830 --> 00:02:42.950
double and it just consumes four bytes of memory,

00:02:42.950 --> 00:02:46.250
and you can have a decimal number within this range.

00:02:46.250 --> 00:02:47.210
Essentially,

00:02:47.210 --> 00:02:49.250
you can have up to seven decimal digits.

00:02:49.250 --> 00:02:52.730
We have a couple of other stereotypes.

00:02:52.730 --> 00:02:56.880
Building is a data time that holds only two values.

00:02:56.880 --> 00:03:00.150
There are only two possible values that bullying can hold.

00:03:00.150 --> 00:03:02.900
One is true and the other is false,

00:03:02.900 --> 00:03:06.350
and it just gun Jim's one bit off memory.

00:03:06.350 --> 00:03:07.260
Actually,

00:03:07.260 --> 00:03:10.620
it's not reasonable to say takes one bit off memory.

00:03:10.620 --> 00:03:13.840
It's actually dependent on few of the factors,

00:03:13.840 --> 00:03:16.970
one of which is the JV in that you're using.

00:03:16.970 --> 00:03:20.950
But typically let us human just takes one bit off memory.

00:03:20.950 --> 00:03:21.890
Carol did.

00:03:21.890 --> 00:03:25.370
A type is a single 16 Bettini cord character.

00:03:25.370 --> 00:03:27.890
It consumes two bites off memory,

00:03:27.890 --> 00:03:30.780
and number has to fall in within this range.

00:03:30.780 --> 00:03:35.370
This might confuse a little bit for you because we're talking about character.

00:03:35.370 --> 00:03:40.770
Character can be Letter A on the paparazzi or hello,

00:03:40.770 --> 00:03:41.770
case X.

00:03:41.770 --> 00:03:47.070
But how come we have numbers New miracles here in order to demonstrate the data type?

00:03:47.070 --> 00:03:49.430
Can I already have a program written?

00:03:49.430 --> 00:03:58.710
Let's go through it if you take a look at the character.

00:03:58.710 --> 00:04:02.540
Variable C three then it's just holding a single character.

00:04:02.540 --> 00:04:03.310
In this case,

00:04:03.310 --> 00:04:07.910
it's a but character data type can also hold and New America.

00:04:07.910 --> 00:04:09.530
If we try to print see one,

00:04:09.530 --> 00:04:11.620
it won't print 76.

00:04:11.620 --> 00:04:12.480
Instead,

00:04:12.480 --> 00:04:16.630
it would print a character which is corresponding to this Unicord,

00:04:16.630 --> 00:04:17.540
for example,

00:04:17.540 --> 00:04:21.770
For 76 the character that is corresponding to this is Letter L.

00:04:21.770 --> 00:04:25.350
And for 40 it is the opening parenthesis.

00:04:25.350 --> 00:04:28.470
Let's run this program so that will understand more.

00:04:28.470 --> 00:04:29.420
Let's open the command.

00:04:29.420 --> 00:04:31.380
Rosser Goto Desktop.

00:04:31.380 --> 00:04:33.120
That's where my program is deciding.

00:04:33.120 --> 00:04:34.600
That's to see Lester Piggott,

00:04:34.600 --> 00:04:38.180
the screen and the Java Sea carried or JAMA.

00:04:38.180 --> 00:04:39.380
Let's run it.

00:04:39.380 --> 00:04:43.980
So let's see what has happened.

00:04:43.980 --> 00:04:48.750
The care for unique or center six is l.

00:04:48.750 --> 00:04:51.090
So this is the instruction,

00:04:51.090 --> 00:04:55.610
which prints that that care for any course under six years.

00:04:55.610 --> 00:04:56.800
See one.

00:04:56.800 --> 00:05:01.720
So it just retrieved the letter Responding to Unicord 76.

00:05:01.720 --> 00:05:04.350
Same is the case with CTU.

00:05:04.350 --> 00:05:06.200
Care for Unicord,

00:05:06.200 --> 00:05:12.100
40 is hoping Prentice now for C three were just simply displaying What is what is there

00:05:12.100 --> 00:05:12.470
here?

00:05:12.470 --> 00:05:15.370
The letter A now here is interesting part.

00:05:15.370 --> 00:05:18.790
The press bless is an increment operator.

00:05:18.790 --> 00:05:23.090
Soon we're going to discuss what this is in this case,

00:05:23.090 --> 00:05:25.790
what it is doing is for C three character.

00:05:25.790 --> 00:05:26.330
A.

00:05:26.330 --> 00:05:28.720
If you do see three plus bless,

00:05:28.720 --> 00:05:32.140
it will just increment the unique or off a by one.

00:05:32.140 --> 00:05:32.870
But that I mean,

00:05:32.870 --> 00:05:38.070
the unicorn off a is 65 it will increments it by one.

00:05:38.070 --> 00:05:39.800
So it will be 66.

00:05:39.800 --> 00:05:41.950
And when we print C three now,

00:05:41.950 --> 00:05:49.920
it would print the character corresponding to the number 66 Letter B In our future Examples

00:05:49.920 --> 00:05:53.400
boot Definite will be using this operator again and again.

00:05:53.400 --> 00:05:57.020
I'm sure that you would feel much comfortable with this now.

00:05:57.020 --> 00:06:01.520
One more thing to note is the Unicord character set has,

00:06:01.520 --> 00:06:02.960
like I mentioned,

00:06:02.960 --> 00:06:05.670
it has 65,000 numerical.

00:06:05.670 --> 00:06:09.360
So that means they're 65,000 plus characters as well,

00:06:09.360 --> 00:06:13.660
which means it supports all the characters in most of the popular languages.

00:06:13.660 --> 00:06:13.790
Now,

00:06:13.790 --> 00:06:18.900
if you give a number something like 90,000 something like that now,

00:06:18.900 --> 00:06:23.470
the character of responding to it may not get displayed in the command processor.

00:06:23.470 --> 00:06:28.020
It's because the command processor does not support all the characters.

00:06:28.020 --> 00:06:31.680
If you have much advanced going to face to run this program,

00:06:31.680 --> 00:06:33.450
maybe something like eclipse or something.

00:06:33.450 --> 00:06:38.070
Then you can probably display the output in most of the popular languages,

00:06:38.070 --> 00:06:38.770
like German,

00:06:38.770 --> 00:06:39.260
French,

00:06:39.260 --> 00:06:39.710
Latin,

00:06:39.710 --> 00:06:40.290
etcetera.

00:06:40.290 --> 00:06:41.050
Hold it.

00:06:41.050 --> 00:06:50.460
Data types is pretty vast concept in Java and whatever we have discussed in this video or

00:06:50.460 --> 00:06:51.940
just primitive data types,

00:06:51.940 --> 00:06:56.190
and when it comes to non primitive there types or object there types,

00:06:56.190 --> 00:06:57.350
it's pretty vast.

00:06:57.350 --> 00:06:58.870
That being said,

00:06:58.870 --> 00:07:00.350
don't get terrified.

00:07:00.350 --> 00:07:03.490
We're going to color everything in detail,

00:07:03.490 --> 00:07:06.250
and I'm sure that I'm going to make you feel comfortable.

00:07:06.250 --> 00:07:07.360
But for now,

00:07:07.360 --> 00:07:09.300
these are called primitive data types,

00:07:09.300 --> 00:07:12.980
and I believe you have a fair idea on what these are.

