WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:00.720
Okay,

00:00:00.720 --> 00:00:06.250
let's take a look at a couple of more examples off Lambda expressions in this class.

00:00:06.250 --> 00:00:09.530
I have the exact chord from our previous example,

00:00:09.530 --> 00:00:13.520
except now this matter would accept a couple of para meters,

00:00:13.520 --> 00:00:14.990
which are off type end.

00:00:14.990 --> 00:00:21.410
I'm finding to some of those two arguments in here and passing that two arguments that I

00:00:21.410 --> 00:00:23.490
wanted to get the summer off.

00:00:23.490 --> 00:00:27.600
Let's run the program now.

00:00:27.600 --> 00:00:31.200
How can we convert this into a Lambda expression?

00:00:31.200 --> 00:00:34.530
Let's go step by step again.

00:00:34.530 --> 00:00:37.410
We're going to get it off the class declaration.

00:00:37.410 --> 00:00:43.550
And since there is no purpose off new and public access pacifier,

00:00:43.550 --> 00:00:46.950
let's get it off them again.

00:00:46.950 --> 00:00:52.230
Compile A can figure out that this set of instructions are in this case is just one

00:00:52.230 --> 00:00:54.690
instruction is not returning anything,

00:00:54.690 --> 00:00:57.050
so I don't have to have there were turned type.

00:00:57.050 --> 00:01:02.410
The name of the matter is something that the compare A can figure out by looking at the

00:01:02.410 --> 00:01:03.360
reference type,

00:01:03.360 --> 00:01:04.350
which is Matt.

00:01:04.350 --> 00:01:08.870
You can get it off this and of course,

00:01:08.870 --> 00:01:14.770
no override because the only method that we can possibly all right is the only method

00:01:14.770 --> 00:01:16.330
present in that interface.

00:01:16.330 --> 00:01:18.870
Let's get it off this as well.

00:01:18.870 --> 00:01:27.240
Now we're going to have this arrow symbol and we're gonna end the statement with a semi

00:01:27.240 --> 00:01:30.440
Colin and that's it.

00:01:30.440 --> 00:01:31.460
And again,

00:01:31.460 --> 00:01:33.410
since it's just one line off court,

00:01:33.410 --> 00:01:37.290
you can get it off this Kohli braces as well.

00:01:37.290 --> 00:01:39.880
Like so.

00:01:39.880 --> 00:01:42.620
And guess what?

00:01:42.620 --> 00:01:45.470
What we have here is a Lambda expression.

00:01:45.470 --> 00:01:50.450
Now we can for their short in this line by a few characters again,

00:01:50.450 --> 00:01:53.940
some parts off this line can be figured out by the compiler.

00:01:53.940 --> 00:01:54.830
By that,

00:01:54.830 --> 00:01:55.430
I mean,

00:01:55.430 --> 00:02:00.810
even if you don't tell compiler the type off argument that they're going to be 1000 in to

00:02:00.810 --> 00:02:01.390
this method,

00:02:01.390 --> 00:02:06.500
it can figure that out by looking at the matter in this interface.

00:02:06.500 --> 00:02:07.080
Matt.

00:02:07.080 --> 00:02:10.220
So still combat does not complain.

00:02:10.220 --> 00:02:12.450
Everything works just well.

00:02:12.450 --> 00:02:22.280
Now what if you have some kind off a return type in here and that's what we're gonna talk

00:02:22.280 --> 00:02:23.550
about in this example?

00:02:23.550 --> 00:02:26.160
Let's have written type as int.

00:02:26.160 --> 00:02:28.250
Same goes in here,

00:02:28.250 --> 00:02:33.720
and this method is going to return to some of those two arguments.

00:02:33.720 --> 00:02:39.440
Return in here.

00:02:39.440 --> 00:02:47.600
Let's use sits out statement just to display whatever is being returned.

00:02:47.600 --> 00:02:50.250
But calling this method find some.

00:02:50.250 --> 00:02:51.570
Let's run the program.

00:02:51.570 --> 00:02:56.770
Let's try to convert this into alarmed expression.

00:02:56.770 --> 00:02:58.690
We can get it off.

00:02:58.690 --> 00:03:10.230
This and everything in here have the a remark pretty well and good.

00:03:10.230 --> 00:03:11.190
And again,

00:03:11.190 --> 00:03:13.150
since it's just one line of code,

00:03:13.150 --> 00:03:16.780
you can have everything and one line,

00:03:16.780 --> 00:03:18.510
but we have a problem here.

00:03:18.510 --> 00:03:25.730
Compiler does not want us to use the written statement because it knows that it needs to

00:03:25.730 --> 00:03:29.880
return int because it is ever off the interface.

00:03:29.880 --> 00:03:34.430
And it knows the return type of this method that skated off this.

00:03:34.430 --> 00:03:35.770
Now guess what?

00:03:35.770 --> 00:03:38.220
This will work just fine.

00:03:38.220 --> 00:03:39.350
Let's run the program.

00:03:39.350 --> 00:03:44.520
But obviously when you have more,

00:03:44.520 --> 00:03:49.080
then more line off court you need to rob the cold around the Kohli braces,

00:03:49.080 --> 00:03:49.750
for example.

00:03:49.750 --> 00:03:53.850
Let's say I'm going to say into X equals a plus B,

00:03:53.850 --> 00:03:58.850
and I'm going to return X in the scarce.

00:03:58.850 --> 00:04:02.580
We need to tell the compiler what we want to return,

00:04:02.580 --> 00:04:06.240
because there we have another lane.

00:04:06.240 --> 00:04:08.550
Something like this.

00:04:08.550 --> 00:04:09.500
Compare.

00:04:09.500 --> 00:04:12.340
It cannot figure out whether to return X what,

00:04:12.340 --> 00:04:14.080
why we need to tell the compiler.

00:04:14.080 --> 00:04:19.510
But whereas if you have just this part and you have it in one line,

00:04:19.510 --> 00:04:22.650
just as we had looked at a moment ago.

00:04:22.650 --> 00:04:23.450
In that case,

00:04:23.450 --> 00:04:25.040
you don't have to use the return key work.

00:04:25.040 --> 00:04:32.000
It's get it off this save the file pretty well and good.

00:04:32.000 --> 00:04:33.820
Also one thing,

00:04:33.820 --> 00:04:39.790
which is what mentioning is that Lambda expressions would work only when you work with an

00:04:39.790 --> 00:04:43.050
interface that has exactly one method.

00:04:43.050 --> 00:04:44.790
For example,

00:04:44.790 --> 00:04:45.690
in this case,

00:04:45.690 --> 00:04:49.370
if you have another mother defined in here,

00:04:49.370 --> 00:04:55.400
compiler does not know the which method is this.

00:04:55.400 --> 00:04:57.350
Implementation belonged to,

00:04:57.350 --> 00:04:58.920
in this case,

00:04:58.920 --> 00:05:05.060
anonymous classes away to go or create your own class and have this interface implemented.

00:05:05.060 --> 00:05:08.160
But if you want to use Lambda expression,

00:05:08.160 --> 00:05:11.970
you would need to have exactly one mattered in your in your interface.

00:05:11.970 --> 00:05:16.510
Let's get out of this.

00:05:16.510 --> 00:05:22.210
But there is a possibility that somebody can accidentally make changes to the interface,

00:05:22.210 --> 00:05:24.790
and that would affect the entire project.

00:05:24.790 --> 00:05:30.320
And it will impact all the areas you used the land expression based on that interface.

00:05:30.320 --> 00:05:36.960
So one way to award that is by using an annotation functional interface,

00:05:36.960 --> 00:05:41.700
and but this if you try to define one more method in this interferes,

00:05:41.700 --> 00:05:49.980
it's going to go through a combat a mirror saying invalid annotation and example,

00:05:49.980 --> 00:05:51.570
that math is not puncture interface.

00:05:51.570 --> 00:05:54.880
So we're opposed to get it off this.

00:05:54.880 --> 00:05:56.120
All right.

00:05:56.120 --> 00:05:57.590
See you in my next video.

