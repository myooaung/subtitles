WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:04.510
Sometimes it's the problems faced by developers or programmers,

00:00:04.510 --> 00:00:06.610
which will introduce new features.

00:00:06.610 --> 00:00:09.350
Same is the case with a raise.

00:00:09.350 --> 00:00:11.440
Let me explain you what I mean.

00:00:11.440 --> 00:00:13.870
Take a look at this program.

00:00:13.870 --> 00:00:20.760
What we're having is we're having the salary details off 10 different employees off a

00:00:20.760 --> 00:00:21.250
company.

00:00:21.250 --> 00:00:22.960
For example,

00:00:22.960 --> 00:00:30.430
Ron earns $10 million and Christian store $1,000,000 off this.

00:00:30.430 --> 00:00:33.750
No paying job would pay you so much whatsoever.

00:00:33.750 --> 00:00:35.130
But for example,

00:00:35.130 --> 00:00:35.560
Zika.

00:00:35.560 --> 00:00:43.060
Let's assume so now let's say I wanted to find out the average salary off all these

00:00:43.060 --> 00:00:43.800
employees.

00:00:43.800 --> 00:00:50.960
The farmland that we need to use is some off all the salaries off all the employees divided

00:00:50.960 --> 00:00:53.350
by the number off employs.

00:00:53.350 --> 00:01:01.510
So I would do Ron Less Ben Bless Library place.

00:01:01.510 --> 00:01:02.600
Koresh,

00:01:02.600 --> 00:01:03.480
cliffs,

00:01:03.480 --> 00:01:03.930
blah,

00:01:03.930 --> 00:01:04.140
blah,

00:01:04.140 --> 00:01:07.450
blah divided by and then the count.

00:01:07.450 --> 00:01:07.850
10.

00:01:07.850 --> 00:01:10.300
Let me just make sure it is Stand.

00:01:10.300 --> 00:01:13.420
1234567 19 Loan.

00:01:13.420 --> 00:01:13.770
Sorry,

00:01:13.770 --> 00:01:14.250
it's 11.

00:01:14.250 --> 00:01:16.550
So he is the problem.

00:01:16.550 --> 00:01:19.930
It is pretty tiresome for me to write,

00:01:19.930 --> 00:01:24.420
and it's even more tiresome for you to listen also.

00:01:24.420 --> 00:01:28.650
Let's what we have some hundreds of employees here,

00:01:28.650 --> 00:01:32.250
and we need to give a proper count here,

00:01:32.250 --> 00:01:34.810
which is pain taking process.

00:01:34.810 --> 00:01:36.930
If I give an incorrect count,

00:01:36.930 --> 00:01:40.350
then that would yield a very bad result.

00:01:40.350 --> 00:01:43.570
So how do we solve this problem with areas?

00:01:43.570 --> 00:01:48.610
Let me pull pen and paper and let's see a real time example of race.

00:01:48.610 --> 00:01:50.370
All right,

00:01:50.370 --> 00:01:57.150
let's say you own a transportation business and you specialize in transporting cars.

00:01:57.150 --> 00:02:00.800
So now you got a requirement very into transport.

00:02:00.800 --> 00:02:01.950
10 cars.

00:02:01.950 --> 00:02:03.120
Now we have,

00:02:03.120 --> 00:02:03.430
AH,

00:02:03.430 --> 00:02:06.610
source and destination,

00:02:06.610 --> 00:02:09.170
which is very need to transport the cars,

00:02:09.170 --> 00:02:09.460
too.

00:02:09.460 --> 00:02:14.040
Now you'll start by sending all the cars on the road.

00:02:14.040 --> 00:02:15.530
R C one.

00:02:15.530 --> 00:02:17.550
C two C three.

00:02:17.550 --> 00:02:19.340
Now the problem is,

00:02:19.340 --> 00:02:20.990
it's pretty difficult toe.

00:02:20.990 --> 00:02:22.720
Keep track on each and every car.

00:02:22.720 --> 00:02:24.010
Make sure it is safe.

00:02:24.010 --> 00:02:29.650
Take care of all the fuel expenses and potential physical damage to the car.

00:02:29.650 --> 00:02:31.790
Exited a lot of things to be considered,

00:02:31.790 --> 00:02:34.550
and it's pretty hard to manage.

00:02:34.550 --> 00:02:38.110
What if one off the driver just goes over with the car,

00:02:38.110 --> 00:02:40.010
not taking to its destination?

00:02:40.010 --> 00:02:40.960
Pretty tough.

00:02:40.960 --> 00:02:43.960
So how do we solve this problem instead?

00:02:43.960 --> 00:02:47.990
Off hiding 10 different drivers and managing 10 different cars,

00:02:47.990 --> 00:02:50.150
it would just hire one truck.

00:02:50.150 --> 00:02:54.650
Let's call this truck as truck D,

00:02:54.650 --> 00:02:58.290
and this truck has a certain capacity.

00:02:58.290 --> 00:03:03.210
Let's say it has a capacity to hold 12 cars,

00:03:03.210 --> 00:03:10.730
and each segment or eat section will be identified with the with an index starting from

00:03:10.730 --> 00:03:11.220
zero.

00:03:11.220 --> 00:03:17.850
So the first section can be accessed with zero index and the second with one that third

00:03:17.850 --> 00:03:18.750
with two.

00:03:18.750 --> 00:03:21.840
The fort with three No.

00:03:21.840 --> 00:03:22.190
One's.

00:03:22.190 --> 00:03:25.250
You learn all the cars into this truck,

00:03:25.250 --> 00:03:27.660
and once it reaches to the destination,

00:03:27.660 --> 00:03:31.750
it can pull a certain car using the index.

00:03:31.750 --> 00:03:32.750
For example,

00:03:32.750 --> 00:03:35.110
if you say T zero,

00:03:35.110 --> 00:03:39.000
that would pull the car inside the segment.

00:03:39.000 --> 00:03:41.590
If you say tea tree,

00:03:41.590 --> 00:03:44.370
that would pull the car in the fourth segment.

00:03:44.370 --> 00:03:48.350
So that's exactly what a race in Jama.

00:03:48.350 --> 00:03:56.380
Let me go a little bit more technical into this when you say in a quartz 10 as I've already

00:03:56.380 --> 00:03:57.030
mentioned,

00:03:57.030 --> 00:04:02.370
this would create a memory size off four bites and store the value off.

00:04:02.370 --> 00:04:05.490
10 in this and this memory location can be accessed.

00:04:05.490 --> 00:04:05.550
Oh,

00:04:05.550 --> 00:04:08.780
but an identifier called a in this case,

00:04:08.780 --> 00:04:15.120
and if you have 10 another image available should clear 10 another memory locations each or

00:04:15.120 --> 00:04:16.010
four bites.

00:04:16.010 --> 00:04:19.050
But whereas if you create an array.

00:04:19.050 --> 00:04:22.540
It would just create one memory location,

00:04:22.540 --> 00:04:24.440
one big chunk off memory location,

00:04:24.440 --> 00:04:26.160
something like this.

00:04:26.160 --> 00:04:32.100
And whatever the science that you specified by creating the array is the number of segments

00:04:32.100 --> 00:04:33.200
it contains.

00:04:33.200 --> 00:04:37.900
And each of this segment convey accessed with an index starting from zero.

00:04:37.900 --> 00:04:38.880
No,

00:04:38.880 --> 00:04:42.750
if you want to pull the value inside one off the index,

00:04:42.750 --> 00:04:43.500
it would access.

00:04:43.500 --> 00:04:44.530
It was in the endings.

00:04:44.530 --> 00:04:47.750
If you want to pull the fourth element you would use in next three.

00:04:47.750 --> 00:04:48.480
No,

00:04:48.480 --> 00:04:53.050
let's play this on our court and let's see how we can solve the problem.

00:04:53.050 --> 00:04:59.300
Let's get it off all the chord in here and start writing a fresh cord.

00:04:59.300 --> 00:05:00.470
Now,

00:05:00.470 --> 00:05:04.820
the way we declare and initialize the variable is.

00:05:04.820 --> 00:05:08.420
But they wouldn't talk about declaration and initialization.

00:05:08.420 --> 00:05:09.750
We will in a while.

00:05:09.750 --> 00:05:13.380
But to declare an initial is a variable,

00:05:13.380 --> 00:05:13.870
we say,

00:05:13.870 --> 00:05:20.350
and Ron equals 10 now to declare an initialize and airy.

00:05:20.350 --> 00:05:22.880
All you would do is tow.

00:05:22.880 --> 00:05:25.100
Add a square bracket here.

00:05:25.100 --> 00:05:26.720
Now we can't give the value.

00:05:26.720 --> 00:05:27.000
10.

00:05:27.000 --> 00:05:33.050
Here we need to use a keyword called New and then the data pipe,

00:05:33.050 --> 00:05:34.160
which in this case,

00:05:34.160 --> 00:05:34.870
it's end.

00:05:34.870 --> 00:05:36.980
And then remember,

00:05:36.980 --> 00:05:38.260
I talked about segments.

00:05:38.260 --> 00:05:40.060
That's what interview here.

00:05:40.060 --> 00:05:43.250
You need to tell Java harmony segments off memory.

00:05:43.250 --> 00:05:44.380
Would you be requiring,

00:05:44.380 --> 00:05:45.620
let's say,

00:05:45.620 --> 00:05:46.150
10.

00:05:46.150 --> 00:05:47.610
No,

00:05:47.610 --> 00:05:50.740
we have an area created.

00:05:50.740 --> 00:05:53.730
We have 10 memory locations created.

00:05:53.730 --> 00:05:58.100
All we need to do is insert values in each one off the segments.

00:05:58.100 --> 00:06:02.660
Often Eri Soto insert a value in the first index.

00:06:02.660 --> 00:06:09.920
What we need to do is you just say wrong at zero Index.

00:06:09.920 --> 00:06:12.930
Let's change the name Ron to something meaningful.

00:06:12.930 --> 00:06:15.350
Let's call it array.

00:06:15.350 --> 00:06:17.350
I mentioned the name here as well.

00:06:17.350 --> 00:06:25.350
A laid off zero index equals 10 array off one equals 20.

00:06:25.350 --> 00:06:27.450
In order to save your time,

00:06:27.450 --> 00:06:30.750
let me just finish all the typing and then I'll get back.

00:06:30.750 --> 00:06:32.980
Okay,

00:06:32.980 --> 00:06:35.950
here we are Now,

00:06:35.950 --> 00:06:41.150
all you would do to find the average salary is this.

00:06:41.150 --> 00:06:45.220
Now,

00:06:45.220 --> 00:06:51.370
please know that you may not be able to understand some of these instructions when record

00:06:51.370 --> 00:06:52.620
the concepts off control,

00:06:52.620 --> 00:06:53.470
statements,

00:06:53.470 --> 00:06:55.100
classes and methods,

00:06:55.100 --> 00:06:57.070
you would better understand dizzy questions.

00:06:57.070 --> 00:07:02.500
We'll definitely be getting back on this example and they'll make you understand.

00:07:02.500 --> 00:07:05.150
But just for the explanations ache,

00:07:05.150 --> 00:07:12.100
what we're doing here is we're just looping through each and every individual item in this

00:07:12.100 --> 00:07:12.520
area,

00:07:12.520 --> 00:07:15.300
and then we are adding each other.

00:07:15.300 --> 00:07:16.760
By the end,

00:07:16.760 --> 00:07:21.350
we're having the some off all the elements.

00:07:21.350 --> 00:07:24.040
And in here,

00:07:24.040 --> 00:07:32.870
what we're doing is we're getting the some divided by the length off binary Going back on

00:07:32.870 --> 00:07:34.450
the problem statement we had,

00:07:34.450 --> 00:07:41.750
we had to count each and every individual variable and tied exact count here.

00:07:41.750 --> 00:07:45.350
But in here you can just say an adat length.

00:07:45.350 --> 00:07:51.420
So this will just take the length off the air rates off in here.

00:07:51.420 --> 00:07:54.250
We're just printing the average.

00:07:54.250 --> 00:07:56.610
Let's try to run the program.

00:07:56.610 --> 00:08:07.690
Cool.

00:08:07.690 --> 00:08:10.050
It displayed the average salary.

00:08:10.050 --> 00:08:17.350
Now the key thing to note here is we give the size as 10.

00:08:17.350 --> 00:08:21.490
If you're just fill Onley five off them,

00:08:21.490 --> 00:08:25.050
we would still be having 10 memory locations.

00:08:25.050 --> 00:08:26.870
So when we do,

00:08:26.870 --> 00:08:27.110
Harry,

00:08:27.110 --> 00:08:33.640
not laying it actually gets the size often every which is stand regardless off number off

00:08:33.640 --> 00:08:35.400
segments that were filled.

00:08:35.400 --> 00:08:41.490
So that's one of the primary disadvantage off using a race,

00:08:41.490 --> 00:08:43.970
you have to know up front,

00:08:43.970 --> 00:08:46.890
the size off the area that you're going to use.

00:08:46.890 --> 00:08:48.270
Otherwise,

00:08:48.270 --> 00:08:50.350
most off the memory will be vested.

00:08:50.350 --> 00:08:57.840
The the point that I want you to take ever from this is that Do we have thousands of

00:08:57.840 --> 00:08:58.730
employees?

00:08:58.730 --> 00:09:01.350
You don't have to type in each and every variable.

00:09:01.350 --> 00:09:02.500
Instead,

00:09:02.500 --> 00:09:05.360
you can just have the similar lines off court.

00:09:05.360 --> 00:09:07.350
But you're do the magic.

00:09:07.350 --> 00:09:11.360
This is just a one simple example off every day.

00:09:11.360 --> 00:09:20.990
But this does not actually explain the real advantage off a raise to know more on a raise.

00:09:20.990 --> 00:09:24.400
We need to call the concepts off classes,

00:09:24.400 --> 00:09:24.930
objects,

00:09:24.930 --> 00:09:31.940
methods also way to go through the control statements to understand better.

00:09:31.940 --> 00:09:33.020
But for now,

00:09:33.020 --> 00:09:34.450
this should suffice.

00:09:34.450 --> 00:09:39.750
Now let's quickly talk about declaration and initialization,

00:09:39.750 --> 00:09:41.160
By the way,

00:09:41.160 --> 00:09:48.350
we can afford the shrink this cord and reduce the number off lines by using calibrates is

00:09:48.350 --> 00:09:57.430
so instead off doing a fixed number off 10 and entering each and every value in this manner

00:09:57.430 --> 00:09:57.430
,

00:09:57.430 --> 00:10:06.670
we can just simply get rid off this and get it off this as ville and simply use curly

00:10:06.670 --> 00:10:15.560
braces and give the numbers or the values separated by coma something like this.

00:10:15.560 --> 00:10:21.150
10 2030 40 50.

00:10:21.150 --> 00:10:23.150
Now the signs off,

00:10:23.150 --> 00:10:26.460
very dependent on number off values that you do here,

00:10:26.460 --> 00:10:29.650
not this statement makes more sense,

00:10:29.650 --> 00:10:32.820
and this would never go wrong.

00:10:32.820 --> 00:10:35.950
Now let's try to run the program again.

00:10:35.950 --> 00:10:47.910
Cool.

00:10:47.910 --> 00:10:49.150
You got the average.

00:10:49.150 --> 00:10:51.150
So it's working.

00:10:51.150 --> 00:10:54.100
Okay,

00:10:54.100 --> 00:10:55.240
now let's see.

00:10:55.240 --> 00:10:57.970
Declaration and initialization.

00:10:57.970 --> 00:11:00.240
As I've already mentioned,

00:11:00.240 --> 00:11:04.340
we have two different types off data types.

00:11:04.340 --> 00:11:05.700
One is primitive,

00:11:05.700 --> 00:11:09.150
other one is non primitive or object time.

00:11:09.150 --> 00:11:11.260
And guess off,

00:11:11.260 --> 00:11:17.160
primitive their time like ent a quotes 10.

00:11:17.160 --> 00:11:20.850
This is the declaration part.

00:11:20.850 --> 00:11:24.780
And if we ascend some value to it,

00:11:24.780 --> 00:11:27.350
that's called initialization.

00:11:27.350 --> 00:11:30.290
So when we say in A,

00:11:30.290 --> 00:11:34.940
we will create a memory location with the A S.

00:11:34.940 --> 00:11:35.640
I didn't differ,

00:11:35.640 --> 00:11:42.010
and we would have a default value of zero regardless off initialization.

00:11:42.010 --> 00:11:47.400
So So even if you don't say equals 10 or something,

00:11:47.400 --> 00:11:50.870
we would still have a memory location created.

00:11:50.870 --> 00:11:54.950
But that's not the case with non criminal data types.

00:11:54.950 --> 00:11:56.680
For example,

00:11:56.680 --> 00:12:06.540
in case off every if you're saying end square brackets array.

00:12:06.540 --> 00:12:12.350
This is just a declaration off area off indigenous.

00:12:12.350 --> 00:12:20.070
This were just tell compiler that we're creating an array off integers undersea use a key.

00:12:20.070 --> 00:12:21.180
What called new?

00:12:21.180 --> 00:12:23.880
No actual memory will be located.

00:12:23.880 --> 00:12:37.670
So you need to say err equals new and off certain size.

00:12:37.670 --> 00:12:44.150
Then this would just create 10 memory locations,

00:12:44.150 --> 00:12:48.950
and each member location would be off size four bites.

00:12:48.950 --> 00:12:52.050
So this part is called decoration,

00:12:52.050 --> 00:12:55.510
and this is called initialization.

00:12:55.510 --> 00:12:56.480
No,

00:12:56.480 --> 00:13:04.240
let's go back to our workbench and see if you other examples now,

00:13:04.240 --> 00:13:05.340
in this example,

00:13:05.340 --> 00:13:09.770
what we're doing is we're just starting all the values ordinary in ascending order.

00:13:09.770 --> 00:13:17.750
So the function the matter by the matter is synonymous to functions in C language and once

00:13:17.750 --> 00:13:25.700
again will talk about methods and classes and more specifically on this operator over here

00:13:25.700 --> 00:13:26.450
the dot.

00:13:26.450 --> 00:13:27.720
But for now,

00:13:27.720 --> 00:13:28.690
just as Jim,

00:13:28.690 --> 00:13:32.050
just think off this as a function in C language,

00:13:32.050 --> 00:13:34.920
and it takes some value and do some process.

00:13:34.920 --> 00:13:36.700
In this Games,

00:13:36.700 --> 00:13:41.120
it just takes every and it sorts all the values in.

00:13:41.120 --> 00:13:46.920
It looks like our listers on the resorted Let's shuffled them a little bit.

00:13:46.920 --> 00:13:47.460
Maybe,

00:13:47.460 --> 00:13:50.400
let's say 40 uh,

00:13:50.400 --> 00:13:54.800
10 or 20 with your 99 here,

00:13:54.800 --> 00:14:00.180
maybe 300.

00:14:00.180 --> 00:14:03.600
Let's save the file and run the program,

00:14:03.600 --> 00:14:10.450
embattled the program and then run it.

00:14:10.450 --> 00:14:12.620
We have about putting talk to order.

00:14:12.620 --> 00:14:13.400
Great.

00:14:13.400 --> 00:14:15.230
Let's take a look at one more example.

00:14:15.230 --> 00:14:25.740
Now,

00:14:25.740 --> 00:14:26.770
in this example,

00:14:26.770 --> 00:14:31.790
we're using BEINA research to find the index off a certain value.

00:14:31.790 --> 00:14:36.960
That's why we wanted to find the index off the value 40.

00:14:36.960 --> 00:14:41.270
The expected result is to,

00:14:41.270 --> 00:14:48.470
since this is the third element that 012 let's try to run the program.

00:14:48.470 --> 00:15:04.740
We got the output that we're expecting now.

00:15:04.740 --> 00:15:05.600
Like I said,

00:15:05.600 --> 00:15:07.460
you may not be able to understand.

00:15:07.460 --> 00:15:11.440
Some of these instructions were definitely be covering all this.

00:15:11.440 --> 00:15:16.700
All these concepts and our I'm sure that I'm going to make you feel comfortable with this.

00:15:16.700 --> 00:15:23.850
The matters like this are all pre defined in Java.

00:15:23.850 --> 00:15:31.600
They come with the standard edition in order to know more on what sort off manipulations

00:15:31.600 --> 00:15:33.070
you can do with their race.

00:15:33.070 --> 00:15:36.050
You can take a look at this link,

00:15:36.050 --> 00:15:45.480
and it's pretty hard and especially time consuming for you to go through each and every

00:15:45.480 --> 00:15:49.370
functions provided by areas I gave you.

00:15:49.370 --> 00:15:56.420
Two examples use those examples to experiment with methods offered by Airy's

