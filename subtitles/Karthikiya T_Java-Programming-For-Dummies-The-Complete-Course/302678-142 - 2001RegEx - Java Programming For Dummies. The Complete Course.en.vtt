WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.500
in this chapter,

00:00:01.500 --> 00:00:06.660
we're just going to talk about a couple of random topics and specifically in this video,

00:00:06.660 --> 00:00:09.150
we're gonna talk about regular expressions.

00:00:09.150 --> 00:00:14.590
Take a look at this example in here we have some random text,

00:00:14.590 --> 00:00:20.610
and what we wanted to accomplish here is that we wanted to replace all the numbers with

00:00:20.610 --> 00:00:21.450
something else.

00:00:21.450 --> 00:00:26.320
One way of accomplishing this task is by using string dot replace method,

00:00:26.320 --> 00:00:32.230
which will let us find a specific number and then we can replace it with something else.

00:00:32.230 --> 00:00:33.720
But the problem is,

00:00:33.720 --> 00:00:38.570
say that you have a text which is spanning across 1000 lanes.

00:00:38.570 --> 00:00:41.640
It's very tedious to use string,

00:00:41.640 --> 00:00:43.950
not repress for each and every individual number.

00:00:43.950 --> 00:00:48.300
So the solution to this problem is regular expression.

00:00:48.300 --> 00:00:56.000
What we have in here is a regular expression that will let us find literally any kind of

00:00:56.000 --> 00:00:58.470
number president in the given text.

00:00:58.470 --> 00:01:01.410
In order to interpret or understand,

00:01:01.410 --> 00:01:06.450
this regular expression went to refer to the documentation off regular expression

00:01:06.450 --> 00:01:07.260
constructs.

00:01:07.260 --> 00:01:08.350
Let's go there,

00:01:08.350 --> 00:01:15.050
goto this link and then you will find the list off regular expression constructs.

00:01:15.050 --> 00:01:18.660
By combining some of these constructs,

00:01:18.660 --> 00:01:21.220
you can construct a regular expression that you wanted.

00:01:21.220 --> 00:01:22.430
In our case,

00:01:22.430 --> 00:01:25.770
we said it slash d And then there's a plus sign.

00:01:25.770 --> 00:01:35.400
If you see it's last demeans any digit but pins it or to nine and the plus sign means one

00:01:35.400 --> 00:01:36.550
or more times.

00:01:36.550 --> 00:01:38.010
So let's go back.

00:01:38.010 --> 00:01:41.670
So we got slash D,

00:01:41.670 --> 00:01:45.050
which means 0 to 9 digits,

00:01:45.050 --> 00:01:50.160
and there can be one or more occurrences off the digits in our text.

00:01:50.160 --> 00:01:53.090
This will be cool into our regular expression.

00:01:53.090 --> 00:01:55.110
This will be Clint,

00:01:55.110 --> 00:01:57.480
and even this will be equal int.

00:01:57.480 --> 00:02:01.900
Now I want to replace all those numbers with this string.

00:02:01.900 --> 00:02:08.440
How in my performing replace I'm going to make use off Patton and Match.

00:02:08.440 --> 00:02:11.550
And that's what I've done in here.

00:02:11.550 --> 00:02:18.330
Have created a patent object by doing patten dot com pile the compartment that will

00:02:18.330 --> 00:02:21.970
actually compel the given regular expression into a Patton.

00:02:21.970 --> 00:02:26.790
And now we can use that pattern object to get the matter object.

00:02:26.790 --> 00:02:29.540
So for their purpose,

00:02:29.540 --> 00:02:34.610
we're going to call this method match er and then we're gonna pass in some text so the

00:02:34.610 --> 00:02:41.210
matter matter will actually match this given text with the regular expression or the

00:02:41.210 --> 00:02:41.750
pattern.

00:02:41.750 --> 00:02:44.990
And once we have the matter object,

00:02:44.990 --> 00:02:47.150
weaken do ability off things with it,

00:02:47.150 --> 00:02:50.750
one of which is the replace all method,

00:02:50.750 --> 00:02:58.640
which will replace all the occurrences off that regular expression in the given text.

00:02:58.640 --> 00:03:03.400
With this string and this string were passing.

00:03:03.400 --> 00:03:05.750
Get towels and argument to this matter.

00:03:05.750 --> 00:03:09.660
Let's on the program and see how the are put looks,

00:03:09.660 --> 00:03:11.850
Peritus.

00:03:11.850 --> 00:03:15.060
All the numbers got replaced.

00:03:15.060 --> 00:03:20.310
But if you notice we also got a number that it mixed with.

00:03:20.310 --> 00:03:26.800
Some characters say that we wanted to only replace the numbers that has the white space

00:03:26.800 --> 00:03:28.380
character on board the sites.

00:03:28.380 --> 00:03:29.670
For that,

00:03:29.670 --> 00:03:31.300
we're going to use one construct,

00:03:31.300 --> 00:03:35.070
which is going to be double slash s.

00:03:35.070 --> 00:03:40.110
Let's have the file and run the program,

00:03:40.110 --> 00:03:48.550
and you would see this getting replaced and nothing else narratives.

00:03:48.550 --> 00:03:55.140
The last one does not have a white space character after it,

00:03:55.140 --> 00:03:58.150
and thats why this is still remained as number,

00:03:58.150 --> 00:04:02.160
but just wanted to show you how you can play around with lyrical expressions.

00:04:02.160 --> 00:04:03.220
Likewise,

00:04:03.220 --> 00:04:05.390
we got another such example,

00:04:05.390 --> 00:04:14.240
and what I'm trying to do here is I'm trying to find a letter which is an uppercase letter

00:04:14.240 --> 00:04:14.240
,

00:04:14.240 --> 00:04:21.220
and that letter have to be between A to Z followed by one or more occurrences of the

00:04:21.220 --> 00:04:22.440
falling characters,

00:04:22.440 --> 00:04:25.970
be it upper case or lower case in our example.

00:04:25.970 --> 00:04:31.100
Random An example are the two words would start with upper castes.

00:04:31.100 --> 00:04:35.530
Let's on the program and hopefully we'll see the string get do place.

00:04:35.530 --> 00:04:35.840
Yeah,

00:04:35.840 --> 00:04:40.720
it is likewise,

00:04:40.720 --> 00:04:44.940
we got many such useful methods in the matter.

00:04:44.940 --> 00:04:45.840
Object in.

00:04:45.840 --> 00:04:49.890
Just explore them by yourself and you can actually go through the description,

00:04:49.890 --> 00:04:52.770
but just hovering the mouse over it.

00:04:52.770 --> 00:04:58.100
Let's take a look at one another example off using medical expression.

00:04:58.100 --> 00:05:04.290
And I would say this is one of the most popular ways the wriggle expression is used is to

00:05:04.290 --> 00:05:09.350
validate an email address to check to see if it is in right form it or not.

00:05:09.350 --> 00:05:14.620
So the magic happens inside this value team L method again.

00:05:14.620 --> 00:05:17.880
We have same pattern and matter objects,

00:05:17.880 --> 00:05:22.100
but this time we got a pretty big regular expression.

00:05:22.100 --> 00:05:23.200
Ultimately,

00:05:23.200 --> 00:05:28.380
what we want to do with this expression is to find out if the given email address is a

00:05:28.380 --> 00:05:30.610
valid email address or not.

00:05:30.610 --> 00:05:34.340
Not this trickle expression will not validate.

00:05:34.340 --> 00:05:40.900
Whether the mail address is existed or not is just going to weld it the format off the

00:05:40.900 --> 00:05:43.590
email address that you provide in here.

00:05:43.590 --> 00:05:46.010
I'm just providing multiple email addresses.

00:05:46.010 --> 00:05:47.370
Some of these are valid.

00:05:47.370 --> 00:05:48.930
Some of these are invalid.

00:05:48.930 --> 00:05:50.290
Let's on the program.

00:05:50.290 --> 00:05:53.770
There you have the output.

00:05:53.770 --> 00:05:56.830
Now you may ask me,

00:05:56.830 --> 00:05:59.850
How did I figure out such a big regular expression?

00:05:59.850 --> 00:06:01.590
The truth is,

00:06:01.590 --> 00:06:03.520
I didn't do it by myself.

00:06:03.520 --> 00:06:05.430
Have social it over Internet,

00:06:05.430 --> 00:06:08.400
and I'm presenting it to you.

00:06:08.400 --> 00:06:11.400
And that's exactly what every dollar produced.

00:06:11.400 --> 00:06:16.870
Why do you want to try to reinvent the wheel when somebody has already done that for you?

00:06:16.870 --> 00:06:19.980
There are a lot of regular expression that you can find on Internet.

00:06:19.980 --> 00:06:21.830
Google Search to be specific.

00:06:21.830 --> 00:06:28.250
And I bet you would find legal expression for most of the popular scenarios.

00:06:28.250 --> 00:06:31.340
That being said this expression,

00:06:31.340 --> 00:06:33.730
all that looks very complaints.

00:06:33.730 --> 00:06:35.730
It's actually very easy to understand.

00:06:35.730 --> 00:06:36.680
Destroyed a map.

00:06:36.680 --> 00:06:41.300
All these individual regular expression constructs with the documentation,

00:06:41.300 --> 00:06:45.150
and you can easily understand what we're doing here.

00:06:45.150 --> 00:06:46.180
All right,

00:06:46.180 --> 00:06:47.800
I guess that's it on this video.

00:06:47.800 --> 00:06:49.350
See you in my next video

