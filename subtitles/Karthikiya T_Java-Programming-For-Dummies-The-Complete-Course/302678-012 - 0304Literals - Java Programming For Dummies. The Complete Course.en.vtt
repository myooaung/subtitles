WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:03.480
in this video will talk about literal zin.

00:00:03.480 --> 00:00:04.050
Java.

00:00:04.050 --> 00:00:09.130
A literal is nothing but their fixed value or a fixed data.

00:00:09.130 --> 00:00:11.450
Take a look at this instruction.

00:00:11.450 --> 00:00:15.630
The data that you see on the right hand side is an indigent,

00:00:15.630 --> 00:00:16.770
literal sense.

00:00:16.770 --> 00:00:18.070
It's an integer value.

00:00:18.070 --> 00:00:19.970
This value can also build.

00:00:19.970 --> 00:00:22.410
Presented in multiple forms.

00:00:22.410 --> 00:00:24.880
This can be in Hexi decimal format.

00:00:24.880 --> 00:00:27.320
This can also be in binary form It.

00:00:27.320 --> 00:00:31.110
Let's take a look at the example off into your liberals.

00:00:31.110 --> 00:00:33.300
Let's go to our workbench.

00:00:33.300 --> 00:00:42.640
Take a look at the following program here.

00:00:42.640 --> 00:00:44.100
The bite,

00:00:44.100 --> 00:00:52.300
short and end holds and integer value and these values or literal can also be the presented

00:00:52.300 --> 00:00:59.070
An exhibit small format with zero x prefix the hex.

00:00:59.070 --> 00:01:04.270
Abysmal number 70 0 is representation off Numerical 2000.

00:01:04.270 --> 00:01:06.080
In the similar fashion,

00:01:06.080 --> 00:01:11.280
you can also represent a number in binary form with zero b perfects.

00:01:11.280 --> 00:01:18.030
This binary number is representation off the number 2000 coming to long.

00:01:18.030 --> 00:01:21.420
You need to upend the letter l in the end,

00:01:21.420 --> 00:01:23.460
so why do we need to do so?

00:01:23.460 --> 00:01:28.970
It's because no matter what integer value that you give here by default,

00:01:28.970 --> 00:01:34.970
Java assumes its data type to be off type and and gets off end.

00:01:34.970 --> 00:01:37.690
The data type is already end,

00:01:37.690 --> 00:01:39.900
so there is no problem.

00:01:39.900 --> 00:01:42.000
But when it comes to bite,

00:01:42.000 --> 00:01:44.340
this is This is an indigent value.

00:01:44.340 --> 00:01:52.520
Java assumes the data type to be off type and but since we give here bite and the value

00:01:52.520 --> 00:02:00.650
that we give here falls in within the range that bite supports Java implicitly convert this

00:02:00.650 --> 00:02:03.850
into type two time bite.

00:02:03.850 --> 00:02:09.040
And we know that bite takes less of memory combat toe integer.

00:02:09.040 --> 00:02:11.750
Same is the case with short.

00:02:11.750 --> 00:02:13.950
But when it comes to long,

00:02:13.950 --> 00:02:18.350
if you give a rally which which is in the range that into supports,

00:02:18.350 --> 00:02:23.710
then job or does not complain even though you tell job but that this is off type long,

00:02:23.710 --> 00:02:25.960
it will just locate four bites off memory.

00:02:25.960 --> 00:02:32.450
But in case if the value exceeds the int there type range,

00:02:32.450 --> 00:02:37.510
then you need to explicitly tell Java that the literal that I'm having here for data type

00:02:37.510 --> 00:02:42.220
long by giving the letter L If you don't give the letter l,

00:02:42.220 --> 00:02:44.580
this would yield a compel ish nearer.

00:02:44.580 --> 00:02:46.430
Alternatively,

00:02:46.430 --> 00:02:52.810
you can go a value which falls in the range off int and now you don't have to give the

00:02:52.810 --> 00:02:55.900
letter L that's perfectly fine.

00:02:55.900 --> 00:02:56.910
So no,

00:02:56.910 --> 00:02:59.650
I hope you understand why we have l here.

00:02:59.650 --> 00:03:06.460
But why does job a default Any integer type while you are in digital type,

00:03:06.460 --> 00:03:08.570
literal to be off type,

00:03:08.570 --> 00:03:11.650
and it's because to save memory,

00:03:11.650 --> 00:03:12.810
for example,

00:03:12.810 --> 00:03:14.760
you're using a long variable,

00:03:14.760 --> 00:03:18.090
which has a value that falls in the range off end.

00:03:18.090 --> 00:03:21.220
Why do we need to locate eight bytes of memory,

00:03:21.220 --> 00:03:25.650
which long takes we can just a locate four bites off memory,

00:03:25.650 --> 00:03:30.750
which infuses so the best counter is to save the memory.

00:03:30.750 --> 00:03:57.780
Let's try to run the program so we have biters 1 20 short as 1000 into your values.

00:03:57.780 --> 00:03:58.650
2000.

00:03:58.650 --> 00:04:03.880
And then we just represented 2000 in Exodus perform it.

00:04:03.880 --> 00:04:05.370
But when we printed,

00:04:05.370 --> 00:04:08.050
it actually printed the numerical.

00:04:08.050 --> 00:04:11.790
Same is the case with Brian Relief Permit.

00:04:11.790 --> 00:04:16.920
Let's experiment a little bit with this long variable.

00:04:16.920 --> 00:04:25.950
Let's try to get rid off this l Let's save the program and the let's compile it once.

00:04:25.950 --> 00:04:27.660
See,

00:04:27.660 --> 00:04:28.790
we have another.

00:04:28.790 --> 00:04:36.170
What says into the number two long so by default job assumes this number to be off type

00:04:36.170 --> 00:04:36.750
hint,

00:04:36.750 --> 00:04:43.790
and it is complaining that that the range exceeded what and that I would support so hands.

00:04:43.790 --> 00:04:45.750
We need to give the letter l here,

00:04:45.750 --> 00:04:47.010
Wood says.

00:04:47.010 --> 00:04:47.940
No,

00:04:47.940 --> 00:04:49.550
I don't want you to as doing this,

00:04:49.550 --> 00:04:50.280
to be off type,

00:04:50.280 --> 00:04:53.580
and I wanted to be off type long.

00:04:53.580 --> 00:04:56.210
Now Job does not give any compassion error,

00:04:56.210 --> 00:05:00.070
but if you give a value which falls in within the range,

00:05:00.070 --> 00:05:05.520
opened the Children program and then let's try to run again this time,

00:05:05.520 --> 00:05:11.150
even though you don't give the letter L it's fine.

00:05:11.150 --> 00:05:19.460
See now Java has just a located.

00:05:19.460 --> 00:05:20.900
Four bites off memory,

00:05:20.900 --> 00:05:22.520
which intakes,

00:05:22.520 --> 00:05:25.050
so this saved some memory.

00:05:25.050 --> 00:05:30.350
Now let's go ahead and take a look at floating point liberals.

00:05:30.350 --> 00:05:45.050
A floating point literal can be represented either in decimal number with a decimal point

00:05:45.050 --> 00:05:53.500
or an exponential form it going back a little bit if you take a look at the stable,

00:05:53.500 --> 00:05:59.650
we have specified the range off both float and double an exponential format.

00:05:59.650 --> 00:06:04.510
This is representation off numerical in a scientific notation,

00:06:04.510 --> 00:06:12.150
and the strange thing here is even the float takes only four bites off memory.

00:06:12.150 --> 00:06:16.890
Since it's representing numbers in exponential format,

00:06:16.890 --> 00:06:22.000
it can even accommodate the maximum value that long supports.

00:06:22.000 --> 00:06:26.630
So even the floor just takes four bytes off memory.

00:06:26.630 --> 00:06:26.940
Were,

00:06:26.940 --> 00:06:27.610
says Long,

00:06:27.610 --> 00:06:29.350
which takes eight bites off memory.

00:06:29.350 --> 00:06:36.760
It can easily accommodate any long value talking about exponential notation and how to

00:06:36.760 --> 00:06:38.310
convert a decimal number.

00:06:38.310 --> 00:06:42.950
Exponential notation is beyond the scope of this tutorial.

00:06:42.950 --> 00:06:46.230
You may want to explore it from other sources,

00:06:46.230 --> 00:06:48.680
but I feel it's really not what,

00:06:48.680 --> 00:06:51.150
knowing he would sell the music,

00:06:51.150 --> 00:06:57.500
know that we need tohave the letter f in case or float.

00:06:57.500 --> 00:06:58.830
Guess why,

00:06:58.830 --> 00:07:03.040
No matter what does move value that ugo here,

00:07:03.040 --> 00:07:07.660
Java as umes this literal to be off type double.

00:07:07.660 --> 00:07:12.090
The reason is to improve the precision.

00:07:12.090 --> 00:07:15.490
When you're dealing with decimal values,

00:07:15.490 --> 00:07:18.030
you need more precision.

00:07:18.030 --> 00:07:19.450
For example,

00:07:19.450 --> 00:07:20.160
if you do,

00:07:20.160 --> 00:07:26.290
if you calculate the value off by which is 22 divided by seven,

00:07:26.290 --> 00:07:33.830
the output that you get might be requiring double the maximum value that float supports may

00:07:33.830 --> 00:07:34.760
not hold it,

00:07:34.760 --> 00:07:40.860
so you need more precision and hence way to have the letter f here.

00:07:40.860 --> 00:07:41.390
Otherwise,

00:07:41.390 --> 00:07:43.740
Java assumes this to be off type double.

00:07:43.740 --> 00:07:59.200
Let's run this program cool.

00:07:59.200 --> 00:08:08.800
We got the float value 12.1 double value 3.1 for the Bull for Doubletree and Exponential

00:08:08.800 --> 00:08:09.290
Value.

00:08:09.290 --> 00:08:12.950
2.147 for 89.

00:08:12.950 --> 00:08:18.900
Now let's take a look at character liberals,

00:08:18.900 --> 00:08:24.750
as we've already seen in our previous examples.

00:08:24.750 --> 00:08:29.150
A character can also be represented in Unicord format,

00:08:29.150 --> 00:08:31.710
so 65 is,

00:08:31.710 --> 00:08:31.870
Ah,

00:08:31.870 --> 00:08:40.510
Unicord for a letter A and so a character literal can have a numerical in a unique or

00:08:40.510 --> 00:08:45.060
format or a letter within a single quotation.

00:08:45.060 --> 00:08:50.200
Or we can also display some escape sequences.

00:08:50.200 --> 00:08:54.750
Slash D Is is a tab button.

00:08:54.750 --> 00:08:57.130
So if you run this,

00:08:57.130 --> 00:09:01.280
if you run this command or if you execute this character,

00:09:01.280 --> 00:09:04.860
it's as good as you pressed Tab Key on your keyboard.

00:09:04.860 --> 00:09:09.050
Let's run this program and see how it goes.

00:09:09.050 --> 00:09:23.080
Cool doubt bodies,

00:09:23.080 --> 00:09:24.050
as expected.

00:09:24.050 --> 00:09:27.470
So the escape sequence of who used here,

00:09:27.470 --> 00:09:28.850
printed at Tab.

00:09:28.850 --> 00:09:31.650
That's the space that you see here.

00:09:31.650 --> 00:09:33.450
It's a damp space.

00:09:33.450 --> 00:09:36.080
Let's take a look at bullying.

00:09:36.080 --> 00:09:36.570
Literal.

00:09:36.570 --> 00:09:45.440
A bullying literal can be either true or faults.

00:09:45.440 --> 00:09:53.910
Let's run this program so you know,

00:09:53.910 --> 00:09:54.630
First Land.

00:09:54.630 --> 00:09:56.650
We're just printing the value.

00:09:56.650 --> 00:10:03.900
True in Second Land were printing the value false coming to third and fourth lines were

00:10:03.900 --> 00:10:05.410
having an expression here.

00:10:05.410 --> 00:10:10.500
His 10 greater than 100 is a true or false.

00:10:10.500 --> 00:10:12.700
It is force.

00:10:12.700 --> 00:10:16.130
So the are put off this expression.

00:10:16.130 --> 00:10:17.960
Is that the true or false?

00:10:17.960 --> 00:10:19.180
It's a bullion value,

00:10:19.180 --> 00:10:22.500
so that's what we have here.

00:10:22.500 --> 00:10:27.430
It's a forms and ease 100 rather than 1000 rather than 10.

00:10:27.430 --> 00:10:28.910
Is this expression true?

00:10:28.910 --> 00:10:29.790
It is true,

00:10:29.790 --> 00:10:31.100
So we got the result.

00:10:31.100 --> 00:10:31.400
True.

00:10:31.400 --> 00:10:32.950
Great.

00:10:32.950 --> 00:10:40.000
Let's quickly take a look at some of the escape sequences that jobless supports in case off

00:10:40.000 --> 00:10:40.460
character.

00:10:40.460 --> 00:10:49.950
Literal Java supports falling character escape sequences slash b for backspace T for tab.

00:10:49.950 --> 00:10:55.200
You can quickly go through each one of these and in experiment with each one off these.

