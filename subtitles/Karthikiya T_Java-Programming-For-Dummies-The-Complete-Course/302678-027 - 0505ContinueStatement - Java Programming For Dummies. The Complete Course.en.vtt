WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.200
in this,

00:00:01.200 --> 00:00:01.460
Really?

00:00:01.460 --> 00:00:04.080
We're gonna talk about the continue statement.

00:00:04.080 --> 00:00:05.330
Um,

00:00:05.330 --> 00:00:06.280
who had already taken?

00:00:06.280 --> 00:00:07.610
Look at the brakes.

00:00:07.610 --> 00:00:08.110
Treatment.

00:00:08.110 --> 00:00:11.670
The brakes treatment will break out of the loop or exit out of the loop.

00:00:11.670 --> 00:00:18.080
But the continue statement will continue with the next iteration skipping the current

00:00:18.080 --> 00:00:18.660
iteration.

00:00:18.660 --> 00:00:25.550
That means it will not let job execute instructions that come afterwards.

00:00:25.550 --> 00:00:26.450
No,

00:00:26.450 --> 00:00:28.090
Let me show you what I mean.

00:00:28.090 --> 00:00:29.450
Take a look at this program.

00:00:29.450 --> 00:00:31.600
We have an array define here.

00:00:31.600 --> 00:00:35.170
We're just looking through all these elements one by one,

00:00:35.170 --> 00:00:39.650
and we're just checking if the number is not divisible by 10.

00:00:39.650 --> 00:00:44.750
If it is not divisible by 10 then we we just want to simply continue.

00:00:44.750 --> 00:00:46.750
That means keep the current iteration,

00:00:46.750 --> 00:00:54.220
and that will result in not executing the instruction that come afterwards in this case is

00:00:54.220 --> 00:00:54.860
just one.

00:00:54.860 --> 00:00:56.750
So by running this program,

00:00:56.750 --> 00:01:02.110
the output would constitute only the numbers that are divisible by 10.

00:01:02.110 --> 00:01:04.150
Let's see how it works.

00:01:04.150 --> 00:01:14.650
Charities.

00:01:14.650 --> 00:01:22.580
Now take a look at this program and try to understand what I've just explained.

00:01:22.580 --> 00:01:28.760
Now,

00:01:28.760 --> 00:01:31.860
let's take a look at another example of continue statement,

00:01:31.860 --> 00:01:33.050
but before that,

00:01:33.050 --> 00:01:38.470
you need to understand what's a prime number Asper definition off a prime number.

00:01:38.470 --> 00:01:43.200
A prime number is a the divisible by one Arbet itself.

00:01:43.200 --> 00:01:46.880
Now we have a logic here that will deter mined.

00:01:46.880 --> 00:01:52.900
If the given value end is a prime or not to explain this better let me pull the white board

00:01:52.900 --> 00:01:52.900
.

00:01:52.900 --> 00:01:56.250
That's what we have a value.

00:01:56.250 --> 00:02:06.970
And seven Now the numbers that come in between 1 to 7 are 234 Why?

00:02:06.970 --> 00:02:12.330
And six If we divide this number,

00:02:12.330 --> 00:02:20.350
end with all these values such that if that results in the reminder off zero,

00:02:20.350 --> 00:02:29.750
that means the number end is not a prime number is to divisible by seven so that it would

00:02:29.750 --> 00:02:31.450
result in the remainder of zero.

00:02:31.450 --> 00:02:32.270
No,

00:02:32.270 --> 00:02:35.420
same is the case with all the other numbers.

00:02:35.420 --> 00:02:38.250
So that means seven is a prime number.

00:02:38.250 --> 00:02:41.310
Let's say we want to take mine.

00:02:41.310 --> 00:02:43.950
In that case,

00:02:43.950 --> 00:02:45.980
mine is divisible by tree,

00:02:45.980 --> 00:02:48.350
so nine is not a prime number.

00:02:48.350 --> 00:02:54.450
Now how do we write this logic programmatically so that we provide a value or a number end

00:02:54.450 --> 00:02:57.550
and the program will deter mine if it's a prime or not?

00:02:57.550 --> 00:03:03.450
I was simply going to use a full look for anti equals two.

00:03:03.450 --> 00:03:07.280
I is less than and I pushed.

00:03:07.280 --> 00:03:07.870
Bless.

00:03:07.870 --> 00:03:13.970
Let's say I have the value has eight.

00:03:13.970 --> 00:03:26.730
So we're gonna look through how many times will look through 23456 seven for a loop through

00:03:26.730 --> 00:03:34.620
this full up six times with each one off these values and in each iteration gonna check to

00:03:34.620 --> 00:03:38.990
see if n person day judge the value.

00:03:38.990 --> 00:03:47.450
I results in zero and we have a block off statements to be executed here.

00:03:47.450 --> 00:03:52.210
If we enter inside this block at least once,

00:03:52.210 --> 00:03:55.550
that means the number and is not a prime number.

00:03:55.550 --> 00:03:58.400
Well,

00:03:58.400 --> 00:03:59.380
if we didn't,

00:03:59.380 --> 00:04:02.840
then that means N is a prime number.

00:04:02.840 --> 00:04:05.650
Now let's go back to our workbench.

00:04:05.650 --> 00:04:09.300
We have more or less the same logic here.

00:04:09.300 --> 00:04:12.650
Just take a minute and go through this This logic.

00:04:12.650 --> 00:04:17.920
Now let's find out if the value end,

00:04:17.920 --> 00:04:20.760
which is 3343 is a prime or not.

00:04:20.760 --> 00:04:22.750
Let's on this program.

00:04:22.750 --> 00:04:29.250
It is indeed a prime number.

00:04:29.250 --> 00:04:32.560
No,

00:04:32.560 --> 00:04:45.610
let's comment or this part an uncommon or actual code that explains they use off.

00:04:45.610 --> 00:04:51.280
Continue statement now in this program.

00:04:51.280 --> 00:04:52.930
What I'm doing is we haven't area,

00:04:52.930 --> 00:04:58.680
and I just wanted to look through all these air elements and find out which one off them

00:04:58.680 --> 00:05:00.450
are the prime numbers.

00:05:00.450 --> 00:05:03.450
So we're gonna use two for loops for this,

00:05:03.450 --> 00:05:04.910
the post for lapis,

00:05:04.910 --> 00:05:06.760
for looping through all these elements.

00:05:06.760 --> 00:05:14.390
And second for loop is to determine if the current number that is in the current iteration

00:05:14.390 --> 00:05:15.700
is a prime number or not.

00:05:15.700 --> 00:05:21.410
So this is essentially the same logic what we have here now,

00:05:21.410 --> 00:05:24.040
in case this condition is meant,

00:05:24.040 --> 00:05:26.090
that means the number is not praying.

00:05:26.090 --> 00:05:29.570
So what we want to do is instead off printing it.

00:05:29.570 --> 00:05:32.090
We're just saying Continue,

00:05:32.090 --> 00:05:34.260
continue outer.

00:05:34.260 --> 00:05:40.910
This is very important because we named this block as outer and we say continue outer is

00:05:40.910 --> 00:05:44.110
just going to skip the current iteration off this four loop,

00:05:44.110 --> 00:05:47.820
and it's going to go ahead with for the right rations.

00:05:47.820 --> 00:05:49.070
So by doing this,

00:05:49.070 --> 00:05:53.440
we're not executing the instructions that come afterwards in this case is just one

00:05:53.440 --> 00:05:55.650
instruction that is to print the number.

00:05:55.650 --> 00:05:58.060
So if we run this program,

00:05:58.060 --> 00:06:05.380
we're gonna see the prime numbers out of this list from the program.

00:06:05.380 --> 00:06:07.780
There it is.

00:06:07.780 --> 00:06:12.990
And just for your information do is also a prime number.

00:06:12.990 --> 00:06:18.350
It's the only even prime number already in our or next week,

00:06:18.350 --> 00:06:23.790
we won't talk about the switch statement that will summarize our chapter on the control

00:06:23.790 --> 00:06:24.550
statements.

