WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:03.465
Given all the disadvantages
but monolithic architecture,

00:00:03.465 --> 00:00:05.430
you may be tempted to think that

00:00:05.430 --> 00:00:08.580
microservices the best
form of architecture.

00:00:08.580 --> 00:00:11.010
That may not be
true all the time.

00:00:11.010 --> 00:00:12.480
There might be instances where

00:00:12.480 --> 00:00:14.790
microservice
architecture may not be

00:00:14.790 --> 00:00:16.680
the best fit Institute wanted to

00:00:16.680 --> 00:00:19.155
go with monolithic architecture.

00:00:19.155 --> 00:00:21.225
Let's talk about some
of the drawbacks

00:00:21.225 --> 00:00:23.265
with microservice architecture.

00:00:23.265 --> 00:00:24.855
But before I do that,

00:00:24.855 --> 00:00:26.700
I want you to pause the video

00:00:26.700 --> 00:00:28.830
and try to make a guess
on at least a couple

00:00:28.830 --> 00:00:30.810
of disadvantageous that you

00:00:30.810 --> 00:00:33.265
find with microservice
architecture.

00:00:33.265 --> 00:00:35.885
Here are some of the
disadvantageous.

00:00:35.885 --> 00:00:37.760
Microservices come with a lot of

00:00:37.760 --> 00:00:40.220
complexity because of
the fact that we're now

00:00:40.220 --> 00:00:45.170
splitting one large application
into small microservices.

00:00:45.170 --> 00:00:47.570
That's going to bring
us a lot of complexity.

00:00:47.570 --> 00:00:50.330
For example, microservices
needs to talk to

00:00:50.330 --> 00:00:53.255
each other in order to
perform a business task.

00:00:53.255 --> 00:00:54.890
How do you manage
that communication

00:00:54.890 --> 00:00:56.570
between microservices?

00:00:56.570 --> 00:00:59.180
How do you manage the
data consistency?

00:00:59.180 --> 00:01:01.430
How do we deal
with transactions?

00:01:01.430 --> 00:01:04.655
How do you ensure that
all the microservices are

00:01:04.655 --> 00:01:07.955
up and running in order
to run your application.

00:01:07.955 --> 00:01:10.865
You have to deal with
such complexities.

00:01:10.865 --> 00:01:13.535
Microservices are
more expensive.

00:01:13.535 --> 00:01:15.890
With microservices,
we're going to have

00:01:15.890 --> 00:01:17.885
a distributed system where

00:01:17.885 --> 00:01:21.229
each microservice would be
hosted on its own container.

00:01:21.229 --> 00:01:23.120
Which also means we need

00:01:23.120 --> 00:01:27.229
additional resources like
RAM, disk space, etc.

00:01:27.229 --> 00:01:29.450
Since microservices
needs to talk

00:01:29.450 --> 00:01:31.430
to each other over a network,

00:01:31.430 --> 00:01:33.875
it's also going to cost
some additional bandwidth.

00:01:33.875 --> 00:01:36.785
Typically in all the
popular Cloud Enrollment,

00:01:36.785 --> 00:01:40.400
you'd be charged on the basis
of resource utilization.

00:01:40.400 --> 00:01:42.110
If you're having a microservice

00:01:42.110 --> 00:01:44.090
application and
you're going to need

00:01:44.090 --> 00:01:46.250
so many resources
that's going to incur

00:01:46.250 --> 00:01:47.690
some additional costs

00:01:47.690 --> 00:01:49.790
compared to monolithic
architecture.

00:01:49.790 --> 00:01:52.220
This is definitely expensive.

00:01:52.220 --> 00:01:55.325
Microservices are
difficult to test.

00:01:55.325 --> 00:01:57.334
If you microservices dependent

00:01:57.334 --> 00:01:59.810
on several other micro-services.

00:01:59.810 --> 00:02:02.090
Before you test
your microservice,

00:02:02.090 --> 00:02:04.790
you have to have the
marked versions of

00:02:04.790 --> 00:02:07.400
other micro-services
that your microservice

00:02:07.400 --> 00:02:09.965
depends on in order to test it.

00:02:09.965 --> 00:02:12.320
Oftentimes, this is not so

00:02:12.320 --> 00:02:15.530
easy because you are
dependent on other teams.

00:02:15.530 --> 00:02:19.325
Other teams have to provide
the mochte microservices,

00:02:19.325 --> 00:02:21.350
which actually
caused and delay in

00:02:21.350 --> 00:02:25.130
testing with monolithic
architecture, however,

00:02:25.130 --> 00:02:27.080
you just deploy
the application in

00:02:27.080 --> 00:02:29.630
one go and you don't
have any issues,

00:02:29.630 --> 00:02:31.805
you can test the
entire application.

00:02:31.805 --> 00:02:34.520
Microservice will need a shift

00:02:34.520 --> 00:02:36.350
in your organization's culture.

00:02:36.350 --> 00:02:37.970
If your organization is used

00:02:37.970 --> 00:02:40.340
to creating monolithic
applications,

00:02:40.340 --> 00:02:43.730
then it's not an easy shift
for an organization to shift

00:02:43.730 --> 00:02:47.255
from monolithic culture
to microservices.

00:02:47.255 --> 00:02:49.310
Because with microservices,

00:02:49.310 --> 00:02:51.470
you're not going to
have one large team.

00:02:51.470 --> 00:02:54.440
Instead, you would need
multiple smaller teams.

00:02:54.440 --> 00:02:57.560
Each will be working on
one or more microservices.

00:02:57.560 --> 00:03:01.460
Also with microservices,
you'd need to have effect to

00:03:01.460 --> 00:03:03.470
coordination between teams in

00:03:03.470 --> 00:03:05.330
order to design the application.

00:03:05.330 --> 00:03:06.740
Otherwise, you may see negative

00:03:06.740 --> 00:03:08.480
consequences down the line.

00:03:08.480 --> 00:03:10.340
Also, microservices
will give you

00:03:10.340 --> 00:03:13.984
the flexibility to use the
technology of your choice.

00:03:13.984 --> 00:03:16.670
Which means multiple
microservices can be

00:03:16.670 --> 00:03:19.670
developed using
multiple technologies.

00:03:19.670 --> 00:03:22.550
You have to have those
tools and process in

00:03:22.550 --> 00:03:26.090
place in order to handle
various different technologies.

00:03:26.090 --> 00:03:28.625
It's easier said than done.

00:03:28.625 --> 00:03:31.370
It's very difficult
to debug if you're

00:03:31.370 --> 00:03:34.205
a tester and if you
were to report a bug,

00:03:34.205 --> 00:03:37.640
you'd have to provide as much
information as possible.

00:03:37.640 --> 00:03:39.830
With monolithic architecture.

00:03:39.830 --> 00:03:41.360
You can easily
find the source of

00:03:41.360 --> 00:03:43.340
the issue by going
through the logs.

00:03:43.340 --> 00:03:45.575
But when it comes
to microservices,

00:03:45.575 --> 00:03:47.675
it's not so straightforward.

00:03:47.675 --> 00:03:49.430
You never know if
the bug is due to

00:03:49.430 --> 00:03:51.890
the microservice you
are testing or is it

00:03:51.890 --> 00:03:53.480
because of the
wrong data received

00:03:53.480 --> 00:03:56.580
from other dependent
microservices?

00:03:56.580 --> 00:03:58.840
So these are some of
the disadvantages

00:03:58.840 --> 00:04:00.760
with microservice architecture.

00:04:00.760 --> 00:04:02.800
So to summarize,
if you're creating

00:04:02.800 --> 00:04:06.400
a very simple application
with very limited features,

00:04:06.400 --> 00:04:09.550
then microservice
architecture is an overkill.

00:04:09.550 --> 00:04:12.325
You may want to go with
monolithic architecture.

00:04:12.325 --> 00:04:14.260
Appear application
however, is very

00:04:14.260 --> 00:04:17.785
complex and has lots of
business functionalities,

00:04:17.785 --> 00:04:21.640
then the microservices may
be a better option for you.

00:04:21.640 --> 00:04:23.020
But even if you know that

00:04:23.020 --> 00:04:25.270
your application is
going to get complex,

00:04:25.270 --> 00:04:28.540
it's always better to start
with monolithic architecture.

00:04:28.540 --> 00:04:31.660
And as the complexity of
your application grows,

00:04:31.660 --> 00:04:34.780
based on the demands
and your capabilities,

00:04:34.780 --> 00:04:38.870
you'd want to switch to
microservices architecture.
