WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.595
So what's a microservice
architecture?

00:00:02.595 --> 00:00:05.025
Well, here's the
official definition.

00:00:05.025 --> 00:00:07.905
Microservices is an
architectural style

00:00:07.905 --> 00:00:09.570
that structures and application

00:00:09.570 --> 00:00:11.715
as a collection of services

00:00:11.715 --> 00:00:14.130
that are highly
maintainable and testable,

00:00:14.130 --> 00:00:17.280
loosely-coupled,
independently deployable,

00:00:17.280 --> 00:00:19.710
organized around
business capabilities

00:00:19.710 --> 00:00:21.705
owned by a small team.

00:00:21.705 --> 00:00:23.310
Obviously, this may not make

00:00:23.310 --> 00:00:24.900
complete sense at this point.

00:00:24.900 --> 00:00:26.850
So let's get into details.

00:00:26.850 --> 00:00:28.200
At a real-world example of

00:00:28.200 --> 00:00:31.320
microservices could be a train.

00:00:31.320 --> 00:00:34.140
Unlike an airplane,
all the modules

00:00:34.140 --> 00:00:36.940
here would be independent
of each other.

00:00:36.940 --> 00:00:38.960
For example, a try
and could have

00:00:38.960 --> 00:00:41.750
all these modules
are compartments.

00:00:41.750 --> 00:00:43.280
You could have engine,

00:00:43.280 --> 00:00:45.935
load carrier that
would carry load

00:00:45.935 --> 00:00:49.040
like coal or cement, etc.

00:00:49.040 --> 00:00:51.200
It could have crew compartment,

00:00:51.200 --> 00:00:52.940
That's where people would sit.

00:00:52.940 --> 00:00:54.950
And then you can
also have a good

00:00:54.950 --> 00:00:57.695
scarier to carry all the goods.

00:00:57.695 --> 00:01:01.100
And they can also be a common
module like wheelbase.

00:01:01.100 --> 00:01:03.245
The good thing about this is

00:01:03.245 --> 00:01:06.410
if something goes wrong with
one of the compartments,

00:01:06.410 --> 00:01:09.889
that something got
damaged in goods carrier,

00:01:09.889 --> 00:01:12.920
it doesn't cause the
entire trained to stop,

00:01:12.920 --> 00:01:15.500
try and can still
move on regardless

00:01:15.500 --> 00:01:18.890
of if there is any problem
in one compartment or not.

00:01:18.890 --> 00:01:22.445
Also, if you want to
fix one compartment,

00:01:22.445 --> 00:01:24.680
then you don't have to
test the entire train.

00:01:24.680 --> 00:01:26.870
You can just test that
particular compartment

00:01:26.870 --> 00:01:29.225
alone and you're good to go.

00:01:29.225 --> 00:01:31.295
Thereby you will
save a lot of time.

00:01:31.295 --> 00:01:34.490
And therefore, scalability
is not an issue.

00:01:34.490 --> 00:01:37.025
If you were to
accommodate more people,

00:01:37.025 --> 00:01:40.370
you just have to add one
additional crew compartment.

00:01:40.370 --> 00:01:43.640
You don't have to create a
duplicate of the entire train.

00:01:43.640 --> 00:01:46.490
And that's going to
save a lot of costs.

00:01:46.490 --> 00:01:49.430
Earlier with monolithic
architecture,

00:01:49.430 --> 00:01:52.280
we had one project
with multiple modules.

00:01:52.280 --> 00:01:54.890
And all these modules
could be deployed

00:01:54.890 --> 00:01:57.875
as a single application
onto the remote server.

00:01:57.875 --> 00:02:00.980
And that's where we have
all those major problems.

00:02:00.980 --> 00:02:02.720
So with microservices,

00:02:02.720 --> 00:02:04.940
instead of having
one single project,

00:02:04.940 --> 00:02:06.830
having multiple modules,

00:02:06.830 --> 00:02:09.170
we're going to have
multiple projects,

00:02:09.170 --> 00:02:12.575
each with one module
or one business task.

00:02:12.575 --> 00:02:13.790
And instead of having

00:02:13.790 --> 00:02:16.910
one large team working
on a single project,

00:02:16.910 --> 00:02:19.355
we're going to have small teams.

00:02:19.355 --> 00:02:21.860
It would work on
individual projects.

00:02:21.860 --> 00:02:24.230
The resulting architecture would

00:02:24.230 --> 00:02:25.835
look something like this.

00:02:25.835 --> 00:02:28.475
We have a project
for order service.

00:02:28.475 --> 00:02:31.430
You also have another
project for admin service,

00:02:31.430 --> 00:02:33.005
so on and so forth.

00:02:33.005 --> 00:02:35.930
Instead of deploying
the entire application

00:02:35.930 --> 00:02:37.220
into a single server,

00:02:37.220 --> 00:02:39.590
we would instead deploy
each one of them

00:02:39.590 --> 00:02:42.860
independently on their
respect to servers.

00:02:42.860 --> 00:02:46.490
This comes along with
their own database.

00:02:46.490 --> 00:02:48.800
And this architecture would
pretty much eliminate

00:02:48.800 --> 00:02:52.355
all the disadvantages with
monolithic architecture.

00:02:52.355 --> 00:02:54.050
For example, if you were to make

00:02:54.050 --> 00:02:55.910
changes in one of the modules,

00:02:55.910 --> 00:02:58.370
you don't have to test
the entire application.

00:02:58.370 --> 00:03:00.140
You can just test
that particular

00:03:00.140 --> 00:03:02.345
module and you're good to go.

00:03:02.345 --> 00:03:06.080
Similarly, if there is some
bug in one of the module,

00:03:06.080 --> 00:03:09.155
it doesn't cause the entire
application to crash.

00:03:09.155 --> 00:03:12.350
Only that particular module
will have an impact.

00:03:12.350 --> 00:03:13.970
For instance, if there is

00:03:13.970 --> 00:03:16.565
a bug in product recommendation,

00:03:16.565 --> 00:03:19.190
Your enter website
would still be fine.

00:03:19.190 --> 00:03:22.685
Only product recommendation
feature wouldn't be working.

00:03:22.685 --> 00:03:25.085
Even scalability
is not an issue.

00:03:25.085 --> 00:03:27.860
If you're running sales on
your e-commerce website,

00:03:27.860 --> 00:03:30.770
then you can just scale
the order service.

00:03:30.770 --> 00:03:32.300
Maybe you want to
create multiple

00:03:32.300 --> 00:03:34.024
instances of the silver.

00:03:34.024 --> 00:03:36.545
You don't have to
create instances of

00:03:36.545 --> 00:03:40.100
other modules which
doesn't need to be scaled.

00:03:40.100 --> 00:03:42.170
So that's another advantage

00:03:42.170 --> 00:03:43.955
with microservice architecture.

00:03:43.955 --> 00:03:46.520
Similarly, because
of the fact that

00:03:46.520 --> 00:03:47.600
these modules are not

00:03:47.600 --> 00:03:50.195
dependent or tightly
coupled to each other,

00:03:50.195 --> 00:03:51.845
you will have the flexibility

00:03:51.845 --> 00:03:53.825
to choose the technology
of your choice.

00:03:53.825 --> 00:03:55.220
For each module.

00:03:55.220 --> 00:03:56.780
You could use a language like

00:03:56.780 --> 00:03:59.000
Scala for product
recommendation.

00:03:59.000 --> 00:04:01.880
And you can have another
module developed in

00:04:01.880 --> 00:04:05.000
another language or a different
technology altogether,

00:04:05.000 --> 00:04:06.964
maybe PHP or whatever.

00:04:06.964 --> 00:04:10.775
You could also have another
module in Java or whatever.

00:04:10.775 --> 00:04:12.770
You have that flexibility.

00:04:12.770 --> 00:04:15.620
Because all these
applications or

00:04:15.620 --> 00:04:20.315
microservices deployed
independently on their own silver,

00:04:20.315 --> 00:04:22.775
they're not dependent
on each other.

00:04:22.775 --> 00:04:26.465
That being said, they all need
to communicate each other.

00:04:26.465 --> 00:04:28.745
And that's possible with

00:04:28.745 --> 00:04:32.435
the API that each of these
modules would expose.

00:04:32.435 --> 00:04:35.690
For example, if you want to
fetch the number of products

00:04:35.690 --> 00:04:39.484
available and show it
on the admin console.

00:04:39.484 --> 00:04:42.335
The admin service module
might want to make

00:04:42.335 --> 00:04:44.420
a rest API call or

00:04:44.420 --> 00:04:47.180
send HTTP requests to
the product service.

00:04:47.180 --> 00:04:49.100
And then the product
service will

00:04:49.100 --> 00:04:51.605
respond back with some data,

00:04:51.605 --> 00:04:53.825
typically in JSON format,

00:04:53.825 --> 00:04:58.790
and render it to the
admin or whatever.

00:04:58.790 --> 00:05:02.285
And this will also reduce the
complexity of the database.

00:05:02.285 --> 00:05:05.090
The admin service
doesn't need to actually

00:05:05.090 --> 00:05:08.255
find a query to the
product service database.

00:05:08.255 --> 00:05:09.920
It would just send a request to

00:05:09.920 --> 00:05:13.100
the API and receive
some response.

00:05:13.100 --> 00:05:15.110
What's a microservice here?

00:05:15.110 --> 00:05:18.650
All these independent
modules that take care of

00:05:18.650 --> 00:05:22.430
individual business tasks are
nothing but microservices.

00:05:22.430 --> 00:05:24.635
And what we're following

00:05:24.635 --> 00:05:27.560
here is microservice
architecture.

00:05:27.560 --> 00:05:30.530
And more I also need
to mention is that

00:05:30.530 --> 00:05:33.755
this is the basic architecture
of microservices.

00:05:33.755 --> 00:05:36.875
For example, we don't
have API gateways

00:05:36.875 --> 00:05:40.565
or load balancer or
naming servers, etc.

00:05:40.565 --> 00:05:43.805
They all would come in
in future lectures.

00:05:43.805 --> 00:05:46.100
For now, I really
hope that you got

00:05:46.100 --> 00:05:49.040
a sense of what is a
microservice architecture.

00:05:49.040 --> 00:05:54.635
What's a microservice and
the significance of it, etc.

00:05:54.635 --> 00:05:58.730
Now this definition should
make complete sense to you.

00:05:58.730 --> 00:06:01.865
Microservices is an
architectural style,

00:06:01.865 --> 00:06:04.910
structures and application
as a collection of

00:06:04.910 --> 00:06:09.140
services that are highly
maintainable and testable.

00:06:09.140 --> 00:06:13.160
They are loosely coupled,
independently deployable,

00:06:13.160 --> 00:06:16.085
organised around
business capabilities,

00:06:16.085 --> 00:06:19.560
and owned by a small team.
