WEBVTT
1
00:00:07.710 --> 00:00:13.290
Python strings have more than 30 built in methods that allow us to manipulate and parse them.

2
00:00:13.290 --> 00:00:18.180
In this section, we are going to learn about some of the most important ones, and we will start this

3
00:00:18.180 --> 00:00:20.790
lecture by learning about the index method.

4
00:00:21.150 --> 00:00:28.080
As you know, a string is a sequence of characters and each character has an ordered position within

5
00:00:28.080 --> 00:00:28.950
that sequence.

6
00:00:28.950 --> 00:00:35.640
If we take the example hello, the letter H occupies index zero.

7
00:00:36.090 --> 00:00:44.460
Python always starts an index at position zero, so always pay attention to this when counting e occupies

8
00:00:44.460 --> 00:00:54.990
index one L occupies index to the second L occupies index three and zero occupies index for empty spaces

9
00:00:54.990 --> 00:00:58.230
and punctuation marks also occupy a place in the sequence.

10
00:00:58.230 --> 00:01:05.940
So if we had a string say hello world it would look like this and there is more in Python.

11
00:01:05.940 --> 00:01:12.450
We can also identify the position of a character using the reverse index, which also starts at zero

12
00:01:12.450 --> 00:01:19.260
for the first character, but then starts from the right side with the negative one index and works

13
00:01:19.260 --> 00:01:22.740
its way down to meet to zero on the left.

14
00:01:22.740 --> 00:01:25.080
And this is where the index method comes in.

15
00:01:25.080 --> 00:01:28.140
It will help us know two things.

16
00:01:28.140 --> 00:01:33.000
On one hand, knowing in which position a certain character is located.

17
00:01:33.390 --> 00:01:38.880
Let's suppose I have the variable my text which contains the string.

18
00:01:38.910 --> 00:01:39.960
Hello.

19
00:01:39.960 --> 00:01:43.500
And I want to know in which position the letter E is.

20
00:01:43.590 --> 00:01:48.000
In this case we tell python that in variable my text.

21
00:01:48.000 --> 00:01:50.790
I want to know the index of the character.

22
00:01:50.790 --> 00:01:51.290
E.

23
00:01:51.690 --> 00:01:57.720
If I write in this way, Python will tell me that the E is at index one.

24
00:01:57.870 --> 00:02:03.930
On the other hand, if I want to know which character is at a certain position, this is even easier

25
00:02:03.930 --> 00:02:04.440
to write.

26
00:02:04.620 --> 00:02:06.750
Just write the variable name.

27
00:02:06.900 --> 00:02:11.550
And between square braces, the index of interest.

28
00:02:12.000 --> 00:02:17.370
In this case Python will tell me the letter O is the one that resides there.

29
00:02:17.370 --> 00:02:22.200
There are many more details to learn about index, but let's see them in pi term.

30
00:02:22.650 --> 00:02:25.020
Let's see how the index behaves in pi charm.

31
00:02:25.470 --> 00:02:28.590
And for that I've already created a folder here called Day three.

32
00:02:29.190 --> 00:02:34.500
We're going to inaugurate this day's lectures with a file called Index, which is what we're going to

33
00:02:34.500 --> 00:02:35.760
start working on right now.

34
00:02:35.760 --> 00:02:39.540
And we're going to start by creating a variable called my text.

35
00:02:40.500 --> 00:02:44.610
This is a variable that is going to contain the string that we're going to work with throughout this

36
00:02:44.610 --> 00:02:45.090
lecture.

37
00:02:45.660 --> 00:02:49.170
We're going to make a string that says this text is a.

38
00:02:50.950 --> 00:02:56.290
I'm going to create another variable called result and which I'm going to do my tests with the index

39
00:02:56.290 --> 00:02:56.920
method.

40
00:02:57.010 --> 00:03:02.470
We're going to make result to be equal to the variable, my text and we're going to open the square

41
00:03:02.470 --> 00:03:05.290
brackets to put the index zero here.

42
00:03:05.530 --> 00:03:09.370
This means that I want result to store the value of what there is in the index.

43
00:03:09.370 --> 00:03:10.780
Zero of the variable.

44
00:03:10.780 --> 00:03:11.800
My text.

45
00:03:11.830 --> 00:03:14.500
Let's try to guess what we will get before executing it.

46
00:03:14.890 --> 00:03:17.640
Remember that we start counting from index zero.

47
00:03:17.650 --> 00:03:20.830
So in the string the text is a test.

48
00:03:20.860 --> 00:03:25.090
The capital letter t is the one we should find in the index.

49
00:03:25.090 --> 00:03:25.720
Zero.

50
00:03:26.050 --> 00:03:28.450
Let's print it out so we can say on the console.

51
00:03:28.960 --> 00:03:31.060
And what we're going to print here is result.

52
00:03:31.780 --> 00:03:33.100
All right, let's run it.

53
00:03:33.850 --> 00:03:35.440
And here we have exactly the result.

54
00:03:35.440 --> 00:03:38.380
We expected the letter capital t.

55
00:03:38.710 --> 00:03:41.680
Let's keep trying different alternatives to see how this works.

56
00:03:41.890 --> 00:03:46.120
If I, for example, want to print whatever is in index seven.

57
00:03:46.900 --> 00:03:47.910
You do your math.

58
00:03:48.420 --> 00:03:53.610
I'm going to run it to discover that the x this x here is the one at index seven.

59
00:03:53.700 --> 00:04:00.720
Let's count together zero one, two, three, four, five, six and seven.

60
00:04:00.840 --> 00:04:01.650
That's correct.

61
00:04:01.920 --> 00:04:04.230
Let's also try doing it with negative numbers.

62
00:04:04.440 --> 00:04:07.630
We said that we can put a negative number like minus three.

63
00:04:07.650 --> 00:04:09.990
And Python will count from left to right.

64
00:04:10.320 --> 00:04:17.190
Remember, zero is always going to be the first index, but then minus one, minus two and minus three.

65
00:04:17.460 --> 00:04:23.340
Here, it should give us the letter E, and indeed we have the letter E with the minus three.

66
00:04:23.610 --> 00:04:29.580
This is how you get the character that inhabits a certain index that you can decide to query.

67
00:04:30.220 --> 00:04:31.750
But now let's do the opposite.

68
00:04:32.050 --> 00:04:37.430
We're going to say what is in the character we've found, and we want to know what index it is in.

69
00:04:37.450 --> 00:04:41.890
For that, we're going to say that the result is equal to my text.

70
00:04:41.980 --> 00:04:45.940
And this time we're going to add here a method that belongs to all strings.

71
00:04:45.940 --> 00:04:51.010
And since my text is a variable that contains a string, it has all the string method.

72
00:04:51.900 --> 00:04:56.910
Simply put a dot here and observe that pie chart displays a whole list with all the methods that we

73
00:04:56.910 --> 00:04:58.350
dispose for our strings.

74
00:04:58.530 --> 00:05:03.600
This circle with an m means that it is a method, and here is index.

75
00:05:03.870 --> 00:05:06.090
This is the method we're interested in.

76
00:05:06.090 --> 00:05:07.470
So we're going to accept.

77
00:05:07.470 --> 00:05:13.860
Here we get this contextual window that gives us some help that says that this method has three possible

78
00:05:13.860 --> 00:05:14.740
parameters.

79
00:05:14.760 --> 00:05:20.100
The first one is a substring, which would be the character or the word that we are going to look for.

80
00:05:20.280 --> 00:05:25.890
Then we have two optional parameters, which is from where and to where we want to search, but we're

81
00:05:25.890 --> 00:05:27.240
going to look at that later.

82
00:05:27.330 --> 00:05:30.750
Now, let's just look at the first parameter, which is the substring.

83
00:05:30.960 --> 00:05:34.620
We're going to start by looking for the letter H in quotes.

84
00:05:34.800 --> 00:05:40.620
We have a letter H here in this text is a test, and if we run it, it's going to tell us that it's

85
00:05:40.620 --> 00:05:42.300
at index number one.

86
00:05:42.300 --> 00:05:43.380
And that's correct.

87
00:05:43.590 --> 00:05:46.470
The T is zero and H is one.

88
00:05:46.740 --> 00:05:50.100
But what happens if we look for a letter that doesn't exist in our string?

89
00:05:50.700 --> 00:05:52.680
Let's try it with A with a Q.

90
00:05:52.830 --> 00:05:55.230
We execute it and it throws an exception.

91
00:05:55.260 --> 00:05:57.510
It tells us that we have a value error.

92
00:05:58.110 --> 00:05:59.640
That's the type of our error.

93
00:05:59.820 --> 00:06:00.780
A value error.

94
00:06:00.810 --> 00:06:02.670
The substring was not found.

95
00:06:03.030 --> 00:06:04.770
Let's also search for whole words.

96
00:06:04.770 --> 00:06:11.370
If I search for the word text, it tells me that text does exist and that this substring starts at index

97
00:06:11.370 --> 00:06:16.440
five, which is the one corresponding to the first t of text.

98
00:06:16.740 --> 00:06:22.590
It doesn't give us the index of each of the letters of text, but only the one where the substring starts.

99
00:06:23.010 --> 00:06:26.580
And of course, if we were to write it wrong, let's write text.

100
00:06:27.120 --> 00:06:29.400
It will throw the same exception as before.

101
00:06:30.150 --> 00:06:32.400
Also the index is case sensitive.

102
00:06:32.580 --> 00:06:38.820
So if I search for h, but this time as a capital letter which does not exist in our string, it will

103
00:06:38.820 --> 00:06:40.080
also give me the same error.

104
00:06:40.880 --> 00:06:45.350
Now let's search for a letter that is repeated several times, such as S, for example.

105
00:06:45.980 --> 00:06:47.870
What happens if I search for S?

106
00:06:48.470 --> 00:06:50.240
Well, the result will be three.

107
00:06:50.270 --> 00:06:55.910
This means that it has told me where the first SE was found because it did the search from left to right.

108
00:06:55.910 --> 00:07:02.750
And once it found an S it stopped there and can no longer know if there is still other S's ahead.

109
00:07:03.020 --> 00:07:07.670
This is a feature of index that only searches from left to right and stops when it finds the the first

110
00:07:07.670 --> 00:07:08.330
result.

111
00:07:08.480 --> 00:07:13.850
But we also have, as I showed you before, other parameters for index that can help us a little with

112
00:07:13.850 --> 00:07:14.330
this.

113
00:07:14.780 --> 00:07:19.880
If I put a comma after the substring parameter, I can add an index from where it is going to start

114
00:07:19.880 --> 00:07:20.600
searching.

115
00:07:20.720 --> 00:07:24.140
So let's say I search from index five and execute.

116
00:07:24.530 --> 00:07:27.320
Now it tells me that s is an index 11.

117
00:07:28.130 --> 00:07:29.090
And why is that?

118
00:07:29.270 --> 00:07:32.410
Because it didn't include the first one, which is at the index three.

119
00:07:32.420 --> 00:07:37.070
It skipped it because it started counting from index five, which is this letter T.

120
00:07:37.190 --> 00:07:40.820
So five, six, seven, eight, nine, ten, 11.

121
00:07:41.680 --> 00:07:43.510
This is the sgh that returns.

122
00:07:44.110 --> 00:07:47.500
We also have the possibility to say how far we want the search to go.

123
00:07:47.590 --> 00:07:53.590
So if I add a comma here and I add that third parameter, I want to search up the character number 11.

124
00:07:54.490 --> 00:07:59.650
Well, now it gives me an error because although there are three SW letters in my string, I asked it

125
00:07:59.650 --> 00:08:06.200
to search from five, which is this t up to 11, which we know is precisely this letter s.

126
00:08:06.220 --> 00:08:08.360
But here we have a learning curve.

127
00:08:08.380 --> 00:08:09.850
It is not inclusive.

128
00:08:10.030 --> 00:08:15.250
That is the number you choose as the third parameter to indicate how far you want to go with the search.

129
00:08:15.490 --> 00:08:17.050
It will not be included.

130
00:08:17.200 --> 00:08:19.900
So keep this in mind when you build your searches.

131
00:08:19.960 --> 00:08:24.340
In our case, in this range, from here to here, there is no SW and that's why it returned an error.

132
00:08:24.460 --> 00:08:28.750
Now let's delete our index method because I want to show you another alternative, which is actually

133
00:08:28.750 --> 00:08:32.120
a different method, but it is very similar to index.

134
00:08:32.140 --> 00:08:37.510
So let's put the dot here one more time and notice that we have the index method.

135
00:08:37.870 --> 00:08:41.200
It's very similar, but the difference is that it searches backwards.

136
00:08:41.500 --> 00:08:44.200
That is, it searches from right to left.

137
00:08:44.440 --> 00:08:50.800
So if I put the letter S here, what it will do is it will search from right to left and it will return

138
00:08:50.800 --> 00:08:58.150
17, which is this s the first one it found and it returns it with the index that goes from left to

139
00:08:58.150 --> 00:09:01.270
right, not to the index that would give me minus one.

140
00:09:01.730 --> 00:09:02.100
Okay.

141
00:09:02.110 --> 00:09:05.020
So this is an alternative to doing searches with index.

142
00:09:05.620 --> 00:09:07.500
And that's about all for the index method.

143
00:09:07.510 --> 00:09:10.260
So let's keep going now because the day is just beginning.

144
00:09:10.270 --> 00:09:11.680
I'll see you in the next lecture.
