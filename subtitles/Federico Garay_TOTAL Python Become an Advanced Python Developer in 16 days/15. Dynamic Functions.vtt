WEBVTT
1
00:00:08.150 --> 00:00:11.430
We already have the basic structure of a function.

2
00:00:11.450 --> 00:00:18.200
Now we are going to start to scale the complexity so that we can see the possibilities that this tool

3
00:00:18.200 --> 00:00:18.860
offers us.

4
00:00:18.860 --> 00:00:23.990
In this lecture, we are going to relate functions in other Python tools, such as loops or control

5
00:00:23.990 --> 00:00:29.660
flow, so that we can incorporate a more dynamic and complex code within the functions.

6
00:00:29.870 --> 00:00:33.560
This will allow us to solve different types of situations and problems.

7
00:00:33.560 --> 00:00:40.010
For example, can I create a function that not only receives a number as a parameter, but a list of

8
00:00:40.010 --> 00:00:43.430
numbers and passes through each of its elements?

9
00:00:43.460 --> 00:00:46.550
Let's jump to the black screen to see this in action.

10
00:00:47.000 --> 00:00:51.520
And what we're going to do is go scaling in complexity from simple to complex.

11
00:00:51.530 --> 00:00:54.770
So let's begin with something that some way we have already seen.

12
00:00:55.160 --> 00:00:57.890
We're going to create a function that is in charge of checking.

13
00:00:57.890 --> 00:01:03.680
If a certain number has three digits, then this is how we're going to call our function check three

14
00:01:03.680 --> 00:01:04.400
digits.

15
00:01:04.610 --> 00:01:10.310
And in the parameters, we're going to pass a variable called number because we need to pass a number

16
00:01:10.310 --> 00:01:11.570
when we invoke it.

17
00:01:11.570 --> 00:01:15.110
And what the function does is to submit it to review process.

18
00:01:15.710 --> 00:01:18.800
It is going to be a very simple process, actually.

19
00:01:18.800 --> 00:01:22.730
We're going to set it inside the return because it's going to return an answer.

20
00:01:23.060 --> 00:01:29.210
This answer is going to tell us if number is in a range that goes between 100.

21
00:01:29.210 --> 00:01:35.210
That is the smallest possible number with three digits and 1000 since 1000 itself is not included.

22
00:01:35.210 --> 00:01:37.730
It will check until 999.

23
00:01:38.450 --> 00:01:43.730
If our number is in that range, then the answer will be true and the return will give us that information.

24
00:01:43.970 --> 00:01:48.470
Remember that when we check within we're doing a boolean comparison.

25
00:01:48.470 --> 00:01:51.590
So the answer it can only be true or false.

26
00:01:52.490 --> 00:01:54.230
Then we exit the function.

27
00:01:54.710 --> 00:01:56.230
Okay, we have our function.

28
00:01:56.240 --> 00:02:01.550
Now we're going to create a variable that is called result in which we're going to store the invocation

29
00:02:01.550 --> 00:02:09.500
of check three digits and we're going to pass some number like 658, a number that does have three digits.

30
00:02:09.500 --> 00:02:11.090
So the answer should be true.

31
00:02:11.420 --> 00:02:15.500
So we're going to print the result so that we can corroborate it on the screen.

32
00:02:15.920 --> 00:02:17.510
Well, let's run it.

33
00:02:17.780 --> 00:02:19.940
There's not going to be any surprises here.

34
00:02:20.480 --> 00:02:21.320
Exactly.

35
00:02:21.320 --> 00:02:22.040
True.

36
00:02:22.610 --> 00:02:28.070
And if we had a two digit number, let's say 68, it would have told us that it was false because that

37
00:02:28.070 --> 00:02:31.850
would be the value that return would have had when we ran this check.

38
00:02:32.090 --> 00:02:33.500
So far, so good.

39
00:02:33.740 --> 00:02:35.240
Let me introduce some complexity.

40
00:02:35.240 --> 00:02:38.990
Now, instead of passing a number, we can pass here a variable.

41
00:02:38.990 --> 00:02:40.490
For example, some.

42
00:02:40.760 --> 00:02:47.060
Let's say that sum is equal to the sum of two values 526 and 311.

43
00:02:47.540 --> 00:02:52.040
And now we do not have here the result of the sum, but we can still pass sum here.

44
00:02:52.040 --> 00:02:58.040
So the verifies, if the result is a three digit number and yes, it is because it does not reach 1000.

45
00:02:58.040 --> 00:03:00.980
So also you can pass variables.

46
00:03:01.750 --> 00:03:05.470
So let me delete this and let's see one more level of complexity.

47
00:03:06.220 --> 00:03:09.490
I want my function check three digits to do the same.

48
00:03:09.490 --> 00:03:10.300
It actually does.

49
00:03:10.300 --> 00:03:16.540
But instead of checking a single number to check all the numbers from a list and returns true if at

50
00:03:16.540 --> 00:03:18.970
least one of those numbers has three digits.

51
00:03:19.220 --> 00:03:21.400
Okay, how would we do that?

52
00:03:21.670 --> 00:03:25.870
So pause the video and try to do it and come back so we do it together.

53
00:03:27.200 --> 00:03:27.490
Okay.

54
00:03:27.550 --> 00:03:31.180
So I hope you've given it a try and this is how I do it.

55
00:03:31.360 --> 00:03:34.720
So we should replace this return line and I will delete it.

56
00:03:34.990 --> 00:03:39.670
And I could let the same name for the parameter, but in the sake of readability, I will change it

57
00:03:39.670 --> 00:03:40.510
to list.

58
00:03:40.750 --> 00:03:47.290
And what we're going to say here is for each number inside list, colon, and there it is going to begin

59
00:03:47.290 --> 00:03:47.950
our loop.

60
00:03:48.190 --> 00:03:56.620
This loop is going to check if each one of those numbers RN is in the range that goes between 101,000.

61
00:03:56.710 --> 00:04:02.620
So here we change the function dynamic to check not only a single number, but a list of numbers in

62
00:04:02.620 --> 00:04:04.420
a loop colon.

63
00:04:04.690 --> 00:04:09.740
And what is our code going to do when it finds that a number meets that condition with three digits?

64
00:04:09.760 --> 00:04:11.200
Well, it's going to return.

65
00:04:11.200 --> 00:04:11.850
True.

66
00:04:11.860 --> 00:04:15.430
And in the case that this is not true, we're going to say pass.

67
00:04:15.430 --> 00:04:18.460
So it continues iterating throughout the whole list.

68
00:04:19.090 --> 00:04:20.920
So two issues to consider.

69
00:04:21.220 --> 00:04:26.730
Return is a key word that in addition to return as a value, it is also going to end the loop.

70
00:04:26.740 --> 00:04:28.960
It will kill the function and exit it.

71
00:04:29.200 --> 00:04:34.780
Then, even if there are still some list elements to continue verifying inside our loop, once it finds

72
00:04:34.780 --> 00:04:36.940
a number of three digits, it will finish.

73
00:04:36.940 --> 00:04:40.510
It will return with true and it will exit the functions completely.

74
00:04:41.380 --> 00:04:47.560
Another thing I wanted to say is that even when return is not precisely at the end of a function, it

75
00:04:47.560 --> 00:04:48.850
is rather in the middle.

76
00:04:48.880 --> 00:04:52.120
It still works the same as a function killer element.

77
00:04:52.540 --> 00:04:55.120
No matter where the code meets the return keyword.

78
00:04:55.120 --> 00:04:57.580
Once it reaches it, the function stops there.

79
00:04:58.270 --> 00:05:03.310
Well outside the function we have here, a variable that invokes this function, but we need to feed

80
00:05:03.310 --> 00:05:04.480
it with a list now.

81
00:05:04.750 --> 00:05:10.840
And we're going to pass a short list of three numbers 55, 99 and 6000.

82
00:05:11.080 --> 00:05:15.220
I'm intentionally not passing any three digit numbers, so we'll see what happens here.

83
00:05:15.580 --> 00:05:17.620
So we run it and it says none.

84
00:05:18.040 --> 00:05:20.740
Actually remember that none is a non object.

85
00:05:20.740 --> 00:05:25.510
If we print the result type we're going to get this that it's a non type object.

86
00:05:25.960 --> 00:05:26.980
So is that okay?

87
00:05:27.280 --> 00:05:28.300
Why is that?

88
00:05:28.300 --> 00:05:29.650
Why did this happen?

89
00:05:29.800 --> 00:05:34.990
Because our loop, when we invoked this function, we passed it the list, then it checked first the

90
00:05:34.990 --> 00:05:37.870
55, which it doesn't meet the condition.

91
00:05:37.870 --> 00:05:42.550
So it went to the else and it passed first iteration completed.

92
00:05:42.910 --> 00:05:48.340
Then it went to the second list element 99, it's not a three digit number, so it went to the else

93
00:05:48.340 --> 00:05:51.700
block and it passed to same thing with 6000.

94
00:05:52.380 --> 00:05:54.240
So we never went into this return.

95
00:05:54.240 --> 00:05:54.680
True.

96
00:05:54.690 --> 00:05:59.070
So we couldn't return even false because there is no return false.

97
00:05:59.280 --> 00:06:01.200
We didn't go through any return.

98
00:06:01.680 --> 00:06:03.810
Our function wasn't able to return anything.

99
00:06:03.810 --> 00:06:08.400
But since functions have to return something, what it returned is an empty object.

100
00:06:08.400 --> 00:06:09.780
A non object.

101
00:06:10.380 --> 00:06:11.400
Is that okay?

102
00:06:11.700 --> 00:06:14.580
Let's continue testing this function with other numbers.

103
00:06:15.180 --> 00:06:20.400
Let's suppose that I have at the beginning a three digit number, 555.

104
00:06:20.550 --> 00:06:23.100
If I run it now, I get that it is a bool.

105
00:06:23.490 --> 00:06:27.720
We're going to change here to see the value of result and not its type anymore.

106
00:06:27.930 --> 00:06:34.380
And when we run it, it says true because it reached 555 in the first round, it returned true and it

107
00:06:34.380 --> 00:06:35.610
cut off the function.

108
00:06:36.000 --> 00:06:37.590
It didn't continue cycling.

109
00:06:37.590 --> 00:06:40.200
It didn't even check if the others have three digits.

110
00:06:40.200 --> 00:06:42.360
This was enough for it to give us an answer.

111
00:06:43.280 --> 00:06:47.840
So let's change this to 55 again and make the last number a three digit number.

112
00:06:48.170 --> 00:06:49.490
The answer is the same.

113
00:06:49.490 --> 00:06:54.350
True, because it went through the first one, the second one, and none of them could find a return.

114
00:06:54.350 --> 00:06:54.740
True.

115
00:06:54.740 --> 00:06:58.910
But then when it reached the last one, the program executed this block and returned true.

116
00:06:59.600 --> 00:07:02.540
Then this function only returns two possible values.

117
00:07:02.540 --> 00:07:03.980
True or none.

118
00:07:04.460 --> 00:07:06.230
It will never return false.

119
00:07:06.770 --> 00:07:11.540
How can we make this function to be able to return false if we want it to be informed that there is

120
00:07:11.540 --> 00:07:13.790
no three digit number along the list?

121
00:07:14.180 --> 00:07:16.310
Well, think about it for a second.

122
00:07:16.670 --> 00:07:19.370
Pause the video and I'll come back with my answer.

123
00:07:19.880 --> 00:07:21.040
So I hope you did it.

124
00:07:21.050 --> 00:07:24.200
Maybe you fell into common error, but don't worry if you did.

125
00:07:24.380 --> 00:07:25.670
It usually happens.

126
00:07:26.270 --> 00:07:27.830
A common error for beginners.

127
00:07:27.830 --> 00:07:34.310
Believe me, I was there is to think that what you have to do is go to this else and say, return false.

128
00:07:34.850 --> 00:07:40.160
I understand if you tried this because it's very common sense to do so, but look what happens.

129
00:07:40.190 --> 00:07:44.330
It returns false even though I have a three digit number in my list.

130
00:07:44.570 --> 00:07:45.890
So why is that?

131
00:07:46.100 --> 00:07:47.630
What did this loop do?

132
00:07:48.230 --> 00:07:50.880
It came in with the first number, which is 55.

133
00:07:50.900 --> 00:07:54.530
It checked if this number is in its range, which is is not.

134
00:07:54.710 --> 00:07:56.600
So it went to the else.

135
00:07:56.600 --> 00:07:59.120
The else block of the code returns false.

136
00:07:59.120 --> 00:08:03.230
And since return is a function killer, there are no more iterations.

137
00:08:03.680 --> 00:08:08.780
The code jumped out of the function and even though the list had three digit number on index to the

138
00:08:08.780 --> 00:08:10.160
code never saw it.

139
00:08:10.160 --> 00:08:11.990
And I did get a wrong answer.

140
00:08:12.440 --> 00:08:13.670
So do you follow me?

141
00:08:13.730 --> 00:08:16.340
So this would not be the right way to deal with this?

142
00:08:16.640 --> 00:08:17.390
I insist.

143
00:08:17.390 --> 00:08:19.760
If you do get confused, it's very normal.

144
00:08:19.760 --> 00:08:21.770
And I did the same mistake back then.

145
00:08:22.820 --> 00:08:23.360
Okay, then.

146
00:08:23.360 --> 00:08:28.790
So what we should we have done here, we have to be sure that the return false line is only reached

147
00:08:28.790 --> 00:08:34.160
after the loop is finished, and only in the case that any of its list elements has met the condition.

148
00:08:34.250 --> 00:08:38.780
That means that the return false has to be located outside of the loop.

149
00:08:40.600 --> 00:08:48.430
So we can go back and say, pass here and right, then return false at the end of the loop at the same

150
00:08:48.430 --> 00:08:51.730
indentation level as this for keyword.

151
00:08:52.240 --> 00:08:54.280
So I run it now and here it is.

152
00:08:54.280 --> 00:08:55.630
It returns false.

153
00:08:55.630 --> 00:08:56.830
So why is that?

154
00:08:57.550 --> 00:09:01.930
Because it's going to get here to this line only if it never went through this one.

155
00:09:02.740 --> 00:09:08.380
So then after making three passes through the else and finishing, it leaves the loop without meeting

156
00:09:08.380 --> 00:09:09.970
the return true line.

157
00:09:10.630 --> 00:09:13.450
It falls on this line and it returns false.

158
00:09:14.050 --> 00:09:17.320
And now we're going to scale one more step in the complexity.

159
00:09:17.680 --> 00:09:23.500
And I will say, okay, dear friend, now I want this function not only to tell me if there is or not

160
00:09:23.500 --> 00:09:29.770
some number with three digits, but also to show me all the numbers that have fulfilled that condition.

161
00:09:30.070 --> 00:09:34.810
This would be that I want this function to print a list with all the three digit numbers.

162
00:09:35.670 --> 00:09:38.850
So pause the video and do your best try.

163
00:09:38.940 --> 00:09:40.590
I'll be here with my answer.

164
00:09:41.610 --> 00:09:42.090
Okay.

165
00:09:42.090 --> 00:09:43.170
So thanks for trying.

166
00:09:43.170 --> 00:09:44.970
And let me show you how I did it.

167
00:09:45.480 --> 00:09:48.690
Let's say we have two numbers that fulfill the condition.

168
00:09:48.720 --> 00:09:53.520
555 Index zero and 600 Index two.

169
00:09:53.790 --> 00:09:54.720
There it is.

170
00:09:55.140 --> 00:09:56.990
Now we need to change a few things.

171
00:09:57.000 --> 00:10:00.960
First, we're going to need a place to hold all the values that meet the condition.

172
00:10:01.080 --> 00:10:04.260
So inside our function, we're going to create an empty list.

173
00:10:04.440 --> 00:10:06.810
Let's name it three digits list.

174
00:10:07.650 --> 00:10:09.270
That's how it's going to be called.

175
00:10:09.270 --> 00:10:12.930
And this is going to be initialized as an empty list, of course.

176
00:10:13.730 --> 00:10:14.060
Now.

177
00:10:14.060 --> 00:10:17.600
We don't want our loop to be cut off when it finds a three digit number here.

178
00:10:17.780 --> 00:10:19.940
So we need to delete this return.

179
00:10:19.940 --> 00:10:20.570
True.

180
00:10:21.490 --> 00:10:27.460
From now on, when MN is in the desired range, we want it to add MN to our three digit list.

181
00:10:27.760 --> 00:10:31.840
So we say here three digit list dot append n.

182
00:10:33.480 --> 00:10:37.140
That way, every number that meets the condition is fed to the list.

183
00:10:37.770 --> 00:10:43.680
Then we leave the past as it is because we still want that nothing happens when any number does not

184
00:10:43.680 --> 00:10:44.970
fulfill the condition.

185
00:10:45.660 --> 00:10:47.640
And what about the return down here?

186
00:10:47.880 --> 00:10:50.070
We don't want it to say false anymore.

187
00:10:50.460 --> 00:10:54.420
What is going to return now is the content of list three digits.

188
00:10:54.750 --> 00:11:00.390
And so if we pass this list that has two, three digit numbers and what we're going to get is just that

189
00:11:00.390 --> 00:11:09.090
a list with 55 and 600, we are beginning to understand the ductility, the flexibility and the breadth

190
00:11:09.090 --> 00:11:11.280
and the possibilities that the functions give us.

191
00:11:11.310 --> 00:11:15.960
And little by little, we're going to get more and more inside the logics of this super useful tool.

192
00:11:16.500 --> 00:11:20.580
So thanks for following Phil and me for this far, and we're going to see you in the next lecture.
