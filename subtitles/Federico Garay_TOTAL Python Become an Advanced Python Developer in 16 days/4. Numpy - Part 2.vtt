WEBVTT
1
00:00:08.030 --> 00:00:11.750
So let's continue getting to know the possibilities that NumPy offers.

2
00:00:11.990 --> 00:00:16.730
I'm visiting this notebook that we have left after having created a raffle.

3
00:00:17.240 --> 00:00:19.670
Now we're going to find inside a raffle.

4
00:00:19.670 --> 00:00:21.170
It's unique values.

5
00:00:21.320 --> 00:00:28.250
For that we can call NPR Dot Unique, which is a method that will allow you to find all the unique elements

6
00:00:28.250 --> 00:00:29.720
inside the raffle.

7
00:00:31.010 --> 00:00:36.650
So we run it and we're going to find that we now have an array composed of numbers, a series of numbers

8
00:00:36.650 --> 00:00:40.880
without repeat, because it took all the numbers from array four.

9
00:00:41.150 --> 00:00:46.670
And however many of them are repeated here, it shows the different numbers without repeats.

10
00:00:47.300 --> 00:00:53.990
If we want to extract an element from a raffle, not from this one without repeats, but from the original

11
00:00:53.990 --> 00:00:56.440
one, this is going to surprise you.

12
00:00:57.110 --> 00:01:01.520
Suppose I want to extract from a raffle only index one.

13
00:01:02.060 --> 00:01:03.890
What do you expect to find?

14
00:01:04.280 --> 00:01:05.180
Let's see.

15
00:01:05.660 --> 00:01:06.890
Take a second to think.

16
00:01:07.370 --> 00:01:11.150
And if we select index one of this element, what do we get?

17
00:01:11.780 --> 00:01:12.920
Well, let's see.

18
00:01:12.920 --> 00:01:16.250
So we run it and we get the whole second line.

19
00:01:16.940 --> 00:01:23.180
And maybe you'd expect using the logic that we've learned so far, that we get the number eight, because

20
00:01:23.180 --> 00:01:27.710
this would be index zero and therefore index one should be eight.

21
00:01:28.070 --> 00:01:37.490
But no actually index zero of this array is this row, all of it index one is this second row and that's

22
00:01:37.490 --> 00:01:38.210
what came.

23
00:01:38.570 --> 00:01:40.460
Index one is all of this.

24
00:01:41.600 --> 00:01:47.900
If this time we want to extract the first two rows of our array for what we're going to call now, inside

25
00:01:47.900 --> 00:01:50.600
the square brackets is colon two.

26
00:01:51.230 --> 00:01:57.020
And when we run it, it's going to bring up both the row that we just got and row zero.

27
00:01:58.100 --> 00:02:03.110
And if you want to extract a certain number of elements from a certain number of rows, for example,

28
00:02:03.110 --> 00:02:06.860
the first two rows of data, we do something similar.

29
00:02:07.670 --> 00:02:15.080
We call array four, but in the square brackets we pass two for the elements, comma, two for the row,

30
00:02:15.470 --> 00:02:16.820
and we're executed.

31
00:02:17.900 --> 00:02:24.650
And this brings us the three and the eight of the first row and the five and the eight of the second

32
00:02:24.650 --> 00:02:25.100
row.

33
00:02:25.730 --> 00:02:29.720
So you're extracting section elements from the whole array.

34
00:02:30.740 --> 00:02:37.310
So the next instruction is for us to create two, three by four arrays each, the first with random

35
00:02:37.310 --> 00:02:40.580
0 to 10 and the second with pure ones.

36
00:02:41.290 --> 00:02:42.370
So let's do that.

37
00:02:42.370 --> 00:02:51.160
Let's create an array five that is equal to an NP dot random dot random that has numbers from 0 to 10

38
00:02:51.640 --> 00:02:54.400
and that has a dimension of three by four.

39
00:02:56.110 --> 00:02:57.790
That's the array five.

40
00:02:57.880 --> 00:02:59.620
You already know how to do this.

41
00:03:00.100 --> 00:03:06.700
You can also know how to make array six, which is according to the instruction has to have pure ones.

42
00:03:06.910 --> 00:03:12.820
So we put np dot ones and that it has a size of three high and four long.

43
00:03:13.960 --> 00:03:15.310
So we declare them.

44
00:03:15.430 --> 00:03:16.780
They already exist.

45
00:03:17.320 --> 00:03:19.960
We call them first array five.

46
00:03:20.170 --> 00:03:23.380
We run it to see it and it's well created.

47
00:03:24.220 --> 00:03:26.260
They are random three by four.

48
00:03:26.380 --> 00:03:32.860
And we also invoke array six, which should be pure ones, but the same size as the previous array.

49
00:03:33.670 --> 00:03:35.710
And here we have our second array.

50
00:03:36.790 --> 00:03:40.510
Notice it has the same dimensions but different contents.

51
00:03:41.410 --> 00:03:43.000
So what are we going to do now?

52
00:03:43.810 --> 00:03:46.750
Let's add these two arrays together and see what happens.

53
00:03:46.750 --> 00:03:55.570
If we add arrays together, let's call array five, plus array six, run this curiosity and we get an

54
00:03:55.570 --> 00:03:58.000
array of the same dimensions as before.

55
00:03:58.000 --> 00:04:03.550
But each of its elements is the sum of the elements that are at the same index.

56
00:04:04.500 --> 00:04:09.870
So now we create an array, but instead of being three by four, it will be four by three.

57
00:04:10.530 --> 00:04:13.440
That is to say, it will have different dimensions.

58
00:04:14.450 --> 00:04:21.350
It is going to be the array seven and it's going to be the same as an NP of ones, but it's not going

59
00:04:21.350 --> 00:04:28.730
to be three by four as before, but four by three now we call it, and we execute it.

60
00:04:29.180 --> 00:04:30.020
There you go.

61
00:04:31.040 --> 00:04:36.950
So we have two arrays of different dimensions, one, four by three and one, three by four.

62
00:04:37.640 --> 00:04:43.910
And what we're going to try to do now is to add up array six, which is three by four, plus array seven,

63
00:04:43.910 --> 00:04:45.080
which is four by three.

64
00:04:45.740 --> 00:04:46.890
So let's do it.

65
00:04:46.910 --> 00:04:50.990
Let's add arrays, six plus array, seven, run.

66
00:04:51.260 --> 00:04:57.650
And we're going to get an error which tells us that the operations cannot be put together with shapes

67
00:04:57.650 --> 00:05:00.110
that are three by four and four by three.

68
00:05:00.560 --> 00:05:05.060
You can only do operations between arrays when they have the same dimensions.

69
00:05:06.170 --> 00:05:11.540
And the curious fact, which you might find very useful, is that when you find the book in the CoLab

70
00:05:11.540 --> 00:05:18.680
notebooks, you will have the possibility to search for this bug in Stack Overflow, which, as you

71
00:05:18.680 --> 00:05:23.600
know, is the biggest forum in the world for finding bugs in programming.

72
00:05:25.370 --> 00:05:31.430
And here you come, you come across this bug and what other users have said and if they've solved it,

73
00:05:31.430 --> 00:05:32.210
etc..

74
00:05:32.720 --> 00:05:35.030
So this bulletin will always be useful for you.

75
00:05:35.960 --> 00:05:38.750
Well, what's the reason for this error above?

76
00:05:39.410 --> 00:05:44.600
What should we take into account so it doesn't happen to our arrays?

77
00:05:44.600 --> 00:05:46.010
Have the same size.

78
00:05:46.640 --> 00:05:50.930
So let's create then another array of size four by three as well.

79
00:05:51.410 --> 00:05:59.330
But this time filled with ones, it's going to be the array eight and it's going to be equal to an NP

80
00:05:59.330 --> 00:05:59.590
dot.

81
00:05:59.660 --> 00:06:02.750
Once that's four high by three long.

82
00:06:03.740 --> 00:06:08.390
We invoke it so that we can see that it came out the way we wanted it to.

83
00:06:09.470 --> 00:06:13.700
And now we're going to subtract array eight minus array seven.

84
00:06:14.660 --> 00:06:21.710
And what we get is a list that was possible to make because since they both have the same dimensions,

85
00:06:21.950 --> 00:06:28.460
the ones in array seven subtract from each other with the ones in array eight and we get an array that

86
00:06:28.460 --> 00:06:30.500
contains only zeros.

87
00:06:31.040 --> 00:06:37.490
Now let's create two other arrays that are both three by three and have random numbers from 1 to 5.

88
00:06:37.700 --> 00:06:45.200
They're going to be array nine, which is going to be equal to NP random dot round it, which has numbers

89
00:06:45.200 --> 00:06:49.580
from 1 to 5 and which has a dimension of three by three.

90
00:06:50.660 --> 00:06:53.780
And the array ten is going to be exactly the same.

91
00:06:54.110 --> 00:06:59.570
So we copy and paste, but we tell it you are the array ten.

92
00:07:00.170 --> 00:07:04.190
We invoke them so we can see them array nine and array ten.

93
00:07:05.360 --> 00:07:08.780
So we execute both cells so that they are shown there.

94
00:07:08.780 --> 00:07:11.390
We have the first one and the second one.

95
00:07:12.230 --> 00:07:17.660
Although both have the same code, we get different values because they are random and now we're going

96
00:07:17.660 --> 00:07:20.390
to multiply the two arrays with each other.

97
00:07:20.720 --> 00:07:23.720
Can we array nine by array ten?

98
00:07:23.750 --> 00:07:28.760
Of course we can, because they have the same dimensions and we can get an array whose numbers are the

99
00:07:28.760 --> 00:07:31.790
result of multiplying the numbers at the same index.

100
00:07:32.930 --> 00:07:34.730
We can also square an array.

101
00:07:34.970 --> 00:07:43.880
Let's do it with the array nine and power it with two asterisks and the two as we do in all Python.

102
00:07:44.330 --> 00:07:45.470
And there we have it.

103
00:07:45.860 --> 00:07:51.200
So we can also find the square root with np dot sqrt.

104
00:07:51.860 --> 00:07:58.760
We apply it to array ten, we run it and we get the square root of each of the numbers in our array.

105
00:07:59.210 --> 00:08:02.540
We can also find the average of the values that are in array.

106
00:08:02.540 --> 00:08:04.340
For example, of array nine.

107
00:08:04.340 --> 00:08:08.780
If I apply the mean method, it will add all the numbers.

108
00:08:08.810 --> 00:08:12.170
It will divide them by the amount of numbers that they are.

109
00:08:12.530 --> 00:08:15.560
And it will tell me the average of array nine.

110
00:08:16.070 --> 00:08:17.390
You can see it there.

111
00:08:18.110 --> 00:08:25.910
We can also find the maximum value to the array nine we apply max and we execute it and you're going

112
00:08:25.910 --> 00:08:30.320
to get a single number which is the highest of all the numbers in that array.

113
00:08:31.580 --> 00:08:38.480
If we want to find the minimum value, we do something very similar with array nine dot min and there

114
00:08:38.480 --> 00:08:39.170
you have it.

115
00:08:40.160 --> 00:08:44.450
We can also change the shape of the array nine, which is three by three.

116
00:08:45.050 --> 00:08:51.860
We're going to transform it into an array, nine high by one long and store it as array 11.

117
00:08:52.820 --> 00:08:54.290
So how do we do this?

118
00:08:54.290 --> 00:09:02.030
We say that array 11 is going to be the same as array nine, but applying the method reshape which asks

119
00:09:02.030 --> 00:09:07.550
us to pass it the new shape it's going to have, which is going to be nine by one.

120
00:09:08.720 --> 00:09:13.880
So we run it, we invoke array 11 down here so we can see how this has turned out.

121
00:09:14.400 --> 00:09:20.730
And now our ray has a very long shape, like a lamp post with all the numbers arranged, one on top

122
00:09:20.730 --> 00:09:21.360
of the other.

123
00:09:22.320 --> 00:09:28.200
This is a two dimensional array, which though it looks one dimensional because it's nine high and one

124
00:09:28.200 --> 00:09:28.680
long.

125
00:09:29.370 --> 00:09:31.140
Now let's transpose the array.

126
00:09:31.140 --> 00:09:31.710
11.

127
00:09:32.040 --> 00:09:33.720
So what does transpose mean?

128
00:09:34.380 --> 00:09:39.540
It means change what is in the columns and put it in rows and vice versa.

129
00:09:39.990 --> 00:09:47.460
We do this with a very simple method which is t this transposes everything and now our array has been

130
00:09:47.460 --> 00:09:49.590
laid down this array.

131
00:09:49.620 --> 00:09:51.740
Don't be fooled has two dimensions.

132
00:09:51.750 --> 00:09:57.750
As you can see, it has two square brackets because it has the dimension height and dimension length.

133
00:09:58.260 --> 00:10:04.950
So we can also compare array nine and array ten to see which elements in array nine are larger than

134
00:10:04.950 --> 00:10:06.090
those in array ten.

135
00:10:07.240 --> 00:10:08.920
To see what this would look like.

136
00:10:09.340 --> 00:10:16.360
So we create an array 12 which is going to be equal to array nine comparing it if it is greater than

137
00:10:16.360 --> 00:10:21.970
array ten, we're going to run our array 12 to see what the result of this is.

138
00:10:22.210 --> 00:10:28.540
And we're going to be able to see that each index in this array says true or false as appropriate,

139
00:10:28.540 --> 00:10:34.060
to tell us if the number in Array nine is greater than the one in the same position in array ten.

140
00:10:34.690 --> 00:10:38.320
The Array 12 is then composed of boolean values.

141
00:10:38.740 --> 00:10:46.270
We can check this by calling array 12 dot D type and we see that the type of data contained in our array

142
00:10:46.270 --> 00:10:48.800
is no longer integers but booleans.

143
00:10:49.570 --> 00:10:51.310
So we are now finishing.

144
00:10:51.310 --> 00:10:56.500
Let's see if any of these elements in array nine is equal to the equivalent in array ten.

145
00:10:57.610 --> 00:11:01.330
We do the same thing we did here, copy and paste.

146
00:11:01.330 --> 00:11:07.540
But this time, instead of seeing if it is greater, we're going to see if this equal with two equals

147
00:11:07.540 --> 00:11:08.230
symbols.

148
00:11:09.710 --> 00:11:13.760
This will tell us which are equal, if any, and which are not.

149
00:11:14.390 --> 00:11:21.020
If we want to compare both arrays to see if nine is greater than or equal to ten, we will receive slightly

150
00:11:21.020 --> 00:11:22.100
similar results.

151
00:11:23.150 --> 00:11:27.740
If we want to find only the elements of array nine that are greater than two.

152
00:11:28.310 --> 00:11:29.630
How would we do it?

153
00:11:30.200 --> 00:11:36.500
We ask array nine to show us the ones greater than two and this will tell us which ones are and which

154
00:11:36.500 --> 00:11:37.250
ones are not.

155
00:11:38.330 --> 00:11:40.640
So look, all you have to play and have fun with.

156
00:11:41.150 --> 00:11:48.510
Finally, let's see that you can sort the elements from smallest to largest inside an array with NPCs.

157
00:11:49.580 --> 00:11:53.480
And here we put the array nine as the object to sort.

158
00:11:54.620 --> 00:12:01.310
We execute this line and here we have the elements sorted from highest to lowest in each line.

159
00:12:02.360 --> 00:12:07.640
Well, this is just a glimpse, the tip of the iceberg of everything numpy allows you to do.

160
00:12:07.940 --> 00:12:14.630
And above all, the most interesting thing is to get to know this array element of which we had no idea

161
00:12:14.630 --> 00:12:15.560
of until now.

162
00:12:16.280 --> 00:12:22.340
So do some research, look for documentation, play around, and look for exercises.

163
00:12:22.430 --> 00:12:26.960
There is a lot to do with NumPy, which is one of the pillars of data science.

164
00:12:27.140 --> 00:12:32.390
In the next lesson, we're going to get to know another of those pillars, which is the Panda Library.

165
00:12:32.690 --> 00:12:34.040
So I'll see you there.
