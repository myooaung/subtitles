WEBVTT
1
00:00:07.730 --> 00:00:12.820
As we saw, the four loops are repeated for a predetermined number of times.

2
00:00:12.830 --> 00:00:18.770
But here is another type of loop that's repeated while asserting condition is met and stops repeating

3
00:00:18.770 --> 00:00:22.160
or iterating when the condition is no longer met.

4
00:00:22.190 --> 00:00:28.400
Here you have to pay attention to one word they repeat while a condition is met.

5
00:00:28.520 --> 00:00:34.840
That's why we refer to this second type of loops as while loops in real life.

6
00:00:34.850 --> 00:00:42.800
An example would be that when one player dies, the game restarts again, while the amount of lives

7
00:00:42.800 --> 00:00:45.140
remaining is greater than zero.

8
00:00:45.290 --> 00:00:48.620
As long as this condition is met, the game will restart.

9
00:00:48.620 --> 00:00:53.480
When the player loses, for example, it will repeat one more iteration of the loop.

10
00:00:54.710 --> 00:01:00.950
But if the player runs out of lives when losing again, the code will check if the condition of having

11
00:01:00.950 --> 00:01:03.830
a number of lives greater than zero is fulfilled.

12
00:01:03.830 --> 00:01:10.280
And if it's not, the loop will not start again and the code will go on with something else like showing

13
00:01:10.280 --> 00:01:11.690
the game over screen.

14
00:01:12.350 --> 00:01:19.070
So in Wild Loops, we cannot know in advance how many times the loop will be executed because it may

15
00:01:19.070 --> 00:01:25.790
depend on dynamic aspects such as how many lives the player gains during the execution of the game.

16
00:01:26.240 --> 00:01:35.810
The syntax of while loops is quite simple and very similar to four loops we say while a certain boolean

17
00:01:35.810 --> 00:01:37.110
condition is fulfilled.

18
00:01:37.130 --> 00:01:40.670
Execute this code if we leave it like this.

19
00:01:40.670 --> 00:01:45.800
Once the condition is no longer met, the code will exit the loop and move forward.

20
00:01:46.070 --> 00:01:53.560
Or we also have the possibility of adding an else block to establish what other code should be executed

21
00:01:53.570 --> 00:01:55.580
if the condition is not met.

22
00:01:56.090 --> 00:01:59.150
A word of warning when writing while loops.

23
00:01:59.150 --> 00:02:06.890
You must be very careful if you do not expressly establish the possibility that at some point the condition

24
00:02:06.890 --> 00:02:13.790
is no longer met, your loop could enter an infinite cycle from which you can only get out of by restarting

25
00:02:13.790 --> 00:02:15.710
the program or the computer.

26
00:02:16.070 --> 00:02:18.960
In a moment, Federico will explain how to avoid this.

27
00:02:18.980 --> 00:02:25.490
We are also going to explain to you three key words that are very useful to use in loops, both in while

28
00:02:25.490 --> 00:02:31.550
and for loops, which are the words break, continue and pass and you will understand them when you

29
00:02:31.550 --> 00:02:33.500
are in the coding part of this video.

30
00:02:33.620 --> 00:02:38.600
Well, I hope everything is perfectly clear right now, but I think that heading over to Pi charm will

31
00:02:38.600 --> 00:02:39.560
help you even more.

32
00:02:39.800 --> 00:02:40.880
We'll see you over there.

33
00:02:41.210 --> 00:02:42.980
I'm already in the game field.

34
00:02:43.160 --> 00:02:48.440
Let's get to know all about these wire loops that they are little different from the four loops, but

35
00:02:48.440 --> 00:02:49.850
they are very important too.

36
00:02:50.420 --> 00:02:54.620
So let's first start by declaring a variable that gives us a number of coins.

37
00:02:54.800 --> 00:02:56.780
Let's say we have five coins.

38
00:02:56.960 --> 00:03:01.760
Now let's declare that the while loop, which is quite similar to the four, because we just put the

39
00:03:01.760 --> 00:03:05.930
while keyword first instead of four and then the condition.

40
00:03:06.630 --> 00:03:11.040
We want a condition that makes this loop repeat as long as coins is greater than zero.

41
00:03:12.030 --> 00:03:17.610
Initially this condition is met because coin starts out having a value of five, so the compiler is

42
00:03:17.610 --> 00:03:19.200
going to enter this loop.

43
00:03:19.380 --> 00:03:24.510
Then as long as the coins are greater than zero, what we're going to do is to have print a phrase that

44
00:03:24.510 --> 00:03:31.320
says, for example, I have and we open a callback that invokes the amount of coins and then the word

45
00:03:31.320 --> 00:03:32.070
coins.

46
00:03:32.100 --> 00:03:35.670
This way our code, it will say how many coins we have.

47
00:03:35.670 --> 00:03:37.090
Now, pay attention to this.

48
00:03:37.110 --> 00:03:39.170
What happens if I execute this loop?

49
00:03:39.180 --> 00:03:42.810
It will loop as long as this condition is met and it will keep repeating itself.

50
00:03:43.170 --> 00:03:48.420
So I can say beforehand that it seems that this loop is never going to stop repeating because nothing

51
00:03:48.420 --> 00:03:52.620
here will change the value of coins and then the loop will never find a way out.

52
00:03:52.860 --> 00:03:56.880
I'm actually going to do something that you don't have to do, which is run this loop.

53
00:03:57.240 --> 00:04:01.590
Let's come over here to run and let's choose while loop and watch.

54
00:04:01.620 --> 00:04:02.870
It started repeating.

55
00:04:02.880 --> 00:04:06.810
I've got five coins, I've got five coins and it never stops doing that.

56
00:04:07.510 --> 00:04:11.950
This is going to last until my computer runs out of memory and collapses and the universe goes into

57
00:04:11.950 --> 00:04:14.920
a void, creating a black hole, and we all disappear into it.

58
00:04:15.580 --> 00:04:19.990
Well, maybe not that much, because luckily, my charm has the ability to stop this.

59
00:04:20.470 --> 00:04:22.120
And here it was, interrupted.

60
00:04:22.210 --> 00:04:23.560
Thank you very much.

61
00:04:23.590 --> 00:04:25.030
The world is safe again.

62
00:04:25.270 --> 00:04:31.090
Anyway, there are other ideas that are not pie charm, that don't have the possibility to interrupt

63
00:04:31.090 --> 00:04:31.840
an infinite loop.

64
00:04:31.840 --> 00:04:36.430
And that would end up needing you to kill the application, disconnect the machine or something like

65
00:04:36.430 --> 00:04:36.910
that.

66
00:04:36.940 --> 00:04:39.670
So luckily we're able to interrupt it.

67
00:04:39.730 --> 00:04:41.350
So how should we solve this?

68
00:04:42.130 --> 00:04:47.530
You need to have inside the loop a line that is in charge of verifying that something is modified.

69
00:04:47.650 --> 00:04:50.110
So at some point, this condition ends.

70
00:04:50.320 --> 00:04:55.720
And in this case, what we would want to put to be a line that modifies the amount of coins and that

71
00:04:55.720 --> 00:05:00.730
says, for example, coins now will be equal to the amount of coins we have, minus one.

72
00:05:01.600 --> 00:05:06.940
Then in each loop I will be losing a coin and if I execute it now, it will tell me that I have five,

73
00:05:06.940 --> 00:05:09.400
four, three, two, one.

74
00:05:09.400 --> 00:05:14.340
And once the condition was no longer fulfilled because when it lost the last coin it was zero.

75
00:05:14.350 --> 00:05:16.530
So coins is no longer greater than zero.

76
00:05:16.540 --> 00:05:21.970
The loop was no longer repeated and it went to the next thing that since there was nothing there, the

77
00:05:21.970 --> 00:05:22.810
program ended.

78
00:05:23.080 --> 00:05:28.300
So I want to show you that there is a much more compact way to write this idea of coins equals coins

79
00:05:28.300 --> 00:05:32.590
minus one, because you can say directly that coins is minus equals one.

80
00:05:32.950 --> 00:05:36.760
This is not readable, but it means equal to the amount I have.

81
00:05:36.760 --> 00:05:38.410
Minus what's next here?

82
00:05:38.530 --> 00:05:40.120
Minus one in this case.

83
00:05:40.540 --> 00:05:42.460
And if I run it, it works the same.

84
00:05:43.150 --> 00:05:47.500
I can also put an else block, same as where we've done before with the loops for.

85
00:05:47.500 --> 00:05:49.960
And here I else would say print something.

86
00:05:49.960 --> 00:05:52.750
For example, I have no money anymore.

87
00:05:53.500 --> 00:05:57.990
If we execute it, it's going to say five, four, three, two, one.

88
00:05:58.000 --> 00:05:59.500
I have no money anymore.

89
00:06:00.040 --> 00:06:02.200
It executed the else and it's gone.

90
00:06:02.470 --> 00:06:07.330
This example may seem to you like it's predetermined in some way how many loops it's going to have,

91
00:06:07.330 --> 00:06:12.190
because it's as if we could anticipate how many iterations this loop will do.

92
00:06:12.550 --> 00:06:15.850
And you'll say that's basically the same thing a loop four does.

93
00:06:15.850 --> 00:06:20.770
But although this is so in this example, the dynamics is pretty different because it's actually developing

94
00:06:20.770 --> 00:06:22.060
during the execution.

95
00:06:22.450 --> 00:06:27.550
Actually, I can incorporate here in the middle that makes it the programmer cannot anticipate how the

96
00:06:27.550 --> 00:06:31.420
events are going to develop and how many repetitions are going to be executed.

97
00:06:31.660 --> 00:06:35.320
As this code, it is now decided to go down one by one.

98
00:06:35.860 --> 00:06:40.600
But what happens if I set the number of coins to be modified according to some user input?

99
00:06:40.600 --> 00:06:43.150
Then I will lose control of what is going to happen.

100
00:06:43.150 --> 00:06:45.160
Let's see it with an example.

101
00:06:45.490 --> 00:06:51.220
We're going to create a variable called answer that starts with a string value y, and then we're going

102
00:06:51.220 --> 00:06:57.910
to create a while loop that says that as long as answer is equal to why the loop is going to be executed.

103
00:06:58.690 --> 00:07:02.470
So the first time it's going to be executed because answer is equal to why.

104
00:07:02.860 --> 00:07:04.840
But then in the first line, we're going to program.

105
00:07:04.840 --> 00:07:06.370
The answer changes.

106
00:07:06.400 --> 00:07:12.040
This way we as programmers lose control because the user can give us anything back he or she wants.

107
00:07:12.050 --> 00:07:14.830
Answer is going to be rewritten by the user.

108
00:07:15.820 --> 00:07:18.910
So the prompt says something like Do you want to continue?

109
00:07:19.150 --> 00:07:20.590
And then we're going to help him.

110
00:07:20.830 --> 00:07:25.450
We're going to give him a hint he can put Y or N, for example.

111
00:07:26.020 --> 00:07:31.000
Well, if the user puts y, the loop is going to keep repeating as many times as he or she keeps doing

112
00:07:31.000 --> 00:07:31.390
that.

113
00:07:32.260 --> 00:07:36.880
We're also going to add an else here so that in case the user does not enter Y.

114
00:07:36.910 --> 00:07:41.830
So in case of anything else, what is going to happen is that thank you will be printed.

115
00:07:42.680 --> 00:07:43.340
Perfect.

116
00:07:43.370 --> 00:07:44.650
We're going to execute it.

117
00:07:44.660 --> 00:07:46.890
And here it says, do you want to continue?

118
00:07:46.910 --> 00:07:47.780
Yes or no?

119
00:07:48.110 --> 00:07:51.470
Let's put yes, I want to continue and let's continue putting.

120
00:07:51.470 --> 00:07:53.120
Yes, the why.

121
00:07:53.150 --> 00:07:55.040
The why and the why.

122
00:07:55.220 --> 00:07:57.230
How many times is it going to repeat?

123
00:07:57.560 --> 00:07:59.900
Well, the programmer cannot anticipate it.

124
00:07:59.930 --> 00:08:02.000
It depends on the behavior of the user.

125
00:08:02.300 --> 00:08:05.660
So now I'm going to put NN and then it said thank you.

126
00:08:06.020 --> 00:08:08.070
And finally we could get out of this loop.

127
00:08:08.090 --> 00:08:11.270
That is a fundamental difference with the for loop.

128
00:08:11.540 --> 00:08:13.190
In the for loop, I'm in control.

129
00:08:13.190 --> 00:08:19.910
Somehow I can anticipate because it depends on variables that maybe I have control over in the while

130
00:08:19.910 --> 00:08:20.240
loop.

131
00:08:20.240 --> 00:08:25.400
It is not predetermined how many times it is going to happen because it depends on the dynamics of the

132
00:08:25.400 --> 00:08:26.660
code execution.

133
00:08:26.660 --> 00:08:31.730
So as I promised you, there are also some key words that you need to know to work with loops.

134
00:08:32.440 --> 00:08:35.800
And this applies both with wild loop and the for loop.

135
00:08:35.890 --> 00:08:40.510
And these keywords are the words pass, break and continue.

136
00:08:40.540 --> 00:08:42.940
Pass is the first one we're going to look at.

137
00:08:43.240 --> 00:08:46.180
Basically what pass does is to do nothing.

138
00:08:46.180 --> 00:08:49.300
And you will be saying, Why do I want a code that does nothing?

139
00:08:49.480 --> 00:08:51.880
Well, let's delete all this in code first.

140
00:08:51.880 --> 00:08:53.800
And now imagine I'm programming here.

141
00:08:54.610 --> 00:08:58.040
I am the programmer and I still don't know what I want this loop to do.

142
00:08:58.060 --> 00:08:59.140
Or maybe I know.

143
00:08:59.140 --> 00:09:02.770
But before writing it, I need to test some other stuff first.

144
00:09:02.980 --> 00:09:05.470
So I want to continue programming something else.

145
00:09:05.650 --> 00:09:06.760
So I get out.

146
00:09:07.620 --> 00:09:10.680
I come here and I want to code a hello print.

147
00:09:11.360 --> 00:09:16.190
If I execute this, I'm going to have an error because I leave the code without some action being completed

148
00:09:16.190 --> 00:09:16.640
here.

149
00:09:16.700 --> 00:09:17.600
So what?

150
00:09:18.380 --> 00:09:21.710
As a programmer, I'm obliged to already know everything I need.

151
00:09:22.160 --> 00:09:22.520
Do I.

152
00:09:22.760 --> 00:09:25.610
Do I have to put a fake print here as a placeholder?

153
00:09:26.090 --> 00:09:28.160
No, that's why Pass exists.

154
00:09:28.280 --> 00:09:33.170
It takes care of all this place for me here so I can execute my code and I can go ahead and so on.

155
00:09:33.800 --> 00:09:35.840
So that's the simple function of pass.

156
00:09:35.990 --> 00:09:40.010
So strictly as a placeholder, that's how it's generally used.

157
00:09:40.610 --> 00:09:42.350
We also have the word break.

158
00:09:42.350 --> 00:09:48.140
And what break does is interrupting the current iteration of the loop that we're in and go straight

159
00:09:48.140 --> 00:09:49.040
out of the loop.

160
00:09:49.830 --> 00:09:52.410
So let's do it again with a user input.

161
00:09:52.770 --> 00:09:57.630
We create a variable called name that is equal to an input that asks the user for their name.

162
00:09:58.170 --> 00:09:59.880
Let's make it simple for the user.

163
00:09:59.910 --> 00:10:00.870
Your name.

164
00:10:01.020 --> 00:10:07.090
And now we're going to do a four loop that makes it so that every letter that exists in its name.

165
00:10:07.110 --> 00:10:09.330
What it does is print letter.

166
00:10:10.280 --> 00:10:14.030
Then if we execute this, it is going to ask me my name.

167
00:10:14.360 --> 00:10:19.550
I say Federico, and it says Federico.

168
00:10:20.120 --> 00:10:22.970
One letter at a time and is finished.

169
00:10:23.000 --> 00:10:23.900
That's perfect.

170
00:10:23.930 --> 00:10:25.130
It works very well.

171
00:10:25.310 --> 00:10:29.000
But what if I want this program to stop when it encounters the letter R?

172
00:10:29.240 --> 00:10:30.920
Is there a way to do that?

173
00:10:31.460 --> 00:10:32.450
Well, yes.

174
00:10:32.690 --> 00:10:34.730
And break is the best way to do it.

175
00:10:34.760 --> 00:10:42.650
I can say here that if letter is equal to R, what I do is break and break is going to make that if

176
00:10:42.650 --> 00:10:46.520
I put pull, nothing happens because there is no r.

177
00:10:46.820 --> 00:10:53.870
But if I put Federico then since we do have an R here, it only gives me back 50 and it is interrupted

178
00:10:53.870 --> 00:10:56.030
and the program ended immediately there.

179
00:10:56.480 --> 00:10:59.510
There is no possibility for the following iterations to run.

180
00:10:59.720 --> 00:11:05.060
For that, we also have the third magic word, which is continue and continue does something similar

181
00:11:05.060 --> 00:11:09.820
to break because it interrupts the current iteration, but it does not interrupt the loop itself.

182
00:11:09.830 --> 00:11:15.080
It only interrupts the actual iteration and it goes back to the beginning of the code block and continues

183
00:11:15.080 --> 00:11:16.450
with the next iteration.

184
00:11:16.460 --> 00:11:23.150
So if I say continue here instead of break and execute, once I put Federico or any name containing

185
00:11:23.150 --> 00:11:29.720
the R, it will print fade, followed by IKO skipped here because the iteration was interrupted before

186
00:11:29.720 --> 00:11:30.800
it got to the print.

187
00:11:31.130 --> 00:11:37.070
But the loop didn't end here and it continued again with the next iterations and the remaining letters

188
00:11:37.070 --> 00:11:38.390
were able to be printed.

189
00:11:38.390 --> 00:11:44.390
These three words pass, break and continue are going to be your allies and facilitating the dynamics

190
00:11:44.390 --> 00:11:45.440
of your loops.

191
00:11:45.620 --> 00:11:50.240
I hope you've learned a lot and you can put them into practice in the exercises that follow next.

192
00:11:50.240 --> 00:11:53.510
So I'm running into the next lecture because there is a lot more to learn.
