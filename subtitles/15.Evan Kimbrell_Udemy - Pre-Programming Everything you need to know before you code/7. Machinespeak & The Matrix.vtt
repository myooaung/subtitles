WEBVTT
1
1

00:00:00.000  -->  00:00:02.130
Hey guys, welcome back to the course.
2

2

00:00:02.130  -->  00:00:05.430
Ok, we're getting more and more comfortable with the concept of
3

3

00:00:05.430  -->  00:00:08.140
computing and computers, hopefully.
4

4

00:00:08.140  -->  00:00:11.570
Realistically, you're probably bored to tears 
and ready to give a bad review
5

5

00:00:11.570  -->  00:00:16.580
and I'm really sorry about that, but we really 
do have to start with the simple stuff
6

6

00:00:16.580  -->  00:00:22.100
if you can really stand a chance of understanding 
the complicated stuff we get into way later.
7

7

00:00:22.100  -->  00:00:26.740
Now, this part I think is rather interesting, maybe I'm nerding out,
8

8

00:00:26.740  -->  00:00:29.990
but maybe you'll also find it interesting. 
Either way, try to pay attention.
9

9

00:00:29.990  -->  00:00:34.900
All right, now, remember the movie 
The Matrix with "far out" Keanu Reeves,
10

10

00:00:34.900  -->  00:00:37.000
fresh out of Bill & Ted's Excellent Adventure?
11

11

00:00:39.400  -->  00:00:42.970
If you haven't seen it, first of all - who are you?
12

12

00:00:42.970  -->  00:00:46.440
And second of all, please pause it and go watch that movie.
13

13

00:00:46.440  -->  00:00:50.150
* What is real? How do you define real? *
14

14

00:00:50.150  -->  00:00:54.150
In that movie, to summarize the 
most important movie of my childhood,
15

15

00:00:54.150  -->  00:00:59.520
humans figure out that they're actually 
living in a simulation of the universe,
16

16

00:00:59.520  -->  00:01:04.000
a simulation that is essentially pulled 
over their eyes to distract themselves
17

17

00:01:04.000  -->  00:01:08.500
from the fact that they actually live in a 
very dirty retro punk universe
18

18

00:01:08.500  -->  00:01:12.970
full of loin clothes and raves, where robots actually control the world
19

19

00:01:12.970  -->  00:01:15.240
and use human beings as batteries.
20

20

00:01:15.240  -->  00:01:18.780
Yes, I know, there are exactly zero plot holes in that story.
21

21

00:01:18.780  -->  00:01:25.210
Anyway, remember how the Matrix, i.e. the simulation 
that is pulled over human beings' eyes,
22

22

00:01:25.210  -->  00:01:30.600
would always be displayed as 
falling green lines of gobbly gook code?
23

23

00:01:30.600  -->  00:01:33.550
And do you guys remember, in the movie, 
how no one could really read it?
24

24

00:01:33.550  -->  00:01:37.230
They had to use other systems to interpret it for them.
25

25

00:01:37.230  -->  00:01:43.230
Well, in the movie, that's how computers speak, 
and in real life, coincidentally,
26

26

00:01:43.230  -->  00:01:45.270
it actually works in a very similar way.
27

27

00:01:45.270  -->  00:01:47.800
No, I'm not saying you are living in a simulation right now.
28

28

00:01:47.800  -->  00:01:52.440
You are indeed watching this course, 
enjoying it, partially wondering
29

29

00:01:52.440  -->  00:01:56.140
if your coworkers are paid more than you, 
probably wondering what you're
30

30

00:01:56.140  -->  00:01:58.280
going to be doing on the weekend. This is all real.
31

31

00:01:58.280  -->  00:02:01.550
What I am saying is that computers 
have their own language and
32

32

00:02:01.550  -->  00:02:04.590
that language is called machine code.
33

33

00:02:04.590  -->  00:02:10.860
And like the Matrix, machine code is really hard 
for us humans to not only write,
34

34

00:02:10.860  -->  00:02:14.330
but read and just have basic comprehension of.
35

35

00:02:14.330  -->  00:02:19.600
Only the nerdiest of the nerds, 
the ultimate nerdos, can actually read and
36

36

00:02:19.600  -->  00:02:25.210
write this stuff and it is an incredibly impressive 
feat that does require admiration.
37

37

00:02:25.210  -->  00:02:29.700
When a computer wants to tell itself to 
do something, or an application, or a
38

38

00:02:29.700  -->  00:02:34.150
peripheral device like a mouse wants it to tell it to do something,
39

39

00:02:34.150  -->  00:02:38.450
it does it through variations of machine code.
40

40

00:02:38.450  -->  00:02:42.790
The simplest version of machine code 
that all hardware uses to communicate
41

41

00:02:42.790  -->  00:02:48.700
is actually just a language that 
consists of two things, 0s and 1s.
42

42

00:02:48.700  -->  00:02:51.470
Essentially beeps and boops.
43

43

00:02:51.470  -->  00:02:55.840
Want to say "yes" in machine code? Say "beep" or 1.
44

44

00:02:55.840  -->  00:02:59.240
Want to say "no"? Say "beep boop" or 10.
45

45

00:02:59.240  -->  00:03:04.450
By stringing together these two digits, 0 and 1, 
also known as the binary system,
46

46

00:03:04.450  -->  00:03:09.220
because it's only two options, your computer 
is going to effectively communicate with itself.
47

47

00:03:09.220  -->  00:03:11.680
But wait, how does this actually work?
48

48

00:03:11.680  -->  00:03:15.160
If it's just 0s and 1s, how does that turn into a language?
49

49

00:03:15.160  -->  00:03:19.260
If it's just the hardware that you run 
electricity through in your computer,
50

50

00:03:19.260  -->  00:03:23.430
how does it actually relay this information and receive it?
51

51

00:03:23.430  -->  00:03:29.000
Well, I'm happy to answer this, because in all 
of my 28 years of existence on this planet,
52

52

00:03:29.000  -->  00:03:33.310
I didn't actually know how this worked until about six months ago
53

53

00:03:33.310  -->  00:03:36.880
when I probably just stumbled on a Wikipedia page.
54

54

00:03:36.880  -->  00:03:41.750
Ok, so within that magical box of a computer, 
we have motherboards.
55

55

00:03:41.750  -->  00:03:47.420
Now, motherboards are the big green squares 
that everything else is attached to.
56

56

00:03:47.420  -->  00:03:51.690
Your RAM, your processor, your storage, it's all on there.
57

57

00:03:51.690  -->  00:03:55.770
That board is actually what transfers these messages.
58

58

00:03:55.770  -->  00:03:58.610
Now the way that it actually works 
is that it alternates between
59

59

00:03:58.610  -->  00:04:04.340
letting electricity pass through a transistor 
and stopping it to communicate.
60

60

00:04:04.340  -->  00:04:11.950
So letting electricity go through a transistor 
is a 1 and stopping it is a 0.
61

61

00:04:11.950  -->  00:04:14.150
Ok, but then how does it actually communicate
62

62

00:04:14.150  -->  00:04:17.150
with any effectiveness if it's just on/off, on/off?
63

63

00:04:17.150  -->  00:04:23.930
Well, it can turn one off and then turn it 
back on easily within a millionth of a second.
64

64

00:04:23.930  -->  00:04:29.600
So in a second, it can send close to 
a million of those 0s and 1s.
65

65

00:04:29.600  -->  00:04:32.400
It's amazing, yes, I know.
66

66

00:04:32.400  -->  00:04:35.540
We'll come back to this later when we 
talk about things like broadband
67

67

00:04:35.540  -->  00:04:39.570
and that ridiculous internet delivery drone 
that Facebook is trying to make,
68

68

00:04:39.570  -->  00:04:43.810
but the point to keep in mind is that 
cable lines and that Facebook drone, well,
69

69

00:04:43.810  -->  00:04:46.550
they actually transfer information in the exact same way.
70

70

00:04:46.550  -->  00:04:49.450
On/off, on/off, on/off.
71

71

00:04:49.450  -->  00:04:52.990
Have you ever heard the joke that 
the internet is just a "series of tubes?"
72

72

00:04:53.290  -->  00:04:55.000
* It's not a big truck *
73

73

00:04:55.000  -->  00:04:56.690
* It's a series of tubes *
74

74

00:04:56.690  -->  00:05:01.260
Well, that joke is actually half serious, 
because the original computers
75

75

00:05:01.260  -->  00:05:07.900
were actually giant tubes, and instead of 
using electricity to go on and off,
76

76

00:05:07.900  -->  00:05:10.440
or 0s and 1s, they used air.
77

77

00:05:10.440  -->  00:05:13.520
Electricity, as it turns out, way more effective.
78

78

00:05:13.520  -->  00:05:17.650
So why is it hard for humans to read these 0s and 1s?
79

79

00:05:17.650  -->  00:05:22.480
Well, because basic commands in 
machine code are insanely long.
80

80

00:05:22.480  -->  00:05:28.460
It's like 010100011110011,
81

81

00:05:28.460  -->  00:05:31.530
and then take that, and then play it out x 100.
82

82

00:05:31.530  -->  00:05:33.900
And that would just be one command right there.
83

83

00:05:33.900  -->  00:05:38.730
Now, could you imagine reading 
a 100 page book of 0s and 1s,
84

84

00:05:38.730  -->  00:05:41.670
and trying to follow the main characters and plot
85

85

00:05:41.670  -->  00:05:45.240
like it were a Harry Potter book? 
No, I don't think so.
86

86

00:05:45.240  -->  00:05:49.050
So that was the problem in the early 
days of computers and it leads me
87

87

00:05:49.050  -->  00:05:54.120
to a very, very important concept in 
programming and in technology in general.
88

88

00:05:54.120  -->  00:06:00.890
Code, whether it be 0s and 1s or a script 
written to display a funny gif on your web browser,
89

89

00:06:03.000  -->  00:06:05.630
all programming code will either be called high level,
90

90

00:06:05.630  -->  00:06:08.830
mid level, or low level, it's on a spectrum.
91

91

00:06:08.830  -->  00:06:14.640
Low level code is just code that basic systems 
and basic pieces of hardware use.
92

92

00:06:14.640  -->  00:06:19.710
Now, machinespeak is the ultimate of the low level code.
93

93

00:06:19.710  -->  00:06:23.680
It actually cannot get any simpler than machinespeak.
94

94

00:06:23.680  -->  00:06:28.320
Low level code is long, it's inefficient, 
and it's actually really hard
95

95

00:06:28.320  -->  00:06:31.120
for humans to manipulate and understand.
96

96

00:06:31.120  -->  00:06:39.250
But there is actually an advantage to having 
this inefficient, overly verbose type of code,
97

97

00:06:39.250  -->  00:06:42.270
and that is that it's infinitely customizable.
98

98

00:06:42.270  -->  00:06:44.700
What do I mean by infinitely customizable?
99

99

00:06:44.700  -->  00:06:50.670
I mean that because you have to spend 
so much time detailing every single part
100

100

00:06:50.670  -->  00:06:55.540
of the message that you send, it gives you 
more control over what you can say.
101

101

00:06:55.540  -->  00:06:58.750
This will make more sense as we actually start exploring
102

102

00:06:58.750  -->  00:07:03.420
some of the more high level programming codes, 
like web programming.
103

103

00:07:03.420  -->  00:07:07.560
You could theoretically use low level code 
to make something you wanted,
104

104

00:07:07.560  -->  00:07:13.770
but because of its inefficiency in size 
and the lack of one's ability to write in it,
105

105

00:07:13.770  -->  00:07:16.500
it would take you an enormous amount of time.
106

106

00:07:16.500  -->  00:07:18.510
Years. Tens of years.
107

107

00:07:18.510  -->  00:07:20.200
I don't know, something really long.
108

108

00:07:20.200  -->  00:07:22.540
High level code, one the other hand, is code designed to
109

109

00:07:22.540  -->  00:07:26.270
progressively fix that problem we just talked about.
110

110

00:07:26.270  -->  00:07:30.880
Now, as code gets higher level, it gets shorter, easier to read,
111

111

00:07:30.880  -->  00:07:35.790
but at the same time it actually gets 
less descriptive and more restricted.
112

112

00:07:35.790  -->  00:07:44.570
Let's say the command "Save this file" 
in machine code is 01001110111 x 50.
113

113

00:07:44.570  -->  00:07:49.130
Ok, well, in a high level language 
it might just be something like
114

114

00:07:49.130  -->  00:07:56.120
<save: the actual location>.
115

115

00:07:56.120  -->  00:08:00.650
That second one is much simpler, 
but you're actually restricted in that
116

116

00:08:00.650  -->  00:08:06.420
you have to save it in, say, only one spot, 
not multiple, not multiple copies.
117

117

00:08:06.420  -->  00:08:08.880
In that sense, it's very restricted.
118

118

00:08:08.880  -->  00:08:15.420
As we progressively move from low level code to high level, 
we see language that is less complicated,
119

119

00:08:15.420  -->  00:08:17.930
and this is the code we see associated with things like
120

120

00:08:17.930  -->  00:08:22.040
software, websites, mobile applications, etc.
121

121

00:08:22.040  -->  00:08:27.540
These languages are designed to get a lot done 
with as few keyboard strokes as you can.
122

122

00:08:27.540  -->  00:08:28.870
So one thing worth mentioning.
123

123

00:08:28.870  -->  00:08:33.180
So you might ask, "My computer only 
speaks in 0s and 1s. Is that true?"
124

124

00:08:33.180  -->  00:08:37.910
Well, yes, at the very most basic level, the hardware does this.
125

125

00:08:37.910  -->  00:08:41.950
When you want to tell your hardware 
to do something, it expects 0s and 1s,
126

126

00:08:41.950  -->  00:08:44.550
because it just eats that stuff all day long.
127

127

00:08:44.550  -->  00:08:48.460
But does something like your mouse 
also communicate in 0s and 1s,
128

128

00:08:48.460  -->  00:08:53.760
or other periphery devices that are attached 
to the motherboard of your computer?
129

129

00:08:53.760  -->  00:08:58.030
Well, no, it actually talks in a slightly higher level of machine code.
130

130

00:08:58.030  -->  00:09:03.380
It's not necessarily 0s and 1s, but it's 
what I imagine it would look like if you
131

131

00:09:03.380  -->  00:09:07.410
took your face and you slammed it onto a Vietnamese keyboard.
132

132

00:09:07.410  -->  00:09:09.420
It looks something like this.
133

133

00:09:09.420  -->  00:09:14.450
Now, when your mouse sends this face Vietnamese 
to your hardware, it has to get translated.
134

134

00:09:14.450  -->  00:09:18.450
Who out there has ever plugged in 
a keyboard into their Windows computer
135

135

00:09:18.450  -->  00:09:22.190
and had it not work because 
you didn't have the right "driver"?
136

136

00:09:22.190  -->  00:09:25.560
If you don't know what I'm talking about, 
then God bless you, because
137

137

00:09:25.560  -->  00:09:29.870
for the longest time this was probably 
the most annoying part of owning a computer.
138

138

00:09:29.870  -->  00:09:33.780
You could never really find the driver 
because it was on a CD, and it was like
139

139

00:09:33.780  -->  00:09:40.140
a CD you lost, or your sister used to overwrite 
and save some rom com movie onto it.
140

140

00:09:40.140  -->  00:09:43.280
A driver is essentially an interpreter.
141

141

00:09:43.280  -->  00:09:48.350
It takes the character A with that 
eyelash on top of it and then it goes,
142

142

00:09:48.350  -->  00:09:54.460
"Ah, I recognize this, it's not an A with 
an eyelash, it's actually 010011100,"
143

143

00:09:54.460  -->  00:09:57.800
and it sends that translated version to your system hardware.
144

144

00:09:57.800  -->  00:10:01.500
So why is it that those two devices 
that are so close to each other
145

145

00:10:01.500  -->  00:10:02.670
speak a different language?
146

146

00:10:02.670  -->  00:10:05.700
Well, the way I would answer that question 
is with a question.
147

147

00:10:05.700  -->  00:10:08.870
Why do we speak different languages?
148

148

00:10:08.870  -->  00:10:10.910
Yeah, exactly. Think about that.
149

149

00:10:10.910  -->  00:10:13.080
We'll actually talk about that later 
in the course, so don't worry.
150

150

00:10:13.080  -->  00:10:14.380
All right, let's recap.
151

151

00:10:14.380  -->  00:10:18.950
Ever seen The Matrix? 
Well, your life is exactly like that,
152

152

00:10:18.950  -->  00:10:24.420
but instead of trying to save humanity, 
as Neo, the perpetually stoned Jesus figure,
153

153

00:10:24.420  -->  00:10:28.560
* Our work is finished here, as it's just begun *
154

154

00:10:28.560  -->  00:10:31.330
you're just trying to get your computer 
to recognize your mouse.
155

155

00:10:31.330  -->  00:10:35.700
Your computer communicates at the 
most basic level in what's called machinespeak
156

156

00:10:35.700  -->  00:10:39.170
and which actually consists of just 0s and 1s.
157

157

00:10:39.170  -->  00:10:44.210
Modern computers actually today communicate more 
in this funky Vietnamese-like code
158

158

00:10:44.210  -->  00:10:48.580
but it actually has built-in interpreters 
to translate that on the fly.
159

159

00:10:48.580  -->  00:10:53.780
It has to translate that because, well, it has to 
relay that information back to the hardware
160

160

00:10:53.780  -->  00:10:58.020
in a language it can understand, which are, again, 
those machine code with the 0s and 1s.
161

161

00:10:58.020  -->  00:11:01.560
There you go, that's it, you just learned 
your first programming language.
162

162

00:11:01.560  -->  00:11:04.820
Next lecture, we're going to talk about 
how we, the dumb consumer,
163

163

00:11:04.820  -->  00:11:07.670
control our mechanical beasts through operating systems.
164

164

00:11:07.670  -->  00:11:08.930
All right, see you then!
