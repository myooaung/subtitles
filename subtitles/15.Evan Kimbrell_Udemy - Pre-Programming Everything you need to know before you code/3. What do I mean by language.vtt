WEBVTT
1
1

00:00:00.000  -->  00:00:01.710
All right, and we are back.
2

2

00:00:01.710  -->  00:00:06.180
On to the next concept for you to digest 
and verbally vomit in your next meeting.
3

3

00:00:06.180  -->  00:00:10.250
Let's address a term you've heard me 
and everybody else at some point say.
4

4

00:00:10.250  -->  00:00:12.390
It's the word "language."
5

5

00:00:12.390  -->  00:00:16.950
I'm obviously not talking about verbal languages, 
we're talking about programming languages.
6

6

00:00:16.950  -->  00:00:19.560
I'm sure you've heard it several times before, but
7

7

00:00:19.560  -->  00:00:23.260
you might not have really gotten what it actually means,
8

8

00:00:23.260  -->  00:00:25.430
and well, it's relatively simple.
9

9

00:00:25.430  -->  00:00:28.960
All programming at the end of the day is a way to write instructions
10

10

00:00:28.960  -->  00:00:31.740
for a computer to understand and then run with.
11

11

00:00:31.740  -->  00:00:34.900
Computers don't speak English, they speak computer.
12

12

00:00:34.900  -->  00:00:38.470
Specifically they speak machine code, as we discussed in section 1.
13

13

00:00:38.470  -->  00:00:42.780
Unfortunately, not all sets of instructions are written in the same way,
14

14

00:00:42.780  -->  00:00:46.020
nor do they have the same rules associated with them.
15

15

00:00:46.020  -->  00:00:49.920
When and if you program, you'll have a set of rules as to
16

16

00:00:49.920  -->  00:00:53.190
what you have to type for the computer to "get it".
17

17

00:00:53.190  -->  00:00:56.860
If you want to refer to something, there might be a very specific spelling,
18

18

00:00:56.860  -->  00:00:59.880
if you want it to save something, you'll probably have to
19

19

00:00:59.880  -->  00:01:03.930
specify precisely how and where it should do that.
20

20

00:01:03.930  -->  00:01:07.570
That set of rules is what makes up a programming language.
21

21

00:01:07.570  -->  00:01:10.200
It's almost identical to human languages.
22

22

00:01:10.200  -->  00:01:13.680
I speak English and if I gave English instructions to
23

23

00:01:13.680  -->  00:01:17.090
someone who only spoke Chinese, it wouldn't compute.
24

24

00:01:17.090  -->  00:01:19.920
Unless they already speak English, which is plausible,
25

25

00:01:19.920  -->  00:01:22.850
considering in about ten years they're going to run the world.
26

26

00:01:22.850  -->  00:01:26.750
Of course, if that Chinese speaker spoke back to me in Chinese,
27

27

00:01:26.750  -->  00:01:30.460
I would look at them in a very similar blank and confused face.
28

28

00:01:30.460  -->  00:01:33.200
Probably something like this.
29

29

00:01:33.200  -->  00:01:38.870
We could have both expressed the same exact thing, 
we could've both said "This course is awful,"
30

30

00:01:38.870  -->  00:01:43.330
but they just had two separate 
rule sets to follow in order to speak it.
31

31

00:01:43.330  -->  00:01:45.340
You also don't hate this course.
32

32

00:01:45.340  -->  00:01:49.770
Like human languages, programming languages 
are only good for software or hardware
33

33

00:01:49.770  -->  00:01:51.420
that is designed specifically to understand it.
34

34

00:01:51.420  -->  00:01:56.340
If you want tell a server to send a computer file for downloading,
35

35

00:01:56.340  -->  00:02:00.030
and you did it in, let's say, a front-end 
programming language, it wouldn't work.
36

36

00:02:00.030  -->  00:02:03.090
So why is it that there are languages at all?
37

37

00:02:03.090  -->  00:02:06.170
Why isn't it the case that there is only one language and
38

38

00:02:06.170  -->  00:02:08.730
all software and machines understood that language?
39

39

00:02:08.730  -->  00:02:14.010
I seriously wish this was the case, but like 
everything else, humans just screw it up.
40

40

00:02:14.010  -->  00:02:16.340
And it's very similar to human languages.
41

41

00:02:16.340  -->  00:02:20.300
Why exactly are there multiple human languages?
42

42

00:02:20.300  -->  00:02:24.620
Well, everyone knows that humans built 
the tower of Babel and it angered God,
43

43

00:02:24.620  -->  00:02:28.450
so he decided to troll us by making 
us not understand each other,
44

44

00:02:28.450  -->  00:02:32.090
and forever make it impossible 
to order goods from Alibaba.com.
45

45

00:02:32.090  -->  00:02:36.620
I'm kidding, obviously, but the answer to 
why we don't have one unified human language
46

46

00:02:36.620  -->  00:02:40.330
is similar to why we don't have a unified programming language.
47

47

00:02:40.330  -->  00:02:42.760
Programming has developed over the years, and over the years,
48

48

00:02:42.760  -->  00:02:46.630
as more and more people contributed to it, standards and rule sets
49

49

00:02:46.630  -->  00:02:49.340
got better, more precise, and more efficient.
50

50

00:02:49.340  -->  00:02:54.700
In this case, it's great that, hey, this language, 
this new language is way more effective
51

51

00:02:54.700  -->  00:02:58.940
than its predecessor, but unfortunately, 
that old language is probably going to be
52

52

00:02:58.940  -->  00:03:01.850
baked into something we still use every day.
53

53

00:03:01.850  -->  00:03:04.890
Most operating systems are written in an old language, because
54

54

00:03:04.890  -->  00:03:10.530
they started a long time ago, and it would be 
insanely expensive to rewrite the whole thing.
55

55

00:03:10.530  -->  00:03:13.090
The other reason is that different groups of people came up
56

56

00:03:13.090  -->  00:03:17.970
with their own rule sets for their own specific needs simultaneously,
57

57

00:03:17.970  -->  00:03:21.960
and unfortunately, there was no giant consortium to get everyone
58

58

00:03:21.960  -->  00:03:24.000
to just make one language from the beginning.
59

59

00:03:24.000  -->  00:03:28.340
In the resources I've included an image of how 
programming languages have changed over time.
60

60

00:03:28.340  -->  00:03:30.590
Check it out, it's kind of like a family tree.
61

61

00:03:30.590  -->  00:03:34.690
Also, as technology developed, we 
needed to do more and different things.
62

62

00:03:34.690  -->  00:03:39.620
No one in the 90s, when they were 
designing the original language for servers,
63

63

00:03:39.620  -->  00:03:44.230
anticipated how many different things and 
use cases we would need to handle for,
64

64

00:03:44.230  -->  00:03:50.360
say, mobile websites, thus we needed big 
changes to accommodate this, but only over time.
65

65

00:03:50.360  -->  00:03:51.800
Ok, let's wrap this up.
66

66

00:03:51.800  -->  00:03:54.410
Languages are just like human languages.
67

67

00:03:54.410  -->  00:03:57.240
Different ways of giving the same set of instructions.
68

68

00:03:57.240  -->  00:04:01.710
They were developed for a specific 
use case, and as an inherent problem
69

69

00:04:01.710  -->  00:04:06.120
with any new technology, we made languages 
work for what we needed now
70

70

00:04:06.120  -->  00:04:09.320
and not for what we anticipated needing in the future.
71

71

00:04:09.320  -->  00:04:10.500
Classic humans.
72

72

00:04:10.500  -->  00:04:12.980
All right, now that we've cleared that hurdle, 
I'll see you in the next lecture!
