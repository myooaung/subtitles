WEBVTT
1

00:00:01.710  -->  00:00:07.340
Hello everyone and welcome to the Big Four Python data structures lecture.

2

00:00:07.340  -->  00:00:13.170
This is going to just be a very brief lecture and we're going to go over the big toe of built in data

3

00:00:13.170  -->  00:00:19.550
structures in Python and it's going to be two data structures lists and dictionaries.

4

00:00:19.620  -->  00:00:25.440
So if you're already familiar with a little bit of C-s background what lists are in Python is they act

5

00:00:25.440  -->  00:00:31.660
as a dynamic array and they support a number of common operations through methods called on them.

6

00:00:32.070  -->  00:00:39.870
And the most common operations performed on a list are indexing and assigning to an index position.

7

00:00:39.870  -->  00:00:45.360
Now what's really amazing here is these operations are both designed to be run in constant time 0 1

8

00:00:45.370  -->  00:00:45.930
.

9

00:00:46.500  -->  00:00:52.020
So let's imagine you wanted to test different methods for constructing a list that would look something

10

00:00:52.020  -->  00:00:52.790
like this.

11

00:00:52.860  -->  00:00:56.390
0 1 2 all the way to 10000.

12

00:00:56.480  -->  00:01:02.370
We're going to do here is go ahead and compare various methods on a list or through a function such

13

00:01:02.370  -->  00:01:08.430
as appending to the end of a list concatenating a list or using tools just casting and a list comprehension

14

00:01:08.430  -->  00:01:09.390
.

15

00:01:09.390  -->  00:01:10.040
All right.

16

00:01:10.410  -->  00:01:14.880
So instead of jumping over to the live code I'm going to go ahead and show you the methods I had built

17

00:01:14.880  -->  00:01:16.100
out here.

18

00:01:16.830  -->  00:01:20.530
So zooming in first method is this function method 1.

19

00:01:20.760  -->  00:01:30.170
We take an empty list and then say for N and x range or range if you're using Python 3 and 10000.

20

00:01:30.300  -->  00:01:38.400
Go ahead and take your current list and then add to it in which is already in a list method to what

21

00:01:38.400  -->  00:01:50.640
it does is WIPs it takes L puts it has an empty list and then it uses the append method method 3 uses

22

00:01:50.640  -->  00:01:51.800
list comprehension.

23

00:01:51.960  -->  00:01:59.940
Again using ex-Rangers generator in order to create that list method for 4 excuse me takes the range

24

00:02:00.060  -->  00:02:04.470
and just uses straight range function in Python 3.

25

00:02:04.470  -->  00:02:07.530
You'll have to use this list range 10000.

26

00:02:07.950  -->  00:02:08.650
OK.

27

00:02:08.910  -->  00:02:16.680
So if we test these methods using the time magic function you'll see here that clearly the most effective

28

00:02:16.710  -->  00:02:22.800
method is using the built in range function in Python which is good to know that the built in method

29

00:02:22.800  -->  00:02:28.890
is the most efficient one and in most cases that will be true the people that write and created this

30

00:02:28.890  -->  00:02:31.400
language take a lot of time to think about these things.

31

00:02:31.530  -->  00:02:36.030
And that's why a built in functions are very efficient and usually the best choice.

32

00:02:36.040  -->  00:02:42.480
Instead of building out your own functions so it's important to keep these sort of factors in mind such

33

00:02:42.480  -->  00:02:45.220
as using arr. or built in functions.

34

00:02:45.330  -->  00:02:50.780
When you're writing efficient code when you're perhaps whiteboarding on an interview question.

35

00:02:50.970  -->  00:02:57.680
So more importantly we want to begin thinking about how we're able to index with a constant time where

36

00:02:57.850  -->  00:02:59.490
we discussed this in more detail.

37

00:02:59.490  -->  00:03:03.180
When we cover arrays in general but for now what don't want to do.

38

00:03:03.180  -->  00:03:05.300
Just be aware of this table right here.

39

00:03:05.410  -->  00:03:08.610
It's a table of Big O for common list operations.

40

00:03:08.610  -->  00:03:12.480
So here all the list operations or different methods you can perform on a list.

41

00:03:12.570  -->  00:03:14.390
And here's their big O efficiency.

42

00:03:14.410  -->  00:03:16.960
And remember this is just time complexity.

43

00:03:17.730  -->  00:03:18.750
OK.

44

00:03:19.320  -->  00:03:20.310
So keep that in mind.

45

00:03:20.310  -->  00:03:25.870
We'll discuss how this actually works later on in the course when we discuss arrays. dictionaries and

46

00:03:25.870  -->  00:03:26.460
Python.

47

00:03:26.460  -->  00:03:32.160
Again if you have a C-s background or an implementation of a hash table and the upper keys and values

48

00:03:32.190  -->  00:03:35.800
so you're familiar with this already K-1 one do two.

49

00:03:35.810  -->  00:03:39.990
And then you can call that K-1 and I'll bring out that value.

50

00:03:39.990  -->  00:03:44.610
So again something that's again pretty amazing here is that getting unsetting items in a dictionary

51

00:03:44.910  -->  00:03:46.580
are also in constant time.

52

00:03:46.590  -->  00:03:51.330
So hash tables are designed with efficiency in mind and we're going to explore them in a much more detail

53

00:03:51.330  -->  00:03:56.220
later on in this course since they're one of the most important data structures to understand.

54

00:03:56.220  -->  00:04:02.270
In the meantime here's a table with the big-O efficiencies of the most common dictionary operations

55

00:04:02.270  -->  00:04:03.530
.

56

00:04:03.570  -->  00:04:04.530
All right.

57

00:04:04.530  -->  00:04:09.570
So as I mentioned this is going to be a brief overview and by the end of this section and this section

58

00:04:09.570  -->  00:04:16.800
in general of big-O analysis which you have developed is an understanding of how big O is use an algorithm

59

00:04:16.800  -->  00:04:22.330
analysis and you should be able to work out the big O of an algorithm you've developed.

60

00:04:22.620  -->  00:04:23.310
OK.

61

00:04:23.520  -->  00:04:24.290
So get ready.

62

00:04:24.290  -->  00:04:29.340
There's a quiz up next to test your understanding and the quizzes are just going to consist of various

63

00:04:29.340  -->  00:04:36.750
code examples and it's a multiple choice to choose the correct big-O of the performance of that algorithm

64

00:04:36.760  -->  00:04:37.130
.

65

00:04:37.500  -->  00:04:38.640
OK.

66

00:04:38.640  -->  00:04:39.720
So just a quick overview.

67

00:04:39.720  -->  00:04:48.360
Keep in mind dictionaries and lists which are essentially hash tables and dynamic arrays how they work

68

00:04:48.510  -->  00:04:53.130
and just start wondering how they're able to do this so efficiently in constant time.

69

00:04:53.130  -->  00:04:57.780
We're going to go over how arrays and hash tables are actually able to do this when we construct them

70

00:04:57.780  -->  00:04:58.750
ourselves.

71

00:04:59.010  -->  00:05:01.100
But I just want you to be aware of that.

72

00:05:01.140  -->  00:05:01.760
All right.

73

00:05:02.040  -->  00:05:06.280
So if that being said Best of luck on the quiz and I'll see you at the next lecture.

74

00:05:06.510  -->  00:05:08.270
Thank you.
