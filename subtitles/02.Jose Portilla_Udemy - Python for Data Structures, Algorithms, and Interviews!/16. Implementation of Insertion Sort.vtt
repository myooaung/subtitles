WEBVTT
1

00:00:01.050  -->  00:00:06.010
Hello everyone and welcome to the implementation of insertion sort lecture.

2

00:00:06.030  -->  00:00:12.920
So just a quick reminder insertion sort builds that final sort of array or list one item at a time.

3

00:00:12.990  -->  00:00:18.390
It's much less efficient on large lists than more advanced algorithms such as quicksort heapsort or

4

00:00:18.390  -->  00:00:19.970
merge sort.

5

00:00:19.980  -->  00:00:25.350
So again here your resource for review in the company Jupiter notebook and here's a function that we're

6

00:00:25.350  -->  00:00:29.180
actually in a code out and go ahead and try ourselves.

7

00:00:29.190  -->  00:00:33.930
So let's go ahead and jump to the live code and check it out.

8

00:00:33.960  -->  00:00:38.580
First thing we're going to do start off for a function DPF and then we're going to go ahead and say

9

00:00:38.670  -->  00:00:39.880
insertion sort.

10

00:00:39.930  -->  00:00:47.850
So certain underscore sort and taken a r r which is going to be our array object in Python again.

11

00:00:47.870  -->  00:00:49.340
That's just a list.

12

00:00:49.380  -->  00:00:54.100
So first thing we're going to do is just go ahead and say for every index in array.

13

00:00:54.270  -->  00:01:04.850
So let's say for I in range and we'll start from 1 to the length of the array.

14

00:01:06.450  -->  00:01:11.880
And then we're going to do is go ahead a set current value and position so or create a variable in a

15

00:01:11.880  -->  00:01:21.470
call at current value and it's going to be basically that value at the current position and then going

16

00:01:21.470  -->  00:01:25.220
to make another variable called position and just call it.

17

00:01:25.230  -->  00:01:30.990
I now again I could just be calling these direcly throughout the algorithm but it's nice to have these

18

00:01:30.990  -->  00:01:31.850
variable names.

19

00:01:31.890  -->  00:01:35.460
So we really are super clear about what's going on.

20

00:01:35.880  -->  00:01:41.970
So then we're going to do is have our sorted sublist so you can go ahead and review the lecture case

21

00:01:41.970  -->  00:01:45.660
you want to remember what that sort of sublease looks like.

22

00:01:45.660  -->  00:01:52.110
That basically where we're going to do here scroll down a bit is say while position is greater than

23

00:01:52.110  -->  00:02:00.210
zero and the value at position minus 1.

24

00:02:00.210  -->  00:02:06.740
So that previous value essentially is greater than the current value.

25

00:02:08.280  -->  00:02:13.950
Well we're going to do is set the value at that current position.

26

00:02:13.950  -->  00:02:21.300
So position equals array position minus 1.

27

00:02:21.300  -->  00:02:23.150
So this is basically a switch right.

28

00:02:23.160  -->  00:02:30.680
And then if I say position equals position minus one I mean essentially just changing my position variable

29

00:02:31.380  -->  00:02:39.920
and then I'll set the array value at that position equal to the current value I'm on.

30

00:02:40.620  -->  00:02:42.240
OK and that's that's essentially it.

31

00:02:42.240  -->  00:02:44.640
That's the sort of sublists that we're creating here.

32

00:02:44.790  -->  00:02:45.990
And that's the insertion sort.

33

00:02:45.990  -->  00:02:50.150
So let's go in and run it make sure it all worked out and then we'll go again line by line.

34

00:02:50.160  -->  00:02:53.420
A quick review of what we've done so run that.

35

00:02:53.730  -->  00:02:55.580
And let's go ahead and take an array.

36

00:02:56.220  -->  00:03:03.060
We'll call this just a or are put in a bunch of numbers in any particular order we want since they are

37

00:03:03.060  -->  00:03:05.750
not going to be sorted yet.

38

00:03:06.000  -->  00:03:09.340

39
23:13 would say two.

40

00:03:10.110  -->  00:03:10.710
OK.

41

00:03:10.710  -->  00:03:13.540
And then we're going to say insertion sort.

42

00:03:14.070  -->  00:03:20.580
On that array and then call the array back again notice just as a reminder I don't have a return function

43

00:03:20.730  -->  00:03:25.820
anywhere in the wire or excuse me I don't have a return key word anywhere in my array.

44

00:03:25.950  -->  00:03:33.080
So I have to manually call it out when I say A are here to make sure it works ok.

45

00:03:33.090  -->  00:03:33.540
Awesome.

46

00:03:33.570  -->  00:03:35.290
We have our sorted array.

47

00:03:35.370  -->  00:03:37.910
So let's go ahead and go line by line one more time.

48

00:03:37.920  -->  00:03:41.130
What's actually happening here in our function that we just created.

49

00:03:41.130  -->  00:03:44.160
Let me zoom out so you can get the whole picture here.

50

00:03:44.220  -->  00:03:49.530
All right so looking at this code let's just remind ourselves that here in this implementation of insertion

51

00:03:49.530  -->  00:03:56.050
of sort showing here that there are again and minus one passes to sort and items.

52

00:03:56.280  -->  00:04:02.040
So that's why this iteration starts at position 1 and then moves all the way through position and minus

53

00:04:02.040  -->  00:04:02.340
1.

54

00:04:02.400  -->  00:04:07.690
Remember because indexing starts at zero and because of the way range works this is one.

55

00:04:07.880  -->  00:04:10.970
And this is actually and minus one.

56

00:04:10.990  -->  00:04:16.200
So there are well this is and but the actual range it put out is at minus 1.

57

00:04:16.200  -->  00:04:19.760
So let me just go ahead and make sure everyone is clear on that.

58

00:04:19.770  -->  00:04:30.370
So if I pass in range from one to link of R and I'll define our as just one two three.

59

00:04:30.500  -->  00:04:32.320
And you notice I get 1 2.

60

00:04:32.340  -->  00:04:35.380
So it goes from 1 to and minus one here.

61

00:04:36.090  -->  00:04:37.260
OK.

62

00:04:37.260  -->  00:04:44.520
So we can see that this line right here this is our array at that position.

63

00:04:44.520  -->  00:04:51.030
So the value of the array at that position equals array position minus 1.

64

00:04:51.240  -->  00:04:57.060
That's essentially performing that shift operation that moves the value up 1 position list making room

65

00:04:57.060  -->  00:04:59.100
behind it for the insertion.

66

00:04:59.100  -->  00:05:04.290
So remember that this is not a complete exchange as was performed in previous algorithms we've seen

67

00:05:04.290  -->  00:05:05.130
.

68

00:05:05.310  -->  00:05:10.530
So that means that the maximum number of comparisons for an insertion sort is the sum of the first and

69

00:05:10.530  -->  00:05:11.960
minus 1 integers.

70

00:05:11.970  -->  00:05:14.900
So again that means order and square.

71

00:05:14.940  -->  00:05:19.230
However in the best case only one comparison needs to be done at each pass.

72

00:05:19.290  -->  00:05:21.630
So this would be the case for an already sorted list.

73

00:05:21.640  -->  00:05:28.590
They happened to call this insertion sort algorithm on one know about shifting versus exchanging is

74

00:05:28.590  -->  00:05:29.670
also important.

75

00:05:29.850  -->  00:05:36.450
In general a shift operation requires approximately a third of the processing work of an exchange since

76

00:05:36.450  -->  00:05:39.090
only one assignment is performed.

77

00:05:39.090  -->  00:05:44.720
So in some benchmark studies insertion sort will actually show very good performance.

78

00:05:44.820  -->  00:05:52.680
So it might be nice for you to check out the Wikipedia link in the notebook and go ahead and learn about

79

00:05:52.680  -->  00:05:58.350
the pros and cons of a search sort in case that's a interview question later on.

80

00:05:58.350  -->  00:06:04.560
So it gives you again the algorithm here you can check it out gives you talks about sort of partial

81

00:06:04.560  -->  00:06:07.220
results those sublists that we're talking about.

82

00:06:07.600  -->  00:06:12.620
And I'll also give you information of Best Worst than average cases of a nice discussion here.

83

00:06:12.630  -->  00:06:14.670
They can prepare for your interviews with.

84

00:06:14.810  -->  00:06:15.840
OK.

85

00:06:16.050  -->  00:06:17.310
So those are the basics.

86

00:06:17.310  -->  00:06:19.600
And that's just the implementation of insertion sort.

87

00:06:19.740  -->  00:06:23.910
You can go and check out the previous lecture if you want to get a background on that theory but that's

88

00:06:23.910  -->  00:06:26.250
really all there is to the implementation.

89

00:06:26.250  -->  00:06:30.090
All right thanks everyone and I will see what the next lecture
