1
1

00:00:00,310  -->  00:00:02,893
(upbeat music)
2

2

00:00:05,240  -->  00:00:06,750
<v Sarah>If you've been working with Java</v>
3

3

00:00:06,750  -->  00:00:09,900
for any length of time, you'll be familiar with array list.
4

4

00:00:09,900  -->  00:00:12,090
It's pretty much the go to class
5

5

00:00:12,090  -->  00:00:14,870
when it comes to storing a collection of objects
6

6

00:00:14,870  -->  00:00:17,630
that you'll want to iterate over sequentially.
7

7

00:00:17,630  -->  00:00:19,250
So let's take a closer look at them
8

8

00:00:19,250  -->  00:00:21,750
by going over to the Java doc.
9

9

00:00:21,750  -->  00:00:26,060
If we scroll down and we read the documentation
10

10

00:00:26,060  -->  00:00:28,820
written by the developers of this class,
11

11

00:00:28,820  -->  00:00:30,340
we'll notice that it says this is
12

12

00:00:30,340  -->  00:00:35,310
a resizable array implementation of the list interface.
13

13

00:00:35,310  -->  00:00:37,090
Meaning that the data in the list
14

14

00:00:37,090  -->  00:00:39,260
is being stored in an array.
15

15

00:00:39,260  -->  00:00:42,270
And this array is called the backing array.
16

16

00:00:42,270  -->  00:00:44,240
Now this tells us a few things based
17

17

00:00:44,240  -->  00:00:45,810
on what we learned about arrays.
18

18

00:00:45,810  -->  00:00:48,550
If we know the position of an item in the list,
19

19

00:00:48,550  -->  00:00:50,130
accessing will be efficient.
20

20

00:00:50,130  -->  00:00:53,620
In fact, it'll be all of one or constant time
21

21

00:00:53,620  -->  00:00:56,960
because we know that if we have the index
22

22

00:00:56,960  -->  00:00:59,300
of the item that we want,
23

23

00:00:59,300  -->  00:01:03,100
then accessing the array element is all of one.
24

24

00:01:03,100  -->  00:01:05,760
So array lists are great if all you're going to do
25

25

00:01:05,760  -->  00:01:07,070
is iterate over them.
26

26

00:01:07,070  -->  00:01:09,790
Because in that case you're always going from
27

27

00:01:09,790  -->  00:01:12,130
index zero to the end of the list.
28

28

00:01:12,130  -->  00:01:13,397
So you know the indices of
29

29

00:01:13,397  -->  00:01:15,240
the items that you want to retrieve.
30

30

00:01:15,240  -->  00:01:18,610
But if you want to add a lot of items to an existing list,
31

31

00:01:18,610  -->  00:01:21,310
this will be slow if the size of the list
32

32

00:01:21,310  -->  00:01:23,680
isn't large enough to accommodate the new items.
33

33

00:01:23,680  -->  00:01:26,940
In other words, if the backing array is already full
34

34

00:01:26,940  -->  00:01:29,170
and you wanna add more items to the list,
35

35

00:01:29,170  -->  00:01:31,860
then you're going to have to resize that backing array.
36

36

00:01:31,860  -->  00:01:34,110
Well, you won't but the implementation
37

37

00:01:34,110  -->  00:01:35,930
of the array list class will.
38

38

00:01:35,930  -->  00:01:38,120
And also, removing items will be slow
39

39

00:01:38,120  -->  00:01:41,070
because we're gonna have to shift the remaining items
40

40

00:01:41,070  -->  00:01:43,230
to remove any empty space.
41

41

00:01:43,230  -->  00:01:44,995
So if you're going to be adding
42

42

00:01:44,995  -->  00:01:46,847
a lot of items into an array list,
43

43

00:01:46,847  -->  00:01:49,380
you want to have some idea of how many items
44

44

00:01:49,380  -->  00:01:51,450
are ultimately going to be on the list
45

45

00:01:51,450  -->  00:01:54,580
so you can create an array list instance with
46

46

00:01:54,580  -->  00:01:58,120
a capacity that will accommodate all the items.
47

47

00:01:58,120  -->  00:02:00,530
Otherwise, the array that's backing the list,
48

48

00:02:00,530  -->  00:02:02,340
that's actually storing the items,
49

49

00:02:02,340  -->  00:02:04,860
will have to be resized when it gets full
50

50

00:02:04,860  -->  00:02:07,160
and you wanna add more items to the list.
51

51

00:02:07,160  -->  00:02:08,913
Now as I said, you can ensure that the array
52

52

00:02:08,913  -->  00:02:12,030
will be large enough by specifying the capacity.
53

53

00:02:12,030  -->  00:02:15,130
And if we go down to the constructors,
54

54

00:02:15,130  -->  00:02:17,710
you'll see there's one that lets you
55

55

00:02:17,710  -->  00:02:19,700
specify the initial capacity.
56

56

00:02:19,700  -->  00:02:21,590
And it says it constructs an empty list
57

57

00:02:21,590  -->  00:02:23,040
with the specified capacity.
58

58

00:02:23,040  -->  00:02:25,040
What it's actually doing is
59

59

00:02:25,040  -->  00:02:26,750
the backing array that it creates
60

60

00:02:26,750  -->  00:02:29,080
will be of length initial capacity.
61

61

00:02:29,080  -->  00:02:30,540
Now when it comes to array lists,
62

62

00:02:30,540  -->  00:02:32,400
it's important to understand the difference
63

63

00:02:32,400  -->  00:02:34,550
between size and capacity.
64

64

00:02:34,550  -->  00:02:37,700
Capacity is the maximum number of items
65

65

00:02:37,700  -->  00:02:41,610
that the list can hold before it's gonna have to be resized,
66

66

00:02:41,610  -->  00:02:42,700
the backing array.
67

67

00:02:42,700  -->  00:02:44,700
The size is the number of items
68

68

00:02:44,700  -->  00:02:46,430
that are actually in the list.
69

69

00:02:46,430  -->  00:02:48,440
So if you create an array list
70

70

00:02:48,440  -->  00:02:52,290
with the capacity of 20 and you add three items to it,
71

71

00:02:52,290  -->  00:02:56,060
then the capacity is 20 and the size is three.
72

72

00:02:56,060  -->  00:02:58,840
And you'll notice up here, if you don't pass a capacity,
73

73

00:02:58,840  -->  00:03:01,200
you're gonna get an initial capacity of 10,
74

74

00:03:01,200  -->  00:03:02,510
which isn't a whole lot.
75

75

00:03:02,510  -->  00:03:05,350
So if you're gonna have more that 10 items on the list,
76

76

00:03:05,350  -->  00:03:08,370
you're better off specifying the capacity.
77

77

00:03:08,370  -->  00:03:10,950
Okay, so let's go over to the IDE
78

78

00:03:10,950  -->  00:03:13,103
and play around with array lists.
79

79

00:03:17,400  -->  00:03:19,020
So I've created a project
80

80

00:03:19,020  -->  00:03:21,470
and I'm putting, or I've put the code into
81

81

00:03:21,470  -->  00:03:23,990
academy.programming.arraylists.
82

82

00:03:23,990  -->  00:03:27,660
And I'm going to create an employee class,
83

83

00:03:27,660  -->  00:03:32,010
employee, so that we have something interesting to add to
84

84

00:03:32,010  -->  00:03:34,300
our lists that isn't just integers.
85

85

00:03:34,300  -->  00:03:38,370
So under the same package, I'll create a new java class
86

86

00:03:38,370  -->  00:03:41,073
and I'll call it employee.
87

87

00:03:43,550  -->  00:03:45,180
And we'll add a
88

88

00:03:47,350  -->  00:03:48,853
first name field,
89

89

00:03:50,270  -->  00:03:54,923
a last name field and we'll throw in an ID field as well.
90

90

00:03:55,920  -->  00:03:58,520
And now we can get the IDE to help us generate
91

91

00:03:58,520  -->  00:04:00,280
all the boiler plate code.
92

92

00:04:00,280  -->  00:04:02,230
So if I right click anywhere
93

93

00:04:02,230  -->  00:04:04,320
or where I want the code to go
94

94

00:04:04,320  -->  00:04:05,760
and I click generate,
95

95

00:04:05,760  -->  00:04:07,530
you'll see there's lot of choices here.
96

96

00:04:07,530  -->  00:04:09,900
So first of all, add a constructor.
97

97

00:04:09,900  -->  00:04:12,990
And I want all three fields to be handled by the constructor
98

98

00:04:12,990  -->  00:04:15,810
so I'll select them and click OK.
99

99

00:04:15,810  -->  00:04:18,370
And now we have our standard constructor
100

100

00:04:18,370  -->  00:04:20,410
that just takes the parameters it's passed
101

101

00:04:20,410  -->  00:04:23,260
and assigns them into the number fields.
102

102

00:04:23,260  -->  00:04:25,580
And of course we want sets and gets for these
103

103

00:04:25,580  -->  00:04:26,440
'cause they're private.
104

104

00:04:26,440  -->  00:04:28,610
So once again, we'll right click,
105

105

00:04:28,610  -->  00:04:32,040
we'll say generate and we want getter and setter.
106

106

00:04:32,040  -->  00:04:33,930
And once again, I want getters and setters
107

107

00:04:33,930  -->  00:04:35,400
generated for all the fields.
108

108

00:04:35,400  -->  00:04:37,553
So I'll select all of them and click OK.
109

109

00:04:38,420  -->  00:04:40,810
And now we have the standard sets and gets.
110

110

00:04:40,810  -->  00:04:42,290
And finally,
111

111

00:04:42,290  -->  00:04:44,910
I'd like a two string method generated.
112

112

00:04:44,910  -->  00:04:47,312
I wanna override the default because when we print
113

113

00:04:47,312  -->  00:04:49,830
an employee instance, I'd like to see
114

114

00:04:49,830  -->  00:04:51,410
first name, last name, and ID.
115

115

00:04:51,410  -->  00:04:53,330
I don't just wanna see the object reference.
116

116

00:04:53,330  -->  00:04:55,600
So I'll right click,
117

117

00:04:55,600  -->  00:04:59,080
go to generate, and I wanna a two string method.
118

118

00:04:59,080  -->  00:05:01,840
I want all the fields and here we go.
119

119

00:05:01,840  -->  00:05:04,660
We have a nice two string method.
120

120

00:05:04,660  -->  00:05:07,700
And so the IDE gave us quite a bit of help there.
121

121

00:05:07,700  -->  00:05:09,540
Just by right clicking and go to generate
122

122

00:05:09,540  -->  00:05:12,290
we can get all the boiler plate code that we need.
123

123

00:05:12,290  -->  00:05:13,780
So now that we have this class,
124

124

00:05:13,780  -->  00:05:16,290
let's go back to our main method.
125

125

00:05:16,290  -->  00:05:19,300
So we want a list so I'm gonna say list employee.
126

126

00:05:19,300  -->  00:05:22,810
Now the reason I'm saying list rather than array list
127

127

00:05:22,810  -->  00:05:26,950
is by using list, if I decide later
128

128

00:05:26,950  -->  00:05:29,290
that I want to use a different type of list,
129

129

00:05:29,290  -->  00:05:32,530
it's easy to change the specific implementation
130

130

00:05:32,530  -->  00:05:33,800
of list that I'm using.
131

131

00:05:33,800  -->  00:05:36,490
So I'm gonna call this employee list
132

132

00:05:36,490  -->  00:05:39,970
and I'm going to create a new array list.
133

133

00:05:39,970  -->  00:05:42,380
And I'm not going to specify capacity
134

134

00:05:42,380  -->  00:05:44,310
because I'm only gonna add four employees
135

135

00:05:44,310  -->  00:05:47,340
and as we saw, the default capacity is 10.
136

136

00:05:47,340  -->  00:05:51,083
So I'm not gonna worry about the array having to be resized.
137

137

00:05:51,940  -->  00:05:53,480
So I got a couple of errors here.
138

138

00:05:53,480  -->  00:05:57,350
First of all, there are multiple possibilities for list
139

139

00:05:57,350  -->  00:05:59,710
because there's more than one list class.
140

140

00:05:59,710  -->  00:06:03,110
So IntelliJ wants me to tell it which one I want
141

141

00:06:03,110  -->  00:06:05,576
and I want java.util.
142

142

00:06:05,576  -->  00:06:09,480
And here it's telling me that diamond types aren't supported
143

143

00:06:09,480  -->  00:06:11,350
at language level 1.6.
144

144

00:06:11,350  -->  00:06:13,230
And if you get something like that,
145

145

00:06:13,230  -->  00:06:16,310
it means that right now for some reason,
146

146

00:06:16,310  -->  00:06:19,410
I'm not sure why it does this because I've specified
147

147

00:06:19,410  -->  00:06:21,210
the JVK is Java nine,
148

148

00:06:21,210  -->  00:06:23,570
it thinks I'm using Java 1.6.
149

149

00:06:23,570  -->  00:06:25,460
So to get rid of that,
150

150

00:06:25,460  -->  00:06:28,810
click here and say set my language level to seven,
151

151

00:06:28,810  -->  00:06:30,740
'cause that supports the diamond.
152

152

00:06:30,740  -->  00:06:32,430
And so now all the errors are gone.
153

153

00:06:32,430  -->  00:06:33,850
So if you get something like that,
154

154

00:06:33,850  -->  00:06:35,270
just wait for the light bulb to come up
155

155

00:06:35,270  -->  00:06:37,030
and then have it set the language level
156

156

00:06:37,030  -->  00:06:38,700
to a higher language level.
157

157

00:06:38,700  -->  00:06:41,010
Okay, so getting back to why I use list here,
158

158

00:06:41,010  -->  00:06:43,830
if I decided I wanted to use a different type of list,
159

159

00:06:43,830  -->  00:06:46,860
I could just replace the specific class
160

160

00:06:46,860  -->  00:06:49,270
that I'm using when I create the instance
161

161

00:06:49,270  -->  00:06:50,560
and this will still work.
162

162

00:06:50,560  -->  00:06:52,780
Because as long as the class that I'm using
163

163

00:06:52,780  -->  00:06:56,063
implements the list interface, the compilers happy.
164

164

00:06:57,210  -->  00:06:58,850
Okay, so now that we have our list,
165

165

00:06:58,850  -->  00:07:00,300
let's add a few employees.
166

166

00:07:00,300  -->  00:07:03,890
So I'll say employee.add, this is how we add
167

167

00:07:03,890  -->  00:07:05,130
an item into our list.
168

168

00:07:05,130  -->  00:07:06,893
And I'll say new employee.
169

169

00:07:07,990  -->  00:07:11,463
Our first employee will be Jane Jones.
170

170

00:07:12,750  -->  00:07:15,193
And she'll have an ID of 123.
171

171

00:07:17,530  -->  00:07:18,973
Let's add another one.
172

172

00:07:21,580  -->  00:07:23,463
And we'll say John Doe.
173

173

00:07:25,420  -->  00:07:27,610
And his ID is 4567.
174

174

00:07:32,080  -->  00:07:33,130
We'll add
175

175

00:07:37,410  -->  00:07:38,303
Mary Smith.
176

176

00:07:42,470  -->  00:07:44,720
And her ID will be 22.
177

177

00:07:44,720  -->  00:07:46,810
And finally we'll add
178

178

00:07:51,900  -->  00:07:53,083
Mike Wilson.
179

179

00:07:56,470  -->  00:08:00,320
And he'll have an ID of 3245.
180

180

00:08:00,320  -->  00:08:02,200
And I think I'm missing a parenthesis here
181

181

00:08:02,200  -->  00:08:03,540
so I'll just add that.
182

182

00:08:03,540  -->  00:08:05,520
So as I said, what's happening under the covers
183

183

00:08:05,520  -->  00:08:07,140
when we call the array list constructor
184

184

00:08:07,140  -->  00:08:09,250
is creating a backing array of 10.
185

185

00:08:09,250  -->  00:08:12,170
'Cause we saw that the default capacity,
186

186

00:08:12,170  -->  00:08:14,480
if we don't specify one, is 10.
187

187

00:08:14,480  -->  00:08:17,270
So we only have four employees so that's okay.
188

188

00:08:17,270  -->  00:08:20,740
It means that when we added our employees,
189

189

00:08:20,740  -->  00:08:23,510
the backing array didn't have to be resized.
190

190

00:08:23,510  -->  00:08:26,290
And let's go look at the add methods.
191

191

00:08:26,290  -->  00:08:28,320
I'm gonna select it, right click
192

192

00:08:28,320  -->  00:08:31,210
and say go to the declaration.
193

193

00:08:31,210  -->  00:08:33,130
And this is actually on the interface.
194

194

00:08:33,130  -->  00:08:34,620
I want to go to the implementation
195

195

00:08:34,620  -->  00:08:37,720
so I'm going to come here and click on the I
196

196

00:08:37,720  -->  00:08:41,760
and I'm going to select the arraylist.add implementation,
197

197

00:08:41,760  -->  00:08:42,810
because that's what we're using.
198

198

00:08:42,810  -->  00:08:45,360
And so here we are in the actual code.
199

199

00:08:45,360  -->  00:08:47,723
And now let's go to that implementation.
200

200

00:08:49,670  -->  00:08:51,770
And so this is where the work's actually done
201

201

00:08:51,770  -->  00:08:53,440
and we'll see that the first thing it does
202

202

00:08:53,440  -->  00:08:56,760
is checks to see whether the backing array is full.
203

203

00:08:56,760  -->  00:08:59,930
And so it checks to see whether the number of items, S,
204

204

00:08:59,930  -->  00:09:03,610
that's in the array are equal to the array's lengths.
205

205

00:09:03,610  -->  00:09:06,210
Because if that's true then the array is full
206

206

00:09:06,210  -->  00:09:09,320
and so it needs to grow the array, it has to resize it.
207

207

00:09:09,320  -->  00:09:10,640
And then after it's done that,
208

208

00:09:10,640  -->  00:09:12,640
it'll assign the item
209

209

00:09:12,640  -->  00:09:14,850
and then of course, it gonna increase the size
210

210

00:09:14,850  -->  00:09:17,220
because as I discussed earlier,
211

211

00:09:17,220  -->  00:09:19,410
the capacity is the maximum number of items
212

212

00:09:19,410  -->  00:09:21,510
that can be stored in the array,
213

213

00:09:21,510  -->  00:09:22,980
basically the array's length,
214

214

00:09:22,980  -->  00:09:25,250
and the size is the actual number
215

215

00:09:25,250  -->  00:09:26,840
of items we've added to it.
216

216

00:09:26,840  -->  00:09:29,430
Okay, so an array list is backed by an array.
217

217

00:09:29,430  -->  00:09:31,100
So why don't we just use an array?
218

218

00:09:31,100  -->  00:09:32,950
Why are we using array list?
219

219

00:09:32,950  -->  00:09:35,300
Well, because array list has a bunch of methods
220

220

00:09:35,300  -->  00:09:37,160
that let you work with the list items.
221

221

00:09:37,160  -->  00:09:40,040
And so the code to do this has been written for you.
222

222

00:09:40,040  -->  00:09:42,890
You don't have to directly work on the array.
223

223

00:09:42,890  -->  00:09:45,540
Also, array list implements the list interface
224

224

00:09:45,540  -->  00:09:47,160
and so as I mentioned earlier,
225

225

00:09:47,160  -->  00:09:49,200
you can swap to another type of list
226

226

00:09:49,200  -->  00:09:50,680
that uses the list interface
227

227

00:09:50,680  -->  00:09:54,930
without too much disruption of the existing code.
228

228

00:09:54,930  -->  00:09:57,800
So let's go back to our main method
229

229

00:09:57,800  -->  00:10:00,653
and look at some of the methods that array list offers.
230

230

00:10:00,653  -->  00:10:02,980
We've seen how we can add items,
231

231

00:10:02,980  -->  00:10:04,420
let's print the items on the list.
232

232

00:10:04,420  -->  00:10:07,880
So we can say employeelist.foreach
233

233

00:10:09,080  -->  00:10:10,910
and then we'll say employee
234

234

00:10:13,290  -->  00:10:16,073
system.out.printlineemployee.
235

235

00:10:18,440  -->  00:10:19,930
And now it wants, I have to move up
236

236

00:10:19,930  -->  00:10:22,627
to language level eight because it wants lambdas.
237

237

00:10:22,627  -->  00:10:24,520
We need Java eight for lambdas.
238

238

00:10:24,520  -->  00:10:26,730
So this is a lambda expression
239

239

00:10:26,730  -->  00:10:31,520
and for each employee in the list,
240

240

00:10:31,520  -->  00:10:33,920
we're going to print that employee out.
241

241

00:10:33,920  -->  00:10:36,250
Now I could've just used a loop
242

242

00:10:36,250  -->  00:10:37,400
and loop through the list
243

243

00:10:37,400  -->  00:10:39,800
but this is more concise.
244

244

00:10:39,800  -->  00:10:41,033
So if we run now.
245

245

00:10:45,480  -->  00:10:46,820
Here are employees
246

246

00:10:46,820  -->  00:10:48,090
and we're getting the nice print out
247

247

00:10:48,090  -->  00:10:52,670
because remember we used the IDE to override the two string.
248

248

00:10:52,670  -->  00:10:54,530
So here are our employees
249

249

00:10:54,530  -->  00:10:56,680
and it was easy for us to just go ahead,
250

250

00:10:56,680  -->  00:10:59,770
call one method and iterate through the list.
251

251

00:10:59,770  -->  00:11:03,393
So let's now get the second employee in the list.
252

252

00:11:05,170  -->  00:11:06,980
And so just like with arrays,
253

253

00:11:06,980  -->  00:11:10,130
the index is zero based when we're working with array lists.
254

254

00:11:10,130  -->  00:11:12,840
And that's surprising because we now know array list
255

255

00:11:12,840  -->  00:11:14,600
is backed by array.
256

256

00:11:14,600  -->  00:11:17,630
So if we want to print out the second employee,
257

257

00:11:17,630  -->  00:11:19,150
we just say employeelist.get1
258

258

00:11:22,410  -->  00:11:25,690
because the second employee will be at index one.
259

259

00:11:25,690  -->  00:11:29,020
So we'll run and we should see John Doe come up
260

260

00:11:29,020  -->  00:11:30,710
and John Doe does.
261

261

00:11:30,710  -->  00:11:33,070
These four are from the four each col
262

262

00:11:33,070  -->  00:11:35,850
and then we have John Doe being printed out from here.
263

263

00:11:35,850  -->  00:11:39,030
And as we know, because an array is backing the array list,
264

264

00:11:39,030  -->  00:11:42,470
this get col, when we actually access the employee,
265

265

00:11:42,470  -->  00:11:44,260
is done in constant time.
266

266

00:11:44,260  -->  00:11:47,650
Because an array is backing the list,
267

267

00:11:47,650  -->  00:11:52,040
random access like this, where we just provide an index,
268

268

00:11:52,040  -->  00:11:53,900
is done in constant time.
269

269

00:11:53,900  -->  00:11:56,860
The time complexity doesn't depend on the size of the list.
270

270

00:11:56,860  -->  00:11:59,060
So array lists are great when you want to load
271

271

00:11:59,060  -->  00:12:01,610
a bunch of data and then access it like this.
272

272

00:12:01,610  -->  00:12:04,460
Now we also can check to see if a list is empty.
273

273

00:12:04,460  -->  00:12:05,800
So we can say
274

274

00:12:07,200  -->  00:12:08,660
system.out.printline
275

275

00:12:11,153  -->  00:12:12,930
employeelist.isempty.
276

276

00:12:12,930  -->  00:12:15,790
Now we expect false because the list isn't empty
277

277

00:12:15,790  -->  00:12:16,993
so let's run,
278

278

00:12:18,180  -->  00:12:20,120
and sure enough, we get false.
279

279

00:12:20,120  -->  00:12:21,650
Okay now another thing we can do
280

280

00:12:21,650  -->  00:12:25,370
is we can replace the employee at a specific position
281

281

00:12:25,370  -->  00:12:26,850
with another employee.
282

282

00:12:26,850  -->  00:12:30,140
So lets replace John Doe with John Adams.
283

283

00:12:30,140  -->  00:12:35,060
So to do that we just have to say employeelist.set,
284

284

00:12:35,060  -->  00:12:37,760
so we're not gonna use add here.
285

285

00:12:37,760  -->  00:12:40,960
And the first parameter is the index
286

286

00:12:40,960  -->  00:12:42,980
of the employee that we want to replace
287

287

00:12:42,980  -->  00:12:47,640
and we're gonna replace John Doe with a new employee John
288

288

00:12:49,210  -->  00:12:50,043
Adams.
289

289

00:12:50,043  -->  00:12:54,823
And John Adams has an ID of 4568.
290

290

00:12:56,160  -->  00:12:58,700
And now if I comment out,
291

291

00:12:58,700  -->  00:13:02,303
I'm gonna comment out all of the prints we've done so far.
292

292

00:13:03,210  -->  00:13:07,863
And I'm going to copy the print that prints the entire list.
293

293

00:13:10,260  -->  00:13:11,313
And let's run.
294

294

00:13:13,370  -->  00:13:17,010
And we'll see for the second employee is now John Adams,
295

295

00:13:17,010  -->  00:13:18,370
it's no long John Doe.
296

296

00:13:18,370  -->  00:13:20,960
So if you wanna add an employee to the list
297

297

00:13:20,960  -->  00:13:22,240
or add an item to the list
298

298

00:13:22,240  -->  00:13:24,170
and it's always added to the end of the list,
299

299

00:13:24,170  -->  00:13:25,550
you use the add method.
300

300

00:13:25,550  -->  00:13:28,860
If you want to replace an item in the list,
301

301

00:13:28,860  -->  00:13:30,630
you use the set method.
302

302

00:13:30,630  -->  00:13:34,955
Now because random access is all of one setting,
303

303

00:13:34,955  -->  00:13:38,320
an employee will happen in constant time.
304

304

00:13:38,320  -->  00:13:40,180
As long as you're providing the index,
305

305

00:13:40,180  -->  00:13:43,760
whatever operation you're performing will perform
306

306

00:13:43,760  -->  00:13:48,010
with a time complexity of constant time over the one.
307

307

00:13:48,010  -->  00:13:50,480
Now if you want to get the number of items in the list,
308

308

00:13:50,480  -->  00:13:53,363
that would be the size, we can do that.
309

309

00:13:55,210  -->  00:13:58,220
So we'll just say employeelist.size.
310

310

00:13:58,220  -->  00:14:00,610
And remember, this won't give us the capacity,
311

311

00:14:00,610  -->  00:14:04,050
the capacity is the total number of items this list
312

312

00:14:04,050  -->  00:14:05,440
can currently hold.
313

313

00:14:05,440  -->  00:14:07,570
That's the length of the backing array.
314

314

00:14:07,570  -->  00:14:09,310
This will tell us how many employees
315

315

00:14:09,310  -->  00:14:11,330
we've actually added to the list.
316

316

00:14:11,330  -->  00:14:12,343
So let's run.
317

317

00:14:13,550  -->  00:14:15,440
And we'll see four, which is what we expect.
318

318

00:14:15,440  -->  00:14:17,540
'Cause we have four employees on the list.
319

319

00:14:17,540  -->  00:14:19,980
Now as I just said, the add method
320

320

00:14:19,980  -->  00:14:21,503
adds items to the end of the list.
321

321

00:14:21,503  -->  00:14:22,820
What if you don't want that?
322

322

00:14:22,820  -->  00:14:26,330
What if you want to add an employee at a specific position?
323

323

00:14:26,330  -->  00:14:29,090
Well, if you wanna do that you can also use the add method
324

324

00:14:29,090  -->  00:14:32,260
but you have provide more parameters.
325

325

00:14:32,260  -->  00:14:35,530
So if we wanted to add John Doe back in
326

326

00:14:35,530  -->  00:14:38,630
but we wanted to add him at index three,
327

327

00:14:38,630  -->  00:14:41,750
so we wanted him to be the fourth employee,
328

328

00:14:41,750  -->  00:14:43,850
we'll say employeelist.add
329

329

00:14:44,750  -->  00:14:47,190
and this time we need to provide an index
330

330

00:14:47,190  -->  00:14:50,640
as well as the instance we want to add.
331

331

00:14:50,640  -->  00:14:52,050
So we'll say John
332

332

00:14:53,320  -->  00:14:56,913
Doe and 4567.
333

333

00:14:58,710  -->  00:15:00,450
And if we now print our list again,
334

334

00:15:00,450  -->  00:15:01,923
so I'll grab this.
335

335

00:15:04,555  -->  00:15:06,423
And copy it here, let's run.
336

336

00:15:08,560  -->  00:15:12,360
And we'll see that John Doe has been added at index three.
337

337

00:15:12,360  -->  00:15:14,430
Now you've provided an index
338

338

00:15:14,430  -->  00:15:17,630
but because in this case you're sticking him
339

339

00:15:17,630  -->  00:15:19,660
in the middle of values,
340

340

00:15:19,660  -->  00:15:22,660
some values are gonna have to be shifted up.
341

341

00:15:22,660  -->  00:15:25,160
So the worst case for this would actually be o of n
342

342

00:15:25,160  -->  00:15:27,160
because the worst case would be
343

343

00:15:27,160  -->  00:15:29,210
you'd want to put him right at the beginning of the array
344

344

00:15:29,210  -->  00:15:31,670
and then all the other elements have to be shifted.
345

345

00:15:31,670  -->  00:15:34,280
And let's go to the source code to look at that.
346

346

00:15:34,280  -->  00:15:36,740
So we'll saw go to
347

347

00:15:36,740  -->  00:15:39,980
the declaration and I want the implementation
348

348

00:15:39,980  -->  00:15:42,150
for array list.
349

349

00:15:42,150  -->  00:15:44,700
And you'll see here, this is the array copy,
350

350

00:15:44,700  -->  00:15:45,980
this is the shifting.
351

351

00:15:45,980  -->  00:15:48,800
So depending on where you want to put him,
352

352

00:15:48,800  -->  00:15:51,470
elements are gonna have to be shifted in the array.
353

353

00:15:51,470  -->  00:15:55,100
And that's what causes this particular operation to be
354

354

00:15:55,100  -->  00:15:57,540
a linear time operation.
355

355

00:15:57,540  -->  00:15:59,550
Alright, back in our code,
356

356

00:15:59,550  -->  00:16:03,277
if we want the array, let's say we have a list
357

357

00:16:03,277  -->  00:16:05,800
and we're saying okay, well give us that backing array.
358

358

00:16:05,800  -->  00:16:08,810
Give us the array that's holding the employees,
359

359

00:16:08,810  -->  00:16:11,270
we can get that by calling the to array method.
360

360

00:16:11,270  -->  00:16:14,150
But we're not going to get an employee array.
361

361

00:16:14,150  -->  00:16:16,200
We'll get an object array.
362

362

00:16:16,200  -->  00:16:17,860
So we'll say object
363

363

00:16:19,950  -->  00:16:24,370
employee array equals employeelist.toarray.
364

364

00:16:24,370  -->  00:16:26,270
Now if we want an employee array,
365

365

00:16:26,270  -->  00:16:28,262
we can get it but then we have to tell
366

366

00:16:28,262  -->  00:16:31,100
the compiler that that's what we want.
367

367

00:16:31,100  -->  00:16:34,240
And to do that, we pass an array of the type we want.
368

368

00:16:34,240  -->  00:16:36,440
So instead of just calling the to array method
369

369

00:16:36,440  -->  00:16:39,820
and not passing anything, we would change this call
370

370

00:16:39,820  -->  00:16:43,840
to say new employee and the length that we want
371

371

00:16:43,840  -->  00:16:48,270
is employeelist.size because the size method
372

372

00:16:48,270  -->  00:16:51,630
will return how many employees we actually added.
373

373

00:16:51,630  -->  00:16:55,060
And so we just needed an array of that length.
374

374

00:16:55,060  -->  00:16:56,990
And then when we get that array back,
375

375

00:16:56,990  -->  00:16:58,460
let's print out
376

376

00:17:00,560  -->  00:17:01,393
the element.
377

377

00:17:01,393  -->  00:17:03,420
So we'll say for employee,
378

378

00:17:03,420  -->  00:17:06,133
employee in the employee's array,
379

379

00:17:07,530  -->  00:17:09,233
or employee array, rather.
380

380

00:17:10,880  -->  00:17:12,980
And I'll change this to employee now
381

381

00:17:12,980  -->  00:17:14,083
'cause we can do that.
382

382

00:17:15,640  -->  00:17:17,243
We'll just print the employee.
383

383

00:17:20,940  -->  00:17:23,900
So let me comment out the other print
384

384

00:17:23,900  -->  00:17:26,730
so we don't get confused with what we're looking at.
385

385

00:17:26,730  -->  00:17:28,203
And let's run this.
386

386

00:17:30,620  -->  00:17:32,570
And I think there must be one more print,
387

387

00:17:32,570  -->  00:17:33,860
yep, here it is.
388

388

00:17:33,860  -->  00:17:35,853
Let me comment that out, run again.
389

389

00:17:36,800  -->  00:17:40,340
And now here's the print coming from the employee array.
390

390

00:17:40,340  -->  00:17:43,320
And so we get the five employees that we had in the list
391

391

00:17:43,320  -->  00:17:46,580
but we now have them in an employee array instead.
392

392

00:17:46,580  -->  00:17:49,690
Now if you want to know if the list contains an instance,
393

393

00:17:49,690  -->  00:17:51,490
you can call the contains method
394

394

00:17:51,490  -->  00:17:54,490
to check whether the list contains an employee.
395

395

00:17:54,490  -->  00:17:57,040
So let's go ahead and do that.
396

396

00:17:57,040  -->  00:17:59,830
So that's system.out.printline
397

397

00:17:59,830  -->  00:18:04,100
and we wanna check employeelist.contains
398

398

00:18:04,100  -->  00:18:06,150
and we have to pass
399

399

00:18:07,040  -->  00:18:08,300
the object we're looking for.
400

400

00:18:08,300  -->  00:18:11,340
Now we don't have that instance because
401

401

00:18:11,340  -->  00:18:13,070
we didn't save Mary anywhere
402

402

00:18:13,070  -->  00:18:16,263
so we'll have to ask for Mary again.
403

403

00:18:18,630  -->  00:18:22,453
And her ID was 22.
404

404

00:18:24,570  -->  00:18:25,633
And let's run.
405

405

00:18:28,150  -->  00:18:29,990
And you'll see that we get false.
406

406

00:18:29,990  -->  00:18:32,670
Now maybe we're expecting true, maybe you weren't.
407

407

00:18:32,670  -->  00:18:34,740
And the reason you get false is because
408

408

00:18:34,740  -->  00:18:37,740
we haven't implemented the equals method
409

409

00:18:37,740  -->  00:18:39,160
in the employee class.
410

410

00:18:39,160  -->  00:18:41,340
So because there's no equals method,
411

411

00:18:41,340  -->  00:18:43,490
what this method is doing is actually checking
412

412

00:18:43,490  -->  00:18:46,830
to see if they're the exact same instance
413

413

00:18:46,830  -->  00:18:49,900
because that's what the default equals method does.
414

414

00:18:49,900  -->  00:18:52,350
The one that's all the way back in object.
415

415

00:18:52,350  -->  00:18:54,650
And they're not the exact same instance.
416

416

00:18:54,650  -->  00:18:56,630
We created an instance here
417

417

00:18:56,630  -->  00:18:58,480
and we created an instance here.
418

418

00:18:58,480  -->  00:19:00,810
So there are two distinct instances.
419

419

00:19:00,810  -->  00:19:03,670
Now they're structurally the same,
420

420

00:19:03,670  -->  00:19:07,370
meaning that all their fields contain the same values
421

421

00:19:07,370  -->  00:19:09,950
and so we think they should be equal.
422

422

00:19:09,950  -->  00:19:11,680
That if we're looking for an employee
423

423

00:19:11,680  -->  00:19:14,470
with the first name Mary, the last name Smith
424

424

00:19:14,470  -->  00:19:18,050
and the ID 22, we know we have an employee like that
425

425

00:19:18,050  -->  00:19:20,890
in the list but we have to implement the equals method
426

426

00:19:20,890  -->  00:19:24,710
in the employees class so that it's going to compare
427

427

00:19:24,710  -->  00:19:27,030
the individual fields against each other.
428

428

00:19:27,030  -->  00:19:29,300
So let's go to our employee class
429

429

00:19:29,300  -->  00:19:30,620
and I'll just put the code here.
430

430

00:19:30,620  -->  00:19:33,470
And once again, we can get the IDE to do this for us.
431

431

00:19:33,470  -->  00:19:35,160
So I'll say generate.
432

432

00:19:35,160  -->  00:19:37,550
Now it's going to create the hash code method for us too
433

433

00:19:37,550  -->  00:19:39,740
because whenever you override the equals method,
434

434

00:19:39,740  -->  00:19:42,320
you should really be overriding hash code as well.
435

435

00:19:42,320  -->  00:19:43,343
So that's fine.
436

436

00:19:44,670  -->  00:19:47,550
We can just accept all the defaults here.
437

437

00:19:47,550  -->  00:19:48,700
I'm gonna select these two
438

438

00:19:48,700  -->  00:19:51,400
and say first name and last name should never be null.
439

439

00:19:52,360  -->  00:19:53,990
And now we have an equals method.
440

440

00:19:53,990  -->  00:19:56,270
So if we go back to our main method and run again,
441

441

00:19:56,270  -->  00:19:57,423
we should see true.
442

442

00:19:58,330  -->  00:19:59,400
And we do.
443

443

00:19:59,400  -->  00:20:02,780
Because now the equals method in the employee class
444

444

00:20:02,780  -->  00:20:06,070
is actually looking at the values in the fields.
445

445

00:20:06,070  -->  00:20:07,990
Now that we have the equals method,
446

446

00:20:07,990  -->  00:20:11,880
we can make use of the index of method.
447

447

00:20:11,880  -->  00:20:14,820
And this will look up an employee in the list
448

448

00:20:14,820  -->  00:20:18,780
and tell us what index that employee is occupying.
449

449

00:20:18,780  -->  00:20:20,963
So let's look at for John Doe.
450

450

00:20:22,300  -->  00:20:25,436
So let's say system.out.printline
451

451

00:20:25,436  -->  00:20:29,620
employeelist.indexof and once again,
452

452

00:20:29,620  -->  00:20:31,990
because we didn't save a reference to John Doe,
453

453

00:20:31,990  -->  00:20:36,340
we'll just create an instance with the values
454

454

00:20:36,340  -->  00:20:38,573
and his ID is 4567.
455

455

00:20:40,370  -->  00:20:42,700
And because we implemented the equals method,
456

456

00:20:42,700  -->  00:20:44,640
this should find John Doe.
457

457

00:20:44,640  -->  00:20:46,530
It'll find the employee that has
458

458

00:20:46,530  -->  00:20:49,083
the same values in the fields.
459

459

00:20:51,140  -->  00:20:52,130
And it does.
460

460

00:20:52,130  -->  00:20:55,000
It says he's at index three and we know that's true
461

461

00:20:55,000  -->  00:20:58,090
because we specifically added him at index three.
462

462

00:20:58,090  -->  00:21:01,020
Now the contains and index of methods
463

463

00:21:01,020  -->  00:21:03,600
are only as good as the search algorithm
464

464

00:21:03,600  -->  00:21:05,290
being used to search the array.
465

465

00:21:05,290  -->  00:21:09,680
In other words, when we're looking something up in the list,
466

466

00:21:09,680  -->  00:21:12,897
the method that we're using has to search the list.
467

467

00:21:12,897  -->  00:21:14,640
And the way it's searching the list
468

468

00:21:14,640  -->  00:21:17,530
will determine whether the index of
469

469

00:21:17,530  -->  00:21:20,480
and contains method are fast or slow.
470

470

00:21:20,480  -->  00:21:22,200
And we'll be looking at search algorithms
471

471

00:21:22,200  -->  00:21:23,800
later in the course.
472

472

00:21:23,800  -->  00:21:25,580
Alright, so the last thing I want to show you
473

473

00:21:25,580  -->  00:21:28,410
is how to remove items from the list.
474

474

00:21:28,410  -->  00:21:30,080
Let's remove the third employee,
475

475

00:21:30,080  -->  00:21:32,040
that's gonna be Mary.
476

476

00:21:32,040  -->  00:21:35,990
So we'll say employeelist.remove
477

477

00:21:35,990  -->  00:21:38,040
and we're gonna pass two
478

478

00:21:38,040  -->  00:21:39,900
because we wanna remove the third employee.
479

479

00:21:39,900  -->  00:21:43,150
We could also pass an instance of her if we wanted to
480

480

00:21:43,150  -->  00:21:45,020
but this is actually faster
481

481

00:21:45,020  -->  00:21:47,340
because we're providing the index.
482

482

00:21:47,340  -->  00:21:50,070
And once we've done that, let's print out the list.
483

483

00:21:50,070  -->  00:21:52,610
I'll comment this out so we're not printing out
484

484

00:21:52,610  -->  00:21:55,690
a bunch of stuff from the array.
485

485

00:21:55,690  -->  00:21:58,533
And I'm gonna copy this line,
486

486

00:21:59,500  -->  00:22:01,400
that prints out our list.
487

487

00:22:01,400  -->  00:22:02,363
And let's run.
488

488

00:22:04,700  -->  00:22:07,230
And we'll see that Mary is no longer in our list.
489

489

00:22:07,230  -->  00:22:09,490
We just have four employees now.
490

490

00:22:09,490  -->  00:22:12,350
Now because we're dealing with an array in the background,
491

491

00:22:12,350  -->  00:22:14,660
remove can be expensive because elements
492

492

00:22:14,660  -->  00:22:16,320
after the one we removed have
493

493

00:22:16,320  -->  00:22:18,190
to be shifted down one position.
494

494

00:22:18,190  -->  00:22:19,600
So if we take a look at that,
495

495

00:22:19,600  -->  00:22:21,220
if we go to the source code
496

496

00:22:25,320  -->  00:22:28,630
and I want the source code for array list,
497

497

00:22:28,630  -->  00:22:31,790
we'll see here that this is an array copy
498

498

00:22:31,790  -->  00:22:34,070
and that's what's doing the shifting.
499

499

00:22:34,070  -->  00:22:38,550
If it has shift elements down to occupy
500

500

00:22:38,550  -->  00:22:41,880
the empty space left by the one that we removed.
501

501

00:22:41,880  -->  00:22:43,780
Okay, so there are a few more methods
502

502

00:22:43,780  -->  00:22:44,950
in the array list class
503

503

00:22:44,950  -->  00:22:47,290
but I'm going to leave you to explore them on your own.
504

504

00:22:47,290  -->  00:22:50,070
For a lot of you, this may have been a review
505

505

00:22:50,070  -->  00:22:53,200
but I just wanted to show some of you the methods
506

506

00:22:53,200  -->  00:22:56,010
and operations you can do on array lists.
507

507

00:22:56,010  -->  00:22:58,790
So array list is good for random access
508

508

00:22:58,790  -->  00:23:00,080
if you have the index
509

509

00:23:00,080  -->  00:23:03,470
and it's good for iterating over the items in the list
510

510

00:23:03,470  -->  00:23:07,970
but it's not so good for inserting items into
511

511

00:23:07,970  -->  00:23:12,030
the list in any position other than the end.
512

512

00:23:12,030  -->  00:23:15,290
It's not so good for deletions, removals.
513

513

00:23:15,290  -->  00:23:18,090
And it's not so good for accessing an item in the list
514

514

00:23:18,090  -->  00:23:19,580
when you don't have it's index.
515

515

00:23:19,580  -->  00:23:22,090
So remember, it's backed by an array
516

516

00:23:22,090  -->  00:23:24,690
and so if you have the index,
517

517

00:23:24,690  -->  00:23:28,100
the operation will be able to be performed in constant time
518

518

00:23:28,100  -->  00:23:29,880
but if you don't have the index
519

519

00:23:29,880  -->  00:23:33,180
or if you're inserting or removing elements
520

520

00:23:33,180  -->  00:23:35,270
from somewhere in the middle of the array
521

521

00:23:35,270  -->  00:23:37,180
or at the beginning of the array,
522

522

00:23:37,180  -->  00:23:39,660
elements are gonna have to be shifted around.
523

523

00:23:39,660  -->  00:23:42,894
And so because an array list is backed by an array,
524

524

00:23:42,894  -->  00:23:47,440
it has the same problems and advantages that arrays have.
525

525

00:23:47,440  -->  00:23:51,580
Okay, that's it for array lists and in the next video
526

526

00:23:51,580  -->  00:23:55,160
we're gonna take a quick look at vector, the vector class.
527

527

00:23:55,160  -->  00:23:56,110
I'll see you there.
