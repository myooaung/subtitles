1
00:00:03,640 --> 00:00:06,480
[Autogenerated] so I'm sure that many of you have come across the idea of

2
00:00:06,480 --> 00:00:09,500
what's known as physical design by physical design.

3
00:00:09,500 --> 00:00:10,240
In this case,

4
00:00:10,240 --> 00:00:12,790
I mean designing the application so it matches the

5
00:00:12,790 --> 00:00:15,640
physical characteristics of the system.

6
00:00:15,640 --> 00:00:19,210
Our system will simply have a database in our code.

7
00:00:19,210 --> 00:00:24,740
We have a section of code, maybe a project dedicated entirely to the database.

8
00:00:24,740 --> 00:00:27,040
And these projects are called repositories.

9
00:00:27,040 --> 00:00:30,440
They will be entities involved in database access.

10
00:00:30,440 --> 00:00:32,830
Well, typically also have a set of services.

11
00:00:32,830 --> 00:00:35,800
These services will wrap up the database access and again,

12
00:00:35,800 --> 00:00:39,600
typically within the application lovey services project on

13
00:00:39,600 --> 00:00:43,690
inside of that services project will place all of the services

14
00:00:43,690 --> 00:00:46,540
that are associated with the database.

15
00:00:46,540 --> 00:00:49,610
So inside here we may have an authentication service.

16
00:00:49,610 --> 00:00:51,100
We may have a blog services.

17
00:00:51,100 --> 00:00:56,340
We may have an article, services, whatever services our application offers,

18
00:00:56,340 --> 00:00:58,940
but they'll follow the physical design.

19
00:00:58,940 --> 00:01:02,040
There will be one project called services on Inside.

20
00:01:02,040 --> 00:01:07,340
This project will contain all of the sources for all of our services.

21
00:01:07,340 --> 00:01:08,720
Then you have a web project.

22
00:01:08,720 --> 00:01:12,440
And a web project will contain all the things to do with the web.

23
00:01:12,440 --> 00:01:14,980
So inside here we have the controllers.

24
00:01:14,980 --> 00:01:16,620
We have the views we'll have.

25
00:01:16,620 --> 00:01:21,340
All the access to the web would structural a source code to follow

26
00:01:21,340 --> 00:01:25,240
this physical structure to follow this architectures.

27
00:01:25,240 --> 00:01:26,220
Do you have a web project?

28
00:01:26,220 --> 00:01:27,050
And I was source code.

29
00:01:27,050 --> 00:01:29,570
We have a services project and I was source code ID going to

30
00:01:29,570 --> 00:01:32,940
database project and I was source code.

31
00:01:32,940 --> 00:01:34,340
So with the logical design,

32
00:01:34,340 --> 00:01:37,300
we break our application down into features on each of

33
00:01:37,300 --> 00:01:39,840
these features would have its own project.

34
00:01:39,840 --> 00:01:43,360
She may have a blog feature we may have an article feature on each of

35
00:01:43,360 --> 00:01:47,150
those would be its own project on each of these would typically consist

36
00:01:47,150 --> 00:01:51,740
off one or maybe more than ___ ___ files.

37
00:01:51,740 --> 00:01:54,220
Now we're going to find we can't always do this.

38
00:01:54,220 --> 00:01:57,710
They're going to be some features across all of the projects.

39
00:01:57,710 --> 00:02:00,240
So, for example, the web here,

40
00:02:00,240 --> 00:02:03,230
we need to deploy a single web project on to one or more

41
00:02:03,230 --> 00:02:06,540
physical pieces of hardware inside the web here.

42
00:02:06,540 --> 00:02:09,950
This will almost certainly create a single web project to hold all

43
00:02:09,950 --> 00:02:13,140
the things that make up the Web application.

44
00:02:13,140 --> 00:02:15,660
Same thing is true for database entities.

45
00:02:15,660 --> 00:02:19,940
If I have a database, I love many entities for their database.

46
00:02:19,940 --> 00:02:23,200
Those entities are going to be related in some way to

47
00:02:23,200 --> 00:02:25,440
love primary keys and foreign keys.

48
00:02:25,440 --> 00:02:29,940
If we try and place each database entity into its own project,

49
00:02:29,940 --> 00:02:33,510
that would end up with many, many cross project relationships.

50
00:02:33,510 --> 00:02:36,140
We may end up with circle dependencies,

51
00:02:36,140 --> 00:02:38,600
so we typically break the entities out into its own

52
00:02:38,600 --> 00:02:41,540
project on We'll see how we evolved on.

53
00:02:41,540 --> 00:02:44,050
We'll see how we evolved to this as you work through the

54
00:02:44,050 --> 00:02:47,440
application that we're going to build here.

55
00:02:47,440 --> 00:02:51,060
So typically what happens with these projects is that the logical projects

56
00:02:51,060 --> 00:02:55,350
cut across the physical tears to create a feature on that feature will have

57
00:02:55,350 --> 00:02:57,540
code that probably runs as part of the web,

58
00:02:57,540 --> 00:03:00,440
part of the services and part of the database.

59
00:03:00,440 --> 00:03:05,740
So each feature is like a horizontal cat across the different services.

60
00:03:05,740 --> 00:03:08,940
So we lay our features onto the tears themselves,

61
00:03:08,940 --> 00:03:19,000
so there are benefits to using the logical design against the physical design. But there are also drawbacks on that's what we'll take a look at now

