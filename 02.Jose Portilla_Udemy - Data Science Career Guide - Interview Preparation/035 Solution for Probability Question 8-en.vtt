WEBVTT
1

00:00:05.290 --> 00:00:07.660

Hello everyone and welcome to solution for a problem.



2

00:00:07.660 --> 00:00:09.560

Question number eight.



3

00:00:09.600 --> 00:00:14.790

So as a quick review of this question it was that if you're given a biased coin with some probability



4

00:00:14.790 --> 00:00:20.930

greater than 0.5 for heads how could you simulate a fair coin given just one biased coin.



5

00:00:20.940 --> 00:00:25.690

So in more general words simulate a fair coin given only access to a biased coin.



6

00:00:25.740 --> 00:00:29.990

Now it's a little bit tricky to actually solve this but it's actually a really simple solution.



7

00:00:30.030 --> 00:00:31.610

You just have to figure out the trick to it.



8

00:00:32.430 --> 00:00:38.460

So Von Neumann which is a linked in the guide notes for this particular lecture actually gives a really



9

00:00:38.460 --> 00:00:44.160

simple solution to this problem and the solution is just to flip the coin twice and then based on those



10

00:00:44.160 --> 00:00:47.430

results you end up deciding how you represent things.



11

00:00:47.490 --> 00:00:51.740

So if you have a biased coin you end up flipping it twice.



12

00:00:51.840 --> 00:00:59.340

And if it comes up heads followed by tails then you call that outcome head if it comes tails followed



13

00:00:59.340 --> 00:01:07.920

by heads then you call that outcome tail so otherwise if you have two heads or tails in a row you in



14

00:01:07.920 --> 00:01:10.840

the repeating that process and you throw away that result.



15

00:01:10.840 --> 00:01:16.080

So the way we're able to actually use that to simulate a fair coin is because throughout this we're



16

00:01:16.090 --> 00:01:17.750

assuming that the flips are in the pen.



17

00:01:18.040 --> 00:01:23.050

So because these flips are in the pen that we're able to use this technique of having either heads followed



18

00:01:23.050 --> 00:01:29.050

by tails is head or tails followed by heads as tails and then we can just throw away these either two



19

00:01:29.050 --> 00:01:34.030

heads in a row or two tails in a row and keep repeating this process and this will actually end up simulating



20

00:01:34.030 --> 00:01:35.270

a fair coin.



21

00:01:35.350 --> 00:01:38.770

And keep in mind this method actually works regardless of the actual bias.



22

00:01:38.920 --> 00:01:44.950

As long as the bias is in between 0 and 1 and not exactly 0 or 1 which is basically impossible on a



23

00:01:44.950 --> 00:01:46.590

physical coin.



24

00:01:46.630 --> 00:01:47.850

So that's the trick to it.



25

00:01:47.920 --> 00:01:52.720

You end up flipping it twice and then checking if you get heads or tails tails or heads and then you



26

00:01:52.720 --> 00:01:57.600

throw away two heads or tails in a row because that's basically where your bias is being held.



27

00:01:57.760 --> 00:02:00.210

So you're treating it as two independent flips.



28

00:02:00.340 --> 00:02:04.870

So that way you can basically make a biased coin into a fair coin.



29

00:02:05.080 --> 00:02:06.880

And if you want the full mathematical derivation.



30

00:02:06.880 --> 00:02:09.270

Go ahead and check that Von Neumann link in the notes.



31

00:02:09.290 --> 00:02:13.940

There's also a simpler link that actually shows this programmatically and proves that it works.



32

00:02:13.940 --> 00:02:18.190

So check out the links and the guy notes if you want more on this kind of simple solution because the



33

00:02:18.190 --> 00:02:23.050

idea is fairly simple just two independent flips heads tails or tails heads.



34

00:02:23.110 --> 00:02:23.540

All right.



35

00:02:23.590 --> 00:02:24.710

Hope those useful to.



36

00:02:24.730 --> 00:02:25.720

I'll see you at the next lecture.



