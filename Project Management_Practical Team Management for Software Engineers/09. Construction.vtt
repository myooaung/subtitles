WEBVTT
1
00:00:00.598 --> 00:00:02.681
Construction, that is, writing software.

2
00:00:02.681 --> 00:00:06.962
But this section is not tell you how to literally write software,

3
00:00:06.962 --> 00:00:08.598
you already know that, of course.

4
00:00:08.598 --> 00:00:11.675
In this section I want to think about two things,

5
00:00:11.675 --> 00:00:15.798
why quality construction is important and also that you need a

6
00:00:15.798 --> 00:00:22.598
standard way or process for your team to write software.

7
00:00:22.598 --> 00:00:24.598
Here's just a quick definition of construction.

8
00:00:24.598 --> 00:00:27.780
The actual development of software, unit testing,

9
00:00:27.780 --> 00:00:32.598
and other system elements that meet the functional and technical requirements.

10
00:00:32.598 --> 00:00:36.973
Pretty straightforward, sometimes it's called just construction,

11
00:00:36.973 --> 00:00:38.798
building software, application development,

12
00:00:38.798 --> 00:00:43.027
you know, a variety of different terms, of course.

13
00:00:43.027 --> 00:00:46.598
I kind of like construction.

14
00:00:46.598 --> 00:00:49.376
Why quality construction is important.

15
00:00:49.376 --> 00:00:49.931
Okay,

16
00:00:49.931 --> 00:00:53.681
software functional quality reflects how well it complies

17
00:00:53.681 --> 00:00:56.598
with or conforms to a given design,

18
00:00:56.598 --> 00:01:00.598
based on functional requirements or specifications.

19
00:01:00.598 --> 00:01:03.983
That attribute can also be described as the fitness for purpose

20
00:01:03.983 --> 00:01:09.181
of a piece of software or how it compares to competitors in the

21
00:01:09.181 --> 00:01:10.689
marketplace as a worthwhile product.

22
00:01:10.689 --> 00:01:13.598
You can literally write the best software in the world,

23
00:01:13.598 --> 00:01:16.265
but if it doesn't meet the functional requirements,

24
00:01:16.265 --> 00:01:17.598
hey who cares.

25
00:01:17.598 --> 00:01:22.709
Software structural quality refers to how it meets non-functional requirements

26
00:01:22.709 --> 00:01:27.098
that supports the delivery of the functional requirements,

27
00:01:27.098 --> 00:01:29.598
such as robustness or maintainability,

28
00:01:29.598 --> 00:01:32.598
the degree to which the software was produced correctly.

29
00:01:32.598 --> 00:01:37.598
Predictability, so software quality drives predictability.

30
00:01:37.598 --> 00:01:41.931
Do it once and do it right and there will be less rework,

31
00:01:41.931 --> 00:01:46.598
less variation in productivity, and better performance overall.

32
00:01:46.598 --> 00:01:49.598
Products get delivered on time and they get built more productively.

33
00:01:49.598 --> 00:01:53.598
Poor quality is much more difficult to manage.

34
00:01:53.598 --> 00:01:59.223
Predictability decreases as rework grows and the likelihood of a late,

35
00:01:59.223 --> 00:02:01.723
lower quality product increases.

36
00:02:01.723 --> 00:02:05.598
Reputation, some companies have a reputation for building quality software.

37
00:02:05.598 --> 00:02:07.265
It becomes who they are,

38
00:02:07.265 --> 00:02:11.027
a part of their brand or their team or organization and

39
00:02:11.027 --> 00:02:14.884
ultimately it is the expectation people have of them,

40
00:02:14.884 --> 00:02:16.598
which means of you.

41
00:02:16.598 --> 00:02:18.752
Customers seek them out because of it,

42
00:02:18.752 --> 00:02:22.444
a good solid reputation is hard to establish and easy to lose,

43
00:02:22.444 --> 00:02:25.265
but when your company or your department has it,

44
00:02:25.265 --> 00:02:26.931
it's a powerful business driver.

45
00:02:26.931 --> 00:02:30.598
A few mistakes and that reputation can be gone,

46
00:02:30.598 --> 00:02:35.820
creating major obstacles to sales and consequently your bottom line.

47
00:02:35.820 --> 00:02:36.931
Employee morale,

48
00:02:36.931 --> 00:02:40.598
the most productive and happy employees have pride in their work.

49
00:02:40.598 --> 00:02:43.931
Enable the employees to build quality software will drive a

50
00:02:43.931 --> 00:02:46.871
much higher level of morale and productivity.

51
00:02:46.871 --> 00:02:51.265
On the other hand, poor products, lots of rework,

52
00:02:51.265 --> 00:02:56.198
unhappy customers, and difficulty making deadlines have the opposite effect,

53
00:02:56.198 --> 00:03:00.027
leading to expensive turnover and less productive workforce.

54
00:03:00.027 --> 00:03:04.798
Customer satisfaction, a quality product satisfies the customer,

55
00:03:04.798 --> 00:03:09.820
a satisfied customer comes back for more and provides positive referrals.

56
00:03:09.820 --> 00:03:14.681
Customer loyalty is heavily driven by the quality of the

57
00:03:14.681 --> 00:03:17.598
software you produce and services you provide.

58
00:03:17.598 --> 00:03:20.983
And let's not forget that with the explosion of social media,

59
00:03:20.983 --> 00:03:24.598
such as Twitter and Facebook, positive referrals can spread quickly.

60
00:03:24.598 --> 00:03:25.507
Of course,

61
00:03:25.507 --> 00:03:30.398
that means poor quality and dissatisfaction can also be communicated quickly,

62
00:03:30.398 --> 00:03:33.598
even if not quicker than the good ones.

63
00:03:33.598 --> 00:03:38.143
The bottom line, it all drives to the bottom line,

64
00:03:38.143 --> 00:03:40.098
predictability and productive performance,

65
00:03:40.098 --> 00:03:42.598
a stellar reputation, happy employees,

66
00:03:42.598 --> 00:03:46.689
and satisfied customers are the formula for a successful

67
00:03:46.689 --> 00:03:49.053
software business or a successful department.

68
00:03:49.053 --> 00:03:53.398
Few other stand alone elements of a successful business have

69
00:03:53.398 --> 00:03:57.598
as deep an impact as software quality.

70
00:03:57.598 --> 00:04:02.598
Okay, now let's talk about the construction process.

71
00:04:02.598 --> 00:04:04.416
The development or construction process.

72
00:04:04.416 --> 00:04:07.431
I recommend that you have a best practice,

73
00:04:07.431 --> 00:04:11.598
that is a way that you generally write your software.

74
00:04:11.598 --> 00:04:15.598
First, design and architecture, as we talked in the previous section,

75
00:04:15.598 --> 00:04:16.752
before you write any code,

76
00:04:16.752 --> 00:04:19.798
you want to be sure you have reviewed the business requirements and

77
00:04:19.798 --> 00:04:22.598
sketched out the best system design and architecture.

78
00:04:22.598 --> 00:04:27.398
You have also determined the best practices and design patterns

79
00:04:27.398 --> 00:04:30.598
to follow when you now being writing code.

80
00:04:30.598 --> 00:04:32.675
These choices will be the foundation on which you

81
00:04:32.675 --> 00:04:34.053
will write your software solutions.

82
00:04:34.053 --> 00:04:40.681
Now there are many choices of methods to write software and most seem to be,

83
00:04:40.681 --> 00:04:41.515
well, whatever.

84
00:04:41.515 --> 00:04:47.598
Somehow you need to find that balance between creativity and structure.

85
00:04:47.598 --> 00:04:48.053
Waterfall,

86
00:04:48.053 --> 00:04:52.143
now this approach typically refers to a very rigid

87
00:04:52.143 --> 00:04:54.213
approach and structure to software development in which

88
00:04:54.213 --> 00:04:58.143
you do all of the planning up front, then all the requirements analysis,

89
00:04:58.143 --> 00:05:01.931
then all the coding, then all the testing,

90
00:05:01.931 --> 00:05:06.598
et cetera, kind of large, big, unwieldy steps.

91
00:05:06.598 --> 00:05:08.136
Now that is one approach,

92
00:05:08.136 --> 00:05:12.312
it's been used many times in the past and I still see it in

93
00:05:12.312 --> 00:05:14.884
the present and sometimes users or user organizations want

94
00:05:14.884 --> 00:05:18.598
to have those plans up front, want to have all the specs done,

95
00:05:18.598 --> 00:05:23.598
and sometimes cannot be convinced to go more Agile or Scrum or things like that.

96
00:05:23.598 --> 00:05:24.455
And in my case,

97
00:05:24.455 --> 00:05:26.998
we've had to follow what the customer wants for customer satisfaction.

98
00:05:26.998 --> 00:05:32.265
But there's also Agile, now again, it's not really a methodology to me,

99
00:05:32.265 --> 00:05:35.598
but more of a philosophy of developing software.

100
00:05:35.598 --> 00:05:38.598
Agile software development describes a set of principles for software

101
00:05:38.598 --> 00:05:41.598
development under which requirements and solutions evolve through the

102
00:05:41.598 --> 00:05:47.598
collaborative effort of self organizing cross functional teams.

103
00:05:47.598 --> 00:05:51.027
Agile promotes adaptive planning, evolutionary development,

104
00:05:51.027 --> 00:05:53.265
early delivery, continuous improvement,

105
00:05:53.265 --> 00:05:57.931
and it encourages rapid and flexible response to change,

106
00:05:57.931 --> 00:06:00.598
that's a biggie, there's always change.

107
00:06:00.598 --> 00:06:02.416
As you have likely discerned,

108
00:06:02.416 --> 00:06:05.931
the waterfall process I have mentioned is counter to

109
00:06:05.931 --> 00:06:08.598
rapid and flexible response to change.

110
00:06:08.598 --> 00:06:12.829
Scrum, it's just one example of a methodology under the Agile,

111
00:06:12.829 --> 00:06:15.098
you know, approach, if you will, and philosophy.

112
00:06:15.098 --> 00:06:15.848
There are many,

113
00:06:15.848 --> 00:06:19.598
but it seems that scrum is one of the most popular in my experience.

114
00:06:19.598 --> 00:06:22.367
There are several other Agile and Scrum courses that

115
00:06:22.367 --> 00:06:24.507
you might check out in Pluralsight.

116
00:06:24.507 --> 00:06:24.962
Kanban,

117
00:06:24.962 --> 00:06:29.665
it's a technique of work management that is very simple and easy

118
00:06:29.665 --> 00:06:33.884
to use and I'll be giving you a quick Kanban overview in a later

119
00:06:33.884 --> 00:06:35.598
section on application maintenance.

120
00:06:35.598 --> 00:06:39.598
Software configuration management and those tools that help do that.

121
00:06:39.598 --> 00:06:42.871
They help you manage the task of tracking and

122
00:06:42.871 --> 00:06:44.689
controlling changes in the software.

123
00:06:44.689 --> 00:06:49.098
If something goes wrong, the SCM, or Software Configuration Management tool,

124
00:06:49.098 --> 00:06:52.829
can determine what was changed and who changed it.

125
00:06:52.829 --> 00:06:57.098
There are tons of tools out there, such as Team Foundation Server,

126
00:06:57.098 --> 00:07:00.598
GitHub, Subversion, Bitbucket and many, many more.

127
00:07:00.598 --> 00:07:03.598
Go do some research and pick one and use it.

128
00:07:03.598 --> 00:07:05.598
Development platform and tools,

129
00:07:05.598 --> 00:07:09.689
alright you will need to determine your suite of

130
00:07:09.689 --> 00:07:12.234
development platform and tools needed to build,

131
00:07:12.234 --> 00:07:14.198
test, and maintain your software.

132
00:07:14.198 --> 00:07:17.884
Those tools and platforms are typically part of your

133
00:07:17.884 --> 00:07:19.598
design and architecture roadmap.

134
00:07:19.598 --> 00:07:21.265
So based on the requirements,

135
00:07:21.265 --> 00:07:25.098
the roadmap helps you determine and identify the platforms and

136
00:07:25.098 --> 00:07:28.598
tools to use in each particular application.

137
00:07:28.598 --> 00:07:31.598
Normally for this course's scenario of about five developers,

138
00:07:31.598 --> 00:07:33.798
I hope you have only one platform and a few tools,

139
00:07:33.798 --> 00:07:40.000
but you never know. Now let's check out user acceptance testing.

