WEBVTT

00:00.180 --> 00:00.450
Baiklah.

00:00.450 --> 00:01.220
Selamat datang kembali.

00:01.410 --> 00:06.210
Jadi dalam video terakhir mereka pada dasarnya menghabiskan beberapa menit untuk memberi tahu Anda betapa buruknya solusi ini

00:06.900 --> 00:08.020
dan seberapa lambatnya.

00:08.160 --> 00:12.540
Sejauh kompleksitas waktu kira-kira dua sampai akhir benar-benar buruk.

00:12.540 --> 00:15.300
Ini wajah sedih kami lagi di video ini.

00:15.390 --> 00:17.710
Saya ingin benar-benar menunjukkan kekurangannya.

00:17.760 --> 00:19.620
Hal yang memperlambat kita.

00:19.860 --> 00:21.360
Apa yang bisa kita lakukan untuk meningkatkan.

00:21.390 --> 00:24.290
Dan kemudian kita akan berbicara tentang dua cara untuk melakukan perbaikan itu.

00:24.300 --> 00:25.770
Yang satu itu berubah.

00:25.770 --> 00:29.860
Jadi masalah sebenarnya adalah kita mengulangi hal-hal berulang kali.

00:30.030 --> 00:30.550
Kanan.

00:30.600 --> 00:36.240
Ketika kita melakukan Fibonacci lima kita menghitung Fibonacci empat ditambah Fibonacci tiga.

00:36.620 --> 00:37.130
BAIK.

00:37.350 --> 00:42.320
Tetapi untuk menghitung Fibonacci empat kita melakukan Fibonacci 3 lagi.

00:43.050 --> 00:44.720
Jadi saya melingkari itu untuk menunjukkan kepada Anda.

00:44.880 --> 00:50.970
Dan ya kita mengulangi Fibonacci dua di sini dan di sana Fibonacci dari satu tetapi mereka tidak

00:50.970 --> 00:54.300
benar-benar mengambil banyak waktu karena mereka adalah kasus dasar.

00:54.300 --> 00:54.500
Kanan.

00:54.500 --> 00:56.180
Kami hanya mengembalikan satu kembali satu.

00:56.340 --> 01:00.750
Jadi itu tidak benar-benar masuk hitungan tetapi Fibonacci 3 memang melibatkan banyak pekerjaan.

01:00.780 --> 01:01.720
Maksud saya kecil.

01:01.760 --> 01:02.010
Kanan.

01:02.010 --> 01:07.500
Ini seperti fraksi terkecil terkecil dari satu detik, tetapi mari kita lihat Fibonacci enam.

01:07.500 --> 01:09.450
Sekarang lihat berapa banyak duplikasi yang kita miliki.

01:09.450 --> 01:15.950
Kami mengulangi sebelum dua kali lima dari tiga tiga kali.

01:16.170 --> 01:18.200
Dan sekarang inilah Fibonacci tujuh.

01:18.240 --> 01:20.750
Lihat saja berapa banyak pengulangan yang kita hitung ulang.

01:20.780 --> 01:21.470
Fitbit 5.

01:21.480 --> 01:26.410
Seluruh sisi kiri di sini kita menghitung ulang semuanya di sini.

01:26.520 --> 01:32.700
Kami tidak ingat bahwa kami melakukan itu dan ini adalah inti dari video pada subproblem yang tumpang tindih.

01:32.700 --> 01:35.270
Ini berarti bahwa kita dapat menggunakan pemrograman dinamis.

01:35.310 --> 01:41.100
Ini semua adalah subproblem dan ada tumpang tindih ada pengulangan tapi kami akan

01:41.100 --> 01:48.300
kembali ke sana hanya untuk menunjukkan Anda di sini sebelum kami melakukannya berkali-kali dan 3:55

01:48.300 --> 01:53.560
melibatkan serangkaian panggilan rekursif tiga panggilan dipanggil berkali-kali juga disini.

01:53.700 --> 01:59.130
Jadi Anda dapat melihat ini tumbuh sangat cepat dan itu bukan perhitungan cepat karena cara solusi kami

01:59.130 --> 02:02.150
saat ini mengaturnya tidak tahu bahwa ia sudah melakukannya.

02:02.220 --> 02:06.520
Ini akan menghitung ulang lima dari lima di sini dan kemudian melakukannya lagi di sini.

02:06.840 --> 02:13.200
Setiap kali mendapat lima sebelum di sini setiap kali Anda melihat oranye itu mengulang yang mengulang lagi

02:13.410 --> 02:14.590
mengulang lagi.

02:14.700 --> 02:20.460
Ini tidak baik tetapi ada harapan karena bagaimana jika kita bisa mengingat nilai-nilai lama ini yang akan menjadi

02:20.460 --> 02:21.770
inti dari bagian ini.

02:21.810 --> 02:27.660
Seluruh titik pemrograman dinamis menggunakan pengetahuan masa lalu untuk membuat penyelesaian masalah di masa depan lebih

02:28.050 --> 02:33.840
mudah atau untuk kembali ke definisi ini metode untuk memecahkan masalah yang kompleks dengan memecahnya

02:33.840 --> 02:35.400
menjadi kumpulan subproblem sederhana.

02:35.400 --> 02:36.330
Kami sudah melakukannya.

02:36.360 --> 02:39.090
Solusi kami memecahnya menjadi submasalah yang lebih sederhana.

02:39.270 --> 02:45.210
Tapi apa yang belum kami lakukan adalah menyelesaikan setiap masalah itu sekali saja dan kemudian menyimpan solusi mereka sehingga

02:45.210 --> 02:46.470
kami dapat menggunakannya kembali.

02:46.470 --> 02:47.480
Jadi ke sanalah kita pergi.

02:47.490 --> 02:50.370
Itulah gagasan di balik pemrograman dinamis.

02:50.370 --> 02:53.870
Jadi kita menghitung 4:55 Tapi kemudian kita ingat jawabannya.

02:54.090 --> 02:58.990
Sehingga lain kali di sini kita bisa mengatakan hei apa jawaban terakhir untuk hidup kembali.

02:59.190 --> 03:02.480
Hal yang sama untuk masalah kecil yang kita hitung sebelumnya.

03:02.580 --> 03:04.760
Secara teknis yang ini akan dihitung dulu.

03:04.770 --> 03:06.770
Urutannya salah dan saya tidak begitu memikirkannya.

03:06.780 --> 03:08.280
Saya hanya melingkari mereka secara acak.

03:08.400 --> 03:13.500
Tapi bagaimanapun ini akan dihitung pertama dan kemudian kita akan mengingatnya ketika kita sampai di sini dan kemudian hal yang

03:13.500 --> 03:15.280
sama ketika kita sampai di sini.

03:15.330 --> 03:16.820
Jadi itu akan menghemat banyak waktu kita.

03:16.830 --> 03:20.130
Kita tidak perlu terus turun dan terus melakukan semua ini.

03:20.160 --> 03:21.650
Dan saya akan pergi dari sana.

03:21.690 --> 03:26.730
Itulah inti dari bagian ini bagaimana jika kita dapat mengingat nilai-nilai lama menyimpannya dan kembali

03:26.730 --> 03:27.420
kepada mereka.

03:27.540 --> 03:31.170
Jadi kami menyelesaikan masing-masing sub-masalah hanya satu kali di video berikutnya.

03:31.170 --> 03:35.980
Saya akan berbicara tentang satu strategi satu cara untuk melakukan itu yang disebut menghafal memoisasi.

03:36.060 --> 03:39.290
Pada dasarnya menyimpan data dalam array atau objek atau struktur.
