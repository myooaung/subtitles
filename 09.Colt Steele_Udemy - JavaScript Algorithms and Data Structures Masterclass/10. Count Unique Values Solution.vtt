WEBVTT

00:00.120 --> 00:01.140
Baiklah, selamat datang kembali.

00:01.140 --> 00:05.670
Inilah solusi saya menggunakan dua petunjuk untuk menghitung masalah nilai unik.

00:05.670 --> 00:10.870
Jadi seperti yang saya sebutkan kita menggunakan dua pointer mulai dari yang kiri mulai di sini dan yang berikutnya

00:10.910 --> 00:14.590
adalah indeks 0 dan kemudian indeks 1 dan kemudian kita menantikan dari sana.

00:14.880 --> 00:21.630
Dan kemudian kita memperbarui pointer pertama hanya pada kondisi tertentu yaitu ketika kita menemukan dua nilai

00:21.630 --> 00:24.380
unik dua nilai yang tidak cocok.

00:24.900 --> 00:26.120
Jadi mari kita melompat kesini.

00:26.400 --> 00:32.710
Dan hal pertama yang akan saya lakukan hanyalah mendefinisikan fungsi saya, menyebutnya menghitung nilai unik dan akan mengambil array dan membiarkan

00:33.810 --> 00:36.890
saya memanggilnya di sini dengan daftar baru nilai unik.

00:36.890 --> 00:44.200
Jadi mari kita lakukan satu, datang satu koma dua tiga tiga.

00:45.020 --> 00:45.430
Baiklah.

00:45.500 --> 00:51.210
Itu cukup bagus seperti ini dan saya ingin memulai dengan membuat variabel I dan mengaturnya sama dengan nol.

00:51.420 --> 00:52.820
Jadi itu akan dimulai di sini.

00:52.940 --> 00:53.390
Kanan.

00:53.540 --> 00:59.030
Dan kemudian saya akan membuat loop dan ini akan menjadi untuk loop, sebut saja J.

00:59.300 --> 01:01.560
Dan saya tidak akan mengatakannya sama dengan nol.

01:01.610 --> 01:05.810
Maksud saya satu set sama dengan indeks 1 yang juga merupakan nilai 1.

01:05.810 --> 01:06.650
Aku benci kalau itu terjadi.

01:06.650 --> 01:07.710
Tapi ya.

01:07.940 --> 01:09.440
Indeks nol indeks 1.

01:09.770 --> 01:14.600
Jadi J sama dengan 1 sedangkan J kurang dari panjang titik merah.

01:14.600 --> 01:16.060
Kami tidak ingin itu melangkah lebih jauh.

01:16.370 --> 01:17.030
Dan kemudian saya.

01:17.030 --> 01:19.930
Plus plus tanpa J plus plus.

01:20.180 --> 01:24.010
Jadi J hanya akan melewati seluruh loop dari sini ke akhir.

01:24.170 --> 01:26.720
Jadi kami memiliki satu iterasi dan hanya itu.

01:26.750 --> 01:34.370
Sekarang di dalam iterasi dari loop kita akan membandingkan indeks array indeks indeks array

01:34.370 --> 01:34.940
J.

01:35.120 --> 01:36.140
Jadi kita bisa mulai dengan itu.

01:36.140 --> 01:41.100
Jadi array Y dan array J.

01:41.420 --> 01:42.740
Jadi apa yang ingin kita periksa.

01:43.190 --> 01:45.750
Jika mereka tidak sama satu sama lain.

01:45.980 --> 01:48.770
Jadi array tidak sama dengan array J.

01:48.770 --> 01:49.810
Apa yang akan kita lakukan.

01:49.850 --> 01:53.590
Pertama-tama, itu sintaks yang tidak valid untuk menjadikannya pernyataan bersyarat.

01:53.690 --> 01:56.070
Jika mereka tidak sama.

01:56.570 --> 02:02.200
Jika Anda tidak menonton seluruh video kami berbicara tentang pendekatan saya di terakhir saya kira ya video terakhir.

02:02.330 --> 02:03.920
Dua tahun yang lalu.

02:03.920 --> 02:09.230
Yang kami lakukan adalah membandingkan mereka jika mereka setara, kami hanya bergerak maju sampai kami menemukan sesuatu yang tidak

02:09.290 --> 02:11.060
sama dengan apa yang saya lihat.

02:11.060 --> 02:12.410
Jadi mereka tidak setara sekarang.

02:12.410 --> 02:17.490
Kami naik satu per satu dan kemudian kami menempatkan nilai ini di sini.

02:17.930 --> 02:22.100
Jadi kita tidak perlu menukar mereka, kita hanya menempatkan dua di sini juga.

02:22.100 --> 02:25.400
Jadi untuk melakukan itu kita bisa melakukannya.

02:25.550 --> 02:28.230
Plus plus yang menambahkan satu ke tinggi.

02:28.250 --> 02:29.660
Jadi itu dimulai dari nol.

02:29.660 --> 02:38.130
Sekarang kita memindahkannya ke sini dan kemudian kita mengatur array I untuk sekarang sama dengan apa array dari J.

02:38.480 --> 02:42.760
Dan kemudian kita bergerak maju lagi sehingga J naik.

02:42.830 --> 02:44.470
Jadi sekarang J adalah 3.

02:44.480 --> 02:46.160
Ini harus menjadi dua bagi kita untuk melakukan itu.

02:46.260 --> 02:48.090
Jadi sekarang J adalah 3 kita membandingkannya.

02:48.260 --> 02:49.710
Oh well mereka tidak cocok lagi.

02:49.910 --> 02:51.250
Jadi kami bergerak maju.

02:51.260 --> 02:57.200
I plus plus dan kita mengatur array I menjadi tiga array sama dengan array J.

02:57.410 --> 02:58.680
Dan kemudian loop itu bergerak.

02:58.730 --> 03:00.300
Kali ini mereka sama.

03:00.470 --> 03:03.080
Ketika itu masalahnya kita tidak melakukan apa-apa.

03:03.080 --> 03:06.080
J bertambah secara otomatis karena loop.

03:06.080 --> 03:07.380
Jadi tiga dan tiga sama.

03:07.430 --> 03:10.150
Jadi waktu berikutnya melalui J naik hingga empat.

03:10.370 --> 03:12.230
Nah sekarang kita memiliki ketidakcocokan lagi.

03:12.440 --> 03:14.780
Jadi kita ambil empat dan kita taruh di sini.

03:14.780 --> 03:19.130
Jadi, pertama kita secara teknis naik dan kemudian kita menempatkan empat di sini.

03:19.170 --> 03:22.520
Jadi sekarang kita membandingkan empat hingga lima.

03:22.580 --> 03:23.370
Jadi kami melakukan hal yang sama.

03:23.390 --> 03:24.240
Kami bergerak ke atas.

03:24.320 --> 03:26.110
Kami menempatkan 5 di sini.

03:26.210 --> 03:27.690
Sekarang kita membandingkan enam hingga lima.

03:27.740 --> 03:32.090
Jadi kami bergerak ke atas dan menempatkan enam di sini, lalu naik lagi.

03:32.150 --> 03:32.890
Mereka cocok.

03:32.930 --> 03:35.120
Jadi kami tidak melakukan apa-apa lagi.

03:35.280 --> 03:38.330
Kami menempatkan saya di sini dan kami menempatkan 7 di sana.

03:38.330 --> 03:44.510
Jadi sekarang kita telah membangun bagian awal array yang memiliki semua nilai unik dan pada dasarnya yang

03:44.510 --> 03:49.070
kita inginkan adalah panjang bagian ini dan kita memilikinya secara default.

03:49.070 --> 03:51.250
Jika kita melihat I dan J di bagian paling akhir.

03:51.440 --> 03:55.480
J akan menjadi indeks terakhir dari array kami.

03:55.610 --> 03:58.420
Jadi sebenarnya untuk menunjukkan ini.

03:58.670 --> 04:00.620
Ingat ini hanya berfungsi dengan array yang diurutkan.

04:00.620 --> 04:07.370
Jadi saya tidak bisa langsung menggunakan array ini karena saya harus mengembalikannya ke keadaan semula.

04:07.390 --> 04:09.670
Jadi itu sebenarnya saya tidak benar-benar mengingatnya.

04:09.670 --> 04:19.060
Sekarang katakan saja 1 1 1 2 2 3 4 5 5 5 6 7 seperti itu.

04:19.060 --> 04:23.160
Ada berapa nomor unik dengan angka itu 1 2 3 4 5 6 7.

04:23.230 --> 04:28.160
Jadi kita harus mendapatkan 7 dan kami akan memanggil menghitung nilai unik dengan itu.

04:28.510 --> 04:35.240
Dan kemudian apa yang akan saya lakukan adalah di sini mari kita masuk ke dalam loop di akhir log itu.

04:35.710 --> 04:37.170
I Khama J.

04:37.450 --> 04:42.380
Dan kita harus melakukannya di sini jika kita ingin J karena J akan menghilang.

04:42.490 --> 04:43.270
Dan jika kita menjalankannya.

04:43.420 --> 04:43.900
BAIK.

04:44.200 --> 04:46.870
Jadi kita bisa melihat Anda tahu di sini saya di sini J.

04:47.050 --> 04:54.460
Dan pada bagian paling akhir, J mencapai ujung array dan kita menghentikan loop pada angka 6 karena itu adalah

04:54.500 --> 04:55.350
indeks enam.

04:55.540 --> 05:00.310
Dan itu karena secara internal array terlihat seperti ini di mana kita memiliki semua nilai unik

05:00.310 --> 05:01.060
di sini.

05:01.060 --> 05:06.650
Di sinilah saya menyingkirkan tingkat tertinggi ini di sini yang merupakan indeks enam.

05:06.700 --> 05:14.080
Jadi kita perlu menambahkan satu ke saya karena pada dasarnya panjang bagian ini sampai saya dan kami tidak ingin memulai

05:14.080 --> 05:14.840
dengan nol.

05:14.830 --> 05:16.450
Kami ingin memulai dari 1 saat menghitung.

05:16.570 --> 05:19.820
Jadi kami ingin mengembalikan I plus 1 di sini.

05:21.120 --> 05:28.910
Sama seperti ini dan jika kita sekarang mengujinya kita mendapat tujuh dan itu harus benar.

05:29.070 --> 05:32.730
Mari kita coba dengan yang seperti ini.

05:32.730 --> 05:35.670
Nomor tiga kita harus mencapai dan kita lakukan.

05:35.670 --> 05:40.820
Sekarang ada kasus khusus yang jika kita memiliki array kosong itu tidak berfungsi.

05:40.980 --> 05:45.150
Itu memberi kita satu dan itu harus memberi kita nol tidak ada angka di sana.

05:45.160 --> 05:46.010
Dan mengapa begitu.

05:46.080 --> 05:47.650
Yah saya mulai dari nol.

05:48.030 --> 05:54.570
Dan bahkan jika semua ini tidak berjalan dan tidak ada yang terjadi dan di sini kita mengembalikan 0 plus 1.

05:54.900 --> 05:57.200
Jadi saya akan menambahkan korsleting kecil di awal.

05:57.330 --> 06:00.990
Periksa apakah panjang nilai sama dengan nol.

06:01.140 --> 06:03.430
Kembalikan nol.

06:03.480 --> 06:05.610
Itu berarti tidak ada digit unik.

06:05.610 --> 06:06.790
Sekarang kita mendapat nol.

06:06.810 --> 06:18.190
Tetapi jika kita kembali ke satu mari kita lakukan seperti ini kita mendapatkan 5 1 2 3 4 5 nomor unik.

06:18.400 --> 06:19.010
BAIK.

06:19.030 --> 06:20.890
Jadi itulah salah satu cara pemecahannya.

06:20.890 --> 06:28.150
Menggunakan dua petunjuk dan ini sudah berakhir dan waktu adalah waktu linier karena kami hanya mengulang sekali yang

06:28.150 --> 06:29.410
cukup bagus.

06:29.410 --> 06:30.020
Baiklah.

06:30.190 --> 06:30.790
Bergerak.
