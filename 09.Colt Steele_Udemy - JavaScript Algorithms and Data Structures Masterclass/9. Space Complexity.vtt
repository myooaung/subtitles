WEBVTT

00:00.240 --> 00:01.560
Baiklah, selamat datang kembali.

00:01.560 --> 00:06.510
Jadi sekarang kita menggeser persneling sedikit dan kita akan berbicara tentang sesuatu yang disebut kompleksitas ruang.

00:06.510 --> 00:11.670
Semua yang kami bicarakan sejauh ini kami khawatir tentang waktu tentang seberapa cepat algoritma berjalan

00:11.670 --> 00:12.520
dengan runtime.

00:12.960 --> 00:14.770
Itu disebut kompleksitas waktu.

00:14.850 --> 00:19.920
Kami telah menganalisis runtime suatu algoritma seiring dengan meningkatnya ukuran input.

00:19.920 --> 00:26.490
Sekarang mari kita bicara tentang apa yang terjadi pada ruang yang mengambil algoritma seiring dengan meningkatnya ukuran input

00:26.550 --> 00:32.660
Kita masih dapat menggunakan notasi Big-O untuk hal yang sama menggunakan sintaksis formal yang sama untuk menggambarkan apa yang terjadi.

00:32.790 --> 00:34.790
Tapi sekarang kita akan fokus pada ruang.

00:34.860 --> 00:40.410
Jumlah memori yang digunakan jadi ada beberapa hal dasar yang harus kita hindari.

00:40.410 --> 00:48.690
Salah satunya adalah yang jelas tumbuh jika kita mendekati tak terbatas ukuran input itu sendiri yang sedang dan

00:48.690 --> 00:50.040
akan tumbuh.

00:50.040 --> 00:51.780
Jadi kita akan mengabaikan bagian itu.

00:51.780 --> 00:55.490
Anda mungkin mendengar istilah kompleksitas ruang tambahan jika Anda melakukan riset.

00:55.500 --> 01:01.980
Jika Anda membaca Wikipedia atau sesuatu yang merujuk pada ruang yang dibutuhkan oleh algoritma hanya tidak termasuk ruang

01:01.980 --> 01:03.710
yang digunakan oleh input.

01:03.810 --> 01:05.090
Itu yang akan kita bicarakan.

01:05.220 --> 01:09.770
Kami peduli dengan algoritme itu sendiri karena tujuan kami berkembang.

01:09.780 --> 01:12.150
Itulah akhir yang besar dan besar.

01:12.160 --> 01:13.100
Oh itu bagus.

01:13.110 --> 01:18.460
Itu semacam poin yang akan kita katakan bahwa saat kita tumbuh, kita mengasumsikan bahwa input yang akhir akan tumbuh.

01:18.450 --> 01:25.200
Jadi mari kita tidak peduli tentang ruang itu, mari kita peduli tentang dampak apa yang ada di dalam algoritma.

01:25.200 --> 01:30.210
Jadi kecuali dinyatakan sebaliknya ketika kita berbicara tentang kompleksitas ruang secara teknis kita berbicara tentang

01:30.210 --> 01:31.470
kompleksitas ruang tambahan.

01:31.470 --> 01:36.870
Semoga itu tidak terlalu menakutkan tetapi pada dasarnya itu hanya berarti kita fokus pada apa yang terjadi di dalam algoritma.

01:36.930 --> 01:39.050
Demikian beberapa aturan dasar praktis.

01:39.050 --> 01:45.270
Yang pertama adalah bahwa hal-hal yang paling primitif seperti boolean angka-angka tidak terdefinisi nol dan Javascript adalah

01:45.270 --> 01:48.540
ruang konstan sehingga tidak masalah berapa ukuran inputnya.

01:48.570 --> 01:54.420
Jika angkanya 1 atau angkanya 1000 kita dapat menganggapnya ruang konstan tidak masalah karena

01:54.420 --> 01:58.240
boolean benar atau salah memakan jumlah ruang yang sama.

01:58.260 --> 02:04.180
String agak berbeda karena mereka membutuhkan 0 ruang jadi jika dan panjang string.

02:04.350 --> 02:10.830
Jika Anda tahu input tumbuh hingga seribu karakter. Nah, itu sebenarnya contoh yang buruk

02:10.920 --> 02:17.710
jika sampai 50 karakter, string membutuhkan ruang 50 kali lebih banyak daripada string karakter tunggal.

02:18.930 --> 02:22.480
Hal yang sama dengan array tipe referensi dan objek.

02:22.520 --> 02:28.200
Secara umum kita berbicara tentang peristiwa O di mana dan itu adalah panjang array atau jumlah kunci untuk

02:28.200 --> 02:29.020
suatu objek.

02:29.190 --> 02:34.830
Ini sebenarnya bukan panjang secara teknis, tetapi jika dan jika panjang array lebih maju dibandingkan dengan yang

02:34.830 --> 02:40.160
lain yaitu dua, maka dibutuhkan dua kali lebih banyak ruang daripada array yang lebih pendek.

02:40.800 --> 02:42.780
Jadi mari kita lihat sebuah contoh.

02:42.990 --> 02:48.280
Jadi di sini kita fokus bukan pada kompleksitas waktu, kita berfokus pada kompleksitas ruang.

02:48.390 --> 02:55.680
Jadi fungsi ini disebut beberapa dibutuhkan array dan hanya menjumlahkan semua item dalam array.

02:56.100 --> 02:59.150
Jadi kita memiliki total mulai variabel ke 0.

02:59.290 --> 03:02.990
Kemudian kita memiliki loop yang berjalan dari 0 ke akhir array.

03:03.390 --> 03:07.590
Dan kami hanya menambahkan nilai setiap item dalam array ke variabel total.

03:07.590 --> 03:09.110
Dan kemudian kita mengembalikannya di akhir.

03:09.270 --> 03:11.030
Jadi sekali lagi ruang bukan waktu.

03:11.030 --> 03:12.200
Jadi kami khawatir.

03:12.210 --> 03:14.130
Jadi apa saja hal-hal yang memakan ruang.

03:14.490 --> 03:22.140
Yah tidak peduli berapa panjang array kita memiliki satu variabel yang disebut Total satu angka dan kemudian kita

03:22.200 --> 03:23.040
perulangan.

03:23.100 --> 03:25.000
Tapi kami tidak khawatir tentang waktu itu lagi.

03:25.170 --> 03:29.440
Dan kemudian kita memiliki deklarasi kedua di dalam for loop sama dengan nol.

03:29.640 --> 03:34.380
Jadi itu nomor lain dan itu untuk ruang.

03:34.380 --> 03:38.540
Kami kembali ke variabel total yang kami tambahkan ke dalamnya, tetapi itu tidak masalah.

03:38.550 --> 03:39.610
Itu butuh waktu.

03:39.690 --> 03:41.130
Tapi ruangnya sudah ada.

03:41.250 --> 03:47.490
Jadi, tidak peduli berapa ukuran array itu dari ujung atau dalam hal ini rr saat ia tumbuh mungkin seribu

03:47.490 --> 03:48.930
item, mungkin sejuta item.

03:48.960 --> 03:51.690
Ya mungkin 10 atau 50 atau ribuan.

03:51.690 --> 03:53.000
Mari kita mulai dari yang sederhana.

03:53.100 --> 03:58.740
Itu tidak berdampak pada ruang yang diambil karena kami hanya memiliki dua variabel ini dan mereka

03:58.740 --> 04:00.150
ada tidak peduli apa.

04:00.270 --> 04:05.180
Kami tidak menambahkan variabel baru berdasarkan dari panjang yang kami tambahkan ke variabel total.

04:05.190 --> 04:06.990
Tapi kami tidak membuat variabel baru.

04:07.290 --> 04:12.160
Jadi itu hanya berarti kita memiliki ruang konstan satu ruang.

04:12.210 --> 04:15.860
Itu selalu sama tidak peduli ukuran input.

04:16.440 --> 04:17.280
Ini satu lagi.

04:17.550 --> 04:19.530
Jadi ini disebut ganda.

04:19.530 --> 04:23.390
Dibutuhkan sebuah array dan mengapa saya tidak menyalinnya saja dan menunjukkannya kepada Anda.

04:23.430 --> 04:28.540
Jadi saya sudah menyalinnya dan itu disebut Double pass dalam array 1 hingga 3.

04:28.560 --> 04:29.970
Apa yang kembali kepada saya.

04:29.970 --> 04:32.330
Array dengan dua item adalah apa yang saya katakan.

04:32.430 --> 04:34.270
Array dengan tiga item dikatakan seperti.

04:34.350 --> 04:36.780
Tetapi masing-masing telah digandakan.

04:36.870 --> 04:40.380
Dan yang penting untuk dicatat adalah membuat array baru.

04:40.770 --> 04:42.900
Jadi itu dimulai dengan membuat array baru itu.

04:42.900 --> 04:49.410
Kemudian loop di atas panjang array pertama dan kemudian mengalikan setiap item dan mendorongnya ke array

04:49.500 --> 04:52.530
baru dan kemudian mengembalikan array baru.

04:52.950 --> 04:59.070
Jadi apa artinya kompleksitas ruang ini saat panjang array bertambah saat input mendekati

04:59.070 --> 05:00.030
tak terhingga.

05:00.280 --> 05:05.160
Tetapi mengabaikan fakta bahwa javascript tidak dapat menangani apa yang terjadi pada ruang yang digunakan oleh

05:05.160 --> 05:06.450
algoritma ini di sini.

05:06.480 --> 05:07.670
Jadi ya kita punya ini.

05:07.690 --> 05:10.380
Kami akan membuat array baru apa pun yang terjadi.

05:10.830 --> 05:17.500
Tapi itu tidak begitu penting ketika kita mempertimbangkan ini di sini kita memiliki array baru ini

05:17.500 --> 05:22.590
dan itu semakin lama semakin lama secara proporsional dengan panjang input.

05:22.840 --> 05:27.440
Jadi jika arraynya adalah 10 item di sini kita menyimpan 10 item dalam array baru.

05:27.520 --> 05:32.980
Jika ini adalah 50 item atau menyimpan 50 item di sini dalam array

05:32.980 --> 05:38.800
baru dan mengembalikannya sehingga ruang yang digunakan berbanding lurus dengan N ke array input.

05:38.800 --> 05:41.360
Jadi angka akhir kita dapatkan 0 dan spasi.

05:41.410 --> 05:46.570
Jadi kita tidak perlu peduli dengan hal-hal seperti ini, kita bisa menyederhanakannya hanya ke tingkat paling fuzzy

05:46.570 --> 05:52.000
yang lebih daripada akhir dan ditambah satu atau sesuatu seperti itu atau sebenarnya ditambah 2 karena kita juga

05:52.000 --> 05:52.620
punya ini.

05:52.660 --> 05:53.590
Itu tidak masalah.

05:53.860 --> 05:55.110
Jadi saya tahu banyak.

05:55.180 --> 05:58.410
Dan sulit untuk langsung mengerti.

05:58.480 --> 05:59.440
Dan itu mungkin tidak klik.

05:59.440 --> 06:04.390
Tidak apa-apa meskipun kami memiliki beberapa latihan tetapi saya ingin menjelaskan bahwa Anda tidak perlu

06:04.390 --> 06:05.430
menguasainya sebelum melanjutkan.

06:05.620 --> 06:10.520
Saya hanya harus menghapus seluruh intinya adalah bahwa saya harus memiliki dalam sepuluh bagian jadi sekarang akan memiliki

06:10.520 --> 06:13.610
beberapa solusi dan saya ingin dapat mengatakan hei kompleks ruang angkasa.

06:13.620 --> 06:14.810
Ya yang ini bagus.

06:15.160 --> 06:22.960
Dan waktu untuk melenturkan yang satu ini adalah kompleksitas waktu yang mengerikan dan kuadrat tetapi kompleksitas ruang yang konstan atau

06:22.960 --> 06:23.620
sesuatu.

06:23.830 --> 06:26.820
Dan semoga Anda bisa memahami apa yang saya maksud dengan itu.
