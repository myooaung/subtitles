WEBVTT

00:00.150 --> 00:00.740
Baiklah.

00:00.810 --> 00:02.080
Jadi kami berbicara tentang tujuan.

00:02.080 --> 00:04.470
Kami membuat cerita kecil dengan Martin dan naga.

00:04.470 --> 00:09.510
Sekarang mari kita benar-benar mendapatkan definisi formal tentang apa itu rekursi dan kedua mari kita bicara tentang mengapa

00:09.510 --> 00:10.470
Anda harus peduli.

00:10.470 --> 00:15.450
Saya melakukan sedikit dengan baik saya tidak berusaha menakut-nakuti siapa pun tetapi saya sedikit

00:15.450 --> 00:18.430
berbicara di awal tentang bagaimana rekursi bisa rumit.

00:18.450 --> 00:22.500
Jadi mari kita bicara tentang mengapa itu berharga mengapa Anda harus peduli dan mengapa Anda harus melewatinya.

00:22.500 --> 00:24.580
Jika Anda mengalami kesulitan mendapatkannya segera.

00:24.870 --> 00:27.670
Tapi definisi pertama apa itu rekursi.

00:28.020 --> 00:30.610
Itu hanya proses yang menyebut dirinya.

00:30.750 --> 00:36.510
Dan dalam kasus kami dalam segala hal yang kami lakukan dalam javascript atau dalam kode ketika kami mengatakan rekursi

00:36.510 --> 00:38.950
kami mengacu pada fungsi yang memanggil dirinya sendiri.

00:38.970 --> 00:43.480
Jadi kita telah melihat banyak fungsi yang memanggil fungsi lain yang sangat umum.

00:43.500 --> 00:47.730
Kita dapat memiliki fungsi bernama laugh dan di dalamnya kita akan memanggil cancel out log.

00:47.730 --> 00:50.840
Berpotensi itulah panggilan fungsi alih-alih fungsi.

00:50.880 --> 00:54.760
Yang berbeda dari fungsi rekursif adalah mereka menyebutnya self.

00:54.780 --> 01:02.910
Jadi fungsi kehidupan kita di dalam akan memanggil tertawa dan Anda dapat membayangkan pertama-tama dari itu dan itu mungkin sudah membuat kepala

01:02.910 --> 01:03.900
Anda sakit.

01:04.050 --> 01:06.730
Tetapi kemudian bayangkan itu terjadi berulang-ulang.

01:06.810 --> 01:12.450
Dan harus ada titik akhir atau jika kita kembali ke slide ini di sini.

01:13.260 --> 01:16.810
Di sini kita bayangkan bahwa kita memiliki fungsi bernama check for odd.

01:17.040 --> 01:23.910
Kami akan menyebutnya di sini dan kemudian di cek untuk aneh itu akan menyebut dirinya lagi pada daftar yang lebih kecil dan kemudian yang

01:23.910 --> 01:27.960
akan memanggil memeriksa peluang berulang dan lagi harus ada titik akhir tentu saja atau

01:27.960 --> 01:30.370
kita tetap berjalan seperti loop tak terbatas.

01:30.690 --> 01:32.850
Tapi ini sedikit berbeda dari loop tak terbatas.

01:32.850 --> 01:33.600
Tapi kita akan sampai di sana.

01:33.720 --> 01:34.550
Jadi mari kita berhenti di situ.

01:34.550 --> 01:36.360
Ini adalah fungsi yang memanggil dirinya sendiri.

01:36.540 --> 01:38.370
Sekarang mengapa Anda harus peduli.

01:38.460 --> 01:40.070
Mengapa Anda perlu mengetahui hal ini.

01:40.080 --> 01:41.010
Ada banyak alasan.

01:41.010 --> 01:42.300
Pertama-tama ada di mana-mana.

01:42.300 --> 01:43.760
Ini digunakan sepanjang waktu.

01:43.770 --> 01:47.580
Kita akan banyak menggunakannya dalam kursus untuk banyak solusi yang kita tulis nanti.

01:47.760 --> 01:53.340
Tetapi bahkan sebelum itu jika Anda telah menulis javascript Anda mungkin telah menggunakan fungsi

01:53.400 --> 01:59.700
rekursif tanpa mengetahui hal-hal seperti J sound parser berdasarkan string phi itu jika Anda pernah membuat panggilan

01:59.730 --> 02:05.500
AJAX dan mendapatkan Jaison kembali dan mengubahnya menjadi javascript maka Anda mungkin telah memanggil fungsi rekursif.

02:05.580 --> 02:11.850
Sekarang Jason Jason yang diimplementasikan oleh phi tergantung pada mesin javascript.

02:11.880 --> 02:13.690
Jadi Mozilla punya sendiri.

02:14.100 --> 02:15.080
Apa itu namanya Badak.

02:15.090 --> 02:16.950
Saya pikir implementasi mereka sendiri.

02:16.950 --> 02:21.210
Di mana mereka benar, Jason dan parsing bagaimana mereka ingin dan itu tidak harus ditulis secara rekursif

02:21.480 --> 02:22.680
tetapi sering kali itu.

02:22.800 --> 02:27.090
Jadi poin yang ingin saya sampaikan bukanlah bahwa Anda dijamin telah memanggil fungsi

02:27.120 --> 02:30.920
rekursif tetapi bahwa Jason yang parse sering ditulis secara berulang.

02:31.020 --> 02:35.690
Dan sebenarnya saya memiliki kode sumber terbuka untuk Rhyno dan ini ada di sini.

02:35.700 --> 02:39.960
Jadi ini adalah mesin yang digunakan Mozilla dan itu ditulis dalam Java.

02:40.080 --> 02:42.250
Jadi jangan khawatir tentang sintaksnya.

02:42.420 --> 02:48.810
Tetapi jika kita melihat itu tidak sesederhana Jaisalmer bagian memanggil JS yang langsung diuraikan.

02:48.900 --> 02:51.440
Ada fungsi yang disebut nilai Baca.

02:51.480 --> 02:55.770
Metode ini di sini dan membaca nilai panggilan hal-hal seperti objek baca.

02:55.770 --> 02:57.960
Jadi mari kita fokus pada dua nilai baca itu.

02:57.960 --> 03:04.260
Anda menyebut itu panggilan objek baca, kita akan melihat objek baca di tengah objek baca jika kita gulir ke

03:04.260 --> 03:06.970
bawah sedikit itu memanggil nilai baca lagi.

03:07.560 --> 03:13.040
Jadi nilai baca dipanggil dan itu bisa memanggil objek baca dan kita berakhir dengan siklus ini di

03:13.090 --> 03:15.760
mana bahkan menyebar di dua metode yang berbeda.

03:15.900 --> 03:22.230
Mereka saling memanggil satu sama lain sehingga nilai baca adalah panggilan objek baca yang memanggil nilai baca yang memanggil

03:22.230 --> 03:25.110
objek baca dan ini merupakan siklus yang berulang-ulang.

03:25.110 --> 03:26.770
Jadi itulah contoh rekursi.

03:26.910 --> 03:29.210
Tapi izinkan saya menunjukkan implementasi yang lebih sederhana.

03:29.340 --> 03:31.980
Berikut ini adalah implementasi sederhana yang ditulis dalam Javascript.

03:32.190 --> 03:37.710
Jadi ini sebenarnya bukan apa yang digunakan di salah satu browser karena browser tidak ditulis Javascript

03:37.710 --> 03:39.360
tidak ditulis dalam Javascript.

03:39.450 --> 03:42.630
Tapi ini adalah implementasi untuk menunjukkan seperti apa bentuknya.

03:42.630 --> 03:44.120
Jadi saya akan memeriksanya.

03:44.130 --> 03:48.900
Ada metode yang disebut walk yang ada di sini sesuatu di sini sehingga disebut Walk

03:48.900 --> 03:51.100
dan bukannya walk itu memanggil walk.

03:51.130 --> 03:54.830
Saya tidak tahu apakah Anda dapat melihat bahwa oh tidak, saya kehilangan itu.

03:54.830 --> 03:55.910
Itu dia.

03:55.950 --> 03:59.220
Jadi berjalan disebut bukannya berjalan itu menyebut dirinya berulang-ulang.

03:59.300 --> 04:00.660
Aku bosan mengatakan kata jalan.

04:00.660 --> 04:03.270
Itu mulai terdengar sangat aneh ketika saya mengulanginya sebanyak itu.

04:03.270 --> 04:06.210
Tapi apa yang dilakukannya jika Anda memikirkan string.

04:06.330 --> 04:08.410
Semuanya bersarang saat dikatakan berjalan.

04:08.550 --> 04:14.640
Ini akan bergerak ke bawah ke baris berikutnya atau ke hal berikutnya untuk menguraikan berulang-ulang sampai

04:14.640 --> 04:15.460
mencapai akhir.

04:15.590 --> 04:21.420
OK jadi sedikit singgung tapi mungkin agak menarik bahwa ada dua contoh Jason untuk mengurai

04:21.420 --> 04:24.350
string jika dokumen mendapatkan elemen dengan ID.

04:24.420 --> 04:30.810
Dan algoritma traversal DOM jadi ingatlah bahwa Dahmus adalah struktur pohon di mana kita memiliki semua hal yang

04:30.810 --> 04:31.610
bersarang ini.

04:31.630 --> 04:36.160
Bisa jadi seratus layer bersarang penuh Anda tahu div bukan div bukan div.

04:36.210 --> 04:41.340
Dan jika kita mencoba untuk mencari melalui semua dari mereka satu pendekatan yang populer adalah

04:41.340 --> 04:46.160
menulis kode yang melakukannya objek traversal secara rekursif yang sama seperti melintasi Jaison.

04:46.170 --> 04:52.200
Sekarang selain dari fungsi-fungsi ini seperti Jason untuk mem-parsing dan mendapatkan elemen dengan id query pemilih hal-hal yang

04:52.320 --> 04:57.330
telah kita gunakan sebelumnya mungkin kita juga akan menulis banyak fungsi rekursif kita sendiri

04:57.330 --> 04:57.780
nanti.

04:57.810 --> 05:03.300
Jadi ketika kita menulis struktur data kita sendiri ketika kita membuat pohon atau grafik misalnya ketika

05:03.300 --> 05:06.880
kita ingin melintasi mereka, kita ingin mencari sesuatu di atasnya.

05:06.960 --> 05:09.540
Seringkali solusinya melibatkan rekursi.

05:09.540 --> 05:12.660
Sekarang ingat Anda tidak perlu melakukan apa pun secara rekursif tetapi itu bagus.

05:12.660 --> 05:14.340
Terkadang lebih mudah, mari kita bicara seperti itu.

05:14.340 --> 05:19.570
Lebih bersih dan sederhana untuk dipahami daripada melakukannya tanpa rekursi dan itu baru saja mendahului poin

05:19.590 --> 05:20.800
saya di sini.

05:20.930 --> 05:23.360
Dan terkadang alternatif yang lebih bersih untuk iterasi.

05:23.610 --> 05:24.750
Jadi kita akan melihat beberapa contoh.

05:24.750 --> 05:28.200
Kita akan menulis beberapa fungsi baik dengan atau tanpa rekursi.

05:28.240 --> 05:31.830
Dan saya pikir kita akan membuatnya sedikit lebih jelas bahwa kadang-kadang lebih baik.

05:32.160 --> 05:33.570
Jadi mengapa Anda harus peduli.

05:33.610 --> 05:34.650
1 ada di mana-mana.

05:34.650 --> 05:35.590
Anda telah menggunakannya.

05:35.670 --> 05:40.980
Itu tidak masalah saya kira karena itu tidak mempengaruhi bagaimana Anda menggunakan hal-hal seperti Jason yang diuraikan tetapi

05:41.040 --> 05:45.340
sangat penting setelah Anda masuk ke dalam struktur data yang lebih maju ini.

05:45.450 --> 05:51.540
Dan kami sedang menulis fungsi bagian kami sendiri pada elemen get kami sendiri dengan id melintasi pohon misalnya.

05:51.540 --> 05:51.800
Baiklah.

05:51.810 --> 05:53.020
Jadi kami tinggalkan video ini di sini.
