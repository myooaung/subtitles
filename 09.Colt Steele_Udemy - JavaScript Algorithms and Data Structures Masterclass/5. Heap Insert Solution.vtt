WEBVTT

00:00.270 --> 00:01.380
Baiklah, selamat datang kembali.

00:01.500 --> 00:04.980
Jadi mari kita terapkan insert pada kelas heap biner Mac kami.

00:04.980 --> 00:08.150
Tetapi pertama-tama kita harus benar-benar mendefinisikan kelas.

00:08.330 --> 00:09.600
Jadi saya akan melakukannya sekarang.

00:10.020 --> 00:16.800
Max binary heap itu super sederhana setidaknya kerangka itu adalah kita memiliki konstruktor dan semua yang

00:16.800 --> 00:20.810
kita miliki adalah nilai properti yang merupakan array kosong.

00:21.060 --> 00:23.360
Di situlah kita akan menyimpan tumpukan.

00:23.400 --> 00:30.750
Dan di sini saya hanya punya di komentar semacam inisial kami Ini persis representasi yang sama atau

00:30.950 --> 00:33.290
representasi data ini di sini.

00:33.510 --> 00:36.450
Hanya agar kita dapat bekerja dengannya dan memvisualisasikan apa yang terjadi.

00:36.450 --> 00:41.400
Jadi kodesemu kita akan mendefinisikan metode yang disebut jawabannya.

00:41.400 --> 00:49.950
Dibutuhkan elemen atau nilai dan bagian termudah dan kami mendorongnya ke nilai-nilai yang baru saja ditambahkan ke bagian

00:49.950 --> 00:50.760
akhir.

00:50.760 --> 00:56.340
Jadi misalnya jika ini adalah nilai-nilai seperti apa jika kita hanya mendorong lima puluh ke ujung itu

00:56.340 --> 01:02.520
langkah pertama maka kita perlu melakukan bagian yang lebih sulit yaitu bubble up dan saya akan mendefinisikan metode

01:02.520 --> 01:05.550
terpisah hanya untuk melakukan itu untuk menyimpan ini.

01:05.820 --> 01:07.850
Saya pribadi suka melakukannya dengan cara ini.

01:07.850 --> 01:08.950
Anda tentu tidak perlu.

01:08.950 --> 01:10.210
Anda dapat melakukan semua logika di sini.

01:10.320 --> 01:13.750
Jadi saya akan menyebut ini gelembung yang tidak ada.

01:14.430 --> 01:18.930
Jadi kami harus menemukan gelembung itu dan kemudian di sini kami akan menempatkan logika yang sebenarnya.

01:18.940 --> 01:27.210
Jadi ingat apa yang perlu kita lakukan adalah ambil item ini ambil indeks item ini untuk menemukan induk yang akan menjadi jika

01:27.630 --> 01:32.940
ini adalah indeks 6 kita perlu mengambil 6 minus 1 yang memberi kita 5

01:32.970 --> 01:40.760
Bagi dengan 2 yang memberi kita 2. 5 dan kemudian putaran ke bawah atau lantai yang memberi kita indeks 2 yang ini.

01:40.770 --> 01:44.490
Jadi mari kita membuat variabel untuk menyimpan elemen dan juga indeksnya.

01:44.490 --> 01:46.770
Jadi kita hanya akan menemukan elemen terakhir.

01:46.920 --> 01:50.860
Jadi itu akan menjadi ini nilai titik panjang titik.

01:50.880 --> 01:55.400
Minus 1 memberi kita indeks jadi mari kita buat variabel yang disebut indeks.

01:55.410 --> 01:59.720
Ini akan melacak di mana item yang baru dimasukkan.

01:59.730 --> 02:01.440
Ini akan mulai sebagai indeks terakhir.

02:01.530 --> 02:06.810
Tetapi jika kita bertukar kita kemudian akan memperbarui indeks untuk berada di sini misalnya dan jika kita

02:06.810 --> 02:13.880
bertukar lagi kita akan memperbaruinya menjadi di mana pun kita bertukar dengan saya menggunakan dan kontra hanya untuk memasukkan beberapa sintaks 20:15 .

02:13.920 --> 02:15.010
Jadi itu indeksnya.

02:15.090 --> 02:19.780
Mari kita juga akan membuat variabel hanya untuk menyimpan nilai elemen itu sendiri.

02:19.830 --> 02:25.720
Jadi elemen Konstitusi indeks akan mengubah konten hanya akan tetap sebagai elemen.

02:25.770 --> 02:28.470
Jadi itu akan menjadi ide nilai titik

02:31.260 --> 02:31.920
ini.

02:31.950 --> 02:33.890
Ini hanya cara mudah.

02:33.900 --> 02:39.720
Maksud saya, kita juga bisa membuatnya sehingga metode bubble up menerima elemen dan Anda tidak

02:39.720 --> 02:40.900
perlu melakukan ini.

02:40.950 --> 02:42.400
Saya baik-baik saja dengan habitus di sini.

02:42.450 --> 02:45.810
Jadi kami meraih indeks enam dalam kasus kami.

02:46.090 --> 02:50.580
Dan ketika saya mengatakan dalam kasus kami sebenarnya saat ini tidak ada tumpukan yang ada.

02:50.580 --> 02:52.560
Jadi saya harus melakukannya sekarang mari kita lakukan.

02:52.560 --> 03:00.570
Heap sama dengan max biner heap baru dan saya hanya akan menginisialisasi cheat itu saja mulai saja ini

03:01.020 --> 03:08.830
sehingga kita tidak harus memasukkan mereka secara manual maka kita akan memanggil insert fifty five OK.

03:09.160 --> 03:15.350
Jadi jika kita baru saja selesai, kita telah menambahkan 55 ke bagian akhir untuk Dipanggil kita telah memanggil indeks gelembung naik 6.

03:15.400 --> 03:17.550
Unsurnya adalah 55.

03:18.160 --> 03:18.870
BAIK.

03:19.150 --> 03:22.020
Sekarang yang ingin kita lakukan adalah loop.

03:22.090 --> 03:27.700
Jadi saya akan mulai dengan hanya sementara benar dan terus berulang berulang dan kemudian

03:27.700 --> 03:29.990
keluar pada waktu yang tepat.

03:30.010 --> 03:34.320
Jadi proses kami adalah mengambil elemen ini dan membandingkannya dengan elemen induk.

03:34.330 --> 03:40.180
Jadi pertama-tama kita perlu menemukan indeks induk sehingga untuk menghitung itu akan membuat variabel yang disebut induk

03:40.390 --> 03:41.390
id x.

03:41.560 --> 03:44.200
Ingat rumusnya jika tidak ada di sini.

03:44.410 --> 03:48.200
Kami mengambil lantai indeks minus satu dibagi dua.

03:48.400 --> 03:49.970
Jadi saya akan melakukan matematika.

03:50.050 --> 03:59.520
Lantai dan kemudian kita perlu menambahkan parens ekstra kurangi satu dulu dan kemudian bagi dua.

04:00.150 --> 04:00.530
BAIK.

04:00.580 --> 04:08.290
Jadi biarkan orang tua matematika indexical untuk indeks minus 1 untuk mendapatkan benar dan benar-benar biarkan aku menyingkirkan

04:08.290 --> 04:10.080
loop untuk sesaat.

04:10.540 --> 04:15.880
Mari kita lakukan indeks induk log untuk memastikan itu berfungsi.

04:15.970 --> 04:17.140
Jalankan kode saya.

04:18.650 --> 04:24.080
Tiga B itu tidak benar semoga Anda melihat itu sebelum saya coba lagi.

04:24.150 --> 04:24.540
BAIK.

04:24.600 --> 04:28.320
Jadi itu memberi kami untuk mencetak juga yang merupakan indeks induk.

04:28.320 --> 04:29.390
Apakah itu benar.

04:29.550 --> 04:31.360
Mari kita lihat 0 1 2.

04:31.440 --> 04:33.810
Itu memberi kita elemen 33.

04:33.810 --> 04:36.930
Itu memang orangtua dari 55.

04:37.260 --> 04:42.700
Dan jika Anda ingin memverifikasi bahwa berdasarkan jenis visualisasi ini Anda dapat melihat.

04:42.750 --> 04:43.920
Tiga puluh tiga adalah orang tua.

04:44.130 --> 04:44.500
BAIK.

04:44.640 --> 04:51.150
Jadi sekarang yang ingin kita lakukan adalah membandingkan item pada indeks ini dengan elemen kita 55.

04:51.150 --> 04:52.110
Bandingkan kedua hal itu.

04:52.110 --> 04:56.460
Jadi kami memiliki indeks elemen dan kami memiliki indeks induknya.

04:56.510 --> 04:57.910
Sekarang mari kita lakukan perbandingan.

04:58.260 --> 05:02.210
Jadi saya akan membuat variabel terpisah untuk melakukan ini karena ini sedikit lebih pendek.

05:02.220 --> 05:13.150
Jadi biarkan orang tua sama dengan nilai dari indeks induk karena kita harus kita tidak harus melakukan variabel dengan benar.

05:13.150 --> 05:20.130
Kami hanya bisa membandingkan ini tetapi saya suka hanya label sebagai orang tua lalu apa yang akan kita lakukan.

05:20.350 --> 05:29.260
Nah jika orang tua dapat melakukannya dengan baik arah jika elemen lebih besar dari orang tua itu berarti kita

05:29.260 --> 05:30.310
ingin bertukar.

05:30.310 --> 05:38.580
Jadi saya hanya akan melakukan ini bahwa nilai indeks induk sama dengan elemen.

05:38.590 --> 05:42.110
Jadi itu menempatkan 55 di sini.

05:42.280 --> 05:51.180
Dan kemudian kita perlu mengatur indeks awal ini nilai-nilai indeks untuk sekarang menjadi orangtua.

05:51.400 --> 05:55.150
Sehingga harus menukar nilai setidaknya satu kali.

05:55.150 --> 05:56.600
Kami tidak mengulangi lagi.

05:56.650 --> 06:01.340
Jadi dan itu hanya jika elemen lebih besar sehingga dalam kasus kami adalah ketika kita memasukkan 55.

06:01.420 --> 06:03.510
Mari kita lihat apakah itu berhasil.

06:03.760 --> 06:04.260
BAIK.

06:04.420 --> 06:10.630
Jadi mari kita lihat bantuan kami sekarang dan Anda dapat melihat kami memiliki 55 di mana 33 dulu.

06:10.930 --> 06:12.670
Jadi itu benar.

06:12.670 --> 06:18.130
Sekarang kita hanya perlu mewujudkannya lagi atau tetap terjadi sementara apa.

06:18.220 --> 06:24.490
Yah saya akan menyimpannya sementara benar untuk saat ini tetapi saya akan mengubah loop saya sedikit sehingga kita mendapatkan

06:24.490 --> 06:28.590
indeks induk membaca orang tua. Kami memeriksa apakah elemen perlu ditukar.

06:28.590 --> 06:29.520
Lalu kita bertukar.

06:29.770 --> 06:33.570
Tetapi jika kita berhenti pada ini kita akan memiliki loop tak terbatas yang berlangsung selamanya.

06:33.970 --> 06:40.510
Dan juga kami tidak pernah memperbarui indeks indeks selalu masih tersisa 6.

06:40.570 --> 06:43.180
Jadi setiap kali melalui indeks induk akan seperti ini.

06:43.240 --> 06:47.500
Jadi kita akan membandingkan enam ke dalam indeks itu berulang-ulang.

06:47.500 --> 06:54.790
Jadi yang ingin kita lakukan adalah memperbarui indeks ke indeks induk karena jika kita bertukar lima puluh lima dan 33

06:54.790 --> 06:59.270
kita sekarang perlu melihat apa yang ada di 55 dan menemukan induknya.

06:59.290 --> 07:03.820
Jadi kita perlu mengubah indeks menjadi ini indeks induk yang lama.

07:04.030 --> 07:09.370
Jadi kita hampir sampai tetapi daripada melakukannya dengan cara ini di mana saya memeriksa apakah elemen lebih

07:09.410 --> 07:12.940
besar dari orang tua saya benar-benar akan mengubah logika saya sepenuhnya.

07:13.210 --> 07:22.120
Yah saya akan membalikkan kepalanya dan mengubah syarat ini menjadi sebaliknya jika elemen kurang dari atau

07:22.120 --> 07:24.130
sama dengan orangtua.

07:24.250 --> 07:31.540
Jika itu kasusnya pecah dan kemudian lakukan ini.

07:31.540 --> 07:33.720
Jadi itu hanya cara yang sedikit lebih pendek untuk mengatakan itu.

07:33.940 --> 07:39.540
Jadi sementara benar selamanya temukan indeks induk temukan nilainya di sana.

07:39.820 --> 07:43.060
Jika elemen kurang dari atau sama dengan istirahat induk kita sudah selesai.

07:43.270 --> 07:52.930
Jika demikian halnya jika misalnya kita memasukkan saya tidak tahu 11 membandingkan 11 dengan induknya 33 kita tidak

07:52.950 --> 07:54.040
menukar selesai.

07:54.700 --> 08:02.950
Namun dalam kasus 55 pertama kali melalui ini adalah apa yang kita miliki kemudian kita bertukar sehingga kita berakhir

08:02.950 --> 08:07.950
dengan 33 di sini dan 55 di sini dan kemudian indeks.

08:07.960 --> 08:09.120
Sekarang ini.

08:09.250 --> 08:11.330
Dan indeks induk di sini.

08:11.440 --> 08:16.460
Jadi kami berupaya nol dalam dua dan kami membandingkan lagi dan kami bertukar lagi.

08:16.630 --> 08:20.210
Jadi jika kita benar-benar melihat apa yang kita dapatkan itu masih tidak akan sepenuhnya benar.

08:20.800 --> 08:26.500
Tetapi jika Anda melihat heape Anda dapat melihat bahwa 55.

08:26.800 --> 08:32.040
OK Anda bisa melihat apa yang terjadi, kami mendapat swap di mana pada indeks 2 kami memiliki 41.

08:32.040 --> 08:32.890
Itu benar.

08:32.890 --> 08:35.400
Jadi kami bertukar 41 dan 55.

08:35.500 --> 08:42.140
Jadi kami pergi dari hanya menempatkan mereka semua dalam satu baris dari ini di mana kami memiliki 55 pada akhirnya kami bertukar ke sini.

08:42.400 --> 08:51.220
Lalu kami pergi ke ini di mana kami bertukar 41 dan 55 tetapi kode kami terus berjalan sekali lagi karena

08:51.220 --> 08:58.270
mencoba membandingkan 55 yang merupakan indeks 0 dan kemudian mencoba untuk menemukan indeks induk yang

08:58.300 --> 09:05.200
nol minus satu negatif 1 dibagi dua bulat indeks down atau floor down negatif 1

09:05.200 --> 09:09.780
yang akan ditentukan dan itu membandingkan undefined ke 55.

09:10.240 --> 09:16.430
Dan Anda dapat melihatnya benar-benar melakukan swap dan kami berakhir dengan 55 pada indeks negatif 1.

09:16.450 --> 09:17.670
Jadi ini adalah perbaikan sederhana.

09:17.680 --> 09:24.610
Kami hanya ingin berhenti alih-alih sementara benar katakan saja indeks baik lebih besar dari nol karena jika indeks

09:24.610 --> 09:28.260
sekarang nol kita tahu bahwa elemen adalah elemen terbesar.

09:28.270 --> 09:31.150
Misalnya 55 kami menukarnya.

09:31.300 --> 09:32.470
Kami bertukar lagi.

09:32.470 --> 09:33.620
Kita harus berhenti sekarang.

09:33.730 --> 09:35.440
Tidak ada yang bisa kita tukarkan dengan itu.

09:35.440 --> 09:37.280
Jadi berhenti saja.

09:37.410 --> 09:39.970
Sekarang mari kita coba dan lihat apakah itu berhasil.

09:39.970 --> 09:43.950
Sekarang lihat tumpukan kita.

09:43.960 --> 09:45.610
Baiklah kita punya 55 di sana.

09:45.640 --> 09:48.420
Sekarang mari kita masukkan sesuatu yang tidak besar.

09:48.850 --> 09:52.620
Mari kita masukkan sesuatu yang tidak akan ditukar sama sekali.

09:53.170 --> 09:56.340
Mari kita lakukan seperti melihat ke tumpukan kita.

09:56.530 --> 09:58.020
Tidak, tidak di sini.

09:59.200 --> 10:01.720
Jika Anda melihatnya, Anda bisa melihatnya langsung di bagian akhir.

10:01.720 --> 10:06.220
Sekarang mari kita masukkan sesuatu seperti saya tidak tahu.

10:06.340 --> 10:08.310
Sekitar 45

10:09.640 --> 10:11.820
Dan kita melihat tumpukan lagi.

10:11.900 --> 10:13.580
Jadi kami melakukan swap dengan 18.

10:13.840 --> 10:16.380
Jadi kami pada akhirnya di sini kami menghentikannya.

10:16.380 --> 10:21.640
Jadi 45 ada di sini dan kemudian kami melakukan satu swap lagi antara 45 dan 39.

10:21.730 --> 10:23.200
Jadi kita berakhir dengan 45 di sini.

10:23.230 --> 10:24.740
Dan itu benar.

10:24.760 --> 10:30.490
Dan akhirnya mari kita pastikan kita mencoba dan memasukkan sesuatu yang masif yang lebih besar seratus

10:30.490 --> 10:31.620
sembilan puluh sembilan.

10:31.650 --> 10:32.570
Seharusnya gelembung.

10:32.620 --> 10:34.410
Ya ampun, kesalahan ketik yang sama lagi.

10:34.510 --> 10:36.520
Seharusnya menggelembung sepanjang jalan di bagian atas.

10:36.550 --> 10:40.000
Mari kita lihat saja nilainya dan itu tidak apa-apa.

10:40.180 --> 10:41.870
Jadi itu masukkan.

10:42.010 --> 10:44.210
Sekali lagi itu hanya salah satu cara untuk menulisnya.

10:44.230 --> 10:49.030
Ada banyak variasi yang mungkin tetapi mereka semua mengikuti ide yang sama di mana Anda memasukkannya di akhir

10:49.180 --> 10:51.530
dan kemudian Anda menggelembungkannya ke tempat yang benar.
