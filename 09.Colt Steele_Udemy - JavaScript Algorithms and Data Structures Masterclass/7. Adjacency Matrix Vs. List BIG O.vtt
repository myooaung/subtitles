WEBVTT

00:00.210 --> 00:06.300
Sama seperti matriks adjacency ada dua cara berbeda untuk mengekspresikan tepi hubungan

00:06.300 --> 00:08.060
antara simpul kita.

00:08.370 --> 00:08.670
BAIK.

00:08.700 --> 00:10.230
Sekarang mari kita bandingkan mereka.

00:10.260 --> 00:16.530
Jadi inilah semacam slide yang mengintimidasi yang berbicara tentang notasi Big O antara yang

00:16.530 --> 00:20.760
berdekatan dengan kami dan matriks kedekatan untuk berbagai operasi.

00:20.760 --> 00:24.990
Jadi, pertama beberapa hal saya harus menjelaskan N E.

00:25.260 --> 00:28.840
Jadi v adalah sejumlah simpul adalah jumlah tepi.

00:29.010 --> 00:33.810
Jadi jika kita berpikir tentang penyimpanan berapa banyak ruang yang mereka ambil dibandingkan satu sama lain.

00:34.050 --> 00:40.530
Jika kita melihat matriks adjacency, Anda dapat melihat kita sedang melihat besar-O dari V kuadrat di mana v adalah

00:40.530 --> 00:44.410
sejumlah simpul dan itu masuk akal karena merupakan struktur dua dimensi.

00:44.430 --> 00:50.220
Jika kita menambahkan titik baru, itu berarti tidak hanya menambahkan satu slot di dalamnya berarti sebenarnya

00:50.220 --> 00:53.630
menambahkan seluruh baris di seluruh kolom ke matriks kita.

00:53.640 --> 00:55.460
Bandingkan dengan daftar adjacency.

00:55.590 --> 00:59.980
Itu benar-benar hanya tumbuh pada tingkat jumlah simpul dan tepi.

01:00.540 --> 01:01.800
Jadi saya pikir itu masuk akal.

01:01.800 --> 01:04.670
Yang harus kita simpan di sini benar-benar ukurannya diatur.

01:04.710 --> 01:09.630
Atau jika kita kembali ke contoh ini, hal yang sama dalam kedekatan daftar ukurannya jumlah penyimpanan

01:09.690 --> 01:13.260
ditentukan oleh berapa tepi berapa banyak koneksi yang kita miliki.

01:13.260 --> 01:17.000
Tetapi jika kita pergi ke matriks kita tidak masalah berapa banyak koneksi yang ada.

01:17.070 --> 01:18.720
Itu penting berapa banyak simpul.

01:18.720 --> 01:24.690
Jadi kita bisa memiliki 100 simpul lagi atau mari kita menjadi lebih konservatif katakanlah sembilan simpul lagi dan mereka mungkin

01:24.690 --> 01:29.180
tidak memiliki koneksi yang sangat banyak mereka hanya dapat memiliki masing-masing satu sisi masing-masing tepi.

01:29.370 --> 01:35.940
Yah kita masih harus menambahkan sembilan baris di sini atau muncul dan sembilan kolom dan itu

01:35.940 --> 01:36.940
banyak ruang.

01:36.960 --> 01:42.900
Jadi jika data Anda jarang jika Anda tidak memiliki banyak koneksi, banyak sisi mungkin tidak menggunakan matriks.

01:43.020 --> 01:44.550
Jadi Anda bisa menggunakan slide ini sebagai referensi.

01:44.550 --> 01:47.180
Tapi di sini ada beberapa poin kunci.

01:47.310 --> 01:53.100
Jadi daftar adjacency seperti yang telah kita bicarakan dapat mengambil lebih sedikit ruang dalam grafik jarang di mana

01:53.100 --> 01:58.060
Anda tidak memiliki banyak sisi dibandingkan dengan matriks adjacency yang membutuhkan lebih banyak ruang.

01:58.200 --> 02:02.290
V kuadrat atau V adalah sejumlah simpul daftar kedekatan.

02:02.340 --> 02:05.910
Jika semua yang Anda inginkan adalah mengetahui ujung-ujungnya hanya iterate.

02:05.910 --> 02:10.060
Misalnya mencari di semua tepi dan Anda perlu mengakses semuanya.

02:10.080 --> 02:15.990
Ini lebih mudah dilakukan dengan daftar adjacency karena saya pikir masuk akal jika kita memiliki struktur ini

02:16.260 --> 02:17.310
kita bisa mulai.

02:17.310 --> 02:19.670
Baiklah, inilah tepi. Ini semua tepi semua tepi.

02:19.740 --> 02:24.880
Jika kita pergi ke sebuah matriks, kita harus beralih pada banyak hal yang bukan edge.

02:24.960 --> 02:29.910
Kami akan memberi tahu Anda bahwa ada hal-hal yang disimpan di sini yang tidak ada yang masuk

02:29.910 --> 02:33.330
akal jika kami meninggalkan ruang kosong versus di lokasi yang berdekatan.

02:33.420 --> 02:40.520
Kami hanya menyimpan koneksi yang sebenarnya, sehingga sangat cepat untuk beralih lebih dari yang lebih rendah untuk beralih ke semua

02:40.520 --> 02:41.990
tepi dalam matriks.

02:41.990 --> 02:48.530
Namun dengan daftar adjacency mencari tepi tertentu untuk melihat apakah ada misalnya bisa lambat dalam sebuah

02:48.920 --> 02:49.770
matriks

02:49.820 --> 02:51.380
Ini sangat cepat.

02:51.380 --> 02:54.860
Anda dapat melihatnya di Big O kami di sini untuk melakukan queery sesuatu.

02:54.970 --> 02:58.010
OLF satu waktu konstan untuk matriks adjacency.

02:58.010 --> 03:03.290
Jadi jika saya ingin tahu kita kembali ke sini apakah ada keunggulan antara a dan D.

03:03.350 --> 03:06.910
Yang harus saya lakukan adalah mencari slot A dan D.

03:07.220 --> 03:08.500
Tidak, tidak ada.

03:08.510 --> 03:13.070
Apakah ada batas antara B dan C A B C.

03:13.070 --> 03:14.280
Ya ada.

03:14.330 --> 03:16.250
Ini waktu yang konstan.

03:16.400 --> 03:22.280
Jika kita membandingkannya dengan CBEST yang berdekatan sebenarnya mari kita pergi ke huruf jika saya ingin tahu apakah

03:22.280 --> 03:24.350
ada hubungan antara A dan D.

03:24.620 --> 03:29.390
Yah aku harus meminta yang pertama maka aku harus mengulangi ini.

03:29.420 --> 03:33.450
Jadi tergantung pada berapa banyak koneksi ada berapa banyak tepi ke A.

03:33.590 --> 03:38.590
Mungkin ada satu ton dan saya mungkin harus mengulangi semuanya tergantung pada jumlah tepi.

03:38.750 --> 03:42.780
Jadi saya tidak bisa langsung tahu seperti yang saya lakukan dengan matriks.

03:42.860 --> 03:49.330
Jadi di situlah kita mendapatkan oh a V ditambah E V adalah jumlah simpul adalah jumlah tepi.

03:49.370 --> 03:55.730
Jadi O besar itu sendiri tidak masalah banyak sekarang hanya tahu bahwa secara umum sebuah matriks membutuhkan lebih

03:55.730 --> 03:56.460
banyak ruang.

03:56.630 --> 03:59.470
Ketika kita berbicara tentang set data yang jarang, itu tidak bagus.

03:59.540 --> 04:04.840
Lebih lambat untuk mengulangi setiap sisi tetapi lebih cepat untuk mencari sisi tertentu.

04:04.850 --> 04:10.760
Juga beberapa orang berpikir implementasi sebuah matriks bisa menjadi sedikit lebih mudah dan daftar adjacency mengambil lebih

04:10.760 --> 04:11.740
sedikit ruang.

04:11.810 --> 04:17.030
Lebih cepat untuk mengulangi semua sisi tetapi lebih lambat untuk queery keberadaan atau untuk memeriksa apakah ada sesuatu jika

04:17.030 --> 04:18.420
ada tepi di sana.

04:18.740 --> 04:22.000
Jadi yang mana yang akan kita gunakan.

04:22.360 --> 04:24.040
Akan pergi dengan pelangi ini.

04:24.050 --> 04:26.600
Teks yang indah dan daftar kedekatan.

04:26.660 --> 04:28.040
Sangat bersemangat tentang hal itu.

04:28.220 --> 04:29.240
Ada tiga kali.

04:29.270 --> 04:31.280
Mengapa kita pergi dengan daftar adjacency.

04:31.610 --> 04:37.160
Yah terutama karena ruang yang dibutuhkan dan fakta bahwa sebagian besar data di dunia

04:37.490 --> 04:44.720
nyata apakah kita berbicara tentang teman-teman jaringan data pemodelan aktor sosial yang berada di film bersama halaman Wikipedia

04:44.720 --> 04:48.520
apa pun itu data dunia nyata cenderung jarang.

04:48.530 --> 04:54.920
Jadi kita dapat memiliki satu ton node banyak simpul tetapi biasanya mereka tidak semua

04:54.920 --> 04:58.100
terhubung dan cocok untuk daftar adjacency.

04:58.100 --> 05:01.610
Ingatlah bagan ini lihat pada simpul yang diberikan di sini.

05:01.880 --> 05:03.550
Itu tidak benar-benar memiliki banyak koneksi.

05:03.620 --> 05:04.380
Beberapa dari mereka melakukannya.

05:04.400 --> 05:09.890
Jelas tapi ada banyak node yang hanya memiliki satu sisi satu koneksi.

05:09.890 --> 05:14.960
Jadi untuk masing-masing dari ini berapa pun jumlah node di sini, jumlah simpul

05:14.960 --> 05:21.560
tampaknya membuat matriks besar versus jika kita hanya menyimpan koneksi aktual menggunakan daftar itu jauh lebih mudah.

05:21.590 --> 05:23.770
Ini sedikit dan membutuhkan lebih sedikit ruang.

05:23.900 --> 05:28.970
Jadi karena sebagian besar data dunia nyata terlihat seperti ini meskipun ada banyak data di sini.

05:29.120 --> 05:33.890
Perangkat besar tidak ada koneksi yang sangat banyak dibandingkan dengan berapa banyak mungkin ada.

05:33.890 --> 05:37.520
Jadi dalam sebuah matriks ia bekerja dengan baik jika data Anda macet.

05:37.520 --> 05:44.600
Jika matriks Anda hampir penuh maka Anda mungkin ingin menggunakan matriks tetapi sebaliknya saya lebih suka menggunakan

05:44.600 --> 05:45.770
daftar adjacency.

05:45.950 --> 05:46.930
Jadi ke sanalah kita pergi.

05:47.120 --> 05:51.040
Dan akhirnya di video berikutnya kita semua mengatur kode kita dan memulai.
