WEBVTT

00:00.180 --> 00:04.530
Baiklah mari kita mulai menerapkan kedalaman traversal pertama secara rekursif.

00:04.530 --> 00:09.660
Jadi hal pertama yang perlu kita lakukan adalah menemukan fungsi yang menerima simpul awal.

00:09.690 --> 00:15.750
OK jadi di sini saya memiliki grafik yang sama yang telah kami kerjakan dengan yang berdekatan dengan Anda daftar vertex adv. teks tambahkan tambah hapus tepi Bob Bob

00:15.810 --> 00:21.030
di sini adalah kode seperti yang ditunjukkan dalam video terakhir jika Anda ingin

00:21.030 --> 00:26.680
mengatur grafik yang sama persis itu aku kelihatannya seperti ini meskipun tidak sempurna harimau ini.

00:26.740 --> 00:28.790
Di mana Anda memiliki slide yang bagus.

00:28.800 --> 00:34.720
Jadi apa yang ingin kita lakukan adalah datang ke sini dan hanya mendefinisikan ini akan sangat lama.

00:34.740 --> 00:41.070
Anda mungkin hanya ingin pergi dengan DFS di mata DFS untuk rekursif dan intuitif tetapi karena ini adalah kode

00:41.070 --> 00:45.980
solusi saya, saya ingin orang-orang dapat menemukannya dan memahami apa itu dengan sangat mudah.

00:45.990 --> 00:55.140
Jadi saya memprioritaskan keterbacaan lebih dari seperti kedalaman rekursif pertama dan dibutuhkan titik awal.

00:55.200 --> 00:59.040
Saya sebenarnya suka menyebut ini mulai untuk membuatnya lebih jelas.

00:59.340 --> 00:59.700
BAIK.

00:59.730 --> 01:01.660
Jadi itu bagian yang mudah.

01:01.900 --> 01:04.960
Sekarang kita memiliki beberapa hal yang perlu kita buat daftar untuk menyimpan hasil akhirnya.

01:05.280 --> 01:08.710
Kita perlu membuat objek untuk menyimpan simpul yang dikunjungi.

01:08.960 --> 01:11.000
OK jadi mari kita lakukan itu.

01:11.170 --> 01:17.760
Kami datang ke sini dan memulai dengan membuat mari saya pergi dengan hasil.

01:17.760 --> 01:25.060
Pertama array kosong dan kemudian kita juga akan dikunjungi sebagai objek kosong.

01:25.230 --> 01:27.300
Jadi selanjutnya kita tambahkan daging itu.

01:27.330 --> 01:33.210
Buat fungsi pembantu yang menerima titik dan fungsi bantuan harus kembali lebih awal jika titik

01:33.210 --> 01:34.110
itu kosong.

01:34.260 --> 01:35.570
Mari kita mulai dari sana.

01:35.910 --> 01:38.130
Jadi mari kita mendefinisikan fungsi helper.

01:38.190 --> 01:46.710
Saya hanya akan memanggil DFS DFS dan butuh titik dan kemudian turun di bagian bawah.

01:46.710 --> 01:52.050
Saya benar-benar akan segera memohonnya dengan permulaan karena itu adalah pertama kalinya meskipun tidak ada logika

01:52.050 --> 01:53.460
belum pertama kali melalui

01:53.460 --> 01:56.260
Kami ingin memulai dengan permulaan.

01:56.340 --> 02:03.700
Anda juga bisa tahu bahwa Anda dapat mendefinisikannya dengan cara ini berfungsi DFS bla bla dan kemudian memanggil DFS secara manual dan lulus

02:03.790 --> 02:05.290
dan mulai seperti itu.

02:05.470 --> 02:06.870
Tapi saya lebih suka melakukannya dengan cara ini.

02:07.110 --> 02:13.260
Jadi, fungsikan DFS Virtex dan simpul itu, kita perlu memeriksa apakah itu kosong.

02:13.260 --> 02:14.290
Itu kasus dasar kami.

02:14.310 --> 02:15.090
Jadi kita lakukan saja.

02:15.140 --> 02:19.690
Jika tidak ada titik dan ingat saat itulah kita mencapai ujung garis.

02:19.770 --> 02:22.610
Jika tidak ada yang lolos ke DFS.

02:22.950 --> 02:27.700
Jadi jika tidak ada simpul kami hanya akan kembali.

02:28.080 --> 02:29.350
Saya hanya akan kembali.

02:29.870 --> 02:30.630
BAIK.

02:30.960 --> 02:31.980
Cukup besar.

02:32.130 --> 02:32.630
Semoga.

02:32.730 --> 02:34.230
OK jadi inilah fungsi pembantu.

02:34.260 --> 02:35.660
Ini akan melakukan sebagian besar pekerjaan.

02:35.850 --> 02:40.820
Menambahkan data ke dalam hasil dan dikunjungi dan kemudian pada akhir kode ini akan mengembalikan hasil.

02:40.830 --> 02:41.690
Ketika kita selesai.

02:42.060 --> 02:48.960
Jadi mari kita mulai sekarang dengan daging asli yang perlu kita lakukan logika ini fungsi pembantu harus menempatkan

02:48.960 --> 02:54.530
simpul kecuali ke objek yang dikunjungi dan mendorong simpul itu ke dalam array hasil.

02:55.020 --> 03:02.850
OK jadi di sini kita akan menambahkan simpul ke dalam hasil dan menambahkannya ke dikunjungi dan set sama dengan benar adalah

03:02.850 --> 03:04.740
bagaimana saya akan melakukannya.

03:04.860 --> 03:12.870
Jadi kami akan melakukan kunjungan kepala mengunjungi Virtex sama dengan benar bahwa mengatakan Anda tahu mengunjungi adalah

03:14.130 --> 03:18.750
benar dan kemudian kami akan melakukan hasil mendorong Virtex.

03:18.990 --> 03:20.330
Perintahnya tidak masalah.

03:20.330 --> 03:21.160
Jadi sudah selesai.

03:21.240 --> 03:27.090
Apa loop berikutnya atas semua nilai dalam daftar adjacency untuk simpul itu.

03:27.150 --> 03:31.230
Jika salah satu dari nilai-nilai itu belum dikunjungi secara rekursif panggil fungsi pembantu.

03:31.260 --> 03:31.840
BAIK.

03:32.130 --> 03:38.850
Baiklah saya akan memberitahu Anda sekarang ada masalah kecil kita bisa menulis semacam ini dengan cara sederhana yang

03:38.850 --> 03:46.140
Anda mungkin berpikir itu harus bekerja daftar kedekatan ini merujuk Anda tahu grafik itu daftar kedekatan Vertex sehingga harus

03:46.140 --> 03:52.360
memberi kita seperti jika kita apakah itu harus memberi kita array B koma C ..

03:52.650 --> 03:55.280
Tapi mari kita cetak saja, mari kita batalkan log.

03:55.290 --> 03:58.150
Ini daftar titik adjacency.

03:58.470 --> 03:58.810
BAIK.

03:58.830 --> 04:02.320
Dan saya benar-benar akan menjalankan kode ini sekarang dan menyebutnya g.

04:02.880 --> 04:05.350
Kedalaman operan rekursif pertama dalam a.

04:05.460 --> 04:13.530
Jadi kita hanya harus melihat bahwa adjacency daftar array yang dicetak tetapi kita tidak kita dapatkan kesalahan ini tidak dapat membaca

04:13.530 --> 04:15.890
daftar adjacency properti yang tidak terdefinisi.

04:15.960 --> 04:19.060
Masalah yang indah dengan ini di javascript.

04:19.080 --> 04:20.340
Kata kuncinya ini.

04:20.340 --> 04:26.520
Jadi apa yang akan saya lakukan untuk membuatnya lebih mudah adalah dengan mendefinisikan daftar adjacency kami untuk

04:26.560 --> 04:32.040
menyamakan daftar adjacency dot ini karena di sini konteks kita makna dari ini telah berubah.

04:32.040 --> 04:35.470
Jadi saya akan menyimpannya di sini dan sebut saja daftar adjacency.

04:35.520 --> 04:37.260
Itu juga membuat kode kita lebih pendek.

04:37.260 --> 04:42.510
Jadi sekarang jika saya melakukan daftar adjacency, ia tahu kapan kita mengatakan bahwa kita merujuk ke daftar

04:42.750 --> 04:46.880
adjacency data ini di mana ini mengacu pada grafik aktual itu sendiri.

04:47.100 --> 04:49.440
Jalankan kembali kodenya.

04:49.650 --> 04:51.370
Sekarang kita mendapatkan B dan C.

04:51.390 --> 04:52.050
Keren.

04:52.290 --> 04:52.820
BAIK.

04:53.040 --> 04:56.410
Jadi sekarang daripada mencetaknya, kami ingin mengulanginya.

04:56.460 --> 05:05.290
Jadi kita akan melakukan masing-masing untuk setiap tetangga dan menyebutnya naver panah kecil yang gemuk.

05:05.520 --> 05:09.310
Kami akan memeriksa apakah tetangga itu sudah dikunjungi.

05:09.660 --> 05:10.530
Jadi bagaimana kita melakukannya.

05:10.530 --> 05:14.750
Yah kita punya objek yang dikunjungi yang baru saja melewati tetangga.

05:14.850 --> 05:21.600
Sehingga Anda tahu B dan C untuk kasus pertama jika kita memulainya dan kami ingin melakukan ini jika belum

05:21.600 --> 05:26.910
dikunjungi jika sudah dikunjungi kami dapat mengabaikannya tetapi jika belum dikunjungi apa yang akan kami

05:26.910 --> 05:31.650
kunjungi lakukan jika belum dikunjungi secara rekursif panggil fungsi pembantu dengan simpul itu.

05:31.940 --> 05:32.460
BAIK.

05:32.550 --> 05:39.840
Jadi jika belum dikunjungi maka kita ingin mengembalikan tetangga DFS OK.

05:40.200 --> 05:41.460
Dan pada dasarnya kita sudah selesai.

05:41.490 --> 05:43.200
Kami kehilangan satu hal di akhir.

05:43.350 --> 05:48.640
Saya akan membahas hal ini tentu saja tetapi kita perlu mengembalikan array hasil aktual yang sedang kita bangun.

05:49.410 --> 05:55.980
OK jadi jika ini pertama-tama mari kita sebelum saya benar-benar menjelaskannya biarkan saya pastikan saya menerapkannya dengan

05:55.980 --> 05:56.750
benar.

05:56.760 --> 05:59.430
Sangat mudah memiliki kesalahan ketik saat Anda berbicara.

05:59.910 --> 06:02.660
Itulah momen kebenaran di sini.

06:03.490 --> 06:03.960
BAIK.

06:03.970 --> 06:06.240
Jadi g dot No. yang berdekatan

06:06.330 --> 06:06.890
Apa yang saya lakukan.

06:06.930 --> 06:10.320
G dot depth pertama rekursif mulai dari a.

06:10.620 --> 06:11.800
Oke, ini berhasil.

06:11.970 --> 06:18.070
ECF Saya sudah melakukan ini beberapa kali jadi saya tahu anak perempuan Serhiy yang membuat slide ke urutan itu.

06:18.390 --> 06:21.020
Tapi mari kita benar-benar berjalan melalui apa yang terjadi di tumpukan panggilan.

06:21.210 --> 06:24.230
Jadi, jika Anda baik hanya untuk melihat itu berfungsi dan Anda selesai.

06:24.270 --> 06:27.540
Cukup adil agak sulit untuk dilalui.

06:27.540 --> 06:34.330
Tapi mari kita benar-benar membuka debugger dan saya akan menelepon ke sini, cukup salin baris ini.

06:34.530 --> 06:36.230
Jadi kita melihat apa yang sedang kita kerjakan.

06:36.600 --> 06:37.740
Dan pada titik istirahat.

06:38.010 --> 06:38.380
BAIK.

06:38.400 --> 06:39.820
Jadi jalankan kodenya.

06:40.080 --> 06:44.970
Gulir kembali ke atas ke area yang menarik dan saya melangkah melalui ini.

06:45.000 --> 06:49.270
Baiklah kita dapatkan panggilan pertama kita secara mendalam rekursif pertama di mana awal sama dengan a.

06:50.400 --> 06:53.240
Dan kami menginisialisasi beberapa data kami.

06:53.760 --> 06:54.470
BAIK.

06:54.770 --> 06:59.680
Sekarang kita dapatkan DFS panggilan pertama kami dengan start.

06:59.700 --> 07:01.220
Jadi simpul adalah a.

07:01.710 --> 07:04.320
Jadi kalau bukan vertex atau Turnell itu tidak benar.

07:04.350 --> 07:08.240
Benar jadi kami melewati garis yang kami setel untuk menjadi benar.

07:08.400 --> 07:13.500
Kami mendorong hasil.

07:13.800 --> 07:15.990
Jadi hasilnya sekarang berisi a.

07:16.200 --> 07:20.090
Jadi Anda dapat menggulir ke bawah memiliki dua tetangga B dan C.

07:20.340 --> 07:23.230
Jadi kita akan pergi dengan apa pun yang terdaftar pertama yaitu B.

07:23.250 --> 07:24.590
Itulah cara saya membangunnya.

07:24.600 --> 07:27.040
Saya menambahkan koneksi itu sebelum ABC.

07:27.300 --> 07:28.640
Jadi kita akan menjadi yang pertama.

07:29.070 --> 07:30.640
Jadi mari kita ke bagian itu.

07:30.760 --> 07:37.710
Dapat melihat kita mendapatkan fungsi anonim ini untuk setiap yang telah ditambahkan dan kita akan memeriksa tetangga yang dikunjungi

07:37.710 --> 07:39.980
berat satu tetangga adalah B.

07:40.290 --> 07:40.980
Kami belum.

07:41.040 --> 07:46.460
Jadi kami mengembalikan DFS dari B dan Anda akan melihat DFS lain sesaat.

07:46.470 --> 07:47.210
Kita mulai.

07:47.220 --> 07:49.820
Jadi kami masih memiliki beberapa panggilan di sini di stack.

07:49.860 --> 07:54.210
Ini adalah DFS dari fungsi internal bersarang di sini.

07:54.240 --> 07:58.040
Ini adalah untuk masing-masing yang menunggu juga lakukan untuk masing-masing C ..

07:58.340 --> 07:58.700
BAIK.

07:58.740 --> 08:01.570
Jadi sekarang kita berada di B dan saya akan mempercepatnya sedikit.

08:01.620 --> 08:02.510
Kami memeriksa.

08:02.510 --> 08:03.250
Apakah ada simpul.

08:03.270 --> 08:04.440
Ya simpul B.

08:04.500 --> 08:06.210
Jadi kalimat itu tidak benar.

08:06.240 --> 08:10.470
Kami pastikan untuk Markby dikunjungi kami mendorong hasil B dan 2.

08:10.490 --> 08:13.190
Jadi sekarang hasilnya memiliki koma B.

08:13.240 --> 08:22.260
Sekarang untuk setiap anak dan katakan anak untuk tetangga B yang berarti B benar-benar hanya memiliki satu yang D dan

08:22.260 --> 08:24.030
benar-benar salah bicara.

08:24.030 --> 08:25.300
Ada dua tetangga.

08:25.600 --> 08:27.280
Ada a dan D.

08:27.420 --> 08:28.810
Tapi kami sudah mengunjungi.

08:28.950 --> 08:31.690
Jadi Anda dapat melihat kami memeriksa jika kami mengunjungi tetangga.

08:31.710 --> 08:33.450
Ya sudah ditandai Sudah dikunjungi.

08:33.600 --> 08:35.130
Jadi ini tidak terjadi.

08:35.130 --> 08:40.750
Kami tidak mengembalikan DFS telur, tetapi kami mencoba lagi dengan tetangga yang ditetapkan sekarang.

08:41.130 --> 08:45.190
Dan ini benar kami belum mengunjungi Deitz. Jadi kami telah mengembalikan DFS ofensif.

08:45.240 --> 08:47.160
Dan Anda akan melihatnya ditambahkan ke tumpukan.

08:47.580 --> 08:48.240
Itu ada.

08:48.240 --> 08:52.570
Ini defensif jika Virtex tidak kosong itu bukan palsu.

08:52.680 --> 08:59.760
Jadi kita terus berjalan, kita mengabaikan pasukan vertex yang dikunjungi dan sekarang kita mengunjungi Dion dan akan pergi ke

08:59.760 --> 09:00.400
tetangga.

09:00.410 --> 09:06.730
Nah apa tetangga ini memang memiliki B E dan F C L C pertama kali lewat.

09:06.870 --> 09:09.190
Kami sedang mencari di B tetapi kami sudah mengunjunginya.

09:09.210 --> 09:10.500
Jadi kami abaikan.

09:10.710 --> 09:11.330
Sekarang kita melihat.

09:11.350 --> 09:13.410
E yang belum kami kunjungi.

09:13.680 --> 09:21.270
Jadi kami punya defensif dan mulga tumpukan panggilan ini tumbuh cukup defensif ada di sini dan kami memeriksa jika tidak

09:21.870 --> 09:22.990
Virtex Baiklah.

09:23.010 --> 09:26.250
Ada Texas e sehingga kami memasarkan seperti yang dikunjungi.

09:26.280 --> 09:27.680
Kami mendorongnya untuk hasil.

09:27.930 --> 09:30.040
Lalu kita pergi ke masing-masing tetangganya.

09:30.180 --> 09:34.830
Jika Anda melihat daftar adjacency untuk e Anda dapat melihat c d n f.

09:34.830 --> 09:35.390
Baiklah.

09:35.550 --> 09:36.620
Jadi kita akan mulai dengan C ..

09:36.630 --> 09:44.840
Ini terdaftar pertama dan tetangga melihat kami belum mengunjungi c jadi kami mengembalikan DFS dari C dan

09:44.840 --> 09:45.500
ditambahkan.

09:45.980 --> 09:46.830
Oh Boy.

09:47.040 --> 09:48.720
Seharusnya membuat grafik yang lebih kecil.

09:48.720 --> 09:51.410
Lihat Virtex adalah kebenaran.

09:51.410 --> 09:53.650
Jadi kami lewati ini.

09:53.690 --> 09:54.500
Kami mengunjunginya.

09:54.500 --> 09:57.740
Kami mengatakan itu benar dan mengunjungi hasil dengan dorongan.

09:58.820 --> 10:01.030
Sekarang untuk masing-masing tetangganya.

10:01.150 --> 10:05.050
Apa yang dilihat tetangga MEMILIKINYA MEMILIKI A dan E.

10:05.300 --> 10:11.330
Yah kita sudah mengunjungi hari jadi kita tidak melakukan ini kita lewati.

10:11.360 --> 10:13.800
Kami sudah mengunjungi juga bukan.

10:14.170 --> 10:15.130
BAIK.

10:16.040 --> 10:17.980
Jadi apa yang terjadi sekarang?

10:17.990 --> 10:19.340
Ini adalah momen nyata.

10:19.340 --> 10:21.310
Akhirnya kita menemui jalan buntu.

10:21.350 --> 10:21.920
Kanan.

10:21.920 --> 10:26.380
Kami pergi untuk melihat dan kami sudah ke ujung yang dalam.

10:26.820 --> 10:28.240
Bukan itu yang terjadi.

10:28.610 --> 10:30.310
Baik perhatikan tumpukan panggilan di sini.

10:31.140 --> 10:35.220
Ada sesuatu yang muncul di sana untuk setiap yang menunggu.

10:35.220 --> 10:36.870
Jadi sudah selesai.

10:36.870 --> 10:43.640
Sekarang kita kembali ke sini di mana kita memiliki simpul E dan kita melihat tetangganya yang kita lihat.

10:44.400 --> 10:52.160
Dan sekarang kita sedang melihat tetangganya yang lain yaitu D yang telah kita kunjungi dan sekarang kita sedang melihat

10:52.160 --> 10:54.640
tetangga terakhirnya yang belum kita kunjungi.

10:54.680 --> 10:57.940
Jadi kita akan menambahkan upaya defensif ke tumpukan panggilan.

10:57.950 --> 10:59.630
Ini dia.

10:59.630 --> 11:04.880
Sekarang kita melihat F dan ada f. kami makan kami mengunjunginya kami menambahkan ke hasil.

11:05.120 --> 11:05.810
BAIK.

11:05.810 --> 11:08.280
Sekarang kita melihat masing-masing tetangganya.

11:08.340 --> 11:10.730
Apakah ada sesuatu yang belum dikunjungi pada saat ini.

11:10.730 --> 11:12.410
Kami telah melihat segalanya.

11:12.530 --> 11:15.270
Kami mengunjungi semua yang ada di seluruh grafik ini.

11:15.320 --> 11:19.730
Jadi semuanya ditandai telah dikunjungi yang berarti kita tidak mengembalikan apa pun di sini.

11:20.000 --> 11:24.570
Jadi kita terus berjalan dan Anda akan melihat segala sesuatunya akhirnya

11:29.480 --> 11:37.460
muncul dan akhirnya kita keluar dari fungsi utama helper batin kita dan akhirnya kita mengembalikan hasil pada bagian paling

11:37.460 --> 11:39.820
akhir yang terlihat seperti ini.

11:39.900 --> 11:44.580
Dan itu seharusnya hanya sebentar di sana.

11:44.620 --> 11:45.400
Ini dia.

11:45.560 --> 11:47.190
ABDC f.

11:47.420 --> 11:47.960
BAIK.

11:48.380 --> 11:50.050
Jadi ada banyak hal yang harus dilalui.

11:50.050 --> 11:54.650
Saya benar-benar mengerti jika Anda tidak berhasil melewati itu saya hampir tidak selamat.

11:54.710 --> 12:00.590
Jadi rekursi bisa sedikit sulit untuk diikuti tetapi anggap saja sebagai mengunjungi simpul dan mengunjungi satu tetangga dan

12:00.590 --> 12:04.650
kemudian mengunjungi kembali salah satu tetangga dan mengunjungi salah satu tetangganya.

12:04.660 --> 12:05.560
Lagipula itu banyak.

12:05.580 --> 12:06.710
Sangat mengerti.

12:06.710 --> 12:11.810
Saya berharap bahwa setidaknya sedikit masuk akal bagaimana kerjanya cara kerja rekursi.

12:11.810 --> 12:14.280
Ingat saya harus melakukan daftar kedekatan ini.

12:14.300 --> 12:15.940
Ini adalah satu-satunya gotcha.

12:15.950 --> 12:19.940
Karena konteks makna perubahan ini dalam fungsi batin kita.

12:19.940 --> 12:24.530
Jadi untuk melestarikannya muncul juga mempersingkat kode kami hanya sedikit.

12:24.620 --> 12:28.380
Saya berharap akan ada sejumlah pertanyaan yang sehat untuk hal ini.

12:28.400 --> 12:32.210
Ini agak sulit, tetapi saya pikir itu mungkin juga membantu dalam video berikutnya.

12:32.220 --> 12:34.430
Saya akan melakukan hal yang sama berulang-ulang.

12:34.610 --> 12:36.790
Jadi sebenarnya urutannya akan sedikit berbeda.

12:36.860 --> 12:38.090
Masih akan menjadi kedalaman pertama.

12:38.090 --> 12:43.940
Tidak hanya ada satu urutan pertama kedalaman tetapi hasil aktual yang kita dapatkan akan terlihat sedikit berbeda dan Anda akan melihat

12:43.940 --> 12:45.080
mengapa hanya sedikit.
