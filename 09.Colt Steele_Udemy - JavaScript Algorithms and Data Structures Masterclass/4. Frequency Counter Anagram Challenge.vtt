WEBVTT

00:00.180 --> 00:00.850
Selamat datang kembali.

00:00.930 --> 00:03.770
Saya hanya di sini dengan cepat untuk memperkenalkan masalah berikutnya.

00:03.840 --> 00:05.040
Jika Anda ingin mencobanya.

00:05.220 --> 00:09.410
Jadi itu ada hubungannya dengan fungsi penulisan anagram yang disebut anagram valid.

00:09.420 --> 00:13.980
Itu membutuhkan dua string dan mengembalikan true jika string adalah anagram satu sama lain.

00:13.980 --> 00:15.790
Sekarang ada banyak cara untuk menyelesaikan ini.

00:15.810 --> 00:21.390
Jelas beberapa lebih baik daripada yang lain tetapi ide saya atau tujuan di sini adalah bagi Anda untuk mencoba dan

00:21.390 --> 00:25.450
menyelesaikannya dengan menggunakan pola penghitung frekuensi atau apa pun yang Anda ingin menyebutnya.

00:25.470 --> 00:30.960
Ini adalah kasus penggunaan yang sempurna di mana kami memiliki dua string dua item dan kami ingin

00:30.990 --> 00:34.820
membandingkan kemunculan karakter di masing-masing karakter dan melihat apakah keduanya sama.

00:34.830 --> 00:40.230
Jadi tidak hanya jika huruf-hurufnya ada di sana, tetapi juga jika mereka ada di

00:40.230 --> 00:41.880
sana, frekuensi frekuensi benar.

00:41.880 --> 00:48.420
Jadi misalnya string kosong juga string kosong yang seharusnya benar dan mudah ZZ Z A.

00:48.600 --> 00:53.910
Jadi ini bukan masalah hanya memeriksa apakah mereka memiliki karakter yang sama karena ini memiliki Z

00:54.050 --> 00:57.780
yang memiliki ini adalah itu perlu nomor yang sama juga.

00:57.900 --> 00:59.580
Jadi ini salah.

00:59.580 --> 01:05.840
Ini benar anagram dan nag ram tikus dan mobil jatuh.

01:05.850 --> 01:07.700
Tentu saja saya tidak tahu mengapa ada dua kesalahan.

01:07.710 --> 01:09.030
Maaf soal itu.

01:09.590 --> 01:15.070
Dan ya, Anda dapat menonton sisa contoh atau memeriksa melihatnya tetapi pada dasarnya mengambil satu string.

01:15.100 --> 01:21.170
Ambil string lain dan lihat apakah mereka terdiri dari karakter yang sama persis dalam urutan yang sama.

01:21.180 --> 01:21.390
Kanan.

01:21.390 --> 01:28.020
Itu harus benar jika kami mencoba kucing dan kucing tetapi kemungkinan besar dalam urutan dan rekomendasi yang berbeda.

01:28.050 --> 01:33.180
Tujuannya adalah menggunakan pola penghitung frekuensi untuk membuat objek atau Anda bisa melakukannya

01:33.180 --> 01:39.870
dengan dua atau hanya satu objek yang akan menjadi yang akan mewakili terjadinya setiap huruf di salah

01:39.870 --> 01:40.930
satu string.

01:41.040 --> 01:42.990
Jadi, Anda harus memiliki lebih dari satu loop.

01:42.990 --> 01:47.970
Anda harus membuat objek ini dan kemudian Anda harus mengulangi string lain mana pun

01:47.970 --> 01:52.980
yang tidak Anda gunakan untuk membangun objek itu dan membandingkannya dan mengurutkan pembaruan objek dengannya.

01:53.010 --> 01:54.210
Jadi saya tidak ingin banyak bicara.

01:54.210 --> 01:55.840
Saya akan memberi Anda solusi.

01:55.860 --> 01:57.210
Dalam video yang mengikuti.

01:57.330 --> 02:01.920
Tetapi jika Anda ingin mencobanya saya memiliki latihan di editor sehingga Anda dapat menguji kode Anda dan melihat

02:01.920 --> 02:02.830
apakah itu berhasil.

02:02.880 --> 02:05.240
Dan kemudian saya akan kembali dengan solusi solusi yang sebenarnya.

02:05.400 --> 02:10.860
Oh, dan sebelum saya lupa Anda bisa berasumsi semua input akan menjadi kata tunggal sehingga tidak akan ada spasi tidak

02:10.860 --> 02:13.560
akan ada periode tanda baca, tidak akan ada angka.

02:13.560 --> 02:19.240
Anda juga dapat berasumsi bahwa mereka semua huruf kecil dan jadi Anda tidak perlu khawatir tentang Anda tahu

02:19.360 --> 02:21.570
modal dan membandingkannya dengan huruf kecil a.

02:21.630 --> 02:23.120
Jadi semuanya huruf kecil.

02:23.160 --> 02:27.420
Jika ini adalah pengaturan wawancara saya pasti akan mendorong Anda untuk bertanya pertanyaan-pertanyaan bagaimana dengan

02:27.420 --> 02:28.140
kasus tepi.

02:28.140 --> 02:29.350
Bagaimana dengan ruang.

02:29.490 --> 02:33.050
Semua itu tapi kami bukan kami hanya fokus pada kata kecil.

02:33.140 --> 02:33.480
BAIK.
