WEBVTT

00:00.150 --> 00:00.500
Baiklah.

00:00.510 --> 00:01.220
Selamat datang kembali.

00:01.320 --> 00:05.230
Mari kita bicara sedikit tentang bagian fungsi hash dari tabel hash kita.

00:05.520 --> 00:12.990
Jadi kita akan menggunakan fungsi hash untuk mengonversi kunci seperti string pink atau apa itu cyan dan mengubahnya menjadi

00:12.990 --> 00:14.640
indeks array yang valid.

00:14.640 --> 00:19.670
Sejumlah kecil tetapi fungsi hash telah menggunakan seluruh dunia Internet dan privasi dan hanya

00:19.680 --> 00:20.850
komputasi pada umumnya.

00:20.940 --> 00:24.930
Jadi di Wikipedia penggunaan pertama yang terdaftar adalah tabel hash.

00:24.930 --> 00:26.030
Apa yang kita bicarakan.

00:26.190 --> 00:31.590
Tetapi mereka juga digunakan untuk membantu melindungi data Anda untuk menyimpan data Anda untuk mengotentikasi Anda ketika

00:31.590 --> 00:36.390
Anda login di situs Web yang digunakan dalam mata uang kripto dan kriptografi secara umum.

00:36.410 --> 00:41.910
Ada banyak banyak jenis fungsi hash termasuk subkelompok yang disebut fungsi hash kriptografi

00:42.180 --> 00:43.420
yang gila.

00:43.440 --> 00:45.200
Matematika dan sains di belakang mereka.

00:45.360 --> 00:50.520
Ini adalah hal-hal di mana saya katakan ada seperti tim peneliti yang

00:50.520 --> 00:56.780
mengerjakannya fungsi hash kriptografi adalah cabang kriptografi gila yang sudah menjadi cabang ilmu pengetahuan yang gila.

00:56.820 --> 00:57.970
Ini hal yang menyenangkan.

00:57.970 --> 00:59.210
Tentu saja saya punya.

00:59.270 --> 01:04.590
Apakah saya boleh mengatakan bahwa saya mungkin atau mungkin tidak memiliki kursus tentang topik ini dan tentang mata uang kripto dan

01:04.590 --> 01:05.620
bagaimana semuanya cocok bersama.

01:05.870 --> 01:08.110
OK saya harap saya tidak mendapat masalah untuk itu.

01:08.220 --> 01:14.070
Pokoknya apa yang kita bicarakan hanyalah fungsi hash dasar dan definisi fungsi hash dasar hanyalah

01:14.370 --> 01:20.220
sebuah fungsi yang mengambil data ukuran sewenang-wenang apakah itu seribu karakter atau sejuta karakter dan

01:20.220 --> 01:23.550
akan memuntahkan data dengan ukuran tetap .

01:23.580 --> 01:28.160
Ini akan memetakan input ke output dengan ukuran tetap.

01:28.170 --> 01:31.020
Jadi bagi kami, kami hanya menunjukkan contoh.

01:31.020 --> 01:36.180
Ini dalam Python yang saya tahu banyak dari Anda mungkin tidak tahu ini bukan kursus khusus

01:36.720 --> 01:38.030
Python yang tidak penting.

01:38.030 --> 01:43.470
Bahasa seperti javascript sebenarnya tidak mengekspos fungsi hash bawaan tetapi Python melakukannya dan beberapa yang lain

01:43.470 --> 01:43.940
melakukannya.

01:43.950 --> 01:48.780
Jadi saya hanya akan menggunakan ini di sini untuk menunjukkan ini adalah salah satu jenis

01:48.780 --> 01:55.410
fungsi hash ada banyak implementasi tetapi yang satu ini memungkinkan kita untuk memasukkan beberapa data seperti katakanlah halo dengan tanda seru

01:55.410 --> 01:56.920
ketika saya menekan enter.

01:57.000 --> 01:58.120
Saya mendapat nomor.

01:58.170 --> 02:04.800
Saya tidak akan menghitung karakter atau bit tetapi dari ukuran ini dan saya bisa melakukannya lagi dan hanya mengubah

02:04.800 --> 02:07.510
sesuatu yang sedikit seperti membuat modal H.

02:08.700 --> 02:10.460
Dan saya mendapatkan nomor dengan ukuran yang sama.

02:10.470 --> 02:12.970
Ini bergeser karena tanda negatif ini ada di sana.

02:13.200 --> 02:17.820
Tetapi jika kita melihat pada saat yang sama itu adalah jumlah karakter yang sama tetapi itu sama sekali

02:17.820 --> 02:19.110
berbeda hanya dari mengubah H.

02:19.260 --> 02:22.060
Tapi saya bisa melakukan satu karakter seperti.

02:22.320 --> 02:27.720
Dan saya masih mendapatkan nomor yang benar-benar salah ini atau saya bisa membuat string super panjang

02:27.720 --> 02:32.360
yang jauh lebih besar dari angka itu dan itu akan dipadatkan menjadi ini.

02:32.400 --> 02:34.500
Sekarang beberapa hal yang harus kita bicarakan.

02:34.500 --> 02:34.960
1.

02:34.980 --> 02:36.800
Jadi ini ukuran tetap.

02:36.870 --> 02:39.840
Ini adalah data yang berukuran sama tidak peduli apa inputnya.

02:39.840 --> 02:41.270
Dan itu penting.

02:41.280 --> 02:46.680
Hal lain yang saya tidak bicarakan adalah dalam kebanyakan kasus fungsi hash kita tidak dapat bekerja mundur.

02:46.680 --> 02:48.820
Ini sebenarnya tidak ada artinya sendiri.

02:48.870 --> 02:50.430
Jika yang kita miliki hanyalah output.

02:50.550 --> 02:57.780
Ini biasanya fungsi satu arah yang berarti saya tidak bisa mengambil ini dan mencari tahu apa yang menghasilkan

02:57.780 --> 02:58.590
angka ini.

02:58.590 --> 03:03.690
Jadi fungsi hash ini menghasilkan cukup besar yang relatif kecil dalam skema besar dibandingkan dengan

03:03.690 --> 03:04.920
fungsi hash lainnya.

03:05.040 --> 03:08.350
Tetapi bagi kami terlalu besar, kami tidak ingin menyimpan angka.

03:08.400 --> 03:10.700
Anda tahu indeks ini dalam sebuah array.

03:10.890 --> 03:13.880
Karena dengan begitu kita akan memiliki banyak ruang kosong di array kita.

03:13.950 --> 03:21.210
Kami ingin menyimpan barang-barang dalam array seperti 200 atau 20 atau bahkan sepuluh tempat 10 elemen.

03:21.360 --> 03:23.630
Dan ini seperti apa triliunan.

03:23.640 --> 03:25.990
Saya bahkan tidak tahu lebih dari triliunan.

03:26.130 --> 03:29.940
Jadi kita tidak akan menggunakan fungsi hash ini kita akan menulis sendiri yang sederhana kita berdua berbicara tentang

03:29.940 --> 03:31.690
apa yang membuat fungsi hash yang baik.

03:31.890 --> 03:34.130
Jadi pertama-tama perlu cepat.

03:34.170 --> 03:39.360
Kami tidak ingin menghabiskan selamanya hashing sesuatu karena ketika kami memasukkan sesuatu ke tabel hash kami

03:39.360 --> 03:40.310
perlu hash.

03:40.470 --> 03:46.560
Tetapi juga ketika kita pergi dan mengambilnya atau memperbarui atau menghapusnya setiap kali kita mencoba mengaksesnya setelah itu kita masih

03:46.620 --> 03:48.780
harus menjalankan fungsi hash itu lagi.

03:48.960 --> 03:49.230
Kanan.

03:49.230 --> 03:53.040
Saya harus mengatakan hei apa hash pink yang akan memberi saya nomor dan kemudian saya akan pergi

03:53.040 --> 03:57.090
ke nomor itu dalam array dan kemudian jika saya mencoba untuk memperbarui cat dan ketika saya katakan inilah

03:57.090 --> 03:58.030
pink Apa hash .

03:58.050 --> 04:00.110
Jadi kami ingin cepat.

04:00.510 --> 04:05.520
Kami ingin memastikan bahwa itu adalah istilah serang yang relatif acak atau acak. Kami ingin memastikan

04:05.520 --> 04:11.340
bahwa itu mendistribusikan hal-hal secara seragam sehingga hal-hal tidak mengelompok. Kami tidak ingin duduk seperti fungsi hash bodoh

04:11.340 --> 04:15.100
yang selalu akan hanya memberi kami tengah array atau posisi nol.

04:15.210 --> 04:18.770
Tidak ada gunanya jika setiap elemen disimpan di tempat yang sama.

04:18.870 --> 04:23.700
Sekarang kita mungkin memiliki tabrakan dan kita akan berbicara tentang bagaimana menangani apa yang mungkin kita miliki jika

04:23.700 --> 04:26.410
kita hanya menyimpan barang-barang di seratus titik dalam array.

04:26.760 --> 04:32.400
Jika kita menyimpan seperti 500 hal kita harus berbagi beberapa lubang cubby beberapa elemen di sana dan itu

04:32.400 --> 04:33.030
OK.

04:33.060 --> 04:35.390
Tapi kami ingin itu tersebar merata.

04:35.400 --> 04:39.130
Dan terakhir kami ingin itu menjadi deterministik dan ini sangat penting.

04:39.150 --> 04:45.090
Ini berarti bahwa setiap kali kita memasukkan satu input, kita selalu mendapatkan output yang sama, ditentukan bahwa kita akan mendapatkan

04:45.090 --> 04:46.030
output yang sama.

04:46.030 --> 04:52.800
Kami tidak ingin harus kami tidak ingin ada ketidakpastian atau beberapa jawaban atau output per satu input

04:52.890 --> 04:54.070
yang diberikan.

04:54.180 --> 04:57.500
Jadi kami ingin input yang sama selalu memberikan hasil yang sama.

04:57.510 --> 05:00.270
Jadi mari kita cepat menjalankannya melalui Berikut ini adalah contoh.

05:00.340 --> 05:04.930
Ini adalah contoh buruk yang mengapa saya menulis contoh fungsi hash lambat.

05:04.930 --> 05:06.450
Kami tidak menginginkan ini.

05:06.460 --> 05:12.760
Yang dilakukannya hanyalah pada awalnya ia berputar ribuan kali 10.000 kali dan hanya mencetak sesuatu dan

05:12.760 --> 05:13.950
kemudian melakukan hashing.

05:13.990 --> 05:14.190
Baiklah.

05:14.200 --> 05:15.070
Itu konyol.

05:15.070 --> 05:18.340
Tetapi kami ingin mencoba dan menjaga segala sesuatunya dengan cepat dan cepat.

05:18.340 --> 05:21.290
Kami tidak ingin harus Anda ketahui berulang kali.

05:21.370 --> 05:23.590
Kami menginginkan sesuatu yang merupakan waktu yang konstan.

05:23.680 --> 05:26.200
Jadi kita akan menulis beberapa fungsi hash kita sendiri hanya dalam sedikit.

05:26.240 --> 05:26.870
Ingatlah itu.

05:26.890 --> 05:28.500
Kami ingin cepat.

05:28.840 --> 05:31.440
Kami ingin mendistribusikan nilai secara seragam.

05:31.450 --> 05:34.710
Jadi tidak seperti ini yang hanya memberi nol.

05:34.740 --> 05:37.900
Ini adalah fungsi hash yang valid jika memenuhi definisi kami.

05:37.990 --> 05:42.550
Dibutuhkan input dari berbagai ukuran dan memetakannya ke output dengan ukuran tetap.

05:42.550 --> 05:49.030
Itu hanya memetakan setiap input ke nol yang bukan yang kita inginkan dan kemudian deterministik sehingga

05:49.030 --> 05:51.520
juga tidak bagus karena tidak deterministik.

05:51.520 --> 05:58.120
Ini melibatkan angka acak dikalikan dengan 1000 dan kemudian menambahkan bahwa itu tidak baik karena itu tidak akan memberi

05:58.120 --> 06:01.930
kita output yang sama setiap kali untuk input yang sama.

06:01.930 --> 06:05.890
Jadi dalam video berikutnya saya akan menunjukkan kepada Anda fungsi hash sederhana yang bisa kita tulis yang hanya

06:05.890 --> 06:06.840
akan bekerja dengan string.

06:06.840 --> 06:11.040
Tapi itu memenuhi beberapa kriteria ini dan kemudian kita akan mencoba dan mengubahnya dan membuatnya lebih baik.
