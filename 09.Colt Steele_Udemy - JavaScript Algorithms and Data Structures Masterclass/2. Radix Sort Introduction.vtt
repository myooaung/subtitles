WEBVTT

00:00.180 --> 00:06.690
Selamat datang kembali semua jenis yang telah kita lihat sejauh ini bersama-sama dalam grup yang disebut algoritma

00:06.720 --> 00:07.940
pengurutan perbandingan.

00:08.130 --> 00:13.050
Semua itu berarti bahwa apakah kita berbicara tentang semacam gelembung atau sesuatu yang lebih

00:13.650 --> 00:19.710
maju seperti quicksort pada akhir hari di bawah permukaan, perbandingan dasar yang kita lakukan adalah antara dua item

00:19.710 --> 00:20.910
pada titik tertentu.

00:21.210 --> 00:25.290
Jadi kita memiliki satu item di sebelah kiri katakanlah dan satu lagi di kanan dan kita memutuskan

00:25.290 --> 00:28.340
mana yang lebih dulu atau yang mana tergantung pada bagaimana kita menyortir.

00:28.440 --> 00:31.690
Jadi perbandingan semacam itu berarti kita membandingkan dua hal.

00:31.920 --> 00:34.640
Itu yang paling sering kita bandingkan pada waktu tertentu.

00:34.800 --> 00:39.770
Kami melakukan kurang dari versus lebih besar dari itu dan kemudian kami memutuskan ke mana barang itu pergi.

00:39.780 --> 00:45.230
Jadi ketika kita berbicara tentang kompleksitas waktu rata-rata untuk sesuatu seperti semacam gelembung kuadrat.

00:45.240 --> 00:47.810
Sama untuk jenis penyisipan dan pemilihan.

00:47.970 --> 00:53.010
Kemudian kami melihat sedikit dan jauh lebih baik daripada sedikit perbaikan, kami melihat peningkatan yang cukup

00:53.520 --> 00:58.260
besar dengan quicksort dan jenis penggabungan yang memiliki kompleksitas waktu rata-rata 0 dari log akhir.

00:58.260 --> 01:01.130
Jadi pertanyaannya adalah apakah ada algoritma penyortiran yang lebih cepat.

01:01.140 --> 01:03.900
Bisakah kita meningkatkan dan mencatatnya.

01:03.900 --> 01:05.210
Bisakah kita berbuat lebih baik.

01:05.280 --> 01:11.510
Dan jawabannya adalah semacam jawaban ya kita bisa tetapi tidak dengan membuat perbandingan.

01:11.640 --> 01:17.940
Jadi secara matematis ada batas bawah asimtot untuk kompleksitas waktu rata-rata dalam jenis

01:17.940 --> 01:18.680
perbandingan.

01:18.730 --> 01:23.700
Jadi tidak peduli apa algoritma perbandingan aktual dengan algoritma pengurutan adalah quicksort.

01:23.700 --> 01:29.350
Heapsort shell sort salah satu yang pernah kita lihat semacam cocktail shaker belum pernah mendengar itu.

01:29.370 --> 01:30.120
Semua ini.

01:30.150 --> 01:30.870
Ya tidak semuanya.

01:30.870 --> 01:33.390
Beberapa dari mereka lebih lambat seperti yang kita lihat dengan semacam gelembung.

01:33.510 --> 01:41.890
Tetapi kompleksitas waktu kasus rata-rata terbaik yang dapat kita harapkan dalam jenis perbandingan apa pun adalah log.

01:41.930 --> 01:47.490
Dan jika Anda ingin mempelajari lebih lanjut tentang alasannya, Anda dapat membaca artikel wikipedia ini menjadi

01:47.490 --> 01:52.100
sedikit bukti di sini yang menjelaskan bagaimana caranya bagaimana kami sampai di sana.

01:52.170 --> 01:55.920
Semua itu berkaitan dengan informasi terbatas yang dapat kita peroleh dari satu perbandingan.

01:55.920 --> 01:58.970
Bagaimanapun juga ada matematika yang terikat padanya.

01:59.340 --> 02:06.090
Itu tidak benar-benar fokus di sini karena kami memiliki solusi, kami memiliki cara untuk mengatasi ini tetapi hanya dalam

02:06.090 --> 02:06.900
kasus-kasus tertentu.

02:06.930 --> 02:12.300
Jadi ada jenis-jenis lain yang menyortir ritme yang bukan merupakan perbandingan algoritma dan

02:12.450 --> 02:15.380
algoritma ini memanfaatkan sifat khusus dari data.

02:15.390 --> 02:21.030
Misalnya ada sekelompok jenis yang disebut algoritma pengurutan integer dan mereka hanya bekerja dengan bilangan

02:21.030 --> 02:24.860
bulat dengan angka dan kami tidak benar-benar membuat perbandingan langsung.

02:24.960 --> 02:27.720
Jadi salah satunya adalah radix sort.

02:27.750 --> 02:32.820
Jadi ketika saya mengatakan bahwa kita tidak membuat perbandingan langsung, maksud saya kita tidak pernah benar-benar membandingkan apakah jumlah ini kurang dari

02:32.820 --> 02:35.400
jumlah ini adalah jumlah ini lebih besar dari jumlah ini.

02:35.520 --> 02:38.180
Jadi kami akhirnya menyortir data dengan cara yang berbeda.

02:38.250 --> 02:44.280
Jadi jenis radix agak menyenangkan dan sangat berbeda dari apa yang telah kami lakukan sejauh ini karena kami

02:44.280 --> 02:45.370
tidak membuat perbandingan.

02:45.390 --> 02:47.510
Jadi mari kita bicara tentang cara kerjanya.

02:47.520 --> 02:52.690
Jadi saya sebutkan itu adalah algoritma penyortiran khusus yang tidak membuat perbandingan dan berfungsi pada angka.

02:52.710 --> 02:58.650
Jadi biasanya ketika ini benar-benar digunakan itu digunakan dengan angka-angka biner dan angka tersebut dapat dinyatakan

02:58.650 --> 02:59.680
dalam biner.

02:59.730 --> 03:04.800
Anda juga dapat mengambil string atau gambar apa pun jika Anda ingin dan mengubahnya menjadi biner.

03:04.830 --> 03:09.630
Jadi dimungkinkan untuk menyortir data lain tetapi data aktual yang bekerja dengan kami pada saat

03:09.630 --> 03:11.460
kami mengurutkannya harus berupa angka.

03:11.760 --> 03:16.250
Dan kita akan bekerja dengan basis 10 angka seperti 950 atau 17.

03:16.920 --> 03:22.340
Jadi jangan pernah membuat perbandingan antara dua elemen yang nevers bertanya apa yang lebih kecil apa yang lebih besar.

03:22.620 --> 03:28.170
Alih-alih itu mengeksploitasi fakta bahwa informasi tentang ukuran angka dikodekan dalam jumlah

03:28.170 --> 03:28.950
digit.

03:28.950 --> 03:35.670
Yang saya maksud dengan itu adalah bahwa jika angka memiliki lebih banyak digit tetapi katakan angka empat digit lebih besar daripada angka

03:35.760 --> 03:38.910
dua digit, tidak masalah apa pun kedua angka tersebut.

03:38.910 --> 03:44.070
Kami tidak membandingkan dua angka tetapi kami tahu bahwa sesuatu dengan lebih banyak angka lebih besar daripada sesuatu

03:44.070 --> 03:45.480
dengan lebih sedikit angka.

03:45.480 --> 03:47.300
Jadi, inilah sebenarnya cara kerjanya.

03:47.340 --> 03:51.260
Kami benar-benar mengambil daftar angka, katakanlah ini yang kami coba urutkan.

03:51.570 --> 03:53.280
Kami memiliki beberapa angka yaitu 1 digit.

03:53.280 --> 04:00.060
Ini semua berdasarkan 10 hingga tiga digit empat digit dan kami membuat 10 bucket berbeda dan bucket ini

04:00.060 --> 04:04.940
mewakili semua angka yang mungkin, yaitu angka satu digit di basis sepuluh.

04:05.040 --> 04:06.160
Jadi 0 hingga 9.

04:06.360 --> 04:11.800
Jadi untuk setiap tempat di angka itu bisa 0 1 atau 2 sampai 9.

04:12.120 --> 04:18.360
Dan yang kami lakukan adalah memeriksa seluruh daftar nomor kami dan kami mulai dengan melihat angka ini.

04:18.570 --> 04:22.790
Jadi digit pertama dalam angka dari sisi kanan.

04:22.830 --> 04:31.830
Jadi 6 4 6 3 8 OK dan kami kelompokkan ke dalam ember berdasarkan dari nomor itu.

04:32.340 --> 04:39.060
Jadi, Anda akan melihat semua angka yang memiliki dua di posisi paling kanan masuk dalam dua ember semua angka

04:39.060 --> 04:41.320
dengan enam di posisi paling kanan.

04:41.430 --> 04:46.980
Apakah mereka dua digit 100 digit, hanya saja kita melihat angka paling kanan.

04:46.980 --> 04:48.540
Kami mengelompokkan mereka di sini.

04:48.570 --> 04:51.150
Jadi kami tidak menyortirnya di dalam ember ini.

04:51.180 --> 04:54.130
Anda dapat melihat bahwa ini tidak berurutan.

04:54.300 --> 05:01.090
Kami mengambil semua tujuh semua delapan semua sembilan dan kemudian kami membentuk mereka kembali ke daftar menjaga

05:01.090 --> 05:02.830
urutan mereka di sini.

05:02.830 --> 05:04.340
Jadi ini akan menjadi awal.

05:04.360 --> 05:07.810
Dan kemudian nomor ini dan kemudian nomor ini dapat Anda lihat di sini.

05:08.290 --> 05:14.080
Jadi angka yang harus menjadi digit terakhir Anda datang sebelum angka yang memiliki tiga atau digit terakhir.

05:14.080 --> 05:17.830
Dan pada akhirnya kami memiliki angka dengan sembilan sebagai digit terakhir mereka.

05:17.830 --> 05:22.470
Sekarang kita ulangi prosesnya kecuali kita melihat angka berikutnya di sebelah kiri.

05:22.600 --> 05:23.810
Jadi kita akan melihat angka ini.

05:23.830 --> 05:25.430
Dan ini dan ini.

05:25.660 --> 05:26.190
BAIK.

05:26.380 --> 05:30.850
Jadi sekarang kita mengelompokkan mereka berdasarkan digit kedua dari kanan.

05:31.120 --> 05:39.610
Jadi jika kita melihat kolom ini, ember ini sedang berbicara tentang nol yang memiliki 0 4 0 8 0 di posisi

05:39.610 --> 05:40.430
itu.

05:40.550 --> 05:41.430
Saya tahu 2.

05:41.530 --> 05:47.230
Tapi kemudian angka-angka ini yang merupakan angka satu digit tidak memiliki angka apa pun di posisi itu, jadi kami letakkan

05:47.230 --> 05:48.680
saja di ember tahun ini.

05:48.970 --> 05:49.770
Ada nol di sana.

05:49.780 --> 05:55.500
Benar kita dapat menulis angka apa saja karena 0 7 sama dengan 7 0 4 sama dengan 4.

05:55.990 --> 06:02.260
Jadi kita berakhir dengan jika kita pergi ke sini kita punya semua angka yang memiliki 5 di posisi itu.

06:02.260 --> 06:07.660
Semua angka yang memiliki 8 di posisi itu dan kami semakin dekat setiap melewati sini.

06:07.660 --> 06:10.180
Kami tidak pernah membandingkan angka satu sama lain.

06:10.810 --> 06:15.870
Dan sekarang kami mereformasi mereka ke dalam daftar ini dan Anda dapat melihatnya semakin dekat untuk diurutkan.

06:15.880 --> 06:16.900
Tapi kita masih di luar sana.

06:16.960 --> 06:21.710
Jadi kita ulangi lagi di mana kita berbicara tentang digit ketiga.

06:22.090 --> 06:24.800
Jadi yang pertama adalah yang kedua digit ketiga.

06:25.150 --> 06:25.920
Melakukannya lagi.

06:26.260 --> 06:26.800
BAIK.

06:27.010 --> 06:33.460
Jadi Anda dapat melihat angka-angka yang lebih kecil sudah dikelompokkan di sini dan kami punya misalnya di sini lima angka ini

06:33.460 --> 06:36.670
memiliki lima dan itu adalah tempat ketiga dan seterusnya.

06:36.670 --> 06:40.540
Dan kemudian kita mengubah daftar lagi dan kemudian kita harus pergi sekali lagi.

06:40.690 --> 06:46.010
Jadi berapa kali kita harus benar-benar melakukan proses ini tergantung pada jumlah terbesar.

06:46.090 --> 06:47.680
Berapa banyak digit yang dimilikinya.

06:47.680 --> 06:50.110
Jadi kami memiliki beberapa angka empat digit.

06:50.110 --> 06:52.690
Jadi kita harus membaginya empat kali.

06:52.690 --> 06:56.040
Jika kita memiliki angka 10 digit di sini kita harus melakukannya 10 kali.

06:56.350 --> 06:56.780
BAIK.

06:57.010 --> 06:58.190
Jadi inilah waktu terakhir kita.

06:58.420 --> 06:59.980
Jadi sekarang mereka sudah berpisah.

06:59.980 --> 07:01.770
Kita berbicara tentang digit keempat.

07:01.790 --> 07:03.730
Tak satu pun dari ini memiliki digit keempat.

07:03.730 --> 07:05.870
Yang ini melakukan beberapa dan sebagainya.

07:06.010 --> 07:09.430
Dan kemudian Re-Forum lagi ke dalam daftar kami dan kami selesai.

07:09.430 --> 07:14.110
Jadi ketika saya mengatakan kita membentuk mereka ke dalam daftar, maksud saya kita hanya mengambil pesanan yang sudah ada di

07:14.110 --> 07:17.450
kantong ini, jadi kita mulai di sini kemudian di sini sampai sembilan atau dua.

07:17.620 --> 07:18.930
Dan kemudian kita ambil ember ini.

07:18.970 --> 07:19.850
Yang ini kosong.

07:19.870 --> 07:21.440
Jadi ini dan kita terus berjalan.

07:21.730 --> 07:23.330
Dan sekarang angkanya diurutkan.

07:23.410 --> 07:27.020
Jadi kami tidak pernah membuat perbandingan antara angka-angka dalam daftar kami.

07:27.110 --> 07:30.750
Sebaliknya, kami mengambil keuntungan dari properti khusus angka.

07:30.760 --> 07:34.600
Jadi Leslie di sini adalah animasi yang bagus dari jenis radix.

07:35.020 --> 07:36.180
All Hit Play.

07:36.220 --> 07:41.950
Apa yang kami lakukan adalah Anda melihat pada digit paling kanan itu dan mengelompokkannya kembali dalam 10 ember itu.

07:41.980 --> 07:47.410
Jadi, jika kita berbicara tentang angka tujuh dasar kita akan memiliki tujuh ember.

07:47.450 --> 07:49.640
Kita berbicara tentang basis 10 sehingga kita memiliki 10 ember.

07:49.930 --> 07:51.060
BAIK.

07:51.100 --> 07:55.690
Dan sekarang kita mereformasi mereka, Anda dapat melihat urutan yang sedang kita bicarakan, kita hanya menarik mereka keluar dari ember

07:55.840 --> 07:57.940
dalam urutan yang sama dengan yang sudah mereka simpan.

07:58.180 --> 08:02.950
Dan sekarang kita lihat digit kedua dari kanan dan kita bentuk mereka menjadi ember.

08:03.460 --> 08:04.040
BAIK.

08:04.360 --> 08:07.710
Dan lagi dalam hal ini angka terbesar kami adalah angka empat digit.

08:07.810 --> 08:10.270
Jadi kita harus melakukan proses ini empat kali.

08:10.280 --> 08:12.000
Itu dua kali turun.

08:12.010 --> 08:13.380
Sekarang kita punya dua lagi.

08:13.510 --> 08:19.270
Jadi sekarang kita melihat angka ketiga dari kanan dan angka yang tidak memiliki angka di posisi

08:19.270 --> 08:20.020
itu.

08:20.020 --> 08:25.150
Kami memasukkannya ke dalam keranjang nol dan kami hampir sampai.

08:25.150 --> 08:30.580
Kita hanya perlu melihat digit keempat dari kanan dan mengelompokkan berbagai hal ke dalam ember yang

08:30.700 --> 08:32.410
benar berdasarkan dari digit tersebut.

08:32.410 --> 08:33.930
Jadi kita hampir sampai.

08:33.940 --> 08:37.050
Jadi ada beberapa hal yang perlu diingat untuk membuat ini bekerja.

08:37.180 --> 08:41.800
Kita harus bisa mengetahui angka dalam angka pada posisi tertentu.

08:41.950 --> 08:46.320
Jadi di video berikutnya saya akan berbicara tentang beberapa fungsi pembantu yang perlu kita tulis.

08:46.390 --> 08:51.480
Misalnya saya harus bisa bertanya, apa digit kedua dari nomor ini, apa digit keempat atau

08:51.660 --> 08:52.720
digit pertama.

08:52.960 --> 08:56.240
Dan sebagian besar bahasa tidak memberi Anda cara mudah untuk melakukan itu.

08:56.260 --> 08:58.050
Kita harus menulis metode kita sendiri untuk melakukannya.

08:58.090 --> 09:01.990
Jadi itulah yang akan kita mulai dengan sebelum kita sampai ke ember.

09:02.050 --> 09:03.380
Itu semacam radix.

09:03.460 --> 09:07.290
Ini adalah kasus khusus dari algoritma pengurutan yang bukan jenis perbandingan.

09:07.330 --> 09:12.970
Ini adalah bilangan bulat yang berfungsi karena khusus saya tidak akan mengatakan celah tetapi properti khusus.

09:13.120 --> 09:19.960
Dan itu memungkinkan kita untuk mengurutkan angka dengan sangat cepat dibandingkan harus melakukan perbandingan.

09:20.350 --> 09:22.450
Diterapkan dengan baik di beberapa video berikutnya.
