WEBVTT

00:00.180 --> 00:01.350
Jadi semacam penyisipan.

00:01.350 --> 00:07.230
Sejauh kompleksitas waktunya itu cukup mirip secara keseluruhan dengan dua lainnya kita telah melihat

00:07.300 --> 00:11.630
kasus terburuknya dan kuadrat adalah kuadrat karena seandainya array tumbuh.

00:11.640 --> 00:15.530
Kita juga pada dasarnya harus membuat perbandingan jumlah n kuadrat.

00:16.020 --> 00:18.880
Tetapi jika data kita hampir semuanya diurutkan.

00:19.080 --> 00:27.540
Jadi jika kita melihat sesuatu seperti saya tidak tahu apa yang akan bekerja di sini, katakanlah 1 2 3 4

00:27.990 --> 00:29.640
negatif 1 misalnya.

00:29.850 --> 00:33.690
Nah jika kita mulai kita melihat dua kita segera menemukan bahwa itu lebih besar.

00:33.690 --> 00:35.640
Kami tidak harus melakukan apa pun untuk menghentikan perulangan.

00:35.730 --> 00:36.660
Lalu kami pindah ke tiga.

00:36.690 --> 00:38.080
Kami menemukan bahwa lebih besar dari 2.

00:38.220 --> 00:39.500
Kita tidak perlu terus berjalan.

00:39.780 --> 00:43.160
Kita melihat empat Di mana kita bisa melihat yang negatif.

00:43.170 --> 00:43.530
Baiklah.

00:43.530 --> 00:46.050
Sekarang kita harus melalui dan meletakkannya di awal.

00:46.320 --> 00:52.760
Tetapi bandingkan dengan data acak yang tidak disortir dimana kita harus terus memainkan sesuatu dan mengulanginya.

00:52.950 --> 00:58.890
Kemudian kita melihat waktu yang jauh lebih buruk atau sebenarnya skenario terburuk yang mungkin

00:58.890 --> 01:00.710
terjadi di awal Anda.

01:00.780 --> 01:01.690
Kita sampai tiga.

01:01.710 --> 01:03.970
Kita harus menukarnya ke sini dan kita dapatkan dua.

01:04.030 --> 01:08.260
Kita harus menukar ke awal dan kita sampai ke 1 dan kita harus menukar ke awal lagi.

01:08.310 --> 01:10.440
Itu kasus terburuk untuk jenis penyisipan.

01:10.560 --> 01:13.300
Tetapi jika data Anda hampir diurutkan Anda dapatkan.

01:13.350 --> 01:16.610
Sekarang hal lain yang menarik adalah jenis penyisipan yang baik.

01:16.980 --> 01:22.560
Jika Anda data ada sesuatu yang disebut algoritma online yang merupakan algoritma yang dapat berfungsi sebagai data

01:22.560 --> 01:24.720
yang masuk saat menerima data baru.

01:24.720 --> 01:27.390
Tidak harus memiliki seluruh array sekaligus.

01:27.390 --> 01:34.540
Jadi misalnya, katakanlah kita memiliki beberapa kode tempat orang mengirimkan nomor kepada kita secara online.

01:34.590 --> 01:36.570
Kami mendapatkannya dan kami ingin menyortirnya.

01:36.570 --> 01:37.390
Jangan tanya kenapa.

01:37.440 --> 01:38.560
Katakanlah kita ingin.

01:38.720 --> 01:44.040
Dengan penyisipan semacam karena cara kerjanya kita menjaga satu sisi array diurutkan dan kita

01:44.040 --> 01:48.700
memasukkan item satu per satu, tidak masalah berapa nomor yang masuk.

01:48.870 --> 01:50.680
Kita bisa menempatkannya di tempat yang harus dituju.

01:50.700 --> 01:56.400
Jadi ini satu kekuatan jika Anda memang perlu jika Anda mencari algoritma pengurutan yang bekerja dengan cara

01:56.400 --> 02:01.470
yang mungkin tidak akan muncul tetapi perlu diketahui bahwa karena cara kerja penyisipan bekerja karena

02:01.470 --> 02:07.050
kami menjaga satu sisi itu diurutkan dan kami memasukkan hal-hal di tempat yang tepat karena itu berfungsi

02:07.040 --> 02:11.370
dengan baik dalam situasi di mana data datang secara langsung atau streaming.

02:11.370 --> 02:14.000
Dan Anda harus memasukkannya sesaat lagi.

02:14.220 --> 02:14.610
BAIK.

02:14.640 --> 02:18.200
Jadi itu adalah tiga ritme pemilah dasar dalam video berikutnya.

02:18.210 --> 02:21.890
Kami hanya akan berbicara tentang kompleksitas waktu dan kompleksitas ruang mereka.

02:21.890 --> 02:24.410
Dan kemudian juga melakukan rekap cepat dari apa yang kita pelajari.
