WEBVTT

00:00.270 --> 00:00.660
Baiklah.

00:00.660 --> 00:05.140
Jadi mari kita coba terapkan pre order pencarian mendalam ini terlebih dahulu.

00:05.370 --> 00:08.380
Jadi kita akan pergi ke sini untuk mendefinisikan fungsi.

00:08.670 --> 00:12.830
Saya hanya akan menyebutnya pre order DFS seperti ini.

00:13.410 --> 00:18.750
Dan kemudian di dalam sini saya akan mulai dengan membuat data variabel kami yang akan kembali di

00:18.750 --> 00:19.270
akhir.

00:19.410 --> 00:22.050
Jadi saya benar-benar bisa turun sampai akhir dan mengembalikan data.

00:22.050 --> 00:27.270
Ini hanya urutan bahwa kita mengunjungi node maka kita akan membuat variabel yang disebut Current dan

00:27.270 --> 00:28.090
mengaturnya menjadi

00:31.520 --> 00:32.670
root begitu saja.

00:32.690 --> 00:37.970
Sekarang untuk bagian yang sulit menulis fungsi pembantu kita akan menyebutnya traverse yang menerima node.

00:38.300 --> 00:45.440
Jadi saya hanya akan melakukan yang sebenarnya bersarang di dalam fungsi Anda traverse menerima sebuah node dan hal

00:45.440 --> 00:50.580
pertama yang kami lakukan adalah mendorong nilai node ke data variabel kami.

00:50.700 --> 00:55.590
Jadi kita akan melakukan data push node.

00:55.760 --> 01:01.790
Kemudian kami memeriksa apakah ada properti kiri jika ada kami memanggil fungsi pembantu dengan properti Kiri dan kami melakukan

01:01.790 --> 01:03.380
hal yang sama untuk kanan.

01:03.770 --> 01:08.200
Jadi kita bisa lakukan jika simpul kiri.

01:08.810 --> 01:09.980
Apa yang akan kita lakukan.

01:10.010 --> 01:14.310
Kami akan memanggil melintasi tidak diragukan lagi.

01:14.320 --> 01:18.590
Jadi ini traverse, kami secara rekursif menyebutnya dan kami melakukan hal yang sama.

01:18.640 --> 01:23.300
Tidak diragukan lagi simpul traverse kanan dot kanan.

01:24.980 --> 01:27.940
Dan itu sebenarnya untuk solusi kami.

01:28.340 --> 01:29.380
Yah itu bohong.

01:29.510 --> 01:33.700
Kita harus benar-benar memanggil traverse yang saya bicarakan di sini.

01:33.740 --> 01:36.040
Aktifkan fungsi pembantu dengan variabel saat ini.

01:36.080 --> 01:40.970
Jadi itu traverse current yang merupakan root.

01:41.130 --> 01:45.520
Dan sebenarnya dia jujur bahkan tidak membutuhkan variabel saat ini.

01:45.620 --> 01:48.700
Anda bisa saja melintasi rute ini.

01:49.160 --> 01:49.730
Tapi apa.

01:49.730 --> 01:55.700
Mengirim variabel saat ini memungkinkan Anda untuk melakukan sesuatu, pengguna dapat menentukan titik awal untuk memulai.

01:55.700 --> 01:59.680
Mereka mungkin tidak ingin melintasi dari akar jika Anda memiliki pohon besar.

01:59.900 --> 02:02.550
Saya hanya akan melakukan ini melalui rute ini.

02:03.080 --> 02:03.770
BAIK.

02:03.980 --> 02:11.420
Jadi jika kita benar-benar menjalankan ini sekarang dengan pohon ini 10: 6 15 3:08 20.

02:11.420 --> 02:12.920
Biarkan saya simpan ini.

02:13.100 --> 02:13.950
Dieksekusi

02:14.120 --> 02:16.040
Mari kita lihat apakah itu berhasil.

02:16.180 --> 02:21.710
Oh, Anda tahu apa yang saya sadari lebih mudah lagi untuk mendorong nilai daripada seluruh node.

02:21.710 --> 02:24.060
Jadi mari kita coba jalankan kembali pohon sekali lagi.

02:24.260 --> 02:26.200
DFS pre order.

02:26.510 --> 02:32.360
Inilah yang kita dapatkan dengan 10 6 3 8 15 20.

02:32.360 --> 02:36.060
Dan itu adalah kedalaman pre order pencarian pertama yang benar.

02:36.080 --> 02:40.400
Jadi sekarang mari kita ke bagian yang lebih sulit yang menjelaskan bagaimana sih yang bekerja.

02:40.430 --> 02:47.600
Jadi saya akan datang ke sini dan melakukan preorder dot pohon DFS dan menambahkan breakpoint di sana.

02:47.600 --> 02:51.430
Sekarang mari kita selidiki apa yang terjadi untuk mengeksekusi kode ini.

02:52.110 --> 02:52.590
BAIK.

02:52.750 --> 02:57.350
Jadi saya akan memesan tumpukan panggilan dan melangkah melalui hal pertama ini dan

02:57.350 --> 03:01.350
membuat array kami disebut data yang kami sebut traverse di root.

03:01.790 --> 03:10.310
OK sekarang jika kita melihat tumpukan panggilan sekarang kita memiliki panggilan traverse dan kita mendorong 10 ke dalam array kita bahwa kita

03:10.310 --> 03:11.900
kembali memanggil data.

03:11.900 --> 03:13.360
Jadi 10 ada di sana.

03:13.460 --> 03:16.300
Lalu kita periksa apakah ada kiri dan ada.

03:16.400 --> 03:22.680
Jadi kita memanggil traverse di sebelah kiri dan simpul kiri adalah 6.

03:22.880 --> 03:28.490
Jadi kita berakhir dengan panggilan lain yang ditambahkan ke stack kali ini di 6.

03:28.640 --> 03:31.650
Jadi kita sekarang mendorong 6 ke dalam array kita.

03:31.790 --> 03:37.960
Jadi array data kami memiliki 10 dan kemudian 6 dan kami memeriksa apakah ada yang tersisa di 6.

03:37.970 --> 03:40.040
Ya ada.

03:40.040 --> 03:44.740
Jadi kita lewati tidak ada titik yang tersisa yaitu tiga.

03:44.810 --> 03:48.390
Dan akhirnya kami dengan panggilan lain ditambahkan di atas.

03:48.390 --> 03:52.050
Sekarang kami bekerja dengan tiga hari untuk mendorong nilai node.

03:52.050 --> 03:54.990
Jadi kami menambahkan tiga ke daftar kami sehingga kami memiliki 10 6.

03:54.990 --> 03:58.110
Sekarang tiga ada di data itu dan kami periksa.

03:58.110 --> 03:59.410
Apakah tidak ada keraguan lagi.

03:59.430 --> 04:01.560
Tidak, tidak ada.

04:02.220 --> 04:04.410
Jadi kita tidak melewati sisa hutang.

04:04.410 --> 04:05.570
Apakah tidak ada titik yang benar.

04:05.610 --> 04:06.810
Tidak ada.

04:06.810 --> 04:11.530
Jadi kami tidak melewati itu yang berarti kami sudah selesai dengan panggilan ini dengan tiga.

04:11.760 --> 04:13.970
Jadi Anda akan melihatnya benar-benar muncul di sini.

04:14.010 --> 04:14.890
Itu dia.

04:15.160 --> 04:20.020
Dan sekarang kita kembali ke tempat kami berada di enam karena kami berhenti di garis ini.

04:20.040 --> 04:20.460
Kanan.

04:20.490 --> 04:22.680
Kami menunggu lintasan ini selesai.

04:22.680 --> 04:23.730
Sekarang kita ke kanan.

04:23.760 --> 04:24.850
Apakah ada sisi kanan?

04:24.930 --> 04:26.320
Ya ada.

04:26.370 --> 04:28.020
Jadi itu delapan.

04:28.020 --> 04:29.710
Jadi sekarang kita melintasi delapan.

04:29.910 --> 04:35.940
Jadi kami menambahkan satu lagi panggilan di sana untuk melintasi hari untuk mendorong nilai simpul yang 8.

04:35.950 --> 04:39.050
Jadi sekarang kita punya 10 6 3 8.

04:39.240 --> 04:40.630
Lalu kita periksa apakah masih ada.

04:40.640 --> 04:41.980
Tidak ada yang benar.

04:41.980 --> 04:42.620
Tidak ada.

04:42.630 --> 04:47.510
Jadi kita sudah selesai beberapa kali dan itu akan muncul.

04:47.580 --> 04:48.700
Itu dia.

04:48.750 --> 04:53.990
Sekarang kita kembali ke enam di akhir karena ini selesai kita melintasi sisi kanan 6.

04:54.020 --> 04:55.500
Kami melakukan yang kiri dari yang kanan.

04:55.530 --> 04:56.990
Tidak ada apa-apa di sana.

04:57.300 --> 04:59.300
Jadi kita selesai dengan enam.

04:59.310 --> 05:00.630
Sekarang kita kembali ke 10.

05:00.840 --> 05:03.210
Jadi kami melakukan seluruh sisi kiri 10.

05:03.240 --> 05:04.730
Sekarang kita akan melakukan sisi yang benar.

05:04.740 --> 05:09.720
Jadi cara kerjanya adalah kita mengunjungi sebuah node dan kemudian kita melintasi seluruh sisi kiri dan kemudian

05:09.720 --> 05:11.190
melintasi seluruh sisi kanan.

05:11.510 --> 05:15.350
Itu semacam ikhtisar tingkat tinggi tetapi cara kerjanya secara rekursif.

05:15.360 --> 05:17.100
Agak sulit untuk melangkah.

05:17.100 --> 05:19.000
Jadi sekarang kita di 10.

05:19.020 --> 05:20.640
Kami selesai mendorong masuk untuk 10.

05:20.640 --> 05:21.690
Itu sangat mudah.

05:21.690 --> 05:23.030
Kami telah melintasi seluruh bagian kiri.

05:23.040 --> 05:24.590
Sekarang kita harus melintasi sebelah kanan.

05:24.600 --> 05:25.570
Apakah ada hak?

05:25.590 --> 05:26.860
Ya 15

05:26.910 --> 05:28.740
Jadi kami melintasi 15.

05:28.860 --> 05:32.450
Jadi kami mendapatkan panggilan yang ditambahkan ke tumpukan panggilan kami untuk 15.

05:32.460 --> 05:34.490
Kami memasukkan 15 ke dalam daftar kami.

05:34.620 --> 05:38.310
Sekarang daftar adalah 10 6 3 8 15 dan periksa kembali.

05:38.300 --> 05:41.900
Apakah ada yang kiri tidak ada yang tersisa untuk 15.

05:42.210 --> 05:43.740
Jadi kita pergi ke baris berikutnya.

05:43.800 --> 05:45.520
Apakah ada yang benar dan ada.

05:45.600 --> 05:47.070
Yaitu 20.

05:47.070 --> 05:52.350
Jadi kami melintasi 20 dan melintasi 20 benar-benar hanya melibatkan Anda dapat melihat panggilan ditambahkan ke

05:52.980 --> 05:54.860
sini hari untuk mendorong 20.

05:54.990 --> 05:58.000
Jadi kami memiliki 20 in dan kami sekarang telah mengunjungi setiap node.

05:58.140 --> 06:01.890
Kami tidak benar-benar tahu bahwa Intel tidak diragukan lagi sehingga ini akan salah.

06:01.900 --> 06:03.680
Tidak ada kiri, tidak ada kanan.

06:03.810 --> 06:11.100
Jadi 20 akan muncul dari tumpukan panggilan dan kemudian panggilan untuk 15 akan muncul dan kemudian panggilan untuk

06:11.100 --> 06:11.690
10.

06:11.700 --> 06:17.310
Yang asli muncul dan kami menyelesaikan semua lintasan Jadi ini adalah garis yang menyebabkan semua

06:17.310 --> 06:18.370
masalah itu.

06:18.540 --> 06:21.000
Dan inilah data yang sekarang terlihat.

06:21.000 --> 06:25.090
Sekarang kami baru saja mengembalikan data dan selesai.

06:25.410 --> 06:27.660
Nah kita mulai sekarang.

06:27.870 --> 06:29.470
Dan itulah urutan hal-hal meninjau kembali.

06:29.820 --> 06:37.230
Jadi untuk rekap yang kita lakukan adalah secara rekursif kita mengunjungi sebuah node kemudian kita mengunjungi seluruh sisi kiri dan kemudian

06:37.230 --> 06:38.310
seluruh sisi kanan.

06:38.310 --> 06:40.420
Jadi pesanan ini sangat penting.

06:40.560 --> 06:44.850
Dan Anda akan melihat dalam dua video berikutnya atau dua solusi berikutnya untuk pesanan yang berbeda.

06:44.850 --> 06:48.140
Yang harus kita lakukan adalah mengubah urutan bahwa ini terjadi.

06:48.500 --> 06:48.990
BAIK.

06:49.080 --> 06:50.280
Jadi itu akan terjadi selanjutnya.
