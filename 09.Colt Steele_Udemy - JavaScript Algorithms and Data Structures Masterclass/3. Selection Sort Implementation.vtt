WEBVTT

00:00.190 --> 00:03.090
OK jadi mari kita coba menulis semacam pilihan kita sendiri.

00:03.480 --> 00:08.670
Jadi saya punya snippet bernama sorting selection dan saya akan mulai dengan mendefinisikan sebuah fungsi.

00:08.670 --> 00:11.010
Saya akan menyebutnya sebagai sorting selection.

00:11.550 --> 00:13.090
Dan dibutuhkan sebuah array.

00:13.800 --> 00:17.230
Dan pada akhirnya kita akan mengembalikan array itu.

00:17.280 --> 00:20.580
Jadi katakanlah kita akan menyebutnya pada array.

00:20.600 --> 00:28.020
Berarti melakukan angka genap kali ini 10 dan saya akan menambahkan satu nomor ganjil di akhir sana dan 17.

00:28.220 --> 00:28.880
BAIK.

00:29.460 --> 00:31.820
Jadi ini yang akan kita coba.

00:32.580 --> 00:37.740
Jadi apa yang ingin kita lakukan untuk memulai adalah kita bisa mulai dengan mengulang setiap item.

00:37.830 --> 00:39.720
Itu tempat yang cukup standar untuk memulai.

00:39.720 --> 00:42.660
Jadi sejauh ini saya sama dengan nol.

00:42.660 --> 00:48.100
Saya kurang dari tautan radar plus plus.

00:48.550 --> 00:49.180
BAIK.

00:49.410 --> 00:54.990
Dan jika kita melihat kode semu kita menyimpan elemen pertama sebagai nilai terkecil yang kita lihat sejauh ini.

00:54.990 --> 01:02.860
Jadi mari kita buat variabel dan kita hanya akan menyebutnya terendah atau laki-laki dan kita akan mengaturnya sama dengan saya.

01:02.970 --> 01:06.800
Jadi itulah posisi elemen terkecil setidaknya di awal.

01:06.800 --> 01:07.540
Kami tidak tahu yang lebih baik.

01:07.540 --> 01:09.980
Jadi ini adalah hal terkecil yang pernah kita lihat.

01:10.080 --> 01:15.390
Dan apa yang ingin kita lakukan adalah membandingkannya dengan item berikutnya setelah itu dan kemudian item berikutnya

01:15.390 --> 01:22.870
setelah itu dan setelah itu dan setelah itu dan jika pada suatu saat kita menemukan nilai yang lebih kecil maka kita akan mengubah terendah.

01:22.890 --> 01:26.200
Jadi mari kita lakukan loop lain untuk membuatnya bekerja.

01:26.310 --> 01:28.150
Mari kita pergi dengan J.

01:28.620 --> 01:33.980
Dan kita akan menetapkan J daripada 0 karena ingat kita tidak ingin mendasarkan.

01:34.020 --> 01:35.710
Kita tidak perlu mengulang setiap bagian.

01:35.790 --> 01:41.910
Jadi jika saya menempatkan ini dengan cara yang lebih baik jika kita mulai di sini dengan loop luar pertama kami, saya merujuk

01:41.910 --> 01:42.470
di sini.

01:42.660 --> 01:44.210
Kami tidak ingin membandingkannya dengan saya.

01:44.250 --> 01:47.710
Sekali lagi yang ingin kami bandingkan adalah saya tambah 1.

01:47.730 --> 01:52.360
Kami ingin membandingkannya dengan ini atau jika kami pada titik ini dalam array.

01:52.410 --> 01:56.850
Jadi jika saya sekarang dua keduanya sudah diurutkan.

01:56.850 --> 02:01.580
Kami tidak ingin mulai membandingkan i dari 2 hingga J dari 0.

02:01.590 --> 02:06.890
Kami ingin membandingkan dengan 19 yang berarti bahwa kami harus naik satu lebih tinggi dari apa pun.

02:07.110 --> 02:12.910
Jadi kita bisa melakukan J sama dengan saya ditambah 1 seperti itu dan kemudian kita akan lakukan.

02:12.910 --> 02:18.660
Sementara J kurang dari panjang yang besar, J plus plus sempurna dan jika kita

02:22.610 --> 02:29.060
hanya menambahkan log konstan sederhana hanya untuk menunjukkan apa yang kita lihat, mari kita lakukan i dan

02:29.060 --> 02:29.640
j.

02:29.750 --> 02:33.930
Jadi, Anda dapat melihat perbandingan yang terjadi dan kami menjalankan ini.

02:33.980 --> 02:41.110
Jadi tidak ada penyortiran yang terjadi tetapi kami mulai dengan membandingkan 0 hingga 1 0 2 2 0 2 3 0 hingga 4.

02:41.390 --> 02:49.370
Kemudian waktu berikutnya kita akan membandingkan satu hingga dua, satu, tiga, dalam satu, empat, dan kemudian dua hingga tiga.

02:49.370 --> 02:50.370
Dua hingga empat.

02:50.600 --> 02:52.680
Dan akhirnya tiga sampai empat.

02:52.700 --> 02:53.850
Jadi ini berhasil.

02:53.870 --> 02:57.190
Maksud saya kita tidak melakukan penyortiran, tetapi ini adalah perbandingan yang kita inginkan.

02:57.320 --> 02:59.530
Kami tidak ingin kami tidak mau.

02:59.540 --> 03:06.110
Sebagai contoh setelah pass pertama kami membandingkan 0 hingga 1 hingga 2 hingga 3 hingga 4 dan kemudian mulai lagi dan bandingkan nol

03:06.110 --> 03:06.560
lagi.

03:06.650 --> 03:11.180
Kami tidak ingin melihat elemen ini karena apa pun yang ada di sini pada akhirnya akan diurutkan.

03:11.180 --> 03:13.240
Itu akan menjadi nilai terkecil yang dipilih sendiri.

03:13.250 --> 03:14.260
Jadi itu berhasil.

03:14.270 --> 03:19.410
Jadi sekarang kita hanya perlu kondisi sederhana di sini untuk memeriksa dengan nilai array berada

03:20.360 --> 03:24.260
pada titik terendah dan kemudian membandingkannya dengan nilai array di J.

03:24.530 --> 03:33.830
Jadi kita akan memiliki array yang terendah dan kemudian array Jay seperti itu dan kami ingin tahu apakah kita bisa kita bisa melakukan ini dengan cara

03:34.040 --> 03:40.430
apa pun kita dapat mengatakan apakah array J kurang dari setengah terendah atau jika terendah saat ini

03:40.430 --> 03:42.740
adalah lebih besar dari array J.

03:42.980 --> 03:45.260
Saya sebenarnya lebih suka.

03:46.280 --> 03:51.530
Secara logis saya pikir ini masuk akal karena kami sedang mencari.

03:51.730 --> 03:52.030
BAIK.

03:52.080 --> 03:53.550
Dan kami sedang mencari barang terendah.

03:53.570 --> 03:54.690
Saya suka melakukannya dengan cara ini.

03:54.830 --> 04:00.900
Jika array J kurang dari terendah kami saat ini, ingat yang terendah itu hanya angka seperti 0.

04:01.130 --> 04:07.100
Jadi pertama kali kita melewati jika kita berjalan melalui mata ini adalah nol yang berarti terendah ke nol.

04:07.280 --> 04:09.420
Dan kemudian J akan mulai pada 1.

04:09.470 --> 04:16.560
Jadi kita membandingkan jika array J kurang dari array terendah adalah rentang satu kurang dari array 0.

04:16.760 --> 04:17.890
Ya itu.

04:17.900 --> 04:22.770
Jadi jika itu masalahnya kita akan terendah sekarang menjadi sama dengan J.

04:23.120 --> 04:25.300
Jadi sekarang kami telah memperbarui nilai terendah.

04:25.520 --> 04:29.390
Jadi jika kita berjalan melalui kita mulai dari awal dengan saya set ke 0.

04:29.480 --> 04:35.680
J adalah 1 dan terendah sekarang akan menjadi 1 karena kami baru saja memperbaruinya.

04:35.750 --> 04:37.220
Jadi ini merujuk ke item ini.

04:37.460 --> 04:41.460
Tapi lain kali kita miliki aku masih nol.

04:41.720 --> 04:43.050
Apa itu J sekarang.

04:43.310 --> 04:45.990
Nah J naik 1 jadi j adalah 2.

04:46.310 --> 04:54.180
Jadi jika kita membandingkan array dua ke array terendah yang merupakan salah satu yang membandingkan keduanya sekarang 10 lebih kecil.

04:54.260 --> 05:01.070
Jadi kita akan menetapkan terendah sama dengan J yang berarti terendah sekarang ke indeks kanan 2.

05:01.070 --> 05:07.430
Sekarang kita bisa mengulang ini dan jika kita lakukan kita akan pergi 0 masih J sekarang akan menjadi

05:07.670 --> 05:13.730
3 tetapi yang terendah masih 2 karena 19 tidak besar atau 10 tidak kurang dari 19

05:13.730 --> 05:15.950
Sekali lagi adalah nol.

05:16.250 --> 05:23.420
Jay akan mencari item terakhir dan centang adalah array J yang 17 adalah bahwa kurang dari

05:23.420 --> 05:25.760
array terendah array terendah.

05:25.880 --> 05:27.070
Akan memberi kita 10.

05:27.260 --> 05:28.400
Tidak, itu tidak benar.

05:28.400 --> 05:29.950
Jadi kami tidak memperbarui.

05:30.020 --> 05:31.290
Terendah juga.

05:31.520 --> 05:37.700
Jadi apa yang telah kami lakukan sekarang adalah kami menemukan indeks pada akhir dari loop ini di sini

05:37.700 --> 05:43.310
kita tahu bahwa indeks terendah dari item yang memiliki indeks nilai terendah sama dengan 2.

05:43.310 --> 05:47.270
Dalam hal ini yang perlu kita lakukan sekarang adalah swap.

05:47.300 --> 05:53.270
Jadi, jika Anda melihat kode pseudo apa yang kita lakukan adalah mengambil nilai yang awalnya kita mulai dengan di mana kita

05:53.270 --> 05:54.980
mulai pertama yang merupakan item pertama.

05:54.980 --> 06:00.150
Saat ini kami menukar itu dengan posisi item terendah.

06:00.620 --> 06:09.330
Jadi itu berarti kita akan menukar nol ke ini dan ini dan untuk melakukan swap kita bisa melakukannya dengan banyak cara

06:09.330 --> 06:16.980
kita bisa melakukannya dengan tempo kita sehingga kita bisa membuat tempo sama dengan mari kita lakukan array

06:17.370 --> 06:25.240
of eye dan kemudian reset array of Saya sekarang sama dengan array terendah dan kemudian kita lakukan array terendah.

06:25.680 --> 06:31.500
Jika saya bisa mengeja sama dengan 10 dan itu adalah semi-titik dua.

06:31.560 --> 06:34.310
Jadi semoga pertukaran logika itu masuk akal.

06:34.470 --> 06:37.050
Anda tentu saja dapat menggunakan sintaks yang lebih bagus juga.

06:37.110 --> 06:40.160
Juga solusi yang sama ditulis di East 2015 di akhir.

06:40.530 --> 06:44.810
OK jadi ini harus memberi kita swap dan lihat apa yang terjadi.

06:44.820 --> 06:47.180
Mari kita lihat apa yang kita cetak.

06:47.190 --> 06:48.530
Mari kita lalui.

06:48.540 --> 06:54.810
Pada akhir setiap kali melakukan merupakan array log begitu saja.

06:55.080 --> 07:03.270
Dan sebenarnya daripada hanya melakukan ini dengan cetak gratis, saya bermaksud melakukan array log konser dan kemudian itu akan

07:03.620 --> 07:05.170
menjadi semacam menjengkelkan.

07:05.440 --> 07:13.730
Keluar log swapping ke dan kemudian konstan seperti array sesudahnya.

07:13.880 --> 07:14.570
BAIK.

07:14.760 --> 07:19.770
Dan untuk membuatnya lebih mudah untuk melihat apa yang terjadi setiap kali ada banyak pekerjaan hanya untuk

07:19.770 --> 07:23.430
menunjukkan apa yang terjadi dan Anda mungkin sudah tahu apa yang terjadi.

07:23.460 --> 07:26.520
Tapi saya hanya akan meletakkan pembagi ini di sana sehingga kita bisa melihat.

07:26.930 --> 07:33.620
OK jadi sekarang jika kita menjalankan ini dan saya akan membuat pembatalan saya lebih besar.

07:34.030 --> 07:35.960
Di mana kita mulai?

07:36.090 --> 07:36.900
Kita mulai.

07:37.320 --> 07:37.620
Baiklah.

07:37.620 --> 07:38.830
Jadi apa yang terjadi?

07:38.970 --> 07:43.420
Kami mulai dengan keadaan ini dan kami melakukan swap. Ini swap pertama kami, kami pindah 10 ke awal.

07:43.620 --> 07:49.960
Jadi kita mulai dengan keadaan itu dan kita melihat ini dan kita memindahkan apa yang kita pindahkan 17 ke awal seperti yang Anda

07:50.400 --> 07:51.400
lihat di sana.

07:51.420 --> 07:54.870
Sekarang kita melihat ketiganya di akhir dan 19 adalah yang terkecil.

07:54.870 --> 07:58.860
Jadi kita bergerak 19 ke awal seperti yang Anda lihat sekarang kita punya dua.

07:59.280 --> 08:00.190
Dan apa yang kita lakukan.

08:00.360 --> 08:03.550
Kami menukar 22 ke awal.

08:03.550 --> 08:06.070
Baiklah sekarang kita memiliki satu elemen tersisa.

08:06.390 --> 08:07.470
Dan apa yang kita lakukan.

08:07.740 --> 08:10.420
Yah, kita masih bertukar 34 sebagai laki-laki.

08:10.580 --> 08:12.440
Dan Anda dapat melihat kode kami masih berjalan.

08:12.480 --> 08:15.090
Kami bertukar 34 dan 34.

08:15.330 --> 08:17.490
Dan kemudian ini adalah nilai pengembalian di akhir.

08:17.490 --> 08:22.220
Jadi kode bekerja yang baik pada akhirnya kita mendapatkan array yang diurutkan dan itu adalah pemilihan semacam

08:22.320 --> 08:27.650
tetapi ada perubahan yang bisa kita buat yang sebenarnya saya pikir akan lebih baik diilustrasikan jika misalnya jika saya melakukan

08:27.650 --> 08:28.370
ini nol.

08:28.440 --> 08:35.700
Dan kemudian dua di awal daftar ini dan saya kira kita dapat menyimpan ini sebenarnya saya akan menyingkirkan ini

08:35.700 --> 08:37.680
karena ini memakan banyak ruang.

08:37.750 --> 08:39.000
Saya akan membatalkan log itu.

08:39.000 --> 08:46.590
Barang-barang yang ditukar sconce log I dan ujung terendah kita akan melihat apa yang terjadi ketika kita

08:46.590 --> 08:51.020
menghapus nasihat saya jalankan kembali itu membuatnya lebih besar.

08:51.510 --> 08:56.990
Jadi pertama kali melalui jika kita melihat seperti apa daftar itu laki-laki adalah nol.

08:57.000 --> 08:59.310
Tapi kami terus menelusuri daftar karena kami tidak tahu itu.

08:59.310 --> 09:06.090
Dan kami mengetahui bahwa 0 adalah laki-laki yang kami masih menukar indeks nol dengan indeks 0 dan tidak menghasilkan apa-apa.

09:06.090 --> 09:06.820
Kami sedang melakukan ini.

09:06.840 --> 09:14.010
Ini tidak perlu karena kami menemukan bahwa saya sebenarnya sama dengan yang terendah dan hal yang sama terjadi

09:14.010 --> 09:14.690
lagi.

09:14.730 --> 09:21.250
Indeks item berikutnya adalah mata kami dan kami menetapkan laki-laki menjadi yang terendah juga.

09:21.270 --> 09:23.550
Kami melewati semua jalan dan tidak ada yang lebih kecil.

09:23.550 --> 09:30.110
Jadi pada akhirnya saya dan terendah adalah sama dan kami masih melakukan swap dan sebenarnya Anda dapat melihat itu terjadi pada

09:30.110 --> 09:30.760
akhirnya.

09:30.800 --> 09:36.510
Baiklah, kita masih memiliki satu hal lagi, di mana kita masih menukar 17 dengan 17.

09:36.540 --> 09:41.780
Jadi sedikit perubahan yang bisa kita lakukan untuk memperbaikinya hanyalah melakukan cek.

09:42.020 --> 09:43.960
Saya benar-benar berpikir itu menempatkan ini dalam kode semu.

09:44.100 --> 09:47.780
Jika minimum bukan nilai yang awalnya Anda mulai dan kemudian tukar.

09:47.790 --> 09:49.900
Saat ini kami hanya bertukar apa pun yang terjadi.

09:49.950 --> 09:56.400
Jadi kita tambahkan saja syarat jika dan kita hanya akan lakukan jika saya tidak sama dengan terendah.

09:57.000 --> 10:02.100
Jika itu masalahnya, kita akan melakukan atau bertukar.

10:02.100 --> 10:08.330
Jadi jika saya menjalankan kembali bagian ini jelas di sini kita jalankan di sini.

10:08.340 --> 10:08.970
Itu dia.

10:08.970 --> 10:11.370
Sekarang Anda bisa melihat kami hanya melakukan empat swap.

10:11.370 --> 10:12.630
Kami tidak melakukan swap di sini.

10:12.630 --> 10:16.960
Kami tidak melakukan pertukaran di sini, tetapi kemudian kami membuatnya dan kami membuat dua.

10:17.040 --> 10:19.000
Mereka menghasilkan tiga dan kami membuat empat.

10:19.170 --> 10:20.030
Dan kemudian itu saja.

10:20.100 --> 10:20.740
Dilakukan.

10:21.060 --> 10:21.330
BAIK.

10:21.330 --> 10:22.760
Jadi saya punya kode yang sama.

10:22.890 --> 10:28.350
Singkirkan log konsulat tetapi tulis dengan sintaks ya 20:15.

10:28.800 --> 10:33.450
Jadi jika Anda lebih suka saya membawa swap keluar ke fungsi kecilnya sendiri muncul.

10:33.690 --> 10:37.100
Dan sekarang jika Anda melihat logika kami di sini cukup singkat.

10:37.100 --> 10:41.370
Anda dapat melakukannya pada satu baris yang saya bisa melakukan hal yang sama saya bisa memindahkan semua ini

10:41.370 --> 10:43.270
ke dalam fungsinya sendiri yang disebut swap juga.

10:43.500 --> 10:49.220
Tapi di sini ada dua versi dan pilih apa pun yang Anda suka. Saya menggunakan cara bertukar data yang lebih baru.

10:49.710 --> 10:54.490
Jadi hal yang sama perulangan pada setiap item membuat Lois menjadi I.

10:54.820 --> 10:59.610
Kemudian kita mulai J pada I ditambah 1 dan kemudian kita periksa.

10:59.610 --> 11:04.260
Saya benar-benar melakukan logika kebalikan atau perbandingan terbalik yang saya periksa apakah yang terendah lebih besar

11:04.260 --> 11:08.760
suatu array hari muncul saya lakukan untuk Ray-J kurang dari maksud saya hal yang sama.

11:08.880 --> 11:14.070
Dan kemudian kita hanya mereset terendah dan kemudian pada akhirnya jika saya tidak sama dengan swap terendah mereka.
