WEBVTT

00:00.240 --> 00:00.600
Baiklah.

00:00.600 --> 00:01.430
Selamat datang kembali.

00:01.440 --> 00:07.230
Jadi kami beralih ke algoritma pencarian kedua kami dan yang ini bisa menjadi peningkatan yang signifikan pada pencarian linear

00:07.320 --> 00:09.530
yang kami lihat di video terakhir.

00:09.570 --> 00:12.930
Ini disebut pencarian biner sehingga bisa jauh lebih cepat.

00:12.930 --> 00:19.020
Kami akan masuk ke spesifikasi dengan Big O nanti, tetapi bisa lebih cepat daripada menghilangkan satu elemen pada waktu seperti yang

00:19.020 --> 00:22.320
kami lakukan dalam pencarian linear di mana kami memeriksa satu elemen.

00:22.320 --> 00:22.950
Apakah ini.

00:22.950 --> 00:23.350
Nggak.

00:23.490 --> 00:24.230
Itu yang berikutnya.

00:24.250 --> 00:25.480
Tidak, itu X di atasnya.

00:25.500 --> 00:31.020
Berulang-ulang dalam pencarian biner kita dapat menghilangkan setengah dari elemen yang tersisa pada titik

00:31.020 --> 00:31.760
tertentu.

00:31.780 --> 00:34.150
Namun ada peringatan yang sangat besar di sini.

00:34.200 --> 00:40.200
Pencarian Biner hanya bekerja pada array yang diurutkan sehingga data harus diurutkan dari apakah itu angka terendah ke

00:40.200 --> 00:43.070
tertinggi atau tertinggi ke terendah atau string alfabet.

00:43.110 --> 00:45.100
Harus ada perintah untuk itu.

00:45.120 --> 00:48.090
Jadi bayangkan kita memiliki array status yang sama.

00:48.210 --> 00:50.100
Anda tidak perlu membayangkan itu ada di sini.

00:50.430 --> 00:56.900
Dan ini diurutkan secara alfabetis sehingga Anda dapat melihat Alabama ke Wyoming dan katakanlah seorang pengguna melakukan contoh yang

00:56.910 --> 01:01.980
sama di mana kami meminta pengguna untuk memasukkan status dan alamat mereka atau sesuatu.

01:01.980 --> 01:04.860
Dan kami akan memverifikasi bahwa itu ada dalam array ini.

01:04.860 --> 01:07.520
Sekarang pertama-tama ini adalah array yang sangat singkat dalam skema besar hal.

01:07.530 --> 01:10.640
Jadi pencarian linear tidak akan menjadi besar.

01:10.860 --> 01:16.710
Ini akan memakan banyak waktu dan bahwa milidetik mungkin kurang dari satu milidetik, sepersekian detik dari

01:16.710 --> 01:17.930
yang kita hemat.

01:17.930 --> 01:22.020
Dengan pencarian biner tidak terlalu bermanfaat, tetapi karena sudah diurutkan, ini adalah contoh yang bagus.

01:22.110 --> 01:26.510
Katakanlah seseorang memasukkan Oregon sebagai pernyataan akhir mereka.

01:26.820 --> 01:28.390
Dan kami ingin memeriksa fakta di sini.

01:28.590 --> 01:34.560
Yah karena ini disortir secara alfabet cara kerja pencarian biner adalah kita memilih titik setengah dalam

01:34.680 --> 01:35.570
array ini.

01:35.760 --> 01:39.240
Jadi di suatu tempat dan saya tidak akan menghitung dengan tepat saya pikir ada 59.

01:39.240 --> 01:45.480
Saya tidak akan menghitung titik setengah persis tetapi mari kita kira kira katakanlah kita memilih dua

01:45.630 --> 01:48.790
puluh sembilan dua puluh sembilan koma lima.

01:48.790 --> 01:49.250
Kanan.

01:49.260 --> 01:50.110
Jadi kita akan membulatkannya.

01:50.160 --> 01:54.540
Jadi kami memilih tempat pertama kami memilih tengah karena kami tahu itu diurutkan.

01:54.540 --> 01:59.910
Dalam hal ini secara alfabetis sehingga tengah harus menjadi elemen yang diurutkan tengah dan kemudian yang kita lakukan adalah

01:59.910 --> 02:00.710
kita periksa.

02:00.900 --> 02:07.650
Jadi kami menemukan Missouri di mana Anda berada dan kami memeriksa apakah Oregon lebih besar dari Missouri atau kurang dari dalam kasus kami

02:07.800 --> 02:08.660
berdasarkan abjad.

02:08.760 --> 02:12.790
Apakah setelah m Missouri itu setelah itu dalam alfabet.

02:12.810 --> 02:15.220
Atau sebelum dan sesudahnya.

02:15.660 --> 02:18.090
Jadi sekarang kita hanya peduli pada bagian teori ini.

02:18.120 --> 02:19.590
Kami baru saja menghilangkan semua ini.

02:19.590 --> 02:23.920
Kami tidak peduli dengan permulaan dan memeriksa kembali setengah dari sedikit berikutnya.

02:24.030 --> 02:28.760
Dan saya hanya akan mengamatinya daripada melakukan matematika katakanlah setengah jalan sekitar 44.

02:28.770 --> 02:33.170
Jadi katakanlah periksa Negara 44 yang memberi kita Pennsylvania.

02:33.180 --> 02:37.010
Jadi sekarang ini adalah tengah dari array ini di sini.

02:37.200 --> 02:41.840
Dan kita pergi ke Pennsylvania dan kita cek di Oregon sebelum atau sesudah Pennsylvania.

02:42.150 --> 02:43.660
Dan itu sebelumnya.

02:43.830 --> 02:46.140
Jadi sekarang kita peduli dengan daftar ini.

02:46.140 --> 02:49.290
Dari Missouri ke Pennsylvania kita tahu ada di suatu tempat di sini.

02:49.710 --> 02:51.800
Kami menghilangkan semua ini di sini.

02:52.020 --> 02:55.740
Jadi sekarang kita pergi dari Missouri ke Pennsylvania dan kita mengambil titik setengah lagi.

02:55.900 --> 02:58.130
Dan saya pikir ini sekitar 16 atau lebih.

02:58.140 --> 03:00.000
Jadi mari kita pergi ke yang kedelapan.

03:00.060 --> 03:07.200
Tiga empat lima enam tujuh delapan jadi kami pergi ke New York dan kami memeriksa Oregon lebih besar atau kurang dari New York

03:07.440 --> 03:08.540
dan lebih besar.

03:08.550 --> 03:11.030
Jadi itu antara New York dan Pennsylvania.

03:11.070 --> 03:13.470
Jadi kami memilih suatu tempat di tengah-tengah antara New York dan Pennsylvania.

03:13.470 --> 03:18.090
Katakanlah itu adalah Ohio dan kita tahu bahwa itu lebih besar daripada Ohio di suatu tempat antara Ohio

03:18.090 --> 03:18.690
dan Pennsylvania.

03:18.690 --> 03:20.950
Kami memilih yang di tengah dan sekarang di Oregon.

03:21.210 --> 03:22.740
Dan saya tahu itu sepertinya banyak pekerjaan.

03:22.860 --> 03:29.070
Tapi ingat itu hanya lima atau enam tebakan dibandingkan jika kita mulai pada awal dengan pencarian

03:29.070 --> 03:31.550
linier, kita periksa ini Oregon.

03:31.590 --> 03:32.020
Nggak.

03:32.100 --> 03:32.790
Apakah ini Oregon?

03:32.820 --> 03:33.260
Nggak.

03:33.360 --> 03:34.610
Lagi dan lagi dan lagi.

03:34.650 --> 03:37.750
Jadi menghemat banyak waktu jika data Anda diurutkan.

03:37.950 --> 03:41.010
Jadi mari kita lanjutkan ke detail implementasi.

03:41.020 --> 03:43.180
Jadi idenya adalah memecah belah dan menaklukkan.

03:43.290 --> 03:46.410
Jadi kami membagi array menjadi dua bagian.

03:46.410 --> 03:52.890
Kami biasanya memilih titik pivot di tengah. Dan kami memeriksa sisi kiri dan kanan dan melihat di mana itu

03:53.010 --> 03:56.400
berdasarkan apa yang kami cari di mana setengahnya berada.

03:56.670 --> 03:59.520
Jadi mari kita cari 15 dalam daftar ini.

03:59.520 --> 04:01.110
Ingat itu harus disortir.

04:01.140 --> 04:02.090
Ini tidak bekerja sama sekali.

04:02.090 --> 04:03.600
Jika tidak diurutkan.

04:03.600 --> 04:07.370
Jadi jika diurutkan di sini kita akan mulai dengan memilih.

04:07.370 --> 04:09.070
Kami akan memanggil mereka kiri dan kanan.

04:09.330 --> 04:13.830
Jadi kita akan mengubah jendela tempat kita mencari karena ingat kita dapat membuang setengah

04:13.830 --> 04:16.140
dari array secara kasar setiap waktu.

04:16.290 --> 04:21.510
Jadi kita akan mulai dengan kiri di satu ujung kanan di akhir 19 dan kemudian kita akan memilih suatu tempat

04:21.510 --> 04:22.290
di tengah.

04:22.290 --> 04:23.810
Dan saya pikir ini adalah angka ganjil.

04:23.970 --> 04:27.110
Jadi Anda bisa membulatkan ke atas atau ke atas hanya dengan konsisten.

04:27.300 --> 04:28.580
Sejauh mana Anda memilih.

04:28.710 --> 04:30.630
Jadi saya pikir kita akan memilih 11 di sini.

04:30.750 --> 04:38.190
Saya tahu kami memilih 11 dan kami memeriksa 15 lebih besar dari 11 atau kurang dari 11 dan lebih besar dari

04:38.190 --> 04:43.590
Jadi sekarang kita hilangkan semua itu ke kiri dan kita buat kiri baru 12.

04:44.430 --> 04:46.020
Dan hak baru itu sama.

04:46.020 --> 04:47.370
Ini 19 tahun.

04:47.370 --> 04:49.280
Sekarang kami memeriksa di suatu tempat di tengah.

04:49.560 --> 04:55.980
Jadi kita akan memeriksa 17 sebagai titik tengah kami dan kami memeriksa 15 lebih besar dari atau kurang dari 17.

04:56.050 --> 05:03.160
Itu ada di sisi kanan atau kiri dan itu adalah sisi kiri sehingga kita bisa menghilangkan 17 18 19.

05:03.400 --> 05:09.750
Dan sekarang kita telah pergi di 12 tepat di 16 dan kemudian tengah adalah 15 yang merupakan satu-satunya pilihan dan

05:10.010 --> 05:14.290
periksa kembali 15 sama dengan 15 lebih besar atau kurang dari itu sama.

05:14.290 --> 05:17.040
Jadi kami menemukan bahwa hanya perlu tiga cek.

05:17.110 --> 05:18.100
Tiga tebakan.

05:18.100 --> 05:21.430
Kami memeriksa di tengah pertama 11 dan kami tahu itu lebih besar.

05:21.430 --> 05:22.690
Jadi kami melakukan pemeriksaan kedua.

05:22.710 --> 05:24.520
Kami memilih 17 yang terlalu besar.

05:24.790 --> 05:28.680
Dan kemudian kami memilih 15 dan itu benar dibandingkan dengan mulai dari awal.

05:28.690 --> 05:33.500
Satu dua tiga empat lima enam tujuh delapan sembilan menebak menggunakan pencarian linier.

05:33.520 --> 05:39.730
Jadi jika kita memiliki nomor atau string array yang diurutkan atau apa pun asalkan kita dapat membandingkan dengan mudah untuk memeriksa apakah

05:39.730 --> 05:45.490
ada sesuatu yang lebih besar atau kurang daripada dalam beberapa hal jika kita bisa melakukan itu maka kita dapat

05:45.490 --> 05:47.640
menerapkan pencarian biner yang jauh lebih cepat.
