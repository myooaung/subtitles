WEBVTT

00:00.270 --> 00:00.840
Baiklah.

00:00.840 --> 00:03.710
Jadi, inilah kode semu untuk mengimplementasikan pencarian pertama yang luas.

00:03.720 --> 00:09.450
Ini sangat mirip dengan apa yang kami lakukan untuk pencarian pertama yang mendalam kecuali kami benar-benar menggunakan struktur data yang

00:09.780 --> 00:11.150
berbeda daripada menggunakan tumpukan.

00:11.190 --> 00:17.100
Kami menggunakan Q tapi saya hanya akan menggunakan array yang kami lakukan untuk stack tetapi kami hanya

00:17.100 --> 00:23.910
menggunakan metode yang berbeda daripada push dan pop kami akan menggunakan push dan kemudian bergeser sehingga kami menambahkan sampai akhir.

00:23.910 --> 00:29.220
Tapi kami bergerak dari awal sehingga hal pertama juga merupakan hal pertama yang berbeda dari yang kami

00:29.220 --> 00:33.790
miliki dengan versi pertama yang mendalam di mana hal pertama harus menunggu sampai akhir.

00:34.030 --> 00:41.820
OK jadi fungsi Anda kecuali untuk memulai kita hanya akan melakukan membuat Q Cukup gunakan array dan buat variabel yang disebut

00:41.820 --> 00:44.700
Q dan tempatkan simpul awal di dalamnya.

00:44.700 --> 00:46.140
Jadi ada sesuatu untuk memulai.

00:46.530 --> 00:47.990
Lalu seperti sebelumnya.

00:48.120 --> 00:50.600
Buat larik hasil kami untuk disimpan.

00:50.600 --> 00:53.430
Anda tahu apa yang kami kembalikan sampai selesai dengan pesanan kami.

00:53.540 --> 00:59.370
Buat objek untuk menyimpan node yang dikunjungi seperti yang telah kita lakukan panggil saja dikunjungi dan kemudian

00:59.370 --> 01:03.120
tandai titik awal sebagai dikunjungi kemudian bagian besar untuk logika.

01:03.300 --> 01:04.880
Selama ada sesuatu dalam antrian.

01:04.920 --> 01:11.430
Jadi sambil loop sementara ada sesuatu di sana kita akan menggeser vertex pertama dari antrian dan mendorongnya

01:11.820 --> 01:16.580
ke array yang menyimpan apa yang kita kunjungi yang menyimpan hasil kita.

01:16.650 --> 01:19.950
Jadi keluarkan item pertama dan dorong ke hasil.

01:20.280 --> 01:26.550
Dan kemudian untuk setiap tetangga di Virtex itu, semua tetangganya dan daftar kedekatan jika kita

01:26.550 --> 01:29.120
belum mengunjungi, menandainya sebagai dikunjungi.

01:29.280 --> 01:32.640
Dan kemudian tambahkan ke antrian itu, dorong ke ujung.

01:32.990 --> 01:33.590
BAIK.

01:33.870 --> 01:34.760
Jadi kita harus antri.

01:34.860 --> 01:36.370
Ini proses yang sama persis.

01:36.540 --> 01:40.300
Nah prosesnya hampir sama dengan pencarian first depth atau depth first traversal.

01:40.300 --> 01:43.550
Versi berulang tapi kami menggunakan q bukan tumpukan.

01:43.590 --> 01:47.000
Jadi kita masih mendorong sampai akhir tetapi kita sekarang bergeser dari awal.

01:47.040 --> 01:48.910
Kalau tidak, itu hampir sama.

01:48.990 --> 01:50.180
Saya akan menulis kode lagi.

01:50.200 --> 01:50.870
Video selanjutnya.

01:50.880 --> 01:55.380
Tapi Anda bisa mengambil kode Anda jika Anda menulis atau mengambil solusi saya dan hanya sedikit men-tweak saja.

01:55.590 --> 01:59.720
Dan pada akhirnya kita perlu mengembalikan array dari semua node yang kita kunjungi.

01:59.920 --> 02:00.460
BAIK.

02:00.720 --> 02:05.180
Jadi buatlah antrian ini untuk menyimpan semuanya, letakkan simpul pertama di sana tempat kita memulai.

02:05.340 --> 02:10.950
Dan sementara ada sesuatu dalam antrian itu kita akan menghapus item pertama kita akan menambahkannya

02:10.950 --> 02:14.470
ke hasil kita kemudian kita akan melihat setiap tetangga.

02:14.550 --> 02:19.650
Dan jika mereka belum dikunjungi mereka belum ditandai sebagai dikunjungi. Tandai bahwa Mr. mengunjungi dan kemudian mendorong mereka ke

02:19.650 --> 02:23.360
antrian dan terus berjalan dan kemudian mengembalikan seluruh hasil.

02:23.360 --> 02:24.280
Pada akhirnya.

02:24.500 --> 02:24.950
BAIK.

02:25.140 --> 02:26.760
Jadi mari kita lakukan di video berikutnya.
