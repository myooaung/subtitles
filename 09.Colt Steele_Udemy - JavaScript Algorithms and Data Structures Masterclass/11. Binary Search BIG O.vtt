WEBVTT

00:00.180 --> 00:00.560
Baiklah.

00:00.560 --> 00:01.380
Selamat datang kembali.

00:01.380 --> 00:05.520
Jadi saya ingin berbicara tentang kompleksitas waktu untuk pencarian biner bagaimana kinerjanya.

00:05.520 --> 00:07.150
Katakan saja pada array.

00:07.320 --> 00:09.920
Sehingga panjang array tumbuh berbagai macam array.

00:09.920 --> 00:10.530
Tentu saja.

00:10.680 --> 00:13.250
Bagaimana kompleksitas waktu tumbuh dalam hubungan.

00:13.380 --> 00:20.040
Dan Anda dapat melihat di sini di sebelah kiri terburuk kasus rata-rata 0 dari log dan saya akan kembali ke sana dan

00:20.040 --> 00:20.700
mengapa itu.

00:20.700 --> 00:26.940
Kasus terbaik tentu saja adalah 0 1 karena mungkin hal pertama yang kita pilih adalah elemen yang

00:26.940 --> 00:27.840
kita cari.

00:27.960 --> 00:31.680
Jika kita memilih titik tengah array dan itulah yang kita inginkan.

00:31.680 --> 00:35.840
Sementara itu satu operasi adalah waktu konstan 0 dari 1 yang cukup langka.

00:35.880 --> 00:42.030
Tapi mungkin terburuk, rata-rata case adalah 0 dari log end dan saya punya beberapa slide untuk menjelaskan bagaimana kita

00:42.120 --> 00:47.550
mendapatkan login jika Anda tidak terbiasa dengan logaritma dan bagaimana ini berlaku untuk O besar.

00:47.700 --> 00:48.750
Saya punya video cepat.

00:48.810 --> 00:51.480
Saya pikir ini adalah video terakhir dari bagian O besar.

00:51.510 --> 00:54.930
Saya pasti akan merekomendasikan Anda menontonnya jika Anda tidak yakin tentang logaritma.

00:54.930 --> 00:59.130
Jika Anda diajari mereka sejak lama dan Anda lupa mereka atau jika Anda tidak pernah mengajari

00:59.130 --> 01:00.490
mereka itu adalah video cepat.

01:00.540 --> 01:05.100
Jadi misalkan kita sedang mencari nomor 13 dalam array ini.

01:05.100 --> 01:06.770
Berapa banyak langkah yang harus diambil.

01:07.050 --> 01:09.880
Sebenarnya kita bisa melihat 13 tidak di sini sebagai manusia.

01:09.960 --> 01:12.680
Seharusnya ada di sini jika ingin berada dalam array ini.

01:12.960 --> 01:15.280
Tapi langkah pertama adalah memilih titik tengah.

01:15.510 --> 01:19.890
Dan saya tahu ini sepertinya bukan tengah tetapi ini semua angka dua digit di sini jadi

01:19.890 --> 01:20.730
agak miring.

01:20.850 --> 01:22.220
Tapi ini titik tengahnya.

01:22.350 --> 01:26.490
Jadi kami memilih 19 dan kami memeriksa 13 kurang dari atau lebih besar dari 19.

01:26.490 --> 01:27.340
Ini kurang dari itu.

01:27.390 --> 01:29.370
Jadi kita tahu ada di suatu tempat di sini.

01:29.370 --> 01:33.410
Jika itu akan berada di sini maka itu yang mewakili array ini.

01:33.450 --> 01:35.850
Kami sebenarnya tidak mengecilkan array.

01:35.850 --> 01:39.520
Kami hanya melihat bagian array yang lebih besar ini.

01:39.540 --> 01:41.670
Jadi kita memilih titik tengah lagi yaitu 9.

01:41.830 --> 01:44.880
Nah 13 adalah bahwa kurang dari atau lebih besar dari itu lebih besar dari 9.

01:44.970 --> 01:48.440
Jadi kita sekarang melihat beberapa array 11 14 15 ini.

01:48.720 --> 01:53.310
Jadi kami memilih titik tengah 14 adalah 13 persen. Untuk itu kurang dari itu.

01:53.580 --> 01:56.120
Jadi kita melihat perjamuan ini sekarang 11.

01:56.220 --> 01:59.300
Jadi kita periksa 13 sama dengan 11.

01:59.310 --> 02:01.040
Jawabannya tentu saja tidak.

02:01.110 --> 02:07.560
Jadi kita tahu bahwa 13 tidak ada dalam array ini kecuali array entah bagaimana tidak disortir dalam hal ini kita seharusnya

02:07.560 --> 02:08.920
tidak menggunakan pencarian biner.

02:09.030 --> 02:15.620
Tetapi mengingat kondisi pencarian biner kita dapat mengatakan tanpa keraguan ada Tinas tidak dalam array ini.

02:16.260 --> 02:17.490
Tidak, tidak di sini.

02:17.910 --> 02:22.690
Jadi jika kita melihat jumlah langkah di sini kita memiliki 16 elemen.

02:22.780 --> 02:27.350
Butuh empat langkah untuk mengatakan dengan pasti bahwa suatu unsur tidak ada di sana.

02:27.520 --> 02:30.650
Jadi kita bisa menemukannya lebih awal jika itu benar-benar ada di array ini.

02:30.730 --> 02:37.120
Jika kita mencari 9 misalnya dibutuhkan dua langkah untuk mencari 14 itu akan membutuhkan tiga langkah.

02:37.180 --> 02:43.510
Tetapi jika kita mencari sesuatu yang tidak ada di sana atau kasus terburuk dibutuhkan empat langkah.

02:43.660 --> 02:45.590
Sekarang 16 elemen 4 langkah.

02:45.640 --> 02:47.770
Mari kita tumbuhkan array kita.

02:47.780 --> 02:49.660
Mari kita gandakan ukurannya.

02:50.050 --> 02:56.940
Jadi alih-alih 16 AKU MENAMBAH benar saya menambahkan 16 elemen lagi sehingga kami memiliki 32 elemen dalam array kami.

02:56.980 --> 02:58.440
Ini terlihat seperti ini.

02:58.480 --> 03:01.660
Dan katakanlah saya sedang mencari nomor 32.

03:01.780 --> 03:03.420
Berapa banyak langkah yang akan diambil.

03:03.460 --> 03:05.620
Nah pada langkah pertama kita memilih titik tengah.

03:05.680 --> 03:06.960
Ini tidak termasuk sebagai langkah.

03:06.980 --> 03:08.550
Ini hanyalah susunan awal kami.

03:08.590 --> 03:13.730
Saya memilih titik tengah yang 16 dan kami testis 32 lebih besar dari atau kurang dari 16.

03:13.750 --> 03:14.690
Itu lebih besar dari.

03:14.710 --> 03:17.040
Jadi kita bisa mengabaikan semua ini.

03:17.050 --> 03:17.900
Itu dia.

03:17.950 --> 03:19.950
Perosotan ini membutuhkan waktu lama.

03:19.960 --> 03:25.870
Jadi sekarang kita melihat bagian array ini dan kami memilih titik tengah yang 24 dan kami membandingkan 32 Nah

03:26.040 --> 03:27.190
ketiga lebih besar.

03:27.190 --> 03:29.210
Jadi kita bisa mengabaikan semua ini.

03:29.320 --> 03:35.150
Selanjutnya kita melihat bagian ini dan kita memilih titik tengah lagi 32 lebih besar dari 28.

03:35.260 --> 03:39.220
Jadi kami mengabaikan semua Lewati ini.

03:39.250 --> 03:44.500
Sekarang kita melihat 30 sambil melihat bagian ini dan kita memilih titik tengah yang 30

03:44.800 --> 03:52.830
dan 32 lebih besar dari 30 sehingga kita mengabaikan bagian ini akhirnya memilih titik tengahnya lagi dan kita menemukan 32 kita baik untuk

03:52.830 --> 03:53.550
pergi.

03:53.670 --> 03:57.920
Dan itu butuh lima langkah satu langkah dua tiga.

03:58.290 --> 03:59.840
Apa yang menyoroti hal yang salah.

03:59.850 --> 04:03.140
Satu dua tiga empat lima sampai kami menemukannya.

04:03.270 --> 04:09.030
Jadi kami menggandakan jumlah elemen dari slide sebelumnya kami memiliki 16 elemen yang merupakan empat langkah untuk

04:09.180 --> 04:09.590
menemukan.

04:09.610 --> 04:13.730
Atau sebenarnya kami tidak menemukan elemen tetapi butuh maksimal empat langkah di sini.

04:13.770 --> 04:19.250
Kami menggandakannya menjadi 32 elemen dan butuh maksimum lima langkah untuk menemukan elemen kami.

04:19.260 --> 04:22.180
Jadi hubungan itu berbasis log juga.

04:22.260 --> 04:29.690
Dan berdasarkan log yang kita disederhanakan untuk login dan pada dasarnya berarti melakukan apa yang memberi kita kekuatan.

04:29.700 --> 04:40.020
Jadi jika kita kembali ke sini, 16 elemen, apa itu log basis 2 dari 16, itu adalah 4 karena 2 hingga kekuatan keempat

04:40.020 --> 04:41.820
memberi kita 16.

04:41.850 --> 04:44.430
Dua kali dua kali dua kali dua.

04:44.610 --> 04:50.560
Atau di sini log basis 2 dari 32 elemen dan 32.

04:50.670 --> 04:54.200
Itu berarti lima dua kali dua kali dua kali dua kali dua.

04:54.420 --> 05:01.550
Jadi setiap kali kita menggandakan ukuran dan setiap kali kita menggandakannya kita hanya menambahkan satu langkah ekstra.

05:01.560 --> 05:09.300
Jadi login benar-benar bagus jika kita melihat grafik kompleksitas O besar di sini Anda dapat melihat log in semua jalan

05:09.300 --> 05:10.490
di sini.

05:10.560 --> 05:11.690
Itu sangat bagus.

05:11.910 --> 05:14.880
Sangat bagus bahkan mereka tidak menempatkan garis yang terpisah di sini.

05:14.880 --> 05:21.720
Jadi ada O dari garis akhir linear-O besar kami dan kemudian di sini mereka meletakkan konstan dan login

05:21.840 --> 05:26.220
bersama karena dalam skema besar hal ketika Anda memperkecil cukup jauh

05:26.310 --> 05:33.300
sehingga Anda melihat sesuatu yang juga termasuk faktorial 0 dari login jauh lebih baik sehingga hanya terlihat seperti itu.

05:33.420 --> 05:37.170
Jadi login adalah pencarian biner yang sangat baik sangat cepat.

05:37.170 --> 05:42.150
Tentu saja peringatannya adalah bahwa ia hanya bekerja pada array yang diurutkan dan jika Anda tidak memiliki data

05:42.150 --> 05:46.860
yang diurutkan maka Anda kurang beruntung dan Anda harus menggunakan pencarian linier yang tidak mendekati kemajuan.

05:46.860 --> 05:51.510
Kita sebenarnya akan melihat beberapa algoritma lain ketika kita berbicara tentang hal-hal

05:51.870 --> 05:59.090
seperti pohon biner dan grafik di mana pemilik stasiun besar untuk kompleksitas waktu termasuk log dan lagi atau juga N masuk.

05:59.310 --> 06:04.320
Jadi, jika Anda tidak nyaman dengan log lagi, saya sangat menyarankan Anda menonton video itu tetapi juga

06:04.320 --> 06:05.140
memberikan waktu.

06:05.190 --> 06:09.450
Saya pikir kami memiliki beberapa bagian sebelum kami menemukan log dan lagi tetapi segera kami akan.
