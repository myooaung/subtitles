WEBVTT

00:00.220 --> 00:00.900
Selamat datang kembali.

00:00.900 --> 00:04.440
Sekarang kita memiliki grafik tertimbang di tempat kita bisa beralih ke diet.

00:04.590 --> 00:06.790
Itu bagus.

00:07.000 --> 00:07.580
Nggak.

00:07.800 --> 00:09.380
Itu dia.

00:09.390 --> 00:12.740
Ini adalah lelucon bodoh, tetapi ini sebenarnya adalah tiga upaya yang saya lakukan untuk memperbaikinya.

00:12.870 --> 00:15.110
Saya minta maaf untuk menodai warisannya.

00:15.120 --> 00:18.270
Saya tidak pernah ingat bagaimana mengeja namanya tetapi yang paling bawah di sini.

00:18.270 --> 00:19.570
D i j.

00:19.590 --> 00:24.810
Bagaimanapun yang akan kita lakukan sekarang adalah berjalan melalui langkah-langkah bagaimana algoritma bekerja agar Anda secara visual melewatinya

00:24.810 --> 00:28.150
satu langkah pada satu waktu sebelum kami menerjemahkannya ke kode.

00:28.350 --> 00:30.630
Dan grafik yang akan kita kerjakan terlihat seperti ini.

00:30.630 --> 00:32.310
Jadi ini adalah grafik berbobot.

00:32.370 --> 00:37.890
Di sini Anda tahu enam simpul dan masing-masing sisi memiliki angka yang terkait dengannya.

00:37.890 --> 00:43.350
Semoga jelas apa yang terjadi dengan apa dan jalur yang terpendek yang ingin kita temukan adalah

00:43.380 --> 00:45.090
dari A hingga Z.

00:45.630 --> 00:47.070
Jadi ada beberapa opsi.

00:47.090 --> 00:51.080
Ini adalah grafik yang sangat kecil dan sebagian besar di dunia nyata cukup besar.

00:51.210 --> 00:55.120
Tetapi bahkan dengan kumpulan data kecil ini ada banyak cara untuk beralih dari A ke.

00:55.560 --> 01:00.970
Dapat pergi di sekitar tepi Anda dapat pergi melalui tengah ada empat opsi plus apa.

01:01.080 --> 01:06.210
Belum lagi bisa mengambil beberapa absurd untuk sampai di sana termasuk loop di pula.

01:06.330 --> 01:07.470
Jadi itulah tujuan kami.

01:07.470 --> 01:08.710
Jadi, inilah algoritmenya.

01:08.710 --> 01:16.070
Rebus atau suling ke empat langkah utama setiap kali melalui loop utama akan melakukan sesuatu seperti ini.

01:16.080 --> 01:21.840
Jadi kami melihat untuk mengunjungi simpul baru yang Anda tahu bahwa satu-satunya cara kerjanya telah dimulai kembali dan kami

01:21.900 --> 01:25.250
mengunjungi simpul dan harus ada beberapa urutan agar kami mengunjungi mereka.

01:25.290 --> 01:30.660
Bagaimana kita memutuskan ke mana harus pergi selanjutnya dan kita mulai dengan memilih node dengan jarak terkecil yang diketahui

01:30.660 --> 01:31.860
untuk dikunjungi terlebih dahulu.

01:31.890 --> 01:35.010
Jadi saya akan kembali ke semua ini secara visual hanya dalam beberapa saat.

01:35.010 --> 01:39.090
Tapi kami selalu memilih node yang memiliki jarak terkecil yang diketahui dari A.

01:39.360 --> 01:45.480
Dan kami mengunjungi yang pertama kemudian setelah kami pindah ke simpul itu kami melihat masing-masing tetangganya

01:45.480 --> 01:50.750
dan kemudian untuk masing-masing tetangganya kami menjumlahkan jarak dari A ke tetangga itu.

01:50.940 --> 01:57.090
Dan jika itu lebih kecil dari apa yang saat ini kita ketahui jika jaraknya lebih kecil maka kita memperbarui

01:57.090 --> 01:57.770
file kita.

01:57.780 --> 02:00.720
Pada dasarnya ini banyak untuk dibicarakan tanpa menunjukkan kepada Anda.

02:00.720 --> 02:02.660
Jadi saya punya banyak diagram seperti ini.

02:02.660 --> 02:05.460
Kita akan tiba sebentar lagi, tetapi itulah langkah-langkahnya.

02:05.460 --> 02:10.890
Jadi setiap kali kita mengunjungi simpul baru setiap kali kita mencari untuk memulai perulangan, kita mengunjungi

02:10.890 --> 02:13.080
jarak terkecil yang diketahui dari A.

02:13.080 --> 02:15.150
Dalam kasus kami, kami sedang mencari delapan.

02:15.570 --> 02:20.840
Jadi kita mulai dengan itu kita pindah ke node itu dan kita melihat masing-masing tetangganya dan untuk

02:21.090 --> 02:24.800
masing-masing tetangga kita sudah memiliki jarak pada file seberapa jauh dari.

02:25.050 --> 02:31.740
Dan kami akan memperbaruinya jika jarak baru yang kami miliki bersama kurang dari yang kami ketahui saat

02:31.740 --> 02:32.350
ini.

02:32.490 --> 02:33.940
Dan saya tahu itu terdengar gila.

02:34.080 --> 02:34.880
Jadi saya akan kembali ke sana.

02:34.890 --> 02:36.130
Tapi ini diagram kita.

02:36.180 --> 02:42.930
Ini adalah semacam pengaturan untuk 30 sesuatu berikutnya mungkin 40 slide dan hanya memudar di antara mereka dan Anda akan melihat

02:42.930 --> 02:44.420
hal-hal datang dan pergi.

02:44.430 --> 02:46.000
Jadi grafik yang sama ada di sini.

02:46.080 --> 02:47.520
Kita beralih dari A ke E.

02:47.640 --> 02:49.470
Itu memiliki nilai yang sama di sana.

02:49.470 --> 02:55.050
Dan di sini adalah semacam file yang saya maksud di mana kami menyimpan jarak terpendek

02:55.080 --> 02:56.670
dari untuk setiap titik.

02:56.790 --> 03:03.510
Jadi A adalah kasus khusus karena itu akan menjadi nol tetapi sesuatu seperti B Yah akhirnya jarak terpendek

03:03.510 --> 03:05.820
dari A ke B adalah empat.

03:05.820 --> 03:06.720
Tentu saja.

03:06.720 --> 03:12.120
Tetapi kemudian seperti E yang akan kita bahas, tujuan kami adalah untuk mencari tahu jarak yang terdekat.

03:12.390 --> 03:15.090
Lagi pula, kami akan memperbarui ini seiring berjalannya waktu.

03:15.090 --> 03:15.930
Dan sebelumnya.

03:15.930 --> 03:17.900
Saya akan jelaskan sedikit.

03:17.910 --> 03:24.060
Jadi mari kita mulai dan hal pertama yang kita lakukan adalah menginisialisasi jarak terpendek dari untuk

03:24.060 --> 03:24.850
setiap titik.

03:24.960 --> 03:27.380
Dan kita tidak benar-benar tahu bagaimana melakukannya.

03:27.510 --> 03:28.230
Itulah intinya.

03:28.230 --> 03:31.590
Kami tidak tahu apa jarak terdekat dari untuk sampai ke F ..

03:31.590 --> 03:33.960
Bayangkan ada sejuta simpul di sini.

03:33.960 --> 03:35.910
Anda tidak bisa hanya tahu dari awal.

03:35.940 --> 03:36.890
Jadi apa yang kita lakukan.

03:36.990 --> 03:41.250
Kami hanya menempatkan tak terhingga di sini kami menempatkan nilai besar pada dasarnya tidak diketahui.

03:41.340 --> 03:47.850
Kita tidak bisa kita tidak tahu nilai-nilai ini kecuali untuk satu yang kita tahu jarak terpendek dari A ke

03:47.850 --> 03:51.790
A adalah nol dari satu titik ke titik itu sendiri.

03:51.900 --> 03:53.020
Itu akan menjadi nol.

03:53.190 --> 03:57.270
Jadi itulah yang kita mulai dengan ini adalah bagaimana kita selalu menginisialisasi pengaturan.

03:57.360 --> 04:01.380
Jadi kita akan membuat struktur data untuk ini kita belum akan membicarakan kode dulu.

04:01.380 --> 04:04.590
Tapi bayangkan Anda menuliskan ini di selembar kertas.

04:04.710 --> 04:08.380
Jadi A ke A adalah nol A ke B.

04:08.430 --> 04:10.380
Saat ini adalah ketidakterbatasan yang tidak kita ketahui.

04:10.380 --> 04:12.060
A hingga Z adalah tak terhingga.

04:12.060 --> 04:13.740
Jadi kami mengabaikannya.

04:13.770 --> 04:15.260
Sekarang ingat langkah-langkahnya.

04:15.300 --> 04:18.970
Hal berikutnya yang kami lakukan setiap kali kami ingin mengunjungi simpul baru.

04:19.110 --> 04:22.280
Kami akan memilih simpul dengan jarak terkecil yang diketahui untuk dikunjungi terlebih dahulu.

04:22.490 --> 04:24.860
Kita punya satu pilihan sekarang.

04:25.260 --> 04:26.120
Itu yang terkecil.

04:26.130 --> 04:28.400
0 jelas lebih kecil dari tak terbatas.

04:28.440 --> 04:29.940
Jadi kita mulai dengan A.

04:29.940 --> 04:30.900
Jadi kami memilih yang terkecil.

04:30.890 --> 04:32.700
Itulah yang ditampilkan di sini.

04:32.700 --> 04:35.340
Dan saya telah menambahkannya ke daftar yang dikunjungi di sini.

04:35.340 --> 04:38.950
Sekarang yang perlu kita lakukan adalah melihat masing-masing tetangganya.

04:38.970 --> 04:45.260
Jadi dari a kita memiliki dua pilihan A ke B A untuk melihat dan saya akan selalu menurut abjad.

04:45.310 --> 04:46.500
Tidak masalah.

04:46.500 --> 04:48.500
Jadi kita akan mulai dengan A ke B.

04:48.570 --> 04:52.730
Jadi yang kita lakukan adalah kita turun ke B dan kita periksa.

04:52.830 --> 04:58.430
Nah saat ini jarak terdekat dari A ke B adalah tak terhingga karena kita tidak tahu yang lebih baik.

04:58.440 --> 05:04.550
Itu hanya keadaan awal sehingga yang kami temukan adalah jarak dari A ke B di sini adalah empat.

05:04.920 --> 05:07.670
Jadi empat pasti kurang dari tak terbatas.

05:07.710 --> 05:14.580
Jadi kami memperbarui ini untuk mengatakan bahwa jarak terpendek baru dari A adalah 4 dan Anda akan melihat bahwa kami memperbarui

05:14.580 --> 05:16.580
beberapa di antaranya beberapa kali.

05:16.620 --> 05:18.940
Tentu saja kita bisa melihat melihat grafik.

05:18.940 --> 05:21.660
Tidak ada yang lebih pendek antara A dan B itu pasti empat.

05:21.720 --> 05:23.140
Itu yang terkecil yang akan kita dapatkan.

05:23.470 --> 05:23.940
BAIK.

05:24.090 --> 05:31.050
Jadi kami memperbarui itu di sini dan kemudian di sini dalam struktur sebelumnya kami akan memperbarui dikatakan

05:31.050 --> 05:32.400
sama dengan A.

05:32.700 --> 05:37.950
Jadi apa yang pada dasarnya dilakukan dan saya tahu saya kehilangan tanda kutip bukan kode yang valid

05:38.100 --> 05:41.880
tetapi apa yang dilakukan adalah mengatakan cara kita harus melalui a.

05:42.260 --> 05:44.750
Dan itu jelas dalam situasi ini.

05:44.760 --> 05:52.080
Tetapi kemudian pada sesuatu seperti f jika kita memperbarui jarak terpendek ke f kita ingin mengingat bahwa kita sampai di

05:52.080 --> 05:53.210
sana dari D.

05:53.220 --> 05:54.890
Atau apakah kita sampai di sana dari C ..

05:54.930 --> 05:56.010
Ada beberapa opsi.

05:56.010 --> 06:02.250
Jadi struktur ini membantu kita mengumpulkan dari mana kita berasal dari simpul yang terjadi atau yang terjadi

06:02.310 --> 06:05.030
tepat sebelum berada di jalur kita.

06:05.040 --> 06:06.490
Jadi itu yang sederhana.

06:06.510 --> 06:09.460
Jadi kami telah melakukan semua yang perlu kami lakukan untuk b.

06:09.480 --> 06:11.800
Sekarang kita melihat untuk melihat.

06:12.060 --> 06:12.710
BAIK.

06:12.900 --> 06:16.390
Jadi saat ini dari a ke c kita memiliki infinity.

06:16.740 --> 06:19.430
Jadi kita melihat pada jarak itu totalnya adalah dua.

06:19.440 --> 06:22.660
Jadi tentu saja kita akan memperbarui ini juga pasti lebih pendek.

06:22.800 --> 06:29.280
Dan kemudian kita datang ke sini untuk melihat dan alih-alih Tidak, kita memperbaruinya untuk mengatakan bahwa

06:29.280 --> 06:36.070
cara kita melihatnya adalah dari a dan hanya itu untuk kita telah melakukan kedua tetangga untuk dicatat.

06:36.520 --> 06:39.740
Jadi sekarang yang harus kita lakukan adalah mengulangi prosesnya.

06:39.760 --> 06:43.780
Kami memilih nilai terkecil yang diketahui, jarak terdekat dari A.

06:43.990 --> 06:45.310
Itu belum kami kunjungi.

06:45.490 --> 06:47.080
Jadi ingat kita pernah berkunjung ke a.

06:47.170 --> 06:51.860
Jadi kita tidak akan memilih karena kita terus melakukan berulang-ulang.

06:52.090 --> 06:53.940
Tapi sekarang kita punya dua pilihan.

06:53.980 --> 06:57.990
B Jaraknya 4 dan C jaraknya dua.

06:58.210 --> 07:01.460
Dan ketika saya mengatakan jarak, itu jarak dari simpul.

07:01.770 --> 07:02.100
BAIK.

07:02.140 --> 07:06.690
Jadi seperti yang Anda lihat, kita mulai dengan C yang merupakan jarak terkecil yang diketahui.

07:06.770 --> 07:12.430
Jadi sekarang kita melihat c dan tetangganya dan ada tiga pilihan tapi kita sudah melakukan delapan C jadi kita tidak

07:12.430 --> 07:13.620
akan melakukan itu.

07:13.630 --> 07:16.460
Jadi sekarang kita memiliki C ke D dan C ke F.

07:16.510 --> 07:16.770
Baiklah.

07:16.780 --> 07:19.040
Jadi mari kita lihat c to d terlebih dahulu.

07:19.060 --> 07:24.720
Jadi apa yang kita lakukan lagi adalah kita melihat apa nilai saat ini dari A ke D.

07:24.790 --> 07:26.500
Ini disimpan hingga tak terbatas.

07:26.710 --> 07:36.190
Jadi kita menghitung nilai baru dari A ke D hingga C dan cara kita melakukannya adalah dengan menjumlahkan A ke C ditambah

07:36.430 --> 07:37.730
C ke D.

07:38.050 --> 07:45.490
Jadi misalnya kita tahu bahwa C to D adalah dua orang jadi ambil dua dan kemudian kita lihat bagaimana kita bisa melihat

07:45.640 --> 07:49.340
apa yang sebelumnya untuk C dan yang sebelumnya adalah a.

07:49.600 --> 07:53.080
Jadi kita mencari tahu berapa jarak dari A ke C 2.

07:53.110 --> 07:55.350
Jadi dua tambah dua memberi kita empat saja.

07:55.570 --> 07:59.470
Dan jelas mudah bagi kami untuk melihatnya, tetapi Anda harus berpikir tentang apa yang akan

07:59.470 --> 08:00.350
dilakukan kode Anda.

08:00.370 --> 08:01.960
Jadi kami menjumlahkan keduanya.

08:02.100 --> 08:02.930
Itu hanya memberi empat.

08:03.000 --> 08:06.180
Dan kami akan memperbarui ini di sini untuk disimpan.

08:06.220 --> 08:08.320
Itu jelas lebih kecil dari tak terbatas.

08:08.650 --> 08:14.650
Dan kemudian kita juga perlu memperbarui di sini untuk mengatakan bagaimana kita sampai ke D dan cara kita sampai di sana adalah melalui

08:14.800 --> 08:15.580
C ..

08:15.720 --> 08:16.920
Jadi itulah yang kami tambahkan.

08:17.260 --> 08:17.900
BAIK.

08:18.250 --> 08:20.960
Selanjutnya kita akan melihat C ke F.

08:21.040 --> 08:22.330
Proses yang sama.

08:22.330 --> 08:27.220
Jadi C ke F adalah 4 dan kemudian A ke C adalah 2.

08:27.310 --> 08:33.520
Dan cara kita tahu pasti tepi ini adalah jika kita melihat c kita menyimpan sebagai sebelumnya Cara terpendek untuk

08:33.520 --> 08:34.530
sampai ke sana.

08:34.810 --> 08:37.270
Jadi dua tambah empat memberi kita enam.

08:37.270 --> 08:40.560
Jadi kita turun ke F dan kita periksa enam kurang dari tak terbatas.

08:40.570 --> 08:41.200
Iya nih.

08:41.230 --> 08:42.210
Jadi kami memperbaruinya.

08:42.250 --> 08:46.470
Jadi kami menyimpan enam di sini dan kemudian yang perlu kami lakukan adalah memperbarui yang sebelumnya.

08:46.570 --> 08:47.990
Bagaimana kita sampai ke ..

08:48.200 --> 08:53.910
Nah apa yang datang tepat sebelum itu C jadi semoga Anda bisa melihat bagaimana ini menjadi berguna.

08:53.980 --> 08:58.560
Apa yang kami simpan di sini adalah jalur terpendek ke sembarang node dari.

08:58.750 --> 09:05.830
Jadi cara terpendek untuk sampai ke D adalah dari C dan kemudian cara terpendek untuk melihat dari a adalah

09:05.830 --> 09:06.800
langsung dari.

09:07.060 --> 09:09.810
Jadi kita hanya perlu menyimpan jalur terpendek sebelumnya.

09:10.030 --> 09:13.840
Jadi itu semacam langkah demi langkah bagaimana kita sampai ke setiap simpul. Cara tersingkat untuk sampai ke sana

09:13.900 --> 09:18.260
Dan kami menggabungkan mereka semua untuk mencari tahu bagaimana untuk sampai pada akhirnya yang tidak dilakukan.

09:18.520 --> 09:20.850
Jadi kami memperbaruinya dengan mengatakan kami berasal dari C ..

09:20.890 --> 09:21.940
Sekarang kita mulai lagi.

09:22.030 --> 09:27.010
Kita harus memilih nilai terkecil jarak terdekat dari A yang belum kita kunjungi.

09:27.160 --> 09:35.220
Jadi kita sudah melakukan a dan c sehingga kita bisa mencoretnya dan yang terpendek adalah b dengan 4 d dengan 4 atau F

09:35.230 --> 09:36.160
dengan enam.

09:36.160 --> 09:41.020
Yah jelas bukan enam dan saya memilih B Pertama hanya karena datang lebih dulu berdasarkan abjad.

09:41.020 --> 09:42.250
Tetapi salah satu dari mereka akan bekerja.

09:42.250 --> 09:43.260
Mereka berdua berempat.

09:43.450 --> 09:48.600
Jadi sekarang kita melihat B dan B itu mudah karena kita sudah mengunjungi A ke B.

09:48.760 --> 09:49.840
Jadi itu tidak terjadi.

09:50.050 --> 09:51.660
Tapi kita punya B untuk dimakan.

09:51.970 --> 09:52.430
BAIK.

09:52.510 --> 09:53.590
Jadi kita akan melihatnya.

09:53.920 --> 10:00.200
Dan itu memberi kita tiga plus apa yang datang sebelum B kita sampai B kita berasal dari a.

10:00.340 --> 10:01.720
Jadi ujung itu empat.

10:01.830 --> 10:04.340
Jadi tiga tambah empat memberi kita tujuh sebagai total baru.

10:04.420 --> 10:06.500
Dan itu jelas kurang dari tak terbatas.

10:06.670 --> 10:13.090
Jadi kami memperbarui ini untuk mengatakan dengan baik bahwa cara terpendek saat ini yang bisa kita dapatkan untuk Z adalah 7 unit atau apa

10:13.090 --> 10:14.820
pun ini tujuh mil atau sesuatu.

10:15.220 --> 10:21.030
Dan kemudian cara kita sampai di sana di sini kita akan memperbarui ini dengan mengatakan kita berasal dari B.

10:21.160 --> 10:21.820
Kanan.

10:21.820 --> 10:27.490
Jadi jika kita berhenti sekarang ini bukan jalan terpendek tetapi kita memiliki jalan yang bisa kita kumpulkan.

10:27.490 --> 10:31.050
Jadi kita harus e dari B dan kita harus dari a.

10:31.150 --> 10:34.800
Sekarang dari node yang belum dikunjungi ke mana kita pergi.

10:35.020 --> 10:41.320
Jadi kami telah melakukan b c dan sekarang kami memiliki DNF atau yang merupakan D. terkecil

10:41.440 --> 10:43.360
Jadi kita akan ke yang berikutnya.

10:43.360 --> 10:43.920
BAIK.

10:44.230 --> 10:45.300
Jadi di sini D.

10:45.610 --> 10:47.120
Dan kami memiliki beberapa opsi.

10:47.140 --> 10:48.350
Kami sudah pernah melihat.

10:48.400 --> 10:49.610
Jadi kita tidak akan seperti itu.

10:49.900 --> 10:54.420
Jadi kita pergi makan atau aku akan abjad jadi e datang dulu.

10:54.700 --> 10:56.480
Jadi kita akan melihat d e.

10:56.710 --> 10:58.430
Jadi ujung itu adalah tiga.

10:58.480 --> 11:03.190
Jadi sekarang kita menghitung jarak total dari A ke E hingga D.

11:03.430 --> 11:05.350
Jadi totalnya di sini adalah 7.

11:05.530 --> 11:09.720
Dan jika kita melihat apa yang telah kita simpan sekarang ini sudah di 7.

11:09.730 --> 11:10.930
Jadi itu tidak menang.

11:10.960 --> 11:11.740
Tidak kalah.

11:11.740 --> 11:12.570
Itu tidak lebih pendek.

11:12.700 --> 11:14.640
Jadi kita tidak akan memperbaruinya.

11:14.650 --> 11:19.780
Anda bisa jika Anda mau, Anda bisa menulis kode Anda yang Anda tambahkan tujuh di sini jika mereka sama.

11:19.780 --> 11:23.220
Tapi tidak ada alasan kita sudah memiliki jalur yang memiliki 7 unit panjang.

11:23.470 --> 11:24.580
Yang ini.

11:24.580 --> 11:25.630
Jadi kami mengabaikannya.

11:25.990 --> 11:29.980
Sekarang kita beralih ke yang berikutnya yaitu D ke F.

11:29.980 --> 11:36.920
Jadi total baru kami di sini sampai F adalah 5 dan jika Anda melihat apa yang telah kami simpan sekarang, kami memiliki enam.

11:36.970 --> 11:38.260
Nah lima kurang dari enam.

11:38.290 --> 11:46.180
Jadi kami memperbaruinya dengan mengatakan lima dan kami datang ke sini untuk f dan kami tidak lagi berasal dari C. Itu yang kita miliki

11:46.180 --> 11:47.170
sebelumnya.

11:47.170 --> 11:49.350
Ini adalah cara terpendek untuk sampai ke F ..

11:49.510 --> 11:52.670
Tapi sekarang sebenarnya lebih pendek jika kita berasal dari D.

11:52.720 --> 11:54.750
Jadi kami memperbaruinya.

11:54.820 --> 11:58.380
Jadi ini mengatakan Anda tahu cara tercepat untuk sampai ke F adalah dari D.

11:58.450 --> 12:06.790
Jalur terdekat terdekat dari A ke D adalah melalui C. Cara terpendek dari A ke C adalah dengan baik karena ada jalur

12:07.390 --> 12:09.360
langsung dari A ke Z.

12:09.690 --> 12:10.250
BAIK.

12:10.390 --> 12:11.980
Jadi itu selesai D.

12:12.010 --> 12:14.420
Kami melakukan tepi ini kami melakukan tepi ini.

12:14.500 --> 12:15.490
Jadi sekarang kita mencoretnya.

12:15.490 --> 12:16.330
Kami mengunjungi.

12:16.510 --> 12:17.570
Itu dia.

12:17.590 --> 12:20.250
Sekarang kita akan memilih yang terkecil lagi.

12:20.260 --> 12:21.800
Jadi kita punya dua opsi.

12:21.850 --> 12:25.250
Kami mengunjungi semua ini untuk a c dan d.

12:25.300 --> 12:31.370
Sekarang kita memiliki E dan F yang terkecil yang memiliki jarak terdekat atau jalur terpendek ke a.

12:31.510 --> 12:35.030
Saat ini f 5 lebih kecil dari 7.

12:35.320 --> 12:38.200
Jadi kita akan mulai di sini dan kita hanya punya satu opsi.

12:38.200 --> 12:40.500
Kami sudah melakukan edge ini, kami sudah melakukan edge ini.

12:40.520 --> 12:43.260
Jadi sekarang kita melihat ft.

12:43.420 --> 12:46.100
Jadi jaraknya adalah satu untuk pergi dari kiri ke E.

12:46.330 --> 12:49.040
Dan apa jalan terpendek untuk sampai ke ..

12:49.060 --> 12:52.530
Jadi kita tambahkan itu bersama-sama 4 5 6.

12:52.900 --> 12:59.510
Dan jika kita melihat apa yang saat ini kita simpan untuk e kita memiliki 7 kita memiliki 7 dari jalur ini di luar.

12:59.530 --> 13:01.050
Kami sekarang menemukan sesuatu yang lebih pendek.

13:01.240 --> 13:04.650
Jadi kami perbarui ini untuk mencoretnya.

13:04.750 --> 13:06.300
Dan sekarang kita tambahkan enam.

13:06.430 --> 13:10.980
Dan tentu saja kita harus memperbarui bagaimana kita sampai di sana karena saat ini kita sedang menyimpan versi lama jika

13:10.990 --> 13:11.700
Anda melihatnya.

13:11.710 --> 13:17.190
Kami mengatakan jalur terpendek dari A ke Z melewati B tetapi itu tidak terjadi.

13:17.350 --> 13:20.700
Kami sekarang hanya menemukan sesuatu yang lebih pendek di mana kami melewati F.

13:21.040 --> 13:22.110
Jadi kami perbarui ini.

13:22.150 --> 13:23.530
Jika kita melihat E.

13:24.340 --> 13:24.890
Itu dia.

13:25.030 --> 13:30.670
Kami sekarang mengatakan cara terpendek untuk sampai ke sana adalah melalui F dan hanya satu perbedaan huruf sekarang

13:30.670 --> 13:35.940
membuat perbedaan besar karena itu kaskade itu rantai karena kami melihat di mana F ..

13:35.950 --> 13:40.850
Baiklah, hanya untuk sampai ke F, kami melewati D untuk sampai ke DeviantArt C untuk melihat kami melewati.

13:41.050 --> 13:43.510
Dan pada titik ini kita tidak punya tempat lain untuk pergi.

13:43.510 --> 13:44.810
Selain dari E.

13:45.130 --> 13:47.020
Dan itu berarti kita sudah selesai.

13:47.020 --> 13:49.250
Kami menemukan jalan terpendek.

13:49.360 --> 13:55.630
Jadi untuk memecahnya lagi saya tidak akan pergi langkah demi langkah tetapi setiap kali kita memilih jarak terkecil saat

13:55.630 --> 13:57.780
ini dari yang belum kita kunjungi.

13:57.880 --> 14:03.820
Kami menjelajahi masing-masing tetangganya dan kami Koukl dengan jarak terpendek yang baru ke masing-masing tetangga dan jika lebih kecil dari

14:03.820 --> 14:09.460
apa yang sudah kami simpan, kami memperbarui apa yang kami simpan dan kemudian kami mencerminkan perubahan di sini

14:09.580 --> 14:11.270
dalam struktur data kami sebelumnya.

14:11.440 --> 14:14.070
Dan ini memungkinkan kita untuk menyatukan semuanya.

14:14.260 --> 14:18.500
Jadi jika kita melihat ini kita sudah selesai sekarang yang harus kita lakukan adalah bekerja mundur.

14:18.520 --> 14:22.750
Jadi untuk mendapatkan e dari kita mulai dan kita melihatnya.

14:22.770 --> 14:24.010
Baiklah.

14:24.340 --> 14:30.160
Nah untuk sampai ke F dari cara terpendek yang mungkin itulah yang ini semua menyimpan kita berakhir dengan

14:30.220 --> 14:38.440
daftar cara terpendek untuk sampai ke setiap simpul dari cara terpendek untuk sampai ke D dari a adalah melalui C dan untuk sampai ke C

14:38.440 --> 14:40.350
kita harus pergi dari a.

14:40.510 --> 14:41.480
Jadi C D.

14:41.500 --> 14:43.000
Itu cara terpendek untuk sampai ke sana.

14:43.150 --> 14:48.890
Cara terpendek untuk sampai ke adalah melalui F dan dari f pertama Anda melewati D dari D.

14:48.890 --> 14:51.060
Kami melewati C C.

14:51.310 --> 14:52.890
Jadi ini jalan terpendek kita.

14:52.960 --> 14:56.060
A C D F D.

14:56.410 --> 15:02.350
Jadi algoritma Dexters bekerja tidak hanya jika memberi Anda jalur terpendek antara dua node di akhir cara

15:02.350 --> 15:07.870
kami mengimplementasikannya, akan memiliki struktur data yang memberi kami jalur terpendek dari A ke semua

15:07.870 --> 15:10.300
node dan itu bisa sangat berguna.

15:10.610 --> 15:13.830
Jika Anda tahu Anda menjalankan ini sekali dan Anda tidak mengubah grafik Anda.

15:13.930 --> 15:17.040
Anda memiliki struktur ini yang memberi Anda jalan terpendek untuk pergi ke mana pun.

15:17.050 --> 15:21.190
Anda tidak perlu memutarnya kembali untuk setiap yang Anda tahu jika Anda mencoba beralih dari A ke B dan kemudian

15:21.360 --> 15:24.740
ke ke d dan e Anda berlari pada satu waktu dan Anda mendapatkan semua informasi itu.

15:25.210 --> 15:25.720
Baiklah.

15:25.810 --> 15:27.040
Jadi saya tahu banyak.

15:27.130 --> 15:30.370
Saya membuat salindia ini untuk selamanya dan saya harap itu membantu.

15:30.370 --> 15:35.080
Saya merekomendasikan untuk melangkah melalui mereka sendiri dan hanya tanpa saya jenis menjelaskan apa yang

15:35.080 --> 15:38.560
saya lakukan dalam video mencoba dan atau bahkan pada selembar kertas.

15:38.710 --> 15:40.450
Begitulah cara saya mempelajarinya semula.

15:40.450 --> 15:44.820
Secara grafik, buat kertas gambar bagan-bagan ini dan ikuti jejak yang Anda ketahui.

15:44.890 --> 15:45.090
Baiklah.

15:45.090 --> 15:51.160
Kami sudah pernah ke tanda silang kami membengkokkan untuk melepaskannya dan menggambar grafik karena dari sini lompatan

15:51.460 --> 15:53.540
ke kode tidak terlalu buruk.

15:53.770 --> 15:57.370
Ini akan sulit jika Anda tidak yakin bagaimana ini bekerja.

15:57.370 --> 16:01.640
Jadi saya benar-benar sangat menyarankan Anda melakukan itu jika Anda sama sekali bingung.

16:01.780 --> 16:04.600
Jika Anda tidak merasa ingin menonton video, saya tidak bermain lama.

16:04.600 --> 16:09.420
Ini tidak terlalu menarik untuk dilalui tetapi bisa sedikit lebih menarik jika Anda melakukannya sendiri.

16:09.490 --> 16:12.770
Dan begitu Anda memahaminya melompat ke kode itu jauh lebih mudah.

16:13.000 --> 16:13.370
Baiklah.

16:13.570 --> 16:15.080
Jadi itulah yang akan kita lakukan selanjutnya.

16:15.100 --> 16:18.220
Saya benar-benar akan menunjukkan kepada Anda semacam kode palsu nyata jika Anda mau.

16:18.370 --> 16:22.840
Dan kemudian jika Anda mau, Anda bisa mencoba dan mengimplementasikan atau karena ini sedikit rumit.

16:22.840 --> 16:25.540
Benar-benar dimengerti jika Anda hanya kode bersama saya.

16:25.570 --> 16:25.880
Baiklah.

16:25.880 --> 16:26.670
Itu akan terjadi selanjutnya.
