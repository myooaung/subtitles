WEBVTT

00:00.210 --> 00:00.810
Baiklah.

00:00.810 --> 00:02.030
Jadi mari kita coba ini.

00:02.190 --> 00:04.420
Tetapi bahkan sebelum kita berbicara tetapi kodesemu.

00:04.590 --> 00:08.820
Ingat saya tidak tahu apakah Anda menonton video awal di bagian ini, tetapi saya berbicara tentang

00:08.820 --> 00:11.350
antrian prioritas dan bagaimana hal itu berperan dalam algoritma.

00:11.670 --> 00:13.140
Di sinilah tempatnya.

00:13.140 --> 00:19.320
Ketika kita berbicara tentang memilih nilai terkecil di sini seperti jika kita kembali, saya tidak tahu di sini di

00:19.320 --> 00:21.860
mana kita harus memilih nilai terkecil berikutnya.

00:21.870 --> 00:27.420
Jadi kami mengunjungi C dan B, kami perlu melihat sisanya dan mencari tahu ke mana kami pergi selanjutnya.

00:27.470 --> 00:31.000
Kami memiliki empat untuk tujuh untuk e dan 6 untuk f.

00:31.050 --> 00:33.760
Jadi kami memilih D untuk itu.

00:33.810 --> 00:36.130
Ini sangat mudah dilakukan dengan tiga node.

00:36.150 --> 00:41.250
Tetapi jika kita memiliki satu juta yang kita pantau untuk menemukan yang terkecil berikutnya untuk dikunjungi dapat mengambil

00:41.250 --> 00:43.590
banyak waktu jika kita melakukannya secara naif.

00:43.950 --> 00:46.010
Jadi maksud saya lakukan dua implementasi.

00:46.140 --> 00:47.610
Ini versi pertama.

00:47.650 --> 00:53.000
Say hit the next through pada slide saya. Inilah antrian prioritas sederhana kami.

00:53.520 --> 00:58.470
Dan kita akan mulai di sini agar kita tidak terlalu terganggu tetapi ini akan memberi

00:58.470 --> 01:01.820
kita simpul berikutnya untuk mengunjungi dan semua yang dilakukannya.

01:01.860 --> 01:02.920
Itu hanya sebuah array.

01:03.000 --> 01:09.150
Dan setiap kali Anda menambahkan sesuatu, Anda memberikan prioritas dan kemudian kami menyortir berdasarkan prioritas itulah yang terjadi

01:09.360 --> 01:10.200
di sini.

01:10.200 --> 01:15.530
Jadi setiap kali kita memasukkan kita resor dan kemudian kita hapus dari array.

01:15.630 --> 01:20.970
Jadi saya telah menyalinnya di sini untuk mengatakan Anda dapat melihatnya dan jika kami melakukan sesuatu seperti saya

01:21.000 --> 01:24.660
tidak tahu seberapa jauh Q sama dengan antrian prioritas baru seperti ini.

01:24.750 --> 01:30.550
Dan kemudian saya melakukan push up ketika saya mendorong atau sebenarnya secara teknis ini disebut dalam queue.

01:31.020 --> 01:37.710
Ketika kita memasukkan sesuatu katakanlah hanya simpul A atau jangan lakukan katakanlah B yang memiliki jarak dan

01:37.710 --> 01:39.110
Riskin katakanlah tiga.

01:39.120 --> 01:43.300
Saya tidak berpikir itu akurat itulah prioritas yang kami tambahkan.

01:43.530 --> 01:48.980
Dan sekarang kita juga dalam antrian C yang memiliki jarak 5.

01:49.290 --> 01:52.780
Mari kita lakukan D yang memiliki jarak 2.

01:53.190 --> 01:55.980
Dan kemudian saya juga tidak tahu.

01:55.980 --> 01:59.340
Q mengatakan jarak 20.

01:59.340 --> 02:06.510
Sekarang jika kita melihat nilai Q Dot Anda akan melihat bahwa itu diurutkan sekarang berdasarkan prioritas itu.

02:06.510 --> 02:09.820
Jadi setiap kali kita memasukkan sesuatu yang resor.

02:10.170 --> 02:18.740
Jadi jika saya memasukkan sesuatu lagi yang sangat kecil seperti di enqueue katakanlah P memiliki jarak 1. 5 itu akan melompat ke

02:19.110 --> 02:20.870
awal.

02:21.060 --> 02:23.440
Jika kita melihat nilai lagi.

02:23.690 --> 02:24.190
Kanan.

02:24.200 --> 02:30.600
Jadi setiap kali kita dequeue ini adalah dua metode yang akan kita gunakan sort digunakan secara internal dan Q

02:30.600 --> 02:31.380
dan dequeue.

02:31.490 --> 02:36.490
Ketika saya melakukan Q Ini akan memberi saya apa pun yang memiliki prioritas terendah.

02:36.620 --> 02:38.450
Kami ingin barang terkecil.

02:38.540 --> 02:44.920
Jadi apa yang akan kita lakukan dalam kode semu kita adalah hanya mendorong nilai-nilai ini seperti kembali ke sini.

02:45.250 --> 02:50.520
Tapi anggaplah mengabaikan fakta bahwa kami mengunjungi semua ini, katakanlah semua ini berada dalam antrian.

02:50.660 --> 02:55.570
Ketika kami bertanya kapan kami keluar, kami ingin apa pun yang memiliki jarak terkecil dari A.

02:55.580 --> 02:57.380
Itulah yang kami utamakan.

02:57.380 --> 02:59.060
Jadi antrian prioritas akan membantu kami.

02:59.180 --> 03:04.790
Dan ini bukan implementasi terbaik itu sederhana tetapi ingat kembali di bagian tumpukan biner jika Anda melihat

03:04.790 --> 03:10.180
bahwa ada cara yang lebih baik implementasi yang lebih cepat untuk antrian prioritas menggunakan tumpukan.

03:10.190 --> 03:15.500
Ini di sini karena kami menyortir setiap kali mati dan masuk.

03:15.500 --> 03:20.660
Yang tidak ideal tetapi sederhana sehingga kita akan dengan ini dan kemudian kita akan memperbarui kode kita untuk menggunakan

03:20.660 --> 03:22.050
tumpukan biner dan sedikit.

03:22.340 --> 03:22.790
BAIK.

03:22.970 --> 03:23.960
Jadi sekali lagi.

03:23.990 --> 03:27.830
Setiap kali saya dequeue itu mendapatkan apa pun prioritas terkecil saya saat ini.

03:27.950 --> 03:34.770
Tetapi jika saya memasukkan sesuatu yang lain lagi jika itu terkecil saya harus mendapatkan yang berikutnya.

03:34.790 --> 03:36.910
Jadi kita akan memanfaatkan ini dalam kode kita.

03:37.100 --> 03:37.620
BAIK.

03:37.970 --> 03:40.130
Jadi itulah prioritas dasar yang naif.

03:40.130 --> 03:46.030
T Tujuannya adalah untuk selalu mendapatkan nilai terkecil terlebih dahulu, apa pun yang ada di sana.

03:46.040 --> 03:47.790
Beri kami yang terkecil dulu.
