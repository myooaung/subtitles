WEBVTT

00:00.150 --> 00:03.580
Pendekatan lain yang akan kita diskusikan disebut daftar adjacency.

00:03.780 --> 00:06.120
Jadi saya benar-benar mengubah node ini.

00:06.120 --> 00:11.460
Putusan itu tampaknya berupa angka dan Anda akan melihat mengapa hanya dalam sedetik lebih mudah untuk menunjukkan bagaimana Anda bisa

00:11.460 --> 00:12.210
menyimpan ini.

00:12.240 --> 00:14.750
Jadi, bukannya A dan B C D.

00:14.760 --> 00:17.630
Jadi kita punya 0 1 2 3 4 5.

00:17.670 --> 00:22.360
Jadi cara kerjanya adalah kita menggunakan array atau daftar untuk menyimpan edge.

00:22.410 --> 00:29.220
Jadi jika kita ingin mencari tahu apa yang ada koneksi di antara 3 dan simpul lainnya,

00:29.220 --> 00:35.590
simpul lain kita akan mengindeks tiga array kita 0 1 2 3 di sini.

00:35.820 --> 00:39.100
Dan kemudian ada daftar di sana yang berisi koneksi itu.

00:39.090 --> 00:43.350
Jadi ada hubungan antara tiga dan dua dan tiga dan empat seperti yang Anda lihat di

00:43.350 --> 00:44.400
sini adalah ujung-ujungnya.

00:44.400 --> 00:48.380
Jika kita ingin tahu apakah ada batas antara 5 dan 1.

00:48.480 --> 00:52.640
Baik kita akan melihat indeks 1 dan melihat 4 atau 5.

00:52.650 --> 00:56.460
Itu tidak ada di sana atau kita akan melihat indeks 5 dan mencari satu.

00:56.460 --> 00:59.860
Itu juga tidak ada dan ini adalah grafik yang tidak terarah.

00:59.880 --> 01:02.520
Jadi kami memiliki semua hal yang tersimpan.

01:02.520 --> 01:05.880
Misalnya nol memiliki keunggulan satu.

01:05.880 --> 01:07.560
Seseorang memiliki keunggulan hingga nol.

01:07.560 --> 01:09.860
Jadi ini adalah cara lain untuk menyimpannya.

01:09.900 --> 01:16.100
Namun jika kita berbicara tentang surat, kita akan kembali ke sini di mana kita memiliki B C D E F dan

01:16.100 --> 01:17.030
surat-surat adalah arbitrer.

01:17.040 --> 01:22.080
Tapi katakanlah itu nama string atau sesuatu yang bukan hanya angka.

01:22.170 --> 01:22.350
Kanan.

01:22.350 --> 01:28.760
Yang ini bergantung pada penggunaan posisi array untuk menemukan koneksi tepi dari nol.

01:28.800 --> 01:31.560
Kami pergi ke nol ini dengan item dan itu berhasil.

01:31.560 --> 01:33.350
Tetapi bagaimana jika node kita bukan angka.

01:33.360 --> 01:35.140
Bagaimana jika mereka tidak berurutan seperti ini.

01:35.490 --> 01:39.120
Bagaimana jika kekuatan mereka adalah bagaimana jika ada kesenjangan besar di antara angka-angka.

01:39.220 --> 01:41.120
Jadi kami tidak ingin hanya menggunakan array.

01:41.160 --> 01:42.230
Apa lagi yang bisa kita lakukan.

01:42.540 --> 01:50.040
Kita bisa menggunakan tabel hash menggunakan struktur data pasangan nilai kunci sehingga kamus objek javascript

01:50.040 --> 01:50.640
peta.

01:50.730 --> 01:52.860
Ada banyak cara untuk melakukan ini tergantung pada bahasanya.

01:52.950 --> 01:59.940
Tapi di sini adalah informasi yang sama persis di mana kami menyimpan kunci yang diberikan, bukan kunci menjadi angka

01:59.940 --> 02:01.590
seperti nol dalam array.

02:01.590 --> 02:07.950
Sekarang dalam tabel hash atau peta hash untuk melihat koneksi tepi dari kita melihat bagian dalam struktur ini dan kemudian

02:07.950 --> 02:12.900
kita melihat daftar dan kita melihat di sana sesuatu dari a ke b dan TO F

02:12.900 --> 02:13.370
..

02:13.410 --> 02:16.830
Seperti yang dapat Anda lihat di sini a hingga b A hingga F. hal yang sama.

02:16.880 --> 02:17.700
Mari lakukan.

02:17.820 --> 02:22.340
Jadi kami akan meminta e dari peta hash ini dan kami mendapatkannya.

02:22.440 --> 02:25.890
Jadi itu memberitahu kita ada hubungan antara Ian D dan F ..

02:26.360 --> 02:26.820
BAIK.

02:27.000 --> 02:28.990
Jadi ini adalah daftar kedekatan.
