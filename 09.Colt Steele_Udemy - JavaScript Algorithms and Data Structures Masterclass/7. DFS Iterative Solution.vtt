WEBVTT

00:00.240 --> 00:01.010
Selamat datang kembali.

00:01.080 --> 00:03.450
Jadi kita akan menerapkan solusi berulang sekarang.

00:03.720 --> 00:08.020
Dan hal pertama yang perlu saya lakukan tentu saja mendefinisikan fungsi itu sendiri.

00:08.340 --> 00:18.080
Jadi apa yang saya sebut kedalaman ini adalah kedalaman rekursif pertama yang berulang Anda pasti bisa melakukan sesuatu yang lebih sederhana.

00:18.420 --> 00:18.880
BAIK.

00:19.080 --> 00:23.940
Jadi ia menerima simpul awal dan ada beberapa hal yang harus Anda hindari jika kita harus

00:23.940 --> 00:24.900
membuat tumpukan kami.

00:25.020 --> 00:32.280
Kita harus membuat hasil kita benar dan daftar yang kita kunjungi atau bukan objek daftar sehingga mengunjungi kita sebenarnya

00:32.280 --> 00:35.640
bisa menyalin ini dari hasil murni dan dikunjungi.

00:36.660 --> 00:38.600
Tapi saya juga perlu membuat stack.

00:38.770 --> 00:46.600
Saya mengatakan stack ini akan menjadi mari kita sebut stack array juga, tetapi kita perlu memulai di sana.

00:46.620 --> 00:51.300
Ingat baris ini di sini di titik awal ke tumpukan dan pasar dikunjungi

00:51.300 --> 00:55.770
dengan baik dan akan melakukan ini daripada mendorongnya, hanya menginisialisasi di sana.

00:55.770 --> 00:58.230
Kemudian setelah itu kita perlu memasarkan sesuai kunjungan.

00:58.260 --> 01:03.280
Mari kita pastikan kita melakukan yang lain membuat fungsi saya membuat tumpukan membuat daftar di luar.

01:03.290 --> 01:03.800
Ya.

01:03.930 --> 01:04.670
Ini semua baik.

01:04.770 --> 01:10.240
Kami perlu menambahkan pusaran awal yang kami lakukan dengan pemasaran yang dikunjungi dan kemudian kami akan menambahkan lingkaran kami.

01:10.380 --> 01:16.260
Jadi saya akan pergi ke set yang dikunjungi membuat ini hanya sebuah baris terpisah sehingga kita bisa

01:16.880 --> 01:21.600
melihat ini adalah variabel kami deklarasi kami dikunjungi mulai sama dengan benar.

01:21.870 --> 01:26.040
Sekali lagi Anda bisa menggunakan array untuk mengelola apa yang telah dikunjungi dan menutup ini.

01:26.040 --> 01:30.640
Ngomong-ngomong, tapi saya suka melakukannya dengan objek ini hanya saja lebih eksplisit.

01:30.900 --> 01:31.460
BAIK.

01:31.710 --> 01:33.090
Sekarang kita perlu melakukan Wildblue kita.

01:33.180 --> 01:37.380
Jadi, sementara ada sesuatu di tumpukan kami, jadi saya hanya akan melakukan sementara tumpukan panjang.

01:37.470 --> 01:42.720
Anda bisa melakukan lebih besar dari nol tetapi panjangnya ditumpuk itu mudah karena begitu kita mencapai nol kita

01:42.990 --> 01:44.320
selesai itu akan salah.

01:44.700 --> 01:50.430
Sementara stack memiliki sesuatu di dalamnya pop vertex berikutnya dari stack jika vertex itu belum

01:50.430 --> 01:52.820
dikunjungi belum ditandai sebagai dikunjungi.

01:52.950 --> 01:54.670
Jadi mari kita mulai dengan itu.

01:54.780 --> 02:00.840
Saya akan membuat variabel pertama untuk menyimpan apa yang kami popping jadi saya hanya akan menyebutnya saya

02:00.840 --> 02:05.990
tidak tahu titik saat ini sama dengan ditumpuk di bagian atas begitu saja.

02:06.090 --> 02:10.360
Maka kita harus benar-benar menambahkan simpul saat ini ke array hasil kami.

02:10.370 --> 02:13.140
Jadi akibat dari push vertex saat ini.

02:13.170 --> 02:15.410
Jadi itulah yang akan kami kembalikan di bagian paling akhir.

02:15.990 --> 02:19.190
Dan kemudian kita akan pergi ke masing-masing tetangganya.

02:19.740 --> 02:25.200
Dan sebelum saya melakukan itu daripada mendefinisikan ulang vertex saat ini setiap kali melalui dalam loop ini saya

02:25.200 --> 02:30.470
akan datang ke sini hanya untuk membiarkan vertex saat ini dan kemudian di sini memberikan nilai.

02:30.840 --> 02:37.380
Hal kecil tapi saya tidak suka Anda tahu terus-menerus menginisialisasi ulang simpul saat ini dalam satu lingkaran.

02:37.380 --> 02:41.350
Sekarang kita perlu menambahkan masing-masing tetangganya ke stack.

02:41.440 --> 02:47.730
Nah jika mereka belum dikunjungi dan mari kita mulai dengan mengakses tetangga sehingga daftar

02:47.730 --> 02:50.030
titik simpul saat ini.

02:50.190 --> 02:56.410
Jadi itu akan memberi kita jika kita berbicara tentang itu akan memberi kita sebuah array yang berisi B dan C ..

02:57.110 --> 02:57.460
BAIK.

02:57.480 --> 03:02.780
Jadi ini mulai Jason daftar data vertex saat ini untuk setiap jenis garis panjang.

03:02.970 --> 03:05.430
Saya akan menyebutnya tetangga bisa menyebutnya.

03:05.430 --> 03:07.850
Saya tidak tahu hubungannya sekarang.

03:08.670 --> 03:09.690
Saya tidak akan menyebutnya teman.

03:09.690 --> 03:10.590
Mungkin tidak.

03:10.590 --> 03:11.710
Jadi apa yang kita lakukan.

03:12.000 --> 03:15.160
Nah kalau belum dikunjungi.

03:15.330 --> 03:18.930
Jadi jika di dalam berkunjung tidak ada apa-apa bagi tetangga.

03:19.260 --> 03:26.280
Jika itu masalahnya kita perlu memastikan bahwa itu telah dikunjungi.

03:26.510 --> 03:35.960
OK jadi kita akan mengunjungi tetangga dan kemudian kita akan mengaturnya untuk dikunjungi kemudian susun push naver begitu

03:35.960 --> 03:36.790
saja.

03:37.250 --> 03:37.890
BAIK.

03:38.180 --> 03:40.030
Dan pada dasarnya kita sudah selesai.

03:40.130 --> 03:45.330
Kami hanya harus pada akhirnya mengembalikan hasil yang benar.

03:46.370 --> 03:53.930
Dan ketika kita akan melalui ini bagaimana kalau di sini karena log stack sehingga kita dapat melihat apa yang

03:53.930 --> 03:54.960
kita kerjakan.

03:55.270 --> 03:55.960
BAIK.

03:56.720 --> 04:00.250
Jadi untuk mengeksekusi kode kita dan disebut G.

04:00.470 --> 04:02.740
Kedalaman iteratif pertama dengan a.

04:03.380 --> 04:05.140
Dan apa yang kita dapat.

04:05.150 --> 04:06.770
Saya bisa membuat ini lebih besar.

04:07.270 --> 04:07.860
BAIK.

04:08.090 --> 04:10.980
Jadi pertama-tama pesanan yang kita dapatkan berbeda.

04:11.090 --> 04:14.710
Dan kita dapat berbicara tentang angin sedikit tetapi masih dalam dulu.

04:14.780 --> 04:17.950
Jika Anda tidak ingat izinkan saya melakukan hal yang sama untuk rekursif.

04:18.170 --> 04:19.340
Kami mendapat nilai B.

04:19.400 --> 04:20.660
ECF.

04:20.660 --> 04:27.760
Jadi versi rekursif adalah B D E C F yang masih mendalam dulu.

04:27.890 --> 04:34.790
Versi iteratif alih-alih pergi a dan kemudian B kita benar-benar berakhir menjadi a dan kemudian C tetapi selama kita mengikuti

04:34.790 --> 04:39.650
jalan ini ke bawah dan mengikuti salah satu tetangga C dan tetangga dan tetangganya

04:39.810 --> 04:41.240
itu masih mendalam pertama.

04:41.240 --> 04:45.850
Hanya saja kita mulai dengan C daripada B karena cara kode kita bekerja dan Anda akan melihat alasannya.

04:46.010 --> 04:49.250
Jadi lihat di mana kita pergi untuk melihat Tetangga.

04:49.250 --> 04:50.090
Kami sudah pernah ke.

04:50.110 --> 04:54.140
Jadi jika kita pergi makan maka dari itu kita punya tiga pilihan.

04:54.140 --> 04:55.180
Kami sudah pernah melihat.

04:55.250 --> 05:01.100
Jadi kita punya D atau kita punya F dan kode kita pergi ke F berikutnya dan kemudian f kita bisa pergi ke E.

05:01.130 --> 05:01.910
Kami sudah pernah ke sana.

05:01.910 --> 05:03.200
Jadi kita pergi ke D.

05:03.390 --> 05:06.090
Dan kemudian dari D E F atau B.

05:06.140 --> 05:06.980
Kita sudah melakukan ini.

05:06.980 --> 05:07.780
Kami sudah melakukan ini.

05:07.880 --> 05:13.960
Jadi jika kita pergi ke B tetapi masih dalam dulu kita pergi ke sini di sini di sini di sini di sini.

05:14.120 --> 05:15.140
Jadi pikirkan seperti ini.

05:15.170 --> 05:16.760
Ini adalah daftar kedekatan kami.

05:16.760 --> 05:18.760
Sama untuk kedua versi.

05:19.040 --> 05:22.130
Apa yang kami lakukan dalam versi rekursif kami mulai dengan cara itu.

05:22.460 --> 05:28.340
Kami pergi untuk menjadi abjad pertama atau apa pun yang pertama dalam daftar kedekatan ini dikunjungi terlebih dahulu.

05:28.340 --> 05:37.840
Jadi a to b versus dalam versi iteratif kami pergi ke a ke c dan kemudian dari C kita melihat c kita pergi ke E

05:38.090 --> 05:39.360
dan dari E.

05:39.560 --> 05:42.080
Anda sudah pernah ke C dan kami pergi ke F ..

05:42.080 --> 05:46.320
Kami mengambil apa pun yang ada di akhir di mana kami bekerja dari arah ini.

05:46.400 --> 05:51.040
Jika itu masuk akal dari akhir daftar adjacency daripada dari awal.

05:51.290 --> 05:53.450
Jadi sekarang mari kita telusuri mengapa ini bekerja.

05:53.450 --> 05:57.830
Biarkan saya menghapus ini dan mari kita lakukan iteratif a.

05:57.890 --> 05:59.420
Seperti inilah tumpukan kita.

05:59.450 --> 06:01.280
Pertama kali melalui kami memiliki.

06:01.640 --> 06:02.130
BAIK.

06:02.390 --> 06:09.200
Jadi kami mengunjungi sedikit naik melalui kode kami sedikit lebih kita akan mengunjunginya menambahkannya ke hasilnya.

06:09.200 --> 06:15.740
Jadi hasil kami sekarang berisi satu untuk setiap tetangga di mana kita harus b dan c kita tambahkan keduanya dan

06:15.740 --> 06:17.420
kita muncul dan menjadi kosong.

06:17.510 --> 06:19.520
Dan kami menambahkan B dan C.

06:19.910 --> 06:25.100
Jadi apa yang akan kita lakukan adalah mengunjungi C karena kita mengakhiri akhirnya.

06:25.130 --> 06:26.930
Jadi kita akan lihat selanjutnya.

06:27.230 --> 06:29.680
Dan kemudian kita akan menambahkannya ke hasilnya.

06:29.780 --> 06:35.180
Jadi hasil kami terlihat seperti C dan kemudian kami pergi ke tetangga C dan kami mendorong mereka masuk

06:35.240 --> 06:39.890
Jadi kami berakhir dengan B dan B karena kami sudah mengunjungi dan tidak menambahkannya.

06:40.250 --> 06:43.350
Jadi selanjutnya kita buang tumpukan kita pergi ke E.

06:43.730 --> 06:46.010
Jadi kami mengunjungi e c.

06:46.070 --> 06:46.610
BAIK.

06:46.730 --> 06:49.590
Jadi Anda bisa melihat bahwa B hanya dengan sabar menunggu di sini.

06:49.790 --> 06:56.270
Ini jika kita melakukan luas pertama kita akan segera pergi ke c dan kemudian kembali ke B tetapi kedalamannya terlebih dahulu.

06:56.270 --> 06:57.860
Begitu miskin b sedang menunggu.

06:58.040 --> 07:03.470
Atau dalam versi rekursif kita pergi ke a dan kemudian C sedang menunggu.

07:03.590 --> 07:10.850
Jadi kita terus berjalan dan Anda dapat melihat bahwa kita berakhir dengan anak-anak atau tetangga F dan D keduanya ditambahkan

07:10.850 --> 07:13.800
dan D adalah pertama dan kemudian F ..

07:13.820 --> 07:15.610
Tapi kami mengakhiri.

07:15.650 --> 07:20.600
Jadi kita mengunjungi f berikutnya dan kemudian dari f kita tidak punya apa-apa untuk ditambahkan karena kita sudah

07:20.600 --> 07:22.120
pernah ke E dan D.

07:22.370 --> 07:28.100
Yah kami belum pernah ke D tetapi kami sudah menambahkannya ke tumpukan kami dan kami sudah mengunjunginya berarti

07:28.280 --> 07:30.760
kami telah mengatakan itu untuk dikunjungi benar.

07:31.030 --> 07:33.480
Kalau tidak, Anda akan terdorong ke sana lagi.

07:33.890 --> 07:35.690
OK jadi kita mati.

07:35.720 --> 07:36.770
Sekarang kita memiliki B dan D.

07:36.920 --> 07:37.860
Kita mulai dengan D.

07:37.880 --> 07:42.630
Lepaskan ujungnya dan akhirnya kita menjadi yang terakhir ditambahkan.

07:43.040 --> 07:49.040
Jadi kami menggunakan susunan array untuk melacak di mana kita harus kembali.

07:49.100 --> 07:49.670
Kanan.

07:49.670 --> 07:56.670
Kita akan ke sini, kita tahu kita perlu mengunjungi B di beberapa titik tetapi kita mulai dengan C dan kemudian dari C kita pergi

07:56.690 --> 07:59.430
makan dan di B kita akan pergi ke f.

07:59.450 --> 08:01.440
Tapi kita juga harus ingat untuk pergi ke D.

08:01.550 --> 08:05.230
Jadi kami menambahkan D juga, tetapi b miskin telah menunggu selama ini.

08:05.240 --> 08:06.650
Ini mendalam dulu.

08:07.040 --> 08:12.990
Jadi saya pikir untuk beberapa orang, saya pikir versi iteratif lebih mudah untuk dipahami, tetapi

08:12.990 --> 08:17.570
saya pikir versi rekursif penting untuk memahami mengapa ia bekerja.

08:17.570 --> 08:21.030
Ini adalah kasus penggunaan klasik untuk rekursi graft versal.

08:21.260 --> 08:26.810
Dan saya pikir jika Anda bisa mendapatkan salah satu dari ini jika Anda dapat memahami berjalan melalui itu Anda baik.

08:27.140 --> 08:28.470
Jadi ini adalah versi yang berulang.

08:28.490 --> 08:30.140
Kami melihat versi rekursif.

08:30.140 --> 08:31.360
Keduanya mendalam terlebih dahulu.

08:31.370 --> 08:33.170
Kami mendapatkan urutan yang sedikit berbeda.

08:33.200 --> 08:37.430
Tidak ada satu pun urutan kedalaman tepat yang tepat untuk setiap grafik yang diberikan.

08:37.550 --> 08:40.430
Jadi ada pesanan yang berbeda tetapi mereka lebih dulu.

08:40.430 --> 08:40.920
BAIK.

08:41.090 --> 08:43.040
Selanjutnya luasnya dulu.

08:43.040 --> 08:44.240
Kita semua kehilangan satu solusi.
