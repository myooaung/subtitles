WEBVTT

00:00.090 --> 00:00.470
Baiklah.

00:00.470 --> 00:01.200
Kembali.

00:01.200 --> 00:03.310
Sekarang mari kita menulis kode untuk membuat ini berfungsi.

00:03.330 --> 00:05.350
Untuk menggabungkan dua array yang diurutkan.

00:05.400 --> 00:11.070
Jadi, jika Anda melompat ke video ini karena Anda melihat implementasi dalam judul, saya sarankan Anda kembali saja

00:11.070 --> 00:14.400
dan melihat kode pseudo kasar bagaimana itu seharusnya bekerja.

00:14.400 --> 00:16.700
Supaya Anda mengerti apa yang kami lakukan di sini.

00:16.740 --> 00:19.470
Jadi di sini saya akan mulai dengan mendefinisikan cuplikan.

00:19.470 --> 00:24.140
Seperti biasa saya akan menyebutnya menggabungkan fungsi saya dan itu akan menjadi array.

00:24.180 --> 00:27.470
Mari kita lakukan r r satu dan r r untuk.

00:27.930 --> 00:33.340
Dan kemudian di sini hal pertama yang harus kita buat hanyalah membuat variabel yang disebut

00:36.480 --> 00:41.500
array kosong hasil dan kemudian pada akhirnya kita mengembalikan hasil seperti itu.

00:41.790 --> 00:43.490
Dan kemudian kita perlu melakukan semua logika kita.

00:43.590 --> 00:48.660
Jadi hal pertama yang akan kita lakukan adalah membuat dua pointer kecil kita akan mulai dengan nol variabel dan

00:48.750 --> 00:49.820
satu lagi di nol.

00:49.830 --> 00:57.000
Masing-masing untuk masing-masing untuk array besar dan kemudian mereka akan bergerak secara individual sehingga kami akan membiarkan saya sama dengan nol

00:57.000 --> 01:03.530
tetapi J sama dengan nol atau apa pun yang Anda bisa menyebutnya indeks r r 1 atau sesuatu.

01:03.540 --> 01:05.110
Aku hanya akan pergi dengan aku.

01:05.640 --> 01:05.950
BAIK.

01:05.970 --> 01:12.930
Sekarang bola CoreLogic ketika Anda memiliki loop sementara yang berjalan sementara saya kurang dari panjang array dan J kurang dari

01:12.930 --> 01:18.150
panjang pada dasarnya berarti sementara masih ada data untuk kita lihat di kedua jika

01:18.390 --> 01:21.060
kita mencapai akhir salah satu diantara mereka.

01:21.090 --> 01:26.080
Ingat dalam video terakhir yang saya perlihatkan ketika kami mulai di sini daripada kami mencapai akhir 50 dan

01:26.080 --> 01:27.520
masih ada data di sini.

01:27.570 --> 01:32.850
Kita akan melakukan sesuatu yang lain untuk loop pertama ini hanya berlaku ketika kita melakukan looping pada keduanya pada

01:32.850 --> 01:33.780
saat yang sama.

01:33.780 --> 01:45.750
Jadi sementara saya kurang dari 1 panjang dan J kurang dari $ 2 seperti sempurna sekarang kita hanya melakukan

01:45.780 --> 01:51.620
perbandingan sederhana dua J dan array satu dari I.

01:51.780 --> 01:53.750
Jadi terserah kita mana yang harus kita lakukan terlebih dahulu.

01:53.760 --> 01:58.020
Saya akan mengatakan jika dua J lebih besar dari array yang saya berikan satu.

01:58.200 --> 02:02.400
Sangat membingungkan untuk mencoba membicarakan apakah ini hasil kami, kami pada dasarnya memeriksa apakah ini

02:02.400 --> 02:03.540
lebih besar dari ini.

02:03.540 --> 02:04.290
Apa yang kita lakukan.

02:04.350 --> 02:06.930
Kami mengambil ini dan kami memasukkannya ke dalam hasil.

02:07.080 --> 02:13.770
Jadi jika itu masalahnya kita akan mengatakan hasil jangan push array.

02:14.490 --> 02:15.540
Oh dan aku mengatakan itu ke belakang.

02:15.540 --> 02:19.560
Maaf jika ini lebih besar dari ini.

02:19.650 --> 02:22.140
Lalu kami mengambil yang lebih kecil dan menaruhnya di sana.

02:22.140 --> 02:25.490
Saya tidak mengerti mengapa kami tidak mencoba melakukan pemesanan.

02:25.500 --> 02:27.560
Kami ingin barang terkecil terlebih dahulu.

02:27.570 --> 02:28.230
Baiklah.

02:28.230 --> 02:34.650
Jadi kita akan mendorong array salah satu dari saya jika jika lebih kecil jika array satu adalah hal terkecil.

02:34.650 --> 02:41.790
Dan jika itu masalahnya jika kita benar-benar mendorong array 1 maka kita perlu memindahkan I itu tidak lagi menjadi

02:41.790 --> 02:42.260
nol.

02:42.270 --> 02:47.770
Kita perlu naik 1 dan itu sangat mudah bagi kita.

02:48.500 --> 02:49.080
BAIK.

02:49.110 --> 02:54.200
Sekarang kita memiliki yang lain yang banyak kali.

02:54.350 --> 02:55.640
Saya kira kita belum membahas kasus tepi.

02:55.650 --> 02:57.110
Jika itu nilainya sama.

02:57.510 --> 03:03.840
Jadi alih-alih melakukan yang lain jika array 2 kurang dari 1 karena jika kita hanya menambahkan lebih dari dan

03:03.850 --> 03:06.840
kurang dari kita kita akan kehilangan kasus kesetaraan.

03:06.840 --> 03:11.640
Tapi kita bisa memilih satu yang bisa kita lakukan lebih besar dari atau sama dengan dua yang lain

03:11.640 --> 03:18.120
atau melakukan lebih besar lalu dan kemudian memiliki yang lain yang akan bergerak yang akan menangkap kasus ketika mereka sama dan ketika array satu lebih besar.

03:18.460 --> 03:20.160
OK jadi jika itu kalau itu masalahnya.

03:20.160 --> 03:24.940
Kalau tidak, kita lakukan hasil mendorong dua dari J.

03:25.200 --> 03:28.360
Dan kemudian kita menambah J dengan 1 karena sekarang kita bergerak ke atas.

03:28.380 --> 03:31.700
Jadi itu akan menjadi Apakah kita memiliki salju itu pertama kali lewat.

03:31.800 --> 03:34.560
Kami menempatkan satu di sini dan kemudian kami melihat sepuluh menjadi dua.

03:34.560 --> 03:34.920
Iya nih.

03:34.920 --> 03:37.140
Sekarang dua lebih kecil.

03:37.140 --> 03:40.640
Jadi dalam hal ini kita menambahkan dua di mana dari array J.

03:40.810 --> 03:44.740
Tapi kemudian kita menambah J dengan 1 dan kita pergi ke sini.

03:44.980 --> 03:46.440
Array dua yang saya maksud.

03:46.440 --> 03:47.160
Baiklah.

03:47.430 --> 03:53.120
Jadi jika kita melihat apa yang sebenarnya terjadi pada akhir dari loop ini, mari kita cetak ini.

03:53.340 --> 03:54.600
Kita akan mengembalikan hasilnya.

03:54.600 --> 03:56.240
Kami sebenarnya tidak perlu mencetaknya.

03:56.250 --> 03:58.580
Itu tidak lengkap tetapi sampai di sana.

03:58.590 --> 04:07.470
Jadi kita berakhir dengan 1 hingga 10 14 dan 50 karena yang terjadi adalah kita melakukan ini dan ini kita lakukan 10 14 melakukan 50 dan kemudian kita mencapai

04:07.470 --> 04:11.280
akhir karena kita melakukan 50 dan kemudian kita menambahkan 1 ke i.

04:11.640 --> 04:14.670
Dan kita mencapai akhir array sehingga loop ini pecah.

04:14.670 --> 04:16.050
Kita selesai.

04:16.050 --> 04:20.820
Jadi apa yang perlu terjadi setelah kita menghabiskan salah satu dari mereka karena ingat kondisi

04:20.820 --> 04:25.810
kita sementara aku kurang dari satu re. Panjang 0 NJ kurang dari panjang baku tembak.

04:26.250 --> 04:31.680
Setelah kita mencapai akhir kita kemudian hanya mengambil semua yang tersisa di J ditambahkan atau jika J.

04:31.710 --> 04:37.630
Jika ini lebih pendek seperti di sini jika kita mencapai akhir kita kemudian mengambil apa pun yang tersisa di array pertama

04:37.630 --> 04:38.450
dan menambahkan.

04:38.850 --> 04:40.330
Jadi itu mudah juga.

04:40.410 --> 04:48.150
Saya hanya akan melakukan dua loop dengan baik dan saya akan memiliki waktu sementara saya kurang dari satu panjang.

04:48.810 --> 04:49.710
Apa yang akan kita lakukan.

04:49.710 --> 04:56.150
Hasil push array salah satu dari saya dan kemudian hanya menambahkan 1 ke i.

04:56.310 --> 04:58.910
Jadi pada dasarnya logika yang sama ada di sini.

04:59.370 --> 05:04.230
Hanya saja kita tidak melakukan pemeriksaan bersyarat lagi dan saya

05:04.230 --> 05:12.090
akan menduplikasi ini tapi kemudian ganti saya dengan J satu array dengan hak untuk itu masuk akal.

05:12.130 --> 05:18.450
Jadi, apa pun yang terjadi pada akhirnya kita gabungkan mereka sejauh yang kita bisa sampai kita mencapai ujung salah satu array.

05:18.610 --> 05:23.920
Jadi katakanlah kita mencapai akhir array yang berarti menetapkan nilai yang masih memiliki barang di dalamnya.

05:23.920 --> 05:27.880
Jadi Jay belum mencapai akhir sehingga Jay akan kurang dari dua dolar panjangnya.

05:27.880 --> 05:34.340
Dalam kasus kami, jika kami pada akhir tahun 1 2 3 kami mendapatkan satu hingga 10 14 50.

05:34.480 --> 05:39.820
Itu berarti bahwa Jay saat ini merupakan indeks dari apa yang ada di 0 1 2.

05:40.300 --> 05:43.380
Jadi kita harus menambahkan ini dan kita harus menambahkan ini.

05:43.540 --> 05:45.300
Dan kemudian Jay akan mencapai akhirnya.

05:45.550 --> 05:51.670
Jay akan sama dengan laju panjang pada titik itu dan kemudian kita selesai dan kita mengembalikan hasilnya.

05:51.820 --> 05:57.190
Mari kita lihat apakah itu berfungsi, itu terlihat bagus jika kita mencoba sesuatu yang sneakier seperti

05:57.190 --> 06:02.920
array kosong dan kemudian array satu kolom dengan tiga masih berfungsi karena loop ini tidak pernah berjalan dengan benar.

06:02.920 --> 06:05.440
Yang terjadi adalah kita memiliki dua array.

06:05.470 --> 06:10.960
Jadi Jay kurang atau aman untuk mengatakan bahwa kita hanya mendorong semua hasil atau semua item

06:10.960 --> 06:20.410
dalam array 2 ke dalam hasil dan kemudian mengembalikannya jika kita mencoba melakukan sesuatu seperti 100 dan kemudian di sini saya tidak tahu saya tidak Bahkan benar-benar

06:20.410 --> 06:25.230
memiliki sesuatu yang layak ditampilkan pada titik ini yang tidak berfungsi perlu disortir.

06:25.240 --> 06:28.900
Yang ingin saya tunjukkan adalah bahwa itu berfungsi dan tidak apa-apa.

06:28.930 --> 06:31.790
Jadi ini adalah bagian pertama dari semacam penggabungan.

06:31.840 --> 06:32.830
Ini bagian terpanjang.

06:32.830 --> 06:37.330
Sebenarnya jika Anda menemukan sesuatu yang lebih baik pasti membaginya dalam komentar di papan diskusi tetapi

06:37.330 --> 06:39.940
ini adalah cara yang cukup sederhana untuk melakukannya.

06:40.240 --> 06:44.030
Dan saya pikir itu terbaca cukup mudah dimengerti dan berjalan melalui.

06:44.230 --> 06:49.810
Jadi kita akan menggunakan kode ini dalam video berikutnya di mana kita menambahkan dan benar-benar menerapkan semacam penggabungan.

06:49.810 --> 06:53.080
Sekarang ini hanya berfungsi dengan dua array yang diurutkan.

06:53.530 --> 06:54.090
BAIK.

06:54.340 --> 06:54.800
Lihat itu.
