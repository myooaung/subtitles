WEBVTT

00:00.180 --> 00:00.660
Baiklah.

00:00.660 --> 00:03.880
Jadi mari kita terapkan kunci dan nilai metode kita.

00:04.050 --> 00:09.870
Saya akan mulai dengan nilai sebenarnya karena di situlah kita benar-benar harus khawatir tentang data

00:09.870 --> 00:10.390
duplikat.

00:10.590 --> 00:16.920
Jadi mari kita mulai dari sana dan yang perlu kita lakukan adalah membuat array untuk menyimpan semua data kita.

00:16.920 --> 00:21.680
Jadi saya akan menyebutnya nilai r r r seperti itu.

00:21.900 --> 00:26.270
Dan kemudian kita perlu mengulang seluruh kunci peta peta kunci ini.

00:26.610 --> 00:31.940
Jadi mari kita tulis a for loop untuk sama dengan nol.

00:31.950 --> 00:38.070
Oh, aku benci mengetik ini ketika saya tidak menggunakan editor biasa ini peta kunci.

00:38.070 --> 00:41.840
Dan kami ingin pergi Lanc lalu aku.

00:41.850 --> 00:42.630
Plus plus.

00:42.630 --> 00:47.140
Jadi ini hanya akan mengulang seluruh peta kunci seperti executer ini.

00:47.220 --> 00:48.330
Saya belum menjalankannya.

00:48.360 --> 00:52.390
Jika kita melihat H. T. di sini kita akan mengulang semua 17 item di sini.

00:52.670 --> 00:55.030
Dan hal pertama yang akan kita periksa adalah ada sesuatu di sana.

00:55.080 --> 01:06.070
Jadi jika ini peta kunci I jika itu masalahnya maka mari kita mulai dengan terus-menerus mencatat peta kunci ini.

01:06.720 --> 01:10.000
Dan jika saya menjalankan ini dan kemudian saya lakukan H. T. nilai-nilai.

01:10.500 --> 01:15.690
Ini mencetak semua array yang memiliki barang-barang itu melompati semua yang kosong karena kami

01:15.690 --> 01:21.990
sedang bekerja dengan sesuatu yang memiliki 17 slot dan kami hanya menggunakan lima dari enam slot yang berbeda.

01:22.020 --> 01:25.020
Jadi ada 11 hal kosong yang tidak kami cetak.

01:25.140 --> 01:26.560
Jadi itu bagus.

01:26.580 --> 01:33.480
Jadi yang ingin kita lakukan adalah memutar di atas peta kunci I ini karena kita sekarang perlu mengulanginya dan mengumpulkan

01:33.510 --> 01:36.840
semua nilai dan mendorongnya ke dalam array nilai kita.

01:36.840 --> 01:40.770
Jadi kita perlu membahas masing-masing dan menemukan item ini.

01:40.770 --> 01:42.060
Bagian kedua.

01:42.060 --> 01:43.020
Jadi ini adalah indeks 0.

01:43.020 --> 01:45.460
Ini adalah indeks Indeks 1.

01:45.540 --> 01:46.090
BAIK.

01:46.470 --> 01:48.190
Jadi mari kita lakukan yang lain untuk loop.

01:48.330 --> 01:54.640
Kali ini akan lakukan, sebut saja J4, biarkan J sama dengan 0.

01:54.750 --> 02:01.260
J kurang dari peta kunci ini yang saya dapatkan panjangnya.

02:01.480 --> 02:06.610
Jadi peta kunci I ini merujuk ke setiap array sel pada indeks itu.

02:07.460 --> 02:08.710
J plus plus.

02:08.900 --> 02:09.200
BAIK.

02:09.210 --> 02:12.790
Jadi untuk setiap item di sana sekarang apa.

02:12.930 --> 02:16.020
Yang perlu kita lakukan adalah nilai array push.

02:16.080 --> 02:17.730
Dan kami hanya ingin mendorong nilainya.

02:17.880 --> 02:25.600
Jadi, inilah peta kunci I of J yang memberikan semuanya.

02:25.590 --> 02:33.260
Jadi jika saya melakukan ini dan saya menjalankan nilai ini dengan tidak mengembalikan apa pun jadi itu tidak berguna.

02:33.420 --> 02:35.490
Itu adalah contoh yang sangat bodoh.

02:35.490 --> 02:37.340
Biarkan saya menambahkan kembali ke bagian paling akhir.

02:37.460 --> 02:38.450
Ayo turun.

02:38.520 --> 02:39.220
Kata-kata itu benar.

02:39.220 --> 02:42.120
Bracket, mari kita lakukan mengembalikan array nilai.

02:42.390 --> 02:45.990
OK jalankan kembali nilai-nilai usia kode.

02:46.700 --> 02:51.620
Jika kita melihatnya, kita masih mengembalikan array yang berisi kunci dan nilainya.

02:51.750 --> 02:56.010
Jadi kami hanya ingin indeks 1 untuk masing-masing item tersebut.

02:56.070 --> 02:59.960
Dan jika saya jalankan lagi kan H. T. nilai.

03:00.210 --> 03:02.280
Kami sekarang mendapatkan semua nilai.

03:02.490 --> 03:03.870
Jadi jika Anda menyebutnya sehari di sini.

03:03.990 --> 03:06.910
Tapi kemudian ada juga masalah data duplikat ini.

03:06.960 --> 03:12.030
Dan seperti yang saya katakan cara banyak bahasa menanganinya adalah ketika Anda melakukan nilai titik atau apa

03:12.030 --> 03:14.790
pun yang setara, Anda hanya mendapatkan nilai unik.

03:15.120 --> 03:16.120
Kamu sering tidak.

03:16.260 --> 03:20.500
Anda tidak mendapatkan semua duplikat karena biasanya tidak ada pesanan yang dijamin.

03:20.550 --> 03:22.910
Dan itu bisa membingungkan jika Anda memiliki data duplikat.

03:22.920 --> 03:24.660
Biasanya itu hanya unik.

03:24.690 --> 03:26.420
Jadi bagaimana kita menerapkannya.

03:26.700 --> 03:32.380
Nah cara paling sederhana adalah sebelum kita mendorongnya ke dalam array nilai yang baru saja kita periksa.

03:32.430 --> 03:37.660
Apakah peta kunci ini sudah atau apakah array nilai sudah termasuk item ini.

03:37.860 --> 03:40.350
Pertama mari kita ambil beberapa data duplikat di sana

03:40.590 --> 03:46.730
Jadi saya akan menambahkan ungu dengan DD ini 0 0 DD.

03:46.950 --> 03:52.060
Dan mari kita tambahkan sesuatu yang disebut Violet seperti ini.

03:52.060 --> 03:59.380
Jadi jika saya jalankan kembali ini dan kami melihat nilai-nilai kami, Anda dapat melihat bahwa kami memiliki apa itu DDA 0.

03:59.400 --> 04:02.590
DD ada di sana satu kali dua kali tiga kali.

04:02.730 --> 04:09.450
Jadi untuk mencegah hal itu kita akan datang ke sini dan sebelum kita mendorong mari kita tambahkan sebuah kondisional kita akan

04:09.450 --> 04:13.900
mengatakan jika array nilai yang termasuk Dan kita akan menggunakan metode menyertakan built-in.

04:14.110 --> 04:22.110
Peta kunci ini, ini artinya ini adalah nilai itu sendiri.

04:22.110 --> 04:23.250
Jadi setiap kali lewat.

04:23.340 --> 04:26.400
Nah periksa apakah sudah termasuk DDA 0.

04:26.410 --> 04:30.690
DD kode warna ini bukan hal yang paling intuitif bagi saya

04:30.690 --> 04:38.250
untuk dibicarakan tetapi jika ini termasuk ini kami tidak ingin mendorong jadi mari kita lakukan sebaliknya katakan jika tidak jika tidak

04:38.250 --> 04:41.460
termasuk maka kami akan mendorong ini seperti .

04:41.760 --> 04:43.530
Dan mari kita coba sekarang.

04:43.560 --> 04:45.490
Jadi saya menggunakan metode menyertakan bawaan.

04:45.600 --> 04:48.170
Jadi jika kita coba H. T. nilai titik.

04:48.180 --> 04:54.110
Sekarang kita hanya mendapatkan satu dari Deedy ini nol d d.

04:54.320 --> 04:59.460
Baiklah jadi itu salah satu cara penanganan tangan nilai duplikat sehingga kita hanya berakhir dengan nilai unik

04:59.520 --> 05:01.490
dalam dataset kami yang kami kembalikan.

05:01.800 --> 05:03.160
Lalu kami mengembalikannya di akhir.

05:03.240 --> 05:05.540
Kami hanya memeriksa setiap waktu untuk setiap nilai.

05:05.550 --> 05:09.180
Apakah itu sudah termasuk nilai itu jika tidak mendorongnya.

05:09.180 --> 05:13.060
Jadi kita bisa menduplikasi hal yang persis sama dan melakukan ini.

05:13.570 --> 05:19.290
Jadi ubah nama ini menjadi anak-anak dan kami akan memanggil deretan anak ini meskipun sebenarnya tidak

05:19.290 --> 05:20.250
ada bedanya.

05:20.340 --> 05:23.490
Secara fungsional ini akan sama.

05:23.610 --> 05:28.150
Ini sama ini di sini juga sama.

05:28.220 --> 05:35.300
Tapi kemudian ini berubah jadi ini akan menjadi nilai anak-anak adalah anak-anak Auray termasuk bahwa peta kunci I

05:35.300 --> 05:40.810
J nol karena kunci kami setiap kunci disimpan pada indeks 0 bukan 1.

05:41.300 --> 05:41.820
BAIK.

05:41.840 --> 05:43.390
Dan kemudian ini juga harus nol.

05:43.400 --> 05:46.820
Dan ini perlu dorongan KIIS ke atas.

05:46.820 --> 05:49.400
Dan kemudian kita mengembalikan array kunci.

05:49.400 --> 05:50.420
Jadi jika kita mengujinya.

05:50.430 --> 05:58.800
Sekarang mari kita lakukan H. T. Bebek kami mendapatkan banyak nilai namun ada berapa banyak anak-anak itu.

05:58.970 --> 06:03.620
Dan jika kita melakukan hal yang sama untuk nilai-nilai di sana kita pergi.

06:03.830 --> 06:06.920
Kami mendapatkan lebih sedikit tentu saja karena kami memiliki nilai duplikat.

06:06.950 --> 06:09.470
Sekarang kami tidak membahas apa yang harus dilakukan dengan kunci duplikat.

06:09.470 --> 06:15.680
Jika seseorang menyisipkan sesuatu sekarang jika saya benar-benar pergi dan memasukkan plumbe lagi yang sudah

06:15.680 --> 06:22.990
ada di sana jadi H. T. atur plumbe yang akan menjadi ganda seperti itu.

06:23.240 --> 06:29.960
Jika kita melihat tabel hash kita, kita dapat melihat bahwa keduanya disimpan bersarang di sebelah satu sama lain di dalam

06:30.170 --> 06:30.940
indeks 0.

06:30.980 --> 06:35.550
Jadi mereka mengolah hash dengan hal yang sama persis nol setiap kali itu seharusnya bekerja.

06:35.630 --> 06:38.060
Tapi kami berakhir dengan dua anak di sana.

06:38.090 --> 06:45.230
Jadi ketika saya melakukan penyeleksian logika kita saat ini hanya akan memberi saya apa pun yang dimasukkan terlebih

06:45.230 --> 06:47.870
dahulu dan harus selalu seperti itu.

06:47.990 --> 06:50.360
Didasarkan pada bagaimana pengaturannya sekarang.

06:50.360 --> 06:57.260
Sekarang mungkin ini solusi yang lebih baik untuk mengingatkan pengguna Anda tentang hal itu jadi di sini Anda tahu kami dapat menambahkan beberapa logika

06:57.260 --> 06:59.460
untuk memeriksa apakah sudah ada di sana.

07:00.200 --> 07:03.320
Anda tahu ketika kita sedang mengatur sesuatu kita akan memeriksa apakah itu kosong.

07:03.400 --> 07:03.660
BAIK.

07:03.680 --> 07:04.640
Itu tidak kosong.

07:04.640 --> 07:09.930
Kemudian Anda bisa mengulangi seluruh hal dan memeriksa untuk melihat apakah sudah berisi kunci itu.

07:10.130 --> 07:12.590
Kami hanya akan pergi dengan implementasi sederhana ini untuk saat ini.

07:12.590 --> 07:19.070
Saat ini memungkinkan Anda untuk memasukkan banyak hal pada tombol yang sama dan Anda hanya akan mendapatkan yang pertama yang dimasukkan

07:19.070 --> 07:21.230
dan itu bagus untuk saat ini.

07:21.260 --> 07:26.480
Ini seharusnya tidak bisa digunakan, tetapi ingatlah bahwa sebagian besar bahasa jika Anda mencoba Anda

07:26.480 --> 07:31.010
tahu memasukkan sesuatu beberapa kali akan menimpa apa yang sudah Anda miliki.

07:31.010 --> 07:36.090
Jadi, jika kita tidak mengatur plumbe menjadi dobel Itu akan menjadi plumbe mulai sekarang.

07:36.350 --> 07:39.810
Namun demikian, kami telah mengimplementasikan kunci dan nilai.

07:39.830 --> 07:44.930
Seharusnya tidak ada duplikat kunci tetapi kode ini memastikan bahwa kita tidak

07:44.930 --> 07:45.810
mendapatkan duplikat.

07:45.980 --> 07:47.490
Hal yang sama di sini dengan nilai.

07:47.510 --> 07:48.850
Jadi itulah kunci dan nilai.

07:48.860 --> 07:54.440
Sekarang kita bisa memanggil Anda tahu titik kunci atau nilai turun dan beralih ke seluruh tabel hash jika itu

07:54.440 --> 07:57.920
yang ingin kami urutkan mencetak setiap warna tunggal yang kami miliki.

07:58.010 --> 08:04.360
Kita bisa melakukan sesuatu seperti tombol T Dot dan melakukan dot.

08:04.460 --> 08:09.120
Saya tidak tahu satu titik untuk setiap mungkin dan memanggil setiap telepon.

08:09.170 --> 08:16.920
Mari kita pergi dengan kunci dan kemudian hanya untuk membatalkan log H. T. jangan mendapatkan kunci.

08:17.120 --> 08:22.940
Dan jika kami mencoba menjalankannya, kami mencetak setiap nilai tunggal dan kami memiliki dua di sana karena

08:22.940 --> 08:26.430
kami menggunakan kunci dan hanya mendapatkan nilai berdasarkan itu.

08:26.750 --> 08:27.990
Dan itu terlihat bagus.

08:28.040 --> 08:32.660
Jadi kami secara resmi mendapatkan kunci dan nilai-nilai dengan metode kami yang terpisah dan kami

08:32.660 --> 08:33.780
dapat mengulanginya sekarang.

08:33.830 --> 08:34.460
Baiklah.

08:34.460 --> 08:37.280
Jadi itulah dasar-dasar tabel hash.

08:37.280 --> 08:39.050
Sekali lagi tidak canggih.

08:39.140 --> 08:43.690
Bukan sesuatu yang benar-benar harus Anda gunakan dalam implementasi ini, tetapi mudah-mudahan masuk akal cara kerjanya.
