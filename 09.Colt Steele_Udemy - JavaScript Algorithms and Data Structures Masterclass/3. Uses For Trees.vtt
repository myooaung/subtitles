WEBVTT

00:00.180 --> 00:00.450
Baiklah.

00:00.450 --> 00:01.280
Selamat datang kembali.

00:01.290 --> 00:06.090
Selanjutnya apa yang ingin saya lakukan adalah dengan cepat menjalankan beberapa kasus penggunaan dunia nyata untuk pohon.

00:06.090 --> 00:09.530
Ini bukan hanya hal-hal teoritis, ini bukan hanya tentang Anda tahu persiapan wawancara.

00:09.600 --> 00:12.880
Pohon digunakan sepanjang waktu bahkan jika Anda tidak sepenuhnya menyadarinya.

00:12.930 --> 00:18.390
Anda telah berinteraksi dengan pohon baik sebagai pengembang javascript yang paling mungkin tetapi kemudian juga hanya sebagai

00:18.570 --> 00:19.280
pengguna Internet.

00:19.410 --> 00:22.290
Jadi contoh paling umum adalah Tim L dan DOM.

00:22.320 --> 00:24.030
Model objek dokumen.

00:24.120 --> 00:28.150
Jadi ketika kita berpikir tentang umur Tim Yah, itu cocok untuk struktur seperti pohon.

00:28.170 --> 00:34.080
Benar kita memiliki elemen dan di dalam elemen kita dapat memiliki elemen bersarang yang adalah anak yang adalah anak yang

00:34.140 --> 00:39.080
adalah anak-anak dan kita dapat terus memiliki anak-anak bersarang di sarang bersarang lebih jauh ke bawah.

00:39.140 --> 00:43.770
Dan jika hubungan orangtua anak antara mereka yang berusia elemen yang hanya teks tetapi

00:43.770 --> 00:48.840
kemudian setelah ia sampai ke browser setelah permintaan dan mendapatkan respon browser kemudian membaca semua itu

00:48.840 --> 00:50.480
mem-parsing dan menciptakan DOM.

00:50.490 --> 00:57.240
Model objek dokumen dan di Chrome kita mendapatkan debugger yang bagus ini kita bisa mengklik semacam cara interaktif

00:57.240 --> 00:59.340
untuk melihat node yang berbeda.

00:59.340 --> 01:05.270
Namun di balik layar ada objek javascript yang sesuai untuk masing-masing node ini.

01:05.340 --> 01:13.870
Jadi ada sebuah badan yang Anda tahu kami dapat mengaksesnya hanya dengan berbicara mengetikkan dokumen titik tubuh dan mencetak teks untuk kami di sini

01:13.870 --> 01:15.930
tapi itu sebenarnya sebuah objek.

01:15.930 --> 01:21.970
Dan jika kita dot, kita dapat melihatnya memiliki banyak properti, banyak metode yang dapat kita

01:21.970 --> 01:27.610
panggil dan kita dapat melakukan hal-hal seperti melihat anak-anaknya dan memberi kita daftar anak-anak.

01:27.640 --> 01:36.390
Jadi mari kita ambil hal pertama di sana yang memberi kita simpul dan kita bisa melakukannya anak-anak di sana dan ada begitu satu

01:36.390 --> 01:41.850
hal di sana yang sepertinya hanya ada satu anak div bukan anak pertama itu.

01:41.850 --> 01:46.320
Lagi pula jika Anda tidak terbiasa dengan Dom saya tidak akan khawatir tentang hal itu hanya tahu bahwa itu adalah struktur

01:46.500 --> 01:47.380
pohon yang sangat sangat.

01:47.380 --> 01:48.030
Mereka menggunakan satu.

01:48.150 --> 01:50.730
Jadi aplikasi lain harus dilakukan dengan routing jaringan.

01:50.820 --> 01:52.630
Jelas bukan keahlian saya.

01:52.650 --> 01:57.420
Saya bahkan tidak akan mencoba menjelaskan cara kerjanya tetapi jika Anda pergi ke halaman perutean di Wikipedia kita

01:57.420 --> 01:59.400
mendapatkan semua jenis diagram pohon di sini.

01:59.400 --> 02:04.830
Jadi ini adalah skema pengiriman yang berbeda untuk bagaimana suatu pesan pada dasarnya ditransmisikan ke sebuah node atau ke

02:04.830 --> 02:10.380
beberapa node dan Anda dapat melihat bahwa kami memiliki beberapa struktur pohon yang terjadi di sini dan itu cukup

02:10.730 --> 02:13.520
banyak karena saya tidak tahu apa-apa tentang routing jaringan.

02:14.250 --> 02:19.890
Tapi di balik layar ada beberapa pohon yang digunakan ada banyak dari Anda tahu logika ilmu komputer klasik

02:19.950 --> 02:22.270
yang masuk ke menemukan jalan terpendek.

02:22.290 --> 02:25.940
Bagaimanapun Selanjutnya kita akan berbicara tentang pohon sintaksis abstrak.

02:26.160 --> 02:32.270
Jadi ini adalah cara kami menggambarkan sintaks dari bahasa pemrograman menggunakan struktur pohon.

02:32.670 --> 02:35.550
Jadi, tanpa terlalu detail, tidak masalah.

02:35.550 --> 02:38.890
Jujur semua yang penting adalah Anda melihat bahwa ini adalah struktur pohon.

02:39.000 --> 02:41.420
Bahasa apa pun ini berasal dari Wikipedia.

02:41.420 --> 02:47.630
Jika Anda ingin membaca lebih lanjut tentang itu kami Anda tahu kami memiliki katakanlah loop sementara daripada blok sementara.

02:47.880 --> 02:54.840
Kami memiliki kondisi sebagai bagian dari sementara dan kemudian kami juga memiliki tubuh di dalamnya sementara Dan dalam

02:54.840 --> 03:01.050
kondisi itu kami dapat memiliki perbandingan antara variabel dan konstanta dan ini adalah versi singkat yang

03:01.050 --> 03:03.420
sangat singkat dan hilang banyak logika.

03:03.510 --> 03:09.240
Tetapi intinya adalah untuk menunjukkan kepada Anda bahwa ini adalah cara pada dasarnya jika Anda menulis kode untuk mengambil kode

03:09.240 --> 03:14.820
lain dan menjalankan kode itu atau mengurai kode itu atau untuk memastikan itu sintaks yang valid Anda bisa menggunakan

03:14.820 --> 03:17.400
pohon teks abstraksi untuk membantu Anda keluar selanjutnya.

03:17.400 --> 03:20.160
Pohon digunakan dalam kecerdasan buatan sepanjang waktu.

03:20.160 --> 03:24.380
Ada banyak aplikasi untuk pohon dan kecerdasan buatan dan pembelajaran mesin.

03:24.420 --> 03:28.560
Mungkin contoh paling sederhana adalah sesuatu yang disebut pohon minimax.

03:28.740 --> 03:34.590
Jadi katakanlah kita sedang membangun game tic tac toe, kami ingin membuat AI yang sangat bagus sehingga tidak

03:34.590 --> 03:36.060
hanya mengambil gerakan acak.

03:36.240 --> 03:41.790
Kami pada dasarnya bisa memecah logika permainan menjadi pohon dan kami pada dasarnya akan mengatakan di sini

03:41.790 --> 03:43.010
adalah kondisi tertentu.

03:43.350 --> 03:47.480
Dan ini adalah semua kemungkinan gerakan yang bisa dilakukan oleh pemain manusia.

03:47.490 --> 03:55.170
Mereka begitu komputernya adalah X dan apa yang kita lihat di sini baik-baik saja. Anda tahu jika seorang pemain manusia bermain di oh

03:55.170 --> 04:02.000
di sini, suasana terbaik yang bisa dilakukan adalah dengan meletakkan X di sini dan dengan cara itu X akan menang.

04:02.340 --> 04:08.190
Jika O masuk ke sini, langkah terbaik yang mungkin adalah menempatkan X di tengah dan kemudian tergantung apa yang dilakukan

04:08.190 --> 04:09.070
0 selanjutnya.

04:09.090 --> 04:10.890
Anda tahu ada banyak pilihan.

04:10.890 --> 04:16.280
Pada dasarnya struktur pohon ini hanya menggambarkan sekumpulan opsi yang mungkin berbeda untuk apa yang bisa terjadi.

04:16.290 --> 04:21.420
Dan setelah langkah yang diberikan oleh lawan langkah terbaik berikutnya.

04:21.420 --> 04:23.190
Jadi itu sangat dangkal.

04:23.190 --> 04:27.550
Anda bahkan tidak menggores permukaan bagaimana Anda benar-benar mengimplementasikan ini dan apa bagian minimumnya

04:27.650 --> 04:28.440
adalah logika.

04:28.500 --> 04:31.730
Tapi yang ingin saya tunjukkan adalah bahwa ini pada dasarnya disebut The Decision Tree.

04:31.860 --> 04:37.170
Anda memiliki keputusan berbeda yang Anda buat poin percabangan dan Anda mengikuti satu dan kemudian yang membagi dan

04:37.200 --> 04:39.630
Anda mengikuti keputusan berikutnya dan Anda terus berjalan.

04:39.630 --> 04:45.870
Dan ini memiliki aplikasi yang sangat rumit Anda tahu algoritma klasifikasi misalnya bukan hanya AI

04:45.930 --> 04:47.050
tac toe.

04:47.130 --> 04:52.230
Dan akhirnya, mungkin contoh paling sederhana adalah cara folder Anda menjadi model dan sistem operasi

04:52.230 --> 04:58.050
yang Anda tahu jika Anda melihat sesuatu seperti ini di Mac atau PC komputer Anda direpresentasikan sebagai struktur

04:58.050 --> 04:58.710
pohon.

04:58.710 --> 05:01.190
Ada semua direktori ini hierarkis.

05:01.240 --> 05:02.280
Ada sebuah root.

05:02.280 --> 05:05.810
Ada folder paling atas yang Anda kenal di Mac.

05:06.000 --> 05:07.890
Saya sebenarnya tidak tahu apa itu lagi.

05:07.890 --> 05:09.440
Di akun Anda itu adalah direktori root.

05:09.450 --> 05:11.390
Tapi Anda tahu ada banyak akun.

05:11.400 --> 05:12.950
Anda bisa mendapatkan komputer sehingga tidak masalah.

05:12.970 --> 05:18.310
Tapi katakan saja kita sedang melihat folder yang diberikan folder ini di dalam ini mungkin root kita.

05:18.330 --> 05:20.050
Kami memiliki dua folder lain di dalamnya.

05:20.280 --> 05:21.900
Dan kemudian mereka memiliki file.

05:21.990 --> 05:22.240
Ya.

05:22.260 --> 05:29.610
Secara teknis ini memiliki dua jenis node yang bisa Anda katakan file dan folder itu tetapi struktur itu sendiri seperti kita

05:29.640 --> 05:34.060
punya semua cabang ini dan anak-anak itu punya anak sendiri dan seterusnya.

05:34.170 --> 05:38.660
Jadi itu hanya pengantar cepat ke beberapa kasus penggunaan dunia nyata untuk pohon.

05:38.730 --> 05:43.310
Tentu Anda tahu ini bukan hal yang murni teoretis, ini bukan sekadar latihan.

05:43.350 --> 05:45.870
Ini adalah hal-hal yang muncul sepanjang waktu dalam pemrograman.

05:45.870 --> 05:48.470
Salah satu contoh yang saya benar-benar lupa sebutkan adalah Jason.

05:48.630 --> 05:52.830
Jadi jika Anda pernah bekerja dengan notasi objek javascript Jaison Anda akan mendapatkannya, Anda

05:52.830 --> 05:58.110
tahu saya tidak tahu panggilan AJAX yang Anda kirim dalam permintaan dan Anda mendapatkan beberapa data dari API

05:58.110 --> 06:03.600
ketika Anda menguraikan respons dari string ke javascript atau untuk menggunakan Python atau bahasa apa pun yang Anda gunakan.

06:03.600 --> 06:09.510
Ada kode yang melintasi pohon atau membuat struktur seperti pohon seperti yang Anda lihat di sini.

06:09.510 --> 06:16.060
Saya menggunakan ekstensi Chrome hanya untuk melihat beberapa simpul anak dan masing-masing punya anak dan ini adalah struktur pohon.

06:16.080 --> 06:17.540
Anda dapat mewakili ini dengan mudah.

06:17.550 --> 06:22.170
Yah saya seharusnya tidak mengatakan dengan mudah itu cocok untuk diwakili oleh pohon itu banyak

06:22.170 --> 06:27.960
pekerjaan tetapi masih merupakan struktur pohon di mana kita memiliki node orangtua dan anak tetapi pada akhirnya ada satu

06:28.020 --> 06:28.570
root.

06:28.680 --> 06:30.190
Baiklah saya akan meninggalkannya di sana.

06:30.220 --> 06:32.250
Ada banyak kegunaan yang berbeda untuk pohon.
