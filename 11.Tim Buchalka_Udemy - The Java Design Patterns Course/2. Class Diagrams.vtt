WEBVTT

00:08.600 --> 00:09.410
Hello and welcome.

00:09.440 --> 00:11.600
Let's talk about class diagrams.

00:11.750 --> 00:17.360
As I mentioned this is gonna be the main diagram we use to show the design of some of the design patterns

00:17.990 --> 00:24.600
in UML so we know a class represents set of objects having similar responsibilities.

00:24.600 --> 00:31.480
It's really a blueprint the class diagram is used to define the detailed design of this system.

00:31.480 --> 00:35.520
You'll see all of the objects in the system represented as classes.

00:35.920 --> 00:37.360
They describe the attributes.

00:37.360 --> 00:40.870
Remember variables and the operations of a class methods

00:43.840 --> 00:48.430
they also show a collection of classes interfaces associates collaboration and constraints.

00:48.430 --> 00:50.350
They show all the relationships.

00:50.350 --> 00:53.980
So when you look at this diagram you're gonna see a bunch of different classes and then you're going

00:53.980 --> 00:58.360
to be able to understand the relationships between those classes whether or not there is a has a relationship

00:58.360 --> 01:01.400
whether or not there's and is a relationship right.

01:01.430 --> 01:06.140
This is known as a structural diagram because it shows the entire system and the structure of the system

01:09.080 --> 01:13.750
class diagrams are widely used in the modeling of object oriented systems because they are the only

01:13.790 --> 01:18.500
small diagrams which can be mapped directly with object oriented languages.

01:18.560 --> 01:22.520
Class doesn't really exist in other types of languages.

01:22.820 --> 01:27.450
They also can generate executable code of an application although again we're not getting into that.

01:27.580 --> 01:32.840
It depends on the tool use but there are some tools out there that can just take a diagram and generate

01:32.840 --> 01:33.680
classes from it.

01:33.710 --> 01:39.050
Because again the class contains a ton of detail shows the relationship between classes.

01:39.050 --> 01:43.820
So if there's inheritance relationship or if you're implementing an interface it also shows you remember

01:43.820 --> 01:45.440
variables and your methods.

01:45.440 --> 01:51.140
So you can see how you can essentially write a tool that takes the diagrams information and generates

01:51.320 --> 01:54.970
actual Java code.

01:55.020 --> 02:01.250
The purpose of class diagrams to model the static view of an application it doesn't show things dynamically.

02:01.410 --> 02:05.220
It just shows really class definitions and relationships.

02:05.220 --> 02:09.460
It's a graphical representation it describes the vocabulary of the system.

02:09.570 --> 02:13.920
Again a quick glance you could look at this diagram and understand in a high level what objects are

02:13.920 --> 02:19.260
involved and how they relate to one another collection of class diagrams represent the whole system.

02:19.260 --> 02:25.440
The most popular UML diagram is the class diagram because it conveys so much information and it's easy

02:25.440 --> 02:31.610
to understand they describe the responsibilities of the system the functionalities performed by the

02:31.610 --> 02:34.840
system because you see the behavior with the methods.

02:34.860 --> 02:37.610
Again you quickly look and say oh this is what this object does.

02:37.610 --> 02:39.160
This is what this other object does.

02:40.560 --> 02:44.390
They provide a base for component and deployment diagrams.

02:44.510 --> 02:49.350
We're not going to discuss those that is a useful information and they provide forward and reverse code

02:49.350 --> 02:49.870
engineering.

02:49.890 --> 02:57.300
As I mentioned drawing a class diagram the name of the class diagram should be meaningful to describe

02:57.300 --> 03:01.570
the aspect of the system and we'll get to some examples.

03:01.650 --> 03:05.650
Each element in the relationship Pete should be identified in advance.

03:05.670 --> 03:09.990
You can't just start writing class diagram unless you have an understanding of what objects are in the

03:09.990 --> 03:14.520
system what the attributes and methods are of those objects and how the objects relate.

03:15.800 --> 03:21.550
So the responsibility of each class should be clearly identified with those attributes and methods and

03:21.560 --> 03:27.500
then for each class a minimum number of properties should be specified as necessary as unnecessary properties

03:27.500 --> 03:29.420
will make the diagram complicated.

03:29.420 --> 03:33.600
You don't want to put in member variables that you don't use or don't need.

03:33.860 --> 03:40.570
You can also use a notes little notes icon whenever you need to describe some aspect of the diagram.

03:40.580 --> 03:47.030
That's maybe not explainable and again we'll provide an example that the whole purpose of the class

03:47.030 --> 03:51.710
diagram is to convey information about the design of the objects to a user.

03:51.710 --> 03:57.890
So if it's confusing you can provide the notes and the ultimate goal is to have the diagram be understandable

03:57.890 --> 04:04.940
by a fellow developer before making the final version the diagrams should be drawn on plain paper and

04:04.940 --> 04:07.010
reworked as many times as possible to make correct.

04:07.040 --> 04:10.790
So you're probably going to go back and refactor you're probably going to get peer reviews from your

04:10.790 --> 04:15.080
class diagram get information from others say hey what do you think about this design.

04:15.080 --> 04:16.140
Does it look good.

04:16.280 --> 04:21.650
They may scratch off some attributes some other things on the class diagram and say hey this is unnecessary

04:21.680 --> 04:29.670
and you will go ahead and refactor have kind of that iterative development class relationships with

04:29.670 --> 04:31.340
one class as a kind of another class.

04:31.340 --> 04:33.210
This is referred to as an is a relationship.

04:33.210 --> 04:38.580
We know that that's inheritance that can be reflected in the diagram when there are associations between

04:38.580 --> 04:45.660
two classes whether it's a has a relationship or aggregation a composition.

04:45.840 --> 04:51.720
If it's a uses and other class which is who uses a relationship really it's similar aggregation except

04:51.720 --> 04:56.850
that maybe you're passing a method or a parameter to a method and you're using an object that way as

04:56.850 --> 04:59.680
opposed to having an action as an actual member variable.

04:59.940 --> 05:02.190
That's a use as a relationship.

05:02.190 --> 05:07.400
Also from one class creates another class that can be reflected as an association between two classes

05:07.410 --> 05:08.090
in the diagram.

05:10.040 --> 05:12.660
There are also variations on these themes.

05:12.840 --> 05:17.400
The contained item is part of the containing items such as an engine in a car composition.

05:17.400 --> 05:22.740
So for has a relationship you have some sub things we know the difference between composition and aggregation

05:23.190 --> 05:25.890
that can also be identified in the UML diagram.

05:25.890 --> 05:30.570
The difference whether it's composition or whether it's an aggregation relationship and we know what

05:30.570 --> 05:30.960
those are

05:33.990 --> 05:36.210
so those are the types of things that you'll see in a class time.

05:36.210 --> 05:40.280
Graham wrote quickly now I want to show you some example.
