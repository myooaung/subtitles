1
00:00:02,892 --> 00:00:04,809
Digest tries to solve the problem of transmitting

2
00:00:04,809 --> 00:00:07,441
credentials in plain text over the network,

3
00:00:07,441 --> 00:00:11,112
making it difficult for someone sniffing network traffic.

4
00:00:11,112 --> 00:00:14,862
It uses md5 checksum hashes so that the credentials are

5
00:00:14,862 --> 00:00:16,815
never transmitted across the wire,

6
00:00:16,815 --> 00:00:22,155
both client and server nonces to defend against replay attacks.

7
00:00:22,155 --> 00:00:24,955
Let's configure digest authentication in our application.

8
00:00:24,955 --> 00:00:27,500
We will mix it up a bit.

9
00:00:27,500 --> 00:00:31,933
For our admin section, we will use digest as it is more secure than basic.

10
00:00:31,933 --> 00:00:36,115
The remainder of the site will continue using basic.

11
00:00:36,115 --> 00:00:38,751
To achieve this, we will need to set up two filter chains.

12
00:00:38,751 --> 00:00:41,762
We need to configure a new configuration class that

13
00:00:41,762 --> 00:00:45,868
extends the WebSecurityConfigurationAdapter.

14
00:00:45,868 --> 00:00:49,306
First we need a digest authentication entry point.

15
00:00:49,306 --> 00:00:52,321
Let's configure a method that returns an instance of 1

16
00:00:52,321 --> 00:00:55,296
and add the realm and key to it.

17
00:00:55,296 --> 00:00:58,010
The realm is the security policy domain.

18
00:00:58,010 --> 00:01:00,732
You can partition parts of your web application into separate

19
00:01:00,732 --> 00:01:04,026
realms with their own security policies.

20
00:01:04,026 --> 00:01:07,246
Hence, we will call this on admin-digest-realm.

21
00:01:07,246 --> 00:01:10,841
The key is used by the entry point to generate a nonce

22
00:01:10,841 --> 00:01:13,162
required in the digest authentication.

23
00:01:13,162 --> 00:01:17,339
It basically is an encoded string used to prevent replay attacks.

24
00:01:17,339 --> 00:01:19,751
The server creates a new nonce for every request and

25
00:01:19,751 --> 00:01:22,158
expects it back in the response.

26
00:01:22,158 --> 00:01:24,724
If the same nonce is detected in multiple requests or some

27
00:01:24,724 --> 00:01:27,570
of the details of the nonce don't add up,

28
00:01:27,570 --> 00:01:29,400
the server can reject it.

29
00:01:29,400 --> 00:01:34,289
to see how Spring generates the nonce, let's drill into the digest entry point.

30
00:01:34,289 --> 00:01:38,912
It uses the expiryTime, which is 300 seconds from the currentTime:,

31
00:01:38,912 --> 00:01:41,378
an md5 hash of the expiryTime,

32
00:01:41,378 --> 00:01:45,093
and the key we added to the authentication provider.

33
00:01:45,093 --> 00:01:47,768
This now forms the signature value.

34
00:01:47,768 --> 00:01:51,008
Finally, it encodes the nonce in base 64.

35
00:01:51,008 --> 00:01:52,740
When the request is sent back to the client,

36
00:01:52,740 --> 00:01:57,905
the expiryTime in the nonce is used to check if the request is still valid,

37
00:01:57,905 --> 00:02:00,751
and the signature ensures that it hasn't been tampered with.

38
00:02:00,751 --> 00:02:02,862
We also need a new UserDetailsService,

39
00:02:02,862 --> 00:02:06,817
the reason being is that the default one generated by Spring

40
00:02:06,817 --> 00:02:11,780
Boot adds a prefix to the password of noop.

41
00:02:11,780 --> 00:02:13,689
The reason it does this is that, by default,

42
00:02:13,689 --> 00:02:15,990
Spring expects the password to be encoded.

43
00:02:15,990 --> 00:02:20,392
And the default encoder in Spring Security 5 is bcrypt.

44
00:02:20,392 --> 00:02:22,741
Hence, if the prefix is in front of the password,

45
00:02:22,741 --> 00:02:27,575
it is stripped, and a noop password encoder is used instead,

46
00:02:27,575 --> 00:02:30,115
which matches the password in plain text.

47
00:02:30,115 --> 00:02:34,637
However, the prefix just doesn't work with the digest authentication filter.

48
00:02:34,637 --> 00:02:38,502
It doesn't strip the noop and, hence, will not authenticate.

49
00:02:38,502 --> 00:02:39,174
In the adapter,

50
00:02:39,174 --> 00:02:42,400
we are going to override the method configure that accepts a

51
00:02:42,400 --> 00:02:46,446
parameter of AuthenticationManagerBuilder and create an

52
00:02:46,446 --> 00:02:49,999
in-memory AuthenticationManager two users,

53
00:02:49,999 --> 00:02:53,135
user and admin.

54
00:02:53,135 --> 00:02:57,789
We also need to expose this UserDetailsService as a bean so that Spring

55
00:02:57,789 --> 00:03:00,559
Boot backs off and doesn't configure the default one.

56
00:03:00,559 --> 00:03:01,653
To do this,

57
00:03:01,653 --> 00:03:07,089
we override the UserDetailsService bean method and expose it as a bean.

58
00:03:07,089 --> 00:03:10,295
Now to get around not having to add the noop prefix,

59
00:03:10,295 --> 00:03:14,306
we will add the noop password encoder as a bean.

60
00:03:14,306 --> 00:03:18,832
This will cause Spring Security to set it as the default encoder.

61
00:03:18,832 --> 00:03:21,619
This is okay for testing your app,

62
00:03:21,619 --> 00:03:25,553
but it is not suitable for production and is why it is depreciated

63
00:03:25,553 --> 00:03:28,730
by Spring as they want to warn you against this.

64
00:03:28,730 --> 00:03:30,229
For now this is fine.

65
00:03:30,229 --> 00:03:33,670
We are going to go over working with credentials securely and correctly.

66
00:03:33,670 --> 00:03:33,925
Next,

67
00:03:33,925 --> 00:03:37,378
we will add a method to the configure that returns an instance of

68
00:03:37,378 --> 00:03:41,793
the DigestAuthenticationFilter and add the new UserDetailsService

69
00:03:41,793 --> 00:03:45,457
and AuthenticationEntryPoint to it.

70
00:03:45,457 --> 00:03:45,867
Finally,

71
00:03:45,867 --> 00:03:50,888
we override the configure method that takes in the HTTP security parameter.

72
00:03:50,888 --> 00:03:53,802
By default, the filter chain matcher is always any.

73
00:03:53,802 --> 00:03:56,591
We want it to only secure the admin site.

74
00:03:56,591 --> 00:04:01,679
So we will add an antMatcher with the admin site URI.

75
00:04:01,679 --> 00:04:05,400
Then add the digest filter and the digest entry

76
00:04:05,400 --> 00:04:07,969
point into the exceptions handler.

77
00:04:07,969 --> 00:04:08,282
Finally,

78
00:04:08,282 --> 00:04:11,204
we indicate that all requests to admin must be

79
00:04:11,204 --> 00:04:14,143
authenticated and have the user role admin.

80
00:04:14,143 --> 00:04:15,689
One last thing.

81
00:04:15,689 --> 00:04:18,256
Because we have two configuration classes that extend the

82
00:04:18,256 --> 00:04:21,724
WebSecurityConfigurerAdapter and override the configure method

83
00:04:21,724 --> 00:04:27,324
that accepts the HttpSecurity object, Spring will configure two filter chains,

84
00:04:27,324 --> 00:04:31,249
and it needs to know the order to evaluate them.

85
00:04:31,249 --> 00:04:34,726
By default, it assigns an order value of 100.

86
00:04:34,726 --> 00:04:38,730
But you cannot have two filter chains with the same order value.

87
00:04:38,730 --> 00:04:42,459
Let's give the admin configuration class an order of

88
00:04:42,459 --> 00:04:46,073
101 by using the Order annotation.

89
00:04:46,073 --> 00:04:47,140
Okay, that's it.

90
00:04:47,140 --> 00:04:49,758
Let's kick off the server and test this.

91
00:04:49,758 --> 00:04:53,700
If we access the admin site, it should be using digest.

92
00:04:53,700 --> 00:04:57,076
However, it seems to still be using basic.

93
00:04:57,076 --> 00:04:59,914
Hmm, let's see what's going on.

94
00:04:59,914 --> 00:05:01,944
If we add a breakpoint and look at the FilterChainProxy,

95
00:05:01,944 --> 00:05:05,385
we can see two expected filter chains.

96
00:05:05,385 --> 00:05:05,870
Basically,

97
00:05:05,870 --> 00:05:11,537
by having two configured classes extending the WebSecurityConfigurerAdapter,

98
00:05:11,537 --> 00:05:14,775
Spring configures two independent filter chains.

99
00:05:14,775 --> 00:05:19,181
The FilterChainProxy will check each filter in order to

100
00:05:19,181 --> 00:05:21,592
see which one matches the request.

101
00:05:21,592 --> 00:05:24,764
The first chain in the list has an anyMatcher and has the

102
00:05:24,764 --> 00:05:27,846
BasicAuthenticationFilter and entry point,

103
00:05:27,846 --> 00:05:30,978
so it will match all requests, including admin.

104
00:05:30,978 --> 00:05:33,779
Hence, the second one will never be evaluated.

105
00:05:33,779 --> 00:05:36,958
One way we can solve this is by changing the matcher to be

106
00:05:36,958 --> 00:05:39,612
more specific and exclude the admin URI.

107
00:05:39,612 --> 00:05:44,525
However, an easier and better way would be to make the digest one evaluate first.

108
00:05:44,525 --> 00:05:47,653
To do this, we can add the order annotation.

109
00:05:47,653 --> 00:05:54,573
We will make the admin configuration that uses digest order 1 and basic order 2.

110
00:05:54,573 --> 00:05:58,076
Let's try to access the admin page again.

111
00:05:58,076 --> 00:06:01,826
Now the chain for admin is evaluated first.

112
00:06:01,826 --> 00:06:06,803
The admin login pop-up now has the admin realm displayed.

113
00:06:06,803 --> 00:06:09,878
And the header returned to the browser indicates

114
00:06:09,878 --> 00:06:12,288
digest authentication is required.

115
00:06:12,288 --> 00:06:13,910
If we log in this time,

116
00:06:13,910 --> 00:06:18,218
the browser adds an authorization property to the header with the

117
00:06:18,218 --> 00:06:20,724
digest details required for authentication,

118
00:06:20,724 --> 00:06:27,216
the username, realm, server, nonce, the URI we want to access,

119
00:06:27,216 --> 00:06:29,684
the hash credentials, quality of protection,

120
00:06:29,684 --> 00:06:31,386
and the nonce count.

121
00:06:31,386 --> 00:06:33,926
The client increments the nonce count each time it

122
00:06:33,926 --> 00:06:36,340
makes a request using the same nonce.

123
00:06:36,340 --> 00:06:40,886
If the server receives the nonce count twice, it could be a replay attack.

124
00:06:40,886 --> 00:06:46,429
In the authorization header value, the key bit is the response property,

125
00:06:46,429 --> 00:06:48,630
which is the encoded credential.

126
00:06:48,630 --> 00:06:51,770
In this instance, our browser selected the qop,

127
00:06:51,770 --> 00:06:54,518
the quality of protection, as auth,

128
00:06:54,518 --> 00:06:59,296
which is defined in the RFC 2617 as the first hash,

129
00:06:59,296 --> 00:07:07,451
which we'll call here HA1, an MD5 of the username:realm:password.

130
00:07:07,451 --> 00:07:11,374
The second hash, which we will HA2 is the method,

131
00:07:11,374 --> 00:07:15,552
example get, post, put:digestURI.

132
00:07:15,552 --> 00:07:19,350
The response is then an MD5 hash of the HA1,

133
00:07:19,350 --> 00:07:23,786
the nonce, the nonceCount, the client nonce,

134
00:07:23,786 --> 00:07:26,049
the qop, and the HA2.

135
00:07:26,049 --> 00:07:28,749
So there is a lot of protection here for your credentials.

136
00:07:28,749 --> 00:07:31,137
The password is encoded and not plain text.

137
00:07:31,137 --> 00:07:34,245
You also have the protection against replay attacks due to

138
00:07:34,245 --> 00:07:36,722
the nonce and the cnonce being included.

139
00:07:36,722 --> 00:07:37,500
It is, however,

140
00:07:37,500 --> 00:07:39,932
susceptible to man-in-the-middle attacks where an

141
00:07:39,932 --> 00:07:42,953
attacker could intercept the request, modify it,

142
00:07:42,953 --> 00:07:45,427
and then forward it on to the server.

143
00:07:45,427 --> 00:07:47,877
There is, however, a version of digest that addresses this.

144
00:07:47,877 --> 00:07:49,919
The qop for that is auth/int,

145
00:07:49,919 --> 00:07:54,281
and it includes the hash of the body in the response.

146
00:07:54,281 --> 00:07:57,588
That way the server can verify that the body wasn't tampered with.

147
00:07:57,588 --> 00:08:02,036
However, it is not widely supported, and Spring also doesn't support it.

148
00:08:02,036 --> 00:08:05,068
The DigestAuthenticationFilter behaves a little

149
00:08:05,068 --> 00:08:07,491
differently to other authentication filters,

150
00:08:07,491 --> 00:08:08,922
like basic.

151
00:08:08,922 --> 00:08:12,307
By default, it doesn't completely authenticate the token.

152
00:08:12,307 --> 00:08:14,756
If we log in again with a breakpoint,

153
00:08:14,756 --> 00:08:19,205
we can see after successfully authenticating the user credentials,

154
00:08:19,205 --> 00:08:22,666
it adds an authentication token to the security context

155
00:08:22,666 --> 00:08:26,433
with a false isAuthenticated flag.

156
00:08:26,433 --> 00:08:29,157
And the credentials are also populated with the password.

157
00:08:29,157 --> 00:08:29,563
Hence,

158
00:08:29,563 --> 00:08:36,341
this is still an authentication request and not an authenticated principal yet.

159
00:08:36,341 --> 00:08:39,662
There are still other pending authentication checks that need to be performed,

160
00:08:39,662 --> 00:08:46,467
like checking the isEnabled or isAccountNotExpired or suspended flags and any

161
00:08:46,467 --> 00:08:50,123
other custom checks defined in the AuthenticationManager.

162
00:08:50,123 --> 00:08:53,780
The digest filter cannot use the AuthenticationManager because it compares

163
00:08:53,780 --> 00:08:57,388
the digest and not just the password for authentication,

164
00:08:57,388 --> 00:09:01,102
and the digest varies between each request.

165
00:09:01,102 --> 00:09:01,531
Hence,

166
00:09:01,531 --> 00:09:05,996
it uses the UserDetailsService instead to retrieve the plain text

167
00:09:05,996 --> 00:09:09,601
password to generate the digest for authentication.

168
00:09:09,601 --> 00:09:12,835
So how did we get access to the site you might ask?

169
00:09:12,835 --> 00:09:16,426
Well the InterceptorFilter will detect that the authentication

170
00:09:16,426 --> 00:09:20,645
token is not yet completely authenticated and will use its

171
00:09:20,645 --> 00:09:24,162
AuthenticationManager to re-authenticate and replace the token

172
00:09:24,162 --> 00:09:25,924
with an authenticate principal,

173
00:09:25,924 --> 00:09:30,212
hence where the password was placed in the token for the digest filter.

174
00:09:30,212 --> 00:09:34,165
This is not ideal as the plain text password is exposed

175
00:09:34,165 --> 00:09:37,176
in the context for a period of time,

176
00:09:37,176 --> 00:09:40,387
which increases the risk of it being exposed.

177
00:09:40,387 --> 00:09:43,110
You can get around this by setting the setCreateAuthenticatedToken

178
00:09:43,110 --> 00:09:48,147
flag to true on the digest authentication filter.

179
00:09:48,147 --> 00:09:50,926
But that would make your authentication limited to

180
00:09:50,926 --> 00:09:53,228
just checking the credentials.

181
00:09:53,228 --> 00:09:55,467
The Spring team actually do not recommend digest as

182
00:09:55,467 --> 00:09:57,652
you can see on their web page,

183
00:09:57,652 --> 00:10:03,743
even though intuitively it might seem that digest is better than basic or form,

184
00:10:03,743 --> 00:10:06,070
even if you use HTTPS.

185
00:10:06,070 --> 00:10:08,607
The Spring team's main concern here is that with digest,

186
00:10:08,607 --> 00:10:13,074
you need to store the password in your identity store in plain text.

187
00:10:13,074 --> 00:10:16,461
Now you can encrypt it and provide a little bit more security.

188
00:10:16,461 --> 00:10:19,813
But the preferred and secure way of storing credentials

189
00:10:19,813 --> 00:10:22,825
is through a one-way hash like bcrypt.

190
00:10:22,825 --> 00:10:27,428
There is way to store part of the credentials in MD5 format for digest,

191
00:10:27,428 --> 00:10:33,000
but it isn't every effective. In the next section, we'll actually show you why.

