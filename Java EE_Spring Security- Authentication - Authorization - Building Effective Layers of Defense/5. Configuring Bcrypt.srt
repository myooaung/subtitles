1
00:00:02,159 --> 00:00:05,460
Bcrypt is a password-hashing algorithm that is

2
00:00:05,460 --> 00:00:08,128
specifically designed with passwords in mind.

3
00:00:08,128 --> 00:00:10,701
The key feature is that it is designed to be slow,

4
00:00:10,701 --> 00:00:15,555
hence reducing the number of passwords per second an attacker can hash,

5
00:00:15,555 --> 00:00:20,200
which limits the effectiveness of brute force attacks or dictionary attacks.

6
00:00:20,200 --> 00:00:23,159
It does this by using a configurable work factor.

7
00:00:23,159 --> 00:00:27,027
The higher the number, the more work is required to match the password,

8
00:00:27,027 --> 00:00:29,237
hence the slower it is.

9
00:00:29,237 --> 00:00:32,337
Now you should aim for about 1 second as the user

10
00:00:32,337 --> 00:00:34,643
will not really be affected by that.

11
00:00:34,643 --> 00:00:38,642
Now I have created a small app to test the processing time of different

12
00:00:38,642 --> 00:00:42,435
work factors for Spring's implementation of bcrypt.

13
00:00:42,435 --> 00:00:43,641
Now as you can see,

14
00:00:43,641 --> 00:00:47,716
the matching time significantly increases the higher the work factor.

15
00:00:47,716 --> 00:00:50,527
Now this gives you the ability to scale your security

16
00:00:50,527 --> 00:00:53,376
as your hardware improves over time.

17
00:00:53,376 --> 00:00:58,665
Now by default, Spring's bcrypt encoder uses a work factor of 10.

18
00:00:58,665 --> 00:01:02,194
The other constructor field is the SecureRandom object.

19
00:01:02,194 --> 00:01:05,927
Now you can just leave this as is as, by default,

20
00:01:05,927 --> 00:01:08,327
Spring uses the Java's implementation of SecureRandom,

21
00:01:08,327 --> 00:01:11,862
which is used to generate the salt for the hash.

22
00:01:11,862 --> 00:01:14,028
Now bcrypt internally generates the salt,

23
00:01:14,028 --> 00:01:16,808
which protects you against rainbow tables.

24
00:01:16,808 --> 00:01:19,611
And the format of the bcrypt hash is as follows.

25
00:01:19,611 --> 00:01:22,203
It's separated by the dollar sign.

26
00:01:22,203 --> 00:01:27,960
So the first part indicates the algorithm, which here is 2a, which means bcrypt.

27
00:01:27,960 --> 00:01:30,262
The second part is the work factor.

28
00:01:30,262 --> 00:01:35,932
And finally, the last part is the salt and the cipher combined.

29
00:01:35,932 --> 00:01:39,923
Now pass phrases must be between 8 to 56 characters and

30
00:01:39,923 --> 00:01:43,220
are hashed internally to a 448-bit key.

31
00:01:43,220 --> 00:01:48,510
So leave around 60 characters of space in your identity store.

32
00:01:48,510 --> 00:01:50,141
Otherwise, it will be truncated,

33
00:01:50,141 --> 00:01:53,434
and your authentication will fail as you also have to

34
00:01:53,434 --> 00:01:56,960
factor in Spring's prefix for the encoders.

35
00:01:56,960 --> 00:01:59,142
One final point worth mentioning.

36
00:01:59,142 --> 00:02:02,139
Now if we print the hash generated by the bcrypt encoder,

37
00:02:02,139 --> 00:02:06,521
you can see bcrypt's internal salt generation in action.

38
00:02:06,521 --> 00:02:10,619
The password hash is different each time the encoder method is called,

39
00:02:10,619 --> 00:02:15,206
even though the password is the same each time as the random salt

40
00:02:15,206 --> 00:02:24,000
is combined with the password before hashing. Now this protects you against rainbow tables.

