WEBVTT
1
1

00:00:01.360  -->  00:00:02.930
<v ->Hi guys and welcome back.</v>
2

2

00:00:02.930  -->  00:00:04.210
In this video, we're going to learn
3

3

00:00:04.210  -->  00:00:07.180
how to get the remainder of a division.
4

4

00:00:07.180  -->  00:00:08.430
And that is going to allow us
5

5

00:00:08.430  -->  00:00:10.920
to find out whether a number is odd or even.
6

6

00:00:10.920  -->  00:00:13.910
And that itself has a number of uses in programming.
7

7

00:00:13.910  -->  00:00:15.010
So let's get started.
8

8

00:00:15.010  -->  00:00:17.700
I'm going to create a variable called integer_division
9

9

00:00:17.700  -->  00:00:22.310
and make it equal to 13 divide divide five.
10

10

00:00:22.310  -->  00:00:24.350
Remember that when we do integer division,
11

11

00:00:24.350  -->  00:00:26.780
what we're doing is we are performing normal division,
12

12

00:00:26.780  -->  00:00:29.720
so 13 divided by five, which gives us 2.6,
13

13

00:00:29.720  -->  00:00:31.320
and then we're dropping everything
14

14

00:00:31.320  -->  00:00:32.830
after the decimal place.
15

15

00:00:32.830  -->  00:00:35.020
So that means we end up with two
16

16

00:00:35.020  -->  00:00:37.770
because five goes into 13 twice.
17

17

00:00:37.770  -->  00:00:38.963
If we print this out,
18

18

00:00:40.120  -->  00:00:42.863
then you'll see that the print output is two.
19

19

00:00:44.270  -->  00:00:46.800
Now if we wanted to get the remainder of the division,
20

20

00:00:46.800  -->  00:00:48.290
which is three,
21

21

00:00:48.290  -->  00:00:51.030
then Python gives us a nice way of doing that
22

22

00:00:51.030  -->  00:00:53.650
with the modulus operator.
23

23

00:00:53.650  -->  00:00:55.880
Let's get the remainder of this division
24

24

00:00:55.880  -->  00:00:59.480
by doing 13 modulus five.
25

25

00:00:59.480  -->  00:01:03.160
Notice that this modulus operator is the percent symbol.
26

26

00:01:03.160  -->  00:01:05.120
When you do 13 modulus five,
27

27

00:01:05.120  -->  00:01:09.210
Python will divide and then calculate what is left over.
28

28

00:01:09.210  -->  00:01:11.170
So if we print the remainder,
29

29

00:01:11.170  -->  00:01:13.780
then you'll see that the output would be first two,
30

30

00:01:13.780  -->  00:01:15.410
and then three.
31

31

00:01:15.410  -->  00:01:17.030
There you have it.
32

32

00:01:17.030  -->  00:01:19.330
So again, if we wanna find out
33

33

00:01:19.330  -->  00:01:20.920
whether a number is odd or even,
34

34

00:01:20.920  -->  00:01:23.150
we can use the modulus operator.
35

35

00:01:23.150  -->  00:01:24.170
Have a look at these numbers
36

36

00:01:24.170  -->  00:01:25.973
and see if you spot a pattern.
37

37

00:01:27.290  -->  00:01:30.830
We've got the number 10, 14, six, and 340,
38

38

00:01:30.830  -->  00:01:32.670
all of them divided by two.
39

39

00:01:32.670  -->  00:01:35.700
What would the remainder of this division be
40

40

00:01:35.700  -->  00:01:37.350
if we evaluate it?
41

41

00:01:37.350  -->  00:01:40.360
And for all of these numbers, which are all even,
42

42

00:01:40.360  -->  00:01:44.840
the remainder of division by two is always zero.
43

43

00:01:44.840  -->  00:01:47.400
That is what characterises even numbers as even,
44

44

00:01:47.400  -->  00:01:51.020
that when they're divided by two, there is no remainder.
45

45

00:01:51.020  -->  00:01:53.370
Similarly, if you get some odd numbers,
46

46

00:01:53.370  -->  00:01:56.430
you'll see that the pattern is inverted in a way,
47

47

00:01:56.430  -->  00:01:57.900
and you get 11 divided by two,
48

48

00:01:57.900  -->  00:02:00.140
27 divided by two, and three divided by two,
49

49

00:02:00.140  -->  00:02:03.870
and the remainder in all of these cases is always one.
50

50

00:02:03.870  -->  00:02:05.670
For example, for 11 divided by two,
51

51

00:02:05.670  -->  00:02:08.630
two goes into 11 five times, you get 10.
52

52

00:02:08.630  -->  00:02:11.763
And then 11 minus 10 gives you a remainder of one.
53

53

00:02:12.600  -->  00:02:14.560
So again, for every even number,
54

54

00:02:14.560  -->  00:02:17.660
the remainder when divided by two is always zero.
55

55

00:02:17.660  -->  00:02:18.920
And for every odd number,
56

56

00:02:18.920  -->  00:02:22.240
the remainder when divided by two is always one.
57

57

00:02:22.240  -->  00:02:24.220
So we can use this knowledge to check
58

58

00:02:24.220  -->  00:02:27.120
whether any arbitrary number is odd or even.
59

59

00:02:27.120  -->  00:02:29.820
Let's say we've got an arbitrary number, 37.
60

60

00:02:29.820  -->  00:02:31.630
This could be the user's age,
61

61

00:02:31.630  -->  00:02:33.650
or it could be the row number
62

62

00:02:33.650  -->  00:02:35.600
in a table or something like that.
63

63

00:02:35.600  -->  00:02:38.350
And then we wanna calculate whether it is odd or even.
64

64

00:02:38.350  -->  00:02:41.480
What we have to do is we have to get the modulus operator
65

65

00:02:41.480  -->  00:02:43.670
and calculate the remainder of this number
66

66

00:02:43.670  -->  00:02:45.300
when divided by two.
67

67

00:02:45.300  -->  00:02:50.010
So we will say remainder equal x percent two.
68

68

00:02:50.010  -->  00:02:52.780
Now notice that we've got this variable remainder,
69

69

00:02:52.780  -->  00:02:53.980
which we used earlier on.
70

70

00:02:53.980  -->  00:02:56.100
That's totally fine, this is just the variable name.
71

71

00:02:56.100  -->  00:02:57.350
You can call it whatever you want,
72

72

00:02:57.350  -->  00:02:59.770
you can even reuse a previous variable name,
73

73

00:02:59.770  -->  00:03:01.120
and that's fine.
74

74

00:03:01.120  -->  00:03:03.690
What we've done here is we've got the value x modulus two,
75

75

00:03:03.690  -->  00:03:05.390
which is the remainder of the division,
76

76

00:03:05.390  -->  00:03:07.540
and we've said that the remainder variable
77

77

00:03:07.540  -->  00:03:11.210
that we created earlier is now a name for this value.
78

78

00:03:11.210  -->  00:03:13.810
So that just reassigns that variable.
79

79

00:03:13.810  -->  00:03:15.510
If we print it out,
80

80

00:03:15.510  -->  00:03:18.500
you'll see that the output should be one.
81

81

00:03:18.500  -->  00:03:21.500
But before running, I'm just going to delete this code here.
82

82

00:03:22.530  -->  00:03:23.723
And now let's run this.
83

83

00:03:24.660  -->  00:03:26.400
You see that we get one back,
84

84

00:03:26.400  -->  00:03:28.953
which tells us this number here is odd.
85

85

00:03:29.950  -->  00:03:30.800
Think about this,
86

86

00:03:30.800  -->  00:03:33.040
have you ever seen a table online
87

87

00:03:33.040  -->  00:03:35.350
where each row has a different colour?
88

88

00:03:35.350  -->  00:03:37.660
So for example, the first row is grey,
89

89

00:03:37.660  -->  00:03:39.840
second one's white, third one's grey,
90

90

00:03:39.840  -->  00:03:40.673
the fourth one's white.
91

91

00:03:40.673  -->  00:03:42.803
So you've got this sort of pattern.
92

92

00:03:43.650  -->  00:03:46.260
This is a perfect example of where the remainder,
93

93

00:03:46.260  -->  00:03:47.400
or being able to calculate
94

94

00:03:47.400  -->  00:03:50.253
whether a number is odd or even comes into play.
95

95

00:03:51.490  -->  00:03:55.020
They are probably using this to only target the even rows
96

96

00:03:55.020  -->  00:03:57.440
and colour them in a grey background.
97

97

00:03:57.440  -->  00:03:59.710
Throughout the course, we may also encounter other instances
98

98

00:03:59.710  -->  00:04:01.420
where this can be useful.
99

99

00:04:01.420  -->  00:04:02.450
But that's it for this video,
100

100

00:04:02.450  -->  00:04:03.530
thank you for joining me
101

101

00:04:03.530  -->  00:04:05.180
and I'll see you in the next one.
