WEBVTT
1
1

00:00:00.710  -->  00:00:02.710
<v Jose>Hi guys, and welcome back.</v>
2

2

00:00:02.710  -->  00:00:06.180
In this video, we're going to learn more about for loops,
3

3

00:00:06.180  -->  00:00:10.903
by creating a mathematical programme that finds prime numbers.
4

4

00:00:11.830  -->  00:00:14.850
Let's start off by finding the prime numbers
5

5

00:00:14.850  -->  00:00:17.480
under the number 10, so we will do
6

6

00:00:17.480  -->  00:00:21.313
for n in range two to 10.
7

7

00:00:22.400  -->  00:00:25.700
And that means that we're going to get a new variable n,
8

8

00:00:25.700  -->  00:00:27.800
and it's going to be equal to two the first time
9

9

00:00:27.800  -->  00:00:29.920
that the loop runs, then it will be three
10

10

00:00:29.920  -->  00:00:31.630
the second time it runs, and then four
11

11

00:00:31.630  -->  00:00:33.760
and so on, up until nine.
12

12

00:00:33.760  -->  00:00:34.660
We're gonna start at two,
13

13

00:00:34.660  -->  00:00:36.663
because it is the first prime number.
14

14

00:00:38.040  -->  00:00:41.583
Now, how do you check whether a number is prime or not?
15

15

00:00:42.490  -->  00:00:44.700
What you'll want to do, is you wanna see
16

16

00:00:44.700  -->  00:00:49.700
whether n is divisible by any number other than itself.
17

17

00:00:51.350  -->  00:00:53.390
So, how do we do that?
18

18

00:00:53.390  -->  00:00:57.750
Well if n is two, we know that it's a prime number
19

19

00:00:57.750  -->  00:01:01.600
because two is only divisible by one and two.
20

20

00:01:01.600  -->  00:01:05.310
If n is three, or what we could do is we could check
21

21

00:01:05.310  -->  00:01:08.430
whether n is divisible by two, and if it's not
22

22

00:01:08.430  -->  00:01:10.550
then we know it's a prime number.
23

23

00:01:10.550  -->  00:01:11.860
So why is that?
24

24

00:01:11.860  -->  00:01:13.563
Well, imagine the number three.
25

25

00:01:14.600  -->  00:01:18.350
There are only two numbers underneath it, one and two,
26

26

00:01:18.350  -->  00:01:21.070
and we know that a prime number can only be divisible
27

27

00:01:21.070  -->  00:01:24.320
by one or itself in order to be prime,
28

28

00:01:24.320  -->  00:01:27.360
so the only number we have to check is two.
29

29

00:01:27.360  -->  00:01:29.860
If three is not divisible by two,
30

30

00:01:29.860  -->  00:01:31.760
we know it's a prime number.
31

31

00:01:31.760  -->  00:01:33.230
Let's move on to four.
32

32

00:01:33.230  -->  00:01:35.190
For the number four, we only have to check
33

33

00:01:35.190  -->  00:01:37.840
numbers two and three.
34

34

00:01:37.840  -->  00:01:40.180
If four is divisible by two,
35

35

00:01:40.180  -->  00:01:42.030
then we know that it's not prime,
36

36

00:01:42.030  -->  00:01:44.740
so for every number under the number
37

37

00:01:44.740  -->  00:01:46.600
we wanna check, we need to see
38

38

00:01:46.600  -->  00:01:48.233
whether it's divisible or not.
39

39

00:01:49.090  -->  00:01:50.210
So what we're gonna do is we're
40

40

00:01:50.210  -->  00:01:52.443
going to create another for loop,
41

41

00:01:53.560  -->  00:01:58.053
that actually goes from two up to the number n.
42

42

00:01:59.290  -->  00:02:01.020
Remember, imagine we wanted to check
43

43

00:02:01.020  -->  00:02:06.020
whether four is prime, then we would check two and three.
44

44

00:02:07.440  -->  00:02:09.490
If we wanted to check eight, then we would check
45

45

00:02:09.490  -->  00:02:11.810
two three four five six and seven.
46

46

00:02:11.810  -->  00:02:13.680
And what we do inside this inner loop
47

47

00:02:13.680  -->  00:02:17.830
is we say if n modulus x is zero,
48

48

00:02:17.830  -->  00:02:22.830
that means n divided by x gives you a remainder of zero,
49

49

00:02:23.090  -->  00:02:28.090
then we can print something like n equals x
50

50

00:02:29.110  -->  00:02:31.643
multiplied by n divide divide x.
51

51

00:02:33.400  -->  00:02:35.190
And then we'll break.
52

52

00:02:35.190  -->  00:02:39.880
What this is doing is, imagine we are iteration number four,
53

53

00:02:39.880  -->  00:02:43.600
we will then start at two, and we will say
54

54

00:02:43.600  -->  00:02:48.600
if four divided by two gives you a remainder of zero,
55

55

00:02:48.700  -->  00:02:52.163
then print four equals two times two.
56

56

00:02:53.000  -->  00:02:54.763
And then we will break.
57

57

00:02:55.610  -->  00:03:00.610
Notice that the break keyword is inside two for loops.
58

58

00:03:01.030  -->  00:03:05.150
The break keyword and the continue keyword only affect
59

59

00:03:05.150  -->  00:03:09.450
the closest for loop to them, so only this loop would break.
60

60

00:03:09.450  -->  00:03:11.740
This loop here would not break.
61

61

00:03:11.740  -->  00:03:13.550
So what does this mean?
62

62

00:03:13.550  -->  00:03:18.550
Well, as soon as we find that n is divisible by x,
63

63

00:03:18.660  -->  00:03:23.190
that means that we know that n is not a prime number.
64

64

00:03:23.190  -->  00:03:25.960
So, we don't have to check anymore numbers.
65

65

00:03:25.960  -->  00:03:28.740
All we have to do is print that it equals something
66

66

00:03:28.740  -->  00:03:31.280
that can be divided, so it's not a prime number.
67

67

00:03:31.280  -->  00:03:34.570
However, imagine we've got iteration number five.
68

68

00:03:34.570  -->  00:03:36.880
Well, we'll start with x is two,
69

69

00:03:36.880  -->  00:03:39.280
and the remainder will not be zero,
70

70

00:03:39.280  -->  00:03:42.050
so we will not run this code.
71

71

00:03:42.050  -->  00:03:45.240
Then, five divided by three will also not give you
72

72

00:03:45.240  -->  00:03:48.190
a remainder of zero, so we will also not run this code.
73

73

00:03:48.190  -->  00:03:50.630
Finally, five divided by four will also
74

74

00:03:50.630  -->  00:03:52.970
not cause to run this code.
75

75

00:03:52.970  -->  00:03:56.870
So, when the number is prime,
76

76

00:03:56.870  -->  00:04:00.033
this loop here will never break.
77

77

00:04:01.210  -->  00:04:06.103
Therefore, we can put an else keyword in this loop.
78

78

00:04:07.240  -->  00:04:10.760
Which means, if this loop runs to completion
79

79

00:04:10.760  -->  00:04:15.243
without encountering any breaks, n is prime.
80

80

00:04:21.090  -->  00:04:23.060
Let's run this, and you'll see the output.
81

81

00:04:23.060  -->  00:04:25.800
It's quite magical, you get two is a prime number,
82

82

00:04:25.800  -->  00:04:28.500
three is a prime number, four equals two times two.
83

83

00:04:28.500  -->  00:04:30.950
Something interesting about this is you can see that
84

84

00:04:30.950  -->  00:04:35.820
as soon as we encounter one thing that it is divisible by,
85

85

00:04:35.820  -->  00:04:38.040
then we break and we don't have to check
86

86

00:04:38.040  -->  00:04:40.230
whether nine is divisible by four,
87

87

00:04:40.230  -->  00:04:42.510
and then whether nine is divisible by five and by six
88

88

00:04:42.510  -->  00:04:45.030
and by seven, as soon as we encounter that nine
89

89

00:04:45.030  -->  00:04:48.510
is divisible by three, we just stop, and that's it.
90

90

00:04:48.510  -->  00:04:51.580
So this here is actually quite a convoluted piece of code
91

91

00:04:51.580  -->  00:04:54.040
because you've got a nested for loop.
92

92

00:04:54.040  -->  00:04:56.630
And you're also making use of this else keyword,
93

93

00:04:56.630  -->  00:04:59.450
that again, most people don't know about.
94

94

00:04:59.450  -->  00:05:01.070
But hopefully it makes sense,
95

95

00:05:01.070  -->  00:05:03.100
if you have any questions, please do ask
96

96

00:05:03.100  -->  00:05:04.640
in the course Q and A.
97

97

00:05:04.640  -->  00:05:07.360
As a small optimization, in case that you get asked
98

98

00:05:07.360  -->  00:05:09.330
in an interview or something like that,
99

99

00:05:09.330  -->  00:05:12.240
you don't have to check this loop from two to n.
100

100

00:05:12.240  -->  00:05:14.640
You actually mathematically only have to check
101

101

00:05:14.640  -->  00:05:17.260
from two to the square root of n.
102

102

00:05:17.260  -->  00:05:19.900
That's just how finding prime numbers works,
103

103

00:05:19.900  -->  00:05:22.210
they're using Erastothenes' sieve,
104

104

00:05:22.210  -->  00:05:25.483
but again, it's not really important for this code.
105

105

00:05:26.770  -->  00:05:28.510
Thank you for joining me in this video,
106

106

00:05:28.510  -->  00:05:29.630
I hope you've learned something,
107

107

00:05:29.630  -->  00:05:31.280
and I'll see you in the next one.
