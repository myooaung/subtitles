WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.100
Hello everyone, Welcome back.

00:00:02.100 --> 00:00:04.155
So we have another simple example,

00:00:04.155 --> 00:00:06.105
how a product can be added,

00:00:06.105 --> 00:00:08.220
ok, but we don't know what type it is going to come.

00:00:08.220 --> 00:00:12.660
So we use an object and we have a problem with the typecasting and delta,

00:00:12.660 --> 00:00:14.130
because when you go for typecasting,

00:00:14.130 --> 00:00:16.770
obviously it will perform even.

00:00:16.770 --> 00:00:19.845
I mean, obviously it will impact your performance, correct?

00:00:19.845 --> 00:00:22.695
Okay. Let us try to modify the same in a different way.

00:00:22.695 --> 00:00:24.750
Which means I'm going to come out this class into

00:00:24.750 --> 00:00:28.515
a generic class and we'll see how it is going to work.

00:00:28.515 --> 00:00:32.850
So I don't want to aid the existing classes,

00:00:32.850 --> 00:00:35.260
so I'm going to comment it out simply.

00:00:35.260 --> 00:00:38.030
And then I'm going to create a new class here.

00:00:38.030 --> 00:00:40.685
And I'm just like a product here, right?

00:00:40.685 --> 00:00:42.470
So I'm going to create a product one,

00:00:42.470 --> 00:00:43.580
something like that because you can keep

00:00:43.580 --> 00:00:46.010
the existing code because I'm going to check and all of the code.

00:00:46.010 --> 00:00:50.660
So this is going to be product 1.

00:00:50.660 --> 00:00:56.370
Okay, now, let me create a constructor here.

00:00:56.650 --> 00:00:59.060
Okay, so now I have a class.

00:00:59.060 --> 00:01:02.465
It doesn't have any datacenter because I'm going to use data object.

00:01:02.465 --> 00:01:04.475
So the first thing first,

00:01:04.475 --> 00:01:07.370
this is not a generic class and we want

00:01:07.370 --> 00:01:10.460
a product ID and description and we don't know what is the type that's going to come.

00:01:10.460 --> 00:01:12.695
So what I'm gonna do, I'm gonna draw,

00:01:12.695 --> 00:01:16.070
I'm going to try to use two parameters here,

00:01:16.070 --> 00:01:18.080
two type parameters for that class,

00:01:18.080 --> 00:01:19.580
which means this is my class,

00:01:19.580 --> 00:01:23.360
this is a normal class and the moment when you introduce the diamond symbol,

00:01:23.360 --> 00:01:24.635
it becomes the generic class.

00:01:24.635 --> 00:01:27.230
And now I'm going to have something like p,

00:01:27.230 --> 00:01:29.255
which is nothing but it's a product ID.

00:01:29.255 --> 00:01:31.535
And the next one, you, The second,

00:01:31.535 --> 00:01:35.210
because if you have only one interesting little parameterized generic class,

00:01:35.210 --> 00:01:39.440
because they're generic classes can have multiple parameters.

00:01:39.440 --> 00:01:40.730
So now I have the two,

00:01:40.730 --> 00:01:43.550
so but t and u, right?

00:01:43.550 --> 00:01:45.020
So you can keep anything,

00:01:45.020 --> 00:01:46.250
whatever you want instead of t,

00:01:46.250 --> 00:01:48.755
you can have something like product aswell.

00:01:48.755 --> 00:01:50.630
And interrupt you.

00:01:50.630 --> 00:01:55.265
You can have description as well, right?

00:01:55.265 --> 00:02:01.400
And now, so here I have a product and description and I don't need an object here.

00:02:01.400 --> 00:02:03.890
Okay, So I want to have the generic here.

00:02:03.890 --> 00:02:07.145
So what I'm gonna do, the product ID becomes the product parity generics,

00:02:07.145 --> 00:02:09.095
which I provided in the class level,

00:02:09.095 --> 00:02:12.260
and the description becomes the description generates.

00:02:12.260 --> 00:02:13.880
So now what do we need to do?

00:02:13.880 --> 00:02:15.345
So it has to be changed.

00:02:15.345 --> 00:02:21.090
It, so I'm just trying to modify this as well.

00:02:23.350 --> 00:02:28.535
Okay, so now I changed my class into a generic class.

00:02:28.535 --> 00:02:34.730
Now let me try to create an object and I'll show you what is the advantage of it.

00:02:34.730 --> 00:02:39.200
So let me, I'm going back to the main method and here,

00:02:39.200 --> 00:02:41.750
product, I'm creating a product one.

00:02:41.750 --> 00:02:45.560
See the moment you create a product one it asks you brought and description.

00:02:45.560 --> 00:02:47.660
So you have to provide what is it type?

00:02:47.660 --> 00:02:50.255
Because product and discrimination said it's a type parameters.

00:02:50.255 --> 00:02:51.890
So in place of product,

00:02:51.890 --> 00:02:55.910
you have to prove it any type in place of description you had a proper anytime.

00:02:55.910 --> 00:02:57.200
So what am I going to use?

00:02:57.200 --> 00:02:58.850
So quantitative is an integer, right?

00:02:58.850 --> 00:03:00.560
So I'm going to use an integer here.

00:03:00.560 --> 00:03:02.270
Got it. And the second thing,

00:03:02.270 --> 00:03:04.680
so description is going to be string.

00:03:05.110 --> 00:03:13.790
And then it's going to be brought new product 1.

00:03:13.790 --> 00:03:17.045
And here we need to provide the data.

00:03:17.045 --> 00:03:18.980
So the first one is one-to-one,

00:03:18.980 --> 00:03:20.960
which is my product ID as an integer.

00:03:20.960 --> 00:03:23.690
And the second one is going to be important description I can grow.

00:03:23.690 --> 00:03:25.430
It just simply says soap.

00:03:25.430 --> 00:03:26.840
Okay, Here is the deal.

00:03:26.840 --> 00:03:28.910
So before when we're using object,

00:03:28.910 --> 00:03:32.735
we need to typecast the data in order to receive them.

00:03:32.735 --> 00:03:34.250
But here I'm using generics.

00:03:34.250 --> 00:03:36.110
So in January, so the advantage of using genetics,

00:03:36.110 --> 00:03:37.595
we don't have to typecast it, right?

00:03:37.595 --> 00:03:42.650
So broad dot product ID,

00:03:42.650 --> 00:03:45.875
okay, or not, it is not visible here y.

00:03:45.875 --> 00:03:48.650
Okay, so I just kept it as a private here.

00:03:48.650 --> 00:03:52.340
So I just modify remote private

00:03:52.340 --> 00:03:54.890
here just in case if you have a getters and setters so you

00:03:54.890 --> 00:03:57.500
don't need to remove the private.

00:03:57.500 --> 00:03:59.030
You can Database a get method.

00:03:59.030 --> 00:04:02.030
So here, now I can use the product ID.

00:04:02.030 --> 00:04:05.790
Okay, so now we've got the product ID.

00:04:06.880 --> 00:04:09.905
So it's a integer here.

00:04:09.905 --> 00:04:12.710
I don't need to convert that into an integer,

00:04:12.710 --> 00:04:14.930
you might think, okay, you're just primitive into your head.

00:04:14.930 --> 00:04:18.200
That's not going to make much difference here and it's still walk.

00:04:18.200 --> 00:04:26.010
And again, broad dot product description.

00:04:26.230 --> 00:04:28.760
It's a string.

00:04:28.760 --> 00:04:30.335
So now here,

00:04:30.335 --> 00:04:38.030
you don't need any type casting at all because I'm using a generic.

00:04:38.030 --> 00:04:40.250
So genetic will take some type of inflammation.

00:04:40.250 --> 00:04:42.875
So how the information is passed on here?

00:04:42.875 --> 00:04:45.050
Because when I'm creating the product,

00:04:45.050 --> 00:04:46.190
I'm in January class, It's a lie.

00:04:46.190 --> 00:04:48.800
I'm letting you know the compiler saying like this is going to be integer

00:04:48.800 --> 00:04:51.770
as my first parameter and the second type is going to be string.

00:04:51.770 --> 00:04:53.150
So product is May first type,

00:04:53.150 --> 00:04:54.410
which means it's an integer.

00:04:54.410 --> 00:04:56.540
And description is my second type,

00:04:56.540 --> 00:04:58.790
which means it's a string, right?

00:04:58.790 --> 00:05:02.195
So let me print the information here.

00:05:02.195 --> 00:05:07.385
So O Net ID.

00:05:07.385 --> 00:05:10.265
And boron ID is going to be

00:05:10.265 --> 00:05:17.550
product photo ID

00:05:19.810 --> 00:05:28.730
and description.

00:05:28.730 --> 00:05:34.460
It's going to be for a description.

00:05:34.460 --> 00:05:38.090
So now let's run the code and we'll see what's going to happen.

00:05:38.090 --> 00:05:40.790
Say it's much better now,

00:05:40.790 --> 00:05:43.625
prototype is 121 and product description is slope.

00:05:43.625 --> 00:05:45.484
So when the breeze example,

00:05:45.484 --> 00:05:47.090
what are the type we are going to pass it?

00:05:47.090 --> 00:05:50.060
You need to do casting it MLA,

00:05:50.060 --> 00:05:52.910
but here we don't have to do it because it's a type parameter.

00:05:52.910 --> 00:05:53.930
When you're passing the type,

00:05:53.930 --> 00:05:55.715
it becomes the type safety.

00:05:55.715 --> 00:05:58.460
And you don't have to do the when you're trying to

00:05:58.460 --> 00:06:01.385
retrieve some information from that you don't have to type cast to them.

00:06:01.385 --> 00:06:04.280
So there we are avoiding the typecasting,

00:06:04.280 --> 00:06:06.380
which means when you're using collection,

00:06:06.380 --> 00:06:09.575
you need to do typecasting and type casting issue,

00:06:09.575 --> 00:06:11.570
type safety and type casting issues there in

00:06:11.570 --> 00:06:14.195
the collection and that has been resolved here.

00:06:14.195 --> 00:06:17.465
And now you might think so what happened if I,

00:06:17.465 --> 00:06:20.165
if I want to pass a string and a string that we can

00:06:20.165 --> 00:06:25.820
use product ideas or string SQL like this.

00:06:25.820 --> 00:06:30.215
So product one and the first type I'm going to,

00:06:30.215 --> 00:06:33.575
the product type is going to be string here.

00:06:33.575 --> 00:06:37.535
And again the description also it's going to be string.

00:06:37.535 --> 00:06:46.040
And then it's going to be proud 1 is equal to new product.

00:06:46.040 --> 00:06:50.015
And here I'm going to provide some,

00:06:50.015 --> 00:06:53.495
some cool like so ie the SUMPRODUCT code.

00:06:53.495 --> 00:06:58.200
And again it is going to be a soap.

00:06:59.590 --> 00:07:01.235
C.

00:07:01.235 --> 00:07:02.915
Still, there is no issues.

00:07:02.915 --> 00:07:06.395
I can still retrieve the same way like

00:07:06.395 --> 00:07:12.180
broad one dot and you're going to get deported to ID.

00:07:13.060 --> 00:07:15.680
It's the string automatically,

00:07:15.680 --> 00:07:16.940
it gets that data,

00:07:16.940 --> 00:07:18.890
it's going to be a string because it does knows

00:07:18.890 --> 00:07:21.245
that because I have the type parameter here.

00:07:21.245 --> 00:07:24.230
And then I'm going to take the description as well.

00:07:24.230 --> 00:07:28.670
Proud one dot prod, sorry.

00:07:28.670 --> 00:07:31.865
Product description.

00:07:31.865 --> 00:07:35.400
So what happened? It's a string again.

00:07:35.920 --> 00:07:40.340
Sorry. So here what I can do,

00:07:40.340 --> 00:07:44.360
I can simply provide the CSO out until

00:07:44.360 --> 00:07:50.060
C. So here's what I can do is instead of prototyping,

00:07:50.060 --> 00:07:52.440
I can use the product ID one.

00:07:52.720 --> 00:07:56.780
I can use deported description one.

00:07:56.780 --> 00:08:00.530
So once the product ID is an integer and add

00:08:00.530 --> 00:08:03.920
doesn't extend the product data center string.

00:08:03.920 --> 00:08:06.140
So but we're not modifying anything in the code,

00:08:06.140 --> 00:08:08.150
we are just passing different kinda types,

00:08:08.150 --> 00:08:09.680
but still my code works.

00:08:09.680 --> 00:08:11.850
So let me run this.

00:08:12.250 --> 00:08:14.600
See it still works.

00:08:14.600 --> 00:08:18.139
So this is the advantage of using the generics

00:08:18.139 --> 00:08:22.070
and this is called as a generic class B have,

00:08:22.070 --> 00:08:25.085
we haven't talked about the methods because when it comes to generic,

00:08:25.085 --> 00:08:28.685
we have generic classes and we have generic methods as well.

00:08:28.685 --> 00:08:31.430
We just spoke about only the generic class.

00:08:31.430 --> 00:08:33.960
So let's more than X1.
