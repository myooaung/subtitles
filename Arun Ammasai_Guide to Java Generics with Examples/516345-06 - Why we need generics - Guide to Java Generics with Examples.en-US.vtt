WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.235
Hello everyone, Welcome back.

00:00:02.235 --> 00:00:05.910
Who we discussed about the difference between a recent collection and how both

00:00:05.910 --> 00:00:09.899
can be work and what is the advantage of array and what is the advantage of collections.

00:00:09.899 --> 00:00:13.125
So now why we need to go, what do January's?

00:00:13.125 --> 00:00:18.660
So there are something missing in our recent collection which is available in generics,

00:00:18.660 --> 00:00:22.370
which means the issues have been addressed in January.

00:00:22.370 --> 00:00:23.535
So what on that?

00:00:23.535 --> 00:00:26.445
So the first thing that is a problem in RSM collection,

00:00:26.445 --> 00:00:28.710
all of them has been undernourished in January.

00:00:28.710 --> 00:00:32.130
So what is that array has a size limit collection.

00:00:32.130 --> 00:00:37.320
It doesn't. But I raise is much faster because they don't have the type casting,

00:00:37.320 --> 00:00:38.640
because they don't need to,

00:00:38.640 --> 00:00:40.500
because there is a tightly coupled one.

00:00:40.500 --> 00:00:42.250
But when it comes to collision,

00:00:42.250 --> 00:00:43.700
you need to do typecasting.

00:00:43.700 --> 00:00:47.810
So that is a reason is, I mean collection is slower than the array.

00:00:47.810 --> 00:00:50.630
Okay, so there are two issues, right?

00:00:50.630 --> 00:00:52.160
So take a look at the third.

00:00:52.160 --> 00:00:54.620
No need to type casting the data in generics.

00:00:54.620 --> 00:00:56.930
So this has been addressed in

00:00:56.930 --> 00:01:00.395
degeneracies that this is not available in the collections, right?

00:01:00.395 --> 00:01:05.510
And the second compiled them safeties enables us to avoid unwanted are invalid type,

00:01:05.510 --> 00:01:07.820
but when it is happening,

00:01:07.820 --> 00:01:09.830
it's happening in the compile-time itself.

00:01:09.830 --> 00:01:12.650
So you don't have to wait until total production now or it just

00:01:12.650 --> 00:01:15.785
go to any environment deployed and then it will turn into Mexico.

00:01:15.785 --> 00:01:18.650
So we can avoid all of them a lot earlier.

00:01:18.650 --> 00:01:22.010
And the last one, 11 method, that's simple,

00:01:22.010 --> 00:01:25.130
one ml dot which will solve multiple problems,

00:01:25.130 --> 00:01:30.380
or a single method which will accept the different kind of, uh, types.

00:01:30.380 --> 00:01:33.875
So normally when a method accepts a string as an input,

00:01:33.875 --> 00:01:36.275
which will always takes a string.

00:01:36.275 --> 00:01:38.870
But if the same at that as a general case,

00:01:38.870 --> 00:01:40.355
it can accept string,

00:01:40.355 --> 00:01:43.670
it can accept integer and double long or student,

00:01:43.670 --> 00:01:45.830
DTU or employee to do whatever it is.

00:01:45.830 --> 00:01:50.910
So that is the ultimate goal of generics.

00:01:51.190 --> 00:01:56.209
So now we have a basic idea about generics.

00:01:56.209 --> 00:01:59.120
Now, the next thing we're going to talk about,

00:01:59.120 --> 00:02:02.390
so what are the things that are available inside a generates?

00:02:02.390 --> 00:02:06.980
So, uh, it is generally class and genetic methods.

00:02:06.980 --> 00:02:13.400
So we're going to talk about how you can create a generic class and how you can use them.

00:02:13.400 --> 00:02:18.330
So let's jump into an example and we'll see how this looks like.
