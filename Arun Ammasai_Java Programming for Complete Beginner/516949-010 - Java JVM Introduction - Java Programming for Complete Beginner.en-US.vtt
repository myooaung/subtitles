WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:02.805
Hello everyone, Welcome back.

00:00:02.805 --> 00:00:04.860
So we discussed what are

00:00:04.860 --> 00:00:09.525
the some key features and people way they're going for Java, right?

00:00:09.525 --> 00:00:17.060
So now let's talk about the TV because we discussed a boat,

00:00:17.060 --> 00:00:20.060
GRE and JDK, right.

00:00:20.060 --> 00:00:23.255
So now when spine for Docker JVM,

00:00:23.255 --> 00:00:25.280
so as I mentioned,

00:00:25.280 --> 00:00:30.830
you need GRE to execute the Java program, right?

00:00:30.830 --> 00:00:33.770
Or bytecode in a simpler way.

00:00:33.770 --> 00:00:41.360
So helium is the one who's doing the job actually DID,

00:00:41.360 --> 00:00:44.465
which we needed for executing a bytecode.

00:00:44.465 --> 00:00:46.475
But instead the GRE,

00:00:46.475 --> 00:00:51.005
who's doing the job actually gave him is the one who's doing a particular job. Okay.

00:00:51.005 --> 00:00:52.325
Let's see.

00:00:52.325 --> 00:00:58.210
So JVM, which will available anywhere PC, I mean,

00:00:58.210 --> 00:00:59.530
when you install JDK rate,

00:00:59.530 --> 00:01:01.495
which will be installed as part of

00:01:01.495 --> 00:01:06.130
your installation process and which will be under GRE folder?

00:01:06.130 --> 00:01:09.295
Correct. And it understands the mission language,

00:01:09.295 --> 00:01:11.230
which is a bytecode.

00:01:11.230 --> 00:01:17.845
And JVM executes the code generated by the Java compiler.

00:01:17.845 --> 00:01:19.285
Right?

00:01:19.285 --> 00:01:21.715
Because JVM is resides in the

00:01:21.715 --> 00:01:25.360
GRE RED geriatric and execute the code with the help of JVM.

00:01:25.360 --> 00:01:26.005
Correct.

00:01:26.005 --> 00:01:30.460
So JVM cannot compel the code because that is a part of JDK.

00:01:30.460 --> 00:01:34.060
Jdk, we have a compiler which will compel the courts adjudicate,

00:01:34.060 --> 00:01:36.445
compile the code and pass under the JRE.

00:01:36.445 --> 00:01:39.190
Jre pass onto the JVM because JVM is the one who can

00:01:39.190 --> 00:01:43.320
read by core and it will show the outcome.

00:01:43.360 --> 00:01:45.560
And to be very frank,

00:01:45.560 --> 00:01:49.609
JVM is the one who makes the platform at the independent.

00:01:49.609 --> 00:01:54.185
Because as I mentioned, each and every different platform which has its own JVM.

00:01:54.185 --> 00:01:55.895
But what the exact thing,

00:01:55.895 --> 00:01:57.620
even though if it is a different idea,

00:01:57.620 --> 00:02:02.105
VM's everything produce the same outcome, correct?

00:02:02.105 --> 00:02:06.395
Since they're all producing the same result in a different platform.

00:02:06.395 --> 00:02:10.055
That is why it is called as a platform independent, right?

00:02:10.055 --> 00:02:14.060
So which means I developed my code in Linux and

00:02:14.060 --> 00:02:19.355
I'm able to exhibit the same good and Mac also in the next.

00:02:19.355 --> 00:02:22.560
So that is called as a platform independent.

00:02:23.440 --> 00:02:30.200
Okay, so let's take a look at how the JVM works.

00:02:30.200 --> 00:02:33.755
Just take at this particular diagram,

00:02:33.755 --> 00:02:38.780
you can easily understand how the entire process walking.

00:02:38.780 --> 00:02:40.760
You're writing your program,

00:02:40.760 --> 00:02:43.370
which is nothing but dot Java file,

00:02:43.370 --> 00:02:44.795
Correct? That's the first step.

00:02:44.795 --> 00:02:46.220
Okay, so what are the next step?

00:02:46.220 --> 00:02:48.185
You are compiling the code.

00:02:48.185 --> 00:02:51.650
You mean the compiler will compile the dot Java file

00:02:51.650 --> 00:02:54.950
called The reason we need to validate and we need to preach it.

00:02:54.950 --> 00:02:56.420
Whether is there any validation issue,

00:02:56.420 --> 00:03:00.410
all the rules and conditions has been placed properly in your program.

00:03:00.410 --> 00:03:03.245
Compilation will do the work for you.

00:03:03.245 --> 00:03:06.095
And then if companies in a success,

00:03:06.095 --> 00:03:10.070
it really generator dot class file because from dad Java it will

00:03:10.070 --> 00:03:14.330
convert it to another file or create another file called a dot class file,

00:03:14.330 --> 00:03:17.270
which contains the bytecode.

00:03:17.270 --> 00:03:19.790
Great, once the bytecode is

00:03:19.790 --> 00:03:25.040
already the code is ready for execution for seeing the output.

00:03:25.040 --> 00:03:26.765
Okay, So who is doing the job?

00:03:26.765 --> 00:03:29.195
So bytecode has been handled to the JRE.

00:03:29.195 --> 00:03:31.055
Jre contains JVM, right?

00:03:31.055 --> 00:03:34.250
So here the bytecode directly sending to the JVM,

00:03:34.250 --> 00:03:41.360
which will interpret the data and print in the operating system or any platforms.

00:03:41.360 --> 00:03:44.750
See, we have an interpreter for a Windows, Linux, and Mac, right?

00:03:44.750 --> 00:03:47.884
But each of them have own JVMs.

00:03:47.884 --> 00:03:50.225
You're writing program in one operating system

00:03:50.225 --> 00:03:52.715
and you can execute in the rest of the operating systems.

00:03:52.715 --> 00:03:55.410
All you need is a JVM.

00:03:55.990 --> 00:03:57.500
Great.

00:03:57.500 --> 00:04:00.560
So not only dad,

00:04:00.560 --> 00:04:03.470
JVM has its own architecture.

00:04:03.470 --> 00:04:08.045
Okay, And so because JVM bytecode,

00:04:08.045 --> 00:04:09.800
so instead the JVM is that there are

00:04:09.800 --> 00:04:13.340
multiple containers which will take an H and individual job.

00:04:13.340 --> 00:04:16.895
Okay. We'll talk about what is available inside the JVM.

00:04:16.895 --> 00:04:19.775
I mean to say the architecture after JVM,

00:04:19.775 --> 00:04:23.900
how would this receiving a class style and what are the steps it is processing to show

00:04:23.900 --> 00:04:29.040
the output will talk about the architecture. The next video.
