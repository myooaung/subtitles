WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:00.000 --> 00:00:01.605
Hello everyone.

00:00:01.605 --> 00:00:03.000
Welcome back.

00:00:03.000 --> 00:00:06.060
We discussed a lot about access modifier.

00:00:06.060 --> 00:00:12.360
Now it's time for us to talk about the non-access modifier.

00:00:12.360 --> 00:00:13.455
Got it.

00:00:13.455 --> 00:00:14.850
So first of all,

00:00:14.850 --> 00:00:18.404
we need to understand what is non-acceptable modifiers.

00:00:18.404 --> 00:00:20.970
See the known access modifiers.

00:00:20.970 --> 00:00:23.100
They provide the information,

00:00:23.100 --> 00:00:25.005
a bolder behavior to the JVM,

00:00:25.005 --> 00:00:27.750
how the method or members of

00:00:27.750 --> 00:00:32.915
the class it has to react based on the known access modifiers.

00:00:32.915 --> 00:00:35.795
Okay, so let's talk some thing.

00:00:35.795 --> 00:00:41.555
Non-access modifier, small access modifiers.

00:00:41.555 --> 00:00:44.630
First thing it is similar to the axiomatic first one,

00:00:44.630 --> 00:00:46.520
it will work against the class.

00:00:46.520 --> 00:00:50.270
So what did that non-active modifies?

00:00:50.270 --> 00:00:51.980
The first one is final,

00:00:51.980 --> 00:00:55.499
guarded and the second one is abstract.

00:00:56.860 --> 00:00:58.430
Okay?

00:00:58.430 --> 00:01:01.010
So one of these 2,

00:01:01.010 --> 00:01:05.490
second 1 is against the methods and variables.

00:01:13.260 --> 00:01:18.370
Methods and variables, and it is uploaded for constructors as well.

00:01:18.370 --> 00:01:21.160
So the first thing, final,

00:01:21.160 --> 00:01:24.355
and the second one, static.

00:01:24.355 --> 00:01:27.619
And the third one is abstract.

00:01:27.660 --> 00:01:31.480
And the fourth one is a transient.

00:01:31.480 --> 00:01:35.750
And the fourth one is synchronized.

00:01:37.620 --> 00:01:42.290
Synchronized, and the last one is a word island.

00:01:44.850 --> 00:01:46.375
Right?

00:01:46.375 --> 00:01:49.195
So what is the final when you define that?

00:01:49.195 --> 00:01:51.730
Because finally, it's a non-access modifier.

00:01:51.730 --> 00:02:02.010
So when you define a class at a final which means cannot inherit, inherit the property.

00:02:03.880 --> 00:02:09.125
Okay? So that's what happened on new use finite, right?

00:02:09.125 --> 00:02:14.990
So you have a class which contains some operations or methods or functionality,

00:02:14.990 --> 00:02:16.910
and you don't want anyone to use it.

00:02:16.910 --> 00:02:18.920
You need to keep it for yourself.

00:02:18.920 --> 00:02:24.410
So those scenarios, you need to create a class with a final keyword,

00:02:24.410 --> 00:02:31.340
which will allow us to do the inherit operation, grid and abstract.

00:02:31.340 --> 00:02:37.400
So upsert is basically different thing basically they absolutely create.

00:02:37.400 --> 00:02:40.670
That's a useful to create abstract methods, right?

00:02:40.670 --> 00:02:44.105
So if you want to know what is abstract methods,

00:02:44.105 --> 00:02:46.655
and we have a separate session for that bit abstract.

00:02:46.655 --> 00:02:48.590
So if you want to put in a simple way,

00:02:48.590 --> 00:02:49.790
if you create an abstract class,

00:02:49.790 --> 00:02:51.545
you can create the object for it.

00:02:51.545 --> 00:02:56.495
You cannot instantiate the object and the purpose.

00:02:56.495 --> 00:03:02.760
You cannot, cannot create objects.

00:03:06.550 --> 00:03:08.525
Okay?

00:03:08.525 --> 00:03:13.700
We don't have much on abstract because they have a separate session for it.

00:03:13.700 --> 00:03:15.425
Because when you're talking about, oops, concept,

00:03:15.425 --> 00:03:19.715
we have a very big examples and the definitions for abstract.

00:03:19.715 --> 00:03:22.040
Now let's go to the final.

00:03:22.040 --> 00:03:26.600
So what do you mean be final when you use final means,

00:03:26.600 --> 00:03:27.740
this cannot be modified.

00:03:27.740 --> 00:03:30.470
It, if it is a variable you created as a final,

00:03:30.470 --> 00:03:34.175
you cannot be modify the value one more time.

00:03:34.175 --> 00:03:40.160
So when you, when you provide final index is equal to 10, That's our final.

00:03:40.160 --> 00:03:41.810
You cannot overwrite the data.

00:03:41.810 --> 00:03:48.780
So cannot or modified.

00:03:48.790 --> 00:03:53.000
And static, which means when you create something as

00:03:53.000 --> 00:03:58.520
a static current which is not belongs to an object,

00:03:58.520 --> 00:04:01.910
you just belongs to a class.

00:04:01.910 --> 00:04:02.735
Basically.

00:04:02.735 --> 00:04:04.355
Take an example of Helloworld.

00:04:04.355 --> 00:04:08.450
Okay, so let's go back to the Eclipse and I'm going to open the HelloWorld.java.

00:04:08.450 --> 00:04:10.820
This is a main method and you're trying to call artery

00:04:10.820 --> 00:04:13.595
creating an object or calling that. No, we're not doing that.

00:04:13.595 --> 00:04:14.885
Since it's a static method,

00:04:14.885 --> 00:04:16.460
It's won't buy a class.

00:04:16.460 --> 00:04:21.440
So the moment you are executing according to exactly executed by the competitor.

00:04:21.440 --> 00:04:22.985
By this way, the class name,

00:04:22.985 --> 00:04:28.460
dot main method and new string.

00:04:28.460 --> 00:04:30.725
So this is our class.

00:04:30.725 --> 00:04:34.040
The compiler I'm in the JVM will execute the code.

00:04:34.040 --> 00:04:35.135
Right?

00:04:35.135 --> 00:04:37.280
So since it's a static method,

00:04:37.280 --> 00:04:38.300
it belongs to a class,

00:04:38.300 --> 00:04:40.340
not belongs to an object that is where the main way that is

00:04:40.340 --> 00:04:44.255
accessible easily without an object, okay.

00:04:44.255 --> 00:04:50.525
Belongs to not to object.

00:04:50.525 --> 00:04:54.410
It doesn't mean began to access those static method using object.

00:04:54.410 --> 00:04:57.620
You can access anything using an object,

00:04:57.620 --> 00:05:00.095
but there are other ways to access the static.

00:05:00.095 --> 00:05:08.015
So abstract method without body,

00:05:08.015 --> 00:05:11.285
which means you can create abstract methods.

00:05:11.285 --> 00:05:13.580
Take an example of abstract drawings.

00:05:13.580 --> 00:05:15.245
If I look at the abstract by,

00:05:15.245 --> 00:05:17.000
I get some different perception.

00:05:17.000 --> 00:05:18.230
If somebody that's looking at

00:05:18.230 --> 00:05:21.230
the same abstract drawing and they'll have a different perception.

00:05:21.230 --> 00:05:22.970
Think about this. This is the example,

00:05:22.970 --> 00:05:26.195
better example again, there is a body, okay?

00:05:26.195 --> 00:05:27.680
Well, we're assuming the body,

00:05:27.680 --> 00:05:29.850
they become something else.

00:05:29.980 --> 00:05:31.490
Okay.

00:05:31.490 --> 00:05:32.420
I'm a person.

00:05:32.420 --> 00:05:33.860
If I'm taking the body,

00:05:33.860 --> 00:05:35.660
I become a human body.

00:05:35.660 --> 00:05:36.935
That becomes a human body.

00:05:36.935 --> 00:05:38.615
If an animal takes the body,

00:05:38.615 --> 00:05:40.730
which means the animal that bigger,

00:05:40.730 --> 00:05:44.540
that becomes animal's body is something else which takes the body,

00:05:44.540 --> 00:05:45.995
it is something else, body.

00:05:45.995 --> 00:05:51.410
So the object, whether one leaves get meaning meaningful when somebody is using it.

00:05:51.410 --> 00:05:52.430
Right?

00:05:52.430 --> 00:05:56.525
And transient is out on an important concept for serialization.

00:05:56.525 --> 00:05:59.580
So not to civilize.

00:06:00.310 --> 00:06:03.290
See relays in a different concept. We'll talk about that.

00:06:03.290 --> 00:06:04.880
So c less than means.

00:06:04.880 --> 00:06:10.190
Whenever the object are transferred through the Internet,

00:06:10.190 --> 00:06:12.110
our intranet, they will be serialized,

00:06:12.110 --> 00:06:15.425
which means they will be converted as a byte stream.

00:06:15.425 --> 00:06:16.505
Okay?

00:06:16.505 --> 00:06:20.750
Sarah, scenarios you need to tell the JVM,

00:06:20.750 --> 00:06:25.490
do not see relays this particular luminaire.

00:06:25.490 --> 00:06:27.605
You have a login username and password.

00:06:27.605 --> 00:06:31.160
You want only the password needs to be serialized.

00:06:31.160 --> 00:06:33.830
So username, I don't want to.

00:06:33.830 --> 00:06:34.850
So then what do you need to do?

00:06:34.850 --> 00:06:37.010
You need to create that variable,

00:06:37.010 --> 00:06:41.135
transient, transient string username.

00:06:41.135 --> 00:06:43.910
And once it's reached the destination,

00:06:43.910 --> 00:06:45.830
the password will be DC arrest.

00:06:45.830 --> 00:06:47.180
But they use an implementer.

00:06:47.180 --> 00:06:50.010
Same thing because it is not civilized.

00:06:50.740 --> 00:06:57.350
Synchronized, which means only one thread at a time.

00:06:57.350 --> 00:07:01.790
So you have some variable which will keep on updated by different,

00:07:01.790 --> 00:07:05.135
different threads or a common property. Okay?

00:07:05.135 --> 00:07:07.475
So if multiple threads at trying to,

00:07:07.475 --> 00:07:13.205
attempt to update the same variable, it will messed up.

00:07:13.205 --> 00:07:17.900
So when you create a variable or a method using

00:07:17.900 --> 00:07:21.650
synchronized other threads has

00:07:21.650 --> 00:07:25.085
to wait until unless the first method, astrophysics, the process.

00:07:25.085 --> 00:07:25.985
Okay?

00:07:25.985 --> 00:07:27.575
So if you're going for a purchase,

00:07:27.575 --> 00:07:28.835
you're in a bill counter.

00:07:28.835 --> 00:07:29.555
Okay.

00:07:29.555 --> 00:07:32.030
So the one person with available in the bill counter,

00:07:32.030 --> 00:07:35.855
our cashier, they cannot serve everybody at the same time.

00:07:35.855 --> 00:07:37.550
So you need to be in a queue.

00:07:37.550 --> 00:07:40.205
You need to wait for the person who stands before you.

00:07:40.205 --> 00:07:43.055
Once he's done, then it is your turn to go and update it.

00:07:43.055 --> 00:07:43.940
Okay?

00:07:43.940 --> 00:07:47.945
So that is how the synchronizer VOC volatile.

00:07:47.945 --> 00:07:50.615
So what it does is basically it's a memory-based.

00:07:50.615 --> 00:07:52.970
So when you use water tight,

00:07:52.970 --> 00:07:55.730
the memories are not cached locally.

00:07:55.730 --> 00:07:58.170
Cached locally.

00:07:59.020 --> 00:08:02.390
Or we can call them as a thread locally.

00:08:02.390 --> 00:08:05.330
So whenever you create a variable,

00:08:05.330 --> 00:08:09.500
that cache memory will be created that the beer store in the temporary memory.

00:08:09.500 --> 00:08:14.405
But when you create a variable in a volatile,

00:08:14.405 --> 00:08:20.915
it always reads from main memory,

00:08:20.915 --> 00:08:23.795
which means your data memory.

00:08:23.795 --> 00:08:25.385
So what does your memory, the RAM, right?

00:08:25.385 --> 00:08:27.650
It will directly read from the RAM.

00:08:27.650 --> 00:08:31.250
Okay, so we're going to see the example for each and every one of them.

00:08:31.250 --> 00:08:33.290
But we're not going to talk about the transients in

00:08:33.290 --> 00:08:36.380
Cornwall because those are some advanced concept.

00:08:36.380 --> 00:08:39.470
But we'll talk about the final static and abstract.

00:08:39.470 --> 00:08:41.945
And even the abstract, we have a separate session.

00:08:41.945 --> 00:08:45.545
So we'll talk about final as a class

00:08:45.545 --> 00:08:49.550
and final as a method and a variable and how the static is going to work.

00:08:49.550 --> 00:08:51.330
Thank you.
