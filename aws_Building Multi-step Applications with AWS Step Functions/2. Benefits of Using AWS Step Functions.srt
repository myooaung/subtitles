1
00:00:01,540 --> 00:00:02,480
[Autogenerated] our company.

2
00:00:02,480 --> 00:00:04,940
Club romantics, like many other companies,

3
00:00:04,940 --> 00:00:08,460
is trying to break down their systems into smaller pieces toe,

4
00:00:08,460 --> 00:00:12,870
help them better manage and understand their business logic much on their e.

5
00:00:12,870 --> 00:00:13,110
P I.

6
00:00:13,110 --> 00:00:15,840
A logic has been converted to either a serverless

7
00:00:15,840 --> 00:00:19,000
function or a smaller micro service.

8
00:00:19,000 --> 00:00:21,030
These now helps them easily.

9
00:00:21,030 --> 00:00:24,260
Main Thing called across different functions but presents

10
00:00:24,260 --> 00:00:27,580
another problem when it comes to coordination.

11
00:00:27,580 --> 00:00:28,960
In a lot of cases,

12
00:00:28,960 --> 00:00:32,150
one several dysfunction needs to be continued by another

13
00:00:32,150 --> 00:00:35,030
function in order to complete a larger task.

14
00:00:35,030 --> 00:00:39,040
Let's take an example off sending a PDF report for clients.

15
00:00:39,040 --> 00:00:41,640
We generate a beauty every board encrypted,

16
00:00:41,640 --> 00:00:46,040
depending on the client requirements and sanded by our email.

17
00:00:46,040 --> 00:00:52,340
Now we could have this process all in one step, generate and creep and sent.

18
00:00:52,340 --> 00:00:56,250
If any of these steps failed, the entire process fails,

19
00:00:56,250 --> 00:00:59,190
and if you only wanted to generate the report,

20
00:00:59,190 --> 00:01:00,420
we couldn't do so.

21
00:01:00,420 --> 00:01:02,900
We would need to have a dedicated service.

22
00:01:02,900 --> 00:01:06,490
Just to generate The report on Ideal solution is to have them

23
00:01:06,490 --> 00:01:09,300
separated into smaller independent service.

24
00:01:09,300 --> 00:01:12,100
Is that individual tasks?

25
00:01:12,100 --> 00:01:12,950
Ideally,

26
00:01:12,950 --> 00:01:16,940
we would have a serverless function or a service to generate the pdf

27
00:01:16,940 --> 00:01:21,190
wantto and creep hand an email service to San a maze.

28
00:01:21,190 --> 00:01:25,450
This way we could scale each independently or have them a server

29
00:01:25,450 --> 00:01:29,330
less toe on Lee pay for when we are using them now that have

30
00:01:29,330 --> 00:01:31,790
broken down our logic into smaller pieces.

31
00:01:31,790 --> 00:01:33,900
There is the matter of coordinating them.

32
00:01:33,900 --> 00:01:35,030
We need detain them.

33
00:01:35,030 --> 00:01:39,340
So once the report generation has completed its past to the increase in step

34
00:01:39,340 --> 00:01:44,880
and after encryption is passed to the email step managing these viacord wild

35
00:01:44,880 --> 00:01:48,710
doable it's very complicated and proved to errors.

36
00:01:48,710 --> 00:01:51,210
We have to think about error handling, retrial,

37
00:01:51,210 --> 00:01:54,950
logic and progress tracking and also down the line.

38
00:01:54,950 --> 00:01:57,670
We might get other requirements, like sand,

39
00:01:57,670 --> 00:02:00,320
a file using other means other than email,

40
00:02:00,320 --> 00:02:03,500
like chat integrations or SMS.

41
00:02:03,500 --> 00:02:05,980
All these is already becoming complicated.

42
00:02:05,980 --> 00:02:08,230
With a small process like ours.

43
00:02:08,230 --> 00:02:11,380
Imagining a large process with multiple steps becomes

44
00:02:11,380 --> 00:02:14,260
quite unfeasible and hard to manage.

45
00:02:14,260 --> 00:02:17,880
That is where AWS step functions come into play.

46
00:02:17,880 --> 00:02:23,830
Step functions is a service that enables us to easily orchestrate multiple AWS

47
00:02:23,830 --> 00:02:28,240
service is that can fit together to accomplish a larger task.

48
00:02:28,240 --> 00:02:30,520
We can have a process with multiple steps.

49
00:02:30,520 --> 00:02:31,090
Each step.

50
00:02:31,090 --> 00:02:33,790
Output can be used as another's import,

51
00:02:33,790 --> 00:02:36,780
and we can build work flows that integrate as many

52
00:02:36,780 --> 00:02:39,620
service's and steps as we require on.

53
00:02:39,620 --> 00:02:42,450
We can arrange them accordingly without writing any

54
00:02:42,450 --> 00:02:43,990
called or having to redeploy.

55
00:02:43,990 --> 00:02:46,580
Our service is when the work flow changes.

56
00:02:46,580 --> 00:02:49,750
Step functions provide us with a lot of crucial functionality

57
00:02:49,750 --> 00:02:52,540
that we would otherwise need to be ourselves.

58
00:02:52,540 --> 00:02:56,780
We have error handling automatic retrial failures,

59
00:02:56,780 --> 00:02:58,750
triggering and tracking steps,

60
00:02:58,750 --> 00:03:02,770
manage the execution order and finally visualize the work

61
00:03:02,770 --> 00:03:06,000
flows in easily to understand diagram When it comes to

62
00:03:06,000 --> 00:03:08,790
orchestrating large scale complex diagram.

63
00:03:08,790 --> 00:03:12,940
Step functions have a lot of benefits over self implementing.

64
00:03:12,940 --> 00:03:16,470
We can easily create complex work flows that could have a lot of

65
00:03:16,470 --> 00:03:20,520
steps coordinating a 100 step workflow on our own.

66
00:03:20,520 --> 00:03:22,140
Other than being time consuming,

67
00:03:22,140 --> 00:03:25,930
it's very hard to do and let alone maintain and watch for errors.

68
00:03:25,930 --> 00:03:29,060
Step functions gives us an easy way to create,

69
00:03:29,060 --> 00:03:32,260
visualize and provide detailed information on each step.

70
00:03:32,260 --> 00:03:33,330
Execution on.

71
00:03:33,330 --> 00:03:34,400
When a step fails,

72
00:03:34,400 --> 00:03:37,520
we can easily see which step failed why and what's

73
00:03:37,520 --> 00:03:39,050
the state of the entire process.

74
00:03:39,050 --> 00:03:40,480
At any given time,

75
00:03:40,480 --> 00:03:45,280
AWS step functions can wait a long time from going from one step to another.

76
00:03:45,280 --> 00:03:47,040
We can easily configure away,

77
00:03:47,040 --> 00:03:50,490
period between two stabs or wait for the next step to

78
00:03:50,490 --> 00:03:53,370
start until an outside factor intervenes.

79
00:03:53,370 --> 00:03:58,440
For example, if we have a payment system and we are going to do a refund,

80
00:03:58,440 --> 00:03:59,150
we can set it.

81
00:03:59,150 --> 00:04:02,860
So if the amount is more than $1000 we can decide to

82
00:04:02,860 --> 00:04:04,900
have a human approving the step.

83
00:04:04,900 --> 00:04:09,510
Execution would halt, and until someone approves or denies the request,

84
00:04:09,510 --> 00:04:11,740
the workflow will not continue forever.

85
00:04:11,740 --> 00:04:15,200
Another benefit is not having worked for logic on the business

86
00:04:15,200 --> 00:04:18,690
logy when he had worked for logic to applications that are

87
00:04:18,690 --> 00:04:22,500
supposed to handle business logic, it makes things complicated.

88
00:04:22,500 --> 00:04:26,160
Changing one requires changing, rather using step functions.

89
00:04:26,160 --> 00:04:27,770
Devil opens the design work.

90
00:04:27,770 --> 00:04:30,100
Clothes don't have to know much about the inner

91
00:04:30,100 --> 00:04:32,170
workings off the service is they use.

92
00:04:32,170 --> 00:04:35,370
They only need to know the possible errors that are thrown,

93
00:04:35,370 --> 00:04:39,080
the input and the output to design the workflow successfully.

94
00:04:39,080 --> 00:04:43,540
And another benefit is that step functions can run in parallel.

95
00:04:43,540 --> 00:04:46,750
We can have multiple parallel executions off the same work

96
00:04:46,750 --> 00:04:50,830
flow as well as we can have parallel executions off a subset

97
00:04:50,830 --> 00:04:52,670
of steps within our workflow.

98
00:04:52,670 --> 00:04:54,950
Tow it, period over a process faster.

99
00:04:54,950 --> 00:04:57,890
Managing these complexity on our own environment would be

100
00:04:57,890 --> 00:05:00,220
very complicated and time consuming.

101
00:05:00,220 --> 00:05:10,000
This was just a brief introduction into AWS step functions. We'll dive deep into different topics in the cliffs to come.

