WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:0

00:00:01.760 --> 00:00:04.230
The title of the previous video

00:00:04.230 --> 00:00:06.030
was called function expressions.

00:00:06.030 --> 00:00:08.190
Now we're going to look at something called

00:00:08.190 --> 00:00:11.025
immediately invoked function expressions.

00:00:11.025 --> 00:00:12.765
It may sound complex,

00:00:12.765 --> 00:00:13.920
but it's not really too bad,

00:00:13.920 --> 00:00:16.320
it just takes our original function expression

00:00:16.320 --> 00:00:17.880
from the previous video,

00:00:17.880 --> 00:00:21.165
and we can run or invoke this function immediately.

00:00:21.165 --> 00:00:23.085
Let's take a look at how this works

00:00:23.085 --> 00:00:25.185
inside of these data files.

00:00:25.185 --> 00:00:28.090
If we take a look inside of this script section,

00:00:28.090 --> 00:00:31.220
have a simple function which creates a browser alert.

00:00:31.220 --> 00:00:32.270
I know this is

00:00:32.270 --> 00:00:34.970
a function declaration since it appears by itself,

00:00:34.970 --> 00:00:38.095
and it's not stored inside of a variable.

00:00:38.095 --> 00:00:41.185
But what we can do is we can remove the name.

00:00:41.185 --> 00:00:42.890
Again, this is optional and we

00:00:42.890 --> 00:00:44.965
will look at this very soon.

00:00:44.965 --> 00:00:47.355
Remove the name of the function.

00:00:47.355 --> 00:00:50.495
Now since this function has no names actually call it by,

00:00:50.495 --> 00:00:53.680
we can now remove the function call at the bottom.

00:00:53.680 --> 00:00:55.620
This lack of name means it's

00:00:55.620 --> 00:00:57.705
called an anonymous function.

00:00:57.705 --> 00:01:00.735
How do we call a function with no name?

00:01:00.735 --> 00:01:02.700
Well, this is where our immediately

00:01:02.700 --> 00:01:05.045
invoked function expressions comes into play.

00:01:05.045 --> 00:01:07.025
We first need to begin by wrapping

00:01:07.025 --> 00:01:10.220
our full function inside of brackets.

00:01:10.220 --> 00:01:12.950
If we cut this out, open

00:01:12.950 --> 00:01:15.020
up the brackets and then paste this in,

00:01:15.020 --> 00:01:16.940
this contains all of our function in

00:01:16.940 --> 00:01:18.050
between these brackets and

00:01:18.050 --> 00:01:19.580
then it's actually run the code.

00:01:19.580 --> 00:01:22.970
We then place in a new set of brackets just afterwards,

00:01:22.970 --> 00:01:26.120
just like we would do with a regular function call.

00:01:26.120 --> 00:01:29.810
Now if we save this and refresh the browser,

00:01:29.810 --> 00:01:33.475
we now see our alert inside of here.

00:01:33.475 --> 00:01:35.660
This means our function is running.

00:01:35.660 --> 00:01:38.225
We can see the code contained inside.

00:01:38.225 --> 00:01:40.850
This just means we've created a function and

00:01:40.850 --> 00:01:44.005
run the function code as soon as the page is loaded.

00:01:44.005 --> 00:01:46.295
If we didn't surround this function code

00:01:46.295 --> 00:01:48.635
with these original brackets just here,

00:01:48.635 --> 00:01:49.940
it would cause an error since

00:01:49.940 --> 00:01:51.110
JavaScript would think this was

00:01:51.110 --> 00:01:54.530
a regular function which would require a name.

00:01:54.530 --> 00:01:56.450
But using these surrounding brackets can

00:01:56.450 --> 00:01:58.565
also cause a problem too.

00:01:58.565 --> 00:02:00.710
If we have some code above, for example,

00:02:00.710 --> 00:02:02.270
such as a variable,

00:02:02.270 --> 00:02:04.295
this can cause an issue.

00:02:04.295 --> 00:02:06.835
Create any variable just above,

00:02:06.835 --> 00:02:09.105
I want to go for language,

00:02:09.105 --> 00:02:12.315
and set this equal to JavaScript.

00:02:12.315 --> 00:02:16.520
Notice here I'm not adding a semicolon at the end,

00:02:16.520 --> 00:02:18.365
and if we save this file,

00:02:18.365 --> 00:02:22.160
the text editor has automatically formatted these photos.

00:02:22.160 --> 00:02:23.945
We can see straight away that

00:02:23.945 --> 00:02:26.685
this is not how our code was intended.

00:02:26.685 --> 00:02:28.460
Let's go off to the browser and see

00:02:28.460 --> 00:02:31.280
what effect this has if we refresh.

00:02:31.280 --> 00:02:32.870
There we go, we'll have an error.

00:02:32.870 --> 00:02:35.305
JavaScript is not a function.

00:02:35.305 --> 00:02:37.525
Now if we go back to the text editor

00:02:37.525 --> 00:02:39.700
and examine our code more closely,

00:02:39.700 --> 00:02:41.845
this error is understandable.

00:02:41.845 --> 00:02:43.660
Where we've laid out is code is pretty

00:02:43.660 --> 00:02:45.160
similar to the function expression

00:02:45.160 --> 00:02:48.405
which looked at in the previous video, it thinks.

00:02:48.405 --> 00:02:52.350
We have a function name of JavaScript.

00:02:52.350 --> 00:02:54.955
Then immediately afterwards we have the contents

00:02:54.955 --> 00:02:57.820
inside of these brackets, just like this.

00:02:57.820 --> 00:02:59.560
Remember earlier we looked at how

00:02:59.560 --> 00:03:01.900
semicolons don't always need to be used.

00:03:01.900 --> 00:03:04.135
Well, this is one of those used cases

00:03:04.135 --> 00:03:05.920
when we do need to add them in.

00:03:05.920 --> 00:03:09.460
If we now add a semicolon after our variable name,

00:03:09.460 --> 00:03:12.580
this will now separate this from our function.

00:03:12.580 --> 00:03:14.725
We test this in the browser,

00:03:14.725 --> 00:03:18.695
refresh, and again, our function is working correctly.

00:03:18.695 --> 00:03:22.250
Alternatively, you may also see some developers add

00:03:22.250 --> 00:03:26.000
a semicolon at the beginning of the function expression.

00:03:26.000 --> 00:03:28.550
This is to avoid any problems if the line

00:03:28.550 --> 00:03:31.385
above doesn't end in a semicolon.

00:03:31.385 --> 00:03:33.530
It's also especially useful if we are

00:03:33.530 --> 00:03:35.560
importing the contents of another file.

00:03:35.560 --> 00:03:37.220
We don't always know if that code

00:03:37.220 --> 00:03:38.945
is going to end in a semicolon,

00:03:38.945 --> 00:03:41.450
or if it's going to cause an error.

00:03:41.450 --> 00:03:43.325
This is how we use them.

00:03:43.325 --> 00:03:44.750
But why do we need to use

00:03:44.750 --> 00:03:47.690
an immediately invoked function expression?

00:03:47.690 --> 00:03:50.120
Well, apart from the obvious that we may need to run

00:03:50.120 --> 00:03:53.120
some code immediately without calling the function.

00:03:53.120 --> 00:03:55.280
Since this is a function expression,

00:03:55.280 --> 00:03:58.150
it also doesn't pollute the global object.

00:03:58.150 --> 00:04:00.170
As we looked at in the previous video,

00:04:00.170 --> 00:04:02.090
when we create a function expression,

00:04:02.090 --> 00:04:05.860
it's not always available to use in any part of our file.

00:04:05.860 --> 00:04:07.340
We must first create

00:04:07.340 --> 00:04:09.980
the function before we can actually use it.

00:04:09.980 --> 00:04:12.110
Also, this is another good way to

00:04:12.110 --> 00:04:14.540
keep variables of the global object too,

00:04:14.540 --> 00:04:16.460
if we only intend on using them

00:04:16.460 --> 00:04:18.895
inside of a particular function.

00:04:18.895 --> 00:04:21.620
For example, if this variable was only

00:04:21.620 --> 00:04:24.170
ever going to be used inside of this function,

00:04:24.170 --> 00:04:26.405
we don't need to add this to the global object,

00:04:26.405 --> 00:04:27.920
just like we are doing now.

00:04:27.920 --> 00:04:30.265
We can see this if we change our alert,

00:04:30.265 --> 00:04:32.990
and we'll log the value of the language.

00:04:32.990 --> 00:04:34.890
Then outside its function, we can

00:04:34.890 --> 00:04:37.540
also log this to the console.

00:04:37.880 --> 00:04:42.735
Save and refresh. We see our alerts,

00:04:42.735 --> 00:04:45.755
and also into the console we see our console log.

00:04:45.755 --> 00:04:48.200
This variable is accessible from both

00:04:48.200 --> 00:04:51.335
inside and outside of the function.

00:04:51.335 --> 00:04:53.360
But as mentioned before, if we didn't want

00:04:53.360 --> 00:04:55.385
this variable to be available globally,

00:04:55.385 --> 00:04:58.235
we could instead move this down to our function.

00:04:58.235 --> 00:05:00.320
This means this valuable is now only

00:05:00.320 --> 00:05:03.250
accessible from inside of this function.

00:05:03.250 --> 00:05:06.130
Over to the browser, refresh,

00:05:06.130 --> 00:05:08.000
we see the alert will run and this has

00:05:08.000 --> 00:05:10.370
access to our language variable.

00:05:10.370 --> 00:05:12.530
However, though inside the console when we try

00:05:12.530 --> 00:05:14.795
to log the value of language,

00:05:14.795 --> 00:05:18.250
this is now not accessible from outside of the function.

00:05:18.250 --> 00:05:21.080
This means that any variables which you create inside of

00:05:21.080 --> 00:05:24.125
the function are also isolated too.

00:05:24.125 --> 00:05:26.900
This is really useful if we want to restrict a piece of

00:05:26.900 --> 00:05:30.845
data to only be accessible from a particular function.

00:05:30.845 --> 00:05:32.840
But even though this variable is only

00:05:32.840 --> 00:05:34.505
available inside of our function,

00:05:34.505 --> 00:05:36.875
we can still return a value.

00:05:36.875 --> 00:05:39.005
Instead of the alert,

00:05:39.005 --> 00:05:43.120
we can return back the language,

00:05:43.120 --> 00:05:45.470
and install the returned value of

00:05:45.470 --> 00:05:47.615
malfunction inside of a variable.

00:05:47.615 --> 00:05:49.870
Log this to the console,

00:05:49.870 --> 00:05:53.700
save and refresh into the console.

00:05:53.700 --> 00:05:57.690
Now we get back the returned value from our variable.
