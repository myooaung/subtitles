WEBVTT
1

00:00:00.630  -->  00:00:06.180
It's time to talk about datatypes datatypes are very easy and moreover in this course we will only be

2

00:00:06.180  -->  00:00:11.690
working for them so we should be able to fly through this tutorial very quickly.

3

00:00:11.880  -->  00:00:20.010
OK datatypes are we going to look at a type and an example and basically a data type is a format or

4

00:00:20.760  -->  00:00:23.940
a storage method for your call.

5

00:00:23.950  -->  00:00:26.090
So what what is your column.

6

00:00:26.100  -->  00:00:28.320
Is it a text is it a number.

7

00:00:28.320  -->  00:00:29.700
Is it a date.

8

00:00:29.760  -->  00:00:31.250
What type of number it is.

9

00:00:31.380  -->  00:00:38.850
And so on so that data type specifies how Asgill should store your column your field how much space

10

00:00:38.900  -->  00:00:43.350
it should allocate for that field and how it should treat that field.

11

00:00:43.470  -->  00:00:50.690
So data type number one is a bar chart where n is the number of characters the maximum number of characters

12

00:00:50.700  -->  00:00:54.130
you know are and example is a string of text.

13

00:00:54.180  -->  00:00:59.400
Hello my name is Kyrle So everything between the single quotations we've already seen March are many

14

00:00:59.400  -->  00:01:00.280
many times.

15

00:01:00.300  -->  00:01:05.340
Basically everything that we upload into our old files is a Bartsch are by default because it comes

16

00:01:05.910  -->  00:01:10.320
in as text and we specified usually a thousand.

17

00:01:10.320  -->  00:01:15.560
If that's not enough we suppose we're 5000 characters maximum length for bar chart in a scale is eight

18

00:01:15.680  -->  00:01:17.360
thousand characters.

19

00:01:17.400  -->  00:01:21.000
So basically any string of text including a single character.

20

00:01:21.000  -->  00:01:27.390
So we're going to store single characters as Watcher anyway even though there are other types for storage

21

00:01:27.390  -->  00:01:28.950
of single characters.

22

00:01:28.950  -->  00:01:33.770
Next is inte well into or integer is a whole number.

23

00:01:33.780  -->  00:01:37.460
Anything like 25 or 100 10000.

24

00:01:37.470  -->  00:01:42.450
Those are all whole numbers and if you want numbers to be treated as numbers and not as text then we've

25

00:01:42.450  -->  00:01:45.730
already seen examples the examples of this previously.

26

00:01:45.750  -->  00:01:52.260
If you are numbers which is numbers and not as just strings of characters one up to the other then you

27

00:01:52.260  -->  00:02:01.170
need to store them as integers and off to this Torneo we will learn how to convert datatypes and later

28

00:02:01.170  -->  00:02:05.560
on in the course will learn how to actually store them in tables as the correct types.

29

00:02:05.730  -->  00:02:10.870
So for now everything we're working with is by default in bar chart because it's raw files.

30

00:02:10.870  -->  00:02:18.980
But eventually we'll get to a point where we will be storing fields in their correct data types.

31

00:02:18.990  -->  00:02:21.360
The next one will be working with is a float.

32

00:02:21.360  -->  00:02:28.350
So basically any number with a decimal point doesn't matter how many characters or how many digits after

33

00:02:28.350  -->  00:02:32.340
the decimal point in this case it's 1040 and 53.

34

00:02:32.430  -->  00:02:36.180
So it could be much more characters after the decimal point.

35

00:02:36.180  -->  00:02:40.650
I mean I mean death's digits after the decimal point doesn't matter.

36

00:02:40.650  -->  00:02:47.790
So basically any number with that decimal point you want to stored as a float ideally because that way

37

00:02:47.790  -->  00:02:54.210
you'll be able to add them up or compare them and perform mathematical operations with them instead

38

00:02:54.210  -->  00:03:00.180
of just being a string of numbers or if it's just text then you can do all those things.

39

00:03:00.180  -->  00:03:06.040
And important point is if you multiply an integer by a float that in the results you will get a float

40

00:03:06.060  -->  00:03:11.730
so the resulting column that you're going to get after multiplying two columns one of which is an integer

41

00:03:11.730  -->  00:03:15.090
1 is a float that result in call will be a float.

42

00:03:15.090  -->  00:03:20.460
That's a good thing to keep in mind and remember for the future we will see one of those examples in

43

00:03:20.610  -->  00:03:23.100
the next section of the course.

44

00:03:23.550  -->  00:03:31.320
And the final type that you will be predominately working with are the final These four are the ones

45

00:03:31.320  -->  00:03:34.860
that you reproduced with you're working with and the final one of them is a date.

46

00:03:34.860  -->  00:03:42.810
So in a secure all data stored in this format where year month day which is exactly the same word we're

47

00:03:42.810  -->  00:03:51.000
uploading and it's called the canonical format for dates very you know very easy to understand what

48

00:03:51.000  -->  00:03:57.170
this is is just basically a data stored in a scale and why it's important to store dates as dates and

49

00:03:57.170  -->  00:04:01.340
not as text because then you can compare a what came first what came next.

50

00:04:01.350  -->  00:04:07.780
And you can Next use special functions to extract months and days from these days and years and so on

51

00:04:07.800  -->  00:04:11.250
so you can work with dates as dates.

52

00:04:11.250  -->  00:04:16.320
So those are the main four that we will be working with in this course and basically you shouldn't need

53

00:04:16.320  -->  00:04:23.550
anything more than that in your work as a data scientist although I will point out another theory that

54

00:04:23.670  -->  00:04:31.110
you might come across because maybe somebody supplies you for a table that is formatted in that that

55

00:04:31.380  -->  00:04:36.720
specific type or for some other reasons so let's have a look at another three that you might ever come

56

00:04:36.720  -->  00:04:37.440
across.

57

00:04:37.510  -->  00:04:38.420
Date time.

58

00:04:38.470  -->  00:04:45.720
So this one is the most likely that you will come across is if your daughter has like dates and times

59

00:04:45.750  -->  00:04:51.690
where not just the day but also you know when the day something happened for instance this could be

60

00:04:51.690  -->  00:04:59.190
data on a certain sports event and you know when somebody started and finished the race and things like

61

00:04:59.190  -->  00:05:00.480
that so maybe that will help.

62

00:05:00.480  -->  00:05:05.820
Times are when when transactions happen for instance somebody was swiping credit cards you might also

63

00:05:05.820  -->  00:05:10.560
know and you might need this information when jury at which time of the day the person was swiping a

64

00:05:10.560  -->  00:05:11.480
credit card.

65

00:05:11.490  -->  00:05:18.410
So in that case there's a format in or a type in a skill which is called Day time there.

66

00:05:18.460  -->  00:05:21.960
That's how it looks like it's got the date and the time bit on it.

67

00:05:21.960  -->  00:05:25.090
So don't get confused if you don't have time date.

68

00:05:25.110  -->  00:05:29.370
Don't use date time some people always use date time and then they have all these zeros for hours minutes

69

00:05:29.370  -->  00:05:30.160
and seconds.

70

00:05:30.250  -->  00:05:34.860
Doesn't look good and you know it just can confuse you if you have a date is a date if you have a date

71

00:05:34.860  -->  00:05:37.650
time use a date time.

72

00:05:37.890  -->  00:05:43.860
Sometimes you might find a time handy but often it might be selfish and might even be better to store

73

00:05:43.860  -->  00:05:48.960
your dates separately and then your hours your minute and your second in separate homes.

74

00:05:49.200  -->  00:05:57.710
That might allow you to you know give you a bit more flexibility of what you can do of those pieces

75

00:05:57.720  -->  00:06:01.190
elements of data before having to invoke additional functions.

76

00:06:01.340  -->  00:06:08.970
Bit is basically a Boolean type in you know skills called bitted it's a one or a zero or a full or a

77

00:06:09.120  -->  00:06:10.330
or a null.

78

00:06:10.380  -->  00:06:19.660
And it allows it to you know check conditions on a chicken store condition results.

79

00:06:19.670  -->  00:06:22.490
Like if if a condition was true or false.

80

00:06:22.500  -->  00:06:28.060
Basically working hard but personally I'd rather use an integer why would you go for it.

81

00:06:28.140  -->  00:06:34.660
It's just maybe for security purposes so nobody can put in a different value in there.

82

00:06:34.740  -->  00:06:41.990
But in data science work I rarely I think I use it maybe once or twice ever use it in integers enough

83

00:06:41.990  -->  00:06:42.160
.

84

00:06:42.330  -->  00:06:44.340
And finally money if it's in money.

85

00:06:44.340  -->  00:06:46.920
My basic advice is run from it.

86

00:06:46.950  -->  00:06:52.050
Don't ever use money it's it's a very horrible horrible horrible type.

87

00:06:52.050  -->  00:07:01.170
I've seen people who I just I don't know why it's I guess they vitty and inexperience maybe even like

88

00:07:01.170  -->  00:07:03.210
money you can't do much.

89

00:07:03.220  -->  00:07:11.460
It's like it's like a float type but you can divide one by the other it's very imprecise.

90

00:07:11.470  -->  00:07:18.680
It causes lots of headache down the track so if you have a value which is like a dollar value then stored

91

00:07:18.720  -->  00:07:25.070
in a float type don't ever use money and if somebody is using money try to advise them against it.

92

00:07:25.080  -->  00:07:31.290
Or when you get the data in your tables converted to float because money can cause you problems on the

93

00:07:31.290  -->  00:07:31.850
track.

94

00:07:32.010  -->  00:07:34.950
Mark my word don't use money.

95

00:07:35.350  -->  00:07:38.170
I mean don't use that type of money in school.

96

00:07:38.250  -->  00:07:40.340
So that's all types.

97

00:07:40.530  -->  00:07:42.840
Pretty straightforward stuff.

98

00:07:42.900  -->  00:07:49.740
This is just basically saying how your column is stored and treated as well.

99

00:07:50.460  -->  00:07:53.660
And the next total We will talk about type conversions
