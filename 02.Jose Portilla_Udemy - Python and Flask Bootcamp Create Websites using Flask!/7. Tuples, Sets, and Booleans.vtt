WEBVTT
1
00:00:05.490 --> 00:00:10.050
Welcome back everyone in this lecture we're going to finish off our discussion of basic data types and

2
00:00:10.050 --> 00:00:14.070
data structures of Python by talking about tuples sets and booleans.

3
00:00:14.070 --> 00:00:17.910
They're all kind of minor smaller topics so we're going to link them all together in this one single

4
00:00:17.910 --> 00:00:18.510
lecture.

5
00:00:18.690 --> 00:00:23.400
So Let's first discuss each one and then we'll head over to the Adam code editor and check them allow

6
00:00:24.500 --> 00:00:27.380
OK we have tuples So what are tuples.

7
00:00:27.380 --> 00:00:29.660
Tuples are actually very similar to lists.

8
00:00:29.690 --> 00:00:32.970
However they have one key difference and that is immutability.

9
00:00:32.990 --> 00:00:37.250
So remember with Lisse you can mutate or change elements that are already inside of the list.

10
00:00:37.400 --> 00:00:42.130
Tuples pretty much operate the exact same way as far as an ordered sequence except that they're immutable.

11
00:00:42.170 --> 00:00:46.140
Once an element is assigned inside a tuple it cannot be reassigned.

12
00:00:46.370 --> 00:00:51.980
And the difference in syntax is that instead of using square brackets tuples are going to use parentheses.

13
00:00:51.980 --> 00:00:55.850
So here we can see an example of a tuple holding three items one two and three.

14
00:00:55.850 --> 00:00:59.590
Notice it looks a lot like lists except instead of square brackets we have princes there.

15
00:00:59.630 --> 00:01:01.630
Main difference here is immutability.

16
00:01:01.640 --> 00:01:07.910
So when you are objects not to be changed within an ordered sequence tuples are a good way to go that

17
00:01:07.910 --> 00:01:13.260
we have sets sets are an order collections of unique elements.

18
00:01:13.260 --> 00:01:14.630
So what do we mean by unique.

19
00:01:14.640 --> 00:01:18.710
That means there can only be one representative object of the same kind of objects.

20
00:01:18.720 --> 00:01:23.260
So we're going to see some examples of that later on in the text editor but just keep in mind sets there

21
00:01:23.330 --> 00:01:30.480
an order collections of unique elements and then finally booleans the last to discuss and booleans are

22
00:01:30.480 --> 00:01:33.840
just operators that lights convey true or false statements.

23
00:01:33.960 --> 00:01:37.620
And these are really important later on when we deal control flow and logic.

24
00:01:37.620 --> 00:01:41.640
So let's learn about these three data types tuples sets and booleans.

25
00:01:41.640 --> 00:01:43.050
Let's head over the atom.

26
00:01:43.130 --> 00:01:43.390
OK.

27
00:01:43.390 --> 00:01:48.330
And to start off by talking about tuples so tuples they look a lot like a list except they're going

28
00:01:48.330 --> 00:01:49.460
to use parentheses.

29
00:01:49.650 --> 00:01:55.650
So we're going to make a tuple of one two three and then I'm going to print out the tuple itself and

30
00:01:55.650 --> 00:01:58.140
you can use indexing just like you would for a list.

31
00:01:58.140 --> 00:02:02.120
So if I wanted to grab the first item in the tuple I would just say t of 0.

32
00:02:02.400 --> 00:02:05.030
So save this and run it.

33
00:02:05.180 --> 00:02:08.940
And here we have the entire tuple and then the first item in the table.

34
00:02:08.990 --> 00:02:13.580
And just like lists that can actually have mixed data types so we can have the floating point number

35
00:02:13.640 --> 00:02:14.790
a letter string.

36
00:02:14.840 --> 00:02:17.550
All that's fine tuples not going to complain.

37
00:02:17.810 --> 00:02:20.730
Remember with a list I could do some sort of re-assignment.

38
00:02:20.990 --> 00:02:23.060
So I'm going to show you that there an example.

39
00:02:23.210 --> 00:02:24.410
I'm going to say my list.

40
00:02:24.440 --> 00:02:26.790
Square brackets One two three.

41
00:02:26.930 --> 00:02:30.270
And let's just make the tuple again one two three.

42
00:02:30.770 --> 00:02:37.700
So a full list I was able to grab the first item in this fashion and then set it equal to something

43
00:02:37.700 --> 00:02:38.240
new.

44
00:02:39.050 --> 00:02:44.930
Now you're going to notice if I print out my list that it's not going to complain about that.

45
00:02:45.000 --> 00:02:47.220
So we already learned this from The Last Lecture.

46
00:02:47.220 --> 00:02:50.240
If I run this code now I get back new to 3.

47
00:02:50.430 --> 00:02:51.930
So I can easily do a re-assignment.

48
00:02:51.960 --> 00:02:53.650
That means lists are mutable.

49
00:02:53.760 --> 00:02:55.570
Let's try the same thing with the tuple though.

50
00:02:55.800 --> 00:02:58.400
So I'm going to try t of 0 set it equal to.

51
00:02:58.410 --> 00:03:03.510
So let's try to get this one equal to you and then I'm going to print out my tuple.

52
00:03:03.690 --> 00:03:05.010
See.

53
00:03:05.060 --> 00:03:06.980
So what happens when we try running this.

54
00:03:07.040 --> 00:03:11.120
You actually get back an error that says tuple object does not support item assignment.

55
00:03:11.120 --> 00:03:14.670
Remember this is a really similar error we got back when we were working with strings.

56
00:03:14.780 --> 00:03:19.020
So tuples are really similar to lists as far as slicing and indexing goes.

57
00:03:19.160 --> 00:03:21.070
But you can't do the re-assignment.

58
00:03:21.260 --> 00:03:27.140
So you typically want to use tuples when you want something set in position not to be edited by a third

59
00:03:27.140 --> 00:03:28.160
party user.

60
00:03:28.160 --> 00:03:32.090
So things like calendar dates are always going to come in the same order and you don't want someone

61
00:03:32.090 --> 00:03:35.770
to just come in and change the 7th of the date to maybe the tenth.

62
00:03:35.810 --> 00:03:36.760
So that kind of thing.

63
00:03:36.770 --> 00:03:40.440
Tuples are a good choice as we learn more and more about Python flask.

64
00:03:40.460 --> 00:03:42.820
We'll start to see natural use cases for tuples.

65
00:03:42.920 --> 00:03:47.060
Often beginners start using lists and then later on when they start dealing with other people using

66
00:03:47.060 --> 00:03:47.620
their code.

67
00:03:47.750 --> 00:03:50.240
They begin to graduate to using tuples.

68
00:03:50.240 --> 00:03:50.670
OK.

69
00:03:50.960 --> 00:03:54.050
So we discuss tuples and a some people call and tipples as well.

70
00:03:54.050 --> 00:03:55.280
Keep that in mind.

71
00:03:55.280 --> 00:03:57.720
Now we're going to talk about sets and booleans.

72
00:03:57.740 --> 00:04:01.600
OK so sets are an unordered collection of unique elements.

73
00:04:02.680 --> 00:04:09.000
I'm going to create a set by saying x is equal to set open in close print C's and then if I just print

74
00:04:09.000 --> 00:04:10.350
the X.

75
00:04:10.510 --> 00:04:12.690
You'll notice right now when I run it.

76
00:04:12.850 --> 00:04:15.340
Because the back and empty set.

77
00:04:15.340 --> 00:04:17.350
Now let's try adding an item to that set.

78
00:04:17.350 --> 00:04:23.800
So the way we do that is we say X add and then I'm going to add on the number 1 to the set and then

79
00:04:23.800 --> 00:04:28.920
let's print out the resulting set after that which is x.

80
00:04:28.980 --> 00:04:34.330
So when I run this now I get back this sort of notation it uses curly braces very similar to a dictionary

81
00:04:34.630 --> 00:04:36.530
except notice now there's no key value pairs.

82
00:04:36.550 --> 00:04:38.780
It's just items inside of the set.

83
00:04:38.860 --> 00:04:40.200
So let's add one more.

84
00:04:40.210 --> 00:04:41.970
In fact let's do this before we print.

85
00:04:42.070 --> 00:04:46.540
We're going to add two and then we're going to add three.

86
00:04:46.720 --> 00:04:47.930
Save those.

87
00:04:47.980 --> 00:04:49.390
Run this and I get back.

88
00:04:49.390 --> 00:04:51.020
One two three in my set.

89
00:04:51.100 --> 00:04:56.130
So set syntax wise is curly braces with each item separated by a comma.

90
00:04:56.380 --> 00:04:57.760
So what's the big deal here.

91
00:04:57.940 --> 00:05:06.510
Well let's try adding theory again and in fact let's added a bunch of times going to say add one add

92
00:05:06.510 --> 00:05:09.390
two and then add three three times.

93
00:05:09.390 --> 00:05:14.470
The key here remember is that sets are an order collection of unique elements.

94
00:05:14.490 --> 00:05:17.130
So when I try to run that I get back the exact same result.

95
00:05:17.160 --> 00:05:23.010
One two three because three is already represented because it's already the single representation of

96
00:05:23.010 --> 00:05:24.240
that unique element.

97
00:05:24.270 --> 00:05:30.840
So you can't be adding more representations of that same element and so that only takes unique elements.

98
00:05:30.840 --> 00:05:32.500
So that's how a set works.

99
00:05:32.610 --> 00:05:39.000
And because a set works this way you can easily get back the unique values of A list by passing it through

100
00:05:39.180 --> 00:05:40.500
the set function.

101
00:05:40.500 --> 00:05:41.770
Let me show you how that works.

102
00:05:43.480 --> 00:05:48.300
I'm going to create a list called 1 to 1 2.

103
00:05:48.370 --> 00:05:50.490
This is to make a bunch of repeated numbers here.

104
00:05:50.620 --> 00:05:52.840
So some of them are repeated some of them messed up.

105
00:05:52.900 --> 00:05:54.660
So let's go back and fill these in.

106
00:05:54.670 --> 00:05:55.060
There we go.

107
00:05:55.060 --> 00:05:57.590
So just create kind of a list of random numbers here.

108
00:05:57.670 --> 00:06:01.480
But make sure some of them are repeated so twos or repeated ones are repeated and so on.

109
00:06:01.480 --> 00:06:07.120
And then if you want to get back the unique numbers where you can do is you can say set passen that

110
00:06:07.120 --> 00:06:10.140
list and then print out that result.

111
00:06:10.140 --> 00:06:18.390
So we're going to say set my list save this and run it and notice now we get back a set of all the unique

112
00:06:18.420 --> 00:06:21.620
elements 1 2 3 4 12 and 21.

113
00:06:21.840 --> 00:06:28.320
So that's a really useful use case for the set function able to easily grab only two unique elements

114
00:06:28.470 --> 00:06:29.360
from a list.

115
00:06:29.460 --> 00:06:32.060
And later on we'll learn about more use cases for sets.

116
00:06:32.070 --> 00:06:34.860
Typically these are going to be kind of more advanced use cases.

117
00:06:34.860 --> 00:06:38.430
So right now as a beginner you won't really be using sets that often.

118
00:06:38.430 --> 00:06:43.110
Finally I want to talk about booleans sibilance we're going to talk about this in a lot more detail

119
00:06:43.470 --> 00:06:44.930
when we discuss control flow.

120
00:06:45.090 --> 00:06:47.340
So let's take a look at these booleans.

121
00:06:47.490 --> 00:06:49.660
Basically it's either true or false.

122
00:06:49.680 --> 00:06:53.830
So you can say a is equal to and then I have to make sure it's a capital T.

123
00:06:54.060 --> 00:06:56.400
In order for it to be the true keyword.

124
00:06:56.450 --> 00:07:00.740
So if I print out a here it's going to show me true.

125
00:07:00.850 --> 00:07:02.110
So true.

126
00:07:02.110 --> 00:07:07.230
Notice if I try a lower case t I end up getting an error saying something like true is not the.

127
00:07:07.480 --> 00:07:08.460
A truth is not defined.

128
00:07:08.460 --> 00:07:11.170
So you have to make sure that it's a capital T.

129
00:07:11.260 --> 00:07:16.170
In order for that true boolean and likewise there's a false Boolean.

130
00:07:16.360 --> 00:07:19.930
So if you want things to be false you can set B equal to capital F false.

131
00:07:19.930 --> 00:07:23.090
And the third one I wanna to talk about is a placeholder called none.

132
00:07:23.320 --> 00:07:26.340
So that's another special key word which are going to see it later on.

133
00:07:26.470 --> 00:07:30.610
But essentially you can use that as a placeholder for an object that you don't want to reassign yet.

134
00:07:30.610 --> 00:07:31.960
So these are booleans.

135
00:07:31.960 --> 00:07:32.790
True and False.

136
00:07:32.830 --> 00:07:33.560
And then none.

137
00:07:33.730 --> 00:07:38.620
That's basically kind of a special keyword which we're going to see later on in the course.

138
00:07:38.620 --> 00:07:42.280
We're not going to use it immediately but I just want to introduce it now since it's kind of similar

139
00:07:42.280 --> 00:07:44.130
to the booleans ideas.

140
00:07:44.140 --> 00:07:45.430
Now why are booleans useful.

141
00:07:45.430 --> 00:07:46.540
True and False.

142
00:07:46.710 --> 00:07:51.040
They're going to be useful when we start learning about control flow and we will only want certain blocks

143
00:07:51.040 --> 00:07:54.770
of code to execute when something is true or when something is false.

144
00:07:54.820 --> 00:07:57.330
Now we're going to learn about comparison operators later on.

145
00:07:57.520 --> 00:08:02.390
But basically those are things like is one greater than two.

146
00:08:02.410 --> 00:08:06.370
So if I print out the result of that I get back false.

147
00:08:06.420 --> 00:08:08.320
One is not greater than two.

148
00:08:08.430 --> 00:08:13.020
And if I do the reverse is one less than two and I run that I'm going to get back.

149
00:08:13.020 --> 00:08:13.530
True.

150
00:08:13.770 --> 00:08:18.180
So right after your exercise lecture It's coming up next we're going to discuss comparison operators

151
00:08:18.240 --> 00:08:19.410
in a lot more detail.

152
00:08:19.620 --> 00:08:24.180
So right now as far as tuples sets and booleans are concerned this is just an introduction to those

153
00:08:24.180 --> 00:08:24.880
terms.

154
00:08:24.930 --> 00:08:30.010
The actual implementation and use cases of those kind of things are going to be seen much further along.

155
00:08:30.030 --> 00:08:35.670
So I just want to introduce them to kind of close off this discussion on data types and data structures.

156
00:08:35.670 --> 00:08:40.750
All right I think we've learned enough so that you can get some exercise and testing new skills.

157
00:08:40.770 --> 00:08:42.660
So let's go ahead and jump to the next lecture.

158
00:08:42.670 --> 00:08:46.130
We're going to show you the quick overview of your exercise assignment.

159
00:08:46.140 --> 00:08:46.820
We'll see you there.
