WEBVTT
1

00:00:00.450 --> 00:00:01.360

Welcome back.



2

00:00:01.530 --> 00:00:02.730

It's now time to discuss.



3

00:00:02.760 --> 00:00:08.520

While loops in general loops allow us to repeat code multiple times.



4

00:00:08.520 --> 00:00:13.470

The first basic loop that we're going to discuss is the while loop which will continually execute a



5

00:00:13.470 --> 00:00:16.910

block of code while it condition remains true.



6

00:00:16.920 --> 00:00:20.270

Let's see an example of this syntax.



7

00:00:20.360 --> 00:00:28.100

Here we can see the find a variable x equal to 1 and we say while X is less than or equal to three colon



8

00:00:28.400 --> 00:00:34.290

we have a block of code that will continually execute while the while condition remains true.



9

00:00:34.460 --> 00:00:40.460

We will go ahead and print out the number x and then we see here and commented form there were adding



10

00:00:40.460 --> 00:00:41.940

1 to the x variable.



11

00:00:41.990 --> 00:00:46.500

So we reassign X equal to the previous value of x plus 1.



12

00:00:46.580 --> 00:00:50.690

So as we continually run this loop we start off with X being equal to 1.



13

00:00:50.720 --> 00:00:56.660

So we print it and then we add on one plus one to now x is equal to 2 then 2 is still less than or equal



14

00:00:56.660 --> 00:00:57.370

to 3.



15

00:00:57.380 --> 00:00:59.230

So we go ahead and print out 2.



16

00:00:59.330 --> 00:01:01.990

Then we say two plus one is equal to 3.



17

00:01:02.030 --> 00:01:05.690

3 is still equal to 3 so it's technically Lessner equal to 3.



18

00:01:05.780 --> 00:01:07.400

So it prints out 3.



19

00:01:07.400 --> 00:01:09.770

Once we have three plus one is equal to 4.



20

00:01:09.800 --> 00:01:14.240

The while condition is no longer true because 4 is not less than or equal to 3.



21

00:01:14.270 --> 00:01:18.610

So the while loop terminates as a quick note.



22

00:01:18.640 --> 00:01:23.710

Be very careful of while loops because if condition is set to always be true then your while loop will



23

00:01:23.710 --> 00:01:27.430

actually run forever causing your program to get stuck.



24

00:01:27.430 --> 00:01:34.860

Let's explore while loops and a little more detail with Python.



25

00:01:34.880 --> 00:01:36.880

Let's begin by cutting out a similar example.



26

00:01:36.900 --> 00:01:38.370

What we just discussed.



27

00:01:38.540 --> 00:01:40.590

We will say x is equal to zero.



28

00:01:40.940 --> 00:01:47.540

And then while X is less than 3 Colan will execute some code.



29

00:01:47.600 --> 00:01:57.520

We will say print X is currently and then we will actually prints the value of x Lotusphere and printing



30

00:01:57.520 --> 00:02:00.220

the actual variable x not the string X..



31

00:02:00.220 --> 00:02:01.500

So keep that in mind.



32

00:02:02.050 --> 00:02:08.100

And then we're going to print still less than 3.



33

00:02:08.200 --> 00:02:16.210

Add 1 2 x and then we'll actually do that here will say x is equal to x plus 1.



34

00:02:16.480 --> 00:02:23.290

And then once we've done that we will print a new line using our special escape character and then we



35

00:02:23.290 --> 00:02:24.960

run this let's see what happens.



36

00:02:25.010 --> 00:02:26.660

We get X is currently zero.



37

00:02:26.800 --> 00:02:27.900

Still less than 3.



38

00:02:27.910 --> 00:02:29.280

Add 1 to x.



39

00:02:29.290 --> 00:02:31.280

It's 1 still less than 3 at once.



40

00:02:31.300 --> 00:02:33.090

X X is currently 2.



41

00:02:33.100 --> 00:02:35.080

Still less than 3 Add one to X.



42

00:02:35.200 --> 00:02:42.160

And notice right after we print this we end up adding 2 plus 1 to x is equal to 3 and since 3 is not



43

00:02:42.160 --> 00:02:44.210

less than 3 it's equal to it.



44

00:02:44.290 --> 00:02:47.500

We actually then terminate this while loop.



45

00:02:47.500 --> 00:02:51.770

Now if we set X less than or equal to 3 and we run this.



46

00:02:51.790 --> 00:02:56.160

You'll notice that we actually end up running one more time because 3 is equal to 3.



47

00:02:56.290 --> 00:03:01.810

It's still valid for the while loop to continue running now as a quick note.



48

00:03:01.870 --> 00:03:05.670

It's very easy to accidentally set a condition to always be true.



49

00:03:05.890 --> 00:03:12.760

So let's say we just said while true and this is very dangerous to do because basically there's nothing



50

00:03:12.760 --> 00:03:21.800

to kill this while loop will say Prince still true and we're going to eliminate this code and eliminate



51

00:03:21.800 --> 00:03:22.530

this code.



52

00:03:22.760 --> 00:03:27.230

So this is something you do not want to actually execute because it's going to constantly be printing



53

00:03:27.230 --> 00:03:27.500

still.



54

00:03:27.500 --> 00:03:29.840

True still true pretty much forever.



55

00:03:30.350 --> 00:03:34.460

So when we run this you can see I have an asterix here and your computer may even slow down if you actually



56

00:03:34.460 --> 00:03:40.160

run this and you'll see still true is constantly being printed out in order to kill this procedure.



57

00:03:40.160 --> 00:03:45.770

What you need to do is either do control plus see if you're running this stop pie script a command line



58

00:03:46.130 --> 00:03:50.990

or you can come up here in the notebook to kernel and then hit interrupt and it should interrupt the



59

00:03:51.000 --> 00:03:51.410

kernel.



60

00:03:51.410 --> 00:03:55.260

You'll notice it no longer has the asterisk indicating that it's no longer running.



61

00:03:55.340 --> 00:04:01.550

And if you scroll all the way down you should see something saying keyboard interrupt so to restart



62

00:04:01.550 --> 00:04:08.380

the kernel click restart and click that will go ahead and delete this do shift enter.



63

00:04:08.480 --> 00:04:10.600

And now we're back and ready to go.



64

00:04:10.670 --> 00:04:16.060

So let's move on to another probably more realistic example of when you may want to use a while loop.



65

00:04:16.520 --> 00:04:21.520

So in order to do this we first need to show you how you can accept input from a user.



66

00:04:21.590 --> 00:04:26.270

So in order to accept user input you use the input function.



67

00:04:26.270 --> 00:04:27.320

So we have input.



68

00:04:27.320 --> 00:04:32.180

Notice it's a special keyword since it's being highlighted and then you pass in a string and this is



69

00:04:32.180 --> 00:04:34.690

the string that will appear to the user.



70

00:04:34.930 --> 00:04:40.550

So we can say please input a number colon and then a space there.



71

00:04:41.900 --> 00:04:47.630

Do shift enter in you'll notice you say please put a number and you have this little box show up if



72

00:04:47.630 --> 00:04:53.920

you're running a PI script you'll still have the string print out but you won't see a little box.



73

00:04:53.920 --> 00:04:57.740

It'll basically just be waiting for you at the command line free to insert something.



74

00:04:57.740 --> 00:05:03.420

So let's provide a number to enter and you can see the output is the string to.



75

00:05:03.800 --> 00:05:08.080

So input is actually returning this string version of whatever you input it.



76

00:05:08.300 --> 00:05:15.980

So we can then say saved underscore input is equal to input and then when I run this I can input the



77

00:05:15.980 --> 00:05:16.750

number two.



78

00:05:17.060 --> 00:05:23.850

And then now later on I have X this variable saved and put as the string to.



79

00:05:23.860 --> 00:05:29.050

So let's show you a little more practical application of using a while loop will create a little program



80

00:05:29.050 --> 00:05:30.930

here in this cell.



81

00:05:30.970 --> 00:05:38.580

It says Welcome agents and will create a passcode variable to be equal to zero.



82

00:05:38.600 --> 00:05:43.340

So that's some sort of default pass code that we've already defined and we're going to say while



83

00:05:45.970 --> 00:05:58.000

passcode is not equal to that's exclamation point equal sign 1 to 3 colon we're going to say pass code



84

00:05:58.150 --> 00:06:04.380

is equal to the integer cast or transformation of.



85

00:06:04.780 --> 00:06:08.310

Please provide your pass code.



86

00:06:10.030 --> 00:06:11.730

So let's see what we're actually doing here.



87

00:06:12.870 --> 00:06:13.630

I'm going to print.



88

00:06:13.650 --> 00:06:14.440

Welcome agent.



89

00:06:14.440 --> 00:06:20.220

I see a default pass code and then while the pass code is not equal to one 2 three I will basically



90

00:06:20.220 --> 00:06:24.200

be continually asking for a pass code to be provided.



91

00:06:24.240 --> 00:06:26.630

So I'm going to keep asking for the correct pass code.



92

00:06:26.880 --> 00:06:29.450

So let's run this and see what happens.



93

00:06:29.520 --> 00:06:35.130

It says Please provide your pass code and due to the formatting of me in the notebook.



94

00:06:35.280 --> 00:06:40.080

You can see that the input is actually above that welcome message but you can ignore that for now.



95

00:06:40.290 --> 00:06:41.740

It says Please provide your passcode.



96

00:06:41.760 --> 00:06:45.970

Let's provide a wrong password two three four enter and see what happens.



97

00:06:45.970 --> 00:06:47.690

And notice here now asks again.



98

00:06:47.700 --> 00:06:49.070

Please provide your passcode.



99

00:06:49.140 --> 00:06:55.170

We can provide another one by accident something like this three 5:4 cetera and it's going to keep asking



100

00:06:55.170 --> 00:07:01.780

us until we finally provide one to three and then the code is done executing that while loop.



101

00:07:01.890 --> 00:07:07.110

That condition is no longer true because 1 to 3 is equal to 1 2 3.



102

00:07:07.140 --> 00:07:14.370

Notice here when I'm doing of I and t is I'm essentially transforming the string input of 2:59 into



103

00:07:14.370 --> 00:07:15.110

an integer.



104

00:07:15.120 --> 00:07:22.910

That way I can make the comparison here because technically when I do input Let's show you an example



105

00:07:22.910 --> 00:07:25.990

here and I provide a number one two three.



106

00:07:26.030 --> 00:07:29.670

The output is actually a string of that number.



107

00:07:29.690 --> 00:07:34.650

So if I have one to three that's different than the number 1 to 3.



108

00:07:34.670 --> 00:07:36.010

This is a string 1 to 3.



109

00:07:36.020 --> 00:07:37.640

This is the integer 1 to 3.



110

00:07:37.850 --> 00:07:40.800

So if I check for equality here it's going to say false.



111

00:07:40.820 --> 00:07:43.160

They're not equal because different data types here.



112

00:07:43.160 --> 00:07:43.940

One is a string.



113

00:07:43.970 --> 00:07:46.280

One is an integer.



114

00:07:46.310 --> 00:07:56.500

If I wanted to transform this into an integer I can use I and T and then pass it inside Similarly I



115

00:07:56.500 --> 00:07:58.660

can actually do the opposite.



116

00:07:58.660 --> 00:08:05.680

I could say SDR to transform this one into a string and then check for equality with one to three.



117

00:08:06.280 --> 00:08:12.710

And the way you can find out what are these special codes to pass in I.A. for integer or SDR for string.



118

00:08:12.760 --> 00:08:16.450

You'll notice that they actually match up with the result of type.



119

00:08:16.450 --> 00:08:21.970

So if I say type 1 to 3 it returns back SDR in the key and that's a string that's also the same built



120

00:08:21.970 --> 00:08:25.220

in function to try to transform variables into strings.



121

00:08:25.480 --> 00:08:31.130

Or if I try to say type of the integer 1 to 3 it gives back I.A..



122

00:08:31.180 --> 00:08:35.290

So it's a nice little connection between types and they're also they're built in function that attempt



123

00:08:35.290 --> 00:08:42.350

to transform other types and knowing what we already know about control flow we could actually expand



124

00:08:42.440 --> 00:08:49.370

on this simple example here and add in some more control flow to ask for or indicate that the pass code



125

00:08:49.370 --> 00:08:57.080

was wrong so we can also say if passcode is not equal to 1 to 3 colon and the various levels of indentation



126

00:08:57.080 --> 00:09:08.000

I have now I'm going to say Prince wrong password Prince please go again.



127

00:09:08.890 --> 00:09:13.560

And then I will print a new line using that special backslash character and.



128

00:09:13.870 --> 00:09:21.550

And then after all this while loop notice main Then station I'm going to Prince correct password.



129

00:09:21.610 --> 00:09:22.460

So here.



130

00:09:22.630 --> 00:09:25.750

How important in the notation is to organize your code.



131

00:09:25.750 --> 00:09:29.470

Everything here is inside the while loop because it's indented.



132

00:09:29.470 --> 00:09:35.350

Pass this while loop indicated by this colon here and then everything here is inside this if statement



133

00:09:35.430 --> 00:09:41.080

because in the TD into this if statement and then finally this print correct password is only going



134

00:09:41.080 --> 00:09:41.790

to execute.



135

00:09:42.010 --> 00:09:46.540

Once this entire while loop is done executing because it's outside of this while loop because it's not



136

00:09:46.660 --> 00:09:51.670

indented so nosey in the notation here and make sure your code matches the same indentation I'm showing



137

00:09:51.670 --> 00:09:52.820

here on the screen.



138

00:09:52.900 --> 00:09:58.690

So if we run this now and we're providing wrong passwords such as three four five it's going to say



139

00:09:58.690 --> 00:10:00.570

please write your passcode wrong password.



140

00:10:00.570 --> 00:10:01.690

Please go again.



141

00:10:01.690 --> 00:10:08.170

And this is a way you can continually ask for user input until they happen to provide you with the right



142

00:10:08.800 --> 00:10:09.290

password.



143

00:10:09.370 --> 00:10:11.890

One two three and then it says correct password.



144

00:10:11.890 --> 00:10:14.050

At the end.



145

00:10:14.220 --> 00:10:19.920

Finally I want to mention one more key word and that's the break keyword break keyword allows you to



146

00:10:19.920 --> 00:10:23.250

actually break out of the loop that contains the break key word.



147

00:10:23.490 --> 00:10:34.640

So show me a simple example of this I'm going equal to zero and say while X is less than 10 Colan enter



148

00:10:35.420 --> 00:10:42.150

Prince X and then say x is equal to x plus 1.



149

00:10:42.270 --> 00:10:48.380

And if I just from this notice I will get back zero all the way up to 9 because once X's equal to 10



150

00:10:48.440 --> 00:10:50.070

this while loop terminates.



151

00:10:50.160 --> 00:10:56.280

But if I want to break out of this while loop prematurely I could say if on some conditions such as



152

00:10:56.350 --> 00:11:04.580

x is equal to three and then I can say break and that's going to break out of the top containing loop.



153

00:11:04.580 --> 00:11:10.100

So now when I run this notice here since x is equal to 3 here we immediately break and that breaks out



154

00:11:10.100 --> 00:11:11.290

of this loop.



155

00:11:11.420 --> 00:11:13.930

We'll go ahead and explore this break keyword later on.



156

00:11:13.940 --> 00:11:16.100

But I just want you to be aware of it for now.



157

00:11:16.510 --> 00:11:16.880

OK.



158

00:11:16.940 --> 00:11:18.170

That's it for while loops.



159

00:11:18.170 --> 00:11:20.780

Coming up next we're going to discuss for loops.



160

00:11:20.780 --> 00:11:21.550

I'll see you there.



