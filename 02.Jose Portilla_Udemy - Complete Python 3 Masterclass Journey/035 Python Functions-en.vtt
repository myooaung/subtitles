WEBVTT
1

00:00:00.680 --> 00:00:07.490

Welcome back recruit today we'll be discussing functions creating clean repeatable code is a key part



2

00:00:07.490 --> 00:00:09.450

of becoming an effective programmer.



3

00:00:09.650 --> 00:00:15.380

Functions allow us create blocks of code that can easily execute multiple times without needing to constantly



4

00:00:15.380 --> 00:00:17.470

rewrite the entire block of code.



5

00:00:17.480 --> 00:00:19.850

Instead you just call the function name itself.



6

00:00:20.030 --> 00:00:24.020

We've already explored the built in functions in Python such as the range function.



7

00:00:24.020 --> 00:00:27.260

Let's explore the syntax for creating our own functions.



8

00:00:28.640 --> 00:00:30.250

The syntax is the following.



9

00:00:30.260 --> 00:00:34.370

You start off with the keyword allowing you to define the function.



10

00:00:34.490 --> 00:00:40.310

Then you have the name of the function and typically the name is lowercase with snake casing that is



11

00:00:40.310 --> 00:00:42.660

the use underscores to separate different words.



12

00:00:42.890 --> 00:00:48.920

And then you have parentheses a colon and then you can have a docstring or documentation string which



13

00:00:48.920 --> 00:00:52.940

is essentially a multi-line comment which explains the function.



14

00:00:53.090 --> 00:00:57.920

And if you want to see the docstring of a function you can do shift tab and you choose a notebook and



15

00:00:57.920 --> 00:01:02.960

this is what pops up as an explanation for users who intend to execute your function.



16

00:01:02.960 --> 00:01:04.690

And then you have here we can see in blue.



17

00:01:04.730 --> 00:01:09.120

Just whatever code you want to happen when the function executes.



18

00:01:09.170 --> 00:01:13.160

So here we can see in purple at the very bottom what would happen if we executed this command line.



19

00:01:13.250 --> 00:01:15.340

We would call the name of the function and then we get back.



20

00:01:15.350 --> 00:01:15.910

Hello.



21

00:01:15.920 --> 00:01:21.040

It prints out Hello You can also provide parameters to functions.



22

00:01:21.040 --> 00:01:26.350

Here it can see a very similar example except this time it's taking a parameter or an argument called



23

00:01:26.440 --> 00:01:30.580

name and then it's going to print hello and concatenate it with the name.



24

00:01:30.580 --> 00:01:36.390

So if we said name and function pass in the string Hopper it will say hello hopper.



25

00:01:36.490 --> 00:01:40.930

Typically we use the return keyword to send back the result of the function instead of just printing



26

00:01:40.930 --> 00:01:41.770

it out.



27

00:01:41.830 --> 00:01:45.990

So if we take a look at the function we just saw here we're really just printing out results.



28

00:01:46.000 --> 00:01:51.070

Usually when you're writing the functions you're going to be returning the results and to do that we



29

00:01:51.070 --> 00:01:53.420

use the return keyword return.



30

00:01:53.440 --> 00:01:57.150

Allows us to assign the output of the function to a new variable.



31

00:01:57.160 --> 00:02:01.420

Here we can see another example showing this use of return keyword.



32

00:02:01.420 --> 00:02:06.370

We've created a new function called add underscore function and it takes in two parameters or two arguments



33

00:02:06.670 --> 00:02:08.290

number one and number two.



34

00:02:08.450 --> 00:02:12.180

And it's going to return one plus them to.



35

00:02:12.190 --> 00:02:16.510

So when you call this function instead of just calling it and expecting something to be printed out.



36

00:02:16.690 --> 00:02:22.870

Instead what we can do is we can assign a variable equal to whatever gets returned from this function



37

00:02:22.930 --> 00:02:28.960

so we can say result is equal to add underscore function pass and whatever arguments are integers or



38

00:02:28.960 --> 00:02:30.850

numbers we want to add together.



39

00:02:30.850 --> 00:02:35.880

Here we have one and two being added together and then we can print the result to three.



40

00:02:36.010 --> 00:02:43.200

And that allows you to actually use variables in order to save the result of multiple function calls.



41

00:02:43.200 --> 00:02:45.820

Let's explore more examples of using functions by loading a



42

00:02:51.000 --> 00:02:51.590

all right.



43

00:02:51.590 --> 00:02:52.910

So a quick overview.



44

00:02:53.060 --> 00:02:55.370

We have DMF as the keyword.



45

00:02:55.440 --> 00:02:59.660

You're going to have a lowercase function name using snake casing and then as many arguments as you



46

00:02:59.660 --> 00:03:02.630

want in arguments can actually default values.



47

00:03:02.780 --> 00:03:08.360

You'll have your docstring which is denoted by either triple single quotes or triple double quotes and



48

00:03:08.360 --> 00:03:11.980

that allows you to create a multi-line comments or multi-line string here.



49

00:03:12.140 --> 00:03:17.210

That is going to get ignored by your function and then after the docstring you can write code that does



50

00:03:17.210 --> 00:03:18.240

whatever you want.



51

00:03:18.440 --> 00:03:21.150

So let's build up many more examples of this.



52

00:03:21.230 --> 00:03:25.180

We'll start off of a really simple example called Report agent.



53

00:03:25.520 --> 00:03:29.380

So notice I use the F keyword and everything is syntax highlighted here.



54

00:03:29.390 --> 00:03:31.770

Space whatever you want the name of your function to be.



55

00:03:31.880 --> 00:03:39.520

And in this case this function will not take any parameters and we're just going to print out report



56

00:03:39.950 --> 00:03:40.750

agents.



57

00:03:41.080 --> 00:03:46.600

So I do shift enter to run this and once I run this this function has now been defined in the namespace



58

00:03:46.600 --> 00:03:47.290

of Python.



59

00:03:47.320 --> 00:03:53.770

Here my notebook so I can call reports and if I hit tab it will autocomplete to the whatever function



60

00:03:53.770 --> 00:03:54.760

I want.



61

00:03:54.760 --> 00:04:01.120

Keep in mind if I call a function with no parentheses that means it just tells me hey there's a function



62

00:04:01.120 --> 00:04:02.070

here.



63

00:04:02.070 --> 00:04:06.120

Report agent will discuss what this maner represents later on.



64

00:04:06.340 --> 00:04:11.400

But in order to actually execute the function you need to pass an open and close parentheses.



65

00:04:11.410 --> 00:04:13.840

So this actually calls the function to execute.



66

00:04:13.930 --> 00:04:16.560

And here we can see the result report agent.



67

00:04:16.930 --> 00:04:20.380

So now it's shown example of passing in arguments or parameters.



68

00:04:20.440 --> 00:04:24.620

So we're going to create another function called reports.



69

00:04:24.810 --> 00:04:33.990

It takes in a name and it's going to print out reporting and we'll just use print formatting here.



70

00:04:33.990 --> 00:04:38.870

It could also just use concatenation But this report function what it does is it takes in the primary



71

00:04:38.910 --> 00:04:43.330

name and it's going to say reporting whatever you passed in.



72

00:04:43.350 --> 00:04:50.580

So if it's just call report with no parameter ill actually induce an error and it says type error report



73

00:04:50.670 --> 00:04:51.230

is missing.



74

00:04:51.240 --> 00:04:57.360

One required positional arguments name so it needs the name in order to run because it has no default



75

00:04:57.360 --> 00:04:58.530

value for name.



76

00:04:58.590 --> 00:05:05.220

So if we try saying bond they'll say reporting bond.



77

00:05:05.270 --> 00:05:11.050

Let's look at another example that uses default arguments so we can add on a default argument to this



78

00:05:11.060 --> 00:05:18.640

name such as Jason and we rerun the cell to read the fine report as having a default argument.



79

00:05:18.640 --> 00:05:25.900

So now if I run a report bond another time they'll still say reporting bond but since report has a default



80

00:05:25.930 --> 00:05:31.870

value for name it will default to that value if you happen to forget to provide one or it just on purpose



81

00:05:32.140 --> 00:05:33.430

you don't provide one.



82

00:05:33.430 --> 00:05:40.090

So if you write out report now run it it will default to report Jason unless you overwrite it to something



83

00:05:40.090 --> 00:05:44.000

else such as report Sallie and they'll say reporting Sally.



84

00:05:44.080 --> 00:05:47.140

So far all of our functions have only been printing results.



85

00:05:47.230 --> 00:05:51.670

But what if we actually wanted to save the actual results of the function to another variable to did



86

00:05:51.690 --> 00:05:54.160

this we can use the return keyword.



87

00:05:54.190 --> 00:06:00.790

Let's revisit our function of adding two numbers together will create a function called ADD and it takes



88

00:06:00.790 --> 00:06:11.480

in two promoters and one and two colon and we will now say Prince and one plus and 2.



89

00:06:11.490 --> 00:06:17.670

So if I call add to comma three it's going to add them together and print out the number five.



90

00:06:17.790 --> 00:06:23.770

If I wanted to save the result of this I would not be able to because I'm only printing it out.



91

00:06:23.800 --> 00:06:25.210

I'm not actually returning it.



92

00:06:26.680 --> 00:06:30.660

So I will say result is equal to add to comma three.



93

00:06:30.670 --> 00:06:35.890

Notice I get back five but if I call my result I don't get anything.



94

00:06:35.890 --> 00:06:39.880

And if I check the type of my result I get back none type.



95

00:06:40.030 --> 00:06:43.720

This is because this function is only set to print things out.



96

00:06:43.750 --> 00:06:48.380

It's not set to actually return objects to be saved which is why we still see a five here.



97

00:06:48.400 --> 00:06:53.760

It's being printed out but result isn't having anything assigned to it in order to assign something



98

00:06:53.770 --> 00:06:55.730

we need to use the return keyword.



99

00:06:57.030 --> 00:06:59.500

Let's show you now how you can add that in.



100

00:06:59.520 --> 00:07:01.370

We will read the fine R function D.



101

00:07:01.470 --> 00:07:08.250

Add in one comma and two instead of printing out and one plus two.



102

00:07:08.470 --> 00:07:13.160

We are going to return and one plus and two.



103

00:07:13.670 --> 00:07:23.130

And now if I say result is equal to add two and four I can check out that result is now equal to 6.



104

00:07:23.420 --> 00:07:29.510

So that's the difference between using return and using print inside a function and almost always you're



105

00:07:29.510 --> 00:07:32.060

going to be using return inside of functions.



106

00:07:32.060 --> 00:07:37.040

We're just using print's before to basically show you the syntax of a function whenever you're using



107

00:07:37.040 --> 00:07:42.320

functions however more likely than not you're going to be having a return as your final statement.



108

00:07:42.320 --> 00:07:48.710

However it is common to see print statements inside of a function saying something like function ran



109

00:07:48.740 --> 00:07:51.100

well or whatever have you.



110

00:07:51.110 --> 00:07:53.070

So you can see that the function ran well.



111

00:07:53.090 --> 00:07:58.180

That way you can understand what's happening but you'll also be able to see a result again.



112

00:07:58.190 --> 00:08:01.140

Now let's go ahead and solve some problems of functions.



113

00:08:01.160 --> 00:08:04.280

Functions are a core building block for scripts and code.



114

00:08:04.340 --> 00:08:06.430

So we're going to show you some more examples.



115

00:08:06.590 --> 00:08:09.750

Let's imagine you wanted to write a function that returns a boolean.



116

00:08:09.800 --> 00:08:14.270

That is true or false indicating if the word secret is in a string.



117

00:08:14.270 --> 00:08:19.580

So again the problem we're trying to solve here is is the word secret in a string.



118

00:08:19.880 --> 00:08:27.030

So he can functionally is this by saying secret check is the name of my function.



119

00:08:27.030 --> 00:08:36.390

It takes some string my string and then what it's going to do is it's going to return if secret that



120

00:08:36.390 --> 00:08:40.730

string is in my string.



121

00:08:40.780 --> 00:08:45.290

Here we can see a really nice example of why Python has such high readability.



122

00:08:45.290 --> 00:08:52.070

We were able to just plainly read this out by writing a simple syntax secret in my string.



123

00:08:52.210 --> 00:08:53.260

So let's run this.



124

00:08:53.320 --> 00:09:02.950

We'll say secret check and I will say this is a secret and it says true.



125

00:09:03.160 --> 00:09:09.450

And if I take away the word secret this is a lie it returns false.



126

00:09:09.460 --> 00:09:18.280

However if I were to say secret check and it says this is a and we capitalize secret it's going to say



127

00:09:18.280 --> 00:09:24.700

false because this string secret has an uppercase s and it doesn't match exactly of what we were checking



128

00:09:24.700 --> 00:09:25.720

for here.



129

00:09:25.720 --> 00:09:33.820

So to fix that what I could do is say lowercase everything in the string so I rerun the cell to find



130

00:09:33.860 --> 00:09:39.950

that and it will now get if I run this secret check this is true because it's lowering case everything



131

00:09:39.950 --> 00:09:44.230

in that string before it runs a check to see if secret is inside that string.



132

00:09:44.270 --> 00:09:48.380

Keep those sort of things in mind when you're trying to solve problems with functions.



133

00:09:48.380 --> 00:09:50.660

Let's look at one more example.



134

00:09:51.080 --> 00:09:56.720

We're going to do a code maker function and this function will take in the string name and replace any



135

00:09:56.720 --> 00:10:03.600

vowels it sees with the letter X as a way of kind of hiding out the real message inside of it.



136

00:10:03.680 --> 00:10:13.750

So we will say code maker and it takes in my string and let's give it a documentation string or a docstring.



137

00:10:13.770 --> 00:10:18.490

So if you type out one to three quotes either single or double.



138

00:10:18.570 --> 00:10:22.290

You'll notice that you put a notebook automatically completes the second set of three.



139

00:10:22.290 --> 00:10:37.550

So here we can write in our docstring will say input is a string output same string but all vowels are



140

00:10:38.480 --> 00:10:40.760

converted to an X.



141

00:10:40.760 --> 00:10:41.960

So let's just look at this right now.



142

00:10:41.960 --> 00:10:48.490

We're going to whip's say output and we're just going to say do nothing here.



143

00:10:49.570 --> 00:10:55.450

So if we take a look at coachmaker and I do shift tab you'll notice that I can now see the docstring



144

00:10:55.630 --> 00:10:58.400

input is a string output same string Brul vows.



145

00:10:58.400 --> 00:10:59.640

Convert it to an X.



146

00:10:59.680 --> 00:11:03.450

So this documentation's string is the exact same thing that we wrote here.



147

00:11:03.460 --> 00:11:08.410

So there's a nice way for other people who are using your code to understand what your intentions are



148

00:11:08.710 --> 00:11:10.570

when you were creating this function.



149

00:11:10.750 --> 00:11:14.190

Now let's actually fill this out so it does what it describes.



150

00:11:14.200 --> 00:11:16.240

So let's start by doing the following.



151

00:11:16.240 --> 00:11:24.690

We're going to create a variable output that at the very end of all this we're going to return the output



152

00:11:26.790 --> 00:11:32.610

and we'll say output is equal to list my string.



153

00:11:32.620 --> 00:11:35.750

So this allows us to take a string and convert it quickly to a list.



154

00:11:35.770 --> 00:11:41.200

So I'm going to show that really quickly on an example string by pass and list in the string example.



155

00:11:41.200 --> 00:11:46.720

It quickly converts this into a list where every character is now an element in that list.



156

00:11:46.720 --> 00:11:48.470

So that's what output is going to look like.



157

00:11:48.490 --> 00:11:58.190

First then we'll say for I comma a letter in enumerates my string.



158

00:11:58.360 --> 00:12:02.740

Remember that enumerate creates that list of tuple pairs.



159

00:12:03.250 --> 00:12:06.720

So we can say numerators showed the example here.



160

00:12:06.820 --> 00:12:11.250

And let's actually pass this to a list so I can see what this is actually looking like.



161

00:12:11.260 --> 00:12:14.110

It's basically having an index count along with the character.



162

00:12:14.110 --> 00:12:17.830

So again we discuss this back when we talk about useful operators.



163

00:12:17.950 --> 00:12:23.290

So you can review that lesson in case you want to see what enumerate those but how these tuple and packing



164

00:12:23.680 --> 00:12:25.570

of enumerate my string.



165

00:12:25.570 --> 00:12:28.280

And then we're going to save for a vowel.



166

00:12:29.510 --> 00:12:32.600

In and I'm going to create illest avowals.



167

00:12:32.650 --> 00:12:34.130

Just do the basic once here a.



168

00:12:34.160 --> 00:12:38.540

E I O U.



169

00:12:38.540 --> 00:12:41.940

So I'll just consider that as a yvel space for this problem.



170

00:12:41.960 --> 00:12:44.630

So now we're going to use a nested for loop.



171

00:12:44.630 --> 00:12:46.240

Notice the indentation here.



172

00:12:46.250 --> 00:12:49.950

So for every index and letter in the string.



173

00:12:50.210 --> 00:13:00.920

And for every vowel in this list or we're going to do is say if the letter turned lowercase is equal



174

00:13:00.920 --> 00:13:09.210

to a vowel we're going to set the output at that index.



175

00:13:10.490 --> 00:13:12.710

Equal to X.



176

00:13:12.710 --> 00:13:15.610

Let's test out this coachmaker that we just created.



177

00:13:15.860 --> 00:13:21.950

We're going to say result is equal to code maker.



178

00:13:21.950 --> 00:13:27.920

And we're going to pass on some string to a simple one like hello and we can see Hello has two vowels



179

00:13:28.000 --> 00:13:28.560

E.A..



180

00:13:28.580 --> 00:13:35.510

So I would expect the result to look like H x l l x since what I'm doing here is I'm going through every



181

00:13:35.510 --> 00:13:39.780

letter in that string hello that I'm checking for every vowel.



182

00:13:39.860 --> 00:13:41.290

H E I O U.



183

00:13:41.390 --> 00:13:46.320

If there's a match for that letter and then we'll say if that letter that lowercase match to that.



184

00:13:46.340 --> 00:13:51.540

Well go ahead and replace that particular letter in the list with X.



185

00:13:51.620 --> 00:14:00.930

So if we run this and we check the results we get back Liszt's H x l l x or would be nice though.



186

00:14:00.970 --> 00:14:07.340

Instead of getting back this list if we actually got it back as a string to do that we can use the join



187

00:14:07.400 --> 00:14:10.600

function or the join method off a string.



188

00:14:10.610 --> 00:14:12.380

Let me show you how that works.



189

00:14:12.380 --> 00:14:14.640

And then we can implement it inside of this function.



190

00:14:16.190 --> 00:14:18.930

So what we're going to show you is start with a simple example.



191

00:14:18.980 --> 00:14:25.140

We start with an empty string here and then off of this we call the join method.



192

00:14:25.160 --> 00:14:27.920

So it's essentially a method off of a string.



193

00:14:28.280 --> 00:14:33.090

And then we pass an this list of letters



194

00:14:36.890 --> 00:14:42.250

who will say ABC and notice when we get back we get back a b c.



195

00:14:42.300 --> 00:14:51.000

So the way this works is you take in a list here and you're going to join every element in this list



196

00:14:51.540 --> 00:14:56.160

together with whatever the string is in-between them to make that more obvious.



197

00:14:56.160 --> 00:14:59.910

If I had two dashes here in my string and rerun this.



198

00:14:59.910 --> 00:15:05.850

Now I get back to dashes in between every string or every element in this list.



199

00:15:05.970 --> 00:15:11.640

Meaning we can play around with this we can add in a bunch of things like a bunch of X's here and you'll



200

00:15:11.640 --> 00:15:17.430

see that in between each of these elements we get back whatever string we want to join them together



201

00:15:17.430 --> 00:15:18.310

by.



202

00:15:18.330 --> 00:15:23.510

So that means if might have an empty string I just join everything together.



203

00:15:23.730 --> 00:15:29.340

So instead of passing that list I could just pass result and get back that string that I wanted.



204

00:15:29.380 --> 00:15:31.320

H x x.



205

00:15:31.340 --> 00:15:33.110

So let's actually return this then.



206

00:15:33.350 --> 00:15:40.720

So we'll see output here if we come back up remember output is still list at this point.



207

00:15:40.850 --> 00:15:45.920

We're going to say join output.



208

00:15:46.130 --> 00:15:48.940

And in fact we don't technically need to reassign that here.



209

00:15:48.950 --> 00:15:52.430

You could just optionally return this by itself.



210

00:15:52.520 --> 00:15:55.880

So if we run this now check our results.



211

00:15:55.900 --> 00:15:58.150

So rerun the cells we get back H.



212

00:15:58.320 --> 00:15:59.770

X x.



213

00:15:59.770 --> 00:16:06.030

So let's quickly go over what's happening in this piece of code and this function we're saying coachmaker



214

00:16:06.380 --> 00:16:07.840

takes in a string.



215

00:16:07.840 --> 00:16:11.430

We have a documentation string describing what our goal is here.



216

00:16:11.500 --> 00:16:12.700

The IMPA is a string.



217

00:16:12.760 --> 00:16:19.150

The output is that same string but for all of L's are converted to an X or a first step so that we can



218

00:16:19.150 --> 00:16:27.340

easily iterate and do reassignments is we convert or we create an output called list of my string which



219

00:16:27.460 --> 00:16:30.890

essentially is creating a list out of the string as we saw earlier.



220

00:16:31.090 --> 00:16:37.240

Then we're going to use the enumerate operator or enumerate function on our string and saying for every



221

00:16:37.300 --> 00:16:43.300

index position and every letter in that then we have a nested for loop inside of that that for every



222

00:16:43.300 --> 00:16:46.830

letter and for every vowel in this list of vowels.



223

00:16:46.930 --> 00:16:51.280

Go ahead and check that letter when it's lowercase matches up with that vowel.



224

00:16:51.670 --> 00:16:56.650

All this essentially means is for every letter we're going to do five checks against that letter to



225

00:16:56.650 --> 00:17:04.540

see if it matches a vowel and then we're going to say output of II is equal to x so reassign that output



226

00:17:04.600 --> 00:17:07.750

X if there happens to be a match here.



227

00:17:08.140 --> 00:17:13.960

The other thing we could do is if you wanted to just for readability you could say else and then use



228

00:17:13.960 --> 00:17:17.550

the pass key word to indicate that you're not going to do anything else.



229

00:17:17.770 --> 00:17:25.430

So it would be if there was a match re-assignment else pass don't do anything that's optional here.



230

00:17:25.540 --> 00:17:27.000

You don't actually really need it.



231

00:17:27.190 --> 00:17:30.140

Otherwise the code will still run the same way if you have it or not.



232

00:17:30.400 --> 00:17:32.550

At the very end we have that list for the output.



233

00:17:32.580 --> 00:17:36.370

And we're going to join the output together using the string right here.



234

00:17:36.370 --> 00:17:41.830

And because the string is empty We're essentially just joining it together every element in that list.



235

00:17:41.830 --> 00:17:42.280

All right.



236

00:17:42.280 --> 00:17:47.800

That's the basics of functions and now that you understand functions as some of the basic building blocks



237

00:17:47.830 --> 00:17:54.610

of larger scripts it really opens up the possibilities of the type of problems you can solve with Python.



238

00:17:54.610 --> 00:18:00.160

Earlier you were seeing in your field readiness exams that we had to constrict the actual problem statements



239

00:18:00.220 --> 00:18:06.700

because more complex problems really need a functional grasp in order to create a real solution for



240

00:18:06.700 --> 00:18:07.410

them.



241

00:18:07.420 --> 00:18:12.310

Now the understand how functions work we're actually going to give you a list of tasks coming up next



242

00:18:12.640 --> 00:18:14.320

to solve with functions.



243

00:18:14.320 --> 00:18:19.040

So we'll see at the next lesson where we describe the tasks you need to solve with functions.



