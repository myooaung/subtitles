WEBVTT
1

00:00:00.390 --> 00:00:01.620

Welcome back recruit.



2

00:00:01.620 --> 00:00:07.170

We've already discussed how you can store Python data objects using a list or a dictionary.



3

00:00:07.170 --> 00:00:13.320

Now let's learn about tuples tuples are actually very similar to a list.



4

00:00:13.480 --> 00:00:16.570

They're ordered sequences of objects just like IList.



5

00:00:16.590 --> 00:00:18.530

However there's two key differences.



6

00:00:18.540 --> 00:00:23.670

One is that they use a slightly different syntax than the list they use parentheses instead of square



7

00:00:23.670 --> 00:00:24.570

brackets.



8

00:00:24.570 --> 00:00:26.240

Here you can see an example of a tuple.



9

00:00:26.250 --> 00:00:31.610

We call this variable my tuple and it's equal to in parentheses one comma to come a three.



10

00:00:31.650 --> 00:00:36.930

So very similar to a list and syntax except for using parentheses instead of square brackets.



11

00:00:36.930 --> 00:00:42.770

The other major difference and this is the most fundamental one is that tuples are what we call immutable



12

00:00:44.180 --> 00:00:50.100

so mutability refers to the ability to change or alter comes from the word mutate or mutation.



13

00:00:50.100 --> 00:00:55.620

Once you've assigned an object to a position in a tuple you cannot reassign it in a list.



14

00:00:55.620 --> 00:00:57.010

You could do this re-assignment.



15

00:00:57.030 --> 00:00:59.300

However in the tuple you cannot.



16

00:00:59.340 --> 00:01:03.200

Let's explore how to work with tuples in Python by loading up a Jupiter notebook.



17

00:01:07.200 --> 00:01:13.320

Let's begin by creating an example tuple I'll say my tuple is equal to and it's going to be really similar



18

00:01:13.320 --> 00:01:16.260

to a list except now are using parentheses here.



19

00:01:16.310 --> 00:01:19.000

We'll say one comma to comma three.



20

00:01:19.260 --> 00:01:25.230

And if I check the type of this object my tuple returns back that it's a tuple type and just like a



21

00:01:25.230 --> 00:01:25.610

list.



22

00:01:25.620 --> 00:01:33.090

You can also use mixed data types so we could say T is another tuple where we have a string mixin with



23

00:01:33.090 --> 00:01:36.660

an integer mixed in a float and tuple doesn't mind.



24

00:01:36.840 --> 00:01:39.810

And you can use indexing or slicing just like you would have a list.



25

00:01:39.810 --> 00:01:41.290

So if I wanted that letter A.



26

00:01:41.520 --> 00:01:44.900

I could just use that bracket annotation just like we use the full list.



27

00:01:44.910 --> 00:01:48.550

However the key difference here is the immutability of a tuple.



28

00:01:48.840 --> 00:01:56.600

So I'm going to create my list one two three let's check the type of my list confirm that it in fact



29

00:01:56.690 --> 00:01:57.730

is a list.



30

00:01:57.860 --> 00:01:58.550

So it is.



31

00:01:58.580 --> 00:02:01.910

And then we still have my original tuple.



32

00:02:02.150 --> 00:02:03.140

One two three.



33

00:02:03.230 --> 00:02:03.910

One is a list.



34

00:02:03.920 --> 00:02:05.350

One is a tuple.



35

00:02:05.480 --> 00:02:09.730

So let's imagine that I wanted to reassign the first item in my list.



36

00:02:09.800 --> 00:02:14.290

So that is the item in the location 0 to be something new.



37

00:02:14.630 --> 00:02:18.860

Well I can easily do that by saying my list at 0 is equal to new.



38

00:02:19.190 --> 00:02:22.830

And then if I check out my list now I have new come to come.



39

00:02:22.850 --> 00:02:30.380

Three if I tried the same thing with the tuple object that created I'm going to get an error and if



40

00:02:30.380 --> 00:02:31.280

I send you here.



41

00:02:31.280 --> 00:02:32.800

It's going to say type error.



42

00:02:32.930 --> 00:02:36.070

The tuple object does not support item assignment.



43

00:02:36.290 --> 00:02:44.050

And that means that I can't add in or replace the objects that are already inside the tuple.



44

00:02:44.060 --> 00:02:49.940

You'll also notice that once I've created that tuple and I check out the available methods it's just



45

00:02:49.940 --> 00:02:50.980

count an index.



46

00:02:50.990 --> 00:02:57.350

There's no way I can append something else that you say hey tuple has no object or the tuple object



47

00:02:57.350 --> 00:02:58.670

has an attribute.



48

00:02:58.850 --> 00:02:59.940

Append.



49

00:03:00.140 --> 00:03:08.180

So that means that there's really only two methods you can do for tuple and that is indexing and counting.



50

00:03:08.180 --> 00:03:17.330

So I will create a tuple object A B C and let's say again.



51

00:03:17.330 --> 00:03:26.890

So I have ABC and a if I wanted to find out the first occurrence of B I can say C index pass and B in



52

00:03:27.010 --> 00:03:32.490

order to turn back the location of the first time B occurs inside the tuple.



53

00:03:32.630 --> 00:03:39.140

If I want to count how many times an object occurs inside this tuple I can say T and then use the count



54

00:03:39.140 --> 00:03:45.290

method and ask it how many times does a string a show up in the tuple and it returns back that it shows



55

00:03:45.290 --> 00:03:46.690

up twice.



56

00:03:46.700 --> 00:03:52.670

Now you may be wondering why would you ever use tuples since they have this immutability aspect to them.



57

00:03:52.760 --> 00:03:57.890

You should use a tuple for collections or sequences that shouldn't be changed things like the dates



58

00:03:57.890 --> 00:04:02.510

of the year or user information where you want the order to remain the same.



59

00:04:02.750 --> 00:04:09.790

And let's actually show in example of this recall that we were creating a dictionary so say a has the



60

00:04:09.790 --> 00:04:14.220

value 1 and B he's going to have the value to.



61

00:04:14.230 --> 00:04:19.040

So I have this dictionary when I called the items of my dictionary.



62

00:04:19.300 --> 00:04:24.640

I got back this lists are a sort of brackets of tuples.



63

00:04:24.640 --> 00:04:30.550

And the reason reason tuples here is because this allows me to know whenever the method or whatever



64

00:04:30.550 --> 00:04:36.910

code that is behind the scenes of this items called is using tuples because it knows that this order



65

00:04:36.910 --> 00:04:38.350

can't be switched around.



66

00:04:38.380 --> 00:04:43.110

So are you using tuples when you want to make sure that you don't have any changes occurring.



67

00:04:43.180 --> 00:04:48.490

So this is basically almost like a slight security feature of your data type in the sense that you're



68

00:04:48.490 --> 00:04:54.310

not going to be able to accidentally re-index something and then reassign it here I know that the first



69

00:04:54.310 --> 00:04:58.600

item in the tuples are going to be the key and the second item in the tuple is going to be the value



70

00:04:58.690 --> 00:05:00.160

associated with it.



71

00:05:00.370 --> 00:05:06.190

And there's lots of built in functions and methods in Python that return lists of tuple items as we've



72

00:05:06.190 --> 00:05:09.750

seen here and later on when we discuss for loops.



73

00:05:09.760 --> 00:05:14.320

We'll see how we can use something called tuple and a packing to work with these functions and methods



74

00:05:14.560 --> 00:05:17.120

that return back lists of tuple objects.



75

00:05:17.170 --> 00:05:19.330

For now just keep in mind that tuples.



76

00:05:19.330 --> 00:05:25.240

The main difference here is that syntax wise you're constructing them with a parentheses and that they



77

00:05:25.240 --> 00:05:30.050

do not support item re-assignment they're immutable objects.



78

00:05:30.060 --> 00:05:31.270

I'll see you at the next lesson recruit.



