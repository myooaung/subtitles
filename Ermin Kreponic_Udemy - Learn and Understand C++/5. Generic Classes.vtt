WEBVTT

00:00.400 --> 00:07.910
OK, por lo que respecta a las clases genéricas, el concepto es similar al de las funciones.

00:08.130 --> 00:19.080
Así que sigamos y creemos nuestra clase genérica que tengo en mi sabiduría

00:21.870 --> 00:28.740
infinita llamada tipo genérico ficticio tipo de nombre

00:31.780 --> 00:38.360
de plantilla y Double-O escribirá en clase ficticia genérica.

00:39.050 --> 00:40.070
DE ACUERDO.

00:43.360 --> 00:53.310
Eric y todos seguimos adelante y hacemos algo bastante extraño para ese atributo de esperanza.

00:53.750 --> 01:01.900
Entonces, esto creará básicamente un atributo del tipo que adivinaste de ese tipo.

01:02.180 --> 01:06.950
Entonces, una vez más, está creando un atributo de tipo tipo.

01:06.980 --> 01:10.380
Ese es literalmente el nombre de eso.

01:10.430 --> 01:20.020
Así que sigamos y escriba en público y no, no es así como quiero que sea.

01:20.360 --> 01:27.230
Sé que se llama libros, quiero que sea así, pero no es solo un maniquí.

01:27.670 --> 01:36.100
Los genéricos van a seguir adelante y obtener nuestro tipo de crear nosotros mismos un constructor aquí

01:40.640 --> 01:45.330
escriba Padam Y y vamos a inicializar los atributos también.

01:45.710 --> 01:49.070
Entonces, pase lo que pase aquí, es un parámetro.

01:49.090 --> 01:54.030
Siempre que se ajuste a su atributo, se inicializará a ese valor.

01:56.140 --> 01:58.080
Vamos a dejar eso vacío.

01:58.090 --> 02:01.640
Quiero decir que la lógica del constructor iría aquí como antes, pero por el momento.

02:01.730 --> 02:03.430
Solo voy a seguir y dejarlo vacío a Israel.

02:03.430 --> 02:14.870
No necesita poner nada en él para demostraciones y Almelo tecleará el tipo y obtendrá terabit.

02:14.970 --> 02:23.910
Esto no cambiará nada, así que muestro que es Kunst y va a girar

02:26.220 --> 02:27.620
este atributo.

02:28.160 --> 02:28.530
Está

02:31.520 --> 02:33.790
bien, te estás perdiendo algo.

02:34.000 --> 02:43.790
Así que devuelve este signo menos mayor que el signo y el atributo, por lo que básicamente devolverá el

02:43.790 --> 02:47.520
atributo para el que hemos definido previamente.

02:47.540 --> 02:52.950
Si no ha logrado concluir hasta ahora, esta es la función getter.

02:53.060 --> 02:58.080
Es una función que tiene un tipo de tipo de retorno y está regresando.

02:58.100 --> 03:01.870
Nos devolverá el atributo cuando se llame.

03:01.880 --> 03:06.770
Es un método para seguir intercambiando funciones y métodos.

03:06.770 --> 03:11.340
Más o menos lo mismo, excepto las funciones que están dentro de las clases, se llaman métodos.

03:11.360 --> 03:12.960
Eso es practicamente todo.

03:12.980 --> 03:14.490
Así que no te confundas con eso.

03:14.660 --> 03:18.440
Y luego voy a seguir adelante y crear un setter.

03:19.180 --> 03:23.100
Probablemente debería hacer esto por razones estáticas.

03:23.330 --> 03:27.300
Void set attribute type a mind mind

03:30.180 --> 03:42.000
capitalización de letras C ++ es extremadamente sensible a mayúsculas y minúsculas y el atributo es igual a a.

03:42.480 --> 03:50.220
Así que este será el centro porque esta variable está en privado y la obtendrá y

03:50.220 --> 03:53.610
establecerá mediante el uso de métodos públicos.

03:54.560 --> 04:02.720
Y América por supuesto eliminar este sí hoy por favor.

04:02.990 --> 04:05.090
No, yo lo haría.

04:05.250 --> 04:12.060
Y luego, más abajo, podemos obtener una gran cantidad de certeza, eliminarnos sabiendo que no

04:12.360 --> 04:19.170
vamos a usar esa cosa de nuevo y crear una instancia genérica aquí en Maine.

04:19.170 --> 04:28.230
Es necesario especificar el tipo con el que queremos crear una instancia dentro de estos corchetes angulares.

04:28.230 --> 04:34.110
Así que escribiré el dummy y el genérico, y esto estará en.

04:34.420 --> 04:36.030
OK, así que

04:38.570 --> 04:39.460
necesitan

04:42.150 --> 04:45.170
un final el maniquí y.

04:45.540 --> 04:47.760
Y jugaremos de pie aquí.

04:48.540 --> 04:58.560
Entonces el tipo será tipo será int y crearé algunos más en la línea solo para el caso de los propósitos.

04:58.600 --> 05:05.760
Hagamos otro y hagamos otro y este será Shahr.

05:05.880 --> 05:10.530
Entonces el y este será doble.

05:10.560 --> 05:11.630
Sí. Seguro, por qué no.

05:11.640 --> 05:12.990
Pongamos como un doble.

05:13.020 --> 05:16.260
Diez punto noventa y nueve y este será un número entero.

05:16.260 --> 05:18.600
Ahora tenemos que cambiarlos aquí también.

05:18.630 --> 05:34.730
Así que aquí voy a tener un doble y aquí voy a char y abajo debajo del no así que también voy a hacer esto para

05:34.850 --> 05:36.660
condenar la línea.

05:36.920 --> 05:47.870
Char Dart dijo terabit p.

05:48.110 --> 05:49.100
Aquí vamos.

05:50.100 --> 05:53.320
Entonces, ¿qué hicimos aquí?

05:53.340 --> 05:56.480
¿Por qué cuál es el propósito de todo esto?

05:56.490 --> 05:57.670
¿Por qué se llama genérico?

05:57.690 --> 06:00.160
Bueno, creo que ya puedes resolverlo.

06:00.300 --> 06:07.680
Mira, es como el tipo de nombre y luego tienes una B que dice genérico que no significa nada.

06:07.680 --> 06:10.100
Ese es solo un nombre arbitrario de la clase.

06:10.230 --> 06:13.740
Y luego tienes atributo que es de tipo tipo.

06:13.750 --> 06:16.360
Al igual que en la tierra es tipo tipo.

06:16.590 --> 06:19.050
Bueno, es por eso que se llama genérico.

06:19.050 --> 06:23.690
Como puede ver, puede pasarle a este constructor prácticamente todo lo que quiera.

06:23.710 --> 06:31.440
Bien, tómenlo con un grano de sal, por supuesto, pero pueden pasar genéricamente un parámetro que

06:31.440 --> 06:34.170
no necesita ser predefinido aquí.

06:34.200 --> 06:35.540
Entonces de alguna manera.

06:35.730 --> 06:40.220
Por lo tanto, no necesita especificar que va a ser un doble, un entero o un char.

06:40.230 --> 06:44.730
En su lugar, puede especificarlo cuando se produce la instanciación.

06:44.740 --> 06:51.380
Así que dummy genérico y he especificado que el tipo es int y luego lo tengo.

06:51.380 --> 06:57.870
Y luego lo he usado y básicamente utilicé este constructor para inicializar el atributo a

06:57.930 --> 06:59.310
ese valor particular.

06:59.310 --> 07:03.650
Entonces ahora el atributo tendrá el valor de 10 y será un número entero.

07:03.660 --> 07:05.490
Entonces sigamos construyendo y ejecutando esto.

07:05.550 --> 07:09.600
Y, por supuesto, parece haber un error en alguna parte.

07:10.580 --> 07:13.980
Probablemente un error ortográfico de algún tipo.

07:14.030 --> 07:15.100
Derecha.

07:15.260 --> 07:18.900
Me he olvidado de modificar estos también.

07:19.340 --> 07:25.850
No necesitan ser llamados dummy y dummy double etc. eso es solo O, pero eso es CHAR arbitrario.

07:25.870 --> 07:28.310
Pero por el simple hecho de hacer referencia, es más fácil así.

07:28.310 --> 07:29.850
Hagamos esto una vez más.

07:29.870 --> 07:30.410
Y ahí tienes.

07:30.410 --> 07:34.370
En realidad funciona sin ningún tipo de problema.

07:34.370 --> 07:43.040
Así que ahora cuando escribo en dummy underline char, el atributo set realmente establecerá el conjunto del conjunto.

07:43.040 --> 07:50.260
Esto establece esta variable con el valor de E en que será un char.

07:50.360 --> 07:59.150
Si tuviera que llamar a un dummy double y si tuviera que utilizar el método get at the

07:59.180 --> 08:05.700
attribute attribute, inicializaría los atributos a un diez punto noventa y nueve, etc. Entonces el tipo no necesita ser especificado de antemano en si es un int.

08:05.720 --> 08:11.320
Es un doble para chamuscar, excepto que puedes poner más o menos lo que

08:11.330 --> 08:18.320
sea que necesites aquí y luego usarlo, ya que puedes instanciar una clase al tipo que realmente requieras.

08:18.410 --> 08:23.930
En el camino en el código en lugar de lo que hemos hecho con la fecha

08:23.960 --> 08:32.150
de la clase donde sabemos los tipos en que está en un mes y es entier y solo puede estar en Turnage no puede

08:32.150 --> 08:38.300
ser nada más a menos que realmente modifiquemos el código mientras aquí en una clase genérica no necesita serlo.

08:38.300 --> 08:45.050
El atributo no necesita ser una entidad, no necesita ser un doble, no necesita ser un char.

08:45.080 --> 08:49.190
Todo eso puede en realidad ser especificado más adelante al llamar

08:49.220 --> 08:57.920
al momento de acceder a los atributos privados de una clase sobre la instanciación que es un concepto muy útil en la programación.

08:57.920 --> 09:05.350
Y créanme si continúan practicando C ++ si hacen algo con C ++ esto les

09:05.390 --> 09:12.800
será extremadamente útil porque simplemente imaginen que están haciendo algo y se darán cuenta de

09:12.860 --> 09:19.940
que lo necesito Necesito necesito Necesito un char aquí en vez de un int .

09:19.940 --> 09:23.400
Qué vas a hacer.

09:23.420 --> 09:24.160
Regrese y reescriba la clase.

09:24.170 --> 09:26.560
No es Buena idea.

09:26.600 --> 09:27.580
Quiero decir que vas a dejar de lado el hecho de que perderás una tonelada de tiempo.

09:27.590 --> 09:31.100
Es cuestionable cuando lo reescribes.

09:31.100 --> 09:32.780
Si esa clase funcionará con el resto del código a continuación.

09:32.790 --> 09:36.620
Por lo tanto, no solo necesitaría reescribir la clase que necesita para

09:37.010 --> 09:40.880
volver a escribir el resto del código para que se ajuste así.

09:40.880 --> 09:42.320
Usted tiene una forma genérica en la que puede enchufar prácticamente cualquier tipo que desee.

09:42.320 --> 09:49.020
OK, eso sería todo.

09:49.370 --> 09:50.630
Vamos a seguir adelante

09:50.630 --> 09:56.270
y llamar al capítulo aquí y vamos a pasar al siguiente capítulo en el siguiente tutorial.

09:56.270 --> 09:57.400
&nbsp;
