WEBVTT

00:00:00.000 --> 00:00:03.171
Hey, welcome back. So
today we're going to

00:00:03.196 --> 00:00:06.440
talk a little bit about
C++ variables so

00:00:06.540 --> 00:00:11.929
far we have worked with constant values
such as the ones we've used before I

00:00:11.929 --> 00:00:17.350
don't know it was like 2015, why do I keep writing fifteen?

00:00:17.350 --> 00:00:23.920
is beyond me 2016 for a year or I don't
know some number for a month or you had

00:00:23.920 --> 00:00:27.029
a string hello hello world or whatever

00:00:27.720 --> 00:00:33.239
well now I would like to introduce
variables so variable is just the name

00:00:33.239 --> 00:00:39.145
of a location in the
memory or RAM are a so

00:00:39.170 --> 00:00:44.830
RAM, this is a location
within memory this

00:00:44.930 --> 00:00:47.434
this RAM is like
those plates that you

00:00:47.459 --> 00:00:49.729
put into your computer
I don't know like 4

00:00:49.829 --> 00:00:54.924
gigs plates 6 sorry,
4816 etc, so you can

00:00:54.949 --> 00:00:59.649
have I don't know,
most people I think I

00:00:59.649 --> 00:01:02.889
have arrived in between 8 and 16
gigs of ram something like that I'm

00:01:02.889 --> 00:01:05.330
pretty sure you know what I'm talking
about,

00:01:05.330 --> 00:01:10.570
in case you don't, just open up Google and
type in what is RAM or something like

00:01:10.570 --> 00:01:13.218
that and use your
favorite search engine

00:01:13.243 --> 00:01:15.979
anyway using variables
we will directly

00:01:15.979 --> 00:01:20.302
access memory locations
so variables can

00:01:20.327 --> 00:01:24.710
be of different type
and this type must be

00:01:24.710 --> 00:01:26.848
defined whenever we
declare a variable

00:01:26.873 --> 00:01:29.380
without this, we
won't be able to

00:01:29.380 --> 00:01:32.316
actually use them,
well in most cases,

00:01:32.341 --> 00:01:35.189
there are some border
cases where this

00:01:35.189 --> 00:01:39.340
perhaps is not true but that doesn't
matter for the time being the syntax for

00:01:39.340 --> 00:01:42.340
declaring variables is as follows

00:01:43.110 --> 00:01:46.315
so you first basically
state the type of

00:01:46.340 --> 00:01:49.520
the variable so you
type in some sort of a type

00:01:51.909 --> 00:01:55.980
and then you'll give the
variable name so I don't

00:01:56.005 --> 00:02:00.200
know, var name and that's
it you can even assign

00:02:00.200 --> 00:02:07.909
a value here but we're gonna
get into that. Anyway, so

00:02:09.940 --> 00:02:12.229
type, represents the
type of the variable and

00:02:12.254 --> 00:02:14.690
variable name is
basically just the name

00:02:14.790 --> 00:02:17.560
of the variable,
there are rules for

00:02:17.585 --> 00:02:20.330
naming variables
name consists of

00:02:20.330 --> 00:02:24.080
letters of English
alphabet a to z a

00:02:24.105 --> 00:02:27.240
lower case letters A
to Z capital case

00:02:27.340 --> 00:02:31.653
letters, digits 0 to 9
and underscore sign.

00:02:31.678 --> 00:02:35.190
You cannot use pretty
much anything else

00:02:35.190 --> 00:02:41.549
variable names also cannot
begin with a digit, only letters and

00:02:41.549 --> 00:02:49.260
underlined signs are allowed to be the
beginning of the beginnings of name or

00:02:49.260 --> 00:02:52.885
the name of these variables.
So here's an

00:02:52.910 --> 00:02:56.359
example of correct
and incorrect names

00:02:56.359 --> 00:03:00.700
so for example if I'm typing
00 var underline name,

00:03:00.725 --> 00:03:05.120
this would be an incorrect
example of a name

00:03:05.120 --> 00:03:09.804
if I'm typing underline,
var, name, this would

00:03:09.829 --> 00:03:14.410
be a perfectly legit variable name.
So this

00:03:14.410 --> 00:03:17.252
is not hard, you just
use letters in the

00:03:17.277 --> 00:03:19.970
alphabet lowercase
and uppercase use

00:03:19.970 --> 00:03:24.200
digits from 0 to 9 and you can use an
underscore sign that's it nothing else

00:03:24.200 --> 00:03:27.050
but you really don't
need anything else

00:03:27.075 --> 00:03:29.490
you can name your
variables rather

00:03:29.590 --> 00:03:31.843
easily just don't put
the numbers in the

00:03:31.868 --> 00:03:34.049
first place and that's
pretty much it it

00:03:34.049 --> 00:03:36.448
is considered to be
a good practice for

00:03:36.473 --> 00:03:38.910
variable names to
be self descriptive

00:03:39.010 --> 00:03:44.403
for example if you
go ahead and do

00:03:44.428 --> 00:03:49.830
this let's say that
you have a max and

00:03:49.930 --> 00:03:52.842
minimum value of something
I don't know, doesn't

00:03:52.867 --> 00:03:55.190
matter, so max this
would be a name for

00:03:55.290 --> 00:03:59.540
one variable and then you would have
min, this would be a name for another

00:03:59.540 --> 00:04:01.400
variable but

00:04:01.400 --> 00:04:06.269
what would be bad name for this is if
you type them like I don't know, G and then

00:04:06.269 --> 00:04:08.531
r, because you have
no idea what this

00:04:08.556 --> 00:04:10.909
means it's a good
idea it's a good

00:04:10.909 --> 00:04:12.607
practice it's good
practice to actually

00:04:12.632 --> 00:04:14.650
name your variables
in a descriptive

00:04:14.750 --> 00:04:18.005
fashion so it that
pretty much explain

00:04:18.030 --> 00:04:20.870
what sort of values
today contain, you

00:04:20.970 --> 00:04:25.880
could have named the variable
temperature or degrees or something like

00:04:25.880 --> 00:04:32.440
that but giving some random names that
don't actually associated with the value

00:04:32.440 --> 00:04:37.250
of the variable but that makes very
little sense you'll see later on when

00:04:37.250 --> 00:04:39.001
you get it doesn't
make it that much of

00:04:39.026 --> 00:04:40.789
a difference in a
simple program like

00:04:40.889 --> 00:04:43.897
this but later on when
you get into code

00:04:43.922 --> 00:04:47.030
into a into coding
and if you have a

00:04:47.030 --> 00:04:49.705
program that contains
like one million

00:04:49.730 --> 00:04:52.380
lines of code it is
a very good idea to

00:04:52.380 --> 00:04:56.590
follow standardized programming
practices otherwise you will get lost on

00:04:56.590 --> 00:04:59.091
or other people will get lost in

00:04:59.116 --> 00:05:01.789
your code and you as well.
Anyway,

00:05:01.789 --> 00:05:05.655
C++ types can be
grouped into embedded

00:05:05.680 --> 00:05:09.340
this is a part of C++
and user-defined

00:05:09.440 --> 00:05:12.336
so a user can define them, so

00:05:12.361 --> 00:05:15.324
user can define a type as well

00:05:17.130 --> 00:05:23.630
embedded ones that are a part
of C++ can be divided into grow

00:05:23.630 --> 00:05:26.976
real and pointer so
let's go ahead and

00:05:27.001 --> 00:05:30.060
take a look at some
of them into grow

00:05:30.060 --> 00:05:37.830
ones, bool I will go over all
of these, you have bool, you have char

00:05:37.830 --> 00:05:41.861
you have short in a
long long actually

00:05:41.886 --> 00:05:45.879
the variable is a
variable type is long

00:05:45.979 --> 00:05:49.419
long long and then
you have long long

00:05:49.444 --> 00:05:52.630
signed unsigned and
for real you have

00:05:52.630 --> 00:05:56.486
like floating pool
float double and long

00:05:56.511 --> 00:06:00.010
double four pointer
well you can put

00:06:00.110 --> 00:06:03.110
pretty much all of the above into the
pointers

00:06:03.900 --> 00:06:06.145
anyway it doesn't
really matter I shall

00:06:06.170 --> 00:06:08.190
explain these individually
I just wanted

00:06:08.290 --> 00:06:12.449
to mention them there. Now the
user defined ones these are a bit more

00:06:12.449 --> 00:06:17.870
complicated ones can be divided into
standard which are a part of C++

00:06:17.870 --> 00:06:21.060
libraries for example
you could have

00:06:21.085 --> 00:06:24.740
something like a std,
colon, colon, string

00:06:24.840 --> 00:06:29.156
or std, colon, colon,
vector I know and

00:06:29.181 --> 00:06:32.970
those would be the
ones that are defined

00:06:33.070 --> 00:06:39.280
by the user but there are some more
complicated things that a user can

00:06:39.280 --> 00:06:46.470
when a user can define a
type and this sort of variables I do

00:06:46.470 --> 00:06:50.400
believe, yes they can be found in the
keylogger course throughout the

00:06:50.400 --> 00:06:53.014
keylogger as we
needed to, a lot of

00:06:53.039 --> 00:06:55.570
things to get to be
custom-made so you

00:06:55.570 --> 00:06:57.467
can see them there,
but anyway forget

00:06:57.492 --> 00:06:59.590
about that for now,
just focus on the

00:06:59.590 --> 00:07:01.658
more simple stuff
I just wanted to

00:07:01.683 --> 00:07:04.300
mention them that's it.
For now, we will

00:07:04.300 --> 00:07:08.050
use embedded types
so the ones that are

00:07:08.075 --> 00:07:11.580
in C++ so these are,
you have bool, now

00:07:11.580 --> 00:07:17.520
bool can be either true or
it can be false

00:07:17.520 --> 00:07:20.537
those are the two
values that this type

00:07:20.562 --> 00:07:23.319
can have, so if I have
bool, which is the

00:07:23.419 --> 00:07:25.730
type and then the
name of the variable

00:07:25.755 --> 00:07:27.810
can be test, so this
can be equal to

00:07:27.810 --> 00:07:32.349
basically true or false

00:07:33.130 --> 00:07:37.260
this can also be substituted with
numbers 0 would represent something to

00:07:37.260 --> 00:07:44.989
be false and any positive integer like
123 or I don't know this number

00:07:45.389 --> 00:07:48.454
they would all
evaluate to true, so

00:07:48.479 --> 00:07:51.320
it can only have two
values it can be

00:07:51.320 --> 00:07:53.430
either true or it can be false

00:07:53.430 --> 00:07:57.371
now the next one that
you have is called

00:07:57.396 --> 00:08:01.050
Char, Char stands
for characters so I

00:08:01.050 --> 00:08:05.522
don't know you could
char c, this could

00:08:05.547 --> 00:08:09.880
be equal to a character
I don't know, w so

00:08:11.750 --> 00:08:19.500
character W that's it, it contains
characters basically unsigned char you

00:08:20.300 --> 00:08:28.160
have this one which is unsigned char, and the
range of unsigned char is from 0 to 255

00:08:32.860 --> 00:08:37.800
and you have signed char whose range is
from minus 128

00:08:37.800 --> 00:08:45.340
to 127, if you have a red X if you have a like

00:08:47.640 --> 00:08:51.490
something that stands in front of
char, in front of pretty much any other

00:08:51.490 --> 00:08:56.030
variable that says variable type it
says like unsigned or signed it is

00:08:56.030 --> 00:09:01.380
usually referring to positive and
positive and negative numbers so if I

00:09:01.380 --> 00:09:03.844
say for example
unsigned that means

00:09:03.869 --> 00:09:06.420
that usually this
type can only contain

00:09:06.420 --> 00:09:10.863
positive values and
if I say sign then

00:09:10.888 --> 00:09:14.770
it can also have
negative values I know

00:09:14.870 --> 00:09:19.190
I notice that this seems a little bit weird that a

00:09:19.190 --> 00:09:21.353
character contains
positive and negative

00:09:21.378 --> 00:09:23.710
values but you will
see when we get like

00:09:23.810 --> 00:09:28.800
when we mention the ASCII table and
how the char actually works, and how you

00:09:28.800 --> 00:09:30.916
can use actually
numbers instead of

00:09:30.941 --> 00:09:32.940
characters which
eventually evaluate two

00:09:32.940 --> 00:09:36.777
characters but in
general you can also

00:09:36.802 --> 00:09:40.520
have like insigned
int, which is like an

00:09:40.520 --> 00:09:42.508
integer but if it's
unsigned integer

00:09:42.533 --> 00:09:44.589
that it can only
receive a positive

00:09:44.589 --> 00:09:47.368
value then, only a positive
value can be assigned

00:09:47.393 --> 00:09:50.100
to it, so unsigned int
and I don't know int

00:09:50.200 --> 00:09:52.522
number equals, so
this can only receive

00:09:52.547 --> 00:09:55.160
value, this can only
be assigned values

00:09:55.160 --> 00:09:58.670
like 10 I don't know one

00:09:58.670 --> 00:10:03.340
2, as long as it's
a positive whole

00:10:03.365 --> 00:10:07.340
number, just want
to explain that

00:10:07.440 --> 00:10:10.942
would unsigned and sign.
You also have a

00:10:10.967 --> 00:10:14.530
variable type called
short this is to

00:10:14.530 --> 00:10:17.516
represent very small
numbers let's go

00:10:17.541 --> 00:10:20.910
ahead and use signed
and unsigned again so on

00:10:21.740 --> 00:10:29.680
unsigned short this basically would
represent numbers in the range between 0

00:10:29.680 --> 00:10:36.960
and it's written on my
screen here 65536 65536

00:10:36.985 --> 00:10:43.830
so this would represent
numbers between

00:10:43.930 --> 00:10:48.172
this range, and you would
have like down below,

00:10:48.197 --> 00:10:52.230
this is some code that
I'm ranging here so i'm

00:10:52.230 --> 00:11:00.100
unsigned here, ups, sorry
signed short which would be minus 32268

00:11:08.100 --> 00:11:15.190
so this would be the beginning of
the range and the end of the range would

00:11:15.190 --> 00:11:20.005
be 32267, excelent. So
this would be a type

00:11:20.030 --> 00:11:25.230
short which has this
range and only values

00:11:25.230 --> 00:11:31.040
from this range can be assigned to a
variable of type short and likewise

00:11:31.040 --> 00:11:34.655
unsigned short and
signed short can only

00:11:34.680 --> 00:11:38.700
receive unsigned short
variable can only

00:11:38.700 --> 00:11:41.941
receive values within this range.
Ok, so

00:11:41.966 --> 00:11:44.970
just to clarify something
you don't need

00:11:44.970 --> 00:11:50.870
to write unsigned unsigned short you can
also just type like short

00:11:50.870 --> 00:11:54.616
and that would be
pretty much the same

00:11:54.641 --> 00:11:58.910
as me typing signed
short so these two

00:11:58.910 --> 00:12:03.660
types are pretty much
exactly the same meaning so no big deal

00:12:03.660 --> 00:12:06.526
there, I know, it
might seem a little

00:12:06.551 --> 00:12:09.100
boring but we need
to go over types of

00:12:09.200 --> 00:12:11.226
variables and
variables themselves

00:12:11.251 --> 00:12:13.324
before we can move
freely anywhere

00:12:14.529 --> 00:12:17.365
probably one of the
most important things

00:12:17.390 --> 00:12:20.140
in C++ when we get
into more complex up

00:12:20.140 --> 00:12:22.710
it's going to get a little bit more
interesting but for the time being I

00:12:22.710 --> 00:12:24.635
just have to go over
these basics if

00:12:24.660 --> 00:12:26.560
some of you have
a good amount of

00:12:26.560 --> 00:12:29.208
previous programming
experience, you might

00:12:29.233 --> 00:12:30.960
find this extremely
boring but down the

00:12:30.960 --> 00:12:32.742
road come the complex stuff.
I need to

00:12:32.767 --> 00:12:34.480
take into consideration
that a lot of

00:12:34.580 --> 00:12:38.500
people are complete beginners and I do
need to explain like everything from a

00:12:38.500 --> 00:12:41.756
to z. So that the course
would be adjusted

00:12:41.781 --> 00:12:44.870
for a broader audience
as we did leave

00:12:44.870 --> 00:12:46.918
as we are most likely
going to label

00:12:46.943 --> 00:12:48.870
this course as the
beginners one as from

00:12:48.870 --> 00:12:52.673
beginner to advanced pretty much.
Anyway,

00:12:52.698 --> 00:12:56.400
our next variable
type will be int, so

00:12:56.400 --> 00:13:00.549
you have int, it stands
for integers, again

00:13:00.574 --> 00:13:03.980
you have signed and
unsigned which you

00:13:03.980 --> 00:13:06.433
can place in front of
them, which is no big

00:13:06.458 --> 00:13:08.990
deal I've showed to
you a moment ago then

00:13:08.990 --> 00:13:11.365
again you have long,
now this is to

00:13:11.390 --> 00:13:14.350
represent bigger
numbers, we also have

00:13:14.350 --> 00:13:18.767
both signed and
unsigned and then you

00:13:18.792 --> 00:13:23.200
have a type long long
I don't know tests

00:13:23.300 --> 00:13:25.770
and that would be the declaration of the
long

00:13:25.770 --> 00:13:32.680
long long type of a variable type which
is this is a variable test which is of

00:13:32.680 --> 00:13:37.520
type long long let's put it like that.
This is to represent like really big

00:13:37.520 --> 00:13:40.393
numbers I mean really
really big numbers

00:13:40.418 --> 00:13:43.040
long is just to
represent big numbers

00:13:43.040 --> 00:13:46.049
and we're not going
to be using these

00:13:46.074 --> 00:13:48.709
that much really,
mostly we're gonna be

00:13:48.709 --> 00:13:54.120
using like int, bool, char, etc, double

00:13:55.580 --> 00:13:59.571
also float float
floating points so this

00:13:59.596 --> 00:14:03.960
means that this
represents real number

00:14:04.060 --> 00:14:07.671
the precision is pretty
much 6 decimals.

00:14:07.696 --> 00:14:10.780
So what is this? so
float if they're just

00:14:10.880 --> 00:14:18.360
float some and number equals two zero
point zero point I don't know, 4343 this would

00:14:20.960 --> 00:14:26.159
be a floating point
number, an integer on the

00:14:26.184 --> 00:14:31.600
other hand int I don't
know, int num would be

00:14:31.600 --> 00:14:36.020
equal like them, to see
the difference this

00:14:36.045 --> 00:14:40.080
one is a whole number
10 and float n the

00:14:40.080 --> 00:14:44.820
floating point is zero point something, I don't know It doesn't really matter so that just

00:14:44.820 --> 00:14:47.870
showing you pretty the
much difference then

00:14:47.895 --> 00:14:50.530
again you have double
now this presents

00:14:50.530 --> 00:14:54.998
again real numbers,
the precision of a

00:14:55.023 --> 00:14:58.740
double is around 13
to 15 decimals you

00:14:58.840 --> 00:15:02.293
also have like long
double same as for

00:15:02.318 --> 00:15:05.950
double but way bigger
precision, let's put

00:15:05.950 --> 00:15:08.226
it like that so double would be

00:15:08.251 --> 00:15:10.990
basically like it's
a double the equals

00:15:10.990 --> 00:15:16.320
this would be a double four-point 33
this would be a double this will be a

00:15:16.320 --> 00:15:19.587
value that would
be assigned to a

00:15:19.612 --> 00:15:22.940
variable of type double.
So you might now

00:15:22.940 --> 00:15:30.787
ask me if you have like
float which is like f and I

00:15:30.812 --> 00:15:38.324
don't know, this is like 0.54
and you have int i equals

00:15:39.220 --> 00:15:43.973
10, why on earth
would you ever use

00:15:43.998 --> 00:15:49.039
these two? why wouldn't
you just use a

00:15:49.139 --> 00:15:52.189
double? and for everything?

00:15:52.189 --> 00:15:54.625
Well, the differences
is in memory space,

00:15:54.650 --> 00:15:57.060
so some of these
require less memory

00:15:57.060 --> 00:16:04.140
space than others and especially if you
type in like unsigned int so if you

00:16:06.240 --> 00:16:08.835
know that the that
this integer I will

00:16:08.860 --> 00:16:11.430
never be assigned
a value that is

00:16:11.430 --> 00:16:15.075
negative, you can
declare it as unsigned

00:16:15.100 --> 00:16:18.889
int, and the smaller
your variable range

00:16:18.889 --> 00:16:25.439
something like that, you have the less memory will take, you can

00:16:25.439 --> 00:16:26.750
look it up on the net

00:16:26.750 --> 00:16:29.762
the order of types which type

00:16:29.787 --> 00:16:32.439
reserves how much memory because

00:16:32.439 --> 00:16:34.371
immediately when you
declare it, the

00:16:34.396 --> 00:16:36.209
computer will actually
reserve a portion

00:16:36.209 --> 00:16:40.560
of the memory for that particular
variable, this is a very

00:16:40.560 --> 00:16:45.000
good coding practice and this
is one of the advantages of C++ over

00:16:45.000 --> 00:16:48.339
some of the other
programming languages

00:16:48.364 --> 00:16:52.759
like for example
PHP or Python or

00:16:52.759 --> 00:16:55.514
something like that,
well maybe not python,

00:16:55.539 --> 00:16:58.160
but over PHP where you
don't really need to

00:16:58.160 --> 00:17:02.131
declare types of
variables, rather instead

00:17:02.156 --> 00:17:05.579
you just declare
variables, here you can

00:17:05.679 --> 00:17:08.138
actually declare types
of variables and

00:17:08.163 --> 00:17:10.319
in such a way save
up a lot of RAM

00:17:10.319 --> 00:17:14.028
which is a very good
coding practice.

00:17:14.053 --> 00:17:17.659
So let's go ahead
and practice these

00:17:17.659 --> 00:17:20.547
variables, a little bit
to clear of you and

00:17:20.572 --> 00:17:23.319
see what happens. Let's
go to a short coding

00:17:23.319 --> 00:17:29.360
exercise and see how this actually works
in real examples but I'm running a

00:17:29.360 --> 00:17:32.130
little bit short on time so we'll
continuing to follow tutorial.