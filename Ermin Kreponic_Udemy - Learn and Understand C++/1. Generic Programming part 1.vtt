WEBVTT

00:00:00.000 --> 00:00:05.629
Welcome back all, today I will introduce
you to the basic concept of generic

00:00:05.629 --> 00:00:12.269
programming now the term generic is
basically define is just a

00:00:12.269 --> 00:00:18.140
characteristic of some sort of a group
or class of things it is not specific so

00:00:18.140 --> 00:00:21.781
basically the opposite
of specific here

00:00:21.806 --> 00:00:25.180
we will go over generic
functions these

00:00:25.180 --> 00:00:26.773
functions have the
same body but can

00:00:26.798 --> 00:00:28.740
accept everything
as a parameter as

00:00:28.740 --> 00:00:32.090
opposed to the functions which we have
been using previously where you have

00:00:32.090 --> 00:00:38.480
specific parameters whose used types
are defined the functions can only

00:00:38.480 --> 00:00:41.882
accept parameters of
those types herr we

00:00:41.907 --> 00:00:45.690
will basically create
functions that can

00:00:45.690 --> 00:00:50.489
pretty much accept anything as a
parameter which is a very useful concept

00:00:50.489 --> 00:00:54.773
and generic programming
is basically based

00:00:54.798 --> 00:00:58.709
on deduction or type
based parameters based

00:00:58.809 --> 00:01:04.760
on the parameter type, compiler will
decide which function to call there are

00:01:04.760 --> 00:01:07.332
two types of deduction
you have partial

00:01:07.357 --> 00:01:09.300
and complete incomplete
deduction we

00:01:09.400 --> 00:01:12.840
know nothing about the parameters so
nothing is known about the parameters

00:01:12.840 --> 00:01:16.790
whereas in partial deduction there is
there is some additional information for

00:01:16.790 --> 00:01:20.310
example we know that the parameter is in
array, but that's pretty much all we

00:01:20.310 --> 00:01:24.271
know about. Anyway
let's go ahead and

00:01:24.296 --> 00:01:28.150
take a look at the
generic functions and

00:01:28.150 --> 00:01:33.869
type deduction. So that's
really what I wanted to go over with you

00:01:33.869 --> 00:01:40.760
in this set of tutorial or a tutorial
depending on how much time will I

00:01:40.760 --> 00:01:42.804
require to actually finish this.
So let's

00:01:42.829 --> 00:01:45.204
go ahead and create
a void function, let's call it print

00:01:50.070 --> 00:01:58.000
and we shall have int urr, ok so nothing new here really and int len so

00:01:59.000 --> 00:02:01.539
in place just a short
version of it,

00:02:01.564 --> 00:02:04.130
let's go ahead and
prototype it and go

00:02:04.130 --> 00:02:09.459
down below and actually create the body of the function

00:02:09.459 --> 00:02:14.880
let me just go ahead
and copy this, so as

00:02:14.905 --> 00:02:19.850
before nothing new,
nothing strange here

00:02:19.850 --> 00:02:23.912
we're just gonna go ahead
and create the body of

00:02:23.937 --> 00:02:28.130
the function std, just gonna
go ahead and create a

00:02:28.130 --> 00:02:36.100
print out here. Ok so there you go,

00:02:38.260 --> 00:02:41.581
and we're gonna need the for
loop because this is gonna

00:02:41.606 --> 00:02:45.030
be our beginning you're
gonna have an opening of a

00:02:45.030 --> 00:02:49.620
bracket and then we're going to have a
for loop which will print out all the

00:02:49.620 --> 00:02:53.629
elements probably except the last one

00:02:54.659 --> 00:02:57.302
we're gonna have some sort
of logic embedded and

00:02:57.327 --> 00:02:59.310
then at that idea and
we're going to close at

00:02:59.310 --> 00:03:06.040
all with another block like this one, so
here so here's what I am

00:03:06.040 --> 00:03:13.950
intending to do here and just gonna go
ahead and say int I =  0 and I is

00:03:23.600 --> 00:03:24.609
we're not going to get any

00:03:24.609 --> 00:03:32.540
curly brackets don't blow as we just
gonna have one single line and this will

00:03:33.440 --> 00:03:37.632
ensure that we
basically managed to

00:03:37.657 --> 00:03:41.310
print out all the
elements except for

00:03:41.310 --> 00:03:48.069
the last one as you can see its length
minus one, variable in minus one with

00:03:48.069 --> 00:03:52.023
len will be the size
of the array since

00:03:52.048 --> 00:03:55.349
we go up to len -1
which means one lesser

00:03:55.449 --> 00:04:03.400
than complete length of the array
we cannot access, we cannot

00:04:04.900 --> 00:04:08.967
basically access the
last element and

00:04:08.992 --> 00:04:12.680
this happens when an
array is we can't

00:04:12.680 --> 00:04:16.459
access the element
which is len -1 so we

00:04:16.484 --> 00:04:20.479
can't access the minus
first element so

00:04:20.479 --> 00:04:22.420
to say I'm doing a very stupid

00:04:22.445 --> 00:04:24.740
explanation of that
let me just go ahead

00:04:24.740 --> 00:04:28.929
and show you like
through the code it's

00:04:28.954 --> 00:04:33.260
kind of cool to put
it in words as fairly

00:04:33.260 --> 00:04:36.260
strange things so to say

00:04:37.270 --> 00:04:39.828
let me just go ahead and
write it out and then

00:04:39.853 --> 00:04:42.260
I'll explain a while
you're actually looking

00:04:42.260 --> 00:04:43.882
at the code I do
believe that it's

00:04:43.907 --> 00:04:45.404
going to make way
more sense that way

00:05:03.350 --> 00:05:06.174
ok so this is gonna
print onto the closing

00:05:06.199 --> 00:05:09.370
bracket outside the
for loop outside of

00:05:09.370 --> 00:05:12.855
the if so look we
have opening bracket

00:05:12.880 --> 00:05:16.050
opening block print
out all the elements

00:05:16.050 --> 00:05:21.150
of the array so it prints out one
element and there is a coma space

00:05:21.150 --> 00:05:24.840
coma space coma space and so on and so forth

00:05:24.840 --> 00:05:27.900
it goes until it actually

00:05:34.000 --> 00:05:38.687
until I becomes equal
or greater than

00:05:38.712 --> 00:05:43.480
len-1 and then down
below you have

00:05:43.480 --> 00:05:46.943
a len not equal to
0 so if the len

00:05:46.968 --> 00:05:50.170
is not equal to 0 if we haven't

00:05:50.170 --> 00:05:53.388
initialized an array
whose size is 0 so

00:05:53.413 --> 00:05:56.990
if the length of the
array is not equal

00:05:56.990 --> 00:06:04.040
to 0 then please create a print out
after the for loop

00:06:04.040 --> 00:06:05.250
which will go like this

00:06:05.250 --> 00:06:10.466
arr len -1 so it will
basically create the print

00:06:10.491 --> 00:06:15.280
out of this element
here, let me just put

00:06:15.280 --> 00:06:20.090
it like this, so it will create a print out
of this element here

00:06:21.360 --> 00:06:23.680
off the array hopefully
it makes more

00:06:23.705 --> 00:06:26.000
sense now with the
if statement of what

00:06:26.000 --> 00:06:30.580
I was saying about a moment ago and I
was doing it really clumsy fashion so

00:06:30.580 --> 00:06:38.040
this one here will not print out len-1
element of the array but this one down

00:06:38.040 --> 00:06:41.014
below, will print out
element with this

00:06:41.039 --> 00:06:43.790
index so element would
this index will

00:06:43.790 --> 00:06:47.600
not be printed out in the for loop but
it will be printed out here

00:06:49.070 --> 00:06:52.600
ok so now that we have
that done this is

00:06:52.625 --> 00:06:56.050
the regular function,
let's just run it,

00:06:56.050 --> 00:07:03.010
well we haven't actually
called function or initialized or pass

00:07:03.010 --> 00:07:06.680
the parameter or anything like that but it
doesn't matter,

00:07:06.680 --> 00:07:12.169
just want to verify that the program
actually compiles without any problems

00:07:12.870 --> 00:07:14.500
now in the main

00:07:14.500 --> 00:07:18.202
we can do the
following, it shouldn't

00:07:18.227 --> 00:07:21.560
be that hard, we can have some

00:07:21.560 --> 00:07:24.560
sort of an array I don't know int arr

00:07:33.810 --> 00:07:41.790
2,3,4,-5,1,1,0,4 you
don't need to type in

00:07:43.315 --> 00:07:51.240
the same values as I
have it's really not

00:07:51.840 --> 00:07:58.350
that important and down below we're gonna
have a const, int, len, because it

00:07:58.350 --> 00:08:01.830
does need to be a const
and look at what

00:08:01.855 --> 00:08:05.310
I'm about to do here,
I'm about to type in sizeof arr

00:08:10.740 --> 00:08:18.663
divided by size of arr
so 0, yeah, there you

00:08:18.788 --> 00:08:26.070
go, 4 so sizeof is an
operator which returns

00:08:26.070 --> 00:08:29.331
the size of an object
in bytes, that is

00:08:29.356 --> 00:08:32.740
why we divided by the
size of a in int,

00:08:32.740 --> 00:08:40.709
and down below we're type in print(arr, len)

00:08:43.969 --> 00:08:46.915
we're just passing the
parameters now ok,

00:08:46.940 --> 00:08:49.800
no big deal, ops I
seem to have made an

00:08:49.800 --> 00:08:54.599
error here, sorry. So
we will initialize the

00:08:54.624 --> 00:08:59.310
size of length so it'll
be length of the

00:08:59.310 --> 00:09:07.300
array, with the result of these
two here so you have size off in terms

00:09:07.400 --> 00:09:12.120
of bytes of the first element of the
array and you have the size of the

00:09:12.120 --> 00:09:14.472
entirety of the array so think

00:09:14.497 --> 00:09:16.710
about what's gonna
get printed out

00:09:16.710 --> 00:09:20.000
onto the screen

00:09:28.839 --> 00:09:35.000
Ok it's confusing me, seems to be a problem here

00:09:35.260 --> 00:09:38.310
to there's a block here

00:09:39.190 --> 00:09:47.125
equal. Ok and let's go
ahead and run it now.

00:09:53.050 --> 00:10:00.190
down there you go,
234-51104 you see they

00:10:00.190 --> 00:10:02.402
all got printed out
without any sort of

00:10:02.427 --> 00:10:04.950
problems and you even
have a new line at

00:10:04.950 --> 00:10:09.839
the bottom now let's go ahead and
discuss despite a little bit more go

00:10:09.839 --> 00:10:12.780
let's go ahead and type
in cout, I do believe

00:10:12.805 --> 00:10:15.530
that by just printing
out of the values

00:10:15.530 --> 00:10:22.190
of these of the size in

00:10:22.190 --> 00:10:30.130
terms of bytes, will basically just be self
explanatory cout, sizeof arr

00:10:40.930 --> 00:10:44.010
sizeof arr 0

00:10:50.550 --> 00:10:58.313
Ok that should be it,
maybe I should do this

00:10:58.338 --> 00:11:06.330
as well. Ok let's run
this, so it's 32 and 4

00:11:06.630 --> 00:11:14.628
what is 32 and 4?
Let's count, 12345678

00:11:17.053 --> 00:11:24.960
what is 8 times 4? Well
8 times 4 is 32 why

00:11:25.660 --> 00:11:29.702
am I saying 8 times 4? Well, you

00:11:29.727 --> 00:11:33.019
have 4 here and 4 is basically

00:11:33.019 --> 00:11:37.350
the size of the first element what is
the first element of the array? its number

00:11:37.350 --> 00:11:39.740
2, what is number 2?
number 2 is an

00:11:39.765 --> 00:11:42.180
integer the size of
an integer in terms

00:11:42.180 --> 00:11:45.609
of bytes is 4,so 4 bytes.
So we basically

00:11:45.634 --> 00:11:49.350
said ok take the first element

00:11:49.350 --> 00:11:55.000
give us the size in terms of
bytes which is 4 and then combined

00:11:55.000 --> 00:11:59.709
the bytes of all the elements and then
divided by 4 to get the number of

00:11:59.709 --> 00:12:02.950
elements within the array so let's go
over that again.

00:12:04.050 --> 00:12:07.503
Integer has the size has
the size of 4 bytes

00:12:07.528 --> 00:12:10.760
in your ram, so you
have bytes, megabytes,

00:12:10.760 --> 00:12:18.329
gigabytes, etc. Well, integer is only
4 bytes in terms of size, number 2 is

00:12:18.329 --> 00:12:24.190
an integer which is the first element of
the array and we have stated okay go

00:12:24.190 --> 00:12:26.319
ahead and take the
first element of the

00:12:26.344 --> 00:12:28.600
array give us its size
in terms of bytes

00:12:28.600 --> 00:12:32.143
that would be 4, and
then give us the

00:12:32.168 --> 00:12:35.940
size of all the
elements combined in

00:12:35.940 --> 00:12:43.040
terms of bytes, which is 32. Ok now divided
by 4 and give us the amount of

00:12:43.040 --> 00:12:46.510
elements give us the number of elements
don't give us the size of the elements

00:12:46.510 --> 00:12:51.120
combined give us the number of elements
that the array contains, so

00:12:51.120 --> 00:12:53.737
that we would get
the length of the

00:12:53.762 --> 00:12:56.240
array hopefully that is clear.
So, 4 is

00:12:56.240 --> 00:12:59.260
the size of a single element in terms of
bytes

00:13:00.579 --> 00:13:05.110
and once you combine all the sizes in
terms of bytes and divide that by 4

00:13:05.110 --> 00:13:10.011
you get the number of elements.
Hopefully

00:13:10.036 --> 00:13:14.519
that explanation was
actually useful. So,

00:13:14.519 --> 00:13:19.499
this function that we have just created
the function print is a regular not a

00:13:19.499 --> 00:13:23.959
generic function which prints out an
array of numbers that is integers,

00:13:23.959 --> 00:13:31.879
the problem is that the function only print out
an array of integers and nothing else so

00:13:32.779 --> 00:13:36.098
if we had an array
of for example real

00:13:36.123 --> 00:13:39.350
numbers that is double,
so this was for

00:13:39.350 --> 00:13:45.939
example, not int but we would have
we would have problems,

00:13:45.939 --> 00:13:50.149
the function will not print out
these numbers, the solution to this

00:13:50.149 --> 00:13:58.089
problem is to write a function that has
the same body but also accept but

00:13:58.189 --> 00:14:05.079
also accepts an array of type double so  we could go about

00:14:05.079 --> 00:14:09.233
doing that, in fact we
will, let me just type

00:14:09.258 --> 00:14:13.079
int here there's a
considerable amount of prep

00:14:13.079 --> 00:14:15.194
work before we get
into the before we

00:14:15.219 --> 00:14:17.309
get into what we
want to get into in

00:14:17.309 --> 00:14:21.119
this particular tutorial in terms of
generic programming because you do need to

00:14:21.119 --> 00:14:24.211
do some preps, if we
basically just do this,

00:14:24.236 --> 00:14:27.049
void we will create
a function overload here

00:14:29.319 --> 00:14:36.259
print and this will be double arr

00:14:40.000 --> 00:14:42.866
it's gonna be int len
again, so this will

00:14:42.891 --> 00:14:45.610
be an overloaded these
two functions are

00:14:45.610 --> 00:14:48.752
considered to be overloaded why?
They

00:14:48.777 --> 00:14:52.200
have the same name,
they have the same

00:14:52.200 --> 00:14:58.000
declaration but they take different
parameters

00:15:15.810 --> 00:15:20.560
Anyway, what we have done here is
overloaded function created an

00:15:20.560 --> 00:15:25.170
overloading function so do you know what
is the difference between these two

00:15:25.170 --> 00:15:28.920
functions? they have the same name, they
have the same declaration, the same

00:15:28.920 --> 00:15:31.412
prototype everything's
the same except

00:15:31.437 --> 00:15:33.790
for the arguments
that they take, so if

00:15:33.790 --> 00:15:37.590
you have two functions of the same name
and doesn't want it to be void they can

00:15:37.590 --> 00:15:40.387
also have a return type but take

00:15:40.412 --> 00:15:42.820
different parameters
that means that you

00:15:42.820 --> 00:15:47.800
are overloading functions, so how would a program differentiate

00:15:47.800 --> 00:15:49.649
how would the machine
differentiate if you

00:15:49.674 --> 00:15:51.420
call a function with
print they both have

00:15:51.420 --> 00:15:52.850
the same name?

00:15:52.850 --> 00:15:54.656
Well it would
differentiate in terms of

00:15:54.681 --> 00:15:56.630
the arguments passed
so if you passed the

00:15:56.630 --> 00:16:02.060
double array an array of doubles, it will
take this function into consideration, if

00:16:02.060 --> 00:16:04.765
you pass an array of
integers, it will

00:16:04.790 --> 00:16:07.740
take this function
into consideration. So

00:16:07.740 --> 00:16:10.115
let's go ahead and
create the body for

00:16:10.140 --> 00:16:12.490
this function and see
how that actually

00:16:12.490 --> 00:16:13.530
works in practice.