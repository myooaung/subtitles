WEBVTT

1
00:00:00.046 --> 00:00:02.235
Okay so, now

2
00:00:02.371 --> 00:00:04.186
let's go ahead and talk
about operators.

3
00:00:04.321 --> 00:00:08.215
C++ has several types
of operators, but in this chapter

4
00:00:08.566 --> 00:00:11.905
I wanted to focus on the
logical operators

5
00:00:12.041 --> 00:00:15.415
and after that we'll go
into relational ones.

6
00:00:17.356 --> 00:00:20.945
You have arethmetic operators
like addition,

7
00:00:21.081 --> 00:00:22.031
multiplication

8
00:00:22.196 --> 00:00:23.295
and division.

9
00:00:23.430 --> 00:00:24.565
We already know them.

10
00:00:25.401 --> 00:00:26.266
And they have

11
00:00:26.401 --> 00:00:27.885
pretty much the same
meaning.

12
00:00:28.561 --> 00:00:30.466
Well, perhaps not the presidence

13
00:00:30.601 --> 00:00:34.090
but they are very similar in terms of

14
00:00:34.356 --> 00:00:35.505
what they

15
00:00:35.641 --> 00:00:38.066
do as supposed to the logical
operators

16
00:00:38.201 --> 00:00:40.050
that I wanted to show you now.

17
00:00:41.771 --> 00:00:43.090
Arethmetic operators, right.

18
00:00:43.396 --> 00:00:44.070
I have

19
00:00:44.605 --> 00:00:45.531
+

20
00:00:45.671 --> 00:00:46.815
*

21
00:00:46.950 --> 00:00:47.946
/ etc.

22
00:00:48.081 --> 00:00:50.226
Those you know and those
you are familiar with.

23
00:00:50.361 --> 00:00:51.405
So there's no need to like

24
00:00:51.641 --> 00:00:53.640
go all over them again.

25
00:00:53.776 --> 00:00:55.336
Obviously division and multiplication

26
00:00:55.471 --> 00:00:58.065
have presidence over addition

27
00:00:58.201 --> 00:00:59.765
and subtraction.

28
00:01:00.486 --> 00:01:02.526
Pretty much the same things that
apply in Math,

29
00:01:02.831 --> 00:01:04.570
apply here as well.

30
00:01:04.736 --> 00:01:05.661
So, same ruling.

31
00:01:07.706 --> 00:01:10.075
Anyway, let's go ahead and
create our main.

32
00:01:12.606 --> 00:01:13.486
And

33
00:01:13.976 --> 00:01:15.120
we're going to put

34
00:01:15.256 --> 00:01:16.995
a boolian variable here.

35
00:01:17.436 --> 00:01:19.990
bool and we're just going to
name this one - A.

36
00:01:20.271 --> 00:01:22.805
And we shall state that A is true.

37
00:01:22.940 --> 00:01:24.060
We will,

38
00:01:24.195 --> 00:01:24.911
keep in mind,

39
00:01:25.121 --> 00:01:28.210
that regardless, that this
is not number or a

40
00:01:28.371 --> 00:01:30.690
string or something like that,
this is a key word.

41
00:01:31.111 --> 00:01:32.295
And it says true.

42
00:01:32.530 --> 00:01:34.461
It can also be,
instead of true,

43
00:01:34.596 --> 00:01:35.476
I can also write

44
00:01:36.455 --> 00:01:37.171
false.

45
00:01:38.010 --> 00:01:38.586
Instead of

46
00:01:39.310 --> 00:01:40.615
false, I can write 0.

47
00:01:40.750 --> 00:01:42.535
And instead of true,
I can write 1.

48
00:01:42.861 --> 00:01:45.066
Everything that is zero
is evaluated as false.

49
00:01:45.201 --> 00:01:46.340
Everything that is

50
00:01:46.761 --> 00:01:50.245
basically greater than zero
is evaluated as true.

51
00:01:51.266 --> 00:01:54.405
So, but you can also use true.

52
00:01:54.541 --> 00:01:57.226
For example in Java,
you cannot use 0 and 1.

53
00:01:57.361 --> 00:01:59.320
You need to use true and false

54
00:01:59.536 --> 00:02:00.531
or so it was.

55
00:02:00.881 --> 00:02:03.758
I haven't used Java in a while
so don't hold my word.

56
00:02:04.271 --> 00:02:05.245
Don't hold my word for that.

57
00:02:05.641 --> 00:02:07.403
You can go ahead and check it
for yourselves if you want.

58
00:02:08.471 --> 00:02:09.175
Anyway, I have stated

59
00:02:09.310 --> 00:02:12.820
that the boolian variable,
that the variable A of type

60
00:02:12.955 --> 00:02:14.160
boolian

61
00:02:14.626 --> 00:02:17.140
is initialized to true.

62
00:02:17.276 --> 00:02:19.385
Because boolian variables
can only have two values.

63
00:02:19.521 --> 00:02:21.775
They can either be true
or they can be false.

64
00:02:22.080 --> 00:02:23.471
There is no third option.

65
00:02:25.471 --> 00:02:27.675
And let's also initialize B.

66
00:02:27.976 --> 00:02:29.530
But we can basically go,

67
00:02:31.321 --> 00:02:32.178
go like this.

68
00:02:34.016 --> 00:02:34.941
B

69
00:02:35.336 --> 00:02:39.075
= and we shall also state
that B is true.

70
00:02:43.721 --> 00:02:44.280
Oops sorry.

71
00:02:44.951 --> 00:02:45.831
Need a comma here.

72
00:02:47.691 --> 00:02:48.871
A B C

73
00:02:49.711 --> 00:02:52.078
And we shall state that the C is

74
00:02:52.451 --> 00:02:52.920
false.

75
00:02:53.056 --> 00:02:55.096
I don't have anything against C but

76
00:02:55.376 --> 00:02:57.890
we shall state C is false.
And one more,

77
00:02:58.025 --> 00:02:58.516
we'll just

78
00:02:58.651 --> 00:02:59.880
name D.

79
00:03:00.111 --> 00:03:01.488
A B C D
I'm just

80
00:03:01.621 --> 00:03:02.695
putting them

81
00:03:02.830 --> 00:03:04.661
in an alphabetical order.
No big deal.

82
00:03:05.081 --> 00:03:07.330
I don't need any particular names
for these variables.

83
00:03:08.981 --> 00:03:11.650
I just need to name them.
That's pretty much it.

84
00:03:12.441 --> 00:03:14.886
So we have declared and initialized

85
00:03:15.021 --> 00:03:20.056
4 boolian variables. 3 of those
are true and one of those is false.

86
00:03:20.571 --> 00:03:21.751
Now we shall go ahead and

87
00:03:21.941 --> 00:03:24.626
we will need to use them in order
to demonstrate

88
00:03:24.761 --> 00:03:27.810
the functionality of
logical operators.

89
00:03:28.071 --> 00:03:31.851
Logical and operator is represented
with two

90
00:03:32.061 --> 00:03:33.475
ampersand signs.

91
00:03:36.916 --> 00:03:39.910
Like this, so if you have another

92
00:03:41.011 --> 00:03:41.926
bool

93
00:03:43.210 --> 00:03:45.530
and we can name this one

94
00:03:46.206 --> 00:03:48.260
and1.

95
00:03:48.896 --> 00:03:51.266
We have not broken the
naming convention

96
00:03:51.401 --> 00:03:54.350
with this. I already explained
how you can name the variables.

97
00:03:54.656 --> 00:03:57.625
So you can use numbers
in naming your variables.

98
00:03:58.206 --> 00:03:59.345
We shall say - A

99
00:04:00.995 --> 00:04:02.571
&amp;&amp;

100
00:04:03.226 --> 00:04:05.185
B;

101
00:04:05.321 --> 00:04:07.035
So A

102
00:04:07.171 --> 00:04:08.846
is true, right?

103
00:04:08.981 --> 00:04:10.256
A = true.

104
00:04:10.861 --> 00:04:12.160
And B

105
00:04:12.535 --> 00:04:13.461
= true.

106
00:04:13.881 --> 00:04:17.505
So what do you think that the
value of this variable will be?

107
00:04:17.641 --> 00:04:19.426
What do you think that the
value of this boolian will be?

108
00:04:19.561 --> 00:04:21.170
Will it be true or false?

109
00:04:21.636 --> 00:04:22.980
Well, if this one is true,

110
00:04:23.656 --> 00:04:24.211
and

111
00:04:25.071 --> 00:04:26.301
this one is true,

112
00:04:26.606 --> 00:04:27.346
then,

113
00:04:27.766 --> 00:04:32.581
then the expression is evaluated
as true.

114
00:04:37.356 --> 00:04:38.910
Let's take a look at another one.

115
00:04:41.441 --> 00:04:43.256
So in order,
just one more time.

116
00:04:43.391 --> 00:04:45.180
In order for this expression
to be true,

117
00:04:45.716 --> 00:04:46.666
both A

118
00:04:46.971 --> 00:04:47.740
and B

119
00:04:47.876 --> 00:04:48.710
need to be true.

120
00:04:49.266 --> 00:04:51.495
If A or B are false,

121
00:04:51.706 --> 00:04:54.815
then this entire expression will
be evaluated

122
00:04:54.980 --> 00:04:55.951
as false.

123
00:04:57.116 --> 00:04:59.228
So we shall name this one
and2.

124
00:05:00.481 --> 00:05:01.340
=

125
00:05:02.550 --> 00:05:03.196
A

126
00:05:05.821 --> 00:05:08.040
&amp;&amp; B

127
00:05:09.886 --> 00:05:10.510
Oops.

128
00:05:10.955 --> 00:05:11.626
&amp;&amp;

129
00:05:14.276 --> 00:05:16.401
C

130
00:05:16.921 --> 00:05:19.345
&amp;&amp; D

131
00:05:20.591 --> 00:05:22.725
Now I want you to take
a look at this expression.

132
00:05:22.936 --> 00:05:25.230
And I would like you to

133
00:05:26.116 --> 00:05:28.560
tell yourselves, well you obviously
can't tell me.

134
00:05:28.696 --> 00:05:30.735
I am quite some distance away

135
00:05:31.041 --> 00:05:32.710
or maybe not, I don't know
where you are.

136
00:05:33.081 --> 00:05:35.186
But I want you to figure out
what is the value

137
00:05:35.321 --> 00:05:37.350
of bool and2.

138
00:05:37.726 --> 00:05:38.660
Is it true

139
00:05:38.796 --> 00:05:39.976
or is it false?

140
00:05:40.326 --> 00:05:42.585
So it doesn't matter that we
have multiple,

141
00:05:42.721 --> 00:05:45.780
multiple variables in the line
are lined up here and

142
00:05:46.181 --> 00:05:49.225
this is longer than this.
Completely irrelevant.

143
00:05:49.360 --> 00:05:50.960
Same rules apply.

144
00:05:51.256 --> 00:05:55.555
All of these variables need to
evaluate as true

145
00:05:55.701 --> 00:06:00.500
in order for this boolian to
be true as well.

146
00:06:01.110 --> 00:06:02.081
Is that the case?

147
00:06:02.316 --> 00:06:03.180
No, it is not.

148
00:06:03.315 --> 00:06:04.596
C is false.

149
00:06:04.731 --> 00:06:06.106
So C = false.

150
00:06:06.241 --> 00:06:07.701
Henceforth, this entire

151
00:06:08.005 --> 00:06:09.983
line will be evaluated as

152
00:06:10.116 --> 00:06:11.370
false and

153
00:06:11.511 --> 00:06:13.736
and2 will have the value of

154
00:06:14.090 --> 00:06:14.711
false.

155
00:06:17.851 --> 00:06:19.573
But there is something else that
you should

156
00:06:19.706 --> 00:06:20.355
keep in mind.

157
00:06:22.981 --> 00:06:24.960
A &amp;&amp; B

158
00:06:25.095 --> 00:06:26.416
is evaluated first.

159
00:06:27.531 --> 00:06:28.831
Okay, that's fine.

160
00:06:30.991 --> 00:06:31.595
B

161
00:06:31.781 --> 00:06:33.273
&amp;&amp; C

162
00:06:33.406 --> 00:06:34.590
is evaluated second.

163
00:06:36.426 --> 00:06:38.235
And this is going to
evaluated as false.

164
00:06:38.956 --> 00:06:40.580
Once this evaluates as false,

165
00:06:41.671 --> 00:06:44.180
the evaluation will not continue
pass this.

166
00:06:44.391 --> 00:06:44.881
So,

167
00:06:45.016 --> 00:06:47.430
D will not even be taken into
consideration,

168
00:06:47.801 --> 00:06:49.431
which is a considerable amount
of time,

169
00:06:49.566 --> 00:06:50.495
which is very nice

170
00:06:51.356 --> 00:06:53.350
and processing time that is.

171
00:06:54.141 --> 00:06:55.485
So it will come to here

172
00:06:55.886 --> 00:06:59.945
and then there is no longer any point
or reason to move on

173
00:07:00.226 --> 00:07:02.963
as there is nothing that will
actually change this.

174
00:07:03.266 --> 00:07:04.500
This will,

175
00:07:04.636 --> 00:07:07.210
this entire expression with
or without D

176
00:07:07.656 --> 00:07:10.030
with ampersands will be evaluated

177
00:07:10.166 --> 00:07:11.815
to false as one of the,

178
00:07:11.951 --> 00:07:13.265
one of the segments is false.

179
00:07:13.401 --> 00:07:16.615
Therefore, the entire line will be
evaluated as false.

180
00:07:16.990 --> 00:07:17.591
And

181
00:07:17.731 --> 00:07:20.190
this variable will be given a value of

182
00:07:20.335 --> 00:07:20.890
false.

183
00:07:22.610 --> 00:07:24.210
Okay, that is done.

184
00:07:25.651 --> 00:07:28.945
I know I doted that it
didn't can seem

185
00:07:29.086 --> 00:07:32.590
a little bit boring or something like
that. I'm really sorry for that.

186
00:07:32.896 --> 00:07:35.345
Nothing I can do about it.
I need to teach you these things.

187
00:07:35.481 --> 00:07:37.535
If you do not understand these
basic things,

188
00:07:37.771 --> 00:07:40.905
you will definitely not be able
to understand some of the,

189
00:07:41.071 --> 00:07:45.305
more than concepts that we move into
as we make our progression

190
00:07:45.441 --> 00:07:48.305
through C++. Because these our the
basic. These are the foundations,

191
00:07:48.441 --> 00:07:50.701
without these, it's very difficult
to move on.

192
00:07:50.845 --> 00:07:52.001
Because you're going to see

193
00:07:52.771 --> 00:07:57.275
a billion expressions containing
boolians and logical operators

194
00:07:57.556 --> 00:08:00.130
and you will see them
branching on and

195
00:08:00.991 --> 00:08:03.465
etc. and you need to be able to
basically...

196
00:08:03.601 --> 00:08:05.506
When you see it, you need
to be able to

197
00:08:05.641 --> 00:08:07.625
read it and know immediately
what it is,

198
00:08:07.761 --> 00:08:10.275
what it represents for,
what it represents, what it does.

199
00:08:11.371 --> 00:08:12.065
So, let's move on.

200
00:08:12.831 --> 00:08:15.626
Next up, we have the logical
or operators.

201
00:08:15.761 --> 00:08:20.195
So, and, or and not.
They are basically

202
00:08:20.331 --> 00:08:21.860
the three basic one,

203
00:08:23.931 --> 00:08:27.205
the logical operators.
So you have, and, or, not.

204
00:08:29.156 --> 00:08:31.465
There are some other ones
but we're not get into them

205
00:08:31.601 --> 00:08:34.635
now. For the time being, I just
want you to learn these three -

206
00:08:36.101 --> 00:08:38.880
and, or, not.
So next up is or.

207
00:08:39.141 --> 00:08:39.928
You can have

208
00:08:40.626 --> 00:08:41.485
bool

209
00:08:42.321 --> 00:08:43.110
or1

210
00:08:43.461 --> 00:08:46.800
= So I just want to demonstrate
how these things works, so you can see

211
00:08:47.176 --> 00:08:49.000
C ||

212
00:08:49.146 --> 00:08:50.215
represents or.

213
00:08:50.401 --> 00:08:52.256
So || represents or.

214
00:08:53.096 --> 00:08:55.716
D;

215
00:08:56.971 --> 00:08:57.690
bool

216
00:09:00.641 --> 00:09:01.080
or2

217
00:09:05.240 --> 00:09:05.746
A

218
00:09:08.906 --> 00:09:09.530
||

219
00:09:10.926 --> 00:09:13.020
D || B

220
00:09:14.066 --> 00:09:17.425
So, this is evaluated from left.

221
00:09:18.220 --> 00:09:18.796
So from left

222
00:09:19.520 --> 00:09:20.121
to the right.

223
00:09:20.516 --> 00:09:22.395
That is the order in which
it goes.

224
00:09:23.235 --> 00:09:24.586
For or,

225
00:09:24.721 --> 00:09:26.165
only one

226
00:09:26.301 --> 00:09:28.115
of the conditions,
only one of these

227
00:09:28.250 --> 00:09:29.686
variable or

228
00:09:30.851 --> 00:09:32.405
expressions that can be
placed

229
00:09:33.011 --> 00:09:34.848
needs to be true. So,
if C

230
00:09:34.981 --> 00:09:38.625
or D is true, it is completely
irrelevant what the other one is.

231
00:09:38.931 --> 00:09:42.016
This entire thing will be evaluated
as true.

232
00:09:44.040 --> 00:09:44.966
And

233
00:09:45.361 --> 00:09:48.826
likewise, it stands here - if only
one of these is true,

234
00:09:48.961 --> 00:09:52.320
the entire expression will be
evaluated as true.

235
00:09:54.486 --> 00:09:57.231
So that's basically the
logic of or.

236
00:09:57.366 --> 00:09:58.161
So you can have

237
00:09:58.296 --> 00:10:00.778
A or B or D or C

238
00:10:01.546 --> 00:10:03.826
and so on and so forth.
If only one of them is true,

239
00:10:03.961 --> 00:10:06.350
it will, the...

240
00:10:07.466 --> 00:10:09.748
They will result in a true value.

241
00:10:09.881 --> 00:10:10.460
So to say.

242
00:10:10.716 --> 00:10:13.995
Also, once it's checks

243
00:10:14.131 --> 00:10:14.971
C

244
00:10:15.106 --> 00:10:17.125
here it will check D as well.

245
00:10:17.496 --> 00:10:19.906
Once it's checks A here,
it will not check anything else.

246
00:10:21.401 --> 00:10:23.266
There was really no need to
evaluate the others.

247
00:10:23.401 --> 00:10:24.855
Because if only one is true,

248
00:10:24.996 --> 00:10:26.016
it's going to be true.

249
00:10:26.555 --> 00:10:27.156
If

250
00:10:28.131 --> 00:10:29.026
the first one here is false,

251
00:10:29.161 --> 00:10:31.065
okay, there was a possibility
that it's false,

252
00:10:31.201 --> 00:10:32.745
because D could be
false as well.

253
00:10:32.881 --> 00:10:34.545
So it's going to need to check
to D as well.

254
00:10:34.681 --> 00:10:36.955
But since A is true, there's
no need to check

255
00:10:37.281 --> 00:10:38.138
the rest at all.

256
00:10:40.765 --> 00:10:42.526
Okay so now,

257
00:10:42.666 --> 00:10:44.895
before we go into not,

258
00:10:45.710 --> 00:10:47.618
let's go ahead and take a
look at

259
00:10:47.751 --> 00:10:48.841
and one more time.

260
00:10:49.191 --> 00:10:52.053
And has a higher presidence
than or.

261
00:10:52.186 --> 00:10:52.843
So,

262
00:10:52.976 --> 00:10:54.320
it is,

263
00:10:54.486 --> 00:10:55.460
how shall I put this?

264
00:10:56.066 --> 00:10:57.741
It is ahead in the line

265
00:10:57.876 --> 00:10:59.013
as oppose to or.

266
00:10:59.411 --> 00:11:01.031
It's more important than or,

267
00:11:02.566 --> 00:11:04.386
to put in a more simpler terms.

268
00:11:04.521 --> 00:11:07.415
Let's create our boolian variable and.

269
00:11:09.206 --> 00:11:09.810
Ooops.

270
00:11:10.181 --> 00:11:11.131
_

271
00:11:11.436 --> 00:11:12.430
or1

272
00:11:12.876 --> 00:11:14.453
It shall be equal to A.

273
00:11:14.711 --> 00:11:15.986
&amp;&amp;

274
00:11:16.521 --> 00:11:17.261
B

275
00:11:17.961 --> 00:11:18.848
And we shall have

276
00:11:18.981 --> 00:11:19.930
this C.

277
00:11:21.211 --> 00:11:24.146
Of course you can configure
the priority as you choose

278
00:11:24.281 --> 00:11:26.595
and please with parenthesis.

279
00:11:27.086 --> 00:11:29.105
And you can put into
parenthesis whatever you want

280
00:11:29.316 --> 00:11:31.265
to be evaluated first.

281
00:11:32.521 --> 00:11:36.141
Same rules apply with
arethmetic operators like,

282
00:11:37.420 --> 00:11:38.321
if you have,

283
00:11:38.741 --> 00:11:39.436
3

284
00:11:39.626 --> 00:11:41.830
+ I don't know 2

285
00:11:42.806 --> 00:11:43.693
*

286
00:11:43.826 --> 00:11:45.545
3

287
00:11:46.056 --> 00:11:46.620
*

288
00:11:46.755 --> 00:11:47.310
5

289
00:11:49.841 --> 00:11:50.931
2 * 5

290
00:11:51.281 --> 00:11:53.426
will happen first and then
onto that

291
00:11:53.561 --> 00:11:56.270
3 will be added. So the
result will be 13.

292
00:11:56.716 --> 00:11:59.245
But you can basically do this,

293
00:12:00.315 --> 00:12:00.985
you can

294
00:12:02.681 --> 00:12:03.725
put this

295
00:12:04.376 --> 00:12:05.116
in a parenthesis.

296
00:12:05.586 --> 00:12:07.000
And you can say now,

297
00:12:07.136 --> 00:12:10.626
okay, regardless of the presidence
of this operator,

298
00:12:10.761 --> 00:12:11.926
I would like you to add

299
00:12:12.061 --> 00:12:13.476
3 +2 first,

300
00:12:13.875 --> 00:12:16.896
which is 5.

301
00:12:17.031 --> 00:12:18.615
And then multiply it by 5,

302
00:12:18.751 --> 00:12:20.355
which will mean that result is

303
00:12:20.491 --> 00:12:21.280
25.

304
00:12:22.211 --> 00:12:23.985
So you can do pretty much
the same things here.

305
00:12:24.121 --> 00:12:26.920
You can configure the
presidence of,

306
00:12:28.991 --> 00:12:31.540
of the entire line. So, which
segment of the line?

307
00:12:31.706 --> 00:12:35.165
Which operations would you like to
be done first with the parenthesis?

308
00:12:37.091 --> 00:12:37.625
However,

309
00:12:38.486 --> 00:12:40.706
placing it like this,
in a clean line,

310
00:12:40.841 --> 00:12:42.600
without manually configure,

311
00:12:42.736 --> 00:12:43.706
without manually configuring

312
00:12:43.841 --> 00:12:45.705
what you would like to be
executed first.

313
00:12:47.636 --> 00:12:52.795
This is basically going to
evaluate the ampersand first and then

314
00:12:52.930 --> 00:12:55.016
the or part will happen.

315
00:12:56.131 --> 00:12:56.990
Now,

316
00:12:59.336 --> 00:12:59.891
A

317
00:13:00.035 --> 00:13:01.541
&amp;&amp; B

318
00:13:01.776 --> 00:13:02.888
will be evaluated

319
00:13:04.701 --> 00:13:05.490
and

320
00:13:05.840 --> 00:13:07.510
it will,
the result

321
00:13:07.650 --> 00:13:09.411
of A &amp;&amp; B

322
00:13:09.761 --> 00:13:11.138
will be stated or

323
00:13:11.271 --> 00:13:11.780
C

324
00:13:12.016 --> 00:13:12.595
So,

325
00:13:13.015 --> 00:13:13.871
let's put it like this.

326
00:13:17.496 --> 00:13:19.188
A &amp;&amp; B

327
00:13:19.726 --> 00:13:21.586
So A is true
and B is true.

328
00:13:21.721 --> 00:13:24.671
So therefore this is
going to be true.

329
00:13:25.621 --> 00:13:26.595
And C,

330
00:13:27.921 --> 00:13:28.523
what is C?

331
00:13:28.666 --> 00:13:29.871
C is false.

332
00:13:30.005 --> 00:13:31.920
So, false.

333
00:13:32.055 --> 00:13:33.561
It's basically true

334
00:13:33.750 --> 00:13:34.511
or

335
00:13:35.791 --> 00:13:36.531
false.

336
00:13:36.696 --> 00:13:37.706
What will this evaluate to?

337
00:13:37.841 --> 00:13:40.505
This will evaluate to
basically true.

338
00:13:40.831 --> 00:13:41.276
Because

339
00:13:41.411 --> 00:13:43.290
for or, only one needs to be true

340
00:13:43.546 --> 00:13:45.425
in order for the entire expression
to be true.

341
00:13:45.986 --> 00:13:47.400
Now, I made a small mistake here.

342
00:13:48.076 --> 00:13:50.115
Somewhere up here basically,

343
00:13:51.951 --> 00:13:53.510
this goes into or

344
00:13:53.646 --> 00:13:57.226
and then the result of this goes
into or with B.

345
00:13:57.361 --> 00:13:59.845
Same with this, A and B

346
00:14:00.196 --> 00:14:03.375
&amp;&amp; and then the result
of this goes

347
00:14:03.540 --> 00:14:05.210
into &amp; with C.

348
00:14:05.631 --> 00:14:09.850
And then the result of all
of that goes into &amp; with D.

349
00:14:09.986 --> 00:14:12.883
My bad there, sorry.

350
00:14:13.036 --> 00:14:14.195
Made a smaller but

351
00:14:14.330 --> 00:14:16.081
no big deal, okay.

352
00:14:16.216 --> 00:14:16.733
So,

353
00:14:16.866 --> 00:14:17.638
let's

354
00:14:17.771 --> 00:14:18.420
move on.

355
00:14:19.190 --> 00:14:22.041
You also have something like this.

356
00:14:22.671 --> 00:14:23.735
Just so that the.

357
00:14:24.156 --> 00:14:27.315
just so that the sequential order
of these things does not confuse you.

358
00:14:28.406 --> 00:14:31.075
The way I have written them,
it doesn't actually,

359
00:14:32.496 --> 00:14:34.890
it doesn't actually,

360
00:14:36.790 --> 00:14:38.135
it doesn't actually matter
that much.

361
00:14:38.485 --> 00:14:39.093
If I write

362
00:14:39.226 --> 00:14:39.860
C

363
00:14:41.526 --> 00:14:42.105
||

364
00:14:42.941 --> 00:14:45.121
A &amp;&amp; here

365
00:14:46.426 --> 00:14:51.140
B &amp;&amp; C &amp;&amp; D

366
00:14:51.860 --> 00:14:53.390
So this is going to be

367
00:14:53.761 --> 00:14:54.395
false.

368
00:14:54.531 --> 00:14:56.246
Because it is the same

369
00:14:56.666 --> 00:14:58.056
as basically

370
00:14:58.895 --> 00:14:59.660
doing this.

371
00:15:00.496 --> 00:15:01.308
So let me just show you.

372
00:15:02.191 --> 00:15:03.256
This entire thing,

373
00:15:04.120 --> 00:15:06.445
this entire thing can be

374
00:15:06.580 --> 00:15:08.041
put down to

375
00:15:08.670 --> 00:15:09.596
basically this.

376
00:15:10.041 --> 00:15:10.781
Copy this.

377
00:15:13.081 --> 00:15:14.403
Oh you don't need to do this.

378
00:15:14.685 --> 00:15:16.386
I'm just going to do this
for demonstrating purposes.

379
00:15:16.521 --> 00:15:17.420
You put it like this.

380
00:15:18.931 --> 00:15:19.611
And then you put

381
00:15:23.576 --> 00:15:24.643
parenthesis around it.

382
00:15:30.520 --> 00:15:31.096
There we go.

383
00:15:31.750 --> 00:15:33.721
And this is going to evaluate
to what?

384
00:15:34.375 --> 00:15:35.231
So,

385
00:15:36.046 --> 00:15:36.926
A and B

386
00:15:37.486 --> 00:15:38.226
is true.

387
00:15:38.716 --> 00:15:43.610
True and C, which is false. So,
true and false is basically false.

388
00:15:44.311 --> 00:15:45.726
Okay, so this is

389
00:15:46.936 --> 00:15:47.468
false.

390
00:15:48.721 --> 00:15:50.835
And C is false.

391
00:15:51.206 --> 00:15:52.460
So it's basically

392
00:15:53.436 --> 00:15:54.130
false.

393
00:15:57.406 --> 00:15:58.080
false

394
00:16:01.426 --> 00:16:04.525
|| false

395
00:16:04.696 --> 00:16:05.656
So, there we go.

396
00:16:05.791 --> 00:16:07.350
Let me just format
a little bit

397
00:16:07.486 --> 00:16:08.016
for you.

398
00:16:09.436 --> 00:16:11.080
This entire expression

399
00:16:11.641 --> 00:16:12.736
comes down to

400
00:16:12.871 --> 00:16:13.635
false

401
00:16:13.891 --> 00:16:14.565
or

402
00:16:15.681 --> 00:16:16.400
false.

403
00:16:18.071 --> 00:16:20.391
One of these falses is basically

404
00:16:20.696 --> 00:16:23.365
this expression and
the other one is C.

405
00:16:24.041 --> 00:16:25.176
So C is false.

406
00:16:25.781 --> 00:16:26.971
So false or

407
00:16:27.106 --> 00:16:28.705
this entire expression false

408
00:16:29.241 --> 00:16:30.220
will yield

409
00:16:30.356 --> 00:16:34.415
false. And the value of this variable
will be

410
00:16:34.581 --> 00:16:35.160
false.

411
00:16:36.276 --> 00:16:37.071
Simple enough, isn't it?

412
00:16:37.206 --> 00:16:38.595
No,

413
00:16:39.041 --> 00:16:39.875
no need to...

414
00:16:40.271 --> 00:16:42.015
Even if you don't understand this

415
00:16:42.151 --> 00:16:45.260
to the fullest of extense,
it is still okay.

416
00:16:45.496 --> 00:16:46.746
I mean you can look it up
on the net.

417
00:16:46.881 --> 00:16:49.460
You can ask question in the
discussion section.

418
00:16:50.696 --> 00:16:53.666
But also there will be plenty of
other examples through the

419
00:16:53.801 --> 00:16:57.030
code itself that is not perhaps
directly related to this,

420
00:16:57.266 --> 00:16:58.410
so you will be able to pick it up

421
00:16:58.545 --> 00:17:01.141
from there without bigger
problems as well.

422
00:17:02.236 --> 00:17:04.138
So it will be repeated
a good amount of

423
00:17:04.556 --> 00:17:06.875
times through the code indirectly.

424
00:17:08.736 --> 00:17:10.905
Anyway, there is a one more operator

425
00:17:11.041 --> 00:17:15.705
which I wish to go over and
then we are going to call it a day.

426
00:17:15.841 --> 00:17:16.946
But I'm running out of time,

427
00:17:17.081 --> 00:17:19.440
so I will do this in the
follow up tutorial.

428
00:17:20.001 --> 00:17:22.071
In part two of the,

429
00:17:22.716 --> 00:17:23.085
of the,

430
00:17:24.226 --> 00:17:25.986
of the logical operands.

