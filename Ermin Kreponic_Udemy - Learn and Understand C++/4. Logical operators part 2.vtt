WEBVTT

1
00:00:00.046 --> 00:00:00.741
Welcome back.

2
00:00:01.066 --> 00:00:04.386
So, let's just quickly take a
look at the not operator

3
00:00:04.521 --> 00:00:07.016
and be done.

4
00:00:08.056 --> 00:00:12.185
Be done with the relational
operators in any case.

5
00:00:13.466 --> 00:00:14.975
So, in order to,

6
00:00:15.581 --> 00:00:17.905
in order to make this code
more readable

7
00:00:18.041 --> 00:00:20.065
you should really use some
parenthesis

8
00:00:20.201 --> 00:00:21.175
like this. I mean,

9
00:00:21.711 --> 00:00:22.845
you're not going to,

10
00:00:23.221 --> 00:00:24.826
you're not going to make
any difference in the compiler

11
00:00:24.961 --> 00:00:26.165
it really

12
00:00:26.656 --> 00:00:27.235
doesn't

13
00:00:28.701 --> 00:00:29.230
care.

14
00:00:29.371 --> 00:00:30.180
But

15
00:00:31.436 --> 00:00:32.345
when somebody's reading it,

16
00:00:32.481 --> 00:00:34.430
another human being,
when they're reading it,

17
00:00:34.736 --> 00:00:37.148
they will appreciate you
segmenting it.

18
00:00:38.891 --> 00:00:39.400
Anyway.

19
00:00:40.886 --> 00:00:44.505
Let's go ahead and take a look
at the logical not operator.

20
00:00:44.951 --> 00:00:46.390
The logical not...

21
00:00:53.661 --> 00:00:56.005
Sorry. It's not...

22
00:00:56.141 --> 00:00:59.205
you need to write an exclamation
mark, that's the not operator.

23
00:01:00.021 --> 00:01:00.971
My bad.

24
00:01:01.296 --> 00:01:04.125
It's just habit from another
programming language. Never mind.

25
00:01:04.686 --> 00:01:08.195
Anyway, of all the logical
operators not

26
00:01:08.331 --> 00:01:10.000
has the highest

27
00:01:10.166 --> 00:01:10.885
presidence.

28
00:01:12.211 --> 00:01:16.315
And logical not operator is a
unary operator because

29
00:01:16.601 --> 00:01:19.205
it has only one operand,

30
00:01:19.340 --> 00:01:21.286
denoted with an exclamation mark.

31
00:01:21.730 --> 00:01:22.896
So if you

32
00:01:23.031 --> 00:01:24.265
write exclamation mark

33
00:01:24.401 --> 00:01:25.333
and if you type

34
00:01:25.466 --> 00:01:26.975
for example, I don't know, A

35
00:01:27.141 --> 00:01:29.455
it means not A.

36
00:01:31.366 --> 00:01:32.340
That's how it's read,
anyway.

37
00:01:32.851 --> 00:01:33.385
But if you type,

38
00:01:33.521 --> 00:01:35.641
let's go ahead and make an
example down below.

39
00:01:35.776 --> 00:01:36.640
Say, not 1.

40
00:01:36.776 --> 00:01:37.750
=

41
00:01:37.891 --> 00:01:38.470
Oh sorry.

42
00:01:38.680 --> 00:01:39.746
bool

43
00:01:40.516 --> 00:01:41.851
not1

44
00:01:42.465 --> 00:01:43.810
=

45
00:01:45.836 --> 00:01:50.200
Ah can't use this. This is a naming
standard, this is going to...

46
00:01:50.336 --> 00:01:52.098
Let's just go ahead and say
n1

47
00:01:52.611 --> 00:01:53.150
and

48
00:01:53.285 --> 00:01:55.465
we're going to say
exclamation mark A.

49
00:01:58.416 --> 00:01:58.985
So, what this means...

50
00:01:59.121 --> 00:02:03.026
What do you think that
the value of n1will be?

51
00:02:03.161 --> 00:02:06.285
Try to guess. So, let me just share
you one more time, A

52
00:02:06.681 --> 00:02:07.865
is equal to true.

53
00:02:08.540 --> 00:02:10.066
Now since we've placed an
exclamation mark,

54
00:02:10.201 --> 00:02:13.155
infront of it, we have successfully
negated it.

55
00:02:13.415 --> 00:02:14.673
So instead of true,

56
00:02:14.806 --> 00:02:15.620
it will be

57
00:02:15.781 --> 00:02:18.265
false. And the value of n1

58
00:02:18.500 --> 00:02:19.216
will be

59
00:02:19.521 --> 00:02:21.198
false.
If you type in,

60
00:02:21.331 --> 00:02:21.871
bool

61
00:02:22.006 --> 00:02:22.863
down below,

62
00:02:23.351 --> 00:02:24.951
we can, I don't know...

63
00:02:25.556 --> 00:02:28.483
type in n2 and say,

64
00:02:30.830 --> 00:02:32.000
not

65
00:02:33.106 --> 00:02:34.146
not C.

66
00:02:35.286 --> 00:02:36.026
Okay so,
not C.

67
00:02:36.961 --> 00:02:39.021
What do you think that the
value of n2 will be?

68
00:02:39.606 --> 00:02:40.138
Think about it.

69
00:02:40.766 --> 00:02:41.555
C

70
00:02:41.741 --> 00:02:42.925
is equal to false.

71
00:02:43.251 --> 00:02:44.643
If we negate this,

72
00:02:45.155 --> 00:02:46.386
it's false.

73
00:02:46.521 --> 00:02:49.005
Ah I'm sorry, if we negate it,
it's going to be true.

74
00:02:49.520 --> 00:02:52.511
So n2 will have the value of

75
00:02:52.865 --> 00:02:53.396
true.

76
00:02:54.241 --> 00:02:55.106
That's it.

77
00:02:55.241 --> 00:02:56.670
No...

78
00:02:57.041 --> 00:02:58.466
You're basically just reversing it.

79
00:02:58.601 --> 00:03:02.380
Like this, if A is true, if you
negate it, it's going to become false.

80
00:03:02.616 --> 00:03:05.940
If C is false, that if you negate it,
it's going to become true.

81
00:03:06.570 --> 00:03:08.726
So this is what I mean

82
00:03:08.861 --> 00:03:09.470
by

83
00:03:09.605 --> 00:03:10.166
the

84
00:03:10.301 --> 00:03:12.156
presidence. If I type in

85
00:03:12.481 --> 00:03:13.246
bool

86
00:03:14.501 --> 00:03:16.960
I don't know, n3,
completely irrelevant,

87
00:03:17.105 --> 00:03:18.541
the name of the variable
in this case.

88
00:03:18.936 --> 00:03:19.585
A

89
00:03:21.816 --> 00:03:22.625
B

90
00:03:23.401 --> 00:03:26.110
!C &amp;&amp;

91
00:03:26.995 --> 00:03:27.945
D

92
00:03:29.361 --> 00:03:30.775
Ah that should be fine.
A

93
00:03:31.291 --> 00:03:32.403
&amp;&amp;

94
00:03:33.171 --> 00:03:33.936
B, sorry.

95
00:03:37.700 --> 00:03:38.461
Okay, there we go.

96
00:03:38.675 --> 00:03:39.926
So, A

97
00:03:40.251 --> 00:03:43.525
&amp;&amp; !C &amp;&amp;

98
00:03:43.851 --> 00:03:44.385
D

99
00:03:44.966 --> 00:03:45.480
So,

100
00:03:45.616 --> 00:03:46.170
what do you...

101
00:03:47.080 --> 00:03:47.906
Take a look at the expression

102
00:03:48.041 --> 00:03:49.506
and try to reach a conclusion

103
00:03:49.641 --> 00:03:51.625
what the end result will be.

104
00:03:52.631 --> 00:03:54.345
The end result will be true.

105
00:03:55.646 --> 00:03:56.435
Because

106
00:03:58.040 --> 00:03:59.126
true

107
00:03:59.941 --> 00:04:01.225
and

108
00:04:01.360 --> 00:04:02.565
A is true.

109
00:04:02.866 --> 00:04:03.381
And we have

110
00:04:03.516 --> 00:04:07.275
negated C here. So,
C will also become true.

111
00:04:09.206 --> 00:04:11.690
And D is also true.

112
00:04:11.991 --> 00:04:12.741
Henceforth,

113
00:04:12.876 --> 00:04:15.235
the result will be true.

114
00:04:15.431 --> 00:04:16.401
Always will be true.

115
00:04:18.796 --> 00:04:20.990
If I type in bool n4,

116
00:04:21.126 --> 00:04:22.676
I do believe this will be the

117
00:04:22.811 --> 00:04:24.600
last example that I shall
give you.

118
00:04:24.811 --> 00:04:27.476
In this regard, you can type in
!A

119
00:04:27.756 --> 00:04:31.246
and try to, as I write it out,
try to guess the result.

120
00:04:31.381 --> 00:04:32.466
Try to guess what will it be.

121
00:04:32.601 --> 00:04:35.231
Will the end result be true?
Or will it be

122
00:04:35.491 --> 00:04:36.023
false?

123
00:04:36.396 --> 00:04:36.951
If I type in

124
00:04:37.511 --> 00:04:38.345
!B

125
00:04:40.436 --> 00:04:41.061
||

126
00:04:42.361 --> 00:04:46.070
!C || !D

127
00:04:46.696 --> 00:04:49.165
So,

128
00:04:50.791 --> 00:04:51.491
take a guess

129
00:04:51.626 --> 00:04:53.226
or conclude it for
yourselves.

130
00:04:53.601 --> 00:04:54.385
It's or.

131
00:04:54.971 --> 00:04:57.826
So as long as at least one
of these

132
00:04:57.961 --> 00:04:59.285
evaluates the true,

133
00:04:59.546 --> 00:05:00.841
this is going to be,

134
00:05:03.121 --> 00:05:06.140
the entire section will be
evaluated as true.

135
00:05:07.556 --> 00:05:10.705
Henceforth, the result will
be true

136
00:05:10.841 --> 00:05:12.760
because A is true.

137
00:05:12.896 --> 00:05:13.690
But if we negate it,

138
00:05:13.825 --> 00:05:14.571
it's false.

139
00:05:14.706 --> 00:05:15.240
And

140
00:05:15.496 --> 00:05:17.025
false and false

141
00:05:17.491 --> 00:05:18.543
will yield

142
00:05:18.676 --> 00:05:20.026
false because B is also true

143
00:05:20.161 --> 00:05:22.275
and when you negate it,
it will be false.

144
00:05:22.766 --> 00:05:24.155
And then you have,

145
00:05:24.526 --> 00:05:25.080
ooops like this,

146
00:05:25.666 --> 00:05:27.126
false and

147
00:05:27.315 --> 00:05:27.870
true

148
00:05:28.360 --> 00:05:28.898
is true.

149
00:05:29.031 --> 00:05:31.785
Because C is false and once
negated it will become true,

150
00:05:31.921 --> 00:05:32.770
henceforth,

151
00:05:33.026 --> 00:05:35.016
the result will be true.

152
00:05:36.056 --> 00:05:37.675
Anyway, that's it

153
00:05:37.811 --> 00:05:40.871
as far as the relational operators
are concerned.

154
00:05:42.801 --> 00:05:43.875
It should be

155
00:05:44.010 --> 00:05:45.166
fine. I don't believe

156
00:05:45.681 --> 00:05:46.630
that I have

157
00:05:47.516 --> 00:05:50.066
skipped anything and
we will jump,

158
00:05:50.581 --> 00:05:52.666
sorry, not relational, these are
the logical operators that

159
00:05:52.801 --> 00:05:55.685
should be it as far as the
logical operators are concerned.

160
00:05:56.315 --> 00:05:58.706
No more I shall speak of them
but later on

161
00:05:58.841 --> 00:06:00.865
when we go through the
examples. You will see

162
00:06:01.001 --> 00:06:03.956
more complex variance of

163
00:06:04.091 --> 00:06:06.535
this. We will use them
extensively.

164
00:06:06.671 --> 00:06:08.875
Please make sure that you
understand this.

165
00:06:09.106 --> 00:06:09.856
You will

166
00:06:09.991 --> 00:06:11.386
need this.
I mean,

167
00:06:13.216 --> 00:06:15.350
four conditions, it will,

168
00:06:15.771 --> 00:06:16.490
you can,

169
00:06:16.771 --> 00:06:17.580
this is,

170
00:06:18.166 --> 00:06:19.866
if you have millions of lines of code

171
00:06:20.001 --> 00:06:22.905
you are bound to encounter
a lot of these examples.

172
00:06:23.041 --> 00:06:24.800
If you have a hundred lines
of code,

173
00:06:24.966 --> 00:06:26.826
you are still bound to encounter
these examples

174
00:06:26.961 --> 00:06:29.005
because a lot of
what C++ is,

175
00:06:29.311 --> 00:06:31.935
a lot of what it does,
it will be based on

176
00:06:32.071 --> 00:06:34.020
sets and sets and sets of

177
00:06:34.416 --> 00:06:35.320
conditions.

178
00:06:35.576 --> 00:06:37.850
Your code will be based
on that basically.

179
00:06:39.361 --> 00:06:41.226
Anyway if you don't
understand these completely,

180
00:06:41.361 --> 00:06:42.426
please look it up on the net.

181
00:06:42.561 --> 00:06:47.365
Additionally, ask questions in
the discussion section and

182
00:06:49.066 --> 00:06:52.180
again if you fail,
it's okay. Just keep on going.

183
00:06:52.316 --> 00:06:55.985
It will be used as I said
extensively through the codes so

184
00:06:56.150 --> 00:06:57.385
hopefully, eventually,

185
00:06:57.520 --> 00:06:58.701
you will pick it up.

186
00:06:58.835 --> 00:07:00.078
So next up,

187
00:07:00.211 --> 00:07:03.705
we will go into
relational operators

188
00:07:03.841 --> 00:07:05.320
so in the follow up tutorial.

189
00:07:05.551 --> 00:07:05.920
Until then,

190
00:07:06.201 --> 00:07:08.940
I'm going to bid you farewell
and a ton load of luck with this.

