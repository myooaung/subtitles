WEBVTT

00:00.300 --> 00:05.860
Bienvenidos a todos hoy. Voy a seguir adelante y hablar sobre mapas.

00:05.970 --> 00:13.180
Así que hasta ahora era como vector dequeue string y vamos a echar un vistazo al mapa de esta parte.

00:13.200 --> 00:17.010
No necesita el letrero para solucionar problemas.

00:17.340 --> 00:24.060
De todos modos, escribí el código esta vez principalmente debido al hecho de que he

00:24.060 --> 00:30.720
fallado miserablemente cuando intenté lanzar esto antes por razones que entraré en un momento porque

00:30.720 --> 00:34.780
también son importantes para ti así que nada realmente nuevo.

00:34.790 --> 00:36.680
Nada realmente extraño sobre esto.

00:36.720 --> 00:38.830
Has visto la mayoría de las cosas como antes.

00:39.060 --> 00:44.400
Sin embargo, el mapa es, básicamente, el mapa básicamente consta de fuera de pares.

00:44.640 --> 00:52.780
Entonces, si tiene un par de valores clave, estaba la clave, que en este caso es INT.

00:52.820 --> 00:56.060
Y luego está el valor que en este caso es una cadena.

00:56.060 --> 01:00.550
Y aquí tienes el nombre del mapa, así que son los números 0.

01:00.560 --> 01:03.020
Básicamente, la cadena es 0.

01:03.020 --> 01:04.260
Aquí la cadena es uno.

01:04.260 --> 01:07.680
Y aquí la cuerda también.

01:07.850 --> 01:13.430
De todos modos, puedes imprimirlos así más o menos igual que imprimirías los elementos

01:13.430 --> 01:17.570
de la matriz o no sé vector o lo que sea.

01:17.570 --> 01:22.900
Es muy similar pero puedes usar esto en cero.

01:23.030 --> 01:24.940
Entonces haremos lo mismo.

01:24.980 --> 01:30.840
Esta es la forma recomendada de hacer las cosas de acuerdo con algunas personas a continuación.

01:30.850 --> 01:37.810
Vamos a seguir adelante e imprimir el tamaño de la matriz que es básicamente números, no el tamaño.

01:37.810 --> 01:40.600
Este no es el tamaño en términos de bytes como antes.

01:40.600 --> 01:45.800
No confundas el tamaño con el tamaño.

01:46.070 --> 01:52.060
El tamaño simplemente te dirá cuántos elementos hay cuántos elementos contiene.

01:52.060 --> 01:57.580
De todos modos, este es el booleano que estamos usando, si estuvieras usando el método, el

01:57.580 --> 02:01.480
vacío aquí para verificar si el mapa está vacío o no.

02:01.480 --> 02:02.400
Igual que antes.

02:02.410 --> 02:04.030
No hay diferencias allí.

02:04.030 --> 02:07.670
Y aquí vamos a seguir adelante y vamos a cazar.

02:07.690 --> 02:09.850
Así que no vamos a buscar, vamos a buscar.

02:09.850 --> 02:11.100
Digámoslo así.

02:11.470 --> 02:13.930
Así que estamos buscando algo dentro de una matriz.

02:13.930 --> 02:20.130
Entonces, ¿hay allí un segundo elemento 220?

02:20.140 --> 02:21.130
Obviamente no.

02:21.130 --> 02:26.420
El conjunto tiene como tres el tamaño del mapa, es tres, por lo que hay tres elementos en total.

02:26.830 --> 02:33.140
Y obviamente no había doscientos veinte elementos para necesitar esto de

02:35.800 --> 02:36.850
todos modos.

02:37.460 --> 02:40.990
Ahora note que he declarado aquí.

02:41.030 --> 02:48.830
Básicamente, la orden tomará el valor de retorno de find y si no

02:48.830 --> 02:54.500
logra encontrar lo que busca, básicamente devuelve algo extraño.

02:54.530 --> 02:56.520
¿Cuál es?

02:56.540 --> 03:01.910
Devuelve un iterador para después del último elemento del mapa.

03:01.910 --> 03:09.420
Digamos que el último elemento de Mehl aquí es 0 1 2 y luego 3 devolvería el iterador, lo que realmente

03:09.420 --> 03:16.430
devolvería sería 3, por lo que es 0 1 2 y luego 3 sería el iterador después del último

03:16.430 --> 03:18.730
porque el el último es 2.

03:19.010 --> 03:24.950
Ahora, desafortunadamente, no voy a imprimirlo en la pantalla porque da como resultado

03:25.040 --> 03:26.210
un comportamiento indefinido.

03:26.270 --> 03:32.540
Usted ve que estoy comparando el valor de TI ahora si es igual al método al valor de

03:32.540 --> 03:38.870
retorno del punto invertido, que básicamente devuelve lo mismo y si es igual a eso, entonces declararé que

03:38.870 --> 03:40.810
la clave no ha sido encontró.

03:40.820 --> 03:49.520
Y aquí intentaré imprimir para imprimir el valor del cuarto elemento número 3, así que 0 1

03:49.520 --> 03:50.570
2 3.

03:50.720 --> 03:52.900
Pero eso dará como resultado un comportamiento indefinido.

03:52.900 --> 03:55.630
Voy a obtener un error o algo así sucederá.

03:55.850 --> 03:59.910
Pero si no quisiera hacer eso, también podría haber escrito I-T aquí.

04:00.380 --> 04:01.880
Esto tampoco funcionaría.

04:01.880 --> 04:06.600
Así que no te preocupes realmente por no quitarle valor a una pelea.

04:06.620 --> 04:08.630
Eso no es realmente tan importante para ti.

04:08.660 --> 04:15.160
Podemos compararlo hasta el final y si se encuentra bien si no lo está, no lo es.

04:15.160 --> 04:15.740
Siga adelante.

04:15.800 --> 04:17.450
Déjame seguir adelante y ejecutar este programa.

04:17.450 --> 04:19.200
Esto se va a bloquear muy probablemente.

04:19.470 --> 04:20.230
Sí, vamos.

04:20.240 --> 04:25.420
Dice terminar llamado después de tirar una instancia de primero a fuera de rango.

04:25.430 --> 04:29.430
Ahora, si estás trabajando con C ++ 98, esto no va a suceder.

04:29.420 --> 04:35.460
Esto es, en realidad debería funcionar, pero va a funcionar de la manera que usted quiere que funcione.

04:35.460 --> 04:39.470
Tendrás algunos problemas, sin embargo, no obtendrás una excepción, pero en

04:39.500 --> 04:42.690
C ++ 11 lo harás de todos modos.

04:43.010 --> 04:51.420
Si simplemente escribimos como tres y ejecutamos esto, verá que dice cero, el tamaño de la matriz es tres.

04:51.610 --> 04:54.980
Y dice que la clave no se ha encontrado.

04:55.430 --> 04:56.470
OK, no usemos tres.

04:56.470 --> 05:02.220
Usemos una flecha 100 porque los Tres del tamaño de la teoría C predicaban el tamaño de la matriz.

05:02.590 --> 05:05.180
Y estamos imprimiendo el primer elemento de la matriz.

05:05.260 --> 05:09.530
Entonces primer elemento y luego el tamaño y luego estamos verificando si está vacío o no.

05:09.550 --> 05:11.220
Y luego estamos buscando un elemento.

05:11.260 --> 05:16.350
Y si se encuentra, indica que se ha encontrado la clave clave suficiente y, si no se encuentra, indicará que no se ha encontrado la clave.

05:18.930 --> 05:26.330
De acuerdo, entonces es un cero, que es el primer elemento, el tamaño es tres y, de hecho, no

05:26.380 --> 05:28.180
ha sido encontrado si Taipan

05:31.190 --> 05:35.600
no lo sé. Uno dice que se ha encontrado la clave.

05:35.600 --> 05:44.270
Creo que también podríamos imprimir el valor, pero por el momento no es necesario no querer molestarnos con

05:44.270 --> 05:44.570
eso.

05:44.570 --> 05:46.190
Realmente podemos eliminarlo.

05:46.250 --> 05:47.640
Realmente no es tan importante.

05:48.600 --> 05:49.650
Puedo hacerlo así

05:49.650 --> 05:53.850
Y conceden que hay una hermosa clave encontrada.

05:53.880 --> 05:54.350
Yo tengo.

05:54.360 --> 05:57.910
Se ha encontrado de manera exitosa.

05:59.500 --> 06:09.740
OK así que al lado tenemos abajo aquí la inicialización de los días de tipo de mapa.

06:10.060 --> 06:11.500
Y así es como se inicializaría.

06:11.500 --> 06:16.480
Entonces los días son más o menos los mismos que los números, excepto que lo hemos inicializado de una manera

06:16.480 --> 06:17.950
diferente, que es mucho más eficiente.

06:18.220 --> 06:25.250
Así que inicializar cosas como esta e inicializar cosas como esta difiere en gran medida.

06:25.270 --> 06:27.230
Antes que nada debes escribir menos.

06:27.370 --> 06:31.260
Y es y es su lugar de una manera mucho más lógica.

06:31.300 --> 06:38.980
Por ejemplo, este fue el método de inicialización que se usó en el registrador de teclas para

06:39.130 --> 06:42.530
mapear las teclas en el teclado físico.

06:42.760 --> 06:46.490
Entonces tenías un valor hexadecimal que era una clave.

06:46.540 --> 06:52.540
Y luego tuviste un valor correspondiente que era algo que era legible por humanos.

06:52.540 --> 06:59.320
Así que decir que no lo sé, así que la letra T la tecla, la tecla o la tecla configurada en su teclado tienen

06:59.320 --> 07:03.430
valores hexadecimales y esas eran las claves si no me equivoco si no recuerdo mal.

07:03.670 --> 07:10.800
Y luego, aquí tenías como un conjunto antiguo o tú o él entra o algo así.

07:11.350 --> 07:18.700
De todos modos, a continuación tenemos un bucle de cuatro para estándar y este es un método estándar para imprimir algo en

07:18.700 --> 07:19.270
la pantalla.

07:19.270 --> 07:23.710
Aquí puede ver que he usado esto de una manera diferente, pero

07:23.770 --> 07:28.620
estoy acostumbrado a usar estos formularios en lugar de a, aunque también puede usarlos.

07:28.650 --> 07:34.650
De todos modos, esto va a imprimir todo esto en la pantalla, todos los días van a imprimirse en la pantalla. El

07:34.650 --> 07:36.940
sanador simplemente continuará y lo hará una vez más.

07:36.930 --> 07:42.490
Entonces lunes martes miércoles jueves viernes sábado domingo.

07:42.720 --> 07:43.480
Excelente.

07:43.480 --> 07:48.930
Entonces nota que uno dos tres cuatro cinco seis siete no se ha impreso en la pantalla de esta manera.

07:48.940 --> 07:51.920
Entonces estos son solo los iteradores las claves.

07:52.090 --> 07:57.390
Y luego tienes los valores y cada valor tiene una clave correspondiente.

07:57.850 --> 08:05.680
OK para despedirse que sería al menos tan lejos como los mapas Darryn demasiado complejo bastante

08:05.680 --> 08:07.100
simple de comprender.

08:07.150 --> 08:11.980
Usted tiene alguna pregunta a través de ellos en la sección de discusión o en la sección Q y A como se llama

08:11.980 --> 08:12.250
ahora.
