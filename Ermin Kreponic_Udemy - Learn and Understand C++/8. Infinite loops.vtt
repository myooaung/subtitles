WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.600
Welcome back. So, let's go ahead and talk
about infinite loops. We use these loops,

00:00:06.600 --> 00:00:13.210
we will use these loops, when we don't
know the exact number of iterations. So,

00:00:13.210 --> 00:00:19.210
we will execute the loop until some
condition is satisfied. So, let's go ahead

00:00:19.210 --> 00:00:23.430
and take a look at the example where we
have modified the previous example in

00:00:23.430 --> 00:00:28.490
which the user keeps entering a number
until the imput is -1. Here

00:00:28.490 --> 00:00:32.660
is the example, I have
just modified it a little bit. The

00:00:32.660 --> 00:00:39.690
modification is here in the for loop. So,
let me just do this. It has no difference in

00:00:39.690 --> 00:00:43.989
terms of the code, I just want to isolate
this part for you so you can see it. So,

00:00:43.989 --> 00:00:48.700
again as before we have "int i = 1"
but hey guess what there was no

00:00:48.700 --> 00:00:54.469
condition in between, and the iteration keeps on going. So, this is always true there is

00:00:54.469 --> 00:00:58.600
nothing to terminate this loop unless
there is some logic implemented within

00:00:58.600 --> 00:01:02.739
the loop to actually terminate it, the loop
will continue on running pretty much

00:01:02.739 --> 00:01:04.379
indefinitely.

00:01:04.379 --> 00:01:09.400
However, it will self-terminate with the execution of the

00:01:09.400 --> 00:01:14.590
break statement once -1 is
entered. Here let me show you. I can build and

00:01:14.590 --> 00:01:24.130
run this, and I can enter see I can just
keep on entering numbers, but it will

00:01:24.130 --> 00:01:30.189
never end. So, it will continuously keep
on asking me to enter a number until I type

00:01:30.189 --> 00:01:36.439
in -1. Then it's going to give me the
sum and terminate the execution, and

00:01:36.439 --> 00:01:41.450
pretty much exit the program.
So, this will continue on repeatedly,

00:01:41.450 --> 00:01:46.520
repeating indefinitely until the
user enters something, until the user

00:01:46.520 --> 00:01:50.189
enters -1. But, that's not the important part, this is

00:01:50.189 --> 00:01:55.530
how you create the infinite for loop by
just leaving the condition empty. You

00:01:55.530 --> 00:01:58.790
could also give a condition which will
never be satisfied,

00:02:00.530 --> 00:02:03.740
perhaps not in this particular statement,

00:02:03.740 --> 00:02:09.220
but there are some situations where you can do

00:02:09.220 --> 00:02:12.220
that. Perhaps you could even do it here
I'm just too lazy to think about it now,

00:02:12.220 --> 00:02:16.830
because it's completely irrelevant as
you can just leave it empty and that's

00:02:16.830 --> 00:02:20.920
pretty much it. That's going to create
the infinite loop without any problems.

00:02:22.190 --> 00:02:30.900
Now the infinite version of the while loop,
well this would be it. So,

00:02:30.900 --> 00:02:41.319
while and then you could just type in
true. So, while true I don't know let's

00:02:41.319 --> 00:02:52.819
go ahead and write some pseudocode.
"while (true) some code..." and below we could

00:02:52.819 --> 00:03:03.620
write an if statement like we did before,
"if(condition)" and then you would have "break" So,

00:03:03.620 --> 00:03:07.230
this would be this would be an example
of the infinite while loop. So,

00:03:07.230 --> 00:03:10.970
you could write in "while(true)" or you
could just write a positive

00:03:10.970 --> 00:03:15.760
integer here. You could just write a
positive number here, sorry. Just type in "1" for

00:03:15.760 --> 00:03:19.670
example. This would also evaluate the
true and this would continue forever

00:03:19.670 --> 00:03:25.690
with some logic within the loop the loop would be terminated, like with the

00:03:25.690 --> 00:03:33.299
the break statement. So, one
more example would be basically instead

00:03:33.299 --> 00:03:43.560
of 1 you could write in while I don't
know "227" Makes no sense but as I said

00:03:43.560 --> 00:03:49.920
you could write a positive number here and it would evaluate the true. You could

00:03:49.920 --> 00:03:53.720
write a negative
numbers, etc. I do believe that I have

00:03:53.720 --> 00:03:56.380
shown that in the previous examples, but
I don't like to play around with these

00:03:56.380 --> 00:04:02.359
things while I'm coding, I like to write either "1" or "0" because those are synonyms for true and

00:04:02.359 --> 00:04:05.769
false, or I like to
write true or false.

00:04:06.269 --> 00:04:09.819
There is no reason why you should write
anything else other than that if you

00:04:09.819 --> 00:04:12.810
just need the evaluation to be true
continuously, however

00:04:12.810 --> 00:04:16.600
you know later on things get
complicated, but for the time being there

00:04:16.600 --> 00:04:20.859
is no need to use anything else other than
"true" or "false" and "0" and "1" but as

00:04:20.859 --> 00:04:22.500
we go through the code later on the

00:04:22.500 --> 00:04:25.780
need becomes greater and greater, and the demands become greater and greater. So,

00:04:25.780 --> 00:04:30.070
you have to use different things. So, I
could have written "227" here and this

00:04:30.070 --> 00:04:35.880
would also be an infinite loop. Anyway,
that's all I want to show in this brief

00:04:35.880 --> 00:04:41.550
example here, now in the follow up tutorial I'll just explain nested loop. How

00:04:41.550 --> 00:04:45.870
you can nest them one inside of another
and that will be it, as far as the loops

00:04:45.870 --> 00:04:46.370
are concerned.

