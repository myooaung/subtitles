WEBVTT

00:00:00.000 --> 00:00:03.313
Welcome back all. Ok
so, in this chapter

00:00:03.338 --> 00:00:06.401
we will introduce
standard types in C++

00:00:06.500 --> 00:00:10.801
that are part of the
standard library

00:00:10.826 --> 00:00:15.290
so in short STL these
types make your

00:00:15.290 --> 00:00:18.545
programming experience
a lot easier and

00:00:18.570 --> 00:00:22.000
they save you a lot
of headaches so here

00:00:22.000 --> 00:00:29.920
we will cover the following one's let's
put him down here so STD vector

00:00:32.820 --> 00:00:40.779
std string std map  it gave
us a very interesting, this is a very

00:00:44.879 --> 00:00:49.219
interesting type map, it's very nice I've
actually utilized in the keylogger

00:00:49.219 --> 00:00:53.088
course in order to
save certain set of

00:00:53.113 --> 00:00:56.599
company of pairs,
which can be accessed

00:00:56.699 --> 00:01:00.910
through an identifier for an
index however you wish to refer to it

00:01:00.910 --> 00:01:02.319
anyway std, function and std, dq

00:01:09.770 --> 00:01:16.180
you might have seen some of them
probably not but we're going to go

00:01:16.180 --> 00:01:21.659
over these and we'll see where we end up so
let's just go ahead and remove it from

00:01:21.659 --> 00:01:26.939
here. So, the very first one that I'm
going to go over as the vector

00:01:27.710 --> 00:01:31.240
so std, colon colon, vector,
represents basically

00:01:31.265 --> 00:01:34.770
a race vector represents
a raise that can

00:01:34.770 --> 00:01:39.016
change in size so
dynamic, flexible and

00:01:39.041 --> 00:01:42.630
it is also reliable
it is a part of the vector

00:01:43.509 --> 00:01:45.966
library as well so to
include vectors in

00:01:45.991 --> 00:01:48.159
your code you would
need the following

00:01:48.259 --> 00:01:53.950
basically just a
live, here include

00:01:53.975 --> 00:01:59.399
vector that set and
then we can move on down

00:02:00.590 --> 00:02:03.890
not that not that much different from
the arrays

00:02:03.890 --> 00:02:07.091
but they do take a
larger chunk of memory

00:02:07.116 --> 00:02:10.470
space however unlike
the arrays they are very much dinamic

00:02:12.420 --> 00:02:15.957
Vector, let's go
ahead and try one so

00:02:15.982 --> 00:02:19.744
let's declare a
vector of 10 integers

00:02:20.940 --> 00:02:28.239
type in int and we shall name it vec1

00:02:29.040 --> 00:02:35.610
yeah let's just leave it like that, let's
put this to 10 so all elements will

00:02:35.610 --> 00:02:39.140
initially have a value
of 0 do notice the

00:02:39.165 --> 00:02:42.459
similarities would
raise ok so let's go ahead

00:02:43.920 --> 00:02:51.860
declare a double, vector and I'm just
trying to demonstrate the sintax here

00:02:52.660 --> 00:03:00.600
it's not really that complicated at all
it's fairly similar to the arrays

00:03:00.700 --> 00:03:05.959
however you register bit of a different
fashion and you can also declare an

00:03:05.959 --> 00:03:11.530
empty vector as well off zero elements
not at all not at all the elements are

00:03:11.530 --> 00:03:13.657
initialized to 0 but
that all the elements

00:03:13.682 --> 00:03:15.730
are 0 so the default
initialization

00:03:15.830 --> 00:03:21.350
for the int type is 0 and for the double
is 0.0

00:03:23.220 --> 00:03:29.086
down below, we can have like
vector and we can leave

00:03:29.111 --> 00:03:35.330
this one to be int as
well but just type in 3

00:03:35.430 --> 00:03:40.299
that's it, you don't actually need to go
any further you can declare a vector

00:03:40.299 --> 00:03:44.025
that is completely
empty that has 0

00:03:44.050 --> 00:03:47.230
elements, ok so we
can also declare a

00:03:47.230 --> 00:03:53.290
vector with elements and we can
state that we want to initialize the

00:03:53.290 --> 00:03:57.440
we can stated we want each and
every element to be initialized to a

00:03:57.440 --> 00:04:02.489
certain value without the loops, but it
does need to be the same value in this

00:04:02.489 --> 00:04:08.902
case, vector int and
then we can type

00:04:08.927 --> 00:04:14.459
in vector, ok this
is going to be like 3,7

00:04:17.139 --> 00:04:23.800
ok we shall have three elements and all three
elements will be initialized to 7 we can

00:04:31.930 --> 00:04:37.359
pull the size of the
vector, see if you

00:04:37.384 --> 00:04:41.749
type in, let me show
you, unsigned int

00:04:41.749 --> 00:04:49.173
let's take a first well,
this spell terribly,

00:04:49.198 --> 00:04:55.189
vect1_size so that's
one size and I can

00:04:55.189 --> 00:05:03.130
state that is equal to vec1.size, so this will be the size of this

00:05:04.930 --> 00:05:09.139
the size of this integer, well the value
that will be assigned to the variable

00:05:09.139 --> 00:05:16.439
that's one size of type unsigned int
will be 10, because that is the size of

00:05:16.439 --> 00:05:22.289
the vector, if you want to print out the
elements of the vector, we would need to

00:05:22.289 --> 00:05:27.620
use a loop simple
enough to do really so

00:05:27.645 --> 00:05:33.529
int I equals 0, semicolon
I is less than

00:05:33.629 --> 00:05:38.509
and you would be able to pull the size
without any bigger problems by just

00:05:38.509 --> 00:05:46.490
using the.. let's take the fourth one
and let's print out all the sevens

00:05:46.899 --> 00:05:54.830
dot, size, plusplus I, std, colon colon

00:05:58.360 --> 00:06:04.994
that's four, I. Ok so,
these elements are

00:06:05.019 --> 00:06:11.980
accessed pretty much
the same way as

00:06:12.080 --> 00:06:16.949
in the arrays, do you remember this
part from the arrays? how about it's to pull it?

00:06:16.949 --> 00:06:22.300
although we couldn't use the
for loops condtition was

00:06:22.300 --> 00:06:27.879
was somewhat different but no big deal
there it will just go over each and

00:06:27.879 --> 00:06:30.646
every element and it
will printed out onto

00:06:30.671 --> 00:06:32.860
the screen, let me just
show you so its 777

00:06:32.860 --> 00:06:38.650
that's what gets printed out onto the
screen then go into the new line just and

00:06:38.650 --> 00:06:40.039
add spaces between them

00:06:40.039 --> 00:06:44.442
ok so it is also
recommended to access

00:06:44.467 --> 00:06:48.080
elements by using
the dot at in the

00:06:48.080 --> 00:06:51.528
provide in the index
instead of going about

00:06:51.553 --> 00:06:55.039
things this way so let
me show you that as

00:06:55.039 --> 00:06:59.783
well I mean it's
just a different way

00:06:59.808 --> 00:07:03.749
of accessing it so
int el in an element

00:07:03.849 --> 00:07:08.909
equals vect1 and we
put a dot and we type

00:07:08.934 --> 00:07:13.219
at, see? you notice
it's the same syntax

00:07:13.219 --> 00:07:14.947
as with the size the
size of some sort

00:07:14.972 --> 00:07:16.659
of a method that
returns some sort of a

00:07:16.759 --> 00:07:20.719
value at will pretty
much is pretty much

00:07:20.744 --> 00:07:24.860
the same thing so we'll
just say at and I

00:07:24.860 --> 00:07:32.790
don't know 0, the value of this would be

00:07:32.990 --> 00:07:40.950
the same as me basically typing in this
so that's 0 so these two

00:07:42.550 --> 00:07:46.120
two will give you
the same value, these two will contain

00:07:46.120 --> 00:07:50.420
the same value so to say,
so let's delete that,

00:07:50.445 --> 00:07:54.620
this is kind of intuitive
so at and then

00:07:54.719 --> 00:08:00.379
the element the element index sorry
a semicolon here

00:08:01.870 --> 00:08:07.040
at certain index. Ok it compiles and runs
let's go look for the printout just

00:08:07.040 --> 00:08:09.946
looking to see if I
have any errors in a

00:08:09.971 --> 00:08:12.550
code, you can
periodically do compile

00:08:12.550 --> 00:08:15.448
build and run, why?
Just to see if

00:08:15.473 --> 00:08:18.410
you have any syntax error, don't

00:08:18.410 --> 00:08:22.300
write the whole code out and then attempt building and rather instead

00:08:22.300 --> 00:08:25.300
do many bills while you're actually
coding

00:08:27.830 --> 00:08:31.314
moving onwards method .
empty well

00:08:31.339 --> 00:08:35.130
method empty, returns
a bool value which

00:08:35.130 --> 00:08:38.545
indicates whether the
vector is empty or not,

00:08:38.570 --> 00:08:42.294
let me go ahead and
write that out for you

00:08:45.220 --> 00:08:49.433
bool empty, here are some
birds in the background

00:08:49.458 --> 00:08:53.800
there is nothing I can do
about it, it's spring so

00:08:53.800 --> 00:09:01.720
they're all around the building vect
and it doesn't help that I that I feed

00:09:05.020 --> 00:09:08.234
pigeons here so, it
might be a terrible

00:09:08.259 --> 00:09:12.020
thing for the sound
but oh well anyway I

00:09:12.020 --> 00:09:14.890
don't think that you can actually hear
them but just wanted to mention that just in case

00:09:16.430 --> 00:09:20.520
so let's do . empty
again we're using

00:09:20.545 --> 00:09:25.010
the same syntax
utilizing a different

00:09:25.110 --> 00:09:31.310
method to check whether the vector is
empty or not and we shall use another

00:09:31.310 --> 00:09:38.407
one bool emp2 so empty 1 empty 23 .
empty

00:09:38.432 --> 00:09:45.930
semicolon, so you see
how we're using these

00:09:45.930 --> 00:09:49.141
methods just by a dot
adding a dot here

00:09:49.166 --> 00:09:52.180
and we're trying to
figure it out so

00:09:52.280 --> 00:09:58.670
that 2 is that empty and you have
3 this 3 is empty basically

00:09:58.670 --> 00:10:01.790
completely, it doesn't have any elements of
whatsoever

00:10:03.080 --> 00:10:06.672
while the vets to
actually has five

00:10:06.697 --> 00:10:10.440
elements that this is
a booling, basically

00:10:10.540 --> 00:10:12.090
true or false
one of it too

00:10:13.059 --> 00:10:18.119
this is not determining
whether the variables have been

00:10:18.119 --> 00:10:21.959
initialized to something, this is just
determining whether the size of the

00:10:21.959 --> 00:10:27.639
vector is equal to 0 or not say you see
the size of this factor is zero and the

00:10:27.639 --> 00:10:32.959
size of this factor is five so this one
is not empty and this one is empty

00:10:32.959 --> 00:10:36.733
simple as that that is how it is

00:10:36.758 --> 00:10:40.199
evaluated ok so now
let's go ahead and

00:10:40.199 --> 00:10:43.199
take a look at pushback method

00:10:44.309 --> 00:10:52.283
std, colon colon, cout,
vec3.size std, colon colon

00:10:58.008 --> 00:11:05.989
and endl, so this is going
to print out the size of

00:11:11.389 --> 00:11:15.240
the vector 3 that
we have here which

00:11:15.265 --> 00:11:19.089
will be basically
I mean ok can you

00:11:19.189 --> 00:11:25.062
guess what is the size of
the vec ?3 this one is 10,

00:11:25.087 --> 00:11:30.609
this one is 5 and this
one is 0 so if we do the

00:11:30.609 --> 00:11:38.586
following vec.push_back
100, so this is adding

00:11:39.511 --> 00:11:47.159
100 you'll see soon enough
what I mean by that

00:11:47.159 --> 00:11:50.349
and let's go ahead and do this

00:11:53.310 --> 00:11:59.881
ok three so let's go
ahead and build and

00:11:59.906 --> 00:12:06.240
run this, its 1, so
see now you have now

00:12:06.340 --> 00:12:11.940
we actually now it's no longer and it's
no longer empty basically, so here it

00:12:11.940 --> 00:12:16.824
was zero yep so here
it was zero and we

00:12:16.849 --> 00:12:21.390
did we need to push
back and then is

00:12:21.390 --> 00:12:25.843
actually one ok what
else can we do? we

00:12:25.868 --> 00:12:31.490
can initialize a
vector so that's like

00:12:31.490 --> 00:12:39.300
super simple to do so, std, colon colon

00:12:44.200 --> 00:12:52.180
so 54321 I don't
really need anymore and you would print

00:13:07.080 --> 00:13:12.320
them out basically the same way you
would print out an array it's not a bad

00:13:12.320 --> 00:13:15.019
idea to use the for
each loop here as it is

00:13:15.044 --> 00:13:17.770
shorter than the for
loop for this purpose

00:13:17.770 --> 00:13:25.741
and easier to use so
int I, vec5, hopefully

00:13:27.866 --> 00:13:35.780
you know how to do
this this is by now,

00:13:36.980 --> 00:13:40.213
I'm gonna create a
very handy print out

00:13:40.238 --> 00:13:43.170
of all the elements
here and for example

00:13:43.170 --> 00:13:51.090
delete the last element so that's vect5.pop

00:13:53.630 --> 00:13:56.994
back, let's it- so this
is just another method

00:13:57.019 --> 00:14:00.490
this is how you would
delete the last element

00:14:00.490 --> 00:14:08.400
and let's go ahead and build it ok so 54321 all

00:14:20.000 --> 00:14:26.860
printed out let's go ahead and do this

00:14:32.520 --> 00:14:40.480
so let's give it an endl
and std, colon colon, cout and so 54

00:14:54.480 --> 00:15:01.340
321 and it's here 5432 there
you go, so does indeed delete the last

00:15:01.340 --> 00:15:09.270
element. Ok that would be it as far as the
vectors in concern here very very very

00:15:10.070 --> 00:15:16.660
similar to arrays, they function in a different way, they are

00:15:16.660 --> 00:15:20.770
more expensive to use in terms of system
resources but you know a lot of

00:15:20.770 --> 00:15:24.282
situations they are
worth it if you they

00:15:24.307 --> 00:15:27.610
have a dynamic size
so it's not like

00:15:27.710 --> 00:15:29.867
the arrays when you need
to have like one fixed

00:15:29.892 --> 00:15:31.740
size and that it cannot
change it is one

00:15:31.840 --> 00:15:36.400
and it should always have that size and
you might wonder why would be able to

00:15:36.400 --> 00:15:40.290
use arrays? and why don't we
always use vectors? Well as I said the

00:15:40.290 --> 00:15:41.540
vectors are not

00:15:41.540 --> 00:15:46.940
as cheap in terms
of system resources as the arrays and

00:15:46.940 --> 00:15:49.940
sometimes you want to have certain
things which are immutable

00:15:51.370 --> 00:15:56.709
wherever you can use array, if you
cannot use an array ok find go to

00:15:56.709 --> 00:16:01.880
vectors. Anyway bet your farewell and
we shall see each other in the next

00:16:01.880 --> 00:16:02.880
tutorial.