WEBVTT

00:00.210 --> 00:01.350
Dar una buena acogida.

00:01.350 --> 00:04.370
Hoy vamos a divertirnos un poco.

00:04.440 --> 00:10.900
Vamos a seguir adelante y jugar con el algoritmo de cifrado básico, así que vamos a escribir uno.

00:10.980 --> 00:19.980
Un programa más que encriptará archivos usando el primitivo escribió el 13 algoritmo Aro the 13 significa rotate

00:19.980 --> 00:28.920
13 y se basa en rotar las letras del alfabeto inglés para 13 lugares ya que el alfabeto

00:28.920 --> 00:33.420
tiene 26 letras y la rotación es circular.

00:33.510 --> 00:38.770
Cada carta está envuelta con la letra que está a 13 lugares de distancia.

00:38.910 --> 00:40.550
¿Qué quiero decir con esto?

00:40.560 --> 00:56.250
Bueno, si tiene veintiséis letras en digamos la sexta y sexta letra, dice que está rotada en 13

00:56.250 --> 00:56.920
espacios.

00:57.090 --> 00:58.750
¿Cómo seguirías desde aquí?

00:58.770 --> 01:07.770
Bueno, simplemente comenzaría de una zy luego a B y así sucesivamente hasta llegar a 13 y luego esa

01:07.770 --> 01:11.290
sería la rotación de un conjunto de letras.

01:11.310 --> 01:21.960
Así que solo te pondrías frente 26 Simplemente se reiniciaría y funcionaría como dije que es circular de todos modos.

01:22.290 --> 01:24.260
Solo las letras serán intercambiadas.

01:24.270 --> 01:28.160
Otros personajes permanecerán cambiados.

01:28.190 --> 01:36.960
Este es un cifrado mucho más primitivo que el método que usé en el registrador de teclas.

01:36.960 --> 01:44.400
En realidad, el registrador de claves básicamente tiene una encriptación unidireccional personalizada que tiene un cifrado síncrono

01:44.400 --> 01:51.270
personalizado básicamente porque usa el algoritmo base 64 que realiza el proceso de codificación y

01:51.270 --> 01:54.290
luego hemos oscurecido el proceso de codificación.

01:54.600 --> 02:01.170
Y al hacerlo, lo encriptamos, creemos que podemos crear nuestras propias claves, sin

02:01.170 --> 02:05.750
las cuales, de todos modos, no sería posible decodificarlas.

02:06.260 --> 02:14.010
Avancemos y eliminemos esto por el momento, ya que escribiremos algo completamente

02:14.010 --> 02:14.820
diferente.

02:14.910 --> 02:22.880
Nuevamente jugaremos alrededor de ese archivo, por supuesto, y sigamos adelante y creamos una función como antes.

02:22.880 --> 02:24.410
Sigamos adelante y prototipo.

02:24.530 --> 02:25.930
Vamos a escribirlo.

02:25.940 --> 02:37.970
El tipo de retorno será una cadena y mostraremos que será a 13 c la cadena s.

02:38.260 --> 02:38.550
DE ACUERDO.

02:38.570 --> 02:43.370
Así que hemos protegido allí y sigamos adelante y crearemos el cuerpo abajo.

02:43.370 --> 02:49.930
Avancemos e implementemos.

02:50.000 --> 02:51.070
Aquí vamos.

02:51.110 --> 02:55.880
Entonces, crearemos un bucle for.

02:55.970 --> 02:59.720
Así que tenga en cuenta que no estamos usando algo que está integrado en C ++.

02:59.840 --> 03:02.380
Esto solo son los algoritmos, entonces necesitamos escribirlo.

03:02.510 --> 03:06.760
Así que tenemos que escribir este algoritmo, quiero decir que sí existe, puede

03:06.770 --> 03:11.300
echar un vistazo a la cama, etc. pero aún necesita implementar el algoritmo que necesita para escribirlo.

03:11.330 --> 03:14.630
Así que crearemos un bucle For Each.

03:15.440 --> 03:22.870
C será una referencia que significa que los cambios se aplicaron para verse o reflejarse en una cadena.

03:23.060 --> 03:28.770
S Déjame mostrártelo quizás sea más simple así.

03:28.770 --> 03:29.540
Por supuesto.

03:29.920 --> 03:37.300
Y el signo de pre-envío Vea los puntos con la esperanza de que ya sepa cómo funciona cada bucle.

03:39.420 --> 03:44.010
Y vamos a necesitar hacer el soporte necesario.

03:44.010 --> 03:49.420
No, en realidad no podemos simplemente escribir la declaración if porque aquí solo hay una declaración if.

03:52.320 --> 03:53.070
Venga.

03:53.210 --> 03:54.450
Sí, vamos.

03:54.450 --> 03:55.380
Así que

03:57.920 --> 04:02.360
Percey lo siento por C mayor o igual a un

04:07.950 --> 04:09.170
porcentaje y porcentaje.

04:09.170 --> 04:13.190
Y entonces ambas condiciones deben ser satisfechas.

04:13.460 --> 04:18.780
Y C es un conjunto menor o igual que el que tenemos que

04:22.810 --> 04:25.300
usar también para las letras mayúsculas.

04:25.300 --> 04:35.260
Entonces crearemos el enunciado de orden aquí C es mayor o igual a a porque como C ++ es extremadamente sensible, sigue

04:35.790 --> 04:41.550
diciendo extremadamente que no existe tal cosa que distinga entre mayúsculas y minúsculas

04:44.210 --> 04:48.570
o que no distinga mayúsculas y minúsculas del capital establecido.

04:50.380 --> 04:50.980
DE ACUERDO.

04:51.020 --> 04:52.130
Aquí vamos.

04:52.160 --> 04:55.370
Entonces, si C es una carta, estamos revisando.

04:55.400 --> 04:56.560
Entonces, ¿qué es qué?

04:56.600 --> 05:05.120
Esta línea completa de código básicamente verifica si C es una letra o no.

05:05.240 --> 05:06.480
¿Cómo está haciendo eso?

05:06.740 --> 05:14.090
Bueno, está comprobando que el valor de la letra c es mayor o igual que la letra A o que

05:14.120 --> 05:18.470
es una letra o igual a la letra que establece estas letras.

05:18.470 --> 05:21.470
Ellos tienen sus representaciones ASCII.

05:21.470 --> 05:29.510
Así que esto es que de alguna manera el signo mayor o igual realmente se aplica aquí o si

05:29.600 --> 05:38.070
es mayor que igual a mayúscula y es el menor o igual al conjunto y así es como se evalúa.

05:38.150 --> 05:42.850
Entonces, si ve si la deja, entonces realice una acción siguiente.

05:42.890 --> 05:48.770
De lo contrario, no obtengas los bloques de código Come.

05:48.770 --> 05:50.530
Por que me estas haciendo esto.

05:50.530 --> 05:51.850
He sido cruel contigo.

05:53.620 --> 05:54.630
DE ACUERDO.

05:54.950 --> 05:59.460
Entonces, si me invitaron, los coloqué aquí.

06:03.400 --> 06:08.580
Esto no tiene nada que ver con el código que estoy haciendo ahora, esto es puramente mi manera de escribir las cosas.

06:08.650 --> 06:28.520
Por lo tanto, si C es menor que un 13 o más, o si C es menor, entonces el capital es más 13.

06:28.530 --> 06:40.170
Así que mira esto es decir si C es menos que un más 13 si C es menor que un más 30

06:40.260 --> 06:47.780
así que si en la primera mitad las letras A M o a m

06:50.520 --> 06:59.360
significan mayúsculas o minúsculas minúsculas c será igual a C más C más 13 suma 13.

06:59.810 --> 07:01.780
No estamos agregando nada aquí.

07:01.790 --> 07:03.440
Esto es solo una evaluación.

07:03.440 --> 07:06.580
Tenga en cuenta que, de

07:10.210 --> 07:15.450
lo contrario, C es igual a C menos 30.

07:15.490 --> 07:17.190
Entonces, debemos conservarlo si necesitamos conservarlo.

07:17.250 --> 07:19.170
Mantenemos el patrón circular.

07:19.180 --> 07:20.390
De lo contrario, va a funcionar.

07:20.620 --> 07:25.490
De lo contrario, saldrá del alcance del que hablé.

07:26.310 --> 07:31.380
Recuerdo lo que dije al 26 26 26.

07:31.390 --> 07:39.220
Si agrega 26 letras a 13 13 espacios, se saldrá del alcance, lo que no es algo

07:39.220 --> 07:41.340
que queremos que suceda.

07:43.050 --> 07:45.150
Entonces queremos que queremos ser.

07:45.180 --> 07:46.120
Queremos estar perdidos.

07:46.200 --> 07:48.310
Queremos estar jugando dentro del alcance.

07:48.330 --> 07:50.930
Queremos mantenerlo circular.

07:50.940 --> 08:01.110
De todos modos, continuemos y leamos ther y S y más adelante realmente necesitaremos implementar esta función y escribir un programa

08:01.140 --> 08:06.750
que en realidad incite al usuario a ingresar algo que quiera y

08:06.750 --> 08:08.970
luego cuando termine la entrada.

08:11.550 --> 08:19.230
El programa realmente encriptará la entrada y la guardará en un archivo con un nombre definido por el usuario.

08:19.230 --> 08:21.840
Ahora eche un vistazo a este algoritmo aquí.

08:21.840 --> 08:22.520
Esto es básico.

08:22.530 --> 08:24.900
También puedes encontrarlo básicamente en la red.

08:24.900 --> 08:28.310
No es muy difícil de encontrar.

08:28.380 --> 08:31.460
Personalmente no lo es, no lo usaría realmente en ninguna parte.

08:31.650 --> 08:34.550
Sin embargo, solo quería otro.

08:34.770 --> 08:37.230
Solo quiero mostrártelo porque es extremadamente simple.

08:37.230 --> 08:41.910
Es mucho más simple que la base 64 y el proceso de ocultamiento al que fuimos en

08:43.340 --> 08:48.320
la sección de captura de teclas para que usted pueda comprender mejor cómo funciona este proceso antes de

08:48.740 --> 08:50.210
pasar a algo más complejo.

08:50.210 --> 08:53.420
Así que una vez más solo para recapitular de esta función.

08:54.190 --> 09:03.070
Así que pasamos una cuerda y pasamos una especie de cuerda y luego colocamos esa cuerda en a para cada ciclo aquí.

09:04.840 --> 09:11.340
Esto está cargando cosas para la masa y luego está verificando, entonces está verificando a través de las

09:11.350 --> 09:16.820
declaraciones IF básicamente diciendo que si C es mayor o igual o menor que eso.

09:16.870 --> 09:17.540
Y así.

09:17.590 --> 09:19.700
Y lo mismo se aplica a las letras mayúsculas.

09:19.840 --> 09:26.350
Entonces, si está comprobando una vez que toma las cosas del hilo de la cadena, está comprobando si ha

09:26.350 --> 09:27.920
recibido una carta o no.

09:27.970 --> 09:36.220
Si en el caso de que se haya tomado una carta en caso de que sea una carta,

09:36.220 --> 09:44.670
entra en un segundo enunciado si abajo donde verifica donde el C es menor que un más 13.

09:44.890 --> 09:53.200
O C es Lessard y capital a más 13 porque no queremos salir del alcance y luego dice OK C

09:53.230 --> 09:55.960
es igual a C más 13.

09:56.020 --> 09:59.790
De lo contrario, si es menor que eso OK, entonces vete entonces.

09:59.800 --> 10:05.130
Si es mayor que eso, entonces ve c menos 30.

10:05.170 --> 10:08.850
Eso es básicamente cómo funciona para que no salga de los límites.

10:08.850 --> 10:16.830
Así que, de todos modos, sigamos adelante y reviva esto.

10:16.860 --> 10:19.720
De acuerdo, déjalo como está y regresa al principal.

10:19.960 --> 10:31.050
Ahora, en general, si no vamos a hacer nada especial aquí, habrá texto en cadena

10:31.200 --> 10:42.190
y una cadena y la puerta de acceso de archivo C D C fuera.

10:42.190 --> 10:45.940
Por lo tanto, estas son tres cadenas que parecen tener texto s

10:49.100 --> 10:51.780
en la ruta del archivo debe ser así.

10:51.940 --> 10:55.140
Ingrese el texto

10:58.700 --> 11:05.960
uno a tres en su línea.

11:06.290 --> 11:17.650
Y entonces esta será la terminación de las tres, las tres, las tres, la ciencia principal y el programa

11:17.650 --> 11:19.170
de instructor.

11:19.170 --> 11:20.160
Ok. Ya terminé.

11:20.160 --> 11:21.180
Adelante un

11:29.720 --> 11:30.360
sobre encriptado.

11:30.370 --> 11:31.760
Necesitamos un bucle

11:32.170 --> 11:34.700
Mientras el ímpetu esté bien.

11:34.780 --> 11:39.690
Y durante ese proceso, guarde la entrada usando la función getline.

11:40.090 --> 11:45.830
Por lo tanto, siempre que la entrada sea válida solo siga adelante y siga almacenando, no se detenga.

11:45.840 --> 11:55.750
Esto es una bonita Esto básicamente es un ciclo infinito hasta que terminamos realmente con nosotros mismos.

11:58.250 --> 11:58.820
Mientras que

12:01.810 --> 12:06.230
las enfermedades de transmisión sexual por así decirlo, pero lo hacen con un grano de sal.

12:06.410 --> 12:11.790
Obtener la línea b c n s.

12:11.810 --> 12:19.200
De acuerdo, algunas noticias viejas de que tendremos que escribir una declaración IF.

12:19.690 --> 12:25.340
Probablemente no necesitó estos corchetes por un tiempo, pero realmente no importa.

12:25.330 --> 12:31.510
Como me verá a menudo, no los uso porque es solo una línea debajo del

12:31.510 --> 12:38.230
ciclo, pero realmente recomiendo que casi siempre los use para evitar errores solo para evitar futuros errores.

12:38.260 --> 12:51.460
Entonces, si S no es igual a tres signos menos si el usuario ingresa los lados menos en una nueva línea

12:51.460 --> 12:55.420
significa el final de la entrada.

12:55.450 --> 12:58.180
Entonces IPN hace lo siguiente.

12:58.180 --> 13:10.360
Entonces, si no es igual a eso, solo ingrese texto más igual a s Más línea nueva.

13:10.750 --> 13:14.800
Entonces, si no, solo agrega la entrada al texto.

13:14.800 --> 13:17.640
Básicamente, desea agregar la entrada a la

13:20.850 --> 13:21.660
siguiente línea.

13:21.690 --> 13:28.380
Entonces, si en realidad es igual a tres signos negativos, entonces quiero que rompas el descanso.

13:28.410 --> 13:33.840
Así que aprendimos la sentencia break the break porque ya he hablado de break y sabes lo que

13:33.840 --> 13:34.170
hace.

13:34.200 --> 13:39.670
Entonces, si no es igual a tres signos negativos, está bien.

13:39.720 --> 13:42.890
Cada vez que pasa el bucle solo entra en la nueva línea.

13:43.870 --> 13:48.590
El otro descanso simplemente se rompe.

13:50.950 --> 13:51.370
Excelente.

13:51.370 --> 13:57.620
Una vez hecho esto, una vez que hayamos terminado, queremos que el usuario ingrese el nombre del

13:57.700 --> 14:02.970
archivo, lo que significa que debe archivar la ruta de acceso de una ciudad.

14:02.980 --> 14:09.820
Así que queremos tener múltiples entradas para ingresar el

14:12.870 --> 14:28.040
nombre del archivo Hey. Y vamos a necesitar una línea regular aquí, una C D C en el archivo.

14:28.340 --> 14:33.830
Así que ingrese el nombre del archivo y usted, por supuesto, si, por supuesto, se le

14:33.830 --> 14:39.730
da la oportunidad de ingresar también en la ruta del archivo a través del nombre del archivo.

14:40.210 --> 14:45.590
Un archivo de flujo constante.

14:45.830 --> 14:53.900
Hemos hecho esto en la ruta anterior de Tauriel y el archivo que simplemente colocará aquí la cadena como una variable

14:54.920 --> 14:59.330
de cadena variable, así que abriremos y abriremos este archivo para escribir.

14:59.330 --> 15:01.140
Ahora, ¿qué tenemos que hacer una vez que abrimos un archivo?

15:01.190 --> 15:03.980
Una vez que tratamos de abrir un archivo para escribir.

15:03.980 --> 15:14.150
Bien, o por cierto, si especificas un usuario, también puedes especificar una ruta a la que ese usuario en particular no

15:14.150 --> 15:17.220
tiene derecho a crear un archivo.

15:17.390 --> 15:21.650
Y luego vas a obtener un error o incluso peor, no obtendrás

15:21.650 --> 15:27.590
nada en el programa que vamos a pasar y terminarás pensando que hiciste algo, pero en

15:27.680 --> 15:31.200
realidad no hiciste nada porque eras denegó los permisos apropiados.

15:32.710 --> 15:36.160
Es por eso que vamos a seguir adelante y ir a lo seguro.

15:36.160 --> 15:37.630
Vamos a

15:41.530 --> 15:43.760
ver si el archivo.

15:44.060 --> 15:51.350
Entonces, si esto sucede, continúe y cree una impresión para nosotros.

15:51.360 --> 15:53.150
Pero de depuración aquí.

15:55.200 --> 15:57.070
Error.

15:57.840 --> 16:01.690
Y no a la derecha.

16:01.740 --> 16:06.050
Y luego imprima el archivo.

16:06.690 --> 16:14.430
El usuario definió la ruta del archivo en la pantalla para que sepamos dónde el usuario intentaba

16:14.490 --> 16:15.100
escribirla.

16:15.150 --> 16:17.880
Y basado en eso, podemos resolverlo.

16:18.340 --> 16:18.970
DE ACUERDO.

16:19.260 --> 16:21.740
Así que abajo.

16:22.610 --> 16:27.430
Si esto sucede el tercero.

16:28.210 --> 16:30.990
Entonces hay un error.

16:30.990 --> 16:35.340
Entonces, el principal salido sería el estado que no es igual a cero.

16:35.430 --> 16:41.400
Entonces sabemos que hubo un problema que la operación que el programa ejecutó sin éxito.

16:41.790 --> 16:42.770
DE ACUERDO.

16:43.070 --> 16:56.260
Hisle se levantó 13 y vamos a escribir el texto aquí, así que este texto es la variable que hemos definido

16:56.320 --> 16:56.970
aquí.

16:56.980 --> 17:06.640
Y básicamente estamos insertando básicamente insertando en él, como puede ver, el texto es básicamente la

17:06.640 --> 17:14.430
cadena que se le agrega y la nueva línea para cada iteración.

17:14.490 --> 17:15.090
Aquí vamos.

17:15.090 --> 17:17.490
Y eso pasará a la función.

17:17.510 --> 17:23.620
RATH 13 cadena de texto de cadena de texto se le pasará como una variable.

17:24.810 --> 17:31.230
Entonces llamaremos a la función y almacenaremos sus resultados en un archivo y luego vamos a seguir

17:31.230 --> 17:39.150
y cerrar el archivo que se cierre, ya que puede ver que en realidad estamos llamando a la función y su

17:39.150 --> 17:42.580
valor de retorno está siendo almacenado en un archivo.

17:42.780 --> 17:48.380
Así que sigamos adelante y construyamos y ejecutemos este programa y veamos cómo funciona realmente bien.

17:48.830 --> 17:50.070
Un poco de error aquí.

17:52.770 --> 17:53.030
DE ACUERDO.

17:53.030 --> 17:56.140
Entonces ingrese texto.

17:56.280 --> 18:02.550
No sé thraw la la la la.

18:03.890 --> 18:04.410
&nbsp;

18:07.650 --> 18:08.300
&nbsp;

18:11.070 --> 18:15.950
Tess Tess vete.

18:16.760 --> 18:17.860
Y tres signos menos.

18:17.900 --> 18:23.760
Y allí vamos inmediatamente después de eso en tres signos menos dice Y tercero, el nombre del archivo que

18:23.840 --> 18:28.900
el nombre del archivo debe tener está en 13 y se guardará en la carpeta actual.

18:30.450 --> 18:32.020
Pulse cualquier tecla para continuar.

18:32.240 --> 18:36.930
OK, vamos a abrirlo.

18:37.220 --> 18:38.630
Eso no es

18:42.210 --> 18:46.370
correcto para perderse 13 Dirigo realmente lo ha creado.

18:46.500 --> 18:54.820
Ábrelo con el Bloc de notas y allí se ve cómo esto no se ve como lo que ejecutamos, lo que estábamos

18:54.850 --> 18:55.950
escribiendo está completo.

18:56.110 --> 19:03.280
Está completamente oscurecido, pero los personajes que no son de cuero, los que no son de escalera, los símbolos que

19:03.280 --> 19:05.800
no son letras, siguen siendo los mismos.

19:05.800 --> 19:11.420
Permanecen alterados sin cambios y completamente tocados.

19:11.660 --> 19:16.540
Así que gracias por seguirme.

19:16.630 --> 19:23.050
Espero que haya disfrutado el curso hasta el momento y hágamelo saber si desea que cubra algunos

19:23.140 --> 19:25.630
temas y temas adicionales para usted.

19:25.660 --> 19:27.430
Les digo adiós.
