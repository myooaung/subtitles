WEBVTT

00:00:00.000 --> 00:00:03.656
Welcome back all. So we're
just gonna go ahead

00:00:03.681 --> 00:00:07.089
and continue with
loops, let me just go

00:00:07.089 --> 00:00:09.809
ahead and switch my
notes to the other

00:00:09.834 --> 00:00:12.320
screen, generally what you just

00:00:12.320 --> 00:00:16.920
saw now this is switching between
screens one another when you pop this

00:00:16.920 --> 00:00:19.465
just gotta bursts
into all the windows

00:00:19.490 --> 00:00:22.010
that are currently
open on this desktop

00:00:22.010 --> 00:00:24.900
I only have one and
on the other I have

00:00:24.925 --> 00:00:27.539
like 10 million of them open.
So anyway

00:00:27.539 --> 00:00:33.890
sometimes in regard to the loops I do
believe that I haven't written now this is

00:00:33.890 --> 00:00:36.466
a while loop, sorry so
anyway sometimes it

00:00:36.491 --> 00:00:38.899
is necessary for the
loop to executes at

00:00:38.899 --> 00:00:41.795
least once, regardless
of the condition

00:00:41.820 --> 00:00:44.170
and that is why we
need the do while loop

00:00:44.170 --> 00:00:47.170
which is fairly similar to the while loop

00:00:47.770 --> 00:00:50.116
let me just enlarge
it for you a little

00:00:50.141 --> 00:00:52.459
bit, for example say
we want our program to

00:00:52.559 --> 00:00:58.399
prompt the user to enter a positive
number if the User does not enter a

00:00:58.399 --> 00:01:00.251
positive number we
want to prompt the

00:01:00.276 --> 00:01:02.149
user to enter it
again and again and

00:01:02.149 --> 00:01:04.782
again and again until
the user actually

00:01:04.807 --> 00:01:07.530
enters a positive
number once the user

00:01:07.530 --> 00:01:14.090
enters a positive number, the program
output it's the program will outputted

00:01:14.090 --> 00:01:18.540
square value but in general the loop
will terminate as well so it will no

00:01:18.540 --> 00:01:21.158
longer be prompting
the user to enter a

00:01:21.183 --> 00:01:23.620
number, so how would
we achieved this? so

00:01:23.720 --> 00:01:28.320
we want, we need this prompts to
happen at least once and if there is a

00:01:28.320 --> 00:01:34.340
wrong input we wanted to repeat itself
but no matter what we want this problem

00:01:34.340 --> 00:01:36.961
to happen at least once,
so to the user be

00:01:36.986 --> 00:01:39.439
asked to enter a
positive number we want

00:01:39.439 --> 00:01:41.675
you for this purpose
we will want to use

00:01:41.700 --> 00:01:43.619
a loop that executes
at least once as I

00:01:43.619 --> 00:01:45.528
said regardless of the
condition, why once?

00:01:45.553 --> 00:01:47.680
well, because we
want to let the user

00:01:47.680 --> 00:01:50.120
enter the number
regardless as I've stated,

00:01:50.145 --> 00:01:52.759
so if the number
is positive, then

00:01:52.759 --> 00:01:55.121
the loop stops
executing otherwise it

00:01:55.146 --> 00:01:57.380
will repeat the process
until the user

00:01:57.380 --> 00:02:00.935
gives a positive number
or until the user goes

00:02:00.960 --> 00:02:04.490
mad and exit stick and
exit the program so

00:02:04.490 --> 00:02:07.960
the pseudocode for this will look
something like this pk,

00:02:10.050 --> 00:02:17.950
So you will have a do for the loop and then
you will have I don't know X will this

00:02:19.250 --> 00:02:23.936
this is a stupid way of me
writing it now, but get

00:02:23.961 --> 00:02:28.850
number the function of
some sort so we will be

00:02:28.950 --> 00:02:36.480
placing some sort of a number into an X which will be a condition, so you

00:02:36.480 --> 00:02:41.360
will notice that the condition will go
at the end so while and then you will

00:02:41.360 --> 00:02:42.680
have the condition

00:02:42.680 --> 00:02:45.338
down below the condition
will be that the

00:02:45.363 --> 00:02:47.840
XP a positive number
so we will input

00:02:47.940 --> 00:02:52.710
something into X and the
condition will be evaluated whether it

00:02:52.710 --> 00:03:00.580
is a positive number or not so let's
write this in a way

00:03:00.580 --> 00:03:03.465
that's more
understandable for you at

00:03:03.490 --> 00:03:06.350
this point in time,
let's type it, this

00:03:06.350 --> 00:03:13.730
will be there will be a block of code
here and here you will have condition

00:03:13.730 --> 00:03:16.367
and one key difference
is that we will

00:03:16.392 --> 00:03:19.489
need a semicolon at
the end so there is

00:03:19.489 --> 00:03:24.750
a semicolon here remember that
regardless of whether we

00:03:24.750 --> 00:03:28.021
place no semicolons
here or for any other

00:03:28.046 --> 00:03:31.020
loops there is one
here, key difference.

00:03:31.020 --> 00:03:34.890
So there's a block of code and then
there was a condition which is being

00:03:34.890 --> 00:03:38.602
evaluated down below,
so let's go ahead

00:03:38.627 --> 00:03:42.459
and see how can we
make this work, we can

00:03:42.459 --> 00:03:46.945
delete the code and
we're not going to

00:03:46.970 --> 00:03:51.430
need most of this, let's
just go ahead and

00:03:51.430 --> 00:03:54.407
deleted all the way
up so we will need

00:03:54.432 --> 00:03:56.670
in 10 that there will
be an integer that

00:03:56.670 --> 00:04:04.310
will be declared here and immediately
down below we will jump into writing a

00:04:04.310 --> 00:04:06.969
do while loop so let's
go ahead and type

00:04:06.994 --> 00:04:10.060
in do and here we
will type in std,

00:04:10.060 --> 00:04:12.630
colon colon, cout

00:04:12.630 --> 00:04:20.578
enter natural number n.
std, colon colon,

00:04:27.303 --> 00:04:35.300
cin, n. Excellent so
we have the first part

00:04:40.800 --> 00:04:46.680
which basically prints out into the screen and it states

00:04:46.680 --> 00:04:49.418
enter a natural number n.

00:04:49.443 --> 00:04:54.970
so whatever that might
be just enter it

00:04:55.070 --> 00:05:01.590
and then the user will be given away off
inputting that number n which needs to be

00:05:01.590 --> 00:05:06.480
a natural number in order for this
loop to terminate and down below we will

00:05:06.480 --> 00:05:12.190
enter a condition, the condition
might be somewhat counterintuitive but I

00:05:12.190 --> 00:05:13.860
will explain in a moment

00:05:13.860 --> 00:05:18.651
lesser or equal to
0, so the condition

00:05:18.676 --> 00:05:22.440
is this one here it basically states

00:05:23.300 --> 00:05:26.353
repeat while not
natural number, well

00:05:26.378 --> 00:05:29.220
as long as the number
is not an actual

00:05:29.220 --> 00:05:31.987
number, keep on repeating
when we get to

00:05:32.012 --> 00:05:34.560
this point we are
certain that the user

00:05:34.560 --> 00:05:37.580
entered a positive number. why?

00:05:37.580 --> 00:05:43.220
well as long as the user keeps entering
something, keeps entering a zero or

00:05:43.220 --> 00:05:47.630
a negative number, this condition will
evaluate to true because if you enter

00:05:47.630 --> 00:05:53.130
minus one and is minus one is it that
less or equal to 0? it is less or equal

00:05:53.130 --> 00:05:55.960
to 0 much it's actually
less than zero, if you

00:05:55.985 --> 00:05:58.910
enter 0 is that less or equal to 0?
it's equal to

00:05:58.910 --> 00:06:01.414
0, so this one will
continuously keep

00:06:01.439 --> 00:06:03.150
on evaluating to true
and the loop will

00:06:03.250 --> 00:06:08.120
continue repeating itself but say you
enter a number ten or 1,4,5 or something

00:06:08.120 --> 00:06:13.300
like that, well in that case and will no
longer be lesser than or equal to 0

00:06:13.300 --> 00:06:18.420
therefore, the condition will become false
and the loop will terminate and at that

00:06:18.420 --> 00:06:20.909
point in time we are
certain absolutely

00:06:20.934 --> 00:06:23.550
certain that the user
entered a positive

00:06:23.550 --> 00:06:25.510
number whatever that might be

00:06:25.510 --> 00:06:29.475
ok so double. Ok so
there are obviously

00:06:29.500 --> 00:06:33.440
inherent flaws in
this you could within

00:06:33.440 --> 00:06:39.040
cover double floating point or
stuff like that but it doesn't matter

00:06:39.040 --> 00:06:45.400
I'm just giving you the general idea so
double as you sqrt

00:06:48.030 --> 00:06:53.320
yeah because it's like integer n and I
don't know you might confuse

00:06:53.320 --> 00:06:55.754
it by entering one
point something or

00:06:55.779 --> 00:06:58.470
stuff like that,
it's just gonna get

00:06:58.470 --> 00:07:01.210
the parts will just
get truncated in all

00:07:01.235 --> 00:07:03.950
likelihood and you
won't get what you

00:07:03.950 --> 00:07:06.765
expect I'm just confused
a little bit, anyway

00:07:06.790 --> 00:07:09.810
that that part doesn't
really matter at

00:07:09.810 --> 00:07:12.057
the time being, I just
want to explain the

00:07:12.082 --> 00:07:14.150
do while loop and its
logic so we will

00:07:14.250 --> 00:07:17.730
declare a variable double and we will
name it

00:07:17.730 --> 00:07:25.680
SQRT for like square root and we will
initialize the value of the variable a

00:07:27.680 --> 00:07:35.360
security underlined n to a std, colon colon, and we're going to use something

00:07:35.360 --> 00:07:39.730
different this time, we're
going to use a function and that's gonna

00:07:39.730 --> 00:07:45.320
be sqrt and we
should place n here,

00:07:45.345 --> 00:07:50.510
so this function will return it

00:07:50.510 --> 00:07:56.040
will actually compute the square root
and it will let down below we will print

00:07:56.040 --> 00:07:58.690
it out, so this function
will return the

00:07:58.715 --> 00:08:01.340
value, the equivalent
of this will be the

00:08:01.340 --> 00:08:05.370
square root defense so this entire
statement, will be the actual

00:08:05.370 --> 00:08:10.800
square root of n, which will be assigned to
this variable and it will be

00:08:10.800 --> 00:08:14.650
printed out we will deal with the
functions and all of that but I just

00:08:14.650 --> 00:08:17.334
wanted to throw it
in here a hint of

00:08:17.359 --> 00:08:19.840
what is to come
so let's go ahead

00:08:19.840 --> 00:08:22.840
std, cout,

00:08:23.490 --> 00:08:31.403
and let's go ahead and type in
sqrt, and we'll do this, this

00:08:32.228 --> 00:08:40.159
will look a little bit weird
but just take a look at it a

00:08:40.159 --> 00:08:45.089
couple of times and you will be able to
figure it out, I assure you it's not so

00:08:45.089 --> 00:08:50.089
difficult format, is not some complex format that I'm

00:08:50.089 --> 00:08:55.477
doing here but I'll
explain it anyway, and

00:08:55.502 --> 00:09:01.110
that's going to be std,
colon colon, endl.

00:09:01.110 --> 00:09:05.676
Ok so, if the cout
is the last line

00:09:05.701 --> 00:09:10.459
and you don't need
anything to be

00:09:10.459 --> 00:09:13.346
printed in the same
line, it's not a bad

00:09:13.371 --> 00:09:16.370
idea to put endl at
the end as it does

00:09:16.370 --> 00:09:22.970
flushes the buffer, anyway we
have cout so it's just this is going to

00:09:22.970 --> 00:09:27.170
be the text that is printed out onto the
screen and then we want to we have

00:09:27.170 --> 00:09:32.240
number n which will be printed out
onto the screen, that is the number

00:09:32.240 --> 00:09:34.767
that the user entered
and then we want

00:09:34.792 --> 00:09:37.020
to close the parenthesis
so you will get

00:09:37.020 --> 00:09:39.857
a printout on screen
something like this I

00:09:39.882 --> 00:09:42.930
guess, well I guess
but exactly like this

00:09:42.930 --> 00:09:50.770
sqrt some number n we'll be there
obviously an integer not the letter n and

00:09:50.770 --> 00:09:57.600
you see this parenthesis is here is
right here and the first parenthesis is

00:09:57.600 --> 00:10:01.849
here and the sqrt that
is this part it'll

00:10:01.874 --> 00:10:06.300
should go like this equal
and then they will

00:10:06.300 --> 00:10:11.660
be again some value here which will be
the square root of the number n which

00:10:11.660 --> 00:10:14.752
we have given, so the
printout will be in

00:10:14.777 --> 00:10:17.790
this format. Ok so
let's go ahead and run

00:10:17.790 --> 00:10:20.790
this program and see what becomes of it

00:10:21.550 --> 00:10:25.420
of course there is there is an error. Why
is there an error here?

00:10:25.420 --> 00:10:29.860
Well, we didn't include the library which
would enable the

00:10:29.860 --> 00:10:33.337
usage of these math
functions so let's

00:10:33.362 --> 00:10:36.950
go ahead and do that
right now include

00:10:36.950 --> 00:10:39.715
cmath, so see you
won't be able to

00:10:39.740 --> 00:10:42.910
actually use the math
functions that are

00:10:42.910 --> 00:10:47.850
available to you without including the
proper libraries, so the cmath

00:10:47.850 --> 00:10:51.170
is included here because they
would like to use the function for

00:10:51.170 --> 00:10:57.880
calculating the square root. Ok so let's
go ahead and try it again.

00:10:57.880 --> 00:11:02.279
Excellent, so enter a natural number, let's say -2

00:11:03.220 --> 00:11:06.989
it's gonna say again,
enter a natural number,

00:11:07.014 --> 00:11:10.620
so 0, again so let's
enter I don't know,

00:11:10.620 --> 00:11:13.908
let's enter number 9
and there you go, it

00:11:13.933 --> 00:11:17.470
says square root of
nine equals to 3 so I

00:11:17.470 --> 00:11:19.890
didn't include the space
down below when I

00:11:19.915 --> 00:11:22.149
was giving the example
but hey what can

00:11:22.149 --> 00:11:23.726
I do about it? So the
square root of 9

00:11:23.751 --> 00:11:25.540
is indeed 3, if you
don't believe me

00:11:25.540 --> 00:11:28.597
go ahead and check it
for yourself 3 times

00:11:28.622 --> 00:11:31.399
3 it's actually 9,
so let's close it.

00:11:31.399 --> 00:11:36.520
Let's run the program one more time
and let's go ahead and say that

00:11:36.520 --> 00:11:42.200
it's not a very nice number that we are
going to enter something like 1111

00:11:42.200 --> 00:11:48.660
so now it says that the
square root of 1111

00:11:48.685 --> 00:11:54.840
is 33.3317, it will
calculate it different,

00:11:54.840 --> 00:12:00.180
again if you don't believe me, take it a
calculator and or take it paper

00:12:00.180 --> 00:12:08.090
and pencil or a pen if you prefer and then

00:12:08.790 --> 00:12:11.703
go ahead and start calculating
or if you trust your

00:12:11.728 --> 00:12:14.420
calculator in your cellphone,
feel free to do it in that

00:12:14.520 --> 00:12:17.898
way as well. Anyway,
that will be it, in

00:12:17.923 --> 00:12:21.040
terms of the do while
loop next up will jump

00:12:21.140 --> 00:12:23.260
into for each loop.