WEBVTT

1
00:00:00.091 --> 00:00:02.025
Okay so, now

2
00:00:02.161 --> 00:00:03.986
that we know what logical

3
00:00:04.121 --> 00:00:05.946
and relational operators are,

4
00:00:06.081 --> 00:00:09.145
we can introduce conditions
and branching.

5
00:00:09.751 --> 00:00:11.080
So you have,

6
00:00:13.466 --> 00:00:15.275
you have if statements.

7
00:00:15.556 --> 00:00:17.165
This syntax is the following.

8
00:00:17.300 --> 00:00:17.976
So basically we type

9
00:00:18.111 --> 00:00:18.666
if

10
00:00:19.551 --> 00:00:21.706
and then you open a
paranthesis.

11
00:00:22.081 --> 00:00:24.795
You write out a
condition.

12
00:00:26.981 --> 00:00:29.045
condition
and depending on how,

13
00:00:29.511 --> 00:00:31.225
depending on what
that condition is.

14
00:00:31.361 --> 00:00:32.665
It can be an entire expression

15
00:00:32.801 --> 00:00:33.985
which needs to be
evaluated.

16
00:00:34.121 --> 00:00:35.265
It can simply be

17
00:00:35.501 --> 00:00:37.505
a number like 0 or 1.

18
00:00:37.641 --> 00:00:40.795
It can be true or false,
whatever.

19
00:00:41.471 --> 00:00:43.745
Based upon the evaluation
of that condition,

20
00:00:44.046 --> 00:00:45.491
you have something

21
00:00:45.626 --> 00:00:46.095
that happens.

22
00:00:46.231 --> 00:00:46.995
We have like

23
00:00:47.740 --> 00:00:48.301
code

24
00:00:48.436 --> 00:00:49.300
goes

25
00:00:49.435 --> 00:00:49.966
here

26
00:00:50.501 --> 00:00:52.475
So if the condition
is true,

27
00:00:52.846 --> 00:00:54.640
this code will be

28
00:00:54.775 --> 00:00:55.453
executed.

29
00:00:55.586 --> 00:00:57.325
Now of course
you

30
00:00:57.656 --> 00:01:00.860
can create like else
and else if, etc.

31
00:01:00.996 --> 00:01:03.530
You can create multiple
conditions depending

32
00:01:03.666 --> 00:01:04.345
on what happens.

33
00:01:04.481 --> 00:01:07.146
But I will show you that
in a moment.

34
00:01:07.281 --> 00:01:08.260
For the time being,

35
00:01:08.546 --> 00:01:10.083
I want to go with something else

36
00:01:10.220 --> 00:01:12.076
first with simpler things.

37
00:01:12.211 --> 00:01:12.786
So we'll need

38
00:01:12.921 --> 00:01:13.546
int x

39
00:01:13.681 --> 00:01:16.600
We will assign it a value of

40
00:01:16.971 --> 00:01:17.526
10

41
00:01:19.131 --> 00:01:20.296
and we shall

42
00:01:21.176 --> 00:01:22.590
redefine our condition here.

43
00:01:22.776 --> 00:01:24.605
We shall state that

44
00:01:25.006 --> 00:01:25.933
x is

45
00:01:26.096 --> 00:01:27.440
&gt;

46
00:01:29.046 --> 00:01:30.111
6

47
00:01:35.616 --> 00:01:36.150
Now

48
00:01:36.661 --> 00:01:38.610
I supposed you can see
it better like this.

49
00:01:39.520 --> 00:01:40.051
No big deal.

50
00:01:40.936 --> 00:01:42.565
I'm trying to find
an optimal way

51
00:01:42.700 --> 00:01:44.391
to write the code not

52
00:01:44.556 --> 00:01:45.625
for my own convenience

53
00:01:45.761 --> 00:01:47.346
but so that when you are
looking at it,

54
00:01:47.481 --> 00:01:50.536
you can see it in a
very clear way.

55
00:01:51.076 --> 00:01:52.473
Anyway so,

56
00:01:52.661 --> 00:01:54.175
code goes here,
okay.

57
00:01:54.311 --> 00:01:55.226
Let's play some codes.

58
00:01:55.361 --> 00:01:59.320
So this will be executed
if x is greater than 6.

59
00:02:00.371 --> 00:02:01.071
Let's type in

60
00:02:01.206 --> 00:02:02.386
std::

61
00:02:02.925 --> 00:02:05.430
cout

62
00:02:08.936 --> 00:02:09.701
X

63
00:02:10.886 --> 00:02:12.210
is

64
00:02:12.955 --> 00:02:13.951
greater

65
00:02:17.156 --> 00:02:18.340
than 6

66
00:02:20.176 --> 00:02:20.800
And

67
00:02:21.916 --> 00:02:22.386
I don't know.

68
00:02:22.521 --> 00:02:25.235
std::

69
00:02:27.651 --> 00:02:28.230
endl

70
00:02:29.650 --> 00:02:30.621
Let's play it out
like that.

71
00:02:32.411 --> 00:02:34.130
So if x is greater
than 6,

72
00:02:34.456 --> 00:02:36.753
this will be printed out
onto the screen.

73
00:02:37.150 --> 00:02:38.036
Here, you can even

74
00:02:38.171 --> 00:02:39.351
convince yourselves
with that.

75
00:02:39.941 --> 00:02:42.465
You see,
X is greater than 6.

76
00:02:43.976 --> 00:02:46.065
Change this to 1.

77
00:02:46.996 --> 00:02:47.966
Let's go ahead
and run.

78
00:02:48.596 --> 00:02:49.745
Oops, nothing happens

79
00:02:49.881 --> 00:02:52.425
because x is not
greater than 6.

80
00:02:53.661 --> 00:02:54.956
Okay, let's change it
back it then.

81
00:02:56.816 --> 00:02:58.308
Down below we can

82
00:02:58.441 --> 00:02:59.391
have

83
00:02:59.811 --> 00:03:00.465
another thing.

84
00:03:00.601 --> 00:03:01.853
Another way of
putting

85
00:03:02.016 --> 00:03:02.826
another

86
00:03:03.456 --> 00:03:04.590
if statement.
Let's just

87
00:03:04.990 --> 00:03:05.940
recycle this.

88
00:03:06.756 --> 00:03:07.845
And we can simply
state

89
00:03:08.961 --> 00:03:09.865
if 10

90
00:03:11.191 --> 00:03:13.325
type in, your 10
is also true.

91
00:03:18.411 --> 00:03:19.315
Okay obviously

92
00:03:19.526 --> 00:03:21.200
this is true.
Why?

93
00:03:21.336 --> 00:03:22.340
Well, as I said

94
00:03:22.475 --> 00:03:26.403
0 is false, anything above
0 is true.

95
00:03:26.536 --> 00:03:27.996
Is evaluated as true.

96
00:03:29.531 --> 00:03:30.155
Therefore,

97
00:03:30.696 --> 00:03:33.665
this will be the same as me
writing true here.

98
00:03:34.666 --> 00:03:37.935
Or any sort of a condition
being evaluated to true,

99
00:03:38.331 --> 00:03:42.035
this will be printed
out onto the screen, so.

100
00:03:42.171 --> 00:03:44.460
10 is also true,

101
00:03:44.926 --> 00:03:45.690
while yes.

102
00:03:47.851 --> 00:03:48.455
Who knew?

103
00:03:50.011 --> 00:03:50.590
However,

104
00:03:52.241 --> 00:03:53.011
there's a,

105
00:03:53.146 --> 00:03:54.560
here's a

106
00:03:55.886 --> 00:03:57.600
not going to call a
trick question but

107
00:03:58.395 --> 00:03:59.576
if - 4

108
00:04:03.341 --> 00:04:04.205
Let's put it like this.

109
00:04:04.340 --> 00:04:06.146
Let's recycle.

110
00:04:06.545 --> 00:04:08.841
Recycling is good for the
environment.

111
00:04:10.281 --> 00:04:11.371
So 10

112
00:04:12.675 --> 00:04:13.486
- 4

113
00:04:14.951 --> 00:04:15.946
and

114
00:04:16.946 --> 00:04:17.685
let's...

115
00:04:19.431 --> 00:04:22.385
Shall we say that
this is false?

116
00:04:22.521 --> 00:04:26.395
Shall I change it
right here to false?

117
00:04:26.676 --> 00:04:29.900
Or will it stay - 4
is also true?

118
00:04:30.321 --> 00:04:30.946
So what do you think?

119
00:04:32.110 --> 00:04:33.871
In your professional
opinion

120
00:04:34.316 --> 00:04:37.685
do you think that - 4
will be evaluated as true?

121
00:04:37.821 --> 00:04:40.721
Or will it be evaluated
as false?

122
00:04:41.746 --> 00:04:42.325
Think about it.

123
00:04:43.466 --> 00:04:45.835
It's actually a little bit
counter intuitive but

124
00:04:45.971 --> 00:04:47.685
if you build and run it,
you will see it,

125
00:04:47.876 --> 00:04:49.151
- 4 is also true.

126
00:04:49.386 --> 00:04:50.031
So,

127
00:04:50.686 --> 00:04:53.841
-4 actually evaluates
to true.

128
00:04:55.725 --> 00:04:58.251
I know it's a little
bit weird but

129
00:04:58.601 --> 00:04:59.411
no big deal.

130
00:05:01.041 --> 00:05:02.385
Okay so, you got if

131
00:05:05.731 --> 00:05:06.868
1.5

132
00:05:09.841 --> 00:05:10.955
And let's see what happens here.

133
00:05:15.251 --> 00:05:16.550
More recycling.

134
00:05:19.916 --> 00:05:21.170
1.5

135
00:05:22.006 --> 00:05:25.510
Do you think that
1.5 will also be true?

136
00:05:26.696 --> 00:05:27.461
So it's.

137
00:05:28.301 --> 00:05:29.135
1.5

138
00:05:30.531 --> 00:05:31.045
Well,

139
00:05:31.180 --> 00:05:32.501
I'm going to have
to rename this.

140
00:05:36.286 --> 00:05:38.351
Everything

141
00:05:38.495 --> 00:05:39.375
not

142
00:05:40.260 --> 00:05:42.191
zero is

143
00:05:42.326 --> 00:05:42.950
true.

144
00:05:43.881 --> 00:05:46.248
And that should answer

145
00:05:46.481 --> 00:05:49.106
this one and all the
future questions

146
00:05:49.241 --> 00:05:51.610
in regard to what sort
of numbers are

147
00:05:51.800 --> 00:05:53.956
evaluated as true. And what
numbers are

148
00:05:54.236 --> 00:05:55.055
evaluated

149
00:05:55.190 --> 00:05:55.890
as false.

150
00:05:56.026 --> 00:05:57.506
So everything not zero

151
00:05:57.641 --> 00:06:00.780
is true. Be it a - b, .b

152
00:06:01.296 --> 00:06:04.963
a positive number, it's really
not that important.

153
00:06:06.471 --> 00:06:08.095
So if I type in

154
00:06:08.610 --> 00:06:09.211
10

155
00:06:10.026 --> 00:06:11.720
is greater than

156
00:06:12.486 --> 00:06:13.041
5

157
00:06:17.561 --> 00:06:19.600
What do you think
this will be?

158
00:06:19.941 --> 00:06:22.935
Is 10 greater than 5?
Yes it is, so.

159
00:06:23.751 --> 00:06:24.490
True.

160
00:06:32.271 --> 00:06:34.125
Let me just scroll down
my notes a little bit.

161
00:06:35.101 --> 00:06:37.015
However, you see,

162
00:06:37.771 --> 00:06:39.985
this evaluates to true
and okay

163
00:06:40.121 --> 00:06:41.185
something happens here.

164
00:06:41.321 --> 00:06:42.586
And this evaluates to true.

165
00:06:42.721 --> 00:06:45.525
And something happens here
and so on and so forth.

166
00:06:45.991 --> 00:06:48.746
If I placed a zero here,
nothing would happen.

167
00:06:48.881 --> 00:06:50.615
The code would not,

168
00:06:50.751 --> 00:06:52.305
would not get executed.

169
00:06:52.541 --> 00:06:53.770
Here in fact let me,

170
00:06:54.491 --> 00:06:55.263
let me just

171
00:06:55.396 --> 00:06:57.306
be thorough and explain
that

172
00:06:57.441 --> 00:06:59.595
and demonstrate that real quick.

173
00:07:09.375 --> 00:07:11.556
Pointless

174
00:07:11.690 --> 00:07:12.740
text that

175
00:07:12.996 --> 00:07:13.970
will

176
00:07:15.806 --> 00:07:16.695
never

177
00:07:16.830 --> 00:07:17.361
be

178
00:07:17.966 --> 00:07:19.386
printed

179
00:07:19.521 --> 00:07:20.450
out.

180
00:07:23.586 --> 00:07:24.581
I just run it.

181
00:07:26.396 --> 00:07:26.926
You see,

182
00:07:27.115 --> 00:07:28.350
x is greater than 6.

183
00:07:28.486 --> 00:07:30.546
10 is also true.
- 4 is also true.

184
00:07:30.681 --> 00:07:31.640
Everything

185
00:07:31.781 --> 00:07:33.290
not zero is true.

186
00:07:33.661 --> 00:07:34.225
And

187
00:07:34.360 --> 00:07:34.891
true.

188
00:07:36.310 --> 00:07:37.816
Ah right,
10 &gt; 5

189
00:07:38.236 --> 00:07:39.580
And if zero, you see,

190
00:07:40.511 --> 00:07:42.955
Pointless text that will
never be

191
00:07:43.090 --> 00:07:44.016
printed out.

192
00:07:44.576 --> 00:07:45.115
Because

193
00:07:47.036 --> 00:07:49.610
this condition will not
change. It will remain zero.

194
00:07:50.151 --> 00:07:52.035
It's not a variable,
it's a constant

195
00:07:52.171 --> 00:07:54.186
and we have written
a number here.

196
00:07:57.626 --> 00:08:00.430
So, it evaluates the false
and nothing happens there.

197
00:08:00.991 --> 00:08:03.010
But now, we would like
to...

198
00:08:04.521 --> 00:08:07.351
Now, we would like to
have a way

199
00:08:08.795 --> 00:08:09.511
of

200
00:08:10.490 --> 00:08:11.440
actually

201
00:08:11.671 --> 00:08:12.838
doing something

202
00:08:12.971 --> 00:08:14.410
if the condition
is not true.

203
00:08:14.946 --> 00:08:16.506
So if it's true,
do one thing.

204
00:08:16.641 --> 00:08:20.060
If it's not true,
do another thing.

205
00:08:20.196 --> 00:08:24.045
That's the idea so I'm just
looking for the code to recycle.

206
00:08:24.721 --> 00:08:26.290
Yup, let's go ahead
and copy this one.

207
00:08:28.211 --> 00:08:31.855
So x is greater than 10.

208
00:08:32.661 --> 00:08:34.930
X is greater than

209
00:08:37.110 --> 00:08:38.136
10.

210
00:08:38.271 --> 00:08:40.230
But in case it is not,

211
00:08:40.536 --> 00:08:42.226
I would like to have an
else statement.

212
00:08:42.461 --> 00:08:44.023
Actually this is not

213
00:08:44.156 --> 00:08:46.105
in case it is not else.

214
00:08:47.431 --> 00:08:48.335
else if

215
00:08:49.221 --> 00:08:49.850
else if

216
00:08:49.986 --> 00:08:51.465
And then a condition
would be...

217
00:08:51.601 --> 00:08:53.905
and then to specify a
specific condition where

218
00:08:54.281 --> 00:08:56.545
x is not greater than 10

219
00:08:56.681 --> 00:08:57.620
would be

220
00:08:57.901 --> 00:08:59.455
more thorough way
of doing this.

221
00:08:59.761 --> 00:09:02.525
But if you write else
at the end, that means

222
00:09:02.661 --> 00:09:04.865
as long as this condition
is not true,

223
00:09:05.001 --> 00:09:08.350
else will be executed
no matter what.

224
00:09:10.581 --> 00:09:11.763
So, std

225
00:09:12.671 --> 00:09:14.875
no matter what,
but you had the idea.

226
00:09:16.156 --> 00:09:18.776
So if its effect is
for example

227
00:09:18.986 --> 00:09:23.443
= 10 or effects is lesser
than 10, else will be executed.

228
00:09:25.626 --> 00:09:28.900
But I will show you the
examples with else if as well.

229
00:09:29.201 --> 00:09:29.896
So no worries there.

230
00:09:30.571 --> 00:09:32.380
I don't know,
cout.

231
00:09:34.591 --> 00:09:35.593
Well, might as well
actually write it.

232
00:09:38.721 --> 00:09:41.621
x is

233
00:09:44.040 --> 00:09:44.686
x

234
00:09:44.946 --> 00:09:45.641
is not

235
00:09:47.431 --> 00:09:48.241
greater

236
00:09:49.126 --> 00:09:49.795
std

237
00:09:52.816 --> 00:09:53.628
New Entry 222

238
00:09:54.001 --> 00:09:55.045
::

239
00:09:55.720 --> 00:09:56.275
endl

240
00:10:01.476 --> 00:10:02.010
So

241
00:10:03.196 --> 00:10:05.285
This is going to
go ahead

242
00:10:05.495 --> 00:10:06.260
and happen

243
00:10:06.561 --> 00:10:07.821
in case x is

244
00:10:07.956 --> 00:10:08.865
not greater than 10.

245
00:10:09.001 --> 00:10:11.180
It can be equal or
it can be less than.

246
00:10:11.576 --> 00:10:12.488
But you can

247
00:10:12.621 --> 00:10:15.026
you can create this, so.

248
00:10:15.161 --> 00:10:17.450
You can cover multiple
conditions.

249
00:10:17.585 --> 00:10:19.941
in this fashion.

250
00:10:20.076 --> 00:10:23.075
However, let's take a look at
something

251
00:10:23.211 --> 00:10:25.903
and I'd like you to tell me
there is a

252
00:10:26.346 --> 00:10:28.456
if there is a mistake here. If this is
possible.

253
00:10:29.061 --> 00:10:30.060
Just take a look at it

254
00:10:30.246 --> 00:10:31.460
think about it and

255
00:10:31.595 --> 00:10:34.706
then come to a conclusion and then
I'll give you the answer.

256
00:10:34.841 --> 00:10:36.351
Pause the video if you must.

257
00:10:38.976 --> 00:10:40.181
Ok, so

258
00:10:43.806 --> 00:10:46.035
I'm just goign to go ahead and
use the same example here

259
00:10:48.171 --> 00:10:49.083
Then want to write

260
00:10:49.216 --> 00:10:51.010
a different example for each
one of this

261
00:10:51.145 --> 00:10:51.961
because it's fairly similar

262
00:10:52.096 --> 00:10:54.608
and if I write here
something randomly,

263
00:10:54.741 --> 00:10:56.065
int y

264
00:10:56.461 --> 00:10:57.970
is equals to

265
00:10:58.296 --> 00:10:58.898
10

266
00:11:00.176 --> 00:11:00.895
and

267
00:11:03.031 --> 00:11:03.775
then I just

268
00:11:04.241 --> 00:11:06.400
input this below.

269
00:11:07.445 --> 00:11:08.930
So, this is not going to work.

270
00:11:09.256 --> 00:11:10.578
If I compile

271
00:11:10.811 --> 00:11:11.436
Oops!

272
00:11:11.696 --> 00:11:13.596
Now it's reporting an error
immediately.

273
00:11:14.176 --> 00:11:14.755
If I just

274
00:11:15.246 --> 00:11:16.475
comment this out,

275
00:11:16.711 --> 00:11:17.866
and If I run it,

276
00:11:18.426 --> 00:11:19.285
Yup, it's fine.

277
00:11:19.541 --> 00:11:21.510
It's going to run
without any problems.

278
00:11:22.261 --> 00:11:24.645
So, you can't really place
anything in between these.

279
00:11:24.931 --> 00:11:28.990
You must keep them clear, one after
the other.

280
00:11:29.386 --> 00:11:30.175
no other way.

281
00:11:31.361 --> 00:11:33.286
you cannot just insert

282
00:11:33.681 --> 00:11:36.080
random things in between them.

283
00:11:37.001 --> 00:11:39.490
So, if we have only one statement,

284
00:11:39.626 --> 00:11:40.908
we can even ommit

285
00:11:41.041 --> 00:11:42.348
these curly brackets.

286
00:11:42.481 --> 00:11:43.616
So, basically

287
00:11:44.156 --> 00:11:45.370
for all these initial examples,

288
00:11:45.505 --> 00:11:49.750
the curly
brackets were completely unnecessary.

289
00:11:50.750 --> 00:11:52.675
if I type in,

290
00:11:54.741 --> 00:11:56.048
x

291
00:11:56.181 --> 00:11:56.628
is

292
00:11:56.761 --> 00:11:57.696
greater than

293
00:11:57.831 --> 00:11:58.340
2

294
00:12:00.616 --> 00:12:02.845
I can type in immediately std

295
00:12:03.611 --> 00:12:05.840
cout

296
00:12:08.301 --> 00:12:09.045
ok.

297
00:12:10.441 --> 00:12:13.255
x &gt; 2

298
00:12:15.385 --> 00:12:16.241
std

299
00:12:16.521 --> 00:12:17.726
::

300
00:12:18.241 --> 00:12:19.680
endl there we go. That's it.

301
00:12:20.561 --> 00:12:22.346
But if you have one more line,

302
00:12:22.481 --> 00:12:25.666
that needs to fall under
the if, or else statements,

303
00:12:25.801 --> 00:12:28.270
you will need the curly braces.

304
00:12:28.900 --> 00:12:30.360
If there is only one line,

305
00:12:30.871 --> 00:12:32.085
you do not require them.

306
00:12:32.220 --> 00:12:34.523
This is valid for both else and

307
00:12:34.656 --> 00:12:35.536
for if. You see,

308
00:12:35.795 --> 00:12:37.836
I can actually remove them here.

309
00:12:38.046 --> 00:12:38.555
and here.

310
00:12:39.116 --> 00:12:41.651
and I can run, build and compile.

311
00:12:41.786 --> 00:12:42.835
You see, it runs.

312
00:12:42.971 --> 00:12:44.600
It's all good.

313
00:12:45.780 --> 00:12:48.640
If there is one.
But if there is more than one,

314
00:12:48.775 --> 00:12:51.605
it might compile again. It probably
will compile

315
00:12:51.841 --> 00:12:54.546
but that something will not be
taken into consideration the way

316
00:12:54.681 --> 00:12:56.021
you want it to be taken

317
00:12:56.156 --> 00:12:59.506
into consideration. Depending on how
it is written. So it might compile or

318
00:12:59.641 --> 00:13:00.310
For example,

319
00:13:00.640 --> 00:13:01.335
If I have

320
00:13:02.056 --> 00:13:03.146
this line of code,

321
00:13:03.775 --> 00:13:06.400
and If I place it here,

322
00:13:06.606 --> 00:13:08.786
and even if I move it like this,

323
00:13:09.045 --> 00:13:12.361
This is going to build and compile
without any problems.

324
00:13:13.086 --> 00:13:13.826
But

325
00:13:15.336 --> 00:13:17.586
this will not fall under it.

326
00:13:17.961 --> 00:13:21.231
And if you saw here, if I put
something in between, if and else

327
00:13:21.421 --> 00:13:22.720
we're going to have problems.

328
00:13:26.135 --> 00:13:27.393
So, hopefully

329
00:13:27.526 --> 00:13:30.496
that part is clear to an extent.

330
00:13:31.685 --> 00:13:32.471
But

331
00:13:32.821 --> 00:13:34.026
you know, in case it is not,

332
00:13:34.331 --> 00:13:35.560
you're always more than

333
00:13:35.886 --> 00:13:37.053
welcome to

334
00:13:37.186 --> 00:13:38.045
ask questions.

335
00:13:38.466 --> 00:13:42.080
Now. let's go ahead and do something
different.

336
00:13:44.151 --> 00:13:45.241
Let's delete all of this

337
00:13:46.080 --> 00:13:47.320
We're not going to need it.

338
00:13:48.911 --> 00:13:49.585
and even this.

339
00:13:49.911 --> 00:13:52.891
We shall type in int age

340
00:13:54.021 --> 00:13:56.271
we will leave it uninitialized

341
00:13:56.991 --> 00:13:59.080
we will leave that to the user.

342
00:13:59.756 --> 00:14:00.405
cout

343
00:14:03.705 --> 00:14:05.305
Enter

344
00:14:07.491 --> 00:14:11.165
personal

345
00:14:12.156 --> 00:14:13.478
enter person's

346
00:14:14.291 --> 00:14:15.056
age.

347
00:14:16.681 --> 00:14:17.610
Fantastic!

348
00:14:19.331 --> 00:14:20.675
std ::

349
00:14:21.141 --> 00:14:23.040
cin

350
00:14:23.531 --> 00:14:24.205
age

351
00:14:25.066 --> 00:14:27.176
we're going to get some input
from the keyboard

352
00:14:28.086 --> 00:14:28.686
and

353
00:14:29.221 --> 00:14:29.891
now,

354
00:14:30.105 --> 00:14:31.866
I would like to

355
00:14:32.171 --> 00:14:34.033
give different outputs

356
00:14:34.166 --> 00:14:36.540
based on the age of
the person.

357
00:14:36.676 --> 00:14:39.480
So, the age of the person you know,
it can be, I don't know,

358
00:14:39.950 --> 00:14:40.535
if you can have

359
00:14:40.670 --> 00:14:42.700
three year old, you can have an
18 year old.

360
00:14:42.836 --> 00:14:44.870
You can have a 13 year old person,

361
00:14:45.011 --> 00:14:47.610
you can have a 30 year old person, you
can have a 50 year old person.

362
00:14:47.776 --> 00:14:50.696
Etc. so you will have a wide variety
of these conditions.

363
00:14:51.396 --> 00:14:54.371
and if and else are simply
not enough, you need more than that.

364
00:14:54.506 --> 00:14:56.060
So, if you type in if,

365
00:14:58.316 --> 00:15:00.496
age is

366
00:15:01.010 --> 00:15:03.631
&gt;= 18

367
00:15:04.516 --> 00:15:06.813
Let's say that this is considered an
adult person,

368
00:15:07.626 --> 00:15:08.515
I mean legally,

369
00:15:08.650 --> 00:15:10.240
it is.

370
00:15:10.971 --> 00:15:11.851
cout

371
00:15:13.410 --> 00:15:13.965
and

372
00:15:14.266 --> 00:15:15.195
I can say:

373
00:15:17.006 --> 00:15:18.840
Person is an

374
00:15:19.701 --> 00:15:20.535
adult.

375
00:15:21.280 --> 00:15:24.535
Unfortunately, you need to be
21 in the US to

376
00:15:24.671 --> 00:15:26.316
be legally buy alcohol.

377
00:15:26.831 --> 00:15:31.356
However, this is so untrue of my own
country, where you can be

378
00:15:31.845 --> 00:15:35.696
I think 16 or 18, something like that
I'm not sure. it's 18, I'm pretty sure.

379
00:15:36.766 --> 00:15:37.600
std

380
00:15:38.510 --> 00:15:39.420
::

381
00:15:39.555 --> 00:15:41.240
endl

382
00:15:42.826 --> 00:15:44.961
So, that's one

383
00:15:45.846 --> 00:15:48.160
but we, you know,

384
00:15:49.351 --> 00:15:52.625
but we cannot just place else and
for every other

385
00:15:52.926 --> 00:15:56.570
every other number that somebody
would enter for somebody's age

386
00:15:57.106 --> 00:15:58.080
I mean that would be,

387
00:15:58.686 --> 00:16:00.775
that would not be very
precise.

388
00:16:00.986 --> 00:16:02.676
So, instead we will use else, if

389
00:16:03.285 --> 00:16:04.420
We'll type in else if

390
00:16:04.701 --> 00:16:06.975
and now we will issue another
condition.

391
00:16:07.395 --> 00:16:08.460
So age

392
00:16:09.020 --> 00:16:10.921
if its' greater than

393
00:16:11.246 --> 00:16:12.175
13

394
00:16:14.801 --> 00:16:16.640
So, the first condition

395
00:16:17.076 --> 00:16:21.000
is false, that his age is less than
18.

396
00:16:21.675 --> 00:16:22.251
So,

397
00:16:22.626 --> 00:16:26.548
you see, if the person is like 15, or
16 or something like that,

398
00:16:26.781 --> 00:16:30.030
and is less than 18, it's not
equal to 18,

399
00:16:30.241 --> 00:16:31.291
it will jump

400
00:16:31.426 --> 00:16:33.886
it will jump into this condition

401
00:16:34.050 --> 00:16:35.216
here and

402
00:16:35.351 --> 00:16:35.906
then

403
00:16:36.041 --> 00:16:36.695
this code,

404
00:16:36.836 --> 00:16:39.881
it will check whether the age is
greater than

405
00:16:40.016 --> 00:16:40.711
13.

406
00:16:41.945 --> 00:16:44.240
And we shall type in std.

407
00:16:44.685 --> 00:16:45.450
cout,

408
00:16:46.961 --> 00:16:48.211
cout

409
00:16:49.071 --> 00:16:50.021
cout

410
00:16:53.761 --> 00:16:58.495
if Person is a teenager,

411
00:17:00.216 --> 00:17:00.750
Ok,

412
00:17:00.986 --> 00:17:03.305
so hopefully I spelled that right.
If I didn't, forgive me.

413
00:17:04.910 --> 00:17:06.625
::endl

414
00:17:06.881 --> 00:17:07.485
;

415
00:17:08.741 --> 00:17:12.685
and now we can practically give
an infinite amount of

416
00:17:13.060 --> 00:17:14.356
conditions down below.

417
00:17:14.755 --> 00:17:16.355
Type in else if

418
00:17:19.700 --> 00:17:21.075
age is

419
00:17:21.210 --> 00:17:22.111
greater than

420
00:17:22.255 --> 00:17:22.761
3

421
00:17:25.760 --> 00:17:26.571
So, yeah,

422
00:17:27.221 --> 00:17:28.845
if age is greater than 3,

423
00:17:30.471 --> 00:17:33.375
so, if this condition is false, and
if this condition is false,

424
00:17:33.841 --> 00:17:36.925
then go ahead and jump into
this condition here.

425
00:17:37.416 --> 00:17:38.526
And as I said, it can

426
00:17:38.856 --> 00:17:41.670
can have quite a lot of them
std::

427
00:17:41.806 --> 00:17:43.196
pretty much as you want

428
00:17:43.570 --> 00:17:45.640
I'm not aware of any limits

429
00:17:45.776 --> 00:17:47.536
there. There is probably a limit
somewhere.

430
00:17:49.376 --> 00:17:50.911
Person is a

431
00:17:51.046 --> 00:17:51.555
kid

432
00:17:54.530 --> 00:17:55.155
ok,

433
00:17:56.966 --> 00:17:58.590
std::

434
00:17:58.941 --> 00:17:59.781
endl;

435
00:17:59.916 --> 00:18:01.005
;

436
00:18:01.356 --> 00:18:03.630
and down below we will just type
in else,

437
00:18:03.911 --> 00:18:09.960
in case it's any other number that
doesn't fit in this range at all.

438
00:18:11.410 --> 00:18:14.981
I can just go ahead and type in
std

439
00:18:15.520 --> 00:18:16.676
::

440
00:18:18.050 --> 00:18:20.255
cout

441
00:18:24.526 --> 00:18:25.476
well, what do you think

442
00:18:26.501 --> 00:18:28.800
is the age of a person

443
00:18:29.080 --> 00:18:32.001
who's age is not greater or equal
to 18?

444
00:18:32.446 --> 00:18:36.113
It is not greater than 13,
it is not greater than 3,

445
00:18:37.506 --> 00:18:38.110
well,

446
00:18:38.785 --> 00:18:40.641
I'll give you one hint,

447
00:18:41.711 --> 00:18:42.360
it's a

448
00:18:42.501 --> 00:18:43.496
BABY

449
00:18:45.681 --> 00:18:49.556
Joyous news for some, sad for others,
depends, how you look at it.

450
00:18:50.046 --> 00:18:51.716
std::

451
00:18:52.021 --> 00:18:52.761
endl

452
00:18:55.176 --> 00:18:55.780
So, there you go.

453
00:18:56.896 --> 00:19:02.536
This is how you can split it out and
branch it to multiple conditions.

454
00:19:03.770 --> 00:19:04.556
You can have

455
00:19:05.486 --> 00:19:06.065
else

456
00:19:06.441 --> 00:19:10.266
if whatever and else if
for whatever again then else

457
00:19:10.401 --> 00:19:10.810
at the end to cover

458
00:19:10.945 --> 00:19:12.923
anything that you might have

459
00:19:13.056 --> 00:19:14.840
missed some general

460
00:19:15.125 --> 00:19:17.000
case what will happen.

461
00:19:17.281 --> 00:19:17.581
Anyway,

462
00:19:17.931 --> 00:19:19.146
I got to bid you farewell here

463
00:19:19.281 --> 00:19:22.205
and we will continue on the
follow up tutorial.

