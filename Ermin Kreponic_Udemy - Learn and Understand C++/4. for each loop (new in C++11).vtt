WEBVTT

00:00:00.000 --> 00:00:03.757
Welcome back all. So
today I am going to

00:00:03.782 --> 00:00:07.100
show you the for each loop.
What you see on

00:00:07.200 --> 00:00:09.619
the screen here are some
fairly new concept,

00:00:09.644 --> 00:00:11.709
let me just bring my
notes up to another

00:00:11.809 --> 00:00:15.488
screen. So first of
all, you have this an

00:00:15.513 --> 00:00:19.150
unknown this here
this is the for each

00:00:19.250 --> 00:00:23.126
loop this here as well
this here as well and this

00:00:23.151 --> 00:00:26.779
is just the for loop.
Let me just format this

00:00:26.779 --> 00:00:29.132
little bit, there we go.
So anyway the

00:00:29.157 --> 00:00:31.340
reason why I'm actually
returned the code

00:00:31.340 --> 00:00:37.550
that I am doing the lecture over the
written code is because, well somebody

00:00:37.550 --> 00:00:41.610
decided to turn on a vacuum in the
middle of my previous cast and I was

00:00:41.610 --> 00:00:44.071
kind of hoping that the
sound wouldn't reach

00:00:44.096 --> 00:00:46.390
this room but unfortunately
it did and I

00:00:46.390 --> 00:00:49.434
wasted twenty minutes
of my life that I

00:00:49.459 --> 00:00:52.340
will never get back.
Anyway for each

00:00:52.340 --> 00:00:54.792
loop, now to explain
this type of loop,

00:00:54.817 --> 00:00:57.140
we first need to
know what container

00:00:57.140 --> 00:01:00.552
types are, for now
let's say that we know

00:01:00.577 --> 00:01:03.809
what arrays are and
we will learn about

00:01:03.809 --> 00:01:05.932
them in the later
chapters or in the

00:01:05.957 --> 00:01:08.490
later chapters if
I'm not mistaken so

00:01:08.490 --> 00:01:12.670
but we need to assume that
we know them in order to be able to

00:01:12.670 --> 00:01:15.465
explain the for each
loop, now for each loop

00:01:15.490 --> 00:01:18.160
is specific to C++ 11
standards so you do

00:01:18.259 --> 00:01:22.747
need to go into
settings compiler and

00:01:22.772 --> 00:01:26.530
all this flag here
so it says have

00:01:26.630 --> 00:01:30.720
C++ follow the C++ 11 ISO C++
language standard

00:01:30.720 --> 00:01:32.907
just go ahead and
click on it, you can

00:01:32.932 --> 00:01:34.870
you can read about it
later, if you want

00:01:34.970 --> 00:01:39.079
you can expand this area and you can
also read in the net the C++

00:01:39.079 --> 00:01:43.939
standards are, eleven standards are. click OK

00:01:45.470 --> 00:01:51.619
anyway so as I said I didn't want to
make an absolute course that is for C++

00:01:51.619 --> 00:01:56.229
as it was back in the day I wanted to
make a course that would show you how

00:01:56.229 --> 00:01:59.118
C++ is it today and
include pretty much

00:01:59.143 --> 00:02:02.200
all the latest
features which are all

00:02:02.200 --> 00:02:05.110
the latest features that I could in fact
there are some

00:02:05.110 --> 00:02:08.268
features it from C++
11 in the keylogger

00:02:08.293 --> 00:02:11.840
course that I mean
it hasn't even been

00:02:11.940 --> 00:02:15.830
a month since the features have been
enabled in the official compiler I'm not

00:02:15.830 --> 00:02:18.830
actually sure about that anyway

00:02:19.420 --> 00:02:23.023
Anyway, so the for each
loop is only for C++

00:02:23.048 --> 00:02:26.560
11 step for C++ 11
and as I said we are

00:02:26.560 --> 00:02:31.470
going to assume for the
time being that we know what arrays are I

00:02:31.470 --> 00:02:33.696
will talk about them
later on, basically

00:02:33.721 --> 00:02:35.690
this is an integer
array, this is a double

00:02:35.690 --> 00:02:39.145
array, an integer array
is basically just a

00:02:39.170 --> 00:02:42.600
combination of integers,
you have 5,4,1,2

00:02:42.600 --> 00:02:48.110
3, -2 a W ray can consist of

00:02:48.110 --> 00:02:52.880
1,1,2,2,6,1,3,5 etc and so on and so forth

00:02:54.910 --> 00:02:59.140
they consist out of elements enclosed
within these curly brackets and now

00:02:59.140 --> 00:03:05.230
they're index each one of these numbers
actually has a position and positions

00:03:05.230 --> 00:03:13.160
begin like this so 11 would be at a
position 0; 22 would be at a position 12

00:03:15.660 --> 00:03:19.335
this is position 3, so 0,1,2,3.
four numbers

00:03:19.360 --> 00:03:22.690
in total sometimes it
can be a little bit

00:03:22.690 --> 00:03:26.254
confusing to have 0123,
four numbers four

00:03:26.279 --> 00:03:29.580
elements, does it have
to be four numbers

00:03:29.580 --> 00:03:31.988
four elements in
total four numbers

00:03:32.013 --> 00:03:34.670
because this is a
double array but array

00:03:34.670 --> 00:03:38.530
of type double and we know what type
double is, but it could have been a

00:03:38.530 --> 00:03:41.157
character we could
have had characters

00:03:41.182 --> 00:03:43.670
we could have had an
array of strings or whatever

00:03:44.200 --> 00:03:46.639
a lot of things so
which one of these

00:03:46.664 --> 00:03:48.500
numbers, could have
been like a word

00:03:48.600 --> 00:03:51.750
which one could have been a word or
something like that doesn't really

00:03:51.750 --> 00:03:53.723
matter, there are so
many variants here its

00:03:53.748 --> 00:03:56.320
hillarious. Anyway,
that is irrelevant

00:03:56.320 --> 00:04:00.040
what I need these types and you to include them here

00:04:00.040 --> 00:04:04.850
because I need to explain what for each
loop was without them it would have been

00:04:04.850 --> 00:04:07.650
kind of difficult or
should I say, probably

00:04:07.675 --> 00:04:10.450
impossible to an extent I
could have chosen to use

00:04:10.450 --> 00:04:15.690
more complex types but I just chosen to
use these by for explanation purposes

00:04:16.370 --> 00:04:20.780
as I said, take what you know
now and you would basically access these

00:04:20.780 --> 00:04:23.780
elements by typing in arr

00:04:24.500 --> 00:04:31.180
let's see zero so this would be an
equivalent of number five or the first

00:04:31.180 --> 00:04:36.860
element of the array as the index begins
from zero and not from one I will

00:04:36.860 --> 00:04:39.726
explain this in
more depth later on

00:04:39.751 --> 00:04:42.650
anyway so let's go
to be subject off

00:04:42.650 --> 00:04:47.650
this tutorial into the for each loop, now
here you can see the syntax of the for

00:04:47.650 --> 00:04:53.389
each loop which roughly translates as
for each element in container or

00:04:53.389 --> 00:04:56.703
collection so you
have for and then you

00:04:56.728 --> 00:04:59.699
have a parenthesis
open you specify some

00:04:59.699 --> 00:05:02.034
sort of a type here and then you

00:05:02.059 --> 00:05:04.229
supply the variable
name, use a colon

00:05:04.229 --> 00:05:09.110
and then you specify the container of
your choosing our container will be the

00:05:09.110 --> 00:05:13.917
variable int arr, the array.
Anyway this

00:05:13.942 --> 00:05:18.190
particular example
will print out each

00:05:18.190 --> 00:05:22.009
element of the array
in the next row so

00:05:22.034 --> 00:05:26.160
that is, variable I
will hold the value

00:05:26.160 --> 00:05:31.430
from each element of the array, so you
see here for each iteration it will go

00:05:31.430 --> 00:05:37.123
like this I will be, i
don't know, I will be

00:05:37.148 --> 00:05:41.950
zero and then it will
print then you will

00:05:41.950 --> 00:05:46.210
have a printout of sorry arr

00:05:47.139 --> 00:05:50.360
0 which will be
equivalent to number

00:05:50.385 --> 00:05:53.370
five and so on and
so forth you don't

00:05:53.370 --> 00:06:00.090
need to specify range or anything like
that here, you just use the

00:06:00.090 --> 00:06:02.806
container and then
use a variable for

00:06:02.831 --> 00:06:05.460
iteration you don't
need to initialize

00:06:05.460 --> 00:06:10.240
it or anything like that it just stands
for each element it begins from zero and

00:06:10.240 --> 00:06:15.669
it goes to the end that's it so you have
that variable which

00:06:15.669 --> 00:06:20.389
you will use for it for iteration or
whatever you wish to call it and here

00:06:20.389 --> 00:06:23.030
you have the container over

00:06:23.030 --> 00:06:26.920
whose elements you wish to
iterate so you will go one element

00:06:26.920 --> 00:06:32.040
that the time it will begin from the
index as 0 and it will end wherever the

00:06:32.040 --> 00:06:34.910
array pretty much ends, simple as that

00:06:34.910 --> 00:06:38.840
now it will printed them out onto the screen and it will go

00:06:38.840 --> 00:06:41.180
into a new line for
each print out the

00:06:41.205 --> 00:06:43.320
same thing will happen
here except here

00:06:43.320 --> 00:06:46.782
we're using a double instead
of an int so you see it's

00:06:46.807 --> 00:06:50.200
an int here and and we're
printing out and onto the

00:06:50.300 --> 00:06:52.879
screen but here printing
out doubles and

00:06:52.904 --> 00:06:55.510
we can also use the
auto keyword that we

00:06:55.510 --> 00:06:59.340
have learned previously to automatic to
detect the type in an automated fashion

00:06:59.340 --> 00:07:03.000
so we don't have to actually specify the
type, this is going to be very useful

00:07:03.000 --> 00:07:07.800
later on, all three of these examples
pretty much do the same exact thing

00:07:07.800 --> 00:07:13.230
these two are exactly the same the only
difference between them is the types

00:07:13.230 --> 00:07:18.030
that they're using and this one is
somewhat different as it has a generic

00:07:18.030 --> 00:07:21.785
type so this can be
pretty much I the

00:07:21.810 --> 00:07:25.690
arr to can be pretty
much off any type

00:07:25.690 --> 00:07:27.805
it can be a double,
can be an integer, it

00:07:27.830 --> 00:07:29.760
can be a floating-point,
it can be whatever

00:07:29.760 --> 00:07:33.208
whatever is allowed
so to say and down

00:07:33.233 --> 00:07:36.590
below I have used a
for loop in order to

00:07:36.590 --> 00:07:40.910
demonstrate how the for each loop would
look how what we have done with the for

00:07:40.910 --> 00:07:44.990
each loop would look like if we have
done if we had done it with a for loop

00:07:44.990 --> 00:07:47.730
so you can see here
we begin at index 0

00:07:47.755 --> 00:07:50.360
we set the condition
that I is less than

00:07:50.360 --> 00:07:56.530
or equal to five and then we reiterate over the I

00:07:56.530 --> 00:08:01.130
by fact by one and then we printed out
we print out the first element of the

00:08:01.130 --> 00:08:06.070
array and the second and the third, fourth,
fifth etc. Now this array has

00:08:06.070 --> 00:08:10.579
1,2,3,4,5,6 elements,
so why is I less

00:08:10.604 --> 00:08:15.410
or equal to 5 here,
what do you think?

00:08:15.410 --> 00:08:19.820
well because the iteration starts at
zero so count with me here

00:08:19.820 --> 00:08:27.640
012345 that's six numbers if you include
the zero and therefore the boundary is

00:08:29.940 --> 00:08:33.030
five size of the array is six

00:08:33.030 --> 00:08:38.350
meaning we have it contains six elements
and therefore if you want to iterate

00:08:38.350 --> 00:08:40.752
over all the six
elements meaning from 0

00:08:40.777 --> 00:08:43.050
to 5 it's a little
bit counterintuitive

00:08:43.050 --> 00:08:45.886
yes but not much of a
problem you get the

00:08:45.911 --> 00:08:48.340
hang of it and you
get used to it so

00:08:48.340 --> 00:08:51.852
down below whe are
printing out I first has

00:08:51.877 --> 00:08:54.950
the value of zero and
arr 0 that's just

00:08:54.950 --> 00:09:00.150
five and then I changes to one and that's
four and changes to two, that's one

00:09:00.150 --> 00:09:02.355
etc so on and so forth.
So let's go

00:09:02.380 --> 00:09:04.560
ahead and compile
and run this and

00:09:04.560 --> 00:09:09.174
there you go you see
how this first print

00:09:09.199 --> 00:09:12.660
out occurred so this
is 54123 and -2

00:09:12.660 --> 00:09:19.310
so this that we're looking at the
first for each loop and as you can see

00:09:19.310 --> 00:09:23.450
it worked flawlessly perfectly each
element of the array was printed out

00:09:23.450 --> 00:09:26.213
second loop that
we're looking at is

00:09:26.238 --> 00:09:28.910
double again the
printout is correct oh

00:09:28.910 --> 00:09:31.591
sure you can go ahead
and check it out

00:09:31.616 --> 00:09:33.860
for yourself if you
wish to choose or

00:09:33.860 --> 00:09:40.500
prefer I do it and finally the third
printout finally what the third

00:09:40.500 --> 00:09:44.060
point out that happened was four but
with auto generic type

00:09:45.630 --> 00:09:48.003
by using auto keyword
for detecting

00:09:48.028 --> 00:09:50.490
the type in an automated

00:09:50.490 --> 00:09:58.450
fashion and it's basically begins from
1122 6135 and down below we just

00:09:58.950 --> 00:10:02.290
have a demonstration of the for loop how
it would look like if we had been at the

00:10:02.290 --> 00:10:05.135
for loop and here we
have the printout

00:10:05.160 --> 00:10:07.980
for which day for
loop was used in a

00:10:07.980 --> 00:10:12.120
sense now let me show you one more thing
that I want to do here you see just a

00:10:12.120 --> 00:10:18.080
show you for each loop is C++ 11
exclusive so, if you're going to compiler

00:10:18.080 --> 00:10:22.182
and if we disable
this, but we have

00:10:22.207 --> 00:10:25.570
enabled previously,
if we try to build

00:10:25.570 --> 00:10:28.570
and run okay it does

00:10:31.850 --> 00:10:34.850
I think I need to reset

00:10:36.980 --> 00:10:42.730
11 it is disabled

00:10:42.730 --> 00:10:45.322
strangely does run
ok let me just do a

00:10:45.347 --> 00:10:47.810
Save, control+s and
then build and run

00:10:47.810 --> 00:10:54.172
it again it builds
and runs let me just

00:10:54.197 --> 00:11:00.110
where is it? that
controlled be in this one

00:11:00.110 --> 00:11:05.740
and then run it it
works again let's

00:11:05.765 --> 00:11:11.370
build it ok so just
go ahead and reset

00:11:11.370 --> 00:11:14.610
it again you can reopen
it by going into the

00:11:14.635 --> 00:11:17.850
folder where you have
saved it, I have in the

00:11:17.850 --> 00:11:25.019
chapter four loops and straight here I can
open it up from here, because

00:11:25.019 --> 00:11:29.420
in C++ standards were
enabled just remember that for some

00:11:29.420 --> 00:11:37.379
strange reason ok so go into there
surprisingly it does build and run

00:11:42.089 --> 00:11:45.370
Ok there was a problem here

00:11:45.370 --> 00:11:49.490
process terminated with status blah blah
blah forget about that

00:11:50.199 --> 00:11:54.927
checking for existence
yeah, does work.

00:11:54.952 --> 00:11:59.870
Anyway I have precompiled
that before and I

00:11:59.870 --> 00:12:04.730
am would need to actually delete the
whole thing and then re do it just showed

00:12:04.730 --> 00:12:11.379
that doesn't actually work but I can't
believe it I really can't I have to have

00:12:11.379 --> 00:12:14.354
to make a proof
otherwise I will have

00:12:14.379 --> 00:12:17.519
shamed myself, ok
let's have just copy

00:12:17.519 --> 00:12:21.021
the entire pro just
copy the entire main

00:12:21.046 --> 00:12:24.180
file and let's open
up codeblocks and

00:12:24.180 --> 00:12:26.704
you don't have to
do this, I'm just

00:12:26.729 --> 00:12:28.970
making a proof of
concept here project

00:12:28.970 --> 00:12:36.780
it's going to be C++ sure it's going to be tralalala and semicolon shouldn't be there

00:12:44.550 --> 00:12:52.479
finish. Goodbye standard main and welcome
our project there you go

00:12:54.379 --> 00:12:57.432
so error you see here
it says red light

00:12:57.457 --> 00:13:00.550
error range based
for loops are not

00:13:00.550 --> 00:13:05.008
allowed in C++ 98 mode,
so you do indeed

00:13:05.033 --> 00:13:08.729
require C++ 11 in order
for this compile

00:13:08.829 --> 00:13:12.879
and he just proved it by going into
compiler one more time

00:13:12.879 --> 00:13:18.594
C++ 11 ISO ok let's run
there you ago, it's

00:13:18.619 --> 00:13:22.910
now it works sorry I
don't find my way

00:13:22.910 --> 00:13:25.190
around codeblocks that
easily, I'm really

00:13:25.215 --> 00:13:27.539
out of shape in terms
of codeblock I

00:13:27.639 --> 00:13:29.832
haven't used it in a
very long time but

00:13:29.857 --> 00:13:31.969
it's best used for
learning and then

00:13:32.069 --> 00:13:36.649
later on people generally tend to move
to something else but it's

00:13:36.649 --> 00:13:39.309
really nice for learning
anyway there you

00:13:39.334 --> 00:13:41.760
ago I have proven
what I have stated I

00:13:41.860 --> 00:13:44.651
didn't leave it had just
take my word for it.

00:13:44.676 --> 00:13:47.290
Anyway I shall see you
in the follow tutorial

00:13:47.290 --> 00:13:49.579
where we shall deal with

00:13:49.579 --> 00:13:53.389
break and continue. what they are? how
they function? and what we use them for?

00:13:53.389 --> 00:13:56.060
I will explain that in the follow tutorial.