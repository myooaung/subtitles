WEBVTT

00:00:00.000 --> 00:00:01.801
So you see, we actually
need to create two

00:00:01.826 --> 00:00:03.699
functions to demonstrate
some concepts

00:00:03.699 --> 00:00:07.465
here, but we are not done yet.
Let's go

00:00:07.690 --> 00:00:12.120
ahead and make it
do exactly the same

00:00:12.120 --> 00:00:14.978
thing at this one to
save some time, just

00:00:15.003 --> 00:00:18.080
basically control+C
and Ctrl+V you don't

00:00:18.080 --> 00:00:20.730
need to do anything different

00:00:20.730 --> 00:00:25.789
it just needs to create a print out but
it will create a print out of double of

00:00:25.789 --> 00:00:33.170
doubles nothing more, nothing less and we
can even add an at here

00:00:34.730 --> 00:00:40.510
oh wait I don't need that, I can just
do it here, not big

00:00:41.200 --> 00:00:49.140
deal, double and we can do it here like int
and so that we can differentiate the

00:00:53.140 --> 00:00:54.925
print out I mean
obviously we'll see the

00:00:54.950 --> 00:00:56.670
different numbers
but maybe once or

00:00:56.670 --> 00:00:59.760
maybe not the different numbers
depending on the arrays that we create

00:00:59.760 --> 00:01:04.236
ok so this is going
to work you'll see,

00:01:04.261 --> 00:01:09.400
hopefully if I didn't
make any mistakes

00:01:09.400 --> 00:01:12.850
excellent, so you see, this is an area

00:01:12.850 --> 00:01:20.299
of integers, ok no problems. Let's go back
into the main function and just create

00:01:20.299 --> 00:01:23.070
just create another
array, it's gonna be

00:01:23.095 --> 00:01:25.590
of doubles doesn't
need to be the same

00:01:25.590 --> 00:01:28.575
size, it can be pretty
much any size,ok

00:01:28.600 --> 00:01:31.430
so just have three
numbers of four

00:01:31.430 --> 00:01:39.360
point 34 3.1 and we can place like
negative 2

00:01:43.440 --> 00:01:51.390
double. Ok so this will be arr1, this should be 00, and this should be 01

00:01:55.990 --> 00:01:58.774
we can name them so I
mean the naming is

00:01:58.799 --> 00:02:01.290
arbitrary of course
and what we want to

00:02:01.290 --> 00:02:02.770
do here

00:02:02.770 --> 00:02:04.617
is typing 01 because
we are going to pass a

00:02:04.642 --> 00:02:06.590
double so you see we're
not changing the

00:02:06.590 --> 00:02:10.840
function call we are just changing the
parameters as being passed and we can go

00:02:10.840 --> 00:02:18.830
ahead and run this, what is this? Oh right, sorry
so 01,01

00:02:22.420 --> 00:02:27.381
change the names here in
my apologies, oh men, one

00:02:27.406 --> 00:02:32.990
humiliation after another
I guess, look at it

00:02:32.990 --> 00:02:34.930
that way

00:02:34.930 --> 00:02:41.920
go ahead and run it. Ok see? now it says
double -23.14.30 40

00:02:41.920 --> 00:02:43.580
but take a look at this

00:02:43.580 --> 00:02:46.340
the size of a double
is not the same as

00:02:46.365 --> 00:02:49.100
the size of an int,
size of double is 8

00:02:49.100 --> 00:02:52.079
bytes and the size of
an int is 4, so it

00:02:52.104 --> 00:02:55.120
takes more memory
space it reserves a

00:02:55.120 --> 00:02:57.424
greater amount of
memory space again you

00:02:57.449 --> 00:02:59.730
can check out the
check out the size in

00:02:59.830 --> 00:03:05.080
terms of bytes for all the types in C++
you can do that on the net I really

00:03:05.080 --> 00:03:09.290
don't feel like listing them out here
and there really is no need for me to do

00:03:09.290 --> 00:03:17.290
that and we can
basically call this function twice and

00:03:17.890 --> 00:03:25.620
twice we can I don't know we can place a 00
and now we can place a

00:03:25.620 --> 00:03:29.366
01 so we can go ahead
and run it again

00:03:29.391 --> 00:03:32.959
each time as you can
see the program

00:03:32.959 --> 00:03:38.459
knows exactly which function to call it
knows where the to call, the one where

00:03:38.459 --> 00:03:42.930
it knows where to call the  first one or the
second one, knows whether to call it

00:03:42.930 --> 00:03:45.524
knows this because the
arguments pass to it

00:03:45.549 --> 00:03:47.600
are different so if you
pass a integer here

00:03:47.600 --> 00:03:53.080
an integer array it's going to of
course create a print out of integers

00:03:53.610 --> 00:03:57.630
and it's going to call the first
function if you pass in a double value

00:03:57.630 --> 00:04:00.960
it will of course call the second
function and will create a print out of

00:04:00.960 --> 00:04:05.670
doubles, so it is the compiler is
intelligent in that fashion it is able to

00:04:05.670 --> 00:04:07.971
recognize this
without you actually

00:04:07.996 --> 00:04:10.390
having to change the
names of functions

00:04:10.390 --> 00:04:16.090
so this does help you a great deal
believe this is all good fine and dandy

00:04:16.090 --> 00:04:19.100
I no big deal, right?

00:04:19.100 --> 00:04:22.453
fairly simple concept
but hey what if we need

00:04:22.478 --> 00:04:25.630
a boolean array? or ar hr array?
then we

00:04:25.630 --> 00:04:28.882
would have to write
a function for each

00:04:28.907 --> 00:04:32.210
of those so imagine
if you had if you

00:04:32.210 --> 00:04:35.613
for example had ten,
maybe five to ten

00:04:35.638 --> 00:04:39.300
different types of
arrays and you needed

00:04:39.300 --> 00:04:43.020
to create this sort of a
function overloading for each one of

00:04:43.020 --> 00:04:48.300
those types it so
I can tell it's a lot of code a lot

00:04:48.300 --> 00:04:53.270
especially if it's a

00:04:53.270 --> 00:04:57.170
little bit longer and you need to change all the
names within the functions, etc

00:04:57.180 --> 00:05:01.707
it can be a pain
staking process so in

00:05:01.732 --> 00:05:05.790
order to avoid this
we can use generic

00:05:05.790 --> 00:05:09.050
functions they accept
the type and print

00:05:09.075 --> 00:05:12.310
it out, the function
body is the same for

00:05:12.310 --> 00:05:19.260
all types so generic function is a
function that is declared with type

00:05:19.260 --> 00:05:24.840
parameters and when called instead of
those type parameters actual types are

00:05:24.840 --> 00:05:28.830
used but the syntax is something

00:05:28.855 --> 00:05:32.820
fairly new so let's
take a look at the

00:05:32.820 --> 00:05:38.600
pseudocode for a generic function. So let
me show you how you can created

00:05:38.600 --> 00:05:45.805
basically keep in
mind this is pseudo

00:05:45.830 --> 00:05:51.540
code so template
typename type so

00:05:51.540 --> 00:05:54.561
instead of typing name,
you can also use

00:05:54.586 --> 00:05:57.890
like class but this
is definitely not

00:05:57.890 --> 00:06:00.390
recommended way of going about things

00:06:00.390 --> 00:06:05.380
so just use type name. Anyway

00:06:05.380 --> 00:06:08.622
down below we shall
go ahead an attempt

00:06:08.647 --> 00:06:11.610
to recreate our void
print function, so

00:06:11.610 --> 00:06:16.450
void print and instead of the
parameters as we've been typing them

00:06:16.450 --> 00:06:19.030
those far like a double
array or implant

00:06:19.055 --> 00:06:21.634
we're gonna go ahead
and just type in

00:06:22.640 --> 00:06:27.301
arr do this and then int len.

00:06:27.326 --> 00:06:35.320
Keep in mind this generic
function this is a

00:06:35.420 --> 00:06:41.700
partial deduction because we already
know that this is an array but we

00:06:41.700 --> 00:06:46.480
do not actually know what type it is
whether it's an integer, an array of

00:06:46.480 --> 00:06:52.070
integers or doubles or floating points
or whatever so we have no idea about

00:06:52.070 --> 00:06:55.800
that anyway

00:06:55.800 --> 00:06:59.410
generic function that would be a
function that is decleared with type

00:06:59.410 --> 00:07:04.050
parameters and went cold instead of
those type parameters actual types are

00:07:04.050 --> 00:07:11.200
used so keep that in mind here we as I
stated we will talk about partial

00:07:11.200 --> 00:07:18.560
deduction because we
already know some information like that

00:07:18.560 --> 00:07:20.944
array, just not the
type that is so let's

00:07:20.969 --> 00:07:23.280
go ahead and delete
this and since we have

00:07:23.280 --> 00:07:27.010
these functions that are overloading
we're going to go ahead and removed them

00:07:27.010 --> 00:07:29.657
as well primarily due
to the fact that

00:07:29.682 --> 00:07:32.160
we don't really need
them anymore and we

00:07:32.160 --> 00:07:37.380
can remove the two prototypes as well as
we do not need them again you can

00:07:37.380 --> 00:07:40.380
leave them if you like, but it doesn't
really matter

00:07:42.850 --> 00:07:48.899
template typename type,
so this will be a generic

00:07:48.924 --> 00:07:55.290
function with name
type for generic type

00:07:55.290 --> 00:07:59.130
I know it can be a little bit confusing but
bear with me here

00:08:11.569 --> 00:08:14.007
syntax is as has been
shown and we're not

00:08:14.032 --> 00:08:16.289
going to prototype
it or anything just

00:08:16.289 --> 00:08:20.800
have one function so we will
write it out here

00:08:22.789 --> 00:08:25.158
create basically the
same body probably

00:08:25.183 --> 00:08:27.280
should have copied the
body from the other

00:08:27.280 --> 00:08:35.229
functions but can't think
of everything always but if you have

00:08:36.729 --> 00:08:40.399
been among some of the people
who have actually managed to have

00:08:40.399 --> 00:08:42.364
preserved the other
functions, feel free

00:08:42.389 --> 00:08:44.370
to just copy-paste
the code otherwise

00:08:44.370 --> 00:08:48.000
write with me.

00:09:02.500 --> 00:09:06.000
So very short snippet of
code

00:09:11.710 --> 00:09:19.300
a coma and a space and we need that if statement

00:09:50.000 --> 00:09:52.000
Ah that was like super painful

00:09:52.370 --> 00:09:59.500
anyway we have created body of the
function and now we do not know what

00:09:59.500 --> 00:10:01.796
type of an array we
are going to pass to

00:10:01.821 --> 00:10:04.150
this function, we can
pass pretty much

00:10:04.150 --> 00:10:08.755
anything we want
that is the beauty

00:10:08.780 --> 00:10:13.060
of this so let's go ahead and

00:10:13.060 --> 00:10:15.564
actually just re run
this code is there

00:10:15.589 --> 00:10:18.020
shouldn't be a need
to actually change

00:10:18.020 --> 00:10:24.910
anything here and we can just go ahead
and run it and there you go again

00:10:24.910 --> 00:10:27.143
the print out is correct
it's working and

00:10:27.168 --> 00:10:29.580
notice how we didn't
need to create like

00:10:29.580 --> 00:10:34.330
2,3 different functions it's just
1 and it's going to accept pretty much

00:10:34.330 --> 00:10:36.631
whatever you can
throw at it as long

00:10:36.656 --> 00:10:38.830
as this is an array
because we have

00:10:38.830 --> 00:10:41.696
we've basically made
it so its generic it

00:10:41.721 --> 00:10:44.250
connects it accepts
pretty much anything

00:10:44.250 --> 00:10:49.134
so you see we have
an int and we have a

00:10:49.159 --> 00:10:53.620
double and we can also
have like a float can

00:10:53.620 --> 00:11:00.350
have pretty much whatever you want, feel free to
play around with types and put random

00:11:00.350 --> 00:11:08.260
ones whatever it is
that you can put in feel free to put it

00:11:08.660 --> 00:11:12.859
so tried but if you
can get a list

00:11:12.884 --> 00:11:17.400
of all the types or just use all

00:11:17.400 --> 00:11:20.810
the types that we have learned those far
and then try implementing them

00:11:20.810 --> 00:11:24.008
in fact we can even
like do this, let's

00:11:24.033 --> 00:11:26.950
go ahead and arrand
it's gonna be

00:11:26.950 --> 00:11:32.320
like let's just use 03 use char but
doesn't really matter

00:11:55.000 --> 00:11:58.310
whatever it
doesn't really matter just some random

00:11:58.310 --> 00:12:02.123
order of letters
it is completely

00:12:02.148 --> 00:12:05.080
irrelevant that makes
no difference so

00:12:05.080 --> 00:12:13.073
let's go ahead and create
another one print arr03

00:12:15.598 --> 00:12:23.580
ok so this is going to
give the sizes from

00:12:24.980 --> 00:12:30.920
the different arrays so that has
to go because even though to compile it

00:12:30.920 --> 00:12:33.270
won't actual report
a mistake you're

00:12:33.295 --> 00:12:35.620
gonna get wrong link sizes here

00:12:35.620 --> 00:12:38.757
wrong sizes of array, why?
because this one

00:12:38.782 --> 00:12:41.960
is doing is calculating
the size for a

00:12:41.960 --> 00:12:47.734
array 01 and we have 00
01 02 03 so we need to

00:12:47.759 --> 00:12:53.089
remove that and instead
of laying here we will

00:12:53.089 --> 00:12:58.632
need to write individual
length for each

00:12:58.657 --> 00:13:04.410
one of these its
12345678 ok so 8 this

00:13:04.410 --> 00:13:12.339
one is like 24, this is actually 00
well forget about

00:13:15.239 --> 00:13:16.680
that let's put it like this

00:13:16.680 --> 00:13:21.130
01 02 03

00:13:22.350 --> 00:13:30.250
actually 00 you know this day has been like uhh 02
00 01 02 and 03

00:13:40.250 --> 00:13:48.240
there you go, so that's what I wanted anyway
for 00 it is for 01 it is 02 its

00:13:48.840 --> 00:13:55.108
late 1233 1234 so there
you go let's go ahead

00:13:55.133 --> 00:14:02.400
and run the code now.
Hu it managed print

00:14:02.400 --> 00:14:05.416
all of them out and
there seems to be a

00:14:05.441 --> 00:14:08.200
bit of a problem here
so let's go ahead

00:14:08.200 --> 00:14:16.020
and see what the problem is so that
would be 01 that's double so 123

00:14:16.820 --> 00:14:22.870
there you go so we went outside the
boundaries of the array I do believe

00:14:22.870 --> 00:14:26.596
that in java, you wouldn't
be able to do this

00:14:26.621 --> 00:14:30.160
it would prevent you but
in C++ you can that's

00:14:30.160 --> 00:14:37.560
-23.1-2 3.14.34 and
then you have another extra element

00:14:37.560 --> 00:14:45.110
which is just whatever
occupied that ram space at the time of

00:14:45.110 --> 00:14:47.845
compiling this ok, so
let's go ahead and

00:14:47.870 --> 00:14:50.630
close this I miss the
array size of their

00:14:50.630 --> 00:14:53.948
so let's go ahead and
type 3 there, build

00:14:53.973 --> 00:14:57.340
and run and there you
go, now it seems

00:14:57.340 --> 00:15:03.530
very much correct and no
problems there so you can disregard

00:15:03.530 --> 00:15:08.590
these two this is just something that
remained from the previous tutorial but

00:15:08.590 --> 00:15:15.310
there you go, so it's 1234, 4 arrays that
we have created here and all

00:15:15.310 --> 00:15:20.010
4 of them we've managed to pass to
this generic function without actually

00:15:20.010 --> 00:15:22.250
stating what's what

00:15:22.250 --> 00:15:26.060
without actually needing to know what it
is that we need to pass that a function

00:15:26.060 --> 00:15:28.350
that we needed to know was that

00:15:28.350 --> 00:15:30.641
we're passing an
array and that array

00:15:30.666 --> 00:15:32.640
could have been anything so the

00:15:32.640 --> 00:15:40.610
question now is how does all this work?
well it's not actually that complicated

00:15:41.310 --> 00:15:46.750
to understand, the compiler creates 4
functions that have the same body keep

00:15:46.750 --> 00:15:50.880
in mind the compiler creates so it
literally create the function that did

00:15:50.880 --> 00:15:54.327
not exist prior to your
compiling the code

00:15:54.352 --> 00:15:57.620
so you have these 4
functions should be

00:15:57.620 --> 00:16:00.256
created they all have
the same body that

00:16:00.281 --> 00:16:02.720
the compiler does
that for us thank you

00:16:02.720 --> 00:16:03.770
compiler