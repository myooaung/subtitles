1
00:00:02,000 --> 00:00:05,830
[Autogenerated] Now we've given an overview of the two core testing strategies.

2
00:00:05,830 --> 00:00:09,190
Let's take a look at how they fit together in a pipeline in

3
00:00:09,190 --> 00:00:13,410
order to see what sort of mess we can end up him after

4
00:00:13,410 --> 00:00:15,570
making a change to a mocha service.

5
00:00:15,570 --> 00:00:18,960
The first thing that would happen is running its individual tests,

6
00:00:18,960 --> 00:00:23,510
where we markets counterparts on passing we would publish it is an

7
00:00:23,510 --> 00:00:27,440
artifact on deploy it to a staging environment.

8
00:00:27,440 --> 00:00:28,950
On this stage and environment,

9
00:00:28,950 --> 00:00:33,680
we would run our into an tests which would test the whole application together.

10
00:00:33,680 --> 00:00:38,980
And finally, when this passes, we will release our Michael Service to production.

11
00:00:38,980 --> 00:00:42,140
So what is the problem with this pipeline?

12
00:00:42,140 --> 00:00:46,120
The first major one is false positives we get from our stops or marks,

13
00:00:46,120 --> 00:00:49,540
not accurately representing the rial counterparts.

14
00:00:49,540 --> 00:00:52,530
Essentially, these cause unreliable feedback,

15
00:00:52,530 --> 00:00:55,350
which lets on Michael Service get favoring the pipeline.

16
00:00:55,350 --> 00:00:56,940
And it should.

17
00:00:56,940 --> 00:01:01,050
The second problem is how slow and flaky and to an tests are.

18
00:01:01,050 --> 00:01:03,120
They end up taken forever to run,

19
00:01:03,120 --> 00:01:05,800
even if we make a trivial change to a single micro

20
00:01:05,800 --> 00:01:08,770
service in software development,

21
00:01:08,770 --> 00:01:11,910
the feedback loop is key as it's what allows teams to

22
00:01:11,910 --> 00:01:14,840
develop in release new features quickly.

23
00:01:14,840 --> 00:01:19,090
One something's broken, ideally, to actually be determined on a local build,

24
00:01:19,090 --> 00:01:21,100
not free hours in the future when we run.

25
00:01:21,100 --> 00:01:23,040
And so in tests.

26
00:01:23,040 --> 00:01:25,050
And of course, when trying to fix a book,

27
00:01:25,050 --> 00:01:28,960
it's easier to do so when it happens sooner rather than later.

28
00:01:28,960 --> 00:01:33,100
As it's hard, it's deeper issues found doing and so in tests.

29
00:01:33,100 --> 00:01:36,370
So what we have here is an extremely weak feedback loop,

30
00:01:36,370 --> 00:01:39,510
which kind of makes our release fade off into the distance and

31
00:01:39,510 --> 00:01:46,000
feel like it's hardly ever gains that happen. This isn't a great situation to be him.

