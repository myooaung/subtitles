WEBVTT
1
00:00:02.140 --> 00:00:04.180
[Autogenerated] before we go any further,

2
00:00:04.180 --> 00:00:07.010
let's take more for look at what specifically is

3
00:00:07.010 --> 00:00:11.180
happening when we generate our stops.

4
00:00:11.180 --> 00:00:15.240
First of all, we're running, install and skipping tests.

5
00:00:15.240 --> 00:00:17.920
It's already being explained that this is because

6
00:00:17.920 --> 00:00:22.230
they at this point in the workflow, we don't care about the provider side.

7
00:00:22.230 --> 00:00:25.640
We just want to generate our stops.

8
00:00:25.640 --> 00:00:28.940
Next, there is a transformation process.

9
00:00:28.940 --> 00:00:32.230
What happens here is that a contract is passed by the

10
00:00:32.230 --> 00:00:36.680
verifier and converted into a stop mapping file.

11
00:00:36.680 --> 00:00:39.800
This is a relatively sophisticated process,

12
00:00:39.800 --> 00:00:42.510
as is able to calculate different types of matching

13
00:00:42.510 --> 00:00:48.840
expressions such as Jason Path, generate values from method calls and much more.

14
00:00:48.840 --> 00:00:52.340
We'll go into more detail about this in a later module,

15
00:00:52.340 --> 00:00:56.440
but for now we can think of a stock mapping as mark AP I data

16
00:00:56.440 --> 00:01:01.000
generated from our contract finally are stuck.

17
00:01:01.000 --> 00:01:04.410
Mapping files are packaged into a jar on installed

18
00:01:04.410 --> 00:01:07.040
into our local maven repository.

19
00:01:07.040 --> 00:01:08.180
Typically,

20
00:01:08.180 --> 00:01:15.040
these live alongside to provide a jar with an added classifier of minus stub.

21
00:01:15.040 --> 00:01:18.150
The advantage of taking this approach is that spring cloud

22
00:01:18.150 --> 00:01:21.750
contract is able to leverage the existing dependency management

23
00:01:21.750 --> 00:01:26.090
and build systems of Java may even in grade all and avoid having

24
00:01:26.090 --> 00:01:29.030
to do anything proprietary.

25
00:01:29.030 --> 00:01:31.290
This also makes adoption easier,

26
00:01:31.290 --> 00:01:36.570
as most organizations would already have the necessary infrastructure in place.

27
00:01:36.570 --> 00:01:37.600
Stub mapping said.

28
00:01:37.600 --> 00:01:41.220
We mentioned a few times now I'm being described as Mark

29
00:01:41.220 --> 00:01:44.740
data generated from our A P I contracts.

30
00:01:44.740 --> 00:01:48.450
Now I'd like to take a step back and give more of an explanation

31
00:01:48.450 --> 00:01:52.840
about their foul former and how their own.

32
00:01:52.840 --> 00:01:54.380
On the consumer side.

33
00:01:54.380 --> 00:01:58.320
When spring cloud contract executes are stops, it does so.

34
00:01:58.320 --> 00:02:04.500
Vira Tal called wire mark Why Mark is a very powerful Java based Web server

35
00:02:04.500 --> 00:02:09.670
for simulating Haiti T P a p Eyes as a standalone tool.

36
00:02:09.670 --> 00:02:14.600
It's already quite popular if in the community able to take on the variety

37
00:02:14.600 --> 00:02:19.820
of AP I simulation use cases because of this popularity.

38
00:02:19.820 --> 00:02:23.870
Rather than reinventing the wheel shrink loud Contract has chosen to

39
00:02:23.870 --> 00:02:28.640
leverage wire mark as a library for running it stops.

40
00:02:28.640 --> 00:02:31.950
This means that stuck map ings we're generating are

41
00:02:31.950 --> 00:02:34.640
actually why Mark Stop wrappings.

42
00:02:34.640 --> 00:02:36.010
Why Mark stubbed wrappings?

43
00:02:36.010 --> 00:02:39.330
Adjust Jason files They're easy to reason about and

44
00:02:39.330 --> 00:02:44.020
can easily be imported and exported, as you can imagine,

45
00:02:44.020 --> 00:02:47.780
because a contract DSL is so feature rich It must mean

46
00:02:47.780 --> 00:02:51.450
that why mark is to as it's able to implement all sorts of

47
00:02:51.450 --> 00:02:53.740
different mocking strategies.

48
00:02:53.740 --> 00:02:56.740
We'll be focusing more on knees in the next module.

49
00:02:56.740 --> 00:02:58.240
But for now just noted,

50
00:02:58.240 --> 00:03:04.570
it will be a lot of flexibility in the types of stops we can build at his core.

51
00:03:04.570 --> 00:03:08.100
Why mark functions by receiving a request on returning to

52
00:03:08.100 --> 00:03:11.140
corresponding stop mapping response.

53
00:03:11.140 --> 00:03:13.940
This works for a process called matching.

54
00:03:13.940 --> 00:03:14.150
Why?

55
00:03:14.150 --> 00:03:16.210
Why Michael Literary over each stub,

56
00:03:16.210 --> 00:03:20.440
mapping and see if any off them correspond to the request.

57
00:03:20.440 --> 00:03:24.740
Once a match is found, it will return the corresponding response.

58
00:03:24.740 --> 00:03:25.060
Why?

59
00:03:25.060 --> 00:03:29.440
Mark also ships with some really useful debugging functionality.

60
00:03:29.440 --> 00:03:31.020
So if we wouldn't dream, why stop?

61
00:03:31.020 --> 00:03:32.010
Doesn't work.

62
00:03:32.010 --> 00:03:35.780
We can easily look a stack trace or tallies information about

63
00:03:35.780 --> 00:03:38.090
why our request was not much by a stub.

64
00:03:38.090 --> 00:03:42.140
Map him well, Licata, Shortly in the next demo,

65
00:03:42.140 --> 00:03:45.970
the final missing piece in this flow is orchestration,

66
00:03:45.970 --> 00:03:48.360
which is done by it'll called the stop Runner,

67
00:03:48.360 --> 00:03:52.930
provided by Spring Cloud contract one x accuse it.

68
00:03:52.930 --> 00:03:55.500
The stub runner will download the stops it has been

69
00:03:55.500 --> 00:03:58.940
configured to get at the start of a test.

70
00:03:58.940 --> 00:04:04.540
After this, it will extract the stud muffin files from the jar into memory.

71
00:04:04.540 --> 00:04:08.650
It will then start by Mark on an important extracted stub,

72
00:04:08.650 --> 00:04:12.440
mapping files into Why Mark to set it up.

73
00:04:12.440 --> 00:04:13.370
Finally,

74
00:04:13.370 --> 00:04:17.150
the test will actually que with all the necessary dependencies

75
00:04:17.150 --> 00:04:21.190
running and configured in order to use the stop runner.

76
00:04:21.190 --> 00:04:24.940
A good starting point would be a spring boots fast.

77
00:04:24.940 --> 00:04:28.120
This is because the stop printer can be orchestrated

78
00:04:28.120 --> 00:04:31.880
violet or to configure stubborn annotation.

79
00:04:31.880 --> 00:04:35.640
This triggers are spring be auto configuration,

80
00:04:35.640 --> 00:04:39.140
meaning this simple meta data is enough to trigger the

81
00:04:39.140 --> 00:04:43.650
starting and stopping of wine mark importing data on audio

82
00:04:43.650 --> 00:04:46.740
of her pieces of functionality.

83
00:04:46.740 --> 00:04:50.190
Next, the annotation is given the i DS off the stoves,

84
00:04:50.190 --> 00:04:54.330
which should be executed first of the group i d.

85
00:04:54.330 --> 00:04:55.990
The artifacts I d.

86
00:04:55.990 --> 00:04:59.400
The version number on the classifier just like

87
00:04:59.400 --> 00:05:03.240
adding any normal babe independency.

88
00:05:03.240 --> 00:05:04.790
Next comes support.

89
00:05:04.790 --> 00:05:07.790
This is a port that why Mark will start on which can be

90
00:05:07.790 --> 00:05:11.560
provided explicitly or randomized.

91
00:05:11.560 --> 00:05:15.340
And finally we are a work or flying out of you.

92
00:05:15.340 --> 00:05:18.050
This means that Robert and looking in an extent,

93
00:05:18.050 --> 00:05:20.460
or maybe a repository for the stops,

94
00:05:20.460 --> 00:05:23.740
the stop runner will look in our local repository.

95
00:05:23.740 --> 00:05:32.000
This makes sense for this stage in the workflow as the stops have only being installed locally.

