WEBVTT
1
00:00:01.940 --> 00:00:05.180
[Autogenerated] So what would be an approach to verify that all our micro

2
00:00:05.180 --> 00:00:10.280
services are able to function together while end to end testing is a

3
00:00:10.280 --> 00:00:13.620
common choice for this riff end to end testing.

4
00:00:13.620 --> 00:00:15.940
We'd start with some automated tests,

5
00:00:15.940 --> 00:00:21.040
normally in an independent project which exist separately to our application.

6
00:00:21.040 --> 00:00:22.210
Once he's run.

7
00:00:22.210 --> 00:00:25.580
Rather than interacting directly with Far Micro Services,

8
00:00:25.580 --> 00:00:27.310
they drive interaction with them.

9
00:00:27.310 --> 00:00:32.340
For a you are Your browser is if they're a real user off the whole system.

10
00:00:32.340 --> 00:00:34.960
If you're familiar with browser based testing,

11
00:00:34.960 --> 00:00:38.290
a tour like Cellini, um, could come into play here.

12
00:00:38.290 --> 00:00:41.800
Finally, that browser interacts with the back end system,

13
00:00:41.800 --> 00:00:45.450
which in this case will be all our micro services together,

14
00:00:45.450 --> 00:00:49.850
forming a single software application to emphasize we are

15
00:00:49.850 --> 00:00:51.990
international individual Michael Services.

16
00:00:51.990 --> 00:00:55.480
Here it all we're testing everything together is if

17
00:00:55.480 --> 00:00:57.840
we're a really user off the system.

18
00:00:57.840 --> 00:01:00.860
So at first glance, this approach seems good.

19
00:01:00.860 --> 00:01:02.820
Were testing the whole application,

20
00:01:02.820 --> 00:01:07.140
which intern guarantees all of its integration points of functional?

21
00:01:07.140 --> 00:01:09.730
But the reality is that there are many short comments with

22
00:01:09.730 --> 00:01:12.740
testing Michael Services in this way.

23
00:01:12.740 --> 00:01:15.610
First of all, these tests are very slow.

24
00:01:15.610 --> 00:01:20.360
In fact, it's not uncommon for organizations to end up with end to end test runs.

25
00:01:20.360 --> 00:01:22.020
It takes several hours.

26
00:01:22.020 --> 00:01:24.060
This is, of course, an anti pattern,

27
00:01:24.060 --> 00:01:27.040
because micro services should be quick and easy to test

28
00:01:27.040 --> 00:01:29.890
and release failures for end to end.

29
00:01:29.890 --> 00:01:32.440
Tests are also hard to deep oak.

30
00:01:32.440 --> 00:01:34.410
One of browser based test fails.

31
00:01:34.410 --> 00:01:37.380
It won't give us a stack trace just a message about

32
00:01:37.380 --> 00:01:40.340
something being unexpected in new I.

33
00:01:40.340 --> 00:01:42.010
So to find a real cause,

34
00:01:42.010 --> 00:01:46.570
we need to trace really aggregated locks of many micro services and try

35
00:01:46.570 --> 00:01:50.340
and figure out specifically where something went wrong.

36
00:01:50.340 --> 00:01:53.640
This is particularly problematic when working with asynchronous

37
00:01:53.640 --> 00:01:56.750
values when some finished synchronous the core fouls

38
00:01:56.750 --> 00:01:59.230
immediately wise with asynchronous calls,

39
00:01:59.230 --> 00:02:00.340
it does no.

40
00:02:00.340 --> 00:02:03.230
So we have to figure out how to map together the production and

41
00:02:03.230 --> 00:02:07.190
consumption of messages across many micro services in order to

42
00:02:07.190 --> 00:02:11.470
determine if value cause we're not saving on cost here,

43
00:02:11.470 --> 00:02:16.440
Eva, we need to produce an entire environment in order to run these tests,

44
00:02:16.440 --> 00:02:20.710
meaning that I infrastructure bill will go up is also common to have a

45
00:02:20.710 --> 00:02:24.900
limit on the amount of environments we can have running at once so and

46
00:02:24.900 --> 00:02:29.040
so and test runs can quite often end up in a queue whilst previous ones

47
00:02:29.040 --> 00:02:31.040
have an environment locked.

48
00:02:31.040 --> 00:02:34.940
Running these types of tests is also operationally challenging.

49
00:02:34.940 --> 00:02:38.050
We need to provisioning infrastructure for a whole environment,

50
00:02:38.050 --> 00:02:41.180
deploy all our micro service together in this environment,

51
00:02:41.180 --> 00:02:44.430
setting up any necessary conflict to coordinate the mall.

52
00:02:44.430 --> 00:02:47.810
Guivarc'h I server access to it on lots more.

53
00:02:47.810 --> 00:02:50.260
Running some tests against a single execute herbal

54
00:02:50.260 --> 00:02:52.840
jar would have been a lot simpler.

55
00:02:52.840 --> 00:02:55.540
Flakiness is also a problem here.

56
00:02:55.540 --> 00:02:58.640
Browser based testing or you I testing is just not as

57
00:02:58.640 --> 00:03:00.630
reliable as we'd like it to be.

58
00:03:00.630 --> 00:03:03.890
Quite often failing due to timing issues.

59
00:03:03.890 --> 00:03:06.850
Imagine how much of an issue this convict come when it build is

60
00:03:06.850 --> 00:03:10.180
four hours and fouls it run them each time.

61
00:03:10.180 --> 00:03:11.080
The final issue.

62
00:03:11.080 --> 00:03:15.170
If this approach is that where implementing a micro services anti pattern.

63
00:03:15.170 --> 00:03:16.300
The distributed model.

64
00:03:16.300 --> 00:03:19.760
If what this means is that we're negating many of the

65
00:03:19.760 --> 00:03:22.980
benefits of micro services and are instead testing

66
00:03:22.980 --> 00:03:26.240
everything together as if it's a monolith.

67
00:03:26.240 --> 00:03:27.770
If this is a way to do it,

68
00:03:27.770 --> 00:03:29.700
we could argue that a model if would have been a

69
00:03:29.700 --> 00:03:31.720
better choice in the first place.

70
00:03:31.720 --> 00:03:38.000
As his less network hops to follow on, it's easy to orchestrate. I'm deploy

