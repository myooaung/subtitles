WEBVTT
1
00:00:02.040 --> 00:00:06.540
[Autogenerated] So are the benefits of consumer driven contract testing.

2
00:00:06.540 --> 00:00:09.660
Is it really worth it over the traditional approaches

3
00:00:09.660 --> 00:00:13.340
off into an testing or stop him?

4
00:00:13.340 --> 00:00:17.140
While the feedback loop is now dramatically improved,

5
00:00:17.140 --> 00:00:20.230
we no longer have to weigh an eternity for our micro

6
00:00:20.230 --> 00:00:24.480
services to build deploy on bientot untested.

7
00:00:24.480 --> 00:00:28.340
Now we can run our local contract us instead.

8
00:00:28.340 --> 00:00:29.280
Also,

9
00:00:29.280 --> 00:00:34.710
as these contract has to continually verified on both sides of our interaction,

10
00:00:34.710 --> 00:00:37.220
it means we don't have the problem of style tests

11
00:00:37.220 --> 00:00:39.440
like we would do with stubbing.

12
00:00:39.440 --> 00:00:42.170
Delivering features is now a lot easier,

13
00:00:42.170 --> 00:00:44.520
as we have two strong feedback fast,

14
00:00:44.520 --> 00:00:48.980
reliable local build failures by the contract tests filling

15
00:00:48.980 --> 00:00:51.980
the gap left behind by into n testing.

16
00:00:51.980 --> 00:00:56.140
We can decommission some of our end so and test environments.

17
00:00:56.140 --> 00:00:59.390
This is because we simply don't need to run them as much as

18
00:00:59.390 --> 00:01:02.640
we did before or even after some changes.

19
00:01:02.640 --> 00:01:04.240
Not at all.

20
00:01:04.240 --> 00:01:06.080
From a business perspective,

21
00:01:06.080 --> 00:01:08.390
this saves his money as we're paying less for

22
00:01:08.390 --> 00:01:11.950
infrastructure as opposed to provider,

23
00:01:11.950 --> 00:01:16.370
creating an M point which may not be exactly what the consumers want.

24
00:01:16.370 --> 00:01:21.260
The consumers now drive the A P I themselves through two contracts this

25
00:01:21.260 --> 00:01:25.620
means we are always implementing what is required for a feature by

26
00:01:25.620 --> 00:01:29.340
giving the consumer exactly what they ask for.

27
00:01:29.340 --> 00:01:32.940
It's no longer possible for there to be any misconceptions.

28
00:01:32.940 --> 00:01:35.880
Andi things not really working correctly when sink

29
00:01:35.880 --> 00:01:38.090
top together for the first time,

30
00:01:38.090 --> 00:01:41.600
trying to figure out what depends on what on whether a change

31
00:01:41.600 --> 00:01:45.600
to an A P I will break any fan is now easy.

32
00:01:45.600 --> 00:01:49.300
This is because every single micro service interaction is to

33
00:01:49.300 --> 00:01:53.890
finding contracts if a provider is changed than the

34
00:01:53.890 --> 00:01:56.290
contracts it has with its consumers,

35
00:01:56.290 --> 00:02:00.990
or tell us whether we break the interaction with those consumers.

36
00:02:00.990 --> 00:02:04.800
This demonstrates how powerful consume a gym and contract testing

37
00:02:04.800 --> 00:02:08.610
really is as the office aggression that we would over wise need

38
00:02:08.610 --> 00:02:12.910
and two in testing for and gives us an automated view of how

39
00:02:12.910 --> 00:02:15.190
everything links together.

40
00:02:15.190 --> 00:02:19.640
It also becomes a lot easier to develop in parallel.

41
00:02:19.640 --> 00:02:23.440
All that really needs to be done upfront is a contract.

42
00:02:23.440 --> 00:02:25.070
Once this is defined,

43
00:02:25.070 --> 00:02:28.540
both the provider under consumer can be implemented

44
00:02:28.540 --> 00:02:31.820
together at the same time on again.

45
00:02:31.820 --> 00:02:35.910
Because of the fantastic feedback given by the contract tests,

46
00:02:35.910 --> 00:02:39.180
we will know that when deployed together for the first time

47
00:02:39.180 --> 00:02:42.870
they will be able to communicate without failure by

48
00:02:42.870 --> 00:02:45.360
continually testing against the contract.

49
00:02:45.360 --> 00:02:47.640
On both sides of the interaction,

50
00:02:47.640 --> 00:02:52.000
it is literally impossible for a contract to become stale.

51
00:02:52.000 --> 00:02:54.700
We're stopping the stop can end up being completely

52
00:02:54.700 --> 00:02:56.940
different to the rial provider,

53
00:02:56.940 --> 00:03:04.000
whereas here the continuous testing on the provider side would prevent that from ever happening.

