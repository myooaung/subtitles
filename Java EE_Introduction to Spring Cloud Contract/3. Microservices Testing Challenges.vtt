WEBVTT
1
00:00:02.040 --> 00:00:03.630
[Autogenerated] So now we've given the high level

2
00:00:03.630 --> 00:00:06.380
overview of micro services architectures.

3
00:00:06.380 --> 00:00:09.080
We're going to look at some of their challenges in this

4
00:00:09.080 --> 00:00:12.340
case specifically in relation to testing.

5
00:00:12.340 --> 00:00:15.650
Many people see micro services as a silver bullet,

6
00:00:15.650 --> 00:00:18.800
solving many of our previous problems on helping us to

7
00:00:18.800 --> 00:00:21.840
deliver software faster and more reliably.

8
00:00:21.840 --> 00:00:22.740
However,

9
00:00:22.740 --> 00:00:25.520
the reality is that silver bullets in technology are

10
00:00:25.520 --> 00:00:28.100
always a delusion on don't really exist.

11
00:00:28.100 --> 00:00:32.160
There are only trade offs, starting with an example,

12
00:00:32.160 --> 00:00:34.950
Let's say we're working on a payment service.

13
00:00:34.950 --> 00:00:36.390
If you make a change to it,

14
00:00:36.390 --> 00:00:40.120
we can run some automated tests against it and then on a green build,

15
00:00:40.120 --> 00:00:41.940
deploy its A production.

16
00:00:41.940 --> 00:00:44.090
However, with micro service,

17
00:00:44.090 --> 00:00:48.510
there's usually some sort of inter service communication with another service.

18
00:00:48.510 --> 00:00:52.840
Let's say our payment service is depended on by an account service.

19
00:00:52.840 --> 00:00:55.790
This could be via Haiti, T p A P I.

20
00:00:55.790 --> 00:00:59.540
If we mess up our your own mapping or our request than this,

21
00:00:59.540 --> 00:01:01.530
dependency can be broken.

22
00:01:01.530 --> 00:01:04.730
In other words, these services is still couple together.

23
00:01:04.730 --> 00:01:06.490
Free message passing.

24
00:01:06.490 --> 00:01:10.580
In fact, this problem can be compounded because more often than not,

25
00:01:10.580 --> 00:01:14.440
they could be multiple dependencies across micro services.

26
00:01:14.440 --> 00:01:17.890
So again with all these interdependent micro services,

27
00:01:17.890 --> 00:01:20.790
how do we build and release one independently with the

28
00:01:20.790 --> 00:01:23.010
confidence that nothing's been broken?

29
00:01:23.010 --> 00:01:25.100
Because, really, they're still coupled for you.

30
00:01:25.100 --> 00:01:26.740
This matches passing.

31
00:01:26.740 --> 00:01:29.110
Or if we're implementing a new feature,

32
00:01:29.110 --> 00:01:32.380
which will span multiple Marcus services again,

33
00:01:32.380 --> 00:01:36.730
how do we know that they will function together correctly in advance?

34
00:01:36.730 --> 00:01:38.800
This makes you realize that more traditional,

35
00:01:38.800 --> 00:01:42.890
monolithic applications are simply to test because traditional

36
00:01:42.890 --> 00:01:46.080
applications are in a single process that could be tested

37
00:01:46.080 --> 00:01:49.240
locally with no external dependencies.

38
00:01:49.240 --> 00:01:52.540
That means if it works, it probably works.

39
00:01:52.540 --> 00:01:55.900
The next that we may follow is to move to more asynchronous

40
00:01:55.900 --> 00:01:59.400
based approach for into service communication.

41
00:01:59.400 --> 00:02:04.420
This has lots of advantages, mainly around scaling and decoupling of services.

42
00:02:04.420 --> 00:02:07.980
Durability guarantees on the ability for messages to be

43
00:02:07.980 --> 00:02:11.340
buffered in order to know overwhelm consumers.

44
00:02:11.340 --> 00:02:14.470
However, a common misconception far too common,

45
00:02:14.470 --> 00:02:19.640
in fact, is that this decoupling via messaging will solve our original problem.

46
00:02:19.640 --> 00:02:22.490
Whilst it's true that when I produce the publishers of message

47
00:02:22.490 --> 00:02:25.040
only cares about the broker receiving it,

48
00:02:25.040 --> 00:02:28.590
ultimately consumers will still need to be able to consume it,

49
00:02:28.590 --> 00:02:32.540
even if failing to do so does not break the consumer.

50
00:02:32.540 --> 00:02:33.340
So really,

51
00:02:33.340 --> 00:02:36.120
we need some sort of a guarantee that messages we can

52
00:02:36.120 --> 00:02:44.000
produce will be consumed by its consumers. Offer wise will have an asynchronous debugging nightmare.

