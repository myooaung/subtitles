WEBVTT
1
00:00:02.040 --> 00:00:07.140
[Autogenerated] currently 22 contracts we have created contained static data.

2
00:00:07.140 --> 00:00:09.790
This means that in order to be complied with,

3
00:00:09.790 --> 00:00:12.980
a specific request and response must be made,

4
00:00:12.980 --> 00:00:15.640
they exactly match the contract.

5
00:00:15.640 --> 00:00:21.440
However, the reality is that lots of software applications generate random data,

6
00:00:21.440 --> 00:00:24.380
and in turn, our contracts may need to support this,

7
00:00:24.380 --> 00:00:25.840
too.

8
00:00:25.840 --> 00:00:27.310
For example,

9
00:00:27.310 --> 00:00:31.830
let's say we make a post request to a payments M point we may need

10
00:00:31.830 --> 00:00:35.000
to provide a body that contains a yo yo i d.

11
00:00:35.000 --> 00:00:37.240
A time on the Mount.

12
00:00:37.240 --> 00:00:42.310
And in turn, a responsive to one is given thinking about this.

13
00:00:42.310 --> 00:00:44.340
You ideas unique.

14
00:00:44.340 --> 00:00:49.350
So if they're generated by consuming micro service each time we make a request,

15
00:00:49.350 --> 00:00:51.340
they would change.

16
00:00:51.340 --> 00:00:52.150
In fact,

17
00:00:52.150 --> 00:00:56.100
are consuming micro service might send a different time value

18
00:00:56.100 --> 00:01:00.300
each time it makes a request to the dynamic nature of

19
00:01:00.300 --> 00:01:03.900
interactions like this needs to be considered when dealing with

20
00:01:03.900 --> 00:01:09.910
consumer driven contract testing.

21
00:01:09.910 --> 00:01:14.340
So how do we deal with this dynamic or run them data?

22
00:01:14.340 --> 00:01:17.760
The first idea is to have a single static contract

23
00:01:17.760 --> 00:01:20.740
for every single possible request.

24
00:01:20.740 --> 00:01:24.940
This would work if there was a small, fine eight set of possible values,

25
00:01:24.940 --> 00:01:27.740
but it could also end up being pretty time consuming and of

26
00:01:27.740 --> 00:01:30.410
maintainable with something like a date,

27
00:01:30.410 --> 00:01:32.850
though it wouldn't work at all because there's an

28
00:01:32.850 --> 00:01:36.610
infinite amount of possible values.

29
00:01:36.610 --> 00:01:40.540
Committing a dynamic part from the contract is also an option.

30
00:01:40.540 --> 00:01:44.370
So if there was a day in the request body which changed each time,

31
00:01:44.370 --> 00:01:46.390
it could simply be ignored.

32
00:01:46.390 --> 00:01:48.770
The problem with this strategy is that if you

33
00:01:48.770 --> 00:01:52.980
forget to send the date altogether, the contract would still be met.

34
00:01:52.980 --> 00:01:56.840
Given this false positives about the request that we make,

35
00:01:56.840 --> 00:02:00.030
what we actually want is for the contract to still require a day,

36
00:02:00.030 --> 00:02:05.840
after all, but just not care about the specific value off it.

37
00:02:05.840 --> 00:02:11.010
We could also try mocking the classes that generate run them data, for example.

38
00:02:11.010 --> 00:02:12.740
We could create a fits clock, too.

39
00:02:12.740 --> 00:02:16.910
Always return to the same time or your I d generator toe

40
00:02:16.910 --> 00:02:18.620
always returns the same you your i.

41
00:02:18.620 --> 00:02:19.940
D.

42
00:02:19.940 --> 00:02:24.840
This is actually a reasonable approach on Doing so would not be a bad idea,

43
00:02:24.840 --> 00:02:27.550
but one thing to consider is that by using marks,

44
00:02:27.550 --> 00:02:30.260
there is a risk of false positives due to fake in

45
00:02:30.260 --> 00:02:34.960
parts of the application codes, and we're also introducing an overhead,

46
00:02:34.960 --> 00:02:38.030
saying them up and maintaining them.

47
00:02:38.030 --> 00:02:40.740
So while store, these options are possible,

48
00:02:40.740 --> 00:02:42.860
none of them quite to what we need,

49
00:02:42.860 --> 00:02:47.540
which is for a contract to comply with random data but also expect out run

50
00:02:47.540 --> 00:02:54.640
them data to be present instructions in a certain way.

51
00:02:54.640 --> 00:02:58.530
Frank Fully Sprinklered contract does have in of a way of working

52
00:02:58.530 --> 00:03:02.640
with random data on its three regular expressions.

53
00:03:02.640 --> 00:03:03.070
Robbing.

54
00:03:03.070 --> 00:03:06.440
Giving a normal definition will give won in a contest

55
00:03:06.440 --> 00:03:09.540
of consumer driven contract testing.

56
00:03:09.540 --> 00:03:11.590
Regular expressions are patterns,

57
00:03:11.590 --> 00:03:14.840
which enable a single contract to be met by multiple

58
00:03:14.840 --> 00:03:17.810
possible requests and responses.

59
00:03:17.810 --> 00:03:22.120
In other words, we could have a regular expression pattern in our contract,

60
00:03:22.120 --> 00:03:24.380
which requires a Valley Geo i D.

61
00:03:24.380 --> 00:03:29.240
But doesn't care about the specific value off that you i d.

62
00:03:29.240 --> 00:03:33.210
There's actually a geeky joke about this, which is You have a problem.

63
00:03:33.210 --> 00:03:37.740
You try and solve with regular expressions, and then you have to problems.

64
00:03:37.740 --> 00:03:40.890
This is actually treat to a certain degree with Java,

65
00:03:40.890 --> 00:03:43.790
But spring cloud contract and groovy actually make

66
00:03:43.790 --> 00:03:46.160
rejects a lot simpler to work with,

67
00:03:46.160 --> 00:03:52.360
which will soon see in the following examples to

68
00:03:52.360 --> 00:03:54.240
demonstrate what we can achieve Afraid.

69
00:03:54.240 --> 00:03:54.940
Jax.

70
00:03:54.940 --> 00:03:56.160
Let's look at an example.

71
00:03:56.160 --> 00:03:57.740
Contract.

72
00:03:57.740 --> 00:04:01.830
Here we expect a post request to slash Hello World with

73
00:04:01.830 --> 00:04:04.840
the name quantity a new your I D on.

74
00:04:04.840 --> 00:04:07.940
We expect a response of ______ one.

75
00:04:07.940 --> 00:04:13.250
What we'd like is for a contract to expect a Jason we provided but a little

76
00:04:13.250 --> 00:04:18.880
looser and allow for any name quantity or you i d values.

77
00:04:18.880 --> 00:04:23.080
So starting with name, we can replace it with a regular expression,

78
00:04:23.080 --> 00:04:28.560
which requires any Alfa character any number of times for quantity.

79
00:04:28.560 --> 00:04:30.740
We can create a regular expression.

80
00:04:30.740 --> 00:04:34.940
They expects any valid number I'm finally for the u I.

81
00:04:34.940 --> 00:04:35.720
D.

82
00:04:35.720 --> 00:04:38.700
We can create a wretch jacks they expects any year.

83
00:04:38.700 --> 00:04:40.280
I d.

84
00:04:40.280 --> 00:04:42.380
For those unfamiliar if rejects,

85
00:04:42.380 --> 00:04:46.240
thes expressions can be a little challenging to understand.

86
00:04:46.240 --> 00:04:49.520
Fortunately, we're working with the spring cloud contract.

87
00:04:49.520 --> 00:04:53.740
DSL, which makes things easy for us, is possible.

88
00:04:53.740 --> 00:04:57.170
So common expressions like this already provided for

89
00:04:57.170 --> 00:04:59.990
us as pre defined expressions.

90
00:04:59.990 --> 00:05:08.000
So most of the time we congest use these help him efforts without having to deal with Fred Jenks directly

