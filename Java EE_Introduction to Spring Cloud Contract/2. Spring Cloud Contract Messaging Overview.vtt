WEBVTT
1
00:00:01.940 --> 00:00:03.870
[Autogenerated] unlike what we've seen so far,

2
00:00:03.870 --> 00:00:08.200
micro services do not always communicate synchronously.

3
00:00:08.200 --> 00:00:14.780
In fact, message driven or asynchronous communication tends to me just is common.

4
00:00:14.780 --> 00:00:17.520
This isn't a Micra Service architecture course,

5
00:00:17.520 --> 00:00:21.840
so we won't go into too much detail about which of the team efforts to use.

6
00:00:21.840 --> 00:00:27.300
But we will go into a high level overview of how messaging works.

7
00:00:27.300 --> 00:00:29.720
If we take a provider under she Met,

8
00:00:29.720 --> 00:00:33.240
uses messaging for inter service communication,

9
00:00:33.240 --> 00:00:37.040
then certain actions will cause it to send the message.

10
00:00:37.040 --> 00:00:39.060
However, unlike with hate,

11
00:00:39.060 --> 00:00:43.530
TTP messages don't go directly to another micro service.

12
00:00:43.530 --> 00:00:49.020
Instead, they end up a message broker on Once a message has ended up there,

13
00:00:49.020 --> 00:00:51.590
the providers work is done.

14
00:00:51.590 --> 00:00:53.720
It is then the responsibility off.

15
00:00:53.720 --> 00:00:57.240
The broker, to then acknowledge it has received the message on them.

16
00:00:57.240 --> 00:01:00.200
Forward it onto the correct place.

17
00:01:00.200 --> 00:01:04.480
This will generally be to a consumer or in some cases,

18
00:01:04.480 --> 00:01:08.310
as messengers confine out and be routed to multiple places.

19
00:01:08.310 --> 00:01:10.690
They can end up with many consumers,

20
00:01:10.690 --> 00:01:15.240
making a journey slightly more complex and hasty t pay.

21
00:01:15.240 --> 00:01:18.420
So there are a few advantages to this approach.

22
00:01:18.420 --> 00:01:19.570
For example,

23
00:01:19.570 --> 00:01:23.020
there's a durability guarantees as Broca's can persist

24
00:01:23.020 --> 00:01:25.820
messages to ensure they are delivered.

25
00:01:25.820 --> 00:01:29.280
They can also retry failed messages on buffered him to

26
00:01:29.280 --> 00:01:32.640
prevent overwhelming off a consumer.

27
00:01:32.640 --> 00:01:36.980
But a core benefit is a decoupling of micro services as now,

28
00:01:36.980 --> 00:01:40.100
they no longer depend on each other directly.

29
00:01:40.100 --> 00:01:43.420
This means that our provider could be tested in isolation,

30
00:01:43.420 --> 00:01:47.620
with only the broker under consumers can also be tested

31
00:01:47.620 --> 00:01:50.710
in isolation with only the broker.

32
00:01:50.710 --> 00:01:54.440
This decoupling House Micro Services become autonomous,

33
00:01:54.440 --> 00:01:58.010
but can also lead to the misconception that consumer driven

34
00:01:58.010 --> 00:02:03.740
contract Chastain would not be needed her.

35
00:02:03.740 --> 00:02:08.280
So why would we need consumer driven contract testing if our micro

36
00:02:08.280 --> 00:02:12.740
services no longer communicate with each other directly?

37
00:02:12.740 --> 00:02:16.500
Well, first of all, there is actually still some coupling.

38
00:02:16.500 --> 00:02:20.790
If a message is consumed from a Q than the producer of that message,

39
00:02:20.790 --> 00:02:22.900
must correctly produce messages to do.

40
00:02:22.900 --> 00:02:24.240
Q.

41
00:02:24.240 --> 00:02:28.870
If there was a mismatch in Q names deter an error in configuration,

42
00:02:28.870 --> 00:02:32.380
the messages would get lost without being an error.

43
00:02:32.380 --> 00:02:35.740
The same principle applies to Messi schemers.

44
00:02:35.740 --> 00:02:38.580
If a consumer expect certain Jason,

45
00:02:38.580 --> 00:02:41.610
then we need to be able to guarantee that all messages

46
00:02:41.610 --> 00:02:44.440
we produce comply with that schemer.

47
00:02:44.440 --> 00:02:45.340
Otherwise,

48
00:02:45.340 --> 00:02:49.030
even if we are able to produce our messages with no errors

49
00:02:49.030 --> 00:02:52.680
are consumers could still start for in exceptions as they

50
00:02:52.680 --> 00:02:55.370
felt on Marshall the payloads.

51
00:02:55.370 --> 00:02:59.200
So, really, although we are decoupled Vira broker,

52
00:02:59.200 --> 00:03:02.820
were still coupled in message schemers que names on

53
00:03:02.820 --> 00:03:05.940
any over common configuration.

54
00:03:05.940 --> 00:03:09.300
The next thing to consider is that is a certain amount

55
00:03:09.300 --> 00:03:11.730
of overhead in running a broker.

56
00:03:11.730 --> 00:03:15.380
They don't star instantly, so console oh down a build or test run,

57
00:03:15.380 --> 00:03:16.970
which depends on them.

58
00:03:16.970 --> 00:03:20.880
They also consume Resource is and can introduce operational

59
00:03:20.880 --> 00:03:25.650
overhead by having to set up and configure them as messages

60
00:03:25.650 --> 00:03:28.340
confront out to multiple consumers.

61
00:03:28.340 --> 00:03:31.360
This makes it important to be able to guarantee their

62
00:03:31.360 --> 00:03:34.040
every interaction works correctly.

63
00:03:34.040 --> 00:03:36.960
This is because the amounts of possible places where things

64
00:03:36.960 --> 00:03:40.080
can go wrong can sometimes be very high.

65
00:03:40.080 --> 00:03:41.210
And finally,

66
00:03:41.210 --> 00:03:45.900
probably the most important thing to consider is just how hard asynchronous

67
00:03:45.900 --> 00:03:51.540
communication is to de book when things go wrong with a synchronous hate TTP

68
00:03:51.540 --> 00:03:55.890
call failures occur immediately when a request is made.

69
00:03:55.890 --> 00:04:00.200
This makes him easy to find in locks with the messaging approach

70
00:04:00.200 --> 00:04:03.840
manages can successfully be published to the brokers,

71
00:04:03.840 --> 00:04:06.690
even if somewhere downstream the consumer fells toe,

72
00:04:06.690 --> 00:04:10.340
Marshall it, or even listening to the wrong cue.

73
00:04:10.340 --> 00:04:15.020
If a system is large with lots of messages and network harps than finding the

74
00:04:15.020 --> 00:04:19.040
cause of these sorts of asynchronous problems is challenging.

75
00:04:19.040 --> 00:04:23.010
So because of this complexity is much better.

76
00:04:23.010 --> 00:04:25.200
Toe have reliable contract tests,

77
00:04:25.200 --> 00:04:33.440
which negate a chance of these sorts of books occurring in the first place,

78
00:04:33.440 --> 00:04:38.940
so support for messaging is built into spring cloud contract out of the box.

79
00:04:38.940 --> 00:04:42.980
The spring cloud contract DSL that we've been working with also

80
00:04:42.980 --> 00:04:46.640
allows you to define message driven interactions.

81
00:04:46.640 --> 00:04:48.890
There's not much of a learning curve here,

82
00:04:48.890 --> 00:04:52.790
as these types of contracts are very similar to the hate TTP driven

83
00:04:52.790 --> 00:04:56.690
ones that we've already developed out of the box.

84
00:04:56.690 --> 00:05:01.290
Apache Camel Spring Integration, Spring Cloud Stream on Spring AM,

85
00:05:01.290 --> 00:05:04.840
QPR supported thanks to spring boot.

86
00:05:04.840 --> 00:05:08.490
If one of these is on the class path, then everything will be all taken.

87
00:05:08.490 --> 00:05:09.570
Figures.

88
00:05:09.570 --> 00:05:12.950
This means it should be easy to integrate spring cloud contract

89
00:05:12.950 --> 00:05:18.600
messaging into your existing projects with next to no configuration in

90
00:05:18.600 --> 00:05:21.900
order to trigger messages for consumer side tests.

91
00:05:21.900 --> 00:05:24.810
A stuffed trigger abstraction is provided.

92
00:05:24.810 --> 00:05:28.280
This meets contracts easy to orchestrate joing tests on.

93
00:05:28.280 --> 00:05:31.900
We'll be looking at how to do this shortly.

94
00:05:31.900 --> 00:05:35.050
Finally, just like with hate TTP,

95
00:05:35.050 --> 00:05:43.000
message driven contracts are automatically converted into provider side verification tests.

