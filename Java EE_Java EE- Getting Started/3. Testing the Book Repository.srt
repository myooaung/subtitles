1
00:00:02,439 --> 00:00:06,817
To understand where the boundary between unit and integration test is,

2
00:00:06,817 --> 00:00:11,694
let's test our book repository using both methods.

3
00:00:11,694 --> 00:00:19,431
In unit tests we test only one class here, book repository, in isolation.

4
00:00:19,431 --> 00:00:23,493
This means that we do not use container services such

5
00:00:23,493 --> 00:00:31,463
as database mapping or transaction, or we mock those container services.

6
00:00:31,463 --> 00:00:34,739
Let's say we have this simple create method that takes a

7
00:00:34,739 --> 00:00:37,482
book as a parameter and returns it.

8
00:00:37,482 --> 00:00:42,140
How do we unit test this code with JUnit?

9
00:00:42,140 --> 00:00:45,431
Well using a JUnit test case,

10
00:00:45,431 --> 00:00:50,798
by convention we call this class BookRepositoryTest and create

11
00:00:50,798 --> 00:00:56,334
as many methods we need annotated with test.

12
00:00:56,334 --> 00:01:01,146
This should create a book method, creates a Book object with some data,

13
00:01:01,146 --> 00:01:04,628
invokes the create method of the BookRepository and

14
00:01:04,628 --> 00:01:07,836
makes sure the Book object is not null.

15
00:01:07,836 --> 00:01:13,428
If you look carefully at this code, there is one thing missing.

16
00:01:13,428 --> 00:01:18,488
We need to instantiate the BookRepository class.

17
00:01:18,488 --> 00:01:19,481
That's it.

18
00:01:19,481 --> 00:01:23,455
Now if we execute this test it passes.

19
00:01:23,455 --> 00:01:23,893
Great.

20
00:01:23,893 --> 00:01:28,715
But this is not the code we have in our BookRepository.

21
00:01:28,715 --> 00:01:33,496
We actually inject the EntityManager to persist a book

22
00:01:33,496 --> 00:01:37,221
into the database in a transactional way.

23
00:01:37,221 --> 00:01:40,951
Our unit test does not work anymore.

24
00:01:40,951 --> 00:01:41,509
Why?

25
00:01:41,509 --> 00:01:47,088
Because the EntityManager needs to get injected by the container.

26
00:01:47,088 --> 00:01:50,699
Testing in isolation we don't have a container.

27
00:01:50,699 --> 00:01:56,613
We don't have the service of injection and therefore the EntityManager is null.

28
00:01:56,613 --> 00:02:02,914
Calling the method persist will throw a null pointer exception.

29
00:02:02,914 --> 00:02:06,397
This test will fail.

30
00:02:06,397 --> 00:02:08,447
That's when we switch to integration tests,

31
00:02:08,447 --> 00:02:11,364
when we need to access the container services.

32
00:02:11,364 --> 00:02:17,175
So the way Arquillian works is that it packages the business code,

33
00:02:17,175 --> 00:02:21,043
here the book repository and the book entity,

34
00:02:21,043 --> 00:02:23,708
and the test class altogether.

35
00:02:23,708 --> 00:02:29,281
Then it automatically deploys the archive into WildFly and

36
00:02:29,281 --> 00:02:34,030
executes the test inside the container.

37
00:02:34,030 --> 00:02:37,823
So let's go back to our test class.

38
00:02:37,823 --> 00:02:43,366
Arquillian integrates with JUnit so we won't need much to make this test pass.

39
00:02:43,366 --> 00:02:44,320
First of all,

40
00:02:44,320 --> 00:02:48,787
to use Arquillian we just annotate the class with a specific Arquillian runner.

41
00:02:48,787 --> 00:02:55,980
Then we need to refactor this code a bit by removing the book

42
00:02:55,980 --> 00:03:00,218
repository initialization and instead use injection.

43
00:03:00,218 --> 00:03:02,138
Now the integration test works,

44
00:03:02,138 --> 00:03:06,169
the repository inserts a book into the database in a

45
00:03:06,169 --> 00:03:10,389
transactional way and the book identifier is generated by

46
00:03:10,389 --> 00:03:15,534
JPA and can be checked is not null.

47
00:03:15,534 --> 00:03:21,395
For the integration test to work, we rely on the Arquillian run time.

48
00:03:21,395 --> 00:03:25,490
Before executing this test we need to package our business

49
00:03:25,490 --> 00:03:30,059
code so Arquillian can deploy it to WildFly.

50
00:03:30,059 --> 00:03:33,031
For this we use ShrinkWrap.

51
00:03:33,031 --> 00:03:38,970
ShrinkWrap is an API to create deployable archives such as jar,

52
00:03:38,970 --> 00:03:41,129
war, or zip files.

53
00:03:41,129 --> 00:03:45,644
It can even add external dependencies if needed.

54
00:03:45,644 --> 00:03:52,316
ShrinkWrap creates the archive, Arquillian deploys the archive.

55
00:03:52,316 --> 00:03:53,797
To create an archive,

56
00:03:53,797 --> 00:03:58,156
our test class needs to have a method here called

57
00:03:58,156 --> 00:04:02,262
createDeploymentPackage annotated with Deployment.

58
00:04:02,262 --> 00:04:05,640
Notice that this method returns an archive.

59
00:04:05,640 --> 00:04:10,060
We use ShrinkWrap to create a JavaArchive.

60
00:04:10,060 --> 00:04:14,733
It also could have been a WebArchive if we wanted to.

61
00:04:14,733 --> 00:04:19,219
Then it's just a matter of adding the business code to the

62
00:04:19,219 --> 00:04:24,093
archive and the needed deployment descriptor,

63
00:04:24,093 --> 00:04:27,000
here the JPA persistence. xml.

