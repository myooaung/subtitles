WEBVTT
1
00:00:01.040 --> 00:00:05.180
[Autogenerated] connecting to a dynamodb table in your code base will require

2
00:00:05.180 --> 00:00:09.990
the AWS sdK so we'll get some more experience working with it will be

3
00:00:09.990 --> 00:00:14.920
changing code for both our toppings and users but we can create a common

4
00:00:14.920 --> 00:00:17.920
interface for them to interact with dynamo dB.

5
00:00:17.920 --> 00:00:21.820
Thus making it much more modular in the data folder,

6
00:00:21.820 --> 00:00:26.640
create a new file called dynamos store dot Js.

7
00:00:26.640 --> 00:00:33.140
We'll start by importing a few modular constructors from the AWS SDK,

8
00:00:33.140 --> 00:00:38.020
create a new const with curly braces inside it,

9
00:00:38.020 --> 00:00:43.620
enter dynamodb client then outside of the curly braces,

10
00:00:43.620 --> 00:00:50.410
adding equals and require the at aWS dash sDK slash

11
00:00:50.410 --> 00:00:54.340
client dash dynamo DB dependency.

12
00:00:54.340 --> 00:00:57.770
We're only getting the client here because we're going to use a

13
00:00:57.770 --> 00:01:01.640
special document client to help us with the commands.

14
00:01:01.640 --> 00:01:04.680
This document client will handle the marshaling and on

15
00:01:04.680 --> 00:01:08.980
marshalling of javascript objects into dynamo db JSON

16
00:01:08.980 --> 00:01:12.040
which will save us a lot of work,

17
00:01:12.040 --> 00:01:17.080
declare another const under that with curly braces in the curly braces,

18
00:01:17.080 --> 00:01:20.140
there will be several properties to import.

19
00:01:20.140 --> 00:01:27.840
Start with the dynamo db document client then add get command,

20
00:01:27.840 --> 00:01:33.840
then put command and finally scan command.

21
00:01:33.840 --> 00:01:35.570
Then after the curly braces,

22
00:01:35.570 --> 00:01:43.340
require the at aWS dash sdk slash lib dash dynamo db.

23
00:01:43.340 --> 00:01:48.340
These commands and this document client are from a higher level library in

24
00:01:48.340 --> 00:01:53.360
the AWS SDK So in this file we're going to be implementing three different

25
00:01:53.360 --> 00:01:56.750
functions for dynamo dB operations because of this,

26
00:01:56.750 --> 00:02:00.340
I'd like to simplify the client creation,

27
00:02:00.340 --> 00:02:02.850
create a new function and name it.

28
00:02:02.850 --> 00:02:08.180
Get client In this function at a new concept variable called

29
00:02:08.180 --> 00:02:12.040
Marshall options with two Ls and Marshall.

30
00:02:12.040 --> 00:02:16.970
This will be an object with one property which is convert class

31
00:02:16.970 --> 00:02:21.840
instance to map set the value for this to be true.

32
00:02:21.840 --> 00:02:25.400
This will make sure that any objects passed into our put

33
00:02:25.400 --> 00:02:28.690
commands will be marshaled into a dynamo.

34
00:02:28.690 --> 00:02:31.040
DB JSON map.

35
00:02:31.040 --> 00:02:36.180
Now create a new concept variable under that named client assigned to it.

36
00:02:36.180 --> 00:02:42.180
A new instance of the dynamodb client constructor in this

37
00:02:42.180 --> 00:02:47.010
constructor call pass in an object with the property region and the

38
00:02:47.010 --> 00:02:50.840
value of the region ID that you're working in.

39
00:02:50.840 --> 00:02:55.790
So this is the bare bones client that is being created.

40
00:02:55.790 --> 00:03:02.370
So now we want to convert that to a document client so add the return key words.

41
00:03:02.370 --> 00:03:07.260
Since we'll be passing this back to the collar and then call dynamo db

42
00:03:07.260 --> 00:03:14.030
document client dot from pass in the client variable first and then an

43
00:03:14.030 --> 00:03:19.040
object second and inside that object inside those curly races just

44
00:03:19.040 --> 00:03:22.940
reference the marshal options variable.

45
00:03:22.940 --> 00:03:27.860
Now this function can be used to get a fully configured dynamodb

46
00:03:27.860 --> 00:03:32.000
document client and we don't have to write all of that code several

47
00:03:32.000 --> 00:03:34.640
different times in the different functions.

48
00:03:34.640 --> 00:03:37.600
Now let's go ahead and create our operation functions

49
00:03:37.600 --> 00:03:40.500
will start with the put item function.

50
00:03:40.500 --> 00:03:44.390
It will be an async function that takes two arguments.

51
00:03:44.390 --> 00:03:48.030
A table and the item first,

52
00:03:48.030 --> 00:03:53.640
declare a programs const variable and assigned to it an object.

53
00:03:53.640 --> 00:03:57.710
We're gonna add two properties here, one with the key table,

54
00:03:57.710 --> 00:03:59.330
name, that's what the upper case.

55
00:03:59.330 --> 00:04:06.140
T and uppercase in and value as our table function argument.

56
00:04:06.140 --> 00:04:11.850
The other property will be item for case I and set its property to

57
00:04:11.850 --> 00:04:15.750
the item function argument after the prams object.

58
00:04:15.750 --> 00:04:19.690
We can get our client by declaring a Const with the identify your

59
00:04:19.690 --> 00:04:24.850
client and assigned to it a function call of get client.

60
00:04:24.850 --> 00:04:26.940
Isn't that pretty easy.

61
00:04:26.940 --> 00:04:30.050
Next declared const named command assigned to it.

62
00:04:30.050 --> 00:04:34.580
A new constructor call of put command passing in the prams

63
00:04:34.580 --> 00:04:40.560
object finally return a call of the client dot send

64
00:04:40.560 --> 00:04:43.440
function passing in the command.

65
00:04:43.440 --> 00:04:46.840
Now the put item function is complete.

66
00:04:46.840 --> 00:04:51.790
Next up is he get all items function which will be async and

67
00:04:51.790 --> 00:04:55.850
it only needs a table argument since it's going to retrieve

68
00:04:55.850 --> 00:04:58.440
all items from a given table.

69
00:04:58.440 --> 00:05:03.530
The prams object will declare here will be very simple with just a table

70
00:05:03.530 --> 00:05:08.840
name property with the value as the table argument that was passed in

71
00:05:08.840 --> 00:05:13.070
after that declare contents with the identify your client and assigned to

72
00:05:13.070 --> 00:05:15.740
it a function call of get client.

73
00:05:15.740 --> 00:05:21.020
Then you can declare a const named command to get all items and a table.

74
00:05:21.020 --> 00:05:24.320
We're going to use a scan operation,

75
00:05:24.320 --> 00:05:29.040
scan pulls all items from a dynamodb table in random order.

76
00:05:29.040 --> 00:05:35.220
However, scans do have limits and will only pull one megabyte of data at a time.

77
00:05:35.220 --> 00:05:36.920
If your table has more than that,

78
00:05:36.920 --> 00:05:40.020
you will need to recursive lee call that scan

79
00:05:40.020 --> 00:05:43.550
operation and you pass a start index.

80
00:05:43.550 --> 00:05:48.000
So you can kind of paginated through the items in your table.

81
00:05:48.000 --> 00:05:48.940
We're not going to do that.

82
00:05:48.940 --> 00:05:53.920
We will use a naive implementation here and just call it once

83
00:05:53.920 --> 00:05:58.040
assuming our tables are going to be smaller than one megabyte

84
00:05:58.040 --> 00:06:01.370
assigned to the command variable, a new constructor,

85
00:06:01.370 --> 00:06:05.940
call of scan command, passing in the prams object,

86
00:06:05.940 --> 00:06:10.100
then create another new const variable named response.

87
00:06:10.100 --> 00:06:17.140
We do need to actually parse the response from dynamodb before we return it,

88
00:06:17.140 --> 00:06:22.940
add the await keyword and then a call to client dot send passing in the command.

89
00:06:22.940 --> 00:06:27.900
Then in the next line you can return the response dot items.

90
00:06:27.900 --> 00:06:32.070
Property, this is an array of the items from the scan operation,

91
00:06:32.070 --> 00:06:35.140
the items from your table and that's it.

92
00:06:35.140 --> 00:06:36.740
Forget all items.

93
00:06:36.740 --> 00:06:40.540
Now let's implement the get item function which will also be a sink.

94
00:06:40.540 --> 00:06:47.440
It will take a table argument, an id key argument and an id argument.

95
00:06:47.440 --> 00:06:51.560
We'll be using a primary key to query for an item but we need

96
00:06:51.560 --> 00:06:54.850
to also know the name of that primary key.

97
00:06:54.850 --> 00:06:56.110
Hence both I.

98
00:06:56.110 --> 00:06:56.550
D.

99
00:06:56.550 --> 00:06:57.550
And I.

100
00:06:57.550 --> 00:06:57.780
D.

101
00:06:57.780 --> 00:06:59.540
Key arguments.

102
00:06:59.540 --> 00:07:02.430
Next create a programs object with a table name,

103
00:07:02.430 --> 00:07:05.540
property and table as the value.

104
00:07:05.540 --> 00:07:10.840
Then also create a key argument with an object, literal as the value.

105
00:07:10.840 --> 00:07:13.990
The single property in this object will need to have

106
00:07:13.990 --> 00:07:16.420
the key of the IDE key argument.

107
00:07:16.420 --> 00:07:20.810
So you'll add square brackets on the left side and put the I.

108
00:07:20.810 --> 00:07:21.080
D.

109
00:07:21.080 --> 00:07:23.540
Key variable inside of them.

110
00:07:23.540 --> 00:07:26.650
Then for the value of that on the right side of the colon.

111
00:07:26.650 --> 00:07:32.700
Enter IDE now we get to do our client command dance one last time.

112
00:07:32.700 --> 00:07:37.190
So under that create a new concept titled client and

113
00:07:37.190 --> 00:07:40.140
assigned to it a call to get client,

114
00:07:40.140 --> 00:07:43.800
then you can create a new const titled command and

115
00:07:43.800 --> 00:07:48.390
assigned to it a new constructor call of get command and

116
00:07:48.390 --> 00:07:51.140
pass the prams variable into that.

117
00:07:51.140 --> 00:07:53.830
We need to modify this response to.

118
00:07:53.830 --> 00:08:00.270
So next create a new concept called response and then the await keyword and

119
00:08:00.270 --> 00:08:05.340
then a call to client dot send passing in the command.

120
00:08:05.340 --> 00:08:12.740
Finally you can return response dot item and now get item is complete.

121
00:08:12.740 --> 00:08:17.390
Finally we need to export these functions so set an object

122
00:08:17.390 --> 00:08:22.740
literal to module dot exports and add all the function identify

123
00:08:22.740 --> 00:08:25.380
IRS from above whichever order you prefer.

124
00:08:25.380 --> 00:08:27.460
You don't need to include get client.

125
00:08:27.460 --> 00:08:29.760
Now that are dynamos store is set up,

126
00:08:29.760 --> 00:08:33.940
we need to use it in the toppings and the users modules just

127
00:08:33.940 --> 00:08:37.950
like the last clip will mostly be uncommenting and commenting

128
00:08:37.950 --> 00:08:43.360
code here that doesn't relate to the AWS SDK so should be pretty

129
00:08:43.360 --> 00:08:45.340
quick in the data folder.

130
00:08:45.340 --> 00:08:47.740
Open toppings dot Js.

131
00:08:47.740 --> 00:08:48.850
The toppings modules.

132
00:08:48.850 --> 00:08:52.360
Pretty minimal if you look past the senate function,

133
00:08:52.360 --> 00:08:57.550
it only really has two other functions create and get all all the

134
00:08:57.550 --> 00:09:01.900
toppings are stored in this toppings hash you know just another

135
00:09:01.900 --> 00:09:07.620
makeshift database So let's start by uncommenting line for so the dynamo

136
00:09:07.620 --> 00:09:12.370
store file that we created will be imported then for the get all

137
00:09:12.370 --> 00:09:17.950
function comment line 20 for an uncommenting line 25 so that we'll be

138
00:09:17.950 --> 00:09:20.740
getting the toppings from dynamo.

139
00:09:20.740 --> 00:09:25.760
Then in the create function comment line 33 uncommenting line 34.

140
00:09:25.760 --> 00:09:31.140
So we're putting the item into dynamo and those are all the changes

141
00:09:31.140 --> 00:09:35.840
for this file Now open up the users dot Js file,

142
00:09:35.840 --> 00:09:41.640
We'll start by uncommenting line 5 to bring in the dynamo store module

143
00:09:41.640 --> 00:09:47.450
then and our user create function comment line 17 and uncommenting line

144
00:09:47.450 --> 00:09:53.410
18 so that the users are being put into dynamo dB then in our get

145
00:09:53.410 --> 00:09:59.160
function comment line 23 uncommenting line 24 so that we're fetching the

146
00:09:59.160 --> 00:10:02.910
user out of dynamo and that's it.

147
00:10:02.910 --> 00:10:05.590
Now we're ready to try it all out.

148
00:10:05.590 --> 00:10:08.650
Head over to your console and run in P M.

149
00:10:08.650 --> 00:10:12.740
Start next let's take a look at our dynamodb tables

150
00:10:12.740 --> 00:10:14.970
in the AWS management console.

151
00:10:14.970 --> 00:10:18.480
If we go to the items, viewer and the toppings table,

152
00:10:18.480 --> 00:10:22.520
you'll see that the toppings items have been put in the table.

153
00:10:22.520 --> 00:10:28.840
The users table will also have the mock users inserted into them as well.

154
00:10:28.840 --> 00:10:31.360
Now that our data is in databases,

155
00:10:31.360 --> 00:10:35.580
we don't need to populate it every time the app starts up In

156
00:10:35.580 --> 00:10:39.830
the plugins.js file in the util folder, you can comment,

157
00:10:39.830 --> 00:10:45.640
outline 80 to avoid populating the data every time the app starts.

158
00:10:45.640 --> 00:10:47.650
And although I won't demonstrate it here.

159
00:10:47.650 --> 00:10:50.780
If you push this code to run on your ec two instance,

160
00:10:50.780 --> 00:10:54.780
you will need to add policies to your Pizza Ec two role.

161
00:10:54.780 --> 00:10:55.640
Specifically.

162
00:10:55.640 --> 00:11:01.790
You want to add the amazon RDS full access and amazon Dynamodb full

163
00:11:01.790 --> 00:11:05.760
access policies to access all the databases we created.

164
00:11:05.760 --> 00:11:06.910
In addition,

165
00:11:06.910 --> 00:11:17.000
you'll need to modify the security group of the RDS instance to allow access from the Pizza EC two S G Security Group.

