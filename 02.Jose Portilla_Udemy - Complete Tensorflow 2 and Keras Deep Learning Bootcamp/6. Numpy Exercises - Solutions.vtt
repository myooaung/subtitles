WEBVTT
1
00:00:05.390 --> 00:00:06.420
Welcome back everyone.

2
00:00:06.500 --> 00:00:10.300
In this lecture we're going to go over the solutions for the name pie exercises.

3
00:00:10.310 --> 00:00:12.500
Let's head over to the exercise notebook and get started.

4
00:00:13.140 --> 00:00:18.770
OK the first thing you had to do was import none pi as MP and then we were asked to create an array

5
00:00:18.800 --> 00:00:20.000
of zeros.

6
00:00:20.000 --> 00:00:24.230
Keep in mind there's probably multiple solutions for each of these questions but in general we'll try

7
00:00:24.230 --> 00:00:30.920
to do the simplest ones so and P zeros we want 10 of them we just as you say and P zeros 10 same thing

8
00:00:30.920 --> 00:00:34.420
for once we just say and P that ones and then pass and 10.

9
00:00:34.550 --> 00:00:37.270
So here we see the 10 ones for fives.

10
00:00:37.280 --> 00:00:39.150
There's lots of different ways you can do this.

11
00:00:39.260 --> 00:00:48.370
You can either say end p ones 10 and then add four to it or multiply it by five.

12
00:00:48.390 --> 00:00:50.330
So lots of different ways to do this.

13
00:00:50.700 --> 00:00:53.810
Create an array of integers from 10 to 50.

14
00:00:54.060 --> 00:00:55.980
So again different ways you can do this.

15
00:00:55.980 --> 00:01:02.920
One way is to simply use MP range and then go from 10 all the way up to but not including 50 one and

16
00:01:02.920 --> 00:01:09.240
that will get you 10 for 50 all the integers they're 6 was to create an array of all the even integers

17
00:01:09.240 --> 00:01:10.590
from 10 to 50.

18
00:01:10.590 --> 00:01:15.320
Same approach except this time we'll add in the step size of two.

19
00:01:15.480 --> 00:01:17.230
And here we can see that even numbers.

20
00:01:17.520 --> 00:01:22.000
Next we wanted to create a three by three matrix of values ranging from 0 to 8.

21
00:01:22.140 --> 00:01:23.580
So different ways we can do this.

22
00:01:23.580 --> 00:01:29.450
One way is to first say and arrange nine and that'll get thus the actual values and then we can call

23
00:01:29.490 --> 00:01:33.110
reshape off of this as a three by three.

24
00:01:33.120 --> 00:01:34.980
And then we have 0 through 8.

25
00:01:35.130 --> 00:01:40.180
So you can actually stack these sort of method calls or if you want you can use assignment as well she

26
00:01:40.200 --> 00:01:44.380
could say something like arrays equal to N.P. arrange and then reshape like this.

27
00:01:44.460 --> 00:01:45.260
And that's the same thing.

28
00:01:45.310 --> 00:01:48.000
You can either stack them or have them in multiple steps.

29
00:01:48.000 --> 00:01:49.530
It's really up to you.

30
00:01:49.880 --> 00:01:56.340
Now we wanted to create a three by three identity matrix that's just gonna be NPI with a three and the

31
00:01:56.340 --> 00:02:00.320
next one was to use an umpire to generate a random number between 0 and 1.

32
00:02:00.450 --> 00:02:08.010
For that we simply use NDP thought random thought random passing one and there's our random number.

33
00:02:08.190 --> 00:02:13.700
Next we wanted to use an umpire to generate 25 random numbers sample from a standard normal distribution.

34
00:02:13.770 --> 00:02:21.650
Remember that's going to be any random dot Rand and twenty five for twenty five nos for this one wanted

35
00:02:21.660 --> 00:02:23.060
to create this following matrix.

36
00:02:23.060 --> 00:02:28.010
So it's a little tricky but basically you have to realize that we're going from zero point zero one

37
00:02:28.010 --> 00:02:30.590
to zero point zero two to zero point zero three.

38
00:02:30.650 --> 00:02:35.660
So it looks like our step size is Point Zero 1 and there's actually lots of different ways you can do

39
00:02:35.660 --> 00:02:44.210
this but one kind of clever way to do this is by saying NPR range from 1 to 1 to 1 and if you do this

40
00:02:44.240 --> 00:02:50.060
you'll notice you now have the same values one two three four etc. except we're just off by two decimal

41
00:02:50.060 --> 00:02:50.970
places.

42
00:02:51.020 --> 00:02:57.170
So then we could say divide this by one hundred and now we have the correct values except notice the

43
00:02:57.170 --> 00:02:58.100
shape here.

44
00:02:58.100 --> 00:03:02.540
This is just a single array so we can see there's one square bracket but it looks like we need this

45
00:03:02.600 --> 00:03:03.790
in two dimensions.

46
00:03:03.860 --> 00:03:13.610
So I'm going to assign this as an array and then I will reshape this to be a 10 by 10 and now we have

47
00:03:13.670 --> 00:03:14.790
the same array.

48
00:03:14.990 --> 00:03:20.810
And if you want you can do this all in one step as well as shown in the solutions notebook.

49
00:03:20.840 --> 00:03:25.970
Next we wanted to create an array of 20 linearly spaced points between 0 and 1 for this.

50
00:03:25.970 --> 00:03:33.840
Basically just call in space go from 0 to 1 and ask for 20 points linearly spaced after that we had

51
00:03:33.840 --> 00:03:36.180
num pi indexing and selection.

52
00:03:36.180 --> 00:03:37.300
So we run the cell.

53
00:03:37.310 --> 00:03:38.650
So this is our starting matrix.

54
00:03:38.670 --> 00:03:39.510
So we go ahead and run that.

55
00:03:39.570 --> 00:03:44.960
So now we've defined this matrix and X is the write code that reproduces the output shown below.

56
00:03:44.970 --> 00:03:49.830
So if we take a look here we want to grab twelve thirteen fourteen fifteen so looks we want to grab

57
00:03:49.830 --> 00:03:52.950
this chunk for these three rows.

58
00:03:52.950 --> 00:03:54.360
So how do we do this.

59
00:03:54.360 --> 00:04:01.020
We simply say the matrix object and for the first one we're gonna start at row two and then go all the

60
00:04:01.020 --> 00:04:05.550
way to the end so here I can see I have those last three rows.

61
00:04:05.550 --> 00:04:11.220
Then for the columns what I want to do is start a column one colon and then go all the way to the end

62
00:04:11.220 --> 00:04:12.150
that way.

63
00:04:12.150 --> 00:04:18.710
So that now gives me that same block of that name pyrite next was to write code that produces the output

64
00:04:18.710 --> 00:04:21.050
shown below which is just a single 20 for this.

65
00:04:21.050 --> 00:04:25.790
We simply had to call the index location which is at row three column four.

66
00:04:25.880 --> 00:04:32.510
You get 20 and then finally this one's a little trickier but the right code that reproduces to 712.

67
00:04:32.650 --> 00:04:37.670
We take a look at our original Matrix 2 7 is right here to 7 12.

68
00:04:37.960 --> 00:04:39.630
So we apply the same logic.

69
00:04:39.850 --> 00:04:43.910
We're gonna grab all the rows starting at the beginning all the way up to row 3.

70
00:04:44.500 --> 00:04:49.060
So we take a look at that we have the rows that contain 2 7 12 and then we actually just want a single

71
00:04:49.060 --> 00:04:56.100
column which you can grab as a slice from one colon all the way up to be including two.

72
00:04:56.110 --> 00:04:57.760
So that's just gonna be one.

73
00:04:57.760 --> 00:05:01.990
If you were to only provide one like this that would actually give you the values.

74
00:05:01.990 --> 00:05:07.720
However it wouldn't give it to you in the same shape so you'd have to use slicing if you wanted to retain

75
00:05:07.750 --> 00:05:11.780
that original two dimensional shape next.

76
00:05:11.960 --> 00:05:14.260
Want to write code that reproduces the output shown below here.

77
00:05:14.260 --> 00:05:16.570
21 22 23 24.

78
00:05:16.600 --> 00:05:21.460
That's simply Matt for so row for all the columns.

79
00:05:21.460 --> 00:05:22.340
That's the same thing.

80
00:05:22.540 --> 00:05:27.220
And you could also just said if we write Matt for here this is the same values.

81
00:05:27.220 --> 00:05:28.450
So up to you which way you want it.

82
00:05:28.470 --> 00:05:32.050
Jus next to write code that reproduces this below.

83
00:05:32.050 --> 00:05:36.470
Very similar thing we say from rows three or five.

84
00:05:36.650 --> 00:05:40.940
Give me all the columns or you could've said rows three to five.

85
00:05:40.940 --> 00:05:43.470
This way is the same thing either way.

86
00:05:43.650 --> 00:05:44.440
Okay.

87
00:05:44.450 --> 00:05:48.330
Finally we have some number of operations which is the get the sum of all the values in Matt.

88
00:05:48.350 --> 00:05:53.900
So that's simply going to be Matt some thirty twenty five to get the standard deviation.

89
00:05:53.900 --> 00:05:59.950
And for this you had to check the notebook it was referenced there but it's going to be SD 4 standard

90
00:05:59.950 --> 00:06:00.840
deviation.

91
00:06:00.880 --> 00:06:05.990
Again we mentioned that there's a link there for all the universal array functions that exist for another

92
00:06:06.010 --> 00:06:13.030
pie and then to get the sum of all the columns in Matt we simply had to say Matt some access equal to

93
00:06:13.030 --> 00:06:17.070
zero and then finally for the bonus question.

94
00:06:17.110 --> 00:06:18.830
So we worked a lot of random data num pi.

95
00:06:18.850 --> 00:06:21.430
Is there a way we can always ensure we get the same ran the numbers.

96
00:06:21.520 --> 00:06:25.450
You can click here for hints but we also mentioned this during the lecture and that's simply to say

97
00:06:25.520 --> 00:06:31.000
NDP thought random that scene and then pass in some arbitrary number choice.

98
00:06:31.300 --> 00:06:36.490
And then if you're following along with me and you ask for some random number it should give you this

99
00:06:36.490 --> 00:06:37.270
exact number.

100
00:06:37.270 --> 00:06:39.360
If you run these both in the same cell as I did.

101
00:06:40.070 --> 00:06:46.420
Okay that's it for the NUM pi exercises don't worry too much if you weren't able to get all the indexing

102
00:06:46.450 --> 00:06:49.480
and selection exercise for the two dimensional arrays.

103
00:06:49.480 --> 00:06:51.730
We won't be doing that too often throughout the course.

104
00:06:51.730 --> 00:06:57.310
Instead just focus on the concept of being able to take slices from one dimensional arrays since typically

105
00:06:57.310 --> 00:07:00.670
our time series data will just be a single one dimensional array.

106
00:07:00.670 --> 00:07:04.510
That's time stamped thanks and we'll see you at the next section of the course.
