WEBVTT
1
00:00:01.840 --> 00:00:02.940
[Autogenerated] Okay, welcome back.

2
00:00:02.940 --> 00:00:05.180
So let's pick up where we left off,

3
00:00:05.180 --> 00:00:09.050
and we're going to start looking at common scenarios with sqs.

4
00:00:09.050 --> 00:00:13.190
Now a very common scenario is using Lambda triggers.

5
00:00:13.190 --> 00:00:16.510
And what this means is that we can trigger one or more

6
00:00:16.510 --> 00:00:20.550
land of functions based on this sqs que So we're

7
00:00:20.550 --> 00:00:23.290
essentially making our lambda functions.

8
00:00:23.290 --> 00:00:28.520
The workers from that diagram and they're processing the messages now.

9
00:00:28.520 --> 00:00:32.380
I went ahead, Let me go to Lambda, and I created two functions here.

10
00:00:32.380 --> 00:00:35.450
I haven't sqs worker in an sqs center,

11
00:00:35.450 --> 00:00:39.440
so the center is just sending messages to our Q URL.

12
00:00:39.440 --> 00:00:44.030
And that brings me to another important point To send messages to a Q.

13
00:00:44.030 --> 00:00:47.840
You have to populate it with the Q u r l.

14
00:00:47.840 --> 00:00:49.490
So what I'll do is I'll copy this.

15
00:00:49.490 --> 00:00:55.070
Q URL I'll put it into our center as an environment variable because I'm

16
00:00:55.070 --> 00:01:02.790
pulling que URL from the environment variables and there we go.

17
00:01:02.790 --> 00:01:08.890
So now we're sending a message using the bow to three library to our Q URL,

18
00:01:08.890 --> 00:01:11.520
which is getting pulled from my environment variables,

19
00:01:11.520 --> 00:01:15.320
and we're just sending a simple message that says hello from Lambda.

20
00:01:15.320 --> 00:01:19.210
And the time is this so this should print the epoch

21
00:01:19.210 --> 00:01:21.580
time as well as hello from Lambda.

22
00:01:21.580 --> 00:01:23.890
So that way we can see different messages.

23
00:01:23.890 --> 00:01:25.260
So let me go ahead,

24
00:01:25.260 --> 00:01:30.190
and I want to go ahead and test this sqs center and you'll see

25
00:01:30.190 --> 00:01:33.440
that we have successfully sent a message.

26
00:01:33.440 --> 00:01:35.730
So now if I look at my Pluralsight.

27
00:01:35.730 --> 00:01:36.500
Q.

28
00:01:36.500 --> 00:01:44.540
We should see one message available, and we do so if I send this several times,

29
00:01:44.540 --> 00:01:47.880
we should eventually see that number of messages built up,

30
00:01:47.880 --> 00:01:48.980
and there they are.

31
00:01:48.980 --> 00:01:51.020
Now you'll notice they're just sitting there.

32
00:01:51.020 --> 00:01:53.940
So if I keep refreshing, they're not going anywhere.

33
00:01:53.940 --> 00:01:56.720
And that's because we don't have a worker that's

34
00:01:56.720 --> 00:01:59.080
pulling those messages off the queue.

35
00:01:59.080 --> 00:02:00.900
Now, for troubleshooting purposes,

36
00:02:00.900 --> 00:02:05.940
you can view and delete messages on the cues from the console

37
00:02:05.940 --> 00:02:08.940
you can see are message hello from Lambda and then the time

38
00:02:08.940 --> 00:02:11.520
stamp in that changes for each message.

39
00:02:11.520 --> 00:02:14.640
This way, we know we've sent different messages.

40
00:02:14.640 --> 00:02:16.640
I'm gonna go and stop polling,

41
00:02:16.640 --> 00:02:20.610
and that's gonna put the message is back on the queue for availability.

42
00:02:20.610 --> 00:02:24.300
Now what we can do just as an architectural example,

43
00:02:24.300 --> 00:02:28.820
is we can implement a land of function based on that sqs Q.

44
00:02:28.820 --> 00:02:31.050
So What I'll do is I'll add a trigger.

45
00:02:31.050 --> 00:02:34.530
And this is for my Lambda Sqs worker function.

46
00:02:34.530 --> 00:02:36.840
I'm selecting Sqs.

47
00:02:36.840 --> 00:02:40.420
We specify the arm, which is Pluralsight right,

48
00:02:40.420 --> 00:02:43.540
and then we can go ahead and look at the batch size.

49
00:02:43.540 --> 00:02:45.430
So what I can do here is I can Go,

50
00:02:45.430 --> 00:02:51.230
let's say five messages and this allows for less API calls like we were

51
00:02:51.230 --> 00:02:55.380
talking about two sqs so you can go down to one message.

52
00:02:55.380 --> 00:02:58.870
So you're processing each message individually or I can.

53
00:02:58.870 --> 00:03:02.930
Grab a batch of messages up to 10.

54
00:03:02.930 --> 00:03:05.700
So I'll go and grab five, and then we enable it.

55
00:03:05.700 --> 00:03:12.940
So if I click add, we've just added a lambda trigger to are Pluralsight sqs que.

56
00:03:12.940 --> 00:03:14.240
And there you go right there.

57
00:03:14.240 --> 00:03:16.800
So once this is done creating that trigger,

58
00:03:16.800 --> 00:03:20.980
what should happen is when we start sending messages on the Q,

59
00:03:20.980 --> 00:03:22.710
it's going to start pulling them off.

60
00:03:22.710 --> 00:03:26.540
So let me go and actually empty this Q.

61
00:03:26.540 --> 00:03:33.240
I'm going to go back to my sender and let me send 10 messages.

62
00:03:33.240 --> 00:03:36.040
Okay, so I've sent 10 messages.

63
00:03:36.040 --> 00:03:39.840
We refresh will see four there, so that means they're already processing.

64
00:03:39.840 --> 00:03:41.790
And there you go after refreshing we can.

65
00:03:41.790 --> 00:03:44.530
See that they're all gone now.

66
00:03:44.530 --> 00:03:46.480
Sometimes you'll see messages in flight,

67
00:03:46.480 --> 00:03:49.420
which means the number of messages that were received,

68
00:03:49.420 --> 00:03:51.440
but they're not deleted yet.

69
00:03:51.440 --> 00:03:56.090
But since this is so fast we saw available and then now they're gone.

70
00:03:56.090 --> 00:04:01.390
So if I go to my worker function and I go to my CloudWatch logs we're going to

71
00:04:01.390 --> 00:04:05.920
see are indications and we can see the JSON that I printed.

72
00:04:05.920 --> 00:04:09.020
So we have our records, and if I scroll through here,

73
00:04:09.020 --> 00:04:10.600
we're going to see are different messages.

74
00:04:10.600 --> 00:04:12.140
So here's one here,

75
00:04:12.140 --> 00:04:16.060
on another one here and then we'll see them all down through this.

76
00:04:16.060 --> 00:04:16.740
Now,

77
00:04:16.740 --> 00:04:21.780
what's neat about this is this is all one call right here so you

78
00:04:21.780 --> 00:04:24.740
can see our records start here for the event,

79
00:04:24.740 --> 00:04:27.440
and then we start having our messages in our message.

80
00:04:27.440 --> 00:04:28.040
IDE s.

81
00:04:28.040 --> 00:04:29.790
So there is one message.

82
00:04:29.790 --> 00:04:33.860
Here is a separate message and those error all in one call.

83
00:04:33.860 --> 00:04:37.920
So we have multiple messages received with one call Now,

84
00:04:37.920 --> 00:04:42.410
depending on how fast are functions can see scale out concurrently.

85
00:04:42.410 --> 00:04:44.940
That's going to drive the amount of calls that are made

86
00:04:44.940 --> 00:04:49.340
so you can see we have one receive, and then a couple two's up top.

87
00:04:49.340 --> 00:04:55.190
So that's how we can configure and sqs Q to decouple our architectures.

88
00:04:55.190 --> 00:04:58.790
It allows for resiliency and decoupling,

89
00:04:58.790 --> 00:05:03.030
which allows us to take a micro service approach for our applications.

90
00:05:03.030 --> 00:05:08.440
Now we're gonna move on to S N s, which is simple notification services.

91
00:05:08.440 --> 00:05:16.000
And after s and s, we're going to dive back in to sqs with some advanced architecture decisions.

