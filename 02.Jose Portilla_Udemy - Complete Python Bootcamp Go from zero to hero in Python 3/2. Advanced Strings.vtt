WEBVTT
1
1

00:00:01.923  -->  00:00:03.779
<v Narrator>Hello everyone and welcome</v>
2

2

00:00:03.779  -->  00:00:05.534
to the advanced strings lecture.
3

3

00:00:05.534  -->  00:00:08.036
So string objects have a variety of methods we can use
4

4

00:00:08.036  -->  00:00:10.174
to save time and add functionality.
5

5

00:00:10.174  -->  00:00:14.147
What we're gonna do is explore some of them in this lecture.
6

6

00:00:14.147  -->  00:00:18.314
So let's go ahead and create a string called hello world
7

7

00:00:20.576  -->  00:00:23.884
and let's explore some different methods we can use.
8

8

00:00:23.884  -->  00:00:26.429
So let's start with changing case.
9

9

00:00:26.429  -->  00:00:29.353
So we can change cases to upper and lower case
10

10

00:00:29.353  -->  00:00:32.174
and there's a couple methods we can use.
11

11

00:00:32.174  -->  00:00:34.693
One of them is the capitalise method
12

12

00:00:34.693  -->  00:00:37.040
and what the capitalise method does is it capitalises
13

13

00:00:37.040  -->  00:00:39.842
the first word in a string.
14

14

00:00:39.842  -->  00:00:42.478
We can also use the upper method which you may have seen
15

15

00:00:42.478  -->  00:00:45.514
before to uppercase every letter in a string,
16

16

00:00:45.514  -->  00:00:47.941
and then we can also use the lower
17

17

00:00:47.941  -->  00:00:51.108
to lowercase every letter in a string.
18

18

00:00:52.955  -->  00:00:55.294
There's also location and counting methods.
19

19

00:00:55.294  -->  00:00:59.253
So if I wanted to for instance count how many O's
20

20

00:00:59.253  -->  00:01:02.744
there are in a string I can use the count method,
21

21

00:01:02.744  -->  00:01:05.321
and I can also find them.
22

22

00:01:05.321  -->  00:01:08.556
So I can say find the first occurrence of an O,
23

23

00:01:08.556  -->  00:01:11.661
and I'll return the index where that happens.
24

24

00:01:11.661  -->  00:01:14.246
Well there's also formatting methods
25

25

00:01:14.246  -->  00:01:17.508
and these are a little strange and they're also not used
26

26

00:01:17.508  -->  00:01:19.519
that often, but it still might be good
27

27

00:01:19.519  -->  00:01:22.162
to know them in case you ever run into them.
28

28

00:01:22.162  -->  00:01:25.122
The first one we're gonna talk about is the centre method.
29

29

00:01:25.122  -->  00:01:26.705
So let's go ahead and check our string.
30

30

00:01:26.705  -->  00:01:28.661
It's still just hello world, since we lowercased it again,
31

31

00:01:28.661  -->  00:01:32.257
and what the centre method does is it allows you
32

32

00:01:32.257  -->  00:01:34.846
to place your string centred between
33

33

00:01:34.846  -->  00:01:37.484
a provided string of a certain length.
34

34

00:01:37.484  -->  00:01:40.280
So these are pretty esoteric and I've actually never seen
35

35

00:01:40.280  -->  00:01:43.920
this used in code but it's still a method you can use.
36

36

00:01:43.920  -->  00:01:48.087
So for instance let's say you wanted to centre your string
37

37

00:01:50.582  -->  00:01:54.952
hello world between a bunch of Z's and you wanted
38

38

00:01:54.952  -->  00:01:58.194
the total length of that string to be 20.
39

39

00:01:58.194  -->  00:02:01.719
Then this is what it would look like.
40

40

00:02:01.719  -->  00:02:05.526
So we centred hello world between Z's
41

41

00:02:05.526  -->  00:02:09.693
and the total length of the string is 20.
42

42

00:02:09.693  -->  00:02:12.916
Okay, there may not be too many use cases for that
43

43

00:02:12.916  -->  00:02:16.403
and I've personally actually I've never used it.
44

44

00:02:16.403  -->  00:02:19.326
Another this method that we may or may not use
45

45

00:02:19.326  -->  00:02:21.963
is the expand tabs method.
46

46

00:02:21.963  -->  00:02:26.130
So for instance if I say hello T and that will break it
47

47

00:02:30.396  -->  00:02:35.333
to a tab, woops, let me make sure that it's working.
48

48

00:02:35.333  -->  00:02:38.500
So this back slash T when you print it
49

49

00:02:40.604  -->  00:02:44.157
it will be an escape character for a tab.
50

50

00:02:44.157  -->  00:02:47.053
So it will actually hello tab hi.
51

51

00:02:47.053  -->  00:02:49.091
So this is gonna be useful if you ever find yourself
52

52

00:02:49.091  -->  00:02:51.893
parsing through all that text data,
53

53

00:02:51.893  -->  00:02:54.451
and instead of having to print it what you can
54

54

00:02:54.451  -->  00:02:58.451
actually do is just call the expand tabs method,
55

55

00:03:00.809  -->  00:03:02.508
and it will do the same thing.
56

56

00:03:02.508  -->  00:03:05.158
Again, not used that often.
57

57

00:03:05.158  -->  00:03:07.480
Let's go ahead and check out some other methods
58

58

00:03:07.480  -->  00:03:10.582
that check if the string is some sort of case.
59

59

00:03:10.582  -->  00:03:14.749
So for instance I'm going to set a string just called hello
60

60

00:03:15.927  -->  00:03:18.844
and there's a method called isalnum
61

61

00:03:21.650  -->  00:03:25.417
and this checks if all the characters in S are alphanumeric,
62

62

00:03:25.417  -->  00:03:29.112
and in this case it's true, and what we can also do
63

63

00:03:29.112  -->  00:03:31.837
is just check if they're all alphabetic.
64

64

00:03:31.837  -->  00:03:34.564
So numeric doesn't count anymore.
65

65

00:03:34.564  -->  00:03:38.965
So we can just check is alpha and that's also true.
66

66

00:03:38.965  -->  00:03:41.760
These are actually quite useful and I have seen them used
67

67

00:03:41.760  -->  00:03:44.957
a lot, especially if you find yourself doing some sort
68

68

00:03:44.957  -->  00:03:48.053
of natural language processing techniques.
69

69

00:03:48.053  -->  00:03:51.529
Another couple of ways, or a couple methods we can use is
70

70

00:03:51.529  -->  00:03:56.144
is lower and this will return true if all case characters
71

71

00:03:56.144  -->  00:03:59.606
in S are lowercase, and if there's
72

72

00:03:59.606  -->  00:04:02.356
at least one case character in S.
73

73

00:04:04.071  -->  00:04:08.428
We can also check is space and it'll return true
74

74

00:04:08.428  -->  00:04:10.838
if all characters in S are white space.
75

75

00:04:10.838  -->  00:04:15.005
In this case that's not the case, so it should return false.
76

76

00:04:15.939  -->  00:04:18.576
So is space which will return true if all characters
77

77

00:04:18.576  -->  00:04:19.994
and that's our white space.
78

78

00:04:19.994  -->  00:04:22.969
It's false since we have letters in there.
79

79

00:04:22.969  -->  00:04:25.552
Another method called is title.
80

80

00:04:26.480  -->  00:04:30.639
So we can check is title and what that does,
81

81

00:04:30.639  -->  00:04:32.627
it's gonna, it'll only return true
82

82

00:04:32.627  -->  00:04:34.862
if S is a title case string,
83

83

00:04:34.862  -->  00:04:37.447
and there's at least one character in this.
84

84

00:04:37.447  -->  00:04:40.829
So uppercase characters may only be, may only follow uncased
85

85

00:04:40.829  -->  00:04:44.996
characters and lowercase characters only follow cased ones.
86

86

00:04:46.451  -->  00:04:50.730
Another method is upper, and that will return true
87

87

00:04:50.730  -->  00:04:53.310
if all the cased characters in this are uppercase.
88

88

00:04:53.310  -->  00:04:54.393
So, is upper.
89

89

00:04:58.364  -->  00:04:59.990
This case, it's false.
90

90

00:04:59.990  -->  00:05:04.639
But if I were to say let's say hello all uppercase
91

91

00:05:04.639  -->  00:05:09.011
and then I asked is upper on that, then that is true.
92

92

00:05:09.011  -->  00:05:09.908
All right.
93

93

00:05:09.908  -->  00:05:13.961
One last method for checking cases is ends with.
94

94

00:05:13.961  -->  00:05:16.862
So I could check S that ends with
95

95

00:05:16.862  -->  00:05:21.057
and let's say I wanted to verify that it ends with O.
96

96

00:05:21.057  -->  00:05:22.642
Yeah, and this is basically the same
97

97

00:05:22.642  -->  00:05:25.077
thing as just doing this, right?
98

98

00:05:25.077  -->  00:05:27.660
Checking if that last character
99

99

00:05:28.746  -->  00:05:31.496
in the string is equal to something.
100

100

00:05:31.496  -->  00:05:33.474
That's, and it returns a Boolean.
101

101

00:05:33.474  -->  00:05:36.351
Okay, so now we're gonna move on to some built
102

102

00:05:36.351  -->  00:05:39.504
in regular expression operations.
103

103

00:05:39.504  -->  00:05:42.316
So strings have some built in methods that can resemble
104

104

00:05:42.316  -->  00:05:44.822
full on regular expressions operations,
105

105

00:05:44.822  -->  00:05:47.897
and one of them that's really commonly used is split,
106

106

00:05:47.897  -->  00:05:49.808
and we can use split to split the string
107

107

00:05:49.808  -->  00:05:53.974
of a certain element and return a list of the results.
108

108

00:05:53.974  -->  00:05:57.177
So let's check our string, which is hello,
109

109

00:05:57.177  -->  00:06:01.260
and let's say we wanted to split the string at E.
110

110

00:06:02.198  -->  00:06:06.670
Then split will return the result in a list,
111

111

00:06:06.670  -->  00:06:10.469
so everything before that E, and then everything after it,
112

112

00:06:10.469  -->  00:06:14.636
and remember, it only separates at the first occurrence.
113

113

00:06:15.941  -->  00:06:19.764
Excuse me, it'll actually separate at every occurrence of E.
114

114

00:06:19.764  -->  00:06:22.447
So just to make that clear I'll show you an example.
115

115

00:06:22.447  -->  00:06:26.011
So if I have a string that's, looks something like this,
116

116

00:06:26.011  -->  00:06:29.678
I could say split at I and it'll split it up
117

117

00:06:33.346  -->  00:06:35.306
at every instance of that I.
118

118

00:06:35.306  -->  00:06:38.763
Okay, there's also partition, which is pretty similar
119

119

00:06:38.763  -->  00:06:42.763
to split but in this case what partition does is
120

120

00:06:44.898  -->  00:06:47.265
it will have the head, the sep, and the tail.
121

121

00:06:47.265  -->  00:06:50.564
So what I'll do is it will search for the separator
122

122

00:06:50.564  -->  00:06:54.091
which ever you feed it in the arguments and S that string
123

123

00:06:54.091  -->  00:06:57.378
and return the part before it, the separator itself
124

124

00:06:57.378  -->  00:07:00.005
and the part after it, and then if the separator
125

125

00:07:00.005  -->  00:07:03.552
is not found it returns S and two empty strings.
126

126

00:07:03.552  -->  00:07:07.955
So, for instance if I said partition of I here
127

127

00:07:07.955  -->  00:07:12.033
this one is at the first instance, instance of I,
128

128

00:07:12.033  -->  00:07:14.120
or whatever separator you put in.
129

129

00:07:14.120  -->  00:07:16.420
So it'll give you the first part, the separator,
130

130

00:07:16.420  -->  00:07:18.908
and then everything else that happened after it.
131

131

00:07:18.908  -->  00:07:21.825
So unlike split which splits at every instance,
132

132

00:07:21.825  -->  00:07:24.471
partition will only do it at the first instance,
133

133

00:07:24.471  -->  00:07:27.815
and it will also return the separator in the middle.
134

134

00:07:27.815  -->  00:07:30.820
So the front, separator, and the back.
135

135

00:07:30.820  -->  00:07:35.633
Okay, so that's it as far as the lecture on strings.
136

136

00:07:35.633  -->  00:07:39.461
Let's just go ahead and do a quick review.
137

137

00:07:39.461  -->  00:07:42.307
A lot of these were Boolean checks so I know
138

138

00:07:42.307  -->  00:07:44.527
that was kind of hard to keep track of.
139

139

00:07:44.527  -->  00:07:46.475
It's probably better just to read it along in the Jupyter
140

140

00:07:46.475  -->  00:07:49.266
notebooks, but we went over methods for changing case,
141

141

00:07:49.266  -->  00:07:51.505
such as capitalise, upper, and lower.
142

142

00:07:51.505  -->  00:07:54.698
We looked at location and counting such as counts and finds.
143

143

00:07:54.698  -->  00:07:57.514
We looked at a few esoteric formatting ones,
144

144

00:07:57.514  -->  00:08:00.800
such as centre, also expand tabs,
145

145

00:08:00.800  -->  00:08:03.475
and then is check methods so that all of the tonnes
146

146

00:08:03.475  -->  00:08:05.892
of methods to check if the string is in some case,
147

147

00:08:05.892  -->  00:08:09.196
such as isalnum, is alpha, is lower, is space,
148

148

00:08:09.196  -->  00:08:11.623
is title, is upper, and ends with.
149

149

00:08:11.623  -->  00:08:14.014
And then we looked at some built in regular expressions,
150

150

00:08:14.014  -->  00:08:16.200
such as splits and partitions.
151

151

00:08:16.200  -->  00:08:18.541
Okay, so you should feel comfortable using the variety
152

152

00:08:18.541  -->  00:08:20.716
of methods that are built into string objects
153

153

00:08:20.716  -->  00:08:23.311
and you should definitely feel comfortable if you run
154

154

00:08:23.311  -->  00:08:25.527
into them when you're reading someone else's code.
155

155

00:08:25.527  -->  00:08:27.927
All right, that's it for the advanced strings lecture.
156

156

00:08:27.927  -->  00:08:30.160
Thanks, I'll see you at the next one.
